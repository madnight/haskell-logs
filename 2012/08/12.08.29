00:00:29 <johnw> hmm, I started my parsec parser on a 10Gb input file back when you first started asking your questions, spark_
00:00:31 <johnw> it's still not done
00:00:35 <visof> Cale how go from 1960 also maybe its old and better
00:00:43 <johnw> using 13.95G of memory so far
00:00:45 <Cale> Haskell doesn't just ignore the last 40 or 50 years of programming language research.
00:00:49 <johnw> and 1h17m43s CPU time
00:01:05 <johnw> in that time, I've rewritten the code to use Attoparsec, let's see if it helps
00:02:49 <startling> Cale: it does get the whole "classes kind of suck" thing
00:03:48 <thirsteh> visof: http://commandcenter.blogspot.se/2012/06/less-is-exponentially-more.html
00:04:18 <thirsteh> Cale: Communicating Sequential Processes was published in 1978 :)
00:05:14 <Cale> thirsteh: Okay, okay, there are a few bits where it adds on a decade or so. It still has a fairly large gap to make up for.
00:05:29 <thirsteh> visof: you can't compare Go and Haskell. Go is a simple language that makes big projects less painful (easier to collaborate, very quick compilation speeds even with thousands of files), Haskell is a language that lets you do, and express, basically everything
00:06:01 <visof> Ken and rob pike are old fashioned programmers
00:06:24 <thirsteh> that rant by Rob explains the thinking behind Go
00:06:32 <thirsteh> if you're looking for PL innovation, you will be disappointed
00:06:36 <thirsteh> Go has not a single new concept
00:07:09 <visof> How can be ruby relative to haskell?
00:07:09 <spark_> johnw: lol
00:07:16 <thirsteh> it is very easy to learn, very easy to work with people who aren't "rockstar programmers" with, and it is compiled and statically typed but compiles and runs as quickly as a "dynamic language"
00:07:20 <spark_> johnw: well at least it didnt crashed
00:07:26 <Cale> visof: Why not just learn all these languages and find out for yourself?
00:08:14 <edwardk> donri: i try to confine myself to one rant on here every couple of weeks, thats what logs are for ;)
00:08:24 <donri> =)
00:08:34 <thirsteh> it was earlier today we had this discussion, was it not?
00:08:35 <startling> edwardk: so do you like it or not?
00:08:36 <spark_> johnw:  I did something wrong with the many1, im getting undefined
00:08:47 <thirsteh> or maybe yesterday
00:08:58 <edwardk> startling: i rather severely dislike go
00:09:08 <johnw> show me
00:09:10 <thirsteh> I guess it's a good sign I lost track of time playing with Haskell :)
00:09:16 <Ralith> edwardk: whyzat?
00:09:28 <startling> edwardk: got it. thought donri meant you liked it, was slightly surprised.
00:09:40 <donri> edwardk: would you rather use haskell over scala at work or is haskell missing something for what you're doing there?
00:09:47 <Cale> You can't write a polymorphic list map function in Go. There, I said it.
00:09:50 <Cale> lol
00:10:03 <hpaste> spark_ pasted “parsing error” at http://hpaste.org/73878
00:10:05 <johnw> if I have a list of large elements that I don't care about, with foldl1' (const (+1)) 0 GC the elements as I'm consuming them?
00:10:08 <visof> Cale I learn ruby and some Haskell but never learn go Haskell is kind of language when you try it you never back I think but is it ok for real application why companies like google or yahoo don't use it
00:10:09 <edwardk> Ralith: there is a long log from this morning of my explaining the issues with go from a sapir-whorf perspective you can hit tunes.nef.org for them if curious ;)
00:10:14 <johnw> s/with/will
00:10:20 <startling> Cale: you can't do it with an interface?
00:10:20 <edwardk> i'd rather not dive back in when barely conscious =)
00:10:27 <Ralith> hah, kay
00:10:45 <mk> visof: perhaps you're trying to choose an interesting and advanced language to learn, to improve your skills as a programmer?
00:10:54 <startling> visof: because they have large large codebases written in not-haskell
00:11:33 <edwardk> Ralith: but the short version is that literally nothing that i have written in the last 4 weeks can be written in go, at all.
00:12:02 <Ralith> edwardk: to be fair, I don't think much of what you've written in the last 4 weeks can be written in anything substantially less expressive than Haskell whatsoever.
00:13:17 <edwardk> Ralith: nah, we ported machines to scala, i've written whole libraries of monoids and fused transducers in c#, i can even say good things about c++. i've worked on lots of libraries over the last 4 weeks. they just all do something generic.
00:13:54 <Cale> startling: From what I understand, you might be able to set it up so that you're forced to write the same map function over and over at every type where you want to use it.
00:13:55 <visof> mk yeah
00:13:59 <Ralith> go's outdone by C++? ouch.
00:14:35 <edwardk> Ralith: go compares somewhat well to Algol 68.
00:14:37 <Jafet> Go is like a safety bicycle, C++ is a 1/4 mile dragster
00:14:46 <spark_> johnw: you saw it? for some reason it fails
00:14:46 <mk> visof: if you're trying to choose higher-level languages to learn, and are concerned about longevity, then you might try a lisp. They've been around forever, and clojure is an excellent variant. If you'd like to learn about types, which are very important, you should pick up a reasonable understanding of haskell
00:14:53 <Jafet> Comparing them isn't very useful
00:15:23 <Jafet> Well, C++ templates is a different thing altogether
00:15:23 <edwardk> Ralith: http://www.cowlark.com/2009-11-15-go/
00:15:23 <startling> Cale: huh. dumb.
00:15:44 <Ralith> edwardk: thanks!
00:16:11 <johnw> spark_: looking now
00:16:22 <startling> Go would be so much better if they changed it to Issue 9.
00:16:22 <johnw> don't use $ there
00:16:57 <johnw> you want many1 parseAcc <* Ap.endOfLine, not many1 (parseAcc <* Ap.endOfLine)
00:17:01 <johnw> which says something quite different
00:17:07 <johnw> oh, wait
00:17:13 <johnw> maybe that's eaxctly what you wanted, never mind
00:17:26 <edwardk> startling: =)
00:17:33 <johnw> oh, and do { x <- ...; return x } == ...
00:17:45 <spark_> ahh
00:18:05 <johnw> so, now's the time to try out this stuff in ghci
00:18:17 <johnw> manufacture a ByteString with pack, and pass it to parse interactively
00:18:20 <johnw> first test parseAcc
00:18:25 <johnw> then test parseACc <* Ap.endOfLine
00:18:48 <johnw> then test many1 $... on two of them
00:19:24 <spark_> well, im sure parseacc worked before
00:19:41 <spark_> aand that parseacc is going to partial //fail all time
00:20:20 <johnw> ah, hmmm
00:20:26 <spark_> ops
00:20:32 <spark_> parseline
00:21:25 <johnw> does Attoparsec wait until the parse is done before returning data?  I have a list of very large elements being parsed, but I only care about the length of that list at the moment.  I would have thought Haskell could do this in constant memory no greater than 2 * size of the largest element
00:22:14 <spark_> johnw:  that seems close to the same problemns im having lol
00:22:24 <johnw> your data set is not the size of mine
00:22:36 <johnw> my memory use is only a bit larger than the file being parsed
00:22:43 <johnw> which is exactly how I've written it
00:23:01 <spark_> hmmm
00:23:06 <johnw> but I was hoping lazy evaluation and garbage collection would be throwing away the bits I don't need anymore while counting the number of elements in the list
00:24:05 <Cale> johnw: Which attoparsec modules are you importing?
00:24:18 <johnw> import qualified Data.Attoparsec.Char8 as AC
00:24:19 <johnw> import           Data.Attoparsec.Combinator
00:24:19 <johnw> import           Data.Attoparsec.Lazy as AL
00:24:38 <johnw> I'm using AL just to avoid having to do the chunking myself
00:25:04 <johnw> @src length
00:25:04 <lambdabot> Source not found. You untyped fool!
00:25:04 <Cale> Okay, and AC? That's the strict bytestring one.
00:25:14 <johnw> AC is only there for AC.decimal
00:25:27 <johnw> the chunks are strict, so that should be OK
00:25:32 <Cale> ah, okay
00:25:52 <johnw> my input is a ByteString.Lazy
00:26:09 <johnw> the output is a [Entry], where Entry is my data fat structure
00:26:12 <johnw> fat data
00:26:27 <johnw> they are not interdependent in any way within the list
00:27:16 <ivanm> gentleben: I'm using forkIO when dealing with the external tools
00:27:17 <hpaste> mmos1127 pasted “typeclass and constraints” at http://hpaste.org/73879
00:27:20 <johnw> it took Parsec 1.5 hours to parse this.  Attoparsec is still working.  The C++ version takes about 48 seconds.  So I know I'm doing something wrong
00:27:32 <mmos> question at above hpaste ^^
00:28:29 <spark_> *Main> parse parseAcc $ B.pack "(1,2,3,test)"  > Done ")" ( 18.0 :+ 0.0 , 36.0 :+ 0.0 , 54.0 :+ 0.0 , "test" )
00:28:33 <johnw> would anyone mind looking at code?
00:28:51 <Cale> johnw: I'll have a quick look, though I'm going to sleep soon
00:29:40 <spark_> *Main> parse parseFile $ B.pack "(1,2,3,test)\n" , Fail ")\n" [] "Failed reading: takeWith"
00:29:49 <johnw> i'm trying to hpaste it with hpaste.el
00:29:59 <johnw> http://hpaste.org/73880
00:30:01 <ivanm> I haven't had hpaste.el working for a few years now
00:30:14 <ivanm> has someone updated it to take into account the new architecture?
00:30:21 <johnw> well, it did paste
00:30:25 <johnw> it just didn't annouce it here
00:30:40 <johnw> so, the function I'm calling, Cale, is readSvnDumpRaw
00:30:47 <johnw> which just does a parse parseSvnDump input
00:30:58 <johnw> so, parseSvnDump (the bottom of the file) is all I'm using at the moment
00:31:05 <johnw> I call "length" on the result, if it's a non-Fail
00:31:10 <ivanm> johnw: I kept having error messages from it
00:31:22 <johnw> ivanm: http://git.swclan.homelinux.org/hpaste.git/
00:31:30 <ivanm> ahhh, a new version?
00:31:31 <johnw> last edited 11/10/2011
00:31:47 <ivanm> I only knew of the one on the wiki
00:31:55 <johnw> this was linked to from the Wiki ;)
00:32:11 <ivanm> well, yes, but i haven't bothered to look for a while ;)
00:32:16 <johnw> Wikis are like that
00:32:21 <Cale> mmos: I guess you could take a meaningless parameter of type a and use asTypeOf... however, that's kind of ugly
00:32:30 <johnw> I'm sure Wikipedia has more to say about Antimony by now
00:32:41 <mmos> Cale: maybe I need to provide actual instances to resolve the ambiguity?
00:33:33 <Cale> mmos: If it would be sufficient just to pick some arbitrary type a like maybe a = Integer or something, then you could indicate that explicitly by putting a type signature on one of the expressions in your definition of search
00:33:54 <Cale> well, probably not Integer :P
00:34:13 <Cale> elemSet = newElemSet state :: MyConcreteElemSet
00:34:34 <mmos> Cale: oh, I'm just trying to do something above my level of understanding -- it seems to me there must be a natural solution. but I get what you are saying
00:35:07 <hpaste> johnw pasted “test-raw-any.hs” at http://hpaste.org/73881
00:35:11 <johnw> good, it worked
00:35:18 <johnw> that's my test driver for that file
00:35:22 <Cale> mmos: Have you written any instances of this type class yet?
00:35:36 <mmos> Cale: no
00:35:54 <Cale> mmos: It's usually better to have at least two instances before defining a class :)
00:36:06 <mmos> Cale: yup :)
00:38:27 <mmos> Cale: in fact now that I started this moment to think about instances, I realize my classes were useless anyway. yeah, getting ahead of myself I was
00:39:04 <arbn> It's a common problem in programming... trying to make things general before there is a need to.
00:39:11 <spark_> johnw: what was that <* operator?
00:39:51 <johnw> throws away the result to the right
00:40:22 <johnw> that's from Control.Applicative
00:40:23 <mmos> arbn: it's common among the programmers who like to be creative; but I've worked with programmers who couldn't think abstractly at all and just "programmed by numbers"
00:40:26 <johnw> it's not special to Attoparsec
00:40:27 <spark_> so if i have parse <* endofline, it returns parse?
00:40:30 <johnw> yes
00:40:47 <spark_> the hell, why it doesnt work
00:40:55 <ivanm> I'm sure I've seen a function that tests if an external executable exists; anyone know what I'm talking about?
00:40:59 <johnw> you verified it on a smaller data set?
00:41:03 <ivanm> (i.e. search the PATH and see if there's such a command)
00:41:13 <johnw> ivanm: oh, like a searchPath command
00:41:13 <arbn> mmos: Oh, sure. This is why I can't bring myself to take almost all C# and Java jobs. :(
00:41:13 <spark_> johnw: *Main> parse parseFile $ B.pack "(1,2,3,test)\n" , Fail ")\n" [] "Failed reading: takeWith"
00:41:33 <johnw> pastie again
00:41:33 <spark_> johnw: if i do parse parseAcc without the \n, it work
00:42:15 <johnw> ivanm: System.FilePath.getSearchPath
00:42:39 <Cale> mmos: Haskell provides you with so many ways to be abstract that it can be easy to get caught up in it.
00:42:56 <sheldonh> is the use of $ to avoid parens widely accepted as good or bad style, or is it just troll bait?
00:43:10 <johnw> ivanm: then map (ownerExecuteMode . (++"/mybin")) over it?
00:43:25 <johnw> sheldonh: good or bad style to whom
00:43:32 <arbn> I've wasted lots of time by making my functions way more polymorphic than they ever should need to be.
00:43:34 <johnw> I like them, when used judiciously
00:43:37 <Cale> sheldonh: My rule is to never make use of the fact that $ associates to the right
00:43:39 <johnw> but I'm from Lisp, so I don't mind parens
00:43:39 <hiptobecubic> sheldonh, combinations . of . (.) . and . ($) . are $ accepted
00:43:56 <mmos> arbn: I'm actually a laid-off programmer who went into a different field: classical music composition (I'm a student) -- but I like to use computers to help me with music and I'm one of the few composers who can actually program
00:44:06 <johnw> what I hate is (. foo) . (. bar) $ baz
00:44:07 <Cale> sheldonh: It keeps the number of $'s down, forces a good compositional style, but also allows elimination of lots of parens
00:44:09 <johnw> i just can't read that
00:44:30 <Cale> johnw: More common to see things like (foo .) . bar
00:44:44 <hiptobecubic> still not intuitive
00:44:49 <johnw> which ends up being what?
00:44:50 <Cale> johnw: It starts making more sense if you remember that (.) is fmap for the function functor :)
00:44:53 <johnw> @unpl (foo .) . bar
00:44:53 <lambdabot> (\ d g -> foo (bar d g))
00:44:58 <johnw> ah
00:45:02 <hiptobecubic> you have either memorized that idiom or it's just another perlskellism
00:45:07 <johnw> a "two argument composition"
00:45:24 <shachaf> (foo .) . bar is a pattern that you learn to read, but I don't recommend ever writing it.
00:45:35 <Cale> Yeah, I don't really write that either :)
00:46:00 <johnw> Cale: no, that doesn't help (the fmap bit)
00:46:10 <johnw> foo fmapped over the result from bar?
00:47:19 <spark_> johnw: i found why, takeTill doesn't consume when the result is true
00:47:28 <johnw> aha
00:47:32 <johnw> good for you
00:47:34 <spark_> so my last byte before then end of line stayed there
00:47:56 <johnw> huh, using forkOS instead of forkIO just improved the speed of some shelly code by 20%
00:48:00 <Cale> johnw: yeah, you imagine applying bar to some value, and getting a function, and then you are applying foo to the results of that function
00:48:39 <johnw> my brain still hurts
00:49:07 <Cale> You can think of a function as being like a container indexed by all the elements in its domain
00:49:26 <johnw> yeah, that I do do
00:49:38 <johnw> it's a map whose contents are made to order
00:49:51 <johnw> (a Map, I meant)
00:50:15 <Cale> yeah
00:50:16 <spark_> johnw: how do i try one parse after another one failed?
00:50:33 <sheldonh> thanks for the $ feedback :)
00:50:33 <johnw> <|>
00:50:45 <johnw> parser1 <|> parser2
00:50:45 <Cale> and so (foo .) is the function which applies foo to the elements in that container
00:50:53 <ivanm> johnw: System.Directory.findExecutable
00:50:54 <johnw> (foo .) == fmap foo
00:50:58 <Cale> yeah
00:50:59 <ivanm> ^^ that's what I wanted
00:51:03 <johnw> fmap foo . bar
00:51:06 <johnw> so much nicer ;)
00:51:11 <johnw> aha!
00:51:19 <johnw> thansk for letting me know ivanm
00:51:38 <johnw> I'm glad I keep a private channel log.  I'm sure I'll search for that someday
00:51:46 <Cale> sheldonh: The usual thing is to write expressions like   f . g . h $ x
00:52:07 <johnw> so, with forkIO my shelly code get around 134% CPU utilization.  With forkOS it gets around 160%.
00:52:10 <Jafet> And then spend ten minutes trying to erase the x
00:52:26 <johnw> which calls for an update!
00:52:45 <Cale> sheldonh: this has some advantages over parens or multiple $'s in terms of being able to separate out parts and think about them independently because (.) is a genuinely associative operation
00:52:59 <Cale> sheldonh: So, for instance, g . h is meaningful on its own there
00:53:06 <johnw> I sometimes like to think of . as being the inverse of | in the shell
00:53:13 <johnw> foo | bar | baz == baz . bar . foo
00:53:15 * hackagebot Craft3e 0.1.0.5 - Code for Haskell: the Craft of Functional Programming, 3rd ed.  http://hackage.haskell.org/package/Craft3e-0.1.0.5 (SimonThompson)
00:53:17 * hackagebot git-all 1.1.0 - Determine which Git repositories need actions to be taken  http://hackage.haskell.org/package/git-all-1.1.0 (JohnWiegley)
00:53:38 <Cale> sheldonh: and you might decide that it's important enough to deserve its own definition and factor it out, and you wouldn't have to edit the code to replace $'s with .'s
00:53:47 <hiptobecubic> i just think of it as 'pipe' and and the rest is obvious
00:54:12 <Cale> sheldonh: (as in  f $ g $ h $ x  the "g $ h" is meaningless on its own)
00:54:13 <sheldonh> Cale: oh, that's an interesting way to think about it (thinking forward to extraction)
00:54:15 <johnw> Cale: any thoughts on the Attoparser?
00:55:03 <Cale> johnw: Ah, I missed the line where you pasted it, found it now :)
00:55:27 <johnw> ok, so my Parser version finished in 1h32m.  My Attoparsec version of the same parser (very minor changes to port it) finished in 38 minutes.
00:55:31 <johnw> s/Parser/Parsec
00:55:37 <hiptobecubic> I can't get (foo . ) . bar  to work ith fmaps. do i need to import some functor instance or something?
00:55:53 <johnw> memory usage for the two was pretty much equal
00:56:17 <johnw> Data.Function maybe?
00:56:18 <hiptobecubic> johnw, what are you parsing that took a half an hour?
00:56:34 <johnw> it's a Subversion dump file of the Boost repository
00:56:43 <hiptobecubic> oh
00:56:49 <johnw> 11G
00:56:56 <johnw> but it should parse in <60s
00:57:22 <hiptobecubic> then your parser sucks i guess
00:57:26 <johnw> i need to find out why Haskell is haning on to all the memory
00:57:32 <n00b6502> ". inverse of | in shell" ... is it F# that has |> that works the other way round
00:57:33 <johnw> hiptobecubic: I'm open to code review :)
00:58:06 <timthelion> johnw: At 500mb/s, it takes 20 secconds just to read that file from disk...
00:58:32 <johnw> the RAID-0 array it's on is running around 360 mb/s average
00:58:44 <spark_> great, now my parser is failing on the last line
00:58:45 <johnw> and the machine has oodles of RAM, so it's all cached by now anyway
00:59:02 <timthelion> :D
00:59:35 <timthelion> johnw: I have windows 95 installed on a laptop with 8 megs of ram :D :D
00:59:50 <johnw> I have such a machine in a VM... :)
00:59:58 <spark_> timthelion: is that extreme coding?
01:00:25 <johnw> he sure won't tolerate bloat
01:00:27 <timthelion> spark_: I don't actually code on that machine, at least not anymore.  And when I did, it was in the terminal, with SNOBOL...
01:01:12 <Cale> johnw: Maybe try profiling with -hr?
01:01:16 <spark_> timthelion: eh, I can imagine how is to use a thing like that
01:01:21 <johnw> ok
01:01:30 <timthelion> johnw: actually, that computeres a beast.  I did 3D gaming on it!
01:01:30 <johnw> is -hr all that I need to build with?
01:01:35 <johnw> or is that a +RTS flag?
01:01:43 <merijn> Is it preferable to enable language extensions on a per-file basis or package wide (using cabal)?
01:01:43 <johnw> timthelion: Descent?
01:01:44 <Cale> that's an RTS flag
01:02:01 <timthelion> johnw: falling tower...  16 color monochrome, but it turns!
01:03:04 <ddarius> MechWarrior 2 could run on that.
01:03:15 * hackagebot parsergen 0.2.0.1 - TH parser generator for splitting bytestring into fixed-width fields  http://hackage.haskell.org/package/parsergen-0.2.0.1 (JasperVanDerJeugt)
01:03:22 <johnw> i'll try it
01:03:31 <johnw> do I only get the results after a full run?
01:03:43 <hiptobecubic> @type (fmap negate . (+)) 0 1
01:03:44 <lambdabot> forall a. (Num a) => a
01:03:50 <hiptobecubic> > (fmap negate . (+)) 0 1
01:03:53 <lambdabot>   -1
01:03:59 <johnw> > (fmap negate . (+)) a b
01:04:01 <lambdabot>   negate (a + b)
01:04:05 <hiptobecubic> why doesn't it work in ghci? Where is that instance?
01:04:08 <ddarius> So, I have a Kalman filter.  What should I do with it?
01:04:23 <Cale> johnw: I believe you should be able to ctrl-c out and still get data
01:04:25 <hiptobecubic> functor (-> Integer)
01:04:32 <johnw> did you try Data.Function?
01:04:36 <hiptobecubic> yes
01:04:40 <hiptobecubic> and Data.Functor
01:04:54 <shachaf> ddarius: Filter Kalmen, of course.
01:04:59 <johnw> I'm getting it from Control.Monad.Instances
01:05:09 <hiptobecubic> ah
01:05:22 <hiptobecubic> yes there we go
01:05:52 <Cale> johnw: Shouldn't need to let it go for too long even
01:06:38 <Cale> johnw: -hy might also be interesting to look at
01:06:49 <Cale> (which breaks the memory usage down by type)
01:06:52 <johnw> -hr = invalid heap profile options
01:07:01 <spark_> -hc?
01:07:13 <Cale> Compile with -prof -fprof-auto
01:07:25 <johnw> ah, ok
01:07:45 <Cale> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/prof-compiler-options.html
01:07:50 <Cale> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/prof-heap.html
01:07:54 <Cale> ^^ relevant
01:08:11 <timthelion> Does anyone have any idea on how this could be improved? http://hackage.haskell.org/trac/ghc/ticket/7187
01:08:39 <johnw> hmm
01:09:00 <johnw> I'm going to have to rebuild a lot of packages with profiling it looks like
01:09:08 <johnw> is there any way to do this local to this project?
01:10:23 <arbn> johnw: cabal-dev?
01:10:43 <johnw> before I do all that work, I'm going to try something real quick
01:12:35 <Cale> johnw: You should be able to just set library-profiling: True in ~/.cabal/config (and probably documentation: True would be good while you're at it)
01:12:36 <Cale> johnw: and then  cabal install world
01:12:52 <johnw> cool
01:13:34 <Cale> (if you're lucky anyway)
01:19:13 <johnw> ok, I found my problem
01:19:38 <johnw> It would seem that Parser [a] builds the list strictly
01:19:53 <johnw> so I don't get to consume the elements as they're being parsed
01:20:11 <johnw> I wonder if conduit-attoparsec solves this
01:20:33 <ivanm> which parser is this?
01:20:54 <johnw> ivanm: http://hpaste.org/73880
01:21:00 <johnw> here's my new driver code:
01:21:16 <hpaste> johnw pasted “test-raw-any.hs (take 2)” at http://hpaste.org/73888
01:21:31 <johnw> here I count the entries by parsing them one at a time
01:21:38 <johnw> rather than asking my library to parse and return a list of them
01:21:56 <ivanm> johnw: which actual parser in there?
01:22:15 <Cale> That's very awkward if many1 produces a strict list result
01:22:15 <johnw> parseSvnDump
01:22:31 <Tordek> I'm playing with parsec, and... why can't I transform "do size <- many1 digit ; return (read size)" into "read =<< (many1 digit)" ?
01:22:32 <ivanm> Cale: I don't think it does
01:22:44 <ivanm> Tordek: fmap read $ many1 digit
01:22:49 <johnw> hmm I could be wrong
01:22:53 <johnw> no, I'm not
01:22:57 <ivanm> or else return . read =<< many1 digit
01:23:01 <mauke> Tordek: because read has the wrong type to be =<<'d
01:23:05 <johnw> take 2 finishes in 4m12s
01:23:13 <johnw> maximum memory utilization is <485 MB
01:23:22 <ivanm> johnw: are you sure it isn't your "reading file from disk" part that's strict?
01:23:34 <johnw> i'm using ByteString.Lazy
01:23:48 <ivanm> johnw: but you're using Data.ByteString.Char8, not the lazy variant
01:24:16 <johnw> only for BC.decimal
01:24:24 <johnw> Attoparsec is strict under the hood
01:24:43 <johnw> according to the documentation, it grabs chunks from ByteString.Lazy, and then parses the strict chunks
01:24:56 <ivanm> yes
01:24:58 <merijn> Tordek: The original has "return (read size)", (=<<) and (>>=) don't add that return to the result
01:25:01 <johnw> so "take 10" returns a non-lazy string
01:25:16 <merijn> :t (=<<)
01:25:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
01:25:22 <johnw> then I have to use non-lazy Char8, because it's parsing the strict chunk
01:25:52 <ivanm> johnw: unless your space and newline characters are different than the usual ' ' and '\n', I believe there are existing combinators for them
01:26:02 <merijn> Tordek: Instead of fmap you could also use (<$>) (i.e., infix fmap) doing "read <$> many1 digit"
01:26:02 <johnw> ivanm: I was hoping so
01:26:57 <ivanm> johnw: I would have thought it would have made more sense in parseHeader to check if it's 45 first since it's numerically least :p
01:27:39 <johnw> true true
01:27:44 <ivanm> johnw: line 193 is probably pretty slow
01:28:00 <ivanm> consider using a Map at the very least, if not the one from unordered-containers
01:28:14 <johnw> ah, ok
01:28:19 <johnw> i don't think preserving order matters, so I will
01:28:48 <ivanm> in this case it might not make much of a difference
01:29:38 <Tordek> cool
01:29:43 <Tordek> thanks, guys :)
01:29:52 <johnw> so, the C++ version of this parser is using fseek to skip uninteresting parts of the data.  That allows it to complete in 2m38s
01:30:03 <johnw> so attosparsec, parsing everything, is not even twice as slow
01:30:06 <johnw> which is great
01:30:38 <ivanm> johnw: I see lots of magic numbers though, when actually providing them with names would probably be better
01:30:54 <johnw> i wasn't sure yet I was giong to stay with attoparsec
01:30:57 <johnw> so i wasn't going for beauty yet
01:31:11 <johnw> @hoogle [(a, b)] -> Map a b
01:31:12 <lambdabot> Data.Map fromDistinctAscList :: [(k, a)] -> Map k a
01:31:12 <lambdabot> Data.Map fromList :: Ord k => [(k, a)] -> Map k a
01:31:12 <lambdabot> Data.Map fromAscList :: Eq k => [(k, a)] -> Map k a
01:31:13 <ivanm> johnw: still could have done "newlineChar :: Int; newlineChar = 10" up the top or something
01:31:56 <ivanm> johnw: also, why are you unpacking stuff to String?
01:32:11 <ivanm> there are also bytestring-optimised versions of takeWhile1, etc. if memory serves
01:32:36 <johnw> i unpack to String for the end user
01:32:42 <johnw> I could unpack them to Text
01:32:58 <ivanm> johnw: going to Text would probably be better, but do so _after_ you've finished processing it
01:33:07 <johnw> ah
01:33:13 <ivanm> I think your case statements might be faster - even using lists - with BS or Text than with String
01:33:22 <johnw> but then I'll have to pack my field names to look them up!
01:33:33 <ivanm> johnw: OverloadedStrings!
01:34:10 <johnw> and default to ByteString?
01:34:58 <ivanm> since your command strings are only ASCII, you might as well
01:35:07 <johnw> cool
01:35:59 <ivanm> if I want to test whether Graphviz is installed, would it suffice to just check if there's an executable called "dot" somewhere in the PATH ?
01:36:05 <johnw> is there a good way to turn a ByteString into an Int?
01:36:12 <johnw> or to a FilePath?
01:36:31 <johnw> @hoogle ByteString -> Int
01:36:31 <lambdabot> Data.ByteString length :: ByteString -> Int
01:36:31 <lambdabot> Data.ByteString.Char8 length :: ByteString -> Int
01:36:31 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
01:36:31 <ivanm> or should I also a) try to parse it's --version or b) see if something like neato (since the name is less common) is also installed?
01:36:39 <ivanm> johnw: why convert to Int ?
01:36:46 <ivanm> and type FilePath = String
01:36:55 <ivanm> so BS.unpack will convert a BS into a FP
01:36:56 <johnw> I need to turn the ByteString "1345" into an Int so that I can take 1345
01:37:11 <ivanm> ahhhh
01:37:19 <ivanm> I believe there are some libraries that can do that
01:37:25 <ivanm> but the easiest is probably read . BS.unpack
01:37:28 <johnw> B.unpack -> [Word8]
01:37:37 <ivanm> johnw: use the Char8 version
01:37:50 <johnw> aren't I throwing away all my speed advantage now?
01:38:01 <ivanm> not if you don't do it often
01:38:02 <johnw> all this conversion?  I could just add up the chars in the ByteString
01:38:07 <johnw> i do it *often*
01:38:15 <johnw> like, for every single property in the whole file
01:38:27 <ivanm> I'm saying as part of it you'd compare strings as BS rather than as Strings
01:38:45 <ivanm> and where do you keep converting BS into Int?
01:39:03 <ivanm> for revNumber ?
01:39:40 <johnw> line 199
01:40:14 <johnw> and line 183
01:40:15 <LordBrain> use -XOverloadedStrings too... "" can be bytestring
01:40:19 <johnw> line 183 is the real killer
01:40:23 <LordBrain> :)
01:40:41 <LordBrain> well just a suggestion, maybe you already do, i am just walking in here, so perhaps i shouldn't interject
01:40:46 <johnw> i think i'll just write an ugly fold
01:42:34 <johnw> @hoogle ByteString.unpack
01:42:34 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
01:42:34 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
01:42:34 <lambdabot> Data.ByteString unpack :: ByteString -> [Word8]
01:42:44 <johnw> @hoogle Word8 -> Int
01:42:44 <lambdabot> Data.ByteString count :: Word8 -> ByteString -> Int
01:42:45 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
01:42:45 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
01:44:25 <LordBrain> why does that match count
01:44:44 <ivanm> LordBrain: which one?
01:44:52 <LordBrain> Word8 -> Int
01:45:23 <ivanm> well, Word8 is probably an instance of Storable
01:45:25 <LordBrain> hoogle's type search seems to broad
01:45:30 <LordBrain> too
01:45:59 <ivanm> johnw: so you want to be able to parse an Int ?
01:46:04 <ivanm> there's probably combinators for that :p
01:47:00 <johnw> true true
01:47:03 <johnw> let me try that route
01:47:12 <johnw> oh, no
01:47:22 <johnw> i don't know until after I've parsed the property that it's an int
01:47:28 <johnw> I wrote this:
01:47:28 <johnw> readInt bs = B.foldl (\acc x -> acc * 10 + fromIntegral x) 0 bs
01:47:44 <johnw> where B = ByteString, and bs :: ByteString
01:48:04 <johnw> hmmm
01:48:10 <johnw> i guess that's not even close to right though
01:48:18 <ivanm> well, foldl' rather than foldl
01:48:21 <johnw> let me try the combinator route
01:48:24 <johnw> and it needs to be foldr
01:48:26 <arbn> Any tips on discerning why aeson is failing to decode a particular value?
01:48:48 <johnw> and it wouldn't work for the number "100"
01:49:03 <johnw> i'll need a tuple accumulator to track which digit I'm on
01:49:06 <johnw> bleh, let me try decimal
01:50:06 <hpaste> arbn pasted “aeson decoding” at http://hpaste.org/73889
01:50:24 <arbn> That returns Nothing, which is not what I want.
01:52:33 <quicksilver> arbn: I don't know specifically but the first thing I would do is try to minimise that counter-example
01:52:42 <quicksilver> chop stuff out until it starts working.
01:52:55 <arbn> quicksilver: Ah. That's a good idea.
01:53:22 <quicksilver> oh I think I do know why
01:53:27 <quicksilver> you're trying to decode it to a String
01:53:30 <quicksilver> but that's a compound value
01:53:34 <quicksilver> it won't be a String
01:54:14 <arbn> OK. It will be a List of some kind of Map?
01:54:35 <chrisbuchholz> Hey guys - i know im asking in a place where i might get more or less biased answers from you bunch of people, but i'd like to get familiar with a pure functional programming language. The contestant i have lined up are Haskell, Scala and Erlang, but I'm having a hard time figuring out which to choose - the pros and cons, which gives the most take-away in form of the art of programming, which are more appliable in todays common ...
01:54:41 <chrisbuchholz> ... programming tasks and so forth. Could you help me out?
01:54:43 <quicksilver> arbn: yes, I think so.
01:55:11 <arbn> chrisbuchholz: Scala and Erlang are not purely functional.
01:55:29 <chrisbuchholz> like, maybe a good resources that lines facts up about the three, or some article the talks about this specific question or something
01:55:46 <quicksilver> arbn: most generically, I think you could decode it as  'Value'
01:55:55 <arbn> chrisbuchholz: Scala is actually a pure OO language, which borrows some functional features.
01:55:56 <quicksilver> arbn: in fact I think you could try [Map String Value]
01:56:03 <arbn> quicksilver: Ah. Thanks.
01:56:09 <quicksilver> arbn: does that make sense?
01:56:17 <chrisbuchholz> arbn: well, all right, theres some cons :)
01:56:21 <quicksilver> if you choose 'Value' you have to navigate through the constructors.
01:56:29 <quicksilver> if you choose [...] then you force the top level to be a list
01:56:34 <quicksilver> if it isn't, you get Nothing
01:56:44 <quicksilver> if it is, then you have one constructor you don't have to navigate through
01:57:01 <arbn> quicksilver: Yeah, that does make sense.
01:57:05 <quicksilver> [Map String Value] forces the first level to always be list and the second level to always be maps
01:57:11 <quicksilver> which seems to be true in your example data
01:57:18 <quicksilver> but that 'value' is hard to fix
01:57:36 <quicksilver> you could do Either Int (Either Bool ())
01:57:37 <quicksilver> I think
01:57:41 <merijn> chrisbuchholz: AFAICT Scala seems a bit more cluttered and messy, syntax and design wise. The fact that it is also OO may lead to confusion (no clue, haven't done Scala)
01:57:55 <arbn> quicksilver: There's already a parser in this code-base, so Value was the missing type I didn't know about. Thanks.
01:58:08 <quicksilver> and you'd get Left 60 for 60, Right Right () for null and Right Left True for true
01:58:11 <quicksilver> but I'm not actually sure
01:58:14 <merijn> chrisbuchholz: Erlang is well done and very interesting, but many of things you can do in Erlang you can also do in Haskell and I think Erlang's syntax is ugly
01:58:16 <quicksilver> not played with aeson myself
01:58:39 <spark_> johnw: I found the memory leak T.T, running with hr made it clear
01:58:51 <merijn> chrisbuchholz: Haskell can be tricky to understand as a beginner as laziness can be tricky to reason about, but I think the syntax is nicer/cleaner and the type system is incredibly valuable
01:58:53 <chrisbuchholz> merijn: i get the feeling that erlang is more hib and haskell is more niche - what are you thought about that?
01:59:34 <chrisbuchholz> merijn: yeah, i understand that coming from imperative languages makes learning a functional language like learning to program for the first time
01:59:42 <johnw> cool!
01:59:53 <arbn> chrisbuchholz: If you go with Scala, you might consider only using vals (immutable), and no vars (reference), to get a feel for the functional style.
01:59:58 <LordBrain> laziness is very valuable too, tho admittedly it is trickier
02:00:07 <johnw> ivanm: ok, trying now with all ByteString, no String, no Text
02:00:11 <johnw> oh, and Maps
02:00:19 <merijn> chrisbuchholz: Yes, but laziness is an added tricky bit, on top of functionalness. It can be very useful and nice, but it's tricky to reason about
02:00:49 <LordBrain> haskell isnt just prettier because of its syntax, laziness allows more freedom in how you write the code, and that means more ability to make it pretty with effort
02:00:49 <chrisbuchholz> arbn: well, i was mostly leaning towards haskell or erlang, but kept scala open just for the sake that somebody might have a good reason to choose it
02:00:52 <merijn> chrisbuchholz: I think Haskell's type system alone makes it worth learning if you've never used a language with a "proper" type system
02:01:16 <merijn> chrisbuchholz: (Proper meaning Hindley-Milner type inferred like haskell, SML and ocaml)
02:01:40 <arbn> chrisbuchholz: If you're completely new to functional programming, you might also consider starting with a LISP dialect like Racket or Clojure.
02:01:48 <LordBrain> and yes, laziness  can pay off big in the right use cases, and it is nice having it as the default, because you sometimes discover that by accident.
02:01:56 <chrisbuchholz> merijn: well, i dont know much about it - what you're talking about is how haskell can understand that a is a number of the assignment is "a = 4 + 5", yes? I read something about it
02:02:19 <merijn> chrisbuchholz: It goes *far* beyond that. If you have no experience with a good type system I would recommend learning haskell first
02:02:30 <johnw> chrisbuchholz: that's called "type inference"
02:02:37 <johnw> it's a wonderful thing
02:02:46 <chrisbuchholz> arbn: well, i have done subfunctional programming in languages like python, but nothing like haskell
02:02:48 <merijn> chrisbuchholz: As a lot of the functional stuff in haskell will transfer 1-to-1 to Erlang, but you will also gain an experience with the type system (which Erlang lacks)
02:02:56 <chrisbuchholz> johnw: ah, all right
02:03:23 <LordBrain> yeah, it's probably not necessarily bad advice to start off with a strict language, but then again, once you do come to haskell, you'll get this feeling like this is the real functional.
02:03:24 <johnw> it's like having the computer say to you, "You're not using that function right... are you *sure* that's what you think you want to be calling?"
02:03:26 <merijn> chrisbuchholz: My personal recommendation would be Haskell first and then look into Erlang/Lisp
02:04:01 <johnw> i would avoid Erlang unless you need to solve just the kinds of problems it solves well
02:04:11 <chrisbuchholz> merijn: can you comment on what scope of tasks that haskell, compared to e.g. erlang which i have read more about, are better in, compared to say erlang?
02:04:12 <LordBrain> well i say go whichever way your interest takes you
02:04:15 <johnw> it doesn't seem like much of a general purpose language
02:04:33 <merijn> chrisbuchholz: You could learn the functional basics in either Haskell or Erlang, but I think the haskell type system beats out Erlang's concurrency/hot code updates (although those are very interesting too!)
02:04:35 <LordBrain> haskell may be hte deep end, but that's also possibly the most valuable education too.
02:04:53 <johnw> ivanm: we're down from 4:12 to 3:39
02:04:58 <johnw> C++ is 2:38
02:05:09 <chrisbuchholz> LordBrain: yeah, i heard that once or twice ;)
02:05:14 <merijn> chrisbuchholz: Large scale highly concurrent IO with a focus on fault tolerance/recovery is Erlang's playground
02:05:16 <LordBrain> we're going to be a biased sample in this room i suppose.
02:05:26 <ivanm> johnw: I think there's also ways to skip ahead in the BS whilst parsing with attoparsec
02:05:45 <chrisbuchholz> merijn: yes - but what is haskells?
02:05:57 <johnw> there's skip, but it looks at each byte
02:06:01 <johnw> I want to seek forward
02:06:16 <ivanm> johnw: so consider integrating it as part of your parseTag
02:06:18 <johnw> in Parsec I do that with getInput and setInput
02:06:28 <ivanm> e.g. directly parse a Prop-content-length tag, or a Text-content-length tag, etc.
02:06:37 <merijn> chrisbuchholz: I think Haskell is nicer for single machine code. You can get many nice things Erlang has (lightweight threads, good concurrency, etc) in haskell too, it's just not as easy to run over multiple machines (although there's people working on Cloud Haskell now)
02:06:40 <ivanm> rather than trying to identifying the tag after the fact
02:06:46 <LordBrain> seeking forward, that sounds like one to be careful about, you could end up preventing garbage collection
02:07:02 <johnw> ivanm: what I mean is, for the Text-content, I want to just zoom forward in the ByteString
02:07:04 <quicksilver> johnw: if you call "take 16" then that has the effect of skipping head 16 bytes
02:07:09 <johnw> oh, o
02:07:09 <johnw> k
02:07:12 <quicksilver> johnw: it doesn't examine them or copy them
02:07:13 <johnw> then I'm already zooming
02:07:17 <johnw> but it reads them
02:07:21 <merijn> chrisbuchholz: In addition writing imperative code in Haskell can be very nice too. The usual killer library mention for haskell is stuff like parsec/attoparsec for parsing data
02:07:22 <johnw> is there a way to not read them?
02:07:23 <quicksilver> they're already read.
02:07:30 <quicksilver> that's how attoparsec works
02:07:34 <johnw> ah
02:07:34 <quicksilver> the bytestrig is already read
02:07:39 <quicksilver> the best you can do is not inspect it.
02:07:41 <johnw> well, I'm using Attoparsec.Lazy
02:07:43 <chrisbuchholz> merijn: but say - what would i use haskell for? What is a killer application of using haskell?
02:07:52 <quicksilver> with modern IO systems there is no point not reading from the disk
02:07:52 <johnw> so I could potentially skip chunks
02:07:56 <chrisbuchholz> merijn: i see
02:07:56 <ivanm> johnw: have parseTag directly identify the type of tag
02:08:01 <quicksilver> unless you're going to not-read an entire page
02:08:03 <quicksilver> even though.
02:08:03 <johnw> ivanm: what does that buy me?
02:08:06 <merijn> chrisbuchholz: That's a hard question, what's the killer application of using python? :p
02:08:11 <quicksilver> even then, your driver will do readahead
02:08:15 <johnw> ivanm: I'll try it
02:08:22 <mauke> chrisbuchholz: I'd say transforming trees
02:08:23 <LordBrain> i am not thinking of parsec specifically, but if you have a lazy list and there is look ahead, it could end up breaking the laziness, or loading up lots of stuff in memory at once
02:08:24 <johnw> ah, I can skip the lookup
02:08:33 <ivanm> johnw: you don't do a lookup on the tags after parsing them
02:08:34 <merijn> chrisbuchholz: Personally I've started to use it as a nicer, typechecked, faster python :)
02:08:57 <chrisbuchholz> merijn: everything thats not supposed to be speedy
02:09:02 <LordBrain> it can be done, just something to watch out for
02:09:09 <arbn> chrisbuchholz: Haskell is very general-purpose. I find it better than Python for both web development and parsing.
02:09:21 <chrisbuchholz> mauke: as in what?
02:09:34 <chrisbuchholz> arbn: web development in what way?
02:09:42 <merijn> I just started playing with Yesod and it's very nice, but the documentation and minimal examples could be a bit better
02:09:44 <charliesome> arbn: you can't be serious
02:10:00 <merijn> charliesome: Why not?
02:10:01 <mauke> chrisbuchholz: e.g. parsing text into syntax trees and munging them, as in optimizers/compilers/etc
02:10:04 <arbn> chrisbuchholz: Yesod is just easier, more flexible, and more powerful than Django. I'm dead serious.
02:10:44 <arbn> chrisbuchholz: Type-checked URL routing and database inputs are very nice.
02:11:03 <chrisbuchholz> mauke: ah okay
02:11:18 <mauke> I think haskell really shines there
02:11:28 <merijn> chrisbuchholz: I guess I'd say the main thing haskell is excellent at is code reuse
02:11:35 <chrisbuchholz> arbn: i will definitely look up yesod
02:11:35 <johnw> does Attoparsec not have <|>?
02:11:50 <ivanm> johnw: it does
02:12:16 <merijn> chrisbuchholz: The type system lets you right a lot more general purpose reusable code then many other languages, as a result I mostly find myself dealing with very high level issues and writing very little code :p
02:12:22 <chrisbuchholz> merijn: yeah, thats mention a lot of places too, so i guess there's something about it
02:12:38 <johnw> oh, that's in Applicative
02:12:56 <chrisbuchholz> merijn: well, i'd had to take your word on that, because i dont know about the type system, but it sure sounds great
02:13:19 <LordBrain> the only problem with haskell, is there is a strong temptation to dive deeper and deeper into type theory, lambda calculus, category theory and yadda yadda, and to get exceedingly clever about it all just to do something that you could whipped up really quick if you weren't being such a perfectionist egg head...
02:13:23 <chrisbuchholz> What would i great source of getting started with haskell be? I was just thinking about using Learn Your Some Haskell For Great Good (online)
02:13:30 <merijn> chrisbuchholz: Yesod is very nice, but the startup documentation is still a bit lacking. There's lots of trivial examples and lots of complicated setups, but moderate complexity skeletons/examples seem to be a bit lacking yet
02:14:04 <merijn> chrisbuchholz: Learn You a Haskell is great, as a followup book focussed on more practical things I'd recommend Real World Haskell
02:14:29 <eikke> chrisbuchholz: the reading list I tend to pass on is available at https://gist.github.com/3299549
02:14:35 <chrisbuchholz> merijn: i shall remember that title if i ever get through LYSHFGG
02:14:38 <johnw> parsing those properties directly is not so easy
02:14:46 <chrisbuchholz> eikke: awesome
02:14:49 <johnw> remember, I use many1 parseTag to fill a map of ByteString -> ByteString
02:15:22 <johnw> i end up having to lookup the property again somehow
02:15:28 <ivanm> johnw: there are better ways of having Parse ByteString
02:15:50 <johnw> how do you mean?
02:15:56 <ivanm> johnw: and searching through a Map or a list is cheaper by comparing constructors than by comparing Strings/BS/Text values
02:16:24 <johnw> you mean, create a Data type for fields?
02:16:30 <ivanm> johnw: takeWhile1 is faster than many1 or something
02:16:32 <ivanm> johnw: yes
02:16:34 <arbn> LordBrain: That's a good point. I've been trying to get through a book on Category Theory, and it's all Haskell's fault. :(
02:16:37 <johnw> like data Field = PropLength | TextLength | Other ByteString
02:16:47 <LordBrain> lol arbn
02:16:48 <johnw> takeWhile1 doesn't return a list, but just a ByteString
02:17:21 <ivanm> that's what I mean
02:17:30 <ivanm> you said you wanted to fill a map of ByteString -> ByteString
02:17:37 <johnw> yes...
02:17:39 <frerich> Don Stewart's company got acquired by Facebook? Did that bring the 'Haskell program to modify PHP source code' (I forgot the name of it...) to Facebook?
02:18:07 <ivanm> johnw: data Field = PropLength Int {the field if you care about it} | TextLength Int {the field if you care about it} | Other ByteString ByteString
02:18:10 <chrisbuchholz> well, i guess theres many reasons to learn haskell. I initially thought about Erlang, but i always felt like a phony company startup when i read Programming Erlang. It always felt weird - i guess it was not just right
02:19:12 <LordBrain> its true tho, you will come in here and hang out with phds, and you will end up reading technical papers and text books, just because you want to follow the discussions, and you know be a good haskeller too.  It's not really that you have to do all that to get anything done, but you just know you could do it even better the more you know, and besides who wants to be left out of a conversation.
02:20:11 <merijn> My IQ has increased more from 2 years in here than my entire CS degree :p
02:20:37 <arbn> LordBrain: It helps with job interviews, too. I bombed a recent interview for Haskell stuff partly because I haven't looked into comonads yet... because I haven't needed to.
02:20:48 <ivanm> merijn: that thing that is only good at indicating how well you do at IQ tests? ;)
02:20:54 <edwardk> interesting that comonads are coming up in job interviews now =)
02:20:59 <ivanm> wtf?
02:21:11 <johnw> ivanm: ok, but then what is the type of my Map?
02:21:15 <ivanm> why would you fail an interview just because you don't know what comonads are?
02:21:17 <edwardk> frerich: not dons, bos
02:21:23 <johnw> [Field] is easy, but then it's an O(n) lookup again
02:21:26 <ivanm> unless edwardk was running it... :p
02:21:34 <johnw> but the n is always small
02:21:36 <johnw> <7
02:21:40 <edwardk> ivanm: hah, not me this time. i swear
02:21:47 <ivanm> johnw: well, you can just do a partition over it
02:21:57 <johnw> what does that mean?
02:22:01 <ivanm> or, build up the list one at a time and identify stuff as you go
02:22:21 <ivanm> johnw: I don't know what the Fields in your file type are like
02:22:26 <ivanm> are they always in a specific order?
02:22:33 <johnw> i'm not guaranteed that, no
02:22:44 <edwardk> its a shame 7.6 lets me make all sorts of sexy names for infix types, but i still can't use . ;)
02:23:03 <ivanm> johnw: are you guaranteed that there is precisely one PropLength and one TextLength ?
02:23:12 <johnw> yes
02:23:13 <ivanm> edwardk: awwwww....... :p
02:23:31 <johnw> how do I lookup a PropertyLength from my list now?
02:23:52 <johnw> I pattern match on the first PropertyLength x?
02:23:59 <ivanm> johnw: so you could always do a fold to construct your Entry
02:24:11 <ivanm> parse all these tags
02:24:13 <johnw> the PropertyLength and TextLength may not be present
02:24:14 <amosr> is 'ill-typed' the opposite of 'well-typed'?
02:24:28 <johnw> and their presence changes how I must parse the entry
02:24:39 <ivanm> johnw: if they're not present, what are the values in your Entry?
02:24:44 <merijn> Complete subjective question time! "Imports.hs" or "Internal.hs" for package-wide imports?
02:24:51 <johnw> it means the body is B.empty
02:24:56 <johnw> and the property list is []
02:25:24 <arbn> merijn: "Import.hs" :P
02:25:39 <ivanm> johnw: so start with "Entry [] [] BS.empty"
02:25:45 <ivanm> and then fold through the list of fields
02:25:50 <johnw> i see what you mean
02:25:54 <ivanm> and you can strip the OtherField constructor
02:26:07 <johnw> good idea
02:27:18 <johnw> ah, but this doesn't work eitheir
02:27:26 <johnw> their order is mixed
02:27:36 <johnw> but their presence means I parse in a certain order
02:27:42 <johnw> as in, if x then y, if z then w
02:27:50 <johnw> but x z could have appeared z and x
02:28:09 <ivanm> I'm not following
02:28:22 <ivanm> according to your current code you parse all these fields and _then_ do stuff
02:28:23 <johnw> see the current parser code
02:28:38 <johnw> i read in the fields, then do further parser depending on values from those fields
02:29:12 <ivanm> johnw: fine, so use an intermediary data structure: here is how much I have to read for the props after I finish the tags, here is how much I have to parse for the body
02:29:21 <johnw> i can't fold the fields into a map, and while folding decide whether to parse properties or parse the body, because they might come out of order
02:29:35 <johnw> oh, I see
02:29:42 <ivanm> your individual fields don't seem to interact with each other in your current code
02:29:46 <johnw> return (map, Int, Int)
02:29:56 <ivanm> or something
02:30:15 <johnw> let me try
02:30:19 <ivanm> you can just return the fields as a list if you don't need to do lookups on them
02:30:35 <johnw> for now I will
02:36:05 <Shapeshifter> Using hscurses, how can I get from a CInt (character entered by the user, retrieved using Curses.getch) to a Char? I can get to a Key using decodeKey, but I don't understand how to make a Char.
02:36:27 <Shapeshifter> (I want to append the entered character to a list of characters)
02:37:07 <Botje> Shapeshifter: it's a member of Integral, so you could just use fromIntegral.
02:39:28 <matthiasgorgens1> has anyone played with halvm?
02:39:39 <matthiasgorgens1> (galois project to run haskell directly on xen.  no os required.)
02:40:56 <Shapeshifter> Botje: mhh, how? With c <- Curses.getch, I can't do (fromIntegral c), it throws "No instance for (Num Char) arising from a use of `fromIntegral' ... In the second argument of `(++)', namely `[(fromIntegral c)]'"
02:41:15 <johnw> ivanm: that last round of changes made not one wit of difference
02:41:27 <ivanm> :o
02:41:29 <johnw> 0.27s faster
02:41:37 <johnw> out of 3:39
02:41:39 <ivanm> what, no lookups and it isn't noticeably faster? :o
02:41:46 * ivanm finds that hard to believe
02:41:54 <johnw> it's always a very small map
02:41:59 <ivanm> maybe because the lists are so small and there's little overlap between the field names
02:42:07 <johnw> yep
02:42:09 <ivanm> so the L.lookup can skip fields very quickly
02:42:28 <Botje> Shapeshifter: fromIntegral gets it to Int. from there you can use Data.Char.chr or toEnum to go to Char
02:42:29 <johnw> and now I have to fold to undo my custom data structure
02:42:37 <Shapeshifter> Botje: ah, thanks
02:43:30 <ivanm> johnw: which fold are you using?
02:43:38 <johnw> foldl'
02:44:16 <spark_> is the a boxed vector to unboxed functino?
02:45:09 <johnw> i don't think I can beat C++ with it's fseek
02:45:20 <johnw> i mean, it's entirely skipping almost 75% of the file's contents
02:45:49 <johnw> and that doesn't look like an optimization I can do, without writing almost the same code in IO
02:45:52 <ivanm> hmmm
02:46:24 <ivanm> I wonder if it would be feasible to fuse the fold in the parsing
02:46:28 <ivanm> probably not that worth it though
02:46:30 <quicksilver> johnw: is it skipping chunks of 4k or larger?
02:47:26 <johnw> yes, quite often
02:47:30 <quicksilver> ah ok
02:47:35 <LordBrain> johnw, whatya doing? you could break out the ffi and use c
02:47:39 <quicksilver> then yes, I think you are probably right.
02:47:48 <johnw> i'm parsing a Subversion dump file
02:47:53 <quicksilver> skipping chunks that big attoparsec isn't going to be perfect for
02:48:06 <johnw> every revision is a series of nodes, and if any node adds or changes a file, it just includes the entire contents of the file for that revision
02:48:09 <quicksilver> you could imagine a seek/skip focusses parsing library
02:48:15 <quicksilver> but I don't think we have one
02:48:20 <quicksilver> so you'd have to write your own hSeek code
02:48:38 <johnw> yeah, and them I'm hand rolling it in IO
02:48:42 <johnw> no fancy combinators :)
02:48:51 <quicksilver> you can write your own combinators it's not hard :)
02:49:00 <johnw> but just not worth it
02:49:04 <quicksilver> perhaps not.
02:49:10 <ivanm> though I think attoparsec _does_ deal with skipping past multiple chunks
02:49:10 <LordBrain> if speed/efficiency is very important, generally.. aren't parser combinators not the best way to go?
02:49:13 <quicksilver> I wrote something a bit like that for a b* tree
02:49:14 <johnw> for the real use case of this utility, I do indeed have to read every byte
02:49:23 <johnw> this is just the "pre-scan" that I'm optimizing now
02:49:23 <LordBrain> after all there is a reason ghc doesnt use parsec
02:49:29 <quicksilver> with a typeclass for the seeking
02:49:39 <quicksilver> LordBrain: yes, and that reason is that parsec didn't exist when GHC was written.
02:49:51 <johnw> ivanm: how do I get it to skip?
02:49:59 <tdammers> chicken and egg
02:50:01 <LordBrain> it existed for some time, and they havent ported
02:50:05 <quicksilver> no point
02:50:06 <johnw> or egg and chicken
02:50:08 <quicksilver> current system works :)
02:50:14 <LordBrain> is not happy faster?
02:50:14 <quicksilver> happy/alex is fine
02:50:15 <ivanm> quicksilver: yeah, I think Axman6 did something like that for a Binary instance for binary trees by storing where the right branch started in the bytestring
02:50:20 <quicksilver> and the grammar doesn't change often.
02:50:33 <quicksilver> LordBrain: I think it probably is, but I'm not sure that's the reason they don't switch.
02:50:36 <Axman6> i did what now?
02:50:37 <ivanm> johnw: I meant that if your skipping goes past the end of one chunk in a lazy bytestring and starts with another attoparsec deals with that
02:51:07 <quicksilver> lazy bytestring chunks are quite large by default
02:51:24 <quicksilver> and I'm not sure they'll ever completely skip the reading
02:51:30 <ivanm> Axman6: I think at Aushac last year you encoded a binary tree using a Bytestring where you stored where the right branch started so you could skip past the left branch
02:53:14 <Axman6> oh right. yeah that was pretty trivial, it was something like put (Branch a l r) = put a >> put (encode l) >> put r; get = do { a <- get; l <- fmap decode get; r <- get; return (Branch a l r) }
02:53:19 <LordBrain> well, i could be wrong, i am not aware of theoretical limitaitons of parser combinators
02:55:43 <LordBrain> there is a package i saw on hackage that will let you put bnf right into your source code, and it would generate a parser for you and let you embed the language using template haskell.
02:57:04 <LordBrain> that sounds like fun
02:59:31 <spark_> he, passing everything to vector reduced memory use by 1/4 (100mb) but seems to have killed all the speed with the boxing/unboxing
03:00:17 <LordBrain> who?
03:00:41 <spark_> who who?
03:01:39 <LordBrain> who he
03:01:51 <spark_> he who
03:01:59 <ivanm> LordBrain: I think he meant as in "heh"
03:02:09 <LordBrain> oh
03:02:17 <spark_> lol
03:02:40 <imeredith> hi all, is there a defacto build system for haskell? just trying to get started
03:02:47 <shachaf> imeredith: Cabal.
03:02:48 <lpvb> cabal
03:02:54 <spark_> yes, cabal
03:02:59 <imeredith> thats what i thought, just making sure
03:03:17 * hackagebot svndump 0.2.0 - Library for reading Subversion dump files  http://hackage.haskell.org/package/svndump-0.2.0 (JohnWiegley)
03:03:39 <ivanm> johnw: what is your purpose behind svndump if I may ask?
03:04:04 <johnw> to convert a subversion repository, with 100% fidelity, into a Git one
03:04:13 <johnw> the code works in C++, this is just an exercise for my Haskelling skills
03:04:29 <tdammers> there is a way involving gitsvn that works well
03:04:45 <imeredith> oh i see, i already have cabal installed from the haskell package, cool
03:05:08 <LordBrain> run cabal update first thing
03:05:15 <imeredith> k
03:05:34 <tdammers> imeredith: look into cabal-dev as well
03:05:50 <imeredith> cabal-dev?
03:05:51 <tdammers> sandboxed cabal, will save you a lot of trouble
03:06:25 <tdammers> you make a sandbox for each project, so that its dependencies do not clutter your global cabal state
03:06:37 <imeredith> as in something like running linux inside a chroot type thing?
03:06:40 <imeredith> ah ok
03:06:42 <Axman6> i think suggesting things like cabal-dev to someone who barely knows what cabal is is silly
03:06:58 <tdammers> don't know
03:07:19 <Tordek> I wrote this https://gist.github.com/3509609 to parse this format: http://tnetstrings.org/
03:07:24 <tdammers> I think using the distro's package manager and cabal-dev only is way saner than plain cabal
03:07:28 <Tordek> any improvements that jump out?
03:07:48 <Tordek> I strongly suspect there must be a way to not re-parse the size constantly
03:07:56 <LordBrain> well i didnt know that, i am grateful for hte suggestion tdammers
03:08:05 <donri> installing/upgrading distro packages can break cabal-dev environments
03:09:04 <ivanm> Axman6: agreed
03:09:12 <donri> cabal-dev solves some problems i've seen beginners have, but it also introduces new ones
03:09:14 <ivanm> especially since there are meant to still be bugs in cabal-dev ghci
03:09:26 <imeredith> tdammers: disto as in apt-get ? im using mac, not sure how that relates
03:09:42 <donri> macports/brew and those?
03:09:45 <imeredith> im not sure how haskell packages work - i come from jvm land
03:09:55 <imeredith> i dont really use brew, although i have it installed
03:10:41 <imeredith> cabal update has finished
03:11:00 <LordBrain> i would use distro stuff, but i am on debian stable, and i like my haskell stuff newer than whatever i expect to find in the repo.
03:11:18 <imeredith> oh so with cabal you dont have individaul projects that download there on deps?
03:11:26 <imeredith> you just have packages that cabal installs
03:11:37 <LordBrain> you can do it both ways
03:11:37 <imeredith> which is why cabal-dev is nice
03:11:38 <donri> project=package, not sure what you mean
03:12:01 <LordBrain> cabal is like apt for  haskell
03:12:10 <imeredith> donri: as in, you are doing an application, and need one version of a lib, and another application and another version of the same lib
03:12:11 <donri> ah yea no, the default with plain cabal-install is a shared per-user package db
03:12:12 <LordBrain> but its also like make
03:12:28 <tdammers> imeredith: don't know how much of haskell there is in macports
03:12:40 <imeredith> you can install everything with cabal though
03:12:41 <imeredith> ?
03:12:43 <donri> imeredith: you can have different versions of the same lib in one package db. cabal will select one that fits your constraints and link against.
03:12:44 <LordBrain> yeah
03:12:48 <LordBrain> well
03:12:56 <LordBrain> you need ghc first
03:13:01 <LordBrain> or some compiler at least
03:13:08 <imeredith> yeah i have ghc
03:13:18 <imeredith> which also installed cabal at the same time
03:13:18 <LordBrain> ok
03:13:22 <imeredith> i think it was the platform thing
03:13:28 <LordBrain> oh yeah, that would do it
03:13:42 <tdammers> yes, haskell-platform includes cabal and a bunch of commonly used libraries
03:14:10 <LordBrain> you run cabal update, and then you can say cabal install whatever-package
03:14:22 <LordBrain> it will download it and compile it
03:14:31 <tdammers> (and all of its dependencies, as needed)
03:14:49 <tdammers> problem is, cabal sometimes breaks when newer versions become available
03:14:53 <imeredith> off topic kind - but if i do a webapp - can you bundle everything up as an executable - or would i need cabal on servers etc
03:14:54 <LordBrain> well, i'm not an expert, but yes it does do some dependency tracking
03:15:12 <ivanm> imeredith: by default GHC does static linking for haskell deps
03:15:18 <tdammers> you don't need cabal on the server
03:15:26 <ivanm> you might need to bundle some C libs (e.g. GMP) but that's about it
03:15:37 <tdammers> you only need the binary and any libraries (OS libraries, not haskell libraries) that you link against
03:15:47 <imeredith> right
03:15:50 <tdammers> and of course, you have to build for the same platform
03:16:03 <tdammers> (so if you build on mac, you can't deploy to a linux server, say)
03:16:14 <LordBrain> on mac ghc does dynamic
03:16:21 <ivanm> oh?
03:16:21 <LordBrain> i think
03:16:28 <imeredith> good to know, i work for cloudbees and am interested in adding it as a runtime, wihch is one of the reasons i want to get started, but i wasnt sure how feasible it was or how it would work :)
03:16:33 <matthiasgorgens1> tdammers: unless you make cross-compiling work.
03:16:35 <ivanm> I take it that's a choice made by whoever builds GHC for macs?
03:16:39 <LordBrain> i think its all dynamic on mac
03:16:41 <tdammers> matthiasgorgens1: of course
03:16:44 <imeredith> regardless of that i want to learn haskell
03:16:44 <ivanm> matthiasgorgens1: that's not going to happen any time soon
03:16:44 <matthiasgorgens1> wasn't cross-compiling promised for ghc 7.4 or so?
03:17:00 <johnw> I'm running on Mac, but it's not linking to anything dynamically, just to system libs and libicon
03:17:01 <johnw> v
03:17:02 <tdammers> I guess setting up a vm is a viable enough option for most people
03:17:09 <matthiasgorgens1> imeredith: good, don't let us discourage you. :o)
03:17:19 <LordBrain> ok, well i dont have a mac here
03:17:39 <LordBrain> dynamic linking was important to the mac port, i recall someone telling me this
03:17:48 <tdammers> it does link dynamically on linux, I know this much
03:17:51 <donri> imeredith: deploying just an executable should be fine if you don't use packages like dyre/hint/plugins and no package is using data-files (if they are you can just deploy those files in the same dir as on the build machine, don't need cabal itself)
03:17:57 <tdammers> (at least it does for libcairo)
03:18:02 <LordBrain> it links dynamically on linux?
03:18:07 <LordBrain> oh
03:18:21 <LordBrain> but that's a binding
03:18:25 <donri> imeredith: alternatively you can use the file-embed package to embed data files inside the executable
03:18:25 <ivanm> LordBrain: you can set dynamic linking by default as an option
03:18:31 <tdammers> well, yes.
03:18:32 <imeredith> donri: ok, well ill have a look at that in depth more when i have something to deploy hehe
03:19:46 <donri> imeredith: if you want to build such a web app i recommend happstack; snap and yesod make more assumptions about the deployment/server setup and are harder to just deploy as one single executable
03:20:03 <donri> @where web
03:20:03 <lambdabot> http://happstack.com/ http://snapframework.com/ http://yesodweb.com/
03:20:07 <ivanm> donri: or one of the lighter ones ?
03:20:11 <donri> ivanm: or that :)
03:20:22 <ivanm> e.g. bird
03:20:25 <donri> stupid lambdabot, twice i've updated that @where web thing
03:20:29 <donri> and it keeps forgetting
03:20:56 <ivanm> someone with privileges needs to do a @flush to make sure it's stored
03:21:02 <donri> aha
03:21:16 <imeredith> um how do i do a simple hello world app with cabal, googling for cabal haskell hello world results in nothing lol
03:21:19 <ivanm> or else get lambdabot to shut down cleanly rather than crash
03:21:24 <ivanm> @hackage pony
03:21:24 <lambdabot> http://hackage.haskell.org/package/pony
03:21:33 <ivanm> wait, there is a hello world package I believe
03:21:44 <ivanm> @hackage hello
03:21:44 <lambdabot> http://hackage.haskell.org/package/hello
03:21:46 <ivanm> imeredith: ^^
03:21:56 <ivanm> there used to also be an example on the wiki I believe
03:22:02 <tdammers> mkdir project
03:22:04 <tdammers> cd project
03:22:05 <donri> @where+ web #happs - http://happstack.com/  |  #snapframework -  http://snapframework.com/  |  #yesod - http://yesodweb.com/
03:22:05 <lambdabot> Nice!
03:22:07 <tdammers> cabal-dev init
03:22:11 <LordBrain> http://hackage.haskell.org/trac/ghc/wiki/SharedLibraries/PlatformSupport?redirectedfrom=DynamicLinking
03:22:12 <ivanm> tdammers: or cabal init
03:22:17 <donri> ivanm: who can @flush?
03:22:32 <ivanm> donri: ummm... from memory, gwern, Cale and others
03:22:33 <tdammers> ivanm: heh, motor memory ;)
03:22:51 <tdammers> and then edit the resulting .cabal file to suit your needs
03:22:56 <tdammers> then cabal install
03:23:00 <donri> @flush
03:23:00 <lambdabot> Not enough privileges
03:23:02 <donri> :(
03:23:20 <imeredith> ivanm: your name is confusing me heh
03:23:38 <ivanm> imeredith: why?
03:23:47 <hpaste> “http://www.youtube.com/watch?v=wXtlR95cjms” pasted “http://www.youtube.com/watch?v=wXtlR95cjms” at http://hpaste.org/73892
03:24:03 <hpaste> “http://www.youtube.com/watch?v=wXtlR95cjms” pasted “ free hulu plus accounts” at http://hpaste.org/73893
03:24:13 <ivanmeredith> ivanm: now does it make sense?
03:24:29 <ivanm> heh
03:24:44 <hiptobecubic> clever spam
03:24:48 <donri> reported
03:25:00 <ivanm> my surname is different though ;)
03:25:14 <ivanm> and I believe I've registered ivanm_ as my backup nick...
03:25:20 <hiptobecubic> seems like hpaste could be pretty easily modified to disallow urls in titls and subjects
03:25:20 <donri> the miljenovic falcon
03:25:21 <hiptobecubic> titles*
03:25:33 <ivanm> no, ivan_m is my backup
03:25:34 <ivanm_> tdammers: i did cabal init, how do i install the hello package? or should i have seltected it from the menu, wasnt sure of what it wanted
03:25:45 <ivanm> hiptobecubic: talk to chrisdone
03:25:55 <imeredith> ivanm: i used to use ivan___ or ivan____
03:26:03 <donri> hiptobecubic: it already has a surprisingly effective anti-spam feature
03:26:13 <hiptobecubic> donri, what feature is that?
03:26:25 <donri> hiptobecubic: there's an email field that should be left empty
03:26:32 <ivanm> being less well known than other paste sites ;)
03:26:40 <donri> i think javascript hides it
03:27:10 <LordBrain> ool
03:27:21 <donri> or maybe just a hidden input, but i suspect spam bots are smart enough to filter out hidden inputs?
03:27:25 <LordBrain> but i guess that bot out smarted it somehow
03:28:11 <donri> yea, but i haven't seen spam on hpaste since the email field was added :)
03:28:15 <hiptobecubic> nice
03:28:31 <LordBrain> until now you mean
03:29:02 <donri> .amelie-spam{display:none}  ahh just css to hide it
03:29:15 <donri> LordBrain: well duh
03:29:21 <donri> just saying it works surprisingly well
03:29:28 <hiptobecubic> ah yeah, i see it
03:30:27 <LordBrain> there will be an arms race effect eventually, until the spam bots develop intelligence and create terminators
03:30:37 <merijn> Is it preferable to enable language extensions on a per-file basis or package wide (using cabal)?
03:30:51 <LordBrain> i'd do it per file
03:30:53 <ivanm> @google xkcd youtube spam
03:30:54 <lambdabot> http://www.youtube.com/watch?v=jOWntIdegws
03:30:59 <donri> when spam bots are intelligence, so will spam filters be
03:30:59 <ivanm> merijn: per-file
03:31:01 <kris`> Hi guys! I am having some trouble with Hudaks "School of Expression" graphics library - it's blocking on input operations. Does anyone have any insight on this?
03:31:08 <ivanm> bah, that's not the link I wanted lambdabot
03:31:20 <sipa> bad AI, bad!
03:32:19 <donri> hiptobecubic: url in title is useful because there's a script copying pastes from pastebin.com to hpaste.org when linked in here (i think it's mauke?)
03:32:34 <ivanm> yeah
03:32:39 <ivanm> but it's still a PITA
03:32:47 <ivanm> s/still//
03:32:56 <ivanm> who cares where the paste _is_?
03:32:59 <merijn> ivanm: What would be a valid reason to use cabal instead of per file? (Also, per file on a single line, or one line per extension?)
03:33:18 <ivanm> merijn: the idea behind listing them in the .cabal file is for documentation
03:33:54 <ivanm> but there's the possibility that applying the wrong extension tot he wrong file could change some semantics or make it not-compile (e.g. OverloadedStrings to a file where literal strings are actually _meant_ to be strings)
03:34:19 <ivanm> I also prefer one overall LANGUAGE pragma, split over multiple lines only if there are enough extensions to warrant it
03:34:34 <ivanm> I don't like the separate-pragma-per-extension approach; it looks untidy ;)
03:34:52 <imeredith> hmm i followed http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program#Add_a_build_system but getting
03:34:55 <imeredith> project-0.1.0.0 failed during the final install step. The exception was:
03:34:55 <imeredith> ExitFailure 1
03:35:01 <imeredith> oh
03:35:05 <imeredith> maybe permissions?
03:35:14 <ivanm> depends: where is it?
03:35:33 <imeredith> hmm no
03:35:40 <imeredith> its just in ~/project
03:35:44 <merijn> ivanm: I was just wondering, since Yesod seems to default to having all the extensions in the cabal file with none in the various sourcefiles
03:35:50 <ivanm> you don't need the --prefix and --user flags for cabal-install; they're enabled by default
03:35:53 <imeredith> and im running cabal install --prefix=$HOME --user
03:35:54 <merijn> (Scaffolded Yesod sites, that is)
03:36:02 <imeredith> oh
03:36:03 <ivanm> merijn: they probably need them for every file
03:36:11 <ivanm> imeredith: it shouldn't hurt though
03:36:16 <ivanm> imeredith: try it again with -v3
03:36:26 <merijn> ivanm: Clearly not, since I'm using a stripped down version of the scaffolded site as skeleton for my own :p
03:36:42 <ivanm> *shrug*
03:36:45 <ivanm> ask snoyman then :)
03:37:00 <ivanm> having it in every file also makes it explicit
03:37:08 <merijn> I just wanted to poll people here on the community preferred style :p
03:37:11 <ivanm> and explicit > implicit
03:37:19 <imeredith> ivanm: it was because i didnt have a LICENSE file - which is weird because cabal init doesnt force you to create one
03:37:28 <ivanm> (unless you're sorting lexicographically or something :p)
03:37:34 <donri> ivanm: i use separate pragmas because they're easier to sort/scan/read and things like hlint point to relevant lines (which show up as warning/error icons in a column in vim for me)
03:37:40 <ivanm> imeredith: huh... I thought it created it for you :/
03:37:43 <ivanm> which license?
03:37:56 <donri> and easier to add/delete separate pragmas
03:37:56 <ivanm> donri: sure
03:38:04 <ivanm> but it doesn't look as pretty! :p
03:38:18 * hackagebot Craft3e 0.1.0.6 - Code for Haskell: the Craft of Functional Programming, 3rd ed.  http://hackage.haskell.org/package/Craft3e-0.1.0.6 (SimonThompson)
03:38:37 <donri> listing extensions in .cabal isn't just documentation, that actually activates them for all modules in that package
03:38:58 <merijn> donri: Yeah, I know. I was just wondering whether that's considered good or bad
03:39:01 <quicksilver> but it does feel annoying that the modules then aren't self-contained
03:39:04 <arbn> Is there some way to start a GHCi instance with all the language extensions set in a given cabal file?
03:39:06 <quicksilver> I don't know what I think about that.
03:39:29 <imeredith> ivanm: it gives you the options, default is none
03:39:31 <arbn> I want a quicker way to get an interpreter shell with all of my project imported.
03:39:35 <merijn> quicksilver: Well, in this case it's a Yesod site, so the modules aren't self-contained anyway
03:39:43 <carpi> how is the type Int defined? all i see when i do ":i Int" is "data Int = GHC.Types.I# GHC.Prim.Int#    -- Defined in `GHC.Types`"
03:39:52 <mauke> carpi: what
03:39:56 <tdammers> arbn: I use cabal-dev ghci
03:39:57 <ivanm> imeredith: oh, that's weird; I thought it defaulted to BSD3
03:40:10 <tdammers> not sure if plain cabal has the same - probably does though
03:40:10 <ivanm> carpi: it's an internal detail you're not meant to know ;)
03:40:19 <imeredith> maybe it did but i pressed 0, cant remember
03:40:20 <mauke> carpi: that *is* the definition of Int
03:40:21 <ivanm> tdammers: nope
03:40:29 <merijn> carpi: It uses primitives built into the compiler
03:40:33 <ivanm> tdammers: but they're working on subsuming the features of cabal-dev into cabal-install
03:40:42 <merijn> carpi: It's kinda like asking how int is defined in GCC
03:40:58 <ivanm> merijn: they use cheese, right?
03:41:28 <carpi> ah okay ... i was thinking i would see something like "data Int = 0 | 1 | 2 | 3 ....."
03:41:29 <arbn> Yet another reason to remember to use cabal-dev for *all* my projects.
03:41:35 * arbn sighs
03:41:42 <imeredith> ivanm: thanks for the help
03:41:43 <ivanm> arbn: why?
03:41:49 <merijn> carpi: I believe the standard guarantees Int to support at least 30 bit integers? (Someone correct me if I'm wrong)
03:41:53 <ivanm> ghci load/file/I/want.hs
03:42:00 <ivanm> merijn: 22 I believe
03:42:03 <ivanm> something like that
03:42:21 <ivanm> in practice it's 32 bits on 32bit architectures and 64bits on 64bit architectures
03:42:22 <donri> carpi: int is signed
03:42:29 <arbn> ivanm: It's a pain to type all the language extensions as GHCi arguments.
03:42:38 <ivanm> arbn: shove them up the top of your file then
03:42:41 <tdammers> ivanm: that doesn't load all the extensions and packages from your .cabal file though
03:42:43 <ivanm> which is why it's recommended!
03:42:51 <merijn> carpi: A definition like that would be horribly inefficient :p
03:42:56 <ivanm> tdammers: why load all the packages?
03:42:57 <Shapeshifter> Mh, how could I break a long line such as this? map (\n -> "0x" ++ (map toUpper $ showIntAtBase 16 intToDigit n "")) [63788,63800..64184]
03:43:13 <merijn> carpi: In fact, defining Int on a 64bit machine like that might result in the definition not fitting on hard disk :p
03:43:21 <tdammers> ivanm: to have them available while you play with your code?
03:43:26 <mauke> Shapeshifter: map (printf "0x%X") [63788,63800..64184]
03:43:31 <merijn> Shapeshifter: use where/let to split part into a separate definition
03:43:36 <ivanm> tdammers: I don't understand what loading all packages even _means_
03:43:44 <ivanm> every single installed package?
03:43:55 <ivanm> what happens when mtl clashes with monads-tf ?
03:43:55 <carpi> merijn: makes sense.. thinking about it. So this is one of those things that are simply a part of the compiler itself
03:44:00 <tdammers> I meant the ones listed in the .cabal file
03:44:08 <merijn> carpi: Yup
03:44:12 <ivanm> tdammers: they get loaded when you load a file that uses them...
03:44:14 <donri> arbn: ghci looks for a .ghci file in the working directory though (but not cabal-dev ghci)
03:44:21 <Shapeshifter> mauke: oh dear
03:44:28 <ivanm> donri: or in ~/.ghci
03:44:34 <quicksilver> Shapeshifter: or.. just break the line wherever you feel like it
03:44:41 <donri> ivanm: yea but the point is for per-project :)
03:44:54 <quicksilver> don't follow merijn's advice and use where/let; naming things you only use once is ugly.
03:45:07 <quicksilver> break after ++ and again after )), possibly
03:45:14 <ivanm> quicksilver: unless it's a very complicated function and it improves readability...
03:45:26 <quicksilver> sure, unless that
03:45:28 <tdammers> ivanm: not if you're using cabal-dev in the first place
03:45:33 <quicksilver> but it never improves readability
03:45:36 <tdammers> but then, that wasn't the question
03:45:37 <quicksilver> so that never happens
03:45:42 <quicksilver> hurrah for vacuous implication :)
03:45:42 <tdammers> (I'll shut up now)
03:45:55 <ivanm> tdammers: why load every module in every dependency? :/
03:46:08 <arbn> tdammers: This is a Yesod project, and there seem to be piles of reasons to use cabal-dev with Yesod. This is just one more. :)
03:46:10 <ivanm> quicksilver: I believe I have a counter argument if you like... :p
03:46:21 <quicksilver> ivanm: I'm not being entirely serious.
03:46:47 <ivanm> quicksilver: no, really? ;)
03:46:47 <quicksilver> but composing expressions is powerful and natural and there is no reason per se to be afraid of large ones
03:46:53 <ivanm> sure
03:47:17 <ivanm> I've had a couple of cases though where I was implementing imperative-listed algorithms, and I couldn't split it up into sensible individual functions any more
03:47:17 <quicksilver> code like "f = a b c d where a = f g; b = h i; c = j k; d = l m;" annoys me
03:47:34 <matthiasgorgens1> quicksilver: sometimes you have to name things you only use once.  at least until we get case-lambdas.
03:47:38 <ivanm> quicksilver: sure
03:47:44 <quicksilver> didn't really mean to use 'f' twice there
03:47:49 <quicksilver> but that kind of thing.
03:47:58 <quicksilver> matthiasgorgens1: you never 'have' to.
03:48:06 <matthiasgorgens1> quicksilver: sure, you do.
03:48:18 <quicksilver> matthiasgorgens1: but yes there are some cases without case-lambda where it may look quite a bit nicer.
03:48:22 <quicksilver> matthiasgorgens1: example?
03:49:43 <imeredith> is [Char] the same as String?
03:49:50 <mauke> imeredith: yes
03:49:50 <quicksilver> yes, imeredith
03:50:01 <imeredith> ok thanks, the compiler seemed to confirm that
03:50:03 <hpaste> “Matthias Goergens” pasted “Silly example” at http://hpaste.org/73894
03:50:10 <ivanm> matthiasgorgens1: I believe we get anonymous case statements in 7.6
03:50:11 <mauke> quicksilver: \m -> case m of Nothing -> 1; Just n -> n
03:50:14 <matthiasgorgens1> quicksilver: please try to get rid of x in the silly example.
03:50:43 <matthiasgorgens1> mauke: for that, you can use (fromMaybe 1)
03:50:45 <ivanm> matthiasgorgens1: use a better variable name?
03:51:03 <mauke> matthiasgorgens1: assume you don't have fromMaybe in the library
03:51:05 <ivanm> matthiasgorgens1: but I don't believe that's what quicksilver was referring to
03:51:09 <matthiasgorgens1> ivan, that's a good idea.  but the point was naming stuff you only use once.
03:51:15 <ivanm> mauke: maybe 1 id :p
03:51:16 <mauke> matthiasgorgens1: alternatively, assume I used a new type isomorphic to Maybe
03:51:22 <matthiasgorgens1> mauke: write fromMaybe.  You are going to use it more than once.
03:51:24 <mauke> ivanm: no library functions
03:51:32 <quicksilver> matthiasgorgens1: oh, right. we were slightly at cross purposes.
03:51:33 <matthiasgorgens1> mauke: why?
03:51:39 <ivanm> mauke: I would define maybe then and use that :p
03:51:51 <quicksilver> matthiasgorgens1: I was talking about adding let/wheres to perfectly sensible expressions pulling out subexpressions which are only used once.
03:51:56 <quicksilver> matthiasgorgens1: you are of course right.
03:51:56 <Shapeshifter> mauke: how do I actually get your solution to work? after import Text.printf and map (printf "0x%X") [63788,63800..64184] I get an "Ambiguous type variable `b0' in the constraint: (PrintfType b0) arising from a use of `printf'"
03:52:00 <mauke> ivanm: then 'maybe' is the identifier you only use once
03:52:08 <matthiasgorgens1> ivan, (maybe) is overkill, fromMaybe is enough, if you second argument to (maybe) is id.
03:52:17 <matthiasgorgens1> quicksilver: oh, yeah.
03:52:22 <ivanm> matthiasgorgens1: note that ivanm /= ivan :)
03:52:34 <mauke> Shapeshifter: how are you using the results of map?
03:52:44 <ivanm> Shapeshifter: give it a type signature
03:52:46 <matthiasgorgens1> that's basically only useful for giving extra names to stuff (for documentation).  and for giving type annotations (for documentation that the compiler checks for you.)
03:52:49 <mauke> hmm
03:52:59 <matthiasgorgens1> ivanm, oh, that's too complicated with all the names. :o)
03:53:00 <mauke> it thinks the PrintfType is ambiguous?
03:53:06 <Shapeshifter> mauke: I want to see it in ghci
03:53:18 * hackagebot Craft3e 0.1.0.7 - Code for Haskell: the Craft of Functional Programming, 3rd ed.  http://hackage.haskell.org/package/Craft3e-0.1.0.7 (SimonThompson)
03:53:30 <mauke> Shapeshifter: try adding a :: [String] annotation to the whole thing
03:53:31 <ivanm> matthiasgorgens1: smart IRC clients will tab-complete to the most recently used nick with that prefix...
03:53:42 <mauke> if that doesn't work, [63788,63800..64184 :: Int]
03:53:49 <matthiasgorgens1> ivanm: my client isn't smart enough. :o)
03:53:53 <Shapeshifter> mauke: ah yes, that works. Thanks
03:55:40 <imeredith> so getArgs >>= print . haqify . head (haqify being String -> String) is basically saying print(haqify(head(getArgs))) ? (i know >>= is bind, just learnt what . is
03:55:56 <ivanm> imeredith: no
03:56:00 <shachaf> imeredith: Not quite.
03:56:02 <mauke> well, sort of yes
03:56:06 <ivanm> you can't use getArgs there
03:56:12 <ivanm> otherwise, yes
03:56:15 <mauke> yeah, the problem is the nature of getArgs
03:56:16 <imeredith> ?
03:56:17 <shachaf> imeredith: It's something like do { args <- getArgs; print (haqify (head args))
03:56:18 <shachaf> }
03:56:26 <ivanm> @type getARgs
03:56:27 <lambdabot> Not in scope: `getARgs'
03:56:28 <ivanm> bah
03:56:31 <ivanm> @hoogle getArgs
03:56:31 <lambdabot> System.Environment getArgs :: IO [String]
03:56:31 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
03:56:32 <imeredith> getArgs is IO [String] ?
03:56:34 <mauke> yes
03:56:35 <ivanm> yup
03:56:37 <mauke> it's not a list
03:56:51 <ivanm> it's an action that returns a list
03:57:00 <imeredith> yeah but thats why >>= is used
03:57:15 <shachaf> Right.
03:57:36 <shachaf> So it's also like "getArgs >>= (\args -> print (haqify (head args)))"
03:57:45 <imeredith> right
03:58:12 <imeredith> >>= is a -> M b right?
03:58:27 <imeredith> otherwise known as flatMap in scala
03:58:40 <quicksilver> M a -> (a -> M b) -> M b
03:58:42 <quicksilver> rather
03:58:47 <quicksilver> but that is possibly what you meant.
03:58:49 <mauke> :t concatMap
03:58:50 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
03:58:52 <imeredith> yeah it is :)
03:58:58 <mauke> :t flip concatMap
03:58:59 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
03:59:07 <mauke> :t (>>=) `asTypeOf` flip concatMap
03:59:08 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
03:59:15 <kammikadze> http://freeleaguecodes.com/ref?id=xio2mls2np
03:59:57 <imeredith> a major goal of learning haskell is so i can read all the haskell docs on category thoery stuff lol, there isnt so much in scala
04:00:10 <ivanm> asTypeOf is definitely a useful function
04:00:39 <timthelion> imeredith: honestly category theory is simpler without all the haskell stuff.
04:00:46 <mauke> asTypeOf : const :: ($) : id
04:00:47 <ts33kr> Hey guys. I have a newbie question re the Data.Typeable. Is there a way to restrict TypeRep, to be sure that it is a TypeRep only of data types that are instances of a certain type class? That is, something like this (pseudocode, no real type parameter) "type RplSpec = (Rpl a) => TypeRep a"?
04:01:21 <shachaf> You probably shouldn't be using Data.Typeable. :-)
04:01:25 <ts33kr> It's most likely there is a saner way than tapeable.
04:01:26 <ts33kr> Yeah...
04:01:39 <ivanm> especially if you're tempted to make a custom instance
04:01:40 <ts33kr> shachaf, What could I use?
04:01:48 <shachaf> ts33kr: I have no idea what you're doing.
04:02:03 <imeredith> timthelion: well, its also about applying it to problems - and in scala its a pita, haskell seems a lot better for that
04:02:55 <ts33kr> shachaf, Fair enough. Let me try to example.
04:03:04 <ts33kr> Or rather explain.
04:03:38 <watermind> been looking at Parallel Haskell, and I've seen 2 different ways to go about parellalizing the evaluation of two values.  1. using par and pseq    2. using two pars
04:04:09 <rtharper> watermind: Par monad?
04:04:17 <ts33kr> shachaf, I have a type class X, instances of this type class should provide a list of other types (that are instances of X as well) that is "connected" to this instance, by the means of instance method, defined in X. Does it make any kind of sense?
04:04:20 <shachaf> watermind: There isn't really any situation where you could either use par twice or par+pseq.
04:04:31 <shachaf> ts33kr: I think maybe you should explain at a higher-level.
04:04:37 <shachaf> ts33kr: Are you sure you need a type class in the first place?
04:04:50 <ts33kr> Yeah, type class is a must here.
04:04:54 <mauke> why?
04:04:56 <shachaf> Why?
04:05:14 <watermind> rtharper: no just Controll.Parallel or Eval Monad haven't seen Par monad yet
04:05:25 <ts33kr> shachaf, I'' try in a higher level, give me a sec. :)
04:05:27 <rtharper> watermind: http://hackage.haskell.org/packages/archive/monad-par/0.1.0.1/doc/html/Control-Monad-Par.html
04:05:44 <shachaf> watermind: You should look at JaffaCake1's slides on concurrent and parallel Haskell.
04:05:47 <shachaf> They're quite good.
04:05:59 <shachaf> watermind: http://community.haskell.org/~simonmar/slides/cadarache2012/
04:06:23 <watermind> shachaf: maybe I didn't explain correctly, I meant par to creat a spark to evaluate one value, and then pseq to establish the evaluation order to make sure the second value is requested first
04:06:53 <watermind> shachaf: the other approach seems to just generate a spark for each value, and not bother with establishing order
04:06:57 <ts33kr> shachaf, So, say I have a command processor. Each command is a data type, which is an instance of Command type class. In this type class I have a rplSpec method, which should specify a list of possible replies. Here is the thing, replied are commands as well. So each command can be responded with another command. (kind of like IRC, where command are replied to with commands, only with ints instead of strings as names).
04:07:17 <mauke> ts33kr: why are commands types?
04:07:21 <shachaf> ts33kr: Are you sure you need a different type for each command?
04:07:31 <watermind> rtharper: shachaf: thanks for the sources, I'll check them out
04:08:01 <mauke> ts33kr: and IRC replies are not commands
04:08:06 <rtharper> if performance is what you're after, I beleive the Par monad is the most peformant
04:08:07 <ts33kr> Well, considering that each command can have different morph, depending on what parameters are used, it made me think that it would be good to model them as types. Was I wrong?
04:08:08 <rtharper> performant*
04:08:13 <shachaf> (Why do I even bother saying anything when mauke's in the channel?)
04:08:14 <mauke> you don't reply to replies
04:08:19 * hackagebot graphviz 2999.14.1.0 - Bindings to Graphviz for graph visualisation.  http://hackage.haskell.org/package/graphviz-2999.14.1.0 (IvanMiljenovic)
04:08:40 <mauke> ts33kr: you could also have a single Command type
04:08:48 <ts33kr> mauke, Well, they are messages, that conform to the same grammar as commands, but have numeric "command names". Yes, I know that. :)
04:08:54 <watermind> rtharper: I've heard so, right now I'm going through the slides for the Chalmers' course, I think I'm getting there
04:09:44 <ts33kr> mauke, Not very handy. I need to be able to provide new commands, from external library. Or rather this library to be used by external applications/libraries.
04:10:03 <oneb> what's the strict version of map called?
04:10:14 <ivanm> oneb: what strict version of map?
04:11:04 <oneb> ivanm: the one that will fix my memory leak :P
04:11:08 <shachaf> ts33kr: OK, but that doesn't mean you need a type class.
04:11:16 <ts33kr> But now it occurred to me that I probably should have used data instead of type class for the command specification, rather than a command itself. This is probably what you (mauke) meant.
04:11:38 <ivanm> oneb: I doubt that map is the cause of the leak
04:11:46 <ivanm> more likely how you consume the result
04:11:49 <shachaf> oneb: You usually want map to be lazy.
04:11:52 <ivanm> or possibly the mapping function itself
04:12:04 <shachaf> ts33kr: The FAQ talks about this a little bit:
04:12:06 <shachaf> @where faq
04:12:06 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:12:12 <shachaf> 5.4
04:12:31 <oneb> I don't consume the result, I return the resulting list. I already tried putting a bunch of "join deepseq"s in the function I'm mapping...
04:12:54 <ts33kr> shachaf, Thanks!
04:12:54 <shachaf> oneb: Randomly throwing seqs and deepseqs isn't going to do you much good.
04:13:19 * hackagebot Graphalyze 0.13.0.1 - Graph-Theoretic Analysis library.  http://hackage.haskell.org/package/Graphalyze-0.13.0.1 (IvanMiljenovic)
04:13:21 <ivanm> oneb: has profiling revealed where the leak is?
04:13:56 <oneb> heh, a deepseq I used on a hunch solved the mem leak I was asking about yesterday
04:14:21 <oneb> no, haven't profiled yet
04:14:34 <shachaf> My computer was making annoying beeping noises, so I hit it with a hammer for a while and it stopped.
04:15:03 <quicksilver> shachaf: Pro Tip: don't try that with your boss
04:15:42 <ivanm> @remember shachaf My computer was making annoying beeping noises, so I hit it with a hammer for a while and it stopped.
04:15:42 <lambdabot> It is forever etched in my memory.
04:16:19 * shachaf suspects that'll make no sense without context.
04:16:30 <shachaf> (I'm not sure that it makes much sense with context, for that matter.)
04:16:38 <ivanm> does to me
04:16:46 <ivanm> and why not confuse people? ;)
04:17:25 <ts33kr> shachaf, What if I use GADTs? Will that be terrible from the idiomatic perspective?
04:17:38 <ts33kr> (With an existential variable)
04:17:50 <shachaf> ts33kr: With a type class, you mean?
04:17:56 <ts33kr> Yeah.
04:18:00 <shachaf> You probably shouldn't. :-(
04:18:19 * hackagebot SourceGraph 0.7.0.3 - Static code analysis using graph-theoretic techniques.  http://hackage.haskell.org/package/SourceGraph-0.7.0.3 (IvanMiljenovic)
04:18:56 <quicksilver> the first rule of typeclasses is, if you think you need a typeclass, you don't.
04:19:02 <quicksilver> typeclasses are not an abstraction
04:19:03 <ivanm> with this release I think I've finally worked out a way of preventing people from emailing me with messages about "why is SourceGraph throwing errors about pipes?!?"
04:19:14 <quicksilver> they are not a general purpose tool for constructing abstract interfaces.
04:19:19 <ivanm> quicksilver: wait, so all the typeclasses I've written are _wrong_?!?!? :o
04:19:19 <quicksilver> They are a device for overloading.
04:19:38 <ivanm> though I assume you're talking more about cases like the classy prelude by snoyman & co.?
04:19:38 <ts33kr> shachaf, Got it, thanks. :)
04:19:52 <quicksilver> They are an device whereby the compiler can select which code to generate for a particular function based on the types of the parameters
04:19:52 <shachaf> ts33kr: It might be educational to write it once with and once without.
04:19:56 <quicksilver> often at compile-time
04:20:17 <quicksilver> that is basically their only purpose - type-directed code selection.
04:20:18 <nand`> so what's a good, lightweight pure-haskell alternative to regexen? To be specific, I'm matching something like ‘closes #([0-9]+)|resolves #([0-9]+)|fixes #([0-9]+)’, I figure something with an applicative style would work well here - with Alternative to replace choice and *> to replace the capture; but I wouldn't know how to use any of the parsing libraries I've seen to ‘search for an arbitrary parse
04:20:20 <nand`> at any position’; other than something inefficient like map parse . tails
04:20:25 <ts33kr> shachaf, Yeah, I proably going to do it anyway and see what the terrible outcome will be. :)
04:20:26 <shachaf> quicksilver: I'd call fmap an abstraction.
04:20:33 <shachaf> And all the things in Control.Monad.
04:20:36 <ivanm> nand`: use a parsing library?
04:20:45 <quicksilver> shachaf: I didn't say they are never used in the construction of abstractions.
04:20:53 <nand`> ivanm: that's too general to be of use, sorry
04:21:09 <ivanm> how is it too general?
04:21:09 <quicksilver> shachaf: I said "they are not a general purpose tool for constructing abstract interfaces"
04:21:11 <nand`> regex libraries are ‘parsing libraries’
04:21:13 <shachaf> quicksilver: Anyway I shouldn't be arguing with you about that because I agree with you. :-)
04:21:18 <nand`> ivanm: because I still don't know what I could use
04:21:20 <ivanm> nand`: find, use a combinator parsing library
04:21:32 <ivanm> polyparse, parsec, attoparsec, trifecta, etc.
04:21:49 <ivanm> even Text.Read (or wherever the GHC replacement for ReadS is implemented) if you want
04:21:56 <ivanm> s/find/fine/
04:22:01 <ts33kr> shachaf, One quick q. If I was to use a GADT with exist. var, could I make an infix type constructor? So that instead of "RplSpec Ok" I have something like "::: Ok"? Or maybe you can guide me towards something better to achieve this syntax sugar?
04:22:43 <shachaf> I don't understand what you're asking.
04:23:00 * shachaf has the feeling ts33kr is going to do the existential type thing no matter what people say. :-)
04:23:21 * hackagebot Craft3e 0.1.0.8 - Code for Haskell: the Craft of Functional Programming, 3rd ed.  http://hackage.haskell.org/package/Craft3e-0.1.0.8 (SimonThompson)
04:23:27 <ts33kr> Guilty as charged. But hey, you have to learn on your own mistakes, right? :)
04:23:47 * nand` did that as well once, then he started tripping over errors like ‘my brain just exploded’
04:23:54 <nand`> a fun first experience that was
04:24:27 <ts33kr> What I was asking is basically, can I make an infix data constructor, so that I can do a syntax sugar like "::: OkCommand", instead of "RplSpec OkCommand"? Or do I have to have * -> * kind for infix DC to work?
04:24:48 <shachaf> "::: OkCommand" on its own is a syntax error.
04:24:59 <ivanm> what is ::: ?
04:25:01 <shachaf> I don't know what you're asking, but you can always make an operator.
04:25:02 <ts33kr> Got it. So only binary is allowed, right?
04:25:12 <ivanm> oh, infix data constructor
04:25:36 <ts33kr> shachaf Can I make an infix operator that is unary?
04:25:38 <ivanm> well, if it's _infix_ you need n >= 2
04:25:39 <nand`> only binary operators are supported in Haskell, for both types and values
04:25:47 <ts33kr> Ok, got it, thanks.
04:25:52 <shachaf> ts33kr: No. But you can make a function...
04:25:53 <nand`> but there's a language extension that allows you to somewhat use postfix operators on the value level
04:25:58 <shachaf> "foo x" -- "foo" is a unary operator!
04:26:23 <ivanm> shachaf: well, it's not an operator in terms of how the report classifies operators, is it?
04:26:29 <ivanm> since it isn't composed solely of symbols...
04:26:50 <shachaf> Yes.
04:27:57 <ts33kr> Right, got it. Basically just something like (<::) :: RplSpec.
04:28:03 <ts33kr> shachaf, Perfect. Thanks.
04:30:57 <quicksilver> the report takes the rather unusual (mathematically speaking) terminology that an 'operator' is used for infix/binary functions.
04:31:14 <quicksilver> I'm not really sure it was the best choice of terminology in retrospect.
04:31:37 <ts33kr> shachaf, By the way, does Typeable have any special support from the compiler?
04:31:47 <ivanm> quicksilver: what would you have used to distinguish symbol-based infix functions from prefix ones with at least one alphanumeric character?
04:32:03 <quicksilver> ts33kr: the compiler automatically generates the instances
04:32:04 <edwardk> ts33kr: just DeriveDataTypeable
04:32:10 <quicksilver> ivanm: "symbolic identifiers" ?
04:32:19 <quicksilver> "infix identifiers" ?
04:32:24 <kaos> Hi, I'm looking for a nice way to periodically flushing data to a database, i.e., basically a timer that has some kind of callback that gets called every interval 't' etc...
04:32:25 <ivanm> doesn't quite roll off the tongue as well though... ;)
04:32:28 * edwardk is sitting here hand writing a bunch of Typeable isntances as we speak
04:32:38 <ivanm> edwardk: :o
04:32:42 <shachaf> edwardk: Don't tell Robert Harper.
04:32:53 <shachaf> (What are you writing them for? Some lens thing?)
04:32:56 <quicksilver> kaos: forever $ flushData >> threadDelay 5000
04:33:00 <ivanm> shachaf: let's make it simple: dont' tell Robert Harper _anything_! :p
04:33:04 <merijn> kaos: How precise do you want it to be?
04:33:09 <quicksilver> kaos: in a separate thread, presumably.
04:33:36 <kaos> quicksilver: that seems like it could work
04:33:37 <merijn> kaos: If you just want "roughly every t" then quicksilver's solution is simplest
04:33:47 <edwardk> shachaf: started toying with a library full of polykinded functors, indexed (co)monads, etc.
04:33:49 <merijn> Just throw a forkIO in front of it :p
04:34:05 <edwardk> shachaf: but i figured i wanted to actually do all the instances correctly
04:34:09 <kaos> merijn: yeah, 'roughly' should be all right :-)
04:34:41 <kaos> quicksilver: thanks :)
04:35:08 <ivanm> edwardk: are you saying that GHC doesn't make the instances correctly?
04:35:40 <edwardk> ivanm: ghc can't generate instances for GADTs or for types that type higher kinded type parameters
04:35:46 <ivanm> ahhhh, duh
04:35:46 <edwardk> er types that take
04:35:46 <quicksilver> kaos: as long as there aren't any concurrency issues.
04:35:57 <quicksilver> can 'flushData' run safely in parallel with whatever else you're doing?
04:36:05 <edwardk> every data type in this package so far is one or the other ;)
04:36:06 <quicksilver> (where it will it get its snapshot of current state?)
04:36:22 <quicksilver> the answer might well be 'yes', especially if you're using immutable/persistent data types.
04:36:29 <edwardk> also, everything here is polykinded, and typeable doesn't work for polykinded types
04:36:38 <ivanm> quicksilver: otherwise wrap it in some MVar call or something to indicate whether it's safe to flush or not?
04:38:01 <quicksilver> ivanm: or just run it in the main thread, perhaps, at that point. Who knows.
04:38:10 <quicksilver> too many questions about how the program is structured :)
04:38:17 <ivanm> yeah
04:38:18 <edwardk> pchiusano: ping
04:38:37 <pchiusano> edwardk: hi
04:39:18 <edwardk> figured that might make your machine ding if the pm's didn't ;)
04:40:22 <kaos> quicksilver: I'm reading a stream of objects over network - but my database (redis) isn't fast enough to keep up, so I'm basically gonna stach an in memory counter in an MVar and use your flushData solution to update the db
04:40:35 <quicksilver> sounds good to me kaos
04:40:43 <quicksilver> the MVar will handle your synchronoisation then.
04:41:00 <kaos> cool :)
04:41:37 <pchiusano> edwardk: what's going on?
04:41:52 <edwardk> check /msg ;)
04:42:13 <Peaker> do strict fields generally improve performance even when not unpacked?
04:42:22 <Peaker> (do they remove the lazy thunk wrapping or such?)
04:45:06 <quicksilver> no
04:45:16 <quicksilver> remoging that wrapping is what 'unpacking' means
04:46:16 <Peaker> thanks..
04:47:49 <quicksilver> they can still improve performance though
04:47:53 <quicksilver> just not for that reason.
04:47:58 <nand`> ivanm: I looked into some of your suggestions, in particular attoparsec; and wrote a parser for the specific sub-string I am matching - but now I'm a bit stumped, because I don't know how to use it to find a match. My first thought was something like many anyChar *> foo <* many anyChar but then I realized that doesn't work because ‘many anyChar’ never stops parsing in the first place. How would I achieve
04:48:00 <nand`> what I want to achieve?
04:51:39 <eikke> is there a nice way to turn a (a -> b -> c -> d) function into a (a -> (b, c) -> d) function?
04:51:48 <eikke> (uncurry came to mind but doesn't work as-is)
04:51:56 <mm_freak> edwardk: do you have a vector-space-based TracedT somewhere?
04:51:58 <nand`> (uncurry .)
04:52:12 <edwardk> vector-space based?
04:52:16 <lumi_> Hi, I'm trying to write a git fast-export filtering library using conduit, and I just wrote a strange combinator. I was wondering if anyone would be willing to look at it for me
04:52:24 <edwardk> i don't build on vector-space =)
04:52:35 <nand`> or fmap uncurry
04:52:38 <copumpkin> how about TracerT?
04:52:39 <lumi_> It's probably doing too much at once, but I'm not sure how to break it up
04:52:53 <mm_freak> edwardk: (Comonad w, VectorSpace m) => Comonad (TracedT m w)
04:52:56 <edwardk> by tracedT do you mean the traced comonad transformer or the Debug.Traced?
04:53:00 <copumpkin> mm_freak: http://www.youtube.com/watch?v=SXmv8quf_xM
04:53:08 <edwardk> mm_freak: no i don't
04:53:17 <nand`> ivanm: ah, I figured it out: bar = foo <|> anyChar *> bar
04:53:22 <eikke> nand`: thanks
04:53:25 <nand`> this works like I expect it to
04:53:26 <mm_freak> lol copumpkin
04:53:29 <edwardk> i don't use vectorspace in my packages. it brings in the top of conal's tree _and_ the top of my tree in
04:53:37 <copumpkin> mm_freak: watch it! it'll teach you loads about security
04:53:41 <edwardk> that is like installing all of hackage except the yesod corner ;)
04:54:36 <mm_freak> edwardk: maybe we're talking about different packages here…  vector-space has only very few dependencies
04:54:49 <edwardk> maybe i'm thinking of memo-trie
04:55:02 <mm_freak> yeah, but the whole dependency tree is very small
04:55:02 <edwardk> regardless, i don't have anything that depends on vector-space
04:55:10 <ts33kr> shachaf, Is it anywhere near possible to have "overloaded" DCs with the same name? Like data Foo = Foo String?
04:55:15 <hpaste> lumi pasted “Complicated conduit combinator” at http://hpaste.org/73896
04:55:20 <mm_freak> edwardk: anyway, you probably know why i'm asking =)
04:55:31 <edwardk> not off hand honestly
04:55:54 <mm_freak> edwardk: well, just like Store Traced can be used for image processing and may even be slightly better at that
04:56:15 <edwardk> hrmm
04:56:33 <edwardk> what are you tracing? raster movements or something?
04:57:15 <mm_freak> i'm not tracing anything…  interpret Traced as Store where the cursor is always at mempty except for 'extend'
04:57:20 <edwardk> guess traced was better named than i thought
04:57:33 <edwardk> oh
04:57:51 <edwardk> cute
04:58:06 <mm_freak> the difference is that now you would have the whole package of vector space operations at your hand for the cursor
04:58:13 <mm_freak> not just the ad hoc ComonadStore class
04:58:14 <edwardk> yep
04:59:10 <mm_freak> if you're not going to write it, i will =)
04:59:21 <mm_freak> because it sounds incredibly useful for image/video processing
04:59:24 <edwardk> feel free, i don't thin i can reasonably package it
04:59:54 <edwardk> in that i'm not interested in going off and building a library on top, and its a lot of dependencies for one module in isolation
05:00:27 <mm_freak> of course…  i didn't think of adding that to comonads-fd
05:00:35 <edwardk> might be curious to take a more principled stab at it using an actual free vector space rather than the VectorSpace version
05:00:54 <frerich> copumpkin: haha (re: youtube video)
05:01:43 <mm_freak> edwardk: do you think TracedT is a good name for that?
05:02:02 <edwardk> i'd avoid punning the main transformer name and come up with something similar
05:02:13 <mm_freak> well, i'd probably call it ImageT
05:02:23 <mm_freak> or SpaceT =)
05:03:21 <mm_freak> btw, what's the easiest way to check the laws?
05:03:30 <mm_freak> just transform source code?
05:03:33 <edwardk> newtype SpaceT e r w a = ImageT { runImageT :: w ((e -> r) -> a) }
05:03:40 <edwardk> er
05:03:57 <edwardk> newtype SpaceT e r w a = SpaceT { runSpaceT :: w ((e -> r) -> a) }
05:04:28 <edwardk> instance (Num r, Comonad w) => Comonad (SpaceT e r w)
05:04:50 <edwardk> that gives you a vectorspace with basis e, and scalars in r.
05:05:05 <mm_freak> btw, i see two possible transformers there…  perhaps this one is more useful:  newtype SpaceT e r w a = SpaceT { runSpaceT :: (e -> r) -> w a }
05:05:17 <edwardk> replace the mappend with liftA2 (+)  and mempty with pure 0
05:05:27 <edwardk> mm_freak: that isn't a comonad-transformer
05:05:31 <edwardk> check the laws
05:05:35 <mm_freak> hmm, ok
05:05:53 <edwardk> mm_freak: thats like making ReaderT with the function inside
05:06:12 <mm_freak> you're right…  i wouldn't know how to implement 'extract' for that one anyway
05:06:35 <edwardk> extract is easy enough given extract for w
05:06:39 <edwardk> but extend is hell
05:06:52 <mm_freak> extract (SpaceT f) = f …?
05:06:54 <edwardk> my original category-extras version was something like that
05:06:59 <edwardk> but the laws were crap
05:07:04 <edwardk> pass it the 0 vector
05:07:13 <mm_freak> what is the 0 vector?
05:07:20 <edwardk> pure 0
05:07:24 <edwardk> const 0
05:07:39 <mm_freak> ah, sure
05:07:56 <edwardk> thats the 0 for tracedT's use of mempty
05:08:14 <mm_freak> hmm, for the sake of practicality i'd rather build that on a vector space class
05:08:23 <mm_freak> that also makes the type less scary
05:08:25 <edwardk> now, the version using w ((e -> r) -> a) i coud probably package
05:08:37 <edwardk> why is the vector space class more practical?
05:08:46 <edwardk> =P
05:09:00 <mm_freak> well, if you would package that one, i could build a VectorSpace-based layer around it
05:09:16 <mm_freak> but i can also package it myself
05:09:28 <edwardk> i think i'll leave it to you
05:09:36 <edwardk> i have a bunch of stuff with polykinds i want to bundle up
05:09:40 <nand`> @hoogle Either a b -> Maybe b
05:09:41 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
05:09:41 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
05:09:41 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
05:09:44 <nand`> :(
05:09:55 <mm_freak> alright then…  i'll write a library for that one
05:09:59 <edwardk> nand`: either (const Nothing) Just
05:10:16 <lumi_> What's the protocol here on warnocks? :P
05:10:26 <edwardk> nand`: headOf traverse
05:10:33 <edwardk> =)
05:10:42 <carpi> if "x = []", is there a difference between "null x" and "x == []" ?
05:10:43 <nand`> edwardk: nice
05:11:00 <quicksilver> carpi: yes.
05:11:00 <mm_freak> carpi: no
05:11:00 <edwardk> nand`: even better ^?traverse
05:11:14 <edwardk> er wait you can't traverse it yet
05:11:15 <quicksilver> carpi: using == requires that your list contain elements of a type which is a member of Eq
05:11:19 <edwardk> ^?traverseRight
05:11:24 <mm_freak> oh yes, the type is different
05:11:25 <quicksilver> carpi: 'null x' requires nothing.
05:11:46 <edwardk> carpi: null doesn't need to know how to compare the elements
05:13:14 <nand`> in [] == [] which type does it default to? () ?
05:13:52 <carpi> thanks for the clarification )
05:15:42 <NOPsled> If I'm trying to define the function applyTwice f x = f ( f x ) is there a way to define its type so that it works for functions like head?
05:16:20 <sipa> NOPsled: how could you apply head twice?
05:16:31 <nand`> > head (head [[1,2],[3,4]]
05:16:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:16:33 <nand`> > head (head [[1,2],[3,4]])
05:16:34 <lambdabot>   1
05:16:40 <bitonic> nand`: yes
05:16:45 <sipa> ah, right, head with a different type two times
05:16:48 <nand`> yeah
05:17:01 <nand`> the trick here is that ‘head’ takes on a different type each time due to polymorphism
05:17:41 <Peaker> Is there some fast alternative to System.Random (esp. when I don't care much for true randomness)?
05:18:01 <nand`> > let headTwice f = f . f; headTwice :: (forall a. [a] -> a) -> [[b]] -> b in headTwice head [[1,2],[3,4]]
05:18:03 <lambdabot>   1
05:18:10 <nand`> but I'd have zero clue how to generalize that
05:18:20 <sipa> applyTwice :: Functor f => (forall a. a -> f a) -> a -> f (f a)
05:18:21 <sipa> ?
05:19:19 <mm_freak> Peaker: mersenne-random-pure64
05:19:37 <mm_freak> Peaker: if you want even more speed in exchange for a very ugly interface you can also use mersenne-random
05:20:18 <quicksilver> nand`: in standard haskell it doesn't default at all.
05:20:19 <edwardk> > let twice :: (forall a. f a -> a) -> f (f a) -> a; twice f = f . f in twice head [[1,2],[3,4]]
05:20:21 <mm_freak> Peaker: if you want both speed, a nice interface and high quality random numbers there is cprng-aes
05:20:23 <lambdabot>   mueval-core: Time limit exceeded
05:20:27 <quicksilver> nand`: in standard haskell [] == [] is an error.
05:20:36 <quicksilver> I think.
05:20:58 <quicksilver> maybe not.
05:21:06 <quicksilver> I think it must default to Integer.
05:21:22 <quicksilver> weird.
05:21:28 <sheldonh> are definitions in a where clause supposed to be available to the preceding guard clause?
05:21:32 <Peaker> mm_freak, thanks
05:21:53 <edwardk> sheldonh: where's span across multipe |'s
05:21:56 <quicksilver> depends what you mean by 'preceding'
05:22:02 <quicksilver> but yes, what edwardk said.
05:22:17 <sheldonh> edwardk: ah, ok. so they're available in guard clauses, but still only evaluated on use, yes?
05:22:25 <edwardk> sheldonh: correct
05:22:36 <nand`> doesn't it depend on indenting?
05:22:38 <nand`> ie. the ‘where’ after the | as opposed to before it; or something
05:22:42 <spark_> stack space overflow
05:22:44 <dropdrive> Are there any comparisons of code written with Prelude vs. with BasicPrelude?
05:22:44 <spark_> is that good?
05:22:45 <edwardk> nand`: nope
05:22:51 <quicksilver> sheldonh: to the same extent as all definitions, in let, where, or top-level.
05:23:02 <quicksilver> sheldonh: (in answer to 'evaluated on use')
05:23:17 <edwardk> spark_: that means your computer is overflowing with stack space, and it wants to share how happy it is
05:23:44 <spark_> edwardk: Im not a happy person, how do i kill it
05:24:03 <sheldonh> thanks, folks
05:25:23 <edwardk> a ballpeen hammer has been demonstrated as an effective way to kill processes by me in the past.
05:25:42 <sheldonh> eish. alternatives to hoogle? i can't live without docs at this stage, and hoogle's timing out for me atm
05:25:50 <nand`> hayoo
05:26:15 <edwardk> nand`: hayyerself
05:27:08 <edwardk> spark_: if you want to fix the bug i'd recommend pasting something
05:27:27 <quicksilver> sheldonh: docs for what? all the library docs are online
05:27:34 <quicksilver> hoogle isn't the only way to get the URLs
05:27:42 <quicksilver> (although it certainly is a convenient one)
05:28:08 <edwardk> quicksilver: it defaults to () even, not integer, no numeric constraint
05:28:16 <spark_> edwardk: will do, one sec!
05:28:25 <quicksilver> edwardk: in standard haskell? surely not?
05:28:50 <quicksilver> edwardk: defaulting to () is an extended-defaulting abhorrence, not a standard feature, I thought.
05:32:27 <edwardk> is haskell.org fried?
05:32:34 <hpaste> “Ertugrul Söylemez” pasted “SpaceT (non-transformer for now)” at http://hpaste.org/73898
05:32:43 <hpaste> spark_ pasted “yetagain retaining data” at http://hpaste.org/73899
05:32:58 <mm_freak> edwardk: is that what you thought of?  it's not transforming right now
05:33:25 <spark_> edwardk: there's the code, atm im trying to get rid of intermediate data to see if uses less memory
05:33:41 <edwardk> mm_freak: the liftA2 (+) and 0 look right didn't check if they are in the right place relative to the comonad-transformer code
05:33:52 <spark_> edwardk: my biggest problem is trying to understand why the runtime size depends on the size of the input
05:34:01 <edwardk> but since you have them there i'm guessing itll work
05:34:19 <mm_freak> edwardk: yeah, it also typechecks and seems reasonable
05:34:42 <mm_freak> edwardk: 'extend' passes the space moved by the current point
05:34:43 <edwardk> spark_: if i had to guess you have a bunch of space leaks
05:35:16 <edwardk> i rather like this use of traced
05:35:16 <spark_> edwardk: I do
05:35:34 <mm_freak> the only amazing thing left would be to abstract movement, such that you can actually move in non-euclidean space =)
05:35:35 <spark_> edwardk: a 25mb goes to 400mb runtime, a 100mb goes to 1.8gb
05:35:50 <mm_freak> like SpaceT for the surface of a sphere
05:35:54 <edwardk> spark_: liberally smash portions of it with rdeepseq until they go away, then come back and figure out why
05:36:08 <mm_freak> now you could blur the surface texture of a sphere with a single line of code =)
05:36:21 <spark_> rdeepseq?
05:36:34 <spark_> @faq rdeepseq
05:36:35 <lambdabot> The answer is: Yes! Haskell can do that.
05:36:42 <spark_> darn
05:36:59 <edwardk> http://hackage.haskell.org/packages/archive/parallel/2.2.0.1/doc/html/Control-Parallel-Strategies.html#v:rdeepseq
05:39:10 <spark_> edwardk: I can't see how this help or how im suposed to use that D:
05:39:44 <edwardk> spark_: consider a line of your code:  map4 f g (a,b,c,d) = ( f a,f  b,f  c, g d)
05:40:08 <spark_> ok
05:40:17 <edwardk> you are building up  (,,,) with 4 fields in it. but those by default are going to be lazy thunks. the functions didn't happen yet
05:40:30 <spark_> yes
05:40:30 <edwardk> they just got stuffed in there, and when someone needs the answer, it'll apply them to their argument
05:40:45 <spark_> ok
05:40:50 <edwardk> there are a number of fixes to this
05:41:07 <edwardk> deepseq is the easy one ;)
05:41:24 <spark_> can i use it like rdeepseq f a?
05:42:12 <edwardk> http://hackage.haskell.org/packages/archive/deepseq/1.3.0.0/doc/html/src/Control-DeepSeq.html#force
05:42:23 <spark_> thanks!
05:42:28 <spark_> ill try right away
05:42:51 <edwardk> force (f a, f b, f c, g d)
05:43:22 <edwardk> you can use more refined notions of sequencing
05:43:46 <edwardk> but this is at least giving you one tool you can use
05:45:19 <spark_> edwardk: well, I need to find somehow to move on, I've been stuck with thise huge leak since 2 days
05:45:46 <edwardk> hence why i wanted to just give you -some- tool to make progress with =)
05:46:05 <edwardk> ok, sleeping
05:52:59 <mm_freak> does anyone actually use comonad transformers?
05:53:54 <mm_freak> it seems weird to stack two stores to get a 2D store
05:54:33 <quicksilver> stores aren't the only comonad
05:54:48 <quicksilver> however I think only edwardk could answer your question :P
05:55:11 <mm_freak> probably =)
05:59:06 <db81> how can I tell cabal to use Haskell2010 by default in my .cabal file?
05:59:18 <dcoutts> default-language: Haskell2010
05:59:18 <lambdabot> dcoutts: You have 4 new messages. '/msg lambdabot @messages' to read them.
05:59:40 <dcoutts> db81: that's in each lib/exe/whatever section
06:00:09 <db81> thanks
06:09:34 <hiptobecubic> what's the default language otherwise?
06:10:02 <ivanm> hiptobecubic: I believe it doesn't have one and you have to specify it explicitly
06:10:13 <mm_freak> the default is h98
06:11:14 <ivanm> mm_freak: I've had to state that I'm using h98 with Cabal-Version >= 1.14
06:11:14 <mm_freak> at least currently
06:11:24 <hiptobecubic> ivanm, that's not usually how 'defaults' work :)
06:12:09 <ivanm> hiptobecubic: I said it doesn't have a default default-language
06:12:21 <mm_freak> i think this is for backwards-compatibility…  i'm specifying cabal-version >= 1.10
06:12:35 <ivanm> where default-language == "which version of the haskell report are we using as the basis of this code"
06:13:19 <hiptobecubic> Well clearly it expects some version of Haskell
06:13:29 <junis> greetings fine people
06:14:13 <junis> has any of you read the so called "yet another haskell tutorial" by Hal Daumé III
06:14:22 <hiptobecubic> h98, 2010, or the state of the language at cabal build time or something
06:14:27 <ivanm> junis: I read part of it I believe
06:14:29 <MHD> Open question: In your opinion, what is Haskell's greatest virtue?
06:14:31 <ivanm> it's rather outdated though
06:14:41 <hiptobecubic> MHD, the community
06:14:55 <ivanm> hiptobecubic: I believe h98 and h2010 are the only allowable options atm
06:15:27 <nand`> MHD: I can't decide on one
06:15:37 <Botje> junis: it is a swift kick in the teeth disguised as a haskell tutorial
06:15:58 <hiptobecubic> ivanm, that's sensible. i didn't really expect it to default to the current draft of the next version of the language.
06:16:00 <MHD> hiptobecubic: that is strictly speaking not the language
06:16:01 <junis> there is an exercise which states the following "We,ve seen that multiplication binds more tightly than division. Can you think of a way to determine whether function application binds more or less tightly than multiplication ?
06:16:04 <Botje> junis: if you're already familiar with other functional programming languages, it's a good introduction
06:16:24 <junis> yes .. i'm familiar with scheme elisp and ocaml
06:16:30 <hiptobecubic> MHD, most things are not the language.
06:16:30 <MHD> I think haskell's greatest thing is the type system
06:16:43 <nand`> there are more powerful type systems around
06:17:02 <Botje> junis: f 2 * 3, for example.
06:17:32 <junis> Botje: what does "bind more tightly" mean
06:17:41 <hiptobecubic> junis, (f 2) * 3
06:17:50 <junis> oh... it's about precendence ?
06:17:52 <Eduard_Munteanu> junis: which binds first
06:17:53 <nand`> yes
06:17:54 <Botje> yes.
06:17:56 <hiptobecubic> yes
06:17:57 <junis> i see
06:18:07 <nand`> tl;dr juxtaposition has the highest precedence
06:18:31 <frerich> junis: "multiplication binds more tightly than division"? I.e. in that system, "12 / 3 * 2" is 2 instead of 8 ?
06:18:49 <junis> i see
06:18:54 <Eduard_Munteanu> With the exception of record update syntax, no?
06:19:38 <MHD> nand`: More powerful typing systems?
06:19:47 <hiptobecubic> both are infix 7
06:20:33 * Eduard_Munteanu wants fixity expressed as a partial order
06:20:50 <hiptobecubic> Eduard_Munteanu, ... why?
06:20:51 <nand`> MHD: ones with dependent types etc. come to mind
06:21:29 <Eduard_Munteanu> hiptobecubic: I think it might be easier to deal with, you just say it binds relatively tighter or looser than other known operators
06:23:22 * hackagebot monoid-extras 0.1.1.0 - Various extra monoid-related definitions and utilities  http://hackage.haskell.org/package/monoid-extras-0.1.1.0 (BrentYorgey)
06:23:26 <Eduard_Munteanu> And it might make sense when you account for additional operators one might wish to add.
06:24:31 <Eduard_Munteanu> I recall somebody in here giving an example of such a language.
06:25:26 <spark_> haskell.org off?
06:25:42 <spark_> haskell.org off?
06:25:59 <spark_> or really slow*
06:26:06 <strg> spark_: seems so
06:26:12 <Eduard_Munteanu> Yep, same here.
06:26:23 <spark_> darn
06:26:48 <Eduard_Munteanu> spark_: use Google's cache if you need some info from the wiki
06:29:02 <spark_> Eduard_Munteanu:  oh right, thanks!
06:36:09 <spark_> I can't believe this shit
06:36:12 <spark_> fuck
06:36:14 <spark_> :(
06:36:30 <spark_> my entire problem was caused by a single lenght
06:36:39 <arbn> Apparently, putting a call to deriveJSON inside $() in GHCi doesn't work, but it's fine at the top-level of a file. Why would this be?
06:37:53 <arbn> $(deriveJSON ((map toLower) . (drop 6)) ''SomeDataType)
06:37:56 <arbn> Something like that.
06:38:19 <arbn> GHCi expects a Language.Haskell.TH.Syntax.Exp, apparently.
06:39:10 <ivanm> Show instances when imports should be qualified are a right royal PITA
06:40:46 <arbn> Language.Haskell.TH.Syntax.Dec *is* an instance of Show, so I don't understand what's going on.
06:42:29 <Guest84233> in acid state, why do event outputs need to be serializable
06:42:56 <Guest84233> i.e. the last field in a Query or Update record
06:43:23 * hackagebot luka 2012.8.29 - Simple ObjectiveC runtime binding  http://hackage.haskell.org/package/luka-2012.8.29 (JinjingWang)
06:50:36 <linduxed> was there a way to generate C code out of a haskell file?
06:51:03 <linduxed> like using ghci to generate a C-file on the basis of a haskell program?
06:51:29 <watermind> -C  ?
06:51:37 <linduxed> oooh, will try that
06:51:59 <arbn> linduxed: Good luck reading GHC's generated C. :P
06:52:28 <matthiasgorgens1> linduxed: why do you want to do that?
06:52:32 <matthiasgorgens1> just for fun?
06:52:35 <matthiasgorgens1> (that's fine.)
06:52:44 <matthiasgorgens1> or for learning haskell out of how it's compiled to C?
06:54:09 <linduxed> nope
06:54:27 <matthiasgorgens1> to both questions?
06:54:30 <linduxed> wait
06:54:36 <linduxed> sorry
06:54:40 <linduxed> something happened
06:54:43 <linduxed> no
06:55:01 <linduxed> the thing is that over at my school there's an automated testing platform for code
06:55:33 <linduxed> there are different problems there (kinda like project Euler) and one sends in the code and then gets an e-mail back with the result
06:55:44 <linduxed> fail/time limit exceeded/success/.....
06:55:47 <linduxed> now
06:55:57 <bitonic> is the C backend even present in the last versions of GHC?
06:56:02 <linduxed> the only languages it supports at the moment is C, C++, Java and Python
06:56:16 <linduxed> i want to see if Hakell-generated C-code will do the trick
06:56:19 <Botje> linduxed: I think you still need the haskell runtime for haskell-compiled C.
06:56:26 <bitonic> linduxed: probably not
06:56:28 <linduxed> Botje: oh...
06:56:32 <linduxed> :-(
06:56:42 <bitonic> Botje: well... you could try to bundle it up :P
06:56:53 <bitonic> but no it's suicidal
06:56:54 <linduxed> i wanted to write some of those assignments in haskell :-/
06:56:59 <matthiasgorgens1> do you give them your java code, or .class files?
06:57:07 <linduxed> java-files
06:57:10 <Eduard_Munteanu> Some C executable that wgets the actual executable code? :)
06:57:28 <Eduard_Munteanu> *some C code
06:57:33 <linduxed> nope, testing platform shuts down and sends you an angry message when you open a socket
06:57:43 <linduxed> along with some other stuff like system() calls
06:57:43 <Eduard_Munteanu> Heh.
06:57:47 <merijn> Doesn't GHC munge the compiled C code with some ugly perl before producing a binary?
06:57:50 <merijn> That's what I remember
06:58:01 <arbn> linduxed: You're probably stuck with Python, I'm afraid.
06:58:08 <linduxed> Eduard_Munteanu: mainly prevents leaking out the secret testing input data for some of the problems
06:58:08 <Eduard_Munteanu> merijn: the evil mangler?
06:58:21 <matthiasgorgens1> linduxed: you can write prototypes in haskell, and then transform them piece by piece with correctness-preserving transformations,
06:58:22 <Eduard_Munteanu> That's been removed in recent GHC versions IIRC.
06:58:24 <linduxed> arbn: well, that's not so bad i'd say, but still
06:58:27 <matthiasgorgens1> into ghastly, ghastly c-code.
06:58:28 <linduxed> arbn: shame
06:58:32 <matthiasgorgens1> full of gotos and longjumps.
06:58:37 <bitonic> Eduard_Munteanu: that refers to the perl script that used to mangle the assembler output
06:58:44 <matthiasgorgens1> the evil mangler.
06:58:50 <matthiasgorgens1> (TM)
06:58:54 <linduxed> so i gather that in general the answer is: NO
06:58:58 <linduxed> am i correct?
06:59:08 <bitonic> linduxed: well.  you might want to look at JHC
06:59:22 <bitonic> with GHC, the answer is no.
06:59:35 <matthiasgorgens1> you could try uploading a haskell interpreter written in C.
06:59:39 <matthiasgorgens1> plus haskell source.
06:59:59 <Eduard_Munteanu> Hm, yeah, JHC might do it, but don't expect those binaries to be fast or anything.
07:01:00 <byorgey> linduxed: can
07:01:10 <byorgey> linduxed: can't you request Haskell to be included?
07:01:36 <linduxed> byorgey: i will, but that involves expanding the system
07:01:40 <arbn> linduxed: You might offer to implement the Haskell support yourself.
07:01:41 <bitonic> byorgey: if it's some automated platform that's probably a fair amount of work...
07:01:47 <linduxed> byorgey: basically asking the admins "can you add this feature"
07:01:56 <linduxed> arbn: lol, no way
07:02:01 <linduxed> arbn: i'm too bad for that
07:02:12 <Guest84233> are you a bad enough dude
07:02:31 <Eduard_Munteanu> It might only do stuff like building the executable, I guess it does LD_PRELOAD tricks to catch certain syscalls?
07:02:32 <Botje> subclass LanguageRunner, substitute ghc for gcc, done?
07:02:51 <linduxed> Eduard_Munteanu: well then that seals it, because some of the problems have speedy execution time as a prerequisite
07:02:52 <Eduard_Munteanu> ^^
07:03:39 <linduxed> Botje: well i have no idea how to do it, and i don't know if the people over there are so keen on implementing it
07:03:46 <linduxed> Botje: i will ask, however
07:03:54 <matthiasgorgens1> linduxed: if you can get away with python, you can get away with anything in terms of runtime.
07:04:08 <linduxed> matthiasgorgens1: well no, they use pypy
07:04:13 <matthiasgorgens1> (given that your algorithm isn't too dumb.)
07:04:17 <linduxed> matthiasgorgens1: so that makes it really fast
07:04:31 <arbn> linduxed: If you just want to use a language that sucks less, you might think of using Scheme, which might be significantly easier to pass off as C.
07:05:03 <matthiasgorgens1> also, coding in C can be a perverse pleasure.
07:05:10 <linduxed> arbn: but dude, the system is automated, there's noone checking the code
07:05:13 <Guest84233> C is great
07:05:19 <Eduard_Munteanu> What matthiasgorgens1 says :)
07:05:21 <linduxed> arbn: so it wouldn't accept scheme
07:05:30 <matthiasgorgens1> at least for those small, well-constrained toy problems.
07:05:31 <linduxed> matthiasgorgens1: true i guess
07:05:42 <matthiasgorgens1> linduxed: scheme might be easier to compile into C.
07:05:52 <matthiasgorgens1> since the runtime can be simpler.
07:06:04 <arbn> linduxed: I meant, compile Scheme to C, or ship a Scheme interpreter embedded in a C program.
07:06:11 <matthiasgorgens1> linduxed: see https://en.wikipedia.org/wiki/Chicken_(Scheme_implementation)
07:06:14 <linduxed> matthiasgorgens1: well i'm not really interested in scheme, i asked here for Haskell->C because i love this language
07:06:27 <linduxed> matthiasgorgens1: i have little interest in scheme
07:06:44 <matthiasgorgens1> ok.
07:06:51 <linduxed> so i mainly started the conversation because i thought there was a nice quick way to do the problems
07:06:56 <linduxed> in haskell that is
07:06:58 <matthiasgorgens1> something else: you might want to try Forth.  just to broaden your horizon.
07:07:08 <matthiasgorgens1> forth interpreters are extremely easy to write in almost any language.
07:07:40 <matthiasgorgens1> linduxed: alas, it's not easy to translate haskell to plain c without any special libraries / runtime support.
07:07:49 <Guest84233> a C implementation in haskell quick and easy?
07:07:57 <matthiasgorgens1> or rather, nobody's done the work, because in the real world that inferior to using a runtime.
07:08:06 <linduxed> yeah, now that i think of it, it would have to generate garbage collection and stuff like that
07:08:15 <linduxed> not just whatever you wrote
07:08:26 <matthiasgorgens1> Guest84233: read PSJ book about compiling purely functional languages. ;o)
07:08:28 <bitonic> matthiasgorgens1: I mentioned JHC already, which is a std. compliant Haskell compiler
07:08:38 <matthiasgorgens1> linduxed: garbage collector is relatively simple.
07:08:39 <bitonic> std. + a lot of extensions
07:08:44 <matthiasgorgens1> but all the lazyness will kill you.
07:08:48 <Guest84233> matthiasgorgens1: not sure thats relevant
07:09:16 <matthiasgorgens1> Guest84233: oh, that book is useful, if you want to produce C out of Haskell, and can't use the standard compilers.
07:09:21 <matthiasgorgens1> that would of course be overkill.
07:09:26 <matthiasgorgens1> to write your own compiler.
07:09:31 <matthiasgorgens1> but rather educational.
07:09:56 <bitonic> linduxed: http://repetae.net/computer/jhc/
07:10:03 <Guest84233> matthiasgorgens1: i misuderstood i thought he was trying to write a c implementation
07:10:07 <nand`> matthiasgorgens1: link?
07:10:45 <matthiasgorgens1> nand`: http://research.microsoft.com/en-us/um/people/simonpj/Papers/pj-lester-book/
07:12:13 <nand`> matthiasgorgens1: thanks
07:12:32 <matthiasgorgens1> nand`: take in mind, that it's 20 years old now.
07:12:46 <matthiasgorgens1> i haven't read the whole thing yet.  but it is still rather illuminating.
07:13:22 <matthiasgorgens1> of course, entirely impractical for what linduxed wants to do. :o)
07:14:25 <matthiasgorgens1> linduxed: do they use gcc?
07:18:24 * hackagebot yesod-fb 0.1 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.1 (FelipeLessa)
07:18:26 * hackagebot yesod-auth-fb 1.2 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.2 (FelipeLessa)
07:20:24 <n00b6502> i was asking about this too... imagine haskell being the 'most high level language' as in the purest description of what an algorithm can do, then imagine crystalizing a specific mapping to memory acess patterns in a C program. cache-optimized C programs are often completely obfuscated versions of ones' initial C implementation.
07:20:57 <n00b6502> (purest description of what an algorithm is, not what it can do)
07:23:28 * hackagebot yesod-fb 0.1.0.1 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.1.0.1 (FelipeLessa)
07:26:37 <ivanm> Yesod has FaceBook support? *shudders*
07:27:06 <matthiasgorgens1> n00b6502: yes.  do you want to draw any conclusions?
07:27:46 <matthiasgorgens1> n00b6502: you might be interested in apfelmus drawing parallels between quick sort / tree sort and quick select (for the median).
07:27:49 <Clint> ivanm: yet i have to hack proxy "passthrough" myself
07:27:55 <matthiasgorgens1> which have nearly the same expression in a lazy language.
07:29:24 <n00b6502> when i first talked about this here i think people got the wrong end of the stick; i'm awre the STG haskell implementaions are very different to C :)
07:29:54 <matthiasgorgens1> STG?
07:30:15 <nand`> what are some major differences between Miranda and Haskell?
07:30:16 <n00b6502> supposedly the back end of haskell is called the "Spineless Tagless G-Machine"
07:30:37 <matthiasgorgens1> I've heard that before, yeah.
07:30:39 <n00b6502> and it works nothing like conventional languages
07:30:42 <matthiasgorgens1> yes.
07:30:45 <yitz> nand`: about 20 years
07:31:00 <kini> note to self: don't read the comments in rwh
07:31:04 <nand`> well, is Miranda more or less a subset of Haskell?
07:31:23 <geekosaur> also, the expanded name hasn't been accurate in years
07:33:25 * hackagebot yesod-fb 0.1.1 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.1.1 (FelipeLessa)
07:35:18 <merijn> kini: Why not?
07:38:25 * hackagebot yesod-auth-fb 1.2.1 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.2.1 (FelipeLessa)
07:39:38 <merijn> haskell.org is down? :(
07:39:54 <merijn> I can't code teh haskellz without Hoogle :(
07:40:09 <matthiasgorgens> merijn: hayoo!
07:40:42 <merijn> Hayoo never seems to work for me
07:41:13 <merijn> Hayoo seems to always return completely unrelated results
07:41:26 <Spockz> is there a package that contains the simply typed lambda calculus, so grammar, (parser?) type-checker etc? I found the lambda-ast package but that only has the AST
07:44:14 <t7> would be nice if Set got as much love as [a] in the prelude
07:46:07 <merijn> @tell edwardk The link to the GitHub wiki page in your readme (https://ekmett.github.com/lens) is broken, should be https://github.com/ekmett/lens/wiki instead
07:46:07 <lambdabot> Consider it noted.
07:53:25 * hackagebot fb 0.11.2 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.11.2 (FelipeLessa)
07:53:35 <kini> <merijn> kini: Why not?
07:53:35 <kini> because they're mostly outdated and all distracting :)
07:58:17 <t7> haskell.org down?
07:58:50 <merijn> t7: Extremely slow
07:59:07 <yitz> t7: http://www.downforeveryoneorjustme.com/haskell.org
07:59:08 <t7> f5 f5 f5
07:59:29 <parcs`> Set is not in the prelude though
07:59:39 <t7> i mean platform
07:59:54 <yitz> t7: what kind of "love" for Data.Set would you want in the Prelude?
08:00:52 <Eduard_Munteanu> yitz: if only Prelude was less obnoxious (read "used typeclasses more often")
08:01:29 <yitz> Eduard_Munteanu: many people wish the Prelude would be less obnoxious and use typeclasses *less*
08:02:00 <Eduard_Munteanu> Dunno, it seems like the Prelude pollutes the namespace quite a bit.
08:02:19 <Eduard_Munteanu> And for what? Some list-oriented functions?
08:02:49 <DT``> +1 for a more general Prelude.
08:02:50 <yitz> Eduard_Munteanu: there is a certain amount of cruft that no one ever uses anymore. but i don't find that gets in my way.
08:05:09 <yitz> lists are very very fundamental in functional programming. to me it makes sense for them to be special in the prelude.
08:06:00 <DT``> meh, they're just really unbalanced trees.
08:06:22 <DT``> they are special if you treat them specially.
08:06:32 <eikke> DT`` read Steele? ;-)
08:07:08 <armlesshobo> Danielle Steele
08:07:23 <DT``> eikke, ``get rid of cons''?
08:08:36 <eikke> DT``: indeed
08:13:29 <mm_freak> i don't think lists are special in functional programming…  they are special in haskell, as they take the role of both a data structure and a control structure
08:13:38 <mm_freak> that's why you naturally want some list functions available
08:13:43 <eikke> mm_freak: s/haskell/lisp/
08:14:04 <allsystemsarego> Hello, I have a question: why is a Haskell type constructor a mapping from types to types?
08:14:09 <t7> yitz: nice operators, other structures taking sets
08:14:11 <mm_freak> eikke: no, haskell
08:14:20 <nand`> I don't follow how lists are special in Haskell
08:14:28 <nand`> other than the built-in sugar
08:14:36 <t7> like mapRemoveKeys Set a -> Map a b
08:14:46 <mm_freak> allsystemsarego: you can interpret Maybe as a function from a type to a type
08:14:55 <mm_freak> allsystemsarego: or to put it in terms of kinds:  Maybe :: * -> *
08:14:57 <mm_freak> Int :: *
08:15:00 <mm_freak> Maybe Int :: *
08:15:08 <Yuu-chan> Just :: a -> Maybe a
08:15:10 <allsystemsarego> aha, ok
08:15:15 <allsystemsarego> thanks
08:15:17 <mm_freak> Yuu-chan: that's not a type constructor
08:15:43 <mm_freak> nand`: they aren't special language-wise, but you really use them as a control structure rather than a data structure in haskell
08:15:45 <Yuu-chan> mm_freak: a value constructor?
08:15:50 <Jeanne-Kamikaze> haskell: that language where you write 3k lines of code (equivalent to 30k lines in traditional languages) and - shit - just - works -
08:15:52 <mm_freak> Yuu-chan: yeah
08:16:57 <nand`> mm_freak: I don't think that's a property inherent or special to lists; many haskell data types can be used as ‘control structures’ - lists are just one example
08:17:31 <mm_freak> nand`: unlike the others lists are uniquitous
08:17:41 <mm_freak> they replace for, while, etc.
08:17:42 <Yuu-chan> Jeanne-Kamikaze: ...or you write a single line of code and everybody else can't even understand what's happening...
08:17:52 <Jeanne-Kamikaze> that too
08:18:30 <mm_freak> nand`: just think of lists in terms of their fold and unfold…  most algorithms are just folds and unfolds of lists
08:18:36 <nand`> mm_freak: but others (think continuations etc.) can replace stuff like goto or return; replacing ‘for/while’ is just one example imo
08:19:45 <mm_freak> nand`: that's why you have continuations by default as well…  you don't even need the Prelude for that one =)
08:20:32 <nand`> I'm not understating the utility of lists or inclusion in the Prelude mind; just claiming that they aren't inherently ‘special’ in any sense - just very useful
08:21:08 <mm_freak> formally they aren't special
08:21:47 <mm_freak> but they are useful enough for a bunch of utility functions in the Prelude to be reasonable
08:21:48 <Yuu-chan> mm_freak: but they have special syntax :)
08:21:58 <mm_freak> Yuu-chan: monads have special syntax, too
08:22:06 <mm_freak> they aren't special either ;)
08:22:27 <mm_freak> Yuu-chan: by that logic even Bool is special
08:22:35 <mm_freak> because there is if/then/else
08:22:41 <nand`> mm_freak: yes I agree; perhaps I misread what you were intending to say somewhat
08:22:48 <Yuu-chan> True...
08:23:37 <mm_freak> and nothing could be less special than () with its special syntax =)
08:23:54 <geekosaur> lists get special syntax more because linear text lends itself to convenient representation of linear data structures.  if we had a truly tree-structured way to work with code (say, at the AST level) trees would also then be eligible for convenient syntax
08:24:10 <nand`> hmm; is stuff like ‘if/then/else’ just a plain syntax transformation? Say I hide the prelude Bool and define my own type eg. data Bool = True | False | FileNotFound; will ‘if x then foo else bar’ desugar to ‘case x of True -> foo | False -> bar’ and type check using my Bool?
08:24:46 <mm_freak> nand`: there is the RebindableSyntax extension, but i don't know how it would behave in this case
08:26:17 <lightquake> let's check!
08:26:31 <nand`> hmm
08:26:39 <nand`> Couldn't match expected type `GHC.Types.Bool' with actual type `MyBool'
08:26:51 <nand`> (without the extension)
08:26:53 <Yuu-chan> geekosaur: that's remind me of Lisp, where we work with AST-level trees via simple lists
08:27:15 <nand`> mm_freak: ah, with RebindableSyntax it desugars to ifThenElse x y z
08:27:51 <nand`> but apparently without it, GHC still wants its own hard-coded Bool type
08:29:20 <byorgey> Yuu-chan: they aren't really lists, they are untyped nested pairs =)
08:30:37 <Yuu-chan> UNPP - Untyped Nested Pair Processing :)
08:30:57 <obiwahn> hi my lambdabot thros the folloing error
08:31:00 <obiwahn> Plugin `seen' failed with: too few bytes. Failed reading at byte
08:31:21 <obiwahn> any suggestion how to fix that?
08:31:29 <Botje> have you tried nuking your seen database file?
08:33:08 <DanBurton> the people over at ##c got a huge laugh out of this, so I figure you guys might enjoy it as well. C code written in Haskell-esque style (commas & semicolons first) http://ideone.com/pd34E
08:34:02 <nand`> DanBurton: that looks like something I'd write :P
08:34:26 <nand`> the style is infectious
08:34:30 <mm_freak> horrible…
08:34:46 <mm_freak> and that's not really haskell style…  it's just a common ugly style in haskell =)
08:34:46 <obiwahn> Botje: where would i find them?
08:35:03 <obiwahn> i have deleted some stuff iin /tmp
08:35:14 <obiwahn> wow the connection is really laggy
08:35:23 <lightquake> i don't think i've ever seen semicolons first
08:35:26 <lightquake> in haskell
08:35:39 <mm_freak> lightquake: do { … }
08:35:43 <nand`> though I do some things a bit differently; eg. I start functions like this: “int foo(int bar) { return”  followed by a linebreak
08:35:52 <lightquake> mm_freak: even then
08:36:01 <lightquake> i've only ever seen do { foo;\n bar;\n baz}
08:36:15 <hiptobecubic> nand`, your entire function is one expression?
08:36:23 <nand`> hiptobecubic: pretty much, yeah
08:36:44 <hiptobecubic> given c's capabilities, I can't imagine your code is very readable
08:37:26 <mm_freak> lightquake: apparently for some reason people seem to acknowledge the ugliness of lined up punctuation in do-notation, but for some very weird reason they are happy with lined up commas in type definitions
08:37:30 <nand`> (I'm referencing C# to be particular; I don't write C), but most of it is just simple haskell-esque machinery; I'll regress to using the built in sequencing functionalities when it comes to things I'd do with IO blocks in Haskell
08:37:46 <nand`> usually my ‘main’ method is imperative style but the rest is single-expr style
08:37:48 <mm_freak> that style buys you nothing and looks really creepy
08:38:00 <lightquake> haha
08:38:10 <Paprikachu> http://ideone.com/qvn5K
08:38:12 <Paprikachu> why?
08:38:12 <lightquake> yeah idk why but it's... unsettling as hell
08:38:33 <nand`> mm_freak: I usually do it most for lists, one reason is easy appending
08:38:53 <mm_freak> nand`: you get easier appending by not using list syntax at all
08:38:54 <Clint> easy appending, reduced diffs
08:39:07 <mm_freak> nand`: x : y : z : []
08:39:12 <mm_freak> where the (:) are at the end of line
08:39:22 <mm_freak> that gives you even easier appending
08:39:35 <nand`> mm_freak: intriguing, I hadn't actually considered that
08:39:48 <mm_freak> it also gives you easy prepending, which is not possible in list syntax
08:39:56 <hpaste> Paprikachu pasted “decimal to binary” at http://hpaste.org/73902
08:40:05 <Paprikachu> why doesnt it work
08:40:13 <malsyned> I'm surprised everyone isn't talking about haskell.org being so slow today. Is it just happening to me?
08:40:24 <thirsteh> Paprikachu: add a type signature
08:40:34 <Paprikachu> what
08:40:48 <Paprikachu> what's a type signature?
08:40:57 <mm_freak> Paprikachu: x :: T
08:41:02 <atriq> Is there a way to stick a resettable counter onto a monad?
08:41:09 <mm_freak> Paprikachu: tobin :: Integer -> IO ()
08:41:24 <mm_freak> atriq: which monad?
08:41:28 <Eduard_Munteanu> atriq: add a StateT to it?
08:41:34 <nand`> ‘counter’?
08:41:50 <Paprikachu> why do i need that?
08:42:00 <nand`> (what's the error you get?)
08:42:00 <mm_freak> Paprikachu: you don't, but do it anyway =)
08:42:03 <atriq> nand`, something that I can say "Plus one to yesel'" and "Be zero again"
08:42:09 <DanBurton> Paprikachu: why? for great justice
08:42:15 <atriq> mm_freak, ideally any, but Maybe in particular
08:42:24 <mm_freak> atriq: there are two options
08:42:25 <nand`> atriq: StateT Integer;  ‘modify succ’ to increase and ‘put 0’ to reset
08:42:29 <nand`> is one option
08:42:31 <Paprikachu> it still doesnt work
08:42:32 <Paprikachu> http://ideone.com/kjxdq
08:42:38 <mm_freak> atriq: MaybeT (State Integer) or StateT Integer Maybe
08:42:44 <nand`> Paprikachu: replace / with `div`
08:42:54 <Eduard_Munteanu> Or a newtype wrapper if you want to prevent others from messing with the internals.
08:42:58 <atriq> I'll go for StateT, I think
08:42:59 <malsyned> Is there a mirror for Haskell Platform downloads?
08:42:59 <nand`> / is for fractional types which, as the error says, Integer is not
08:43:01 <atriq> Thank you
08:43:25 <mm_freak> atriq: the nicest option is probably to write your own free monad:  newtype CoutingMaybeF a = CountingMaybeF (Integer -> Maybe (a, Integer))
08:43:35 <mm_freak> type CountingMaybe = Free CountingMaybeF
08:43:39 <Paprikachu> http://ideone.com/MAKZb
08:43:46 <Paprikachu> how can i get rid of the /n's?
08:43:49 <Paprikachu> \n
08:44:07 <thirsteh> Paprikachu: remove them...
08:44:15 <Paprikachu> ??
08:44:28 <monochrom> "print" adds the newlines. don't use print
08:44:45 <thirsteh> oh, I thought you meant in your paste
08:44:45 <Eduard_Munteanu> @src print
08:44:45 <lambdabot> print x = putStrLn (show x)
08:44:59 <mm_freak> Paprikachu: the usual way is to write a pure function
08:45:06 <monochrom> but the whole program is misguided. don't mix data crunching with outputting
08:45:30 <thirsteh> do main = print $ tobin 10, instead
08:45:38 <mm_freak> > map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2) $ 10
08:45:40 <lambdabot>   [0,1,0,1]
08:46:03 <monochrom> yeah, tobin :: Integer -> String and does not output. output in main
08:46:38 * nand` .oO( toBase :: Integer -> Integer -> String )
08:46:44 <Paprikachu> [17:44:47]	<monochrom>	but the whole program is misguided. don't mix data crunching with outputting << dont talk with me about programming principles, i am beyond that
08:47:01 <mm_freak> Paprikachu: you are not in haskell
08:47:18 <monochrom> fine, I talk with the rest of the channel, everyone except you. are you happy now?
08:47:27 * Clint chortles.
08:48:19 <monochrom> I saw c++ beginner code that says class ComplexNumber { public ComplexNumber() { cout << "please enter the real part:"; cin >> r; ...
08:48:32 <Paprikachu> lol
08:48:35 <Paprikachu> i dont write such bs
08:48:36 <Eduard_Munteanu> Oh, yeah, that sucks.
08:48:48 <sm> Me neither! I am beyond that, don't talk to me about it
08:48:48 <mm_freak> haskell is sufficiently different that even the best programmers in other languages become programming newbies in haskell
08:49:04 <mm_freak> so listen to monochrom =)
08:49:04 <monochrom> http://ideone.com/MAKZb is not too different from such bs. again I am saying this to everyone except you
08:49:33 <nand`> mm_freak: what if I'm an expert miranda, gopher, lazy ML, w/e programmer? :)
08:49:39 <Paprikachu> are you seriously telling me that everyone who mixes algorithms an output is a beginner?
08:49:49 <mm_freak> Paprikachu: no in other languages, yes in haskell
08:49:51 <lightquake> in haskell, usually!
08:49:56 <monochrom> no, I am seriously telling you nothing, as said.
08:50:08 <monochrom> I am just telling everyone else
08:50:09 <malsyned> Paprikachu: in Haskell, it's a very unusual thing to do.
08:50:11 <mm_freak> nand`: good question…  you probably still have to rethink a few things =)
08:50:23 <copumpkin> it's considered bad practice in any language
08:50:29 <nand`> mm_freak: correct answer would have been ‘then you're simon peyton jones’
08:50:36 <mm_freak> lol nand`
08:50:42 <monochrom> tobin 0 = putChar '0'  if you like
08:50:46 <Paprikachu> i dont give a fuck if it bad practise since this is far from being a useful program
08:50:54 <copumpkin> "don't teach me, my ego is too big"
08:51:02 <Clint> i'm beyond ego
08:51:09 <lightquake> i'm the most humble person ever
08:51:17 <mm_freak> to answer your question, your program works as expected
08:51:17 <copumpkin> my humility far exceeds yours
08:51:26 <nand`> lightquake: it's egoistic of you to assume that
08:51:29 <nand`> :(
08:51:30 <malsyned> Paprikachu: you can say "putStr (show x)" instead of "print x" to get rid of the newlines in the output. If you must.
08:51:41 <Paprikachu> yeah i already did tha
08:51:43 <Paprikachu> that
08:51:52 <Paprikachu> http://ideone.com/Wg0RP
08:52:08 <mm_freak> > let toBin = map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2) in toBin 76251
08:52:08 <Paprikachu> didnt know of the existence of putChar though :P
08:52:10 <lambdabot>   [1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1]
08:52:10 <nand`> (I missed the joke the first time round, didn't I?)
08:52:19 <mm_freak> then just print (toBin 15892745)
08:52:21 <Clint> seems that way
08:52:51 <mm_freak> and if you want to print on multiple lines:  mapM_ print (toBin 852739851)
08:52:55 <Paprikachu> mm_freak: how does this work?
08:53:14 <mm_freak> Paprikachu: toBin is a pure function that doesn't perform IO…  it just turns your number into a list of binary digits
08:53:20 <mm_freak> this list can then be printed in various ways
08:53:31 <Paprikachu> can you put some parenthesis around the subexpressions?
08:53:39 <mm_freak> where?
08:53:47 <Paprikachu> i dunno how it's evaluated
08:53:57 <mm_freak> of course (.) is associative, so feel free to write (f . g) . h instead of f . g . h =)
08:54:12 <nand`> (((mapM_) (print)) ((toBin) (852739851)))  -- this doesn't help, does it?
08:54:16 <mm_freak> (f . g . h) x = f (g (h x))
08:54:28 <Paprikachu> i mean that one: > let toBin = map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2) in toBin 76251
08:54:28 <mm_freak> it's a composition of three functions…  read from right to left
08:54:32 <mm_freak> i know =)
08:54:34 <nand`> oh
08:54:39 <copumpkin> > let toBin = takeWhile (> 0) . iterate (`div` 2) in toBin 76251
08:54:41 <lambdabot>   [76251,38125,19062,9531,4765,2382,1191,595,297,148,74,37,18,9,4,2,1]
08:54:58 <monochrom> parentheses determine parsing, not exactly evaluation order
08:55:04 <Paprikachu> yeah whatever
08:55:17 <copumpkin> lol
08:55:29 <monochrom> " 0 * (3948950434 + 203984934) "  you do not evaluate  (3948950434 + 203984934) first. (or do you?)
08:55:29 <Paprikachu> let's assume lazy evaluation does not exist.
08:55:33 <nand`> monochrom: wouldn't that depend on how sufficiently broad your definition of ‘evaluation’ is?
08:56:17 <monochrom> schools tell you "parentheses determine order" as a simplification. apparently, teachers think that "parsing" is too deep
08:56:19 <Paprikachu> could you maybe write the explicit form
08:56:28 <Paprikachu> with let toBin x = ...
08:56:31 <mauke> sometimes C programmers claim parentheses affect evaluation order
08:56:34 <mauke> then I kill them
08:56:40 <monochrom> but it is always fair to say "parentheses disambiguate"
08:56:57 <nand`> suppose my parser ‘evaluates’ a valid expression in the source language (list of unicode characters) into a result in the target language (haskell programs)
08:58:04 <monochrom> yes nand`, that is exactly school's simplified story, evaluate while you parse, and bottom-up too. see it is a very special case
08:58:23 <Paprikachu> > let toBin x = map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2) x in toBin 76251
08:58:24 <lambdabot>   No instance for (GHC.Real.Integral [a])
08:58:24 <lambdabot>    arising from a use of `e_1202762...
08:58:41 <Paprikachu> > let toBin x = map ((`mod` 2) . takeWhile (> 0) . iterate (`div` 2)) x in toBin 76251
08:58:42 <lambdabot>   No instance for (GHC.Real.Integral [a])
08:58:42 <lambdabot>    arising from a use of `e_1202762...
08:59:13 <nand`> it would have to be
08:59:22 <nand`> (map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2)) x
08:59:39 <nand`> otherwise that parses as ... . (iterate (`div` 2) x)
08:59:41 <Paprikachu> > let toBin x = (map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2)) x in toBin 76251
08:59:42 <lambdabot>  Terminated
08:59:50 <Paprikachu> what
08:59:56 <nand`> huh, try running that again
08:59:59 <Paprikachu> > let toBin x = (map (`mod` 2) . takeWhile (> 0) . iterate (`div` 2)) x in toBin 76251
09:00:01 <lambdabot>   [1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1]
09:00:47 <Paprikachu> how can i show the signature of a function?
09:00:50 <byorgey> > foldr (\b n -> b + 2*n) 0 [1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1]
09:00:51 <lambdabot>   76251
09:01:09 <Paprikachu> > takeWhile
09:01:10 <lambdabot>   Overlapping instances for GHC.Show.Show
09:01:10 <lambdabot>                              ((a ->...
09:01:22 <byorgey> @type takeWhile
09:01:23 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
09:01:45 <Paprikachu> > let toBin x = (map ((`mod` 2) . takeWhile (> 0) . iterate (`div` 2))) x in toBin 76251
09:01:46 <lambdabot>   No instance for (GHC.Real.Integral [a])
09:01:46 <lambdabot>    arising from a use of `e_1202762...
09:02:15 <Paprikachu> -
09:02:17 <Paprikachu> -_-
09:02:38 <nand`> juxtaposition has the highest precedence
09:02:40 <Paprikachu> > let toBin x = ((map (`mod` 2)) . takeWhile (> 0) . iterate (`div` 2)) x in toBin 76251
09:02:42 <lambdabot>   [1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1]
09:02:49 <nand`> a b . c d is (a b) . (c d), not a (b . c) d
09:03:18 <Paprikachu> > let toBin x = ((map (`mod` 2)) . (takeWhile (> 0)) . iterate (`div` 2)) x in toBin 76251
09:03:20 <lambdabot>   [1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1]
09:03:38 <Paprikachu> > let toBin x = ((map (`mod` 2)) . (takeWhile (> 0)) . (iterate (`div` 2))) x in toBin 76251
09:03:40 <lambdabot>   [1,1,0,1,1,0,1,1,1,0,0,1,0,1,0,0,1]
09:04:07 <Paprikachu> what is iterate?
09:04:16 <nand`> @src iterate
09:04:17 <lambdabot> iterate f x =  x : iterate f (f x)
09:04:46 <Cale> iterate f x = [x, f x, f (f x), f (f (f x)), ...]
09:05:10 <mm_freak> > iterate (*2) 1
09:05:11 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
09:05:18 <allsystemsarego> in other words, iterate == Inception
09:05:25 <nand`> no, that's fix
09:05:29 <Paprikachu> > iterate (`div` 2) 42
09:05:31 <lambdabot>   [42,21,10,5,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
09:05:41 <Cale> > fix error
09:05:43 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
09:05:51 <Cale> Exception inception
09:05:55 <mm_freak> > let test = iterate (*2) in test 1
09:05:56 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
09:06:02 <mm_freak> > let test = takeWhile (< 10000) . iterate (*2) in test 1
09:06:04 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192]
09:06:13 <mm_freak> > let test = map (+ 1) . takeWhile (< 10000) . iterate (*2) in test 1
09:06:15 <lambdabot>   [2,3,5,9,17,33,65,129,257,513,1025,2049,4097,8193]
09:06:19 <mm_freak> just a function composition
09:06:54 <mm_freak> you can add as many functions as you want
09:06:59 <nand`> Cale: ouch, I never noticed that parallel between the words ‘inception’ and ‘exception’
09:07:01 <mm_freak> as long as the types fit of course =)
09:07:18 <nand`> ‘exception’ must be the process of making people forget things by invading their dreams :)
09:08:16 <mm_freak> > iterate (liftA2 (:) head id) "blah"
09:08:17 <lambdabot>   ["blah","bblah","bbblah","bbbblah","bbbbblah","bbbbbblah","bbbbbbblah","bbb...
09:08:43 <mm_freak> > iterate (liftA2 (++) (take 3) id) "blah"
09:08:45 <lambdabot>   ["blah","blablah","blablablah","blablablablah","blablablablablah","blablabl...
09:09:05 <Paprikachu> > let fib 0 = 0; fib 1 = 1; fib n = (fib $ n - 1) + fib $ n - 2 in fib 10
09:09:06 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
09:09:21 <mm_freak> Paprikachu: try with parentheses instead of ($)
09:09:35 <rosie> What's a good way to distinguish between GET and POST using http-types? e.g. something like       case (parseMethod (requestMethod req)) of GET -> "It's a GET." POST -> "It's a POST."
09:09:43 <Paprikachu> > let fib 0 = 0; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2) in fib 10
09:09:44 <lambdabot>   55
09:09:56 <nand`> Paprikachu: $ has a lower precedence than + and - so that's ((fib $ n - 1) + fib) $ (n - 2)
09:10:20 <Paprikachu> > let fib 0 = 0; fib 1 = 1; fib n = ((fib $ n - 1) + fib) $ (n - 2) in fib 10
09:10:22 <lambdabot>   Occurs check: cannot construct the infinite type: t = t1 -> t
09:10:37 <mm_freak> (fib $ n - 1) + (fib $ n - 2)
09:10:39 <Paprikachu> > let fib 0 = 0; fib 1 = 1; fib n = ((fib $ n - 1) + (fib $ (n - 2)) in fib 10
09:10:40 <lambdabot>   <no location info>: parse error on input `in'
09:10:49 <aristid> rosie: that should work, no? i mean you might need to add a Just because parseMethod returns a Maybe
09:10:51 <mm_freak> but seriously fib (n - 1) + fib (n - 2) is more readable =)
09:10:53 <Paprikachu> > let fib 0 = 0; fib 1 = 1; fib n = (fib $ n - 1) + (fib $ (n - 2)) in fib 10
09:10:54 <lambdabot>   55
09:11:03 <aristid> an Either i mean
09:11:20 <Paprikachu> @src lift2A
09:11:20 <lambdabot> Source not found. :(
09:11:23 <quicksilver> Right GET -> blah ... ; Right POST -> blah ...
09:11:26 <Paprikachu> @src liftA2
09:11:26 <lambdabot> liftA2 f a b = f <$> a <*> b
09:11:28 <quicksilver> ^^ rosie CC: aristid
09:11:37 <Paprikachu> okay, what is this o_o
09:11:37 <aristid> quicksilver: yeah exactly
09:11:50 <nand`> Paprikachu: functions from class Applicative
09:11:57 <mm_freak> Paprikachu: for now, think of it as this:  liftA2 f g h x = f (g x) (h x)
09:12:05 <nand`> (well, <$> is for Functor and not a class function either)
09:12:23 <Cale> nand`: Exception is the process of breaking out of someone's dream
09:12:25 <mm_freak> Paprikachu: when you get to applicative functors you will understand the full meaning of liftA2
09:12:29 <rosie> aristid and quicksilver: Thanks! it worked
09:12:34 <mm_freak> > liftA2 (+) [1..3] [10,20,30]
09:12:35 <lambdabot>   [11,21,31,12,22,32,13,23,33]
09:12:46 <Paprikachu> > liftA2 (+2) (+3) (+4) 5
09:12:47 <lambdabot>   Occurs check: cannot construct the infinite type: b = b -> c
09:13:06 <mm_freak> > liftA2 (*) (+ 2) (+ 3) 5
09:13:07 <lambdabot>   56
09:13:10 <Paprikachu> > liftA2 (+) (+3) (+4) 5
09:13:11 <lambdabot>   17
09:13:16 <mm_freak> (5 + 2) * (5 + 3)
09:13:24 <mauke> > liftA2 (*) (+ 2) (+ 3) 5 :: Expr
09:13:26 <lambdabot>   (5 + 2) * (5 + 3)
09:13:26 <aristid> rosie: you can just as well match on "GET" and "POST" tho :)
09:13:59 <Paprikachu> > id
09:14:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:14:00 <lambdabot>    arising from a use of `...
09:14:01 <aristid> > liftA2 (+) (+3) (+4) x
09:14:02 <lambdabot>   x + 3 + (x + 4)
09:14:39 <mauke> > liftA2 (*) (+ 2) (+ 3) 5 x
09:14:40 <Paprikachu> > id "foo"
09:14:40 <lambdabot>   56
09:14:41 <lambdabot>   "foo"
09:15:05 <mm_freak> i see…  it's lambdabot play time…  i'm off…  see you later, guys =)
09:15:49 <Paprikachu> > iterate . liftA2 (:) head id $ "blah"
09:15:50 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
09:15:57 <Paprikachu> > iterate . liftA2 (:) head id . "blah"
09:15:58 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
09:16:12 <Paprikachu> > (iterate . liftA2 (:) head id) "blah"
09:16:13 <lambdabot>   Couldn't match expected type `a -> a' against inferred type `[a1]'
09:16:47 <mauke> :t liftA2 (:) head id
09:16:48 <lambdabot> forall a. [a] -> [a]
09:16:55 <mauke> :t iterate . liftA2 (:) head id
09:16:56 <lambdabot>     Couldn't match expected type `a -> a' against inferred type `[a1]'
09:16:57 <lambdabot>     In the first argument of `liftA2', namely `(:)'
09:16:57 <lambdabot>     In the second argument of `(.)', namely `liftA2 (:) head id'
09:17:11 <mauke> :t iterate (liftA2 (:) head id)
09:17:12 <lambdabot> forall a. [a] -> [[a]]
09:17:24 <Paprikachu> > iterate $ liftA2 (:) head id $ "blah"
09:17:25 <lambdabot>   Couldn't match expected type `a -> a'
09:17:25 <lambdabot>         against inferred type `[GHC.T...
09:18:15 <mauke> :t iterate ((:) =<< head)
09:18:16 <lambdabot> forall a. [a] -> [[a]]
09:18:21 <mauke> > iterate ((:) =<< head) "blah"
09:18:23 <lambdabot>   ["blah","bblah","bbblah","bbbblah","bbbbblah","bbbbbblah","bbbbbbblah","bbb...
09:18:27 <Paprikachu> :t =<<
09:18:28 <lambdabot> parse error on input `=<<'
09:18:34 <Paprikachu> :t (=<<)
09:18:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:18:47 <Paprikachu> -_-
09:19:19 <quicksilver> Cale: pure exceptions are dreams when you are still awake, from which you cannot escape?
09:19:22 <mauke> Paprikachu: http://mauke.hopto.org/tmp/flow.png
09:19:55 <mauke> (=<<) c f x = c (f x) x
09:20:22 <nand`> mauke: that's.. one way to illustrate
09:20:38 <Paprikachu> > (=<<) (+) (*2) 5
09:20:40 <lambdabot>   15
09:20:41 <mauke> 100 hours in mspaint
09:21:21 <Paprikachu> now that i understand this operator... what is its use?
09:21:31 <mauke> you only think you understand it
09:22:34 <Paprikachu> oh well
09:22:55 <Paprikachu> :t (<*>
09:22:56 <lambdabot> parse error (possibly incorrect indentation)
09:22:58 <Paprikachu> :t (<*>)
09:23:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:23:15 <mauke> <*> is identical to ap in the diagram above, btw
09:23:28 <Paprikachu> i don't really understand your diagram
09:23:44 <mauke> (<*>) c g x = c x (g x)
09:24:07 <mauke> and liftA2/liftM2 c f g x = c (f x) (g x)
09:24:27 <Paprikachu> so why is <*> not a function with a regular name
09:24:31 <Paprikachu> ifit takes 3 arguments
09:24:34 <Paprikachu> if it
09:24:56 <Clint> it doesn't take 3 arguments
09:24:58 <lightquake> it takes two arguments
09:25:02 <nand`> it takes one argument
09:25:03 <Paprikachu> c, g, x
09:25:43 <lightquake> i can equally rewrite that as (<*>) c g = \x -> c x (g x)
09:25:57 <mauke> c <*> g = \x -> c x (g x)
09:26:05 <lightquake> look, now it only has two arguments
09:26:08 <mauke> now it's a function composer
09:26:11 <Paprikachu> oh, it returns a function
09:26:20 <nand`> > let (f . g) x = f (g x) in (succ . succ) 3
09:26:22 <lambdabot>   5
09:27:14 <Paprikachu> > ((+) <*> (*2)) 5
09:27:15 <lambdabot>   15
09:27:43 <Paprikachu> > (+) <*> (*2) $ 5
09:27:44 <lambdabot>   15
09:28:20 <EvanR> all functions take exactly one argument
09:29:07 <lightquake> this is true.
09:29:14 <Paprikachu> > ((<*>) (+)) (*2) $ 5
09:29:15 <lambdabot>   15
09:30:09 <Paprikachu> > (<*>) . (+) . (*2) $ 5
09:30:10 <lambdabot>   Overlapping instances for GHC.Show.Show
09:30:10 <lambdabot>                              (((a -...
09:30:18 <Paprikachu> > ((<*>) . (+) . (*2)) 5
09:30:19 <lambdabot>   Overlapping instances for GHC.Show.Show
09:30:19 <lambdabot>                              (((a -...
09:30:28 <Paprikachu> > ((<*>) (+) . (*2)) 5
09:30:29 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:30:29 <lambdabot>    arising from a use of `...
09:30:57 <Paprikachu> > ((<*>) $ (+) . (*2)) 5
09:30:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:30:58 <lambdabot>    arising from a use of `...
09:31:05 <parcs`> is there some TH to replace the contents of a file with a binary value?
09:31:05 <nand`> NumInstances strikes again?
09:31:07 <Paprikachu> > ((<*>) $ (+) $ (*2)) 5
09:31:08 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a)
09:31:09 <lambdabot>    arising from a u...
09:31:19 <Paprikachu> > (<*>) $ (+) $ (*2) $ 5
09:31:21 <lambdabot>   Overlapping instances for GHC.Show.Show
09:31:21 <lambdabot>                              (((a -...
09:31:24 <Paprikachu> ok.
09:31:28 <Paprikachu> i give up.
09:31:29 <parcs`> let me try that again
09:32:08 <quicksilver> parcs`: well you can run arbitrary IO inside TH
09:32:13 <quicksilver> but as to whether that's sane... :)
09:32:22 <nand`> quicksilver: you can? with unsafePerformIO?
09:32:25 <Paprikachu> what is wrong here?
09:32:32 <parcs`> nand`: runQIO
09:32:35 <nand`> or does the Q monad allow IO
09:32:37 <nand`> ah
09:32:51 <quicksilver> nand`: runIO :: IO a -> Q a
09:33:03 <lightquake> > ((<*>) (+) (*2)) 5
09:33:04 <lambdabot>   15
09:33:18 <parcs`> i meant, is there some TH to read the contents of a file into a list, vector, bytestring or something?
09:33:59 <Paprikachu> > a <- b <- 42
09:34:00 <lambdabot>   <no location info>: parse error on input `<-'
09:34:02 <malsyned> Anybody know what's up with haskell.org today?
09:34:05 <Paprikachu> > a <- 42
09:34:07 <lambdabot>   not an expression: `a <- 42'
09:34:12 <Paprikachu> > doa <- 42
09:34:13 <lambdabot>   not an expression: `doa <- 42'
09:34:13 <luite> parcs`: you want the file contents embedded in your executable?
09:34:16 <Paprikachu> > do a <- 42
09:34:17 <lambdabot>   <no location info>:
09:34:17 <lambdabot>      The last statement in a 'do' construct must be an ...
09:34:23 <Paprikachu> > do a <- 42 print a
09:34:24 <lambdabot>   <no location info>:
09:34:24 <lambdabot>      The last statement in a 'do' construct must be an ...
09:34:28 <Paprikachu> > do a <- 42; print a
09:34:29 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.IO t))
09:34:29 <lambdabot>    arising from the literal ...
09:34:30 <parcs`> luite: yeah, that's a much better way of putting it
09:34:33 <Paprikachu> fu
09:34:36 <malsyned> do { a <- 42 ; print a }
09:34:36 <luite> parcs`: the file-embed package
09:34:39 <malsyned> > do { a <- 42 ; print a }
09:34:40 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.IO t))
09:34:40 <lambdabot>    arising from the literal ...
09:34:42 <merijn> Paprikachu: FYI, you can privmsg lambdabot
09:34:47 <parcs`> luite: awesome! thanks
09:34:56 <merijn> Relatedly, you can't do IO in lambdabot
09:35:01 <EvanR> > do { a <- return 42; print a }
09:35:02 <lambdabot>   <IO ()>
09:35:12 <nand`> (you can also download GHCi and run it locally, which will 1. allow you to run IO, 2. perhaps less confusing error messages due to lack of Caleskell)
09:35:48 <Paprikachu> Prelude> :t <*>
09:35:49 <Paprikachu> <interactive>:1:1: parse error on input `<*>'
09:35:51 <Paprikachu> :|
09:36:03 <Eduard_Munteanu> :t (<*>)
09:36:04 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:36:08 <Paprikachu> Prelude> :t (<*>)
09:36:10 <Paprikachu> <interactive>:1:1: Not in scope: `<*>'
09:36:22 <atriq> Paprikachu, import Control.Applicative
09:36:46 <Paprikachu> is there something like a import *; ?
09:36:58 <EvanR> import all the modules!
09:37:04 <EvanR> o/
09:37:06 <Eduard_Munteanu> moar modules!
09:37:37 <atriq> That would be, simply put, ridiculous
09:37:38 <nand`> (would it be possible to query a list of all modules exported by all packages using metaquerying tools like ghc-pkg, then dump that into .ghci? not that it would be very sane, mind)
09:37:56 <atriq> @hoogle sequenceA
09:37:56 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
09:37:56 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
09:37:58 <Paprikachu> how can i set the Prelude> text?
09:38:07 <nand`> :set prompt="> "
09:38:09 <nand`> or whatever
09:38:17 <EvanR> nand`: it now suggests things you might have wanted to import when the name isnt found
09:38:24 <EvanR> its often wrong
09:38:48 <merijn> nand`: Real Haskell-ballers use "λ " ;)
09:38:57 <nand`> merijn: I do!
09:39:15 <nand`> I actually have λ for my bash prompt as well :P
09:39:33 <Eduard_Munteanu> That must be confusing.
09:39:48 <Paprikachu> what is Applicative?
09:39:52 <nand`> “nand@nanodesu ~/.xmonad λ ls” <- I don't think it is
09:39:59 <nand`> Paprikachu: a type class for applicative functors
09:40:13 <Paprikachu> and what is an applicative functor? :x
09:41:03 <merijn> :i Applicative
09:41:07 <nand`> I'm not sure if now is the best time to introduce them
09:41:07 <Hadaka> I have thing for which in Java I would use ConcurrentHashMap - I need to verify that no two threads modify the same file at the same time - what should I use in haskell? just roll my own MVar, roll my own TVar, or use some library that handles this for me?
09:41:08 <merijn> hmm
09:41:11 <merijn> @info Applicative
09:41:11 <lambdabot> Applicative
09:41:12 <rosie> Hoogle is down for me -- where can I find documentation on overloadedStrings?
09:41:16 <nand`> there's no @info
09:41:28 <nand`> it gets typo-fuzzy-parsed as @undo
09:41:36 <Cale> an applicative functor is a functor f which has additional operations  pure :: a -> f a, and (<*>) :: f (a -> b) -> f a -> f b, satisfying some simple laws
09:42:06 <merijn> rosie: OverloadedStrings is fairly simple, it treats all literal strings as being "fromString whatever" and the fromString is provided by the IsString typeclass
09:42:50 <Hadaka> it probably does not matter for performance, but on a theoretical level it would be really nice if the data structure would be optimized for concurrent access - just like java's ConcurrentHashMap is (it is not simply a synchronized HashMap)
09:43:07 <parcs`> holy hell that is not efficient at all. embedding a 16MB file eats 3GB of ram during compile time and takes about a minute to compile and link
09:43:27 <EvanR> Hadaka: but they are optimized, all data is immutable
09:43:34 <Paprikachu> ok, i guess i don't want to know what an applicative functor is :d
09:43:39 <EvanR> you can access all you want from wherever
09:43:40 <merijn> Hadaka: Haskell hash maps are immutable, so you don't need concurrent hash maps :p
09:43:52 <Hadaka> did you guys read my problem?
09:44:38 <merijn> Hadaka: It depends really, if you need simple atomic access I'd use an MVar with modifyMVar
09:44:46 <Paprikachu> what does => mean again?
09:44:52 <Cale> Hadaka: You could use an MVar (Set FilePath)
09:45:04 <Cale> Paprikachu: Do you already know what monads are about?
09:45:10 <Paprikachu> no i don't
09:45:13 <Cale> Paprikachu: If not, then don't bother with applicative functors yet
09:45:16 <merijn> Hadaka: As long as you only use modifyMVar it is always atomic anyway
09:45:27 <rosie> merijn: So it's a converter from String literals to ByteString (apologies, my internet connection is hanging)
09:45:28 <Hadaka> merijn, Cale: that is the same as a synchronized map, completely mutex locked for edits, no concurrency
09:45:41 <Hadaka> it's not really a problem here, I'd just like to do better
09:45:52 <byorgey> Paprikachu: => separates class constraints from the rest of the type
09:46:11 <Paprikachu> :t (<*>)
09:46:12 <merijn> rosie: Not just ByteString, whatever you'd like
09:46:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:46:21 <Paprikachu> so that means f must be an applicative, right?
09:46:25 <EvanR> Hadaka: seems like theoretically its simpler to just synchronize
09:46:29 <merijn> rosie: For example, String to Text, String to XML (if you'd like)
09:46:41 <Cale> Hadaka: I was thinking that you'd only take the Map briefly, but you're right, that won't quite do.
09:46:47 <rosie> merijn: Is the conversion based on type inference?
09:47:17 <merijn> rosie: Yes, similar to numeric literals (i.e. passing 5 to a function expecting a float is identical to passing "fromIntegral 5" to that functions
09:47:26 <Cale> Hadaka: Well, hmm, it might be okay...
09:48:10 <merijn> rosie: For OverloadStrings passing "test" to something expecting a ByteString is identical to passing 'fromString "test"' where type inference will detect that you want the ByteString instance of fromString
09:48:14 <merijn> :t fromString
09:48:15 <lambdabot> Not in scope: `fromString'
09:48:17 <merijn> hmm
09:48:27 <EvanR> seems like for real concurrent access to a map youd also want transactions
09:48:35 <Paprikachu> so what does the type signature f (a -> b) -> f a -> f b mean
09:48:42 <EvanR> which will involve synchronization eventually
09:48:52 <EvanR> concurrent updates*
09:49:03 <merijn> :t Data.String.fromString
09:49:04 <lambdabot> forall a. (Data.String.IsString a) => String -> a
09:49:04 <Hadaka> EvanR: putIfAbsent etc. things would be enough
09:49:05 <Paprikachu> f is a function (taking a function, taking an a and returning b), ...
09:49:18 <EvanR> Hadaka: well now its application specific
09:49:29 <Cale> Hadaka: The idea is that when something wants to start processing a new file, it briefly takes the MVar, checks whether or not that file is already being processed doing a lookup in the Set, and if not, it adds the element to the set and writes the new set back to the MVar. Otherwise, it just puts the original set back and aborts/tries some other file.
09:49:41 <nand`> Hadaka: you'll probably want to roll your own TMap; I don't know of any and there's probably no way to simply ‘lift’ a normal Map since eg. conflicting insertions can be resolved in two different orders that won't change the semantics for Map but there's no way of knowing that in general
09:50:04 <rosie> merijn: awesome. makes sense, thanks. How should I parse this error?   No instance for (Data.String.IsString [a0])  arising from the literal `" etc."'Possible fix:  add an instance declaration for (Data.String.IsString [a0])    In the first argument of `(++)', namely…
09:50:08 <Paprikachu> :t read
09:50:08 <lambdabot> forall a. (Read a) => String -> a
09:50:15 <EvanR> Paprikachu: f is not a function, its a type constructor
09:50:23 <Cale> Hadaka: the whole time that the MVar is taken should be much less time than it takes to do the real work, hopefully'
09:50:28 <Paprikachu> QQ
09:50:41 <merijn> rosie: Type inference is expecting something of type "[a]", but " etc." clearly doesn't match that
09:50:41 <Hadaka> Cale: I understand that method
09:50:53 <Cale> Paprikachu: f is a *type level* function -- a type constructor
09:51:04 <Cale> Paprikachu: It takes a type and produces another type
09:51:15 <merijn> rosie: Or rather, it's telling you that [a] is not an instance of IsString, so calling fromString fails
09:51:16 <Cale> Paprikachu: For example, Maybe is such an f
09:51:54 <Hadaka> the point of a "concurrent hash map" is to allow for many simultaneous writers (to different keys) without lock contention
09:52:07 <merijn> rosie: Maybe hpaste a minimal sample + full error?
09:52:14 <EvanR> Hadaka: for that to make any sense in general, you need transactions
09:52:27 <Cale> Hadaka: You could make an honest to goodness concurrent set structure, but to be honest, there are other overheads which usually make that not worthwhile.
09:53:06 <EvanR> often you dont 'just want to write to stuff' you might want to write somewhere something depending on the current state
09:53:29 <Hadaka> EvanR: sure, for the most generic case - however, concurrenthashmap is an often enough appearing construction to be useful quite a lot of the time
09:53:35 <Cale> In this case, it doesn't really sound like you need multiple writers to different parts of the Set to operate concurrently, because inserting a key into a Set takes so little time anyway that it should be almost irrelevant.
09:53:46 <Hadaka> which is why it is included in the java standard library
09:53:51 <rosie> merijn: So this line "No instance for (Data.String.IsString [a0])" means, we have a list whose type is not an instance of Data.String.isString (that is, it doesn't have  a fromString method defined), so type inference is not allowing us to convert the String literal into the type we're expecting? i'll post in a sec...
09:54:21 <EvanR> Hadaka: well java has special needs
09:55:13 <Peaker> is SPECIALIZE recursive?
09:55:26 <Cale> Peaker: no
09:55:33 <merijn> rosie: Yes, for example, if you had 'foo :: [a] -> b; foo "test"' then the type inference sees that it needs the [a] instance of IsString to return the proper value (i.e. the fromString instance that will turn "test" into an [a]), and it's saying that that instance doesn't exist
09:55:34 <Peaker> thanks
09:55:49 <Cale> Peaker: At least, last time I checked it wasn't.
09:56:05 <Cale> Peaker: would have been a few GHC releases ago :)
09:56:21 <Hadaka> heh, there's a google summer of code thing for this exact thing: http://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/lorehead/1
09:56:51 <Hadaka> (or proposal)
09:57:01 <EvanR> im not sure the point if its not for performance
09:57:02 <Cale> Hashtables are overrated
09:57:09 <Cale> In general
09:58:01 <Cale> I don't like them because hash functions are by their very nature difficult to understand, and tree structures are relatively easily understood and asymptotically just as good.
09:58:04 <Hadaka> it doesn't really matter if its a hashtable or tree or a trie or whatever - the point is to have a data structure which doesn't not need to be completely locked for modification
09:58:39 <EvanR> if you just dont want to deal with the locking, you can hide that details away in another type
09:58:51 <EvanR> you wont have to worry about it
09:58:54 <merijn> Hadaka: locking doesn't take that long, though
09:59:13 <merijn> Hadaka: Most likely a concurrent version will have more overhead than just locking the entire thing shortly everytime will
10:00:25 <DMcGill> > let x@(Just x') = Nothing in x
10:00:26 <lambdabot>   *Exception: <interactive>:3:4-24: Irrefutable pattern failed for pattern (x...
10:00:38 <DMcGill> is there a lazy version of '@'?
10:01:28 <Hadaka> thank you for all your answers - looks like the default way in haskell is to do it with just MVar and a normal Map
10:01:59 <nand`> DMcGill: I don't see what that has to do with laziness
10:02:05 <nand`> > let x@(Just _) = Nothing in ()
10:02:07 <lambdabot>   ()
10:02:41 <DMcGill> similar to suspended pattern matching, so I could still refer to x but not x'
10:02:48 <merijn> DMcGill: Maybe you want pattern guards?
10:03:06 <DMcGill> so "let x@(Just x') = Nothing in x == Nothing"
10:03:14 <merijn> "foo x | Just y <- x = whatever | otherwise = somethingelse"
10:03:47 <DMcGill> > let x = Nothing; x' = fromJust x in x
10:03:48 <lambdabot>   Nothing
10:03:54 <DMcGill> thanks
10:05:44 <parcs`> @hoogle bytes
10:05:45 <lambdabot> Data.ByteString data ByteString
10:05:45 <lambdabot> Data.ByteString.Char8 data ByteString
10:05:45 <lambdabot> Data.ByteString.Lazy data ByteString
10:05:56 <hpaste> r pasted “overloaded strings” at http://hpaste.org/73904
10:06:08 <rosie> merijn: posted
10:07:18 <rosie> merijn: the strange thing is I don't even use the concatenated string "use"...
10:07:19 <DMcGill> merijn: this is what I meant
10:07:29 <DMcGill> > let x@(~(Just x')) = Nothing in x
10:07:31 <lambdabot>   Nothing
10:10:57 <rosie> merijn: figured it out
10:14:57 <Paprikachu> :t (@)
10:14:58 <lambdabot> parse error on input `@'
10:15:06 <Paprikachu> :t (~)
10:15:07 <lambdabot> parse error on input `)'
10:15:17 <Paprikachu> what
10:15:33 <Mon_Ouie> @ isn't a function, it's used for pattern matching
10:15:38 <nand`> @ and ~ aren't valid operator names
10:15:46 <Paprikachu> what do they do?
10:15:46 <Mon_Ouie> It gives a name to the whole matched expression
10:16:08 <nand`> they're called as-patterns and irrefutable matches respectively, best read up on them in the Haskell report
10:16:12 <ion> > let f a@b@c@d@e = (a,b,c,d,e) in f 42
10:16:13 <lambdabot>   (42,42,42,42,42)
10:16:33 <Paprikachu> what
10:16:52 <DMcGill> @src f
10:16:52 <lambdabot> Source not found. Where did you learn to type?
10:17:03 <ion> > let f a@(Just b) = (a, b) in f (Just 42)
10:17:04 <lambdabot>   (Just 42,42)
10:17:40 <Paprikachu> i dont get it
10:18:05 <hiptobecubic> Paprikachu, think of it as a copy of the thing in parens
10:18:12 <nand`> a@b is equivalent to matching ‘b’ but gives the whole of ‘b’ an extra name: ‘a’
10:18:35 <Paprikachu> oh
10:18:36 <luksow> hi there, what's your suggestion of lib for converting records to JSON?
10:18:47 <nand`> perhaps package ‘json’
10:18:58 <hiptobecubic> > let f = wholelist@(x:xs) = (wholelist, x, xs) in f [1,2,3,4,5]
10:18:59 <lambdabot>   <no location info>: parse error on input `='
10:19:02 <Paprikachu> > let f x@[] = x in f []
10:19:02 <hiptobecubic> damnit
10:19:03 <lambdabot>   []
10:19:07 <hiptobecubic> > let f wholelist@(x:xs) = (wholelist, x, xs) in f [1,2,3,4,5]
10:19:08 <lambdabot>   ([1,2,3,4,5],1,[2,3,4,5])
10:19:39 <Paprikachu> and what's ~?
10:19:46 <luksow> nand`, you mean Text.JSON?
10:20:10 <sm> luksow: the hackage package json.. or aeson or (newest) cassava
10:20:21 <nand`> > let f (Just _) = 3 in f Nothing
10:20:21 <sm> sorry, ignore the last
10:20:23 <lambdabot>   *Exception: <interactive>:3:4-17: Non-exhaustive patterns in function f
10:20:25 <nand`> > let f ~(Just _) = 3 in f Nothing
10:20:27 <lambdabot>   3
10:20:33 <nand`> > let f (Just x) = x in f Nothing
10:20:34 <lambdabot>   *Exception: <interactive>:3:4-17: Non-exhaustive patterns in function f
10:20:36 <nand`> > let f ~(Just x) = x in f Nothing
10:20:37 <lambdabot>   *Exception: <interactive>:3:4-18: Irrefutable pattern failed for pattern (D...
10:20:50 <iamtakingiteasy> does haskell has any thread/actor support for concurent computations (like, on different cores of CPU) ?
10:21:15 <nand`> iamtakingiteasy: there are a few different techniques
10:21:32 <iamtakingiteasy> what are they?
10:21:49 <nand`> the ‘simplest/dumbest’ way would be to use forkIO
10:21:54 <luksow> sm, thanks! any comments/articles/comparisions on those?
10:22:02 <iamtakingiteasy> aha
10:22:07 <iamtakingiteasy> but haskell is immutable
10:22:13 <nand`> more advanced techiques include stuff like STM (software transactional memory) which allows for efficient concurrent access to data
10:22:15 <iamtakingiteasy> it should paralell very well
10:22:47 <iamtakingiteasy> ah, interesting
10:23:12 <nand`> oh, are you talking about concurrent evaluation of immutable stuff?
10:23:32 <latro`a> > let f (Just x) = 3 in f Nothing
10:23:33 <lambdabot>   *Exception: <interactive>:3:4-17: Non-exhaustive patterns in function f
10:23:35 <latro`a> ah
10:23:36 <nand`> or about concurrent /behaviors/ (ie. defining programs that run concurrently)
10:23:55 <hiptobecubic> nand`, i think you're overestimating the question
10:23:57 <iamtakingiteasy> no, i am seeking for the boost of CPU-intensive computations
10:24:00 <Peaker> do forkIOs have priorities?
10:24:02 <hiptobecubic> this sounds like a "how can i go fast for free" question
10:24:18 <nand`> hiptobecubic: it seems you were right :P
10:24:21 <iamtakingiteasy> :/
10:24:34 <iamtakingiteasy> but it uses single core of my core i7
10:24:35 <hiptobecubic> iamtakingiteasy, myprogram +RTS -N
10:24:52 <hiptobecubic> iamtakingiteasy, and compile with ghc -threaded -rtsopts
10:25:26 <hiptobecubic> and before you come back and complain that it's slower than before, google haskellwiki parallel and read a bit.
10:25:45 <iamtakingiteasy> i see. thanks!
10:26:02 <iamtakingiteasy> sorry for giving you false hopes of my cleverness
10:28:49 <hiptobecubic> iamtakingiteasy, if you have something embarrassingly parallel, then look at Control.Parallel for some nice things
10:31:05 <hiptobecubic> iamtakingiteasy, https://donsbot.wordpress.com/2009/09/03/parallel-programming-in-haskell-a-reading-list/
10:31:24 <iamtakingiteasy> awesome!
10:38:44 * hackagebot lambda-canvas 0.1 - Educational drawing canvas for FP explorers.  http://hackage.haskell.org/package/lambda-canvas-0.1 (DimitrySolovyov)
10:42:33 <snifcjo> Hello! I want to make a little timer that ticks down from 30 seconds to 0 with gtkhs. How would I store the starting time in Haskell?
10:42:45 <Paprikachu> > let factorial :: Integer -> Integer; factorial n = product [1 .. n] in factorial 100000
10:42:49 <lambdabot>   mueval-core: Time limit exceeded
10:42:57 <Paprikachu> > let factorial :: Integer -> Integer; factorial n = product [1 .. n] in factorial 10000
10:42:58 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
10:43:42 <Paprikachu> > let factorial :: Integer -> Integer; factorial n = product [1 .. n] in take 1 $ show $ factorial 10000
10:43:44 <lambdabot>   "2"
10:44:00 <Paprikachu> > let factorial :: Integer -> Integer; factorial n = product [1 .. n] in head $ show $ factorial 10000
10:44:01 <lambdabot>   '2'
10:44:27 <Paprikachu> > let factorial :: Integer -> Integer; factorial n = product [1 .. n] in head . show . factorial 10000
10:44:28 <lambdabot>   Couldn't match expected type `f a'
10:44:28 <lambdabot>         against inferred type `GHC.Integ...
10:44:38 <Paprikachu> > let factorial :: Integer -> Integer; factorial n = product [1 .. n] in (head . show . factorial) 10000
10:44:41 <lambdabot>   '2'
10:45:38 <Paprikachu> > let factorial :: Integer -> Integer; factorial = product [1 ..] in (head . show . factorial) 10000
10:45:39 <lambdabot>   No instance for (GHC.Enum.Enum
10:45:40 <lambdabot>                     (GHC.Integer.Type.Intege...
10:46:00 <ion> It works in private, too.
10:48:26 <Paprikachu> > let factorial :: Integer -> Integer; factorial = product . ((flip take) [1..]) in (head . show . factorial) 10000
10:48:27 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
10:48:27 <lambdabot>         against inf...
10:48:33 <Paprikachu> what
10:49:09 <Cale> :t take
10:49:10 <lambdabot> forall a. Int -> [a] -> [a]
10:49:15 <Cale> take uses Int  :(
10:49:27 <obiwahn> @seen wickendmic
10:49:27 <lambdabot> Unknown command, try @list
10:49:37 <Cale> preflex: seen wickendmic
10:49:37 <preflex>  Sorry, I haven't seen wickendmic
10:50:45 <obiwahn> @seen wickendmic
10:50:45 <lambdabot> Unknown command, try @list
10:50:48 <Paprikachu> > let factorial = product . ((flip take) [1..]) in (head . show . factorial) 10
10:50:50 <lambdabot>   '3'
10:50:59 <Cale> obiwahn: If you were paying attention, that command doesn't exist.
10:51:01 <Cale> :)
10:51:19 <Cale> obiwahn: preflex will do it though, see above
10:51:20 <Paprikachu> > let factorial = product . ((flip take) [1..]) in factorial 10
10:51:23 <lambdabot>   3628800
10:51:34 <Paprikachu> can this be written better?
10:51:35 <Cale> > let factorial = product . ((flip take) [1..]) in factorial 100
10:51:37 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
10:51:50 <obiwahn> hey Cale my bot is offline atm and i have lost my screen session a few times when givin the command:)
10:51:53 <Cale> oh, of course :)
10:52:09 <Cale> obiwahn: preflex hadn't seen the guy either
10:52:11 <parcs`> > let factorial = product . enumFromTo 1 in factorial 10
10:52:13 <lambdabot>   3628800
10:52:13 <obiwahn> i thought the bot maybe gives some strange escape sequence
10:52:14 <Paprikachu> especially the flip-part
10:52:24 <Cale> Paprikachu: Yeah, you can use enumFromTo
10:52:37 <Paprikachu> > enumFromTo 1 10
10:52:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:52:42 <Cale> Paprikachu: but tbh, there's nothing wrong with  factorial n = product [1..n]
10:52:43 <DMcGill> enumFromTo x y = [x..y]
10:52:46 <obiwahn> screen detached itself just in the moment you wrote ...
10:53:12 <Paprikachu> well i wanted to make it so i don't have to write down the parameter x
10:53:41 <merijn> That's easy :p
10:53:41 <lambdabot> merijn: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:54:01 <Paprikachu> > let factorial = product . (flip take . [1..]) in factorial 10
10:54:02 <lambdabot>   Couldn't match expected type `[a1 -> a]'
10:54:02 <lambdabot>         against inferred type `GHC...
10:54:04 <merijn> @pl \x -> product [1..x]
10:54:04 <lambdabot> product . enumFromTo 1
10:54:15 <Paprikachu> > let factorial = product . (flip take $ [1..]) in factorial 10
10:54:17 <lambdabot>   3628800
10:54:33 <Cale> :t let factorial = product . (flip take $ [1..]) in factorial
10:54:35 <lambdabot> forall a. (Enum a, Num a) => Int -> a
10:54:51 <merijn> > let factorial = product . enumFromTo 1 in factorial 10
10:54:52 <lambdabot>   3628800
10:55:04 <Cale> :t let factorial = product . enumFromTo 1 in factorial
10:55:05 <lambdabot> forall a. (Enum a, Num a) => a -> a
10:56:54 <byorgey> > let factorial = product . (flip take $ [1..]) in factorial 100
10:56:56 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
10:57:01 <Starfire> Is there a mirror for the Haskell Platform? haskell.org seems down...
10:57:15 <byorgey> again!?
10:57:31 <obiwahn> Main: caught (and ignoring) too few bytes. Failed reading at byte position 8 - who can i fix taht?
10:57:50 <Starfire> Funnily enough, hackage.haskell.org seems to work.
10:57:53 <sykora> hackage is up though
10:58:28 <Starfire> However, lambda.haskell.org, which hosts the installer, is down.
10:58:50 <Cale> obiwahn: What program is producing that?
10:59:40 <byorgey> I've seen that before, I forget what the problem is
10:59:46 <byorgey> probably an encoding issue
11:00:53 <Cale> obiwahn: are you on Windows by any chance?
11:00:59 <obiwahn> lambdabot when using the seen command - sorry i have to do something about my screen
11:01:12 <obiwahn> Cale: no it is a linux on my server
11:01:14 <Cale> oh, right
11:01:16 <Cale> lol
11:01:24 <obiwahn> brb
11:01:28 <Cale> That means...
11:01:35 <Cale> okay, just leave then
11:01:38 <Cale> lol
11:02:00 <Cale> That is the whole reason that the @seen plugin is disabled
11:02:10 <Cale> The seen database file gets corrupted
11:02:21 <byorgey> haha, THAT'S where I've seen it before =)
11:02:21 <Cale> and a blank file is not an acceptable seen database, apparently
11:02:29 <armlesshobo> is there a way to convert an Int to a Double/Float in Fractional?
11:02:36 <Cale> So you have to keep copying over a good one
11:02:42 <Cale> and it's tedious and stupid
11:02:46 <byorgey> armlesshobo: "in Fractional" ?
11:02:50 <latro`a> armlesshobo, fromIntegral surely
11:03:03 <byorgey> fromIntegral will convert an Int to a Double or Float.
11:03:16 <byorgey> I don't understand the Fractional part of your question.
11:03:20 <armlesshobo> byorgey: oops. that was supposed to be erased :S
11:03:25 <byorgey> ok =)
11:03:31 <armlesshobo> ty :)
11:03:37 <byorgey> @quote fromIntegral
11:03:37 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
11:03:44 * hackagebot proctest 0.1.3.0 - An IO library for testing interactive command line programs  http://hackage.haskell.org/package/proctest-0.1.3.0 (NiklasHambuechen)
11:03:47 <byorgey> @quote fromIntegral
11:03:48 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
11:03:55 <byorgey> @quote gonna.call
11:03:55 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
11:04:08 <Paprikachu> @quote flip
11:04:08 <lambdabot> chmod666 says: > let (><>) = ((flip ($)) (foldr ((:) . succ) [] "hs&r\US`\USehrg") $ (.) const const) in "what is this" ><> "i don't know"
11:04:10 * byorgey matches wits with a rutabaga
11:04:22 <Cale> lambdabot really needs a maintainer
11:04:26 <Paprikachu> > let (><>) = ((flip ($)) (foldr ((:) . succ) [] "hs&r\US`\USehrg") $ (.) const const) in "what is this" ><> "i don't know"
11:04:28 <lambdabot>   "it's a fish"
11:04:31 <Paprikachu> wtf :D
11:04:32 <obiwahn> re :)
11:04:34 <byorgey> hahaha
11:04:44 <plat0>                    "what is this" ><> "i don't know"
11:04:44 <armlesshobo> lol
11:04:48 <Cale> obiwahn: That error is the reason that I've disabled the @seen plugin
11:04:58 <Cale> obiwahn: The seen database gets corrupted
11:05:09 <Cale> obiwahn: and a blank file is not an acceptable substitute
11:05:28 <Cale> obiwahn: so you have to keep copying over a known good db
11:05:33 <Cale> and it's tedious and stupid
11:05:40 <obiwahn> oh
11:06:02 <Paprikachu> @quote $
11:06:02 <lambdabot> kmc: says: "monads are like containers, as long as you forget everything you know about containers, and treat it as a synonym for 'monad'"
11:06:26 <Paprikachu> @quote read
11:06:26 <lambdabot> Cale says: I don't think he can read your fancy schmancy lowercase letters.
11:06:32 <geekosaur> I think that's a regex, and every quote has an end of string
11:06:39 <geekosaur> @quote \$
11:06:39 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
11:06:41 <Paprikachu> ah
11:07:03 <Paprikachu> @quote </*>
11:07:03 <lambdabot> chmod666 says: > let (><>) = ((flip ($)) (foldr ((:) . succ) [] "hs&r\US`\USehrg") $ (.) const const) in "what is this" ><> "i don't know"
11:07:10 <Paprikachu> @quote <\*>
11:07:10 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
11:07:33 <Paprikachu> @quote =<<
11:07:34 <lambdabot> zalgo says: import Random;main=mapM_((>>(י=<<randomRIO('̀','ͯ'))).י)=<<getContents;י=putChar
11:08:00 <Paprikachu> @quote :
11:08:00 <lambdabot> sjanssen says: Quoth the Prelude, Chapter 6, verse 4:  Yeah verily shall repeat floweth cons cells over.
11:08:07 <obiwahn> oh Cale it is ugly and stupid:)
11:08:20 <obiwahn> but it works again!!!! thanks for the hint:)
11:08:53 <Cale> obiwahn: It works again approximately until the next time lambdabot gets killed for any reason and needs to be restarted
11:10:18 <Paprikachu> > let (') = (+) in 2 ' 2
11:10:19 <lambdabot>   <no location info>:
11:10:20 <lambdabot>      lexical error in string/character literal at chara...
11:10:28 <Paprikachu> :(
11:10:53 <Cale> ' is a valid identifier character, but for ordinary names
11:11:13 <Cale> (and only following something else, not at the beginning)
11:11:24 <Paprikachu> > let (+++++) = (+) in 2 +++++ 2
11:11:25 <lambdabot>   4
11:11:48 <geekosaur> also ' has to be internal, not initial; initial ' is used by Char literals (and Template Haskell)
11:12:17 <Paprikachu> > let (+') = (+) in 2 +' 2
11:12:18 <lambdabot>   <no location info>:
11:12:19 <lambdabot>      lexical error in string/character literal at chara...
11:12:33 <geekosaur> identifier character, as Cale said
11:12:53 <geekosaur> > let a'd'd = (+) in a'd'd 2 2
11:12:54 <lambdabot>   4
11:12:57 <Paprikachu> > let (p') = (+) in 2 p' 2
11:12:58 <lambdabot>   2
11:13:15 <srhb> That's odd.
11:13:30 <Paprikachu> what.
11:13:31 <srhb> Oh, quirky Num instance again I guess
11:13:35 <Paprikachu> > let (p') = (+) in 2 p' 2
11:13:36 <lambdabot>   2
11:13:39 <Paprikachu> why on earth
11:13:51 <srhb> Someone did a funny on lambdabots Num instances :P
11:13:58 <c_wraith> Paprikachu: because 2 is the function
11:14:05 <srhb> > 2 2
11:14:06 <c_wraith> > 2 "garble" 8648263
11:14:06 <lambdabot>   2
11:14:07 <lambdabot>   2
11:14:17 <Paprikachu> > let (plus') = (+) in 2 plus' 2
11:14:18 <lambdabot>   2
11:14:27 <srhb> Oh, so it's really a function instance
11:14:28 <geekosaur> translation:  lambdabot doesn't quite speak Haskell any more >.<
11:14:29 <srhb> Of course
11:14:36 <Paprikachu> > let p' = (+) in 2 `p'` 2
11:14:37 <lambdabot>   4
11:14:38 <c_wraith> Paprikachu: when you keep making 2 the function you're applying, the answer isn't going to change
11:14:42 <srhb> Perhaps we should get a more conservative lambdabot in here. :P
11:14:46 <c_wraith> Paprikachu: there you go
11:14:47 <DMcGill> Paprikachu: please use GHCi or /msg lambdabot for just playing around
11:15:22 <Paprikachu> i do not make 2 a function
11:15:28 <c_wraith> Paprikachu: you do!
11:15:30 <Paprikachu> or at least i do not intend to do so :\
11:15:45 <Paprikachu> how ca 2 be a function?
11:15:48 <latro`a> something like p' is a prefix function, not infix
11:15:51 <srhb> Because lambdabot is weird.
11:15:58 <geekosaur> you didn't; lambdabot's maintainer did
11:15:59 <Paprikachu> > let 5 = 4 in 5
11:16:00 <lambdabot>   5
11:16:01 <c_wraith> Paprikachu: well, usually, you'd get a compile error telling you there's no instance for Num for (a -> b)
11:16:21 <c_wraith> Paprikachu: but in lambdabot, there is such an instance
11:16:25 <latro`a> and yeah, lambdabot has a funny Num instance for functions, which means numerical literals can be functions
11:16:39 <Paprikachu> why is it 5?
11:16:44 <Paprikachu> :|
11:16:48 <latro`a> > ((+2) + (+7)) 3
11:16:48 <c_wraith> because that let doesn't bind anything
11:16:49 <lambdabot>   15
11:16:55 <srhb> Paprikachu: Don't worry about it, just conclude that it is not weird in ghci :P
11:17:03 <c_wraith> it's basically the same as "let x = 4 in 5"
11:17:04 <latro`a> ^up there actually makes a lot of sense
11:17:13 <Paprikachu> but i redefine 5? D:
11:17:17 <srhb> (Well, except the last bit)
11:17:31 <c_wraith> Paprikachu: no, you defined a pattern match
11:17:36 <Paprikachu> > let 5 x = x in 5 4
11:17:37 <lambdabot>   <no location info>: Parse error in pattern
11:17:42 <c_wraith> > let "foo" = "bar" in 5
11:17:44 <lambdabot>   5
11:17:50 <c_wraith> that's a pattern match
11:17:59 <c_wraith> It just doesn't happen to bind a name
11:18:12 <Paprikachu> how can i redefine 5 then?
11:18:18 <Cale> Paprikachu: you can't
11:18:18 <srhb> You cannot.
11:18:25 <Paprikachu> :|
11:18:32 <Paprikachu> > 2 2
11:18:33 <srhb> Why on earth would you want to?
11:18:34 <lambdabot>   2
11:18:42 <srhb> It's bad enough that they are functions here. :P
11:18:44 <Paprikachu> why does this work then, if i cant
11:18:52 <latro`a> because it's an *instance*
11:18:54 <latro`a> not a redefinition
11:18:57 <Cale> because 2 means fromInteger (2 :: Integer)
11:19:19 <Cale> and the fromInteger in the instance of Num for functions gives a constant function
11:19:24 <latro`a> and fromInteger is polymorphic
11:19:32 <Cale> :t fromInteger
11:19:33 <lambdabot> forall a. (Num a) => Integer -> a
11:19:39 <latro`a> rather polymorphic in its return type
11:19:56 <Paprikachu> > fromInteger (2 :: Integer) 2
11:19:57 <lambdabot>   2
11:19:59 <Cale> When you write an instance of Num for a new datatype, you provide an implementation of fromInteger
11:20:13 <latro`a> ((+3) + 2) 7
11:20:15 <Cale> which basically says how to interpret numeric literals as that type
11:20:15 <latro`a> erm
11:20:19 <latro`a> > ((+3) + 2) 7
11:20:20 <lambdabot>   12
11:20:40 <Cale> > ((*10) + 2) 7
11:20:41 <lambdabot>   72
11:20:49 <Cale> ^^ might be easier to see what's going on :)
11:21:23 <Paprikachu> soit it possible to define something like complex that can be used as "1+2i"?
11:21:31 <Paprikachu> *is it
11:21:37 <Cale> Paprikachu: That already exists in Data.Complex
11:21:49 <Paprikachu> > 1 + 2i
11:21:50 <lambdabot>   3
11:21:52 <Cale> Though the constructor is :+
11:21:57 <Cale> > 1 :+ 2
11:21:58 <lambdabot>   1.0 :+ 2.0
11:22:06 <latro`a> :t 1 :+ 2
11:22:07 <lambdabot> forall t. (RealFloat t) => Complex t
11:22:08 <Cale> > (0 :+ 1)^2
11:22:09 <lambdabot>   (-1.0) :+ 0.0
11:22:15 <latro`a> why does it insist on RealFloat
11:22:17 <Paprikachu> > e
11:22:18 <lambdabot>   e
11:22:23 <Cale> > exp 1
11:22:24 <lambdabot>   2.718281828459045
11:22:28 <latro`a> why can't you do Complex Int
11:22:37 <Cale> > exp (0 :+ pi)
11:22:38 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
11:22:43 <Cale> > exp (0 :+ pi) + 1
11:22:44 <lambdabot>   0.0 :+ 1.2246467991473532e-16
11:22:55 <Paprikachu> > exp 1 ^ (0 :+ 1) ^ pi
11:22:56 <lambdabot>   No instance for (GHC.Real.Integral (Data.Complex.Complex t))
11:22:56 <lambdabot>    arising fro...
11:23:02 <ziman> > exp (0 :+ pi) + 1 :: Complex Float
11:23:04 <lambdabot>   0.0 :+ (-8.742278e-8)
11:23:10 <latro`a> > 1 :+ 2 :: Complex Int
11:23:11 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
11:23:12 <lambdabot>    arising from a use o...
11:23:14 <Paprikachu> > pi
11:23:14 <latro`a> wtf
11:23:15 <lambdabot>   3.141592653589793
11:23:17 <latro`a> :t (:+)
11:23:18 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
11:23:20 <latro`a> ^wtf
11:23:25 <latro`a> why does it require realfloat :(
11:23:28 <latro`a> in the constructor, even
11:23:32 <Cale> latro`a: abs
11:23:35 <Cale> :t abs
11:23:36 <lambdabot> forall a. (Num a) => a -> a
11:23:43 <rosie> How can I find out how "show" is implemented for BsonValue ?
11:23:44 <Cale> > abs (1 :+ 1)
11:23:45 <Paprikachu> > (exp 1) :+ 0 `pow` (0 :+ 1) `pow` pi :+ 0
11:23:45 <lambdabot>   1.4142135623730951 :+ 0.0
11:23:45 <latro`a> oh
11:23:46 <lambdabot>   Not in scope: `pow'Not in scope: `pow'Precedence parsing error
11:23:46 <lambdabot>      cannot ...
11:23:48 <latro`a> that's ugly
11:23:50 <latro`a> but OK
11:24:04 <Paprikachu> > ((exp 1) :+ 0) `pow` (0 :+ 1) `pow` (pi :+ 0)
11:24:05 <lambdabot>   Not in scope: `pow'Not in scope: `pow'
11:24:14 <Paprikachu> > ((exp 1) :+ 0) `pow` (0 :+ 1) * (pi :+ 0)
11:24:15 <lambdabot>   Not in scope: `pow'
11:24:17 <ludwigschubert> exit
11:24:17 <Cale> Paprikachu: perhaps you want **
11:24:25 <Cale> Paprikachu: are you just ignoring the error messages?
11:24:31 <Paprikachu> > ((exp 1) :+ 0) ** ((0 :+ 1) * (pi :+ 0))
11:24:32 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
11:24:41 <Cale> If pow wasn't in scope before, it's not going to be more in scope the next time ;)
11:24:42 <srhb> rosie: In the source, have you seen that it says deriving Show?
11:25:00 <Paprikachu> meh, floating point errors
11:25:00 <srhb> rosie: And have you read how deriving works?
11:25:06 <Paprikachu> it's exactly -1
11:25:35 <Paprikachu> > ((exp 1) :+ 0) ** (0 :+ 1 * pi :+ 0)
11:25:36 <lambdabot>   Precedence parsing error
11:25:36 <lambdabot>      cannot mix `Data.Complex.:+' [infix 6] and `D...
11:25:47 <Cale> That's about as close to -1 as you could expect
11:25:48 <Paprikachu> > ((exp 1) :+ 0) ** (0 :+ 1 * (pi :+ 0))
11:25:49 <lambdabot>   No instance for (GHC.Float.RealFloat (Data.Complex.Complex a))
11:25:49 <lambdabot>    arising f...
11:25:59 <Paprikachu> do i really need all the parenthesis?
11:26:18 <Cale> You could just write exp (0 :+ pi)
11:26:25 <Cale> > exp (0 :+ pi)
11:26:26 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
11:26:43 <Paprikachu> lol
11:26:47 <Paprikachu> oh well
11:27:03 <Cale> > exp (0 :+ pi) :: Complex CReal
11:27:04 <lambdabot>   (-1.0) :+ 0.0
11:27:07 <Cale> happy?
11:27:14 <Paprikachu> yes :)
11:27:19 <latro`a> lol
11:27:20 <Paprikachu> what is CRel?
11:27:24 <srhb> <_<
11:27:26 <Paprikachu> CReal
11:27:28 <Cale> Computable real numbers
11:27:32 <Cale> From the numbers package
11:27:39 <Paprikachu> "computable"?
11:27:46 <latro`a> huh...why was I expecting an FFI type
11:27:54 <Cale> Yeah, of course most real numbers aren't expressible using programs
11:27:59 <c_wraith> Paprikachu: you know, the subset of the reals you can actually do stuff with.
11:28:09 <Cale> But this type encodes all the real numbers whose value can be computed effectively.
11:28:19 <Cale> (infinite precision)
11:28:23 <c_wraith> Paprikachu: the non-computable reals are awfully hard to do anything with, other than kind of admire from a distance.
11:28:38 <Paprikachu> how does it even work
11:28:38 <latro`a> > (sqrt 2 :: CReal) ** 2
11:28:39 <lambdabot>   2.0
11:28:46 <latro`a> > (sqrt 2 :: Double) ** 2
11:28:47 <lambdabot>   2.0000000000000004
11:28:50 <latro`a> neat
11:28:58 <Paprikachu> does it save all the operations applied to it?
11:29:36 <Cale> Paprikachu: By representing them as functions from n to rational numbers which are within 1/2^n of the real number being represented, iirc.
11:30:02 <Cale> i.e. as Cauchy sequences with a particularly strong convergence condition
11:30:16 <n-dolio> No, the output is integer.
11:30:20 <Cale> oh, okay
11:30:52 <n-dolio> So, presumably n -> m such that m/2^n <= r <= (m+1)/2^n or something.
11:31:12 <latro`a> eh
11:31:14 <latro`a> isomorphic
11:31:36 <latro`a> faster, though, of course
11:31:52 <Paprikachu> > 1.0/3.0 :: CReal
11:31:53 <lambdabot>   0.3333333333333333333333333333333333333333
11:32:13 <c_wraith> however the input is Int, so it's not *actually* infinite-precision
11:32:18 <Cale> > (1/3 :: CReal) * 3
11:32:19 <lambdabot>   1.0
11:32:32 <Paprikachu> > 1/3
11:32:33 <latro`a> it could just as easily be Integer though, no?
11:32:33 <lambdabot>   0.3333333333333333
11:32:43 <byorgey> > 10000 * (1/10000) == 1
11:32:44 <lambdabot>   True
11:33:41 <byorgey> > sum (replicate 1000 (1/1000)) == 1
11:33:42 <lambdabot>   False
11:33:49 <byorgey> > sum (replicate 1000 (1/1000)) == (1 :: CReal)
11:33:50 <lambdabot>   True
11:33:57 <Paprikachu> o_o
11:34:21 <latro`a> (that doesn't involve a cast, of course, so it's not as wtf as it looks)
11:35:07 <tromp_> > sum [1/3,1/3,1/3] == 1
11:35:10 <lambdabot>   True
11:35:18 <byorgey> there's also  http://hackage.haskell.org/package/cyclotomic  for working with a fun subset of computable complex numbers
11:35:21 <tromp_> > sum [1/5,1/5,1/5.1/5,1/5] == 1
11:35:22 <lambdabot>   False
11:35:26 <latro`a> 1/3 is actually represented accurately in floating point
11:35:34 <latro`a> not exactly, but all the digits are correct
11:35:39 <byorgey> tromp_: sneaky =)
11:35:50 <Paprikachu> > sum $ replicate 17 (1/17) == 1
11:35:51 <lambdabot>   Couldn't match expected type `[a]'
11:35:51 <lambdabot>         against inferred type `GHC.Bool....
11:36:00 <Paprikachu> > (sum $ replicate 17 (1/17)) == 1
11:36:01 <lambdabot>   True
11:36:01 <latro`a> $ absorbs the ==
11:36:16 <roconnor> > 0.999999999999999999999999999999999999999999999 == 1
11:36:17 <lambdabot>   True
11:36:22 <roconnor> > 0.999999999999999999999999999999999999999999999 == (1 :: CReal)
11:36:23 <rosie> srhb: Yes. it's an instance of Show. I think it will help to find the documentation on e.g. BsonFloat, but I can't seem to find it.
11:36:24 <lambdabot>   True
11:36:26 <Paprikachu> > sum (replicate 17 (1/17)) == 1
11:36:27 <lambdabot>   True
11:36:32 <byorgey> roconnor: haha, oh, right =)
11:36:50 <tromp_> > map ((==1).sum.(\n->replicate n (1/n)) [1..]
11:36:51 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:37:16 <tromp_> > map ((==1).sum.(\n->replicate n (1/n))) [1..]
11:37:17 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
11:37:17 <lambdabot>    arising from a use o...
11:38:01 <byorgey> > map ((==1).sum.(\n->replicate n (1/fromIntegral n))) [1..]
11:38:04 <lambdabot>   mueval-core: Time limit exceeded
11:38:43 <Paprikachu> > take 5 $ map ((==1).sum.(\n->replicate n (1/fromIntegral n))) [1..]
11:38:45 <lambdabot>   [True,True,True,True,True]
11:38:50 <Paprikachu> > take 10 $ map ((==1).sum.(\n->replicate n (1/fromIntegral n))) [1..]
11:38:52 <lambdabot>   [True,True,True,True,True,False,False,True,False,False]
11:39:09 <Paprikachu> > take 20 $ map ((==1).sum.(\n->replicate n (1/fromIntegral n))) [1..]
11:39:11 <lambdabot>   [True,True,True,True,True,False,False,True,False,False,False,True,False,Fal...
11:39:25 <tromp_> how come the 5th is True??
11:39:47 <byorgey> hehehe
11:39:52 <byorgey> (14:35) <    tromp_> > sum [1/5,1/5,1/5.1/5,1/5] == 1
11:39:55 <byorgey> look carefully
11:40:17 <rosie> shrb: ah sorry, found it
11:40:32 <byorgey> I thought you did that on purpose =)
11:40:39 <tromp_> oops!
11:40:44 <tromp_> no, i didnt!
11:40:45 <srhb> rosie: Cool :)
11:41:09 <tromp_> but now i understand your sneaky remark:-)
11:41:16 <srhb> rosie: That's the general recipe as well, go to the datatype definition, search for deriving, if it isn't there there must be an instance Show YourType somewhere.
11:41:18 <byorgey> indeed =)
11:41:49 <rosie> srhb: thanks :)
11:42:54 <byorgey> > take 50 . map fst . filter snd . map ((id &&& (==1)).sum.(\n->replicate n (1/fromIntegral n))) $ [1..]
11:42:57 <lambdabot>   mueval-core: Time limit exceeded
11:43:05 <byorgey> > take 30 . map fst . filter snd . map ((id &&& (==1)).sum.(\n->replicate n (1/fromIntegral n))) $ [1..]
11:43:09 <lambdabot>   mueval-core: Time limit exceeded
11:43:12 <latro`a> wat
11:43:13 <byorgey> oh, come on
11:43:35 <byorgey> > take 20 . map fst . filter snd . map ((id &&& (==1)).sum.(\n->replicate n (1/fromIntegral n))) $ [1..]
11:43:37 <tromp_> byorgey: Patience exceeded
11:43:37 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1....
11:43:49 <Paprikachu> what's &&&?
11:43:53 <byorgey> whoops
11:44:01 <latro`a> it's an Arrow function, but for functions it is
11:44:08 <latro`a> (f &&& g) x = (f x,g x)
11:44:26 <Paprikachu> what :|
11:44:45 <byorgey> > take 20 . map fst . filter snd . map ((const n &&& (==1)).sum.(\n->replicate n (1/fromIntegral n))) $ [1..]
11:44:46 <Paprikachu> > (+2) &&& (+4) 5
11:44:48 <lambdabot>   [n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n]
11:44:48 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> (b, c'))
11:44:48 <lambdabot>    arising from a us...
11:44:55 <Paprikachu> > ((+2) &&& (+4)) 5
11:44:56 <byorgey> lol
11:44:56 <lambdabot>   (7,9)
11:45:03 * byorgey admist defeat
11:45:19 * byorgey can't evin spel
11:45:38 <luite> pour byorgey
11:45:53 <tgeeky> correct spelling, different language
11:46:12 <byorgey> oh, I thought luite was advising me to have a beer
11:46:59 <dncr> What's the best way to get generate a lot of Int32's in Haskell and marshal them to a (Ptr Int32)?
11:46:59 <lambdabot> dncr: You have 1 new message. '/msg lambdabot @messages' to read it.
11:47:19 <dncr> This is to generate and play sound w/ portaudio.
11:47:36 <dncr> Should I use vector?
11:47:50 <luite> you can use storable vectors
11:48:49 <dncr> ok http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector-Storable.html
11:50:30 <rosie> Where does "Bin" come from in this documentation? http://hackage.haskell.org/packages/archive/bson/0.0.4/doc/html/src/Data-Bson.html
11:51:11 <byorgey> rosie: it looks like it's one of the constructors of the Value type
11:52:37 <rosie> I see data Value = … Bin Binary … but then, instance Val Binary where val = Bin. I'm not sure what "Bin" is referring to in that last bit of code
11:54:02 <latro`a> Bin is a constructor
11:54:04 <byorgey> rosie: the same thing
11:54:15 <latro`a> and all constructors are functions
11:54:23 <byorgey> rosie: in  val = Bin,   Bin is being used as a function of type  Binary -> Value
12:02:47 <rosie> ah. so I would I sue it like this?  let b = Bin Binary "some byteString". and then when I want to get its value, I use val b to give me…   It looks like it would give me just a data constructor according to " class (Typeable a, Show a, Eq a) => Val a where    val :: a -> Value" How would I get "some byteString"
12:03:01 <rosie> byorgey: CC ^^
12:06:20 <Shapeshifter> Is there a tool I can run on my source code that will detect superfluous braces, unused imports, and other such things?
12:06:44 <hiptobecubic> Shapeshifter, ghc-mod lint i think?
12:06:54 <hiptobecubic> or hlint?
12:06:56 <geekosaur> http://hackage.haskell.org/package/hlint
12:07:28 <Clint> hlint won't do unused imports
12:07:31 <Clint> but ghc -Wall will
12:07:55 <Shapeshifter> thanks!
12:08:57 <aristid> @quote oleg
12:08:57 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
12:10:01 <dncr> how do you stuff a (Data.Vector.Storable.Vector Int32) into a (Ptr Int32)?
12:12:04 <dncr> i see {Foreign.Marhal.Array.withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b}, but I think going thru a List would defeat the efficiency of using a Vector?
12:13:04 <Cale> dncr: Use a Data.Vector.Storable
12:13:14 <Cale> errr
12:13:41 <Cale> lol, is there no Storable instance for Data.Vector.Storable.Vector?
12:13:46 <johnw> Shapeshifter: I use ghc-mod, so Emacs highlights stupid lines in blue
12:14:02 <dncr> there is i just don't know how to store i guess?
12:14:26 <Clint> what are you actually trying to do?
12:15:10 <dncr> @hoogle pokeVector :: Ptr a -> Vector a -> IO ()
12:15:11 <lambdabot> Warning: Unknown type Vector
12:15:11 <lambdabot> No results found
12:15:32 <Cale> dncr: If there's a Storable instance, you can just malloc and poke.
12:16:23 <Cale> However, that *does* seem suspicious, as they'll obviously be variable-sized
12:18:15 <Cale> Data.Array.Storable provides  withStorableArray :: StorableArray i e -> (Ptr e -> IO a) -> IO a
12:18:29 <Cale> You want an analogue to that, I think.
12:18:52 <dncr> Isn't it weird that Data.Vector.Storable has no withStorableVector?
12:19:47 <Cale> At least slightly weird
12:19:53 <dncr> ok
12:20:02 <Cale> It *does* allow you to work with things obtained via FFI
12:20:12 <Cale> But you can't get a pointer to the whole structure.
12:20:57 <Cale> oh, there are some unsafe* functions at the bottom of the file
12:21:03 <Cale> http://hackage.haskell.org/packages/archive/vector/0.9.1/doc/html/Data-Vector-Storable.html
12:21:11 <HugoDaniel> hi
12:21:44 * dncr tries unsafeWith
12:31:14 * Shapeshifter is quite pleased with his first creation/abomination written in haskell http://login.icu.uzh.ch/~archer/fallout3hs.png
12:31:30 <johnw> haha
12:33:57 <johnw> has anyone here used both Shelly and HsShellScript?
12:34:00 <ReinH> Shapeshifter: :)
12:35:21 <jfischoff> johnw: if you find anything about HsShellScript can you let me know?
12:35:40 <johnw> sure
12:35:52 <jfischoff> I'll do the same
12:36:07 <johnw> one difference i see so far is that Shelly uses Text everywhere, but HsShellScript more traditionally uses String
12:36:42 <jfischoff> HsShellScript seems simpler
12:37:09 <jfischoff> on first blush I am partial to it, but I don't know if it works
12:37:19 <johnw> it's library is quite a bit more extensive too
12:37:46 <johnw> though I'm not user I would use its GetArgs facility over Cmdargs
12:37:56 <johnw> s/user/sure
12:38:08 * jfischoff nods
12:38:23 <johnw> i sent Greg an e-mail asking for more details on how it compares
12:38:39 <jfischoff> I heard bad things about shelly, but nothing specific...
12:38:46 <johnw> really?
12:39:11 <hiptobecubic> What I heard about shelly was that it was not worth the trouble
12:39:24 <jfischoff> one person I was talking to was very down on it after using it, but he didn't really articulate what the issue was
12:39:35 <jfischoff> just that it was horrible
12:39:46 <johnw> well, that's at least one data point
12:39:55 <johnw> i've only used shelly for something so trivial I could have not used it
12:40:02 * jfischoff nods
12:40:30 <jfischoff> I'm looking for shell scripting to go with shake
12:40:53 <johnw> ah yes
12:40:57 <jfischoff> the one thing that worries me is shelly is monadic and so is shake
12:41:00 <johnw> shake looks interesting too
12:41:21 <johnw> well, hsshellscript is all in IO too
12:41:22 <jfischoff> yeah I hope to replace my rake file at work with it ….one day
12:41:24 <jfischoff> sure
12:41:28 <johnw> Sh is just a wrapper so he can manage exception state I think
12:41:33 <jfischoff> ah
12:41:39 <johnw> Shelly's error reporting is rather nice I find
12:41:51 <jfischoff> shake has liftIO for IO
12:41:53 <jfischoff> I think
12:42:04 <jfischoff> ah
12:42:51 <luite> johnw: Shelly uses system-filepath, not Text, although it can be converted to Text
12:43:05 <johnw> well, I mean it uses Text everywhere else
12:43:07 <hpaste> “Carlos López-Camey” pasted “Rewrite flip” at http://hpaste.org/73908
12:43:12 <johnw> so dealing with FilePaths gets to be a real pain actually
12:43:18 <johnw> you have to fromText and toText all over the place
12:43:22 <jfischoff> luite: have you used shelly much?
12:43:59 <kmels> hi, the code in http://hpaste.org/73908 compiles, I would like to know how to rewrite the flip in the line 4 without the parenthesis?
12:44:04 <johnw> what's great about shelly for me so far is that when a command fails, it tells me, captures the output into a log file, and then stops the program (if I don't catch it)
12:44:19 <luite> johnw: yeah but it's better than having FilePath = String or FilePath = Text
12:44:28 <geekosaur> FilePaths vs. Text is difficult anyway; on Windows the paths are Unicode, on Unix they're raw ByteStrings (talking how the native format naturally maps into Haskell, not how base actually represents them...)
12:44:30 <luite> jfischoff: a few times
12:45:00 <jfischoff> the error reporting sounds cool
12:45:05 <luite> haven't used hsshellscript, it's only been on hackage since a few months
12:46:35 <johnw> ah
12:46:44 <johnw> wow, the author sure did wait a while before uploading it
12:48:30 <byorgey> rosie: no, you would use it like   let b = Bin "some bytestring"
12:48:40 <byorgey> rosie: and you could get the bytestring out again by pattern matching
12:48:57 <byorgey> foo (Bin bs) = ... bs ...   and then call   foo b
12:50:03 <_Vi> What attitude does the Haskell community have towards Scala? Do you think Scala is good choice to do programming (including FP) when we need to program something for JVM?
12:50:30 <johnw> it's strange when some cabal installs fail due to a missing pakcage
12:50:35 <Cale> _Vi: Scala seems like one of the more tolerable languages on the JVM to me.
12:50:35 <johnw> I mean, why doesn't cabal just install the package?
12:50:47 <rosie> byorgey: I see, thanks! What's the purpose of the "val" function, then?
12:50:50 <johnw> (hsshellscript needing c2hs is the case in point at the moment)
12:51:09 <Cale> _Vi: edwardk might have more to say about it :)
12:51:13 <lightquake> johnw: it doesn't install executables on your system
12:51:17 <lightquake> c2hs is an executable
12:51:21 <johnw> ah
12:51:26 <johnw> well, that makes sense at least
12:52:34 <jfischoff> Cale: Groovy hasn't grown on you ;)
12:52:38 <Cale> jfischoff: lol
12:52:51 <Cale> Groovy is fucking terrible
12:52:52 <_Vi> Cale, Should Haskell experience help programming Scala in idiomatic way?
12:53:15 <jamiltron> Cale: word
12:53:24 <Cale> _Vi: From what I've heard from Scala programmers, most of them think in Haskell anyway
12:53:42 <_Vi> Note: going to ask a similar question on #scala
12:53:54 <lightquake> didn't Groovy's author disown it
12:53:59 <johnw> oh bummer, hsshellscript won't install at all
12:54:12 <johnw> it wants mntent.h
12:54:18 <johnw> so I'm guessing this is a Linux-centric package
12:54:22 <jamiltron> lightquake: Kind of, if I recall he said if he knew about Scala he wouldn't have made Groovy
12:54:32 <lightquake> yeah
12:54:54 <edwardk> Cale: on what?
12:55:01 <edwardk> oh scala
12:55:49 <edwardk> its the best replacement for java at this time. it has lots of features. some of those features even work together
12:56:05 <Cale> I've been considering making an attempt to mod minecraft in Scala, lol.
12:56:53 <edwardk> Cale: one of my coworker josh_cough has a scala library for manipulating minecraft
12:56:56 <ousado> edwardk: what makes frege worse?
12:57:42 <edwardk> frege isn't java and doesn't evaluate in a manner that a java developer new to fp would even remotely expect.
12:58:02 <edwardk> we have our own non-strict pure functional programming language that we wrote that runs on the jvm
12:58:11 <edwardk> but we also do a lot of scala development
12:58:34 <Cale> edwardk: The tricky bit is that the .class files in minecraft.jar are obfuscated in a ridiculous way. There are community-developed tools (MCP in particular) to obfuscate and deobfuscate, but I'm not sure how well they'll deal with non-Java stuff.
12:59:19 <ousado> edwardk: oh I see.. - that's a consideration beyond the language
12:59:38 <Cale> (I don't know whether the (de)obfuscation is done before or after (de)compilation)
13:00:00 <edwardk> anyways, we wrote ermine for many of the same reasons that i presume the other guys wrote frege
13:01:01 <edwardk> sent up the josh signal. maybe i can get him to join the channel for a bit
13:01:18 <sheldonh> i know i'm biting off too much too soon, but i'd love to know why i'm getting this "Couldn't match expected type" error, when i'm convinced i've gotten the typing right: http://fpaste.org/zRox/ (error message at the botom). maybe i don't understand how let works?
13:02:21 <Cale> sheldonh: Well, your type signature for consumeArray says that the first element of the resulting pair should be a JsonValue
13:02:21 <hiptobecubic> I hate that json parser example with all my heart.
13:02:41 <Cale> sheldonh: However, you have put a list there, as evidenced by the fact that you're using (:)
13:02:54 <johnw> your return type is (JsonValue,[])
13:02:56 <danr> hiptobecubic: is it from some tutorial?
13:02:59 <johnw> but you're making a ([],[])
13:03:00 <sheldonh> hiptobecubic: sorry. i just wanted to see how far i could get without reading the solution in the book
13:03:02 <Cale> sheldonh: Perhaps you wanted  JsonArray (...) ?
13:03:03 <hiptobecubic> danr, RWH
13:03:06 <danr> oh
13:03:30 <latro`a> sheldonh, is it possible you just have fst and snd backwards here?
13:03:42 <hiptobecubic> sheldonh, not your fault. it's from the book. I just felt like it was unwieldy and super contrived
13:03:49 <sheldonh> Cale: ahhhhhhhh. damnit! okay thanks. so the error really means exactly what you said
13:04:05 <latro`a> oh nvm, can't be that either
13:04:10 <sheldonh> Cale: *what _it_ said*
13:04:14 <Cale> yes
13:04:15 <danr> hiptobecubic: but json is actually quite realistic :)
13:04:20 <Cale> (they usually do, even!)
13:04:42 <hiptobecubic> danr, yes. But why would you make a parser like this?
13:04:47 <sheldonh> Cale: but it wasn't complaining that (fst c) is an array. it was complaining that JsonValue : (fst c) is an array
13:04:55 <Cale> Is a list
13:05:01 <Cale> array /= list
13:05:47 <Cale> (even if JsonArray has a list parameter rather than an array :P)
13:06:18 <sheldonh> Cale: sorry, list. it was complaining that JsonValue : (fst c) is a list
13:06:29 <Cale> right
13:07:02 <sheldonh> Cale: i should have trusted that the topmost "In the expression" referred to the value of offending type
13:07:54 <sheldonh> Cale: thanks. i will be very glad when error messages feel natural to me :)
13:09:15 <dncr> if my_lib.o is in the current directory w/ Main.hs that calls out to it, how do i build?  i thought: ghc -L. -lmy_lib --make Main
13:09:32 <dncr> but i get "ld: cannot find -lmy_lib"
13:10:57 <sheldonh> hiptobecubic: a json parser appealed to me because i know json well, and i couldn't (and now see still can't) begin to imagine how i'd pull one off :)
13:10:59 <Cale> sheldonh: Yeah, it takes some care to read them at first. At least you have a line number to stare at :)
13:11:33 <sheldonh> Cale: if only it were always the one that required an edit ;)
13:11:45 <ReinH> sheldonh: there was a ruby quiz on JSON parsing so there's probably a haskell solution or three
13:12:21 <sheldonh> ReinH: aloha, ltns.  think i'm being too ambitious trying to figure it out for myself in week 1?
13:12:23 <Cale> This approach to parsing isn't really the best one, but it can probably be made to work.
13:12:36 <hiptobecubic> sheldonh, but that's the point. This *isn't* how you'd pull one off. There are great libraries for writing parsers. When I struggled though that example and then came to ask about it, everyone just said "why are you doing this?"
13:13:15 <atriq> Is it possible to pattern-match in let expressions?
13:13:19 <ReinH> http://www.downforeveryoneorjustme.com/haskell.org
13:13:19 <ReinH> :(
13:13:20 <hiptobecubic> I was kind of disappointed that RWH didn't take this opportunity to use a real-world® library to do something in the real-world®
13:13:25 <atriq> Or will I need a guard?
13:13:30 <ReinH> hiptobecubic: :p
13:13:36 <atriq> Or a casey thing
13:13:39 <Cale> hiptobecubic: I think there can be some value in writing it in a naive way so that you can fully appreciate what parser combinators buy you :)
13:13:42 <johnw> haskell.org has been very slow for me today
13:13:44 <johnw> but not absent
13:13:45 <sheldonh> there are libraries for writing parsers... no, no, get thee hence! :)
13:13:46 <ReinH> hiptobecubic: it's a pedagogical choice
13:13:47 <Clint> atriq: yes
13:14:00 <johnw> ah, pedagogy
13:14:02 <Cale> sheldonh: Even better: write your own library for writing parsers :)
13:14:07 <ReinH> you know, for teaching people things
13:14:10 <johnw> one of those words that no matter how well you know it, it still looks like something you can't pronounce
13:14:20 <hiptobecubic> Cale, is that the point of that book though?
13:14:22 * sheldonh cries to his mummy.
13:14:26 <atriq> This is going to make this ridiculous program EVEN MORE RIDICULOUS
13:14:41 <ReinH> so haskell.org is down, yes?
13:14:53 <ReinH> ok sort of
13:14:54 <sheldonh> ReinH: it's been spotty for me since sunday
13:14:55 <johnw> haskell.org has been having difficulties all week
13:15:05 <ReinH> no json parser in haskell quiz
13:15:11 <Cale> atriq: there are pattern bindings, but if you do that, you can only match against one pattern, so you'd better know which one is going to match
13:15:24 <atriq> Yeah, that's what I meant
13:15:29 <Cale> atriq: If you don't, then you want case
13:15:34 <Cale> (rather than let)
13:15:37 <atriq> :(
13:15:40 <mizu_no_oto> edwardk: if you just needed to interop with java but wanted to write pure functional code, is frege better than scala?
13:15:56 <Cale> atriq: It's not so bad is it?
13:16:06 <atriq> This function's 32 lines already
13:16:10 <Cale> atriq: you may also appreciate pattern guards
13:16:40 <Cale> of course, haskell.org is down
13:16:41 <Cale> lol
13:17:32 <Cale> atriq: But pattern guards let you write things like    foo x | Just y <- bar x, y < 10  = ...
13:17:59 <sheldonh> isn't scala the hybrid that lets you learn no functional thinking if you so choose?
13:18:12 <Cale> atriq: Maybe you should hpaste the code so we can have a look at it
13:18:14 <Cale> @paste
13:18:14 <lambdabot> Haskell pastebin: http://hpaste.org/
13:18:16 <hiptobecubic> sheldonh, it's one of them.
13:18:22 <hpaste> Shapeshifter pasted “scatter” at http://hpaste.org/73910
13:18:26 <Shapeshifter> Does someone have an idea how to write this as a fold or some other short way? It's like a zip, but the longer list doesn't get discarded and is instead concatenated to the end.
13:18:54 <Shapeshifter> ehm and in this case the longer one is the left one.
13:19:26 <hiptobecubic> @src zip
13:19:26 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
13:19:26 <lambdabot> zip _      _      = []
13:20:51 <Cale> Shapeshifter: I'd write:  [] /\/ ys = ys; (x:xs) /\/ ys = x : (ys /\/ xs), and then scatter xs ys = concat (xs /\/ ys)
13:20:54 <johnw> grr..  shelly depends on a different version of mtl than everything else
13:21:08 <johnw> so now cabal wants to rebuild shelly with everyone else's version of mtl, and it fails
13:21:18 <johnw> so I can cabal build my utility, but I can't cabal install it
13:21:25 <johnw> that makes very little sense
13:21:50 <Cale> and then... maybe we can write that first thing as a foldr...
13:21:55 <Shapeshifter> Cale: what's the /\/ ?
13:22:02 <Cale> the operation I'm defining
13:22:10 <Cale> which interleaves the elements of two lists
13:22:33 <edwardk> mizu_no_oto: honestly i don't know.
13:22:37 <sheldonh> does gh have a documentation browser like ruby's ri or perl's... whatever it was?
13:22:40 <hiptobecubic> do you want foldr though? i imagine these can be infinite lists?
13:22:51 <Cale> foldr can deal with infinite lists
13:22:55 <mizu_no_oto> edwardk: fair enough
13:23:03 <edwardk> i know the shape of what i can get away with in scala. it has some jagged edges, but i know i can do everything i need to do
13:23:12 <edwardk> in frege i don't know what i can't say
13:23:14 <Cale> But actually, foldr isn't quite right for this.
13:23:14 * sheldonh boggles at the thought of starting on the RIGHT of an infinite list
13:23:41 <Cale> sheldonh: foldr doesn't start at the right
13:23:50 <hiptobecubic> sheldonh, you don't start at the right, you associate to the right
13:23:51 <Cale> foldr f z [] = z
13:24:01 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
13:24:09 <atriq> Cale, the code should probably be split into about a dozen functions
13:24:14 <atriq> But I like it like this
13:24:18 <Cale> In the case of a nonempty list, foldr f z immediately passes control to f
13:24:33 <sheldonh> Cale: that... explains a lot. argh!!!!! :)
13:24:37 <edwardk> sheldonh: foldr starts from the left if you look at that code. =)
13:25:04 <mizu_no_oto> sheldonh: And foldl starts from the right
13:25:11 <sheldonh> the real world haskell book seriously isn't working for me
13:25:30 <edwardk> its foldl that requires you to jump over an infinite numberof ()'s to get to where you can start working on an infinite list.
13:25:57 <sheldonh> i found the foldl/foldr/foldl' section pretty opaque, except for the bit that said "oh, btw, foldr is incredibly important to understand" :)
13:26:08 <mizu_no_oto> sheldonh: Have you read Learn You A Haskell?
13:26:17 <Cale> sheldonh: http://cale.yi.org/share/Folds.svg
13:26:26 <Cale> sheldonh: Perhaps those pictures will help
13:26:50 <sheldonh> mizu_no_oto: i'm going to give up and switch to Learn You. i think Real World is pitched at smarter okes than me
13:27:17 <Cale> sheldonh: Looking at those, it should be immediately obvious why foldr is the real one :)
13:28:02 <mizu_no_oto> sheldonh: I think LYAH -> RWH is a decent progression
13:28:41 <jamiltron> Even doing them both kind of swapping back and forth is pretty good. I wish LYAH had exercises relevant to each section.
13:28:56 <sheldonh> Cale: in the foldr picture, the little lines that run between numbers and the function indicate the number as input to the function, right?
13:29:08 <ReinH> > foldr f 1 [1..5]
13:29:09 <lambdabot>   Ambiguous occurrence `f'
13:29:10 <lambdabot>  It could refer to either `L.f', defined at <local...
13:29:27 <sheldonh> jamiltron: you ain't missin' much... Real World's exercise regimen is terrible :)
13:29:29 <atriq> Actually, that isn't that hard to convert
13:29:31 <ReinH> how does Debug.SimpleReflect work again
13:30:03 <jamiltron> sheldonh: I thought certain exercises here and there were good. Maybe like a fourth of them.
13:30:07 <ReinH> oh yeah
13:30:18 <ReinH> > foldr f x [1..5]
13:30:19 <lambdabot>   Ambiguous occurrence `f'
13:30:19 <lambdabot>  It could refer to either `L.f', defined at <local...
13:30:23 <ReinH> never mind :(
13:30:24 <sheldonh> jamiltron: agreed :)
13:30:39 <Cale> sheldonh: that's right
13:31:00 <sheldonh> Cale: then this SVG is awesome. thank you :)
13:31:02 <Cale> sheldonh: the lines go from the bottom of the functions to the tops of their parameters
13:31:05 <ReinH> > foldr f x [1..5] :: Expr
13:31:06 <lambdabot>   Ambiguous occurrence `f'
13:31:06 <lambdabot>  It could refer to either `L.f', defined at <local...
13:31:07 <jamiltron> sheldonh: I wish that somewhere right before Applicative Functors in LYAH it's like "Go do the first half of 20 intermediate haskell problems"
13:31:11 <ReinH> oh. duh
13:31:20 <Cale> or, I guess I should say the tops of their arguments
13:31:24 <ReinH> > foldr a 0 [1..5]
13:31:25 <lambdabot>   Couldn't match expected type `a -> b -> b'
13:31:25 <lambdabot>         against inferred type `S...
13:31:30 <ReinH> sorry for spamming
13:31:34 <ReinH> I'll just install lambdabot
13:31:51 <jamiltron> sheldonh: Cause those are good problems to solve, but they kind of show you how to in LYAH in the corresponding sections. I think those would be good prequel exercises.
13:32:00 <Saizan> ReinH: you can query it
13:32:57 <sheldonh> jamiltron: in my case, i got lucky. some guy on irc suggested that, right before Applicative Functors, i go do the first half of 20 intermediate haskell problems :)
13:33:48 * hackagebot svndump 0.3.0 - Library for reading Subversion dump files  http://hackage.haskell.org/package/svndump-0.3.0 (JohnWiegley)
13:36:03 <bobajett> what is "20 intermediate haskell problems"? because I haven't gotten to Application Functors in LYAH yet :)
13:38:13 <gabriel`> question: I'm trying to get hoogle accessible offline and followed the instructions here: https://github.com/ndmitchell/hoogle/blob/master/docs/Local-Install.md
13:38:19 <gabriel`> specifically:
13:38:25 <sheldonh> bobajett: this, i think: http://blog.tmorris.net/20-intermediate-haskell-exercises/
13:38:26 <gabriel`> cabal install hoogle
13:38:30 <srhb> bobajett: To completely them you pretty much need all of LYAH and then some
13:38:48 <gabriel`> and echo >> ~/.ghci ':def hoogle \x -> return $ ":!hoogle \"" ++ x ++ "\""'
13:39:15 <gabriel`> but the shell doesn't recognize the command 'hoogle'
13:39:56 <bobajett> heh, ok I'll stick with LYAH first then.
13:39:56 <gabriel`> after ostensibly successfully installing everything
13:40:10 <bobajett> question: how do i zipWith (+) [1,3] [1] but instead of getting [3] get [2,3]?
13:40:16 <hiptobecubic> @src negate
13:40:16 <lambdabot> negate x = 0 - x
13:40:56 <srhb> bobajett: Also they are "applicative" functors. :)
13:41:20 <bobajett> or in other words, I'd like to add two lists but not get them truncated to the size of the smaller list
13:42:04 <srhb> bobajett: you could pad one list.
13:42:31 <danr> I wouldn't recommend those exercises on Tony's blog... It's just confusing that things have arbitrary names. I would rather go for reimplementing all the functions in Control.Monad
13:42:58 <danr> oh. I guess State actually have its correct name.
13:43:19 <fmap> gabriel`: you probably don't have hoogle in PATH
13:43:40 <jamiltron> danr: I think the confusing names are a benefit.
13:44:00 <bobajett> srhb: ah makes sense, i'll try that out
13:44:18 <statusfailed> gabriel`: to add to what fmap said, you probably want /home/<you>/.cabal/bin/ in your path
13:44:26 <statusfailed> at least, that's what I have
13:44:42 <srhb> bobajett: It's by no means the best solution, but I figure if you're doing LYAH now it might be up your alley. You could also consider what you could concatenate with the result of the zipping. :-)
13:46:51 <bobajett> srhb: yep sounds good, I should try out my level of solutions first :)
13:47:03 <gabriel`> alright, I'll check that - thanks
13:47:29 <lpvb> > zipWith (+) [1,3] [1..]
13:47:30 <lambdabot>   [2,5]
13:50:12 <johnw> it's strange that my attoparsec parser allocates 845,628,591,424 on the heap, yeah?
13:50:39 <c_wraith> not necessarily.
13:50:49 <johnw> But 845 Gb??
13:50:58 <lpvb> oh now I know what bobajett wanted
13:51:10 <c_wraith> not *that* surprising, depending on how much data you were parsing.
13:51:13 <lpvb> > zipWith (+) [1,3] (1:repeat 0)
13:51:14 <lambdabot>   [2,3]
13:51:19 <rosie> Why is type inference expecting the type of b to be a Char?  in:  a ++ b
13:51:19 <johnw> 11G of data
13:51:27 <rosie> :t (++)
13:51:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
13:51:34 <shachaf> rosie: Are you sure about that?
13:51:44 <c_wraith> rosie: don't trust lambdabot
13:51:45 <shachaf> rosie: The normal Prelude (++) works on lists only.
13:52:05 <shachaf> It may be expecting b to be [Char], though.
13:52:08 <c_wraith> :t (Prelude.++)
13:52:09 <lambdabot> forall a. [a] -> [a] -> [a]
13:52:37 <rosie> shachaf: here's the error: No instance for (HsonVal Char) where the HsonVal instance is inferred from the context   a ++ b
13:53:02 <shachaf> I'm not sure that's enough context to say much. :-)
13:53:30 <rosie> shachaf: er, do you have an idea as to why it's not inferring HsonVal [Char] ?
13:53:57 <shachaf> I don't even know what HsonVal is, or what the types of a and b are, or what the context of that code is.
13:54:32 <c_wraith> johnw: I'm going with expansion by a factor of 80 being unsurprising.  Remember that it's counting allocation of *everything*
13:54:46 <shachaf> I don't see any relevant results on Google for HsonVal.
13:56:25 <johnw> c_wraith: i spell that e.g.r.e.g.i.o.u.s.
13:57:03 <shachaf> Haskell programs tend to do a lot of allocation.
13:57:07 <Sgeo> @hoogle zipWith
13:57:07 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
13:57:08 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
13:57:08 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
13:57:29 <johnw> but 865g?  I could barely fit that on my internal hard drive, if it were written out
13:57:48 <shachaf> johnw: It's not all being allocated at once, of course.
13:57:52 <johnw> i wonder if all that allocation is just a matter of moving a stack point,r though
13:57:59 <johnw> the memory is "allocated"
13:58:07 <shachaf> Not stack, but yes, allocation is pretty much just incrementing a pointer.
13:58:10 <johnw> but isn't causing structure in a red-black heap store to be moved around
13:59:25 <rosie> shachaf: oh boy, you're right. ignore HsonVal. it's like BsonVal. It's just a class "class (Typeable a, Show a) => BsonVal a where" that derives many classes, like  "instance BsonVal String where". hmm, what's the wording you use for a, ah, parameterized instance? It should cast to whatever instance is inferred.
13:59:42 <byorgey> rosie: did someone else answer your question about 'val'?
13:59:42 <johnw> the problem with a number that big, though, is that I just have to ignore it as meaningless information
13:59:43 <shachaf> rosie: It's your own class?
13:59:53 <rosie> shachaf: yep
13:59:58 <rosie> shachaf: i'm just using it
14:00:11 <johnw> once you start saying "Giant numbers are fine", then 800 Gb and 2 Tb aren't that far apart
14:00:31 <rosie> shachaf: er, I mean to say it's a library my friend made, so I don't know all about it, but it's not on Google..
14:00:46 <shachaf> rosie: Ah.
14:01:06 <rosie> It corresponds closely to Data.Bson, though
14:02:02 <shachaf> I'm not sure what your question is anymore, if there still is one. :-)
14:04:40 <johnw> i have attoparsec and my whole world compiled with profiling now, but when i build with -prof -fauto-prof and run with +RTS -p, the profiling output just says 100% in main, with zeroes everywhere else.  Am I missing something?
14:05:09 <rosie> schachaf: Ha, I have a function that returns an HsonValue. Based on the context, it should give me an HsonValue that is an instance of a HsonVal Float or HsonVal String, etc. So I expect that in the contexct of list concatenation using strings and ++, it would infer the type of HsonValue String, but instead it seems to interpret HsonValue Char. Why is that?
14:06:34 <Paprikachu> if i define an operator, will it bind stronger than all other operators or weaker?
14:06:47 <hpc> it will bind as strong as you tell it to
14:06:49 <shachaf> rosie: Maybe you should @paste some code.
14:06:54 <merijn> Paprikachu: It's configurable
14:06:57 <hpc> between precedence 0 and 9
14:07:06 <shachaf> Just edit operators.ini
14:07:07 <Paprikachu> cool, how does that look like?
14:07:12 <geekosaur> heh
14:07:20 <hpc> syntax is generally 10 or more
14:07:42 <Paprikachu> is there a syntax construct to set the priority?
14:07:55 <shachaf> infixl and infixr (and infix)
14:07:56 <hpc> @hoogle infix
14:07:56 <lambdabot> Data.Data Infix :: Fixity
14:07:56 <lambdabot> Language.Haskell.TH.Syntax Infix :: NameIs
14:07:57 <lambdabot> Text.ParserCombinators.Parsec.Expr Infix :: (GenParser tok st (a -> a -> a)) -> Assoc -> Operator tok st a
14:08:11 <shachaf> Not those things. Hoogle won't find syntax
14:08:17 <merijn> Paprikachu: Looks something like "infixl 4 +"
14:08:31 <merijn> Paprikachu: Which says + is left associative with precedence 4
14:08:37 <Paprikachu> ok
14:08:55 <merijn> function application has precedence 10, operators can have anything between 0 and 9
14:11:25 <statusfailed> Those intermediate haskell exercises look cool
14:13:55 <Cale> johnw: Isn't is -fprof-auto?
14:14:32 <Cale> (I would check the GHC documentation, but lol...)
14:14:36 <Tordek> I wrote https://gist.github.com/3509609 to parse thetstrings, but it's clearly shitty since it reparses the length every time. So I tried this to make it pass the size to the subparsers, but it says size is not in scope... help? : http://pastebin.com/02SUHhSk
14:14:39 <mauke> The paste 02SUHhSk has been copied to http://hpaste.org/73913
14:15:56 <alex404> alex404
14:16:23 <Tordek> statusfailed: what exercises?
14:16:33 <statusfailed> http://blog.tmorris.net/20-intermediate-haskell-exercises/
14:16:37 <statusfailed> Tordek: ^ those ones
14:16:42 <Tordek> ossum, thanks
14:18:18 <alex404> Those are pretty cool
14:19:13 <Paprikachu> :t infixl
14:19:14 <lambdabot> parse error on input `infixl'
14:19:38 <statusfailed> isn't that a keywordy-not-function thing?
14:19:47 <statusfailed> i.e. a keyword
14:20:01 <shachaf> It's a keyword.
14:21:35 <atriq> Can I mix >> and Data.Sequence.|>?
14:21:39 <hpaste> dancor pasted “portaudio basic test seg. faults” at http://hpaste.org/73914
14:21:58 <atriq> Like put 0 >> fs' |> f |> f
14:22:16 <dncr> ^^^ if anyone can shed any light on a "freeHaskellFunctionPtr" seg. fault in my 38 lines of code
14:22:36 <johnw> Cale: indeed, I did this (checking my shell history): ghc --make -O -prof -fprof-auto -rtsopts test-raw-any.hs
14:22:43 <atriq> Wait
14:22:47 <atriq> I want that in a return anyway
14:22:47 <johnw> and then: ./test-raw-any ~/Mirrors/Boost/boost.svnrepo.dump +RTS -p -hr
14:22:52 <edwardk> mm_freak: thinking about time reversibility, frp and leapfrog integration again
14:28:44 <dncr> a-ha, found this: https://github.com/sw17ch/portaudio/blob/master/examples/Example1.hs
14:37:27 <Tordek> I wrote https://gist.github.com/3509609 to parse thetstrings, but it's clearly shitty since it reparses the length every time. So I tried this to make it pass the size to the subparsers, but it says size is not in scope... help? : http://pastebin.com/02SUHhSk
14:37:27 <mauke> The paste 02SUHhSk has been copied to http://hpaste.org/73913
14:38:52 <shachaf> Tordek: That's being parsed as (do { size <- ...; ... } <|> try $ parseBool' size)
14:40:35 <armlesshobo> > 3 / 4
14:40:36 <lambdabot>   0.75
14:42:09 <Earnestly> !war4
14:42:19 <johnw> > (3 :: Int) / (4 :: Int)
14:42:20 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
14:42:20 <lambdabot>    arising from a use o...
14:42:31 <armlesshobo> johnw: :(
14:42:43 <armlesshobo> johnw: (/) expects a Fractional for the denominator
14:42:48 <armlesshobo> and I only have an int :(
14:42:50 <johnw> armlesshobo: I was sort of guessing that's what you really wanted
14:42:59 <armlesshobo> johnw: yes :P ty
14:43:02 <shachaf> armlesshobo: What do you want the result of 3/4 to be?
14:43:34 <armlesshobo> shachaf: it's not so much what I want 3/4 to be, it's that (/) expects a Fractional
14:43:38 <armlesshobo> for the second argument
14:43:39 <johnw> :t div
14:43:40 <lambdabot> forall a. (Integral a) => a -> a -> a
14:43:46 <shachaf> armlesshobo: No, it's what you want it to be.
14:43:46 <johnw> > div 3 4
14:43:47 <lambdabot>   0
14:43:55 <armlesshobo> johnw: i need to find the mean of the values in a list
14:43:55 <shachaf> armlesshobo: What value do you want? What type do you want it to have?
14:44:00 <johnw> > 3 `div` 4
14:44:01 <lambdabot>   0
14:44:01 <armlesshobo> shachaf: Double
14:44:09 <johnw> > 4 `div` 3
14:44:09 <shachaf> :-(
14:44:10 <lambdabot>   1
14:44:15 <shachaf> (/) :: Double -> Double -> Double
14:44:18 <Tordek> shachaf: hmm, is there a les parenthesised option for this? ((try $ parseNull' size) <|> (try $ parseBool' size))
14:44:22 <armlesshobo> shachaf: (i misread your question, sorry. :) )
14:44:24 <Tordek> *less
14:44:24 <shachaf> fromIntegral :: Int -> Double
14:44:27 <johnw> You'll find `div` is what you're used to from dummer languages, when dividing integers
14:44:33 <johnw> haha, dummer
14:44:37 <johnw> dumBer
14:44:39 <shachaf> Tordek: Indent it more and use less $
14:44:44 <armlesshobo> johnw: i need to find the average of a list of numbers
14:45:01 <armlesshobo> 1 / 2 != 0
14:45:02 <atriq> Well, mconcat is the function I want
14:45:06 <atriq> For the first time ever
14:45:10 <johnw> try <$> (parseNull' size <|> parseBool' size)
14:45:22 <johnw> or just drop the <$> even
14:45:25 <shachaf> armlesshobo: Did you see what I said above?
14:45:33 <shachaf> Those should be all the functions you need.
14:45:42 <monochrom> > 1/2 /= 0
14:45:43 <lambdabot>   True
14:45:45 <monochrom> works
14:45:47 <armlesshobo> shachaf: fromIntegral :: (Integral a, Num b) => a -> b
14:45:54 <shachaf> fromIntegral :: Int -> Double
14:46:02 <armlesshobo> that's what it shows in my ghci
14:46:06 <armlesshobo> when i do :t
14:46:12 <shachaf> Ignore ghci. fromIntegral :: Int -> Double
14:46:18 <monochrom> Int->Double is clearly a special case of  (Integral a, Num b) => a -> b
14:46:30 <Tordek> johnw: where's <$> defined?
14:46:33 <armlesshobo> monochrom: ohhhh.
14:46:39 <johnw> Tordek: Control.Applicative
14:46:49 <johnw> if you haven't found out about <$> yet, you'll love it once you get to know it
14:46:53 <Tordek> thansk
14:46:58 <Tordek> *thanks
14:46:58 <johnw> it's fmap, it's another guise
14:47:01 <johnw> s/it's/in
14:47:09 <armlesshobo> so I would do something like \x -> sumLst x / fromIntegral ( lstSize x )?
14:47:19 <monochrom> yes
14:47:31 <johnw> Cale: so, I configure via cabal with cabal configure --enable-library-profiling --enable-executable-profiling --enable-tests --ghc-option=-auto-all, rebuilt my library, then did ghc --make -prof -auto-all -caf-all -fforce-recomp -rtsopts foo.hs; and still I get useless results (all costs assigned to main)
14:47:47 <Cale> johnw: What? div is the one with nice semantics
14:47:49 <johnw> :t on
14:47:50 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
14:47:55 <Cale> johnw: quot is the dumb one
14:48:25 <shachaf> Cale: (/) :: Rational -> Rational -> Rational is much nicer than div.
14:48:49 <Cale> Well, that depends on what you're attempting to do, it's a completely different operation.
14:48:57 <Cale> I actually had to go to the trouble of hand implementing div and mod in groovy, lol.
14:49:01 <shachaf> Yep.
14:50:40 <Cale> johnw: Which version of GHC?
14:50:44 <johnw> 7.4.2
14:50:55 <johnw> just rebuilt my whole world of library-profiling enabled last night, as you suggested
14:51:00 <Cale> do -auto-all and -caf-all even work still?
14:51:01 <johnw> s/of/with
14:51:13 <johnw> well, I do get CAF:main in my output now
14:51:20 <Cale> huh, okay
14:51:25 <Cale> I guess they do
14:51:31 <Cale> fsvo work
14:53:14 <armlesshobo> monochrom: that doesn't work :(
14:53:22 <armlesshobo> i must be doing something else wrong, then
14:53:48 <Ippo> hi everyone
14:54:48 <Tordek> johnw: :/ it gives me a type mismatch
14:55:05 <johnw> Tordek: I don't think <$> is right there
14:55:13 <johnw> try takes a parser, not the result from a parser
14:55:17 <johnw> just drop the <$>
14:55:30 <Tordek> ah
14:55:38 <johnw> Cale: fixed!
14:55:56 <Tordek> yeah, but that won't work as intended (i mean, yeah, in this case it will)
14:57:19 <hpaste> johnw pasted “test-raw.prof” at http://hpaste.org/73916
14:57:22 <johnw> so Cale, check this out
14:57:30 <lpvb> are there any style guides for haskell?
14:57:43 <johnw> newline doesn't call anything, so how do I read this?
14:58:02 <johnw> (well, newline calls satisfy, but nothing else in my program)
14:58:54 <monochrom> there is no style guide. go with your heart.
15:00:31 <johnw> lpvb: there are many, just none printed
15:01:15 <monochrom> indeed, there is one in your heart, and there is another one in mine
15:02:11 <monochrom> other languages need style guide because messy code and tidy code look too similar, need some social convention to draw the line
15:02:13 <Cale> johnw: lol, what the heck?
15:02:30 <monochrom> haskell makes messy code look obviously messy. your heart suffices
15:03:02 <Cale> JaffaCake: are you here?
15:03:24 <hpaste> Tordek pasted “Parser fragment” at http://hpaste.org/73917
15:03:35 <johnw> it did make me realize that "satisfy (== 10)" is the more expensive form of "word8 10"
15:03:48 <hiptobecubic> When you are trying to use a new package and the only documentation is like this: http://hackage.haskell.org/PRIVOXY-FORCE/packages/archive/ad/latest/doc/html/Numeric-AD.html#v:grad   how do you figure out how the hell it works?
15:03:54 <Tordek> that one works... but it's ugly; any thoughts?
15:03:57 <Cale> johnw: yeah, but something really weird is obviously happening
15:04:05 <Tordek> https://gist.github.com/3509609 this is the slower, but more complete, version
15:04:21 <Cale> johnw: The funny thing about profiling is that there is no call stack in the GHC evaluator
15:04:55 <johnw> so how do I know what's actually being slow here?
15:05:08 <Cale> johnw: So basically, you have cost centres which get added to your program (either automatically or by hand), and the thing keeps track of how much time is spent inside of which cost centres.
15:05:21 <johnw> ah
15:05:35 <Cale> I think there was a recent update to the way in which it tries to keep track of things in order to try to make it look more like a regular call stack
15:05:45 <Cale> but apparently it has failed in this case
15:05:49 <johnw> this seems to relate to something I'm seeing: http://stackoverflow.com/questions/4151265/attoparsec-allocates-a-ton-of-memory-on-large-take-call
15:06:31 <johnw> that might really help me, actually
15:06:47 <johnw> instead of returning my headers+body from Attoparsec, since the body is always the last thing, I'll return headers+bodylen
15:06:55 <johnw> and then my code can take from the bytestring and resume the parse
15:07:10 <johnw> that way, Attoparsec doesn't have to strictify the input data
15:07:16 <c_wraith> johnw: another thing to remember - allocation isn't necessarily the enemy.  (though if you're on a final optimization pass, reducing allocation usually corresponds with increasing speed)
15:08:36 <Cale> johnw: Do you have the current version of the code pasted somewhere?
15:08:43 <johnw> it on github
15:08:48 <johnw> github.com/jwiegley/svndump
15:09:42 <Cale> I wonder if matters are confused by the fact that these are all CAFs
15:10:26 <Cale> johnw: turn optimisations off
15:10:30 <Cale> johnw: and try again
15:10:44 <Cale> Of course, this is unrealistic, but it might actually produce saner results
15:10:52 <Cale> By "off" I just mean don't pass -O
15:11:14 <Tordek> how can I make this more strict? "parseNull' l = char '~' >> return N" ? it should return N iff l == 0; otherwise, parse error?
15:11:14 <Cale> I bet this is being caused by inlining
15:11:39 <johnw> how do I change just one field in a record again?
15:11:46 <Cale> Tordek: pattern match?
15:11:48 <johnw> Cale: ok, I'll try that
15:12:00 <Tordek> johnw: record { foo = bar} ?
15:12:02 <Cale> johnw: myRecord { fieldName = newValue }
15:12:17 <johnw> kk
15:12:18 <johnw> thanks
15:12:29 <johnw> trying the not-letting-attoparsec-read-the-body trick
15:12:41 <Tordek> Cale: is there a  "never match" function?
15:14:10 <Cale> Tordek: you mean, a parser which always fails?
15:14:18 <Cale> Tordek: which parsing library are you using?
15:14:22 <Tordek> yeah
15:14:29 <hpaste> armlesshobo pasted “wat” at http://hpaste.org/73918
15:14:30 <Tordek> I found it, pzero/fail
15:14:33 <Tordek> I'm using parsec
15:14:48 <hpaste> bobajett pasted “sum two unequal lists” at http://hpaste.org/73919
15:14:54 <armlesshobo> i must be missing something
15:15:22 <johnw> oh wow, that *really* changed the speed
15:15:44 <monochrom> "a" is not "Double"
15:15:46 <bobajett> ok I took a shot at summing two unequal lists, but is there a better way to do this? especially if Im summing more than two lists?
15:15:54 <Cale> Tordek: maybe you could use  'unexpected'
15:16:07 <hiptobecubic> @info grad
15:16:07 <lambdabot> grad
15:16:24 <hiptobecubic> Guess it doesn't have that module by default. oh well
15:16:37 <hiptobecubic> Does anyone know how the grad function works in Numeric.AD?
15:16:43 <hiptobecubic> diff is obvious enough
15:16:44 <johnw> Cale: we're now faster than egrep!
15:16:57 <Cale> johnw: What did you do?
15:17:08 <johnw> moved the body read out of AttoParsec
15:17:11 <alpounet> hiptobecubic, 'ad' package?
15:17:15 <hiptobecubic> alpounet, yes
15:17:15 <Cale> hah
15:17:26 <johnw> I parse the Entry, the take X from the lazy bytestring, drop X and pass that to AP to read the next Entry
15:17:42 <johnw> this is huge
15:18:03 <johnw> because I'm not doing any skipping, like the C++ version does, I actually make everything available to the caller
15:18:47 <shachaf> @let zip' [] [] = []; zip' [] ys = map (\y -> (Nothing,Just y)) ys; zip' xs [] = map (\x -> (Just x,Nothing)) xs; zip' (x:xs) (y:ys) = (Just x, Just y):zip' xs ys
15:18:49 <lambdabot>  Defined.
15:18:52 <johnw> the numbers it's getting out are correct, though
15:19:04 <Paprikachu> > --3
15:19:05 <lambdabot>   not an expression: `--3'
15:19:09 <Paprikachu> > -(-3)
15:19:10 <lambdabot>   3
15:19:15 <atriq> If I've got a silly transformer stack that has MaybeT at the bottom, how do I get the NothingT or whatever
15:19:27 <johnw> ok, now doing the full comparison timing, with results averaged
15:19:28 <hiptobecubic> oh i didn't even notice my ugly PRIVOXY-FORCE in the url :(
15:19:31 <johnw> be done in about 30 mins
15:19:43 <Ippo> !quit
15:19:50 <johnw> thanks for all your help, Cale!
15:19:56 <johnw> this is huge win for lazy programming in my opinion
15:20:09 <hpc> atriq: start with the definition, i think
15:20:11 <hpc> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/src/Control-Monad-Trans-Maybe.html#MaybeT
15:20:14 <c_wraith> atriq: First off, MaybeT can't be at the bottom, by standard terminology
15:20:36 <atriq> I ignore your standard terminology and replace it with my own!
15:20:36 <alpounet> hiptobecubic, what is it that you don't get with grad?
15:20:38 <atriq> Anyway
15:20:41 <Cale> johnw: Yeah, many programs take a little bit of subtlety to get right, but it's always just a bit of strictness in the right places.
15:20:43 <johnw> the C++ code to do this parsing is 506 lines; the Haskell code is 82.  And it's now 5 times aster
15:20:51 <johnw> *and* it's far simpler
15:20:55 <atriq> It's MaybeT (StateT Integer IO)
15:20:57 <Cale> johnw: I'd still like to see what the profile looks like without -O
15:21:00 <hiptobecubic> alpounet, what the arguments to that function even look like?
15:21:04 <johnw> Cale: I'll do that next
15:21:04 <lpvb> hey, I tried running the example code in http://learnyouahaskell.com/input-and-output#randomness where the program is asking you to guess a random number, but the question string only gets displayed after I enter input
15:21:06 <Cale> johnw: See if it's any clearer
15:21:21 <c_wraith> atriq: so you want to branch depending on whether it's shortcutting or not?
15:21:28 <hpc> lpvb: running it from ghci, i take it?
15:21:32 <lpvb> no
15:21:34 <lpvb> I compiled it
15:21:39 <c_wraith> atriq: in that case, I'd use (<|>)
15:21:42 <atriq> c_wraith, I don't know? I want to short-circuit it, I think
15:21:45 <hiptobecubic> alpounet, so i have a function of three arguments and i want to compute the gradient of it
15:21:52 <hpc> hm, the solution is probably the same, anyway
15:22:01 <hpc> lpvb: you should hFlush stdin
15:22:03 <hpc> er
15:22:03 <johnw> be back in a while
15:22:04 <hpc> stdout
15:22:10 <bobajett> shachaf: was that code snippet for me? (Im trying to sum two lists)
15:22:11 <atriq> Wait,
15:22:12 <hiptobecubic> alpounet, f a b c works fine.  diff (f a b) c, does what you'd expect as well
15:22:13 <atriq> mzero
15:22:15 <lpvb> ok I'll try that
15:22:15 <hpc> the question is getting buffered
15:22:33 <hiptobecubic> alpounet, but i don't understand the type signature of grad
15:22:47 <shachaf> bobajett: Well, doing it that way is probably more trouble than it's worth.
15:22:58 <c_wraith> atriq: hmm.  Have you got it sorted out?
15:23:05 <atriq> c_wraith, I think so
15:23:26 <bobajett> the way I was doing it? or the way you wrote it? Plus I'd really like to generalize it to sum more than 2 lists.
15:23:50 <alpounet> edwardk, hiptobecubic needs help with ad
15:23:51 * hackagebot svndump 0.4.0 - Library for reading Subversion dump files  http://hackage.haskell.org/package/svndump-0.4.0 (JohnWiegley)
15:24:01 <edwardk> ?
15:24:14 <hiptobecubic> alpounet, i suppose i could have done that as well :)
15:24:24 <edwardk> hiptobecubic: vgrad f a b c
15:24:25 <lpvb> hpc: That worked thanks. Why did it not run as expected though? Did haskell change or is it an OS thing?
15:24:34 <hiptobecubic> edwardk, the type sig of grad. What's going on there
15:24:52 <hpc> lpvb: ghci buffers one way, compiled programs buffer another
15:24:57 <edwardk> grad (\[x,y,z] -> x * y + z) [1,2,3]
15:25:05 <EvanR_> always set the buffering mode explicitly
15:25:05 <alpounet> hiptobecubic, i've used ad a while back for uni, but not since then, i prefer handing it over to edward at that point
15:25:11 <hpc> it's a ghc thing; i don't think the standard specifies
15:25:19 <alpounet> ven if f is basically any traversable thing that will hold your values
15:25:21 <hpc> yeah, if buffering matters, set it explicitly
15:25:28 <edwardk> hiptobecubic: i need to bundle up with every variable some kind of metadata, be it an entry in the tape of reverse mode, or a bunch of derivatives for forward, tower and sparse mode
15:25:43 <alpounet> it's made so that you don't have to be specific like enforcing the use of vector, lists, etc
15:25:45 <hpc> a statement of no buffering mode means "i don't care" more than "i want the default"
15:25:48 <edwardk> hiptobecubic: thats what the 'AD s' nonsense is about
15:25:55 <hpc> er, no statement of buffering mode
15:26:16 <edwardk> hiptobecubic: now, to take multiple arguments gracefully, i let grad take any traversable container full of variables and i refill it with ad variables
15:26:23 <lpvb> the tutorial ran it with runhaskell though
15:26:33 <lpvb> how do you run it in ghci?
15:26:39 <hiptobecubic> edwardk, ahhhh ok.
15:26:46 <alpounet> i was thinking about writing up a short ttorial about ad at that time
15:26:49 <hiptobecubic> edwardk, that's what i wasn't seeing
15:26:50 <alpounet> maybe i should do it
15:26:54 <armlesshobo> monochrom: why does it expect [Double] and not [a]?
15:27:03 <armlesshobo> monochrom: that doesn't make sense to me :\
15:27:04 <alpounet> and then rewrite hnn on top
15:27:05 <alpounet> bam.
15:27:21 <edwardk> hiptobecubic: you can use [] if you want to just pass in a fixed set of numbers, or you can make something more principled for exactly the number of args you need
15:27:50 <edwardk> hiptobecubic: now, the version of the type used by 'grad' is very safe. it can't go wrong with you forgetting to lift or lifting too many times
15:27:58 <monochrom> in "x / y", we expect x, y, and the answer to be of the same type. you have chosen the answer type to be Double. therefore the others are also Double
15:28:03 <edwardk> mathematically it keeps you from confusing infinitesimals
15:28:15 <edwardk> but there is a 'nicer' form of grad i also export
15:28:19 <edwardk> that lacks this safety
15:28:19 <monochrom> this makes every sense to me
15:28:30 <hiptobecubic> edwardk, sounds good. I need to play with it some more to be comfortable with it
15:28:36 <edwardk> 'vgrad' doesn't require you to bundle up your arguments
15:28:36 <monochrom> type of (/) has never been (Num a, Num b, Num c) => a -> b -> c
15:28:38 <EvanR_> nice and safe, choose one ;)
15:28:40 <edwardk> vgrad (+) 1 2
15:28:47 <edwardk> and vgrad' (+) 1 2
15:29:05 <hiptobecubic> edwardk, ah ok. I was just reading about that complaint on blog.sigfpe
15:29:05 <edwardk> the variadic grad functions take an n ary function and return an n-ary function
15:29:11 <monochrom> actually even Num is wrong. (/) requires the type class Fractional
15:29:13 <hiptobecubic> the "confusion of infinitesimals"
15:29:22 <edwardk> yeah, barak is rather opinionated about that topic, even if he's wrong ;)
15:29:48 <edwardk> the types keep you safe, remember that =)
15:29:59 <armlesshobo> monochrom: right. Which has instances of Fractional Float/Double defined.
15:30:21 <edwardk> anyways, if you just have a double lying around you need to use you can use 'lift' (its in Numeric.AD.Types or Numeric.AD.Classes
15:30:35 <edwardk> that embeds it as an AD constant
15:32:15 <edwardk> infinitesimal confusion is the same thing you get when you start taking the derivative of something with regards to one variable, and then switch to doing something else that depends on what you were just doing. chung-chieh shan wrote a very nice blog post explaining the issue by showing how you can screw up taking the derivative of a function that also takes derivatives internally
15:32:36 <edwardk> with the (forall … ) that is hiding in the signature of my methods in AD, you can't screw it up.
15:32:55 <edwardk> but with vgrad, if you take vgrad of a function that uses vgrad you can screw it up
15:33:28 <edwardk> it is unfortunate that there is no way to get the convenience of vgrad with the safety of grad
15:33:53 <hpaste> Yiq pasted “javascript” at http://hpaste.org/73920
15:34:27 <edwardk> hiptobecubic: i was also contacted by someone who wants to work with me to add a bunch of conjugate gradient methods, etc. to ad, so there will probably be more toys in there forthcoming
15:34:44 <hiptobecubic> sounds like fun
15:35:48 <monochrom> Haskell 2010 defines line-buffering, block-buffering, and no-buffering. however, "The default buffering mode when a handle is opened is implementation-dependent and may depend on the file system object which is attached to that handle. For most implementations, physical files will normally be block-buffered and terminals will normally be line-buffered." (chapter 41)
15:37:04 <Ippo> testing, don't mind me
15:37:23 <Ippo> !quit
15:37:53 <Ippo> new test
15:38:26 <armlesshobo> monochrom: so, I can only use the (/) with the (Num a, Fractional a) type contraint?
15:39:12 <hpc> Ippo: test on another channel
15:39:20 <monochrom> just Fractional is enough. subsumes Num
15:39:24 <Ippo> ok sorry
15:39:42 <Paprikachu> > +3
15:39:43 <lambdabot>   <no location info>: parse error on input `+'
15:40:13 <armlesshobo> monochrom: but, what if I wanted to be able to handle lists of Ints?
15:40:20 <armlesshobo> [1,2,3,4]
15:40:56 <monochrom> I will have to think about that
15:41:33 <hpaste> bobajett pasted “sum unequal lists” at http://hpaste.org/73922
15:42:29 <spark_> and here I am again, with my space leaks
15:42:35 <armlesshobo> lol
15:42:43 <armlesshobo> spark_: wb :P
15:42:52 <armlesshobo> spark_: don't lie, you just want to be around us :P
15:43:06 <bobajett> shachaf: how's this? http://hpaste.org/73922
15:43:29 <spark_> armlesshobo: hahahaha
15:43:32 <shachaf> bobajett: How 'bout it?
15:43:49 <shachaf> bobajett: As a special optimization you can say sum' xs [] = xs and so on.
15:44:17 <spark_> armlesshobo: This channel is where Icast out the space leak ghost
15:44:23 <armlesshobo> hahah
15:44:31 <armlesshobo> that's #haskell-exorcism
15:44:32 <shachaf> bobajett: Also, you can foldl instead of foldl1 -- [] is an identity.
15:44:34 <armlesshobo> spark_: ^
15:44:53 <johnw> Cale: fully optimized, the numbers are: egrep 62s, c++ full 181s, c++ fseeks 112s, haskell 26s
15:45:12 <bobajett> shachaf: ah gotcha. Im just feeling proud I figured out how to sum unequal lists after at first thinking I can't even sum a few lists in haskell! :-)
15:45:16 <Nafai> johnw: nice!
15:45:27 <hpc> it's funny, because in space, a leak leaves you with empty space instead of stuff
15:45:37 <hpc> whereas a space leak is where your empty space fills with stuff
15:45:46 <ivanm> johnw: so, how did you optimise it to beat fseek? (I'm assuming this is still your svndump stuff)
15:46:11 <bobajett> learning a new language like haskell is proportionally harder with the number of years you've spent doing other (imperative) languages
15:46:24 <ivanm> I beg to differ
15:46:24 <spark_> Someone could see if my SO post is ok? Yesterday I was quite tired and it was a mess t.t
15:46:30 <ivanm> I think it depens on the person
15:46:37 <shachaf> bobajett: Why do you want sum' in the first place?
15:46:48 <ivanm> I had no trouble picking up Haskell when I first started
15:47:05 <ivanm> I think I was probably also the only person in my first year programming course that actually _liked_ scheme
15:47:06 <spark_> bobajett: the bigest problem for me is : the hell im spending time with X, I would be done already in Y
15:48:01 <bobajett> spark_: exactly. took me like an hour to figure out how to sum n lists, when my brain is going "that pattern is already ingrained in your head in python"
15:48:11 <spark_> yep
15:48:15 <bobajett> shachaf: I basically need to sum a number of series and their lengths were unequal
15:48:32 <ivanm> bobajett: sure, but don't generalise your experience to everyone
15:48:50 <ivanm> it almost seems to be a meme that Haskell is hard to pick up, even more so for people used to imperative languages
15:49:09 <ivanm> but that's because those people who find it hard tend to bitch more than the people who find it easy to pick up
15:49:10 <spark_> http://stackoverflow.com/questions/12170439/why-my-program-use-so-much-memory  (for the good mind that could review it for me, thanks! D: )
15:49:22 <bobajett> ivanm: compared to haskell how much time had you spent with other languages before you started haskell?
15:49:29 <monochrom> @quote monochrom unlearning
15:49:29 <lambdabot> monochrom says: Learning is unlearning. Intuition is experience. Understanding is feeling.
15:49:33 <badablargh> for me, it's because it forces you to actually think through the program before you do any writing
15:49:43 <spark_> @quote poet
15:49:43 <lambdabot> poetix says: < poetix_>: In ancient Athens, they used to punish adulterers by forcing radishes up their rectums < boegel>: poetix_: sounds like fun !
15:49:46 <badablargh> you can't just hack something together and then refine it
15:49:52 <monochrom> and I am generalizing everyone's experience to everyone
15:50:32 <spark_> the nice thing about haskell is that when unsure, compile
15:50:43 <ivanm> bobajett: I used Pascal/Delphi all through high school; one semester of scheme in first year uni; three or four years of Java throughout uni; one semester of python in 3rd year uni; matlab throughout uni
15:51:06 <ivanm> and apart from scheme, I did more OO-style programming in matlab and python
15:51:20 <spark_> OO in matlab? dear god
15:51:23 <ivanm> though after learning Haskell I started taking a more FP approach in Matlab (when I had to use it)
15:51:26 <ivanm> spark_: well, not OO
15:51:29 <ivanm> I meant imperative
15:51:33 <spark_> oh right
15:51:41 <ivanm> I did a very heavy OO-style in Python
15:51:53 <nand`> edwardk: what are the lenses for traversing specific list positions called again?
15:51:55 <edwardk> ok, https://twitter.com/kmett/status/240944489731076096 pretty much sums up the last response i want to make to zedshaw
15:52:10 <edwardk> nand`: element and elementOf
15:52:10 <monochrom> I have a special ability enabling me to learn haskell quickly even though I had been imperative and OO all along. I can set up some kind of virtual machine in my mind.
15:52:12 <Tordek> https://gist.github.com/3509609 how can I convert "readContents l" into "readContents l c" so that I can do "readContents size ',' >>= return . S" ?
15:52:12 <edwardk> iirc
15:52:46 <Tordek> (that, and anything you find worthy of mention regarding the parser I'd like to hear)
15:52:56 <nand`> edwardk: is there a (read-only) version that uses Maybe instead of exceptions?
15:53:14 <edwardk> you can use iwhereOf to get a subtraversal
15:53:34 <edwardk> iwhereOf l (==5)
15:53:42 <edwardk> gives you a single element traversal
15:53:48 <edwardk> rather than a lens
15:54:53 <badablargh> !quit
15:55:05 <EvanR_> blarg
15:55:09 <edwardk> yes, you didn't quit
15:55:28 <EvanR_> so i have an acid state, and im trying to write updates for the state which can produce random numbers internally
15:55:50 <hpc> EvanR_: so it's impure inside?
15:56:04 <hpc> but pure outside?
15:56:10 <EvanR_> cant use io, so either the generator has to be in the state, the number have to be passed in to the update, or a generator has to be passed into the update and be serializable
15:56:34 <EvanR_> and i cant seem to get one that i like
15:56:39 <monochrom> armlesshobo: (\x -> realToFrac (sumLst x) / fromIntegral (sizeLst x))  is the more general I can get. it is (Real a, Fractional b) => [a] -> b. it includes both [Int]->Double and [Double]->Double
15:56:43 <hpc> @hoogle unsafePerformIO
15:56:43 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
15:56:43 <lambdabot> Foreign unsafePerformIO :: IO a -> a
15:56:46 <monochrom> s/more/most/
15:56:59 <EvanR_> if i used unsafePerformIO inside an acid state update that would surely break the system
15:57:00 <hpc> EvanR_: if you can prove to yourself that it doesn't matter, you can do the nuclear option
15:57:05 <hpc> ah
15:57:10 <hpaste> Yiq pasted “qq” at http://hpaste.org/73923
15:57:21 <spark_> Question: why parseFile many $ parseLine <* (Ap.endOfInput)  does not terminate when the last line is (parseLine)\n?
15:57:26 <nand`> edwardk: I'm a bit confused. How would I use it to write Integer -> [a] -> Maybe a ?
15:57:26 <EvanR_> it wouldnt be acid anymore
15:58:01 <tnks> to sanity check that Hackage/Cabal works like I think it should:  1) cabal source should never have compiled native code in it, right?
15:58:08 <armlesshobo> monochrom: see, this exercise was found in Chapter 3 of RWH and I thought that I wouldn't have to do something like that (or even have to worry about type contraints in general) as it wasn't really covered completely yet.
15:58:25 <tnks> (every build builds all it's dependencies from scratch?)
15:58:38 <edwardk> myList^?iwhereOf itraverse (==n)
15:58:48 <monochrom> perhaps that exercise does not ask you to be general or flexible either
15:58:52 <edwardk> not the prettiest example
15:58:55 <spark_> tnks: I think if you have the version required, it doesn't
15:59:05 <geekosaur> builds building dependencies all over again is usually a bad sign.  older cabal-install was prone to doing so and breaking the world though
15:59:09 <tnks> spark_: you mean cached, right?
15:59:13 <tnks> that's no problem, I get that.
15:59:16 <bobajett> shachaf: when you said [] is an identity did you mean I could write instead of foldl1 (blah) [[1,2],[3,4]] this: foldl (blah) [] [1,2],[3,4]]
15:59:22 <armlesshobo> monochrom: that's true. I guess I'm just overthinking it then.
15:59:27 <armlesshobo> monochrom: thanks for your help :)
15:59:29 <edwardk> i should probably add an 'iwhere' to the TraversableWithIndex class
15:59:38 <edwardk> then you coul use myList^?iwhere (==n)
15:59:43 <EvanR_> hpc: i decided on mwc-random early on, and now its seems to be rather incompatible with acid state
15:59:43 <shachaf> bobajett: Yes. And it would be nicer, wouldn't it?
15:59:58 <shachaf> In particular, it can't crash. :-)
16:00:04 <nand`> edwardk: I'm still feeling there should be some nicer combinator for iwhere (==n) even so; like iat n
16:00:25 <edwardk> yeah i just omitted it
16:00:28 <nand`> edwardk: worst comes to worst, I could roll my own Integer -> [a] -> Maybe a and compose that with ‘to’
16:00:31 <edwardk> its a big search space =)
16:00:35 * armlesshobo realized you can find the length of a list using foldr
16:00:36 <bobajett> shachaf: ah yes, foldl1 has that ability to crash.
16:00:47 <shachaf> That's foldl1's super power. Not a very good one.
16:00:55 <monochrom> I like crashing
16:01:14 <hpc> EvanR_: i think you should decide what kind of interface you want to have
16:01:18 <nand`> @hoogle Int -> [a] -> Maybe a
16:01:19 <lambdabot> Prelude (!!) :: [a] -> Int -> a
16:01:19 <lambdabot> Data.List (!!) :: [a] -> Int -> a
16:01:19 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
16:01:26 <edwardk> nand`: ill just add iwhere
16:01:38 <hpc> extra parameter, embedded stdgen in the state, etc
16:01:48 <shachaf> foldl1 can mess up your L1 crache
16:02:11 <monochrom> I like confounding caches
16:02:18 <EvanR_> hpc: i decided not to use stdgen because i wanted the statistical properties of mwc, but even though mwc-random only lets me use like 256 bytes of state
16:02:26 <armlesshobo> > foldr (\x -> (1+)) 0 [1,2,3,4]
16:02:27 <lambdabot>   4
16:02:36 <armlesshobo> > foldl (\x -> (+1)) 0 [1,2,3,4]
16:02:36 <EvanR_> in any case, 256 bytes is a lot to serialize
16:02:37 <lambdabot>   5
16:02:49 <EvanR_> every time an update uses random numbers
16:03:00 <EvanR_> hpc: i dont really understand stdgens properties...
16:03:05 <hpc> EvanR_: pppsh, 256 bytes isn't really that much
16:03:12 <spark_> armlesshobo: shouldn't them be the same?
16:03:17 <armlesshobo> spark_: no
16:03:18 <EvanR_> still 256 is not enough for me
16:03:22 <tnks> the next question is about backwards compatibility with older versions of GHC.  Has GHC ever broken backwards-compatibility?
16:03:23 <spark_> armlesshobo: why not?
16:03:36 <EvanR_> and i feel stupid feeding a generator to updates every time
16:03:36 <armlesshobo> spark_: associativity, i believe (i'm actually working it out now)
16:04:06 <EvanR_> bah
16:04:11 <gadtfly> Sorry to shit up the channel with this, but my local builds of pointfree and lambdabot both choke on this
16:04:18 <gadtfly> @pl \w -> (== (length w)) . length
16:04:18 <lambdabot> (. length) . (==) . length
16:04:24 <gadtfly> @pl \d w -> nub . (d ++) . (`zip` w)
16:04:24 <lambdabot> ((nub .) .) . (. flip zip) . (.) . (++)
16:04:39 <gadtfly> ... well that was worthless
16:04:39 <tnks> I noticed the "Built on" field in Hackage, but it doesn't seem to be coming from the corresponding .cabal package metadata
16:04:46 <EvanR_> hpc: my first idea was to give the particilar random numbers needed to the update function, but then... you have to either decide on a specific number of numbers for each kind of update, or give a list and you might run out
16:05:01 <EvanR_> if the number you need is indeterminate
16:05:06 <EvanR_> and if it is, it wont be type safe
16:05:07 <edwardk> nand`: implemented
16:05:15 <hpc> EvanR_: you can pass an infinite list
16:05:28 <EvanR_> that will not work
16:05:36 <EvanR_> everything you pass to an update needs to be serializable
16:05:48 <geekosaur> tnks, I think it comes from index data and refers to automatic test builds by a buildbot on the hackage server
16:06:03 <EvanR_> updates are converted to Update X Y Z and written to the acid log on disk
16:06:07 <hpc> oh right, damn
16:06:10 <hpc> forgot about that
16:06:32 <EvanR_> why is this so hard >_<
16:06:46 <tnks> geekosaur: I see, so I'm guessing GHC has never broken backwards compatibility, so if you're on a late enough GHC, you're fine?
16:06:57 <geekosaur> not always true
16:07:14 <hpc> EvanR_: perhaps if you described the application this is for
16:07:22 <hpc> there could be a specific solution to your needs
16:07:24 <edwardk> ghc very rarely breaks backwards compatibility, but if it does its for a good cause ;)
16:07:41 <geekosaur> there are a number of times backward compat has been lost, and various conditionals in many .cabal files to compensate
16:08:00 <geekosaur> yeh, they try to avoid it, but it still happens and usually for good reason
16:08:07 <HugoDaniel> hi
16:08:18 <edwardk> expect some upheaval once a year with the major version releases
16:08:33 <hpc> backwards compatibility isn't as much of an issue as other libs needing more recent depends
16:08:35 <hpc> imo
16:09:03 <edwardk> yeah the ecosystem is moving forward, keep pace or your libs die. this is good, it forces active maintainership
16:09:04 <nand`> edwardk: can you push ‘iwhere’ to github?
16:09:05 <tnks> just curious why the target GHC isn't part of the cabal metadata.
16:09:07 <hpc> which forces ghc upgrades more often than would usually be expected for a compiler
16:09:11 <edwardk> nand`: yep
16:09:13 <tnks> even if a range.
16:09:24 <hpc> tnks: to a certain extent, it is
16:09:31 <bobajett> spark_: armlesshobo: LYAH explains that foldl starts with the accumulator as the first value and then the first element of the list
16:09:33 <hpc> the version of base is tied directly to ghc
16:09:45 <tnks> hpc: ah. . . cool.
16:09:54 <bobajett> whereas foldr starts with the first value of the list (from the right) as the accumulator value
16:10:06 <tnks> hpc: although. . . slightly wonky (seems error-prone)
16:10:08 <edwardk> nand`: check now
16:10:10 <EvanR_> hpc: its an acid mud
16:10:16 <dcoutts_> tnks: most packages can build with most ghc versions
16:10:22 <tnks> dcoutts_: that's what I figured.
16:10:33 <dcoutts_> tnks: and also, there are Haskell implementations other than ghc
16:10:36 <tnks> mostly, I just wanted to better understand the state of the art from an operations perspective.
16:10:40 <hpc> EvanR_: and the statistical properties matter that much?
16:10:47 <nand`> edwardk: excellent, thanks
16:10:50 <latro`a> bobajett: I think that treating foldr as based on an accumulator is somewhat misleading
16:10:53 <hpc> you should probably bite the bullet and just put the generator into the state
16:10:55 <EvanR_> when its time for autonomous events to occur and update the world, it may want to produce random numbers
16:11:08 <bobajett> latro`a: I'd agree
16:11:10 <EvanR_> hpc: yeah...
16:11:15 <hpc> that way you can restore the same generator at any point
16:11:23 <EvanR_> yes
16:11:26 <hpc> seamless statistical whatever
16:11:28 <EvanR_> but this time, i decided i didnt care
16:11:31 <tnks> thanks everyone for the chat about Cabal/Hackage.
16:11:32 <hpc> heh
16:11:34 <EvanR_> i wanted 'just random'
16:12:08 <EvanR_> well anyway, yeah i need to put the generator in the state
16:12:14 <EvanR_> and that means it cant be mwc
16:12:38 * EvanR_ redesigns the whole interface
16:13:09 <Tordek> hmph; I'm trying these: http://blog.tmorris.net/20-intermediate-haskell-exercises/ but I have  no clue how to read the 3rd one
16:13:52 <EvanR_> lets see if stdgen will serialize
16:14:25 <latro`a> tordek, what about it
16:14:32 <nand`> edwardk: is there a State version of ^? ?
16:14:34 <c_wraith> Tordek: it's like (t ->)
16:14:51 <latro`a> the only different thing about (->) is that it infix, but it behaves like the other infix functions in that it becomes prefix when you wrap parens
16:14:55 <c_wraith> Tordek: it means "a function from the type t to a type that hasn't been applied yet"
16:15:04 <nand`> or do I have to use ‘gets (headOf l)’
16:15:05 <latro`a> so ((->) t) is like ((+) t)
16:15:11 <edwardk> nand`: nope. names welcome
16:15:24 <Tordek> ok, that makes sense
16:15:53 <edwardk> i could go with something like 'access'
16:16:02 <Tordek> but how would you call one of those? as in, what would you pass to "furry"?
16:16:16 <edwardk> since use is also similarly imperative
16:16:17 <nand`> edwardk: I would be fine with something like that
16:16:54 <latro`a> tordek: one of what?
16:17:29 <latro`a> plug in f = ((->) t)
16:17:32 <Tordek> latro`a: what's an exaple of a function of type "t ->" I guess?
16:17:39 <latro`a> and you get (a->b) -> (t->a) -> (t->b)
16:17:48 <latro`a> for the type of furry
16:18:55 <Tordek> hmm
16:19:10 * Tordek tries to grok this; bbl
16:19:14 <latro`a> that is, ((->) t) a = (t->a)
16:21:37 <dibblego> hi Tordek, So far you have done exercises on [] and Maybe and you will surely recognise that these are "things that take one more type variable." This property (denoted by having the kind: * -> *) is critical to defining instances for Functor. However, the (->) takes *two* type variables (the input and output type) so what we do is partially-apply one type variable (t) and then we have "a thing that takes one type-variable", which means we can instance F
16:21:38 <dibblego> unctor without a "kind error" from the compiler
16:22:53 <dibblego> er s/Functor/Fluffy (woops!)
16:23:26 <Tordek> haha yea, I already gathered fluffy meant functor
16:23:33 <Tordek> thanks :)
16:26:01 <edwardk> dibblego: i need to come up with a bunch of warm and fuzzy names for lenses and stores, etc. for a similar set of examples ;)
16:26:19 <dibblego> edwardk: yes definitely!
16:26:36 <edwardk> do you have the link to your original worksheet handy?
16:26:41 <Tordek> so, "fluffy = (.)". I'mma be picking up shards of mind over here; bbl
16:26:57 <edwardk> Tordek: yep
16:27:16 <nand`> is there a way to get the first index of an indexed traversal?
16:27:17 <edwardk> torek: you missed some under the desk
16:27:19 <ixmatus> is there anything like a project skeleton builder for Haskell? A bit like rebar for Erlang (even though Rebar does way more than what a haskell equiv would need to do)
16:27:26 <dibblego> edwardk: I keep everything updated at https://github.com/tonymorris/course but I have not done much with lenses and some of it is experimental (in that I have tried it in a teaching setting and failed)
16:27:33 <EvanR_> hpc: so im looking at cprng-aes for the shit of it
16:27:40 <edwardk> nand`: you want the minimum key or something?
16:27:45 <nand`> edwardk: maximum key of a map, yeah
16:28:03 <nand`> I don't see a nice function for it in Data.Map so I figured I'd use traverseMaxKey or w/e
16:28:04 <dibblego> Tordek: notice how (.) fits the signature for fluffy
16:28:08 <edwardk> there is a actual indexed traverseAtMax in Data.Map.Lens
16:28:14 <ixmatus> ^?
16:28:23 <nand`> edwardk: but I'm not interested in the value - just the key
16:28:54 <Tordek> dibblego: yeah; I actually did the step-by-step
16:29:02 <edwardk> hrmm i need 'iviews' i think
16:29:39 <EvanR_> hpc: split for this rng produces a seed using the generator and makes a new generator with it
16:29:40 <edwardk> you can use minViewWithKey and maxViewWithKey to get the key, thats how that traversal work
16:29:46 <edwardk> er works
16:29:50 <EvanR_> hpc: is that how it normally works? does that do what split is supposed to do?
16:30:09 <hpc> i honestly don't know
16:30:10 <edwardk> gives you a Maybe ((k,v),Map k v)
16:30:27 <hpc> split is fairly subtle in what it is "supposed" to do
16:30:28 <armlesshobo> can i step through recursive functions in ghci?
16:30:36 <nand`> edwardk: just trying to avoid the ugly fmap (fst.fst)
16:30:40 <hpc> and i understand it doesn't actually do it, for stdgen
16:30:45 <nand`> I guess I'll go with that
16:31:16 <nand`> and I'm composing with lenses either way, so I'd need to use ‘to’ also
16:31:18 <edwardk> getFirst . getConst . itraverseAtMax (\i -> Const . First . Just . const i)
16:31:23 <edwardk> clearly thats prettier ;)
16:31:48 <EvanR_> hpc: really, for a while i thought stdgen was the only one to 'do it right' but never got any concrete details on it
16:31:56 <edwardk> now, i'm curious what the right compositional answer is though
16:32:17 <nand`> I figured it'd be something like:  access (foo.traverseAtMax.index)
16:32:18 <edwardk> i can make an iviews and indices combinator to get back all the indices
16:32:24 <edwardk> yeah
16:32:35 <edwardk> i see where you're going. just trying to figure out how to get there
16:32:55 <edwardk> i can probably make something that takes an indexed fold/traversal and gives you an indexed fold of the indices
16:33:11 <edwardk> foo.indices traverseAtMax
16:33:12 <nand`> that seems reasonable
16:33:25 <edwardk> or i suppose just a fold of the indices even
16:33:52 <edwardk> indicesOf sounds right
16:34:01 <edwardk> then indices can work on an indexed foldable
16:34:07 <edwardk> er FoldableWithIndex
16:35:18 <nand`> hmm, stylistic issue: foo.at i .= Just v   vs   foo  %= Map.insert i v
16:35:43 <edwardk> the Just _is_ kinda ugly
16:35:49 <janua> How can i partially apply fmap? Is it possible?
16:35:52 <nand`> yeah
16:36:27 <edwardk> the latter is probably marginally more efficient as well
16:36:45 <edwardk> i don't like using constructors to communicate meaning to functions like that when i can avoid it
16:36:58 <nand`> fair point; I'll go with the latter
16:37:13 <nand`> figure it's best to avoid fancy lens code when it doesn't improve anything
16:37:20 <nand`> to prevent the amount of ‘migration’ hassle
16:43:07 <EvanR_> arrrggg cprng-aes rng cant be saved and restoreddddddd
16:44:15 <EvanR_> what kind of rng doesnt let you serialize the current state
16:44:31 <donri> cprng-aes
16:44:43 <monochrom> ghostly kind :)
16:45:51 <EvanR_> i see theres a CryptoRng class for letting you add entropy on the fly
16:46:09 <EvanR_> maybe we need a save and restore class
16:46:49 <EvanR_> alright next rng
16:52:50 <hiptobecubic> Tuples aren't Traverasble?
16:53:11 <hpc> hiptobecubic: you can traverse the right-most element
16:53:14 <hpc> maybe?
16:53:38 <hiptobecubic> hpc, well that's what fmap does i guess?
16:53:45 <hiptobecubic> > fmap negate (1,2,3)
16:53:46 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t t1))
16:53:46 <lambdabot>    arising from a use of `e_...
16:53:52 <hiptobecubic> > fmap negate (1,3)
16:53:53 <lambdabot>   (1,-3)
16:53:59 <hiptobecubic> only two tuples i guess
16:54:27 <hpc> you might be able to traverse over specific tuple lengths if you do a silly Endo-like trick
16:54:39 <hpc> newtype Vec5 a = Vec5 (a, a, a, a, a)
16:55:35 <ahkurtz> why are tuples not traversible?
16:56:40 <monochrom> because "traversing" (Int, Double, Char, Bool, IO (Int, Double, Char, Bool)) is strange
16:57:01 <hiptobecubic> indeed
16:57:04 <shachaf> Haskell forbids strangeness.
16:57:07 <monochrom> I mean, sure, lisp and perl and python and php let you do it
16:57:08 <hpc> haha
16:57:31 <hpc> more likely because writing 62 instances for each tuple size is a bitch
16:57:33 <monochrom> precisely why I put lisp, perl, python and php in the same group, and don't use any of them
17:00:15 <geekosaur> tuples aren't really intended to be iterated over.  you want a list, use a list
17:06:44 <lpvb> what editors do you guys use for haskell?
17:06:59 <donri> vim
17:07:04 <latro`a> raw vim, though I won't say that's the best idea in the world
17:07:14 <hiptobecubic> i will :)
17:07:17 <latro`a> (raw as in without any neat shenanigans)
17:07:23 <hiptobecubic> ah
17:07:24 <hiptobecubic> then no
17:07:32 <donri> neat shenanigans = https://github.com/dag/vim2hs
17:07:38 <latro`a> that sort of stuff yeah
17:07:42 <hiptobecubic> vim without shenanigans is a pretty big disaster
17:07:53 <latro`a> I mean, just the shenanigans vim itself offers
17:07:57 <latro`a> no vimrc or extension shenanigans
17:08:12 <hiptobecubic> that's what i mean
17:08:25 <latro`a> k
17:08:56 <lpvb> so no autocomplete or anything?
17:09:15 <donri> lpvb: https://github.com/ujihisa/neco-ghc
17:10:07 <hpaste> dancor pasted “portaudio segfault iff compiled.  Am I compiling incorrectly?” at http://hpaste.org/73924
17:11:16 <geekosaur> hm, occurs to me you might check if it works if compiled -threaded; ghci runs threaded runtime.  although that's still a bug if so (but helps narrow the possibilities)
17:12:19 <dncr> geekosaur: no luck
17:12:22 <edwardk> nand`: adding withIndicesOf which takes an indexed fold to a fold of index, value pairs, and indicesOf which takes an indexed fold to a fold of its indices
17:12:34 <edwardk> nand`: and the corresponding withIndices and indices
17:12:52 <geekosaur> :(
17:13:16 <dncr> geekosaur: interestingly, -threaded makes the larger file Example1.hs stop doing SIGBUS; and it now also segfaults!
17:13:32 <latro`a> why do you bind ret
17:13:34 <latro`a> just curious
17:13:39 <latro`a> you never use it
17:13:43 * ddarius has always used vim without shenanigans for Haskell.
17:13:50 <geekosaur> interesting.  I fully expect ghci lays memory out differently
17:13:52 <dncr> latro`a: i was going to print it
17:13:59 <latro`a> k
17:14:03 <EvanR_> haha shenanigans
17:14:06 <ahkurtz> geekosaur: I feel that is more of a non-answer than I usually get from haskell. what hpc said makes sense though
17:14:19 <edwardk> i need to write a vim plugin called shenanigans now
17:14:25 <latro`a> lol
17:14:29 <EvanR_> yeah
17:14:55 <dncr> geekosaur: do you think this might be a bug in the haskell binding to portaudio?
17:15:22 <geekosaur> dncr, I think it likely.  I'm try9ng to figure out if it's at all sane to run a ghc compiled program under valgrind
17:16:02 <dncr> ooooh
17:16:02 <geekosaur> ahkurtz, when I see someone trying to iterate or etc. over a tuple I tend to think they have haskell tuples confused with python's tuples, whcih are equivalent to haskell's lists.  (python's lists are more like Vector.)
17:16:41 <shachaf> geekosaur: Aren't they both like (heterogeneous) arrays?
17:17:06 <ahkurtz> the order isn't really supposed to be important though, they aren't sequential
17:17:09 <ahkurtz> right?
17:17:26 <ahkurtz> just a relation of things
17:17:31 <monochrom> wait til you see someone treating haskell class like python class
17:17:57 <geekosaur> dncr, sounds like ghc binaries are known to blow up under valgrind though.  :(  http://hackage.haskell.org/trac/ghc/ticket/3215
17:17:58 <monochrom> the power of "they are the same thing because they have the same name" cannot be overestimated
17:18:07 <ahkurtz> geekosaur: I'm just used to haskell answers being "deep math reason you didn't think of" rather than "you're doing it wrong"
17:18:08 <geekosaur> yeh, that was my point
17:18:56 <geekosaur> I think the idea of "iterating" over an ADT (of which tuples are kind of a degenerate case) gets into generics
17:18:56 <monochrom> I make "deep" math reasons shallow
17:20:04 <ahkurtz> haha, yeah, I mean compared to my understanding of things the answers are often deep. I'm running from ruby/python.
17:21:08 <geekosaur> dncr, in any case, it sounds vaguely like something is writing outside the bounds of a vector or something.  (I have not looked at the portaudio package to see if this happens, but I fully expect it manipulates buffers of some kind just by the nature of the beast)
17:21:25 <geekosaur> alternately it's treating as pinned some memory that is not pinned and a garbage collection has moved it
17:21:30 <dncr> can anyone reproduce my problem
17:21:39 <dncr> geekosaur: have you reproduced it?
17:21:48 <ahkurtz> it's not REALLY generics, because an instance of each kind of tuple is a consistent type, but that the compiler would have to generate all possible implementations which is really just generics pretending not to be
17:22:26 <geekosaur> I can't try currently, this machine is not really up to building stuff (I'm running portable on an overloaded macbook air)
17:22:33 <dncr> ah ok
17:22:58 * dncr afraid to submit bug report w/o repro
17:22:58 * EvanR_ is using a macbook air
17:23:06 * EvanR_ cabal installs something
17:25:23 <lpvb> donri: how do I install vim2hs with Vundle?
17:25:32 <EvanR_> ok ac-random also does not let you serialize deserialize the generator
17:25:35 * EvanR_ continues
17:25:59 <monochrom> hmm, do you have to cabal install to find out?
17:27:20 <EvanR_> no but its painfully obvious if i do, then 'show' the generator
17:27:28 <EvanR_> then look for an alternative and cant find it
17:27:40 <EvanR_> and then bitch about it
17:28:47 <iv597> Hello all. So, I'm new to Haskell, and the first project I'm looking to do is basically an ncurses Mumble client. I can easily think of how to do it in Python or C, but obviously that doesn't all carry over. The biggest stumping point I've found is how to store a list of connected users. I can't use an array as I need to be able to change the list of users. Would some monad hackery be the "right way" to
17:28:48 <iv597> implement such a thing?
17:29:01 <lpvb> nvm, donri, found my answer
17:29:53 <monochrom> I wonder why it is a list or an array, but not a set.
17:30:47 <iv597> monochrom: See, my newbishness with haskell shows. List/arrays were the first (and only, really) thing that popped in my mind. I'll go read about sets I guess then :D
17:31:07 <monochrom> but in all 3 cases there are ways to either have real mutability or fake mutability. fake mutability means passing a parameter around, pass a different paramenter to "mutate"
17:31:11 <EvanR_> iv597: yeah you really want a set of connections
17:31:31 <hpc> you can't really make a Set out of connections though
17:31:35 <hpc> what with the whole Ord thing
17:31:39 <EvanR_> assign an id
17:31:42 <monochrom> I have problem believing that you have never seen sets in python
17:31:45 <hpc> that works
17:32:02 <monochrom> I am more inclined to believe that most people just pretend "everything is an array"
17:32:50 <iv597> monochrom: I always used arrays for mutable lists. Tuples for immutables. Never bothered with sets that I recall. Or if I did I sure didn't realize >.>
17:32:56 <latro`a> eh, I wouldn't be too surprised if they only used dicts
17:33:08 <latro`a> but then dicts aren't that far from sets
17:33:13 <EvanR_> its called a list in python
17:33:16 <latro`a> in that sets are just dicts without values
17:33:39 <monochrom> yes latro`a, it is why my disbelief
17:33:54 * hackagebot postgresql-simple 0.2.4.1 - Mid-Level PostgreSQL client library  http://hackage.haskell.org/package/postgresql-simple-0.2.4.1 (LeonSmith)
17:35:02 <EvanR_> Map ConnId Connection
17:35:39 <dncr> i used sets in python, but i think i was considered haughty
17:36:08 <ddarius> Presumably with Python's philosophy sets have a use.
17:36:15 <dncr> we don't take kindly to invariants around these parts
17:38:03 <monochrom> I have seen code written by world-class winners of programming contests. when they write graph algorithms, e.g., dijkstra shortest path, they use arrays. not binary search trees, not heaps. arrays. yes they use linear search for "find the minimum". every iteration. these are world-class winners of programming contests, and even they code like data structures do not exist
17:38:40 <monochrom> granted, their language is C, which has "arrays" written all over it, and any other data structure requires extra hand-typing
17:39:01 <ddarius> They know the tao of the machine.
17:39:59 <sipa> monochrom: that's just because array processing requires the least code
17:40:04 <sipa> i think
17:40:08 <monochrom> yes
17:41:06 <lpvb> vim2hs is folding all my functions and it's really annoying, how do I disable that? :(
17:41:53 <ddarius> lpvb: If you need to see more than the types of your functions, you're doing it wrong.
17:42:35 <EvanR_> :: IO () ;)
17:42:42 <dncr> let's say types and names
17:42:50 <dncr> well then still main :: IO ()
17:42:55 <ddarius> Names lie.
17:43:09 <monochrom> you can disable by deleting vim2hs
17:43:25 <monochrom> also, switch to emacs
17:43:42 <lpvb> I don't like emacs way of editing
17:43:49 <shachaf> Types can lie too. :-(
17:44:06 <dncr> lpvb: isn't there a vim command to just unfold everything http://vim.wikia.com/wiki/Folding
17:44:38 <hiptobecubic> z R i think?
17:44:50 <monochrom> amazon.ca is shipping my order of the perils of functional programming!
17:45:07 <shachaf> :set nofoldenable
17:45:47 <lpvb> thanks shachaf
17:46:20 <ddarius> "Functional Perils" by Dick Avian.
17:47:00 <monochrom> actually, http://www.amazon.ca/Perils-Functional-Programming/dp/0521513383/
17:47:29 <EvanR_> stupid RandomGen class
17:47:36 <EvanR_> with its Int crap
17:48:07 <EvanR_> my rng doesnt produce Int it produces Word32 or Int32
17:48:13 * ddarius would, incidentally, expect PRNG state to be serializable through Binary or like, not Show.
17:48:45 <EvanR_> ddarius: either way even fewer export a Binary than show
17:52:21 <ddarius> EvanR_: There's nothing for it then but for you to create your own language where all PRNG states are serializable.
17:54:47 * ddarius has a sudden desire to make a language based on temporal logic with both backward and forward necessity modalities.
17:54:58 <aristid> ddarius: it will pass.
18:03:29 * otters reluctantly gives up on using IsString and Category to make PHP-like string concatenation
18:03:55 <ddarius> otters: What?  You give up too easily.
18:03:55 * hackagebot parsergen 0.2.0.2 - TH parser generator for splitting bytestring into fixed-width fields  http://hackage.haskell.org/package/parsergen-0.2.0.2 (JasperVanDerJeugt)
18:04:01 <otters> ddarius: It's true
18:04:01 <monochrom> haha
18:04:31 <otters> I got as far as defining a Category instance for Const String a b where data Const a b c = Const a
18:04:36 <otters> and then the IsString bit escaped me
18:05:11 <ddarius> otters: Incidentally, you can generalize to all monoids which will also make you not need flexible instances.
18:05:24 <otters> You're absolutely right
18:06:10 <ddarius> otters: Then you can try to convince people that PHP's syntax is inspired by and revealing a deep categorical insight.
18:07:21 <monad> :S
18:07:22 <otters> I don't know anyone who uses PHP heavily that would understand that.
18:08:40 <dolio> ddarius: That blog post has been written already, just for C.
18:08:42 <otters> The IsString instance still escapes me though.
18:08:55 <otters> At least, without using flexible instances.
18:09:24 <Saizan> you should not be scared by FlexibleInstances
18:10:18 <otters> Wait, that isn't the problem
18:10:18 <ddarius> How many possible implementations of IsString can Const have?
18:10:33 <otters> ("foo" :: Const String a b) . ("bar" :: Const String a b) returns Const "foobar"
18:10:49 <otters> But "foo" . "bar" gives me a missing instance error
18:10:49 <otters> With OverloadedStrings turned on
18:11:03 <johnw> Cale: ping
18:11:35 <Saizan> well, that's just ambiguity i suspect
18:11:55 <ddarius> php :: Const String a b -> String; php ("foo" . "bar")
18:11:58 <Cale> johnw: hello
18:12:01 <Cale> I'm back :)
18:12:08 <johnw> so, I have the non-O profiling results
18:12:25 <johnw> heap using is *totally* changed by not having Attoparsec read the node bodies
18:12:38 <johnw> down from 865G allocated over the run, to 33G allocated (data input size *3)
18:12:54 <johnw> but the profiling output still looks strange
18:13:04 <hpaste> johnw pasted “test-raw.prof (without -O)” at http://hpaste.org/73925
18:13:34 <johnw> also, why is 33% of the time being spent in main, I don't really get what main is doing that's expensive
18:13:35 <hpaste> otters pasted “PHP string concat” at http://hpaste.org/73926
18:13:37 <johnw> it's just calling "length"
18:13:40 <otters> that's the stuff
18:14:52 <ddarius> otters: You can define Const { php :: a } and save yourself two lines of code, and you can immediately generalize the IsString instance to all Monoids.
18:15:02 <ddarius> Er no.
18:15:14 <zzo38> How to make internet service handling multiple clients simultaneously, continuing to do something when data is received from any client?
18:15:26 <ddarius> You can generalize it to everything Showable but that would do the wrong thing with Strings.
18:15:53 <ddarius> zzo38: I'd recommend a receptionist.
18:15:54 <Saizan> to everything IsString
18:16:08 <otters> ddarius: Oh that's brilliant
18:16:15 <zzo38> ddarius: I mean doing with Haskell programming.
18:16:36 <hpaste> otters annotated “PHP string concat” with “PHP string concat (annotation)” at http://hpaste.org/73926#a73927
18:17:37 * ddarius clearly doesn't use OverloadedStrings much because he apparently forgets which way it goes.
18:17:44 <ddarius> Oh well, I had a 50/50 chance.
18:18:12 <Saizan> otters: does that last annotation typecheck?
18:18:15 * ddarius gets to see if his guest about how the unscented Kalman filter works is correct.
18:18:16 <otters> Actually, I don't think it does.
18:18:54 <ddarius> No, it loses the String, but if a is always going to be String you can just set it to that.
18:19:03 <otters> Set what?
18:19:09 <ddarius> a
18:19:33 <Saizan> you could instance a ~ String => IsString (Const a b c) where to remove ambiguity there
18:19:33 <ddarius> Also, parentheses work in patterns pretty much with the same rules that they have in expressions.
18:19:34 <otters> which one?
18:19:39 <mm_freak> edwardk: go on
18:20:09 <edwardk> mm_freak: oh the integration thing? got distracted =)
18:20:15 <otters> Oh jesus not the tilde
18:20:22 <johnw> @unpl (||) `on` (==)
18:20:22 <lambdabot> (on (||) (==))
18:20:59 <Saizan> got a bad experience with tildes?:)
18:21:12 <otters> yes
18:21:18 <otters> they scare me because I don't understand them
18:21:19 <mm_freak> edwardk: thought so…  yes, that thing
18:21:32 <mm_freak> edwardk: i'm interested in everything FRP =)
18:22:00 <mm_freak> comonadic FRP seems promising, but unfortunately signal inhibition is impossible for a comonad
18:22:06 <ddarius> otters: It's equality, but = wasn't really available.
18:22:14 <mm_freak> i'm very sure Wire is an Extend, but it's definitely not a comonad
18:22:24 <edwardk> not sure what you mean by that part
18:22:43 <edwardk> i do expect that there are a number of things you can't encode with the comonadic version
18:22:51 <edwardk> just like there are somethings you can't say with the monadic version
18:23:07 <mm_freak> do you know the wire arrow?
18:23:16 <otters> Then why doesn't it just let me define IsString (Const String b c)
18:23:19 <otters> or why does it get confused?
18:23:21 <zzo38> What is a wire arrow?
18:23:37 <ddarius> otters: Because => doesn't mean implication.
18:23:47 <mm_freak> here is a highly simplified variant of it:  newtype Wire a b = Wire (a -> (Maybe b, Wire a b))
18:23:59 <edwardk> yeah then you're screwed ;)
18:24:06 <edwardk> same problem i have in machines
18:24:11 <edwardk> i have a comonad for moore machines
18:24:15 <edwardk> but not for the general machines
18:24:18 <mm_freak> or you allow bottoms, but i don't want to
18:24:29 <Saizan> instance resolution is committed-choice, it only checks the RHS of => to pick the instance, and then tries what it can to satisfy the LHS
18:24:42 <edwardk> yeah thats a bad idea
18:24:45 <zzo38> mm_freak: I think it is definitely a Functor, is it a monad, is it a category, etc?
18:24:49 <mm_freak> you could probably construct a very weird comonad out of that by expecting that a wire must produce at some instant in the future
18:25:02 <zzo38> And is it a comonad?
18:25:10 <otters> ddarius: okay
18:25:11 <zzo38> Absolutely it is not a comonad.
18:25:15 <mm_freak> zzo38: it's Alternative, Applicative, Arrow, Category, Functor and a couple more
18:25:16 <zzo38> I can see that.
18:25:35 <mm_freak> you can't make it both a Comonad and an Alternative
18:25:36 <Saizan> but, btw, the restriction lifted by FlexibleInstances is an archaic one from a time people weren't sure what was implementable
18:25:40 <mm_freak> that's the main problem
18:25:46 <mm_freak> extract empty = ?
18:25:49 <zzo38> mm_freak: And yes I know that Comonad and Alternative are mutually exclusive.
18:26:05 <edwardk> yeah same problem with any attempt to make things both a monoid and an comonad
18:26:16 <zzo38> At first I didn't know if it was comonad or not but then I saw (Maybe b) it is obviously not comonad.
18:26:27 <edwardk> curious what properties you get when you break the other way though
18:26:40 <mm_freak> the type alone doesn't necessarily forbid it to be a comonad, if you place some assumptions
18:26:41 <edwardk> e.g. choose to support the comonad operations throughout
18:26:46 <mm_freak> but Alternative breaks those assumptions
18:27:05 <zzo38> I have realized a while ago that Alternative and Comonad are mutually exclusive.
18:27:45 <edwardk> i suppose when you dualize, the thing is you don't get to filter the outputs, but rather filter whether or not you want another input before you emit again
18:28:01 <edwardk> so you get the ability to emit multiple answers for everything you demand
18:28:09 <edwardk> (relative to the super simple model above)
18:28:17 <edwardk> of course in practice you probably already have both
18:28:22 <zzo38> As far I can see that Wire type cannot be a comonad.
18:28:26 <mm_freak> yeah
18:28:39 <mm_freak> newtype Wire a b = Wire (a -> (b, Maybe (Wire a b)))
18:28:46 <edwardk> zzo38: the wire he mentioned there is a placeholder for a more interesting type. we're talking about variants of it
18:29:04 <edwardk> no, it can't need the a to start
18:29:14 <mm_freak> yeah, true
18:29:23 <mm_freak> well…  wait
18:29:35 <mm_freak> no, forget it
18:29:38 <edwardk> it has to be Yield  b (Wire a b) | Await (a -> (b, Wire a b))
18:29:42 <mm_freak> i don't see a comonad there
18:29:54 <edwardk> or wait, even that fails
18:29:57 <mm_freak> yeah
18:30:02 <edwardk> got it
18:30:02 <mm_freak> extract (Await f) = ?
18:30:15 <edwardk> Yield b (Either (Wire a b) (a -> Wire a b))
18:30:29 <zzo38> mm_freak: extract (Await f) = fst (f mempty);
18:30:30 <edwardk> that is the correct dual
18:30:34 <edwardk> now you can await
18:30:35 <mm_freak> that could be a comonad, but now it's definitely not an Alternative
18:30:43 <edwardk> zzo38: that has very wrong semantics for what these do
18:30:43 <mm_freak> so it misses netwire's elegance
18:30:57 <edwardk> mm_freak: sure. you're trading the alternative for the comonad functionality
18:31:01 <zzo38> edwardk: You are probably correct.
18:31:02 <edwardk> just curious what that structure means =)
18:31:15 <mm_freak> well, it's just a stream
18:31:17 <zzo38> *Nothing* can be both Alternative and Comonad it can be proven.
18:31:25 <edwardk> zzo38: we know ;)
18:31:58 <edwardk> well, its a stream that in exchange for emitting something can request something, so it can only consume at most as much as it emits.
18:31:59 <zzo38> Can do-notation (in general, not only in Haskell) works with what categories? Does it work with Cartesian closed categories in general?
18:32:09 <mm_freak> let's talk about AFRP instead of generic FRP, because AFRP assumes a stream-based implementation just like netwire and yampa
18:32:10 <edwardk> thats an interesting rate limiting model
18:32:38 <mm_freak> but i guess i should give netwire's model a different name, because it isn't really AFRP
18:33:04 <mm_freak> it started out as AFRP, but now AFRP is just a remote base model =)
18:33:09 <Tordek> https://gist.github.com/3509609 how can I convert "readContents l" into "readContents l c" so that I can do "readContents size ',' >>= return . S" ? Also, please mention any corrections you think relevant
18:33:39 <edwardk> hrmm that turns into a moore machine you could drive in parallel with other moore machines with the choice of 'left' being explicitly opting out of its input, which could be used to save work over a traditional moore machine
18:34:10 <mm_freak> well, there is another way to do it
18:34:16 <mm_freak> produce regardless of inhibition
18:34:27 <edwardk> sure
18:34:39 <mm_freak> but as long as it's a Category it won't be a Comonad
18:34:49 <edwardk> ?
18:35:03 <mm_freak> unless you provide a default input, TracedT-style
18:35:05 <mm_freak> or StoreT-style
18:35:07 <edwardk> the category and comonad work together for mealy
18:35:09 <edwardk> er moore
18:36:02 <mm_freak> what i mean is:  you could have:  data Behavior a = Behavior a (Behavior a)
18:36:11 <edwardk> i suppose you could adapt a wire to be a comonad, by requiring an output at all points possibly separate from what it has or is emitting
18:36:12 <mm_freak> that's the simplified non-Category variant
18:36:16 <mm_freak> but it's not very powerful
18:36:21 <edwardk> sure
18:36:40 <mm_freak> you could, but i think that would lead to a very weird mixture of Category and Comonad laws
18:36:42 <zzo38> mm_freak: Would that be a kind of infinite list?
18:36:50 <mm_freak> zzo38: yes
18:36:53 <mm_freak> zzo38: a stream
18:37:07 <zzo38> Why did you call it "Behavior", does it have different instances?
18:37:15 <mm_freak> zzo38: the basis for AFRP is ZipStreams
18:37:26 <edwardk> zzo38: its a rather traditional name for it in FRP
18:37:36 <mm_freak> in a /very/ simple AFRP model Behavior = ZipStream
18:37:49 <mm_freak> with the same Applicative instance as ZipList, but only for infinite lists
18:38:06 <zzo38> I think it could be a monad too
18:38:19 <zzo38> Just as ((->) Natural) can be a monad too
18:38:21 <mm_freak> yes, if you're willing to accept unconditional time leaks
18:38:28 <ivanm> yay for trying to debug a value generated by QC that fails a test, where the value is 175000+ characters long :s
18:38:35 <rosie> What's a good way to convert from Float to String?
18:38:43 <mm_freak> rosie: show, printf, …
18:38:49 <mm_freak> > printf "%8.2f" 3.34
18:38:50 <shachaf> rosie: That depends on what behavior you want.
18:38:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:38:51 <lambdabot>    `Text.Printf.PrintfType ...
18:38:51 <ivanm> @hoogle Float -> String
18:38:51 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
18:38:51 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
18:38:52 <lambdabot> Prelude show :: Show a => a -> String
18:38:56 <rosie> mm_freak: ah, of course, thanks
18:38:58 <mm_freak> > printf "%8.2f" (3.34 :: Double)
18:38:59 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:38:59 <lambdabot>    `GHC.Show.Show a'
18:39:00 <lambdabot>      a...
18:39:01 <edwardk> zzo38: https://github.com/ekmett/machines/blob/master/src/Data/Machine/Type.hs#L58 is more or less a souped up version of this
18:39:03 <mm_freak> > printf "%8.2f" (3.34 :: Double) :: String
18:39:04 <lambdabot>   "    3.34"
18:39:34 <edwardk> with https://github.com/ekmett/machines/blob/master/src/Data/Machine/Moore.hs and https://github.com/ekmett/machines/blob/master/src/Data/Machine/Mealy.hs being simple models you can compile to a more complex machine
18:39:55 <edwardk> ivanm: shrink? ;)
18:40:07 <ivanm> edwardk: somehow shrink failed to run, or at least run fully :s
18:40:18 <ivanm> but I think I've finally managed to work out where the problem is
18:40:23 <ivanm> now to try and work out how to fix it :s
18:40:23 <edwardk> make a custom shrink?
18:40:29 <edwardk> k
18:40:33 <ivanm> edwardk: it _is_ a custom shrink
18:40:45 <ivanm> but I have nfi how to tell QC "here's a value, try to shrink it and continue"
18:40:47 <mm_freak> zzo38: ZipStream is a diagonalizing monad…  the problem is that the diagonalization process will grow in complexity with every instant (every element of the stream), because (>>=)'s second argument is an opaque function
18:40:51 <rosie> What's the naming scheme for variables in ghci errors? e.g. the m0 and v0 in "Couldn't match expected type `Float' with actual type `m0 v0'"
18:41:06 <mm_freak> zzo38: i have tried for a long time to come up with a reasonable Monad instance for ZipStream, before i gave up =)
18:41:16 <mm_freak> s/reasonable/sensible/
18:41:42 <bobTBuilder> hey guys, do you know how to merge 2 lists into 1 list of tuples?
18:41:45 <zzo38> Certainly join would retrieve the diagonal I would think.
18:41:53 <bobTBuilder> I saw a function for this somewhere
18:41:56 <mm_freak> zzo38: same problem
18:41:56 <zzo38> While return would make it all elements same value.
18:41:58 <bobTBuilder> but now I can't find it
18:42:05 <zzo38> That is how I would define it.
18:42:08 <mm_freak> zzo38: you have to traverse the substream when you implement 'join'
18:42:36 <zzo38> mm_freak: Yes I know you do, but only as far as the element you want to receive it look like isn't it?
18:42:39 <edwardk> zzo38: getting the diagonal is expensive. you have to walk an average of n/2 steps along n completely separate streams
18:42:55 <ivanm> bobTBuilder: zip ?
18:43:03 <bobTBuilder> oh yeah
18:43:04 <bobTBuilder> thanks!
18:43:05 <ivanm> @hoogle [a] -> [b] -> [(a,b)]
18:43:06 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
18:43:06 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
18:43:06 <lambdabot> Test.QuickCheck.Modifiers shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
18:43:08 <mm_freak> zzo38: it's not hard to implement, but the time complexity for an instant will grow like O(t)…  in a typical FRP system you don't want that
18:43:18 <Pseudonym> @ft zip
18:43:19 <lambdabot> Done.
18:43:23 <Pseudonym> Erm.
18:43:26 <Pseudonym> @free zip
18:43:27 <lambdabot> $map ($map_Pair f g) . zip xs = zip ($map f xs) . $map g
18:43:34 <zzo38> mm_freak: O, I don't know much about FRP. But I can believe you.
18:43:47 <Pseudonym> What did lambdabot think I meant by ft?
18:44:11 <mm_freak> zzo38: it's simple:  asking for the first value takes 1 time, asking for the 10000th value takes 10000 time…  unconditionally!
18:44:12 <lambdabot> I thought you were an idiot. And it's rude to talk about robots in the third person.
18:44:27 <zzo38> mm_freak: I know that! But I still don't know much about FRP.
18:44:43 <mm_freak> zzo38: in FRP you want to be able to follow arbitrarily many instants =)
18:44:46 <otters> "frp" has the worst acronym because I can't take it seriously
18:44:49 <mm_freak> in O(1) time for each instant
18:44:56 <mm_freak> otters: why?
18:45:11 <Pseudonym> otters: You get XP for every element you pull from the stream.
18:45:15 <otters> "what are you working on?" "*frrrrrp* nothing"
18:45:21 <zzo38> mm_freak: Then you will need something else. You can do O(1) with ((->) Natural) but that might lack other features you need
18:45:26 <shachaf> Hey, Pseudonym is alive.
18:45:28 <Pseudonym> Oh, I thought you were referring to fantasy role playing.
18:45:33 <otters> Not really.
18:45:51 <Pseudonym> Yes, I'm alive.
18:45:53 <mm_freak> zzo38: it does =)
18:45:57 <Pseudonym> Sorry, in paper writing hell atm.
18:46:05 <ivanm> shachaf: why are you so surprised???
18:46:17 <ivanm> Pseudonym: did you receive any "gifts" from shachaf lately or something? :p
18:46:40 <Pseudonym> That sounds like am obscure cultural reference.
18:46:46 <mm_freak> zzo38: so far the best AFRP implementation i came up with is the wire arrow…  it's very powerful, but it's neither a monad nor a comonad
18:46:52 <mm_freak> it's an applicative functor and a category
18:47:10 <edwardk>  which are basically the properties i have in a processn ;)
18:47:14 <edwardk> er process
18:47:16 <Pseudonym> Aren't all applicative functors also categories?
18:47:27 <Pseudonym> Or did I dream that?
18:47:28 <zzo38> Pseudonym: No; the kind is different.
18:47:31 <edwardk> Pseudonym: they give rise to a static arrow category. different beast
18:47:32 <Pseudonym> Ah, of course.
18:47:39 <Pseudonym> Yeah, that's it.
18:47:50 <edwardk> just lie how every monad gives you a kleisli category/arrow
18:47:57 <edwardk> er like
18:48:02 <zzo38> Would you think the (CodensityAsk (Store s)) monad is useful for something?
18:48:29 <edwardk> now, when you adopt the wadler arrow calculus the 'every monad is an arrow' thing makes more sense directly
18:48:40 <zzo38> What is a wadler arrow calculus?
18:48:54 <Pseudonym> zzo38: It's the arrow notation that Haskell should have, but doesn't.
18:49:00 <ddarius> otters: They had the same problem with the Calculus of Constructions, but they solved that by creating Coq.
18:49:02 <edwardk> http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf
18:49:06 <otters> I see.
18:49:21 <Pseudonym> Coq solves a lot of problems.
18:49:32 <zzo38> I just know that there will be a Kleisli category from any monad on any category.
18:49:33 <mm_freak> and introduces new problems =)
18:49:37 <Pseudonym> :-)
18:49:44 <edwardk> the proof that it is equivalent to the traditional arrow calculus is insufficient though, as i recall
18:49:54 <zzo38> And that there are functors both ways.
18:50:39 <zzo38> edwardk: Why do you have everything HTML and PDF? PDF is not very good
18:50:40 <mm_freak> what's the name of a natural transformation from a functor to itself?
18:50:46 <shachaf> elliott suggests that if you have LEM, you can write fmap for (-> Bool)
18:50:52 <shachaf> That seems kind of strange.
18:51:08 <edwardk> zzo38: i didn't write the paper =P
18:51:15 <zzo38> mm_freak: I don't know.
18:51:29 <mm_freak> endotransformation? =)
18:51:40 <zzo38> mm_freak: That is what I thought of too, but I don't know.
18:52:09 <zzo38> edwardk: Well, OK.
18:52:33 <zzo38> Just usually I would prefer not to open more programs
18:52:43 <ddarius> edwardk: I don't know.  With a nick like edwardk, it's easy to see how someone could get confused.
18:53:19 <zzo38> I prefer to use plain text this way it require not open up a web browser or PDF reader or whatever; just use curl or wget or nc to retrieve a file.
18:53:37 <shachaf> (-> Bool) is still contravariant, after all.
18:53:47 <edwardk> alas the internet was not created with such considerations in mind ;)
18:53:54 <mm_freak> plaintext is not a good choice for math stuff…  you see that in mailing lists all the time
18:53:56 * hackagebot hoauth 0.3.5 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.3.5 (DiegoSouza)
18:53:56 <ddarius> shachaf: And yet there are covariant set functors.
18:54:01 <mm_freak> i prefer properly typeset equations
18:54:11 <zzo38> edwardk: Actually it was created with such considerations in mind; people just ignored it.
18:54:21 <ddarius> edwardk: I don't know.  Last time I checked, an HTML file was text.
18:54:22 <shachaf> ddarius: Right.
18:54:41 <edwardk> ddarius: zzo38 isn't happy unless he can get the data over gopher
18:54:45 <zzo38> If we do need typesetting there is DVI format which is what I use.
18:55:06 <zzo38> edwardk: Actually I don't care; I just want to get it without loading HTML and so on.
18:55:09 <mm_freak> zzo38: it's the year 2012…  just like i don't understand what people have against well designed GUIs, i don't get what people have against HTML mails or scientific PDFs
18:55:23 <mm_freak> nowadays we measure RAM in gigabytes
18:55:37 <ddarius> mm_freak: You are assuming zzo38 is people.
18:55:38 <edwardk> welp. i've given the link, and spent more time talking with you about the nature of the link than i'd cared to give the entire conversation.
18:55:47 <mm_freak> true
18:56:10 <Pseudonym> On the Internet, nobody knows you're not hoi polloi.
18:56:29 <zzo38> My computer has 224 MB RAM, but regardless of amount of RAM you have to load other programs and it can slow down by multitasking, and anyways you might be using RAM for other things too.
18:56:35 <mm_freak> or bill gates for that matter
18:56:38 <Kostya> I was programming in haskell for several days, and my programms have become pretty big, but I still use 1 to 2 lines in ghci interpreter.
18:56:48 <mm_freak> after all no reasonable computer program needs more than 640k RAM
18:56:52 <Pseudonym> My phone's memory is not measured in gigabytes. Nor is my netbook's.
18:56:54 <Kostya> I tried writing code in normal text editor, but the formatting was crap
18:56:56 <mm_freak> or was it 512k?
18:57:03 <Pseudonym> If I had a tablet, it probably wouldn't either.
18:57:05 <zzo38> Pseudonym: That is like what I mean!
18:57:14 <Kostya> is there any text editor that can highlight and format the code correctly for haskell?
18:57:23 <zzo38> Of course more RAM would be better, since some things require a lot of RAM, and some things require a lot of speed, too.
18:57:31 <zzo38> But that isn't the point.
18:57:33 <Pseudonym> Dynamic RAM uses battery.
18:57:39 <mm_freak> Kostya: most programming editors do that by now
18:57:49 <mm_freak> Kostya: i think most people use emacs or vim
18:57:55 <Pseudonym> My netbook's memory is measured in gigabyte, not gigabytes.
18:58:19 <shachaf> Mine is measured in square gigabytes per hour.
18:58:20 <Kostya> do I have to install plug-ins additionally
18:58:35 <Kostya> or do they work automatically?
18:58:44 <Kostya> I think this is a great time to learn to use Vim at last!
18:59:10 <zzo38> (Of course, using HTML, PDF, and whatever other things you use (even DVI) requires the software for that!)
18:59:30 <Pseudonym> Nice!  Garbage collector in 600 lines.
18:59:42 <ddarius> PDF is also a semi-textual format...
18:59:45 <zzo38> I happen to like vi, although the syntax highlighting sometimes works badly so I turn it off.
18:59:58 <zzo38> ddarius: Yes I know, I have seen it. But it is no good.
19:00:51 <Cale> Kostya: In my experience, most programming editors will be okay, as long as you can replace tabs with spaces automatically. (Most of them have halfway-okay syntax highlighting)
19:01:06 * liyang prefers to format code manually.
19:01:22 <Pseudonym> To me, "manually" means punched cards.
19:01:30 <Cale> But that said, I use vim
19:01:35 <zzo38> I also prefer to format code manually (not with punched cards, though).
19:01:38 * ddarius congratulates edwardk.
19:01:47 <edwardk> ?
19:02:07 <Cale> (I don't use it much differently from how I'd use most text editors though.)
19:02:08 <zzo38> (If I do use punch cards at least I would write it on something else first before punching the cards, since punch cards cannot be cleared once set)
19:02:09 <Pseudonym> The dirty non-partisan secret of programming is that it doesn't actually matter which editor you use, as long as you know it very well.
19:02:25 <Cale> You don't even have to know it all that well.
19:02:26 <Cale> lol
19:02:27 * Kostya uses gedit, and thinks that vim, emacs and formatting code manually is badass.
19:02:28 <liyang> Follow https://github.com/tibbe/haskell-style-guide , read other people's code, decide on your own aesthetics.
19:02:41 <Pseudonym> Cale, clearly you're not paid by code deliverables.
19:02:48 <Kostya> thx for the link
19:02:52 <ddarius> The dirtier non-partisan secret of programming is that it doesn't actually matter which editor you use.
19:03:07 <Pseudonym> But there's a grain of truth there, in that other things dominate programmer productivity.
19:03:12 <Pseudonym> Like screen real estate.
19:03:16 <zzo38> Some people like layout syntax, other people hate layout syntax; I happen to hate layout syntax but you can use what you prefer. My only suggestion is that they shouldn't be mixed within one file since that can confuse things even more.
19:03:16 <edwardk> ddarius: did you see the zed shaw crapstorm over my galling use of single character type variables in scalaz?
19:03:24 <Philippa> ddarius: so long as it's not EDLIN
19:03:35 <ddarius> Philippa: What's wrong with EDLIN?
19:03:35 <Pseudonym> Or TECO.
19:03:39 <Cale> ?
19:03:44 <Kostya> cat perhaps?
19:03:51 <Pseudonym> cat - > a.out.tz
19:03:55 <Pseudonym> Err...
19:03:59 <Pseudonym> cat - > a.out.gz
19:04:06 <Philippa> ddarius: it's a tolerable text entry tool if you haven't got a punch card reader handy. It's a really shitty editor
19:04:15 <zzo38> If you are editing on a hard copy terminal, EDLIN might not be so bad.
19:04:17 <ddarius> Pseudonym: Surely, cat - > a.out.bz2
19:04:26 <shachaf> <adrake> I get severely creeped out every time I see a type variable with length != 1 <adrake> it feels so wrong <adrake> like you're making it less polymorphic or something by making the variable name meaningful
19:04:28 <Philippa> (and yes, it was my first editor)
19:04:34 <Cale> ed is the standard text editor!
19:04:46 <ddarius> edwardk: No, I don't generally follow Scala news.
19:04:53 <edwardk> yes, yes i am. and i use that as the excuse to grab the keyboard when i pair program ;)
19:05:25 <Cale> shachaf: pretty reasonable sentiment
19:05:33 <Philippa> there are times when a multi-char type variable makes good sense. But.
19:05:47 <Cale> (~>) makes a nice type variable sometimes
19:05:49 <Cale> :)
19:05:50 <Philippa> zomg, we expected m for monad to suffice!
19:05:50 <ddarius> Such as when programming in Miranda.
19:05:58 <edwardk> ddarius: basically the verbosity police came by and banged on the doors of scalaz. https://twitter.com/kmett/status/240944489731076096 was the last thing i posted before i walked away from it
19:06:07 <shachaf> Cale: Not as of GHC 7.6!
19:06:18 <Cale> shachaf: wat
19:06:23 <Pseudonym> Try to imagine type classes in Miranda.
19:06:38 <Pseudonym> fmap :: (* -> **) -> (*** * -> *** **)
19:06:45 <edwardk> Pseudonym: hahaha
19:07:11 <Kostya> how to paste code in vim on the same line?
19:07:30 <Philippa> edwardk: butbutbut jobs!
19:07:47 <Cale> Kostya: Paste from an external source or from inside vim?
19:07:54 <Kostya> inside
19:07:59 <edwardk> Philippa: =)
19:08:10 <Kostya> for example I got 2 lines, and I want to put one of them, in the middle of the other
19:08:23 <Kostya> I use v to highlight, and p to paste
19:08:31 <Kostya> but then it pastes on new line :(
19:09:13 <Cale> Maybe select the text with the mouse in visual mode before yanking with y
19:09:22 <Cale> and then move to where you want it and press p?
19:09:35 <Cale> you can also use v and arrows
19:09:41 <ddarius> P?
19:09:43 * Kostya thinks he is too cool for the "mouse"
19:09:49 <Cale> (I use arrows in vim, haters gonna hate)
19:10:02 <Kostya> hjkl
19:10:13 <Kostya> Yeah, I succeeded at highlighting it
19:10:19 <nus> use ctrl-v for selections if you're so into visual mode
19:10:22 <Kostya> it's just that it pastes on a different line
19:10:29 <Cale> The only reason hjkl are used is tradition from a time when those keys had arrows on them
19:10:37 <Kostya> what's the difference between ctrl+v and v?
19:10:41 <geekosaur> don't yank a whole line
19:10:43 * ddarius uses both arrows and dhtn.
19:10:51 <Pseudonym> Kostya: ctrl. HTH.
19:10:52 <geekosaur> 0y$
19:11:06 <geekosaur> then go to your line and p, it should insert in the middle instead of adding a new line
19:11:19 <Kostya> I will try that!
19:11:50 <Kostya> it worked!
19:11:52 <Cale> Kostya: if you yank the newline at the end of the line, it'll paste that
19:12:00 <ivanm> I seem to recall there being a package that pretty-printed values (laying out records, lists, etc.)
19:12:05 <ivanm> anyone know what I'm talking about?
19:12:17 <Cale> You'll notice that you can select one character beyond the last when making the selection
19:12:25 <Cale> and that means you'll grab the newline
19:12:55 <Cale> ivanm: I assume you're not just talking about wl-pprint or something?
19:13:02 <ivanm> nope
19:13:08 <ivanm> hmmm maybe ipprint
19:13:38 <Cale> GenericPretty?
19:13:58 * ddarius actually finds it a bit odd how rarely he uses a debugger in any language nowadays.
19:14:14 * geekosaur thinks GenericPretty as well
19:14:42 <ddarius> Though I guess the only time I used a debugger reasonably extensively was when programming in assembly, but that's more like a repl.
19:14:51 <ivanm> I was hoping not to have to edit the source to derive something
19:14:54 <ddarius> That said, I rarely use repl.s
19:14:54 <Cale> Oh yeah, ipprint looks cool
19:15:24 <Saizan> i've started using a debugger recently instead, to prune unwanted choice points from prolog code
19:15:27 <Cale> ivanm: Yeah, the name led me to believe it would use Data.Generics
19:15:42 <Cale> but then when I looked closer it got more boring
19:15:43 <ivanm> I thought chrisdone had something for it but can't find what :/
19:16:54 <ivanm> oh, he's doing it within emacs
19:16:54 <Cale> http://hackage.haskell.org/package/data-pprint seems to actually use some generics
19:17:22 <shachaf> Cale: In GHC 7.6 ~> isn't a type variable, I think?
19:17:43 <Cale> shachaf: That's going to break so much arrow code that it hurts
19:18:26 <shachaf> Cale: http://www.haskell.org/pipermail/glasgow-haskell-users/2012-January/021611.html
19:18:33 <ddarius> type (~>) = Either
19:18:42 <Cale> ivanm: oh, this data-pprint is really clever
19:18:52 <ivanm> do I need to derive Generic?
19:19:46 <ivanm> yeah, I do *sigh*
19:19:57 <ivanm> that's a _lot_ of deriving statements to add :s
19:20:27 <zzo38> Do you know if (CodensityAsk (Store s)) would ever be useful monad?
19:20:31 <ddarius> There's a pretty printer that will pretty print the output of Show (assuming standard instances).
19:20:43 <ivanm> ddarius: that's what I'm trying to remember the name of
19:20:48 <shachaf> groom?
19:20:51 <ivanm> thought it might have been ipprint
19:21:04 <ivanm> shachaf: ahhh, that sounds right
19:21:08 <Cale> Why... do we not want to have infix type variables?
19:21:14 <rosie> Where can I find documentation on the naming scheme of variables in ghci errors? e.g. m0 v0
19:21:14 <Cale> I don't understand
19:21:28 <ivanm> rosie: it's part of the type checking stuff
19:21:35 <shachaf> rosie: It's just heuristics.
19:21:36 <ivanm> but does it really matter? *shrug*
19:21:57 <shachaf> m0/m1/... are "related" to m, but GHC just tries to pick a name that'll hopefully be helpful.
19:22:01 <shachaf> It changes between versions.
19:22:13 <rosie> shachaf: cool, thanks
19:22:14 <shachaf> (I preferred it when it didn't use numbers so much.)
19:22:32 <Pseudonym> Numbers get in the way of maths.
19:22:36 <joeyh> rosie: there was a nice article in the most recent edition of the Monad Reader that explained how errors are constructed in some detail, and has a lot of useful tips for reading them
19:22:52 <Cale> shachaf: Yeah, it used to be much more aggressive about trying to pick one-letter type variables first
19:22:54 <shachaf> "(t -> u) -> v t -> t u" is much more readable to me than "(t0 -> t1) -> t2 t0 -> t2 t1"
19:23:10 <shachaf> Er.
19:23:15 <shachaf> "(t -> u) -> v t -> v u"
19:23:31 <ddarius> Cale: It seems we could have our cake and eat it too with type (+) = Either.
19:23:51 <Cale> ddarius: indeed
19:24:13 <shachaf> We can either have our cake or eat it.
19:24:24 <ivanm> then again, maybe this value is too damn big to do pretty-printing on... *sigh*
19:24:38 <Cale> Also, I'm not sure we really want + at the type level stolen for Either
19:24:55 <DT`> :+:?
19:24:59 <Cale> What about type level numerics?
19:25:51 <parcs`> with KDNR, + can be both!
19:26:21 <Pseudonym> Cale: If you use Peano numbers, you can convince yourself that you're actually using ADTs rather than numbers.
19:26:47 <Cale> lol type level floating point
19:27:27 <Pseudonym> Even better, since NaN isn't a number.
19:27:40 <Saizan> error: expected type Foo NaN, inferred type Foo NaN
19:27:49 <Cale> ahahaha
19:28:04 <Pseudonym> Ah, but does NaN ~ NaN?
19:28:10 <Cale> clearly not
19:28:13 <ddarius> Type errors would be much more helpful if we gensymed type variable names from Encyclopedia Britannica.
19:28:29 <Pseudonym> I liked the forceful and yet evidence-free use of the word "clearly". Nice work.
19:29:12 <ddarius> Pseudonym: What do Prologs do?
19:29:21 <Pseudonym> ddarius: Inferred type (Functor barbarossa) => (brazil -> barbarossa brazil)
19:29:26 <ddarius> eq(X,X).  eq(0/0, 0/0)
19:29:33 <shachaf> Pseudonym: It depends on what's in the spare NaN bits.
19:29:46 <latro`a> ...type level spare bits
19:30:02 <Pseudonym> ddarius, that's a damn good question, actually.
19:30:14 <Pseudonym> Unification-equals isn't the same as numeric-equals.
19:31:17 <Cale> fmap :: (Functor aasvoel) => (aardvark -> aardwolf) -> (aasvoel aardvark -> aasvoel aardwolf)
19:31:46 <monochrom> I prefer alice, bob, charlie, etc
19:31:56 <Pseudonym> encrypt :: alice -> bob
19:32:12 <ivanm> @hoogle Monad m => m a -> m ()
19:32:12 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
19:32:12 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
19:32:13 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
19:32:18 <ivanm> @hoogle void
19:32:18 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
19:32:18 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
19:32:18 <lambdabot> package void
19:32:35 <Pseudonym> Foreign.Marshal sounds very law enforcement.
19:35:48 <latro`a> haskell has to keep C in line
19:36:18 <Pseudonym> The last thing I want in Haskell is inline C.
19:36:28 <latro`a> lol
19:36:34 <lpvb> inline asm?
19:36:44 <Pseudonym> Inline Python.
19:36:55 <Pseudonym> Closures don't matter, after all.
19:37:29 <lpvb> inline LOLCODE
19:37:54 * ddarius was actually envisioning entire sentences. the'variety'of'senses'that'logos'possesses'may'suggest'the'difficulties'to'be'encountered'in'characterizing'the'nature'and'scope'of'logic could not be unified with silica'deposits'such'as'flint'chert'and'the'abrasive'tripoli'originate'from'radiolarian'skeletons.
19:38:24 <mapreduce> The only thing you really need from C is goto.
19:38:40 * geekosaur thinks tht looks very old-skool perl, actually
19:38:40 <Pseudonym> GOTO: the ultimate LAMBDA
19:38:44 <shachaf> ddarius: That's horribly unreadable. Clearly what Haskell needs is spaces inside identifiers.
19:38:56 * hackagebot parsergen 0.2.0.3 - TH parser generator for splitting bytestring into fixed-width fields  http://hackage.haskell.org/package/parsergen-0.2.0.3 (JasperVanDerJeugt)
19:39:09 <geekosaur> (back when ' worked as a package separator instead of ::)
19:39:46 <otters> ::)
19:43:57 * hackagebot text-icu 0.6.3.5 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.6.3.5 (BryanOSullivan)
20:06:21 <rosie> What's a good way to keep the parameters of a many-parameter function straight?  e.g. it's a bit difficult to keep track of which variables refer to which parameters in the following: viewTemplate :: String -> [Html] -> [Html] -> Html -> Html -> Html -> Html -> Html -> Html -> String -> Html
20:08:39 <ddarius> rosie: There are a variety of options.  In this case it looks like you should be passing in a record containing most of the parameters.
20:08:55 <rosie> ddarius: thanks
20:16:05 <latro`a> possibly several records
20:16:36 <latro`a> that also depends on to what extent you're partially applying
20:16:54 <latro`a> for example I could see partially applying that function with just a String, or up to the very last argument, just based on its type
20:17:02 <latro`a> (as well as fully applying it, obviously)
20:17:24 <latro`a> by contrast it seems like it would be rather strange to truncate it partway through all those Html variables
20:18:57 * hackagebot filemanip 0.3.6.1 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/filemanip-0.3.6.1 (BryanOSullivan)
20:22:02 <lpvb> anyone know what the most expressive esoteric language is?
20:22:15 <EvanR_> c++
20:22:52 <monad> pascal
20:23:04 <latro`a> haskell, by a certain definition of esoterci
20:23:05 <latro`a> *esoteric
20:23:20 <EvanR_> agda
20:23:23 <tnks> I keep on forgetting the rationale for why existentials in Haskell use "forall" instead of "exists"
20:23:50 <latro`a> for why it is this way, or why this approach is equivalent
20:23:56 <tnks> I know it's about distributing a negation through the quantification.
20:24:05 <aristid> tnks: because forall is already there and can be used for it, if wrapped inside a data constructor?
20:24:09 <tnks> but I never /see/ it.
20:25:35 <tnks> sorry, not sure I understand.
20:26:24 <rosie> What's a good way to implement MVC design using haskell? When dealing with blaze-html, what's a good way to separate the controller from the view? I'm thinking I'll have a record that contains all the pieces of the page (e.g. data Template = Template { title :: String, headers :: [String], buttons [(String, AttributeValue, String)] } etc. The controller will populate this record. Then in the view, I'll have one function that takes in that
20:26:24 <rosie> record as the input, and it'll call many functions that convert e.g. a [String] to Html. Then I return the Html output to the controller. Sound like a plan?
20:27:40 <EvanR_> uhg mvc has come to mean something totally different thanks to the web frameworks
20:28:28 <ddarius> tnks: Vaguely related to negation, as negation can be defined as A -> False, it has to do with the continuity properties of the first argument of (->).
20:29:43 <tnks> ddarius: yeah, it's coming back to me.
20:30:03 <tnks> I think there's a simple one-liner that makes it viscerally clear.
20:30:15 <edwardk> heh i can't cabal install cabal-install while running the release candidate because of bounds on http. if i go to fix them the version of cabal i'm running generates a Path_HTTP file that contains references to 'catch' which is no longer exported by Prelude.
20:30:15 <tnks> it just slips me every time I look at it.
20:30:28 <ddarius> exists a. f a -> b ~ (forall a. f a) -> b
20:30:35 <tnks> thanks.
20:30:36 <ddarius> Er, sorry the other way
20:30:47 <ddarius> forall a. f a -> b ~ (exists a. f a) -> b
20:31:22 <tnks> thanks a lot.
20:33:58 * hackagebot snappy 0.2.0.2 - Bindings to the Google Snappy library for fast compression/decompression  http://hackage.haskell.org/package/snappy-0.2.0.2 (BryanOSullivan)
20:34:28 <rosie> Anyone have a good idea on how to implement the Model-View-Controller paradigm in haskell? (see last post for details)
20:35:03 <lpvb> anyone use Haskell on archlinux? is it better to install ghc and libraries through pacman or cabal?
20:35:21 <ddarius> Exercise: Look up the notion of "unbiased estimator" and, as a particular concrete example, "unbiased sample variance."  Under the typical assumptions (independent observations) and, also as usual, assuming you want to minimize the expected squared error, calculate the optimal estimator for variance (again, optimal means minimum expected squared error).  Compare that to unbiased sample variance.
20:36:02 <latro`a> ...???
20:36:31 <augur> boop
20:39:04 <Z`> Hi people. I'm reading the book.realwroldhaskell.org . In 'types and functions' says that once you assign a value to a variable, you can no longer change it.
20:39:42 <Z`> What is the difference between:
20:39:44 <Z`> x = 10
20:39:46 <Z`> x = 11
20:39:47 <Z`> and
20:39:49 <Z`> let x = 10
20:39:50 <Z`> let x = 11
20:39:51 <Z`> ?
20:40:55 <latro`a> let bindings don't exist at top level; they are local scope
20:41:26 <tnks> ddarius: so where's the implication in: data Counter = forall a. MkCounter a (a -> a) (a -> Int)?
20:41:28 <lpvb> x = let y = 10 in y
20:41:32 <pqmodn> Z`, the second example creates a new binding, shadowing the original. similar to (\x -> (\x -> ...) 11) 10
20:41:46 <tnks> I think that's why I keep on forgetting the rationale.
20:42:30 <ddarius> tnks: What is the type of MkCounter.
20:42:47 <hpaste> spark_ pasted “intervalFinder returns [] ALWAYS” at http://hpaste.org/73928
20:43:42 <spark_> Im having some problems here, I can't understand why my function returns always []
20:44:13 <ddarius> spark_: It's probably because you've written an inefficient version of const [].
20:44:24 <spark_> well, maybe
20:44:36 <spark_> but I thought I had guaranteed output for every guard
20:44:49 <shachaf> Is there a function for Data.ByteString like unconsn :: Int -> ByteString -> Maybe ([Word8], ByteString)?
20:44:59 <pqmodn> spark_: have you used QuickCheck?
20:45:21 <spark_> pqmodn: noot really
20:45:44 <spark_> pqmodn: hmm, i should do that, it probably has an instance for bytestring anyway
20:45:52 <shachaf> I can do something like foo (B.splitAt 3 -> Just ([...], rest)) = ...; foo (B.splitAt 3 -> Nothing) = ...
20:46:10 <shachaf> Or, rather (B.splitAt 3 -> Just ((B.unpack -> [...]), rest)) = ...; foo (B.splitAt 3 -> Nothing) = ...
20:46:13 <shachaf> But that's kind of annoying.
20:46:16 <pqmodn> spark_: writing instances for Arbitrary is quite easy. see the source code on hackage for reference
20:46:37 <spark_> pqmodn:  ok, thanks! I never tried quickcheck before, I def need
20:48:14 <tnks> ddarius: I want to say: exists a. a -> (a->a) -> (a->Int) -> Counter
20:48:34 <ddarius> tnks: You don't have to guess.  You can simply ask GHCi.
20:48:43 <tnks> that's true.
20:48:58 * hackagebot HDBC-mysql 0.6.6.1 - MySQL driver for HDBC  http://hackage.haskell.org/package/HDBC-mysql-0.6.6.1 (BryanOSullivan)
20:49:00 * hackagebot cognimeta-utils 0.1.0 - Utilities for Cognimeta products (such as perdure). API may change often.  http://hackage.haskell.org/package/cognimeta-utils-0.1.0 (PatrickPremont)
20:49:02 * hackagebot xdot 0.1 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.1 (DennisFelsing)
20:49:24 <shachaf> tnks: A nicer representation for Counter is (Nat -> Int), or Stream Int.
20:49:36 <shachaf> Or data Counter = Counter { val :: Int, next :: Counter }
20:49:49 <shachaf> Or many other things that don't involve existential types. :-)
20:50:07 <ddarius> shachaf: "Nice" depends on the fitness function being used.
20:51:47 <tnks> shachaf: that's fine.  I'm following along a recent redit Haskell post.
20:52:07 <tnks> it reminded me that I'm still confused about something I thought I'd understood earlier.
20:52:55 <tnks> ddarius: okay, so MkCounter appears to be universal
20:53:16 <tnks> MkCounter :: a -> (a -> a) -> (a -> Int) -> Counter
20:53:34 <ddarius> Add the explicit quantification and apply the isomorphism I menitoned above.
20:53:42 <applicative> spark, note that you presuppose that all lists of bytestrings havetwo elements.
20:54:05 <applicative> spark_: intervalFinder [B.empty,B.pack "hello"] doesn't yield []
20:55:07 <spark_> applicative: then I can't understand what happens. In my main function if i introduce it, I don't have output
20:55:18 <applicative> spark_: you havent decided what to do with the empty list of ByteStrings, or a singleton
20:55:34 <spark_> applicative: that's true
20:55:38 <applicative> are you thinking that 'otherwise' takes care of it
20:55:57 <spark_> shouldn't it ?
20:56:09 <spark_> The other patterns should never happen
20:57:15 <Clint> if it doesn't match (x:y:xs) those guards won't be relevant
20:58:05 <spark_> Clint: but if im sure the list is >3 , should i care?
20:58:10 <applicative> intervalFinder [B.empty,B.pack "hello"] is the second case; after the first step it has to find out what intervalFinder [] is, but thats  undefined
20:58:38 <spark_> applicative: hmmm
20:58:53 <spark_> ill fix that
20:59:02 <applicative> you need a line intervalFinder _ = = ((Bl.pack . B.unpack)                   ((B.pack("NEVER")))):[] that's not behind guards
20:59:30 <applicative> intervalFinder _ = ((Bl.pack . B.unpack)   ((B.pack("NEVER")))):[]
20:59:58 <applicative> that is the second pattern you deal with, the first is intervalFinder (x:y:xs)
21:00:23 <spark_> I see
21:02:14 <Z`> What is wrong with:    data BookInfo =  Book Intr String [String]  deriving (Show) ? I get a parse error on input `=' if I then write:   myInfo = Book 12345 "Algebra" ["Stathis", "lala"]
21:02:22 <Z`> er Int*
21:03:11 <applicative> Z`: this is probably due to an error on a previous line.  It was expecting more
21:03:53 <applicative> are you sure it compiles when you strike that line?
21:03:58 <Z`> hnm, how do you mean? Those 2 lines are the only lines in my ghci session.
21:04:12 <applicative> ah ghci
21:04:17 <tnks> ddarius: okay, I think I see it again, but i think it helps to think about the uncurried form of the type constructor.
21:04:19 <Z`> let me put that into a .hs file
21:04:20 <applicative> use let before myInfo
21:04:31 <applicative> let myInfo = Book 12345 "Algebra" ["Stathis", "lala"]
21:04:48 <Z`> duh. it worked. Thanks applicative :)
21:05:39 <ddarius> tnks: For you, I think it would be easiest to remember going the other way.  If we had an exists form, then an existential would just be data S = S (exists a. f a) where clearly S :: (exists a. f a) -> S.  Then apply the isomorphism to get forall a. f a -> S.
21:06:08 <ddarius> Also using GADT syntax helps.
21:16:54 <Tordek> https://gist.github.com/3509609 how can I convert "readContents l" into "readContents l c" so that I can do "readContents size ',' >>= return . S" ? Also, please mention any corrections you think relevant
21:17:06 <Z`> oh boy that is a very boring book. I think I'll switch to a 'getnle introduction to haskell, v98'
21:17:17 <latro`a> tordek-- m >>= return . f = fmap f m
21:18:20 <Tordek> so "fmap S $ readContents size ','"?
21:18:25 <latro`a> yeah
21:18:35 <latro`a> I don't know what monad that is
21:18:40 <Tordek> parser
21:18:46 <latro`a> but very nearly every standard library monad has a Functor instance already
21:18:49 <latro`a> if not you can write it
21:20:19 <latro`a> yeah I don't know what count is
21:20:26 <Tordek> anything "unhaskelly" or ugly that jumps out from the code?
21:20:27 <latro`a> which seems important to be able to answer your question
21:20:42 <latro`a> lack of signatures (though the signatures might be ugly in which case I understand)
21:20:51 <Tordek> count is from Parsec
21:21:11 <latro`a> you can match key on S key_value
21:21:12 <latro`a> instead
21:21:16 <latro`a> that is
21:21:24 <latro`a> S key_value <- value
21:21:27 <latro`a> (might need parens idr)
21:21:46 <latro`a> since you already do it irrefutably you may as well
21:22:20 <latro`a> pair can also be a liftM2
21:23:08 <ddarius> latro`a: You don't need parentheses.
21:23:16 <startling> hi, what date/time format should I use if I want good compatibility with reading and writing to and from (Byte)Strings flexibly?
21:23:17 <latro`a> k
21:23:35 <startling> these are user-reported times and dates; I just need to be able to order them, not deal with leap years/seconds
21:24:01 <Tordek> *TParser> :t readContents
21:24:02 <Tordek> readContents
21:24:02 <Tordek>   :: Text.Parsec.Prim.Stream s m Char =>
21:24:03 <Tordek>      Int -> Text.Parsec.Prim.ParsecT s u m [Char]
21:24:12 <Tordek> latro`a: ^ if it helps?
21:24:29 <latro`a> right, but that doesn't really
21:24:39 <latro`a> you want to add an argument, but that requires restructuring
21:24:41 <latro`a> in some way
21:24:45 <latro`a> and I'm not familiar with the lib
21:24:52 <Tordek> it takes an int k, and parses k characters into a string, here
21:24:57 <Tordek> ok
21:25:18 <latro`a> what does the new character do
21:26:19 <Tordek> it's an attempt at simplification, since I'm always doing "readcontents ... char"
21:26:39 <latro`a> oh, oh
21:26:41 <latro`a> that's easy then
21:27:00 <latro`a> well....no, actually, because of what comes after it
21:27:19 <latro`a> just those two is easy, but you need the result from readContents
21:27:36 <latro`a> and since order matters you can't just flip them either
21:28:07 <Tordek> this may be a stupid idea anyway, so don't worry too much
21:28:20 <latro`a> I suppose you can do readContents l c = c >>= (\r -> char c >> return r)
21:28:56 <latro`a> and then returnbut then, you're also always returning a constructor on the result
21:29:03 <latro`a> so that makes these a one liner
21:29:07 <Tordek> although I believe there may be an optimization possibility there, because for each type, I read k chars, and it it's the wrong type, I undo it
21:29:17 <latro`a> readContents l c f = c >>= (\r -> char c >> return (f r))
21:29:44 <latro`a> then parseString' l = readContents l ',' I . read
21:29:46 <latro`a> erm
21:29:49 <latro`a> (I . read)
21:29:50 <Tordek> I wonder if there's a way to do "lookahead nth char", that could help
21:30:13 <latro`a> that might be a good idea here actually
21:30:14 <Tordek> parseInteger', you mean?
21:30:20 <latro`a> woops
21:30:23 <latro`a> read one and then the other
21:30:34 <latro`a> parseString' l = readContents l ',' S
21:30:45 <latro`a> parseInteger' l = readContents l '#' (I . read)
21:30:45 <latro`a> etc.
21:31:17 <ddarius> What the heck are you talking about?
21:31:25 <Tordek> potatoes
21:31:34 <latro`a> he wanted to refactor this code, to have less repetition
21:31:41 <latro`a> this is a way to do it
21:31:58 <ddarius> Yes, but if he wants r <- readContents l; char c; return r, just write that.
21:32:10 <latro`a> 's the same thing
21:32:19 <applicative> startling: http://hackage.haskell.org/package/time-http uses bytestring and text. Can't say if it's any good
21:32:30 <latro`a> "just write it in do notation" for small examples isn't really a thing, imo
21:32:40 <ddarius> readContents l c f = c >>= (
21:32:53 <latro`a> woops, meant l >>=
21:32:59 <latro`a> or something similar
21:33:01 <ddarius> readContents l c f = c >>= (\r -> char c >> return (f r)) is hardly the same thing.
21:33:01 <latro`a> bah, tired
21:33:26 <latro`a> readContents' l c f = readContents l >>= (\r -> char c >> return (f r))
21:33:28 <latro`a> is what I meant
21:33:40 <Tordek> also, I'm asking not only for refactoring but anything that looks stupid
21:33:42 <latro`a> this is straightforward to write in do notation if preferred, obviously
21:33:59 * hackagebot pcap 0.4.5.2 - A system-independent interface for user-level packet capture  http://hackage.haskell.org/package/pcap-0.4.5.2 (BryanOSullivan)
21:34:01 <Z`> I'd like to implement a 'head-like' function that returns the 1st element of a list or an empty list if an empty list is given. What would the type signature of the function be ? myHead :: [a] -> a   isn't enough to describe it
21:34:26 <ddarius> That's better.  I would just write: readContents' l c = readContents l <* char c; and for what you are writing, I'd probably just explicitly write: S <$> readContents' l ','
21:34:27 <latro`a> you can't have it return an empty list, because then it's not well-typed
21:34:28 <Tordek> Z`: you can't.
21:34:53 <latro`a> but you can write a "safe head" that returns Maybe, or returns a singleton list or else an empty list
21:34:59 <latro`a> the former already exists, and is called listToMaybe
21:35:00 <parcs`> [a] -> Either [b] a
21:35:14 <Z`> a ha. new keyword. thanks! I'll look them up
21:35:23 <latro`a> the latter is easy enough to write; head' [] = []; head' (x:_) = [x]
21:35:44 <latro`a> there's a maybeToList, right?
21:35:50 <latro`a> :t maybeToList
21:35:51 <lambdabot> forall a. Maybe a -> [a]
21:36:02 <latro`a> so head' = maybeToList . listToMaybe also works
21:36:45 <ddarius> Tordek: Writing try all over the place is not a good thing to do. You do probably want try, but you should push them into the functions to make them atomic things so you don't have to keep writing them everywhere.  You could optimize by combining parseString', parseInteger', and parseFloat' together, though, unless l is big, it's probably not worth it.
21:37:06 <Jafet> head' = take 1
21:37:13 <latro`a> ^touche
21:37:23 <latro`a> easy to forget that take is safe
21:37:29 <rosie> Anyone have a good idea on how to implement the MVC paradigm in Haskell (using blaze-html)?
21:37:43 <ddarius> Tordek: Also, use choice.
21:37:51 <Tordek> choice?
21:37:55 <ddarius> @hoogle choice
21:37:55 <lambdabot> Text.ParserCombinators.ReadP choice :: [ReadP a] -> ReadP a
21:37:56 <lambdabot> Text.ParserCombinators.ReadPrec choice :: [ReadPrec a] -> ReadPrec a
21:37:56 <lambdabot> Text.Parsec.Combinator choice :: Stream s m t => [ParsecT s u m a] -> ParsecT s u m a
21:38:29 <Tordek> oh, goodie
21:38:35 <dibblego> head'' :: Simple Lens [a] a
21:40:47 <Tordek> choice (map try [ parseNull size, parseBool size, ...]) <?> "format suffix"
21:42:26 <ddarius> Tordek: Really what you want to do with this parser is make a stack machine (or equivalent) and interpret it as a postfix language.
21:42:43 <ddarius> I don't think the size field matters except for strings (except as a cross-check).
21:42:45 <avartanian> @help
21:42:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:43:28 <Tordek> ddarius: http://i.qkme.me/353xnp.jpg
21:43:52 <avartanian> pl \x -> x+x+x
21:43:57 <avartanian> @pl \x -> x+x+x
21:43:57 <lambdabot> (+) =<< join (+)
21:43:59 * hackagebot riak-protobuf 0.16.0.1 - Haskell types for the Riak protocol buffer API  http://hackage.haskell.org/package/riak-protobuf-0.16.0.1 (BryanOSullivan)
21:44:36 <latro`a> join then fmap then join, interesting
21:44:52 <avartanian> @pl \f g x y -> f x (g y)
21:44:52 <lambdabot> flip . ((.) .)
21:45:09 <South> Hello!
21:45:21 <latro`a> @pl \f g x -> f x (g x)
21:45:22 <avartanian> South Hello!
21:45:22 <lambdabot> ap
21:45:25 <latro`a> cute
21:45:31 <Tordek> ddarius: there are some edge cases where the size is relevant, like "100:123#asdfsdfsadf," would be misparsed as a number if you ignored the size
21:45:31 <dibblego> (<*>)
21:46:00 <ddarius> Tordek: Because it's a string.
21:46:02 <dibblego> \\@pl "join then fmap"
21:46:05 <dibblego> (=<<)
21:46:20 <avartanian> @pl \f g x y z -> f x y (g z)
21:46:20 <lambdabot> flip . ((flip . ((.) .)) .)
21:46:23 <ddarius> Tordek: I think (but I don't know the whole spec) that the string case is the only one where there is ambiguity.
21:46:38 <Tordek> ddarius: actually, it isn't, because the length is invalid ;P
21:47:14 <ddarius> This format does seem intended for random access, not streaming access.
21:47:44 <ddarius> ("more for" I should say)
21:47:47 <Tordek> yeah, it was an odd decision to postfix the format, imeo
21:47:53 <Tordek> imo
21:47:53 <dibblego> avartanian: liftA2 (<*>) with some flipping
21:48:13 <latro`a> :t liftM2 (<*>)
21:48:14 <lambdabot> forall (f :: * -> *) a b (m :: * -> *). (Applicative f, Monad m) => m (f (a -> b)) -> m (f a) -> m (f b)
21:48:20 <latro`a> huh
21:48:40 <latro`a> oh, derp
21:49:01 * hackagebot riak 0.7.0.1 - A Haskell client for the Riak decentralized data store  http://hackage.haskell.org/package/riak-0.7.0.1 (BryanOSullivan)
21:50:22 <spark_> can i have guards in lambda?
21:50:23 <avartanian> I lack the IQ to dream up the stuff @pl comes up with.
21:50:29 <Cale> > 226 * atan (tan (355/226)) :: CReal
21:50:31 <lambdabot>   -354.9999397112932718925574046211676518285603
21:50:34 <Cale> ^^ wat
21:50:50 <shachaf> avartanian: @pl is very mechanical.
21:50:52 <shachaf> Cale: ?
21:51:05 <Cale> Note the type
21:51:10 <latro`a> > 226 * atan (tan (355/266)) :: Double
21:51:11 <lambdabot>   301.6165413533834
21:51:14 <Cale> heh
21:51:18 <ddarius> Tordek: I think the only way to parse this format without random access/multiple passes is to essentially parse it as if nothing was a string, but remember the strings you are building up in case you do hit a ','.  With laziness you could probably get this where you aren't actually doing much work if it does turn out to be a string.
21:51:20 <spark_> > (\a-> |a>5 ="yes"; |a<5 ="no") 5
21:51:21 <lambdabot>   <no location info>: parse error on input `|'
21:51:22 <johnw> today i learn to read (f .) . g as (\x -> (f . g) x y).  But I'm still not sure I'd ever use it
21:51:24 <latro`a> > 226*355/266
21:51:25 <lambdabot>   301.61654135338347
21:51:26 <johnw> sorry, \x y
21:51:29 <latro`a> um
21:51:34 <latro`a> why did the CReal implode
21:51:44 <avartanian> shachaf Well then I don't have the IQ to recover the rules it must be using :)
21:51:46 <Cale> you replaced a 2 with a 6
21:51:56 <Cale> > 226 * atan (tan (355/226)) :: Double
21:51:57 <lambdabot>   -354.9999397112933
21:52:01 <johnw> Cale: on a RAM disk, my parser is down to 10s.  That's better than 1 Gb/s
21:52:09 <Cale> johnw: nice
21:52:10 <johnw> GB/s
21:52:11 <latro`a> oh
21:52:15 <latro`a> > tan (355/226)
21:52:16 <lambdabot>   -7497258.179140373
21:52:27 <ddarius> @google 10s in GB/s
21:52:29 <lambdabot> http://www.vistax64.com/windows-updates/281736-hdd-space-decreasing-everyday-10s-gbs-without-me-having-downloaded-anything.html
21:52:33 <latro`a> > atan (tan (355/226))
21:52:34 <lambdabot>   -1.570796193412802
21:53:07 <Cale> oh, of course
21:53:12 <Cale> lel
21:53:49 <Cale> > 226 * atan (tan (355/226)) + 226 * pi :: CReal
21:53:50 <lambdabot>   355.0
21:53:51 <latro`a> atan is right half plane right
21:53:55 <latro`a> yeah
21:53:55 <Cale> there we are :)
21:54:01 <johnw> actually, if I think of the "." at each level as an elided argument, then (f .) . g taking two arguments makes sense, and ((f .) .) . g would take three arguments
21:54:18 <shachaf> johnw: Yes, but please don't write that. :-(
21:54:18 <latro`a> yup
21:54:25 <Cale> > 226 * atan (tan (355/226)) + 226 * pi :: Double
21:54:26 <lambdabot>   354.99999999999994
21:54:31 <johnw> (((why .) .) . ever . not)?
21:54:40 * latro`a implodes
21:54:41 <Tordek> ddarius: I'm not quite sure how to go about doing that
21:54:45 <johnw> @pl (((why .) .) . ever . not)?
21:54:45 <lambdabot> (line 1, column 28):
21:54:45 <lambdabot> unexpected end of input
21:54:45 <lambdabot> expecting white space or simple term
21:54:48 <johnw> @pl (((why .) .) . ever . not)
21:54:48 <lambdabot> ((why .) .) . ever . not
21:54:54 <johnw> lol
21:55:39 <ddarius> Tordek: Well there's a question of what you want to optimize for.
21:55:56 <ddarius> And also the properties of the input you intend to handle.
21:57:05 <Cale> or, more simply
21:57:27 <Cale> > (atan (tan (355/226)) + pi) * 226 :: CReal
21:57:29 <lambdabot>   355.0
21:57:33 <Cale> > (atan (tan (355/226)) + pi) * 226 :: Float
21:57:34 <ddarius> Yay "r_r(k)"
21:57:34 <lambdabot>   355.00003
21:58:08 <Tordek> ddarius: I actually don't mind too much about details like those, since this is just to play about with Parsec
21:58:10 <Cale> > (atan (tan (355/226)) + pi) * 226 :: Double
21:58:11 <lambdabot>   355.0
21:58:12 <latro`a> > 1 + 10**(-10000) :: CReal
21:58:13 <lambdabot>   1.0
21:58:16 <latro`a> hrm
21:58:22 <latro`a> CReal has a strange Show, then?
21:58:30 <latro`a> > 1 + 10**(-1000) :: CReal
21:58:31 <lambdabot>   1.0
21:58:34 <latro`a> > 1 + 10**(-100) :: CReal
21:58:35 <Cale> latro`a: It uses showCReal 100 or something
21:58:35 <lambdabot>   1.0
21:58:40 <latro`a> > 1 + 10**(-50) :: CReal
21:58:41 <lambdabot>   1.0
21:58:41 <Cale> or, not 100...
21:58:44 <latro`a> > 1 + 10**(-30) :: CReal
21:58:45 <lambdabot>   1.000000000000000000000000000001
21:58:48 <latro`a> there we go
21:58:52 <Tordek> I just want to see if any of that is "clearly un-haskell-like" or
21:58:55 <Cale> > pi :: CReal
21:58:56 <lambdabot>   3.1415926535897932384626433832795028841972
21:59:02 <Cale> > length "1415926535897932384626433832795028841972"
21:59:04 <lambdabot>   40
21:59:06 <Cale> 40 :)
21:59:33 <shachaf> CReal also has a "strange" Eq.
22:01:15 <Cale> Well, it has a semidecidable Eq
22:01:28 <Cale> if it had the correct one
22:01:54 <johnw> Cale: mind if I mention you in a blog article about this parsing adventure?
22:02:01 <Cale> I don't mind
22:02:20 <Cale> heh, did I actually manage to help?
22:02:28 <johnw> quite a lot
22:02:54 <Cale> I'm still not totally sure what was causing your program to be so slow before.
22:03:33 * Tordek is interested in johnw's code, if that's available
22:03:42 <johnw> well, the blog article explains it in depth :)
22:03:47 <Tordek> and/or the article, when posted :D
22:03:52 <johnw> it all came down to strictness in the wrong places
22:04:52 <Cale> I can imagine that being the case
22:05:03 <Cale> It's sad that the profiler gave such bizarre results
22:06:18 <Cale> I think the new way that the profiler treats cost centres might actually be a lot worse than the old way, I had a bad experience with it too, though for a very different reason. On the program where I was using it, it gave meaningful data, but the .prof files were *ridiculously* large.
22:07:27 <ddarius> Disk is cheap.
22:07:32 <Cale> cale@ender:~/Work/bloodknight$ ls -l gameBenchmark.prof
22:07:32 <Cale> -rw-r--r-- 1 cale cale 40788019 2012-03-07 23:00 gameBenchmark.prof
22:07:37 <Cale> ^^ rofl
22:08:25 <Cale> cale@ender:~/Work/bloodknight$ wc gameBenchmark.prof
22:08:26 <Cale>   279399  2234959 40788019 gameBenchmark.prof
22:08:54 <oneb> > (sqrt ((pi :: CReal)^2)) == (pi :: CReal)
22:08:55 <lambdabot>   True
22:08:58 <Cale> Searching through combinatorially large prof files for the bits of information you want kinda sucks
22:11:34 <johnw> on a RAM disk the C++ parser only improved by 20%
22:11:40 <johnw> the Haskell parser improved by 2.5x
22:11:47 <johnw> egrep hardly changed
22:12:05 <johnw> (the Haskell code is now 6x faster than a straight egrep)
22:12:11 <dylukes> What?
22:13:53 <ddarius> egrep is very likely optimized for disk access.
22:14:29 <johnw> it makes me think that locale conversions are happening
22:14:43 <johnw> that it's not a regexp against straight bytes.  plus, it has to hunt for newlines
22:15:10 <MostAwesomeDude> I have a type: data Dir = Up | Down; -- and I would like to have a [Dir] which has only Ups or Downs. In order to make that list, I want to take a list of many Ups and Downs, and cancel out each Up with each Down until only a number of either remain.
22:15:28 <MostAwesomeDude> Is there something stupidly simple that I have forgotten about in base for doing this?
22:15:59 <johnw> you can certainly split the list
22:16:01 <johnw> partition?
22:16:04 <MostAwesomeDude> I was just gonna partition, count, and then take the difference.
22:16:06 <johnw> and then sum to the two result lists
22:16:10 <johnw> yep :)
22:19:00 <ddarius> sum . map (\x -> case x of Up -> 1; Down -> -1)
22:19:53 <johnw> how well does Parsec on plain ByteStrings compare with Attoparsec?
22:19:58 <MostAwesomeDude> Yeah, and then I need to turn it back into Ups or Downs. Or maybe I could make a better datatype.
22:20:48 <ddarius> johnw: It depends what you are going for. Parsec is more powerful and flexible in many ways, but it is intended for complex grammars, not for data shoveling.
22:24:38 <startling> haha, data shoveling
22:24:40 <startling> that's great
22:30:34 <Cale> http://johncarlosbaez.wordpress.com/2012/04/24/enormous-integers/ -- this is amusing
22:37:37 <johnw> ok, here is the blog entry:
22:37:38 <johnw> http://newartisans.com/2012/08/parsing-with-haskell-and-attoparsec/
22:45:33 <Cale> http://christianmarks.wordpress.com/2010/05/25/mathematical-logic-finds-unexpected-application-on-wall-street/ -- now I've heard everything :D
22:45:35 <Cale> lol
22:47:28 <deggis> johnw: that was a nice read
22:51:11 <Cale> johnw: Are you going to post that to the programming reddit?
22:55:06 <mikeplus64> ddarius: (assuming a Enum instance where fromEnum Up = 1
22:55:09 <mikeplus64> \]]
22:55:13 <mikeplus64> oops premature return key
22:55:28 <mikeplus64> and fromEnum Down = -1, just sum . map fromEnum
22:57:21 <Z`> when one writes:     Branch :: Tree a -> Tree a -> Tree -> a
22:57:31 <Z`> should I read it with left-associativ-eness?
22:57:34 <ddarius> mikeplus64: Yes, but writing that Enum instance is more effort than passing the lambda and makes a fairly arbitrary decision globally.
23:08:13 <shachaf> unsafeCoerce should be able to coerce between WordN and WordM in GHC, right?
23:09:41 <ddarius> Read the docs for unsafeCoerce.
23:13:16 <Z`> mm anyone knows what's wrong with this http://paste.lisp.org/display/131329
23:14:07 <shachaf> Z`: You don't need to specify the signatures.
23:14:26 <shachaf> Those are correct but you can't just write them like that.
23:14:43 <Z`> yeh, I've read that it is 'good tactic', because they serve like documentation or so
23:14:47 <Z`> ah
23:14:48 <shachaf> You can do it using a GADT if you want, i.e. data Tree a where { Leaf :: ...; Branch :: ... }.
23:15:15 <shachaf> Z`: That advice is generally for regular top-level values, not constructors.
23:15:20 <Z`> So, data Tree a = Leaf a | Branch (Tree a) (Tree a) would be enough ?
23:15:35 <shachaf> The data declaration is probably good enough as far as type-documentation.
23:15:49 <Z`> Interesting.
23:15:57 <Z`> Thanks shachaf
23:19:30 <Cale> I've always thought it might be nice to be able to give type signatures of arbitrary expressions at the top level.
23:19:41 <Cale> and have them checked / provide information to the typechecker
23:20:03 <avpx> Seems reasonable
23:20:40 <avpx> Cale: I also can't see what I'd use this for
23:22:42 <ddarius> Cale: You can do that just by declaring type auxillary declarations.
23:24:35 <ddarius> In fact, unit/quickcheck tests will already accomplish that typically.
23:27:57 <johnw> Cale: I suppose I could
23:29:14 <nobdraisentone> Is it ok that some hackage packages don't exist on new-hackage?
23:38:04 <Z`> http://paste.lisp.org/display/131330
23:38:25 <Z`> Any help on to descrypt the error message?
23:39:06 <avpx> Z`: It's because main has type IO (), and fringe myTree has type [a]
23:39:35 <Z`> a ha
23:39:47 <scshunt> Z`: if you want to print it, putStr $ show $
23:39:54 <scshunt> or putStrLn
23:40:07 <avpx> Except that won't exactly work, because there's nothing to suggest that a provides a Show instance
23:40:18 <avpx> Oh wait
23:40:20 <avpx> <-- derped
23:40:42 <Z`> Show how could print the result of fringe myTree as if I was doing that in ghci ?
23:40:55 <avpx> scshunt explains it
23:41:12 <lpvb> show converts your list into a string
23:41:17 <avpx> If you want the elements line-by-line, I like mapM_ (putStrLn . show) . fringe $ myTree
23:41:19 <lpvb> putStrLn prints it to the console
23:41:24 <avpx> But that requires mapM_ from Control.Monad
23:41:49 <Z`> and the surrounding dollar signs ?
23:42:16 <scshunt> ($) is function application
23:42:19 <scshunt> f $ g is f g
23:42:24 <scshunt> but $ has much lower precedence
23:42:24 <Z`> neat. thanks
23:42:45 <avpx> It's the precedence that really matters here
23:42:47 <scshunt> $ in fact has the lowest precedence available, while normal application has high precedence
23:42:48 <lpvb> $ means the part after that acts like it's in parenthesis
23:42:58 <scshunt> so it's common to do f $ g h instead of f (g h)
23:43:18 <Z`> if you wrote f g h it would be like (f g) h ?
23:43:24 <startling> Z`: yep
23:43:32 <avpx> We often write code like f . g . h $ x, rather than f (g (h x))
23:43:33 <Z`> alright, thanks
23:43:59 <Z`> it worked...!
