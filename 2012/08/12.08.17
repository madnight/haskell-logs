00:01:03 <n00b6502> is it possible to have a function that gets the Nth element of an M element tuple where N<M
00:01:18 <shachaf> Yes, but you don't want it.
00:01:44 <n00b6502> this might sound hacky but..
00:02:18 <n00b6502> if the same named component of struct elements is in the same place,  i was considering making an accessor by location
00:02:35 <shachaf> I don't know what you mean.
00:02:45 <n00b6502> this is another idea oops
00:03:53 <n00b6502> if i want several struct's to have an element called 'name'
00:04:11 <n00b6502> what are the workarounds
00:04:40 <n00b6502> other than manually prefixing the name... mdlName,   scnName etc
00:05:03 <n00b6502> whats the recomended way of doing this in haskell-land
00:05:31 <shachaf> I don't know what a struct is.
00:05:40 <shachaf> Oh, I see.
00:05:48 <shachaf> No, the short answer is that you can't do that.
00:05:57 <shachaf> Haskell records aren't that great. Just prefix it.
00:06:02 <shachaf> (But see also lenses.)
00:07:29 <n00b6502> ah i can't even have an overloaded function...   name x y z = x               name x y =x            name x y z w = x
00:07:52 <n00b6502> (i wondered if i could have a workaround where i always put it in the same slot)
00:08:22 <n00b6502> supposedly you can fix it with a typeclass ?
00:08:36 <n00b6502> but thats probably more hastle than prefixing
00:08:50 <n00b6502> its funny because it reminds me of records in ASM
00:09:03 <n00b6502> where you just had literals for offsets
00:09:11 <n00b6502> at least there you could have a sort of single inheritance
00:09:43 <n00b6502> rsreset        name rw 1   or whatever
00:12:57 <mm_freak> lenses can help there
00:13:00 <mm_freak> have a type class
00:13:16 <mm_freak> class HasName a where name :: Lens a Name
00:13:20 <shachaf> You don't want to use a tpe class.
00:13:27 <shachaf> That's not what they're for. :-(
00:13:59 <mm_freak> i think n00b6502 has to figure that out by himself =)
00:14:04 <edwardk> i don't really mind a bit of ad hoc overloading, but if the type signatures get too far out of whack it gets silly
00:14:39 <edwardk> HasFoo is typically a very productive abuse of overloading where lenses are concerned
00:15:00 <shachaf> _1 is maybe vaguely justified because fst doesn't have that much meaning in the first place.
00:15:12 <shachaf> HasFoo in general seems like a big hack, though.
00:21:05 <mm_freak> shachaf: well, that big hack is used in snap
00:21:16 <mm_freak> it doesn't feel too much like a hack
00:21:29 <mm_freak> it's just a use case of type classes that doesn't encode a design pattern
00:21:58 <mm_freak> unfortunate maybe, but not a hack
00:22:04 <mm_freak> a hack would be trying to emulate OOP using type classes
00:55:31 <mm_freak> ConstraintKinds is very useful as a convenience with associated types
00:56:08 <mm_freak> type Effectful m a = (SomeClass a, ClassMonad a ~ m)
00:56:20 <jupiter234> Hi, Haskell newbie here
00:56:29 <mm_freak> hi there jupiter234
00:56:43 <jupiter234> I am trying to parallelise a mod operation
00:56:53 <jupiter234> using Control.Parallel's par function
00:57:45 <jupiter234> module Bench (doesDivide) where
00:57:47 <jupiter234> import Control.Parallel
00:57:48 <jupiter234> doesDivide :: (Integral a) => [a] -> [a]
00:57:50 <jupiter234> doesDivide a = [x | x <- a, mod x 1593 == 0]
00:58:05 <jupiter234> and then I call this code in Module Bmain:
00:58:15 <jupiter234> module Main (comp, main) where
00:58:16 <jupiter234> import Bench
00:58:18 <jupiter234> import Control.Parallel
00:58:19 <jupiter234> comp = par (doesDivide [3000000001..4500000000]) (doesDivide [1500000000..3000000000])
00:58:21 <jupiter234> main = print comp
00:58:41 <jupiter234> Compiled as: ghc Bmain.hs --make -threaded -rtsopts
00:59:02 <shachaf> -O2 :-(
00:59:08 <shachaf> But that's completely not how you use par.
00:59:14 <jupiter234> then?
00:59:45 <jupiter234> -02 : I deliberately avoided that
00:59:58 <shachaf> @google how to use par in haskell
01:00:00 <lambdabot> http://www.haskell.org/ghc/docs/7.0.3/html/users_guide/lang-parallel.html
01:00:00 <lambdabot> Title: 7.18.�Concurrent and Parallel Haskell
01:00:12 <shachaf> jupiter234: What are you even expecting that program to print?
01:00:28 <shachaf> A (++) of the two lists?
01:00:46 <jupiter234> factors of 1593 from the given range
01:01:12 <shachaf> Which range?
01:01:26 <shachaf> You should look at simonmar's slides on this.
01:01:35 <jupiter234> [3000000001..4500000000] & [1500000000..3000000000]
01:01:50 <shachaf> http://community.haskell.org/~simonmar/slides/cadarache2012/
01:01:57 <shachaf> "&"?
01:02:05 <shachaf> You should read about what par does. :-)
01:02:08 <n00b6502> i'll stick with prefixing names for the timebeing.
01:02:33 <jupiter234> & implying 'and' in english :)
01:03:01 <jupiter234> as I understand par takes two arguments that can be computed in parallel
01:03:51 <shachaf> There are several things you're not considering, including what par does and what laziness. You should look at those slides. :-)
01:04:05 <jupiter234> fair enough
01:04:10 <jupiter234> let me see
01:04:37 <n00b6502> 'hasName...' perhaps i just wanted a map in the firstplae
01:04:39 <n00b6502> fristplace
01:05:40 <n00b6502> hmmm.
01:06:54 <n00b6502> in C++ terms, map<name, object> objects;  instead of vector<object> with object.name
01:09:33 <n00b6502> [([String],object)]
01:10:37 <n00b6502> feels weird to have to do that but..
01:10:54 <n00b6502> maybe less weird than prefixing.
01:12:29 <kanedank> what's the difference between <- and =? I want to say that <- allows for the value of a variable to be updated, but I know haskell prevents that.
01:13:41 <ion> Do you mean in do notation? It
01:13:45 <ion> 's just syntactic sugar:
01:14:03 <ion> @undo do { a <- foo; b <- bar; baz }
01:14:03 <lambdabot> foo >>= \ a -> bar >>= \ b -> baz
01:14:17 <ion> It expands to that.
01:15:06 <sp3ctum> kanedank, in a monad, if you write value <- action; the action is ran and you get the value in the name "value"
01:15:36 <sp3ctum> if you write value = action; the action is not run but is instead bound to the name "value", and can be ran later with result <- value
01:16:06 <typoclass> kanedank: roughly speaking, = assigns while <- unwraps and then assigns. this concerns monadic functions such as getLine, which has type "IO String". with "let x = getLine", x would have type "IO String", with "x <- getLine" it would be "String". <- is only available in do blocks. there's some more subtlety to it, but that's the gist
01:16:24 <sp3ctum> ^ yes
01:16:37 <ion> Unwrap is a misleading word. There's no String in an IO String to unwrap.
01:16:41 <typoclass> (um, for "unwrap" you can also read "execute")
01:17:19 <typoclass> ion: yeah, i was going with the "monads as containers" view. not so sensible here
01:18:03 <ion> > do a <- [100,200,300]; b <- [1,2,3]; return (a + b)
01:18:05 <lambdabot>   [101,102,103,201,202,203,301,302,303]
01:18:18 <ion> > do a <- [100,200,300]; let bs = [1,2,3]; b <- bs; return (a + b)
01:18:19 <lambdabot>   <no location info>: parse error on input `<-'
01:18:29 <ion> > do a <- [100,200,300]; let { bs = [1,2,3] }; b <- bs; return (a + b)
01:18:31 <lambdabot>   [101,102,103,201,202,203,301,302,303]
01:20:00 <mm_freak> sp3ctum: that's a /very/ unfortunate way to explain it
01:20:06 <mm_freak> "<-" does not run anything
01:20:35 <mm_freak> also "=" does not assign
01:20:38 <sp3ctum> mm_freak, it executes a function that gets the value inside the monad
01:20:41 <mm_freak> it introduces an equation
01:20:48 <mm_freak> sp3ctum: no, it doesn't
01:21:11 <Ralith> nothing like that at all
01:21:28 <Ralith> it's probably best not to explain things to others until you are familiar with them!
01:21:38 <mm_freak> sp3ctum: the whole do-notation is just syntactic sugar for a pure description of whatever the monad denotes
01:21:46 <mm_freak> even in case of IO no "running" is done
01:22:02 <Automorphism> do { x <- f ; g x } is simply "f >>= g", right?
01:22:07 <mm_freak> Automorphism: yeah
01:22:23 <mm_freak> note that 'f' is not a function, so naming it 'f' may be misleading
01:22:36 <Automorphism> True.
01:22:38 <mm_freak> i usually name these things 'c'
01:22:46 <statusfailed> Why not 'zoidberg'?
01:22:58 <jupiter234> does main module always require print?
01:23:08 <Automorphism> jupiter234, whut, no
01:23:10 <mm_freak> jupiter234: huh?
01:23:11 <sp3ctum> mm_freak, so your point is i shouldn't call bind "running"?
01:23:16 <mm_freak> sp3ctum: yes
01:23:33 <typoclass> mm_freak: what would you call it, in the IO monad?
01:23:41 <mm_freak> binding?
01:23:49 <ion> IO actions are pure values that describe actions that the runtime system can execute if you assign the action into "main". IO monad's >>= combines two IO actions into a new IO action.
01:24:05 <ion> s/assign/bind/ rather
01:24:06 <mm_freak> when you have "x <- c", then x becomes the name of the result of c
01:24:29 <mm_freak> in that sense "<-" binds monadic values to names in the sense of (>>=)
01:25:21 <mm_freak> sp3ctum: notice that monads are DSLs…  you can model IO as a big GADT, i.e. entirely purely
01:25:39 <sp3ctum> i agree :). "running" was an oversimplification
01:25:46 <mm_freak> not even a simplification
01:25:49 <mm_freak> it's just plain wrong
01:26:05 <edwardk> mm_freak: ping
01:26:08 <mm_freak> edwardk: pong
01:26:11 <edwardk> heh
01:26:17 <ion> ion: pang
01:26:18 <kanedank> sp3ctum, typoclass: thank you! those definitions are really helpful
01:26:33 <edwardk> mm_freak: you might find https://github.com/ekmett/machines amusing
01:26:48 <edwardk> very much a work in progress
01:26:59 <jupiter234> But when I try Main without print, I get: Couldn't match expected type `IO t0' with actual type `[t1]'
01:27:02 <statusfailed> kanedank: if you're trying to understand the <- still, try rewriting your code just with >>=
01:27:05 <sp3ctum> kanedank, np. also note that apparently my explanation is misleading but i think it should get you started
01:27:07 <statusfailed> it's fugly but it helped me understand
01:27:27 <typoclass> mm_freak: you say "x becomes the name of the result of c". i don't see much difference between this and saying "runs c and assigns the name x to the result". afaik "assign" is commonly used to mean "introduce a name and bind something to it", and "result" hints that a computation will go on that produces something
01:28:15 <statusfailed> I kinda have to agree with typoclass :P
01:28:31 <sp3ctum> me too
01:28:37 <mm_freak> edwardk: nice =)
01:28:41 <statusfailed> What about "x <- c gives the name x to the parameter of the function bound to c"?
01:28:45 <statusfailed> :P
01:28:55 <Automorphism> Function bound to c?
01:29:07 <typoclass> (and i think the word "running" is okay when talking about the IO monad. what else is the rts supposed to do when it sees "getLine" or whatever ...)
01:29:09 <Automorphism> Maybe "monad" bound to c".
01:29:15 <statusfailed> Automorphism: 'cos it desugars to 'c >>= \x -> ' right?
01:29:33 <Automorphism> statusfailed: Yes, but c is not (guaranteed to be) a function.
01:29:42 <edwardk> mm_freak: basically you build plans for a machine using a monad, construct machines (that can take multiple inputs) compose them with (.) and other combinators, tie off various inputs with capL, capR, or supplying, and then run the resulting machine to get your answers (with demand-driven side-effects)
01:29:50 <statusfailed> Automorphism: c is a monad isn't it?
01:29:56 <Automorphism> statusfailed: Yep.
01:30:05 <mm_freak> typoclass: that doesn't really play well with some monads…  consider Cont and RState…  running does not happen at the point of "<-"
01:30:12 <typoclass> i thought c was a monadic action
01:30:15 <sp3ctum> jupiter234, main must return something in IO
01:30:36 <Automorphism> statusfailed: This very confusion is why I prefer understanding monads in terms of return and join, instead of return and bind. :P
01:30:39 <typoclass> mm_freak: yes, but with a newbie question like that, he's unlikely to be working with Cont or RState. he must be talking about IO
01:30:50 <statusfailed> Automorphism: what's join? :|
01:31:01 <mm_freak> edwardk: interesting, but i don't really need mealy machines…  i'm doing FRP, so i really need wires
01:31:07 <statusfailed> ooh, mealy machines!
01:31:08 <statusfailed> I need those
01:31:13 <n00b6502> translating a fileparser for a scene... my C++ method is imperatively consuming a string and appending to variouslists
01:31:19 <edwardk> mm_freak: erm, most of the machines aren't mealy
01:31:23 <Automorphism> @type join
01:31:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:31:29 <mm_freak> typoclass: that description however will mess his intuition up to the point where people believe that "monads allow IO"
01:31:40 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Type.hs#L55
01:31:41 <n00b6502> should i make some stateful monad to handle this?
01:31:51 <statusfailed> edwardk: executive summary of package? I need mealy machines where I can extract their state and save it
01:31:52 <jupiter234> sp3ctum, so is there no way I can only run the code without any output
01:31:57 <mm_freak> edwardk: i know…  i'm just saying that i have a very specific need and wires meet that need exactly
01:32:20 <edwardk> mm_freak: sure. not looking to replace your wires, just to point you at some new tricks ;)
01:32:35 <n00b6502> i guess if i restructure it a lot building some intermediate lists then my 'scene' is compposed of them i can avoid it
01:32:45 <jupiter234> I need to do that for profiling purposes and output unnecessarily garbles the screen
01:32:46 <mm_freak> edwardk: certainly nice…  i'm looking forward to the first release =)
01:32:59 <sp3ctum> jupiter234, you can do return ()
01:33:02 <edwardk> statusfailed: the mealy machines i supply are basically the newtype Mealy a b = Mealy (a -> (b, Mealy a b)) machines
01:33:14 <edwardk> statusfailed: i just provide a cheap way to lift them into my larger 'Machine' type
01:33:40 <edwardk> statusfailed: they are effectively infinite state machines, not readily serializable
01:33:47 <mm_freak> statusfailed: Mealy can't be serialized
01:33:53 <kanedank> if I said monads are closures in the sense that they execute function within a portion of the global state. Is that be wrong?
01:34:04 <mm_freak> kanedank: yes
01:34:05 <kanedank> sorry, meant ","
01:34:21 <kanedank> mm_freak: It's wrong?
01:34:26 <mm_freak> kanedank: yes
01:34:27 <ion> kanedank: yes
01:34:35 <kanedank> haha, okay, I'll go back to reading :P
01:35:05 <mm_freak> kanedank: monads in haskell are domain-specific languages, sometimes imperative (like IO)
01:35:19 <sp3ctum> they can model many other contexts besides IO too
01:35:28 <mm_freak> a good counter-example to your description is the list monad
01:35:31 <hiptobecubic> mm_freak, my life got a lot easier when i realized that connection.
01:35:40 <mm_freak> > do x <- [1..3]; y <- [4..6]; return (x, y)
01:35:42 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
01:35:49 <jupiter234> sp3ctum++
01:36:24 <typoclass> kanedank: if you change "monad" to "IO monad" in your question, you're getting closer
01:36:57 <ion> That doesn't describe the IO monad either.
01:37:08 <kanedank> mm_freak: are you saying that [] is a monad?
01:37:13 <kanedank> I thought it was a functor...
01:37:19 <ion> kanedank: All monads are functors.
01:37:32 <statusfailed> mm_freak: Mealy can't be serialized?!
01:37:40 <statusfailed> mm_freak: You mean in general, or those specific ones?
01:37:52 <kanedank> ion: but does that mean [] is a monad?
01:37:53 <mm_freak> kanedank: one way to summarize monads is to say:  a monad is a structure for which insertion and combination is safe, where combination means that you can refer to the "value" of one monadic value in another
01:38:08 <mm_freak> statusfailed: those specific ones
01:38:28 <mm_freak> kanedank: [] is a monad, thus it's also a functor
01:38:33 <mm_freak> the reverse is not true
01:38:39 <mm_freak> ZipList is a functor, but not a monad
01:38:49 <ion> kanedank: It means that return and (>>=) are defined for [].
01:38:51 <kanedank> ah, I didn't understand [] was a monad as well as a functor
01:38:53 <ion> @src Monad []
01:38:54 <lambdabot> Source not found. I am sorry.
01:39:02 <kanedank> what's an example of a pure functor? I thought [] was a pure functor
01:39:12 <hiptobecubic> ZipList?
01:39:14 <statusfailed> mm_freak: ok, right
01:39:21 <mm_freak> kanedank: it's unfortunate but related to the history of haskell that Functor is not a superclass of Monad
01:39:22 <ion> instance Monad [] where return a = [a]; as >>= f = concatMap f as
01:39:26 <mm_freak> normally it would be
01:39:33 <mm_freak> notice that for monads liftM = fmap
01:40:15 <n00b6502> if i have a traditional parser in C++ can i translate this into haskel directly using some sort of state monad
01:40:20 <DT``> and ap = (<*>), and return = pure.
01:40:23 <mm_freak> statusfailed: you can have a transparent, serializable description of automata, but then it won't be an Applicative
01:40:30 <n00b6502> while (header=consume(file)) { if (header=="foo") add foo to output else if ...  } return output
01:40:40 <mm_freak> statusfailed: or an Arrow for that matter
01:40:52 <kanedank> mm_freak: what does "safe" mean in your definition? and does your definition imply that monads can only be interacted with by other monads?
01:41:04 <ion> n00b6502: I guarantee it'll be nicer to use a parser library such as Parsec.
01:41:10 <mm_freak> kanedank: well, safe means total…  for example the 'head' function is nontotal
01:41:16 <mm_freak> > head []
01:41:17 <lambdabot>   *Exception: Prelude.head: empty list
01:41:24 <mm_freak> 'return' must be total for every monad
01:41:45 <kanedank> so monads must have an infinite domain?
01:41:45 <statusfailed> mm_freak: I'm gonna have to think about that, but I can sort of see why
01:41:46 <n00b6502> ion: i want to learn haskell aswell as simply get the file in
01:41:58 <mm_freak> kanedank: what does that mean?  again, monads are types
01:42:00 <kanedank> within their accepting types of course
01:42:08 <n00b6502> ion: the fact i dont know what the best way to write this now is ... troubles me
01:42:40 <mm_freak> kanedank: every monad gives rise to infinitely many types of course…  where IO is a monad, you have IO Int, IO String, IO (Int -> Int), etc.
01:42:52 <mm_freak> statusfailed: the reason is that you can't serialize functions
01:43:30 <mm_freak> statusfailed: the distributed-process package uses a hack to get around that, but that hack doesn't apply to automata
01:43:43 <mm_freak> i.e. cloud haskell
01:44:29 <mm_freak> there is also the simpler 'remote' package, but i think that one is more like a proof of concept…  you can see how the Closure type works there, which is basically a serialized function under certain assumptions
01:44:44 <quicksilver> mm_freak: "can't serialize functions" is a strong claim.
01:45:00 <mm_freak> ok, can't serialize functions in general
01:45:07 <mm_freak> ok, can't serialize haskell functions in general
01:45:08 <mm_freak> =)
01:45:13 <quicksilver> no even that. what is true, I think, is that a full serialization solution for functions would require RTS and compiler support which we don't have.
01:45:21 <quicksilver> however those things are possible and, even, have been done before.
01:45:35 <quicksilver> gdh, and yhcjs had two parts of the solution IIRC.
01:45:50 <mm_freak> given laziness that would seem to be very unsafe to me
01:45:56 <quicksilver> *shrug*
01:45:59 <quicksilver> you just copy the code
01:46:06 <quicksilver> or arrange for the code to already be present locally.
01:46:12 <quicksilver> it's just a case of programming :)
01:46:17 <mm_freak> which code?
01:46:34 <n00b6502> readNextBitOfScene (inputString, currentScene) -> (remainingString, updatedScene)
01:46:38 <n00b6502> but how to loop it
01:46:40 <mm_freak> i mean if that's serialization, then we already have it
01:46:44 <mm_freak> 'hint'
01:47:02 <n00b6502> while()... eek,imperative
01:47:05 <mm_freak> but i rather thought about something like:  (a -> b) -> String
01:47:36 <n00b6502> ah tail recursion ... silly me
01:47:55 <mm_freak> n00b6502: that really looks like a parser monad
01:48:23 <n00b6502> mm_freak: perhaps i have to write it without a monad first
01:49:18 <n00b6502> then see how a monad makes it easier
01:50:30 <mm_freak> well, to answer your question, i'd just recur
01:50:54 <n00b6502> ok;
01:51:38 <n00b6502> ok .. if i try to do this with "a parser monad"... do you suggest library code..
01:51:55 <n00b6502> i think i've got to go through seeing how this all works peice by peice
01:52:08 <mm_freak> well, whenever you have a function like X -> (A, X) you have a potential application for State
01:52:24 <mm_freak> newtype State s a = State (s -> (a, s))
01:52:50 <mm_freak> now imagine that s = InputString
01:53:08 <mm_freak> readNextBitOfScene :: Scene -> State InputString Scene
01:53:43 <mm_freak> that's a very basic parser monad…  to use something more powerful you can have a look at parsec
01:54:15 <mm_freak> the homepage has a comprehensive tutorial
01:55:20 <n00b6502> really basic question. is the monad a language feature, or just a pattern using functions...
01:55:43 <edwardk> n00b6502: 90% a pattern.
01:55:46 <flux> well, in principle it's a pattern, but the language has the 'do' blocks to facilitate their use
01:55:53 <edwardk> n00b6502: there is some very minor language support for 'do' sugar
01:56:13 <n00b6502> is the IO 'monad' instrinsic aswell (via the main.. )
01:56:15 <quicksilver> mm_freak: the actual excutable code that the thunk points to.
01:56:30 <quicksilver> mm_freak: (and recursively .. all the code pointers in the transitive closure of the function)
01:56:44 <mm_freak> quicksilver: but then at least you would need IO
01:56:45 <sp3ctum> n00b6502, main is always IO
01:56:52 <mm_freak> serialization would become effectful
01:56:54 <n00b6502> sure
01:57:18 <mm_freak> edwardk: that language support isn't really "minor" in fact
01:57:24 <quicksilver> mm_freak: not if the RTS does it for you.
01:57:36 <edwardk> mm_freak: well, it didn't exist for a long time, and it can be rebound to other types
01:57:42 <quicksilver> mm_freak: it's denotationally pure
01:57:45 <quicksilver> it's just an RTS feature
01:58:18 <mm_freak> quicksilver: you're saying that serializeFunction :: (a -> b) -> String would be a pure function using thunk serialization?
01:58:26 <quicksilver> no.
01:58:38 <quicksilver> that's obviously not referentially transparent.
01:59:01 <quicksilver> but you can conceive of higher level functionality - like distributed programming - which uses this RTS feature and remains pure.
01:59:39 <mm_freak> quicksilver: of course that's possible, but i wouldn't call that serialization…  i'd expect a serializer to allow me to save stuff to a file
01:59:50 <mm_freak> in application code that is
02:00:59 <mm_freak> n00b6502: yes, IO is intrinsic
02:01:16 <mm_freak> execution can't be observed within haskell, unless you use unsafePerformIO
02:01:30 <quicksilver> mm_freak: sure. And you might expose it that way too, and once you're writing to a file you're in IO anyway.
02:01:48 <quicksilver> mm_freak: and you might also make it available for transparent suspend/resume of entire applications
02:02:25 <mm_freak> quicksilver: i don't know, it just feels wrong…  notice how 'serialize :: (a -> b) -> IO String' could give two different strings
02:02:40 <mm_freak> and that string would depend on execution context
02:02:56 <mm_freak> you would end up serializing the entire node graph to make this safe
02:04:59 <ksf> I'd really like a record system in which I could say "take this ADT, but with all instances of type Foo replaced by Bar (here's the function to do that)".
02:05:18 <mm_freak> ksf: where Foo is a type?
02:05:22 <ksf> yep.
02:05:31 <mm_freak> ksf: you have that…  generic programming
02:05:37 <mm_freak> see uniplate and friends
02:05:45 <ksf> uniplate can change types?
02:06:01 <kanedank> what's the point of the $ symbol here: return ((toUpper . head $ inpStr) == 'Y')
02:06:24 <mm_freak> ksf: not sure, i i'd say yes
02:06:25 <ksf> kanedank, parenthesis around (toUpper. head)
02:06:31 <ksf> syb can't.
02:06:33 <mm_freak> kanedank: f $ x = f x
02:06:55 <mm_freak> ksf: syb has found itself replaced by uniplate mostly
02:06:57 <sp3ctum> kanedank, $ is function application. it applies the function on its left side to the value on the right side
02:07:04 <ion> kanedank: IMO it makes that piece of code worse. return ((toUpper . head) inpStr == 'Y')
02:07:19 <lpvb> kanedank: first toUpper and head are composed so toUpper(header(blank)) then $ fills the blank with inpStr
02:07:21 <sp3ctum> kanedank, easy way to think of it is f $ x == f(x), so it can replace parentheses
02:07:44 <ion> lpvb: ಠ_ಠ
02:07:47 <mm_freak> ($) is defined that way
02:08:14 <mm_freak> import Prelude hiding (($)); f $ x = f x
02:08:21 <mm_freak> (and please don't write f(x)) =)
02:08:29 <shachaf> What ion and mm_freak said.
02:08:37 <adnam> what everyone said
02:08:52 <kanedank> ion: okay, that makes it clear, for some reason I was translating it in my head as return ((toUpper . head inpStr) == 'Y')
02:09:09 <ksf> looking at http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm, uniplate can't do type-changing traversals.
02:09:13 <mm_freak> kanedank: that would be a type error
02:09:19 <ksf> I'd be damn suprised if it could, anyway.
02:09:50 <mm_freak> ksf: that's weird actually…  gfoldl from Data.Data can actually change types
02:10:00 <ion> kanedank: Pattern matching the 'Y' from inpStr might be nicer than that expression. (YMMV)
02:10:57 <mm_freak> kanedank: perhaps syb/uniplate just don't provide the necessary combinators
02:11:01 <mm_freak> that was for ksf
02:12:16 <mikeplus64> why would one use mtl over transformers?
02:12:22 <ksf> ...basically, I want a functor for every single field in an ADT, and then compose those functors freely.
02:13:28 <ksf> it's doable, but the boilerplate is enormous and sadly utterly incompatible with uuagc.
02:14:25 <mm_freak> mikeplus64: it's a tradeoff
02:14:34 <mm_freak> mtl has a nicer interface, but is not standard haskell 2010
02:14:48 <danr> people use transformers? o_O
02:14:55 <mm_freak> danr: all the time, just not directly
02:15:01 <mm_freak> mtl is based on transformers
02:15:05 <edwardk> danr: mtl builds on transformers
02:15:11 <danr> yeah, I know that much
02:15:20 <danr> but... why use the transformers library directly?
02:15:21 <mikeplus64> i use transformers most of the time
02:15:25 <edwardk> danr: if i just need Data.Functor.Identity or something i just use transformers
02:15:27 <mm_freak> ksf: why don't you just write a generic fold for your type?
02:15:29 <mikeplus64> because i don't really see a need for mtl
02:15:35 <edwardk> if i need a single monad transformer, i may also use it
02:16:05 <mm_freak> mikeplus64: there is no /need/ for mtl
02:16:06 <edwardk> mikeplus64: the advantage of programming to the MTL is when you want to build combinators and you don't have a single monad in which it'll be running
02:16:11 <ksf> mm_freak, I don't have any problems folding over my type, I want to transform it into another, quite similar one without much boilerplate.
02:16:12 <mm_freak> it has a nicer interface, that's it
02:16:20 <mm_freak> mtl is a nice interface to transformers
02:16:31 <mikeplus64> edwardk: ah
02:16:34 <edwardk> its nice to be able to say some times, given state, and an environment i can do these things
02:16:43 <mm_freak> ksf: in that case generic programming is your best bet, but i can't answer your question
02:17:12 <mm_freak> mikeplus64: what edwardk said…  for example compare the types of 'get' in the two libraries
02:17:40 <mm_freak> you can use 'put' in ReaderT or ErrorT, when there is a StateT beneath
02:17:54 <edwardk> e.g. much of my code needs, say, localization settings, so i can make a lens that knows how to get those out of my state, put that in a class, and then any time i'm in a MonadState t m, where HasLocalization t holds, I can use my localization stuff
02:18:26 <mikeplus64> i more or less only use ReaderT, so i don't run in to that problem (but the more i know :))
02:18:34 <edwardk> i don't care if its a hand rolled monad that unboxes everything, Strict StateT, RWST, something buried 5 levels in a stack, etc.
02:18:52 <mm_freak> people actually use ReaderT?
02:19:09 <edwardk> another important thing about the classes is that when you write a new monad transformer, its nice to lift them over your monad transformer
02:19:10 <danr> mm_freak: all the time? :)
02:19:16 <mikeplus64> mm_freak: haha
02:19:39 <edwardk> so get and put, tell, ask, etc can work over your new transformer
02:19:54 <edwardk> speaking of which, i'd better go add those to PlanT ;)
02:20:01 <ksf> mm_freak, consider e.g. erasing an alternative out of a sum type.
02:20:10 <mm_freak> basically mtl saves me from having to write lift . lift . lift . lift . lift . lift . lift . lift . lift . lift . lift
02:20:11 <ksf> I *know* that it's not possible, I just wanted to complain :)
02:20:49 <mm_freak> ksf: well, it is, but template haskell is ugly =)
02:21:16 * hackagebot free 3.1.1 - Monads for free (EdwardKmett)
02:21:17 * hackagebot comonad 3.0.0.2 - Haskell 98 compatible comonads (EdwardKmett)
02:21:38 <mysticc> How to have cabal produce more than one executables ?
02:21:40 <mm_freak> yeah!
02:21:42 <mm_freak> thanks edwardk
02:21:43 <mikeplus64> edwardk: you're certainly a busy haskeller!
02:21:45 <mm_freak> FreeT finally =)
02:21:54 <edwardk> mikeplus64: =)
02:22:09 <mm_freak> mysticc: just add multiple Executalbe blocks
02:22:13 <mm_freak> Executable
02:22:15 <edwardk> mysticc: put in more than one executable section
02:22:20 <mysticc> ok thanks
02:22:52 <ksf> edwardk, planT? is that a haskell re-implementation of plan9?
02:23:22 <edwardk> ksf: heh, its just a monad for building up something like pipes, iteratees, etc.
02:30:49 <mm_freak> isn't there a way to update my system without having to stop working?
02:30:58 <mm_freak> update my system?  update my haskell packages of course =)
02:31:20 <ksf> do it with a different ~/.cabal and ~./.ghc
02:31:38 <ksf> or just use a new ghc version for it.
02:32:19 <kosmikus> or use NixOS :)
02:32:30 <mm_freak> how to do it with a different ~/.cabal and ~/.ghc?
02:32:47 <mm_freak> kosmikus: that's not something nixos can solve by itself, because it's about cabal, not my system package manager =)
02:34:32 <ksf> hmm cabal-install doesn't seem to have a --with-config option.
02:34:42 <ksf> you could use a different user, tohugh.
02:39:20 <xkb> hmm in my new os x install meta-x inserts the almost equal sign
02:39:32 <xkb> how do I return it to meta-x? (in emacs in iterm2)
02:40:30 <kosmikus> mm_freak: well, but nixpkgs supports an awful lot of Haskell packages out of the box, and it's not extremely difficult to add more (but yes, strictly speaking you're right)
02:47:38 <mm_freak> kosmikus: in most cases i'm not patient enough to wait for my distribution, when it comes to haskell packages =)
02:47:59 <mm_freak> no doubt that nixos is great, but right now i just don't have the time to switch
02:48:11 <mm_freak> because switching to nixos does cost some time
02:48:26 <kuribas> What does a # mean in a .lhs file?
02:48:35 <mm_freak> kuribas: nothing
02:48:37 <kuribas> I tried using # for markdown headers, but I got a syntax error.
02:48:45 <mm_freak> kuribas: you can't
02:48:50 <kuribas> Why?
02:49:25 <mm_freak> because GHC interprets hashes in .lhs files…  i don't know exactly why it does that, but yeah, it's a pain
02:49:45 <mm_freak> if you have only two levels of headers, you can underline using ===== or -----
02:50:10 <kuribas> Yeah, but I'd like three levels too...
02:50:18 <kuribas> Maybe it's some sor
02:50:32 <kuribas> Maybe it's for pragma's?
02:50:35 <LambdaDusk> I desperately need help
02:50:43 <mm_freak> yeah, that's possible
02:51:08 <mm_freak> LambdaDusk: are you the guy with the yampa question on SO?
02:51:22 <LambdaDusk> https://github.com/scan/ponyv/blob/master/src/Main.hs#L17 This creates an eternal loop eating up system resources
02:51:27 <LambdaDusk> mm_freak: Yes I am
02:51:30 <kuribas> Like {-# somepragma #-}
02:51:36 <mm_freak> LambdaDusk: sorry, i couldn't respond to your comment, because i don't have an account =)
02:52:02 <mm_freak> LambdaDusk: i wonder why it does that…  the switching version works in netwire and it has almost the same internal representation as yampa
02:52:08 <LambdaDusk> mm_freak: I didn't know you'd need one. Anyway, help me here before my forehead meets the desk edge?
02:52:13 <edwardk> ok, going to go get some sleep. night all
02:52:21 <mm_freak> night edwardk
02:52:48 <mm_freak> LambdaDusk: i could imagine that you need dSwitch instead of switch
02:52:52 <LambdaDusk> mm_freak: I wanted to give netwire a try but somehow the wiring with external sense and actuate is too different
02:52:53 <mm_freak> but it would be very weird
02:53:01 <LambdaDusk> mm_freak: I use dSwitch there
02:53:17 <LambdaDusk> bug in Yampa?
02:53:26 <ksf> sodium has the perfect outwards interface.
02:53:44 <LambdaDusk> isn't sodium monadic FRP?
02:53:54 <ksf> it's mostly applicative
02:54:31 <mm_freak> LambdaDusk: well, i can't imagine that it's a bug in yampa…  as far as i see it the only space leak is when you don't actually refer to the values
02:54:47 <mm_freak> ksf: most sensible FPR libraries are like that
02:54:59 <mm_freak> ksf: including netwire and reactive-banana
02:55:06 <killy9999> How is the type () pronounced?
02:55:18 <killy9999> I belive in Scala it is called a Unit
02:55:28 <killy9999> what's the Haskell name for it?
02:55:42 <merijn> killy9999: Unit
02:55:42 <LambdaDusk> unit
02:55:54 <killy9999> OK :)
02:55:55 <LambdaDusk> mm_freak:
02:56:21 <LambdaDusk> mm_freak: If you can help me writing the SDL interface, I could give netwire another try
02:56:48 <LambdaDusk> it looks very interesting, but I just don't get how/why some arrows behave the way they do
02:57:13 <mm_freak> LambdaDusk: well, i'm currently finishing netwire 4
02:57:30 <mm_freak> and i have already planned to write an SDL/GL interface, but you'd have to be patient
02:57:56 <LambdaDusk> mm_freak: Patience is not one of my strength when it comes to programming
02:58:23 <kosmikus> mm_freak: of course, I absolutely understand you don't want to switch; but regarding being up-to-date, you can just check the distribution data that's on Hackage, and I think that NixOS is currently likely to be distribution with the best Haskell support
02:59:54 <LambdaDusk> mm_freak: Also I don't know why I should rewrite it just because of a little bump on the road ^^
03:00:59 <bartavelle> is there a good explanation of when to use a monad, comonad, arrow or those weird data types ? When I lookup information on comonad or arrows, I get information on what they are, but no clue about why I would want to use them
03:01:41 <ksf> bartavelle, you use them when you notice that you reinvented them.
03:01:46 <typoclass> bartavelle: that's a good question
03:01:54 <bartavelle> ksf, about what I expected ...
03:01:56 <mm_freak> LambdaDusk: because arrow syntax makes it ugly =)
03:02:15 <mm_freak> LambdaDusk: anyway, i really don't understand why the switch wouldn't work
03:02:34 <LambdaDusk> mm_freak: Fork it, execute it, see it for yourself
03:02:34 <bartavelle> it seems that arrow are used when you are doing a "computation pipeline" over pairs of stuff, but I am unable to see why I would want to do that
03:02:36 <mm_freak> bartavelle: there is the typeclassopedia
03:03:02 <mm_freak> bartavelle: no, you use arrows when the pattern at hand is not a monad
03:03:23 <mm_freak> bartavelle: if you're interested, here is my (unfinished) arrow tutorial:  http://ertes.de/new/tutorials/arrows.html
03:03:33 <bartavelle> ah cool
03:03:43 <bartavelle> also I didn't know about the typeclassopedia
03:03:54 <mm_freak> LambdaDusk: if you're patient enough i'll try it as soon as my current installation process is finished =)
03:03:57 * killy9999 is reading typeclassopedia ATM
03:04:08 <LambdaDusk> mm_freak: Well all right
03:06:08 <killy9999> I need some help. I'm trying to understand how list comprehensions and monads are equivalent
03:06:14 <killy9999> And I have this line of code:
03:06:15 <killy9999> [1..50] >>= \x -> guard ('7' `elem` show x) >> return x
03:06:28 <ocharles> mm_freak: your website doesn't set Content-Type correctly
03:06:33 <ocharles> so your own name doesn't display :)
03:06:34 <killy9999> it produces [7,17,27,37,47]
03:06:56 <killy9999> and I'm trying to figure ot why does this result in ONE list
03:07:11 <ksf> > [x | x <- [1..50], '7' `elem` show x]
03:07:12 <lambdabot>   [7,17,27,37,47]
03:07:23 <killy9999> instead of many lists, because each x is wrapped using return
03:07:39 <bartavelle> because x isn't a list
03:07:47 <killy9999> I know that (>>=) definition for lists contains concat that flattens the resulting list
03:08:03 <ksf> :t (>>=)
03:08:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:08:11 <ksf> there's no m in front of that one a, there.
03:08:18 <ksf> so x *can't* be a list.
03:08:22 <killy9999> I know
03:08:26 <ksf> (well, if m a is [a])
03:08:34 <killy9999> but in the end there's "return x"
03:08:49 <killy9999> which wrapps x into a list
03:09:13 <ksf> but it's the second argument to >>=
03:09:16 <killy9999> and I don't understand how this result of [7], [17] and so on is assembled into one list
03:09:18 * mekeor likes http://stackoverflow.com/a/5917133
03:09:46 <kuribas> Not having third level markdown headers in .lhs sucks...
03:09:49 <killy9999> aaah, so >> contains implicit call to >>=, which calls concat on the result
03:09:52 <ksf> killy9999, [1..50] >>= (  \x -> guard ('7' `elem` show x) >> return x   )
03:10:05 <mekeor> kuribas: why don't you have them?
03:10:22 <mekeor> kuribas: ### third level header
03:10:39 <mekeor> kuribas: see http://daringfireball.net/projects/markdown/syntax#header
03:10:57 <kuribas> mekeor: I tried, but I get a syntax error from ghc.
03:11:05 <killy9999> ksf: >>+ and >> are left associative, right?
03:11:18 <LambdaDusk> mm_freak: Do I have enough time to go out and find something to eat?
03:11:29 <ksf> @info (>>=)
03:11:30 <lambdabot> (>>=)
03:11:32 <killy9999> so without the explicit parens
03:11:33 <ksf> grrr
03:11:46 <ksf> infixl 1 >>=
03:11:52 <killy9999> this work like this: ([1..50] >>= \x -> guard ('7' `elem` show x)  ) >> return x
03:11:58 <killy9999> right?
03:12:10 <ksf> nope, the lambda eats everything to the right
03:12:12 <bartavelle> no
03:12:26 <killy9999> wat?
03:12:39 <bartavelle> [1..50] >>= (...)
03:12:55 <killy9999> WAT?
03:12:58 <killy9999> how's that?
03:13:10 <bartavelle> [1..50] >>= (\x -> guard ('7' `elem` show x)  ) >> return x)
03:13:25 <killy9999> hm...
03:13:31 <killy9999> what is the priority of lambda?
03:14:17 <ksf> lambda isn't an operatore.
03:14:26 <ksf> it's a reserved word, like let or if.
03:14:54 <ksf> "The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible. "
03:14:59 <ksf> http://www.haskell.org/onlinereport/exps.html
03:15:02 <killy9999> thanks
03:15:55 <shachaf> It's unfortunate that you can't say "f \x -> ..."
03:16:08 <hpaste> “Splinter of Chaos” pasted “Draw Circle” at http://hpaste.org/73311
03:16:27 <SplinterOfChaos> Can anyone tell me why this code doesn't work?
03:17:04 <SplinterOfChaos> It's supposed to move the circle when you hit an arrow key. I think something's wrong with the way i'm using IORef.
03:17:52 <ksf> you need to redraw, too.
03:18:19 <mm_freak> ocharles: i know…  the website is terribly outdated, and i'm already implementing a new one
03:20:44 <SplinterOfChaos> ksf: Simple as that. Thanks.
03:22:50 <kuribas> shachaf: You can say f $ \x -> ...
03:23:51 <shachaf> kuribas: I am aware.
03:24:01 <shachaf> You also can't say "f do ..." and so on.
03:24:28 <mm_freak> i don't find parentheses there too bad
03:25:25 <kuribas> shachaf: What's wrong with that?
03:25:33 <shachaf> With what?
03:25:37 <kuribas> using ($)
03:25:47 <shachaf> $ is annoying.
03:25:56 <mm_freak> i try to prevent ($) as much as possible
03:25:58 <n00b6502> ouch, 'State' is a state processor working on the state..
03:25:58 <typoclass> shachaf: you can also say let f' x = ... in f f'
03:26:04 <mm_freak> it's about the ugliest operator we have in haskell
03:26:13 <kuribas> I use it as much as possible...
03:26:34 <kuribas> It hasn't given me trouble...
03:26:42 <mm_freak> i have found that when revisiting my old code ($) is the main reason i have to read more closely to understand my own code
03:26:54 <mm_freak> that's why i even tend to write (f . g) x
03:27:06 <shachaf> typoclass: You can say many many things.
03:27:17 <typoclass> mm_freak: hm, that's an interesting thought
03:27:20 <shachaf> I'm not complaning about what you can say, only what you can't say.
03:28:01 <mm_freak> i only use ($) when there is something multi-line to the right
03:28:13 <mm_freak> like f $ \x -> multipleLines
03:28:27 <mm_freak> but then there is a hanging "\x ->" to the right, which is fine
03:28:37 <typoclass> shachaf: you could change your font so that $ renders the same as whitespace. problem solved
03:28:59 <mm_freak> typoclass: so that "f . g $ x" is rendered as "f . g   x"?
03:29:04 <mm_freak> sounds worse to me
03:29:08 <shachaf> mm_freak: Right, but I wish you could avoce $ even then.
03:29:15 * shachaf wonders what goes bad if you allow that.
03:29:20 <shachaf> s/ce/id/
03:29:32 <shachaf> The keys are right next to each other.
03:30:36 <mm_freak> i'm agreeing there
03:30:50 <mm_freak> every additional ($) makes your code look more like PHP, and we all know how readable PHP code is
03:31:13 <mm_freak> we should probably replace ($) by something longer like (<<<>>>)
03:31:19 <mm_freak> then people wouldn't be so compelled to use it
03:31:56 <Yuu-chan> What to do with $! and <$>?
03:32:09 <mm_freak> Yuu-chan: those are not function application
03:32:48 <Yuu-chan> Speaking about PHP.
03:33:05 <mm_freak> <mm_freak> every additional ($) […]
03:33:13 <mm_freak> ($!) ≠ ($)
03:33:26 <typoclass> Yuu-chan: i like <$> quite much, but i think there is a faction who doesn't like it
03:33:34 <kuribas> Is "m >>= \x -> m2 >>= \y -> m3" equivalent to  "((m >>= \x -> m2) >>= \y -> m3)"?
03:33:55 <mm_freak> typoclass: i belong to that faction, but not unconditionally
03:34:06 <shachaf> @pl m >>= \x -> m2 >>= \y -> m3
03:34:06 <lambdabot> m >> (m2 >> m3)
03:34:07 <shachaf> @pl ((m >>= \x -> m2) >>= \y -> m3)
03:34:08 <lambdabot> m >>= const m2 >>= const m3
03:34:19 <mm_freak> well, actually i do unconditionally
03:34:23 <shachaf> Hmm, @pl is unhelpful here.
03:34:26 <mm_freak> i think i haven't used (<$>) for months
03:34:32 <Yuu-chan> mm_freak: I know, but I don't get why $ does make code PHPish and $! doesn't.
03:34:36 <shachaf> <$> is great.
03:34:44 <shachaf> kuribas: Anyway, try it out in ghci.
03:35:14 <mm_freak> Yuu-chan: because you don't use ($!) unless you have good reason to do so…  to be fair, i don't like that combinator much either
03:35:14 <atriq> I really need to actually learn the records-y things
03:35:41 <mm_freak> Yuu-chan: often i prefer "x `seq` return x" over "return $! x"
03:36:05 <atriq> What's so bad about ($!)?
03:36:16 <mm_freak> Yuu-chan: note that i'm not complaining about the dollar sign
03:36:30 <mm_freak> the main problem with combinators like ($) and ($!) is that they make your code flatter
03:36:43 <Yuu-chan> Isn't that good?
03:36:58 <mm_freak> it's not
03:37:13 <mm_freak> flat code means code which you have to parse yourself to understand groupings
03:37:13 <Automorphism> Why not?
03:37:32 <mm_freak> hence my preference of "print (sum xs)" over "print $ sum xs"
03:37:52 <mm_freak> again, you feel it most when you revisit old code
03:37:54 <Yuu-chan> Infix operators flatten code too, and I personally find it more readable then Lisp style
03:38:19 <mm_freak> infix operators are fine, when the operands are short
03:38:20 <Automorphism> mm_freak: Reading "a $ ..." as "a (...)" has become second nature in me.
03:38:23 <mm_freak> x + y is fine
03:38:34 <mm_freak> Automorphism: what if both sides are long?
03:38:47 * shachaf tends not to like $ much.
03:38:52 <shachaf> <$> is great, however.
03:39:01 <mm_freak> i mostly prefer fmap over (<$>)
03:39:02 <Yrogirg> how does m a -> m (a -> b) -> m b called? m is IO
03:39:04 <Automorphism> mm_freak: I do not like code wider than, say, 60 characters per line.
03:39:10 <mm_freak> Yrogirg: (>>=)
03:39:28 <Yuu-chan> @hoogle m a -> m (a -> b) -> m b
03:39:29 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
03:39:29 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
03:39:29 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
03:39:29 <Automorphism> mm_freak: No.
03:39:35 <mm_freak> oh
03:39:39 <mm_freak> i misread
03:39:44 <Automorphism> :P
03:39:48 <shachaf> Yrogirg: That depends on the order of effects you want.
03:40:00 <shachaf> But it's either (<**>) or flip (<*>)
03:40:25 <Yuu-chan> :t (<$>)
03:40:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:40:41 <Yuu-chan> :t lift (<$>)
03:40:43 <lambdabot> forall a b (f :: * -> *) (t :: (* -> *) -> * -> *). (Functor f, MonadTrans t) => t ((->) (a -> b)) (f a -> f b)
03:40:50 <Yuu-chan> O_O
03:41:06 <shachaf> What?
03:41:13 <shachaf> Why are you using either <$> or lift?
03:41:16 <Yuu-chan> :t (<$>) . lift
03:41:17 <lambdabot>     Couldn't match kind `(* -> *) -> * -> *' against `?? -> ? -> *'
03:41:18 <lambdabot>     When matching the kinds of `t :: (* -> *) -> * -> *' and
03:41:18 <lambdabot>                                `(->) :: ?? -> ? -> *'
03:41:50 <mm_freak> Automorphism: splitting code into multiple lines doesn't really improve things…  this is about code readability, and insisting on code as flat as possible is just the wrong way to go
03:41:55 <Yuu-chan> I'm trying to decompose <*>
03:42:04 <mm_freak> just because haskell allows you to do that doesn't mean it's a good thing to do
03:43:01 <mm_freak> again there is nothing wrong with parentheses, but for some reason haskell programmers (mostly newbies) develop a hate for them
03:44:00 <shachaf> Yuu-chan: Decompose?
03:44:19 <shachaf> "lift" has to do with monad transformers, which are neither here nor there.
03:46:49 <Yuu-chan> shachaf: I mean to represent <*>as a combination of <$> with something
03:47:13 <Yuu-chan> :t liftM
03:47:14 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
03:47:31 <Yuu-chan> (<$>) . liftM
03:47:38 <Yuu-chan> :t (<$>) . liftM
03:47:40 <lambdabot> forall (f :: * -> *) a1 r (m :: * -> *). (Functor f, Monad m) => (a1 -> r) -> f (m a1) -> f (m r)
03:47:57 <Yuu-chan> Silly me ._.
03:48:23 <mm_freak> representing (<*>) in terms of monadic combinators?
03:48:26 <mm_freak> @src ap
03:48:27 <lambdabot> ap = liftM2 id
03:48:44 <shachaf> Yuu-chan: <*> is a primitive.
03:49:08 <shachaf> Yuu-chan: You can express it in terms of liftA2 :: (a -> b -> c) -> f a -> f b -> f c
03:49:18 <shachaf> Or in terms of zipA2 :: f a -> f b -> f (a,b)
03:49:33 <shachaf> But that doesn't get you much.
03:49:53 <merijn> mm_freak: The problem I have with parentheses is that I frequently change and update code, and when using parentheses this involves having to jump back and forth a lot to fix the bracketing
03:51:00 <mm_freak> merijn: i'd take that to get more readable code
03:56:20 * hackagebot MonadCatchIO-mtl 0.3.0.5 - Monad-transformer version of the Control.Exception module (DanielGorin)
03:57:24 <merijn> I (personally) don't find $ that unreadable, I actually prefer it
03:57:53 <atriq> I find writing unreadable code (as a hobby) fun.
03:58:35 <atriq> Serious things I go for readability. Whether I prefer $ or brackets depends heavily on context, the weather, time of day, phase of the moon, etc.
04:00:39 <statusfailed> kuribas: comment? Just a guess
04:00:45 <statusfailed> woops
04:00:48 <statusfailed> I was scrolled up :D
04:04:04 <atriq> It happens
04:07:42 <kuribas> This maybe the reason for not allowing # : http://hackage.haskell.org/trac/ghc/ticket/4073
04:08:35 <kuribas> Should I file a bug request?
04:09:15 <kuribas> Even better: http://hackage.haskell.org/trac/ghc/ticket/4836
04:12:15 <k0ral> hello
04:12:27 <kuribas> So does ghc use cpp?
04:12:52 <danr> bug request? :)
04:13:04 <k0ral> which monad transformers library do you use guys ?
04:13:25 <zomg> Optimus Prime
04:13:47 <typoclass> kuribas: sometimes the c preprocessor is involved. i think it's only for .hsc files normally
04:13:54 <k0ral> especially, is anyone using monadLib ?
04:14:18 <k0ral> I can't find much documentation and code example for monadLib
04:15:17 <kuribas> danr: bug ticket :)
04:15:45 <danr> kuribas: :)
04:17:45 <valentin_> I fail to understand how a function of two variables, x -> y -> Int, can be interpreted as (x -> y) -> Int. In the latter case we take a function of one variable, f -> Int. Where another argument has gone?
04:17:58 <quicksilver> valentin_: it can't.
04:18:03 <quicksilver> it's x -> (y -> Int)
04:18:32 <valentin_> interestengly, a couple of weeks ago I was convinced in this channel that it can!
04:18:35 <merijn> -> is right associative
04:20:30 <quicksilver> valentin_: I think you just remembered the brackets wrongly?
04:20:39 <quicksilver> x -> (y -> Int) is right
04:20:42 <osfameron> @faq can a function of two variables be interpreted as (x -> y) -> Int?
04:20:43 <lambdabot> The answer is: Yes! Haskell can do that.
04:20:46 <merijn> valentin_: Are you sure you didn't misunderstand them or misremembered the parenthesis?
04:20:47 <quicksilver> (x -> y) -> Int is quite different
04:21:09 <typoclass> valentin_: x -> y -> Int is parsed as (x -> (y -> (Int)))
04:21:21 <typoclass> osfameron: way to confuse the issue :)
04:21:47 <osfameron> typoclass: blame lambdabot! ;-P
04:43:31 <k0ral> anyone has an example code using monadlib ?
04:48:39 <n00b6502> heh just discovered a pattern match occurs in the order you declare
04:50:07 <ion> tag:todo, note to self: http://stackoverflow.com/a/5917133
04:50:37 <fmap> k0ral: is there any reason to use monadlib now?
04:51:37 <Botje> ah yes
04:51:43 <Botje> that clowns to the left of me paper is super cool
04:51:45 <ocharles> ion: temko has done a bigger write up on that
04:51:52 <k0ral> fmap: I'm trying to figure out
04:52:06 <k0ral> fmap: for that, I need to test it :)
04:52:07 <ocharles> ion: well, maybe not quite that, but related
04:52:45 <ocharles> ion: http://www.haskellforall.com/2012/01/haskell-for-mainstream-programmers.html
05:08:47 <argoneus> eh
05:19:11 <n00b6502> monad operations in a do block infer the type backwards from the return value?
05:20:22 <n00b6502> a do block return a function whos type infered by the return type of the function holding the do block)..? ... and the function is invoked when that return value is called?
05:21:12 <merijn> n00b6502: I don't really follow those questions?
05:21:27 <merijn> n00b6502: do blocks are just syntactic sugar for >> and >>=
05:21:50 <merijn> (One of these days I should write this explanation in a blog post so I can just link it >.>)
05:21:53 <n00b6502> so those in turn are (the content of my question)
05:22:21 <merijn> n00b6502: "do {foo; bar}" = "foo >> bar" and "do {x <- foo; bar x}" = "foo >>= \x -> bar x"
05:22:27 <merijn> :t (>>)
05:22:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
05:22:31 <merijn> :t (>>=)
05:22:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:22:48 <merijn> n00b6502: >> and >>= are just type inferred like any other function
05:22:50 <n00b6502> ok do is just sugar for >> >>=... i'm fine with that
05:23:22 <n00b6502> >>= itself returns a function ?
05:23:32 <hpc> :t (>>=)
05:23:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
05:23:53 <merijn> n00b6502: No, it returns an action
05:24:05 <merijn> n00b6502: The simplest explanation would be getLine and putStrLn
05:24:13 <clsmith> more bracketed, that's ((foo) >>= (\x -> bar x)).
05:24:22 <n00b6502> i've seen how those work
05:24:40 <merijn> "putStrLn" is a function that takes a string and returns an action. The action being "when executed, print the string to stdout"
05:24:41 <n00b6502> but now i'm trying to use the monad syntax for a parser
05:24:55 <n00b6502> i've done a simple example"the hard way"...
05:25:03 <n00b6502> passing the values along manually
05:25:42 <merijn> So the result of 'putStrLn "foo"' is an action that prints foo. >>= takes an action that results in an "a" and a function that needs an "a" and returns an action that results in a "b"
05:25:58 <n00b6502> this is in the IO monad
05:26:24 <n00b6502> is there anything about the word 'action' specific to monads *independent* of IO; is an action just a function
05:26:35 <n00b6502> now i'm trying to write a monad for a parser
05:26:58 <merijn> n00b6502: Yes, you can see "Maybe a" as an action that *may* return an a, for example
05:27:17 <n00b6502> i've done a simple example the clumsy way, i.e.  parse (sourceobject,dstobject) -> (sourceObject', destObject') where...
05:27:49 <n00b6502> (some code to produce source' and something extracted, and destObject = somethiing to update dstObject with the extracted thing)
05:27:50 <merijn> You can use >>= to combine a "Maybe a" and an (a -> Maybe b" into a an action that *may* return a b
05:28:59 <n00b6502> so to make a parser - i'm starting conceptually with a pair...  a source object to drain, and a dest object to build
05:29:19 <n00b6502> i'm going to stick those together in a monad so i can use >>= >> (and better still do notation) ???
05:29:21 <merijn> For parsing you can think of having a "foo :: Parser a" (an "a" parsing action) and "repeat :: a -> Parser [a]", then you could combine them as "foo >>= repeat" to get a combined parser
05:29:21 <quicksilver> n00b6502: actions are almost never functions.
05:29:32 <n00b6502> ok i'm still confused
05:29:34 <quicksilver> n00b6502: but I think you might be using the word 'function' differently.
05:29:49 <merijn> Not actually sure, that explanation was actually useful...
05:29:51 <quicksilver> "getLine" isn't a function
05:29:58 <quicksilver> "Just 4" isn't a function
05:30:01 <n00b6502> oh can an action be a value that causes functions to be executed when you read it (lazy eval)
05:30:03 <quicksilver> (but they're both monadic actions)
05:30:10 <quicksilver> absolutely no.
05:30:17 <frerich> quicksilver: almost? Maybe my definition of 'action' is imprecise, but I can't see how an action can be a function in any case.
05:30:18 <quicksilver> that sounds like side effects
05:30:30 <quicksilver> frerich: you could write a monad instance for (->)
05:30:36 <quicksilver> frerich: and then your actions are indeed functions :)
05:30:44 <quicksilver> but that's the only case.
05:30:56 <n00b6502> lazy eval: you can return a value, but nothing happens until the value is used.
05:31:04 <n00b6502> does that mean every value is an action?
05:31:05 <quicksilver> that's true enough, n00b6502
05:31:07 <dmwit> State(T) actions are arguably functions.
05:31:08 <quicksilver> no.
05:31:21 <quicksilver> an "action" is not some formal or technical term
05:31:29 <n00b6502> what distinguishes an 'action' from a value or a 'function'
05:31:33 <quicksilver> but it's a word people like touse for values of monadic types.
05:31:37 <quicksilver> actions are all values.
05:31:45 <n00b6502> ok
05:31:48 <quicksilver> a function is something which takes an argument and returns a result.
05:31:56 <quicksilver> functions always have -> at the top of their type
05:32:01 <merijn> n00b6502: Basically IO actions are first class values in haskell
05:32:04 <n00b6502> so now i need to go from my "clumsy" pre monadic parser to something elegant
05:32:04 <quicksilver> that's what a function is - it's a mapping from input to output.
05:32:19 <merijn> Unlike most languages, where they just sort of happen as a side effect
05:32:27 <n00b6502> but i  think i want to do this with minimal library code so i know how it works..
05:32:45 <merijn> n00b6502: Actually, there's a paper you might want to read
05:32:48 <merijn> Let me look up the title
05:33:08 <frerich> merijn: I think quicksilver is explaining this very nicely, giving alternative explanations only tends to make it more confusing :-)
05:33:13 <n00b6502> i'm a bit distressed i dont seem to be inventing monads then asking what they;re called
05:33:14 <dmwit> Step 1. Write a parsing library
05:33:31 <dmwit> Step 2. Check the types: got any that look like (a -> b) -> Parser a -> Parser b? Neat, Parser is (probably) a Functor!
05:33:37 <merijn> n00b6502: Wadler - Monads for Functional Programming
05:34:04 * frerich prays that dmwit's list has no item saying "Profit"
05:34:06 <merijn> n00b6502: That paper shows quite explicitly how and why Monads are useful for parsing
05:34:08 <dmwit> Step 3. Just like Step 2, but with (a -> Parser b) -> (Parser a -> Parser b) and Monad instead of Functor.
05:34:28 <n00b6502> this is making me feel stupid
05:34:33 <quicksilver> I was only really talking about the naming of words because I thought you were confusing people (and maybe yourself) by using words differently to other people.
05:34:37 <n00b6502> i thought i understood this :)
05:34:38 <merijn> n00b6502: As far as I remember it is pretty easy to read if you know basic haskell type signtures
05:34:47 <knz> n00b6502: alternatively you could grab a copy of "Real World Haskell" and start from there -- it takes the topic from the practical side
05:35:02 <frerich> n00b6502: My only advice right now - ignore what everybody else is saying, only listen to quicksilver.
05:35:25 <knz> frerich: nicely insulting, but oh well..
05:36:22 <frerich> knz: Not meant to be - but I believe it's easier to follow one teacher at a time than four of them (and each of then approaching the issue from a different angle) simultaneously. :-)
05:38:44 <knz> frerich: when I was student I liked the diversity, it makes it easier to distinguish the message(s) from the messenger(s)
05:40:04 <n00b6502> ok i know  what problem the monad is to solve... it sucks writing out s' =... s'' = .... etc   states being updated and passed in..
05:40:18 <n00b6502> sucessive return values..
05:40:52 <n00b6502> so basically i need to throw what i'm doing into one of these wrappers so that the "do" syntax (or >>= >> ) can hide those variables
05:41:11 <quicksilver> that is the point of the state monad, yes
05:41:23 <quicksilver> the point of the state monad is not to have to name (mostly) the annoying s and s' etc
05:41:29 <quicksilver> and just have them automatically consistent
05:42:03 <n00b6502> http://www.haskell.org/haskellwiki/State_Monad
05:42:16 <n00b6502> [3 concrete example 1] ok
05:43:11 <quicksilver> if you paste a code fragment we may be able to show you how it would look
05:43:39 <n00b6502> i'll read a bit more
05:44:15 <n00b6502> its the state monad i need ?
05:45:36 <d-old> hey guys is this syntax a regular haskell feature? [whamlet|Hello World!|]
05:45:37 <quicksilver> what you have described is the state monad yes
05:45:47 <quicksilver> d-old: it's called quasiquotations
05:45:48 <d-old> or is it a language extension?
05:45:51 <quicksilver> its an GHC extension
05:46:02 <quicksilver> http://www.haskell.org/haskellwiki/Quasiquotation
05:46:09 <d-old> aha thank :)
05:46:10 <d-old> s
05:46:12 <d-old> thanks :)
05:47:07 <quicksilver> frerich: it is sometimes annoying when people are talking cross purposes but also, friendly anarchy is often better than inadvertantly creating bad feeling by trying to corral the conversation.
05:47:21 <quicksilver> friendly anarchy is also more robust, because I might go into a meeting and stop talking :)
05:49:47 <frerich> knz, merijn, quicksilver: Yeah, sorry - that wasn't my intention. :-/
05:50:01 <frerich> I just tried to... "streamline" the discussion.
05:50:49 <merijn> Quasiquotation is part of TH, right?
05:51:04 <typoclass> merijn: afaict yes
05:51:47 <n00b6502> runState (m x) b = (x,b)
05:52:05 <t7> TH is the devil
05:53:33 <quicksilver> merijn: I would rather say "quasiquotation was implemented, mostly, in terms of TH constructs and using things which already existed for TH"
05:53:33 <merijn> t7: Why?
05:53:43 <t7> not type safe
05:54:16 <quicksilver> it's not really *part* of TH and it has a different syntax (from the user's perspective).
05:54:26 <quicksilver> t7: that's a bit simplistic. TH's output is still typechecked.
05:54:37 <quicksilver> certainly it would be nice if it had better source-level typing like metaML
05:54:43 <quicksilver> and I think it probably will, soonish.
05:54:48 <quicksilver> in, say, two SPJ time units.
05:55:39 <t7> how many Microcenturies is that?
05:56:23 * hackagebot metronome 0.1 - Time Synchronized execution. (PaoloVeronelli)
06:11:49 <mekeor> what's a nice to represent a directional graph (of lists of strings) in haskell?
06:13:13 <osfameron> adjacency matrix?
06:14:13 <neothemachine> Hey, I'm playing with a particular piece of pattern matching code and wondered if it can be expressed more simple, have a look at the paste :)
06:14:14 <hpaste> neothemachine pasted “Express pattern matching combinations” at http://hpaste.org/73315
06:15:19 <mekeor> osfameron: that's not nice... it wastes memory :/
06:15:58 <osfameron> mekeor: DAG or a cyclic graph?
06:16:49 <Yuu-chan> neothemachine: test arg1 arg2 Bar3 = arg1 `in` [Bar1, Bar2] && arg2 `in` [Bar1, Bar2, Bar4]
06:17:05 <Yuu-chan> neothemachine: test _ _ _ = False
06:17:46 <osfameron> mekeor: cyclic graphs aren't convenient to use node representation on with FP, as you essentially have to recreate the whole graph on any change
06:17:47 <Yuu-chan> Also, Bool, not Boolean
06:17:49 <osfameron> aiui
06:17:54 <neothemachine> Yuu-chan: ah cool, thanks! :)
06:18:00 <hpaste> mekeor annotated “Express pattern matching combinations” with “neothemachine: Express pattern matching combinations (annotation)” at http://hpaste.org/73315#a73316
06:18:24 <mekeor> osfameron: Yuu-chan there's no "in", you meant "elem"
06:18:38 <Yuu-chan> Er, yes, sorry
06:18:42 <mekeor> :)
06:19:05 <osfameron> I always want to write `in` too!
06:19:14 <osfameron> but I guess you can't use it as it's a keyword...
06:21:23 <mekeor> osfameron: well, i want a nice representation of a directional graph  (1) which i won't change, just want to be able to define nicely;  (2) which contains lists of strings in its nodes;  (3) in which i can as easily as possible find the lists of all "parents" of a node.
06:22:22 <neothemachine> Yuu-chan: hmm, it seems I abstracted too much for the example, it's not so easily if the data elements have arguments, then I can't construct them in the lists because I don't know the arguments as they are arbitrary
06:23:13 <osfameron> mekeor: ah, if you're not going to change it, then you could probably define it as a doubly linked object graph (with 'tying the knot' fun ;-)  Not sure if that's "nice" or not ;-)
06:23:22 <mekeor> osfameron: i'm using [([String],[[String]])] at the moment where the first thing in the pair is the content of a node and the second thing in the pair is a list of connections to other elements...
06:23:34 <Saizan> neothemachine: but you don't care about the arguments in this test?
06:23:45 <neothemachine> Saizan: right
06:24:11 <Saizan> neothemachine: then define isBarN functions first
06:24:23 <Yuu-chan> :t any
06:24:24 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
06:24:37 <Saizan> isBarN (BarN {}) = True; isBarN _ = False
06:25:07 <neothemachine> and then?
06:25:12 <osfameron> mekeor: you could use a Map?  if the node name is unique
06:25:27 <mekeor> osfameron: yep, nodes are unique
06:25:43 <osfameron> there's surely a haskell Graph library that abstracts all this anyway?
06:25:48 <Saizan> then you can compose them fairly well
06:25:57 <mekeor> osfameron: yeah, that's what i was asking for ;) :P :D
06:26:04 <osfameron> hehe
06:26:48 <Saizan> p <||> q = \x -> p x || q x; p <&&> q = \x -> p x && q x
06:26:50 <neothemachine> you mean, with regular if checks... like if isBar1 arg1 || isBar2 arg1 etc
06:27:00 <Saizan> yep
06:27:09 <Saizan> i'd use guards though
06:27:23 <Saizan> or just take a and of them all
06:27:33 <neothemachine> yeah the thing with guards is that they can't be nested
06:28:08 <Yuu-chan> Or any ($ arg1) [isBar1, isBar2] && any ($ arg2) [isBar1, isBar2, isBarf4]
06:28:38 <Yuu-chan> :t (<||>)
06:28:40 <lambdabot> Not in scope: `<||>'
06:28:51 <neothemachine> hm yeah, but I really wonder that there isn't a generic function to test for a data type, like isType Foo1 arg
06:29:29 <Saizan> for a constructor you mean?
06:29:31 <neothemachine> yep
06:29:33 <Yuu-chan> neomachine: this seems suspiciously close to RTTI/instanceof
06:29:43 <neothemachine> what's RTTI?
06:29:43 <Saizan> neothemachine: look at the Data class
06:30:33 <mm_freak> i think the closest to RTTI is Typeable and Data is a subclass of it
06:30:39 <Yuu-chan> Runtime type information, when you need to determine the class of an instance in the runtime
06:31:13 <mm_freak> but in a sense existential types also carry RTTI
06:31:43 <Yuu-chan> But AFAIK it isn't considered a good practice
06:31:44 <Saizan> Data.Data has toConstr :: Data a => a -> Constr; but you'd be forced into guards anyway
06:32:13 <Saizan> (or if's, or what have you)
06:33:14 <neothemachine> ok and then I get a Constr, how do I check against that?
06:33:40 <Yuu-chan> neothemachine: could you explain the initial task maybe?
06:34:07 <quicksilver> don't use toConstr.
06:34:09 <dolio> No, existential types do not carry RTTI.
06:34:32 <quicksilver> use isBar type functions, or set up a secondary data type of constructor names
06:35:07 <Saizan> even better, refactor Foo into a pair of tags and payloads
06:35:11 <neothemachine> Yuu-chan: hmm not so easy, but basically that part of the algorithm constructs an abstract syntax tree and now I wanted to put in checks to test if the implementation is correct and is only producing valid trees
06:35:51 <Saizan> data Foo = Foo (Bar a) a; data Bar :: * -> * where Bar1 :: Bar X; Bar2 :: Bar Y; ..
06:36:20 <Yuu-chan> Saizan: is that a GADT?
06:36:30 <Saizan> Yuu-chan: Bar is
06:37:04 <neothemachine> hm I guess I need to read up on that first
06:37:44 <Saizan> i think the isBarN functions are probably the best way at first
06:37:46 <mm_freak> donri: i said in a sense
06:38:55 <neothemachine> "Applications of GADTs include generic programming, modelling programming languages (higher-order abstract syntax), maintaining invariants in data structures, expressing constraints in embedded domain-specific languages, and modelling objects.[9]"
06:39:03 <neothemachine> seems about right, let's see...
06:43:03 <donri> mm_freak: context? I just joined
06:43:16 <mm_freak> donri: RTTI, it was a general statement
06:43:29 <donri> what now?
06:43:42 <mm_freak> the only existential type that doesn't carry RTTI in any way is:  data Useless = forall a. Useless a
06:44:06 <donri> why are you telling me this?
06:44:19 <Saizan> donri /= dolio
06:44:22 <mm_freak> oh
06:44:27 <donri> ah
06:44:30 <mm_freak> i confused your name with dolio's =)
06:44:40 <donri> it happens!
06:44:41 <Saizan> or so it seems :)
06:44:53 <mm_freak> the statement from earlier was for dolio in fact…  stupid tab completion
06:45:37 <mm_freak> <mm_freak> but in a sense existential types also carry RTTI  <dolio> No, existential types do not carry RTTI.
06:51:53 <quicksilver> mm_freak: what kind of RTTI is carred by data Ex1 = forall a . Ex1 (a -> Int) (a -> a) a
06:51:57 <quicksilver> ?
06:53:48 <dolio> Existentials only carry the values you put in them, and maybe not even that.
06:54:14 <dolio> For instance the constructor for (exists a. a) is required by parametricity to smash every value you feed it to a single point.
06:54:54 <dolio> So you don't even really know that in 'case Useless 5 of Useless x -> ...' that x = 5 in the body of the case.
07:00:22 <mm_freak> quicksilver: in a sense it does carry RTTI, but that just seems to be my interpretation
07:00:47 <mm_freak> after all what we call RTTI in C++ is often just a pointer to a vtable
07:01:36 <hpaste> neothemachine pasted “GADT How to” at http://hpaste.org/73318
07:02:01 <neothemachine> Saizan: I don't get it... can you help me?
07:02:07 <quicksilver> mm_freak: in what sense.
07:02:26 <quicksilver> data Ex1 = forall a . Ex1 (a -> Int) (a -> a) a
07:02:37 <quicksilver> repeated due to noisy netsplit and my lazy eyes
07:02:43 <quicksilver> in what sense is there any kind of RTTI there?
07:03:02 <quicksilver> what information can you extract about the type of anything; or what information do you imagine the compiler is storing?
07:03:46 <shachaf> mm_freak: You're still talking about Ex1? :-)
07:04:01 <mm_freak> quicksilver: none
07:04:11 <mm_freak> there is no explicit in-memory information
07:04:29 <mm_freak> the point is:  you know that you can apply the two functions to the value
07:04:31 <quicksilver> the "RT" in RTTI means "Run Time"
07:04:43 <mm_freak> shachaf: apparently =)
07:04:57 <quicksilver> it means that running programs have some information about the types of the values
07:05:03 <DKordic> neothemachine: Why not use two mutualy recursive data types (make Pair separate data type).
07:05:44 <neothemachine> DKordic: because then I can't use it as a single return type of something
07:06:11 <neothemachine> well, that's wrong, I rather mean do proper processing, walking the tree
07:06:21 <DKordic> neothemachine: I see.
07:06:31 <shachaf> type Ex1 = Nat -> Int
07:06:31 <neothemachine> hmmm... or would I then need a tree walker for every data type? maybe
07:09:49 <ion> ocharles: Thanks. The article doesn’t seem to mention differentiation of data types, that’s what caught my eye. The SO post mentions byorgey’s paper, i’ll have to check it out.
07:09:50 <mm_freak> shachaf: that wasn't the point actually
07:10:04 <mm_freak> shachaf: it's just that quicksilver's interpretation of RTTI is different from mine =)
07:10:20 <jfischoff> Can Data.Vector wrap a C array? (I assume it can because repa can..)
07:10:24 <shachaf> mm_freak: I know. I just really like that kind of isomorphism. :-)
07:10:29 <mm_freak> jfischoff: see Data.Vector.Storable
07:10:36 <quicksilver> mm_freak: are you able to explain your interpretation of RTTI so I can see your point?
07:10:43 <shachaf> mm_freak: There should be a place with exercises like that. "simplify this type and prove the isomorphism"
07:11:06 <mm_freak> quicksilver: when you allow RTTI to boil down to a bunch of pointers in memory, then C++ RTTI is not much different from an existential type in haskell
07:11:12 <hpaste> Saizan annotated “GADT How to” with “GADT How to (annotation)” at http://hpaste.org/73318#a73319
07:11:20 <Saizan> neothemachine: ^^^
07:11:46 <quicksilver> mm_freak: where are the pointers in my example above?
07:11:46 <mm_freak> shachaf: well, despite my over four years of haskell experience i probably wouldn't have come up with that isomorphism =)
07:12:03 <quicksilver> mm_freak: my example has no vtable or anything like a vtable that I can see.
07:12:06 <neothemachine> Saizan: hmm and how does this restrict the first arg of Left?
07:12:12 <mm_freak> quicksilver: the functions
07:12:29 <quicksilver> the functions are just functions - they don't point to anything unique to the type
07:12:41 <shachaf> mm_freak: Exactly!
07:12:43 <mm_freak> quicksilver: but the constructor points to the functions
07:12:43 <Saizan> neothemachine: oh, i've misunderstood the question
07:12:58 <quicksilver> yes, just like all haskell constructors point to their members
07:13:13 <quicksilver> so is "data Foo = Bar Int Double" like RTTI too?
07:13:27 <nand`> neothemachine: the easiest solution would be to unwrap the Pair, ie. Left (Start, Start, Start) Start
07:13:27 <mm_freak> quicksilver: no, because the types are fixed
07:13:28 <quicksilver> because it contains two pointers, one pointing to an Int and the other pointing to a Double?
07:13:40 <nand`> neothemachine: other than that you could probably achieve this by passing around phantom types, but I think that's ugly
07:13:48 <jfischoff> Is there a package that loads a Wavefile into a Data.Vector.Storable vector in a analogous way to how repa-devil library works?
07:14:34 <mm_freak> quicksilver: for an existential type the actual type used can be dependent on the contents of a file at run-time, and the constructor implicitly contains /some/ information about what you can do with the value
07:14:55 <mm_freak> that's my interpretation…  again, yours may be different
07:15:10 <quicksilver> I don't see room for interpretation, really
07:15:12 <Saizan> neothemachine: you can do something like data Start :: * -> * where Nil :: Start NotPair; Left :: Start Pair -> Start a -> Start NotPair; Pair :: Start a -> Start b -> Start c -> Start Pair
07:15:18 <quicksilver> either the constructor contains type information, or it doesn't.
07:15:35 <quicksilver> are you saying that because it contains a pointer to a function of type (a -> Int) it must contain information about that type?
07:15:54 <quicksilver> the type a, that is.
07:16:08 <nand`> isn't the point of static type checking that no type information is needed at runtime?
07:16:20 <t7> is there a bi-directional map in the prelude? or should i just store two?
07:16:24 <mm_freak> quicksilver: in the same sense a hash contains information about the original string
07:16:26 <quicksilver> nand`: I'm not sure if it's the point or not, but it's certainly a property of it.
07:16:37 <nand`> one of the points
07:16:38 <quicksilver> mm_freak: but that function might be, for example (const 3)
07:16:40 <nand`> at least
07:16:49 <neothemachine> Saizan: hmm, seems to get out of hand quickly for more constraints, maybe in the end, listing all possible pattern matches is the easiest when the data type is applied
07:16:52 <quicksilver> mm_freak: which has no information about the type a because it accepts all types.
07:17:08 <mm_freak> quicksilver: you can still apply it to the value, when it's used as the argument to the constructor
07:17:09 <neothemachine> Saizan: static vs. dynamic I geuss
07:17:20 <quicksilver> certainly you can apply it, that's the point
07:17:25 <quicksilver> but it doesn't know anything about the type.
07:17:39 <nand`> mm_freak: for an existential; sure, the actual type can vary, but you can't differentiate based on this at runtime - remember that anything you can do with the type is stored along with it in the constructor
07:17:40 <quicksilver> you could choose to use (const 3) and (id) as the two functions
07:17:51 <quicksilver> and they would work with any value of course
07:18:07 <quicksilver> so I'm not seeing where type information is there in the constructor
07:18:16 <nand`> there's no way to discern what type it actually is; for all intents and purposes the language could be untyped
07:18:20 <nand`> and existentials could still work
07:19:07 <mm_freak> then let's say you can use an existential type for that purpose
07:19:28 <quicksilver> I will happily say "you can use an existential type to avoid RTTI, when it might be needed in another language"
07:19:29 <nand`> unless you're counting stuff like eg. Typeable; which isn't much different from just using forall a. Foo String a where you have the string be something like "Int" or "Char"
07:19:51 <quicksilver> but that doesn't mean existential types *are* RTTI - it means they are a technique which obviates the need.
07:20:15 <VisionIncision> Hi all, has anybody used hnn?
07:20:26 <VisionIncision> That's Haskell Neural Network
07:21:09 <mm_freak> VisionIncision: no, but i have my own library for ANNs
07:21:21 <nand`> ANN?
07:21:27 <mm_freak> artifical neural network
07:21:28 <nand`> abstract? algebraic? automatic?
07:21:30 <nand`> :(
07:21:38 <mm_freak> artificial neural network
07:22:04 <VisionIncision> Yes, theres a library on Hackage, I was wondering if anybody had used it.
07:24:00 <mm_freak> hnn is very old and based on the deprecated uvector library
07:24:12 <mm_freak> i doubt that anyone is using it, because i doubt that it still compiles
07:24:34 <t7> @hoogle [m a] -> m [a]
07:24:34 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:24:34 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
07:24:34 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
07:24:58 <t7> sequence [Just 1, Just 2, Nothing, Just 3]
07:25:00 <t7> > sequence [Just 1, Just 2, Nothing, Just 3]
07:25:01 <lambdabot>   Nothing
07:25:03 <Saizan> neothemachine: the way i proposed using gadts wasn't to make the checks static (though that's often possible), but to allow splitting the constructors into their own datatype, so that you could work on them not caring about the arguments
07:25:30 <t7> @hoogle [Maybe a] -> Maybe [a]
07:25:30 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
07:25:30 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
07:25:30 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
07:25:31 <Saizan> neothemachine: but it might be overkill
07:25:46 <t7> > catMaybes [Just 1, Just 2, Nothing, Just 3]
07:25:47 <lambdabot>   [1,2,3]
07:26:01 <VisionIncision> Ah ok
07:26:15 <neothemachine> Saizan: I see, well the silver bullet is still missing, but at least I know some ways now :)
07:26:59 <nand`> neothemachine: honestly, the best solution would be to use two datatypes
07:27:21 <t7> @hoogle (a -> b) -> [a] -> [(a, b)]
07:27:21 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
07:27:21 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
07:27:21 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
07:27:37 <nand`> data Pair = Pair Start Start Start; data Start = Nil | Left Pair Start | P Pair; you don't even need two functions for unwrapping the tree either
07:27:55 <nand`> might as well swap the ‘Pair’ and ‘P’ constructors
07:28:20 <nand`> unwrap (Pair (P a b c)) = ...; unwrap (Left a b) = ... unwrap (Pair a) ..
07:29:13 <mm_freak> :t \f -> map (id &&& f)
07:29:14 <lambdabot> forall a c'. (a -> c') -> [a] -> [(a, c')]
07:29:44 <t7> @hoogle (a -> m b) -> [a] -> [m (a, b)]
07:29:45 <lambdabot> No results found
07:30:18 <mm_freak> :t \f -> map (return &&& f)
07:30:20 <lambdabot> forall a (m :: * -> *) c'. (Monad m) => (a -> c') -> [a] -> [(m a, c')]
07:30:33 <mm_freak> :t \f -> map (return . (id &&& f))
07:30:35 <lambdabot> forall (m :: * -> *) a c'. (Monad m) => (a -> c') -> [a] -> [m (a, c')]
07:31:13 <nand`> :t \f -> map (Data.Traversable.sequenceA . (return &&& f))
07:31:14 <lambdabot> forall (f :: * -> *) a a1 (m :: * -> *). (Data.Traversable.Traversable ((,) (m a1)), Applicative f, Monad m) => (a1 -> f a) -> [a1] -> [f (m a1, a)]
07:31:28 <t7> @djinn  (a -> m b) -> [a] -> [m (a, b)]
07:31:28 <lambdabot> Error: Undefined type []
07:31:40 <nand`> oh, that traversable instance didn't work out as I expected
07:31:41 <t7> @djinn  (a -> m b) -> l a -> l (m (a, b))
07:31:41 <lambdabot> -- f cannot be realized.
07:31:53 <mm_freak> t7: just in case you didn't notice, i have given you solutions above
07:32:14 <t7> mm_freak: which one?
07:32:22 <mm_freak> t7: the last one
07:32:26 <mm_freak> :t \f -> map (return . (id &&& f))
07:32:28 <lambdabot> forall (m :: * -> *) a c'. (Monad m) => (a -> c') -> [a] -> [m (a, c')]
07:32:40 <t7> (a -> c') /= (a -> m b)
07:32:47 <mm_freak> oh yeah
07:33:18 <mm_freak> :t \f -> map (\x -> liftA2 (,) pure f)
07:33:20 <lambdabot> forall a b a1 (f :: * -> *). (Applicative f) => (a1 -> b) -> [a] -> [a1 -> (f a1, b)]
07:33:31 <mm_freak> :t \f -> map (liftA2 (,) pure f)
07:33:33 <lambdabot> forall b a (f :: * -> *). (Applicative f) => (a -> b) -> [a] -> [(f a, b)]
07:33:46 <mm_freak> i'm stupid today
07:34:24 <mm_freak> :t \f -> map (fmap (x,) . f)
07:34:26 <lambdabot> Illegal tuple section: use -XTupleSections
07:34:35 <mm_freak> :t \f -> map (fmap ((,) x) . f)
07:34:37 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1 -> f a) -> [a1] -> [f (Expr, a)]
07:34:56 <mm_freak> :t \f -> map (\x -> fmap ((,) x) (f x))
07:34:58 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => (a -> f a1) -> [a] -> [f (a, a1)]
07:35:03 <mm_freak> finally
07:35:32 <nand`> :t \f -> map (uncurry (liftA2 (,)) . return &&& f)
07:35:34 <lambdabot> forall a b (f :: * -> *) c'. (Applicative f, Monad ((,) (f a))) => (f b -> c') -> [f b] -> [(f (a, b), c')]
07:35:49 <nand`> :(
07:36:19 <nand`> oh
07:36:22 <nand`> :t \f -> map (uncurry (liftA2 (,)) . (return &&& f))
07:36:24 <lambdabot> forall a b (f :: * -> *). (Applicative f, Monad f) => (a -> f b) -> [a] -> [f (a, b)]
07:36:40 <nand`> yeah but mm_freak's is better
07:36:42 <otters> Monad ((,) (f a))
07:36:44 <otters> no problem
07:37:59 <t7> @pl \f -> map (\x -> fmap ((,) x) (f x))
07:37:59 <lambdabot> map . liftM2 fmap (,)
07:39:51 <efie> Do you know what the argument "[Text]" stands for in "cellSource :: MonadThrow m => Xlsx -> Int -> [Text] -> Source m [Cell]"? (http://hackage.haskell.org/packages/archive/xlsx/0.0.1/doc/html/Codec-Xlsx-Parser.html) Xlsx is the data I get from the xlsx-function, Int probably specifies the worksheet, but what is "Text"?
07:40:00 <efie> [Text]*
07:40:52 <donri> efie: it's an alternative to String, you can click it to go to its package and definition
07:41:30 <quicksilver> donri: I think he means 'what does the parameter signify' not 'what is that type' :)
07:41:37 <donri> efie: oh you're asking what the parameter is for. in the source it says "cols"
07:42:43 <mm_freak> :t \f -> map (liftA2 fmap (,) f)
07:42:45 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1 -> f a) -> [a1] -> [f (a1, a)]
07:43:06 <mm_freak> :t map . liftA2 fmap (,)
07:43:08 <lambdabot> forall a a1 (f :: * -> *). (Functor f) => (a -> f a1) -> [a] -> [f (a, a1)]
07:43:09 <mekeor> neat: http://adam.chlipala.net/cpdt/html/Universes.html – "Library Universes"
07:45:44 <efie> ok thanks, so "cols" probably stands for columns? I wonder many packages don't provide a minimum example
07:50:56 <scooty-puff> is it possible, using on unwrap and the comonad functions, to have (f (Cofree f a) -> f (Cofree f a)) -> Cofree f a -> Cofree f a?
07:51:05 <scooty-puff> *on -> only
07:51:19 <edwardk> no
07:51:55 <scooty-puff> k
07:53:07 <statusfailed> Hmmm
07:53:17 <statusfailed> I need Category((.)) and Prelude((.))
07:53:32 <statusfailed> how do I use a specific one?
07:53:35 <mm_freak> i'm making the first revision of netwire 4 available, if anyone is interested
07:53:38 <statusfailed> I can't do Cat.(.)
07:53:39 <statusfailed> :\
07:53:41 <mm_freak> http://darcs.ertes.de/netwire/
07:53:43 <statusfailed> mm_freak: I am!
07:53:43 <nand`> (Cat..)
07:53:46 <quicksilver> statusfailed: it's just Cat..
07:53:49 <scooty-puff> Prelude.(.) is just Category.(.) for cat ~ (->)
07:53:50 <statusfailed> ah! thanks :)
07:53:54 <mm_freak> statusfailed: have fun =)
07:53:57 <quicksilver> statusfailed: (but why do you need both? Cat.. should cover both)
07:54:01 <statusfailed> oh, herp derp
07:54:05 <statusfailed> :D
07:54:05 <copumpkin> quicksilver: map/fmap
07:54:23 <quicksilver> copumpkin: depends what you think 'need' means.
07:54:25 <statusfailed> quicksilver: thanks :P
07:54:28 <copumpkin> :)
07:54:29 <mm_freak> statusfailed: please gimme feedback =)
07:54:36 <quicksilver> if he just wants to restrict the type he can use a type sig.
07:54:38 <mm_freak> negative feedback is the most useful
07:55:08 <statusfailed> mm_freak: I need to learn how to use it first to be honest :)
07:55:10 <nand`> at a glance, what is new?
07:55:27 <mm_freak> nand`: everything =)
07:55:36 <statusfailed> will take a look when I get home
07:55:44 <mm_freak> from the user perspective a notable change is the way the event wires are defined
07:56:09 <mm_freak> http://darcs.ertes.de/netwire/Control/Wire/Prefab/Event.hs
07:56:27 <mm_freak> now they all act like identity wires, so you can nicely use them in a Category pipeline
07:56:41 <mm_freak> (1 + 1) . for 4 . after 7
07:56:59 <nand`> I don't think I've seen a crazier operator than ~+++~
07:57:07 <mm_freak> you wouldn't use that operator
07:57:08 <nand`> <<>~ might count
07:57:26 <mm_freak> you would use the ArrowChoice interface instead
07:57:36 <mm_freak> the operators in Reactive are mostly for internal purposes
07:58:02 <nand`> (what's Reactive from?)
07:58:14 <mm_freak> another notable change is that not only is there a Reactive instance for (->), but it's also the main one
07:58:31 <mm_freak> netwire 4 puts its focus on pure wires
07:58:43 <mm_freak> http://darcs.ertes.de/netwire/Control/Wire/Classes.hs
07:58:49 <mm_freak> Reactive is defined there
07:59:12 <nand`> I see
08:01:01 <roconnor> nand`: <<>~ "parses" as < <> ~ ?
08:01:13 <nand`> correct
08:01:23 <roconnor> nand`: I think ^%%= might be worse
08:01:28 <scshunt> nand`: waitwhat?
08:01:30 <danr> and what is < <> ~ supposed to mean? less than mappend twiggle?
08:01:32 <nand`> I haven't seen ^%%=
08:01:34 <scshunt> it parses as <<>~
08:01:59 <danr> scshunt: I guess they mean mentally
08:02:03 <nand`> danr: < means ‘return the argument as well’; <> as mappend; ~ for ‘pure’ (contrast = for ‘stateful’)
08:02:06 <danr> slash mneomically
08:02:07 <roconnor> nand`: http://hackage.haskell.org/packages/archive/data-lens/2.10.2/doc/html/Data-Lens-Common.html#v:-94--37--37--61-
08:02:21 <nand`> compare eg. <+= which increases a lens by some number and returns the result as well
08:02:23 <danr> nand`: oh, ok, thanks :)
08:02:27 <nand`> (statefull)
08:02:31 <nand`> statefully*
08:02:58 <nand`> and by ‘argument’ I mean ‘result’
08:03:13 <roconnor> interestingly the ^%= operation turns a Data.Lens into a Control.Lens and a Lens.Family
08:03:15 <roconnor> er
08:03:18 <roconnor> ^%=
08:03:24 <roconnor> ^%%= I mean
08:03:30 <roconnor> stupid irc client
08:03:45 <nand`> roconnor: at least it isn't defined as ‘id’
08:03:48 <nand`> like %%~ is
08:05:03 <roconnor> nand`: %%~ is the new name for ^%%=.  %%~ also converts a lens into a Control.Lens and a Lens.Family.  It is defined to be (id) since they it is already a Control.Lens
08:05:13 <roconnor> s/they //
08:05:21 * scshunt sighs
08:06:12 <nand`> (yeah, that's why I brought up %%~)
08:06:45 <mekeor> do all impure monads have to base upon IO?  (let me know if the question itself is invalid.)
08:07:18 <nand`> depends on how you define ‘impure’
08:07:19 <quicksilver> the question is not quite well-formed.
08:07:30 <mekeor> i expected that
08:07:37 <quicksilver> the operations on the IO monad are quite referentially transparent, and pure
08:07:53 <quicksilver> the thing that is 'special' about IO is that the RTS "actually executes" the IO action main
08:08:00 <nand`> I think one definition of ‘pure’ vs ‘impure’ monads is when a >>> (id &&& id) = a &&& a  holds for Kleisli m
08:08:08 <quicksilver> (and, by implication, all the other IO actions you've used to compose main)
08:08:09 <nand`> but that doesn't hold for eg. state
08:08:32 <mekeor> can i define "myPutStrLn :: MyIO ()" where MyIO doesn't base upon IO?
08:08:43 <nand`> well yes
08:08:47 <nand`> you could use a free monad
08:08:53 <nand`> but that wouldn't print anything to the screen
08:08:54 <quicksilver> you can define it. But you can't make it output to the terminal
08:08:57 <ocharles> mekeor: but running MyIO will be IO
08:09:04 <scshunt> unless you use unsafePerformIO
08:09:10 <nand`> but you can then write run :: MyIO () -> IO ()
08:09:10 <scshunt> (which you won't)
08:09:14 <ocharles> my :: MyIO a -> IO a
08:09:14 <quicksilver> because the only way you have in haskell of outputting to the terminal uses IO
08:09:15 <mekeor> nand`: yeah
08:09:21 <mekeor> ocharles: yeah i see
08:09:21 <ocharles> s/my/run/ :)
08:09:34 <mekeor> i'd still have to call that function inside "main :: IO ()""
08:09:41 <ocharles> correct
08:10:00 <ocharles> any reason you ask, or just curiousity?
08:10:02 <mekeor> so everything which has side-effects is in the IO monad
08:10:10 <mekeor> curiousity
08:10:17 <ocharles> that again depends on your definition of side effects
08:10:20 <nand`> (observable) side-effects outside Haskell, pretty much; yeah
08:10:29 <nand`> you can still have ‘side effects’ in a pure sense
08:10:35 <nand`> again, compelling example is State
08:10:37 <ocharles> and we like definitions here :)
08:10:52 <mekeor> nand`: yeah, that's not what i mean :)
08:11:14 <scshunt> nand`: wha? No, State is pure
08:11:18 <nand`> there are also monads eg. ST that let you modify memory in a safe manner
08:11:26 <t7> @pl \x -> f x >>= g
08:11:26 <lambdabot> (g =<<) . f
08:11:28 <nand`> scshunt: that doesn't contradict what I said
08:11:42 <scshunt> then maybe I just don't understand your definition of side-effect and pure
08:11:52 <scshunt> ST is funny
08:11:55 <nand`> I gave the definition I was applying above
08:12:08 <scshunt> ST is more like an implementation signal to allow for memory manipulation; its semantics are pure
08:12:09 <mekeor> t7: yeah, that pl-notation of that sucks. needed it often, too
08:12:27 <nand`> something has a side effect if ’ it twice has a different result than only once
08:12:30 <nand`> if ‘binding’*
08:12:36 <quicksilver> these words are potentaially confusing
08:12:43 <quicksilver> t7, mekeor : isn't that >=> ?
08:12:48 <mekeor> oO
08:12:56 <quicksilver> even IO doesn't have side-effects in haskell.
08:13:03 <nand`> quicksilver: should be
08:13:05 <jfischoff> Anyone know an eloquent way to implement undo functionality?
08:13:06 <t7> g <$> f x    ?
08:13:11 <otters> :t (>=>)
08:13:13 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:13:22 <quicksilver> because the 'side' in 'side-effect' means the effects are "alongside" evaluation.
08:13:23 <t7> oh no
08:13:24 <merijn> jfischoff: Undo functionality in what?
08:13:41 <quicksilver> and evaluating IO actions doesn't cause the effects
08:13:44 <jfischoff> merjin: an interactive program
08:13:45 <bo> Hi everybody. I am relatively new to Haskell (and new here). I am wondering if anybody could help me with a little problem I am trying to solve using Either String as a monad for error handling.
08:13:53 <otters> bo: hit us
08:14:07 <mekeor> bo: go ahead! shoot! fire!
08:14:14 <otters> break a leg
08:14:19 <scshunt> jfischoff: tardis monad :P
08:14:41 <jfischoff> scshunt: is there an example you can point me too?
08:14:50 <bo> ok: I am trying to convert a list of lists into a 2-dimensional array. And I want it to fail gracefully when the list of lists is not rectangular or empty
08:14:54 <scshunt> it was a joke
08:14:54 <ocharles> i don't think tardis will give you undo
08:14:59 <nand`> Either String for error handling can be misleading
08:15:05 <ocharles> jfischoff: your question is a bit vague, try and be a bit more specific
08:15:06 <bo> I have written this
08:15:08 <t7> wow data.binary and ByteString.Readfile is fast
08:15:13 <nand`> notably because eg. failed pattern matching in Either String will still end up calling ‘error’
08:15:14 <bo> readProblem :: String -> Either String Problem
08:15:14 <bo> readProblem s = do
08:15:14 <bo>             pl <- readProblemList s
08:15:16 <bo>             let columns = length $ head pl
08:15:18 <bo>             let rows = length pl
08:15:20 <bo>             return $ listArray ((1, 1), (rows, columns)) $ concat pl
08:15:23 <otters> bo: nuuu. put code in hpaste
08:15:25 <scshunt> jfischoff: maintain a tree or list of actions, where each action stores enough information to undo and redo it
08:15:33 <bo> oh, ok. hpaste
08:15:36 <bo> let's see...
08:15:42 <nand`> @where hpaste
08:15:42 <mekeor> @where hpaste
08:15:43 <lambdabot> http://hpaste.org/
08:15:43 <lambdabot> http://hpaste.org/
08:15:45 <mekeor> :D
08:15:49 <otters> @hoogle transpose
08:15:49 <ocharles> jfischoff: alternatively, store your entire program state in a tree, and simply jump around that tree
08:15:49 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
08:15:50 <lambdabot> Data.ByteString transpose :: [ByteString] -> [ByteString]
08:15:50 <lambdabot> Data.ByteString.Char8 transpose :: [ByteString] -> [ByteString]
08:15:53 <ocharles> (for example, with a zipper)
08:15:57 <quicksilver> jfischoff: ( scshunt ) or just maintain a list of previous states and go back to them.
08:15:59 <otters> > transpose [[1..3], [2..4], [3..5]]
08:16:00 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
08:16:09 <otters> haha, wow
08:16:11 <quicksilver> if your states naturally share most of their data with each other
08:16:11 <t7> whats the idiomatic way to handle cmdline args
08:16:18 <quicksilver> then it won't take much memory.
08:16:19 <t7> whats teh defacto package
08:16:21 <otters> getArgs
08:16:21 <ocharles> t7: there isn't one way, really
08:16:23 <otters> @hoogle getArgs
08:16:24 <lambdabot> System.Environment getArgs :: IO [String]
08:16:24 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
08:16:27 <nand`> t7: there are a few
08:16:28 <ocharles> I like optparse-applicative, but there are more
08:16:38 <ocharles> cmdargs is one
08:16:44 <otters> oh like...parsing
08:16:44 <hpaste> bo pasted “wrestling with Either String monad” at http://hpaste.org/73323
08:16:54 <nand`> I had pleasing results when using System.Console.GetOpt
08:16:59 <nand`> whichever package that is in
08:17:21 <otters> bo: what's your issue
08:17:26 <bo> now I am looking for some lines to insert into readProblem that will give nice error strings when pl is empty or not rectangular
08:17:39 <bo> or am I completely on the wrong way?
08:18:21 <nand`> unless (length pl == length (transpose pl)) $ Left "Input list is not rectangular!"
08:18:24 <jfischoff> I think I am going to have each command execute an action and produce a result and inverse action. I will use the inverse action for undo.
08:18:31 <otters> what nand` said
08:18:31 <nand`> probably not the most efficient implementation
08:18:36 <otters> but you'd have to check every item in the list
08:18:40 <otters> oh wait no
08:18:41 <t7> im making a Latex name to UTF8 converter for nice unicode input in vim :) i have allready parsed the unicode file from w3 so now i just need the bridge application
08:18:43 <otters> never mind, I'm silly
08:19:17 <merijn> t7: I love you, where do I subscribe to updates? :>
08:19:18 <bo> aahhhh... unless .. $ Left ...
08:19:25 <otters> :src unless
08:19:26 <nand`> (or go for when (... /= ...) depending on how you prefer your choices)
08:19:28 <otters> @src unless
08:19:29 <lambdabot> unless p s = if p then return () else s
08:19:30 <otters> dammit
08:19:30 <bo> I knew it had to be easy
08:19:42 <t7> i will make a github repo before i leave
08:19:50 <otters> @pl \x -> length x == length (transpose x)
08:19:50 <t7> leave work
08:19:51 <lambdabot> liftM2 (==) length (length . transpose)
08:20:23 <nand`> bo: note that what you might want to do is create a newtype around Either String with its own Monad instance; defining fail = Left
08:20:33 <nand`> then you can simply use fail "foo bar"
08:20:37 <otters> fail already is Left
08:20:38 <bo> sorry to bother you ... still wrestling with the basics. Didn't quite understand unless
08:20:39 <otters> @src Either fail
08:20:40 <lambdabot> fail msg      = Left (strMsg msg)
08:20:41 <nand`> otters: no
08:20:47 <nand`> wait, that can't be right
08:20:47 <otters> ^
08:20:51 <otters> yes it can
08:21:04 <otters> > (fail "hello") :: Either String Int
08:21:05 <lambdabot>   *Exception: hello
08:21:08 <otters> wow
08:21:16 <otters> somebody's lying
08:21:16 <nand`> @src strMsg
08:21:16 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:21:27 <nand`> otters: exactly; I was pretty sure it's ‘error’ in base
08:21:32 <otters> @hoogle strMsg
08:21:33 <lambdabot> Control.Monad.Trans.Error strMsg :: Error a => String -> a
08:21:33 <lambdabot> Control.Monad.Error.Class strMsg :: Error a => String -> a
08:21:33 <lambdabot> Control.Monad.Error strMsg :: Error a => String -> a
08:21:46 <ReinH> It occurs to me that if hackage packages used semver.org versioning, upper bounds would be far more useful and reasonable (http://www.haskell.org/pipermail/haskell-cafe/2012-August/102885.html)
08:22:04 <roconnor> bo: I've never used it, but you might be interested in the errors package
08:22:06 <ReinH> since the semantics of "beyond this point there may be breaking changes" will be defined
08:22:06 <roconnor> @hackage errors
08:22:07 <lambdabot> http://hackage.haskell.org/package/errors
08:22:35 <nand`> otters: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad-Instances.html
08:22:55 <nand`> the problem with fail = Left is that the instance is Monad (Either e); not Monad (Either String)
08:22:55 <otters> wow
08:22:56 <roconnor> bo: in particular the note function
08:22:57 <Veinor> ReinH: i disagree; there are certain things that are far less likely to change than others
08:22:59 <roconnor> http://hackage.haskell.org/packages/archive/errors/1.2.1/doc/html/Control-Error-Util.html#v:note
08:23:47 <Veinor> for example, if i'm depending on text just for pack and unpack, i can be 99.9% sure that my code will work with any version of text, ever
08:23:49 <ReinH> Veinor: ofc, in which case they would not get a major version bump
08:23:56 <nand`> bo: Do you understand how the Either e monad works in general?
08:24:06 <ReinH> Veinor: not specifying upper bounds is ofc still an option
08:24:14 <ReinH> I'm just suggesting that semver would make upper bounds more useful and less broken
08:24:26 <Veinor> isn't that already what the PVP says?
08:24:30 <ReinH> roconnor: note and hush are wonderful
08:25:18 <nand`> bo: Desugared, the unless (...) $ Left ... looks something like this:   if (...) then return () else Left ...;  and since return = Right for Either e; that's  if (...) then Right () else Left ...
08:25:28 <ReinH> Veinor: not quite: semver would indicate that any interface breaking changes require a major version bump
08:25:33 <roconnor> ReinH: I haven't yet had the pleasure of using them
08:25:36 <nand`> and by ‘desugared’ I mean ‘evaluated’
08:25:39 <ReinH> Veinor: my reading of PVP is that it only requires a minor version bump
08:26:43 <ReinH> Veinor: although that's just a bitshift away, so to speak, and specifying <2.2 while using a 2.1.x package *should* have the same effect
08:26:53 <bo> thanks everybody, I am beginning to understand
08:27:13 <ReinH> it seems like the situation on the ground is that PVP's versioning rules aren't being honored, which is making upper bounds less useful than they should be
08:27:58 <nand`> bo: now just note that Left l >>= _ = Left l; so by evaluating a ‘Left ...’ in a line of a do block like that; you effectively halt all further evaluation
08:28:31 <nand`> meanwhile ‘Right _ >> x’ = x
08:28:35 <nand`> so Right () simply gets ignored
08:28:39 <nand`> and the computation continues
08:29:26 <ReinH> imo it's a bit easier to understand either if you use Wadler's original type constructors: Raise and Return
08:29:57 <nand`> s/Left/Wrong/ :)
08:30:03 <ReinH> nand`: ;)
08:30:19 <mekeor> quicksilver: what does "evaluating IO actions doesn't cause the effects" mean?
08:30:31 <latro`a> try doing like
08:30:35 <ReinH> or consider that either is a "decorated" maybe
08:30:36 <latro`a> b = getLine `seq` 2
08:30:52 <latro`a> and watch as no IO happens
08:31:08 <mekeor> ah, hm
08:31:45 <mekeor> well, i think you can't even do that...
08:31:48 <mekeor> @ty seq
08:31:50 <lambdabot> forall a t. a -> t -> t
08:31:52 <nand`> you can
08:31:57 <mekeor> you'd have to write a seqM
08:31:57 <ocharles> does anyone know any websocket clients for haskell?
08:32:00 <nand`> > getLine `seq` 2
08:32:02 <lambdabot>   2
08:32:02 <otters> @hoogle deepseq
08:32:02 <lambdabot> Control.DeepSeq module Control.DeepSeq
08:32:03 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
08:32:03 <lambdabot> package deepseq
08:32:05 <otters> :t deepseq
08:32:06 <lambdabot> Not in scope: `deepseq'
08:32:08 <ReinH> ocharles: clients?
08:32:09 <otters> aw
08:32:18 <ocharles> or is there nothing special about them from the client side?
08:32:19 <mekeor> nand`: how does that work?
08:32:26 <nand`> mekeor: look at the type of seq
08:32:30 <nand`> ‘a’ can be anything
08:32:39 <ReinH> ocharles: arent' websocket clients typically browsers?
08:32:40 <ocharles> ReinH: yea, have I asked a dumb question?
08:32:41 <mekeor> but...
08:32:48 <EvanR> is there a mirror for haskell platform
08:32:49 <mekeor> nand`: ah, well, okay
08:32:51 <EvanR> its taking forever
08:33:05 <ocharles> ReinH: i don't see why
08:33:11 <ocharles> it's just a protocol
08:33:14 <quicksilver> mekeor: yes, as latro`a says. the evaluation does not cause the effect.
08:33:19 <mekeor> nand`: anyway, the type of 'b' is... well, it's 'Num t => t', right?
08:33:27 <mekeor> oO
08:33:38 <quicksilver> and this is quite a key distinction.
08:33:45 <ReinH> ocharles: true enough, but I don't think there's much need that would drive a haskell impl.
08:33:51 <mekeor> i see, cool. exciting!
08:33:56 <ReinH> ocharles: but if you have a need, that's a great reason to create a package :)
08:33:56 <nand`> :t curry (uncurry seq `asAppliedTo` (getLine, 2))
08:33:58 <lambdabot> forall b. (Num b) => IO String -> b -> b
08:34:04 <nand`> mekeor: ^
08:34:08 <otters> :t asAppliedTo
08:34:10 <mekeor> quicksilver: so, what does side the side effects? just *execution*?
08:34:10 <lambdabot> forall t b. (t -> b) -> t -> t -> b
08:34:15 <otters> what does that do
08:34:28 <nand`> otters: nothing; it's basically const
08:34:40 <nand`> but with a more limited type signature
08:34:41 <quicksilver> yes, the IO execution is what actually fires off the effects.
08:34:56 <nand`> mekeor: assigning to main and running the executable, yeah
08:34:58 <mekeor> nand`: you're mixing up asAppliedTo and asTypeOf, aren't you?
08:35:14 <nand`> mekeor: I don't see why I am
08:35:21 <quicksilver> to see an example of effects performed during evaluation, see unsafePerformIO, or Debug.Trace.
08:35:24 <nand`> :t const :: (t -> b) -> t -> t -> b
08:35:26 <lambdabot> forall t b. (t -> b) -> t -> t -> b
08:35:29 <nand`> :t asAppliedTo
08:35:31 <lambdabot> forall t b. (t -> b) -> t -> t -> b
08:35:39 <mekeor> :t asTypeOf
08:35:41 <lambdabot> forall a. a -> a -> a
08:35:42 <mekeor> :t const
08:35:44 <lambdabot> forall a b. a -> b -> a
08:35:44 <nand`> asTypeOf is const too
08:35:46 <mekeor> okay
08:35:48 <mekeor> =)
08:35:53 <nand`> all of the as* are const :)
08:36:15 <mekeor> alright
08:38:01 <mekeor> thanks quicksilver, latro`a and nand`. that was helpful and exciting :)
08:38:29 <ReinH> ocharles: you would probably be implementing on top of http://hackage.haskell.org/packages/archive/network-bytestring/0.1.2.1/doc/html/Network-Socket-ByteString.html I think
08:39:36 <ReinH> ocharles: probably http://hackage.haskell.org/packages/archive/network/latest/doc/html/Network.html actually
08:39:52 <ocharles> yes, i know how to build it, i would just ideally not like to do that
08:40:03 <ocharles> seeing as i'm prototyping, i'll probably just use python which already has libraries
08:40:07 <ocharles> not ideal, but eh
08:40:24 <ReinH> right
08:40:47 <k0ral> hello
08:40:53 <k0ral> again I have a problem with mtl transformers
08:41:15 <hpaste> bo pasted “wrestling with Either String monad, SOLVED” at http://hpaste.org/73324
08:41:31 <k0ral> I have a library that provides f :: IO a -> IO a and I want to turn it into f' :: m a -> m a
08:41:38 <bo> this is how I solved it
08:41:43 <k0ral> with (MonadIO m, MonadX m, MonadY m ...)
08:41:53 <bo> my problem was actually understanding when and unless
08:42:00 <quicksilver> k0ral: short answer - can't be done. Sorry.
08:42:07 <nand`> I still think length x == length (transpose x) is cleaner :)
08:42:08 <bo> the rest might not be elegant yet, but at least I understand it :-)
08:42:12 <bindy> hi, please, anyone knows how to use multiExec in Hedis library? Is it possible to use a result of one redis command in a different command, both of them inside of a multiExec?
08:42:24 <k0ral> quicksilver: :( that really sucks
08:42:33 <nand`> ah
08:42:36 <bo> nand`: but is your version correct? I don't want to check for square, only rectangular
08:42:37 <nand`> but my solution is bugged
08:42:38 <nand`> disregard me
08:42:45 <nand`> oh; rectangular
08:42:48 <quicksilver> k0ral: take a look at this very old post - http://www.haskell.org/pipermail/haskell-cafe/2007-July/028501.html
08:42:54 <nand`> my solution is bugged due to another reason
08:42:57 <quicksilver> k0ral: for some of the problems and solutions
08:43:06 <nand`> > transpose [[1,2,3], [4,5,6], [7,8]]
08:43:08 <lambdabot>   [[1,4,7],[2,5,8],[3,6]]
08:43:10 <nand`> length is still 3
08:43:20 <k0ral> quicksilver: I wrote f' x = liftIO . runX . runY . f
08:43:30 <k0ral> without the "x"
08:44:02 <k0ral> well, actualy I wrote some additional processing to get back to MonadX and MonadY
08:44:06 <k0ral> actually*
08:45:14 <k0ral> quicksilver: the start of the post you mentioned is exactly what I'm dealing with: callbacks
08:45:45 <bo> why did hpaste just tell me: "13:21: Error: Use all"?
08:46:41 <latro`a> link?
08:47:05 <fmap> bo: and . map ≡ all
08:47:22 <fmap> (roughly)
08:47:32 <latro`a> precisely, actually
08:47:46 <latro`a> map gets type-constrained in that setting
08:47:46 <bo> ah, thanks fmap
08:48:20 <latro`a> or . map = any
08:48:43 <fmap> :t \f -> and . map f
08:48:45 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:48:46 <fmap> :t all
08:48:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:49:01 <bo> ok, all is nicer
08:49:04 <latro`a> no need for the lambda
08:49:07 <latro`a> :t and . map
08:49:09 <lambdabot>     Couldn't match expected type `[Bool]'
08:49:09 <lambdabot>            against inferred type `[a] -> [b]'
08:49:09 <lambdabot>     Probable cause: `map' is applied to too few arguments
08:49:13 <latro`a> uh
08:49:14 <latro`a> wat
08:49:15 <nand`> :t and .: map
08:49:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:49:25 <nand`> map takes two arguments
08:49:36 <otters> :t (and .) . map
08:49:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
08:49:38 <latro`a> oh oh
08:49:39 <latro`a> right
08:49:41 <latro`a> that
08:49:41 <otters> that's the stuff
08:49:47 <latro`a> yeah
08:49:47 <quicksilver> k0ral: a general solution seems very hard
08:49:51 <latro`a> silly me
08:50:00 <quicksilver> k0ral: for special monads, or specific callback patterns, there are specific solutions
08:50:25 <latro`a> k0ral, trying to take an interface and "abstract" it from the IO monad like that may be appropriate for a free monad
08:50:43 <latro`a> :t (.:)
08:50:45 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
08:51:17 <k0ral> latro`a: what ?
08:51:20 <latro`a> :t and .: zipWith
08:51:22 <lambdabot>     Couldn't match expected type `[Bool]'
08:51:23 <lambdabot>            against inferred type `[b] -> [c]'
08:51:23 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
08:51:25 <latro`a> ahh
08:51:25 <ReinH> bo: it might be nice to create your own error types to represent failure modes a la control.monad.error
08:51:29 <latro`a> so it doesn't go any higher
08:51:39 <latro`a> k0ral, there are tons of articles recently on free monads
08:51:42 <ch33sus_> dont get it
08:51:42 <ch33sus_> quadrat :: a -> a quadrat x = x + x
08:51:42 <ch33sus_> doesnt work
08:51:56 <latro`a> the signature includes too many types
08:51:58 <otters> :t (..:)
08:51:59 <lambdabot> Not in scope: `..:'
08:52:11 <nand`> .::
08:52:20 <nand`> :t and .:: zipWith
08:52:21 <lambdabot> Not in scope: `.::'
08:52:24 <nand`> bah
08:52:30 <otters> @src (.:)
08:52:30 <lambdabot> Source not found. Just what do you think you're doing Dave?
08:52:35 <otters> :t fmap . fmap
08:52:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
08:52:44 <latro`a> k0ral, it sounds to me like you are using a weakened subset of the IO monad and want to remove the IO monad itself from the equation
08:52:50 <otters> @let (.::) = fmap . fmap . fmap
08:52:52 <lambdabot>  Defined.
08:52:55 <latro`a> a free monad is fitting for this purpose
08:52:57 <otters> :t and .:: zipWith
08:52:59 <lambdabot> forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool
08:53:02 <ion> fmap`fmap`fmap`fmap`fmap
08:53:03 <latro`a> ah
08:53:04 <ch33sus_> fmap. fmap  what does the dot do?
08:53:04 <latro`a> cute
08:53:15 <otters> the dot composes fmap and fmap
08:53:17 <latro`a> @src (.)
08:53:17 <lambdabot> (f . g) x = f (g x)
08:53:18 <lambdabot> NB: In lambdabot,  (.) = fmap
08:53:22 <nand`> ion: nice
08:53:26 <ion> nand: FSVO nice
08:53:36 <nand`> ion: syntax highlighting makes it obvious though :(
08:53:44 <ch33sus_> so still i dont get why my function doestn work
08:53:55 <ch33sus_> f:: a -> a
08:54:02 <ch33sus_> f x = x*x
08:54:17 <otters> :t (*)
08:54:19 <lambdabot> forall a. (Num a) => a -> a -> a
08:54:19 <zhulikas> and?
08:54:34 <ion> ch33sus: (*) doesn’t work for all values of type “a”.
08:54:39 <otters> :t (\x -> x * x) :: a -> a
08:54:40 <lambdabot>     Could not deduce (Num a) from the context ()
08:54:41 <lambdabot>       arising from a use of `*' at <interactive>:1:7-11
08:54:41 <lambdabot>     Possible fix:
08:54:48 <otters> :t (\x -> x * x) :: Num a => a -> a -> a
08:54:49 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
08:54:49 <lambdabot>     In the expression: (\ x -> x * x) :: (Num a) => a -> a -> a
08:54:58 <otters> :t (\x -> x * x) :: Num a => a -> a
08:55:00 <lambdabot> forall a. (Num a) => a -> a
08:55:18 <ion> @type (^2)
08:55:19 <lambdabot> forall a. (Num a) => a -> a
08:55:30 <ch33sus_> so i gotta be  f :: Num a => a -> a
08:55:31 <ch33sus_> ?
08:55:39 <otters> yeh
08:56:15 <ch33sus_> also im confused with normal brackets to clarify math terms
08:56:23 <ch33sus_> like sin x / 5
08:56:40 <ch33sus_> is it sin (x/5) or sin (x) / 5?
08:57:03 <quicksilver> depends what font size you use
08:57:05 <ch33sus_> also can i write additionall brackets to clarify?
08:57:12 <quicksilver> and how thick you draw the chalk lines
08:57:19 <ion> ch33sus: Function application always binds the tightest. Yes, you can always write additional brackets for clarification.
08:57:22 <sipa> ch33sus_: typically (sin x)/5
08:57:38 <zhulikas> :t sin
08:57:40 <ch33sus_> kk thx
08:57:40 <lambdabot> forall a. (Floating a) => a -> a
08:58:52 <latro`a> note that the function application as tightest operator approach isn't the standard approach in mathematics
08:59:07 <latro`a> (though you may have already picked up on that)
08:59:10 <ch33sus_> left to right?
08:59:21 <ch33sus_> hm that would still be tightest
08:59:24 <latro`a> erm, no, not exactly
08:59:26 <ch33sus_> so how is it?
08:59:33 <latro`a> sin x/5 is typically read as sin(x/5) in mathematics
08:59:49 <ch33sus_> ya
09:00:03 <sipa> unless the / is written below
09:00:08 <zhulikas> or (sin x) / 5
09:00:08 <latro`a> that's not / :p
09:00:08 <ch33sus_> but if its like sin x / * 52e + 324
09:00:18 <ch33sus_> not really clear
09:00:24 <ch33sus_> i always write brackets
09:00:41 * zhulikas always spends the dollars 
09:01:32 <ch33sus_> omg so now i have k1 :: Num a => [a] -> a
09:01:38 <ch33sus_> and quadrat :: Num a => a -> a
09:01:50 <ch33sus_> and quadrat k1 [2,42,4,2] doesnt work :(
09:02:00 <zhulikas> :D
09:02:28 <ch33sus_> why???
09:02:29 <zhulikas> quadrat $ k1 [2,42,4,2]
09:02:32 <zhulikas> try this :D
09:02:41 <ch33sus_> whats the dollar sign for?
09:02:46 <zhulikas> money
09:02:52 <ch33sus_> lol
09:03:01 <ch33sus_> im just passing the result to quadrat
09:03:16 <latro`a> again, function application is tighter, so you get
09:03:19 <ch33sus_> which has adaequat types (in my eyes)
09:03:22 <latro`a> (quadrat k1) [2,42,4,2]
09:03:27 <latro`a> which breaks
09:03:30 <ch33sus_> aaaaaaa
09:03:45 <latro`a> the $ is more or less a left paren where it appears and a right paren at the end of the expression
09:03:55 <donri> you want, quadrat (k1 [2,42]), the dollar is another way to spell that
09:04:02 <ch33sus_> ya
09:04:06 <ion> And in this case, a worse way. :-P
09:04:10 <ch33sus_> but i guess brackets are less confusing
09:04:12 <ch33sus_> why
09:04:21 <ch33sus_> oh
09:04:24 <ch33sus_> nvmd
09:04:40 <latro`a> I think the $ is more useful when it avoids giant right paren madness
09:04:45 <donri> i like parens for some things, dollar for others.
09:04:55 <donri> often you can also use composition in place of dollar
09:04:55 <latro`a> any fewer than, say, 2
09:04:58 <latro`a> and it's not too bad
09:05:03 <latro`a> and yeah, that is true
09:05:03 <donri> qudrat . k1 $ [2,42,4,2]
09:05:26 <donri> that can be easier to refactor because you can move out qudrat . k1
09:05:49 <ion> (quadrat . k1) [2,42,4,2]
09:08:40 <identity> yet another mis-/msg to me, instead of nickserv. I can soon dominate freenode
09:08:46 <ch33sus_> so do you always write the types ontop of functions or too lazy?
09:08:52 <identity> eh, wrong channel
09:09:23 <latro`a> ch33sus_, a lot of the time there's some benefit to writing the type of a function before you actually know how to implement it
09:09:35 <latro`a> it gives structure to the creative process, if you will
09:09:39 <ch33sus_> huh yeah
09:09:44 <zhulikas> ch33sus_, I always do that. Also HLint suggests that
09:09:47 <ch33sus_> seems like thats a good idea
09:09:53 <ch33sus_> HLintß
09:09:54 <ch33sus_> ?
09:10:03 <zhulikas> actually I usually start with type definition
09:10:12 <latro`a> the program that hpaste uses to throw complaints at you is called HLint
09:10:19 <donri> ch33sus_: top-level types are usually written out because it serves as good documentation, avoids the monomorphism restriction and you sometimes don't want the inferred type
09:10:34 <latro`a> it goes through haskell source code and finds things that are considered stylistic mistakes
09:11:00 <latro`a> not all of them necessarily *are* stylistic mistakes; last time I ran code through HLint I had something like 25 things and left behind about 10
09:11:27 <zhulikas> oh oh! and once for some Euler problem the performance boost was ~1.5x for using defined function types!
09:11:34 <zhulikas> so I guess it inferred something really bad
09:11:44 <donri> hlint actually suggests changes that change types :p
09:11:49 <latro`a> lol
09:11:56 <latro`a> HLint is not type safe, oh noes
09:11:59 <ch33sus_> hm so i started with using lesah ide but its super annoying that it always interprets after i type a new letter
09:12:13 <ch33sus_> also i couldnt access the preferences
09:12:13 <zhulikas> ch33sus_, consider EclipseFP
09:12:15 * zhulikas loves it
09:12:16 <donri> for example it suggests void, which induces a Functor constraint
09:12:38 <ch33sus_> yeah well
09:12:44 <ch33sus_> see you later
09:14:03 <logicalguy> hi ppl, this is my first day trying out haskell
09:14:17 <mekeor> logicalguy: yay!
09:14:25 <mekeor> haskell is lots of fun! =)
09:14:28 <anders_> lillis: you have my nick!
09:14:38 <logicalguy> ha ha, thanks mekeor
09:14:41 <donri> latro`a: try hlint -hDollar -hGeneralise ;)
09:14:44 <logicalguy> I am liking it loads already
09:15:31 <logicalguy> i have a question
09:15:51 <logicalguy>  in the haskell wikibook the first section it says variables don't change.  but in ghci I typed in "let t = 8" followed by "let t = 9" and printed t which was 9
09:16:22 <donri> logicalguy: it's a new variable
09:16:31 <parcs`> you're not changing the variable you're redefining 't' and shadowing the old one
09:16:48 <logicalguy> so in memory there are two 't's
09:17:01 <nand`> yeah but the old one should get GCd by that point
09:17:03 <nand`> (does ghci GC?)
09:17:05 <parcs`> sure, until the old 't' gets gc'd
09:17:17 <latro`a> ghci is a litttle different; you're not actually changing t, you're basically changing scope
09:17:25 <logicalguy> oh ok I get it
09:17:30 <nand`> note the ‘let’
09:17:33 <latro`a> yeah
09:17:36 <latro`a> the let changes matters
09:17:44 <nand`> which is not part of normal Haskell syntax (without an ‘in’)
09:17:52 <latro`a> ehh...kinda, nand`
09:17:55 <logicalguy> ok...
09:18:06 <nand`> it's basically sort of like “let t = 9 in ... <everything from now on>”
09:18:20 <nand`> latro`a: oh right, do blocks
09:18:24 <latro`a> yeah
09:18:26 <nand`> I guess you could say GHCi simulates a big do block
09:18:34 <latro`a> hell, you can even do crazy things like
09:18:37 <latro`a> foo <- getLine
09:18:40 <nand`> it does “let it = ” and “it <- ” implicitly
09:18:40 <efie> what is wrong with >  ['\','"'] :: [Char] < ? it says "lexical error in string/character literal at character ','"
09:18:41 <latro`a> directly in ghci
09:18:43 <EvanR> insanity!
09:18:55 <logicalguy> i'll have to bypass this for now till I learn do blocks, then :)
09:19:02 <logicalguy> this all sounds well confusing
09:19:07 <latro`a> eh, not really, ghci mostly works like you expect
09:19:07 <nand`> I rescind my claim that ‘let’ is special to GHCi
09:19:14 <typoclass> efie: it tries to see \' as one escape. try '\\'
09:19:26 <EvanR> when you want to execute an IO action do
09:19:31 <EvanR> foo <- bar
09:19:35 <latro`a> the point is that you don't actually change the same variable, but you create a new scope, which in practice is similar
09:19:38 <EvanR> when you want to define a variable
09:19:40 <EvanR> let foo = bar
09:20:24 <latro`a> to clarify, even though there can only be one value "x" at the top of a program, we use the symbol "x" in many many many function definitions
09:20:36 <donri> > let a = 1; b = a + 1 in let a = 2 in b
09:20:36 <nand`> logicalguy: “let t = 8”, “let f x = x+t”, “let t = 9”, “f 2” ==> 10
09:20:38 <lambdabot>   2
09:20:48 <donri> changing "a" didn't change "b"
09:21:06 <donri> > let a = 1; b = a + 1 in let a = 2 in (a,b) -- maybe clearer
09:21:08 <lambdabot>   (2,2)
09:21:17 <logicalguy> ok let me try it donri
09:21:39 <logicalguy> .. and nand`
09:21:40 <donri> logicalguy: well > bla in here is like ghci via lambdabot
09:21:49 <donri> > 1+1
09:21:49 <nand`> well, not quite
09:21:51 <lambdabot>   2
09:22:08 <nand`> ‘> ’ doesn't have the same sort of ‘do-block’ logic that GHCi does
09:22:15 <donri> i said "like" ;)
09:22:20 <typoclass> logicalguy: the second "let" creates a new variable t, which just happens to have the same name as the old one. from then, you can't  make any accesses of the old one anymore. you read it correctly that haskell doesn't (normally) use variables that can change. but it is a little bit hard to see in your case; you raised a good question
09:22:34 <nand`> so you can't do “> let x = 3” in lambdabot. You can do “@let x = 3” but that affects everybody
09:22:49 <nand`> you can do “let x = 3 in x” though, since that's a normal Haskell expression
09:23:02 <EvanR> variables never change, x is always x ;)
09:23:13 <logicalguy> thanks, typoclass
09:23:30 <donri> the point was that logicalguy wanted to "try it" (supposedly in ghci) but i already demoed it via lambdabot which logicalguy maybe wasn't aware of
09:25:14 <logicalguy> I hink in java as well, strings are immutable
09:25:20 <logicalguy> what's lambdabot?
09:25:32 <mekeor> the best bot ever
09:25:39 <mekeor> > 1+2*3^4
09:25:41 <lambdabot>   163
09:25:48 <donri> it's a program that runs as an irc user in here
09:26:13 <nand`> strings are immutable in Haskell too. All data is immutable. (Though, some pieces of data in fact references to memory that can be modified via I/O - the data itself arguably still doesn't change)
09:26:24 <nand`> are in fact*
09:26:26 <typoclass> logicalguy: it can evaluate haskell and do various other things. it's also available in private chat. you can read along in here for ideas; anything with "> " or "@" at the front is a lambdabot command
09:26:26 <logicalguy> oh ok i get it now, ha ha.  no wonder I was getting all confused by all the text in this window
09:26:58 <nand`> she even has cake
09:27:01 <nand`> > cake
09:27:04 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
09:27:04 <logicalguy> > shutdown -t now
09:27:05 <lambdabot>   Not in scope: `shutdown'Not in scope: `now'
09:27:21 <nand`> you're going to have to try harder than that :)
09:27:22 <logicalguy> didn't work :)
09:28:20 <efie> typoclass: thanks!
09:28:39 <donri> > let f = f in f
09:28:43 <lambdabot>   mueval-core: Time limit exceeded
09:28:50 <otters> lambdabot is a chick?
09:29:08 <mekeor> yep, a really hot but nerdy chick
09:29:12 <donri> no, it's a program, but straight geeks seem obsessed with feminizing bots.
09:29:14 <EvanR> @vixen
09:29:15 <lambdabot> I brought myself down. I impeached myself by resigning.
09:29:16 <nand`> http://www.haskell.org/wikiupload/1/13/Lambdabot.png
09:29:34 <nand`> “lambdabot is female, miss one period and she goes crazy”
09:29:35 <lillis> donri: and also boats
09:29:37 <EvanR> a fembot could be pretty nice
09:29:37 <nand`> sorry
09:29:44 <otters> yeah, straight geeks
09:30:02 <nand`> EvanR: @vixen was removed
09:30:06 <identity> I wrote a bot once called femtobot
09:30:09 <EvanR> lillis: and tropical cyclones
09:30:21 <identity> It was to diss on my friend's "nanobot", because it was supposed to be smaller and faster
09:30:33 <identity> I should've named it fembot and made it fall in love with me.
09:30:38 <logicalguy> ok guys, I'm going back to my tutorial.  laters...
09:30:39 <lillis> identity: there there
09:30:42 <nand`> nanobot sounds like something I'd have written
09:30:48 <nand`> logicalguy: you reading LYAH?
09:31:00 <logicalguy> whats lyah?
09:31:06 <lillis> learn you a haskell!
09:31:06 <donri> @where lyah
09:31:07 <latro`a> @where lyah
09:31:07 <lambdabot> http://www.learnyouahaskell.com/
09:31:07 <nand`> @where lyah
09:31:07 <lambdabot> http://www.learnyouahaskell.com/
09:31:08 <lambdabot> http://www.learnyouahaskell.com/
09:31:10 <donri> ^_^
09:31:13 <latro`a> lol
09:31:15 <identity> @where lyah
09:31:16 <lambdabot> http://www.learnyouahaskell.com/
09:31:18 <identity> I wanted to join
09:31:24 <lillis> identity: thanks for that link!
09:31:32 <logicalguy> ha ha, cool
09:31:38 <identity> ilya: You're welcome!
09:31:38 <latro`a> what were you guys' timestamps on that, lol
09:31:40 <logicalguy> no, I'm following the haskell wikibook
09:31:42 <luite> identity: you should've called it attobot. and then start it with 'attobot roll out'
09:31:42 <nand`> logicalguy: it's arguably the most popular introduction to haskell around here
09:31:43 <identity> lillis: as well
09:31:49 <latro`a> I had donri 47 latro`a 47 nand` 48
09:31:57 <identity> luite: I should have done so many things
09:31:58 <donri> i don't timestamp seconds
09:32:00 <nand`> latro`a: unfair, I was on a 3 second ping
09:32:02 <identity> Like.. finish the bot
09:32:08 <latro`a> lol ping
09:32:08 <nand`> network spike
09:32:12 <donri> but i was first here, although irc clients show your own lines instantly
09:32:19 <latro`a> I know
09:32:20 <logicalguy> ok, thanks, nand` I will try it out
09:32:25 <lillis> donri: the source of many arguments over the time..
09:32:28 <latro`a> but with 3 parties we should be able to resolve :p
09:32:29 <donri> :)
09:32:35 <nand`> I was first here too :(
09:32:37 <nand`> yeah
09:32:37 <nand`> well
09:32:37 <nand`> there's an unambiguous way to resolve this
09:32:41 <otters> @where lyah
09:32:41 <nand`> public logs
09:32:42 <lambdabot> http://www.learnyouahaskell.com/
09:32:43 <donri> also people can get things in different order because they're on different networks anyway
09:32:51 <donri> uh servers on the same network
09:32:57 <latro`a> ah yes
09:32:59 <nand`> http://tunes.org/~nef/logs/haskell/12.08.17
09:33:08 <nand`> donri, latro`a, nand`
09:33:16 <latro`a> all three of us are on different ones
09:33:19 <otters> same here
09:33:19 <sellout42> Using Alex, is there any way to specify rules in terms of Unicode categories (or other Unicode properties)? EG, I want any codepoint in the Math_Symbol category to be valid in an operator, but don't want to explicitly list all ~1k of them.
09:33:36 <nand`> donri: ah, true
09:33:47 <latro`a> interesting, my end is the same as the public
09:34:18 <identity> We need a bot that it directly connected to each node and judges who said something first.
09:34:22 <identity> is*
09:34:27 <latro`a> also, why are my seconds not the same as the bot
09:34:33 <latro`a> do I need to sync my clock or does it >.>
09:34:38 <latro`a> like, not just not the same but way off
09:34:48 <latro`a> 20 seconds difference
09:34:54 <nand`> identity: we could just each track the TAI and compare our local sent times against TAI, thus making network ping irrelevant
09:35:06 <donri> preferably with an atomic clock with nanoprecision that accounts for leap seconds
09:35:10 <latro`a> lol
09:35:12 <nand`> :)
09:35:12 <EvanR> heh good luck with TAI in haskell ;)
09:35:17 <nand`> TAI doesn't have leap seconds, mind
09:35:27 <nand`> that's why it's like 20 seconds behind UTC
09:35:36 <EvanR> yeah, you wouldnt need to worry about leap seconds
09:35:43 <sellout42> latro`a: The bot's on local solar time ;)
09:35:44 <typoclass> yeah clearly leap seconds are at the core of any solution ...
09:35:47 <EvanR> if everyone had the same absolute time source
09:36:18 <identity> nand`: Perhaps, but that means one user could intentionally and maliciously spoof his own times to prove he was the first to say something useful
09:36:21 <identity> I think we need a neutral party.
09:36:23 <EvanR> typoclass: leap second support is top of my list for calendar apps
09:36:31 <identity> But then again.. how neutral will the neutral part be? Open source it, perhaps.
09:36:33 <nand`> identity: we're all honest men in here are we not? :)
09:36:48 <identity> nand`: If I say "Of course we are." will that help?
09:37:00 <nand`> naturally
09:37:12 <identity> Unless I'm dishonest.
09:37:23 <nand`> Or I am.
09:37:42 <nand`> I could be lying right now
09:37:49 <nand`> (there's a fun paradox)
09:37:51 <identity> Dude. I'm drunk. Stop that shit.
09:38:06 <identity> Or maybe I'm sober.
09:38:27 <identity> I'm not sure myself now. I think I've confused myself.
09:38:33 <identity> Let me get another beer and think about it.
09:38:45 * latro`a gives identity salvia instead
09:38:48 <latro`a> have fun
09:38:52 <donri> you're not drunk, you're *a* drunk
09:39:07 <nand`> that's fairly ambiguous. I had salvia just the other day
09:39:10 <EvanR> identity salvia, leaves you in the same fucked up state you started in
09:39:21 <nand`> EvanR: :)
09:39:21 <latro`a> lol
09:39:51 <latro`a> I would've expected that joke from donri
09:39:57 <latro`a> as it is much like the lojban broken light joke >.>
09:40:54 <identity> Like the State monad with a broken put?
09:40:56 <identity> oh my god
09:41:08 <latro`a> (How many lojbanists does it take to change a broken light bulb? Two. One to figure out what to change it into, and another to figure out what broken light is)
09:41:11 <identity> donri: I am both drunk and *a* drunk.
09:41:18 <latro`a> (doesn't really make sense without explaining some other stuff, though)
09:41:29 <identity> but I justify my borderline alcoholism with the fact that I am a student
09:41:58 <donri> lo mi mamta cu mabla co'e i sa'e lo mi mamta be do cu go'i vau ga'isai le'o zo'o
09:42:10 <identity> I Denmark, it comes with the territory. We might as well have a class called "Beer drinking"
09:42:12 <atriq> Are you allowed to do "data Foo = Foo {foo :: Int} | Bar {bar :: Char}"?
09:42:25 <avpx> atriq: Yeah
09:42:43 <atriq> Actually, do I want to?
09:42:44 <atriq> Hmm
09:42:53 <latro`a> .u'i doi la donri
09:43:01 <avpx> Lojban?
09:43:01 <nand`> you can even do something like
09:43:20 <nand`> data Foo { foo :: Int} | Bar { foo :: Int, bar :: Char }
09:43:26 <nand`> Data Foo = *
09:43:31 <nand`> d*
09:43:33 <nand`> :(
09:43:41 <ion> That went well.
09:43:47 <donri> ko se lojbo doi selke'i remna
09:43:49 <identity> Ég get líka talað tungumál sem flestir ykkar skilja ekkert íEn ég helt að localð á skelinni sskíta á sig og þið sjáið bara rugl.
09:43:50 <atriq> I think I see what you mean
09:44:00 <identity> Yeah. Shell or irssi locale shat itself.
09:44:01 <donri> y sa'e ko se si lojbo
09:44:28 <latro`a> when you understand what record syntax desugars to it's not too hard to see what you can and can't do
09:44:45 <latro`a> with it, I mean
09:45:28 <donri> identity: jag tycker inte om ditt val av teckenkodning :(
09:45:31 <latro`a> specifically, data Foo = Foo {foo :: Int} | Bar {foo :: Int} makes a foo :: Foo -> Int that will match on both Foo and Bar constructors
09:45:46 <identity> donri: Og jeg synes fandme ikke særlig godt om dit svensk.
09:46:16 <donri> \o/
09:47:16 <donri> atriq: you can, but if you do what nand` suggests "bar" is partial
09:47:26 <atriq> Okay
09:47:41 <atriq> I had a vague memory of that being "Breaks Haskell and kills puppies"
09:48:37 <avpx> Eh? No, record syntax isn't *that* bad.
09:48:48 <atriq> I meant the partial-iness
09:48:57 <avpx> Ah.
09:49:03 <identity> It is inadequate for many things though.
09:49:08 <EvanR> partialness eats your babies
09:49:13 <Cale> In a case like that, you'd probably not use the field names as functions.
09:49:55 <nand`> partialness murders your kittens
09:50:03 <EvanR> > head []
09:50:05 <lambdabot>   *Exception: Prelude.head: empty list
09:50:07 <EvanR> oh no the horror
09:50:11 <nand`> EvanR: stop it! think of the kittens
09:50:12 <donri> i'm partial to totality
09:50:23 <nand`> I'm totally partial
09:50:25 <donri> like, totally partial
09:50:26 <EvanR> id like to partial functions vs evil mangler crossover
09:50:31 <EvanR> see
09:50:43 <nand`> two wrongs make a right?
09:50:55 <donri> two lefts make a turn over
09:51:09 <EvanR> two lefts == two rights
09:51:23 <identity> I am not totally partial to totally partial functions, but I am partial to totally total functions
09:51:24 <EvanR> think about that for a minute
09:51:24 <donri> three lefts make a right
09:51:26 <identity> or something
09:51:27 <nand`> > Left () >> Left ()
09:51:29 <lambdabot>   Left ()
09:51:39 <avpx> > Right () >> Right ()
09:51:41 <lambdabot>   Right ()
09:51:50 <avpx> EvanR: I'm starting to doubt this story of yours.
09:51:54 <nand`> EvanR: clearly, roads form a group
09:52:12 <EvanR> the dihedral group of order 4 or something
09:52:31 <avpx> Clearly, roads form a category.
09:52:40 <avpx> Objects are houses and arrows are roads between them.
09:53:06 <nand`> EvanR: yeah
09:53:15 <johnw> in a city with a gentrification program, the roads are usually catamorphic
09:54:18 * avpx reads a couple more chapters in Mac Lane
09:59:25 <neothemachine> someone want to take a journey on Arrows?
10:01:36 <armlesshobo> neothemachine: looks interesting, but I'm still on level noob :\
10:01:56 <nand`> neothemachine: you could try reading http://ertes.de/new/tutorials/arrows.html
10:02:14 <johnw> nice article, thanks!
10:03:02 <neothemachine> ok I'll try it: I know that I can express "foo a = (bar1 a, bar2 a)" as "foo = bar1 &&& bar2" or also "foo (a1,a2) = (bar1 a1, bar2 a2)" as "foo = bar1 *** bar2"
10:03:03 <neothemachine> right?
10:03:24 <nand`> yes
10:03:48 <neothemachine> now, how could I express the following as arrows: foo (a1,a2) (b1,b2) = (bar1 a1 b1, bar2 a2 b2)
10:05:17 <tromp_> :t (&&&)
10:05:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:06:25 <latro`a> is there a way to apply a pair of functions to a pair of arguments in the arrow structure?
10:06:48 <ocharles> :t (&&)
10:06:48 <neothemachine> don't know, but I thought it must somehow fit into the scheme
10:06:49 <luite> (***)
10:06:50 <lambdabot> Bool -> Bool -> Bool
10:06:56 <ocharles> :t (&&&)
10:06:58 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:07:06 <ocharles> :t (***)
10:07:08 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:07:33 <neothemachine> after all, when I just do bar1 *** bar2 then I get a tuple which the rest function
10:07:56 <neothemachine> and then I would need to transform this tuple into a new arrow or something so that it can be used for the second/first argument
10:08:02 <luite> hm, right not quite (***), it's uncurry (***)
10:08:14 <latro`a> :t uncurry (***)
10:08:16 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
10:08:29 <latro`a> that takes a pair of arrows
10:08:45 <latro`a> but a pair of functions is a pair of arrows, so touche
10:09:02 <nand`> foo (a1,a2) (b1,b2) = (bar1 a1 b1, bar2 a2 b2) arrow-ically would be foo (a1,a2) = arr $ bar1 a1 *** bar2 a2
10:09:11 <nand`> which could probably be further transformed
10:09:32 <neothemachine> we really need a minification bot here :D
10:09:40 <latro`a> minification?
10:09:46 <armlesshobo> condenser
10:09:46 <nand`> @pl foo (a1, a2) = bar1 a1 *** bar2 a2
10:09:47 <lambdabot> foo = uncurry ((. bar2) . (***) . bar1)
10:09:47 <armlesshobo> lol
10:09:55 <latro`a> @pl is sorta like that
10:09:56 <lambdabot> is sorta like that
10:10:02 <latro`a> (knew that would happen)
10:10:25 <neothemachine> hmmm
10:10:26 <latro`a> @pl foo (a1,a2) (b1,b2) = (bar1 a1 b1,bar2 a2 b2)
10:10:27 <lambdabot> foo = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. bar2) . flip . (((.) . (,)) .) . bar1)
10:10:30 <latro`a> :|
10:11:00 <latro`a> @pl foo a1 a2 b1 b2 = (bar1 a1 b1,bar2 a2 b2)
10:11:01 <lambdabot> foo = (. bar2) . flip . (((.) . (,)) .) . bar1
10:11:01 <neothemachine> I'd like a way that scales, e.g. for 3, 4 argument tuples
10:11:05 <latro`a> I like how that's shorter
10:11:18 <latro`a> though maybe it just converts to that and then does it?
10:11:30 * hackagebot threadmanager 0.1.5 - Simple thread management (BrianLewis)
10:11:39 <latro`a> :t (((.) . (,)) .)
10:11:41 <lambdabot> forall a (f :: * -> *) a1 (f1 :: * -> *). (Functor f, Functor f1) => f1 a1 -> f1 (f a -> f (a1, a))
10:11:49 <latro`a> dammit lambdabot
10:11:52 <latro`a> silly (.) = fmap
10:12:28 <neothemachine> @pl foo (a1,a2) (b1,b2) (c1,c2) = (bar1 a1 b1 c1, bar2 a2 b2 c2)
10:12:31 <lambdabot> foo = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . (. bar2) . flip . (((.) .
10:12:31 <lambdabot> flip . (((.) . (,)) .)) .) . bar1)
10:12:32 <lambdabot> optimization suspended, use @pl-resume to continue.
10:12:36 <latro`a> lol
10:12:36 <nand`> join (***) . bar1 *** bar2 -- something like this?
10:12:52 <nand`> hmm no
10:12:55 <nand`> not quite
10:12:57 <nand`> uncurry (***) might do it
10:13:15 <nand`> oh, save for precedence
10:13:28 <nand`> :t uncurry (***) . (?bar1 *** ?bar2)
10:13:30 <lambdabot> forall (a :: * -> * -> *) b c b' c' (a1 :: * -> * -> *) b1 b'1. (Arrow a, ?bar1::a1 b1 (a b c), ?bar2::a1 b'1 (a b' c'), Arrow a1, Functor (a1 (b1, b'1))) => a1 (b1, b'1) (a (b, b') (c, c'))
10:13:43 <nand`> looks right
10:13:48 <neothemachine> lol
10:13:52 <t7> haskell Strings are UTF8 right?
10:13:53 <neothemachine> you can see that? oh boy^^
10:13:55 <latro`a> what is the ?
10:13:58 <nand`> t7: wrong
10:14:04 <ion> t7: Nope. But they are Unicode.
10:14:06 <nand`> latro`a: implicit parameters
10:14:11 <latro`a> wat
10:14:20 <nand`> :t ?f ()
10:14:21 <lambdabot> forall t. (?f::() -> t) => t
10:14:26 <latro`a> uh
10:14:28 <latro`a> what
10:14:38 <neothemachine> yeah well, implicit stuff doesn't matter at the moment I guess
10:14:42 <nand`> it reads: f () has type ‘t’ when f :: () -> t
10:15:13 <neothemachine> so how would I use uncurry for my example exactly?
10:15:30 <nand`> back to the example earlier, it's basically ‘a (b1, b2) (a (c1, c2) (d1, d2))’ and if you instantiate ‘a’ as -> that turns into
10:15:36 <nand`> (b1, b2) -> (c1, c2) -> (d1, d2)
10:15:53 <augur> what the hell is this ? stuff
10:15:59 <nand`> the implicit stuff says bar1 has type b1 -> c1 -> d1
10:16:04 <nand`> and bar2 has type b2 -> c2 -> d2
10:16:31 <typoclass> augur: it's the implicit parameters extension
10:16:55 <augur> typoclass: i dont know this extension
10:18:13 <ion> > let { foo :: (?f :: Integer -> Integer) => Integer; foo = ?f 42 } in let { ?f = (+1) } in foo
10:18:15 <lambdabot>   43
10:18:22 <neothemachine> I'm back in a while, eating something
10:18:53 <typoclass> augur: it's not very difficult, you can declare "f :: (?moarDebug :: Bool) => whatever" and then call it with either "f" or "let ?moarDebug = True in f". it's kind of in the same area as the Reader monad, or of course passing along tons of arguments the plain way
10:19:15 <augur> oic
10:19:17 <typoclass> (i left out a little there, but that's the gist)
10:19:32 <augur> it lets you pass arguments to constraints
10:19:37 <augur> well
10:19:40 <augur> not real constraints
10:19:44 <nand`> of course, it's not much different from
10:19:54 <nand`> > let foo f = f 42 in foo (+1)
10:19:55 <lambdabot>   43
10:19:56 <augur> hm.
10:19:57 <typoclass> yeah, just arguments to regular functions. i don't think it has to do with constraints
10:20:15 <nand`> I just use it when showing types on lambdabot involving functions that are assumed to float in from somewhere else
10:20:19 <augur> what does f by itself do??
10:20:34 <ion> typoclass: Well… GHC implements constraints as arguments to regular functions. ;-)
10:21:23 <ion> > let ?f = 42 in ?f  -- augur
10:21:24 <lambdabot>   42
10:21:59 <augur> ion: no i mean, like, if you have this implicit argument but you dont specify it, what happens
10:22:15 <ion> > let { foo :: (?f :: Integer -> Integer) => Integer; foo = ?f 42 } in foo
10:22:16 <lambdabot>   mueval-core: internal error: PAP object entered!
10:22:17 <typoclass> nand`: yeah it's not very different in that case, but suppose you're in main, you want to turn on (say) a flag "?verbose :: Bool", and the next function that would read the ?verbose flag is 17 levels down in the call graph. you can either introduce a "verbose :: Bool" in all of those 17 functions and just pass it through, or you can move them all into a Reader, or you can turn on ImplicitParams, which is the least invasive
10:22:17 <lambdabot>      (GHC version 6.12.3 f...
10:22:25 <typoclass> ... at least that's how i see it
10:22:26 <ion> Uh. That has been fixed in a newer version of GHC.
10:22:34 <ion> Now it says “Unbound implicit parameter blahblah”
10:23:05 <augur> so then whats the point of implicit parameters :|
10:23:13 <nand`> typoclass: you still have to type out the verbose constraint everywhere though :(
10:23:25 <zuserm> Is ":m - Prelude" in ghci broken for anyone else? I'm on ghci 7.4.1
10:23:43 <typoclass> augur: it has to be bound somewhere; main is the last chance; if even the main function doesn't "let" it, you get a compiler error
10:24:04 <augur> typoclass: yeah but whats the point of it at all
10:24:14 <augur> why not just define it without using an implicit parameter
10:24:19 <ion> augur: Well… I don’t know if that was even considered when defining the extension, but it *is* useful as a pseudo-hole.
10:24:59 <typoclass> augur: yeah, but then you _have_ to pass it through whether that function needs it or not
10:25:17 <augur> typoclass: no no i mean
10:25:28 <sclv> so ghc has a bug rolldown process
10:25:29 <augur> just define f with no implicit
10:25:43 <augur> just fix the value of the implicit
10:25:44 <sclv> where like if a bug is idle and not worked on for a certain length of time it goes from high to medium
10:25:47 <sclv> and soforth
10:25:50 <augur> since its going to be fixed anyway
10:25:57 <sclv> so that we just don't get highs that are increasingly meaningless
10:26:08 <nand`> augur: I got the impression that you would be defining ?verbose based on IO
10:26:09 <sclv> and then if someone objects they can move it back up, but we clear out the stuff nobody cares about
10:26:16 <sclv> does anybody know where that process comes from?
10:26:20 <sclv> like is it industry standard?
10:26:26 <sclv> are there blogs or books or whatever that discuss it?
10:27:06 <ion> I hear it was discussed on #haskell on 2012-08-17.
10:27:44 <sclv> thank you :-P
10:28:09 <sclv> it's a really good idea, so i'd like to find some documentation to refer others too
10:28:39 <parcs`> maybe it'll be worthwhile to ask in #ghc
10:29:37 <typoclass> augur: i think i'm missing something. to me, you sounded like "why bother writing a function 'map' which takes a list; before you can run your program, that list argument will have to be some concrete, actual list anyway; why bother with the parameter and why not fix it right there"
10:29:53 <neothemachine> ok watching MacGyver now, maybe that inspires me to a solution for the arrows
10:30:44 <jfischoff> how would you resample an image with reps?
10:30:50 <jfischoff> *repa
10:30:58 <augur> typoclass: maybe i just dont understand these implicits
10:31:15 <jfischoff> as in resize it and apply some filtering to the pixels
10:31:22 <jfischoff> like bilinear etc
10:34:04 <typoclass> augur: i think implicit parameters are really only a smallish extension to regular parameters. they are just, when calling a function, a tiny bit more flexible about where you can nail down the parameter's value
10:34:17 <typoclass> lemme see if i can come up with an example ...
10:35:08 <augur> typoclass: nah its ok, dont worry
10:35:51 <nand`> I don't think MacGuyver would make a very good Haskeller
10:36:16 <nand`> “patch it together with glue and duct tape” approaches tend to be contrary to the spirit
10:38:12 <nh2> is there a cabal install --no-install? I don't want to type cabal install --only-dependencies && cabal configure && cabal build
10:38:54 <dcoutts_> nh2: no, sorry
10:39:12 <dcoutts_> nh2: but we're moving in the direction of automatically doing dependent steps
10:39:28 <t7> cabal remove plox
10:39:42 <nh2> dcoutts_: do you think if I make a feature request I've got a chance?
10:40:04 <dcoutts_> nh2: no, we're not likely to add a specific command to do that
10:40:10 <dgpratt> I have a vague remembrance of reading an article/blog post/paper/book excerpt some time ago about coding a Chess playing algorithm in Haskell; anyone have a clue what I'm on about?
10:40:45 <dcoutts_> nh2: what we've discussed is making build automatically do a configure if needed, and perhaps also making configure automatically install dependencies if needed
10:41:02 <dcoutts_> nh2: and that'd cover your use case: you'd just do cabal build
10:41:09 <typoclass> dcoutts_: oooh nice :)
10:41:12 <nh2> dcoutts_: that sounds very sane
10:41:24 <dcoutts_> though I think we'd need to make it interactive at that point
10:41:30 * hackagebot tnet 0.0.1 - Library for encoding/decoding TNET strings for PGI (HarryTerkelsen)
10:41:32 * hackagebot network-pgi 0.0.1 - Library for writing PGI applications (HarryTerkelsen)
10:41:42 <dcoutts_> ie a confirmation that it'll go and install a bunch of things
10:42:15 <nh2> dcoutts_: I'm always a bit scared of interactive-only commands as I cannot script them (unless they have something like -y of course)
10:42:55 <logicalguy> Hi I'm reading the introductory chapter of lyah now, and I have a question: a script has two functions doubleMe x = x*2 and doubleUs x y = x*2 + y*2.  Now when I load it into the interpreter, because of variable immutability, will the two x's be different?
10:43:09 <dcoutts_> nh2: right, we currently have it all non-interactive, and I'm not overjoyed to move to an interactive mode, but I think for some of these big steps it does need confirmation
10:43:30 <dcoutts_> nh2: and if we did that, then certainly we'd have a switch to ask no questions, like we do for cabal init
10:43:33 <latro`a> logicalguy, variables in functions have their own scope
10:43:34 <nh2> dcoutts_: I basically want to write a readme for my users saying "install haskell-platform, then run cabal build"
10:43:36 <SegFaultAX|work2> logicalguy: Those x's are actually the name of formal arguments to the function.
10:43:45 <latro`a> imperative languages do the same thing
10:43:48 <typoclass> dcoutts_: you could also print out the necessary cabal command. e.g. "cabal configure could not blah. You need to install X and Y. Try the command:\n    cabal install X Y". that way you can highlight it, middle-click, and hit enter. or edit it if desired
10:44:08 <logicalguy> so they are just placeholders and are therefore treated differently
10:44:10 <nh2> dcoutts_: and currently I have to say "... then run cabal --install --no-install... then run ... configure ... then run ... build"
10:44:20 <dcoutts_> typoclass: true, though making it 'y' is probably nicer
10:44:22 <nh2> normally I'd just put a makefile, but that doesn't work too well on windows
10:44:44 <dcoutts_> nh2: but you can also see my point that it could be surprising for a user that when they do build, it goes away and installs loads of stuff
10:44:45 <roconnor> edwardk: http://arxiv.org/abs/1202.2919 seems to also mention the fact that duplicate traversals are disallowed by the traversable laws.
10:44:55 <latro`a> logicalguy, is haskell your first language?
10:44:59 <latro`a> (I assume not)
10:45:11 <edwardk> nice
10:45:17 <dcoutts_> nh2: we'd also need good control over package environments
10:45:28 <logicalguy> no, but I'm wary of carrying my previous notions to this language already :)
10:45:35 <roconnor> edwardk: nice expect I no longer have an original result :P
10:45:44 <SegFaultAX|work2> logicalguy: What other languages have you used?
10:46:00 <logicalguy> c/c++/java/bits of python/vb6
10:46:07 <nh2> dcoutts_: definitely I can see that, and as long as it is possible to turn it off with some switch for automatisation, interactive-by-default is even nicer IMO
10:46:21 <latro`a> for the most part scoping rules aren't that much different in haskell than elsewhere
10:46:23 <otters> logicalguy: the x's are just naming the arguments to the function
10:46:31 <logicalguy> ok, I get it
10:46:32 <latro`a> one important difference is that definitions don't have to precede usage
10:46:48 <logicalguy> thanks, guys, latro`a otters SegFaultAX
10:47:01 <logicalguy> oh, ok
10:47:10 <edwardk> roconnor: well its still new to me!
10:47:13 <otters> > let f x = x + 1 in f 3
10:47:14 <lambdabot>   4
10:47:15 <SegFaultAX|work2> logicalguy: Then it works exactly as in C. In other words, in `int foo(int a) {...} int bar(int a) {...}` the as don't interfere with eachother.
10:47:15 <otters> bam
10:47:16 <edwardk> and you did a good job resolving it ;)
10:47:27 <covi> http://hpaste.org/73288 Hi all. I want to write a simple script that just copies some files to some dir. I want to have a recursiveExpand function that receives a FilePath as input, and outputs all files in it or its subdirs. I'm using the doesFileExist and doesDirectoryExist functions in System.Directory. However, they return IO Bool instead of Bool (which can be used in a guard). I really don't know how to somehow circumvent this problem and write the fun
10:47:42 <roconnor> edwardk: interestingly that paper has a consume version of traversable where consume :: Applicative f => (t a -> b) -> t (f a) -> f b
10:47:48 <logicalguy> ok, thanks, SegFaultAX
10:48:01 <edwardk> hrmm
10:48:18 <SegFaultAX|work2> logicalguy: Sure thing. Good luck!
10:48:35 <edwardk> good of them to use the right name for traversing ;)
10:48:38 <latro`a> covi, first off I'd suggest not just pattern match failing if the user gives the wrong number of arguments
10:49:06 <edwardk> i'm sure you were crushed that they didn't call them multilenses ;)
10:49:29 <covi> latro`a: instead?
10:49:31 <roconnor> edwardk: well, I'm thinking of reserving multilense for the monomorphic version of traversals
10:49:40 <nand`> ‘multilens’ for me would be a traversal
10:49:42 <latro`a> (fileListPath : destDir : _) <- getArgs
10:50:01 <edwardk> nand`: exactly
10:50:09 <latro`a> either that, or a somewhat more involved approach where you scold the user for giving the wrong number of arguments
10:50:53 <covi> latro`a: I see
10:50:55 <typoclass> covi: if you have an IO Something, you can execute it using "<-" (latro`a gave an example). for this, you need to be in IO, such as in your main function
10:50:57 <latro`a> anyway, recursiveExpand has to be something like FilePath -> IO [[FilePath]]
10:51:43 <edwardk> roconnor: besides, i've moved on to working with machines now, lenses are old ;)
10:51:43 <latro`a> the input doesn't depend on the IO monad necessarily, it can just be a string, but the procedure you use does, so the output is an IO value
10:51:51 <roconnor> ha
10:51:58 <edwardk> https://github.com/ekmett/machines
10:52:22 <edwardk> basically stabbing at pipes/conduits
10:52:22 <covi> Ok. Then I can use a do block in the definition of recursiveExpand. But after I get the two Bool values, I don't know how to proceed. If..then..else is different from the counterpart in imperative langs
10:52:46 <roconnor> edwardk: ah the other big ticket haskell item
10:52:50 <edwardk> yep
10:53:06 <latro`a> in the IO monad it's not so different, actually
10:53:22 <roconnor> you can always tell what is interesting going on in Haskell by looking at Twan's blog
10:53:24 <latro`a> (if then else that is)
10:53:53 <avpx> latro`a: Yeah, but that's a bit of an advanced topic for someone learning basic Haskell expressions :p
10:54:00 <latro`a> a bit, yeah
10:54:11 <nand`> “Latest commit: Switched from Identity to Id”
10:54:30 <nand`> I see this library is also essentially going to be 100 different ways of writing id
10:55:20 <covi> latro`a: I have googled and you're right. But, I wonder, is if..then..else recommended in such senario?
10:55:27 <latro`a> I'm writing up a suggestion
10:56:03 <edwardk> nand`: hahaha
10:56:06 <edwardk> nand`: needed missing instances
10:56:15 <covi> latro`a: thx
10:56:52 <edwardk> nand`: basically you build machines using plans, functions, mealy or moore, and machines are generalized pipes, they can have more than one input (see tee)
10:57:08 <ion> edwardk: Sounds neat.
10:57:18 <nand`> looking at the definition of Step atm
10:57:20 <edwardk> you can tie off inputs with sources, and or pre-feed some of the processes data with supply
10:57:27 <nand`> so I can understand Stop and Yield; but how does Await work?
10:57:30 <edwardk> then you can run the whole machine
10:57:47 <edwardk> await is a little bit scary because it is trying to avoid having to map over the inside of 'k i'
10:58:00 <edwardk> think of await as two arguments Await (k i r) r
10:58:17 <edwardk> its a request for input, and what to do when it goes wrong
10:58:18 <roconnor> edwardk: do you know how to express polymorpic update lenses using the isomorphism representation of a ~ Ex c. (c, b) ?
10:58:24 <nand`> edwardk: I see
10:58:30 <typoclass> edwardk: so the 'pipes' and 'conduit' packages are ancestors of that?
10:58:37 <edwardk> roconnor: i know the model, yes
10:58:46 <edwardk> oh
10:58:52 <MostAwesomeDude> typoclass: They're different implementations of the same concept.
10:58:54 <edwardk> you mean how to make them polymorphic
10:58:59 <roconnor> ya
10:59:23 <typoclass> MostAwesomeDude: right. ancestors in terms of ideas and inspiration, not really implementation
10:59:26 <roconnor> edwardk: you seem have polymorphic isomorphisms, so maybe you understand.
10:59:37 <edwardk> yes exists r. (a -> (r, c), (r,d) -> b)
10:59:54 <roconnor> what's the law on that?
10:59:56 <edwardk> where the family structure holds so you can choose c = d, a = b
11:00:02 <roconnor> hmm
11:00:11 <edwardk> typoclass: yes
11:00:35 <edwardk> basically its my 'not invented here' knee jerk reaction to both ;)
11:00:57 <MostAwesomeDude> edwardk:
11:00:57 <edwardk> and its me trying to roll up a bunch of what we do with machines and stream processing here at capital iq
11:00:59 <MostAwesomeDude> Urg.
11:01:23 <MostAwesomeDude> edwardk: Well, my main complaint of conduits is that there are certain operations that are near-impossible to formulate correctly.
11:01:27 <hellertime> can anyone familiar with Aeson tell me if its possible to extend a Object value once constructed?
11:01:45 <MostAwesomeDude> The canonical problem in async networking is constructing a simultaneous duplex proxy.
11:01:53 <MostAwesomeDude> And good luck making one in conduits.
11:01:53 <edwardk> i started with pure machines, so i still need to do a lot of the conduit'ish resource management
11:02:00 <pcapriotti> edwardk: it's unfortunate that the type with the Monad instance and the one that can be composed are separate, if I understand correctly
11:02:02 <Enigmagic> hellertime: what do you mean by 'extend'?
11:02:28 <edwardk> pcapriotti: its done deliberately. you compile the machine, then you work with them categorically
11:02:29 <jfischoff> hellertime: you can unpack it insert new values
11:02:39 <edwardk> also the categorical machines will be getting an applicative structure of their own
11:02:42 <hellertime> that would work
11:02:50 <edwardk> so you need to have the distinction
11:02:52 <pcapriotti> edwardk: but it's a lot convenient to have a single type
11:03:10 <edwardk> its convenient, but it also precludes you from talking about certain kinds of machine compositon
11:03:17 <edwardk> there are two applicative structures on process
11:03:20 <hellertime> I don't see a toList function or anthing like that...
11:03:24 <edwardk> one is the monad for awaiting, yielding
11:03:38 <edwardk> the other is gluing together the yielded answers of different machines on the same input
11:03:48 <jfischoff> hellertime: pattern match on it and get the underlying Data.Hashmap.Strict object.
11:03:48 <edwardk> none of the other libraries expose this second structure
11:03:56 <jfischoff> @hoogle Hashmap
11:03:57 <lambdabot> package hashmap
11:04:11 <edwardk> so i'm taking a very distinct step towards a different point in the design space
11:04:22 <pcapriotti> edwardk: can you elaborate on the second Applicative instance?
11:04:22 <edwardk> you get a number of benefits working this way
11:04:24 <hellertime> ah right. I'll try that approach
11:04:25 <pcapriotti> I don't think I understand
11:04:35 <jfischoff> hellertime: http://hackage.haskell.org/packages/archive/unordered-containers/0.1.3.0/doc/html/Data-HashMap-Strict.html
11:04:58 <edwardk> pcapriotti: lets say you have two machines that don't have an extra 'result' type, that just take inputs and yield outputs
11:05:00 <jfischoff> hellertime: insert is the function you want
11:05:15 <edwardk> pcapriotti: now, i can run both of those machines simultaneously on the same input
11:05:24 <edwardk> and i can merge their answers
11:05:51 <hellertime> jfischoff: looks like I first have to cast off all the extra wrapped put on by yesod-persist, but I think this will work
11:05:59 <pcapriotti> merge how? alternate?
11:06:27 <jfischoff> hellertime: sounds right (never used yesod)
11:06:35 <edwardk> no, literally merge, take the first output of one and apply it as a function to the first output of the second, repeat
11:06:42 <edwardk> pure for that applicative is the repetition machine
11:06:48 <edwardk> its like a ziplist with input
11:07:06 <edwardk> now when my machines are things like monoidal reductions this becomes fairly useful
11:07:10 <pcapriotti> hm... but the outputs can be interleaved arbitrarily, say the first yields twice while the second yields once
11:07:14 <efie> what is the name of the package which contains "Network.CGI.Protocol"? I'd like to cabal install it but do not know what to type
11:07:31 <danil> edwardk: in the monoidal view of applicative that's like getting (length &&& sum) in one fold, right?
11:07:43 <edwardk> then you merge the first answers, and the last one gets dropped (like a ziplist)
11:08:05 <edwardk> its more useful for things that generate a summary every step as they run, its a sound applicative, its just a bit odd to get used to
11:08:19 <edwardk> danil: yes
11:08:51 <jfischoff> @hoogle Network.CGI.Protocol
11:08:52 <lambdabot> Network.CGI.Protocol module Network.CGI.Protocol
11:08:52 <lambdabot> package protocol-buffers
11:08:52 <lambdabot> package protocol-buffers-descriptor
11:09:07 <jfischoff> ^ efie
11:09:09 <pcapriotti> hm, I'll think about it
11:09:48 <edwardk> pcapriotti: anyways, both pipes and conduits have converged to essentially the same design, so i wanted to try something different based on something Apocalisp and pchiusano were playing with at the office a week back
11:10:14 <edwardk> and the use of tees and sources here is quite nice
11:10:25 <pcapriotti> sure, that's great, I'll definitely study your code in more detail
11:10:30 <efie> jfischoff: thanks, where can I this info at http://www.haskell.org/hoogle/?hoogle=Network.CGI.Protocol when I dont want to disturb lamdabot?
11:10:40 <pcapriotti> there's definitely something to learn there for me :)
11:10:44 <edwardk> pcapriotti: its definitely pre-alpha at this point
11:11:00 <jfischoff> efie: google for hoogle or hayoo. Hayoo is better in my opinion
11:11:41 <efie> jfischoff:  my link contains the hoogle search
11:12:13 <jfischoff> efie: oh sorry what are you asking?
11:12:56 <n00b6502> ok.. runState  arg1 arg2  ... runState (do block....)  initialState   ....<---- that lets me apply sucessive operations to modify a state object, with syntactic sugar for  passing the updated state along... funal return value combines resulting state and final value....?
11:13:42 <otters> final return value is the modified state
11:13:47 <otters> :t runState
11:13:48 <lambdabot> forall s a. State s a -> s -> (a, s)
11:14:00 <otters> runState (modify (+1)) 3
11:14:03 <otters> > runState (modify (+1)) 3
11:14:05 <lambdabot>   ((),4)
11:15:01 <n00b6502> runState (do{  modify (+10); modify (+100)  })   3
11:15:09 <n00b6502> >runState (do{  modify (+10); modify (+100)  })   3
11:15:14 <roconnor> edwardk: I think I can prove their conjecture at the end of that paper that every traversable container is a finitary container.
11:15:20 <danil> n00b6502: yeah, that's right.  "flip runState initialState $ do ..." may look prettier
11:15:21 <efie> jfischoff: I was searching for a "replace" function http://www.haskell.org/hoogle/?hoogle=replace In the seach result I see that the "Network.CGI.Protocol" contains the function, but where is the info that I need package X to import Network.CGI.Protocol?
11:15:25 <otters> > runState (modify (+1) >> modify (+100)) 3
11:15:27 <lambdabot>   ((),104)
11:15:28 <geekosaur> n00b6502, space after >
11:15:31 <edwardk> finite or countable?
11:16:01 <MostAwesomeDude> > flip runState 3 $ do { modify (^3); return 1 }
11:16:03 <lambdabot>   (1,27)
11:16:22 <roconnor> edwardk: their definition of finatary container is a bit misleading.  List is a finitary container for example.
11:16:31 <n00b6502> so i can use that for my parser, with functions that take a tuple instead (sourcestring,objectBuilder) ..and final state is spat out..
11:16:43 <otters> yeah
11:16:44 <n00b6502> (i'm guessing there's dedicated parsing libs.. but)
11:16:50 <roconnor> edwardk: each instance can only contain a finite number of elements.
11:16:51 <jfischoff> efie: its right there. its the first word on the second line of the result I think...
11:16:56 <timthelion> If I have a list of [a -> b] and a longer list of [a] and I want a list of [b] what should I do?
11:17:00 <n00b6502> (i need to build a simple case without the libs to understand it)
11:17:12 <roconnor> edwardk: I guess this is modulo coinductve stuff I guess.
11:17:18 <roconnor> s/I guess//
11:17:26 <danil> efie: Though depending on a CGI package for a 1-line replace function may not be wise.
11:17:36 <n00b6502> "unfortunately no one can be told what the monad is, you have to invent it for yourself"
11:17:59 <MostAwesomeDude> timthelion: You mean that you have more as than functions that will make bs?
11:18:13 <timthelion> n00b6502: O shut it, monads are simple, they are just pairings of typeclasses(which follow the monadic laws) and data types.
11:18:20 <n00b6502> something like that. i'm not going to understand this if I just cut-paste into samplecode
11:18:27 <efie> jfischoff: oh yes, thanks :)
11:18:33 <n00b6502> timethelion its a simple idea but the libraries take some getting used to....
11:18:35 <efie> danil: um, right
11:18:40 <jfischoff> efie: :)
11:19:09 <hpaste> latro`a annotated “files_collector” with “files_collector (annotation)” at http://hpaste.org/73288#a73326
11:19:14 <timthelion> MostAwesomeDude: say I have [(\x->x+1),(\y->y+2)] and I have [1,2] and I want [2,3]
11:19:15 <latro`a> ^@covi
11:19:26 <MostAwesomeDude> timthelion: Oh!
11:19:43 <MostAwesomeDude> :t zipWith ($)
11:19:45 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
11:19:58 <latro`a> erm
11:19:59 <latro`a> my bad
11:20:06 <timthelion> >zipWith [(\x->x+1),(\y->y+2)]  [1,2]
11:20:11 <timthelion> > zipWith [(\x->x+1),(\y->y+2)]  [1,2]
11:20:12 <lambdabot>   Couldn't match expected type `a -> b -> c'
11:20:12 <lambdabot>         against inferred type `[...
11:20:19 <MostAwesomeDude> > zipWith ($) [
11:20:20 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:20:21 <MostAwesomeDude> Erg.
11:20:27 <timthelion> > zipWith ($) [(\x->x+1),(\y->y+2)]  [1,2]
11:20:29 <lambdabot>   [2,4]
11:20:34 <MostAwesomeDude> There ya go.
11:20:35 <timthelion> cool ! thanks :D
11:20:37 <hpaste> latro`a annotated “files_collector” with “files_collector (annotation) (annotation)” at http://hpaste.org/73288#a73327
11:20:40 <latro`a> there we go
11:21:18 <timthelion> MostAwesomeDude: I'm finally getting into the relm of doing things with first class functions and laziness that are IMPOSSIBLE in other languages, and where therefore inconcevable for me before I became proficient at haskell :D
11:21:18 <latro`a> you can also do it with nested if then else inside the do block, or using an if' construct
11:21:42 <n00b6502> "flip runState initialState $ do.."  i've got b#a for a flip, perhaps i can say     intialState#(runstate (do.......))
11:21:58 <MostAwesomeDude> timthelion: Gentle; there are many things that only *appear* impossible in other languages.
11:22:02 <covi> latro`a: nested if-then-else looks ugly and not Haskelly
11:22:05 <latro`a> I agree
11:22:18 <latro`a> but in do blocks it is convenient at times, if you don't like if'
11:22:18 <otters> > let (#) = flip in subtract # 3 4
11:22:19 <lambdabot>   <no location info>: parse error on input `)'
11:22:22 <latro`a> (if' is basically lisp's if)
11:22:35 <covi> latro`a: your approach, guards inside a do block looks great
11:22:38 <covi> if'?
11:22:41 <otters> > let a # b = b a in subtract # 3 4
11:22:42 <lambdabot>   3
11:22:47 <latro`a> if' True x _ = x
11:22:49 <otters> lol
11:22:51 <latro`a> if' False _ y = y
11:23:18 <covi> Oh, I see
11:23:20 <latro`a> if' isn't in base but is a somewhat common idiom nonetheless
11:23:24 <typoclass> edwardk: i'm looking at the source, and a tee is something that has 2 inputs, 1 output? (asking 'cause for the unix tool it's 1 in, N out)
11:23:27 <covi> thanks for your great help, now I can finish this script
11:24:21 <typoclass> (sorry, did i ask that twice? my internet connection went wahooni-shaped)
11:24:30 <latro`a> actually
11:24:32 <latro`a> is it nested?
11:24:34 <n00b6502> i'm wondering how this  "syntactic sugar for passing a value along" would compare with a forth-like language
11:24:36 <latro`a> @ covi?
11:24:55 <edwardk> typoclass: yeah. its more of a merge point
11:24:59 <latro`a> I think it's actually IO [FilePath]
11:25:02 <latro`a> not IO [[FilePath]]
11:25:12 <latro`a> since one of your cases is return [mypath]
11:25:18 <n00b6502> push inistial state;    push some other args1; dosomething1;   push args2; dosomething2; push args3; dosomething3;
11:25:18 <roconnor> @seen twanvl
11:25:19 <lambdabot> Unknown command, try @list
11:25:22 <n00b6502> return =final state
11:25:26 <roconnor> preflex: seen twanvl
11:25:27 <preflex>  twanvl was last seen on #haskell 21 days, 17 hours, 16 minutes and 23 seconds ago, saying: Haskell already has defaults, but only for a few classes, most importantly for Num
11:25:44 <n00b6502> can haskel implement something like that with various brackets and ccustom operators
11:26:04 <covi> latro`a: oh in my version I wrote [[FilePath]], that's why return [path]. Now I think IO [FilePath] suffices.
11:26:20 <typoclass> edwardk: an eet, so to say =)
11:26:23 <MostAwesomeDude> n00b6502: It would definitely be possible to make something like that. Give it a whirl.
11:26:25 <edwardk> typoclass: =)
11:26:33 <n00b6502> imagine in C++.     NewState state.Apply(args);     finalState = initialState.Apply(F1).Apply(F2).Apply(F3)
11:26:34 <edwardk> i'm adding 'wyes' which are non-deterministic tees as well
11:26:52 <n00b6502> MostAwesomeDude: glad to see i'm not completely insane
11:27:22 <n00b6502> i've currently got '#' doing something like C++ .
11:27:55 <n00b6502> ah but the monads do all the extracting and assigning to temporaries
11:28:00 <n00b6502> which i can't do that way
11:28:24 <n00b6502> LMAO i'm considering a FORTH like alternative to make monads clearer... wtf
11:29:33 <ParahSailin> random, interesting
11:29:33 <ParahSailin> def hamming_distance(s1, s2):
11:29:33 <ParahSailin>     assert len(s1) == len(s2)
11:29:52 <ParahSailin> oops wrong thing on paste buffer
11:29:53 <ParahSailin> sorry
11:29:59 <ParahSailin> http://www.csse.monash.edu.au/~lloyd/tildeStrings/Alignment/92.IPL.html
11:31:54 <n00b6502> ah so i could have a state-updater which takes a tuple as "the stack". an op which extracts a value (eg string token) could be "pushing an auxilary value infront of the tuple".; an op which consumes a token could be a fcuntion that just extracts from the state tuple
11:37:01 <danil> n00b6502: yeah, you could look at a Forth word as having type "State Stack ()", and >> to sequence them.  No return values, just stack modification.  (You'd have to use the same type for all the stack items to do this in Haskell, unless you want to use parametrized monads.)
11:37:57 <n00b6502> looks like if i try this any other way i'm going to just have a more convoluted , less flexible alternative
11:38:56 <danil> what are you actually trying to do?
11:40:13 <n00b6502> just a parser. equivalent of a C++ program reading a text file, building a datastructure.
11:40:53 <n00b6502> i know there's some libraries to do this but i wont beleive i 'grok' haskell until i can build that with minimal assistance..
11:41:32 * hackagebot modular-prelude 0.2.0.0 - A new Prelude featuring first class modules (DanBurton)
11:41:43 <n00b6502> i'm only thinking in haskelly terms if i can build that myself and end up with the same result..
11:43:53 <ParahSailin> @src replicate
11:43:54 <lambdabot> replicate n x = take n (repeat x)
11:44:26 <n00b6502> tangential question, i can't find something like my '#'   , kind of like opposite of $; i think Fsharp has |> ?
11:44:52 <n00b6502> a#b =b a
11:45:04 <n00b6502> F-sharp, i think a|>b= b a
11:45:20 <danil> n00b6502: well, you could start out with something like Parser a = State String (Maybe a) -- tries to read an 'a' from the front of the string, and either gives you an 'a' and consumes some characters or gives you Nothing and doesn't change the state.  You'd want some combinators on top of that to compose Parsers to end up with a pleasant library to use.
11:45:37 <typoclass> > flip map [1..5] pred -- n00b6502, you could try flip
11:45:40 <lambdabot>   [0,1,2,3,4]
11:46:12 <n00b6502> right now all my modules are ending up starting with the line a#b=b a :)
11:46:57 <n00b6502> i' nervous '#' might be used elsewhere
11:47:06 <Hakkla> Hello.
11:49:41 <danil> n00b6502: it's not widely used in Haskell; the diagrams package actually defines it the way you do, and there are some operator-hungry math packages that use it for other things.  But it's pretty unidiomatic to be writing lots of applications backwards.
11:51:40 <MostAwesomeDude> n00b6502: You know the Forth style, right? Don't define things you're not gonna use.
11:54:27 <Hakkla> If anyone has experience installing latest wxHaskell on Windows... I try to follow the guidelines on http://www.haskell.org/haskellwiki/WxHaskell/Windows, but when making "cabal install wxc" (one of the last steps; with all previous steps done) it keeps telling me "Please use the --wxcfg flag (...) or set the environment variable WXCFG to (x) (...)". Seems that the program thinks the variable is not set... but damn, it's what I've been doin
11:54:27 <Hakkla> the last hour or so! I can confirm that WXCFG = gcc_dll\mswu. What the heck could be wrong here?
11:55:07 <timthelion> I'm using topSort from Data.Graph to resolve dependencies.  I have two types of vertexes(say a and b).  I need to make vertexes of type b grouped together as much as is possible, while still following the condition described on the hackage page: a vertex i precedes j whenever j is reachable from i but not vice versa.
11:55:12 <timthelion> How can I do this?
11:56:03 <timthelion> I presume I have to write my own function.  But dependency resolution isn't my prime area of study so to speak.
12:08:03 <Egbert9e9> https://en.wikibooks.org/wiki/Haskell/Hierarchical_libraries/Randoms
12:08:07 <Egbert9e9> this is radical.
12:10:08 <timthelion> Egbert9e9: I don't see anthing so much as daring in that article.
12:11:50 <Egbert9e9> timthelion: for you it isn't, but I just found out how random numbers are produced in Haskell
12:14:28 <timthelion> Egbert9e9: I have a friend, who came up with the following sollution to "print the numbers between 1 and 100 in C++"
12:14:34 <hpaste> Timothy pasted “number printer” at http://hpaste.org/73331
12:15:06 <timthelion> at least I think it was 100, let me check
12:15:16 <otters> what's the rand() bit for?
12:15:23 <Nereid> what
12:15:30 <hpaste> shs pasted “beginner fail” at http://hpaste.org/73332
12:15:50 <Shapeshifter> Hello. I just started learning haskell and after having read the introductory chapers, I'm trying to solve some problems without looking at the solution but I don't understand why my code doesn't work. pastebinned above ^ I'm just trying a fibonacci.
12:16:15 <Shapeshifter> Basically, I cannot see fib being called with too few arguments for example.
12:16:20 <timthelion> gah
12:16:31 <Nereid> Shapeshifter: the first thing I see is
12:16:32 <timthelion> sent you the wrong source looks like
12:16:36 <Nereid> function application binds more tightly than :
12:16:47 <Nereid> so f a:b c means (f a):(b c), not f (a:b) c
12:17:11 <otters> Egbert9e9: what's the rand() bit for
12:17:12 <Shapeshifter> Nereid: ahh, yes, fixing this did the trick. thank you
12:17:23 <Nereid> :)
12:17:29 <Egbert9e9> otters: I am still scratching my head
12:17:41 <Egbert9e9> (in confusion)
12:17:43 <scooty-puff> Shapeshifter: in ghci, you can do :info : to get the fixity, etc., of symbols
12:17:43 <Shapeshifter> Mh, it even works. I'm sure there are much nicer solutions but yay, still.
12:17:45 <Nereid> well, function application binds more tightly than anything
12:17:51 <otters> Egbert9e9: I see
12:17:56 <Shapeshifter> scooty-puff: I see.
12:17:58 <hpaste> Timothy annotated “number printer” with “number printer (annotation)” at http://hpaste.org/73331#a73333
12:18:00 <Nereid> so you can write ...if head l > z then l else fib (head l + ...
12:18:08 <timthelion> There, that's the correct source sorry.
12:18:30 <Nereid> timthelion: again what.
12:18:49 <timthelion> otters: so basically, rand() in C has to be "seeded" before it is seeded, rand() has a deterministic sequence of numbers.
12:18:50 <roconnor> @type Data.Traversable.traverse Identity
12:18:51 <otters> :t mapM_
12:18:51 <lambdabot> forall a (t :: * -> *). (Data.Traversable.Traversable t) => t a -> Identity (t a)
12:18:52 <Nereid> does it assume rand() always starts with some known seed
12:18:53 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
12:18:59 <Nereid> :|
12:19:00 <timthelion> Nereid: yes!
12:19:04 <otters> timthelion: yeah, I figured it had something to do with seed.
12:19:12 <roconnor> @free foo : (t a) -> Identity (t a)
12:19:13 <lambdabot> Extra stuff at end of line
12:19:15 <timthelion> :P
12:19:16 <roconnor> @free foo :: (t a) -> Identity (t a)
12:19:17 <lambdabot> Plugin `free' failed with: Plugin/Free/Type.hs:(152,16)-(160,44): Non-exhaustive patterns in case
12:19:23 <otters> > mapM_ print [1..100]
12:19:24 <lambdabot>   <IO ()>
12:19:27 <otters> ^ much prettier
12:19:37 <roconnor> @free foo :: (T a) -> Identity (T a)
12:19:38 <lambdabot> $map_Identity ($map_T f) . foo = foo . $map_T f
12:20:14 <timthelion> So no one knows the sollution to my grouping problem?
12:20:22 <roconnor> @free (traverse Identity) :: (T a) -> Identity (T a)
12:20:23 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:22:15 <timthelion> I mean, I have some of my own solutions, but there all like O(n^n)!
12:22:25 <timthelion> Or worse
12:23:18 <zzing___> finally have IRC through ssh going, they block irc at the school
12:23:32 <timthelion> zzing___: but they don't block ssh...
12:23:43 <zzing___> timthelion, I never said it made any sense :-)
12:23:57 <LadyAurora> timthelion: what grouping problem?
12:23:59 <zzing___> and the server I ssh to is internal anyways, but no they don't block ssh
12:24:40 <timthelion> LadyAurora: I'm using topSort from Data.Graph to resolve dependencies.  I have two types of vertexes(say a and b).  I need to make vertexes of type b grouped together as much as is possible, while still following the condition described on the hackage page: a vertex i precedes j whenever j is reachable from i but not vice versa.
12:25:43 <LadyAurora> timthelion: uh, I'm afraid I can't help you.
12:25:44 <timthelion> LadyAurora: So far, I can only think to try changing things, and then running a dependency checker to see if I broke something.
12:26:08 <chrisdone> λ> Data.Aeson.decode (Data.Aeson.encode (123 :: Integer)) :: Maybe Integer
12:26:08 <chrisdone> Nothing
12:26:08 <chrisdone> can someone please explain this
12:26:22 <timthelion> LadyAurora: have I stated the problem formally enough, that a brilliant mathematician would be able to help me, and not simple look at me and say "I don't know what you're trying to do"?
12:27:20 <LadyAurora> timthelion: honestly, I dunno.
12:27:22 <typoclass> chrisdone: what does Data.Aeson.encode (123 :: Integer) give? does it look plausible? if yes, paste the raw String it into decode maybe
12:27:31 <timthelion> LadyAurora: well thanks for tryin :)
12:27:38 <ocharles> chrisdone: doesn't json require objcets at top level?
12:27:40 <ocharles> or an array
12:27:46 <ocharles> ie, is '123' really a valid json document?
12:27:51 <BMeph> preflex: seen ddarius
12:27:51 <preflex>  ddarius was last seen on #haskell 18 hours, 45 minutes and 24 seconds ago, saying: Personally, I think a nuclear holocaust would hasten your goal.
12:28:08 <LadyAurora> lol
12:28:17 <zzing___> Was there a way to setup a temporary local package cache (under ~) that can be discarded afterwards?
12:28:18 <chrisdone> ocharles: i looked at the spec and it seems only lists and objects at the top-level. news to me. Text.JSON behaves differently on this point
12:28:42 <timthelion> BMeph: ddarius was taken away to a special home after that statment :)
12:28:56 <latro`a> covi, I just caught a mistake earlier
12:29:01 <latro`a> the $ should be <$>
12:29:40 <latro`a> (you may already be encountering that if you tried to compile that script)
12:29:45 <chrisdone> ocharles: what's also confusing is that Data.Aeson.encode 123 → "123". so these functions aren't bijective
12:29:56 <chrisdone> or, what's the right word
12:29:56 <typoclass> zzing___: perhaps cabal-dev? not sure what you're looking for
12:30:03 <ocharles> chrisdone: i know what you mean, yea
12:30:32 <zzing___> typoclass, I want to be able to have a normal install but then when I go to develop something special I want to be able to set aside my normal environment
12:30:35 <ocharles> you'd assume forall x. decode . encode $ x == x
12:30:37 <ocharles> but that's not the case
12:30:46 <scooty-puff> when composing monadic operations in an applicative style, i often find i need to join at the end: join $ f <$> a <*> b - where f :: a -> b -> m c - is there a combinator i'm missing?
12:30:58 <roconnor> @free traverse :: (a -> F b) -> T a -> F (T a)
12:30:59 <lambdabot> $map_F g . h = k . f => $map_F ($map_T f) . traverse h = traverse k . $map_T f
12:31:03 <typoclass> zzing___: yeah, cabal-dev is a solution to that
12:31:26 <chrisdone> ocharles: yeah. category theorists have a special word for it
12:31:47 <ocharles> i've too wondered what the word is when writing quickcheck properties
12:31:51 <rking> Hrm. Category theorists.
12:32:12 <zzing___> cabal-dev looks wonderful
12:32:46 <scooty-puff> the fact it has cabal-dev ghci was enough to make me use it for everything
12:32:49 <roconnor> @free traverse :: (a -> F b) -> T a -> F (T b)
12:32:50 <lambdabot> $map_F g . h = k . f => $map_F ($map_T g) . traverse h = traverse k . $map_T f
12:32:53 <BMeph> timthelion: don't be fooled; ddarius goes where he wants to go - no one "takes" him anywhere. He's #haskell's answer to Liam Neeson.
12:32:58 <chrisdone> i vaguely recall c -> r notation. codomain and domain whatsits, when discussing show . read and read . show
12:33:04 <chrisdone> where's ski when ya need him
12:34:29 <zzing___> How many test suite failures is normal? I think the count was 70 when I had to stop the test last time near the end
12:35:30 <aristid> how can i get darcs to show me the actual patches along with the summaries in darcs changes?
12:42:01 <typoclass> aristid: "darcs changes --verbose --last=3" works for me. an alternative is "darcs diff", but i found that less readable
12:42:12 <typoclass> ("darcs diff --last=10" for example)
12:43:25 <aristid> typoclass: thanks. i like the git ui better tho :P
13:05:19 <EvanR> how do you generate a random Integer less than N
13:05:25 <EvanR> uniformly distributed!
13:06:23 <EvanR> (and greater than or equal to zero)
13:06:37 <shapr> How do I get cabal-dev ghci to load my Main.hs instead of my Library section?
13:06:59 <luite> EvanR: randomRIO (0,n)
13:07:07 <luite> might be n-1 instead of n
13:07:22 <eacameron> Is this statement true? "Conceptually, a monad is a container of things chained together in a specific order."
13:07:38 <mauke> no
13:07:45 <jfischoff> shapr: Personally I use the ghci -package-conf option and point to the cabal-dev package-conf
13:07:59 <mauke> a monad is a type constructor
13:08:11 <jfischoff> shapr: probably not what you want but it works
13:08:15 <EvanR> luite: not sure thats right
13:08:23 <luite> EvanR: why not?
13:08:56 <EvanR> hmm
13:08:58 <eacameron> mauke: oh...hmmm. do type constructors exist outside of the context of Haskell?
13:09:03 <mauke> no
13:09:10 <EvanR> luite: whats up with randomIO :: IO Integer working
13:09:15 <eacameron> mauke: but don't monads exist outside the context of Haskell?
13:09:31 <mauke> eacameron: yes, but I don't know math
13:09:41 <luite> EvanR: oh it's inclusive, so it should be randomRIO (0,n-1)
13:09:53 <eacameron> mauke: right...but like that quote says, it's "conceptually" speaking
13:09:58 <luite> EvanR: it's polymorphic, what you had probably was ambiguous
13:10:07 <EvanR> it gives a number
13:10:12 <mauke> eacameron: yes, and it's wrong
13:10:19 <EvanR> but randomIO shouldnt work
13:10:43 <eacameron> mauke: so it must be possible to describe monads without the term "type constructor"...but how?
13:10:48 <EvanR> anyway randomRIO (1,n) works for my purposes
13:10:54 <EvanR> i wish mwc-random did
13:11:06 <EvanR> but it has no instance for Integer
13:11:24 <johnw> isn't every C++ template with a parameterized type a type constructor?
13:11:33 <mauke> "A monad is a monoid in the category of endofunctors, what's the problem?"
13:11:58 <eacameron> mauke: can I get a "what's a monad for dummies" version?
13:12:03 * EvanR wonders what a monoid 'in a category' is
13:12:05 <pqmodn> eacameron: i liked this description: http://stackoverflow.com/a/11241990/1036439
13:12:34 <mauke> eacameron: do you know what a monoid is?
13:12:45 <luite> EvanR: yeah an instance Variate Integer is not possible
13:13:11 <EvanR> well RandomGen Integer shouldnt be either
13:13:12 <typoclass> eacameron: the quote that you gave isn't too bad in my opinion. there's a document called typeclassopedia that talks about these kinds of things, and discusses how Functors can be viewed as containers. (every Monad is a Functor.)
13:13:16 <typoclass> @where typeclassopedia
13:13:17 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
13:13:55 <johnw> eacameron: One of the most valuable bits of advice from the Typeclassopedia: "This document can only be a starting point, since good intuition comes from hard work, not from learning the right metaphor."
13:14:22 <mauke> [1,2,3] is not a monad
13:14:25 <johnw> because I find you can't really answer the question of what Monads *are* in any really useful way, you have to ask what a particular Monad *does*
13:14:35 <typoclass> ... where "hard work" == "messing around with your xmonad.hs, or with other haskell code" ;-)
13:14:51 <luite> EvanR: right, the non-ranged thing implicitly has the same range as Int, but i think the Integer one does the right thing
13:14:57 <luite> uh the ranged
13:15:03 <EvanR> very weird
13:15:12 <eacameron> mauke: but lists are monads, no?
13:15:15 <EvanR> @info RandomGen
13:15:16 <lambdabot> RandomGen
13:15:45 <mauke> eacameron: no
13:15:49 <EvanR> now what im thinking
13:15:52 <mauke> eacameron: the type constructor [] is a monad
13:15:57 <EvanR> not*
13:16:02 <EvanR> instance Random Integer
13:16:07 <johnw> lists are monadic values
13:16:18 <mauke> and this is misleading because "[]" is also the empty list but that's not what I'm talking about
13:16:25 <zzing___> Is there a way to tell ghc globally to include stuff from /usr/local/include and /usr/local/lib for libs?
13:16:47 <shapr> jfischoff: That sounds cool, lemme try it.
13:17:05 <eacameron> mauke: ahh...ok. that's better. to me "it's a type constructor" is confusing, because there are type constructors that are not monads
13:19:58 <johnw> "A monad is a monoid in the category of endofunctors": this statement still contains zero information for me
13:20:03 <danil> eacameron: more specifically, it's a type constructor equipped with two polymorphic operations (return and >>=) that satisfy some laws.
13:20:14 <drewr> johnw++
13:20:19 <shapr> johnw: Yah, I think so too.
13:20:25 <typoclass> johnw: it's a joke and meant to be obscure
13:20:45 <shapr> I wish it were clearly labeled as a joke :-/
13:20:47 <eacameron> danil: so it sounds like what yall are telling me is that asking "what is a monad" is like asking "define entity"...
13:21:02 <geekosaur> pretty much
13:21:04 <nand`> I thought it originated from a joke website
13:21:05 <typoclass> johnw: afaik the original source was http://james-iry.blogspot.de/2009/05/brief-incomplete-and-mostly-wrong.html
13:21:16 <typoclass> shapr: yes, mauke didn't make that clear :(
13:21:20 <nand`> at least, the particular formulation of “Monads are just monoids in the category of endofunctors, what's the problem?”
13:21:33 <geekosaur> a monad is an abstraction.  it's at such a level of abstraction that practically any statement you make about it is simultaneously false and true
13:21:34 <johnw> ah: http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
13:21:36 <nand`> typoclass: yeah that's what I was thinking about
13:21:39 <geekosaur> except the ones that are completely false
13:21:45 <johnw> eacameron: exactly
13:21:51 <johnw> eacameron: the question is too abstract
13:22:00 <eacameron> I FINALLY UNDERSTAND MONADS!
13:22:14 <shapr> eacameron: heh, it's like saying "what is an object?" in my opinion.
13:22:17 <johnw> it reminds me of a day when I tried to ask "How do you say food" in Italian, without sufficient vocabulary to describe the level at which I was asking the question
13:22:33 <shapr> When it's more useful to know how to accomplish a particular task with objects.
13:22:34 <johnw> I kept giving examples, but they kept not getting that I was after the name of a category
13:23:15 <johnw> (that is, I didn't know the word for "food", and I was trying to ask how you name the category of all food without having the word for food)
13:23:37 <johnw> felt a lot like talking about monads :)
13:23:44 * shapr grins
13:24:58 <latro`a> I think the hardest part about understanding monads is figuring out what they *aren't*
13:25:04 <latro`a> which I still don't fully grasp
13:25:05 <typoclass> you could have fallen back to a level shared by all humans ... "lolcats! nom nom! capice!?"
13:25:20 <johnw> haha
13:25:25 <latro`a> mainly because I don't fully grasp arrows
13:25:36 <johnw> latro`a: arrows are morphisms ;)
13:25:45 <latro`a> not in haskell
13:25:51 <latro`a> er, well
13:25:52 <johnw> damn
13:25:52 <latro`a> Arrows
13:25:54 <johnw> there goes my world
13:26:01 <latro`a> they aren't morphisms in a generic category
13:26:06 <latro`a> Category does that
13:26:15 <latro`a> Arrow gives you morphisms in rather large class of categories
13:26:23 <latro`a> which includes the Kleisli categories of any monad among others
13:26:26 <latro`a> *in a rather
13:26:29 <johnw> I just Kindled a big tutorial article on Arrows, so I'll talk with you about it tomorrow
13:26:31 <latro`a> but not every category
13:26:50 <latro`a> as I recall the category theory term is Freyd categories
13:26:55 <johnw> I mainly see Arrows as abstracting functions, the way that Monads abstract values
13:27:19 <latro`a> eh, monads can be looked at as functions too
13:27:32 <johnw> IO String is a monadic value that promises to yield a String, while Arrow Int String is an operation that takes an Int and promises to yield a String
13:27:40 <latro`a> one way of looking at them is "how do you compose a -> m b values?"
13:27:42 <latro`a> erm
13:27:43 <latro`a> functions
13:27:43 * nand` .oO( Do Arrow tutorials burn well? )
13:27:59 <johnw> latro`a: yeah, from the applicative point of view
13:28:04 <johnw> there are several ways to look at it
13:28:08 <latro`a> true
13:28:15 <latro`a> I find the category theory way rather roundabout for Hask
13:28:20 <johnw> ME TOO
13:28:28 <latro`a> especially since much of the benefit you get from going that way is actually lost
13:28:47 <johnw> for example: http://www.youtube.com/watch?v=9fohXBj2UEI
13:28:47 <latro`a> in particular, every category theory monad has a comonad, but in the haskell setting it's usually a comonad *in the wrong category*
13:28:56 <eacameron> \me: wishes he understood a single word of this conversation
13:29:02 <johnw> that video on Monads does nothing to help me write Haskell code :)
13:29:13 <nand`> reminds me of reading edwardk's articles: “a right kan extension is just a blah blah blah ... -shows haskell example-” “oh, that makes it so much clearer!”
13:29:20 * eacameron wishes he understood the IRC language
13:29:33 <edwardk> nand`: =P
13:29:33 <johnw> nand`: I get the same feeling from reading basically any article on the Free Monad
13:30:02 <danil> eacameron: it's sort of like asking "what's an Iterable" or "what's a linear operator" -- there are precise requirements and there are examples, butthe more abstract the thing is (e.g. linear operators or monads) the harder it is to see how the definition captures what all the examples have in common.
13:30:04 * typoclass feels that johnw's opinions are so much more clear-headed than those of the math pedants
13:30:11 <johnw> some day, I feel like I'm going to be able to walk on rice paper without leaving a footprint
13:30:13 <latro`a> that said, I find the category theory way "restricted" to Hask
13:30:16 <latro`a> that is, join-fmap-return
13:30:32 <edwardk> johnw: you might find my response to https://plus.google.com/106871002817915335660/posts/g9LASrMjeFS to somewhat useful for getting your head around 'freeness'
13:30:33 <latro`a> to be clearer than the return-bind approach
13:30:37 <edwardk> er to be
13:30:44 <zzing___> Can I tell cabal to install a packages dependencies only?
13:30:57 <edwardk> johnw: there i go through precisely what it means for lists to be the free monoid
13:31:20 <johnw> edwardk: thank you!! Kindling now
13:31:39 <nand`> “Well, Swierstra's paper mentions that "In general, a structure is called free when it is left-adjoint to a forgetful functor.” <- this is actually a fairly good definition
13:31:52 <nand`> ..and one I understand, miraculously
13:32:20 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Wye.hs#L57 is the product of a ride on the T well spent ;)
13:33:01 * eacameron feels dumber the more he learns haskell...the despair is unbearable
13:33:12 <mauke> "it gets better"
13:33:17 <johnw> eacameron: acquiring knowledge in general *should* have that effect
13:33:19 <thoughtpolice> zzing___: cabal install --only-dependencies
13:33:21 <mauke> turns out you can just ignore monads
13:33:22 <nand`> by that logic, the more I forget haskell, the smarter I get?
13:33:27 <nand`> or rather, the smarter I'll feel.
13:33:28 <johnw> otherwise, you're using knowledge to close doors rather than open them
13:33:29 <nand`> hmm
13:33:30 <nand`> that's not exactly desirable
13:33:34 <edwardk> nand`: dunning-kruger effect
13:33:53 <nand`> edwardk: exactly
13:33:55 <eacameron> johnw: but no other language has that effect on me
13:34:06 <johnw> eacameron: point to haskell then :)
13:34:08 <Shapeshifter> I tried to google this but couldn't find anything. How can I evaluate a list expression to find out if all elements are True? E.g. if I did alltrue [ x | x <- [True, True, True, False, True]] it would return False as soon as it has evaluated the 4th element the list expression returned instead of continuing.
13:34:10 <edwardk> eacameron: that should tell you something about the information content you were deriving from them ;)
13:34:14 <zzing___> thoughtpolice: merci
13:34:19 <latro`a> Shapeshifter, there's a builtin function called and
13:34:21 <edwardk> > and [True,False]
13:34:22 <nand`> eacameron: that goes to show how similar other popular languages really are
13:34:23 <lambdabot>   False
13:34:29 <latro`a> it is implemented using foldr
13:34:32 <latro`a> @src and
13:34:33 <lambdabot> and   =  foldr (&&) True
13:34:36 <zzing___> any idea why   extra-lib-dirs: /usr/local/lib   wouldn't be used during a cabal install (--global this time) that was in ~/.cabal/config?
13:34:51 <nand`> I reckon there are many wildly different languages that might have similar effects; Agda, Coq, Mercury, Prolog, Ur, etc.
13:34:54 <Shapeshifter> latro`a: ahh, nice. How obvious... thanks.
13:34:56 <ivan> is there a GHC compiler I can trust in the trusting trust sense? (just for building GHC)
13:35:02 <nand`> and by wildly different I mean wildly different to the most popular languages
13:35:09 <latro`a> there is also a builtin function called or
13:35:14 <latro`a> which is similarly implemented using foldr
13:35:16 <latro`a> @src or
13:35:16 <lambdabot> or    =  foldr (||) False
13:35:22 <eacameron> nand`: thats true no doube
13:35:24 <eacameron> *doubt
13:36:06 <ParahSailin> @src and
13:36:06 <lambdabot> and   =  foldr (&&) True
13:36:19 <mauke> @src all
13:36:20 <lambdabot> all p =  and . map p
13:36:24 <nand`> Shapeshifter: you could do null [ x | x <- [True, True, True, False, True], not x] if you really wanted a list comprehension :)
13:36:35 * hackagebot aeson-smart 0.2.0.0 - Smart derivation of Aeson instances (SamAnklesaria)
13:36:37 <johnw> edwardk: I think you should blog that response
13:36:38 <latro`a> that is terrible, lol
13:36:46 <edwardk> johnw: was it useful?
13:36:57 <johnw> i've only glanced at it, not read it in depth yet
13:37:07 <johnw> but it feels usefulish
13:37:21 <typoclass> eacameron: don't be intimidated by the goofy mathy names. i always thought there had to be some mysterious mathematical substance to monads and functors and all that, and spent a lot of time looking for it. at this point i don't think there is anything much behind it
13:37:24 <johnw> enough so that it shouldn't be buried in a response to someone else's post
13:37:38 <typoclass> they're some typeclasses. you can look up their definition, they're quite short. over time, while reading and writing haskell, you come across more and more examples of where a Functor or a Monad is used. that's about it, for me *shrug*
13:37:54 <edwardk> johnw: fair nuff
13:38:53 <zzing___> Any ideas why cabal installs things to /usr/local when ghc is in /opt and its own options file says global is prefixed on /opt?
13:39:08 <nand`> typoclass: there's a reason so many other languages that implement mathematical concepts tend to rename them
13:39:14 <nand`> but I'm personally against that approach
13:40:15 <nand`> giving something a name that implies meaning makes instances of that concept which *don't* fall into that particular interpretation unintuitive
13:40:21 <johnw> Haskell has made me regret C++'s use of the word 'functor'
13:40:36 <johnw> I never realized how much that was blocking me
13:41:02 <timthelion> Have there been any proposals to make data declarations automatically derive from type classes?  It's anoying sometimes, to have to type deriving(Show,Eq) after everything, just to get basic debuging and logic support.
13:41:06 <t7> are vectors catagorys
13:41:08 <t7> or points?
13:41:10 <luite> typoclass: the mathy part is the laws and the stuff you can derive from those, the part that you don't see in the class and instance definitions
13:41:24 <t7> or is 3d space a catagory
13:41:39 <Shapeshifter> Mhh. So I've already written the third solution to this problem but I still can't get it to be just a little bit fast. I'm trying to find the smallest integer divisible by all of [1..20]. When I try this: head [ x | x <- [20..], and [ q | y <- [10,9..1], let q = (mod x y == 0)]] It evaluates immediately. But the same with [20,19..1] takes forever...
13:41:43 <nand`> t7: there's a category of vector spaces, but vector spaces themselves don't give rise to categories iirc; at least not any simple / immediately obvious ones
13:43:26 <nand`> (though I think representing a vector space as a geometric algebra gives rise to a category)
13:44:09 <latro`a> timthelion, given that you do sometimes want custom instances, I think that's probably a bad idea
13:44:22 <latro`a> the first example that comes to mind is the Eq instance for Handle (since I looked at it today)
13:45:06 <Nafai> johnw: it's been so long since I've actively done C++, I can't really recall exactly how C++ uses 'functor'
13:45:11 <nand`> I think we really want a ‘debug :: a -> String’
13:45:48 <nand`> or debug :: Debug a => a -> String where every single type is inherently an instance of Debug
13:46:30 <thoughtpolice> Nafai: it refers to a 'function object' which is just any old object with an overloaded operator(), so you can apply it like a function. you can use it to imiate lambdas and other stuff by capturing things in the constructor, and then applying it later
13:46:39 <mauke> Nafai: a C++ "functor" is an object that overloads operator()
13:46:51 <timthelion> latro`a: Hmph, you're right, but perhaps we could derive Eq by default and have a noderive keyword ;)
13:46:57 <thoughtpolice> (which is actually how c++11 lambdas are compiled, roughtly speaking)
13:47:23 <typoclass> nand`: i personally think that from a teaching perspective, it's a tiny number of people who know CT terminology but not haskell, i.e. who are helped by typeclass names like Monad. i also think it's a large number of people who become intimidated or uncertain due to those names
13:47:27 <pcapriotti> edwardk: what do you think of this? http://hpaste.org/73335 I use the resulting lens as a Traversal when I need to update a Maybe field, and be aware if it fails (because it's Nothing)
13:47:36 <pcapriotti> edwardk: is there already other functionality to achieve this?
13:47:37 <latro`a> Show is particularly bad, I think, because a lot of times you want custom Show instances
13:47:44 <timthelion> typoclass: agree
13:48:08 <johnw> Nafai: In Haskell, the "functor" is an interface for the thing being mapping over, but in C++ it's the exact opposite, the "functor" is the function you are mapping and has nothing to do with the container
13:48:09 <nand`> thoughtpolice: do you know why they are named this way? Ie. is there any connection to CT?
13:48:10 <timthelion> latro`a: but as I said, you would be able to noderive classes you didn't want derived.
13:48:13 <latro`a> true
13:48:37 <Nafai> thoughtpolice, mauke, johnw: ah, thanks.
13:48:51 <timthelion> latro`a: perhaps I should just make a typeclass Super, which derives the things I want,  So I just have to derive(Super) each time I want the standard stuff.
13:48:52 <eacameron> latro`a: I kinda like Python's differentiation of "str" and "repr"...in haskell that would be "Show -> Repr" and "Show" would be some custom string
13:49:00 <nand`> for example, C# has ‘covariant’ and ‘contravariant’ instances. For a long time I just ignored these names but after reading up on CT I dug up the theory behind them and realized that they represented actual covariant / contravariant functors on the poset category of implicit type coercion
13:49:08 <edwardk> pcapriotti: i have to admit it makes me queasy ;)
13:49:10 <mauke> and in OCaml a "functor" is a module constructor
13:49:21 <thoughtpolice> nand`: i don't think so, i think it's just a compound word resulting from the fact you can treat the object like a function, thanks to the overloading
13:49:36 <thoughtpolice> but i read that post on C# too, so i could be wrong :D
13:49:40 <nand`> thoughtpolice: but why ‘or’? I would have expected ‘funobj’ or ‘functob’
13:49:40 <pcapriotti> edwardk: why?
13:50:18 <edwardk> pcapriotti: because you wind up with something that you can probably clone but isn't a lens.
13:50:28 <edwardk> so lets get you the functionality you want
13:50:32 <eacameron> latro`a: sorry. I assumed you knew Python. the Repr would be a parsable representation of the data and Show would be some human readable version
13:50:34 <thoughtpolice> nand`: good question
13:50:35 <danil> nand`: "functor" was just an existing word that various people used for things that were like functions but not exactly
13:50:41 <osa1> do we know which parameter will be executed first for sure in this code: f <$> p1 <*> p2 ?
13:50:47 * timthelion loved C# and wishes there where something as good as C#+VisualStudio on linux :/
13:51:04 <nand`> timthelion: I code C# on linux from time to time, and I use vim which is quite good
13:51:04 <edwardk> pcapriotti: there is a notion of a partial lens you can use that can only target at most one element
13:51:19 <nand`> there's also MonoDevelop if you're into that sort of stuff
13:51:34 <edwardk> i don't supply them because they need dependencies i'm not willing to add, and because Pointed isn't a superclass of Applicative, so i can't use them directly as Traversals
13:51:36 <edwardk> you can make
13:51:43 <timthelion> nand`: that's not why I liked C#(and is there really C# outside of mono on linux?)  I liked C# because of the IDE.
13:51:58 <edwardk> type PartialLens a b c d = forall f. (Pointed f, Functor f) => (c -> f d) -> a -> f b
13:52:11 <johnw> C# does have a great ecosystem
13:52:14 <johnw> I like it when I used it too
13:52:25 <edwardk> with PartialLens you can get what you want
13:52:39 <edwardk> you know it can only update one entry, and you can know if its present
13:52:58 <edwardk> and you can adapt a lens to a Maybe into a partial lens
13:53:06 <pcapriotti> ok, I see, the difference is that the Pointed instance is inside the quantifier, I guess
13:53:15 <edwardk> yep
13:53:19 <pcapriotti> in my code, the first argument is basically a Pointed instance
13:53:35 <pcapriotti> that makes sense
13:53:37 <nand`> the only thing I like about C# is that I'm familiar enough to create mind-bending examples to show to my teachers who, accordingly, teach C#
13:53:38 <edwardk> yep, the difference is that i can reason about these and you can use them in multiple contexts ;)
13:53:46 <edwardk> you get decent laws out of this formulation
13:54:31 <edwardk> now you can always just use a Traversal instead, and then extract if the traversal is null using nullOf
13:54:40 <danil> osa1: the order of the applicative effects in `f <$> x <*> y` doesn't depend on `f`, if that's what you're asking.  There isn't necessarily any notion of "executed first" for all Applicative instances though.
13:54:45 * pcapriotti looks up nullOf
13:55:32 <timthelion> I need a word, for the state of being a parameter, or being a completely static value.  But parametricity is already taken :/
13:56:11 <nand`> parameterness? (I don't understand the question)
13:56:44 <edwardk> pcapriotti: keep in mind you can run the update in a writer monad, and log success by returning All False or Any True
13:57:02 <timthelion> nand`: I think I'll just use "IsParameter"
13:57:08 <edwardk> and 'firstOf' can read it
13:57:19 <edwardk> so you can just use a traversal that happens to target a single element
13:57:24 <nand`> if this is for a typeclass why not ‘Parameter’
13:57:32 <nand`> the whole Is- prefix thing seems redundant to me
13:57:40 <nand`> ‘IsFunctor, IsMonad, IsTraversable’ etc.
13:57:42 <edwardk> this is what took a lot of pressure off of me to implement partial lenses
13:57:56 <pcapriotti> edwardk: I see, that might be good enough
13:58:18 <timthelion> nand`: I'm implementing parametric modules at the semantic level(not at the type level) and some top level declarations can be reasigned by being passed by the loader of the module.
13:58:58 <edwardk> pcapriotti: i could definitely stand to provide a set of combinators for reading the first target of a traversal
14:01:35 * hackagebot yesod-test-json 0.2.0.0 - Utility functions for testing JSON web services written in Yesod (SamAnklesaria)
14:03:04 <frerich_> Shapeshifter: At the risk of pointing out the obvious, but 'x <- [20..]' makes it draw from a list starting at 20 and increasing, whereas 'x <- [20,19..]' makes it draw from a list starting at 20 and decreasing.
14:04:49 <twmb> At the risk of asking a pretty dumb question, do you guys recommend first reading "Learn You a Haskell" and then "Real World Haskell"... and then I'm pretty set/
14:05:01 <johnw> I would definitely recommend LYAH first
14:05:02 <twmb> where else would I go for the more advanced Haskell topics, like... getting GUI with Haskell?
14:05:12 <johnw> twmb: haskellwiki.org
14:05:19 <johnw> has a very good tutorial section for particular topics
14:06:02 <timthelion> twmb: Go back in time 4 years.  Get on IRC at #xmonad, and ask dons to teach you haskell.  Timetraveling is now supported by the State monad incase you where finding that first part difficult :P
14:06:03 <twmb> johnw: Thank you... I'm going to begin learning Haskell next week, with the ultimate goal of a small multithreaded gui
14:06:29 <timthelion> twmb: cool, good luck.
14:06:42 <nand`> nah time travel is in the Cont monad
14:06:43 <twmb> timthelion: I'm sure I'll be asking questions in this channel within the coming months...
14:06:44 <armlesshobo> timthelion: LOL. The last part caught me off guard :P
14:07:32 <timthelion> nand`: scary thing, is I actually USED time traveling lazyness in a parser!!!
14:07:33 <typoclass> twmb: welcome to haskell =) yes, LYAH is a good starting point. after that, well, i guess it's best to check back here and say "i want to do X, where do i go, can anyone recommend a tutorial or blog post"
14:08:19 <twmb> Oh also one more question:  So, I keep reading all this stuff about how "monads will melt your brain" and the likes...
14:08:28 <timthelion> twmb: don't beleive it
14:08:30 <twmb> so are monads about the hardest concepts that one could encounter in programming?
14:08:31 <timthelion> twmb: monads are easy
14:08:37 <armlesshobo> twmb: i definitely recommend LYAH until you're comfortable with the language, and then Real-World Haskell after to get you to think about developing functionally.
14:08:49 <johnw> >I thought time travel was now in the Tardis monad
14:08:49 <timthelion> twmb: no, monads are supper simple.  Just a lot of people get confused by them.
14:08:57 <nand`> twmb: no. you can do much, much, much worse
14:09:06 <timthelion> johnw: which is State, ok , I fudged my words.
14:09:07 <nand`> I just think monads mark the barrier where those that give up give up and those that don't don't
14:09:19 * armlesshobo is still confused by monads. One day it will click :P
14:09:23 <nand`> so you probably get a lot of whining about them by the giver-upers
14:09:42 <Iceland_jack> I think Haskellers make far to big a deal about monads
14:09:51 <Iceland_jack> that and the name don't help
14:09:52 <johnw> twmb: monads are no different from any other interface; don't believe the hype
14:10:01 <timthelion> armlesshobo: Step one, don't call them monads, call them "pairings of typeClasses which follow the monadic laws and data declarations" and bingo, its simple as pie.
14:10:06 <nand`> actually I think non-Haskellers talking about Haskell make a bigger deal about monads
14:10:06 <twmb> K good I din't think they would be the *worst*... sounds interesting
14:10:13 <startling> Iceland_jack, nah, monads are easy! they're just morphisms in the category of endofunctors
14:10:13 <Adeon> monads are easy to understand most of the time except when they are not easy to understand
14:10:18 <typoclass> twmb: i think a lot of people are intimidated by the strange academic name "monad"
14:10:19 <johnw> it's quite a phenomenon, how the explanation of monads has taken on a life of its own
14:10:26 <johnw> I wonder why Functor didn't win this level of enthusiasm
14:10:30 <donri> MONADS.
14:10:32 <johnw> when they are so closely related
14:10:38 <startling> Applicative is cooler
14:10:44 <twmb> typoclass: I never thought acedemic name, I thought more along the lines of "gonads"... and strife
14:10:47 <donri> i like foldable and monoid
14:10:48 <johnw> yeah, but Functor is older
14:11:01 <nand`> and then you have the arrow camp
14:11:03 <Iceland_jack> startling: I know that's meant as a joke but it's not that far off from the responses some people give...
14:11:08 <nand`> bitter about how people are using monads instead of their favorite ArrowApply or w/e
14:11:13 * barrucadu is confused by arrows
14:11:14 <johnw> I mean, Monad is really no more special than Eq for frak's sake
14:11:21 <armlesshobo> timthelion: hmm. I guess I just have to read up on monadic laws and it's data declarations and I'll be golden lol
14:11:26 <startling> Iceland_jack: heh. the funny thing is I'm *just* starting to understand that phrase
14:11:31 * timthelion shoots barrucadu with an arrow
14:11:36 <armlesshobo> timthelion: I didn't realize I'd become a functional progamming lawyer :P
14:11:41 <donri> calling it "monads" is as silly as calling it "equality" instead of "sameness"
14:11:43 <timthelion> armlesshobo: you don't have to understand the darned laws!
14:12:05 <nobdraisentone> How can I make instance Eq for Int → Int → Bool
14:12:06 <nand`> I think you have to understand the laws
14:12:06 <nobdraisentone> ?
14:12:09 <nand`> they're a great source of intuition
14:12:17 <nand`> nobdraisentone: you don't. not reasonably
14:12:22 <timthelion> donri: but the fact that "Monad" in haskell is actually a misnomer, really confused me actually :)
14:12:30 <mauke> nobdraisentone: brute force
14:12:33 <nand`> (there are ways but they most definitely, DEFINITELY won't help you)
14:12:40 <Iceland_jack> nand`: (he didn't say anything about reason) ;)
14:12:41 <typoclass> donri: the word equality is in the normal english lexicon. the word monad is only in the lexicon of a very specialized small group
14:12:51 <armlesshobo> Monad is just a type that allows for binding and stuff, right?
14:13:03 <danil> typoclass: made-up words would be in nobody's lexicon, though
14:13:04 <timthelion> armlesshobo: yes
14:13:06 <Yiq> can you do code hot-code swapping in haskell? under what premises?
14:13:16 <johnw> yeah, I think it comes from ordinary programmers trying to translate this word "Monad" into something they can relate to
14:13:18 <nand`> equality checking on that type is pretty much guaranteed to take longer than the lifetime of the universe on current computers to ever evaluate down to True or False
14:13:26 <nand`> johnw: hehe Linq
14:13:36 <timthelion> Yiq: yes you can.  It's weird though.  Not very well developed.  You can use hint and load modules on the fly though.
14:13:45 <johnw> if it were called FunctorThatDoesItsOwnBoxing, I would have gotten it a LONG time ago
14:13:46 <mauke> instance Eq (Int -> Int -> Bool) where f == g = and $ do { x <- [minBound .. maxBound]; y <- [minBound .. maxBound]; return $ f x y == g x y }
14:14:09 <startling> johnw: ooh
14:14:12 <donri> lol brute force
14:14:17 <armlesshobo> timthelion: i guess the issue is that when I see people talk about monads (main monad, IO monad, etc) it makes me instantly think about threads, which further confuses me
14:14:20 <startling> mauke: ouch
14:14:41 <mauke> armlesshobo: what's a "main monad"?
14:14:53 <johnw> the monad you don't tell your monadic mistresses about
14:15:01 <armlesshobo> timthelion: because I'm still to unfamiliar with it. I bet if I work with monads more, I'll eventually understand it.
14:15:11 <timthelion> armlesshobo: You know what a type class is, you know what a data construcor is, you know what a data constructor that derives a type class is, so you know that a Monad is a data constructor that deriives the Monad type class and your set :D
14:15:21 <Iceland_jack> Whose set?
14:15:28 <hughfdjackson> Iceland_jack: your one
14:15:31 <hughfdjackson> didn't you hear?
14:15:32 <hughfdjackson> :D
14:15:35 <Iceland_jack> Oh right, right.
14:15:35 <timthelion> s/your/you're/
14:15:37 <mauke> timthelion: you can't derive Monad
14:15:52 <armlesshobo> mauke: don't know, I may have misread something somewhere (they may have been refering to them using a specific monad type as the "main" monad for there project)
14:15:56 <mauke> timthelion: monads are type constructors, not data constructors
14:15:57 <nand`> Yiq: a few programs (most notably xmonad) solve this by recompiling themselves at runtime
14:16:12 <timthelion> mauke: now you're confusing me :P
14:16:17 <nand`> there's probably a library or two to do it
14:16:22 <nand`> but I forgot the names
14:17:04 <startling> hint is one
14:17:38 <johnw> bah, I got confused again by C++ functors.  I should have said, FunctorThatUnboxesButDoesNotBoxTheResult
14:18:10 <johnw> so, a -> b for Functor, a -> m b for Monad
14:18:18 <armlesshobo> timthelion: i thought typeclass described a set of types that share similar types of values
14:18:34 <armlesshobo> Num -> Int, Double, Float, etc
14:18:42 <Iceland_jack> Shouldn't there be an Internet law stating: “The more you try to explain monads in simple terms, the more complicated it will appear.”
14:18:53 <johnw> I think it's called the monad tutorial fallacy
14:18:56 <armlesshobo> "...and the more insane you'll look"
14:18:57 <hughfdjackson> hehe
14:19:11 <mauke> http://i.imgur.com/OEHtT.gif
14:19:12 <hughfdjackson> the only explanation that ever made sense to me (and i sure don't grok them) is a computation builder
14:19:25 <timthelion> mauke: according to what I'm reading Monad is a typeclass, though you are correct about creating a newtype and not a data constructor for the seccond part.
14:19:38 <nand`> mauke: is that cat fighting itself?
14:19:39 <mauke> timthelion: I didn't say anything about newtype
14:19:42 <johnw> hughfdjackson: yeah, I now think of them as "computational contexts"
14:19:52 <Iceland_jack> I personally think most tutorials do it wrong by not simply focusing more on example of monads
14:19:53 <hughfdjackson> :/ no doubt that explanation will seem a bit thin if/when i understand them a bit better
14:19:53 <timthelion> mauke: are you just trying to troll me now?
14:20:02 <mauke> timthelion: what are you talking about?
14:20:22 <mauke> hughfdjackson: I "understand" monadic values as magic boxes, but only by stretching the definition of "box"
14:20:26 <johnw> that GIF is awesome
14:20:41 <johnw> clearly a monadic cat
14:20:42 <timthelion> mauke: you go and say I'm wrong.  But you don't correct me.  And I'm not wrong, at least not entirely :/
14:20:47 <Yiq> Is SPJ the premier computer scientist today?
14:20:49 <hughfdjackson> if i understand haskell's IO right, it builds up a declarative 'set of instructions' to the interpreter of the IO monad
14:20:55 <mauke> timthelion: I'm pointing out incorrect bits you said
14:20:55 <johnw> by trying to clean himself of misunderstanding, he gets into a fight with his own self
14:21:01 <hughfdjackson> some of which will be hooks into your pure code
14:21:04 <startling> hughfdjackson: that's my understanding, too
14:21:07 <Iceland_jack> hughfdjackson: putStr "Hello" >> putStr " " >> putStrLn "World."
14:21:18 <ciaranm> burn the heretic
14:21:24 <timthelion> mauke: if I've missunderstood something, than say what part of what I've said should be changed.  Don't just add uncertainty :/
14:21:25 <mauke> timthelion: where did you get "newtype" from?
14:21:26 <johnw> hughfdjackson: that's my understanding as well
14:21:32 <typoclass> mauke: yes, but that's not very helpful without an explanation of why you think he's incorrect
14:21:33 <ciaranm> burn the heretic!
14:21:39 <ciaranm> buuuuuurrrrnnnnn!
14:21:43 <johnw> hughfdjackson: it builds a set of action that are executed by unsafePerformIO
14:21:49 <timthelion> mauke: ah, you said "type constructor" and not "data constructor"
14:21:59 <nand`> hughfdjackson: haskell's approach to IO is by reifying real world interactions
14:22:01 <mauke> timthelion: do you understand the difference?
14:22:02 <Yiq> is cloud haskell released, im excited about it
14:22:21 <timthelion> mauke: Only pragmatically :/
14:22:27 <mauke> timthelion: that's enough
14:22:36 <nand`> then interpreting this in some implementation-specific way
14:22:50 <mauke> timthelion: 'Maybe' is a type constructor, 'Just' is a data constructor
14:23:00 <hughfdjackson> mauke: do you have that haskell IO blog you linked me to ages back kicking about? it's not showing up in the google
14:23:02 <timthelion> mauke: aha, I see.
14:23:10 <danil> armlesshobo: a typeclass is like an interface that type can support ("be instances of"), with some functions that work on any type that's an instance of the class.  The *values* of the types that are instances don't have to be similar, as long as the operations still work.  For instance, values of type in the Show or Eq classes don't have much in common with each other.
14:23:30 <danil> (er, "values of types in...")
14:23:43 <mauke> hughfdjackson: do you mean http://mauke.hopto.org/stuff/haskell/how-to-io.html or Cale's?
14:23:48 <startling> typeclasses made more sense to me once I became familiar with algebraic structures
14:23:58 <timthelion> mauke: so I'm not that far off, it's just my vocabulary that needs work.  And I was wrong about "deriving" Monad, since you cannot derive, but only create an instance of...?
14:24:06 <hughfdjackson> that's the one :) cheers
14:24:29 <mauke> timthelion: "deriving" is when the compiler writes the instance automatically
14:24:32 <hughfdjackson> nand`: :| now that i've looked up reify in the context of CS
14:24:37 <hughfdjackson> that makes a good deal of sense
14:24:39 <mauke> by looking at the structure of the type
14:24:47 <timthelion> mauke: I see.
14:24:54 <mauke> it only works for a handful of classes like Eq or Show
14:24:55 <nand`> conceptually Monad and Functor are not that different - they're both typeclasses on type constructors of kind * -> *
14:25:00 <johnw> i understood typeclasses once I saw the C++ proposal for concepts
14:25:08 <nand`> that you can derive functor but not monad is due to other reasons than some inherent limit of this property
14:25:09 <hughfdjackson> mauke: nothing says programming more than the sigel of baphomet
14:25:20 <johnw> the thing is that Haskell makes generic programming so natural, it's hard to recognize at first
14:25:22 <hughfdjackson> :p unless i'm mistaken in my favicon interpretation
14:25:38 <mauke> hughfdjackson: and hearts
14:25:48 <barrucadu> hughfdjackson: Hardcore programming.
14:26:03 <johnw> there's a whole other layer of abstraction there, which C++ doesn't have, but it looks and feels so much like the rest of Haskell that it's hard to notice it as different
14:26:04 <hughfdjackson> :D
14:27:14 <n00b6502> did anything like haskell ever try an assignment operator that re-assigns a symbol (not mutates a state) as a way of streamlining mutation. eg s:=f1(s,...); s:=f2(s,...);  .. note i mean re-assigning the symbol, not modifying the state   i understand monads have other benefits
14:27:29 <mauke> non-recursive let
14:27:46 <hughfdjackson> so are all monads just reified actions?
14:27:53 <hughfdjackson> or is this a particular property of the IO monad?
14:28:08 <nand`> IO
14:28:12 <hughfdjackson> okay :) thanks
14:28:13 <mauke> hughfdjackson: I don't think it's a property of IO
14:28:22 <nand`> not necessarily just IO
14:28:22 <johnw> hughfdjackson: doesn't that depend on the monad?
14:28:27 <nand`> it depends on the monad
14:28:30 <hughfdjackson> johnw: oh, that's kinda what i meant
14:28:35 <nand`> eg. you can reify actions plenty using Free monads
14:28:36 <hughfdjackson> i meant 'is this inherent to monads, or just some', really
14:28:41 <johnw> ah
14:28:51 <hughfdjackson> i've got a case of friday brain
14:29:00 <mauke> hughfdjackson: well, look at a few concrete monads
14:29:09 <mauke> Maybe, [], (->) e, Identity
14:29:10 <nand`> some canonical monads are also pretty ‘action-y’: State, Reader, Writer
14:29:28 <nand`> but usually the ‘action’ of a monad refers to the Kleisli arrow
14:29:42 <nand`> eg. a kleisli [] is sometimes called a ‘non-deterministic computation’
14:29:44 <nand`> but not lists themselves
14:29:49 <johnw> "but usually the ‘action’ of a monad refers to the Kleisli arrow": you completely lost me there
14:29:58 <nand`> a kleisli arrow is something like a -> m b
14:30:01 <nand`> for some monad m
14:30:05 <johnw> ah!
14:30:14 <mauke> :t Kleisli
14:30:16 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
14:30:16 <johnw> thanks, what an awesomely clear answer
14:30:21 <johnw> (i mean, seriously)
14:30:28 <johnw> i've been wondering what Kleisli arrows were
14:30:36 <nand`> well now you know
14:30:45 <johnw> the question is whether I'm better for knowing ;)
14:30:51 <nand`> Monad m => Kleisli m is an instance of a Category and an Arrow
14:30:53 <johnw> you've stolen the mystery from my day
14:31:53 <nand`> (to perhaps demystify further, this Kleisli m Category is often called a “kleisli category”)
14:32:23 <nand`> and it exemplifies the fact that you can sequence together kleisli arrows - in other words, you can chain together “monadic computations”
14:32:35 <nand`> one of the reasons Monads are so popular
14:32:41 <johnw> and the thing Functors cannot do
14:33:05 <johnw> i've got it: Monads are the Computer Science version of the Human Centipede
14:33:08 <Yiq> anyone tried cloud haskell?7
14:33:32 <ahkurtz> johnw: troll!
14:33:39 <johnw> ;-)
14:33:45 <johnw> shh
14:33:54 <ahkurtz> straight up trollin
14:33:56 <Saizan> johnw: exactly :)
14:34:31 <barrucadu> johnw: Thanks for the bizarre mental image :P
14:34:39 <Saizan> johnw: the best analogy was a similar one with unicorns, you can figure out the details
14:34:43 <armlesshobo> danil: but Show and Eq are type classes, right? So any type t can be "shown" or "equated"
14:34:47 <nand`> Saizan: haha
14:34:54 <armlesshobo> danil: that's what I'm trying to get at.
14:34:59 <zzing___> Should GOA work in 7.4.2?
14:35:15 <n00b6502> maybe a parser is going to look ok done with something like folds combining a tokenstream and input object
14:35:31 <t7> trolling would be inventing a language just like haskell but without type checking
14:35:38 <armlesshobo> danil: Num is a typeclass for types that are numbers Int, Double, etc.
14:35:45 <nand`> armlesshobo: I'd agree with ‘typeclasses are for types that share commonalities’
14:35:58 <nand`> more formally, typeclasses are just abstraction layers
14:36:05 <armlesshobo> nand`: right.
14:36:14 <frerich_> johnw: Oh dear, I didn't know what you meant so I googled it. What has been seen, cannot be un-seen!!
14:36:14 <armlesshobo> a category
14:37:20 <Yiq> why should i cabal install remote when it is called dsitributed-process now?
14:37:25 <johnw> frerich_: yeah, tell me about it.  I've never seen the movie, but I am afraid just knowing it's out there
14:37:50 <nand`> as far as japanese manga goes, it's fairly tame
14:37:54 <johnw> lol
14:38:02 <frerich_> :-)
14:38:25 <nand`> armlesshobo: I think the word ‘category’ is taken by something else
14:38:41 <shapr> Yiq: I heard Cloud Haskell works on the Raspberry Pi now.
14:39:04 <ahkurtz> yes, and it takes a million years to compile
14:39:14 <shapr> zzing___: are you looking at GHCi-on-Acid?
14:39:23 <zzing___> si
14:39:29 <zzing___> It was mentioned on the wiki
14:39:32 <Yiq> shapr: correct
14:39:35 <shapr> I don't know, but I heard that johnw was working on something like that.
14:39:48 <johnw> what was I working on?
14:39:51 <shapr> If it takes a million years, I better start building cloude haskell right now!
14:39:55 <Yiq> http://alenribic.com/writings/post/raspberry-pi-in-a-haskell-cloud
14:39:56 <shapr> johnw: lambdabot inside ghci
14:40:09 <johnw> i wanted to run lambdabot inside emacs, not ghci
14:40:24 <shapr> oh
14:40:46 <ahkurtz> if you wait longer maybe they'll fix that part :-*
14:41:03 <ahkurtz> definitely not gonna be me, too stupid
14:41:15 <johnw> kind of the opposite of "if you build it they will come?"  "If you wait, they will build it"
14:41:25 <shapr> hah
14:41:28 <ahkurtz> "if you wait, it will build"
14:42:45 <n00b6502> would it be insane to try and write a parser as a fold:         foldr     (combineTokenWithObject)  emptyObject    tokenStream
14:43:13 <johnw> n00b6502: if you never needed to consume more than one token per term of your grammar
14:43:29 <johnw> and how would you deal with precedence?
14:43:37 <startling> johnw: you could do all that
14:43:47 <startling> it wouldn't be pretty though
14:43:48 <armlesshobo> nand`: hmmm. okay
14:43:54 <johnw> startling: well, true
14:44:00 <johnw> it depends on how stateful the combiner is
14:44:20 <zzing___> Is it correct that you cannot use a user packages and cabal-dev sandbox at the same time?
14:44:23 <startling> yeah
14:44:27 <johnw> but then you're just transferring complexity
14:44:29 <n00b6502> (foldr (combineTokenWithObject)    (reorderTokenStream rawTokenStream))
14:44:31 <barrucadu> johnw: Operator precedence can be implemented with tree rotations on the resultant parse tree
14:44:33 <johnw> it's the same solution, only refactored so you can use a fold
14:44:42 <johnw> barrucadu: good point!
14:44:42 <n00b6502> result=(foldr (combineTokenWithObject)   (emptyojbect) (reorderTokenStream rawTokenStream))
14:45:00 <n00b6502> result=(foldr (combineTokenWithObject)   (emptyojbect) (applyParseTree rawTokenStream))
14:45:22 <barrucadu> As I found out when I decided to write a toy compiler earlier this year, before I learned how to do it properly :P
14:45:43 <n00b6502> aka 'can i write a parser without a monad' :)
14:45:57 <nand`> yes, with an applicative :P
14:46:03 <startling> n00b6502: arrows
14:46:05 <Yiq> http://hackage.haskell.org/package/distributed-process
14:46:08 <nand`> I think some parsers are deliberately *not* monads
14:46:09 <Yiq> is that down fo you?
14:46:29 <startling> n00b6502: of course you can. turing-equivalence yo
14:46:58 <n00b6502> well perhaps the real question is "can a parser be written elegantly without monads"
14:47:21 <johnw> n00b6502: if you don't mind argument passing, absolutely
14:47:31 <zzing___> I thought applicative was able to be done decently
14:47:34 <n00b6502> relying on the 'fold' to do the argument parsing
14:47:40 <johnw> but why do it?  the monads saves you that redundancy
14:47:52 <n00b6502> i haven't invented monads myself yet
14:48:02 <johnw> you could write a nice, traditional, stack-based LL parser with a State monad which contains the term stack and current input string as its state
14:48:02 <n00b6502> that pathway isn't burned into my brain properly
14:48:27 <zzing___> n00b6502, do them in c++
14:48:35 <johnw> or, use Parsec
14:48:43 <johnw> and avoid resolving an ancient problem
14:49:14 <n00b6502> i'm only going to feel i understand haskell if i can do it myself ( even if i then go on to use Parsec)
14:49:26 <johnw> then do what zzing__ suggested
14:49:29 <johnw> implement the Maybe monad in C++
14:49:31 <johnw> that's what I did
14:49:34 <n00b6502> implement monads as templates ?
14:49:45 <johnw> you'd have to
14:49:48 <johnw> to emulate the type constructor
14:49:49 <zzing___> n00b6502, you would use templates and probably some metaprogramming
14:50:05 <johnw> that is, if you want your monad to feel like the Haskell monad
14:50:15 <n00b6502> yeah that is what  it will take
14:50:20 <johnw> n00b6502: https://gist.github.com/3382999
14:50:29 <johnw> that's a simple Maybe<T> with short-circuiting evaluation
14:50:31 <n00b6502> i'm quite solidly wanting to write C++ with map,fold, filter where possible
14:50:35 <n00b6502> i'm totally sold on that
14:50:58 <n00b6502> those are burned into my head
14:51:53 <johnw> n00b6502: what my Maybe<T> implementation lacks is >>=
14:52:00 <Yiq> whats that about when sites are down for some people but not for others?
14:52:01 <johnw> so it would be a good exercise to add a "bind" method
14:52:10 <n00b6502> ok
14:52:22 <zzing___> I I would like a C level languages in haskellish syntax
14:52:28 <n00b6502> same here
14:52:35 <n00b6502> partial application, type inference instead of templates
14:52:37 <n00b6502> tuples
14:52:42 <hpc> Habit was supposed to be that language
14:52:49 <n00b6502> and NO SODDING HEADER FILES :)
14:52:51 <hpc> dunno if it died or what
14:52:58 <johnw> C++11 does have type inference
14:53:01 <johnw> auto and decltype
14:53:11 <zzing___> johnw, c++11 is amazing
14:53:24 <n00b6502> C++11 is a massive step foward but not as good as haskell you have to jump through hoops to get the output still
14:53:47 <zzing___> n00b6502, concepts will seal the deal…
14:53:50 <johnw> and its generic programming facilities are still hobbled by incredibly obscure syntax and a lack of concepts
14:54:03 <n00b6502> template<typename A,typename B>  doSomething(A,B) -> SOME_HOOPS_TO_GET_RETURN_TYPE { return ...myfunctoin }
14:54:24 <johnw> hopefully concepts will make it into C++17
14:54:32 <zzing___> johnw, c++99
14:54:35 <hpaste> Yiq pasted “cabal install base problem” at http://hpaste.org/73339
14:54:53 <n00b6502> through replies to this type of internet ranting, i discovered something called "clay"
14:54:58 <zzing___> johnw, or maybe they just have to called it c++2328
14:55:00 <Yiq> ^^ i dont get that
14:55:05 <johnw> there is already ConceptClang, so it's not like the problem hasn't been solved to a certain degree
14:55:10 <hughfdjackson> is there really no prettier way to keep the .hi and .o files out of the way than specifying an --output directory?
14:55:20 <n00b6502> "clay" is a c like language with type inference instead of templates , and other niceities
14:55:20 <hughfdjackson> in ghc, i mean
14:55:30 <hughfdjackson> *-outputdir
14:55:32 <zzing___> I think I would really like some haskell-like C level language that has the facilities to do meta-programming that doesn't suck
14:56:00 <n00b6502> i often hear someone says "the IO monad" in response to that
14:56:10 <Yiq> top level dependancy -any?
14:56:16 <johnw> I want C++ meta-programming to use C++, the way that CL works
14:56:34 <n00b6502> so like lisp macros are to lisp ?
14:56:39 <johnw> yeah
14:56:41 <nand`> template metaprogramming best metaprogramming
14:56:46 <johnw> lisp macros have all of CL at their disposal
14:56:58 <zzing___> Does cabal just wrap the Setup.hs if it is included?
14:56:58 <johnw> you can use a macro to read new code in from a file if you want to!
14:57:25 <johnw> n00b6502: have you seen MetaFun?  http://gergo.erdi.hu/projects/metafun/
14:57:31 <johnw> it converts Haskell to C++ TMP code
14:57:41 <n00b6502> nice
14:57:47 <johnw> well, a Haskell-like syntax
14:58:02 * timthelion "hm, is this -blah?"
14:58:04 <fmap> Yiq: what ghc version are you using?
14:58:42 <zzing___> Is it possible to have the ability to limit side effects and many of the wonderful monads without having to do all the lifting and such? That could prevent mass appeal to where I think we need to go.
15:00:13 <johnw> zzing___: I don't quite understand your question
15:00:49 <n00b6502> haskell "skeptics" say, "look at the hoops they have to jjump through with monad transformers to work with state..."
15:00:55 <n00b6502> sometimes
15:00:58 <zzing___> johnw, much of the noise I have seen in code involving different monads involves the unwrapping and lifting and so on.
15:01:25 <hpc> n00b6502: it helps to point out that those hoops are just to avoid IORef
15:01:43 <n00b6502> another thought going through my mind is... what would haskell look like as a graphical node-chart
15:02:01 <n00b6502> (avoid naming variables as links in a chart)
15:02:28 <hpc> n00b6502: a DAG with a locally graph-like structure
15:02:29 <n00b6502> editing programs that way is really clunky with mouse+keys but might work ok with touchscreen
15:03:06 <hpc> or better-phrased
15:03:18 <hpc> a graph, with a DAG-like shape at larger scales
15:03:31 <nand`> DAG?
15:03:39 <n00b6502> DirectedAcyclicGraph
15:03:49 <hughfdjackson> :/ i really feel like i'm missing something here
15:03:51 <ahkurtz> a tree if you like
15:03:52 <n00b6502> recursion will loop back
15:03:55 <n00b6502> cycles
15:04:05 <hpc> ahkurtz: not a tree; children can have multiple parents in a DAG
15:04:07 <hughfdjackson> haskell developers don't just deal with the .o .hi etc intermediate file mess manually do they?
15:04:23 <hughfdjackson>  / with seperate *nix tools, etc
15:04:36 <nand`> generally you wouldn't
15:04:41 <hpc> ahkurtz: an example DAG would be haskell module imports
15:04:50 <hpc> branches and leaves are modules
15:04:57 <nand`> but some programs exist which operate on those files; and in some situations you need to be at least aware of their presence, if nothing more
15:04:58 <hpc> draw arrows from modules to modules that import them
15:05:17 <hpc> so at the leaves we have modules that import from stuff above them
15:05:25 <hpc> and multiple roots, which are modules that import nothing
15:05:35 <hughfdjackson> nand`: ah; so the go-to is to put them in a build file and not worry about it?
15:05:47 <hpc> ignoring .hs-boot files, GHC doesn't do cyclic imports
15:05:52 <hpc> so that's the acyclic part
15:05:53 <zzing___> I use cabal-dev to install everything to a specified sandbox, I move the directory and now it wants to install everything again
15:06:00 <hpc> and directed, because we draw arrows instead of lines
15:06:35 <johnw> zzing___: I don't see any way around that.  liftM turns a pure function into one that operates in the context of the Monad, the same way that fmap does for functions applied to a Functor.  If you don't lift it somehow, it can't affect the monad (and won't type check if you try).  Your only option then would be to restrict yourself to using functions whose return type is already in the monad, which would be severely limiting, like
15:06:35 <johnw> writing one's entire program in the IO monad.
15:07:13 <zzing___> johnw, what about being able to detect at that compiler level if the function needs to be lifted?
15:07:24 <johnw> that could introduce very subtle bugs
15:07:32 <johnw> you'd be thwarting the very value of the type inference engine
15:07:33 <Yiq> fmap: how do i check? because platform says 2011.4 in the folder but im sure i have th latest. 7.2or something'
15:07:57 <johnw> you're asking if Haskell can auto-lift pure functions
15:07:59 <fmap> Yiq: ghc --version
15:08:07 <danil> zzing___, johnw: something like that has been tried, though not in Haskell: http://lambda-the-ultimate.org/node/4321
15:08:17 <hpc> that auto-lifting would fuck with doubly-lifted stuff
15:08:32 <Yiq> 7.0.4
15:08:41 <johnw> or times when failing to lift reflects an incorrect assumption on the coder's part
15:09:20 <johnw> danil: interesting
15:09:36 <fmap> Yiq: you probably need to upgrade to 7.4.1 or something to use distributed-process since it wants base >= 4.4
15:09:43 <zzing___> gotta love my phone… "Congrats! Your number has made you Apple's winner! Go to http://apple.ca.bgbss.biz/2/ and enter code "6417" to claim an Apple product! Be sure to register now!"
15:09:53 <armlesshobo> does anyone here use a special debugger for haskell?
15:10:25 <Jeanne-Kamikaze> do you have to debug haskell ?
15:10:32 <nand`> hughfdjackson: what I do is just dump them into an extra directory; but I do agree they tend to become annoying if all you care about is the executable
15:10:41 * armlesshobo shrugs
15:10:58 <nand`> hughfdjackson: though they speed up rebuilds
15:11:30 <hughfdjackson> nand`: i take it ghc checks timestamps and all of that good stuff to make sure it doesn't act as a stale cache?
15:11:40 <kallisti> armlesshobo: I typically use trace statements. I've never needed a debugger, but ghci has one.
15:12:08 <danil> the short story is, inferring returns/binds is perfectly doable as long as you separate the code where they're inferred from the code where you want to use them manually
15:12:16 <geekosaur> hughfdjackson, it does, absent -fforce-recomp
15:12:25 <hughfdjackson> :D brill, thanks for the tips
15:12:26 <ahkurtz> hpc: I am stupid. Up until this very point I thought it was just a special kind of tree that allowed for a node to have multiple parents.
15:12:37 <nand`> hughfdjackson: I think it checks hashes or something. I'm not quite sure
15:16:09 <hughfdjackson> nand`: that'd be another sensible option :3
15:18:56 <n00b6502> perhaps a graphical representation of a haskell program would be less of a gimmick than with imperative stateful programs
15:20:19 <armlesshobo> actually, my goal is to step throuh a couple haskell programs or something to get familiar with some of the tools available.
15:23:03 <MagneticDuck> hey, I have a question... what's the most efficient way to read / write a large recursive data structure to and from a file?
15:23:13 <geekosaur> someday, we need an updated hat
15:24:18 <MagneticDuck> (I made a text file parser for humans to write and read said data structure, but it will be inefficient to constantly read / write it from a program)
15:25:08 <MagneticDuck> any ideas?
15:25:12 <ragusa> binary, I guess
15:25:17 <ragusa> @hackage binary
15:25:18 <lambdabot> http://hackage.haskell.org/package/binary
15:25:31 <kallisti> @hackage cereal
15:25:31 <lambdabot> http://hackage.haskell.org/package/cereal
15:26:13 <jfischoff> maybe you can keep the structure resident in memory and apply patches
15:26:21 <jfischoff> @hackage gdiff
15:26:22 <lambdabot> http://hackage.haskell.org/package/gdiff
15:28:10 <latro`a> johnw--saying liftM does something in the same way as fmap is an understatement :p
15:28:45 <shachaf> latro`a: liftM does the same thing as fmap, but it doesn't do it the same way.
15:29:16 <latro`a> that depends on how the fmap is implemented
15:29:30 <latro`a> it's not unusual to define instance Functor Something where fmap = liftM
15:29:37 <jfischoff> conceptually they are the same
15:29:54 <latro`a> they just *are* the same, categorically
15:30:01 <jfischoff> yes
15:30:13 <jfischoff> that's a better way of putting it
15:30:22 <WinVery> http://winvery.com
15:30:39 * shachaf wonders whether you could have fmap and liftM with different strictness behavior.
15:30:48 <nobdraisentone> What package should I use to found a list of vertices reachable from a given vertex of a polymorphic graph?
15:31:07 <nobdraisentone> s/of a/in a/
15:31:11 <hughfdjackson> aside from avoiding problems with lazy evaluation (and maintaining the level of nominal purity of the language)
15:31:18 <latro`a> whether you could define them that way? sure. but it should probably be the case that both are lazy unless it's nonsensical to have them not be
15:31:23 <latro`a> erm
15:31:25 <latro`a> s/not//
15:31:36 <hughfdjackson> does the IO monad have any qualities that a sandbox imperative environment would have?
15:31:45 <hughfdjackson> *wouldn't have
15:31:59 <jfischoff> nobdraisentone: have you looked at fgl?
15:32:21 <nobdraisentone> jfischoff: not yet
15:32:24 <jfischoff> @hackage fgl
15:32:24 <lambdabot> http://hackage.haskell.org/package/fgl
15:33:41 <nobdraisentone> jfischoff: looks nice, thanks
15:33:49 <jfischoff> np
15:34:07 <zzing___> If I copy .cabal and .ghc and replace them as necessary, would that be able to effectively isolate different installed things when I am testing? cabal-dev is giving me some problem and thought a manual solution might be simpler.
15:34:36 <danil> hughfdjackson: the fact that monadic computations are values lets you implement control structures within the language (e.g. when and mapM in Control.Monad), though you could get a similar effect by wrapping everything in functions (like ruby does with blocks)
15:35:07 <hughfdjackson> :D i'll take alook at those
15:35:28 <nobdraisentone> Well, > type Node = Int
15:35:53 <WinVery> the end is nigh :) http://winvery.com
15:36:11 <shachaf> @where ops
15:36:11 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
15:36:25 <danil> hughfdjackson: mapM is a bad example actually (since the thing it takes is already a function), but it's true for `when`, `sequence`, and most of the `monad-loops` package
15:36:46 <nobdraisentone> jfischoff: any others?
15:38:01 <jfischoff> nobdraisentone: probably, I'm just not familiar with them
15:45:31 <dotnull> hello
15:46:06 <jfischoff> hi dotnull
16:08:13 <squidz> what is the best way to work with data, when it is for simple programs. Normally in java i would setup a database, but I would like to know the haskell way of doing it.
16:09:00 <squidz> ive seen acid-state, but dont know if thats what I need
16:09:21 <nand`> acid-state is for when you want state to persist in between program runs
16:09:31 <nand`> on top of this, it provides ACID guarantees.
16:09:36 <nand`> (similar to databases)
16:09:42 <nand`> if this sounds like what you want, then acid-state is what you want
16:10:54 <squidz> nand`: so learning acid-state should be sufficient for about any non-enterprise program that i do in haskel?(because i heard acid-state runs in memory, i suppose that is is perfect for anything except very large amounts of data)
16:11:01 <donri> acid-state is great if you can fit your data in RAM and don't have to use an existing (live) database
16:11:13 <nand`> acid-state can run remotely too
16:12:00 <donri> still need to fit it in RAM on some server somewhere, though
16:12:20 <squidz> i think it should be fine memory-wise
16:12:39 <nand`> I'd like to be pedantic and claim that it needs to fit in memory, not RAM - so if you use large swap files on a dedicated server there's not a terrible lot of distinction
16:12:44 <donri> although if you have logically separate data you can use multiple states that you can run on different servers
16:12:46 <squidz> since i am only playing around. And if I were to do anything serious then I could use a remote server
16:13:02 <donri> nand`: i hear GHC is terrible for swapping though
16:13:13 <nand`> at any rate, I'm not sure how acid-state handles memory in general
16:13:36 <nand`> squidz: note that if you do not need persistent state, you do not need acid-state either
16:13:48 <LadyAurora> donri: that's because swapping is terrible.
16:13:48 <nand`> for just ‘playing around’ there doesn't seem to be much of a use of the former
16:13:59 <nand`> donri: entirely possible, I have no knowledge on this matter
16:14:12 <squidz> so now my next question, I am a beginner at haskell, but have heard that i should try to keep my IO under control. What is best-practice for setting up and accessing data with acid-state
16:14:13 <donri> LadyAurora: varnish author seems to disagree ^_^
16:14:58 <squidz> in java i would make a service layer that accesses the data
16:15:13 <donri> squidz: you have to go IO if you want durability (there's a pure backend for acid-state but it's not logged and mostly useful for testing)
16:15:14 <squidz> can i keep all the data accessing in one spot in haskell
16:15:36 <nand`> I would like to suggest using free monads for this purpose, but I'm not too sure it'd be all too helpful
16:15:41 <donri> squidz: yea, with acid-state you'll already be writing transactions as separate functions
16:15:41 <LadyAurora> donri: then that person is mistaken about how computers work. Disk will never be as fast as RAM.
16:15:56 <donri> LadyAurora: well duh. but that guy is a bsd kernel dev.
16:16:13 <squidz> donri: so i just write it wherever it is needed?
16:16:22 <donri> LadyAurora: the point is if you need to serialize to disk, let the OS do it (but this doesn't work well with GHC)
16:16:34 <donri> squidz: not sure what you're asking.
16:17:31 <donri> squidz: http://www.happstack.com/docs/crashcourse/AcidState.html#acid_state this is probably the best docs on acid-state
16:17:49 <squidz> donri: it could be that i have the wrong idea because i have almost zero experience with haskell and exactly zero experience with acid-state, but i guess what i'm asking is organization-wise, where do you normally define your data?
16:18:26 <donri> squidz: you use normal haskell data types in acid-state
16:18:33 <donri> squidz: so organization is up to you
16:18:51 <squidz> donri: so there are no patterns or best practices?
16:18:52 <nand`> squidz: I've been programming Haskell for a long time and never needed to keep data anywhere other than memory
16:19:21 <squidz> nand`: sorry i mean where we write the data types in code
16:19:22 <nand`> I don't really know what kind of answer you're expecting, since it depends on the situation you're in, doesn't it?
16:19:27 <nand`> well
16:19:32 <donri> squidz: as for manipulating the data, you write updates as computations in a state monad and queries as computations in a reader monad, so it's a bit like a "model" in an ORM
16:19:42 <nand`> usually you split larger projects up into modules; and it's not uncommon to have a module for ‘types’ where you define the data type
16:19:54 <nand`> donri: that's just one possible model
16:19:57 <nand`> out of very many
16:19:59 <nand`> I'd like to stress that
16:20:04 <donri> what?
16:20:10 <nand`> using State and Reader
16:20:13 <nand`> for managing data
16:20:18 <donri> i'm talking about acid-state
16:20:28 <nand`> sorry, I misinterpreted
16:20:29 <squidz> okay, thanks, you guys are being very helpful, even though my questions were so vague
16:20:36 <donri> well, i was unclear :)
16:20:49 <nand`> squidz: if you're writing a small project (<200 lines); you'd just have all of your types etc. in the same file
16:21:32 <donri> squidz: i suppose you saw these too? http://mirror.seize.it/acid-state/examples/
16:21:40 <squidz> ill read the acid-state tutorial to get started. I was told yesterday on this channel, that while playing around with Monads i might want to avoid IO since it is somewhat of an exception. Does the same applay with acid-state?
16:21:52 <nand`> if you're new to Haskell I don't recommend jumping into acid-state
16:21:54 <LadyAurora> nand`: and if you write a project bigger than that, you're doing something wrong, because Haskell is überconcise.
16:22:00 <nand`> squidz: how much Haskell do you know?
16:22:07 <latro`a> not sure why to avoid basic IO
16:22:13 <nand`> LadyAurora: meh, the cap definitely goes larger than 200
16:22:18 <nand`> LadyAurora: even xmonad has like 500 lines
16:22:26 <donri> well some people recommend learning monads separately from IO to avoid confusing the two
16:22:37 <donri> IO has a Monad instance, that's about it
16:22:45 <nand`> I don't see how IO is an exception to monads
16:22:46 <squidz> i just finished LYAH and want to start playing around with code. I normally do a lot of DB stuff so I thought about jumping into acid-state
16:22:51 <nand`> it's a fairly monad-y monad as far as monads are concerned
16:23:04 <nand`> ah, so you read through LYAH - I was going to suggest that
16:23:10 <donri> i heard it breaks some monad law though
16:23:14 <latro`a> huh?
16:23:17 <nand`> donri: it doesn't
16:23:21 <donri> alright
16:23:45 <donri> http://www.r6.ca/blog/20110520T220201Z.html
16:23:48 <latro`a> if you write the monad laws as do notation and then read them as imperative code they are blatantly obvious
16:24:05 <latro`a> hence, via obviousness, they apply to the IO monad, since the IO monad is just imperative code
16:24:13 <latro`a> ^worst pseudo-proof evar
16:24:16 <nand`> the monad laws are ‘sanity’ laws; they encode that >>= and  return work together the way you'd expect them to
16:24:17 <danil> nand`: the fact that its representation is hidden makes it somewhat less illuminating as an example, but that's not the same as being an exception
16:24:31 <nand`> the same goes for many laws
16:24:32 <nand`> eg. lens laws
16:24:34 <latro`a> arguably I'd say it's *more* illuminating but harder to grasp
16:25:02 <latro`a> erm, s/arguably//
16:25:03 <nand`> I don't think the IO monad is just imperative code - imperative code in general I would liken to the free monad
16:25:10 <nand`> because the free monad encapsulates flow
16:25:11 <latro`a> I know
16:25:14 <latro`a> I commented on that
16:25:17 <latro`a> with the caret
16:25:17 <nand`> but I see where you're coming from
16:25:19 <latro`a> it was sarcasm
16:25:28 <latro`a> ...something like sarcasm anyway
16:25:32 <LadyAurora> Free monad?
16:25:47 <nand`> LadyAurora: the free monad associated with any functor
16:26:05 <latro`a> the existence of free monads is somewhat special to Hask, I assume?
16:26:13 <nand`> latro`a: not sure where you're coming from
16:26:18 <latro`a> with what
16:26:23 <nand`> being special to Hask
16:26:30 <nand`> oh, you mean as in other categories not having free monads?
16:26:33 <latro`a> yeah
16:26:43 <nand`> I'm not sure
16:26:47 <nand`> maybe you need sums and products
16:26:49 <latro`a> every functor has a free monad in Hask, I suspect the same is not true elsewhere
16:26:51 <nand`> (you definitely do in Hask)
16:27:04 <nand`> edwardk: ?
16:27:14 <edwardk> ?
16:27:24 <squidz> he has been summoned
16:27:25 <nand`> edwardk: do categories other than Hask have free monads for *every* functors?
16:27:25 <edwardk> latro`a: no free monads live everywhere
16:27:35 <latro`a> how can that be
16:27:59 <latro`a> how can you have a free monad if, say, your functor isn't pointed
16:28:05 <latro`a> and can't be pointed
16:28:16 <nand`> functors in Hask don't need to be pointed to make a free monad
16:28:19 <nand`> unless I'm misunderstanding
16:28:21 <nand`> you mean Pointed ?
16:28:36 <latro`a> oh wait nvm
16:28:37 <edwardk> you need _some_ structure, notably coproducts
16:28:39 <latro`a> the type constructor isn't the same
16:28:42 <latro`a> right
16:28:47 <latro`a> so no, they aren't everywhere
16:28:53 <nand`> oh right; earlier I claimed you need sums and products - but you don't need products
16:29:15 <latro`a> was gonna say, any universal existence statement in category theory is remarkable
16:29:19 <latro`a> especially of a rich object like a monad
16:29:29 <latro`a> the Yoneda lemma is remarkable for its universality
16:29:31 <edwardk> correcta free monad is just left adjoint to the forgetful functor that takes a monad in the category of monads to its base functor in the category Cat of functors.
16:29:46 <edwardk> it exists wherever that left adjoint can be constructed ;)
16:29:48 <latro`a> "just left adjoint" involves assumptions about existence of adjoints
16:29:52 <edwardk> yes
16:29:54 <latro`a> which are fairly strong
16:29:57 <edwardk> yes
16:30:13 <latro`a> also
16:30:14 <latro`a> wow
16:30:15 <latro`a> that's really cool
16:30:26 <edwardk> ?
16:30:36 <danil> latro`a: you can generalize "free monad of a signature" in categories with the right structure, but I'm not sure exactly what property lets you interpret (endo-)functors in Hask as algebraic signatures
16:30:39 <latro`a> that statement you just made
16:31:05 <latro`a> about free monads as left adjoints to a really natural forgetful functor
16:31:16 <latro`a> "natural", not category-natural
16:31:33 <nand`> it doesn't just apply to monads
16:31:45 <nand`> eg. the free monoid is left adjoint to the forgetful functor taking each monoid to its carrier
16:31:49 <donri> squidz: if you have any further questions on acid-state and this channel is too noisy, #happs is good
16:31:54 <davesque> is there any good documentation on how to use regexes in haskell?  i've found very few (if any) articles which are understandable.
16:31:58 <nand`> in general, ‘freeness’ implies left adjointedness to forgetful functors
16:32:01 <latro`a> I knew that, nand`
16:32:07 <latro`a> but I didn't know *which* forgetful functor
16:32:11 <nand`> oh
16:32:46 <edwardk> latro`a: so being left adjoint it tells you a monad homomorphism F f -> m is isomorphic to f -> U n in the category of endofunctors, so when you work it out it says that every monad homomoprhism from the free monad is equivalent to just giving a natural transformation from the base functor to the target monad
16:32:50 <davesque> does anyone know?
16:32:54 <kgzm> exit
16:33:10 <nand`> davesque: there are a few regex packages on hackage but I think they're all horrible
16:33:29 <nand`> in the basic case it should be as simple as "foobar" =~ "oo"
16:33:51 <donri> davesque: i like the rex package
16:33:56 <davesque> nand`: but what if you want to get groups in a match?
16:34:06 <nand`> davesque: then I have no idea
16:34:11 <edwardk> oh that reminds me i need to add a compiler from regular expressions to machines
16:34:15 <edwardk> =)
16:34:21 <donri> davesque: http://hackage.haskell.org/packages/archive/rex/0.3.1/doc/html/Text-Regex-PCRE-Rex.html
16:34:28 <nand`> edwardk: do you have one for regular languages?
16:34:31 <davesque> donri: mkay i'll check that out
16:34:33 <edwardk> nand`: not yet
16:34:39 <edwardk> i just have mealy and moore machines
16:34:48 <nand`> I would go with that first, then a compiler from regex to regular languages :)
16:34:51 <edwardk> so you can run a autamata
16:34:55 <edwardk> er automata
16:35:03 <edwardk> er automaton even sheesh
16:35:57 <edwardk> well, the mealy driver lets me deal with infinite state automata, so DFAs fit in that
16:40:25 <nand`> data Dialogue1 = Stop
16:40:28 <nand`>                | Go Request (Response -> Dialogue1)
16:40:30 * nand` smiles
16:43:09 <MostAwesomeDude> :t 42
16:43:10 <lambdabot> forall t. (Num t) => t
16:48:45 <MostAwesomeDude> Hey, is this ^^ polymorphic numeric literal thing unique to lambdabot, or can I rely on that?
16:49:14 <S11001001> MostAwesomeDude: it's in prelude
16:49:56 <kallisti> not technically. it's just a language feature. It's part of Haskell 98
16:50:47 <monochrom> you can rely on it
16:51:15 <MostAwesomeDude> Okay. I'm doing some hax, and I wanted to know how feasible this might be: do { thing; 42; otherThing }
16:51:31 <avpx> Err?
16:51:59 <dmwit> very feasible
16:52:01 <avpx> That won't type check unless you're using the Identity monad
16:52:10 <MostAwesomeDude> Or unless I create a new Num instance. >:3
16:52:12 <dmwit> That is not necessarily true.
16:52:15 <dmwit> right =)
16:52:17 <shachaf> avpx: That's not how Identity works.
16:52:26 <avpx> shachaf: Heh, you're right
16:52:41 <avpx> Scratch that last part, I can't see how that will type check ever
16:52:52 <nand`> it will
16:53:16 <nand`> > do { negate; 42; succ } $ 50
16:53:17 <lambdabot>   51
16:53:24 <monochrom> ha
16:53:39 <donri> yay NumInstances
16:53:49 <DT``> :t do { negate; 42; succ }
16:53:50 <lambdabot> forall b. (Num b, Enum b) => b -> b
16:53:51 * avpx throws out all his Haskell code and goes back to C
16:53:57 <avpx> Apparently I have no idea what I'm doing
16:53:57 <dmwit> davesque: Capturing groups is still just (=~), but at a different type. =)
16:54:03 <shachaf> > 1 :: (Int,Double)
16:54:04 <lambdabot>   (1,1.0)
16:54:06 <danil> :t do { return (); 2 + 2 } -- avpx
16:54:08 <lambdabot> forall (m :: * -> *) b. (Monad m, Num (m b)) => m b
16:54:08 <shachaf> Ah, lambdabot has that instance too.
16:54:24 <shachaf> But you probably can't use that for Writer.
16:54:32 * dmwit disappears in a puff of smoke
16:54:53 <nand`> shachaf: you can if you can find some numeric monoid
16:55:10 <shachaf> And a Monoid w => (w,) instance for lambdabot.
16:55:13 <shachaf> Which you don't have.
16:55:13 <nand`> arguably trivial; instance Num a => Num [a]
16:55:46 <shachaf> ?
16:55:57 <shachaf> > 1 :: [Int]
16:55:58 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
16:55:59 <lambdabot>    arising from the literal `...
16:56:02 <shachaf> lambdabot doesn't have that either.
16:56:09 <DT``> isn't (+) morally a monoid?
16:56:24 <DT``> I mean, mappend = (+).
16:56:33 <shachaf> (+) and 0 sometimes form a monoid.
16:56:35 <DT``> and mempty = 0.
16:56:43 <shachaf> > getSum $ Sum 1 `mappend` Sum 2
16:56:45 <lambdabot>   3
16:56:45 <nand`> shachaf: you mean instance Monoid w => Monad (,) w?
16:56:47 <donri> also (*) and 1
16:56:56 <nand`> > return 3 :: ([Int], Int)
16:56:58 <lambdabot>   No instance for (GHC.Base.Monad ((,) [GHC.Types.Int]))
16:56:58 <lambdabot>    arising from a us...
16:57:03 <shachaf> nand`: Yes. That was implied.
16:57:07 <nand`> yeah
16:57:11 <nand`> you'd need that too :(
16:57:16 <nand`> well, you can still use it for Writer
16:57:16 <shachaf> DT``: However, (+) and 0 don't form a monoid for Double.
16:57:39 <DT``> shachaf, Double is an hack anyway.
16:57:49 <donri> Double plus ungood :(
16:57:57 <nand`> :t writer 42
16:57:58 <lambdabot> forall a w. (Num a, Num w) => Writer w a
16:58:03 <shachaf> Double plus ungood /= ungood plus Double :-(
16:58:27 <nand`> :t tell [10] >> writer 42
16:58:28 <lambdabot> forall t b. (Num [t], Num b, Num t) => WriterT [t] Identity b
16:59:34 <davesque> nand`: looks like you can get group matches like so... :m Text.Regex.Posix; getAllTextSubmatches $ "xyz abc" =~ "([a-z]+) ([a-z]+)" :: [String] == ["xyz abc", "xyz", "abc"]
17:00:05 <nand`> there you go. ugly :)
17:00:16 <davesque> nand`: heh, yeah
17:00:29 <nand`> usually you'd use something like a static parser for this sort of thing
17:00:35 <nand`> instead of a crufty regex
17:00:59 <davesque> nand`: i see...was wondering.  seemed like an odd absence of regex facilities
17:01:16 <nand`> there are lots of odd absences of horrible things other languages seem to popularize in Haskell
17:01:21 <davesque> nand`: i figured it meant it isn't idiomatic
17:01:29 <nand`> you figured right
17:01:46 <davesque> nand`: would you whip out something like parsec?
17:01:58 <nand`> I don't know. I've never written parsers
17:02:05 <davesque> nand`: mkay
17:02:06 <nand`> I think there are much lighter alternatives
17:02:30 <davesque> mkay.  thanks
17:03:55 <danil> generally I go for attoparsec if I can and parsec if I must
17:05:57 <n00b6502> heh doubleplus ungood
17:06:52 <n00b6502> anyone tried naming a computer language "newspeak"
17:07:17 <DT``> n00b6502, yes!
17:07:20 <DT``> http://newspeaklanguage.org/
17:07:33 <n00b6502> lol i had to ask. its the internet. everything has been done.
17:07:38 <shachaf> @google anyone tried naming a computer language "newspeak"
17:07:39 <lambdabot> http://en.wikipedia.org/wiki/Newspeak_(programming_language)
17:07:39 <lambdabot> Title: Newspeak (programming language) - Wikipedia, the free encyclopedia
17:07:47 <shachaf> Asking Google is much more efficient than asking #haskell. :-)
17:07:48 <n00b6502> i'll ask first, has the pun "doubleplus" been used with it aswell
17:07:57 <n00b6502> newspeakdoubleplus
17:08:02 <n00b6502> cdoubleplus
17:08:05 <n00b6502> cdoubleplusungood
17:08:23 <shachaf> Ask first, think questions later!
17:08:40 <DT``> what's a think?
17:08:58 <nand`> https://duckduckgo.com/?q=anyone+tried+naming+a+computer+language+%22newspeak%22 <- for when you don't feel like google monitoring your search queries :(
17:09:16 <nand`> a think is an evaluated thunjk
17:09:18 <nand`> -j
17:09:27 <shachaf> #not-haskell
17:09:43 <DT``> nand`, but the monitoring helps me to not feel alone.
17:14:19 <dmwit> I have m indistinguishable balls and n distinguishable buckets. I want to choose uniformly between all the ways of dropping all the balls into buckets. What do?
17:15:13 <shachaf> Enumerate all the ways, choose a number between 1 and x.
17:15:21 <ParahSailin_> @google building ridiculously big boms
17:15:23 <lambdabot> http://answers.yahoo.com/question/index?qid=20081127061758AAesbjC
17:15:23 <lambdabot> Title: Really ridiculously BIg BOOBS :O? - Yahoo! Answers
17:15:30 <latro`a> lol
17:15:35 <nand`> nice title.
17:16:01 <dmwit> I clicked. I was disappointed.
17:16:11 <nand`> dmwit: do indistinguishable dropping methods count as the same?
17:16:38 <dmwit> hm =)
17:16:43 <nand`> like say I have one ball in my left hand and one in my right; and I drop one into the left bucket and one into the right; does this count as a distinct way from dropping the left ball into the right bucket and vice versa?
17:16:58 <shachaf> You're asking about all the sequences of n naturals that add up to n, I assume.
17:17:12 <nand`> m, yes
17:17:12 <dmwit> shachaf: yes, but n and n aren't necessarily the same
17:17:17 <dmwit> nand`: The balls are indistinguishable.
17:17:23 <shachaf> dmwit: Er, one of those was an m.
17:17:34 <shachaf> You're asking about all the sequences of n naturals that add up to m, I assume.
17:17:35 <nand`> right; then what shachaf said - all sequences of n nats that add up to m
17:17:41 <dmwit> yes
17:17:57 <monochrom> for 2 balls (indistinguishable) and buckets A,B (distinguishable), you can have (A=0, B=2), (A=1, B=1), (A=2, B=0) --- 3 ways
17:18:00 <nand`> and thus, we can write shachaf's original solution directly
17:18:18 <dmwit> Is there really nothing better than enumerating them all?
17:18:26 <shachaf> dmwit: There surely is.
17:18:30 <nand`> filter (==m) n [1..m]
17:18:31 <shachaf> I gave a worst-case solution.
17:18:32 <nand`> oops
17:18:32 <dmwit> I mean, I can certainly do that. And that's what I'm doing now.
17:18:37 <monochrom> there is a better way, but I have forgotten all my combinatorics
17:18:38 <nand`> filter (==m) . replicateM n [1..m]
17:18:53 <shachaf> nand`: That's not right.
17:19:03 <shachaf> You want to nub it, at least.
17:19:05 <ParahSailin_> :t replicateM
17:19:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
17:19:22 <nand`> filter ((==m) . sum)
17:19:29 <nand`> I'm not sure why you want to nub it
17:19:29 <dmwit> replicateM n [1..m] will not produce any duplicates for nub to eliminate.
17:19:30 <danil> dmwit: the objects you're interested in are called "integer partitions", and it seems there's some literature on generating them randomly
17:19:32 <monochrom> aw, please don't spend time golfing a slow solution!
17:19:37 <nand`> oh
17:19:40 <nand`> you meant nub the replicateM
17:19:42 <nand`> yeah then what dmwit said
17:19:47 <DanBurton> suppose I have two cabalized projects in folders ./foo and ./depends-on-foo, is there a way to build depends-on-foo by using the code found in the "foo" folder?
17:19:53 <shachaf> nub on the sum, I mean.
17:19:56 <shachaf> No, wait.
17:20:04 <shachaf> Ignore that.
17:20:12 <ddarius> Actually, lambdabot acts kind of like Tor with respect to Google searches.
17:20:32 <nand`> > filter ((==2) . sum) $ replicateM 2 [0..2]
17:20:35 <lambdabot>   [[0,2],[1,1],[2,0]]
17:20:37 <nand`> ddarius: no, because logs are public
17:20:44 <dmwit> DanBurton: yes, cabal install foo/ depends-on-foo/
17:20:49 <ddarius> nand`: You can private message lambdabot.
17:20:57 <ddarius> Though, yes, the point is defeated in #haskell.
17:21:01 <nand`> fair point
17:21:02 <shachaf> Anyway, we want something better than enumerating.
17:21:06 <shachaf> So ==monochrom
17:21:10 <DanBurton> dmwit: excellent, thank you
17:21:16 <dmwit> danil: Thanks for the pointer, I'm googling.
17:21:17 <monochrom> I think you must register foo first. but you can use cabal-dev to register very localizedly
17:21:52 <shachaf> danil: I don't think dmwit is quite after integer partitions.
17:22:09 <ddarius> > nubBy((>1).:gcd)[2..] -- to spite monochrom
17:22:09 <shachaf> E.g. 1 + 2 and 2 + 1 are the same partition.
17:22:12 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
17:22:32 <monochrom> damn you haha
17:22:47 <dmwit> Yes, the buckets are distinguishable, so integer partitions don't quite seem to be it.
17:22:57 <dmwit> And there's a fixed number of buckets, too.
17:23:15 <danil> oh, hmm
17:23:22 <ddarius> dmwit: Ask Cale.
17:23:34 <dmwit> Cale, byorgey: ping!
17:23:41 <dmwit> You guys do combinatorics, right? =)
17:24:22 <shachaf> dolio does combinatorics.
17:24:33 <shachaf> But only when byorgey is around, I think.
17:25:41 <shachaf> @let arrng = (\b s -> filter ((==s).sum) . replicateM (fromIntegral b) $ [0..s])
17:25:43 <lambdabot>  Defined.
17:25:46 <shachaf> > map (arrng 2) [0..]
17:25:49 <lambdabot>   [[[0,0]],[[0,1],[1,0]],[[0,2],[1,1],[2,0]],[[0,3],[1,2],[2,1],[3,0]],[[0,4]...
17:25:56 <shachaf> > map (length . arrng 2) [0..]
17:26:00 <lambdabot>   mueval-core: Time limit exceeded
17:26:03 <monochrom> the barbara substitutability principle says that if you can impersonate byorgey then dolio will do combinatorics :)
17:26:04 <shachaf> > map (length . arrng 2) [0..]
17:26:08 <lambdabot>   mueval-core: Time limit exceeded
17:26:14 <shachaf> Hmm.
17:26:19 <shachaf> > take 15 $ map (length . arrng 2) [0..]
17:26:21 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
17:26:22 <shachaf> > take 15 $ map (length . arrng 3) [0..]
17:26:25 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120]
17:26:35 <sipa> (m+n-1)!/((n-1)!*m!), no?
17:27:43 <shachaf> sipa: Multichoose!
17:27:48 <shachaf> (Is it?)
17:28:03 <sipa> i have no idea what it's called
17:28:12 <shachaf> n+k-1 choose k
17:28:29 <sipa> i just envision it at placing m-1 separators between the n balls
17:28:41 <shachaf> The number of unordered k-tuples of values of type n.
17:28:41 <nand`> @oeis 1 3 6 10 15 21 28 36 45 55 66 78 91 105 120
17:28:43 <lambdabot>  Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
17:28:43 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,2...
17:28:48 <sipa> and the separators individually and the balls individually are indistinguishable
17:28:48 <dolio> wat
17:29:03 <nand`> > take 15 $ map (length . arrng 4) [0..]
17:29:05 <lambdabot>   [1,4,10,20,35,56,84,120,165,220,286,364,455,560,680]
17:29:14 <shachaf> nand`: I think we can imagine how the pattern continues. :-)
17:29:18 <nand`> @oeis 1 4 10 20 35 56 84 120 165 220 286 364 455 560 680
17:29:19 <lambdabot>  Tetrahedral (or triangular pyramidal) numbers: a(n) = C(n+2,3) = n*(n+1)*(n+...
17:29:19 <lambdabot>  [0,1,4,10,20,35,56,84,120,165,220,286,364,455,560,680,816,969,1140,1330,1540...
17:29:21 <nand`> ha
17:29:22 <dmwit> dolio: How can I pick uniformly at random between the different ways of placing m indistinguishable balls in n distinguishable buckets?
17:29:23 <nand`> you're right
17:29:54 <dolio> dmwit: Use the axiom of choice.
17:30:10 <dmwit> The axiom of choice says nothing about uniform distributivity. =)
17:30:27 <sipa> dmwit: generate m+n-1 numbers, randonly
17:30:29 <dolio> Make a new axiom of uniform choice, then.
17:30:48 <sipa> the first uniformly between 1 and m+n-1
17:30:49 <shachaf> When in doubt, make a new axiom.
17:30:55 <latro`a> lol
17:30:58 <MostAwesomeDude> Is that an axiom?
17:31:02 <sipa> the second between 1 and m+n-2
17:31:06 <sipa> and so on
17:31:11 <latro`a> "theorem is true because I axiomatically say so?"
17:31:12 <shachaf> sipa: That reminds me of the thing dolio said about k-tuples.
17:31:19 <latro`a> erm
17:31:21 <latro`a> *so
17:31:28 <latro`a> "are you sure that's consistent with the other axioms?"
17:31:38 <latro`a> "shut up"
17:31:40 <latro`a> etc.
17:31:43 <sipa> dolio: use that to randomly permute a list with n balls and m-1 separators
17:31:48 <Cale> dmwit: What's up?
17:31:58 <sipa> than read out the resulting number of balls between the separators
17:32:17 <dmwit> Cale: The question I've been asking is "How can I pick uniformly at random between the different ways of placing m indistinguishable balls in n distinguishable buckets?".
17:32:31 <sipa> dmwit: ^
17:32:48 <dmwit> sipa: That's not bad.
17:32:52 <Cale> dmwit: ah, think of it this way
17:33:00 <Cale> er, yes, what sipa just said
17:33:21 <Cale> you don't have to permute the balls
17:33:50 <dmwit> What does that mean?
17:34:04 <dmwit> You're saying there's a more efficient way to shuffle the list?
17:34:26 <Cale> the balls are indistinguishable
17:34:33 <dmwit> So are the separators.
17:34:36 <Cale> so you just have to decide where the separators go
17:34:41 <dmwit> ...if I'm reading it right.
17:34:49 <sipa> yes
17:34:53 <shachaf> Oh, I've heard the separator thing before.
17:35:22 <shachaf> Except the question was with any number of buckets except a specific number.
17:35:23 <sipa> yes i am throwing away some entropy
17:35:24 <dolio> shachaf: I don't really do combinatorics. That's why I need byorgey to do the hard stuff.
17:35:35 <dmwit> Cale: "just have to decide where the separators go" <- how, if not by shuffling a list with m balls and n-1 separators?
17:35:41 <sipa> so there may be a more efficient way
17:35:56 <sipa> but just permuting the list was the easiest thing i can come up with
17:36:21 <shachaf> dolio: But you do types, right? Isn't that basically combinatorics?
17:36:41 <dolio> I guess.
17:37:04 <dolio> Translating questions about balls and buckets into types isn't my forte, though.
17:37:26 <shachaf> dolio: I suspect there's a meaningful translation of that question somehow.
17:37:59 <ddarius> shachaf: Sure, as a combinatorial species.
17:38:16 <shachaf> dolio: ...If anything, what you do is translate questions about types into balls and buckets in order to understand them. At least for some things.
17:38:24 <dolio> Species are different than types, though. That was the point of the byorgey discussion.
17:38:46 <Cale> I believe you should get a uniform distribution if you just pick uniformly among the n buckets, m times.
17:39:08 * ddarius needs to decide what to eat tonight.
17:39:23 <dolio> I'm supposed to write up the whole thing for edwardk's blog.
17:39:25 <Cale> hmm, is choosing a permutation any better or worse than that?
17:39:42 <shachaf> Cale: Pick uniformly among the n buckets?
17:39:47 <Cale> yes
17:39:47 <dmwit> Cale: Really? I would expect that to be really skewed towards partitions that have nearly equal amounts of balls in each bucket?
17:40:21 <Cale> hmm
17:40:52 <dolio> dmwit: It doesn't matter which ball goes in which bucket, is the point?
17:40:54 <shachaf> Oh, I see what you mean.
17:41:23 <dmwit> dolio: Well, "which ball" doesn't matter, but "which bucket" does.
17:41:35 <dolio> Does it?
17:41:50 <dmwit> For this problem, yes.
17:41:56 <dolio> If you arbitrarily order the buckets, is 3 2 1 the same as 2 3 1?
17:42:17 <dmwit> No, they're different. The buckets are distinguishable.
17:42:19 <nand`> the buckets are distinguishable
17:42:29 <dolio> Like, if 'there is a bucket with 3 balls a bucket with 2 balls and a bucket with 1 ball' is one possible solution?
17:42:34 <dolio> Oh, okay.
17:42:46 <Cale> oh, I guess it also can't be right, because the probability of getting (m,0,0,0,...) is clearly 1/(n^m), which is much less than it ought to be, yes.
17:42:48 <dmwit> No. "The first bucket has three balls, the second has two balls, and the third has one ball" is a solution.
17:43:03 <dolio> Okay.
17:43:40 <nand`> again, the problem is completely summarized by “pick uniformly between all n-tuples that add up to m”
17:44:02 <dmwit> Yep, that's a fine formulation. n-tuples of naturals
17:44:13 <Cale> I wonder what we get if we try to randomise a generator for all such compositions.
17:44:33 <Cale> I guess you get a lot of cases where you need to try again
17:44:34 <nand`> hmm
17:44:38 <Cale> which might not be efficient
17:44:42 <nand`> is filter f . randomize = randomize . filter f ?
17:44:55 <dolio> Well, there's a type for that, but I'm not sure how to figure out how big it is.
17:45:10 <Cale> nand`: what's randomize?
17:45:21 <dolio> Once you figure out how big it is, you just put in bijection with a finite set somehow, and then pick uniformly from the finite set.
17:45:28 <dmwit> nand`: if randomize is uniform, and filter renormalizes... then yes
17:45:35 <nand`> Cale: shuffles a list; for the sake of brevity using unsafePerfomIO
17:45:47 <dmwit> Oh, that's different.
17:46:18 <dmwit> Though the equation still seems plausible. It "feels" right.
17:46:21 <Cale> nand`: I'd say "yes", making some assumptions about what "same" means :)
17:46:54 <nand`> hard to argue about “same” when you're implying randomness
17:47:00 <nand`> here I meant “will they both have a uniform distribution”
17:47:12 <dmwit> No, you meant "will they have the same distribution".
17:47:17 <dmwit> (I hope that's what you meant, anyway.)
17:47:29 <nand`> uhm, probably
17:47:35 <nand`> I'm not up to terms with these terms
17:48:22 <nand`> what I'm really getting at is:  head . filter f . randomize vs head . randomize . filter f; will both pick fairly?
17:48:45 <nand`> ie; are they equal to pick . filter f
17:49:09 <dolio> data T k n where () : T 0 0 ; (,) : (m : Nat) -> T k n -> T (1 + k) (m + n)
17:49:19 <maurer> So, say I have a moderately large read only database. Is there any way that I can get this imported into my program such that accesses can be pure without having to essentially rebuild all the indexes haskel-side?
17:49:32 <latro`a> nand`: in general filtering and randomization don't play nice with one another iirc
17:49:37 <shachaf> haurer
17:49:54 <latro`a> because the result doesn't normalize in the same way, more or less
17:50:06 <maurer> *haskell-side
17:50:14 <latro`a> might be mistaken, though
17:50:32 <nand`> latro`a: that is what I had feared; otherwise dmwit's problem would be perhaps more efficiently solved (compared to brute force) by generating the combinations in a random fashion and then finding the first one that has sum m
17:50:55 <shachaf> maurer: What do you mean by "rebuild all the indexes" (and "imported")?
17:51:06 <ddarius> maurer: unsafePerformIO
17:51:11 <shachaf> Is this the thing where you embed the database directly into the executable?
17:51:38 <maurer> ddarius: I guess?
17:52:01 <maurer> shachaf: So, the naive way for me to do this is that at initialization, it reads the entire database into a list, then builds maps pointing to the elements
17:52:11 <maurer> Where the "indexes" are essentially the trees used by the maps
17:52:37 <maurer> ddarius: My hope was actually to not have it call out to the database after load time
17:52:45 <maurer> Ideally I'd preprocess the data into the binary
17:52:52 <Cale> It seems like picking a uniform random permutation in S_n and then deleting all indices i > k should get you a uniform random permutation in S_k
17:53:04 <Cale> but maybe not?
17:53:11 <Cale> It's hard to tell, so probably not.
17:53:15 <Cale> :)
17:53:43 <maurer> I guess I could just create a caching map that triggers unsafePerformIO calls any time a thunk is hit
17:53:51 <Cale> well, which sort of permutation in S_k would be preferred then?
17:53:57 <dmwit> maurer: Seems like a use case for TH.
17:54:06 <shachaf> dmwit: Why TH?
17:54:16 <dmwit> Parse the database at compile time and stick a Haskell value in your code. Ta-da!
17:54:33 <maurer> dmwit: So, I kind of considered this, and may do something like that, but am worried that the first accesses to the database will be slow if I do tht.
17:54:37 <maurer> *that
17:54:38 <shachaf> dmwit: The database is ~1.4GB
17:54:43 <shachaf> (I assume.)
17:54:53 <shachaf> (Just seems like, y'know, a reasonable size.)
17:55:00 <dmwit> maurer: Is the database 1.4GB?
17:55:03 <maurer> shachaf: I wonder where that number came from :P
17:55:12 <maurer> dmwit: About. I can shave it down to about 350MB
17:55:26 <nand`> 350 MB .exe, no problem
17:55:39 <maurer> nand`: I mean, it's personal use, so that's fine
17:55:43 <dmwit> I wonder whether that's pushing the boundaries of what GHC can handle or not.
17:55:46 <dmwit> I actually have no idea.
17:56:02 <nand`> I've never tried compiling a 350 MB large haskell file
17:56:03 <ddarius> dmwit: It definitely would as normal Haskell source.
17:56:03 <shachaf> I don't think GHC is designed to handle it, at least.
17:56:15 <maurer> dmwit: Hm. The other possibility I could do would be to write a Data.Binary instance and put it into a .rodata section and forcibly link it in
17:56:20 <maurer> nand`: It'll be larger in source too :(
17:56:27 <maurer> nand`: As everything will have to be quoted and such
17:56:37 <slack1256> shachaf: I don't think any compiler is designed to compile a 350MB file.
17:56:37 <nand`> maurer: yeah plus the structure added
17:56:56 <shachaf> Some compilers are designed to generate 350MB files, though.
17:56:56 <nand`> Java compilers must be
17:57:00 <shachaf> It's easy with g++
17:57:32 <ddarius> It's easy with GHC.
17:57:42 <slack1256> shachaf: but usually that to much meta-trickery with STL.
17:57:57 <dmwit> The largest file on Hackage is 72,443 lines long.
17:57:58 <ddarius> You can never have too much meta-trickery.
17:58:13 <otters> dmwit: what is it
17:58:18 <dmwit> Which is not very close to 350MB, I guess -- off by a factor of 50 at least.
17:58:26 <shachaf> It's easy with g++ for a few-hundred-line file to generate a 300MB .o file.
17:58:30 <dmwit> otters: ecu/src/CANDB.hs
17:58:33 <maurer> (The overall goal here is that I want to make an actually-safe way to grab my database and throw it in memory, ideally at compilation time)
17:58:34 <otters> a type-level "hello world" program?
17:58:36 <shachaf> Easy to do it accidentally, that is.
17:58:36 <otters> oh
17:58:37 <dmwit> otters: Seems to be a static database. =)
17:58:40 <otters> I see
17:58:44 <dmwit> Just the kind of thing we're discussing.
17:58:46 <ddarius> shachaf: I'm pretty sure I can do that with GHC too.
17:59:09 <maurer> Yeah, the database is "update no more frequently than 3 months, usually once per 6"
17:59:38 <shachaf> What kind of database is it?
17:59:52 <maurer> shachaf: Sizes are based on sqlite, but it can be translated to whatever
18:00:07 <shachaf> I mean, what's in it?
18:00:14 <maurer> shachaf: EVE Online game data
18:00:14 <ddarius> Presumably you could add it to a binary section and then use sqlite in memory.
18:00:25 <shachaf> Oh.
18:00:28 <maurer> ddarius: That would be cool if sqlite knew how to do that
18:00:59 <dmwit> Thanks to all for your help.
18:01:38 <maurer> (basically the issue is I'd like queries like "What does X item refine to" to be pure, and logically, these things _can_ be pure
18:02:35 <ddarius> Just build an image-based environment for Haskell, then your problem will be solved.
18:02:59 <maurer> ddarius: "image-based" ?
18:03:10 <shachaf> Like Smalltalk, I assume.
18:03:25 <MissionControl> this is going to be a stupid question but...   what is haskell?
18:03:32 <nand`> A programming language
18:03:36 <MissionControl> and how is it different from other languages?
18:03:42 <MissionControl> specifically java?
18:03:52 <shachaf> MissionControl: See haskell.org.
18:03:53 <dmwit> Haskell is an advanced purely-functional programming language. An open-source product of more than twenty years of cutting-edge research, it allows rapid development of robust, concise, correct software. With strong support for integration with other languages, built-in concurrency and parallelism, debuggers, profilers, rich libraries and an active community, Haskell makes it easier to produce flexible, maintainable, high-quality s
18:04:00 <MissionControl> : \
18:04:01 <nand`> it's based on a strong static type-system, pure evaluation and non-strict semantics
18:04:12 <shachaf> Whew.
18:04:18 <shachaf> This channel is so easy to troll. :-(
18:04:30 <sipa> and it is most likely completely different from any other language you may know
18:04:56 * nand` imagines some disgruntled Lazy ML, Agda, Mercury etc. programmer scoffing
18:05:25 <sipa> or VHDL, SQL, or Excel programmer
18:05:36 <sipa> (also purely functional languages, right?)
18:05:45 <sipa> not higher-order though
18:05:53 <nand`> ..but are they based on a strong static polymorphic type system with nonstrict semantics?
18:06:02 <sipa> hardly
18:06:03 <nand`> I think those are all defining attributes of haskell
18:06:13 <sipa> sure
18:06:32 * nand` thinks ‘declarational’ is a better label than ‘functional’, at any rate
18:06:45 * hackagebot modular-prelude 0.3.0.0 - A new Prelude featuring first class modules (DanBurton)
18:06:46 <sipa> declarational is a vague term
18:06:46 <shachaf> maurer: What sorts of queries are you doing on the database?
18:06:48 * hackagebot modular-prelude-classy 0.1.0.0 - Reifying ClassyPrelude a la ModularPrelude (DanBurton)
18:06:49 * hackagebot daemons 0.1.1 - Daemons in Haskell made fun and easy (AlexandruScvortov)
18:07:01 <dmwit> "declarative"?
18:07:10 <nand`> oh; I probably meant that
18:07:17 <latro`a> it's sorta both
18:07:28 <sipa> i understand it to mean "somewhat less concerned with specifying ooerational semantics than usual"
18:07:28 <maurer> shachaf: So, for the moment it's mostly queries into the crafting/refinement database, so it's literally just "Item ID foo, table bar, what comes out of that" ?
18:07:31 <latro`a> functions are the main piece of control flow, but that's true in most usage of lisps too
18:07:39 <maurer> shachaf: But I'd like to bind the database
18:07:47 <maurer> So that later I can do things
18:07:49 <sipa> yeah, declarativ
18:07:50 <sipa> e
18:10:07 <nand`> “In spite of its lack of popularity, LISP (now "Lisp" or sometimes "Arc") remains an influential language in "key algorithmic techniques such as recursion and condescension"[2].”
18:10:12 <nand`> Haha, I read this a few times but never picked that up
18:10:57 <shachaf> maurer: Maybe you can make a http://www.sqlite.org/c3ref/vfs.html for accessing .rodata?
18:11:28 <sipa> what is condescension?
18:11:42 <latro`a> think "condescending" :p
18:11:55 <sipa> and that is?
18:12:07 <latro`a> sorta looking down on etc.
18:12:09 <nand`> to treat someone as inferior, to patronize
18:12:12 <nand`> to talk down etc.
18:12:13 <sipa> ah
18:12:15 <sipa> ok
18:12:40 <sipa> it sound more sciency than that
18:13:00 <nand`> that's the joke
18:13:12 <nand`> well, part of it
18:19:48 <slack1256> is there a way to link source-code to the haddock documentation in .cabal/ as in hackage?
18:19:52 <maurer> shachaf: That could work, but I'm starting to think I should just do IO and call it a day.
18:20:17 <shachaf> maurer: unsafePerformIO isn't all that bad for something that's really guaranteed to be read-only.
18:20:44 <shachaf> I mean, it's just an implementation detail. Every call to ByteString does an unsafePerformIO.
18:20:55 <roconnor> edwardk: I wrote a few theorems about traversals and kleene stores @ http://r6research.livejournal.com/26693.html
18:20:57 <shachaf> (Actually it does something more unsafe than that.)
18:21:02 <nand`> what happens if you delete the executable while it's running?
18:21:45 <nand`> shachaf: what does it do? unsafe casting?
18:21:48 <shachaf> nand`: Nothing, on Linux.
18:22:11 <nand`> shachaf: well, I meant if the unsafePerformIO thing is trying to read itself, but the file no longer exists; how would that work?
18:22:14 <maurer> shachaf: If it's not in memory, the unsafePerformIO can raise errors = not pure.
18:22:20 <shachaf> nand`: unsafePerformIO has protection against a thunk being evaluated by multiple capabilities simultaneously.
18:22:25 <maurer> Memory is the only thing I have integrity gaurantees on
18:22:26 <edwardk> roconnor: nice
18:22:28 <shachaf> maurer: Oh, sure, I meant in-memory.
18:22:34 <shachaf> I thought that's what you were doing.
18:22:35 <maurer> shachaf: In memory that would be fine
18:22:38 <nand`> oh
18:22:42 <shachaf> nand`: You can't make the file no longer exist.
18:22:46 <nand`> I thought this was about “how do I avoid holding 350 MB in memory?”
18:23:03 <nand`> shachaf: it still exists on disk, but what interface are you going to use to read it?
18:23:09 <nand`> the file node no longer exists
18:23:12 <shachaf> nand`: The same one you were always using.
18:23:17 * nand` is confused
18:23:19 <dmwit> the node still exists
18:23:20 <shachaf> It's not as if you open() the file for every read.
18:23:23 <dmwit> Your assumption is faulty.
18:23:25 <nand`> oh
18:23:34 <nand`> hrm, right; yes
18:23:45 <maurer> nand`: I am cool with 350MB in memory
18:23:49 <maurer> nand`: This is a matter of avoiding
18:23:51 <roconnor> the two main results are (TraversableIdLaw (Coalgebroid_to_Traversable t) <-> CoalgebroidExtractLaw t) and (@TraversableComposeLaw i o (fun a b => Coalgebroid_to_Traversable (t a b)) <-> @CoalgebroidDuplicateLaw i o t).
18:23:53 <maurer> 1.) Initialization time
18:23:54 <nand`> you open it once and keep that handle in an IOVar or something
18:23:57 <maurer> 2.) Impurity
18:24:05 <nand`> maurer: right, this was going tangent to your problem
18:24:05 <maurer> I am thinking I'll just amke it impure and deal with it
18:24:10 <maurer> nand`: Ah, my apologies
18:24:23 <shachaf> maurer: Aw. :-(
18:24:38 <dmwit> maurer: There is an mmap package on Hackage.
18:24:42 <otters> o____o
18:24:45 <dmwit> There are two, actually, I think.
18:24:46 <otters> roconnor: what language is that?
18:25:00 <maurer> dmwit: I don't think that really helps.
18:25:02 <dmwit> otters: Looks like Coq.
18:25:04 <nand`> dmwit: I must have been misusing terminology - I meant the file path no longer exists
18:25:12 <dmwit> nand`: Yes, that's true.
18:25:12 <otters> suck my coq
18:25:17 <roconnor> otters: coq 8.3pl4
18:25:25 <dmwit> otters: That's a new joke, never heard it before.
18:25:37 <nand`> dmwit: actually, me neither
18:25:38 <otters> That's a new reaction to overused jokes, never heard it before.
18:26:07 <nand`> all of the coq jokes I know involved more, uh, coloring; I guess
18:26:26 <sipa> such as?
18:26:35 <dmwit> Mix in a touch of Hoare logic for great amusement.
18:27:12 <nand`> sipa: hey; I just universally quantified - that doesn't mean I know any
18:27:30 <sipa> :)
18:27:44 <Philippa_> nand`: but did you stratify?
18:28:12 <nand`> I've never heard that word :(
18:28:38 <Philippa_> nand`: (im)predicativity - did you quantify over that quip?
18:28:47 <dmwit> nand`: You know how there's Set and Set0 and Set1 (or whatever they're called in Coq... maybe Type0 and Type1, etc.)?
18:28:55 <Philippa_> right, exactly
18:29:16 * Philippa_ shoots the joke in the head to put it out of its misery
18:29:16 <nand`> dmwit: yeah
18:29:23 <ddarius> I suspect there was exactly one LML programmer.
18:29:34 <nand`> there was one LML programmer, and he wrote GHC
18:29:41 <ddarius> He wrote HBC.
18:29:42 <Aktsa> oh
18:30:03 <nand`> fair enough
18:30:14 <nand`> but GHC also originated in Lazy ML, didn't it?
18:30:23 <ddarius> No, it was bootstrapped by HBC.
18:30:38 <nand`> “GHC originally started in 1989 as a prototype, written in LML (Lazy ML) by Kevin Hammond at the University of Glasgow.” hrm
18:49:55 <ddarius> nand`: Well, according to the History of Haskell, the prototype was completely rewritten, except for the parser, though they did allegedly use it to bootstrap GHC.  However, the first release of HBC is almost a year before GHC, and presumably, since it was in LML for a while longer, it was the route to build a GHC from scratch for a while, but we can ask lennart.
18:51:21 <ddarius> But I will modify it to there being exactly two users of Haskell and they each wrote major Haskell implementations.
18:51:39 <ddarius> s/Haskell/LML/
18:52:26 <ddarius> But only one also wrote the LML implementation.
19:19:26 <adnauseam> need light weight haskell for raspberry pi...
19:21:48 <ddarius> nhc is geared to a small memory footprint.
19:22:05 <Cale> wat: http://www.haskell.org/haskellwiki/IO%E5%85%A5%E9%96%80%E7%B7%A8 -- I didn't know this translation existed!
19:22:40 <ddarius> Cale: Me neither, but it doesn't surprise me.
19:23:18 <ddarius> Actually, I'm surprised there isn't a cn one.
19:23:37 <nexx> Just thought the same @ ddarius
19:24:55 <nand`> they didn't translate the code snippets :(
19:25:11 <nand`> are they cross-linked internally or something (eg. for bug fixes)
19:26:48 * hackagebot snaplet-i18n 0.0.3 - snaplet-i18n (HaishengWu)
19:32:16 <zzing_> Are there environment variables that handle locations of ~/.cabal and ~/.ghc?
19:36:32 <geekosaur> zzing, http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html#ghc-package-path
19:36:39 <geekosaur> no idea re Cabal
19:44:19 <zzing_> I wonder if ~/.cabal has to do with cabal install instead of the library
19:46:00 <geekosaur> .cabal is only used by cabal for package caches, builds, and staging
19:46:15 <nand`> ~/.cabal is used by cabal-install
19:46:18 <geekosaur> ghc knows nothug of it
19:46:22 <nand`> I reason this because I have cabal but not cabal-install and no ~/.cabal
19:46:27 <geekosaur> and cabal the library doesn;t use it either, yeh
19:50:04 <lewis1711> ok so a functor maps categories to other categories, like fmap. an endofunctor maps categories to itself... so like regular map? assuming lists are categories
19:50:25 <nand`> fmap is an endofunctor
19:51:13 <shachaf> No, Functor is an endofunctor.
19:51:37 <shachaf> lewis1711: I don't think "category" means what you think it means.
19:51:45 <nand`> maximum pedantry: any ‘f’ with a Functor f instance is an endofunctor
19:52:03 <shachaf> nand`: You can get more pedantry than that!
19:52:17 <shachaf> There are lots of endofunctors in Hask that aren't or can't be instances of Functor.
19:52:41 <shachaf> lewis1711: Every "Functor" in Haskell is an endofunctor.
19:52:51 <nand`> shachaf: that doesn't matter :)
19:53:04 <shachaf> lewis1711: When you say "Maybe" is a functor, that means it maps a type like "Int" to a type like "Maybe Int".
19:53:07 <lewis1711> I thought thought sets were a kind of category, where each object was a set and each arrow was a transfomration from one set to another
19:53:18 <shachaf> And a function like "Int -> Char" to a function like "Maybe Int -> Maybe Char"
19:53:26 <lewis1711> oh right. maps into to itself
19:53:27 <nand`> you also say that Maybe's fmap maps functions to functions between Maybes
19:53:29 <lewis1711> ?
19:53:44 <lewis1711> Maps int to itself, i mean
19:53:46 <nand`> sets are a kind of category; yes, but that's not the category we're reasoning about
19:53:58 <nand`> we're talking about one particular category
19:54:06 <lewis1711> nand`: it's the category I was using to familiarise myself with category
19:54:07 <nand`> Hask, where objects are haskell types and morphisms are haskell functions
19:54:24 <nand`> and not a bad category for that either; but Functor/fmap has nothing to do with it
19:54:27 <lewis1711> oh yes, right
19:55:12 <lewis1711> so a haskell monad deals with that category, of haskell objects and haskell functions?
19:55:30 <adnauseam> nhc :o
19:56:09 <adnauseam> MOST EXCELLENT
19:56:17 <adnauseam> would it run on arm ?
19:56:37 <adnauseam> wait, it should. nvm
19:56:58 <nand`> lewis1711: yes
19:57:46 <lewis1711> in if monads are a monoid... whats its identity?
19:57:50 <nand`> return
19:58:16 <nand`> return >=> f = f = f >=> return
19:58:19 <adnauseam> return n = m n
19:59:31 <nand`> adnauseam: ?
20:01:34 <lewis1711> ((Just 3) >>= return)
20:01:46 <nand`> is Just 3
20:01:48 <lewis1711> so >>= is the binary function, return is the ID
20:01:53 <nand`> no
20:01:54 <nand`> >=> is
20:02:06 <nand`> :t (>=>)
20:02:07 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
20:02:22 <ddarius> For monads as monoid objects in the category of endofunctors, join is the "multiplication".
20:02:51 <lewis1711> I don't have >=> :/
20:03:20 <ddarius> (>=>) isn't a monoid operation or even a multiplication of a monoid object since it's typed, making it into the "multiplication" of a category, i.e. composition i.e. Kleisli composition.
20:03:30 <lewis1711> ddarius: huh? multiplication? I'm even more lost now.
20:03:53 <nand`> ddarius: right
20:04:40 <nand`> ddarius: (>=>) can still be a monoid operation for Kleisli endoarrows, though
20:04:47 <ddarius> True.
20:05:10 <nand`> (which is the reason I brought it up in the first place, it's a good way to demonstrate the associativity property of join in practical terms)
20:05:38 <nand`> though join . join = join . fmap join works just as well
20:05:54 <nand`> it just doesn't look very monoid-y until you get under the hood
20:06:12 <sayuke> so MaybeT is not an instance of MonadPlus. Whats a nice way to execute a series of MaybeT's until one succeeds?
20:06:50 <nand`> huh
20:06:53 <nand`> MaybeT is a MonadPlus
20:07:24 <sayuke> "The instance MonadPlus is not provided, because it has ambiguous semantics."
20:07:35 <nand`> we must be looking at different MaybeTs
20:07:36 <nand`> http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/Control-Monad-Trans-Maybe.html#v:MaybeT
20:07:45 <nand`> “Monad m => MonadPlus (MaybeT m)”
20:07:56 <lewis1711> so, >=> is the binary operator in that monoid? not >>= ?
20:08:08 <nand`> in the monoid of kleisli endomorphisms, yeah
20:08:22 <nand`> but in the monoid in the category of endofunctors, join is like ddarius said
20:08:28 <sayuke> nand`: sorry I was looking at an old version of the docs
20:08:34 <ddarius> s/monoid/monoid object/
20:08:35 <sayuke> nand`: face palm
20:08:37 <nand`> note that join : M∘M → M
20:08:43 <nand`> sayuke: :)
20:08:54 <geekosaur> lewis1711, as I understand it, "multiplication" there is an abstraction of actual multiplication.  the canonical monoid is unit = 1 and multiplication is actual multiplication.  for monads, replace 1 with return and * with join
20:08:54 <lewis1711> which crazy smybol is join? :)
20:08:59 <geekosaur> it isn't
20:09:02 <ddarius> Did the semantics become unambiguous?
20:09:11 <geekosaur> although >>= is closely related
20:09:18 <nand`> lewis1711: I see η used for join
20:09:22 <nand`> (or was it μ ?)
20:09:25 <nand`> no, μ was return iirc
20:09:28 <lewis1711> I mean in haskell monads
20:09:40 <nand`> not sure what you're asking
20:09:44 <lewis1711> if I wanted to type my binary operator in my monad monoid, I would use what
20:09:57 <nand`> I don't think that's possible
20:10:09 <ddarius> geekosaur: You have to do more than that.  These monoid objects are not monoids.  The tensor product of the monoidal category (a different "monoid" here) is not cartesian/categorical product.
20:10:16 <nand`> unless you reify abstract categories or something
20:10:19 <nand`> but that's probably not what you're asking
20:10:22 <ddarius> Eta is return, mu is join.
20:10:36 <ddarius> mu for multiplication.
20:11:29 <nand`> there's a mnemonic as good as any
20:11:29 <lewis1711> but every monoid has to have a binary operator. haskells monads has one but you can't use it?
20:11:35 <nand`> lewis1711: ‘join’
20:11:41 <nand`> as ddarius said, it's a monoid object
20:11:44 <nand`> not a true monoid
20:12:03 <latro`a> the monadic values aren't monoid values, necessarily
20:12:08 <latro`a> (some are, but for unrelated reasons)
20:12:20 <nand`> by monadic values do you mean Monad m => m a ?
20:12:22 <latro`a> yeah
20:12:47 <nand`> lewis1711: if what latro`a described is what you're looking for, you're looking at MonadPlus
20:12:50 <nand`> every MonadPlus is a monoid
20:13:18 <nand`> well, (MonadPlus m => m a, mzero, mplus)
20:13:22 <latro`a> MonadPlus really only exists because of some awkwardness associated with kinds
20:13:43 <latro`a> I think?
20:13:57 <latro`a> I'm not sure why you can't do "instance Monad m => Monoid (m a) where ..."
20:14:09 <nand`> well, you can't do that in general
20:14:14 <latro`a> undecidableinstances fail?
20:14:14 <shachaf> latro`a: Not really.
20:14:19 <nand`> but you can do instance Monoid [a] -- or whatever
20:14:19 <shachaf> @google monadplus vs monoid
20:14:21 <lambdabot> http://www.haskell.org/pipermail/haskell/2006-January/017310.html
20:14:21 <lambdabot> Title: [Haskell] MonadPlus vs. Monoid
20:14:39 <shachaf> Hmm, that thread isn't helpful.
20:14:42 <latro`a> erm, that's not what I meant
20:14:50 <latro`a> instance Monoid [a], instance Monoid (Maybe a)
20:14:51 <latro`a> etc.
20:14:53 <latro`a> is what I meant
20:14:54 <nand`> oh
20:14:57 <nand`> wait
20:14:58 <latro`a> derp
20:14:59 <nand`> latro`a: MonadPlus has extra semantics
20:15:02 <latro`a> not sure why I said that other thing
20:15:06 <nand`> in the form of mzero >> _ = mzero; _ >> mzero = mzero
20:15:07 <latro`a> oh right
20:15:08 <latro`a> that
20:15:09 <nand`> something like that
20:15:09 <latro`a> yes
20:15:32 <latro`a> but there's no real reason for classes to enforce those laws separately, is there?
20:15:39 <ddarius> class Monoid (m :: k) (args :: [*]) where mempty :: m args; mappend :: m args -> m args -> m args
20:15:39 <nand`> I'm not sure
20:15:55 <latro`a> what's wrong with "if (m a) is also a Monoid, then mempty >> _ = mempty" etc.?
20:16:32 <nand`> latro`a: I think on shachaf's link Cale mentions the possibility of diverging instances
20:16:43 <shachaf> That wasn't what I meant.
20:16:57 <andyjgill> Evening all.
20:17:14 <nand`> I quote “The only trouble with this is that there may be a case where you have a MonadPlus type which is a monoid in a way which is separate from the way given above, and you want that instance instead. I can't really think of a good example of that happening though.”
20:17:43 <latro`a> if you can't find an example I don't think there should be a concern
20:18:19 <latro`a> but maybe there is one, where you have a sensible mzero and mappend but they don't interact with the monad operations correctly?
20:18:39 <latro`a> but then what *DO* they do with the monad operations
20:18:52 <latro`a> I guess I can imagine this:
20:18:54 <latro`a> mempty >> x = x
20:18:55 <nand`> disregarding ddarius's suggestion, there might be examples involving rank-2 types where the (Monoid (m a)) thing fails
20:18:58 <nand`> due to not being able to list all constraints
20:19:03 <lewis1711> in what sense are Monads not to true Monoids? because because they're not over the category of sets?
20:19:27 <latro`a> the thing that forms a monoid is the collection of Kleisli arrows with Kleisli composition and return as the identity
20:19:44 <latro`a> these aren't the values of type m a
20:19:47 <nand`> lewis1711: in the sense that (m, join, return) don't form a one-object category, I'd say
20:19:53 <latro`a> which is what they would need to be to get a monoid
20:20:40 <ddarius> latro`a: The (Kleisli) category is the collection of Kleisli arrows with Kleisli composition.
20:20:49 <latro`a> sure
20:21:03 <latro`a> that forms a monoid, in the sense that, modulo various inference issues
20:21:03 <nand`> the kleisli category gives rise to infinitely many monoids, each centered around a certain haskell type; mind
20:21:10 <latro`a> instance Monad m => Monoid (a->m b)
20:21:13 <latro`a> makes sense
20:21:24 <nand`> no
20:21:26 <latro`a> ish
20:21:27 <nand`> Monoid (a -> m a)
20:21:33 <latro`a> ah right, touche
20:21:39 <latro`a> composition gets you multiple objects
20:21:46 <latro`a> erm
20:21:49 <ddarius> Leading from a monoid to a category.
20:21:52 <latro`a> composition over distinct types gives you multiple objects
20:22:00 <latro`a> composition over just one type gives you one object i.e. a monoid
20:22:06 <nand`> yeah
20:22:28 <lewis1711> well this all serves me right for trying to understand monads without being a maths graduate
20:22:37 <ddarius> Yes, but this is not the monoid people mean when they talk about monads being "monoid objects in the category of endofunctors".
20:22:44 <nand`> I'm not a maths graduate; then again I probably don't truly understand monads
20:22:53 <lewis1711> I might read that bit on the wiki book on category theory, the algebraic data structures stuff makes sense
20:22:56 <ddarius> I would bet the vast majority of people here are not "maths graduates."
20:23:34 <nand`> lewis1711: are you genuinely interested in CT or is this just about understanding the role of monads in Haskell?
20:23:54 <lewis1711> nand`: both, but the latter is my main motivation right now
20:24:03 <conal> lewis1711: there's a gentle path to understanding Monad: Monoid, Functor, Applicative, Monad. when you to Monad, you'll realize it's no big deal.
20:24:06 <nand`> then I would advise forgetting about the CT definitions
20:24:22 <latro`a> I'm not sure why to start with Monoid at all
20:24:23 * nand` doesn't see how Monoid fits in that chain
20:24:33 <latro`a> yes the kleisli arrows form a monoid but so what
20:24:41 <nand`> when I started, I thought they must be pretty similar, since the names are
20:24:51 <conal> nand`: in that it's a simple & useful type class
20:24:56 <nand`> well, LYAH introduces them in that way
20:25:01 <latro`a> they are, but only via the CT abstraction
20:25:02 <latro`a> I think
20:25:02 <nand`> actually, I'm not sure
20:25:06 <nand`> does LYAH introduce applicatives before monads?
20:25:14 <latro`a> it does IO before applicatives iirc
20:25:22 <conal> :(
20:25:24 <latro`a> but applicatives are before monads in general
20:25:29 <latro`a> @where lyah
20:25:29 <lambdabot> http://www.learnyouahaskell.com/
20:25:31 <ddarius> latro`a: Again, Kleisli arrows don't form a monoid in general, and that's neither here nor there.  That said, I agree that the "monad as a monoid object" is a very roundabout way to get into monads in almost any context.
20:25:38 <nand`> uhm
20:25:47 <nand`> ‘Functors, Applicatives and Monoids’
20:25:49 <nand`> that order
20:26:15 <nand`> conal: I agree with Monoid being a simple and useful type class to help understand typeclasses, yes
20:26:18 <conal> i put Monoid first because it's a type (non-constructor) class
20:26:46 <conal> and so is less taxing conceptually
20:26:47 <ddarius> Every computer scientist should be intimately familiar with monoids (and to a large extent are.)
20:27:07 <latro`a> uh
20:27:09 <nand`> every computer scientist should be intimately familiar with /some/ monoids
20:27:18 <latro`a> if the point is to learn about non-constructor typeclasses
20:27:22 <nand`> most people should be
20:27:30 <latro`a> Eq, Ord, Show, etc. are more straightforward than Monoid
20:27:32 <latro`a> conceptually
20:27:42 <latro`a> I see your point that Monoid also has laws, though
20:27:59 <nand`> agree; I don't think conal's path was supposed to be absolute
20:28:00 <latro`a> which the others...kinda do, but they're so intuitive that they don't come to mind
20:28:01 <shachaf> Hey, conal is alive.
20:28:02 <nand`> it was cut off at both sides
20:28:03 <ddarius> nand`: Monoids, general and specific, are more important to CS people than they are to most other people, even most other people when restricted to just mathematicians.
20:28:07 <conal> nand`: right.
20:28:21 <nand`> I don't know which typeclass I would introduce first. Probably Num
20:28:29 <nand`> Perhaps Show
20:29:01 <nand`> but Num is a nice example to people familiar with writing polymorphic numeric algorithms (notably the ones in languages that can't)
20:29:13 <ddarius> Mathematicians tend to be more interested in groups.
20:30:20 <nand`> ddarius: can you list examples of why this is the case? I'm coming up with free monoid homomorphisms and their various uses
20:31:04 <hpaste> mast pasted “schemeparse” at http://hpaste.org/73342
20:31:22 <lewis1711> I have a decent handle on monoids, but I guess functors are new to me
20:31:42 <hpaste> mast annotated “schemeparse” with “schemeparse (annotation)” at http://hpaste.org/73342#a73343
20:32:11 <lewis1711> nand`: but you advise staying away from CT definitions?
20:32:19 <lewis1711> (was eating breakfast)
20:32:29 <nand`> lewis1711: if your goal is to learn their use in Haskell, yes
20:32:34 <ddarius> nand`: M-sets are rather extremely important for computer scince.
20:32:36 <ddarius> +e
20:32:41 <nand`> and I don't mean “staying away” but rather “not dwindling on them”
20:33:07 <lewis1711> fair point
20:33:11 <conal> lewis1711: you may appreciate the CT definitions more after you've played with some concrete incarnations in haskell.
20:33:18 <nand`> ddarius: M-set?
20:33:53 <lewis1711> well I liked what small but I'd learned of algebraic data structures, and I disliked not understanding haskell monads at all. I'll take your adice
20:33:57 <lewis1711> *small bit
20:34:04 <mast`> I'm following the wikibook about writing Scheme in Haskell and I have a parsing error on line 17 (http://hpaste.org/73342) but I really can't find what's wrong. I feel it might be something to do with indenting but I've been looking at it for 10 minutes now and can't find it
20:34:39 <ddarius> An M set is a set X, a monoid M, and an operation t : MxX -> X such that t(1, x) = x and t(a*b, x) = t(a, t(b, x))
20:34:53 <ddarius> Alternatively, an M set is a monoid homomorphism into an endofunction monoid.
20:35:23 <ddarius> (or you could curry the other argument and come up with a third representation)
20:35:30 <Cale> mast`: tabs
20:35:40 <nand`> ddarius: that makes sense
20:35:47 <Cale> mast`: Make sure to configure your editor to replace tabs with spaces
20:36:08 <mast`> Cale, aah, that's what I get for trying a new editor
20:36:08 <Cale> mast`: and align the "x <- ..." with the "char ..." in the previous line
20:36:21 <nand`> ddarius: I also see one immediate connection to computer science: any imperative model, that is any model which deals with sequenced actions; can be deconstructed into a free monoid set
20:36:29 <nand`> sound correct?
20:36:38 <ddarius> nand`: Well, an M-set is a form of state machine.
20:36:39 <lewis1711> ...this CT stuff is blowing my mind though. is there a noob friendly channel on that?
20:36:43 <conal> mostly i suspect that when people want to "understand monads", they're looking for something that isn't there. part of why i say "Monad" instead of "monads" in this context. people are already understand many monads (e.g. function, pair, Maybe, list) but say they they "don't
20:37:12 <Cale> lewis1711: You're not going to get much noob-friendlier than this one :)
20:37:12 <nand`> yeah; name ‘t’ as ‘exec’; * as ‘sequence’, let a/b be descriptions of actions in your system and the set X be the set of possible states
20:37:27 <Cale> lewis1711: anything I can help with?
20:37:31 <latro`a> I think once you understand a few concrete instances it mostly comes down to "what are the a->m b"?
20:37:33 <latro`a> erm
20:37:34 <latro`a> *?"
20:37:51 <nand`> we have summoned Cale
20:38:01 <nand`> lewis1711: is in good hands
20:38:18 <lewis1711> Cale: sure. so these arrows right? there sort of functions Object -> Object?
20:38:20 <ddarius> GPS is delightfully multidisplinary and interesting.
20:38:47 <lewis1711> and any arrow A such that that A(x) = x is an identity?
20:38:59 <Cale> lewis1711: It's more the other way around...
20:39:23 <nand`> “any arrow A such that A(x) = x” <- if you're talking about CT arrows, then it's important to distinguish arrows and functions
20:39:26 <Cale> lewis1711: Functions are the arrows in a category whose objects are sets
20:39:29 <nand`> some arrows are functions; many are not
20:39:42 <nand`> you can't “apply” arrows in general
20:39:45 <lewis1711> so they're more general than functions
20:39:48 <ddarius> As far as CT is concerned, arrows and objects have no structure.
20:40:06 <nand`> well, except for the structure given by the category itself
20:40:17 <nand`> ie. where the arrows point
20:40:33 <ddarius> Okay, arrows have source and target objects.
20:40:41 <nand`> right
20:40:45 <Cale> Yeah, let's review the definition of a small category
20:40:45 <ddarius> And there is, usually not stated, a notion of equality.
20:41:16 <lewis1711> an equality relation between objects?
20:41:17 <nand`> categories are like enhanced monoids; where each element (arrow) has a ‘type signature’ denoting what it can and can't be composed with
20:41:26 <Cale> You have a set Ob(C) of objects, and for each pair A,B of objects, you have a set C(A,B) of arrows A -> B
20:41:38 <nand`> and the set of objects is the set of ‘types’; I put this in quotes because thinking of objects = types can be misleading
20:41:45 <nand`> when you get to other sort of types, eg. the ones in programming language theory
20:42:04 <Cale> and for each three objects X,Y,Z, you have a function .: C(Y,Z) x C(X,Y) -> C(X,Z)
20:42:15 <Cale> called composition
20:42:20 <latro`a> it's also misleading because in the setting of "structured sets" there are sorta two sorts of categories
20:42:37 <latro`a> a category which is a single such set, and a category of many such sets and their morphisms
20:42:54 <lewis1711> wait categories are enhanced monoids over the *arrows*, not objects?
20:42:55 <Cale> and for each object X in Ob(C), there is a special arrow id_X in C(X,X)
20:43:01 <Cale> lewis1711: that's right
20:43:19 <Cale> lewis1711: a monoid is a category having one object (and all the arrows are from that object to itself)
20:43:41 <ddarius> lewis1711: The only purpose of objects in category theory is to label the ends of arrows so we know which arrows compose.
20:43:42 <nand`> ddarius: if we accept the notion that all of mathematics is based on ST, we get equality for free either way :)
20:43:53 <Cale> lewis1711: Also, there is another related notion of a preorder
20:44:08 <shapr> math based on STG machine?
20:44:13 <lewis1711> what's the one object in the  monoid then? the binary operator?
20:44:14 <ddarius> nand`: And categorists are one school that would not find that particularly keen (though most don't care).  Computer scientists are another school.
20:44:15 <latro`a> I think he meant CT
20:44:17 <Cale> A preorder is a set S together with a relation <= (i.e. a subset of S x S) such that:
20:44:23 <nand`> lewis1711: one important realization is that category theory focuses on the properties of *arrows*
20:44:23 <Cale> 1) for all a in S, we have a <= a
20:44:24 <nand`> not objects
20:44:35 <ddarius> latro`a: He meant Set Theory.
20:44:37 <nand`> I meant set theory
20:44:38 <latro`a> oh oh
20:44:40 <latro`a> right
20:44:43 <Cale> 2) for all a, b, c in S, whenever a <= b and b <= c, we have a <= c
20:45:02 <Cale> i.e. a reflexive, transitive relation
20:45:29 <Cale> A preorder is the same thing as a (small) category with at most one arrow between any two objects
20:45:44 <latro`a> uh
20:45:46 <latro`a> huh?
20:46:02 <latro`a> the subset partial order doesn't have at most one arrow between any two objects
20:46:14 <nand`> latro`a: it does
20:46:14 <latro`a> oh wait nvm
20:46:14 <lewis1711> so a preorder would be a less general case of a category?
20:46:16 <latro`a> derp
20:46:18 <latro`a> sleepy
20:46:19 <Cale> Specifically, we can construct the category explicitly with S being the set of objects, and putting an arrow a -> b whenever a <= b
20:46:19 <nand`> lewis1711: yeah
20:46:19 <lewis1711> sorry, a more general
20:46:33 <Cale> Preorders are a special case of categories
20:46:34 <nand`> ‘less general’ and ‘more general’ are often mixed up for some reason
20:46:36 <Cale> and so are monoids
20:46:40 <lewis1711> LOL
20:46:41 <lewis1711> special case
20:46:57 <lewis1711> makes sense
20:47:07 <Cale> You can sort of see categories as being like a conceptual product of these two notions
20:47:12 <Cale> monoids and preorders
20:47:19 <nand`> I think
20:47:28 <nand`> it makes more sense to view categories as inspired upon graph theory
20:47:36 <nand`> rather than preorders explicitly
20:47:39 <nand`> which are just subsets of graphs
20:48:07 <latro`a> categories are big directed graphs with some closure properties
20:48:14 <Cale> Preorders are an underappreciated structure though, so I like boosting their popularity :)
20:48:16 <latro`a> eh, "big" is unnecessary
20:48:21 <lewis1711> nand`: yes I saw some "pretty pictures" that seemed like directed graphs
20:48:28 <Cale> Everyone always talks about posets all the time
20:48:30 <Cale> :)
20:48:34 <nand`> latro`a: don't forget identity
20:48:35 <lewis1711> with the ID arrows being loops
20:48:41 <Cale> But preorders are more fundamental, I think :)
20:48:57 <nand`> type inference? posets!
20:48:58 <nand`> err
20:48:59 <Cale> (and a lot of the stuff which applies to posets also applies to preorders)
20:48:59 <ddarius> nand`: That's because "more theorems" might lead one to think more general, you can do more with it, but "more instances" is also viewed as more general.
20:49:02 <nand`> type coercion*
20:49:04 <latro`a> I said closure properties
20:49:07 <Cale> (and indeed, categories in general)
20:49:20 <latro`a> "closure under identity" :P
20:49:34 <ddarius> nand`: Basically, the variance properties of implication lead to this confusion.
20:49:54 <nand`> ddarius: yeah, I see it as “a poset is less general than a category because there are categories that are not posets”; but simultaneously “a poset is more general than a category because it gives you less power than a category”
20:50:02 <Cale> http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf
20:50:07 <Cale> ^^ my favourite intro book
20:50:23 <latro`a> nand`, in that case they're not comparable
20:50:24 <Cale> (hopefully not everyone in this channel tries to grab it at once :)
20:50:24 <latro`a> :p
20:50:26 <nand`> this is why I prefer the term ‘subset’ instead of ‘general’
20:50:32 <nand`> posets are a subset of categories
20:50:34 <nand`> no question there
20:50:36 <ddarius> Cale: People like equality.
20:50:52 <latro`a> then it can't *really* give you less power than a category
20:50:59 <latro`a> if you always get a category from it
20:51:17 <latro`a> this is like saying that >=> gives you less power than >>= when you can define the latter in terms of the former
20:51:21 <nand`> hmm, well
20:51:29 * ddarius would say there is a monomorphic functor including Pos into Cat.
20:51:44 <ddarius> (Actually, probably not even a monomorphism in general, though very likely in this case.)
20:51:45 * nand` .oO( Can you define >>= in terms of >=> ? )
20:51:57 <latro`a> m >>= f = (const m >=> f) ()
20:52:02 <Cale> nand`: yes, though it's mildly unnatural
20:52:06 <Cale> yeah
20:52:11 <latro`a> not especially natural but it works
20:52:13 <nand`> oh, right
20:52:14 <ddarius> I believe it relies on the strength of Haskell.
20:52:21 <ddarius> (The tensorial strength.)
20:52:28 <nand`> I remember coming across this a while ago, but that was defining >>= in terms of Kleisli m
20:52:31 <nand`> ie. just Arrow operations
20:53:12 <lewis1711> Cale: that books seems very accessible, can't beat the price either
20:54:02 <ddarius> (>>=), or usually (=<<) notated (f=<<) = f^*, is a "meta"-operation (a function from hom-sets to hom-sets) typically.
20:54:06 <Cale> lewis1711: It actually ordinarily costs money, and I'm not 100% sure I should be sharing it here, but I guess I consider dissemination of ideas to be more important than copyright.
20:54:18 <ddarius> Admittedly, so is (>=>)
20:54:38 <ddarius> (Well pairs of hom-sets to hom-sets.)
20:54:39 <Cale> (vastly more important)
20:54:59 <ddarius> Cale: Well, when your professor sues you, you can reconsider.
20:55:31 <ddarius> Actually, he may well not hold the copyright anymore.
20:55:43 <lewis1711> I'll keep it under my hat then
20:56:22 <Cale> Also, consider it as good advertising for the paper version.
20:56:46 <otters> :t f
20:56:48 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
20:56:51 <otters> > f
20:56:52 <lambdabot>   Ambiguous type variable `a' in the constraints:
20:56:52 <lambdabot>    `SimpleReflect.FromExpr ...
20:56:57 * ddarius highly likes Barr and Wells' ESSLLI lecture notes.
20:57:02 <ddarius> They are CS oriented.
20:57:21 <ddarius> And pretty readable, albeit not as comprehensive or quite as well organized as Awodey's book.
20:57:27 <ddarius> They are also freely available online.
20:57:36 <ddarius> (As is TTT, albeit that is not easy reading.)
20:58:39 * nand` won't be one to report Cale for sharing information. Information should be free
20:58:48 <nand`> perhaps s/information/knowledge/
20:59:02 <ddarius> s/information/data/
20:59:30 <nand`> the most obvious contradiction to this philosophy I see is that by the same logic, every single private thought I've ever had should be broadcast to the general public
20:59:32 <nand`> and possibly misused
20:59:48 <nand`> I could try limiting it to “academic knowledge” but that's bound to be hard to define
21:00:04 <ddarius> And is probably too limiting anyway.
21:00:24 <nand`> yeah, assuming ‘academic’ is defined to be limited enough to cover my private thoughts
21:00:38 <Cale> nand`: Maybe it would be okay if everyone else's thoughts were necessarily the same way
21:01:00 <lewis1711> almost makes me want to do postgrad computer science
21:01:03 <ddarius> Yes, there'd be so much noise, no one would either a) be able to understand anything, or b) care about the vast majority of it.
21:01:17 <ddarius> lewis1711: Don't waste your money, unless you want to be a professor.
21:01:34 <nand`> free doesn't necessarily mean forced on you; it might as well just be as the current universe is but with the ability to gain arbitrary knowledge at will
21:01:42 * ddarius recommends Isaac Asimov's short story "The Dead Past" to the mob.
21:02:02 <ddarius> nand`: That would lead to the b) scenario.
21:02:37 <nand`> ddarius: yeah fair enough; I'd probably have more interesting things to think about with such resources
21:02:43 <lewis1711> ddarius: seems better than doing business and enterprise development in godawful languages in a suit for the next few years. are you american? I think the situation with academia is a bit worse overthere
21:02:47 <ddarius> That story would play this crowd perfectly.
21:03:01 <nand`> studying is free here
21:03:45 <hayashi> mmm, business and enterprise development, just the two things my university CS department expects all its graduates to go into =/
21:03:50 <hayashi> do not want
21:03:57 <nand`> ah yeah
21:04:00 <nand`> Java classes
21:04:22 <ddarius> You do have some control over the job you get, and you are quite capable of learning on your own.  In fact, colleges tend to get in the way of learning.
21:04:45 <nand`> @ask edwardk Does Java (as in Java, not Scala) lend itself to the same form of hacking-in-monads as C#? Like, is its type system capable of everything C#'s is?
21:04:45 <lambdabot> Consider it noted.
21:05:06 <lewis1711> hayashi: in the same boat, I am graduating soon
21:05:08 <ddarius> Java's type system is slightly more powerful, if wartier, than C#'s.
21:05:49 <ddarius> Of course, the CLR'- type system is more powerful than the JVM's.
21:06:00 <nand`> https://en.wikipedia.org/wiki/Comparison_of_Java_and_C_Sharp#Type_system heh
21:06:06 <lewis1711> ddarius: sure, that's why I am here on a saturday afternoon. still, I can't see myself getting an interesting job with an undergrad degree from a "vocational java" type university
21:06:59 <hayashi> we have a programming languages research group here that are mainly into Haskell, but I fear researching functional programming is too awesome and over-my-head to be a viable way of escaping career programming =P
21:07:00 <ddarius> lewis1711: You can't if you market yourself that way and if you don't do anything on your own.  You can quite definitely get a nice paying and/or interesting job if you start doing/joining projects that interest you.
21:07:02 <nand`> part of the reason I want to go to university is so I can get a feel for what university jobs are like. I'm interested by the idea of becoming a professor
21:07:30 <lewis1711> ddarius: I hope so, since that's the plan :)
21:08:10 <lewis1711> hayashi: our compsci department is like....8 professors, many of whom are more software engineers, and half our courses cater to the engineering department. it's a bit dire
21:08:25 <hayashi> lewis1711: ugh, java vocational university, that sounds so much like my situation, they changed the course the year I joined from starting with introductional programming in Scheme to Java
21:08:40 <hayashi> and then the second year software project, for whomever chooses it... also Java
21:08:45 <lewis1711> mines moved onto python now. which I can only commend (even though I do not like java)
21:09:10 <lewis1711> I get to choose whatever language I want for a few projects now though, which is nice.
21:09:12 <hayashi> they DO do the good thing of teaching half a compilers course in Haskell in the second year, that's how I got into Haskell =P
21:09:18 <nand`> apparently it's not half bad at my uni, eg. you're not forced to use any language in particular - the classes just use Java
21:09:30 <lewis1711> nice. I learned it as part of second year "declarative programming"
21:09:32 <nand`> and after the first few semesters you get to the point where the language is irrelevant
21:09:40 <lewis1711> well, barely learned it
21:09:41 <hayashi> wow, why can't other universities be like nand`'s
21:09:53 <hayashi> here in the first year, not only did you have to use Java in the first year
21:09:53 <nand`> apparently masters students are free to go into fun things like compiler design, functional programming and language theory
21:10:03 <hayashi> you also had to use the BlueJ environment (ick) in the programming exams
21:10:19 <hayashi> no eclipse/netbeans/emacs/vim/whatever allowed~
21:10:20 <nand`> hayashi: unfortunately, some classes still expect you to know UML
21:10:24 * hayashi vomits
21:10:32 <lewis1711> my algorithm and data structures course involved.... unit testing and parsming xml in java. Not that they aren't useful,but they have no place there IMO
21:10:35 <hayashi> I had to go through UML in the second year (the one I've just finished)
21:10:45 <hayashi> I had to do the UML for my team in the team software project...
21:10:48 <hayashi> Never again...
21:10:52 <nand`> heh
21:10:59 <lewis1711> I actually quite liked software architecture
21:11:13 <nand`> I had to go through UML last year, also project management
21:11:44 <lewis1711> I thought UML was fine. very applied of course, but seems more useful
21:11:49 <JoeyA> Is there a monad transformer for generating list items?  Perhaps a convenience wrapper around WriterT (DList a).
21:11:53 <hayashi> I DID manage to have a bit of fun with UML, wasting most of the time unnecessarily re-inventing the wheel by creating a Haskell program to convert a somewhat-easy-to-write DSL into graphviz that looked like UML =P
21:12:13 <nand`> :(
21:12:15 <nand`> i had to do it on paper
21:12:20 <hayashi> oh lord
21:12:22 <hayashi> that sounds painful
21:12:34 <nand`> yeah; 12th grade
21:12:43 <hayashi> we had to do ours electronically, which meant (initially) ArgoUML
21:12:53 <hayashi> and its horrifically bad user interface and lack of undo functionality
21:12:59 <nand`> no computers involved in exams. (okay, most exams. The C# practicals were still done in front of a compiler. Half of them.)
21:13:00 <lewis1711> don't say those words! I am having flashbacks now
21:13:41 <lewis1711> right, I'm off to get get therapy for PASD - post argouml stress disorder. bye everyone.
21:13:59 <hayashi> oh wow, I should set up an argouml support group
21:14:15 * nand` looks up ArgoUML
21:15:26 <Okasu> http://vpaste.net/FuZ7F how does it work? I don't understand where goes this [9,0] arg
21:15:54 <Okasu> it seems like it implicitly gouse into pop and push
21:15:57 <hayashi> I'm worried because this CS department binned its functional programming module due to lack of lecturer unavailability a while ago, the only thing similar in the third year is programming by graph transformation (which sounds fun)
21:16:33 <nand`> hayashi: reminds me of how my teacher required us to submit a gantt chart. Of course, every software to create gantt charts is either some horribly broken Java thing that doesn't run properly on my system or the abysmal windows-only Microsoft Project. Fortunately, we did get free keys for Microsoft Project 2003
21:17:45 <nand`> Okasu: [9,0] is the initial state that gets fed into the first chain of state-modifying functions
21:18:10 <nand`> in this case; pop: as you see by the definition of pop it's basically \(x:xs) -> (x,xs) so that returns (9,[0])
21:18:12 <nand`> etc.
21:18:36 <Okasu> nand`: thanks
21:19:14 <hayashi> nand`: our lecturers pretty much said "all gantt chart creating software sucks", so our team just did ours by abusing a Google spreadsheet I think
21:19:41 <hayashi> I can't remember, memories of that whole project are being redirected to /dev/null now
21:20:10 <nand`> hayashi: I'll do the same
21:36:45 <NemesisD> i'm looking for an idiomatic, concise way to take an action IO a and IO b and return IO (a,b). i could do: do a <- act1; b <- act2; return (a,b) but thats kinda nasty
21:37:06 <shachaf> liftA2 (,)
21:37:21 <shachaf> ezyang would call it "*"
21:37:51 <NemesisD> why would he call it that?
21:38:34 <nand`> mm_freak would call it ***
21:38:37 <nand`> sorry, &&&
21:41:27 <n00b6502> main :: IO ()  ... is that signature an input or an output
21:41:29 <ezyang> It's a star in the original paper, but * is already taken by Num
21:41:42 <ezyang> and *** is taken by Control.Arrow.
21:42:05 <shachaf> Unicode has *no shortage* of stars to use here.
21:42:19 <shachaf> ★
21:42:21 <n00b6502> what does the signature of main actally mean
21:42:30 <nand`> n00b6502: it's an IO action with no result
21:42:37 <XexonixXexillion> ☆
21:42:54 <shachaf> × ✖ are available too.
21:43:08 <shachaf> As well as dozens of stars and asterisks at U+27xx
21:43:29 <shachaf> ✯ ✭ ✪ ✳ etc.
21:43:36 <nand`> ✡
21:43:44 <XexonixXexillion> ☘ can be used if you're feeling lucky
21:43:56 <shachaf> The road to Agda is paved with good intentions.
21:47:15 <XexonixXexillion> What's the requirement for a constructor in Haskell? Could I write something like "data ChessPiece = ♚ | ♛ | ♜ |♝ | ♞ | ♟" ?
21:47:33 <shachaf> Has to start with an uppercase letter.
21:47:57 <shachaf> In the next version of GHC the requirements for infix constructors might be loosened a bit.
21:49:24 <nand`> or :
21:49:31 <Veinor> let x ♚ y = 8 in 2 ♚ 3
21:49:36 <Veinor> > let x ♚ y = 8 in 2 ♚ 3
21:49:37 <lambdabot>   8
21:49:41 <nand`> > generalCategory '♚'
21:49:43 <lambdabot>   OtherSymbol
21:59:47 <noob> [42,13,22]
22:00:15 <lambdabot> [42,13,22]
22:02:43 <ddarius> Dammit.
22:02:50 * ddarius may need to get a computer with gigabit ethernet.
22:02:56 <shachaf> Why?
22:03:05 <nand`> ... or just a network card?
22:03:06 <vncsnvs> yeah
22:03:06 <vncsnvs> why
22:03:07 <vncsnvs> ?
22:03:12 <shachaf> (Can you even get a computer with 100Mb ethernet these days?)
22:03:17 <ddarius> nand`: I have a cheap laptop.
22:03:17 <nand`> shachaf: doubt it
22:03:22 <nand`> ddarius: oh
22:03:31 <vncsnvs> ddarius, nice
22:03:32 <vncsnvs> !
22:03:41 <nand`> shachaf: well, not new mainboards at any rate (current generation, previous too)
22:03:49 <vncsnvs> cheap stuff makes miracles
22:03:52 <nand`> of course you can still ‘get’ old things
22:05:11 <ddarius> I was sort of surprised how common 100Mb ethernet is for cheap laptops, but I didn't really care when I got my laptop since I practically never use my ethernet connection and even if I did 100Mb would be enough... except for doing heavy data processing of 50MHz analog signals.
22:05:56 <ddarius> But I guess all this really means is I can get some cheap desktop or a slightly less cheap laptop, or I can learn how to program an FPGA.
22:06:37 <mast`> Quick question (found in the "99 haskell problems' solutions): What exactly does \x -> does when passed as a parameter to map()? I'm assuming it replaces, but is there a reference to this somewhere?
22:06:56 <shachaf> mast`: \ is lambda.
22:07:07 <ddarius> I can probably pull off the 4.092MHz data bandwidth I need without going to the FPGA though.
22:07:14 <shachaf> mast`: You'll find an explanation pretty early on in most introductions to Haskell.
22:07:28 <shachaf> mast`: (Also, there's no such thing as map(). That's a type error. :-) )
22:07:52 <mast`> shachaf, I'll go back to "Learn you a haskell" and check!
22:08:15 <mast`> shachaf, map (\x -> (length x, head x)) (group xs) was the actual line
22:08:40 <ddarius> :t map ()
22:08:42 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `()'
22:08:42 <lambdabot>     In the first argument of `map', namely `()'
22:08:42 <lambdabot>     In the expression: map ()
22:08:54 <mast`> I'm assuming it replaces the content of xs by the tuple (length x, head x)
22:09:02 <shachaf> mast`: Reading solutions to exercises is probably not a good way to learn Haskell.
22:09:03 <mast`> :t map
22:09:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:09:46 <ddarius> :t ()
22:09:47 <lambdabot> ()
22:10:33 * ddarius wonders about good implementations of the FFT in FPGA/DSP hardware.
22:10:46 <mast`> shachaf, true. I had succeeded the problem with takeWhile/dropWhile but I was curious about map (I had only seen it used to modify the values of a list)
22:11:07 <shachaf> mast`: You can't modify things in Haskell. :-)
22:11:18 <shachaf> > map (\x -> x + 1) [1,2,3,4,5]
22:11:20 <lambdabot>   [2,3,4,5,6]
22:11:42 <mast`> > map (+1) [1,2,3,4,5]
22:11:43 <lambdabot>   [2,3,4,5,6]
22:12:05 <shachaf> (+1) means (\x -> x + 1)
22:12:40 <mast`> shachaf, Any reason why someone would prefer one over the other?
22:13:03 <shachaf> One is shorter.
22:13:22 <shachaf> And you don't need to strain your memory by remembering one more name.
22:14:07 <mast`> shachaf, got it, thanks!
22:18:20 <thetallguy> is it possible to import a module and hide an instance?
22:20:08 <shachaf> thetallguy: No.
22:20:47 <thetallguy> shachaf: thanks.  I didn't think I'd ever seen that.
22:21:23 <shachaf> thetallguy: Instances are completely global.
22:21:29 <shachaf> (Otherwise there could be Trouble.)
22:21:49 <thetallguy> seems there's trouble anyway
22:22:33 <Veinor> yeah. module Foo defines an Ord instance on Complex one way, module Bar defines it another way. now what happens if I do Foo.z `compare` Bar.w
22:24:39 <ddarius> Veinor: Clearly we should take z's instance of compare.
22:25:22 <Veinor> haha
22:25:58 <shachaf> What we need is an Ord instance for Ord instances.
22:26:03 <shachaf> So we can decide which one is the best.
22:26:24 <ddarius> That implies there is a total order on Ord instances.
22:26:46 <auda> Why doesn't this work: 10 / (factorial 4)
22:27:11 <auda> <interactive>:10:4:     Ambiguous type variable `a0' in the constraints:       (Fractional a0) arising from a use of `/' at <interactive>:10:4       (Integral a0)         arising from a use of `factorial' at <interactive>:10:7-15       (Num a0) arising from the literal `10' at <interactive>:10:1-2     Probable fix: add a type signature that fixes these type variable(s)     In the expression: 10 / (factorial 4)     In an equation for `it':
22:28:33 <shachaf> > 10 / factorial 4
22:28:35 <lambdabot>   0.4166666666666667
22:29:09 <shachaf> (What I'm subtly hinting at is that you didn't say what "factorial"'s definition is. And type, more importantly.)
22:29:16 <Veinor> @type 10 / (factorial 4)
22:29:18 <lambdabot> forall t. (Fractional t) => t
22:29:55 <Veinor> auda: basically, it can't decide whether you want to divide them as doubles, floats, or something else
22:30:19 <auda> factorial :: (Integral a) => a -> a
22:30:19 <auda> factorial a = product [1..a]
22:30:34 <shachaf> auda: OK. Now look at the type for (/)
22:30:50 <auda> :t / doesn't work
22:30:51 <lambdabot> parse error on input `/'
22:31:03 <ddarius> Maybe I'll start with GLONASS rather than GPS.
22:31:06 <auda> ok,let's say I want to divide as doubles
22:31:09 <Veinor> :t (/)
22:31:10 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:31:33 <shachaf> @ty fromIntegral
22:31:35 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:31:40 <charliesome> what's my best option for doing gui stuff with haskell on mac os x?
22:37:32 <auda> ok, this works: 10 / (fromIntegral (factorial 4))
22:37:40 <auda> how about this function:
22:37:45 <auda> an :: (Integral n, Num b) => n -> b
22:37:47 <auda> an n = fromIntegral (10^n) / (fromIntegral (factorial n))
22:38:05 <shachaf> How 'bout it?
22:38:07 <auda>     Could not deduce (Fractional b) arising from a use of `/'     from the context (Integral n, Num b)       bound by the type signature for an :: (Integral n, Num b) => n -> b       at hello.hs:18:1-57     Possible fix:       add (Fractional b) to the context of         the type signature for an :: (Integral n, Num b) => n -> b     In the expression:       fromIntegral (10 ^ n) / (fromIntegral (factorial n))     In an equation for `an': 
22:38:50 <shachaf> > let an n = fromIntegral (10^n) / (fromIntegral (factorial n)) in an 5
22:38:52 <lambdabot>   833.3333333333334
22:38:53 <shachaf> Works for me.
23:11:07 <savask> Hello. In order to port GHC to a new OS I should use .hc files. But to generate them, I should compile GHC with -fvia-C which isn't supported now, as I guess. What can I do then? How to compile GHC on an OS with no GHC at all?
23:15:44 <Cale> http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
23:16:11 <savask> Cale: I read that. Take a look at line: "GhcLibHcOpts = -O -fvia-C -keep-hc-files"
23:16:47 <savask> I have GHC version 7.4.2, and when I use fvia-C there it says "Warning: The -fvia-C flag does nothing; it will be removed in a future GHC release"
23:17:01 <Cale> hmm
23:17:32 <savask> The only way I see now is to get the oldest GHC version possible and start compiling newer versions one by one XD
23:17:50 <savask> But that's going to be too long, I think.
23:21:47 <Cale> What platform btw?
23:21:57 <savask> GNU/Hurd
23:22:49 <Cale> Interesting, I haven't hurd much about it in years.
23:23:05 <MostAwesomeDude> Nifty.
23:23:14 <savask> Yeah
23:23:29 <savask> Cale: It's semi-frozen, I think.
23:23:53 <savask> Though if I will be able to get GHC to it, it will become a little bit more awesome.
23:25:07 <pharaun> I can implement a concept of ducktyping "sortof" via class types correct? in which i define a class type
23:25:30 <pharaun> then i can provide an impl for one way then another impl? or am i barking up the wrong tree here
23:26:23 <pharaun> hmm actually i can probably just do that via modules
23:26:39 <pharaun> and exporting the same functions with same type interface
23:27:33 <Cale> pharaun: Or just make records of functions.
23:27:52 <Mortchek> pharaun, typeclasses are stronger than ducktyping because they have to explicitly be supported by the type you're using.
23:28:31 <pharaun> Mortchek: ahh i see so i was on roughly the right track with thinking about typeclasses
23:28:48 <pharaun> Cale: records?
23:29:09 <pharaun> as in i have a records data type and i store the function in the records itself
23:29:13 <pharaun> and refer/execute via that?
23:29:24 <Mortchek> pharaun, duck typing is characterised by not explicitly caring about the type. With typeclasses, you do have to care. So it's not really duck typing at all.
23:29:34 <Cale> pharaun: As in you just store a bunch of functions together characterising the interface that you wanted.
23:29:44 <pharaun> Mortchek: i just wasn't for sure of what the rough "equivalent" was in haskell
23:29:52 <pharaun> Cale: ah i see
23:30:07 <pharaun> Cale: that could work but it seems a bit weak from a type point of view?
23:30:18 <Cale> weak?
23:30:35 <Mortchek> pharaun, I think you were on the right track in that case.
23:30:46 <Cale> In what way?
23:31:08 <pharaun> Cale: for ex say i have an interface for network, then an interface for pipe/file or what you have not
23:31:34 <pharaun> i could take a function from the network and a function from the pipe and put it into the record, and since both would have the same type/function def it would work but the program itself would fail
23:32:00 <Cale> How is that not a problem shared by every other mechanism here?
23:32:19 <pharaun> i was under the impression that type classes would be a bit stronger in that case ?
23:32:32 <Cale> Do you know what typeclasses are?
23:32:52 <pharaun> its from memory, so i'm going back and double checking
23:32:58 <Cale> If the types of your methods are permissive enough to allow behaviour that you don't want, then someone could always come along and write an instance which does something you don't want.
23:33:50 <pharaun> yeah i can see that
23:33:51 <Cale> Typeclasses are implemented in GHC by passing around records filled with the implementations for the methods of the typeclass (as provided/produced as a function of the instances)
23:33:58 <Mortchek> Cale, in what sort of case would that be problematic? I was under the impression that creative uses of types are encouraged.
23:34:06 <Mortchek> i.e., doing things the author doesn't expect
23:34:08 <Cale> and the translation which does that is type-safe
23:34:30 <Cale> (well, there are some things which require somewhat fancy types, but it's typesafe nonetheless)
23:35:10 <Cale> Mortchek: well, you might have laws for your methods that other library authors need to rely on for their algorithms to work
23:35:15 <pharaun> for context, i am writing a network api wrapper and i wanted to be able to slot in a pipe/file for local testing
23:35:35 <Cale> Mortchek: for example, most libraries assume that Ord instances provide a total ordering on the type in question
23:35:36 <Mortchek> Ah, such as the monad or functor laws.
23:35:44 <Cale> and fail miserably in various ways if not
23:35:55 <Cale> and yeah, the monad and functor laws
23:37:10 <Cale> pharaun: I see no immediate reason why you couldn't use any of these solutions.
23:38:51 <Cale> pharaun: But I think probably the nicest thing in that case is to parametrise things on a record of primitive I/O operations. You're unlikely to have a type parameter which you can base a typeclass off of, which would mean introducing an artificial parameter anyway
23:39:23 <Cale> and the main advantage that typeclasses have over passing clumps of functions/values around is the fact that you don't have to do that passing around by hand.
23:40:39 <pharaun> yeah i think i'm leaning that way
23:41:10 <pharaun> i just refreshed my memory a bit on type classes and was like eh
23:41:41 <pharaun> Cale: Mortchek alright thanks you two :)
23:42:28 <Cale> Of course, it also sounds a bit like the sort of thing which MonadPrompt would be good for
23:43:19 <Cale> but that's a fancy solution to a problem which might just be better solved here by good-ol-fashioned-functional-programming
23:44:02 <pharaun> hehe i mainly just need it for testing
23:44:24 <pharaun> so i can replace the lower level network stuff with something else that is a tad faster/for testing
23:56:12 <louix> [42,13,22]
