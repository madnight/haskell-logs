00:00:10 <copumpkin> heh
00:00:13 <latro`a> just like how stuff would be in the way if you don't have return
00:00:23 <latro`a> *didn't
00:00:23 <copumpkin> no, because arrows are a much more ad-hoc construction
00:00:36 <copumpkin> what gets in the way is that you can't do what the designers of arrows wanted to do with them
00:00:42 <copumpkin> which is arrow notation
00:00:54 <copumpkin> which nobody uses anyway
00:10:04 <master5o1> WHERE IS ASH?
00:11:19 <copumpkin> not in here
00:12:17 <startling> mt. silver
00:34:06 <edwardk> @tell peaker (%~) = adjust
00:34:07 <lambdabot> Consider it noted.
00:50:47 * hackagebot monadloc 0.7 - A class for monads which can keep a monadic call trace (PepeIborra)
00:50:49 * hackagebot control-monad-exception 0.10.3.1 - Explicitly typed, checked exceptions with stack traces (PepeIborra)
01:06:02 <sleepyMonad> @list
01:06:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
01:26:38 <PaulVisschers> which package should I use for setting up a client-server for a video game?
01:30:02 <Athas> PaulVisschers: that's a very open question.
01:30:29 <shachaf> edwardk's "arcade" thing, obviously. :-)
01:30:35 --- mode: ChanServ set +o mauke
01:30:35 --- mode: mauke set +b $a:chaotic_good
01:30:39 <Athas> PaulVisschers: use the network package for a normal socket-like interface.
01:31:01 <PaulVisschers> Athas: yeah I think I will use that one
01:32:35 --- mode: mauke set -o mauke
01:45:34 <Taneb> Is Pair (data Pair a = Pair a a) a Monad?
01:45:39 <Taneb> I don't think it is
01:48:02 <Athas> Taneb: it could be an identity monad.
01:48:14 <Taneb> What would join be?
01:49:12 <Taneb> (it's definitely an applicative)
01:53:59 <XexonixXexillion> Taneb: Join could simply return the first in the pair
01:54:20 <PaulVisschers> is there a standard package to use IO Handle-based channels?
01:56:21 <Taneb> XexonixXexillion, that, as x >>= f = join (fmap f x), means that Pair 1 2 >>= return = join (fmap return (Pair 1 2)) = join (Pair (Pair 1 1) (Pair 2 2)) = Pair 1 1
01:56:30 <Taneb> Which breaks x >>= return = x
01:57:31 <XexonixXexillion> why (Pair (Pair 1 1) (Pair 2 2))?, shouldn't it be (Pair (Pair 1 2) (Pair 1 2))?
01:57:46 <XexonixXexillion> actually wait...
01:58:21 <XexonixXexillion> so we return the first of the first, and the second of the second, and now we meet the laws :p
02:00:17 <Taneb> return 3 >>= \x -> Pair (x * 3) (x + 1) => Pair 3 3 >>= \x -> Pair (x * 3) (x + 1) >>= join (fmap (\x -> Pair (x * 3) (x + 1)) (Pair 3 3)) => join (Pair (Pair 9 4) (Pair 9 4)) => Pair 9 4...
02:00:23 <Taneb> Okay, that one works
02:00:30 <XexonixXexillion> so return x = Pair x x, fmap f (Pair x y) = (Pair (f x) (f y)) and join (Pair (Pair x _) (Pair _ y)) = Pair x y
02:00:35 <Taneb> Bah, I beleive you
02:01:11 <Taneb> I just don't like the idea of destructive joins
02:01:33 <shachaf> join is usually "destructive" in some way.
02:01:47 <Taneb> Yeah, this is only a problem on the inside of my mind
02:02:04 <XexonixXexillion> Taneb: if I concat a list, I can't know what it was before, this isn't much different
02:02:18 <Taneb> Yeah, you're right
02:05:49 * hackagebot doctest 0.8.0 - Test interactive Haskell examples (SimonHengel)
02:09:31 <shachaf> So Pair is a monad.
02:09:39 <shachaf> Is it an interesting one?
02:09:44 <Taneb> I dunno
02:10:10 <Taneb> I don't think so
02:12:38 <XexonixXexillion> There are no uninteresting monads; just uninterested people :p
02:14:39 <shachaf> http://hackage.haskell.org/packages/archive/functor-combo/latest/doc/html/src/FunctorCombo-Functor.html
02:15:15 <shachaf> http://hackage.haskell.org/packages/archive/lens/latest/doc/html/src/Control-Lens-Representable.html
02:16:13 <shachaf> https://gist.github.com/3190574
02:21:06 <XexonixXexillion> also Pair is a comonad with cojoin (Pair x y) = Pair (Pair x x) (Pair y y) and coreturn (Pair x _) = x
02:21:54 <XexonixXexillion> So I think it's interesting; it's one of the simplest things that is both and monad and a comonad that isn't the identity monad
02:25:27 <Taneb> There are two possible copures (also two possible joins)
02:25:31 <Taneb> Hmm
02:25:39 <autodidakto> I'm trying to compile (cabal install) a simple, but apparently old program, and it says "Rolving dependencies" and warns, as far as I can tell, that older versions would overwrite some current versions, breaking other things... I'm not too familiar with cabal (just ruby/gem). Is cabal not able to have multiple versions of a package? Or am I missing something?
02:25:42 <Taneb> It's also one of the simplest things with multiple possible monad instanes
02:26:07 <Taneb> autodidakto, cabal is not able to have multiple versions of a package, no.
02:26:13 <shachaf> Taneb: Sure it is.
02:26:16 <Taneb> It is?
02:26:22 <shachaf> Installed? Sure.
02:26:36 <Taneb> autodidakto, I'm wrong. Ask shachaf.
02:26:42 <autodidakto> lol alright
02:26:42 <alpounet> it can't use several versions for the same project though
02:27:08 <alpounet> (one version for dependency X, another for dependency Y, for example)
02:27:11 <shachaf> autodidakto: Don't ask me! Ask the channel. But while you're asking the channel, you should provide a lot more information, like the output of everything that's going wrong.
02:27:28 <autodidakto> I'm, generally, trying to figure out cabal. The haskell tutorials/books/things Ive been going through haven't touched much with the nitty-gritty details of tooling. I'm not really sure what cabal-dev is, etc
02:27:35 <shachaf> It's probably what alpounet said, maybe, but there's no way of knowing given what you've said.
02:30:52 <XexonixXexillion> I just realised that I can trivially implement Q learning as an arrow /mind blown
02:31:05 <Taneb> Would it be evil to use fmap undefined as a sort of transConst?
02:31:07 <autodidakto> with a cabal install, it says "Resolving dependencies"... then "In order, the following would be installed:" and includes a line like "deepseq-1.3.0.0 (reinstall) changes: array-0.4.0.0 -> 0.3.0.3" then "The following packages are likely to be broken by the reinstalls:"
02:32:52 <autodidakto> It seems like cabal should just install the older versions of packages as necessary instead of needing to --force, breaking other packages
02:41:53 <Athas> What's the easiest way to convert a Double to a String representation using only decimals, not scientific notation?
03:09:36 <zhulikas> Athas, show? :D
03:09:50 <nobdraisentone> I have x ∷ IO (Maybe A) and f ∷ A → IO (). How can I apply x to f only if x inside IO monad is Just?
03:10:21 <shachaf> zhulikas: No.
03:11:03 <dixie> anybody is running latest haskell platform / ghc on solaris x86 ?
03:12:17 <shachaf> @ty \f x -> do { y <- x; maybe (return ()) f y }
03:12:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> m (Maybe a) -> m ()
03:14:12 <answer_42> Is there a (good) maildir library?
03:18:27 <nobdraisentone> shachaf: thanks for `maybe'
03:44:32 <zhulikas> @src maybe
03:44:32 <lambdabot> maybe n _ Nothing  = n
03:44:33 <lambdabot> maybe _ f (Just x) = f x
04:04:40 <[mth]_> Does anyone know if string gaps should work with OverloadedStrings?
04:05:53 <[mth]_> Goal is to format sql for use with Database.PostgreSQL.Simple, so switching to concatenation is not really a good option.
04:19:54 <iamtakingiteasy> hi, for some reason one of my complex data types which can act as (Num a) makes my program hang up untill interruption when i am trying to show a negative number represented by this type while positve numbers and zero are showing just fine. what could be the possible reason?
04:21:23 <danil> your fromInteger or show implementation probably loops
04:21:26 <Cale> iamtakingiteasy: hpaste.org
04:21:59 <iamtakingiteasy> danil: thanks, this is already narrowing problem down
04:22:29 <Cale> (paste the code, and we can probably tell you)
04:23:13 <iamtakingiteasy> there is a lot of "real" code, so i need to know which parts are responsible for this so i can make a test case
04:24:19 <Cale> Well, in that case, just paste the data declaration and the Num instance to start with
04:24:29 <Cale> (and if there is a Show instance, that as well)
04:24:38 <iamtakingiteasy> okay
04:26:12 <Wibowit> does anyone know of an intuitive introduction to call-with-current-continuation?
04:26:30 <Wibowit> i've spent few days on it and still no progress
04:26:52 <hpaste> iamtakingiteasy pasted “Type declarations” at http://hpaste.org/72638
04:27:40 <iamtakingiteasy> errm
04:27:42 <iamtakingiteasy> this is working fine
04:27:48 <Cale> iamtakingiteasy: indeed, it should
04:28:12 <iamtakingiteasy> must be one other type that uses NumStack internally
04:29:40 <Cale> Wibowit: v <- callCC (\ret -> do ...)  will provide the code in ... a second way to end by calling ret with a value. v will then be bound to that value.
04:30:12 <Cale> Wibowit: the interesting bit is that ret is a first class function, representing the rest of the computation as a function of v
04:31:28 <danil> Cale: the Cont monad isn't really call-with-current-continuation -- the continuations you get are delimited (by runCont)
04:31:31 <yitz> [mth]_: OverloadedStrings doesn't add anything if you're only working with String. it works as well for String as for anything else; but not as well as String works on its own, *without* OverloadedStrings.
04:31:52 <Cale> danil: Sure, but you can just as well imagine the running Cont computation as the entire program.
04:32:26 <Wibowit> I'm trying to understand the ordinary callCC
04:32:38 <Wibowit> as of now it seems to me as infinite recursion
04:32:53 <VitamnP> I'm making Conway's game of life, and I have a list of ((Int, Int), Bool) tuples that I want to step through, filtering neighbours out of the list for each. Is there any way of storing a reference to the whole list in each cell? Or is this the wrong approach in haskell? I would like to avoid passing the list itself as an argument so I can use map and filter etc on the listy
04:33:00 <Cale> Wibowit: do you understand how return works in most imperative languages?
04:33:07 <Wibowit> yes
04:33:17 <Wibowit> i'm coming from imperative languages
04:33:20 <Cale> Wibowit: procedures in imperative languages act as if they are all wrapped in callCC
04:33:34 <Cale> Wibowit: and return calls the current continuation that callCC gave
04:33:52 <[mth]_> yitz: In thase case I am using OverloadedStrings to create a Query data type, in this library it is encouraged as the query is a simplified Data.Text that doesn't expose monoid/concat operations, to reduce risk of sql-injections
04:34:29 <Wibowit> not really; return returns to function one level up, whereas with callCC we can skip several levels IIRC
04:34:38 <Cale> e.g.  procedure foo { ... return bar ... } is really like   foo = callCC (\ret -> ... ret bar ... )
04:35:16 <Cale> Wibowit: return just calls that *one* continuation, and since the continuations aren't named, you can't choose to call another one
04:36:32 <Cale> But yes, you're right, the fact that callCC names the continuations gives us extra power
04:36:53 <Wibowit> and extra confusion
04:36:55 <Cale> Actually, imperative languages add extra language features, like break for breaking out of loops early
04:37:20 <Cale> and that's like a second callCC, since we could choose to return or break
04:37:48 <Cale> (though that's slightly trivial, since loops usually don't produce a value)
04:38:04 <yitz> [mth]_: you can certainly use String instead of Text as the data type inside Query. it should work just the same way with OverloadedStrings.
04:39:14 <yitz> [mth]_: type inference will ensure that the string syntax is interpreted as a Query, not as a String, when that is the context. if the context is ambiguous, the program will be rejected.
04:40:41 <Wibowit> Cale: the main problem I have is to understand why calling the named continuations causes to skip the following steps in do block
04:41:15 <[mth]_> yitz: ok thanks, I will have a bit more of a play around to see if I can get the gaps working, likely user error.
04:41:23 <Cale> Wibowit: Because that name refers to the rest of the computation after the callCC, as a function of its result
04:41:25 <Wibowit> Cale: if i do continuation like: do return 5 return 25, then it acts like do return 25, so the continuation behaviour is surprising
04:41:50 <Cale> Haskell's  return  doesn't call any continuations
04:42:18 <Wibowit> yes i know
04:42:28 <Cale> In Haskell, return v is a computation which does nothing except to, well, return v as its result :)
04:42:30 <Wibowit> it returns a continuation
04:43:15 <Cale> > runCont (callCC (\ret -> do ret 5; ret 25)) id
04:43:17 <lambdabot>   5
04:43:37 <danil> Wibowit: a value of type `Cont r a` is not a continuation, it's a computation that might use continuation effects
04:43:55 <Cale> right
04:44:02 <Cale> ^^ that is important
04:44:40 <iamtakingiteasy> i was doubely wrong. this is not fine. here: http://hpaste.org/72639
04:44:42 <Cale> The continuations themselves will have type a -> Cont r b for some a and b
04:45:04 <Cale> iamtakingiteasy: You left negate out of your Num instance
04:46:15 <iamtakingiteasy> oh
04:46:18 <iamtakingiteasy> Cale: thank you!
04:46:20 <Cale> iamtakingiteasy: *and* you didn't define -
04:46:37 <Cale> The default negate is  negate x = 0 - x
04:46:50 <Cale> and the default (-) is x - y = x + negate y
04:47:05 <Cale> and so if you define neither, it loops
04:47:15 <Cale> but if you define either one, both will work
04:47:22 <iamtakingiteasy> yeah
04:47:57 <timthelion> > let foo :: a -> b ; foo a = error "bar" in foo "Cat" -- Take that free theorem for foo!
04:47:59 <lambdabot>   *Exception: bar
04:48:54 <Wibowit> Cale: when i put named continuation in do block, how does haskell know that it should not execute next steps in that do block?
04:49:54 <Cale> Wibowit: okay, to see that, we need to look at how >>= for Cont is implemented
04:50:58 <Wibowit> i have a code like that:
04:51:01 <Wibowit> instance Monad (Cont r) where
04:51:03 <Wibowit>   return n = Cont (\k -> k n)
04:51:05 <Wibowit>   m >>= f  = Cont (\k -> runCont m (\a -> runCont (f a) k))
04:52:45 <Cale> right
04:53:28 <Wibowit> the resulting continuation firstly runs cont m, with a continuation that takes its result and applies that result to f
04:53:31 <Cale> and so when we're inside the callCC and we have   ret 5 >>= (\v -> ret 25)
04:54:11 <Wibowit> and runs then result of f with the new continuation as a parameter
04:54:27 <Wibowit> i think i understand how >>= works for Cont
04:57:06 <Cale> so we have:  callCC $ \ret -> Cont (\k -> runCont (ret 5) (\a -> runCont (ret 25) k))
04:57:44 <Cale> and the implementation of callCC is:
04:57:57 <Cale> callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k
04:58:40 <Cale> We could just plug things in, but perhaps it's better just to think about what's going to happen before that
04:58:53 <Wibowit> yes
04:59:44 <Cale> The f in the definition of callCC is going to be bound to our function \ret -> Cont (\k -> runCont (ret 5) (...))
05:02:51 <Cale> Now what does k represent in the definition of the callCC? It's more or less the rest of the computation after the callCC -- (>>=) is going to plug in the rest of the computation there, or runCont will supply something there directly (in my example, I just used id, because I just wanted the result immediately)
05:03:52 <Cale> and we're going to be passing to f this ret which is  (\a -> Cont $ \_ -> k a) -- where this k is the function representing the computation after the callCC
05:05:31 <Cale> and we're going to call *this* with 5
05:05:46 <Cale> which will produce  Cont $ \_ -> k 5
05:06:53 <Cale> the fact that this lambda uses _ to match is essentially what's throwing away the (\a -> runCont (ret 25) k) here
05:07:18 <Cale> Instead, this k is the outer k, representing the computation after the callCC
05:07:34 <Cale> So we'll be calling the code after the callCC with 5
05:09:36 <Cale> Let's watch it happen
05:10:03 <Cale> runCont (callCC $ \ret -> Cont (\k -> runCont (ret 5) (\a -> runCont (ret 25) k))) id
05:12:16 <Cale> -> runCont (Cont $ \k -> runCont ( (\ret -> Cont (\k -> runCont (ret 5) (\a -> runCont (ret 25) k))) (\a -> Cont $ \_ k a)) k) id -- this is confusing, but we're going to plug in ret now
05:12:57 <Cale> but before we do, let's rename one of the k's so that we don't have a problem :)
05:13:55 <xplat> copumpkin: i remember a paper that made a whole big deal about the fact that patricia tries can do set union in some kind of sublinear time
05:14:37 <Cale> -> runCont (Cont $ \k' -> runCont ((\ret -> Cont (\k -> runCont (ret 5) (\a -> runCont (ret 25) k))) (\a -> Cont $ \_ k' a)) k') id
05:15:46 <Cale> maybe I should have replaced the dead code with (...) from the beginning :P
05:16:21 <Wibowit> i'm still there, fyi :)
05:16:24 <Cale> (It's actually usually a mistake to be looking at the code in this way, and better to just understand what it means)
05:17:13 <Cale> Okay, let's try again, but this time, I'm going to elide some of the code which I know from the beginning won't be used
05:17:39 <xplat> copumpkin: monads have to be at least 'all functions' too ... return gives you all functions for ap, (return .) gives you all functions for bind / >=>.  the equivalent of arrows without arr is relative monads or something of the sort
05:17:43 <Cale> and I'll start from the very beginning with:
05:18:24 <Cale> runCont (callCC $ \ret -> ret 5 >>= \v -> ret 25)
05:20:17 <Cale> -> runCont $ let f = \ret -> ret 5 >>= \v -> ret 25   in Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k
05:21:44 <Cale> -> let let f = \ret -> ret 5 >>= \v -> ret 25   in \k -> runCont (f (\a -> Cont $ \_ -> k a)) k -- the runCont gets rid of the Cont constructor
05:22:06 <Cale> oop, shouldn't have two lets there :)
05:22:40 <Cale> now we need to know what f (\a -> Cont $ \_ -> k a) is in order to evaluate the runCont
05:22:52 <Cale> (it's going to pattern match on Cont)
05:23:03 <Cale> (well, it would, when we apply this function)
05:23:29 <Cale> so it's:
05:24:45 <Cale> -> \k -> runCont (let ret = (\a -> Cont $ \_ -> k a) in ret 5 >>= \v -> ret 25) k
05:25:01 <Cale> and now we evaluate the >>=
05:26:20 <Cale> -> \k -> runCont (let ret = (\a -> Cont $ \_ -> k a) in Cont (\k' -> runCont (ret 5) (\b -> runCont ((\v -> ret 25) b) k') k
05:26:44 <Cale> I know at this point that we're not ever going to use this \b function, so I'm going to elide it here:
05:26:55 <Cale> -> \k -> runCont (let ret = (\a -> Cont $ \_ -> k a) in Cont (\k' -> runCont (ret 5) (...) k') k
05:27:53 <Cale> damn it, I think I lost a paren
05:28:08 <Cale> -> \k -> runCont (let ret = (\a -> Cont $ \_ -> k a) in Cont (\k' -> runCont (ret 5) (...) k')) k
05:28:10 <Cale> there
05:28:23 <Cale> all right!
05:28:34 <Wibowit> wait a moment
05:28:38 <Wibowit> i think i got it
05:28:43 <Wibowit> :]
05:28:48 <Cale> you see it now?
05:28:53 <Wibowit> callCC is
05:28:55 <Wibowit> callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k
05:29:00 <Cale> yeah
05:29:11 <Wibowit> if i don't invoke f from do block then the argument to f is completely ignored
05:29:24 <Wibowit> ie is irrelevant
05:29:47 <Wibowit> or i'm wrong?
05:30:13 <Cale> If you don't invoke ret ...
05:30:37 <Cale> The argument to f here is 'ret'
05:31:56 <Cale> okay, let's take a couple more steps...
05:32:03 <Cale> we were at:
05:32:08 <Cale> \k -> runCont (let ret = (\a -> Cont $ \_ -> k a) in Cont (\k' -> runCont (ret 5) (...) k')) k
05:32:27 <Cale> now the runCont can apply
05:32:50 <Cale> well, let me push it through the let first, for sanity
05:33:32 <Cale> -> \k -> let ret = (\a -> Cont $ \_ -> k a) in runCont (Cont (\k' -> runCont (ret 5) (...) k')) k
05:34:17 <Cale> -> \k -> let ret = (\a -> Cont $ \_ -> k a) in (\k' -> runCont (ret 5) (...) k') k
05:34:35 <Cale> -> \k -> let ret = (\a -> Cont $ \_ -> k a) in runCont (ret 5) (...) k)
05:35:09 <Cale> -> \k -> runCont (Cont $ \_ -> k 5) (...) k)
05:35:20 <Cale> ah, dangling )
05:35:54 <Cale> oh, derp, also the k
05:36:14 <Cale> .___.
05:36:19 <Cale> augh
05:36:35 <Cale> I've been applying runCont to too many parameters for a while
05:37:50 <Cale> okay, I have no idea what that last k is doing there, it shouldn't be
05:38:11 <Cale> but the idea here is that \_ -> k 5  will ignore the stuff in the (...)
05:38:16 <Cale> and just call k with 5
05:38:28 <Cale> so in the end it'll simplify to
05:38:33 <Cale> \k -> k 5
05:38:50 <Cale> and then if I'd applied the whole thing to id, that would just be 5
05:39:02 <Cale> So in the definition of callCC
05:39:12 <Cale> callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k
05:39:20 <Cale> Cont $ \_ -> k a
05:39:51 <Cale> is what says to ignore the bit after the 'ret'
05:40:03 <Cale> and just call the continuation of the callCC with the value a
05:40:27 <yitz> Cale: what would you put there? undefined?
05:40:33 <Cale> hm?
05:41:21 <yitz> Cale: you said k shouldn't be there
05:41:24 <Cale> (I'm sorry for messing up the hand-evaluation so badly. In my defense, I just woke up a couple hours early, and haven't had a coffee yet.
05:41:32 <Cale> yitz: that parameter shouldn't be there at all
05:41:40 <yitz> oh ok
05:41:46 <Cale> (it's a type error)
05:42:01 <yitz> good it should be
05:42:21 <Cale> I'm pretty sure I just forgot to remove it when beta reducing at one point
05:42:57 <Cale> and since the expression is a mess, it can be a few lines before you notice something like that
05:43:12 <Wibowit> well i think i was right with that parameter ignoring
05:43:16 <yitz> as a CPS naysayer, i suppose i should say something like "i told you so". but i won't do that.
05:43:24 <Wibowit> ie callCC is callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k
05:44:16 <Wibowit> so if in a do block i do not invoke named continuation then the parameter ie. "callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k" is never evaluated
05:44:37 <Cale> huh?
05:44:44 <Wibowit> sorry i meant: "(\a -> Cont $ \_ -> k a)"
05:44:51 <Cale> oh, yes, that's right
05:44:53 <Wibowit> that was the ignored parameter
05:45:04 <Wibowit> ok so
05:45:06 <Cale> and if you *do* invoke it
05:45:18 <Cale> then it ignores its own continuation
05:45:31 <Cale> and instead calls k
05:45:38 <Wibowit> if i invoke f then it produces a continuation which ignores the following steps in do block and calls k
05:45:41 <Cale> which is callCC's continuation
05:46:04 <Cale> a computation
05:46:14 <Cale> it produces a computation which...
05:46:47 <yitz> we should have a variation on runCont called don'tRunCont
05:48:17 <Wibowit> slightly another topic: continuation was said to be something of type: a -> (b -> r) -> r, but Cont r a is (a->r) -> r
05:48:22 <Wibowit> that's confusing
05:48:35 <Wibowit> how should i pronounce Cont?
05:48:50 <Cale> Usually just how it's written
05:50:10 <Wibowit> ok so my last statement should be
05:50:12 <Wibowit> if i invoke f then it produces a continuation which ignores the following steps in do block and calls k
05:50:14 <Wibowit> sorry
05:50:21 <Wibowit> if i invoke f then it produces a Cont which ignores the following steps in do block and calls k
05:50:24 <Cale> Cont r is the continuation monad with results of type r. Values of type Cont r a are called (Cont r)-computations or (Cont r)-actions, or just Cont computations/actions
05:51:31 <Cale> (this is generally true of monads -- when M is a monad, we call values of type M a by the name M-actions or M-computations, unless we have a better name)
05:52:50 <Cale> Wibowit: but yes, that's right
05:52:59 <Wibowit> thanks to your suggestions i have rewritten
05:53:02 <Wibowit> callCC f = Cont $ \k -> runCont (f (\a -> Cont $ \_ -> k a)) k
05:53:04 <Wibowit> as
05:53:08 <Wibowit> callCC f = Cont $ \afterCall -> runCont (f (\a -> Cont $ \_ -> afterCall a)) afterCall
05:53:16 <Wibowit> and that helped me a lot :)
05:54:03 <triyo> On Debian, what package is the GHCi pat of? I installed `ghc' and it wasnt packaged with the compiler form what I can tell.
05:54:10 <triyo> *part
05:54:22 <Cale> Wibowit: but all this is implementation details of course, and once you understand that the intention is that in  callCC (\ret -> ...)  the ret is a function from the result of the callCC to the computation following the callCC, then you can just think of it that way.
05:54:40 <Wibowit> yes, i know
05:54:54 <Wibowit> but i like to know the implementation details
05:54:58 <Cale> with that in mind...
05:55:02 <Wibowit> i'm a former assembly guy :]
05:56:03 * hackagebot xkcd 0.1.1 - Downloads the most recent xkcd comic. (RobertSelvek)
05:56:05 * hackagebot optparse-applicative 0.4.0 - Utilities and combinators for parsing command line options (PaoloCapriotti)
05:56:49 <Wibowit> ok, so thank you very much Cale :)
05:57:55 <Cale> > let getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f)) in runCont (do ((x,xs), next) <- getCC' (0,[]); if x > 10 then return xs else next ((x+1),x:xs)) id
05:57:56 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0]
05:58:21 <Cale> (implementing goto-with-parameter using callCC :)
05:59:54 <Cale> you can also use  getCC = callCC (\c -> let x = c x in return x)
06:00:29 <Cale> but without some other effects, it's hard to see the loop that this creates
06:01:23 <triyo> What dist package / library is GHCi part of?
06:01:46 <triyo> I installed `ghc' on my Debian instance and need the GHCi.
06:01:55 <Cale> ghci> let getCC :: MonadCont m => m (m a); getCC = callCC (\c -> let x = c x in return x)
06:02:07 <Cale> ghci> runContT (do back <- getCC; liftIO (putStrLn "hello"); back) return
06:02:26 <Cale> <infinite loop printing hello>
06:02:48 <Cale> triyo: should be part of ghc's package
06:03:02 <Cale> triyo: but I never use Debian's package for GHC
06:03:22 <triyo> Cale: Hmm, I typed in ghci and didn't find the command. ghc command is there.
06:03:38 <Cale> (I prefer to install the generic linux binary from the GHC website, because it's usually more up to date, and not split up into a million tiny packages)
06:03:51 <Cale> triyo: maybe they split the package up even more than I recall
06:04:09 <Cale> Try  apt-cache search GHCi
06:04:09 <geekosaur> not that I'm aware of.  is this debian/arm or something?
06:05:02 <triyo> Cale: found nothing
06:05:47 <triyo> Apologies, left out the small detail. :-) It is ARM proc. Its Raspberry to be exact
06:05:53 <triyo> R-Pi
06:06:00 <geekosaur> I mentioned RAM becausse there;s no ghci for ARM (yet)
06:06:08 <triyo> Got it
06:06:09 <triyo> thank
06:06:11 <triyo> Thanks
06:06:16 <triyo> That explains it then
06:06:58 <triyo> geekosaur: any ideas if there is work being done on the GHCi for ARM?
06:07:08 <geekosaur> they're working on making ghci use the system linker instead of its own so it works on any platform instead of only the subset that a custom ghci linker exists for
06:07:31 <geekosaur> ghc for arm is under active development, yes.  you might want to subscribe to the ghc mailing lists
06:09:23 <alpounet> triyo, have you seen http://ghcarm.wordpress.com/ ?
06:10:09 <triyo> geekosaur: thanks, I'll subscribe to ghc
06:11:10 <triyo> apounet: thanks, I haven't seen that link before. Having a look now.
06:11:25 <triyo> alpounet: thanks, I haven't seen that link before. Having a look now.
06:14:42 <triyo> Found this: http://www.haskell.org/haskellwiki/Raspberry_Pi
06:14:49 <triyo> Note: GHCi does not currently work on ARM below version 7.4.2. See this post on haskell-cafe for information on this
06:15:04 <triyo> I have 7.4.1 installed via debian pck manager
06:15:53 <triyo> I'll just run a remote ghci from my R-Pi, then when happy, compile with local ghc ;-)
06:56:22 <mekeor> so, does ghci-7.4.2 support ARM? cooool, finally! yay!
06:58:15 <triyo> mekeor: yes, that is the case.
06:59:03 <triyo> On Raspberry Pi, there seems to be some issues: as per link I provided earlier ... "djhuk has been able to compile and install GHC-7.4.2 via QEMU to the Raspberry Pi but there still seems to be some work to do."
07:25:40 <mvj4> has there been any work on monadic stuff in Array.Accelerate (GPU)? Of course it is severly restricted but at least Identity would be nice.
07:26:00 <mvj4> like having foldM.
07:32:11 <ZsoL> has nobody ever needed an instance of (Lift ByteString)? really? :)
07:32:32 <ZsoL> (template-haskell)
07:34:17 <Saizan> hard to make a reasonable one, you have to go through String
07:40:30 <ZsoL> Saizan: do you know of any unreasonable implementations?
07:41:28 <Saizan> lift . unpack
07:41:40 <Saizan> well, not quite
07:42:20 <Saizan> \x -> [| pack $(lift (unpack x)) |]
07:43:37 <ZsoL> fair enough :) thanks
07:56:12 <t7> modular divion is so strange
07:56:53 <iamtakingiteasy> is there exists anything like "reverse forall", showing up hidden type variable to ghc?
07:58:04 <ion> wat
07:58:19 <Cale> Do you mean 'exists'?
07:58:34 <t7> does look like division
07:59:15 <Saizan> iamtakingiteasy: can you give an example of where you'd want to use it?
07:59:35 <hpaste> iamtakingiteasy pasted “Reverse forall - ?” at http://hpaste.org/72643
08:00:24 <Cale> iamtakingiteasy: That operation is intentionally impossible
08:00:34 <iamtakingiteasy> :/
08:00:39 <Cale> iamtakingiteasy: The whole point of the existential type is that you can't do that.
08:01:07 <jmcarthur> iamtakingiteasy: if you want a to be available there, you must expose it from DataStack
08:01:08 <Cale> If you want to be able to do that, then you need  data DataStack a = DataStack { stackBefore :: [a], stackAfter :: [a] }
08:01:20 <Cale> and then  getCurrent :: DataStack a -> a
08:01:28 <iamtakingiteasy> and write a (BFDataStackValue a) => constraint few dozen times :/
08:01:41 <Cale> Oh
08:01:47 <Cale> If you want to avoid that...
08:01:53 <Cale> data DataStack a where
08:02:13 <Cale>   DataStack :: (BFDataStackValue a) => [a] -> [a] -> DataStack a
08:02:53 <Cale> (I don't recall if the record syntax for GADTs still exists, or what)
08:03:02 <jmcarthur> it does exist, although it has changed
08:03:12 <danr> what was the record syntax for GADTs? :O
08:03:15 <jmcarthur> i don't remember it off the top of my head
08:03:23 <Cale> ah, the GHC user guide has it
08:03:28 <Saizan> the definition in the past is also fine if you remove the forall a. and put a on the LHS
08:03:28 <danr> ah
08:03:44 <Saizan> *paste
08:04:07 <danr> hmm can't really see how you would write the BFDataStackValue context with the record syntax though
08:05:04 <Cale> Isn't the real problem here though that you named your typeclass BFDataStackValue? :)
08:05:21 <Cale> and therefore can't stand to type its name :)
08:05:50 <danr> don't look at me ;)
08:06:05 <Cale> I'm looking at iamtakingiteasy :)
08:06:12 <Cale> What is this class used for?
08:06:53 <iamtakingiteasy> it represents a data type that can be treated as a value of stack for my BrainFuck-evaluator
08:07:39 <iamtakingiteasy> it derives from Eq,Read,Show,Num and also has 'identity' method which represents inital value for stack cell
08:07:54 <Cale> iamtakingiteasy: okay, so what are its methods?
08:08:30 <iamtakingiteasy> single one i mentioned just right now, in my previos message about 30 seconds ago :)
08:09:12 <triyo> I git this error when compiling a lib on a ARM arch: "Template Haskell bracket illegal in a stage-1 compiler". Anyone have any ideas how to go about fixing this?
08:09:50 <triyo> This one is a similar problem (also Debian on ARM): http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=654628
08:10:07 <Cale> iamtakingiteasy: I suspect that all this typeclass is doing is making your life harder
08:10:18 <hpaste> iamtakingiteasy pasted “BFDataStackValue declaration” at http://hpaste.org/72645
08:11:12 <iamtakingiteasy> mrm
08:11:15 <iamtakingiteasy> maybe you're right
08:11:53 <jmcarthur> data DataStack a = DataStack { identity :: a, stackBefore :: [a], stackAfter :: [a] }  -- one simpler possibility
08:12:05 <parcs`> triyo: TH doesn't work on arm
08:12:13 <triyo> Hmm, sadly, this might explain why: http://lists.debian.org/debian-haskell/2010/10/msg00018.html
08:12:24 <triyo> Needs GHCi bit it seems
08:13:51 <parcs`> looks like you can have contexts + records in a gadt: 'data Foo where Foo :: Show a => { foo :: a } -> Foo' works
08:14:00 <parcs`> er, fields
08:14:32 <jmcarthur> not the most memorable syntax, though
08:14:41 <jmcarthur> for fields
08:16:02 <danil> it looks like what a function signature would look like if we had anonymous record types, so I can see why they picked it
08:16:12 <danil> (but we don't, so it's still pretty strange)
08:17:07 <jmcarthur> ah, that makes sense
08:17:23 <jmcarthur> anonymous record types would be pretty awesome to have
08:17:31 <jmcarthur> so would polymorphic variants, while we're at it
08:18:16 <danil> I'm not so sold on polymorphic variants, the OCaml best practice seems to be to avoid them at all costs as far as I can tell
08:18:25 <jmcarthur> we use them all the time
08:19:23 <jmcarthur> they are great for making certain properties of functions clear in the type. for example, a return type of [ `Ok of a | `Eof ] is much more clear than Maybe a
08:19:37 <jmcarthur> OTOH, now you can't use functions designed for Maybe on it
08:20:38 <jmcarthur> of course you could always just define a new type, but making that a convention would require a lot more browsing of code to understand type signatures
08:21:08 * hackagebot jmacro-rpc-happstack 0.1 - Happstack backend for jmacro-rpc (GershomBazerman)
08:21:11 <danil> Hmm, that does seem nice.  Maybe the advice I heard was just to steer people away from trying to replace their regular ADTs with them.
08:22:13 <danil> do you use subtyping much, or is it mostly one-off closed types like that?
08:22:50 <jmcarthur> even for ADTs, it's sometimes nice to use poly variants instead. for example, if the implementation of your type is exposed so other code can pattern match on it, it's convenient to use poly variants because you can do the pattern matching without having to qualify the module names or do unqualified imports
08:23:13 <jmcarthur> we use subtyping with poly variants sometimes, but only for some select cases
08:23:20 <jmcarthur> for example, it's useful for versioning of protocols
08:24:38 <jmcarthur> type t = [ `V1 of v1 | `V2 of v2 | `V3 of v3]    (* can still read messages from processes that only know [ `V1 of v1 | `V2 of v2 ]
08:24:41 <jmcarthur> *)
08:26:09 * hackagebot language-objc 0.4.2.2 - Analysis and generation of Objective C code (JohnLato)
08:26:36 <jmcarthur> a coworker and i recently made a typerep sort of thing that allows network communications to be type checked at runtime, supporting subtyping like that. pretty handy
08:27:30 <danil> are you at Jane Street?
08:27:45 <jmcarthur> yes
08:29:33 <danil> I've been considering applying
08:29:36 <jmcarthur> there are definitely downsides to using poly variants too much though
08:29:39 <jmcarthur> ah, you should!
08:30:06 <timthelion> When does the hackage hadock cron job get run?
08:30:24 <jmcarthur> timthelion: i don't know exactly, but it's usually within a few hours, for me
08:30:39 <timthelion> jmcarthur: days for me this time...
08:30:42 <jmcarthur> i wish it would just run upon submission
08:30:45 <jmcarthur> ew!
08:31:19 <timthelion> It's frustrating, since different hadock versions work differently, it's really the only reliable way to see if the haddock is right.
08:32:01 <alpounet> timthelion, normally it's like 12h maximum
08:33:20 <timthelion> Do we know what hackage uses to generate the literate haskell haddocks?
08:37:04 <otters> I don't understand how the Wai vault works
08:37:08 <otters> are insertions persistent?
08:37:24 <danil> I wonder how classes would work with anonymous types.  Maybe through something like the generics system...
08:37:31 <otters> across requests
08:38:00 <roconnor> danil: what are anonymous types?
08:38:35 <danil> records and polymorphic variants
08:39:10 <roconnor> danil: in Coq/SSReflect we just declare canonical instances without declaring structures as explicitly being classes.
08:39:24 <roconnor> danil: any structure can be a class
08:39:43 <danil> like scala implicits?
08:39:54 <roconnor> I don't know scala
08:41:32 <danil> is the idea that you say "this value is canonical (at this type)" and the elaborator fills in that value when it wants something of that type?
08:42:19 <roconnor> danil: in coq/SSReflect the carrier type doesn't have to be the key; any value in the structure can be a key.
08:42:21 <danil> (I barely know any Coq, my only dependent experience is a smidgeon of Agda)
08:43:41 <roconnor> danil: ao you say "this structure is canonical" and the elaborator fills in that value when it tries to unify a canonical field element with the field projector of some unification vairable of a structure.
08:44:00 <roconnor> more specifically
08:45:12 <roconnor> when (expr === field_proj ?A) is encountered during unification, and there exists a canonical structure C with expr in its field_proj position, then ?A is magically unified with C.
08:45:36 <roconnor> Often (expr) is a type and (field_proj) is "Carrier"
08:47:06 <danil> ah, so a little like fundeps, only values can also be keys/get refined
08:47:23 <roconnor> So, to take a simple haskell example
08:48:03 <roconnor> imagine a structure {Carrier := Bool, eq := bool_eq} which is approxiamtely the dictionary for the Eq instance for Bool.
08:48:18 <roconnor> suppose we declare this structure as canonical in Coq
08:49:33 <roconnor> let me try a somewhat better example
08:49:43 <roconnor> imagine a structure {Carrier := Int, eq := int_eq} which is approxiamtely the dictionary for the Eq instance for Int.
08:49:46 <roconnor> suppose we declare this structure as canonical in Coq
08:50:02 <roconnor> so (eq) has type (forall (dict: EqType), Carrier dict -> Carrier dict -> Bool)
08:50:27 <roconnor> and we label the dict argument of eq as implicit
08:51:08 <roconnor> then we go along and write x y :: Int |- eq x y
08:51:12 <danil> so as soon as you know that "Carrier dict" is Int, it can fill in the dict
08:51:21 <roconnor> I.E we write eq x y  in the context where x and y are Int
08:51:26 <roconnor> how does this type check
08:51:50 <roconnor> Firstly there is an implicit argument, so really eq _ x y is typechecked where _ is the unknown dict argument
08:52:27 <roconnor> the type checker sees the hole _ and passed by it since there is nothing available to typecheck yet
08:52:34 <roconnor> next we turn to x, which has type Int
08:53:04 <roconnor> but x is supposed to have type Carrier ?dict where ?dict is the unification variable for that hole we just hopped by.
08:53:27 <roconnor> so we try to solve the unification problem Int === Carrier ?dict
08:54:11 <roconnor> It doesn't really unifiy normally, but now the canonical structure mechanism kicks in and says: Hey, we are trying to unify an expression with the projection of some record, do we have a canonical instance?
08:54:37 <roconnor> so we look around for any canonical instance of EqType whose Carrier field is Int
08:54:43 <roconnor> and we find one was declared
08:54:57 <danil> ah.
08:55:06 <roconnor> so we fill in the declared Int_EqType :: EqType for ?dict
08:55:17 <roconnor> yeilding Int === Carrier (Int_EqType)
08:55:25 <roconnor> and filling that hole in with Int_EqType
08:56:15 <danil> that clears things up
08:56:43 <danil> what I was actually wondering though was along the lines of how to write e.g. one Show instance for all records
08:56:55 <roconnor> ah
08:56:59 <roconnor> heh
08:57:09 <roconnor> that probably requires a generic programming mechanism
08:58:12 <danil> if they were just lists of (label, value) it'd be fine, but there's no canonical field order
08:58:30 <roconnor> sure there is; the order that the labels were declared :D
08:58:58 <roconnor> unless swaping the order of fields yields the same type :/
08:59:10 <roconnor> in which case you have to sort the field labels
08:59:59 <danil> yeah, I was thinking about OCaml style records in particular, but basically all the systems proposed for Haskell identify record types with different field orderings
09:00:33 <danil> if you have record polymorphism (of any sort) it gets worse, because you may not know the full list of field names
09:01:10 * hackagebot static-resources 0.1.5.1 - JavaScript and Css files concat for http optimization. Now with LESS suppor. (MariuszRak)
09:02:32 <danil> with Has-constraints I guess it's manageable; you end up with contexts like (Show r, Has r FieldA, Has r FieldB) => ...
09:02:32 <gwern> @quote
09:02:32 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
09:06:49 <bitrust> Today I'm reading Prelude like a book, followed by the better parts of what's included in platform. Might learn something...
09:06:51 <danil> but if you have polymorphic record extension you really want "(\r -> show {a = 1 | r}) {b = 1}" to be the same as "(\r -> show {b = 1 | r}) {a = 1}", which means the instance you build at runtime starting from Show {a :: Int} and from Show {b :: Int} need to end up the same when you add the same fields
09:08:54 <danil> I assume OCaml does this sort of thing as a builtin or implements it with Obj by inspecting the (concrete) runtime representation?
09:09:33 <jmcarthur> i went away for a bit and only just now came back. is there a short summary or should i read the whole conversation above?
09:10:22 <danil> you can skip the Coq parts unless you're after a diversion
09:12:28 <timthelion> Is there anything written on using haddock with lhs???
09:12:48 <jmcarthur> danil: i think i just don't understand the question
09:13:28 <timthelion> all I can find in google are like 3 rants about how it sucks.  The official documentation claims it works, but provides nothing to support that claim(aka examples)
09:13:31 <jmcarthur> danil: ocaml has anonymous objects. classes are basially just types for objects
09:13:47 <danil> oh, I meant Haskell classes
09:13:49 <timthelion> Does anyone know of a project written in LHS on hackage?
09:13:57 <danil> if you had polymorphic records / variants in Haskell, you'd want to have Eq and Show and such on them when the fields supported it
09:14:08 <jmcarthur> ah
09:14:24 <danil> but I'm not sure how you'd go about defining those
09:14:35 <b_jonas> timthelion: do you mean literate haskell?
09:14:40 <b_jonas> because yes, there are such projects
09:14:44 <timthelion> b_jonas: yes, of course
09:14:47 <timthelion> link?
09:14:54 <timthelion> how would I search for lhs?
09:15:03 <b_jonas> a moment
09:15:33 <jmcarthur> danil: i think one direction i would look into is making the type class dictionary basically just another field in the record. that's kind of using type classes more like first class modules, i guess
09:15:49 <jmcarthur> thinking about it more, i like it less and less
09:16:05 <jmcarthur> it's a lot like an object then. i like type classes being "outside" the record, a lot
09:16:47 <bitrust> timthelion: I know that this is for eg.: http://hackage.haskell.org/package/epic
09:18:07 <jmcarthur> of course the simplest way to go about it is to just require that it be a named type, like we do already (you can't make an instance for a mere type synonym, for example)
09:18:46 <b_jonas> timthelion: literate haskell sources files usu have the extension ".lhs" instead of ".hs" in their filename. some packages that include such files are ghc itself, plus these cabal: HTTP, HUnit, TypeCompose, binary, control-event, editline, haddock, hexpat, hmatrix, hxt, text, utf8-string
09:19:47 <danil> jmcarthur: That's true.  Not having Show in ghci would be painful, but ghci should probably be more aggressive about printing things anyway
09:19:52 <timthelion> bitrust: but that's not literate haskell in any sense of the name :( , that's just normall haskell with a bunch of >'s  for no reason.  The haddock comments are all >'d off.
09:19:55 <timthelion> b_jonas: I'll take a look
09:21:25 <bitrust> timthelion: The source code is all .lhs
09:21:38 <timthelion> bitrust: yes, but that doesn't make it "literate" :/
09:21:56 <bitrust> timthelion: Ah!
09:22:13 <timthelion> bitrust: look at the code, not a single LHS comment.
09:23:28 <bitrust> timthelion: My bad, I think I see what you want now. For haddock to use the LHS comments.
09:24:07 <timthelion> bitrust: yes.
09:24:16 <timthelion> I'd like to see how it's done...
09:25:25 <jfischoff> Can you write Uniplate instances for a type safe GADT, or will need to use Multiplate?
09:25:49 <jfischoff> err type safe expression as a GADT I guess is a better phrasing
09:26:11 * hackagebot jmacro-rpc-snap 0.1 - Snap backend for jmacro-rpc (GershomBazerman)
09:26:13 * hackagebot subtitleParser 0.3 - A parser for .srt and .sub files (RubenAstudillo)
09:26:33 <hpaste> “Jonathan Fischoff” pasted “GADT expression” at http://hpaste.org/72653
09:26:44 <jfischoff> ^ that is the GADT in question
09:27:19 <slack1256> ls
09:27:28 <slack1256> *sorry
09:28:56 <Athas> timthelion: I wrote a window manager in Literate Haskell, but it's not on Hackage.
09:29:04 <Athas> It's on, uh... darcsden, I think.
09:30:19 <timthelion> Athas: It's only useful to me, if it has the haddoc documentation...
09:30:32 <timthelion> what wm btw?  xmonad didn't suffice?
09:31:07 <slack1256> Athas: if is a floating windows WM I would like to check it out
09:31:12 <Athas> timthelion: it's a Ratpoison clone, called Mousetoxin.
09:31:17 <Athas> It's tiling.
09:31:28 <timthelion> Athas: why?
09:31:44 <Athas> Because I liked Ratpoison, but wanted to try writing a nontrivial literate program.
09:31:44 <xORioN63> hey, I'm new to Haskell, could anyone check what's wrong with my code?
09:31:45 <xORioN63> http://pastebin.com/p4f4nvVg
09:31:48 <mauke> The paste p4f4nvVg has been copied to http://hpaste.org/72654
09:31:52 * timthelion wonders if people still use ratpoison
09:31:54 * timthelion googles it
09:31:58 <Athas> It's at http://old.sigkill.dk/code/darcsrepos/mousetoxin/ if you want to check it out.
09:32:01 <b_jonas> timthelion: I see
09:32:18 <slack1256> xORioN63: give me a sec
09:32:30 <xORioN63> slack1256: thanks ;)
09:32:44 <slack1256> xORioN63: btw haskeller have hpaste (which announce in the channel automagically)
09:33:15 <timthelion> Athas: OMG latex :D  nice
09:33:22 <merijn> xORioN63: Ah, dread monomorphism restriction
09:33:22 <xORioN63> slack1256: yep, sorry about that. I'm used to pastebin
09:33:50 <merijn> xORioN63: Lemme look up a good explanation for you
09:34:19 <slack1256> xORioN63: is this aproject euler problem?
09:34:23 <xORioN63> yep
09:34:35 <merijn> xORioN63: Did you try running it with -XNoMonomorphismRestriction as it suggests? If so, did that work?
09:34:58 <parcs`> xORioN63: do floor (sqrt x) instead of sqrt x
09:35:04 <xORioN63> merijn: no, I assumed it was my code
09:35:10 <merijn> xORioN63: Here's an explanation of what the MMR is and why it exists: http://www.haskell.org/haskellwiki/MR
09:35:45 <merijn> xORioN63: I'm not sure whether the MMR is the real problem, but it is at least the most obvious one that GHC is complaining about
09:36:11 * hackagebot bytestring-show 0.3.5.2 - Efficient conversion of values into readable byte strings. (DanDoel)
09:36:35 <parcs`> xORioN63: floor (sqrt (fromIntegral x))) actually
09:36:39 <geekosaur> the rest is mixing sqrt with mod
09:36:47 <geekosaur> ....that
09:37:09 <xORioN63> well, that works...
09:37:11 <xORioN63> why?
09:37:28 <Athas> timthelion: it was a surprisingly pleasant way to program, although I found it hard when doing exploratory programming.
09:37:43 <Athas> Also, nowadays, I would probably use a format amenable to producing HTML.
09:37:47 <slack1256> xORioN63: the 'isPrime' function isn't imported
09:37:51 <xORioN63> >[1..sqrt(10)]
09:38:01 <slack1256> xORioN63: from which package did you get it?
09:38:02 <merijn> slack1256: It's in the let binding
09:38:17 <merijn> xORioN63: Lambdabot demands a space between > and haskell expressions
09:38:18 <xORioN63> this works on ghci, why do I need to use the rest on that code?
09:38:20 <slack1256> merijn: right, right.
09:38:23 <merijn> > [1..sqrt 10]
09:38:25 <lambdabot>   [1.0,2.0,3.0]
09:38:27 <xORioN63> thanks
09:38:38 <merijn> Also, the parenthesis are not needed there
09:38:50 <xORioN63> that works, why do I need to floor it on my code?
09:38:51 <parcs`> xORioN63: because you're using 'x' in a place that requires it to be Integral and in a place that requires it to be Floating, which doesn't make sense
09:39:00 <merijn> :t mod
09:39:02 <lambdabot> forall a. (Integral a) => a -> a -> a
09:39:10 <xORioN63> oh, ok
09:39:11 <Athas> timthelion: in general, though, Haddock and Literate Haskell are disjoint concepts.  They serve different purposes.  If I were writing a literate project with Haddock documentation, I might even conceal the Haddock comments from the document.
09:39:17 <xORioN63> got it
09:39:24 <merijn> xORioN63: As you see mod expect an "Integral a", whereas sqrt returns a non-Integral
09:39:28 <merijn> :t sqrt
09:39:29 <lambdabot> forall a. (Floating a) => a -> a
09:39:38 <merijn> :t floor
09:39:39 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:40:19 <merijn> xORioN63: Unlike C and others there is no implicit conversion from floating point to integral values, so you need floor to do it explicitly and avoid type errors
09:40:51 <xORioN63> ok
09:40:59 <slack1256> merijn: you are right. use someting like floot( sqrt x )
09:41:13 <slack1256> i mean xORionN63
09:41:24 <xORioN63> got it
09:41:29 <merijn> It's a blessing in a curse, the use of floor/fromIntegral can be annoying at times. On the other hand you never have to worry about debugging accidental conversions which are a pain too
09:41:45 <merijn> s/in a/and a/
09:42:33 <slack1256> is not that bad, specially if you don't know how C operates in this matter
09:44:10 <xORioN63> why do I need the fromIntegral?
09:44:24 <xORioN63> sqrt accepts both ints and floats
09:44:35 <danil> > sqrt (1 :: Int)
09:44:36 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
09:44:36 <lambdabot>    arising from a use of...
09:45:56 <danil> > :t 80
09:45:57 <lambdabot>   <no location info>: parse error on input `:'
09:46:08 <danil> :t 80
09:46:09 <lambdabot> forall t. (Num t) => t
09:46:20 <slack1256> xORioN63: that's only in ghci because al numeral are in the Num Class
09:46:25 <merijn> xORioN63: sqrt only accepts "Floating a", haskell has polymorphic numeric constants
09:46:32 <slack1256> which includes Float and Int
09:46:44 <danil> you can use a numeric literal as any numeric type, so "sqrt 1" will work because 1 can be a Float
09:46:46 <merijn> xORioN63: So "10" is not type "Int", but "Num a => a"
09:47:10 <merijn> > sqrt (1 :: Float)
09:47:12 <lambdabot>   1.0
09:47:19 <merijn> > sqrt (1 :: Double)
09:47:21 <lambdabot>   1.0
09:47:24 <merijn> > sqrt (1 :: Integer)
09:47:26 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
09:47:26 <lambdabot>    arising fr...
09:47:41 <xORioN63> oh, ok, thank you all
09:47:51 <merijn> > sqrt (fromIntegral (1 :: Integer))
09:47:52 <lambdabot>   1.0
09:47:56 <merijn> :t fromIntegral
09:47:57 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:51:42 <slack1256> anybody here uses vng (the darcs-like wrapper for git) and has experience with github?
09:58:32 * ksf wonders whether a program that could generate different versions of ADTs and transitions between them would be worth the lines it's made up of.
09:59:18 <ksf> you know, those typical situations where you start out with one ADT, then remove or add some alternatives in a sum type, factor a Maybe into a constant just, etc.
09:59:45 <ksf> right now I can express the latter, but sum types are just out of reach
10:11:29 <belgin> http://pastebin.com/ChUXDJrc can someone please explain how this works with the omitted list argument?
10:11:31 <mauke> The paste ChUXDJrc has been copied to http://hpaste.org/72655
10:11:47 <slack1256> I don't understand the difference between sum and product types
10:12:27 <slack1256> it seem to me product types have all their types on one constructor, and that sum types usually in different constructors.
10:13:17 <slack1256> *it seems
10:13:49 <danil> slack1256: that's basically it.  A product type like (A, B) gets you an A and a B, while a sum type like Either A B gets you one or the other but not both
10:14:16 <monochrom> evenNR p xs = parity (map p xs)
10:14:57 <pozic_> Would it be correct to say that GHC's threading is nothing more than running preemptive lightweight threads on top of a few pthreads?
10:15:04 <slack1256> danil: is there any import implication of that in CS?
10:15:19 <slack1256> *s/import/important/
10:15:42 <monochrom> I think yes pozic_
10:16:27 <pozic_> monochrom: and naturally the run-time support to have parallel GC.
10:16:57 <monochrom> I don't know the GC story. but it gets better every version
10:17:01 <pozic_> Which basically is just the same system with some system for mutal exclusion.
10:17:06 <pozic_> mutual exclusion
10:17:24 <pozic_> The RTS is still C, AFAIK.
10:17:29 <slack1256> monochrom: weird, I use the same phrase in my head about GC in haskell.
10:17:30 <danil> slack1256: there are a bunch of useful symmetries between the two, and they're convenient terms for talking about things.  But nothing too deep unless you get into the logic/category theory end of things.
10:17:37 <belgin> monochrom: i know it can be rewritten like that, but i'm wondering how the form with the omitted argument works
10:18:12 <monochrom> then I don't understand what you mean by "how it works". I don't understand the question.
10:18:26 <slack1256> danil: oh, cool then. thanks danil.
10:19:03 <slack1256> pozic_: the RTS needs to be C, it manage low level resources.
10:19:12 <belgin> monochrom: how does the interpreter know where to put the omitted argument inside the function body?
10:19:13 <danil> slack1256: for an example of the symmetry, look at the types of fst, snd, Left, Right, (,) and either and see if you see a pattern
10:19:33 <monochrom> the "." operator knows. the interpreter merely evaluate the "." operator
10:20:12 <monochrom> (parity . map p) [1,2,3] --> parity ((map p) [1,2,3]  by expanding the definition of the "." operator
10:20:28 <monochrom> parity ((map p) [1,2,3])
10:20:42 <belgin> ok thanks
10:22:06 <monochrom> the difference between product type and sum type is the same difference between "answer all 5 questions in this exam" and "answer only 1 out of 5 questions in this exam"
10:22:54 <monochrom> if I were a student taking an exam, I wouldn't call it "I can't see the difference". I would have to see the difference, just to survive
10:23:35 <monochrom> granted, some other students don't see the difference, but then they don't survive
10:24:13 <luite> yeah i once got a lower grade because i answered all questions :(
10:26:40 <sentientwaffle> is it possible to convert a type [[IO SomeType]] to IO [[SomeType]]?
10:27:05 <slack1256> sentientwaffle: check Data.Traversable
10:27:13 <MostAwesomeDude> @hoogle [IO a] -> IO [a]
10:27:14 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:27:14 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:27:14 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:27:25 <danil> :t mapM sequence
10:27:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
10:27:37 <Veinor> :t sequence . sequence
10:27:38 <lambdabot> forall a. [[a]] -> [[a]]
10:27:49 <sentientwaffle> wow, thanks!
10:27:53 <MostAwesomeDude> Sure.
10:28:35 * slack1256 gives MostAwesomeDude a black-belt in lambdabot-fu
10:28:47 <monochrom> "\_ -> return []" also has that type
10:29:41 <danil> not most generally though
10:30:20 <Saizan> :t sequence <=< sequence
10:30:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m (m a)] -> m [a]
10:30:37 <merijn> Saizan: Ha, wrong type :p
10:30:42 <sentientwaffle> excellent, "sequence" was exactly what I needed
10:31:06 <roconnor> sequence is the solution to most programming problems
10:31:14 <latro`a> lol
10:31:17 <merijn> sentientwaffle: For future reference you can always try searching hoogle with the type signature you were hoping to get
10:31:43 <slack1256> really Data.Traversable should get more publicity, is truly useful.
10:31:51 <paolino> sentientwaffle, maybe you could avoid it by using a couple of mapM instead of map before
10:34:48 <sentientwaffle> paolino: yep, looks like it, thanks!
10:44:25 <DMcGill> is there no way to access the cabal-install library (i.e. Distribution.Client and so on)?
10:44:40 <geekosaur> hm? it's called Cabal
10:45:20 <geekosaur> http://www.haskell.org/cabal/release/cabal-latest/doc/API/Cabal/
10:45:24 <DMcGill> the package Cabal doesn't include the Distribution.Client libraries
10:45:54 <DMcGill> this answer suggests not: http://stackoverflow.com/questions/11257712/how-to-get-cabal-install-distribution-client-indexutils
10:46:03 <DMcGill> that was 6 months ago however
10:46:13 <geekosaur> oh.  those may not actually be exposed as a library, then.  probably can raise that on haskell-cafe or file a bug somewhere
10:46:36 <geekosaur> although the cabal folks have tended to be a bit busy so things like that tend to happen slowly
10:51:14 * hackagebot cursedcsv 0.1.1 - Terminal tool for viewing tabular data (GershomBazerman)
10:51:16 * hackagebot boolsimplifier 0.1.7 - Simplification tools for simple propositional formulas. (GershomBazerman)
10:56:02 <jfischoff> @ty sequence . fmap sequence
10:56:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
10:56:32 <otters> :t [a]
10:56:33 <lambdabot> [Expr]
10:56:44 <otters> :t ()
10:56:45 <lambdabot> ()
10:58:30 <otters> :t Void
10:58:32 <lambdabot> Not in scope: data constructor `Void'
11:00:43 <allsystemsarego> @src maximum
11:00:43 <lambdabot> maximum [] = undefined
11:00:44 <lambdabot> maximum xs = foldl1 max xs
11:01:12 * mekeor is sad because he still didn't get his Hackage user account although he sent the e-mail 26 hours ago.
11:01:54 <aristid> mekeor: all cool people have a Hackage user account. it is known
11:01:58 <hpc> mekeor: took me over a week
11:02:27 <sm> :/
11:02:39 <aristid> is it's still all done by sending an email to ... i think his name was ross?
11:02:55 <alpounet> yes, ross paterson
11:03:45 <mekeor> hpc: oh my god. -.-
11:04:01 <aristid> alpounet: i guess that does prevent spambots from creating accounts
11:05:22 <alpounet> aristid, yeah, but hackage2 is coming little by little, and iirc the user registration procedure is going to be different
11:05:29 <alpounet> they'll have to be moderator-approved or something iirc
11:07:04 <aristid> alpounet: right, but it's probably better not to have it be a single person
11:07:39 <alpounet> aristid, if what i mentionned is the system hackage2 will use, there won't be only one person to approve/reject user account creation
11:07:49 <alpounet> and there'll be a smart handling of packages
11:07:57 <alpounet> like groups of maintainers for a given package, etc
11:08:13 <donri> mekeor: maybe someone could upload for you
11:08:26 <mekeor> yeah!
11:08:35 <mekeor> donri: the package is already on github =)
11:08:39 <mekeor> donri: would you upload it?
11:08:40 <hpc> the author field is tied to the .cabal file anyway
11:08:47 <mekeor> oO?
11:08:58 <mekeor> hpc: so only the author can upload the package?
11:09:01 <donri> mekeor: sure, repo?
11:09:03 <hpc> so it isnt visible who did the actual upload
11:09:14 <donri> it's visible who uploaded, but it's separate from author and maintainer
11:09:14 <luite> it is visible in the log
11:09:20 <hpc> ah
11:09:36 <donri> and no one owns any package in hackage1
11:09:38 <otters> > case undefined of undefined -> 1
11:09:39 <lambdabot>   1
11:09:44 <otters> no way
11:09:45 <mekeor> donri: :)
11:10:04 <mekeor> donri:
11:10:16 <alpounet> hpc, Hackage always shows "Uploaded by" i think
11:10:34 <alpounet> but as the others say, it's separate from Author/Maintainer
11:10:40 <c_wraith> otters: that case statement doesn't evaluate anything
11:10:50 <luite> oh also on the haddock page :)
11:11:08 <aristid> otters: undefined is a variable there
11:11:57 <alpounet> indeed
11:12:09 <otters> good
11:13:33 <Veinor> > let undefined = 2 in undefined
11:13:35 <lambdabot>   2
11:14:13 <alpounet> :t \x -> case undefined of undefined -> 1
11:14:14 <lambdabot> forall t t1. (Num t1) => t -> t1
11:14:30 <donri> > let (---) = "ohai" in (---) -- --- -
11:14:32 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:14:35 <donri> :(
11:15:03 <donri> > let (-->) = "ohai" in (-->) --> <--- -<
11:15:04 <lambdabot>   <no location info>: parse error on input `<---'
11:18:24 <alpounet> > let (-->) = "ohai" in (-->) -- (<--)
11:18:25 <lambdabot>   "ohai"
11:18:51 <donri> oh rightg
11:22:47 <tromp_> :t fromInteger
11:22:48 <lambdabot> forall a. (Num a) => Integer -> a
11:23:15 <tromp_> @instances Num
11:23:16 <lambdabot> Double, Float, Int, Integer
11:23:58 <tromp_> > -2/8 -2/13+1/17
11:23:59 <lambdabot>   -0.34502262443438914
11:24:12 <tromp_> > -2/8+3/13+4/17
11:24:13 <lambdabot>   0.2160633484162896
11:24:44 <tromp_> > -0.34502262443438914**2 + 0.2160633484162896**2
11:24:45 <lambdabot>   -7.23572408427346e-2
11:25:09 <tromp_> > 0.34502262443438914**2 + 0.2160633484162896**2
11:25:10 <lambdabot>   0.16572398190045248
11:31:15 * hackagebot hascal 1 - a minimal, extensible and precise calculator (DagOdenhall)
11:33:11 * mekeor didn't know Haddock was also a fish until now.
11:33:31 <sipa> haha
11:33:47 <mekeor> :D
11:34:01 <mekeor> sipa: did you?
11:34:07 <mekeor> … did you know it?
11:34:09 <k0ral> hello there, I think there is opportunity for a new monad that would make it possible to write FilePath in a plateform-independent way, e.g. to allow writing: home </> "dir" </> "file", instead of writing first "getHomeDirectory" each time
11:34:19 <mroman> I only knew that it had dock.
11:34:27 <sipa> mekeor: i did :)
11:34:43 <mekeor> s/plateform/platform/
11:34:49 <sipa> k0ral: why would that need to be a monad?
11:34:51 <k0ral> mekeor: my bad
11:34:55 <mekeor> :P :D
11:35:34 <k0ral> sipa: hmmm, actually that may not be a monad
11:36:06 <hpaste> gertc pasted “https://github.com/gertcuykens/haskell-design” at http://hpaste.org/72657
11:36:17 <mekeor> @hoogle (</>)
11:36:17 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
11:36:18 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
11:36:28 <sipa> the problem is that reading the home directory is an IO operation
11:36:31 <mekeor> there's already this which is certainly not what you want but similar.
11:36:36 <mekeor> k0ral.
11:36:42 <k0ral> mekeor: it would require redefining </> to work on symbols like home, tmp etc
11:36:54 <sipa> k0ral: it does
11:37:06 <sipa> it works on any expression of type FilePath
11:37:18 <k0ral> sipa: yes but I want it to work on an IO FilePAth
11:37:21 <k0ral> FilePath*
11:37:21 <gertc> how do i tel cabal to use the old conduit for chat.hs and the new one for Web.hs?
11:37:32 <k0ral> like getHomeDirectory
11:37:41 <donri> the new tintin movie taught me haddock is a fish
11:37:43 <k0ral> wouldn't that be nice ?
11:38:02 <k0ral> we could even extend it to m FilePath, provided we can run m
11:38:34 <k0ral> the idea is to get rid of the need to perform a get***Directory in the first place
11:38:48 <sipa> k0ral: but you cannot avoid that
11:39:02 <k0ral> sipa: that would be encapsulated in </>
11:39:10 <mekeor> k0ral: getHomeDirectory <$> (</> "Desktop" </> "anotherDirectory) -- i think this should work.
11:39:31 <mekeor> > getHomeDirectory <$> (</> "Desktop" </> "anotherDirectory) -- does lambdabot have the needed modules included?
11:39:33 <lambdabot>   <no location info>:
11:39:33 <lambdabot>      lexical error in string/character literal at end o...
11:39:41 <mekeor> > getHomeDirectory <$> (</> "Desktop" </> "anotherDirectory") -- does lambdabot have the needed modules included?
11:39:42 <lambdabot>   Not in scope: `getHomeDirectory'Not in scope: `</>'Not in scope: `</>'
11:39:45 <mekeor> No.
11:40:51 <k0ral> oh, if that works, then everything I said is bullshit :)
11:41:05 <mekeor> @type let (</>) a b = a ++ "/" ++ b; getHomeDirectory = return "/home/lambdabot/" :: IO FilePath; in getHomeDirectory <$> (</> "Desktop" </> "anotherDirectory") -- does lambdabot have the needed modules included?
11:41:07 <lambdabot>     The operator `</>' [infixl 9] of a section
11:41:07 <lambdabot>         must have lower precedence than that of the operand,
11:41:07 <lambdabot>           namely `</>' [infixl 9]
11:41:14 <mekeor> -.-
11:41:26 <allsystemsarego> @src fold
11:41:27 <lambdabot> Source not found. Do you think like you type?
11:41:29 <mekeor> we need a fixity declaration…
11:41:38 <allsystemsarego> @src foldr
11:41:39 <lambdabot> foldr f z []     = z
11:41:39 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:41:58 <mekeor> allsystemsarego: there's only foldl and foldr. you can also do /msg lambdabot @src …, btw. :P
11:42:08 <mekeor> s/only //
11:42:21 <allsystemsarego> mekeor, thanks
11:42:38 <mekeor> allsystemsarego: i did not help :P :D =) :) :]
11:51:25 <k0ral> @hoogle getHomeDirectory
11:51:25 <lambdabot> System.Directory getHomeDirectory :: IO FilePath
11:54:52 <k0ral> mekeor: getHomeDirectory <$> cannot work since it doesn't take any argument
11:55:12 <sipa> :t (<$>)
11:55:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:55:19 <k0ral> (</> "xxx") <$> getHomeDirectory
11:55:54 <k0ral> @hoogle f a -> (a -> b) -> f b
11:55:55 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
11:55:55 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
11:55:55 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
11:56:09 <k0ral> I want flip <$>
11:56:45 <k0ral> > let >$< = flip <$> in getHomeDirectory >$< (</> "xxx")
11:56:47 <lambdabot>   <no location info>: parse error on input `>$<'
11:57:14 <Taneb> > let (>$<) = flip (<$>) in getHomeDirectory >$< (</> "xxx")
11:57:15 <lambdabot>   Not in scope: `getHomeDirectory'Not in scope: `</>'
11:57:23 <k0ral> oh right, parens
12:07:40 <MagneticDuck> hey.. I'm trying to add a haddock comment to my code
12:07:46 <MagneticDuck> --| seems to not work
12:07:53 <MagneticDuck> I get errors from buildwrapper
12:08:03 <Taneb> -- |
12:08:06 <Taneb> With a space
12:08:11 <MagneticDuck> ah
12:08:13 <MagneticDuck> x)
12:08:14 <jmcarthur> > let a --| b = (+) in a --| b
12:08:14 <MagneticDuck> ty
12:08:16 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
12:08:16 <lambdabot>    arising from a use...
12:08:19 <Taneb> Yeah, got me too
12:08:20 <jmcarthur> bah
12:08:23 <jmcarthur> > let a --| b = (+) in 4 --| 3
12:08:25 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
12:08:25 <lambdabot>    arising from a use...
12:08:30 <jmcarthur> lol
12:08:33 <MagneticDuck> xD
12:08:35 <jmcarthur> > let (--|) = (+) in 4 --| 3
12:08:37 <lambdabot>   7
12:08:47 <MagneticDuck> btw, what's the exact syntax?
12:09:00 <MagneticDuck> I put one comment before the function declaration?
12:09:05 <MagneticDuck> can I put more then one?
12:09:39 <jmcarthur> well, -- | just means that you're documenting the next thing below it
12:09:52 <jmcarthur> not sure what multiple doc comments would be interpreted as
12:10:08 <jmcarthur> if you need multiple lines you just continue the comment without using | anymore
12:10:24 <beaky> can you overload functions in Haskell/
12:10:26 <MagneticDuck> okay
12:10:29 <MagneticDuck> I'm reading the user guide
12:10:38 <jmcarthur> beaky: by using type classes, yes
12:11:19 * hackagebot Vec-Transform 1.1 - This package is obsolete (TobiasBexelius)
12:13:38 <merijn> beaky: No, but in practice it's not really a problem because polymorphism/typeclasses are usually better
12:13:48 <beaky> right
12:14:38 <merijn> For examples see the Num, Ord and Bounded typeclasses
12:14:51 <merijn> > maxBound :: Int
12:14:53 <lambdabot>   9223372036854775807
12:14:56 <merijn> > maxBound :: Char
12:14:57 <lambdabot>   '\1114111'
12:15:54 <adnam> Any reason cabal-install would not overwrite symlinks for old versions of executables in bin when i run `cabal install`? (On OS X, I only tried running it from the directory and not cabal install <pkg>, if that matters)
12:18:06 <Peaker> edwardk, here?
12:18:07 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
12:22:03 <JoeyA> Is FunPtr the appropriate type for representing a pointer to a WINAPI function?
12:22:15 <JoeyA> I want to test, at runtime, if GetTickCount64 is available.
12:22:43 <JoeyA> e.g. FunPtr (IO #{type ULONGLONG})
12:23:29 <k0ral> @hoogle IO FilePath -> FilePath -> IO FilePath
12:23:29 <lambdabot> System.Posix.Env getEnvDefault :: String -> String -> IO String
12:23:29 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
12:23:29 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
12:23:48 <Peaker> k0ral, what functionality do you need?
12:24:31 <JorgeArbusto> is CUT not equal to Greenwhich time?
12:24:36 <k0ral> Peaker: I want </> for IO FilePath as first argument
12:24:48 <geekosaur> JorgeArbusto, yes and no
12:24:52 <k0ral> Peaker: for now, I've written myself, I just wondered if it already existed
12:25:02 <sipa> he wants: m <//> p = m >>= \x -> x </> p
12:25:34 <k0ral> let >/> a b = (</> b) <$> a
12:25:41 <sipa> @pl \m p -> m >>= \x -> x </> p
12:25:41 <lambdabot> (. flip (</>)) . (>>=)
12:26:18 <edwardk> Peaker: yeah
12:26:19 <Peaker> k0ral, no need to make a function for every binding possible
12:26:44 <k0ral> Peaker: what do you mean "every binding" ?
12:26:54 <geekosaur> http://www.apparent-wind.com/gmt-explained.html
12:27:19 <Peaker> k0ral, any argument of any function could be wrapped in some functor/applicative/monad..  that's a combinatorial explosion of functions
12:27:26 <Peaker> edwardk, I was about to ask something then I realized you already answered it
12:27:35 <Peaker> edwardk, (in the @message and also in the previous chat)
12:27:45 <edwardk> k
12:27:58 <edwardk> ah =)
12:28:00 <k0ral> Peaker: so ?
12:28:17 <Peaker> k0ral, so it wouldn't make sense to define a new operator for every combination of such and every function in existence :)
12:28:31 <k0ral> Peaker: oh, you mean: why would I care doing it for IO ?
12:28:49 <Peaker> edwardk, though now I have a new question: I have a Rect type which contains a top-left and size vectors -- and I had a function to figure out the center. Though it might make sense to move the center (which would move the top-left, probably).  What is an elegant way to define this center lens?
12:29:13 <k0ral> Peaker: because there are file paths that are platform-dependent, and IO is the minimum to get that information
12:29:22 <k0ral> Peaker: I could lift to MonadIO
12:29:38 <intrigue> so -- i'm a bit confused. I'm readin gthe "roll your own IRC bot" tut and I'm not sure how we determine that we're in the Net monad. haskell.org/heskellwiki/Roll_your_own_IRC_bot
12:29:59 <intrigue> is it just because the type signature of those functions includes Net () that we can do things like "asks socket"?
12:30:00 <Peaker> edwardk, data Rect = Rect { _topLeft :: Vector2 R, _size :: Vector2 R } ; makeLens ''Rect ;    center (Rect topLeft size) = topLeft + size / 2
12:30:18 <edwardk> yep
12:30:19 <Peaker> edwardk, and:  atCenter = adjust topLeft
12:30:41 <edwardk> so moving the center should adjust the top left, so calculate the delta in the center and add it to the top left
12:31:08 <Peaker> k0ral, I mean that I much prefer (</> b) <$> a   or:  a <$$> (</> b)    over a specialized operator just to fuse these two operators
12:31:35 <Peaker> edwardk, right, what I said was only correct for translations, not scaling/etc
12:31:56 <edwardk> center f (Rect topLeft size) = (\newcenter -> Rect (topLeft + newcenter - newcenter) size) <$> f (topLeft + size / 2)
12:32:04 <edwardk> er
12:32:06 <edwardk> - center
12:32:07 <k0ral> Peaker: depends on how often you need to write it
12:32:31 <edwardk> center :: Simple Lens Rect Vector2
12:32:32 <Peaker> edwardk, ah, so the direct Functor encoding is the recommended way of defining such lens?
12:32:37 <edwardk> yeah
12:32:41 <Peaker> edwardk, cool, thanks
12:32:53 <edwardk> you can write it all with the combinators, but the functor is easy enough
12:33:45 <merijn> intrigue: The key bit is the do part
12:34:13 <edwardk> another way would be to define an isomorphism for your rectangle from its current rep to the rep that has a center stored
12:34:24 <merijn> intrigue: Do is really just syntactic sugar
12:34:41 <intrigue> merijn: yeah, I re-wrote it with >>= notation just to see that
12:34:42 <merijn> @undo do {h <- asks socket; foo h}
12:34:42 <lambdabot> asks socket >>= \ h -> foo h
12:34:49 <edwardk> data CenteredRect = CenteredRect { _center, size :: Vector2 }
12:35:00 <intrigue> merijn: but I guess im not sure where we ever pass the "Net" monad around anywhere
12:35:15 <merijn> intrigue: The Net annotation (and also the use of asks) let's the compiler infer that the appropriate monad to use for >>= must be the Net monad
12:35:17 <intrigue> merijn: the code says "asks socket" but how does it know which state to use?
12:35:25 <Peaker> edwardk, the Simple alias is really cute :)
12:35:27 <intrigue> merijn: ahhh
12:35:34 <edwardk> centerIso = iso (\(Rect tl s) -> …) (\(CenteredRect c s) -> …)
12:35:50 <edwardk> then centerOfRect = centeredIso.center
12:36:07 <edwardk> Peaker: =)
12:36:08 <intrigue> merijn: so it's that the function's type signature mentions it?
12:37:08 <edwardk> that would be the way to write it with the combinators without ever talking about the function the user supplies you
12:37:16 <merijn> intrigue: Since "(>>=) :: Monad m => m a -> (a -> m b) -> m b", the compiler needs to select the correct "m", this is determined by inferrence and also by the type signature you provide
12:37:59 <merijn> intrigue: You could leave out the signature if the compiler can infer from your use which monad it is (for example, a function you pass it to explicitly demands a "Net a" input)
12:38:06 <Peaker> edwardk, SimpleSetter = Simple Setter ?
12:38:11 <edwardk> yep
12:38:20 <Peaker> edwardk, isn't it superfluous?
12:38:20 <edwardk> but it avoids the need for the liberal type synonym
12:38:35 <edwardk> to use Simple sometimes you need LiberalTypeSynonyms on in your code
12:38:35 <intrigue> merijn: that makes sense -- Thanks =)
12:38:40 <merijn> intrigue: np
12:38:42 <edwardk> SImpleFoo lets you live without a pragma
12:38:55 <Peaker> edwardk, what's LiberalTypeSynonyms?
12:39:05 <edwardk> the extension that makes Simple work ;)
12:39:06 <intrigue> merijn: and I presume that is why we need to use liftIO on those functions that should be in the IO monad
12:39:28 <edwardk> it winds up not being needed in user code when you use a type alias that has a forall in it, but Setter does not ;)
12:39:41 <edwardk> (the fact that it works without that flag is arguably a bug)
12:39:47 <merijn> intrigue: Well, an IO function returns a value of "IO a", which is a type error inside the Net monad, because it expects "Net a"
12:39:58 <merijn> :t liftIO
12:39:59 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:40:39 <Peaker> edwardk, but it seems if I use Simple Setter a b <-- it will fully saturate all args?
12:41:07 <merijn> intrigue: The MonadIO typeclass is for Monads that are actually wrappers around IO (like Net presumably is), liftIO lets you turn some IO action into a Net action, using the fact that Net actually just wraps IO (and thus obeys all the requirements of IO)
12:41:13 <edwardk> the problem is 'Setter' is a type alias that isn't yet saturated until you put the a and b on it
12:41:20 * hackagebot Vec-Boolean 1.0.6 - Provides Boolean instances for the Vec package (TobiasBexelius)
12:41:21 <edwardk> so that is what the compiler will whine about
12:41:22 * hackagebot GPipe 1.4 - A functional graphics API for programmable GPUs (TobiasBexelius)
12:41:23 <intrigue> merijn: ah -- so we need to take an IO a and turn it into a Net a
12:41:33 <edwardk> if it was a data type it'd be silent
12:41:40 <merijn> intrigue: Yes, essentially you delegate the IO work to a monad that knows how to do IO
12:41:56 <edwardk> the liberal type synonym involved is the use of Setter without 4 of its arguments
12:42:06 <merijn> Basically "hey, could you do this IO for me?"
12:42:23 <Peaker> edwardk, I see
12:42:46 <intrigue> merijn: righteous.. thanks for your help :) I'm going to hack around with this for a while.
12:42:53 <merijn> intrigue: Good luck!
12:43:32 <Peaker> edwardk, what if I have 2 lens, and I want to compose their setters into a setter that sets both (no getter)?
12:43:47 <edwardk> its not a legal setter necessarily, sadly
12:43:57 <Peaker> what do you mean?
12:44:17 <edwardk> (_1 *** _1) %= (+1)
12:44:17 <Peaker> Because of potential overlap or such?
12:44:22 <edwardk> both try to set the same thing
12:44:28 <edwardk> yep
12:45:03 <edwardk> there is a 'bothLenses' combinator that works on disjoint domains in and tuples it into a pair
12:45:14 <edwardk> but i can't provide a combinator that is always safe
12:45:26 <Peaker> I see.. I could just use %~ twice and then use sets
12:45:35 <edwardk> *nods*
12:45:54 <edwardk> i'll eventually give you a $(compound [''_foo, ''_bar]) lens
12:46:34 <Peaker> cool, that would work here.. it's for applying a function on both topLeft and size
12:47:04 <edwardk> are they both vectors?
12:47:10 <edwardk> make a traversa ;)
12:47:22 <Peaker> traversa?
12:47:28 <MagneticDuck> is there such thing as too many haddock comments?
12:47:32 <jfischoff> is there a test-framework provider for smartcheck yet?
12:47:33 <edwardk> traverseVectors :: Simple Traversal Rect Vector2
12:47:34 <nand`> how are indexed traversals coming along?
12:47:42 <MagneticDuck> is there?
12:47:47 <edwardk> traverseVectors f (Rect tl s) = Rect <$> f tl <*> f s
12:48:20 <edwardk> traverseVectors += V 10 10 $ ...
12:48:22 <edwardk> or something
12:48:27 <edwardk> or do you need to have access to the tuple?
12:48:28 <Peaker> edwardk, ah, cool, thanks
12:48:51 <edwardk> of course odds that you want to work identically on both a size and position
12:48:56 <edwardk> a better one is
12:49:05 <edwardk> to make the traversal of the topleft and bottom left position
12:49:10 <edwardk> er bottom right
12:49:15 <edwardk> then you can put it back in like with center
12:49:30 <edwardk> then you are working with 2 points rather than 1 point and 1 vector
12:50:10 <Peaker> well, the current code uses the point/vector code, I think it's just for scaling
12:50:35 <Peaker> edwardk, the topleft/size representation makes translations of all points easy via translating topleft only
12:50:43 <edwardk> yes
12:50:48 <jfischoff> has anyone here used smart check?
12:50:52 <edwardk> just saying the traversal i just defined doesn't make much sense
12:51:02 <edwardk> because i can't think of any operations you can perform on it legally ;)
12:51:13 <edwardk> += V2 10 10
12:51:36 <Peaker> edwardk, scaling/multiplication makes some sense
12:51:45 <edwardk> ah
12:51:46 <Peaker> if the position is relative to some (0,0), at least
12:51:58 <Peaker> then they're both distances
12:52:11 <edwardk> it also works if they are homogenous, etc.
12:52:21 <Peaker> it's called "topLeftAndSize" so the senseless is advertised :)
12:52:27 <edwardk> heh
12:54:15 <augur> where is ski! D:
12:54:30 <Taneb> preflex: seen ski
12:54:30 <preflex>  ski was last seen on #haskell 6 days, 21 hours, 56 minutes and 52 seconds ago, saying: * ski should look more at how packages the work, ty for the reminder
12:54:47 <augur> yes i know when he was last seen
12:55:41 <Peaker> edwardk, the (.) composition of lens is opposite of those of previous libraries and of getters, isn't it?
12:55:51 <edwardk> most of them
12:55:51 <edwardk> yes
12:56:03 <Peaker> edwardk, ah, confused for a moment by the errors I was getting :)
12:56:05 <edwardk> foo^.bar.baz.quux is pretty unsurprising when read though
12:56:11 <edwardk> so it works out nicely
12:56:16 <MagneticDuck> I already installed regex-compat, but I don't have Text.Regex
12:56:17 <JorgeArbusto> > (map . map (+1)) [[1..10]]
12:56:18 <edwardk> and i couldn't flip it if i wanted to ;)
12:56:18 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
12:56:22 <MagneticDuck> any help?
12:56:28 <JorgeArbusto> > (map . (map (+1))) [[1..10]]
12:56:30 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
12:56:55 <JorgeArbusto> how do i compose map?
12:57:00 <MagneticDuck> hm?
12:57:05 <augur> JorgeArbusto: think of the types
12:57:06 <JorgeArbusto> > map (+1) [1..10]
12:57:08 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
12:57:14 <augur> yep
12:57:20 <augur> so now you want
12:57:23 <MagneticDuck> > map (map toLower) $ ["HI THERE", "THIS IS A TEST"]
12:57:24 <lambdabot>   ["hi there","this is a test"]
12:57:25 <augur> to do map (+1)
12:57:28 <MagneticDuck> that kind of thing?
12:57:30 <augur> to every element of the list
12:57:32 <JorgeArbusto> > (map (map (+1)) [[1..10]]
12:57:33 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:57:34 <augur> [[1..10]]
12:57:35 <augur> no?
12:57:39 <JorgeArbusto> > (map (map (+1))) [[1..10]]
12:57:40 <lambdabot>   [[2,3,4,5,6,7,8,9,10,11]]
12:57:46 <augur> there you go!
12:57:49 <augur> but its not composing map
12:57:51 <augur> its mapping map
12:57:55 <MagneticDuck> yeah
12:57:57 <JorgeArbusto> yes
12:58:14 <JorgeArbusto> ofc i cant compose sinc ehtye are not in order
12:58:19 <JorgeArbusto> but nested
12:58:39 <MagneticDuck> anyway
12:58:43 <MagneticDuck> I'm trying to get Text.Regex
12:58:50 <Peaker> edwardk, yeah, as long as it's not arbitrary, it's of course fine :)
12:58:51 <MagneticDuck> I installed regex-compat
12:58:52 <JorgeArbusto> ($) is just infix id?
12:58:59 <MagneticDuck> but it doesn't recognize the module
12:59:03 <JorgeArbusto> print id 12
12:59:04 <MagneticDuck> JorgeArbusto: no
12:59:06 <nobdraisentone> How can I perform IO action inside State monad `do' block?
12:59:10 <JorgeArbusto> > print id 12
12:59:12 <lambdabot>   Couldn't match expected type `t1 -> t'
12:59:12 <lambdabot>         against inferred type `GHC.T...
12:59:23 <JorgeArbusto> > print id (+1) 12
12:59:24 <lambdabot>   Couldn't match expected type `(a -> a) -> t1 -> t'
12:59:24 <lambdabot>         against inferred...
12:59:29 <JorgeArbusto> > print $ (+1) 12
12:59:30 <MagneticDuck> f ($) x == f g
12:59:30 <lambdabot>   <IO ()>
12:59:33 <MagneticDuck> what are you trying to do?
12:59:42 <MagneticDuck> (+1) $ id 1
12:59:46 <MagneticDuck> > (+1) $ id 1
12:59:48 <lambdabot>   2
12:59:55 <MagneticDuck> (+1) (id 1)
13:00:00 <MagneticDuck> > (+1) (id 1)
13:00:01 <MagneticDuck> x)
13:00:01 <lambdabot>   2
13:00:11 <MagneticDuck> arr
13:00:17 <MagneticDuck> f ($) x == f x
13:00:32 <MagneticDuck> it just for avoiding parenthesis
13:00:50 <Taneb> MagneticDuck, f $ x, you mean
13:00:51 <Iceland_jack> MagneticDuck: and application ;)
13:01:09 <MagneticDuck> > map toLower filter isAlpha "hi"
13:01:10 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
13:01:10 <lambdabot>         against inferred ty...
13:01:11 <MagneticDuck> doesnt work
13:01:23 <MagneticDuck> > map toLower . filter isAlpha $ "hi"
13:01:24 <Iceland_jack> > map ($ 10) [(*2), (*3)]
13:01:25 <MagneticDuck> does
13:01:26 <lambdabot>   [20,30]
13:01:27 <lambdabot>   "hi"
13:01:36 <MagneticDuck> yeah
13:01:39 <MagneticDuck> that too
13:01:55 <MagneticDuck> anyway
13:01:58 <MagneticDuck> MY question!
13:02:04 <MagneticDuck> I'm trying to get Text.Regex
13:02:10 <MagneticDuck> I installed regex-compat
13:02:17 <MagneticDuck> but the module Text.Regex isn't recognized
13:02:23 <Peaker> edwardk, hmm.. if adjust = (%~), why are the type signatures very different?
13:03:01 <edwardk> the isomorphism was a cute definitional trick for adjust
13:03:07 <edwardk> because you can 'from adjust fmap'
13:03:29 <MagneticDuck> aaaa, MY question!!
13:03:29 <edwardk> (%~) on the other hand probably wouldn't be partially applied like that
13:03:37 <MagneticDuck> Everyone's been avoiding answering it
13:03:38 <edwardk> from (%~) fmap is silly ;)
13:03:46 <edwardk> yes, we have
13:03:58 <MagneticDuck> is it poorly stated?
13:04:00 <MagneticDuck> obvious?
13:04:11 <MagneticDuck> not fun at all?
13:04:30 <geekosaur> MagneticDuck, regex-compat should be part of the Haskell Platform, you should not have needed to install it
13:04:37 <MagneticDuck> okay
13:04:43 <MagneticDuck> I have that all installed
13:04:50 <MagneticDuck> but Text.Regex isn't recognized
13:04:52 <edwardk> honestly i mostly said that for the snide comment, because i was distracted by 4 other conversations, sorry. i have no idea
13:04:54 <geekosaur> if you *did*install it then your problem is probably that now you have two of them and ghc is confused abouyt which one to yse
13:05:15 <MagneticDuck> mm
13:05:18 <MagneticDuck> I didn't reinstall it
13:05:33 <geekosaur> which will lead to ghc saying it can;t use Text.Regex because it doesn't know which one to use.  otherwise, see if "ghc-pkg check" reports any problems
13:05:49 <kuribas> What's this editor?  http://www.youtube.com/watch?v=ScS8Q32lMxA
13:06:26 <MagneticDuck> looks like vim of some sort
13:06:30 <xORioN63> vim
13:06:42 <Peaker> edwardk, I see -- though it would be nice to be able to see the correspondence between the various functions there
13:06:53 <Peaker> edwardk, I am searching for aliases via the type, and can't see them
13:07:00 <edwardk> well, if i can get monadic setters working the isomorphism will die ;)
13:07:32 <xORioN63> MacVim, actually
13:07:50 <edwardk> many of those cute isomorphisms are probably going to be ripped out because they aren't robust in the presence of me adding parameters to the type aliases
13:08:18 <lapinferoce> or maybe sublime text
13:08:35 <kuribas> Oh, I see.  He was doing some editing of several lines at once, which I found interesting.
13:08:45 <edwardk> i've been meaning to take a pass and make sure that i have named all the aliases at each type
13:09:06 <edwardk> er i mean put in adjust = mapOf = (%~) as a comment right below it
13:09:10 <edwardk> etc
13:09:22 <kuribas> at about 4:35
13:09:42 <xORioN63> there are a few plugins like that
13:10:26 <xORioN63> if you're willing to learn, either vim or emacs, will give you god-like editing powers
13:10:31 <Peaker> edwardk, if my field names are prefixed with _ for the lens, is it customary to export them for an ordinary buildup of a record value?
13:10:32 <MagneticDuck> vim
13:10:37 <MagneticDuck> is deh best
13:10:39 <MagneticDuck> (imo)
13:10:41 <MagneticDuck> :P
13:10:42 <kuribas> xORioN63: I use emacs :)
13:10:44 <Peaker> edwardk, or is there some nice way to do it?
13:10:51 <edwardk> Peaker: honestly i'm not sure
13:10:52 <xORioN63> MagneticDuck: I agree with you
13:10:59 <mekeor> kuribas: YAY!
13:11:00 <edwardk> i don't tend to export them
13:11:06 <edwardk> i just export Foo(Foo)
13:11:09 <MagneticDuck> also, lots of IDEs (including eclipseFP which I use and love) have vi wrappers
13:11:12 <MagneticDuck> so if you learn vim
13:11:14 <edwardk> and put them on positionally
13:11:23 <MagneticDuck> you don't have to stick to that boring interface of gvim or something
13:11:36 <MagneticDuck> you can use a big IDE, but edit your code that much faster
13:11:44 <MagneticDuck> emacs is a completely different beast though
13:12:07 <xORioN63> well, I kinda hate eclipse
13:12:20 <MagneticDuck> it's nice to have a full IDE for haskell
13:12:21 <Peaker> edwardk, Rect topLeft size   is a bit dangerous/error-prone, it's nicer to see: topLeft=topLeft, size=size (so the semantics of the vectors are visible)
13:12:22 <kuribas> I couldn't live without automatic indentation.  I don't know how well it works in vi though...
13:12:23 <MagneticDuck> I'm fine with it
13:12:31 <belgin> kuribas: it's vim with solarized dark terminal theme
13:12:36 <xORioN63> If you take your time to make a good environment for each language in vim, it's amazing
13:12:47 <edwardk> *nods*
13:12:51 <edwardk> then export the _foo's
13:12:58 <edwardk> and you can at least write something sane
13:13:01 <MagneticDuck> well, try eclipse too kuribas
13:13:10 <xORioN63> kuribas: you can use automatic indentation on vim
13:13:23 <edwardk> you can always use something like
13:13:32 <MagneticDuck> if you're looking for a good ol' IDE with refactoring and lots of windows and stuff, try it
13:13:40 <kuribas> I don't think I would change, because I am already too familiar with emacs...
13:13:51 <MagneticDuck> oh
13:13:55 <jmcarthur> i use emacs with evil-mode
13:14:00 <xORioN63> ahaha
13:14:01 <edwardk> instance Default Rect where def = Rect (0,0) (0,0);   then you can use lenses to update it
13:14:35 <xORioN63> emacs has the ability of secretly being a full featured OS
13:14:51 <xORioN63> fully*
13:15:01 <jmcarthur> not much of a secret. that's basically how most people end up using it
13:15:17 <edwardk> topLeft.x .~ 10 $ topRight.y .~ 20 $ width .~ 10 $ height .~ 100 $ def
13:15:17 <jmcarthur> in fact, the only decent text editor i've found for emacs is evil-mode
13:15:32 <edwardk> not super pretty but it spreads across multiple lines well
13:15:36 <kuribas> xORioN63: haha, I am reading this in emacs :)
13:16:08 <MagneticDuck> oh, my Text.Regex problem just magically went away
13:16:29 <MagneticDuck> darned buildwrapper ~_~
13:17:43 <MagneticDuck> jmcarthur: yeah, vi key mapping are the best ever
13:17:52 <edwardk> myRect = foldr (.) def [topLeft.x .~ 10, topRight,y .~ 20, width .~ 10, height .~ 100]   ;)
13:17:53 <MagneticDuck> I can't use an IDE if it doesn't have some sort of vi wrapper
13:19:21 <kuribas> I find the vi emulation modes in emacs a bit awkward, they don't seem to work nicely with the rest of emacs.
13:19:34 <kuribas> (the same with cua-mode)
13:19:37 <xORioN63> MagneticDuck: Why not just Vim? It now supports Python programming
13:20:17 <MagneticDuck> xORioN63: because I'd like an IDE. Something graphical... I know vim can do a lot.. but eclipse is fine too
13:20:47 <jmcarthur> kuribas: in what way do they behave badly with other emacs features? i was afraid of that happening, too, but i've never had a problem as long as i'm willing to occasionally do some things in insert mode
13:23:10 <kuribas> jmcarthur: It's just that some keys don't seem to work in vim mode.  I didn't mean it would mess things up though...
13:23:29 <Ralith> kuribas: rebind them?
13:23:53 <kuribas> But it is a long time ago I tried it.  I am comfortable with emacs bindings.
13:25:49 <nobdraisentone> `filter :: (a -> Bool) -> Seq a -> Seq a'. How can I make filterM to be able to use (a → IO Bool) function here?
13:26:32 <jmcarthur> @src mapM
13:26:33 <lambdabot> mapM f as = sequence (map f as)
13:26:54 <jmcarthur> :t \f -> sequence . filter f
13:26:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => (m a -> Bool) -> [m a] -> m [a]
13:27:12 <jmcarthur> err
13:27:27 <jmcarthur> that is of course incorrect
13:28:10 <merijn> nobdraisentone: I think there's something like that in the monad-loops package?
13:28:24 <jmcarthur> :t filterM
13:28:26 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:28:30 <jmcarthur> @src filter<
13:28:31 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:28:33 <jmcarthur> @src filterM
13:28:33 <lambdabot> Source not found. I feel much better now.
13:28:41 <jmcarthur> i think that lives in Control.Monad
13:29:07 <merijn> nobdraisentone: "dropWhileM :: Monad m => (a -> m Bool) -> [a] -> m [a]"?
13:29:10 <jmcarthur> just have to adapt it to Seq
13:29:31 <merijn> oh wait
13:29:36 <jmcarthur> dropWhileM is not the same as filterM ;)
13:29:36 <merijn> That's not filter, obviously
13:29:43 <nobdraisentone> Uguu
13:31:28 <merijn> Wait, doesn't filterM already support using (a -> IO Bool) functions?
13:31:32 <nobdraisentone> Could `(a → IO Bool) → Seq a → Seq a' be formulate with `(a → Bool) → Seq a → Seq a'?
13:31:48 <jmcarthur> this is about Seq vs. [], i think
13:31:55 <jmcarthur> filterM is for lists
13:31:58 <merijn> hmm
13:32:12 <merijn> Maybe something based on traversable?
13:32:25 <nobdraisentone> Or foldable
13:32:30 <jmcarthur> seems like it would have to be a further specialization of traversable, to me
13:32:45 <merijn> I think your only options willbe "(a -> IO Bool) -> Seq a -> IO (Seq a)", btw
13:32:51 <jmcarthur> traversable is required for mapM, and filterM seems to require even more specificity
13:34:13 <jmcarthur> needs something like   f (Maybe a) -> f a
13:34:28 <jmcarthur> and that seems unfortunately generic
13:34:37 <jmcarthur> *specific
13:34:56 <jmcarthur> how about just using bind?
13:35:03 <jmcarthur> not sure if Seq has a monad instance, but it probably should
13:35:26 <jmcarthur> you still have to sequence the result, but it should get you there
13:35:48 <jmcarthur> it seems to have a monad instance!
13:36:02 <Cale> The bind for Seq won't let you do IO obviously.
13:36:15 <jmcarthur> :t \f xs -> Data.Traversable.sequence $ xs >>= f
13:36:17 <Cale> Unless I don't understand what you mean...
13:36:17 <lambdabot> forall (t :: * -> *) (m :: * -> *) a a1. (Data.Traversable.Traversable t, Monad m, Monad t) => (a1 -> t (m a)) -> t a1 -> m (t a)
13:36:21 <Cale> ah
13:37:01 <jmcarthur> Cale: i mean concatMap-like functionality instead of mapMaybes-like functionality
13:37:23 <jmcarthur> i think i still got something wrong
13:37:55 <DMcGill> is there an "insertWith" for Data
13:37:58 <DMcGill> Data.Set I mean
13:39:22 <Peaker> edwardk, thanks, sounds good.  .~   is a weird name for "set", isn't it?
13:43:22 <roconnor> Peaker: lens-families is now using <~ :D
13:44:33 <Peaker> is lens-families an extension of lens? Compatible with it?
13:44:48 <roconnor> Peaker: they are (currently) compatible for lenses
13:45:12 <roconnor> right now they only support lenses, not traversable or foldable
13:46:35 <donri> i just realized ghc has smart error reporting for passing too many args to a function
13:46:51 <Taneb> > (+) 1 2 3
13:46:52 <lambdabot>   3
13:47:02 <Taneb> > id () ()
13:47:03 <lambdabot>   Couldn't match expected type `() -> t' against inferred type `()'
13:47:30 <Taneb> :(
13:47:52 <donri> > map (+1) [1,2,3] [4,5,6]
13:47:54 <lambdabot>   Couldn't match expected type `[t1] -> t'
13:47:54 <lambdabot>         against inferred type `[a]'
13:47:57 <danil> only when the return type of the function isn't a type variable, otherwise you might have intended it to get instantiated to a function type
13:48:03 <donri> that's not the error i get in ghci
13:48:28 <monochrom> it is also not the same ghc version to begin with
13:48:50 <monochrom> also the "smart" hints come at the end, not at the beginning
13:51:22 <merijn> Peaker: AFAICT lens is supposed to be the lens-package to end all lens packages
13:53:35 <diagoras> greetings, fellow haskellers. may I ask, please, if anyone knows sane way to interactively test large collection of "ReaderT over IO" monadic functions in GHCi? it is terribly frustrating explicitly to pass around state to read in each call :-(
13:54:25 <Peaker> diagoras, can you paste a portion showing the frustrating part?
13:54:45 <merijn> diagoras: Define a simple wrapper that takes a ReaderT and runs with whatever initial state you want?
13:55:00 <jmcarthur> diagoras: best i can think of is to define a function in ghci that goes ahead and applied runReaderT with a predetermined input for you, so you just say "run $ myAction"
13:55:10 <jmcarthur> *applies
13:55:12 <jfischoff> also ghci isn't the best test bed when you have to initialize a bunch of state
13:55:38 <jfischoff> because every time you reload it goes away
13:57:13 <Zhan> @help
13:57:13 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:57:18 <diagoras> Peaker: I mean starting every line with "runReaderT my_local_state_var"
13:57:23 <Zhan> @help unmtl
13:57:24 <lambdabot> unroll mtl monads
13:58:16 <Zhan> @unmtl MaybeT (State s) a
13:58:16 <lambdabot> s -> (Maybe a, s)
13:58:37 <Zhan> @unmtl StateT s Maybe a
13:58:38 <lambdabot> s -> Maybe (a, s)
13:58:53 <Peaker> diagoras, alias it?
13:59:10 <donri> let foo' = runReaderT foo env
13:59:10 <jmcarthur> diagoras: let run = runReaderT my_local_state_var
13:59:18 <Peaker> diagoras, if you have some more boilerplate wrapping each test case, why not compose all the boilerplate into a "runTest"?
13:59:54 <Zhan> @unmtl EitherT e (State s) a
13:59:55 <lambdabot> EitherT e (State s) a
14:00:29 <donri> @unmtl ErrorT e (State s) a
14:00:30 <lambdabot> s -> (Either e a, s)
14:00:50 <Zhan> thanks donri
14:00:52 * hackagebot lenses 0.1.5 - Simple Functional Lenses (JobVranish)
14:01:00 <donri> oh dear another lens package?
14:01:32 <Zhan> @unmtl State s (ErrorT e) a
14:01:32 <lambdabot> Plugin `unmtl' failed with: `ErrorT e' is not applied to enough arguments, giving `/\A B. A (Either e B)'
14:01:39 <Zhan> @unmtl StateT s (Error e) a
14:01:40 <lambdabot> s -> Error e (a, s)
14:03:37 <JorgeArbusto> > Just 5 >>= return id (+1)
14:03:38 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b))
14:03:38 <lambdabot>    arising from a use of...
14:03:46 <JorgeArbusto> > Just 5 >>= return $ (+1)
14:03:47 <lambdabot>   Couldn't match expected type `a -> a1'
14:03:48 <lambdabot>         against inferred type `Data....
14:04:02 <JorgeArbusto> > Just 5 >>= \r -> return $ r + 1
14:04:03 <lambdabot>   Just 6
14:04:33 <diagoras> thank you, people - I just was curious if may be it's possible to somehow automate out this this "runTest $ " things completely :-) but one word is still better then two - idea to just "let" it into one word felt out of my mind somehow
14:05:50 <Zhan> > Just 5 >>= liftM (+1)
14:05:52 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
14:05:52 <lambdabot>    arising from a use of...
14:07:41 <Ralith> Zhan: you don't need >>= there
14:08:20 <Zhan> > liftM (+1) (Just 5)
14:08:22 <lambdabot>   Just 6
14:08:25 <Zhan> I see
14:10:08 <avpx> @type fmap
14:10:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:10:10 <DMcGill> how does (Set.toList . Set.fromList) compare to nub?
14:10:13 <avpx> @type liftM
14:10:14 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:10:50 <Zhan> > Just 5 >>= return . (+1)
14:10:53 <lambdabot>   Just 6
14:11:03 <DMcGill> > (+1) <$> Just 5
14:11:05 <lambdabot>   Just 6
14:11:11 <avpx> I honestly think that >>= is confusing in Haskell because composition is generally done right-to-left
14:11:17 <DMcGill> Zhan: don't use x >>= return . f
14:11:27 <geekosaur> DMcGill, probably faster, since Set has an Ord behind it
14:11:29 <DMcGill> use liftM or fmap or <$> instead
14:11:37 <Zhan> yes yes, just experimenting :)
14:11:40 <geekosaur> maybe nub is faster on short lists
14:12:26 <otters> nearly everything is faster on short lists
14:12:37 <typoclass> avpx: i think you're onto something
14:12:41 <DMcGill> except for those things that aren't of course
14:12:56 <DMcGill> avpx: =<<
14:13:07 <avpx> Well, yes.
14:13:13 <avpx> I'm aware that it exists, I just think it's less confusing.
14:13:49 <c_wraith> DMcGill: first off, it has an Ord requirement, where nub only needs Eq.
14:14:45 <mekeor> when i type "haddock", i get "/usr/local/bin/haddock: 10: exec: /usr/local/lib/ghc-7.4.1/haddock: not found"(, similar to the issue with runhaskell/runghc which i solved by symlinking to /usr/bin/runghc manually). how can i solve this problem? (yes, i'm using ghc-7.4.1.)
14:15:10 <typoclass> DMcGill: i don't think they're quite on the same level. >>= is the prominent thing that's being taught everywhere. =<< seems like an afterthought to me
14:16:03 <avpx> typoclass: That's what I'm talking about. I mean, I think that the mathematical convention of right-to-left composition is hard to follow in general, but what's worse than that is having monadic code using compositions of monadic functions (right-to-left) and bindings (left-to-right)
14:17:10 <typoclass> mekeor: could you verify if /usr/local/lib/ghc-7.4.1/haddock exists? e.g. on my system, it's in /usr/lib instead of /usr/local/lib
14:18:05 <c_wraith> avpx: is f(g(x)) hard to follow?  if it isn't, why is (f . g)(x) hard to follow, having all the important symbols in the exact same order?
14:18:15 <typoclass> avpx: all true. (although this might be a slippery slope that ends with writing do blocks from bottom to top ;-) )
14:18:26 <mekeor> typoclass: ah! that's it. /usr/local/lib/ghc-7.4.1/haddock doesn't exist but /usr/local/lib/haddock-ghc-7.4.1 does. i'll just create a symlink again, thanks.
14:19:04 <avpx> c_wraith: I understand that, but we also prefer to read left to right.
14:19:14 <mekeor> typoclass: wait, even /usr/local/bin/haddock exists… fine.
14:19:16 <avpx> c_wraith: When I have a function that is a composition of many other functions, I don't like following it backwards
14:19:58 <avpx> You do have a point though.
14:20:00 <c_wraith> avpx: then follow it forwards.  It *is* haskell, after all.  f . g only cares about g if f decides to
14:20:40 <avpx> c_wraith: It's not hugely bothersome. My main point is that having two different conventions is the worst.
14:20:52 * hackagebot time-recurrence 0.9.1 - Generate recurring dates. (ChrisHeller)
14:20:59 <jmcarthur> f . g   *is* left-to-right
14:21:06 <typoclass> c_wraith: you have a point, but f(g(x)) is still conceptually different from (f . g)(x). the first is a function application and then another one. the second form creates a new function that is the composition of f and g, and then applies that one function. at least i think of it that way
14:21:20 <mekeor> typoclass: i did "sudo ln -s /usr/local/bin/ /usr/local/lib/ghc-7.4.1" which solves my problem ultimatively.
14:22:49 <typoclass> mekeor: it all sounds a bit weird that you have to manually create those symlinks :-/ is something muddled on your system? like you installed ghc in /usr and later another one in /usr/local?
14:23:40 <mekeor> typoclass: i just did "apt-get install haskell-platform" on my debian. but this is debian unstable, so, it's not much surprising that things are unstabe ;) :)
14:26:01 <JorgeArbusto> Usain Bolt!
14:26:19 <mekeor> JorgeArbusto: again? did he win again?
14:26:27 <typoclass> avpx: i just realized -- shell pipes are the other way as well. "cat ... | grep ... | wc -l". it does seem very natural, at least in that context
14:29:07 * typoclass sneaks into the ghc source code and renames (>>=) to (|)
14:32:30 <EvanR> \
14:34:07 <EvanR> > [1,2,3] \ [2]
14:34:09 <lambdabot>   <no location info>: parse error on input `\'
14:34:17 <EvanR> > [1,2,3] \\ [2]
14:34:19 <lambdabot>   [1,3]
14:34:30 <EvanR> hrm
14:43:02 <EvanR> for a caf of the form foo :: Text, foo = fromString "bar", i can see how this would be evaluated at most once
14:43:34 <EvanR> but what about foo :: IsString a => a, foo = fromString "bar"
14:44:06 <shachaf> That'll be evaluated more than once.
14:44:15 <shachaf> Even if you use it as the same type each time.
14:44:22 <EvanR> lovely
14:44:59 <shachaf> foo turns into a function :: (String -> a) -> a
14:45:14 <EvanR> now i see how cafs arent necessarily constants
14:45:53 <EvanR> (String -> a) -> a wouldnt work as a type for fromString "bar"
14:47:44 <shachaf> No, but it would work as a type for foo = \fromString -> fromString "bar"
14:48:00 <shachaf> Which is what foo is probably being compiled to.
14:48:47 <EvanR> cant this be optimized
14:49:18 <shachaf> To what?
14:49:44 <EvanR> a memoized set of values one for each instance
14:49:56 <danil> there aren't necessarily a finite number of instances
14:50:14 <EvanR> at any given time a finite number of instances were used at runtime
14:50:15 <shachaf> EvanR: Depending on how you use foo, it may well be optimized.
14:52:51 <sqrt> Does anyone in here use eclipse for haskell? I can't figure out how to load my module.
14:57:14 <merijn> Is there a name/paradigm for making heavy use of combinators while programming? Combinatorial programming seems wrong and I can't think of anything better
14:58:12 <donri> merijn: "OMGEDSL"
14:58:45 <merijn> donri: Don't think I can get away with that :)
14:58:54 <EvanR> pointless programming
14:58:56 <merijn> Also, EDSL is already more advanced then I'm thinking
14:59:22 <merijn> When I say combinators I include such trivial/simple ideas as map/fold/filter
15:00:09 <donri> functional? :p
15:00:20 <EvanR> merijn: its called chaining in javascript/ruby etc
15:00:50 <merijn> hmm, maybe higher-order programming is a better term
15:00:55 <typoclass> merijn: "functions all the way down, until you hit the turtles programming"
15:00:58 <Ralith> I think 'functional' fits
15:01:01 <sipa> merijn: compositional
15:01:02 <sipa> ?
15:01:06 <Ralith> sipa's is good.
15:01:10 <Ralith> higher-order isn't always appropriate
15:01:12 <EvanR> a . b x . c . d y
15:01:14 <merijn> sipa: Yeah, that's also a good one
15:01:25 <typoclass> but yeah, functional programming seems to capture it
15:01:38 <merijn> typoclass: Functional programming is more specific than I was looking for
15:02:08 <JorgeArbusto> what would you call this function:
15:02:56 <JorgeArbusto> > let f x = if (length $ show x) == 1 then "0" ++ (show x) else show x in (f 1, f 12)
15:02:57 <merijn> Functional programming is very well suited to a compositional style, yes (Which is actually the argument I want to make). But functional programming I consider more specific
15:02:58 <lambdabot>   ("01","12")
15:03:20 <merijn> JorgeArbusto: prettyPrint?
15:03:23 <EvanR> JorgeArbusto: thats not a function
15:03:41 <yitz> merijn: i usually call it "combinator style", though i agree that sipa's is good
15:04:04 <typoclass> JorgeArbusto: "pad". the leading 0 is often called padding
15:04:13 <EvanR> 10000 lotus blossom style
15:04:31 <merijn> yitz,sipa,EvanR,the rest: I think I'll go with compositional, thanks for the brainstorm!
15:04:32 <sipa> merijn: depending on how far you push it, you could call it pointless programming too __:D
15:04:52 <sipa> yw
15:05:03 <yitz> EvanR: combinator style is different than pointfree. pointfree does often come up in combinator style, but only when it makes the code more clear.
15:05:35 <sipa> i was joking :)
15:05:48 <sipa> i agree they are quite different
15:06:17 <danil> historically I think the term "applicative style" was used (in ISWIM and SASL)
15:10:00 <EvanR> question about recursive name bindings
15:10:06 <EvanR> show = show . compile
15:10:13 <EvanR> looks recursive
15:10:15 <EvanR> but
15:10:25 <EvanR> in an instance does it work differently
15:11:10 <EvanR> do i need to use qualification to use the other show instance
15:11:19 <cleantc> is desugaring of guards in function bindings the same desugaring of guards in case alternatives?
15:12:41 <danil> EvanR: names defined by a class are bound once, with a (constrained) polymorphic type, when the class is defined.  Even inside an instance declaration (or an equation for "show" in an instance declaration) the polymorphic version is the one in scope
15:13:00 <EvanR> oh
15:13:29 <jfischoff> @tell roconnor: really digging Multiplate
15:13:30 <lambdabot> Consider it noted.
15:14:11 <shachaf> jfischoff: Unfortunately that : won't work.
15:14:18 <jfischoff> oh
15:15:07 <jfischoff> should it be: tell roconnor really digging ...
15:15:47 <nobdraisentone> Is there some function to add value to a list if it isJust? :: Maybe a -> [a] -> [a]
15:16:08 <jfischoff> @tell roconnor really digging Multiplate
15:16:09 <lambdabot> Consider it noted.
15:16:43 <donri> > maybeToList (Just 1) ++ [2,3]
15:16:46 <lambdabot>   [1,2,3]
15:16:57 <nobdraisentone> donri: thanks
15:17:29 <shachaf> > maybe id (:) (Just 1) [2,3]
15:17:30 <lambdabot>   [1,2,3]
15:17:31 <donri> > catMaybes [Just 1, Nothing, Just 3]
15:17:32 <lambdabot>   [1,3]
15:17:36 <shachaf> > maybe id (:) Nothing [2,3]
15:17:37 <lambdabot>   [2,3]
15:18:43 <donri> oh yea that's better
15:20:11 <cleantc>  is it always true that \p1 p2 p3 -> e     =   \p1 -> \p2 -> \p3 -> e ? is there any extension or restriction (like monomorphism restriction) that violates this rule?
15:21:33 <EvanR> :t maybeToList
15:21:35 <lambdabot> forall a. Maybe a -> [a]
15:21:39 <EvanR> wheres that defined
15:22:15 <typoclass> EvanR: Data.Maybe
15:22:22 <yitz> cleantc: those are equivalent semantically. i'm not sure if there aren't occasions where ghc might treat them differently w.r.t. optimizationthough.
15:22:58 <typoclass> Data.Maybe is a module full of odd names :)
15:23:41 <EvanR> > listToMaybe [4,3,undefined]
15:23:42 <lambdabot>   Just 4
15:23:53 <EvanR> thats a funny name
15:24:01 <donri> yea it's more like, safeHead
15:24:30 <cleantc> yitz: f x = show x   =\=   f = \x -> show x , so that makes me get worried about other apparent semantically equivalent expressions
15:25:45 <typoclass> donri: exactly. and i think catMaybes could be named "justs", because Data.Either has "rights" and "lefts"
15:25:56 <donri> cleantc: but those aren't expressions
15:26:03 <typoclass> and i wonder what a cute name for maybeToList would be
15:26:07 <donri> typoclass: agreed
15:26:13 <EvanR> the lefts what their justs rights
15:26:18 <EvanR> want*
15:26:49 <donri> also we should have a nothings = const []
15:26:54 <EvanR> typoclass: toList
15:27:10 <avpx> cleantc: I'd venture that they are equivalent taking into account the monomorphism restriction, seeing as how they both involve simple pattern bindings for all arguments
15:27:12 <donri> > Data.Foldable.toList (Just 1)
15:27:14 <lambdabot>   [1]
15:27:20 <gertc> do {exe1;exe2} how can you tell haskell to continue exe2 and not wait for exe1 to finish?
15:27:53 <avpx> cleantc: And no explicit type signature is given, I should say
15:28:00 <danil> cleantc: the MR is the biggest wart of that sort -- it keeps bindings that look like constants from being generalized (and hence being evaluated more than once at different types)
15:28:05 <merijn> gertc: You probably want to use threads to run them in parallel?
15:28:10 <gertc> more specifix exe1 is websocket exe2 is webserver
15:28:15 <shachaf> gertc: Yes, run exe1 in a thread.
15:28:28 <merijn> gertc: forkIO lets you spawn an IO action in a separate (lightweight haskell) thread
15:28:36 <gertc> sounds complicated :)
15:28:47 <shachaf> You might want to use something like "spawn" or "async" to wait for its result.
15:28:51 <avpx> http://www.haskell.org/onlinereport/decls.html <-- this is where the monomorphism restriction is explained and motivated
15:28:52 <shachaf> gertc: No, threads are really easy.
15:28:54 <EvanR> do {forkIO exe1; exe2}
15:29:00 <merijn> gertc: It's pretty simple. "forkIO exe1" would be enough :p
15:29:07 <shachaf> The simplest case is what EvanR said.
15:29:12 <gertc> testing just as sec :)
15:29:16 <typoclass> gertc: it's not really complicated. you import one thing and you do "forkIO whatever" :)
15:29:21 <shachaf> Except that way you have no way to wait for the exe1 thread to finish.
15:29:28 <merijn> shachaf: #haskell is the only place where anyone can get away with saying "threads are really easy" :p
15:29:40 <shachaf> So you might want something like do { wait <- exe1; exe2; wait; ... } or something
15:29:53 <shachaf> merijn: They're easy to start!
15:29:54 <EvanR> merijn: yeah but i can get away with pthreads are hard anywhere
15:30:38 <shachaf> merijn: In Ruby you could say Thread.new { exe1 }; exe2;, if you wanted. As long as they're completely independent it'd work.
15:31:02 <cleantc> is -XNoMonomorphismRestriction is on, except the performance penalty, is there any other side effects?
15:31:14 <merijn> gertc: If you want to wait for a thread to finish you probably want to use an MVar. Your thread writes to the MVar when it's finished and your main thread reads from it (and thus blocks until the new thread finishes and writes to that mvar)
15:31:29 <cleantc> *if
15:31:32 <merijn> cleantc: Shouldn't be any other effects, and it is only a potential performance penalty
15:31:58 <avpx> Yeah, the monomorphism restriction is really  there to be conservative about potentially repeating computations.
15:32:13 <danil> cleantc: there's no actual performance penalty -- you can run the same code with it and without it and it does the same thing.  You just have to write more type signatures with the MR on because it makes ghc refuse to infer some types
15:32:24 <shachaf> merijn: Or spawn/async!
15:32:46 <shachaf> http://hackage.haskell.org/packages/archive/spawn/latest/doc/html/Control-Concurrent-Spawn.html / http://hackage.haskell.org/packages/archive/async/latest/doc/html/Control-Concurrent-Async.html
15:32:54 <mekeor> i totally messed things up. my cabal hangs up at "Configuring haddock-2.10.0..." when i type "cabal install haddock". (i previsously did "ghc-pkg unregister haddock". and before that, i manually created some symlinks because "cabal haddock" didn't work because cabal couldn't find haddock.) (i'm using debian (unstable) and i installed the haskell-platform (including cabal) through my package-manager.)
15:32:59 <mekeor> HELP.
15:33:31 <mekeor> why does it hang up?
15:33:38 <avpx> danil: I had an issue with this once where it was impossible to explicitly name my types without ScopedTypeVariables
15:34:12 <avpx> I still chose ScopedTypeVariables over NoMonomorphismRestriction, though. I think it's better practice to leave it on.
15:34:56 <cleantc> according to http://www.haskell.org/haskellwiki/Monomorphism_restriction: Basically, it solves one practical problem (without the restriction, there would be some ambiguous types) ...
15:35:00 <danil> avpx: you can also turn them into function bindings by adding a spurious () argument
15:35:02 <cleantc> examples?
15:35:04 <mekeor> I'd appreciate ANY ideas/suggestions/suspections/advices/opinions/….
15:35:54 <cleantc> how can eta reduction introduce ambiguity?
15:36:52 <merijn> cleantc: If I have "foo = [1..100]" then you'd want it to evaluate the list only once and reuse, but since it has type "Num a => [a]" the compiler would have to make it a function and every use of foo would have to recompute it
15:37:51 <cleantc> merijn: I dont see the connection to type ambiguity
15:38:21 <merijn> cleantc: Instead, if the compiler sees you use "foo" in a function expecting [Int] it will restrict foo to be type [Int], rather than "Num a => [a]", the result is foo is only computed once. But, foo is now a lot less polymorphic then you as a programmer would expect
15:39:05 <merijn> Disabling MMR, lets foo still infer foo as "Num a => [a]", the other solution would be to explicitly annotate foo to be "Num a => [a]"
15:39:24 <merijn> fingers crossed that I didn't botch the explanation
15:39:28 <danil> cleantc: that's just someone confused on the wiki; there's no ambiguity problem, just potential unexpected non-sharing
15:40:04 <merijn> cleantc: So basically, the performance penalty of disabling MMR in my example is that foo gets recomputed on every use
15:40:24 <shachaf> danil: Well, sometimes the DMR solves ambiguity problems too. But that's not what it's for.
15:40:44 <cleantc> shachaf: examples please
15:40:45 <applicative> mekeor didn't  haddock come with the distro's haskell platform?
15:41:05 <typoclass> shachaf: do these packages offer some kind of "waitForAll" that you can call on the main thread? i couldn't find it so far
15:41:37 <shachaf> typoclass: What, with a global variable that stores everything you've spawned?
15:41:46 <mekeor> applicative: no. (this is what came with my distro's haskell-pf: <http://codepad.org/Z39kvmhg>.)
15:43:20 <typoclass> shachaf: yeah, guess so :-/ basically an implementation of the example code in the haddock page for Control.Concurrent. i know i have copy-pasted it more than once ...
15:43:37 <applicative> mekoer, that looks like a list of libraries, but haddock is an executable like happy and alex
15:43:51 <applicative> hi farooq
15:43:52 <shachaf> typoclass: What example code?
15:44:00 <shachaf> Oh, I see.
15:44:08 <gertc> the forkIO exe1 worked the run <- exe1 still was holding exe2
15:44:35 <shachaf> typoclass: Not that I know of.
15:45:23 <mekeor> applicative: erm. i used "ghc-pkg list" and pasted the global database. "ghc-pkg list" "List[s] registered packages in the global database" (extract from the documentation).
15:45:54 <applicative> mekeor: yes, my point was that haddock doesnt install a library, just an executable.
15:46:32 <applicative> mekeor: I was wondering whether, e.g. it is somewhere not in path.
15:46:36 <mekeor> applicative: yeah, and my point is that ghc-pkg would list haddock if it was installed by my package-manager altough it's a binary.
15:46:44 <mekeor> applicative: hm?
15:46:49 <mekeor> oh, no.
15:46:58 <mekeor> no, no. that's not the problem.
15:47:37 <applicative> http://packages.debian.org/sid/haskell-platform includes haddock, happy alex et al they are part of the definition of the Platform
15:47:40 <hpaste> danil pasted “monomorphism restriction ambiguity example” at http://hpaste.org/72666
15:47:54 <mekeor> applicative: oh.
15:47:56 <mekeor> oO
15:48:18 <applicative> mekeor: but in any case you ought to be able to build it yourself, so something else is wrong
15:49:05 <gertc> acid-state or redis?
15:49:37 <cleantc> hmmm
15:51:24 <cleantc> so transformation f p1 p2= e to f = \p1 -> \p2 -> e makes typechecking unsound!
15:52:00 <danil> cleantc: so in cases where inferring the most general type causes an ambiguous constraint, the MMR can apply and (basically by accident) resolve things
15:52:16 <gertc> which one wil i be pulling te least amount of my hair out?
15:52:23 <roconnor> do people use pattern guards for view patterns?
15:52:24 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:52:41 <roconnor> jfischoff: :)
15:52:56 <jfischoff> :)
15:53:00 <mekeor> gertc: i don't know.
15:53:13 <roconnor> jfischoff: you've probably used it more than I have
15:53:32 <jfischoff> roconnor: hehe
15:53:48 <mekeor> gertc: but personally i'd use acid-state.
15:53:49 <jfischoff> roconnor: it works!
15:54:15 <edwardk> Peaker: it has the benefit of being fairly quiet, and it is consistent with .= for state though
15:54:28 <cleantc> dail: why is it the correct type ?
15:54:32 <danil> cleantc: "demonstrates that type inference is incomplete," rather.  It's totally *sound* to fill in any old instance to satisfy an ambiguous constraint, but it would be terribly confusing
15:54:39 <edwardk> foo.bar.~ 12 $ ...
15:55:04 <cleantc> I argue Integer is not a valid type!
15:55:05 <jfischoff> roconnor: new confession of a haskell programmer: If you used my library, you've used it more then me.
15:55:09 <gertc> mekeor, is acid-state still active enough there home page scares me :)
15:55:25 <cleantc> any member of class num would do
15:55:34 <mekeor> s/there/their/
15:55:59 <danil> cleantc: oh, maybe that was a bad example -- defaulting gets involved.  All the same stuff happens if you replace "1" with "(1 :: Integer)" though
15:56:11 <mekeor> gertc: the latest upload was on Wed Jul 18 07:57:02 UTC 2012. so, i'd say, yes, it's active.
15:56:39 <mekeor> gertc: (see here, <http://hackage.haskell.org/package/acid-state>, for the latest upload date.)
15:56:42 <cleantc> forall a that (Show a) ^(Num a)^(Read a)
15:57:39 <gertc> mekeor, ok acid-state it is, thx
15:57:59 <mekeor> gertc: :D
16:01:53 <mekeor> applicative: when i try to manually install haddock (from source) and type "cabal install", it again hangs up at "Configuring haddock-2.11.0..."!
16:04:36 <cleantc> if a type is ambiguous, and it get "solved" by MR,  the solution suggested by MR seems non-deterministic (sensitive to the syntax of the code rather the semantics)
16:06:06 <cleantc> that's why it get triggered by semantic preserving syntactic transformations
16:08:21 <mekeor> i'd even accept radical suggestions for solving my problem. :/
16:09:49 <avpx> mekeor: Throw your computer out the window.
16:10:47 <danil> cleantc: the MR doesn't actually choose a type, it just lets the variable's uses fight over which monotype gets chosen.  But you're right that whether or not the MR applies is purely syntactic.
16:11:34 <cleantc> danil: is there any other feature/restriction in Haskell which is sensitive to syntactic transformations (semantic preserving) ?
16:12:13 <Jafet> It's clearly not semantic-preserving if it changes the types.
16:12:57 <latro`a> hm, those issues that MR is said to solve in the MR article--what does NoMR do about them?
16:13:09 <Jafet> They become your issues
16:13:11 <latro`a> (in particular the ambiguity issue)
16:13:13 <cleantc> Jafet: type of  f x = show x is different from f = \x -> show x?
16:13:35 <Jafet> cleantc: in haskell98
16:13:52 <Jafet> Well, not that anyone uses that any more
16:14:05 <cleantc> well, Haskell 2010 is the same right?
16:15:12 <Jafet> > let a (f, g) = (f (), g 0); f x = show x in g (f, f)
16:15:13 <lambdabot>   Overlapping instances for GHC.Show.Show (a1 -> GHC.Base.String)
16:15:13 <lambdabot>    arising ...
16:15:24 <Jafet> > let a (f, g) = (f (), g 0); f x = show x in a (f, f)
16:15:26 <lambdabot>   ("()","0")
16:16:04 <danil> cleantc: type inference with Rank2Types (or RankNTypes) is not actually decidable in the general case, so occasionally you can be surprised by which type annotations on parts of expressions/patterns/declarations cause which types to be inferred
16:16:47 * mekeor is absolutely, totally, ultimately, deeply, honestly, frankly, entirely, fully DESPERATE. :C
16:19:48 <d-snp> hey, odd question instead of a list of values I want to map a function over
16:19:57 <d-snp> I have a list of function I want to map on a value
16:20:05 <d-snp> does that have a name?
16:20:07 <copumpkin> > flip [(+1), (*2)] 5
16:20:09 <lambdabot>   [6,10]
16:20:11 <copumpkin> > sequence [(+1), (*2)] 5
16:20:12 <lambdabot>   [6,10]
16:20:14 <dibblego> d-snp: sequence
16:20:16 <mekeor> map ($value) listOfFuncitons
16:20:18 <copumpkin> > map ($5) [(+1), (*2)]
16:20:18 <d-snp> ah thanks :D
16:20:19 <lambdabot>   [6,10]
16:20:30 <d-snp> and flip is an alias? :P
16:20:38 <copumpkin> no, it's a Cale-ism
16:20:45 <typoclass> d-snp: this last one is the clearest. the others give me the willies
16:20:47 <Cale> Invented by ski
16:20:51 <Cale> iirc
16:20:52 <cleantc> danil: Having RankN, some  syntactic transformations (semantic-preserving in rank 1) may change the semantics?
16:20:52 <copumpkin> oh
16:20:54 <copumpkin> a ski-ism
16:21:05 <typoclass> caleskiism
16:21:08 <d-snp> :P
16:21:17 <d-snp> caleski, the notorious russion mathematician
16:21:26 <d-snp> s/russion/russian
16:21:52 <d-snp> I like the last one too, it retains the idea of a map
16:22:27 <copumpkin> sequence views it differently
16:22:48 <danil> cleantc: not exactly, but they can change whether or not your code compiles in... unexpected ways
16:23:16 <cleantc> the practicality of my question is: I am going to write a system that works with desugared AST of Haskell  therefore I need to know what desugaring s are semantic preserving
16:23:33 <danil> cleantc: I have an example that someone was asking about earlier, but it uses the lens library
16:23:57 <cleantc> sure, please share
16:24:01 <hpaste> danil pasted “RankNTypes = strange inference” at http://hpaste.org/72668
16:24:21 <Jafet> All of ghc's desugarings should, obviously, preserve semantics
16:25:52 <d-snp> I have a function 'validMoves' that is fairly expensive, will haskell do its functional transparency thing and cache it if I use it in a bunch of different scopes on the same game?
16:26:04 <d-snp> where a game is just a board with some pieces on it
16:26:47 <d-snp> or is it smarter to first call validmoves, and pass the valid moves list to the various functions?
16:29:49 <cleantc> Jafet: why "should"?
16:30:45 <latro`a> d-snp--it is probably more robust in general to pass it around as an argument
16:31:15 <Jafet> cleantc: barring bugs
16:31:23 <latro`a> a way that involves less cruft would be to keep it in a record
16:31:30 <latro`a> and then pass that record around in StateT or such
16:31:34 <Jafet> d-snp: transparency does not imply memoization
16:36:30 <sentientwaffle> in a "do" block, one of my expressions returns [[IO ()]] (which is not allowed apparently?). how can I convert it without using `head . head`?
16:37:11 <Jafet> :t sequence_ :: [IO a] -> IO ()
16:37:13 <lambdabot> forall a. [IO a] -> IO ()
16:37:27 <copumpkin> sentientwaffle: depends what you want it to do
16:37:59 <sentientwaffle> using sequence_ gives 'Couldn't match expected type `IO a0' with actual type `[b0]''
16:38:10 <copumpkin> sequence_ . concat
16:38:15 <copumpkin> but you need to figure out what you want
16:38:45 <Jafet> sequence sequences the actions
16:39:00 <typoclass> sentientwaffle: sentientwaffle: in principle a [[IO ()]] is allowed. post some code (use hpaste) and folks can give you more concrete advice
16:39:05 <Jafet> head.head takes the first action (or dies in a fire)
16:39:16 <sentientwaffle> k, 1 sec
16:40:55 <cleantc> ok, to sum up: except for the times that monomorphism restriction "helps" solving an ambiguous type, having it off doesn't affect the typechecking?
16:41:52 <sentientwaffle> okay, I think I included the relavant parts, let me know if I missed anything: http://hpaste.org/72669
16:42:04 <Jafet> I don't think MR changes the meaning of any program that compiles under it
16:42:20 <Jafet> Maybe programs with ranked types
16:42:25 <Jafet> Or gadt
16:42:30 <danil> cleantc: it still makes the inferred type less polymorphic even when there's no ambiguity
16:42:54 <cleantc> is there any name for this less-polymorphic in the literature ?
16:43:22 <danil> "monomorphic" or "not generalized"
16:43:34 <typoclass> :t mapM sentientwaffle, you might be interested in this
16:43:35 <lambdabot> parse error on input `,'
16:43:42 <typoclass> erm
16:43:42 <geekosaur> heh
16:43:44 <typoclass> :t mapM
16:43:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:44:50 <typoclass> (you can read that as "(a -> IO b) -> [a] -> IO [b]". i think you could make use of that in your showRow function)
16:45:09 <danil> Jafet: I'm pretty sure you're right, if code compiles with and without the MR then it does the same thing
16:45:58 <Jafet> sentientwaffle: try writing showWorld :: World -> String
16:46:05 <cleantc> danil: we are talking about cases that MR is off
16:46:51 <cleantc> in other words, is it totally safe to use -XNoMR ?
16:47:02 <Reaga> why wasnt i taught haskell at univeristy
16:47:22 <typoclass> sentientwaffle: and yes, what jafet says. we like to structure programs so that you have as few functions in IO as possible
16:48:08 <danil> cleantc: yes, and it will almost certainly someday be the default
16:48:10 <Jafet> @faq can haskell be taught at university?
16:48:11 <lambdabot> The answer is: Yes! Haskell can do that.
16:48:22 <Reaga> huh?
16:48:55 <sentientwaffle> typoclass: thanks for the advice! and it looks like "mapM sequence ..." does exactly what I want
16:48:59 <cleantc> in my university that's kinda the main language :)
16:49:02 <danil> @where let should not be generalized
16:49:03 <lambdabot> I know nothing about let.
16:50:49 <cleantc> danil : http://research.microsoft.com/~simonpj/papers/constraints/index.htm :)
16:51:53 <cleantc> latest belief: no MR  +  LG at the top level , MR + no LG at the local bindings
16:53:34 <hpaste> d-snp pasted “$ or .” at http://hpaste.org/72670
16:53:51 <d-snp> ok guys, I keep struggling with this
16:53:56 <d-snp> how would you write line 13?
16:54:13 <d-snp> I always use $ instead of ., because when I use . it throws errors
16:54:21 <d-snp> but sometimes I see people write beautiful stuff with .
16:54:25 <Jafet> I can't afford to use $
16:54:37 <Jafet> . is function composition, $ is function application
16:54:57 <Jafet> f $ g $ x = f (g x) = (f . g) x = f . g $ x
16:54:58 <cleantc> the reason behind no LG is that having a constraint based type system (using ~ constraint), let generalization pollutes the surface type (the type that users see) with the implication constraints that should remain under the hood
16:55:20 * hackagebot hascal 1.1 - a minimal, extensible and precise calculator (DagOdenhall)
16:55:45 <d-snp> but I can't just do best . concat . map ($game) strategies
16:56:03 <Jafet> map ($game) strategies isn't a function
16:56:14 <Jafet> map ($game) is a function
16:56:36 <d-snp> eh oh
16:56:47 <typoclass> d-snp: you can often convert $ to . but you may need to insert some parens. in your case, you could do "(best . concat) (map ...)", but that's not really more clear or concise
16:57:31 <d-snp> right
16:57:50 <d-snp> so $ is just more chainable than .?
16:58:23 <d-snp> I was hoping for something like best.concat.(map ($game)) strategies
16:58:38 <d-snp> but that doesn't work
16:58:47 <shachaf> "convert $ to ." is a strange way of thinking about it.
16:58:51 <Jafet> Because map ($game) strategies isn't a function
16:59:23 <typoclass> shachaf: it's all jafet's fault! ;)
17:00:40 <d-snp> oh  best . concat . (map ($game)) $ strategies
17:00:42 <typoclass> d-snp: yeah, that doesn't work. it parses "(map (...)) strategies" as one unit, and tries to compose that onto "best . concat". what should work is "(best . concat . map ($ game)) strategies"
17:00:43 <d-snp> that works :P
17:00:51 <d-snp> I think I get it now
17:00:52 <typoclass> er, yeah :9
17:01:05 <Jafet> Warning: redundant brackets around map ($game)
17:01:24 <d-snp> does $game just work?
17:01:26 <d-snp> cool
17:01:37 <d-snp> no wait
17:01:39 <d-snp> that can't be
17:01:41 <typoclass> no, he meant the "(" before the m
17:02:05 <d-snp> ah you're right
17:02:06 <d-snp> nice
17:02:22 <d-snp> ok I think that's pretty
17:05:43 <Reaga> i want to learn haskell
17:05:55 <Reaga> i know a bit of java and thats it really
17:06:00 <Reaga> is haskell like java?
17:06:04 <nand`> no
17:06:17 <Reaga> i heard that you arent allowed variables in haskell
17:06:17 <avpx> Not sure if trolling...
17:06:18 <Reaga> is that true
17:06:21 <nand`> no
17:06:37 <nand`> well, depends on how you define ‘variable’
17:06:42 <nand`> there have been heated discussions over this before
17:06:44 <Reaga> x
17:06:45 <Cale> heh
17:06:48 <typoclass> Reaga: it's not really like java :) but give it a shot, haskell is very rewarding in the end. try this tutorial
17:06:50 <typoclass> @where lyah
17:06:51 <lambdabot> http://www.learnyouahaskell.com/
17:06:53 <cleantc> any example that Haskell infers a RankN type?
17:07:01 <nand`> Haskell infers rank n types?
17:07:15 <d-snp> lol, PrPerleuldued.e(.!(!!)!:) :i nidnedxe xt otoo ol alragreg
17:07:22 <d-snp> is the error I got ;)
17:07:24 <nand`> does a rank-1 type count as a rank-n type?
17:07:25 <Cale> cleantc: The type inference specifically is designed not to infer polytypes for type variables
17:07:34 <Jafet> d-snp: do you know this guy called concatMap
17:07:38 <avpx> d-snp: Runtime errors can be so cryptic...
17:07:42 <Reaga> does haskell have a good ide ?
17:07:45 <Jafet> You might like him
17:07:48 <Reaga> i dont like programming in command line
17:08:01 <nand`> ah yes, good old ‘cat’
17:08:06 <nand`> and ‘echo’
17:08:07 <Cale> Reaga: there are IDEs, but mostly whatever your favourite text editor is + ghci will do nicely
17:08:07 <mapreduce> @google leksah
17:08:10 <lambdabot> http://leksah.org/
17:08:10 <lambdabot> Title: Leksah - Haskell IDE in Haskell
17:08:10 <d-snp> Jafet: is its source concat.map ?
17:08:24 <Cale> Reaga: Just keep ghci open in a second window, and :r to reload your code whenever you change it
17:08:30 <nand`> raek: haskell has a great IDE and it's called ghci
17:08:32 <Jafet> (concat.).map
17:08:33 <nand`> sorry, Reaga
17:08:37 <Reaga> what
17:08:39 <Reaga> oh
17:08:46 <Cale> You can ask ghci to evaluate expressions or ask it for the types of things, etc.
17:08:58 <Reaga> i want an ide tho
17:09:00 <cleantc> Having  emacs, ctrl+c ctrl+l works fine
17:09:02 <typoclass> Reaga: what is not allowed is having a variable, assigning it a value, and then assigning it another value. haskell's variables are a little like java's final variables
17:09:11 <Reaga> ah, i see.
17:09:16 <Jafet> Haskell's variables are constants
17:09:23 <danil> Or like "variables" in algebra
17:09:27 <Reaga> so they arent really variables then since they cant vary
17:09:45 <Cale> Haskell does have mutable cells called IORefs, but they're not used as much as mutable variables in most languages.
17:09:53 <typoclass> Reaga: that's true. the word "variable" therefore isn't really popular
17:09:53 <d-snp> hey Reaga have you watched this? http://haskelllive.com/
17:10:06 <nand`> ignoring all that, the bottom line is that haskell values are immutable
17:10:12 <mapreduce> Sure they can.  f x = x * 2 -- x could be any number, it can vary each time it's used
17:10:22 <mapreduce> I might do f 3, f 5, f 10000, x varies
17:10:36 <Cale> mapreduce: indeed
17:10:45 <typoclass> mapreduce: talk to jafet then :)
17:10:48 <nand`> you can't say, define ‘x’ as something that changes its value
17:10:48 <cleantc> Cale: why? "The type inference specifically is designed not to infer polytypes for type variables"
17:10:48 <avpx> Reaga: You're probably used to thinking of programs as being a series of instructions that cause a part of memory to be changed, or some disk action to be performed, or a string to be written to I/O. This is not how Haskell's model of computation works.
17:11:03 <Jafet> It's a different x each time!
17:11:12 <Cale> Jafet: It's the same x in the code.
17:11:16 <danil> cleantc: type variables only get instantiated with monotypes, but expressions can be inferred to have higher-rank types if you apply something that requires a polymorphic argument to them
17:11:18 <nand`> Jafet: exactly, each time you're talking about a different x in a different scope
17:11:54 <mapreduce> Reaga: Doesn't x = x + 5; strike you as odd in C-based languages?  x is equal to x plus 5?  How can that be?
17:12:04 <nand`> there's no cross-interference, eg. evaluating ‘f 2’ and ‘f 3’ the two x's are completely independent
17:12:30 <nand`> mapreduce: I think it's just a poor choice of operator
17:12:38 <nand`> <- would have been better
17:12:38 <poelfda> there is no x in f 3
17:12:40 <Cale> cleantc: It's because things which ought to be type errors can be deferred by inferring polytypes sometimes, and make error messages confusing or even perhaps allow code to run and do something unintentional.
17:12:47 <Reaga> mapreduce: yes its odd
17:13:01 <Jafet> > f x
17:13:03 <lambdabot>   Ambiguous occurrence `x'
17:13:03 <lambdabot>  It could refer to either `L.x', defined at <local...
17:13:09 <avpx> And now we have to use == for equality
17:13:22 <mapreduce> Haskell uses == for equality. :)
17:13:30 <Jafet> Haskell also uses = for assignment
17:13:39 <d-snp> if I use runhaskell, it doesn't show me linenumbers of the index too large error, can I turn that on or is that lost in any compilation?
17:13:40 <nand`> poelfda: if f is defined as “f x = x*2” then wouldn't that technically expand to (\x -> x*2) 3; ie. (x*2) with x replaced by 3 (I forget the notation for this)
17:13:40 <avpx> Truth, truth in all of these statements
17:13:41 <typoclass> Jafet: except when it uses <-
17:13:43 <mapreduce> Erlang uses = for both, kinda.
17:13:44 <typoclass> :)
17:13:56 <nand`> haskell uses = for definitions
17:13:58 <nand`> C doesn't
17:14:00 <mapreduce> Actually that's not true, sorry.
17:14:14 <mekeor> it would be nice to have a syntax like "f = g = h = …", actually.
17:14:33 <nand`> mekeor: I've never found the need, personally; why bother having two names?
17:14:35 <monochrom> C uses = for x=x+1 therefore 0=1
17:14:42 <monochrom> also, BASIC
17:14:49 <Jafet> (f:g:h:_) = repeat $ …
17:14:51 <Reaga> i need to learn haskell in linux dont i
17:14:58 <Nereid> Reaga: no, it works on windows and mac too
17:15:00 <nand`> I learned Haskell on windows
17:15:00 <mapreduce> > (16777216 :: Float) + 1
17:15:02 <lambdabot>   1.6777216e7
17:15:02 <typoclass> nand`: you can later sneakily modify one of them! er wait, this is haskell ...
17:15:04 <mekeor> Jafet: heh.
17:15:05 <Reaga> no but the libraries are all for linux
17:15:08 <monochrom> I learned haskell on vic-20
17:15:08 <mapreduce> See, x = x + 1
17:15:13 <Jafet> I believe there was a version of fortran where you could make 0 = 1
17:15:13 <Nereid> Reaga: no, the libraries are all for haskell.
17:15:26 <Reaga> lies
17:15:26 <Jafet> Well, unix is for unix
17:15:33 <mekeor> monochrom: rly?
17:15:37 <avpx> Reaga: Which libraries are you talking about?
17:15:38 <nand`> Jafet: not like haskell's Num/Eq make any sense either way
17:15:40 <monochrom> I learned BASIC in ubuntu
17:15:47 <mapreduce> Reaga: I've used it mostly on Windows.
17:15:47 <monochrom> I am joking :)
17:15:52 <poelfda> poelfda : yes, there is an occurence of x in (\x -> x*2) 3; but when you write (\x -> x*2) 3 + (\x -> x * 2) 4; there is nog longer any doubt that the two x-es refer to two different occurrences
17:15:53 <nand`> Jafet: so you could probably get away with 0 == 1 = True
17:15:58 <Reaga> mapreduce: dont u have to mess with the libraries to get them to work on windows tho
17:16:13 <Nereid> > let x = 2^64 :: Float in x == x + 1
17:16:14 <lambdabot>   True
17:16:25 <Jafet> nand: the compiler stored 0 in a register for some optimization
17:16:32 <poelfda> so why not constrain ourselves, to only reffering to x when it actually occurs?
17:16:42 <mapreduce> I've not done an awful lot to be honest.  It's possible that libraries could be tricky but it's not come up yet for me.
17:16:49 <nand`> Jafet: wait, so a compiler bug broke the language semantics?
17:17:02 <Nereid> mekeor: why would you want to define multiple names to be the same thing?
17:17:03 <typoclass> Reaga: i think quite a few of haskell's creators use windows these days. it's pretty well-supported
17:17:03 <Jafet> No, you just added some machine code to change 0 to 1
17:17:13 <Jafet> I might have misremembered
17:17:22 <Nereid> in the same place
17:17:26 <nand`> mapreduce: I remember having trouble with wxwidgets on windows
17:17:29 <mapreduce> Reaga: The ghc lead developer works for MS. :)
17:17:34 <xORioN63>  hey, could anyone see what's wrong with my code... http://pastebin.com/KpD6UrUC thanks ;)
17:17:35 <mekeor> Nereid: why do people do type F = G?
17:17:36 <mauke> The paste KpD6UrUC has been copied to http://hpaste.org/72671
17:17:37 <nand`> or was it gtk? I don't remember
17:17:37 <danil> Nereid: clearly so you can put different type signatures on them ;)
17:17:43 <monochrom> I am a fan of using different variable names at different places, too. it doesn't solve all problems
17:17:47 <Jafet> mekeor: to save typing
17:17:54 <nand`> mapreduce: oh, no; I was barking up the wrong tree - it was SDL I was having trouble with
17:18:01 <mekeor> Jafet: huh?
17:18:03 <Jafet> Usually F is shorter than G.
17:18:09 <Nereid> nand`: a couple years ago I tried getting SDL working on windows, and failed
17:18:16 <Nereid> I tried again last month and it worked first try without any trouble
17:18:16 <zzing_> Is using the icu library in C compatible with the Text type in Haskell?
17:18:18 <Nereid> using mingw
17:18:19 <mapreduce> nand`: I've only used wx* from python on Windows, and that worked easily.
17:18:28 <nand`> Nereid: it was.. a few months back
17:18:31 <Nereid> zzing_: there's a text-icu package or something
17:18:31 <monochrom> I is shorter than J. in almost all proportional fonts
17:18:39 <nand`> Nereid: I just used OpenGL instead at the time, which worked fine
17:18:49 <Jafet> I should change my editor to proportional fonts
17:18:53 <nand`> Nereid: (I switched to linux shortly afterwards either way)
17:19:09 <zzing_> Nereid, ok. Should mention, that I am doing some code for font rendering in C, that is to be bound to Haskell eventually - thought ICU might be a good way to do unicode.
17:19:19 <nand`> monochrom: you use proportional fonts for viewing code?
17:19:32 <Nereid> ICU seems to be a good way to do unicode.
17:19:39 <zzing_> guten.
17:19:49 <monochrom> not yet
17:20:22 <monochrom> package "text-icu" seems to bridge ICU and Text
17:21:03 <cleantc> danil: if I am not mistaken, having  (f::forall a.(forall b. [b]->[b])->[a]->[a])  x , typechecks x with forall b. [b]->[b]  (in contrast to typeinfer x), i.e., in applications arguments are always typechecked
17:21:45 <Reaga> what drugs can i take to enhance my coding ability?
17:22:00 <nand`> some people seem to think caffeine helps
17:22:02 <Reaga> answer: hard work. and lots of it!
17:22:16 <Reaga> i dont drink caffeine...
17:22:20 <nand`> neither do I
17:22:22 <Reaga> or eat it
17:23:51 <monochrom> no drug can enhance your coding ability. however, you may hope to make babies and raise them to have better coding ability
17:24:10 <monochrom> and hope that by the time they are adults, coding ability will not yet be obsolete
17:24:27 <nand`> depends on how liberally you define ‘code’
17:24:39 <Urthwhyte> anything that lets you focus will help
17:24:48 <monochrom> well yeah but you can't predict what is "code" 30 years later
17:24:56 <Urthwhyte> Nothing will make you smarter, it will allow you to bash your head against the wall for longer
17:25:12 <nand`> monochrom: worst comes to worst it'll be synonymous with Java source
17:25:33 <monochrom> not convinced it is worst
17:25:49 <nand`> my mind deliberately prevents me from imagining worse scenarios
17:26:43 <monochrom> I mean, you hone your kids on java, you think it's the worst possible. but 30 years later, no one needs to code in our sense, not java or agda, they program computers by natural language
17:27:17 <monochrom> if you hone your kids on formal languages, they actually sacrifice natural language skills
17:27:59 <danil> that is interesting if true, do you have a reference?
17:28:33 <mapreduce> Or they learn how to express themselves unambiguously in natural language and interpret ambiguous words.
17:29:03 <nand`> I'm not exactly sure it's within the capacity of natural languages to be unambiguous
17:29:18 <Reaga> i think i know what coding will be like in 30 years
17:29:20 <nand`> then again, I know nothing about linguistics; formal or otherwise
17:29:41 <cleantc> I hope natural languages started become more formal instead :)
17:29:44 <Reaga> i believe that P=NP and my life revolves around that
17:30:04 <avpx> How will that change how we write code?
17:30:26 <Reaga> i have read stephen wolfram's NKS and it got me thinking
17:30:31 * nand` admits having no real idea what ‘P’ and ‘NP’ are and how they relate
17:30:37 <danil> I think the gap between computers knowing what we mean enough to generate code from natural language and computers knowing what we want enough to just do the right thing without being asked is relatively small
17:30:44 <monochrom> oh, i'm pretty sure the part about "plain text editor" won't change
17:30:51 <avpx> nand`: They're complexity classes, and they relate by being equal or not equal
17:30:53 <Reaga> monochrom: think again
17:31:12 <monochrom> oh I have thought again and again
17:31:17 <Ralith> nand`: if P=NP, conventional cryptography breaks and lots of slow algorithms get faster
17:31:47 <Reaga> nand`: does some subset of {-6, 34, -99, 3, 5, 88, 4, -73, 7} add up to 0?
17:31:55 <Reaga> :D
17:32:07 <monochrom> um, you do not literally mean "slow algorithms get faster"
17:32:07 <Reaga> the answer to that question is hard to compute but easy to verify
17:32:07 <nand`> Reaga: bah, decidable; brute force. Next?
17:32:30 <Reaga> nand`: the point is that it isnt known if an algorithm exists that computers the answer in the same time it takes to verify it
17:32:43 <Reaga> we might just really suck at algorithms
17:32:47 <Reaga> and i think thats the case
17:33:34 <Ralith> monochrom: yes, that was a dramatic oversimplification :P
17:33:35 <Gracenotes> it seems we are being fairly loosey-goosey about complexity theory terminology.
17:33:40 <avpx> > any (==0) . map sum $ subsequences [-6, 34, -99, 3, 5, 88, 4, -73, 7]
17:33:42 <lambdabot>   True
17:33:47 <Reaga> Gracenotes: no shit
17:33:49 <danil> > any ((== 0) . sum) $ filterM (const [True, False]) $ [-6, 34, -99, 3, 5, 88, 4, -73, 7]
17:33:52 <lambdabot>   True
17:33:54 <Reaga> whoah
17:34:10 <poelfda> does that list include []?
17:34:10 <Reaga> anyway, processors work by using prodecural instructions
17:34:15 <Reaga> why doesnt haskell accept this?
17:34:21 <nand`> poelfda: it should
17:34:26 <nand`> > subsequences "foo"
17:34:27 <lambdabot>   ["","f","o","fo","o","fo","oo","foo"]
17:34:29 <avpx> Reaga: Derp. That is all I will say.
17:34:36 <Reaga> anyway, i sleep now
17:34:50 <Ralith> monochrom: if you want to convey the precise answer to nand`, please do!
17:34:54 <nand`> poelfda: but that actually exposes a loophole in the problem statement
17:35:02 <monochrom> haskell accepts procedural instructions. look at putStrLn and getLine
17:35:04 <avpx> Reaga: Processors don't deal with objects anyway, but you have no problem using Java...
17:35:19 <avpx> It's a flimsy argument.
17:35:19 <Ralith> avpx: some processors do! :D
17:35:26 <avpx> Ralith: And some processors do graph reduction
17:35:29 <monochrom> if P=NP, you can find faster algorithms for used-to-be-harder problems
17:35:34 <Ralith> oo, really?
17:35:43 <nand`> and some processors are the reduceron
17:35:55 <monochrom> but the slow algorithms you wrote yesterday, well you wrote them to be slow, they will still be slow
17:36:05 <avpx> nand`: Thanks
17:36:06 <nand`> monochrom: surely that wording should be changed to ‘there exist’, not ‘you can find’
17:36:25 <avpx> I'm really not sure what was up with that user
17:36:29 <Ralith> nand`: I think the finding is usually pretty easy.
17:36:43 <Ralith> since rewriting NP problems in terms of eachother is generally how you prove they're in NP.
17:36:48 <monochrom> that distinction is purely philosophical
17:36:58 <avpx> "What's Haskell? Does it have variables? Is it P=NP? Why can't Haskellers accept that CPUs are imperative?"
17:37:03 <avpx> It was just an odd exchange
17:37:08 <Gracenotes> monocrom: if P=NP, there might not be algorithms we care about whose speed is increased for input sizes we care about.
17:37:11 <roconnor> avpx: where?
17:37:13 <Ralith> that was pretty odd, now that you mention it
17:37:22 <nand`> suppose P=NP and the finding is easy; then wouldn't we have already found the P equivalents of NP algorithms now? therefore, if P=NP, surely finding them must be non-easy
17:37:26 <avpx> roconnor: Reaga
17:37:38 <Gracenotes> *monochrom
17:38:04 <roconnor> oh
17:38:10 <monochrom> it is more constructive to change my wording to "if we find a constructive proof of P=NP"
17:38:19 <nand`> Ralith: maybe the proof for P=NP involves a method of constructing a P algorithm for any NP algorithm
17:38:21 <Ralith> nand`: NP problems are frequently rewritten in terms of other NP problems, so if one NP problem is found to also be in P, I expect that there will be a large body of knowledge to draw on to rewrite other problems in its terms.
17:38:27 <nand`> which would make finding trivial
17:38:36 <roconnor> monochrom: if P = NP then there is a constructive proof that P = NP (specific for P = NP)
17:38:48 <avpx> roconnor: Why do you say that?
17:38:53 <monochrom> now we're getting modal
17:38:54 <nand`> Ralith: fair enough
17:39:15 <Ralith> I'm not sure if there's anything special about NP that makes writing problems in terms of eachother easy, but it happens a lot.
17:39:17 <roconnor> avpx monochrom: because today, right now, we can write a polytime solution to any problem solvable in polytime.
17:39:18 <Gracenotes> even so. polynomial-time doesn't mean feasible.
17:39:47 <avpx> Heh, look at sorting...
17:40:02 <Gracenotes> just ask a computational geometrist near you
17:40:10 <Gracenotes> if you can find any
17:40:21 <roconnor> avpx: basically you can run every algorithm in parallel and achive only a quadradic slowdown
17:40:37 <avpx> roconnor: Oh, cool
17:40:59 <monochrom> what is haskell?
17:41:08 <roconnor> @faq what is haskell?
17:41:09 <lambdabot> The answer is: Yes! Haskell can do that.
17:41:22 <Ralith> oh, that's the command
17:41:23 * Ralith note
17:41:23 <monochrom> haha
17:41:36 <Ralith> "Haskell is the thing that can do that."
17:42:04 * nand` likes @faq Can Haskell do something Haskell can't?
17:42:05 <slack1256> @faq can haskell be asked about what is haskell?
17:42:05 <lambdabot> The answer is: Yes! Haskell can do that.
17:42:30 <danil> roconnor: every time you introduce dovetailing to an intro cs theory class you can just watch people's brains exploding
17:42:31 <avpx> @faq Can Haskell create a type error so complex that even a Haskell program could not figure out what it means?
17:42:31 <lambdabot> The answer is: Yes! Haskell can do that.
17:42:48 <nand`> dovetailing?
17:42:48 <slack1256> somebody quickly call Douglas Hofstadter!
17:42:51 <danil> roconnor: "run... EVERY... algorithm?"
17:43:47 <roconnor> nand`: dovetailing is a standard process whereby every value in N * N is visited
17:44:16 <shachaf> roconnor: Oh, that's what it's called?
17:44:19 <roconnor> http://en.wikipedia.org/wiki/Dovetailing_%28computer_science%29
17:44:23 <nand`> you mean like (0,0), (1,0), (0,1), (1,1) ..?
17:44:28 <danil> nand`: in this case, simulating every step of every algorithm
17:45:02 <roconnor> nand`: usually (0,0), (1,0), (0,1) (2,0), (1,1), (0,2), ...
17:45:30 <JoeyA> Oh my, I think I found a bug in atomicModifyIORef on Windows.  Namely, if an IORef is bombarded by two threads repeatedly calling atomicModifyIORef on it, I get garbage when I access it using a third thread.
17:45:39 <JoeyA> Here's my test case (depending on a library I'm working on): https://github.com/joeyadams/haskell-system-time-monotonic/blob/master/testing/bombard.hs
17:45:42 <JoeyA> I'll try to make a simpler test.
17:45:45 <roconnor> JoeyA: that sounds really bad
17:46:12 * roconnor guess it is 64-bit windows
17:46:16 <JoeyA> Nope, 32-bit
17:46:18 <JoeyA> Windows XP
17:46:47 <JoeyA> I'm also doing GetTickCount system calls, but I determined that those aren't returning trash (at least not most of the time).
17:46:48 <Cale> JoeyA: does it only happen with forkOS? Why are you using forkOS?
17:46:58 <JoeyA> It could be a race in GetTickCount.  I haven't ruled that out yet.
17:47:03 <JoeyA> Cale: Happens with forkIO, too.
17:47:06 <JoeyA> Even without -threaded.
17:47:35 <JoeyA> I'll write a simpler testcase.
17:54:15 <JoeyA> Hmm, doesn't happen with a trivial case (incrementing an Int modulo 10).
17:54:43 <JoeyA> So I'll add a guard to GetTickCount to make sure it isn't returning odd results occasionally.
17:59:48 <JoeyA> Nope, GetTickCount is always returning sane results.
18:09:12 <d-snp> I made a go ai that performs random valid moves :P https://github.com/d-snp/Ergo/blob/master/ergo/ai.hs
18:09:31 <irene-knapp> lol very nice
18:09:51 <avpx> d-snp: As far as I understand, that's about the best Go AI we have :p
18:15:46 <otters> @pl \n -> concatMap (\x -> concatMap (\y -> [(x,y)]) n) n
18:15:47 <lambdabot> (=<<) =<< (. (flip flip [] . ((:) .) . (,))) . (>>=)
18:15:53 <otters> neato
18:17:18 <d-snp> is pl a command that turns barely readable haskell into completely unreadable haskell? :D
18:18:19 <nand`> yes. mnemonic ‘@perl’
18:18:51 <d-snp> :P
18:20:47 <startling> I wish bifunctor had mapLeft and mapRight functions
18:21:00 <startling> maybe (|<|) and (|>|) or something?
18:21:34 <startling> mapRight is usually fmap I guess, but mapLeft would be useful
18:22:55 <callen> is there a way to get slime/repl-esque programming in Emacs ala Lisp and Schee with Haskell? ghci rustles my jimmies.
18:23:33 <startling> callen, I use m-x-ansi-term and ghci
18:23:43 <startling> not really what you're asking for though, I guess
18:23:49 <callen> that is disappointing beyond words.
18:23:54 <startling> haha
18:24:27 <callen> but seriously though? nothin'?
18:25:29 <callen> it looks like there used to be shime, but it has disappeared.
18:26:03 <JoeyA> False alarm (about an atomicModifyIORef bug on Windows).  Looks like my code isn't handling overflow properly.
18:26:07 <startling> what does slime do? I was never much of a lisper
18:26:17 <sinelaw> Peaker, hey
18:26:19 <callen> startling: dude...you are missing out.
18:26:39 <startling> callen: o rly
18:26:55 <startling> is it just like a fancy copy-paste thing?
18:27:04 <callen> startling: no!
18:27:29 * mekeor doesn't understand callen's request.
18:27:35 <startling> is this like orgmode
18:27:49 <callen> no.
18:28:15 <callen> I can't keep responding to bad comparisons, my internet is slow and I have to keep ^k and ^y'ing my answer to what it is every time you force me to say no
18:28:37 <mekeor> callen: you aren't looking for haskell-mode, are you?
18:29:00 <callen> what did I just say? no.
18:29:12 <callen> startling: you write code, test code, eval code, see outputs all in the same buffer. It's a unification of authoring code and experimenting with it. It's a programmable environment for writing code where the code itself is tangible.
18:29:18 <avpx> So I guess callen is like the opposite of @faq?
18:29:25 <mekeor> hehehe
18:30:19 <d-snp> the miranda clone I learnt FP in worked like that too
18:30:27 <callen> I'm not a retard, I have haskell mode and automatic type-checking working in EMacs already. I want slime.
18:30:47 <startling> k.
18:31:03 <d-snp> it didn't even have a compiler outside of that, just the windows frontend with the weird REPL system
18:31:06 <callen> for example, I can have a change made to a function, hit C-x C-e, eval the new version of it and automatically see the results of test output in another buffer.
18:31:21 <callen> d-snp: hahahaha
18:31:21 <d-snp> oh it didn't do that
18:31:31 <callen> d-snp: it sounds similar though.
18:31:39 <startling> d-snp: was it agda
18:31:46 <mekeor> he said miranda.
18:31:53 <startling>  /troll
18:31:53 <callen> the important part is that the round-trip time for seeing the results of a hypothetical change approach zero.
18:31:53 <mekeor> miranda clone, oh.
18:31:56 <d-snp> the clone was called amanda
18:32:34 <d-snp> now the course moved to regular haskell, so people don't have to deal with it anymore :P
18:33:09 <callen> I'm surprised an entire channel of haskell users are naive to lisp and emacs. Where did you guys come to haskell from?
18:33:29 <d-snp> university? :P
18:33:49 <startling> callen, I've done scheme, just not with slime because I never *got* it.
18:34:17 <startling> I came mostly from python though tbh
18:34:24 <d-snp> or do you mean programming language
18:34:25 <d-snp> then ruby
18:34:47 <d-snp> (and before that C#)
18:35:20 <latro`a> started in python myself, twiddled in C and common lisp each a tiny bit before finding haskell
18:35:24 * hackagebot accelerate-cuda 0.12.1.1 - Accelerate backend for NVIDIA GPUs (TrevorMcDonell)
18:36:06 <callen> startling: you should go back and rectify that.
18:36:34 <startling> callen, meh
18:36:55 <callen> I found something that is close enough to what I want anyway.
18:38:01 <d-snp> callen: do you perhaps know a video of what it's like to work in emacs
18:38:34 <d-snp> this is what vim is like ;) http://haskelllive.com/
18:38:47 <callen> I'm a vim user as well, I just prefer Emacs.
18:39:24 <callen> Knowing both, I'd made the choice to stick with Emacs a long time ago.
18:39:58 <d-snp> oh.. I never tried emacs, I would like to, its pretty counterculture right now :P
18:41:47 <startling> I like vim, but emacs is better at vim than vim is. :)
18:42:12 <callen> d-snp: if you want a video of somebody using Emacs the wiki is pretty good: http://www.emacswiki.org/cgi-bin/wiki/EmacsScreencasts
18:42:22 <callen> alternately: http://archive.org/details/UsingtheSLIMELispInteractionModeforEmacs
18:43:35 <callen> d-snp: I use Emacs because I've tried most other things, including most popular text editors and IDEs, even got a good grasp of vim and vimscript. Emacs is just better for me.
18:43:49 <callen> d-snp: been using Emacs for 12 years. hardly counterculture in my little world, but okay :P
18:44:34 <callen> d-snp: the clojure folk have some pretty good examples of using swank/slime with clojure in Emacs.
18:56:57 <mkCurry> Question to anyone: I'm writing a "deep" DSL which generates code in another language. I want the variable names produced to be related to those used in Haskell, but there's no reflection. I had planned to do a preprocessor to pass in the variable name, but I started looking at TH. Is it possible to take all instances of variables in the generated AST, inject the name of the variables into them, and then inject that back into Haskell?
19:01:55 <callen> mkCurry: http://hackage.haskell.org/package/language-haskell-extract from http://hackage.haskell.org/package/test-framework-th
19:02:41 <callen> mkCurry: basically no in the most flexible sense, but if you're satisfied with compile-time extraction, it's a solved problem you can learn from.
19:03:21 <mkCurry> callen: Based on my limited TH fu, I'm shocked that even works!
19:03:48 <callen> mkCurry: you'll groan at the simplicity of the dumb hack I just linked you when you read the code.
19:04:02 <callen> mkCurry: it's just static extraction, don't get too excited.
19:04:29 <mkCurry> Alright, let me grok this a little deeper and I'll get back to you with questions. Thanks!
19:04:36 <callen> mkCurry: they use language-haskell-extract to find vars beginning with "case_*"
19:04:48 <callen> mkCurry: cheers.
19:10:25 * hackagebot gpx-conduit 0.1 - Read GPX files using conduits (ThomasDuBuisson)
19:17:00 <mkCurry> callen: Wait, so this looks at the file, parses it, and gives me the AST to play with? Can I use this as a pre-processor to replace the AST with my own?
19:19:06 <callen> mkCurry: I know less than you do, I'm just better at Googling apparently.
19:20:52 <callen> that's like, 99% of irc in programming channels for me really.
19:21:44 <mkCurry> callen: You have to know what to Google to Google it. Usually :)
19:22:17 <donri> callen meant to say it uses haskell-src-*exts*
19:22:35 <donri> and yea you can use that to write preprocessors (e.g. hsx, HTF)
19:23:22 <mkCurry> donri: Interesting. Thanks for the two pointers.
19:23:52 <EvanR> mmm pointers
19:23:56 <EvanR> *segfault*
19:24:24 <mkCurry> Thanks for the two references? :)
19:24:36 <EvanR> mmm c++ references
19:24:49 <EvanR> g++ compiler error hieroglyphics
19:25:07 <mkCurry> EvanR: Use LLVM.
19:25:22 <EvanR> for c++?
19:25:26 <donri> mmm circular references GC bugs
19:25:27 * hackagebot gps 1.1 - For manipulating GPS coordinates and trails. (ThomasDuBuisson)
19:25:47 <mkCurry> No no... You use LLVM for the error/warnings, and GCC for the optimizatio.
19:26:00 <EvanR> haha use the right tool for the job
19:26:14 <sentientwaffle> given "data Foo = Foo {a :: String, b :: String, ...}", and a function "Foo -> Foo" is it possible to return the parameter with only one changed attribute?
19:26:34 <sentientwaffle> w/o recopying them all manually with the getters
19:26:39 <EvanR> yes
19:26:41 <EvanR> update syntax
19:26:56 <EvanR> Foo {b = b'}
19:27:09 <EvanR> myFoo {b = b'}
19:27:20 <sentientwaffle> ah, awesome! thanks :)
19:27:28 <fragamus> I just exchanged emails with my friend who is director of planetary sciences at NASA. I told him about haskell's type safety and provable correctness
19:27:36 <donri> sentientwaffle: see also lenses
19:27:39 <startling> sentientwaffle, lenses are another interesting thing
19:27:42 <donri> e.g. the "lens" package
19:27:43 <startling> oh
19:27:46 <startling> jinx
19:27:51 <d-snp> provable correctness?
19:28:16 <mkCurry> d-snp: For some definition of provable.
19:28:31 <sentientwaffle> donri, startling: checking it out now
19:29:06 <EvanR> for very large values of 2
19:29:16 <fragamus> Yeah so if curiosity slams into the crater, Haskell gets a boost.   : )
19:29:28 <mkCurry> fragmus: I work for a 10k + engineer company, very C++ oriented. We finally got a project started in Haskell, it's very exciting.
19:29:41 <EvanR> heh like when they used ft instead of meters
19:29:45 <callen> mkCurry: you are one fortunate cookie.
19:29:49 <EvanR> they could have used a newtype ;)
19:29:59 <mkCurry> callen: I didn't say I get to write Haskell :)
19:30:15 <callen> fragamus: a lot of NASA folk are skeptical of language-level assurances for type/value constraints after Ariane V :P
19:30:19 <mkCurry> callen: The project is in another country :)
19:30:21 <callen> fragamus: or at least, the ones old enough to remember are.
19:30:27 <fragamus> I am building my first big application and it is very exciting
19:30:58 <callen> fragamus: Ariane V is why we have quickcheck and not just the type system...
19:31:26 <donri> needs moar agda
19:31:48 <fragamus> Certainly module interfaces should have new types instead of naked numbers
19:32:07 <tacosanta> n00b question: I am making the shift from OO -> func programming and beating my head against a wall trying to understand class constraints. Any good online docs for a n00b like me on this?
19:32:11 <fragamus> For stuff that costs billions
19:32:21 <callen> tacosanta: http://stackoverflow.com/questions/6929305/good-tutorial-for-haskell-type-signatures start here?
19:32:40 <callen> fragamus: anyway, point being, the compiler can't save you from stupid.
19:32:41 <startling> tacosanta, what kinds of class constraints? function signatures like "Eq k => k -> k -> Bool"?
19:32:47 <startling> callen: not yet!
19:33:09 <tacosanta> startling: everything to the left of =>
19:33:17 <tacosanta> startling: the right of => is easy
19:33:48 <startling> tacosanta: sure. So "Eq" is a typeclass; "Eq k =>" means "for any type k that is an instance of the typeclass Eq"
19:33:54 <mkCurry> tacosanta: It's a "filter". It says nothing but this type for k.
19:33:55 <EvanR> tacosanta: first thing is to delete any idea you have about classes from OOP
19:34:01 <startling> ^ that too
19:34:07 <startling> classes != typeclasses
19:34:08 <EvanR> typeclasses in haskell are not the same thing
19:34:18 <EvanR> typeclasses also has become a single word
19:34:19 <EvanR> haha
19:34:43 <tacosanta> so typeclasses don't give me any methods or anything
19:34:52 <mkCurry> EvanrR has a good point. C++ Classes are additive, definiting them adds something. In Haskell you're limiting the universe of types to just those that match the class.
19:34:53 <startling> tacosanta: sure they do
19:35:01 <startling> tacosanta: the typeclass Eq gives you (==)
19:35:02 <EvanR> tacosanta: so while they are still good to understand, they arent the main thing you need to begin work with haskell
19:35:06 <tacosanta> i need to read more but the books on this are lackluster in this department and i am anal
19:35:06 <jmcarthur> depends on how you define "method"
19:35:28 <tacosanta> so they're kind of like classes
19:35:36 <callen> tacosanta: dude, stop.
19:35:36 <jmcarthur> not like OO classes
19:35:36 <EvanR> no they are like interfaces in java
19:35:38 <startling> tacosanta: they're more like interfaces
19:35:38 <tacosanta> haha
19:35:45 <mkCurry> tacosanta: They do give you "methods". If I limit something to a class, then I know that anything that works on that class works here.
19:35:47 <callen> tacosanta: stop trying to make unlike things get conflated in your head.
19:35:50 <jmcarthur> they are in some ways like interfaces, but even that isn't quite right
19:36:01 <startling> tacosanta: they're like algebraic structures
19:36:18 <mkCurry> jmcarthur: They're like Go Interfaces, not Java ones.
19:36:18 <tacosanta> http://i.imgur.com/UmpOi.gif
19:36:22 <donri> type classes are like templates for type signatures with class instances filling in the "blanks"
19:36:30 <d-snp> oooh algebraic structures.. now it all makes sense to me
19:36:37 <jmcarthur> mkCurry: that only works if you know Go, though, of course
19:36:41 <d-snp> :P
19:36:42 <callen> tacosanta: typeclasses are just functional duck-typing, all code, no data.
19:36:45 <startling> d-snp: you'll get it someday
19:36:52 <startling> tacosanta, what languages do you know?
19:36:59 <callen> tacosanta: they're ways of integrating what functionality is intended for a given kind of thing into the type of the thing.
19:37:01 <EvanR> callen: wouldnt that be more like structural typing
19:37:03 <tacosanta> c++, php, perl
19:37:13 <callen> EvanR: I'm trying desperately to make it relatable.
19:37:17 <EvanR> haha
19:37:19 <tacosanta> so they're kind of like magic templates?
19:37:23 <jmcarthur> as a demonstration of the sense that type classes are like algebraic structures, Monoid is one of the most instructive type classes in the standard libs
19:37:32 <callen> tacosanta: less generic, similar idea.
19:37:54 <EvanR> tacosanta: check out Monoid
19:38:03 <EvanR> mempty, mappend
19:38:12 <mkCurry> tacosanta: Do NOT check out Monoid. It's confusing at first :)
19:38:13 <EvanR> > mempty :: Maybe Int
19:38:14 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
19:38:15 <lambdabot>    arising from a use of...
19:38:17 <jmcarthur> mkCurry: ?
19:38:18 <EvanR> haha
19:38:19 <startling> tacosanta, so to make something an instance of Eq you need to provide a (==) function like a -> a -> Bool
19:38:22 <EvanR> > mempty :: Maybe Sum
19:38:24 <lambdabot>   `Data.Monoid.Sum' is not applied to enough type arguments
19:38:24 <lambdabot>  The first argume...
19:38:38 <EvanR> and now im confusing you more :)
19:38:40 <callen> tacosanta: they don't really generate code, they just say that if something provides the verb, "quack" (a function) and the verb "walk", it's close enough to pretend it's a duck.
19:38:44 * jmcarthur thinks Monoid is one of the clearest type classes we have, apart from naming things "mempty" and "mappend"
19:38:47 <tacosanta> i'm working my way through "learn you a haskell" and that question was bugging me.. i think i'm getting closer to understanding, you guys are crazy helpful.
19:38:56 <startling> tacosanta: then you write generic functions that use (==) and work on any Eq type
19:38:57 <tacosanta> in #perl they would have told me to f-off :P
19:39:01 <EvanR> yeah Monoid is better than Ord i think, to begin with
19:39:04 <ParahSailin__> i got monad down, whats monoid
19:39:22 <mkCurry> jmcarthur: Monoids are very simple, and horribly explained, so they confuse you at first. Never start with monoid.
19:39:27 <startling> ParahSailin__, a type with an associative binary operation and an identity element
19:39:28 <d-snp> I would be telling people to f-off if my work involved writing perl too..
19:39:39 <EvanR> > [1,3,5] `mappend` [4,4]
19:39:41 <lambdabot>   [1,3,5,4,4]
19:39:47 <jmcarthur> mkCurry: an associative binary operation with an identity... not so hard to explain, IMO
19:39:48 <EvanR> > mempty :: [Int]
19:39:50 <lambdabot>   []
19:39:56 <ParahSailin__> no relation to monad?
19:40:04 <EvanR> > [1,3,5] `mappend` mempty
19:40:06 <lambdabot>   [1,3,5]
19:40:09 <jmcarthur> ParahSailin__: there are several ways they relate, but not important to understanding them
19:40:12 <mkCurry> jmcarthur: You're assuming he's taken Linear or Abstract algebra :)
19:40:24 <tacosanta> so if I have two of them, say (Num i, Ord i) => ....
19:40:27 <tacosanta> how do i read that in english
19:40:32 <startling> ParahSailin__: the names are kind of similar. :)
19:40:37 <mkCurry> jmcarthur: Else you have to explain identity.
19:40:45 <startling> tacosanta: "for any type i that is an instance of Num and Ord"...
19:40:48 <jmcarthur> mkCurry: i'm assuming no such thing. monoids are simple to explain by themselves, then it's just a few extra steps to relate them to the Monoid type class
19:40:49 <callen> tacosanta: input data must be ordered and numerical.
19:40:56 <mkCurry> jmcarthur: There once was a woman who swallowed a fly...
19:40:58 <nand`> tacosanta: “(for all i) which is numeric and orderable”
19:41:06 <tacosanta> ah shit.
19:41:08 <EvanR> tacosanta: something has type for all i such that i supports Num and Ord...
19:41:10 <tacosanta> its like a forall statement
19:41:16 <callen> tacosanta: no
19:41:19 <tacosanta> AHH
19:41:24 <startling> tacosanta: it's a qualified forall
19:41:24 <nand`> callen: yes?
19:41:28 <jmcarthur> callen: it is
19:41:28 <nand`> it's a forall
19:41:33 <d-snp> :D
19:41:34 <nand`> :t id
19:41:36 <lambdabot> forall a. a -> a
19:41:36 <callen> it's an overloaded term.
19:41:37 <tacosanta> like a mathematical forall, the upside down A
19:41:41 <nand`> :t (+)
19:41:42 <lambdabot> forall a. (Num a) => a -> a -> a
19:41:43 <jmcarthur> unqualified type variables are implicitly universally quantified
19:41:49 <callen> qualifying it as a mathemtical forall is a good statmeent to make.
19:41:56 <callen> it can mean other things to other programmers.
19:41:58 <jmcarthur> s/unqualified/unbound/
19:42:09 <callen> be careful, this dude is super eager to attach any connotation he can come up with.
19:42:18 <EvanR> :t []
19:42:19 <d-snp> :P
19:42:19 <startling> tacosanta: it's like a "for all x such that"
19:42:20 <lambdabot> forall a. [a]
19:42:25 <jmcarthur> tacosanta: yes, like a mathematical forall
19:42:37 <EvanR> :t [2,4]
19:42:39 <lambdabot> forall t. (Num t) => [t]
19:42:51 <d-snp> like forall hamburgers I eat it
19:42:52 <callen> tacosanta: the original link I sent you explains all this btw.
19:42:57 <callen> tacosanta: please read this: http://stackoverflow.com/questions/6929305/good-tutorial-for-haskell-type-signatures
19:43:08 <tacosanta> callen: I will read that now before i bomb you guys with more of this idiociy
19:43:15 <callen> tacosanta: it goes down the lit of virtually anything you'd encounter in a type sig.
19:43:16 <tacosanta> thanks for your help all
19:43:24 <mkCurry> tacosanta: Good luck.
19:43:24 <callen> tacosanta: cheers.
19:43:25 <mekeor> np
19:43:35 <callen> mekeor: you have a homework assignment too.
19:43:38 <callen> mekeor: you need to learn Emacs.
19:43:43 <mekeor> i know emacs.
19:43:46 <mekeor> i am in emacs atm.
19:43:50 <d-snp> :D
19:43:52 <callen> your statements didn't make it seem like it :(
19:43:53 <mekeor> (using erc =])
19:43:55 <d-snp> you irc in emacs?
19:43:59 <mekeor> yeah :D
19:44:01 <callen> apparently so.
19:44:04 <d-snp> damn
19:44:05 <startling> I irc in telnet
19:44:08 <d-snp> I can't irc in my vim :(
19:44:09 <mekeor> hehe
19:44:14 <EvanR> > Identity 9
19:44:15 <mkCurry> Can you IRC outside of Emacs?
19:44:16 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity t))
19:44:16 <lambdabot>    arisi...
19:44:21 <mekeor> callen: i don't know elisp that much.
19:44:23 <fragamus> This infinite list thing helps so much
19:44:34 <callen> mekeor: what i was talking about had little/nothing to do with elips.
19:44:38 <callen> elisp*
19:44:41 <mekeor> fragamus: yeah.
19:45:14 * mekeor hits callen. just for fun.
19:45:19 <EvanR> elips, an IDE for everything but C
19:45:40 <startling> and E
19:45:46 <EvanR> haha
19:46:01 <EvanR> no it works with e
19:46:03 <startling> well, the second one I guess
19:46:22 <startling> E 1.0 only
19:46:48 <startling> oh I'm thinking of D
19:46:50 <startling> oh well
19:47:32 <EvanR> evolution of programming languages... algol, B, C, D, E, F#, Go, Haskell, Io, J, K, Lisp, ML...
19:48:15 <mkCurry> EvanR: Why does that evolution look like a Parabola to me?
19:48:33 <EvanR> haha
19:48:55 <startling> mkCurry, evolution doesn't go for superiority
19:48:58 <EvanR> it looks like a delta function to me
19:49:00 <startling> it goes for "good enough"
19:49:08 <startling> I think java should be at the end there somewhere
19:49:30 <nand`> EvanR: haha
19:49:38 <mkCurry> startling: Ahhh, yes, as the masses flooded the computing industry, survival of the fittest required medicorecy.
19:49:40 <nand`> EvanR: doesn't it to everybody?
19:49:51 <mkCurry> BTW, ispell doesn't seem to be loaded on this machine, so I'm not going to try to spell.
19:49:54 <nand`> only difference being where the origin is
19:50:00 <EvanR> lol
19:50:02 <callen> mkCurry: easy with the elitist talk, you might remind people you're a haskell programmer.
19:50:35 * callen throws a grenade at mekeor
19:50:39 <mkCurry> callen: One has to write Haskell to be a Haskell programmer. I'm more of an evangalist.
19:50:51 <callen> mkCurry: all the more arrogant then!
19:50:57 <callen> just as well.
19:51:16 <mkCurry> callen: They make me write Python at work.
19:51:30 <EvanR> mkCurry: if youre not careful, youll end up writing a monad tutorial such as this one http://the-27th-comrade.appspot.com/blog/ahJzfnRoZS0yN3RoLWNvbXJhZGVyDAsSBUVudHJ5GOFdDA
19:51:36 <callen> mkCurry:  I willingly write Python at work. It's fine for what we're doing.
19:52:04 <EvanR> you can avoid it by writing some haskell
19:52:10 <mkCurry> callen: It's not fine for what we're doing :) It takes us 30 minutes to run the app, and we find the syntax errors around 29:59 :)
19:52:25 <callen> mkCurry: that's your retardation, not Python's :P
19:52:32 <startling> are there python combinators for haskell?
19:52:35 <startling> that would be interesting
19:53:17 <jmcarthur> what's a python combinator?
19:53:20 <mkCurry> EvanR: I swear I've seen that image before.
19:53:27 <startling> combinators for writing python in haskell
19:54:00 <jmcarthur> i don't know of any, but there is this, which should make it pretty easy to make some: http://hackage.haskell.org/package/language-python
19:54:17 <levi> Isn't that what do notation is? :P
19:54:21 <EvanR> python monad
19:54:26 <EvanR> theres already a BASIC monad
19:54:52 <EvanR> we already have the C monad... IO ;)
19:54:53 <jmcarthur> i love how the BASIC monad is actually competitive with C
19:55:01 <jmcarthur> despite all the layers of abstraction
19:55:11 <jmcarthur> *semi-competitive, to be fair
19:55:14 <mkCurry> jmcarthur: Hmmm... Maybe we should run this on our Python code before running it, so we can find the syntax errors :)
19:55:20 <jmcarthur> ha
19:55:40 <EvanR> python finds syntax errors at run time?
19:55:55 <mkCurry> EvanR: Yes.
19:55:58 <EvanR> :|
19:56:05 <jmcarthur> yeah it would be more interesting to use that library for some sort of model checking algorithm
19:56:07 <slack1256> jmcarthur: is that so? is there a benchmark or is your experience that tells you?
19:56:19 <mkCurry> EvanR: To be fair, you can write Python that doesn't do that.
19:56:25 <nand`> I wouldn't call myself a Haskell elitist, it's just that I'm too stupid to program in any other languages
19:56:35 <EvanR> haha
19:56:41 <jmcarthur> slack1256: http://augustss.blogspot.com/2009/02/is-haskell-fast-lets-do-simple.html
19:56:44 <nand`> they make no sense to me
19:56:50 <mkCurry> We have a saying at work. Perl is superior to Python, in that no one would mistaken Perl for a programming language.
19:56:51 <slack1256> nand`: get on my level. I only know haskell.
19:57:16 <EvanR> nand`: i get so flamed for saying imperative code is hard to understand
19:57:37 <jmcarthur> i also believe that imperative code is hard to understand
19:58:13 <nand`> EvanR: on a somewhat related note, whenever I try to make heavy use of the state monad in modelling algorithms they tend to get out of hand and prone to bugs and other unforeseen conditions
19:58:17 <nand`> I try to avoid it as much as possible
19:58:22 <mkCurry> jmcarthur: We do code reviews. At first my reviewers were skeptical of the currying library in Python, but now they love it.
19:58:25 <nand`> but my preconditioned mind wants to use it :(
19:59:02 <EvanR> ive never found an actual use for State
19:59:21 <EvanR> so far
19:59:25 <EvanR> id certainly love to
19:59:57 <nand`> EvanR: I tend to make use of it for interactive programs
19:59:59 <jmcarthur> mkCurry: i'm fortunate enough to work in a culture where imperative code is often considered harder to understand than purely functional code
20:00:07 <EvanR> i use IO for that
20:00:09 <nand`> (which I hate writing, mind)
20:00:12 <slack1256> EvanR: i mostly use it for pseudoRandom number propagation.
20:00:29 <EvanR> for that i use random monad or IO
20:00:30 <jmcarthur> mkCurry: but at my last job i think i would never have been able to sell something like that
20:00:32 <mkCurry> jmcarthur: They do have a point. They haven't seen it before. Therefore it's harder to understand :)
20:00:33 <nand`> EvanR: well, it usually boils down to something like ReaderT Config (StateT Foo IO)
20:00:55 <EvanR> nand`: well, you can avoid the StateT by putting IORefs or MVars or whatever in the reader
20:01:15 <nand`> I don't see much of an improvement in doing that
20:01:28 <EvanR> less lifting
20:02:22 <callen> I've found that whnever I use cabal to install somehthing, I get less nervous if I go to a different terminal.
20:02:33 <EvanR> lol
20:03:11 <mkCurry> Alright. Thanks everyone. Later!
20:03:14 <mkCurry> :quit
20:03:31 <MagneticDuck> x)
20:03:36 <MagneticDuck> ./quit
20:03:40 <fragamus> Without lazy evaluation I think fp would suck hard
20:03:55 <jmcarthur> i disagree
20:03:57 <MagneticDuck> probably
20:04:14 <jmcarthur> don't get me wrong. i love lazy evaluation, but it has nothing on purity.
20:04:19 <MagneticDuck> well, I sure wouldn't like haskell so much without laziness!
20:04:46 <EvanR> scheme is still way ahead of imperative
20:04:47 <jmcarthur> me either, but that is different from it "sucking"
20:05:10 <EvanR> even functional javascript is way ahead of imperative
20:05:41 <callen> _.map
20:05:54 <EvanR> underscore gets a few things wrong
20:06:00 <callen> my employees get so fucking mad when I abuse underscore.
20:06:04 <EvanR> but its a good try
20:06:08 <callen> EvanR: no doubt.
20:06:53 <callen> EvanR: you wouldn't believe the unholy things I do in _.template
20:07:04 <callen> shit's hilarious.
20:07:13 <EvanR> i deleted all underscore template code
20:07:21 <EvanR> because of how horrible that library is
20:07:35 <fragamus> Because there would be no way to have infinite lists in imperative Lang
20:07:44 <callen> EvanR: it's awful enough that I wonder if it was designed to punish people on purpose.
20:07:48 <EvanR> now i use dom combinators
20:07:49 <callen> fragamus: that's...not true.
20:08:14 <EvanR> fragamus: well ruby gets by with 'enumerators'
20:08:31 <EvanR> [1,2,3].cycle is almost like haskell cycle [1,2,3]
20:09:42 <callen> EvanR: I prefer declarative data binding.
20:09:48 <slack1256> fragamus: you can have "infinite" data structures in imperative langs.
20:10:02 <slack1256> the think is that they aren't as straight fowards.
20:10:04 <callen> fragamus: you're a little too religious m'boy.
20:10:07 <EvanR> callen: yeah templates are just functions, so you can compose templates by composing functions
20:10:12 <callen> fragamus: take it down a notch.
20:10:19 <callen> EvanR: makes sense, pretty cool.
20:10:26 <callen> EvanR: I'm looking at jQuery-combinators right now.
20:10:30 <EvanR> hmm
20:10:59 <slack1256> if we want to grow as a community, we need to keep an eye on fanboism, an recheck our argument every couple of months
20:11:09 <slack1256> or else this will end as comp.lang.lisp
20:11:13 <callen> I agree with slack1256
20:11:19 <EvanR> monad tutorials
20:11:19 <callen> slack1256: god don't get me started on comp.lang.lisp.
20:12:24 <VitamnP> if it aint lisp its crap
20:12:35 <EvanR> i miss the lispers who used to come in here and explain why lists are better in lisp
20:13:58 <VitamnP> could someone help me out with a conceptual problem I'm having? Learning Haskell here...
20:14:04 <callen> EvanR: I'm a lisper. What sort of arguments would they make?
20:14:15 <EvanR> im just talking shit at this point
20:14:20 <callen> EvanR: I can tell.
20:14:21 <slack1256> VitamnP: tell us :-)
20:14:29 <callen> EvanR: want to join fragamus in putting your nose in the corner? :P
20:14:34 <callen> VitamnP: don't ask to ask, just ask.
20:14:34 <EvanR> but you can have hetero lists in lisp
20:14:43 <mapreduce> @google HList
20:14:45 <lambdabot> http://homepages.cwi.nl/~ralf/HList/
20:14:45 <lambdabot> Title: Strongly typed heterogeneous collections
20:14:48 <hpaste> me pasted “gol” at http://hpaste.org/72673
20:14:51 <callen> EvanR: and?
20:14:58 <callen> EvanR: that's a necessity of the design of the language.
20:15:04 <EvanR> any size tuples
20:15:05 <VitamnP> Well, I have this code for Conways GoL
20:15:12 <VitamnP> http://hpaste.org/72673
20:15:22 <mapreduce> HList also covers any size tuples
20:15:36 <callen> mapreduce: we're not actually interested in answers, i think.
20:15:37 <VitamnP> and I know making world a global isnt going to work because of no destructive updates etc
20:15:41 <callen> mapreduce: he's strawmanning lispers.
20:15:46 <mapreduce> Ok.
20:15:47 <EvanR> i need my logs ;)
20:15:52 <callen> mapreduce: thank you though.
20:15:54 <mapreduce> In which case..
20:16:07 <slack1256> VitamnP: right.
20:16:16 <mapreduce> (defun (f x)) (f f x)) 'can't write this in Haskell
20:16:16 <VitamnP> but I want to keep those functions having only one argument because then i can map, filkter with them etc
20:16:27 <callen> VitamnP: percolate the data through a chain of functions.
20:16:43 <VitamnP> so i don't want to pass in a list of points... how would you do something like this in haskell, whats the idiom?
20:17:10 <shachaf> Are you people still having the Haskell Lisp Emacs Vim editor language wars? :-(
20:17:26 <mapreduce> Spaces > tabs
20:17:30 <VitamnP> if u kind of understand what im saying...
20:17:44 <callen> mapreduce: agreed.
20:18:05 <EvanR> tabs should be deleted forever
20:18:14 <EvanR> and the tab key renamed to autocomplete
20:18:55 <EvanR> and all legacy text files converted to 8 spaces !!!!!
20:19:08 <mapreduce> Hard tabs are still the default in both Eclipse and Visual Studio afaik.  New legacy files will be created tomorrow.
20:19:37 <slack1256> VitamnP: I don't think I understand.
20:21:55 <zzing_> Can I model a process that takes an input data structure and has the most efficient operations being modifications of existing structures during a transaction, and finally returning a final copy that is distinct from the input?
20:21:59 <VitamnP> Ahh... well, see how I use world in the "alive" fn? I could pass that in as a parameter, but then I couldn't use filter on lists of coords
20:22:26 <EvanR> zzing_: maybe acid state?
20:23:06 <VitamnP> is there some way of having a reference to the list containing a thing "inside" the thing? or is that not the right way fo thinking about it
20:23:07 <zzing_> EvanR, that looks complicated
20:23:38 <EvanR> well he did what you said, and now its a library
20:23:46 <VitamnP> I don't really know what I'm talking about either tbh
20:24:17 <EvanR> VitamnP: a pointer?
20:24:26 <VitamnP> yeah something like that
20:24:41 <EvanR> yech
20:24:45 <VitamnP> I guess what I want is a graph and its hard to see how to make one without pointers
20:25:00 <EvanR> theres a graph library ...
20:25:15 <BMeph> Vitamn: Are you familiar with Zippers?
20:25:24 <slack1256> EvanR: that might be an overkill.
20:25:31 <VitamnP> no... what's that?
20:25:42 <EvanR> zippers might be overkill?
20:25:42 <VitamnP> would it be in Learn You a Haskell?
20:25:57 <EvanR> use a table of vertexes ;)
20:26:02 <slack1256> EvanR: no the FGL might be an overkill
20:26:41 <BMeph> @google sigfpe zipper
20:26:42 <lambdabot> http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html
20:28:06 <BMeph> That might be giving it away; maybe the H-wiki would be better.
20:28:38 <VitamnP> thanks
20:29:41 <VitamnP> no problem, the thing is I don't really have the vocab or knowledge to explain what I wnt to know :)
20:29:52 <VitamnP> I'll get there in the end though
20:30:06 <EvanR> im writing a mud
20:30:30 * hackagebot snaplet-typed-sessions 0.5 - Typed session snaplets and continuation-based  programming for the Snap web framework (ChrisSmith)
20:30:32 <callen> EvanR: I'm writing a dust.
20:30:34 <EvanR> and the room connections are implemented as a relational data set
20:30:43 <EvanR> instead of a graph
20:30:55 <callen> EvanR: that's a good idea.
20:31:25 <EvanR> hope that helps VitamnP, though i have no idea what hes doing
20:31:57 <VitamnP> thanks, just googled
20:32:04 <EvanR> ixset
20:32:06 <slack1256> VitaminP from where are learning?
20:32:07 <EvanR> for example
20:32:34 <VitamnP> Learn You a Haskell, altho it's pretty boring
20:32:53 <VitamnP> I got this book from the uni library today though, "The Haskell School of Expression"
20:32:57 <slack1256> VitamnP: I am the author :S
20:33:10 <VitamnP> oh man be g pardon lol
20:33:14 <slack1256> VitamnP: I am kidding, i am kidding.
20:33:20 <VitamnP> haha
20:33:45 <VitamnP> i just find its throwing big lists of syntax at me instead of showing me examples of working code
20:34:59 <slack1256> VitamnP: well that like every programming language book ever
20:35:11 <EvanR> is learn you a haskell kind of like whys guide?
20:35:25 <slack1256> do exercises. (project euler). when you hit a wall check a book or a blogpost and repeat
20:35:38 <startling> no, _why's guide is much crazier
20:35:58 <EvanR> i actually tried that to learn ruby
20:35:59 <slack1256> _why's has some cool side stories.
20:36:02 <VitamnP> http://www.amazon.com/The-Haskell-School-Expression-Programming/dp/0521644089
20:36:05 <EvanR> i never got to any ruby code
20:36:08 <VitamnP> I quite like the look of this
20:36:26 <EvanR> i do too
20:36:27 <VitamnP> might go and do some now, thanks for the help and encouragement
20:38:08 <sentientwaffle> when should I be using Integer vs Int?
20:38:14 <slack1256> Learn you a haskell is a haskell introductory book disguised as a children book
20:38:30 <EvanR> always use Integer ;)
20:38:44 <slack1256> sentientwaffle: Integer when you want infinite precision
20:38:51 <mapreduce> > maxValue :: Int
20:38:52 <lambdabot>   Not in scope: `maxValue'
20:39:00 <Clint> > maxBound :: Int
20:39:01 <lambdabot>   9223372036854775807
20:39:04 <slack1256> > :t 2^65
20:39:05 <lambdabot>   <no location info>: parse error on input `:'
20:39:14 <slack1256> @type 2^65
20:39:15 <lambdabot> forall t. (Num t) => t
20:39:18 <mapreduce> > maxBound :: Integer
20:39:20 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
20:39:20 <lambdabot>    arising from...
20:39:36 <EvanR> > genericLength (replicate 92233720368547758070 ()) :: Integer
20:39:37 <slack1256> > 2^65 :: Integer
20:39:38 <lambdabot>   0
20:39:38 <lambdabot>   36893488147419103232
20:39:44 <slack1256> > 2^65 :: Int
20:39:44 <sentientwaffle> slack1256, EvanR: everything seems to take integer, except "length" returns Int...
20:39:45 <lambdabot>   0
20:39:54 <EvanR> :t genericLength
20:39:56 <lambdabot> forall b i. (Num i) => [b] -> i
20:40:47 <slack1256> sentientwaffle: that just in ghci where all numeral are redefined on demand (is that the correct phrasing?)
20:40:51 <EvanR> > genericLength (genericReplicate 92233720368547758070 ()) :: Integer
20:40:53 <lambdabot>   *Exception: stack overflow
20:40:57 <EvanR> o_O
20:41:42 <callen> lol.
20:41:47 <latro`a> wow what
20:41:52 <latro`a> why isn't genericLength a foldl'?
20:42:00 <EvanR> it cant be
20:42:04 <latro`a> ...because then you couldn't get the length of a list of undefined?
20:42:09 <EvanR> it has to work for any Num
20:42:12 <Nereid> latro`a: you could
20:42:15 <Nereid> > genericLength (genericReplicate 1000000 ())
20:42:17 <lambdabot>   *Exception: stack overflow
20:42:30 <latro`a> why is that a problem EvanR
20:42:37 <EvanR> nevermind
20:42:41 <EvanR> @src genericLength
20:42:42 <lambdabot> genericLength []    = 0
20:42:42 <lambdabot> genericLength (_:l) = 1 + genericLength l
20:42:57 <slack1256> @type 5
20:42:58 <lambdabot> forall t. (Num t) => t
20:43:05 <slack1256> @type 5 :: Double
20:43:07 <lambdabot> Double
20:43:12 <slack1256> @type 5 :: Int
20:43:13 <lambdabot> Int
20:43:16 <EvanR> :t 5.0
20:43:17 <lambdabot> forall t. (Fractional t) => t
20:43:33 <EvanR> :t 5/1
20:43:34 <lambdabot> forall t. (Fractional t) => t
20:43:43 <Nereid> > foldl' (const . (+1)) 0 (genericReplicate 1000000 ())
20:43:46 <lambdabot>   1000000
20:43:52 <Nereid> easy
20:44:20 <EvanR> > foldl' (const . (+1)) 0 (genericReplicate 92233720368547758070 ()) :: Integer
20:44:24 <lambdabot>   mueval-core: Time limit exceeded
20:44:29 <Nereid> duh
20:44:30 <Nereid> :P
20:44:42 <EvanR> computer is too slow
20:45:17 <EvanR> so 64bit Int is enough
20:45:20 <EvanR> for anybody ;)
20:45:32 <slack1256> all I know is that lambdabot is throwing smoke in some foreign country for our fault
20:45:41 <colock> anyone no testing 64bit limits ? :P
20:46:10 <slack1256> EvanR: don't make me do a "yo' mama" joke about it.
20:46:41 <EvanR> your mom is so fat she cant represent her weight with an unsigned 64bit int
20:53:32 <roconnor> EvanR: Word
20:53:34 <roconnor> 64
21:03:31 <mekeor> can i somehow call a function and cancel the execution of the function if it takes too long (and use another value instead)?
21:04:21 <Targen> mekeor: System.Timeout.timeout might interest you.
21:04:26 <shachaf> @hoogle timeout
21:04:27 <lambdabot> System.Timeout module System.Timeout
21:04:27 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
21:04:27 <lambdabot> System.Event type TimeoutCallback = IO ()
21:04:30 <slack1256> mekeor: if you do it in the IO () monad maybe if you execute it in another thead and check and kill it after
21:04:41 <shachaf> IO () isn't a monad.
21:04:53 <mekeor> oO
21:04:55 <mekeor> anyway.
21:05:00 <slack1256> shachaf: in the IO monad then
21:05:01 <mekeor> so, timeout is what i want?
21:05:13 <mekeor> thanks :)
21:05:31 <shachaf> mekeor: Only you know what you want. timeout is what's available, though.
21:05:35 <Targen> Is there some way to avoid having to liftIO every IO action when using a monad transformer stack based on IO?
21:05:41 <mekeor> actually, the function is non-monadic.
21:05:48 <mekeor> but i could do (return . f), right?
21:06:06 <slack1256> yes
21:06:09 <mekeor> nice.
21:06:18 <Targen> “liftIO $ putStrLn this”, “liftIO $ forkIO that”, etc — it’s getting pretty tedious.
21:07:03 <shachaf> Targen: Are you sure you need to be doing that?
21:07:13 <startling> Targen, maybe <$> and <*> could help? No idea if this monad transformer is a functor and/or applicative, but it helps for liftM et al
21:07:34 <shachaf> What do <$> and <*> have to do with it?
21:07:41 <liyang> There's http://hackage.haskell.org/package/lifted-base .
21:07:49 <Targen> I could work around it, I suppose.
21:07:56 <startling> liftIO <$> forkIO that <- is what I meant
21:08:05 <startling> errrr
21:08:16 <startling> forkIO that <$> something else
21:08:28 <liyang> I don't know why System.IO isn't in lifted-base. Probably never got around to it.
21:08:36 <Targen> liyang: Oh, that’s wonderful.
21:09:24 <shachaf> Having everything in MonadIO/MonadBase/etc. seems somehow terrible to me. :-(
21:09:36 * shachaf is just a h8r (of monad transformers).
21:31:48 <shachaf> Cale: What's the probability that you'll move to Boston?
21:37:04 <dfeuer> Why doesn't GHC give meaningful syntax error messages?
21:37:27 <startling> dfeuer: that bugs me too. it's pretty silly, isn't it?
21:37:29 <dfeuer> "Parse error on whatever line so-and-so" is about the best you can hope for.
21:38:05 <dfeuer> I've even gotten to the point where the type checker errors are sometimes easier for me to puzzle out, and that sure does say a lot.
21:38:13 <startling> a clang-style arrow pointing to the error would be helpful, at the least
21:38:50 <callen> startling: dude. clang. that errorreporting is glorious.
21:39:17 <shachaf> edwardk was working on a fancy type error slices thing once.
21:40:31 * hackagebot system-time-monotonic 0.1 - Simple library for using the system's monotonic clock (JoeyAdams)
21:43:20 <startling> shachaf, yeah, trifecta! I use it
21:43:28 <startling> callen: indeed. it makes C so much easier
21:43:59 <shachaf> startling: No, not (just) trifecta.
21:44:23 <callen> startling: it really...really does.
21:44:23 <startling> shachaf: o rly. A general error-reporting thing?
21:44:37 <callen> startling: clang was a massive improvement to my quality of life when I'm futzing around in C. That and valgrind.
21:44:40 <callen> my fucking god valgrind.
21:45:26 <startling> yeah, valgrind is pretty useful too. Did people just like, wonder if they had leaks before that?
21:45:51 <shachaf> startling: No, a Haskell type checker.
21:46:20 <callen> shachaf: what happened to it and what is it called?
21:46:22 <callen> shachaf: I can't find it.
21:46:57 <startling> shachaf, oh, I misunderstood
21:47:12 <callen> https://github.com/ekmett/reflection this is cool though.
21:53:39 <startling> indeed: https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
21:55:30 * mgsloan has been digging into Lens.  Why do I get the feeling that ekmett just wrote the new prelude, for a more civilized era? ;)
21:59:44 <dibblego> Ed's Control.Lens is pretty darn awesome
22:02:13 <mgsloan> Yup.  Almost too awesome.  The core type synonyms really seem "right" - you can't really argue with them
22:05:32 * hackagebot egison 2.4.0 - An Interpreter for the Programming Language Egison (SatoshiEgi)
22:41:06 <shachaf> cabal: The following packages are likely to be broken by the reinstalls:
22:41:07 <shachaf> ghc-7.4.1
22:41:15 <shachaf> I think this has to do with containers-0.5.0.0
22:41:24 <shachaf> Is there a standard thing to do about that?
22:44:13 <shachaf> template-haskell-2.7.0.0 (reinstall) changes: containers-0.4.2.1 -> 0.5.0.0
22:45:49 <shachaf> "With containers being a dependency of GHC core libraries such as template-haskell, there isn't currently a good option to use containers-0.5.0.0 with ghc-7.4."
22:45:52 <shachaf> Hmm.
22:47:27 <shachaf> edwardk: Is the test suite for "text" supposed to be usable with GHC 7.4?
22:47:51 <edwardk> ?
22:47:59 <edwardk> dunno
22:48:12 <edwardk> where was that said?
22:48:28 <shachaf> It wasn't said.
22:48:40 <shachaf> But I assumed it would work...
22:48:49 <shachaf> I'm getting issues with "containers".
22:49:45 <shachaf> I thought something was messed up with my installation but I'm not sure how this is supposed to work at all now.
22:50:42 <callen> edwardk: did you write some sort of clang'ish type checker?
22:50:51 <callen> edwardk: shachaf was taunting me earlier with such.
22:51:04 <edwardk> oh the type error slicer?
22:51:12 <callen> edwardk: yes prz.
22:51:16 <edwardk> or the trifecta diagnostics?
22:51:22 <callen> edwardk: former
22:51:28 <callen> I already has trifecta.
22:51:33 <edwardk> ah
22:51:41 <edwardk> i haven't released the slicer yet
22:51:47 <callen> edwardk: github?
22:51:51 <edwardk> not yet
22:52:03 <edwardk> still local til i can figure out how to make it fit with revisions
22:52:08 <callen> edwardk: you're killin' me homes.
22:52:12 <callen> or slicin', as the case may be.
22:52:15 <edwardk> =P
22:53:10 <edwardk> i'm still trying to resolve a number of issues with the approach in the presence of higher rank types
22:53:25 <startling> edwardk, how would you feel about a mapLeft in bifunctor?
22:53:26 <MostAwesomeDude> edwardk: Parsing things, I have global directives that ideally would go at the top but could be found anywhere. Any special advice?
22:53:36 <edwardk> startling: isn't that 'first'?
22:53:49 <MostAwesomeDude> I was gonna just put them into my AST and then use my AST tools to dig them out later.
22:54:04 <startling> edwardk, Control.Arrow.first?
22:54:10 <edwardk> MostAwesomeDude: you could use a writer or something to collect them
22:54:15 <edwardk> no bifunctor first
22:54:19 <startling> edwardk: oh what
22:54:26 <startling> oops
22:54:41 <MostAwesomeDude> edwardk: Mm, Writer. Does that actually work in Trifect-land though?
22:54:51 <edwardk> http://hackage.haskell.org/packages/archive/bifunctors/3.0/doc/html/Data-Bifunctor.html
22:55:03 <edwardk> MostAwesomeDude: sure just apply a monad transformer
22:55:07 <startling> edwardk: somehow missed that. thanks!
22:55:07 <edwardk> trifecta works under transformers
22:55:23 <MostAwesomeDude> edwardk: Okay, I could see that. Thanks.
22:57:26 <edwardk> oh, as a side note, i figured out how to get nicer error messages out of lens
22:58:10 <edwardk> so it says 'no instance of Gettable Mutator' when you try to write to a getter, etc.
22:58:25 <edwardk> rather than give a huge unification error
22:58:36 <shachaf> hugenification
22:58:40 <shachaf> How?
22:58:43 <MostAwesomeDude> Nice.
22:58:48 <edwardk> unification succeeds, then type class inference fails ;)
22:58:52 <edwardk> the latter gives nicer errors
22:59:39 <edwardk> basically type Getter a c = forall f b d. Gettable f => (c -> f d) -> a -> f b  -- unifies with the type for Setter
22:59:48 <edwardk> but the Gettable constraint can't be satisfied
22:59:58 <edwardk> so that is what whines not the whole type
23:00:31 <MostAwesomeDude> Hm. So is Gettable a relatively empty class then?
23:00:32 <edwardk> should make a HUGE difference in the quality of the error messages it gives
23:00:46 <edwardk> class Functor f => Gettable f where coerce :: f a -> f b
23:00:54 <edwardk> its an 'anyvariant' functor
23:02:17 <MostAwesomeDude> Tricky.
23:02:22 <edwardk> instance Gettable (Accessor r) where coerce (Accessor r) = Accessor r
23:02:35 <edwardk> oh, and i have traversals using ghc.generics now that are pretty sweet
23:03:22 <edwardk> allOf gtraverse (=="Hello") (1::Int,2::Double,(),"Hello",["Hello"])
23:03:28 <edwardk> will find the "Hello"s
23:03:42 <edwardk> ghci> mapMOf_ gtraverse putStrLn ("hello",[(2 :: Int, "world!")])
23:03:45 <edwardk> will find and print them
23:03:48 <shachaf> Ah, adding a constraint: containers < 0.5 to my ~/.cabal/config seems to make it work.
23:05:37 <edwardk> i mostly just like that it makes generic programming suck a lot less ;)
23:05:42 <edwardk> because you can use combinators you already know
23:06:51 <Ram_> hi
23:07:04 <shachaf> hi Ram_
23:07:18 <Ram_> i just heart about haskell today
23:07:30 <Ram_> whats the power of this language
23:07:36 <shachaf> @where faq
23:07:37 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
23:07:41 <shachaf> @where haskell
23:07:41 <lambdabot> http://haskell.org
23:07:47 <shachaf> Those pages will probably be helpful. :-)
23:08:05 <Ram_> Thanks
23:08:17 <srhb> In case anyone missed it, Curiosity landed about half an hour ago and is alive and well. <<
23:08:35 <shachaf> It would be seem to be difficult to miss!
23:08:35 * srhb is telling all her friends, most of which just don't care, the uncouth barbarians. ._.
23:08:39 <ion> was
23:08:51 <edwardk> in other news, the actions are proving to possibly be more trouble than they are worth
23:08:51 <edwardk> srhb: yeah reddit noticed a while ago
23:08:58 <Jafet> Perhaps they are...
23:09:01 <Jafet> incurious
23:09:04 <ion> The Martian Homeland Defense System might have destroyed it already.
23:09:07 <shachaf> #haskell-blah is all about it!
23:10:18 <zzing_> Does anyone know how to make sure GLFW-b creates an opengl 3.2 context?
23:21:25 <madtusker> Hi there
23:21:31 <srhb> madtusker: Hi
23:22:03 <madtusker> first time to this channel…i am new to Haskell
23:22:10 <srhb> madtusker: Welcome :)
23:22:21 <madtusker> thanks :)
23:37:42 <ezyang> In what sense is the universal property of folds "unique"?
23:38:13 <ezyang> The intuitive sense, which is that 'fold f v' is the unique solution for the equations, doesn't seem to be quite right (since I could have just added a bunch of junk to the solution..)
23:38:27 <edwardk> fold in the Data.Foldable sense?
23:38:37 <edwardk> or fold in the catamorphism sense?
23:38:38 <shachaf> What's the universal property of folds?
23:38:46 <ezyang> Catamorphism sense
23:38:50 <edwardk> there is a nice commutative diagram
23:39:00 <ezyang> I'm referring to Graham Hutton's tutorial on the universality of fold
23:39:19 <ezyang> OK, I guess we can put it in category theory and shake it out from there. Let me see if I can draw it...
23:39:32 <edwardk> http://comonad.com/haskell/catamorphisms.html
23:39:40 <edwardk> look at the first diagram
23:39:47 <edwardk> that is the reason it is unique
23:40:47 <ezyang> Oh, it's that diagram! I remember using it to prove the Lambek lemma, right?
23:41:10 <edwardk> don't recall
23:41:15 <edwardk> probably
23:41:28 <edwardk> yeah
23:41:56 <edwardk> took me a minute to page back in the lambek lemma ;)
23:42:06 * ezyang attempts to translate into layman terms 
23:43:30 <ezyang> Dammit, it's so clear in category theory, and so muddy without it >_<
23:43:37 <edwardk> ha
23:44:29 <edwardk> In . out = id; out . In = id ;)
23:45:13 <ezyang> OK, maybe here is where I am tripping up: why does a commuting diagram imply the homomorphism is unique?
23:46:23 <edwardk> well, its a homomorphism from an initial algebra no?
23:46:36 <edwardk> there is a word in that sentence that implies a bit of uniqueness ;)
23:52:22 <edwardk> did that help?
23:52:51 <ezyang> "initiality, right?"
23:52:58 <edwardk> yeah
23:53:12 <ezyang> Hmm, my initial algebra intuition must be a little off then.
23:53:57 <edwardk> start with an initial algebra In :: f (Mu f) -> Mu f
23:54:46 <ezyang> OK, I need to just ponder this a little :-)
23:54:50 <edwardk> now given any other f-algebra (X,phi), there is a unique homomorphism from (Mu f, In) to (X, phi)
23:55:30 <edwardk> we name that morphism cata phi
23:55:43 <ezyang> Right.
23:56:31 <ezyang> OK, so I think I'd like to answer: (1) what is an example of an object that looks initial, but actually isn't, and (2) how do you prove that something is initial?
23:56:38 <edwardk> and we can name it because it is uniquely determined by initiality and since its an algebra homomorphism we get cata phi . In = phi . fmap (cata Phi)
23:56:55 <ezyang> I guess for (1), that's easy, two objects with two distinct morphisms A -> B
23:56:57 <edwardk> prove that there exists a unique arrow to any other such thing
23:58:02 <ezyang> And we show uniqueness by showing that if I have two arrows that fulfill the property, they are actually equal
23:58:09 <edwardk> yep
23:58:16 <edwardk> done
23:58:58 <ezyang> Do we ever use diagram arguments for that? (Or is it usually just a term rewriting proof)
23:59:16 <edwardk> dunno. i'm not a category theorist
23:59:28 <edwardk> i just like the pretty pictures ;)
