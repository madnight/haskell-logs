00:06:48 <hpaste> randomclown pasted “lisp” at http://hpaste.org/73270
00:07:08 <randomclown> what would be the best way to rewrite that lisp code in haskell?
00:07:45 <shachaf> What is that Lisp code trying to do?
00:07:53 <shachaf> Evaluate an AST?
00:08:15 <randomclown> derives a mathmatical expression
00:08:20 <shachaf> Oh, differentiate.
00:08:32 <shachaf> There are various ways.
00:08:39 <augur> shachaf: is that what hes asking tho
00:08:40 <shachaf> @google haskell automatic differentiation
00:08:42 <lambdabot> http://www.haskell.org/haskellwiki/Automatic_Differentiation
00:08:42 <lambdabot> Title: Automatic Differentiation - HaskellWiki
00:08:50 <randomclown> so in the end you still have a variable x so you can apply it to the function
00:08:51 <augur> oh yes, it is :)
00:09:20 <augur> randomclown: the lisp code is just doing symbolic manipulation of equations
00:09:31 <augur> or expressions, rather
00:09:37 <augur> you can represent expressions in haskell
00:09:45 <augur> so you just need to port the code
00:10:18 <shachaf> > deriv (\x -> sin x + x^3) 5
00:10:19 <lambdabot>   75.28366218546323
00:11:21 <mauke> > deriv (sin + (^3)) 5
00:11:22 <lambdabot>   75.28366218546323
00:11:27 <mauke> > deriv (sin + (^3)) x
00:11:29 <lambdabot>   1 * cos x + ((1 * x + x * 1) * x + x * x * 1)
00:13:20 <augur> randomclown: ive annotated your paste
00:13:27 <augur> thats where you should start
00:14:01 <randomclown> what's the (:+:)
00:14:04 <shachaf> You could start there, or you could do it the way people have just mentioned.
00:14:12 <randomclown> is that just the name
00:14:16 <shachaf> Yes.
00:14:18 <augur> randomclown: an infix constructor
00:14:20 <shachaf> :+: is like '+
00:14:34 <augur> instead of writing something like   Plus Expr Expr
00:14:46 <shachaf> Or, rather, (foo :+: bar) is like `(+ ,foo ,bar)
00:15:13 <augur> or like   (define (plus x y) (list '+ x y))!
00:15:40 * augur is a schemer
00:15:55 <shachaf> augur: I think you're answering the wrong question, though.
00:16:03 <shachaf> We don't know what randomclown actually wants to do.
00:16:15 <augur> shachaf: from the looks of it he wants to know how to translate that code
00:16:22 <augur> and then, from there, to learn about more advanced techniques
00:16:47 <augur> i say that because he asked "what would be the best way to rewrite that lisp code in haskell?"
00:16:48 <augur> :P
00:16:55 <shachaf> augur: "how to translate that code" is a low-level question.
00:17:04 <augur> yes it is, and im trying to answer it
00:17:11 <augur> theres nothing wrong with low-level questions
00:17:22 <shachaf> Yes there is.
00:17:25 <augur> no there isnt.
00:17:29 <shachaf> Or, rather, there's something wrong with low-level answers.
00:17:36 <augur> shachaf: no, there isnt.
00:17:53 <augur> its often VERY useful to get your feet wet with something by understanding some simple examples
00:17:59 <shachaf> OK, a lower-level answer would involve a whole lot of Dynamic, or writing half a Lisp evaluator, or something.
00:18:12 <shachaf> augur: That's the sort of thing a linguist would say.
00:18:28 <augur> its no use telling him to go read about fancy differentiation techniques in haskell if he doesnt even understand the simplest techniques
00:18:42 <randomclown> So I'll still need an eval functions in the end that'll return a value
00:18:59 <shachaf> augur: No, but it's a lot of use to have a high-level understanding of what the code is trying to accomplish.
00:19:00 <augur> randomclown: well, if you want to just do symbolic differentiation, no
00:19:30 <shachaf> Yes.
00:19:35 <augur> but if you want to then implement something like df/dx (4)  or something, yes
00:20:18 <augur> randomclown: theres a difference between manipulating equations, and using equations. eval is about using equations.
00:20:52 <shachaf> There have been no equations mentioned so far.
00:20:53 <augur> expressions*
00:21:12 <edsko> what is type ->>(#,#) in a -hy profile?
00:21:32 <augur> what shachaf gave links to is about just using expressions (native haskell ones) for differentiation and so forth.
00:21:54 <shachaf> augur: That link isn't my answer to the question.
00:22:03 <shachaf> My answer to the question is "What are you actually trying to do?".
00:22:12 <augur> yes i know thank you shachaf
00:22:38 <shachaf> My second answer might well end up being something like your AST (though probably not with Int? Ew, Int).
00:22:58 <augur> its an example, shachaf, chill out.
00:23:18 <shachaf> I AM CHILL
00:25:46 <augur> RELAX MAN FUCKIN RELAX JESUS FUCKING CHRIST
00:27:54 <augur> randomclown: did my annotation make sense?
00:28:21 <randomclown> Yeah algebraic datatypes to express espressions
00:28:30 <randomclown> is that the only way?
00:28:39 <shachaf> randomclown: It's a very sensible way.
00:28:47 <shachaf> What other way do you want?
00:28:58 <shachaf> (Once again, a "what are you trying to accomplish" question. :-) )
00:28:59 <randomclown> Just checking
00:29:33 <shachaf> No, it's not the only way. Of course there are other ways.
00:29:54 <shachaf> You can have arbitrary pseudo-untyped trees like the Lisp code, and keep track of all the invariants in your head.
00:29:57 <augur> randomclown: it depends on your goal!
00:30:21 <augur> randomclown: if your goal is to write a program that can check mathematical reasoning about differentiation, then its probably the best way
00:30:39 <randomclown> Ok this is close enough.
00:30:57 <augur> but if you're trying to write a program that finds derivatives at points, for the purpose of guiding a robot, you'd want to use some other techniques
00:31:41 <augur> but those techniques aren't specific to haskell
00:31:49 <augur> you could implement them in lisp just as well
00:36:38 * hackagebot opentheory-primitive 1.1 - Haskell primitives used by OpenTheory packages (JoeHurd)
00:36:41 * hackagebot opentheory-parser 1.105 - Simple stream parsers (JoeHurd)
00:41:43 * hackagebot opentheory-char 1.30 - Unicode characters (JoeHurd)
00:41:45 * hackagebot opentheory-prime 1.9 - Prime numbers (JoeHurd)
00:42:26 <randomclown> How do I pattern match a constructor that's a symbol?
00:42:43 <augur> randomclown: you mean like the :+: constructor?
00:42:50 <randomclown> yeah
00:42:53 <augur> same as always! foo (x :+: y)
00:43:04 <augur> all constructors are "symbols"
00:43:10 <augur> the only difference is where they appear
00:43:47 <randomclown> right right
00:50:19 <Okasu> why logging in lambdabot doesn't work?
00:50:31 <Okasu> should i somehow enable it in rc?
00:50:43 <shachaf> Yes.
00:50:54 <Okasu> shachaf: how?
00:51:19 <shachaf> Okasu: You can probably figure it out as well as I can...
00:51:28 <shachaf> Look at the sample file, change it as needed.
00:51:53 * hackagebot opentheory 1.61 - The Haskell base (JoeHurd)
00:52:38 <Okasu> shachaf: there is nothing about logging in sample rc
00:52:53 <shachaf> Okasu: Yes there is.
00:52:55 <Okasu> just regular leftover stuff from Cale
00:53:14 <shachaf> The second line in online.rc
00:53:23 <Okasu> rc passwd.rc
00:53:32 <Okasu> http://vpaste.net/aAhDW
00:53:33 <shachaf> Yep.
00:53:41 <shachaf> So put a log-in command in passwd.rc
00:54:07 <Okasu> shachaf: geez, not "log-in" but logging
00:54:55 <shachaf> Oh, by "logging in" you didn't mean logging in.
00:55:05 <shachaf> Yes, the plugin is disabled by default.
00:55:25 <Okasu> shachaf: how can i enamble it?
00:56:04 <shachaf> I don't know. Look at one of the enabled plugins, compare, copy.
00:57:52 <shachaf> Okasu: Looks like it's Modules.hs
00:58:37 <Okasu> shachaf: yeah, thanks
01:04:52 <Okasu> urgh, Log.hs is totally broken :/
01:07:13 <Okasu>     Couldn't match expected type `ModuleT (M.Map a0 a1) LB b0'
01:07:15 <Okasu>                 with actual type `Maybe a1'
01:07:40 * shachaf isn't *too* surprised.
01:07:46 <shachaf> lambdabot is kind of dead.
01:08:32 <Okasu> shachaf: but is there other itc bots in haskell?
01:08:37 <Okasu> irc*
01:08:45 <Okasu> not dead :)
01:08:46 <shachaf> Sure.
01:08:57 <shachaf> I know of at least two others that are actively being useful on Freenode.
01:09:18 <shachaf> But I don't know about logging.
01:09:32 <Okasu> shachaf: which ones?
01:09:39 <shachaf> preflex and that C++ bot
01:09:44 <shachaf> Probably some others too.
01:10:11 <Okasu> shachaf: "in haskell" :)
01:10:20 <shachaf> They're both in Haskell.
01:10:49 <Okasu> C++ bot in haskell ? But anyway, thanks for info
01:10:55 <shachaf> Yes.
01:11:00 <shachaf> It evaluates C++
01:13:42 <hiptobecubic> geordi?
01:13:48 <shachaf> geordi
01:13:54 <hiptobecubic> geordi is nice
01:17:26 <Okasu> i figured out that preflex is just some modification of lambdabot but is it opensource because i cant find any src of preflex on the net?
01:32:21 <ezyang> Do applicative functors have the moral equivalent of an associativity law, much the same way monads do?
01:32:21 <lambdabot> ezyang: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:32:26 <ezyang> @messages
01:32:27 <lambdabot> augur said 5d 9h 14m 9s ago: its perpetuated not perpetrated
01:32:27 <lambdabot> ddarius said 1d 8h 39m 21s ago: For Robert, GHC's exception mechanism is only for GHC not Haskell, and even it has changed drastically multiple times so there's hardly "no chance to fix it."
01:32:40 <augur> hey ezyang
01:32:48 <ezyang> augur: Heya
01:33:51 <tdammers> ezyang: my gut feeling says "yes", but I'm not an expert
01:34:00 <ezyang> (context: I'm trying to understand what extra laws applicative functors uphold, and the obvious one: a <*> b == ($b) <*> a seems to need a little help)
01:34:12 <ezyang> *commutative applicative functors
01:34:25 <ezyang> erm, that's not right
01:34:36 <shachaf> ezyang: ezyan: ($b) <*> a?
01:34:39 <shachaf> Er.
01:34:41 <ezyang> a <*> b == (fmap ($) b) <*> a <-- better
01:35:01 <ezyang> erm, s/($)/flip ($)/g
01:35:21 <shachaf> The idea comes through. :-)
01:35:52 <ezyang> augur: Re your other comment, really? Huh.
01:36:07 <shachaf> Are you sure about the "perpetuated" thing?
01:36:18 <ezyang> eggcorn in my face
01:36:19 <shachaf> I mean, you can presumably perpetuate a myth, but only if it already exists.
01:36:24 <augur> ezyang: : perpetuate means to continue an idea. especially a false idea
01:36:32 <augur> make-perpetual
01:36:42 <augur> perpetrate means to commit, as in a crime
01:37:31 * hackagebot language-c-quote 0.4.1 - C/CUDA/OpenCL quasiquoting library. (GeoffreyMainland)
01:37:35 <shachaf> ezyang: I guess your law is (<**>) = flip (<*>)?
01:39:25 <ezyang> That's about right.
01:39:58 <ezyang> assuming that the order of execution is ltr for <**> too
01:40:07 <shachaf> @src <**>
01:40:07 <lambdabot> (<**>) = liftA2 (flip ($))
01:40:10 <ezyang> yeah, looking at teh def it is.
01:40:17 <shachaf> That's the main reason it exists, I think.
01:40:20 <lizzzin> how do i make this work? filter(`mod` 4)[1..10]
01:40:22 <lizzzin> err
01:40:27 <lizzzin> how do i make this work? filter(`mod` 4 == 0)[1..10]
01:40:40 <shachaf> > filter (\x -> x `mod` 4 == 0) [1..10]
01:40:42 <lambdabot>   [4,8]
01:40:43 <ezyang> lizzzin: Make it a lambda :-)
01:40:54 <lizzzin> ezyang: make the predicate a lambda?
01:41:03 <lizzzin> oh
01:41:05 <ezyang> see shachaf's comment
01:41:10 <shachaf> If you want to get rid of the x, you can do that, but start with the lambda.
01:41:16 <shachaf> @pl (\x -> x `mod` 4 == 0)
01:41:17 <lambdabot> (0 ==) . (`mod` 4)
01:41:23 <lizzzin> thanks
01:41:36 <lizzzin> shachaf: solution was what i was wondering how to do
01:41:44 <shachaf> > let divides x y = y `mod` x == 0 in filter (divides 4) [1..10]
01:41:45 <lambdabot>   [4,8]
01:42:59 <lizzzin> is that \ used anywhere else but in lambdas?
01:43:12 <shachaf> ezyang: One of the Applicative laws seems to be pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
01:43:16 <shachaf> That's sort of like associativity?
01:43:39 <ezyang> shachaf: Maybe. It's a bit odd though.
01:43:50 <ezyang> because composition shows up
01:44:21 <shachaf> The applicative laws don't look as nice as the monad laws. :-(
01:44:32 <ezyang> Alas.
01:44:47 <shachaf> Is there an alternative way of defining Applicative, like join instead of (>>=) for Monad?
01:45:02 <ezyang> Maybe I should lookup the original paper.
01:45:50 <shachaf> I guess you could have liftA2 instead of (<*>), but that's not very different.
01:45:56 <shachaf> Maybe it works out a bit nicer, though?
01:46:51 <shachaf> Functor has lift1 :: (a -> b) -> f a -> f b; Applicative also has lift0 :: a -> f a and lift2 :: (a -> b -> c) -> f a -> f b -> f c
01:47:21 <JoeyA> Is it possible for a cabal package to have multiple maintainers?  That is, multiple people who may upload new versions of that package?
01:47:39 * hackagebot fast-logger 0.2.2 - A fast logging system (KazuYamamoto)
01:47:40 <shachaf> JoeyA: If I remember correctly, anyone may upload a new version of any package to Hackage.
01:47:59 <JoeyA> Scary
01:48:09 <ezyang> shachaf: I'm a fan of >=> as an alternate >>=, but less so of things like lift2
01:48:51 <shachaf> ezyang: (>=>) and join are both nice ways of thinking about Monad.
01:48:59 <ezyang> oh oh, here it is
01:49:12 <shachaf> lift2 seems a bit simpler to me because f (a -> b) is kind of weird.
01:49:26 <ezyang> (*) :: f a -> f b -> f (a,b)
01:49:39 <ezyang> so called "Monoidal"
01:49:58 <shachaf> liftA2 (,) :-)
01:50:15 <ezyang> Right, but in fact that's all you need.
01:50:30 <JoeyA> Here's one way to cause mischief: 1) Take a package with a lot of upper bounds, and delete them.  Add a surprise, too.  2) Upload it. 3) Upload another minor version with the upper bounds restored.
01:50:37 <ezyang> (assuming pointedness, of course. Or you can add unit :: f ())
01:50:40 <shachaf> Oh, unit :: f ()
01:50:53 <shachaf> I see.
01:50:59 <shachaf> That's equivalent to Applicative?
01:51:03 <ezyang> yep
01:51:06 <yitz> @hoogle >=>
01:51:07 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
01:51:12 <JoeyA> This way, if an unnecessary upper bound isn't satisfied, it'll keep falling back to (2), since it's the latest package.
01:51:14 <ezyang> OK, this is *much* nicer.
01:51:23 <ezyang> ...aaand apparently I know what a 'lax monoidal functor' is now.
01:51:25 <shachaf> What do the laws come out to?
01:51:53 <ezyang> naturality, left/right identity and associativity
01:52:05 <shachaf> Naturality?
01:52:32 * shachaf opens the paper himself instead of reading-via-IRC.
01:52:47 <ezyang> let f `x` g = \(x,y) = (f x, g y)
01:53:07 <ezyang> then, naturality stateS: fmap (f `x` g) (u * v) = fmap f u * fmap f v
01:53:22 <Kakadu> Can you help me find finding right package for module Data.Map.Lazy? http://pastebin.com/qp3LuWEw
01:53:25 <mauke> The paste qp3LuWEw has been copied to http://hpaste.org/73274
01:54:01 <ezyang> Kakadu: Can you rerun that with -v?
01:54:27 <shachaf> Kakadu: You probably don't want to be using containers-0.5.0.0
01:54:54 <shachaf> Upgrading containers with a version of GHC/base/etc. that wasn't meant to work with it is doomed to failure, so I understand.
01:55:20 <shachaf> So your best bet is probably to add a containers < 0.5 constraint or something like that.
01:55:42 <Kakadu> shachaf: rerun here: http://pastebin.com/raw.php?i=TN3NrsJY
01:55:44 <mauke> The paste TN3NrsJY has been copied to http://hpaste.org/73275
01:56:42 <shachaf> Kakadu: ?
01:56:45 <shachaf> Oh, the -v
01:56:50 <shachaf> I stand by what I said before. :-)
01:57:55 <Kakadu> shachaf: So you recommend to install containers <0.5 and add this constraint to the cabal-file?
01:58:00 <shachaf> ezyang: Associativity works out just as ugly, though. :-(
01:58:19 <ezyang> Just use Data.Map
01:58:24 <ezyang> Data.Map = Data.Map.Lazy
01:58:26 <shachaf> You need this function assoc.
01:58:34 <shachaf> ezyang: That's not the issue here, I think.
01:58:37 <ezyang> I added Data.Map.Strict in the newer containers, but you're GHC isn't new enough.
01:58:46 <shachaf> Oh, maybe it is the issue.
01:58:51 <ezyang> shachaf: If I use 'is isomorphic to' then it's really easy :-)
01:59:18 <shachaf> Pft, you and your isomorphisms.
01:59:28 <ezyang> I love isomorphisms! :^)
01:59:29 <yitz> JoeyA: if someone notices an upload by a non-maintainer, ross can undo it. but likely it would go unnoticed.
01:59:52 <Kakadu> ezyang: Thanks a lot! It complies
01:59:57 <Kakadu> compiles now*
02:01:41 <tdammers> yitz: isn't that kind of like a huge security issue?
02:02:10 <yitz> tdammers: kind of like yeah. someone ought to monitor that.
02:03:32 <shachaf> ezyang: Hmm, so what do the laws work out to with lift2?
02:04:55 <ezyang> Dunno, I just saw the nice formulation and stopped thinking about it ^_^
02:05:10 <shachaf> Hmph, OK.
02:05:32 <shachaf> How about your commutative law?
02:06:03 <shachaf> Something like fmap swap (flip (*) a b) == a * b?
02:06:17 <ezyang> a * b is isomorphic to b * a, ya
02:06:25 <tdammers> I could just upload a malicious version of some widely-used package, bump the third or fourth version number part, and wait for all kinds of projects silently using it
02:06:28 * ezyang still fucking loves his isomorphisms 
02:06:42 <shachaf> Hey, isomorphisms are great!
02:06:52 <ezyang> tdammers: Yes. It's also a huge security issue that we're not signing packages.
02:07:02 <tdammers> yes.
02:07:13 <tdammers> and that upload is over plain HTTP.
02:07:17 <tdammers> (or is it HTTPS?)
02:07:32 <shachaf> And download, I think.
02:08:51 <tdammers> insecure download doesn't compromise the central repository though
02:08:54 <shachaf> Are there noice commutative monad laws?
02:08:55 <tdammers> only makes it unreliabel
02:09:00 <tdammers> s/el/le/
02:09:37 <shachaf> s/oi/i/
02:09:44 <ezyang> shachaf: Oh, I guess I haven't thought about that much.
02:11:13 <shachaf> Is [] commutative?
02:11:15 <shachaf> Oh, no, it's not.
02:11:53 <ezyang> Set is, tho
02:11:53 <JoeHazzers> i'm trying to work out the number of pages that are available for a certain search on a website. the only reliable way of which is to grab the HTML page, and check for a "Next Page" link, which i can do. how should i do what i can only imagine would have to be recursive IO?
02:12:05 <shachaf> ezyang: Set isn't a monad in the first place. :-(
02:12:11 <ezyang> go go restricted monads
02:12:22 <ezyang> JoeHazzers: You can totally do recursive IO
02:12:25 <merijn> JoeHazzers: What exactly is the problem with recursive IO?
02:12:34 <shachaf> Do restricted monads always "work" as long as you prove the monad laws?
02:12:40 <shachaf> I guess they would.
02:12:42 <JoeHazzers> well, i'm not sure how to do it is the only thing
02:13:29 <shachaf> JoeHazzers: let foo x = do { ...; if blah then foo (x+1) else ... }
02:13:31 <merijn> "recursiveIO :: a -> IO a; recursiveIO x = if foo x then return x else recursiveIO whatever"
02:13:50 <JoeHazzers> oh okay
02:14:13 <shachaf> Alternatively, fix $ \loop -> ...; if blah then loop else ...
02:14:40 <merijn> JoeHazzers: In a do block you just have to make sure that the last statement in the block has type "IO a" where "IO a" is the type of that block. If that statement happens to recursively call the same block that's fine
02:14:58 <merijn> Of course your program won't terminate unless the recursive call has a stop condition :p
02:15:22 <JoeHazzers> up until a few days ago, as far i was concerned, IO was black magic
02:15:47 <shachaf> JoeHazzers: Eventually you'll discover that it *is* black magic.
02:15:58 <shachaf> But you don't need to know the magic to use it. :-)
02:16:31 <tdammers> shachaf: yes, it actually is, from the language's point of view
02:16:45 <merijn> JoeHazzers: It is black magic behind the scenes, but the center stage is pretty simple. Once you realise how simple it actually is :p
02:16:54 <merijn> There's just the bootstrapping problem of realising it :p
02:17:24 <shachaf> ezyang: Actually what the commutative monad laws would be isn't completely obvious to me.
02:17:41 <shachaf> It doesn't seem as simple as Applicative.
02:17:49 <shachaf> (Unless I'm missing something. Which isn't unlikely.)
02:18:36 <merijn> JoeHazzers: Are you aware of how do-notation works (i.e. what it is sugar for)? That might help show how things work
02:18:52 <JoeHazzers> don't *really* understand it
02:18:59 <JoeHazzers> i've just had a bit of trouble getting my head around it
02:19:07 * shachaf looks at http://upload.wikimedia.org/wikipedia/en/f/f2/Strong_monad_commutation.png
02:19:16 <shachaf> JoeHazzers: Did you read "Introduction to IO"?
02:19:18 <tdammers> maybe try writing a few things without do notation
02:19:29 <ezyang> Wouldn't it be, if it's a commutative applicative functor, it's a commutative monad?
02:19:34 <shachaf> strength :: (Monad m) => (a, m b) -> m (a,b)
02:19:49 <shachaf> ezyang: Well, sure, I guess.
02:20:03 <shachaf> I was hoping for something more Monady...
02:20:53 <ezyang> Well, certainly, there might be a nice version of the law that uses join or whatnot.
02:21:25 <shachaf> OK, that diagram makes some sense.
02:21:32 <merijn> JoeHazzers: do notation is just syntactic sugar for the following: "do {foo; bar}" = "foo >> bar" and "do {x <- foo; bar x}" = "foo >>= \x -> bar x"
02:21:43 <ezyang> Huh, do you only need strength?
02:22:03 <shachaf> No, it's a law that uses strength.
02:22:14 <shachaf> You can define strength on any Haskell Monad.
02:23:03 <merijn> JoeHazzers: If you look at the types (I'll specialise to IO for now, in practice they're more general) of >> (IO a -> IO b -> IO b) and >>= (IO a -> (a -> IO b) -> IO b)
02:24:15 <shachaf> strength_fst :: (Monad m) => (m a, b) -> m (a,b); strength_snd :: (Monad m) => (a, m b) -> m (a,b)
02:24:16 <JoeHazzers> where >> allows the chaining of IO functions, and >>= allows passing the result from the first function to the second as input? :S
02:24:38 <shachaf> The law says that strength_fst followed by strength_snd followed by join is the same as strength_snd followed by strength_fst followed by jon.
02:24:41 <shachaf> I think.
02:24:52 <merijn> JoeHazzers: Basically >> is "create an action that wil run the first action, then the second action and return the result of the second" and >>= is "create an action that will run the first action, call the "a -> IO b" with the result of that acction and then run the new action and return its result"
02:25:05 <JoeHazzers> oh okay
02:25:09 <merijn> JoeHazzers: >> chains IO *actions*, not function
02:25:21 <JoeHazzers> i don't know why i never understood this before, it seems so simple
02:25:32 <merijn> JoeHazzers: There is a difference, you can run a function, but you can't run a function
02:25:43 <JoeHazzers> o.o
02:26:01 <merijn> JoeHazzers: Essentially you're composing a big runnable action (which may do something everytime) by glueing together smaller actions using pure functions
02:26:20 <merijn> (The end result being main, which gets run when you execute your program)
02:26:30 <JoeHazzers> okay
02:26:44 <JoeHazzers> i just find it eerie as you see IO pollute your lovely pure code
02:26:56 <tdammers> IO is pure. In a way.
02:27:17 <merijn> JoeHazzers: It depends, I've written quite a bit of imperative haskell (IO everywhere!) and it is still very neat and nice
02:27:24 <JoeHazzers> no, what i mean is... you can sort of see exactly which bits of your code suffer having to directly interact with the world :(
02:30:00 <merijn> To get back to recursive IO "forever :: IO a -> IO a; forever x = do {x; forever x}" desugars into "forever x = x >> forever x", which is just a normal recursive function (like repeat), of course it doesn't terminate, but that is easily done using some if/else construct
02:30:15 <tdammers> JoeHazzers: you can have a function return IO (IO a)
02:30:25 <tdammers> e.g.
02:30:33 <tdammers> f x = return $ return x
02:30:39 <shachaf> Can you define join with strength?
02:31:01 <merijn> JoeHazzers: Given the earlier explanation of >> that should make sense, right?
02:31:57 <JoeHazzers> merijn: yeah
02:32:03 <shachaf> ezyang: Since you know what "lax monoidal functor" means, what does "lax" mean? :-)
02:32:17 <JoeHazzers> excessive haskell consumption may cause lax effects?
02:32:39 <merijn> JoeHazzers: For an easy runnable example:
02:32:51 <merijn> :t forever $ getLine >>= putStrLn
02:32:53 <lambdabot> forall b. IO b
02:33:25 <sp3ctum> i find it helpful not feeling bad if i need IO somewhere
02:33:42 <sp3ctum> i often worry about the wrong thing if a substantial amount of time goes to worrying that
02:33:59 <sp3ctum> if it can be refactored to a pure form, good. if not, oh well :)
02:35:39 <quicksilver> shachaf: some laws only hold up to isomorphism instead of exactly.
02:36:35 <shachaf> quicksilver: What's the context?
02:36:52 <quicksilver> shachaf: lax monoid functor?
02:37:16 <shachaf> Ah.
02:37:38 <quicksilver> something like rather than requiring F ( a (x) b ) to actually *be* F a (x) F b
02:37:47 <quicksilver> you just require it to be an isomorphic object.
02:38:14 <shachaf> Ah.
02:39:08 <quicksilver> in fact it's apparently even weaker than that; but that's the general idea.
02:39:15 <JoeHazzers> merijn: thanks for the help, by the way!
02:39:28 <merijn> JoeHazzers: np
02:47:58 <shachaf> Hah, of course you can't define join using strength.
02:48:04 <shachaf> You can define strength on any Functor.
02:48:48 <quicksilver> in haskell strength comes for free
02:49:09 <shachaf> Right.
02:53:41 <dmwit> How strong can you make that claim?
02:53:52 <dmwit> Like, can you say "in CCCs strength comes for free"?
02:58:14 <quicksilver> dmwit: I don't think so, no.
02:58:31 <quicksilver> functor strength isn't really a standard concept - the concept standardly applies to monads.
02:58:41 <quicksilver> in haskell you only need functor to define it
02:58:47 <quicksilver> I'm not sure what the significance of that is.
02:59:00 <quicksilver> but anyhow it's certainly not true that all monads on a CCC are strong.
02:59:07 <JoeHazzers> since i'm a happy little nooblet, how can i turn the output from getArgs into a tuple easily?
02:59:26 <quicksilver> JoeHazzers: the problem is you don't know how many there are.
02:59:42 <shachaf> JoeHazzers: args <- getArgs; case args of [a,b,c] -> ...; _ -> ...
02:59:59 <quicksilver> if you're prepared to assume there are (for example) 3, and crash if not, then: do [a,b,c] <- getArgs; .... use (a,b,c) ...
03:00:13 <shachaf> Or make your own getArgs that checks the arguments and gives you a nice tuple.
03:00:24 <JoeHazzers> i was considering that
03:01:50 <tdammers> quicksilver: if you match on a:b:c:_ instead, it will only crash if there are less than 3 arguments and ignore the rest
03:02:04 <shachaf> tdammers: Yes, but that's not the point.
03:02:16 <shachaf> You can also match on (take 3 -> [a,b,c]) :-)
03:02:29 <quicksilver> tdammers: yes indeed.
03:02:36 <quicksilver> which may or may not be what you want.
03:02:41 <quicksilver> the point is to decide what you do want.
03:02:42 <tdammers> yes
03:02:48 <shachaf> ==quicksilver
03:02:49 <tdammers> and you can add another match condition on _
03:02:55 <shachaf> That's always the important thing.
03:02:56 <tdammers> to handle failures more gracefully
03:03:09 <shachaf> Usually people skip that step before they ask questions in here, alas.
03:04:55 <tdammers> well; if you choose to ignore the 'non-exhaustive patterns' warning, be my guest, but don'tya come knockin'!
03:32:27 <frerich> Hm, a little question for native english speakers - in a piece of documentation, should I say "Elements can be added to the list, providing that they belong to at least one set." or "*provided* that"?
03:32:39 <dmwit> provided
03:32:41 <shachaf> "provided that"
03:33:00 <shachaf> Providing would mean that you return both a list and a proof that they belond to at least one set. :-)
03:33:10 <tdammers> I think 'that' is optional in this context. Not a native speaker though.
03:33:19 <frerich> Thanks (sorry for being offtopic, but it was rather quiet, so... :-)).
03:33:22 <shachaf> Yes.
03:33:36 * shachaf just read the GeneralizedNewtypeDeriving-is-unsound post.
03:33:39 <shachaf> Kind of unsettling.
03:33:44 <quicksilver> both are correct
03:34:14 <quicksilver> provided and providing are both correct, and "that" is optional - it sometimes reads better without.
03:36:59 <t7> @pl \x -> f x >> return x
03:37:00 <lambdabot> liftM2 (>>) f return
03:38:27 <randomclown> @pl \x,y -> (f 1 x) ++ (f 2 y)
03:38:27 <lambdabot> uncurry ((. f 2) . (++) . f 1)
03:39:09 <edsko> why is " forever a " not defined as " let a' = a >> a in a' " in the base libraries? the version that's there is giving me a space leak
03:39:38 <shachaf> a >> a wouldn't execute forever.
03:39:42 <shachaf> It'd execute twice.
03:40:29 <quicksilver> that was a typo :)
03:40:38 <quicksilver> edsko's second a was meant to be an a'
03:40:52 <edsko> uh, yes, sorry. thanks quicksilver  :)
03:40:56 <quicksilver> I'd guess, edsko, that it depends on the monad and that version does something funny in other monads.
03:41:17 <edsko> quicksilver: yes, you're probably right, but I can't think of an example :-/
03:41:23 <t7> I dont want to export a constructor but i want to let people pattern match it
03:41:36 <t7> like let people read but not create
03:41:53 <quicksilver> edsko: it's all a bit subtle. I don't claim to know the answer.
03:41:58 <quicksilver> edsko: http://hackage.haskell.org/trac/ghc/ticket/5205
03:42:50 <edsko> quicksilver: yes, I'm aware of that ticket, but the strange thing is that in my example I'm getting a space leak with -O1 and with -O2 but not with -O0, whereas the documentation of 'forever' in base says the spaceleak might HAPPEN with -O0 but NOT with with -O1, -O2
03:43:22 <quicksilver> edsko: I'm guessing their "fix" for that ticket broke your example
03:43:25 <quicksilver> but, I'm only guessing.
03:43:44 <edsko> yeah, it all seems a bit..
03:43:50 * edsko searches for diplomatic term
03:43:59 <edsko> brittle, yes, brittle is a good word :)
03:44:53 <quicksilver> optimisation is brittle :(
03:45:05 <Saizan> what's your example btw?
03:45:06 <quicksilver> writing compilers is hard, can we go shopping?
03:45:21 <edsko> quicksilver: sure, of course. I just wish the space behaviour of my program didn't depend on it :)
03:45:54 <edsko> Saizan: it's part of my Cloud Haskell implementation. I tried distilling it to a small example but failed so far
03:46:36 <bitonic> is cloud haskell usable?
03:46:46 <mekeor> t7: export the eliminator?
03:47:14 <edsko> bitonic: usable?
03:47:18 * edsko looks offended
03:47:22 <edsko> :-P
03:48:02 <t7> mekeor: i have a function todo PrivateFoo -> Foo
03:48:08 <t7> but i cant pattern match :(
03:48:24 <edsko> t7: so export a fold
03:48:37 <edsko> I think that's what mekeor meant
03:48:45 <t7> oh
03:48:54 <bitonic> edsko: well as in can I write "real world" stuff with it?
03:49:05 * bitonic loves the "real world"
03:49:15 <isomorphic> I'm interested in sandboxed haskell implementations - how does lambdabot do it?
03:49:18 <t7> is that the thing in the IO monad?
03:49:26 <t7> passed around behind the scenes
03:49:27 <bitonic> isomorphic: mueval
03:49:40 <edsko> t7: huh? no. like "foldr", but then for your data type
03:49:48 <edsko> t7: maybe check out the "large bananas" paper
03:49:57 <t7> i was talking about Real world
03:50:03 <isomorphic> bitonic: Perfect, thanks :)  I'm assuming hint is more dangerous?
03:50:08 <edsko> bitonic: why wouldn't you? what are the things you worry about?
03:50:37 <bitonic> edsko: I don't know.  I looked at it very briefly, and it looked like it was in its early stages.
03:51:09 <bitonic> actually, rephrasing the question: have useful programs been written with cloud haskell?
03:51:45 <edsko> bitonic: so I've been working on the rewrite of Cloud Haskell full time for the last four months, and it's getting to a point where it should be usable. bugs might still be there of course (bug reports welcome).
03:52:10 <bitonic> edsko: ah, I didn't even know that there was a rewrite.  so is there an hackage package now?
03:52:11 <mekeor> bitonic: this one? https://github.com/jepst/CloudHaskell/
03:52:12 <edsko> bitonic: the main area that's still lacking I think is high quality backends that deal with specific network infrastructures
03:52:23 <edsko> mekeor: no, that's the original prototype
03:52:53 <edsko> distributed-process on Hackage, or http://github.com/haskell-distributed/distributed-process
03:52:59 <mekeor> ah
03:53:13 <bitonic> edsko: thanks, I'll take a look
03:53:23 <edsko> cool. give me a shout when you have questions
03:55:11 <bitonic> edsko: well, the first question is: why do we need "backends"?
03:55:41 <bitonic> I thought it was going to be a message passing thing + something like gen_* in erlang
03:56:17 <edsko> bitonic: backends deal with node discovery, creating new nodes, etc. that's different if you run on a local network (simplelocalnet backend), on Azure (azure backend, work in progress), on EC2 (not yetimplemented), etc.
03:56:46 <bitonic> edsko: mhm... so there isn't something like distributed erlang?
03:57:05 <edsko> come again?
03:57:38 <bitonic> edsko: there isn't a "standard" way to create nodes, connect them, passing messages between them like in erlang?
03:57:55 <edsko> there is a standard way to send messages, of course
03:58:12 <edsko> thre is no such thing as "connecting"
03:58:18 <edsko> as message passing is connection-less
03:58:21 <edsko> in CH as well as in Erlang
03:58:35 <bitonic> edsko: I meant monitoring there
03:58:41 <bitonic> but yeah
03:58:48 <edsko> oh, sure, monitoring is also standard
03:59:08 <edsko> http://hackage.haskell.org/packages/archive/distributed-process/0.3.0/doc/html/Control-Distributed-Process.html
03:59:20 <bitonic> so wait I don't get why you need specific backend.  erlang does not have backends
03:59:24 <Egbert9e9> it is not a good idea to repeatedly Data.Vector.thaw and Data.Vector.freeze. Memory was flooded.
03:59:27 <edsko> but setting up new nodes is not. after all, the specifics of how to set up new nodes depends very much on the backend
03:59:43 <edsko> for azure you mgiht want to specify an Azure-specific VM image, for instance
03:59:51 <Egbert9e9> I am not sure how to fix that
04:00:06 <edsko> bitonic: erlang assumes a single model
04:00:10 <bitonic> edsko: mhm... I'm not sure I see the advantages.  distributed erlang has serverd programmers pretty well
04:00:11 <isomorphic> edsko:  I notice from the Cloud Haskell page that function identifiers are sent rather than new code.  Are you considering a way to send new code by any chance?
04:00:12 <shachaf> Egbert9e9: I would suggest a high-level reëxamination of your data structures.
04:00:42 <edsko> bitonic: for instance, Cloud Haskell can run on high performance CCI networks (InfinitBand)
04:00:45 <edsko> Erlang cannot
04:00:53 <typoclass> shachaf: your e on its head has antennas with eyes or something, like andorians
04:01:06 <bitonic> edsko: well OK then, as long as we have something like erlang out of the box
04:01:07 <edsko> isomorphic: no, it is assumed all nodes run the same code.
04:01:20 <edsko> bitonic: sure, just pick the backend that suits and go :)
04:01:36 <bitonic> edsko: so is there a backend that behaves more or less like distributed erlang?
04:01:42 <mjga> edsko: I may actually want to try your Cloud Haskell on 48-proc node, and then over an Infiniband. Did you already implement these?
04:01:51 <shachaf> typoclass: They come from New York.
04:01:55 <isomorphic> edsko:   are you aware of anything that can serialize, deserialize, and execute a function?
04:02:05 <shachaf> typoclass: That's how people write there!
04:02:23 <merijn> bitonic: Just plain TCP/IP, probably
04:03:09 <edsko> isomorphic: in theory there is no reason why "Static" couldn't support that, but in practice -- no
04:03:47 <edsko> bitonic: the simple-localnet backend allows to create new nodes and discovery nodes by broadcasting over UDP.
04:03:59 <edsko> I'm not sure precisely what you mean by "like distributed erlang"
04:04:08 <bitonic> edsko: but the "local" in there makes me think that it'll work only... locally?
04:04:10 <Egbert9e9> shachaf: could you help me with that?
04:04:29 <shachaf> Egbert9e9: Possibly -- what are you trying to do?
04:04:31 <isomorphic> edsko:   What do you mean "Static" - a package?
04:04:32 <edsko> bitonic: local as in: on a local network -- no firewalls in between nodes, and nodes can reach each other through UDP
04:04:54 <bitonic> edsko: oh, OK.  distributed erlang = http://www.erlang.org/doc/reference_manual/distributed.html
04:05:05 <merijn> isomorphic: It's described in the Cloud Haskell paper, it's what they use for serialising closures
04:05:11 <Egbert9e9> it's a vector with N*N cells, each cell has three boolean values
04:05:22 <isomorphic> edsko: Thanks :)
04:05:41 <edsko> mjga: Parallel Scientific is working on supporting CCI at the moment
04:05:53 <shachaf> Egbert9e9: What do you do to the vector?
04:06:13 <edsko> merijn, isomorphic: yes, it's dscribed in that paper, although I have extended it in various ways. see http://hackage.haskell.org/package/distributed-static
04:06:45 <Egbert9e9> imperatively, each step I would change one cell according to some rule, then do many 4 cell clockwise or anticlockwise 90 degree spinnings
04:06:45 <edsko> bitonic: right, so the simplelocalnet backend uses TCP/IP as the network transport
04:07:19 <isomorphic> merijn: thanks :) misread previously
04:07:54 <Egbert9e9> each time i change a cell, its moore neighboorhood is affected, changing the outcome of the next step
04:08:18 <bitonic> edsko: OK.  I think that that would be enough for most uses, no?  I mean that's all that erlang does and erlang is very useful :)
04:08:44 <Egbert9e9> moore neighboorhood of order (?) 2
04:08:45 <shachaf> Egbert9e9: "Each step"?
04:08:53 <edsko> bitonic: it depends on your application. if your application depends heavily on efficienct message sending then TCP/IP will not be good enough.
04:09:16 <shachaf> Egbert9e9: There's a question of whether you can describe the whole transformation as a in a certain way which works nicely with immutable arrays, I guess.
04:09:33 <edsko> bitonic: so that's why Cloud Haskell can run on an arbirtary Network.Transport (http://hackage.haskell.org/package/network-transport-0.2.0.2) and why there is the concept of backends
04:09:38 <shachaf> Egbert9e9: One possible approach is to use Data.Map (Int,Int) Cell, or Data.Sequence Cell, or something like that, instead of arrays.
04:09:45 <shachaf> Egbert9e9: Those allow nice functional update.
04:09:54 <shachaf> But maybe functional arrays work for you too.
04:10:05 <bitonic> edsko: OK, I'm just saying that TCP/IP will be OK for the vast majority of distributed applications :)
04:10:11 <shachaf> For example, if you're updating the entire array each time, and each cell can be described as some function of the old array.
04:11:17 <edsko> bitonic: yes. but even then -- for instance, the Azure backend also uses TCP/IP under the hood but uses a different process to discover nodes, because UDP broadcast doesn't work on Azure networks (instead, it queries the Azure API) -- and to set up a new host, obviously (i.e., create a new VM) it needs to call into the Azure API too, and that doesn't even *have* an equivalent in some other setups
04:12:09 <ketil> Any cmdargs experts?  I want to force a "usage" output (similar to --help), as a result of checking some parameters.  How?
04:12:38 <b52> does Integer has an Infinity value?
04:12:44 <shachaf> b52: No.
04:13:17 <shachaf> Hah, a Data.Integer.Lazy in the style of Data.{ByteString,Text}.Lazy would be funny.
04:13:39 <shachaf> data Integer = Zero | Plus I.Integer Integer
04:13:48 <Jeanne-Kamikaze> b52: Integer is unbounded, it goes to infinity and beyond
04:13:58 <bitonic> edsko: well what erlang does is to have its own thing (epmd)
04:14:12 <bitonic> edsko: and you have to connect to remote nodes first before you "see" them
04:14:52 <bitonic> so that doesn't use UDP broadcasts
04:15:01 <bitonic> and still works well for most purposes
04:15:34 <bitonic> edsko: actually thinking about it your TCP/IP backend is very different from erlang if it doesn't have something like epmd
04:17:17 <edsko> bitonic: the point is not to insist on a single way to do this, but to make it configurable
04:17:41 <bitonic> edsko: well I'm just trying to see if generalising that is worth it, at least for my usage
04:17:53 <bitonic> since it introduces one more thing to think about
04:18:18 <edsko> "anyone's" usage is always complicated by having options do also do "somebody else's" usage :)
04:19:11 <bitonic> edsko: well we have good evidence that erlang's way of doing things serves well a large chunk of usages, in the field of distributed applications
04:19:37 <bitonic> so I'd be wary of complicating that model, that's all.  but I'm sure there are advantages that I'm not seeing now.
04:20:09 <edsko> bitonic: most code isn't affected by the generalziation. it's only the setup. most CH write would be backend agnosti
04:21:36 <bitonic> edsko: it's still one more thing to think about - deciding that you have one way of distributing things simplifies things a lot
04:22:03 <edsko> it also limits you :)
04:22:18 <bitonic> sometimes limitations are good, in lack of discipline :)
04:22:27 <mekeor> bitonic: do you use haskell-indentation or haskell-indent or haskell-simple-indent for editing haskell in emacs?
04:22:47 <bitonic> mekeor: I use the one that actually indents the code for you
04:23:06 <mekeor> bitonic: which one is that? =)
04:23:06 <edsko> bitonic, mekeor: surely absolutely none of them. just do it by hand, having options to do indentation would be bad! :-P
04:23:30 <bitonic> mekeor: I have `(turn-on-haskell-indentation)' in my emacs config.
04:24:00 <mekeor> bitonic: hm, i see. thanks
04:24:13 <bitonic> that works reasonably well for me, apart from certain things...
04:24:20 <bitonic> I should look at the elisp code someday.
04:25:06 <bitonic> tbh I haven't really tried anything else.
04:25:56 <mekeor> bitonic: do C-c C-= etc work in that indent-mode for you? for me, many keys don't work with it
04:27:15 <bitonic> mekeor: I don't know what that does, and `C-h m' does not show anything relevant
04:28:31 <mekeor> bitonic: anyway... i don't like that indent-mode much because if you press enter in the middle of a line somewhere, and then backspace, it jumps back up, if you know what i mean.
04:28:51 <quicksilver> I think the equals sign ligning up indeed is a feature you lose in haskell-indentation-mode, but it's so much better at indentation
04:29:02 <quicksilver> and I just trained myself to use align-regexp instead
04:30:27 <mekeor> i didn't learn regexp yet..
04:31:01 <mekeor> in any case, we need a better indent-minor-mode.
04:33:13 <bitonic> mekeor: most of my uses of `align-regexp' are just with the string I want to align after
04:34:40 <mekeor> oh neat
04:35:31 * mekeor just tried out align-regexp... coool!
04:35:37 <Egbert9e9> shachaf: read a tiny bit about Data.Map and it looks cool. I'll see what I can make of it.
04:39:32 <b0fh_ua> Hi all! I'm trying to link my application with libcurl on Windows. It successfully compiles all *.hs files into *.o but fails on linking stage. I think that it is caused by the fact that GHC doesn't pick up libraries like libcrypto.dll.a/libssh2.dll.a
04:39:57 <b0fh_ua> how do I specify LDFLAGS or something like this on Windows for GHC?
04:59:10 <charliesome> why does 'sum [1..100000000]' consume a gig and a half of ram?
05:00:12 <Botje> because sum is foldl instead of foldl', sadly.
05:00:16 <mekeor> @src sum
05:00:17 <lambdabot> sum = foldl (+) 0
05:00:26 <mekeor> @ty foldl'
05:00:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:00:32 <mekeor> @ty foldl
05:00:34 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
05:00:50 <mekeor> charliesome: try fold' (+) 0 [1..100000000]
05:00:55 <mekeor> er i mean
05:01:00 <mekeor> charliesome: try foldl' (+) 0 [1..100000000] -- :)
05:01:04 <Botje> charliesome: so Haskell spends all its time building up a giant thunk that is only evaluated at the end
05:01:20 <Botje> with foldl' you immediately force the intermediate result
05:01:22 <flux> if only there was a little bit more magic in haskell
05:01:29 <flux> although I suppose with optimizations on it should work as is?
05:01:32 <charliesome> mekeor: will try; Botje: ah right, came as a nasty little surprise
05:01:40 <quicksilver> it does work if you compile with optimisation
05:01:54 <quicksilver> > sum [1..100000000]
05:01:59 <lambdabot>   mueval-core: Time limit exceeded
05:02:03 <quicksilver> bother :)
05:02:18 <quicksilver> it works but takes longer than 3 seconds, on LB's machine.
05:02:21 <charliesome> quicksilver: optimization is -O3 right/
05:02:25 <yitz> flux: well here there is magic for compiled programs with the default optimization level. it doesn't work in ghci though.
05:02:28 <quicksilver> -O2
05:03:14 <charliesome> ah yeah -O2 does the trick
05:03:38 <mekeor> charliesome: did foldl' work, too? =)
05:03:55 <hiptobecubic> the wiki claims that -O2 and -O are pretty much the same really, just -O2 takes forever for some minor things that don't help a great deal i guess?
05:04:22 <quicksilver> people used to recommend -O by default and -O2 only if you proved it was better for your actual module
05:04:31 <quicksilver> I don't know if that's still good advice or not.
05:04:46 <charliesome> mekeor: what package is foldl' in?
05:04:57 <quicksilver> it's in the base package
05:05:00 <charliesome> :\
05:05:03 <quicksilver> in a module called Data.List
05:05:03 <mekeor> charliesome: base in Data.List
05:05:12 <charliesome> ah s/package/module/
05:05:32 <charliesome> mekeor: yup did the trick
05:05:38 <mekeor> cool
05:05:41 <mekeor> charliesome: do you know hoogle?
05:05:43 <quicksilver> I *suspect* the reason that sum isn't foldl' is so you can do things like
05:05:49 * merijn was about to ask the same thing too
05:05:52 <quicksilver> sum [1..] > 2
05:05:56 <quicksilver> for lazy naturals
05:06:16 <mekeor> ah yea makes sense
05:06:19 <quicksilver> hmm, my suspicions are absurd.
05:06:21 <shachaf> But not for Integers, no matter how lazy!
05:06:24 <mekeor> oh right
05:06:26 <quicksilver> if that was the reason it would be foldr :P
05:06:38 <mekeor> heh
05:06:48 <shachaf> quicksilver: It's because foldl' isn't in the Prelude, isn't it?
05:06:56 <quicksilver> shachaf: perhaps that's all it is.
05:06:59 <frerich> I wonder whether these 'sum [1..n]' calls are just academic examples or whether it's actually really common (in the latter case, a 'gaussSum' or so which uses n * (n + 1) / 2 would probably help, too...).
05:07:22 <shachaf> product [1..n]
05:07:23 <quicksilver> but it does rather beg the question why not move foldl' into the Prelude :)
05:07:24 <yitz> quicksilver: well, not explicitly so you can do that. just lazy by default as usual in haskell.
05:07:35 <shachaf> yitz: There's hardly ever an excuse for foldl.
05:07:45 <shachaf> Over either foldl' or foldr, take your pick.
05:07:56 <mekeor> charliesome: take a look at http://www.haskell.org/hoogle/ and holumbus.fh-wedel.de/hayoo/ if you don't know them already ;) :)
05:08:09 <charliesome> mekeor: ah cheers
05:08:25 <yitz> quicksilver: what we really need is for it to be foldl' by default, leaving your case broken, and then foldl with optimisation turned on. that's hard to set up though.
05:09:01 <yitz> shachaf: right the vast majority of uses of sum either want the strict version or don't care.
05:09:21 <shachaf> yitz: Wait, what case?
05:09:33 <yitz> shachaf: like the one quicksilver said ^^
05:09:49 <quicksilver> the one I said needs foldr, though
05:09:50 <shachaf> Oh, foldr?
05:10:08 <shachaf> yitz: You can't switch from foldl to foldl' in general without changing semantics.
05:10:29 <yitz> shachaf: yeah
05:11:29 <yitz> oh. well, i guess you'd have to come up with one pretty bizarr0 Num instance to get a case where foldl is useful then.
05:11:38 <shachaf> yitz: Yes.
05:11:40 <shachaf> There's one on the wiki.
05:11:50 <shachaf> @google haskell foldl foldr
05:11:52 <lambdabot> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
05:11:52 <lambdabot> Title: Foldr Foldl Foldl' - HaskellWiki
05:12:39 <shachaf> Well, that would make sense for product, not sum.
05:13:00 <shachaf> Anyway, it exists, but it's specialized enough that write your own function.
05:13:35 <shachaf> Of course, foldl' isn't sufficient on its own to avoid space leaks. :-(
05:22:50 <shachaf> !
05:22:53 <shachaf> > 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001 == (0::CReal)
05:22:54 <lambdabot>   True
05:23:07 <hiptobecubic> you broke math
05:23:43 <shachaf> Apparently it just checks 40 digits or something
05:23:47 <nand`> CReal's comparisons have very limited precision
05:23:49 <nand`> something like that, yeah
05:24:02 <nand`> (reason is that exact precision would, as you surely know, never terminate)
05:24:03 <typoclass> @src CReal
05:24:04 <lambdabot> Source not found. Do you think like you type?
05:24:21 <nand`> well, inequalities might terminate. but equalities would never
05:24:22 <shachaf> nand`: Right, but...
05:24:33 <shachaf> I mean, just hard-wiring it?
05:24:42 <shachaf> typoclass: http://hackage.haskell.org/packages/archive/numbers/latest/doc/html/src/Data-Number-CReal.html
05:24:56 <nand`> there are some who are of the opinion that CReal should not implement Ord
05:25:02 <nand`> or Eq, for that matter
05:25:17 <nand`> yeah
05:25:20 <nand`> ‘digits = 40’
05:25:31 <shachaf> Anyway, you can still get away with == in specific cases.
05:25:46 <shachaf> I thought CReal was just being really smart and pseudo-symbolic when it managed things like "tan pi == 0"
05:25:58 <nand`> it's nothing that complex
05:26:04 <shachaf> I know. :-(
05:27:17 <nand`> > let eqN n x y = showCReal n x == showCReal n y in eqN 1000 0 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
05:27:19 <lambdabot>   False
05:27:23 <nand`> horrible, I know :P
05:34:36 <MagneticDuck> hey all... I have a syntax error when I put a let statement in a do block
05:34:52 <Botje> probably indentation. can you put it on hpaste?
05:34:56 <MagneticDuck> okey
05:34:58 <shachaf> MagneticDuck: Line 4, delete the space.
05:35:32 <hpaste> MagneticDuck pasted “do block let statement error” at http://hpaste.org/73276
05:35:40 <Astro-> hi
05:35:44 <Astro-> how do I rename/move a file
05:35:49 <Astro-> can't seem to find anything in System.IO
05:35:51 <MagneticDuck> there you are
05:35:53 <Astro-> ?
05:36:17 <MagneticDuck> I think that's in System.Directory or something
05:36:22 <MagneticDuck> let me check
05:36:27 <shachaf> MagneticDuck: That's not a let statement.
05:36:32 <shachaf> It's a let expression.
05:36:45 <MagneticDuck> okay
05:36:46 <shachaf> Get rid of the in.
05:36:47 <Astro-> ah, System.Directory.renameFile
05:36:51 <MagneticDuck> but what's the problem
05:36:55 <MagneticDuck> oh
05:36:57 <MagneticDuck> that's right
05:36:59 <MagneticDuck> thanks
05:37:52 <MagneticDuck> I forgot about that funky thing in do blocks
05:38:53 <MagneticDuck> Astro-: In System.Directory, you're looking for the functions renameFile and removeFile
05:39:00 <Astro-> MagneticDuck: cheers
05:39:06 <MagneticDuck> here's the documentation:
05:39:09 <MagneticDuck> http://hackage.haskell.org/packages/archive/directory/1.1.0.2/doc/html/System-Directory.html
05:39:34 <Astro-> already compiled successfully :)
05:43:36 <merijn> @hoogle m [a] -> (a -> m b) -> m b
05:43:38 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
05:43:38 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
05:43:38 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
05:44:07 <shachaf> merijn: What's that?
05:44:15 <merijn> :t lift forM_
05:44:18 <lambdabot> forall a (m :: * -> *) b (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => t ((->) [a]) ((a -> m b) -> m ())
05:44:26 <merijn> :t liftM forM_
05:44:28 <lambdabot> forall a (m :: * -> *) b (m1 :: * -> *). (Monad m, Monad m1) => m1 [a] -> m1 ((a -> m b) -> m ())
05:44:55 <shachaf> What function are you after?
05:45:04 <merijn> shachaf: I have "IO [Char]" and I want to map putChar over it
05:45:24 <merijn> :t liftM (map putChar)
05:45:26 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char] -> m [IO ()]
05:45:30 <merijn> hmm
05:45:34 <shachaf> @ty (>>= mapM_ putChar)
05:45:36 <lambdabot> IO [Char] -> IO ()
05:45:43 <shachaf> Of course, you could just use putStr. :-)
05:46:34 <merijn> shachaf: Doh
05:46:45 <merijn> Refactoring existing code, so that didn't occur to me :p
05:53:10 <asda8> how does hslogger on hackage have a global logger? I just need to initialize the logger once and only need to import System.Log.Logger in my module to use it. I want to do something similar for my database connection...
05:53:17 <MagneticDuck> okay, now I'm getting an error with an if statement in a do expressions
05:56:28 <fmap> asda8: I guess that's some MVar (or IORef) + unsafePerformIO. Check the sources.
05:57:25 <hpaste> MagneticDuck pasted “if statement in do block” at http://hpaste.org/73277
05:57:38 <MagneticDuck> http://hpaste.org/73277
05:57:48 <MagneticDuck> why does that not compile?
05:58:08 <dmwit> indent the else more
05:58:09 <asda8> fmap: thanks, but I can only find unsafePerformIO once in the code and I don't think it has to do with the global logger
05:58:21 <MagneticDuck> "unexpected semicolons in conditional..."
05:58:26 <MagneticDuck> okay
05:58:51 <MagneticDuck> dmwit: huh, now it looks funny, but works
05:58:58 <dmwit> Otherwise it parses as do { if ... then ...; else ... }
05:58:58 * hackagebot clock 0.3 - High-resolution clock functions: monotonic, realtime, cputime. (CetinSert)
05:59:18 <asda8> fmap: you can't do it with only MVar?
05:59:19 <MagneticDuck> dmwit: aahh
05:59:50 <asda8> fmap: I mean set the logger up and fetch it multiple times via an IO action
05:59:58 <shachaf> asda8: You can have that but it won't be truly "global".
06:00:07 <shachaf> Global things can cause problems, of course.
06:00:15 <MagneticDuck> btw, I want to have a program module with a file name something other then "Main.hs"
06:00:24 <kuribas> Data.IntMap has a worst case complexity of min(n, W).  Does that mean it is faster to use a alist for small n?
06:00:24 <MagneticDuck> does the module name still have to be "Main"?
06:00:43 <shachaf> kuribas: That doesn't say anything about "faster".
06:00:53 <shachaf> kuribas: Don't worry about faster. Write your program. :-)
06:01:16 <kuribas> shachaf: With IntMap or [(Int, Value)] ?
06:01:42 <asda8> shachaf: thanks, I know about them. What I want is to be able to initialize something once and get it from memory afterwards
06:01:52 <shachaf> kuribas: IntMap represents the semantics you want much more nicely, right?
06:01:57 <shachaf> So use IntMap.
06:02:02 <kuribas> shachaf: yes.
06:02:08 <kuribas> ok
06:03:02 <shachaf> kuribas: (I have no idea how you came to that conclusion from that piece of documentation, anyway.)
06:03:23 <kuribas> It's written in the documentation of IntMap.
06:03:34 <kuribas> "Many operations have a worst-case complexity of O(min(n,W)). This means that the operation can become linear in the number of elements with a maximum of W -- the number of bits in an Int (32 or 64). "
06:03:39 <fmap> asda8: no, you can do it only with MVar
06:03:44 <fmap> see http://hackage.haskell.org/packages/archive/hslogger/1.2.0/doc/html/src/System-Log-Logger.html#logTree
06:03:50 <shachaf> kuribas: Right, from that sentence, how did you come to your conclusion?
06:03:57 <fmap> s/can/can't/
06:04:09 <shachaf> W is probably 32 or 64. min(n,W) is going to be <= W
06:04:40 <shachaf> (And anyway asymptotic complexity is so so far from performance-in-practice that you have absolutely no idea how it'll behave in practice for small cases.)
06:05:04 <dmwit> I find using "min" in big-O a bit suspect.
06:05:36 <fmap> @google top level mutable state
06:05:38 <lambdabot> http://www.haskell.org/haskellwiki/Top_level_mutable_state
06:05:38 <lambdabot> Title: Top level mutable state - HaskellWiki
06:05:41 <asda8> fmap: ok, but with simple MVars I can do the following, right? Write getConfigFile :: IO MyConfig which reads the configuration from file or if that's already done, get it from memory.
06:05:43 <fmap> asda8: also see that ^
06:05:50 <kuribas> Anyway, I'd better do profiling when I finish the program.
06:05:54 <dmwit> O(min(n,some constant)) is O(1)
06:06:18 <ezyang> Does anyone know of an article describing the design space for forcing order of evaluation / dealing with IO, and how the Haskell community ended up settling on monads?
06:06:45 <kuribas> dmwit: Yes, but the constant is log(the number of numbers possible).
06:06:55 <fmap> asda8: yes
06:06:55 <asda8> fmap: I don't want top-level mutable state, I just want to store stuff in memory, so I don't have to read from the disk again and again
06:07:00 <shachaf> ezyang: I think I saw an article about the history of that once.
06:07:09 <shachaf> It mentioned continuations and [Response] -> [Request] at least.
06:07:15 <shachaf> Unfortunately I don't remember what it was called.
06:07:27 <dmwit> kuribas: ...so?
06:07:36 <yitz> ezyang: what about spj's history of haskell article?
06:07:40 <ezyang> hm, I wonder if it is tackling the awkward squad that you are thinking of.
06:07:45 <ezyang> yitz: Which one? ;-)
06:08:05 <asda8> fmap: hm, could you maybe provide an example? It's a bit hard to wrap my head around this :)
06:08:06 <kuribas> dmwit: So the complexity is independend from the input?
06:08:09 <shachaf> ezyang: It's possible!
06:09:11 <shachaf> ezyang: Whichever article you find, it would be nice if it mentioned something in the style of the interpreted ADT data IO = PutChar Char IO | GetChar (Char -> IO) | Exit
06:09:21 <shachaf> That's my favorite way to explain how IO works in Haskell.
06:09:27 <yitz> ezyang: http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm
06:09:44 <kuribas> dmwit: But that's often the case when you pick n large enough.
06:10:02 <dmwit> kuribas: I'm not following you. What does it mean for "complexity to be independent of the input"?
06:10:13 <dmwit> Complexity is a property of all inputs.
06:10:20 <shachaf> (And you can easily define your own little IO and write an interpreter for it.)
06:10:23 <Yiq> Fixed point programming - what is that? http://www.mathworks.se/company/events/webinars/wbnr30474.html?id=30474&p1=32475&p2=32477
06:11:17 <kuribas> dmwit: It's constant?
06:11:39 <asda8> fmap: my problem is, that to create an MVar I need to use IO so instead of passing around my configuration / database / logger, I have to pass that MVar around (gaining nothing)
06:11:40 <dmwit> Right, O(1) means it's constant. Are we vigorously agreeing here?
06:11:45 <kuribas> sure
06:12:15 <shachaf> Yiq: I expect that webpage has very little to do with what people might mean by the term in Haskell.
06:12:22 <dmwit> ezyang: You might like http://r6.ca/blog/20110520T220201Z.html
06:12:41 <dmwit> Even though the intro claims to be about something else, it's about the history of IO.
06:13:54 <asda8> fmap: I guess hslogger creates the MVar with unsafePerformIO to get around this. Is that better than initializing stuff with unsafePerformIO directly?
06:14:32 <ezyang> Hmm. I guess one theme these articles have in common, it is that they don't really talk about how the "problem" of /substitution/
06:14:33 <asda8> you'd still need to be in IO to access those things I guess
06:14:49 <shachaf> ezyang: Which problem?
06:14:58 <yitz> > fix $ (1:) . (1:) . (zipWith (+) <*> tail) -- Yiq: like this?
06:15:01 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
06:15:03 <dmwit> The problem of substitution?
06:15:31 <fmap> or probably the answer is "no" and i'm mistaken
06:15:37 <ezyang> As in, laziness lets us always say (\x -> e) y == e[x/y]
06:15:43 <otters> :t zipWith (+) <*> tail
06:15:45 <lambdabot> forall a. (Num a) => [a] -> [a]
06:15:58 <ezyang> but this is emphatically not true when you want to do side effects.
06:16:01 <otters> zipWith (+) <*> tail $ [1]
06:16:05 <shachaf> ezyang: You mean that none of them mention extra-evil "impure" I/O?
06:16:10 <otters> > zipWith (+) <*> tail $ [1..5]
06:16:12 <lambdabot>   [3,5,7,9]
06:16:15 <ezyang> Not quite.
06:16:39 <fmap> asda8: I don't think you need global mutable state at the first place
06:16:40 <shachaf> I think Haskell people start out with substitution as a sort of axiom and then try to make IO fit into the framework.
06:16:49 <ezyang> I guess, the perspective on the issue that I'm developing is that we needed a way to stop Haskell substituting things that it shouldn't
06:17:05 <ezyang> and the best way we ended up with was, "Well, just bind another variable man!"
06:17:05 <fmap> if all your functions need some Config just use Reader
06:17:09 <ezyang> (pun intended)
06:18:09 <ezyang> I feel like someone on the Haskell committee would have been thinking about the problem this way, but I don't see it showing up in any of the historical accounts.
06:18:09 <asda8> fmap: that's still too verbose even if it's just in the type signature, but this is just my opinion
06:18:12 <fmap> asda8: (and I don't understand your last question)
06:18:31 <Saizan> ezyang: bind another variable?
06:18:45 <ezyang> >>= \x ->    <--- that binds a new variable x!
06:18:56 <qwr> ezyang: i've written most of my code interacting with "outer world" using Reader or State over IO
06:18:56 <shachaf> ezyang: Right.
06:19:10 <asda8> fmap: I was asking if using unsafePerformIO for creating an MVar had any benefits compared to doing whatever you want to do with unsafePerformIO in the first place
06:19:11 <yitz> > iterate cos 0 -- Yiq: as shachaf says, more likely they are trying to provide efficient ways of this
06:19:13 <lambdabot>   [0.0,1.0,0.5403023058681398,0.8575532158463934,0.6542897904977791,0.7934803...
06:19:18 <shachaf> ezyang: That's how people tend to deal with most everything in Haskell.
06:19:28 <shachaf> Are you suggesting there's another reasonable way of thinking of I/O?
06:19:37 <qwr> ezyang: kind of easy context for storing the local state and configuration
06:19:58 <Yiq> schahaf: i dont meant the haskell-fix-point either...but if igueed it out
06:20:08 <Saizan> ezyang: binding a variable doesn't seem fundamental, maybe you mean using CPS?
06:20:23 <Saizan> or well, higher order programming
06:20:29 <ezyang> Saizan: Aren't they equivalent in some sense? Yeah.
06:20:44 <fmap> asda8: why don't use unsafePerformIO on every IO action then?
06:21:02 <shachaf> Monads/other models for I/O in Haskell aren't exactly CPS, I think, though they're close.
06:21:04 <asda8> fmap: I guess it has the advantage, that whatever you are storing in the MVar, it is limited to be used inside IO and not inside pure functions
06:21:13 <ezyang> But, as a side effect, we end up with a nice ordering principle, and there is nothing about variable binding that is necessarily ordered
06:21:51 <shachaf> ezyang: Oh, this whole thing is in the context of commutative whatsits?
06:22:04 <shachaf> Monads introduce too much ordering, and all that?
06:22:05 <ezyang> shachaf: Yeah, I'm thinking about commutative whatsits
06:22:09 <merijn> asda8: The main reason why you'd want to unsafePerformIO an MVar is to have a top level MVar
06:22:30 <Saizan> shachaf: yeah, it's still "pass me a function", not necessarily one you'd call a continuation though
06:22:36 <merijn> asda8: If you do "foo = newMVar" at the top level, every use of foo will return a newMVar, instead of the same shared one
06:22:39 <shachaf> I don't know that looking to IO as inspiration for commutative whatsits would be that helpful. :-)
06:23:31 <asda8> merijn: if I have a top-level mvar, I don't need to pass it explicitely to my functions. Just import the module it is in... right?
06:23:49 <dmwit> If you write "foo = newMVar" at the top level, then you can use "foo" and "newMVar" interchangeably. (Surprise! That's what equality means.)
06:23:53 <merijn> asda8: Yes, although that's widely frowned upon in here
06:24:12 <ezyang> So, one stance you could take, is that commutative applicative functors should just be written the same way you write pure code (no idiom brackets, even)
06:24:42 <ezyang> But then substitution bites you in the ass.
06:24:52 <shachaf> Hmm, I guess in one sense threads are a really heavyweight way to talk about commutativity in IO.
06:24:53 <asda8> merijn: I mean why can't I create an IO action that always returns the same MVar? I can create a function which always reads the same file...
06:24:57 <gertc> pleaaas give me Text let j = Data.Text.Lazy.Encoding.decodeUtf8 (Data.ByteString.Lazy.fromChunks [Data.Aeson.encode (toJSON u)] )
06:25:08 <asda8> merijn: or always reads the same data from the database
06:25:10 <gertc>   
06:25:18 <asda8> merijn: why can't I treat memory the same way?
06:25:31 <merijn> asda8: Because newMVar is not a function
06:25:48 <merijn> You could probably build one that always returns the same one, but I'm not sure how
06:26:09 <donri> put the mvar in an mvar!
06:26:20 <ezyang> So the lessons from the development of IO are applicable, because commutative monads are a step on the road to purity.
06:26:24 <Saizan> asda8: oh but you can! do act <- fmap return (newMVar ()); ... here act will always return the same mvar ..
06:26:27 <dmwit> asda8: You can create an IO action that produces an IO action that always returns the same MVar.
06:26:30 <asda8> merijn: if I use an external system, like a key-value store it's easy
06:26:58 <asda8> dmwit: yeah, but what I'm trying to avoid here is passing anything around
06:27:03 <dmwit> asda8: TOUGH
06:27:14 <asda8> dmwit: I want it to be top-level, like an IO action that always reads the same file
06:27:24 * mekeor loves pattern matching once more
06:27:24 <Saizan> asda8: you want globals
06:27:29 <dmwit> asda8: Your functions depend on some shared state. Deal with it.
06:27:31 <t7> State ?
06:27:34 <Saizan> and in fact, files are globals
06:27:38 <shachaf> ezyang: Hmm, that's an interesting perspective.
06:27:39 <shachaf> It seems kind of far from Haskell, though...
06:27:53 <asda8> Saizan: they are, so is the database. I just want the same thing with memory
06:28:11 <ezyang> Yes. It is a much more ML-y perspective, IMO.
06:28:12 <t7> asda8: its not good practise in any language
06:28:12 <asda8> Saizan: just for efficiency, I don't want to read the same file over and over again
06:28:19 <dmwit> I want a rainbow and a lifetime supply of peanut-butter M&Ms.
06:28:22 <t7> harder to test etc
06:28:49 <shachaf> ezyang: (Whatever interesting insights you end up with, you should tell me! I've been vaguely unhappy with the too-much-ordering thing for a while.)
06:29:02 <asda8> t7: I only put something there once, it's not going to change. ever.
06:29:06 <Saizan> asda8: there is a way with unsafePeformIO if you really want
06:29:18 <t7> asda8: at compile time?
06:29:25 <asda8> Saizan: top-level MVar with unsafePerformIO?
06:29:33 <Saizan> asda8: i've just found that people regret the decision to do this
06:29:36 <Saizan> asda8: yeah
06:29:42 <ezyang> I'm not super optimistic on me cracking it; Simon has written about it quite a while ago as an open problem, and most people acknowledge it, but no one's figured it out yet.
06:30:10 <asda8> Saizan: maybe, I just don't understand how this is different than using a database. I'm in IO anyway.
06:30:36 <shachaf> ezyang: How many examples of commutative monads/applicative are there?
06:30:41 <shachaf> (Hmm, is ZipList commutative?)
06:30:55 <ezyang> shachaf: random, fresh names, reader
06:30:56 <shachaf> (I think it is?)
06:31:27 <ezyang> ZipList is.
06:31:36 <shachaf> I guess Maybe too?
06:31:46 <donri> asda8: you can put the mvar in a reader to get local mutable state
06:31:56 <ezyang> Yeah, Maybe is commutative too.
06:32:17 <Saizan> asda8: most often one desings so you can externally point your code to a different database or even use it on different databases in the same program, but with globals that's not doable
06:32:30 <asda8> donri: how is that better? It's more explicit I guess...
06:32:39 <ezyang> Even Either is commutative, up to the semantics described in imprecise exceptions.
06:32:59 <ezyang> (which is that all of the error conditions are valid, and we just gave you one of them)
06:32:59 <donri> asda8: well for one you can run the reader with a different mvar, without mutating a global one
06:33:05 <Saizan> asda8: also if you start doing code loading it ends up using different "databases" for memory, from this pov, without you bein able to control it
06:33:16 <shachaf> ezyang: So you're talking about "commutativity up to some isomorphism", I guess.
06:33:26 <donri> asda8: which keeps the code reusable and testable
06:33:29 <shachaf> (Otherwise fresh names wouldn't work either.)
06:33:30 <ezyang> Yes, random and fresh names are commutativity up to some isomorphism
06:34:12 <asda8> ok, I got the point. I just used hslogger and it seemed really convenient...
06:34:13 * shachaf wonders whether something like forkIO for other monads with the purpose of expressing commutativity makes sense.
06:34:15 <donri> asda8: you're right files are global state, and file IO with hardcoded paths is in deed difficult to reuse and test.
06:34:21 <shachaf> Probably not really.
06:35:16 <shachaf> (I guess monad-par is commutative, though.)
06:36:18 <ezyang> yes, though monad-par is also a bit stronger than commutative in some sense, I think.
06:36:35 <asda8> donri: if I'm writing a database-centric app and writing / reading files all the time: I'm full of state anyway, I couldn't really see how adding the database connection to that global state would hurt me.
06:36:38 <donri> asda8: i think that's the key difference here. an mvar is like a file *path*, so a global mvar is like a hardcoded path.
06:36:54 <shachaf> Well, monad-par's semantics are almost like Identity, right?
06:37:00 <shachaf> Er, no.
06:37:09 * shachaf was thinking of something else.
06:37:16 <ezyang> oh, here is something really weird: if you don't mind your IO actions being duplicated ad nauseum, actually substitution is OK! So something like idempotent monads do OK.
06:37:48 <donri> asda8: your code, do as thy wish :) but it's usually considered a last resort and not the best practice. even if you don't seem to need it *now*, you might be making the code harder to work with for future needs.
06:37:51 <ezyang> This does pretty well if you're in the probability distributions monad, *as long as* you are OK with never having correlated random variables.
06:38:13 <shachaf> I guess ACIO is a restricted IO which is commutative by design.
06:38:53 <donri> atomic, consistent I/O?
06:38:58 <asda8> donri: I will meditate on this, global state is really seductive because I hate typing :)
06:38:59 <shachaf> Affine Central I/O
06:39:15 <shachaf> But the 'C' might as well stand for commutative. :-)
06:39:18 <donri> asda8: not that much typing with a reader monad
06:39:38 <shachaf> donri: http://www.haskell.org/pipermail/haskell-cafe/2004-November/007664.html
06:39:44 <mjga> shachaf: how? I can understand that IO on different objects _may_ be commutative, but normally two writes to the same file are at most associative, not commutative
06:39:52 <donri> asda8: could even make your reader monad an instance of MonadState and use lens operations directly
06:39:55 <shachaf> mjga: ?
06:40:06 <shachaf> mjga: IO-in-general is definitely not commutative.
06:40:40 <asda8> donri: still would have to type "Reader" a lot of times, also "get" and also passing the database connection for executing queries
06:41:16 <asda8> donri: when all your app does is execute queries, it's a bit annoying
06:41:46 <mjga> shachaf: could you give us an example of when this ACIO helps, but unsafePerformIO doesn't?
06:42:17 <asda8> donri: I could just ask GHC to put Connection in front of every one of my functions, it also obscures their types
06:42:17 <ezyang> I think of implicit parameters as another attempt to do normal code style for a commutative monad, with relevant lessons.
06:42:18 <donri> asda8: type synonyms, helper functions...
06:42:21 <shachaf> ezyang: Actually, I think you need affinity as well as commutativity to write "pure-looking code", unless you want to be effect-strict.
06:42:44 <ezyang> Sorry, what have we defined affinity as?
06:42:46 <donri> asda8: it doesn't obscure types, it keeps the types honest about the use of an mvar
06:42:53 <shachaf> ezyang: As in http://www.haskell.org/pipermail/haskell-cafe/2004-November/007664.html
06:43:10 <ezyang> Right-o.
06:43:23 <asda8> donri: I know that every function uses MVar, why would I need that explicitely?
06:43:23 <shachaf> You don't want a stray Nothing turning your whole computation into a Nothing if you don't use it.
06:43:31 <ezyang> So, reader is affine.
06:43:42 <ezyang> Maybe is not affine.
06:43:45 <shachaf> Right.
06:44:37 <donri> asda8: *every* function? :p
06:44:50 <donri> asda8: is this like a 100 lines one-of script or something
06:45:33 <asda8> donri: nope, but it's just about running queries. I want to use haskell because I can combine them easily and I love the syntax
06:45:47 <ezyang> So, tl;dr monad is very clever and manages to slay many related problems but are also very distinct, so this problem is Hard(TM)
06:46:28 <shachaf> ezyang: Sounds reasonable.
06:46:29 <asda8> donri: there will be some code, which isn't IO. But there I can be sure I'm not using MVars anyway :)
06:47:01 <shachaf> Someone should lay out what all these separate problems are.
06:47:18 <shachaf> mjga: Until recently the unsafePerformIO trick actually had a bug.
06:47:23 <donri> asda8: well if it's not for a library you intend for others to use, do wtf you want eh ;)
06:47:32 <shachaf> @google thunks lazy blackholes
06:47:34 <lambdabot> http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
06:47:49 <Saizan> asda8: your primitives for handling queries should be doing the get'ing etc.. your main program should just call those
06:47:55 <donri> thugs and lazy black hoes?
06:48:43 <donri> -XRacistSexistHaskell
06:48:47 <asda8> Saizan: yeah, I plan it that way
06:49:05 <ezyang> Which is why I ask about historical perspectives on IO, since I'm pretty sure the committee /already thought about all of these problems already/ :-)
06:49:36 <asda8> donri: I'll give Reader a shot, but if it annoys me too much I'll just switch to the unsafePerformIO + MVar thing
06:49:37 <Saizan> asda8: then passing a mvar with ReaderT shouldn't be a burden, no?
06:50:20 <shachaf> ezyang: Fair enough!
06:50:39 <asda8> Saizan: yes, I just like typing the whole signature and something that's there everywhere isn't saying much at all
06:50:49 <shachaf> I still suspect looking to IO specifically might be a mistake.
06:52:03 <Saizan> asda8: copy/paste from what ghci infers :P or let an haskell mode do that for you
06:52:24 <dmwit> type IO' = ReaderT MVar IO
06:52:27 <dmwit> enjoy
06:53:28 <dmwit> eh... up to kinding errors, I guess
06:54:14 <Saizan> the worst part of ReaderT over IO is actually the need to liftIO the rest, but even there you can pre-lift a few primtives and stick to them
06:54:38 <dmwit> type IO' a b = MVar a -> IO b -- if that's what you're into
06:54:57 <dmwit> You don't actually need to use ReaderT if that's too bothersome.
06:55:40 <Saizan> that would be worse here
06:56:11 <Saizan> it would work fine if we could abstract MVar a at the module level.
06:56:34 <scooty-puff> is there any way to write a type signature ComplicatedThingICareAbout -> _, where _ will just be whatevers inferred?
06:56:55 <ocharles> I don't think so
06:56:56 <scooty-puff> i have reason to what this when using pattern matching on a GADT that returns a complicated monad stack
06:56:57 <asda8> Saizan: ok, I now probably sound really annoying, but then I'd still have to read it ;)
06:56:57 <scooty-puff> k
06:58:15 <asda8> dmwit: hm, didn't think of aliases yet
06:58:37 <asda8> dmwit: now I only need some kind of auto-lifting ;)
06:59:39 <asda8> maybe template haskell :)
07:00:06 <Saizan> i think you would have already wrote the boilerplate by now
07:00:14 <dmwit> whaaaat
07:00:26 <Saizan> *written
07:00:59 <asda8> Saizan: I like discussing mundane things :)
07:01:13 <asda8> more than I like actual work I guess...
07:07:20 <nobdraisentone> Another good question on stackoverflow with -2 http://stackoverflow.com/q/11988853/ . What is wrong with you, guys?
07:08:22 <MostAwesomeDude> nobdraisentone: That's a pretty poor question; it's hard to tell all of what he's doing and his source isn't complete.
07:08:26 <rking> https://gist.github.com/3356675
07:08:41 <shachaf> Wow, Robert Harper really is somewhat trolly.
07:09:33 <Clint> rtharper: good work
07:09:43 * rtharper is not Rob Harper.
07:10:01 <shachaf> rking: Gah.
07:10:18 * rtharper should change his username...again.
07:10:26 <shachaf> rking: I did something vaguely similar for some C syntax: http://slbkbs.org/structish.txt
07:11:03 <t7> nobdraisentone: not a good question
07:11:11 <t7> but i didnt downvote
07:11:57 <rking> shachaf: LOL… I'm posting this back to #ruby where they were talking about the comprehensions gist.
07:12:58 <rking> shachaf: Too bad it tops out at '**'.
07:13:22 <rking> Though you could do it in multiples of *'s, I suppose (separate statements)
07:13:57 <shachaf> rking: You can stretch the syntax a little further than I went.
07:14:13 <shachaf> But I don't think there's a way to make *** really nice.
07:15:11 <rking> Pretty funny, though.  I'll have to find an opportunity to do an actual parser like this.  That is, the next time I need to read in something that could possibly be Ruby, just let /usr/bin/ruby do the reading. =)
07:18:16 <shachaf> edwardk: Is there some nice thing for doing a bunch of lens sets at once?
07:18:23 <shachaf> Or are you just supposed to use .?
07:18:46 <edwardk> foldr (.) id [foo .~ bar, baz .~ quux] ;)
07:18:51 <shachaf> Well, sure.
07:19:34 <edwardk> not sure how i'd make something for simultaneous lens setting type/law check
07:19:53 <edwardk> armwrestling with getting 'magnify' generalized to handle folds
07:19:58 <edwardk> i have the easy ones done
07:20:19 <roconnor> edwardk: flip (foldr id) [foo .~ bar, baz .~ quux]
07:20:54 <roconnor> shachaf: flip (foldr id) [foo .~ bar, baz .~ quux]
07:21:01 <shachaf> roconnor: Sure.
07:21:05 <shachaf> I think I like foldr (.) id better.
07:21:23 * shachaf has an irrational dislike of flip.
07:21:26 <shachaf> Or maybe it's rational.
07:21:32 <roconnor> > foldr (.) id [f, g] x
07:21:35 <lambdabot>   f (g x)
07:21:39 <edwardk> clearly it should be foldr fmap id
07:21:46 <roconnor> > flip (foldr id) [f, g] x
07:21:49 <lambdabot>   f (g x)
07:21:56 <edwardk> to avoid parens. i have an irrational dislike of parens ;)
07:22:06 <shachaf> foldr fmap (fmap fix return)
07:22:56 <roconnor> I wonder if they are compiled to the same code
07:24:06 <edwardk>  we need lens thrists so we can write out chains like that that change types
07:24:11 <dmwit> Can't we just give (.~) the right fixity so that foo .~ bar . baz .~ quux just works?
07:24:25 <shachaf> dmwit: No.
07:24:25 <edwardk> no, thats worse than the current fixity.
07:24:33 <shachaf> dmwit: You want . to do something else for lenses.
07:24:39 <edwardk> foo .~ bar^.baz $ quux
07:24:39 <dmwit> oh, right
07:24:42 <edwardk> i nice
07:24:45 <edwardk> er is nice
07:24:49 <dmwit> yes, yess
07:25:03 <EVanR> so...... is there a text-like type for ascii text
07:25:21 <shachaf> EVanR: Not really. Why do you want one?
07:25:27 <edwardk> .~ is infixr 4, ^. has fixity 8 . has finity 9, once you go up that high .~ needs parens _everywhere_ else
07:25:30 <shachaf> (Yes, but it's kind of evil. And racist.)
07:25:42 <edwardk> EVanR: we call it bytestring
07:25:58 <EVanR> hmm.
07:25:59 <dmwit> ByteString is extended ASCII. =)
07:26:03 <shachaf> edwardk: Pft. You can fit an ASCII codepoint in 7 bits.
07:26:10 <timthelion> Is it possible to search only open tickets in track?
07:26:10 <shachaf> Which means 9 codepoints in a 64-bit word.
07:26:12 <dmwit> I want UArray Int Word7
07:26:23 <edwardk> shachaf: you clearly need to rewrite bytestring too!
07:26:33 <shachaf> edwardk: No! ByteString isn't for text.
07:26:47 <edwardk> come on. AsciiString. you know you want to
07:26:48 <EVanR> because right now im using text, but im sending it over a 7bit protocol
07:26:59 <shachaf> edwardk: Are you calling me racist?
07:27:22 <shachaf> edwardk: I was vaguely wondering whether there was actually any value to trying UTF-32 text.
07:27:30 <EVanR> and so you can totally put unicode text in there and it will cause epic failure when encoded into a bytestring (using utf8)
07:27:38 <edwardk> O(1) indexing, but worse interop
07:27:45 <shachaf> Even if it's faster would it be worth switching?
07:27:49 <shachaf> Given ICU and all that.
07:28:16 <EVanR> so i want ascii text because i simply dont want to support non ascii text
07:28:23 <shachaf> Codepoint indexing is probably overrated if you have an interface that allows indexing by byte.
07:28:30 <shachaf> But making that interface safe is probably tricky?
07:28:58 <roconnor> edwardk: after rerereading "the essence of the iterator pattern" I'm a bit disappointed that learn that your fancy new lens library is nothing more than a gloified for loop. :D
07:29:08 <roconnor> *glorified
07:29:08 <edwardk> hahahahaha
07:30:25 <edwardk> I can see @PLT_Borat's post now, "Kleene indexed store coalgebroid is port of 'for' loop technology to Haskell"
07:30:42 <roconnor> we had for loops in the 1990's!!
07:30:45 <asid> hello, I have a something of type [(a,[(b,c)])] and I would like to transform it to [(a,b,c)] like this: [(1,[("a","aa"),("b","bb")])] to [(1,"a,"aa"),(1,"b","bb")] could you tell me a simple way to do this?
07:30:52 <shachaf> "coalgebroid"?
07:31:01 <ezyang> So, I've been wondering, who writes @PLT_Borat ;-)
07:31:11 <danr> asid: did you try using a list comprehension?
07:31:11 <drewr> anybody know how to fix this? http://p.draines.com/13451273995330217b031.txt
07:31:13 <roconnor> shachaf: coalgebra's execpt categorified
07:31:19 <drewr> ghc 7.4.1
07:31:24 <shachaf> Oh, right, that's what "oid" means.
07:31:29 <edwardk> technically its a coalgebra of the indexed kleene store comonad, not an coalgebroid there
07:31:34 <edwardk> ezyang: lots of people have
07:31:38 <timthelion> Has anyone tried to make threads that get killed by the GC?  I mean, you would have a value of type Thread, and when that value whent out of scope, than the thread would be killed.
07:31:42 <ezyang> oh I see :-)
07:31:43 <asid> danr: um no, I stumbled around a bit with "map" but I did not really came to a solution
07:31:48 <dmwit> EVanR: Use ByteString, and map (.&. 0b01111111) before you send it down the wire or something.
07:32:01 <shachaf> > do { (x,l) <- [(1,[("a","aa"),("b","bb")])]; (y,z) <- l; return (x,y,z) }
07:32:03 <lambdabot>   [(1,"a","aa"),(1,"b","bb")]
07:32:03 <edwardk> or is it, hrmm
07:32:10 <edwardk> nope thats a coalgebroid
07:32:11 <danr> asid: well, here's a start, f xs = [ ... | (a,ys) <- xs, .. ]
07:32:14 <dmwit> 0x7f, I guess, I was never very good at hex
07:32:20 <danr> or what shachaf said :)
07:32:24 <shachaf> > [(x,y,z) | (x,l) <- [(1,[("a","aa"),("b","bb")])], (y,z) <- l]
07:32:24 <timthelion> My question, is with haskell's GC, is this feasable from a preformance standpoint.
07:32:25 <lambdabot>   [(1,"a","aa"),(1,"b","bb")]
07:32:31 <shachaf> Right. Something like that.
07:32:35 <asid> thanks..
07:32:42 <EVanR> dmwit: on the other hand, i hear there was an rfc to suggest ways to send > 127 over telnet
07:32:53 <EVanR> or 255
07:32:54 <shachaf> timthelion: Threads already get killed by GC.
07:33:10 <EVanR> and some clients might then interpret that as utf8
07:33:10 <timthelion> shachaf: well that's a start :)  But the current behavior is different.
07:33:10 <shachaf> timthelion: Except instead of "reference to the thread", it's "reference to an MVar the thread is blocking on".
07:33:17 <EVanR> and life would go on
07:33:33 <dmwit> Why the !@$* are you using telnet?
07:33:38 <EVanR> mud
07:33:40 <EVanR> obviously
07:33:44 <EVanR> the only use of telnet ever
07:34:02 <Adeon> roguelikes
07:34:02 <timthelion> shachaf: but the current model, is that threads die when the parent thread dies(or before).  I'd like parentless threads, that have a Thread value which is their "parent" and when that Value gets GC'd than the thread would die.
07:34:02 * hackagebot distributed-static 0.2.0.0 - Compositional, type-safe, polymorphic static values and closures (EdskoDeVries)
07:34:09 <Adeon> those that run on servers
07:34:11 <EVanR> i play rogue like over ssh
07:34:14 <timthelion> shachaf: do you see how this could be more intuitive?
07:35:00 <shachaf> timthelion: Threads don't have parents.
07:35:12 <fmap> drewr: did you try to pass that option to ghc?
07:35:39 <timthelion> shachaf: yes they do, sadly... https://github.com/timthelion/threadmanager/blob/master/Test/GrandChildTest.lhs
07:36:04 <timthelion> shachaf: the thread that calls forkIO is the parent of the thread that is forked.
07:36:06 <drewr> fmap: nope; just ran `cabal-dev install ranges` (originally failed when installing yesod)
07:36:10 <shachaf> timthelion: Huh?
07:36:29 <shachaf> timthelion: If thread A forks thread B and thread B forks thread C, and thread B exits, thread C doesn't exit.
07:36:40 <drewr> fmap: using haskell platform on OS X 10.6
07:37:09 <timthelion> shachaf: Try it.
07:37:20 <timthelion> shachaf: yes it does.
07:37:44 <dmwit> timthelion: The program ends when the main thread ends. So keep your main thread running.
07:38:06 <fmap> drewr: you can either add DatatypeContexts extension to .cabal file or pass the extension to ghc directly (--ghc-options=-XDatatypeContexts for cabal, don't know if it works for cabal-dev)
07:38:13 <timthelion> dmwit: but the grandchildthreads also die when their parents die.
07:38:24 <shachaf> timthelion: No. That's not how threads work.
07:38:30 <dmwit> No. The grandchild thread dies in your example because the program ends, not because its parent dies.
07:39:03 <dmwit> Try adding a threadDelay 1e6 at the bottom of main and see what I mean.
07:39:03 <drewr> fmap: ok, thanks; that helps boil down what the error is telling me
07:39:05 <geekosaur> right, special case there is when thread A is the main thread, and that's fairly common behavior across languages/environments.  fork thread A off from the main thread, then watch how threads B, C etc. behave
07:39:11 <timthelion> dmwit: it shouldn't.  wiatForAll should wait for the grandChild if that was true.
07:39:31 <timthelion> dmwit: in my example
07:39:40 <dmwit> What is the name of the package that provides this thread manager?
07:39:50 <timthelion> threadmanager
07:39:51 <shachaf> dmwit: It's in the same git repository.
07:40:04 <timthelion> dmwit: look at the commits before mine
07:40:18 <timthelion> dmwit: the commits owned by bsl
07:40:26 <timthelion> dmwit: https://github.com/bsl/threadmanager
07:41:29 <shachaf> The abstraction is probably broken or something.
07:41:34 <shachaf> There are no "parent" threads.
07:42:04 <dmwit> My hypothesis is confirmed. When I add threadDelay 1000000 to the bottom of main, I get numbers printed after the message "you should morn [sic]".
07:42:17 <drewr> fmap: `cabal-dev install ranges --ghc-options=-XDatatypeContexts` does indeed work, albeit with copious deprecation warnings :-)
07:42:24 <dmwit> So in fact the grandchild thread is not dead when the message claims it is dead.
07:42:49 <timthelion> dmwit: so then there is a bug in waitForAll
07:42:55 <fmap> drewr: yeah, -XDatatypeContexts is actually considered useless
07:42:58 <dmwit> I happily believe that.
07:43:37 * shachaf doesn't like ThreadManager abstraction much on first sight.
07:43:37 <timthelion> OK, so now I understand threads a bit better... hmph
07:44:01 <timthelion> shachaf: what would you like better?
07:44:03 * hackagebot distributed-process 0.3.1 - Cloud Haskell: Erlang-style concurrency in Haskell (EdskoDeVries)
07:44:32 <shachaf> timthelion: Depends on what you're doing.
07:44:41 <dmwit> timthelion: (correct spelling is mourn, paupers)
07:44:55 <Yiq> http://www.erlang-factory.com/upload/presentations/527/erlang-factory-2012-slides.pdf #heroku supported languages. ANYTHING. Including Erlang. ...o including Haskell?
07:45:14 <timthelion> dmwit: thanks :) BTW, I am quite dyslexic I really didn't know how to spell paupers, I even tried googling it.
07:45:38 <timthelion> dmwit: so why did my change fix the bug?
07:45:51 <timthelion> dmwit: if my understanding was wrong...
07:46:37 <dmwit> I don't know, and don't really want to dig into it.
07:46:38 <dmwit> Sorry.
07:46:47 * timthelion is confused now.
07:46:48 <iamtakingiteasy> hi, is there a way to express takeWhile in List monad ?
07:46:53 <luite> Yiq: yes
07:47:07 <luite> Yiq: though you have to compile a compatible executable and upload it
07:47:18 <copumpkin> iamtakingiteasy: no
07:47:21 <iamtakingiteasy> :/
07:47:28 <iamtakingiteasy> copumpkin: k, thanks for clarifying
07:47:39 <copumpkin> list monad is "nondeterministic choice", more or less
07:47:46 <copumpkin> so it'd be hard to deal with ordered choice like that
07:48:29 <dmwit> timthelion: Okay, I understand the bug now, I believe, if not what changed that fixed it.
07:48:51 <timthelion> dmwit: care to explain?
07:48:57 <dmwit> give me a second to type =)
07:49:07 <S11001001> copumpkin: I propose calling list the nondeterminism monad without exception in the future; monad isn't scary enough for newbies anymore
07:49:12 <hpaste> “[author]” pasted “"grandparent"” at http://hpaste.org/73279
07:49:21 <t7> S11001001: agreed
07:49:29 <t7> too many new haskells everyday
07:49:37 <t7> i dont feel very hipster
07:49:42 <dmwit> It goes like this: 1. main thread spawns a thing 2. main thread looks at the list of threads it knows about and waits for all of them 3. secondary thread runs, creating an additional thread, but that's not going in the list the main thread is waiting for since that's already been read
07:50:16 <shachaf> Yes, that looks like the bug in the original code.
07:50:18 <timthelion> dmwit: ah, race condition.
07:50:30 <timthelion> I see now.
07:50:34 <copumpkin> S11001001: or "the monad obtained by composing the adjoint pair of the free functor to the category of monoids and its corresponding forgetful functor back to the category of sets"
07:50:45 <shachaf> In my code main waits for a to end then waits for b to end.
07:50:46 <copumpkin> S11001001: do you think that would help newbies?
07:50:50 <timthelion> dmwit: thanks.  I feel like a bit of an idiot now :)
07:50:51 <shachaf> spawn is so nice. :-)
07:51:11 <Yiq> > msum [Nothing]
07:51:13 <lambdabot>   Nothing
07:51:13 <EVanR> copumpkin: nice
07:51:21 <S11001001> copumpkin: problem is IRC has 510-character command limit
07:51:26 <copumpkin> true
07:51:28 <Yiq> > msum [Just 5]
07:51:29 <lambdabot>   Just 5
07:51:43 <MostAwesomeDude> /monad
07:51:44 <timthelion> dmwit: yet, there actually IS a bug in the threadmanager code then.
07:51:44 <EVanR> haskell needs syntactic sugar for generalized abstract nonsense
07:52:17 <timthelion> dmwit: the bug is that waitForAll should update the list that it's waiting for, each time a thread terminates, so it actually has an up to date list.
07:52:40 <shachaf> timthelion: That's not the bug. That's a proposal for how to change it.
07:52:53 <timthelion> shachaf: but there *is* a bug.
07:52:58 <shachaf> Yes.
07:53:00 <dmwit> That seems like a rather unfortunate way to fix it.
07:53:16 <timthelion> dmwit: how should it fix it?  Laziness of the list?
07:53:20 <timthelion> rather than a map
07:53:49 <dmwit> Laziness isn't going to help. But I don't know what is a good way to fix it.
07:53:53 <shachaf> Laziness won't give you anything.
07:54:16 <EVanR> you only get ahead with perserverance and hard work
07:54:37 <shachaf> I think the idea of "waitForAll" might be flawed, at least in this context.
07:54:45 <shachaf> Oh, you could use a Queue of threads instead of a list.
07:54:48 <ocharles> Any crypto-api users around? Is the idea that I have to create instances of the provided classes, or is there already a common set of instances?
07:54:54 <ocharles> I'm having a bit of a hard time getting started with it
07:55:00 <shachaf> But that's still nasty.
07:55:01 <timthelion> shachaf: like a Chanel?
07:55:08 <shachaf> timthelion: I mean Chan, sorry.
07:55:15 <timthelion> shachaf: yes, that would work.
07:55:20 <dmwit> I think Chan isn't quite right, but something similar, yes.
07:55:31 <dmwit> (Since you never get to observe a Chan "coming to the end" so to speak.)
07:55:35 <shachaf> I don't think you'll figure out any really nice abstraction, though...
07:55:43 <shachaf> dmwit: Right.
07:55:45 <mm_freak> ocharles: Crypto-API is really just the interface…  there are no default instances IIRC
07:56:01 <shachaf> dmwit: I was wondering what a nice abstraction on top of Chan would be.
07:56:09 <dmwit> I had thought of (and rejected) Chan by the time I said I didn't know what a good way to fix this was. =P
07:56:11 <shachaf> You can use Chan (Maybe a) and stop at Nothing.
07:56:16 * timthelion goes back to look at his "fix" to see if it even helped.
07:56:18 <ocharles> mm_freak: ok. is there a package of default instances? :)
07:56:30 <shachaf> Maybe that shouldn't be so much a "bounded Chan" as a "chunked Chan".
07:56:40 <timthelion> shachaf: who's going to put Nothing in there though?
07:56:40 <mm_freak> ocharles: most crypto packages now provide a Crypto-API interface
07:56:41 <shachaf> I.e., you can "take from this Chan until the next Nothing".
07:56:51 <shachaf> timthelion: Yes, it won't work for your program.
07:56:57 <mm_freak> ocharles: just look around hackage…  out of my head i can name only one right now:  cprng-aes
07:57:00 * shachaf was wondering about this for other contexts, though.
07:57:12 <ocharles> does hackage have a reverse dependency graph?
07:57:39 <dmwit> hm
07:57:48 <dmwit> How about an MVar that stores a list of MVars? =)
07:57:49 <ocharles> http://packdeps.haskellers.com/reverse/crypto-api magic!
07:57:50 <mm_freak> ocharles: don't think so, but you can grep with -A and -B on cabal list output
07:57:56 <mm_freak> oh!
07:58:00 <mm_freak> that's great, thanks =)
07:58:10 <dmwit> "when I finish, check all these guys, too, please"
07:58:24 <timthelion> dmwit: still have to check for updates recursively.
07:58:58 <dmwit> Oh, yes, but you don't have to reread the entire list of threads. Only the ones that have started since you last checked.
08:00:18 <timthelion> dmwit: true
08:00:20 * dmwit shrugs and wishes timthelion the best of luck
08:00:51 <shachaf> I don't think a centralized waitForAll is a good primitive.
08:01:06 * dmwit neither
08:01:11 <timthelion> :(
08:01:15 <shachaf> I said that at the beginning, though. :-)
08:01:22 <shachaf> Just wait for the threads that you're responsible for.
08:01:23 * timthelion thinks it's very usefull.  And usefull= good.
08:01:56 <dmwit> What is it used for?
08:02:41 <Cale> timthelion: useful has one l
08:02:55 <Cale> (usually)
08:03:09 <timthelion> dmwit: say you have a whole bunch of threads that are in an event loop.  These threads, want to save some setting info on program exit.. So you send them a Term signal.  They start to save.. and you want to wait for them to exit naturally, so that info actually gets saved.
08:03:42 <dmwit> Yup, with you so far.
08:04:03 * hackagebot case-insensitive 0.4.0.2 - Case insensitive string comparison (BasVanDijk)
08:04:04 <shachaf> timthelion: A *localized* thread pool that can be waited for, with a clear notion of ownership, might be sensible.
08:04:31 <shachaf> That's just a small abstraction for a thing people do anyway when spawning multiple threads.
08:04:50 <timthelion> dmwit: So you would, say, putTVar termTVar Term...  and each of these loops would have an orElse that would be listening for a myEventTVar or termTVar and if termTVar was filled, they would putTVar termTVar Term and then save and then exit.
08:05:14 <timthelion> dmwit: and then you would want to wait for ALL theads to exit.
08:05:31 <timthelion> in order to exit that is.
08:05:40 <timthelion> shachaf: that's not usefull in this case.
08:05:50 <shachaf> But a pseudo-global "thread manager" for the whole program is inviting race conditions like the one you had, among other things.
08:06:19 <timthelion> shachaf: one bug, and you start jumping up and down!
08:06:21 <EVanR> thread manager :(
08:06:25 <shachaf> timthelion: Anyway I agree that MVar is too low-level an abstraction for spawning things that you wait for.
08:06:48 <dmwit> timthelion: Eh, you suddenly lost me.
08:06:49 <shachaf> That's why we have things like "Spawn" and "Async".
08:07:01 <dmwit> timthelion: Why are you waiting for all threads to exit, and not just the ones you spawned?
08:07:20 <timthelion> dmwit: because we are exiting the entire program, and we want to make sure all settings get saved.
08:07:54 <EVanR> figure out how to make threads that can get killed anytime and not care
08:08:01 <EVanR> then just exit the main thread
08:08:21 <shachaf> timthelion: Just wait for the ones you spawned.
08:08:25 <shachaf> Let them wait for the ones they spawn.
08:08:30 <timthelion> EVanR: that's idiotic.  If the thread has information that needs to be saved to disk, they cannot be killed at anytime.
08:08:31 <asid> there was a function which executes all IO () actions in a list but I cannot find it via hoogle, can someone help me?
08:08:40 <timthelion> shachaf: memory leak
08:08:50 <MostAwesomeDude> asid: Did you want sequence?
08:08:51 <EVanR> timthelion: if it needs to be saved to disk before exit, why are you quitting before?
08:08:53 <MostAwesomeDude> :t sequence
08:08:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:08:56 <shachaf> timthelion: What?
08:09:00 <dmwit> timthelion: ...memory leak?
08:09:21 <EVanR> timthelion: i think acid state helps with this idea a lot, now everything is always saved to disk
08:09:28 <dmwit> ?hoogle [IO ()] -> IO ()
08:09:29 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
08:09:30 <lambdabot> Test.QuickCheck.Test safely :: State -> IO () -> IO ()
08:09:30 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
08:09:30 <shachaf> EVanR: These are unrelated problems.
08:09:32 <asid> sequence! yes thanks
08:09:33 <timthelion> dmwit: if you have, for example, a recursion, that spawns each time.  And each thread is waiting for it's children, you could have an infinite number of threads waiting.
08:09:33 <dmwit> bummer
08:09:38 <dmwit> ?hoogle [m a] -> m ()
08:09:39 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
08:09:39 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
08:09:39 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
08:10:00 <dmwit> timthelion: wut
08:10:05 <timthelion> EVanR: what about SDD?  You don't WANT to always sinc to disk... What about preformance?
08:10:20 <shachaf> ==dmwit
08:10:28 <EVanR> acid state is high performance
08:10:28 <shachaf> An infinite number of threads sounds exciting, though.
08:10:44 <timthelion> dmwit: shachaf was telling me, that each thread should wait for it's children.  Which is idiotic.. What if there was a great great great great grand child. Should all the grandparents just be sitting arround waiting?
08:10:55 <shachaf> Yes.
08:11:01 <timthelion> shachaf: that is dumb!
08:11:02 <MostAwesomeDude> timthelion: What else do grandparents do?
08:11:09 <shachaf> timthelion: I'm sorry. :-(
08:11:22 <timthelion> shachaf: think about it. you have finite resources.
08:11:30 <MostAwesomeDude> Actually, my granddad goes down to the Elks sometimes, but that's probably not relevant.
08:11:36 <dmwit> timthelion: You *already have those threads*.
08:11:43 <dmwit> You've already spent the resources.
08:11:50 <dmwit> Now you're telling me you want to unspend them?
08:11:55 <fryguybob> timthelion: "you have finite resources" <- didn't you just say infinite threads?
08:11:59 <timthelion> dmwit: but if those threads would otherwise die, then the resources otherwise are not spent.
08:12:10 <shachaf> dmwit: timthelion wants TCO for thread-waiting.
08:12:25 <timthelion> no, I just want a waitForAll function that works :)
08:12:27 <shachaf> It's a silly optimization for any practical program I can think of.
08:12:39 <shachaf> timthelion: No, that function has the wrong semantics.
08:12:40 <timthelion> what is so hard about a waitForAll function?
08:12:55 <shachaf> timthelion: Nothing. Go ahead and write one that works.
08:13:10 <dmwit> Are you perhaps thinking that threads are expensive?
08:13:18 <dmwit> GHC can handle a few hundred thousand of them without choking.
08:13:34 <companion_cube> infinite threads in a finite amount of memory, of course :>
08:13:42 <EVanR> should be possible
08:13:46 <timthelion> dmwit: no, but I'm thinking, that a build up of threads that are simply waiting for another thread that they spawned, before they themselves can die, is a waste of resources.
08:14:15 <dmwit> The whole program is about to die. Who cares?
08:14:26 <dmwit> You've been wasting those resources all program long.
08:14:31 <otters> A hundred thousand threads? What would you need that for?
08:14:36 <dmwit> Now you're worried that you're going to waste them another few microseconds?
08:14:43 <timthelion> dmwit: no, you don't get it.
08:14:47 <dmwit> No, I don't.
08:14:47 <EVanR> dontWaitForAny
08:14:50 <shachaf> dmwit: No, that's not what timthelion means.
08:15:07 <fryguybob> EVanR: don'tWaitForAny
08:15:14 <EVanR> haha
08:15:21 <timthelion> dmwit: say I have a threadA that spawns threadB, then threadA dies... Should threadA have to wait for threadB throughout the entire runtime of the program?
08:15:23 <shachaf> dmwit: A starts B starts C starts ... starts F. F now does an hour of actual work.
08:15:33 <timthelion> shachaf: yes!
08:15:36 <shachaf> dmwit: You might have whole *kilobytes* of wasted memory with B..F!
08:16:04 <dmwit> throughout the entire runtime of the program? No!
08:16:04 <flux> maybe your program works so that it always starts a new thread - from the previously created thread - to handle a request.
08:16:12 <timthelion> flux: exactly!
08:16:22 <dmwit> Only when it receives a signal to die.
08:16:31 <shachaf> A sort of "TCO" for thread-waits would fix this, maybe. I don't know.
08:16:40 <shachaf> Anyway, waitForAll still has the wrong semantics.
08:17:05 <shachaf> If you want a simple work-around, just have A pass an MVar to B, which will pass it to C and then terminate, and so on.
08:17:14 <shachaf> That way there's a clear idea of ownership.
08:17:42 <shachaf> That's not a "work-around", really -- if your program is structured as you mentioned, it's a sensible way to do things.
08:17:59 <shachaf> I have no idea why thread T would spawn thread U only to wait for U to finish and then exit.
08:18:02 <timthelion> shachaf: so how would that work.  What does the MVar hold?
08:18:03 <shachaf> Just run the action yourself.
08:18:07 <shachaf> timthelion: ()
08:18:34 <shachaf> Anyway, waitForAll is wrong, and you seem to be ignoring what people are saying about it.
08:18:49 <timthelion> shachaf: the usual reason I do it, is to get arround problems with blocking GUI toolkits like GTK ;)
08:19:20 <EVanR> only wait for some threads, the ones that need to 'finish'
08:19:33 <EVanR> let the other ones die with extreme prejudice
08:20:02 <timthelion> EVanR: You don't seem to understand at all.  Most threads should be given some time to quit after they are given a term signal.
08:20:12 <EVanR> 'most threads' ?
08:20:21 <timthelion> yes, most threads in my program.
08:20:21 <EVanR> most threads i use dont need to do that
08:20:25 * shachaf has no idea what is being talked about anymore.
08:20:33 <EVanR> and i dont know what 'some time' is
08:20:39 <timthelion> EVanR: we are using threads for different things then...
08:20:55 <shachaf> This conversation should probably go to #haskell-overflow
08:21:24 <EVanR> i missed the part about why mvar is not good enough
08:21:25 <fryguybob> timthelion:  do p <- initializeWaitPool; ... spawnP p act ... waitForPool p
08:22:14 <timthelion> fryguybob: give me a seccond to digest that.
08:22:31 <timthelion> EVanR: an MVar holding what, being put by whom, being taken by whom?
08:23:35 <timthelion> fryguybob: hayoo doesn't know initializeWaitPool
08:25:19 <EVanR> timthelion: holding a counter
08:26:07 <timthelion> EVanR: oh, yes.  OK.  so at the end of each thread, you'd just have to remember to decriment the counter.  Works, bit tricky to debug.
08:27:03 <timthelion> actually waitForAll should work, despite the protests of most people in this channel.  Just make it recursive.  Make it recurse iff there where still threads running last time it was called.
08:27:52 <timthelion> That will indeed always work
08:29:02 <fryguybob> timthelion: I'm just telling you an API (that you could write) that is like waitForAll, but is explicit about it's state and you don't have to wonder if it will work because you are actually in control of all the necessary parts.
08:29:04 * hackagebot lifted-base 0.1.2 - lifted IO operations from the base library (BasVanDijk)
08:29:52 <timthelion> fryguybob: I don't see the difference actually...
08:30:18 <fryguybob> timthelion: Do you see the explicit state?
08:30:49 <timthelion> fryguybob: no :/
08:30:59 <fryguybob> timthelion:  p <-
08:31:57 <timthelion> fryguybob: did you meant to write p' <- spawnP p act ... waitForPool p' ?
08:32:35 <fryguybob> timthelion: No.
08:32:36 <JoeHazzers> i'm getting a [IO ()] coming back from an action. how do i just "disregard" it in a do?
08:32:57 <shachaf> JoeHazzers: [IO ()] or IO [()]?
08:33:07 <JoeHazzers> [IO ()]
08:33:16 <shachaf> JoeHazzers: You can always use "return ()" at the end of a do-block to have the whole thing be of type "IO ()"
08:33:30 <shachaf> But if you're dealing with [IO ()], the actions didn't actually get executed.
08:33:38 <timthelion> fryguybob: then I really don't. the syntax looks quite the same to me, as that of threadmanager's.
08:33:49 <shachaf> (Also, you probably want an _ function like mapM_ or sequence_)
08:33:50 <typoclass> JoeHazzers: you could also do "void $ yourAction", which may or may not be what you want (see shachaf's remark)
08:34:09 <JoeHazzers> yeah, i should probably check that this is even working as intented.
08:36:24 <timthelion> fryguybob: ?
08:37:32 <fryguybob> timthelion: Ah, I wasn't looking at that API.  Yes that is the same.  The pitfall of this approach is you can easily screw things up.  Much better to add a layer where you can express more meaningful and specific work.
08:38:04 <timthelion> fryguybob: there's actually nothing wrong with this API.  It can be done, the bug just needs to be fixed...
08:38:11 <fryguybob> timthelion: If you have a bunch of work that does stuff, then saves stuff, abstract out the reading and writing.
08:38:31 <timthelion> and they shouldn't have used F'n Map!  It's soo hard to understand :/
08:39:10 <timthelion> fryguybob: I don't really want to design my application arround it's exit sequence :P
08:40:56 <ocharles> how do I go from a String -> Data.ByteString? Do I have to go through Data.ByteString.Char8 first?
08:41:06 <ocharles> always forget this...
08:41:13 <ocharles> I basically need [String] -> [Word8], actually
08:41:13 <shachaf> ocharles: That depends.
08:41:26 <shachaf> What do you want to do with the String "á"?
08:41:40 <ocharles> string is only ascii
08:42:00 <shachaf> Do you mean [Char] instead of [String]?
08:42:07 <ocharles> I mean String -> [Word8], even
08:42:13 <ocharles> so, yes
08:42:14 <shachaf> Well, if you're sure, you can map lossyCharToWord8Function str
08:42:24 <shachaf> Probably something like (fromIntegral . ord)
08:42:49 <Clint> is that better than Data.ByteString.Char8.pack?
08:43:00 <dmwit> مسص لنضک نتی کشپی
08:43:06 <dmwit> uhh... "no, it's the same"
08:43:21 <timthelion> dmwit: you speak arabic?
08:43:27 <dmwit> I'm learning Persian.
08:43:32 <timthelion> I see
08:43:36 <timthelion> good choice
08:43:54 <timthelion> I have friends in afghanistan
08:45:08 <mbuf> is there a recommended way to write a function to poll a remote web service to check for change in status or update, or should it just be put in a do notation?
08:45:16 <ocharles> bah, I can't get this SHA512 HMAC to come out the same as python :(
08:45:35 <fryguybob> timthelion: The fact that you care about saving state at exit is an implementation detail.  I'm saying it is much better to be able to write more of your program with parts that look like   Request -> Response  instead of   Request -> IO Response
08:45:37 <hpaste> ocharles pasted “hmac sha512” at http://hpaste.org/73282
08:45:55 <fryguybob> timthelion: And you get the freedom to do whatever state saving you want with that.
08:46:13 <sipa> ocharles: what's that 128?
08:46:20 <ocharles> sipa: the block size
08:46:26 <ocharles> https://gist.github.com/3371201 is my python implementation
08:46:35 <sipa> ok, input block size?
08:46:38 <ocharles> according to python's "hashlib.new('sha512').block_size", 128 is the block size
08:47:12 <sipa> yes, that's correct
08:47:16 <ocharles> ok, that's good
08:47:30 <sipa> 1024 bits input, 512 bits output, iirc
08:47:40 <johnw> i wish Puppet were written in Haskell
08:48:02 <JoeHazzers> how difficult is it to get Network.HTTP to play ball with bytestrings?
08:48:25 <johnw> JoeHazzers: http://nominolo.blogspot.com/2007/05/networkhttp-bytestrings.html
08:48:29 <johnw> does that help?
08:49:18 <timthelion> fryguybob: that's fine if you have a list of objects which reside in threads, and need saving of type a, but once that list is polymorphic. it's better to keep the saving code with the object, uless you were to declare a typeclass Savable, which I'll think about...
08:49:28 <JoeHazzers> looks more like a full rewrite
08:50:42 <fryguybob> timthelion: Or  Request -> IO (Response, IO ())  and explicit saver to be scheduled by someone else, but that doesn't get you nearly the benefits of being more explicit about your state.
08:51:01 <typoclass> JoeHazzers: you might want to look at the http-conduit package. i think it gives ByteStrings by default
08:51:40 <merijn> JoeHazzers: I second http-conduit, it's interface is much nicer than Network.HTTP
08:52:00 <merijn> Also, it works really nice with xml-conduit and html-conduit if you later want to parse the fetched document
08:53:20 <nand`> isn't http-conduit also much, much faster?
08:53:22 <ocharles> so any idea what the difference between  https://gist.github.com/3371201 and  http://hpaste.org/73282 is? :) my crypto fu is weak
08:53:45 <merijn> nand`: And has more deterministic resource usage, etc. :p
08:53:57 <merijn> In general, it's just better :p
08:54:23 <shachaf> ocharles: What packages do I need to run the Haskell?
08:54:25 <bitonic> there's also `curl', if you don't want to pull in a thousand dependencies.
08:54:38 <luite> except libcurl...
08:55:17 <bitonic> actually, `curl' uses Strings as well.
08:55:51 <shachaf> Ah, "Crypto".
08:55:56 <ocharles> shachaf: Crypto, base64-bytestring
08:56:00 <shachaf> I don't like this library much, by the way.
08:56:05 <shachaf> But anyway.
08:56:08 <ocharles> shachaf: happily use something else
08:56:15 <ocharles> I just need to generate hmac signatures with sha512
08:56:17 <shachaf> I don't know what a good one is for Haskell. :-(
08:56:26 <ocharles> i didn't manage to really find any
08:56:31 <Clint> cryptohash isn't too bad
08:56:53 <shachaf> Clint: Is it not?
08:56:58 <ocharles> oh, it does hmac too
08:57:01 * shachaf doesn't like the part where it's written in Haskell, for instance.
08:57:06 <Cale> iirc, the main problem with Crypto is just that it's old
08:57:09 <shachaf> Not that it matters so much here, maybe...
08:57:13 <shachaf> But who knows.
08:57:20 <ocharles> ooooh
08:57:36 <ocharles> Crypto.MAC.HMAC  is almost :: ByteString -> ByteString -> ByteString
08:57:38 <ocharles> that looks approachable
08:57:46 <timthelion> if I do newtype StringFoo = String, can I then define competing typclass instances for StringFoo which are DIFFERENT than their String counterparts?
08:57:49 <ocharles> lovely "Int" parameter that is completely undocumented
08:58:04 <merijn> timthelion: Yes
08:58:19 <timthelion> merijn: cool :) thanks
08:58:38 <fmap> bitonic: iirc curl can use bytestrings too
08:59:06 <Clint> ocharles: well, not _completely_
08:59:12 <luite> curl is annoying to install on windows
08:59:40 <ocharles> Clint: ok, but I had to read the source to figure out exactly what it was
08:59:44 <Clint> right
08:59:57 <Clint> you could file a bug
09:00:01 <ocharles> but sadly I'm getting used to the state of documentation in haskell. our communities biggest weak point, imo. but it's getting better
09:00:07 <ocharles> of course, we all know that too
09:00:07 <ocharles> :)
09:00:26 * ocharles submits a doc pull request
09:00:29 <bitonic> merijn, timthelion: no, you can't
09:00:48 <bitonic> ah
09:00:49 <bitonic> newtype.
09:01:02 <ocharles> hurrah! haskell and python agree on my hmac signature of "foo" "bar"
09:01:03 <bitonic> sorry, yes, you can.  but `newtype StringFoo = String' is not valid haskell.
09:01:07 <timthelion> ocharles: what are you talking about? haddock seems to be one of the strong points.  If I don't get something, then I look at it's type, if I still don't get it, I look at it's source...
09:01:12 <ocharles> thanks for pointing me to this library Clint
09:01:15 <shachaf> ocharles: Block size is 1024.
09:01:24 <ocharles> timthelion: haddock does not write the prose
09:01:25 <shachaf> Then the Haskell code gives the same result as the Python code.
09:01:28 <ocharles> just the formatting
09:01:38 <shachaf> Of course, the fact that you have to know that...
09:01:42 <ocharles> timthelion: a user should never have to read the source to figure out what a paremeter is
09:01:55 <ocharles> shachaf: ahhh, not 128
09:02:02 <timthelion> bitonic: I see yes,
09:02:04 <shachaf> Yes, block sizes are measured in bits.
09:02:06 * ocharles nods
09:02:14 <ocharles> (in Crypto)
09:02:15 <Clint> ocharles: sure thing
09:02:20 <shachaf> ocharles: In general. :-)
09:02:20 <bitonic> timthelion: yes to what?
09:02:28 <timthelion> ocharles: I don't really see the problem with reading the source, as long as it's clear and easy to get at.
09:02:37 <shachaf> ocharles: You can SHA512 a bitstring whose length isn't a multiple of 8.
09:02:53 <timthelion> bitonic: that I wrote the syntax wrong
09:02:59 <bitonic> timthelion: OK
09:03:15 <bitonic> so you meant something like `newtype StringFoo = StringFoo String'
09:04:20 <timthelion> bitonic: right now I have a function of type foo :: a -> IO a -> (a->b)-> IO a,,, and I wanted to see if changing this to foo :: Fooable => a -> IO a and requiring the programmer to create a fooable instance wouldn't be clearer.
09:04:22 <Clint> shachaf: hmm, the cryptohash description says "The implementations are made in C with a haskell FFI wrapper that hide the C implementation.
09:04:43 <shachaf> Clint: Oh, maybe I was confusing it with something else.
09:04:48 <timthelion> bitonic: but I want to make sure, that two values of the same type, could have different functions associated with them.
09:05:03 <timthelion> bitonic: and by functions, I mean typeclass instances.
09:05:05 <bitonic> timthelion: two values of the same type can't have two different instances.
09:05:09 <shachaf> Anyway I have other problems with Haskell cryptography libraries but now isn't the time for that.
09:05:33 <sipa> bitonic: with overlappting instances, they can :)
09:05:36 <bitonic> timthelion: for obvious reasons.  if `StringFoo' is a newtype containing `String', it is *not* the same type as `String'.
09:05:58 <timthelion> bitonic: I'm on the fence in this.  But if the programmer can just NewType every time they need a different instance, it's equivalent.
09:06:00 <nand`> sipa: that's not how overlapping instances work though
09:06:05 <bitonic> sipa: you still can't define two instances for the same type
09:06:14 * timthelion having though about it more, now see's that the typeclass idea was stupid.
09:06:21 <bitonic> timthelion: what's equivalent to what?
09:06:45 <timthelion> bitonic: reboxing a value with a newtype, is equivalent to passing the functions seperately.
09:06:54 <timthelion> bitonic: but it's clunkier, so I won't do it.
09:07:02 <bitonic> timthelion: passing what functions?
09:07:09 <bitonic> ah, the typeclass functions
09:07:39 <timthelion> bitonic: like in the example I showed you.  Now I pass functions.  If I instead had the programmer define a typeclass instance with those funcitons, it would be equivalent, but worse.
09:08:02 <bitonic> timthelion: well it depends.  if it makes sense to "bind" those functions to types...
09:08:12 <sipa> nand`: if you have typeclass for FooClass (X a B) and one for FooClass (X A b), you have two instances for a value matching (X a b), no?
09:08:33 <sipa> or you need IncoherentInstances before there is actually chance both get chosen for a given type?
09:08:42 <nand`> sipa: no. -XOverlappingInstances works by merging together the clashes so that each type ends up having only one instance
09:08:50 <nand`> in fact I'm not even sure what it would do in that particular case, maybe just error
09:09:12 <danil> sipa: neither of those is more specific than the other, so OverlappingInstances still says it can't resolve it rather than choosing one arbitrarily
09:09:35 <sipa> right; you need IncoherentInstances, in which case it picks the first matching one, iirc
09:09:45 <bitonic> sipa: that is irrelevant to timthelion question
09:09:51 <timthelion> bitonic: I thought it did, because what I have, is like a String, that gets drawn to a GTK label.  But when I thought about it more, I realised, that the value doesn't just get drawn to "any" label, but a specific label.  So it would in reality change my function to foo :: Fooable a => a -> Lable -> IO a ... which really doesn't help.
09:09:52 <bitonic> I think UndecidableInstances is enough
09:10:35 <timthelion> bitonic: so I might have many Strings, that all get drawn to GTK Labels, but that still doesn't let me abstract at all :/
09:10:48 <nand`> think FooClass (X a b) and FooClass (X A b); the definitions overlap for (X A b), but OverloadedInstances makes it work by ‘cutting out’ (X A b) types from the (X a b) instance and filling that hole by (X A b) instead
09:14:08 * hackagebot network 2.3.1.0 - Low-level networking interface (JohanTibell)
09:18:26 <JoeHazzers> shachaf: i figured out my problem. in totally not unrelated news i remembered that sequence existed after sleep deprivation
09:18:59 <shachaf> JoeHazzers: You want sequence_
09:19:24 * JoeHazzers goes on to the wiki to find out why he should never use sequence
09:19:44 <nand`> you almost never want sequence with ()
09:19:56 <nand`> that is, [IO ()]
09:20:09 <JoeHazzers> then how do i run all of the actions?
09:20:20 <shachaf> sequence_
09:20:24 <nand`> :t sequence `asAppliedTo` (undefined :: [IO ()])
09:20:26 <lambdabot> [IO ()] -> IO [()]
09:20:27 <shachaf> JoeHazzers: sequence is good.
09:20:28 <nand`> :t sequence_ `asAppliedTo` (undefined :: [IO ()])
09:20:29 <lambdabot> [IO ()] -> IO ()
09:20:42 <shachaf> JoeHazzers: But you're not actually using the result here, I assume.
09:20:58 <shachaf> sequence_ is like sequence except it doesn't give you a result.
09:21:02 <JoeHazzers> oh okay
09:21:04 <nand`> note that [()] is fairly useless unless you have some contrived unary counting going on
09:24:08 <JoeHazzers> shachaf: no, it's the result of some file operations
09:33:24 <edwardk> back to trying to figure out magnify
09:34:37 <edwardk> i got zoom to work for everything with traversals (except Cont), but magnify with folds is stymying me on getting over state for some reason
09:34:38 <hpaste> daniel_- pasted “going mad soon” at http://hpaste.org/73283
09:35:09 <timthelion> How can I lookup the haddock page for a module given it's name, say Data.Map?
09:35:39 <shachaf> @google data.map hackage
09:35:41 <lambdabot> http://hackage.haskell.org/packages/archive/containers/0.3.0.0/doc/html/Data-Map.html
09:35:41 <lambdabot> Title: Data.Map
09:35:47 <Cale> timthelion: If you have local documentation, then file:///home/timthelion/.cabal/share/doc/index.html will list it
09:35:49 <daniel_-> and to note that ``lookup cfg (pack "MAX_RUNNING_SERVICES")`` works fine
09:35:54 <dmwit> ...or just put "Data.Map" in Hoogle. It works.
09:36:06 <Cale> Otherwise, using the google site search on hackage is the easiest way
09:36:57 <timthelion> Cale: ok, :/ I'm surprised neither hayoo, nor hoogle can manage this. but I'll live .)
09:37:31 <Cale> timthelion: If you know what package the module is in, then you can browse the package list on hackage and then pick the module name
09:37:38 <timthelion> dmwit: actually hoogle only found Data.Map.Lazy ...
09:37:40 <Cale> (after clicking on the package)
09:37:45 <geekosaur> hayoo doesn't suppoet module:Data.Map ?
09:38:02 <Cale> timthelion: Data.Map just re-exports everything in Data.Map.Lazy
09:38:04 <timthelion> geekosaur: I didn't try that syntax
09:38:17 <Cale> timthelion: So everything is really in Data.Map.Lazy anyway
09:38:18 <timthelion> Cale: perhaps that's why :)
09:38:19 <daniel_-> anyone familiar with the Data.Configurator package?
09:38:28 <geekosaur> that's what is documented on its landing page...
09:38:43 * timthelion still isn't clear why anyone would want a Map over a [(a,b)]
09:40:10 * BMeph wonders why anyone would want a [(a,b)]...
09:40:34 <timthelion> BMeph: Simplicity :)
09:40:47 <donri> timthelion: fast lookup
09:41:11 <parcs`> Map has a better api
09:41:17 <donri> timthelion: consistently non-duplicate keys
09:41:19 <daniel_-> okay, i give up. can anyone recommend a nice package for handling configurationfiles?
09:41:29 <donri> daniel_-: dyre, configurator
09:41:44 <daniel_-> configurator is not working as expected for me
09:41:48 <nexx> i find it simpler to use a map over a [(a,b)]
09:42:11 * timthelion still hasn't figured out how to map over the tuples in a Map.
09:42:20 <shachaf> A Map doesn't have tuples.
09:42:24 <daniel_-> http://hpaste.org/73283 also note that ``lookup cfg (pack "MAX_RUNNING_SERVICES")`` works fine
09:42:50 <timthelion> shachaf: technically true, but I'd like to map over the key value pairs.
09:42:51 <donri> timthelion: mapWithKeys?
09:42:56 <nexx> shachaf except you put them there :)
09:43:02 <donri> mapWithKey, rather
09:43:57 <MostAwesomeDude> timthelion: So you want something of signature (k -> v -> (k', v')) -> Map k v -> Map k' v'
09:44:17 <timthelion> donri: that's nice, but I'm looking for mapWithKeyToList :: (k->a->b) -> Map k a -> [b]
09:45:14 <timthelion> perhaps I'll just map over assocs
09:45:14 <donri> timthelion: elems . mapWithKey
09:45:20 <shachaf> timthelion: You can always map over M.toList
09:45:31 <timthelion> shachaf: that's what I'll do
09:46:11 <timthelion> what's the difference between toList and assocs?
09:46:40 <shachaf> None in the implementation.
09:46:55 <shachaf> assocs is guaranteed to be sorted, it looks like?
09:46:56 <timthelion> :D
09:47:18 <donri> assocs = toList = toAscList /= toDescList
09:48:39 <shachaf> donri: In implementation, sure.
09:53:05 <donri> daniel_-: yea that looks like it should work? maybe talk to bos or the #snapframework guys who use configurator a lot
09:56:16 <timthelion> Why does cabal require -XDoAndIfThenElse when ghc doesn't?  Should this be reported as a bug?
09:56:44 <donri> timthelion: do you have default-language:Haskell2010 perhaps?
09:57:06 <Yiq> mbbx6spp / cabal-heroku-buildpack --any limitations to this comapred to using python for example?
09:57:23 <Cale> That was the worst change in H2010 imo
09:57:32 <timthelion> donri: I don't have any such line, no
09:57:52 <donri> timthelion: what do you mean require btw
09:57:54 <timthelion> Cale: How did it change? Did they start requiring it?
09:57:55 <Cale> PLEASE HALP ME TO INDENT BADLY
09:58:00 <Egbert9e9> What does "<<loop>>" mean?
09:58:07 <Cale> Haskell Committee: okay .___.
09:58:13 <timthelion> donri: it errors out when I don't have it.
09:58:25 <timthelion> Cale: I don't understand
09:58:26 <Cale> Egbert9e9: It means that your program would have gone into an infinite loop, but that loop was detected.
09:58:28 <donri> timthelion: what errors out?
09:58:41 <tromp_> like m@main=m
09:58:49 <Egbert9e9> oh wow. I wonder where
09:59:00 <donri> oh i see. maybe ghc defaults to Haskell2010 now?
09:59:00 <timthelion> donri: cabal install
09:59:22 <timthelion> donri: yes, it does.
09:59:45 <Cale> timthelion: That extension lets you align the 'then' and 'else' with the 'if' inside of a do-block, mainly because beginners write code like this:
09:59:49 <clsmith> can an infinite loop be safely treated as _|_ and skipped? like, is that legal in haskell's semantics and things?
09:59:52 <Cale> do if foo then
09:59:57 <Cale>        bar
10:00:00 <ParahSailin> :t (_|_)
10:00:01 <lambdabot> parse error on input `|'
10:00:04 <Cale>    else
10:00:08 <Cale>        quux
10:00:16 <Cale> and then wonder why it doesn't work
10:00:37 <timthelion> Cale: I normally do that.  I don't see why not.
10:00:44 <Cale> do if foo
10:00:48 <Cale>        then bar
10:00:51 <Cale>        else quux
10:01:05 <timthelion> Cale: I don't like to have too much indentation :P
10:01:07 <danil> clsmith: infinite loops are bottoms, and hence skippable only when not forced
10:01:08 <Cale> line up the 'then' and 'else', indent them more than the 'if'
10:01:12 <donri> timthelion: anyway i think cabal is being conservative for back-compat and lets you set it with default-language:Haskell2010 instead
10:01:29 <clsmith> danil: what do you mean by 'forced'?
10:02:07 <Cale> timthelion: Well, you can still use less indentation there
10:02:34 <Cale> timthelion: how many spaces exactly is irrelevant, as long as 'then' and 'else' are lined up and start in a deeper column than 'if'
10:02:55 <donri> then and else have to be aligned?
10:03:00 <Egbert9e9> I could swear this function is finite
10:03:01 <Cale> This isn't a hard rule of the Haskell syntax, but I'd consider it a reasonable style guideline.
10:03:47 <Cale> Egbert9e9: You only get <<loop>> if the value of some variable is demanded during the computation of that same variable.
10:04:00 <clsmith> oh, that 'black hole' thing?
10:04:04 <Cale> yes
10:04:36 <Veinor> as in 'x = x'
10:04:59 <Cale> yeah or something like  let x = x + 1 in f x
10:05:03 <donri> (but not in ghci)
10:05:18 <Cale> Yeah, the threaded runtime generally doesn't have a good time catching them
10:05:26 <Egbert9e9> can it also pin point the location?
10:05:31 <timthelion> Cale: Honestly, I'd use if' if it was in prelude and didn't look ugly
10:05:44 <Cale> If you compile with -prof -auto-all, and run the program with +RTS -xc
10:05:54 <Egbert9e9> ah, thanks
10:05:54 <Cale> you might get some more information about where the problem occurred
10:06:04 <Cale> otherwise, paste your code on hpaste and I'll have a quick look
10:06:39 <Cale> timthelion: if you were using if' it would become even more important to indent the arguments properly because then there's even less visual indication of what's going on
10:06:40 <donri> isn't that -fprof-auto
10:06:53 <Cale> donri: what's -fprof-auto? Is that new?
10:06:56 <timthelion> dmwit: shachaf So what do you think? https://github.com/timthelion/threadmanager/blob/master/src/Control/Concurrent/ThreadManager.hs#L72
10:07:00 <donri> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-compiler-options.html
10:07:21 <timthelion> Cale: I know it would become even more important, but it would require less memorization of syntax :D
10:07:22 <Cale> oh, maybe it got changed, weird
10:07:47 <Cale> well, I like the new flag name better, I guessd
10:07:48 <Egbert9e9> Cale: this code is horrible
10:07:49 <Cale> -d
10:07:58 <Cale> Egbert9e9: that's okay :)
10:08:13 <Cale> Egbert9e9: as long as it's not several hundred lines :)
10:08:16 <donri> "-fprof-auto was known as -auto-all prior to GHC 7.4.1."
10:08:25 <Cale> donri: aha
10:08:41 <Egbert9e9> ... ... 200 loc
10:08:49 <Cale> yeah, that'll be okay
10:08:52 <Cale> I'll look through it :)
10:09:08 <JoeyA> Has anyone made an alternative to "cabal init" ?  I usually have to change a lot after I run it.
10:09:25 <hpaste> Egbert9e9 pasted “game of strife” at http://hpaste.org/73284
10:09:37 <donri> JoeyA: i use expanding snippets in vim instead, https://github.com/dag/vim2hs
10:11:07 <Cale> let wdata = seq wdata $ trace (show il ++ " " ++ show cl) $ DM.insert il cl wdata -- looks suspicious
10:11:09 <Egbert9e9> oh, poop. forgot the other one
10:12:27 <Egbert9e9> OH
10:12:34 <Cale> Egbert9e9: also, even though it's not actually what you have here, you should be aware that  x `seq` x  is the same thing as x
10:12:58 <JoeyA> My changes are usually: 1) Loosen the package requirements (e.g. base == 4.5.*)  2) Compile with -Wall -fwarn-tabs  3) Fix the indentation (4 spaces), and remove whitespace after commented-out description 4) Type in copyright  5) Add extra-source-files as needed  6) Add github links (homepage, bug-reports, and source-repository).
10:13:08 <Cale> Egbert9e9: because if something causes (x `seq` x) to be evaluated, then it would also have caused x to be evaluated.
10:13:21 <JoeyA> cabal now, by default, uses == for every package.  Ugh.
10:14:45 <donri> does -Wall not include -fwarn-tabs?
10:14:59 <JoeyA> I don't think so.
10:15:20 <Cale> I think tabs should just be made a lexical error
10:16:14 <donri> JoeyA: anyway my vim snippets use the shiftwidth, set -Wall and includes a snippet for setting github (guessing username and repo, but i could probably improve it to set homepage and issues too)
10:16:16 <scshunt> you know what I've concluded?
10:16:26 <scshunt> the #1 reason above all else for pure functions
10:16:27 <scshunt> is testing
10:16:54 <Cale> scshunt: well, correctness in general
10:17:15 <JoeyA> Another good reason: pure functions don't have to worry about asynchronous exceptions.
10:17:22 <Cale> scshunt: reasoning about what code does benefits just as much, but testing is easier to explain to people :)
10:18:06 <JoeyA> If they do, then it's a bug in the RTS.
10:19:26 <Cale> If the number 1 reason is testing and being able to understand the behaviour of code in isolation, then the number 2 reason is probably all the benefits to concurrency and parallelism
10:19:44 <Cale> (and async exceptions being part of that :)
10:20:35 * timthelion would really like to see more packages written with good support for optional arguments
10:20:39 <asid> If I type the first two lines of http://hackage.haskell.org/packages/archive/sqlite-simple/0.1.0.0/doc/html/Database-SQLite-Simple.html the database creation works fine. But I don't want to insert any values, I just want to create the database. But when I only type the first line in the shell, nothing happens..
10:21:50 <Cale> Is anyone else having trouble connecting to hackage?
10:21:58 <Cale> (That link is slow, maybe dead for me)
10:22:00 <joshc> asid: did you properly terminate the query string?
10:22:04 <timthelion> For example, it would be nice if I could run something like http://hackage.haskell.org/packages/archive/her-lexer/0.0/doc/html/Language-Haskell-Her-HaLay.html with my own list of symbols, or my own list of keywords, without having to edit the source of the package
10:22:30 <timthelion> Cale: nope
10:23:05 <danil> timthelion: sounds like a job for ML modules
10:23:19 <Cale> I have 100% packet loss to hackage.haskell.org, and mtr seems to indicate that it happens closer to hackage's side of things.
10:23:22 <asid> joshc: oh, uups.. thanks.
10:23:47 <Cale> presently hackage.haskell.org resolves to 69.30.63.204 for me
10:24:00 <timthelion> danil: as in the language ML?
10:24:10 * hackagebot uu-parsinglib 2.7.3.4 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators. (DoaitseSwierstra)
10:24:39 <Cale> timthelion: yeah, well, not ML itself, I think(?), but SML and OCaml at least
10:24:40 <aristid> Cale: 66.193.37.204 is the correct IP i think. unless there is more than one IP.
10:24:47 <aristid> hackage works here.
10:25:10 <timthelion> Cale: PING hackage.haskell.org (66.193.37.204) 56(84) bytes of data.
10:25:32 <aristid> Cale: maybe you need to flush out your DNS cache
10:25:52 <shapr> Cale: Yah, you have the pre-weekend change-over DNS address
10:25:55 <timthelion> Strangely, hackage does not respond to ping, despite the fact that I can access the page
10:25:58 <timthelion> --- hackage.haskell.org ping statistics ---
10:25:58 <timthelion> 65 packets transmitted, 0 received, 100% packet loss, time 64008ms
10:26:01 <shapr> Cale: Try using 8.8.8.8 or 8.8.4.4 for your dns server
10:26:05 <Cale> I hate DNS caches
10:26:16 <shapr> Yah, they need generational GC :-)
10:26:28 <nand`> timthelion: it's not uncommon for servers to block pings these days
10:26:28 <Cale> ah, I'm using 18.18.18.18
10:26:29 <nand`> for some reason
10:26:38 <nand`> eg. ping amazon.com
10:26:39 <shapr> Cale: What the heck is that?
10:26:44 * nand` is using 127.0.0.1
10:26:53 <Egbert9e9> wooo! working
10:26:54 <shapr> Cale: 8.8.8.8 and 8.8.4.4 are google's free public access DNS servers.
10:27:22 <Cale> lol, what the heck
10:27:26 <nand`> note that you're essentially broadcasting every single domain you visit and when to google
10:27:32 <timthelion> nand`: Well a lot of services block ping by default to block service sniffers and other bad people.  So if no one reconfigured the service to allow pings then....
10:27:36 <shachaf> timthelion: How does that not suffer from the same race condition?
10:27:54 <shachaf> Wait, there have been lots of lines since you said that.
10:27:57 <shapr> Cale: That appears to be some address inside MIT, where'd you get that?
10:28:10 <Cale> If I look in my router config, I have 8.8.8.8 and 8.8.4.4 as my first and second dns server, but on the page which tells me how things are configured, the 8.8.8.8 it replaced by 18.18.18.18 which is also a DNS server I have used before
10:28:14 <Egbert9e9> hmm.. how do I get rid of all these trace calls, now?
10:28:21 <danil> timthelion: yeah.  Something like a functor that builds a lexer, parametrized over the token definitions.  It's similar to just passing around a big record of parameters, but when the language makes it easy people are much more likely to actually abstract that way.
10:28:33 <Cale> shapr: It's a DNS server at MIT which has a convenient IP
10:28:40 <shapr> huh, ok
10:28:43 <timthelion> shachaf: it doesn't suffer from the same race, because if all threads are finished by the time it runs, it doesn't restart, otherwise it starts waiting again, untill it is run at a time when all threads really are finished.
10:28:55 <hpaste> mbuf pasted “How to use the returned username in a function?” at http://hpaste.org/73285
10:29:00 <shachaf> Cale: Ah, I didn't know about 18.18.18.18.
10:29:07 <shachaf> Cale: 4.2.2.2 is another convenient one.
10:29:27 <timthelion> danil: interesting.
10:29:29 <nand`> I think I will use 18.18.18.18 when I need a DNS server for whatever reason and don't have the motivation to set one up locally
10:29:34 <nand`> shachaf: what's 4.2.2.2?
10:29:43 <shachaf> An IP address.
10:29:59 <Cale> oh, that one's run by Level 3 Communications apparently
10:30:07 <Cale> I wonder if I trust them more than Google.
10:30:14 <timthelion> shachaf: so do you see how that is no longer a race condition?
10:30:27 <nand`> 2.2.2.4.in-addr.arpa. 86400 IN PTR b.resolvers.Level3.net.
10:30:34 <scshunt> Cale: Sure. But testing is the most obvious aspect of correctness
10:30:46 <timthelion> shachaf: it's a bit like STM's orElse I guess.
10:30:49 <shachaf> timthelion: Oh, you have some more logic later.
10:31:03 <shachaf> I don't know.
10:31:23 <shachaf> I don't care much either, really. :-) You'll run into other trouble with this absraction, I think.
10:31:26 <ocharles> can anyone with http-conduit installed please try 'simpleHttp "https://mtgox.com"' in ghci? it freezes for me
10:31:33 <Cale> lol:
10:31:34 <Cale> cale@ender:~$ host hackage.haskell.org
10:31:34 <Cale> hackage.haskell.org has address 66.193.37.204
10:31:34 <Cale> cale@ender:~$ ping hackage.haskell.org
10:31:34 <Cale> PING hackage.haskell.org (69.30.63.204) 56(84) bytes of data.
10:31:38 <timthelion> shachaf: I'm sure it's not :) and no, I won't run into trouble :D
10:31:57 <timthelion> shachaf: I just don't understand why you guys are so bone set against it.
10:32:01 <Cale> DNS caches mang, how do they work?
10:32:12 <aristid> Cale: try getent hosts hackage.haskell.org
10:32:13 <shapr> Nobody knows.
10:32:20 <shachaf> Cale: ipconfig /flushdns, man!
10:32:25 <nand`> does ‘host’ respect /etc/hosts ?
10:32:26 <aristid> Cale: host resolves things differently than the rest of the system
10:32:36 * shachaf actually has no idea how the DNS cache works or who stores it or how to flush it.
10:32:38 <nand`> (just curious, unrelated to Cale's problem)
10:33:03 <nand`> I checked, apparently it does not
10:33:07 <aristid> shachaf: modern linux desktop DNS setups are way too contrived :/
10:33:14 <nand`> Cale: just a thought, check /etc/hosts then?
10:33:29 <Cale> ah, you're right
10:33:45 <Cale> I still have entries in there from last time the DNS changed
10:33:47 <mbuf> got it, user <- get_username
10:33:48 <Cale> lol
10:33:49 <aristid> lol
10:33:52 <nand`> Cale: :)
10:34:46 <nand`> aristid: wait till you have bind9 running locally
10:34:51 <nand`> then it starts getting contrived
10:35:38 <aristid> nand`: LALALA I CAN'T HEAR YOU
10:35:48 <nand`> (I actually do this, so I can use OpenNIC's nameservers for all of their TLDs, but the usual root nameservers for the rest of the internet. It's fairly contrived)
10:37:42 <aristid> nand`: on the upside, you can flush your cache anytime you want
10:37:55 <nand`> you're right; I can. I forgot about that
10:38:05 <aristid> nand`: say, do the root servers have rate limits?
10:38:05 <nand`> I should have done that instead of /etc/hosts to fix haddock
10:38:10 <aristid> oO
10:38:10 <nand`> no idea
10:38:15 <nand`> aristid: but I don't think they recurse
10:38:24 <nand`> so you can't use them as general purpose NSs
10:38:51 <aristid> nand`: changing the /etc/hosts either proves your forgetfulness, or the contrivedness of BIND9 :)
10:39:16 <aristid> nand`: yeah but you have your own BIND9 to do the recursing
10:40:49 <JoeyA> When you say f 0 = ...; f 1 = ...; f 2 = ...; f 3 = ...; f 100 = ...; f _ = Nothing (where the number is of type CInt), does the compiler optimize this into a jump?
10:41:06 <JoeyA> That is, a jump table or lookup table.
10:41:18 <JoeyA> Or if I have 30 error codes, will it do up to 30 comparisons?
10:41:31 <shachaf> Try it out!
10:41:42 <roconnor> JoeyA: I guess one way to find out would be to look at the assembly
10:41:50 <roconnor> dons appears to do this frequently
10:41:58 <roconnor> maybe his blog will have tips
10:42:14 <nand`> aristid: it's the former :) and yeah, I recurse locally
10:43:05 <nand`> JoeyA: GHC uses jump tables after a certain amount of conditions iirc
10:43:14 <nand`> I forgot what the number was
10:43:41 <aristid> nand`: you should build an easy-to-use DNS server in haskell.
10:44:20 <nand`> I should :)
10:47:41 <nand`> JoeyA: https://github.com/ghc/ghc/blob/master/compiler/codeGen/CgUtils.hs#L568
10:48:16 <Egbert9e9> I am trying to do two things: 1. Fix this non-tail recursive function into tail recursive. 2. Find a successful implementation of the "curse" and "recursion" pun.
10:48:18 <JoeyA> Thanks
10:48:39 <shachaf> Egbert9e9: Why do you want to do 1?
10:48:52 <Philippa_> Egbert9e9: name fix "recurse"...
10:49:54 <Egbert9e9> shachaf: because it is stack overflowing
10:50:17 <shachaf> Egbert9e9: Haskell code doesn't work the way you might think.
10:50:42 <shachaf> Sometimes you can get rid of stack overflows by making it *not* tail recursive. :-)
10:51:02 <Egbert9e9> with that last message I am utterly confused
10:51:04 <shachaf> JoeyA: Looks like with 33 Ints, 0-32, it'll do n comparisons.
10:51:09 <shachaf> Egbert9e9: For example,
10:51:11 <shachaf> @src map
10:51:11 <lambdabot> map _ []     = []
10:51:12 <lambdabot> map f (x:xs) = f x : map f xs
10:51:21 * Egbert9e9 squints
10:51:25 <shachaf> That's not tail-recursive.
10:51:38 <shachaf> Anyway what's your actual code? Is it small enough to @paste easily?
10:52:13 <Egbert9e9> http://hpaste.org/73284
10:52:28 <Egbert9e9> shachaf: it's the commented partDiffuse
10:52:33 <nand`> Egbert9e9: tail recursive functions generally build up huge thunks in their arguments (unless they're also strict); whereas a lazy producer (that is not tail recursive) like map will only recurse as far as needed
10:52:43 <shachaf> Egbert9e9: You should take all the comments from hlint on that page, while you're at it. :-)
10:52:52 <Egbert9e9> oh.
10:53:04 <JoeyA> shachaf: Actually, it looks like it's using a binary decision tree.
10:53:15 <JoeyA> So it should involve O(log n) comparisons.
10:53:20 <shachaf> JoeyA: Not in the code my thing compiled into...
10:53:35 <JoeyA> What optimization did you use?
10:53:40 <shachaf> Egbert9e9: That code is... Oddly structured.
10:53:40 <shachaf> -O2
10:53:42 <JoeyA> (I'm using -O1)
10:53:58 <Egbert9e9> shachaf: it is horrible, I know.
10:54:35 <Egbert9e9> not cool enough to unhorriblize it yet
10:55:15 <merijn> It is never to early to unhorriblise code!
10:55:43 <danil> eww, hlint likes qualified infix names?
10:56:58 <donri> it's not in the scope of hlint to suggest otherwise
10:58:05 <danil> I mean, it suggests "a `DM.union` b" over "DM.union a b"
10:58:16 <hpaste> “Joey Adams” pasted “Does GHC optimize a large number of Int cases?” at http://hpaste.org/73287
10:58:39 <donri> danil: looks fine to me
11:00:06 <JoeyA> This looks like a binary search to me: http://hpaste.org/73287#line844
11:01:51 <danil> donri: I guess I'm not that much against it, I'm just surprised hlint has an opinion on the matter
11:03:06 <shachaf> JoeyA: Hmm, yes.
11:05:20 <k0ral> hello
11:05:50 <k0ral> GHC complains about the following: I have f :: (MonadX m, MonadY m) => m ()
11:06:05 <shachaf> GHC's generated native code has all sorts of things that look redundant. :-(
11:06:05 <k0ral> inside f, I perform a newIORef (return ())
11:06:28 <k0ral> I want this return to be interpreted as the one of m
11:06:28 <shachaf> I guess that's part of the point of going through LLVM.
11:06:41 <k0ral> but it seems GHC assumes it is another monad m'
11:07:22 <Egbert9e9> How would you apply the same a -> IO a function n times, each time using the previous application's result?
11:07:46 <k0ral> the error message is: Couldn't match type `m3' with `m5' because type variable `m5' would escape its scope This (rigid, skolem) type variable is bound by a type expected by the context: (MonadX m, MonadY m) => ...
11:08:18 <shachaf> Egbert9e9: foldr (>=>) return (replicate n f)?
11:08:20 <k0ral> I really can't see any workaround for this issue, would anyone be so kind as to give me some hint please ?
11:09:09 <Egbert9e9> shachaf: let me meditate on that for a minute
11:09:52 <shachaf> @ty (>=>)
11:09:53 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
11:11:31 <Egbert9e9> oh wow. you fold using that tunnelling operation
11:11:47 <Egbert9e9> over the list of functions
11:12:58 <merijn> And another mind is blown :p
11:13:24 <DT``> :t foldr (>=>)
11:13:26 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m c) -> [a -> m a] -> a -> m c
11:13:30 <merijn> That seems something for Control.Monad.Loops, btw
11:13:51 <DT``> ... oh.
11:13:55 <DT``> that's neat.
11:14:00 <nand`> which would be more efficient, foldr or foldl for (>=>) ?
11:14:33 <nand`> or would it not matter
11:14:37 <nand`> (or depend on the monad)
11:15:15 <startling> can you define a monad instance with (>=>)?
11:15:16 <danil> k0ral: can you paste it?
11:15:28 <shachaf> startling: You can get (>>=) from (>=>)
11:15:33 <shachaf> Exercise left for the reader.
11:15:43 <startling> shachaf, yeah, I know. how about return?
11:15:55 <k0ral> danil: pretty big, I will try to simplify before
11:16:59 <shachaf> startling: I don't think so. Try it out!
11:17:20 <Egbert9e9> shachaf: what is the weirdest thing about the code?
11:17:33 <Egbert9e9> if there's one thing I should fix
11:17:37 <Egbert9e9> what would that be
11:17:47 <shachaf> Not sure. I haven't slept in quite a number of hours.
11:18:37 <Egbert9e9> do you often do that? it can chip away your sanity if often
11:18:56 <shachaf> I have no sanity left.
11:19:04 <shachaf> Didn't you notice back then?
11:19:18 <Egbert9e9> Arkham's sanitarium for you, then
11:24:12 * hackagebot basic-prelude 0.2.0.0 - An enhanced core prelude; a common foundation for alternate preludes. (DanBurton)
11:28:54 <k0ral> here it is: https://gist.github.com/3372412
11:31:07 <shachaf> k0ral: What?
11:31:24 <shachaf> I'm not sure what you're trying to do but it seems very likely that "A" isn't the way to do it.
11:33:54 <danil> k0ral: IORefs can't contain polymorphic things (or rather, newIORef can't return a polymorphic thing), but the A constructor requires a polymorphic argument.
11:34:59 <danil> (shachaf is right that A looks like a very questionable type)
11:36:12 <k0ral> danil: apart from the IORef thing, why would A be questionable ?
11:36:36 <k0ral> I want to live in a monad that can read an environment and fail
11:36:58 <k0ral> isn't that the right way to do it ?
11:37:09 <k0ral> shachaf: ^
11:38:59 <geekosaur> that is not the right way to do it
11:39:24 <geekosaur> the error message told you what that you did *is* for:  it "hides" types so they can't escape
11:39:59 <k0ral> the error message is quite cryptic to me
11:40:19 <k0ral> especially the (rigid,skolem) thing
11:40:31 <k0ral> what does escape mean in this context ?
11:41:28 <Eduard_Munteanu> k0ral: that a variable which isn't quantified in the outer scope can't occur in that scope?
11:41:32 <danil> it means the thing that needs to get universally quantified over in order for A's argument to be polymorphic enough also appears outside of A's argument
11:41:37 <Eduard_Munteanu> :t runST
11:41:39 <lambdabot> forall a. (forall s. ST s a) -> a
11:41:59 <Eduard_Munteanu> You can't have 's' occur in the result type there.
11:42:07 <geekosaur> you used a type that's hidden inside another type (that is, A does not name m so m is only available inside of it).  "escaper" means you tried to extrat "m" from an "A"
11:43:36 <Eduard_Munteanu> :t runST (newSTRef 1)
11:43:38 <lambdabot>     Inferred type is less polymorphic than expected
11:43:38 <lambdabot>       Quantified type variable `s' escapes
11:43:38 <lambdabot>     In the first argument of `runST', namely `(newSTRef 1)'
11:44:07 <k0ral> alright, I kinda get it, but then what's the right way to do it ? Should I give specific MonadError and MonadReader only for the IORef ?
11:44:40 <MostAwesomeDude> k0ral: IORef needs a concrete monomorphic type. What's the bigger picture?
11:45:02 <zzing> If I wanted to make a command line utility that had parameters centred around verbs with specific parameters instead of normal dashed options, is there a good parsing library that would be appropriate for this usage and provide some help?
11:45:40 <danil> k0ral: you should probably parametrize A over m rather than quantifying, but it depends on what you want to do with A's.
11:46:42 <k0ral> (MonadX m, MonadY m) => A m { mRef :: IORef (m ()) }
11:46:52 <k0ral> is that what you mean ?
11:47:00 <Eduard_Munteanu> k0ral: um, MaybeT + Reader?
11:47:18 <k0ral> Eduard_Munteanu: I'd rather EitherT (ErrorT actually)
11:47:27 <Eduard_Munteanu> Ok.
11:47:59 <Eduard_Munteanu> What's the IORef about though?
11:48:01 <drunK> k0ral: you probably want something like that: http://codepad.org/RdyvNzTT (I removed other constraints for clarity's sake)
11:49:10 <ocharles> zzing: maybe see what hledger is using?
11:49:18 <k0ral> Eduard_Munteanu: it's about storing a callback to trigger when a further event occur
11:49:39 <atriq> runIO :: IO a -> a; runIO = error "This probably isn't what you want."
11:49:48 <jfischoff> Is there a repa traverse takes in a Array F and returns an Array F? I'm trying to get the luminosity example from here working http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial#Example:_parallel_image_desaturation
11:50:57 <zzing> ocharles: , thank you for the tip
11:50:59 <covi> I want to write a simple script that just copies some files to some dir. I want to have a recursiveExpand function that receives a FilePath as input, and outputs all files in it or its subdirs. I'm using the doesFileExist and doesDirectoryExist functions in System.Directory. However, they return IO Bool instead of Bool (which can be used in a guard). I really don't know how to somehow circumvent this problem and write the function I want. Any help? http://h
11:51:19 <mauke> covi: no
11:51:20 <zzing> cmdargs
11:51:35 <covi> mauke: ?
11:52:05 <mauke> covi: you won't get any help for truncated urls
11:52:50 <covi> mauke: truncated url? It's a hpaste url.
11:52:56 <mauke> no, it's not
11:53:13 <k0ral> drunK: not sure I understand how to mimic your code in my case
11:53:43 <k0ral> you don't parametrize F, it's what I'm doing too and it doesn't work
11:54:12 <covi> mauke: ???
11:54:13 <zzing> If I have a data entry that just has plain constructors deriving Read andShow, will the read be able to take something like 'listusers' and return the type ListUsers?
11:54:17 <jfischoff> i guess I need to "undelay" a repa array, any ideas?
11:54:37 <mauke> covi: yes/no/maybe
11:54:50 <tdammers> this is probably stupid, but I can't figure it out:
11:54:56 <tdammers> how can I get rid of x in
11:55:07 <tdammers> x <- f >>= return (g x)
11:55:18 <mauke> which x?
11:55:22 <kosmikus> jfischoff: computeS, computeP
11:55:38 <Guest60587> tdammers: i was trying the same thing last night
11:55:53 <tdammers> I'd like to write that line without introducing the extra variable
11:55:55 * jfischoff is looking at the doc for computeS
11:55:56 <Guest60587> actually i wasnt
11:55:59 <Guest60587> tdammers: but here
11:56:03 <mauke> tdammers: which extra variable? there are two x's there
11:56:04 <Guest60587> tdammers: x <- fmap g f
11:56:07 <danil> k0ral: you only need the forall inside the constructor if you want to unwrap callbacks and then run the action in multiple concrete monads.  Otherwise there's no need to hide m, and you can use a type "A m" and have functions like "(SomeContext m) => A m -> ..."
11:56:15 <tdammers> hmm hold on
11:56:17 <zzing> Why does ghci say "Could not find module `Clckwrks.ProfileData.Types'"  but cabal works just fine?
11:56:21 <mauke> tdammers: and why are you >>=ing into return?
11:56:25 <Guest60587> oh now im confused
11:56:31 <k0ral> Eduard_Munteanu, MostAwesomeDude, danil, geekosaur: you're asking me to parametrize A, but that would mean cascading the parameter just about everywhere in my code, this is really annoying, isn't there any other solution ?
11:56:33 <mauke> that's just f >> g x
11:56:51 <tdammers> sorry
11:56:54 <drunK> k0ral: I just replaced A with F, but you can as well have data A = A { mRef :: IORef F } and it looks almost the same. it also compiles in case you didn't check
11:56:58 <tdammers> I meant
11:57:03 <jfischoff> kosmikus: thanks!
11:57:07 <tdammers> f >>= \x -> return (g x)
11:57:13 <Guest60587> fmap
11:57:20 <mauke> @pl f >>= \x -> return (g x)
11:57:20 <lambdabot> g `fmap` f
11:57:24 <tdammers> heh, yeah
11:57:35 <tdammers> no wonder I couldn't tickle it out of lambdabot earlier
11:57:55 <mauke> @pl f >>= return (g x)
11:57:56 <lambdabot> return (g x) =<< f
11:58:07 <Guest60587> \o/
11:58:08 <mauke> :t ?f >>= return (?g ?x)
11:58:09 <tdammers> exactly.
11:58:10 <lambdabot> forall (m :: * -> *) a t b. (?f::m a, ?g::t -> m b, ?x::t, Monad m) => m b
11:58:26 <ParahSailin> @src liftM
11:58:27 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
12:00:18 <tdammers> wait a minute
12:00:34 <tdammers> I was using liftM the whole time
12:00:39 <tdammers> only wrong, apparently
12:00:51 <mauke> :t [fmap, liftM, liftA]
12:00:53 <lambdabot> forall a b (f :: * -> *). (Applicative f, Monad f) => [(a -> b) -> f a -> f b]
12:01:35 <Guest60587> o_O
12:01:59 <tdammers> \o/ compiles, passes tests, all is good
12:02:15 <k0ral> drunK: it asks for ConstraintKinds, don't know how unpure it is
12:02:33 <tdammers> awesome, thanks.
12:03:10 <drunK> k0ral: it works here with Rank2Types alone (ghc 7.4.2)
12:03:12 <MostAwesomeDude> k0ral: Well, TBH my solution would involve not using IORefs. I *still* don't know what you're doing.
12:03:51 <k0ral> MostAwesomeDude: sorry I forgot to answer
12:04:07 <k0ral> MostAwesomeDude: those IORefs are callbacks I need to register for further triggering
12:04:38 <k0ral> MostAwesomeDude: if you know of a way to do it without IORef, I'm listening :)
12:04:54 <zzing> When I try to do export GHC_PACKAGE_PATH=/usr/local/lib/ghc-7.4.1/package.conf.d/package.cache  ghci says read: no parse  and have a panic, is this normal or is there a path I am missing?
12:04:57 <MostAwesomeDude> k0ral: Well, I can think of a couple ways, sure.
12:05:09 <MostAwesomeDude> I mean, for starters, StateT is your friend.
12:05:34 <Guest60587> ReaderT _ IO
12:06:57 <k0ral> MostAwesomeDude: you're right, that would be cleaner
12:07:34 <k0ral> MostAwesomeDude: that makes 1, still waiting for the couple others :P
12:08:23 <k0ral> drunK: it works fine using your solution; I will try to use StateT instead though, if I can
12:08:33 <danil> MostAwesomeDude: there are certain issues with having the type of your monad transformer stack occur in the state type
12:09:11 <danil> (though drunK's wrapper works just as well in that case as with IORefs)
12:09:13 * hackagebot oberon0 0.0.1 - Oberon0 Compiler (MarcosViera)
12:09:45 <MostAwesomeDude> k0ral: Continuation passing is a time-honored tradition. :3
12:09:56 <MostAwesomeDude> danil: Really? What's the problem?
12:10:41 <k0ral> danil: name the problems before I start rewriting my whole code using StateT instead of IORef :)
12:13:40 <keki> any die suggestions for haskell? possibly support clicking through to source
12:13:50 <keki> ide!
12:14:13 * hackagebot hissmetrics 0.4 - Unofficial API bindings to KISSmetrics. (FelipeLessa)
12:15:00 <zzing> If a haskell module is dynamically linked, will ldd show it?
12:15:13 <danil> k0ral: well, you can write a constraint like "MonadState [m ()] m" just fine, but when you actually go to make a concrete instance you'll have an infinite type
12:16:05 <danil> type M = StateT [M ()] (...)
12:16:46 <danil> I guess if you write your own instance or use a newtype (and derive a bunch of classes) instead of using StateT it works fine
12:24:13 * hackagebot fb 0.11 - Bindings to Facebook's API. (FelipeLessa)
12:24:15 * hackagebot yesod-recaptcha 1.1 - Dead simple support for reCAPTCHA on Yesod applications. (FelipeLessa)
12:26:38 <adis> can you someone me to defined a function of type [(a,b,c)] -> [(a,[(b,c)])] which behaves like this:  [("a",1,11),("a",2,22)] to [("a",[(1,11),(2,22)])]?
12:26:38 <adis> help me*
12:26:49 <keki> creating 1st web-app in haskell….snap or yesod?
12:26:56 <scshunt> adis: is this a homework question?
12:27:23 <adis> scshunt: no, I need it for my private purpose
12:27:54 <scshunt> :t groupBy (`on` \(a,b,c) -> c)
12:27:56 <lambdabot>     Couldn't match expected type `b -> b -> c'
12:27:56 <lambdabot>            against inferred type `(a, b1, c1)'
12:27:56 <lambdabot>     In the pattern: (a, b, c)
12:28:07 <scshunt> :t groupBy (== `on` \(a,b,c) -> c)
12:28:09 <lambdabot> parse error on input ``'
12:28:13 <sm> keki: I say scotty
12:28:16 <scshunt> :t groupBy ((==) `on` \(a,b,c) -> c)
12:28:18 <lambdabot> forall b t t1. (Eq b) => [(t, t1, b)] -> [[(t, t1, b)]]
12:28:28 <scshunt> :t groupBy ((==) `on` \(a,b,c) -> a)
12:28:30 <lambdabot> forall b t t1. (Eq b) => [(b, t, t1)] -> [[(b, t, t1)]]
12:28:30 <scshunt> start with that
12:29:13 * hackagebot yesod-auth-fb 1.1 - Authentication backend for Yesod using Facebook. (FelipeLessa)
12:30:18 <adis> scshunt: ok thanks, I play with these functions around and try it
12:30:35 <Soultaker> I'd probably write an ad-hoc function to do it.
12:30:44 <keki> sm: cheers, will take a look
12:30:50 <Soultaker> seems like these built-in functions aren't too well-suited to the task
12:30:59 <scshunt> Soultaker: groupBy seems like a good start
12:31:16 <Soultaker> you could look at the groupBy source code to get an idea of the approach to take I suppose
12:31:43 <shapr> johnw: Howdy! Did you get lambdabot building?
12:32:00 <Soultaker> (group/groupBy doesn't sort, right?)
12:32:43 <johnw> shapr: I did, but it doesn't work
12:32:50 <johnw> it never gives me a prompt
12:33:15 <shapr> :-(
12:33:57 <adis> I am having problems to load Data.List and Data.Function to ghci ... ":module +Data.Function +Data.List"?
12:34:13 * hackagebot yesod-auth-zendesk 1.1 - Zendesk remote authentication support for Yesod apps. (FelipeLessa)
12:34:15 * hackagebot fb-persistent 0.1.4 - Provides Persistent instances to Facebook types. (FelipeLessa)
12:40:03 <JoeyA> Does Haddock support bold text in documentation?
12:41:23 <shapr> adis: :m + Data.List
12:41:31 <shapr> adis: and then :m + Data.Function
12:41:40 <shapr> adis: Do you get an error?
12:41:52 <kanedank> I'm having a lot of trouble understanding the type of fmap...
12:41:55 <ocharles> JoeyA: I have a feeling it might only do italics
12:41:58 <shapr> :t fmap
12:41:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:42:14 <kanedank> specificall how f a -> f b can mean a single element a that f applies to or a list of a
12:42:30 <shapr> It only means a single element, right?
12:42:39 <kanedank> it can mean either
12:42:41 <zhulikas> it can as well mean a list, can't it?
12:42:50 <zhulikas> f a or [a] as [] is also f! :D
12:42:50 <kanedank> but I don't get how...
12:43:09 <zhulikas> list is a functor I mean
12:43:12 <kanedank> to me f a != f [a]
12:43:25 <zhulikas> Functor f
12:43:26 <geekosaur> kanedank, a is just a variable.  it cpuld be flled with Int, or [Int], or Maybe [Int], etc.
12:43:26 <zhulikas> and f a
12:43:33 <zhulikas> so list is a functor, therefore f a can be [a]
12:43:37 <Saizan> kanedank: f a != f [a] is correct
12:43:46 <geekosaur> or is that not the question... hm
12:43:49 <kanedank> but in type definitions I have seen [a]
12:43:56 <Saizan> kanedank: but f a can become [a] if you substitute [] for f
12:43:58 <zhulikas> @src fmap
12:43:59 <lambdabot> Source not found. stty: unknown mode: doofus
12:44:03 <zhulikas> oh
12:44:09 <shapr> @src Control.Monad.fmap
12:44:09 <lambdabot> Source not found. Do you think like you type?
12:44:15 * shapr throws rocks at lambdabot
12:44:16 <geekosaur> @src [] fmap
12:44:16 <Saizan> kanedank: this is because [] a = [a], as syntax sugar
12:44:17 <lambdabot> fmap = map
12:44:22 <zhulikas> :D
12:44:25 <geekosaur> @src Functor
12:44:26 <lambdabot> class  Functor f  where
12:44:26 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
12:44:31 <zhulikas> haha useless :D
12:44:43 <geekosaur> so fmap has an appropriate definition for each type that wishes to be a Functor
12:44:51 <geekosaur> @src (->) fmap
12:44:52 <lambdabot> fmap = (.)
12:45:00 <geekosaur> @src Maybe fmap
12:45:00 <lambdabot> fmap _ Nothing       = Nothing
12:45:01 <lambdabot> fmap f (Just a)      = Just (f a)
12:45:12 <zhulikas> that is a good example
12:45:27 <zhulikas> f is (a -> b) type of function
12:45:33 <zhulikas> Just a is f a
12:45:39 <zhulikas> Just (f a) is f b
12:45:41 <zhulikas> (by definition)
12:45:55 <zhulikas> so you get (a -> b) -> f a -> fb
12:46:51 <zhulikas> kanedank, fmap is a way to map a function over a value which is inside some functor
12:47:11 <nand`> FSVO ‘inside’
12:47:24 <zhulikas> hey! that's how I understand it :)
12:47:29 <shapr> kanedank: Clear as mud so far? :-)
12:47:31 <nand`> are values inside functions? :)
12:47:45 <zhulikas> no :|
12:47:55 <zhulikas> but is functor a function?
12:47:58 <nand`> fmap :: (a -> b) -> (r -> a) -> (r -> b)
12:48:02 <nand`> other way round
12:48:09 <nand`> ((->) r) is a functor
12:48:11 <merijn> zhulikas: There's a functor instance for functions, I believe
12:48:41 <nand`> (in fact, for this instance fmap = (.))
12:48:41 <shapr> I wonder if kanedank has fallen asleep or decided to go party in Davis Square.
12:49:00 <zhulikas> or his brains exploded
12:49:05 <shapr> kanedank: Artisan's Asylum has some good people.
12:50:03 <shapr> It might help if you ask kanedank (or other future questioners) what parts are understood, and then work from there :-)
12:50:15 <nand`> kanedank: reading up on what you were originally asking; I think there may be some confusion here between value-level functions and type-level ‘functions’
12:50:58 <zhulikas> it would be awesome to have history of questions with explanations somewhere online
12:51:09 <nand`> in the type sig of fmap :: (a -> b) -> f a -> f b it doesn't mean that ‘f’ is some function being applied to some ‘a’; it means that ‘f’ is a type constructor; or a polymorphic type accepting some parameter ‘a’
12:51:18 <zhulikas> so you could check every step of explanation if you understood it and check some of it if you did not to get support
12:52:08 <zhulikas> heh
12:52:18 <zhulikas> I guess my understanding of fmap is as good as kanedank's then
12:52:48 <nand`> eg. lists, which require an additional type parameter for the type of elements in the list. it's “list of Strings” or “list of Ints”; in Haskell [] String, [] Int; so when you're using the [] Functor instance ‘f’ itself is ’[]’; so the type is fmap :: (a -> b) -> [] a -> [] b; or fmap :: (a -> b) -> [a] -> [b] -- note that this has nothing to do with the ‘f’ often seen in the body:
12:52:50 <shapr> zhulikas: That would be awesome... #haskell mining.
12:52:51 <nand`> ‘fmap f = ...’
12:53:02 <zhulikas> shapr, idea for a next GSoC? :P
12:53:16 <zhulikas> I am thinking about web interface
12:53:23 <zhulikas> to read ti
12:53:30 <shapr> GSoC isn't for documentation-only projects, documentation was my first GSoC idea :-)
12:53:59 <zhulikas> although mining here is tricky as not all explanations are directed to people who ask questions (I mean nickname mentioning in messages)
12:54:20 <zhulikas> so you could only rely on time and relevance of messages
12:54:53 <zhulikas> although then you gather all relevant info and submit it to moderators for approvals who dismiss irrelevant messages and further commit the question/explanations to a database
12:54:54 <zhulikas> that could work
12:54:59 <adis> um, I don't see how groupBy can help me with my  [("a",1,11),("a",2,22)] to [("a",[(1,11),(2,22)])] problem
12:55:23 <shapr> adis: Did you get :m + Data.List to work?
12:55:29 <adis> shapr: yes
12:55:34 <shapr> adis: yay!
12:55:58 <adis> =)
12:56:45 <zhulikas> we can shoot higher and can make it to work with any IRC or other group chat protocol and any subject!
12:56:46 <luite> adis: groupBy can get you to [[("a",1,11),("a",2,22)],[("b",....]], which is a good first step
12:57:36 * nand` .oO ( Traversable might be useful in changing that to ("a",[(1,11),(2,22)]) )
12:57:45 <zhulikas> @hoogle groupBy
12:57:46 <lambdabot> Data.List groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
12:57:46 <lambdabot> Data.ByteString.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
12:57:46 <lambdabot> Data.ByteString.Lazy.Char8 groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
12:58:20 <nand`> so why do we have ‘comparing’ but not ‘equating’ ?
12:58:32 <luite> (==) `on`
12:58:43 <nand`> yeah, but ugly
12:58:45 <adis> but when I have "[("a",1,11),("a",2,22),("b",..,..),("a",..,..)]"?
12:58:46 <nand`> doesn't read as english
12:58:47 <kosmikus> nand`: no good reason
12:58:51 <geekosaur> comparing predated Data.Function.on
12:58:59 <luite> adis: oh then you have to sort first
12:59:11 <geekosaur> so it's kinda grandfathered, but ideally would be replaced with th emore general combinator
12:59:46 <luite> adis: does the order of the (1,11), (2,22) in the resumt matter?
12:59:58 <luite> result
13:00:10 <nand`> let me just comment on how this would be easier if the input was [("a", (1,11)), ..] instead of ("a", 1, 11)
13:00:10 <adis> luite: no
13:00:26 <adis> sorting sounds good..
13:00:36 <nand`> because then it would probably be as simple as map sequenceA . groupBy ((==) `on` fst) . sortBy (comparing fst)
13:01:39 <nand`> oh, no; not quite :)
13:01:52 <nand`> that would end you up with ("aaa",[(1,11), (2,22), (3,33)]) :)
13:02:14 <nand`> you could probably wrap a First monoid around it but that makes for more boilerplate
13:02:29 <nand`> and at that point you might as well not use sequenceA in the first place
13:03:34 <adis> monoid sounds difficult, I am still beginning to learn Haskell :)
13:03:55 <shapr> adis: Monoid is very easy, don't worry! It's a big name for a simple idea.
13:03:59 <zzing> Does anyone know about any problems compiling ghc7.4.2 on freebsd? After I configure it, gmake stops at Configuring hsc2hs-0.67... ghc.mk:85: *** Make has restarted itself 2 times; is there a makefile bug?.
13:04:14 * hackagebot wai-eventsource 1.3.0.1 - WAI support for server-sent events (FelipeLessa)
13:04:21 <luite> adis: ok, then you can just sort the list, with sort (the standard sort compares the first element of the tuple, then the second, then the third)
13:05:12 <luite> adis: so then the groupBy will work as expected, since all "a" elements will be in a contiguous part of the list
13:06:49 <Guest60587> monoids are simple
13:06:55 <Guest60587> and warm and fuzzy
13:07:02 <ocharles> apparently so are comonads
13:08:12 <Guest60587> im still struggling to understand what comonads ARE *really*
13:08:16 <Guest60587> xD
13:08:28 <DT``> cowarm or cofuzzy cothings.
13:08:39 <Guest60587> comonoids in the cocategory of coendofunctors
13:09:46 <donri> a comonad is the inverse of a monad. instead of return :: a -> m a, you have extract :: w a -> a; instead of join :: m (m a) -> m a, you have duplicate :: w a -> w (w a)
13:10:05 <ion> adis: ((+),0) is a monoid (consisting of a binary operation and an “empty”/identity value), so are ((*),1) and ((++),""). The laws are: 0 + a = a; a + 0 = a; a + (b + c) = (a + b) + c
13:10:08 <ocharles> oh that clears it aalllllll up
13:10:14 <donri> extract (1,2) == 2; duplicate (1,2) == (1,(1,2))
13:10:24 <JoeyA> Find a problem that's modeled well with comonads.  I don't know what that would be, since I don't understand them.
13:10:30 <ocharles> yes, but that doesn't show any motivation of where a comonad would be a good choice
13:10:58 <JoeyA> What helped me with Arrow was learning about the Mealy machine: newtype Mealy a b = Mealy { runMealy :: a -> (b, Mealy a b) }
13:11:07 <donri> data-lens uses the Store comonad which i think is the inverse of State?
13:11:23 <edwardk> ocharles: i use them in scala for helping track bound names during parsing, i use them for running cellular automata, image filters, non-empty streams, lenses can be built using the store comonad, etc.
13:11:43 <edwardk> in particular you _don't_ use them like monads. monads give you nice overall control flow
13:11:50 <ocharles> hm, maybe i just don't do enough interesting work :)
13:11:58 <ocharles> i just prod databases and render html
13:11:59 <donri> you use them like the inverse of monads. ;)
13:12:01 <ocharles> what a boring life :(
13:12:02 <edwardk> comonads give you some nice local structures you can manipulate that have a comonadic wrapper
13:12:17 <edwardk> i use them for tracking names and types on terms in compilers, all sorts of things
13:12:28 <edwardk> cofree comonads are useful to annotate syntax trees as well
13:12:51 <tdammers> edwardk: how does that work? the tracking names thing?
13:13:08 <adis> ion: thanks, but I want to figureout how to implement shapr's advices first :)
13:13:08 <tdammers> I'm using a plain old state monad for that right now
13:13:37 <donri> tekmo was promising an upcoming blog post on the tuple comonad
13:13:38 <shapr> adis: ooh, what was my advice?
13:14:03 <adis> ups, sorry, I meant luite
13:14:14 <shapr> adis: Oh, ion told you exactly what a monoid is/does.
13:15:18 <Guest60587> what does a monoid do, great question, very imperative ;)
13:16:16 <edwardk> tdammers: newtype Patterned a = Patterned a [Name] -- instance Comonad Patterned where extract (Patterned a _) = a; extend f w@(Patterned _ xs) = Pattered (f w) xs
13:16:59 <edwardk> tdammers: now we can mash them together instance ComonadApply Patterned where Patterned f xs <@> Patterned a ys = Patterned (f a) (xs ++ ys)
13:17:39 <edwardk> i use it in scala because in scala monad transformers are downright awful, so in effect Patterned is a monad transformer that adds a [Name]'s to the current State when you thread it through your code
13:18:16 <tdammers> hmm
13:18:52 <tdammers> that is actually somewhat over my head
13:19:27 <tdammers> no wait, that last sentence made some sense
13:19:49 <Clint> is there an easy way for me to convert [[(k,v)]] to a Map k [v] with a default value for v in the event the key is not present in that index of the original list?
13:20:02 <tdammers> I just don't see the advantage of using a comonad when a plain old monad transformer would do
13:20:09 <tdammers> but then, I don't speak scala
13:20:41 <edwardk> tdammers: try writing a monad transformer in scala some time. the moment you go to actually use it, you wind up doing things like
13:21:12 <merijn> Clint: There's no existing "default map" (although it's trivial to wrap Map to do it)
13:21:29 * Clint squints.
13:21:34 <merijn> Clint: Just replace "lookup" with "findWithDefault v" (or whatever it's called)
13:21:38 <edwardk> pure[({type F[X] = StateT[S,Trampoline,X]})#F,Int](10)
13:21:41 <merijn> :t Data.Map.findWithDefault
13:21:43 <lambdabot> forall a k. (Ord k) => a -> k -> M.Map k a -> a
13:21:46 <edwardk> that is clearly the most intuitive way to write 'return' ;)
13:21:53 <tdammers> holy crap
13:21:55 <hpaste> adis pasted “-” at http://hpaste.org/73292
13:21:57 <edwardk> and you can't drop the stupid type signatures
13:22:02 <adis> this is what I came up with
13:22:12 <edwardk> so its a much much nicer experience to just plumb a comonad through
13:22:18 <edwardk> since every comonad gives rise to a monad transformer
13:22:26 <tdammers> well, I'm writing mine in haskell
13:22:27 <d-old> hey, I did cabal install yesod-platform, but I didn't get the yesod executable
13:22:33 <edwardk> and its easier to just work with the comonads where you don't fight inference
13:22:34 <edwardk> tdammers: sure
13:22:40 <edwardk> in haskell monad transform away
13:22:44 <edwardk> and that example isn't so great
13:22:46 <adis> can I simplify it?
13:22:49 <tdammers> ah
13:22:52 <d-old> did I do something wrong or is there no longer a yesod exe?
13:22:57 <adis> (not by using monids :))
13:22:58 <edwardk> but the other examples using things like cellular automata are pretty nice
13:23:38 <tdammers> any reading material on those?
13:25:53 <fryguybob> tdammers: Perhaps http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html ?
13:26:26 <edwardk> but the other examples using things like cellular automata are pretty nice
13:27:20 <edwardk> tdammers: check sigfpe's blog on using an image monad for describing image blurring
13:27:26 <edwardk> er image comonad
13:27:41 <tdammers> (reading)
13:28:07 <edwardk> you may also want to look at comonad-transformers and comonads-fd
13:28:17 <scooty-puff> do type classes exist in ghc core in constraint form?
13:28:19 <edwardk> they give you monad transformers analogues
13:28:25 <ocharles> tdammers: http://etorreborre.blogspot.com.au/2012/06/strong-functional-programming.html apparently gets to comonads. if not, it's still a great read :)
13:28:29 * ocharles is currently reading this
13:31:09 <osa1> I'm looking for a channel for asking some general type stuff, do we have a channel for this?
13:31:49 <tdammers> ocharles: interesting reading, yes
13:31:57 <ocharles> i'm really interested in total programming atm
13:32:40 <ocharles> i might try my hand at building my own interpreter as a learning experience to really get the various parts
13:34:34 <Clint> merijn: nono, i have a series of key-value pairs and i want to be able to get the correct sequence of values for a given key, but returning a default value if data are missing from the series
13:34:43 <Clint> but i may have just answered my own question
13:36:21 <ocharles> '"a <> Colist a" stands for "Cocons a (Colist a)"' *head explodes*
13:36:32 <ocharles> coconut
13:42:10 <hpaste> avocado pasted “prettySize” at http://hpaste.org/73293
13:42:40 <MostAwesomeDude> @djinn (a -> a -> b) -> a -> b
13:42:41 <lambdabot> f a b = a b b
13:43:24 <avocado> i can't get this function to load up in ghci because i don't understand what to do with the error it gives me. if i define the function inside ghci, it works fine, though.
13:43:58 <ion> It seems the error is missing from the paste.
13:44:36 <hpaste> avocado annotated “prettySize” with “prettySize (annotation)” at http://hpaste.org/73293#a73294
13:45:06 <ion> Okay. You’ll have to pick a type for “d”.
13:46:03 <ion> You don’t need the realToFrac for the “y” parameter, btw.
13:46:35 <avocado> what would the final type be? Fractional Integer?
13:46:49 <ion> Also, it’s evil to call 1024² bytes “MB”. Mega is 1000². :-P
13:46:59 <avocado> this division thing has been really confusing for me to deal with. i spent a good portion of last night trying to understand what was happening
13:47:04 <ion> Double perhaps.
13:47:17 <avocado> i didn't get very far, obviously
13:47:38 <avocado> > :t (/)
13:47:39 <lambdabot>   <no location info>: parse error on input `:'
13:47:48 <rking> https://en.wikipedia.org/wiki/Mebibyte
13:48:28 <ion> Using MiB is also usually a worse idea than using MB because the latter is the only one we as humans can reason about more or less intuitively.
13:49:21 <ion> Quick, how many GiB is 955 MiB? How many B is it?
13:49:32 <ion> Using GB and MB, the answers are immediately obvious.
13:50:10 <avocado> TIL GiB = 1024^3 and GB = 1000^3 -_-
13:50:28 <MostAwesomeDude> ion: Quick, how many pints are in a gallon?
13:50:42 <Guest60587> 8
13:50:46 <rking> ion: Quick, how many MB is 2¹⁰ bytes?
13:50:50 <nand`> quick, how many milliseconds are in a microfortnight?
13:50:51 <tdammers> how did you do that?
13:51:15 <tdammers> how many macrocosmoses are in a microbe?
13:51:16 <ocharles> nand`: I think I might close dates with "I'll call you in a microfortnight"
13:51:22 <ion> rking: 2¹⁰/1e6
13:51:35 <nand`> 1 * microfortnight = 1.2096 s
13:51:41 <nand`> the wonders of libqalculate
13:51:41 <Guest60587> how many microcosms in a megalomaniac
13:51:43 <rking> ion: Neither one is useless
13:52:09 <rking> But I agree that MB = 10⁶ bytes.
13:52:25 <Guest60587> i see 10? bytes
13:52:34 <ion> rking: That’s why i said “usually”. Usually it’s better for user interfaces targeted for humans to use unit prefixes humans can understand intuitively.
13:52:35 <nand`> I think it makes more sense to use base 10 units with decimal numbers and base 2 units with binary or hex numbers
13:52:55 <nand`> and non-debugging user interfaces are most certainly almost always going to be decimal :P
13:53:05 <tdammers> a microfortnight is about 1.2 seconds, right?
13:53:10 <nand`> tdammers: yes
13:53:17 <rking> Guest60587: Then either your font doesn't support the U+2076 char, or else you're not getting properly decoded UTF-8.
13:53:59 <tdammers> in that case, saying "I'll call you in a microfortnight" probably takes longer than an actual microfortnight
13:54:11 <rking> ion: K.  Though I wonder how often that 24/1024 matters to a human.
13:54:27 <tdammers> in fact, the word "microfortnight" alone takes about a microfortnight to pronounce
13:54:28 <Guest60587> rking: i i know, i was looking for the 2076
13:54:58 <nand`> tdammers: indeed
13:55:17 <DT``> tdammers, that's why it's so long.
13:55:25 <tdammers> which makes it kind of mnemoic. Self-describing, if you will. Very well done.
13:55:35 <Guest60587> note that 'a human' is not an absolute configuration of 'nice units' since different cultures in different time periods (or the same time period) have wildly different base systems and other weird ass number writing systems
13:55:55 <tdammers> 2, 5, 10 and 12 stick out though
13:56:10 <tdammers> 2 hands, 5 fingers per hand, 10 fingers total
13:56:14 <tdammers> 12 just divides nicely
13:56:26 <DT``> 12 finger bones.
13:56:27 <Guest60587> 12 divides 60 nicely, among many other numbers
13:56:41 <tdammers> oh, and roughly 12 moons per year
13:56:44 <Guest60587> and we have not always used bases
13:56:50 <tdammers> roman numerals?
13:57:00 <nand`> while you kids are still arguing over which base to use I'm off counting in unary
13:57:02 <nand`> 00000000000000000000000000000000000000000000000000
13:57:18 * Guest60587 invents zero real fast
13:57:22 <tdammers> nand`: bah. unary is bloated. I'll use nullary.
13:57:31 <nand`> tdammers: :)
13:57:44 <tdammers> see? I've reached infinity already.
13:57:56 <nand`> nullary base numbers constitute a field, don't they?
13:57:59 <Guest60587> roman numerals only stick out since they tried to take over the world
13:58:13 <Guest60587> many weird systems were lost or are mostly forgotten now
13:58:22 <tdammers> nand`: absolutely no fucking clue
13:58:44 <tdammers> Guest60587: yeah... it's interesting to see in retrospect how they struggled
13:58:48 <nand`> tdammers: I was going by the fact that the only nullary number is ‘’, not counting the ‘ ’. so * =
13:59:12 <Guest60587> tdammers: that being said, maybe we have yet to invent a system better than 'base whatever' ;)
13:59:13 <nand`> etc., in general every algebraic equivalence holds since it's a trivial set
13:59:51 <tdammers> nand`: well, but you'll have to make a choice - either you can represent all numbers, but their representations are all equal, or you can only represent one number
14:00:02 <tdammers> complete or consistent, can't have both
14:00:21 <nand`> I was going by the latter
14:00:33 <nand`> what use an inconsistent number system? :)
14:00:59 <Guest60587> having all the same representation would make business calculations very fast and easy ;)
14:01:07 <hpc> tdammers: you can for sufficiently boring logical frameworks
14:01:08 <Guest60587> hey i want 0
14:01:11 <Guest60587> ok it costs 0
14:01:12 <nand`> either way, base 1 and base 2 both introduce interesting properties; but all higher bases are essentially redundant
14:01:15 <Guest60587> damn ionly have zero
14:01:20 <Guest60587> well here, your change in zero
14:01:53 <Guest60587> nand`: base sqrt2
14:01:58 <DT``> nand`, base e.
14:02:04 <DT``> damn, too slow.
14:02:12 <Guest60587> base i
14:02:21 <nand`> the property base 1 introduces is an algebraic one: 1. every natural number is representable, 2. all equal numbers have an equal representation; base 2 introduces the property that differing numbers can have the same length; which is useful for storage reasons
14:02:23 <DT``> base -2i.
14:02:39 <nand`> ah, I meant for natural bases only
14:03:20 <Guest60587> does 'nullary' even make sense
14:03:23 <nand`> base 2i is interesting as well
14:03:26 <nand`> Guest60587: of course
14:03:29 <Guest60587> >_>
14:03:34 <DT``> nand`, for storage reasons, 3 should be a better base than 2.
14:04:06 <Guest60587> base infinity
14:04:11 <DT``> since it's closer to e.
14:04:13 <Guest60587> for maximum storage
14:04:20 <pdxleif> Are there some library functions out there for mean and standard deviation? (hstats doesn't build at the moment).
14:04:51 <nand`> well, for real world storage reasons you're limited by what your real world device can easily represent
14:04:56 <hpc> pdxleif: mean and stddev are fairly simple calculations
14:05:00 <nand`> base 2 works well with transistors
14:05:19 <Guest60587> base 2 works well with magnetic disk
14:05:56 <Guest60587> higher base works well with optical and coaxial cables
14:06:19 <Cale> hpc: Implementing mean efficiently over lazy lists takes a little bit of cleverness/care though
14:06:59 <hpc> ah, true
14:07:01 <nand`> re: nullary, an n-ary number representation is some string of elements from the n-digit set; eg. the 3-digit set is [0,1,2]; the 2-digit set is [0,1]; the 1 digit set is [0] and the 0-digit set is, appropriately []
14:07:21 <nand`> as such, nullary number is a string of elements from []; and of course only one such string exists: the empty string
14:07:48 <nand`> (though to be pedantic we'd have to allow empty strings in other bases too, eg an empty string in any base would be zero)
14:08:04 <nand`> if we disallow empty strings in general then no nullary number can exist
14:08:12 <Guest60587> thats what i figured
14:08:28 <Guest60587> empty string doesnt make sense as a value in any base
14:08:43 <nand`> I think it does. 000 = 00 = 0 =
14:08:59 <Guest60587> >_>
14:09:01 <Cale> pdxleif: http://hackage.haskell.org/packages/archive/statistics/0.10.1.0/doc/html/Statistics-Sample.html might be what you're after
14:09:05 <nand`> same as 0001 = 001 = 01 = 1
14:09:11 <Cale> Though it may also be a little more fancy than you need :)
14:09:19 <Guest60587> 0001 = 001 = 01 = 1 =
14:09:21 <Guest60587> ERROR
14:09:28 <nand`> though we would probably need some notation to write down the empty string when speaking about it, I propose ∅
14:09:33 <DT``> nand`, that doesn't hold in unary, though.
14:09:41 <Guest60587> nand`: ? ?
14:09:52 <nand`> DT``: ah, true; hmm
14:09:59 <Cale> Guest60587: obviously the empty string has value 0
14:10:04 <Cale> Because it's an empty sum
14:10:43 <nand`> hmm
14:10:51 <Cale> When you write a string of digits in base b, say d_n d_(n-1) ... d_0, the number you are referring to is sum over k = 0 to n of d_k b^k
14:10:53 <nand`> to make unary truly fit into the same set of rules, the only possible unary number would be 0
14:10:59 <Guest60587> Cale: i guess i need to go back to the third millenium BC because i cant imagine numbers written out by not being written at all
14:11:08 <Guest60587> we ARE talking about writing systems
14:11:12 <nand`> since 0*1^3 + 0*1^2 + 0*1^1 + 0*1^0 = 0
14:11:14 <Guest60587> not math
14:11:15 <DT``> Cale, then it's indefinite: 0^0.
14:11:26 <Cale> > 0^0
14:11:28 <lambdabot>   1
14:11:41 <DT``> that's one possible definition.
14:11:47 <Cale> It's the only reasonable definition
14:11:54 <Cale> and the one which is generally accepted
14:11:56 <nand`> I retract my former propositions then; 00 isn't the successor of 0 in unary, since we're not talking about peano nats
14:12:06 <ocharles> edwardk: category-extras say's it's obsolete. has been obsoleted by anything in particular?
14:12:17 <Guest60587> maybe we should give up trying to fit zero into every corner of our ideas
14:12:23 <Guest60587> where it doesnt go
14:12:32 <Cale> but even so, that would only come up in base 0
14:12:38 <Cale> which is weird
14:12:43 <nand`> defining 0^0 breaks some exponentiation laws unless you rewrite those to account for the exception
14:12:47 <DT``> the limit of 0^n as n->0 is 0, though.
14:12:51 <nand`> I don't think 0^0 would come up in base 0
14:12:53 <Cale> nand`: It preserves the important one
14:13:06 <Cale> which is that x^(a+b) = x^a * x^b
14:13:08 <nand`> you never have b^n standing alone; it's always d*b^n
14:13:14 <nand`> and there's no nullary ‘d’
14:13:21 <Guest60587> why not ''
14:13:22 <ocharles> edwardk: oh nvm, I was looking at an old version. I see you've expanded it into new libraries
14:13:38 <scshunt> 0^0 = 1 is indeed the only sensible definition
14:13:40 <edwardk> ocharles: yeah its split into like 20 pieces now
14:13:40 <DT``> nand`, that's also true. uhm...
14:13:46 <frerich_> Hm, is anybody aware of code using the TransformListComp extension? It seems really neat to me,  I wondered why I never heard of it before...
14:13:47 <Cale> nand`: yeah, it depends on what digits you'd be allowed
14:14:02 <Cale> nand`: and it's unclear whether you're allowed any
14:14:29 <meursault> is anyone good at linking haskell libraries with a c++ program in OS X? I've been trying to follow the various directions I've found online and the -v option to ghc does not seem to provide a list of libraries. I know I can go grepping but I am wondering if there is an easier way
14:14:33 <nand`> we can trivially rewrite our “base” system to not be ... d₃b³ + d₂b² + d₁b¹
14:14:44 <nand`> but instead ... d₃b³ + d₂b² + d₁b¹ + 0
14:14:46 <Guest60587> linking haskell with c++ heh
14:14:52 <nand`> err, I forgot a d_0*b^0
14:14:52 <DT``> scshunt, why prefer x^0 instead of 0^x? it's indefinite, like 0/0.
14:15:00 <Cale> n^m is the number of functions from a set of m elements to a set of n elements
14:15:13 <nand`> but either way, we can trivially redefine the ‘base-n to number’ equations by adding an extra + 0; and then if we take away all of the digits we end up with 0
14:15:23 <Cale> There is exactly one function from the empty set to itself: the identity function which is required to exist in order for Set to be a category.
14:15:31 <DT``> it's 1 when it's useful for it to be 1, it's 0 when it's useful for it to be 0.
14:15:43 <Cale> 0^0 is never considered to be 0
14:15:45 <scshunt> DT``: because 0^0 is "usually" 1
14:15:52 <scshunt> specifically, quoth wikipedia: If the functions f and g are analytic and f is not identically zero in a neighbourhood of c on the complex plane, then the limit of f(z) g(z) will always be 1
14:16:19 <scshunt> (where \lim_{x \to 0^+} f(x) = 0 and \lim_{x \to 0} g(x) = 0)
14:16:20 <ocharles> edwardk: how come comonad is no longer copointed?
14:16:28 <Guest60587> Cale: what makes that function an identity function?
14:16:29 <ocharles> at least in Control.Comonad from the comonad package
14:16:32 <meursault> oddly the linker line I get with ghc -XForeignFunctionInterface -c Foo.hs -v5 is only '/usr/bin/gcc' '-m64' '-fno-stack-protector' '-m64' '-nostdlib' '-nodefaultlibs' '-Wl,-r' '-o' 'Foo.o' '/var/folders/ol/olc2-MPVGAS7UUz85VMaxk++--Q/-Tmp-/ghc26864_0/ghc26864_1.o' '/var/folders/ol/olc2-MPVGAS7UUz85VMaxk++--Q/-Tmp-/ghc26864_0/ghc26864_0.o'
14:16:33 <edwardk> because copointed and pointed are a terrible abstraction
14:16:38 <Cale> Guest60587: the empty function?
14:16:42 <ocharles> hm
14:16:45 <Guest60587> Cale: isnt everything else also true about that function?
14:16:52 <scshunt> DT``: and in combinatorics, 0^0 should always be 1 to make a lot of things make sense
14:16:54 <Cale> Guest60587: Well, many things are true of it
14:17:21 <Guest60587> such as 'for all elements in the domain, f maps them to something unequal ;)
14:17:22 <Guest60587> '
14:17:23 <Cale> Guest60587: but I'm pointing out that if the empty function doesn't exist or is somehow excluded from the definition of a function, then Set won't be a category anymore.
14:17:28 <edwardk> ocharles: turns out to be more useful to care about the semigroup like structure provided by 'extend' than it is to focus on 'empty'
14:17:40 <scshunt> defining e^x as 1 + \sum_{n=1}^\infty \frac{x^n}{n!} seems just... sad
14:17:45 <edwardk> there are very few ways you can actually program correctly with point and copoint
14:17:54 <Cale> Guest60587: because it won't have an identity arrow from the empty set to itself
14:17:58 <edwardk> e.g. say you wanted to build a set up. you might go 'oh a set can be pointed!'
14:18:11 <edwardk> and then you can point to build up singleton sets, and use mappend to smash them together
14:18:13 <scshunt> DT``: so basically, the 0^x case is special, most of the rest of the time the limit is 1
14:18:16 <DT``> scshunt, I'm not arguing that you should never have 0^0 = 1, I'm saying it's context-dependent (or multivalued, even).
14:18:17 <edwardk> but there are no laws relating point and mappend!
14:18:24 <edwardk> so its a utter one-off hack
14:18:25 <nand`> b^(x-y) = b^x / b^y; so 0^(1-1) = 0^1 / 0^1 = 0/0 = 0^0
14:18:27 <ocharles> hmm
14:18:35 <nand`> we'd need to fix that law, at least; if we take 0^0 = 1
14:18:37 <ocharles> I was using copointed as a wrapper for pulling stuff out of a database
14:18:41 <Cale> DT``: It's not context-dependent. f(x,y) = x^y is discontinuous at (0,0)
14:18:47 <Cale> DT``: but it is defined as 1
14:19:00 <ocharles> ie, if I have a 'musician' table, then FromDB a = FromDB { rowId :: Int, rowData :: a }
14:19:11 <ocharles> so you can pass around FromDB Musician, and fill in the rowId field.
14:19:22 <ocharles> maybe that forms something more than just Copointed though (where extract = rowData)
14:19:27 <Cale> DT``: which is because there's a combinatorially important reason for it to be 1
14:19:42 <Cale> also, because it's convenient everywhere
14:19:50 <Cale> For example, in every power series expansion
14:19:53 <roconnor> Cale: (^) is continous since it is working over the discrete topology.
14:20:01 * roconnor ponders that
14:20:02 <nand`> https://en.wikipedia.org/wiki/Exponentiation#Zero_to_the_power_of_zero
14:20:09 <Cale> exp(z) = sum over k >= 0 of x^k / k!
14:20:13 <Cale> er
14:20:16 <Cale> exp(z) = sum over k >= 0 of z^k / k!
14:20:33 <Cale> this expansion fails at 0 unless 0^0 = 1
14:20:37 <Cale> (and 0! = 1)
14:20:39 <ocharles> however, I sort of needed copointed because I thought I had 2 different 'FromDB' type data types, but it turns out with much schema fiddling it can be simplified to one and you get a much simpler model. So maybe I don't need that at all
14:20:40 <pdxleif> Mean is trivial, stddev slightly less so
14:20:51 <pdxleif> Just wondering why they're not in some utils lib or something.
14:20:57 <scshunt> Cale: I disagree with you that it is "defined" to be 1
14:21:08 <scshunt> Cale: It is /usually/ defined to be 1 becasue it's convenient
14:21:14 <pdxleif> The J language for instance, has things like euler's totient function built-in, nothing to "import".
14:21:18 <Cale> scshunt: Well, same goes for 2 + 3 = 5
14:21:20 <scshunt> but I don't think it's necessarily fair to generalize
14:21:32 <Cale> scshunt: It's *usually* the case that 2 + 3 = 5 in Z because it's convenient.
14:21:34 <Guest60587> god defined it, sorry
14:21:42 <nand`> I think it better to define 0^0 = 1 and special-case theorems that would be practical with 0^0=0 instead
14:21:45 <pdxleif> Cale: Thanks!
14:22:13 <roconnor> @djinn Void -> Void
14:22:14 <lambdabot> f a = a
14:22:19 <Cale> nand`: yes, though the latter sort of thing is very exceptional -- I can't think of any examples of it
14:22:20 <nand`> it goes well with the basic intuition of how exponentiation works too: x^2 = x * x * 1;  x^1 = x * 1; x^0 = 1; x^-1 = 1 / x; x^-2 = 1 / x / x
14:22:31 <nand`> Cale: the wikipedia page I mentioned lists some examples from analysis
14:23:06 <DT``> Cale, it's too late for me to find an example of the utility of 0^0 (if there's any), but 0^0 is not 1, it can be 1.
14:23:13 <nand`> and of course x^(2-2) = x * x * 1 / x / x = 1
14:23:21 <Cale> DT``: Okay, then 2 + 3 is not 5, it just can be 5
14:23:41 <Egbert9e9> Data.Vector freeze or thaw flood the heap with mut_arr_ptrs_frozen
14:23:48 <Cale> THERE IS NO DIFFERENCE IN MATHEMATICS BECAUSE MATHEMATICS IS CONVENTION
14:23:49 <DT``> also, we're talking about a specific 0^0, saying that 2+3=5 is a strawman.
14:24:17 * hackagebot index-core 1.0.1 - Indexed Types (GabrielGonzalez)
14:24:37 <Cale> (between what is and what can be)
14:24:38 <DT``> Cale, 0/0: x/x = 1, 0/x = 0, x/0 = impossible, which is it?
14:25:01 <Guest60587> i hate 'its an absolute fact like 2+2=4'
14:25:02 <Cale> huh?
14:25:11 <DT``> same with 0^0.
14:25:14 <Cale> DT``: no
14:25:30 <kuribas> Why can I not use ### in literate haskell?
14:25:32 <scshunt> DT``: x/x = 1 does not hold when x = 0
14:25:56 <nand`> Cale: the reason why 0^0 is to be considered indeterminate is also from analysis apparently; there's a certain rule that states something is indeterminate if its limit is not equal to the expression formed by the limits of its subexpression; something like that
14:25:58 <DT``> and x^0 = 1 does not hold when x = 0.
14:26:00 <Cale> DT``: 0/0 is, by convention, undefined, because the notation a/b means a * b^-1 and b^-1 means the (unique) number c such that b*c = 1, and in the case of b = 0, no such c exists.
14:26:02 <DT``> same thing.
14:26:06 <nand`> Cale: which holds true for 0/0 and other indeterminate stuff
14:26:09 <nand`> and also apparently 0^0
14:26:26 <Cale> But 0^0 is conventionally defined to be equal to 1
14:26:35 <DT``> nand`, exactly that.
14:27:17 <DT``> you might like 0^0 = 1, and indeed it's useful, but it's an indefinite form nonetheless.
14:27:17 <Cale> nand`: "indeteminate form" is an antequated name for "discontinuity of a function"
14:27:24 <Cale> and is not the same as being undefined
14:27:41 <nand`> the problem with 0/0 is that introducing 0/0 = whatever breaks a lot of theorems and/or makes them unnecessarily complicated in order to special-case 0
14:27:48 <Guest60587> 0^0 = 1, now its definite ;)
14:27:50 <DT``> *indeterminate
14:27:51 <Cale> It simply means that when taking limits, one cannot push the limit through whatever operation is involved.
14:27:53 <DT``> right.
14:28:04 <nand`> but the thing about 0^0 is that the situation seems to be more often than not the exact opposite, introducing 0^0=1 makes a lot of theorems shorter
14:28:27 <Cale> But 0^0 *is* by convention defined, despite being an "indeterminate form", that is, the exponentiation function having a discontinuity at that point.
14:28:28 <Guest60587> occams razor
14:28:33 <nand`> and by ‘seems to’ I really mean ‘I have no clue what I'm talking about’
14:28:57 <Cale> and the reasons we like that convention are many :)
14:29:01 <nand`> but that's the impression I got from wikipedia
14:29:31 <nand`> which notes that 0^0=1 simplifies many formulas involving discrete exponents; but 0^0=0 or 0^0=indet simplifies a lot of formulas involving continuous ranges (eg. analysis)
14:29:47 <kuribas> Why is there a discontinuity at 0^0 ?
14:29:59 <DT``> Cale, the usefulness of a definition doesn't make it more right.
14:30:09 <Cale> kuribas: because the limit as x -> 0 of x^0 is not equal to the limit as y -> 0 of 0^y
14:30:09 <scshunt> DT``: Why is 1 + 1 = 2 right?
14:30:10 <DT``> or wrong.
14:30:27 <nand`> kuribas: https://upload.wikimedia.org/wikipedia/commons/e/e0/X%5Ey.png
14:30:34 <Cale> DT``: The usefulness of a definition is why we choose that definition over another definition.
14:30:37 <scshunt> a definition is neither right nor wrong
14:30:50 <scshunt> usefulness is the only distinguishing characteristic of a definition
14:30:53 <nand`> kuribas: red lines are z = abs(x)^y
14:31:12 <Cale> Mathematics as a whole is not true or false any more than a chair or a pencil is true or false
14:31:24 <DT``> Cale, but both can be useful, and you do simplify x/x to 1, ignoring the x=0 case.
14:31:41 <Cale> DT``: that simplification is conditional!
14:32:12 <EvanR> Cale: but so many people will confront you and say no its the real source of objective truth
14:32:28 <Cale> EvanR: I am prepared to laugh at those people, to their face.
14:32:30 <DT``> what do you mean?
14:33:00 <Cale> (and I have a degree to be able to make some appeal to authority while doing it)
14:33:11 <nand`> conventionally, all of mathematics is based on ZFC set theory; no? how is (^) defined on ZFC sets? surely this must bring some light on the matter
14:33:16 <EvanR> degrees are the real source of objective truth ;)
14:33:28 <scshunt> nand`: it's defined on numbers
14:33:30 <Cale> nand`: On raw sets, rather than, say, real numbers?
14:33:42 <scshunt> nand`: you ignore the set properties of ^ at that point
14:33:45 <Cale> There is an exponential notation which is defined on sets, which is closely related here.
14:33:57 <nand`> Cale: on real numbers considered as sets
14:34:09 <scshunt> nand`: what is the set "pi"
14:34:09 <kuribas> What does '###' mean in a .lhs file?  I wanted to use it as a markdown header, but I get an error...
14:34:15 <scshunt> nand`: the answer is we don't define ^ on sets
14:34:15 <nand`> (how does one represent real numbers using sets either way? I know one possible construction for nats but that's where it stops)
14:34:19 * frerich_ is an amateur, but considers Mathematics to be a cathedral built on a few axioms - and this whole thing helps explaining (and predicting...) the curveballs mother nature throws at mankind. There is no absolute "truth" in it or anything.
14:34:22 <scshunt> we define it on numbers, which are certain sets
14:34:25 <Cale> nand`: Oh, well, the fact that real numbers are sets doesn't really help much -- we can still go either way
14:34:38 <scshunt> and we only rely on the specific properties of numbers
14:34:44 <scshunt> it works fine on Church numerals too
14:34:57 <lpsmith> Ok,  when you are writing a QuasiQuoter,  is there a "standard"  quoteDec that will do what GHC would normally do?
14:35:03 <nand`> yeah I guess the set-theoretic interpretation of (^) would still be able to diverge depending on how you define the set operation
14:35:42 <Cale> frerich_: Well, it helps that mathematics is full of things which correspond in some way to patterns that humans are pretty good at recognising (or at least, have become good at recognising from doing mathematics), and scientists try to describe the things they see in terms of those patterns.
14:35:45 <scshunt> nand`: I don't think there's a definition of ^ that doesn't rely on properties of numbers
14:35:48 <lpsmith> I'd like to have a quasiquoter where I can write some declarations,  and then get back those declarations + the literal text.
14:36:03 <sclv> declarations ?
14:36:03 <lpsmith> one additional declaration consisting of the literal text,  that is.
14:36:10 <sclv> oh, you mean haskell declarations
14:36:10 <scshunt> nand`: and real number are sequences of integers, where a sequence is a function \bbN -> \bbZ
14:36:16 <lpsmith> quoteDec?
14:36:24 <meursault> if anyone reads this log and finds my reference to linking haskell from g++ and wonders what the solution is
14:36:32 <Cale> nand`: On raw sets, we often define B^A to be the set of all functions A -> B
14:36:47 <lpsmith> http://www.haskell.org/ghc/docs/7.0.3/html/libraries/template-haskell-2.5.0.0/Language-Haskell-TH-Quote.html
14:36:47 <Cale> nand`: and when A and B are finite sets, B^A has |B|^|A| elements.
14:36:48 <nand`> m^n = n m -- for church numerals, and 0 = const id; so 0^0 = const id (const id) = id = 1
14:37:06 <sclv> you should use haskell-src-exts and haskell-src-meta
14:37:14 <meursault> the solution is as follows: you need to define a main temporarily in your haskell file and then link a fully functional haskell programm with -v or -v5
14:37:30 <sclv> I think there were plans to add the "standard" quoters into TH directly at some point
14:37:33 <Cale> Another way to say it: n^m is the number of strings of length m on an alphabet of size n.
14:37:40 <sclv> but there's nothing like that yet.
14:37:56 <Cale> There is one string of length 0 on the empty alphabet, which is the empty string.
14:38:00 <meursault> then it will give you a link line which you can remove the temp files from and pass to your g++ link line. I still don't know how to get a link line if your haskell library has no main
14:38:20 <sclv> lpsmith: http://hackage.haskell.org/package/haskell-src-meta/
14:38:40 <nand`> right, and I can prove that every possible function {} -> {} is identical via vacuous quantification
14:38:50 <Cale> yeah
14:38:51 <EvanR> and that they are all different
14:38:54 <nand`> as such there's only one possible
14:39:05 <Cale> the only such function has an empty graph
14:39:08 <nand`> EvanR: no, the inverse would rely on existential
14:39:19 <nand`> which can't be fulfilled for empty sets
14:39:41 <EvanR> for each pair of a -> b, a != b
14:39:50 <EvanR> true
14:40:04 <nand`> f=g iff ∀x.f(x) = g(x)
14:40:11 <Cale> You can say however that for any two functions f,g: {} -> {}, and any x in {}, that f(x) /= g(x) :)
14:40:11 <nand`> therefore f≠g iff ∀x.f(x) ≠ g(x)
14:40:21 <nand`> sorry
14:40:22 <EvanR> not disagreeing with that
14:40:25 <nand`> iff ∃x.f(x) ≠ g(x)
14:40:27 <meursault> has anyone tried to do run time compilation and loading a haskell modules from a c++ program? Specifically I am trying to allow users to write filter modules in haskell and load them from a .hs file or string at runtime
14:40:34 <nand`> but ∄x∈∅
14:40:38 <nand`> so it can never be true
14:40:39 <Cale> nand`: yeah, I was about to complain :D
14:41:00 * frerich_ admiers nand's Unicode-fu
14:41:14 <Cale> SCIM LaTeX?
14:41:21 <nand`> I debated using ⇔ for ‘iff’
14:41:29 <nand`> Cale: nah, just a plain old keyboard layout
14:41:46 <EvanR> nand`: types on an APL keyboard
14:42:05 <Cale> I have that stuff available, but I'm usually too lazy to push the combinations of keys required to obtain the symbols in regular conversation.
14:42:11 <nand`> yeah, I use LaTeX for stuff like ! or " or other useless stuff
14:42:28 <nand`> :)
14:43:35 <nand`> EvanR: I'm just pointing out that ZFC doesn't let us infer ∀x.f(x)≠g(x) ⇒ f≠g
14:43:55 <nand`> so your approach, while valid, doesn't disprove what we're saying
14:43:56 <EvanR> not that zfc is the final arbiter or really anything
14:44:03 <EvanR> of
14:44:12 <nand`> well, it's the only system I'm somewhat familiar with
14:44:17 <EvanR> i wasnt trying to contradict your vacuuous quantification xD
14:44:19 <nand`> I imagine other formalizations of functions as sets work differently
14:44:32 <nand`> oh, then I must have misunderstood
14:45:00 <frerich_> EvanR: Maybe he just wanted to exercise his Unicode skills. :-)
14:45:09 <Cale> meursault: Interesting concept. I would say probably the easiest thing is to write part of your host program in Haskell using a library such as hint
14:45:23 <Cale> meursault: and write C FFI to interface with the C++ part
14:45:36 <Cale> meursault: Should be doable.
14:45:40 <nand`> meursault: you can probably use GHC to compile your haskell code as a dynamic library
14:45:46 <nand`> then load that from within C
14:45:49 <meursault> Cale: yeah that's the basic plan is to have the haskell side expect a very specific interface
14:46:30 <n00b6502> can haskell use unicode operators
14:46:36 <Cale> (If you're up for dynamic loading of code from the C or C++ side of things, then you can also probably do that, but I would just use the GHC API or hint)
14:46:42 <Cale> n00b6502: yes
14:46:47 <EvanR> n00b6502: yes the most popular being the snowman
14:46:48 <meursault> Cale: I was mainly wondering if there were any major pitfalls with the FFI and dynamic compilation loading
14:47:00 <n00b6502> can you type one
14:47:01 <nand`> n00b6502: there's even a language extension that allows you to use unicode for some built-in language operators
14:47:11 <meursault> Specifically I'm trying to create an alternative to VTK python programmable filters
14:47:21 <n00b6502> where is lambda on the keyboard
14:47:35 <Cale> λ is a Greek letter, so it can't be an infix operator
14:47:48 <Cale> (it's considered a lowercase letter)
14:47:52 <nand`> λ for \ is one of the things -XUnicodeSyntax seems to be missing :(
14:47:58 <mauke> > let (·) = fmap in (show · (* 2)) 21
14:48:00 <lambdabot>   "42"
14:48:03 <nand`> bah
14:48:06 <nand`> that should be ∘ not ·
14:48:10 <nand`> · is multiplication
14:48:12 <mauke> · is easier to type
14:48:13 <n00b6502> i would have thought they would have put that in first
14:48:17 <nand`> nonsense :)
14:48:27 <mauke> nand`: λ is a bad substitute for \
14:48:40 <nand`> mauke: you think?
14:48:42 <n00b6502> but its what they mean when they write \  right?
14:48:43 <geekosaur> nand`, Cale just explained why it is "missing"
14:48:47 <mauke> n00b6502: not me
14:48:49 <mauke> I mean \
14:48:59 <Cale> > let λ = 5 in λ + λ
14:49:01 <lambdabot>   10
14:49:10 <n00b6502> when they put \ in haskel, they really mean <lambda>
14:49:16 <mauke> n00b6502: no
14:49:28 <scshunt> Cale: that's not a good reason; it could be special-cased
14:49:34 <n00b6502> they used \ as an ascii approximation to lambda
14:49:35 <mauke> scshunt: no, it shouldn't
14:49:36 <Cale> scshunt: It could, yes.
14:49:42 <Cale> scshunt: But I'm not sure it should be
14:49:43 <mauke> oh, "could"
14:49:48 <meursault> couldn't you just make your editor display the lambda?
14:49:56 <mauke> n00b6502: but lambda sucks
14:50:11 <scshunt> mauke: blame Church
14:50:13 <Cale> If we wanted to use a lambda, probably the mathematical symbol lambda would be better than the Greek letter lambda.
14:50:18 <nand`> geekosaur: I don't think that's a valid reason; λ could easily be specialcased with an appropriate language extension
14:50:24 <nand`> oh, what scshunt said
14:50:26 <mauke> scshunt: I blame mathematicians and their fear of words
14:50:27 <scshunt> Cale: are they distinguished, in Unicode?
14:50:42 <nand`> yes
14:50:55 <nand`> > map generalCategory ['\\', 'λ']
14:50:56 <lambdabot>   [OtherPunctuation,LowercaseLetter]
14:51:19 <geekosaur> nand`, I understand that you don't think nonUS people have the right to their own *letter* characters.  The language designers, for some reason, disagree with your obviously reasonable position
14:51:44 <mauke> seriously, what's so great about λ?
14:51:44 <Cale> scshunt: λ𝛌𝜆𝝀𝝺
14:51:59 <n00b6502> was mathematics a US invention..
14:52:06 <nand`> mauke: admit it, you really just want (s,k) = (ap, const) in the Prelude and a syntax extension for `
14:52:11 <roconnor> scshunt: Church didn't make lambda;  He put little hats on his variables.
14:52:17 <Cale> n00b6502: lol
14:52:21 <mauke> nand`: no, I'm fine with \
14:52:25 <nand`> Cale: my unicode-fu is too weak, I don't see the four characters after λ
14:52:35 <nand`> mauke: oh, I thought you were griping about the lambda calculus
14:52:37 <nand`> not the letter λ
14:52:41 <Nereid> stop whining and get your text editor to display \ as λ
14:52:42 <scshunt> roconnor: that's not what I recall, but I could be wrong
14:52:49 <mauke> nand`: http://mauke.hopto.org/stuff/javascript/unicode.html?q=%CE%BB%F0%9D%9B%8C%F0%9D%9C%86%F0%9D%9D%80%F0%9D%9D%BA
14:52:52 <nand`> Nereid: "Hello, world!λn"
14:52:53 <Nereid> >:O
14:52:56 <scshunt> Cale: fails to render on my client
14:53:05 <mauke> scshunt: ^
14:53:11 <Nereid> no, obviously only in the places where it is syntactically appropriate
14:53:12 <nand`> mauke: heh
14:53:17 <scshunt> Cale: oh, those are the mathematical alphabets
14:53:21 <Nereid> vim can do this
14:53:28 <Cale> My glyphs for those apparently come from a font called "FreeSerif"
14:53:31 <scshunt> Cale: Each of those is distinct from lambda itself
14:53:35 <Cale> yes
14:53:41 <n00b6502> i suppose you could have a language where each line is actually parsed with lines above and below, and use ASCII-art operators
14:53:42 <nand`> there's no blackboard bold lambda!?
14:53:45 <n00b6502>  \
14:53:49 <nand`> n00b6502: like befunge?
14:53:57 <mauke> nand`: I have nothing against the lambda calculus. my point is that as notation \ is superior to λ in every way
14:54:01 <scshunt> Cale: And by mathematical convention, the lambda operator should be in roman font
14:54:08 <scshunt> which is U+03BB
14:54:15 <scshunt> no different from using d in differentiation
14:54:18 <roconnor> scshunt: ah you are right
14:54:21 <Cale> How about using a Fraktur 𝕷?
14:54:23 <n00b6502> the problem with "\" is.. it already means other things elsewhere
14:54:25 <roconnor> http://math.stackexchange.com/questions/64468/why-is-lambda-calculus-named-after-that-specific-greek-letter-why-not-rho-calc
14:54:37 <nand`> mauke: I'm not one leaping to use -XUnicodeSyntax either
14:54:41 <nand`> in general
14:54:47 <scshunt> roconnor: Heh. I've read the paper, but I couldn't remember exactly
14:54:49 <mauke> this is orthogonal to -XUnicodeSyntax
14:54:51 <danil> n00b6502: apparently something like that was used by the Russian space program: http://lambda-the-ultimate.org/node/4534
14:55:02 <scshunt> Cale: If the Greeks want variables, really, they should use the Italic one :P
14:55:12 <lpsmith> ok,  another possibility... is there an easy way to include another file using Template Haskell,  so that some text is interpreted directly as a top-level declaration?
14:55:14 <nand`> mauke: then I'm not sure I follow; but note that in my font λ displays exactly like \ with a small tail to the bottom left
14:55:18 <Cale> (𝕱𝖚𝖓𝖈𝖙𝖎𝖔𝖞 x. x + 1)
14:55:22 <mauke> nand`: and?
14:55:42 <Cale> Use Fraktur for all language keywords
14:55:42 <nand`> so there's no clear advantage or disadvantage between either; except that λ is, well, unicode - and \ is easily available on common keyboard layouts
14:55:53 <nand`> which is the same argument I apply to -XUnicodeSyntax in general
14:56:06 <Cale> it would be annoying to type, but it would look SICK
14:56:06 <mauke> nand`: that doesn't follow
14:56:08 <Cale> lol
14:56:19 <nand`> mauke: perhaps you could explain why \ is better than λ
14:56:21 <scshunt> Cale: I can't tell if the error is my terminal, screen, or just the lack of a fixed-width font with that character
14:56:22 <mauke> nand`: the advantage of \ is that is't not a letter
14:56:51 <nand`> mauke: I'm not seeing a clear advantage there
14:56:56 <mauke> nand`: and that it is used to escape things in other languages, but that's pretty weak
14:56:57 <Cale> wat
14:57:16 <Cale> nand`: not being a letter is good, because it means it doesn't steal an identifier
14:57:20 <mauke> nand`: if you use λ, you have to make it a keyword
14:57:32 <mauke> and it means you can't write \x -> x + 1 because you have to write λ x -> x + 1
14:57:35 <mauke> with a space after λ
14:57:55 <Cale> > map (\λ -> λ^2) [1..10]
14:57:56 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
14:57:58 <mauke> and this keyword doesn't even mean anything
14:58:14 <mauke> I can see why a language might have "if", "while", or "return" as keywords
14:58:14 <nand`> why not simply extend the rules for naming things with ‘may not contain λ’, then it no longer has to be a keyword or identifier and can simply be replaced for \ in the current syntax
14:58:17 <mauke> but "λ"?
14:58:30 <mauke> nand`: that's just crazy
14:58:40 <mauke> you'd have completely non-standard rules for identifiers
14:58:41 <nand`> it's about as crazy as -XUnicodeSyntax already is
14:58:45 <mauke> no
14:58:46 <Cale> What if I'm Greek and want to name variables in Greek?
14:58:49 <mauke> -XUnicodeSyntax uses unicode
14:59:17 <Cale> I don't know if anyone does :)
14:59:24 <Cale> but I think it should be allowed
14:59:27 <mauke> your proposed system is pretty much incompatible with all unicode rules for identifiers
14:59:29 <nand`> -XUnicodeSyntax already makes it impossible for identifiers with ‘∀’ in them to work
14:59:50 <Cale> ∀ isn't a letter in some language though, it's a mathematical symbol
14:59:59 <geekosaur> we didn't already establisht he Greeks have no right to theirpseudoalphabet when a proper American wants to use it for symbols?
14:59:59 <nand`> since it renames ‘∀’ to ‘forall’ even outside type signatures; at least it did the last time I tested this (7.0.x)
14:59:59 <mauke> > generalCategory '∀'
15:00:01 <lambdabot>   MathSymbol
15:00:09 <nand`> but mathsymbols can be identifiers
15:00:10 <mauke> nand`: that's a symbol, not a letter
15:00:11 <nand`> too
15:00:15 <Cale> geekosaur: lol
15:00:19 <geekosaur> (yes, this is sarcasm, but also very obviously what nand` is doing here...)
15:00:32 <Cale> pseudoalphabet
15:00:35 <Cale> I love it
15:00:39 <nand`> > let x + y = x * y in 1+2 -- what is the role of + here?
15:00:41 <lambdabot>   2
15:00:44 <ion> pselphabet
15:00:49 <mauke> "pseudo", "alpha", "beta"
15:00:55 <Cale> especially as the word "alphabet" comes from the Greek
15:00:56 <mauke> ಠ_ಠ
15:01:10 <EvanR> ?_?
15:01:26 <mauke> EvanR: get more fonts
15:01:35 <EvanR> its not a font thing
15:01:40 <nand`> geekosaur: Haskell clearly already favors English, not Greek
15:01:43 <EvanR> im using screen
15:01:48 <Nereid> me too
15:01:52 <rking> Screen can do utf-8.
15:01:52 <nand`> I don't think adding a cherry on top would cause any massive riots
15:01:53 <mauke> EvanR: screen can do unicode
15:01:59 <EvanR> i dont doubt it
15:02:09 <mauke> (I'm using tmux, though)
15:02:11 <EvanR> my shell plus screen plus iterm are conspiring against me right now
15:02:29 <mauke> Cale: thanks for the font
15:02:48 <Cale> > let αλφάβητο = ['a'..'z'] in map toUpper αλφάβητο
15:02:49 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
15:02:55 <armlesshobo> nand`: does it become the identifier for '*' which is the infix operator for 1 * 2 ?
15:03:21 <geekosaur> nand`, it's a turd for anyone outside the US.  only a cherry for people who have decided the US is the Only Country With Any Right To Anything
15:03:46 <EvanR> countries dont have rights
15:03:48 <gertc> how do you putStrLn lazy Text
15:04:26 <nand`> geekosaur: I'm outside the US though
15:04:28 <Nereid> > toUpper 'λ'
15:04:29 <lambdabot>   '\923'
15:04:34 <Nereid> urgh
15:04:36 <nand`> and I think it would be a cherry
15:04:37 <luite> gertc: import Data.Text.Lazy.IO
15:04:39 <geekosaur> so you're just prejudiced against Greeks?
15:04:43 <Nereid> > 'λ'
15:04:44 <gertc> thx
15:04:45 <lambdabot>   '\955'
15:04:47 <Nereid> ok
15:04:48 <geekosaur> just, enough.
15:04:54 <nand`> geekosaur: Greek, not Greeks; yes
15:04:55 <EvanR> > random :: Char
15:04:57 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
15:04:57 <lambdabot>         against inferred type...
15:05:05 <mauke> http://mauke.hopto.org/stuff/javascript/unicode.html?q=923
15:05:13 <nand`> I'm prejudiced against languages other than English. Isn't that the whole point? Haskell already uses English everywhere: “let... in”, “where”, “forall” etc.
15:05:39 <armlesshobo> Permite ... en
15:05:41 <armlesshobo> donde
15:05:44 <armlesshobo> para todo
15:05:46 <armlesshobo> lol
15:05:50 <rking> I don't get it. Why is λ something that can't be reserved, but "let" is?
15:05:50 <armlesshobo> sounds weird
15:05:50 <EvanR> http://en.wikipedia.org/wiki/Glagol
15:06:08 <mauke> rking: because "let" is an actual word
15:06:21 <Nereid> \ is lexed differently anyway
15:06:24 <mauke> rking: and you can still use "abcletdef" is an identifier
15:06:31 <scshunt> Nereid: you could magic the lexing for a lone lambda
15:06:32 <nand`> “let” is discriminatory against all non-English languages that use the roman alphabet. I want to name my variables ‘let’ because the word means X in language Y
15:06:43 <nand`> lexing doesn't factor into this whatsoever
15:06:47 <scshunt> Nereid: there is no technical reason
15:06:50 <nand`> it's trivial to replace \ and λ
15:07:03 <Nereid> I prefer to write my code with characters on my keyboard, thanks.
15:07:09 <nand`> it's just an ethical issue of “discriminating against greeks”, apparently
15:07:15 <rking> mauke: I'm fine with the requirement that there has to be a delimiter of some kind, probably a space.
15:07:18 <mauke> and mathematicians
15:07:21 <scshunt> Nereid: some people don't
15:07:45 <nand`> Nereid: (this all started as a hypothetical extension to -XUnicodeSyntax. It wouldn't be on by default)
15:07:53 <scshunt> yeah, not a fan of co-opting the entire letter
15:07:55 <roconnor> @quote edwardk unicode
15:07:56 <lambdabot> edwardk says: i used to be a huge proponent of unicode syntax everywhere, then i used agda ;)
15:07:57 <scshunt> just if it's lone
15:08:20 <mauke> wait, I still don't understand why people *want* to use λ instead of \
15:08:27 <Nereid> mhm
15:08:31 <nand`> same reason some people want to use -XUnicodeSyntax
15:08:32 <mauke> I understand → instead of ->
15:08:46 <mauke> I understand ⇒ instead of =>
15:09:08 <mauke> I understand ∀ instead of forall
15:09:18 <parcs`> and ∷ instead of ::
15:09:24 <n00b6502> \ jumps out as escape code in  string literals , line extention for people coming from other languages
15:09:24 <mauke> but I don't use \ as an ascii substitute for λ
15:09:36 <mauke> n00b6502: that's a feature, not a bug
15:09:38 <nand`> what about ★ instead of * ?
15:09:40 <n00b6502> its ok... but a real lambda would be better
15:09:47 <mauke> n00b6502: it's not a fake lambda
15:09:53 <n00b6502> it IS a fake lambda
15:09:57 <mauke> n00b6502: you might as well call λ a fake backspace
15:09:57 <Nereid> nand`: no, use a proper asterisk
15:10:00 <mauke> n00b6502: I disagree
15:10:03 <mauke> er
15:10:07 <mauke> fake *backslash
15:10:17 <Nereid> ∗
15:10:29 <ParahSailin> my console font does not even have ⇒ ∀ ∷ ★
15:10:39 <nand`> the only citation on this I know is that “\ kind of looks like a lambda if you squint really hard” from LYAH, but I don't know if that's canon or something the author thought up
15:10:42 <mauke> ParahSailin: DejaVu Sans Mono has all of them
15:10:53 <n00b6502> i'm sure iread somewhere it really was chosen as being the closesst approximation to lambda
15:11:04 <nand`> n00b6502: probably also in LYAH
15:11:06 <mauke> nand`: it's probably why \ was chosen historically
15:11:33 <mauke> but that doesn't mean λ is automatically better or more fundamental
15:11:36 <nand`> but that's the case for all ASCII operators; they're approximations for the mathematical symbols from theory
15:11:58 <mauke> λ was an approximation of x̂
15:12:59 <rking> Not having a way to input Unicode easily is OK. Not everyone knows about XCompose (and similar) yet.  Not having a way to view them?  That's 2005 stuff.
15:13:16 <Cale> nand`: at the very least, the idea that \ was chosen to look like lambda has been around since I started programming in Haskell in 2001 or so. I'm just trying to find a more official reference :)
15:13:18 <nand`> I don't think that's the same situation. It's not like some greeks went ahead and said ‘boy, we sure want to type X but we can't due to (voluntary) technical limitations; so we'll use λ instead!’; and even if they did, λ is still the symbol used in the lambda calculus
15:13:21 <nand`> which is what we are trying to emulate
15:13:24 <nand`> with our \ syntax
15:14:02 <mauke> nand`: the lambda calculus is a bad syntax to emulate
15:14:12 <Cale> and yeah, λ was itself originally a typographical cop-out
15:14:30 <nand`> that's an entirely different point imo; many mathematical syntaxen are bad - but we stick to them out of convention
15:14:30 <Cale> (in the context of the lambda calculus)
15:14:40 <n00b6502> anonymous-function-calculus
15:14:41 <mauke> the printer simply couldn't handle church's awesome notation
15:14:51 <nand`> Cale: that sounds interesting; what λ originally supposed to represent?
15:15:01 <mauke> hats on variables
15:15:03 <Cale> nand`: A hat overtop the following letter
15:15:11 <mauke> like my x̂ example
15:15:11 <nand`> ah
15:15:17 <nand`> and the name ‘lambda calculus’ came afterwards?
15:15:21 <Cale> yeah
15:15:29 <nand`> mauke: I don't see a hat on your ‘x’. This caused some confusion
15:15:54 <mauke> nand`: your environment is insufficiently unicode aware
15:15:58 <Cale> The usual modern mathematical syntax for functions is to use an arrow like |---->
15:16:10 <Cale> which exists (at least twice) in unicode...
15:16:22 <Cale> ↦
15:16:26 <mauke> http://mauke.hopto.org/stuff/javascript/unicode.html?q=x%CC%82
15:16:45 <nand`> I see the ^ after the x there
15:16:48 <nand`> unfortunately
15:16:52 <roconnor> mauke:http://math.stackexchange.com/questions/64468/why-is-lambda-calculus-named-after-that-specific-greek-letter-why-not-rho-calc
15:16:53 <mauke> ⟼
15:16:59 <Cale> ⟼
15:17:13 <Cale> (might look the same here)
15:17:32 <n00b6502> |->
15:17:46 <nand`> roconnor: that seems fairly conclusive
15:17:47 <n00b6502> heh at least that isn't "pointer dereference"
15:18:23 <EvanR> (->) :: Ptr a -> (a -> b) -> IO b
15:18:48 <EvanR> well im misremembering C at the moment
15:19:04 * nand` .oO( Ptr a -> Lens a b c d -> IO c )
15:19:07 <Peaker> EvanR, that's such a silly operator in C, due to dereference mistakenly being prefix rather than postfix
15:19:10 <n00b6502> haha can you actually implement a -> pointer dereference in haskell ?
15:19:19 <mauke> ẑ.z+1
15:19:27 <nand`> mauke: I see that correctly
15:19:29 <Cale> n00b6502: yes, apart from the fact that -> is special syntax and taken
15:19:33 <EvanR> "Thinking of Maud you forget everything else."
15:19:34 <mauke> nand`: but not ẑ
15:19:34 <Peaker> n00b6502, yeah, the FFI lets you deal directly with ptrs/etc
15:19:46 <nand`> mauke: I see that as “but not z”
15:19:48 <n00b6502> i suppose you could use *.
15:20:01 <n00b6502> or *->
15:20:04 <EvanR> * is taken by a library
15:20:10 <EvanR> :t (*)
15:20:12 <lambdabot> forall a. (Num a) => a -> a -> a
15:20:21 <mauke> nand`: ẑ is "z with circumflex", ẑ is "z" + "combining circumflex accent"
15:20:27 <n00b6502> can you not use * in multi character operators then :(
15:20:28 <nand`> there are other syntaxen for pointer dereferencing, eg. ^
15:20:30 <mauke> nand`: and apparently you can't see combining characters
15:20:31 <geekosaur> there's always pascal's ^.
15:20:32 <nand`> x^.foo
15:20:36 <EvanR> :t (**)
15:20:38 <Cale> n00b6502: you can
15:20:38 <lambdabot> forall a. (Floating a) => a -> a -> a
15:20:41 <EvanR> :t (***)
15:20:43 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
15:20:45 <EvanR> :t (****)
15:20:46 <Cale> *-> you can use
15:20:47 <lambdabot> Not in scope: `****'
15:20:48 <n00b6502> ^ is xor to me
15:20:57 <EvanR> > 2^9
15:20:58 <Cale> > let x *-> y = x + y in 5 *-> 7
15:20:59 <lambdabot>   512
15:20:59 <lambdabot>   can't find file: L.hs
15:21:04 <Cale> oops
15:21:05 <Cale> > let x *-> y = x + y in 5 *-> 7
15:21:06 <lambdabot>   12
15:21:15 <nand`> mauke: I don't know where the problem lies, but it's probably either the terminal or the font
15:21:22 <mauke> nand`: éé  áá  çç  ññ
15:21:31 <mauke> should be all identical pairs
15:21:49 <geekosaur> there are slight differences here
15:21:57 <mauke> ok, that's to be expected
15:21:58 <nand`> I see the first two the same; but all others have the second element without accents
15:21:58 <Cale> n00b6502: In Haskell, ^ is exponentiation (to non-negative integral exponents).
15:22:19 <mauke> nand`: yeah, the first two were literally the same codepoint
15:22:20 <n00b6502> ok
15:22:52 <nand`> :t (*~)
15:22:54 <lambdabot> Not in scope: `*~'
15:22:59 <nand`> Cale: go install lens on lambdabot :(
15:23:07 <n00b6502> is there a xor :: a -> a -> a  ... and it there a typeclass for integers
15:23:14 <Cale> :t xor
15:23:16 <lambdabot> forall a. (Bits a) => a -> a -> a
15:23:16 <nand`> :t xor
15:23:18 <lambdabot> forall a. (Bits a) => a -> a -> a
15:23:19 <Nereid> lol
15:23:29 <Nereid> @hoogle xor
15:23:29 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
15:23:30 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Xor :: LogicOp
15:23:30 <lambdabot> package xorshift
15:23:42 <Cale> If you want the xor operation on Bool though, it's easier just to use /=
15:24:07 <Nereid> clever
15:24:20 <mauke> I'mma define a Bits Bool instance, B style
15:24:32 <n00b6502> what do i import to get bitwise xor, shifts, or, and etc
15:24:33 <Cale> > xor True False
15:24:35 <lambdabot>   No instance for (Data.Bits.Bits GHC.Bool.Bool)
15:24:35 <lambdabot>    arising from a use of `Da...
15:24:36 <nand`> hardly, that's one possible way of defining xor in general: “a xor b is 1 if a and b are different”
15:24:37 <Cale> lol
15:24:44 <nand`> n00b6502: Data.Bits
15:25:12 <n00b6502> ok
15:25:34 <n00b6502> hah shift. nice
15:25:45 <nand`> > 3 `shiftL` 2
15:25:47 <lambdabot>   Ambiguous type variable `a' in the constraint:
15:25:47 <lambdabot>    `Data.Bits.Bits a'
15:25:47 <lambdabot>      a...
15:25:53 <nand`> > 3 `shiftL` 2 :: Word32
15:25:55 <lambdabot>   12
15:26:14 <n00b6502> here's me still wanting to call is ASL LSL LSL LSR etc
15:26:27 <nand`> > 3 `shiftL` 2000 :: Integer
15:26:27 <n00b6502> but i can live with SHIFT
15:26:28 <lambdabot>   344439208582276357269849960353304595206695310626608560143292821047729878417...
15:26:34 <Nereid> why isn't there a Bits instance for Bool?
15:26:47 <n00b6502> woohoo bitwise arithmetic. now i'm happy
15:26:49 <mauke> Nereid: how do you shift bools?
15:26:51 <nand`> probably because it isn't very useful
15:27:01 <Nereid> mauke: same way you shift n-bit integers, except n = 1
15:27:03 <nand`> mauke: same way you shift 8-vectors of bits; except for a 1-vector
15:27:05 <nand`> .. :(
15:27:06 <Nereid> so it's trivial
15:27:10 <mauke> Nereid: sounds useless
15:27:12 <Nereid> it is
15:27:13 <nand`> exactly
15:27:16 <Nereid> why would you shift bools
15:27:23 <n00b6502> does haskell have literal hexidecimal ?
15:27:27 <nand`> why would you .&. .|. etc. bools either? you have && ||
15:27:32 <mauke> > 0x00b6502
15:27:32 <Cale> > 0xdeadbeef
15:27:33 <geekosaur> > 0x5
15:27:35 <lambdabot>   3735928559
15:27:35 <lambdabot>   can't find file: L.hs
15:27:35 <lambdabot>   can't find file: L.hs
15:27:36 <Cale> lol
15:27:37 <geekosaur> heh
15:27:48 <Cale> I wonder what caused it to start having that race condition
15:27:48 <Nereid> what
15:27:55 <Cale> It never used to do that
15:28:17 <Nereid> nand`: polymorphism I guess
15:28:27 <nand`> have you checked to see whether L.hs is actually getting deleted / recreated on a race condition? or if the “can't find file” error is, well, erroneous (and it's actually locked or something)
15:28:37 <Cale> I haven't looked into why that happens at all
15:28:48 <nand`> on an evaluation*
15:30:01 <fmap> Nereid: Bits requires Num, you probably don't want Bools be Nums
15:30:15 <Nereid> why not?
15:30:25 <mauke> > -True
15:30:27 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
15:30:27 <lambdabot>    arising from a use of syntac...
15:30:32 <Nereid> Bool deserves to be a Num just as much as Word8 does.
15:30:40 <Nereid> since it's basically Word1.
15:30:52 <mauke> except it isn't
15:30:57 <mauke> names matter
15:31:03 <SegFault1X|work2> So I'm trying to wrap my head around the S-K basis. It seems trivial to convert I and K to to lambdas (eg \x -> x and \x -> \y -> x, respectively) but I can't figure out based on the Wikipedia definiton how to translate S to a lambda.
15:31:14 <mauke> haha, what
15:31:17 <fmap> well, `if 3 then … else …' become possible, for example
15:31:25 <mauke> SegFault1X|work2: \f -> \g -> \x -> f x (g x)
15:31:37 <Nereid> SegFault1X|work2: s = ap
15:31:40 <Nereid> yeah
15:31:42 <SegFault1X|work2> mauke: Please hold while I try and process that.
15:32:00 <Nereid> @type s where s f g x = f x (g x)
15:32:02 <lambdabot> parse error on input `where'
15:32:06 <nand`> O.o; it's written right there on the english wikipedia
15:32:11 <SegFault1X|work2> mauke: Ohh, duh.
15:32:12 <Nereid> @type \f g x -> f x (g x)
15:32:14 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
15:32:17 <nand`> from https://en.wikipedia.org/wiki/SKI_combinator_calculus Sxyz = xz(yz)
15:32:19 <Nereid> mm.
15:32:36 <SegFault1X|work2> nand`: Is it, I must have missed it. :)
15:33:03 <nand`> there are some examples on https://en.wikipedia.org/wiki/Combinatory_logic#Combinatory_calculi too
15:33:15 <nand`> (S x y z) = (x z (y z))
15:33:29 <SegFault1X|work2> nand`: Yea, that line for some reason wasn't making sense to me.
15:33:33 <nand`> which is verbatim valid haskell except for the S/s
15:33:36 <Nereid> @type ap const const
15:33:38 <lambdabot> forall b. b -> b
15:34:01 <mauke> :t (<*>) pure pure
15:34:03 <lambdabot>     Ambiguous type variable `f' in the constraint:
15:34:03 <lambdabot>       `Applicative f'
15:34:03 <lambdabot>         arising from a use of `pure' at <interactive>:1:11-14
15:34:47 <Nereid> @type ap return return
15:34:48 <lambdabot>     Ambiguous type variable `m' in the constraint:
15:34:49 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:10-15
15:34:49 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
15:34:51 <Nereid> mhm
15:35:01 <nand`> @type ap return ()
15:35:03 <lambdabot>     Couldn't match expected type `b -> a' against inferred type `()'
15:35:03 <lambdabot>     In the second argument of `ap', namely `()'
15:35:03 <lambdabot>     In the expression: ap return ()
15:35:08 <nand`> err
15:35:13 <nand`> @type ap return id
15:35:15 <lambdabot> forall b. b -> b
15:35:40 <mauke> :t let id = ap return id in id
15:35:42 <lambdabot> forall b. b -> b
15:35:49 <mauke> gentlemen
15:35:53 <nand`> :)
15:36:07 <nand`> > fix (ap pure)
15:36:08 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> b)
15:36:09 <lambdabot>    arising from a use of `...
15:36:13 <nand`> :t fix (ap pure)
15:36:15 <lambdabot> forall b. b -> b
15:36:16 <Nereid> > let id = ap return id in id 5
15:36:18 <lambdabot>   5
15:36:20 <mauke> :t fmap fix return
15:36:22 <lambdabot> forall a. a -> a
15:36:46 <d-old> wow I'm having a really shitty experience installing yesod
15:37:42 <luite> d-old: can you hpaste the error?
15:37:57 <shapr> d-old: yesod is awesome once it does get installed!
15:37:59 <nand`> :t let k = pure `asTypeOf` const in k <*> k
15:38:00 <lambdabot> forall b. b -> b
15:38:28 <d-old> luite: the regular wanted Some.Type  got Some.Type-1.2.3
15:38:43 <d-old> I'm installing yesod + dependencies for the third time now
15:39:34 <shapr> d-old: Are you using cabal install?
15:39:37 <luite> d-old: it can help if you install yesod-platform instead of the yesod package
15:43:42 <d-old> hmm perhaps I messed up there
15:44:01 <d-old> for some reason my haskell bin's weren't in my path
15:44:06 <d-old> so I experimented a bit with installs
15:44:30 <luite> ah right, i think you need happy for one of the dependencies
15:53:26 <P_K_Rao> hi there.. are there any free video tutorials for haskell?
15:53:58 * morel doesn't know of one
15:54:13 <hpc> there's probably at least one, but i don't know of any
15:54:29 <hpc> it probably wouldn't even remotely compare with LYAH, anyway
15:54:45 <gertc> if msg is lazy text wich Attoparsec parse and Aeson json do i need to use?
15:55:35 <morel> P_K_Rao: did you look at youtube? i just found a tutorial by simply searching... http://www.youtube.com/watch?v=BQQ2VnZkj7k
15:56:12 <morel> P_K_Rao: you can find all of the 5 videos of that series at http://www.youtube.com/user/pthariensflame/videos
15:56:30 <roconnor> @src <**>
15:56:31 <lambdabot> (<**>) = liftA2 (flip ($))
15:56:37 <Botje> P_K_Rao: there's the haskell live series.
15:56:54 <Botje> P_K_Rao: but videos are not a very good way to learn about programming languages.
15:57:08 <morel> +1
15:57:22 <Botje> since the authors have to choose between explaining _everything_ or taking shortcuts and saying "we'll come back to this later"
15:57:33 <Botje> P_K_Rao: why not try the excellent free online books?
15:57:43 <P_K_Rao> morel: thanks.. i had a look at those. but that does not cover a lot of ground..
15:57:49 <gertc> parse seem to expect a text but json is for bytestring? let v = parse json msg
15:58:19 <P_K_Rao> Botje: yes.. i will try the LYAH for sure.. thanks to hpc too.
15:58:46 <morel> P_K_Rao: there's a really nice to read book called "Learn you a Haskell for Great Good" for free online. it's even readable for those who don't like reading, like me for example.
15:59:08 <morel> @where lyah -- P_K_Rao, here you can find the book
15:59:09 <lambdabot> http://www.learnyouahaskell.com/
16:00:06 <morel> oh, erm. didn't read the last message of P_K_Rao =) heh :)
16:01:28 <P_K_Rao> i am currently using 'Real World Haskell' book..
16:01:43 <morel> oh, yeah, that one is good, too.
16:01:54 <P_K_Rao> am not sure if i fully understood why Algebraic Data Types are called so..
16:02:11 <roconnor> grr, the wrong applicative instance for KleeneStore isn't structurely recursive, while the "backwards" impelmentation is.
16:02:12 <morel> yeah, LYAH is more for beginners
16:02:24 <hpc> P_K_Rao: because it encodes sum types and product types
16:02:31 <hpc> which roughly correspond to (+) and (*)
16:02:43 <hpc> sum type: data Either a b = Left a | Right b
16:02:49 <hpc> product type: data (a, b) = (a, b)
16:03:00 <gertc> anybody have time to help me with a `instance FromJSON` example?
16:03:14 <hpc> and if you squint hard enough, they follow algebraic laws
16:03:54 <shapr> gertc: import Data.Aeson.TH $(derive id ''MyType)
16:04:27 <Saizan> roconnor: and that's upsetting?
16:05:00 <hpaste> “Splinter of Chaos” pasted “Draw Circle” at http://hpaste.org/73296
16:05:00 <gertc> shapr: thats cheating i want to learn how the boiler code looks like :)
16:05:04 <shapr> ah!
16:05:30 <shapr> gertc: In that case, have fun :-) I wrote my own toJSON once, and that was enough for me.
16:06:14 <gertc> shapr, will you take a quick look at my paste?
16:06:19 <P_K_Rao> hpc: thanks
16:06:31 <shapr> gertc: Sadly I'm busy at the moment, big deadline on Monady
16:06:45 <shapr> Monday*
16:06:55 <gertc> shapr, np thanks next time maybe
16:06:59 <shapr> sure :-)
16:08:18 <Saizan> gertc: you can -ddump-splices to look at the code
16:10:13 <d-old> ooh it's running migrations
16:11:11 <luite> gertc: where's the paste?
16:11:42 <gertc> luite, do you prefer paste or stackover
16:12:01 <copumpkin> @ask edwardk did you figure it all out? can I use it yet?!?
16:12:02 <lambdabot> Consider it noted.
16:13:12 <luite> gertc: hpaste is ok
16:14:28 <hpaste> gertc pasted “fromJSON” at http://hpaste.org/73297
16:14:28 <SegFault1X|work2> How hard would it be to create a basic pattern matching program in Haskell?
16:14:44 <SegFault1X|work2> Grep-lite, if you will.
16:14:56 <Cale> SegFault1X|work2: not hard?
16:15:25 <gertc> luite, i can reduce it to something smaler if it does not make sense
16:15:29 <SegFault1X|work2> Cale: If I wanted to do such a thing, where should I start?
16:16:50 <luite> gertc: oh that's a package problem
16:17:00 <luite> no wait
16:17:06 <luite> sorry brb
16:19:05 <Cale> SegFaultAX|work2: Well, depends on how much of that you want to implement by hand.
16:19:25 <Cale> SegFaultAX|work2: I'd probably start with the representation of an NFA or something if I was doing it for fun :)
16:19:59 <luite> gertc: right an aeson parser parses a ByteString, not a Text
16:20:48 <gertc> is there a Text version?
16:20:52 <Cale> SegFaultAX|work2: http://cale.yi.org/share/Regular.hs is my little implementation of NFA construction from abstract regular expressions.
16:21:23 <luite> gertc: hm, don't think there is one, but you can use (encodeUtf8 msg) instead of msg
16:21:31 <Cale> (and there's a bunch of unnecessary code in there dealing with comparing languages and differentiation of regular expressions)
16:21:32 <luite> from Data.Text.Encoding
16:22:07 <gertc> luite, i tried that but then i get \just a sec\
16:23:18 <Cale> (but differentiation for NFAs is important, as it's the only way to input a string :)
16:24:22 <luite> gertc: oh you need the Data.Text.Lazy.Encoding one here
16:25:09 <hpaste> gertc annotated “fromJSON” with “fromJSON (annotation)” at http://hpaste.org/73297#a73298
16:25:44 <gertc> import Data.Text.Lazy.Encoding (decodeUtf8,encodeUtf8)
16:26:02 <gertc> same error?
16:27:29 <gertc> its like there is only one json version but parse does not want to try bytestings
16:27:43 <gertc> maybe i need other parse?
16:28:48 <luite> gertc: you can use decode (encodeUtf8 msg)
16:28:59 <luite> from Data.Aeson
16:29:05 <luite> with a Maybe User result
16:31:05 <gertc> Data.Aeson.decode /just a sec/
16:33:18 <hpaste> gertc annotated “fromJSON” with “fromJSON (annotation)” at http://hpaste.org/73297#a73299
16:33:44 <gertc> still does not want to sorry :(
16:35:35 <gertc> let v = parse json (Data.Aeson.encode msg)
16:35:40 <gertc> also the same
16:35:44 <gertc> error
16:38:59 <copumpkin> fucked-up hack of the day: https://gist.github.com/3356675?utm_source=rubyweekly&utm_medium=email
16:42:29 <luite> gertc: this is what i meant: user msg = fromMaybe (error "invalid user json") (decode $ encodeUtf8 msg)
16:42:36 <jfischoff> copumpkin: :o
16:43:12 <gertc> luite, testing /just a sec/
16:51:43 <gertc> luite, user msg = fromMaybe (error "invalid user json") (decode $ encodeUtf8 msg)
16:52:09 <gertc> works but does it do teh same as parse? i am confused :)
16:54:34 <gertc> so i do not need import Data.Attoparsec.Text.Lazy also to do fromJSON?
16:55:54 <hpaste> gertc annotated “fromJSON” with “fromJSON (annotation)” at http://hpaste.org/73297#a73300
16:57:49 <luite> gertc: it parses the json to a Value and then runs your FromJSON parser for the type
16:58:04 <gertc> so thats it i just do this and its the same as using the parse stuff?
16:58:31 <luite> yeah it's a combination of parse and parseJSON
16:59:20 <gertc> ok looks less complicated :)
16:59:53 <gertc> thanks, i can go sleep now :)
17:07:48 <mebaran151> so I'm trying to interface with a REST API that uses an authentication token; what is the best way to structure this in factor
17:26:55 <shapr>  mebaran151: As in, factor the language?
17:30:25 * ddarius hasn't seen slava here in a while.
17:31:09 <shapr> ddarius: Nor have I
17:32:22 <MostAwesomeDude> I hear that it's largely dead upstream. :c
17:32:24 <MostAwesomeDude> I liked Factor.
17:34:25 <ddarius> Factor was a fairly good language in the Forth/Joy/Postscript area.
17:35:58 <zzing> I am trying to install cabal-install 0.17.0 and it says at least the following dependencies are missing: Cabal >=1.17.0 && <1.18   yet I have Cabal-1.17.0 installed according ghc-pkg list. What could cause this?
17:36:31 <MostAwesomeDude> It's too bad that Factor's not suitable for taking over the world. :c
17:36:36 <MostAwesomeDude> I'm banking on Haskell.
17:36:37 <Philippa_> ddarius: hell, don't think I'd noticed you talking for a while, but to be fair I've not been paying attention enough
17:37:03 <hpc> whoa, it's Philippa_
17:37:31 <zzing> MostAwesomeDude: It is likely to be the languages that come out of Haskell because haskell has no problem dropping features and changing
17:37:47 <MostAwesomeDude> zzing: Well, I've been thinking about this for a while.
17:37:55 <Philippa_> 'lo hpc
17:38:04 <MostAwesomeDude> So, we all use ctypes, right? 'Cause C is the language of the full stack, kernel to high-level userland.
17:38:08 <MostAwesomeDude> But what if it were something else?
17:38:34 <Philippa_> MostAwesomeDude: you end up being stuck with a ctypes-like layer and then getting into bitching contests about what to layer on top
17:38:48 <ddarius> MostAwesomeDude: It has been other things at other times, albeit not so universally.
17:38:49 <zzing> MostAwesomeDude: less philosophy, more eyes open! :P
17:40:28 <MostAwesomeDude> zzing: Fine, the practical side: Everybody uses C and you're gonna have to displace it with something universally compelling on all fronts, probably with a change of architecture.
17:41:01 <zzing> MostAwesomeDude: I look towards Idris in hope
17:41:11 <Philippa_> why replace it when you can embed and thus absorb it?
17:41:58 <ddarius> MostAwesomeDude: Good luck.
17:42:27 <ddarius> Personally, I think a nuclear holocaust would hasten your goal.
17:42:43 <MostAwesomeDude> zzing: http://en.wikipedia.org/wiki/Idris_(operating_system) ?
17:42:58 <Jafet> Clearly we should pre-emptively write a haskell environment for larrabee.
17:43:07 <zzing> MostAwesomeDude: The language
17:43:15 <zzing> http://idris-lang.org/
17:43:48 <MostAwesomeDude> Hmm.
17:44:15 <zzing> I suspect dependent types to be a possible improvement on haskell
17:46:27 <MostAwesomeDude> I don't grok dependent types. Or maybe I just haven't seem them used right; I seem to only see them used to make lists of guaranteed length.
17:47:01 <Philippa_> mmm. When you see them used to make a regex matcher that's definitely a regex matcher, that's a little different?
17:49:18 <MostAwesomeDude> A little.
17:51:51 <Philippa_> MostAwesomeDude: so what'd feel like "right" for you?
17:54:08 <MostAwesomeDude> Philippa_: Well, I mean, like any other language feature, hopefully it enables something really compelling that separates it from other languages.
17:55:02 <Jafet> Except from the languages that already have dependent typing
17:55:24 <MostAwesomeDude> Sure.
17:55:25 <Philippa_> sure. But basically, it sounds like you don't find being able to prove your code does what you claim it does compelling, regardless of the scale it's done on?
17:56:19 <Philippa_> or to put it another way: you're happy knowing you can always be lied to?
17:57:08 <MostAwesomeDude> Well, I find that to be (a) not something you need dependent types for (b) not something you do for most code, in practice (c) something I do daily in Python.
17:57:23 <Jafet> There are lies, damn lies, unit tests, and proofs
17:58:08 <Philippa_> yeah, quite. There's a lot of stuff you really can't do with testing, and I'd like to know how else you're "proving" anything in Python
17:59:09 <Philippa_> I mean sure, you can prove stuff in Haskell, it's just that you can fix anything
17:59:26 <Philippa_> and as for b) - do you want that to remain the status quo for much-used library code?
17:59:32 <Philippa_> 'cos I don't
17:59:43 <MostAwesomeDude> Have you *seen* PHP?
17:59:52 <Philippa_> hell, I've shat some out
18:00:03 <Philippa_> not that I actually knew the language, you understand
18:00:18 <MostAwesomeDude> *That* is the status quo.
18:00:44 <Philippa_> yes, and?
18:00:46 <MostAwesomeDude> I think that just about anything a denizen of this channel would write would be an improvement.\
18:01:10 <Philippa_> so?
18:01:24 <Philippa_> that's not a good reason for avoiding further potential for improvement
18:01:44 <MostAwesomeDude> Okay, so you seem to think that I'm anti-dependent types. I'm not. I just don't understand how I could be using them.
18:01:47 <Jafet> I write terrible haskell programs
18:02:55 <Philippa_> MostAwesomeDude: you use this library and its type tells you that it does what it says on the tin. It can be that simple
18:03:36 <Philippa_> only then, you notice that you've got some invariants you're trying to maintain and you might find that they're easier - or possible where it'd be impossible - to encode in the type system than they would be in Haskell
18:03:53 <Philippa_> same as any other type system feature, IOW
18:04:28 <MostAwesomeDude> Okay. So why Idris?
18:04:44 <Philippa_> I imagine it got linked because it's actively aiming at systems programming
18:05:02 <Philippa_> which isn't to say that it's ready to replace C right now
18:05:09 <MostAwesomeDude> Ah.
18:06:42 <zzing_> What version of cabal-install works with ghc 7.6?
18:07:29 <dolio> I don't think Idris is aimed at systems programming.
18:07:30 <Jafet> I would just kick cabal-install.cabal.
18:10:03 <Philippa_> dolio: well, either my memory's playing tricks or I've seen/heard edwinb say as much
18:10:16 <Philippa_> as I said, that doesn't mean it's /ready/ yet
18:11:28 <lazard> what's the status of Trellys?
18:12:56 <Saizan> unimplemented yet i'm told
18:13:29 <zzing_> hmm, when building the cabal-install dependencies it said /usr/bin/ld: cannot find -liconv  but iconv is under /usr/local/lib.
18:13:59 <dolio> I think ccasin said he's presenting his thesis on it soon, though.
18:14:13 <geekosaur> --extra-lib-dir=/usr/local/lib ?
18:24:33 * hackagebot listlike-instances 0.2.2 - Extra instances of the ListLike class (JohnLato)
18:31:01 <MostAwesomeDude> Philippa_, zzing_ : Yeah, okay, Idris is pretty sweet.
18:35:45 <JunkBee> I cannot make function :: IO String -> String
18:35:46 <JunkBee> ?
18:36:03 <MostAwesomeDude> JunkBee: Well, not safely. What are you wanting to do?
18:36:12 <Philippa_> nope. But you have one of type IO String -> (String -> IO b) -> IO b
18:36:25 <Philippa_> so you can't return it from the IO monad, but you can pass it into another computation
18:36:33 <JunkBee> I wanted to have an impure function read in a file into a list, then I wanted to just give my list to pure functions to work on
18:36:39 <Philippa_> the IO monad might be 'inside' haskell, but it's the outside of the program
18:36:56 <ion> junkbee: pureFunction <$> readFile "foo"
18:36:58 <otters> fmap my_pure_function (get_file)
18:37:05 <otters> oh yeah, camelcase
18:37:08 <otters> I've been writing Ruby all day
18:37:19 <Philippa_> do f <- readFile "foo"; return (pureFunction f)
18:37:26 <Philippa_> (but <$> is nicer)
18:37:42 <JunkBee> ion: The return type of my pureFunction will have to be IO a?
18:37:43 <otters> yeah, that's just readFile "foo" >>= return . pureFunction
18:37:50 <JunkBee> were a is what the function originally returned?
18:37:50 <otters> JunkBee: no, it can be a
18:37:56 <Philippa_> otterdam: enough with the pointlessness!
18:37:57 <otters> :t fmap -- JunkBee
18:37:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:37:59 <Philippa_> otters, even
18:38:17 <Philippa_> JunkBee: no, but the type of your main function will
18:38:20 <otters> IO is a Functor, so you can give a function String -> b to fmap and apply it to an IO action IO a
18:38:24 <otters> or rather IO String
18:38:30 <otters> not keeping track of my own example
18:39:37 <JunkBee> :t [readFile]
18:39:39 <lambdabot> [FilePath -> IO String]
18:40:32 <Philippa_> JunkBee: do you want mapM readFile ["foo.txt", "bar.txt"] ?
18:41:36 <JunkBee> Philippa_: no I want to take my IO String and run regex on it
18:41:45 <JunkBee> but PRCE needs String's
18:41:54 <Philippa_> right, you've been shown how to do that above
18:42:20 <Philippa_> PCRE might need strings, but your main function is still going to have an IO type
18:42:25 <Philippa_> IO calls pure, not the other way round
18:43:09 <zzing_> JunkBee, gutan tag
18:43:17 <JunkBee> zzing_: hallo
18:43:57 <zzing_> Verstehst du, was ich sage?
18:44:15 <JunkBee> Philippa_: I will investigate this soon, I was trying it earlier today with no success and got head ache :/
18:44:39 <Philippa_> JunkBee: take one of the examples above, use it as main and put your PCRE all in place of pureFunction
18:44:47 <Philippa_> PCRE call, even
18:45:07 <frio> ive still not got this straight in my head
18:45:11 <Philippa_> you might find the do notation one easiest, it works better if pureFunction wants more than one parameter
18:45:19 <frio> but it's worth appreciating that given that lists, IO etc. are all monads
18:45:24 <JunkBee> zzing_: nicht wirklich
18:45:28 <frio> mapM is entirely analogous to map
18:45:42 <frio> but i believe map doesn't work on monads due to historical reasons?
18:45:43 <zzing_> :-)
18:45:56 <frio> understanding that really helped me with IO stuff :)
18:46:31 <JunkBee> Philippa_: ah k. I will review my functions when I open my laptop.
18:46:32 <frio> (and made me feel more comfortable using fmap/mapM, without the fear of impurifying my pure code)
18:53:08 <Jafet> Sprechen Sie bitte a real language
18:58:30 <ezyang> Rawr, it works with runghc but not with ghc --make
19:00:51 <shachaf> What does?
19:26:41 <shachaf> Given q :: (a -> b -> c) -> (r -> a) -> (r -> b) -> r -> c, and k :: a -> b -> a, can you make id?
19:31:19 <otters> :t (..)
19:31:21 <lambdabot> parse error on input `..'
19:34:35 * hackagebot xattr 0.6.1 - Haskell extended file attributes interface (DeianStefan)
19:34:37 * hackagebot lio 0.9.0.0 - Labeled IO Information Flow Control Library (DeianStefan)
19:47:18 <mm_freak> i think that (&&&) belongs into Control.Applicative
19:47:25 <mm_freak> it's equivalent to liftA2 (,)
19:47:42 <mm_freak> and often easier to write
19:48:02 <donri> but it's generalized to arrows?
19:48:12 <mm_freak> arrows aren't more general
19:48:44 <mm_freak> if something is an Arrow, you can also make it Applicative…  then (&&&) is the same as liftA2 (,)
19:48:56 <donri> true
19:49:16 <donri> (there should be such an arrow in base though, maybe?)
19:49:35 * hackagebot persistent-mysql 1.0.1 - Backend for the persistent library using MySQL database server. (FelipeLessa)
19:49:37 * hackagebot dclabel 0.9.0.0 - This packge is deprecated. See the the "LIO.DCLabel" in the "lio" package. (DeianStefan)
19:49:57 <donri> can you make any applicative an arrow too? i know at least some can be
19:50:55 <mm_freak> donri: yes
19:51:23 <mm_freak> and then liftA2 (,) is the same as (&&&) =)
19:51:54 <donri> e.g. http://hackage.haskell.org/packages/archive/optparse-applicative/0.4.0/doc/html/Options-Applicative-Arrows.html and it does look generalized to any applicative
19:53:20 <donri> of course "A" doesn't work as a name if we're to have both :p
19:56:17 <mm_freak> my point was that (&&&) somehow has the wrong type =)
19:56:34 <mm_freak> (&&&) :: (Applicative f) => f a -> f b -> f (a, b)
19:56:51 <mm_freak> it's really just an applicative 'zip'
19:57:29 <donri> yea i tend to find myself using (&&&) when i consider using (,) <$> <*>
19:57:52 <mm_freak> i seldomly use (<$>) and (<*>)
19:57:56 <mm_freak> mostly i use liftA*
19:58:11 <nand`> I use <$> for fmap on occasion
19:58:19 <nand`> but liftA* lends itself much better to point-free coding
19:58:25 <mm_freak> > liftA2 (,) sin cos 3
19:58:27 <lambdabot>   (0.1411200080598672,-0.9899924966004454)
19:58:31 <mm_freak> > (sin &&& cos) 3
19:58:33 <lambdabot>   (0.1411200080598672,-0.9899924966004454)
20:01:26 <nand`> instance Arrow a => Applicative (a b) where pure = arr . const; a <*> b = a &&& b >>> arr (uncurry id) -- ?
20:01:45 <donri> > (,) <$> sin <*> cos $ 3
20:01:46 <lambdabot>   (0.1411200080598672,-0.9899924966004454)
20:02:01 <mm_freak> i'd rather implement Arrow in terms of Applicative
20:02:37 <mm_freak> and Category
20:03:10 <donri> does that work, without wrapper types?
20:03:16 <mm_freak> yeah
20:05:18 <mm_freak> arr f = fmap f id; first c = liftA2 (,) (c . fmap fst id) (fmap snd id)
20:05:31 <donri> so you can make an applicative an arrow, at the same time and without wrappers?
20:05:41 <donri> why does optparse-applicative provide "A" then
20:06:13 <mm_freak> i don't know it
20:06:32 <nand`> is this the ‘id’ from Category?
20:06:36 <mm_freak> yeah
20:06:44 <mm_freak> using Profunctor you can even express this much nicer
20:07:08 <donri> pcapriot`: why!
20:07:20 <mm_freak> arr f = fmap f id; first c = liftA2 (,) (lmap fst c) (fmap snd id)
20:07:21 <nand`> hrm, how is Cat.id implemented in terms of Applicative (f a) ?
20:07:24 <mm_freak> well, not /much/ nicer
20:07:28 <mm_freak> but somewhat nicer =)
20:07:42 <mm_freak> nand`: you can't implement 'id' in terms of Applicative
20:07:49 <mm_freak> you can implement Arrow in terms of Category and Applicative
20:07:55 <nand`> oh
20:08:11 <nand`> I interpreted ‘and Category’ on the wrong side, it seems
20:20:11 <JoeyA> Are 'succ' and 'prec' required to fail if the result is out of bounds?
20:20:17 <JoeyA> e.g. newtype Even = Even Int
20:20:43 <mauke> how can it be out of bounds?
20:20:47 <JoeyA> toEnum n | even n = Even n | otherwise = error "toEnum: not even"
20:21:02 <JoeyA> succ would return n+1.  Of course, for Even, that always fails.
20:21:04 <mauke> toEnum n | even n = Even (n `div` 2)
20:21:06 <nand`> “The calls succ maxBound and pred minBound should result in a runtime error.”
20:21:15 <mauke> I represent 2*n as n
20:21:18 <nand`> “fromEnum and toEnum should give a runtime error if the result value is not representable in the result type.”
20:21:21 <JoeyA> Right, but what if the range is sparse?
20:21:33 <mauke> then maybe you're not an Enum
20:21:34 <JoeyA> Meh, I guess my range isn't sparse.
20:21:44 <JoeyA> (SQLite parameter indices)
20:21:51 <nand`> but fwiw what mauke said
20:22:21 <nand`> actually, the other way round
20:22:26 <nand`> toEnum n = Even (n * 2)
20:22:47 <JoeyA> Is the minimal complete definition just 'toEnum' and 'fromEnum' ?
20:22:53 <JoeyA> Looks like it in the source.
20:23:50 <nand`> toEnum/fromEnum is supposed to map between your enum type and some range of naturals
20:24:15 <nand`> integers, actually
20:26:49 <JoeyA> Thanks
20:29:10 <nand`> though I would still implement succ/pred/enumFrom etc. manually
20:29:12 <nand`> in your case
20:34:36 * hackagebot skein 0.1.0.8 - Skein, a family of cryptographic hash functions. Includes Skein-MAC as well. (FelipeLessa)
20:50:00 <johnw> does Applicative have a composition operator?
20:50:59 <johnw> pure (.)?
20:51:26 <Saizan> ?type liftA2 (.) -- ?
20:51:27 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Applicative f1) => f1 (a -> b) -> f1 (f a) -> f1 (f b)
20:51:43 <johnw> pure (.) <*> liftA (+1) <*> liftA (+2) <*> [3]
20:51:45 <johnw> > pure (.) <*> liftA (+1) <*> liftA (+2) <*> [3]
20:51:47 <lambdabot>   Couldn't match expected type `(a -> a) -> a'
20:51:47 <lambdabot>         against inferred type ...
20:51:54 <Saizan> ?type liftA2 (Prelude..)
20:51:56 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
20:52:09 <johnw> oh
20:52:47 <slack1256> > pure (.) <*> liftA (+1) <*> liftA (+2) <*> [3] $ 5
20:52:49 <lambdabot>   Couldn't match expected type `(a -> a) -> a'
20:52:49 <lambdabot>         against inferred type ...
20:53:05 <slack1256> > pure (.) <*> liftA (+1) <*> liftA (+2) <*> 3
20:53:06 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a) -> a)
20:53:07 <lambdabot>    arising from a u...
20:53:22 <Saizan> > pure (.) <*> pure (+1) <*> pure (+2) <*> [3]
20:53:25 <lambdabot>   [6]
20:53:32 <johnw> haha
20:53:58 <slack1256> oh liftA
20:54:02 <slack1256> @src liftA
20:54:03 <lambdabot> liftA f a = pure f <*> a
20:55:16 <ParahSailin_> :t pure
20:55:18 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
20:55:42 <johnw> wonder why there's no <.>
20:56:06 <johnw> > pure (.) <*> [(+1)] <*> [(+2)] <*> [3]
20:56:10 <lambdabot>   [6]
20:56:12 <johnw> that's what I had meant
20:56:24 <johnw> I can compose functions in the applicative
20:56:43 <johnw> but i expected to write: [(+1)] <.> [(+2)] <*> [3]
20:57:13 <Saizan> you can define it
20:57:19 <johnw> sure
20:57:28 <johnw> that's the beauty of Haskell
20:57:40 <johnw> I can add things that in other languages would need a core change
20:57:59 <johnw> my co-worker and I spent the day mulling over State today
20:58:10 <johnw> fully convincing ourselves of why it works
20:58:50 <Ralith> I'm pretty sure infix operators aren't an especially noteworthy feature of haskell
20:59:17 <johnw> but it feels "right" to be able to use =~ for regex operations without it being anything special (as it is in Ruby or Perl)
20:59:37 * hackagebot classy-prelude 0.2.0.0 - A typeclass-based Prelude. (MichaelSnoyman)
20:59:39 * hackagebot classy-prelude-conduit 0.2.0.0 - conduit instances for classy-prelude (MichaelSnoyman)
21:01:02 <slack1256> Ralith: curiously. the use of infix operators was the thing that got most attention in haskell at my faculty
21:01:25 <Ralith> slack1256: that's worrisome.
21:01:59 <slack1256> Ralith: well that at-least got them interested. gives me something from where to work on.
21:02:13 <Ralith> fair enough
21:02:20 <Ralith> start small
21:04:14 <EvanR> uhg
21:04:26 <EvanR> suddenly my acid state stuff wont compile
21:04:47 <EvanR> complains that the instances are not defined which are supposed to be autogenerated with template haskell
21:05:14 <EvanR> only started happening when i tried to add another query type to the makeAcidic list
21:07:13 * EvanR looks more closely
21:09:24 <EvanR> gah
21:09:33 <EvanR> no instance declaration for QueryEvent
21:09:48 <EvanR> thats what makeAcidic is supposed to do
21:12:09 <EvanR> http://hpaste.org/report/24897
21:12:17 <EvanR> this isnt my code but its the same issue :(
21:12:37 <shachaf> /report/?
21:13:20 <shachaf> Oh, it's just the form.
21:14:12 <shachaf> For that matter, that report form looks insecure. :-(
21:14:56 <EvanR> uhg
21:18:10 <EvanR> answer, using lowercase version of query
21:26:47 <dmj> Do any haskell VIM users know if you can use vundle to install neo-ghc?
21:31:30 <johnw> which module is the multiplicative Int monoid in?
21:31:57 <johnw> I'm not sure how to ask Hoogle that question...
21:32:44 <shachaf> I suspect Int isn't actually a Monoid with (*). :-)
21:32:48 <shachaf> (Because overflow is undefined.)
21:32:51 <johnw> ah
21:32:53 <shachaf> Anyway, I expect it's in Data.Monoid.
21:33:06 <shachaf> It's probably called Prod or something like that.
21:33:16 <shachaf> Product
21:33:27 <shachaf> Works for any Num.
21:34:05 <johnw> I had the realization today that if you try to implement State without function passing, you basically get a non-accumulating Writer
21:34:17 <johnw> so I've written both and proved myself that yes, this is so
21:34:22 <shachaf> What do you mean?
21:34:28 <johnw> all that function-passing magic in State is to get the functionality of "get"
21:34:36 <johnw> i.e., that State is a function value
21:34:40 <johnw> and Writer is a tuple value
21:35:27 <shachaf> What's a "non-accumulating Writer"?
21:35:55 <johnw> this: https://gist.github.com/3375959
21:36:22 <johnw> writer.hs is just state.hs with its functionness downgraded
21:36:49 <shachaf> And its "state" "upgraded"...
21:37:00 <JoeyA> Is it possible to produce a compiler warning if a program is compiled with -O0 ?
21:37:12 <johnw> yeah, to support == and mempty, but I couldn't find another way
21:37:16 <JoeyA> Why would I want to do this?  See http://hackage.haskell.org/trac/ghc/ticket/3676
21:37:30 <johnw> but seeing this parallel in code really made it click to me how State works its magic
21:37:37 <shachaf> johnw: Wait, (==)?
21:37:49 <shachaf> You don't need == for Writer.
21:37:55 <johnw> so that I can tell whether to use the old monadic value's state, or the new monadic value's state
21:37:58 <johnw> this isn't a real Writer
21:38:13 <johnw> if you "put 10; put 20", the state in my dummy writer is 20
21:38:16 <shachaf> Oh.
21:38:19 <shachaf> That's the Last Monoid.
21:38:26 <johnw> that's what I meant by "non-accumulating"
21:38:33 <johnw> oh, cool
21:38:41 <shachaf> They use Maybe instead of (==), which is much nicer.
21:38:42 <Nereid> shachaf: that's a monoid?
21:38:58 <johnw> i started using Maybe, but it was getting ugly, so I backed away
21:39:18 <Nereid> oh, with Maybe.
21:39:55 <johnw> but the Last Monoid still builds a list, yeah?
21:40:01 <shachaf> No.
21:40:08 <shachaf> Well, a list of length 0 or 1. :-)
21:40:12 <johnw> because mappend is always reducing?
21:40:37 <johnw> oh, wait, I Get it
21:40:41 <Nereid> because of the definition of the Last monoid
21:40:44 <johnw> Just 10 `mappend` Nothing would be Just 10
21:40:50 <johnw> but Just 10 `mappend` Just 20 would be Just 20
21:40:56 <johnw> so it's always the last non-Nothing value
21:41:21 <johnw> is it written, Last 20 `mappend` Nothing
21:41:40 <johnw> ah, Last (Just 10)
21:41:48 <johnw> that great to know, thanks!
21:41:55 <shachaf> > map getLast [Last Nothing ++ Last Nothing, Last (Just 'a') ++ Last (Just 'b'), Last (Just 'a') ++ Last Nothing, Last Nothing ++ Last (Just 'b')]
21:41:58 <lambdabot>   [Nothing,Just 'b',Just 'a',Just 'b']
21:42:20 <shachaf> That way you can just pattern-match on Maybe instead of ==ing mempty.
21:42:24 <shachaf> Which is way nicer.
21:42:32 <johnw> yeah
21:42:47 <kanedank> hey, what does the "$" mean in putStrLn $ "I have a temporary file at " ++ tempname
21:42:54 <c_wraith> @src ($)
21:42:54 <lambdabot> f $ x = f x
21:43:05 <kanedank> so it does nothing?
21:43:15 <c_wraith> it does "function application"
21:43:21 <johnw> "$" is the same as " ", but the precedence is the lowest of all
21:43:31 <shachaf> Lowest of most.
21:43:33 <johnw> so: foo (bar (baz x)) == foo $ bar $ baz x
21:43:39 <johnw> oh, it's not the lowest of all?
21:43:42 <johnw> good to know
21:43:43 <shachaf> But please don't write foo $ bar $ baz x!
21:43:49 <johnw> it's just an example!
21:43:52 <shachaf> Write foo . bar $ baz x, or foo . bar . baz $ x
21:43:54 <Axman6> foo . bar . bad $ x
21:43:58 <shachaf> But anyway.
21:43:59 <Axman6> right
21:44:05 <kanedank> ah, okay
21:44:06 <kanedank> thanks!
21:44:16 <johnw> foo (bar baz x) == foo $ bar baz x
21:44:35 <johnw> kanedank: it comes in super handy when your arguments would span multiple lines
21:44:52 <johnw> like: forM_ vars $ \x -> do ... <many lines of code> ...
21:45:01 <johnw> parens would be very ugly in that case
21:45:43 <shachaf> johnw: It's the least sticky operator, but non-operators can be less sticky.
21:45:48 <XexonixXexillion> Parens aren't that bad :p
21:45:56 <shachaf> So foo $ bar :: baz === (foo $ bar) :: baz
21:46:03 <johnw> i use parens quite often
21:46:17 <johnw> somehow, the multi-line lambdas parens with monad control ops just look odd
21:46:38 <kanedank> johnw: ah, thanks
21:47:54 <XexonixXexillion> I don't think it looks that odd (I don't do it though), but that might be my scheme background talking
21:48:24 <tgeeky_> eww
21:52:54 <johnw> shachaf: I updated https://gist.github.com/3375959
21:53:02 <johnw> using the Last Monoid makes the parallel even clearer
21:53:03 <johnw> thanks
21:53:24 <shachaf> johnw: Last Nothing = mempty
21:53:30 <johnw> oh, hehe, duh
21:53:36 <shachaf> johnw: Of course, now your Writer is just regular Writer restricted to one Monoid.
21:53:48 <johnw> you know, you do have me there
21:54:00 <johnw> i'll change it to be the regular Writer
21:54:04 <johnw> the restriction is not edifying
21:55:07 <johnw> updated again
21:55:40 <johnw> is it wrong that this gets me completely excited??
21:56:09 <johnw> i should go ahead and call it tell
21:57:08 * shachaf notes that ghci takes >1.5 seconds to start.
21:57:15 <johnw> yeah, I've noticed that too
21:57:21 <johnw> makes "Haskell scripting" a non-reality for me
21:57:28 <johnw> I have to compile anything I want to use
21:57:30 <shachaf> No, no, this is clearly my fault.
21:57:33 <johnw> ah
21:57:39 <shachaf> I have... Let me count...
21:57:39 <johnw> then it must be my fault too
21:58:27 <shachaf> 80 imports in my .ghci
21:58:36 <shachaf> Do you have 80 imports in your .ghci? If not, it's probably not your fault.
21:59:19 <johnw> ok
21:59:22 <johnw> <-- exonerated
22:01:53 <Ralith> can't you precompile them?
22:02:11 <shachaf> Precompile?
22:02:51 <shachaf> Hah, my laptop was being throttled.
22:03:08 <shachaf> When I unplug it it ghci starts in ~0.5s
22:03:26 <shachaf> (Yes, my laptop gets faster when unplugged.)
22:03:38 <shachaf> (It's kind of not the way it's supposed to work, I think.)
22:04:10 <shachaf> (My clock speed goes from 2.2GHz to 800MHz when I plug it in.)
22:04:34 <johnw> ok, it starts in 0.165s here
22:05:05 <johnw> It's my una scripts that needs 0.675s to run through runhaskell, and 0.053s to run compiled
22:05:43 <johnw> my Kindle is becoming full of Haskell articles
22:08:17 <pharaun> that's a good thing!
22:08:23 <johnw> yeah, it really is
22:08:39 <johnw> i'm starting to experience an avalanche effect
22:09:05 <johnw> things are becoming clearer at an advancing rate, and connecting with each other at the same time
22:09:22 <johnw> and also some of the stuff you guys talk about here actually makes sense :)
22:10:37 <pharaun> i haven't quite gotten to that point yet i think (for the more complicated stuff)
22:10:45 <pharaun> but i'm starting to figure things out, its excellent
22:10:49 <johnw> this is my 3rd time through reading all this stuff
22:10:53 <johnw> so believe me, it's taken a while
22:11:02 <johnw> it's like sipping jello through a straw
22:11:10 <pharaun> hahaha
22:11:50 <shachaf> > nubBy((>1).:gcd)[2..]
22:11:52 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
22:11:55 <kanedank> what does "<-" and "-<" mean?
22:12:10 <shachaf> > fix$(1:).scanl(+)1
22:12:11 <johnw> it's arrow notation
22:12:12 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:12:19 <shachaf> kanedank: Are you sure you're seeing a "-<"?
22:12:42 <kanedank> no, I was just skimming an advanced tutorial and was wondering if they were related
22:12:50 <shachaf> kanedank: Based on the fact that you were just asking about $ a few minutes ago, I'd say to avoid anything involving -< :-)
22:12:53 <johnw> x <- f -< y, I believe, means to bind y as the "in" side of the arrow, and "x" to the "out" side.  Is that right?
22:13:02 <shachaf> It's from an esoteric syntax extension.
22:13:03 <kanedank> actually I don't know the proper name for "->" or "<-"
22:13:47 <shachaf> kanedank: -> and <- are unrelated.
22:13:57 <shachaf> Their proper names are "->" and "<-", respectively. :-)
22:14:01 <johnw> <- is a rewrite for -> in a do block, isn't it?
22:14:18 <johnw> x <- y; ... === y >>= \x -> ...
22:14:18 <shachaf> kanedank: Are you reading some introduction to Haskell? They usually explain all this syntax.
22:14:34 <liyang> "<-" is sometimes pronounced "bind".
22:14:36 <shachaf> johnw: It's a rewrite for something that happens to use a ->?
22:14:37 <kanedank> well I just don't understand the relationship between -> and <-
22:14:47 <kanedank> I mean I know how to use them...
22:14:54 <shachaf> kanedank: There's no real relationship. They just happen to look similar.
22:15:21 <kanedank> this part in rwh is what's causing me to tear my hair out: https://gist.github.com/3376139
22:15:29 <johnw> schachaf: but when you see <-, doesn't it mean the compiler is going to rewrite your term using a lambda, which uses ->?
22:15:37 <kanedank> I don't get how pos <- hTell temph is there twice
22:16:15 <johnw> kanedank: it's in the IO monad, getting the file position
22:16:29 <johnw> kanedank: it can have two different values because that's the impurity of IO
22:16:29 <shachaf> kanedank: The two "pos"es are unrelated variables.
22:16:36 <shachaf> They just happen to have the same name, which is confusing.
22:16:43 <johnw> yeah
22:16:46 <kanedank> what
22:16:58 <johnw> because of the >>= \pos -> rewrite, you can think of them as nested local variables
22:17:04 <shachaf> The second one could just as easily be "pos' <-hTell temph"
22:17:18 <kanedank> but how is that possible?
22:17:22 <shachaf> kanedank: I have the feeling you're skipping too far ahead of the introductions-to-how-syntax-works, and getting confused. :-)
22:17:28 <johnw> hTell temph >>= \pos -> ...; hTell temph >>= \pos -> ...
22:17:33 <johnw> the inner pos shadows the outer pos
22:17:49 <johnw> yeah, I would agree with shachaf
22:17:51 <kanedank> I just don't get how one variable name can refer to two different values in haskell
22:18:01 <johnw> they are not the same variable
22:18:09 <shachaf> kanedank: let x = 5 in { let x = 6 in x }
22:18:14 <shachaf> It's called "shadowing".
22:18:18 <johnw> what other languages do you know kanedank?  C or C++?
22:18:22 <shachaf> They're two different variables which happen to have the same name.
22:18:23 <johnw> yeah, shadowing
22:18:35 <shachaf> Most other languages have this too.
22:18:47 <kanedank> I know what shadowing is, but how the hell am I supposed to guess that from that code sample?
22:18:58 <kanedank> it looks like the same context to me...
22:19:04 <johnw> at this point, you wouldn't be able to guess that
22:19:20 <shachaf> kanedank: Refer to my earlier statement. :-)
22:19:24 <johnw> each line is actually a lambda function with its own scope
22:19:31 <johnw> each line begins a new lambda function
22:19:33 <kanedank> java/python/a bit of cl
22:19:37 <johnw> you'll get to it later
22:19:42 <johnw> (wonders if he has been /ignore'd)
22:20:22 <kanedank> johnw: I'm going through rwh trying to make sure I understand everything, but I feel like there is so much handwaving or "we'll get to this part next chapter..."
22:20:32 <johnw> I didn't really like RWH
22:20:38 <shachaf> kanedank: Don't use RWH as an introduction to Haskell.
22:20:41 <kanedank> johnw: how did you learn?
22:20:51 <shachaf> Read it if you already know Haskell somewhat.
22:21:01 <johnw> learnyouahaskell.com
22:21:14 <shachaf> kanedank: The book johnw mentioned is recommended in here a lot.
22:21:28 <shachaf> I haven't read it, though.
22:21:32 <johnw> it's not great at everything, but it's absolutely steller for about 85% of it
22:21:37 <shachaf> Hutton's _Programming in Haskell_ is good (though I don't think you can get it online).
22:21:44 <johnw> some of its explanations are actually confusing to me
22:22:02 <johnw> it's pretty much terrible for learning monads; but it's awesome for grokking functors and applicatives
22:22:05 <kanedank> well I think rwh is okay, as long as I reread stuff
22:22:51 <shachaf> kanedank: OK, but what you're doing is coming in here and asking people to type in half of an introduction to Haskell by hand to help you understand some detail of an example. :-)
22:23:00 <johnw> kanedank: that code you pasted, here is how the compiler really sees it: https://gist.github.com/3376163
22:23:06 <shachaf> Which leads me to believe that you're skipping too far ahead or that the book isn't structured well.
22:23:07 <johnw> (well, close to how it sees it)
22:23:15 <johnw> you can see the shadowing effect clearly there
22:23:23 <shachaf> (I expect that johnw's paste will only confuse you.)
22:23:30 <johnw> yeah, I suspect that too
22:23:35 <johnw> and shachaf is right
22:23:44 <kanedank> johnw: ah that formatting makes sense to me!
22:23:50 <kanedank> the formatting in rwh is terrible: https://gist.github.com/3376160
22:24:11 <shachaf> kanedank: The formatting there is great.
22:24:20 <shachaf> It assumes that you already know how "do" works, though.
22:24:26 <johnw> I rewrote the do notation as bind notation
22:24:28 <johnw> that's all
22:25:08 <shachaf> That is not a good Haskell file to learn from when you're starting off from the point of "not knowing what $ does". :-)
22:25:20 <johnw> yes, that is exactly right
22:25:29 <johnw> step away from do-notation
22:25:33 <johnw> :)
22:25:43 <johnw> it's a thorny beast that will leave you with scars
22:25:43 <kanedank> hmm, well I guess I'll have to go back and reread that other stuff and maybe come back to rwh
22:25:54 <kanedank> thank you!
22:25:55 <johnw> try LYAH for a few chapters
22:26:05 <johnw> it's quite an enjoyable read
22:27:06 <johnw> the chapters I didn't like: 7 (too much info at once), 10, 12, 14
22:27:09 <johnw> the others I loved
22:27:10 <gurkoboy> ghci> [2, 1] > [1, 7]
22:27:11 <gurkoboy> True
22:27:11 <gurkoboy> 
22:27:19 <gurkoboy> shouldn't that be false? 1 > 7?
22:27:55 <johnw> huh, what does that even mean?
22:28:05 <johnw> > all (>) [2, 1] [1, 7]
22:28:06 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
22:28:06 <lambdabot>         against inferred type ...
22:28:27 <shachaf> gurkoboy: It's lexicographical.
22:28:27 <jfischoff> > [2,1] > [1, 7]
22:28:28 <lambdabot>   True
22:28:35 <kanedank> also, is there a place to look up keywords like "->" when I get confused? google isn't helping...
22:28:42 <shachaf> > "ba" > "ag"
22:28:44 <lambdabot>   True
22:28:53 <shachaf> kanedank: It's not really a keyword, it's syntax.
22:29:04 <shachaf> kanedank: The answer is "an introduction to Haskell".
22:29:09 <jfischoff> > (2, 1) > (1, 7)
22:29:11 <lambdabot>   True
22:29:13 <shachaf> If it was an operator, you could use Hoogle.
22:29:32 <johnw> kanedank: -> has two distinct uses (that I know of): separate of type parameters, and separate of lambda arguments from the lambda body
22:29:41 <johnw> separation
22:29:52 <shachaf> johnw: It has more than that!
22:30:03 <shachaf> It's a type constructor but also a kind constructor.
22:30:07 <johnw> separation of kinds?
22:30:11 <johnw> blasted, you beat me!
22:30:11 <Catnaroek> * -> *
22:30:20 <shachaf> I wouldn't call it "separation", though -- on the type level it's just an operator.
22:30:28 <Catnaroek> Also used in case statements.
22:30:29 <shachaf> s/n operator/ constructor/
22:30:39 <Catnaroek> shachaf: A kind constructor?
22:30:45 <shachaf> But used with lambdas it's a weird syntax-thing.
22:30:46 <kanedank> but other syntax like "(\_ -> return ".")"
22:30:52 <johnw> gurkoboy: all (==True) $ zipWith (>) [2,1] [1,7]
22:30:56 <kanedank> the \_ in that case
22:31:09 <shachaf> kanedank: Again, "an introduction to Haskell".
22:31:19 <johnw> kanedank: that's a lambda.  Time to hit the books
22:31:24 <shachaf> All the references you can look these things up assume a certain base level of understanding of Haskell syntax.
22:31:34 <shachaf> \ and -> are part of that. :-)
22:32:36 <johnw> oh yeah, case statements
22:32:50 <shachaf> johnw: "all (==True)" :-(
22:32:57 <shachaf> (==True) = id
22:33:00 <shachaf> all id = and
22:33:09 <johnw> oh, cool
22:33:20 <johnw> i told you, I'm still a newbie
22:33:26 <johnw> and $ zipWith (>) [2,1] [1,7]
22:33:28 <johnw> > and $ zipWith (>) [2,1] [1,7]
22:33:29 <lambdabot>   False
22:33:37 <johnw> > or $ zipWith (>) [2,1] [1,7]
22:33:38 <lambdabot>   True
22:33:41 <johnw> neato
22:34:12 <johnw> oh, becasue all takes a -> Bool
22:34:14 <n00b6502> i'm about to try and translate some C++ code doing file parsing to haskell..
22:34:26 <johnw> that's like me saying "if (a == b) == True"
22:34:46 <johnw> n00b6502: you are using I/O streams in your C++?
22:34:54 <n00b6502> yes
22:35:14 <johnw> will you be using Data.ByteString.Lazy?
22:35:27 <n00b6502> perhaps
22:35:43 <shachaf> n00b6502: Please don't translate your C++ code to Haskell. :-(
22:36:21 <n00b6502> reasoning about file-parsing to build a datastructure
22:36:52 <n00b6502> its a slightly JSON-esque format but not exactly (FBX)
22:37:14 <n00b6502> i'm going to run into haskell's record system
22:37:40 <johnw> as in "with open arms", or "like a mac truck"? :)
22:37:41 <n00b6502> the very worst i could do is basically end up with lots of :: IO x
22:38:01 <johnw> why would your records need to contain values in IO?
22:38:01 <n00b6502> write an imperative program in haskell
22:38:26 <johnw> only the parser would need to know about IO
22:38:34 <johnw> and even that maybe not
22:38:37 <johnw> only the text reader
22:38:38 <n00b6502> thats the program
22:39:00 <n00b6502> well... the C++ source infront of me is a program to load an FBX model and draw it in opengl.
22:39:03 <johnw> so, use IO to get data from the file, but pass that data on to the Parser pure
22:39:11 <n00b6502> if i can do that in haskel then i'll be pretty pleased
22:39:25 <johnw> n00b6502: I don't think it will be that hard
22:39:31 <n00b6502> so just load into a big string ?
22:39:40 <johnw> n00b6502: Haskell will read it lazily
22:39:45 <johnw> write the code as if you're reading a big string
22:39:46 <n00b6502> ah of course
22:39:48 <johnw> but that's not what will happen
22:40:04 <n00b6502> ok that sounds pretty cool
22:40:06 <johnw> I expect the solution will be rather beatiful compared to the C++ equivalent
22:40:10 <jfischoff> n00b6502: have you tried Parsec?
22:40:47 <n00b6502> i should rename myself "haskelln00b" , i have more experience with 6502 assembler than haskell
22:41:24 <liyang> mmaping into a ByteString is pretty efficient. http://hackage.haskell.org/package/bytestring-mmap
22:41:43 <johnw> I was wondering if you'd coded 6502
22:41:44 <n00b6502> the thing that frustrates me in C++ is the lack of RTTI
22:41:47 <johnw> I was a big 65c02 coder myself
22:42:03 <johnw> n00b6502: you mean, runtime type reflection?
22:42:06 <n00b6502> yes
22:42:10 <johnw> yeah
22:42:33 <n00b6502> a struct describing the struct. thats all i want. i'm sure everyone wants it.
22:42:39 <johnw> i'm on the C++ standards committee, that's something that comes up quite often
22:42:39 <n00b6502> but the language doesn't have it
22:43:13 <johnw> at least you have type_traits now in C++11, but that is a bit OT
22:43:25 <n00b6502> i'm interested, how do they work
22:43:38 <johnw> privmsg?
22:43:42 <n00b6502> sure
22:50:17 <gurkoboy> what does "xs" typically stand for
22:50:23 <johnw> "some list data"
22:50:27 <gurkoboy> thanks
22:50:50 <Ralith> more generally
22:50:53 <Ralith> "multiple things"
22:50:58 <johnw> yeah
22:51:30 <jfischoff> I read it "x is"
22:51:32 <shachaf> gurkoboy: It's the plural of x.
22:51:51 <johnw> in the clothing store, in means "really small"
22:52:15 <gurkoboy> thanks everyone :)
22:52:19 <NihilistDandy> It's an affectionate abbreviation for "kisses"
22:52:25 <NihilistDandy> Haskell is full of kisses
22:52:55 <NihilistDandy> So all those people talking about how unfriendly the language is to new people are full of it
22:53:22 <shachaf> Kisses can be unfriendly.
22:53:25 <jfischoff> The error messages could be better
22:53:43 <mlh> xs is Hungarian notation :-)
22:54:06 <pqmodn> jfischoff: how do you improve on "my brain just exploded"?
22:54:35 <jfischoff> pqmodn: no you can't improve on that :)
22:54:54 <NihilistDandy> shachaf: Only if they're unkinded
22:54:56 <pqmodn> another favorite, "the 'impossible' just happened!"
22:55:04 <Veinor> i know i've run into instances where application of a type synonym would've cleaned things up
22:55:14 <Veinor> but i imagine picking the right type synonym to use is tricky
22:55:17 <Catnaroek> jfischoff: What is your problem with the/(presumably GHC's) error messages?
22:57:27 <pqmodn> i making them more prescriptive, where possible would help beginners. i noticed undefined name errors now offer suggestions like "perhaps you meant: xs?"
22:57:41 <jfischoff> Catnaroek: This paper does a better job explaining how things could be improved then I can http://sources.haskell.cz/Helium.pdf
22:58:30 <pqmodn> sadly Helium accomplishes better error messages by removing features like type classes :\ but that might be sensible for beginners
22:58:56 <jfischoff> "parse error" is not that helpful. Many hpastes are made just so beginners can get past that
22:59:26 <shachaf> jfischoff: If only beginners would start out by reading the BNF grammar!
22:59:39 <jfischoff> :)
23:01:23 <Catnaroek> Well, BNF grammars are easy to read, especially so if you are familiar with algebraic data types. They map onto each other pretty nicely.
23:01:25 <jfischoff> it would be interesting to see what Haskell could become if it had the resources of LLVM or VS C++ teams. I
23:01:39 <jfischoff> 'm sure it could have good error message
23:01:46 <Catnaroek> jfischoff: I am not completely sure it would be for the better.
23:01:54 <jfischoff> perhaps not
23:02:22 <jfischoff> goodnight all!
23:02:31 <pqmodn> see ya!
23:02:36 <Catnaroek> One of Haskell's main competitive advantages vis--vis other languages is the principled approach to its design.
23:02:38 <Catnaroek> Oh.
23:02:48 <Catnaroek> Too late.
23:04:27 <NihilistDandy> Catnaroek: And BNF grammars are sophomore-level CS material, so pretty well within reach of most programmers, I'd think
23:06:31 <Catnaroek> NihilistDandy: Indeed. When I was taught how to use them, I did not about algebraic data types, and even then I understood them pretty easily. When I discovered ADTs, the first thing I thought was "these are BNF grammars turned into types!".
23:07:58 <mm_freak> if any of you guys live in or near stuttgart, germany, i'll be conducting an introductory haskell-workshop today at 8:00 PM
23:08:25 <NihilistDandy> I had a little headstart with Haskell when I was first exposed to them, but they definitely helped to solidify my understanding of ADTs
23:15:19 <shachaf> Should adding {-# LANGUAGE DataKinds #-} makes things that used to compile no longer compiler?
23:15:50 <shachaf> This thing looks sort of like a GHC bug:
23:16:18 <shachaf> data Foo a b; data Bar foo where { Bar :: { hmm :: a -> Int } -> Bar (Foo a b) }
23:16:40 <mm_freak> shachaf: at least it can change error messages, but i don't think that correct h2010 code will stop compiling
23:16:48 <shachaf> No, I'm using GADTs.
23:17:06 <shachaf> That thing compiles fine without PolyKinds, but fails with PolyKinds.
23:17:10 <shachaf> However, this works with both:
23:17:17 <shachaf> data Foo a; data Bar foo where { Bar :: { hmm :: a -> Int } -> Bar (Foo a) }
23:17:34 <mm_freak> are we talking about DataKinds or PolyKinds?
23:17:44 <shachaf> Um, looks like it's actually PolyKinds.
23:18:00 * shachaf turned two extensions on with one stone there earlier.
23:18:34 <mm_freak> so by just turning on PolyKinds your code stopped compiling, while it does without it?
23:18:40 <shachaf> Yes.
23:18:48 <shachaf> Wait...
23:18:55 <shachaf> Oh, yes.
23:19:35 <mm_freak> well, the only advice i can give you from my experience is that * is not a wildcard
23:19:46 <mm_freak> if you want kind polymorphism you really need a kind variable
23:19:47 <shachaf> I don't have any explicit kinds everywhere.
23:19:54 <shachaf> The whole code is what I pasted up there.
23:20:09 <mm_freak> weird
23:20:13 <shachaf> Does someone here have a recent GHC to test it with?
23:20:20 <mm_freak> that definitely shouldn't stop compiling as far as i see
23:20:27 <mm_freak> i have 7.4.2
23:20:29 <shachaf> It seems kind of like a bug to me but maybe I don't understand PolyKinds.
23:20:30 <mm_freak> let me check
23:20:39 <shachaf> I have 7.4.1 -- I doubt that makes a difference.
23:20:52 * shachaf doesn't really feel like compiling HEAD just for this. :-)
23:21:44 <mm_freak> for me it compiles both with and without PolyKinds
23:21:47 <mm_freak> given GADTs
23:22:09 <mm_freak> command line:  ghc -O2 -threaded -rtsopts --make -o polykinds polykinds.hs
23:22:24 <shachaf> Which code?
23:22:32 <mm_freak> data Foo a; data Bar foo where { Bar :: { hmm :: a -> Int } -> Bar (Foo a) }
23:22:41 <shachaf> 23:16 <shachaf> However, this works with both:
23:22:45 <shachaf> Look a few lines above. :-)
23:22:46 <mm_freak> oh
23:22:49 <mm_freak> hehe sorry
23:23:44 <mm_freak> yeah, indeed it doesn't compile
23:23:52 <mm_freak> weird
23:25:20 <shachaf> Without an accessor:
23:25:22 <mm_freak> it seems to be related to the 'hmm' field
23:25:29 <mm_freak> yeah, just wanted to say that =)
23:25:34 <mikeplus64> @pl (\(x, y) -> y /= Foo)
23:25:35 <lambdabot> (Foo /=) . snd
23:25:46 <shachaf> data Foo a b; data Bar foo where { Bar :: (a -> Int) -> Bar (Foo a b) }; hmm :: Bar (Foo a b) -> a -> Int; hmm (Bar x) = undefined
23:25:52 <shachaf> Exhibits the same behavior.
23:26:41 <shachaf> Or data Foo a b; data Bar foo where { Bar :: (a -> Int) -> Bar (Foo a b) }; hmm :: Bar (Foo a b) -> a -> Int; hmm (Bar x) = x
23:26:42 <mm_freak> hmm :: Bar (foo a b) -> a -> Int
23:26:42 <mm_freak> hmm (Bar f) = f
23:26:45 <mm_freak> this one fails as well
23:27:14 <mm_freak> s/foo/Foo/
23:27:33 <shachaf> Right.
23:27:43 <shachaf> Maybe I should ask in #ghc
23:27:46 <mm_freak> feels like a bug, yes
