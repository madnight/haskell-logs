00:00:00 <shachaf> Identity endofunctor?
00:00:09 <johnw> this is very clarifying
00:00:11 <shachaf> Not to be confused with the newtype "Identity"
00:00:15 <Nereid> that's naturally isomorphic to an instance of Functor.
00:00:20 <Nereid> so it may as well be.
00:00:31 <johnw> it also makes sense that if all functions are arrows, they would have to map between exactly two types
00:00:46 <sheldonh> pharaun: awesome! thank you. i find "one great way into the standard library" really accelerates my learning
00:01:13 <johnw> sheldonh: is that an article you read?
00:01:20 <shachaf> johnw: You don't need category theory for that.
00:01:28 <shachaf> You just need a definition of the word "function".
00:01:45 <johnw> gotcha.  i was more connecting it out loud with other thoughts
00:01:59 <mauke> .oO( you are a modem )
00:02:02 <johnw> like, if nullary functions existed, they couldn't be arrows, which would break a definition
00:02:43 <shachaf> I don't know what "nullary function" would even mean.
00:03:02 <sheldonh> johnw: no, referring to pharaun's suggestion of hayoo/hoogle :)
00:03:05 <liyang> thunks?
00:03:06 <Twisol> you can pretend you have a nullary function like this…
00:03:07 <Twisol> > let four = const 4 in four()
00:03:08 <johnw> shachaf: in programming world, not math world, we use it to mean a function that takes no arguments: (define f () 10)
00:03:08 <lambdabot>   4
00:03:15 <Nereid> shachaf: have you heard of multicategories?
00:03:34 <johnw> sheldonh: hoogle is where I spend most of my day when I'm writing Haskell code
00:04:03 <sheldonh> johnw: i'm a long way from writing Haskell code. looking forward to it :)
00:04:04 <shachaf> johnw: I mean in the context of Haskell.
00:04:09 <Nereid> sure.
00:04:12 <johnw> shachaf: ah
00:04:30 <shachaf> We have the type constructor (->) of kind * -> * -> *
00:04:32 <mauke> I wonder if that is legal scheme
00:04:52 <mauke> (answer: no)
00:05:07 <rstott> Hi, I have a pretty newbie question but it feels important :) What's the advised way to have (records) of type A (which are all stored in one list) hold references to certain objects of type B, all of which are stored in another list? I'm making a top-down simulation toy and I want my "living" entities to be able to move towards static "world" entities, but I keep running into the problem of not wanting to store the value of the world entit
00:05:08 <rstott> two places.
00:06:30 <rstott> that is, their list (which is part of the World type), and the "targetEntity" field of the living entity's record
00:11:16 <mm_freak_> rstott: use Data.Map instead of lists
00:11:23 <mm_freak_> have every object have a key
00:11:30 <rstott> Ah nevermind, I think I'm complecting identity and value. rich hickey would be so mad at me!
00:11:33 <rstott> yeah
00:11:34 <rstott> exactly
00:13:23 <sheldonh> hang on... when i do map toUpper "xyzzy"... that looks like two arguments to me. is a tuple being formed transparently?
00:13:35 <mauke> no
00:13:39 <mauke> it's two calls
00:13:53 <mauke> ((map toUpper) "xyzzy")
00:14:12 <sheldonh> ah, much better. thanks
00:14:16 <mauke> first map is called with toUpper. it upgrades toUpper to a version that operates on lists and returns it
00:14:23 <mauke> then that new function is called with "xyzzy"
00:14:44 <mauke> map :: (a -> b) -> ([a] -> [b])
00:15:03 <mm_freak_> sheldonh: map :: (a -> b) -> [a] -> [b]…  the (->) type operator is right-associative, so the type can be read as:  map :: (a -> b) -> ([a] -> [b])
00:15:12 * shachaf likes the word "upgrade"
00:15:18 <mm_freak_> so map toUpper :: [Char] -> [Char]
00:15:25 <mm_freak_> you have refined a and b to Char
00:15:38 <mauke> it sounds cooler than "lift"
00:16:09 <mm_freak_> i think "lift" sounds cooler =)
00:16:49 <sheldonh> very different from map in ruby :)
00:16:55 <mm_freak_> 'map' has lifted toUpper to a higher level of consciousness, if you're esoteric =)
00:17:30 <mm_freak_> :t foldl'
00:17:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
00:17:33 <mm_freak_> :t foldl' (+)
00:17:34 <lambdabot> forall a. (Num a) => a -> [a] -> a
00:17:37 <mm_freak_> :t foldl' (+) 0
00:17:38 <lambdabot> forall a. (Num a) => [a] -> a
00:17:42 <mm_freak_> :t foldl' (+) 0 [1..9]
00:17:43 <lambdabot> forall a. (Num a, Enum a) => a
00:18:06 <Sgeo> sheldonh, do you know Ruby's collect?
00:18:15 <sheldonh> Sgeo: yup.
00:18:34 <Sgeo> Actually, wait, it's also called map in Ruby. So how is it different?
00:20:13 <shachaf> Sgeo: Ruby's map takes two arguments rather than lifting a function to work on arrays.
00:20:42 <mm_freak_> Sgeo: rubyMap :: (a -> b, [a]) -> [b]
00:20:45 <mm_freak_> that's the difference
00:21:00 <mm_freak_> :t uncurry map
00:21:01 <lambdabot> forall a b. (a -> b, [a]) -> [b]
00:21:28 <Sgeo> But (a -> b) -> ([a] -> [b]) can be thought of as taking two arguments in a sense
00:21:38 <Sgeo> Depending on how you look at it
00:21:40 * Sgeo shuts up
00:21:42 <mm_freak_> Sgeo: you have the option to pass only one
00:21:49 <mm_freak_> you don't have that option in ruby
00:21:59 <sheldonh> Sgeo: ruby's map applies an anonymous function to each value in a tuple, if i have my haskell terminology correct
00:22:01 <mm_freak_> you would have to wrap it up in a lambda to emulate currying
00:22:22 <Sgeo> mm_freak_, but this isn't a difference that's localized to map
00:23:04 <mauke> perlMap :: (Context a) => (Scalar -> List, List) -> a
00:23:20 <mm_freak_> Sgeo: correct…  together with the fact that ruby's syntax is too heavyweight for actual currying you get multi-argument functions all over the place
00:23:25 <mauke> except that's not quite right because I have no idea how to model the first parameter
00:23:52 <mauke> maybe perlMap :: (Context a) => (IO List, List) -> a
00:24:03 <mauke> no, it would have to return IO a
00:24:19 <mm_freak_> mauke: perlMap :: (Scalar -> List, List, (forall a. (PerlType a) => a -> IO b)) -> IO b
00:24:38 <mauke> mm_freak_: that makes no sense
00:24:43 <Sgeo> sheldonh, I'm sorry if I caused any confusion
00:24:50 <mm_freak_> it's an existential context in perl
00:25:19 <mm_freak_> perlMap :: (Scalar -> IO List, List, (forall a. (PerlType a) => a -> IO b)) -> IO b
00:25:24 <mm_freak_> uhm
00:25:34 <mauke> but it doesn't use CPS
00:25:55 <mauke> also, why are you trying to use an existential type here?
00:26:10 <mauke> the caller determines the type context
00:26:15 <mm_freak_> i've rewritten the existential to universal quantification, hence the CPS
00:26:19 <mm_freak_> does he?
00:26:22 <mauke> yes
00:26:27 <mauke> > read "42" :: Int
00:26:28 <lambdabot>   42
00:26:39 <mm_freak_> i see…  well, i don't know perl
00:27:17 <mauke> the difference is that perl has only three possible contexts and they're built into the language
00:27:31 <mauke> but it's quite similar to haskell otherwise
00:27:58 <shachaf> You don't need a type class, then.
00:28:20 <mauke> how would you model it?
00:28:31 <shachaf> Either or a tuple or something, presumably.
00:28:37 <mauke> huh?
00:28:44 <mm_freak_> phpMap :: (PHP, PHP) -> IO PHP
00:29:38 <mm_freak_> phpConnectToDB :: (PHP, PHP, PHP, PHP, PHP, PHP) -> IO PHP
00:29:41 <shachaf> mauke: If something can return either an Int or a Char, and the caller gets to choose, you can return (Int,Char)
00:29:57 <shachaf> Or maybe I'm misunderstanding.
00:30:27 <mauke> shachaf: but then you have to compute both
00:30:52 <shachaf> Well, it's lazy.
00:30:56 <mauke> not in perl
00:31:07 <shachaf> I thought we were talking about Haskell here.
00:31:50 <mauke> a haskellish type signature for perl's map
00:31:53 <shachaf> (Trying to model Perl's map in Haskell.)
00:32:08 <mauke> more transcription than translation
00:32:30 <shachaf> Well, type classes are open, and Perl's contexts are closed.
00:32:39 <mauke> a minor detail
00:32:44 <shachaf> OK.
00:33:11 <mauke> oh man, .. would get completely weird
00:33:49 <mauke> (..) :: Scalar -> Scalar -> (IO Scalar, List) or something like that
00:33:59 <mauke> using your approach, I mean
00:47:13 <pharaun> wow, just finished coding up a network async reciever and that was quite nice to do in haskell :)
00:50:31 <maus_> pharaun, what's the network receiver?
00:51:32 <pharaun> maus_: i am just doing a udp client for a service i wanted to interface with, and i just coded up a function that will take inbound replies form the server and give the data to the correct sleeping thread (that sent the data)
00:51:49 <pharaun> s/form/from/
00:54:39 <pharaun> maus_: i was just generally pleased at how easy/clean it was to code up that stuff :) i thought it would be nightmarish from previous experience with other languages :)
00:54:50 <maus_> pharaun, nice :) How did you structure the code?
00:55:33 <pharaun> honestly its still a little messy and bit "type unsafe" in spots, i still need to clean it up but i wanted to get a functional POC running....
00:56:12 <pharaun> but anyway i sorta of structured it in layer, a lower layer that did the network stuff, then a medium layer that basically provided "stub" function for like say "ping", "auth", "logout", "data (data types/etc)"
00:56:48 <pharaun> and it would basically take that information and generate the request data, send it to the lower layer to get sent out, then put theirselves to sleep via a "data tag -> mvar" map
00:57:02 <maus_> some time ago I worked on a http traffic compressor in Haskell. The networking part turned out to be quite tricky to make robust. I guess it was the result of a lack of experience, though.
00:57:15 <pharaun> then i had a receiver that was looping that will receive and identify which thread it belong to and put it into their mvar and off they went
00:57:27 <pharaun> maus_: yeah it can be surprisingly tricky
00:58:08 <pharaun> maus_: in this case its even more fun by the fact that the underlaying protocol is udp, and that i need to deal with session management, re-transmitting, tags/tracking which (request to reply) etc
00:59:10 <maus_> oh.. In my case it was tcp, but link supposed to be unstable, so I had to tackle with various timeouts too.
01:00:05 <maus_> I guess one should first come up with a sound model of distributed system. And then start implement it. Not the other way :)
01:00:52 <pharaun> indeed
01:01:17 <pharaun> i'm still not quite *100%* solid on my model to be honest, but i'm happy with the basics so far :)
01:01:21 <maus_> Looking backward I understand that was my mistake :)
01:02:08 <sheldonh> hmmm... is this golden rule of one argument per function typical of functional programming languages?
01:02:42 <pharaun> sheldonh: no in haskell case its - partial application and currying, are you familiar with these two concept?
01:03:18 <quicksilver> it's not really clear what counts as a functional programming language
01:03:32 <quicksilver> but probably the answer is 'no'
01:04:13 <pharaun> also there's many "functions" that takes multiple args, but thanks to partial function application/currying/etc ....
01:04:34 <pharaun> well that's not technically correct but meh
01:05:19 <maus_> yeah, with curring you can treat any function as unary :)
01:06:34 <shachaf> The main thing that makes a language count as "function" is using {- -} for multiline comments.
01:06:45 <shachaf> (To paraphrase someone who used to be here.)
01:06:45 <pharaun> probably a silly example but let's say - (a `mod` b) - you can like define (mod' = mod 10)
01:07:48 <pharaun> heh
01:08:50 <simon> in Typeclassopedia, I am stuck on the exercise 'instance Functor ((,) e) where fmap f g = ...' g takes an x and returns (e,x), so I figure it should instead return (e,f x), but '\x -> g (f x)' apparently has a parameter too much.
01:09:37 <dmwit> Wait, what?
01:09:47 <dmwit> In "fmap f g" there, g is not a function.
01:10:15 <dmwit> g is an (,) e a, and you need to return a (,) e b using f :: a -> b
01:10:22 <simon> I thought it (e,) = \x -> (e,x)
01:10:41 <dmwit> That's at the type level.
01:10:44 <shachaf> I think you're confusing types and values.
01:11:04 <dmwit> g is not a value of type (e,), because (e,) is not a type but rather a type constructor.
01:11:04 <simon> aha.
01:12:01 <Twisol> fmap :: Functor f => (a -> b) -> f a -> f b. Given an instance Funtor ((,) e), you have f = (,) e. So (f a -> f b) expands to ((,) e a) -> (,) e b).
01:12:39 <shachaf> -funsafe-ctors
01:13:01 <shachaf> The only thing better than fun Ctors is fun, safe Ctors.
01:14:38 <simon> ah, I get it now.
01:14:53 <Twisol> simon: sorry, symbol soup. :)
01:14:58 <dmwit> simon++ you just leveled up, man!
01:15:05 <simon> hehe. :)
01:15:08 <shachaf> Happy birthday!
01:15:09 <shachaf> Wait.
01:16:22 <startling> what's the thing that's like "data Whatever a = Whatever a (Whatever a)" and where can I get it?
01:16:40 <Twisol> isn't that []?
01:16:41 <shachaf> Stream?
01:17:00 <scshunt> what Twisol said
01:17:01 <Twisol> data [a] = (:) a ([a])
01:17:08 <Twisol> oh, and | []
01:17:14 <startling> Twisol: sure, [] could be defined in terms of it
01:17:15 <shachaf> Lots of packages define it.
01:17:19 <shachaf> http://hackage.haskell.org/packages/archive/Stream/0.4.6/doc/html/Data-Stream.html
01:17:27 <maus_> Do anybody have an experience of building game bots in haskell?
01:17:35 <startling> shachaf: oh huh
01:17:39 <simon> maus_, for IRC or HTTP?
01:17:42 <startling> shachaf: thought Stream was something else
01:17:45 <mm_freak_> maus_: what kind of game?
01:17:54 <shachaf> startling: Lots of things are called Stream. :-)
01:18:22 <maus_> simon, mm_freak_, for something like World of Warcraft, really :)
01:18:25 <mm_freak_> startling: that's about the most basic stream type possible =)
01:18:39 <startling> mm_freak_: yeah, s'true
01:18:45 <mm_freak_> maus_: that would involve some reverse engineering…  i don't think anyone here has gone through that trouble
01:18:51 <mikeplus64> would that definition of Stream, if you actually used it, be inefficient (ie use a lot of memory) in actual use, or would laziness + smart garbage collection save you?
01:19:02 <startling> I wasn't thinking of it in terms of list for some reason -- I was thinking "a fix data type"
01:19:45 <startling> mikeplus64: I was going to stick an Either in there, so it's not necessarily an infinite thing
01:19:59 <shachaf> startling: Well, you can define it in terms of Fix.
01:20:06 <mikeplus64> startling: in that case maybe what you want is just a list
01:20:15 <mm_freak_> mikeplus64: laziness and GC saves you
01:20:17 <startling> shachaf: what's Fix?
01:20:21 <shachaf> @src Fix
01:20:21 <lambdabot> Source not found. stty: unknown mode: doofus
01:20:24 <maus_> mm_freak_, yeah, on a lowest level you basically need to parse the memory of a process and simulate user activity to it.
01:20:25 <shachaf> @src Mu
01:20:25 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
01:20:26 <startling> mikeplus64: nope! I wan't a weird-ass tree
01:20:28 <shachaf> That's Fix.
01:20:51 <startling> shachaf: oh, isn't that what I said?
01:21:06 <shachaf> startling: Right.
01:21:07 <maus_> mm_freak_, but that's a dull part. I was more interested in a AI-related stuff
01:21:12 <startling> shachaf: where do I get it?
01:21:16 <mm_freak_> maus_: i didn't even think of it that way…  a bot to me is something that connects to the game server itself
01:21:18 <shachaf> Get what?
01:21:32 <mm_freak_> maus_: there is AI going on in the haskell community
01:21:35 <startling> shachaf: Mu. is there a common package that defines it?
01:21:49 <maus_> mm_freak_, it's possible too, but is harder
01:21:50 <startling> with appropriate instances
01:22:11 <Twisol> I'm a bit confused about writing a network data parser. So confused, actually, that I'm having trouble phrasing my question…  Are there any easy-to-understand implementations of some kind of event stream protocol?
01:22:15 <shachaf> startling: Not sure.
01:22:25 <shachaf> startling: But you probably don't *actually* want a stream defined in terms of Mu.
01:22:32 <mm_freak_> Twisol: cloud haskell
01:22:35 <shachaf> startling: Stream is also CoFree Identity, and a bunch of other things.
01:22:39 <startling> shachaf: I don't have a stream, I have a weird tree
01:23:07 <shachaf> Weird :: * -> *
01:23:11 <shachaf> type WeirdTree = Weird Tree
01:23:11 <Twisol> I'm looking to implement a protocol that's basically a stream of events (character data interspersed with annotations), so document parsers like for JSON probably aren't good
01:23:14 <Twisol> mm_freak: will look, thanks
01:23:28 <shachaf> Um, Weird :: (* -> *) -> * -> *, I guess.
01:23:43 <mm_freak_> Twisol: there are many ways to do it
01:24:05 <dmwit> For all x, probably you don't want x in terms of Mu.
01:24:13 <dmwit> You might be forced to to use some API, but I doubt you *want* it.
01:24:58 <dmwit> ?hackage recursion-schemes
01:24:58 <lambdabot> http://hackage.haskell.org/package/recursion-schemes
01:25:22 <dmwit> startling: There you go, Fix, Mu, and Nu.
01:25:28 <startling> dmwit: thanks
01:25:36 <startling> maybe I should explain what I'm doing though
01:26:19 <startling> I want a data Tree k a = Map k (Either a (Tree k a)). Free is close to what I want, but I don't want a leaf by itself to be a valid Tree
01:26:51 <t7> whats Nu and how does it work?
01:27:14 <startling> now I have newtype Tree k a = Tree (Free (Map k) a)
01:27:50 <startling> which is fine, but I have a bunch of partial functions that operate only on the (Free whatever) and not the (Pure whatever)
01:28:01 <startling> so I'd rather encode the "no standalone leaves" thing in the type system
01:28:09 <mm_freak_> recursion-schemes lacks one particularly interesting type
01:28:11 <mm_freak_> Free =)
01:28:31 <startling> so is Mu what I want here?
01:29:03 <rking> OK, I keep trying not to ask questions until I've read stuff first, but this is killing me:  How do you be pure FP for things that are entirely supposed to have side effects, like interacting with the filesystem?
01:29:13 <scshunt> rking: The IO monad
01:29:18 <rking> Is there maybe some filesystem-replacement idea that is functional-approved?
01:29:19 <startling> rking, you construct a computation rather than doing the computation
01:29:46 <startling> (in this instance, you use the IO monad)
01:29:50 <rking> I mean, where's the referential transparency in reading 16 bytes from /dev/urandom ?
01:29:56 <scshunt> you compose, in pure FP, a series of instructions on how to perform a calculation, and then output that
01:29:59 <rking> Or for reading stdin.
01:30:00 <scshunt> which is run in a non-pure manner
01:30:04 <lpvb> rking: http://learnyouahaskell.com/input-and-output
01:30:13 <scshunt> putStr is a pure function
01:30:23 <lpvb> http://book.realworldhaskell.org/read/io.html
01:30:26 <scshunt> putStr produces an IO object which will read in a string
01:30:41 <scshunt> err
01:30:44 <scshunt> write out a string
01:32:01 <mm_freak_> scshunt: "object"?
01:32:20 <mikeplus64> rking: the only thing you can tell from something performing IO is that it performs IO, and what you should end up getting (e.g. getLine returns a IO String)
01:32:44 <mm_freak_> rking: a value of type IO String is the operation that performs something and results in a string…  you never actually run such an action, you just compose these actions
01:33:13 <nand`> “you can never actually run such an action” well you can assign it to main
01:33:19 <nand`> that's about it
01:33:26 <mm_freak_> so an IO String is note "an impure string", but rather no string at all…  it's the description of the operation that results in a string
01:33:40 <startling> rking: by writing the program, you create a dependency graph of these computations (some of which call your pure functions) which is then compiled into an executable
01:33:41 * mikeplus64 whispers unsafePerformIO
01:33:42 <mm_freak_> s/note/not/
01:33:50 <shachaf> @quote /bin/ls
01:33:51 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
01:33:57 <startling> ha
01:34:04 <startling> I like that
01:34:39 <scshunt> mm_freak_: a something
01:34:41 <typoclass> rking: basically in haskell, a list of IO actions is constructed at compile-time (purely and FPly and all that). the "list" then gets run at runtime, and you're right that this involves side-effects. it's not exactly a list, and there's some more subtlety to it, but that's how the pure part and the IO part relate, in my view
01:35:12 <startling> btw, can anyone think of a catchy name for my weird trees? they're labelled rose trees
01:35:15 <scshunt> I like the ls anaology
01:36:31 <startling> would anyone hurt me if I called them Tuliptrees?
01:36:49 <RawProduce> yes
01:36:54 <mm_freak_> scshunt: a value =)
01:37:02 <shachaf> What's labelled rose tree?
01:37:08 <rking> Guys: Thank you.
01:37:13 <scshunt> mm_freak_: an "IO value" doesn't sound rihgt
01:37:18 <mm_freak_> scshunt: but it is
01:37:21 <startling> shachaf: a rose tree with maps instead of lists
01:37:25 <mm_freak_> a value of type IO String is an operation
01:37:26 <shachaf> Except if you believe the report!
01:37:26 <scshunt> it would be like saying a "function value"
01:37:34 <shachaf> scshunt: A function is also a value.
01:37:37 <scshunt> shachaf: sure
01:37:46 <scshunt> but "function value" doesn't sound right all the same
01:37:48 <nand`> startling: an association list, rather
01:37:50 <mm_freak_> scshunt: if you have trouble with "value", think of IO operations as recipes…  those are certainly values
01:37:50 <shachaf> You can call it an "IO action" if you want.
01:37:53 <startling> nand`: sure why not
01:37:55 <mm_freak_> and i have no trouble with "function value" either
01:37:57 <shachaf> But it still *is* a value.
01:38:01 <scshunt> mm_freak_: I am well aware of what IO is
01:38:03 <rking> So what about my question about doing something other than a filesystem-like thing?  Couldn't you be more FP-pure if you somehow stored data in a completely different paradigm?
01:38:05 <nand`> startling: (maps are sorted based on key)
01:38:16 <rking> No wait, any user input would taint the thing anyway.
01:38:20 <mm_freak_> scshunt: i'm sure you are, but you shouldn't have trouble with IO "values" =)
01:38:21 <startling> nand`: well, these are unordered
01:38:31 <scshunt> rking: yeah, any interaction with the outside environment is non-pure
01:38:39 <shachaf> nand`: Why are you telling startling what the type of startling's tree is?
01:39:07 <nand`> I'm telling him what a ‘labelled rose tree’ would be
01:39:11 <mm_freak_> rking: storage itself is impure
01:39:12 <nand`> a rose tree with labels on the branches
01:39:13 <scshunt> mm_freak_: I don't like saying "IO value". There are no values of type IO, and second, I just don't like it ;)
01:39:21 <frerich> rking: FWIW, another analogy I like to use is to consider IO actions to be similiar to Java runnables. They are pure by themselves, but running them (which eventually happens when the run-time system runs 'main', which in turn runs all the actions it consists of) may have side effects.
01:39:23 <rking> I think I might've made a blunder by hating C++/Java's types then assuming all static typing was detestable.
01:39:24 <startling> nand`: oh, I see your point
01:39:33 <startling> no, these aren't labelled rose trees, then
01:39:34 <scshunt> rking: haha
01:39:36 <mm_freak_> scshunt: IO String value ;)
01:40:00 <shachaf> According to the Report, getLine is a function.
01:40:24 <nand`> shachaf: where?
01:40:38 <mm_freak_> i'd consider that a bug in the report
01:40:42 <paolino> hello, which are the condition for this function to give me a lazy list instead of looping forever ? http://hpaste.org/73616
01:40:50 <shachaf> nand`: http://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1450007.1
01:40:58 <Twisol> it's possible to look at IO x as a function of World -> x, even if that's not completely accurate
01:41:09 <mm_freak_> paolino: which monad?
01:41:34 <startling> Twisol: State World x, maybe
01:41:46 <paolino> mm_freak_, I tested in IO
01:41:55 <paolino> it's MonadRandom m
01:41:58 <shachaf> Twisol: No. :-(
01:41:58 <mm_freak_> paolino: IO is the monad in which this won't work =)
01:42:00 <shachaf> startling: No. :-(
01:42:07 <paolino> mm_freak_, :-)
01:42:20 <mm_freak_> paolino: try in the Identity monad
01:42:25 <startling> shachaf: maybe in an alternate universe
01:43:20 <mm_freak_> paolino: the problem with the monads is context…  say you would actually produce a lazy list in the Maybe monad
01:43:47 <mm_freak_> paolino: now imagine that some element much later in the list won't be computed, because the corresponding computation is Nothing
01:43:51 <mm_freak_> then the whole list is Nothing
01:43:56 <mm_freak_> same with IO and exceptions
01:44:12 <mm_freak_> so the result of your function indirectly depends on the end of the list all the time
01:44:56 <mm_freak_> monads without context are the only ones, where this can work
01:44:57 <shachaf> The problem is effects in general.
01:44:59 <mm_freak_> Identity and Writer
01:45:21 <shachaf> mm_freak_: "monads without context" -- is there a name for those?
01:45:21 <mm_freak_> it should work in Writer, too
01:45:35 <shachaf> Maybe "commutative+affine" or something?
01:45:35 <mm_freak_> good question
01:45:40 <paolino> mm_freak_, I suppose State is ok
01:45:44 <mm_freak_> they don't have to be commutative
01:45:53 <mm_freak_> paolino: lazy state might work
01:45:56 <quicksilver> you can generate infinite lists from state
01:46:02 <mm_freak_> paolino: but never ask for the final state =)
01:46:03 <quicksilver> as long as you don't inspect the state value.
01:46:06 <shachaf> Oh, yes.
01:46:16 <paolino> ok
01:46:32 <paolino> the Maybe is not clear actually
01:46:41 <quicksilver> you can generate them in most monads if you do so in a way which doesn't actually have infinite effects
01:46:59 <quicksilver> e.g. return [1..]
01:47:18 <quicksilver> but (sequence $ map Just [1..]) won't work
01:47:19 <mm_freak_> paolino: in the Maybe monad if any component computation results in Nothing, then the whole computation results in Nothing
01:47:25 <quicksilver> because it has to keep looking for that nothing.
01:47:54 <mm_freak_> paolino: imagine that your ritmoStream produces 10000 elements, but then results in a Nothing
01:48:00 <quicksilver> so the questions are "are you asking for an infinite effect" and "do the semantics of the monad force that entire infinite effect before the first value?"
01:48:04 <mm_freak_> paolino: then the whole thing will result in Nothing
01:48:51 * paolino puts quicksilver in the left channel and mm_freak_  in the right and relax 
01:49:11 <mm_freak_> paolino: does your ritmoStream ever produce a Nothing?  it doesn't…  you know that, but haskell doesn't…  to produce an infinite list in the first place it has to ask whether there is a Nothing anywhere throughout the computation of the list…  otherwise reading the first element would potentially be a paradox
01:49:42 <mm_freak_> > liftA3 (,,) (Just 1) (Just 2) (Just 3)
01:49:43 <lambdabot>   Just (1,2,3)
01:49:44 <mm_freak_> fine
01:49:49 <mm_freak_> > liftA3 (,,) (Just 1) (Just 2) Nothing
01:49:50 <lambdabot>   Nothing
01:49:54 <mm_freak_> now as for the first element
01:50:20 <paolino> ok, I suppose randomRs is defined in another way so
01:50:38 <paolino> in IO
01:51:36 <mm_freak_> no, it's simply unsafe and operates under the assumption that it will never throw an exception
01:51:46 <mm_freak_> wait
01:52:04 <mm_freak_> there is no randomRs for IO =)
01:52:23 <mm_freak_> but consider 'readFile "/dev/urandom"'
01:52:32 <mm_freak_> that one produces a lazy infinite list…  potentially
01:52:56 <mm_freak_> readFile makes the dangerous assumption that it will never fail and just ignores failure…  it uses unsafeInterleaveIO under the hood
01:53:09 <mm_freak_> ah no, it doesn't ignore anymore
01:53:20 <mm_freak_> but you might find pure code throwing an exception, which wouldn't otherwise
01:54:00 <paolino> I have getRandomRs in IO
01:54:51 <paolino> *Supercollider> a <- getRandomRs (0,1)
01:55:02 <paolino> a :: [Integer]
01:55:15 <Twisol> How should I structure a parser using the Pipes library? I'm getting stuck on the fact that there's no 'peek' operation, I think.
01:55:37 <paolino> but yes I mostly understand the situation
01:56:36 <mm_freak_> paolino: that must be an unsafe operation…  every IO action that produces a lazy list must be unsafe for operating under assumptions
01:56:57 <mm_freak_> of course 'return' by the monad laws is guaranteed not to have effects, so sometimes the assumptions can be safe
01:57:02 <startling> so where should I get bifunctor from? category extras?
01:57:02 <mm_freak_> but then you don't need IO in the first place
01:57:09 <mm_freak_> startling:
01:57:14 <mm_freak_> @hackage bifunctors
01:57:14 <lambdabot> http://hackage.haskell.org/package/bifunctors
01:57:41 <startling> oh, category-extras is the obsolete one
01:57:44 <startling> mm_freak_: thanks
01:57:46 <mm_freak_> Twisol: pipes are not for parsing, but for streaming…  you would normally have a parser sink
01:57:50 <bas__> lambdabot (pl) often suggest the use of liftM2, but when I try to use it I get an error like "No instance for (Monad ((->) Board)) arising from a use of `liftM2'
01:58:04 <nand`> import Control.Monad.Instances
01:58:06 <mm_freak_> bas__: import Control.Monad.Instances
01:58:24 <bas__> thanks :}
01:58:42 <paolino> mm_freak_, so the solution is getting a seed in IO and eval an iterateM in state random monad with that seed ?
01:59:07 <Twisol> mm_freak_: I think that's what I'm trying to do right now. I have a Consumer of Chars that I plan on using from another pipe, sort of like how await is used.
02:00:04 <mm_freak_> paolino: depends…  if the stream actually needs to be generated in IO you should use some form of coroutines…  either some simple stream abstraction or a free monad
02:00:23 <Peaker> hey, can anyone think of a nice way to do:   Map (Maybe a) b -> Map a b?
02:00:30 <Peaker> (without going through list?)
02:00:43 <paolino> mm_freak_, I make my experiments , thanks
02:00:46 <mm_freak_> Peaker: well, there is mapKeys
02:00:47 <bas__> is there a way to write and if-then-else statement pointfree?
02:00:48 <Twisol> ergh, nevermind - don't think I can do that. >_<
02:00:54 <bas__> an*
02:00:56 <Peaker> mm_freak_, What do you map Nothing to?
02:01:06 <Peaker> @hoogle mapKeys
02:01:06 <lambdabot> Data.Map mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
02:01:06 <lambdabot> Data.Map mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
02:01:06 <lambdabot> Data.Map mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
02:01:11 <nand`> bas__: lambdabot's @pl uses if' but that's not a standard function
02:01:22 <Twisol> bas__: let if' pred t f = if pred then t else f
02:01:23 <startling> @pl \x -> if x == 12 then 13 else 14
02:01:23 <lambdabot> flip (flip if' 13 . (12 ==)) 14
02:01:30 <startling> @src if
02:01:31 <lambdabot> Source not found.
02:01:32 <startling> @src if'
02:01:33 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
02:01:36 <Twisol> Ha
02:01:47 <nand`> Twisol already gave it
02:01:54 <Peaker> the nicest way I can think of for now is:   Map.fromList . mapMaybe f . Map.toList
02:01:55 <paolino> lambdabot secrets
02:02:05 <ivanm> or you can use the fold over Bool: bool f t p = if p then t else f
02:02:07 <bas__> so where does lambdabot get it from?
02:02:15 <startling> nand`, Twisol: oh oops / thanks
02:02:19 <nand`> bas__: it's defined locally in lambdabot
02:02:19 <Palmik> Hi guys, is it somehow possible to nest quasi quotes?
02:02:19 <ivanm> bas__: predefined in lambdabot's DB
02:02:24 <bas__> okay :}
02:02:30 <mm_freak_> Peaker: one way is to do:   Map (Maybe k) a -> Map k (Maybe a)
02:02:33 <mm_freak_> Peaker: then filter
02:02:38 <shachaf> lambdabot doesn't have it.
02:02:51 <Peaker> mm_freak_, how can you do that?
02:03:21 <Peaker> mm_freak_, all the functions that let you change the key type don't let you get rid of any key
02:03:41 <mm_freak_> Peaker: apparently there is no way to do that map directly =/
02:03:59 <mm_freak_> Peaker: another way is to filterWithKey out all the Nothing keys
02:04:05 <mm_freak_> or, well, /the/ Nothing key =)
02:04:13 <Peaker> mm_freak_, and then use "fromJust"? :(
02:04:16 <mm_freak_> then simply mapKeys fromJust
02:04:18 <mm_freak_> yeah
02:04:22 <mm_freak_> it's ugly, but it would work
02:04:32 <paolino> mm_freak_, incidentally there is evalRandIO in the Control.Monad.Random, so  evalRandIO (ritmoStream Play) just works
02:04:33 <mm_freak_> anyway, i'm sure going through a list will be faster than that
02:04:36 <nand`> or you could simply remove Nothing
02:04:59 <mm_freak_> notice that there is fromDistinctAscList
02:05:00 <Peaker> mm_freak_, theoretically, due to Maybe a and a being monotonic w.r.t Ord (and Nothing is gone), it could avoid rebuilding the whole Map
02:05:24 <mm_freak_> M.fromDistinctAscList . catMaybes . M.toList
02:05:28 <ivanm> Peaker: mapMonotonic?
02:06:17 <Peaker> ivan, doesn't let me get rid of the "Maybe" wrapper (and Nothing keys)
02:06:29 <mm_freak_> you would have to benchmark, but follow nand`s suggestion…  there can only be one Nothing key
02:06:44 <ivanm> Peaker: I meant rather than using fromDistinctAscList . catMaybes . toList
02:06:54 <mm_freak_> M.mapKeys fromJust . M.delete Nothing
02:07:13 <Peaker> my real scenario actually involves a different type than (Maybe a) but the principle is similar. more than one key can have no "a" in it though, and the new map needs the "a"s only
02:07:32 <ivanm> mapKeysMonotonic is what I meant
02:07:52 <nand`> he can't use a map
02:07:54 <Peaker> ivan, I would want: mapMaybeKeysMonotonic
02:08:09 <ivanm> Peaker: I meant after you get rid of the Nothing
02:08:33 <Peaker> nand`, I'd rather avoid partiality though
02:08:39 <Peaker> oops, ^ivanm
02:08:47 <Peaker> I guess just going through list is ok
02:08:47 <ivanm> *nod*
02:09:12 <nand`> enumeration is linear time, and fromDistinctAscList should be linear time too, right?
02:09:19 <ivanm> yeah
02:09:20 <ivanm> you can't use mm_freak_'s catMaybes solution as is though
02:09:30 <ivanm> you first need to turn (Maybe a, b) into Maybe (a,b)
02:09:47 <nand`> sequence
02:09:57 <nand`> I think
02:10:18 <nand`> > Data.Traversable.sequence (Just 3, 4)
02:10:19 <lambdabot>   No instance for (GHC.Show.Show (m (Data.Maybe.Maybe t, a)))
02:10:19 <lambdabot>    arising from...
02:10:34 <ivanm> @free (Maybe a, b) -> Maybe (a,b)
02:10:34 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
02:10:36 <ivanm> bah
02:10:40 <nand`> oh, right; wrong side of the tuple
02:11:03 <ivanm> @pl \ (ma, b) -> fmap (flip (,) b) ma
02:11:03 <lambdabot> uncurry (flip (fmap . flip (,)))
02:11:09 <ivanm> ^^ one way of doing it
02:12:14 <Spark21> Is there a known bug of a compiled program behind bad for ghci?
02:13:08 <bitonic> Spark21: what?
02:13:27 <Spark21> let me get a testcase
02:13:31 <ivanm> I'm using a State monad whilst doing a graph traversal
02:14:50 <ivanm> I'm outputting a serialised form of the traversal, which works... but suddenly if I include using any of the state variables and using them afterwards (e.g. to get the next component), laziness seems to be chucked out of the window and my sample program takes about 2.5 times as long :s
02:15:57 <Spark21> Ok, so I got this code ( http://hpaste.org/73617 ) . I know I did something wrong with my definition of aux buuut it compiles. when executing nothing happens. when loading on ghci, I can'ttypecheck my functions . Is this because of the pattern matching overlaping , so ghci wont load it?
02:16:22 <ivanm> Spark21: are you _sure_ it's compiling?
02:16:43 <Spark21> [1 of 1] Compiling Main             ( test.hs, test.o )
02:16:44 <ivanm> and your definition of aux is a bit weird; the third case is redundant :/
02:16:51 <Spark21> gives only a warning
02:16:55 <Spark21> and links
02:17:09 <ivanm> huh
02:17:17 <belgin> can someone please explain to me why Maybe a is defined as Nothing | Just a and not Nothing | a ? What's the point of the Just?
02:17:17 <ivanm> oh, wait, is your error to do with Gtk?
02:17:22 <Spark21> oh, wait, on the new file now i get a runtime error
02:17:37 <bas__> Have any Haskell chess engines been written? (competitive with top engines)
02:17:38 <ivanm> belgin: because you need a constructor to specify the non-Nothing case
02:17:59 <ivanm> belgin: consider a data type like: data MyEither a = MyLeft a | MyRight a
02:18:11 <ivanm> if we didn't use constructors, then how would you differentiate the two `a' sub-types?
02:18:17 <ivanm> bas__: check hackage?
02:18:30 <bas__> I've searched around yeah
02:18:41 <ivanm> then it probably means there isn't any :)
02:18:55 <ivanm> @google haskell chess engine
02:18:57 <lambdabot> http://www.steffen-mazanek.de/blog/2007/02/haskell-chess.html
02:18:57 <lambdabot> Title: Informatik-Praxis: Haskell: Chess
02:19:10 <Spark21> oh wait, it doesnt give a run time error, I just forgot to give the argument to run the program
02:19:20 <Spark21> so yeah, it compiles but ghci wont load it
02:19:32 <ivanm> Spark21: by "load" you mean "ghci Foo.hs" doesn't work?
02:19:37 <ivanm> or that you can't run it in ghci?
02:19:56 <Spark21> it loads
02:20:03 <Spark21> but if I try any definition
02:20:06 <Spark21> they arent there
02:20:22 <ivanm> Spark21: because the .o and .hi files are there from compiling it
02:20:33 <ivanm> so it's using the pre-compiled object files
02:20:42 <ivanm> and thus treating the file as a compiled module
02:21:00 <ivanm> touch Foo.hs && ghci Foo.hs
02:22:06 <startling> @hackage errors
02:22:07 <lambdabot> http://hackage.haskell.org/package/errors
02:22:16 <Spark21> i expect touch to be something from unix, im on windows D:
02:22:33 <ivanm> Spark21: in that case, make a useless change to the file and save it
02:22:41 <ivanm> just to force it to be "newer" than the compiled files
02:22:45 <ivanm> or delete the .o and .hi files
02:23:11 <Spark21> just did it
02:23:21 <Spark21> oh, i got main> in place of prelude main>
02:23:26 <Spark21> should be working, thanks!
02:23:47 <ivanm> and if you're not going to use Cabal to compile your work, consider using -hidir and -odir to avoid this problem in future
02:23:56 <Spark21> hmmm
02:24:01 <Spark21> okk ty
02:24:20 <Spark21> now to figure out where I messed up my code
02:25:14 <ivanm> how can I test if lack of laziness from the State monad is indeed causing my slow-down? (even something like using seq to force whether or not a Map is empty or not causes it to slow down :s)
02:30:03 <jinblack> Hi to everybody
02:30:13 * ivanm waves idly in jinblack's general direction
02:30:57 <jinblack> how can i use :t to determinate a type of something on runtime
02:31:11 <jinblack> i want to write something like "take n [y| y <- randomRs (minBound,x) gen]"
02:31:26 <ivanm> jinblack: you can't
02:31:30 <ivanm> that's the point of type annotations
02:31:40 <ivanm> and why use the list comprehension? :/
02:32:07 <ivanm> @type \ n x gen -> take n $ randomRs (minBound,x) gen
02:32:08 <lambdabot> forall a g. (Bounded a, Random a, RandomGen g) => Int -> a -> g -> [a]
02:32:27 <ivanm> jinblack: ^^ add a type signature saying what `a' should be
02:33:20 <mm_freak_> jinblack: [ x | x <- xs ] = xs
02:33:45 <jinblack> but i want to make a general function I don't wanna fix the type
02:34:09 <mm_freak_> jinblack: general in what sense?  your expression has already a general type
02:34:12 <jinblack> that's the sing of my function : diffSelect :: Ord a => Int -> a -> IO [a]
02:34:36 <ivanm> jinblack: if you want to use minBound, then you need to have Bounded there with Ord
02:34:39 <ion> Hmm. “[ x, x | x <- xs ]” should be equal to “do x <- xs; [x, x]”?
02:34:45 <ivanm> (and I'm not sure that Ord is needed)
02:34:53 <ivanm> you also need to specify Random
02:34:55 <ion> Err, s/\?/./
02:35:05 <mm_freak_> is that syntatically valid?
02:35:11 <shachaf> ion: Should it?
02:35:12 <mm_freak_> > [ x, x | x <- [1..3] ]
02:35:13 <lambdabot>   <no location info>: parse error on input `|'
02:35:15 <ivanm> ion: can you just have "x, x" like that ?
02:35:18 <shachaf> ion: MonadComprehensions, man.
02:35:37 <ion> ivanm: “should”
02:35:41 <ion> shachaf: Darn.
02:35:57 <mm_freak_> > [ x | x <- [1..3], [(), ()] ]
02:35:58 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
02:35:58 <lambdabot>         against inferred type ...
02:36:02 <mm_freak_> > [ x | x <- [1..3], y <- [(), ()] ]
02:36:03 <lambdabot>   [1,1,2,2,3,3]
02:36:20 <shachaf> ion: Next you'll say it should be return x `mplus` return x
02:36:27 <mm_freak_> > concatMap (\x -> [x, x]) [1..3]
02:36:27 <ion> heh
02:36:28 <lambdabot>   [1,1,2,2,3,3]
02:36:31 <ivanm> > concatMap (replicate 2) [1..3]
02:36:32 <lambdabot>   [1,1,2,2,3,3]
02:37:20 * ivanm gets back to banging his head against State acting weirdly
02:38:38 <jinblack> ivan, in this way works (diffSelect :: (Ord a,Bounded a,Random a)  => Int -> a -> IO [a]) but why i need Random is it for randomRs?
02:38:53 * hackagebot language-puppet 0.1.7 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.1.7 (SimonMarechal)
02:38:55 <mm_freak_> jinblack: yeah
02:39:35 <ivan> contrary to popular belief, I am not ivanm
02:39:41 <startling> @hoogle Either a b -> Either b a
02:39:42 <lambdabot> Network.Stream bindE :: Result a -> (a -> Result b) -> Result b
02:39:42 <lambdabot> Data.Graph.Inductive.Basic unlab :: DynGraph gr => gr a b -> gr () ()
02:39:42 <lambdabot> Data.Graph.Inductive.Graph gmap :: DynGraph gr => (Context a b -> Context c d) -> gr a b -> gr c d
02:39:47 <ivanm> ivan: heh
02:40:10 <ivanm> jinblack: because you need to say that only values which can have random values generated can be used with that function
02:40:21 <ivanm> I still don't see why you have Ord there, unless you're doing something else...
02:40:24 <ivanm> @type randomRs
02:40:25 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
02:40:27 <jinblack> K work with out Ord is it cause Bounded is cointeint in Ord? How can i check something like that?
02:40:39 <ivanm> jinblack: huh?
02:41:05 <jinblack> diffSelect :: (Bounded a,Random a)  => Int -> a -> IO [a] that is the final sing
02:41:18 <startling> what would it take to have a flip function on bifunctor-like structures? is bifunctor enough?
02:41:19 <ivanm> jinblack: so, why are you doing that in IO though?
02:41:50 <startling> e.g, turn (a, b) into (b, a) and Either a b to Eiher b a
02:42:08 <ivanm> startling: well, I believe Data.Tuple now has a "swap" function for the former... :p
02:42:21 <startling> ivanm: yeah, I'm just wondering how you could do it in general
02:42:41 <ivanm> *shrug*
02:43:29 <HugoDaniel> hey
02:43:32 <HugoDaniel> :)
02:43:49 <jinblack> ivanm, I use IO cause I used random how it is should be done?
02:44:10 <mm_freak_> jinblack: random doesn't require IO
02:44:24 <mm_freak_> :t randomRs
02:44:25 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
02:44:31 <ivanm> jinblack: you use newStdGen in your IO code to get a RandomGen value, and then pass that around in your code to where you need to do the actual random value calculation
02:44:36 <tdammers> you need IO to *create* a RNG, but not to use it
02:45:08 <ivanm> you can use a supply monad or an explicit state monad to pass the seed around if it makes your code easier
02:45:32 <mm_freak_> i have a totally different way to pass random number generators around
02:45:56 <mm_freak_> myComp :: (forall a. (Random a) => (a, a) -> m a) -> m X
02:46:05 <mm_freak_> myComp :: (Monad m) => (forall a. (Random a) => (a, a) -> m a) -> m X
02:46:09 <jinblack> that's my final script http://pastebin.com/v8KnVz3Z should I take over IO ?
02:46:11 <mauke> The paste v8KnVz3Z has been copied to http://hpaste.org/73619
02:46:55 <mm_freak_> jinblack: that code doesn't require IO at all, and the base case isn't necessary either
02:47:02 <mm_freak_> jinblack: write the type siganture first
02:47:05 <ivanm> mm_freak_: wait, where does the RandomGen come into it?
02:47:22 <ivanm> jinblack: you don't need the separate 0 case either
02:47:26 <ivanm> > take 0 [1..]
02:47:27 <lambdabot>   []
02:47:36 <ivanm> > take (-3) [1..]
02:47:37 <lambdabot>   []
02:47:41 <mm_freak_> ivanm: it doesn't
02:47:54 <mm_freak_> ivanm: myComp randomRIO
02:48:01 <ivanm> mm_freak_: so how do you pass the seed around then?
02:48:01 <mm_freak_> ivanm: myComp getRandomR = …
02:48:06 <mm_freak_> you don't =)
02:48:06 <ivanm> ahhh, you use IO...
02:48:11 <mm_freak_> not necessarily
02:48:25 <mm_freak_> this is just the IO variant, but you can also use State with a generator
02:48:29 <ivanm> *nod*
02:49:37 <mrotondo> > randomIO
02:49:38 <lambdabot>   Ambiguous type variable `a' in the constraints:
02:49:38 <lambdabot>    `System.Random.Random a'...
02:49:51 <mrotondo> why doesn't this work: zip (replicateM 10 randomIO) (replicateM 10 randomIO)
02:50:29 <shachaf> mrotondo: Because look at the types.
02:50:45 <mrotondo> :( I was expecting a list of tuples of IO actions
02:50:56 <shachaf> That would be plain old replicate.
02:51:22 <mrotondo> er right, got it
02:51:25 <mrotondo> thanks
02:51:40 <timthelion> Is there *any* preformance/memory usage difference between using Bool everywhere and a whole bunch of nicely named data Choice = Be | NotToBe s?
02:51:52 <mm_freak_> timthelion: no
02:52:05 <timthelion> cool.  My code will be readable then :D
02:52:06 <shachaf> Better yet is not to use Bool *or* an isomorphic type, though.
02:52:06 <hiptobecubic> well , is that a parametric NotToBe?
02:52:09 <shachaf> Because Bool is evil.
02:52:15 <ivanm> I don't think there's any real optimisations GHC does or can do with Bool
02:52:17 <shachaf> hiptobecubic: No, it's a plural.
02:52:18 <ivanm> shachaf: oh? why?
02:52:22 <shachaf> @google boolean blindness
02:52:24 <lambdabot> http://existentialtype.wordpress.com/2011/03/15/boolean-blindness/
02:52:24 <lambdabot> Title: Boolean Blindness « Existential Type
02:52:33 <ivanm> oh, because who knows wtf that Bool there means?
02:52:43 <ivanm> newtype over Bool! :p
02:52:54 <shachaf> ivanm: No, because it relies on you doing proofs in your code.
02:53:08 <shachaf> Which the compiler can't check.
02:53:09 <ivanm> OK, I'm remembering the wrong blog post then :p
02:53:14 <shachaf> map f l = if null l then [] else f (head l) : map f (tail l)
02:53:17 <shachaf> map f l = case l of [] -> []; (x:xs) -> f x : map f xs
02:53:25 <shachaf> Well, it's that too.
02:53:33 <shachaf> Bool is all sorts of evil.
02:53:47 <mm_freak_> in a functional language bool is evil
02:54:05 <mm_freak_> and it's amazing how little you actually need it
02:54:08 <shachaf> It's evil in a lot of languages.
02:54:10 <ion> shachaf: What should be type of a == b? data Equality = NE | EQ?
02:54:16 <ivanm> shachaf: so how do you deal with something like Data.Map.null then?
02:54:18 <shachaf> Sometimes you have alternatives, though.
02:54:27 <shachaf> ion: The question is whether you need to == in the first place.
02:54:36 <ivanm> every single type with non-exported constructors needs to define a custom data type to denote whether it is empty or not?
02:54:39 <shachaf> ivanm: I'd rather you avoid it if you can?
02:54:42 <mm_freak_> ion: the type should still be Bool, but you probably shouldn't use (==) in the first place
02:54:45 <shachaf> ivanm: You can use a view pattern or something.
02:55:05 <shachaf> mapSmallestElem :: Map k a -> Maybe a -- no need for a custom type.
02:55:06 <timthelion> mm_freak_: the only trouble, is the functions like any, which only work on Bools.  Maybe I'll create a "Booleanish" type class and equivalent functions for them?
02:55:23 <ivanm> shachaf: how about configuration about which of two behaviours you want to do?
02:55:42 <ivanm> e.g. should I restart counting for every new component in this traversal
02:55:51 <shachaf> ivanm: I don't know, man! I can't give you a localized change to make.
02:56:04 <mm_freak_> timthelion: it's not about the Bool type specifically, it's about boolean operations
02:56:13 <shachaf> It's like asking: OK, you say I don't want to use null. So I should have map f l = if ??? then ... else ...
02:56:17 <ivanm> I can see the argument for _minimising_ usage of Bool
02:56:19 * timthelion is fostering a slowly growing dread, that haskell really should have typeclascized everything, not just Nums but Bools, Strings, ect.
02:56:31 <shachaf> ivanm: Right, you won't be able to get rid of it completely in Haskell.
02:56:42 <ivanm> timthelion: that way leads to either something like the classy prelude where a lot of people think terms are over-used
02:56:43 <shachaf> ivanm: In Agda I'd rather use propositions than Bools, of course. :-)
02:56:48 <ivanm> or else making stuff so general it's a nightmare to use
02:57:07 <shachaf> So you can have div :: (a :: Int) -> (b :: Int) -> ProofNonZero b -> Int
02:57:13 <shachaf> Or whatever you might have.
02:57:18 <luite> timthelion: you might like the OverloadedStrings extension, that makes string literals polymorphic
02:57:37 <shachaf> timthelion: No, you're wrong.
02:57:43 <shachaf> Sorry. :-(
02:57:58 <ivanm> shachaf: how would you do something like filter then without Bool?
02:58:04 <ivanm> using catMaybes instead?
02:58:06 <timthelion> luite: I looked at the overloaded strings thing. but it seemed like a cludge of ugliness :/  If I want a typeclass I want a typeclass, I don't want a completely new and poorly designed typeclass like syntax.
02:58:31 <ion> > let swap (a,b) = (b,a) in unfoldr (\n -> swap (n `divMod` 10) <$ guard (n /= 0)) 1234567890
02:58:31 <ivanm> timthelion: OverloadedStrings was designed so people can have "foo" :: Text
02:58:31 <lambdabot>   [0,9,8,7,6,5,4,3,2,1]
02:58:38 <timthelion> shachaf: but how do I use functions like any, on a Booleanesque data like the Choice I described above?
02:58:49 <shachaf> timthelion: I don't know what Choice is.
02:59:02 <ivanm> I for one hate the cludge that people like bos use to abuse OverloadedStrings for parsing purposes for SQL query generation, etc.
02:59:03 <shachaf> ivanm: I don't know. It depends on what you're actually doing.
02:59:04 <timthelion> shachaf: data Choice = ToBe | NotToBe
02:59:06 <ion> What’s a nice replacement for the use of Bool in there?
02:59:31 <shachaf> ivanm: The point is that Bool has you keep track of what you're actually doing manually. Instead you should express it in a way that the compiler can understand it.
02:59:38 <mm_freak_> ion: bool is evil, not useless
03:00:03 <shachaf> timthelion: If you're insisting on using Bool functions, any (foo . isToBe) or something.
03:00:13 <shachaf> No need for a type class. Don't get crazy with the type classes.
03:00:15 <ivanm> shachaf: in one case, I generate a lot of graphs with their "starting" edges.  I then have a function that given a graph and a starting edge, it determines whether that edge determines a canonical example of that graph (by doing re-labelling via BFS on every possible edge), and I use that to only keep the graphs + edges that are canonical examples
03:00:17 <mm_freak_> ion: think of all the C functions where you compared to -1 to check for errors
03:00:31 <timthelion> shachaf: perhaps you're right there.
03:00:35 <shachaf> ion: A nice replacement is a divMod that returns a Maybe. :-)
03:00:39 <mm_freak_> or think of hEOF
03:00:42 * frerich thinks "<shachaf>timthelion: I don't know what Choice is." sounds almost apocalyptical
03:01:07 <shachaf> ion: Then you can pattern-match on the Maybe.
03:01:15 <shachaf> ion: This has the advantage that divMod is now always safe.
03:01:30 <timthelion> frerich: luckly we Do know what choice is.  Choice is dictum.
03:01:59 <ion> shachaf: divMod 0 10 will not return Nothing.
03:02:26 <shachaf> ion: Oh, maybe I misread what you said.
03:02:31 <stj> according to shootout.alioth.debian.org, LISP is a bit faster than haskell... but how is that even possible since LISP is dynamically typed? am I missing something here?
03:02:50 <ion> > let swap (a,b) = (b,a) in unfoldr (\n -> swap (n `divMod` 10) <$ guard True) 1234567890
03:02:51 <lambdabot>   [0,9,8,7,6,5,4,3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
03:02:51 <ivanm> stj: it just means that the LISP people bothered to spend more time recently micro-optimising useless benchmarks
03:03:01 <shachaf> Ah, I see.
03:03:22 <ivanm> I believe at least some of which aren't aimed all that well at the FP mindset by stating an algorithm that is primarily imperative in nature that must be used
03:03:26 <srhb> stj: Also, what?
03:03:40 <srhb> stj: Lisp only beats Haskell on one specific setup, in average.
03:03:41 <RebelBunny> Given a large enough n, all your programs will halt
03:03:58 <srhb> stj: Which is one core 64 bit. All the other shows Haskell beating Lisp.
03:04:31 <srhb> stj: And where Lisp beats Haskell, on average, it is by such a small margin that they are basically equal.
03:04:42 <shachaf> stj: What do types have to do with it?
03:04:52 <stj> oh I see, sorry about that
03:05:01 <Guest42011> Hi, I have a question about Concurrent Haskell. Given a Thread ID, is it possible to query its status? For example, if it is currently blocked on an mvar. I have found nothing about it, so I guess it's not possible.. I just wanted to be sure
03:05:04 <shachaf> For that matter, languages aren't fast. Implementations (of languages + programs) are fast.
03:05:12 <shachaf> Guest42011: Not really.
03:05:25 <shachaf> Guest42011: You probably should be finding another way to express what you're doing.
03:05:32 <stj> shachaf: well, I find it difficult to imagine what kinds of optimizations and assumption a compiler can make in a dynamically typed language
03:05:48 <srhb> stj: http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=ghc&lang2=sbcl also note how even on that setup, Haskell uses far less memory in most cases and less code in some of them, but never more.
03:05:49 <shachaf> stj: Did you look at the source of the Lisp programs?
03:06:03 <srhb> stj: But it's way more interesting looking at the multicore programs
03:06:28 <stj> shachaf: not in depth
03:06:30 <Guest42011> shachaf: thanks, I'm trying to build a particular kind of scheduler for Haskell threads for distributed algorithms
03:07:04 <Guest42011> shachaf: I'll find out something else :)
03:07:23 <mm_freak_> the problem with the shootout is that they are not posing problems, but solutions
03:07:26 <timthelion> Guest42011: Well if you have multiple conditions that you want to fill before you schedual something, don't use an external schedualar, but make implicit schedualing using STM conditions.
03:07:34 <hardc0de> newbie on algorithm: split x l = ([y|y<-l,y<=x], [y|y<-l, y>x]), a function which split a list of numbers comparing to number x. How can I define a similar function that operates in just on pass?
03:07:44 <shachaf> stj: Look at them and you'll probably understand.
03:08:00 <timthelion> @google stm
03:08:03 <lambdabot> http://www.stm-assoc.org/
03:08:03 <lambdabot> Title: STM | International Association of Scientific, Technical & Medical Publishers
03:08:11 <mm_freak_> so i'd ignore the shootout results entirely, even when haskell is the fastest language
03:08:19 <timthelion> hmm
03:08:20 <mm_freak_> they are meaningless
03:08:23 <shachaf> ==mm_freak_
03:08:37 <Guest42011> timthelion: I'm want to avoid STM, I am not sure how it would scale over a network of nodes
03:09:15 <timthelion> Guest42011: I cannot comment on that.  You'd have to ask edwardk, who is not here right now.  He is an expert on that.
03:09:49 <mm_freak_> Guest42011: STM scales as well as you make it scale…  in general it's just as fast as the non-STM solution and sometimes even faster…  only rarely it's slower
03:09:54 <mm_freak_> according to my experience
03:10:03 <ivanm> wait, I thought edwardk was just an expert on creating undocumented structure-based libraries; I didn't realise he was an expert on STM as well!
03:10:03 <Guest42011> timthelion: thanks, maybe I'll try later
03:10:31 <ivanm> mm_freak_: "non-STM solution" == locks, etc. ?
03:10:33 <mm_freak_> ivanm: being an expert in category theory makes you an expert in about everything =)
03:10:37 <ivanm> heh
03:10:39 <timthelion> @seen edwardk
03:10:39 <lambdabot> Unknown command, try @list
03:10:42 <companion_cube> ivanm: or message passing
03:10:51 <timthelion> preflex: seen edwardk
03:10:51 <preflex>  edwardk was last seen on #haskell 4 hours, 5 minutes and 58 seconds ago, saying: just because something might be an error for someone somewhere, i don't see why i should have to waste time round tripping through a huge monad transformer stack to put a () i'm never going to look at in there
03:10:52 <mm_freak_> ivanm: locks, auxilliary threads, etc.
03:10:59 <ivanm> I thought there was some expected slow down with STM vs explicit locks, especially if you use retry
03:11:00 <shachaf> 03:09 <mm_freak_> Guest42011: STM scales as well as you make it scale…  in general it's just as fast as the non-STM solution and sometimes even faster…  only rarely it's slower
03:11:07 <shachaf> That sounds inaccurate.
03:11:20 <mm_freak_> shachaf: it is…  it's an experience report =)
03:11:22 <ivanm> since STM is doing all the logging, etc.
03:11:24 <shachaf> However, the main goal of using STM isn't performance.
03:11:25 <Guest42011> mm_freak_: my understanding of STM is that it is only applicable to one node
03:11:29 <ivanm> shachaf: right
03:11:38 <mm_freak_> Guest42011: yes, it's not distributed
03:11:45 <ivanm> Guest42011: well, it _is_ for concurrency rather than parallelism...
03:12:06 <ivanm> (not saying you can't or shouldn't do concurrency over multiple nodes)
03:12:07 <Guest42011> mm_freak_: yes, that's what I mean
03:12:22 <shachaf> Are you using Cloud Haskell?
03:12:27 <mm_freak_> Guest42011: there is cloud haskell, if you want something like this
03:12:32 <mm_freak_> see the distributed-process package
03:12:41 <Guest42011> I haven't looked into it much for the moment
03:12:45 <srhb> Did you see the latest examples for Cloud Haskell? It's so awesome.
03:12:46 <shachaf> You were talking about MVars. As far as I know TVars should work in any situation where MVars do.
03:13:03 <mm_freak_> shachaf: nope
03:13:12 <mm_freak_> shachaf: expect for hacks like TVar (Maybe a)
03:13:15 <mm_freak_> except
03:13:21 <dmwit> You know the code is good when the first 25 lines are language extensions.
03:13:42 <timthelion> dmwit: good?
03:13:43 <shachaf> mm_freak_: ?
03:13:47 <mm_freak_> TMVar corresponds to MVar, not TVar
03:13:56 <shachaf> mm_freak_: I mean, you won't have a situation where MVars are distributed and TVars aren't.
03:14:05 <shachaf> Not the exact semantics, of course.
03:14:36 <mm_freak_> ah…  not sure…  i think distributed STM has to be implemented separately
03:14:53 <Guest42011> well I mentioned MVars because I'm working on an interpreter at them moment
03:15:12 <Guest42011> on a single machine
03:15:26 <shachaf> mm_freak_: Well, sure. But -- well, maybe I don't udnerstand what Guest42011 is asking.
03:15:30 <Guest42011> I'll definitely look into Cloud Haskell though
03:16:11 <Guest42011> I wanted to know if it is possible to query the state of thread
03:16:32 <Guest42011> which is not, I reckon
03:16:40 <shachaf> Right -- how did that conversation get sidetracked into STM?
03:16:59 <shachaf> It's probably perfectly possible to make an MVar solution to your problem.
03:17:07 <Guest42011> someone mentioned STM conditions
03:17:32 <Guest42011> I see
03:18:11 <timthelion> I did.  It seems to me, that if he's blocking on MVar and also waiting for a condition sent by a thread schedualer. Than what he really wants, is to block orElse on TMVar and wait for either the MVar or the scheduler to ask about him.
03:19:12 * shachaf gives up on conversation.
03:19:20 <timthelion> Get it?  takeTMvar foo `orElse` respondToRequestForInfoFromSchedulerAndTellTheSchedulerThatWe'reCurrentlyBlockingOnTMVar...
03:19:36 <timthelion> Guest42011: that is the same as being able to query a threads status...
03:20:39 <Guest42011> so you would put a sort of recursive call in the orElse part
03:20:53 <Guest42011> so that after contacting the scheduler you would block again
03:21:22 <merijn> Why not have "MVar (Either Foo SchedulerEvent)" and have both things write to the same MVar?
03:21:37 <timthelion> Guest42011: No.  orElse does some magic that it can wait for either one of two or more condtions to be true.  So in this case, it would wait for either the TMVar to be filled, or the scheduler to ask something.
03:21:38 <merijn> Although I guess that could block the scheduler
03:21:53 <timthelion> merijn: that could also work.
03:22:17 * timthelion wasn't trying to say that MVar's cannot do it, jus that he thought that STM might do this elegantly...
03:22:36 <Guest42011> but sending the information to the scheduler should not interrupt what the thread was doing
03:23:05 <timthelion> Guest42011: Then you would make it recursive yes. Sorry, didn't think of that.
03:23:21 <Guest42011> ok I see
03:23:33 <Guest42011> thanks merjn, didn't think of that
03:24:16 <timthelion> Guest42011: so: f = takeTMvar foo `orElse` respondToScheduler >> f
03:24:18 <merijn> Guest42011: In the case the scheduler can be blocked until the worker gets the value inside out first, not sure if that's a problem
03:24:45 <Guest42011> merijn: yes that would be a problem
03:25:01 <Guest42011> merijn: the scheduler should be transparent to threads
03:25:26 <Guest42011> timthelion: ok
03:25:28 <merijn> Guest42011: Should a thread respond to a scheduler *immediately* or just as soon as it's finished the most recent work?
03:25:59 <timthelion> Guest42011: and you realise that the >> is for the STM monad that the whole orElse block is in...
03:26:13 <Guest42011> merijn: well I'd be interested if the thread is stuck
03:26:35 <timthelion> Guest42011: well haskell will throw an exception in that case.
03:26:39 <Guest42011> timthelion: yes :)
03:26:55 <Guest42011> timthelion: in the case of STM right?
03:27:18 <timthelion> Guest42011: no in the case that the thread is blocked indefinitely on an MVar opperation.
03:27:44 <timthelion> Guest42011: you can catch that exception though.
03:28:06 <Guest42011> timethelion: who is it thrown to
03:28:11 <timthelion> So you can have catch handler aBunchOfMVarStuff
03:28:19 <merijn> timthelion: No, it *might* throw an exception
03:28:23 <timthelion> Guest42011: the first thing that chatches it.
03:28:28 <merijn> timthelion: There is no guarantee whatsoever
03:28:44 <merijn> Unless the halting problem happens to have been solved...
03:29:01 <shachaf> You shouldn't rely on BlockedIndefinitelyOnMVar
03:29:03 <timthelion> merijn: Lets not solve that situation untill we come to it, and when we do, then we'll look at the specific case.
03:29:15 <shachaf> What?
03:29:46 <merijn> timthelion: You shouldn't tell people that haskell will throw an exception if a thread is indefinitely blocked on an MVar operation, because that's not ture
03:29:49 <merijn> s/ture/true
03:29:51 <timthelion> Guest42011: Blocked indefinitely relies on a reference counter to the MVar, when the reference count reaches 1 then we know we've blocked or something along those lines.
03:30:37 <Guest42011> I see, but even in that case, the exception would interrupt the blocked thread, right?
03:31:12 <Guest42011> in my case, I would like to do something to "help" the blocked thread to communicate with some other process/node
03:31:36 <timthelion> Guest42011: The exception travels down the semantic tree to the first thing that catches it.  Be that the blocked thread, or the parent/main thread(I'm actually not sure who catches it if the thread doesn't manage to...:/).
03:31:48 <shachaf> You should definitely use a higher-level thing than MVars for this.
03:32:42 <timthelion> Guest42011: well in the case that you CAN "help" it, then you WON'T get an exception.  Think about what I said about reference counters :)  If the reference count is down to 1, then no one has a reference to the MVar in order to help the blocked thread.
03:33:02 <Guest42011> shachaf: you mean that I should wrap up MVars with some extra code to handle information exchange with a scheduler or such
03:33:28 * timthelion thinks that you should design you program such that the threads don't block.
03:33:51 <Guest42011> timthelion: in my scenario, two processes that communicate on different MVar might switch to communicate to the same MVar
03:34:14 * timthelion doesn't follow.
03:34:28 <Guest42011> yeah it's a bit complicated..
03:35:17 <Guest42011> Let's say that two processes want to communicate on channel c
03:35:38 <Guest42011> an abstract, fairy tale channel :D
03:35:49 <Guest42011> but they are too far away and don't know each other
03:36:01 <Guest42011> on one wants to send and the other receive on that channel
03:36:31 <Guest42011> in my case, it would be possible to bring the two processes in the same "room"
03:37:17 <Guest42011> it's a bit weird
03:37:33 <timthelion> Guest42011: well, if you are working on something this convoluted, you better hope to hell you understand it yourself :)  I sure don't :D
03:38:13 <Guest42011> timthelion: that's the beauty of phds :D
03:38:53 <Guest42011> anyway, thanks a lot for the feedback
03:39:10 <Guest42011> I'll surely come back for wierder questions soon :D
03:39:25 <timthelion> Guest42011: You did understand my "solution"?
03:39:41 <Guest42011> I think I did
03:40:07 <Guest42011> I wouldn't want to rely on either STM or Exceptions though
03:40:24 <Guest42011> but I'll keep it in mind
04:09:34 <shachaf> Hmm, the thing Guest42011 asked for *does* exist.
04:09:41 <shachaf> But it's not meant to be used for what they asked for.
04:18:43 <orzo> I'm trying to exempt from qualification the symbol Vec2F exported by Data.Vec.Packed, but I can't figure out how to phrase the import.  Vec2F is declared as a constructor for Packed (Vec2 Float) which is an algebraic type defined within an instance called PackedVec (Vec2 Float)
04:19:38 <shachaf> Exempt from qualification? You mean you want the rest of the module imported qualified but not Vec2F?
04:19:54 <shachaf> If so you'll need two imports.
04:20:08 <shachaf> Oh, you're just trying to figure out how to specify it in the import list?
04:20:13 <orzo> yes
04:20:37 <orzo> (Vec2F) doesnt work (Vec2F(..)) doesnt work, (Packed (..)) doesnt work, ...
04:21:19 <shachaf> You have an associated data type?
04:22:12 <orzo> Well, in the Data.Vec source code, I can see that Vec2F is a constructor for the type Packed (Vec2 Float)
04:22:56 <orzo> but that type is declared within an instance for type class PackedVec
04:23:09 <orzo> The instance is for (Vec2 Float)
04:24:03 <ivanm> is there any nice way of comparing two .prof files to see what caused it to run longer?
04:24:16 <ivanm> (yes, I can compare them line by line, but I'm hoping for something more automatic)
04:24:49 <Jafet> A very small perl script?
04:25:03 <ivanm> that would require me to learn perl :p
04:25:19 <orzo> it's pretty much impossible eh
04:25:32 <ivanm> I was hoping someone would have some haskell tool to examine haskell profile results
04:26:14 <ivanm> orzo: Vec2F is the constructor for which data type?
04:26:18 <ivanm> Packed?
04:26:37 <ivanm> it should then be: import Data.Vec(Packed(Ve2F))
04:26:40 <ivanm> (I think)
04:27:29 <orzo> its a parameterized type Packed v
04:27:38 <orzo> where v is Vec2 Float
04:28:07 <ivanm> which package is this?
04:28:16 <orzo> vec
04:28:30 <ivanm> there's no package called "vec" on hackage...
04:28:36 <ivanm> do you mean vector?
04:28:43 <orzo> no, it's Vec
04:28:46 <ivanm> ahhh
04:28:55 <orzo> * Vec Synopsis: Fixed-length lists and low-dimensional linear algebra.
04:29:15 <ivanm> ummm.... Vec2 is its own data type
04:29:26 <ivanm> type Vec2 a = a :. (a :. ())
04:29:35 <ivanm> so: import Data.Vec.Packaged(Vec2)
04:29:43 <ivanm> ^^ that will get the type alias in unqualified
04:30:47 <orzo> There is no Data.Vec.Packaged and Data.Vec(Vec2) didn't work
04:31:35 <ivanm> I mean Packed
04:31:37 <ivanm> not Packaged
04:31:45 <orzo> okay, well Packed does not export Vec2
04:31:56 <ivanm> Data.Vec.Base actually
04:32:24 <orzo> doesn't work.
04:32:46 <orzo> I think Vec2F symbol is a data constructor, not for Vec2 but for Packed (Vec2 Float)
04:33:37 <ivanm> ahhhh, it's a type family
04:33:50 <ivanm> hmmm...
04:34:17 <ivanm> @where type families
04:34:17 <lambdabot> Clause a = [Literal a]
04:34:23 <ivanm> @where type family
04:34:23 <lambdabot> Clause a = [Literal a]
04:34:40 <ivanm> am I getting my plugin usage wrong?
04:34:41 <ivanm> @help where
04:34:41 <lambdabot> where <key>. Return element associated with key
04:34:51 <ivanm> @google type families
04:34:52 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_families
04:34:53 <lambdabot> Title: GHC/Type families - HaskellWiki
04:34:55 <Jafet> @where type
04:34:55 <lambdabot> Clause a = [Literal a]
04:35:10 <Jafet> Not that that makes any sense anyway
04:35:12 <byorgey> that's... odd.
04:35:33 <ivanm> orzo: Vec2F is also a type synonym for Packed (Vec2 Float)
04:35:38 <Jafet> @where+ type
04:35:38 <lambdabot> I will remember.
04:35:42 <Jafet> @where type
04:35:46 <ivanm> so you can do import Data.Vec.Packed(Vec2F)
04:35:57 <ivanm> are you after the constructor or the type name?
04:36:02 <orzo> the constructor
04:36:29 <orzo> import Data.Vec.Packed(Vec2F) doesn't do it for me
04:36:44 <ivanm> no, that won't get the constructor
04:36:58 <orzo> using (..) in there doesn't help
04:37:02 <ivanm> orzo: just to check: if you just import the entire module, is the constructor available?
04:37:10 <orzo> yes
04:37:34 <orzo> but the module defines things like map and such that conflict with prelude elements
04:37:48 <ivanm> orzo: try reading http://www.haskell.org/haskellwiki/GHC/Type_families#Import_and_export
04:37:58 <orzo> i started that yes
04:38:54 <ivanm> I was about to say that the constructor needs to be explicitly exported, then remembered you said it was available...
04:40:05 <ivanm> just to clarify: saying ` :type Vec2F ' in ghci after importing the entire module says it's of type Float -> Float -> Packed (Vec2 FLoat) ?
04:40:10 <ivanm> (or something like that)
04:41:31 <orzo> yes indeed
04:43:38 <ivanm> *shrug*
04:44:28 <ivanm> my guess is that you import the entire class, import Vec2 and it might automagically work
04:44:36 <orzo> they extended the import syntax to have a "type" keyword, I'm wondering if maybe i can do it with that somehow
04:45:23 <ivanm> orzo: because it's an instance and instances are implicitly imported, I don't think so
04:46:06 <orzo> are yo ufamiliar with this type keyword and understand its use?
04:46:17 <ivanm> maybe import Data.Vec.Packed(PackedVec(type Packed))
04:46:39 <ivanm> orzo: I've used it before, but never in a case where I wanted to import a constructor explicitly like you do
04:47:24 <orzo> i've tried importing Vec2 and such
04:47:57 <orzo> i don't think i can get it to automagically work
04:48:35 <orzo> also, I don't really understand how parameterized types play with import/export
04:49:07 <orzo> there doesnt seem to be syntax for saying import Vec2F data constrcutor for type Packed (Vec2 Float)
04:49:45 <merijn> I like how "yesod init" blindly assumes BSD license for the Scaffolded code >.>
04:49:59 <shurikas> orzo, there is
04:50:12 <ivanm> so, :browse seems to think the associated types are defined separately from the class
04:50:25 <shurikas> when you import Vec2F(..) you import all its constructors
04:50:37 <ivanm> shurikas: no, I think you're mis-reading
04:50:46 <ivanm> Vec2F _is_ the constructor
04:50:50 <ivanm> of an associated type family
04:50:56 <shurikas> uhm, ok
04:51:10 <ivanm> http://hackage.haskell.org/packages/archive/Vec/1.0.1/doc/html/src/Data-Vec-Packed.html
04:52:13 <orzo> there's a class PackedVec with a type (family?) Packed and one instance for Packed has the constructor Vec2F
04:52:25 <orzo> heh
04:52:32 <shurikas> yeah, I see Vec2F
04:52:35 <ivanm> orzo: maybe try #ghc ?
04:52:39 <orzo> maybe you just can't do it
04:52:41 <ivanm> or try haskell-cafe ?
04:53:44 <ivanm> but my understanding is that you're not meant to access those constructors/types...
04:54:01 <ivanm> orzo: why are you trying to do that anyway?
04:54:08 <ivanm> can't you just use pack/unpack ?
04:54:54 <orzo> yes
04:55:14 <ivanm> so... why do you need access to Vec2F?
04:55:28 <orzo> well, i can simply use V.Vec2F or something
04:55:35 <orzo> its not like i cant use it
04:55:41 <orzo> i just cant take the qualification off
04:55:41 <ivanm> but why do you want/need access to it?
04:56:07 <orzo> what do you mean?  It's a nice interface
04:56:07 <sheldonh> hey! interact. awesome. shoulda just said so on the front page of haskell.org. "If you're a UNIXhead, start with the interact function." :)
04:56:29 <ivanm> orzo: yes, but if you can't use it why not juse use unpack?
04:56:39 <ivanm> sheldonh: I don't think I've ever used interact...
04:56:41 <orzo> but i can use it, why not use V.Vec2F ?
04:56:48 <ivanm> then again, I tend not to write interactive scripts :p
04:56:57 <mbuf> can this function be improved? http://hpaste.org/73626
04:57:06 <orzo> I can't use it unqualified, that's all
04:57:13 <ivanm> orzo: well, I would hazard a guess that your ability to access Vec2F might be a bug (but I could be wrong)
04:57:20 <sheldonh> ivanm: UNIX pipes are a great way to explore :)
04:57:27 <mbuf> how can I make it return immediately as soon as a match is found
04:57:44 <orzo> ivanm: i don't think so, i think the Data.Vec documentation material encouraged it
04:57:57 <ivanm> mbuf: might be to do with how System.IO.HVFS works, whatever it is
04:58:17 <ivanm> orzo: I meant a bug from the compiler's point of view
04:58:28 <ivanm> and if you're meant to access it, what's the point of pack/unpack in the first place?
04:58:43 <orzo> using pack would be something like:  pack (x :. y :. ()) which is ugly compared to Vec2F x y
04:58:51 <merijn> mbuf: Use something that terminate after the first match, rather than walking the entire list like filter
04:59:27 <mbuf> merijn: is there an example?
04:59:45 <merijn> Not sure that function exists
04:59:52 <ivanm> mbuf: it would depend upon the library you're using, which doesn't seem familiar to me
05:00:00 <mbuf> ivanm: merijn I see
05:00:01 <merijn> Shouldn't be hard to write using something like "dropWhile"
05:00:02 <ivanm> (in that I can't spot which library it's from just from the module name)
05:00:35 <ivanm> mbuf: wait, that's going to return a list of results...
05:00:49 <ivanm> if you just want the first match, why not just get the first match?
05:00:58 <mbuf> ivanm: how do I get the first match?
05:01:00 <merijn> mbuf: For just the first match something like: "case dropWhile (~= filename) a of (x:xs) -> print x; _ -> whatever"
05:01:02 <ivanm> (though admittedly recurseDir might not be lazy enough in that sense)
05:01:09 <ivanm> mbuf: how do you get the first element of a list? ...
05:01:15 <mbuf> ivanm: head
05:01:33 <ivanm> listToMaybe might be more relevant here though, unless you can guarantee the list is non-empty :)
05:01:54 <ivanm> but you probably want a fold over the directory tree, rather than a list of results (as that's probably non-lazy)
05:02:56 <mbuf> ivanm: I see
05:09:04 <sheldonh> runghc... it's doing a compile and run?
05:09:41 * frerich writes "if (!blacklist.empty() && blacklist.find(expensiveFunctionCall()) != blacklist.end())" and longs for lazyness...
05:09:44 <ivanm> sheldonh: no
05:09:49 <ivanm> just interprets it
05:10:03 <sheldonh> ivanm: okay, sanity restored. seemed awefully fast :)
05:11:09 <byorgey> frerich: eek
05:11:17 <bas__> ls
05:11:51 <bas__> is it possible to update/copy a record pointfree?
05:13:26 <ivanm> bas__: using lenses?
05:13:31 <Na-Fiann> Hi, I'm learning haskell, and I've got some code that returns a Maybe [a]. Now I want to use that in an IO block, printing an error message and exiting on Nothing, or continuing on Just [a], but have no idea how to do this..
05:13:38 <ivanm> or explicitly writing your own function to do so
05:13:51 <ivanm> Na-Fiann: use a case statement within your do-block?
05:14:04 <bas__> ivanm: thanks
05:14:31 <ivanm> there are various lens implementations on hackage
05:14:54 <shachaf> Na-Fiann: case x of Nothing -> ...; Just list -> ...
05:19:04 <paolino> @hoogle (|||)
05:19:04 <lambdabot> Control.Arrow (|||) :: ArrowChoice a => a b d -> a c d -> a (Either b c) d
05:20:00 <paolino> is (|||) beside Control.Category ?
05:20:26 <paolino> :t (>>>)
05:20:27 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
05:20:46 <paolino> :t arr
05:20:47 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
05:21:59 <paolino> :t id
05:22:01 <lambdabot> forall a. a -> a
05:22:41 * ivanm glares at his code for not working
05:23:15 <byorgey> how dare it
05:23:31 <byorgey> paolino: I don't understand your question about (|||)
05:23:49 <fmap> bas__: what do you mean by "copy"?
05:24:14 <thelarry> Hi! In haskell you can derive from several typeclasses, right?
05:24:14 <thelarry> like:
05:24:14 <thelarry> data Person = Person { firstName :: String
05:24:14 <thelarry> , lastName :: String
05:24:14 <thelarry> , age :: Int
05:24:15 <thelarry> } deriving (Eq, Show, Read)
05:24:18 <thelarry> what if the classes have different implementations of the same (named) method??
05:24:27 <paolino> byorgey, it seems to me there is overlapping id === arr, (.) === (>>>)
05:24:27 <bas__> hm I actually just mean 'update' but that sounds incorrect
05:24:33 <nand`> thelarry: for example?
05:25:38 <paolino> byorgey , so importing Control.Category is giving me (|||) also ?
05:26:07 <paolino> (sorry for my language...)
05:26:08 <ivanm> byorgey: I reckon! (actually, it's working: what I can't understand is why it's so slow when I try to get more than one component...)
05:26:15 <trem_> so i removed every single occurence of unsafe* from my code, and still get a perfectly reproducible "scavenge_one: strange object 16777216" -- what should I do next?
05:26:29 <dreugeworst> Hi, I'm learning haskell, and I've got some code that returns a Maybe [a]. Now I want to use that in an IO block, printing an error message and exiting on Nothing, or continuing on Just [a], but have no idea how to do this..
05:26:42 <ivanm> thelarry: you can only automatically derive from several specified in-built classes
05:26:52 <paolino> dreugeworst, ?
05:27:14 <ivanm> dreugeworst == Na-Fiann ?
05:27:20 <fmap> bas__: oh, record update is actually correct term
05:27:27 <ivanm> shachaf and I already answered that question...
05:27:45 <bas__> ok fmap, thanks
05:27:56 <nand`> what's strange about ‘update’?
05:28:01 <nand`> just that it sounds like mutation?
05:28:06 <fmap> yes
05:28:07 <bas__> yes
05:28:27 <bas__> conceptually it makes sense, but it feels inaccurate
05:29:01 <hpc> bas__: yeah, sometimes it bugs me
05:29:05 <DT`> functional update?
05:29:11 <hpc> then i waste half an hour trying to find a better term and give up
05:31:41 <nand`> I feel at ease with the term - it describes what you're doing - updating a field of a record; whether this is via mutation or creating a new copy internally is an implementation detail
05:32:08 <paolino> liftW from Control.Comonad
05:32:18 <bas__> you're right, but I am still trying to ban imperitive ideas from my mind
05:34:49 <aristid> not exactly new, but crazy: http://hackage.haskell.org/package/polytypeable
05:36:02 <byorgey> paolino: id is not arr
05:36:13 <byorgey> paolino: but (<<<) is indeed a synonym for (.)
05:36:37 <byorgey> paolino: oI seriously doubt importing Control.Category is giving you (|||). That's defined in Control.Arrow.
05:36:49 <nand`> id is arr id; but this has nothing to do with Control.Category
05:37:02 <nand`> well, the ‘arr id’ side
05:37:06 <shurikas> source code for it is SICK
05:37:11 <shurikas> polytypeable
05:37:30 <nand`> why can't I hold all of these language extensions?
05:37:31 <thelarry_> ahh ok. Thx!
05:39:05 <paolino> byorgey, so Arrow and Category are unrelated ?
05:39:20 <nand`> Category is a superclass of Arrow
05:39:56 <DT`> wasn't Arrow Category+Applicative?
05:40:21 <nand`> any arrow can be made into an applicative, iirc
05:41:01 <nand`> but what really sets arrow apart from category is that arrow provides ‘arr’, which can be used to lift pure functions into the arrow
05:42:03 <paolino> nand`, how arrow needs id ?
05:42:08 <nand`> ?
05:42:19 <nand`> I don't understand your question
05:43:16 <paolino> the meaning of superclass is not clear to me, sorry
05:43:28 <nand`> class Category a => Arrow a where ... -- that's what superclass means here
05:43:45 <nand`> every Arrow is also a Category, but not vice versa
05:44:12 <paolino> so Arrow uses Category methods to define its methods
05:44:48 <paolino> but only (<<<) which is (.)
05:44:50 <nand`> yes, for example the default implementations of ‘second’, (***) and (&&&) use Category functions
05:45:28 <paolino> ouch I've confused (|||) with (***) in my original question
05:49:09 <dreugeworst> paolino, ivanm: sorry, had some trouble with IRC, thought it was my username. I've found what I'm trying to do now though
05:49:21 <ivanm> OK
05:49:54 <deggis> ghci problem (Failed to load interface) http://hpaste.org/73628 what's happening there? import [LIB] as SV clearly works at first
05:49:59 <byorgey> paolino: (***) still comes from Control.Arrow and not Control.Category
05:52:47 <spriteDrinker> Hello, I am fairly new to Haskell and I was trying to create a Fibonnaci list, which is not really hard (if I don't mind the inefficiencies; I created a Fibonnaci list by defining fib n = fib (n-1) + fib (n-2) and then fib 0 = 0 and fib 1 = 1 and then applying that formula to an infite list).
05:53:16 <spriteDrinker> However due to its inefficiencies I was wondering whether I could "use" the previous computations from the list...
05:53:30 <spriteDrinker> (I know the answer is yes, however I think I need a hint as I am kind of stuck :()
05:55:49 <f8_> I strongly disagree with aluminum cases on laptops.
05:55:56 <monad1> lol
05:56:01 <f8_> damn, wrong window
05:56:14 <aristid> spriteDrinker: fix ((0:) . (1:) . (zipWith (+) <*> tail))
05:56:29 <byorgey> spriteDrinker: the answer is yes.  and pay no attention to aristid.
05:56:29 <aristid> spriteDrinker: just kidding :D (it works though)
05:56:38 <nand`> aristid: here's a more elegant and concise formulation
05:56:40 <spriteDrinker> I was looking for a hint XD
05:56:47 <spriteDrinker> not the answer :(
05:56:48 <nand`> > fix $ scanl (+) 0 . (1:)
05:56:50 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
05:56:56 <aristid> spriteDrinker: don't use my answer :)
05:57:02 <aristid> spriteDrinker: but it's prove that it's possible
05:57:03 <luite> spriteDrinker: the hint is probably that you should try to make a list of all fibs directly, recursively
05:57:26 <byorgey> spriteDrinker: first, try doing it with a function that takes a pair of fibonacci numbers and produces the next pair
05:57:35 <luite> spriteDrinker: so you already have the first two elements of the list, then write something that produces the next
05:57:40 <byorgey> spriteDrinker: e.g.  (2,3) -> (3,5);  (3,5) -> (5,8); etc.
05:57:41 <aristid> nand`: ah, scanl, the function that i always forget what it does. *looks up*
05:57:53 <byorgey> spriteDrinker: then use that function to make a list
05:58:05 <spriteDrinker> ah, that helps a lot =)
05:58:09 <byorgey> spriteDrinker: there are also ways to use the list directly to compute itself but I'd recommend doing the way with the pairs first.
05:58:38 <nand`> I don't think the list has any real relevance, the main element is going from two recursive applications down to one
05:58:46 <byorgey> right
05:58:52 <byorgey> hence the pairs
05:59:08 <nand`> yeah
05:59:17 <spriteDrinker> Thank you guys! I am going to try again before you guys post more solutions :P
05:59:25 <nand`> the key element here is figuring out how to write iterative algorithms via tail call recursion
05:59:44 <nand`> as a first step towards a more efficient solution than the trivial one
06:01:12 <spriteDrinker> Bye guys! Thanks for the advice, help =). I am going to try for myself =)
06:01:13 <spriteDrinker> cya!
06:06:02 <deggis> ideas on this one http://hpaste.org/73628 ? not the biggest of deals but would increase comfort in using haskell if i'd know how to deal with these (reinstalling all libraries didn't help)
06:08:06 <deggis> mm, okay, i interpreted it wrong. the failed to load interface msg didn't mean that the API was missing, only that it couldn't see a data constructor
06:08:25 <ivanm> deggis: does the same thing happen when the import statement, etc. is in a file rather than in ghci?
06:08:50 <ivanm> do other packages work apart from svm-simple ?
06:09:07 <deggis> ivanm: no, only in ghci. and it seems that :info SV.SVMRegressor works fine, only :t didn't
06:09:17 <ivanm> oh, is that the name of the data type?
06:09:22 <ivanm> if so, then yes, :t won't work :)
06:09:41 <deggis> yes it's a newtype
06:10:47 <deggis> i blindly assumed you can grind cats and mouses and horses and spaceships wrapped monad transformer dimensions beyond comprehension, anything, and as for its type with :t
06:10:57 <deggis> ask*
06:11:57 <aristid> deggis: types don't have a type, they have a kind :)
06:12:03 <deggis> ..and yes, if it's a value i can do that
06:12:14 <aristid> try :k Int
06:12:16 <aristid> that
06:12:20 <aristid> that's a kind
06:12:31 <deggis> oh, there's :k too, which works
06:12:41 <aristid> yup
06:13:35 <deggis> heh, thanks a lot. feeling kinda stupid; this was helpful :)
06:14:15 <aristid> deggis: no need to, in other languages types _have_ types :)
06:16:40 <trem_> can someone here guide me a little on how to debug something that might be a GHC bug? i have a program which segfaults, but is completely clean from any unsafe* usage. I'm kinda lost now. :-/
06:16:58 <deggis> aristid: heh, hadn't thought of that before. i'll start conversations with next java guy with that opening line
06:17:18 <aristid> deggis: java types _don't_ have types.
06:18:44 <shurikas> aristid, give us an example where types have types
06:18:53 <shurikas> I can't think of any :)
06:18:56 <aristid> shurikas: agda :P
06:19:00 <shurikas> dafuq
06:19:11 <shurikas> ok
06:19:35 <DT`> in agda, types have kinds have Set 2 have Set 3 have Set 4 ...
06:19:45 <aristid> why, it's true. agda is a real programming language.
06:19:57 <shurikas> hah
06:19:58 <aristid> DT`: Set1 is not really called "kind" there :)
06:20:09 <shurikas> agda is written in Haskell
06:20:18 <ivanm> trem_: maybe one of the libraries you use uses unsafe* ?
06:20:22 <ivanm> you have partial functions?
06:20:23 <DT`> aristid, to put it in usual terms.
06:20:33 <ivanm> deggis: does using -Wall say anything?
06:20:51 <aristid> ivanm: i think the problem was that he was using :t on a type
06:21:14 <ivanm> I meant trem_, not deggis :)
06:21:27 <trem_> ivan, i'm using the vector package quite a lot, but I have no partial functions (at least -Wall does not mention any)
06:22:31 <trem_> deggis, in fact, the whole thing is -Wall clean, GHC has nothing to complain. *except* for some mysterious output then compiling a certain module with optimization
06:22:54 <trem_> the "mysterious" output goes away with "-O0" -- but the crash remains
06:23:16 <trem_> googling for it hinted that it's some debug output from the optimizer i'm seeing
06:23:37 <ivanm> trem_: try running it with "+RTC -xc" to get a stack trace
06:23:38 <trem_> I'm currently building GHC head to see what it gives...
06:24:08 <sheldonh> someone earlier told me that all functions in haskell take only one argument. in ghci, this has proven true with every :type inspection i've tried. but the "real world haskell" book consistently talks about plural arguments in the section on types and functions. is it just "lying to freshmen"?
06:24:44 <trem_> ivan, I'm trying the -xc thing, moment please
06:25:08 <quicksilver> sheldonh: it's not really lying, it's just conventional language.
06:25:15 <nand`> Is there a good introduction to Coq with Haskell programmers in mind?
06:25:25 <quicksilver> sheldonh: take is a function which takes two arguments
06:25:27 <quicksilver> :t take
06:25:28 <lambdabot> forall a. Int -> [a] -> [a]
06:25:45 <quicksilver> sheldonh: it is also correct to view it as a function with one argument which returns a function.
06:25:52 <quicksilver> that's what a two-argument function is, in haskell.
06:25:54 <koala_man> one man's currying is another man's partial application
06:26:13 <ivanm> trem_: please note that ivanm /= ivan; please stop pestering him so he doesn't throw another temper tantrum :p
06:26:13 <quicksilver> one of those men is wrong.
06:26:14 <sheldonh> ah, okay. so they're just using english that they expect me to relate to
06:26:15 <nand`> sheldonh: it's completely correct to say that every haskell function takes only one argument
06:26:24 <quicksilver> currying is not partial application.
06:26:38 <trem_> ivanm, oops, sorry. :-)
06:26:40 <aristid> ivanm: he threw a temper tantrum once?
06:26:50 <aristid> preflex: seen ivan
06:26:51 <preflex>  ivan was last seen on #haskell 3 hours, 47 minutes and 15 seconds ago, saying: contrary to popular belief, I am not ivanm
06:26:51 <ivanm> well, not really...
06:26:55 <koala_man> quicksilver: how do you differentiate between a language with automatic currying and one with partial application?
06:27:17 <quicksilver> koala_man: I don't know what you mean by 'automatic' currying, really.
06:27:23 <trem_> ivanm, +RTS -xc causes no additional output, just "Speicherzugriffsfehler (Speicherabzug geschrieben)" aka "segfault, you're borked"
06:27:33 <Saizan> in a sense "only one argument" is a lower-level way to see it, and plural arguments is an abstraction we "build" on top of that
06:27:48 <nand`> koala_man: in a language with implicit side effects; a curried function could perform side effects after being passed only one argument, something that I would describe as ‘partial application’ could arguably not
06:27:49 <ivanm> trem_: is your code small enough to be pasted somewhere?
06:27:55 <nand`> but this is a very fuzzy argument
06:28:03 <quicksilver> koala_man: how do you distinguish betwee a car with a gearbox and a car with a driveshaft??
06:28:11 <trem_> it's on github, but not exactly small
06:28:13 <quicksilver> koala_man: (they are different concepts although they do indeed work together)
06:28:44 <trem_> ivanm, https://github.com/waldheinz/bling
06:28:52 <nand`> it depends on how you define ‘partial application’, really
06:29:28 <trem_> ivanm, i'll make a commit of the current state (all unsafe* replace with their safe counterparts); though it really makes no difference
06:29:43 <ivanm> trem_: OK, there's a lot of code there to look through... :p
06:30:15 <trem_> ivanm, ok, I push waht I currently have
06:30:25 <koala_man> quicksilver: they're not identical concepts, no
06:30:58 <trem_> ivanm, it takes quite some code to produce a cute cow: https://plus.google.com/photos/107968783614195434185/albums/5660724573840020945/5779242731246568994 :-)
06:31:35 <ivanm> heh
06:32:04 <trem_> ivanm, if you want to reproduce: clone, cabal configure, cabal build, and then "./dist/build/bling/bling examples/cornell-box-underwater.bling"
06:32:24 <trem_> here it crashes after ~30 seconds
06:34:57 * ivanm grumbles and installs the necessary packages
06:34:57 <trem_> ivanm, oh, wow, I was wrong when I said that -xc generates no output, there's a "*** Exception (reporting due to +RTS -xc): (THUNK_1_0), stack trace: \n MAIN.MAIN" -- but that's the *first* output, appearing immedially when starting
06:35:08 <ivanm> yeah, I think you can ignore that
06:37:33 <spaceships> o/
06:38:18 <byorgey> trem_: wow, this is a raytracer?
06:38:26 <byorgey> yo spaceships
06:38:42 <trem_> byorgey, yes sir
06:39:08 <byorgey> impressive
06:39:28 <ivanm> trem_: it's telling me that it can't find Data.Primitive.MutVar
06:40:07 <ivanm> your .cabal file needs to be updated to dep on primitive >= 0.4.1
06:40:23 <trem_> ivanm, oh, thanks, I'll do that
06:42:20 <Palmik> Hi guys. Does anyone here use conditional exporting (using CPP) with cabal? I have this setup for my library with test-suite (http://hpaste.org/73631) and it does not seem to work... maybe I'm just overlooking something trivial.
06:42:56 <trem_> byorgey, thanks. I'm trying to get a grasp on Haskell by writing it... currently I'm cleaning it up, pimping performance here and there so I can put it up on hackage soon
06:43:15 <ivanm> Palmik: in general, doing that is discouraged
06:43:48 <ivanm> maybe put a {-# LANGUAGE CPP #-} at the top of SomeModule just to be sure?
06:44:20 <Palmik> ivanm, I do that as well. Not sure why it should be discouraged... it seems better than to export all the functions just to test test them.
06:44:36 <ivanm> because the API shouldn't change based upon compile-time flags
06:45:04 <ivanm> I've had various discussions with dcoutts about this; I used to conditionally export some modules based upon a cabal flag
06:45:16 <Saizan> Palmik: isn't your #ifdef the wrong way around?
06:45:55 <ivanm> Saizan: if he's testing he wants implicit exporting
06:46:09 <byorgey> Palmik: in this situation I make two modules: one "internal" module which exports everything, then a second module which imports the internal module and only re-exports selected things
06:46:16 <byorgey> then in the tests I can import the "internal" module
06:46:18 <Palmik> Well, since there is not a proper support for testing internal modules or modules that do not export all of their functions, this seems to be only way to do it.
06:46:27 <Saizan> ivanm: right, and in the defined branch it has just where
06:46:50 <ivanm> Saizan: yes, when it's testing export everything; when not testing only export someFunction1
06:47:16 <Palmik> Yes, that's what I'm going for.
06:47:24 <ivanm> Palmik: see how I do it in graphviz: http://hackage.haskell.org/packages/archive/graphviz/2999.13.0.3/graphviz.cabal
06:47:33 <Saizan> ah, right, forgot about the implicit exporting
06:47:34 <Palmik> byorgey, yes, but the internal module would still have to be exposed.
06:48:13 <ivanm> Palmik: when I'm building the test suite for graphviz, it brings in all the internal modules and builds them again for testing purposes
06:48:30 <byorgey> Palmik: right, and I see that as a feature, not a bug.  You make it clear from the documentation that users are intended to use the "public" API, but if for some reason they want access to the internals (and they understand they may be able to shoot themselves in the foot that way) they can do it.
06:48:48 <byorgey> I see no value in actively hiding things from users.
06:49:18 * byorgey needs to write a blog post about this
06:49:19 <Guest53303> then u dont understand the magic of computers
06:49:37 <byorgey> it's true, I don't.
06:49:41 <byorgey> they are super magical.
06:49:54 <ivanm> definitely!
06:50:22 <ivanm> O MIGHT BOX, THAT GRANTETH ME THE ABILITY TO CALCULATE THINGS RAPIDLY!!!
06:50:23 <Palmik> byorgey, I do not really see that as a feature. Even my "internal" modules contain loads of functions that are not normaly exported (since they are used only withing the module)...
06:50:26 <ivanm> *MIGHTY
06:51:11 <quicksilver> byorgey: it's all fun and games until people start using them, and you want to change something that was supposed to be behind an abstract barrier
06:51:30 <quicksilver> and in the process you break a popular package and the PVP helicopters start circling around your house.
06:51:58 <Yiq> http://blogs.uw.edu/ajko/2012/08/22/john-carmack-discusses-the-art-and-science-of-software-engineering/
06:52:02 <ivanm> I also found cases where bos used bytestring internals where the public API had what he used as well
06:52:05 <Yiq> ^^ mentions haskell
06:52:20 <Saizan> oh, that's what they use the GSoC money for
06:52:21 <ivanm> trem_: OK, finally ran it
06:52:31 <byorgey> Saizan: the helicopters?
06:52:37 <Saizan> byorgey: yeah
06:52:44 <ivanm> it makes a difference if I use +RTS rather than +RTC :p
06:52:56 <byorgey> ivanm: yes, yes it does.
06:53:11 <Palmik> ivanm, hmm, your test suite does not depend on the library itself... that is the only difference I could spot. But If I remove the dependency, the package is then hidden for the test-suite's Main.
06:53:30 <trem_> ivanm, does it crash?
06:53:37 <ivanm> Palmik: right, the hs-source-dirs speficies that it uses the root directory as well, so it rebuilds all the library internals for the test suite
06:53:40 <ivanm> trem_: yup :(
06:53:49 <trem_> ivanm, cool! :-)
06:53:57 <ivanm> trem_: I'm going to make a wild guess and say that it's segfaulting at the C barrier
06:54:12 <trem_> ivanm, which GHC version are you using?
06:54:16 <ivanm> maybe shove some print or trace statments in strategic locations to help track it down?
06:54:22 <ivanm> 7.4.2
06:54:49 <trem_> ivanm, I'm 7.4.1, but HEAD currently compiles, I'll see what that does
06:55:36 <trem_> ivanm, I suspect the MutVars currently because a) I started using them only a few days ago and b) they seem to be generally new also
06:55:38 <ivanm> if my guess is correct, it won't make a difference
06:55:45 <ivanm> *nod*
06:57:37 <Palmik> ivanm, OIC. Then you have to repeat the dependencies.
06:57:58 <ivanm> yeah, that's the downside of this approach
06:58:55 <Palmik> BTW, my problem was in the typo for cpp-options (missing ':')
06:59:49 <trem_> ivanm, oh, do you see the massive debug output when compiling SPPM.hs, too?
06:59:50 <Palmik> Strangely, cabal did let it pass.
06:59:59 <ivanm> yup :s
07:00:43 <ivanm> trem_: with GHC, you can usually just use -O rather than -O2; the latter only sometimes seems to improve stuff (whilst emmitting a lot of output)
07:01:21 <trem_> ivanm, only -O0 makes that output go away, but that's really unusable.
07:01:53 <ivanm> *nod*
07:02:03 <ivanm> even if you get rid of those specconstr flags, etc.?
07:03:04 <trem_> ivanm, yum, thos flags are only for the executable, the library is pretty clean on flags. the executable should be, too...
07:03:17 <sheldonh> meh, is there readline support for ghci on linux? driving me nuts! :)
07:04:31 <fmap> sheldonh: ghci uses haskeline
07:04:49 <Yiq> http://blogs.uw.edu/ajko/2012/08/22/john-carmack-discusses-the-art-and-science-of-software-engineering/ i think you want to read it
07:05:10 <merijn> fmap: But haskeline doesn't properly follow .inputrc *grumble*
07:06:45 <sheldonh> fmap: bah. new tricks for fingers to learn :)
07:08:17 <trem_> so i finally compiled GHC and installed it to /opt/ghc-head -- is it enough to add it to PATH to use it?
07:08:47 <ivanm> trem_: I believe so, but you'll need to rebuild all your deps as well
07:09:26 <trem_> ghc seems to have become faster, the installs currently fly by.. nice.
07:24:22 <Yiq> > words "cant touch this"
07:24:23 <lambdabot>   ["cant","touch","this"]
07:24:35 <Yiq> > splitOn " " "cant touch this"
07:24:36 <lambdabot>   Not in scope: `splitOn'
07:24:52 <Yiq> @hoogle String -> [String]
07:24:53 <lambdabot> Prelude lines :: String -> [String]
07:24:53 <lambdabot> Data.List lines :: String -> [String]
07:24:53 <lambdabot> Data.String lines :: String -> [String]
07:31:19 <Yiq> @hoogle String -> [String]
07:31:19 <lambdabot> Prelude lines :: String -> [String]
07:31:19 <lambdabot> Data.List lines :: String -> [String]
07:31:20 <lambdabot> Data.String lines :: String -> [String]
07:31:23 <Yiq> hoogle String -> [String]
07:31:57 <Yiq> @type lines
07:31:57 <lambdabot> String -> [String]
07:32:03 <Yiq> @src lines
07:32:03 <lambdabot> Source not found. Are you on drugs?
07:32:44 <Yiq> splitOn char str -- Char -> String -> [String] --exists such a  fun?
07:33:02 <Botje> have you looked in Data.List.Split ?
07:33:59 <Eduard_Munteanu> @hackage split
07:33:59 <lambdabot> http://hackage.haskell.org/package/split
07:36:34 <thirsteh> Can I pattern match a "pre-defined value", e.g. foo = '@'; one = foo:y:ys to achieve the same as one = '@':y:ys ?
07:37:31 <siracusa> No
07:37:44 <thirsteh> ok
07:38:24 <merijn> thirsteh: I don't see a pattern match in those examples, though
07:38:53 <thirsteh> sorry, one '@':y:ys = ...
07:39:57 <thirsteh> vs. foo = '@'; one foo:y:ys = ...
07:40:30 <applicative> thirsteh: no then foo:y:ys isn't a pattern
07:41:28 <thirsteh> ok cheers
07:41:39 <merijn> thirsteh: You could use a guard like this, though "one x:y:ys | x == foo = {- code here -}"
07:42:27 <thirsteh> I'll just KISS, the foo var is only used in two places anyway
07:53:55 <eikke> anyone ever used conduit with UDP networking?
07:56:16 <sheldonh> about this one argument thing... "add a b = a + b" <-- how is that anything but a function that takes two arguments?
07:56:36 <paolino> it seems like noone is mantaining MonadRandom, I have a bug and a patch, is anyone in the position of fixing it ?
07:56:51 <paolino> :t (+)
07:56:52 <lambdabot> forall a. (Num a) => a -> a -> a
07:57:12 <paolino> == a -> (a -> a)
07:57:16 <thirsteh> sheldonh: http://en.wikipedia.org/wiki/Currying
07:57:51 <paolino> it's a function of one argument which produces a function of another of the same type
07:58:03 <sheldonh> so when i say that to haskell, it compiles a function called add, that takes a and returns a function that takes b and returns a + b?
07:58:10 <thirsteh> sheldonh: yes
07:58:40 <paolino> that's how (+4) makes sense
07:58:45 <paolino> :t (+4)
07:58:45 <lambdabot> forall a. (Num a) => a -> a
07:58:57 <sheldonh> thirsteh: okay. so now my question is... will it actually become important that things work like this under the hood? it seems at this early point in my learning, that this is an interesting but entirely academic detail
07:59:06 <paolino> > map (+4) [1..]
07:59:07 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
07:59:30 <sheldonh> it's a good thing someone taught that bot when to stop :)
08:00:07 <thirsteh> sheldonh: it's extremely powerful. You need to think this way to make the best use of Haskell. I'm a noob myself, but point-free style and mapping partially applied functions is already helping me a lot
08:00:11 <Botje> sheldonh: it means you get to write nice code like foldr (flip Map.insert k) Map.empty
08:00:33 <Botje> instead of \xs -> foldr (\v map -> Map.insert k v map) Map.empty
08:01:10 <sheldonh> okay cool. i'm not arguing, just making sure it's worth my while to keep remembering that realworldhaskell is simplifying matters
08:01:15 <Saizan> Botje: except you should never use foldr there
08:01:33 <sheldonh> thanks again, sorry for the repeated lack of faith :)
08:02:05 <Botje> Saizan: heh, I wasn't sure I'd get the types correct with foldl :]
08:02:49 <thirsteh> sheldonh: did you look at LYAH? It has a good section on currying
08:03:16 <thirsteh> sheldonh: http://learnyouahaskell.com/higher-order-functions#curried-functions
08:03:23 <sheldonh> thirsteh: no. in fact, book selection was my source of procrastination for some time. today, i decided "stuff it" and just flipped a coin :)
08:03:34 <sheldonh> shot, thanks
08:03:49 <thirsteh> LYAH is a bit more approachable than RWH IMO, but both are great
08:04:04 <Saizan> sheldonh: btw, as unsoliticed information: at the lowest level of abstraction, (i.e. assembly or near there) GHC would actually compile add to a function that takes 2 arguments because it's more efficient that way
08:04:46 <sheldonh> Saizan: lol! you just couldn't allow me bliss, could you? :)
08:05:46 <sheldonh> oic.... add2 = add 2, and now add2 7 is 9
08:06:22 <sheldonh> i vacilate between "this is awesome!" and "how could it possibly be useful to think like this!" :)
08:07:30 <Cale> sheldonh: The usefulness comes when you start applying higher order functions
08:07:33 <thirsteh> (left choices)
08:07:34 <thirsteh> :D
08:08:22 <sheldonh> Cale: i have a feeling the "aha" moment in functional thinking just takes a lot longer to arrive
08:08:37 <Cale> > map (+1) [1..10]
08:08:38 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
08:09:44 <sheldonh> Cale: yeah, *just* tried it with my add function :)   map (add 12) [1..5] :)
08:09:49 <paolino> Cale, maybe you could apply a patch to MondaRandom as you are mentioned in the fathers and the manteiner has given up ?
08:10:37 <Cale> paolino: I originally put MonadRandom on the wiki, other people turned it into a package. I say just modify it and upload a new package if you have a fix for something.
08:10:50 <Cale> paolino: what are you patching?
08:11:02 <paolino> evalRandIO is broken
08:11:47 <Cale> really?
08:12:07 <paolino> actually I couldn't find the bug, I just rewrited it, so it should be reviewed by someone wiser than me
08:12:41 <whoev> http://groups.engin.umd.umich.edu/CIS/course.des/cis400/scheme/substr.html i'm curious if anyone can tell me how this looks in haskell?
08:13:27 <whoev> something tells me it's probably way more simple...
08:13:29 <Cale> paolino: how exactly is it broken?
08:13:35 <Cale> paolino: It appears to work to me
08:14:16 <Cale> paolino: I suspect that if it's broken for you, the bug isn't in evalRandIO, but in getStdRandom
08:14:24 <Yiq> Cale: http://blogs.uw.edu/ajko/2012/08/22/john-carmack-discusses-the-art-and-science-of-software-engineering/ #Maybe it would interest u
08:14:36 <adnam> whoev: is that to find the position of an infix?
08:14:47 <sheldonh> ooo. mr id
08:15:08 <paolino> Cale , try run this 2 times head `fmap` evalRandIO (let  f = getRandom >>= \y -> f >>= \ys -> return (y:ys) in f)
08:15:54 <adnam> whoev: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-List.html#isInfixOf
08:16:23 <whoev> adnam: no the return value is an index
08:16:26 <whoev> not t/f
08:16:35 <whoev> well i mean
08:16:38 <whoev> the return value is a *function*
08:16:43 <whoev> that returns the index
08:16:56 <whoev> strstr i think?
08:17:05 <roconnor> whoev: \p t -> elemIndex (isPrefixOf p) tails t
08:17:13 <whoev> O_O
08:17:14 <roconnor> @type  \p t -> elemIndex (isPrefixOf p) tails t
08:17:15 <lambdabot>     Couldn't match expected type `[[a] -> Bool]'
08:17:15 <lambdabot>            against inferred type `[a1] -> [[a1]]'
08:17:15 <lambdabot>     In the second argument of `elemIndex', namely `tails'
08:17:20 <roconnor> oops
08:17:23 <roconnor> @type  \p t -> elemIndex (isPrefixOf p) (tails t)
08:17:24 <whoev> yeah i like haskell...
08:17:24 <lambdabot>     Couldn't match expected type `[a] -> Bool'
08:17:24 <lambdabot>            against inferred type `[a1]'
08:17:24 <lambdabot>       Expected type: [[a] -> Bool]
08:17:32 <Cale> paolino: Do that, and then  getStdRandom (randomR (1,10))
08:17:46 <roconnor> whoev: I've failed :(
08:17:47 <hiptobecubic> whoev, replace `any` with a function that returns the index of the first true
08:17:48 <Cale> paolino: The bug isn't in Control.Monad.Random, it's in System.Random, apparently
08:18:23 <roconnor> @type  \p t -> findIndex (isPrefixOf p) (tails t)
08:18:24 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Maybe Int
08:18:29 <paolino> ok, I trust you, so we don't work around it ?
08:18:33 <roconnor> whoev: ah better
08:18:44 <Cale> paolino: well, you could put in a workaround
08:18:56 <roconnor> let locate p t = findIndex (isPrefixOf p) (tails t) in locate "World" "Hello World"
08:19:03 <roconnor> ? let locate p t = findIndex (isPrefixOf p) (tails t) in locate "World" "Hello World"
08:19:06 <roconnor> > let locate p t = findIndex (isPrefixOf p) (tails t) in locate "World" "Hello World"
08:19:07 <lambdabot>   Just 6
08:19:09 <adnam> :D
08:19:12 <Cale> To be honest, I'd much prefer using  newStdGen  to making use of the pointlessly stateful nature of System.Random
08:19:18 <whoev> why is it like 40 lines long in scheme  :(
08:19:29 <hiptobecubic> whoev, because scheme is a different language
08:19:48 <roconnor> whoev: more effiecent and less code resuse in scheme
08:19:56 <whoev> it's more efficient in scheme?
08:20:01 <luite> whoev: the scheme implementation is also a more efficient algorith, where partial matches on long patterns don't take as much time
08:20:08 <whoev> oh
08:20:16 <whoev> i can't even read it
08:20:24 <paolino> Cale, I don't understand your point
08:20:27 <Veinor> yeah, the most efficient algorithm is probably something along the lines of 'build a state machine out of the needle, then traverse the haystack'
08:21:08 <Cale> i.e.  evalRandIO x = fmap (evalRand x) newStdGen
08:21:29 <whoev> finite state machines are just religious dogma, hidden in plain sight
08:21:30 <hiptobecubic> I would expect some tricks like "look at the first and last char first" to speed it up a lot, if we're considering the RealWorld®
08:21:32 <whoev> FSM <--
08:21:45 <paolino> Cale, is that broken ?
08:22:22 <Cale> paolino: It doesn't trigger the bug
08:22:27 <luite> whoev: here's a more efficient algorithm implementation in haskell: http://hackage.haskell.org/packages/archive/stringsearch/0.3.6.3/doc/html/src/Data-ByteString-Search-Internal-BoyerMoore.html#strictSearcher
08:22:47 <Cale> paolino: and it also doesn't make use of System.Random's stupid global mutable variable like getStdRandom does
08:22:52 <roconnor> whoev: this is a resonably fast algorithm in Haskell: http://twanvl.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell  However, it needs to be modified to return the location of the match instead of just whether a match exists or not.
08:23:22 <whoev> i met donald knuth
08:23:23 <sheldonh> lol. my 6 year old. "What are you doing that hands up in the sky thing for?" ... he wasn't impressed with "I just reimplemented drop in Haskell."
08:23:24 <whoev> on freenode
08:23:33 <whoev> in #go i  think
08:23:52 <paolino> Cale , I didn't know newStdGen, I used getStdGen
08:23:53 <Cale> Figures
08:24:01 <Cale> paolino: okay
08:24:01 <Veinor> sheldonh: haha
08:24:20 <paolino> and updated after a split
08:24:58 <paolino> with setStdGen
08:25:13 <roconnor> I can't get out of my head the description of go as a modern version of Algol 68
08:25:47 <geekosaur> *snrk* yeh
08:25:59 <Cale> roconnor: It's pretty accurate
08:26:02 <geekosaur> ...and algol68 won the comparison, IIRC
08:26:03 <Cale> paolino: hmm
08:26:27 <roconnor> geekosaur: ha.  You mean that people prefered Algol 68 to go?
08:27:03 <geekosaur> that description came from a blog entry that did a point by point comparison and showed pretty much that algol68 did all of it and generally did it in a better way.
08:27:10 <whoev> are people using go at all?
08:27:14 <geekosaur> which one users/programmers find preferable is another question, of course
08:27:25 <Cale> paolino: OH
08:27:33 <geekosaur> (algol68 is a bit fiddly in many areas so I can well imagine people preferirng go, actually)
08:27:34 <Cale> paolino: lol, I know why you're having problems
08:27:55 <roconnor> geekosaur: oh I didn't know that
08:28:06 <Jurily> http://www.cowlark.com/2009-11-15-go/
08:28:08 <Cale> paolino: It's actually not a bug in any of this. If you look at the action which you're passing to evalRandIO, that thing is never going to finish running.
08:28:39 <Cale> paolino: and so the resulting random generator state from running it can never be obtained
08:28:45 <paolino> well, I started from there
08:30:24 <paolino> that is what I want, so the point is  evalRandIO is broken or not?, if I run it twice and second time it hangs, it has a problem imo
08:30:26 <geekosaur> (you could say, all the "innovations" in go are done better in algol68; much of the standard stuff is more fiddly in algol68, in particular variable declarations feel like someone was reaching toward ADTs but not quite getting it)
08:31:01 <Cale> paolino: The problem is that you're updating the "system" random generator state with _|_
08:31:44 <Cale> paolino: because that's basically what you're getting from runRand, because your action never finishes running
08:32:13 <Cale> paolino: System.Random has this really stupid top-level mutable variable
08:32:39 <Cale> the value of which is obtained by getStdGen and set by setStdGen
08:32:47 <Cale> and getStdRandom uses that
08:33:16 <paolino> my fix also, and newStdGen the same I suppose
08:33:33 <Cale> newStdGen makes a genuinely new one and doesn't touch that state
08:35:02 <Cale> So I would support  evalRandIO x = fmap (evalRand x) newStdGen  (and a corresponding change in the documentation)
08:35:27 <Cale> because it's just better not to bother with global mutable state where it isn't needed
08:35:33 <paolino> ok
08:36:38 <Cale> splitting the generator like you were doing will also probably work, but nobody really understands the statistical effect of splitting generators (which is really sad from a computer science standpoint)
08:37:57 <Cale> I have no idea why nobody who works on studying pseudorandom number generation seems to have put even the slightest effort into studying ways to split the PRNG state.
08:38:30 <Cale> Or designing high-quality generators which have that ability.
08:39:02 <t7> wtf is brandx?
08:39:08 <Cale> ?
08:39:27 <Cale> t7: If you're referring to http://www.cowlark.com/2009-11-15-go/
08:39:38 <Saizan> newStdGen is still using the global mutable var, it splits from it
08:39:42 <Cale> t7: then Brand X is revealed at the bottom of the page
08:39:52 <t7> its gonna be agol or something
08:39:57 <Cale> t7: Hint: it's from the 1960's
08:39:59 <t7> yup
08:40:38 <paolino> Cale, what I have to to with the manteiner field in the cabal? He wrote to me he's not more manteining it.
08:40:53 <t7> go would be better with sensible type system
08:40:55 <Cale> Set it blank, or make yourself the maintainer
08:41:01 <paolino> blank
08:41:40 <t7> i have a imperative garbage collected language with parametric polymorphism in my head
08:41:41 <iamtakingiteasy> hi, how do i split list effectively on several positions? i want something like ``splitBy (`elem`[2,5,9]) [0..10]'' ==== ``[[0,1],[2,3,4],[5,6,7,8],[9,10]]''
08:41:45 <t7> i should implement
08:41:50 <paolino> Cale, there are UndecidableInstances ....
08:42:18 <t7> is like retarded typing
08:43:03 <t7> go is *
08:44:13 <iamtakingiteasy> except that in real case it is not a plain numbers, but rather tuples from which elements should be extracted first
08:44:24 <Cale> http://hackage.haskell.org/packages/archive/split/0.2.0.0/doc/html/Data-List-Split.html
08:45:38 <iamtakingiteasy> Cale: splitWhen is almost like what i want, only not removing matched element, but rather adding it to the next sub-list
08:45:42 <paolino> Saizan, should I write "splitting global standard generator" in the docs using newStdGen in the code ?
08:45:55 <Cale> iamtakingiteasy: I think you'll need to actually use the combinators...
08:46:14 <iamtakingiteasy> what combinators are?
08:46:39 <Cale> iamtakingiteasy: the things which operate on "Splitter a" values
08:47:17 <iamtakingiteasy> yeah, seems like what i want. thank you, Cale!
08:47:24 <Cale> > split (keepDelimsL (oneOf [2,5,9])) [0..10]
08:47:24 <lambdabot>   Could not find module `Data.List.Split':
08:47:24 <lambdabot>    Use -v to see a list of the fil...
08:47:31 <Cale> ah, not installed :P
08:48:14 <iamtakingiteasy> i've got the idea. thank you!
08:48:38 <Saizan> > groupBy (\_ y -> y `elem` [2,5,9]) [0..10]
08:48:41 <lambdabot>   [[0],[1,2],[3],[4,5],[6],[7],[8,9],[10]]
08:49:40 <Cale> > groupBy (\x y -> x `elem` [2,5,9]) [0..10]
08:49:41 <lambdabot>   [[0],[1],[2,3,4,5,6,7,8,9,10]]
08:49:44 <Cale> heh
08:49:46 <Cale> right :)
08:50:01 <hiptobecubic> whta?
08:50:11 <Cale> > split (keepDelimsL (oneOf [2,5,9])) [0..10]
08:50:12 <lambdabot>   Ambiguous occurrence `split'
08:50:13 <lambdabot>  It could refer to either `System.Random.split...
08:50:16 <Cale> of course
08:50:17 <Cale> lol
08:50:43 <Cale> > Split.split (Split.keepDelimsL (Split.oneOf [2,5,9])) [0..10]
08:50:45 <lambdabot>   [[0,1],[2,3,4],[5,6,7,8],[9,10]]
08:51:13 <iamtakingiteasy> awesome
08:51:52 <Cale> Yeah, there are so many ways to want to split up lists that Brent decided to design a language in which to express them :)
08:52:40 <Cale> > Split.split (Split.keepDelimsL (Split.oneOf [2,5,9])) [2,2,2,2,5,2,5,9]
08:52:41 <lambdabot>   [[],[2],[2],[2],[2],[5],[2],[5],[9]]
08:52:53 <Cale> > Split.split (Split.condense (Split.keepDelimsL (Split.oneOf [2,5,9]))) [2,2,2,2,5,2,5,9]
08:52:54 <lambdabot>   [[],[2,2,2,2,5,2,5,9]]
08:53:19 <Cale> > Split.split (Split.dropInitBlank . Split.condense . Split.keepDelimsL . Split.oneOf $ [2,5,9]) [2,2,2,2,5,2,5,9]
08:53:22 <lambdabot>   mueval-core: Time limit exceeded
08:53:31 <Cale> lol, what?
08:53:32 <Cale> > Split.split (Split.dropInitBlank . Split.condense . Split.keepDelimsL . Split.oneOf $ [2,5,9]) [2,2,2,2,5,2,5,9]
08:53:34 <lambdabot>   [[2,2,2,2,5,2,5,9]]
08:54:36 <sheldonh> Saizan: so when a function compiles to a 2 arg, and then you create a variable using the function and only one arg, that compiles down to a new function that takes one args, contains the other, and passes both to the 2arg function?
08:54:46 <Cale> > Split.split (Split.startsWithOneOf $ [2,5,9]) [0..10]
08:54:47 <lambdabot>   [[0,1],[2,3,4],[5,6,7,8],[9,10]]
08:54:54 <Cale> > Split.split (Split.startsWithOneOf $ [2,5,9]) [2,2,2,2,5,2,5,9]
08:54:55 <lambdabot>   [[2],[2],[2],[2],[5],[2],[5],[9]]
08:55:09 <Saizan> sheldonh: yeah
08:55:36 <iamtakingiteasy> > Data.List.Split.split (keepDelimsL (whenElt ((`elem`[2,5,9]) . snd))) (zip ['A'..] [0..10])
08:55:37 <lambdabot>   Not in scope: `Data.List.Split.split'Not in scope: `keepDelimsL'Not in scop...
08:55:42 <sheldonh> Saizan: ok, i feel much more comfortable now. maybe i should be looking at what the examples compile down to :)
08:56:10 <Saizan> sheldonh: it's not always like that though
08:56:13 <Cale> sheldonh: Basically, by default functions of multiple parameters are really functions of one parameter whose result is another function, but the compiler will sometimes recognise cases where you always pass more than one parameter and optimise things a bit.
08:56:20 <iamtakingiteasy> > Split.split (Split.keepDelimsL (Split.whenElt ((`elem`[2,5,9]) . snd))) (zip ['A'..] [0..10])
08:56:21 <Saizan> sheldonh: depends on what GHC decides is more efficient
08:56:22 <lambdabot>   [[('A',0),('B',1)],[('C',2),('D',3),('E',4)],[('F',5),('G',6),('H',7),('I',...
08:56:27 <iamtakingiteasy> there i go
08:56:34 <DanBurton> anyone have any idea how to answer this question? http://stackoverflow.com/questions/12112698/control-documented-type-signature-of-re-exported-function
08:56:54 <DanBurton> I really want a solution but I get the feeling that the answer is going to be "you can't do it, submit a trac ticket"
08:56:59 <monochrom> I think it can't be answered
08:57:10 <sheldonh> Saizan, Cale: and i'm guessing i shouldn't concern myself with C-level optimisations yet :)
08:57:21 <monochrom> you can't do it. submit a Haskell2020 ticket
08:57:22 <Saizan> sheldonh: right
08:57:30 <DanBurton> monochrom: o_o
08:57:47 <Cale> sheldonh: Yeah, and just get used to the fact that for a while all your intuitions about what is efficient are going to be wrong.
08:57:54 <sheldonh> pity, that would have made an epic procrastination :)
08:58:11 <hiptobecubic> unless you are doing numerics with unboxed vectors, then things seem pretty similar to me
08:58:13 <hiptobecubic> at least so far
08:59:09 <Cale> sheldonh: The order in which things are evaluated is up to the compiler, but the usual ordering (lazy evaluation), is actually exactly backwards from what you'll expect. If you write f (g (h x)), it's f which is evaluated first :)
08:59:25 <monochrom> IMO it is misguided to try to control when and how type aliases are expanded and contracted
08:59:36 <sheldonh> Cale: w. t. f.
08:59:42 <jfischoff> haha
09:00:11 <sheldonh> Cale: i'm tempted to ask how that's possible, but i don't think the answer is going to make me feel better right now :)
09:00:12 <Cale> sheldonh: and (g (h x)) is passed as the parameter.
09:00:23 <sheldonh> oh. okay THAT makes sense
09:00:31 <sheldonh> oh right. lazy. duh
09:00:32 <Cale> sheldonh: A runtime representation of expressions, of course :)
09:00:47 <monochrom> (if 5<6 then (\x -> x+1) else (\x -> x-1)) (5*4)  the if-then-else is likely evaluated first
09:01:03 <monochrom> because the function has to be resolved first
09:01:11 <Cale> (the data structure used to represent an expression at runtime is called a thunk, but I prefer to just think about and speak of expressions)
09:01:59 <dmwit> > (if 5 < 6 then 42 else 69) undefined
09:02:00 <lambdabot>   42
09:02:07 <monochrom> actually a better example is (if 5<6 then (\x ->x+1) else (\x -> 0)) (5*4). you want to know whether you run into the (\x->0) case and can skip the argument
09:02:42 <monochrom> evaluate until the function is clearly a lambda. then you can plug in parameters and continue
09:03:02 <Cale> DanBurton: GHC tries to preserve the names of types used in the declarations of things when they're explicitly given by the programmer
09:03:26 <Cale> DanBurton: Try defining  thing :: Bar; thing = Foo 3, and then asking for the type.
09:03:56 <monochrom> you didn't think of it because, by 30 years of C experience, you didn't know that a function could be unresolved until runtime
09:07:17 <johnn> hi
09:09:12 <thirsteh> how do I represent ESC? ^[
09:09:30 <monochrom> depends on who's reading it
09:09:55 <thirsteh> want to hPutStrLn a string with ESC codes in it
09:09:56 <sheldonh> wow. this lazy evaluation thing means that a lot of computation can be saved, where conditional branches didn't need an argument after all
09:10:11 <monochrom> \27
09:10:47 <monochrom> it saves some computations and wastes some others
09:10:54 <sheldonh> oh :(
09:11:07 <typoclass> thirsteh: try "\ESC"
09:11:29 <ion> > [minBound..] :: [Char]
09:11:31 <lambdabot>   "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\S...
09:11:46 <hiptobecubic> nice trick
09:11:47 <thirsteh> oh, I'm stupid. monochrom, typoclass: both worked perfectly, thanks!
09:11:57 <monochrom> if (this takes a year to evaluate) then 'x' else 'x' ---> takes a year to evaluate
09:12:40 <monochrom> actually that is not a good example, eager languages do that too
09:13:36 <monochrom> I guess the best example is foldl (+) 0. eager is more efficient
09:13:51 <mm_freak_> sheldonh: laziness isn't really about saving computation time…  it's about enabling exciting paradigms of programming
09:14:06 <mm_freak_> laziness won't make your program faster, but it allows you to write your program in new, different ways
09:14:22 <thirsteh> zip [1..] xs
09:14:35 <mm_freak_> in general we are willing to give up a negligible amount of speed for that convenience and beauty
09:14:47 <mm_freak_> (negligible for most applications)
09:16:36 <sheldonh> mm_freak_: i'm a ruby programmer, so i've already bought into that trade off :)
09:16:52 <sheldonh> mm_freak_: well, a trade off that has the same smell :)
09:17:13 <mm_freak_> sheldonh: it's not as bad as in ruby though…  you usually have about 50%-80% of the speed of the corresponding C program =)
09:17:20 <mm_freak_> sometimes a bit less, sometimes even more than 100%
09:17:52 <sheldonh> mm_freak_: it's been a long time since a high level language couldn't give me what i wanted :)
09:18:23 <mm_freak_> yet it's nice to know that a high level language like haskell can produce fast code =)
09:21:32 <carter> copumpkin you have two handles?
09:21:57 <carter> anyone else hitting type checker bugs in the 7.6rc ?
09:23:47 <DanBurton> Cale: the thing is, I want to do this for Data.Text.Lazy.Internal.Text
09:24:24 <DanBurton> Cale: I have a synonym "LText" for it, but I don't know how to tell ghc to use this synonym
09:24:57 <Cale> DanBurton: It will use it when you use it.
09:26:05 <monochrom> I would just write in the text of my doc: "the Text in the type refers to the lazy one"
09:26:33 <carter> the current typelits stuff in the 7.6 release candidate can't even deduce that 1<=2
09:26:34 <carter> !
09:26:51 <Cale> DanBurton: if you use it in the typesignatures for things, it will show up like that when you ask for :t of stuff.
09:28:35 <Cale> Why does Haddock always mess with (and screw up on) parens? http://www.haskell.org/ghc/dist/current/docs/html/libraries/base-4.5.0.0/GHC-TypeLits.html#t:-60--61-
09:29:20 <Cale> If it just literally copied the declaration head from the source code, it wouldn't have that problem.
09:29:55 <Cale> carter: so this class doesn't work?
09:30:24 <carter> Cale : looks that way: look at my most recent 2 gists
09:30:26 <carter> :)
09:31:12 <carter> Cale
09:31:13 <carter> https://gist.github.com/3445419
09:31:19 <carter> load in ghci
09:31:23 <carter> then do :t a
09:32:11 <Cale> I don't have 7.6 installed
09:32:11 <carter> basically it looks like doing anything computational with known type level nats requires having a solver instantiate the variables
09:32:18 <carter> Cale: just tliing you
09:32:41 <monochrom> I think we humans underestimate the difficulty of doing arithmetic
09:32:48 <carter> and this is making me think: I'd much rather just have type level closed recursive functions
09:33:00 <carter> rather than punt on magic solver goodness
09:33:09 <monochrom> only computers and small kids know that it is pretty difficult
09:33:11 <carter> monochrom: i'm not wanting a magic decision proceedures
09:33:29 <carter> I want to just be able to define a darn "absolute value of different of two natural numbers"
09:33:34 <carter> and compute with it
09:33:41 <Cale> lol, type level Presburger arithmetic
09:40:13 <ranger66> hello, why _exactly_ is it not possible to make data F a = F (a -> Int) an instance of Functor?
09:40:55 * monochrom breaks his own oath
09:41:06 <monochrom> because it doesn't "contain" a
09:41:49 <ranger66> but (Int->a) does?
09:41:50 <Cale> If you have a function (a -> b), and a function (a -> Int), you can't put them together to get a function (b -> Int)
09:41:52 <monochrom> there is a better reason but I don't know the details
09:42:20 <Philippa> right, you'd need b -> a instead
09:42:36 <Cale> If you have a function (a -> b) and you have a function (Int -> a), then you can compose them to get a function (Int -> b)
09:43:48 <Cale> (and the associativity and right unit of composition will provide the functor laws)
09:44:03 <Philippa> tl;dr: follow the types you have to implement, see what breaks
09:44:09 <Cale> er, left unit, rather
09:45:52 <ranger66> Philippa: i tried but failed: fmap :: (a->b) -> f a -> f b so for data F a = F (a->Int) it would be: fmap :: (a->b) -> (a->Int) -> (b->Int)?
09:46:10 <Cale> ranger66: yes
09:46:19 <vcjklaps> is there a class somewhere of contravariant functors?
09:46:32 <ranger66> vcjklaps: cofunctor?
09:46:52 <Cale> ranger66: well, it's (a -> b) -> F a -> F b of course, but if you unwrap the F, that's basically what you have
09:47:01 <ranger66> yes ok
09:47:22 <Cale> vcjklaps: http://hackage.haskell.org/package/contravariant
09:47:38 <nand`> (why did I have the suspicion that would be an edwardk package?)
09:47:52 <vcjklaps> ah yes, F could be given an instance of Cofunctor
09:48:14 <Philippa> ranger66: which somewhere requires a function of the type a -> b
09:48:35 * Philippa hands ranger66 `const undefined`
09:49:50 <Cale> fix id is the solution to all our problems
09:49:59 <nand`> fix error is
09:50:23 <Cale> > fix error
09:50:24 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
09:51:16 <Philippa> fix id will protect you from the terrible secret of space?
09:51:52 <Cale> 0 bits ought to be enough for anyone
09:52:06 <ion> > fix (error . show)
09:52:06 <c_wraith> I can express any lack of information in 0 bits
09:52:08 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
10:00:47 <spark_> Hey, I have a type foo a a a,bar b b and a function f :: [a]->[b], is there any neat way to have g :: [foo]->[bar] ?
10:02:09 <monochrom> no
10:02:11 <simon> spark_, not without some h :: foo -> bar, I think.
10:02:27 <spark_> darn
10:02:42 <spark_> thanks
10:02:46 <nand`> to summarize, you want (a,a,a) -> (b,b) ?
10:02:56 <spark_> oh wait, i forgot a b there
10:02:59 <nand`> maybe I'm misreading
10:03:34 <nand`> oh, rather [b] -> [b] -> [bar]
10:03:36 <monochrom> it is a very ill-written question
10:03:42 <nand`> something like that
10:03:44 <nand`> w/e
10:03:49 <simon> it seems a bit abstract.
10:04:35 <spark_> Well, I have an axis type, and a list of [axis], im trying to map a function in each axis
10:05:12 <simon> map f axises?
10:05:48 <spark_> but f takes from a->a(the type from the a single axis)
10:06:04 <nand`> so you want to apply f to each element of a pair/triple ?
10:06:10 <spark_> exactly
10:06:17 <ranger66> sorry i'm not yet through this :) - i need a way to apply (a->Int) to (a->b) so that i get (b->Int)? why is this not possible?
10:06:25 <simon> by "list of [axis]", I assume you mean just [axis], right?
10:06:31 <nand`> map3 f (a,b,c) = (f a, f b, f c) -- done
10:06:35 <spark_> yes
10:06:43 <nand`> map (map3 f)
10:07:17 <spark_> ahh, nand`, sorry I misinterpreted what you said
10:10:22 <simon> ranger66, if f :: a -> Int, g :: a -> b, then getting some h :: b -> Int, you would need the inverse of f and compose it with g.
10:10:55 <simon> ranger66, if the inverse f' :: Int -> a, then f . g :: Int -> b.
10:11:41 <nand`> that doesn't seem right
10:11:46 <nand`> but it works if you take the inverse of g
10:12:01 <nand`> f . g' :: b -> Int
10:12:36 <simon> oops, my mistake. mine would be b :: Int -> b.
10:13:01 <ranger66> and i cannot inverse a function?
10:13:06 <nand`> not in general, no
10:14:06 <ranger66> ok i understand why it doesn'T work via composition but does that tell me that it is not working in another way?
10:14:08 <simon> ranger66, mathematical functions that have inverses are bijective. many practical functions aren't.
10:14:38 <spark_> http://hpaste.org/73641 this should explain what I want better
10:14:42 <ranger66> that i got :)
10:16:00 <aristid> now that's pricing. http://precog.com/pricing
10:17:38 <nand`> ranger66: there's only really one way to construct a function, and that's via lambda abstraction - so to construct a function (b -> Int) you'd need to abstract over the ‘b’ and then transform it into an Int somehow via applications; none of the functions in your assumptions accept a ‘b’, so there's nothing you can do with it
10:20:03 <ranger66> nand`: wow that's easier than i thought
10:20:06 * copumpkin beholds his glory
10:20:11 * nand` .oO( Would a compiler flag to warn on top-level ‘undefined’ definitions be useful? ’
10:20:21 <nand`> ranger66: what do you mean?
10:20:37 <ranger66> your answer
10:21:11 <nand`> ah, you mean the explanation why it can't work?
10:21:17 <ranger66> yes
10:21:27 <ranger66> it's to the point
10:21:31 <simon> spark_, since f handles only [Integer], you can't apply it to the (Integer,Integer,Integer)s inside [Axis].
10:21:40 <ranger66> i understood that
10:21:49 <ranger66> thank you all very much
10:22:11 <simon> spark_, you need some other f :: Integer -> Integer and map3 f axises.
10:22:12 <spark_> simon:  so I have to create helper functions to get the lists, right?
10:23:08 <johnw> might anyone have a guess as to why lambdabot, run from command-line, never produces a prompt?
10:24:13 <nand`> ugh, agda pulls in emacs?
10:24:20 <spark_> alright, i was just hoping there would be some nice [F a a]-> (f [a] , f[a]) -> [F a a] function
10:24:57 <typoclass> johnw: no idea, but is it listening on some irc port? i mean, it doesn't produce prompts in here, for instance
10:25:12 <geekosaur> nand`, sounds like someone's packaging is wonky.  if it's rpm-based, by default it's likely to notice inclusion of a .el defining an agda editing mode and impute an unnecessary dependency on emacs
10:25:40 <nand`> geekosaur: so agda itself does not somehow rely on emacs? If so, I'll amend the package and make it configurable
10:25:52 <geekosaur> I wouldn't expect it to
10:25:53 <simon> spark_, or rather, that is if type Axis = (Integer,Integer,Integer). if data Axis = Axis Integer Integer Integer, then f needs to be of type Axis -> Axis before you can map f axises.
10:26:02 <byorgey> johnw: there's some flag or somethingyou have to pass to run it in command-line mode.  I don't remember what it is.
10:26:15 <geekosaur> just something I regularly see happen with dependency-happy linux package managers
10:26:31 <simon> spark_, what are F and f in that signature?
10:26:54 <nand`> geekosaur: it's not an optional dependency in the package, or that wouldn't have been a problem
10:27:02 <spark_> simon:  ah sorry, that isnt a type signature, is more like what I was expecting as steps
10:27:46 <simon> spark_, usually when there are ->s, it is a type signature. :-)
10:28:11 <geekosaur> nand`, what platform?  RH/fedora doesn't do so great with optional dependencies, fr example
10:28:18 <nand`> geekosaur: gentoo/portage
10:28:29 <geekosaur> and I notice the agda library package on hackage eplicitly mentions an emacs interface
10:28:38 <hayashi> blagh, cabal dependency hell gogogo
10:28:56 <spark_> simon:  bad channel to use arrows as steps D:
10:29:19 <geekosaur> I don't think it's required in the sense of you can't use agda without emacs; you probably want the agda-executable package though
10:29:37 <geekosaur> and, I have no idea how gentoo's portage sets things up
10:29:39 <nand`> geekosaur: that's the plan
10:30:07 <geekosaur> hopefully I will get myself back into position to set up a gentoo VM and play with it soonish :/
10:31:47 <geekosaur> oh, that's interesting, it actually has a command for configuring the emacs mode.  still not required but probably makes it harder to disentangle the emacs prerequisite
10:31:57 <applicative> I think using agda without emacs is likely to be hopeless. the package includes a special el file.
10:31:59 <nand`> well, here goes nothing
10:32:00 <simon> spark_, yes. in one ML book I saw ~> being used as reduction steps.
10:32:03 <geekosaur> (shell-level command)
10:33:39 <applicative> nand`: are you trying to avoid the emacs dependency
10:34:03 <nand`> that's odd, I actually get a build error in src/full/Agda/Termination/Lexicographic.hs:233:30 `maxDiscard' is not a (visible) constructor field name
10:34:05 <nand`> applicative: yes
10:34:08 <nand`> applicative: is that not possible?
10:34:46 <applicative> it will compile and thus check valid .agda files
10:35:36 <applicative> but the brains necessary to make a valid agda file without the constant interaction with the typechecker would far outclass my own :)
10:36:01 <nand`> does agda have no repl other than emacs?
10:36:19 <applicative> its not a repl
10:36:27 <applicative> it's hard to describe
10:36:37 <hayashi> package I want depends on versions of other packages I can't use, but works fine if I tweak the cabal file to accept the newer versions and I can build against the result.  Not entirely sure of the least awful way to proceed, except maybe emailing the package author or something
10:36:59 <applicative> but basically trying to write a file in emacs you leave holes and so on and ask the typechecker if its okay, and it fills in blanks and so on
10:37:14 <nand`> or perhaps assuming the worst case scenario, can I use it without knowing a single thing about emacs?
10:37:29 <applicative> the agda-composition process is extremely interactive.  I would kill to be able to use something other than  emacs
10:37:38 <hayashi> is there a semi-standard thing to do when confronted with dependency issues caused by packages depending on outdated stuff that your packages can't use?
10:38:28 <applicative> nand`: you dont need to know much that is general emacs, just obvious things about opening and saving files; then there are agda-specific keybindings
10:39:00 <nand`> I wonder if I can somehow shoehorn it into just reloading the file constantly in emacs, so I can use vim to edit it
10:39:00 <applicative> i didn;t know any emacs to speak of before using it, and could get away with not knowing much.
10:39:08 <nand`> then reload in emacs whenever I want to check
10:39:56 <nand`> (that's assuming I can get it to build first)
10:39:56 <applicative> nand`: yeah you could do that, but I think you will soon find it impractical, though you  probably have more knowledge how to make it practical than I did
10:40:04 <applicative> well yes...
10:40:06 <nand`> doubtful
10:41:05 <applicative> but as I say the general emacs things you need to know are not many. Isn't there a vim-like overlay so that at least some of you instincts would be respected?
10:42:35 <applicative> I found emacs a considerable impediment, but its so cool, it was worth it to get past the emacs impediments.  On the other hand its not like I'm skilled with any editor so I wasn't  losing much
10:43:04 <applicative> I mean, agda is so cool
10:43:35 <applicative> nand`: there is an #agda maybe someone there will have wisdom how to negotiate this
10:45:00 <nand`> odd, I'm getting a ‘darcs get’ failure when trying to install the latest
10:46:22 <nand`> s/get/pull/
10:46:37 <nand`> agh, that replacement didn't work as expected
10:48:29 <sm> hayashi: first decision is, update the main package installation, or create a separate one for this project ?
10:48:44 <mk> if the error monad defines Left l >>= _  =  Left l, then how does the left value end up ever being caught?
10:49:32 <shachaf> I don't know what "caught" means, but the answer is probably "using a function other than >>="
10:51:02 <mk> but this other function behaves almost exactly like bind, except that it treats Right and Left opposite to how bind treats them?
10:51:26 <mk> (that is, it accepts left, but ignores right?)
10:52:26 <Clint> what?
10:52:52 <monochrom> clearly, this other function does not behave almost exactly like bind
10:53:20 <shachaf> mk: The other function behaves however you want.
10:53:23 <shachaf> It's a function.
10:53:24 <typoclass> mk: i'm not sure what you mean, but "Left l >>= _ = Left l" doesn't ignore the Left. it means when a Left is put into it as the first argument, it will ignore its second argument
10:54:07 <hayashi> sm: well, I've git cloned the library, changed the cabal package and installed it under a different name for now, which should be fine because I'm only using it for internal stuff that won't go on hackage any time soon, but that's not as tidy a solution as I'd have liked
10:54:31 <sm> hayashi: nice
10:54:47 <sm> there's also the virthualenv/cabal-dev solution
10:55:58 <mk> typoclass: bind usually passes the monadic value "through" its bound function in some way. In the case of Left (or Nothing), bind "ignores" it, and lets it pass through unaltered. Yeah?
10:57:26 <mk> shachaf: this other function, what happens when it receives a Right value?
10:57:36 <shachaf> Whatever you want.
10:57:39 <typoclass> mk: yes. if you have "a >>= b >>= c >>= d" and b produces a Left (= an error), then c and d are never evaluated
10:57:44 <hayashi> er, changed the cabal file (literally bumping all the dependent version numbers up one or two)~
10:57:57 <shachaf> It's your own function, so you can decide what it does.
10:58:21 <nand`> looks like the ‘maxDiscard’ error might be due to QuickCheck (maxDiscard is a field name in the Test.QuickCheck.Test.Args record)
10:58:31 <mk> shachaf: so in haskell, programmers tend to actually use that function to modify Right values?
10:58:33 <nand`> maybe my version of quickcheck is too new or too old or something
10:58:41 <shachaf> mk: What function?
10:58:46 <shachaf> I have no idea what you're talking about.
10:58:53 <mk> (I mean, I understand how this is equivalent to a finally clause, but those are rare.)
10:58:59 <shachaf> What?
10:59:16 <mk> shachaf: the one you just mentioned. "your own function". As in, the one that "catches" Left values.
10:59:53 <shachaf> 10:49 <shachaf> I don't know what "caught" means, but the answer is probably "using a function other than >>="
11:00:03 <shachaf> I don't know what this has to do with "finally".
11:00:27 <shachaf> You can write a concrete function: f (Left x) = something; f (Right y) = something
11:00:40 <shachaf> It can do whatever you want.
11:02:10 <mk> shachaf: in other languages, finally is often used to perform additional operations, whether or not an exception was thrown. By specifying this "catching" (ie, does not merely let Left values pass through) function to also alter Right values, that's something very much like finally.
11:03:15 <mk> typoclass: thanks, yeah, that makes sense
11:03:17 <nand`> it sounds like you are asking about Control.Exception.catch rather than Either
11:03:19 <shachaf> I have no idea what you you mean but I don't think it's right.
11:03:33 <shachaf> nand`: (Either e) is certainly an exception monad.
11:04:04 <monochrom> finally main@(Left _) final = final >> main
11:04:15 <mk> nand`: I'm just looking at the definition of Error, and it uses Left and Right (left stores exception, right stores the "right"/correct value)
11:04:15 <monochrom> err nevermind
11:04:20 <shachaf> mk: Why don't you think about what thing you want -- it can be anything in the world -- and then figure out how to do it.
11:04:20 <mjga> BTW: beside submitting a patch to *.cabal file, or notifying the maintainer (the former is better), there is a growing consensus that Package Versioning Policy should be relaxed to remove upper bounds, unless they are absolutely necessary.
11:04:32 <mjga> hayashi: BTW: beside submitting a patch to *.cabal file, or notifying the maintainer (the former is better), there is a growing consensus that Package Versioning Policy should be relaxed to remove upper bounds, unless they are absolutely necessary.
11:04:40 <shachaf> monochrom: Yes, we're apparently talking about Java here. :-)
11:04:57 <byorgey> mjga: I don't think there is such a consensus at all.
11:05:04 <Clint> sadly not
11:05:19 <mjga> byorgey: I must have misunderstood recent Haskell Cafe posts then :-(.
11:05:30 <monochrom> yes, beware of selection bias
11:05:46 <byorgey> mjga: some on the Cafe have advocated removing upper bounds.  Others have argued why this is a bad idea.  There is no consensus.
11:05:52 <mk> shachaf: I'm not sure what you're saying there. I'm asking something specific about how an error monad's left values tend to be handled.
11:06:16 <shachaf> mk: What behavior are you after here?
11:06:27 <mjga> byorgey: I must have been biased by both personal experience, and the unrefuted claims that there are not too many examples when hard upper bounds help.
11:06:29 <sclv> growing consensus is wrong, but "significant sentiment" is probably correct
11:06:36 <mk> shachaf: none. I'm asking about typical, perhaps "idiomatic" use
11:06:39 <monochrom> my impression is that there is a consensus on "we need both soft bound and hard bound". this is due to my selection bias on the one single message that suggests it
11:06:47 * nand` .oO( catch :: Either e a -> (e -> a) -> a )
11:06:53 <sclv> and also "there are well known maintainers of well known packages" that don't use upper bounds as strongly as the pvp would perscribe
11:07:04 <shachaf> Yes, you can use a function like nand`'s, for instance.
11:07:04 <mjga> sclv: I understand that would require at least a significant political campaign and then a proper voting process ;-)
11:07:08 <sclv> erm those quotes should really be slightly dif.
11:07:17 <sclv> mjga: to change the pvp, yes.
11:07:18 <nand`> though it probably shouldn't be called ‘catch’
11:07:20 <hayashi> I think I'll go check to see if the library actually works before sending off a patch request, there doesn't appear to be a testsuite I can use (it DID compile correctly, which is reassuring)
11:07:29 <sclv> in practice we have various practices, with no enforcement :-)
11:07:29 <nand`> catch I think would imply (e -> Either e a) -> Either e a
11:07:41 <nand`> (I left off the first argument)
11:07:56 <mjga> monochrom: I also would say that we rarely need hard bound, but soft bound would be useful as a sign of what _was_tested_, but obviously some people understand it another way.
11:08:03 <monochrom> catch (Left x) handler = handler x
11:08:38 <monochrom> catch r@(Right _) handler = r
11:08:53 <nand`> that @(Right _) shouldn't be needed
11:09:02 <shachaf> But it's nice anyway.
11:09:09 <shachaf> That way all the cases are disjoint.
11:09:10 <monochrom> I like more symmetry
11:09:30 <mjga> sclv: I must say that this is probably a rare moment when "best practice suggestion" seems to be burning many people over a long time. I am afraid that I do agree that "best practice" manuals are best first tested in practice.
11:10:20 <shachaf> You can make it more general with catch (Right x) handler = Right x
11:10:26 * mjga covers his head with ash. Sorry!
11:10:26 <mk> http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Error-Class.html
11:10:28 <shachaf> (Because then the result can be of a different type.)
11:10:36 <byorgey> I think there is going to be pain associated with package version management no matter what the policy, and everyone will always think the grass is greener on the other side.
11:10:46 * shapr hugs byorgey for awesome code
11:10:47 <mk> A common idiom is:do { action1; action2; action3 } `catchError` handler
11:10:54 <Clint> unless the problem is solved in a better way
11:11:07 <byorgey> shapr: thanks!  which code, if I might ask? =)
11:12:15 <mjga> mk: what would be precedence of catchError if one wants to use indentation instead of { ; }?
11:13:14 <mk> it seems that catchError would tend to behave in a way opposite to bind. It would let Right values pass through unaltered (or might unwrap them), but it would detect and do something with Left values
11:13:27 <mk> mjga: that's pasted from the above link
11:13:27 <nand`> mjga: probably whatever the default precedence is; I think infixr 9
11:13:31 <nand`> or maybe infixl 9
11:13:35 <whoev> hey it's byorgey
11:13:35 <whoev> <3
11:13:48 <monochrom> we have just written the code for catch. are you too busy asking to read answers?
11:14:17 <mk> am I in some way mistaken about how catchError tends to behave?
11:14:38 <mjga> nand`: I meant that I wonder whether thats understood as do { ...} `catchError` handler or rather as do { ...; (lastAction `catchError` handler) }, then the idiom is rather inconvenient
11:14:42 <monochrom> or equivalently since you're on the catchError page you can find and read its implementation
11:14:55 <monochrom> unless you will it to remain a mystery
11:14:59 <nand`> mjga: it's most certainly catchError (do { ... }) handler
11:15:22 <nand`> oh
11:15:27 <nand`> you meant when using indenting
11:15:40 <shapr> byorgey: I'm enjoying playing with diagrams interactively!
11:15:55 <byorgey> hi whoev
11:16:01 <byorgey> shapr: nice =)
11:16:08 <mjga> nand`: and that is the problem :-( I always have when catching exceptions: parenthesitis
11:16:09 <typoclass> mk: right, what you described the last few minutes seems all plausible. that function catchError would make sense
11:16:23 <mk> monochrom: my confusion is due to the fact that earlier, I was repeatedly told that I could "implement this function however I wanted"
11:17:27 <mk> typoclass: thanks. Is it bad form to define catchError in such a way that it does alter Right values?
11:17:33 <mjga> nand`: I believe that is why people use rather a handle (\(e :: SomeException) -> ...) $ do actions type of syntax
11:18:47 <mjga> nand`: indeed python's special syntax for catching exception is quite a beauty with try;\n  actions\nexcept e:\n  ...\nfinally:  ...
11:19:12 <nand`> mjga: http://hpaste.org/73645 <- demo evaluates to ‘Just 5’
11:19:16 <mjga> nand`: then it feels like just another control construct it indeed is
11:19:36 <monochrom> "you can implement however you want" is a correct answer to a poorly written question you posed
11:19:37 <nand`> indicating that it applies to the entire do block
11:19:49 <nand`> if I indent the `foo` past the start of the do block's alignment, then it evaluates to Nothing
11:19:56 <nand`> indicating that it only applies to the Just 4
11:21:25 <typoclass> mk: if there is something sensible that catchError can do with your Right value, then sure, it could do that. or you might say "no, i'd like catchError to be as simple and clear as possible, i want it to do only call the handler and nothing else". both choices seem reasonable to me
11:22:15 <typoclass> monochrom: "what do you mean" might have made more sense ...
11:22:36 <monochrom> I think that was asked before, too
11:22:41 <mjga> nand`: but I expected it ;-). Unfortunately Haskell doesn't yet have Maude's "mixfix" operators yet
11:23:00 <mjga> nand`: so that one could define their own try _ catch _ finally _
11:23:04 <mk> typoclass: that's helpful, thanks
11:23:09 <monochrom> the wonder of a poorly written question is that it can still be a perfectly clear question, just that it is an XY Problem
11:23:46 <nand`> mjga: see the annotation here also: http://hpaste.org/73645 <- this time the `foo` bit only applies to lines 6-8
11:23:57 <monochrom> Q:"am I confined to writing functions identical to bind?" A:"of course not, you can write functions to do whatever you want"
11:24:02 <nand`> you could use syntax like that if you want to throw around exception handling without using excessive parentheses
11:24:35 <typoclass> monochrom: sure, but the the asker isn't entirely to blame. i think it's largely up to the answerer to detect things like the XY problem
11:25:04 <monochrom> no, XY Problems can only be detected postmortem, that is, after the asker reveals more information
11:25:14 <monochrom> this is basic information theory
11:25:15 <nand`> What's an XY problem?
11:25:41 <typoclass> monochrom: which is my point. saying "what do you mean" is what you do to get the asker to reveal more information
11:26:02 <mk> monochrom: what was poor about it? If you don't understand what I mean by eg "catch", you can ask me, and if you suspect that I mean "catchError", you might mention that, no?
11:26:23 <mjga> nand`: not that it is apparent of what happens :-), but it is better than nothing ;-)
11:26:27 <monochrom> XY Problem: you want to add two Int's in haskell. you deduce that using bitwise logic operators is a good approach. you spend all your time in #haskell asking about bitwise logic operators
11:26:47 <nand`> mjga: I think it's completely apparent what's going on
11:26:52 <nand`> mjga: you just need to learn to read indentation
11:27:02 <mjga> nand`: Maybe I should start using it just to make sure people fall into "indentrap" when changing the code
11:27:33 <monochrom> typoclass, if the written question is clear, it is hard to guess that the asker wants something else
11:27:52 <zhulikas> :D
11:28:03 <nand`> monochrom: ah, yes; I am familiar with this problem
11:28:09 <monochrom> but you can be cynical. assume everyone never writes what they mean. always ask "what do you mean" unconditionally. I used to do that
11:28:12 <nand`> monochrom: aka ‘not asking about what you actually want to achieve’
11:28:52 <monochrom> there is another XY Problem I really like. it's a good joke. "males" :)
11:29:24 <nand`> that could probably be reduced to the ‘X’ problem: males and females
11:29:57 <monochrom> http://www.perlmonks.org/index.pl?node_id=542341 :)
11:30:48 <mk> monochrom: "Haskell will not check that Right comes out unaltered, and there's no law against it, nor is it discouraged as non-idiomatic. Just be reasonable."
11:31:23 <mk> looks like a list
11:31:38 <monochrom> yes? you're telling me this quote because...?
11:32:01 <monochrom> oh I'll use the typoclass method
11:32:11 <monochrom> what do you mean?
11:33:47 <nand`> I like the answer that goes like ‘answer Y and you get flamed for presenting misleading/helping with bad solutions, answer X and you get flamed for not answering the question’
11:34:27 <mk> monochrom: you seem to be saying that a response like "it behaves however you want" is correct and appropriate?
11:35:12 * monochrom is tempted to say "what do you mean" again
11:35:28 <monochrom> it is a correct answer to the written question at that time
11:35:46 <shachaf> monochrom: That strategy is getting warnings from my termination checker.
11:36:03 <monochrom> the written question was "but but the function has to behave as bind". the correct response is "no"
11:36:06 <typoclass> nand`: that might be true for whatever perl subcommunities, but i don't think a lot of flaming goes on in #haskell. conflict in here always seems pretty calm and productive
11:36:27 <nand`> typoclass: most of the time, I'd agree
11:36:44 <typoclass> shachaf: what do you mean? ;)
11:36:49 <mk> monochrom: no, the question was "but this other function behaves almost exactly like bind, except that..."
11:37:04 <nand`> typoclass: he means monochrom well be sitting here 3 days from now responding to mk's trolls/questions/whatevers
11:37:19 <nand`> s/well/will/
11:37:53 <monochrom> it is not troll. but it is certainly too much writing essays and too little scientific experiments
11:37:59 <paolino> is the deriving mechanism working in presence of type families ?
11:38:18 <typoclass> nand`: yes yes i got that, i was just kidding (see smiley). it's also possible that people get stuck in an infinite loop where the reaction to each "what do you mean" is another "what do you mean"
11:38:30 <nand`> typoclass: oh. that went over my head
11:38:46 <nand`> I must be too tired for this
11:39:26 <nand`> typoclass: if you had done this expertly, you would have replied ‘what do you mean’ to my response :)
11:39:56 <paolino> the deriving Traversable makes the classic "impossible happened", but even deriving show requires the type family to be instance of Show, which I cannot satisfy with context
11:40:07 <nand`> so is it just me or does hpaste no longer announce pastes?
11:40:20 <monochrom> "if you answer X, you may get flame" is possible in any community. the flame comes from the asker. the asker doesn't like how you can do X without going through Y, so the asker flames you
11:40:52 <spark_> > 0x12
11:40:53 <lambdabot>   18
11:40:58 <spark_> > 0b12
11:40:59 <lambdabot>   Not in scope: `b12'
11:41:04 <spark_> > 0b10
11:41:05 <lambdabot>   Not in scope: `b10'
11:42:28 <typoclass> > 0o7 -- spark_: afaik there's only decimal, 0x, and 0o. but binary is pretty easy to translate into hex (4 binary digits are 1 hex digit)
11:42:29 <lambdabot>   7
11:44:08 <mk> monochrom: I've found that it's usually the "community" that flames the "asker", especially if the asker isn't a regular in the community
11:44:09 <Tehnix> Evening all :) Running into a bit of a problem since my knowledge of type declaring in Haskell is very limited, but gonna ask for directions anyhow (just a sec)
11:45:38 <Tehnix> If you have a function: 'pTriplet a b n' where all three arguments are integers, and it can only return eiter a) an integer or b) a recursive call to itself. Are there any general way of declaring this in the type declaration of the function (if that was enough to go on)?
11:46:45 <Tehnix> ie like pTriplet :: Integral a => a -> a
11:46:47 <typoclass> Tehnix: sounds like a basic (Integer -> Integer -> Integer -> Integer) to me. or Int.
11:46:57 <Tehnix> ah
11:47:03 <mk> like if I say "I don't get that answer" instead of "oooh... yeah... I'll think bout that", I might end up with "monochrom will be sitting here 3 days from now responding to mk's trolls/..."
11:47:04 <typoclass> or yes, Integral of course :)
11:47:46 <monochrom> well, there is your accusation
11:47:49 <Tehnix> so, from what i might have read, it's because of the currying kindda. Normally I would think: Integer, Integer, Integer -> Integer
11:48:19 <mk> monochrom: where is my accusation of what?
11:48:21 <Tehnix> (Coming from OOP and all the thought patterns it brings)
11:48:33 <typoclass> mk: i don't think you were trolling. i think there was a misunderstanding, and it took some minutes until folks really understood what you meant.
11:48:41 <nand`> it's entirely possible to write a function of type (Integer, Integer, Integer) -> Integer
11:48:49 <nand`> but that's isomorphic to Integer -> Integer -> Integer -> Integer
11:48:52 <monochrom> if anything, you misstate the cause
11:49:20 <nand`> (perhaps as an exercise you can write the conversions)
11:49:34 <monochrom> the cause is not that you don't understand answers. the cause is that you ask very misguided questions
11:49:36 <typoclass> Tehnix: yeah, you'd write that as (Integer, Integer, Integer) -> Integer, with parens. having one argument that is a 3-tuple is pretty much the same as having 3 separate arguments
11:49:55 <mk> typoclass: yep. Trolling isn't common, really
11:50:09 <Clint> speaking of triples
11:50:17 <Clint> is there a way to do \(x,y,z) -> (x,y) without pattern matching?
11:50:36 <nand`> (can mk's discussions be moved to #haskell-overflow or something? they have nothing to do with Haskell at this point)
11:50:48 <roconnor> Clint: not really
11:51:12 <nand`> Clint: depends on how pedantic you want to be; ultimately it all comes down to pattern matching
11:51:27 <mk> monochrom: how was my question misguided?
11:51:32 <nand`> but arguably you could write some horrible point-free version using intermixed const/flip/uncurry3 and stuff
11:51:39 <nand`> I doubt it'd be an improvement
11:51:41 <DT`> @pl \(x,y,z) -> (x,y)
11:51:41 <lambdabot> (line 1, column 6):
11:51:41 <lambdabot> unexpected ","
11:51:41 <lambdabot> expecting letter or digit, operator or ")"
11:51:41 <lambdabot> ambiguous use of a non associative operator
11:51:55 <DT`> what?
11:51:59 <nand`> hmm
11:52:08 <nand`>  @pl doesn't like some patterns
11:52:09 <DT`> @pl (1,2,3)
11:52:09 <lambdabot> (1, 2, 3)
11:52:19 <Clint> like >2-tuples
11:52:27 <DT`> oh, I see.
11:52:35 <nand`> since they ultimately compile down to case..of that can't be expressed point-free
11:52:40 <nand`> well, not compile down
11:52:42 <nand`> but translate down
11:52:58 <mk> nand`: I don't know, can comments like yours that imply that I'm trolling be moved there?
11:53:06 <nand`> it can only do stuff that it has built-in eliminators for like ‘fst’, ‘snd’, ‘maybe’
11:53:50 <spark_> typoclass: thanks! I was just curious
11:54:16 <nand`> @pl \f (x,y) -> (f x, f y)
11:54:16 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
11:54:32 <nand`> aw, was expecting &&&
11:55:19 <nand`> join (***) actually
12:00:11 <brisingr> I'm trying to explain why flip (f y x) won't work. To do that, I actually ran the expression. It gave an error, but it wasn't the one I expected. What's going on?
12:00:28 <latro`a> flip f y x is probably what you meant
12:00:36 <brisingr> I know
12:00:38 <brisingr> http://hpaste.org/73649
12:00:56 <brisingr> I was trying to explain the fact that parens won't work with flip
12:01:26 <brisingr> but it doesn't even evaluate the expression, it seems to only look at the type definitions
12:01:34 <geekosaur> parentheses don't work in haskell like they do with other languages
12:01:39 <brisingr> I know
12:01:51 <nand`> brisingr: drink 5 "male" type-checks assuming a Fractional String and Num String instance, and has type String
12:02:05 <nand`> so it tries checking ‘flip’ next but ‘flip (x :: String)’ fails because of hte type of flip
12:02:08 <nand`> :T flip
12:02:10 <typoclass> brisingr: flip (f y x) means that you evaluate "f y x" and give the result (one value) to flip. this fails because flip expects a function as its argument (not a String)
12:02:10 <nand`> :t flip
12:02:11 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
12:02:14 <latro`a> why do you need fractional
12:02:28 <nand`> latro`a: for 0.03, presumably
12:02:40 <brisingr> so it would be correct to say that before evaluating an expression, the interpreter looks at the type definitions
12:02:48 <latro`a> erm
12:02:51 <latro`a> you need Floating no?
12:02:52 <typoclass> brisingr: yes, it does
12:02:54 <nand`> no
12:03:03 <nand`> :t 0.03
12:03:04 <lambdabot> forall t. (Fractional t) => t
12:03:06 <latro`a> huh
12:03:08 <latro`a> interesting
12:03:12 <geekosaur> the first paramrter to flip is a function tthat takes two parameters.  you pass it an expression that produces String
12:03:15 <latro`a> > 0.03 :: Ratio
12:03:16 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
12:03:18 <latro`a> erm
12:03:20 <nand`> Floating is only for silly stuff like sin/cos
12:03:21 <latro`a> > 0.03 :: Rational
12:03:23 <lambdabot>   3 % 100
12:03:26 <latro`a> neat
12:03:58 <brisingr> huh. neat thing.
12:04:02 <brisingr> so I can do, like
12:04:11 <brisingr> > flip (undefined ++ undefined)
12:04:12 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> f b)
12:04:13 <lambdabot>    arising from a use of...
12:04:39 <mk> brisbin: what does plus (1 2) do in haskell?
12:04:46 <mk> brisingr: ^
12:04:58 <brisingr> it passes the result of (1 2) to plus
12:05:04 <brisingr> so it calles "1" with "2"
12:05:28 <brisingr> *calls
12:06:22 <nand`> “it passes the result of (1 2) to plus” <- I'm not sure which example this is supposed to relate to, I don't see (1 2) anywhere in your paste or recent log
12:06:24 <typoclass> brisingr: "flip (undefined ++ undefined)" <- not sure what you're trying to do there, but this is not the same as "flip (++) undefined undefined"
12:06:43 <brisingr> typoclass: yes, that's what I'm trying to illustrate
12:07:04 <brisingr> so I'm basically writing an explanation of why flip (f y x) won't work
12:07:10 <brisingr> I tried to give a concrete example
12:07:19 <paolino> http://hpaste.org/73650, is it possible ?
12:07:22 <nand`> note that flip (undefined ++ undefined) doesn't type-check if you use the prelude's ++
12:08:07 <brisingr> but I expected the error to be No instance for (Fractional [Char]) and No instance for (Num String)
12:08:31 <nand`> brisingr: instance resolution happens at a later step
12:08:43 <nand`> brisingr: it tries checking all of the applications and stuff first; and then goes on to pick appropriate instances
12:09:02 <typoclass> brisingr: it doesn't work because of the parens. "flip f y x" is the same as "(flip f) y x". if you put in the parens as in "flip (f y x)" that means something else, which makes the type checker complain (as it should)
12:09:43 <nand`> brisingr: note what happens when you try typechecking just drink 5 "male"
12:10:05 <Tehnix> Just a quick question, does Integral a => a imply that a is an Integral (and all the subsequent a's after that) ?
12:10:25 <brisingr> nand`: Interesting
12:10:33 <nand`> Tehnix: in a type like forall a. a -> a -> a all of the ‘a’s are the same
12:10:41 <nand`> so forall a. Num a => a -> a -> a  would apply to all
12:11:13 <brisingr> nand`: Do you know of a reference which elaborates the order in which these steps occur?
12:11:49 <nand`> brisingr: the Haskell Report should describe these semantics in full
12:11:58 <nand`> other than that I don't know of any
12:12:05 <typoclass> Tehnix: yup. all the 'a' in a signature refer to the same type. the bit on the left of a '=>' is called constraint. in your example, it requires that a must be a type for which an instance of typeclass Integral is present. hence, 'a' can't be a String for example
12:12:45 <paolino> brisingr, the space binds harder than everything and associate left
12:12:50 <typoclass> (er, forgot one pair of ', but you get it ... :) )
12:13:12 <Tehnix> typoclass: I've sometimes seen it declared as multiple types (ie (Eq a1, Integral a, Num a1) ), would that imply that a1 could belong to Num or Eq?
12:13:23 <latro`a> both
12:13:28 <latro`a> that is, it must belong to both
12:13:37 <Tehnix> Ah, not either, but both
12:13:37 <Tehnix> kk
12:13:38 <brisingr> nand`: thanks
12:14:16 <Tehnix> thanks for answering :) Slowly working my way through understanding how to declare my function I'm debugging
12:14:23 <latro`a> paste it?
12:14:30 <typoclass> Tehnix: you're welcome
12:14:33 <Tehnix> could do that ^^
12:15:10 * hackagebot fclabels 1.1.4.2 - First class accessor labels.  http://hackage.haskell.org/package/fclabels-1.1.4.2 (SebastiaanVisser)
12:16:10 <Tehnix> Okay, I'm working my way through project euler, for fun while solving the problems in Haskell (just to have something concrete to do in Haskell), paste is here : http://hpaste.org/73651
12:16:30 <Tehnix> My problem is that I don't know exactly how to declare the type of pTriplet
12:16:44 <Tehnix> (Should probably have included the ghci output)
12:16:58 <adnausea1> (,,) ?
12:17:36 <adnausea1> hmm, look at prelude's code, you can find tupel defs there and their functions so that might help
12:17:58 <typoclass> Tehnix: you can use "annotate" on your hpaste
12:18:28 <nand`> pTriplet 0 0 n = 1 1 n -- this is calling the ‘1’ function with arguments ‘1’, ‘n’; probably not what you want
12:18:49 <brisingr> Okay, thanks everyone, got it figured out. As nand` pointed out, the interpreter performs instance resolution _after_ checking that the types match.
12:18:52 <Tehnix> oh my god -.-
12:19:06 <Tehnix> sry, I'm stared myself completely blind in this
12:19:08 <Tehnix> heh
12:19:11 <Tehnix> I've *
12:20:33 <zhulikas> > let 1 = 2 in 1
12:20:34 <lambdabot>   1
12:20:36 <zhulikas> :(
12:20:41 <Tehnix> as they say, "You can't see the wood for the trees"
12:20:52 <nand`> I'm surprised ‘let 1 = 2’ parses
12:20:53 <Tehnix> Anyways, thanks again :)
12:21:19 <fmap> > let !1 = 2 in 1
12:21:20 <lambdabot>   *Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
12:21:28 <zhulikas> nice
12:21:54 <zhulikas> > 1 where !1 = 2
12:21:54 <nand`> come to think of it, it makes sense
12:21:55 <lambdabot>   <no location info>: parse error on input `where'
12:21:59 <nand`> > let !1 = 1 in 1
12:22:00 <lambdabot>   1
12:22:29 <zhulikas> @type let !1 = 1 in 1
12:22:30 <lambdabot> forall t. (Num t) => t
12:22:42 <zhulikas> @type let !1 = 1 in !1
12:22:43 <lambdabot> parse error on input `!'
12:23:35 <paolino> pattern matching is not assignment
12:24:42 <hpd> how would you parse (standard-)input, when you have only ghc(-boundled-libraries) and input specifications like "there is an integer on the first line and the other lines consist of an int, a char and a string separated by whitespace"? plain and ugly 'reads'?
12:25:17 <hpd> this is for a programming contest optimized for C++'s std::cin or C's scanf
12:25:51 <typoclass> hpd: yeah, why not use Prelude.read
12:26:00 <paolino> hpd there are scanf like functions, also
12:26:37 <nand`> depends on how quick and dirty vs. clean and elegant you want the solution to be
12:26:56 <nand`> if this is for production code I would probably use some proper stream parsing solution
12:27:27 <hpd> no, it's just for the contest
12:27:50 <nand`> but for cases where it doesn't matter much (eg. your code isn't public ;) you may as well just use something like read/unwords
12:27:55 <nand`> s/unwords/words/
12:28:47 <hpd> hmm, didn't think of words. thanks
12:29:37 <nand`> > case words "123 a string" of [n,[c],s] -> (read n, c, s)
12:29:38 <lambdabot>   (*Exception: Prelude.read: no parse
12:29:43 <nand`> ah
12:29:48 <nand`> > case words "123 a string" of [n,[c],s] -> (read n, c, s) :: (Int, Char, String)
12:29:49 <lambdabot>   (123,'a',"string")
12:30:10 * hackagebot cassava 0.1.0.1 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.1.0.1 (JohanTibell)
12:30:25 <hpd> nand`: yeah, quite nice
12:33:00 <byorgey> dolio, edwardk, sclv: (14:31) < monochrom> what do you mean?
12:33:12 <edwardk> ?
12:33:12 <byorgey> gah, not what I meant to paste
12:33:41 <nand`> byorgey: what do you mean?
12:33:47 <byorgey> it turns out it the X clipboard does not work across different machines =P
12:33:54 <byorgey> http://byorgey.wordpress.com/2012/08/24/unordered-tuples-and-type-algebra/
12:33:55 <byorgey> there
12:34:31 <shachaf> byorgey: Hooray!
12:34:45 <edwardk> byorgey: pretty pictures. =)
12:34:52 <byorgey> thanks =)
12:34:59 <byorgey> three guesses which library I used to make them
12:35:27 <shachaf> I talked about this subject with dolio a while ago, and a while later he said "I talked with byorgey about it and now it all makes sense".
12:35:31 * shachaf is paraphrasing.
12:35:34 <byorgey> hehe
12:36:00 * shachaf ought to read Concrete Mathematics.
12:36:01 <byorgey> well, I hope it will make sense to you too, after reading my blog post
12:36:08 <shachaf> I've read bits of it.
12:36:17 <shachaf> I think it made sense to me after talking with dolio about it in #-blah.
12:36:24 <byorgey> ok.
12:36:29 <byorgey> yes, CM is wonderful
12:36:53 * shachaf will look at this post. byorgey++
12:37:31 <edwardk> byorgey: i like it a lot
12:37:40 <byorgey> edwardk: thanks =)
12:40:23 <typoclass> byorgey: by the way, i've had good experience with http://synergy-foss.org/ for sharing the mouse and keyboard, but it also shares the clipboard :)
12:40:49 <byorgey> typoclass: neat!
12:41:22 <typoclass> yeah it really is
12:41:59 * byorgey downloads
12:54:17 <raaaamin> hii :D
12:55:21 <ion> Hah. The Synergy site displays a horribly translated Finnish version to me.
12:55:45 <raaaamin> any body is here ?
12:55:49 <ion> Looks like a broken machine translation.
12:56:14 <raaaamin> where are you from ?
12:56:23 <Clint> this is going to turn out well
12:56:34 <carter> byorgey: am I the only one who's been hitting type system bugs with 7.6RC?
12:56:57 <carter> (if you know anything one way or another)
12:57:03 <byorgey> carter: no idea
12:57:21 <byorgey> hi raaaamin, are you here to discuss the programming language Haskell?
12:57:27 <carter> byorgey: all I know is that typelit nats aren't ready for prime time :(
12:57:40 <carter> I was really excited about what might be possible
12:58:15 <carter> but i think it needs another release cycle of love
12:58:50 <Automorphism> Is haskell-mode for Emacs on hackage (just like agda-mode)?
12:58:51 <byorgey> carter: not surprising, really
12:58:57 <carter> byorgey: true
12:59:07 <carter> but you may notice I approach technology with optimize :)
12:59:10 <byorgey> carter: in fact I'm not even sure that type nats are supposed to be an advertised/supported feature yet
12:59:17 <carter> ok
12:59:20 <carter> fairrrrr
12:59:31 <byorgey> carter: but that's why they put them in, so people like you can hammer on them and uncover all the bugs =)
12:59:57 <byorgey> same thing happened with type promotion and kind polymorphism in 7.4
13:00:22 <carter> byorgey: one issue is theres not really a "resolve this type variable to a concrete value/type " for the variables in a constraint
13:00:28 <carter> eg   1+d ~ 2
13:00:48 <carter> theres no way to express "d has but a single value"
13:00:53 <carter> or at least the current solver knows not this
13:01:06 <carter> even with functional dependencies
13:01:38 * byorgey knows nothing
13:01:55 * carter knows less than byorgey 
13:02:00 <carter> hehe
13:02:30 <colock> induction!
13:02:40 <carter> either way, if things go well for me this fall, I really want to beable to throw 1+ full time units of manpower on ghc love
13:02:59 <carter> granted, it'll be for my own nefarious ends
13:03:01 <carter> but
13:03:14 <carter> those nefarious ends will be handy for other folks too
13:05:34 <carter> byorgey: are there really no heavy haskell users who'd want to help cheer lead the ghc-simd work along aside from me?
13:13:24 * monochrom abuses his op privilege!
13:13:35 --- mode: ChanServ set +o monochrom
13:13:38 --- topic: set to '["what do you mean?","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
13:13:45 <monochrom> hehe
13:13:51 --- topic: set to '["Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.2: http://is.gd/EllZnn ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by monochrom
13:13:57 --- mode: monochrom set -o monochrom
13:15:10 <shachaf> monochrom: what do you mean?
13:15:11 * hackagebot cpsa 2.2.11 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.11 (JohnRamsdell)
13:15:13 * hackagebot largeword 1.0.3 - Provides Word128, Word192 and Word256 and a way of producing other large words if required.  http://hackage.haskell.org/package/largeword-1.0.3 (DominicSteinitz)
13:15:33 <monochrom> what do you meme?
13:19:47 <squidz> im trying to build a list from funciton(String -> IO String) over alist of parameters passed to that function. So ideally for each different parameter passed to the function I get a different IO String which i then want to append to a list [String]. Is there an easy way to do this?
13:20:22 <startling> squidz: mapM
13:20:23 <squidz> if you need the code, i am referring to line 41 http://hpaste.org/73656
13:20:25 <startling> :t mapM
13:20:27 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:21:15 <startling> oh, you're using mapM? what's wrong with it?
13:21:31 <squidz> startling: if you take a look at the code i have, I used mapM but get an error: expected IO b0, actual typt [a0]
13:21:48 <squidz> its in line 41 of the paste
13:21:56 <startling> squidz: k. something else is going on
13:21:58 <latro`a> squidz: this is the same problem as you had yesterday
13:22:11 <latro`a> or related
13:22:21 <latro`a> you have a do block in IO, and then you try to bind it to a list
13:22:26 <latro`a> and you're not allowed to do that
13:22:59 <squidz> latro`a: im not sure if it is the same as yesterday
13:23:04 <latro`a> it's similar
13:23:11 <latro`a> :t mapM
13:23:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
13:23:40 <latro`a> yeah, note that :resultList is a -> [b]
13:23:49 <latro`a> also, :[] is return in []
13:23:53 <latro`a> which is clearer
13:23:59 <latro`a> or do you want to build *one* list
13:24:07 <squidz> i would like to build one list
13:24:14 <latro`a> oh, now I see what you're doing wrong
13:24:35 <latro`a> you need to get the string out of "getSynonyms $ lines links"
13:24:36 <latro`a> so
13:24:38 <squidz> latro`a: it's different than yesterday right
13:24:42 <latro`a> syns <- getSynonyms $ lines links
13:25:00 <latro`a> now syns :: String (handwaving a little, but you get the point)
13:25:23 <latro`a> not sure what you want to do after that
13:25:28 <Twisol> I'm trying to build a parser, and GHC is complaining about constructing infinite types. I can see the problem, but I don't know what I should be doing instead… http://hpaste.org/73657
13:25:37 <latro`a> oh, oh no
13:25:37 <squidz> latro`a: i will unlines the list and write to file
13:25:44 <latro`a> you tried to change resultList
13:25:52 <latro`a> you can't do that even in IO, without IORefs or similar
13:25:59 <latro`a> I think you just want
13:26:11 <latro`a> getSynonyms (lines links) >>= writeFile "synonyms.txt"
13:26:18 <latro`a> or the analogous line in do notation
13:26:23 <latro`a> *lines
13:26:31 <latro`a> wait
13:26:34 <latro`a> unlines?
13:26:41 <latro`a> getSynonyms gives you a String
13:27:05 <squidz> getSynonyms returns IO String
13:27:12 <latro`a> yeah, which means there's no need to unlines
13:27:30 <squidz> latro`a: well yes because i will call getSynonyms many times
13:27:35 <latro`a> huh?
13:27:40 <latro`a> what are you mapping over
13:27:41 <squidz> and put each result as an element in a list
13:27:52 <latro`a> oh oh
13:27:57 <squidz> do you see it?
13:27:58 <latro`a> then don't think of it as putting
13:28:06 <rosie> When pattern matching against a string to read a single integer, why do I need the parenthesis in the pattern, [(x, "")] ?
13:28:17 <haqe17> Hello. Im a haskell newb. Im trying to define a for loop in Haskell, as part of an exercise in the wiki. This is what I have but I dont know how to finish it. http://hpaste.org/73658
13:28:23 <startling> Twisol: mind pasting the error, too?
13:28:25 <latro`a> I think you're thinking of sequence rather than mapM
13:28:27 <latro`a> :t sequence
13:28:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:28:41 <latro`a> or maybe not
13:28:44 <latro`a> ahh
13:28:51 <latro`a> mapM getSynonyms $ lines links
13:29:39 <latro`a> then syns <- mapM getSynonyms $ lines links; writeFile "synonyms.txt" (unlines syns)
13:30:07 <sheldonh> is intellij IDEA's haskell plugin worth a damn? i'm a vim-not-emacs guy, and this whole edit-in-vim-and-load-in-ghci thing is a drag
13:30:16 <latro`a> or mapM getSynonyms (lines links) >>= writeFile "synonyms.txt" . unlines
13:30:25 <spark_> ham, is bitwise operation & disponible for ints or I have to use another type?
13:30:41 <latro`a> squidz: do you follow?
13:30:50 <squidz> latro`a: just a sec let me take a look
13:30:52 <Twisol> startling: http://hpaste.org/73661
13:31:04 <startling> sheldonh, as a former vim guy, emacs is wonderful for haskell
13:31:37 <sheldonh> startling: no doubt. it's just... how much do you really wanna learn at once? :)
13:32:12 <squidz> latro`a: i will try it out and let you know if it works. It compiles fine, but not sure if it will produce the desired results. The computation takes a bit, so I will tell you once I see if it works
13:32:12 <mm_freak_> is higgsset the only alternative to IxSet?  i'm trying to find an alternative that both compiles and gets along without Typeable
13:32:27 <zachk> startling: is there a good haskell/emacs combined tutorial ?
13:32:30 <startling> sheldonh: yeah, understood
13:32:36 <mm_freak_> higgsset unfortunately doesn't compile with GHC 7.4
13:33:39 <zachk> or just emacs for haskellers tutorial?
13:33:40 <startling> zachk: I used c-h t to learn emacs and http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs to learn haskell-mode
13:33:52 <startling> zachk: dunno of a combined tutorial. wish there was one
13:33:56 <rosie> When pattern matching against a string to read a single integer, why do I need the parenthesis in the pattern, [(x, "")] ?
13:34:12 <zachk> everytime I try to learn emacs: 1) I get overwhelmed 2) try to do to much 3) quit because it doesnt work how I think should work
13:34:17 <latro`a> rosie--reads is silly
13:34:34 <latro`a> rosie--it was originally meant to be flexible enough to show multiple parses, but no implementation actually does this
13:34:42 <zachk> rosie how are you getting the integer that is suppsoed to be a string?
13:34:45 <latro`a> (to my knowledge; at the very least GHC definitely doesn't)
13:34:56 <startling> zachk: yeah. emacs is hard
13:35:06 <latro`a> zachk--I think rosie has a string like "123" and is calling reads on it
13:35:29 <ion> latro: Nothing prevents you from making ReadS values that return multiple choices.
13:35:42 <zachk> rosie: try calling read::Integer on it
13:35:53 <latro`a> ion--ah
13:36:00 <zachk> unless you really needs to use reads
13:36:09 <ion> read is evil.
13:36:13 <latro`a> read is terrible, yeah
13:36:16 <latro`a> global crashes when it fails
13:36:26 <squidz> latro`a: actually sorry it doesnt compile after all
13:36:29 <latro`a> unless you want to catch it in IO, which is also pretty terrible
13:36:43 <zachk> latro`a: why is catching bad?
13:36:59 <ion> > let f str = listToMaybe [ x | (x,"") <- reads str ] in f "123" :: Maybe Integer
13:37:00 <lambdabot>   Just 123
13:37:00 <latro`a> it puts way more IO in the program than necessary, and is too general to easily reason about
13:37:04 <latro`a> and is often slow
13:37:09 <ion> latro: In IO you’d use readIO.
13:37:18 <latro`a> :t readIO
13:37:19 <lambdabot> forall a. (Read a) => String -> IO a
13:37:27 <latro`a> huh
13:37:27 <latro`a> k
13:37:54 <ion> It makes sure any exceptions happen during the execution of the action,
13:38:14 <timthelion> The readIO function is similar to read except that it signals parse failure to the IO monad instead of terminating the program.
13:38:20 <timthelion> <-- from haddock
13:38:29 <Twisol> startling: any suggestions for that parser paste?
13:38:35 <startling> Twisol: no idea, sorry
13:38:40 <Twisol> no worries
13:38:43 <startling> why isn't read just "Read a => String -> Maybe a"?
13:38:51 <latro`a> multiple parses
13:38:56 <ion> See “f” above.
13:39:00 <latro`a> which isn't actually how read alone is defined
13:39:07 <latro`a> but readS values can do it
13:39:15 <typoclass> startling: good question. it probably should be.
13:39:30 <startling> for that matter, why isn't div "div :: Integral a => a -> a -> Maybe a"?
13:39:41 <ion> rosie also: see “f” above.
13:39:43 <startling> hysterical reasons?
13:39:45 <timthelion> startling: everyone complains about it, then they learn to live with it.
13:39:55 <startling> timthelion: heh
13:40:30 <startling> just seems like the canonical example of a failable computation
13:40:43 <timthelion> startling: the thing is, that it takes the same amound of effort to type case n of 0 -> don't do div n -> div. then it does to do case y div n of Just result -> Nothing ->
13:41:05 <startling> timthelion: yeah, but you can't use >>= and <$> on 0
13:41:36 <timthelion> startling: prelude was written before the Walnder(is that the correct name) paper on Monads.  So people didn't know that yet :D
13:41:47 <startling> :/
13:42:03 <timthelion> Maybe in haskell 2014...
13:42:07 <startling> hehe
13:42:51 * timthelion would vote for it in the next version of the standard :D
13:43:39 <mm_freak_> i have found a slight syntax inconsistency
13:43:41 <mizu_no_oto> timthelion:  Wadler, you mean?
13:43:46 <mm_freak_> > (`mod`) 4 3
13:43:47 <lambdabot>   <no location info>: parse error on input `)'
13:43:47 <timthelion> startling: and you can also do maybeDiv x y = case y of 0 -> Nothing ; Just _ -> x `div` y
13:43:59 <timthelion> mizu_no_oto: yes, yes, sorry.
13:44:13 <startling> mm_freak_: yeah, I've noticed that too. it's odd
13:44:32 <startling> > let (#) = mod in (#) 4 3
13:44:33 <lambdabot>   <no location info>: parse error on input `)'
13:44:33 <timthelion> mm_freak_: oooh, definitely report that.  The devs will love that one.  If for nothing else, but to laugh.
13:44:42 <startling> > let (#) = mod in ((#) 4 3)
13:44:43 <lambdabot>   <no location info>: parse error on input `)'
13:45:10 * timthelion reported his seccond ever legit GHC bug today.  
13:45:42 <latro`a> squidz--what's the error?
13:45:55 <latro`a> also did you see my hpaste?
13:45:55 <timthelion> mm_freak_: are you going to file a bug report, or should I?
13:46:31 <mm_freak_> timthelion: you may, if you feel like it =)
13:46:38 * timthelion leaves
13:46:44 <haqe17> can anyone help me define a for loop in haskell
13:47:03 <latro`a> forM is the closest thing you're going to get
13:47:06 <latro`a> if you're not actually trolling
13:47:07 <jamiltron> haqe17: Are you sure that's what you want?
13:47:15 <mizu_no_oto> haqe17: what are you trying to do?
13:47:43 <haqe17> im trying to do an exercise in the wiki tutorial. that is, define the function   "for :: a -> (a->Bool) -> (a->a) -> (a-> IO ()) -> IO ()"
13:48:18 <spark_> ha
13:48:23 <squidz> latro`a: cant see your hpaste, and of course im not trolling
13:48:29 <timthelion> the wiki is trolling !!!!
13:48:43 <haqe17> I have this but it doesnt work  "for i p f job = if (p i) then (for (f i) p f job )  else return ()"
13:49:15 <squidz> latro`a: exptected type: char, actual type: String
13:49:26 <latro`a> squidz: the trollling thing was to haqe17
13:49:34 <squidz> latro`a: ah sorry
13:49:47 <timthelion> latro`a: who is also not trolling apparently
13:49:53 <latro`a> http://hpaste.org/73656
13:49:54 <latro`a> yup
13:49:57 <latro`a> my apologies
13:49:58 <timthelion> haqe17: which error?
13:50:15 <latro`a> not sure what that function is supposed to do, though
13:50:21 <haqe17> timthelion: no error, just doesnt seem to do anything when i run it
13:50:40 <spark_> because you dont execute job, i believe
13:50:40 <latro`a> f x p g h = if p x then h (g x) else h x
13:50:40 <latro`a> ?
13:50:44 <latro`a> or...what
13:50:47 <timthelion> haqe17: what did you run it with?  Sorry, moment. give me 15 secconds and I'll tell you what's wrong.
13:51:32 <roconnor> @type (<**>)
13:51:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
13:51:50 <mizu_no_oto> for i p f job = if (p i) then job i >> (for (f i) p f job ) else return ()
13:52:16 <spark_> shouldnt it be ' then do{job; return (for (f i ) p f job)} ?
13:52:17 <latro`a> squidz: did you see link?
13:52:25 <latro`a> because that should typecheck at least
13:52:45 <timthelion> :t for i p f job = if (p i) then (for (f i) p f job ) else return ()
13:52:46 <lambdabot> parse error on input `='
13:53:03 <spark_> :t let for i p f job = if (p i) then (for (f i) p f job ) else return ()
13:53:04 <lambdabot> <no location info>:
13:53:05 <lambdabot>     not an expression: `let for i p f job = if (p i) then (for (f i) p f job ) else return ()'
13:53:19 <timthelion> :t let for i p f job = if (p i) then (for (f i) p f job ) else return () in for
13:53:20 <lambdabot> forall t t1 (m :: * -> *). (Monad m) => t -> (t -> Bool) -> (t -> t) -> t1 -> m ()
13:53:41 <squidz> latro`a: yeah i got the link now,  but for some reason it still doesnt compile. I still get the same error, exptected Char got String
13:53:42 <spark_> why it likes your let but not my let
13:53:49 <mizu_no_oto> His problem is that he never runs the job
13:53:50 <timthelion> spark_: you need an in for at the end.
13:53:53 <haqe17> timthelion: I ran it with a function that should print out a list of Ints, but nothing got printed
13:54:04 <ocharles> hi, spending my evening with data kinds and poly kinds. I know that (:) is a -> [a] -> [a], by doing :t (:). How do I do the equivilent at kind level, with the promoted ':?
13:54:07 <timthelion> haqe17: what did you run it with?
13:54:07 <ocharles> (in ghci)
13:54:10 <mk> is there any monad besides trivial for which an inverse to return can't be constructed? that is, a function f such that (f (return x))=x?
13:54:11 <spark_> timemage: aaahh i se
13:54:32 <spark_> timthelion: his code tipechecks, but he never runs job, so it doesn't do anything
13:54:38 <mizu_no_oto> let for i p f job = if (p i) then job i >> (for (f i) p f job ) else return ()
13:54:44 <latro`a> at what line, squidz?
13:54:51 <mizu_no_oto> Notice  job i >> (for (f i) p f job )
13:55:04 <latro`a> mk--uh
13:55:05 <latro`a> most
13:55:07 <latro`a> can't
13:55:09 <spark_> D:
13:55:14 <latro`a> [], Maybe, IO (...mostly)
13:55:15 <latro`a> etc.
13:55:34 <Eduard_Munteanu> mk: in Haskell, or generally?
13:55:43 <latro`a> some do live in Hask (Reader/Writer), but most comonads live in different categories than the corresponding monads
13:55:50 <latro`a> *for example Reader/Writer
13:55:56 <squidz> latro`a: line 41
13:56:06 <squidz> latro`a: sorry i mean 51
13:56:13 <latro`a> 51?
13:56:15 <mizu_no_oto> >> runs job i, and then runs the result of for (f i) p f job
13:56:18 <latro`a> there is no 51 here
13:56:20 <mk> latro`a: I know that many are one-way, but in principle values from Just x can be extracted (they're extracted by bind during mapping)
13:56:22 <squidz> latro`a: wait no hold on
13:56:35 <haqe17> timthelion:  for 5 (> 1) ((-)1) (\n -> putStrLn(show n))
13:56:37 <latro`a> mk--you can't invert return without a partial function
13:56:40 <latro`a> in Mabye
13:56:41 <latro`a> *Maybe
13:56:45 <squidz> latro`a: line 40
13:56:47 <mk> Eduard_Munteanu: both, I suppose?
13:56:48 <Eduard_Munteanu> mk: but it's partial for Nothing
13:56:57 <latro`a> ahh, my bad
13:57:12 <spark_> haqe17: have you seen the code from mizu_no_oto  ?
13:57:22 <Eduard_Munteanu> Generally that needn't hold at all.
13:57:24 <timthelion> > let for i p f job = if (p i) then job >> (for (f i) p f job ) else return () in for 0 (\i -> i == 10) (+1) print
13:57:25 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> ())
13:57:25 <lambdabot>    arising from a use of ...
13:57:26 <mk> latro`a: (nick-- does not trigger like nick: does)
13:57:30 <timthelion> hmm
13:57:39 <timthelion> that gives me an error, not sure why.
13:58:01 <mk> Eduard_Munteanu: not sure I follow
13:58:18 <ion> preflex: karma mk
13:58:18 <preflex>  mk has no karma
13:58:24 <ion> preflex: karma nick
13:58:24 <preflex>  nick: 4
13:58:56 <timthelion> haqe17: you need to run job like I showed.  but my code currently is also not working, working on that ;)
13:59:04 <haqe17> spark_: yeah im looking at it right now
13:59:16 <latro`a> squidz -- which does it think needs to be Char?
13:59:26 <mizu_no_oto> haqe17: it works, try it
13:59:58 <squidz>     Couldn't match expected type `Char' with actual type `String'
13:59:59 <squidz>     Expected type: String
13:59:59 <squidz>       Actual type: [String]
13:59:59 <squidz>     In the return type of a call of `lines'
13:59:59 <squidz>     In the second argument of `($)', namely `(lines links)'
14:00:01 <squidz> Failed, modules loaded: none.
14:00:33 <mk> Eduard_Munteanu: what is partial for nothing?
14:00:43 <latro`a> that's weird...
14:01:02 <squidz> yeah, also dont know why its not compiling. hpaste doesnt complain
14:01:03 <haqe17> mizu_no_oto: can you post it again sorry,. I just tried this one "for i p f job = if (p i) then job i >> (for (f i) p f job ) else return ()" but it doesnt work
14:01:08 <mizu_no_oto> It builds up a value of type IO () recursively: job i >> job (f i) >> job (f $ f i) >> ... >> return ()
14:01:12 <latro`a> mapM :: (a->m b) -> [a] -> m [b]; mapM getSynonyms :: [String] -> IO [String]
14:01:15 <Eduard_Munteanu> mk: you can't have a total function  Maybe a -> a
14:01:25 <Eduard_Munteanu> > fromJust Nothing
14:01:27 <lambdabot>   *Exception: Maybe.fromJust: Nothing
14:01:29 <latro`a> so syns should be String, no?
14:01:31 <Eduard_Munteanu> :t fromJust
14:01:33 <lambdabot> forall a. Maybe a -> a
14:02:04 <latro`a> eh
14:02:05 <latro`a> pm
14:02:08 <mk> Eduard_Munteanu: isn't that alright, since return never returns Nothing?
14:02:43 <mizu_no_oto> > let for i p f job = if (p i) then job i >> (for (f i) p f job ) else return ()
14:02:44 <lambdabot>   not an expression: `let for i p f job = if (p i) then job i >> (for (f i) p...
14:03:28 <timthelion> haqe17:
14:03:31 <timthelion> haqe17: > let for ::Show a => a -> (a -> Bool) -> (a->a) -> (a-> IO ()) -> IO () ;for i p f job = if (p i) then (job i) >> (for (f i) p f job) else return () in for 0 (\i -> not $ i == 10) (+1) print
14:03:47 <timthelion> mizu_no_oto: hehe, we come up wit hthe same solution :D
14:04:03 <mizu_no_oto> how do I define a function in lambdabot?
14:04:12 <timthelion> mizu_no_oto: let
14:04:25 <timthelion> > let foo = "hi mizu_no_oto " in foo
14:04:26 <lambdabot>   "hi mizu_no_oto "
14:04:26 <mk> Eduard_Munteanu: I'm asking about "a function f such that (f (return x))=x"
14:05:05 <mizu_no_oto> > let for i p f job = if (p i) then job i >> (for (f i) p f job ) else return () in for 1 (< 5) (+ 1) print
14:05:06 <lambdabot>   <IO ()>
14:05:07 <Eduard_Munteanu> mk: hm, I guess so
14:05:39 <Eduard_Munteanu> mk: but consider f's type
14:05:40 <mk> it looks like the only monad for which such a function is impossible is Trivial. Am I right?
14:05:49 <timthelion> mizu_no_oto: for obvious reasons IO is strictly forbidden.
14:06:06 <mizu_no_oto> haqe17: What problems are you having with trying to get it to work?
14:06:13 <mm_freak_> paolino: ?
14:06:14 <mizu_no_oto> makes sense
14:06:59 * timthelion is so dependent on type deffinitions that he didn't understand haqe17's simple ass code till he wrote one.
14:07:03 <haqe17> mizu_no_oto: timthelion . sorry, i think there wasnt calling the function properly with "for 5 (< 1) ((-)1) (\n -> putStrLn(show n))"
14:07:03 * timthelion thus feels stupid.
14:07:04 <Eduard_Munteanu> mk: how about   data NotQuiteTrivial a = One | Two?
14:07:25 <haqe17> mizu_no_oto: it works using the call timthelion posted
14:07:32 <mk> Eduard_Munteanu: not a monad! :)
14:07:43 <Eduard_Munteanu> Why not?
14:07:57 <mk> it fails one of the first two laws...
14:08:14 <aoeu> is it true that haskell is useless? http://www.youtube.com/watch?v=iSmkqocn0oQ
14:08:16 <mk> the first one, I think
14:08:42 <startling> aoeu: yep
14:09:09 <mk> return a >>= f  =  f a
14:10:07 <mk> the idea is that if return, say, returns One, what is bind going to feed into f?
14:10:26 <haqe17> mizu_no_oto: nvmind. im an idiot
14:10:33 <aoeu> startling: Why do people use it then?
14:10:51 <timthelion> aoeu: like harowin.  Gives you this kind of flowtin feelin
14:11:03 <startling> aoeu: reverse-trolling
14:11:19 <startling> aoeu: we get lots of trolls here. joke's on them!
14:11:53 <timthelion> Cale is no longer a hidden python method.
14:11:55 <mizu_no_oto> haqe17: do you see how the code works?
14:12:02 <aoeu> startling: But they say it's useless, and they seem right.
14:12:17 <Cale> mk: I can think of another
14:12:33 <mk> Cale: oh?
14:12:35 <startling> timthelion: wrong side
14:12:57 <timthelion> startling: really?  Should I be proud of my utter lack of python knowlege?
14:13:00 <Cale> mk: Consider  newtype Query a = Q { runQuery :: (a -> Bool) -> Bool }
14:13:15 <haqe17> mizu_no_oto: not quite; i havent got to the >> operator yet.
14:13:16 <Cale> return v = Q (\q -> q v)
14:13:47 <mizu_no_oto> >> :: m b -> m a -> m a
14:13:56 <loreints> sorry to bother people again, but I'm having a lot of trouble trying to get an instance of Show to work. I think it's because my data is stuck in a newtype and I don't really know how to extract it; I've been trying everyting but I can't seem to get anywhere. Could someone perhaps help me? The problem is on line 10 and the source is http://hpaste.org/73655 and the error is http://hpaste.org/
14:14:08 <loreints> sorry: http://hpaste.org/73671
14:14:11 <timthelion> startling: is it not supposed to be on BOTH sides actually, now that I look at the docs?
14:14:20 <haqe17> mizu_no_oto: can this code be written with "do"
14:14:21 <startling> timthelion: nope, those are magic methods
14:14:22 <mizu_no_oto> haqe17: it "runs" the first argument, and then returns the second
14:14:27 <Cale> x >>= f = Q (\q -> runQuery x (\v -> runQuery (f v) q))
14:14:50 <startling> timthelion: __method gets name-mangled, _method is private by convention, __method__ is a magic method like __len__ or __iter__
14:14:58 <mizu_no_oto> haqe17: do { job i ; for ... }
14:15:20 <mizu_no_oto> Where { and ; are usually replaced with whitespace
14:15:32 <Cale> mk: This is a monad (it's the same as Cont Bool)
14:15:46 <haqe17> ok
14:15:58 <timthelion> startling: Weird and ugly... :)
14:16:25 <startling> timthelion: oh yeah, definitely
14:16:26 <mk> Cale: why isn't v accessible?
14:16:35 <startling> timthelion: I liked python until I learned haskell. :/
14:16:42 <Cale> mk: Try writing a function  ((a -> Bool) -> Bool) -> a
14:16:52 <haqe17> thanks squidz timthelion mizu_no_oto
14:17:07 * timthelion doesn't dislike python, but has read far to much python code written by non programmers.
14:17:07 <Cale> mk: You can only ask yes or no questions about v
14:18:33 <mk> Cale: v is in a closure?
14:18:47 <Cale> If you want to examine the runtime implementation, I guess.
14:18:48 <rosie> How do I pronounce <=< ?
14:19:07 <Cale> rosie: That is Kleisli composition.
14:19:14 <rosie> Cale: Thanks!
14:19:32 <startling> rosie: less-than-or-equal-to-or-less-than
14:19:38 <Cale> lol
14:19:41 <typoclass> isn't >=> pronounced fish? <=< could be reverse fish or something
14:19:52 <typoclass> unfish!
14:19:54 <edwardk> ><> is clearly the fish operator
14:20:05 <edwardk> <>< would be unfish
14:20:06 <edwardk> ;)
14:20:13 <Saizan> loreints: something of type Parse PcapRaw like (parsePcap pcapFile) doesn't contain a PcapRaw, it's something that when given a ParseState can try to parse a PcapRaw from it
14:20:17 <Cale> co-fish!
14:20:28 <startling> @hoogle (><>)
14:20:29 <lambdabot> No results found
14:20:29 <edwardk> its closely related to the <<>~ rat operator in lens
14:20:37 <Saizan> loreints: so, that's your problem
14:20:38 <mm_freak_> edwardk: no, that's cofish
14:20:49 <startling> ~~(___)^o>
14:20:50 <mm_freak_> ~><> is unfish
14:21:01 <edwardk> ah, my mistake
14:21:11 <typoclass> edwardk: i admit that your thingy looks much more fishy than mine :) but i distinctly remember someone in here used the term fish operator for something that had a '=' in it
14:21:12 <Saizan> loreints: you should first write a function Parser a -> L.ByteString -> Either String a
14:21:22 <Automorphism> Good Lord, do those actually exist (besides >=> and <=<, of course)?
14:21:31 <Saizan> loreints: you'd want to implement that using runParser
14:21:43 <Saizan> loreints: *runParse
14:22:13 <mm_freak_> Automorphism: you can make any operator exist that you want
14:22:27 <Clint> almost
14:22:37 <loreints> Saizan: thank you!
14:22:43 <mk> Cale: it's not entirely clear but I think I get the idea. It's not possible to detect which value resides in the closure by testing all possible finite (infinite?) values?
14:23:09 <Cale> mk: For specific types 'a' it will be possible to recover the value by asking enough questions.
14:23:33 <Cale> mk: But it's impossible to do it polymorphically
14:23:39 <mm_freak_> Automorphism: any syntactically valid operator that is
14:23:45 <n00b6502> jesuss... ascii art operators
14:24:43 <Saizan> loreints: also, the first argument of parsePcap is unused, so you should probably remove it
14:25:05 <mk> Cale: I see. Thanks for the example
14:25:16 <Cale> mk: For example, it's obviously easy to do when a = Bool, because runQuery (return v) id = v
14:25:28 <popl> （*＾＾）/~~~~~~<;>< # is there a fish catching operator?
14:27:15 <johnw> I just discovered BlogLiterally
14:27:15 <johnw> wow
14:27:23 <startling> >(^.^)># -- the waffle-eating operator
14:27:32 <Automorphism> :-O
14:27:36 <Cale> mk: One reason why I'd usually shy away from talking about closures here, even if it's actually implemented that way, is that if we actually had access to the supposed closure, we'd easily be able to recover v
14:27:53 <startling> let (>(^.^)>#) = (+) in (1 >(^.^)># 2)
14:28:02 <startling> > let (>(^.^)>#) = (+) in (1 >(^.^)># 2)
14:28:03 <lambdabot>   <no location info>: parse error on input `)'
14:28:05 <Cale> Whereas the interface that we actually are presented to the data is just that of a function, rather than the closure implementing that function.
14:28:12 <startling> what am I doing wrong?
14:28:18 <popl> mmm waffles
14:28:22 <Automorphism> startling: The inner parentheses?
14:28:27 <startling> oh, right
14:28:29 <popl> startling: I literally have not eaten a waffle in years.
14:28:33 <popl> :(
14:28:36 <startling> popl: poor guy
14:28:40 <startling> popl: go to a waffle house
14:28:50 <popl> There are none in my area.
14:29:06 <startling> where do you live? midwest? west coast?
14:29:41 <mk> Cale: yeah, I see that and agree. Is there any other way to implement it, though?
14:29:43 <popl> the latter
14:29:46 <popl> er
14:30:13 * hackagebot MissingPy 0.10.6 - Haskell interface to Python  http://hackage.haskell.org/package/MissingPy-0.10.6 (MattBrown)
14:31:42 <badkins> I was looking at a solution to Paul Graham's challenge to write an "accumulator generator". I was able to placate the compiler by using import Data.IORef instead of import IOExts, but now I have no idea how to invoke the function. The idea is that each time you invoke the function, it increments the internal state by the argument.
14:31:44 <badkins> http://pastie.org/4582766
14:32:21 <shachaf> badkins: The Haskell solution to that challenge would probably involve expressing it in a different way, rather than using an IORef.
14:32:31 <badkins> I haven't done much with monads in Haskell yet. I can "let foo = accgen 7", but how do I call foo ?
14:32:39 <shachaf> WIth that said, that solution looks reasonable.
14:32:46 <badkins> shachaf: I'm open to other ideas.
14:32:49 <shachaf> Just "foo 5", presumably.
14:32:55 <badkins> :) nope
14:33:00 <shachaf> ?
14:33:07 <shachaf> Oh, right.
14:33:08 <badkins> foo 5 is what I guessed first
14:33:09 <shachaf> foo <- accgen 7
14:33:32 <shachaf> It would help you to write out the type of accgen. :-)
14:33:34 <badkins> huh?  If I do foo = accgen 7  I get the function
14:33:40 <shachaf> No you don't.
14:34:04 <badkins> cool - you're right! thx
14:34:15 <badkins> foo <- accgen 7
14:34:16 <badkins> foo 8
14:34:37 <shachaf> accgen :: Integer -> IO (Integer -> IO Integer)
14:34:46 <shachaf> badkins: What I mean is that the Haskell solution would involve not having hidden state like that in the first place.
14:34:55 <loreints> Saizan: why wouldn't I want to create a function with a type of  Parse a -> Either String a since the bytestring is within the parse type and I don't have an instance of Parser (I think)?
14:35:08 <badkins> shachaf: that doesn't make sense since the goal is to write a function with hidden state :)
14:35:20 <badkins> i.e. micro benchmark of language feature
14:35:24 <shachaf> badkins: I'm saying that you wouldn't have that goal in the first place.
14:35:35 <shachaf> Right -- like most microbenchmarks, this one isn't very useful. :-)
14:35:41 <badkins> it is useful
14:35:53 <Saizan> loreints: Parse a doesn't contain a bytestring, it asks for one
14:36:08 <badkins> Arc can do some nice functional stuff, so it's interesting to see how Haskell might do some imperative stuff even if you wouldn't normally lean that way
14:36:16 <badkins> but I get your point
14:36:24 <shachaf> badkins: Even for "imperative stuff" you wouldn't necessarily use IO.
14:36:35 <shachaf> I mean, Haskell is fine with "imperative stuff" and using IO everywhere.
14:37:07 <shachaf> But you have other ways of modeling problems also.
14:37:17 <badkins> shachaf: how would you solve this problem?
14:37:17 <startling> @pl \ks k a -> mappend $ construct ks k a
14:37:17 <lambdabot> ((mappend .) .) . construct
14:37:20 <shachaf> For example the monad "State Integer" might be one way.
14:37:51 <Automorphism> Or, more likely, ST. :-P
14:37:52 <shachaf> What I'm saying is that this isn't an actual problem in the first place. That's the issue with most microbenchmarks.
14:38:08 <bobajett> howdy folks, how do I write a function to give me the nestedness of a list? so  ghci> findDepth ["hello"] #=> 1  ghci> findDepth [["hello"]] #=> 2
14:38:13 <shachaf> Automorphism: Not really -- ST is a completely different thing.
14:38:34 <shachaf> bobajett: The "nestedness" of a list is something you know at compile-time.
14:38:59 <bobajett> shachaf: so it can't be done at runtime?
14:39:01 <Automorphism> I sense some JavaScript-ish thinking in the desire to construct that findDepth function. :-P
14:39:18 <shachaf> bobajett: Maybe it can, but it would be a really weird thing to do.
14:39:24 <shachaf> bobajett: Are you sure you're not thinking of a tree?
14:39:26 <Automorphism> bobajett: It would be useless, the depth would be associated to the type, not to specific values.
14:39:28 <bobajett> Automorphism: actually Im working through HTDP but using Haskell instead :-)
14:39:41 <shachaf> bobajett: OK, then you're thinking of a tree, not a list.
14:39:47 <shachaf> Scheme lists are actually trees.
14:40:12 <bobajett> oh ok.
14:40:43 <startling> scheme lists are actually lists of n-ary Eithers
14:42:39 <shachaf> startling: Recursive n-ary Eithers, if you want to put it that way. And one of the options is List.
14:42:43 <shachaf> The point is that they're trees.
14:43:06 <shachaf> startling: Scheme lists are *actually* tuples of "n-ary Eithers".
14:43:17 <shachaf> + a sentinel value
14:43:49 <bobajett> cool thanks guys, I guess I'll wait until I get to trees and Eithers in my Haskell books to understand this :-)
14:44:06 <startling> shachaf: yep
14:44:42 <shachaf> bobajett: Scheme is dynamically typed, so things are different.
14:45:13 * hackagebot readable 0.1 - Reading from Text and ByteString  http://hackage.haskell.org/package/readable-0.1 (DougBeardsley)
14:50:46 <timthelion> mm_freak_: http://hackage.haskell.org/trac/ghc/ticket/7188#comment:2
15:00:27 <erasmas> does anyone know of a data structure that works like an ordered list but is optimized for frequent reordering?
15:01:43 <mdittmer> Does anyone know whether a .cabal file can specify that a module remain hidden in general, but accessible to a test suite defined in the same .cabal file?
15:03:33 <bobTbuilder> is (3) a list or a number?
15:03:46 <bobTbuilder> how can I tell if parenthesis are used to form a list or operator grouping?
15:04:09 <shachaf> badkins: Parentheses are almost always grouping.
15:04:16 <shachaf> s/adkins/obTbuilder/
15:04:32 <matthiasgorgens1> erasmas: can you give more details?
15:04:45 <shachaf> bobTbuilder: There's a special case, tuples, which is "()" or "(x, y)" or more elements.
15:04:51 <shachaf> bobTbuilder: But those aren't lists, they're tuples.
15:05:07 <bobTbuilder> that's what I meant
15:05:08 <bobTbuilder> tuples
15:05:14 * hackagebot asn1-data 0.7.0 - ASN1 data reader and writer in RAW, BER and DER forms  http://hackage.haskell.org/package/asn1-data-0.7.0 (VincentHanquez)
15:05:27 <bobTbuilder> is tuples with a single element the same as no tuple at all?
15:05:43 <bobTbuilder> for example (3) and 3
15:05:59 <bobTbuilder> or map (toUpper) "hello" and map toUpper "hello"
15:05:59 <erasmas> matthiasgorgens1: sure. it's essentially a queue with thousands of items that needed to ordered, but also need to be frequently reordered (item 5 moves up to position 2, item 9,807 moves up to position 5,430)
15:06:02 <bobTbuilder> work exactly the same
15:06:07 <shachaf> bobTbuilder: There's no such thing as a one-element tuple.
15:06:14 <shachaf> bobTbuilder: Parentheses are just for grouping there.
15:06:21 <bobTbuilder> ok
15:06:30 <bobTbuilder> is there tuples with more then 2 elements?
15:06:49 <shachaf> Yes. 0 and 2-or-more.
15:06:50 <bobTbuilder> and what exactly is :
15:06:54 <matthiasgorgens1> erasmas: you might want to try prioritity queues?
15:07:05 <shachaf> bobTbuilder: It's a list constructor. It has nothing to do with tuples.
15:07:14 <shachaf> bobTbuilder: This is explained in most introduction to Haskell pretty early on.
15:07:19 <shachaf> Is there one that you're reading?
15:07:27 <bobTbuilder> Try Haskell
15:07:30 <erasmas> matthiasgorgens1: thanks, I will read up on it
15:07:35 <bobTbuilder> .org
15:07:58 <c_wraith> erasmas, matthiasgorgens1: I think you probably actually want a priority *search* queue, based on your description.  There are packages for that on hackage.
15:08:05 <bobTbuilder> I can use it, but I didn't understand what it was
15:08:15 <bobTbuilder> thank you1
15:08:25 <bobTbuilder> *thank you!
15:08:36 <matthiasgorgens1> bobTbuilder: learn you a haskell for great good (also linked from tryhaskell.org) is a good way to get started.
15:08:45 <erasmas> c_wraith: looking it up now -- thanks!
15:09:08 <bobTbuilder> Yeah, I already downloaded it in my kindle, I am planning to read it after I finish try Haskell
15:09:44 <matthiasgorgens1> bobTbuilder: I don't see any tutorial at tryhaskell.org
15:09:57 <matthiasgorgens1> bobTbuilder: just the window to try out code.  where's the tutorial?
15:10:00 <bobTbuilder> ?
15:10:03 <bobTbuilder> step1
15:10:07 <bobTbuilder> type step1
15:10:08 <matthiasgorgens1> bobTbuilder: oh, type "help"
15:10:18 <bobTbuilder> yeah :)
15:10:53 <matthiasgorgens1> bobTbuilder: it might be easier just to install haskell locally on your computer.  (thought that might depend on the operating system you run.)
15:11:05 <bobTbuilder> I already got it
15:11:38 <matthiasgorgens1> good.
15:12:42 <nus> mdittmer, "other-modules:"
15:12:50 <matthiasgorgens1> bobTbuilder: have fun!
15:13:06 <bobTbuilder> I am having fun! I love Haskell so far
15:13:14 <bobTbuilder> thank you!
15:13:55 <mdittmer> nus: thanks, but that doesn't seem to be working. The test suite complains that it's missing.
15:14:15 <mdittmer> nus: should I be making my main src dir a test src dir rather than depending on the package I'm testing directly?
15:26:25 <loreints> does _ mean anyting special in haskell? or is just a common idiom for a var no one cares about?
15:26:36 <shachaf> It means you're ignoring a value.
15:26:40 <shachaf> It's special.
15:26:52 <loreints> shachaf: thanks!
15:26:55 <shachaf> > (\x x -> 5) "a" "b"
15:26:56 <bobTbuilder> let (a:_:_:_) = "xyz" in a
15:26:56 <lambdabot>   Conflicting definitions for `x'
15:26:56 <lambdabot>  Bound at: <interactive>:1:2
15:26:56 <lambdabot>            <in...
15:26:57 <shachaf> > (\_ _ -> 5) "a" "b"
15:26:58 <lambdabot>   5
15:27:04 <bobTbuilder> > let (a:_:_:_) = "xyz" in a
15:27:05 <lambdabot>   'x'
15:27:14 <edwardk> loreints: _ with nothing after it just means it doesn't bind a variable, _foo has some special interactions with error messages (it won't complain if you don't use it, etc)
15:27:42 <edwardk> and _1, _2, etc. are lenses.. ;)
15:28:29 <nus> mdittmer, http://hackage.haskell.org/packages/archive/attoparsec/0.10.2.0/attoparsec.cabal
15:28:30 <shachaf> I'm suspicious of that naming scheme for lenses.
15:28:40 <edwardk> shachaf: it is one way to avoid conflicts ;)
15:29:07 <edwardk> and it gives me a comparatively low verbosity, underutilized portion of the valid namespace nearly for free
15:29:26 <bobTbuilder> > let (a:_:_:_) = [5,3] in a
15:29:27 <lambdabot>   *Exception: <interactive>:3:4-20: Irrefutable pattern failed for pattern (a...
15:29:28 <bobTbuilder> > let (a:_:_:_) = [5,3,5] in a
15:29:29 <lambdabot>   5
15:29:40 <bobTbuilder> why does the first one does not work and the second one does?
15:29:50 <kane77> http://hpaste.org/73676 any tips how to avoid the "dancing around" in 'index' function?
15:29:52 <shachaf> I,I makeLenses ''_1
15:29:55 <bobTbuilder> > let (a:_:_:_) = [5,3,5,6,6,6234,2,4] in a
15:29:56 <lambdabot>   5
15:30:57 <typoclass> bobTbuilder: if you write (a:_:_:_), you're requiring a list that has at least 3 elements (first will be called 'a', the next two are anonymous but must be present)
15:31:11 <typoclass> if you put in a shorter list, you get the runtime error you saw above
15:31:23 <bobTbuilder> > let (a:_:_:_:_:_) = [5,3,5,4] in a
15:31:24 <lambdabot>   *Exception: <interactive>:3:4-28: Irrefutable pattern failed for pattern (a...
15:31:33 <typoclass> what's _1 again, the lens equivalent of fst?
15:31:40 <edwardk> typoclass: yeah
15:31:52 <bobTbuilder> ok
15:31:53 <edwardk> ("hello","world","!!!")^._1  ==> "hello"
15:33:36 <edwardk> _1.contains "hello" .~ False $ (Set.fromList ["hello","world"], "!!!")    ==> (Set.fromList ["world"], "!!!")
15:34:22 <edwardk> toListOf (traverse._1) [(1,"hello"),(2,"there")] ==> [1,2], etc.
15:34:51 <mdittmer> nus: I'm not sure what I'm supposed to take from that. I can see that both the library and the test have "other-modules". My experience with my current code is that non-exposed-modules from the library are not available to the test suite.
15:34:54 <edwardk> works for k-ary tuples, and composes with other lenses and traversals
15:35:48 <typoclass> looks nice. is it part of some naming system, or are _1/_2/_3 the only names with an underscore?
15:36:26 <mdittmer> nus: I also see that the test suite depends on auto parsec, so it doesn't appear that auto parsec's source dir is supposed to be a test suite source dir (i.e., built as a part of the test rather than included as a dependency).
15:38:09 <y3n> esmi.allalla.com
15:40:32 <Mandarin> I'm having trouble with a web page scraping since I don't know how to map through a IO [URI]: http://hpaste.org/73679
15:42:26 <edwardk> typoclass: i have a number of other lenses using that naming scheme as well, mostly when i need a lens to go with an already named concept
15:42:57 <edwardk> e.g. if you already have head, it isn't a stretch to switch to _head and get the ability to read and write from it
15:43:41 <typoclass> edwardk: ah, i see
15:43:58 <jfischoff> Mandarin: Have you tried mapM?
15:43:59 <edwardk> in general i tend to switch to something more declarative, by just switching the tense of the name, or switching to prefix _'s where its just a strict generalization.
15:44:04 <jfischoff> @type mapM
15:44:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:44:06 <Dodek> Mandarin: line 20, consider using mapM instead of map
15:44:35 <Mandarin> Dodek: jfischoff: never heard of mapM before.. Will look into it!
15:44:44 <latro`a> @src mapM
15:44:44 <lambdabot> mapM f as = sequence (map f as)
15:44:47 <latro`a> @src sequence
15:44:47 <lambdabot> sequence []     = return []
15:44:47 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:44:47 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
15:44:53 <Nereid> @type sequence
15:44:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:45:07 <latro`a> sequence is pretty awesome
15:45:11 <Nereid> yes
15:45:14 <nus> mdittmer, what happens if you setup a symlink from the test-suite dir to the internals?
15:45:28 <Mandarin> Thanks! Worked like a charm :)
15:46:02 <jfischoff> Mandarin: fyi you can find functions like that by searching type signatures in hayoo or hoogle
15:46:32 <mdittmer> nus: I can simply include the internals dir in my test suite's list of source dirs, but that's not what your example does. It makes the library's package a dependency, which, as far as I can tell, won't provide access to internal packages.
15:46:39 <mdittmer> nus: **internal modules
15:47:19 <Mandarin> jfischoff: hadn't heard of hayoo before, thanks!
15:47:44 <nus> mdittmer, right, it won't... I meant the attoparsec's .cabal more as a general example
15:51:35 <Hadaka> hello! I'd need to do a simple client & server with haskell, just for testing
15:52:05 <Hadaka> the client scans a bunch of files, and composes a message about them, sending it as a HTTPS POST to the server
15:52:25 <Hadaka> the server receives the POST and then writes some files on the disk and replies with a bit of data
15:52:51 <Hadaka> the messages fit easily in memory, but there's going to be quite a bit of them, so it should be pretty high performance
15:53:37 <Hadaka> there's no HTML involved anywhere, and the server / client do not have to support anything except the simple HTTPS POST, but obviously HTTP keepalive should be used
15:54:07 <Hadaka> the data format base assumption would be JSON, but if there's a significantly better idea, that could be used
15:54:41 <Hadaka> now, what libraries should I use for the HTTP parts?
15:55:02 <Hadaka> for the client, Network.HTTP.Conduit looks great I guess
15:55:38 <Hadaka> for the server, I've taken a peek at Yesod and Snap, but both kind of got a knee jerk reaction from all the HTML templating and scaffolding going on for something as simple as this
15:56:52 <nus> mdittmer, so, does adding the directory with the internals to the test-suite's hs-source-dirs work?
15:57:42 <Hadaka> also, this isn't critical, is there something akin to libeio for haskell? that is, a library that provides file-IO that does not block the entire program even if the filesystem ends up blocking
15:58:03 <mdittmer> nus: Seems to, but I don't have very elaborate tests in place yet to see whether it might cause other problems.
15:58:07 <mdittmer> nus: thanks for the help :)
15:58:36 <nus> yw
16:06:59 <spark_> any library that does integration?
16:08:31 <latro`a> http://hackage.haskell.org/packages/archive/hmatrix/0.8.3.1/doc/html/Numeric-GSL-Integration.html apparently
16:09:09 <spark_> latro`a: I was just going to say, that isn't hmatrix >.<
16:09:20 <latro`a> oh
16:09:25 <latro`a> k
16:09:31 <latro`a> I'm not too fond of hmatrix either
16:09:41 <latro`a> if only because of those app functions
16:09:43 <spark_> latro`a: i never manage to get it to install on windows
16:09:47 <latro`a> which I *still* completely don't understand
16:09:57 <latro`a> why is that?
16:10:01 <latro`a> can you get LAPACK installed?
16:10:06 <latro`a> that should be the main obstacle afaik
16:10:18 <spark_> yes, thats my problem
16:10:22 <latro`a> ahh
16:10:29 <latro`a> there should be tutorials for how to do that on windows
16:10:38 <spark_> always had problems with c bidings
16:10:44 <latro`a> it's a bitch though, since most tutorials are written to get something like ATLAS
16:10:56 <latro`a> or to compile your own BLAS
16:10:57 <latro`a> etc.
16:12:48 <spark_> It's kinda sad that many libraries I try to cabal install plainly fail on windows because of the bidings
16:12:57 <spark_> and I never got to know how to install those
16:13:55 <spark_> Is there something on the wiki about this? I believe it's kinda of common for windows users
16:19:18 <edwardk> woot. i finally got all the fancy hit cache plumbing for Data.Data from uniplate working with lens, so you can do generic traversals that don't waste time
16:19:30 <HugoDaniel> :D
16:19:31 <edwardk> next up, porting the same machinery so it can work with GHC.Generics s well
16:20:03 <edwardk> then you can pretty much have a version of uniplate that doesn't require wrestling with overlapping instances, etc.
16:20:17 * hackagebot active 0.1.0.2 - Abstractions for animation  http://hackage.haskell.org/package/active-0.1.0.2 (BrentYorgey)
16:20:21 <edwardk> and where you can use any of the other lens/traversal combinators with plates
16:20:46 <edwardk> and you can use any of the tools for constructing lenses and traversals to help build plates
16:21:38 <edwardk> plus it doesn't require the hackish 'Str' type that uniplate uses. it is 'correct by construction', and there isn't a huge invariant you have to preserve everywhere in every combinator
16:21:57 <edwardk> over all a good day =)
16:22:32 <latro`a> feh, recursion with default values based on Maybe is irritating
16:23:00 <latro`a> you either need a helper that takes the default or you get Justs in your recursive call
16:23:19 <Hakkla> hello.
16:24:32 <spark_> Hakkla: hello
16:25:22 <Hakkla> Anyone experienced in changing the stack size when compiling in GHC? I don't seem to be able to increase it, I've tried every "+RTS -K128M -RTS and the compiled program still has only 8MB of stack!
16:25:42 <shachaf> Hakkla: +RTS is a runtime option.
16:25:56 <shachaf> Hakkla: Compile the program with ghc -rtsopts, and then run it with +RTS -K...
16:26:09 <geekosaur> there's --wth-rtsopts when compiling
16:26:23 <geekosaur> --with-rtsopts=-K128M
16:27:42 <donri> one hyphen though
16:27:48 <Hakkla> Aha! Thank you, it works.
16:28:31 <Hakkla> shachaf++
16:44:15 <startling> what's the way to set an -X flag in ghci?
16:44:38 <latro`a> :set
16:45:41 <startling> latro`a: thanks
16:45:48 <latro`a> np
16:48:21 <mk> if I want a monad that models stateful non-deterministic computations, what are the monadic values going to look like? A list of state monadic values?
16:48:41 <sipa> you mean the [] monad?
16:48:53 <latro`a> depends what you mean by "stateful non-deterministic"
16:49:04 <latro`a> how are the states accessed
16:49:17 <startling> mk, a SomeState -> [Whatever] function
16:49:34 <startling> where SomeState is a list or a tuple or a map or whatever
16:49:40 <latro`a> do the different "branches" of the computation have their own states?
16:49:53 <mk> sipa: is there a difference between [] and list?
16:50:00 <sipa> mk: no
16:50:48 <startling> mk, well, `list` doesn't seem to be a thing
16:51:49 <bobTbuilder> > :t map
16:51:50 <lambdabot>   <no location info>: parse error on input `:'
16:52:01 <bobTbuilder> :type map
16:52:11 <bobTbuilder> > :type map
16:52:12 <lambdabot>   <no location info>: parse error on input `:'
16:52:15 <siracusa> @type map
16:52:16 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:52:26 <bobTbuilder> thanks lol
16:52:28 <mk> latro`a: bind would map the same state in. It wouldn't thread the state through each invocation of the monadic function while it's doing the mapping.
16:52:37 <bobTbuilder> why is it (a -> b) -> [a] -> [b]?
16:52:42 <bobTbuilder> doesn't it return one value?
16:52:51 <bobTbuilder> shouldn't it be (a -> b) -> [a]?
16:53:02 <latro`a> ...huh?
16:53:22 <latro`a> bobTbuilder, it applies the function to each element of the [a]
16:53:39 <latro`a> also, :t does work
16:53:40 <latro`a> :t map
16:53:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:53:49 <latro`a> doesn't work in query, however
16:54:00 <latro`a> "@type" works in both
16:54:04 <startling> bobTbuilder: you can look at it like  (a -> b) -> ([a] -> [b])
16:54:30 <bobTbuilder> ok
16:54:37 <bobTbuilder> I need a minute to think about it
16:54:45 <latro`a> it actually is that
16:54:58 <startling> bobTbuilder: it takes a function that works on a and turns it into a function that works on [a]
16:55:12 <bobTbuilder> uh
16:55:13 <bobTbuilder> ok
16:55:15 <bobTbuilder> I get it now
16:55:33 <startling> :t (+ 1)
16:55:34 <lambdabot> forall a. (Num a) => a -> a
16:55:39 <startling> :t fmap (+ 1)
16:55:40 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
16:55:49 <startling> :t map (+ 1)
16:55:50 <lambdabot> forall a. (Num a) => [a] -> [a]
16:55:54 <startling> ^ might be more intuitive
16:56:17 <bobTbuilder> yeah
16:56:25 <bobTbuilder> I just finished Try Haskell tutorial, but there seems to be a lot missing.
16:56:34 <bobTbuilder> It didn't even mention monads or anything
16:56:42 <latro`a> for a second there I read Num f,Functor f
16:56:43 <latro`a> and head exploded
16:56:52 <latro`a> (or rather internally kind error'd)
16:56:52 <startling> latro`a: heh
16:57:15 <startling> latro`a: (Num b => a -> b) would work for that!
16:57:24 <mk> latro`a: bind receives a single monadic value. That value contains (effectively) a list of state-value pairs. Bind maps those into the monadic function provided to it. It doesn't thread a single state value while doing the mapping. If that doesn't make sense, then I'm not sure what you mean by "do the different branches of the computation have their own states?"
16:58:07 <startling> bobTbuilder: anyway, monads are easy. did it cover typeclasses?
16:58:16 <latro`a> touche, startling
16:58:23 <bobTbuilder> what is typeclass?
16:58:35 <latro`a> mk: a list of *results*
16:58:45 <latro`a> that's rather strange
16:58:49 <latro`a> and contrary to how State works
16:59:28 <startling> bobTbuilder: that'd be a thing to learn
16:59:35 <startling> bobTbuilder: have you looked at lyah?
16:59:38 <startling> @where lyah
16:59:38 <lambdabot> http://www.learnyouahaskell.com/
16:59:40 <bobTbuilder> Learn You a Haskell For Great Good!?
16:59:51 <startling> bobTbuilder: that's the one
16:59:52 <bobTbuilder> yeah, I already downloaded it
17:00:02 <mk> bobTbuilder: a typeclass is pretty much an interface, if you're coming from a language that has those
17:00:17 <bobTbuilder> what is interface?
17:00:25 <mk> bobTbuilder: then nevermind :)
17:00:32 <bobTbuilder> I know C++ and C
17:00:39 <n00b6502> C/C++ :)
17:00:53 <bobTbuilder> interfaces sound like something from Java
17:01:07 <bobTbuilder> I consider C++ and C different languages
17:01:10 <startling> bobTbuilder: temporarily get rid of that knowledge
17:01:22 <startling> bobTbuilder: forget what "class" means
17:01:26 <bobTbuilder> and if someone knows C++, I do not consider that they know java
17:01:28 <bobTbuilder> ok
17:01:28 <startling> and then read lyah
17:01:38 <bobTbuilder> I mean C
17:01:41 <bobTbuilder> not Java
17:01:44 <mk> bobTbuilder: don't worry about all that for now. Do you know what a type is?
17:01:46 <bobTbuilder> my brain doesn't work today
17:02:02 <bobTbuilder> like integer, float and char?
17:02:17 <n00b6502> i prefer to say c/c++ because of the ability to overlap
17:02:29 <latro`a> actually, startling, no it wouldn't
17:02:38 <latro`a> not without type level lambdas
17:02:39 <mk> bobTbuilder: yeah those are examples. A type is a "set" of values, in the mathematical notion of a set.
17:02:42 <otters> Is it possible to get a String representation for a function's type in haskell?
17:02:46 <startling> latro`a: hm?
17:02:49 <bobTbuilder> still, I know many C++ programmers, that cannot use printf and can't write a 100 line program in C
17:02:54 <latro`a> because you are thinking of \a -> a -> b, basically
17:03:05 <latro`a> which can't be written using partial application of (->)
17:03:06 <n00b6502> because they only know c++stdlib ?
17:03:07 <startling> latro`a: isn't (Num b => a -> b) an instance of Num in lambdabot?
17:03:13 <latro`a> it is, but it's not a Functor
17:03:15 <bobTbuilder> yeah
17:03:24 <mk> bobTbuilder: forget c and c++ ;)
17:03:31 <latro`a> the Functor instance for (->) holds the *first* parameter fixed
17:03:41 <latro`a> so a->Int can't be a Functor
17:03:42 <startling> latro`a: oh! got it
17:03:46 <latro`a> might be able to do it with synonyms, however
17:03:48 <startling> darn. :/
17:04:08 <bobTbuilder> ok :)
17:04:24 <latro`a> erm, no, you still can't
17:04:28 <latro`a> because then the functor is contravariant
17:04:32 <latro`a> which isn't a Functor in haskell's sense
17:04:59 <mk> bobTbuilder: you know how some types have functions that go with them? like, numbers have +, and strings have concatenate, or whatever?
17:05:25 <bobTbuilder> void operator+(string t);
17:05:30 <bobTbuilder> ;)
17:05:32 <bobTbuilder> yeah
17:06:27 <mk> bobTbuilder: ok, well, look at >, aka greater-than. That one works with a whole bunch of types. We can order ints, strings... lists...
17:06:32 <latro`a> the details of these functions may differ from type to type even if basic properties are the same
17:06:51 <bobTbuilder> ok
17:06:58 <latro`a> in which case in haskell terminology we make all the pertinent types an instance of the same class
17:07:09 <latro`a> in java and similar terminology all the pertinent types provide the same interface
17:07:49 <bobTbuilder> instance of the same class?
17:08:05 <latro`a> yes; for example Double and Int are both instances of Num, which means they have +, *, etc.
17:08:33 <bobTbuilder> like derived classes and overloaded virtual functions?
17:08:33 <latro`a> this means you can use +, *, etc. on numbers whose precise type you don't know
17:08:34 <mk> bobTbuilder: all of those "orderable" things that I listed form a typeclass under the > operation
17:08:57 <bobTbuilder> ok
17:09:39 <HugoDaniel> https://github.com/mozilla/servo
17:09:41 <mk> the relevant properties of > are exactly the same for each one of those types. So if you define an implementation of "greater than" for each one of them, you're good to go. You can now use > with any of them (and even with brand new types that you make up).
17:09:44 <HugoDaniel> they aren't doing it in haskell
17:10:34 <latro`a> one thing about typeclasses is that they needn't actually satisfy the properties you expect; the compiler only enforces that the typeclass functions have the right type
17:10:46 <latro`a> for example
17:10:48 <latro`a> :t (>)
17:10:49 <lambdabot> forall a. (Ord a) => a -> a -> Bool
17:11:08 <bobTbuilder> what does Ord mean?
17:11:10 <latro`a> the compiler doesn't prevent you from writing "x > y = x == foo"
17:11:13 <mk> bobTbuilder: what this means in the end is that you can create a sorted set, or a treemap, or whatever, and it'll work for any types in the typeclass -- even ones that you don't know existed, and even ones that are defined long after you define your datastructure
17:11:20 <latro`a> Ord is the name of the typeclass of ordered types
17:11:38 <mk> bobTbuilder: Ord is "Ordered", it... ^
17:11:48 <startling> HugoDaniel: well, isn't that why they wrote Rust?
17:11:52 <bobTbuilder> oh, ok
17:11:53 <mk> or "Orderable", if you prefer
17:11:53 <bobTbuilder> I get it
17:12:27 <bobTbuilder> and why does it has => instead of ->
17:12:35 <startling> bobTbuilder: that's a different thing
17:13:36 <startling> bobTbuilder: "Num b => b" means "a type b that satisfies Num"
17:13:54 <bobTbuilder> ok
17:14:01 <startling> bobTbuilder: "Num b => b -> b -> b" means "a function b -> b -> b where b satisfies Num"
17:14:54 <bobTbuilder> so what does "(Ord a) => a -> a -> Bool" take?
17:15:21 <bobTbuilder> Ord a? or a? or 2 a's? or all of them are a's and it doesn't do anything?
17:16:08 <geekosaur> the stuff befre => qiualifies names, which are then so qualified in all occurrences
17:16:13 <mk> bobTbuilder: first you figure out your types. Then, you figure out if any interesting operators "just work" for your types (does each one have a next value? can you add them?), and set up the appropriate typeclass
17:16:40 <shachaf> That sounds like advice that would lead to overuse of typeclasses.
17:17:24 <startling> bobTbuilder: it takes two a; a must satisfy Ord
17:17:44 <mk> "then, if you really need to, you figure out if any interesting operators..."
17:18:49 <bobTbuilder> yeah, I know that this particular takes two a's and returns bool, but the rrors can be ambiguous
17:19:20 <mk> bobTbuilder: it's like when you write String a. It just tags "a" with a type, but in this case, it tags it with a typeclass
17:19:32 <latro`a> uh
17:19:36 <latro`a> String a is nonsense
17:19:57 * shachaf has the feeling that's not the only nonsense being spoken here.
17:20:04 <mk> latro`a: bobTbuilder is coming from C/C++
17:20:12 <shachaf> C/C++ isn't a language.
17:20:20 <mk> shachaf: I never said it was?
17:20:21 <monochrom> is there "String a" in C++ too?
17:20:33 <shachaf> And analogies to either C or C++ aren't helpful in figuring out type classes.
17:20:40 <monochrom> maybe you should use a better example
17:21:05 <latro`a> making analogies to java interfaces is arguably helpful
17:21:20 <mk> I think they are, but if you're unsatisfied, just read " It just tags "a" with a type, but in this case, it tags it with a typeclass"
17:21:20 <bobTbuilder> but the problem is, I never used Java
17:21:24 <latro`a> since typeclasses are basically strictly stronger than interfaces
17:21:39 <shachaf> bobTbuilder: Good, because type classes are pretty different from Java interfaces.
17:21:49 <shachaf> So if you've never seen Java interfaces, you'll understand them in no time!
17:21:59 <bobTbuilder> is Java interfaces somewhat like C++ templates?
17:22:05 <monochrom> "tag" is misleading or wrong, too
17:22:07 <latro`a> very distantly, to my knowledge
17:22:09 <shachaf> No.
17:22:17 <startling> bobTbuilder: I told you, forget all that stuff!
17:22:18 <mk> bobTbuilder: forget java interfaces. Really :)
17:22:26 <bobTbuilder> ok
17:22:32 <shachaf> bobTbuilder: Type classes aren't all that important a feature of Haskell. I'd say you should just ignore them for a while.
17:22:35 <bobTbuilder> I gtg. Thanks for explaining this to be.
17:22:38 <shachaf> Write concrete functions.
17:22:42 <bobTbuilder> See you all later!
17:22:47 <mk> bye bobTbuilder
17:22:55 <latro`a> eh, that's pretty deceptive shachaf
17:23:05 <bobTbuilder> "concrete functions"
17:23:09 <bobTbuilder> what is that?
17:23:13 <latro`a> functions with concrete types
17:23:16 <bobTbuilder> like normal once?
17:23:18 <startling> yeah
17:23:23 <bobTbuilder> ok
17:23:26 <latro`a> Int -> Int and so on
17:23:29 <monochrom> I think type classes are important and can be learned early. but as usual, learn it as entirely new, don't analogize
17:23:37 <shachaf> latro`a: What's deceptive?
17:23:54 <latro`a> but I think it's deceptive to say they aren't that important; Control.Monad (not so much monads themselves) is one of the central strengths of the standard library
17:24:00 <monochrom> learn any part of haskell as entirely new
17:24:09 <shachaf> Haskell without type classes wouldn't be a particularly bad language.
17:24:24 <latro`a> true, but you lose a lot of power and abstraction that way
17:24:32 <latro`a> losing "sequence" alone is kinda terrifying
17:24:32 <bobTbuilder> would it be particularly good?
17:25:08 <latro`a> I think you could sorta circumlocute the places where you would use typeclasses now
17:25:09 <shachaf> It would be pretty good, yep.
17:25:10 <latro`a> for the most part
17:25:24 <latro`a> sorta like how GTK used circumlocution to work around C's type system
17:25:41 <bobTbuilder> that's mainly why I prefere Qt
17:25:44 <shachaf> Type classes are overused.
17:25:50 <startling> I think haskell would be an ugly ugly language without typeclasses
17:25:52 <latro`a> I also think just more code would be concrete in the first place
17:26:03 <latro`a> which is sometimes a pro but usually a con imo
17:26:03 <shachaf> startling: You're wrong. :-(
17:26:30 <latro`a> for an example of a pro, I was writing a program where I had type parameters everywhere that would let me choose between a couple different types
17:26:31 <mk> bobTbuilder: you would lose a very nice way to have polymorphism
17:26:33 <latro`a> Int/Integer for example etc.
17:26:40 <startling> shachaf: k
17:26:48 <latro`a> and eventually got tired of carrying them around and keeping track of what they were, so I made them concrete
17:26:54 * shachaf should probably not get into the habit of saying "you're wrong".
17:27:19 <latro`a> since they would have no reason not to be Double and Int in the first place
17:27:31 <startling> especially "you're wrong about this subjective aesthetic preference"
17:27:46 <shachaf> That's my favorite thing to say that about, though.
17:28:01 <shachaf> But I ought not to.
17:28:46 <mk> bobTbuilder: some advice: if people start arguing about whatever thing you're asking about (in this case, typeclasses), it's probably worth learning about
17:29:05 <startling> haha
17:29:15 <startling> more so if they say lots of words you don't know
17:29:21 <shachaf> On the contrary, it's probably worth not learning about it.
17:29:25 <bobTbuilder> As of right now, if people start arguing about something I ask about, it is too early for me to learn
17:29:49 <bobTbuilder> As of right now, if people start arguing about something I ask, it is too early for me to learn it*
17:31:07 <mk> bobTbuilder: it really isn't. It might be confusing to hear people say different and incomprehensible things, but sorting that out is a good way to learn
17:33:26 <bobTbuilder> why does
17:33:27 <bobTbuilder> :t take
17:33:28 <lambdabot> forall a. Int -> [a] -> [a]
17:33:32 <bobTbuilder> has []
17:33:43 <bobTbuilder> and :t map
17:33:51 <bobTbuilder> doesn't
17:34:01 <mk> bobTbuilder: anyway, "(Ord a) =>" pretty much means "that a thing over there must be an Ord"
17:34:48 <ranger66> :t map
17:34:48 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:36:25 <bobTbuilder> nevermind
17:36:29 <bobTbuilder> bye all!
17:36:34 <mk> bobTbuilder: see ya
17:40:22 * hackagebot wraparound 0.0.1.1 - Convenient handling of points on a seamless 2-dimensional plane  http://hackage.haskell.org/package/wraparound-0.0.1.1 (ChristopherHoward)
17:43:37 <MagneticDuck> hey there, any help on a little irc bot problem?
17:43:43 <MagneticDuck> http://stackoverflow.com/questions/12118246/haskell-irc-bot-stalling-out
17:43:54 <MagneticDuck> I'm responding to ping, but I loose the connection somehow
17:44:48 <MagneticDuck> argh, g2g
17:45:00 <MagneticDuck> if you have a response, respond on the site
17:45:03 <MagneticDuck> thanks
17:46:11 <latro`a> ...isn't freenode a .net?
17:46:24 <latro`a> it is in my client
17:46:48 <latro`a> oh wait, nvm, it does connect initially apparently
17:46:50 <latro`a> not sure how
17:47:02 <zomg> Guess it works either way
17:48:42 <latro`a> I am curious why that breaks, actually
17:48:57 <latro`a> wonder if it would work on another server
17:49:07 <latro`a> (freenode has some weird regulations)
18:14:08 <scshunt> hmm
18:14:27 <scshunt> I have some questions for you folk-type folk
18:14:46 <scshunt> I would like to make a log of actions on a state
18:15:16 <scshunt> this is easily represented by a monad
18:15:41 <scshunt> however, I might want to get a log which grabs only those things which affect certain aspects of the state
18:15:45 <scshunt> and I may not know these things in advance
18:15:58 <scshunt> does anyone know of a good way to manage this?
18:16:32 <mk> so the state monad is like the identity monad, except that instead getting a singleton value container (Id x), I get this strange... function. That function contains all those other functions that I might have chained together, and is waiting for me to give it an initial state. And then it returns my x, except it also returns the final state, too. Is that right?
18:16:48 <shachaf> scshunt: filter?
18:16:59 <shachaf> mk: The State monad has very little to do with the Identity monad.
18:17:03 <shachaf> Other than that they're both monads.
18:17:04 <roconnor> mk: it is right, except for the part about being like the identity monad
18:17:16 <scshunt> shachaf: yeah, filter, except I'd rather not have to filter on the comparison of input and output of a function
18:17:35 <shachaf> scshunt: I don't know what you're so I took a random guess.
18:18:09 <shachaf> What you're asking, I mean.
18:18:11 <mk> roconnor: are there other ways, besides the ways I specified, in which the two are different?
18:18:28 <shachaf> mk: Other than "everything", they're not different at all. :-)
18:19:05 <mk> I'm comparing it to identity because identity deals with only a single value (unlike list), and doesn't address failure (unlike maybe)
18:19:22 <shachaf> There's not much point to comparing it to anything. It's its own thing.
18:19:29 <shachaf> If you have to compare it to something, compare it to Reader.
18:19:37 <scshunt> shachaf: imagine something along the lines of do { log1 <- trans1 "do first transformation\n"; log2 <- trans2 (log++"do second transformation\n") } which would let me get a log of everything
18:19:38 <shachaf> But it's pretty different from Reader.
18:19:41 <scshunt> which some wrapper
18:19:44 <roconnor> mk: well the state monad has an output for every state input; so it isn't like the state monad is a singleton container.
18:19:54 <scshunt> *with some wrapper
18:20:03 <shachaf> "State s a" doesn't contain an "a" at all.
18:20:26 <shachaf> scshunt: I'm not sure I understand.
18:20:30 <latro`a> sure it does, in the same sense that r->a does
18:20:33 <shachaf> scshunt: Does Writer not do what you want?
18:20:40 <shachaf> latro`a: Right -- it doesn't.
18:20:49 <shachaf> get :: State Int Int
18:20:51 <latro`a> if you want to look at it that way, OK
18:20:52 <shachaf> Does that contain an Int?
18:20:55 <latro`a> absolutely
18:21:25 <shachaf> And the function (id :: Int -> Int) contains an Int too?
18:21:29 <latro`a> the container analogy gets stretched, but it never really breaks imo
18:21:30 <mk> roconnor: right - it's a function, but it's a bit like ... getting a zero-place function back from Identity, and getting a one-place function back from State (which expects the initial state)
18:21:30 <latro`a> yes
18:21:48 <latro`a> functions are basically Maps
18:22:09 <shachaf> latro`a: It breaks horribly when you're trying to explain things. It breaks non-horribly when you're just trying to think about it yourself.
18:22:20 <latro`a> I disagree to a fair extent
18:22:21 <shachaf> Does getLine :: IO String contain a String?
18:22:23 <latro`a> yes
18:22:24 <mk> shachaf: I think in much the same way that a List monad contains all those so
18:22:34 <roconnor> mk: Can I say that (+) is like 0 except instead of being one number it takes two numbers and adds them together to produce a new number?
18:22:36 <shachaf> By "contain" do you mean "is covariant in" or something like that?
18:22:39 <mk> -called "possible" values. Except a function lets you resolve which one you want.
18:22:53 <latro`a> ultimately, yes, but the analogy doesn't really break down that hard even without replacing "contain"
18:23:15 <scshunt> shachaf: hmm
18:23:19 <latro`a> "yields" is more precise, and encompasses both the computation and container analogies
18:23:26 <latro`a> but "contains" is still sufficient
18:23:38 <latro`a> I have trouble reasoning about Cont in a container analogy, however
18:24:09 <shachaf> latro`a: Does (data Null a = Null) Null Int "contain" an Int?
18:24:12 <scshunt> shachaf: That looks like the correct monad, but it doesn't really help with my 'filter'ing problem
18:24:16 <mk> roconnor: well, somewhat, but perhaps more like (+1) is like a number, but it's waiting for you to complete it
18:24:22 <shachaf> scshunt: I don't know what your "filter"ing problem is.
18:24:29 <latro`a> shachaf--Trivial breaks all kinds of intuitions
18:24:32 <roconnor> mk: okay, the the State monad is like the Identity monad
18:24:34 <pqmodn> scshunt: you'd probably want to tag your log messages, like data LogMessage = AspectA String | AspectB String | ...; then when you've got a list of log messages you can filter them
18:24:35 <roconnor> *then the
18:24:47 <shachaf> latro`a: It doesn't break the "action" intuition! :-)
18:24:52 <shachaf> Nor does Cont r or anything else.
18:24:57 <shachaf> Whereas IO totally breaks it.
18:25:05 <latro`a> breaks what, container?
18:25:09 <latro`a> I disagree about IO
18:25:10 <scshunt> pqmodn: yeah, I don't really want to explicitly tag
18:25:18 <scshunt> pqmodn: I'm okay if I have to limit how I access the state
18:25:23 <scshunt> something lens-like
18:25:29 <shachaf> Does "Maybe Int" contain an Int?
18:25:30 <latro`a> the action contains a value in the sense that you can open it up to see the value
18:25:30 <scshunt> and that manages the tagging behind the scenes
18:25:35 <shachaf> I have the feeling this discussion is pointless.
18:26:05 <latro`a> it's fairly pointless because neither of us are dependent upon analogies to use monads, and because analogies are fundamentally approximate anyway
18:26:15 <shachaf> scshunt: Aren't you explicitly tagging anyway?
18:26:30 <shachaf> What do you want, primitives logTypeA and logTypeB, and then to see the result of only one log?
18:26:38 <pqmodn> scshunt: you could probably abstract those details away. say you have a monadic action that increments the state. you could do inc = modify (+ 1) >> tell [AspectA "inc"]. you want to distinguish it from an action that decrements the state, dec = modify (- 1) >> tell [AspectB "dec"]
18:26:52 <mk> "container" isn't really an analogy, any more than "returns (a value)" is
18:26:58 <latro`a> I would say that an m a can yield an a, to the extent that you can bind the m a to a function
18:27:00 <scshunt> pqmodn: yeah, I'm wondering if there's anything that can do that already in a lens-like fashion
18:27:04 <roconnor> BTW, there is a formal definition of container, and not all monads are containers, though many are.
18:27:10 <latro`a> the semantics of "yield" ar ehence dependent on the semantics of "bind"
18:27:13 <latro`a> *are hence
18:27:16 <shachaf> roconnor: What's the formal definition?
18:27:30 <edwardk> roconnor: got uniplate's fancy Data traversals working, so now 'every' can just walk right into Data
18:27:41 <scshunt> pqmodn: or something similar
18:27:56 <edwardk> and they are just traversals you can use like anything else that magically avoid walking parts of the structure that can't contain a given type
18:28:01 <scshunt> edwardk: maybe you know?
18:28:10 <scshunt> shachaf: No, I'm not explicitly tagging
18:28:16 <roconnor> shachaf: a functor isomorphic to (x |-> Sigma a:S. P a -> x)
18:28:17 <edwardk> scshunt: what are you trying to do?
18:28:36 <roconnor> shachaf: aka a sum of representable functors
18:28:47 <latro`a> I don't think using a category theory definition to refute an analogy is a very good argument
18:28:58 <latro`a> it would be if the objective was to make the analogy precise, but it isn't
18:29:43 <edwardk> your objective and roconnor's objectives may differ ;)
18:29:58 <roconnor> well catogory theorists don't use the word "container" prefering the term "dependent polynomial functor" or something like that.
18:30:32 <scshunt> edwardk: I want a series of operations and a logging mechanism, akin to the Writer monad
18:30:50 <latro`a> edwardk--in context it sounded like he was trying to make a point that the "container" analogy is fundamentally limited
18:30:55 <jkff> roconnor: can you explain more about that functor? Actually, what's S and P there?
18:31:11 <thirsteh> Can I do something like rs <- sFetchRow $ <- dbExec db  instead of stmt <- dbExec db; rs <- sFetchRow stmt?
18:31:15 <scshunt> edwardk: but my operations are all on a single state type, and I would be able to filter operations from the log based on what operations are performed on the state type without needing to plumb tagging through
18:31:21 <scshunt> *would like to be able
18:31:22 <jkff> (and this is how you get from logging to a dependent polynomial functor on #haskell)
18:31:26 <latro`a> thirsteh, that's >>=
18:31:27 <edwardk> scshunt: i used to have a whisper combinator in lens but i thought it was silly so i took it out, but thats the only thing i added that dealt with lenses and logs
18:31:35 <scshunt> whisper combinator?
18:31:37 <thirsteh> latro`a: oh, cool. Was wondering when I'd get to use that
18:31:44 <latro`a> well, something like >>=
18:31:44 <roconnor> jkff: they are parmeters that specify the container.  S is the type of shapes and P : S -> type gives the type of positions for each shape.
18:31:55 <joe9> need some advice on my data structures: is this good http://codepad.org/J2dZrb3o
18:31:57 <edwardk> scshunt: it was a joke, basically it was used to 'tell' part of the monoidal result ;)
18:32:03 <joe9> forget the syntax
18:32:06 <scshunt> edwardk: ah, hah
18:32:06 <latro`a> rs <- dbExec db >>= sFetchRow
18:32:09 <scshunt> hmm
18:32:10 <joe9> just the structure ofthe data structuers.
18:32:12 <thirsteh> latro`a: thanks!
18:32:12 <edwardk> it'd take mempty and then use the lens to update it
18:32:32 <scshunt> I don't know if this is strictly monadic since it wouldn't contain an arbitrary value though :/
18:32:43 <scshunt> although I suppose that there's no reason it couldn't
18:32:54 <scshunt> hmm
18:33:09 <jkff> roconnor: I'm terrified to say that but I understood this definition.
18:33:16 <scshunt> I think it would be a Tracking monad or something
18:33:29 <scshunt> which would just be... Writer with a special type
18:33:32 <scshunt> and a lifting function
18:33:33 <scshunt> hmm
18:33:35 <roconnor> jkff: for the list container take S = Nat and P = Fin : Nat -> Type.
18:33:58 <latro`a> thirsteh, I'd actually suggest =<< there, so that the information moves in one direction
18:34:09 <latro`a> rs <- sFetchRow =<< dbExec db
18:34:25 <jkff> joe9: Good for what?
18:35:09 <joe9> jkff: are those data representations reasonable? or, can I use type classes oslt to make them simpler?
18:35:23 <jkff> joe9: Reasonable for what? ;) Can you give more context?
18:35:46 <joe9> jkff: you are correct. I need to put something more down before I can ask for input.
18:35:55 <joe9> jkff: let me get something more together.
18:36:20 <scshunt> edwardk: I feel like there's something funky in the MTL somewhere that should cover this :P
18:36:45 <edwardk> scshunt: you can do a lot with the mtl and some custom combinators to hide the gunk ;)
18:37:06 <scshunt> edwardk: yeah, I'm just not sure what the best way is :)
18:37:38 <scshunt> edwardk: out of curiosity, why is WriterT called that? It isn't a transformer, is it?
18:37:39 <edwardk> try something. when it doesn't work, learn from that, and try something else.
18:37:47 <edwardk> WriterT is a transformer
18:38:07 <edwardk> it adds a monoidal 'log' to another Monad.
18:38:16 <edwardk> @src WriterT
18:38:17 <lambdabot> Source not found.
18:38:22 <edwardk> @source WriterT
18:38:22 <lambdabot> WriterT not available
18:38:25 <edwardk> blech
18:38:27 <scshunt> oh, hm
18:38:41 <scshunt> how would I use it with just plain functions?
18:38:45 <shachaf> What's "newtype Stream m a b = Stream { runStream :: m (Either b (a, Stream m a b)) }" called?
18:38:50 <edwardk> newtype WriterT w m a = WriterT { runWriterT :: m (a, w) }  -- or whatever
18:38:59 <edwardk> shachaf: CofreeT its in 'free'
18:39:10 <edwardk> er
18:39:11 <edwardk> sorry
18:39:16 <edwardk> Either, FreeT ;)
18:39:19 <scshunt> edwardk: e.g. what would I use as a vanilla Writer monad?
18:39:34 <shachaf> edwardk: Oh.
18:39:35 <edwardk> scshunt: (,) w     or Writer
18:39:40 <scshunt> edwardk: where is Writer?
18:39:58 <mk> what is the signature of State monadic functions?
18:39:59 <edwardk> scshunt: its a type alias provided along with the WriterT type in transformers
18:40:09 <scshunt> oh I get it
18:40:11 <scshunt> haha
18:40:13 <scshunt> I can read tonight
18:40:16 * scshunt should get sleep
18:40:20 <edwardk> scshunt: basically Writer w = WriterT w Identity
18:40:22 <latro`a> mk: you mean second args to >>=?
18:40:31 <latro`a> or State s a values?
18:40:42 <scshunt> edwardk: yeah I see it now
18:40:57 <mk> latro`a: the args, sorry
18:41:04 <latro`a> ...?
18:41:07 <latro`a> the first one or the second one
18:41:17 <edwardk> finally gave in and just named the old naive uniplate like traversal 'tinplate' for now
18:41:38 <pqmodn> :t (>>=) `asAppliedTo` State w a
18:41:39 <lambdabot> Not in scope: data constructor `State'
18:41:39 <shachaf> newtype FreeT f m a = FreeT {runFreeT :: m (Control.Monad.Trans.Free.FreeF f a (FreeT f m a))}
18:41:42 <mk> the one you referred to as args - so the first ;)
18:42:02 <edwardk> shachaf: FreeF is just a fancy Either a (f b)
18:42:05 <pqmodn> :t (>>=) `asAppliedTo` (\s -> (Int, s))
18:42:05 <lambdabot> Not in scope: data constructor `Int'
18:42:12 <pqmodn> :t (>>=) `asAppliedTo` (\s -> (10, s))
18:42:13 <lambdabot> forall b t t1. (Num t) => (t1 -> (t, t1)) -> ((t, t1) -> t1 -> b) -> t1 -> b
18:42:24 <shachaf> edwardk: Ah.
18:42:27 <edwardk> so that you can read the code that you wrote a month later
18:42:29 <jkff> :t asAppliedTo
18:42:30 <lambdabot> forall t b. (t -> b) -> t -> t -> b
18:42:40 <edwardk> otherwise you need to hold in your head what Left and Right meant
18:42:43 <jkff> heh
18:42:53 <latro`a> mk: OK, then they are a -> State s a
18:43:05 <latro`a> which is essentially a -> s -> (a,s), but not used as a two argument function really
18:43:14 <shachaf> Hey, it's jkff.
18:43:15 <latro`a> erm
18:43:17 <latro`a> woops
18:43:19 <latro`a> a -> State s b
18:43:23 <latro`a> and a -> s -> (b,s)
18:43:26 <jkff> shachaf: indeed it is
18:43:38 <mk> latro`a: is that some sort of alias? or?
18:43:43 <latro`a> is what an alias
18:43:56 <latro`a> State s a = s -> (a,s) is what you get when you go through the State type synonym
18:44:11 <mk> State s b in place of "a -> s -> (b,s)"
18:44:20 <latro`a> State s b replaces s->(b,s)
18:44:59 <mk> so like String = [Char]?
18:45:08 <edwardk> can't come up with a good tiny plate name, tapas is more about the food than the plates ;)
18:45:29 <latro`a> mk--less directly
18:45:40 <latro`a> State s = StateT s Identity (I think that's StateT's order)
18:45:42 <shachaf> edwardk: coaster?
18:45:55 <edwardk> clearly it should be 'bowl'
18:46:26 <edwardk> then i can set out to compare bowl with plate in the benchmarks suite
18:46:33 <latro`a> then StateT s m a = s -> m (a,s) (except this is actually a newtype, not a synonym)
18:46:53 <edwardk> since i'm already planning on adding a pan combinator. i think we have a full set of kitchenware
18:47:19 <jkff> edwardk: don't forget the kitchen sink too
18:47:29 <mk> latro`a: why isn't it defined as a->(s->(a,s))?
18:47:38 <edwardk> sinks are in the machines package, not lens ;)
18:47:46 <latro`a> mk: I was talking about the *second* argument to >>=
18:47:52 <latro`a> that is the Kleisli arrow
18:47:53 <jkff> mk: because state doesn't take "a" as an input
18:48:11 <latro`a> State's Kleisli arrows are basically two argument functions that leave one of the types fixed
18:48:27 <shachaf> @unmtl StateT s m a
18:48:27 <lambdabot> s -> m (a, s)
18:48:28 <mk> oops, I was looking at the uncorrected version. replace second a with b
18:48:41 <latro`a> same point applies
18:48:50 <otters> @unmtl RWST r w s m a
18:48:50 <lambdabot> r -> s -> m (a, s, w)
18:49:02 <latro`a> a -> s -> (b,s) are State's Kleisli arrows; s -> (b,s) are its values
18:49:37 <mk> define Kleisli arrow?
18:49:52 <latro`a> for a general monad m, a function of type a -> m b is a Kleisli arrow
18:50:51 <latro`a> they get called that because they form a category, whose composition operator is <=<
18:50:53 <mk> oh, so "monadic functions", or "those things which bind takes", and return is an arrow - right?
18:50:58 <latro`a> and whose identity is return
18:51:04 <latro`a> yes
18:51:17 <ahkurtz> why name something with more characters than it takes to just notate it?
18:51:31 <mk> what is the right way to refer to those?
18:51:36 <latro`a> to refer to what
18:51:42 <latro`a> functions of type a -> m b?
18:51:45 <latro`a> the correct term is Kleisli arrow
18:51:58 <mk> are there any other terms?
18:52:05 <flebron> Hi. If I have f: a -> Bool, g: a -> Bool, is there a notation for \x -> (f a && f b)?
18:52:12 <flebron> err, f x && g x.
18:52:21 <shachaf> flebron: You can say "liftA2 (&&) f g"
18:52:30 <flebron> Is that... idiomatic/pretty?
18:52:33 <shachaf> But not really beyond that.
18:52:50 <shachaf> Oh, you can say "all f [a,b]"
18:52:59 <shachaf> @ty all
18:53:00 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
18:53:15 <latro`a> flebron made a typo, and missed g in the last part
18:53:25 <shachaf> Oh, wait.
18:53:27 <latro`a> you do need liftA2 (or liftM2) or applicative style
18:53:33 <shachaf> What are a and b?
18:53:38 <shachaf> Oh, now I see.'
18:53:45 <shachaf> all ($x) [f,g]
18:53:50 <flebron> I typoed, corrected below :)
18:53:51 <latro`a> not really
18:53:59 <latro`a> oh wait
18:54:01 <latro`a> x is fixed
18:54:03 <latro`a> so yeah
18:54:07 <latro`a> all ($ x) [f,g]
18:54:17 <latro`a> ($ x) is a cute trick
18:54:18 <flebron> Haha, that too, yeah.
18:55:26 <latro`a> for that sort of thing in general, though, look up applicative functors
18:55:36 <mk> why is the definition a -> State s a  used instead of a -> s -> (a,s) ?
18:55:38 <shachaf> (and .: sequence) [f,g] 6
18:55:44 <shachaf> Er, s/6/x/
18:55:53 <shachaf> mk: Used for what?
18:55:54 <mk> in state's return?
18:55:56 <jkff> mk: to make it more obvious that this is a Kleisli arrow perhaps
18:56:06 <shachaf> mk: Because of the type.
18:56:13 <latro`a> mk: it's a newtype, makes it a different object
18:56:23 <shachaf> The type of return, that is.
18:56:58 <mk> if it's a newtype, then it can't be used as a function without some form of extraction?
18:57:06 <shachaf> Or do you mean why there isn't an instance Monad (Λa -> s -> (a,s))? :-)
18:57:09 <latro`a> directly, yes
18:57:11 <shachaf> mk: Right.
18:57:21 <latro`a> runStateT exists for this purpose
18:57:51 <latro`a> in "pretty" State code, you chain together a bunch of stateful *functions* and never see the state except at the end
18:57:57 <latro`a> (or beginning, depending on how you look at it)
18:58:22 <latro`a> in practice "get" shows up from time to time
18:58:30 <latro`a> and makes things a bit uglier (imo)
18:58:42 <shachaf> There's regular State code, and then there's State code that uses Control.Lens
18:59:04 <latro`a> haven't really learned about lenses yet, so not in a position to comment
18:59:17 <mk> I was confused by get. Can everything be done nicely without it?
18:59:23 <shachaf> latro`a: Just look at https://github.com/ekmett/lens/blob/master/examples/Pong.hs
18:59:32 <shachaf> mk: Everything can be done nicely without "State" at all.
18:59:42 <shachaf> But if you don't understand "get" you won't understand "State".
19:00:05 <mk> shachaf: why's that?
19:00:18 <latro`a> it's not that get is such an important State value (though it is)
19:00:26 <donri> is there an intention behind Sum and Product not being Num?
19:00:28 <latro`a> it's that it's really the simplest one other than "return x"
19:00:34 <shachaf> donri: Why would they be Num?
19:00:40 <shachaf> They're only there to be mappended.
19:00:48 <edwardk> mk: basically once you understand how get and put work with state you have characterized it, the rest follows from the monad laws ;)
19:01:01 <donri> shachaf: for literals
19:01:06 <edwardk> mk: so they are pretty key to understanding how and why we work with state this way
19:01:12 <shachaf> edwardk: All you need to understand is "state"! :-)
19:01:23 <edwardk> shachaf: =P
19:03:06 <latro`a> shachaf, I acn't easily even see where lenses get used here
19:03:08 <latro`a> *can't
19:03:12 <mk> why are get and put needed, if the initial state is fed into the resulting state mote (monadic value) using runState, and it's up to the ... monadic functions? Kleisli arrows? ...koats? to pull out and produce state?
19:03:17 <latro`a> I see the making, and then some operators that I can't see
19:03:34 <shachaf> latro`a: Everywhere!
19:03:41 <latro`a> um, no
19:03:42 <edwardk> latro`a: if the state you are carrying around has lenses that know how to access it then you can use a number of combinators to get at the state
19:03:46 <latro`a> like the firsthalf of the file never uses them
19:03:54 <edwardk> latro`a: e.g. in there ballSpeed.x .= 10
19:03:58 <latro`a> *first half
19:04:21 <edwardk> would be the composition of the ballSpeed lens with the x lens to get a lens that we're using to edit the current state, setting the target of that lens to 10
19:04:36 <latro`a> and the names of the operators don't really help with intuition either, for the most part
19:04:37 <edwardk> latro`a: that is a state action using 2 lenses and a lens combinator
19:04:43 <shachaf> edwardk: Except it's _x. The naming convention leaks. :-(
19:04:45 <latro`a> so no, I don't think this is really adequate for pedagogy, shachaf
19:04:52 <shachaf> latro`a: That file wasn't meant for pedagogy.
19:04:55 <edwardk> shachaf: _x was Nand's doing ;)
19:05:03 <latro`a> you were acting like you could just read this and understand
19:05:09 <shachaf> latro`a: See https://github.com/ekmett/lens/wiki/Tutorial
19:05:20 <edwardk> latro`a: https://github.com/ekmett/lens#lens-lenses-folds-and-traversals the README gives a number of examples
19:05:22 <Clint> what's regex-pcre-builtin all about?
19:05:33 <edwardk> it doesn't cover the (ab)use of lenses for state though
19:05:41 <latro`a> as I said, I haven't learned about lenses yet; wasn't saying that I wanted to do so now
19:05:50 <latro`a> I have plenty to learn about in the next few months already -_-
19:06:05 <jkff> Clint: The docs say "The PCRE backend to accompany regex-base, see www.pcre.org" :)
19:06:07 <latro`a> the lebesgue measure for one thing
19:06:20 * edwardk goes back to getting stuff done rather than try to push lens tutorials on someone who doesn't want them
19:06:30 <shachaf> latro`a: All I said was that lens-style State code looks pretty different from normal-style.
19:06:45 <latro`a> um
19:06:50 <latro`a> <shachaf> latro`a: Just look at https://github.com/ekmett/lens/blob/master/examples/Pong.hs
19:06:52 <shachaf> Anyway, never mind. :-)
19:06:58 <latro`a> doesn't suggest that at all :p
19:07:01 <jkff> Clint: http://hackage.haskell.org/packages/archive/regex-pcre-builtin/0.94.2.1.7.7/doc/html/Text-Regex-PCRE.html helps too
19:07:31 <edwardk> latro:   (u, v) <- use ballSpeed;   ballPos += (time * u, time * v)
19:07:41 <edwardk> those were the kinds of things i think he was expecting you to see
19:08:05 <edwardk>  keyPressed key = p^.keys.contains (SpecialKey key)
19:08:19 <latro`a> as I was saying, most of the names don't really mean much to me
19:08:32 <flebron> If I say putStr "k: ", how can I make that show up in console immediately without writing a newline?
19:08:45 <edwardk> its a pong game, it has a ball bouncing around and a couple of paddles
19:08:50 <Saizan> flebron: hFlush stdout
19:08:50 <jkff> flebron: hSetBuffering hStdout NoBuffering or something
19:09:05 <edwardk> and the combinators are pretty much what you'd expect coming from an imperative background
19:09:17 <latro`a> %=?
19:09:20 <latro`a> ^.?
19:09:21 <latro`a> etc.
19:09:21 <Clint> jkff: right, but that's what regex-pcre says too
19:09:26 <edwardk> ^. is field access
19:09:27 <latro`a> += ok fair enough
19:09:38 <latro`a> .~
19:09:38 <edwardk> %= is 'mod' equal, it lets you pass a function.
19:09:38 <latro`a> etc.
19:09:50 <edwardk> l += 2    is l %= (+ 2)
19:09:56 <latro`a> I'm sure all these combinators are great, but this file doesn't explain a damn thing :p
19:09:56 <shachaf> latro`a: All I meant was "look at how different-looking that code is".
19:10:00 <latro`a> mmk
19:10:16 <latro`a> given that I was saying "I don't know anything about lenses", I don't have a frame of reference to grasp what it is different from
19:10:27 <edwardk> latro`a: anyways the point has been beaten to death and clearly you don't care =P
19:10:39 <jkff> Clint: Indeed. I suggest to ask Chris
19:10:40 <shachaf> Yep.
19:10:42 <latro`a> I'm interested to learn, but not anytime soon
19:10:42 <latro`a> so
19:10:43 <latro`a> yeah
19:14:07 <JoeyA> Is there a way to get a test-suite program to print output?  With default verbosity, cabal hides stdout and stderr output (writing them to the log file instead).
19:14:32 <edwardk> JoeyA: there is a flag you can pass to cabal, but cabal deliberately hides your output ;)
19:14:43 <JoeyA> I want to print a warning, but not fail, if a system library lacks a feature.
19:14:53 <Clint> jkff: does he irc?
19:15:02 <donri> JoeyA: --show-details=always
19:15:07 <jkff> Clint: I don't know. But he definitely does answer emails.
19:15:08 <JoeyA> (the feature is detected a run-time)
19:15:23 <JoeyA> Can that be used in the .cabal file, or does the user have to say it?
19:15:41 <Clint> jkff: thanks
19:16:05 <donri> JoeyA: user. i usually write a makefile to wrap cabal for development
19:16:29 <JoeyA> :(
19:16:35 <JoeyA> I guess I'll just make the test fail.
19:16:53 <mk> so in order to write a function that works with state's bind, I have to create one that returns yet another function, which takes state and then returns the value, right?
19:18:02 <mgsloan> edwardk: (response far delayed) cool!!  I'd love to see generic mutation that does proper polymorphism stuff
19:18:14 <mk> (and this is just how two-argument functions look in haskell)
19:18:49 <edwardk> mgsloan: i upgraded the little 6 line data.data traversal with the smarts to avoid parts of the search space that can't contain the value. now i need to port that reasoning to GHC.Generics.Lens
19:18:52 <flebron> Is there a simple way of checking if a lists' elements are pairwise coprime?
19:18:56 <edwardk> then you can pick between them for your biplates, etc.
19:19:09 <flebron> filter coprime [x <- li, y <- li] won't work, x could be the same as y :(
19:19:17 <mk> what is put used for if I can just feed an initial state in using runState?
19:19:38 <flebron> err, s/filter/all/;
19:19:56 <mk> and what is get used for if the functions basically just accept the state as their second argument anyway?
19:20:11 <latro`a> mk--if you look at the definition of >>= you may get the point
19:20:27 <shachaf> mk: You never write those functions yourself.
19:20:59 <latro`a> eh
19:21:03 <latro`a> never is a slight stretch
19:21:06 <mgsloan> edwardk: awesome! so comparatively small performance overhead?
19:21:12 <edwardk> yeah
19:21:14 <latro`a> but yes, you don't tend to actually have a -> State s b values around
19:21:15 <shachaf> You are not meant to write those functions yourself.
19:21:21 <latro`a> they're lambdas most of the time
19:21:25 <edwardk> its basically the uniplate code upgraded to work as a Traversal
19:21:32 <shachaf> ahkurtz: ?
19:21:34 <shachaf> Er.
19:21:36 <latro`a> and lambdas that are hidden by do notation, too
19:21:38 <mk> what's the best way to look up source?
19:21:50 <latro`a> unfortunately there isn't any source for just State
19:21:57 <shachaf> latro`a: I meant that you never write "State (\s -> ...(a,s')...)"
19:22:13 <ahkurtz> shachaf: don't mind me. bad day.
19:22:21 <latro`a> you can read the source for StateT, and plug in Identity, or you can find a tutorial on just State
19:22:34 <latro`a> the latter is probably easier, as StateT has the other monad's >>= somewhat in the way
19:22:38 <shachaf> ahkurtz: Just mis-tabbed.
19:22:53 <latro`a> also shachaf, I'm not sure about that?
19:23:24 <shachaf> latro`a: Well, you actually do sometimes, yes.
19:23:29 <latro`a> I mean, State (or rather "state") brings ordinary functions into the monad so you can chain them
19:23:29 <shachaf> But that's not the point.
19:23:41 <Saizan> flebron: [(x,y) | (x:ys) <- tails li; y <- ys]
19:24:21 <tswett> Suppose I define a type as "data MyInt = MyInt {unMyInt :: Int}", and then include unMyInt in the module's export list.
19:24:50 <tswett> If another module imports mine, can they mutate values of type MyInt by saying stuff like "val {unMyInt = 5}"?
19:25:14 <shachaf> Yes.
19:25:27 * hackagebot hermit 0.1.1.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.1.1.0 (AndrewFarmer)
19:25:56 <tswett> Is there an easy way to make it not so, besides just renaming the record field and exporting a separately defined function?
19:26:37 <n00b6502> less need to control mutation with pure FP lanugage perhaps
19:26:56 <shachaf> tswett: Export a lens! :-)
19:27:00 <shachaf> tswett: Not really, as far as I know.
19:27:20 <shachaf> (A read-only lens, I mean.)
19:28:15 <Saizan> tswett, shachaf: actually i've just tested and if you export only the field you don't get to use the update syntax
19:28:37 <roconnor> Saizan: thank goodness
19:28:56 <tswett> The identity lens?  :)
19:29:20 <shachaf> Saizan: Oh, you have to export "Type(field)"?
19:29:27 <flebron> Oh, I could ask for (x:ys), x is coprime with everything in ys, and ys is pairwise coprime :)
19:29:53 <Saizan> oops, sorry, bad test, shachaf was right.
19:30:02 <flebron> pairwise_coprime (x:xs) = map (coprime x) ys && pairwise_coprime ys
19:30:06 * shachaf doesn't know what's going on anymore.
19:30:07 <edwardk> if i want unMyInt to be read only, i general just don't make it a field accessor, and instead actually write it as a function
19:30:15 <edwardk> unMyInt (MyInt i) = i
19:30:21 <edwardk> can't be used to change the contents
19:30:22 <flebron> err, all $ map (coprime x) ys, sorry.
19:30:24 <mk> latro`a: I'm looking at e.g. http://mvanier.livejournal.com/5406.html , about halfway through, and I still don't see how put and set are used/useful
19:30:27 * shachaf wonders why GHC defines a FastBool.
19:30:38 <flebron> or... all (coprime x) ys. :s
19:30:48 <Saizan> shachaf, roconnor, tswett: sorry for the confusion :)
19:31:24 <roconnor> oh noes
19:31:25 <tswett> edwardk: yeah, good idea.
19:31:25 <shachaf> Does FastBool in GHC actually make a difference?
19:31:30 <roconnor> oh well
19:32:01 <edwardk> shachaf: its a wrapped 0 or 1 right?
19:32:19 <edwardk> shachaf: that lets it unbox into another constructor
19:32:24 <shachaf> Yes, an Int#
19:32:41 <shachaf> Ah, hmm.
19:32:46 <edwardk> and  you can know its always evaluated if its an Int#, etc.
19:32:57 <shachaf> Does that not happen with a strict Bool?
19:33:02 <edwardk> no thunk to force, no pair of pipeline stalls
19:33:19 <edwardk> with a strict bool you can know its already preforced, you just have to muck around unmasking the tagbits
19:33:36 <edwardk> so nowadays? its not a huge win i'd bet
19:33:37 <shachaf> Does {-# UNPACK #-} not work on simple types like Bool?
19:33:43 <edwardk> but before tagbits it was probably huge
19:33:52 <edwardk> correct, Bool has two constructors.
19:34:03 <edwardk> so UNPACK punts
19:34:13 <thirsteh> just to make sure I understand correctly -- Haskell is pass-by-reference: if I pass a huge World type around I'm not making hundreds of copies of it, right?
19:34:38 <mk> what are state's get and put used for?
19:34:48 <shachaf> Is treating a strict, unpacked Bool as a 0-or-1 a valid optimization?
19:34:53 <latro`a> you use get to retrieve the state, so you can do arbitrary things with it
19:35:00 <latro`a> you use put to put arbitrary things in the state
19:35:03 <n00b6502> even if you mutate i imagine you're probably copying one structure and it has lots of references to unmodified originals
19:35:14 <shachaf> thirsteh: Yes, it's pretty much always copying pointers.
19:35:19 <thirsteh> great, thanks
19:35:20 <shachaf> n00b6502: "mutate"? What's that?
19:35:34 <n00b6502> object{ member=... } :)
19:35:45 <shachaf> That's not mutation.
19:36:06 <n00b6502> returning a mutated copy
19:36:12 <mk> latro`a: don't the Kleisli functions simply accept state as their second argument, and spit the next state out in a pair along with the resultant value? Why would I ever need to put and set?
19:36:26 <shachaf> Ah, if you have Foo {x :: A, y :: B}, foo{x=newX} will just copy a pointer, yes.
19:36:37 <shachaf> But that's not mutation.
19:37:00 <latro`a> mk, the way they're used isn't the same, try looking at some code where State is used
19:37:03 <n00b6502> you'd use it where you'd have used mutation in imperative, if i''ve understood..
19:37:05 <latro`a> you could also look at some code where Rand is used
19:37:27 <shachaf> n00b6502: Not really. It's a completely different thing.
19:37:28 <latro`a> n00b6502, somewhat; you're never really changing the variable, only passing around a different version
19:37:44 <mk> latro`a: where can I find such code?
19:37:52 <n00b6502> well whats the syntax for? its a close to mutation as you can get
19:38:05 <latro`a> saves you having to write out all the fields you don't change
19:38:06 <latro`a> that's all
19:38:15 <shachaf> n00b6502: Is the function (+1) mutation?
19:38:24 <latro`a> but other than that it's no different from any other function
19:38:40 <n00b6502> you might eeven hope a runtime could figure out where object{newvalue=....} could be done inplace
19:38:59 <latro`a> also, how do you do a State computation up until a certain condition is met
19:39:03 <shachaf> That has nothing to do with mutation.
19:39:12 <latro`a> lemme write a nontrivial example I guess
19:39:14 <shachaf> I mean, other than the implementation.
19:39:29 <n00b6502> well..  its something that you would hope could be implemented by the compiler and runtime as mutation, in some situations
19:39:30 <tswett> It's kinda mutation-like.
19:39:47 <latro`a> ‎I guess in this one case I could just use Exit
19:39:49 <latro`a> but that's pretty ugly
19:40:22 <latro`a> also, I seem to be banned from hpaste or something
19:40:28 <startling> n00b6502: yeah maybe sometimes
19:40:33 <latro`a> "limit exceeded for non-superusers" has been popping up for a number of hours
19:40:40 <latro`a> haven't tried for several hours
19:40:45 <latro`a> but just tried again and yeah
19:41:15 <startling> latro`a: you need a break from haskell
19:41:31 <latro`a> eh, didn't have anything to do this evening
19:42:51 <Twisol> There's always gist
19:43:01 <latro`a> or I can pastebin and mauke's bot will do magic
19:43:30 <latro`a> http://pastebin.com/dMqkqrQV
19:43:35 <latro`a> or...not?
19:44:21 <latro`a> bah, meant endGame board'
19:44:25 <Twisol> Kinda bugs me that Prelude.(.) isn't Data.Category.(.) :(
19:44:42 <Twisol> *Control.Category
19:44:52 <latro`a> anyway, askCycle can return one of its arguments, and if it returns endGame I'd like the recursion to stop
19:46:05 <latro`a> oh wait nvm
19:46:16 <n00b6502> lenses can do things like += ? (return a copy with operate on struct member?)
19:46:35 <n00b6502> c +=
19:46:38 <shachaf> n00b6502: Yes, but as a recovering C++ programmer, you shouldn't look at lenses yet.
19:47:27 <n00b6502> how does one do that :)
19:47:50 <shachaf> c += most likely doesn't do what you think.
19:48:26 <n00b6502> i was just qualifying that i meant C's +=
19:48:34 <shachaf> Oh.
19:48:39 <n00b6502> does haskell actually have a += operator for something else :)
19:48:43 <shachaf> There's a lens state operator called "+=", yes.
19:48:51 <shachaf> It looks like it does what you think, too.
19:49:12 <n00b6502> does it return a copy with an element incrremented
19:49:20 <n00b6502> or is it something completely different
19:49:22 <edwardk> ballSpeed.x *= speedMultiplier    works
19:49:41 <edwardk> n00b6502: basically the lens version is to use +~ that does what you expect there
19:50:08 <edwardk> _1 +~ 10 $ (5, "hello")      ==> (15, "hello")
19:50:13 <edwardk> yields a new copy
19:50:26 <n00b6502> shachaf is probably right that i have more elsewhere to learn in haskell before i use lenses, but this is still interesting
19:50:34 <edwardk> the += version of those lens operations works on the state in the state monad, which is plumbed around for you
19:51:18 <edwardk> so you can just write ballSpeed.x += 10 and that updates state, using the same technique as +~, without you having to explicitly pass it around
19:51:39 <n00b6502> ah in the do blocks
19:51:43 <edwardk> yep
19:51:44 <n00b6502> or >>=
19:51:46 <n00b6502> >>
19:51:57 <edwardk> +=, etc are designed so they work with state monads
19:52:22 <Twisol> edwardk: What is that _1 you used?
19:52:39 <edwardk> Twisol: _2 f (a,b) = (,) a <$> f b
19:52:47 <aristid> oO looks like hpaste.org is down?
19:52:50 <thirsteh> I'm importing module Bar from module Foo, and trying to use value constructor Bar.Baz, but I keep getting "Not in scope: data constructor `Baz'" What gives?
19:52:54 <n00b6502> is that an alias for fst , or something like _1'th element of N-element tuple
19:53:00 <thirsteh> data constructor*
19:53:10 <edwardk> _1 f (a,b) = (\a' -> (a',b)) <$> f a
19:53:32 <latro`a> how did you import Bar, and does it export Baz?
19:53:36 <aristid> bos: whois indicates you run hpaste.org. it seems to be down. GeneralError "Chunk \"SFATAL\\NULC53300\\NULMconnection limit exceeded for non-superusers\\NULFpostinit.c\\NULL637\\NULRInitPostgres\\NUL\\NUL\" Empty"
19:53:39 <Twisol> edwardk: So… like fst and snd over applicatives?
19:53:50 <edwardk> Twisol: its in Control.Lens.Type in 'lens'
19:53:55 <thirsteh> latro`a: tried import Bar and import Bar(Baz), Bar is module Bar (Baz) where ...
19:54:01 <edwardk> Twisol: yeah, though its more general, as it works over larger tuples as well
19:54:11 <shachaf> I don't think bos runs hpaste.org
19:54:12 <thirsteh> latro`a: maybe it's Cabal, I didn't add it to the cabal file
19:54:15 <Twisol> edwardk: Interesting! I will be giving that a look.
19:54:15 <edwardk> you can use _4 on a 8 tuple, etc.
19:54:34 <shachaf> I think chrisdone does.
19:54:40 <n00b6502> > (_1 (+~ 10) (5,"hello))
19:54:41 <lambdabot>   <no location info>:
19:54:41 <lambdabot>      lexical error in string/character literal at end o...
19:54:50 <latro`a> http://pastebin.com/cRRpv0AW <- bah, so much lift, put, get
19:54:51 <edwardk> n00b6502: lambdabot doesn't know about lenses
19:54:53 <n00b6502> > (_1 (+~ 10) (5,"hello"))
19:54:54 <lambdabot>   Not in scope: `_1'Not in scope: `+~'
19:54:57 <thirsteh> latro`a: oh, that must be the "other-modules" in cabal
19:54:59 <n00b6502> ok
19:55:20 <edwardk> also the parenthesization would be (_1 +~ 10) (5, "hello")
19:55:27 * hackagebot statistics 0.10.2.0 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.10.2.0 (BryanOSullivan)
19:55:50 <n00b6502> hah that's what i was trying to check
19:56:08 <edwardk> n00b6502: basically _1 is a lot like fst, but its designed to both read and write from that location
19:56:31 <edwardk> ("hello","world")^._1    works like fst ("hello","world")
19:56:37 <edwardk> but it can be used to write back with other combinators
19:58:20 <Twisol> I'm pretty sure the answer to this is "yes", but I want to ask anyway: Is there a certain point in one's Haskell career where it becomes second-nature to think in terms of Haskell?
19:58:39 <edwardk> Twisol: yes =)
19:58:43 <shachaf> Twisol: How long have you been using Haskell?
19:58:53 <Twisol> I "get" things conceptually, but it's still really hard to actually apply them. ^_^;
19:59:04 <pharaun> is there a good hashing library? i'm wanting to look at one for clues on how to implement a hash
19:59:22 <Twisol> shachaf: Maybe a few months since I was exposed to it. Not very long in terms of actual time writing code.
19:59:23 <shachaf> Why do you want a hash?
19:59:31 <edwardk> pharaun: 'hashable' provides you with a simple quick hash function for containers, etc. but its not cryptographically strong
19:59:38 <pharaun> shachaf: i'm writing ed2k hash for a project
19:59:54 <Twisol> shachaf: lets say 6 months since I started learning
19:59:57 <edwardk> there is a Crypto package that has some stronger stuff
20:00:05 <shachaf> Looks like ed2k is based on MD4.
20:00:21 <shachaf> MD4 is hardly cryptographically strong. :-)
20:00:24 <pharaun> and i had to implement it for a previous project not in haskell and i doubt that there would be a ed2k module so i was wanting to have some hints to look at so i can check out how to construct a hashing library/module in an useful manner
20:00:27 <shachaf> But maybe it doesn't matter for their use.
20:00:30 <pharaun> shachaf: yeah i'm aware
20:00:47 <shachaf> Twisol: OK. It happens on the 7th month. Look out for it!
20:00:52 <Twisol> shachaf: XD
20:00:57 <pharaun> i don't control the remote end, i need to be able to provide ed2k hash for file identification
20:01:06 <shachaf> pharaun: Right.
20:01:16 <shachaf> Well, there's http://hackage.haskell.org/packages/archive/cryptohash/0.7.5/doc/html/Crypto-Hash-MD4.html
20:01:36 <pharaun> hmm
20:01:44 <edwardk> pharaun: basically you're going to have to implement the feistel structure by hand using something like Data.Bits, etc.
20:01:50 <pharaun> the api seems reasonable, i'll dig into how they do the implementation
20:02:12 <shachaf> Can't you just use the API?
20:02:22 <shachaf> The ed2k algorithm looks pretty simple from the description on Wikipedia.
20:02:38 <pharaun> shachaf: yeah i probably will use the md4 part out of that but i was wondering how i should design *my* hashing api for the ed2k hash :)
20:03:03 <shachaf> Ah.
20:03:35 <edwardk> pharaun: take a closer look at cryptohash and Crypto
20:03:40 <edwardk> and copy the parts you like
20:03:49 <pharaun> edwardk: k
20:04:58 <pharaun> edwardk: ah nice :) thanks
20:05:02 <pharaun> shachaf: edwardk thanks you two
20:05:23 * shachaf doesn't really like all the cryptography packages on Hackage that reimplement ciphers in pure Haskell rather than binding to a library.
20:05:44 <shachaf> Not that it matters much for hashes, presumably.
20:05:54 <pharaun> thankfully i won't need to deal with much if any crytography (api supports encryption) but meh
20:06:06 <pharaun> its optional so i'll probably refrain for the time being anyway
20:06:30 <pharaun> shachaf: yeah for hashing, i mean for crypto-secure hashing it could matter but for a simple file hash *shrugs*
20:06:47 <shachaf> I didn't know ed2k still existed.
20:06:57 <pharaun> i was surprised when i was reading up on the spec
20:07:00 <bos> edwardk: you sent me a lambdabot pm months ago about some statistical thingy
20:07:08 <edwardk> bos: order-statistics
20:07:08 <edwardk> ?
20:07:13 <edwardk> or something deeper
20:07:13 <bos> lambdabot is almost the worst way to get in touch with me
20:07:19 <bos> i think it was that
20:07:19 <edwardk> hah
20:07:52 <edwardk> i think you guys stole my beta distribution i should check to make sure i can still compile if you shipped that when i saw statistics ding by a little while ago
20:08:15 <pharaun> shachaf: but i don't really mind *too* much cos it looks fairly straightforward to implement anyway :)
20:08:45 <edwardk> (stole as in i gave it freely)
20:09:44 * aristid really wants to read this hpaste *grml*
20:09:55 <edwardk> with luck i can just drop Statistics.Distribution.Beta from order-statistics and turn on using yours and I should be all set.
20:10:28 <edwardk> I remember there was one issue i started to raise with how you can't use improper priors with 'statistics'
20:10:39 <edwardk> but i don't remember if a resolution was ever reached
20:10:48 <shachaf> Is it GHC policy not to use Hackage libraries for writing the compiler?
20:10:54 <shachaf> And not to use crazy extensions or something?
20:11:00 <aristid> or am i the only one who can't access hpaste?
20:11:08 <shachaf> aristid: No, it's down.
20:11:51 <letrec> I'm trying to access a DB. I've got this Conn object using to connect. Trying to write a function Conn -> Integer -> (Conn -> a -> IO b) -> a -> IO (Maybe b) that will retry a given number of times (if there are exceptions) and then give up. Any pointers?
20:13:11 <aristid> shachaf: am i also right in my assumption who runs it?
20:13:47 <shachaf> aristid: bos? No, it's not bos. It's chrisdone.
20:13:55 <aristid> shachaf: oh.
20:14:16 <aristid> shachaf: well, it _is_ in the whois record :)
20:14:30 <shachaf> aristid: It's bos's domain.
20:15:14 <aristid> shachaf: too bad chrisdone doesn't really come to irc anymore. also i believe he's in europe. i am too, but it's sleeping time now. so no hpaste now for me
20:16:40 <shachaf> GHC has some strange code.
20:16:50 <shachaf> I guess a lot of it is just old.
20:17:05 <shachaf> Pre-H98 old.
20:17:47 <Cale> Does it still have code in it with monads that are not an instance of Monad?
20:18:08 <shachaf> I'm not sure -- which ones do you mean?
20:18:41 <shachaf> It has a lot of exciting monads.
20:18:47 <shachaf> Like data MaybeErr err val = Succeeded val | Failed err
20:18:48 <luite> aristid: actually he does, he's in #fay often
20:18:52 <Cale> I mean where someone has defined a separate unitM and thenM or bindM or something, rather than using the Monad class.
20:19:05 <Cale> (because the code was written before the Monad class existed)
20:19:08 <shachaf> Oh, for each instance?
20:19:11 <Cale> yeah
20:19:12 <shachaf> I haven't seen that.
20:19:25 <aristid> luite: oh. i think he wrote that he doesn't frequent irc much anymore. so maybe that statement was not accurate.
20:19:30 <Cale> Maybe someone cleaned it up, at least a few years ago it did :)
20:19:36 <shachaf> aristid: His whois is online.
20:19:45 <shachaf> Do people just not change old code?
20:19:47 <luite> aristid: well he only started f ay recently :)
20:19:52 <shachaf> Reading GHC code I keep getting the urge to change things.
20:20:18 <aristid> shachaf: yeah, but a lot of people (including yours truly) are on irc via an always-on server :)
20:20:25 <shachaf> Sure.
20:20:34 <edwardk> every time i spend a prolonged period reading ghc internals i get a strong itch to work in thc some more ;)
20:20:43 <aristid> edwardk: what's thc?
20:21:01 <edwardk> aristid: a little 'turbo haskell' compiler i keep playing with partially as a joke
20:21:07 <aristid> apart from being a terrible name for google
20:21:13 <donri> tetrahydrocannabinol
20:21:14 <shachaf> aristid: A popular form of recreational chemistry.
20:21:18 <Twisol> Ala turbo pascal?
20:21:22 <edwardk> Twisol: yeah
20:21:25 <Twisol> :D
20:21:33 <shachaf> edwardk: You should make that compiler work!
20:21:43 <edwardk> Twisol: same basic goals, dumbest thing that can possibly generate code, then tricks to make it fast ;)
20:21:43 * latro`a compiles marijuana from source
20:21:44 <shachaf> And the type slices thing.
20:21:44 <aristid> shachaf: are you suggesting edwardk uses drugs? :P
20:21:52 <latro`a> but to compile marijuana from source, you must first create the universe!
20:21:58 * latro`a compiles the universe
20:22:05 <edwardk> shachaf: yeah the type slices are something i need to finish figuring out
20:22:26 <edwardk> aristid: i barely even touch alcohol =P
20:22:34 <shachaf> edwardk: Is any of the code for any of those things out?
20:22:59 <aristid> edwardk: well i heard there are people who use marijuana but no alcohol. but whatever :D
20:23:10 <edwardk> shachaf: not really. i've got about two dozen 'thc' folders on my hard drive with different stabs at a design
20:23:17 <shachaf> edwardk: You should call it THE. "THE Haskell Environment"
20:23:20 <shachaf> edwardk: Hah.
20:23:31 <aristid> shachaf: but it's a compiler, not an environment.
20:23:32 <latro`a> oh fuck the recursion
20:23:48 <shachaf> latro`a: What recursion?
20:23:54 <latro`a> THE expands again
20:23:59 <shachaf> That's just saying it's THE environment for Haskell.
20:24:04 <edwardk> shachaf: =)
20:24:06 <latro`a> except it isn't, which is the joke
20:24:11 <latro`a> erm
20:24:15 <latro`a> except it can also expand, which is the joke
20:24:25 <shachaf> It's not a joke when you say it. :-(
20:24:28 <latro`a> :(
20:24:31 <aristid> edwardk: folders? you're supposed to use feature branches!</kool aid>
20:24:52 <shachaf> edwardk: The world needs more Haskell compilers!
20:25:08 <edwardk> aristid: most of them are little git repos, they are just unrelated to one another
20:25:22 <aristid> shachaf: another serious haskell compiler would be nice indeed, but that isn't really in sight i think :)
20:25:23 <edwardk> until i have some semblance of an idea how its going to fit together thats how i tend to work
20:25:45 <edwardk> most of my efforts towards thc wound up turning into the ermine compiler at work
20:25:59 <donri> edwardk: git checkout --orphan
20:26:09 <aristid> so ermine is the name of your internal language
20:26:21 <edwardk> it has polykinds, etc with the same general model i was looking to use in thc
20:26:25 <edwardk> yeah
20:26:46 <edwardk> we finally picked the name a couple months back
20:27:17 <Twisol> Good choice
20:27:28 <edwardk> came replete with a cute mascot
20:29:11 <aristid> so the logo looks like this? ;) http://en.wikipedia.org/wiki/File:COA_fr_BRE.svg
20:29:43 <edwardk> heh, right now it looks more like http://www.retrojunkie.com/asciiart/animals/weasels.htm
20:31:35 <letrec> Any better way to write do { r<- g a b; return $ Just r } ?
20:31:52 <edwardk> Just <$> g a b
20:32:09 <edwardk> assuming you can allow an extra Functor constraint for your Monad
20:32:15 <edwardk> liftM Just (g a b) otherwise
20:32:20 <edwardk> or Just `liftM` g a b
20:32:24 <aristid> or even Just `liftM` g a b
20:32:32 <shachaf> @ty even Just
20:32:33 <lambdabot>     No instance for (Integral (a -> Maybe a))
20:32:33 <lambdabot>       arising from a use of `even' at <interactive>:1:0-8
20:32:33 <lambdabot>     Possible fix:
20:32:43 <aristid> shachaf: you!!
20:32:52 <letrec> Where is <$> defined?
20:32:57 <shachaf> Control.Applicative
20:32:59 <edwardk> Data.Functor or Control.Applicative
20:33:00 <shachaf> @hoogle <$>
20:33:00 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
20:33:00 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
20:33:02 <latro`a> it's just fmap
20:33:03 <edwardk> either import it
20:33:04 <latro`a> but infix
20:35:02 <aristid> @index liftM
20:35:02 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
20:35:16 <aristid> all those modules reexport it? oO
20:35:21 <edwardk> aristid: yeah
20:35:27 <aristid> why?
20:35:32 <edwardk> Control.Monad gets re-exported all over the place
20:35:39 <edwardk> because MonadPlus, etc aren't in the Prelude
20:36:10 <edwardk> also it was an early design, peope hadn't gotten used to importing lots of modules yet
20:36:28 <aristid> right, but that's no reason to re-export it in a semi-related module. liftM does not belong in Control.Monad.Reader IMHO, so it should be re-exported from there
20:36:28 <Cale> I still think it kinda sucks to have to have a lot of import lines
20:36:44 <aristid> edwardk: ah, so it's mostly historical
20:36:53 <aristid> Cale: sure, but this is not the right solution :)
20:36:55 <edwardk> i'm not likely to remove those re-exports from the mtl at this point ;)
20:37:12 <aristid> edwardk: of course not, that would break compatibility for little gain
20:37:13 <tswett> So, uh, I think that implementing Lua in Haskell is going to involve creating a Lua monad, composed of ContT, EitherT, two instances of ReaderT, and ST.
20:37:16 <tswett> :(
20:37:49 <aristid> edwardk: but i can talk about what is right and wrong all day long without any repercussions in terms of broken compatibility
20:37:55 <edwardk> tswett: in my experience implementing a compiler in haskell involves working with several different monads over the course of compilation
20:38:21 <tswett> This is going to be an interpreter.
20:38:24 <latro`a> "in my experience [with] implementing a compiler in haskell" is kinda terrifying >.<
20:38:24 <edwardk> and there is no need to make two readerT's, just tuple them up
20:38:40 <edwardk> tswett: an interpreter is just a compiler that doesn't know when to stop ;)
20:38:45 <tswett> That only works if the ReaderTs would be consecutive.
20:38:54 <Cale> latro`a: ?
20:39:00 <latro`a> idk
20:39:21 <aristid> tswett: it also works if there is State and Writer in between. because you can shuffle those around, i think. also, there's RWS
20:39:22 <latro`a> I feel like that would be rather difficult, albeit probably less difficult than some other choices
20:39:55 <edwardk> tswett: reader should commute over any other monad pretty safely
20:39:57 <Cale> Implementing a compiler in Haskell?
20:40:26 <tswett> Anyway, now I just have to figure out what order the ContT, EitherT, and ReaderTs need to come in.
20:40:28 <Cale> Haskell's a very nice language in which to implement a compiler.
20:40:47 <aristid> so it turns out, ermines do _not_ suck blood.
20:41:00 <Nafai> It feels like it would be so different than implementing a compiler in C
20:41:10 <edwardk> tswett: don't pick everything a priori, just start using MonadState, etc. constraints on individual methods as you build things up
20:41:12 <aristid> tswett: are you really sure you need a ContT?
20:41:27 <tswett> aristid: do you have any better ideas for how to implement coroutines?
20:41:27 <Cale> Implementing a compiler in C, now that's scary :)
20:41:35 <edwardk> tswett: by the time you have that you'll have a pretty good idea of what you actually need and if you need backtracking on state, etc.
20:41:49 <tswett> edwardk: hm.  Yeah, that sounds like a good idea.
20:41:58 <Nafai> Cale: Yeah, did that in college.
20:42:09 <edwardk> i rarely have an idea of what monad will be running all of my code in the end when i set out
20:42:13 <mgsloan> A cute animated lambda pops up and says "It looks like you're implementing a compiler in Haskell!  There's a wizard for that" followed by SPJ's phone number
20:42:20 <aristid> tswett: the monad reader 19 has a nice chapter on coroutines :)
20:42:22 <edwardk> well i have ideas, but they are almost always wrong ;)
20:42:48 <edwardk> coroutines are just free monads of the indexed store comonad obviously
20:42:58 <Twisol> "obviously"
20:43:04 <edwardk> =)
20:43:11 <aristid> edwardk: that's what the article says, without mentioning indexed store comonads obviously.
20:43:18 <mgsloan> this terminology is getting pretty codense
20:43:20 <edwardk> aristid: as it should
20:44:07 <randomclown> @pl (replicateM 2 (genTree h' v)) >>= \(a:b:[]) -> return (Nand a b)
20:44:07 <lambdabot> (line 1, column 41):
20:44:07 <lambdabot> unexpected "["
20:44:07 <lambdabot> expecting "()", natural, identifier, "_" or "("
20:44:08 <edwardk> in all seriousness that is how we implement them here
20:44:09 <tswett> We don't have indexed stores around here; can I use the gas station comonad instead?
20:44:14 <aristid> edwardk: do you think the current design of pipes was influenced by that article, or does the causality flow another way?
20:44:27 <tswett> So, uh, what *is* the indexed store comonad?
20:44:33 <donri> aristid: it says so in the docs it was
20:44:48 <aristid> oh, fair enough
20:44:49 <Cale> tswett: "Probably just what it sounds like"
20:45:01 <donri> "The Pipe type is strongly inspired by Mario Blazevic's Coroutine type in his concurrency article from Issue 19 of The Monad Reader and is formulated in the exact same way. "
20:45:05 <edwardk> tswett: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal.hs#L153
20:45:27 <aristid> donri: nice
20:46:18 <Cale> That's an interesting application of type equality constraints.
20:46:22 <Twisol> I like how pipes uses both monad and category. Really makes the concepts clearer in a way.
20:46:32 <edwardk> cale: works well
20:46:44 <tswett> data Context c d a = Context (d -> a) c
20:46:49 <tswett> I can't understand that code.  It's too simple.
20:47:05 <Twisol> tswett: I agree
20:47:09 <Cale> tswett: pay attention to the (c ~ d) on the Comonad instance
20:47:17 <edwardk> cale: i do something similar in machines: https://github.com/ekmett/machines/blob/master/src/Data/Machine/Is.hs
20:47:31 <tswett> What does the ~ mean?
20:47:39 <Twisol> it sometimes really, really annoys me how a complex thing ends up being insanely simple in Haskell
20:47:39 <edwardk> tswett: data Store s a = Store (s -> a) s -- is easier to understand
20:47:46 <Cale> tswett: that the types are equal
20:47:49 <Twisol> because I can't intuit what that simple thing is yet
20:47:56 <tswett> Ah.
20:48:11 <Twisol> Cale: What's the difference between that and just using the same letter?
20:48:26 <edwardk> Twisol: if i use the same letter then i have a flexible instance
20:48:34 <Cale> Twisol: The Context datatype could still be used at other types, you'd just lose the instance
20:48:40 <edwardk> the flexible instance means that ghc might have less specific instance lying around as well
20:48:53 <Cale> (you'd still have a Functor instance, you just don't get Comonad unless the types match)
20:48:55 <edwardk> e.g. i might have instance Comonad (Context c c) but also instance Comonad (Context c d)
20:49:06 <aristid> and this way you can all competing instances?
20:49:08 <edwardk> the latter is bad because its hard to get to fire right
20:49:13 <aristid> +eliminate
20:49:15 <tswett> Whelp, good news.  I can get rid of one of the ReaderTs.
20:49:23 <Twisol> Ah. Okay. :S
20:49:31 <tswett> You don't actually have to tell a function what the global table is.  Functions simply know that.
20:49:44 <edwardk> with the abuse of (~) in there, once the compiler figures out that it is a Store and it needs a Comonad, it is forced to know that c must equal d
20:50:03 <edwardk> the 'instance Comonad (Context c c) doesn't force c = d, it just says, if they are equal then the comonad is here
20:50:15 <edwardk> but if they are unequal i can't rule out that there might be another different comonad.
20:50:20 <Twisol> So it re-orders the logical considerations the compiler has to make?
20:50:26 <edwardk> yes
20:50:32 <Twisol> Then I get it!
20:50:44 <edwardk> it means i can't write instance Comonad (Context Bar Foo) later
20:51:00 <edwardk> but i don't want that anyways!
20:51:00 <edwardk> so its a net good here, it helps type inference along
20:51:14 <edwardk> i used something even more sinister to make ghclive able to gracefully infer types for diagram
20:51:16 <edwardk> er diagrams
20:51:48 <edwardk> it has a instance (a ~ R2, b ~ SVG, c ~ All) => Display (QDiagram a b c) where ...
20:51:59 <edwardk> so once it knows it has a diagram it forces the other parameters on it
20:52:05 <tswett> data LuaTable s u = LuaTable (Maybe (LuaTable s u)) (STRef s (Map (LuaVal s u) (LuaVal s u))) -- simple, right?
20:52:06 <letrec> Similar question: any better way to write do { r<- g a b; return $ (a, Just r) } ?
20:52:24 <letrec> In the IO monad
20:52:45 <Cale> letrec: you can get rid of the $
20:52:45 <edwardk> letrec: (,) a . Just <$> g a b
20:53:52 <edwardk> of course that hack is piled on another hack that makes it so we can get defaulting in the first place.
20:54:04 <tswett> letrec: what edwardk is trying to say is, "no".  :)
20:54:19 <edwardk> cale: found it: https://github.com/ekmett/machines/blob/master/src/Data/Machine/Is.hs#L33
20:54:29 <tswett> Though I'm tempted...
20:54:37 <tswett> $pl \a -> (,) a . Just <$> g a b
20:54:42 <tswett> @pl \a -> (,) a . Just <$> g a b
20:54:42 <lambdabot> ap ((<$>) . (. Just) . (,)) (flip g b)
20:54:51 <aristid> tswett: no.
20:55:38 <letrec> tswett: edwardk : thanks :)
20:56:13 <Cale> I like the Category instance for Is
20:56:34 <aristid> edwardk: so that's the same Monoid as for () on the propositional equality type?
20:56:47 <edwardk> aristid: yeah
20:56:49 <edwardk> Cale: =)
20:57:25 <aristid> the (.) there is transitivity?
20:57:29 <Cale> yes
20:57:32 <aristid> cool
20:58:14 <edwardk> Cale: i still prefer the leibnizian equality, its more fun to write
20:58:25 <aristid> what's the type of that?
20:58:39 <edwardk> https://github.com/ekmett/eq/blob/master/Data/Eq/Type.hs#L62
20:58:47 <edwardk> see the a := b type above
20:59:10 <aristid> oh
20:59:43 <edwardk> (b := c) -> (a := b) -> a := c      -- so subst is using the first equality to change the type of the second equality from a := b to a := c
21:00:30 <Cale> very nice :)
21:00:30 * hackagebot blaze-textual 0.2.0.7 - Fast rendering of common datatypes  http://hackage.haskell.org/package/blaze-textual-0.2.0.7 (BryanOSullivan)
21:00:32 <edwardk> this is cheaper when it is repeatedly applied than chaining the functions
21:02:08 <edwardk> https://github.com/scalaz/scalaz/blob/master/core/src/main/scala/scalaz/Leibniz.scala is the master class version of that that i wrote for scalaz, which goes along with liskov substitutability: https://github.com/scalaz/scalaz/blob/master/core/src/main/scala/scalaz/Liskov.scala
21:02:50 <aristid> the haskell code looks much nicer :P
21:02:55 <edwardk> definitely
21:03:12 <Cale> wow α looks weird in the typeface used on github
21:03:20 <edwardk> yeah
21:04:11 <aristid> edwardk: that coerce function is cool
21:04:28 <edwardk> take an indentity function and change its type =)
21:04:28 <bos> you know, there's nothing i love better than fixing trivial build breakage in 25 packages every time a new GHC release comes out.
21:04:32 <edwardk> er identity
21:05:01 <edwardk> bos: i feel your pain
21:05:12 <aristid> bos: is that related to that one long thread on haskell-cafe about upper version limits?
21:05:21 <bos> aristid: yes
21:05:38 <bos> edwardk: you've kind of got a worse problem, since you've got 100 packages each containing a single file :)
21:06:01 <edwardk> bos: no, you have me confused with snoyman. mine at least contain 3-4 ;)
21:06:16 <pharaun> haha
21:06:22 <edwardk> some over 100 sadly
21:06:28 <pharaun> edwardk: 100 files?
21:06:32 <edwardk> yeah
21:06:45 <aristid> and that's not category-extras?
21:07:09 <edwardk> aristid: correct. trifecta is pretty big, was ~60 modules or so before i started reeling it back in and downscoping
21:07:23 <edwardk> lens is getting massive
21:08:19 <Cale> category-extras is empty now, isn't it? :)
21:08:29 <edwardk> cale: yeah.
21:08:41 <aristid> well, it _used_ to be huge:)
21:08:46 <edwardk> kind of wish i hadn't bothered breaking it up
21:09:11 <pharaun> why?
21:09:13 <edwardk> the same people who clamored about breaking it up so they could use parts of it didn't bother to use many parts of it ;)
21:09:16 <aristid> i guess a large fraction of the lens stuff is much more practical than most of the category-extras modules :>
21:09:25 <pharaun> heh
21:09:41 <Cale> edwardk: Make an edwardk package and just put all your stuff in it.
21:09:49 <roconnor> edwardk: I just wanted comonad :P
21:09:51 <edwardk> i don't mind having a strong haskell 98 core to my libraries now. that part worked out really well
21:10:13 <aristid> roconnor: and you got it
21:10:16 <pharaun> edwardk: cos that helps avoid GHC breakage on upgrades?
21:10:19 <edwardk> but i think the factoring of the upper levels of them to avoid extensions, etc. made a twisty little maze of packages all alike
21:10:53 <aristid> edwardk: maybe the right path is to split between haskell98 and full banana
21:11:09 <edwardk> pharaun: well, i will say that focusing hard on how to make GOOD apis with haskell 98 made me really think a lot about how to avoid flexible instances, etc. which in turn made my code more robust against needing type signatures, etc.
21:11:30 <pharaun> edwardk: point taken :)
21:12:08 <edwardk> i find it pretty galling when something can't be inferred, and will bend over pretty far backwards to make it infer better
21:13:05 <edwardk> if you look at lens for instance, i don't use many MPTCs in there. i could easily make, say, a class TraversableWithIndex  -- but i've deliberately left it off because there is no satisfactory way to ship it
21:13:28 <pharaun> ah i see
21:13:43 <edwardk> prior to 2.5 i'd been trying to keep all my dependencies in the platform, but that means that TraversableWithIndex couldn't have instances for hashmap, for instance
21:14:02 <edwardk> and so any such instance would be an orphan.
21:14:30 <aristid> 2.5 being the upcoming version?
21:14:44 <edwardk> so instead i broke down and did the bytestring/text style separate modules with the same api approach, and just bundled small Data.Text.Lens, etc. modules with the individual apis
21:15:17 <bos> if only we had ML-style functors!
21:15:19 <edwardk> early on i had a class for packing, but that lead to fragility because if you pack.from pack  inference fails you
21:15:30 * hackagebot double-conversion 0.2.0.5 - Fast conversion between double precision floating point and text  http://hackage.haskell.org/package/double-conversion-0.2.0.5 (BryanOSullivan)
21:15:32 * hackagebot blaze-textual 0.2.0.8 - Fast rendering of common datatypes  http://hackage.haskell.org/package/blaze-textual-0.2.0.8 (BryanOSullivan)
21:15:46 <edwardk> it is nice that the api for text support in lens boils down to two functions though =)
21:16:04 <edwardk> with 'text' and 'packed' you can do pretty much anything (slowly)
21:16:38 <edwardk> anyOf text (=='o') $ "hello"^.packed
21:16:58 <edwardk> text lets me traverse characters, packed lets me go to/from Data.Text
21:17:46 <bos> you've got lenses over strings? that's interesting
21:17:46 <pharaun> :D
21:17:48 <edwardk> so for example, Data.Text doesn't expose a 'traverse' analogue, but text can be used as one
21:18:10 <edwardk> bos: basically the 'lens' package exposes Traversals, which are generalized lenses that work like 'traverse'
21:18:34 <edwardk> and there are combinators in there for doing anything you can do with a Traversable with them
21:18:46 <edwardk> and they compose with . from the prelude.
21:18:51 <bos> i'd support traverse if i knew more about what it was
21:19:03 <bos> (i've never used it)
21:19:04 <aristid> edwardk: do lenses also support partial isomorphism, like (excuse my lack of comonads): (a -> Maybe b, b -> Maybe a)?
21:19:09 <edwardk> bos: you know mapM?
21:19:14 <bos> doesn't look like something that can obviously be implemented efficiently
21:19:16 <edwardk> bos: same diff
21:19:19 <bos> edwardk: sure
21:19:36 <bos> oh, it's mapM over Applicative
21:19:38 <edwardk> bos: mapM can be implemented with just return and 'ap', swap in pure and <*>
21:19:39 <edwardk> yes
21:19:49 <edwardk> thats all it is
21:19:56 <edwardk> you never need the full monad structure to traverse something
21:20:01 <edwardk> only to make decisions
21:20:31 <edwardk> then creative choices of Applicative let you derive Foldable and Functor from traverse
21:20:35 <bos> fascinating, captain
21:20:44 <edwardk> if you traverse with the Identity applicative/monad you get fmap
21:21:00 <bos> i don't think anyone has tried stream fusion (how text's map is implemented) via an Applicative or Monad
21:21:02 <edwardk> if you traverse with 'Const', which is applicative if its argument is a Monoid you get foldMap
21:21:11 <bos> i expect it wouldn't fuse
21:21:25 <edwardk> it doesn't, but its a valuable enough tool to expose anyways
21:21:28 <bos> sure
21:21:37 <bos> i think it could still be implemented efficiently, maybe
21:21:52 <bos> preallocate an array for the result, populate it element by element, grow if too small
21:22:07 <edwardk> anyways the vector stuff has some monadic stream fusion code iirc
21:22:27 <bos> all of vector's stream fusion code is implemented via a monad
21:22:31 <edwardk> problem though, the applicative may be something like [], so you may get multiple arrays
21:22:35 <bos> it just uses the identity monad for the base case
21:22:39 <bos> right
21:23:06 <edwardk> yes, and the approach taken by vector for monadic stream fusion doesn't generalize to applicative as i recall
21:23:23 <edwardk> i beat myself bloody on it a couple years back for vector-instances
21:23:43 <edwardk> before i finally got roman to just merge the common instances in ;)
21:24:53 <Twisol> So I noticed that pipes defines a Pipe type with a monad instance, and a newtype PipeC wrapper with a category instance. Is there any reason Haskell doesn't support making Pipe an instance of both?
21:25:08 <edwardk> actually there may be a very good way to do traverse for text
21:25:11 <aristid> Twisol: order of type parameters.
21:25:36 <edwardk> you don't need to grow the array if its too small, they are always the same size as the source array (modulo surrogate noise)
21:25:42 <aristid> Twisol: Monad demands its parameter to be the last one, Category likewise wants the last two
21:26:16 <Twisol> Couldn't Haskell support instancing over parameters besides the last ones?
21:26:18 <bos> edwardk: yes, it's the noise issue that's the problem
21:26:35 <bos> an array of length K may need to be doubled in size
21:26:36 <edwardk> Twisol: yes, because they both need to be in the same position. if you want to take a whack at working with a language that offers you the power and flexibility of putting monads on any argument, i welcome you to try scala.
21:26:52 <aristid> Twisol: i don't think that would be easy to add
21:27:00 <Twisol> edwardk: I heard the scala discussion earlier. Not sure I want to do that. ^_^;
21:27:24 <aristid> Twisol: the "discussion" where i said the haskell code looks more beautiful?
21:27:40 <Twisol> the discussion where someone said scala was like a bunch of things tossed into a bol
21:27:41 <Twisol> *bowl
21:27:50 <edwardk> bos: yep. shachaf was fiddling around with ucs4 and 3-codepoints to a 64 bit word encodings the other day for fun. they of course side-step the resizing, but yegods
21:27:53 <aristid> oh, must have been earlier then
21:28:05 <edwardk> i think he even got most of the Data.Text tests to pass =)
21:28:12 <bos> that's just wrong
21:28:35 <aristid> what were the results of the utf-8 experiments btw?
21:28:41 <edwardk> bos: the 3 codepoints thing started out as a joke i made i think
21:28:43 <Twisol> It's just that wrapping/unwrapping PipeC feels a bit frivolous
21:29:07 <bos> aristid: it made the code more complicated, didn't have a measurable effect on speed
21:29:27 <edwardk> aristid: it was within ~5% across the board, mostly faster at going to and from utf-8, go figure, and wasn't worth the interoperability issues with talking to 3rd party libraries
21:29:44 <aristid> Twisol: just use pipe rather than (.). i think that instance is mostly a "proof"
21:30:04 <edwardk> Twisol: you can always switch to machines
21:30:05 <edwardk> ;)
21:30:11 <Twisol> aristid: It supplies <+< to do the (un)wrapping implicitly.
21:30:20 <shachaf> bos: Yes, I don't think it's a seriously viable encoding, but it was a fun way to learn about Data.Text if nothing else.
21:30:24 <aristid> edwardk: you mean with those 3rd-party libraries that don't use utf-8 :)
21:30:30 <Twisol> aristid: but I like using the more generic functions wherever possible, like Monoid (<>)
21:30:37 <donri> bos: hey does the rewrite rules for text literals work for other IsString things like Builder, newtypes around Text with generalized newtype deriving of IsString?
21:30:38 <edwardk> the model i use there is that you build plans for machines in a monad. the plans are like pipes, you await and yield, etc.
21:30:53 <edwardk> then you compile the plans into machines that you connect like a category
21:30:55 <shachaf> But codepoints going across byte boundaries causes way too many problems.
21:31:02 <aristid> Twisol: not possible if the type parameters are in the "wrong" order ;)
21:31:13 <edwardk> aristid: notably iconv, which we use for talking to all those other encodings
21:31:40 <bos> donri: no idea
21:31:44 <shachaf> bos: Would there be any benefit to trying a UTF-32 implementation of Text? Or does the whole mess with ICU etc. make it not worth it?
21:31:52 <aristid> Twisol: and i think exposing the monad natively is the better choice
21:31:55 <Twisol> aristid: I know. :( I'm asking from a language-design point of view, if being able to specify the parameters used by an instance would be possible
21:32:03 <shachaf> (Or maybe UTF-24, which is at least byte-aligned... But that's probably not a good idea either. :-) )
21:32:05 <aristid> edwardk: huh? iconv can take any encodings on both sides
21:32:11 <bos> shachaf: i can't imagine it being worth the bother
21:32:11 <Twisol> aristid: not currently, just conceptually
21:32:15 <donri> bos: ok :) guess i should experiment with that flag for showing rules being triggered
21:32:34 <shachaf> I just don't like UTF-16, really. :-(
21:32:46 <edwardk> aristid: the fast path is going through wchar_t in utf16
21:32:58 <aristid> bos: but you wouldn't discourage shachaf from making experiments?
21:33:10 <bos> shachaf: i recommend you switch to EUC-JP then
21:33:22 <aristid> edwardk: huh, wchar_t is 32-bit on my linux
21:34:16 <pharaun> shachaf: i'm just sad that newer utf-8 is limited to 4 bytes, forces you into utf16 or higher if you want more than the BMP
21:34:37 <pharaun> and i'm not a fan of utf16 either
21:34:46 <aristid> pharaun: what? i don't think utf-8 is limited to the BMP.
21:34:59 <bos> pharaun: wat
21:35:06 <Twisol> can't you use surrogates to extend past the BMP? or something?
21:35:06 <shachaf> pharaun: Huh?
21:35:14 <bos> pharaun: i think you've been reading the 1998 internet again
21:35:14 <shachaf> pharaun: UTF-8 can express all of Unicode.
21:35:19 <aristid> Twisol: no that's unrelated
21:35:22 <pharaun> maybe i'm misunderstanding ths specs again
21:35:31 * hackagebot text-format 0.3.0.8 - Text formatting  http://hackage.haskell.org/package/text-format-0.3.0.8 (BryanOSullivan)
21:35:33 <bos> UTF-8 is infinitely extensible
21:35:43 <pharaun> won't be the first time :) but what i mean isn't utf8 limited to 4 bytes in general? according to the spec
21:35:47 <edwardk> derp. i meant icu =)
21:35:48 <bos> no
21:35:55 <aristid> but right now utf-8 only uses up to 4 bytes, no?
21:35:56 <pharaun> i always thought it would be infinitely extensible
21:35:59 <bos> no
21:36:08 <aristid> but still those 4 bytes suffice for more than the BMP
21:36:10 <shachaf> How do you take UTF-8 past 7 bytes?
21:36:20 <piglittlepuffpuf> hi, can someone give me a simple non-technical explanation of a 'combinator' and why they're useful?
21:36:45 <shachaf> UTF-8-as-used-to-encode-Unicode only uses up to 4 bytes.
21:36:51 <shachaf> Which is enough to encode all the planes.
21:36:51 <pharaun> shachaf: chained extension?
21:37:28 <shachaf> pharaun: ?
21:37:36 <aristid> please don't beat me up for citing wikipedia on this: "UTF-8 encodes each of the 1,112,064[7] code points in the Unicode character set using one to four 8-bit bytes (termed "octets" in the Unicode Standard)."
21:37:46 <edwardk> piglittlepuffpuf: 'function'
21:38:27 <piglittlepuffpuf> edwardk: ok but what about a combinator is interesting enough that it's been given its own name separate from just 'function'
21:38:36 <edwardk> aristid: yes, the encoding was truncated when it was standardized
21:39:00 <shachaf> I guess you could do 8 bytes with normal UTF-8
21:39:15 <shachaf> But I'm not sure how you'd keep all its nice properties beyond that.
21:39:21 <edwardk> piglittlepuffpuf: the origin of the name combinator comes from a long time ago when people were still learning the theory of computation. back when turing machines and lambda calculi roamed the earth wild and untamed
21:39:21 <pharaun> thus won't the four 8bit bytes not be able to show the full unicode range?
21:39:36 <piglittlepuffpuf> edwardk: hehe
21:39:44 <edwardk> piglittlepuffpuf: at the time the lambda calculus was one formalism for describing computation
21:39:57 <edwardk> but it required these anonymous functions or lambdas
21:40:39 <dolio> A combinator is a function defined only using arguments on the left and an expression on the right containing only its arguments, previously defined combinators, and application.
21:40:44 <edwardk> the idea of a combinator calculus came along, where you could encode anything you could encode with those crazy nested anonymous functions using a few 'top level' functions with no environment called combinators for how they combined
21:40:45 <dolio> No lambda expressions.
21:41:31 <pharaun> according to http://tools.ietf.org/html/rfc3629 - In UTF-8, characters from the U+0000..U+10FFFF range, and blah, would mean it won't be able to access the U+11* -> U+FF* ?
21:41:36 <edwardk> the S, K and I combinators that make up the SKI calculus are an example of a usable combinator basis for arbitrary computation
21:41:44 <shachaf> dolio: Can't you make anything using "previously defined combinators"?
21:41:50 <shachaf> Assuming S and K are previously defined.
21:41:55 <dolio> Yes.
21:42:00 <dolio> Depending on types.
21:42:04 <shachaf> So why is "combinator" interesting?
21:42:42 <dolio> It is a simpler calculus than the lambda calculus.
21:42:43 <edwardk> shachaf: because it wasn't immediately obvious when they first showed up that you could combine a finite set of functions into any function you can think of
21:42:58 <dolio> Once the combinators are defined, there are no binders and no reduction rules.
21:43:06 <piglittlepuffpuf> edwardk: what is S combinator for example
21:43:12 <napping> dolio: shouldn't the definition take no arguments at all?
21:43:17 <shachaf> Ah. Hmm.
21:43:18 <dolio> No binders and no variables, even.
21:43:20 <shachaf> When did they show up?
21:43:38 <edwardk> piglittlepuffpuf: s x y z = x z (y z)
21:43:44 <dolio> Just simple 'replace left side with right side' rewrite rules.
21:44:00 <napping> I think it's mostly descriptive, not something that's particularly useful in itself
21:44:48 <piglittlepuffpuf> edwardk: can you write that in normal mathematical function notatin, is it like: s(x, y, z) = x(z, y(z)) ?
21:44:55 <piglittlepuffpuf> or something..
21:45:01 <pharaun> meh ignore me, i misread the spec again
21:45:03 <edwardk> piglittlepuffpuf: yes
21:45:11 <shachaf> s(x)(y)(z) = x(z)(y(z))
21:45:42 <JoeyA> How expensive is an exception handler in GHC, assuming the code does not throw an exception?  Anyone know off the top of their head?
21:45:54 <edwardk> piglittlepuffpuf: but we want to make it so that you can partially apply the functions, etc. so you get what shachaf wrote there, which after you erase the ()'s is what i wrote ;)
21:46:01 <JoeyA> err, *when* the code does not throw an exception
21:46:13 <JoeyA> If we assume it doesn't throw an exception, we just leave out the `try` :-)
21:47:00 <shachaf> S and K which only take exactly 3 or exactly 2 arguments respectively aren't very useful.
21:48:31 <piglittlepuffpuf> are there any interactive haskell tutorials like tryruby?
21:48:42 <donri> http://tryhaskell.org/
21:48:58 <edwardk> (unsafeCoerce <*> unsafeCoerce) (unsafeCoerce <*> unsafeCoerce) -- is a way to encode SII (SII) -- an irreducible expression in the SKI calculus in haskell.
21:49:11 <piglittlepuffpuf> should have guessed ;) donri, is it recommended? is it any good
21:49:17 <donri> sure
21:49:27 <shachaf> edwardk: To someone who just asked what a combinator is a few minutes ago? :-(
21:49:35 <edwardk> shachaf: =)
21:50:20 <edwardk> I have a system. Throw them in the deep end. if they manage to swim out past the sharks, mines and depth charges that i've placed, then they are someone i want to keep talking to. ;)
21:50:54 <shachaf> That's a reasonable system, actually.
21:51:02 <dolio> shachaf: It's extremely useless, because you can't partially apply them unless you add combinators. :)
21:51:03 <edwardk> Or they explode. Either way I'm good.
21:51:13 <shachaf> dolio: Exactly.
21:52:06 <edwardk> Actually I prefer it if they make it out alive. I'm running out of friends who are willing to let me use their pool this way.
21:52:37 <shachaf> edwardk: Why use a pool when you have the ocean?
21:53:08 <edwardk> shachaf: takes a lot to seed the entire ocean with mines and sharks
21:53:54 <shachaf> Maybe you could toss more than one in and have them fight to the death.
21:53:59 <edwardk> this has drifted decidedly into #haskell-blah territory
21:54:07 <shachaf> True.
21:54:13 <napping> piglittlepuffpuf: for messing with SKI combinators, there's Unlambda
21:54:42 <napping> haskell doesn't use or dependend on anything like a combinator basis
21:55:11 <Twisol> It amazes me that, for every mind-blowing Haskell epiphany (for which there have been many), it all boils down to a small set of decoupled features.
21:56:08 <edwardk> is @unlambda working?
21:56:10 <edwardk> @unlambda
21:56:10 <lambdabot>   unlambda: Parse error at end of file
21:56:13 <napping> used to be combinator graph reduction was how lazy functional languages were implemented, but that's pretty old
21:56:21 <shachaf> @bf +++++++++++++++++++++++++++.
21:56:21 <lambdabot>  Done.
21:56:27 <shachaf> @bf +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.
21:56:27 <lambdabot>   ?
21:56:36 <napping> @unlamda `.ai
21:56:36 <lambdabot>   a
21:56:37 <shachaf> Clearly imperative programming is more reliable than functional.
21:56:39 <napping> guess so
21:56:40 <aristid> @bf ,.
21:56:40 <lambdabot>  Done.
21:56:47 <edwardk> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
21:56:47 <lambdabot>   Hello World!
21:56:59 <aristid> brainfuck without input:(
21:57:09 <mauke> @bf +[>+]
21:57:12 <lambdabot>  Done.
21:57:46 * aristid refrains from more @bf queries as that would be bot abuse
21:57:51 <shachaf> #haskell needs a Lazy K bot, not Unlambda.
21:59:13 <pharaun> is lambdabot source somewhere? or is there a list of commands that it support
21:59:42 <donri> @help
21:59:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:59:43 <shachaf> @google lambdabot source
21:59:44 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
21:59:44 <lambdabot> Title: Lambdabot - HaskellWiki
21:59:51 <donri> @list
21:59:51 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
22:00:56 <pharaun> :D
22:21:22 <slack1256> In the code of cabal. The real work occurs on github and the darcs repo just mirrors it, right?
22:24:41 <donri> slack1256: https://github.com/haskell/cabal/ claims to be the official repo
22:25:32 * hackagebot unix-compat 0.3.0.2 - Portable POSIX-compatibility layer.  http://hackage.haskell.org/package/unix-compat-0.3.0.2 (BryanOSullivan)
22:25:40 <slack1256> donri: time to learn git then.
22:55:33 * hackagebot yesod-auth-oauth 1.1.0.0 - OAuth Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-oauth-1.1.0.0 (HiromiIshii)
23:08:17 <orzo> is there something like span, but which returns the first list reversed?
23:09:41 <shachaf> Not in the standard library.
23:09:48 <shachaf> Are you making a zipper?
23:10:12 <orzo> what's a zipper?
23:11:06 <orzo> i am implementing a linear search that assumes the next element to find will be near the last one that was found
23:11:24 <orzo> so i just want to keep a cursor position in the list
23:11:44 <orzo> seems removing from one list and consing on the other would be a decent way to do that
23:11:47 <shachaf> A zipper is a cursor into a data structure.
23:12:08 <orzo> Okay, then probably, yes, i'm making a zipper
23:12:09 <shachaf> A zipper on a list is usually stored as an element + list of elements ahead + reversed lists of elements behind.
23:12:13 <paolino> .,--------------------------------------------------------------------------------------------------------------------------------------------------------------+
23:12:39 <orzo> okay, well are zippers on lists already implemented in the standard library?
23:13:05 <shachaf> xmonad has a zipper type that it implements itself.
23:13:21 <shachaf> But there's probably one on Hackage too. Not sure if it's good or not.
23:13:28 <orzo> Data.List.Zipper exists
23:13:40 <shachaf> Yep.
23:13:49 <slack1256> orzo: when learning about zipper (and when probably you need one) check the wikibook of haskell the zipper part
23:13:51 <shachaf> It doesn't have your function, though. :-)
23:13:59 <slack1256> I think is the most crafted chapter of the whole wikibook
23:14:08 <shachaf> slack1256: orzo already understands the data structure he wants. That wikibook chapter just makes things confusing.
23:14:41 <slack1256> shachaf: mmm, you're probably right.
23:15:07 <shachaf> You might be best off implementing it yourself. I don't know.
23:15:57 <shachaf> Hmm, ListZipper seems to claim that its Zipper is a comonad.
23:16:12 <edwardk> i have a zipper comonad in comonad-extras
23:16:19 <shachaf> And yet it supports empty zippers. Does that make sense?
23:16:21 <edwardk> for arbitrary traversables
23:16:23 <edwardk> no
23:17:36 <djapo> how do i install X11 >=1.5.0.0 && <1.6, mtl -any, utf8-string ==0.3.*
23:17:56 <shachaf> orzo": To answer your original question -- I don't think you'll find that function. :-)
23:19:01 <orzo> hmm, Data.List.Zipper is really close but they implement it as a pair of lists where the "current" item is represented as the head of the second in the pair, where I would prefer it the head of the first of the pair because i'd like easy access to the next element also
23:19:02 <slack1256> djapo: cabal install didn't solve that automagically?
23:19:30 <orzo> the way they do it, you have easy access to the previous element
23:19:43 <djapo> slack1256: i recently upgrate to ubuntu 12.04 i think it removed cabal
23:19:46 <shachaf> orzo: The first list is the "backwards" one.
23:19:51 <orzo> yes
23:19:53 <orzo> that's what i want
23:19:55 <edwardk> shachaf: basically its pleasant fiction, its a legal 'Extend' instance but not a fully legal Comonad
23:20:07 <pharaun> wee finished the ed2k hasher, now time to figure out the quickcheck thing, never done a quickcheck test
23:20:29 <slack1256> djapo: really?, damn, that really puts you in an odd position.
23:20:32 <edwardk> the one i offer for traversables http://hackage.haskell.org/packages/archive/comonad-extras/3.0/doc/html/Control-Comonad-Store-Zipper.html is a legal comonad ;)
23:20:49 <shachaf> orzo: Oh, I see.
23:20:53 <slack1256> djapo: I'm not in ubuntu, but aren't a PPA with haskell packages? maybe cabal-install is there.
23:21:22 <shachaf> If the library doesn't do what you want, the data structure is probably simple enough that you can just write your own.
23:21:32 <djapo> slack1256: yes im installing right now, just had not noticed it was missing
23:21:35 <shachaf> It's only a handful of functions.
23:21:57 <shachaf> "zipper" is a nice abstract concept but as far as I can tell there are so many little variations of it that it's hard to make a good abstraction.
23:23:47 * shachaf still wants to see some justification for "taking the derivative gives you the zipper".
23:24:02 * shachaf 's battery is at 5%
23:24:26 <opqdonut> well the derivative is _defined_ as the type of one-hole contexts
23:24:53 <edwardk> opqdonut: thats one derivative, there are several admissable ones
23:25:28 <edwardk> http://blog.sigfpe.com/2007/01/foxs-ubiquitous-free-derivative-pt-2.html
23:25:49 <pharaun> @pl hash a = finalize $ update init a
23:25:49 <lambdabot> hash = finalize . update init
23:26:47 <shachaf> opqdonut: OK, so why does the "normal" derivative operation we're used to happen to compute one-hole contexts?
23:26:53 <shachaf> Battery: 3%
23:27:01 * shachaf will be back later.
23:47:50 <amiller> is anyone familiar with these slides
23:47:51 <amiller> http://www.cs.ut.ee/~varmo/tday-koke06/uustalu-slides.pdf
23:48:03 <amiller> "behind every zipper lies a comonad" and "attribute binary trees"
23:48:24 <amiller> i'm trying to find the write way to describe secure computations on a merkle tree
23:48:24 <edwardk> amiller: yes
23:48:28 <mmos> I want to do something like "type X = MonadError String m => Float -> m Float" but I'm getting an error -- Illegal polymorphic or qualified type
23:48:39 <edwardk> amiller: hrmmm
23:48:43 <amiller> data Tree e a = a :< Trunk e (Tree e a)
23:48:43 <amiller> data Trunk e x = Leaf e | Bin x x
23:49:00 <amiller> that's very close to what i've been writing, but it's a little confusing to me
23:49:09 <amiller> what is :<, is that standard?
23:49:40 <amiller> Tree in some case acts like Mu, which is what someone helped me find before
23:49:59 <edwardk> amiller: it looks kind of like : to indicate that you have the 'rest of the structure, and the < is to indicate fanout
23:50:22 <amiller> @hoogle :<
23:50:22 <lambdabot> Data.Sequence (:<) :: a -> Seq a -> ViewL a
23:50:31 <edwardk> it was just something i started using on my stream types, and uustalu and some others also did
23:51:03 <edwardk> plus you have to start with : to be a type operator so the choices are somewhat limited
23:51:14 <edwardk> I've used :- :> and :< variously for different types ;)
23:51:23 <startling> how do type operators work?
23:51:39 <edwardk> startling: effectively : is an uppercase symbol.
23:51:48 <edwardk> thats changing in 7.6.1
23:51:53 <startling> and you can have infix type constructors?
23:51:56 <edwardk> yeah
23:52:00 <startling> oh, weird
23:52:07 <edwardk> though you can't section them
23:52:18 <edwardk> you can only prefix them entirely with ()'s
23:52:54 <startling> so you can do ((:>) Whatever) but not (Whatever :>)
23:53:06 <edwardk> startling: sadly correct
23:53:15 <amiller> i'm going to attempt pasting five lines, sorry if this goes poorly
23:53:16 <amiller> instance Comonad (Tree e) where
23:53:16 <amiller> counit (a :< _) = a
23:53:16 <amiller> cobind k d@(_ :< as) = k d :< case as of
23:53:16 <amiller> Leaf e -> Leaf e
23:53:16 <amiller> Bin asL asR -> Bin (cobind k asL) (cobind k asR)
23:53:46 <edwardk> amiller: yes, that is a cofree comonad
23:54:48 <amiller> i don't understand how to read :< there
23:55:01 <edwardk> amiller: do you know how to read : in lists?
23:55:19 <amiller> yeah, head to the left, everything else to the right
23:55:26 <edwardk> amiller: same here
23:55:33 <amiller> a represents the attribute then
23:55:33 <edwardk> head to the left, then the branches are to the right
23:55:41 <edwardk> yes
23:55:53 <amiller> okay i think i see
23:56:10 <edwardk> https://github.com/ekmett/free/blob/master/src/Control/Comonad/Cofree.hs#L112
23:56:13 <amiller> the relationship of trunk to tree is bizarre, but i've been using "Node" and "Tree" because i couldn't figure out what else to call them
23:56:15 <edwardk> is the same thing basically
23:56:43 <edwardk> you can do this entire construction without ever picking a choice of 'f', then you can instantiate it several ways to see different list types
23:56:52 <edwardk> data Cofree f a = a :< f (Cofree f a)
23:56:54 <edwardk> start there
23:57:05 <edwardk> When f = Identity, this is easy
23:57:23 <edwardk> a :< Identity (a :< Identity (a :< Identity (….
23:57:33 <edwardk> its an infinite non-branching stream, right?
23:57:53 <amiller> i'm not sure about the branching but i think that's correct
23:58:08 <edwardk> ok, now, lets change out f, for Maybe
23:58:21 <edwardk> a :< Just (a :< Just (a :< Nothing))
23:58:38 <edwardk> so you have a :< Nothing or a :< Just (a :< Nothing) ...
23:58:42 <edwardk> its a non-empty list
23:59:12 <edwardk> notice the comonad doesn't care about what choice we make for 'f', just that its a functor
23:59:32 <edwardk> so far so good?
23:59:35 <amiller> yes
23:59:42 <edwardk> we can duplicate Data.Tree from containers by choosing f = []
