00:04:03 <chris___> sort "chris" => "chris"  ?
00:04:15 <shachaf> Not quite.
00:04:29 <unrar> Hi
00:04:33 <chris___> i'm try Haskell in browser
00:05:21 <peano_player> try yourself a Haskell for great good ^^
00:05:38 <unrar> Yay that book is great
00:05:56 <unrar> And O'Reilly's Haskell in the real world
00:06:24 <chris___> thanks
00:09:22 <peano_player> what are closures?
00:09:41 <peano_player> are they like morphisms?
00:09:53 <startling> peano_player: how do you mean?
00:10:04 <startling> peano_player: they're a way to implement first class functions
00:10:14 <startling> peano_player: or the property of an operation being closed over some set
00:10:18 <peano_player> ah
00:12:22 <chris___>  fst ("fst","snd") => "fst", how could that happen?
00:12:50 <shachaf> Sheer coïncidence.
00:12:53 <unrar> But in functional programmin is it possible to do big and serious programs?
00:13:13 <lpvb> yes
00:13:16 <lispy> ?faq  But in functional programmin is it possible to do big and serious programs?
00:13:17 <Attic> chris__: because "fst" is the first element in the tuple
00:13:26 <peano_player> is the y combinator a kind of closure
00:13:26 <lispy> :t fst
00:13:31 <lispy> Where is lambdabot
00:13:37 <shachaf> lispy: There was a short linode outage.
00:13:46 <Attic> chris__: fst ("snd","fst") => "snd"
00:13:51 <peano_player> fst :: (a, b) -> a
00:13:55 <lispy> hmm..I'm typing this from my linode...the same one that runs lambdabot :)
00:14:02 <chris___> i can write my fucntion.  fst x y = x. exiting
00:14:04 <johnw> not to be confused with an out-linode shortage
00:14:17 <shachaf> lispy: My Linode server stopped being connected briefly at the same time that lambdabot went down.
00:14:20 <shachaf> It was only a few minutes.
00:14:47 <lispy> shachaf: I believe you, it's just odd that my irssi session didn't blink too
00:14:58 <Attic> chris__: You can, but it won't be a tuple anymore. It'll be 2 arguments instead
00:15:05 <chris___> oh ,yes
00:15:13 <chris___> fst (x,y) = x
00:15:20 <Attic> chris__: Yes
00:15:27 <chris___> thanks
00:15:43 <lispy> unrar: You can make big serious programs in Haskell.
00:16:11 <lispy> unrar: It's actually really good at allowing you to make libraries. So "big serious" Haskell programs tend to be made up from lots of libraries
00:16:37 <peano_player> yes Haskell supports a proper module system
00:16:40 <unrar> ow
00:16:54 <unrar> what is linode?
00:17:06 <lispy> unrar: it's a hosting service
00:17:21 <unrar> Oh
00:18:32 <lpvb> :t fst
00:18:33 <jubjub`bird> forall a b. (a, b) -> a
00:18:45 <peano_player> lol
00:20:33 <unrar> Well, ciao
00:20:35 <unrar> brb
00:21:15 <unrar>  /quit FireWoman@zyra.puta.irc-hispano.org
00:21:18 <unrar> oops
00:21:22 <unrar> sorry haha
00:27:59 * hackagebot gloss 1.7.6.5 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.6.5 (BenLippmeier)
00:35:35 <chris___> upper_one x = if elem x ['a'..'z'] then x+32  ,  how to solve this problem
00:35:55 <chris___> > upper_one x = if elem x ['a'..'z'] then x+32 else x
00:35:56 <jubjub`bird>   mueval-core: /usr/lib/ghc-7.4.1/settings: openFile: does not exist (No such...
00:37:09 <dobblego> which problem?
00:37:11 <startling> chris___: what's the problem?
00:37:21 <startling> chris___: you probably want Data.Char.toUpper
00:37:31 <startling> you can't just add whatever to a Char
00:37:33 <chris___> yes ,that;s it
00:37:49 <startling> chris___: you don't need the if, either
00:37:54 <chris___> i want to write it myself
00:37:55 <startling> chris___: just toUpper x
00:38:01 <startling> chris___: why?
00:38:11 <chris___> just for fun
00:38:34 <dobblego> chr (ord x + 32)
00:38:44 <startling> chris___: converting unicode chars to uppercase is not really fun
00:39:55 <chris___> i see.
00:40:02 <chris___> is not ascii.
00:40:08 <startling> correct
00:43:00 * hackagebot general-prelude 0.1.1 - Prelude replacement using generalized type classes where possible  http://hackage.haskell.org/package/general-prelude-0.1.1 (JohnWiegley)
00:43:02 * hackagebot gitlib 0.4.1 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.4.1 (JohnWiegley)
00:52:09 <chris___> let chose_upper x = [y | y<-x,elem y ['A'..'Z']] , only one line
00:53:00 * hackagebot svndump 0.4.5 - Library for reading Subversion dump files  http://hackage.haskell.org/package/svndump-0.4.5 (JohnWiegley)
00:53:02 * hackagebot hsubconvert 0.0.2 - One-time, faithful conversion of Subversion repositories to Git  http://hackage.haskell.org/package/hsubconvert-0.0.2 (JohnWiegley)
00:53:04 * hackagebot pushme 0.2.0 - Script I use for synchronizing my data among machines  http://hackage.haskell.org/package/pushme-0.2.0 (JohnWiegley)
00:53:06 * hackagebot deepseq-th 0.1.0.4 - Template Haskell based deriver for optimised NFData instances  http://hackage.haskell.org/package/deepseq-th-0.1.0.4 (HerbertValerioRiedel)
00:53:51 <chris___> i think haskell like sql , is that right?
00:56:39 <peano_player> Haskell is quite different from SQL; Haskell is turing-complete, and is intended to be a non-strict, purely-functional, and modular general-purpose programming language for computers. On the other hand, SQL is a declarative query language designed for operating on relational databases
00:58:01 <peano_player> You would use SQL to write queries to a relational database, and Haskell to implement SQL.
00:58:32 <chris___> they are same easy to use
00:58:44 <mikeplus64> chris___: you could also write chose_upper = filter (`elem` ['A'..'Z'])
00:59:33 <chris___> yes ,thanks
01:06:20 <chris___> how could i response someone?
01:06:53 <peano_player>  /msg <person> <message>
01:07:05 <chris___> i got it
01:09:27 <peano_player> so closures are basically lambdas?
01:09:39 <peano_player> or is it the other way around?
01:11:32 <chris___> take one argument , return function , right?
01:25:12 <lpvb> peano_player: closures are functions with the ability to access non-local variables
01:27:35 <nand`> the way I like to see it, closures are unevaluated instantiations
01:27:45 <nand`> (of templates / function bodies)
01:28:36 <nand`> in nonstrict languages, almost everything is a closure until you force it, and then it may still contain closures
01:28:38 <mcstar> nand`: are you using an augmented reality device with a built in irc client?
01:28:44 <nand`> mcstar: no, I am not
01:29:11 <mcstar> most of the time i see this channel, your talking XD
01:29:16 <mcstar> youre*
01:37:57 <mcstar> nand`: i didnt mean you should stop! it was a way of me saying good morning
01:40:10 <nand`> mcstar: well, good morning
01:41:42 <Rc43> Hi, guys.
01:41:57 <Rc43> Anybody can tell what is polynomial abstract data type?
01:43:37 <nand`> maybe a type that is constructed using only the operations of addition, multiplication, exponentiation and other polynomial types?
01:43:40 <nand`> but I have no idea
01:45:18 <mcstar> maybe, it is supposed to be, polynomial algebraic data type?
01:45:51 <nand`> I think people use ‘abstract data type’ and ‘algebraic data type’ interchangeably, often the former to mean the latter
01:45:57 <Rc43> mcstar, maybe; but what is ^ in types?
01:46:11 <nand`> though ‘abstract data type’ to me means ‘a data type with hidden implementation’
01:46:13 <mcstar> im would be guessing like nand`
01:46:16 <nand`> Rc43: (->)
01:46:20 <Rc43> (I suppose that + is union and * is cartesian)
01:46:20 <mcstar> -m
01:46:34 <nand`> Rc43: yeah pretty much
01:46:41 <Rc43> nand`, ok, nice
01:47:44 <mcstar> data Poly = Zero | One Type | Two Type Type | Three Type Type Type ... ?
01:47:52 <Palmik> Hmm, can haddock handle commented ADT contructors?
01:49:47 <efie> I want to read a large file and parse its input. Regarding efficiency, it is better to do do some maps and filters, or to use Parsec?
01:50:30 <fmap> Palmik: http://www.haskell.org/haddock/doc/html/ch03s02.html ?
01:50:51 <Palmik> fmap, sorry I meand GADT
01:50:55 <Palmik> t
01:51:39 <Palmik> for example here it chokes on the comment on KN http://hpaste.org/76224
01:54:10 <fmap> Palmik: I guess no: http://trac.haskell.org/haddock/ticket/43
01:54:55 <randomclown> say I use iterate, and the function eventually converges. I know I can write a function to get that result, is there a better way?
01:54:56 <Palmik> Hmm, unfortunate.
01:55:46 <Palmik> randomclown, are you interested in all the values that precede or just the last one?
01:55:52 <randomclown> it's like fixpoint but has a starting parameters. Usually I think people just return a function that already captures the state when they use fix
01:55:54 <randomclown> just the last
01:57:03 <Palmik> The I do not think using iterate would be optimal, as the last value would be at the end of the list -- which is kind of hard to reach. :)
01:57:38 <randomclown> obviously not using last
01:57:59 <randomclown> but comparing parts of the list until they equal.
01:58:11 <Palmik> Well, yes, but even the it would be at the end of the prefix.
01:58:21 <hiptobecubic> randomclown, write a function that does that, call it "while" and you're done i tihnk
01:58:22 <Palmik> Why not just use Data.Function.fix?
01:58:41 <randomclown> how do you use fix with a starting parameter
01:58:48 <fmap> @botsnack
02:00:12 <randomclown> i.e. improve :: Int -> Int, does something to the int, used like (improve (improove ... (improve (imporve (imporve 1))...)
02:00:59 <randomclown> Palmik:
02:01:06 <fmap> randomclown: fix (\f x -> if goodEnough x then x else f (improve x))
02:01:28 <fmap> er
02:01:32 <fmap> randomclown: fix (\f x -> if goodEnough x then x else f (improve x)) initial *
02:02:30 <randomclown> fmap: why do you need the "goodEnough" function
02:02:38 <Palmik> randomclown, you are right, how about this "stable f c = if f c == c then c else stable f (f c)"
02:03:03 * hackagebot markdown-unlit 0.2.0.1 - Literate Haskell support for Markdown  http://hackage.haskell.org/package/markdown-unlit-0.2.0.1 (SimonHengel)
02:03:51 <fmap> randomclown: well, you need some condition to stop recursion
02:04:11 <Palmik> randomclown, I think the condition is that the last value is equal to the previous one
02:04:26 <Palmik> fmap ^
02:04:57 <mcstar> > fix (\f a -> if a < 2 then a else f (a`div`2)) (2^10)
02:05:07 <mcstar> @bot
02:05:14 <mcstar> agh..
02:05:40 <fmap> mcstar: yeah, that's unfortunate
02:06:03 <randomclown> > 1 + 1
02:06:10 <randomclown> what's up with the bot
02:06:55 <randomclown> Palmik: Anyways that's a pretty nice and clean way to do it
02:07:27 <Sgeo> The bot's not here
02:07:50 <mcstar> stable f c = let fc = f c in if fc == c then c else stable f fc
02:07:55 <mcstar> i think thats better
02:08:14 <Cale> @bot
02:08:21 <lambdabot> :)
02:08:30 <mcstar> @botsnack
02:08:35 <lambdabot> :)
02:08:51 <Cale> > fix (\f a -> if a < 2 then a else f (a`div`2)) (2^10)
02:08:57 <lambdabot>   1
02:08:59 <Palmik> mcstar, yes, you save one eval of f c per iteration. :)
02:09:12 <randomclown> doesn't ghc automatically optimise that?
02:09:49 <Cale> randomclown: Sorry, I missed the start, optimise what exactly?
02:10:23 <Palmik> Cale, foo f x = f x + fx vs. foo f x = let fx = f x in fx + fx
02:10:23 <Cale> randomclown: GHC does not automatically do common subexpression elimination
02:10:49 <Cale> If you write foo f x = f x + f x, then you will evaluate the application of f to x twice
02:11:24 <Cale> if you write  foo f x = let y = f x in y + y  then it'll only be evaluated once
02:12:08 <randomclown> Right right
02:12:17 <Cale> However, there are cases where, supposing that y is something very space intensive, and + is some operation which might only need its second parameter much later, where you would not want this to happen automatically
02:13:24 <Cale> (because you'd keep that large thing in memory for the entire time -- if it's fast to compute, but takes lots of space, this is a bad sort of optimisation to do)
02:14:38 <randomclown> Ah right, because there are cases where you want it evaluated twice
02:16:00 <suhovweb> hi
02:16:13 <Cale> hello
02:16:28 <Palmik> Cale, if it's fast to evaluate, the function will also return fast and the memory would be gced after that, no? Aslo you woild avoid (potentially) expensive memory allocation twice.
02:16:42 <DanMere345768> hi
02:16:45 <Palmik> hi
02:17:16 <Cale> Palmik: consider something like  subsequences [] = [[]]; subsequences (x:xs) = subsequences xs ++ map (x:) (subsequences xs)
02:17:20 <mcstar> what about top level definitions? wont they get memoized all the time?
02:17:56 <Cale> we *could* CSE this, and produce   subsequences (x:xs) = let ss = subsequences xs in ss ++ map (x:) ss
02:18:11 <Cale> but this is actually a very bad idea
02:18:17 <Palmik> Cale, yes, well, in non tail recursive definitions, it's probably bad. What I had in mind was the given example before (with simple +)
02:18:35 <Cale> because ss is going to be a long list in general, and we can't garbage collect it until the very end
02:18:41 <Cale> but its elements are easily produced
02:19:05 <Cale> yeah, sorry, I was generalising + there to some other arbitrary operation
02:20:01 <Cale> mcstar: Top level pattern bindings will get stored as long as the remainder of your program still has a reference to them
02:20:37 <Cale> Any *variable* is computed at most once
02:20:37 <DanMere345768> can I ask a quick question, I have been trying to make a function that takes a string input and a int input, then the function will look up that part of a list depending on what was written in th string. I manged to get it to only need one definintion per country, but i know that with a series of switch type statments i can get it down to just one function definition for every country that has a list. could you help me? This is what I
02:20:38 <DanMere345768> have so far..
02:20:46 <mcstar> Cale: any kind of binding, or only if it matches a value?
02:20:52 <DanMere345768> totlPop "AFGANISTAN" n = printf "\n THE TOTAL POPULATION OF %s IN %i WAS %i PEOPLE. \n" ("AFGANISTAN"::String) (n::Int) (sp_pop_totl_AFG !! (n-1960) ::Int)
02:20:55 <mcstar> pattern any = vs. pattern 2 =
02:21:12 <Cale> x = factorial 10  in this case is an example of a pattern binding
02:21:23 <mcstar> thats a CAF
02:21:34 <mcstar> im talking about function like things
02:21:56 <Cale> mcstar: Functions are not automatically memoised
02:22:08 <mcstar> fun 1 = <long computation>; fun 2 = <other long comp>; fun x = ...
02:22:21 <mcstar> here, fun 1 and fun 2 will or will not be memoised?
02:23:33 <Cale> mcstar: will not
02:23:39 <mcstar> ok, thanks
02:24:07 <mcstar> DanMere345768: you might want to use an array or some kind of map/hashtable
02:24:10 <Cale> Well, at least I'm pretty sure that GHC will not lift CAFs out to top level like that
02:24:12 <Botje> w 21
02:24:15 <Botje> oops
02:24:52 <DanMere345768> tell mcstar ahhh ok.
02:25:01 <DanMere345768> @help
02:25:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:25:07 <DanMere345768> list
02:25:10 <Cale> mcstar: I would personally consider it a bit of a bug for it to do that, at least, in any case where it couldn't be totally certain about the amount of space that the results would take.
02:25:47 <Cale> DanMere345768: If you're just starting out and are comfortable with lists already, you might like to know that there is a function called lookup
02:25:48 <mcstar> Cale: i remember reading something about a space leak, cause a top level thing kind of like what i showed didnt get GC'd
02:25:51 <Cale> :t lookup
02:25:53 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
02:25:58 <Botje> DanMere345768: have you tried making a data structure that maps countries to lists of populations?
02:26:29 <DanMere345768> no not yet, i was trying to keep it simple and just have a list as a basic structure and build from there.
02:26:55 <mcstar> a list is not simple for random access of structured data
02:27:02 <mcstar> imho
02:27:18 <Cale> DanMere345768: which given a key of type a, and a list of key/value pairs of type [(a,b)], searches the list for a key that matches the given one, and if it finds (k,v), produces Just v as the result, and otherwise, Nothing
02:27:31 <Cale> A list is a bad data structure for this in general
02:27:38 <DanMere345768> ah ok
02:27:52 <Cale> But if you can manage this, you can easily stick a Map.fromList onto your list of pairs
02:28:03 <Cale> and switch to using the lookup from Data.Map
02:28:21 <Cale> which will provide a performance boost :)
02:28:23 <DanMere345768> ah ok
02:28:58 <mcstar> i really like that lots of times, you can change the implementation with changing the name of the qualified import
02:28:59 <DanMere345768> i figured it might not be the best way, but then when it was such a basic thing i noticed i could use it with the more advanced techniques later.
02:30:08 <DanMere345768> one thing i wondered about was, at the moment i have to use "" to enclose the parameter i pass to the function, is there a way i can do without that?
02:31:02 <DanMere345768> like at the moment im having to type totlPop "AFGANISTAN" 1976
02:31:19 <mcstar> use the country code instead
02:31:20 <DanMere345768> what i would like to do is totlPop AFGANISTAN 1976
02:31:41 <mcstar> AFG(or whatever) -> afganistan
02:33:34 <DanMere345768> theres a bunch of data in XML format, i been trying to figure out whats easyest way to import the data so i can generate the base lists automaticaly and not have to do it all by hand. Sorry i am very newbish.
02:34:16 <mcstar> Map ShortName Int; Array String; getPopulation short = let i = M.lookup short in "populaion of " ++ countries!(i,0) ++ ": " ++ countries!(i,1)
02:35:00 <Cale> DanMere345768: Being able to write AFGHANISTAN and have that refer to a value means that (because A is uppercase here) there is a data type declared with AFGHANISTAN as a data constructor.
02:35:29 <Cale> DanMere345768: This would suggest that you have an enumeration data type with constructors for all the countries in the world, or at least in your data.
02:35:36 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/Facts/0.1.2/doc/html/Facts-Geography-Countries.html
02:36:17 <Cale> This *might* be an okay idea, and indeed, there is a package, which ClaudiusMaximus just linked, providing such a thing.
02:36:18 <DanMere345768> ok
02:36:33 <mcstar> isoalpha3 then :)
02:36:52 <Cale> Writing functions on such a data type with so many constructors in general can be a little bit awkward depending on what you're doing though.
02:37:21 <DanMere345768> would it be a big negative on performance?
02:37:30 <ClaudiusMaximus> but it's last uploaded in 2010, and fails to build on recent ghc (maybe just too-stricct cabal version constraints, maybe not)
02:37:35 <Cale> No, it would be better for performance to use such a type
02:37:40 <Cale> generally
02:37:45 <DanMere345768> ah ok
02:38:39 <mcstar> you could put your data into a database too, and query that from haskell
02:39:37 <Cale> But those values are *not* strings, and as such you might need to convert them back and forth to strings, which implies doing some sort of parsing.
02:39:48 <DanMere345768> i been trying to think of the best way to do it load all of the data into the haskell program on startup, use a database or file..
02:40:04 <Cale> (you might be able to avoid that if you just want to type everything at the GHCi commandline though)
02:42:16 <Cale> DanMere345768: It really depends on what type of program you're writing and how much you want to verify at compile time about how your program works.
02:42:43 <Cale> DanMere345768: In some ways, it's safer and faster to use such a datatype, but in others, it's going to be more work.
02:43:28 <DanMere345768> Cale: so stability wise, its much better to use the map/datatype.
02:44:05 <Cale> yeah, because computations which operate on that datatype know that they are not going to receive an invalid country
02:44:16 <Cale> So it's safer
02:45:07 <DanMere345768> and i guess having everything actualy contained within the haskell program is safer as it removes the possibilty of having the external data corupted.
02:45:18 <Cale> But on the other hand, if you suddenly have to deal with a country which isn't supported by the datatype, you end up needing to fork that package it's defined in, or at least, grab the datatype definition and extend it, and then extend all the functions which work on it accordingly.
02:45:48 <DanMere345768> i see so safety but at the expence of flexability.
02:46:08 <Cale> yeah
02:46:43 <DanMere345768> thats ok, my guess its it would be faster keeping everything in the one place, removing the need for lots of IO.
02:48:56 <efie> "do a <- Just 3; b <- Just 4; return $ (+) a b" can be written as "(+) <$> Just 3 <*> Just 4", how do you do this for "do a<-Just 3; x <- Just 0 ; b <- Just 4; return (+) a b"?
02:51:47 <DanMere345768> thanks guys you been great.
02:54:40 <efie> it can be rewritten, can't it?
02:56:35 <Botje> @pl \a x b -> (+) a b
02:56:36 <lambdabot> const . (+)
02:57:00 <Botje> efie: so something like (const . (+)) <$> Just 3 <*> Just 0 <*> Just 4
02:57:05 <Botje> of course that's kind of silly
02:59:51 <efie> thanks
02:59:59 <nand`> (+) <$> Just 3 <* Just 0 <*> Just 4
03:00:29 <efie> that's nice :)
03:02:20 <nand`> there's also *> and <$ for your convenience
03:29:35 <ippo> what is the correct way to add a line of text to a textBuffer in gtk2hs? I always end up invalidating the iterators
03:35:12 <ClaudiusMaximus> ippo: https://gitorious.org/maximus/gulcii/blobs/master/src/gulcii.hs#line146 is how i did it in one project
03:35:33 <ClaudiusMaximus> ippo: may have bitrotted / become deprecated
03:35:40 <ClaudiusMaximus> ippo: can't help right now, gotta dash...
03:36:00 <ippo> thank you very much, I'm taking a look right now :)
03:36:58 <ippo> thanks gtk2hs... that was so concise and elegant Oo
03:37:15 <ClaudiusMaximus> ippo: it's a bit overcomplicated as it adds tags so each line can be a different colour
03:37:45 <ippo> yes, I see it... you remove everything beforehand and reinsert with the tag
03:38:04 <ippo> I just need to do the same without the tag insertion, if I understand it
03:38:05 <basdirks_> when I have a function (Integral a) => a -> a, can I force the compiler to optimise for Int -> Int in certain cases?
03:38:06 <ClaudiusMaximus> yep, then copy the whole tagged text to the end of the real buffer
03:38:21 <ClaudiusMaximus> as i didn't figure out how to insert tagged text directly
03:38:45 <ClaudiusMaximus> basdirks_: add a type signature, and if that doesn't work, look at SPECIALIZE pragmas
03:38:45 <nand`> basdirks_: SPECIALIZE pragma
03:38:52 <ippo> thanks claudius, will try it later
03:39:02 <basdirks_> thanks ClaudiusMaximus, nand`
03:46:14 <ippo> the good news is that the iterators are not invalidated anymore
03:46:21 <ippo> the bad news is that I get a new exception -.-
03:46:32 <ippo> I'm so tempted to move to wxHaskell
03:48:49 <ousado> the struggle with GUI libraries seems to be a recurring theme here
03:49:33 <ippo> it wouldn't be so bad if at least it told me what the error is
03:49:43 <ippo> and where and when it happened
03:56:01 <peano_player> maybe someday we will have a cross-platform FRP GUI library
03:56:07 <peano_player> that's as good as Qt
04:03:46 <fujisan> peano_player:  hello
04:03:52 <fujisan> how are you peano_player
04:07:10 <fujisan> peano_player:  D:
04:07:13 <mcstar> peano_player says: What do you think?
04:07:24 <dobblego> @type let filterM' _ [] = return []; filterM' p (h:t) = p h >>= \r -> if r then liftM (h:) $ filterM' p t else filterM' p t in filterM'
04:07:25 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
04:07:34 <fujisan> mcstar and peano_player you remind me mcdonalds and sesame street
04:07:39 <mcstar> peano_player says: Can you elaborate on that?
04:07:53 <dobblego> why doesn't filterM work this way?
04:08:02 <mcstar> peano_player says: Why do you say?
04:09:10 <Saizan> ?type filterM
04:09:11 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
04:10:10 <dobblego> Saizan: I posted in #haskell-in-depth
04:11:46 <mcstar> fujisan: please, continue talking to my emacs' psychoterapist
04:13:03 <merijn> dobblego: what does it do then? if not (p h)?
04:13:22 <dobblego> @type let filterM'' _ [] = return []; filterM'' p (h:t) = p h >>= \r -> filterM'' p t >>= \s -> return $ if r then h:s else s in filterM''
04:13:23 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
04:13:26 <dobblego> merijn: it does this instead
04:17:40 <mcstar> ill kill the *doctor*, i pay be the hour..
04:17:51 <Saizan> probably no particular reason
04:18:23 <Saizan> they just overlooked the opportunity of a tail call there
04:18:51 <dobblego> tail call?
04:22:45 <Saizan> yeah, assuming (>>=) will call the second argument in a tail position the else branch will be a tail call, though i guess that's an extension of the concept
04:32:03 <lucignolo> ciao
04:36:13 <mcstar> http://attractivechaos.wordpress.com/2011/06/19/an-incomplete-review-of-sudoku-solver-implementations/
04:36:23 <mcstar> this table needs a fast haskell solver, right?
04:37:29 <mcstar> i wrote one, that would place above the fastest python one
04:37:52 <mcstar> but it uses a Map as its main data structure and relies on the immutability of it
04:38:09 * hackagebot geniplate 0.6.0.3 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.6.0.3 (LennartAugustsson)
04:41:16 <rick___> I'm having some trouble with FFI
04:41:39 <rick___> the haskell code seems to work (no error message) but the c function does not seem to be called
04:41:49 <rick___> in interface.h, I have this line
04:41:57 <rick___> void write(int num_floats, float * values);
04:42:10 <rick___> and in haskell
04:42:12 <rick___> foreign import ccall "interface.h write"
04:42:19 <rick___>     c_write :: CInt -> Ptr CFloat -> IO ()
04:42:43 <rick___> I can call c_write, but write doesn't seem to be called
04:42:45 <rick___> any ideas?
04:45:18 <mcstar> (i think they gonna require a minimum non-working example on hpaste)
05:13:06 <paolino> hello, is there some library to help map recursive datatype to GtkTreeModel ?
05:15:15 <paolino> maybe going through Tree a, as it is already supported ?
06:03:14 * hackagebot alpha 0.9.5 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9.5 (MarcCoiffier)
06:10:54 <merijn> Where should I look if I'm interested in messing with the implementation details of STM?
06:15:52 <smash> applicative: Aeson worked perfectly and without much work.. thks
06:17:48 <mietek> Has anyone tried installing yesod-platform under ghc 7.6.1?
06:20:38 <merijn> mietek: Probably *someone* has, but it seems like a huge time sink
06:20:53 <merijn> mietek: Why do you want to use 7.6 with yesod-platform?
06:21:02 <merijn> Or even "why do you want to use 7.6?"
06:26:05 <mietek> merijn: includes x86_64 crash fix for yesod dev
06:26:43 <mietek> http://hackage.haskell.org/trac/ghc/ticket/7040
06:27:01 <merijn> Hmmm, I recall using yesod dev just fine in earlier versions? Although I'm not sure whether I'm using 32bit compiler
06:27:06 <mietek> OS X
06:27:46 <merijn> mietek: Wouldn't it be easier to use the 32bit version of 7.4?
06:28:09 <merijn> 7.6 is not well supported by the library ecosystem
06:28:35 <geekosaur> 32 bit has other issues on OS X
06:28:43 <merijn> oh?
06:29:04 <mietek> merijn: perhaps it would; what's your point? Give up?
06:29:08 <merijn> I've been using 32bit GHC on OSX for a long time now and I never ran into any problems?
06:29:09 <byorgey> wouldn't it be easier to use linux?
06:29:15 <byorgey> OS X is not well supported by the Haskell ecosystem.
06:29:19 <geekosaur> briefly, if you have non-Apple-sourced libraries, they often don't include 32 bit support.  likewise anything released within the last month, because Mountian Lion killed 32 bit support
06:29:20 <merijn> byorgey: heh
06:29:37 * merijn is still on Lion
06:29:51 * byorgey is still on linux
06:30:25 <merijn> byorgey: For an OS that is supposedly not well-supported I've run into surprisingly little issues in the past two years...
06:30:42 <hpc> merijn: done any gtk work?
06:30:46 <merijn> And by surprisingly little I mean zero OS related ones
06:30:50 <hpc> or really anything ffi at all
06:30:51 <mietek> hpc: ha!
06:30:57 <merijn> hpc: No, because GUI's are for losers :)
06:31:00 <hpc> ;)
06:31:04 <byorgey> merijn: I'm glad!
06:31:06 <merijn> hpc: Haven't had any issues with the FFI yet?
06:31:24 <merijn> What would be going wrong according to you?
06:32:19 <merijn> mietek: My point was that yesod probably won't be fixed for 7.6 until Haskell Platform ships with 7.6 (ok, maybe earlier, but not something I would count on happening very soon)
06:33:59 * gienah has snap, happstack and yesod installed with ghc 7.6.1
06:34:13 <adnauseam> gienah: howto, howto
06:34:30 <hpc> darcs?
06:34:41 <gienah> anonus: emerge dev-haskell/snap dev-haskell/yesod-platform dev-haskell/happstack
06:34:55 <mietek> Right
06:34:59 <gienah> oops wrong nick
06:35:51 <mietek> I always thought emerge was nice
06:35:59 <mietek> Certainly gives better error messages than
06:36:02 <mietek> Cabal
06:36:14 <mietek> http://pastie.textmate.org/private/rqse2rnvfexcgqqtbdnesa
06:36:35 <gienah> adnauseam: they all build fine in the gentoo haskell overlay, if you have problems with some package then there are likely to be patches in the files sub-directories https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell
06:40:20 <adnauseam> gienah: i'll check it out! i plan on setting up yesod on my vps
06:41:58 <gienah> adnauseam: from memory I thought yesod just built fine with ghc 7.6.1 without needing to do anything
06:44:08 <adnauseam> gienah: oh that's good news!
06:45:39 <nand`> anybody know when the next GLUT release can be expected? the git version has patches for 7.6.1 compatibility already
06:45:53 <nand`> and that was a month ago
06:49:20 <nand`> oh never mind, I forgot I already had the git version installed. Which means gloss 1.7.6.5 builds on GHC 7.6.1 :D
06:54:10 <gienah> mietek: for that you need to loosen the stringsearch dep in yesod-platform, stringsearch-0.3.6.4 builds fine
06:54:48 * gienah changes the == deps to >= in yesod-platform and uses the latest versions
06:56:40 <mietek> gienah: thanks, I'm currently building yesod alone
07:10:12 <srhb> §§
07:13:32 <merijn> Using unsafeIOtoSTM on threadWaitRead and threadWaitWrite should be safe, right?
07:14:29 <merijn> Although now I think about it, I'm not sure whether that's as useful as I initially thought >.>
07:18:30 <merijn> There's no way to race two (or more) blocking IO operations and pick the result of whichever returns first, right? (Well, at least without doing forkIO per operation, and having the threads write the result to a Chan/MVar)
07:19:52 <sheriff_> Given: data Moo = Mood
07:19:58 <sheriff_> Mood is a data constructor
07:19:59 <sheriff_> If I then say:
07:20:03 <sheriff_> foo = Mood
07:20:05 <sheriff_> What's foo?
07:20:15 <paolino> a value
07:20:15 <sheriff_> Also a data constructor? An instance of Mood? An alias to Mood?
07:20:24 <merijn> sheriff_: A function
07:20:33 <merijn> Data constructors are functions to, FYI
07:21:00 <merijn> Eh
07:21:01 <merijn> Wait
07:21:04 <merijn> foo is a value
07:21:13 <paolino> which can be an evaluated value or a thunk waiting to be evaluated
07:21:18 <merijn> I was thinking Mood took another argument, which is not true in your example
07:21:45 <sheriff_> A value that's an instance of Moo, created using Mood?
07:22:07 <merijn> sheriff_: A value that has type Moo
07:22:13 <paolino> it evaluates to Mood
07:22:19 <merijn> The specific value being Mood in this case
07:22:28 <sheriff_> OK
07:22:37 <merijn> sheriff_: Like 1 is a value of type Int
07:22:42 <byorgey> sheriff_: we usually reserve the word "instance" for types which are instances of type classes
07:22:53 <sheriff_> byorgey: OK, thanks
07:23:01 <byorgey> sheriff_: instead of "x is an instance of the type X" we just say "x has type X"
07:26:05 <merijn> Man, I want "threadWaitReads :: [Fd] -> IO Fd" and "threadWaitWrites :: [Fd] -> IO Fd" or something :(
07:26:51 <merijn> Or some easy way to integrate blocking IO with STM...
07:27:27 <fryguybob> merijn: Have you seen "transactional events"
07:27:37 <fryguybob> I'm not sure it is what you are looking for, but it might be related.
07:27:39 <hpc> "blocking IO" sounds pretty much entirely incompatible with STM
07:27:42 <hpc> :P
07:28:06 <monochrom> atomically (do { x <- readTVar v; if x==0 then retry ... }) should block
07:28:12 <fryguybob> http://www.cs.rit.edu/~mtf/research/tx-events/index.html
07:28:33 <monochrom> "transactional event" sounds cool :)
07:29:58 <merijn> hpc: I want to "block until either this STM succeeds OR this blocking call returns"
07:31:20 <merijn> fryguybob: That looks like it's exactly what I want, if I can use something like that without being stuck with their message passing
07:31:49 <merijn> Synchronous channel's :\
07:32:03 <fryguybob> I think Edward Amsden hangs out here as fmapE?
07:32:24 <merijn> Looks like it won't work for me as-is
07:32:26 <Clint> jaspervdj: okay, thanks
07:33:02 * fryguybob should organize some Rochester Haskell group...
07:33:05 <merijn> It provides more guarantees than I need at the cost of functionality I need...
07:34:52 <merijn> My main problem is that if I have incoming Chans, sockets, whatever, I can't do anything until I get a message that unblocks me
07:35:15 <merijn> For Chan that is easily solved by using TChan, but there's no TSocket, unfortunately :\
07:35:40 <paolino> merijn, doSTM `orElse` readTChan channelOfIOActionComplete
07:36:23 <merijn> The usual solution people propose is to have a thread read from socket and write to a TChan, but that doesn't work if I need to write back to the same socket
07:36:51 <merijn> Like paolino :p
07:36:56 <paolino> :)
07:37:41 <merijn> paolino: That won't work because the thread reading from the socket needs to also write back to it (I'm using ZeroMQ sockets which are not threadsafe, so I can't have multiple forkIO threads using the same socket)
07:38:22 <merijn> So then I just move the problem to the thread that reads from the socket having to block on reading the socket and not being able to detect new messages that should be written to it
07:39:26 <paolino> merijn, write to the socket from stm thread
07:39:49 <merijn> paolino: If I do do that the STM thread also has to be the one reading from the socket
07:39:58 <merijn> paolino: So then I *still* get blocked on reading the socket
07:40:48 <merijn> I don't see a solution without being able to poll both a (T)Chan *and* an Fd
07:42:43 <hpc> if you're feeling silly, you can have two threads feeding into the same MVar, read by a third thread (which kills both children when it gets a thing from one)
07:43:18 * hackagebot stm-delay 0.1 - Updatable one-shot timer polled with STM  http://hackage.haskell.org/package/stm-delay-0.1 (JoeyAdams)
07:43:20 <merijn> hpc: Yeah, but that seems *highly* inefficient
07:43:34 <JoeyA> How is that inefficient?
07:44:02 <JoeyA> I don't know how to benchmark this, but I think forkIO takes roughly 0.1 microseconds.
07:44:05 <hpc> it's pretty basic and low-overhead, honestly
07:44:19 <hpc> just very explicit and annoying to write
07:44:20 <merijn> hmm, might be right
07:44:20 <sm> merijn: how about http://hackage.haskell.org/packages/archive/async/2.0.1.3/doc/html/Control-Concurrent-Async.html#v:race
07:44:58 <merijn> sm: I love you
07:45:22 <merijn> Maybe race isn't exactly what I need, but the entire package looks promising
07:45:27 <sm> love simon marlow :) this is also great: http://skillsmatter.com/podcast/home/high-performance-concurrency
07:45:47 <JoeyA> Just bear in mind that killThread will block if the target thread is making an FFI call.
07:45:59 <JoeyA> Network I/O is implemented with FFI calls on Windows.
07:46:16 <JoeyA> ∴ killThread can't be used to timeout network I/O on Windows
07:46:34 <merijn> I don't think that holds for all FFI, though
07:46:38 <hpc> that's okay if you have a built-in timeout/loop with network primitives
07:46:45 <hpc> like hWaitForInput
07:47:07 <merijn> Oh wait, maybe it does
07:47:15 <merijn> ZeroMQ bindings block in haskell, not FFI
07:47:19 <merijn> I forgot
07:48:40 <merijn> Problem solved: async has waitSTM
07:48:47 <merijn> Which is "Async a -> STM a"
07:49:08 <merijn> After that step it is trivial to mix it with TChan, etc
08:14:49 <sm> if I want to efficiently look upward as well as downward from a node in a tree.. do I want a zipper ?
08:15:10 <hpc> yes
08:15:34 <sm> yay.. now to find some simple examples
08:16:01 <sm> http://www.haskell.org/haskellwiki/Zipper excellent
08:16:06 <hpc> LYAH has one with a directory tree
08:16:13 <hpc> yeah, that
08:16:21 <sm> thanks
08:18:22 <sm> and http://hackage.haskell.org/packages/archive/rosezipper .. just the thing
08:21:19 <byorgey> sm: alternatively, if you just want a static tree that you don't need to modify, you could do something clever with knot-tying.
08:21:26 <byorgey> but I guess that scenario is probably rare.
08:34:26 <paolino> I'd like to modify a recursive datatype in a GUI, any idea on the interface, aside Gtk TreeStore ?
08:38:53 <hpc> if you happen to have a way of observing sharing, there's an existing library that displays data structures
08:38:56 <sm> byorgey: that could be a possibility, especially if it turns out simple. I'm refactoring account tree handling in hledger. Currently that data is immutable
08:39:02 <hpc> which you could insert controls for
08:39:05 <sm> s/simple/simpler/
08:39:18 <hpc> i forget the name, but it's used a lot on stackoverflow
08:39:59 <byorgey> sm: yeah, if you just want to create a static tree once and then traverse it quickly, knot-tying might be simpler
08:41:12 <byorgey> data Knotty a = Empty | Knot a (Knotty a {- parent -}) (Knotty a {- child1 -}) (Knotty a {- child2 -}) -- for example
08:41:20 <byorgey> let me code up an example quick
08:43:07 <sm> something like Account2 at https://gist.github.com/3885049 ?
08:43:44 <paolino> hpc, I cannot find it, any more words to look for ?
08:45:38 <hpc> uh
08:46:30 <hpc> no idea :(
08:47:22 <sm> or like http://hub.darcs.net/simon/hledger/browse/hledger-lib/Hledger/Data/Transaction.hs#358
08:47:53 <ClaudiusMaximus> hpc: you weren't thinking of vacuum-cairo?
08:48:31 <ClaudiusMaximus> but that sucks directly from the ghc heap...
08:48:35 <hpc> that's exactly it
08:49:22 <hpc> you probably wouldn't be using vacuum itself, but that style of display would work perfectly
08:51:26 <hpaste> “Brent Yorgey” pasted “creating a knotty tree with O(1) access to parents” at http://hpaste.org/76227
08:51:50 <byorgey> hpc: there
08:52:02 <byorgey> hpc: there's vacuum-cairo, but also the newer ghc-vis
08:52:41 <byorgey> sm: see that hpaste for the general idea.  That has some code to convert a tree without parent links into a tree with parent links, using recursion to create a shared cyclic structure in memory
08:52:57 <byorgey> I'm installing ghc-vis to try to visualize an example now
08:54:48 <Trudko> is show function used for same purpose as toString in java?
08:54:53 <Trudko> to convert something to string?
08:55:27 <Trudko> read
08:55:43 <Trudko> ...is used also for conversion?
08:56:00 <paolino> is'a valid serialization
08:56:07 <MagneticDuck> I wish someone would write a tutorial from grapefruit
08:56:13 <MagneticDuck> =(
08:56:16 <MagneticDuck> *for
08:57:27 <MagneticDuck> I tried reactive-banana, but I can't get wxHaskell to install on linux
08:57:43 <MagneticDuck> so I must continue my search for a FRP setup that works
08:57:47 <MagneticDuck> and has documentation
08:57:54 <sm> byorgey: nice, thanks!
08:58:20 <sm> would it make sense to keep using Tree of these, for the standard tree functions and possibly later zipperising ? I think not, Tree would no longer add much
08:58:37 <Daroth> hi
08:58:55 <MagneticDuck> hi!
08:58:56 <siracusa> MagneticDuck: Grapefruit is still very experimental, and I think Wolfgang is working on a major overhaul which would probably cause lots of API changes
08:58:56 <MagneticDuck> x|
08:59:05 <MagneticDuck> yeah I heard
08:59:08 <MagneticDuck> so I might as well wait
08:59:19 <MagneticDuck> what's a really good stable FRP with documentation?
08:59:27 <Daroth> is there a way to see classtype implementation for a given type in ghci ?
08:59:36 <MagneticDuck> it would have to have a gtk2hs backend
08:59:47 <MagneticDuck> because it's one of the few I can get to work on ubuntu
09:00:01 <MagneticDuck> err
09:00:08 <MagneticDuck> Daroth: ":i ___"?
09:00:20 <MagneticDuck> that lists the instances a certain data type has
09:00:58 <byorgey> sm: yeah, I doubt it
09:01:12 <Daroth> MagneticDuck: yep, but for exemple, :i Function give me instance Functor Maybe -- Defined in Data.Maybe
09:01:17 <monochrom> what is classtype? but in any case, ghci seldom shows implementations
09:01:30 <Daroth> what if i want to know what is "inside" instance Functor Maybe
09:01:32 <Daroth> ?
09:01:44 <MagneticDuck> ah
09:01:47 <MagneticDuck> go on hackage?
09:01:51 <MagneticDuck> I don't really know
09:01:57 <Clint> you want to know how fmap is defined?
09:02:00 <MagneticDuck> you can always find the code on hackage
09:02:12 <MagneticDuck> *hayoo
09:02:21 <Daroth> Clint: exactly
09:02:41 <MagneticDuck> Daroth: go on hayoo
09:02:45 <MagneticDuck> search for the data type
09:02:54 <MagneticDuck> and you'll see all the instances it's implemented in
09:02:59 <MagneticDuck> you can click to find the code
09:03:04 <Daroth> (i actually want to know if it possible to do directly on ghci, i'm already aware of hoogle and hayoo & others)
09:03:18 <MagneticDuck> okay
09:03:22 <Enigmagic> @src Maybe fmap
09:03:22 <lambdabot> fmap _ Nothing       = Nothing
09:03:22 <lambdabot> fmap f (Just a)      = Just (f a)
09:03:23 <MagneticDuck> yeah, I don't think so
09:03:46 <MagneticDuck> good 'ol lambdabot
09:03:56 <MagneticDuck> I'm sure there's an extension for ghci though...
09:04:04 <Daroth> well, good enough, thanks buddies :)
09:04:16 <MagneticDuck> de nada
09:05:33 * MagneticDuck wonders if there is, somewhere out there, the perfect FRP library for him
09:05:39 <byorgey> sm: https://gist.github.com/3885121
09:05:40 <MagneticDuck> :')
09:05:43 <MagneticDuck> I can always dream
09:06:37 <donri> it seems haddock 2.10 fails for docs on GADTs, is this fixed in a newer version?
09:06:37 <preflex>  donri: you have 2 new messages. '/msg preflex messages' to read them.
09:06:41 <byorgey> MagneticDuck: yes.  When you meet it, you will Just Know.  It will be love at first sight.
09:06:49 <byorgey> MagneticDuck: however, the love may vary continuously with time
09:07:22 <MagneticDuck> =D
09:07:50 <MagneticDuck> because Love is not an Event, it's a stream
09:10:11 <byorgey> haha, so true
09:10:15 <byorgey> Love is not an Event, it's a Behavior
09:10:27 <MagneticDuck> but a stream, or a Behavior..
09:10:44 <MagneticDuck> a continuous data type by any other name would map the same
09:10:48 <MagneticDuck> <3
09:10:51 <byorgey> hehehe
09:13:12 <MagneticDuck> O Functoreo, Functoreo! where art thou Functoreo!
09:13:19 <sm> I often get confused about memoisation and efficiency. With Account in http://hpaste.org/76227 , apostings is primary data and aebalance is derived from it when I construct the value. I think this is useful memoisation, and if I didn't have aebalance, every time I called sum . apostings acct that calculation would be repeated - am I right ?
09:13:31 <MagneticDuck> Deny thy instance and refuse thy incorrect parallel with category theory!
09:13:57 <byorgey> sm: right.
09:14:33 <paolino> donri, http://trac.haskell.org/haddock/ticket/43#comment:12
09:14:54 <MagneticDuck> "reactive"
09:14:56 <MagneticDuck> hmm
09:14:59 <MagneticDuck> sounds very original
09:15:08 <donri> paolino: ah, thanks
09:15:12 <parcs`> hpc: are you talknig about data-reify?
09:15:16 <sm> and thanks to laziness, if I never use aebalance there's probably no cost to doing it there at value creation
09:15:29 <sm> the calculation won't happen in that case
09:15:31 <byorgey> sm: correct.
09:15:35 <sm> great
09:17:10 <cmccann> hm
09:17:31 <cmccann> I seem to have invented a data type which can be pattern matched but never constructed
09:17:47 <cmccann> sounds useful
09:19:16 <MagneticDuck> O.o
09:19:19 <MagneticDuck> ah
09:19:28 <MagneticDuck> you don't export constructors?
09:19:41 <MagneticDuck> or, are you doing math again?
09:19:54 <ClaudiusMaximus> hm
09:19:57 <ClaudiusMaximus> @src Complex
09:19:58 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
09:20:10 <cmccann> no, I mean a visible constructor that's impossible to use for constructing anything
09:20:22 <ClaudiusMaximus> so, if you don't export the class you use for something like that...
09:20:23 <cmccann> which is not quite what I was trying to accomplish
09:20:24 <MagneticDuck> ...post code
09:20:42 <ClaudiusMaximus> (but that's Old Haskell, not Haskell)
09:21:35 * cmccann is still tinkering with the code trying to do something more interesting
09:22:22 <Trudko> guys i alwas get something else when calling lucky why is that ? http://pastebin.com/7dgpitRF
09:22:26 <maukd> The paste 7dgpitRF has been copied to http://hpaste.org/76230
09:23:06 <paolino> Trudko, you are in IO monad
09:23:57 <Trudko> what do you mean?
09:25:09 <paolino> you assign different values to lucky
09:25:13 <MagneticDuck> you know what the IO monad is?
09:25:58 <Trudko> no
09:26:08 <Trudko> and how would i define it as pattern matching?
09:26:09 <MagneticDuck> write it like this: "let lucky 1 = "1"; lucky 2 = "2"; lucky _ = "something else""
09:26:14 <MagneticDuck> ^
09:26:29 <MagneticDuck> also, please, don't write functions in ghci
09:26:31 <MagneticDuck> it's..
09:26:33 <MagneticDuck> it's just bad
09:26:36 <MagneticDuck> ;D
09:26:50 <Trudko> i see i just used what was wrrite in lyh
09:26:51 <paolino> mh, maybe I got it also wrong, but define lucky in the same let binding as MagneticDuck says
09:26:55 <Trudko> what else should i wrong/
09:27:01 <Trudko> should I use
09:27:08 <MagneticDuck> just what I wrote
09:27:13 <MagneticDuck> you have to keep it in one let box
09:27:15 <Trudko> instead of ghci
09:27:21 <MagneticDuck> erm
09:27:24 <MagneticDuck> a code file
09:27:29 <MagneticDuck> just make Main.hs
09:27:32 <MagneticDuck> and write stuff
09:27:36 <Trudko> and then load i see
09:27:38 <MagneticDuck> and then ":l Main.hs"
09:27:57 <MagneticDuck> I do NOT recommend using ghci to do work
09:28:00 <MagneticDuck> or even testing stuff
09:28:03 <MagneticDuck> erm
09:28:10 <MagneticDuck> I mean, making functions and testing them
09:28:11 <MagneticDuck> in ghci
09:28:25 <MagneticDuck> not until you learn about the IO monad
09:28:30 <MagneticDuck> because it can be confusing
09:28:55 <MagneticDuck> btw, do you come from a procedural language?
09:29:05 <Trudko> so meanwhiole i will use external file?
09:29:10 <MagneticDuck> yeah
09:29:13 <Trudko> yes I do come from java/javascript
09:29:14 <MagneticDuck> you write code, and load it
09:29:16 <MagneticDuck> ah
09:29:24 <MagneticDuck> you've probably been told this....
09:29:32 <MagneticDuck> but forget it all
09:29:33 <MagneticDuck> :D
09:29:41 <MagneticDuck> haskell is different
09:29:57 <hpaste> ClaudiusMaximus pasted “security via deprecation” at http://hpaste.org/76232
09:30:12 <MagneticDuck> the problem is that you're kind of writing "let lucky 1 = "1" in (let lucky 2 = "2" in (let lucky _ = "something else))
09:30:27 <MagneticDuck> so, previous definitions are shadowed
09:30:35 <Trudko> yeah i know that but i still try to compare what i see in haskell to compare it to java, but in sense that if I would wanna do this in java/js  how it would look like so i can see what is different.
09:30:57 <Trudko> yeah that make sense i was confused about this but i just wrote what I saw in lyh
09:31:06 <MagneticDuck> the problem is that you're kind of writing "let lucky 1 = "1" in (let lucky 2 = "2" in (let lucky _ = "something else in .........))
09:31:42 <Trudko> what if i dont want to load hs files always ower and ower
09:31:48 <Trudko> some simple IDE?
09:31:49 <MagneticDuck> why not?
09:31:52 <MagneticDuck> erm
09:31:53 <chrisdone> ( ^_^)／
09:31:54 <ClaudiusMaximus> Trudko: :r in ghci reloads
09:31:55 <MagneticDuck> you can do ":r"
09:31:57 <MagneticDuck> yeah
09:32:06 <Trudko> because I am lazy as hell  and I am used to using IDE :D
09:32:06 <ClaudiusMaximus> and  :e edits
09:32:12 <MagneticDuck> and once you get going, there's buildwrapper + EclipseFP
09:32:17 <cmccann> ClaudiusMaximus, haha, that's great
09:32:25 <ClaudiusMaximus> cmccann: :D
09:32:34 <MagneticDuck> Trudko: don't worry, we have our share of awesome IDEs
09:32:36 <MagneticDuck> ...right guys?
09:32:37 <MagneticDuck> =|
09:32:44 <MagneticDuck> lol, at least we have EclipseFP
09:32:53 <cmccann> in fact that may be the first time I've seen data type contexts that might actually be useful!
09:33:01 <ClaudiusMaximus> cmccann: hehe
09:33:24 <sm> byorgey: in tie, did you use let ... in.. to enforce strictness ?
09:33:26 <MagneticDuck> Trudko: have fun! You'll learn to love our crazy little world
09:33:28 <monochrom> in a java IDE, you click "save" over and over.
09:33:32 <MagneticDuck> haha
09:33:34 <MagneticDuck> or..
09:33:38 <MagneticDuck> ctrl+s
09:33:39 <MagneticDuck> :O
09:33:40 <ClaudiusMaximus> rather than "annoying as hell that i can't use Data.Complex because I don't have RealFloat, and that won't change because of Num.abs"
09:34:04 <MagneticDuck> okay, be back in 50 mins
09:34:08 <ClaudiusMaximus> > abs (1:+1)
09:34:09 <byorgey> sm: no, I used it to create the sharing
09:34:10 <lambdabot>   1.4142135623730951 :+ 0.0
09:34:10 <MagneticDuck> group theory learnage
09:34:17 <monochrom> the dark secret is that "save" is configured to not just save, but also recompiles
09:34:20 <byorgey> sm: note how the definition of acct refers recursively to acct
09:34:36 <byorgey> sm: that's the whole trick =)
09:34:49 * MagneticDuck is away: group theory rules
09:35:05 <monochrom> group therapy for group theory victims
09:35:14 <ClaudiusMaximus> monochrom: sounds like what i set up in 'clive' - "ctrl-o return" in nano saves, meanwhile a script watches for changes and recompiles/reloads/gitcommits/etc
09:35:29 <cmccann> ClaudiusMaximus, the code I'm tinkering with amounts to the same thing, except using multiple confusing extensions instead of a deprecated one and scoping rules
09:35:42 <ClaudiusMaximus> cmccann: :)
09:35:43 <sm> oh of course, thx
09:35:59 <sm> I was all about to refactor it away
09:36:02 <cmccann> since I'm trying to do something a bit more subtle than just "impossible to construct"
09:36:16 * sm is not to smart at this time of morning apparently
09:36:35 <byorgey> sm: well, if you tried you probably would have realized, because you can't refactor it away (due to the recursive occurrence of acct)
09:36:46 <sm> I hope so :)
09:36:58 <byorgey> =)
09:37:05 <Trudko> monochrom yes you use a lot ctrl+s so?
09:37:10 <merijn> I have a question about async's semantics, any one here knowledgeable on its implementation details or do I need to bug SimonMarlow if I can't grok the code details myself?
09:37:23 <sm> and if not, GHC would have smacked me. We totally need to use haskell where I work
09:38:26 * cmccann is trying to create a data structure that can be pattern-matched and reassembled exactly as given, but not reassembled in any other way
09:38:32 <byorgey> sm: right, that's what I mean, it wouldn't have compiled =)
09:38:42 <monochrom> just pointing out "over and over" ain't bad
09:38:49 <byorgey> and then you would have been enlightened
09:38:57 <MagneticDuck> monochrom: GROUP THEORY RULES! *foaming at mouth*
09:39:14 <cmccann> (without needing horrendous syntax, ideally)
09:39:29 <ClaudiusMaximus> cmccann: that vaguelly reminds me of some presentation about "correct spelling in haskell", will see if i can find it
09:39:59 <cmccann> that'd be awesome
09:40:04 <byorgey> cmccann: do you want to allow constructing values of this type at all?
09:40:12 <Eduard_Munteanu> cmccann: create a view into the data structure, along with conversion functions?
09:41:18 <byorgey> cmccann: I really don't understand what you're trying to accomplish.
09:41:29 <cmccann> byorgey, oh yeah, that wasn't very clear
09:41:45 <cmccann> also I'm mostly tinkering, not accomplishing anything in particular, heh
09:42:29 <cmccann> but the idea is that for a type T, you can write functions (T -> T) which are subject to the above limitation in a type-enforced way
09:42:46 <cmccann> or you can discard the limitation and just construct/pattern match normally
09:43:18 <byorgey> cmccann: oh, I think I get it now
09:43:24 <merijn> waitSTM in Async can potentially lose information when composing STM, no?
09:43:37 <cmccann> so that if a function requires as an argument a function with that limitation, it knows that function can only do certain things to its input
09:44:04 <cmccann> it's a sort of extremely baroque generalization of how runST works
09:44:25 <chrisdone> monochrom: http://www.youtube.com/watch?v=xpseFECPeQE
09:44:36 <monochrom> hmm what's that?
09:44:51 <byorgey> cmccann: I actually still don't understand the limitation though.  If all you can do is deconstruct and then reconstruct exactly as given, what can you write that isn't the identity function?
09:45:31 <cmccann> byorgey, or extract pieces of the structure
09:45:38 <byorgey> oh, I see
09:45:40 <cmccann> this is mostly interesting in the context of a recursive type
09:46:10 <cmccann> and I'm then extending it with a way of relaxing that restriction in a marked way
09:46:24 <chrisdone> monochrom: a mode i'm working on :) no more tabbing, no more indentation cycles, just editing!™
09:46:56 <byorgey> cmccann: how about this: make T' isomorphic to T, and don't export constructors for T'.  Just export a function which takes a T' and a continuation which is given a deconstructed T' and can decide which (allowable) thing(s) to do
09:47:00 <monochrom> foobedoo
09:47:09 <sheriff_> Given: let {x = 5; y = let z = 9 in z + 6} in x + y
09:47:16 <sheriff_> In order to resolve that, does `in` have a precedence?
09:47:24 <cmccann> byorgey, yes, that's one of the more obvious approaches
09:47:37 <sheriff_> If so, how can I find the value or its precedence?
09:47:44 <cmccann> I'm making this needlessly difficult by trying to allow pattern matching, because it looks nicer
09:47:54 <cmccann> this is where the "not really aiming to accomplish something specific" part comes in
09:47:56 <byorgey> I see
09:47:59 <byorgey> hehe
09:48:12 <rwbarton> sheriff_: 'in' doesn't have "precedence"
09:48:31 <rwbarton> what happens is that since you don't have a { after the token 'let', layout applies
09:48:41 <rwbarton> the second let, that is
09:48:56 <cmccann> byorgey, as well as just seeing what I can accomplish with these sort of restrictions
09:49:06 <sheriff_> rwbarton: OK. Presumably there is a rhyme and reason to how it's deciding what the (+ 6) is applying to
09:49:12 <rwbarton> when 'in' is encountered, since it would be an error otherwise, a } is inserted before it so you get let { x = 5; y = let { z = 9 } in z + 6 } in x + y
09:49:18 <rwbarton> oh
09:49:21 <byorgey> cmccann: right, sounds interesting
09:49:25 <rwbarton> uh, hmm
09:49:32 <rwbarton> I see what you are saying now
09:49:57 <rwbarton> I think what comes after "in" always extends as far as possible
09:50:12 <sheriff_> That would imply that 'in' has very weak precendece...
09:50:40 <sheriff_> and everything binds tighter than it does
09:51:02 <sheriff_> Which is fine, but I'm trying to find something I can cite that says that
09:51:15 <rwbarton> well, http://www.haskell.org/onlinereport/exps.html is the place to look
09:51:26 <rwbarton> or the 2010 version
09:51:30 * sheriff_ takes a look
09:51:43 <cmccann> byorgey, the general motivation is stuff like type-enforced resource controls and such, again along the lines of why runST works
09:52:15 <dabrahams> I'm in a function returning  IO [ Text ], but I have an [ IO Text ]. How to get from one to the other?
09:52:16 <sheriff_> " Expressions that involve the interaction of fixities with the let/lambda meta-rule may be hard to parse"
09:52:20 <sheriff_> Yah.
09:52:21 <rwbarton> > let { z = 9 } in z + z
09:52:22 <lambdabot>   18
09:52:30 <sheriff_> "Programmers are advised to avoid constructs whose parsing involves an interaction of (lack of) associativity with the let/lambda meta-rule."
09:52:36 <rwbarton> aha, yeah
09:52:40 <rwbarton> "The grammar is ambiguous regarding the extent of lambda abstractions, let expressions, and conditionals. The ambiguity is resolved by the meta-rule that each of these constructs extends as far to the right as possible."
09:52:44 <sheriff_> scumbag specification
09:53:16 <sheriff_> I think I can use this as justification for always surrounding the part after it in parentheses
09:53:50 <rwbarton> I would rather always enclose the let-expression itself in parentheses when it is part of a larger expression
09:54:05 <sheriff_> That seems reasonable too
09:54:06 <rwbarton> if this is just a coding style thing
09:54:26 <chrisdone> parens everywhere!
09:54:26 <sheriff_> This is homework, and I think I'm several degrees beyond over-engineering it at this point :-P
09:54:36 <merijn> dabrahams: sequence
09:54:40 <merijn> :t sequence
09:54:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:54:43 <sheriff_> So I'll just quote that and use it as justification
09:54:43 <sm> is there a way to define a string literal based on a CPP variable, if the var contains just the string value and not the double quotes ?
09:54:48 * cmccann mostly regards using let inside a lambda as a sign that it's time to not use a lambda there
09:55:02 <rwbarton> > (reverse . let f = id in f) [1,2,3]
09:55:04 <lambdabot>   [3,2,1]
09:55:13 <rwbarton> > (reverse . \f -> f) [1,2,3]
09:55:15 <lambdabot>   [3,2,1]
09:55:25 <maukd> sm: with the actual C preprocessor, yes. I'm not so sure about the Haskell version
09:55:39 <maukd> #define STR(X) STR_(X)
09:55:43 <rwbarton> I guess there is "forM_ xs $ \x -> do ..."
09:55:43 <maukd> #define STR_(X) #X
09:55:44 <cmccann> or really any sort of inline let
09:55:55 <rwbarton> where one doesn't write parens around the lambda
09:56:33 <rwbarton> for some reason (f . \x -> y) looks odd to me while (f $ \x -> y) looks fine, heh
09:57:03 <maukd> write more Perl :-)
09:57:33 <cmccann> rwbarton, reading $ as syntax instead of an operator? :P
09:57:38 <shachaf> > (sin + \x -> x) 1
09:57:40 <lambdabot>   1.8414709848078965
09:57:41 <rwbarton> maybe
09:57:45 * sheriff_ spents the afternoon writing code to typeset his LHS/Markdown mix in to PDF using Perl
09:57:49 <ClaudiusMaximus> cmccann: can't find it...
09:57:57 <sheriff_> pandoc was not enough
09:57:57 <cmccann> ClaudiusMaximus, :[ thanks anyway
09:58:00 <rwbarton> another thing is that I could imagine continuing (f . \x -> y . g) -- but now I need parentheses
09:58:20 <maukd> yeah, left-precedence vs. right-precedence
09:58:26 <shachaf> Right, $ has the same "extending all the way to the right" property as \
09:58:36 <shachaf> Which . doesn't, despite being infixr.
09:58:50 <dabrahams> merjin: thanks, you saved me some hair
09:59:00 <shachaf> I still want (f \x -> x) :-(
09:59:27 <cmccann> for extra fun, add some type annotations to these expressions
09:59:35 <cmccann> and try to figure out which expression they apply to
09:59:49 <sm> maukd: thanks for the pointer, I'll play around with it
10:00:06 <Eduard_Munteanu> Mm, why wouldn't (f \x -> x) parse?
10:00:19 <maukd> e.g. STR_(EXIT_SUCCESS) should be "EXIT_SUCCESS" while STR(EXIT_SUCCESS) should be "0"
10:00:21 <c_wraith> type annotations extend to the entire preceding expression.  So you just need to know what syntactically bounds expressions.
10:00:35 <maukd> c_wraith: ->
10:00:37 <monochrom> yeah, I really like (f \x -> x), too
10:00:59 <ion> Also (foo do bar; baz)
10:01:00 <shachaf> Also (f do ...) and such.
10:01:06 <c_wraith> maukd: or = or , or other things
10:01:15 <Eduard_Munteanu> :t id \x -> x
10:01:16 <shachaf> Does it make something ambiguous to allow that?
10:01:16 <lambdabot> parse error on input `\'
10:01:22 <maukd> f . \x -> x :: () -> ()
10:01:44 <sm> but I think ghc's cpp doesn't recognise #, as you hinted
10:01:48 <ion> I also want (:: Foo) to be sugar for (id :: Foo -> Foo)
10:01:55 <ion> show . (:: Integer) . read
10:02:06 <shachaf> GHC's CPP is a bit old-fashioned.
10:02:23 <maukd> s/old-fashioned/broken/
10:02:28 <rwbarton> it would require rejiggering the Report grammer a bit
10:02:30 <shachaf> #define STR(X) "X"
10:02:39 <rwbarton> because currently "f x" is the same category of thing as "let ... in ..."
10:02:54 <rwbarton> and we cannot have "f g x" mean both "(f g) x" and "f (g x)"
10:02:56 <cmccann> :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
10:02:58 <lambdabot> (Int -> Int) -> Int -> Int
10:03:05 <rwbarton> wat
10:03:06 <cmccann> parse THAT
10:03:08 <sm> hmm, http://www.haskell.org/pipermail/glasgow-haskell-users/2009-October/017925.html
10:03:21 <ion> cmccann: hah
10:03:26 <rwbarton> :t \x -> x :: Int :: Int
10:03:27 <lambdabot>     The lambda expression `\ x -> ...' has one argument,
10:03:27 <lambdabot>     but its type `Int' has none
10:03:27 <lambdabot>     In the expression: \ x -> x :: Int :: Int
10:03:30 <rwbarton> fascinating
10:03:37 <monochrom> hahaha cmccann++
10:03:56 <c_wraith> looks like type ascriptions syntactically terminate expressions.
10:03:56 <sm> shachaf: doesn't work
10:03:58 <shachaf> @quote rwbarton inference
10:03:59 <lambdabot> rwbarton says: type inference is supposed to be the compiler's job, not the reader's job
10:04:05 <shachaf> s/type inference/parsing/
10:04:12 <cmccann> :D
10:04:14 <maukd> oh god
10:04:14 <rwbarton> haha
10:04:37 <monochrom> cmccann has the deepest understanding of haskell grammar
10:04:39 <maukd> @remember cmccann :t \f -> \x -> f x :: Int :: (Int -> Int) :: (Int -> Int) -> Int -> Int
10:04:40 <otters> I can't believe if' isn't in the standard library
10:04:40 <lambdabot> It is forever etched in my memory.
10:04:40 * shachaf didn't know about that particular behavior of ::
10:04:42 <otters> are there plans to add it
10:04:55 <rwbarton> :t \x -> (x :: Int) :: Int
10:04:57 <lambdabot> Int -> Int
10:05:29 <cmccann> and yeah, it's actually pretty simple what's going on there
10:05:34 <c_wraith> :t \x -> x :: Int :: Int -> Int
10:05:35 <lambdabot> Int -> Int
10:05:41 <cmccann> once you get past the "wtf" at how it looks
10:05:48 <c_wraith> seems pretty clear
10:06:03 <rwbarton> if we had f \x -> x then we would also have lovely syntax like f let in g x -- look ma no parens
10:06:10 <cmccann> an interesting detail though
10:06:11 <rwbarton> f do g x
10:06:33 <shachaf> f let in do g x
10:06:36 <cmccann> is that (\f -> \x -> f x)  and (\f x -> f x) aren't the same in that expression
10:06:46 <maukd> f do x :: Int
10:06:57 <rwbarton> > do 3 :: Int
10:06:58 <lambdabot>   3
10:07:03 <cmccann> because each :: terminates one lambda
10:07:19 <rwbarton> > f (g x) :: Expr
10:07:20 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:07:21 <lambdabot>    `GHC.Show.Show t'
10:07:21 <lambdabot>      a...
10:07:57 <maukd> > (\f g -> f (g x) :: Expr) f g
10:07:59 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:07:59 <lambdabot>    `SimpleReflect.FromExpr ...
10:08:04 <rwbarton> :t ?f (?g ?x)
10:08:05 <lambdabot> forall t t1 t2. (?x::t2, ?g::t2 -> t, ?f::t -> t1) => t1
10:08:12 <rwbarton> :t ?f (?g ?x) (?h ?y)
10:08:13 <lambdabot> forall t t1 t2 t3 t4. (?y::t4, ?h::t4 -> t1, ?x::t3, ?g::t3 -> t, ?f::t -> t1 -> t2) => t2
10:08:15 <maukd> > (\f g -> f (g x) :: Expr) f f
10:08:16 <lambdabot>   Ambiguous type variable `t' in the constraints:
10:08:16 <lambdabot>    `SimpleReflect.FromExpr ...
10:08:25 <rwbarton> :t ?f $ let in ?g ?x $ let in ?h ?y
10:08:26 <lambdabot> forall b t a b1 t1. (?y::t1, ?h::t1 -> a, ?x::t, ?g::t -> a -> b1, ?f::b1 -> b) => b
10:08:33 <rwbarton> oh no
10:08:34 <Peaker> Using emacs key bindings in xchat can have harmful consequences
10:08:36 <rwbarton> it still doesn't work
10:09:08 <rwbarton> another argument for infixl ($) ??
10:09:18 <rwbarton> because you can just write $ let in for the infixr version
10:09:33 <maukd> haha
10:10:09 <maukd> > length $do show $do 'x'
10:10:10 <lambdabot>   3
10:10:30 <rwbarton> yeah, or $do but it feels dirtier
10:10:45 <shachaf> maukd: Will that work with TH?
10:10:57 <shachaf> Nope.
10:11:00 <shachaf>     Not in scope: `do'
10:11:05 <maukd> haha
10:11:05 <rwbarton> haha
10:11:08 <rwbarton> as if it could be
10:11:14 <rwbarton> or maybe, with TH it can? :)
10:11:17 <maukd> what an excellent error message
10:11:18 <shachaf> rwbarton: Maybe with -- yes, that.
10:11:35 <maukd> maybe there should be a contest: given an error message, write code that triggers it
10:11:38 <shachaf> I would try it but I don't feel like getting close enough to TH to figure out how to define things.
10:11:43 <cmccann> maukd, hahahaha
10:11:46 <shachaf> maukd: Segmentation fault
10:11:48 <rwbarton> Template "all bets are off" Haskell
10:11:52 <Eduard_Munteanu> Heh.
10:11:58 <maukd> shachaf: too easy
10:12:07 <solirc> http://hpaste.org/76233
10:12:08 <shachaf> At compile time?
10:12:16 <shachaf> Well, I guess there's TH.
10:12:16 <solirc> ^ for that code, is there a way to get rid of the newtype?
10:12:17 <Eduard_Munteanu> shachaf: given TH...
10:13:14 <maukd> @quote ghc brain
10:13:14 <lambdabot> ghc says: My brain just exploded.
10:13:39 <Eduard_Munteanu> GADTs IIRC.
10:14:23 <shachaf> maukd: I get that one too much. :-(
10:14:44 * cmccann wonders what shachaf is doing to see that message often
10:14:52 <maukd> unwrapping existentials
10:14:56 <rwbarton> > [|3|]
10:14:57 <lambdabot>   <no location info>: parse error on input `|'
10:15:21 <shachaf> cmccann: Well, I consider "ever" often, with error messages like that.
10:15:30 <cmccann> maukd, which begs the question of what shachaf is doing to use existentials that often...
10:15:55 <ClaudiusMaximus> solirc: i don't think so, last time i tried something like that i got into hell with instance for partially-applied type synonyms being impossible, or something
10:16:43 * cmccann goes back to writing code involve existentially quantified Constraints, which is clearly sensible
10:17:06 <ClaudiusMaximus> solirc: http://stackoverflow.com/questions/4922560/why-doesnt-typesynonyminstances-allow-partially-applied-type-synonyms-to-be-use has some examples of why
10:17:42 <shachaf> cmccann: And I put cream and sugar on my strawberries, and they call *me* crazy?
10:18:55 <solirc> ClaudiusMaximus: thx :)
10:21:38 <bigfg> can i do 'scoped types' like `where { data Scoped = Not| Valid| Outside |The |Where; }
10:22:06 <rwbarton> no
10:22:48 <bigfg> :(
10:25:06 * cmccann occasionally wishes you could define types inside any where clause
10:25:19 <cmccann> with the "where" clause of a module being a special case of course
10:25:52 <shachaf> Were-claws is like a lesser version of were-wolf?
10:25:52 <bigfg> a simple way to make enumerates that you only will use for a single function
10:26:22 <shachaf> cmccann: Next you'll want instances in a where clause.
10:26:51 <Trudko> guys i can't wrap my head around (x:_) = x   this pattern  what does it exactly mean
10:27:06 <bigfg> Trudko, take the head out of a list
10:27:08 <cmccann> shachaf, I would if instances weren't annoying about stuff like that
10:27:09 <Iceland_jack> Trudko: Do you know what : is?
10:27:19 <tazjin> If I have a "class Data a => BarClass a" and a type "data Bar = forall a . BarClass a => Foo { foo :: a } deriving (Typeable)", is it possible to automatically derive Data for Bar?
10:27:27 <shachaf> cmccann: I wish type classes weren't so global. :-(
10:27:36 <hpc> Trudko: is that the whole line?
10:27:38 <tazjin> I've tried using standalone deriving instances but it doesn't type-check
10:27:43 <Trudko> Iceland_jack not really
10:27:45 <cmccann> but I've said before that I'd like a unified notion of "where" clause
10:27:46 <shachaf> That's the evil thing about them.
10:27:52 <merijn> Trudko: The pattern _ is a wildcard pattern. It matches everything and doesn't give a name to the matched thing
10:28:04 <cmccann> with modules being a degenerate case of a where clause not attached to a binding
10:28:08 <Iceland_jack> Trudko: it takes an element and "adds" it to a list
10:28:11 <merijn> Trudko: : is a constructor that adds an item to the front of a list
10:28:23 <Iceland_jack> [1,2,3] is really 1:[2,3]
10:28:53 <cmccann> so you'd have nested scopes for not just functions, but also classes, instances, GADTs...
10:28:54 <Iceland_jack> So if you pattern match [1,2,3] against (x:xs), x is going to become 1, xs is going to become [2,3]
10:28:55 <merijn> > 1:2:3:[]
10:28:57 <lambdabot>   [1,2,3]
10:29:16 <Iceland_jack> > case [1,2,3] of (x:xs) -> x
10:29:18 <lambdabot>   1
10:29:19 <Iceland_jack> > case [1,2,3] of (x:xs) -> xs
10:29:20 <lambdabot>   [2,3]
10:29:29 <cmccann> shachaf, I'm sure all kinds of stuff would break horribly though
10:29:48 <shachaf> cmccann: Yes, I don't know any way of making it good.
10:29:53 <shachaf> That's why I said "evil". :-(
10:30:19 <cmccann> shachaf, well, stuff besides instances would probably break under the full generality of what I suggest
10:30:29 <shachaf> Oh, you're tlaking about the "where" thing.
10:30:45 <cmccann> yeah
10:30:51 <rwbarton> type classes within type classes seem a bit scary
10:31:01 <rwbarton> or is that too general
10:31:04 <cmccann> making (almost) anything you can put at the top-level of a module valid in any where clause
10:31:23 <cmccann> instance scope is the biggest wtf here
10:31:40 <shachaf> cmccann: I like the part where «foo would just be a special case» could either mean that you implement unusual behavior for foo or that you don't.
10:32:12 <cmccann> well, there'd probably still be stuff that only made sense in modules
10:32:49 <cmccann> I'm not sure I'd want to go down the rabbit hole of, say, explicit export lists for type classes or GADTs with nested definitions
10:32:51 <cmccann> because
10:32:52 <cmccann> yeah
10:33:29 <cmccann> I dunno, there's a huge amount of potential overlap between all of these, but the edges that don't overlap are the worst parts :D
10:33:49 <cmccann> it's the sort of thing I'd probably build into a Haskell-ish language from the start, but not try to retrofit
10:35:15 * cmccann also isn't sure whether everything in the where clause of a class would be in scope inside instance definitions
10:36:58 <cmccann> anyway clearly my idea is awesome and the problem here is that type classes are complete bullshit and ruin everything, so there
10:37:04 <shachaf> mgsloan wanted to do https://github.com/mgsloan/instance-templates
10:37:14 * cmccann goes back to misusing Constraint kinds
10:38:04 <Trudko> Iceland_jack hmm still not quite sure if : is for adding element to list, does it mean that head' will return list with one element?
10:38:42 <Iceland_jack> : takes one element and one list
10:38:49 <rwbarton> what is head'
10:39:20 * cmccann is not entirely convinced that type classes are a good idea outside of a more limited type system
10:39:30 <Trudko> hmm is pattern matching something like regular expression?
10:39:37 <Iceland_jack> no
10:40:05 <Eduard_Munteanu> Trudko: pattern-matching follows exactly the data definition for that particular type.
10:41:16 <Trudko> ok will have to a look at it again
10:41:18 <Eduard_Munteanu> If you have  data List a = Empty | Cons a (List a)  then you can pattern-match like  case xss of (Cons x xs) -> ...
10:41:19 <bigfg> i don't see typeclasses any more brittle than interfaces in an object oriented language
10:41:55 <rwbarton> pattern matching is like regular expressions in that both are languages for recognizing certain kinds of values and extracting pieces of information from them
10:42:06 <rwbarton> however pattern matching is not the same as regular expressions
10:42:07 <bigfg> they are 'close to metal' when talking about interfacing two pieces of code, so it seems natural that they will tend to break from changes in either part
10:42:22 <Trudko> for example I do understand this that  (_, _, z) = z   if you get some tupple return the third element dont care about first two
10:42:38 <shachaf> rwbarton: New lambda syntax! s/argument/result/
10:42:40 <cmccann> bigfg, having a notion of subtyping built into the language seems like it might help
10:42:53 <bigfg> what do you mean by subtyping?
10:42:59 <cmccann> shachaf, hahahahaha
10:43:07 <rwbarton> we can call it an s-expression
10:43:14 <cmccann> perfect
10:43:20 <latro`a_> oh god that pun was horrible
10:43:34 <bigfg> Trudko, you don't need to ignore the first two parameters in the program flow, but the idea is just to extract the third
10:44:28 <bigfg> consider this function: f x = (fst x, snd x, third x) where third (_, _, z) = z
10:44:34 <maukd> s{x}{x x} s{x}{x x}
10:44:46 <latro`a_> ...............
10:45:10 <latro`a_> > let f x = x x in f f
10:45:11 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
10:45:13 <latro`a_> aww
10:45:25 <latro`a_> knew that would happen, but still aww
10:45:28 <shachaf> > let f x = outR x x in f (InR f)
10:45:30 <Eduard_Munteanu> @src Mu
10:45:30 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
10:45:32 <lambdabot>   mueval-core: Time limit exceeded
10:45:49 <maukd> shachaf: shouldn't it be body =~ s/parameter/argument/?
10:47:12 <Trudko> could (x:_) pattern by rewritten ?
10:47:18 <drostie> today I became inexplicably happy that Haskell allows both [] and [[]] to be of the same type. Some day I'll write a tutorial where I'll get to explain "is everything a Functor? No, booleans and numbers aren't functors... but they could have been." :D
10:47:38 <srhb> Trudko: Not exactly. Not while still matching an at-least one element list.
10:47:50 <srhb> Trudko: Why?
10:47:50 <shachaf> drostie: Well, one of them has a more general type.
10:47:52 <maukd> xs@(x:_)
10:48:16 <Trudko> srhb because it seems that  i am used to write list asi [x] rather then x:[]
10:48:17 <shachaf> drostie: That sentence doesn't even make sense. :-(
10:48:53 <drostie> shachaf: I'm sorry you feel that way. it makes sense to me. :<
10:49:24 * Eduard_Munteanu wonders if @-patterns can take '_'.
10:49:38 <Eduard_Munteanu> (which of course, would be useless, but still)
10:49:56 <rwbarton> > let f (_@_) = 1 in f 'x'
10:49:57 <lambdabot>   <no location info>: parse error on input `@'
10:50:02 <rwbarton> > let f (x@_) = 1 in f 'x'
10:50:03 <lambdabot>   1
10:50:07 <rwbarton> > let f (_@x) = 1 in f 'x'
10:50:08 <lambdabot>   <no location info>: parse error on input `@'
10:50:26 <Eduard_Munteanu> Another arbitrary limitation of Haskell :)
10:50:35 <rwbarton> > let f (_y@x) = 1 in f 'x'
10:50:36 <lambdabot>   1
10:50:47 <Eduard_Munteanu> Or actually, it makes sense.
10:51:07 <Eduard_Munteanu> xss in xss@xs isn't a pattern.
10:51:43 <Eduard_Munteanu> > let f ([]@[]) = 1 in f 'x'
10:51:44 <lambdabot>   <no location info>: parse error on input `@'
10:52:55 <maukd> > let o@ο = 'o' in o
10:52:56 <lambdabot>   'o'
10:53:22 <Eduard_Munteanu> It might be fun to have patterns on the left hand side of @.
10:54:48 <Eduard_Munteanu> You could do stuff like   f "34"@(x:xs) = ...
10:56:42 * Eduard_Munteanu isn't sure if there's anything nice or useful you could do with it though.
10:56:57 <fryguybob> > let f ((x@'4'):(xs@('2':_))) = ("yes",x,xs) in f "42"
10:56:58 <lambdabot>   ("yes",'4',"2")
10:57:31 * cmccann has been trying to figure out a way to do pattern matching with Haskell-ish syntax in a language using linear types
10:57:41 <crdueck> @hoogle (a -> b -> c -> d) -> c -> b -> a -> d
10:57:41 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
10:57:41 <lambdabot> Data.Sequence zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
10:57:41 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
10:57:59 <Eduard_Munteanu> Perhaps with view-patterns, stuff like f (length -> 10)@('3':xs) = ...
10:58:35 <Eduard_Munteanu> Matching lists of length 10 starting with a '3'.
10:58:38 <fryguybob> > let f (x@'4':xs@'2':_) = ("yes",x,xs) in f "42"
10:58:39 <lambdabot>   ("yes",'4','2')
10:59:37 <latro`a_> that's terrible
10:59:39 <ousado> cmccann: which language?
11:00:15 <cmccann> ousado, there isn't a language
11:00:25 <cmccann> there isn't even a syntax
11:00:42 <cmccann> which is why I'm trying to figure out how it might work :P
11:01:53 <dropdrive> Is the Haskell dialect "Mu" (from Augustsson, CUFP 2011) available online?
11:02:11 <shachaf> It looked like an internal SCB thing.
11:02:37 <shachaf> Those finance companies sure love their internal languages.
11:02:45 <dropdrive> Ah, they were just showing off at CUFP then ;)
11:03:22 <shachaf> Well, someone mentioned it to me and I couldn't find much about it.
11:04:25 <ousado> cmccann: ATS has linear types and pattern matching
11:04:59 <ousado> dunno if ML is haskell-ish enough, though
11:10:42 <ousado> cmccann: here's a blog post with some examples http://www.bluishcoder.co.nz/2011/12/16/pattern-matching-against-linear-objects-in-ats.html
11:12:11 <cmccann> ousado, hm, interesting
11:14:56 <cmccann> ousado, that seems more focused on just tracking resource use, though, where I'm trying to handle a bit more of linear logic-ish stuff
11:15:55 <cmccann> specifically dealing with terms that have negative polarity
11:15:57 <shachaf> cmccann: Are you going to make that game thing have linear types?
11:16:04 <shachaf> s/ have linear types//, for that matter.
11:16:14 <cmccann> shachaf, nah, this is mostly unrelated
11:16:32 <cmccann> linear logic is an ongoing fascination of mine
11:17:02 <cmccann> see also: the simple arrow-ish Haskell implementation I hpaste'd a while back, and the stream processing library I'm still trying to make work nicely
11:17:20 <shachaf> I was thinking that linear types might make a lot more sense with it.
11:17:40 <shachaf> But on the other hand I don't properly understand linear types/logic.
11:17:42 <ousado> cmccann: the dominant use (if such a thing exists for anything ATS-related) is for resources, but you are free to use them for whatever you want
11:18:27 <sm> is there a tool more recent than searchpath, that works for non-cabal builds, for auto-recompiling when source files change ?
11:18:53 <cmccann> ousado, well... negative polarity amounts to tracking demands for resources, where positive polarity is more like availability of resources
11:20:04 <cmccann> so really I'm just trying to be more expressive than that, even as far as resource tracking goes
11:20:18 <cmccann> the ATS stuff looks interesting from an implementation standpoint though
11:20:53 <cmccann> so if I get far enough to write a compiler of some sort it might help a great deal to look at
11:21:00 * sm gives shaker a try
11:21:59 <ousado> cmccann: well, I'm not sure what the limitations of the current implementation are, but you can always ask hongwei xi, he's very responsive
11:22:05 <cmccann> shachaf, anyway, linear logic's not really that complicated but is a bit counterintuitive in places and hard to build intuition for, I guess
11:22:32 <ousado> .. and in the process of rewriting ATS, maybe you can give some input
11:23:01 <shachaf> cmccann: Yes, that's what I mean.
11:24:14 <cmccann> ousado, if it gives you any idea, what I'm trying to do requires that function arguments (as in, binding identifiers inside the function) are interchangeable with values
11:25:36 <cmccann> so a function of two arguments returning one value is equivalent to a function of one argument returning two values, one of which is negative :D
11:26:27 <cmccann> shachaf, well, to start with I assume the linearity thing is straightforward enough
11:26:52 <cmccann> in programming terms it means each identifier is (by default) bound exactly once and referenced exactly once
11:27:06 <danharaj> cmccann: How is that different from curryied function application?
11:27:44 <shachaf> cmccann: Can't it be referenced no times?
11:27:45 <cmccann> danharaj, well, it's precisely the curry function translated to linear logic
11:27:51 <danharaj> ah ok gotcha
11:28:01 <cmccann> shachaf, no, can't discard or duplicate things
11:28:41 <ousado> http://homepages.inf.ed.ac.uk/wadler/topics/linear-logic.html
11:28:51 <ousado> check out a taste of linear logic
11:28:52 <cmccann> danharaj, the difference is the "returning two values", because input and output types can be manipulated independently
11:29:13 * cmccann has read all of Wadler's stuff on linear logic
11:29:23 <cmccann> some of it multiple times, heh
11:31:50 <cmccann> anyway, it's like taking a function as an argument, pattern-matching it as a lambda abstraction, and then using the head and body of the lambda separately as arguments to other functions
11:31:56 <cmccann> and having that actually make sense
11:34:36 <ousado> I found this to be a very nice informal intro: "Some of the best things in life are free; and some are not. Truth is free. Having proved a theorem, you may use this proof as many times as you wish, at no extra cost. Food, on the other hand, has a cost. Having baked a cake, you may eat it only once. If traditional logic is about truth, then linear logic is about food"
11:34:46 <cmccann> heh
11:36:02 <shachaf> Unless you're Zeno.
11:36:09 <shachaf> Zeno knew how to halve his cake and eat it too.
11:36:23 <ousado> .. yes, or a cow
11:36:43 <cmccann> it seems shachaf is going rot13 on us again :I
11:39:07 <bigfg> once you eat food you will eventually have to poop it out of the system
11:39:22 <bigfg> is that a correct informal application?
11:40:48 <cmccann> any physical analogy for linear proof that relies on conservation of mass is probably correct-ish in some informal way
11:41:11 <ousado> or space in this case
11:43:08 <Cale> |- A, A^_|_  corresponds to particle/antiparticle pair formation?
11:43:13 <Eduard_Munteanu> On the other hand, I guess mainstream languages that use neither linear typing nor monads to contain side-effects are content to let you poop where you eat.
11:43:21 <merijn> Is my understanding of STM correct when I think that using waitSTM (from the async package) can cause me to lose information when the Async action obtains a value from an IO action but another STM transaction completes first and discards the async result?
11:44:06 <cmccann> Cale, is "A^_|_" really what you want there?
11:44:54 <Cale> cmccann: I'm just looking at the axioms on Wikipedia
11:45:08 <cmccann> oh, heh
11:45:15 <cmccann> the superscript for negation
11:45:20 <rwbarton> "oh that _|_"
11:45:49 <merijn> Or should I give up trying to ask these details here and just mail SimonMar directly?
11:46:30 <Eduard_Munteanu> merijn: maybe you can catch him in here
11:46:37 <shachaf> He's not in here right now.
11:46:51 <merijn> Oh, wait...my entire question is pointless I just realised
11:46:54 <cmccann> Cale, for some reason I read that in the "exponential object" sense as meaning _|_ -> A which is the opposite of what the syntax in the article means
11:46:55 <Cale> merijn: I'm not sure exactly what you mean there...
11:47:05 * shachaf tries to figure out what merijn's question is.
11:47:09 <merijn> async uses separate forkIO threads to implement async so that rules them out for me anyway
11:47:21 <Cale> cmccann: Yeah, I just realised that it seems backwards
11:47:22 <shachaf> merijn: ?
11:47:32 <Cale> It should be _|_^A for negation
11:47:51 <cmccann> Cale, it's a generic superscript notation, not an exponent, I suppose
11:47:59 <cmccann> stupid ambiguous syntax
11:48:14 <maukd> ⊥ᴬ
11:48:20 <merijn> shachaf: async has "async :: IO a -> Async a" and "waitSTM :: Async a -> STM a" I figured I could use that to compose reading from a socket with other STM things, but the way waitSTM and async are implemented leads me to believe I could lose data that way
11:48:24 <cmccann> and of course "exponential" in linear logic means something entirely different
11:48:39 <cmccann> and linear logic as a category isn't cartesian closed anyway
11:49:13 <Cale> oh, wow, really?
11:49:18 <Cale> hmm
11:49:25 <cmccann> "really?" about what?
11:49:29 <cmccann> not being cartesian closed?
11:49:31 <Cale> That it's not a CCC
11:49:33 <cmccann> yeah
11:49:46 <merijn> shachaf: I have a problem where I have a thread reading from a ZeroMQ socket and writing to a Chan (to get messages from the network into my program), now obviously I also want to write messages back *to* the network
11:50:03 <cmccann> the "tensor product" that allows currying &c. is not a categorical product
11:50:19 <cmccann> and the categorical product doesn't play nicely with functions
11:50:24 <merijn> shachaf: But ZeroMQ sockets aren't thread safe, so writing to the socket from another thread is wrong. So I need to have one thread that blocks on both the IO action *and* a Chan/MVar/whatever
11:50:29 <Cale> Interesting
11:50:42 <merijn> shachaf: Finding a way to do this is (so far at least) *hard*
11:51:06 <cmccann> Cale, moving to intuitionistic logic essentially collapses both conjunctions into one, which gets you to a CCC
11:51:11 <shachaf> merijn: Oh, you have to use bound threads for everything?
11:51:25 <merijn> shachaf: No, I just can't have two threads interacting with the same socket
11:51:46 <merijn> At least, not without a full memory barrier between every interaction
11:51:47 <cmccann> Cale, did you see my arrow-ish implementation of linear logic in Haskell? I described some of this in comments there I think
11:52:25 <Cale> I saw some implementation
11:52:27 <Eduard_Munteanu> cmccann: where is that?
11:52:28 <shachaf> merijn: Oh, that sort of not thread safe.
11:52:56 <cmccann> Eduard_Munteanu, http://hpaste.org/75222
11:53:35 <rwbarton> is ⊕ a coproduct?
11:53:36 <cmccann> Cale, you probably stopped reading because it makes heavy use of the new version of TypeOperators and that made you go cry for a while :T
11:53:44 <Cale> hahaha
11:53:45 <cmccann> rwbarton, yes
11:54:01 <cmccann> the addictive connectives are the product and coproduct
11:54:26 <Cale> "addictive" :D
11:54:30 <cmccann> ...
11:54:32 <cmccann> that was a nice typo
11:54:34 <merijn> Actually, when multiple asynchronous exceptions are delivered to a thread how does that work. One exception at a time, the next one not being delivered until the previous handler is finished?
11:54:56 <nand`> can't you use PolyKinds to generalize Category?
11:55:06 <cmccann> and the additive identities are the initial and terminal objects, additive falsehood is the usual useless uninhabited type, &c
11:55:17 <cmccann> nand`, yes
11:55:40 <merijn> I might be going about this problem entirely wrong
11:57:03 <Cale> merijn: What is this ZeroMQ thing for, and what business does it have not being threadsafe? :)
11:57:29 <Cale> It *sounds* like the sort of thing which you would absolutely rely on being threadsafe
11:58:03 <nand`> hmm; defining class Cat (a :: x -> x -> *); running :k Cat gives me (BOX -> BOX -> *) -> Constraint -- I thought BOX was a sort, not a kind
11:58:03 <merijn> Cale: It's high performance communication library (not just networking, it also provides IPC/inter-thread communication)
11:58:05 <nand`> what's going on with that?
11:58:09 * cmccann notes that with additive conjunction (A&¬A) is a non-explosive contradiction
11:58:13 <nand`> I would have expected forall a. (a -> a -> *) -> Constraint
11:58:15 <merijn> Cale: ZeroMQ is threadsafe, ZeroMQ *sockets* are not
11:58:28 <merijn> Cale: You are not supposed to share sockets between threads
11:58:38 <cmccann> nand`, if you copy+paste the existing Category definition and turn on PolyKinds I think it works automatically
11:58:51 <nand`> cmccann: yeah it should; I'm just curious
11:58:57 <merijn> Cale: So having one read and one write thread for a socket like people usually recommend is out.
11:59:16 <cmccann> nand`, also GHC gives goofy error messages for some of the new kind stuff
11:59:28 <nand`> cmccann: if I omit the kind signature, I get :k Cat :: (k -> k -> *) -> Constraint
11:59:30 <nand`> which makes more sense
11:59:55 <ClaudiusMaximus> merijn: how about making all communication go via ZeroMQ instead of forwarding through Chan or whatever?  so each Haskell thread has its own ZeroMQ thingy... is that feasible?
12:00:02 <Cale> merijn: Maybe the Haskell binding should create a new thread every time it makes a socket, and then have the operations on the socket send messages to that thread...
12:00:04 <merijn> Cale: But I think I've been going about this wrong. The bindings block in the haskell runtime, so I'm thinking I can use asynchronous exceptions to "wakeup" a thread blocked on a ZeroMQ socket to read from its Chan
12:00:19 <Cale> (or at least, perhaps you can do this in your program)
12:00:43 <merijn> ClaudiusMaximus: I thought about this, but than I can't use TChan's + STM internally
12:01:00 <ClaudiusMaximus> ah
12:01:24 <ClaudiusMaximus> rebuild STM on top of ZeroMQ?  sounds like a nightmare...
12:01:30 <Cale> Threads are pretty cheap, maybe it wouldn't be unreasonable to have an extra thread and Chan for each Socket.
12:01:36 <merijn> Cale: That doesn't solve the problem, does it? You just said "can't the haskell bindings implement what you are unable to implement in haskell?"
12:01:53 <Cale> merijn: You should be able to implement this :)
12:02:25 <merijn> Cale: How? If you block on reading from the socket how do you (at the same time) wait for input to write to the socket?
12:02:42 <Saizan> Cale: the single thread dealing with the Socket has to both wait for output from the Socket and for messages from the "to write" Chan
12:03:25 <Cale> hmm
12:03:40 <merijn> Cale: Like I said, I think the sensible way is to use asynchronous exceptions to wake up the thread to read from it's Chan. Then I just need to ensure I avoid a race that blocks me on the Chan instead :p
12:05:02 <merijn> If all asynchronous exceptions are guaranteed to be delivered (given the thread doesn't die, obviously) and don't interrupt each other's handler then I don't have a race, I guess
12:05:32 <merijn> Hell, why have a Chan at all? Can't I just declare an Exception that carries the message to send in it?
12:05:44 <Cale> Yeah, you could do that
12:06:04 <merijn> My day is considerably brightened by this realisation
12:06:17 <Cale> Though I don't know whether they interrupt each other or not
12:06:29 <b__> what kind of data structure am I looking for when storing a big [(Int, Bool)], where I only update Bool once at most?
12:06:32 <Cale> Maybe you need to make the handler a critical section
12:06:33 <b__> an array of some kind?
12:06:36 <merijn> I'll have to read up on Control.Exception
12:06:44 <Saizan> catch runs handlers in a block
12:06:53 <Saizan> but do read the details
12:07:00 <Cale> b__: By "update once at most" do you really mean "never update"?
12:07:29 <b__> well it concerns prime vs composite numbers
12:07:42 <Simon____> Hello, I'm Simon
12:07:47 <Cale> Or do you mean that you're toggling each position at some point as the program runs, but then never toggling it again?
12:07:54 <b__> yes Cale, that
12:07:54 <Eduard_Munteanu> A bitmap of some sort would be quite economical.
12:08:15 <Cale> Simon____: Peyton Jones or Marlow? :D
12:08:30 <merijn> Cale, Saizan: From the Control.Exception docs: The following operations are guaranteed not to be interruptible: everything from Control.Exception
12:08:40 <merijn> (and a bunch of others I don't care about)
12:09:31 <Saizan> the race i'd be worried about is the one just after you got something from ZeroMQ but you haven't reported it yet and an exception is arriving
12:09:37 <Cale> b__: Is the point that the list consist of (n, isPrime n)?
12:09:43 <b__> yes
12:09:48 <Cale> b__: then that never changes
12:10:16 <Cale> (The primality of a number is rarely revised ;)
12:10:29 <b__> ah ja
12:10:34 <Cale> So, you could use an Array, for example
12:10:46 <b__> I don't have to initially set it of course
12:10:56 <b__> but I will end up with a list of composites
12:11:29 <Cale> Well, you can usually just initially set everything to its final value, but only actually force the evaluation of those values later.
12:11:58 <rwbarton> Cale: http://arxiv.org/pdf/1209.2007.pdf ;)
12:12:01 <ClaudiusMaximus> merijn: this paper might be relevant? http://research.microsoft.com/en-us/um/people/simonpj/papers/lw-conc/
12:12:29 <merijn> Saizan: Yeah, but I think that can be solved by running everything inside "mask", afaik (I'm going to test this now) some blocking operations like putMVar and (I'm hoping) threadWaitRead and threadWaitWrite will reenable exceptions for their duration
12:13:05 <merijn> Saizan: So *either* I'm interrupted inside threadWaitRead (in which case I can't have read any data yet) or the entire thing runs uninterrupted
12:13:12 <Cale> rwbarton: The real reason that 1 isn't prime is that the trivial ring isn't considered a field :D
12:15:20 <nikita-0> "Field of one element" does exist though. :-)
12:15:37 <nikita-0> But it is something completely different.
12:16:02 <b__> Cale, I see many different types of arrays mentioned in the docs
12:16:13 <b__> what kind am I looking for to start with?
12:16:37 <Cale> Start with just the simple Array type
12:16:42 <Cale> Data.Array
12:17:08 <b__> okay
12:18:28 <Cale> b__: It is not strict in the elements, so you can do things like defining  primality = array (1,big) [(n, isPrime n) | n <- [1..big]]
12:18:41 <Cale> b__: and then have isPrime defined to use this array
12:18:50 <Cale> (mutually recursively)
12:18:51 <Saizan> merijn: *nod*
12:19:10 <b__> yeah I have a naive implementation which is mutually recursive
12:19:29 <b__> I'm now trying to implement the paper by Atkin and Bernstein
12:24:41 <Cale> b__: If it really comes down to it and you find you need mutation, there's always IntMap before you give up and use something like ST
12:25:37 <b__> yeah I implemented the sieve described in Melissa O'Neills paper with IntMap and PQueue
12:26:18 <b__> but I can't imagine (though probably a baseless intuition) that IntMap is the way to go for this
12:51:19 <merijn> Saizan: Looks like the sane approach is to run in a masked thread and then uninterruptibleMask everything but the receive (so I don't lose messages when I get interrupted while dealing with a message)
12:54:59 <haskell1> hey! I'm new to Haskell, can I get some help?
12:55:40 <ben> of course
12:56:23 <hpc> haskell1: have you found any help yet? i think it's around here somewhere...
12:56:28 <hpc> ;)
12:56:31 <merijn> haskell1: Usually people here give more help than people can handle :p
12:57:19 <haskell1> haha thanks! I'm stuck with guards, I think there might be an easier way to do what I want
12:57:28 <ousado> heh
12:57:45 <haskell1> basically I need to check every condition and print a message if true.
12:58:05 <Clint> that sounds painful
12:58:26 <hpc> :t or -- might something like this be relevant to your interests?
12:58:27 <lambdabot> [Bool] -> Bool
12:58:38 <hpc> :t and
12:58:39 <lambdabot> [Bool] -> Bool
13:04:21 <jmcarthur> haskell1: if you have some code that you don't like you can put it on hpaste.org and give us a link to look at
13:06:32 <nand`> haskell1: what, like you have some set of conditions and you need to print out one message for each condition that matches, even if multiple do?
13:06:57 <mapf`> hi everybody
13:07:40 <danharaj> edwardk: got anything cool on the hoas-bound question?
13:07:46 <haskell1> nand`: that's it
13:07:57 <edwardk> haven't added anything new
13:07:59 <haskell1> I'll paste the code now
13:08:06 <hpaste> haskell1 pasted “Conditions haskell” at http://hpaste.org/76239
13:08:44 <hpaste> haskell1 pasted “Conditions haskell” at http://hpaste.org/76240
13:08:47 <nand`> well, that doesn't match what I just described
13:09:33 <nand`> but what is immediately apparent (apart from the horrible formatting) is that you have putStrLn everywhere; surely you can make the function pure by returning String instead of IO ()
13:10:17 <haskell1> thanks, will do that
13:10:30 <mapf`> package named pretty still good? i want a pretty printing library to format generated C code, and i investignated 'pretty' and 'wl-pretty'. these looks good but i can't decide one should i use
13:10:47 <haskell1> and I need the code to print every message when a condition matches, not only the first condition
13:10:57 <haskell1> I don't know if I can do that with guards
13:11:30 <mapf`> mapf`: fix: which one i should use.
13:11:37 <jmcarthur> haskell1: sounds like you want some sort of a map, not a guard
13:12:07 * jmcarthur gives it a shot
13:12:20 <nand`> I would approach the problem with something like a -> [a -> Maybe String] -> IO () -- which can be split up into a -> [a -> Maybe b] -> [b] -- which can be further split up into ‘map’ and ‘catMaybes’
13:13:35 <mapf`> or maybe there are no difference?
13:13:51 <nand`> :t (mapM_ putStrLn . catMaybes) .: (map . flip id)
13:13:53 <lambdabot> forall a. a -> [a -> Maybe String] -> IO ()
13:14:45 <nand`> excuse the excessive pointlessness
13:15:10 <nand`> here, this one's cleaner
13:15:16 <nand`> :t \x -> mapM_ putStrLn . catMaybes . map ($x)
13:15:18 <lambdabot> forall a. a -> [a -> Maybe String] -> IO ()
13:16:21 <magicman> :t mapMaybe
13:16:22 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
13:16:29 <nand`> nice
13:16:44 <nand`> :t \x -> mapM_ putStrLn . mapMaybe ($x)
13:16:45 <lambdabot> forall a. a -> [a -> Maybe String] -> IO ()
13:16:48 * lispy is annoyed that new ghc releases break so many packages
13:17:01 * nand` is annoyed that so many packages fail to keep up with the new ghc releases
13:17:11 <nand`> I'm looking at you, GtkHs and lambdabot
13:17:33 <Clint> lambdabot: apologize
13:19:15 <alephomega> Wait... so everything broken on my sytem is ghc's fault, and not because pacman hates haskell?
13:19:33 <merijn> alpounet: Which GHC do you have?
13:19:59 <jmcarthur> alephomega: it's a combination of the two
13:20:03 <hpc> honestly, if you have 7.6.1, it's the arch maintainers' fault
13:20:18 <jmcarthur> arch switched to 7.6.1 the other day
13:20:24 <jmcarthur> i don't think that is problematic itself
13:20:37 <merijn> hpc: Probably some "so state of the art we throw our users off a cliff"-distro
13:20:48 <alephomega> lol
13:20:52 <hpc> -blah was having that discussion the other day
13:22:00 <beaky> hello
13:22:01 <jmcarthur> arch is more about being transparent than being state of the art. i think the latter just happens to come with the former a lot of the time, since you end up with a more knowledgable userbase that way anyway
13:22:04 <jmcarthur> hello
13:22:37 <merijn> jmcarthur: 7.6 has all sorts of major packages broken still...
13:23:03 <merijn> Especially with Prelude.catch removed
13:23:04 <beaky> How does Miranda relate to Haskell? Both languages seem to have quite similar syntax, and both are purely-functional
13:23:09 <jmcarthur> merijn: not any that affect the arch packages that depend on it
13:23:26 <merijn> beaky: I think Miranda predates Haskell and had many of the same people working on it
13:23:28 <lpvb> what's wrong with 7.6.1?
13:23:41 <merijn> lpvb: Nothing, but not all important packages support it
13:23:51 <merijn> lpvb: So it's "use at your own risk"
13:24:06 <lpvb> I updated to it with arch and didn't look apparently
13:24:13 <jmcarthur> merijn: haskell developers are also quite used to having to tweak packages for ghc updates (although of course the need to do it at all is unfortunate)
13:24:39 <alephomega> So... is the best plan for me to downgrade ghc?
13:24:48 <lpvb> Do ghc extensions ever become apart of the core language?
13:25:01 <lpvb> Seems like almost every haskell program has a few language extensions
13:25:03 <jmcarthur> alephomega: what's broken? arch packages or just other stuff you've installed with cabal?
13:25:08 <thoughtpolice> lpvb: sometimes, they certainly do
13:25:09 <jmcarthur> lpvb: occasionally
13:25:42 <thoughtpolice> some extensions are practically speaking never going to go away, like MultiParamTypeClasses, but it's not standard either
13:26:01 <alephomega> jmcarthur: at this point I'm not even sure... But ghc seems unable to find System.Process.
13:26:37 <jmcarthur> alephomega: install the process package?
13:26:53 <alephomega> it's installed...
13:26:58 <jmcarthur> for 7.6.1?
13:27:01 <alephomega> Unless it's not...
13:27:04 * alephomega checks.
13:27:27 <alephomega> Yes.
13:27:35 <alephomega> Or ghc-pkg says it is.
13:28:03 <jmcarthur> alephomega: and it's not hidden or anything either?
13:28:23 <jmcarthur> alephomega: (this doesn't sound like a problem with ghc. it sounds more like the installation got screwed up)
13:29:25 <alephomega> jmcarthur: Not hidden.
13:29:37 <alephomega> So... reinstall, or ?
13:29:59 <jmcarthur> i guess i would wipe the /home/<user>/.ghc directory and reinstall
13:30:07 <jmcarthur> unless you would just rather have an older one anyway
13:30:30 <jmcarthur> are you sure you are using the correct ghc binary, if you have multiple installed?
13:30:45 <jmcarthur> oh
13:30:57 <jmcarthur> i guess i would first try just reinstalling the process package
13:31:06 <alephomega> Yeah... that's my plan right now. :)
13:38:34 <alephomega> feels really stupid right now...
13:38:48 <alephomega> I should have done that half an hour ago.
13:40:19 <notdan> Does anyone here have any experience with Alex? Is it possible to specify a case-insensitive lexem?
13:40:43 <notdan> For example, I want cLASS and ClasS to be the same keyword
13:49:20 <merijn> lpvb: Haskell2010 added a bunch of extensions to the standard
14:03:14 <hpaste> merijn pasted “Vile hacks using uninterruptibleMask” at http://hpaste.org/76244
14:03:36 * hackagebot weather-api 0.2.0 - Weather api implemented in haskell  http://hackage.haskell.org/package/weather-api-0.2.0 (PeterGoncharov)
14:04:10 <merijn> Well, looks like I have a working example of code that does what I want. As long as I make sure that the code doesn't do any blocking operations that can deadlock :p
14:16:46 <littletinybaby> Hey all trying to learn haskell again, and I was wondering how one reads function mappings (a ->b) in plain english?
14:17:08 <hiptobecubic> "from a to b" ?
14:17:17 <Jeanne-Kamikaze> take an a and return a b ?
14:17:18 <littletinybaby> what about this one (a -> Bool) -> [a] -> [a]
14:17:25 <maukd> you are not a modem
14:17:39 <alephomega> Take a function from a to bool, and a list of a's and return a list of a's
14:17:41 <littletinybaby> It's a composition?
14:18:01 <alephomega> It's a function which takes a function.
14:18:09 <maukd> :t filter
14:18:11 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:18:12 <hiptobecubic> it is a function that takes two arguments, essentially. the first of which is a function, the second is a list
14:18:19 <alephomega> learn you a haskell is a good resource. :)
14:18:22 <maukd> takes a function and a list; returns a list
14:19:17 <littletinybaby> I've already tried learn you a haskell, it's too wordy. Haha, I love it, but it's not a good reference when I forget. Is there a place that translates haskell into math, since it is a functional language and all.
14:20:48 <alephomega> I'm not sure what you mean... type signatures in Haskell essentially look exactly like in type theory.
14:21:01 <alephomega> There's no translation to do.
14:21:13 <littletinybaby> I suppose that's true
14:21:33 <littletinybaby> Well actually, it's good to know about type theory
14:21:45 <startling> is there an easy way to check that some function on elements of a list is equal for all the elements?
14:22:05 <astropirate> does there exist a "learn haskell interactively" tutorial
14:22:14 <astropirate> many programming languages have them.
14:22:19 <astropirate> usually in the browser
14:23:10 <littletinybaby> http://tryhaskell.org/
14:23:14 <startling> @hoogle (a -> Bool) -> [a] -> Bool
14:23:15 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
14:23:15 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
14:23:15 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
14:23:26 <startling> oh, woah
14:23:33 <astropirate> nice! thanks littletinybaby
14:23:42 <startling> oh wait, those aren't what I want.
14:23:49 <littletinybaby> :D first time I've helped someone in an IRC
14:24:00 <startling> @hoogle (a -> a -> Bool) -> [a] -> Bool
14:24:00 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
14:24:00 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
14:24:00 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
14:24:20 <startling> bah
14:24:21 <alephomega> startling: apply the function and then use all.
14:24:38 <startling> alephomega: I want to see that they're all equal to each other.
14:24:53 <hiptobecubic> fold with true
14:24:58 <startling> :t true
14:24:59 <lambdabot> Not in scope: `true'
14:25:11 <hiptobecubic> :t True
14:25:13 <lambdabot> Bool
14:25:16 <alephomega> all (== head f list) $ f list
14:25:20 <alephomega> That's ugly...
14:25:26 <alephomega> but it should get the job done
14:25:27 <typoclass> startling: map your function over the list, then do group and check you got only one element?
14:25:30 <startling> alephomega: that's not bad, thanks
14:25:37 <typoclass> > group "aaabbbbb"
14:25:37 <alephomega> Group! way better
14:25:38 <lambdabot>   ["aaa","bbbbb"]
14:26:01 <alephomega> Err... nub, right?
14:26:09 <startling> :t nub
14:26:09 <alephomega> > nub [1,1,1]
14:26:10 <lambdabot> forall a. (Eq a) => [a] -> [a]
14:26:11 <lambdabot>   [1]
14:26:17 <alephomega> Yes. Nub.
14:26:30 <alephomega> Anyway, do one of those. :)
14:26:33 <hiptobecubic> let l = [1,1,1,1,1,1,1,1] in all $ zipWith (==) l (tail l)
14:26:39 <hiptobecubic> > let l = [1,1,1,1,1,1,1,1] in all $ zipWith (==) l (tail l)
14:26:40 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
14:26:40 <lambdabot>         against inferred ...
14:26:45 <mroman> There's no Monoid (a -> a) ?
14:26:54 <atriq> Endo
14:26:57 <atriq> :k Endo
14:26:59 <lambdabot> * -> *
14:26:59 <hiptobecubic> > let l = [1,1,1,1,1,1,1,1] in and $ zipWith (==) l (tail l)
14:27:00 <lambdabot>   True
14:27:06 <hiptobecubic> > let l = [1,1,1,1,1,1,1,2] in and $ zipWith (==) l (tail l)
14:27:07 <lambdabot>   False
14:27:24 <atriq> > getEndo (Endo (+ 1) <> Endo (* 2)) 7
14:27:25 <lambdabot>   Not in scope: `getEndo'
14:27:30 <atriq> > runEndo (Endo (+ 1) <> Endo (* 2)) 7
14:27:31 <lambdabot>   Not in scope: `runEndo'
14:27:37 <atriq> :info endo
14:27:44 <atriq> @info endo
14:27:45 <lambdabot> endo
14:27:49 <startling> typoclass, alephomega: thanks
14:28:16 <atriq> > appEndo (Endo (+ 1) <> Endo (* 2)) 7
14:28:17 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
14:28:17 <lambdabot>         agains...
14:28:25 <atriq> > appEndo (Endo (+ 1) `mappend` Endo (* 2)) 7
14:28:26 <lambdabot>   15
14:28:30 <atriq> mroman, ^^^
14:28:43 <atriq> After I flail about for half an hour
14:29:36 <alephomega> ... This language is absurd.
14:30:17 <atriq> This language is brilliantly absurd
14:30:18 <augur> alephomega: why!
14:30:32 <mroman> there is Monoid (a -> b) though
14:30:36 <merijn> What's the best way to block my main thread until other threads have terminated? Read an empty MVar that gets filled when last thread exits? atomically (readTVar runningThreadCount >>= check . (==1))? Some other option?
14:30:51 <atriq> mroman, that's why you need to wrap it in the Endo newtype
14:30:55 <alephomega> augur: there's an endomorphism typeclass.
14:31:08 <augur> why wouldnt there be?
14:31:24 <alephomega> Because we're not doign category theory?
14:31:26 <alephomega> Oh wait...
14:31:30 <alephomega> doing*
14:31:32 <augur> some people are!
14:31:32 <hiptobecubic> merijn, list of mvars, one for each thread, read them all in main thread then exit?
14:31:33 <startling> :t nubBy
14:31:34 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
14:31:43 <Guest71334> Would anyone mind providing some guidance on documentation that may help do the equivalent of Perl's  s/\s+/-/  operation?
14:31:44 <Guest71334> I've read about isSpace in Data.Char and replace in Data.String.Utils, but I'm sure how to put them together or if there's a better way.
14:31:57 <mroman> instance Monoid (a -> a) where { mempty = id; mappend f g = f . g; } ?
14:32:00 <atriq> alephomega, Haskell takes a lot of inspiration from Category Theory
14:32:01 <startling> is there a nub that maps over while it goes?
14:32:09 <alephomega> I think that respnce explains why Haskell is absurd. :)
14:32:18 <Guest71334> Im just trying to replace any whitespace in a String with a single dash char.
14:32:19 <atriq> mroman, would clash with instance Monoid b => Monoid (a -> b)
14:32:24 <atriq> mroman, hence Endo
14:32:30 <alephomega> atriq: Haskell is why I have "sheaves in Geometry and Logic" on my bookshelf. :)
14:32:37 <augur> alephomega: why does that make haskell absurd
14:33:24 <atriq> augur, I think he means that it's different from pretty much every other programming language in the history of ever
14:33:26 <alephomega> augur: Every time I learn something new about haskell I laugh at out how ridiculous/awesome it is.
14:33:32 <merijn> hiptobecubic: Waste if I don't care about anything other then when the last one exits. Might as well keep a counter and write to a single MVar when it becomes zero
14:33:39 * augur shrugs
14:33:42 <alephomega> Absurd is not meant to be an insult here. Many of the best things are absurd.
14:33:52 <augur> i dont see how any of its absurd but ok
14:33:53 <mroman> atriq: I was hoping there were a way to hide instances on import
14:34:02 <hiptobecubic> merijn, true, but how will any thread know if it's last?
14:34:06 <atriq> mroman, there actually isn't
14:34:11 <atriq> Really annoys me
14:34:17 <merijn> hiptobecubic: Second MVar with a counter that you modifyMVar_ :)
14:35:06 <mroman> > appEndo (Endo (+ 1) `mappend` Endo (* 2)) 7
14:35:07 <lambdabot>   15
14:35:14 <mroman> > appEndo (Endo (+ 1) `mappend` Endo (* 2) `mappend` mempty) 7
14:35:15 <lambdabot>   15
14:35:37 <mroman> Neat.
14:36:39 <atriq> (a `mappend` mempty ") == mempty == (mempty `mappend` a) by the Monoid laws
14:36:45 <atriq> Here, mempty == id
14:36:58 <atriq> With the other function one, I believe mempty is (const mempty)
14:37:27 <alephomega> :t mappend
14:37:29 <lambdabot> forall a. (Monoid a) => a -> a -> a
14:38:01 <atriq> alephomega, in case you don't know, a monoid is sort of like a group, but without inverse
14:38:13 <atriq> There's no Group class in Haskell as far as I am aware
14:38:18 <alephomega> atriq: So like, a category with one element? ;)
14:38:34 <atriq> I... think so
14:38:54 <alephomega> I checked the type because I'm confused where that equation comes from.
14:39:15 <alephomega> My intuition suggests a `mappend` mempty should equal a
14:39:24 <atriq> YEs
14:39:28 <c_wraith> that's a monoid law, too
14:39:29 <atriq> I made a mistake back there
14:39:32 <alephomega> Ok!
14:39:34 <atriq> Because I'm tired
14:39:51 <atriq> And have had more sugar and caffeine than I probably should
14:40:15 <alephomega> :)
14:41:00 <mroman> I'm aware of the monoid laws :)
14:41:54 <alephomega> Now I want to watch some Eugenia Cheng videos...
14:42:09 <mroman> Endo defines mempty = Endo id
14:42:31 <mroman> But it somehow is disappointing that I have to wrap it in an Endo :(
14:43:34 <atriq> Without the Endo, I think you'd have to have FlexibleInstances as well
14:43:36 <atriq> But I'm not sure
14:44:05 <startling> :t Eq b => (a -> b) -> [a] -> [[a]]
14:44:06 <lambdabot> parse error on input `=>'
14:44:10 <startling> er
14:44:16 <startling> @hoogle  Eq b => (a -> b) -> [a] -> [[a]]
14:44:17 <lambdabot> GHC.Exts groupWith :: Ord b => (a -> b) -> [a] -> [[a]]
14:44:17 <lambdabot> GHC.Exts sortWith :: Ord b => (a -> b) -> [a] -> [a]
14:44:17 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
14:44:55 <mroman> atriq: FlexibleInstances doesn't seem to resolve it
14:45:15 <mroman> There is no syntax like :: to select manually an instance?
14:45:57 <mroman> hm well
14:46:06 <mroman> Num a => Monoid a would still be kinda...
14:46:41 <mroman> One would need named instances :)
14:47:30 <maukd> named instances, a.k.a. newtype
14:49:54 <startling> where the hell do i get that "groupWith"?
14:50:04 <atriq> mroman, I mean you can't even write the instance without FlexibleInstances
14:50:25 <atriq> I think you'd need OverlappingInstances or something even more drastic for it to work
14:50:37 <typoclass> startling: you mean groupBy? it lets you pass in your own test function (instead of always using (==))
14:51:10 <startling> typoclass: that would work. I was referring to
14:51:11 <startling> <lambdabot> GHC.Exts groupWith :: Ord b => (a -> b) -> [a] -> [[a]]
14:51:20 <Cale> startling: it says what module it's in
14:51:30 <Cale> It's in GHC.Exts
14:51:56 <shapr> @index groupWith
14:51:56 <lambdabot> bzzt
14:52:01 <shapr> :-(
14:52:49 <mroman> atriq: Using type you can't write it without TypeSynonym
14:53:03 <atriq> Yeah
14:53:11 <mroman> not sure if that restriction also applies to newtype
14:53:13 <mroman> but I guess so.
14:54:00 <mroman> To declare freaky instances one obviously needs freaky -X paramaters.
14:54:20 <atriq> If you make your own Monoid class, you can make that (a -> a) instance with just -XFlexibleInstances
14:54:21 <mroman> But I very like ghc telling you which parameters you need to enable it instead of just rejecting the code :)
14:55:37 <mroman> atriq: Yeah. I  just don't import Data.Monoid :)
14:56:04 <mroman> are instances global?
14:56:05 <atriq> To do both you'd need -XOverlappingInstances
14:56:07 <atriq> Yish
14:56:16 <mroman> If something I import imports Data.Monoid?
14:56:16 <atriq> They're implicitly exported
14:56:18 <Cale> The lifting instance for Monoid is *very* useful though
14:56:22 <atriq> Probably
14:56:38 <mroman> I thought I've heard that then those instances will be global.
14:56:46 <astropirate> who here is awesome?
14:57:07 <atriq> I'd like to say me, but I'm not
14:57:10 <Cale> There's no-one here by that name
14:57:25 <awesome> Guess again
14:57:26 <typoclass> astropirate: we generally like xmonad better than awesome 8-)
14:57:33 <mroman> I whish I were.
14:58:02 <atriq> astropirate, I've a feeling Cale is awesome
14:59:04 <strebe> atriq: you are correct
14:59:48 <strebe> typoclass: yes, xmonad rocks :-)
15:00:03 <atriq> What's xmonad?
15:00:10 <atriq> Sounds graphicsy?
15:00:51 <merijn> atriq: Tiling window manager
15:00:53 <typoclass> atriq: it's a tiling window manager written in haskell. for some people it was the gateway drug to haskell programming (e.g. me)
15:01:15 <atriq> Okay, heh
15:01:34 <atriq> I use Haskell because for me it's perfect
15:01:43 <atriq> It's a brilliant language to just mess around in
15:03:19 <astropirate> I use xmonad
15:03:27 <astropirate> except it totally screwes up flash :(
15:03:31 <astropirate> fullscreen
15:03:38 <astropirate> I shoudl fix that :S
15:03:49 <astropirate> the probelm with xmonad is you need to know h askell to even use it
15:04:05 <astropirate> I didn't really knwo what haskell was when i started with xmonad :(
15:04:11 <typoclass> astropirate: it's fairly easy to fix. you just put this one line in your manageHook. i bet it's in the xmonad faq
15:04:19 <typoclass> astropirate: same here :)
15:04:19 <strebe> astropirate: http://www.haskell.org/haskellwiki/Xmonad/Frequently_asked_questions#Removing_the_borders_around_mplayer worked nicely for me with mplayer; I haven't tried with flash
15:04:41 <astropirate> tnx
15:04:59 <typoclass> astropirate: also check section 3.10
15:05:22 <astropirate> aye aye
15:24:23 <ceezer> Anyone here using haskell for signal processing?
15:24:36 <ceezer> digital signal processing specifically.
15:25:54 <ion> I probably will some day.
15:26:50 <solrize> so is MonadPlus really a particular monoid instance for the associated monad ?
15:27:41 <atriq> With a couple more laws
15:27:54 <atriq> I think mzero >>= f = mzero is a law
15:28:08 <solrize> hmm ok
15:28:09 <solrize> thanks
15:28:33 <solrize> monoids don't have that?
15:28:33 <c_wraith> actually, MonadPlus doesn't exactly have laws.  Instead, it has a bunch of alternative possible laws
15:28:35 <ceezer> just looking at what the current state of haskell libraries are
15:28:50 <ceezer> there's a haskell dsp package.
15:29:05 <atriq> Nah, monoids aren't normally monads, so won't need anything to do with (>>=)
15:30:04 <solrize> > mconcat [1,2] [3,4]
15:30:05 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:30:05 <lambdabot>    `GHC.Num.Num a'
15:30:05 <lambdabot>      ari...
15:30:18 <solrize> > mconcat (Just 2) (Just 3)
15:30:20 <lambdabot>   Couldn't match expected type `[a]'
15:30:20 <lambdabot>         against inferred type `Data.Mayb...
15:30:47 <ion> > mconcat [Sum 2, Sum 3]
15:30:49 <lambdabot>   Sum {getSum = 5}
15:30:51 <solrize> atriq i just mean you could define a monoid instance for m a  instead of having MonadPlus
15:31:21 <atriq> Not really
15:31:30 <atriq> That leads to occasional dodgy stuff
15:31:49 <solrize> > mappend (Just "foo") (Just "bar")
15:31:51 <lambdabot>   Just "foobar"
15:31:59 <solrize> > mappend (Just 2) (Just 3)
15:32:01 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:32:01 <lambdabot>    `Data.Monoid.Monoid t'
15:32:01 <lambdabot>  ...
15:32:12 <solrize> hmm
15:32:13 <atriq> > mplus (Just "foo") (Just "bar"
15:32:14 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:32:15 <atriq> > mplus (Just "foo") (Just "bar")
15:32:16 <lambdabot>   Just "foo"
15:32:39 <solrize> well the MonadPlus instance for Maybe happens to be like First
15:33:02 <solrize> > mappend (First (Just "foo")) (First (Just "bar"))
15:33:04 <lambdabot>   First {getFirst = Just "foo"}
15:35:15 <mcstar> two packages, unordered-containers and hashmap both provide Data.HashMap and Data.HashSet
15:35:21 <mcstar> what should i do?
15:35:29 <atriq> Use unordered-containers
15:35:45 <mcstar> is it pure/persistent?
15:35:58 <hpc> do the types look pure?
15:36:05 <mcstar> i cant even look at the docs
15:36:10 <hpc> ah
15:36:19 <mcstar> they are both present
15:36:24 <mcstar> the docs are messed up i think
15:36:29 <mcstar> i can go to hackage...
15:36:41 <mcstar> but im not sure what to do, remove one of them from the system?
15:36:53 <mcstar> or can i just temporarily shadow it?
15:37:06 <mcstar> cause i get Ambiguous module name `Data.HashSet':
15:37:34 <atriq> Only 3 libraries depend on hashmap
15:37:41 <atriq> *packages
15:37:57 <atriq> implicit, wordsetdiff, and yesod-continuations
15:38:02 <atriq> Are you using any of those?
15:38:32 <mcstar> unordered-containers looks good, it is pure
15:38:44 <mcstar> i dont think so
15:38:51 <atriq> (whereas 96 depend on unordered-containers, including some major ones like aeson and yesod)
15:38:57 <atriq> Remove hashmap, then
15:38:59 <mcstar> ok, then its clear
15:39:04 <MrFenix> hi
15:39:06 <atriq> Don't ask me how, though...
15:39:10 <donri> there is also a plan to get unordered-containers into containers, and thus into the platform
15:39:10 <atriq> Hey, MrFenix
15:39:21 <mcstar> atriq: how did you get those packages? through hackage?
15:39:27 <mcstar> i mean the statistics
15:39:42 <mcstar> or with cabal?
15:39:43 <atriq> http://packdeps.haskellers.com/
15:40:02 <mcstar> thanks, bookmarked
15:40:19 <MrFenix> can anyone help me on "Type synonym `Foo' should have 1 argument, but has been given none"?
15:40:32 <MrFenix> where type Foo t = Bar t
15:40:36 <shachaf> MrFenix: I'm going to guess that you have a type synonym, Foo, that should have 1 argument, but you gave it none.
15:40:52 <shachaf> (I might be wrong on that.)
15:40:55 <tazjin> Does anyone know if aeson has its own Parser type or if it's just using attoparsec? Doesn't seem very clear from the Haddocks
15:41:09 <atriq> MrFenix, have you said foo :: Foo anywhere?
15:41:10 <MrFenix> its in the context Compose (Foo) (Baz)
15:41:13 <atriq> Aaah
15:41:19 <shachaf> MrFenix: You can't use Compose with type synonyms.
15:41:22 <atriq> You can't use types like that
15:41:33 <shachaf> MrFenix: It *would* work if you wrote type Foo = Bar
15:41:41 <shachaf> But then it'd really just compose Bar with Baz.
15:42:04 <shachaf> If you want to be able to use Compose, you have to make something into an actual type, with newtype (or data).
15:42:07 <atriq> If Bar is more complicated, though, maybe you'd want a newtype?
15:42:25 <MrFenix> yeah.. I feared that
15:42:51 <MrFenix> I don't like it though, as that will produce a lot of lifting all over the place
15:43:45 <cmccann> edwardk, you around?
15:43:47 <mcstar> atriq: i just unregistered implicit and hashmap with ghc-pkg
15:43:50 <edwardk> nope
15:43:54 <cmccann> oh ok
15:44:01 <MrFenix> it is lifting hell already, as type Foo t = ListT (Either (Err t)) (t, t)
15:44:32 <shachaf> If you have lots of lifting, it probably means you *should* be using a newtype.
15:44:33 * cmccann found an entertaining abuse of Constraint kinds
15:44:41 <shachaf> ...As well as operations that operate directly on it.
15:44:46 <shachaf> cmccann: Uh oh.
15:44:55 <edwardk> cmccann: oh i see, bait me in with an opening like that why don't you
15:44:58 <edwardk> whats the abuse?
15:45:15 <hpaste> “C. McCann” pasted “Constraint abuse” at http://hpaste.org/76248
15:45:28 <cmccann> if things work the way I think they work
15:45:49 <atriq> :t liftA2 fromMaybe show cast
15:45:51 <lambdabot> forall a. (Show a, Typeable a) => a -> String
15:45:53 <cmccann> the function passed to alterTree can only create a Mark if it preserves a subtree exactly
15:46:28 <cmccann> so it can deconstruct as much as it wants, but must indicate points where it might have changed the tree
15:46:36 <atriq> > let f = liftA2 fromMaybe show cast in [f 1, f (), f [1,2,3], f "Hello"]
15:46:38 <lambdabot>   ["1","()","[1,2,3]","Hello"]
15:46:44 <MrFenix> hmm.. seems to me, that using the recursion-schemes from Data.Functor.Foldable send you directly into boilerplatehell
15:46:44 <atriq> > let f = liftA2 fromMaybe show cast in f [f 1, f (), f [1,2,3], f "Hello"]
15:46:45 <lambdabot>   "[\"1\",\"()\",\"[1,2,3]\",\"Hello\"]"
15:46:56 <cmccann> if it puts a subtree back together exactly as it received it the Mark can be reused
15:47:01 <MrFenix> but thanks, shachaf and atriq
15:47:01 <cmccann> otherwise it has to resort to Nothing
15:47:02 <edwardk> i'm having motivating what you have there
15:47:22 <cmccann> http://stackoverflow.com/q/12873988/157360 is what started the tinkering
15:47:31 <cmccann> but it's not a very good solution
15:47:50 <edwardk> hrmmm
15:47:52 <cmccann> (mostly because it doesn't generalize well to the B-tree structure)
15:48:16 <cmccann> basically this would be the first approach suggested in the question, but with type-enforced correctness
15:48:27 <cmccann> in that the user can't put an offset where it doesn't belong.
15:48:58 <MrFenix> cmcann: use zippers
15:49:10 <cmccann> and then at the end, the equality constraints demolish all the existential bullshit and you have annotations preserved on unchanged nodes, or removed from altered nodes
15:49:47 <cmccann> note that you'd also get a shortcut to structural equality checks, of a sort
15:50:18 <edwardk> so what i'm looking for is something where i an edit a structure with something like traverse, but if i don't change part of it, i want sharing with the original.
15:50:21 <edwardk> can i get there with this?
15:50:23 <cmccann> since the moment you find a Mark present instead of Nothing, you know that everything below there is the same as what you gave the function that altered it
15:51:32 <cmccann> well, the question is about mapping back to sharing in another domain, i.e. data in a file
15:51:52 <edwardk> the sharing domain i care about is the in-memory domain ;)
15:52:10 <cmccann> but it was actually harder to allow reassembling a subtree that has the same data
15:52:24 <edwardk> e.g. the function detects that it got back a marked structure, so it throws it away and just uses the one it was passed in
15:52:27 <cmccann> I needed a helper function with an explicit type signature
15:52:33 <cmccann> that would also work
15:52:33 <int-e> cmccann: hmm, but if I have a leaf, can't I can reuse its mark to unfold it into a subtree? (since the node constructor certainly works if d = d1 = d2)
15:52:56 <cmccann> actually I'm not sure if the Leaf is correct
15:53:10 <cmccann> I weakened the restriction there somewhat in order to have a single Leaf constructor
15:53:51 <cmccann> but yeah, the idea is that finding a Mark means you have structural equality, so you can reuse existing data (either in-memory from what you passed in, or on disk)
15:55:20 <MrFenix> cmccann: can you map your trees to rose trees?
15:55:28 <int-e> cmccann: the idea works in principle, just provide enough constraints to define the tree shape completely (e.g. a predicate for the leaves and two binary relations encoding left and right children.) the question is more of how far one can optimize it.
15:55:55 <cmccann> MrFenix, not directly, you'd need a list type that threaded constraints through
15:56:37 <cmccann> since this relies on each node having a Constraint on its existential annotation, and a master Constraint that constrains the constraints on its children
15:57:02 <cmccann> int-e, and yeah, the more I think about it the Leaf definition is probably bogus
15:57:40 <cmccann> the definition I started with had two leaf types, one with no Mark at all, and one with more existential types that was impossible to construct without specific constraints
15:57:54 <MrFenix> cmccann: if you only had an isomorphism to rose trees - https://github.com/JanBessai/dirdiff/blob/b0edfa7dd4ee0e2df06cdea4f8b57e95855d17ef/src/Data/Tree/Diff.hs
15:59:07 <cmccann> MrFenix, I could certainly make a rose tree version, I'd just need to make a list type that worked the same way as well
15:59:15 <cmccann> regular lists can't work
16:00:19 <cmccann> edwardk, anyhow, it might also be possible to contrive something that doesn't even allow reconstructing equivalent subtrees
16:00:33 <cmccann> so that a Mark would guarantee not just equality, but actual sharing
16:02:26 <MrFenix> cmccann: memory domain sharing as in "the same pointer"?
16:02:55 <cmccann> yes, because it would be impossible to construct something new of that type
16:03:33 <cmccann> much like how parametricity guarantees that (forall a. a -> a) is the identity function
16:04:01 <cmccann> except possibly stronger, because even "undefined" can't satisfy the weird constraint stuff, I don't think
16:04:41 <Polarina> What's the difference between { :: a -> a } and { :: forall a. a -> a }? I've never seem to have seen a difference.
16:05:12 <cmccann> Polarina, at top-level, nothing
16:05:40 <cmccann> but "(forall a. a -> a) -> b -> b" means something different from "(a -> a) -> b -> b"
16:05:46 <copumpkin> your syntax seems to suggest that you consider it part of a type
16:05:50 <copumpkin> which makes them quite different
16:06:03 <copumpkin> part of a data declaration, that is
16:06:05 <cmccann> and yeah, what copumpkin said
16:06:25 <shachaf> copumpkin: { } is used for modules too. :-)
16:06:29 <Polarina> I've only seen forall used in types.
16:06:30 <hpaste> “C. McCann” annotated “Constraint abuse” with “Constraint abuse (annotation)” at http://hpaste.org/76248#a76250
16:06:55 <copumpkin> meh
16:06:55 <cmccann> I think two Leaf constructors works properly
16:15:01 <hpaste> int-e annotated “Constraint abuse” with “Constraint abuse (annotation)” at http://hpaste.org/76248#a76252
16:15:54 <int-e> cmccann: how about this? it reflects the whole structure of the tree on the type level using auxillary types.
16:16:02 <cmccann> ooh
16:16:17 <cmccann> in a sense that's what it was already doing
16:16:37 <int-e> I know, but this seems more systematic
16:16:41 <cmccann> yes
16:17:00 <cmccann> I think you lost the actual annotation type in the process, but that's irrelevant
16:17:10 <cmccann> since it was an artifact of starting from that SO question
16:17:57 <cmccann> I like that, it's far more elegant than what I had
16:19:24 <int-e> oh and a universal constraint is easy to come by, of course; it's just  class Universal a; instance Universal a.
16:19:26 <copumpkin> int-e: reverse systematic?
16:19:29 <copumpkin> :P
16:19:46 <int-e> citametsys?
16:19:53 <copumpkin> data Node' t
16:19:53 <copumpkin> data Leaf' t1 t2 t
16:20:10 <cmccann> heh
16:20:49 * cmccann is still pondering to what extent this could actually be useful
16:21:32 <copumpkin> I like it
16:24:37 <int-e> It's a very interestin idea. One can capture other constraints, for example one can constrain functions to rotations of trees using something like  data Tree c t1 t2 where Leaf :: (c t1 t2) => a -> Tree t1 t2 a; Node :: (c t1 t2, c t2 t3) => Tree t1 t2 a -> Tree t2 t3 a -> Tree t1 t3 a
16:24:47 <cmccann> it's interesting how this lets you play some games with a type that reflects the structure of the data, but hides it all behind layers of existentials that can be unified after the fact
16:24:55 <cmccann> yeah
16:25:05 <cmccann> expressing other structural properties could be fun
16:33:26 <hpaste> int-e annotated “Constraint abuse” with “Constraint abuse (with a Functor instance and example of using alterTree)” at http://hpaste.org/76248#a76254
16:33:30 <shachaf> Can you write Y using newtype P = InP { outP :: forall a. P -> a }?
16:34:06 <cmccann> int-e, nice!
16:35:00 <copumpkin> int-e: what I was pointing out before is that Node' and Leaf' (the names) are reversed :P
16:35:27 <int-e> copumpkin: So you did, but I didn't get the point. Oops :)
16:35:41 <copumpkin> I stared at it for a while before noticing
16:36:13 <int-e> leafs are nodes, too!
16:36:22 <cmccann> yeah, I didn't notice that until copumpkin pointed it out, heh
16:37:01 <int-e> maybe I should've used Con0 and Con1
16:43:17 <int-e> shachaf: is P inhabited by anything besides InP undefined and InP (const undefined)?
16:43:53 <shachaf> int-e: Well, this is by analogy to newtype Rec a = InR { outR :: Rec a -> a }
16:44:15 <shachaf> Which you can use to do recursion without any value-level recursion.
16:44:54 <cmccann> using similar types, you can also do GHC's inliner-level recursion
16:44:56 <cmccann> which is fun
16:45:59 <shachaf> cmccann: Apparently the behavior of GHC's inliner has changed.
16:46:01 <shachaf> At one point
16:46:02 <shachaf> @where y
16:46:02 <lambdabot> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
16:46:04 <int-e> shachaf: but given values p and q of type P, we have  outP p q = undefined, since that's the only value of type forall a. a.
16:46:10 <shachaf> Was noon-terminating, but no longer.
16:46:32 <shachaf> int-e: It'll be ⊥ but not undefined.
16:46:36 <shachaf> That's the point.
16:47:51 <unyty> hi
16:48:02 <mgccl> Many dynamic programming problems are very simple: a simple function relate 1 value with smaller values. did anyone try to make a general DP DSL, where someone write the relations in the DSL and Haskell solves it with DP techniques.
16:48:02 <shachaf> > (join outR . InR . join) outR
16:48:06 <lambdabot>   mueval-core: Time limit exceeded
16:48:34 <cmccann> shachaf, the bug I'm referring to is still mentioned in the latest GHC docs
16:48:49 <shachaf> cmccann: OK, it must be more than one bug. :-)
16:48:51 <startling> @hoogle Map a b -> [a] -> ([a], [b])
16:48:51 <lambdabot> No results found
16:48:57 <startling> darn.
16:50:07 <int-e> shachaf: I'm arguing that you can't use your P like that.
16:50:17 <cmccann> shachaf, cf. http://codegolf.stackexchange.com/a/7198
16:50:22 <shachaf> int-e: You mean to write Y?
16:50:26 <int-e> shachaf: yes
16:50:40 <shachaf> Because you end up having to provide the polymorphism in one place, rather than use it?
16:51:43 <edwardk> @tell nand` clearly you need to add this to your pong game http://www.boredwrestlingfan.com/wp-content/uploads/2011/10/funny-gifs-pac-pong.gif
16:51:44 <lambdabot> Consider it noted.
16:52:14 <int-e> shachaf: pretty much, yes. The claim is that any value of type P constructed will not contribute to the final result of the function. This is because all you can do with it is apply 'outP' to it and then apply the result to another value of type P. But what you get then must be bottom, because it's fully polymorphic (it has any type).
16:52:18 <shachaf> edwardk: That's Player 3?
16:52:29 <cmccann> edwardk, that would be better if it also included breakout-style smashing of the playing field walls
16:52:55 <edwardk> cmccann: http://www.youtube.com/watch?v=_BNylOIcY-U
16:54:23 <cmccann> edwardk, that's a neat concept
16:56:12 <int-e> edwardk: hmm, now what would happen if the pacman catches the ball? would it grow? would it then chase the closest player (treating it as a temporarily vulnerable ghost)?
16:56:38 <edwardk> int-e: =) you'd want more degrees of freedom of moment i think if that was the case ;)
16:56:40 <int-e> or would it split into 4 smaller pacmans (think asteroids) ...?
16:57:18 <fizzbang> hey! f, g, and h are common names for functions... a, b, & c are common names for functions... what are common names for data? p & q?
16:57:36 <fizzbang> **** a, b, & c are common names for types
16:57:36 <Polarina> fizzbang, a, b, c, etc.
16:57:37 <JoshTriplett> dcoutts, dcoutts_: Around?
16:57:37 <int-e> fizzbang: a b and c.
16:57:51 <shachaf> x and y
16:58:05 <Polarina> x, xs, too, like shachaf mentioned.
16:58:08 <int-e> i j n m p q x y ... pretty much anything that's not a function
16:58:08 <JoshTriplett> fizzbang: If you mean an argument or let variable, frequently x and y, and for lists, xs and ys.
16:58:28 <JoshTriplett> fizzbang: Numbers: n and m are common.  Indexes: i and j...
16:58:28 <shachaf> Functions are data anyway.
16:58:32 <JoshTriplett> fizzbang: Pretty much what you'd expect.
16:58:42 <JoshTriplett> shachaf: True, but if you *know* they're a function, f and g are traditional. :)
17:00:24 <shachaf> I like a and a' for types, a'' and a''' for data, and a'''' and a''''' for functions.
17:00:30 <cmccann> a unicode snowman is a good name for a function
17:00:34 <fizzbang> shachaf: good man!
17:00:40 <fizzbang> i'll go with the primes
17:00:52 <cmccann> or there's edwardk's emoticons
17:00:55 <magicman> Unary encode ALL the things.
17:00:55 <cmccann> which I've lost the link to
17:00:57 <fizzbang> cmccann: i tried to use lambda in my code the other day and ghc was unhappy with me
17:00:57 <shachaf> fizzbang: In special cases I'll "a'" for a prime number.
17:01:08 <edwardk> http://hpaste.org/51474
17:01:10 <cmccann> :D
17:01:23 <int-e> shachaf: are you aware of http://www.haskell.org/haskellwiki/Obfuscation ?
17:01:30 <JoshTriplett> fizzbang: You need an extension for that.
17:01:35 <edwardk> (╯°□°)╯ 彡 ┻━┻    is a perfectly good function
17:02:19 <JoshTriplett> edwardk: Indeed, it's ت awesome. :)
17:02:34 <shachaf> °͜°
17:02:40 <typoclass> edwardk: i see it in source code frequently
17:03:00 <edwardk> typoclass: i see you've been working with my lens library ;)
17:03:01 <cmccann> there's also a bunch of unicode stuff for letters in different typefaces because mathematicians are weird
17:03:09 <typoclass> edwardk: :D
17:03:11 <cmccann> script, fraktur, blackboard bold...
17:03:17 <shachaf> double-struck
17:03:23 <shachaf> Or is that the same as blackboard bold?
17:03:28 <shachaf> I guess it is.
17:03:30 <JoshTriplett> I like that the unicode character "teh" is a smiley face: ت
17:03:30 <cmccann> I think so
17:03:45 <edwardk> the sad thing is NFKC and NKFD normalization turn those into normal letters, which rather drastically cripples ones ability to use them for identifiers
17:03:46 <alephomega> Wait, there's blackboard bold in unicode?
17:03:49 <shachaf> U+067a ARABIC LETTER TEEHEE
17:04:15 <shachaf> Maybe that should be U+67F
17:04:18 <alephomega> My life has just been changed.
17:04:28 <shachaf> alephomega: Most of it is outside the BMP, sadly.
17:04:48 <int-e> > map generalCategory "♕☃☹"
17:04:49 <lambdabot>   [OtherSymbol,OtherSymbol,OtherSymbol]
17:04:55 <cmccann> alephomega, 𝕐𝕖𝕤, 𝕥𝕙𝕖𝕣𝕖 𝕚𝕤.
17:04:56 * JoshTriplett looks forward to the next great web programming library, ☄
17:05:08 <shachaf> ℂ ℍ ℕ ℙ ℚ ℝ ℤ
17:05:30 <shachaf> cmccann: All I see is 17:04 <cmccann> alephomega, ���, ����� ��.
17:05:32 * Clint twitches.
17:05:33 <shachaf> Curse you, screen!
17:05:38 <shachaf> Does that say "yes, there is"?
17:05:38 <cmccann> haha
17:05:44 <alephomega> My poor twitter followers...
17:05:44 <cmccann> yep
17:05:55 * shachaf .psychic.moed
17:06:14 <ion> shachaf: tmux
17:06:19 <shachaf> 1EEA1   ARABIC MATHEMATICAL DOUBLE-STRUCK BEH     [<U+1EEA1>]
17:06:24 <shachaf> ion: I know, I know.
17:06:25 <JoshTriplett> > let ☂ = try , ☔ = catch in 1
17:06:26 <lambdabot>   <no location info>: parse error on input `
17:06:29 <JoshTriplett> Awww.
17:06:29 <hpaste> “C. McCann” pasted “I needed this function for reasons” at http://hpaste.org/76256
17:06:44 <JoshTriplett> shachaf: Actually, screen has a utf8 mode.  Turn it on.
17:06:54 <shachaf> JoshTriplett: Yes, but it doesn't support non-BMP characters.
17:07:07 <alephomega> :)
17:07:08 <shachaf> Because the screen developers are racist against mathematicians.
17:07:08 <JoshTriplett> shachaf: Oh. :(
17:07:11 <Clint> that seems like a bug
17:07:20 <shachaf> It is a bug.
17:07:49 <shachaf> cmccann: I don't like your prompt.
17:07:51 <shachaf> It confuses me.
17:08:02 <typoclass> @remember alephomega Wait, there's blackboard bold in unicode? My life has just been changed. My poor twitter followers...
17:08:03 <lambdabot> Done.
17:08:11 <cmccann> my GHCi prompt is awesome and that's really all there is to say on the matter
17:08:28 <shachaf> cmccann: "x" seems a little on the low-tech side.
17:08:40 <shachaf> Why not α or something?
17:08:43 <cmccann> hm
17:08:46 <cmccann> tempting
17:09:05 <cmccann> something weirder looking instead though
17:09:18 <Clint> ugh, https://savannah.gnu.org/bugs/?26723
17:09:22 <typoclass> shachaf: i've said it before, i use a screen replacement that supports gui programs, any number of layouts and extensions, and is generally excellent. it's called xmonad.
17:09:23 <cmccann> shachaf, you saw my SciTE abbreviations file, right?
17:09:39 <shachaf> cmccann: I don't think so.
17:10:13 <cmccann> shachaf, http://hpaste.org/75848
17:10:26 <trol> func74 (x:z:_) = "Allllalalalala " ++ show (all the list)
17:10:31 <trol> how could i?
17:10:33 <int-e> Hmm, Unicode has Fraktur letters, but only one 's' for them :(
17:10:36 <cmccann> those are the substitutions my editor does when I press ctrl-b
17:11:33 <typoclass> cmccann: loli?
17:11:40 <shachaf> cmccann: Do they Yesod developers have a Unicode Snoyman character?
17:11:42 <trol> how could i show the a entire list func74 (x:z:_) = "Alllllll " ++ show (all the list)
17:11:42 <shachaf> s/y//
17:11:59 <cmccann> typoclass, "lollipop"
17:12:07 <shachaf> cmccann: I just memorize the codepoints, man.
17:12:08 <shachaf> Seems easier.
17:12:37 <hiptobecubic> i don't remember who it was on here that had the great unicode lookup thing
17:13:03 <ownchooda> evaluating haskell-mode.el produces an error: "Wrong type argument: stringp, nil."  Why is it so (@#*%&(ing hard to get *anything* Haskell-related to work?!
17:13:08 <shachaf> hiptobecubic: Which thing?
17:13:21 <typoclass> trol: hello, i'm not sure what you're asking, but it might be "xs@(x:z:_)". this means xs will be the name of the entire list, while x and z can still be used (no change)
17:13:35 <hiptobecubic> shachaf, just a static html page with javascript search for unicode
17:13:41 <trol> ooooooo love love thanx
17:13:51 <trol> could you explain a little further @
17:13:55 <shachaf> hiptobecubic: I have a file I search with less.
17:14:03 <hiptobecubic> shachaf, http://john.bitsurge.net/public/unicode-lookup.html
17:14:10 <hiptobecubic> shachaf, same idea
17:15:00 <shachaf> hiptobecubic: Hmm, it matches misspellings.
17:15:02 <int-e> @faq Can Haskell make your life a living hell? (for ownchooda)
17:15:02 <lambdabot> The answer is: Yes! Haskell can do that.
17:15:04 <shachaf> That's useful.
17:15:20 <shachaf> ownchooda: Maybe it's difficult to get Emacs-related things to work.
17:15:27 <shachaf> I edit Haskell code fine without Emacs.
17:15:59 <typoclass> trol: it's simple really. when you do pattern matching (you did it by saying "(x:z:_)"), you can add the "somename@" if you want. it will refer to the entire matched thing (not taken apart with pattern matching)
17:16:03 <int-e> I've never had issues with haskell-mode either.
17:16:05 * cmccann has no problems writing Haskell in SciTE, even with gratuitous unicode snowmans!
17:16:25 <cmccann> writing Haskell on windows can be a real adventure though
17:16:30 <trol> that is great also ither thing
17:16:35 <cmccann> if you try to use anything FFI-based
17:16:36 <typoclass> ownchooda: you might want to talk to johnw when he's around, he spent considerable time setting up haskell and getting it tightly integrated with his emacs
17:16:40 <ownchooda> shachaf: I don't mean to be argumentative, but the file is part of github/haskell.
17:16:41 <hiptobecubic> shachaf, there's also this, which is nice https://github.com/johntyree/latex-to-unicode
17:17:17 <int-e> that said I think I've never installed haskell-mode myself, but relied on distro packages instead
17:17:29 <shachaf> I'm not sure who github/haskell is.
17:17:40 <trol> func74 (x:[]) = func74 (x:[]) = func74 xs@(x:z:_)  return different "syntax" 'h' ('h','b') \"hbg\"
17:18:03 <typoclass> ownchooda: you could have a look at johnw's stuff on github, e.g. this seems relevant https://github.com/jwiegley/haskell-config
17:19:15 <ownchooda> Whatever, people.  I'm getting really fed up with hyper-broken haskell stuff.  Why do we see none of these problems with Python, which I thought was just as 'open' as Haskell?
17:19:38 <cmccann> ownchooda, my stuff's not broken
17:19:43 <cmccann> not sure what your problem is
17:20:02 <ownchooda> cmccann: let's begin and end with cabal and dependency hell.
17:20:27 <cmccann> no, let's not
17:20:31 <cmccann> I'm not interested in arguing with you
17:20:44 <cmccann> because you clearly aren't interested in being convinced otherwise
17:20:56 <ownchooda> But cavetching aside, I sincerely want to know: Python is not as smart as Haskell is, so why do they not have these problems?
17:20:59 <cmccann> just saying, if your shit's broken it's because you broke it
17:21:01 <cmccann> end of story
17:21:07 <ownchooda> OMG!!! HAHAHA!
17:21:29 --- mode: ChanServ set +o copumpkin
17:21:32 --- mode: copumpkin set +b ownchooda!*@*
17:21:32 --- kick: ownchooda was kicked by copumpkin (bye bye)
17:21:34 --- mode: copumpkin set -o copumpkin
17:21:35 <typoclass> cmccann: no, he is reporting that things can't be installed or he can't get them to run
17:22:03 <trol> why "func74 (x:[]) "= "func74 (x:z:[]) =" " func74 xs@(x:z:_)"  return different "syntax" 'x'  ('x','z')  \"xzxs\"
17:22:12 <cmccann> he was reporting that something didn't work, almost certainly through his own fault, and wanted to blame everyone else for it
17:22:38 <typoclass> copumpkin: that was a little harsh ... you didn't even give a warning :( i think he was just frustrated. and it's not like people were very helpful
17:22:52 <int-e> typoclass: maybe, but starting with a general offense to the community rather than describing the actual problem and steps taken to get there is not productive.
17:22:54 <copumpkin> there's frustrated and there's a dick
17:22:58 <cmccann> meh, I've seen that sort of complaint from people in other communities as well
17:23:05 <cmccann> they're not looking to be helped at that point
17:23:20 <typoclass> int-e: fair point
17:23:24 <copumpkin> what kind of answer is there to "is there *anything* that works right in haskell?"
17:23:29 <copumpkin> "um, yes?"
17:23:41 <copumpkin> that's not a question, it's rhetorical
17:24:04 <cmccann> anyway, I gave him the correct answer
17:24:24 <trol> will someone help [19:22] <trol> why "func74 (x:[]) "= "func74 (x:z:[]) =" " func74 xs@(x:z:_)"  return different "syntax" 'x'  ('x','z')  \"xzxs\"
17:24:51 <typoclass> copumpkin: well, a plausible answer could have been "could you describe what you were trying, and what went wrong, and use hpaste if necessary"
17:25:04 <shachaf> trol: Probably not with that phrasing. I doubt anyone understands what's going on with that code.
17:25:04 <copumpkin> [20:20:45] <ownchooda> OMG!!! HAHAHA!
17:25:08 <copumpkin> typoclass: seriously?
17:25:41 <cmccann> typoclass, legitimate questions get legitimate answers
17:26:05 <copumpkin> anyway, I kicked him because that kind of attitude devolves into a bunch of people fighting with him and everyone getting progressively more angry
17:26:17 <copumpkin> if you don't like it, talk to #haskell-ops about it
17:26:26 <copumpkin> the whole point was to avoid too much crap about it happening in here
17:26:26 * shachaf gave up on the fighting early on. :-)
17:26:54 <int-e> shachaf: well extrapolate to 923 people :)
17:27:01 <int-e> (maybe 20 active)
17:27:25 <Peaker> I haven't had great experiences with he emacs Haskell mode myself
17:27:27 <typoclass> cmccann: if you refer to "my stuff isn't broken", that's not a helpful or relevant answer in my opinion
17:27:30 <Peaker> none of the neat stuff seems to work
17:27:50 <shachaf> edwardk: Did you say that existential types were fundamentally contradictory somehow with the way GHC's type checker worked?
17:27:58 <shachaf> First-class, I mean.
17:28:16 <startling> @hoogle (a -> b -> c -> d) -> (c -> a -> b -> d)
17:28:16 <lambdabot> Data.Sequence zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
17:28:16 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
17:28:16 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
17:28:29 <typoclass> copumpkin: i'm okay with kicking him, he was aggressive, but in my view it was pretty quick, it was without warning, and people had not exhausted the route of trying to ask him what he was trying exactly
17:28:51 <startling> @pl \fn a b c -> fn c a b
17:28:51 <lambdabot> (flip .) . flip
17:29:10 * cmccann doesn't have the mental fortitude to be infinitely patient with nitwits
17:29:21 <typoclass> Peaker: have you written about it? blog posts etc.?
17:29:23 <cmccann> that's Cale's department, he's good at helping people
17:29:42 <shachaf> typoclass: He seemed like either a troll or at least someone unconstructive even before the kicking. But I agree about the #haskell-ops thing. :-)
17:39:04 <carter> I was just reading yesterday about the GSOC Immix GC project from 2 summers ago, does anyone know what the final status of tht project was in terms of viability?
17:39:19 <fizzbang> so i've learned that i should use all of unicode for my variable names
17:39:21 <carter> edwardk or others involved with haskell gsoc know?
17:39:22 <fizzbang> you guys helped a lot
17:39:27 <fizzbang> :D
17:39:45 <edwardk> oh the garbage collector changes?
17:39:53 <carter> yes,
17:40:06 <carter> seemed it was gotten to the sortof almost done state
17:40:10 <carter> then
17:40:21 <carter> unclear benchmark data
17:41:08 <Ahora> is Haskell still unable to have different record types with fields of the same name in a module?
17:41:26 <shachaf> Yes.
17:41:27 <edwardk> "Hi. I wondered about continuing my work on the Immix GC collector, but Simon Marlow, my mentor, thought it was not a good idea to invest more effort on Immix. So I dropped it, and started working on other things. Greetings."
17:41:38 <Ahora> schachaf: for me?
17:41:48 <shachaf> Yes.
17:41:50 <carter> whats that quote from?
17:41:56 <Ahora> How can I take this language seriously if you can't even do that
17:42:10 <typoclass> Ahora: yes, a solution is to have them in different modules and import them qualified ("F.fieldname" vs. "fieldname" etc.)
17:42:14 <cmccann> it does lots of things other languages can't do, how can I take them seriously?
17:42:17 <Ahora> I don't want them in different modules
17:42:19 <lpvb> maybe haskell should have some kind of scoping access syntax for records?
17:42:40 <carter> Ahora: what is the *goal* or programming exercise you want to solve?
17:42:44 <Ahora> They are a bunch of tiny little record types, like 30 different ones closely related, they go in the same module
17:42:44 <cmccann> most people who think they want lots of named record fields are misguided anyway
17:42:49 <parcs`> you can have ambiguous field names but you can't use ambiguous field names as functions
17:42:57 <cmccann> I kinda like records being terrible because it encourages beginners to avoid them
17:43:21 <Ahora> theres NO FUCKING WAY i am putting them in separate files, if I do that it will be too unwieldy
17:43:29 <carter> Ahora: you may want to to use a map data structure
17:43:33 <cmccann> Ahora, have you considered not using named fields instead?
17:43:38 <cmccann> pattern matching is nice.
17:43:38 <parcs`> Ahora: give each ambiguous field a meaningful prefix
17:43:42 <Saizan> (i kinda like records being terrible because it discourages people that care about them from sticking to Haskell)
17:43:55 <carter> everyone please chill
17:43:58 <Ahora> I dont want to give different meaningless prefixes, the field names are very clear and they come directly out of my scientific data
17:43:59 <typoclass> Ahora: you might be interested in this http://www.haskell.org/ghc/docs/7.2.1/html/users_guide/syntax-extns.html#disambiguate-fields
17:44:09 <carter> Ahora: you mean you have tabular data?
17:44:56 <edwardk> carter: a now defunct disqus thread
17:45:07 <carter> gotcha
17:45:42 <Ahora> forget it, this is reason to not use Haskell
17:45:50 <Ahora> I will check if it's a real language again in a year
17:45:53 <danharaj> haha ok
17:46:22 <parcs`> is Ahora the same person that copumpkin just kicked?
17:46:31 <shachaf> Probably.
17:46:50 <shachaf> In a few minutes Ahora will be the same person that copumpkin just kicked, anyway.
17:46:56 <shachaf> ...Or not. They left.
17:48:54 <fizzbang> i'm not understanding what his issue was.. he had a bunch of constant values which he wanted to store in a namespaced way?
17:48:57 <startling> ugh, I can't reify something that was just declared?
17:49:12 <startling> can I do Dec -> Info somehow?
17:49:37 <typoclass> startling: probably not, but you could pattern match and things like that. what are Dec and Info?
17:50:03 <startling> typoclass: Dec and Info are from Language.Haskell.TH
17:50:48 <startling> my issue is that I want a deriveSomeClass and i want a mkSomeData that makes a type and derives SomeClass for it
17:50:51 <startling> this is tricky.
17:51:13 <thoughtpolice> fizzbang: he had a bunch of data types which were records, and a bunch of different records all had the same field name. so like, 'data D = D { foo :: Int } ... data E = E { foo :: String }', and that's ambiguous because 'foo' is just a generic function. so if you want to do that, a simple way is to just put things in modules
17:51:20 <thoughtpolice> and then import the modules qualified
17:51:44 <typoclass> startling: good question; i don't really know much about TH
17:51:57 <startling> thoughtpolice: oh hey, that's the problem I'm solving
17:52:12 <thoughtpolice> in general this seems to hint that people want some sort of structural typing, but generally i think i agree it's mostly completely unneeded. if you actually need to overload names, typeclasses are what that's there for
17:52:48 <startling> typoclass: I guess I can just pass [Con] to a deriveSomeClass' and let deriveSomeClass reify and then call deriveSomeClass'
17:53:10 <alephomega> The issue is that people coming from OO languages think types are objects.
17:53:18 <startling> yeah
17:53:47 <typoclass> right, or that records are like oo classes
17:54:20 <shachaf> thoughtpolice: There are reasonable justifications for structural typing. I think if Haskell supported people in here wouldn't say it's completely unneeded as much. :-)
17:55:45 <typoclass> shachaf: we like the status quo, alright? we're humans
17:56:26 <shachaf> typoclass: I'm not a fan of humans.
17:56:32 <Saizan> i think it's more important to have an integration between typeclasses records and modules
17:57:06 <carter> Saizan you may have a good point
17:57:24 <carter> type classes + ML style module / type class functors
17:57:36 <carter> would be pretty darn awesome
17:57:48 <danharaj> typeclasses, records, and modules do some awfully similar things.
17:58:10 <Saizan> and yet different
17:58:15 <carter> danharaj: they're formally the same :)
17:58:25 <carter> cf Coq and Agda to see what that looks like :)
17:58:26 <Saizan> it'd be nice to have easier bridges between them
17:58:29 <typoclass> carter: do you have a link about those famed ml-style modules i keep hearing about?
17:58:51 <carter> read any tutorial on Ocaml or SML?
17:59:07 <typoclass> carter: oh, it's that basic? ok will do
17:59:10 <carter> yeah
17:59:11 <carter> :)
17:59:24 <carter> typoclass theres fancy stuff about the  formal equivalance
18:00:59 <Cale> They
18:01:03 <carter> but basically the things we do with type classes in haskell, SML / Ocaml folks do with Modules, Signatures and Functors
18:01:09 <Cale> They're formally the same, but practically completely different
18:01:15 <fizzbang> seems silly to me for somebody learning a functional language which advertises that it's nothing like an oo language to get upset when they can't apply oo concepts to it..
18:01:28 <carter> (aside from the type recursion stuff originally observed by oleg)
18:01:30 <shachaf> Cale: Aren't the ML things more first-class?
18:01:39 <shachaf> I don't know much about them.
18:01:40 <Cale> carter: *some* of the things... they couldn't stand to use modules for an equivalent to Eq for example
18:01:43 <carter> Cale: yup, exactly
18:01:48 <carter> yeah
18:01:50 <kamatsu> howdy, i'm wondering about some category theory
18:01:50 <typoclass> fizzbang: maybe he didn't get the memo that it's nothing like oo ...
18:02:01 <fizzbang> typoclass: possibly
18:02:02 <carter> the Eq story in ML is definitely wonky
18:02:21 <kamatsu> If I have foo : (a -> m b) -> (n a -> n b)
18:02:32 <kamatsu> where m and n are both monads, such that the functor laws are obeyed but on the monad level:
18:02:32 <m3ga> carter: yes, Eq is weird
18:02:33 <fizzbang> typoclass: but i feel like it's a bilboard clearly readable along any haskell tutorial [THIS GROUND IS UNFAMILIAR]
18:02:48 <kamatsu> i.e (foo f (foo g x) == foo (g >=> f) x) and (foo return x == x)
18:02:49 <Cale> The thing which sets typeclasses apart from first class modules is the whole implicit type-directed choice of implementations for things
18:02:55 <kamatsu> What is "foo"? What is the correct terminology here?
18:02:58 <carter> Cale yup!
18:03:04 <carter> it lets some cool stuff be done
18:03:43 <carter> hopefully the injective / case handling for type families will help put some of the more direct style way's one would like to write that code which currenty needs type classes fu on more solid ground
18:03:52 <carter> (once that gets sorted out)
18:04:45 <alephomega> kamatsu: I'm not sure there's a proper name for it, in category theory anyway.
18:04:53 <Cale> kamatsu: Interesting, hmm
18:05:40 <carter> kamatsu: if i saw that in haskell code
18:05:49 <carter> i'd expect that M can be lifted into N
18:05:56 <carter> or something like that
18:06:04 <kamatsu> it can't, not necessarily.
18:06:08 * cmccann returns from being afk and notes that the person who was upset that haskell only offers flimsy screwdrivers unsuitable for pounding in nails has left
18:06:26 <carter>  cmccann no micrwave lazers either
18:06:27 <kamatsu> in my use case, m is Type and n is Constraint
18:06:38 <kamatsu> (constraints about types)
18:06:51 <carter> kamatsu that fits my remark too :)
18:07:05 <cmccann> no, lazers sound like a good language feature, haskell should have those
18:07:07 <kamatsu> but there's no trivial lift from Type to Constraint
18:07:13 <cmccann> just let me decide what they are
18:07:38 <carter> kamatsu if we lifted the constraints piece to the the front of the type
18:07:55 <fizzbang> maybe i'm not clever enough for this language
18:08:03 <carter> it'd be like N is a monad transformer on top of M
18:08:06 <carter> right?
18:08:10 <kamatsu> carter: these are types, not type schema
18:08:13 <kamatsu> they don't have constraints
18:08:20 <Ralith> cmccann: they're what you get when you use Lenses with Conduits, obviously.
18:08:20 <carter> i know
18:08:33 <carter> constraint kind means theres some constraints then a type
18:08:34 <cmccann> Ralith, that sounds plausible
18:08:49 <carter> cmccann Ralith heheheheheheheheh
18:08:51 <kamatsu> i'm not sure I understand
18:09:14 <carter> kamatsu: are we talking about foo is a function you have
18:09:18 <carter> or an idea?
18:09:23 <kamatsu> it's a function
18:09:25 <carter> ok
18:09:35 <carter> whats a concrete instantiation of N and M you have ?
18:09:49 <kamatsu> like i said, type terms for m, constraint terms for n
18:10:02 <carter> no
18:10:09 <kamatsu> as in data Type n = Var n | Function (Type n) (Type n) | ...
18:10:18 <carter> kamatsu
18:10:20 <carter> i understand
18:10:26 <carter> hrm?
18:10:42 <carter> you mean kinds * vs kind constraint
18:10:49 <typoclass> fizzbang: what's up?
18:10:50 <kamatsu> no
18:10:59 <kamatsu> this isn't actually Haskell i'm writing, i'm writing Agda
18:11:10 <carter> kamatsu, ohhhh
18:11:11 <carter> ok
18:11:12 <kamatsu> but I'm talking about a syntax tree
18:11:34 <carter> i thought you had some haskell code :)
18:11:40 <carter> so your responses were confusing me
18:11:43 <kamatsu> which is parameterised by the type of some available variables.
18:11:55 <kamatsu> Type is a monad where substitution is a kleisli arrow
18:12:13 <kamatsu> bind: Type a -> (a -> Type b) -> Type b is applying a substitution
18:12:22 <kamatsu> now, constraint terms can contain type terms
18:12:31 <kamatsu> and sometimes I want to apply a type substitution to those constraints
18:12:36 <kamatsu> that's where I get:
18:12:56 <kamatsu> foo : (a -> Type b) -> Constraint a -> Constraint b
18:13:03 <kamatsu> oh wait, but Constraint isn't necessarily a monad
18:13:04 <othiym23> hey all
18:13:05 <kamatsu> it's just a functor
18:13:13 <typoclass> othiym23: hello
18:13:19 <alephomega> Hi.
18:13:48 <othiym23> if I want a language that's pure, with no built-in I/O support, and no built-in concurrency primitives, is there a way to cut Haskell down to that size?
18:14:22 <othiym23> I've been thinking about playing with libuv + scheme, and realized it would be nice to have a real type system
18:14:23 <kamatsu> othiym23, sure, just use Safe Haskell and demand a value of some non-IO type
18:14:34 <typoclass> othiym23: i guess you could just avoid the IO monad and you'd have a very pure language then. question is what that would actually help :)
18:14:39 <othiym23> well, it would be awesome if it were embeddable, too
18:15:34 <othiym23> there would be IO, and maybe I could even reuse the IO monad / unsafeIO, but the goal would be to leverage the purity to come up with an evented async IO system without JavaScript's reliance on mutation / state
18:15:39 <carter> othiym23 what level of emdbed are you talking about here?
18:15:44 <typoclass> othiym23: or you could investigate lambdabot or ghci (?), which evaluate haskell but refuse to do IO actions
18:15:51 <carter> theres also lib approaches like Accelerate
18:15:56 <danharaj> ghci does io actions just fine
18:15:57 <carter> that let you write haskell style code
18:16:01 <carter> but compile to something else
18:16:15 <typoclass> danharaj: right
18:16:40 <carter> kamatsu: ok, those details  help  :)
18:17:10 <othiym23> Safe Haskell might do what I want, depending on if I can get the FFI to libuv to do what I want
18:17:13 <kamatsu> yeah, so our "n" isn't necessarily a monad, but it is a functor
18:17:57 <kamatsu> but i can map not just straightforward function arrows a -> b but also kleisli arrows a -> type b
18:18:02 <othiym23> it would be great to be able to actually use the continuation monad explicitly over async operations
18:18:30 <kamatsu> ah, so, we have two functors here
18:18:36 <othiym23> if you haven't played with Node.js, you haven't learned what a pain it is to reason about async / CPS built entirely on pure callbacks
18:19:53 <alephomega> So basically we have a map from kleisli a kleisli category to an arrow category, only lifted... sort of?
18:19:58 <carter> kamatsu glad I could help by way of question asking
18:20:09 <danharaj> every monad is an arrow
18:20:15 <danharaj> and I'm not sure anyone cares :3
18:20:17 <typoclass> othiym23: heh, yeah, there's periodically people in here talking about how annoyed they are by node.js
18:20:18 <danharaj> arrows aren't very awesome
18:21:12 <othiym23> node is AWESOME unless / until you want to reason about your execution contexts at a higher level -- it's lightweight, minimal and fast, but it's not designed for reasoning about FP
18:22:09 <othiym23> and that's largely due to the huge stateful hole mutation (by which I mean JS's assignment-heavy OO style) opens in controlling the flow of state through execution
18:22:21 <othiym23> that's maybe not worded the most elegantly, but maybe you catch my drift
18:22:27 <kamatsu> so, I'm just trying to work out the language I should use to express this now
18:23:34 <othiym23> I'm writing instrumentation for Node, so I've got code that needs to transparently operate over user code written against 3rd party code, and I have no control over what either side decides to do, and there are a billion ways libraries doe things in Node because of the absence of any conventional metaphor for flow control
18:24:23 <othiym23> also, exceptions in async code are horrific and make me pine for Either or Maybe or some other standardized ways of forcing out-of-band exception data into a conventionalized channel
18:25:12 <othiym23> the way the latest version of Node does it, domains, isn't hacky, but it does touch a lot of pieces of the code base and doesn't capture all of the situations in which exceptions / errors can be raised
18:25:14 <othiym23> anyway!
18:25:48 <othiym23> I'll give SafeHaskell a shot -- I have a feeling what it's expecting to do is the exact opposite of what I'm going to do with it, but it'll be a learning experience
18:26:26 <othiym23> thx for the pointers, Accelerate looks cool as well
18:26:50 <typoclass> othiym23: good luck then!
18:27:45 <gaze_> Say I have data a, data b. Data a and b are both instances of X, which has one function f, which takes one argument and returns type c. Say I want to serialize a and b to disk, with a Show, and some other step to preserve WHICH type I'm serializing, and then be able to map (\x -> f (Read' x)) ["serialized data", "serialized data"] where Read' has type Read' :: X n => String -> n
18:28:26 <gaze_> I could use template haskell and generate all my Read's  and use some sorta wrapper type
18:28:29 <typoclass> gaze_: you mean read' instead of Read' ?
18:28:30 <gaze_> but is there a better way?
18:28:34 <gaze_> ah yeah whoops!
18:29:56 <t7> whats the time package in base/ haskell platform?
18:30:06 <typoclass> t7: import Data.Time
18:30:23 <gaze_> maybe there's some trick using generics? I dunno
18:30:47 <typoclass> gaze_: so the 'some other step' would put type information into the strings, right? it'd be inside of those "serialized data"s
18:31:40 <gaze_> yeah. In the case of template haskell I'd have a data XWrap = AWrap A | BWrap B; then you could Show AWrap x
18:32:06 <gaze_> could generate all that stuff
18:32:18 <gaze_> and then sorta do the reverse for read
18:34:07 <typoclass> t7: here's some good information (i've always found the haddock difficult to figure out) http://pleac.sourceforge.net/pleac_haskell/datesandtimes.html
18:34:32 <shachaf> @@ @read @run (@where rot13) @show shachaf
18:34:34 <lambdabot>  funpuns
18:34:35 <shachaf> Who needs @let?
18:35:06 <typoclass> gaze_: i don't really have any ideas, but you're aware of Data.Typeable, right? http://stackoverflow.com/questions/6600380/what-is-haskells-data-typeable
18:36:14 <typoclass> shachaf: that must have taken a lot of attempts in your private lambdabot window :-) what's @where?
18:36:30 <ski> @where LYAH
18:36:30 <lambdabot> http://www.learnyouahaskell.com/
18:36:31 <shachaf> typoclass: It worked on the first attempt!
18:36:34 <ski> @help where
18:36:35 <lambdabot> where <key>. Return element associated with key
18:36:59 <typoclass> uhm, right, i'm an idiot
18:37:03 <typoclass> thanks
18:38:33 <t7> @hoogle fromReal
18:38:34 <lambdabot> No results found
18:38:51 <t7> @hoogle DiffTime -> Float
18:38:52 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
18:38:52 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:38:52 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
18:39:01 <typoclass> shachaf: we should change @where so that it supports a namespace for actual whereish things and a namespace for functions!
18:39:39 <t7> how do i get time (seconds) in Float or whatever?
18:39:41 <typoclass> t7: the answer is realToFrac
18:41:06 <t7> hmm i dont think DiffTime does microseconds...
18:41:37 <t7> oh haha
18:41:43 <t7> wasnt requesting new frame
18:42:27 <typoclass> t7: most of the Data.Time stuff is synonyms for Data.Fixed.Picos (12 decimal places or some such)
18:48:54 <t7> IO State errywer yucks
18:50:15 <Ralith> that seems like an extremely silly type
18:51:33 <ceezer> hello, is there a function like scanl1 that does not return the final result, just the intermediate ones?
18:52:32 <shachaf> @ty init .: scanl1
18:52:34 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
18:53:37 <t7> i got a ghost window in xmonad :|
18:55:15 <gaze_> shachaf: I've got another one for ya: http://stackoverflow.com/questions/12878651/haskell-data-serialization-of-some-data-implementing-a-common-type-class
18:55:54 <shachaf> gaze_: Are you the same person as the "list of IO ()" person?
18:56:03 <gaze_> yeah.
18:56:55 <shachaf> I'm not quite sure what the question is...
18:57:06 <shachaf> What's the point of the type class?
18:57:08 <shachaf> What behavior do you want?
18:58:53 <shachaf> Anyway, read' is impossible to write with your class.
18:59:07 <gaze_> I want to be able to serialize some types A and B to strings and somehow get the fact that they have type A or B in with them, so that when I read them back, I'd be able to call the relevant functions of their common typeclass on them
18:59:43 <shachaf> gaze_: Are you sure a type class is the right answer?
18:59:58 <gaze_> no, not at all.
19:00:42 <ski>   data A_or_B = It's_an_A A | It's_a_B B
19:01:03 <shachaf> ski: Yes, that's mentioned in the link.
19:01:31 <gaze_> definitely don't want that... I'd like to provide this as a sort of API for people
19:01:36 <shachaf> I think gaze_ is vague about the question, so we must be even vaguer about the answer. :-)
19:01:44 <gaze_> hahaha
19:01:47 <t7> opengl lights transform with the modelview matrix ! :O
19:01:53 <shachaf> Also Thomas's answer doesn't really help.
19:02:14 <shachaf> Show corresponds to existential types, sort of, but Read corresponds to universal types.
19:02:35 <t7> so i have to position lights for every object?
19:02:38 <ski> gaze_ : i suspect that you really want something like
19:02:39 <t7> my head hurts
19:02:47 <ski>   read' :: String -> exists a. X a *> a
19:02:54 <ski> (rather than your current signature?
19:02:57 <ski> s?/)/
19:03:31 <gaze_> I'll be more specific. A might contain information on how to connect to an FTP server and download a file. B might contain information on how to connect to some other kind of server and download a file... they're different and correspond to how to do different actions
19:03:58 <gaze_> and then I want my program to read these data structures off the disk and call the relevant functions on them to run the task
19:05:02 <gaze_> Q would be IO (), for instance... and f might be called runTask
19:05:38 <gaze_> does that make a bit more sense?
19:05:50 <ski> you need some way of encoding in the serialization which type `a' is intended (or at least which behaviour is intended, if it doesn't matter if you read back as the same type or not)
19:06:09 <shachaf> gaze_: So how about somethign like parse :: String -> IO (); parse ('F':'T':'P':blah) = mkFtp blah; parse (...) = ...
19:06:27 <gaze_> I don't want the user to have to write this
19:06:28 <typoclass> gaze_: i'm not sure what you're planning, but i'd recommend to try a much simpler approach. try the simplest thing that could possibly work. you can expand later
19:06:33 <ski> if you have a closed set of alternatives, you can go the `data A_or_B' way (at least if you have a place in the program which knows about all the alternatives)
19:06:42 <shachaf> gaze_: User?
19:07:21 <gaze_> I'm writing a DSL for stringing together idempotent steps where data never gets lost between each step
19:07:27 <ski> for an open set, one would presumably need some way of allocating some kind of id strings to different instances of `X' -- and i'm not sure how to best do that
19:07:32 <gaze_> and each step is like... download an mp3, re-encode it
19:08:34 <typoclass> gaze_: and the expressions in your DSL is read from disk?
19:08:49 <gaze_> typoclass: No. Backups of the intended actions are.
19:10:21 <gaze_> damnit... okay... I just figured out the right way to do this... but I'm still curious if there's a non template-haskell way to do this thing
19:10:26 <gaze_> just the problem as stated generally
19:12:27 <hpaste> gaze_ pasted “Moop” at http://hpaste.org/76260
19:14:35 <gaze_> the answer to my problem is you make each server name itself in it's Ticket typeclass, so that upon restart, the server can read through a designated subdirectory where all of it's serialized data has been put and you're guaranteed that it'll read serialized data of the proper type
19:14:38 <gaze_> and it'll be more organized
19:16:06 <ski> (i'd do the `get'&`put' with `modify' -- and no need for `return ()' there)
19:16:35 <typoclass> gaze_: have you considered using the shell? "wget ftp://.../somefile.mp3 | somerecodetool ..." or of course the equivalent thing in haskell, e.g. with the shelly library
19:16:58 <gaze_> that has the exact problem I'm trying to solve
19:17:11 <gaze_> which is that if something fucks up in the middle, you have to start the whole thing over again
19:17:21 <fizzbang> i'm curious... now that i've learned about functors, why would i ever use "map" instead of "fmap" ?
19:17:42 <gaze_> this tracks the data as it flows through the | and ensures that it never ever gets lost
19:18:23 <startling> do you typically put your email address in the Author field for cabal or is there another field for that?
19:18:26 <ski> fizzbang : perhaps if you want to emphasize to the reader that you're talking about lists -- or if you want to constrain to working with lists for some reason
19:18:46 <startling> fizzbang: you wouldn't
19:19:03 <fizzbang> ski: startling: i like both of your anwsers. :)
19:19:05 <Cale> fizzbang: Basically, it's silly that map isn't generalised
19:19:16 <gaze_> basically runFTPToRecoder runs totally atomically. each pushticket is pushing an io action as well as the information necessary to delete that the previous task needs to happen while pushing that the next tasks need to happen
19:19:25 <Cale> In Haskell 1.4, we had  map :: (Functor f) => (a -> b) -> f a -> f b
19:19:32 <gaze_> ya dig?
19:19:40 <typoclass> gaze_: ok ... my first suggestion is that wget and similar tools have a switch for "resume this partial download". my second suggestion is, have a look at conduits and http-conduits (they're on hackage, well-documented, simple to use, and there's a chapter in the yesod book describing them)
19:19:51 <Cale> But some people said "waaah, I don't want to teach my students about typeclasses!"
19:20:02 <Cale> and there you go
19:20:19 <shachaf> Cale: To be fair, most type classes aren't as nice as Functor.
19:20:20 <gaze_> this isn't streaming data though
19:20:24 <startling> where do I see a list of all the hackage/cabal classes?
19:20:33 <startling> s/classes/categories
19:20:37 <startling> dunno where that came from
19:20:42 <gaze_> this is about atomicly pushing tiny pieces of data through and atomically storing that they have to happen and have happened
19:21:42 * ski . o O ( Helium  )
19:21:59 <gaze_> it's an entirely separate problem
19:22:12 <typoclass> Cale: right, but i do think that innocent beginnerish mistakes (5 + "6") cause wild error messages (No instance for (Num [Char])), which can be difficult to read for beginners
19:22:16 <shachaf> My .ghci is up to enabling 37 extensions.
19:22:28 <fizzbang> "The Haskell 98 report was released in February 1999; it is a refinement and simplification of Haskell 1.4."
19:23:05 <Cale> typoclass: Right, this is true independently of map being generalised -- type classes are one of the first things you have to tell students about
19:23:10 <shachaf> Cale: Sometimes I read bits of the Haskell 1.4 report and get sad. :-(
19:23:11 <Cale> because of error messages like that
19:23:14 <typoclass> Cale: yes, absolutely
19:23:34 <fizzbang> typoclass: yes, i have a heck of a time understanding error messages; even after reading the Monad Reader's article about them
19:23:49 <shachaf> -XNoMonomorphismRestriction -XRankNTypes -XMagicHash -XScopedTypeVariables -XImplicitParams -XTemplateHaskell -XQuasiQuotes -XBangPatterns -XPatternGuards -XViewPatterns -XParallelListComp -XTupleSections -XPostfixOperators -XTypeOperators -XGADTs -XKindSignatures -XConstraintKinds -XPolyKinds -XDataKinds -XFlexibleContexts -XFlexibleInstances -XMultiParamTypeClasses -XTypeFamilies -XLiberalTypeSynonyms -XPolymorphicComponents ...
19:23:54 * hackagebot hs-pkpass 0.2 - A library for Passbook pass creation & signing  http://hackage.haskell.org/package/hs-pkpass-0.2 (VincentAmbo)
19:23:54 <t7> i swear translations are in the wrong order :|
19:23:55 <shachaf> ... -XStandaloneDeriving -XDeriveDataTypeable -XDeriveFunctor -XUnboxedTuples -XImpredicativeTypes -XOverloadedStrings -XLambdaCase -XMultiWayIf -XInstanceSigs -XDefaultSignatures -XGeneralizedNewtypeDeriving -XFunctionalDependencies
19:24:09 <shachaf> Finally with GHC 7.6 I can enable OverloadedStrings!
19:24:11 <Cale> fizzbang: Start by just paying attention to the line number, then when you figure out what the problem was, re-read the message :)
19:24:56 <typoclass> shachaf: MultiWayIf and LambdaCatse are new in 7.6 as well, aren't they?
19:25:01 <Cale> (and eventually you'll understand them all :)
19:25:04 <shachaf> typoclass: Yes.
19:25:19 <shachaf> typoclass: OverloadedStrings isn't new in 7.6, but I think being able to use it in ghci is.
19:25:22 <shachaf> (I.e. String defaulting.)
19:25:36 <fizzbang> Cale: thanks; it's that re-reading i need to establish a habit for :)
19:26:19 <Cale> Most of them actually make a lot of sense, but if you're not used to the technical terms, it can be a bit weird.
19:26:31 <shachaf> What else should I turn on?
19:26:46 <Cale> ... LADIES
19:26:58 <wlangstroth> agreed. -XLadies
19:27:01 <shachaf> Cale: Error messages still don't make so much sense that I read them before going to the relevant line number and reading that.
19:28:01 <typoclass> fizzbang: the error message usually tells you almost everything. read what function it complains about, then first of all do :t function. that's about the only thing that the error messages do not mention (perhaps they should)
19:28:05 <typoclass> > 5 + "6"
19:28:06 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
19:28:06 <lambdabot>    arising from the literal ...
19:28:10 <typoclass> :t (+)
19:28:11 <lambdabot> forall a. (Num a) => a -> a -> a
19:29:00 <dolio> shachaf: Turf off your lambdacats autocomplete.
19:29:06 <dolio> Turn, even.
19:29:09 <parcs`> shachaf: what do you mean about OverloadedStrings and ghci?
19:29:25 <shachaf> dolio: ?
19:29:33 <shachaf> parcs`: It used to give annoying ambiguity errors in some contexts.
19:29:39 <shachaf> In 7.6 it defaults to String.
19:29:41 <dolio> "LambdaCatse"
19:30:16 <shachaf> I assume typoclass meant LambdaKatze
19:30:23 <parcs`> shachaf: example?
19:30:24 <typoclass> shachaf: i know. i've rigged up vim so that it shows ghc's messages and jumps to the line that it refers to
19:30:31 <dolio> Man, I can't read.
19:30:50 <typoclass> shachaf: sure why not, both languages are fusing into lolcatese anyway
19:30:58 <startling> merijn: you were the one I was talking about this, right? https://github.com/startling/mixin
19:31:12 <shachaf> parcs`: Oh, wait.
19:31:14 <typoclass> dolio: read again what i said :) i did actually write that
19:31:18 <shachaf> This has nothing to do with 7.6.
19:31:24 <shachaf> It's something else in my .ghci somewhere.
19:31:29 <dolio> typoclass: Yeah, but you wrote it.
19:31:35 <dolio> Not shachaf.
19:32:00 <typoclass> dolio: yes absolutely
19:32:08 <fizzbang> Cale: typoclass: thanks!
19:32:14 <shachaf> parcs`: Wait, I was completely wrong.
19:33:11 <shachaf> parcs`: It's still broken. :-(
19:33:24 <parcs`> yeah :(
19:33:46 <startling> merijn: it took a surprisingly small amount of code, too
19:35:44 <parcs`> a simple fix for the ambiguity problems with OverloadedStrings is to change the 'IsString [Char]' instance to '(a ~ Char) => IsString [a]'
19:36:14 <shmoo_> If I wanted to depend on a local development version of a package ive already installed with cabal, what is the best way to go about this without installing the develpment version? Just mirror the contents of its cabal file?
19:37:44 <typoclass> parcs`: aaah, that reminds me of the time where i made 3-4 weird OverloadedString instances for IO String and [String] -> IO String and such. the error messages got very funky after that
19:39:54 <typoclass> shmoo_: maybe you could put cabal-dev to use ...? it creates a new repo of installed cabal packages inside your project directory (not touching the common ~/.cabal directory)
19:40:28 <shmoo_> ahh, probably, i'll go check it out, thanks.
19:40:59 <typoclass> shmoo_: alternatively, it has worked for me to do "cabal unpack", change stuff in the package, and then do "cabal install" again. don't forget to bump the version number a little (i got terribly confused once)
19:41:23 <parcs`> typoclass: that reminds me of the time i had an IsString CString instance
19:42:37 <typoclass> shmoo_: if you want some packages to use your modified version, and some packages to use the unmodified old version, you'd have to put in some version constraints. perhaps via the command line while installing (cabal install foo --constraint='doodle <= 1.4' or some such, you need to look up the exact syntax)
19:45:11 <typoclass> parcs`: that seems fairly benign :) my use case was that i wanted to allow «"grep whatever.txt"» in an IO do block, alone on its own line, and it'd be run as a rawSystem or whatever. ultimately i decided it was idiotic, but not after implementing it and trying it out :-D
19:45:59 * typoclass is like the kid who was warned severely not to touch the hot pan, and does it exactly *because* of the warning, to see what the fuss was about
19:47:14 <fizzbang> i have a record type with a list containing some other stuff ... I have the list as ":: Maybe [Stuff a]"  ... but that's silly because the list can just be empty... so maybe it should be ":: [Stuff a]" ??
19:47:41 <trol> why the returns of this functions have so different syntax
19:47:42 <trol> func74 :: (Show a) => [a] -> String func74 [] = "Shit " func74 (x:[]) = "This list is fucking faggot 1 " ++ show x func74 (x:z:[]) = = "All your family deserves to die 2 " ++ show (x,z) func74 xs@(x:z:_)  ="fuck you all + " ++ show xs
19:47:52 <ski> fizzbang : it's not the same thing
19:48:22 <ski> fizzbang : in the first case, there's a distinction between there being an empty list present and there being no list present
19:48:44 <fizzbang> ski: yes, and i don't think i need that distinction..
19:48:54 <ski> then remove the `Maybe' ?
19:48:58 <latro`a_> @where op
19:48:58 <lambdabot> I know nothing about op.
19:49:01 <latro`a_> ...
19:49:07 <fizzbang> ski: genius! .. done.
19:49:07 <latro`a_> @ops
19:49:07 <lambdabot> Maybe you meant: docs oeis pl
19:49:09 <typoclass> trol: please watch your language. also, please use hpaste for pastes longer than 1 line
19:49:10 <latro`a_> @op
19:49:11 <lambdabot> Maybe you meant: . ? @ bf do ft id map pl rc v wn yow
19:49:11 <typoclass> @where hpaste
19:49:12 <lambdabot> http://hpaste.org/
19:49:13 <latro`a_> bah
19:49:30 <ski> latro`a_ : `op' is a keyword in SML ..
19:49:34 <t7> @hoogle fmap
19:49:35 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
19:49:35 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
19:49:35 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
19:49:44 <latro`a_> ski--I thought lambdabot had a command to ping ops
19:49:58 <trol> ok i just release wome pressure when writing code :!
19:50:24 <ski> latro`a_ : is there a reason to ping ops ?
19:50:24 <fizzbang> poll: (A) record types should use short names, which are all about the same length and easy to remember or (B) record types should use evocative names written in camelcase
19:50:36 <hpaste> zungaloca pasted “WEIRD RETURN” at http://hpaste.org/76261
19:50:45 <latro`a_> not necessarily, but I thought they should at least see what trol wrote above
19:51:05 <latro`a_> (I also (apparently mistakenly) assumed that trol's name was appropriate, if you catch my drift)
19:51:35 <trol> if i am trol then not very smart troll
19:53:02 <ski> trol : is there a valid reason for spewing such profanity in your code snippet ?
19:53:39 <ski> i think most people here would appreciate it if you didn't do it again
19:54:07 <typoclass> ski: i told him, and he indicated he understood ...?
19:54:35 <trol> just release some pressure when writing code :!
19:54:43 <ski> ok
19:54:45 <typoclass> fizzbang: either one is fine, i think. my rule of thumb is, the bigger the scope where a name is visible, the longer its name should be. the upper limit is 3-4 words. (i find it unreadable to have objective-c-style names with 10 words, the only really meaningful words being #6 and #9 or whatever)
19:55:06 <typoclass> trol: so, what exactly was your question about that code?
19:55:19 <trol> why their return are so different
19:55:19 <ski> trol : i'm not sure what you mean by "the returns of this functions have so different syntax"
19:55:58 <trol> 'h' ('h','b') \"hbg\"
19:56:19 <trol> list with 1 elemetn 2 elements more than 2 elements
19:56:36 <ski> `show' can convert values of many different kinds to a string
19:56:46 <ski> `++' can concatenate strings
19:56:57 <fizzbang> typoclass: i'm trying to decide between "offset, dimensions, parts" and "offs, dims, parts" :)
19:57:04 <ski> `(x,z)' is not a list, it's a pair
19:57:09 <fizzbang> guess it's not important..
19:58:08 <hpaste> zungaloca pasted “This” at http://hpaste.org/76262
19:59:27 <typoclass> trol: ok, when you do "show" on a single Char (like 'h'), it comes out as 'h'. when you do "show" on a tuple like (x,z), it comes out as "(... , ...)", and then internally "show" is again called for the x, and another time for the z
20:00:08 <trol> i tough show always returned a plain strign
20:00:18 <ski> yes
20:00:30 <ski> the input gets encoded as a string
20:00:36 <typoclass> trol: this is being done using typeclasses (your textbook probably has a chapter on them). the 'show' function is defined in a typeclass and therefore it behaves differently when you give it different values
20:00:39 <ski> > show 'h'
20:00:40 <lambdabot>   "'h'"
20:00:47 <ski> > show ('h','b')
20:00:49 <lambdabot>   "('h','b')"
20:00:57 <ski> > show "hbg"
20:00:58 <lambdabot>   "\"hbg\""
20:01:03 <typoclass> trol: yes, the output of 'show' is always a String. but the input can be a number of things
20:01:21 <typoclass> :t show
20:01:23 <lambdabot> forall a. (Show a) => a -> String
20:01:59 <trol> ok but why those \\ bars
20:02:17 <latro`a_> those are escape characters
20:02:18 <ski> > length "\""
20:02:20 <lambdabot>   1
20:02:27 <typoclass> trol: ^^ this means it gives back a String, but it takes *any* type as long as we have an instance of the Show typeclass, for that type. and there's probably a dozen of those instances for all kinds of things
20:02:30 <typoclass> @instances Show
20:02:31 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
20:02:46 <latro`a_> > show (1,2,3,4,5)
20:02:47 <lambdabot>   "(1,2,3,4,5)"
20:02:48 <ski> that computed the length of a string containing a single character : a `"' one
20:02:53 <latro`a_> apparently @instances lies
20:02:53 <latro`a_> :p
20:02:59 <latro`a_> also, how does one show an ST
20:03:04 <shachaf> ski: `"'? That's three characters!
20:03:19 <ski> trol : to include a `"' in a string literal, you need to escape it with a `\', like `\"'
20:03:22 <danharaj> > show ((),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),())
20:03:23 <lambdabot>   No instance for (GHC.Show.Show
20:03:23 <lambdabot>                     ((),
20:03:24 <lambdabot>                    ...
20:04:22 <ski> > return () :: ST Int ()
20:04:23 <lambdabot>   <<ST action>>
20:04:35 <trol> ok gotta read it slowly
20:05:44 <ski> trol : we can't just write the quotation mark directly in the string literal, since then it'd get interpreted as terminating our string, instead of including a quotation mark in the string
20:06:08 <ski> > ['a','b','"','c','d']
20:06:10 <lambdabot>   "ab\"cd"
20:15:47 <t7> http://i.imgur.com/Bfpsv.png 'ark at me making a 3d roguelike... in haskell
20:16:52 <Cale> t7: So many spelling mistakes! ;)
20:17:13 <t7> Cale: yeah i wish it only worked on comments :(
20:22:49 <t7> how do i do floating point mod?
20:23:55 <latro`a_> is there no builtin for that?
20:23:58 <latro`a_> I can't think of one
20:23:59 <latro`a_> :t rem
20:24:00 <lambdabot> forall a. (Integral a) => a -> a -> a
20:24:02 <latro`a_> :t mod
20:24:03 <lambdabot> forall a. (Integral a) => a -> a -> a
20:24:04 <latro`a_> hmm
20:24:10 <latro`a_> is the base floating?
20:24:16 <t7> no
20:24:29 <latro`a_> if not then you can get the fractional part and do integer mod
20:24:33 <latro`a_> and add it back
20:24:44 <t7> good thinking
20:26:48 <Cale> :t mod'
20:26:49 <lambdabot> forall a. (Real a) => a -> a -> a
20:27:03 <Cale> :t divMod'
20:27:05 <lambdabot> forall a b. (Real a, Integral b) => a -> a -> (b, a)
20:27:18 <Cale> t7: These are in Data.Fixed
20:27:28 <t7> hmm i need my floating point mod 1
20:27:43 <t7> ah thanks
20:27:43 <Cale> > mod' pi 1
20:27:44 <lambdabot>   0.14159265358979312
20:28:25 <cmccann> it's kind of reassuring, when testing a simple type-checker you've implemented, having the first error encountered turn out to be a typo in the type of a test expression
20:31:53 <cornihilio> hey, can I execute multiple lines of code in a case statement selection? something like case a of b -> { blah blah; blah blah; blah blah;}? Hopefully that makes sense.
20:32:12 <t7> rotate (mod' t 2 * 360)   should rotate 360 degrees every 2 seconds if t is +1 per second, right?
20:32:32 <t7> that rotation is stateless
20:33:09 <t7> oh i need 180
20:33:35 <shachaf> Degrees. :-(
20:33:50 <t7> opengl
20:34:20 <shachaf> cornihilio: That depends on what "execute multiple lines of code" means.
20:34:28 <shachaf> It has no fundamental meaning in Haskell.
20:34:33 <shachaf> You might be looking for "do", though.
20:38:13 * cmccann thinks usual angle measurements are needlessly complicated
20:38:38 <cmccann> working in terms of fractions of a complete revolution is much more intuitive
20:39:22 <cmccann> who needs irrational numbers or arbitrary integers chosen because of convenient prime factors.
20:39:48 <Cale> Measuring the arc length of a curve along a unit circle seems very natural though :)
20:39:56 <t7> > 2 * pi
20:39:58 <lambdabot>   6.283185307179586
20:40:14 <danharaj> physics has taught us that factors of pi and 2 don't matter.
20:40:52 <shachaf> pi isn't very natural.
20:41:26 <shachaf> Measuring arc length is natural, though.
20:41:32 <shachaf> Measuring fractions of a full turn is also natural.
20:42:04 <t7> > (sin 0, sin pi)
20:42:06 <lambdabot>   (0.0,1.2246467991473532e-16)
20:42:17 <shachaf> > sin (2*pi)
20:42:19 <lambdabot>   -2.4492935982947064e-16
20:42:27 * cmccann notes that "fractions of a full revolution" is radians with a factor of 2*pi removed
20:42:34 <shachaf> > sin (pi 2)
20:42:35 <lambdabot>   1.2246467991473532e-16
20:42:40 <shachaf> cmccann: Right.
20:42:53 <cmccann> but it sounds so much simpler phrased the way I said it!
20:43:43 <shachaf> cmccann: I like using fractions of 360*pi
20:43:53 <cmccann> the best of both worlds!
20:44:00 <danharaj> shachaf: parametrising a curve by its length is natural though. Behold the 2*pi
20:44:02 <latro`a_> "best"
20:44:04 <latro`a_> sure
20:44:05 <latro`a_> -_-
20:44:44 <shachaf> cmccann: Sometimes I use fractions of e instead.
20:44:57 <shachaf> The poor constant feels so lonely.
20:45:46 <cmccann> though really, roots of unity are the way to go
20:46:05 <cmccann> complex numbers with a magnitude 1 are nice and simple, right
20:46:11 <shachaf> Hah.
20:46:34 * shachaf didn't know they were called that.
20:46:58 <danharaj> some of them are called that :P
20:47:39 <shachaf> danharaj: ?
20:48:10 <t7> every (2 pi) seconds my box moves in a complete circle
20:48:15 <danharaj> not all numbers of norm 1 are roots of unity
20:48:27 <cmccann> yeah
20:49:17 <t7> mod' seconds (2 * pi) * 57.295 = my angle to look at it?
20:50:49 <danharaj> wha
20:50:54 <cmccann> danharaj, I expect the roots of unity would include all rational fractions of a complete rotation though
20:51:34 <danharaj> cmccann: sure
20:52:05 <t7> im gonna just use lookAt
20:52:08 <cmccann> so they work for my running joke of proposing alternate forms of angle measurement that are trivially equivalent to the rest
20:52:11 <t7> that was a waste of 30 mins
20:52:13 <cmccann> :D
20:52:58 <shachaf> cmccann: Is it trivial if you have to argue about it on IRC for a few minutes before being sure that it's correct?
20:53:09 <shachaf> ...Well, maybe people *only* argue about trivial things on IRC, actually.
20:53:21 <cmccann> it's a mathematical question that has a known answer
20:53:24 <cmccann> that's what trivial means
20:54:14 <cmccann> (cf. the feynman anecdote about math students)
20:54:22 <danharaj> cmccann: just refer to it as SO(2,R)
20:54:37 <cmccann> good idea!
20:56:31 <eflister> hola.  i'm trying to use the mysql package on windows.  it wants to link against mysqlclient.dll, but i can only get mysql to install a .lib.  does anyone know how to either a) convince mysql to link against a static lib, or b) convince mysql to install a .dll?
21:09:38 <cornihilio> hey, I have a really weird error. I have this attoparsec parser https://gist.github.com/3887256 and all of the trace statements are printing, but for some reason the result of running the parser I am getting is Fail, not Done. Why is that? Is there any way for me to narrow down the error?
21:10:33 <shachaf> cornihilio: Put a trace after endPacket?
21:10:37 <eflister> anyone ever used the mysql binding on windows?  does bos ever hang out here?
21:10:41 <shachaf> trace "allDone" $ return ...
21:10:57 <shachaf> If that doesn't print, the problem is probably in endPacket.
21:11:56 <cornihilio> shachaf: wow, you're right, it's not getting there. thank you so much!
21:12:02 <eflister> @seen bos
21:12:03 <lambdabot> Unknown command, try @list
21:15:25 <eflister> @list
21:15:26 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:15:33 <eflister> @help
21:15:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:15:43 <eflister> @help seen
21:15:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:16:15 <shachaf> preflex: seen bos
21:16:15 <preflex>  bos was last seen on #haskell 1 day, 11 hours, 6 minutes and 18 seconds ago, saying: shachaf: week after next
21:18:41 <eflister> thanks shachaf.  any chance you know anything about the mysql binding he maintains?  :)
21:19:24 <shachaf> I don't know anything about libraries on Windows.
21:20:03 <eflister> cool, thanks.  how about getting a binding to link against static instead of shared libs?
21:26:35 <eflister> preflex: seen midfield
21:26:35 <preflex>  midfield was last seen on #haskell 2 years, 130 days, 20 minutes and 12 seconds ago, saying: goodnight!
21:26:57 <shachaf> eflister: Shouldn't it do that by default?
21:28:06 <eflister> shachaf: i don't know anything about linker stuff, but it is looking for a .dll and all i have is the .lib.
21:30:03 <ricree> identify rar030025
21:31:39 <Ralith> welp
21:31:55 <shachaf> ricree: Might want to change that.
21:32:12 * Ralith resists urge to ghost
21:35:34 <cornihilio> (x : xs) creates a new list, or does it create a new list in a tuple?
21:36:15 <elliott> (x:xs) doesn't really *create* anything; it just is a list.
21:36:33 <fosskers> Hello gents
21:37:09 <Nisstyre> cornihilio: (x:xs) binds the name x to the head of a list and xs to the tail
21:37:41 <pdxleif_> The parens are optional (unless needed for precedence reasons)
21:37:47 <Nisstyre> indeed
21:38:07 <elliott> Nisstyre: That's as a pattern.
21:38:15 <elliott> It sounded like cornihilio was asking about an expression.
21:38:23 <Nisstyre> elliott: I tried to make it apply to consing as well
21:38:28 <fosskers> So I'm attempting to write the first Functor instance declaration i ever have
21:38:42 <fosskers> and I'm getting a weird type error
21:38:44 <pdxleif_> Oh, in a pattern you need the parans afaik.
21:39:07 <elliott> i think x:xs = [1,2,3] is valid at the top-level albeit useless
21:40:07 <hpaste> fosskers pasted “functor def” at http://hpaste.org/76264
21:40:17 <fosskers> yeah, that there
21:40:54 <fosskers> It's giving a type error and I'm not sure why
21:41:14 <elliott>     fmap f (BashArr n v) = BashArr n $ f v
21:41:17 <elliott> what's the type of f and v here?
21:41:32 <fosskers> f is (a -> b)
21:41:33 <Nisstyre> fosskers: what is the type of 'v' ?
21:41:44 <fosskers> and v is a list, i suppose
21:41:49 <elliott> v is [a]
21:41:52 <fosskers> yeah
21:41:54 <elliott> so is (f v) well-typed?
21:42:00 <fosskers> no...?
21:42:07 <elliott> then why do you have f v? :p
21:42:13 <pdxleif_> instance Functor BashVar n, maybe?
21:42:20 <elliott> the instance head is perfectly fine
21:42:43 <Eduard_Munteanu> pdxleif_: that's not well-kinded :)
21:42:55 <elliott> fosskers: -- if you agree that (f v) is ill-typed, then (BashArr n $ f v) is too
21:42:56 <Eduard_Munteanu> Functors need to be * -> *.
21:43:00 <elliott> fosskers: since that's BashArr n (f v)
21:43:14 <elliott> probably you want (BashArr n $ map f v), to map f over every element of the list v?
21:45:29 <pdxleif_> Oh, it's BashVar a - I was confused by the BashVar n v data constructor below :/
21:49:08 <Springwight> If you had to call a tuple of 0 to 4 items by a name (other than tuple) what would it be?
21:49:16 <Springwight> Bunch?
21:49:28 <Springwight> Bushel
21:49:34 <Springwight> Amalgamation
21:50:02 <elliott> TupleOfZeroToFourItems
21:50:32 <Nisstyre> Springwight: quadruple
21:50:41 <Nisstyre> well
21:50:43 <Springwight> But it can have 0 to 4 :P it would be awkward
21:50:44 <Nisstyre> quadruple?
21:50:59 <Springwight> Bunch sounds good. It reminds me of brady bunch.
21:51:07 <Springwight> I'd use group but urm
21:51:09 <Springwight> Band
21:51:12 <Springwight> Troupe
21:51:18 <Springwight> A hoard of tuples
21:51:24 <Nisstyre> it's too bad you can't put question marks at the end of Haskell identifiers
21:51:26 <Nisstyre> ala Scheme
21:51:45 <Springwight> This is quadruple? is it a horse? who knows
22:14:02 <startling> @hoogle Monad m => m a -> m [a]
22:14:03 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
22:14:03 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
22:14:03 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
22:14:14 <startling> there's no repeatM?
22:15:54 <cmccann> :t forever
22:15:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
22:15:59 <mikeplus64> @hoogle many
22:15:59 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
22:15:59 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
22:16:00 <lambdabot> Text.ParserCombinators.ReadP many1 :: ReadP a -> ReadP [a]
22:16:35 <startling> cmccann: how does forever work?
22:16:45 <cmccann> the same way that repeatM would
22:16:57 <mikeplus64> startling: forever x = x >> forever x
22:16:57 <startling> why is the result type different, though?
22:16:57 <cmccann> you give it something, it does it over and over forever
22:17:34 <startling> oh, I want an output list though
22:17:36 <mikeplus64> startling: because it loops infinitely, like let x = x in x
22:17:46 <startling> fmap repeat works, though
22:17:53 <cmccann> well, repeatM would never finish
22:17:56 <mikeplus64> @hoogle repeat
22:17:56 <lambdabot> Prelude repeat :: a -> [a]
22:17:56 <lambdabot> Data.List repeat :: a -> [a]
22:17:56 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Parameters Repeat :: Clamping
22:17:58 <startling> oh, wait, no it doesn't
22:17:58 <cmccann> so you're not going to get a list that way
22:18:03 <startling> yeah
22:18:05 <startling> hmm
22:18:06 <mikeplus64> > repeat 0
22:18:07 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
22:18:17 <cmccann> startling, you need some sort of stopping condition
22:18:17 <mikeplus64> oh, repeat = cycle
22:18:29 <mikeplus64> except for 1 element
22:18:30 <startling> mikeplus64: repeat = cycle . return
22:18:35 <mikeplus64> yeah
22:18:42 <startling> cmccann: yeah, didn't realize that
22:18:48 <cmccann> replicateM being the simple case of "do it this many times"
22:18:49 <startling> hmm, alright. thanks anyway!
22:19:03 <cmccann> some sort of unfoldrM is the general form
22:19:11 <cmccann> but I don't think that's in the standard library :[
22:21:00 <eflister> can anyone help me figure out how to get a binding to link against the static .lib rather than .dll on windows?
22:24:56 <elliott> <cmccann> well, repeatM would never finish
22:25:03 <elliott> in sufficiently lazy monads it would
22:26:10 <cmccann> like what?
22:26:28 <elliott> not sure :)
22:26:28 <mmcdermo> @eflister Does this help? https://groups.google.com/forum/?fromgroups=#!topic/fa.haskell/F-mILOF2U5o
22:26:29 <lambdabot> Unknown command, try @list
22:26:32 <elliott> function monad?
22:27:05 <elliott> IIRC there are monads lazy enough, anyway
22:27:12 <shachaf> Identity?
22:27:19 <shachaf> Null is pretty lazy.
22:28:20 <cmccann> yeah, I suppose reader and identity would be fine
22:28:26 <shachaf> Are there any monads with effects that it would work with?
22:28:32 <shachaf> Oh, Writer, I guess?
22:29:50 <cmccann> writer might work as long as the monoid is lazy enough
22:30:12 <shachaf> Yep, Writer works.
22:30:17 <shachaf> Probably no interesting monad, though.
22:30:49 <shachaf> Where interesting means, uh, that the effects can, um, affect something.
22:30:56 <eflister> mmcdermo: thanks, i'll try.  i've been using 'cabal install' on the mysql package -- is there an easy way to find out what ghc commands it is issuing?
22:32:53 <cmccann> shachaf, well, State won't work if you use the state value after "repeatM"
22:33:01 <cmccann> and any sum type won't work at all
22:33:11 <Puffton> == and /= seem to be implemented depending on one another?
22:33:19 <shachaf> cmccann: Cont will work!
22:33:24 <Puffton> How can that work without causing circular references?
22:33:31 <shachaf> Puffton: It's circular.
22:33:46 <shachaf> Puffton: You have to implement one of them yourself and the other one gets implemented for you.
22:33:46 <Puffton> shachaf, so how come it won't keep on going forever then?
22:33:50 <Puffton> oh ok
22:33:54 <Puffton> then I'm following
22:33:54 <shachaf> You can see that in the documentation just above the class definition.
22:34:42 <mmcdermo> eflister: Generally you'd control that in your cabal file. You can use 'ghc-options:' to set them. GHC usually won't require other haskell libraries dynamically though.
22:35:40 <mmcdermo> eflister: You can always distribute the .dll with your application, which is typical.
22:40:43 <eflister> mmcdermo: i'm just trying to install the mysql package, which for some reason tries to link against mysqlclient.dll, but mysql seems to only install a .lib.  it's cabal file only mentions -Wall as ghc-options.  i'll try adding -static -optl-static there?
22:43:28 <mmcdermo> eflister: That would be the place to do it. I think what may be happening is that it requires mysqlclient.dll from an external source regardless.
22:44:09 <mmcdermo> eflister: You may need to download mysql (not the haskell package) and package mysqlclient.dll with your application.
22:46:19 <mmcdermo> eflister: Unless what you mean is, you installed mysql and it only came with mysqlclient.lib. In which case you'll have to hunt or statically compile.
22:59:50 <startling> I'm not sure what to make of this type signature: http://hackage.haskell.org/packages/archive/nanocurses/1.5.2/doc/html/UI-Nanocurses-Curses.html#v%3AinitCurses
23:00:48 <startling> it doesn't do anything with the argument...
23:03:51 <mmcdermo> startling: IO () -> IO () means it takes an IO action and returns an IO action
23:03:59 <Cale> startling: hmm, it installs a handler with that argument
23:04:26 <mmcdermo> startling: If you look at the source on hackage it just does some other things before, right, installing a handler.
23:05:03 <startling> mmcdermo: oh, that line is part of the monad
23:05:04 <startling> got it
23:05:23 <startling> it's formatted oddly
23:05:47 <mmcdermo> startling: Ahh yeah. Indentation is the final arbiter :D
23:17:17 <startling> is there a MonadState somewhere that records all changes?
23:20:56 <eflister> mmcdermo: yeah i mean mysql (itself, not the bindings) doesn't seem to come with a .dll, only a .lib.  so i'm trying to link against the .lib, but can't figure out how.  i can cabal install the bindings fine, it's only when i try to cabal install something that depends on them that i get the "can't find the dll" error.  i added  -static -optl-static to both cabals, but it didn't help.  there's also the --disable-shared option for cabal install, 
23:20:56 <eflister> didn't help in either place.
23:21:12 <arbn> If I want to use join to define >>=, how would I prevent an infinite loop, since join calls >>= in its definition?
23:21:51 <startling> arbn: I don't think you can in haskell
23:22:18 <startling> arbn: but surely you understand that recursive code can finish?
23:22:26 <startling> @src join
23:22:26 <lambdabot> join x =  x >>= id
23:22:48 <startling> ha, that's clever
23:25:21 <arbn> startling: Yes, I know that recursive code can finish.
23:31:43 <arbn> @src concat
23:31:43 <lambdabot> concat = foldr (++) []
23:36:29 <mmcdermo> eflister: I've heard of a lot of rough bugs when compiling things on Windows with external dependencies. There should be a mysqlclient.dll available somewhere, though - even if you have to compile it.
23:36:57 <Nereid> I wish join was a method in the Monad class.
23:37:23 <Nereid> arbn: you could do something like
23:37:44 <Nereid> a >>= b = let join x = ... in ...
23:38:28 <Nereid> where the second ... is join (fmap b a) or whatever
23:38:45 <startling> is there a difference between hsc and chs files?
23:40:06 <Nereid> @pl \a b -> join (fmap b a)
23:40:07 <lambdabot> (join .) . flip fmap
23:40:23 <Nereid> right
23:41:09 <arbn> Nereid: Ah. Thanks. That's a good idea, for writing this monad the way I want to. :)
23:42:31 <Nereid> I find join is often easier to write than >>=, yeah
23:43:37 <startling> is there a nice workflow for .hsc in emacs, or do you just try to compile repeatedly?
23:43:40 <shachaf> Nereid: For any monad where >>= is tricky to write, join is easier.
23:43:57 <shachaf> For the monads where >>= isn't tricky to write, >>= is easier.
23:44:14 <Cale> Shachaf's Lemma
23:44:17 <Nereid> lol
23:44:32 <shachaf> Cale: More like Shachaf's Dilemma.
23:44:35 <Nereid> shachaf: actually, what's an example of on where >>= is easier?
23:44:38 <startling> Shachaf's Binding
23:44:39 <shachaf> How do I know whether >>= is tricky without trying it?
23:44:47 <Nereid> one*
23:44:54 <startling> Nereid: Maybe is pretty easy
23:45:04 <Nereid> I think join is even easier for Maybe.
23:45:07 <shachaf> Maybe is an example... Though join is also pretty easy for Maybe.
23:45:13 <Nereid> join (Just (Just x)) = x; join _ = Nothing
23:45:44 <shachaf> = Just x
23:45:46 <startling> vs Nothing >>= x = Nothing; (Just x) >>= y = yx
23:45:49 <Nereid> shachaf: oops yes
23:45:53 <shachaf> Nereid: See?
23:45:57 <startling> yeah, they're both pretty easy
23:45:58 <shachaf> I bet you wouldn't've gotten >>= wrong
23:46:08 <Nereid> I bet I wouldn't have gotten join wrong either
23:47:18 <startling> Nereid: you just did!
23:47:34 <Nereid> shut up
23:47:35 <Nereid> :V
23:47:53 <startling> how do the cool kids write their c bindings?
23:48:33 <startling> which is better: hsc2hs or c2hs?
23:50:31 <shachaf> Do you really expect a straight answer to a question like that?
23:50:39 <startling> should I use either of those? so many questions
23:50:54 <startling> shachaf: one might be the old and busted one that's still around for hysterical raisins
23:50:59 <shachaf> And none of them specific enough for anyone to be able to help you!
23:52:26 <startling> I have no idea where to start with this, and there's a bunch of wildly varying guides out there.
23:52:42 <startling> I want to write weird bindings to ncurses.
23:53:04 <shachaf> kmc has some slides on the FFI
23:53:21 <shachaf> @google keegan ffi
23:53:22 <lambdabot> http://ugcs.net/~keegan/talks/high-level-ffi/talk.pdf
23:53:23 <lambdabot> Title: High-level FFI in Haskell
23:57:51 <mietek> startling: doing it manually works well and is a good learning experience
