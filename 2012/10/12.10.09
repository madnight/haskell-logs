00:00:19 <ClaudiusMaximus> zzo38: some combination of zip, partition, fmap (for (,)), mergeSortedBy (which is in some hackage probably), unzip
00:02:19 <zzo38> ClaudiusMaximus: I meant if there is some known function of such things, but thanks anyways
00:02:22 <ski>   (a -> Bool) -> (forall f. Functor f => f a -> f a) -> ([a] -> [a])  -- hm
00:02:49 <ski> possibly s/Functor/Applicative/
00:03:00 <maukd> :t \f g -> map (\x -> if f x then g x else x)
00:03:01 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> [a] -> [a]
00:03:24 <zzo38> ski: To do similar to what I have done, Applicative is not enough; you also need Alternative and Foldable, I think.
00:04:06 <ski> (the idea was to statically ensure the same length is returned)
00:05:08 <maukd> :t scanl
00:05:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
00:05:17 <maukd> :t mapAccumL
00:05:19 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
00:05:19 <Jafet> Statically ensuring that each output depends only on one input is too strict.
00:05:30 <ski> yes
00:05:34 <zzo38> ski: Yes, well, then that works too, but with the program I have, it is require to have the entire list available to the function, as well as some other stuff too, actually
00:06:38 <zzo38> But there is a way to ensure that the length remains the same by the type, I think:  [z] -> (z -> x) -> z -> x  may work?
00:08:39 <maukd> :t \f g xs -> let ys = g (filter f xs); rs = mapAccumL (\ys x -> if f x then (tail ys, head ys) else (ys, x)) ys xs in rs
00:08:39 <zzo38> CodensityAsk Initialize = Finalize; CodensityAsk Finalize = Identity; CodensityAsk Identity = Maybe; CodensityAsk (Const x) = (->) x; CodensityAsk ((->) x) = Either x; CodensityAsk Predicate = the infinite search monad; ...
00:08:41 <lambdabot> forall a. (a -> Bool) -> ([a] -> [a]) -> [a] -> ([a], [a])
00:08:59 <maukd> :t \f g xs -> let ys = g (filter f xs); (_, rs) = mapAccumL (\ys x -> if f x then (tail ys, head ys) else (ys, x)) ys xs in rs
00:09:00 <lambdabot> forall a. (a -> Bool) -> ([a] -> [a]) -> [a] -> [a]
00:09:40 <zzo38> O no, with the type I gave might not be good enough, maybe you need Eq
00:09:43 <lpvb> has anyone used a haskell -> javascript compiler to any effect?
00:11:09 <Jafet> @google ghcjs
00:11:10 <lambdabot> https://github.com/ghcjs/ghcjs
00:12:25 <zzo38> maukd: OK, at least the type is correct. Now let's see. Perhaps it would be useful to have it by a functor, too?   forall a f. Functor f => (a -> Bool) -> ([a] -> f [a]) -> [a] -> f [a]    since I realized with the program I have, it is necessary having some extra state as well.
00:12:54 <zzo38> AntiSpamMeta: Go away
00:12:57 <rwbarton> looks like Traversal from lens
00:13:23 <zzo38> OK
00:13:40 <maukd> zzo38: why are you talking to bots?
00:13:55 <zzo38> maukd: For no reason.
00:15:09 <zzo38> An unrelated question is if you like CodensityAsk, or even if you don't already know it, if you know it from the description I gave is it enough for you to understand?
00:16:38 <zzo38> And I think the (Either x) should also be MonadPlus if x is Monoid, isn't it? (With my CodensityAsk based, it ends up being a MonadPlus for free if x is Monoid, because ((->) x) is Comonad if x is Monoid.)
00:19:10 <sp3ctum> lpvb, there is the project fay, which compiles a subset of haskell to javascript. i've followed it to some extent and it looks promising: http://fay-lang.org/
00:21:29 <zzo38> But can you compile Haskell into MMIX, or compile Haskell into Verilog, or into Glulx, etc? Although some people have want, I have never wanted to compile Haskell codes into Javascript.
00:21:50 <lpvb> sp3ctum: what about haste and ghcjs?
00:22:28 <zzo38> Or possibly even RogueVM can be another target?
00:23:04 <sp3ctum> lpvb, sorry. i have no idea
00:23:05 <zzo38> Will Haskell compile to ARMv2?
00:23:19 <lpvb> but my quesiton was not so much what compilers there are so much as are there any projects/websites which have used it to do cool things
00:23:43 <sp3ctum> i only know the examples in the fay page
00:26:08 <ski>   data EndoVector a = forall p. EV (Foo a () p p)
00:26:34 <adnam> lpvb: are you looking for fay examples?
00:26:50 <shachaf> luite's ghcjs thing seems nice.
00:26:57 <ski> hm, actually
00:27:03 <ski>   data EndoVector a = forall p. EV (Foo a p () p)
00:27:35 <ski>   data Foo a p :: * -> * -> *
00:27:38 <ski>     where
00:27:47 <ski>     Done :: i -> Foo a p p i
00:27:50 <lpvb> what I'm looking for is if a haskell -> javascript compiler is production capable
00:27:55 <ski>     More :: Foo a p (a,o) (a -> i) -> Foo a p o i
00:29:12 <ski> zzo38 : `EndoVector a' is basically `a -> a -> ... -> a -> (a,(a,..(a,())..))', with the same number of `a's input as output
00:29:48 <zzo38> ski: O, OK, I suppose that is one way, then.
00:30:20 <luite> lpvb: none of them really is, but ghcjs is the most unfinished one
00:30:34 <ski> zzo38 : i don't know `CodensityAsk'
00:31:11 <zzo38> ski: Can you understand it from the examples I gave, possibly guess/figure out what it is? (If not, I can tell you, but see if it can be figure out)
00:31:41 <ski> zzo38 : oh, didn't notice the examples 'til now
00:33:53 <ski> zzo38 : i don't know what `Initialize',`Finalize',`Predicate',"the infinite search monad" (Martín Escardó's thing ?) is
00:36:27 <adnam> lpvb: yeah i agree with luite. I think fay works well, but it's not "1.0" so perhaps it's not as stable as you'd want. But you can definitely be productive in it, eg http://ide.fay-lang.org/
00:37:55 <ski> it bothers me that `x' seems to occurs covariantly on the left, but contravariantly on the right, in `CodensityAsk (Const x) = (->) x'
00:38:03 <zzo38> Initialize is the endofunctor mapping all objects to the initial object (and it is a comonad). Finalize is the endofunctor mapping all objects to the final object (and it is a monad). Predicate x is (x -> Bool) it is a contravariant functor. The infinite search monad is Martin Escardo's thing, yes.
00:38:57 <zzo38> ski: Yes, it does sometimes; let's see if you know why (if you don't know, I can tell you, though).
00:40:12 <zzo38> (See if you are able to figure out from the examples given)
00:42:43 <donri> luite: how is ghcjs the most unfinished?  sorta looks like the most complete, not that i've actually looked
00:44:50 <zzo38> ski: Are my answers to your questions OK so far?
00:45:37 <ski> yes
00:46:14 <ski> first i was suspecting that `CodensityAsk' was meant as a left inverse `Codensity'
00:46:24 <luite> donri: depends on how you see it, the current version does have the most features, but it's also the slowest and most unpolished installation procedure, and no 'getting started' examples
00:46:41 <donri> ah sure
00:47:08 <luite> and the new generator is not yet useful in any way, even though it will blow the socks off haste and fay ;)
00:47:27 <donri> \o/
00:47:48 <zzo38> I wonder if any mathematicians use the Initialize and Finalize functors and if so, if they have other names for them?
00:48:00 <ski> zzo38 : hm, so i suspect `CodensityAsk' is really contravariant itself, in some way
00:48:24 <shachaf> What's CodensityAsk?
00:49:02 <ski> some concoction of zzo38's, see above
00:49:05 <zzo38> shachaf: See if you can understand from the examples I gave; if not, I can tell you.
00:49:13 <shachaf> What's the example?
00:49:40 <ski> <zzo38> CodensityAsk Initialize = Finalize; CodensityAsk Finalize = Identity; CodensityAsk Identity = Maybe; CodensityAsk (Const x) = (->) x; CodensityAsk ((->) x) = Either x; CodensityAsk Predicate = the infinite search monad; ...
00:49:42 <zzo38> ski: Well in some way it is contravariant, but it is not a contravariant functor (since it is always a monad)
00:50:09 <ski> zzo38 : are you saying that `CodensityAsk f' is always a monad ?
00:50:59 <shachaf> What are Initialize and Finalize?
00:51:12 <ski> shachaf : `Const Void' and `Const ()', iiuc
00:51:52 <zzo38> ski: Yes, it is always a monad. In addition, if f is Comonad, then `CodensityAsk f' is MonadPlus.
00:52:20 <ski> zzo38 : ok, well, i was suspecting that `CodensityAsk' (*not* `CodensityAsk f') was contravariant ..
00:52:25 <zzo38> ski: Yes, those would be equivalent to the Initialize and Finalize I have defined, I believe.
00:53:03 <zzo38> ski: It is, in a way, kind of...
00:54:17 <zzo38> (I defined Initialize and Finalize in terms of categories having initial/final objects, rather than in terms of Haskell, although it works in Haskell too, and are equivalent to what ski said)
00:54:28 <ski> zzo38 : btw, earlier we tried to define `Compose :: (k -> l) -> (* -> k) -> (* -> l)' -- if you want, you could have a try at that
00:55:34 <zzo38> ski: OK, I will try, maybe not right now but even when I am in bed maybe, what is this "Compose" supposed to be though, a type with the specified kind?
00:55:36 <ski> (hm, another idea is that the above might be some kind of adjunction chain)
00:56:01 <ski> `Compose f g a' should be iso to `f (g a)'
00:56:16 <ski> note that the `l' there shouldn't have to be `*'
00:56:58 <zzo38> ski: I don't have the version of Haskell to do that but I can think about it and work it on paper!
00:57:14 <zzo38> (Note that Const gives you neither Comonad nor Monad instances; I have defined Initialize and Finalize datatypes which do have these instances.)
00:58:05 <zzo38> I can show you the definition of CodensityAsk if you want it, if you are really unable to figure it out from the examples.
00:58:55 <ski> zzo38 : you could also try to define a `NatTransf :: k -> k -> *', polymorphic in `k' (working for `k' of shape `*' and `k0 -> k1', recursively), for natural transformations
00:58:58 <zzo38> But do you know that ((->) x) is a comonad when x is a monoid?
00:59:11 <shachaf> Just like ((,) x) is a monad when x is a monoid.
00:59:14 <zzo38> ski: OK
00:59:34 <ski> zzo38 : i need to leave presently -- perhaps we could continue talking some later time
00:59:39 <zzo38> shachaf: Yes, although they didn't define the instance for that, but they should.
00:59:41 <zzo38> ski: OK.
00:59:56 <zzo38> Maybe another day later this week (I don't know when, unfortunately)
01:00:26 <shachaf> Tomorrow is later this week, as are Thu, Fri, and Sat.
01:00:35 <bartavelle> I am trying to understand what to do with this : http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
01:00:40 <lightquake> @pl \(a, b) (c, d) -> (a + c, b + d)
01:00:40 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
01:00:46 <bartavelle> The Hugues list type seems to be that of map
01:00:47 <lightquake> :I
01:00:54 <bartavelle> I have no clue what it is supposed to model
01:01:04 <bartavelle> and google doesn't seem too helpful here (thanks imdb)
01:01:06 <shachaf> bartavelle: You should probably know how those lists work before doing the problem set.
01:01:12 <bartavelle> exactly
01:01:14 <Ralith> lightquake: haha
01:01:19 <fmap> keyword is difference lists
01:01:22 <shachaf> The common name for these is "difference lists".
01:01:26 <bartavelle> ah thanks
01:01:26 <Ralith> hm
01:01:39 <shachaf> The idea is that instead of using xs and ys and zs, you use (xs++) and (ys++) and (zs++)
01:01:45 <shachaf> And instead of using (++), you use (.).
01:02:00 <Ralith> has anyone ever made an effort to find an input that maximizes the ratio between input and output of @pl?
01:02:00 <zzo38> shachaf: Do you understand CodensityAsk by now? Do you know if any mathematics uses Initialize and Finalize for anything in any category (or in general)?
01:02:21 <shachaf> It can make some algorithms asymptotically better (and others worse).
01:02:36 <shachaf> Ralith: Yes, that's come up in here before at least once.
01:02:55 <bartavelle> shachaf, yes this makes sense now
01:02:56 <lightquake> i keep getting namespace collisions with my lenses :I
01:02:58 <bartavelle> thanks
01:03:09 <Ralith> shachaf: what were the results?
01:03:09 <zzo38> What are "difference lists", exactly?
01:03:37 <shachaf> zzo38: Using (xs++) instead of xs and (.) instead of id.
01:03:55 <Nereid> you mean id instead of []
01:03:57 <Nereid> er
01:04:01 <Nereid> a bunch of things.
01:04:04 <shachaf> I mean (.) instead of (++).
01:04:08 <shachaf> And ($ []) instead of id
01:04:18 <shachaf> But "instead of id" is a bit silly to say. :-)
01:04:24 * hackagebot syntactic 1.2 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.2 (EmilAxelsson)
01:04:38 <zzo38> O, so that is what it is.
01:05:44 <shachaf> > foldr f z [a,b,c,d]
01:05:45 <lambdabot>   f a (f b (f c (f d z)))
01:05:49 <shachaf> > foldl f z [a,b,c,d]
01:05:50 <lambdabot>   f (f (f (f z a) b) c) d
01:05:57 <shachaf> > ($ z) $ foldr (.) id [f a,f b,f c,f d]
01:05:59 <lambdabot>   f a (f b (f c (f d z)))
01:06:01 <shachaf> > ($ z) $ foldl (.) id [f a,f b,f c,f d]
01:06:03 <lambdabot>   f a (f b (f c (f d z)))
01:06:06 <shachaf> That's the goal of it.
01:07:31 <shachaf> You can do this with any Monoid (in fact, that's what Endo in Data.Monoid does, given fromMonoid :: Monoid m => m -> Endo m; fromMonoid x = Endo (x <>); toMonoid :: Monoid m => Endo m -> m; toMonoid (Endo f) = f mempty).
01:14:19 <zzo38> OK
01:19:25 * hackagebot stringbuilder 0.3.0 - A monadic builder for multi-line string literals  http://hackage.haskell.org/package/stringbuilder-0.3.0 (SimonHengel)
01:27:55 <bartavelle> follow up to my previous question, if anybody has in mind the "codensity transformation" exercise from ezyang, what is that supposed to model ? newtype CTree a = CTree { unCTree :: forall r. (a -> Tree r) -> Tree r }
01:28:47 <bartavelle> I see how this is related to the previous part with Hughes lists, but do not have the intuition to understand the meaning
01:30:17 <bartavelle> I have no clue at all about why the type is (a -> Tree r) for the first argument, and not (r -> Tree r) for example
01:31:49 <merijn> mornin'
01:31:50 <lambdabot> merijn: You have 2 new messages. '/msg lambdabot @messages' to read them.
01:40:51 <merijn> mm_freak: I was under the impression that testWireM would run the "m a" action for every instant and the original (netwire 3) would take one argument (number of instants in between prints). I get that there is now an extra 2 arguments (threadDelay between instants and a session), but I'm not sure what they do. Additionally testWireM seems to only execute the "m a" input once.
01:44:14 <srhb> Is there a combination of etherpad and codepad somewhere that allows collaborative Haskell editing + type checking (at least) ?
01:45:42 <merijn> srhb: ghclive which shapr's been working on?
01:46:23 <srhb> Oh yeah, I'd forgotten about that.
01:47:22 <srhb> I feel like, in 2012 we ought to be able to quickly import and export whole files from within our respective editors to a collaborative environment. :-)
01:49:57 <merijn> srhb: github? :p
01:50:36 <srhb> Interactive collaborative environments* :-)
01:51:29 <srhb> Like.. "What is going on here" (key-combo to share interactive editing session on some site) -> work together with someone to fix it, including whatever type checking / compilation you need -> re-import to own editor
01:51:38 <srhb> Would be nice.
01:52:11 <srhb> I guess ideally you'd like your editor to hook up to this shared session somehow. Hmm.
01:54:22 <merijn> Maybe once we finally get IPv6 and everyone will have globally accessible IPs for their workstations...
01:54:28 <srhb> Heh, yeah.
01:54:46 <srhb> Maybe rainbows and unicorns.
01:55:56 <merijn> Any intermediate solutions will require a central host to deal with NAT :\
01:56:05 <Jafet> That sounds totally like it won't have security issues
01:56:05 <merijn> Or you need to do NAT piercing, which is annoying as hell
01:56:44 <srhb> I think something where you could either use a shared, secure service or set up your own server would be nice.
01:56:54 <srhb> Of course there will be security issues.
01:57:09 <merijn> Time to pimp FreeBSD jails as a solution once again :p
01:57:16 <srhb> Oh god. :P
01:57:49 <merijn> They're getting nicer by the year, I think the virtualized networking has now been integrated into the production release too :)
02:00:56 <merijn> @tell mm_freak Ignore my earlier comment about testWireM not working right/be confusing. I'm an idiot of unbelievably epic proportions.
02:00:57 <lambdabot> Consider it noted.
02:00:59 <mikeplus64> is there a way to do something like runhaskell -c 'main = do { ... }' ?
02:01:23 <merijn> mikeplus64: Are you trying to use haskell as a shell scripting language?
02:01:28 <mikeplus64> a bit
02:01:34 <mikeplus64> :)
02:01:48 <Jeanne-Kamikaze> haskell makes an awesome scripting language
02:01:48 <merijn> mikeplus64: Sounds like you want to check out shelly
02:01:54 <merijn> http://hackage.haskell.org/package/shelly-0.14.1
02:02:05 <mikeplus64> merijn: i know of shelly, i just want a runhaskell -c like thing
02:02:12 <merijn> ah, ok :)
02:02:13 <mikeplus64> like awk
02:02:20 <mikeplus64> or perl i guess
02:02:30 <merijn> mikeplus64: You can do it ghetto style
02:02:34 <mikeplus64> yeah :(
02:02:47 <merijn> echo "my program" | runhaskell /dev/stdin
02:02:59 <merijn> Some fancy aliasing around it and you're done
02:03:04 <Jeanne-Kamikaze> very interesting package there
02:03:15 <merijn> Obviously only works if your haskell code doesn't use stdin :p
02:03:28 <maukd> mikeplus64: ghc -e '
02:03:34 <mikeplus64> maukd: excellent
02:04:02 <mikeplus64> ~> ghc -e
02:04:04 <mikeplus64> ghc: on the commandline: unrecognised flag: -e
02:04:21 <mikeplus64> ~> ghc -e 'main = putStrLn "yes"'
02:04:25 <mikeplus64> <interactive>:1:6: parse error on input `='
02:04:40 <mikeplus64> oh, i see
02:04:42 <mikeplus64> just expressions
02:05:35 <troydm> any idea why i can't compile ghc 7.4.2
02:05:37 <troydm> http://pastebin.com/kWCNr4we
02:05:39 <troydm> ?
02:05:43 <maukd> The paste kWCNr4we has been copied to http://hpaste.org/76027
02:05:54 <troydm> ic that there is problem with the linker
02:06:09 <troydm> but where should i look for linker options in makefiles?
02:08:15 <maukd> I'd try running the command manually, with -v
02:09:27 <troydm> maukd: hmm ic that some unneccessary linker option is added
02:19:19 <t7>     Warning: -XDatatypeContexts is deprecated: It was widely considered a misfea
02:19:21 <t7> ture, and has been removed from the Haskell language. :O
02:21:03 <t7> oh i guess i just put class constraints in the functions instead
02:21:37 <nor> what program do you recommend to burn ISOs to DVDs?
02:21:46 <t7> windows explorer
02:21:53 <nor> ?
02:21:55 <maukd> s/instead/in addition/
02:22:05 <maukd> nor: k3b
02:22:36 <zomg> Linux
02:23:46 <fmap> t7: -XDatatypeContexts doesn't save you from writing class constraints in the functions
02:30:16 <jasmine25> hi
02:39:30 * hackagebot monad-codec 0.2.0 - Monadic conversion between complex data structures and unique integers  http://hackage.haskell.org/package/monad-codec-0.2.0 (JakubWaszczuk)
02:39:32 * hackagebot syntactic 1.2.1 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.2.1 (EmilAxelsson)
02:48:21 <t7> writing poker in a functional style is a brain fuck :(
02:49:05 <HugoDaniel> writing poker in fuck style has functional style
02:52:39 <t7> cmon brain!
02:53:20 <HugoDaniel> :D
02:54:24 <maukd> I prefer peeker
02:54:49 <t7> maybe i should write imperative first
02:56:44 <Bluelz> Does the "read :: String --> Int" work for negative numbers?
02:56:56 <danr> > read "-1"
02:56:57 <lambdabot>   *Exception: Prelude.read: no parse
02:57:09 <danr> > read "-1" :: Int
02:57:10 <lambdabot>   -1
02:57:13 <danr> yes heh
02:58:24 <liyang> > read "()"
02:58:25 <lambdabot>   ()
02:58:29 <liyang> Thought so.
02:58:49 <Bluelz> <
03:06:40 <d-snp> hi I'm a bit confused by the first example here http://www.haskell.org/haskellwiki/Dynamic_programming_example
03:06:58 <d-snp> it says it's dynamic programming, but I can't see how it is
03:07:14 <t7> is there something like interface structs in C++ ? i need ADTs :(
03:07:41 <HugoDaniel> "interface structs" ?
03:08:01 <t7> like a struct i cant instantiate, but i can derive from
03:08:13 <HugoDaniel> type classes won't do ?
03:08:22 <d-snp> oh wait.. because its lazy, the elements of the array exist?
03:08:42 <companion_cube> t7: abstract classes?
03:08:49 <maukd> t7: yeah, make a class with a virtual destructor
03:09:01 <companion_cube> with at least one purely virtual member function
03:09:18 <companion_cube> virtual void f() = 0; or something like this
03:09:36 <maukd> virtual ~Foo() = 0;
03:09:38 <HugoDaniel> d-snp: they exist, but they haven't been evaluated yet
03:09:51 <d-snp> right
03:09:55 <d-snp> that's brilliant I guess
03:10:19 <maukd> I don't think laziness is even necessary here
03:10:40 <maukd> you have mutual recursion between f and the array initializer
03:11:00 <maukd> the array caches results; the function uses the array to get the solutions for smaller subproblems
03:11:26 <d-snp> for some reason it feels a bit magical to me that you can access the previous elements the map returned from within the mapping function
03:11:28 <maukd> the only difference is that in a lazy language the array isn't computed up front but on demand
03:12:01 <maukd> > fix (1 :)
03:12:02 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
03:12:11 <maukd> > fix ((1 :) . map (* 3))
03:12:13 <lambdabot>   [1,3,9,27,81,243,729,2187,6561,19683,59049,177147,531441,1594323,4782969,14...
03:12:36 <d-snp> :P
03:12:55 <maukd> the crucial bit there is (True : ...)
03:13:03 <d-snp> yeah it needs a base case
03:13:08 <maukd> so the first element is always known and doesn't depend on other things
03:14:36 <d-snp> so this array will be of thunks right, are thunks big?
03:15:51 <t7> i cant believe i am having so much trouble writing poker betting now, i wrote this before when i was like 13. Im such a perfectionist now :(
03:18:12 <d-snp> well if the poker isn't perfect, all bets are off
03:18:16 <d-snp> .. ;)
03:18:55 <t7> Pot
03:18:55 <cornihil`> can I do this in haskell (specifically the repeated use of a as the  var name for the remainder bytestring?): https://gist.github.com/3857805
03:21:00 <adnam> cornihil`: not in the same scope
03:24:33 * hackagebot blaze-html-truncate 0.1.0.3 - A truncator for blaze-html  http://hackage.haskell.org/package/blaze-html-truncate-0.1.0.3 (MarcelRuegenberg)
03:26:25 <cornihil`> so if I want to read a lot of different portions of a bytestring within a single monad, I'm stuck with using a myriad of random var names?
03:28:42 <Cale> cornihil`: You can repeatedly use the same name, but each one you bind will shadow the others
03:29:00 <Cale> cornihil`: It's like (\x -> (\x -> ...))
03:30:30 <adnam> cornihil`: there are also abstractions to prevent this things, such as MonadState
03:31:00 <Cale> Or, based on what you're doing, using one of the binary serialisation libraries like binary or cereal might be a good idea.
03:32:06 <Cale> You could write  do alpha <- getBytes 12; beta <- getBytes 12; return (PacketRaw alpha beta)
03:33:41 <quicksilver> you could not bother to name things you only use ones
03:33:52 <quicksilver> PacketRaw <$> getBytes 12 <*> getBytes 12
03:34:20 <Cale> Well, *I* could ;)
03:34:37 <Cale> That's a little trickier to apply to his code, though still possible
03:35:18 <Cale> actually, why is this in a do?
03:36:40 <Cale> BL.split is probably Data.ByteString.Lazy.split, in which case, it's not an action to run.
03:38:25 <t7> @hoogle Num n => [n] -> n
03:38:25 <lambdabot> Prelude product :: Num a => [a] -> a
03:38:25 <lambdabot> Data.List product :: Num a => [a] -> a
03:38:26 <lambdabot> Prelude sum :: Num a => [a] -> a
03:38:55 <troydm> i have this problem when i try to compile ghc 7.4.2 on latest OpenIndiana
03:39:02 <troydm> http://pastie.org/5023488
03:39:06 <troydm> any ideas?
03:42:25 <Cale> troydm: Is your ld the GNU ld?
03:42:59 <troydm> Cale: yes sss
03:44:07 <troydm> Cale: i've just set it to system ld and i'm trying to compile it again
03:44:23 <troydm> let's see if it works
03:44:34 <Cale> Well, I guess that would be something to try
03:44:47 <Cale> I think ldscript is a gnu-specific thing? I dunno.
03:46:05 <Cale> Oh, also, you already have a working GHC, and you're trying to build a newer one? Or are you trying to bootstrap?
03:47:12 <troydm> Cale: i have ghc 7.2.2 installed from SFE
03:47:40 <troydm> so i'm trying to build a newer one
03:53:43 <b__> @where trees
03:53:43 <lambdabot> I know nothing about trees.
03:53:46 <b__> @where tree
03:53:46 <lambdabot> I know nothing about tree.
03:54:35 <Cale> b__: what are you looking for?
03:55:23 <b__> articles/tuts on how to access/update/generate different kinds of trees
03:56:31 <Cale> Well, hmm... Haskell's built in support for recursive algebraic types could be looked at as "different kinds of trees"
03:57:18 <Cale> e.g. you can define   data Tree a = Tip | Branch a (Tree a) (Tree a) deriving (Eq, Ord, Show)   and that gives you a binary tree datastructure
03:57:31 <Cale> (with labelled internal nodes)
03:58:20 <Cale> The one in Data.Tree is more along the lines of   data Tree a = Branch a [Tree a]  -- all nodes labelled, arbitrary lists of child nodes
03:58:38 <Cale> You'd just pattern match on tree types like this
03:58:43 <b__> how could I generate such a tree starting from the root? for example applying (* 2) all the time
03:58:54 <b__> will be a very boring tree, but just as an example
03:59:15 <Cale> one sec, let me check if I have one of these available in the bot already
03:59:18 <Cale> :t Branch
03:59:19 <lambdabot> forall a. a -> Bin a -> Bin a -> Bin a
03:59:25 <Cale> :t Tip
03:59:27 <lambdabot> forall a. Bin a
03:59:30 <Cale> okay, good
04:00:15 <Cale> > let mkTree n = Branch n (mkTree (2*n)) (mkTree (2*n + 1)) in mkTree 1
04:00:18 <lambdabot>   Branch 1 (Branch 2 (Branch 4 (Branch 8 (Branch 16 (Branch 32 (Branch 64 (Br...
04:00:46 <Cale> heh, you only get to see the left branches like that, but the right ones are available too :)
04:01:29 <b__> ahaaa, yeah I get it
04:01:38 <b__> thanks
04:02:38 <b__> what's a good way to access the Tree?
04:02:55 <b__> for example I want to find the first Tip with value (> 100)
04:04:18 <Cale> In something like:
04:04:27 <Cale> data Tree a = Tip a | Branch (Tree a) (Tree a) ?
04:04:40 <Cale> (the tips don't have values in the tree type that I gave before)
04:05:03 <Cale> Or do you want a binary search tree?
04:05:28 <b__> yeah in that example
04:05:34 <Cale> (You should be aware that there are good Set and Map datastructures available as well, which are internally trees, but you wouldn't have to care)
04:06:59 <Cale> Well, okay, we can define various traversals to turn trees back into lists
04:07:14 <Cale> for iterating through them
04:07:18 <b__> My type would be something like: data Chain a = Branch1 a (Chain a) | Branch2 a (Chain a) (Chain a)
04:07:29 <Cale> okay
04:07:37 <Cale> So every tree will be infinite in that case?
04:07:48 <b__> yes in theory it would be
04:07:59 <Cale> all right
04:08:16 <Cale> So we probably want something like a breadth first search
04:08:32 <b__> but might be more practical to do data Chain a = Branch0 a | Branch1 a (Chain a) | Branch2 a (Chain a) (Chain a)?
04:08:45 <Cale> Maybe, maybe not :)
04:09:03 <Cale> It's perfectly okay to work with infinite datastructures.
04:10:23 <Cale> So, the trick to this will be to produce a list of lists of the elements on each level of the tree
04:10:50 <Cale> This way, we can merge the lists of elements at the same level
04:11:23 <Nereid> @pl \f x y -> compare (f x) (f y)
04:11:23 <lambdabot> flip =<< (((.) . compare) .)
04:11:25 <Nereid> ew
04:11:30 <b__> I think I understand
04:12:13 <Cale> levels (Branch1 x t) = [x] : levels t
04:12:29 <Nereid> @type comparing
04:12:30 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
04:12:37 <Nereid> oh duh
04:12:44 <Cale> levels (Branch2 x l r) = [x] : zipWith (++) (levels l) (levels r)
04:13:34 <Cale> This (++) is not ideal, and we might want to replace it with something better, but let's just make this work first.
04:13:49 <b__> sure
04:14:17 <b__> we're talking about the version with infinite a?
04:14:21 <Springwight> What would you call a queue that has log* levels. I have ExpQueue or StarQueue. Or maybe LogQueue.
04:14:28 <Cale> yes
04:14:55 <Cale> Springwight: I'm not sure.
04:15:56 <b__> I must admit that I have no idea how to work with this kind of infinite structure
04:16:55 <b__> My initial data type included Branch0 so that I could have some finite examples to work with
04:18:03 <Cale> yeah, that might actually be helpful, because it's much easier to display finite trees
04:18:58 <Cale> however
04:19:02 <b__> And with your earlier example I am probably able to generate such a tree
04:19:10 <Cale> this levels function will let us display a finite portion of the tree
04:19:20 <Cale> (albeit with some of the structure destroyed)
04:19:53 <Cale> makeChain n | even n    = Branch1 n (makeChain (n `div` 2))
04:19:54 <Cale>             | otherwise = Branch2 n (makeChain (3*n+1)) (makeChain (3*n+2))
04:19:58 <absence> why does "rec a <- delay 0 -< a + 1" (arrow syntax) crash with the message "<<loop>>"?
04:20:04 <Cale> for playing around with this, I made that function
04:20:09 <Cale> ghci> take 5 (levels (makeChain 42))
04:20:09 <Cale> [[42],[21],[64,65],[32,196,197],[16,98,592,593]]
04:20:22 <b__> well, that happens to be the precise thing I am using it for
04:20:29 <Cale> :D
04:20:31 <b__> so that certainly helps ^^
04:21:23 <Cale> absence: Probably because while computing a, it determined that it had to evaluate a
04:22:00 <Cale> absence: (i.e. while computing a and before determining the outermost data constructor)
04:22:07 <Springwight> B__ what are you trying to do?
04:22:09 <Springwight> With trees
04:22:16 <Springwight> I've been working a lot with trees lately...
04:22:36 <Cale> Springwight: apparently, explore the Collatz conjecture
04:22:41 <absence> Cale: i thought delay was supposed to make sure thatdidn't happen?
04:22:41 <b__> yes
04:23:03 <Cale> absence: well, apparently it didn't? I don't know what the definition of your delay is :)
04:23:16 <b__> I am using the Collatz conjecture to learn about trees, and vice-versa.
04:23:31 <Springwight> hmm isn't it undecidable
04:23:40 <Cale> Springwight: no, just undecided
04:24:08 <b__> sure, I have no ambition to seriously research it, but I'm just trying to deepen my knowledge
04:24:23 <Cale> okay, so let's add on a Branch0
04:24:38 <Cale> levels (Branch0 x) = [x]
04:24:51 <Cale> makeChain 1 = Branch0 1
04:24:52 <b__> yeah I got that one right :D
04:25:49 <Cale> oh, derp
04:25:56 <Cale> levels (Branch0 x) = [[x]]
04:26:01 <b__> oh, I didn't
04:26:04 <Cale> or [x] : []
04:26:22 <absence> Cale: "my" delay is part of the arrow stuff i think. trying to find out where it's defined :)
04:26:34 <Cale> ah, actually, that's pretty broken...
04:26:38 <Cale> we really need
04:26:51 <Cale> levels (Branch0 x) = [x] : repeat []
04:27:11 <Springwight> did I mention I'm impressed with my queue :) it is the most exponential structure I've ever seen.
04:27:12 <Cale> because otherwise we end up stopping at the first leaf
04:27:48 <b__> do we?
04:28:00 <Nereid> are there any ready-to-use multimap libraries?
04:28:07 <Nereid> by a multimap I mean something like Map k (Set a)
04:28:11 <Cale> yeah, try something like levels (makeChain 42)
04:28:17 <sinisa> I'm trying to use mutable vectors inside the ST monad. Why does (runST $ V.replicate 10 0) result in an error? What am I doing wrong? Thanks.
04:28:45 <Cale> sinisa: What's the type of V.replicate?
04:28:47 <Cale> oh!
04:28:53 <Cale> runST $ doesn't work
04:28:58 <Cale> :t runST
04:28:59 <lambdabot> forall a. (forall s. ST s a) -> a
04:29:29 <Cale> The fact that the parameter must be polymorphic means that if you lambda-bind it at some point, it messes things up.
04:29:40 <Cale> :t ($)
04:29:42 <lambdabot> forall a b. (a -> b) -> a -> b
04:29:47 <b__> Cale 1 sec if you have it, I'll put the code in a file and load it into ghci
04:29:53 <Cale> GHC will never instantiate a and b here to polymorphic types on its own
04:30:21 <Cale> and it needs to instantiate a to (forall s. ST s t) for some t in order for that to work
04:30:24 <hpc> i thought there was a special case for ($) built in
04:30:46 <Cale> hpc: for a while, there was, but it was an ugly hack that I'm pretty sure they later removed
04:30:47 <absence> Cale: ah right, it's defined by the library i use that has an ArrowCircuit instance. is it a library issue then? i.e. is the code "supposed" to work?
04:30:57 <Cale> absence: I don't know.
04:31:18 <Cale> absence: Maybe it's supposed to work
04:31:45 <Cale> absence: what does delay 0 actually mean?
04:32:02 <Cale> oh, an initial value?
04:32:26 <sinisa> Should (runST (V.replicate 10 0)) then be able to work? It doesn't in my case. The type of V.replicate is (Control.Monad.Primitive.PrimMonad m, V.Unbox a) => Int -> a -> m (V.MVector (Control.Monad.Primitive.PrimState m) a)
04:32:42 <absence> Cale: yes
04:33:03 <Cale> sinisa: okay, and what are the instances of PrimMonad? Is there one for ST s?
04:33:04 <absence> Cale: so it would first return 0, then 1, then 2 ...
04:33:10 <Cale> absence: right
04:33:32 <Cale> absence: Well, there are definitely ArrowLoop instances which can do that.
04:34:08 <Cale> oh!
04:34:13 <sinisa> Cale: Yes, there seems to be a Monad (ST s) => PrimMonad (ST s) instance.
04:34:14 <Cale> sinisa: Right, of course that won't work
04:34:35 * hackagebot vector-binary 0.1.0 - Binary instances for vector types  http://hackage.haskell.org/package/vector-binary-0.1.0 (JakubWaszczuk)
04:34:39 <Cale> sinisa: you can't return the MVector (ST s) a from the computation
04:34:45 <Cale> because it has an s in its type
04:34:53 <sinisa> Cale: Ahh, so I need to convert it into something else?
04:34:56 <Cale> yeah
04:35:18 <Cale> you need to actually do all the computation you were going to do with your mutable vectors inside ST
04:35:20 <sinisa> Cale: Great, I get it now. This is the whole point of the ST monad I guess. :D
04:35:24 <Cale> yeah
04:35:36 <sinisa> Thanks!
04:37:44 <rfw> @pl [1, 2, 3, 4, 5] >>= (\x -> return $ x + 1) >>= (\x -> return $ x + 2)
04:37:44 <lambdabot> [4, 5, 6, 7, 8]
04:37:48 <rfw> aw how boring
04:39:19 <Jafet> @pl \xs -> xs >>= return . (+1) >>= return . (+2)
04:39:19 <lambdabot> fmap (3 +)
04:39:29 <Jafet> Nice
04:40:24 <Nereid> heh
04:40:42 <Nereid> @pl \xs -> [x + 1 + 2 | x <- xs
04:40:42 <lambdabot> (line 1, column 8):
04:40:42 <lambdabot> unexpected "["
04:40:42 <lambdabot> expecting lambda abstraction or expression
04:40:44 <Nereid> @pl \xs -> [x + 1 + 2 | x <- xs]
04:40:44 <lambdabot> return . ((x + 1) +) . ((2 | x) <-)
04:40:46 <b__> Cale, I am generating the collate chains in reverse
04:40:49 <Nereid> oh haha.
04:41:01 <b__> f n | mod (n-1) 3 == 0 = Branch2 n (f $ 2*n) (f $ div (n-1) 3)
04:41:05 <b__> | otherwise        = Branch1 n (f $ 2*n)
04:41:42 <Jafet> @@ @pl @undo [ x + 1 + 2 | x <- xs ]
04:41:42 <lambdabot>  (3 +) `fmap` xs
04:41:43 <b__> but will this not only generate a limited subset of the chains?
04:42:34 <Cale> hmm
04:43:29 <Cale> Well, if you start from 1 it will generate everything that eventually ends up at 1 under Collatz iteration
04:44:35 * hackagebot crf-chain1 0.2.0 - First-order, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-0.2.0 (JakubWaszczuk)
04:44:52 <b__> okay
04:47:08 <Cale> You may find that sending n to (n+2) `div` 3 works better though, in that it'll avoid 0.
04:47:44 <b__> yeah now I did:
04:47:46 <b__> f :: Integer -> Chain Integer
04:47:46 <b__> f n | m == 0 && d /= 1 = Branch2 n (f $ 2*n) (f d)
04:47:46 <b__>     | otherwise        = Branch1 n (f $ 2*n)
04:47:46 <b__>     where (d,m) = divMod (n-1) 3
04:49:31 <b__> because it can only reach 0 when (div (1-1) 3) right?
04:50:02 <troydm> Cale: now i get
04:50:04 <troydm> make[1]: *** [libraries/base/dist-install/doc/html/base/base.haddock] Segmentation Fault (core dumped)
04:50:19 <Cale> troydm: well, that's fun
04:50:31 <troydm> two hours of compiling in order to get that error
04:50:34 <Cale> troydm: maybe turn off documentation generation?
04:50:38 <troydm> that's just more than a fun
04:50:50 <troydm> Cale: how do i do that?
04:50:54 <Cale> uhhh...
04:51:01 <Cale> I don't actually know off-hand
04:51:10 <Nereid> ok I just cobbled together a couple function for working nicely with Map k (Set a)
04:51:17 <Nereid> good enough for now
04:51:36 <Cale> HADDOCK_DOCS = NO
04:51:36 <troydm> Cale: i don't see any options for that on ./configure
04:51:40 <Cale> in mk/build.mk
04:51:40 <b__> mapM_ print $ take 10 $ levels $ f 2 -- gives good results :}
04:52:07 <Cale> b__: you should get used to composing functions with (.) rather than chaining ($) :)
04:52:10 <b__> now I can do takeWhile on levels
04:52:20 <Jafet> I thought a multimap is Map k [a]
04:52:23 <troydm> Cale: i think i'm not using mk files at all
04:52:24 <Cale> mapM_ print . take 10 . levels $ f 2
04:52:34 <Jafet> Map k (Set a) is like Map (k, a) a?
04:52:35 <troydm> coz most of them are .mk.sample
04:52:50 <Jafet> Or Set (k, a)
04:52:57 <b__> ok so the last $ stays, rest becomes composition?
04:52:59 <Cale> troydm: do you have a mk/build.mk?
04:53:04 <Cale> b__: yeah
04:53:15 <troydm> Cale: no only mk/build.mk.sample
04:53:18 <Cale> b__: you could even push the $ one further out
04:53:31 <Cale> mapM_ print . take 10 . levels . f $ 2
04:53:43 <b__> okay
04:53:46 <Cale> (it's more characters, but composition is a nice operation)
04:54:09 <Cale> the nice thing here is that, e.g.  take 10 . levels  is a function on its own
04:54:19 <Cale> while  take 10 $ levels  is meaningless
04:54:20 <b__> yeah
04:54:30 <Jafet> mapM_ print . take 10 . levels . f . 2 $
04:54:33 <Nereid> I wish $ associated the other way
04:54:49 <b__> so is it for ease of development, or mostly a conceptual habit?
04:54:51 <Nereid> so I could write f $ big long thing $ other long thing to mean f (big long thing) (other long thing)
04:55:03 <Cale> troydm: maybe try just creating that file then, and putting the one line in it
04:55:31 <troydm> Cale: ok, i'll do that now
04:56:09 <Jafet> It's not common to have two big long things next to each other.
04:56:31 <Cale> It's not that uncommon either
04:56:33 <Jafet> I suppose some people enjoy that sort of thing
04:57:01 <Cale> There are cases where you end up using layout to make sense of the function parameters
04:57:46 <Cale> (where being able to line up some $'s would be nice)
04:59:00 <Jafet> €?
04:59:19 <Cale> No, just replace $
04:59:20 <Cale> :)
05:00:11 <Jafet> Why does ghci still not parse fixity descriptions.
05:00:33 <quicksilver> I don't quite understand the allergy to parentheses in that case
05:00:45 <quicksilver> what's so bad about f \n (big long thing) \n (other big long thing )
05:00:53 <quicksilver> with appropriate whitespace
05:01:24 <Jafet> Well, parentheses shouldn't span multiple lines
05:01:56 <quicksilver> why on earth not?
05:02:18 <Jafet> It's often bad for reading
05:02:42 <Cale> quicksilver: If you have the option, it's nice to limit the distance between an opening paren and closing paren, because humans are not ideal at maintaining stacks in their head.
05:02:57 <Jafet> 💲, heavy duty apply operator
05:03:10 <quicksilver> Cale: I don't see the different
05:03:26 <quicksilver> Cale: you either have to track between "$" and "$" or between "(" and ")("
05:03:32 <Jafet> It might be nice to use layout for grouping as well.
05:03:38 <quicksilver> that's exactly the same amount of work for the human mind.
05:04:05 <Cale> quicksilver: you have to be able to see which ) goes with which (
05:04:08 <merijn> Nereid: Import Control.Lens, it defines (%) as flip ($) :p
05:04:19 <Cale> merijn: that's not what we want
05:04:19 <Nereid> I don't want flip ($)
05:04:25 <merijn> oh, wait
05:04:30 <Nereid> I want an infixl version
05:04:42 <merijn> yeah, I wasn't paying enough attention ;p
05:04:50 <quicksilver> Cale: you have to be able to see which $ goes with which $.
05:04:59 <Nereid> I guess there's `id`
05:05:17 <Nereid> > (+) `id` 1 `id` 2
05:05:18 <lambdabot>   3
05:05:19 <Cale> hah
05:05:37 <Jafet> infixl 0 `id`
05:05:44 <FireFly> what is the fixity of backtick-infix functions?
05:05:56 <Cale> FireFly: whatever you define it to be
05:05:56 <FireFly> err, precedence I mean
05:06:11 <Jafet> The default fixity is infixl 9
05:06:13 <FireFly> oh
05:06:14 <Jafet> Or infix 9
05:06:29 <FireFly> I see
05:06:46 <Cale> If no fixity declaration is given for `op` then it defaults to highest precedence and left associativity
05:07:21 <quicksilver> which is not special to backtick-infix
05:07:27 <quicksilver> it's also true of normal operators, no?
05:07:30 <Cale> yes
05:07:49 <Jafet> Backticking creates normal operators
05:08:08 <Cale> quicksilver: I don't usually think of $ as an enclosing operation
05:08:26 <Cale> quicksilver: i.e. each $ doesn't pair up with another $ which I have to locate
05:08:46 <Cale> while for parens, this is the case
05:09:03 <Jafet> Existing $-chains aren't that hard to read. If you reverse the associativity, you just have to read them in reverse.
05:09:31 <Cale> If I see ( then I have to find its (matching) ) to know where the expression ends.
05:10:06 <quicksilver> Cale: you really do have to see which is the corresponding $
05:10:12 <Cale> Now, sure, another $ will stop the previous expression
05:10:26 <quicksilver> which means you have to jump over any inner () or [] which might be masking other $
05:10:38 <quicksilver> maybe you claim that's less likely to happen
05:10:41 <quicksilver> maybe that's an argument
05:10:45 <Cale> yeah
05:10:48 <quicksilver> but it's not *different* mental load in principle
05:10:49 <Jafet> That's what layout is for.
05:10:56 <quicksilver> but if you think layout solves it, Jafet
05:11:05 <quicksilver> then just use multine () with layout as a clue
05:11:30 <quicksilver> I mean, I assume you're referring to aesthetic layout, not some putative enhanced layout rule.
05:11:33 <Cale> I also for some inexplicable reason find it awkward that the )'s don't line up
05:11:51 <Cale> in general
05:11:52 <Cale> Even if you do lay things out nicely
05:11:58 <Jafet> The real problem is when you don't just have subexpressions, but enclosed blocks
05:12:10 <Jafet> catch (do ... ... ... )
05:12:29 <Jafet> I won't care to understand why it looks bad, but it does.
05:12:54 <quicksilver> not to me.
05:13:21 <b__rb>  <Cale> You may find that sending n to (n+2) `div` 3 works better though, in that it'll avoid 0.
05:13:28 <quicksilver> If you think that (do ... ... ) looks awkward then I have to wonder if perhaps you don't *really* believe that 'do' is an expression former.
05:13:35 <b__rb> instead of (n*2)?
05:13:50 <quicksilver> I think it's important - and powerful - to honestly believe that do is just another expression former.
05:13:52 <Abraxas> i don't understand the expansion on k in the top answer to this question: http://stackoverflow.com/questions/6172004/writing-foldl-using-foldr
05:14:10 <Saizan> i feel a bit claustrophobic with complex expressions in parentheses
05:14:13 <Jafet> This is probably going back to what Cale said--that the matching parens are on different lines and probably indented differently
05:14:31 <Cale> b__rb: yeah, maybe that was the wrong suggestion after all, but in place of (n-1)`div`3
05:14:42 <Jafet> It's interesting that you don't have any problem reading that.
05:15:38 <Cale> Ideally, your opening paren would span multiple lines and enclose the entire block
05:15:50 <Abraxas> this: <=  g' (f v x) = k x g' v   <=>   k = \x g' -> (\a -> g' (f v x))
05:15:51 <Jafet> Keep in mind that most of this reading is a subconscious process. So it's probably not just about whether you believe do statements are expressions or not
05:15:57 <Cale> (and your closing paren would as well, being in the right margin)
05:16:07 <Cale> (this
05:16:09 <Cale>  looks
05:16:12 <Cale>  ugly)
05:16:46 <Cale> Splitting lines in the middle of a paren is generally bad, but there's not much you can do about it.
05:17:18 <AfC> I just discovered the filemanip package
05:17:39 * AfC basks in the glow of using code written by smarter people than him
05:18:14 <Jafet> Well, the big subexpressions can usually be named separately. But that's also annoying unless haskell becomes more permissive about where you can stick a where block
05:19:42 <b__> is it worth writing things like (chain $ 2 * n) in a composed style?
05:20:44 <Saizan> Abraxas: i think the [10/09/12 12:15] #agda augur t7: thats _definitely_ fine
05:21:03 <augur> O_O
05:21:14 <Saizan> Abraxas: sorry, i think they got it wrong, the last 'v' should be 'a'
05:21:19 <t7> wut
05:21:31 <Saizan> t7: mispaste
05:21:42 <frerich> b__: I would just wrote "chain 2*n" actually.
05:21:52 <quicksilver> Jafet: I hate naming big subexpressons as a solution to that problem.
05:22:06 <Philonous> frerich:  But that's (chain 2) * n
05:22:09 <quicksilver> Name things if you use them more than once or if they are separately useful or can be tested separately.
05:22:22 <quicksilver> but don't name them *just* because they're big. (Is my opinion, and I know people disagree)
05:22:33 <b__> frerich: | No instance for (Num (Chain Integer))
05:22:52 <Jafet> It's definitely not the solution. Sometimes there are no useful names
05:23:22 <quicksilver> Cale: (\n  this\n  looks\n  fine\n)
05:23:39 <quicksilver> Cale: (that is, matching one of the common ways to layout out {} in C-likes)
05:23:42 <frerich> b__, Philonous: Sorry, of course Philonous is right. You just suffered from my weekly attempt to say something useful in #haskell (I hope that at one point the moment will come)
05:24:21 <b__> it's useful because it made me wonder _why_ it didn't work ^^
05:24:24 <Jafet> However, it trades off vertical space.
05:24:51 <Philonous> b__:  prefix application always binds stronger than infix application
05:25:13 <frerich> b__: what's sad is that I "tested" my answer first in ghci by having "let chain = id" and "let n = 3" and then I ran "chain $ 2*n" vs. "chain 2*n" :-]
05:25:57 <Jafet> (Paul Graham says vertical space is important; it must be true.)
05:26:33 <t7> does infixl mean the left branch is bigger or the right?
05:26:59 <Jafet> It means start grouping from the left.
05:27:18 <Philonous> t7:  infixl means a `op` b `op` c === (a `op` b) `op` c
05:27:20 <t7> 1 + 1 + 1 + 1 = (((1 + 1) + 1) + 1)
05:27:25 <Abraxas> saizan: but what does it change? the a in that lambda is not part of the RHS?
05:27:41 <t7> right?
05:27:49 <quicksilver> Jafet: I do, actually, agree that vertical space is important.
05:28:13 <t7> ah yes thanks
05:29:11 <Abraxas> or did i not get this right...for a lambda expression you take the next value from the left and replace the variable(s) on the RHS of the lambda with the value
05:31:54 <t7> why is exponentiation an infixr?
05:32:14 <osa1> what does being "first-order" for an expression mean ? I'm reading TaPL and it's written that unification algorithm can be used to solve equality constraints of any kind of "first-order" expressions
05:32:41 <ClaudiusMaximus> t7: more useful, because (a ** b) ** c = a ** (b * c)
05:33:02 <hpc> osa1: see also, "higher order functions"
05:33:04 <Jafet> Because we like to make big numbers easily
05:33:51 <osa1> hpc: so expressions that depends on other expressions to be reduced/evaluated ?
05:33:54 <ClaudiusMaximus> @check \a b c -> any (<= 0) [a,b,c] || (a ^ b) ^ c == a ^ (b * c :: Integer)
05:33:56 <lambdabot>   "OK, passed 500 tests."
05:34:40 <Abraxas> this just doesn't make sense: (\a -> g' (f v x))
05:35:02 <Abraxas> unless you simply ignore the value
05:35:07 <hpc> b
05:35:19 <hpc> (ignore that, phone slipped)
05:35:59 <Jafet> First order means that variables always refer to "ordinary" things in sentences.
05:36:24 <Jafet> Higher order means that variables can refer to sentences.
05:37:30 <osa1> Jafet: ok, what are "ordinary" things in expressions ? values ?
05:37:46 <Saizan> Abraxas: if you want to define a function k such that ..v.. = k v; you can do that by defining k = \x -> ..x..; because when k is applied to v it'll return the expression ..x.. but with x replaced by v
05:38:09 <Jafet> In the context of functions, ordinary normally means things that are not functions.
05:38:42 <troydm> Cale: ok now i'm in real despair
05:38:50 <troydm> 4 hours of compiling ghc
05:38:55 <troydm> and no result at all :(
05:39:16 <troydm> wait stop i think i've just finished it!
05:39:39 <hiptobecubic> Why are you compiling ghc
05:39:39 <hpc> hmm, enforcing linearity in Cont can be tricky
05:39:43 <troydm> but previously it aborted with no defined symbols error
05:39:53 <troydm> hiptobecubic: i'm on OpenIndiana
05:40:03 <troydm> hiptobecubic: so i don't have much choice do i?
05:40:24 <Jafet> hpc: no shit
05:41:17 <hpc> i only have to keep one thing linear at a time though, and i dont need callCC
05:41:30 <hiptobecubic> troydm, well that leads to the next obvious question
05:41:37 <hpc> but that would be a neat general problem to try and solve
05:42:39 <hiptobecubic> troydm, why stick with solaris after oracle?
05:43:00 <troydm> hiptobecubic: openindiana isn't oracle
05:43:11 <troydm> it's open source
05:43:22 <Abraxas> Saizan: yes, but the "a" must be wrong, cause it doesn't show up on the RHS...right?
05:44:06 <hiptobecubic> troydm, i said solaris
05:45:39 <Saizan> Abraxas: which one is the RHS for you?
05:45:46 <troydm> hiptobecubic: hmm well generally i'm for zfs
05:45:52 <yaxu> Hi all, I'm looking for a way of dynamically working out whether a value can be applied to a function, something like compatible :: (a -> b) -> c -> Bool
05:45:56 <Abraxas> hold on...it *does* just drop the value
05:46:32 <Abraxas> \x g' -> (\a -> g' (f v x)) x g' a = (\a -> g' (f v x)) a = g' (f v x)
05:46:53 <troydm> now i've installed ghc 7.4.2
05:46:58 <troydm> what should i do next?
05:47:02 <troydm> install haskell platform?
05:47:21 <Saizan> Abraxas: i'm pretty sure the correct solution is k = \x g' -> (\a -> g' (f a x))
05:47:27 <Abraxas> if the v is replaced, as you suggested
05:47:39 <twmb> I asked this yesterday but I forgot, sorry:  How do you read the type definition of a function?  "length :: (Num b, Integral a) => [a] -> b" means "length is defined such that, for a Num b and Integral a, it will take a list [a] and return a b"?
05:47:48 <Abraxas> no no...it doesn't have to be replaced...sorry
05:48:27 <Abraxas> your solution would work, if the last v is replaced by a
05:48:43 <Abraxas> but it doesn't have to, i think?
05:49:12 <Saizan> if you take my k and apply it like (k x g' v) you get g' (f v x)
05:49:25 <yaxu> Data.Typeable.funResultTy seems to do what I want..
05:49:31 <Abraxas> any value is simply dropped, because the a doesn't show up on the RHS of the lambda expression
05:49:55 <Saizan> right, with the answer's k that's what happens, and it's wrong
05:50:25 <Saizan> it satisfies the equation there but it's not going to work for foldl
05:51:03 <Saizan> my k satisfies the equation too but is also what you want for foldl
05:52:52 <twmb> anybody?
05:52:59 <Abraxas> originally the a was v...in your definition of k the a is going to be v, again...no difference there, but you say, that's coincidence in this case?
05:54:41 * hackagebot language-dot 0.0.8 - A library for the analysis and creation of Graphviz DOT files  http://hackage.haskell.org/package/language-dot-0.0.8 (BrianLewis)
05:54:43 <Saizan> well, i haven't followed the derivation there, maybe they forgot to include some constraint, it's just that when you look at the resulting foldl it doesn't propagate the accumulator 'a' properly to the folding of the rest of the list
05:54:47 <srhb> Is there a good tip on recognizing good vs. bad consumers out there somewhere?
05:55:01 <Saizan> it drops it on the floor and keeps using the initial accumulator 'v'
05:55:03 <srhb> My understanding is that when people say "good consumers" they mean "this will not leak, despite laziness"
05:55:14 <srhb> Despite is probably the wrong word. :-)
05:55:42 <Saizan> i thought good/bad consumers/producers were about fusion
05:55:55 <t7> tommmo
05:56:11 <srhb> Hm, I guess I've misunderstood the problem then.
05:57:37 <srhb> I guess the real question is then: How do I recognize leaks from laziness before I make them?
05:57:50 <t7> i just forgot localhost address
05:57:56 <t7> i think im losing my mind
05:58:30 <yaxu> > funResultTy (typeOf (+ 1)) (typeOf 1)
05:58:32 <lambdabot>   Just Integer
05:58:54 <yaxu> > funResultTy (typeOf (length)) (typeOf "hello world")
05:58:55 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:58:56 <lambdabot>    `Data.Typeable.Typeable a...
05:59:00 <yaxu> :(
05:59:05 <Abraxas> btw, this is equivalent, right?   k = \x g' a -> g' (f a x)
05:59:18 <Saizan> Abraxas: yeah
06:00:01 <Abraxas> not sure how the way it's written on SO is supposed to help the explanation
06:00:18 <fmap> > funResultTy (typeOf (length :: String -> Int)) (typeOf "hello world")
06:00:20 <lambdabot>   Just Int
06:00:40 <Saizan> Abraxas: maybe because it show how k is a function from 2 arguments that results in a function
06:01:33 <Abraxas> the way i understand it i just construct a definition of k that uses all the known components and re-arranges them
06:01:39 <Abraxas> that might be it
06:02:25 <Abraxas> yeah, that was the emphasis going into the explanation
06:03:39 <Saizan> srhb: the first thing is to consider the types, if you have a simple one like Int or a spine-strict one like Map laziness doesn't help and should often be squashed (memoization is a interesting exception though)
06:03:45 <Abraxas> oh, and it corresponds to hutton's example
06:03:49 <fmap> yaxu: TypeReps don't have any wrapped type information in their type so inferer can't deduce the type of `length'
06:04:15 <Abraxas> and ofc he writes exactly what you have written, saizan...lol
06:04:39 <Saizan> srhb: a case where this often matters is accumulators, if they don't get inspected during the processing they won't get evaluated
06:04:42 * hackagebot stm-conduit 0.4.3 - Introduces conduits to channels, and promotes using  conduits concurrently.  http://hackage.haskell.org/package/stm-conduit-0.4.3 (ClarkGaebel)
06:04:58 <Abraxas> the excerpt from hutton that the explanation starts with, there is your k
06:05:51 <troydm> what is a cabal-install?
06:05:56 <troydm> should i install it
06:05:58 <Saizan> heh, Hutton is a good guy
06:06:00 <troydm> or haskell platform?
06:06:00 <Abraxas> or rather, the v replaced by a just as you suggested
06:06:24 <Saizan> troydm: the haskell platform includes cabal-install
06:06:43 <Abraxas> so that's where that came from, should have checked, but i didn't understand hutton's explanation, at all :D
06:06:46 <Saizan> troydm: cabal-install is a program that helps installing packages, especially from hackage
06:07:39 <srhb> Saizan: Hmm, I'm not sure if I really understand what memoization is, but that probably does not matter for me yet, I guess.
06:08:58 <Saizan> srhb: sometimes a divide-and-conquer algorithm will end up solvind the same subproblem multiple times, so to save computation costs one builds a table where the intermediate results are stored
06:09:04 <yaxu> fmap: hm, righto ta
06:10:58 <Saizan> srhb: with laziness that becomes pretty elegant because you just define an immutable table containing all the intermediates and you'll just compute those actually needed
06:11:09 <absence> mm_freak: got the synth thing working with netwire 4 by making a wire that maps stepWire on a list of "voice wires" it takes as input. fun, but VERY slow - my cpu manages three simultaneous sine waves :) btw, is rec a <- delay 0 -< a supposed to work? it crashes with "<<loop>>"
06:12:52 <Saizan> srhb: the table can be for example an array with lazy values
06:13:15 <troydm> Saizan: does cabal-install install cabal itself?
06:14:03 <Saizan> troydm: the executable from the package cabal-install is called 'cabal'
06:14:13 <troydm> Saizan: ic
06:14:16 <troydm> so i have a choice
06:14:22 <troydm> to just install cabal-install
06:14:30 <troydm> or install whole haskell platform instead
06:14:40 <Saizan> yeah
06:16:54 <troydm> Saizan: i have strange problem install haskell platform specificly OpenGL module
06:17:10 <troydm> since i'm doing install on headless server
06:17:17 <troydm> i don't need that library
06:17:31 <troydm> is there a way to install haskell platform without it?
06:17:41 <Saizan> i don't know
06:23:47 <troydm> i think i have a major ghc problem
06:23:52 <troydm> it compiled incorrectly
06:24:00 <troydm> coz it segfaults randomly all the time
06:25:01 <ski> bartavelle : codensity does two things, (a) `Codensity f' is a monad, regardless of what `f' is; (b) in case `f' is a monad, then it is iso to `Codensity f', but the latter can be more efficient
06:25:47 <Botje> troydm: sure it's not your memory?
06:26:09 <troydm> Botje: 4GB of ram free
06:26:25 <Botje> no, i mean hardware issues
06:26:46 <troydm> Botje: absolutely sure
06:26:47 <Cale> Botje: He's compiling on a weird operating system
06:26:54 <Botje> oh, brr
06:27:14 <troydm> ok i'm bracing for a compile attempt #2
06:27:22 <troydm> i hope it'll compile normaly now
06:28:21 <fmap> ski: I was told that they are not isomorphic since `(to ∷ Monad m ⇒ m a → C m a) ∘ (from ∷ Monad m ⇒ C m a → m a)' is not `id' :[
06:31:02 <Saizan> given F -| G then GF ~ Codensity G, (still modulo performance)
06:32:20 <fmap> scary symbols
06:37:34 <elliott> troydm: what OS are you using
06:37:50 <troydm> elliott: OpenIndiana 151a6
06:38:17 <elliott> pfft, I was hoping for something weirder after Cale said that :p
06:38:52 <quuuux> that just reminds me about how sad I am about what happened to Solaris :(
06:39:26 <Cale> elliott: I'd never heard of it before, nor the kernel that it's based on
06:39:37 <elliott> Cale: you've never heard of Solaris? really?
06:39:57 <Cale> elliott: It's apparently based on something called "illumos"?
06:40:09 <merijn> Cale: Illumos is the fork of OpenSolaris
06:40:12 <Cale> okay
06:40:19 <elliott> callen: it's just the continuation of OpenSolaris
06:40:22 <bartavelle> ski, I finally read the paper and finished the exercise. I can't say I intuitively understand this (or the point of this) though
06:40:22 <merijn> After Oracle practically killed it
06:40:36 <bartavelle> I suppose it is like most things, it need work
06:40:51 <hiptobecubic> I can't say I've met anyone not on IRC that ever used or cared about Solaris :/
06:40:53 <bartavelle> except I'm not sure why I would want to use this :)
06:41:25 <Cale> bartavelle: What are you talking about?
06:41:48 <Cale> oh, Codensity?
06:41:48 <bartavelle> codensity exercise http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
06:42:15 <typoclass> hiptobecubic: doesn't that also hold for linux ...? :-)
06:42:21 <bartavelle> I believe I understand the mathematical appeal, but I can't figure out the practical use (except it says you optimize some monadic thingies with it)
06:42:37 <hiptobecubic> typoclass, no actually.
06:43:10 <bartavelle> I'd say solaris users are usually sysadmins in "old" shops, such as banks or administrations
06:43:19 <bartavelle> a bit like mainframe guys
06:43:29 <hiptobecubic> although, almost everyone I've met there has been in the last few (two or three) years.
06:43:54 <hiptobecubic> I think they're using redhat here
06:44:08 <bartavelle> it is a shame as it has so many cool stuff (I just would LOVE having dtrace on linux)
06:44:21 <hiptobecubic> zfs ?
06:44:26 <bartavelle> and ZFS obviously, but dtrace is just crazy cool
06:44:28 <bartavelle> to me
06:44:35 <hiptobecubic> what is dtrace?
06:44:52 <bartavelle> script language + kernel infrastructure to monitor just about anything
06:45:02 <bartavelle> it is incredibly powerful and useful
06:45:25 <bartavelle> I used it to reverse engineer some parts of oracle authentication, whereas it was designed for performance troubleshooting
06:46:10 <hiptobecubic> I guess that doesn't affect me much
06:46:15 <hiptobecubic> directly, anyway
06:46:17 <merijn> bartavelle: Fortunately DTrace has been ported to both FreeBSD and OSX \o/
06:46:19 <frerich> bartavelle: Is dtrace the OS/X equivalent of strace? I remember that I once looked for strace on the Mac, found dtrace but couldn't wrap my brain around it.
06:46:29 <bartavelle> no dtrace is not like strace
06:46:33 <bartavelle> it can do what strace does
06:46:38 <ski> fmap : i stand corrected. i see a counter-example with `amb_ma = \amb -> amb () >>= \b -> modify (1 +) >> return b',`amb () = get', then since `from = ($ return)',`to = (>>=)', so `(to . from) amb_ma amb  =  to (from amb_mb) amb  =  amb_ma return >>= amb  =  return () >>= \b -> modify (1 +) >> return b >>= amb  =  modify (1 +) >> get' which is different from `get >>= \b -> modify (1 +) >> return b  =  amb () >>= \b -> modify (1 +) >> return b 
06:46:40 <merijn> frerich: DTrace is *much* more flexible and powerful than strace
06:46:40 <bartavelle> also I have heard the osx port is castrated
06:46:48 <bartavelle> anyway, not the topic of this channel
06:47:43 <ski> bartavelle : see correction above. `Codensity f' isn't iso to `f', `f' is merely included in `Codensity f'
06:48:09 <bartavelle> ski, I guess this is a bit too advanced for my feeble mind (yet)
06:48:14 <bartavelle> anyway, why do you use it for in practice ?
06:48:23 <bartavelle> erm, s/why/what/
06:48:49 <ski> bartavelle : you know why `(((as0 ++ as1) ++ as2) ++ as3) ++ as4' is bad, yes ?
06:48:56 <bartavelle> yes
06:49:31 <ski> a similar problem can occur with `(((ma >>= amb) >>= bmc) >>= cmd) >>= dme''
06:49:35 <bartavelle> actually I don't even know why the list type doesn't have hardcoded a pointer to the end so that it was fast
06:49:57 <Cale> bartavelle: lists are immutable
06:50:05 <bartavelle> ah
06:50:06 <Cale> bartavelle: you have a pointer to the end of every list, it's just []
06:50:11 <quicksilver> :)
06:50:13 <Cale> that doesn't help you
06:50:18 <bartavelle> ok that explains a lot ;)
06:50:28 <ski> the standard cure for the append case is to (essentially) say `((((as0 ++) . (as1 ++)) . (as2 ++)) . (as3 ++)) . (as4 ++)' instead
06:50:36 <quicksilver> you could design a list type which magically cached a reference to the last element of course
06:50:42 <quicksilver> but people don't do that
06:50:50 <quicksilver> it's not worth paying the extra cost in general
06:51:03 <quicksilver> it might be for some specific algorithm - in which case, just do it :)
06:51:10 <bartavelle> ski, but when you actually need the result, it doesn't change the cost right ?
06:51:23 <ski> when finally applied to `as', this will turn out as `as0 ++ (as1 ++ (as2 ++ (as3 ++ (as3 ++ as))))'
06:51:31 <bartavelle> ah !!!
06:51:49 <ski> `Codensity m' achieves something similar for the `(>>=)' case, effectively right-associating the `>>=' calls
06:52:15 <bartavelle> I understand why this is a problem for ++ but not for >>=
06:52:26 <Sculptor> o/
06:52:31 <bartavelle> `(((ma >>= amb) >>= bmc) >>= cmd) >>= dmc` is usually what I want to happen, right ?
06:52:53 <ski> bartavelle : consider `data Tree b l = Leaf l | Branch b (Tree b l) (Tree b l)'
06:53:02 <bartavelle> yes that is the example they use
06:53:06 <bartavelle> then a zig/zag function
06:53:23 <ski> bartavelle : `Tree b' is a monad -- consider how `(>>=)' is implemented, and how left-associated calls to it will execute naively
06:53:36 <bartavelle> I understand this in this specific example (except I do not really understand why this works)
06:53:48 <ski> bartavelle : another example is `Either e'
06:54:06 <bartavelle> like with the error monad ?
06:54:37 <bartavelle> I usually want this evaluated like you wrote it then
06:54:46 <ski> bartavelle : in case you get an intermediate result `Left err', then *every* intermediate `(>>=)' will check the result "oh, it's an error, i'll pass it one step up, then"
06:54:54 <bartavelle> ah yes
06:55:26 <ski> but if you right-associate (when you can) and only left-associate (when you must, i.e. when you want to catch an error), you'll only inspect for errors at the "handler" site
06:55:32 <bartavelle> isn't that related to CPS ?
06:55:36 <ski> yes
06:55:55 <bartavelle> this is about automagically turning your monad into a continuation monad ?
06:56:02 <ski> `instance Monad (Codensity f)' is basically CPS, it can be written without knowing anything about `f'
06:56:18 <ski> it is turning the (internal) code into CPS
06:56:25 <bartavelle> ah
06:56:32 <bartavelle> this explains a lot, I will re read it again
06:56:35 <bartavelle> thanks for the insights
06:56:43 <ski> however, when you actually want to handle an exception, you can't write it as quite CPS
06:56:57 <ski> (this is called "nqCPS" for "not-quite CPS" :)
06:57:00 <otters> @. pl undo do { a <- b; c <- f a; return c + 1 }
06:57:01 <lambdabot> (1 +) . return =<< f =<< b
06:57:03 <bartavelle> ;)
06:57:06 <otters> crap
06:57:27 <Cale> @. pl undo do { a <- b; c <- f a; return (c + 1) }
06:57:28 <lambdabot> (1 +) `fmap` (f =<< b)
06:58:01 * quuuux wonders if (Num m, Monad m) has any instances
06:58:09 <Cale> It can
06:58:18 <byorgey> no it can't
06:58:21 <Cale> Num (m a), Monad m
06:58:24 <byorgey> kind mismatch
06:58:27 <Cale> hehe, yes
06:58:29 <quuuux> oh yeah, that's what I meant
06:58:58 <byorgey> > (return 3) + (return 5) $ "x"
06:58:59 <lambdabot>   8
06:59:00 <quuuux> (Num r => a -> r)
06:59:11 <byorgey> indeed
06:59:55 <bartavelle> ski, another question, while all of this has obvious complexity benefits, doesn't it really results in faster code ? because conceptually the scaffolding seems much more complex
07:03:32 <quicksilver> bartavelle: you rely on the compiler inlining and compiling away the scaffolding
07:03:36 <quicksilver> I believe it does so.
07:04:04 <bartavelle> ok
07:04:04 <ski> bartavelle :  instance MonadError e m => MonadError e (Codensity m) where throwError :: r -> Codensity m a; throwError e = MkC (\amb -> throwError e); catchError :: Codensity m a -> (e -> Codensity m a) -> Codensity m a; catchError (MkC amb_mb) e_cma = MkC (\amb -> catchError (amb_ma return) (\e -> e_cma e `unC` return) >>= amb)
07:05:06 <ski> bartavelle : note how this (a) requires the use of `return' and `(>>=)' for `m'; (b) the continuation `amb' is unused in `throwError', and `amb_ma' is not called in tail-position in `catchError' -- hence nqCPS
07:06:11 <bartavelle> as I don't know CPS (except what it means), I can't really say much on this subject. I suppose I will have to read this too !
07:06:15 <ski> bartavelle : also, this can improve the asymptotics of the program, so for large enough inputs it'd often be a gain anyway
07:06:34 <ski> (cf. the left-associated `(++)' case)
07:06:39 <bartavelle> yes
07:08:09 <ski> (btw, i think `MonadError e m' ought to contain a `bindCatchError :: m a -> (a -> m b) -> (e -> m b) -> m b' operation)
07:08:43 <mm_freak> merijn: the session value comes from something like clockSession or counterSession
07:08:43 <lambdabot> mm_freak: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:09:26 <mm_freak> absence: no, that's not supposed to work, and i wonder why you did it that way
07:09:42 <mm_freak> wave1 + wave2  -- gives you the sum of two waves
07:09:45 * hackagebot monad-ox 0.2.0 - Monad for observation extraction  http://hackage.haskell.org/package/monad-ox-0.2.0 (JakubWaszczuk)
07:09:49 <mm_freak> it's as simple as that
07:10:03 <ski> bartavelle : if we have a computation of type `(a -> o) -> o', then this may or may not be in CPS -- in case `o' is fully abstract, it must be CPS
07:10:47 <ski> so, e.g. when `O' is an abstract datatype, with no exposed operations, `(a -> O) -> O' must be fully in CPS
07:10:55 <merijn> mm_freak: Yeah, I noticed. My confusion came from the fact that I couldn't get "more" output out of my wire while testing. But as I mentioned I was stupidly copying the "print once very 1000 instants" argument xD
07:11:15 <mm_freak> =)
07:11:24 <ski> alternatively, when we have `forall o. (a -> o) -> o', because such a computation is parametric in `o', it can't look at `o'-values since it doesn't know what type `o' will turn out to be in the end
07:11:33 <merijn> mm_freak: Running with a 1 instant print it worked exactly as expected :p
07:11:53 <ski> but if we have `forall o. (a -> f o) -> f o', then `f o' is only partially abstract (`o' is abstract, but `f' may be known)
07:12:16 <ski> which is why we can write nqCPS code of this type
07:12:16 <bartavelle> I'm too newb to follow this. I don't even understand the point of writing forall in type signatures.
07:12:36 <ski> bartavelle : `forall' means "polymorphism"
07:12:47 <merijn> mm_freak: I take it the extra session input is just to know how time based wires like dtime should behave? during every instant?
07:12:47 <bartavelle> what's the difference when you omit it ?
07:13:18 <ski> bartavelle : `length :: forall a. [a] -> Int' means `length' is polymorphic in `a' : for every possibly concrete type `A', a possible type of `length' is `[A] -> Int'
07:13:41 <ceii> bartavelle, when you use a type variable without a forall, you can imagine GHC automatically inserts it at the beginning
07:13:50 <bartavelle> yes but doesn't `length:: [a] -> Int` mean the exact same thing ?
07:14:04 <ski> bartavelle : when we have `foo :: forall a. ..a..', with `forall a.' at the *top-level* of the type, just after the `::', then Haskell allows us to omit it (it will be inferred)
07:14:20 <bartavelle> okay ...
07:14:41 <bartavelle> where else could it be ?
07:14:45 <frerich> ski: Is there an "exists", too, as in "length :: exists a. [a] -> Int", and how would that be useful?
07:15:05 <ceii> but (using extensions) you can have foralls that aren't a the top-level, for example runST has type (forall s. ST s a) -> a
07:15:23 <ski> bartavelle : however, when we write `foo :: (forall a. [a] -> [a]) -> [(Int,Bool)] -> [(Int,Bool)]' we're now saying that the (first) *argument* of `foo' must be polymorphic (`foo' itself is *not* polymorphic here)
07:15:26 <ceii> which means runST's argument has to be polymorphic in s
07:16:04 <ski> frerich : conceptually, there's an `exists', but there's no actuall Haskell syntax for it (it can be encoded, though) -- sometimes i (at least) write it in pseudo-code, to more clearly convey an idea
07:16:11 <bartavelle> what if you wrote it like `forall s. (ST s a) -> a` ?
07:16:37 <ski> (frerich : possibly, one could (with some restrictions) add a (first-class) `exists' construct to Haskell -- but it hasn't been done yet)
07:16:46 <bartavelle> I suppose I'll just read this: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
07:17:13 <ski> bartavelle : `foo :: forall s. ST s a -> a' would claim `foo' itself is polymorphic -- which isn't what is wanted here
07:17:24 <ceii> then runST's argument doesn't have to be polymorphic; rather, runST has to adapt to whatever 's' its argument decides on
07:17:45 <merijn> bartavelle: A concrete example: I have a datatype (Record) that is parameterised over a type (i.e. "Record a"), and a function that applies another function to several different types of records the naive type for the function "(Record a -> b) -> b" doesn't work
07:18:14 <merijn> bartavelle: Because "(Record a -> b) -> b" means my function excepts any function that works on *one* type of record, rather than working on *all* of them
07:18:27 <bartavelle> ah
07:18:31 <bartavelle> yes this makes sense
07:18:37 <ski> bartavelle : a "rule-of-thumb" : (a) if something has type `forall a. ..a..', i.e. is polymorphic in `a', then it's the *caller*/user which decides what type `a' is, the *callee* (i.e. the code defining that value) itself must be prepared to work for *any* choice of `a'
07:18:48 <merijn> bartavelle: The correct type ends up being "(forall a . Record a -> b) -> b" i.e. given a function that can work on *any* record, do something with a bunch of different records
07:19:18 <bartavelle> ok ok !
07:19:23 <frerich> ski: but if you would be to write a pseudo function signature like 'f :: exists a. a -> Bool', then you surely think of at least one type already, no? So why not just use the type directly (e.g. "f :: Int -> Bool") or use a constraint (as in "f :: (Eq a) => forall a. a -> Bool") (I don't know where the 'forall' would go in the second thing)?
07:20:09 <ski> bartavelle : (b) if something has type `exists a. ..a..', i.e. is existential in `a', then it is the *callee* / the code defining/computing the value which decides what type `a' is, and the *caller* must now be prepared to work for *any* choice of `a' the callee happens to actually use
07:20:34 * merijn thinks explaining forall without mentioning existentials is a simpler approach
07:20:44 <ski> `foo :: forall a. ..a..' means user of `foo' decides what `a' is, code of `foo' should work with any
07:21:04 <ksf> exists a. a -> Bool is quite trivially true...
07:21:12 <ski> `bar :: exists a. ..a..' means code of `bar' decides what `a' is, user of `bar' should work with any
07:21:28 <bartavelle> (btw, are you guys CS. profs. or are you just used to explaning the same old things all the time on IRC?)
07:21:33 <ksf> among of  a gazillion others, a = Bool is a good example.
07:21:43 <hiptobecubic> bartavelle, the latter i'd say
07:21:49 <hiptobecubic> maybe some minor exceptions
07:22:17 <mm_freak> merijn: correct
07:22:20 <frerich> ksf: Yes, but that's my point - why would bes omething like 'exists' ever be useful if you can just as well use the type you think of directly, or use 'forall' with constraint(s)?
07:22:21 * ski thinks pointing to the symmetry/duality between `forall' and `exists' can help here
07:23:09 <merijn> bartavelle: I plan to be a CS prof eventually, does that count? :p
07:23:24 <ski> bartavelle : btw,`exists' is typically used for some "OO"-like things
07:23:30 <merijn> Or, teacher anyway. Not sure whether I can be bothered to play the academic game enough to become professor :p
07:23:41 <frerich> bartavell: I'm a bloody amateur but I think ski is a die hard CS guy :)
07:23:50 <int-e> bartavelle: students are more likely to have time for IRC. we have a great mix of people here though, from professional programmers to people who are just curious about this Haskell thing.
07:25:22 <bartavelle> heh
07:25:40 <ski> frerich, bartavelle : `foo :: (exists a. ..a..) -> ...' is the same as `foo :: forall a. (..a.. -> ...)', but `bar :: ... -> (exists a. ..a..)' and `baz :: (forall a. ..a..) -> ...' can't easily be expressed otherwise
07:26:10 <ski> `bar' is a rank-2 function. `bar' is a function *returning* an existential
07:26:22 <ksf> frerich, http://stackoverflow.com/questions/5235116/what-does-exists-mean-in-haskell-type-system
07:27:18 <ski> (in case you're curious, `quux :: ... -> (forall a. ..a..)' is the same as `quux :: forall a. (... -> ..a..)')
07:27:23 <merijn> bartavelle: In my experience Rank2Types (and RankNTypes) become relatively obvious and simple the first time you encounter a situation in your own code where they are needed to express what happens
07:27:40 <merijn> (Note: I'm not sure yet whether the same applies to existentials :p)
07:28:00 <bartavelle> I know I had to write Rank2Types in code I wrote when I started haskell
07:28:10 <bartavelle> I am pretty sure I did something wrong though
07:28:25 <tywei> hey guys. is there a generic type of all anonymous functions when define functions parameter types?
07:28:25 <ski> the `bar' form (returning existential) is typically used when you want the type of the result to depend on the input in some non-trivial way -- or when you want to return a collection of things having the same interface, but not containing exactly the same types (think returning a list of OO widgets)
07:28:56 <ski> er, sorry, *`baz'* above is a rank-2 function, not `bar'
07:29:25 <bartavelle> ah yes, this is what I did (return a collection of things having the same interface, but not containing exactly the same types)
07:29:27 <ksf> tywei, whether a function has a name isn't expressed in its type
07:29:39 <ski> the `baz' form (polymorphic argument) can be used when you really need to use the argument polymorphically; or when you just want to hide implementation details inside `baz'
07:30:03 <ski> bartavelle : yes, and sometimes you really want that
07:30:05 <ski> however
07:30:13 <ski> @where existential-antipattern
07:30:13 <lambdabot> "Haskell Antipattern: Existential Typeclass" by Luke Palmer at <http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/>
07:31:06 <ski> bartavelle : did this help somewhat ?
07:31:50 <bartavelle> ski, yes, somewhat. I need to work this on my own to acutally understand it
07:32:24 <tywei> thanks ksf, no something like foo :: (Int, \lambda) -> Int ?
07:32:54 <ski> bartavelle : i think the difference between caller vs. callee deciding the type vs. handling any chosen type for `forall' vs. `exists' could help
07:32:58 <merijn> tywei: "foo :: (Int, b) -> Int"?
07:33:05 <ksf> you can have something like foo :: (Int, Foo -> Bar) -> Int
07:33:10 <merijn> tywei: b can match any function type
07:33:22 <bartavelle> ski, yes definitely
07:33:22 <ksf> but haskell won't care if the Foo -> Bar you pass has a name
07:33:43 <ski> bartavelle : do you know any C or C++ ?
07:33:48 <bartavelle> yes
07:34:17 <mizu_no_oto> What's the best way to work with infix operators on values wrapped in a functor (e.g. adding Reader Foo Ints, together)?  Define (<$+>) = fmap (+)?
07:34:46 * hackagebot mustache2hs 0.1.1 - Utility to generate Haskell code from Mustache templates  http://hackage.haskell.org/package/mustache2hs-0.1.1 (StephenWeber)
07:35:15 <ksf> mizu_no_oto, instance Num Foo where (+) = liftA2 (+)
07:35:23 <Cale> mizu_no_oto: itym  liftM2 (+)
07:36:02 <ski> bartavelle : you may have seen stuff like `struct {void *data; result_t (*callback)(void *data,argument_t arg);}' or simply `other_result_t with_callback(void *data,result_t (*callback)(void *data,argument_t arg),other_argument_t other_arg)'
07:36:38 <tywei> ksf: can foo->bar represent any number of arguments?
07:36:40 <bartavelle> well yes
07:36:58 <mizu_no_oto> The actual type in the Reader isn't an Int, but I do mean liftM2 >_<
07:36:59 <ski> bartavelle : it might help to realize that this (normally) is basically `exists<T> struct {T *data; result_t (*callback)(T *data,argument_t arg);}' or simply `other_result_t exists<T> with_callback(T *data,result_t (*callback)(T *data,argument_t arg),other_argument_t other_arg)'
07:37:19 <ksf> tywei, you'd say Foo -> Bar -> Baz for two arguments.
07:37:23 <tywei> merijn: sorry mate b maybe is not suitable for \anonymous funcrions
07:37:29 <ski> bartavelle : and of course (some uses of) templates in C++ corresponds to polymorphism/`forall'
07:37:33 <ksf> hint: just write the code, load ghci, type :t <name>
07:37:46 <frerich> ski: aaaaaah.... *that* is a good way to put it!
07:37:46 <ksf> :t \f x y -> f x y
07:37:48 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
07:38:11 <bartavelle> exists<> is a valid C++ template keyword ?
07:38:19 <ski> not afaik
07:38:23 <mizu_no_oto> Should I define new operators to keep the infixity, or should I just use liftA2 (+) prefix?
07:38:23 <bartavelle> ah good
07:38:25 <ksf> mizu_no_oto, http://www.reddit.com/r/programming/comments/9wmjt/askproggit_what_is_the_most_boilerplate_free/c0esfjt
07:38:31 <merijn> tywei: Eh, why not?
07:38:32 * ski doesn't profess to be very proficient with C++, though
07:38:39 <ksf> you need an applicative instance for that.
07:38:51 <tywei> ksf: thank you very much .my first question a silly one
07:39:09 <merijn> > let getFirst :: (Int, b) -> Int; getFirst (i, _) = i in getFirst (1, \x -> x)
07:39:10 <lambdabot>   1
07:39:31 <ski> bartavelle : the point is, each such struct "hides" *some* type `T', where the type of `data' is `T *' and the type of the first argument is also `T *', for the *same* type `T' (so we can safely pass the pointer as first arg)
07:39:46 <bartavelle> yes that is plain
07:40:00 <merijn> hah, this is actually a nice Rank2Types example, I think :p
07:40:08 <ski> bartavelle : however, given a different such struct, it might well be associated with a *different* type `T', which can't be mixed with the ones from other such structs
07:40:19 <bartavelle> yes
07:40:26 <merijn> > let getFirst :: (Int, b) -> Int; getFirst (i, _) = i in (getFirst (1, \x -> x), getFirst (3, \x y -> y))
07:40:26 <bartavelle> ahhhhh
07:40:28 <lambdabot>   (1,3)
07:40:29 <ski> this is what existential types is about
07:40:31 <merijn> oh, blah
07:41:09 <ski> existential types is about private, implementation-chosen types
07:41:30 <bartavelle> got it (I suppose)
07:43:03 <tywei> merijn: maybe it is too generic to represent all possible anonymouses     its a question we came up with in a class so its probly trivial
07:43:53 <ski> bartavelle : would like like a small example ?
07:44:34 <bartavelle> perhaps if you have time for this
07:44:40 <ski> consider the type
07:44:46 <ski>   data SSP a b = MkSSP {unSSP :: a -> (b,SSP a b)}
07:44:50 <ski> (`SSP' for "synchronous stream processor")
07:45:16 <ski> a value of type `SSP a b' is a kind of "machine", which can be passed `a' inputs and which outputs `b' values
07:45:38 <ski> when passed an `a' input, it outputs a `b', together with a new `SSP a b' machine (think : a new machine state)
07:46:06 <ski> then you can continue by feeding *that* stream processor a new `a' input, getting a new `b' output, and so on
07:46:07 <bartavelle> ok
07:46:20 <ski> it's easy to write a function
07:46:33 <ski>   fromSSP :: SSP a b -> ([a] -> [b])
07:46:36 <Puffton> Do you guys know of any table listing arithmetic operators and their relative cost?
07:46:57 <ski> that given a stream processor and an input stream (possibly finite), produces an output stream (of the same length)
07:46:58 <quicksilver> cost?
07:47:08 <Puffton> quicksilver, yeah in terms of computation
07:47:11 <quicksilver> (*) costs £1.50 but I bought mine from amazon marketplace for 1.25
07:47:23 <Puffton> for instance modulo is more expensive than multiplication
07:47:24 <bartavelle> Puffton, this is architecture dependant
07:47:35 <ski> bartavelle : however, we can (if we want to) rephrase this type in a non-recursive way
07:47:48 <quicksilver> this is very architecture, compiler, compiler version, backend dependenet
07:47:51 <quicksilver> so, no, I don't.
07:48:01 <ski> instead of returning a new "machine" every time, we could get it to just return a new "machine state" (think "instance variables")
07:48:23 <Puffton> ok :(
07:48:31 <ski> of course, how the internal state/instance variables look for an individual machine depends on the machine
07:49:05 <quuuux> well, not -entirely-. For sufficiently large values of the operands, you can start talking about asymptotic behaviour
07:49:05 <ski> but, to represent this, we need (a) the current state, of type `s' (say); (b) a function that given an input and the current state, gives the output and the next state
07:49:14 <ski> iow, we get
07:49:34 <ski>   data SSP a b = MkSSP (exists s. (s,(a -> s -> (b,s))))
07:49:38 <bartavelle> quuuux, this is representation dependant too
07:50:00 <ski> (this is not quite valid Haskell-with-extensions, yet)
07:50:01 <bartavelle> gniiii
07:50:23 <bartavelle> alright
07:50:25 <ski> now, lets see what the type of the constructor `MkSSP' is
07:50:41 <ski>   MkSSP :: (exists s. (s,(a -> s -> (b,s))) -> SSP a b
07:50:50 <ski> but this is the same as
07:51:00 <ski>   MkSSP :: forall s. (s,(a -> s -> (b,s)) -> SSP a b
07:51:38 <ski> i.e. for every type `s', we have the type `(s,(a -> s -> (b,s))) -> SSP a b'
07:51:46 <ski>   forall s. MkSSP :: (s,(a -> s -> (b,s)) -> SSP a b
07:52:02 <ski> converting back to the datatype definition, we get
07:52:15 <ski>   data SSP a b = forall s. MkSSP (s,(a -> s -> (b,s)))
07:53:03 <ski> which is valid Haskell (using `ExistentialQuantification')
07:53:20 <ski> as a final step, we could uncurry the data constructor, so we get
07:53:26 <ski>   data SSP a b = forall s. MkSSP s (a -> s -> (b,s))
07:53:35 <hpaste> sarfraz pasted “project euler 3” at http://hpaste.org/76031
07:53:53 <sarfraz> help plz?
07:53:54 <sarfraz> http://hpaste.org/76031
07:54:21 <ski> so, an `SSP a b' contains (a) "instance variables" of type `s', and (b) methods (just one here) of type `a -> s -> (b,s)' (`s' corresponds to the `this'/`self' implicit argument)
07:54:35 <srhb> sarfraz: division between integers is called `div`
07:55:03 <sarfraz> ahh I see
07:55:08 <srhb> sarfraz: It is telling you that / is defined for types that are instances of Fractional -- Integrals are not.
07:55:12 <sarfraz> let me check
07:55:23 <bartavelle> I still have trouble understanding why I need this "forall s." notation here, is it implicit if removed ? Why isn't it written for b ?
07:55:33 <bartavelle> because b depends on a somehow so can't exist for all bs ?
07:55:38 <quuuux> sarfraz: or, if you don't want integer division, you need to switch to a fractional type (which can be done with fromIntegral)
07:55:57 <bartavelle> ah
07:55:58 <bartavelle> no
07:55:59 <bartavelle> I get it
07:56:27 <bartavelle> it means it works for whatever state representation I want, but why would I need the forall at all ?
07:56:57 <bartavelle> and what's the difference with forall a s. ?
07:57:49 <sarfraz> no I want to keep integral I am trying to get the list of prime factors
08:00:46 <sarfraz> ok thx :) The algo doesn't work will have to keep searching.
08:01:55 <Cale> bartavelle: when you don't write forall to quantify type variables, one is implicitly inserted for you at the top level of the type signature you're writing
08:01:59 <Cale> :t length
08:02:01 <lambdabot> forall a. [a] -> Int
08:02:10 <Cale> :t map
08:02:12 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:02:29 <Cale> bartavelle: normally you'd just write   length :: [a] -> Int
08:02:29 <bartavelle> Cale, ok, then what would be wrong with writing ski's sample with forall a s. ?
08:02:37 <Cale> or   map :: (a -> b) -> [a] -> [b]
08:03:04 <bartavelle> or forall a s b. ? (which I suppose is wrong because b depends on a somehow)
08:03:09 <merijn> bartavelle: The confusion here is that existential quantification (ski's example) reuses the forall syntax
08:03:25 <merijn> Which is one of my pet peeves
08:03:30 <Cale> bartavelle: I'm not sure which example you're talking about
08:03:36 <merijn> bartavelle: Notice how the forall is on the right side of a data declaration
08:03:43 <merijn> < ski>   data SSP a b = forall s. MkSSP s (a -> s -> (b,s))
08:03:59 <bartavelle> Cale,  data SSP a b = forall s. MkSSP s (a -> s -> (b,s))
08:04:02 <bartavelle> damn, phone, brb
08:04:21 <Cale> It means that for all types s, there is a data constructor MkSSP which takes a parameter of type s and a parameter of type (a -> s -> (b,s))
08:04:58 <bartavelle> but why isn't this true for all a's too ?
08:05:04 <bartavelle> well
08:05:08 <bartavelle> why wouldn't want this to be true
08:05:14 <Cale> You're getting something of type SSP a b
08:05:22 <Cale> as the result of that constructor
08:05:38 <bartavelle> ah so a and b are given
08:05:41 <Cale> yeah
08:05:46 <bartavelle> ok, got it
08:06:05 <Cale> another way to write that type:
08:06:11 <Cale> data SSP a b where
08:06:31 <Cale>   MkSSP :: forall s. s -> (a -> s -> (b,s)) -> SSP a b
08:06:54 <merijn> Cale: You wouldn't even need the forall in that GADT, right?
08:06:57 <Cale> and we can leave out the 'forall s' there
08:06:59 <Cale> yeah
08:07:04 <akamaus> hi! After some refactoring I got this function: http://hpaste.org/76032 . I feel It can be simplified even further. Can you give a hint?
08:07:15 <Springwight> What do you think about using arrays for the front-ends of queues
08:07:17 <shachaf> Also: data SSP a b = MkSSP (a -> (b, SSP a b))
08:07:18 <merijn> GADTs == the shit
08:07:32 <quuuux> akamaus: use fromMaybe
08:07:41 <Springwight> hmm
08:07:45 <quuuux> er, wait, no, just maybe
08:08:01 <shachaf> No particular need for the existential type there since you can just keep track of "s" with a closure.
08:09:21 <Cale> Springwight: To be honest, I've never run into a case where I couldn't just use Data.Sequence (which is internally a finger tree) as a perfectly reasonable queue implementation.
08:09:22 <akamaus> quuuux, thought about it. I suspect it also has something to do with Monoids
08:09:35 <merijn> akamaus: I feel there should be something use mconcat there
08:09:40 <merijn> :t mconcat
08:09:42 <lambdabot> forall a. (Monoid a) => [a] -> a
08:09:49 <akamaus> merijn, yeah!
08:10:03 <akamaus> but I'm inside a monad..
08:10:04 <merijn> :t mconcat . sequence
08:10:05 <lambdabot> forall a. [[a]] -> [a]
08:10:11 <merijn> hmm
08:10:13 <merijn> :t mconcat . sequenceM
08:10:15 <lambdabot> Not in scope: `sequenceM'
08:10:19 <merijn> :t sequence
08:10:20 <shachaf> merijn: You don't want sequence.
08:10:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:10:24 <akamaus> no.. I won't get short circuiting behavior this way
08:10:29 <merijn> right
08:10:31 <merijn> bleh
08:10:36 <merijn> :t foldM
08:10:37 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
08:10:47 <Springwight> Cale, you just don't understand me ;_;
08:10:56 <merijn> Maybe foldM with mplus or something?
08:11:04 <merijn> or mappend, whatever
08:12:05 <Cale> Springwight: YOU WILL SUBMIT TO THE ALL-ENCOMPASSING WILL OF THE FINGER TREE!
08:12:09 <Cale> :D
08:12:11 <Springwight> :)
08:12:27 <akamaus> merijn, we're close, but foldM wouldn't stop the computation too
08:12:27 <byorgey> merijn: well, the case can be replaced with a call to  maybe (while rest) (return . Just)
08:12:38 <shachaf> Control.Monad.Loops might have something you like.
08:12:58 <byorgey> merijn: and then you don't have to give r a name:   act >>= maybe (while rest) (return . Just)
08:13:05 <quuuux> oh, wow, that's incredible
08:13:10 <quuuux> I have that pattern all over one codebase
08:13:29 <quuuux> and I didn't even know about Control.Monad.Loops
08:13:33 <merijn> quuuux: :p
08:13:53 <fmap> @type foldr (liftA2 mplus) (return Nothing)
08:13:54 <lambdabot> forall a (f :: * -> *). (Applicative f, Monad f) => [f (Maybe a)] -> f (Maybe a)
08:14:16 <fmap> hm
08:16:29 <akamaus> byorgey, perfect! :)
08:16:45 <doomlord> if you have a record with component records and you create a copy with modification a=b{something=...} ... am I right in assuming any sizeable components will merely have references copied
08:17:16 <merijn> doomlord: All unmodified components will just be reference copied
08:17:55 <ski> byorgey : `a' and `b' are type arguments of `SSP', so they're bound to the left of `=' -- however `s' is not bound there, but must be bound somewhere, in this case in the `forall s.' in `forall s. MkSSP ..s..'
08:17:59 <ski> er
08:18:02 <ski> bartavelle ^
08:18:38 <merijn> doomlord: in your example you'll get a copy of b where ever record entry is just a reference copy of the one in the original b (except for something(
08:18:56 <Cale> Springwight: actually, there seems to be a sense in which monoidally-indexed trees are the only thing worth caring about
08:19:12 <merijn> doomlord: Immutability and all that ;)
08:19:12 <Springwight> what do you mean?
08:19:23 <byorgey> akamaus: alternatively, this is basically just 'msum' if you express the type as  [MaybeT m a] -> MaybeT m a
08:19:24 <Cale> Springwight: Whenever we use trees to make things perform better in computer science, there's always a monoid hanging around, at least implicitly, on the branch nodes.
08:19:32 <doomlord> yeah i figured immutablity must make it safer to just use references more often :)
08:19:42 <Springwight> what do you mean by monoid in this context
08:19:55 <Springwight> oh
08:19:58 <akamaus> byorgey, I guess MaybeT is overkill in my case
08:19:59 <Springwight> yeah I get it
08:20:05 <Cale> A monoid is a set M together with a binary operation * which is associative and has an identity
08:20:07 <byorgey> akamaus: because the MonadPlus instance for MaybeT does exactly this short-circuiting-find-the-first-Just thing
08:20:11 <byorgey> akamaus: why?
08:20:35 <byorgey> it's really quite lightweight
08:20:58 <Cale> Springwight: basically, the branches need to summarise what's going on in the leaves, and the operation of combining summaries needs to be associative in order for tree rotations to work properly
08:21:15 <Springwight> it uses memoization?
08:21:23 <doomlord> the use case I'm thinking about at the minute is a gameworld; If parts are updateing, and parts are static;(active & idle lists) parts might be local references to permanently immutablee data.
08:21:29 <Cale> Springwight: Well, think about every tree you've ever used :)
08:21:38 <Cale> Springwight: Like, say, a binary search tree
08:21:39 <akamaus> byorgey, I just need to run a bunch of actions until first one succeds. I'm already inside StateT s  (ReaderT r IO) :)
08:22:07 <Springwight> so it memorizes the node count and things
08:22:11 <byorgey> akamaus: right, and running a bunch of actions until the first one succeeds is exactly what msum for MaybeT does.
08:22:15 <Springwight> by definition
08:22:19 <merijn> doomlord: Essentially it's reasonable to assume that everything will always be reference copied unless you're "updating" an element inside, in which case you clearly have to update that particular entry
08:22:29 <byorgey> akamaus: you can convert to MaybeT by applying 'MaybeT', and convert back with 'runMaybeT'
08:22:40 <Cale> Springwight: right, and if not the node count, then *something* about all the stuff in that subtree
08:22:46 <Springwight> my finger tree implementation had to have annotated sizes.
08:22:54 <Springwight> because none of that cool stuff in F#
08:23:19 <doomlord> somewhere there's going to be actual state data, records holding position/velocity etc; below a certain grain one wants value rather than reference.
08:23:20 * byorgey thinks people are too afraid to use one-off, 'local' instances of monads and monad transformers
08:23:27 <Cale> Springwight: So you fixed one particular monoid and just implemented sequences?
08:23:27 <akamaus> byorgey, I'll consider it in the future, but now it's too isolated use case to introduce another transformer, imho
08:23:47 <Springwight> what do you mean?
08:23:48 <Cale> Springwight: and not all the other cool things like interval trees and priority search queues? :)
08:23:56 <byorgey> like if you are using a monad transformer it's some sort of Big Deal and it's only worth considering if you will be using it Everywhere
08:24:08 <Cale> Springwight: By picking different monoids, finger trees can become a wide variety of useful data structures
08:24:17 <byorgey> akamaus: no worries though, do whatever you want =)
08:24:21 <shachaf> byorgey: I think monad transformers are way too awkward to justify localized use.
08:24:46 <Springwight> yeah that's true. I implemented indexing, concat, and split. and insert in the middle.
08:24:52 <Springwight> but I cut a few corners
08:24:52 <byorgey> shachaf: awkward in what sense?
08:25:11 <Springwight> I had to annotate stuff explicitly
08:25:12 <byorgey> shachaf: not that I don't think they can be awkward.  I just want to know what you mean.
08:25:26 <shachaf> Running and wrapping and lifting and all that, for one.
08:25:38 <Springwight> Though I always annotate size in nested data structures.
08:25:40 <typoclass> cale: interesting; do you have a link on that?
08:25:52 <akamaus> shachaf, indeed :)
08:25:52 <Springwight> It's in the original finger tree paper
08:25:52 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
08:25:59 <typoclass> cale, thanks a lot
08:26:10 <Springwight> finger trees aren't that good ya know :P
08:26:18 <byorgey> shachaf: sure, but this particular use case involves exactly one wrap, one unwrap, and no lifts.
08:26:30 <byorgey> you could even encapsulate the wrap/unwrap in a single function.
08:26:34 <akamaus> shachaf, it pays pack only when used systematically
08:27:36 <shachaf> byorgey: You could also encapsulate the whole thing in a single function with the type akamaus was asking for, and that function won't even need to use monad transformers. :-)
08:27:40 <Cale> Springwight: The actual choice of tree structure actually isn't the important thing about that paper, as far as I'm concerned.
08:27:56 <Springwight> what is then?
08:28:15 <Springwight> the use of monoids to create a felxible data thingy
08:28:19 <Cale> yes
08:28:25 <Cale> Springwight: It's the recognition that when we have some data structure which we're using some sort of tree to store the elements of
08:28:46 <byorgey> shachaf: but that same argument applies to ANY abstraction.  Why use monads at all?  You can always just re-implement them from scratch, and encapsulate all the details!
08:28:48 <shachaf> byorgey: Let's say I have some monadic computation and I want to add early return into various places in it using EitherT. I can't think of a small case where that ends up being less awkward than the alternative.
08:28:50 <Cale> then there's always a monoid hanging around, which we turn single elements of our structure into in some fashion
08:29:00 <Springwight> unless you don't have monoids
08:29:04 <Springwight> in which case
08:29:05 <Cale> and then combine summaries at each branch
08:29:05 <byorgey> it's more a question of where the cost/benefit break-even point is, I guess.
08:29:09 <shachaf> byorgey: Indeed, most abstractions aren't worth it when using them is more trouble than not using them.
08:29:13 <Cale> You always have some monoid
08:29:23 <Cale> Even if you're not abstracting over monoids
08:29:23 <Springwight> Not in other languages :P
08:29:30 <Cale> Yes in other languages!
08:29:31 <byorgey> shachaf: I agree. I think we just disagree where the cutoff point is in this particular case.
08:29:33 <Springwight> Ohh
08:29:39 <Cale> addition is a monoid!
08:29:39 <Springwight> You could say a lot of things then
08:29:46 <Springwight> Isn't that silly
08:29:47 <shachaf> byorgey: Monad transformers also just generally annoy me.
08:29:51 <typoclass> shachaf: please refrain from being practical
08:29:52 <shachaf> The whole n^2 instances thing.
08:29:55 <byorgey> fair enough.
08:29:57 <Cale> No it isn't silly
08:29:59 <byorgey> yes, that is annoying.
08:30:10 <Springwight> well you're saying "we need addition in all data structures" :P
08:30:15 <Cale> The fact that addition is a monoid is why it's okay to store sizes of subtrees
08:30:39 <Cale> because rebalancing won't affect the size of the whole tree
08:30:45 <Cale> yeah?
08:30:50 <shachaf> I like the idea of monad transformers, but I haven't seen that many cases where localized use makes sense.
08:31:13 <shachaf> byorgey: I suspect this conversation would be easier with some more concrete examples, but unfortunately I don't have any on hand. :-)
08:31:21 <Cale> and for example, taking the maximum element is a monoid (with some representation of negative infinity as the unit)
08:31:29 <Cale> and that gives binary search trees
08:31:38 <typoclass> > (\(+) (*) -> 1 + 2 + 3) (*) (+) -- question: on tryhaskell.org this gives 5. lambdabot and ghci both give 6. any ideas?
08:31:39 <lambdabot>   6
08:31:45 <Springwight> I understand what you mean
08:31:51 <Cale> (perhaps slightly skewed binary search trees, but nonetheless)
08:32:06 <Springwight> I'm lesss familiar with the monoid term so I'd use different terminology
08:32:23 <shachaf> typoclass: I get 6 on tryhaskell.org
08:32:54 <typoclass> shachaf: right. i'm an idiot. hang on
08:33:00 <Cale> monoid just means some set of values with a binary operation * on them which is associative, so a*(b*c) = (a*b)*c, and which has an identity element e such that for any a, we have a*e = e*a = a
08:33:32 <Cale> and in addition to this monoid, we also want a function which turns the elements we're storing in our tree structure into elements of the monoid
08:33:38 <Springwight> if you can't memoize the result though it doesn't yield good performance
08:33:38 <Cale> this is often something really simple
08:33:44 <Cale> Springwight: right!
08:33:58 <Springwight> I understand what you mean
08:34:01 <Cale> Springwight: and in order to be able to memoise, you need the monoid to be an honest monoid
08:34:05 <Springwight> you can memoize it because
08:34:17 <Cale> (one which satisfies those laws)
08:34:18 <Springwight> yes
08:34:43 <Springwight> I can't memoize things. I can't define a monoid in this way but it will be recursively evaluated forever and ever.
08:34:51 <Springwight> I mean in my current languae
08:35:09 <Cale> You can certainly define a monoid in F#
08:35:29 <Springwight> you can't memoize the result
08:35:34 <Cale> You just build a structure with two fields, one which consists of the identity element, and the other a function encoding the combining operation.
08:35:45 <Cale> The memoising goes on inside the actual tree structure
08:35:50 <Cale> which you're building
08:36:00 <Cale> you store values which the monoid's combining operation acts on
08:36:10 <Springwight> that would require modification of the structure
08:36:13 <Cale> ?
08:36:23 <Springwight> I'd need to code it in a way that it would store the data
08:37:13 <Springwight> which I guess is what I do already
08:37:47 <Springwight> The idea of coming from outside, and implementing something without modifying the code of the object is not possible for me
08:38:14 <typoclass> shachaf: i wondered because i saw https://lh4.googleusercontent.com/-I34Y2QndsYs/UHLAZxj2SWI/AAAAAAAAD3E/c8RX1akOX9w/s343/Bildschirmfoto+2012-10-08+um+13.59.38.png but you're right, i can't reproduce it myself. it's weird
08:38:34 <armlesshobo> what's this memo stuff? what do I need to search for?
08:38:36 <typoclass> i have no idea what went on when that guy typed that in
08:39:30 <Cale> Springwight: doesn't F# have first class functions?
08:39:35 <Josh> God damn 974 :D
08:39:44 <Springwight> it does
08:39:56 <Cale> Springwight: that's all there is to it
08:39:56 <Springwight> I see
08:40:05 <Springwight> I didn't think about it like that
08:40:22 <Cale> Springwight: a monoid is some type T for which there is a function T -> T -> T which is associative and has an identity element, which is a value in T
08:40:48 <Cale> If you have parametric polymorphism and first class functions, it shouldn't be hard to parametrise something on a monoid
08:40:52 <Springwight> so you're saying implement memoization for arbitrary functions
08:40:56 <t7> natural numbers are teh monoid
08:41:08 <Springwight> on the data structure?
08:41:16 <Cale> You don't have to memoise the function, because what you'll be doing is storing elements of T in your actual tree structure on the branch nodes
08:41:22 <Cale> which is enough of a memo table
08:41:31 <Springwight> yeah but I don't know what I need to store
08:41:54 <Springwight> I'd need to make a space to store something
08:42:00 <Cale> The other ingredient you need is a function A -> T where A is the type of elements at the leaves of your structure
08:42:19 <Cale> values of type A are at the leaves, values of type T are at the branch nodes
08:42:32 <Springwight> There is an F# lazy construct that uses memoization but it has limitations.
08:42:42 <shachaf> What's a generic name in Haskell for anything which is associative and has an identity?
08:42:43 <Springwight> It's not suitable for most purposes
08:42:55 <shachaf> I.e. either a monoid or a category. Don't say category.
08:43:20 <typoclass> shachaf: Endobamboozloid
08:43:23 <maukd> mormonoid
08:44:23 * ski . o O ( "marmaloid" )
08:44:47 <otters> dioid
08:44:57 <Cale> shachaf: category is the right term though
08:45:04 <typoclass> man, we're helpful today ...
08:45:11 <shachaf> Cale: I know. :-(
08:45:14 <typoclass> (except cale of course)
08:45:20 <shachaf> But in Haskell people will think you mean Category.
08:45:41 <ski> shachaf : kinds ?
08:45:43 <Cale> Springwight: you know how you presently cache sizes in the branch nodes of your tree?
08:45:48 <Cale> Springwight: it's just like that
08:46:05 <Cale> Springwight: you can think of those sizes as memoising the addition function, but that might be a little strange :)
08:46:27 <Cale> Springwight: basically instead of just a size, you store some value of type T
08:46:56 <Cale> Springwight: and then when you combine two subtrees at a new branch node, you combine their elements of type T with the monoid function on T
08:47:12 <Cale> and you put that value at the new root
08:47:17 <Springwight> That's... not... that won't work.
08:47:19 <Springwight> in F#.
08:47:21 <Cale> what?
08:47:25 <Cale> You are insane
08:47:32 <Cale> that would work in literally any language
08:47:41 <Cale> I can do this in C, if I want :)
08:47:42 <Springwight> no, I mean, it depends on what you mean.
08:48:00 <Springwight> You're saying make a field of generic type T
08:48:03 <Cale> (it might be slightly painful to do it right in C)
08:48:04 <Springwight> that could be anything at all?
08:48:11 <Cale> Springwight: yes
08:48:22 <shachaf> ski: Right.
08:48:22 <Springwight> I see
08:48:25 <danharaj> edwardk: I'm about to start hacking a little bit on machines, but I'd like some guidance. My goal is to add blocking machines that don't require input and aren't stopped so that I can use `wye` to pull from potentially blocking sources. I think there might also be profit to be had by implementing an asynchronous version of awaits. Thoughts?
08:48:37 <Springwight> that would be painful. F# is finicky about generics used like that.
08:48:55 <Springwight> A lot of it isn't inferred too.
08:48:57 * ski . o O ( `data Tree a = Leaf { element :: a, size :: Integer, size = 1 } | Branch { leftTree :: Tree a, rightTree :: Tree a, size :: Integer, size = 1 + size leftTree + size RightTree }' )
08:49:03 <Cale> Springwight: If you can confine it to being T which has a particular interface, that's even better
08:49:15 <edwardk> danharaj: you mean you want to be able to request input if its available but proceed otherwise?
08:49:15 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
08:49:22 <edwardk> @messages
08:49:22 <lambdabot> merijn said 7h 5m 36s ago: I know about the Operators list (it's a life saver!), I was just curious of the pattern behind the naming convention (e.g. % is flip $). Was just curious if the rest i.e.
08:49:22 <lambdabot> what <, << and ~ stand for in operators was written down somewhere :)
08:49:28 <Springwight> what if I want more than one of these?
08:49:28 <Cale> Springwight: (then you can stick the monoid operation and identity in that interface)
08:49:42 <Cale> Springwight: more than one monoid operation on the same type?
08:49:48 <Springwight> yeah
08:50:02 <ski> shachaf : sorry :) i mean, what are the kinds of the involved types ?
08:50:10 <danharaj> edwardk: yes, and perhaps request input but demand it later in the machine execution-- have the driver decide how to handle such asynchronous demands.
08:50:40 <Springwight> I understand what you mean
08:50:49 <Springwight> That is really interesting
08:50:54 <Springwight> I never thought about it like that
08:50:58 <Cale> Springwight: then making subclasses might work, but you might also just split off your monoid structure into something like  Monoid<T> which would have fields  identity : T  and  multiply : T -> T -> T
08:51:10 <shachaf> ski: Any kinds, as long as the operation is associative and the identity is, uh, an identity.
08:51:25 <edwardk> danharaj: ah, you can do that by just making a custom input type that creates the async request and gives you back the token for it, that you can use another query to force later
08:51:33 <Springwight> Making a structure extensible by means of an external function.
08:51:46 <edwardk> danharaj: let me see if i can give an example, hrmm
08:53:28 <Cale> Springwight: don't they call that delegates or something in the OO world?
08:53:45 <Springwight> They call them delegates specifically in .NET but that's not how they are used.
08:53:57 <Springwight> Not normally, at least.
08:54:03 <Springwight> It's just functions in F#.
08:54:03 <edwardk> Something like: data Async i o where Async :: Async i (Async i i); Foo :: Whatever -> Async i i
08:54:21 <edwardk> danharaj: then you can req <- awaits Async;   and then later awaits req
08:54:23 <Springwight> It makes sense why not use them like that.
08:54:24 <Cale> "delegates" is such an enterprisey term for functions
08:54:30 <Cale> lol
08:54:35 <Springwight> It's not functions. It's a type of object.
08:54:51 <Cale> yeah, but that type of object is just a way to represent a function :P
08:54:52 * nand` likes ‘methods’, because it captures the concept of imperative side effects
08:54:56 <edwardk> danharaj: also i'm thinking about changing awaits to 'prompt' to make more obvious the MonadPrompt connection
08:54:59 <nand`> but ‘procedure’ is good too
08:55:05 <quuuux> AIUI, 'delegate' is a useful technical term, particularly when talking about prototype-based OOP
08:55:10 <Springwight> The reason being, one of the points of OO is not to allow too much mishmash with the internals of a class
08:55:30 <quuuux> of course, every useful technical term will eventually be co-opted in the great game of buzzword bingo
08:55:37 <Springwight> Allowing a class to support unknown operations is kind of like making private members public
08:55:44 <Springwight> since in OO state is mutable
08:55:53 <Springwight> (that is, in many OO languages)
08:56:07 <Cale> I'm fairly opinionated when it comes to what OO is about and what is wrong with most typed OO languages though.
08:56:20 <Springwight> mutation?
08:56:47 <Cale> Actually no, there's something even more fundamentally wrong with how typed OO languages have failed to capture what OO is about.
08:56:55 <Cale> Classes contain method implementations.
08:56:56 <Springwight> What is it about?
08:57:01 <Cale> That is what's wrong :)
08:57:06 <Springwight> No, that's right.
08:57:16 <Springwight> What's wrong with that?
08:58:11 <Cale> The point of objects is to have these values whose identity corresponds to the manner in which they respond to messages. The type of an object is morally just which messages it is capable of dealing with and responding to, and the types of its responses.
08:58:22 <Springwight> That's the interface.
08:58:34 <maukd> the interface is the type
08:58:42 <Cale> Classes are types of objects, but they don't just specify an interface, they say how that interface is implemented.
08:59:00 <Cale> and that's a mistake -- the implementation of the interface should be part of the value, not part of the type
08:59:21 <Springwight> OO guidelines generally state that you should use Interfaces instead of concrete Classes at all times.
08:59:22 <Cale> When you *construct* an object of a given type, you should provide that implementation.
08:59:25 <Springwight> You deal a lot with interfaces.
08:59:37 <Springwight> Languages support them.
08:59:38 <danharaj> edwardk: prompt is shorter so ostensibly it would be a net improvement :P I will try this strategy for Async behavior after lunch.
08:59:38 <Cale> Yes, that's because everyone is slowly coming to agree with me :)
08:59:43 <danharaj> edwardk:  My use case is having two sources for game input: a source of input driven by an external library and a source for time that ticks every t seconds. I'd like the game to be driven by asking for Either and servicing inputs before ticks.
08:59:52 <Springwight> Cale, I'm sorry, but they've been in there since long ago :P
09:00:01 <Cale> But what I'm saying is that we shouldn't have classes like we do at all
09:00:10 <Cale> We should *only* have those interfaces.
09:00:55 <edwardk> danharaj: *nods* note, you don't need to put your custom input types directly into machines for them to be usable. I have some funny ones I'm using here that don't really generalize, and so I haven't loaded them into the machines codebase
09:00:56 <Cale> and the fundamental way in which you construct a value of a given object type is to provide implementations for the methods
09:01:00 <Springwight> We should have classes to a limited extent. Using the scheme you're proposing, there would have to be a way to define ad-hoc interfaces with default implementations that are essentially classes.
09:01:19 <Springwight> Because it's just a lot of fuss if you want to write a bit of code
09:01:23 <Springwight> check out how objects mingle
09:01:53 <Cale> Well, the author of the class can just provide a value which has the default implementations, if there is such a natural one
09:02:06 <Cale> right?
09:02:13 <Cale> And that can be separate from the class itself
09:02:28 <Cale> also: fuck subtyping :)
09:02:34 <Cale> and inheritance
09:02:37 <Springwight> uhhhh
09:02:43 <Springwight> now
09:02:45 <Springwight> that's not right
09:02:49 <Cale> Oh?
09:02:57 <Cale> Why do we need them anymore?
09:03:02 <Cale> We have interfaces!
09:03:17 <Springwight> That's not enough.
09:03:26 <Cale> You'd be surprised :)
09:03:38 <Springwight> There's such a thing as DictionaryBase for example. it defines certain operations on the internal state of the object.
09:03:45 <otters> so use class constraints
09:03:46 <Springwight> You can then extend this definition by writing your own code
09:04:02 <Springwight> By overriding specific methods.
09:04:06 <Cale> The main reason we make subclasses is to reimplement the methods of the base class.
09:04:09 <Cale> yes?
09:04:22 <Springwight> to extend its functionality
09:04:25 <Cale> I'm saying, just make those new objects, instead of new classes.
09:04:27 <Springwight> in general
09:04:30 <Springwight> urm
09:04:51 <yitz> Cale: and to get hierarchical namespaces
09:05:00 <Cale> There *are* things that this won't give you.
09:05:22 <Cale> But it will largely improve the situation.
09:05:48 <Cale> You can do hierarchical namespacing in some other way.
09:06:43 <Cale> Why doesn't everyone do this? Because no first class methods.
09:07:03 <doomlord> i like the way 'go' does things
09:07:13 <doomlord> classes are over-rated
09:07:20 <Cale> In the old days, we weren't good at implementing functional languages, and having vtables was fast.
09:07:26 <Cale> That's the only reason things are like this.
09:07:29 <Springwight> Go is pointless :P
09:07:45 <Springwight> It just doesn't have anything interesting
09:08:25 <Cale> Yeah, Go is essentially 40 years old out of the door.
09:08:26 <doomlord> which other language has exactly the same specific blend of features
09:08:36 <Springwight> huh
09:08:37 <Springwight> what features
09:08:44 <Cale> doomlord: Have you seen the comparison with Algol 68?
09:09:09 <Springwight> You can say that about Scala. You can say that about haskell. Also about F#.
09:09:11 <doomlord> does algol 68 have goroutines
09:09:50 * hackagebot data-dword 0.1 - Stick two binary words together to get a bigger one  http://hackage.haskell.org/package/data-dword-0.1 (MikhailVorozhtsov)
09:10:04 <doomlord> indeed, each language has a specific blend. With some tools common (eg LLVM, JVM) its good that implementors try different blends.
09:10:07 <Springwight> Java and .net have constructs like that.
09:10:42 <doomlord> but java puts everything in class heirachies
09:10:43 <Cale> doomlord: Well, it has concurrency support. The language spec didn't really say anything about the mechanism, but there are implementations with channels.
09:11:05 <tac> I wish there was a crash course on "concepts of compiler optimizations"
09:11:47 <Springwight> .NET has syntactic sugar. F# is good with it.
09:11:51 <Cale> doomlord: and of course, Haskell's concurrency makes everything that Go has in that department seem really boring.
09:11:58 <Springwight> :P
09:12:10 <doomlord> I'm not sure the language I want exists yet. The features I want are out there in different languages.. showing its possible, but they've not been blended exactly how i'd want them yet
09:12:27 <doomlord> go was interesting to me as it ticked a lot of boxes. of course it still isn't perfect
09:13:10 <Springwight> Scala is very interesting.
09:13:11 <Cale> For a good while after I learned Haskell, I thought about how it might be nice to take some of the features of Haskell and put them into an imperative language, but then I realised that the language I was designing was Haskell.
09:13:13 <Springwight> Traits are awesome.
09:13:13 <Cale> lol
09:13:15 <doomlord> haskell is certainly important but it isn't perfect.
09:13:18 <Puffton> How do you guys think Haskell compares to other functional languages in terms of general performance?
09:13:36 <Cale> Puffton: It does fairly well. GHC is a good implementation.
09:14:01 * tac still doesn't fully understand why lazy evaluation is ever useful
09:14:08 <Springwight> huh
09:14:12 <Cale> doomlord: Haskell isn't perfect, but the improvements I'd like to see are all things which are still research problems, for the most part.
09:14:22 <tac> As far as I can tell, it's for increasing the base salary for Haskell developers
09:14:23 <Springwight> with or without memoization?
09:14:26 <quuuux> my hope for Go is that it cannibalises a significant chunk of C/C++'s current domain, and doesn't really expand to other languages' domains
09:14:32 <Cale> With the possible exception of stealing the module system of OCaml/SML
09:14:38 <quuuux> I'm worried that that's not going to happen though :(
09:14:51 <tac> Cale: You've seen the copatterns paper, right?
09:14:52 <c_wraith> tac: lazy evaluation is great for eliminating boundary conditions from your code
09:14:56 <Springwight> what, all sorts of laziness? even stuff like streams/iterators?
09:14:56 <doomlord> suppsedly c/c++ programmers aren't moving to go, but people are moving from scripting langauges
09:14:57 <quuuux> c.f., Java's tentacles expanding into everything in the 1990s
09:15:15 <Puffton> Springwight, but F# isn't purely functional though, right? Played with it today a little and it doesn't seem to have many immutables :p
09:15:35 <Springwight> F# is immutable by default.
09:15:38 <tac> c_wraith: What do you mean by boundary condition?
09:15:55 <doomlord> syntax might seem less important but some of haskell's syntax choices are a bit off, IMO. (i can see past that of course.. but it does still irritate me a little)
09:16:08 <Springwight> It supports imperative programming but F# encourages you to do it functionally.
09:16:11 <c_wraith> tac: I recently ported some terrible php code to haskell.  One of the steps involved custom base64 conversion.  The php code for it was littered with conditionals for having reached the end of the input.  Like, every other line was an extra check for end-of-input.
09:16:16 <Puffton> Springwight, but you can change elements in a list, or do let k = 5, let k = 6, let k = 7 etc.
09:16:24 <Cale> tac: Rather than generating all the things of up to some limited size which you have to know ahead of time, and then being careful not to ever need to go over, you can just make a structure of *all* the things.
09:16:35 <Cale> tac: and only use what you need
09:16:43 <c_wraith> tac: the haskell code ended up having zero checks for end of input. I just padded the input to infinite length, then took only as much output as was needed.
09:16:56 <Springwight> It depends on the object. Objects live in .NET. .NET itself supports mutability and immutability.
09:17:04 <tac> fmmm
09:17:04 <Springwight> The F# default list construct is immutable.
09:17:13 <Springwight> let bindings are immutable by default
09:17:31 <tac> I'd rather have a better understanding of the theory of codata :)
09:17:31 <augur> tac: are you 1/4 of a giant
09:17:45 <Springwight> System.Collections.Generic.List<T> is a mutable collection. map or FSharpMap is not.
09:17:48 <augur> tac: read about coalgebras!
09:17:55 <doomlord> i'd like to see languages that try the other ways of controlling side effects, "linear types" etc. also you can have a pure function that looks imperative internally (assignment is just reusing a symbol)
09:18:02 <doomlord> still, I am enjoying haskell.
09:18:03 <augur> tac: there are some good tutorials on (co)algebras
09:18:07 <Springwight> But F# has many problems, especially with recursion.
09:18:15 <Springwight> there is no stream fusion
09:18:26 <doomlord> whats stream fusion.
09:18:30 <maukd> does anyone here have a machine to run preflex on?
09:18:30 <Springwight> so if you iterate
09:18:38 <Springwight> you get a shitton of allocations.
09:18:43 <tac> stream fusion is an optimizer's dream come true.
09:19:04 <doomlord> suecession of maps / filters fused into one operation ?
09:19:08 <doomlord> oe something else
09:20:12 <doomlord> lazy eval makes haskell better at composing functional constructs, right ?
09:20:27 <doomlord> <better than others>
09:21:30 <doomlord> do haskellers always avoid something like F#'s  |>  .. or is there an operator like that
09:22:00 <c_wraith> well.  $ is kind of like it, but doesn't involve flipping your logic around.
09:22:36 <Springwight> |> doesn't flip logic around :P it's perfectly logical for inner-first evaluation.
09:22:54 <c_wraith> f(g(x)) -> x |> g |> f
09:22:55 <doomlord> matter of preference :)  |> is logical to me. you write a sequence of what actually happens, in order
09:22:59 <c_wraith> that looks flipped around to me
09:23:23 <Springwight> oh, that? That's not flipped at all. That's exactly right.
09:23:29 <Springwight> x goes to g goes to f
09:23:32 <doomlord> +1
09:23:33 <Springwight> perfectly comprehensible
09:23:48 <c_wraith> if you don't mind throwing out all of math, sure
09:24:02 <doomlord> how is any math thrown out?
09:24:14 <b__> math notation?
09:24:15 <c_wraith> f(g(x)).  standard math notation
09:24:18 <Springwight> In math you can evaluate inner-first as well as outer-first.
09:24:18 <quuuux> :t (>>>)
09:24:19 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
09:24:28 <c_wraith> note the order of the symbols
09:24:44 <doomlord> yeah but coding isn't math. its mathematical sure. but some think in terms of pipelines. building machines :)
09:25:04 <maukd> g |> isn't a pipeline
09:25:05 <c_wraith> Or you can think in terms of math, and use everything math has done in the last 5000 years
09:25:08 <maukd> f . g is
09:25:14 <Springwight> pipelines make more sense because they describe how a computation occurs, left to right.
09:25:18 <doomlord> 5000 years ago they didn't have computers
09:25:23 <Springwight> that's composition
09:25:35 <c_wraith> yet they still had math.  and they still did stuff with it.
09:25:46 <Springwight> huh
09:25:53 <c_wraith> And throwing that out just because we have automated computation seems short-sighted
09:25:54 <doomlord> there are many notations in math
09:26:11 <doomlord> some suit different situations better
09:26:38 <Springwight> you can define |> in math just as easily as in F# :P probably more so
09:26:50 <doomlord> i definitely find |>  and clojures' -> very natural constructs to use
09:27:07 <b__> haskell has <-
09:27:08 <merijn> I think you mean closures? Clojure is a language :p
09:27:16 <b__> >>= etc
09:27:19 <doomlord> similarly c++    blah.doSomething().somethingElse().somethignElse() but i dont like c++ classes
09:27:23 <Springwight> Clojures' yes
09:27:27 <Springwight> that of clojure
09:27:38 <dolio> Why would x |> g |> f evaluate x first?
09:27:56 <Springwight> because that would be inner-first evaluation.
09:28:15 <doomlord> look... you can say its not your preference to write x |> g |> f ... but you cant say its wrong. Its just preference. And for some tasks, it IS more natural.
09:28:15 <dolio> Why would that notation have anything to do with inner-most first evaluation?
09:28:29 <dolio> Why would you expect your notation to correpond to evaluation order?
09:28:32 <hpaste> newbiee pasted “error in hug” at http://hpaste.org/76034
09:28:53 <Springwight> well I guess it makes no sense, you're right
09:29:00 <Springwight> I was so silly
09:29:02 <Springwight> ah well
09:29:03 <doomlord> if you draw the operation as a pipeline - which is often used to explain functoins to non-programmers - you'd have arrows and boxes looking much more like x |> g |> f
09:29:31 <maukd> newbiee: that is not "the code"
09:30:05 <shachaf> "27 8×10 color glossy pictures with circles and arrows and a paragraph on the back of each one explaining what each one was to be used as evidence against us"
09:30:16 <yitz> doomlord: explaining functions as pipelines to non-programmers is doing them a very big disservice. that's not what functions are.
09:30:25 <maukd> doomlord: not quite. you can extract subdiagrams from the diagram, but you can't extract g |> f from x |> g |> f
09:30:35 <shachaf> yitz: Yes, functions are sets of ordered pairs!
09:30:36 <newbiee> maukd what do you mean?
09:30:47 <maukd> newbiee: Token and getType are undeclared
09:30:53 <dolio> shachaf: Go sit on the group w bench.
09:30:57 <yitz> shachaf: not usually very useful, but at least true.
09:31:27 <newbiee> I declared them both already, that's why there is no error of undeclared type when compile
09:31:37 <maukd> newbiee: yes, but you didn't paste them
09:31:42 <Saizan> shachaf: not just any set of ordered pairs though!
09:31:46 <shachaf> yitz: I don't know what "pipeline" means, so I can't tell you whether a function is a pipeline or not. But it sounds plausible.
09:31:50 <Springwight> you could extract g |> f theoretically. it would be composition.
09:31:55 <newbiee> ok let me paste them too
09:31:58 <doomlord> a lot of programming makes sense as pipelines. and people read left to right. Note, i'm not claiming "its better". I'm just saying it definitely suits me. I have studied maths, I dont see a need to write all code like maths.
09:32:20 <Springwight> x |> (g >> f)
09:32:42 <maukd> > (g >>> f) x
09:32:43 <nand`> Saizan: if you include partial and nondeterministic functions, doesn't that extend it to any set of ordered pairs?
09:32:44 <lambdabot>   Ambiguous type variable `b' in the constraints:
09:32:44 <lambdabot>    `SimpleReflect.FromExpr ...
09:32:55 <hpaste> newbiee pasted “error in hug” at http://hpaste.org/76035
09:33:12 <maukd> newbiee: the program is called "hugs", not "hug"
09:33:40 <newbiee> i know :)
09:33:56 <maukd> newbiee: your Show instance is doubly broken
09:34:03 <maukd> 1) the indentation is wrong
09:34:07 <maukd> 2) show is not a member of Show
09:34:30 <shachaf> maukd: Yes it is.
09:34:32 <nand`> re 2) I thought it is?
09:34:34 <shachaf> (To 2.)
09:34:34 <doomlord> its quite possible to define a |> for haskell isn't it.. but that symbol is already taken, right
09:34:36 <nand`> I can define an instance Show a where show ...
09:34:38 <Saizan> nand`: i.e. relations correspond to relations? yes :)
09:34:41 <maukd> oops
09:34:46 <shachaf> On the other hand, read is not a member of Read.
09:34:56 <danharaj> :t read
09:34:58 <lambdabot> forall a. (Read a) => String -> a
09:35:05 <maukd> I'm wrong
09:35:06 <danharaj> close enough
09:35:16 <maukd> your Show instance is only singly broken
09:35:45 <shachaf> Hmm, I just made runghc stack-overflow.
09:35:59 <shachaf> Oh, no I didn't.
09:37:34 <nooodl> i don't see why you can't extract (g |> f)
09:37:55 <nooodl> oh wait, nevermind
09:38:02 <maukd> because it's f $ g
09:38:20 <fmap> i thought |> is only useful because f# doesn't have proper type-inference
09:38:21 <doomlord> is the symbol $> taken :)
09:38:33 <maukd> @hoogle ($>)
09:38:34 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
09:38:34 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
09:38:34 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
09:38:46 <maukd> @hoogle (<$)
09:38:46 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
09:38:46 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
09:38:46 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
09:38:47 <doomlord> |> is useful because many people think like that. Pipelines of operations. start to finish
09:39:03 <Springwight> it's also good at dis-ambiguiating type inference.
09:39:04 <fmap> in lazy language that would be backwards?
09:39:07 <nooodl> well, isn't that a bit like saying (x $ y $ z) is bad because you can't extract the (x $ y) part
09:39:08 <Springwight> it sucks.
09:39:33 <dolio> nooodl: Yes.
09:39:44 <scp> hi everybody
09:39:45 <fmap> i.e. in `f . g . h' `f' is evaluated first
09:39:45 <maukd> nooodl: it's exactly like that
09:40:04 <shachaf> How do I extract the eye from the IO the tiger?
09:40:05 <scp> I'm trying to write a simple compiler in haskell
09:40:14 <scp> and I find myself using monads a ton, my code looks _almost_ procedural
09:40:16 <scp> is this bad
09:40:17 <scp> ?
09:40:24 <nooodl> oh wait, you weren't making a point against |> there. oops
09:40:36 <maukd> I wasn't?
09:40:46 <shachaf> scp: Does it express what you want to express?
09:40:48 <dolio> I do say that 'f $ g $ x' is undesirable.
09:40:55 <doomlord> if i've understood lazy evaluation,   f.g.h  is more like f TRIES  to evaluate first, then goes on to get its dependancies until it gets to h :)
09:41:04 <nooodl> well, not a point against |> that tells people to use $ instead
09:41:06 <c_wraith> doomlord: it may never need h
09:41:13 <c_wraith> doomlord: that's an important consideration
09:41:24 <scp> shachaf: yes, but I'm using this compiler as a way to learn haskell, so I'd like to be doing things the "haskell way"
09:41:49 <shachaf> scp: "procedural-looking" can mean a lot of things.
09:42:23 <scp> shachaf: Most of the business of the code takes place in 'do' blocks
09:42:40 <nand`> > do (do 1) + (do 2)
09:42:41 <lambdabot>   3
09:42:42 <nand`> like that?
09:43:10 <c_wraith> > do do do do do do do do do 3
09:43:11 <lambdabot>   can't find file: L.hs
09:43:15 <c_wraith> uh
09:43:20 <nooodl> > let x |> f = f x in   [0..4] |> map (2^) |> tail |> reverse
09:43:22 <lambdabot>   [16,8,4,2]
09:43:27 <nooodl> this actually doesn't look too bad to me
09:43:42 <nand`> Control.Lens has (%) for that, fwiw
09:43:49 <nand`> which comes in handy at times
09:43:51 <nooodl> (maybe slightly forth-y)
09:44:07 <maukd> > let (.) = flip id in [0..4].map(2^).tail.reverse
09:44:10 <lambdabot>   [16,8,4,2]
09:44:13 <maukd> javascript!
09:44:31 <nand`> looks more like ruby
09:44:32 <nooodl> that looks a lot like ruby
09:44:33 <nooodl> yes
09:44:49 <quuuux> brb, writing brainfuck with operators
09:44:50 <nooodl> now we need map {|x| f x} blocks
09:45:11 <nand`> (\x-> f x) comes reasonably close
09:45:22 <atriq> I wonder what the most ridiculous Monad Transformer stack ever seriously used is
09:45:46 <dustingetz> atriq: the "monad transformers and modular interpreters" is pretty nifty
09:46:00 <scp> I guess I should mention I am using the State monad a lot, so I basically end up defining a few variables and then manipulating them. It's a compiler so I'm doing a lot of transformations on trees
09:46:00 <dustingetz> *paper
09:46:25 <dustingetz> http://haskell.cs.yale.edu/wp-content/uploads/2011/02/POPL96-Modular-interpreters.pdf
09:46:50 <c_wraith> scp: I hear that attribute grammars are specifically designed for describing those kinds of transformations in more declarative ways.  But I've never actually used them
09:47:00 <atriq> I think I've used MaybeT (StateT Integer IO)
09:47:23 <nand`> I've used RWST IO
09:47:31 <maukd> @unmtl MaybeT (StateT Integer IO)
09:47:31 <lambdabot> Plugin `unmtl' failed with: `MaybeT (StateT Integer IO)' is not applied to enough arguments, giving `/\A. Integer -> IO (Maybe A, Integer)'
09:47:39 <maukd> @unmtl MaybeT (StateT Integer IO) a
09:47:39 <lambdabot> Integer -> IO (Maybe a, Integer)
09:47:43 <nand`> (I left out the first three parameters to RWST)
09:48:53 <scp> c_wraith: yacc is more or less what attribute grammars are all about
09:49:48 <doomlord> left-to-right is handy with IDE's , typing something out... you want a value burried in some datastructure, you type the parent , press '.' and you get a list of options where the thing you want might be.. and drill down sucessively. This is an example of left-to-right matching how some people think
09:49:51 * hackagebot murder 1.3.1 - MUtually Recursive Definitions Explicitly Represented  http://hackage.haskell.org/package/murder-1.3.1 (MarcosViera)
09:50:10 <c_wraith> scp: hmm.  I've used yacc.  It feels to ad-hoc to be a good example of anything. :)
09:50:13 <nand`> doomlord: I want an IDE with tab completion on lenses now
09:50:20 <nand`> or traversals
09:50:28 <c_wraith> *too
09:51:05 <doomlord> a lot of programming is hunting through libraries.. tools like that are really useful. (on that note haskell's type based search is pretty neat)
09:53:09 <Saizan> it works just as well starting from the type of the result
09:53:34 <Saizan> even prolog does backchaining :)
09:53:35 <doomlord> but with type inference you dont type the type of the result in the editor :)
09:53:47 <c_wraith> You can soon
09:53:54 <nand`> I type the type of the function before I type the function
09:53:55 <c_wraith> ghc now has support for holes in head
09:54:09 <tac> Scumbag Haskell tooling // Most powerful static type system in the world // No useful autocomplete
09:54:14 <doomlord> mesh.getShape(1).getVertex(2).getChannel(POSITION).getComponent(1)   .. i know what iwant is in "mesh", i drill down..
09:54:25 <maukd> c_wraith: I need that like I need holes in the head
09:54:26 <doomlord> and the IDE tells me whats there at each stage if i forgot
09:54:36 <Saizan> doomlord: with type inference you don't type the type of the argument either
09:54:43 <Saizan> doomlord: it's all inferred :)
09:54:54 <doomlord> i like type inference its awesome.
09:55:13 <scp> ok, here is a better statement of my question: With haskell, is it common to use the State monad _everywhere_?
09:55:24 <dustingetz> no
09:55:28 <scp> or is that the sign of a poorly-adjusted C programmer
09:55:35 <dustingetz> yes
09:55:37 <nand`> I try to avoid the state monad
09:55:46 <nand`> except where I want to model sequential state transitions
09:55:57 <shachaf> nand`: Even there, State isn't always what you want.
09:56:02 <quuuux> scp: on larger things, it tends to get that way, but that's not necessarily a good thing
09:56:03 <shachaf> For example, you might want a fold.
09:56:03 <c_wraith> I need something strange to be going on to use State
09:56:03 <Eduard_Munteanu> Use Reader if you want to propagate some environment around.
09:56:10 <doomlord> i avoid the state monad beause i dont get it yet lol.
09:56:11 <c_wraith> like, non-linear transitions
09:56:13 <shachaf> scp: Your question is probably too vague to answer without code.
09:56:18 <c_wraith> err, non-linear control flow
09:56:31 <c_wraith> if I have linear control flow, a fold is easier
09:56:36 <c_wraith> things like that
09:56:51 <nand`> yeah, I guess that's what I meant
09:57:01 <doomlord> will my haskell programs suck if i only use the IO monad, an NO state monads
09:57:07 <hiptobecubic> yes
09:57:19 <nand`> basically, when my state transitions have to be monads
09:57:36 <shachaf> "be monads"? What does that mean?
09:58:25 <tac> doomlord: no, not really. But you'll get a lot of hassle from this channel :P
09:58:27 <nand`> shachaf: well, when the result of one state-modifying operation is needed to determine what the next operations will be
09:58:43 <atriq> To be simply monoids in the category of endofunctors, of course.
09:58:43 <atriq> :P
09:59:06 <tac> Keeping everything in IO is no worse than writing a program in any other language. All Java/PHP/C code is as if it lived entirely in the IO monad.
09:59:10 <doomlord> heh monads make you write things left to write at least, >>= :)
09:59:27 <maukd> :t (=<<)
09:59:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
09:59:29 <nand`> in other words, when I need something like Op a -> (a -> Op b) -> Op b
09:59:32 <tac> maukd: beat me to it
09:59:36 <Philonous> doomlord:  You don't need the state monad. You can thread all your state through your program by hand.
09:59:36 <doomlord> heh. keeping everything in IO one still gets a language with awesome type inference
09:59:47 <elliott> maukd: are you mauke
09:59:53 <Philonous> doomlord:  Yes, Haskell is a great imperative language
10:00:06 <djahandarie> :t (($), (=<<))
10:00:07 <tac> doomlord: yep. The only thing you lose are static guarantees.
10:00:07 <lambdabot> forall a b a1 (m :: * -> *) b1. (Monad m) => ((a -> b) -> a -> b, (a1 -> m b1) -> m a1 -> m b1)
10:00:11 <nand`> https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs
10:00:23 <tac> and you can't actually *run* IO objects in pure code.
10:00:23 <Eduard_Munteanu> Which reminds me... how much of arrows does Bikleisli subsume? Presumably not all of them, but is it an important class of arrows?
10:00:32 <tac> So a lot of std lib stuff isn't so great
10:00:58 <Eduard_Munteanu> That is, monad + comonad + distributivity law.
10:01:20 <doomlord> i think i'd only really get the state monad if i built it myself at least once
10:01:28 <doomlord> and felt the need to do it
10:01:28 <nand`> that's a good approach
10:01:49 <dustingetz> doomlord: i grokked the state monad by writing it in python
10:01:52 <dustingetz> maybe this will help you
10:01:53 <dustingetz> http://www.dustingetz.com/2012/10/02/reader-writer-state-monad-in-python.html
10:01:55 <dustingetz> (maybe not)
10:02:06 <doomlord> Maybe ()
10:02:24 <tac> monads don't belong in impure languages.
10:02:38 <dustingetz> i agree with tac
10:02:40 <tac> well, state, reader and writer certainly don't
10:02:41 <dustingetz> its academic
10:02:41 <Eduard_Munteanu> tac: IMO they do, depending on the language.
10:02:43 <nand`> disagree
10:02:47 <Eduard_Munteanu> Erlang for example.
10:02:51 <nand`> you can write pure code in many impure languages
10:02:55 <doomlord> +1
10:03:04 <dustingetz> you need expression oriented language for monads to be nice to use
10:03:13 <dustingetz> and expression oriented basically means functional
10:03:13 <tac> "nice"
10:03:38 <doomlord> optimizing compilers extract pure code from impure code ..
10:03:43 <doomlord> SSA
10:04:18 <Eduard_Munteanu> Single assignment isn't quite purity.
10:04:34 <scp> ya, SSA can still write to a pointer o_O
10:04:36 <Eduard_Munteanu> Erlang again.
10:04:41 <doomlord> the compiler needs to extract a pure subset for instruction scheduling.
10:04:54 <tac> Monads in non-Haskell languages remind me of the episode of Futurama where a group of hippies is trying to make the argument that you shouldn't eat meat. Their "evidence" of this is a lion they taught to eat tofu.
10:05:01 <hpaste> newbiee pasted “recursive function” at http://hpaste.org/76036
10:05:02 <doomlord> it needs to know where the side effects are, those are barriers for re-ordering instructions
10:05:14 <tac> The lion is sickly, but yet, the hippies had a point -- it hadn't died eating only tofu :)
10:05:22 <doomlord> the rest of the time it will shift instructions around all over the place to parallelize
10:05:39 <scp> ah, I see what you mean by 'extracts' now
10:06:31 <nand`> doomlord: all you need to commute functions is for their side effects to be independent
10:06:36 <doomlord> thats why i think 'expression oriented' and 'statements' needn't be such a hard dividing line
10:06:37 <nand`> not for them to have no side effects
10:06:48 <nand`> eg. var a, b;  a = 3; b = 5 -- I can reorder these two assignments without changing semantics
10:07:03 <nand`> s/functions/operations
10:07:17 <doomlord> well  , if you consider registers as being renamed and the real values as being abstract, its pure..
10:07:23 <doomlord> which is why they invented SSA :)
10:07:29 <doomlord> (probably)
10:08:20 <newbiee> can anyone look at my post 76036 and give me some pointer?
10:08:54 <doomlord> var a,b; a=3; b=5; ... what you really have there is two declarations with no side-effects, just unoptimized :)  those values haven't been drawn from. a modern C++ compiler will emit no code here.
10:09:13 <doomlord> (heh asside from not compiling 'var' )
10:10:01 * ksf thinks SSA is the proof that CPS is the one true programming style
10:10:08 <doomlord> CPS= ?
10:10:14 <scp> doomlord: his argument stands if you have func(a, b) { a = 5; b = 3; return a + b; }
10:10:15 <ksf> continuation passing style
10:10:29 <scp> a and b are still stateful, but reordering them doesn't matter
10:10:30 <doomlord> that'll still be inlined :)
10:10:36 <nand`> I don't remember ever talking about C++, envision my code as some sort of pseudo-machine code
10:10:39 <ksf> both are equivalent, imperative languages usually compile via SSA, functional ones via CPS
10:10:45 <nooodl> newbiee: iterate down the list and keep track of a (Set a) containing items you've already seen
10:11:09 <nand`> cps is doubly trivial, what's the big deal? :P
10:11:15 <nooodl> newbiee: then don't add items to the result if they're already in the set
10:12:02 <newbiee> nooodl thanks.  Can you give me an example?
10:12:54 <nand`> your function is tail recursive though
10:13:07 <doomlord> scp: func(a, b) { a = 5; b = 3; return a + b; }  ...those are only assignments if a and b are references. if they are values passed in... its just like you're relabling what 'a' and 'b' mean. nothing is modified
10:14:43 <scp> So I'm trying to generate SSA from an expression syntax tree. This means taking a binary tree and flattening it to a bunch of statements -- one for each node in the binary tree. Furthermore, each of these nodes needs to have a unique integer associated with it. The only solution I can see in 'functional' style is to pass around a tuple containing 'tree so far' and 'max unique integer so far', to every function.
10:14:50 <scp> (unrelated to above SSA conversation
10:14:51 <scp> )
10:15:21 <scp> this is equivalent to the use of the state monad, is there an advantage to tuple-passing? Should I be thinking outside of the box more?
10:15:41 <scp> s/bunch/list
10:16:06 <nooodl> newbiee: http://codepad.org/jCZgLGSq
10:16:57 <nand`> note that nooodl's removeDup isn't the same function as remDouble
10:17:06 <scp> ugh, I made like 5 typos. Tuple would contain 'list of statements so far', not 'tree so far'
10:17:07 <nand`> different type signatures
10:18:00 <doomlord> anyone here familiar with haskell glut bindings , and know what SettableStaVar does?
10:18:08 <doomlord> anyone here familiar with haskell glut bindings , and know what SettableStateVar does? (typo)
10:18:11 <nooodl> aren't they both Eq a => [a] -> [a]?
10:18:17 <nand`> nooodl: Set requries Ord
10:18:47 <nand`> it builds a tree, which it needs a compare function to do
10:18:54 <nooodl> i see
10:19:25 <nooodl> well, you could easily replace it with a list: Set.empty -> [], member -> elem, insert -> (:)
10:19:49 <kirindave> I need to get better at educational writing.
10:20:01 <kirindave> I am still getting email and tweets with annotations like this: http://pastebin.com/B4wVXh4X
10:20:08 <maukd> The paste B4wVXh4X has been copied to http://hpaste.org/76038
10:20:19 <kirindave> And I dunno how someone could so profoundly miss the main thrust of what I wrote.
10:20:55 <newbiee> nooodl and nand` thank you I kinda get it now, got to digest the code a bit more
10:21:31 <nooodl> "length = length | 100;" uh
10:22:07 <nand`> fizzBuzz x = fromMaybe (show x) $ ["fizz" | x `rem` 3 == 0] <> ["buzz" | x `rem` 5 == 0]
10:22:20 <nand`> easily extensible too
10:22:23 <Lutin`> kirindave: Yeah...
10:22:28 <kirindave> nand` Yeah.
10:22:45 <nand`> you can even generate easily from a [(Integer, String)] via mconcat
10:22:59 * ksf would absolutely factor out the rems.
10:23:07 <int-e> haha
10:23:45 <nand`> ksf: yeah, maybe something like [(a -> Bool, b)] -> a -> Maybe b
10:23:48 <quuuux> I wonder if anyone's written HQ9+B yet
10:23:50 <doomlord> any suggestions for what to call a F# |> alike in haskell :) has anyone already done one.   I was using # as equivalent of other languages subscript operator too.
10:23:50 <nand`> ah, Monoid b =>
10:24:00 <quuuux> an esoteric joke language for the 21st century
10:24:19 <nand`> doomlord: I mentioned earlier, Control.Lens uses %
10:24:28 <nand`> you could just re-use that or give your own the same name
10:25:00 <nooodl> x |$| f -- "it's a pip"
10:25:04 <nooodl> +e
10:25:05 <edwardk> doomlord: % in Control.Lens matches the %~ and %= operators it uses, you can read % as 'mod' from c/c++
10:25:22 <nand`> x % dosomething % dosomethingelse % andanother thing
10:25:34 <nand`> same semantics as:  andanother thing $ dosomethingelse $ dosomething $ x
10:25:46 <doomlord> ok
10:25:53 <edwardk> _2 %~ length $ ("hello, "world")     ==> ("hello",5)
10:26:08 <nand`> ($x)$ dosomething >>> dosomethingelse >>> andanother thing
10:26:10 <nand`> ?
10:26:48 <nooodl> @type (%~)
10:26:50 <lambdabot> Not in scope: `%~'
10:26:54 <nooodl> boo
10:26:55 <edwardk> the precedence of % is such that it binds _just_ a little bit tighter than $. There is also a ^% which matches the precedence of ^.
10:26:56 <nand`> ("hello", "world") % _2 %~ length -- actually looks quite good
10:27:22 <nand`> what's ^% again?
10:27:30 <edwardk> http://ekmett.github.com/lens/Control-Lens-Setter.html#v:-37--126-
10:27:33 <nand`> ah, mine is a type error
10:27:35 <nand`> precedence
10:27:38 <edwardk> nand`: an alias for % with tighter precedence
10:28:16 <edwardk> nand`: >>>  ("hello", "world") % _2 %~ length
10:28:17 <edwardk> ("hello",5)
10:28:18 <edwardk> works fine
10:28:19 <nooodl> thank god lenses are around to convince me i don't actually understand haskell
10:28:44 <nand`> oh
10:28:58 <nand`> I was using Ratio's (%)
10:29:00 <doomlord> ( ("hello","world").at(2).length() :) ... what i liked in go is you can define free functions to look like members, for those who say go is useless)
10:29:01 <nand`> no wonder
10:29:03 <edwardk> % has really low precedence. ^% has really high precedence
10:29:42 <edwardk> thats ("hello","world")^._2.to length  in lens parlance ;)
10:29:45 <ZULTRAMAN> Do % and $ really serve to make code that much more readable?
10:30:00 <scp> > :t %
10:30:01 <lambdabot>   <no location info>: parse error on input `:'
10:30:02 <doomlord> i think its highly debateable!
10:30:04 <nooodl> $ sure, % maybe
10:30:23 <doomlord> $ is not readable to a newcomer. i admit its pleasant to type.
10:30:25 <ZULTRAMAN> I dunno, I like brackets more.
10:30:31 <edwardk> ZULTRAMAN: consider foo % bar .~ 12 % baz .~ 10.   without % or $ you'd have to section the operator or use .'s
10:30:31 <Lutin`> I love $
10:30:51 <nooodl> (f (g (h (i (j x))))) < (f $ g $ h $ i $ j x)
10:30:52 <nand`> zipper ("hello", "world") % down _2 % focus %~ length % rezip -- for zipper silliness
10:31:01 <Lutin`> What nooodl sed
10:31:08 <edwardk> nand`: yeah that was a big part of why i added % to the package ;)
10:31:15 <nooodl> $ is super readable if you ignore it
10:31:24 <hpaste> newbiee pasted “recursive function” at http://hpaste.org/76039
10:31:25 <nand`> f . g . h . i . j $ x
10:31:28 <edwardk> nand`: sadly i don't have type changing zippers so the length example doesn't work ;)
10:31:38 <ZULTRAMAN> nooodl, I find the first form orders of magnitude more readable honestly.
10:31:44 <ZULTRAMAN> It's immediately clear what it deos to me at least.
10:31:44 <nand`> oh; focus is a simple lens
10:31:56 <nooodl> how about nand`'s answer
10:31:57 <newbiee> nooodl i try out your code but the type does not match
10:31:57 <edwardk> nand`: i couldn't do traversals otherwise
10:32:00 <doomlord> clojure (->> x j i h g f)
10:32:03 <nand`> I saw that it's indexed by the tape, is there an example that uses this indexing to do something useful?
10:32:11 <nand`> edwardk: yeah makes sense
10:32:20 <nand`> edwardk: otherwise how would you modify the type of a single focused element of a list
10:32:21 <doomlord> go:   x.j().i().h().g().f()
10:32:23 <Lutin`> ZULTRAMAN: What about (f (g (h (i (j x)))), anything wrong with that?
10:32:28 <edwardk> nand`: yep
10:32:29 <nand`> Lutin`: )))))
10:32:38 <Lutin`> nand`: Shut yer yap
10:32:43 <ZULTRAMAN> Lutin`, misses a ) obviously.
10:32:44 <nand`> this ain't lisp
10:32:46 <ski> Lutin` : it's fine
10:32:48 <edwardk> nand`: i could expose the entire traversal and let you do some comonadic transformations on it, but its messy
10:32:55 <nooodl> newbiee: how're you calling it
10:32:59 <ZULTRAMAN> 5 on one side, 4 on he other.
10:33:07 <nooodl> (that is, which arguments are you passing in)
10:33:12 <ski> Lutin` : i would perhaps have written `(f . g . h . i . j) x', though
10:33:14 <Lutin`> And you had to count them somewhat?
10:33:22 <newbiee> nooodl I have not call it yet, it gave me that error at compile
10:33:34 <Lutin`> I was just trying to point out that having that many parens turns into bookkeeping
10:33:36 <edwardk> nand`: erm whats indexed by the tape?
10:33:39 <edwardk> the zipper?
10:33:44 <nooodl> oh
10:33:45 <ZULTRAMAN> Annywy, you can always use compose in that sense of course.
10:33:53 <nand`> edwardk: focus
10:34:00 <nooodl> :: Eq a => [a] -> [a] is wrong; that's for removeDup, not removeDupI
10:34:08 <ZULTRAMAN> ((c f g h  j) x) is surely the most readable anyway.
10:34:10 <nand`> SimpleIndexedLens (Tape (h :> a)) (h ;> a) a
10:34:15 <nand`> :> even
10:34:24 <edwardk> oh, yeah i forgot i added that =)
10:34:32 <doomlord> lisp syntax is pleasing if you're jumping between languages.. not much to remember to read it.
10:34:37 <nooodl> newbiee: change it to ":: Eq a => [a] -> [a] -> [a]"
10:34:52 <Lutin`> I wanted to try clojure but I can't do lisp syntax
10:34:52 <edwardk> its kind of convenient if you want to store something related to the path in the structure, or record the path for later use
10:35:05 <Lutin`> I have nightmares about forgetting a paren
10:35:24 <doomlord> most editors highlight it well
10:35:42 <edwardk> Lutin`: those errors are quickly resolved for the most part
10:35:54 <edwardk> Lutin`: its the bad assumptions about types that get you ;)
10:36:02 <ski> nooodl : hm, not `Eq a => Set a -> [a] -> [a]' ?
10:36:14 <edwardk> ill be at racketcon this weekend, in case there are any schemers in the audience ;)
10:36:23 <Lutin`> edwardk: I didn't like (+ 1 2 3 ...)
10:36:34 <nooodl> ski: used to be (Set a), now it's a [a] -- Sets require Ord
10:36:41 <doomlord> i can handle prefix maths fine. What i miss in lisp is subscript operator, object.component
10:36:47 <nooodl> while a nub function shouldn't
10:36:52 <ski> Lutin` : if you intent properly, and let your $EDITOR match brackets, it shouldn't be a problem
10:36:57 <edwardk> Lutin`: i'm not a huge fan myself, just mentioning the forgotten paren thing isn't really a problem in practice
10:37:08 <ZULTRAMAN> You're basically doing lisp for the syntax honestly. THere are a lot of scemes to translate lisps to curly braces languages or whatever
10:37:15 <edwardk> in haskell i quest to eliminate parentheses everywhere i see them
10:37:18 <ski> nooodl : ah
10:37:23 <edwardk> when writing scheme i'm much more tolerant of them obviously ;)
10:37:23 <Lutin`> doomlord: Prefix maths is fine, it's the arbitary arguments
10:37:25 <kirindave> Lutin`: Lisp is a whole different experience with emacs+paredit.
10:37:29 <newbiee> noool it's compiled but it now gave an error that it cannon find show function for: *** Expression : removeDupI [1,2,3,4,3,6,1]
10:37:30 <kirindave> It's like robot vision and robot hands.
10:37:31 <ZULTRAMAN> In haskell I quaest to add them redundently because it makes code clearer.
10:37:49 <nooodl> newbiee: you have to call removeDup, not removeDupI
10:37:58 <kirindave> slurp-sexp and barf-sexp. Dirty sounding functions for incredibly cool code manipulation.
10:38:10 <ski> @karma+ ZULTRAMAN
10:38:10 <lambdabot> ZULTRAMAN's karma raised to 1.
10:38:13 <ski> (for being contrary)
10:38:13 <edwardk> i find prophylactic parentheses to be a sign that the guy writing the code doesn't really understand what he's written
10:38:17 <Lutin`> How in the hell does something redundant make it cleaner what
10:38:56 <newbiee> nooodl gave error: ERROR - Undefined variable "removeDup"
10:38:59 <Lutin`> kirindave: I mean I have my vim, I just gahhh
10:39:04 <ZULTRAMAN> Maybe I should just keep one nick so my karma actually keep accumilating, you gotta store fame and fortune.
10:39:08 <Lutin`> so many parens...
10:39:12 <newbiee> nooodl the function is define as removeDupI
10:39:40 <troydm> after 8 hours of blood tears despair compiling ghc on OpenIndiana
10:39:40 <ZULTRAMAN> map f (x : xs) = (f x) : (map f xs) all he way obviouly.
10:39:54 <troydm> i've SUCCESSEDED !!!!!!!
10:40:13 <edwardk> troydm congratulations. now, the real question is why OpenIndiana?
10:40:27 <troydm> i feel like compiling haskell is more hard than actually learning the language
10:40:28 <ski> edwardk : even `(f a -> b) -> (f c -> d)' kind of redundant brackets ?
10:40:44 <edwardk> ski: especially those
10:41:02 <troydm> edwardk: becoz this machine is on OpenIndiana
10:41:12 <ZULTRAMAN> edwardk, how about using mnemonic identifiers?
10:41:22 <rwbarton> didn't take very long to find an example of that at http://hackage.haskell.org/package/lens
10:41:25 <ZULTRAMAN> Why not just name all functions a, b, , c d e f.
10:41:30 <troydm> maybe someday i'll migrate to FreeBSD since it supports ZFS
10:41:33 <ZULTRAMAN> I mean, surely if you understand what's writte?
10:41:57 <ski> ZULTRAMAN : depends on how large scope it lives in, and how concrete a role it has
10:42:02 <ZULTRAMAN> I mean, why would you use if (cond) { only-a-single-expression;}, does that mean you don't understand that {  and } are optoinal in that case?
10:42:18 <edwardk> ZULTRAMAN: i can somewhat understand using parentheses around operators that don't commonly get used together, but putting ()'s around juxtaposition is silly. f x   ALWAYS binds tighter than any operator you put next to it
10:42:22 <nand`> edwardk: maybe something like where you want to update some item in some nested structure, but the update operation depends on how far you went down? would it be possible to get back the number of traversals since Top from a Tape?
10:42:34 <ZULTRAMAN> ski, that's my point, it makes code clearer, I know that the parethenses are optional, it just makes it immediately clear what the logic is without having to fiddle it out.
10:42:36 <edwardk> map f (x:xs) = f x : map f xs  is a lot less noisy and completely unambiguous
10:42:41 <fmap> speaking about mnemonic identifiers i like (auf, ala) pair from lens
10:42:42 <augur> ski! :o
10:42:43 <scp> ZULTRAMAN: reductio ad absurdum is not a valid method of argument
10:43:00 <maukd> ZULTRAMAN: more parens = harder to parse
10:43:02 <ZULTRAMAN> edwardk, using parentheses makes it immediately clear for me because it visually guides my eyes to the operator.
10:43:04 <edwardk> fmap: i kind of regret renaming au to ala. when it was au, the relation was obvious ;)
10:43:11 <maukd> ZULTRAMAN: your eyes suck
10:43:19 * ski passes scp through a CPS-transformer
10:43:19 <nand`> edwardk: two parens there, what is this nonsense?
10:43:21 <edwardk> ZULTRAMAN: well, i suppose we'll agree to disagree =P
10:43:28 <rwbarton> just write
10:43:35 <rwbarton> map f ((:) x xs) = (:) (f x) (map f xs)
10:43:36 <nand`> map f l = case l of x:xs ...
10:43:42 <nand`> no parens
10:43:44 <rwbarton> problem solved?!
10:43:44 <nand`> 100% improvement
10:43:45 <edwardk> nand`: clearly map f xxs = case xxs of x : xs -> ...
10:43:53 <Lutin`> lol nand`
10:44:05 <edwardk> nand`: whats this, a named temporary!
10:44:11 <nand`> oh
10:44:13 <nand`> I'm so silly
10:44:17 <nand`> map f = case x:xs -> ...
10:44:22 <edwardk> map f = \case x : xs -> f x : map f xs
10:44:25 <nand`> embrace the 7.6.1
10:44:26 <ZULTRAMAN> rwbarton, if you didn't have to put (:) around it I'd find (map f (: x xs)) = (: (f x) (map f xs)) to be clearler honestly.
10:44:31 <nand`> yeah \case
10:44:50 <rwbarton> ZULTRAMAN, it does not come as a surprise to me to learn that you would think that
10:44:55 <edwardk> maukd++
10:45:02 <edwardk> ZULTRAMAN: lisper?
10:45:09 <ZULTRAMAN> rwbarton, how so?
10:45:28 <ZULTRAMAN> edwardk, I wouldn't affiliate myself with any language to that extend, but lisps have an exceptionally clear and easy to read syntax I find.
10:45:38 <maukd> ok, you're crazy
10:45:40 <ZULTRAMAN> It just doesn't make a lot of sense if you don't have variadic functions as a starting point.
10:45:45 <nand`> I think it's funny that all the lispers I see indent their code in blocks
10:45:52 <nand`> why not just make it indentation sensitive
10:45:54 <nand`> and forget all the ))))))))))))))))))))0
10:45:58 <nand`> without the 0, even
10:45:59 <Lutin`> exactly
10:46:06 <doomlord> maybe editors will emerge with some highlighting scheme thatmakes operator binding clearer
10:46:07 <scp> I see no reason to omit the 0
10:46:13 <edwardk> the prefix convention doesn't make sense you mean?
10:46:15 <quuuux> there's a SRFI that does almost exactly that, actually
10:46:23 <rking> nand`: That's true of 100% of languages with ending tokens.
10:46:28 <Lutin`> doomlord: Why does the editor have to make it sane to code in the language?
10:46:37 <Trudko_> guys if i have two lists [2,2] [3,3] and i would like function which takes every element and multiply by every element of other list.
10:46:45 <nand`> most of my lines of C# end with something like ;});}}}
10:46:49 <shachaf> Trudko_: liftM2 (*)
10:46:56 <ski> nand` : "SRFI 49: Indentation-sensitive syntax" by Egil Möller at <http://srfi.schemers.org/srfi-49/srfi-49.html>
10:46:59 <ZULTRAMAN> In lisp it's very common to have a very subjective indentation on a lot of things. I persoally favour writing (if (null? xs) '() \n other-stuff) some people write (if (null? xs) \n '() \n other-stuff)
10:47:00 <rking> nand`: You just tuck them all away into one blob?
10:47:00 <doomlord> Clear code is open to interpretation; assist make it clearer to more people
10:47:00 <edwardk> personally i prefer to work with explicit folds rather than variadic operators. you don't have to worry about which way it is folding, etc.
10:47:26 <nand`> rking: not always
10:47:27 <shachaf> Perl 6 uses the infixity of an operator to decide which way to fold.
10:47:30 <ZULTRAMAN> Any way, I find something as clear as ) to denote the end of some logical unit to be faaaar clearer than trying to reason with spaces.
10:47:35 <edwardk> and once you've limited yourself to binary operators having fixities follows very naturally
10:47:35 <nand`> rking: in extreme cases I'll put spaces between blobs of 4 or 5
10:47:37 <quuuux> I think it's sort of funny how the s-expr versus m-expr discussion never, ever really dies
10:47:42 <rking> ZULTRAMAN: IMO that subjectivity is rarely missed for languages not requiring endings.
10:47:44 <ZULTRAMAN> Like 'Oh, there'san endline here and 2 less spaces than the line above tarted with, that means the block has ended'
10:47:57 <ZULTRAMAN> Instead of jut 'oh, a ), the block has ended'
10:47:58 <nand`> but my editor highlights them as I write them so it's not much of a problem, and I use the indentation when reading, not the braces
10:48:02 <shachaf> ZULTRAMAN: That's why I use 16-space indentation.
10:48:04 <edwardk> so you don't like layout either?
10:48:08 <clahey> So, I've read the arrows paper and one of the tutorials, and I understand the definition of the arrow used to do static/dynamic parsing.
10:48:09 <rking> ZULTRAMAN: Though I'm thinking of e.g. Coffee where you can do suffix, 'x if y'
10:48:11 <clahey> Sorta.
10:48:16 <clahey> But I don't understand why it's helpful.
10:48:21 <ZULTRAMAN> rking, what do you mean?
10:48:29 <edwardk> then we definitely will never see eye to eye ;)
10:48:48 <nand`> I find ; much more logical to separate two statements, rather than something arcane and non-printable like \n. These days I just write all of my programs into a single line
10:48:50 <nand`> it's much clearer
10:48:53 <doomlord> it would be nice if languages were AST's and your editor just converts to whatever style you prefer :) but people dont do that for the one langauge that is actually an AST..
10:49:01 <rking> ZULTRAMAN: By the first statement I'm saying it takes almost no time to adjust to a style (of reading and writing) where the missing enders are not a problem at all.
10:49:11 <shachaf> ZULTRAMAN: You can always write Haskell without the layout.
10:49:22 <shachaf> Like GHC and zzo38.
10:49:22 <clahey> Does anyone understand it well enough to explain it to me?
10:49:29 <clahey> As I'm thinking of writing a parser?
10:49:31 <maukd> ZULTRAMAN: http://codepad.org/4NAY4Hog
10:49:34 <edwardk> shachaf: sure. it just becomes impossible to get people to look at your code after a while
10:49:38 <Trudko_> shachaf: i think i neeed to implmement it by my self  it should not be that hard
10:49:41 <rking> ZULTRAMAN: By the 2nd thing, I'm saying that for some things (in CoffeeScript) where you'd be annoyed at having to break a line out, you can flip it around anyway.
10:49:57 <shachaf> Trudko_: Need? Is this homework?
10:50:05 <Lutin`> maukd: oh god
10:50:13 <rking> maukd: Haha
10:50:18 <shachaf> edwardk: Just make your code relevant enough! E.g. the only Haskell compiler anyone uses.
10:50:19 <ZULTRAMAN> maukd, yeah, that's unreadable and why indentation is pretty subjective and ruleless to avoid that stuff.
10:50:21 <quuuux> also, comment: whitespace-sensitive syntax should -always- be optional, otherwise screenreaders have a hellish time
10:50:23 <Trudko_> shachaf yes to school I did and cartesian product which i managed to do
10:50:28 <edwardk> clahey: arrows are _almost_ universally a bad idea and should be replaced with applicatives wherever you can. this covers your static/dynamic parsing example
10:50:38 <nand`> Trudko_: then you're basically done
10:50:39 <shachaf> Trudko_: You should probably mention when a question you ask in here is homework.
10:50:39 <ZULTRAMAN> Seems like pretty bad code anyway.
10:50:40 <maukd> ZULTRAMAN: why do you think that's unreadable? it uses ) religiously to mark the ends of blocks
10:51:03 <ZULTRAMAN> Logic expressed that way is unredable no matter how you write it down, your mind just can't pares that any more
10:51:20 <maukd> ))))))))) is not logic
10:51:25 <ZULTRAMAN> I know where the blocks end, that'snot the issue, I have no idea what it does, my mental stack doesn't go deep enough to keep trac of that.
10:51:31 <maukd> you can't parse )))))))) no matter how you arrange it
10:51:45 <rking> maukd: https://gist.github.com/3d74c4bc794d8770b87c
10:51:56 <nand`> ) )  )    )        )                )                                )
10:52:03 <Trudko_> shachaf good to know
10:52:04 <ZULTRAMAN> )))))))) is eaiser to parse than )\n)\n) etc how it's done there, that's why peope do )))))))) on one line, takes up less space.
10:52:16 <edwardk> rking: =)
10:52:21 <maukd> ZULTRAMAN: why do you think ))))))) is easier to parse?
10:52:22 <shachaf> You know what takes even less space than ")))))))))"?
10:52:23 <shachaf> ""
10:52:24 <Lutin`> You know what easier than ')))))))'? ''
10:52:28 <edwardk> shachaf++
10:52:29 <Lutin`> Dammit shachaf lol
10:52:35 <ZULTRAMAN> maukd, takes up less space, meaning more of the ecode can actually be in view
10:52:37 <Saizan> clahey: the static part allows the parser to optimize itself, without even considering the input
10:52:37 <ZULTRAMAN> At least for me.
10:52:41 <clahey> edwardk:
10:52:48 <maukd> ZULTRAMAN: yeah, but you're not parsing )))))))) then. you're ignoring it
10:52:52 <clahey> Saizan: Yeah, I sorta understand that.
10:52:57 <rking> BTW another thing you can do is like this: https://github.com/nathanaelkane/vim-indent-guides#screenshots
10:53:05 <Lutin`> ZULTRAMAN: All your parens also take up space
10:53:08 <maukd> at which point you may as well make the indentation semantically significant
10:53:16 <clahey> Saizan: But they write out these 3 operators for parsers.
10:53:22 <ZULTRAMAN> Lutin`, nope, they take up less, they are condensed in a very small space.
10:53:29 <clahey> Saizan: And don't really explain how they combine to make the parser you want.
10:53:31 <ZULTRAMAN> maukd, I disagree, you are not ignoring it at all.
10:53:39 <rking> I think it's clear that ending tokens are redundant against the whitespace we use. If you're like me, any redundancy is an instant candidate for deduplication.
10:53:40 * ski . o O ( "*** Line Separation","Absolutely do *not* place closing brackets on their own lines.","Rationale:  The parentheses grow lonely if their closing brackets are all kept separated and segregated." -- quoth "Riastradh's Lisp Style Rules" <http://mumble.net/~campbell/scheme/style.txt> )
10:53:41 <maukd> ZULTRAMAN: I said "you", not me
10:53:41 <zzing_> I have a parser using parsec: http://hpaste.org/76040  I am trying to figure out how to use (runParser parseHeading () "test" "header : text")  to test it, but I cannot get it to work. Any ideas on what I can run to just get it to work?
10:53:47 <nand`> when I write code with indenting, the indenting just tends to grow and eventually terminate
10:53:51 <nand`> going back to the beginning
10:53:52 <clahey> edwardk: That is a very strong opinion.  Do you have a tutorial or explanation somewhere of how to use applicatives to be useful in this framework?
10:53:53 <maukd> ZULTRAMAN: I don't ignore them because I don't write )))))))) because I can't parse it
10:54:00 <nand`> I seldom see code where the indentation goes backwards in steps
10:54:04 <Saizan> clahey: ah, i don't remember the specifics
10:54:17 <edwardk> clahey: the swierstra and duponcheel parsers are pretty easy. you have a 'static part' that describes what a conservative approximation first set of the parser looks like, this enables you to quickly accept or reject
10:54:33 <edwardk> and then you use the dynamic part of the parser to confirm
10:54:36 <clahey> edwardk: I get that.
10:54:55 <ZULTRAMAN> maukd, I have no troubles with it, there's a reason S expressions are far more popular than M expressions though and indentation based lisp ever caugt on, I don't think it's clearer at all, far from it, it leaves me confused. I like explicit opening and ending of blocks rather than having to puzzle my way through indentation
10:55:07 <maukd> rking: here's another version: http://codepad.org/4NAY4Hog
10:55:14 <clahey> edwardk: Hmm, I got the idea that if the static parser worked, you didn't need to check the dynamic part and could just get the result out of it, but having it be a conservative approximation makes a lot more sense.
10:55:20 <edwardk> nothing in that actually needs the 'arrow'ness of the arrow. the first parameter is all but ignored
10:55:24 <ZULTRAMAN> If you absolutely have to know you can use a syntax highlighter to find matching brackets, something that's a bit more complex if it's whitespace based
10:55:39 <copumpkin> moo
10:55:41 <maukd> ZULTRAMAN: but you already do that! you can't tell me that you actually see the difference between ))))))) and ))))))))
10:55:48 <clahey> edwardk: I just had the idea that you could use a list monad in a way that they didn't describe.
10:55:54 <ion> Both are Russian smileys.
10:56:01 <Lutin`> lolololll
10:56:01 <edwardk> i prefer to use it as the conservative approximation of the first set, because then you _can_ define a monad for it, it just conservatively assumes everything could succeed, etc.
10:56:30 <ZULTRAMAN> maukd, certainly I do.
10:56:34 <clahey> edwardk: They talk about having to walk all the way down the path before returning back to your place.
10:56:42 <maukd> ZULTRAMAN: hmm, ok.
10:56:43 <Lutin`> ZULTRAMAN: Did you count them?
10:56:50 <edwardk> the goal is to make it more efficient when you have a bunch of parsers to proceed with. you can choose between the different alternatives from <|> much more efficiently with a swierstra and duponcheel style parser
10:57:00 <ZULTRAMAN> Nope, I don't count them mentally, it goes by feeling, I 'estimate' it, if you will.
10:57:36 <ZULTRAMAN> I also estimate typing the )))))) trail sort of I guess, I don't actually count, it goes on auto pilot, it tends to be right, right more often anyway than Haskell or python give me an error for whitespace abuse.
10:57:36 <edwardk> you don't have to walk down all the left associations of <*> to find the first thing being accepted in each branch. that has already been lifted up to the <|> to consider
10:57:58 <clahey> edwardk: Yeah, I don't understand.
10:58:01 <edwardk> ZULTRAMAN: amazingly this is what everyone else gets out of operator precedence. =P its just what you are familiar with
10:58:05 <rking> maukd: I see your codepad and raise you this gist: https://gist.github.com/cb359b583f4f955468f2
10:58:37 <clahey> edwardk: So, I have this image of a way to build a parser.  It might match what they're doing.
10:58:59 <ski> ZULTRAMAN : do you use bracket-highlighting in $EDITOR ?
10:59:01 <ZULTRAMAN> edwardk, probably, but I've been using operator praecedence all my life and I got more accustomed to S-expressions in like 2 days.
10:59:06 <doomlord> (use of so many unfamiliar operators makes haskell hard to read for newcomers, imo.)
10:59:09 <maukd> rking: beautiful
10:59:10 <Lutin`> clahey: Then take a brain picture and compare images
10:59:15 <ZULTRAMAN> I do believe it is superior and far easier to learn. People are just more used to operators.
10:59:15 <Lutin`> :P
10:59:17 <rking> =~)
10:59:19 <ZULTRAMAN> ski, yap.
10:59:26 <clahey> edwardk: Basically, you build up a dynamic state machine and use the list monad as in its concept as possible states.
10:59:36 <maukd> ZULTRAMAN: your beliefs are wrong
10:59:41 <clahey> Lutin`: If I had that technology, I probably wouldn't be worried about how to write an efficient parser.  :)
10:59:51 <doomlord> funny though, coders are used to object.member , but its a full stop which is a separator to most of the population  :)
10:59:54 <edwardk> clahey: (fwiw i've implemented a pretty complicated variant on the S&D parser that used information about how many symbols a parser could parse to speculatively evaluate the next parser while still working. i just never got it to be faster than the naive version) =)
10:59:58 <ZULTRAMAN> Which is also a plus of explicit brackets, easier to let a highlighter match it.
11:00:08 <edwardk> clahey: thats the 'list of successes' parser
11:00:11 <edwardk> its pretty well known
11:00:25 <edwardk> the problem with it is the error information tend to be non-existent or just suck
11:00:26 <Lutin`> doomlord: And what kind of non-programmer uses {}?
11:00:29 <Lutin`> Or |
11:00:30 <ZULTRAMAN> maukd, well, everyone grows up with infix stuff and that and there are a lot of people who claim that S-expressions are superior once they got used to him or unconventional but intentionally designed notation in general.
11:00:40 <stepcut> anyone know the location/status of the GSoC project that was supposed to produce a portable inotify-like library?
11:00:42 <clahey> edwardk: Ah, that makes sense.
11:00:42 <ZULTRAMAN> Many people who are accustomed to APL's notation also swear by it.
11:00:51 <maukd> ZULTRAMAN: I don't
11:01:01 <edwardk> clahey: because all you get to know is you have an empty list of successes ;)
11:01:02 <alpounet> stepcut, edwardk might have a clue about that
11:01:06 <clahey> edwardk: I'm actually just thinking about how to parse an xml like format, so it's probably not as hard as I'm making it look.
11:01:16 <edwardk> stepcut: hrmm
11:01:23 <clahey> edwardk: Could you not look at what the possible sets were right before that?
11:01:33 <Lutin`> Screw all this noise just use Forth and we don't need any punctuation
11:01:37 <Lutin`> Except .
11:01:41 <ZULTRAMAN> Well, until we start raising kids in S-expressions to see if they later on willingly transition to infix notation, we can't really know I guess, but I seriously doubt anyone raised with S-exprssions would consider infix notation anything more than cumbersome arbitrary madness.
11:01:48 <ZULTRAMAN> I do, and I was raised with infix.
11:01:59 <edwardk> clahey: in parsec/trifecta we work pretty hard to keep track of 'why' things fail, and track what was expected at the current position
11:02:12 <Lutin`> ZULTRAMAN: What's so wrong with infix
11:02:21 <edwardk> ZULTRAMAN: so why are you in #haskell then?
11:02:26 <maukd> ZULTRAMAN: but that's not what you said
11:02:36 <clahey> edwardk: Is parsec an S&D parser then?
11:02:46 <maukd> ZULTRAMAN: I grew up with infix, learned lisp, and hated it
11:02:47 <doomlord> infix is great if you know the precedences, and its easier to type than parens
11:02:52 <Lutin`> Are we going to start using prefix notation in math now?
11:02:53 <ZULTRAMAN> Lutin`, what's wrong with the imperial sytem? More rules to remember probably means that your brain subconsciously has to work more to make sense of it, therefore once you are used to S-expressions it becomes easier to read because it's built on less rules.
11:02:56 <nand`> what would be the best way to write a parsec parser that parses until the first unmatched closing parenthesis?
11:03:03 <clahey> ZULTRAMAN: They have a good point.  Why don't you just hang out in a scheme channel?
11:03:05 <nand`> for example, "foo(bar)bat)baz" would parse up to and including ‘bat’
11:03:12 <edwardk> no, parsec is a fairly traditional monadic parser combinator library
11:03:18 <doomlord> infix keeps the operators closer to thee operands
11:03:29 <doomlord> this is why the OO calling style is popular.  object.method(arg)
11:03:31 <maukd> ZULTRAMAN: getting more used to S-expressions just made me hate lisp more
11:03:31 <rwbarton> if S-expression syntax is so easy for humans then where are all the natural languages that say "begin add three four end" for "three plus four"
11:03:36 <ZULTRAMAN> edwardk, like I said, I do not ssociate myself like that with any language, I use multiple languages, I just answered your quaestin with that I find lisps to have an exceptionally clear sytax, that' all.
11:03:37 <stepcut> ah, I think I found it, https://github.com/mdittmer/hfsnotify
11:03:55 <nand`> rwbarton: hehe
11:03:56 <ZULTRAMAN> rwbarton, my native langauge is SOV, mind you.
11:04:03 <ZULTRAMAN> SVO word orderis definitely not a universal given.
11:04:09 <rwbarton> I understand, and that may play a role
11:04:15 <clahey> rwbarton: Wow, that's an actual argument.  :)
11:04:15 <ZULTRAMAN> Japanese grammar is essentially pure postfix notation
11:04:21 <hpaste> scp pasted “Indentation Error?” at http://hpaste.org/76041
11:04:22 <rwbarton> I still bet it doesn't end all sentences with "begin begin begin begin begin begin begin"
11:04:24 <ZULTRAMAN> JApanse is basically forth.
11:04:31 <rwbarton> or begin sentences rather
11:04:37 <scp> Would you guys be kind enough to tell me all the things wrong with that hpaste?
11:04:39 <ZULTRAMAN> There is no need in Japanse due to typing for that basically.
11:04:44 <Lutin`> ZULTRAMAN: That actually sound nice
11:04:58 <scp> taking for granted that my Expr, Var, Const type constructors are correct
11:04:59 <ZULTRAMAN> Japanese doesn't have variadic functions, you use different verbs for transitive and intransitive verbs.
11:05:00 <nand`> I want a natural language based on dependent types
11:05:03 <Trudko_> shachaf so i guess i am on my own if is it homework?
11:05:12 <ZULTRAMAN> Like, if you say 'I move' or 'I move him', you would use a different derivation of a verbal stem.
11:05:25 <maukd> scp: redefining the Show instance, calling 'show' 'Show', and I stopped reading there
11:05:29 <ZULTRAMAN> Which is actually more common in world language than what English has in its use of ergative verbs.
11:05:39 <rwbarton> also English speakers have a much easier time handling right-recursion than arbitrary recursion
11:05:40 <Lutin`> ZULTRAMAN: Oh the verb stem changes?
11:05:44 <int-e> scp: is this a test?
11:05:46 <rwbarton> which corresponds nicely to ($)
11:05:56 <scp> int-e: this is a nooby!
11:06:06 <rwbarton> I don't know whether there is an equivalent in SOV languages
11:06:08 <doomlord> "japanese is forth", interesting :)
11:06:18 <doomlord> does it have DUP and SWAP
11:06:38 <scp> :w
11:06:38 <edwardk> this conversation is definitely drifting into #haskell-blah territory
11:06:45 <zzing_> If I have a (x:xs) for a string, is there an equivalent pattern match I can do for text?
11:06:47 <rwbarton> more like #lisp-blah
11:06:55 <quuuux> #sapir-whorf-blah
11:07:00 <ZULTRAMAN> Lutin`, no, the stem remains the same, the ending is different, I don't speak Japanese to that extend, but in Finnish for instance. siirtyä means 'to move' as in 'I move' and siirtää means 'to move' as in 'I move him'
11:07:07 <Lutin`> I was reading this one thing on how the reason why Chinese kids tend to be better at math than English kids is cause of the difference in number systems
11:07:20 <Lutin`> ZULTRAMAN: Same goes in spanish
11:07:22 <scp> maukd: So I can't define my own Show for a certain kind of list?
11:07:32 <maukd> scp: correct
11:07:34 <clahey> edwardk: Does that mean it's going to be more space-leaky than doing something on my own?
11:07:40 <maukd> >implying math is about numbers
11:07:54 <scp> scp: Would `type MyList = [MyType]` let me circumvent it?
11:07:55 <Lutin`> maukd: What it was is we can remember about 1.5 seconds worth of numbers
11:07:56 <clahey> edwardk: Second question, how much less descriptive is atto-parsec?
11:08:06 <Lutin`> And the chinese number system is more axiomatic than english
11:08:07 <scp> doh, I even can't IRC today x_X
11:08:13 <Lutin`> Also les syllables
11:08:17 <maukd> scp: no
11:08:21 <nand`> maukd: early exposure to more powerful logical systems of abstractions might be beneficial for many non-numerical areas of mathematics
11:08:30 <nand`> s/of/or/
11:08:30 <scp> maukd: ok, thanks =]
11:08:50 <rwbarton> zzing_: not directly
11:09:09 <Lutin`> nand`, maukd: Part of it I'm sure stems from the frustrations with the system
11:09:21 <ski> scp : ǹewtype MyList = ML [MyType]' would allow you to `instance Show MyList', though
11:09:25 <rwbarton> zzing_: there is probably some kind of "viewL" or "uncons" function you can use though
11:09:29 <Lutin`> Why would you want to study math if you have to remember 12 is twelve and not ten-two
11:09:39 <zzing_> rwbarton, view patterns?
11:09:51 <maukd> ski: did you mean: ǹewtype MyList = ML [MyType]́
11:09:52 <rwbarton> you could use view patterns as well yes
11:10:02 <ski> yes
11:10:13 <clahey> Lutin`: Why would you have to think about decimal when you can just look at 12 things and think "twelve"
11:10:15 <zzing_> I am now trying to figure out how view patterns work
11:10:21 <nand`> Lutin`: it's even worse in german, where ‘354’ is “three hundred four and fifty”
11:10:31 <int-e> scp: I think the upper case Show is worst; in a where clause, you have to indent everything at least as deep as the first word following 'where'. And using 'id' as a variable is bad style. (id is the identity function)
11:10:33 <edwardk> clahey: attoparsec gives you no error messages and sometimes backtracks too much, but its faster
11:10:38 <clahey> Lutin`: (I'm not disagreeing with you so much as pointing out that it's not obvious."
11:10:44 <Lutin`> clahey: Fair enough
11:10:44 <nand`> I still constantly make mistakes when reading or hearing numbers in german
11:10:45 <hpaste> scp pasted “toListing variant” at http://hpaste.org/76042
11:10:49 <clahey> edwardk: Hmm.  conduit-xml uses atto-parsec for some reason.
11:10:52 <doomlord> does haskell allow unicode symbols... is there an opensource editor that can subsitute strings for unicode symbols conviniently
11:10:55 <nand`> since I intuitively swap the tens and ones to their more logical order
11:10:56 <hiptobecubic> nand`, also dutch
11:10:59 <maukd> map f ((f -> y) : (map f -> ys)) = y : ys
11:11:03 <clahey> I think French wins at this.
11:11:04 <maukd> streams crossed.
11:11:04 <scp> ok, can anyone tell me now why I'm getting an indentation error after 'where'?
11:11:10 <nand`> doomlord: yes to both
11:11:13 <edwardk> clahey: trifecta and parsec won't leak memory unless you put together a particularly crappy grammar, as a rule of thumb only use 'try' on small parsers
11:11:14 <watermind> is there a way to nest guards? i.e. in the same way we can nest if then elses?
11:11:17 <clahey> Three hundred four twenties and ten four.
11:11:28 <edwardk> clahey: sure. its fast and fits their operational model
11:11:36 <rwbarton> scp: sure, because all those patterns need to be indented more than 'thisLine'
11:11:38 <edwardk> doomlord: yes, unicode works
11:11:40 <watermind> so that if a guard applies then check some other guards?
11:11:40 <maukd> nand`: I have a program for writing numbers in german :-)
11:11:41 <ski> maukd : i want `g@(map f) ((f -> y) : (g -> ys)) = y : ys' ..
11:11:47 <nand`> doomlord: -XUnicodeSyntax allows unicode symbols for some Haskell syntax; and ‘yi’ for example can automatically displays Haskell code using these
11:11:56 <nand`> yi is open source
11:12:11 <scp> rwbarton: ah, I see... I thought they just had to be indented more than the beginning of the line that thisLine was on
11:12:14 <scp> rwbarton: thanks!
11:12:14 <nand`> doomlord: apart from that, you can use unicode letters and operators in your names without needing any special extensions
11:12:16 <clahey> Oh, that's not quite right.  three hundred four twenties and fourteen.
11:12:18 <doomlord> Perhaps with all the crazy operators in haskell it might be clearer with dedicateed symbols
11:12:19 <edwardk> doomlord: http://comonad.com/haskell/haskell.vim does unicode replacement, but saves as ascii
11:12:23 <clahey> Oh, that's not quite right.  three hundred four twenties fourteen.
11:12:24 <Lutin`> clahey: While it's not obvious, it would make sense to have the language used to describe the numbers match the system of the nubers
11:12:29 <elliott> using yi in 2012 seems questionable
11:12:30 <Lutin`> numbers*
11:12:31 <rwbarton> scp: that is true only when thisLine is at the beginning of its line :)
11:12:33 <elliott> unless it started being maintained again
11:12:47 <hiptobecubic> clahey, french?
11:12:50 <clahey> hiptobecubic: Yep.
11:12:51 <nand`> french is silly too, 396 is “three hundred, four-twenty and sixteen”
11:12:59 <doomlord> would be nice to have actual lambda, function compose dot etc.
11:13:02 <clahey> nand`: No and there.
11:13:08 <nand`> oh yeah
11:13:10 <nand`> no and
11:13:11 <hiptobecubic> the and is only with 'one'
11:13:13 <rwbarton> doomlord: do you want to use unicode syntax (e.g. a unicode arrow instead of ->) or unicode variable names
11:13:14 <maukd> doomlord: not "actual lambda" :-|
11:13:21 <rwbarton> the latter is easy
11:13:28 <doomlord> i like the fact shen approximates its lambda as /.  although .\ looks more like it to me
11:13:33 <edwardk> brb
11:13:45 <clahey> Lutin`: When I count on my fingers, my thumb counts for 5.
11:13:45 <nand`> doomlord: you can set (∘) = (.) without -XUnicodeSyntax
11:13:48 <Lutin`> doomlord: /. the top is the wrong way
11:13:52 <nand`> regardless, UnicodeSyntax doesn't allow λ for \
11:13:53 <clahey> Lutin`: And my left hand counts for tens (and fifty)
11:14:17 <clahey> So I can count to 100 on my hands without doing any physical calisthenics with random fingers sticking up.
11:14:21 <Lutin`> clahey: I do that too actually
11:14:22 <doomlord> I'd use unicode for operators .
11:14:34 <nand`> UnicodeSyntax allows stuff like → for ->, ∀ for forall, and some other stuff
11:14:37 <rwbarton> unicode operators are fine too
11:14:41 <merijn> Who was working on the vim unicode stuff to more easily type unicode syntax?
11:14:52 <zzing_> Can I replace (x:xs) :: String  with  (uncons s -> Just (x, xs))  :: Text   when converting to Text with a view pattern?
11:15:17 <quuuux> clahey: you just gave me an idea: use the gaps between fingers to count more fives
11:15:18 <Lutin`> clahey: Except I do 1 to 10 on my right hand
11:15:20 <rwbarton> there are some caveats though, like I think the Haskell spec says that all characters count as a single column for indentation purposes while your editor may not agree with that
11:15:32 <Lutin`> quuuux, clahey: ASL counting
11:15:45 <doomlord> argh could get mesy
11:16:01 <clahey> Lutin`: Ah, I do it slightly differently.
11:16:13 <Lutin`> clahey: Yea I know
11:16:18 <clahey> Lutin`: No fingers touching.  Just thumb for 5, thumb and index for 6, and so forth.
11:16:32 <Lutin`> That's what I figued
11:16:34 <quuuux> how does ASL count? I actually use the same system as clahey, and learned it as the 'Korean method'
11:16:35 <nand`> an idea I just got: start with the pinky when counting upwards, then retract your fingers one by one in the same order
11:16:46 <nand`> depending on which side of the hand has fingers raised you know if you are <5 or >5
11:16:50 <ski> scp : what is the `%'s for ?
11:16:59 <nand`> (or start with the thumb, that's probably more natural)
11:17:04 <Lutin`> quuuux: once you get past 5 you touch your thumb to the other fingers
11:17:15 <clahey> nand`: Having just your pinky and ring finger up feels somewhat unnatural.
11:17:32 <Lutin`> Yes your hand doesn't like that
11:17:36 <maukd> doable. full binary all the way!
11:17:37 <clahey> Lutin`, quuuux: 9 and f are the same.
11:17:56 <clahey> maukd: Are you seriously telling me 17 isn't uncomfortable?
11:18:07 <yitz> Lutin`: just counting fingers and gaps gives which months are 31 days or less than 30. Great for kids!
11:18:09 <Lutin`> You don't flatten your fingers together for 9
11:18:13 <rwbarton> 17? I think you counted wrong
11:18:17 <Lutin`> yitz: I still do that lol
11:18:22 <clahey> Lutin`: Ah, interesting.
11:18:27 <clahey> Sorry, 21.
11:18:28 <yitz> Lutin`: yeah, kids like me and you
11:18:44 <scp> ski: just notation that I want in my output, nothing significant to the question =]
11:18:51 <clahey> Yeah, 17 is a pretty common gesture.  :)
11:19:45 <maukd> clahey: I lack the english vocabulary to describe my fingers. interesting.
11:20:02 <quuuux> maukd: thumb, {index, middle, ring, little} + finger
11:20:09 <maukd> quuuux: yes, that's trivial
11:20:29 <maukd> quuuux: how do you say "halb abgeknickt", "geballt", or "zum ersten glied"?
11:20:41 <quuuux> maukd: give me a gloss for those? My german was never any good
11:20:53 <nand`> “half-raised” ?
11:21:22 <maukd> "phalanx"? whoa
11:21:29 <Lutin`> I tried copying those into google translate and accidentally posted "variadic operators". Google detected it as Italian
11:21:35 <osfameron> hehe
11:21:37 <quuuux> I don't think there are actually common english terms for those
11:21:50 <Lutin`> Your knuckles?
11:21:52 <nand`> when counting in rational roots I like overlapping my fingers
11:22:02 <quuuux> if it had to be specified, it'd probably be 'bent at the (first/second/third joint)/knuckle'
11:22:09 <Lutin`> Yes what quuuux said
11:22:13 <maukd> clahey: it's pretty comfortable if I don't completely bend the index/ring fingers
11:22:34 <maukd> bent at the first joint! nice
11:22:41 <quuuux> the other finger-counting method I intend to try sometime is base-12, enumerating each joint
11:22:42 <maukd> but wait, which direction is "first" in?
11:22:51 <hpaste> ski annotated “toListing variant” with “blah” at http://hpaste.org/76042#a76043
11:22:56 <ski> scp ^
11:22:58 <Lutin`> maukd: hand side
11:23:05 <maukd> good
11:23:06 <yitz> maukd: no simple idiomatic analogue. google translate give pretty much gibberish: "kinked half", "concentrated", "first link"
11:23:12 <quuuux> that is, pointing at the joints with the thumb
11:23:30 <Lutin`> maukd: So where your fingers connect to your hand is one
11:23:37 <maukd> yitz: well, that's synonymously correct but nonsensical in this context
11:23:48 <scp> ski: thanks =]
11:23:50 <yitz> maukd: right
11:23:56 <quuuux> iirc that's in use in some sub-saharan cultures, but interestingly they still use base-10
11:24:31 <Lutin`> Woah
11:24:32 <Nafai> man I would have been confused
11:24:39 <Nafai> I would have had to count base 14
11:24:42 <Lutin`> You could do hexadecimal that way
11:24:52 <ski> scp : depending on the base case of `toListing', the main equations might be simplifiable as well
11:25:07 <quuuux> oh, hey, if you use the gaps between fingers too, you can get 20 easily on one hand
11:25:18 <Lutin`> 24
11:25:36 <yitz> the babylonians used base 60 in cuneiform
11:25:43 <Lutin`> Today in #haskell: How to best count on your hands
11:26:06 <maukd> ~abstract nonsense~
11:26:08 <Cale> I thought for a moment that people were talking about finger trees
11:26:17 <Cale> but that turned out not to be true
11:26:29 <spaceships> why is ghc so huge?
11:26:36 <maukd> it has huge guts
11:27:07 <spaceships> so, ghc is big because its big? fair enough..
11:27:08 <Cale> spaceships: It has a lot of features, and comes with a fair number of libraries
11:27:17 <Lutin`> Giant Huge Compiler
11:27:33 <Lutin`> And extensions
11:27:51 <quuuux> -Glorious- Giant Huge Compiler
11:28:03 <Cale> also, I think most stuff is still statically linked
11:28:14 <Lutin`> Yes
11:28:32 <quuuux> Lutin`: come to #haskell-blah, I want to keep talking about finger counting
11:29:50 <maukd> sorry, I had to make this joke
11:30:08 <spaceships> :)
11:30:39 <hpaste> nand` pasted “Parsec parse until unbalanced closing parenthesis” at http://hpaste.org/76044
11:30:43 <nand`> any way to improve this?
11:30:45 <nand`> it looks horrendeously ugly
11:33:06 <kmbt> Which library would you advise for regex (PCRE) matching against Text?
11:33:25 <kmbt> recommend*
11:34:40 <Cale> kmbt: My very first question would be: do you really *need* regular expressions, or is general parsing okay?
11:35:07 <Cale> i.e. are you presenting a regular expression interface to your users or are you just parsing some text?
11:35:23 <maukd> I'd recommend perl because all other regex implementations I've seen suck too much
11:35:32 <Cale> haha
11:35:58 <maukd> perl's regexes suck in acceptable ways
11:36:21 <Cale> (I don't think the ways that they suck in are particularly acceptable, but don't really want to get into that argument)
11:36:29 <kmbt> Cale: I am wriding an ETL app and need some pattern matching/substitution
11:37:19 <Cale> kmbt: Okay, I think you will have a much happier time if you just learn a proper parsing library like Parsec for example.
11:37:26 <clahey> edwardk: So, I'm interested in writing a parser for microxml.
11:37:41 <clahey> edwardk: Would you suggest parsec, atto-parsec, something else?
11:37:55 <edwardk> @hackage trifecta
11:37:55 <lambdabot> http://hackage.haskell.org/package/trifecta
11:38:09 <edwardk> its faster than parsec, and gives nicer error messages
11:38:15 <Cale> kmbt: So unless the actual data contains regexes that you need to match against other parts of the data, using Parsec or something would be way way nicer than writing regular expressions.
11:38:22 <edwardk> @hackage parsers
11:38:23 <lambdabot> http://hackage.haskell.org/package/parsers
11:38:34 <jfischoff> edwardk: nicer than parsec or attoparsec?
11:38:36 <Cale> Or, indeed, trifecta :)
11:38:49 <edwardk> is a generic interface to different parsing libraries though admittedly its missing instances for parsec and attoparsec (or even trifecta right now)
11:38:59 <maukd> hahaha
11:39:10 <nejucomo> Does the error "Could not deduce (t ~ u)" mean the type system could not prove t and u (from different code locations) are the same type?
11:39:16 <edwardk> i'd write to trifecta, since with a little refactoring you'd be able to use parsers when i ship the new trifecta and get it to work with any of them
11:39:24 <rwbarton> nejucomo, yes
11:39:35 <maukd> .oO( it's a generic interface to different parsing libraries but it's kinda missing instances for all parsing libraries right now )
11:39:37 <rwbarton> the error message used to be clearer
11:40:11 <edwardk> maukd: i had a buddy of mine approach me a few weeks ago. he was getting ready to write a parser and i had just uploaded parsers. and after he implemented it he was convinced i trolled him because the parsers package doesn't contain any actual parsers ;)
11:40:27 <MostAwesomeDude> Heh.
11:40:59 <hpaste> nand` annotated “Parsec parse until unbalanced closing parenthesis” with “Parsec parse until unbalanced closing parenthesis (annotation)” at http://hpaste.org/76044#a76045
11:41:04 <edwardk> maukd: well, its all the stuff from trifecta that doesn't depend on trifecta goodness
11:41:07 <nand`> I improved it slightly by factoring out the repeated logic
11:41:12 <nand`> but it's still probably not idiomatic parsec
11:41:15 <clahey> edwardk: Is there a trifecta tutorial?
11:41:18 <nand`> isn't there any better way to do this?
11:41:32 <edwardk> clahey: sadly no. there are some simple parsers out there written with it though, let me find you one
11:42:11 <edwardk> clahey: https://github.com/DylanLukes/Winchester-STG-Compiler/blob/master/WSC/Parser.hs is probably a good example of style
11:42:21 <hpaste> nejucomo pasted “Invertible (Not possible?)” at http://hpaste.org/76046
11:42:24 <kmbt> Cale: I see. I am a beginner to haskell and would like to learn Parsec eventually. But for now i would like to go with something that would work in a way I already understand. Do you think that regex-pcre package would be good?
11:42:54 <Cale> kmbt: It'll work, but it's kind of confusingly designed.
11:43:09 <merijn> kmbt: The haskell regex packages tend to be confusingly designed. Using lots of weird typeclass magic
11:43:12 <nejucomo> Here's where I've run into that problem.  I hope what the code is attempting makes sense.  If so, could any haskeleer tell me definitively if this is possible or not?
11:43:14 <doomlord> yikes. so haskell doesn't use unicode lambda for lambda because its a letter. That should be an exception surely :)
11:43:22 <Cale> doomlord: huh?
11:43:25 <merijn> kmbt: tbh, Parsec isn't that hard to start with
11:43:29 <Cale> doomlord: Why should it be an exception?
11:43:38 <doomlord> lambda for lambda :)
11:43:49 <kmbt> merijn: Any tutorial you could recommend?
11:44:03 <nejucomo> Is there no lambda-like thingy as one of the mathematical or technical characters?
11:44:06 <Cale> doomlord: If we were to use a Unicode lambda for \ we would probably use the symbol version
11:44:33 <maukd> doomlord: \ is 100% superior to λ
11:44:38 <clahey> edwardk: So I build a top level MonadParser out of lower level MonadParsers and pass that to the parse function?
11:44:48 <merijn> kmbt: Real World Haskell has a chapter explaining Parsec (although I think it describes Parsec2, *most* things apply to Parsec3, but there might be a few pitfalls. People here should be able to help you with any pitfalls you encounter)
11:44:48 <edwardk> yep
11:44:53 * nejucomo suspects something like Invertible is not possible but is not yet certain; keeps exploring type classes, GADTs, and DataKinds...
11:44:55 <nand`> we'd have hats above the abstraction variables like in the original syntax
11:44:57 <Cale> i.e. something like 𝜆 instead of λ
11:45:09 <doomlord> oh there is another
11:45:14 <Cale> There are several
11:45:27 <Cale> > generalCategory '𝜆'
11:45:28 <lambdabot>   LowercaseLetter
11:45:32 <Cale> ah, hmm
11:45:33 <doomlord> well  λ is superior to .\   which is superior to \
11:46:07 <rwbarton> REPLACEMENT CHARACTER is my favorite too
11:46:12 <maukd> doomlord: that's backwards
11:46:34 <Cale> > map generalCategory "𝛌𝜆𝝀𝝺𝞴"
11:46:34 <doomlord> \ already has other meanings in other places
11:46:36 <lambdabot>   [LowercaseLetter,LowercaseLetter,LowercaseLetter,LowercaseLetter,LowercaseL...
11:46:44 <Cale> okay, fine, be that way
11:46:44 <rwbarton> > '�'
11:46:46 <lambdabot>   '\65533'
11:46:51 <rwbarton> is this really what you mean
11:46:59 <rwbarton> or is something broken
11:47:09 <clahey> edwardk: Okay.  Where do I find definitions of all the atoms and what the combinators mean in terms of parsers?
11:47:11 <Cale> but any of those would be better than stealing the ordinary Greek λ
11:47:13 <Cale> I think
11:47:13 <maukd> doomlord: λ already has other meanings in other places
11:47:14 <rwbarton> I am guessing something is broken
11:47:15 <clahey> Or is that not available anywhere?
11:47:31 <doomlord> lambda has fewer other meanings in computing
11:47:34 <clahey> rwbarton: That looks like an inverse color ?
11:47:39 <maukd> doomlord: [citation needed]
11:47:58 <edwardk> clahey: http://hackage.haskell.org/packages/archive/trifecta/0.53/doc/html/Text-Trifecta-Parser-Char.html http://hackage.haskell.org/packages/archive/trifecta/0.53/doc/html/Text-Trifecta-Parser-Combinators.html etc
11:48:21 <doomlord> well i know of other meanings for \ but not for λ  (in computing)
11:48:29 <maukd> doomlord: it's a letter
11:48:30 <edwardk> the parsers library is basically the bulk of the combinators from trifecta just factored out without the actual parser machinery ;)
11:48:32 <rwbarton> when I copy&paste Cale's weird unicode character I just get U+FFFD REPLACEMENT CHARACTER
11:48:37 <maukd> doomlord: can you think of meanings for 'a'?
11:48:45 <rwbarton> maybe Cale is not using unicode at all??
11:48:47 <doomlord> its not a letter to me
11:48:58 <Cale> rwbarton: I think that's probably on your end then?
11:48:58 <maukd> rwbarton: which one is the "weird" one?
11:49:01 <nejucomo> Greek letter lambda is hard for me to type.  I think it should just be 'f'.
11:49:02 <maukd> doomlord: yeah, but you're wrong
11:49:02 <Cale> > map ord "𝛌𝜆𝝀𝝺𝞴"
11:49:03 <lambdabot>   [120524,120582,120640,120698,120756]
11:49:11 <rwbarton> interesting
11:49:18 <rwbarton> I wonder how that happens then
11:49:24 <maukd> U+1D6CC (f0 9d 9b 8c): MATHEMATICAL BOLD SMALL LAMDA [𝛌]; U+1D706 (f0 9d 9c 86): MATHEMATICAL ITALIC SMALL LAMDA [𝜆]; U+1D740 (f0 9d 9d 80): MATHEMATICAL BOLD ITALIC SMALL LAMDA [𝝀]; U+1D77A (f0 9d 9d ba): MATHEMATICAL SANS-SERIF BOLD SMALL LAMDA [𝝺]; U+1D7B4 (f0 9d 9e b4): MATHEMATICAL SANS-SERIF BOLD ITALIC SMALL LAMDA [𝞴]
11:49:32 <rwbarton> maukd, all of them
11:49:34 <Cale> rwbarton: Either misconfigured IRC client or misconfigured terminal?
11:49:45 <doomlord> most people  in computing call anonymous functions "lambda functoins"
11:49:46 <rwbarton> it normally works with utf-8
11:49:52 <maukd> doomlord: [citation needed]
11:50:02 <rwbarton> so it is only partially misconfigured
11:50:07 <nejucomo> Most haskell programmers will probably soon be Mandarin speakers, so 'f' doesn't mean anything special to them.  ;-p
11:50:11 <Cale> rwbarton: which client?
11:50:14 <maukd> because a lot of people call them "closures"
11:50:22 <rwbarton> irssi over ssh in urxvt
11:50:27 <rwbarton> in screen
11:50:28 <maukd> rwbarton: no screen?
11:50:30 <maukd> ah
11:50:30 <rwbarton> ah
11:50:35 <Cale> maukd: I hate that *so* much
11:50:37 <doomlord> english is the language of computing
11:50:37 <djahandarie> ah
11:50:38 <rwbarton> why does that matter and how do I fix that
11:50:43 <doomlord> (main0
11:50:45 <kmbt> merijn: Btw do you think that Parsec could be used for natural language parsing? Eg. to mine structured text documents for information on dates and events?
11:50:46 <elemir> rwbarton: Why not dtach?
11:50:50 <maukd> doomlord: "GRUNNUR"
11:51:17 <Cale> (calling things closures when they are functions or procedures, and only potentially implemented by closures internally)
11:51:18 <rwbarton> because (a) I've never heard of dtach (b) sometimes I need to use systems running screen so I might as well be familiar with screen
11:51:28 <maukd> rwbarton: well, you'll need to find out at which point the miscommunication happens: terminal<->screen<->irssi
11:51:37 <djahandarie> I think it's irssi.
11:51:41 <zomg> Does dtach have something better over screen?
11:51:45 <maukd> dtach can detach+attach but not multiplex
11:51:46 <clahey> edwardk: So, I can mostly just copy in the EBNF and massage it to match the syntax, no?
11:51:47 <Cale> kmbt: maybe
11:51:47 <zomg> Tmux seems to be the new "hip" choice
11:52:01 <Lutin`> i like tmux
11:52:01 <maukd> zomg: it's transparent to applications
11:52:06 <Cale> kmbt: It's not designed for natural language parsing, but you can write fairly general parsers in it
11:52:14 <rwbarton> Cale: can you send those wacky characters again
11:52:17 <maukd> zomg: that is, it doesn't parse/recreate escape sequences
11:52:18 <Cale> > map ord "𝛌𝜆𝝀𝝺𝞴"
11:52:20 <lambdabot>   [120524,120582,120640,120698,120756]
11:52:20 <edwardk> yep, though you need to be careful to avoid left recursion in the grammar, and you need to use 'try' around small chunks where the grammar fails to be LL(1)
11:52:21 <rwbarton> thanks
11:52:47 <doomlord> are there unicode symbols for <= >=
11:53:00 <clahey> choice [a, b]  =====  a <|> b
11:53:00 <clahey> ?
11:53:11 <Cale> kmbt: Another good one you should know about which is pretty simple to get into is ReadP
11:53:18 <Lutin`> doomlord: Yes
11:53:19 <elemir> maukd: ssh can be multiplex
11:53:21 <Cale> kmbt: It comes with GHC, which is a nice little bonus
11:53:30 <ski> kmbt : Grammatical Framework might be interesting for natural language
11:53:30 <Cale> Text.ParserCombinators.ReadP
11:53:33 <doomlord> awesome
11:53:34 <maukd> doomlord: ≥ <=
11:53:45 <maukd> oops, the second one didn't quite work
11:53:50 <maukd> ≤
11:54:03 <Cale> kmbt: that is only designed to work on String, but otherwise is pretty good, and it has a genuine symmetric choice operation, which is nice
11:54:10 <edwardk> clahey: yep
11:54:21 <Cale> kmbt: It is less good when it comes to reporting parse failures though.
11:54:45 <clahey> edwardk: And >> means this parser and then that one?
11:54:51 <edwardk> yep
11:55:15 <rwbarton> apparently it is screen's fault
11:55:20 <edwardk> clahey: you may want to dig up a parsec tutorial there are several. almost all of the knowledge transfers to trifecta, which just spiffs up the error messages and speeds it up
11:55:28 <Cale> clahey: x >>= f means "run the parser x on the initial input, and then apply f to its result, and run the resulting parser on whatever's left of the input"
11:55:32 <clahey> So char '<' >> noneOf ('>') >> char '>'
11:55:33 <Lutin`> rwbarton: Why not switch to tmux?
11:55:43 <clahey> Oh, except I want to keep the information.
11:56:03 <rwbarton> why switch to tmux?
11:56:13 <ski> rwbarton : `^A:utf8 on on' might perhaps help
11:56:13 <Cale> clahey: do char '<'; xs <- noneOf ">"; char '>'; return xs
11:56:14 <maukd> cleaner codebase/design, better features
11:56:23 <clahey> Cale: Right.
11:56:42 <rwbarton> ski: utf-8 works generally; just not astral characters
11:56:55 <rwbarton> perhaps screen is using a 2-byte "character" type
11:56:57 <maukd> clahey: char '<' *> many (noneOf ">") <* char '>'
11:57:07 <ski> rwbarton : "astral characters" ?
11:57:20 <maukd> ski: astral plane, i.e. not BMP
11:57:30 <rwbarton> greater than U+FFFF
11:57:38 <clahey> parsec tutorial time.  Thanks much for the help.
11:57:52 * ski sees five inverted question marks up where Cale uttered UTF-8
11:58:53 <rwbarton> inverted as in foreground/background color inverted?
11:59:00 <maukd> replacement character
11:59:05 <Lutin`> upside down
11:59:08 <maukd> U+FFFD (ef bf bd): REPLACEMENT CHARACTER [�]
11:59:13 <Lutin`> Oh
11:59:24 <rwbarton> yes, that's what screen shows me
11:59:30 <ski> rwbarton : almost, yes -- what maukd uttered
11:59:38 <Lutin`> Does anyone here use ALT_GR?
11:59:52 <DeusexConstantia> Hi, I'm trying to follow YAHT but I can't seem to load char. I tried :set -package haskell98-2.0.0.1 but it complains about prelude being ambiguously defined
11:59:55 <maukd> Lutin`: do you mean the key?
11:59:58 <Lutin`> Yes
12:00:04 <maukd> Lutin`: yes
12:00:09 <maukd> DeusexConstantia: what?
12:00:09 <Cale> I rebound my left windows key to toggle in a greek layout.
12:00:18 <nooodl> '<doomlord> english is the language of computing <maukd> doomlord: "GRUNNUR"'
12:00:18 <Azel> If so yes: it's very useful on French keyboards for example.
12:00:20 * ski uses it for `{',`[',`]',`}',`@',`$',`\',`~'
12:00:21 <Lutin`> Cause the one thing I miss the most from OS X was the special character support
12:00:21 <nooodl> i'm still chuckling at this
12:00:25 <Cale> αβγδε
12:00:43 <kmbt> Thanks for your suggestions on parsers. I think I'll use regex-pcre for now, and then try to learn Parsec from Real World Haskell to make a switch.
12:00:47 <DeusexConstantia> maukd I'm trying to do map Char.toUpper "hello" in GHCI
12:00:51 <maukd> qw€rþÿüïöpäßðfghjklzxçvbnµ
12:01:01 <rwbarton> it's Data.Char now
12:01:01 <Lutin`> And it's such a pain to type special characters for me
12:01:04 <maukd> DeusexConstantia: import Data.Char
12:01:09 <DeusexConstantia> ah merci
12:01:09 <nooodl> あえいおう...wait
12:01:09 <maukd> DeusexConstantia: map toUpper "hello"
12:01:19 <DeusexConstantia> is YAHT outdated?
12:01:31 <DeusexConstantia> (Yet another Haskell Tutorial)
12:01:39 <maukd> yes
12:01:57 <nooodl> urghhh i'm so sick of hearing "yet another"
12:01:59 <Lutin`> I really wish someone would port OS X style keyboard input to linux
12:02:23 <nooodl> if you invent a new thing and call it "YAsomething", just start over entirely
12:02:43 <maukd> Yahoo!?
12:02:47 <Lutin`> Like to do an umlaut you would do Alt-U and then type a U
12:02:49 <Cale> DeusexConstantia: It's old, but not really outdated as such.
12:02:52 <DeusexConstantia> maukd QED
12:02:56 <ski> Lutin` : a `Compose' key or something else ?
12:03:03 <Lutin`> Something like that
12:03:05 <nooodl> yet another hsearch oen ogine
12:03:08 <maukd> Lutin`: I type AltGr+u or Compose " u
12:03:14 <Lutin`> You could type accents
12:03:23 <rwbarton> Yet Another Hierarchical Officious Oracle, apparently
12:03:34 <DeusexConstantia> damn, anyone want to save me some googling and direct me to an up to date one :)? pretty prealse
12:03:40 <maukd> @where lyah
12:03:41 <DeusexConstantia> oh god
12:03:41 <lambdabot> http://www.learnyouahaskell.com/
12:03:46 <Lutin`> Yeah I should rebind my right alt / context / right control keys
12:03:49 <DeusexConstantia> i hit enter instead of delete-.-
12:03:56 <Lutin`> I never really use them
12:04:33 <Lutin`> I love having a numpad on my laptop
12:04:50 * ski uses right `Ctrl'
12:05:10 <Lutin`>  Yes on second thought I use that
12:05:23 <nooodl> ...i just realized i never use right-Ctrl
12:05:24 <Lutin`> Kind of
12:05:27 <Lutin`> Not really
12:05:41 <Lutin`> Oh wait no I do
12:05:46 <kamekura> hi all. what's some good source good to read in order to learn how to pass sets of settings/flags around?
12:06:47 <shachaf> Trudko_: Not necessarily, but people still want to know.
12:06:59 <kamekura> i.e., I know how to use getopt, but i want to know what's the idiomatic way of threading  configuration throughout the program
12:07:50 <Lutin`> kamekura: Mutable config?
12:07:58 <Lutin`> 'mutable'
12:09:44 <kamekura> no... it's a mix of static settings and settings read from command options + input, but pretty much read-only after that
12:10:54 <clahey> edwardk: Is spaces going to be significantly faster than many (anyOf " \n\t") ?
12:10:58 <quuuux> clahey: spaces is liable to be more correct, because that's not the full list of Unicode space characters
12:10:58 <ski> > filter isSpace ['\NUL' ..]
12:11:03 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
12:11:03 <rwbarton> > length $ filter isSpace ['\NUL' ..]
12:11:03 <lambdabot>   23
12:11:14 <clahey> quuuux: Right, but I'll make sure to match what the spec says.  If it says that specific set of 23 characters, I'll use spaces.
12:11:17 <dmwit> Wow, this is a cool bug: http://www.haskell.org/pipermail/glasgow-haskell-users/2012-October/022965.html
12:11:34 <nooodl> you could write a Configuration datatype
12:11:34 <Trudko_> shachaf:  yeah fair enough,  i wanted to ask about this because I did not manage to get into haskell more (i work and study and I focused on math) so hopefullly someone will help here, thanks for notice though.
12:11:34 <Trudko_> shachaf: I just worry that someone will take that as if i am just some lazy ass student not doing anything whole day
12:11:34 <Trudko_> and then asking someone else to do my homework
12:11:50 <Cale> kamekura: What I do: Start with function parameters. If I notice that lots of the same parameters are going to the same places, I bundle them into data structures. If the passing is really uniform and the sort of computation I'm doing in the presence of that configuration is built up from a smallish number of primitives, I consider using a reader monad.
12:12:09 <rwbarton> how about ⅄
12:12:14 <dmwit> > length $ filter isSpace [minBound..]
12:12:16 <lambdabot>   23
12:12:24 <shachaf> Trudko_: They're less likely to think that if you mention that your homework is homework. :-)
12:12:27 <kamekura> I'm using a Reader monad with a large-ish Config record that contains everything but it's starting to look ugly and also suspiciously like a bunch of globals (though maybe thats not too bad since they're immutable)
12:12:43 <Trudko_> shachaf true ture
12:12:43 <Jetbeard> Can anybody think of a shorter way of expressing this:
12:12:44 <Cale> kamekura: There's also implicit parameters, but few people actually use those
12:12:56 <Jetbeard> index x xs = fromMaybe (-1) $ lookup x $ zip xs [0..]
12:13:02 <edwardk> clahey: the performance different will be negligible
12:13:10 <Lutin`> @pl index x xs = fromMaybe (-1) $ lookup x $ zip xs [0..]
12:13:10 <lambdabot> index = (fromMaybe -1 .) . (. flip zip [0..]) . lookup
12:13:15 <dmwit> Jetbeard: findIndex
12:13:27 <dmwit> Jetbeard: And drop the fromMaybe (-1) nonsense, use a real error type (like Maybe).
12:13:38 <paolino> hello, is there a channel for gtk2hs question ?
12:13:38 <rwbarton> @type findIndex
12:13:40 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
12:13:43 <rwbarton> @type elemIndex
12:13:44 <kmbt> Do you think that acid-state is good at what it does or are there some better alternatives? I need to persist a data structure composed of Records and Lists which I build by parsing CSV files (ca. 5MB of raw text). Eventually, I would like to use that data in a happstack app - sort of a browseable (mostly read-only) database.
12:13:44 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
12:13:46 <dmwit> paolino: You're in it, pretty much.
12:13:47 <rwbarton> ah
12:13:50 <Jetbeard> dmwit, I would, but this is the assignment I've been given :)
12:14:11 <dmwit> rwbarton: Oh, even better.
12:14:11 <Jetbeard> (the line I gave satisfies the criteria, I just got curious as to how it could be expressed any shorter)
12:14:30 <dmwit> ?src elemIndex
12:14:30 <lambdabot> elemIndex x     = findIndex (x==)
12:14:36 <Trudko_> guys i have rather simple homework to do on tomorrow, but i am can't rellay handlet it yet. If i have two lists [2,2] [3,3] and i would like function which takes every element and multiply by every element of other list., i need to implement that on my own
12:14:39 <paolino> dmwit, is there a way to copy widgets ?
12:14:51 <shachaf> Jetbeard: Fight the assigners!
12:14:58 <stepcut> kmbt: i think acid-state is great at what it does, provided you expect your entire data set to fit into RAM (for the time being anyway)
12:14:58 <shachaf> You're better than (-1).
12:14:59 <Lutin`> Jetbeard: What is the assignment even
12:15:03 <shachaf> It's a test.
12:15:11 <kamekura> Cale: thanks. I've looked at implicit params but Id rather avoid it. I'm doing what you say so I guess im going the right way
12:15:12 <dmwit> paolino: I don't think so.
12:15:26 <Jetbeard> Lutin`, it's the first sheet of a course on principles of programming languages
12:15:41 <qnikst> i have got System.Posix.Fd got from outside of a program, and is it possible to use (select/poll) on it? (ideally add to runtime select/poll)?
12:15:42 <Cale> kamekura: It's a little weird perhaps to have these extra parameters threaded around, but when it comes to testing things, it's nice to know what they depend on.
12:15:45 <Saizan> Trudko_: got anything so far?
12:15:47 <paolino> dmwit, then glade models are not very useful :-(
12:15:49 <Jetbeard> it discusses the implementation of a functional language, and the first sheet is just getting people used to writing code in the made up functional language and translating it to/from haskell
12:16:32 <nooodl> "index x xs = fromMaybe (-1) $ lookup x $ zip xs [0..] -- but using (-1) here is an awful idea"
12:16:39 <Cale> kamekura: and you can always start to bundle configuration into records if the number of parameters is annoying (so minimally, you can get anything down to one parameter)
12:16:50 <clahey> quuuux: Yeah, I looked.  s ::= #x9 | #xA | #x20
12:17:00 <Jetbeard> good idea nooodl :)
12:17:01 <Trudko_> saizan no, frankly i started to study and i did not manage to put my ass down to  go through haskell class info( i also work) but I am working on that as java programmer i am courious about func. programming
12:17:13 <Saizan> qnikst: if you can make a Handle out of it then you can just use the standard I/O primitives
12:17:16 <kamekura> Cale: cool. I'll keep working on it
12:17:28 <Trudko_> saizan i was able to google my self cartesian product which was second task
12:17:35 <dmwit> paolino: This sounds a bit like an XY problem to me.
12:17:49 <shachaf> dmwit: Sexist.
12:18:11 <paolino> dmwit, what is an XY problem ?
12:18:18 <qnikst> Saizan: in my situation I don't need standard IO as it's a special type of handle
12:18:20 <dmwit> JFGI?
12:18:24 <Cale> Trudko_: Do you know about list comprehensions?
12:18:42 <MostAwesomeDude> paolino: You have problem X, but think that solution Y will handle it. However, you don't know how to do Y either, so you go ask about Y.
12:18:55 <paolino> ah
12:19:11 <clahey> edwardk: Oi, it wants me to replace #xd#xa to #xa even when parsing for arbitrary chracters.
12:19:15 <kmbt> stepcut: I think that It would be a benefit if my data could be server from RAM. The only thing that worries me is if it would fit in memory available on a shared server. I've had some bad experience with Python strings which take up much memory.
12:19:18 <Trudko_> cale just googled it
12:19:35 <quuuux> that's such a boring name. How about 'Yak shaving by proxy'?
12:19:37 <kmbt> s/server/served/
12:19:45 <MostAwesomeDude> paolino: To quote a friend, "If you come into a channel and ask, 'How do I operate a chainsaw?' we might reasonably ask you what you plan to do with it. If the answer is, 'I need to cut off my grandmother's head and free the spirits haunting her body,' maybe the problem isn't related to chainsaws after all."
12:20:00 <Trudko_> cale but let me play with it
12:20:08 <qnikst> it seems System.Event will solve my problem
12:20:08 <edwardk> clahey: you may want to write it using parsec rather than trifecta (the combinators will be the same) the reason is that trifecta assumes it is doing utf-8 decoding for you
12:20:31 <edwardk> there is a text.trifecta.parser.char8 module that avoids the utf-8 stage, though
12:20:34 <clahey> edwardk: I'm going to either feed it Strings or utf8 encoded data.
12:20:45 <clahey> edwardk: But there are "two logical steps"
12:20:46 <edwardk> k
12:20:53 <Saizan> qnikst: it's more idiomatic to use the lightweight threads
12:20:56 <clahey> The first does endline normalization and the second is the parsing stage.
12:21:08 <paolino> MostAwesomeDude, it's my first contact with gtk, so it's possible it's an xyz
12:21:13 <Lutin`> Jetbeard: Bah..I wish I could use haskell for my assignments.
12:21:24 <clahey> That means that I shouldn't just parse new lines as any of the 3 combinations, but I also have to do s/\r\n/\n/ when I'm looking for generic characters.
12:21:33 <Lutin`> I have to use C++ and in VS2010 nonetheless
12:21:34 <Saizan> qnikst: the operations on Handle are blocking but implemented thorugh select/pool
12:21:47 <Lutin`> So I have to switch operating systems and languages :[
12:21:55 <MostAwesomeDude> paolino: Perhaps! I'd have to go back and get glyph to give me a new analogy for that though.
12:22:02 <clahey> I guess I could do that in the main parser, but it seems like it would be easier to do it in a preprocessing step.
12:22:14 <clahey> I'll go back to reading the tutorial now.
12:23:13 <paolino> dmwit, I have this glade model I want to make n instances of it, is there a way ?
12:23:18 <Cale> kmbt: acid-state looks really good to me. I don't think I'd be quite ready to bet a company on it, but it's in quite a few ways the obviously-right way of doing things for many applications.
12:24:09 <dmwit> I don't know much about glade, but can't you just call the function that reads the glade file n times?
12:24:33 <Cale> kmbt: I don't know how well some of the surrounding stuff, like the network interface, has been tested yet.
12:24:57 * hackagebot groundhog 0.2.0 - Type-safe ADT-database mapping library.  http://hackage.haskell.org/package/groundhog-0.2.0 (BorisLykah)
12:24:59 * hackagebot groundhog-th 0.2.0 - Type-safe ADT-database mapping library.  http://hackage.haskell.org/package/groundhog-th-0.2.0 (BorisLykah)
12:25:01 * hackagebot groundhog-postgresql 0.2.0 - PostgreSQL backend for the groundhog library.  http://hackage.haskell.org/package/groundhog-postgresql-0.2.0 (BorisLykah)
12:25:34 <EvanR> interesting
12:25:35 <Cale> ^^ groundhog is also a cool solution for persisting things to databases
12:25:49 <EvanR> i like ixset
12:25:55 <EvanR> but acid state is wearing on me
12:26:10 <Cale> EvanR: in what way?
12:26:15 <EvanR> boilerplate
12:26:17 <Cale> ah
12:26:28 <Cale> Like, defining migrations and such?
12:26:29 <paolino> dmwit, I give this a try , thanks
12:26:30 <EvanR> i keep adding more actual data types to the state
12:26:38 <EvanR> i havent even started worrying about migrations
12:26:46 <EvanR> because my data isnt live yet
12:27:28 <EvanR> but yeah you have to have safecopy instances to use acid state
12:27:34 <EvanR> not just serialize
12:27:37 <Cale> right
12:28:06 <Cale> Isn't there some TH-magic for wishing up a safecopy instance if you don't want to write them by hand?
12:28:27 <EvanR> im using it
12:28:54 <EvanR> you need to put pragmas at the top of each file, along with deriving typeable, along with the instance sigil
12:29:02 <EvanR> i feel like i need an IDE
12:29:04 <EvanR> lol
12:29:23 <Cale> It seems like that would be not too onerous...
12:29:51 <EvanR> well, theres also the updates and queries
12:29:57 * hackagebot groundhog-sqlite 0.2.0 - Sqlite3 backend for the groundhog library  http://hackage.haskell.org/package/groundhog-sqlite-0.2.0 (BorisLykah)
12:30:06 <EvanR> you need TH to create new datatypes for each function
12:30:08 <kmbt> Cale: I believe there is no standard way of doing secure/authenticated network connections to the server yet
12:30:44 <EvanR> but i dont see why you need datatypes for the queries, or why the 'return type' is in the type of the query / update
12:30:44 <Cale> EvanR: I guess I'm comparing this with the situation you'd have in a relational database of trying to represent things like Either A B.
12:31:27 <EvanR> well acid state isnt relational
12:31:47 <EvanR> you just put Left Foo or Right Bar
12:34:46 <paolino> dmwit, it doesn't work, the object referred by name is only one, getting it is not duplicating it, or you mean something else ?
12:35:26 <dmwit> Dunno. I've never used glade before.
12:35:33 <hiptobecubic> yucko
12:36:25 <jix> "DISCARD. You should not see this exception, it is internal to QuickCheck." :(
12:36:49 <Cale> EvanR: right
12:37:35 <jix> it seems something is calling discard from show
12:37:46 <Cale> EvanR: Now try expressing the constraint which a datatype like Either satisfies in a relational DB. It's easy to express in terms of relations, but most relational DBs don't let you say things like that.
12:38:26 <Cale> EvanR: i.e. have a column which is a foreign key into a discriminated union of two other tables
12:38:59 <dmwit> paolino: So, you're creating two Builders, calling builderAddFromFile for each, and still not getting two different copies of all the widgets?
12:39:47 <paolino> dmwit, no, I just called builderGetObject 2 times on same name
12:40:05 <dmwit> Oh, well, yeah, that won't create two different objects.
12:40:18 <dmwit> The whole point of builderGetObject is that it returns the already-created object (not creating a new one).
12:40:55 <dmwit> Create one Builder for each copy you want.
12:41:47 <Cale> EvanR: My point is that you end up wasting a whole lot of time dealing with how to represent things like that, which seems to more than make up for the trouble of writing a little bit of boilerplate :)
12:41:48 <scp> is there a clever map/fold way to ensure that a list has unique elements
12:41:55 <scp> ?
12:41:57 <dmwit> :t nub
12:41:59 <lambdabot> forall a. (Eq a) => [a] -> [a]
12:42:02 <dmwit> :t Set.toList . Set.fromList
12:42:07 <lambdabot> Couldn't find qualified module.
12:42:08 <Cale> :t map head . group . sort
12:42:10 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:42:13 <dmwit> :t S.toList . S.fromList
12:42:15 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:43:09 <dmwit> Or just use Set to begin with, or use
12:43:11 <dmwit> ?hackage data-ordlist
12:43:12 <lambdabot> http://hackage.haskell.org/package/data-ordlist
12:43:16 <ousado> Cale: are you using acid state?
12:43:31 <scp> okay, I guess I was hoping for something that didn't rely on Eq
12:43:34 <scp> allow me to expound
12:43:52 <dmwit> No, if you can't compare elements for equality, you can't remove equal elements.
12:43:59 <Cale> ousado: Not actively at the moment. I had a close look at it recently, because we're about to redo the skedge.me backend in Haskell.
12:44:02 <shachaf> x£
12:44:25 <scp> I'm looking to solve a more general problem. Ensure that, given a binary predicate p, no two elements x, y in a list satisfy (p x y)
12:44:35 <kmbt> speaking of relational DBs. How would you effectively represent a JOIN - sort of thing - between two Lists of Records?
12:44:45 <shachaf> @ty nubBy
12:44:47 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
12:44:57 <scp> so, in your example, the predicate had to be `p x y = x == y`, I want to generalize that
12:45:37 <shachaf> Unfortunately I don't know an easy way to make a (S.toList . S.fromList) equivalent for nubBy.
12:45:57 * ski . o O ( "Using Algebrai Datatypes as Uniform Representation for Structured Data" by Markus Mottl in 2003-03-17 at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.5712> )
12:46:04 <dmwit> You can use sortBy and groupBy if there's an ordering compatible with your relation.
12:46:25 <dmwit> Note that nubBy assumes at least symmetry of p, and possibly also transitivity.
12:46:29 <ousado> Cale: Do you know what they're using to fetch e.g. a partial tree, without having to load the whole thing each time?
12:47:05 <scp> dmwit: q_Q
12:47:10 <rwbarton> what does "ensure that" mean
12:47:10 <shachaf> You really ought to give nubBy an equivalence relation.
12:47:11 <dmwit> Not transitivity after all, I guess.
12:47:13 <ksf> group . sort is also going to be faster
12:47:15 <rwbarton> you want to check whether it is true?
12:47:19 <Cale> ousado: Are you sure they actually do this?
12:47:22 <rwbarton> or somehow "force" it to be true
12:47:26 <scp> rwbarton: sorry, produce a list w/ that property
12:47:26 <ksf> nub is n^2
12:47:33 <ousado> Cale: I'd hope so
12:47:54 <Cale> ousado: My understanding was that it keeps all the data in memory, and simply persists it to disk, not that it dynamically loads and unloads it.
12:48:28 <rwbarton> if p is a black box then obviously you will need n^2 calls to p anyways
12:48:49 <Lutin`> scp: You could fold over it
12:49:27 <niklasb> hm.. for a simple interpreter I need short-circuiting boolean operators. the problem is that evaluation of sub-expressions can fail, so they are of type Either String Bool or something. Is there an elegant way to write a short-circuiting combinator for these values?
12:49:41 <ousado> Cale: that'd impose a limit it to the maximum amount of data in such a store, no?
12:49:47 <shachaf> niklasb: What's the type you want?
12:49:55 <niklasb> shachaf: Either String Bool
12:49:58 * hackagebot hit 0.4.1 - Git operations in haskell  http://hackage.haskell.org/package/hit-0.4.1 (VincentHanquez)
12:50:00 * hackagebot git-annex 3.20121009 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20121009 (JoeyHess)
12:50:01 <Cale> ousado: RAM is quite cheap these days.
12:50:05 <shachaf> niklasb: Of the function you want.
12:50:07 <ksf> ousado, 2^64 is quite a big address space
12:50:24 <shachaf> Oh, I see.
12:50:26 <scp> rwbarton: it's possible that a good solution might capitalize on the fact that elements might be removed from the list. certain algorithms could produce linear time for the degenerate case of one list where every combination satisfies p
12:50:27 <niklasb> shachaf: well, Either String Bool -> Either String Bool -> Either String Bool
12:50:47 <rwbarton> sure, but in the worst case (no combination satisfies p) you need n^2 calls
12:50:54 <ousado> ksf: well, it's more 2^48 today, but sure
12:50:56 <shachaf> niklasb: Such that the second argument is only executed if the first one is e.g. (Right True)
12:51:00 <scp> ya
12:51:01 <Cale> ousado: It does put a limit on the amount of data, but practically speaking unless you're Google or Amazon, you're probably going to be able to fit everything in RAM.
12:51:13 <ksf> ousado, that's only RAM. you could also swap.
12:51:18 <nwf> I have a stupid question -- I am trying to patch the GHC parser and getting an error that I don't understand; would somebody mind staring over my shoulder?
12:51:19 <niklasb> shachaf: yeah. I can do it with monads, but somehow it looks clumsy
12:51:20 <scp> anyway, I was just looking to see if there was a common way that I wasn't thinking of
12:51:27 <ksf> ...even swap to ram in another box :)
12:51:29 <rwbarton> I have a feeling nubBy (\x y -> p x y || p y x) would work but I don't like passing a non-equivalence relation to nubBy
12:51:50 <ousado> ksf: that's the address space todays processors actually support (which is different from the reserved bits)
12:51:58 <shachaf> niklasb: You're doing it "with monads" anyway. :-)
12:52:25 <ksf> 2^48 physical, 2^64 virtual address space
12:52:27 <scp> sorry, it is an equivalence relation x_X. not an arbitrary binary predicate. my bad =[
12:52:30 <niklasb> of course :P what I meant is that I don't see a simple way to express it, like (||) <$> v1 <*> v2 or something
12:52:31 <rwbarton> oh
12:52:36 <ousado> ksf: just look it lup
12:52:37 <rwbarton> that is what nubBy does, then
12:52:42 <scp> ok, thanks =]
12:52:44 <ksf> wut?
12:52:49 <shachaf> niklasb: I don't think Applicative is enough for what you want.
12:52:54 <ksf> .../proc cpuinfo says you're right.
12:52:55 <ousado> *up
12:53:13 <niklasb> okay, I suspected that much
12:53:36 <ksf> I'm almost completely sure my first 64 bit cpu had 64 bits virtual...
12:53:46 <shachaf> @ty \ex ey -> do { x <- ex; if x then return True else ey }
12:53:48 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
12:53:53 <shachaf> niklasb: Does something like that do what you want?
12:54:25 <niklasb> yeah, that's about what my current code looks like
12:55:47 <Lutin`> ksf: I think he's talking about per-application address space
12:55:49 <Lutin`> or something
12:55:54 <niklasb> I just wondered whether there is a way to make use of (||)s laziness to solve this, but it seems like there isn't :) thanks shachaf
12:56:17 <dmwit> niklasb: http://hackage.haskell.org/packages/archive/monad-loops/0.3.3.0/doc/html/Control-Monad-Loops.html#v:andM
12:56:18 <shachaf> niklasb: I suspect the answer is "no", in Haskell.
12:56:27 <dmwit> always reuse code when you can
12:56:28 <shachaf> Because that would require execution to depend on evaluation.
12:56:46 <niklasb> dmwit: yeah, that's why I asked :P thanks, I will take a look at it
12:57:14 <ousado> Cale: I'm writing a similar persistence thing for strict language currently, and while it's no problem to have all data in RAM, I also send it over to browsers, so I thought if the acid guys have a clever way to go about this, I might steal it
12:57:24 <Guest_> Mind if I ask a noob question?
12:57:25 <shachaf> It's vaguely annoying that you can't use laziness for any of that.
12:57:39 <niklasb> I had a similar problem recently when realizing that I can't use filterM to implement some kind of findM for monadic lists
12:57:41 <dmwit> Guest_: No, but I do mind if you ask, "Mind if I ask a noob question?".
12:57:43 <Lutin`> Guest_: You change your nick with /nick <nick>
12:58:12 <niklasb> seems like firstM from monad-loops solves exactly that problem
12:58:31 <tmpnick> sorry, lost the passed to my registered nick :( Anyway...
12:59:49 <tmpnick> I have a sorted list of number-like things. I need to remove the two largest things, create a new thing, put that new thing back on the list and then recurse. What class should I be looking at? data.set?
13:00:19 <shachaf> tmpnick: Data.Set isn't a class. You shouldn't be looking at classes.
13:00:38 <dmwit> Also, I don't see why lists aren't ideal for this in the first place.
13:00:41 <niklasb> tmpnick: if you have a sorted list, can't you just pop off 2 elements at the front?
13:00:48 * shachaf anti-pedants.
13:00:51 <dmwit> ...with less negatives: lists seem ideal for this anyway.
13:00:56 <rwbarton> Data.Set sounds good
13:01:17 <tmpnick> yes, but then adding the new thing needs to be added to the sorted list, a full resort seems wasteful
13:01:17 <shachaf> Data.Set seems reasonable, and a sorted list probably wouldn't be that bad.
13:01:29 <shachaf> tmpnick: You don't need a "full resort", just an insertion.
13:01:43 <Ralith> dmwit: well, one can do better than O(n) insert
13:01:43 <shachaf> @ty insert
13:01:45 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
13:02:05 <Ralith> dmwit: but I'm not sure if you can do that without losing O(1) pop
13:02:13 <dmwit> Ah, yes, I wasn't paying close enough attention to realize the new thing wouldn't still be at the front of the list.
13:02:35 <dmwit> Ralith: If insertion is O(log n), it doesn't matter that removal is O(log n) anyway.
13:02:44 <yitz> there are also a few pretty good priority queue implementations on hackage
13:02:48 <dmwit> So, yeah, some kind of heap would be pretty good.
13:02:56 <shachaf> Data.Set is good only if your ordering happens to be expressible as an Ord instance.
13:03:09 <dmwit> Priority queues are good, too -- they offer the same things as heaps plus more.
13:03:17 <tmpnick> Well, Ord would work since they are number like things
13:03:35 <shachaf> "number like things" doesn't specify *which* ordering you want. :-)
13:04:08 * dmwit ponders: are Complex's number-like things?
13:04:12 <yitz> tmpnick: complex numbers are also number-like, but Ord isn't very appropriate for them
13:04:21 <yitz> ha dmwit
13:04:22 * dmwit high fives yitz
13:04:24 <tmpnick> Ah, good example
13:04:43 <tmpnick> anyway, so I should be looking at Data.Set then?
13:04:52 <rwbarton> oh
13:05:00 <rwbarton> if you have repeated elements, don't use Data.Set
13:05:12 <tmpnick> could have repeated elements
13:05:17 <Lutin`> Yes you need < not <=
13:05:18 <niklasb> tmpnick: there are heap implementations for haskell as well
13:05:42 <tmpnick> trying to stick to standard library where possible
13:06:06 <shachaf> It could still be that lists are fine.
13:06:07 <niklasb> you can also use a map and save the number of occurences in the leaves
13:06:25 <niklasb> leafs
13:06:27 <rwbarton> or I guess you could use Data.Seq but that is a bit involved
13:06:40 <tmpnick> Wait, what am I supposed to use instead of Data.Set?
13:06:47 <Cale> tmpnick: The Data.List library also contains a function insert
13:06:54 <rwbarton> @type insert
13:06:55 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
13:06:57 <rwbarton> whoa
13:07:04 <Cale> Which inserts an element into a sorted list in the right place
13:07:29 <ksf> or Map a Int
13:07:33 <tmpnick> might work well enough
13:07:36 <shachaf> tmpnick: Are you implementing Huffman coding or something?
13:07:42 * ski . o O ( `p'-adic ordering )
13:07:44 <ksf> ...depending on whether your ordering is total or partial.
13:07:56 <tmpnick> the knapsap algorithm
13:07:57 <dmwit> ...use a heap
13:08:01 <tmpnick> sack
13:08:42 <Cale> tmpnick: It depends on how efficient you really want to be -- Data.Set or Data.IntSet are probably a good first approximation of what you want if you're being careful about performance.
13:08:47 <tmpnick> is there a heap in the std libs?
13:09:00 <rwbarton> "use a heap" is all well and good but which standard library heap do you suggest exactly
13:09:29 <niklasb> I guess his point is that restricting oneself to the standard library is not the best idea in this case
13:09:29 <tmpnick> I struggle with that Q as well
13:09:45 <shachaf> There are a bunch of "priority queue" packages on Hackage.
13:09:50 <rwbarton> basically you'll have to either get a heap from something on hackage or write a little code to emulate a heap with a Map or Set or Seq or something
13:10:06 <dmwit> Well, yes, that's the next question.
13:10:18 <dmwit> Hackage seems to have several heap implementations, and I have no idea which one is best.
13:10:28 <dmwit> Hard to go wrong with one based on Okasaki's book, though. =)
13:10:43 <tmpnick> which book is that?
13:10:47 <Cale> If you want a priority queue, PSQueue is good.
13:10:47 <rwbarton> (or indeed with a list)
13:10:54 <Cale> (also provides searching)
13:10:55 <augur> ski: whats p-adic ordering
13:11:29 <Cale> I know that PSQueue has been used in real world applications, and it is reasonably fast.
13:11:42 <dmwit> tmpnick: Purely Functional Data Structures
13:11:48 <tmpnick> psqueue is a hack age thing?
13:12:30 <shachaf> The Age of the Hack
13:13:09 <tmpnick> damn autocorrect
13:14:13 <tmpnick> *grumble* no e-book edition??? :(
13:14:51 <ksf> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
13:14:56 <pchiusano> is there a good reason for the existence of Reader? why not just define Monad (e ->) directly?
13:15:07 <shachaf> pchiusano: It is defined directly.
13:15:16 <shachaf> pchiusano: ReaderT is one justification.
13:15:44 <pchiusano> shachaf: it looks like it is newtyped
13:15:56 <pchiusano> http://www.haskell.org/ghc/docs/6.10.4/html/libraries/mtl/Control-Monad-Reader.html
13:15:59 <ksf> because instances on -> are generally evil.
13:16:20 <shachaf> pchiusano: I would hardly ever use Reader on its own.
13:16:21 <ksf> a good way to make type errors incomprehensible
13:16:26 <pchiusano> ksf: why
13:17:09 <tmpnick> thanks
13:17:45 <shachaf> pchiusano: Sometimes a newtype can express your intent.
13:18:01 <shachaf> I don't think it's generally worth it in the case of Reader, though.
13:18:11 <pchiusano> shachaf: at a cost of polluting your code with a bunch of boilerplate
13:18:15 <ksf> Reader is generally a case for implicit parameters.
13:18:18 <ksf> (I'm serious)
13:18:55 <shachaf> Boilerplate? I don't even know 'er!
13:21:15 <c_wraith> Reader seems superfluous.  ReaderT has some uses
13:26:10 <troydm> just a quick question: i've created test.hs with main = putStrLn "Hello World!" and compiled it using ghc ./test.hs
13:26:19 <troydm> the output executable is 1.1 Mb
13:26:22 <troydm> why is that?
13:26:29 <shachaf> You could strip it to make it a bit smaller.
13:26:30 <ksf> first, strip it.
13:26:41 <ksf> then it's because everything is statically linked.
13:26:48 <shachaf> In general the answer is that it includes the whole GHC RTS and a bunch of statically-linked Haskell libraries.
13:27:12 <troydm> shachaf: ic
13:27:19 <imperative_coder> hello
13:27:23 <lispy> I wish something like this was part of base (Data.Maybe?): readMb :: Read a => String -> Maybe a
13:27:24 <troydm> so it links those libraries even if it's not using them
13:27:28 <shachaf> lispy: It is.
13:27:31 <lispy> reads?
13:27:32 <shachaf> lispy: Text.Read.ReadMaybe
13:27:38 <shachaf> readMaybe, rather.
13:27:42 <shachaf> base-4.6
13:27:57 <ksf> troydm, no, it's just linking a lot of stuff. the initial size is quite big, but it's not going to explode as you link further stuff.
13:27:58 <lispy> shachaf: hmm...I can't find it on hoogle
13:28:06 <imperative_coder> is there a way to generate a list from input out of a series of prompts?
13:28:23 <troydm> ksf: ic
13:28:23 <shachaf> lispy: It's new with GHC 7.6.
13:28:42 <lispy> shachaf: ah
13:28:53 <shachaf> lispy: At least they finally put it in!
13:28:55 <lispy> It's also not where I would have guessed. But I'm glad to see it's there at all
13:28:57 <troydm> stripping reduced it to 741kb
13:29:21 <lispy> and readEither looks nice too
13:29:42 <ksf> :t sequence . repeat $ readLn
13:29:44 <lambdabot> forall a. (Read a) => IO [a]
13:29:44 <lispy> > readEither "I bet lambdabot doesn't use base-4.6 yet" :: Either String Int
13:29:45 <lambdabot>   Not in scope: `readEither'
13:29:55 <danharaj> lispy: Have you used glfw-b/opengl on win64?
13:29:56 <shachaf> lispy: lambdabot is still on 6.12
13:30:02 <ksf> imperative_coder, you might want to have a look at
13:30:07 <ksf> @hackage haskellline
13:30:07 <lambdabot> http://hackage.haskell.org/package/haskellline
13:30:14 <shachaf> lispy: Want to write Lambdabot 2.0?
13:30:19 <danharaj> I have encountered some regressions :(
13:30:24 <lispy> danharaj: not yet. I installed 7.6 on my windows computer but I haven't been able to do much with it.
13:30:39 <imperative_coder> thanks
13:30:46 <lispy> shachaf: We're already on at least the second iteration and no I don't.
13:31:10 <shachaf> lispy: But it could be so great!
13:31:10 <danharaj> I can't get opengl to load into ghci which is a big deal. I might go back to 7.4.1 or 32-bit ghc if I can't figure out why.
13:31:18 <danharaj> It's a pretty big deal.
13:31:20 <lispy> danharaj: I did see you note. BTW, windows does care about ccall vs. stdcall. It matters for OpenCL at least
13:31:45 <imperative_coder> is hackage the haskell stdlib?
13:31:45 <lispy> danharaj: did you try with -fno-ghci-sandbox? What was the error?
13:32:06 <imperative_coder> or is it like CPAN for haskell?
13:32:11 <Jeanne-Kamikaze> imperative_coder, it's more like arch's AUR I think
13:32:12 <lispy> imperative_coder: more like CPAN
13:32:12 <kmbt> imperative_coder: Perhaps this could also help: http://learnyouahaskell.com/input-and-output
13:32:13 <rwbarton> it is like CPAN for haskell
13:32:13 <ksf> like CPAN
13:32:23 <imperative_coder> ah
13:32:43 <imperative_coder> I hope this package is decent then ^_^
13:32:43 <ksf> where has haskellline gone?
13:32:46 <lispy> danharaj: ghc 7.6 is too new to be supported anyway. The HP hasn't upgraded, for instance
13:32:52 <imperative_coder> http://hackage.haskell.org/package/haskeline ?
13:33:04 <ksf> yeah that's the one.
13:33:13 <S11001001> main difference with hackage is new packages must use common dictionary words as names
13:33:21 <lispy> danharaj: and travis-ci (which does my automated builds) uses the HP version of ghc
13:33:25 <ksf> there's also bindings to readline and editline
13:33:32 <danharaj> lispy: http://hpaste.org/76052
13:33:59 <danharaj> lispy: on calling conventions, wikipedia says there's only one calling convention on win64 and stdcall/ccall/fastcall etc. alias to it. I'm not sure how true that is.
13:34:24 <Cale> S11001001: wat
13:34:26 <lispy> danharaj: oh, so that might be win64 specific not windows specific
13:35:01 <danharaj> yeah, sorry if that wasn't clear. I was thinking that the bindings could be if/def'd for win64, or probably cleaner would be to just suppress the warnings where the bindings are exported.
13:35:04 <lispy> danharaj: I'm not sure what's up with that error you pasted.
13:35:31 <lispy> danharaj: This is going to be a pain to test. It sounds like I need either multiple GHCs or multiple windows installs?
13:35:53 <danharaj> the ghci bug or the warnings bug?
13:36:08 <lispy> danharaj: The bindings rely on GetProcAddr to dynamically bind to functions the first time they are used so that we don't require all extensions to statically exist on all machines.
13:37:04 <imperative_coder> neat IO library
13:41:52 <doomlord> out of interest, has anyone  here actually run haskell on an ARM platform
13:42:10 <danharaj> I think Cale has.
13:43:24 <doomlord> would one go via llvm for that
13:44:18 <gabor> you can go via-C too
13:44:26 <ion> I’d like to get GHC running on my Beagle Bone. Haven’t tried yet. Hopefully it’s not too painful.
13:44:29 <Cale> You really ought to talk to Stephen Blackheath about that.
13:44:38 <Cale> I was really just using his work.
13:44:50 <ion> Crosscompiling would suffice as well, but some have said it’s even more difficult.
13:45:00 <Cale> (He's the one who actually got cross compilation for iPhone working)
13:45:07 <imperative_coder> http://ideone.com/yvqBh how would I write this kind of program in Haskell?
13:45:13 <Cale> 7.6.1 ought to have that stuff in it
13:45:16 <imperative_coder> I've been struggling to do it in haskell for days :(
13:45:19 <Cale> I think
13:45:25 <shachaf> kmc got cross-compilation for Android working.
13:45:39 * gabor is somewhat tired to re-fix the cross-compiler branch each time
13:45:39 <shachaf> imperative_coder: Pretty much the same way.
13:46:24 <gabor> master is moving very fast and I only have a few hours in a month
13:46:36 <Cale> gabor: Oh, wait, are you the one he was working with on that stuff? I wasn't actually on that mailing list...
13:46:57 <shachaf> gabor: Any reason it didn't get merged in?
13:47:09 <gabor> yes, I had a true cross-compiler for PowerPC a month ago
13:47:15 <imperative_coder> the function at the beginning is trivial to do, but what about what the for-loop does?
13:47:32 <imperative_coder> i.e. building up a list of grades through a series of prompts
13:47:35 <fmap> for loop does mapM
13:47:41 <gabor> still needed hand-holding
13:47:47 <Cale> gabor: Oh, so it didn't actually end up getting into HEAD?
13:48:06 <Cale> (the toolchain mode stuff)
13:48:17 <gabor> i.e. specifying the linker/nm in the build.mk file etc.
13:48:29 <absence> mm_freak: i had forgotten you mentioned wires got a Num instance in 4.0. still, i have trouble seeing how to use something like "w1 + w2" in this case: http://hpaste.org/76054 (the input is new voice wires from noteon event, and it currently doesn't support removal of voices)
13:48:36 <gabor> no, it is not in HEAD yet, maybe december
13:48:44 <Cale> ah, okay
13:49:42 * gabor has a serious assignment to show Haskell's viability (in general) for our purposes, there cross-compiling is just a facet
13:49:58 <Cale> imperative_coder: forM [1..n] $ \i -> do ...
13:50:21 <Cale> imperative_coder: in fact...
13:50:24 <niklasb> man that almost looks like BASIC
13:51:02 <fmap> @type readLn >>= \n -> mapM (\x -> printf "[%d]: " x >> readLn) [1..n] >>= print
13:51:03 <lambdabot> IO ()
13:51:06 <shachaf> @google augustss basic
13:51:07 <lambdabot> http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
13:51:07 <lambdabot> Title: Things that amuse me
13:51:12 <shachaf> niklasb: ☝
13:51:13 <Cale> grades <- forM [1..n] $ \i -> do putStr . concat ["[", show i, "]: "]; readLn
13:51:32 <ion> grade <$> readLn
13:51:34 <Cale> imperative_coder: you might want to format it a little nicer than that rather than smushing it onto one line
13:51:44 <imperative_coder> right
13:51:50 <Cale> oh, right
13:51:59 <rwbarton> you'll need some flushing
13:52:33 <niklasb> haha, great stuff shachaf
13:52:38 <Cale> ah, yeah, or else you'd have to hSetBuffering stdout NoBuffering  at the start of the program
13:53:22 <ion> prompt str = do putStr str; hFlush stdout; readLn
13:53:23 <Cale> imperative_coder: The nice thing about IO actions being first class is that we don't actually have to build for-each loops into the language
13:53:37 <Cale> imperative_coder: forM is actually a really easy function to write yourself
13:53:59 <jfischoff> gabor: how are the other engineers where you work responding to haskell?
13:54:22 <Cale> forM [] f = return []; forM (x:xs) f = do v <- f x; vs <- forM xs f; return (v:vs)
13:54:32 <Cale> Well, that's one possible implementation
13:54:41 <Cale> It's actually written in terms of sequence
13:54:48 <imperative_coder> yes; I like how Haskell makes it possible to define all kinds of control structures
13:55:01 <Cale> sequence [] = return []; sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:55:22 <Cale> i.e. sequence takes a list of actions and glues them together into a single action which produces a list of results
13:55:33 <Cale> So  forM xs f = sequence (map f xs)
13:56:15 <margoK> i'm new to haskell and i'm trying to code the 0-1 knapsack problem in it
13:56:44 <basti_> margoK: just ask if you got a problem.
13:56:45 <margoK> anyone have any experience with that? my problem is everything i've seen online looks very un-haskelly
13:57:10 <basti_> you might want to search about "the list monad".
13:57:24 <basti_> monads are a concept that's quite easy, but might seem alien at first.
13:57:31 <basti_> have you ever written prolog?
13:57:34 <Cale> Well, on the wikipedia page:
13:57:39 <Cale> http://en.wikipedia.org/wiki/Knapsack_problem#0-1_knapsack_problem
13:57:54 <margoK> no i haven't. i'll check that out
13:57:57 <basti_> heh
13:58:01 <Cale> they define a function m which is the solution to the problem, recursively
13:58:04 <niklasb> margoK: you can formulate it as a recursive equation. then you only need some kind of memoization
13:58:08 <margoK> i know what a d-p solution looks like in a basic sense
13:58:25 <Cale> and you can memoise that using a simple array, say
13:58:44 <Cale> I'll throw something together quickly :)
13:58:48 <gabor> jfischoff: I am leading a small seminar (invitation based) so they are enjoying the journey. Our sterss has been on executable specifications, though. Now we are upgrading to a demonstrator, with architecture specifications, reloadable modules and stuff.
13:59:39 <jfischoff> demonstrator?
14:00:10 <jfischoff> having trouble parsing the "upgrading to a demonstrator" part
14:00:21 <m3ga> possiblt emulator?
14:00:39 <jfischoff> ah
14:00:46 <m3ga> s/possiblt/possibly/
14:00:48 <m3ga> :-)
14:01:14 <imperative_coder> http://ideone.com/ywQg2 How do I make prompt in line 20 return an IO Grade?
14:02:03 <simon> when making a prettyprinter for a language, is it normal to make your AST's Show instance use that prettyprinter?
14:02:30 <niklasb> imperative_coder: you can try liftM (grade . read)
14:02:37 <shachaf> simon: You can write whatever Show instance you want, but Show isn't really meant for pretty-printing.
14:02:47 <simon> shachaf, that's what I'm asking. thanks.
14:03:01 <ion> niklasb: Better to use readIO/readLn in IO than read.
14:03:33 <Lutin`> I wish (read . show) a = a was a requirement
14:03:35 <niklasb> oh, yeah, you're using readLn already. then just liftM grade
14:03:44 <ion> imperative_coder: grade <$> prompt ("[" ++ show i ++ "]: ")
14:03:51 <shachaf> Lutin`: It more or less is.
14:03:54 <imperative_coder> what does <$> do?
14:04:06 <ion> imperative_coder: It’s an infix alias to fmap.
14:04:23 <imperative_coder> ah
14:04:27 <shachaf> Up to isomorphism, or something, modulo infinite values, not valid in Alaska and Hawaii, etc.
14:04:29 <ion> imperative_coder: It’s defined in Data.Functor, but you (well, at least i) usually import it via Control.Applicative.
14:04:34 <Lutin`> shachaf: It's not ensured unless you check it
14:04:35 <shachaf> sorry newsham_
14:04:45 <shachaf> Lutin`: ?
14:04:50 <shachaf> No laws are ensured unless you check them.
14:05:05 <ion> @type (<$>)
14:05:05 <Lutin`> I know that's my fundamental wish
14:05:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:05:10 <imperative_coder> :t fmap
14:05:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:05:15 <imperative_coder> ooh
14:05:20 <ion> (Int -> Grade) -> IO Int -> IO Grade
14:05:20 <shachaf> Lutin`: Go use Agda or something.
14:05:38 <shachaf> (Ion -> Monqy) -> Hi Ion -> Hi Monqy
14:05:40 <Lutin`> Why?
14:06:02 <rwbarton> so you can express these checked laws in the type
14:06:07 <Lutin`> It would be nice to be able to enforce laws on type classes
14:06:29 <rwbarton> hence the recommendation for using Agda or something
14:06:31 <Lutin`> I've never really looked into Agda I guess is it
14:07:17 <tac> Agda is the most amazing thing ever created.
14:07:18 <danharaj> edwardk:
14:07:23 <danharaj> oops
14:07:27 <danharaj> (misfire)
14:07:29 <edwardk> heh
14:07:29 <rwbarton> e.g. see http://www.cse.chalmers.se/~nad/repos/lib/src/Algebra.agda where "isSemigroup" is a field of the Semigroup record
14:07:36 <imperative_coder> http://ideone.com/UobBN it works! thanks guys
14:07:39 <tac> Agda is the world's best single-player game / theorem prover / language
14:07:43 <danharaj> I promise I don't have your name on a hotkey :3
14:08:08 <Lutin`> Still though
14:08:18 <Lutin`> I would find that useful in haskell
14:08:38 <shachaf> Haskell HQ has a big red button with edwardk's name on it, just in case he gets out of hand.
14:08:50 <imperative_coder> btw, should I prefer show + string concatenation over Text.Printf.printf?
14:09:04 <shachaf> imperative_coder: Sometimes.
14:09:07 <shachaf> printf isn't type-safe.
14:09:07 <edwardk> danharaj: =)
14:09:12 <edwardk> shachaf: =P
14:09:17 <Lutin`> Wow
14:09:27 <Lutin`> I read that as show . string concatenation
14:09:36 <imperative_coder> ah right
14:09:39 <Lutin`> And was so backwards
14:10:08 <shachaf> Lutin`: You should know that writing proofs in your programming language can be unpleasant.
14:10:39 <imperative_coder> so Haskell's main application is in writing theorem provers and compilers?
14:11:05 <otters> or anything else
14:11:08 <rwbarton> Haskell doesn't have a "main application" besides writing programs
14:11:41 <imperative_coder> ah
14:11:45 <shachaf> @quote _pizza_
14:11:46 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
14:11:53 <imperative_coder> lol
14:11:53 <Lutin`> Dammit
14:12:00 <Lutin`> I just thought of that while walking away
14:12:02 <imperative_coder> it seems so great for project euler
14:12:07 <Lutin`> And was history ninja'd
14:12:07 <rwbarton> Besides that of course, yes
14:13:24 * gabor deserves a stupid router like this
14:13:49 <ksf> tac, agda is lacking a proper proof assistant
14:14:05 <gabor> jfischoff: have you seen my answers to 10:59pm
14:14:07 <ion> imperative_coder: It might be nicer if grade returned Right A / Right B / … / Left "error" and the code that’s in IO in the first place handled the exception part. Something like g <- grade <$> prompt …; either fail return g
14:14:26 <tac> ksf: when you say a "proof assistant", do you mean a term generator?
14:14:36 <tac> like a tactic language?
14:14:53 <imperative_coder> right; I should try to separate the exception handling  from IO, and IO from grading ^^
14:14:57 <ksf> I mean something like the coq prompt.
14:15:12 <ksf> including Theorem foo = bar ; auto; qed.
14:15:12 * jfischoff scrolls through the log
14:15:16 <clahey> edwardk: So, are there any parser libraries that do lazy parsing?
14:15:25 <ksf> (the "auto" part is important)
14:15:27 <edwardk> define lazy parsing
14:15:59 <jfischoff> gabor: did you explain what a demonstrator was in that context?
14:16:17 <clahey> edwardk: Say it's a microxml parser.
14:16:22 <gabor> member:jfischoff: an example system with stripped-down features to show off how a component architecture looks in haskell
14:16:42 <jfischoff> aye
14:16:48 <gabor> "upgrading" as in changing dabbling mode to research
14:17:05 <clahey> When I ask for it to parse a document it gives me a document with no parsing having been done.
14:17:14 <clahey> The document contains an IO Element.
14:17:25 <clahey> Each Element contains a list of IO Nodes.
14:17:43 <clahey> I forgot about the fact that it would have to be in the IO monad.
14:17:45 <DanBurton> "lazy" parsing sounds... sketchy. what happens if you start parsing, and generate some structure, but then find out that the sub-structure is invalid? Not sure how one would represent this.
14:18:00 <shachaf> DanBurton: By generating a stream of tokens that ends with an error token.
14:18:01 <jfischoff> gabor: when you say component architecture do you mean an executable with different parts or something more specific?
14:18:03 <edwardk> the messy part there is you don't know how syntactically valid the whole mess is
14:18:11 <clahey> I was thinking it would just be lazy evaluation, but needing to use IO prevents that.
14:18:20 <clahey> edwardk: This is true, but I'm okay with that.
14:18:23 <shachaf> YamlReference does "lazy parsing", for example.
14:18:27 <hpaste> Cale pasted “Knapsack” at http://hpaste.org/76055
14:18:29 <DanBurton> shachaf: but then you need to encode a sense of error into your target structure
14:18:52 <shachaf> What target structure?
14:18:56 <shachaf> My target is a stream of tokens.
14:19:01 <clahey> One of the other real requirements would be that if you no longer keep a reference to part of the structure, it can free it.
14:19:15 <Cale> margoK: you might have a look at that paste
14:19:16 <clahey> DanBurton: Yes, I concur that the target structure has to have a sense of error.
14:19:31 <clahey> DanBurton: And that the error happens in weird places.
14:19:49 <margoK> Cale: thanks!
14:20:22 <Cale> margoK: Hopefully it actually works, I only really tested it on one input :)
14:20:24 <rwbarton> your XML file could abruptly end in the middle of an attribute value, does that mean you will have an Error constructor inside your "string" inside your tag attribute list inside your tags
14:20:25 <clahey> Actually, wait.
14:20:27 <gabor> jfischoff: the idea is to package up "new functionality" into a plugin, that brings its own parsing (for its supported entities) binds it into the general CLI parser and pretty-printer, manages its own (opaque) state and does IO to the (embedded) bits of HW it is designed for
14:20:29 <clahey> readFile is lazy, right?
14:20:38 <Cale> margoK: but you should see from that how an array can be used to memoise
14:20:43 <rwbarton> readFile does lazy IO
14:20:45 <clahey> rwbarton: Yeah, I understand this issue.
14:20:56 <clahey> rwbarton: Which means you can do lazy IO even if you're not in the IO monad?
14:20:57 <Cale> margoK: It's possible to do better than that in terms of space.
14:21:00 <rwbarton> sure
14:21:10 <Cale> margoK: But this way is simple to write anyway :)
14:21:24 <rwbarton> consuming the result of readFile via pattern matching will cause the file to be actually read
14:21:29 <DanBurton> yes, Prelude.readFile will interleave IO with pure computation, as laziness dictates
14:21:42 <jfischoff> gabor: interesting. I just wrote my first plugin for with Haskell this weekend.
14:21:52 <clahey> So you could do a lazy parser like I describe without IOs throughout the structure.
14:21:56 <margoK> Cale: thanks! a friend and i have been discussing this for a bit (we're both new to haskell) and we got a little stuck. thanks for trying to get us unstuck
14:22:14 <clahey> In fact, you could have it be all pure and just pass in the result of readFile and you'd get lazy IO.
14:22:14 <gabor> jfischoff: it's always the same broken record :-)
14:22:30 <rwbarton> yes. in fact I didn't even understand at first where the IO was coming from
14:22:37 <clahey> rwbarton: I was mixed up.
14:22:39 * jfischoff wishes GHC could compile for 32 and 64 bit regardless of what its arch is
14:22:42 <gabor> jfischoff: which plugin package did you use?
14:22:51 <Cale> margoK: you might also look at this: http://www.reddit.com/r/programming/comments/w4gs6/levenshtein_distance_in_haskell/c5a6jjz
14:23:09 <Cale> margoK: Where I implemented a bunch of versions of the Levenshtein distance in Haskell
14:23:18 <Cale> margoK: and used various methods to memoise
14:23:30 <Cale> (it's conceptually extremely similar)
14:23:34 <clahey> Note, I'm going to just use parsec or trifecta right now, but it's an interesting thought that I want to think more about.
14:23:43 <jfischoff> gabor: well it is a flash for Adobe Flash CS. Not a haskell code loading other haskell code. (there was a little bit of glue code)
14:23:59 <margoK> Cale: cool. i'll check that out
14:24:36 <gabor> jfischoff: I see, so you provide a C-calling-convention interface towards Flash?
14:25:26 <jfischoff> gabor: yes and Flash loads the haskell code compiled as a so (or specially and .bundle folder with an so)
14:25:31 <Cale> margoK: (also see my comments in replies, there were a couple more versions I discussed)
14:25:47 <jfischoff> but I was hoping to have that plugin load haskell dynamically somehow...
14:26:33 <rwbarton> it seems like what you'd want for lazy parsing is a parser library which statically tracks whether a parser can fail
14:26:46 <merijn> Is there any way to figure out whether a package will work on windows (without trying to compile it on windows, that is)?
14:27:42 <shachaf> merijn: I think there's a famous theorem about that.
14:27:50 <jfischoff> ha
14:28:10 <clahey> rwbarton: There's no way to tell whether the parser I'm imagining can fail until eof.
14:28:26 <gabor> jfischoff: I may suggest https://github.com/ggreif/dynamic-loader
14:28:36 <rwbarton> well here's what I'm thinking
14:28:36 <jfischoff> killer
14:28:59 <rwbarton> if it weren't for parsers that can fail, lazy parsing would be easy
14:29:33 <rwbarton> but without parsers that can fail you lack composability (<|>)
14:29:52 <merijn> shachaf: I mean some coarsegrained way to figure out whether some libraries are grossly unportable (like System.Posix)
14:29:54 <rwbarton> but if I write f <|> return Error, that is now a parser that can never fail again
14:30:41 <EvanR> windows has POSIX stuff
14:31:35 <shachaf> merijn: There's a "portability" field of some sort in modules.
14:31:39 <clahey> rwbarton: I think I'm okay with <|> being non lazy.  I just want many to be lazy.
14:31:40 <merijn> EvanR: Without cygwin?
14:31:55 <clahey> rwbarton: And <*> in general to some degree.
14:31:57 <merijn> It has some posix stuff, but not for example signals, afaik
14:32:04 <shachaf> I don't think there's much in the way of automated checking for it.
14:32:10 <EvanR> cygwin uses the posix stuff
14:32:11 <clahey> rwbarton: I'm guessing it's not possible to make it that simple.
14:32:22 <EvanR> i think
14:32:30 <rwbarton> clahey: so the idea is you would transform your parser into one that could never fail but returns this Error-laden ADT. then build it out of pieces in such a way that you allow failure in individual pieces, as long as the failure is handled by having a fallback
14:32:39 <merijn> EvanR: Yeah, but you have degrees of posix :p
14:32:41 <EvanR> 'unix services for windows'
14:32:50 <EvanR> maybe that was a windows 2000 thing :)
14:32:54 <EvanR> its been a while
14:33:13 <merijn> shachaf: I think I'm screwed anyway since I was gonna prototype using ncurses/something similar and windows has no proper terminal anyway...
14:33:23 <clahey> Right, and the fallback is an error in the ADT.
14:33:32 <clahey> What's an ADT?
14:33:36 <clahey> Abstract Data Tree?
14:33:41 <shachaf> merijn: Why do you need Windows for your prototype?
14:33:47 <rwbarton> well I just meant algebraic data type
14:34:13 <gabor> clahey: Algebraic Data Type
14:34:14 <shachaf> Gratuitously Abstract Data Type
14:34:15 <merijn> shachaf: Messing around with networking and game type things, but most of my friends don't run *nix
14:34:30 <merijn> shachaf: So if I want them involved I'm gonna have to support windows in some form
14:34:55 <merijn> Although that form may end up being "here's putty and a server whose login shell has been replaced by my code, go nuts"
14:35:00 <shachaf> Given the choice between writing Windows code and getting new friends...
14:35:12 <rwbarton> Generally-not Algebraic Data Type
14:35:29 <merijn> @remember shachaf GADT = Gratuitously Abstract Data Type
14:35:29 <lambdabot> Done.
14:35:46 <shachaf> :-(
14:39:05 <clahey> rwbarton: That seems about right.
14:39:22 <clahey> rwbarton: But I believe that current parsers will still parse the whole thing in that case.
14:40:20 <rwbarton> they have to because they have a "failure" constructor in their parser type
14:41:03 <clahey> rwbarton: It makes sense.
14:41:28 <rwbarton> but if you tracked whether a parser could fail in its type you could avoid that
14:42:09 <imperative_coder> why must I have a 'where' after the module header?
14:42:11 <clahey> rwbarton: And even combine fallible and infallible parsers.
14:42:38 <clahey> rwbarton: I wonder if it would be possible to implement it as an extension to an existing parser so that all the work that those parsers already do wouldn't have to be duplicated.
14:42:46 <ksf> imperative_coder, because the original designers, in their wisdom, wanted an exception to the layout rule.
14:42:54 <soapyillusions> Is there a way to turn a (String, IO String) into IO (String, String)?
14:42:56 <ksf> (in all other cases, you have to indent after "where")
14:42:56 <clahey> rwbarton: many could take a fallible parser and return an infallible one.
14:43:03 <shachaf> soapyillusions: Yes.
14:43:10 <rwbarton> right
14:43:12 <maukd> ksf: what?
14:43:22 <soapyillusions> shachaf how would I go about doing that?
14:43:28 <clahey> \a b = c <- b; return (a, c)
14:43:28 <maukd> I never indent after "where"
14:43:32 <clahey> \a b = do c <- b; return (a, c)
14:43:37 <blackh> imperative_coder: It's because 'where' starts a new layout block.
14:43:37 <clahey> Something like that?
14:43:37 <shachaf> strength (x,y) = fmap (x,) y
14:43:48 <clahey> Or that.  :)
14:43:50 <shachaf> That's the "usual" name, I think.
14:44:08 <shachaf> By which I mean I once saw it called that.
14:44:14 <ksf> maukd, not after the where in the module declaration line, no.
14:44:29 <imperative_coder> oh
14:44:44 <clahey> I'm still stuck in imperative mode.  I'll get there.
14:45:04 <maukd> ksf: never
14:45:06 <clahey> rwbarton: I really like this idea.  I have too much to play with right now, but it's a cool idea.
14:45:26 <clahey> rwbarton: My biggest concern is the ability to not keep all the previous parse state in memory.
14:45:35 <ksf> foo = bar\n__where\n____bar = baz
14:45:45 <soapyillusions> thanks
14:45:47 <maukd> foo = bar
14:45:48 <maukd>   where
14:45:50 <maukd>   bar = baz
14:45:57 <ksf> that's an actual layout block
14:46:14 <ksf> that's still indented, according to -XNonDecreasingIndentation
14:46:26 <maukd> ?
14:46:29 <ksf> you can't indent top-level decls, though.
14:46:34 <ksf> module Foo where
14:46:35 <maukd> wat
14:46:36 <ksf>   bar = baz
14:46:43 <maukd> why not?
14:46:47 <maukd> I've seen code like that
14:46:49 <clahey> rwbarton: Say I want to do something like map lengthFunction (doParse (many element)).  The goal would be to only have to have the parse tree for one element in memory at once.
14:47:19 <ksf> hmm.
14:47:38 <ksf> hmmm.
14:48:25 <ksf> oh. I misremembered because I thought too much about multiple modules per file and disciple's lack of a "where".
14:48:31 <blackh> imperative_coder: Actually now that I think about it, the stuff after a 'module X where' follows exactly the same syntax as a where clause in a function.
14:48:38 <rwbarton> clahey: right, I believe that should be possible with this
14:48:42 <rwbarton> I imagine someone has done this before
14:49:06 <rwbarton> since there is a lot of research into parsing
14:50:26 <imperative_coder> blackh: ah makes more sense now
14:50:38 <clahey> rwbarton: I'll try to do a search before I spend too much time on it.
14:50:46 <imperative_coder> btw, haskell supports literate programming?
14:50:51 <imperative_coder> what's that?
14:50:57 <clahey> rwbarton: If I do it smart enough, the laziness should just leak through haskell into my code, right?
14:52:12 <ksf> imperative_coder, by default everything's a comment, unless you say otherwise.
14:52:58 <blackh> imperative_coder: It's not exactly the same, now that I think about it, because you can't import in a function where clause. The where clause in a class declaration is also nearly the same, except for 'type X' vs 'type family X' at the module level.
14:53:18 <ksf> imperative_coder, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-List.html
14:54:02 <DanBurton> hrm, is -fno-warn-unused-binds broken?
14:54:14 <DanBurton> ghc is still giving me "defined but not used"
14:54:14 <imperative_coder> eww looks like LaTeX mixed with Haskell
14:54:27 <ksf> that's what it is.
14:54:28 <niklasb> it is
14:55:01 <jfischoff> has anyone used uu-parsinglib or another error correcting parser? 
14:55:06 <jaj> huhuh? haskell + latex? sounds like heaven
14:55:15 <rwbarton> you also can't define a type class inside a type class :)
14:55:22 <jaj> DSL to generate latex with haskell?
14:55:41 <ksf> imperative_coder, http://catseye.tc/projects/pail/src/Pail.lhs  <-- markdown
14:56:21 <rwbarton> but yeah, as a rule declarations go in where blocks
14:56:40 <imperative_coder> imagine if other programming languages supported comments as first-class objects; then we would have proper code documentation ^^
14:57:02 <maukd> lisp; python
14:57:12 <MostAwesomeDude> Yeah, Pythonl.
14:57:15 <imperative_coder> python ftw
14:57:17 <MostAwesomeDude> Er, *Python.
14:57:22 <shachaf> FSVO "comments"
14:57:42 <shachaf> Python requires you to use a string.
14:58:08 <rwbarton> or in let
14:58:12 <maukd> yeah, I was pointing out that python still sucks and you still don't have proper documentation
15:01:23 <DanBurton> ugh, TIL -fno-warn-unused-matches suppresses warnings that look like they come from warn-unused-binds instead
15:02:43 <kirindave> Man, I cannot get data.ringbuffer to compile correctly.
15:07:34 <FreiaBudeia> Hello.
15:07:50 <blackh> Hello!
15:08:32 <hpc> hello?
15:08:38 <MostAwesomeDude> Hi.
15:08:41 <FreiaBudeia> hi
15:08:53 <hpc> hi
15:08:56 <pckt> hi
15:09:01 <jix> edwardk: I wrote some code to convert between 'lens' lenses and 'a -> (b, b -> a)' style lenses, which I missed in the lens package. The code might be usable for the lens package (modulo my stupid names and documentation) https://gist.github.com/a576f9dabcb5948c314b
15:09:51 <gwern> @quote
15:09:52 <edwardk> jix: in Lens i call (b, b -> a) 'Context b b a'
15:09:52 <lambdabot> merijn says: rostayob: I used to be a functional programmer like you, but then I took an UML diagram to the knee >.>
15:10:13 <edwardk> jix: that way you can use its comonad, etc.
15:11:23 <dmwit> ?quote
15:11:24 <lambdabot> Einskell says: Make everything as monad as possible, but not monadder.
15:11:38 <dmwit> hm, I feel cheated a bit
15:11:38 <edwardk> jix: to convert to 'foo :: Lens a b c d' to 'a -> Context c d b', just call 'foo (Context id)'
15:11:39 <MostAwesomeDude> Haha.
15:11:41 <dmwit> ?quote
15:11:41 <lambdabot> defun says: [defun] conal: you seem knowledgable on the subject of FRP ... [conal] defun: btw, i invented frp.
15:11:49 <edwardk> to convert back, there is cloneLens
15:12:12 <jix> edwardk: ah I searched something like this but didn't find it...
15:12:42 <edwardk> so 'Tunnel' is 'Context'
15:13:09 <edwardk> jix: the Control.Lens.Plated combinators use it a lot ;)
15:13:27 <jix> yeah I see it now.. I probably saw Context before but since I didn't know what type I was looking for before figuring out how to implement it I didn't recognize it
15:13:43 <edwardk> *nods*
15:13:58 <edwardk> the docs for the plated module reference the fact that Context is used instead of (b, b -> a)
15:14:07 <edwardk> but its not very well advertised outside of that
15:15:06 * hackagebot fountain 0.1 - A fountain codec.  http://hackage.haskell.org/package/fountain-0.1 (RubenAstudillo)
15:15:28 <cmccann> someone needs to write an SMTP library that uses uniplate for some reason, so that it can be named "platemail"
15:16:13 <edwardk> cmccann++
15:16:33 <edwardk> well, my zipper can be viewed as a chain of plates. so maybe i can call it chainmail ;)
15:16:45 <cmccann> haha
15:16:56 <cmccann> sounds reasonable to me
15:17:22 <quuuux> if Facebook picks it up and starts using it for billions of emails, it'd be scalemail
15:18:59 <dmwit> and then they'll reimplement it in PHP, it'll be three orders of magnitude slower, and emails will tend to drag on and on and on.... and it will be called dragon scale mail.
15:19:43 <FreiaBudeia> The conversation here is way over my head :) Could someone direct me to the place I need to go where people want to discuss newbie stuff?
15:20:03 <dmwit> Just ask your questions.
15:20:04 <cmccann> newbie stuff as opposed to... terrible puns?
15:20:13 <dmwit> If you don't understand the answer, ask more questions until you do.
15:20:23 <dustingetz> is it possible to write a haskell program, without IO monad, which crashes, e.g. via unhanded exception
15:20:38 <dmwit> It is not possible to write a Haskell program without the IO monad.
15:20:43 <dmwit> Forget whether it crashes or not.
15:20:51 <blackh> FreiaBudeia: This is the channel for newbie questions. You'll typically get four answers the same within 10 seconds, then a half-hour discussion in-depth discussion about the topic.
15:21:12 <shachaf> dmwit: Sure it is.
15:21:17 <cmccann> dmwit, "main = undefined", don't need IO there :P
15:21:26 <dmwit> undefined has type IO a
15:21:37 <FreiaBudeia> :D Okay,  I am trying to write a program that parses arithmetic expressions with prefix notation.
15:21:43 <FreiaBudeia> AND..
15:21:48 <shachaf> «This includes such issues as the nature of programming environments and the error messages returned for undefined programs (i.e. programs that formally evaluate to ⊥).»
15:22:45 <cmccann> I like how we immediately start arguing about weird semantic minutia because someone wanted to ask a newbie question
15:23:01 <FreiaBudeia> that includes an evaluation function that can handle expressions such as "let a = 5 in + a 6"
15:23:04 <dustingetz> is it accurate to say that for all possible programs without IO would be memorized at compile time
15:23:10 <blackh> yeah - philosophical and historical implications, etc
15:23:12 <alpounet> cmccann, that's pretty much standard here unfortunately
15:23:44 <merijn> alpounet: I don't think it's necessarily bad, as long as people answer the newbie questions "seriously" too
15:24:09 <cmccann> no, sometimes it's endless abstraction golfing instead of nitpicking semantics
15:24:10 <FreiaBudeia> you guys are chatting like the characters of a terry pratchett book :)
15:24:13 <alpounet> merijn, yeah, but sometimes we can really see it as "arguing for arguing"
15:24:41 <FreiaBudeia> evali:: [(Char, Int)]-> AST -> Int
15:24:42 <FreiaBudeia> evali lst (Leaf x) = x
15:24:44 <FreiaBudeia> evali lst (Sum x y) = (evali (lst x)) + (evali (lst y))
15:24:45 <FreiaBudeia> evali lst (Mult x y) = (evali (lst x)) * (evali (lst y))
15:24:47 <FreiaBudeia> evali lst (Neg x) = - (evali (lst x))
15:24:48 <FreiaBudeia> evali lst (In x) = (evali lst x)
15:24:50 <FreiaBudeia> evali lst (Let v x y) = evali(((v, (evali lst x)):lst) y) -- I run in to problems here
15:24:51 <FreiaBudeia> evali lst (Leaf' x) = if elem x (fst(unzip lst)) then findValue x lst
15:24:53 <FreiaBudeia>                         else (x,0):lst
15:24:54 <merijn> FreiaBudeia: In general people don't really mind answering newbies questions if you don't let yourself get scared by the other ongoing conversations :)
15:24:54 <FreiaBudeia> findValue x [] = 0
15:24:56 <FreiaBudeia> findValue x lst = if x == fst(head lst) then snd(head lst)
15:24:57 <FreiaBudeia>                     else findValue x (tail lst)
15:25:00 <cmccann> FreiaBudeia, you should use hpaste instead of pasting code in channel
15:25:04 <cmccann> @where hpaste
15:25:05 <lambdabot> http://hpaste.org/
15:25:06 <merijn> FreiaBudeia: Use something like hpaste.org, please
15:25:06 * hackagebot numbers 3000.1.0.0 - Various number types  http://hackage.haskell.org/package/numbers-3000.1.0.0 (DanBurton)
15:25:07 <FreiaBudeia> totally not scared:)
15:25:30 <DanBurton> :) yay hackagebot noticed me
15:26:38 <ion> I like how numbers is almost 1000 years in the future.
15:26:54 <dmwit> dustingetz: No, GHC doesn't memoize anything.
15:27:01 <DanBurton> yep I felt like it wasnt awesome enough in 2009
15:27:01 <hpaste> FreiaBudeia pasted “Parsing/ Abstract Syntax Tree” at http://hpaste.org/76056
15:27:09 <dustingetz> but it could
15:27:10 <DanBurton> so I skipped a few hundred
15:27:11 <dmwit> dustingetz: If you want memoization, you must do it yourself.
15:27:14 <FreiaBudeia> http://hpaste.org/76056
15:27:27 <dmwit> dustingetz: Nothing about memoizing everything would break the spec. However, it would lead to horrible memory performance.
15:27:45 <dmwit> See also the StackOverflow question:
15:28:42 <dmwit> uh... huh
15:28:57 <dmwit> I swear I *just* saw a question describing the tradeoffs beautifully, but I have no idea where now.
15:29:08 <cmccann> well, it would perform fine regarding memory use
15:29:14 <cmccann> in fact, it would be very, very good at using memory
15:29:29 <cmccann> you'd have no problems whatsoever with getting that memory used up
15:29:38 <FreiaBudeia> I get an error I don't understand..
15:29:48 <FreiaBudeia> Couldn't match expected type `Int' with actual type `AST -> Int'
15:29:50 <FreiaBudeia>     In the return type of a call of `evali'
15:29:52 <FreiaBudeia>     Probable cause: `evali' is applied to too few arguments
15:29:53 <FreiaBudeia>     In the first argument of `(+)', namely `(evali (lst x))'
15:29:55 <FreiaBudeia>     In the expression: (evali (lst x)) + (evali (lst y))
15:30:10 <Botje> FreiaBudeia: next time, add the error to the paste
15:30:23 <FreiaBudeia> Oh, Sorry..
15:30:52 <Botje> FreiaBudeia: note that evali (lst x) calls "lst x" first and passes the result to evali.
15:30:59 <Botje> you probably meant evali lst x instead
15:32:03 <FreiaBudeia> That was what I worte there initially, but I got the same error. Sorry meant to paste the other version
15:32:53 <Botje> FreiaBudeia: can you paste that version together with the error you get, then?
15:35:12 <lispy> danharaj: I think we are missing a library during linking: http://www.gamedev.net/topic/594858-problems-linking-glew/
15:35:45 <FreiaBudeia> No shit, you were right. That was the problem. And I didnt write that in earlier version.THANK YOU!
15:36:03 <jaj> w 1
15:36:08 <Botje> FreiaBudeia: yay!
15:36:09 <lispy> danharaj: If you have the chance, could you please try modifying your OpenGLRaw to link against the mentioned file (some variant of opengl32.lib) and let me know what happens?
15:36:10 <FreiaBudeia> This place is awesome.
15:37:11 <danharaj> lispy: shouldn't compilation to executable also fail if we are lacking a library?
15:37:34 <Botje> FreiaBudeia: you could clean up the last clause of token a bit with guards
15:37:48 <lispy> danharaj: Good question. I guess this could be a bug in ghci.
15:37:55 <lispy> danharaj: I assumed it was a bug in the .cabal file
15:38:12 <Botje> token (x xs) | isDigit x = .... | x >= 'a' && x <= 'z' || ... = ...
15:38:18 <Botje> (with each | on a new line)
15:38:19 <danharaj> lispy: hmm, just a random guess but I tried to compile with -dynamic and I got this error:
15:38:28 <danharaj> Could not find module `Graphics.Rendering.OpenGL'     Perhaps you haven't installed the "dyn" libraries for package `OpenGL-2.5.0.0'?
15:38:31 <danharaj> I am not sure if this is relevant.
15:38:33 * lispy doesn't know what -dynamic does
15:38:38 <danharaj> neither do I! :P
15:39:34 <Botje> FreiaBudeia: you could also clean up some of the ast stuff with pattern matching.
15:39:38 <danharaj> I suppose it is irrelevant.
15:40:04 <Botje> let (left, rest) = ast xs; (right, rest') = ast rest
15:40:43 <nejucomo> After reading the haskell wiki page on fundeps, I still don't quite grok what they "do".  Do they signify "the space for instances of this class is constrained to only the parameters left of the arrow" ?
15:40:50 <FreiaBudeia> What do you mean by pattern matching for ast?
15:41:03 <Botje> FreiaBudeia: take the case for *, for example
15:41:19 <Botje> FreiaBudeia: you invoke ast xs three times, and you only use one part of the result each time
15:41:20 <FreiaBudeia> and yeah tokens look cleaner with guards. Are there any other benifits?
15:41:30 <Botje> no, just cleaner :)
15:41:38 <FreiaBudeia> :)
15:41:42 <nejucomo> So would class A t where ... and class B t u | t -> u where ... each only have one "degree of freedom" in instance space?
15:42:00 <Botje> FreiaBudeia: I'll annotate your paste with a cleaned up version of *, sec
15:42:24 <byorgey> nejucomo: yes, I think you have the right idea
15:42:35 <FreiaBudeia> Okay, sweet! I didnt quite understand what you meant at first.. :)
15:42:59 <nejucomo> byorgey: Ok, thanks.  I'm still fuzzy about how type classes / instances and inference fit together, but I'm slowly getting a "feel" for it.
15:43:29 * nejucomo glances at an open partially-read tab at http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.5674
15:43:49 <danharaj> lispy: we already have extra-libraries: opengl32 in the OpenGLRaw.cabal.
15:43:52 <nejucomo> Oh, first I think I need to read "Typing Haskell in Haskell".
15:44:15 <hpaste> Botje annotated “Parsing/ Abstract Syntax Tree” with “Parsing/ Abstract Syntax Tree (annotation)” at http://hpaste.org/76056#a76057
15:44:16 <lispy> danharaj: Sorry to keep bugging you. Does ghci produce anything more relevant when you add "-v" to your command line?
15:44:31 <Botje> FreiaBudeia: see that url.
15:44:34 * lispy wonders of opengl64 is a thing
15:45:34 <danharaj> lispy: http://hpaste.org/76058
15:45:55 <danharaj> btw I posted the problem on the cafe so that hopefully someone who knows what's up will see it.
15:46:57 <lispy> danharaj: Well, the -package you're using in that hpaste is not working
15:48:26 <danharaj> lispy: what do you mean?
15:48:44 <danharaj> oh yes
15:48:47 <danharaj> it is case sensitive, my bad
15:49:24 <lispy> danharaj: you said you're getting warnings about the calling convention right?
15:49:29 <lispy> danharaj: what was that warning again?
15:49:37 <lispy> http://hackage.haskell.org/packages/archive/OpenGLRaw/1.2.0.0/OpenGLRaw.cabal
15:49:39 <lispy> look at the if statement
15:49:49 <danharaj> lispy : http://hpaste.org/76059
15:49:51 <danharaj> for reals this time
15:49:58 <lispy> if os(windows) && ... cpp-options: "-DCALLCONV=stdcall"
15:50:44 <FreiaBudeia> Botje: Wow. does that work? I thought that left would be unavailible to the (Mult left right, xs')
15:50:49 <lispy> danharaj: thanks. Unfortunately the verbose output doesn't help me :(
15:51:16 <danharaj> lispy: Should I change that to -DCALLCONV=ccall and see what happens?
15:51:23 <FreiaBudeia> Botje: Sorry it took me a while to figure what you wrote out.. I just started learning Haskell a couple of weeks ago :)
15:51:33 <Botje> FreiaBudeia: no problem, I have a few years on you ;)
15:51:38 <danharaj> actually I'll be less hasty and go look up calling conventions on x86-64 windows :P
15:51:44 <lispy> danharaj: I'm pretty sure the opengl spec says to use stdcall
15:51:59 <Botje> FreiaBudeia: all of the bindings introduced in the where clause are visible in the body of the where (so the (Mult..., xs'') part) and other bindings
15:52:33 <FreiaBudeia> That is very good to know. Thank you so much.
15:54:38 <lispy> danharaj: this answers some questions: http://stackoverflow.com/questions/1236670/how-to-make-opengl-apps-in-64-bits-windows
15:55:00 <lispy> danharaj: Looks like x86-64 just has one calling convention but on win32 it mattered
15:55:25 <nejucomo> Is this nonsensical?  class C a b | a -> b where ... ; instance C a b => C b a where ...
15:55:26 <shachaf> matter*s*
15:55:28 <lispy> danharaj: so I guess the cabal file now needs a check for 64 vs. 32bit ghc
15:55:42 <danharaj> indeed
15:55:43 <lispy> shachaf: win32 is dead, right?
15:55:56 <Phlogistique> bl
15:55:56 <nejucomo> I mean, to me it makes sense, but is it feasible in Haskell (or is there something illogical I miss when it "makes sense" to me?)
15:55:59 * lispy wonders if cabal even supports that
15:55:59 <danharaj> if you direct me at the syntax for that I'll try it right now.
15:56:00 <Phlogistique> oops
15:56:03 <shachaf> nejucomo: What are you trying to accomplish?
15:56:04 <danharaj> oh ._.
15:56:23 <maukd> nejucomo: looks like an infinite loop to me
15:56:35 <maukd> even without taking the fundep into account
15:56:40 <shachaf> lispy: Win16 is maybe dead-ish.
15:56:50 <nejucomo> shachaf: For any type t, I effectively want the type system to deduce another type u with some relation.
15:57:13 * nejucomo hpastes a motivating (?) example...
15:58:00 <johnw> too bad there wasn't a Win8.  Oh, wait... ;)
15:58:33 <lispy> danharaj: I think it depends on System.Info http://www.haskell.org/cabal/users-guide/developing-packages.html#configurations
15:58:36 <hpaste> nejucomo pasted “Invertible attempt” at http://hpaste.org/76060
15:58:38 <shachaf> johnw: I don't care to find out what your interpretation of Win3.11 is.
15:59:11 <johnw> it's .03 less than WinPI
15:59:13 <lispy> danharaj: in reality we'll probably have to do something complicated in Setup.hs to run ghc and parse the result of rtsinfo or some nonsense?
15:59:40 <johnw> cabal install -j is quite handy
16:00:15 <nejucomo> This is part of a general musing exploration of if it's possible to make a "dimensional units" library that statically verifies that dimensional units are correct for computations.
16:00:17 <danharaj> lispy: At least we have a lead now. How can I kludge the .cabal so that it tries to do everything for 64-bits. If it works, we can ask the cabal team for an answer.
16:01:24 <blackh> nejucomo: Have you tried | t -> u, u -> t ?
16:01:44 <nejucomo> blackh: It had not occurred to me.
16:02:04 <blackh> It compiles, so therefore it must also work! :)
16:02:16 <lispy> danharaj: I'd start by changing that stdcall to ccall
16:02:20 <nejucomo> It does not compile for me.
16:02:27 <lispy> danharaj: opengl32 is still the right library name even on 64bit
16:03:08 <nejucomo> oh wait a minute.
16:03:08 <lispy> danharaj: other than that, I don't know what to try
16:03:12 <blackh> nejucomo: I'm using ghc-7.6.1. I just took your first 4 non-empty lines and hacked them.
16:04:32 <lispy> danharaj: you can try finding opengl32.lib on your system (or it might be .dll) and passing the full path to ghci
16:04:44 <lispy> danharaj: see if ghci can find it in that case
16:04:49 <nejucomo> Woah.
16:05:28 <nejucomo> My mind is almost blown.  I now need some way to magically simplify Inversion (Inversion t) with t...  doubt that's possible.
16:07:02 <nejucomo> I can't tell if there's a fundamental type-theory concept or lack of concept I'm implicitly relying on, or if there's a Haskell limitation, or if it's possible in ghc + extensions and I just haven't found it.
16:07:37 <maukd> but what if t = Inversion (Inversion t')?
16:08:48 <nejucomo> maukd: Right.  It smells like fundamentally I want to say: "these two types are related in this way *except* if they are the same type then they're related in a different way."
16:09:37 <nejucomo> maukd: Is your question proposing a result of inference rather than a definition?
16:11:44 <nejucomo> As for the exception, it's like I want two types for one function: invert :: t -> Inversion t -magic or- Inversion t -> t
16:15:58 <danharaj> lispy: so building with ccall doesn't fix the problem, but it does get rid of all the warnings during build, so that should be arranged for windows x86-64 anyway.
16:18:39 <danharaj> lispy: for the second idea, did you mean passing `-lopengl32` to ghci and providing -L(path)?
16:23:25 <hpaste> “ottos mops” pasted “397” at http://hpaste.org/76062
16:24:55 <lispy> danharaj: Sure. I think you can also simply provide the full path/filename of a .dll and ghci will understand that.
16:27:35 <danharaj> lispy: tried it, didn't work :[
16:28:27 <lispy> danharaj: Okay. i'm not sure what is needed
16:28:39 <lispy> ghci is really not great for using things that have sophisticated deps
16:39:46 <kirindave_> aristid-ipad: Hey aristid-ipad, how did you get data-ringbuffer to even compile?
16:39:59 <kirindave_> aristid-ipad: Has syntax errors and doesn't generate tests when I check out of gist
16:40:03 <kirindave_> err, gi
16:40:04 <kirindave_> t
16:40:09 * hackagebot http-accept 0.2 - Functions for working with HTTP Accept headers  http://hackage.haskell.org/package/http-accept-0.2 (StephenWeber)
16:40:21 <aristid-ipad> kirindave_: it did compile for me oO
16:40:33 <kirindave_> I did a checkout of the current master
16:40:35 <kirindave_> And it just failed.
16:40:38 <aristid-ipad> kirindave_: which ghc version for you?
16:40:41 <kirindave_> 7.4.1
16:40:56 <aristid-ipad> were there commits yesterday?
16:40:58 <kirindave_> No
16:41:06 <kirindave_> I do not know how it could possibly compile for you
16:41:42 <aristid-ipad> for the benchmarks you need --enable-benchmarks, the readme lies
16:42:02 <kirindave_> https://github.com/kim/data-ringbuffer/blob/master/src/Data/RingBuffer/Types.hs
16:42:04 <kirindave_> This file fails
16:42:08 <kirindave_> Because the comments confuse my ghc
16:43:09 <aristid-ipad> how do you compile?
16:44:35 <kirindave_> cabal-dev build
16:45:07 <kirindave_> Or cabal-dev install
16:45:39 <aristid-ipad> kirindave_: i used plain cabal
16:45:51 <aristid-ipad> just build no install
16:47:26 <kirindave_> aristid-ipad: Still, seems like the author wants to rewrite.
16:47:45 <kirindave_> aristid-ipad: And I'd love to see some kind of trivial abstraction over this.
16:47:52 <aristid-ipad> kirindave_: you talked to him?
16:47:59 <kirindave_> I read his issues
16:48:00 <aristid-ipad> yeah the api is terrible
16:49:28 <aristid-ipad> kirindave_: most of the time your network is static, right? i think it would be possible to make a nice api for that
16:50:10 <kirindave_> aristid-ipad: For disruptor on java the only way you'll get good optimization is to have a static network.
16:51:30 <aristid-ipad> kirindave_: dynamic would complicate how i see the optimal api :) (note i avoid the term dsl, insert if you prefer)
16:52:24 <kirindave_> aristid-ipad: You know what would be PERFECT for this?
16:52:30 <kirindave_> aristid-ipad: Something like conduit or pipes
16:52:52 <kirindave_> aristid-ipad: I mean that's almost exactly the model you want.
16:52:53 <aristid-ipad> kirindave_: yeah something coroutiny
16:53:12 <aristid-ipad> kirindave_: just with a static plumbing network
16:53:17 <kirindave_> Where you can both fuse ops into a single step and sequence them.
16:54:37 <aristid-ipad> kirindave_: looks like colloquy decided to crash, lost all context
16:54:57 <kirindave_> "here you can both fuse ops into a single step and sequence them.
16:54:57 <kirindave_> "
16:56:00 <kirindave_> aristid-ipad: And I cannot get data-ringbuffer to build criterion
16:56:30 <aristid-ipad> kirindave_: i just built the newest master on my linux machine
16:56:42 <kirindave_> Not using cabal-dev?
16:56:47 <aristid-ipad> running benchmarks, hopefully no crashes this time!
16:56:48 <kirindave_> Cabal-dev must be broken.
16:56:49 <aristid-ipad> nah
16:57:28 <aristid-ipad> reason i dont use it is i just never bothered setting it up
16:57:39 <kirindave_> Well
16:57:41 <kirindave_> I check out a fresh version
16:57:55 <kirindave_> I type in cabal-dev install --enable-benchmarks
16:57:58 <kirindave_> I get no perf output.
16:58:19 <aristid-ipad> need cabal bench to run the benchmark
17:00:19 <aristid-ipad> kirindave_: did i ever mention that one big advantage of my thinkpad over my mba is that it does not become a siren under load?
17:00:36 <kirindave_> aristid-ipad: I just want something that can drive external monitors.
17:00:44 <kirindave_> aristid-ipad: I have a nice monitor and an awesome monitor arm now.
17:01:07 <aristid-ipad> kirindave_: i drive an external over displayport. intel graphics tho
17:01:22 <kirindave_> aristid-ipad: Wanna by my thinkpad T520? $500.
17:01:29 <kirindave_> It's a hell of a good deal
17:01:33 <kirindave_> If you want that fucking machine.
17:01:42 <kirindave_> I have yet to even throw it at a wall yet.
17:02:14 <aristid-ipad> kirindave_: dont currently want another laptop, but thanks
17:02:37 <hiptobecubic> <3 thinkpad
17:04:28 <hpc> can someone save me from a huge brainfart?
17:04:52 <hiptobecubic> Don't hold it in
17:04:54 <hiptobecubic> it's bad for you
17:05:03 <hpc> i have ContT r IO a, and want an IO r
17:05:05 * johnw gives hpc some brain beano
17:05:08 <aristid-ipad> kirindave_: ffs, looks like the same ghc bug also affects linux
17:05:09 <hpc> er
17:05:13 <hpc> i have ContT r IO (), and want an IO r
17:05:21 <hpc> runContT m return -- obviously wrong
17:05:38 <johnw> join $ execContT m return?
17:05:44 <aristid-ipad> kirindave_: same "strange closure type" after 15 min of benchmarking
17:05:44 <hpc> :t execContT
17:05:45 <lambdabot> Not in scope: `execContT'
17:05:51 <hpc> @hoogle execContT
17:05:52 <lambdabot> No results found
17:05:55 <johnw> it was a guess
17:05:58 <kirindave_> aristid-ipad: Well that is not awesome.
17:06:07 <aristid-ipad> kirindave_: indeed
17:06:13 <johnw> sometimes I shouldn't let my fingers answer
17:06:15 <kirindave_> aristid-ipad: In 7.6?
17:06:17 <hpc> lol
17:06:29 <aristid-ipad> kirindave_: 7.4.2
17:07:02 <kirindave_> Hmm.
17:07:11 <hpc> ooh, ooh
17:07:14 <hpc> :t withContT
17:07:15 <lambdabot> forall b (m :: * -> *) r a. ((b -> m r) -> a -> m r) -> ContT r m a -> ContT r m b
17:07:22 <johnw> there!
17:07:31 <hpc> :t withContT (const . ($)) ?m
17:07:32 <lambdabot>     Occurs check: cannot construct the infinite type: r = b -> r
17:07:32 <lambdabot>     Probable cause: `$' is applied to too few arguments
17:07:32 <lambdabot>     In the second argument of `(.)', namely `($)'
17:07:36 <johnw> I knew it had to have a moral equivalent to execStateT
17:07:49 <hpc> :t withContT (\f _ -> f True) ?m
17:07:50 <lambdabot> forall (m :: * -> *) r a. (?m::ContT r m a) => ContT r m Bool
17:07:56 <hpc> bitchin!
17:07:58 <kirindave_> aristid-ipad: Trying on mine.
17:08:03 <kirindave_> This machine is quite "pristine."
17:08:09 <hpc> :t runContT (withContT (\f _ -> f True) ?m) return
17:08:11 <lambdabot> forall (m :: * -> *) a. (?m::ContT Bool m a, Monad m) => m Bool
17:08:42 <aristid-ipad> kirindave_: in cheerier news, TChan seems to be reasonably fast
17:09:00 <kirindave_> aristid-ipad: Oh?
17:09:11 <hpc> er, hmm
17:09:14 <kirindave_> aristid-ipad: What I'd love to do is say.. given a 3 stage pipeline
17:09:27 <kirindave_> aristid-ipad: How many records can we push through per second with 1 core, and with 3.
17:09:33 <hpc> that's ultimately equal to (return True)
17:09:48 <aristid-ipad> kirindave_: in one benchmark tchan gets in excess of 1mm tps on my old nehalem mobile dualcore
17:10:22 <hpc> wait, im dumb, and asking for the impossible
17:10:35 <johnw> it's not always dumb to ask for the impossible
17:10:44 <hpc> nah, i totally should have known better
17:10:45 <johnw> it's dumb to think you've received an answer ;)
17:10:45 <kirindave_> aristid-ipad: Well the important part is to set up multi-stage pipelines.
17:10:52 <kirindave_> aristid-ipad: But I have heard tchan is quite fast these days.
17:11:13 <kirindave_> People I know in the java world scoff but these cell-wise transactional impls seem to have gotten really good.
17:12:01 <aristid-ipad> kirindave_: i wonder how much overhead each atomically block has
17:12:36 <kirindave_> nimplemented/strange closure type 3840
17:12:47 <aristid-ipad> gnnn
17:12:58 <aristid-ipad> looks like youre affected too!
17:13:01 <kirindave_> Yeah
17:13:04 <kirindave_> That's multicast
17:13:08 <kirindave_> Let's see how unicast goes
17:14:39 <aristid-ipad> kirindave_: my ghc bug is 7302 on the ghc trac
17:15:30 <Taslem> I'm assuming `take n` has a time complexity of O(n)?
17:15:45 <johnw> Taslem: depends on the library
17:15:56 <Taslem> Prelude implementation, whatever's default.
17:16:03 <aristid-ipad> Taslem: if you actually use all those list element, yes
17:16:03 <johnw> ah, on lists
17:16:30 <kirindave_> aristid-ipad: I am reasonably certain this implementation is more than entirely broken.
17:16:39 <aristid-ipad> kirindave_: :(
17:16:47 <shachaf> More than entirely?
17:16:49 <kirindave_> aristid-ipad: It doesn't even peg a single core.
17:16:52 <kirindave_> That's wrong.
17:16:53 <shachaf> That's pretty broken.
17:17:05 <kirindave_> Disruptor absolutely annihilates my machine.
17:17:34 <shachaf> Taslem: That question is a little tricky to ask in a way that makes sense.
17:18:00 <aristid-ipad> kirindave_: you should just implement the pattern with a simple IORef (that uses memory barriers i think) and see how that performs :)
17:18:02 <Taslem> Isn't reasoning about performance in lazy, functional languages great? :3
17:18:06 <Taslem> My only gripe with Haskell.
17:18:21 <shachaf> "take 100 [1..]" "returns" immediately. If you look at its last element, that'll take 100 steps, but looking at the 100th element of a list takes 100 elements anyway.
17:18:25 <kirindave_> aristid-ipad: I wonder if you could.
17:18:26 <johnw> i like to reason by way of the profiler :)
17:18:30 <kirindave_> It'd be a good learn-haskell-deeply project.
17:18:39 <johnw> oh, wait, that's what I have to do for _any_ language!
17:18:51 <parcs`> take is constant time
17:18:58 <aristid-ipad> kirindave_: i think it might be possible. and awesome!
17:20:40 <shachaf> Could what?
17:20:55 * shachaf tries to figure out what the topic is.
17:21:30 <aristid-ipad> shachaf: disruptor pattern in haskell
17:22:11 <dylukes> disruptor pattern? :\
17:22:29 <aristid-ipad> a ring buffer thingie
17:23:34 <aristid-ipad> allows quick 1:n messaging on an intel multicore cpu
17:27:25 <kirindave_> Which is to say, nearly all hardware used in the industry for server systems
17:27:42 <kirindave_> it's best for writing high speed evented systems.
17:27:57 <kirindave_> Like, message comes in, needs to be decoded and processed in minimum time.
17:29:01 <aristid-ipad> and in parallel be logged
17:34:17 <hpc> you can tell you got your types right when all of a sudden, defining functions becomes REALLY EASY
17:34:28 <dylukes> :P
17:34:35 <dylukes> "it's all just fitting into place!"
17:34:58 <Taslem> You can tell when you get them wrong when GHC starts writing novels.
17:35:11 <dylukes> :)
17:37:37 <nicoo> hpc: Half of a good library design is choosing types and monad exposed in the API
17:44:59 * Polarina dislikes GHC's novels.
17:45:37 <doomlord> let x = dosomething x  puts haskel into an infinite loop ?
17:45:52 <Polarina> doomlord, not neccesarily.
17:46:00 <hpc> depends on what dosomething is
17:46:09 <doomlord> what could make it escape that
17:46:17 <Polarina> doomlord, not evaluating x.
17:46:27 <hpc> > let dosomething = (1:) in (let x = dosomething x in x)
17:46:29 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:46:47 <alpounet> > let x = 1:x in take 10 x
17:46:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
17:46:56 <alpounet> despite x being infinite, here.
17:47:01 <alpounet> (an infinite list)
17:47:06 <Taslem> (because it's lazy)
17:47:34 <hpc> well let's be clear, it's because each pattern match on the list takes finite time
17:47:42 <hpc> (or rather, each pattern match on (show x)
17:47:43 <doomlord> ( i just encountered such a case as a bug in my code )
17:47:44 <hpc> )
17:48:39 <Taslem> Could you provide the code? That could help.
17:49:55 <doomlord> it was easy to fix - it was a typo; i was just surprised it even compiled
17:50:15 <boccato> What is a good library for monitoring file changes?
17:50:59 <doomlord> it's in some manually threaded state code;      let (v1,s1)= update s in let (v2,s2)=update s2   <<<<< TYPO, should be update s1
17:51:19 <hpc> doomlord: congrats, you just invented State
17:51:42 <hpc> (and the Monad instance for it)
17:51:58 <doomlord> i'm doing it the hard way because i dont instinctively get how to use the state monad yet
17:52:22 <doomlord> trying to actually write something to enjoy the rest of haskell... then i'll get back to that..
17:52:28 <hpc> :P
17:53:08 <doomlord> specifically this is a random seed being thrown around
17:53:59 <cmccann> reimplementing the state monad is not a bad learning exercise
17:54:21 <cmccann> especially for de-mystifying how State works
17:54:39 <doomlord> <get my asteroids game working then clean it up>
17:55:00 <doomlord> yeah i figure i'll only truly get it if i implemented it once
17:56:08 <kirindave_> doomlord: Understanding State and StateT is pretty much the point where I really 'got' monads.
17:56:52 <hpc> i spent a long time wondering "where the state came from" before i stopped trying to turn it into metaphors
17:57:01 <bss03> Does the pipes developer ever stop in here?
17:57:02 <lambdabot> bss03: You have 1 new message. '/msg lambdabot @messages' to read it.
17:57:07 <kirindave_> bss03: Yes
17:57:14 <bss03> I don't see his reddit nick in the user list for the channel. :(
17:57:23 <cmccann> he's not here right now
17:57:29 <cmccann> but he does use the same nick
17:57:55 <hpc> i don't remember ever seeing someone with that nick around
18:00:32 <sinelaw> hey, what's a nice lib for reading xmls?
18:00:42 <sinelaw> HXML seems ancient
18:02:42 * BMeph starts reading documentation, "Tekmo Gangnam-style"!
18:04:26 <bss03> sinelaw: I use HXT last time I was processing xml.
18:04:49 <bss03> sinelaw: I think the arrow approach works fairly well.
18:05:17 <sinelaw> bss03, thanks i'll take a look
18:05:51 <bss03> sinelaw: ISTR there was a "tagsoup" parser for HXT, too.  Since I was parsing not-really XML. :(
18:06:25 <sinelaw> tagsoup is for parsing badly formed xml?
18:07:03 <alpounet> sinelaw, hxt, xml-light, tagsoup are cool
18:07:54 <sinelaw> I have tons of xml documents i want to later process. I was thinking about storing them in some "document" DB such as CouchDB
18:08:12 <bss03> sinelaw: Yeah, tagsoup is suitable for parsing not-well-formed XML or HTML.
18:08:19 <sinelaw> which requires that I first parse them and convert them into some format such as json
18:08:59 <bss03> Really?  Why does CouchDB like JSON and not XML?
18:09:16 <bss03> lambdabot: @seen Tekmo
18:09:17 <lambdabot> Unknown command, try @list
18:09:20 <sinelaw> bss03, maybe it does like xml. the main docs only mention json so far
18:11:05 <sinelaw> yo jva
18:11:24 <ivanm> is there an FFI tutorial focused on "I want to re-write this function in C for performance" (rather than writing bindings)?
18:11:32 <ivanm> bonus points if it doesn't assume much C knowledge
18:11:47 <ivanm> (I know about RWH and I'm re-reading that chapter now, but it assumes you already have a library you want to bind to)
18:12:02 <dmwit> You want to rewrite something in C for performance without knowing C?
18:12:26 <sinelaw> ivanm, what kind of code are you looking to rewrite?
18:12:34 <ivanm> dmwit: my supervisor wants me to put bounds on how much faster an implementation in C would be
18:12:44 <ivanm> so I want to write one function and benchmark it
18:13:15 <ivanm> I've never really programmed in C, but I can read and grok it reasonably enough (I think), and I'll be basing my code off of his from another project
18:13:18 <sinelaw> ivanm, there are different ways to optimize code in C, you could get either terrible or awesome performance depending on the implementation
18:13:19 <doomlord> can you get an idea from timing one function
18:13:27 <ivanm> doomlord: he thinks I can :)
18:13:33 <ivanm> this function is about 25% of my runtime
18:13:35 <dmwit> That's a really tricky thing to do. Unless the function is largish, you're going to be benchmarking the Haskell -> C boundary...
18:13:51 <ivanm> dmwit: I'm going to be benchmarking only that function using criterion
18:13:58 <ivanm> (as I figured the boundary would be the case)
18:14:17 <dmwit> Well, anyway, more to the point: the FFI spec is pretty readable, and the c2hs documentation was quite helpful for me in understanding the raw FFI (not just c2hs itself).
18:14:30 <shachaf> ivanm: What's the function?
18:14:37 <ivanm> so, I think I know how to represent my data type in C and how to write the function
18:14:46 <shachaf> ivanm: Looking at examples might be helpful. I remember that Data.Text does some of this.
18:14:52 <shachaf> E.g. for UTF-8 decoding
18:14:53 <ivanm> I just wasn't sure what the best approach would be for writing the .c, .h, etc. files
18:15:24 <shachaf> .h files? Who needs those? :-)
18:15:41 <ivanm> don't you? that's how little my C knowledge is :)
18:15:51 <doomlord> you might find that starting with code in haskell is a very bad way to write C
18:15:56 <ivanm> I've only ever either modified or converted existing C code
18:16:02 <shachaf> ivanm: You usually need them.
18:16:07 <dmwit> shachaf is being a bit snarky, but it's true that GHC ignores any headers you tell it about.
18:16:08 <shachaf> For C code calling other C code, for instance.
18:16:25 <shachaf> But in the FFI you write out the types yourself in Haskell.
18:16:43 <dmwit> (Because you duplicate the contents of the header file in Haskell syntax anyway.)
18:16:47 <ivanm> the actual function is matchBud from here: http://code.haskell.org/~ivanm/dangd/Math/Combinatorics/Graph/Planar/DangD.hs
18:16:53 <ivanm> shachaf: ahhh
18:17:05 <shachaf> ivanm: Content-type isn't text/plain. :-(
18:17:13 <shachaf> I should be mad at my browser.
18:17:17 <otters> sometimes I wish Haskell had proper loops
18:17:23 <otters> rather than recursion
18:17:52 <dmwit> otters-- for BLASPHEMY
18:17:53 <bss03> otters: forM not enough?
18:18:04 <shachaf> ivanm: By the way: Use "Just x = ..." instead of "x = fromJust ..."
18:18:07 <ivanm> shachaf: yeah, that gets annoying
18:18:10 <otters> it's just when I'm trying to recurse in the IO monad
18:18:13 <ivanm> shachaf: oh? why?
18:18:14 <shachaf> ivanm: That way you get a nice line number if the pattern match fails.
18:18:17 <ivanm> hmmmmm
18:18:20 <otters> afaict there's no TCO because I run out of stack space after like
18:18:24 <doomlord> is that manually threaded stateful code for building graphs ... seeing all the m m' m''s in there :)
18:18:24 <shachaf> I know it won't ever fail. But still. :-)
18:18:31 <otters> some number under 250,000 recursions
18:18:45 <shachaf> otters: If you want loops, feel free to write them. :-)
18:18:47 * otters can iterate over /usr/share/dict/words in C, but not in Haskell :(
18:18:48 <orzo> Is ghc smart enough to optimize this away?  noOp =  map fst (map (,1))
18:19:00 <ivanm> shachaf: I went through my code, and anywhere where I had the possibility of a pattern match failure I replaced it with `fromMaybe (error "foo function")'
18:19:05 <orzo> (with tupple sections)
18:19:11 <ivanm> doomlord: yeah, something like that
18:19:18 <shachaf> orzo: Maybe -- compile it and find out.
18:19:28 <doomlord> reminds me of the crap i'm writing myself heh
18:19:34 <shachaf> You can probably add an explicit rule for it if it doesn't happen already.
18:19:38 <sinelaw> ivanm, still swimming in graphs, are you :)
18:19:48 <shachaf> ivanm: OK, but there's no real overhead to Just x = ...
18:19:49 <doomlord> let s' s'' s''' -- i dont understand the state monad yeet
18:19:55 <shachaf> And you get the error message for free. :-)
18:20:25 <sinelaw> ivanm, how's the dot-thingy going?
18:21:23 <shachaf> otters: "TCO" isn't quite something that makes sense when you're talking about evaluating Haskell.
18:21:31 <ivanm> sinelaw: which bit? :p
18:21:40 <ivanm> and my entire PhD thesis is on graphs... :p
18:21:45 <otters> shachaf: I have absolutely no idea how haskell evaluation works anyway
18:21:56 <shachaf> otters: But something like "forever x = x >> forever x" should use constant stack space.
18:22:01 <shachaf> otters: You should learn!
18:22:06 <otters> yeah
18:22:11 <Tarrasch> Hey, Is there any way to tell `cabal install` in which order to solve the dependencies. I'm using the "meta-package" yesod-platform whose sole purpose is to put strict version numbers on all other packages so I don't have too. But it's useless if it's not considered first by the dependency checker. Any ideas?
18:22:16 <otters> mine doesn't take constant stack space though
18:22:19 <otters> might as well paste the program
18:22:20 <dmwit> otters: If you want help, you need to post code instead of just whining. =)
18:22:23 <dmwit> yes
18:22:40 <otters> I like whining...it's much more satisfying
18:22:53 <dmwit> Tarrasch: "first"...?
18:23:09 <sinelaw> ivanm, i was using your dot stuff a while back for a project if you recall
18:23:34 <ivanm> oh, you wanted parallel processing of dot -Tdot, right?
18:23:38 <orzo> shachaf: well, my real situation is really that I want to do a sort of foldr but one that doesnt need to go to the end of the list... (could work on infinite) But in order to do it, i need to map (,False) first and then use the snd as a stopping condition (where it wont need to evaluate the right side) and then remove the Bool ...
18:23:38 <ivanm> never got around to that
18:23:43 <ivanm> I have ideas for it
18:23:54 <Tarrasch> dmwit: Yea, if "yesod-platform" is considered first, then cabal "don't need to think" about which versions to use for the other packages specified in my cabal file
18:24:07 <shachaf> ivanm: Oh, that kind of supervisor.
18:24:21 <ivanm> yeah, not work
18:24:21 <Cale> orzo: You ought to be able to build the map into the foldr
18:24:35 <shachaf> orzo: I don't understand.
18:24:36 <Cale> (though ghc will fuse them for you anyway)
18:25:11 <hpaste> otters pasted “otters' whiny program” at http://hpaste.org/76064
18:25:13 <ivanm> if you enable optimisations anyway
18:25:16 <sinelaw> ivanm, i've been away from haskell stuff for a while
18:25:25 <Cale> foldr f z . map g = foldr (f . g) z
18:25:29 <otters> picks N random lines from an input of unknown size
18:25:30 <liyang> shachaf: even that's tricky! http://hackage.haskell.org/trac/ghc/ticket/5205
18:25:34 <ivanm> ahhh, fair enough
18:25:44 <sinelaw> ivanm, so I don't really need that specific feature anymore
18:25:51 <ivanm> I'm currently trying to get someone from Graphviz upstream to realise that their mailing lists no longer exist :p
18:26:00 <ivanm> fair enough :)
18:26:08 <sinelaw> ivanm, yeah graphviz is rather dead
18:26:14 <otters> pick N for reading from stdin
18:26:17 <otters> or pick N FILE
18:26:29 <sinelaw> ivanm, i still use it very often though :)
18:26:47 <ivanm> yup
18:26:56 <ivanm> finally managed to get someone to answer his email though!
18:27:00 <twmb> I asked this yesterday, but I'm having trouble thinking about it again...
18:27:23 <ivanm> I think they all want graphviz to die, but no-one has a replacement for the smaller case (all the fun is in the "I have fifty million nodes!" use-cases)
18:27:25 <twmb> how would you read the type definition of length, "length :: (Num b, Integral a) => [a] -> b"?
18:27:30 <dmwit> otters: Your state is probably building up a very deeply nested thunk.
18:27:52 <otters> that's probably it
18:27:55 <ivanm> twmb: given a list of values which are all Integral, return a value that is a Num
18:28:07 <dmwit> Try something like put $! if ...
18:28:23 <ivanm> twmb: in the usual definition of length, there is no constraint on the list type, and the return value is an Int (though there is genericLength)
18:28:26 <ivanm> @type length
18:28:28 <lambdabot> forall a. [a] -> Int
18:28:29 <sinelaw> ivanm, i once tried reading their code and some papers to find out the basic algorithm behind dot, but it was too big an effort
18:28:30 <ivanm> @hoogle genericLength
18:28:30 <lambdabot> Data.List genericLength :: Num i => [b] -> i
18:28:38 <sinelaw> the code seems a huge mess
18:28:42 <ivanm> sinelaw: heh, yeah
18:28:55 <twmb> ivanm: so do the types in parenthesis, is there a reason they need to be in parenthesis?
18:29:05 <otters> dmwit: that worked o_o
18:29:20 <ivanm> twmb: for grouping
18:29:32 <ivanm> if you have more than one constraint on the LHS of an =>, you need to group them in parens
18:29:45 <twmb> ok,
18:29:45 <ivanm> I prefer doing so even if I have only one constraint, as it makes it easier to add another constraint :)
18:30:10 <twmb> and the order in which you use the function name or constraint doesn't matter, but it's convention to do functionName :: Constraints => ?
18:30:52 <ivanm> it's always: functionName :: Constraints => Type
18:30:54 <Cale> twmb: constraints always come before the rest of the type
18:30:59 <ivanm> if you dont' have constraints, it's functionName :: Type
18:31:23 <twmb> k, thanks for setting me straight again, time to continue learning
18:31:52 <sinelaw> ivanm, do you use any huge graph data sets for your research or is it just theory?
18:33:27 <ivanm> I'm only generating graphs
18:34:08 <sinelaw> ivanm, what sort of graphs?
18:34:17 <ivanm> planar graphs
18:34:24 <Axman6> complicated ones
18:36:20 <mm_freak> absence: pstep1 + pstep2
18:36:29 <ivanm> with "cabal bench", is there a way of saying "by default only use this benchmark, but if I tell you to run this one instead"?
18:36:34 <mm_freak> that's the same as liftA2 (+) pstep1 pstep2, i.e. the sum of the outputs
18:39:38 <carter> anyone here have experience with PLT Redex?
18:40:47 <ivanm> Axman6: hmmm?
18:44:15 <AxiomOfChoice> lambdabot: pointfree (\y -> if x == y then f y else id)
18:45:35 <ivanm> @pf \ y -> if x == y then f y else id
18:45:36 <lambdabot> Maybe you meant: bf pl
18:45:39 <ivanm> @pl \ y -> if x == y then f y else id
18:45:40 <lambdabot> flip (liftM2 if' (x ==) f) id
18:45:45 <ivanm> AxiomOfChoice: ^^
18:45:46 <AxiomOfChoice> Whoops, thanks.
18:45:54 <ivanm> note that if' is a lambdabot-ism
18:46:22 <AxiomOfChoice> ivanm: I see, thanks.
18:46:33 <ivanm> in reality, unless you wanted to define such a function yourself, you can't really simplify what you wrote
18:46:43 <AxiomOfChoice> ivanm: So I figured.
18:48:48 <dustingetz> how do i look up the source to, say, haskell div
18:48:53 <dustingetz> or haskell Integral
18:49:01 <dustingetz> hoogle isn't helping, hard to google for
18:49:42 <geekosaur> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:div
18:49:49 <dustingetz> i want to see the haskell code that shows me how the numeric types returned by div account for zero denominator without an exception
18:49:50 <ivanm> dustingetz: div depends on the Integral instance
18:50:15 <ivanm> in general, go to the documentation page on hackage and click on the "view source" option next to the function
18:50:25 <ivanm> lambdabot also knows _some_ definitions
18:50:26 <liyang> dustingetz: http://hackage.haskell.org/packages/archive/base/latest/doc/html/
18:50:29 <geekosaur> that said, this is getting into compiler internals territory which will be hard to deal with in general
18:50:29 <ivanm> @src Int div
18:50:30 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:50:47 <ivanm> but a lot of the numeric ones are defined at a rather low level
18:50:50 <shachaf> ivanm: I'm going to guess:
18:51:15 <ivanm> > 4 `div` 0
18:51:17 <lambdabot>   *Exception: divide by zero
18:51:18 <shachaf> div (I# a) (I# b) = I# (divInt# a b)
18:51:22 <ivanm> sure looks like an exception to me...
18:51:25 <geekosaur> they do throw an exception, anyway
18:51:29 <ivanm> shachaf: was that aimed at dustingetz?
18:51:29 <shachaf> Oh, maybe not.
18:51:31 <dustingetz> you're in IO or some monad that allows it
18:51:33 <dustingetz> presumablu
18:51:41 <ivanm> dustingetz: you can do error _anywhere_
18:51:45 <dustingetz> in ghci, i get NaN and Infinity appropriately
18:51:48 <ivanm> @type error
18:51:49 <lambdabot> forall a. [Char] -> a
18:51:53 <shachaf> Oh, no, they check for 0 explicitly.
18:51:55 <ivanm> dustingetz: that's using / on floating values
18:52:11 <dustingetz> so if i have some code that does int division
18:52:15 <dustingetz> and it type checks and compiles
18:52:18 <shachaf> > (-9223372036854775808::Int) `div` (-1)
18:52:20 <lambdabot>   *Exception: arithmetic overflow
18:52:37 <dustingetz> i thought i can assume that it won't through (it can return NaN though via a complex type)
18:52:38 <ivanm> dustingetz: yeah, you can't guarantee there aren't any numeric exceptions
18:52:40 <dustingetz> or Maybe
18:52:49 <dustingetz> why not?
18:52:50 <ivanm> write your own safeDiv function
18:52:55 <ivanm> (and there probably are some around)
18:52:57 <dustingetz> why can't you have div return Rational
18:53:00 <dustingetz> why does it return int
18:53:09 <ivanm> dustingetz: because it can get very annoying to unwrap Maybe values for the common case of non-zero denominators
18:53:10 <shachaf> (%) returns Ratio Int
18:53:26 <ivanm> does Rational prevent you from dividing by 0?
18:53:40 <shachaf> div :: (a::Int) -> (b::Int) -> NonZero b -> Int
18:53:42 <dustingetz> in SICP, a Rational type is defined which just stores a num and denom
18:53:43 <ivanm> dustingetz: quite often people want the same type coming out of a division as they did coming in...
18:53:51 <cmccann> > (0/0) :: Rational
18:53:52 <lambdabot>   *Exception: Ratio.%: zero denominator
18:53:53 <dustingetz> ivanm but then the type system is lying
18:53:54 <dustingetz> i don't get it
18:53:55 <ivanm> shachaf: why the third argument? default?
18:54:04 <ivanm> dustingetz: it's a trade-off
18:54:12 <shachaf> ivanm: It's a proof that b is nonzero.
18:54:16 <shachaf> That way it can't fail!
18:54:22 <dustingetz> so what are the other places, where safety is compromised
18:54:26 <liyang> Hagda FTW.
18:54:28 <ivanm> a compromise between absolute safety and usability
18:54:41 <shachaf> ...Unless a == minBound and b == -1
18:54:43 <ivanm> dustingetz: does actual scheme use rational for division?
18:54:49 <dustingetz> i dunno
18:54:49 <ivanm> dustingetz: head, tail
18:54:53 <ivanm> fromJust
18:54:55 <dustingetz> scheme isn't haskell
18:54:57 <cmccann> there is some benefit to Maybe-style semantics, where undefined operations produce an undefined value without throwing an exception
18:55:03 <ivanm> sure, but you're the one talking about SICP :)
18:55:10 <cmccann> also known as a non-signaling NaN
18:55:27 <ivanm> cmccann: sure, but in the general case of "I want to do computations using Haskell" it can get annoying
18:55:30 <shachaf> NaN stands for "Not a NaN"
18:55:33 <ivanm> heh
18:55:39 <dustingetz> so it is possible to write an expression outside of IO which crashes the program via an unhanded exception, without -XEmptyDataDecls
18:55:44 <cmccann> shachaf, surely you mean "NaN ain't NaN"
18:55:46 <cmccann> which is true
18:55:51 <ivanm> dustingetz: sure
18:55:54 <cmccann> > (0/0) == (0/0)
18:55:55 <dustingetz> *mind explodes*
18:55:55 <lambdabot>   False
18:55:56 <dustingetz> wtf
18:55:56 <ivanm> but you can catch these in IO
18:56:03 <ivanm> dustingetz: note: these are errors, not exceptions
18:56:11 <ivanm> errors are meant to be unrecoverable, exceptions are recoverable
18:56:21 <liyang> dustingetz: IEEE-754 has decreed it so.
18:56:23 <dustingetz> > 0/0
18:56:24 <lambdabot>   NaN
18:56:26 <ivanm> dustingetz: by definition of IEEE754, NaN /= NaN
18:56:32 <dustingetz> > (0/0) == (0/0)
18:56:34 <lambdabot>   False
18:56:39 <dustingetz> no exceptionm
18:56:42 <dustingetz> so what
18:56:48 <ivanm> liyang: oh good, I remembered the number correctly :p
18:56:49 <dustingetz> its a valid expression and it is defined to false
18:56:55 <dustingetz> that's not crashing the program
18:57:01 <signalsea> can someone help me to understand the pointfree dot combinator, (.) . (.),  piecewise?
18:57:06 <geekosaur> floating point is special.  again, blame IEEE754
18:57:10 <geekosaur> it's defined that way
18:57:20 <dustingetz> > (0.0/0.0)
18:57:22 <lambdabot>   NaN
18:57:23 <geekosaur> it's nonsensical, but there it is.
18:57:39 <cmccann> geekosaur, actually floats make a lot of sense for the purpose they're designed to solve
18:57:42 <shachaf> geekosaur: It's not *quite* nonsensical.
18:57:47 <cmccann> including the implicit Maybe-style semantics
18:58:01 <shachaf> > Nothing == Nothing
18:58:03 <lambdabot>   True
18:58:04 <cmccann> they're just not really "numbers" in the usual sense one would expect
18:58:05 <dustingetz> can someone evaluate a program in the bot right now which crashes the program
18:58:09 <dustingetz> outside of IO
18:58:17 <cmccann> > error "oh no!"
18:58:18 <dustingetz> the float equality is defined to False, that's not a crash
18:58:18 <lambdabot>   *Exception: oh no!
18:58:22 <shachaf> > fix error
18:58:24 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:58:35 <cmccann> ah, the canonical usage of "fix"
18:58:41 <danharaj> > fix (show "ponies" ++)
18:58:43 <lambdabot>   "\"ponies\"\"ponies\"\"ponies\"\"ponies\"\"ponies\"\"ponies\"\"ponies\"\"po...
18:58:49 <nejucomo> hehe
18:59:02 <shachaf> > fix show
18:59:04 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
18:59:10 <dustingetz> can you do it without a special form (error)
18:59:12 <cmccann> that's a lot of escape sequences
18:59:26 <dustingetz> i'm not sure why you consider an infinite list to be a crash
18:59:29 <cmccann> > fix not
18:59:30 <dustingetz> should i ?
18:59:32 <lambdabot>   mueval-core: Time limit exceeded
18:59:37 <shachaf> dustingetz: No, (fix show) isn't a crash.
18:59:39 <danharaj> what is a crash?
18:59:48 <dustingetz> crash - unhanded exception
18:59:54 <shachaf> > fix id
18:59:57 <danharaj> error "this is an unhandled exception"
18:59:58 <lambdabot>   mueval-core: Time limit exceeded
19:00:00 <shachaf> It crashed with an OutOfTimeError
19:00:20 * cmccann thinks there's a lot of unclear use of terminology going on here
19:00:31 <dustingetz> yeah, I'm not sure if I'm being unreasonable in my question
19:00:36 <dustingetz> error is a special form, that's cheating
19:00:44 <dustingetz> evaluating an inf series is cheating
19:01:12 <cmccann> define "cheating"
19:01:14 <ivanm> cmccann: yup
19:01:23 <danharaj> your question is undefined right now
19:01:29 <liyang> Rather than list what you consider cheating, could you tell us what is allowed?
19:01:30 * nejucomo reads fix description and source code; breaks brain.
19:01:31 <dustingetz> my question is, if i have a good-faith, reasonable expression, and it type checks, and it is not in IO, can it throw
19:01:37 <dmwit> > let f [] = 3 in f [3]
19:01:39 <lambdabot>   *Exception: <interactive>:3:4-11: Non-exhaustive patterns in function f
19:01:45 <dustingetz> without declaring that it throws in the type sig of the expression
19:01:45 <shachaf> cmccann: But don't you enjoy arguing about words?
19:01:49 <cmccann> define "reasonable".
19:01:51 <danharaj> > head []
19:01:52 <lambdabot>   *Exception: Prelude.head: empty list
19:01:53 <ivanm> dustingetz: a strong type system cannot prevent out-of-memory errors, computer-crashed errors, zomg-there's-a-fire-in-the-building errors, etc.
19:02:05 <dustingetz> understood
19:02:10 <cmccann> I could define "reasonable" expression as one which will not evaluate to bottom
19:02:11 <shachaf> ivanm: Agda can.
19:02:18 <cmccann> in which case the answer is trivial
19:02:20 <dustingetz> eliminate the class of errors which are related to register machines, which have state we can't avoid
19:02:35 <ivanm> now, if you wanted absolute safety/security, it's possible (and quite possibly already done) to write a "safe" Int-like data type that has a special "error" constructor
19:02:46 <dustingetz> cmccaann: unclear whether its trivially true or trivially false
19:02:59 <ivanm> you can define non-empty lists
19:03:02 <dustingetz> if i say i have an expression, with no exceptions in the return type, which is not in IO and does not evaluate to bottom
19:03:05 <ivanm> (that don't have the head/tail issues)
19:03:11 <dustingetz> can it throw
19:03:27 <cmccann> no, because you defined it not to
19:03:30 <cmccann> that's what "bottom" means
19:03:41 <ivanm> shachaf: all of them?
19:03:45 <elliott> <dustingetz> my question is, if i have a good-faith, reasonable expression, and it type checks, and it is not in IO, can it throw
19:03:48 <liyang> dustingetz: Haskell exceptions don't show up in the type.
19:03:53 <Cale> dustingetz: bottom is a value which represents all forms of nontermination, including exceptions
19:03:55 <elliott> :t Control.Exception.throw
19:03:57 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> a
19:03:59 <elliott> so yes
19:04:04 <shachaf> ivanm: Yes, even computer-on-fire.
19:04:07 <dustingetz> so lets say the expression was in error monad
19:04:09 <elliott> note that undefined is defined as throw somethingorother
19:04:23 <dustingetz> can there be any exceptions that can't be redefined into error monad
19:04:25 <ivanm> liyang: which is good from the "damn this Java type is huge from all the errors" PoV, bad from the "OK, which exceptions can I expect from here" PoV
19:04:26 <dustingetz> and thus show up on the type
19:04:27 <ivanm> shachaf: :o
19:04:31 <ivanm> shachaf: how?
19:04:37 <ivanm> shachaf: note I said _building_ is on fire!
19:04:40 <Cale> dustingetz: However, note that it's impossible to *catch* exceptions from non-IO code
19:04:43 <shachaf> ivanm: Oh, *building*.
19:04:46 <shachaf> ivanm: That's in Agda'
19:04:50 <elliott> dustingetz: that question doesn't make any sense
19:04:52 <mm_freak> there is one kind of error for which you can't write a type signature against in haskell:  bottom
19:05:02 <ivanm> shachaf: also, can Agda protect against "someone tripped and pulled the power cable out of the computer" error?
19:05:05 <mm_freak> you have that problem in every turing-complete language
19:05:14 <dustingetz> mm_freak: what about exceptions
19:05:15 <mm_freak> to defend against that you need a language like agda
19:05:20 <cmccann> the most common solution to prevent runtime errors in Agda is by not running the program
19:05:27 <monochrom> haha
19:05:28 <shachaf> ivanm: Yes, that's in HEAD already.
19:05:28 <ivanm> cmccann: heh
19:05:28 <cmccann> and it does indeed prevent all errors
19:05:29 <dustingetz> or are exceptions only for things related to runtime implementation, like RAM
19:05:35 <Cale> dustingetz: So if you throw one, it essentially means that you've completely given up on ever producing a result, unlike null in OO languages.
19:05:35 <elliott> @remember cmccann the most common solution to prevent runtime errors in Agda is by not running the program
19:05:36 <lambdabot> Done.
19:05:43 <mm_freak> dustingetz: one form of bottom is an exception…  it's the "never calculated" value
19:05:49 <ivanm> cmccann: is that related to the old GHC technique of deleting source code if it failed to type-check?
19:06:03 <mm_freak> dustingetz: IO exceptions are something different…  they are actually expressed in the type
19:06:08 <dustingetz> understood
19:06:08 <mm_freak> but very implicitly
19:06:17 <ivanm> dustingetz: exceptions are meant to be from recoverable issues
19:06:17 <mm_freak> think of Maybe
19:06:18 <dustingetz> I'm interested in the case of an expression which is not inside IO
19:06:34 <mm_freak> dustingetz: such an exception might be "x = x"
19:06:37 <mm_freak> > let x = x in x
19:06:38 <Cale> dustingetz: You can use an exception to mean "I'd rather this program stop running right now and fail than continue, because some fundamental assumption that it was based on is false"
19:06:41 <lambdabot>   mueval-core: Time limit exceeded
19:06:42 <ivanm> "I couldn't parse the provided value", etc.
19:06:50 <nejucomo> I'm totally confused by fix.  I just tried: fix (\x -> x * x) and my interpreter is doing a lot of work.  ;-)
19:07:00 <dustingetz> Cale: but that would either need a special form (assert/error), or it would need to be on the tyope
19:07:06 <elliott> <mm_freak> dustingetz: IO exceptions are something different…  they are actually expressed in the type
19:07:06 <dustingetz> is this statement false ^ ?
19:07:09 <elliott> this isn't true
19:07:16 <elliott> at least unless you have a weird definition of io exception
19:07:16 <Cale> > error "die" :: Integer
19:07:17 <mm_freak> nejucomo: typocally 'fix' is used this way: fix (\again -> …)
19:07:18 <lambdabot>   *Exception: die
19:07:19 <shachaf> nejucomo: If you compiled it, it would probably finish much more quickly.
19:07:28 <Cale> > 1 : 2 : 3 : error "die" :: [Integer]
19:07:29 <mm_freak> > fix (\again -> 1 : again)
19:07:30 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:07:30 <lambdabot>   can't find file: L.hs
19:07:33 <Cale> derp
19:07:36 <Cale> > 1 : 2 : 3 : error "die" :: [Integer]
19:07:37 <lambdabot>   [1,2,3*Exception: die
19:08:07 <Cale> So there you have such an exception being thrown from a pure list of integers
19:08:26 <Cale> however, it's impossible to catch that, at least from the point of view of evaluating expressions
19:08:31 <dustingetz> > :t error
19:08:31 <liyang> > length [1,2,3,error "oops"]
19:08:33 <lambdabot>   <no location info>: parse error on input `:'
19:08:33 <lambdabot>   can't find file: L.hs
19:08:35 <mm_freak> dustingetz: "exceptions" in the IO sense are captured semantically…  they are observable and hence not really "exceptions" in the semantic sense…  think of Maybe, where Nothing is the computation that throws an exception
19:08:37 <Cale> So it's similar in meaning to this program:
19:08:48 <Cale> > let x = x in 1 : 2 : 3 : x :: [Integer]
19:08:50 <dustingetz> error appears to be a special form
19:08:52 <lambdabot>   mueval-core: Time limit exceeded
19:08:56 <monochrom> every year, some group of programmers on the internet debate over reasonable uses of exceptions
19:08:59 <dustingetz> @type error
19:09:00 <Cale> > let x = x in take 3 (1 : 2 : 3 : x :: [Integer])
19:09:00 <lambdabot> forall a. [Char] -> a
19:09:01 <lambdabot>   [1,2,3]
19:09:13 <dustingetz> that signature doesn't make any sense
19:09:15 <dustingetz> is a bottom?
19:09:15 <mm_freak> monochrom: i don't think this is about usage, but rather about fundamentals
19:09:32 <dustingetz> yes, im interested in fundamentals, I'm noob
19:09:34 <Cale> dustingetz: It says that for any type a, it takes a string and produces a value of type a
19:09:36 <mm_freak> dustingetz: 'bottom' is a value, not in the type
19:09:42 <mm_freak> s/in the/a/
19:09:49 <nejucomo> Ok, so let me try a new question: when would I ever use fix?
19:09:52 <monochrom> there is no fundamental for this
19:09:57 <zebr> (_|_) :: a, kinda
19:09:58 <nejucomo> Also what are it's runtime costs?
19:09:58 <dustingetz> @type fix
19:10:00 <lambdabot> forall a. (a -> a) -> a
19:10:04 <cmccann> nejucomo, for showing off in #haskell mostly
19:10:09 <dustingetz> > fix 1
19:10:10 <lambdabot>   1
19:10:12 <nejucomo> cmccann: haha!
19:10:20 <elliott> i actually use fix sometimes
19:10:20 <Cale> nejucomo: it's handy when you want to loop in the middle of a do-block. Saves you from defining some recursive thing first and then calling it.
19:10:20 * cmccann is not really joking there fyi
19:10:24 <elliott> i forget when
19:10:26 <mm_freak> nejucomo: fix $ \again -> do p <- randomNumber; if isPrime p then return p else again
19:10:32 <Cale> fix $ \loop -> do ... ; loop
19:10:34 <danharaj> inline recursive functions
19:10:46 <elliott> i generally separate functions out into a where
19:10:57 <elliott> fix (partially applied function) is nice
19:11:01 <cmccann> and usually there's some better recursion combinator than fix anyhow
19:11:12 <mm_freak> i use fix quite frequently
19:11:28 <nejucomo> mm_freak: Can you give an example?
19:11:42 <dustingetz> so rephrasing: given an expression with type int -> int, which is not in IO and does not evaluate to bottom, what things other than return an int can it do
19:11:44 <nejucomo> mm_freak: Oh, I see your example.
19:11:44 <dustingetz> how do i crash it
19:11:45 <mm_freak> nejucomo: i just did
19:11:48 <mm_freak> =)
19:11:48 <dustingetz> in my mind, that's like crashing math
19:11:52 <dustingetz> what am i missing
19:12:00 <Cale> dustingetz: nothing
19:12:02 <dustingetz> i can crash math by running it on a register machine instead of in my head
19:12:09 <Cale> > 1 `div` 0
19:12:10 <mm_freak> dustingetz: it may fail to return
19:12:10 <lambdabot>   *Exception: divide by zero
19:12:16 <dustingetz> eliminate that class of errors
19:12:16 <dustingetz> @type div
19:12:18 <lambdabot> forall a. (Integral a) => a -> a -> a
19:12:23 <Cale> dustingetz: bottom encompasses all those errors and nontermination
19:12:24 <mm_freak> dustingetz: then nothing
19:12:54 <dustingetz> so the only way is via arithmetic errors, which are either register machine impl details, or DivByZero for convenience because we're too lazy to unwrap Maybes
19:12:54 <mm_freak> in haskell a function with that type either returns an Int (assuming you meant Int instead of int) or does not return
19:12:59 <Cale> (or: just nontermination, because we think of errors as just being a faster version of spinning forever without producing a result)
19:13:00 <elliott> these questions do not make any sense to me
19:13:06 <elliott> or at least their phrasing suggests some really odd thinking
19:13:12 <mm_freak> dustingetz: arithmetic errors are either on the value level or are equivalent to bottom
19:13:13 <cmccann> elliott, so how is raven like a writing desk?
19:13:15 <mm_freak> > 1/0
19:13:17 <lambdabot>   Infinity
19:13:23 <nejucomo> mm_freak: Can you explain what your example does?
19:13:26 <dustingetz> > (\x -> div x 0) 1
19:13:28 <lambdabot>   *Exception: divide by zero
19:13:35 <Cale> Infinity is a non-bottom value of Float/Double
19:13:36 <monochrom> why do you want to crash the computer by merely doing Int arithmetic
19:13:39 <shachaf> > BerMalBerIst
19:13:40 <lambdabot>   Not in scope: data constructor `BerMalBerIst'
19:13:43 <dustingetz> @type (\x -> div x 0) 1
19:13:45 <mm_freak> nejucomo: fix (\again -> …) -- 'again' is the computation after the "->"
19:13:45 <lambdabot> forall a. (Integral a) => a
19:13:52 <dustingetz> @type (\x -> div x 0)
19:13:54 <lambdabot> forall a. (Integral a) => a -> a
19:14:11 <dustingetz> so the reason there's no error on the type of div, is because of convenience
19:14:14 <bgamari> Is there any easy way to mark all of the fields of a record as strict?
19:14:25 <bgamari> surrounding all of the types with !( ) gets rather tiresome
19:14:27 <mm_freak> > div 3 0
19:14:28 <lambdabot>   *Exception: divide by zero
19:14:31 <Cale> nejucomo: fix (\x -> ... x ...) is like  let x = ... x ... in x
19:14:34 <mm_freak> dustingetz: yes, convenience
19:14:46 <mm_freak> bgamari: no
19:15:10 <Cale> bgamari: You don't need the parens in many cases
19:15:10 <elliott> "yes, convenience"?
19:15:16 <elliott> it seems to me to have nothing to do with convenience whatsoever
19:15:16 <mm_freak> bgamari: also strict fields without unboxing is usually a bad idea
19:15:41 <mm_freak> elliott: do you want 'div' to give you a Maybe?  or let Integer have values like NaN/Infinity?
19:15:52 <monochrom> "fix" is just anonymous recursion
19:15:53 <Cale> bgamari: actually, I think you don't need the parens in any case, am I wrong?
19:16:00 <nejucomo> mm_freak: Yeah...  I'm still having a problem with understanding the recursive binding itself.
19:16:11 <elliott> i assumed dustingetz was talking about bottom in general.
19:16:12 <bgamari> Cale, If the type takes arguments (e.g. Map Int Int)
19:16:12 <mm_freak> Cale: yes, you are…  you need the parens in case of type constructors
19:16:13 <elliott> not just the case of div
19:16:17 <elliott> in fact I do want div to return Maybe
19:16:19 <monochrom> nejucomo: try my http://www.vex.net/~trebla/haskell/fix.xhtml
19:16:25 <elliott> or at least to have a better second argument type
19:16:29 <nejucomo> I need to write out redexes for a simple case.
19:16:30 <elliott> but that is another matter
19:16:35 <nejucomo> monochrom: Thanks.
19:16:42 <shachaf> I want HyperInteger in addition to Integer.
19:16:43 <mm_freak> nejucomo: the first argument of the function you pass to 'fix' is the expression it represents
19:16:52 <bgamari> mm_freak, Why is strictness without unboxing bad?
19:17:08 <bgamari> currently I'm just trying to figure out why I'm stack overflowing
19:17:14 <Cale> mm_freak: ah, yeah, the production has atype there
19:17:16 <mm_freak> bgamari: in a nonstrict field you can decide when to evaluate, in a strict field evaluation happens regardless
19:17:18 <Cale> mm_freak: huh
19:17:28 <danharaj> edwardk: Just wanted your eyes on this function because I'm not sure it has the semantics I intend. I haven't worked with the concurrency primitives before. http://hpaste.org/76067
19:18:06 <mm_freak> nejucomo: fix (\again -> a >> b >> c), then again = a >> b >> c
19:18:15 <mm_freak> nejucomo: fix (\again -> a >> b >> again), then again = a >> b >> again
19:18:24 <mm_freak> hence "again" =)
19:18:33 <danharaj> fix turns a function into an equation for a value
19:18:37 <edwardk> thats complicated enough that i'd need more motivation ;)
19:18:43 <mm_freak> that's what i call it usually…  sometimes i call it "r", and others call it "loop"
19:18:57 <monochrom> there need more fix tutorials than monad tutorials
19:18:58 <shachaf> PSA: a >> b >> c === (a >> b) >> c
19:19:11 <Cale> dustingetz: yes, convenience
19:19:29 <bgamari> mm_freak, this is true; unfortunately adding strictness here fixes my stack overflow
19:19:31 <Cale> dustingetz: Sometimes it's actually not convenient, but most of the time it is.
19:19:43 <dustingetz> besides div
19:19:49 <dustingetz> what other functions, for example, have this property
19:19:54 <bgamari> mm_freak, and it's much easier just to force strictness in the datatype than track down every usage and figure out whether it's safe
19:19:54 <dustingetz> of having a type which is a lie
19:19:55 <mm_freak> bgamari: then your data dependencies are broken, and strict fields are just a workaround =)
19:19:59 <dustingetz> for convenience
19:20:02 <Cale> dustingetz: Well, it's not a lie
19:20:03 <danharaj> edwardk: So normally if I use an IO action as a Source, when something demands a value from it the whole machine will block until the IO action produces a value.
19:20:05 <danharaj> This is supposed to spin the action off into a separate thread so that demands for the value produce Nothing until the action produces something. Then it produces Just the value. Subsequent requests cause the action to be spun up again.
19:20:10 <monochrom> you need unboxing for polymorphism, too. and where you don't have polymorphism either, the compiler probably unboxes for you
19:20:10 <Cale> dustingetz: _|_ is a value of type Integer
19:20:15 <nejucomo> monochrom: Thanks.  That helps a lot.  I had thought this was doing some kind of local minimum search, which had me quite confused.
19:20:20 <dustingetz> cale, is that bottom?
19:20:22 <mm_freak> bgamari: strict fields impose some things you don't usually want
19:20:24 <Cale> dustingetz: yes
19:20:33 <mm_freak> bgamari: let (x, y) = (3, x*x)
19:20:35 <Cale> dustingetz: Every type has a bottom value
19:20:38 <dustingetz> how is it not a lie
19:20:42 <mm_freak> bgamari: if (,) were strict that wouldn't work
19:20:44 <Cale> dustingetz: a least defined value
19:20:44 <monochrom> thank you for chooing monochrom!
19:20:45 <dustingetz> 1/0 doesn't return bottom
19:20:49 <dustingetz> oh, it does
19:20:50 <dustingetz> boom
19:20:58 <mm_freak> dustingetz: it doesn't for Float/Double
19:21:03 <Cale> dustingetz: 1/0, well, it depends which type you're using
19:21:06 <mm_freak> div 1 0 returns bottom
19:21:12 <mm_freak> for Integer at least
19:21:17 <shachaf> mm_freak: div 1 0 *is* bottom
19:21:25 <mm_freak> yeah, that's a better way to word it
19:21:26 <shachaf> It doesn't return anything because it's not a function. :-)
19:21:28 <dustingetz> how do you relate bottom in haskell to -XEmptyDataDecls
19:21:29 <mm_freak> div 1 0 = ⊥
19:21:31 <danharaj> that's the colloquial meaning of 'returns'
19:21:47 <Cale> dustingetz: An empty data declaration has only one value, which is bottom
19:21:47 <bgamari> mm_freak, If there were better tools for identifying the source of the thunk explosion then I might be willing to track it down; sadly it seems these tools either don't exist or I haven't stumbled upon them yet
19:21:50 <mm_freak> dustingetz: data X; x :: X; x = x
19:22:00 <Cale> (or, a datatype defined by one does)
19:22:10 <mm_freak> bgamari: profiling may help
19:22:17 <Cale> dustingetz: because of general recursion, it's impossible to prevent bottom from occuring as a value
19:22:28 <dustingetz> yeah
19:22:29 <mm_freak> bgamari: but it's usually better to think of data dependencies while coding
19:22:33 <Cale> dustingetz: since any computation can take arbitrarily long
19:22:36 <dustingetz> so [1..] is bottom too
19:22:39 <Cale> no!
19:22:44 <Cale> [1..] is completely defined
19:22:44 <dustingetz> if i realize it?
19:22:45 <mm_freak> dustingetz: last [1..] is bottom
19:22:48 <dustingetz> ah
19:22:49 <dustingetz> thanks
19:22:52 <Cale> length [1..] is bottom as well
19:23:01 <mm_freak> [1..] couldn't be more defined
19:23:04 <dustingetz> agree
19:23:04 <bgamari> mm_freak, yeah, so I've heard. One day it'll become second nature but until then, pain and unnecessary strictness
19:23:17 <bgamari> mm_freak, I'll try tracking this one down though, thanks for the encouragement
19:23:18 <mm_freak> dustingetz: bottom is the "least defined" value
19:23:44 <mm_freak> bgamari: happy to hear…  let me encourage you by saying that i seldomly run into these issues =)
19:23:50 <mm_freak> but it took some time to get there
19:24:16 <mm_freak> and when i do, i usually know where it comes from
19:24:41 <monochrom> bgamari: my http://www.vex.net/~trebla/haskell/lazy.xhtml may help you know the issues
19:24:42 <Cale> dustingetz: You can arrange values into a partial ordering based on definedness, where x <= y if y can be obtained from x by replacing occurrences of _|_ in x with other values
19:24:44 <nejucomo> lazy recursion trips me up sometimes because there's no "base case".
19:24:59 <bgamari> mm_freak, monochrom, Thanks
19:24:59 <dustingetz> you guys are awesome thank you so much for your help
19:25:12 <Cale> _|_ is then the very bottom of this ordering
19:25:25 <Cale> and maximal elements are the fully-defined values
19:25:26 <mm_freak> nejucomo: as long as your recursion is productive, there is no problem =)
19:25:38 <mm_freak> > let x = 1 : x in x
19:25:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:25:41 <Cale> and in between, for structured types like [Bool] you get lots of other things
19:25:57 <Cale> like  _|_ : True : _|_ : False : _|_
19:26:13 <mm_freak> nejucomo: that means:  if your recursive call is wrapped by a nonstrict constructor there is no problem
19:26:19 <mm_freak> nejucomo: the constructor in this case is (:)
19:26:39 <monochrom> how to know the recursion "x = 1:x" gives you the infinite list of 1's: there actually is a base case, it's ⊥
19:27:05 <shachaf> monochrom: There's no _|_ anywhere there. :-(
19:27:15 <mm_freak> monochrom: how would you formalize that sensibly?
19:27:20 <mm_freak> because i agree with shachaf there
19:27:30 <shachaf> I think I understand what monochrom means, though.
19:27:57 <mm_freak> i think the same, but i don't think "bottom is the base case" is a sensible thing to say
19:27:58 <monochrom> you construct this sequence. the first item is always ⊥. the (n+1)th item is always f (the nth item), if your recursion is "x = f x"
19:28:00 <Cale> fix f finds the limit of the sequence {_|_, f _|_, f (f _|_), ...} in the definedness ordering, if it exists
19:28:03 <rwbarton> you can compute the fixed point of f as the limit ... ^
19:28:14 <mm_freak> ah, i understand
19:28:23 <bgamari> mm_freak, monochrom, Just to confirm, the point which the -xc stack trace points to as the source of the stack overflow is not the source of the exploding thunks, correct?
19:28:27 <bgamari> It's just the point they were evaluated
19:28:30 <Cale> well, it exists :)
19:28:33 <monochrom> so, "x = 1:x". the first item is ⊥. the second item is 1:⊥. the 3rd item is 1:(1:⊥). etc.
19:28:52 <monochrom> now you take the "limit" of that sequence. that's 1:1:1:...
19:28:56 <shachaf> You can always pretend there's a ⊥ just past the last 1 you look at.
19:29:11 <mm_freak> bgamari: the stack grows with pattern matches, not with function invocations
19:29:18 <Cale> shachaf: Yeah, and that kind of gives another way to look at evaluation
19:29:24 <mm_freak> function invocation is stackless in GHC haskell
19:29:26 <shachaf> I think defining a total value with no ⊥s anywhere in terms of ⊥ is annoying, though. :-(
19:29:37 <Cale> as the process of replacing _|_'s with other values according to the program
19:30:16 <Cale> (i.e. in a way which is consistent with the equations you've given)
19:30:20 <rwbarton> it's not really "replacing", is it
19:30:27 <rwbarton> more like you are drilling down into smaller and smaller sets
19:30:40 <rwbarton> ??? -> 1 : ??? -> 1 : 1 : ??? -> 1 : 1 : 1 : ??? -> ...
19:30:52 <monochrom> Cale, under popular assumptions about the programming language being used, "if it exists" is redundant. it exists, period. for it to not exist, f must be discontinuous, but you don't usually have a programming language supporting discontinuous functions
19:31:03 <mm_freak> > fix (\bottom -> 1 : bottom)
19:31:04 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:31:20 <Cale> monochrom: right, I did say "well, it exists :)" a little later
19:31:27 <monochrom> yeah
19:32:26 <Cale> Every effective function is monotone and continuous with respect to the definedness ordering
19:33:05 <Cale> so if x <= y then f x <= f y
19:33:42 <Cale> This is basically another way to say that we don't have termination oracles.
19:33:42 <monochrom> some other day we will discuss the discontinous case (but still monotonic) and transfinite ordinals!
19:37:08 <shachaf> monoton
19:38:58 <dustingetz> @type safeDiv
19:39:00 <lambdabot> Not in scope: `safeDiv'
19:39:40 <mm_freak> Integer a -> Integer NonZero -> Integer a
19:39:58 <dustingetz> im looking at the implementation in hackage
19:40:05 <dustingetz>    in  if isZero r
19:40:06 <dustingetz>          then q
19:40:07 <dustingetz>          else error "safeDiv: indivisible term"
19:40:14 <dustingetz> error is a special form, not expressed in the type
19:40:15 <dustingetz> how is that safe
19:40:20 <mm_freak> it's not
19:40:34 <rwbarton> weird
19:40:34 <dustingetz> @type error
19:40:36 <lambdabot> forall a. [Char] -> a
19:40:42 <cmccann> we need more functions with "safe" in the name
19:40:46 <rwbarton> > 1 `div` 0
19:40:47 <lambdabot>   *Exception: divide by zero
19:40:50 <cmccann> safePerformIO :: IO a -> IO a
19:40:52 <rwbarton> basically the same thing
19:41:03 <cmccann> safeFromJust :: Maybe a -> Maybe a
19:41:04 <shachaf> cmccann: Fortuantely every function with "unsafe" in its name has "safe" in its name.
19:41:12 <shachaf> So the "safe" crowd always wins.
19:41:17 <monochrom> haha
19:41:21 <mm_freak> safeFromJust :: Maybe IsJust a -> a
19:41:38 <dustingetz> how is safeDiv safe if it can still throw
19:41:43 <dustingetz> > error "hi"
19:41:44 <lambdabot>   *Exception: hi
19:41:46 <mm_freak> dustingetz: as said, it's not
19:41:47 <dustingetz> so error is considered bottom
19:42:02 <shachaf> error x is ⊥ for any x
19:42:08 * cmccann thinks dustingetz would be happier programming in Agda
19:42:10 <mm_freak> safeDiv isn't really safeDiv, and i really wonder about the quality of the library you found that function in
19:42:16 <shachaf> If x isn't a String, it's a compile-time ⊥!
19:42:22 <dustingetz> ohhhh its not defined in haskell core
19:42:23 <monochrom> perhaps your "safe" and their "safe" are unrelated?
19:42:26 <dustingetz> its some shitty lib
19:42:38 <cornihilio> can someone perhaps please help me with this?: https://gist.github.com/3862840
19:42:44 <mm_freak> dustingetz: hackage is a library of haskell packages from arbitrary people
19:42:50 <dustingetz> got it
19:42:59 <mm_freak> dustingetz: see the Acme category there =)
19:43:04 <mm_freak> i like acme-dont
19:43:06 <cornihilio> it's like I am stuck misusing the do monad
19:43:06 <shachaf> cornihilio: Your type is wrong.
19:43:07 <monochrom> you know how different people use "object" to refer to unrelated things. so why not "safe" too
19:43:14 <mm_freak> don't (putStrLn "Hello world!")
19:43:31 <rwbarton> it's in numeric-prelude apparently
19:43:38 <dustingetz> > length [1..]
19:43:40 <shachaf> I love the do monad!
19:43:42 <lambdabot>   mueval-core: Time limit exceeded
19:43:44 <cornihilio> shachaf: but why is it trying to return there? that's just a statement, not hte return value for my function (or at least I don't want it to be)
19:44:15 <shachaf> cornihilio: I don't know. Simplify it until it doesn't error, then add things slowly until it does.
19:44:35 <mm_freak> cornihilio: try 'where' instead of 'do'
19:44:40 <rwbarton> since it's cornihilio it's much more likely that the type is right and the 'do' is wrong
19:44:45 <mm_freak> "x <- c" is not the same as "x = c"
19:44:56 <mm_freak> and i'm pretty sure you want "x = c"
19:45:11 <monochrom> looks like you shouldn't even be using "do" and "<-"
19:45:31 <rwbarton> yes
19:46:01 <mm_freak> and please don't begin with "createRawPacket contents = where" =)
19:46:25 <monochrom> perhaps use "let" so that you can keep the punchline at the end
19:47:00 <mm_freak> usually when i use 'where' i keep the punchline at the beginning, but below the "where" keyword
19:47:27 <mm_freak> f x = result where result = …
19:47:40 <elliott> cornihilio: it's quite hard to misuse something that doesn't exist
19:47:57 <stew> you guys and your punchlines
19:49:04 <dustingetz> > Double
19:49:06 <lambdabot>   Not in scope: data constructor `Double'
19:49:14 <dustingetz> how do i ask ghci for the definition of double
19:49:23 <dustingetz> and at what point does the complex type allow for NaN and Inf
19:49:31 <monochrom> it doesn't have that
19:49:42 <dustingetz> e.g. an algebraic data type: double64 | NaN | Inf (something like that)
19:49:44 <dustingetz> am i wrong?
19:49:50 <monochrom> well, maybe ":info Double" tells you something
19:49:51 <bgamari> mm_freak, If I add a strictness annotation to even a single field of this record I seem to avoid the overflow
19:49:52 <shachaf> dustingetz: :i, but that's not how Double works.
19:49:59 <dustingetz> how does it work
19:50:05 <shachaf> dustingetz: NaN and Inf and all that are probably implemented directly in your CPU.
19:50:07 <rwbarton> it's just an IEEE double presumably
19:50:11 <dustingetz> oh, IEEE doubles have these conecpts
19:50:15 <dustingetz> so you don't need algebraic data type
19:50:19 <mm_freak> bgamari: the find out where you return the record, but don't force the field
19:50:29 <mm_freak> the → then
19:50:46 <edwardk> danharaj: can you send me it in an email?
19:51:26 <mm_freak> dustingetz: conceptually every type is algebraic, but it may be only on its surface
19:51:27 <rwbarton> by which I mean a compiler is free to do what it likes with Double but ghc and probably any other compiler just uses IEEE doubles
19:51:36 <mm_freak> for example an Integer is actually a GMP integer in memory
19:51:44 <mm_freak> at least in GHC with the default configuration
19:52:23 <Cale> mm_freak: there's function types...
19:52:25 <mm_freak> and even that is not accurate, because GHC can choose a machine integer at runtime
19:52:36 <Cale> mm_freak: I guess maybe those count
19:53:13 <mm_freak> Cale: i think functions are conceptually algebraic, too, but they are opaque
19:53:42 <mm_freak> but i agree that they are a special case
19:53:57 <Cale> I think function types are not, in general
19:54:17 <mm_freak> well, you can't /define/ the function type
19:54:19 <Cale> An algebraic data type is a recursive sum of product types.
19:54:41 <rwbarton> if you find ezyang's blog post with pictures of the domains corresponding to various types you can tell the function types have some distinguishing characteristics
19:54:49 <edwardk> danharaj: just kind of distracted IRL
19:54:57 <rwbarton> for example, you can have an infinite descending sequence of values of a function type
19:55:08 <rwbarton> which I found a bit surprising
19:55:23 <roconnor> rumour has it that functions are coalgebraic
19:55:34 <rwbarton> well, perhaps that isn't so surprising
19:55:46 <zzing> When I have a record with a certain name, is there a function defined so that I can replace the content (obviously in a copy)
19:56:11 <geekosaur> hm?  myRecord { someField = newValue }
19:56:17 <Cale> zzing: not a function, but a notation anyway
19:56:27 <zzing> notation is good
19:56:36 <geekosaur> "record update syntax"
19:56:39 <latro`a> geekosaur: syntactic sugar for building new records from old ones
19:56:54 <dustingetz> is it accurate to say, the definition of `error` is that it returns bottom
19:57:10 <dustingetz> so you could implement that as any expression that is bottom
19:57:21 <dustingetz> s/returns/is defined as
19:57:32 <latro`a> data Foo a = { bar :: a, baz :: a}; kwag = Foo {bar = 2, baz = 3}; del = kwag {bar = 4}
19:57:49 <latro`a> that del line is the same as del = Foo {bar = 4, baz = baz kwag}
19:57:59 <latro`a> eh
19:58:06 <latro`a> *data Foo a = Foo { bar :: a, baz :: a}
19:58:09 <latro`a> sorry
19:58:13 <Cale> dustingetz: yeah, though an implementation which did that would be considered a little impractical. It's nice when you can *tell* that a value is bottom to just quit
19:58:31 <latro`a> does that help geekosaur
19:58:32 <latro`a> ?
19:58:45 <geekosaur> what?  I was answering, not asking
19:58:50 <latro`a> oh
19:58:51 <Cale> dustingetz: replacing  error "foo"  with a program which just took forever and used 100% CPU would be a little bit mean :)
19:58:51 <latro`a> derp
19:58:52 <shachaf> Cale: Some of the time, anyway.
19:58:52 <latro`a> sorry
19:58:56 <latro`a> wasn't following the whole discussion
19:58:59 <Cale> dustingetz: (but semantically valid)
19:59:04 <geekosaur> so I figured
19:59:05 <dustingetz> thank you
19:59:23 <latro`a> sorry, I saw "hm?" and assumed a question
19:59:37 <latro`a> as opposed to "this is straightforward"
20:01:45 <startling> is there a function somewhere for template haskell that does what ' does?
20:01:58 <startling> I want to give it a string and get the fully-qualified name in the current scope
20:02:06 <rwbarton> @hoogle reify
20:02:06 <lambdabot> Language.Haskell.TH.Syntax reify :: Name -> Q Info
20:02:06 <lambdabot> Language.Haskell.TH reify :: Name -> Q Info
20:02:06 <lambdabot> package reify
20:02:10 <rwbarton> hmm
20:02:12 <rwbarton> maybe not that
20:02:55 <Cale> lookupValueName and lookupTypeName are similar to 'f and ''T respectively, but the Names are looked up at the point where the current splice is being run. These names can never be captured.
20:03:03 <rwbarton> yeah
20:03:35 <startling> Cale: how do you mean "captured"?
20:03:49 <rwbarton> ask http://hackage.haskell.org/packages/archive/template-haskell/latest/doc/html/Language-Haskell-TH-Syntax.html#t:Name not Cale
20:03:51 <Cale> http://hackage.haskell.org/packages/archive/template-haskell/2.8.0.0/doc/html/Language-Haskell-TH-Syntax.html#namecapture
20:03:56 <zzo38> Do you understand the CodensityAsk yet, or do you need to ask about it (like the name even says "ask" so you can ask about it)?
20:04:29 <zzo38> Cale: I think 'f and ''T use the names in scope is that it?
20:04:52 <rwbarton> so you may instead want mkName
20:04:53 <zzo38> Except you cannot use that syntax with names x' and so on
20:06:00 <startling> rwbarton: well, I've got a Map Name x, and I don't want identical names from different modules to look up the same thing
20:06:26 <startling> does that make sense?
20:07:19 <elliott> zzo38: very good pun
20:07:56 <rwbarton> what about if I have the same name twice in the same module
20:08:00 <cornihilio> I want to display a certain datatype in a specific format when I use show; should I be looking into creating an instance Show datatype where ... or is that only for types? what should I be googling (as I haven't found much on stack overflow)
20:08:09 <rwbarton> defined in two different where clauses
20:08:09 <startling> rwbarton, I don't. ;)
20:08:14 <startling> oh, hmm
20:08:48 <rwbarton> anyways I am not that much of an expert on this stuff, sorry
20:09:00 <rwbarton> on a related note, though, I came up with an actual use for @pl today
20:09:07 <shachaf> Is there a way to compile an entire module with NOINLINE on everything?
20:09:36 <zzo38> elliott: ?
20:10:36 <shachaf> What's a CodensityAsk?
20:11:00 <elliott> zzo38: the ask thing
20:11:29 <zzo38> shachaf: It is: newtype CodensityAsk f x = CodensityAsk { runCodensityAsk :: forall z. f z -> (x -> z) -> z };   Do you understand the examples now?
20:11:38 <shachaf> What examples?
20:11:42 <rwbarton> in cloud haskell you can "send" a value defined at top-level (by sending its name), and you can also send the application of one such thing to another such thing
20:11:47 <zzo38> The yesterday examples.
20:12:47 <rwbarton> so if you have some complicated function you want to send, even if the other side doesn't have that function already, as long as it has the basic stuff that @pl builds functions out of, you can @pl your function and send it that way
20:14:09 <shachaf> zzo38: What were those?
20:15:06 <zzo38> shachaf:   CodensityAsk Initialize = Finalize; CodensityAsk Finalize = Identity; CodensityAsk Identity = Maybe;   and so on.
20:15:29 <shachaf> What's Initialize and Finalize?
20:15:36 <cornihilio> I want to display a certain datatype in a specific format when I use show; should I be looking into creating an instance Show datatype where ... or is that only for types? what terms should I be googling (as I haven't found much on stack overflow)?
20:15:38 <shachaf> I guess data Finalize a = Finalize
20:15:47 <zzo38> shachaf: Yes.
20:16:10 <shachaf> data Initialize a = ?
20:16:17 <zzo38> data Initialize a;
20:16:32 <zzo38> It is a comonad.
20:16:37 <shachaf> Ah, right.
20:16:55 <shachaf> What's the "so on"?
20:17:05 <rwbarton> cornihilio, sure
20:17:14 <elliott> rwbarton: Is that actually true?
20:17:24 <rwbarton> elliott, is what?
20:17:25 <zzo38> A few others are:   CodensityAsk (Const x) = (->) x; CodensityAsk ((->) x) = Either x;
20:17:28 <elliott> rwbarton: Oh, I misread.
20:17:38 <elliott> rwbarton: I thought you said Cloud Haskell could natively decompose these functions into other functions.
20:17:47 <rwbarton> that's what @pl is for!
20:17:49 <elliott> So you could send (\x y z -> (x, y + z)) or whatever and it'd automatically @pl it.
20:17:57 <elliott> finally lambdabot is useful for cloud computing
20:18:06 <rwbarton> you could write TH to do the @pl for you
20:18:23 <zzo38> Wouldn't you take the lambdabot @pl code and include it in your program, then?
20:18:41 <bgamari> mm_freak, If I have a record, how can I force its contents short of seq'ing on every field
20:18:44 <bgamari> or using deepseq
20:18:48 <rwbarton> there may be a catch involving polymorphic functions
20:18:51 <bgamari> which some people apparently have an aversion to
20:18:56 <shachaf> bgamari: Don't use deepseq. :-(
20:18:57 <elliott> bgamari: seqing on every field or using deepseq
20:19:04 <elliott> except the latter does a different thing
20:19:26 <rwbarton> cornihilio, I'm not sure what you think the difference between "a datatype" and "a type" is, though?
20:19:29 <shachaf> Forcing one field of a record isn't very related to forcing another field.
20:19:33 <zzo38> shachaf: Are these examples OK?
20:19:34 <rwbarton> cornihilio: if I write data Foo = ... then Foo is a type
20:19:52 <shachaf> zzo38: Yep. Funny type.
20:19:52 <bgamari> shachaf, Right, but I have a fairly large record
20:20:03 <elliott> you can use generic programming
20:20:07 <shachaf> bgamari: You just want to strictify it in this one place?
20:20:16 <shachaf> s/strictify/force/
20:20:18 <elliott> like scrap your boilerplate's generics or uniplate or
20:20:20 <bgamari> shachaf, there could be a few places
20:20:22 <elliott> or template haskell or
20:20:34 <bgamari> elliott, to generate a force function?
20:20:54 <bgamari> shachaf, Why not deepseq?
20:20:58 <shachaf> zzo38: Why do you call it CodensityAsk?
20:21:02 <zzo38> I don't know if the mathematicians use these Initialize and Finalize functors with different names, but this is what I called them.
20:21:09 <zzo38> shachaf: I don't remember exactly why.
20:21:17 <shachaf> bgamari: Well, that'll deepseq all the values too.
20:21:31 <bgamari> shachaf, Sure, but is that inherently bad?
20:21:47 <zzo38> shachaf: Actually the reason is because I don't know what else to call it.
20:21:50 <shachaf> bgamari: Well, it's a different thing from what you ask for.
20:21:53 <shachaf> It's rarely what you want.
20:22:09 <bgamari> shachaf, alright, I'll take your word on that
20:22:45 <doomlord> can haskell introspect function arguments after binding
20:22:47 <shachaf> bgamari: I'd say more, but I don't know what it is that you want. :-)
20:23:13 <rwbarton> how about using a record with strict fields?
20:23:30 <shachaf> That's why I asked if it was being done everywhere.
20:23:35 <rwbarton> aha
20:24:01 <bgamari> shachaf, elliott , I'm just a bit confused since thinking back on other people's Haskell code I've seen, I rarely see people defining forceMyDatatype functions
20:24:16 <bgamari> rwbarton, shachaf, well, technically I could use strict fields
20:24:17 <elliott> yes, it sounds like a bad thing to write
20:24:19 <elliott> i wouldn't write it
20:24:30 <bgamari> and suggested it earlier, but was discouraged
20:24:36 <bgamari> from doing so
20:24:39 <bgamari> shachaf, https://github.com/bgamari/bayes-stack/blob/stable/network-topic-models/BayesStack/Models/Topic/CitationInfluence.hs#L403
20:24:44 <shachaf> bgamari: Well, <shachaf> Forcing one field of a record isn't very related to forcing another field.
20:25:01 <shachaf> I'm not sure how much sense it makes to just say "force all the fields".
20:25:22 <bgamari> shachaf, That expression is giving me stack overflows
20:25:37 <bgamari> shachaf, since setCitingUU is recursively evaluated
20:25:55 <adnauseam> doomlord: noob answer here but, i think you mean type checking, and that happens before. if a function gets bound, it becomes a new type, and the next type you feed it needs to be compatible. if a function is fed proper types but pruposely used in the wrong context, that's a failure of semantics.
20:25:59 <bgamari> shachaf, As you can see, setCitingUU touches pretty much every field of the recrod
20:26:31 <doomlord> what i really mean is to extract curried arguments :)
20:26:42 <bgamari> shachaf, Which is quite a number of fields, hence my reluctance to seq on all of them
20:26:58 <adnauseam> a function that could take functions could do that
20:27:02 <rwbarton> doomlord: you mean if I hand you a function g and secretly I had defined g as f 3 can you extract the 3?
20:27:16 <shachaf> bgamari: You could maybe change some of those $s to $!s...
20:27:32 <bgamari> shachaf, That's been done, but not in the repository
20:27:42 <bgamari> shachaf, It doesn't help since the fields aren't evaluated
20:27:47 <adnauseam> something along the lines of f :: (a->b) -> a
20:28:00 <elliott> that type is uninhabited
20:28:03 <doomlord> yes
20:28:09 <rwbarton> you can't do that
20:28:18 <shachaf> Oh, er, yes.
20:28:24 <doomlord> ok didn't think so
20:28:32 <adnauseam> monads should be suitable for this
20:29:03 <shachaf> You can write (a -> b) -> (a -> b), though.
20:29:17 <elliott> this has nothing to do with monads as far as i can tell
20:29:19 <rwbarton> basically the only thing you can do with a function is apply it to something
20:29:26 <rwbarton> you can't take them apart ever
20:29:38 <latro`a> I find really really polymorphic function types are easier to think about as propositions than as actual functions
20:29:49 <adnauseam> elliott: wouldn't Just x justify as a function that could have X be extracted from it ?
20:29:56 <bgamari> shachaf, Do you think this is an appropriate case to just strictify the fields themselves?
20:30:32 <shachaf> bgamari: Is there ever a case where you don't want them strict?
20:30:32 <bgamari> I guess it's probably better than deepseq
20:30:33 <elliott> adnauseam: Just x isn't a function
20:30:39 <latro`a> for example, (a->b)->a is not inhabited because you could have ~a, whereas (a->b)->(a->b) is inhabited because a->a is inhabited because a actually does imply a
20:30:41 <elliott> it's not even a type
20:30:46 <adnauseam> well it's context - but i was just wodering if
20:30:50 <elliott> and you can extract an x from the value Just x but you can't an x from Maybe x
20:30:56 <elliott> I have no idea what you are saying really
20:31:01 <adnauseam> true
20:31:04 <bgamari> shachaf, Not that I can think of off the top of my head, but then again I'm not really yet in the habit of considering this sort of thing
20:31:09 <latro`a> on the other hand fromJust is definable and has that type
20:31:10 <latro`a> it's just partial
20:31:12 <bgamari> automatically
20:31:14 <zzo38> latro`a: Yes, that is one way, although it is intuitionistic logic so you cannot use classical logic except with continuations.
20:31:18 <adnauseam> elliott: just reffering to the monadic context in general
20:31:21 <latro`a> yeah, I know
20:31:28 <doomlord> whats the haskell type for a homogeneous non-resizing immutable array/vector
20:31:42 <latro`a> but intuitionistic logic isn't really all THAT weak
20:31:45 <elliott> doomlord: define homogeneous
20:31:50 <elliott> wait never mind
20:31:52 <latro`a> eh, "weak" in the sense of proving few theorems
20:31:52 <elliott> doomlord: http://hackage.haskell.org/package/vector
20:31:54 <doomlord> all elements the same type
20:31:57 <elliott> i mixed up homogeneous and heterogeneous
20:32:00 <rwbarton> or Array
20:32:04 <elliott> there is also http://hackage.haskell.org/package/array but it is not as good
20:32:13 <elliott> or more precisely it is better in a few ways but worse in all the other ways
20:32:23 <elliott> but it does come "by default" with most GHC installations whereas vector does not
20:32:28 <elliott> however so much stuff depends on vector that it's no harm to use it
20:32:44 <rwbarton> I find the cost model of vector almost impossible to understand
20:32:45 <latro`a> incidentally, how would you go about doing something like, say, proving that id is the unique representative of a->a
20:33:04 <elliott> rwbarton: that's what most people say about haskell :)
20:33:23 <elliott> I agree it is not ideal but OTOH I find the APi of array almost impossible to understand
20:33:27 <elliott> so it balances out
20:33:28 <zzo38> latro`a: Obviously it is but I don't know how to make a proper proof of such things really.
20:33:29 <elliott> latro`a: like this
20:33:30 <elliott> @free a -> a
20:33:31 <lambdabot> Extra stuff at end of line
20:33:33 <elliott> what!
20:33:35 <elliott> @free id :: a -> a
20:33:35 <lambdabot> f . id = id . f
20:33:46 <elliott> (it follows from parametricity)
20:33:48 <doomlord> did i hear right that there's template-haskell solutions to the record system limitations ?
20:33:50 <latro`a> I know
20:33:56 <latro`a> I just don't really know how to do parametricity proofs
20:34:13 <elliott> might want to read "Theorems for free!"?
20:34:15 <elliott> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.9875
20:34:21 <latro`a> yeah I've read it, it's been a while
20:34:23 <rwbarton> well if you believe the "id :: forall a. a -> a implies f . id = id . f" it is pretty easy
20:34:23 <latro`a> will have to go back to it
20:34:54 <latro`a> I believe that that's true, but don't believe in it as an "atomic" step
20:34:55 <latro`a> if that makes sense
20:35:08 <rwbarton> no it's certainly not atomic
20:36:02 <mapreduce> Is theorems for free available for free?
20:36:10 <zzo38> I did once realize that the monad laws imply the left zero law for MonadPlus, and made a proof using parametricity, although I did not know it is called parametricity and I did not manage to really make a complete proper proof unfortunately. Neverthess it is true.
20:36:36 <mapreduce> nm, yes, http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
20:36:55 <elliott> theorems for free for free
20:37:20 <mapreduce>     pun indented
20:40:43 <zzo38> Well, you can emulate classical logic in intuitionistic logic.
20:41:20 <latro`a> er
20:41:21 <latro`a> what
20:41:33 <latro`a> it's strictly weaker
20:41:35 <shachaf> Is there a nice way of doing the reverse?
20:41:37 <latro`a> how would that make sense
20:41:40 <shachaf> latro`a: Which is why you can embed it.
20:41:43 <zzo38> By Kleisli categories!
20:41:53 <shachaf> latro`a: (By using ¬
20:41:56 <latro`a> that's a subcategory though
20:41:57 <shachaf> ¬a instead of a)
20:42:54 <zzo38> For example in Haskell we have (->) for intuitionistic logic and (Kleisli (Cont r)) for classical logic.
20:43:02 <zzo38> That is what I meant.
20:43:26 <zzo38> gg7: I believe you.
20:43:35 <zzo38> (I know gg7 is quit)
20:44:13 <elliott> latro`a: yes, you can embed classical logic in intuitionistic logic
20:44:21 <elliott> see for instance http://en.wikipedia.org/wiki/Double-negation_translation
20:44:31 <zzo38> That is actually what I meant.
20:44:49 <elliott> i don't know what you mean by "that's a subcategory".
20:44:52 <zzo38> I did not see that Wikipedia article but I guess it is the same as Haskell's Cont type.
20:54:14 <jfischoff> preflex tibbe
20:54:20 <jfischoff> hmm
20:54:32 <rwbarton> preflex: seen tibbe
20:54:32 <preflex>  tibbe was last seen on #ghc 12 hours, 17 minutes and 31 seconds ago, saying: ezyang: but it would be awesome, do it!
20:54:41 <jfischoff> ah
20:55:13 <zzo38> I suppose you could even have multiple incompatible classical logics, like (Cont r) and (Cont r') and (Cont r'') or something like that, maybe
20:55:36 <jfischoff> @tell tibbe thought you would like this answer http://codereview.stackexchange.com/a/16385/2460
20:55:37 <lambdabot> Consider it noted.
20:59:49 <zzo38> The way I actually defined Initialize and Finalize was not by the datatype declarations in Haskell, but rather by, Initialize is endofunctor mapping all objects to initial object (and is also a comonad; there is only one possibility and it always is), Finalize is endofunctor mapping all objects to final object (and is also a monad; like above, there is only one possibility and it always is).
21:00:10 <zzo38> This is why I wanted to ask, if it is ever used by mathematics?
21:01:18 <rwbarton> sure, they are just the initial/final objects in a category of functors
21:01:45 <zzo38> OK
21:04:20 <zzo38> But in which specific cases to these used specifically (including as monad/comonads)?
21:20:19 * hackagebot punycode 0.5.1 - Encode unicode strings to ascii forms according to RFC 3492  http://hackage.haskell.org/package/punycode-0.5.1 (MylesMaxfield)
21:21:49 <ivanm> I've specified an explicit SCC pragma at the top of a function, which looks like "foo bar baz = {-# SCC "foo" #-} (a,b,c) where ..."; however, it seems that the SCC pragma doesn't seem to like that stuff is defined in where
21:22:22 <ivanm> as another function which has its own SCC pragma that's called by foo is specified at the same level as foo in the profiling report :s
21:23:38 <c_wraith> that SCC is really only going to apply to the tuple creation
21:26:58 <ivanm> SCC pragmas and where clauses don't seem to mix :s
21:40:25 * hackagebot gtk-mac-integration 0.2.0.0 - Bindings for the Gtk/OS X integration library.  http://hackage.haskell.org/package/gtk-mac-integration-0.2.0.0 (HamishMackenzie)
22:04:45 <shachaf> bos: Are you coming to edwardk's talk next week?
22:07:43 <djahandarie> What talk is that?
22:07:58 <shachaf> Lenses and traversals and that sort of thing.
22:08:13 <KirinDave> Is there a haskell library for amazon dynamodb?
22:08:17 <djahandarie> Boston Haskell?
22:08:21 <KirinDave> I am having trouble finding one.
22:08:23 <shachaf> djahandarie: Bay area Haskell!
22:08:24 <ion> shachaf: I hope someome records that on video.
22:08:35 <djahandarie> Oh, he's in Cali huh
22:08:40 <shachaf> He will be next week.
22:08:45 <shachaf> You should too!
22:08:49 <djahandarie> Your question suddenly makes more sense now
22:09:31 <djahandarie> Once you fund my ticket and bribe all the teachers of the classes I miss
22:14:00 <KirinDave> Oh helloooo
22:14:08 <KirinDave> Aristidb is the one who made this library for Aws stuff.
22:16:04 <KirinDave> import           Data.Conduit (($$+-))
22:16:12 <KirinDave> Who thinks these operators are okay? :\
22:16:25 <KirinDave> After about the fifth random character it seems like just using backticks might be a win for clarity.
22:16:46 <shachaf> KirinDave: http://hpaste.org/74134
22:17:18 <KirinDave> shachaf: ?
22:17:25 <ion> @hoogle (***||****)
22:17:25 <lambdabot> No results found
22:17:36 <shachaf> KirinDave: That's all the operators exportd on Hackage.
22:17:39 <shachaf> At one point, anyway.
22:17:52 <elliott> $$+- is fine
22:17:58 <elliott> if you know what the components mean
22:18:02 <shachaf> $$±
22:18:03 <elliott> just like many phrases
22:18:20 <shachaf> Not to be confused with ∓
22:18:23 <shachaf> Not to be confused with $$∓
22:18:28 <shachaf> There.
22:18:29 <ion> ＄±
22:18:32 <KirinDave> elliott: Isn't that sort of like saying, "It is fine if you have decided that it is fine because you are familiar with it?"
22:18:43 <elliott> actually it is nothing like that
22:18:52 <KirinDave> elliott: Conduits is a good library, but some of these operators are like self-parody of the haskell condition.
22:19:02 <elliott> i don't agree
22:19:10 <KirinDave> elliott: Alright then.
22:19:14 <shachaf> The only good thing about Conduits is its operators.
22:19:22 <elliott> on both accounts really
22:20:00 <KirinDave> elliott: I think conduits is good because ResourceT is part of it and ResourceT helps mitigate a problem a lot of people have to deal with.
22:20:20 <elliott> actually resourcet is a separate package
22:20:20 <KirinDave> elliott: yes, you can use ResourceT in isolation, but there is a pretty good volume of conduits code with that support baked in.
22:20:26 <KirinDave> It wasn't originally
22:20:34 <KirinDave> Or so I recall reading recently?
22:20:41 <elliott> right, it was separated out in one of the early versions
22:21:34 <KirinDave> elliott: Well, in any event I think at some point arguing that these incredibly densely overloaded operator strings is a phrase is sort of missing the complaint.
22:22:13 <KirinDave> There are lots of short, useful arguments in haskell, so we get a sort of phrasebook. People know what things like >=>, >>=, >>, <$>, <*> etc are trying to imply
22:22:20 <elliott> they are infix because they are useful to use infix
22:22:34 <elliott> there is already ($$) so it is better to base the name off ($$) than to invent a prefix name (only to use it infix with backticks) that bears no relation
22:22:34 <KirinDave> But it seems like the conduit operators diverge from that phrasebook.
22:22:40 <elliott> (and dollarDollarContinued or whatever is just silly)
22:23:02 <elliott> yes conduit has to make a new phrasebook so to speak, since it is introducing a new topic that the standard library doesn't deal with, but one that is just as fundamental, i.e. stream processing
22:23:04 <KirinDave> $$ is not what the complaint is.
22:23:21 <shachaf> The complain't there
22:24:09 <mapreduce> dollarPeso
22:24:16 <KirinDave> dollarQueso
22:24:22 <KirinDave> `cheapCheese`
22:24:34 <ion> $$€₨
22:38:13 <mm_freak> sorry for the OT question, but is it "pronouncable" or "pronouncible"?
22:39:46 <AfC> mm_freak: neither. "pronounceable"
22:40:27 * hackagebot yjtools 0.9.17 - some tools for Monad, List, Tuple and so on.  http://hackage.haskell.org/package/yjtools-0.9.17 (YoshikuniJujo)
22:40:56 <mm_freak> AfC: thanks
22:42:45 <mapreduce> mm_freak: but 'pronunciation' not 'pronounciation'.  It's like the language deliberately sets up pedants for a fall.
22:44:36 <mm_freak> yeah
22:46:55 <shachaf> Bah, stupid GHC! You know what the types are! Why won't you just tell me? :-(
22:47:37 <zzing> I am having trouble getting Parsec to work. Can anyone give me some hints on how I can test a function (specified here: http://hpaste.org/76071 )    The type is currently, parseHeading :: (Stream s m Char) => ParsecT s u m ([Char], [Char])    but it doesn't have to be.
22:50:27 * hackagebot yjtools 0.9.18 - some tools for Monad, List, Tuple and so on.  http://hackage.haskell.org/package/yjtools-0.9.18 (YoshikuniJujo)
22:52:34 <Ptival> what do Haskell folks use these days for command-line arguments?
22:52:35 <yitz> mm_freak: http://www.ojohaven.com/fun/spelling.html
22:53:01 <yitz> Ptival: there are many, many options now. all different styles.
22:53:18 <Ptival> yitz: do you know of OCaml's Arg?
22:53:35 <Ptival> I'd like something similar to it I guess...
22:53:49 <KirinDave> Ugh
22:53:49 <yitz> Ptival: sorry no. do some searches on hackage's front page. it's lots of fun!
22:53:53 <Ptival> k
22:53:59 <KirinDave> I really need to cowboy up and sit down and force comonads into my head.
22:54:41 <KirinDave> I increasingly run up against brick walls from this lack of understanding.
22:54:47 <yitz> KirinDave: did you wboy up when you learned monads?
22:55:01 <KirinDave> yitz: Didn't have to, so much
22:55:27 <KirinDave> I did this recently for Free and FreeT, which i think I get the uses and constructor of pretty well now.
22:55:36 <yitz> KirinDave: (that was a cojoke)
22:55:51 <KirinDave> See?
22:55:57 <KirinDave> It happened again!
22:56:51 <Ferdirand> "An incomprehensible guide to the theory and practice of comonadic programming in Haskell" that sounds pleasant
22:57:01 <Ptival> yitz: I see what you did there :)
22:57:22 <Ptival> Ferdirand: the "gentle" introduction to Haskell was a lie
22:57:45 <Ptival> maybe it helps people face difficulties
22:58:25 <yitz> Ptival: haha right. that was the only tutorial available when i first learned haskell. perhaps "irony" is a nicer way of saying it.
23:06:49 <yitz> zzing: parse "" parseHeading "test: data"
23:07:23 <zzing> Couldn't match expected type `Parsec s0 () a0'                with actual type `[Char]'
23:10:32 <yitz> zzing: where?
23:10:48 <zzing> line 9
23:11:03 <zzing> hmm one sec, maybe not
23:11:12 <zzing> its with the "" parameter
23:11:27 <zzing> there we go
23:11:30 <zzing> Just in the wrong order
23:11:35 <zzing> yitz, thank you
23:11:57 <zzing> Is it proper to use it like this in practice as well?
23:13:00 <yitz> sure, if that works. this is the simplest function to run a parser. the others give you more options if you need them.
23:13:53 <zzing> Now I need this thing to work with the Text datatype
23:14:19 <zzing> I haved tried importing Text.Parsec.Text, and changing the types from Char/[Char] to Text, without success
23:14:35 <utzzza> hi guys
23:15:33 <yitz> zzing: Text.Parsec.Text (but that actually does almost nothing, just a saves a few lines of boilerplate. look at its source.)
23:16:00 <yitz> zzing: leave Char as it is, replace [Char] with Text
23:16:25 <yitz> utzzza: hi
23:16:27 <zzing> Couldn't match expected type `Text' with actual type `[Char]'
23:16:34 <zzing> That was on line 17 with 'name'
23:17:26 <yitz> zzing: {-# LANGUAGE OverloadedStrings #-} on the first line of the file. :set -XOverloadedStrings in ghci.
23:17:34 <zzing> have that already
23:18:41 <zzing> many1 letter is definiely many1 letter :: Stream s m Char => ParsecT s u m [Char]    according to ghci
23:18:53 <yitz> zzing: maybe change Char to just t in the Stream constraint?
23:19:12 <zzing> no change
23:19:44 <zzing> This difficulty always encourages me to try to write my own parsing library. Parsec for all its fun always give me this crap.
23:20:43 <zzing> It appears to be [Char] because many1 is many1 :: Stream s m t => ParsecT s u m a -> ParsecT s u m [a]
23:21:58 <yitz> zzing: ah right. that type actually makes sense for many1, for a general parsing library. you'll have to use pack there. or switch to attoparsec, which is specialized for text and very fast.
23:22:24 <zzing> attoparsec is for bytestrings, not Text
23:22:37 <yitz> zzing: no also Text. mostly for Text nowadays.
23:22:46 <zzing> oh… I didn't see that
23:23:08 <zzing> Does it give decent error messages?
23:23:20 <yitz> zzing: felipe ported it to Text as a separate library a while back. then bos incorporated his port maybe a year ago.
23:23:35 <yitz> zzing: ymmv. works fine for me.
23:23:52 <zzing> I will try it out, thank you
23:25:05 <zzing> thank you for mentioning it
23:25:18 <yitz> zzing: np
23:28:17 <shachaf> What's this type? Foo r a = forall z. ((z -> r) -> r) -> (a -> z) -> z
23:32:06 * ivanm wishes there was a way of doing something like :info for C
23:32:15 <ivanm> I knkow there's a data type defined _somewhere_ here, but can't work out where...
23:32:23 <shachaf> ctags
23:36:38 <pharaun> @pl fromListSyncSet xs = IS.fromList $ map (\u -> UniqueStatus (u, Unseen)) xs
23:36:38 <lambdabot> fromListSyncSet = IS.fromList . map (UniqueStatus . flip (,) Unseen)
23:41:05 <osa1> I'm getting this error while running a file on GHCi: "Loading package llvm-base-3.0.1.0 ... can't load .so/.DLL for: /usr/lib/libpthread.so (/lib/libpthread.so.0: wrong ELF class: ELFCLASS32)" I think the problem is it should look at /usr/lib64 instead, how can I fix this ?
23:53:48 <carpi> what do you use for testing your code and building confidence on it?
23:57:19 <osa1> carpi: ghc --make just works. but I somehow can't run it in GHCi
