00:01:47 <johnw> ok
00:06:22 <Jafet> Minimorphism
00:18:06 <shachaf> So the type "Haskell 98 kinds" is just binary tree skeletons.
00:18:17 <maukd> spooky
00:21:53 <liyang> lightquake: are you getting some kind of ambiguous type error?
00:25:07 <lightquake> liyang: yeah
00:25:30 <lightquake> i just specified the type of an expression and it worked
00:36:02 <strebe> Johnw: Awodey is awesome, but it's also very, very dense
00:36:32 <johnw> ah, ok
00:38:06 <FatPhil> @pl \ x y -> map (* x) v
00:38:06 <lambdabot> const . flip map v . (*)
00:42:00 <strebe> johnw: http://scienceblogs.com/goodmath/2006/06/07/a-first-glance-at-category-the/ gives a really quick glance at the start of category theory. You'll find terms from category theory pop up quite often in haskell (monoid, functor, monad, etc), but it's certainly possible to write haskell without really knowing category theory
00:42:11 <johnw> thanks!
00:42:15 <strebe> np :-)
00:43:31 <FatPhil> I might be unusual in this, but I really didn't like Awodey
00:44:16 <strebe> FatPhil: hmm, why? And is there something you like better?
00:45:37 <FatPhil> strebe: All of his explanations tend to be very long-winded and somehow make things less clear than a more concise explanation would have been. This might just be me though, as the book certainly seems popular in general.
00:46:45 <strebe> FatPhil: hmm. I've found the goodmath blog helps me understand awodey and often puts things way more understandably (but it covers way less, and I'm not sure I'd understand it without fighting through the relevant bit of Awodey first)
00:46:51 <FatPhil> strebe: I got on a lot better with Categories for the Working Mathematician, but I imagine this will look very unfriendly to someone without any maths background. Any notes by Tom Leinster are also usually pretty good. I'm sure there's notes for some of his courses available online
00:47:09 <hpaste> eflister pasted “short circuit” at http://hpaste.org/76399
00:47:42 <strebe> and the other book I have on category theory is one I find a bit insufferable, it's a few hundred pages of definitions with examples that hardly gets anywhere (it's very much aimed at people without a math background)
00:48:30 <strebe> FatPhil: hmm. I could take a look at that, but from what I've heard I expect you're right (and I don't have much maths background)
00:48:40 <eflister> cale and maukd: hey, can you guys check out my paste?  i got my newtype to work for a simple case, but deeper in a monad it doesn't short circuit
00:50:14 <FatPhil> strebe: It's the source of ".. monads are just monoids in the category of endofunctors" quote that's been jokingly attributed to Wadler. What's the other book you've read?
00:50:17 * hackagebot zip-conduit 0.2.1 - Working with zip archives via conduits.  http://hackage.haskell.org/package/zip-conduit-0.2.1 (TimCherganov)
00:50:54 <strebe> "Read" is putting it too strongly, but I've spent some time with "Conceptual mathematics: a first introduction to categories"
00:51:19 <strebe> as something to refer back to, or look up examples in, it can be useful, but reading it gets impossible
00:52:03 <FatPhil> Ah, is that by Lawvere?
00:52:06 <strebe> it's pile after pile of definitions and examples
00:52:10 <strebe> yeah
00:52:26 <strebe> and Schanuel
00:52:28 <ClaudiusMaximus> eflister: liftA2 must always run both actions, maybe someone can explain it better than me on minimal sleep..
00:52:35 <strebe> I've wanted to like it, but, well, I can't :/
00:53:28 <FatPhil> Yeah, I can imagine that would be pretty unreadable. The book I mentioned is probably also going to be pretty unreadable if you want to learn categories to understand Haskell better. So, not a very helpful contribution by me! Perhaps Pierce's categories for type theory? I've heard good things about it, but not read it myself
00:54:07 <strebe> I think category theory looks nifty in and of itself frankly, too - being able to understand haskell packages that do monad transformations and so forth would just be a nice side bonus
00:54:38 <FatPhil> Ok, well categories for the working mathematician is a "classioc
00:54:45 <FatPhil> Oops, finger slippped
00:57:25 <ClaudiusMaximus> i was struggling with http://hpaste.org/76392 for quite some hours, got into type error hell (either "the inferred type was ambiguous" or mismatching types scrolling up the terminal for pages)
00:58:12 <startling> @hoogle (<:>)
00:58:12 <lambdabot> No results found
01:00:35 <ClaudiusMaximus> ..and when it finally loaded in ghci and i checked the type, it asserted that both  NaturalNumber p > 0  and  p ~ 2 * p   which is kinda useles as there is no such type that can satisfy those constraints :(
01:04:35 <eflister> ClaudiusMaximus: liftA2 is strict in its arguments?  why?  i think its implementation for [] goes through 'ap', which goes through 'liftM2', and i don't see anything non-strict...
01:07:31 <Nereid> eflister: you have two IO (ShortCircuit a) values (let's call them x and y), so let's look
01:07:37 <ClaudiusMaximus> eflister: as far as i can tell, you're running liftA2 (<|>) in some MonadDB, not []
01:07:47 <Nereid> liftA2 (<|>) x y = do {a <- x; b <- y; return (a <|> b)}
01:08:13 <Nereid> because you're running it in this monad.
01:08:18 <Nereid> not in your ShortCircuit thing.
01:10:26 <Nereid> whereas maybe you were expecting something more like do {a <- x; if null a then y else return a}
01:10:27 <Nereid> ??
01:10:37 <Nereid> (roughly speaking)
01:13:36 <eflister> nereid + claudiusmaximus: ok, yeah -- you can see what i'm trying to do though, right?  it looks to me like i'm applying <|> to lists, it's just that they contain monadic values.  <|> should still be able to see that the first side is not empty...
01:14:13 <Nereid> eflister: yeah, but you're effectively "running" both values before feeding them to <|>
01:14:27 <Nereid> maybe expanding out the liftA2 would help you see that
01:14:34 <Nereid> (which is really a liftM2 here...)
01:15:19 <lightquake> hmm
01:17:10 <eflister> nereid: yeah, what's causing side 2 to run?  i did follow liftA2's implementation to see <*>, which calls 'ap', which calls liftM, which calls return -- at no point do i see why i'd get a strict evaluation of the second side until the first side was seen to be empty
01:18:00 <Nereid> it's not a matter of strictness or not
01:18:25 <Nereid> maybe it's clearer in do notation: liftM2 f x y = do { a <- x; b <- y; return f x y }
01:18:59 <eflister> nereid: i thought that would not evaluate y unless f uses its value
01:19:08 <Nereid> but it does.
01:19:31 <eflister> nereid: isn't f = <|> here?
01:19:33 <Nereid> yes.
01:19:37 <Nereid> and it's not evaluation
01:20:03 <Nereid> do {  a <- getLine; b <- getLine; putStrLn a } :: IO ()
01:20:09 <Nereid> surely this reads two lines, even though it doesn't use the second line?
01:21:02 <eflister> nereid: what's the right term?  i would have thought it would not have read the second line.
01:21:28 <eflister> nereid: why isn't that strict?
01:21:34 <Nereid> it is strict.
01:21:36 <Nereid> er
01:21:46 <Nereid> ?
01:21:54 <ClaudiusMaximus> eflister: http://www.haskell.org/haskellwiki/Typeclassopaedia#Intuition_3 explains the additional power of Monad over Applicative
01:21:54 <eflister> nereid: you said above it's not a matter of strictness?
01:21:55 <Nereid> the issue is not strictness
01:21:57 <Nereid> yeah
01:22:07 <Nereid> it's just how monadic actions are composed
01:22:15 <Nereid> ClaudiusMaximus: the same issue happens with applicative
01:22:26 <lightquake> i have data Entity = Entity Position and  data World = World [Entity], with entities and position lenses
01:22:42 <lightquake> what's the nicest way to go from a world to the list of positions of its entities?
01:22:53 <Nereid> eflister: do { putStrLn "hi"; return 5 } surely prints "hi", even though it doesn't use the result of putStrLn  (which is ()
01:23:04 <eflister> nereid: oh ok, when i think of >> i see it.
01:23:05 <Nereid> else what's the whole point
01:24:40 <Nereid> lightquake: entities . mapOf position, or something?
01:24:47 <eflister> nereid: so how would i adjust my paste to do what i want?  i'm also guessing there is a more idiomatic way to do this, or at least get rid of some of the constructor noise
01:24:48 <Nereid> wait
01:24:59 <Nereid> something along those lines.
01:25:12 <Nereid> eflister: you can't use ShortCircuit as is.
01:25:37 <lightquake> Nereid: mapOf is for modifying, i'm just looking to access
01:25:44 <Nereid> bleh.
01:26:06 <Nereid> wait.
01:27:38 <Nereid> eflister: you'll have to write whatever short-circuiting you do at the monad level.
01:27:39 <ClaudiusMaximus> eflister: http://hackage.haskell.org/package/shortcircuit seems to have implemented a solution of some kind, though i'm not sure i like the boolish naming (found via http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=short%20circuit )
01:28:17 <Nereid> ah yes, that'd do it.
01:28:41 <Nereid> so write a ShortCircuit instance for [a], and use orM.
01:28:59 <Nereid> er, Shortcircuit.
01:31:19 <eflister> nereid: can you explain what you mean by "write at the monad level"?  it seems like it should be possible to have [IO] (or any [a]) and do different things when that is empty/non-empty, without evaluating the contained values.  (you said i shouldn't say 'evaluate' -- why not?)
01:31:57 <Jafet> @hackage unamb
01:31:57 <lambdabot> http://hackage.haskell.org/package/unamb
01:31:58 <shachaf> eflister: Execution isn't the same thing as evaluation.
01:32:04 <shachaf> I don't know what the rest of what you wrote meant.
01:32:20 <eflister> i'll check out shortcircuit but want to understand how to fix my from-scratch example first
01:32:32 <shachaf> [IO] is a kind error.
01:32:40 <shachaf> Do you mean [IO a]?
01:33:03 * shachaf looks for context.
01:33:07 <Nereid> let me drop the newtype noise.
01:33:08 <eflister> yeah, thought that shorthand was clear.  at first i wrote "Monad m => [m a]" but thought it was pedantic
01:33:13 <Nereid> what he has is a pair of IO [a] values
01:33:30 <lightquake> bleh, i'll ask edwardk tomorrow
01:33:32 <shachaf> eflister: IO [a] is very different from [IO a]
01:33:36 <Nereid> and he wrote (<|>) :: [a] -> [a] -> [a] as in http://hpaste.org/76399
01:33:47 <shachaf> lightquake: You should go to his talk in CA tomorrow!
01:34:18 <Nereid> which ignores the second argument if the first is not null
01:34:21 <eflister> yeah i mean to have [IO a], do i really have IO [a]?
01:34:28 <Nereid> he is expecting liftM2 (<|>) :: IO [a] -> IO [a] -> IO [a] to not execute the second action if the first returns null
01:35:29 <Jafet> Maybe IO (IO [a])!
01:35:44 <Nereid> eflister: but what it's doing is executing both actions and then feeding the results to (<|>)
01:35:49 <shachaf> [IO [IO [a]]]
01:35:58 <Nereid> IO doesn't know anything about what (<|>) does.
01:37:35 <Jafet> return . unsafePerformIO
01:37:48 <Nereid> disgusting.
01:37:54 <eflister> i mean to define <|> such that i can check if Monad m => [m a] is empty without executing m
01:38:06 <Nereid> you don't have [m a], you have m [a].
01:38:15 <eflister> i'm having trouble seeing that :)
01:38:41 <eflister> but let's say i can fix that, the general plan of having [m a] should make this work, right?
01:38:46 <Jafet> Well, you only need unsafeInterleaveIO here
01:39:32 <shachaf> unsafeInterleaveIO is more or less return . unsafePerformIO, isn't it?
01:39:45 <shachaf> Assuming that's IO-return.
01:40:02 <quicksilver> eflister: yes, if you had [m a] you could check it was empty without executing the actions.
01:40:07 <Jafet> It can't be less, so I assume it's more
01:40:24 <eflister> why do i want anything unsafe?  i think i'm being messed with :)
01:40:31 <quicksilver> eflister: you are. Ignore Jafet.
01:41:11 <shachaf> It's true that you can check whether [IO a] is empty or not without executing any actions.
01:41:18 <shachaf> But according to Nereid that's not what you have.
01:41:26 <shachaf> I missed the beginning of this conversation, though.
01:41:46 <eflister> :) ok thx -- so now to see why i have IO [a], not [IO a] -- it's in http://hpaste.org/76399
01:41:49 <Nereid> the two arguments to liftA2 (<|>) are monadic values.
01:42:08 <eflister> yep i agree!
01:42:49 <Nereid> let's pretend this is the IO monad, because I don't know what runDB is.
01:42:56 <Nereid> well we already have been pretending.
01:42:57 <Nereid> anyway,
01:43:20 <quicksilver> <$> is pushing the ShortCircuit 'inside' the monad.
01:43:23 <Nereid> so the (do liftIO ... ) thing presumably is a value of type IO [a]
01:43:38 <quicksilver> ShortCircuit <$> (putStrLn "hi")
01:43:52 <quicksilver> would have type IO (ShortCircuit ())
01:44:01 <Nereid> and then applying shortCircuit <$> to that gives you a value of type IO (ShortCircuit a)
01:44:06 <quicksilver> well not quite, because ShortCircuit requires a list.
01:44:18 <Nereid> because that's what <$> does.
01:44:20 <quicksilver> but yes, as nereid just said.
01:44:23 <eflister> m here is actually a transformer of IO, if i have that right, but it doesn't matter
01:44:28 <Nereid> yeah.
01:44:33 <quicksilver> it's the <$> pushing ShortCircuit *inside* the monad
01:44:40 <quicksilver> so you have m(ShortCircuit a)
01:44:45 <quicksilver> not ShortCircuit (m a)
01:45:03 <eflister> i agree i have [m (ShortCircuit a)] <|> [m (ShortCircuit a)], which should be a [m (ShortCircuit a)]
01:45:09 <Nereid> no, no [] there
01:45:23 <Nereid> ShortCircuit :: [a] -> ShortCircuit a
01:45:34 <Nereid> there are no lists around here.
01:46:14 <eflister> ok, yeah, that cleared it up.  i agree i have an (m (ShortCircuit a))
01:46:21 <Nereid> you have two of them
01:46:26 <eflister> yeah
01:46:31 <Nereid> and then liftA2 (<|>) applied to them gives you another m (ShortCircuit a)
01:46:44 <Nereid> which is obtained by running the two actions and returning their <|>
01:46:44 <t7> @hoogle (<|>)
01:46:45 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
01:46:45 <lambdabot> Text.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
01:46:45 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: (ParsecT s u m a) -> (ParsecT s u m a) -> (ParsecT s u m a)
01:46:49 <Nereid> er, the <|> of their results
01:47:19 <t7> > Just 123 <|> Just 321
01:47:20 <lambdabot>   Just 123
01:47:27 <t7> > Just 123 <|> Nothing
01:47:28 <eflister> so what i want is ShortCircuit (m a)
01:47:28 <lambdabot>   Just 123
01:47:37 <Nereid> not really.
01:47:37 <t7> all of my why
01:47:38 <Nereid> well
01:47:59 <merijn> t7: How so? Seems expected behaviour to me
01:48:06 <Nereid> eflister: what you want is some function that takes two actions, runs the first action, looks at its result,
01:48:12 <t7> ignore the second arg? why bother....
01:48:17 <Nereid> and then runs the second action only if the first one returns null.
01:48:31 <merijn> > Nothing <|> Just 3
01:48:33 <lambdabot>   Just 3
01:48:42 <eflister> nereid: yeah
01:48:52 <t7> aha :)
01:48:59 <merijn> t7: To select between alternatives where one may fail
01:49:03 <Nereid> there is no way you can do that by lifting a pure thing like <|>.
01:49:10 <merijn> t7: As opposed to >> which will stop if the first argument fails
01:49:30 <merijn> t7: <|> just picks the first succeeding with left to right prio
01:49:50 <Nereid> eflister: so you could write something like
01:50:01 <eflister> nereid: how can one see that it can't be done by lifting a pure?
01:50:20 <Nereid> uh.
01:50:39 <eflister> nereid: since i have lists of actions, and want to see if one of those lists is empty
01:50:47 <Nereid> ok
01:50:54 <Nereid> I could just say "that's how monads work", but
01:51:04 <eflister> nereid: i don't actually want to run the actions, just know if there are any
01:51:31 <Nereid> ok, so you make a list of actions.
01:51:33 <eflister> actually i find the 'action' and 'computation' words misleading, can i just say monadic value?
01:51:37 <Nereid> sure.
01:51:39 <merijn> I think this code and you are conflating lots of orthoganl issues that make this discussion hard
01:52:04 <eflister> i agree!  i'm writing it exactly to try to unmangle myself.  :)
01:52:33 <merijn> Can't you split into discrete steps what you have and what you want to do? Preferably one logical step at a time
01:52:45 <Nereid> starting with what you have.
01:52:47 <eflister> but the motivation is very compelling, i think -- i was inspired by the shortcircuiting <|> from parsec...
01:53:04 <b__> what would be the fastest way to get all indices with value True for a STUArray s Int Bool?
01:53:06 <merijn> You have lists of actions, some potentially empty and you want to... ?
01:53:25 <eflister> only execute some lists if others are empty
01:53:34 <quicksilver> eflister: there is no doubt that what you are doing is reasonable.
01:53:48 <quicksilver> I've often defined a combinator called something like "orElse" for things like you want.
01:53:50 <Nereid> eflister: ok, so apply <|> directly to the lists of actions.
01:54:04 <eflister> <|> on lists does not short circuit!
01:54:08 <eflister> that's why i needed the newtype
01:54:16 <Nereid> ok, through the newtype.
01:54:17 <quicksilver> you're just getting tangled in <$>s and liftA2s
01:54:34 <merijn> eflister: It does, when you don't mess around with the fmaps and lifts
01:54:54 <eflister> <|> on list is ++
01:54:55 <merijn> eflister: Seems to my you start lifting and fmapping things way before you should, which is why everything becomes so complicated
01:55:18 <quicksilver> merijn: no, it doesn't.
01:55:29 <quicksilver> > [1,2,3] <|> [4,5,6]
01:55:30 <lambdabot>   [1,2,3,4,5,6]
01:55:44 <quicksilver> ^^ this is reasonable but it's not what eflister is after here.
01:55:45 <Nereid> eflister: but right now you have a m (ShortCircuit a), and you're looking more for ShortCircuit (m a), no?
01:55:46 <merijn> quicksilver: I didn't mean on lists, I meant on his ShortCircuit type
01:55:50 <quicksilver> ah.
01:55:54 <merijn> quicksilver: Unlucky timing
01:55:56 <quicksilver> merijn: but that's not what he meant :)
01:56:19 <eflister> so the issue comes down to my liftA2 -- which i only added to make it compile.  :)
01:56:27 <Nereid> without thinking about what it does.
01:56:49 <eflister> i tried <|>'ing the (lists of) monadic values themselves, but that didn't compile.
01:56:57 <merijn> eflister: Can you simplifiy the code inside the liftA2 (<|>) to separate small actions annotated with their types?
01:57:00 <Nereid> probably because you never had a list of monadic values to begin with.
01:57:16 <merijn> eflister: Because personally I can't parse this code as is without investing more effort than it is worth
01:58:07 <eflister> i'll try, but the values are in some transformed monads that i'm not familiar with
01:58:07 <Nereid> eflister: what's the type of (selectList [PersonName ==. "Michael"] [])
01:58:26 <merijn> eflister: It is hard to see what the operators are doing without knowing the types of things
01:58:40 <eflister> brb, i'll get that example
01:59:01 <Nereid> my guess is that it's something that looks like m [a]?
01:59:46 <t7> > [1..3] >> [4..6]
01:59:47 <lambdabot>   [4,5,6,4,5,6,4,5,6]
02:00:18 <Nereid> > [1..3] `mplus` [4..6]
02:00:19 <lambdabot>   [1,2,3,4,5,6]
02:00:19 <sopvop> is there  standard function like `maybe` or `either` but for `if`? Like `if_ onTrue onFalse $ a > b`?
02:00:28 <merijn> sopvop: Nope
02:00:37 <t7> Are applicative Functors a maths thing?
02:00:37 <Nereid> sopvop: nope, and I keep saying how there should be.
02:00:40 <Nereid> and it should be called bool.
02:00:57 <merijn> Nereid: Have you submitted the suggestion to libraries@ ?
02:00:58 <Nereid> t7: on the math side they're called strong lax monoidal functors or something.
02:01:07 <Nereid> merijn: I haven't submitted anything.
02:01:34 <merijn> Might be time to start? ;)
02:02:02 <Nereid> I also am not subscribed to any mailing lists.
02:02:08 <Nereid> might be the time to start that too.
02:02:10 <eflister> nereid, et al: ok, maybe it's: (backend0 m0 [Entity (PersonGeneric backend0)])  ?  ha ha...
02:02:28 <Nereid> eflister: eh?
02:03:16 <eflister> the return type of selectList -- this is why i have been kind of ignoring the types  :)
02:03:33 <Nereid> sounds like that would get you into trouble.
02:04:22 <bartavelle> anybody remotely knowledgeable about persistent ?
02:04:48 <bartavelle> I did a selectList, extract a result, and do another selectList with that result
02:04:56 <zenzike> ~
02:05:15 <bartavelle> problem is the second one is in sql something like "WHERE parentid=12", except I don't know how to express it with persistent
02:05:31 <bartavelle> I get an "id" from things like "insert", don't know how to get them from a selectList
02:05:37 <eflister> bartavelle -- ha ha, we are talking about selectList right now
02:05:56 <bartavelle> oh yes !
02:05:59 <bartavelle> I can see that :)
02:06:37 <Nereid> eflister: ok, well backend0 m0 is our monad
02:06:39 <malorie> i am looking for something like a edsl for sequencing events. think music and the like. any ideas where i might find such a thing?
02:06:42 <Nereid> let's just call it m
02:06:55 <Nereid> and let's call the Entity ... junk a
02:06:57 <Nereid> so you have a m [a]
02:07:17 <sopvop> Also tail 'case' would be nice like  caseof Foo ->...; Bar -> ...; $FooBar
02:07:37 <Nereid> ugh, hard to distinguish the word a from the type variable a.
02:07:55 <sopvop> `\x -> case x of ` is 7 extra characters :(
02:08:30 <Nereid> oh no, 7 characters!
02:08:51 <eflister> malorie: http://hackage.haskell.org/package/control-event
02:09:19 <sopvop> Yeah, point free encryption coding style is againts 7 characters (and brackets)
02:10:49 <malorie> eflister: thanks. this should get me going
02:11:16 <eflister> bartavelle: you had to use entityVal to get the value out of selectList's results right?
02:11:31 <eflister> bartavelle: there's another one (entityID or similar) to get the id
02:12:25 <fmap> lightquake: `world ^. entities ^.. traverse . position' should work
02:13:09 <statusfailed> Is there a more obvious way to write this? (,,) <$> Just 10 <*> Just 20 <*> Just 30
02:13:23 <statusfailed> where those "Just" values are not known at compile time
02:13:52 <statusfailed> oh, liftA3
02:14:11 <eflister> malorie: i have a realtime livecoder for midi that doesn't use control-event, but has its own timing: http://code.google.com/p/h1ccup/source/browse/trunk/theory/haskell/src/LiveCode.hs
02:14:57 * Nereid looks at what ^.. is
02:15:38 <Nereid> ah yeah.
02:15:40 * fmap doesn't actually knows
02:15:50 <fmap> s/knows/know
02:16:35 <Nereid> lol
02:17:15 <bartavelle> eflister, yes I managed to figure what should be done by reading the docs ;)
02:20:39 <Nereid> ok so ^.. is not it.
02:21:33 <fmap> is not what?
02:22:07 <Nereid> what we want.
02:23:07 <frontendloader> Any of you familiar with the subset sum problem? I'm trying to think of an attack angle for a variant where you can reuse any element in the set.
02:23:49 <fmap> well, we want to apply `position' lens on list of Entity; `^.. traverse . position' should do it?
02:24:27 <Nereid> oh I misread one of the operators earlier.
02:24:35 <laker> hello, anyone knows how to convert the following LR rule to LL ? expr: expr '.' expr '<-' expr
02:26:08 <Nereid> ok yeah that does it.
02:28:51 <Nereid> but I feel like we shouldn't need the power of Traversable here.
02:30:00 <eflister> nereid: ok, yeah, definitely m [a].  so i should be able to use ShortCircuit's <|> to do what i want somehow, right?  you said you could see that <|> couldn't be lifted past that m without executing it?  shouldn't traversable's sequenceA help?
02:30:19 * hackagebot DSH 0.8.2.0 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.8.2.0 (GeorgeGiorgidze)
02:30:20 <eflister> speaking of... :)
02:30:23 <Nereid> eflister: no
02:31:54 <eflister> cuz it evaluates and collects, huh...
02:31:59 <Nereid> sequence would only give you [m a] -> m [a]
02:32:19 <statusfailed> @src liftA3
02:32:19 <lambdabot> Source not found. Take a stress pill and think things over.
02:32:24 <statusfailed> booo!
02:32:27 <Nereid> and you are wanting to shortcircuit some [m a] values.
02:32:32 <Nereid> which you can't.
02:33:29 <eflister> doesn't it flip any inner applicative (like [] in my case)?  m [a] -> [m a]
02:33:40 <Nereid> only if m is traversable
02:33:43 <Nereid> (it isn't)
02:34:06 <quicksilver> eflister: it's fundaementally impossible to go from IO [a] to [IO a] in the sense you want.
02:34:14 <eflister> ah right just saw the traversable constraint.  you know it isn't because any transformer of IO can't be?
02:34:29 <quicksilver> "IO [a]" means "an execution which you execute completely and then it returns a list"
02:34:47 <quicksilver> there is no way to "split" that into a bunch of little actions each of which yields a single element
02:34:53 <quicksilver> (which is what [IO a] means)
02:37:29 <eflister> well i don't need to actually split any -- i have an m [a] and just want to know if it's empty, and if so, execute some other m [a]
02:37:43 <eflister> (so both are executed in entirety)
02:37:47 <eflister> (if at all)
02:38:06 <Nereid> yes
02:38:14 <Nereid> but you can't do that with some pure [a] -> [a] -> [a]
02:38:33 <eflister> ah, hmm.  that makes some sense.
02:38:58 <Nereid> ok, some intuition here:
02:39:10 <Nereid> say you had your f :: [a] -> [a] -> [a]
02:39:27 <Nereid> well liftA2 f would give you a m [a] -> m [a] -> m [a], but
02:39:39 <Nereid> liftA2 is a thing that works on applicatives.
02:39:55 <Nereid> and one of the big differences between applicatives and monads is:
02:40:12 <quicksilver> erm, no.
02:40:23 <Nereid> no what?
02:40:35 <quicksilver> hmm
02:40:42 <Nereid> anyway...
02:40:48 <quicksilver> what eflister wants now seems, to me, different from what he wanted at first
02:40:56 <quicksilver> but persuably I misunderstood :)
02:40:59 <Nereid> it's that applicatives can't use results of previous computations to decide what to execute next.
02:41:07 <Nereid> but monads can.
02:41:25 * quicksilver nods
02:41:35 <Nereid> so nothing that works on applicatives in general could possibly give you the m [a] -> m [a] -> m [a] you want
02:42:52 <eflister> i guess i feel like i'm deciding which applicatives to run, not expecting them to do it.  in any case, why wouldn't liftM2 then use the extra monadic power required?
02:43:00 <Nereid> because liftM2 = liftA2
02:43:09 <quicksilver> just because that isn't what liftM2 does.
02:43:15 <quicksilver> there's nothing wrong with what you want
02:43:15 <eflister> but some lifting of <|> should then work, right?
02:43:22 <quicksilver> it just happens that liftM2 isn't it.
02:43:27 <quicksilver> liftM2 always runs both actions.
02:43:45 <quicksilver> there isn't a general purpose lift which only runs the second action if needed.
02:43:59 <eflister> i should be able to write one, yes?
02:44:08 <quicksilver> it's not clear how you'd make it "general"
02:44:14 <Nereid> you can write one that specifically works at the level of m [a]
02:44:19 <quicksilver> because it's not clear what the general definition of "if needed" is.
02:44:27 <quicksilver> you can certainly write the specific thing you want here.
02:44:34 <eflister> well i just want it to be non-strict.  :)
02:44:41 <quicksilver> no, you don't.
02:44:46 <quicksilver> this has nothing at all to do with strictness.
02:45:00 <quicksilver> execution (or not) of a monadic action is completely unrelated to strictness.
02:45:28 <eflister> i hear you and remember the >> intuition we discussed above...
02:45:46 <Nereid> (and (>>) = (*>) is an applicative thing)
02:46:08 <eflister> but some intuition i'm having says that since there's a way to have a monadic value without executing it...
02:46:31 <eflister> then it's 'non strict' to not execute it until someone demands its result
02:46:46 <Nereid> strictness has nothing to do with execution
02:47:56 <eflister> i hear you, i'm trying to say that i feel like there is a homologous concept for execution -- having an unexecuted monadic value
02:48:10 <quicksilver> it is, in a sense, homologous
02:48:13 <quicksilver> but it's different
02:48:27 <quicksilver> and conflating the two leads to confusion
02:48:49 <quicksilver> (the haskell report makes this mistake when it describes getContents as 'lazy IO' so you're in good(?) company)
02:49:40 <Nereid> but the "laziness" is magical and you have to talk about stuff like unsafeInterleaveIO to make sense of it.
02:51:00 <eflister> ok, let's call it something else -- "execute on demand" or something -- but that's all i need here, right?  lifting into a monad m without forcing execution?
02:51:43 <Nereid> that's what unsafeInterleaveIO does.
02:51:44 <Nereid> and it's unsafe.
02:51:51 <Nereid> er
02:51:55 <eflister> and my intuition that i could lift a pure <|> works for any traversable, which means no transformers of IO, right?
02:51:56 <Nereid> the excuting on demand part, that is.
02:52:32 <eflister> i don't get why it's not the same as having [IO a], and only executing some of them?
02:52:38 <Nereid> eflister: I wouldn't call that lifting.
02:52:44 <Nereid> about the <|>
02:52:51 <Nereid> eflister: but you don't have a [IO a]
02:52:52 <eflister> why does safety come into it?
02:52:57 <Nereid> you only have IO [a]
02:53:16 <Nereid> and to be able to look at any of that list, you have to execute the entire IO action to get it.
02:53:22 <Nereid> (unless you use unsafeInterleaveIO or so)
02:53:24 <eflister> yeah, not talking about what i have, but in general, having unexecuted monadic values laying around
02:53:31 <Nereid> if you had a list of them, sure.
02:53:34 <Nereid> but you don't.
02:53:52 <quicksilver> if you had [IO a] then your ShortCircuit would have done the right thing.
02:54:08 <quicksilver> <|> on "ShortCircuit (IO a)" would have been what you wanted
02:54:18 <eflister> i have two lists, and i do want to execute them in their entirety if at all -- i never need to get inside them
02:54:42 <Nereid> you don't have lists of actions
02:54:44 <Nereid> you have actions which return lists
02:55:20 <Nereid> and, as I understand it,
02:55:32 <Nereid> you want to execute the first action, and use its result to determine whether to execute the second.
02:56:10 <eflister> yeah, but hopefully at some level of abstraction :)
02:56:34 <Nereid> sure, but let's start concretely, and then see how far we can abstract.
02:56:59 <eflister> ok, that's easy.  it's just 'when' or something, right?
02:57:23 <Nereid> well, when only works for actions with trivial return type.
02:57:26 <Nereid> i.e. m ()
02:58:04 <eflister> x <|> y = when (null <$> x) y
02:58:26 <Nereid> not quite, the first argument of when is a pure Bool value.
02:58:29 <Nereid> so you could say
02:58:52 <Nereid> x <|> y = do { c <- x; when (not (null c)) y }
02:58:59 <Nereid> for x :: m [a] and y :: m ()
02:59:45 <Nereid> but
02:59:59 <Nereid> when b m = if b then m else return ()
03:00:26 <Nereid> now, and I think this is what you want but I'm not sure, is:
03:00:33 <Nereid> we have x :: m [a] and y :: m [a]
03:00:47 <Nereid> we run x. if it's nonempty, return its result, but if it's empty, run y and return the result of y.
03:01:14 <Nereid> in code: do { r <- x; if (null r) then y else return r }
03:01:26 <Nereid> or
03:01:38 <Nereid> do { r <- x; if (not (null r)) then return r else y }
03:01:48 <Nereid> which has type m [a]
03:02:39 <eflister> yeah i guess i forgot the returns -- why was when written only for m ()?
03:03:02 <Nereid> well, they could have written when_ :: Bool -> m a -> m ()
03:03:32 <Nereid> but whatever it is, the return type can't have a, because if the condition is false then we have no a to return.
03:03:57 <eflister> ah right
03:04:56 <quicksilver> I have often defined
03:05:08 <quicksilver> orElse :: m (Maybe a) -> m (Maybe a) -> m (Maybe a)
03:05:19 <quicksilver> which is, pretty much, the same thing as eflister wanted (I think)
03:05:23 <quicksilver> it's a generally useful notion.
03:05:23 <Nereid> yes
03:05:31 <Nereid> and that is orM from shortcircuit
03:05:35 <quicksilver> morally it lives in the 'MaybeT m' monad
03:05:37 <Nereid> (using the Shortcircuit instance for Maybe a)
03:05:47 <quicksilver> but it's not normally worth doing the transformer
03:06:27 <quicksilver> I think it's mplus for the MonadPlus instance of MaybeT
03:06:34 <quicksilver> but I can't remember if that's actually defined.
03:07:07 <quicksilver> "The instance MonadPlus is not provided, because it has ambiguous semantics"
03:07:11 <quicksilver> I guess not :)
03:07:52 <eflister> yeah, i wanted exactly that, but for lists.  <|> already short circuits for Maybe.  but i guess that can't be lifted for the same reasons?
03:08:21 <Nereid> eflister: right.
03:09:23 <Nereid> so instead of writing a pure <|> and lifting it, you have to write a monadic thing.
03:09:44 <Nereid> anyway,
03:10:17 <Nereid> that shortcircuit package abstracts this as far as I can see it going.
03:10:40 <Nereid> because if you write a Shortcircuit instance for [a] where isTrue = not . null,
03:10:50 <Nereid> then orM :: m [a] -> m [a] -> m [a] does exactly what you want it to.
03:12:06 <Nereid> ah, and (??) generalizes my proposed bool :: a -> a -> Bool -> a
03:12:34 <eflister> all right i'll just use that.  but i can't shake the feeling that the "lifting without forcing execution" makes sense, since i am not trying to break up the m [a].
03:12:35 <Nereid> ((??) specializes to it)
03:12:51 <Nereid> eflister: you're not breaking it up.
03:13:30 <eflister> i agree do { r <- x; if (null r) then y else return r } doesn't break it up, it's just so literal -- i mean i should be able to "lift without forcing execution" because i don't need to break it up.
03:14:40 <quicksilver> lift *what* without forcing execution?
03:14:42 <Nereid> fmap: I guess maybe we do need traverse to get an honest lens.
03:14:48 <quicksilver> what kind of operation would you like to lift, in general?
03:15:15 <eflister> m [a], or even Traversable t => m t a (guessing)
03:15:31 <quicksilver> no
03:15:34 <quicksilver> what kind of *operation*.
03:15:39 <quicksilver> not what kind of action.
03:15:45 <eflister> <|>
03:15:51 <eflister> a pure one
03:15:54 <quicksilver> <|> requires two [a] to operate on.
03:16:06 <eflister> but it may never get to the second one!  :)
03:16:06 <quicksilver> you can't possibly give it two [a] without executing both sides.
03:16:16 <quicksilver> but, nonetheless that is what it requires.
03:16:22 <quicksilver> you can't call <|> without two [a].
03:16:42 <eflister> but i mean "a promise to give you an [a] if you really want one"
03:17:11 <quicksilver> ah well now you're breaking things.
03:17:16 <quicksilver> you can't do that.
03:17:18 <quicksilver> [a] is a pure value
03:17:22 <quicksilver> it actually *is* an [a]
03:17:26 <Nereid> you can do it with unsafeInterleaveIO ;)
03:17:30 <quicksilver> you're not allowed to have hidden execution
03:17:36 <quicksilver> Nereid: "you can't do that in haskell"
03:17:42 <Nereid> hence ;)
03:17:50 <quicksilver> if you're allowed to break the semantics then obviously you can do anything
03:17:55 <quicksilver> just poke some machine code and JMP to it
03:17:58 <quicksilver> I dont' care :)
03:18:15 <eflister> i'm only breaking the two [a] from each other -- not either one alone
03:18:45 <Nereid> eflister: <|> needs two [a] values.
03:18:50 <Nereid> there is no such thing as a promise to give you a value.
03:19:07 <Nereid> there is such a thing as a promise to tell how how to deconstruct this value, and this is what laziness is.
03:19:09 <Nereid> but that's different.
03:21:51 <Nereid> so. hGetContents.
03:22:13 <Nereid> close the handle out from under it before you evaluate the result. evil.
03:23:21 <fmap> Nereid: i don't understand Traversal (and Fold) so some kind of proof (even handwavy) why it's necessary here would be welcome
03:24:06 <eflister> doesn't it seem plausible (even if haskell can't express it) to have laziness at the execution level?  i haven't heard laziness explained as involving deconstruction, but "promising to give you a value when you actually are going to use it."  or have i misremembered standard intro haskell rhetoric?
03:24:14 <Nereid> it's sufficient. it may not be necessary. but it certainly can't be done with IO.
03:24:18 <Jafet> unsafeInterleaveIO has perfectly good semantics
03:25:03 <Jafet> eflister: no
03:25:32 <Nereid> er
03:25:39 <b_jonas> Jafet: what? ...
03:25:40 <Nereid> my text was in response to Traversable
03:25:46 <Jafet> It's not the same to do two things to the RealWorld but in a different order, or to do one and omit the other
03:25:58 <eflister> nereid: yeah i understood.
03:26:21 <Jafet> This is why IO cannot be interpreted as a pure language
03:26:21 <eflister> jafet: where did i depend on things being 'the same'?
03:26:40 <eflister> they can be "the same type"
03:26:42 <Jafet> Running the second IO is not the same thing as not running it.
03:26:43 <quicksilver> Jafet: giving a semantics to unsafeInterleaveIO requires giving a precise semantics to haskell evaluation order.
03:26:49 <quicksilver> Jafet: this has never been done
03:27:09 <quicksilver> and to the extent that the report is a guide, different haskell implementations are free to vary the order within certain limits.
03:27:14 <Jafet> quicksilver: I write a program using it and the program runs, that's its semantics. Of course not very useful semantics but still
03:27:24 <quicksilver> so I think "perfectly good semantics" is quite a bold claim.
03:27:43 <Jafet> Certainly if you're using glasgow haskell you can depend on it having certain properties
03:27:44 <Nereid> yes, there is a perfectly good semantics determined by how ghc turns your haskell into machine code.
03:27:53 <Nereid> maybe.
03:28:06 <quicksilver> "depend on it having certain properties" is quite a lot weaker than "perfectly good semantics"
03:28:53 <Jafet> Unless you only accept semantics that don't contain any nasal demons as semantics
03:29:32 <Nereid> Jafet: the point is that a semantics that depends on the implementation details of ghc is basically worthless.
03:30:30 <Jafet> That sounds stupid
03:31:11 <Jafet> So you just write programs that will still work if the implementation doesn't share anything
03:31:23 <Nereid> huh?
03:31:33 <Jafet> Because the haskell report doesn't specify that
03:32:04 <quicksilver> it's not just sharing.
03:32:23 <quicksilver> it's perfectly legal for a haskell compiler to evaluate something 'early' as long as it doesn't go into non-termination by doing so.
03:32:37 <quicksilver> GHC will do this sometimes thanks to its strictness analysis.
03:32:57 <quicksilver> if you have unsafeInterleaved thunks there then your IO actions can be evaluated earlier than you were expecting.
03:33:16 <Jafet> Or later, or not at all
03:33:18 <Nereid> and it all could depend on your version/platform of ghc, or what flags you give it, or ...
03:33:24 <quicksilver> in fact that very rarely happens - but it does make it hard to give an accurate semantics for unsafeInterleave
03:34:02 <eflister> if monadic computations can depend on previous values and applicatives can't, why can't lifting a pure function into a monad have execution that depends on the function's arguments?
03:34:23 <Nereid> eflister: what do you mean by lifting?
03:34:30 <quicksilver> eflister: because if you have a binary operation a -> b -> c
03:34:38 <quicksilver> eflister: then it *requires* a and b before you run it.
03:34:46 <quicksilver> you can't decide what to execute later.
03:35:00 <quicksilver> if you're calling a -> b -> c then you must lready have provided your 'a' and 'b'
03:35:04 <eflister> what if it never looks at b?
03:35:09 <quicksilver> and if that required execution you must have already done it.
03:35:11 <quicksilver> it doesn't matter.
03:35:20 <quicksilver> If you are calling a -> b -> cthen you MUST HAVE 'a' and 'b'.
03:35:30 <quicksilver> I really can't say this any differently than I've said it already :)
03:35:33 <Nereid> eflister: if you have IO b, then there is no b in sight at all until it's executed.
03:35:40 <Jafet> Your parameter isn't b, so whether the operator looks at b is irrelevant.
03:35:53 <eflister> you see why i think this, though, right?  b might require infinite memory, let's say
03:36:18 <Nereid> there isn't even a thunk for a value of type b
03:36:27 <Jafet> The parameter to liftM is IO b, and when liftM is run, that gets run
03:36:48 <Jafet> liftM and the IO are both run in IO, not evaluated.
03:37:08 <Jafet> Not just evaluated
03:37:50 <eflister> let's back up -- you guys see where i'm coming from, right?  a pure function a -> b -> c can be passed undefined for b
03:38:13 <Nereid> sure
03:38:19 <Nereid> but undefined is still a value
03:38:21 <quicksilver> I do know where you're coming from
03:38:27 <Jafet> The interpretation of your program has a layer of IO on the outside that does not have the same semantics as the layer inside
03:38:28 <quicksilver> but, still it is a 'pure value of type b'
03:38:39 <quicksilver> a 'pure value of type b' can require "work" to evaluate
03:38:46 <quicksilver> but it cannot have side-effects (IO actions)
03:39:13 <quicksilver> a pure value of type b can indeed require work to evaluate just partially and then more work later - consider infinite lists.
03:39:19 <merijn> Is there a "data MapOn f a b" notion where it uses "f a" as key rather than a itself?
03:39:20 <quicksilver> but still, not side-effects.
03:39:28 <merijn> Or should I define my own Ord of a that accomplishes that?
03:40:14 <eflister> but b could be "a list of instructions that you should only execute if i tell you to"
03:40:26 <quicksilver> eflister: no, that would not be of type b.
03:40:31 <quicksilver> that would be of type IO b
03:40:34 <merijn> eflister: No, that'd be [IO b], not IO [b]
03:40:59 <quicksilver> depending what you mean by instruction, I suppose.
03:41:06 <maukd> and list!
03:41:08 <quicksilver> but a pure value of type b CANNOT require side-effects to calculat the value.
03:41:17 <quicksilver> that's the point of the purity.
03:41:28 <Jafet> (IO a) is like a burrito. You can squash and reorder the filling however you like and even choose not to eat it, but to get there you need to bite off the wrapping.
03:41:44 <merijn> eflister: The point is that given "IO b" you can decide to evaluate it or not, but you cannot turn "IO b" into "b" without evaluating it (which is what you are trying)
03:42:12 <maukd> purito
03:42:15 <Nereid> without *executing* it
03:42:39 <Jafet> @quote executes
03:42:39 <lambdabot> Jafet says: In Soviet Russia, State executes you
03:42:51 <Nereid> maybe try and see how this works in a less magical monad like State
03:42:55 <Nereid> IO is too magical.
03:43:42 <Nereid> I *dare* you to write lift :: (a -> b -> c) -> State s a -> State s b -> State s c such that lift f doesn't look at its second argument if f doesn't.
03:44:05 <Nereid> or at least see why you can't.
03:44:24 <Nereid> hm, or even Reader.
03:44:32 <merijn> eflister: "liftM2" is just "\f a b -> do { x <- a; y <- b; return (f x y) }" as you can see both sides are forced to be executed, regardless of whether f uses them or not
03:44:35 <eflister> ok -- all i think i want to do is decide whether to execute it, not turn IO b into b.  at what point am i saying i want to do that?  will the state/reader exercise show me that?
03:45:21 <Nereid> eflister: I dunno.
03:45:25 <eflister> merijin: yeah i see that's what liftM2 does, but i'm trying to see why no liftM' could be written that didn't do that.
03:45:26 <maukd> the point is >>=
03:45:29 <merijn> eflister: Then you should just use the earlier code shown "\a b -> do { x <- a; if condition x then return x else b }"
03:45:57 <merijn> eflister: Well, how would you write it without executing the second argument?
03:46:19 <ivanm> :o I somehow managed to request too much memory in my FFI bindings! :o
03:46:34 <merijn> eflister: f *has to get* two arguments, neither of which can be in IO
03:46:39 <eflister> merijin: yes i know that code does what i want, but i am trying to correct my mis-intuition that i should be able to lift a pure function, which to me seems much more satisfying
03:46:59 <quicksilver> by the time you call the pure function, you have to have two parameters for it
03:47:00 * ivanm facepalms
03:47:05 <ivanm> I forgot to convert from CInt to Int
03:47:06 <quicksilver> I've said that before but you don't believe me, it seems :)
03:47:17 <quicksilver> I think Nereid'd State exercise might help
03:47:23 <quicksilver> at the risk of spoilering it...
03:47:24 <Nereid> yeah Reader won't do it.
03:47:39 <quicksilver> you'll discover that you can't even get the second value 'b' without deciding which state 's' to give it
03:47:49 <quicksilver> and the "inside" of your pure function doesn't have an 's' to give it.
03:49:06 <Nereid> why not even simplify the exercise to lift :: (b -> c) -> State s b -> State s c
03:49:34 <eflister> i shall try it.
03:49:40 <eflister> thanks for the patience guys!
03:50:17 <Jafet> Heh, an exercise that can
03:50:20 <Jafet> 't be completed.
03:51:13 <Nereid> the exercise is to see why you can't
03:52:04 <Nereid> djinn tells me that there are only two possible definitions for lift
03:52:18 <Nereid> one is liftM; the other doesn't do the right thing
03:52:48 <Nereid> liftM, fmap, same thing
03:52:57 <monsieurlu> Please, I'm feeling not really confortable with folds in haskell. Someone can tell me exactly what the second argument is about? is that the bottom up value of the recusion?
03:53:14 <maukd> @src foldr
03:53:15 <lambdabot> foldr f z []     = z
03:53:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:53:35 <monsieurlu> ha ! Thanks :)
03:53:49 <monsieurlu> Understood!
03:54:08 <Nereid> monsieurlu: foldr f z replaces (:) with f and [] with z.
03:54:15 <Nereid> Cale: where's that picture again
03:54:37 <Nereid> found it http://www.haskell.org/wikiupload/3/3e/Right-fold-transformation.png
03:55:02 <Nereid> http://www.haskell.org/haskellwiki/Fold
03:55:07 <Jafet> http://foldr.com
03:55:21 * hackagebot xdg-userdirs 0.1.0.1 - Basic implementation of XDG user directories specification  http://hackage.haskell.org/package/xdg-userdirs-0.1.0.1 (IlyaPortnov)
03:55:30 <Jafet> Heh, that's still around.
03:56:05 <Nereid> and foldl.com
04:01:54 <monsieurlu> Nereid: Explications are definitely more clear in this page than the book i read. Thanks!
04:10:00 <merijn> So, back to my own question from earlier: What's the best way to go about obtaining something like "data MapOn f a b" which is essentially Map but using "f a" as key rather than a. Should I just implement Ord a in a way that it does that implicitly and then use Map?
04:12:52 <Nereid> I wonder if you could do some silliness like
04:12:53 <maukd> data MapOn k k' v = MapOn (k -> k') (Map k' (k, v))
04:13:44 <merijn> maukd: I don't care about the original a tbh, I just want to do map lookups based on a field, rather than the entire record
04:14:33 <maukd> lookup (field rec) m
04:14:38 <merijn> Clearly it can be rather simply implemented, I was just wondering if it already exists :)
04:16:23 <Nereid> never mind
04:17:53 <merijn> Unrelatedly, I'm guessing STM has almost no overhead in the case of frequent reads/extremely infrequent writes?
04:20:21 * hackagebot morfeusz 0.3.0 - Bindings to the morphological analyser Morfeusz  http://hackage.haskell.org/package/morfeusz-0.3.0 (JakubWaszczuk)
04:24:04 <eflister> ok i'm lost.  am i trying to see why i can't write (a->b) -> State s a -> State s b without being strict in the pure function's argument?
04:25:45 <Saizan> \f m -> State $ \s -> first f (runState m s) -- that isn't strict in f
04:26:43 <DanMere34567> whats teh best way to show colours? I have the ansi system library but I am wondering if there are some other ways to do this?
04:28:16 <merijn> Saizan: Earlier we were having a discussion where he wanted to liftM2 a function without executing the second IO action unless the function used it
04:28:38 <merijn> Saizan: Which is, of course, impossible. So someone gave that exercise to learn why
04:29:02 <Jafet> danmere: probably vty
04:29:20 <eflister> yep, but i think i don't get what i'm supposed to be doing, for reasons like saizan gave
04:29:40 <merijn> "unsafeIOtoSTM newChan" should be safe, right? i.e. in the worst case it allocates a Chan that immediately gets collected because the transaction retried
04:29:40 <Nereid> eflister: so we want to write lift :: (a -> b) -> State s a -> State s b, which has these properties:
04:29:58 <mysticc> How do I do something like  f a + f b = f (a + b) where I have defined functor instance for type of f. (Is it possible or  I need monad instance too)
04:30:10 <eflister> incidentally, i get why "action" is a good word for IO a, but i don't get why "computation" is used -- i think of pure things like 2+2 as computations.  (and "executions", for that matter)
04:30:15 <merijn> mysticc: You need Applicative
04:30:30 <merijn> mysticc: Then you can use "liftA2 (+)"
04:30:40 <mysticc> merijn: oh ... thanks
04:30:53 <Nereid> eflister: uh, so
04:31:05 <merijn> mysticc: Although monad and liftM2 should work too, I guess.
04:31:26 <eflister> and i don't understand why any of these terms picks out monadic things other than IO
04:31:43 <Nereid> they're not really precise terms.
04:32:05 <eflister> side-effect i get.
04:32:06 <Nereid> they're analogies, I guess.
04:32:21 <Nereid> eflister: anyway, so you want to write such a lift, such that
04:32:43 <Nereid> if f doesn't look at its argument, then lift f m doesn't change the state of m
04:32:58 <Nereid> i.e. if f _ = x, then lift f m = return x
04:33:31 <Nereid> err
04:33:40 <Nereid> "... lift f m doesn't change the state"
04:33:45 <Nereid> no "of m", that makes no sense.
04:34:20 <Nereid> lift f m :: State s c
04:34:24 <t7> can i multiply quaternions together like roatation matrixes ?
04:34:37 <Nereid> t7: there is quaternion multiplication
04:34:51 <Nereid> and yes
04:34:52 <Jafet> Unit quaternions are the same thing as rotation matrices
04:35:06 <Jafet> Well, three-dimensional rotation matrices
04:35:13 <Nereid> the rotation corresponding to a product of quaternions is indeed the composite of the rotations corresponding to each
04:35:21 * hackagebot nkjp 0.2.0.1 - Manipulating the National Corpus of Polish (NKJP)  http://hackage.haskell.org/package/nkjp-0.2.0.1 (JakubWaszczuk)
04:35:51 * ion manipulates the Polish
04:36:14 <merijn> Is there somewhere I can read up on the exact details of things I need to take into account when using unsafe*?
04:36:24 <Saizan> eflister: well yeah, we are interested in keeping a distinction between what happens when you want to reduce an expression to a value and what happens when you want to perform the side-effects of some monad, the choice of evaluation for the former and execution for the latter is a bit arbitrary
04:38:18 <Nereid> hmm, I wonder if I should write a package for working with EDICT/KANJIDIC files
04:38:52 * typoclass manipulates the corpuses of the polish
04:39:03 <Jafet> merijn: darcs.haskell.org
04:40:04 <Jafet> You're unlikely to get any kind of formal english definition of anything named unsafe
04:40:53 <merijn> Jafet: That's what I feared :p
04:41:14 <quicksilver> well the promises for some of them are written down
04:41:16 <quicksilver> not sure where.
04:41:38 <merijn> Jafet: I guess it's safe to unsafeIOtoSTM if the IO is idempotent (aside from some haskell memory allocation which should get GC'ed)?
04:41:57 <Jafet> It morally should be
04:41:59 <quicksilver> yes for unsafeIOtoSTM you need it not to matter if it's called multiple times or never
04:42:10 <eflister> nereid: doesn't change the state?  why can't i write lift _ x = x?  or sets the state to the output of f?  lift f _ = return $ f undefined
04:42:33 <Saizan> eflister: wrong types
04:42:39 <Nereid> lift _ x = x has the wrong type
04:42:41 <Jafet> You're returning, like, a TVar Chan?
04:42:59 <Nereid> eflister: the last thing does the wrong thing for when f *does* look at its argument
04:43:02 <merijn> Jafet: I have a "Map a Chan" inside a TVar
04:44:02 <dmwit> merijn: idempotent doesn't seem like enough
04:44:34 <dmwit> merijn: You need to be able to roll back... it might be done as part of a transaction that doesn't get to commit.
04:44:35 <merijn> I want other threads to start listening to a Chan for a given key which means either dupChan the existing entry or insert a newChan
04:45:26 <merijn> dmwit: Well, in my case the only rollback to do would be GC the allocated/duplicated Chan
04:45:52 <Nereid> <quicksilver> yes for unsafeIOtoSTM you need it not to matter if it's called multiple times or never
04:45:57 <Nereid> so what sort of use case would it have?
04:46:14 <merijn> Nereid: I just described one I think :p
04:46:17 <Nereid> hmm
04:46:58 <eflister> nereid: couldn't i check if (f undefined) errors, and do fmap otherwise?
04:47:33 <eflister> s/otherwise/if so
04:48:07 <merijn> eflister: (f undefined) might error way after returning
04:48:21 <merijn> eflister: You'd have to force all the possible computation first
04:48:30 <merijn> > Just undefined
04:48:31 <lambdabot>   Just *Exception: Prelude.undefined
04:48:40 <merijn> > Just 1 <|> Just undefined
04:48:42 <lambdabot>   Just 1
04:48:58 <Nereid> eflister: if you were in IO, I suppose you could.
04:49:05 <Nereid> but that's disgusting
04:49:06 <Nereid> :V
04:49:11 <eflister> deepSeq (f undefined)
04:49:14 <eflister> :)
04:49:30 <Jafet> That's still wrong
04:50:19 <eflister> see, doesn't this seem to come down to strictness?!?!
04:51:12 <Jafet> f x = (0, undefined)
04:51:20 <Jafet> f x = (x, undefined)
04:51:31 <Jafet> Neither seq or deepseq can differentiate those
04:52:36 <eflister> > id undefined
04:52:38 <lambdabot>   *Exception: Prelude.undefined
04:53:26 <Nereid> deepseq doesn't work on arbitrary types anyway
04:53:34 <Nereid> @hoogle deepseq
04:53:34 <lambdabot> Control.DeepSeq module Control.DeepSeq
04:53:34 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
04:53:34 <lambdabot> package deepseq
04:53:47 <eflister> couldn't i write something that traverses all sum/product type structure calling id at each point?
04:53:55 <Brax> is there some way to receive suggestions on code like on hpaste, without having to post the code?
04:53:58 <Jafet> instance NFData a where rnf = const ()
04:54:03 <Nereid> eflister: what if it's not a sum or product type?
04:54:11 <dmwit> What exactly are you expecting "calling id" to do that's helpful?
04:54:17 <Nereid> also heh.
04:54:18 <Jafet> Brax: that program is called hlint
04:54:28 <Brax> on ideone i can post it private, but it's strange for haskell
04:54:41 <eflister> nereid: what else is there?  dmwit: error if undefined
04:54:42 <Jafet> dmwit: yo dawg
04:54:44 <Nereid> eflister: like say, a function type, or an existential type, or ...
04:54:48 <Nereid> some GADT...
04:55:04 <Nereid> or an IO value...
04:55:10 <eflister> > id (+)
04:55:11 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
04:55:11 <lambdabot>    arising from a use...
04:55:23 <dmwit> eflister: If "id x" would cause an error, so would "x".
04:56:06 <Brax> Jafet: ah, thanks
04:56:58 <eflister> dmwit: i can have a value "undefined", which as long as i never reference it, doesn't error.  that's the difference i'm trying to overcome with id.  (i'm sure i'm wrong, just trying to learn)
04:57:25 <eflister> x = undefined doesn't error until i do something like id x, right?
04:57:25 <tgirod> is there a way to visualize the dependency graph of a package I want to install with cabal ? I'm stuck in the dependency hell and need a map ;)
04:57:36 <Nereid> what does "do something like id x" mean?
04:57:43 <Nereid> if you don't evaluate id x, then nothing happens.
04:57:46 <Nereid> if you evaluate id x, then you evaluate x
04:57:50 <sipa> eflister: not if id x isn't used
04:58:20 <Nereid> x and id x are the same thing
04:58:25 <Nereid> in pretty much every way
04:58:27 <eflister> that's what i'm trying to do: come up with something that evaluates id on every part of a value, to force an error if anything is bottom
04:58:44 <maukd> > length [id undefined]
04:58:45 <lambdabot>   1
04:59:27 <sipa> you want id $! x, maybe?
04:59:28 <Nereid> > length [let x = x in x]
04:59:29 <lambdabot>   1
04:59:34 <sipa> wait, nvm
04:59:52 <eflister> > (1,undefined)
04:59:53 <lambdabot>   (1,*Exception: Prelude.undefined
05:00:11 <Nereid> > fst (1,undefined)
05:00:13 <lambdabot>   1
05:00:41 <sipa> eflister: the question whethert you inspect the value produced by x
05:00:56 <eflister> yeah that's what i'm tryign to do with id
05:01:00 <sipa> adding id in front doesn't change that
05:01:26 <sipa> it doesn't need to know what is inside, it just passes it through
05:01:33 <fmap> eflister: you can't pattern match on undefined (i guess it's what you are trying to do)
05:02:09 <eflister> ok i don't need the id, i just want to see if some complicated value has any undefineds buried in it
05:02:14 <_box> > fst (deepseq (1,undefined))
05:02:15 <lambdabot>   Not in scope: `deepseq'
05:02:16 <Nereid> no you don't
05:02:24 <_box> hmh
05:02:38 <Nereid> eflister: and you can't
05:02:52 <eflister> nereid: yeah you guys are saying that doesn't solve it, but i'm not caught up to why yet
05:03:17 <dmwit> What is the top-level goal here?
05:03:23 <dmwit> I feel like we're deep in yak-shaving territory.
05:03:27 <sipa> it doesn't matter whether there is an undefined buried inside, if it never needs to be evaluated
05:03:46 <Jafet> There are things that are not defined and not undefined.
05:03:51 <Jafet> > fix id
05:03:54 <dmwit> "yak-shaving" isn't the right term. "deep in X-Y territory"?
05:03:55 <lambdabot>   mueval-core: Time limit exceeded
05:03:59 <_box> couldn't he use catch & deepseq?
05:04:19 <dmwit> I feel like we're thinking deeply about the wrong problem. <- there, no catchy buzzwords, much clearer
05:04:23 <Jafet> dmwit: that reminds me of xycombinator.com
05:04:42 <eflister> you see why i think it helps though -- if i have something like (f undefined) not error, then i can detect whether f uses b
05:05:03 <maukd> eflister: how so?
05:05:05 <dmwit> Jafet: love it
05:05:06 <fmap> _box: deepseq isn't polymorphic enough
05:05:12 <Jafet> eflister: f (sum [0..])
05:06:14 <eflister> dmwit: they're helping me see why i can't lift a pure a -> a -> a into a monad that only executes its second arg if the first is empty
05:06:41 <Nereid> well, [a] -> [a] -> [a]
05:07:07 <eflister> dmwit: this got turned into seeing why you can't write lift' :: (a->b) -> State s a -> State s b
05:07:53 <dmwit> Wait, what?
05:08:01 <dmwit> lift' = fmap -- ?
05:08:04 <Saizan> you can, but not with liftM2
05:08:18 <Nereid> Saizan: no, you can't lift the given function.
05:08:24 <Nereid> for an arbitrary function.
05:08:33 <sipa> :t fmap
05:08:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:08:44 <eflister> dmwit: so i'm trying to find ways of seeing whether the first arg uses its first arg
05:08:45 <Saizan> Nereid: what's the full type, (a -> a -> a) -> [a] -> [a] -> [a] ?
05:08:49 <Nereid> no
05:09:00 <Nereid> say, ([a] -> [a] -> [a]) -> m [a] -> m [a] -> m [a]
05:09:55 <dmwit> I must say I'm even more thoroughly lost now than when I first asked what problem we were trying to solve.
05:10:19 <Nereid> ok, here was the original thing:
05:10:21 <maukd> dmwit: fmap doesn't solve the problem
05:10:41 <Nereid> eflister effectively wrote (<|>) :: [a] -> [a] -> [a], that returns the first list if it's nonempty, otherwise the second.
05:10:50 <Saizan> ok
05:11:24 <Nereid> and his expectation was that, for x, y :: IO [a], liftM2 (<|>) x y wouldn't execute y if x returned an empty list.
05:11:28 <eflister> dmwit: lift' subject to "if f doesn't look at its argument, then lift f m doesn't change the state"
05:11:33 <Saizan> i see
05:11:43 <dmwit> okay
05:12:46 <Nereid> well, you can write m [a] -> m [a] -> m [a] that does that
05:13:00 <Nereid> \x y -> do { c <- x; if (not (null c)) then return c else y }
05:13:13 <Nereid> but he was hoping to be able to use this (<|>) somehow.
05:13:53 <Nereid> so,
05:15:16 <eflister> well, to be fair, i tacitly thought i had [IO a]'s.  but given IO [a]'s, it still isn't clear to me why it's impossible to write a lift that behaves this way, though i see that liftM2 does not.  :)
05:15:31 <Nereid> right.
05:15:51 <Nereid> well we can simplify things a bit, to a function of one argument.
05:16:26 <eflister> but i agree i am forced into something ugly, like trying to see if there is an undefined buried anywhere inside the result of (f undefined)
05:16:35 <Saizan> (you have to duplicate the short-circuiting logic into the monadic combinator, so it won't be "correct" for functions that don't short-circuit in the same way)
05:16:49 <Nereid> that's what we've all been saying.
05:16:57 <Nereid> or something like it.
05:17:13 <quicksilver> eflister: (checking for undefined is impossible)
05:17:13 <yitz> Nereid: you mean "wouldn't execute y *unless* x returned an empty list"?
05:17:46 <Nereid> hmm, yes.
05:17:52 <Nereid> it's late.
05:17:56 <yitz> :)
05:19:36 <yitz> i guess you could define a specialized kind of lift that requires Alternative structure and respects it
05:19:52 <yitz> but regular lifts know nothing about Alternative.
05:19:56 <eflister> saizan: what is the intuition that the short circuiting logic has to be duplicated?  that desire to avoid duplication is my motivation -- once i have a pure expression of short circuiting, i want to lift it, rather than rewriting it.
05:20:22 <Nereid> eflister: you don't have to duplicate anything
05:20:23 <merijn> If I'm worker on a server and client which share some modules, what's the best source layout? One big source tree, a server/client/shared split or something else?
05:20:28 <Nereid> but you do have to generalize the short circuiting
05:20:31 <Nereid> to work in any monad
05:20:45 <Nereid> and you can specialize it back to the pure one by using that on the Identity monad, say
05:21:15 <Nereid> this isn't an unusual thing to do.
05:21:20 <yitz> merijn: using some kind of rpc?
05:21:27 <merijn> yitz: huh?
05:21:42 <Nereid> eflister: silly example coming up.
05:21:47 <Nereid> let's say we had the factorial function
05:21:48 <eflister> nereid: i like that.  but i still feel i need to understand why what i'm doing is impossible.
05:21:56 <Saizan> eflister: the intuition is that lifting pure functions can be done with Applicative alone, and Applicative doesn't let you decide the successive side-effects depending on information for earlier results
05:22:14 <yitz> merijn: trying to figure out why the client and server would share modules.
05:22:16 <merijn> yitz: I just mean I plan to use the same protocol/data structures on both sides so those modules are needed to build both the server and client
05:22:29 <Nereid> Saizan: I did say that, but he's still wondering why we can't write a different lift that uses monad features.
05:22:31 <Nereid> anyway.
05:22:33 <Saizan> eflister: information *from other results
05:22:44 <Nereid> fact 0 = 1; fact n = n * fact (n-1)
05:22:45 <Nereid> easy.
05:22:55 <yitz> merijn: so you serialize/deserialize and then use the same types at each end?
05:23:02 <Nereid> now say I wanted to generalize this to, say
05:23:21 <Nereid> factBounded :: Integer -> Maybe Integer
05:23:29 <merijn> yitz: Yes, and also stuff like the event loop for dealing with messages, etc
05:23:34 <Nereid> such that factBounded would return Nothing if the recursion took us to values bigger than a million, say.
05:24:03 <Nereid> and moreover the recursion would actually stop, so factBounded 3000 wouldn't compute a huge integer just to throw it away because it's too big.
05:24:04 <eflister> nereid: ok
05:24:09 <Saizan> eflister: also, apart for ugly hacks, you don't get any information from a function until you've given it all of its arguments
05:24:22 <Nereid> so let's start with our original fact :: Integer -> Integer
05:24:43 <Nereid> somehow we want to "monadify" this to get fact' :: Monad m => m Integer -> m Integer
05:24:44 <yitz> merijn: if so, then i would have a package for the data and its methods. and another for event-loop stuff if that's logically independent.
05:24:52 <eflister> saizan: yeah, my ugly hack was to set some arguments to undefined and catch resulting errors
05:24:59 <Nereid> hmm.
05:25:11 <Nereid> hang on, I haven't thought this through
05:25:23 * hackagebot gluturtle 0.0.33 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.33 (YoshikuniJujo)
05:25:25 * hackagebot cakyrespa 0.0.24 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.24 (YoshikuniJujo)
05:25:35 <yitz> merijn: disclaimer: i tend to use too many packages, so i *always* use cabal-dev, and i have some scripts to help me manage that.
05:25:36 <merijn> yitz: It's not going to be logically independent at all. Server are client are tightly coupled, alternative implementations do not make sense (well, they might make sense but I don't plan to allow them)
05:26:12 <merijn> I'm more thinking how I should layout the directory tree for modules
05:26:39 <Nereid> yeah let's start over.
05:26:52 <Nereid> hmm I still haven't thought it through.
05:27:08 <yitz> merijn: ah i see. well, what i meant was "independent" w.r.t. version bumps, not necessarily implementation or api independence.
05:28:29 <merijn> Not sure whether I should have a different server, client and shared top level directory or just one module tree or something else entirely
05:30:22 <Nereid> eflister: yeah I don't know where I was going with that, sorry :V
05:30:33 <yitz> merijn: i don't think the directory structure matters very much. you could have everything in one big monolithic directory even if you have several packages, and vice versa.
05:31:39 <eflister> quicksilver says you can't check for undefined, but can't you try to force its evaluation and catch resulting errors?
05:32:04 <quicksilver> no.
05:32:11 <quicksilver> you can't catch any errors at all in pure code.
05:32:24 <quicksilver> if you try to do so, you're actually breaking the semantics of the language.
05:32:27 <quicksilver> "There is no spoon".
05:32:42 <KBme> is there a way to import qualified, but import selectively?
05:32:45 <Nereid> eflister: an undefined value may not ever error
05:32:49 <Nereid> let x = x in x
05:33:26 <typoclass> eflister: i'm not sure what you're planning to do with 'undefined', but i don't think that's the straightforward haskell way to do it :-) you could post some code (use hpaste) and folks can give you advice
05:34:18 <Jafet> (He did and we did.)
05:34:27 <Nereid> eflister: basically you can't do it
05:34:55 <eflister> why am i in pure code when trying to write that lift' (typoclass: i'm trying to be taught why ugly hacks don't get me out of the pedagogical corner they made for me)
05:34:55 <typoclass> Jafet: ok thanks
05:35:08 <Nereid> oh and that exercise was also probably wrong.
05:35:17 <eflister> good grief :)
05:35:17 <merijn> yitz: I know, that's why I'm asking for opinions about what other people find pleasant to use :p
05:35:32 <Nereid> or missing the point.
05:35:52 <merijn> KBme: What do you mean by "qualified but selectively"?
05:35:56 <quicksilver> KBme: yes, certainly
05:35:59 <maukd> eflister: you're always in pure code
05:36:10 <quicksilver> KBme: you can combine the qualified + selective syntaxes for import
05:36:14 <quicksilver> they're not either-or
05:36:33 <Nereid> eflister: either that or it's late and I'm tired :v
05:36:51 <eflister> maukd: well, there i was in the state monad.  people use "pure code" to mean "not in a monad" right?
05:37:08 <Nereid> if they do, they shouldn't
05:37:26 <Jafet> Pure code is, obviously, whatever you pass to pure
05:37:27 <eflister> well then pure has no meaning, does it?
05:37:49 <Nereid> I'd say pure doesn't have a precise meaning.
05:37:55 <merijn> eflister: Sure it does, but many people misuse the word
05:38:04 <eflister> in what sense was quicksilver using it?
05:38:09 <quicksilver> people abuse the language because it's convenient.
05:38:12 <merijn> eflister: In general pure is usually intended to mean "referentially transparent"
05:38:34 <Nereid> and in that sense, everything you write is pure. unless you use unsafe* stuff
05:38:34 <merijn> eflister: Which all haskell code is, regardless of monads and what not
05:38:40 <merijn> (unless you use unsafe*)
05:38:57 <eflister> but i can catch errors in haskell, and quicksilver said i cannot in pure code
05:39:00 <merijn> Which is also why those things are labelled "unsafe" :p
05:39:01 <typoclass> eflister: no, you have that right, it's common to say "pure code" as opposed to "monadic code"
05:39:07 <Nereid> no, you can write code that describes catching errors.
05:39:09 <Nereid> :v
05:39:54 <eflister> as helpful as you guys are, many comments seem deliberately opaque.  :)
05:40:00 <maukd> eflister: you can't catch errors
05:40:12 <typoclass> eflister: welcome to #haskell :-(
05:40:50 <eflister> > catch undefined 3
05:40:51 <lambdabot>   No instance for (GHC.Num.Num (GHC.Types.IO a))
05:40:51 <lambdabot>    arising from a use of `e_...
05:40:58 <quicksilver> you can't write expressions which, as they evaluate, automatically find errors in subexpressions and reduce to values conditional on that.
05:41:03 <eflister> @type catch
05:41:04 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
05:41:24 <quicksilver> you *can* write IO actions which, as they execute, conditionally choose execution paths based on exceptions which they catch.
05:41:30 <quicksilver> I'm not quite sure how to say that in a nice way.
05:42:35 <quicksilver> I welcome attempts to improve my wording or my precision
05:42:35 <quicksilver> :)
05:42:57 <eflister> can i have an exception when i try to evaluate undefined?
05:43:13 <Nereid> yes, but you can't catch it outside of IO.
05:43:17 <dmwit> ?google halting problem
05:43:17 <lambdabot> http://en.wikipedia.org/wiki/Halting_problem
05:43:17 <lambdabot> Title: Halting problem - Wikipedia, the free encyclopedia
05:43:24 <typoclass> eflister: ^^ from the final "IO a" in the type, you can see that this is "in IO", i.e. monadic, i.e. not pure. this is what people meant when they said exceptions can be thrown anywhere, but caught only in IO
05:43:43 <Jafet> undefined is a placeholder for something that does not produce a value
05:43:47 <dmwit> ?google rice's theorem
05:43:47 <lambdabot> http://en.wikipedia.org/wiki/Rice's_theorem
05:43:54 <Jafet> You could also use (let x = x in x)
05:44:06 <Jafet> Or unsafePerformIO exitFailure
05:44:12 <Nereid> haha
05:44:42 <dmwit> Rice's theorem: any non-trivial property of programs is undecidable. (!)
05:46:22 <merijn> It's not really possible to specify a module with some functions a -> b, a -> c or a -> d, but with a the same for every function in the module?
05:46:42 <merijn> Sort of module wide type variable...
05:46:46 <Jafet> {-# LANGUAGE ML #-}
05:46:58 <Nereid> what does "the same" mean?
05:47:08 <merijn> Jafet: Yeah, I was writing that and thought "I think I finally understand the value of ML modules"
05:47:09 <eflister> i am happy to be in IO for now to find undefineds.  since i can write exception catching in IO in haskell, and all haskell is pure, i don't get what the point of saying "i can't catch errors in pure code" is.
05:47:10 <ion> Is that what ML calls functors? I haven’t studied ML yet.
05:47:13 <Nereid> (presumably these are polymorphic in a)
05:47:14 <dmwit> Yeah, several people have wished for something akin to Coq's Section mechanic.
05:47:26 <dmwit> It's not currently possible.
05:47:27 <merijn> Nereid: The module is polymorphic in a, the functions are not
05:47:32 <Nereid> hm.
05:47:52 <quicksilver> eflister: what I meant by "I can't catch errors in pure code" is "you can only catch errors in the IO monad using primitives which are IO actions"
05:47:55 <merijn> dmwit: That's what I feared. What's the best alternative approach?
05:48:03 <Jafet> merijn: you may be able to use rank-2
05:48:04 <dmwit> Oh, you want ML-style, which is even less likely to happen in the future than Coq-style. =)
05:48:17 <quicksilver> merijn: you may be able to package that as a piece of data
05:48:36 <quicksilver> data Merijn a = Merijn { foo :: a -> b, bar :: a -> c }
05:48:43 <merijn> quicksilver: Yeah, but then I need to ship the data around everywhere which is what I wanted to avoid :)
05:48:48 <eflister> quicksilver: which is adequate for trying to find undefineds, no?
05:49:02 <quicksilver> eflister: no, because even in IO you can't reliably find undefineds.
05:49:11 <merijn> I think I'll either hardcode the type or switch to something Reader/State-ish
05:49:16 <quicksilver> eflister: there will always be some _|_ you cannot detect.
05:49:23 <quicksilver> this is the halting problem.
05:49:27 <Jafet> merijn: if you can ship it in a class constraint, you can do something like reflection
05:49:29 <dmwit> See also: Rice's Theorem (linked above and summarized above).
05:49:55 <merijn> Jafet: I can't ship it as a class constraint until we get closeable typeclasses :\
05:50:10 <eflister> quicksilver: i believe that -- but seems like this is the important fact, not that i "can't catch errors"
05:50:49 <merijn> I think I'll just hardcode the type, as I only need it for one type anyway. Just thought that keeping it more polymorphic might make it a little more reusable
05:50:50 <quicksilver> eflister: tehre are two different important facts.
05:51:10 <quicksilver> eflister: one is that you cannot make a function a -> b which behaves differently depending if a "contains" an exception.
05:51:21 <quicksilver> eflister: (although you can do that for a -> IO b)
05:51:33 <quicksilver> the second is the issue about not all _|_ being detectable.
05:53:06 <eflister> but neither of those is the conjunction "you can't catch errors in pure code" and "all haskell is pure"
05:54:02 <Nereid> alright, I should have gone to bed hours ago.
05:54:03 <Nereid> bye :)
05:54:12 <eflister> thanks for your help nereid :)
05:54:55 <quicksilver> eflister: "you can't make a function a -> b which behaves different depending if a "contains" an exception" is what I meant by "you can't catch errors in pure code".
05:55:48 <eflister> incidentally, how do you guys use irc?  i am always 20 messages behind the conversation and totally unable to attend to any other task.  you guys are always a few messages ahead of the conversation and obviously super productive on real work at the same time.  what am i doing wrong?
05:56:09 <typoclass> eflister: moar coffee?
05:56:19 <merijn> eflister: "obviously super productive on real work at the same time" <- ahahahahahahahaha
05:56:46 <flameo_> just visiting on MYBIRTHDAY!
05:56:48 <quicksilver> eflister: if I ever appear a few messages ahead it's only because I've had the conversation before.
05:57:00 <typoclass> merijn: i forgot, looking at lolcats counts as work in the 21st century, doesn't it?
05:57:08 <quicksilver> eflister: if you hit me with something I haven't thought about properly before I will of course be behind just like anyone.
05:57:32 <quicksilver> also sometimes I appear to be ahead when in actual fact I'm simply wrong.
05:57:41 <eflister> quicksilver: you were using "pure" to mean "not in IO", right?  others chimed in that "all haskell is pure" -- so that's confusing.  and why did you think i shouldn't be in IO?
05:58:04 <Nimatek> What merijn said.
05:58:33 <quicksilver> eflister: I don't think you shouldn't be in IO. You can if you like. I was just making a point about the limitations of not being in IO.
05:58:33 <byorgey> flameo_: happy birthday!
05:58:46 <flameo_> thank you
05:58:50 <dmwit> ?quote roconnor arrow.*pure
05:58:50 <lambdabot> roconnor says: An arrow (category) is pure if (f &&& f) = f >>> (id &&& id). When people say Haskell is pure they mean that (->) is pure. When people say IO isn't pure they mean that (Kleisli IO)
05:58:50 <lambdabot> isn't pure.
05:59:12 <quicksilver> eflister: I was using pure to mean 'without the power of IO execution'
05:59:22 <quicksilver> eflister: the other people were quite right that I was abusing the language.
05:59:32 <quicksilver> it's a common abuse I'm sorry that it contributed to confusion.
05:59:46 <dmwit> eflister: These are the two common (and not identical) meanings people typically use when they say "pure".
05:59:52 <eflister> i liked what saizan had to say -- applicative is enough to lift a pure function, so you need more than a lifted pure function if you want to have execution depend on previous values.  so i am left with the question "what is it about applicative that prevents conditioning on previous values."  perhaps typecassopedia makes that clear?
06:00:48 <typoclass> eflister: i suggest you forget about "all haskell is pure" for the moment. it refers largely to the distinction between compile time and runtime (impure IO stuff happens at runtime ...), but i bet you're clear on that distinction anyway. the "all haskell is pure" thing is hairsplittery which i don't think is particularly helpful in any context
06:01:52 <b__> when I profile the same function twice (in one defaultMain) with criterion, the second test is always faster, can I avoid this somehow?
06:01:57 <typoclass> quicksilver: i don't see what's the abuse about that ... IO stuff here, pure stuff there. seems like a useful choice of names
06:01:57 <KBme> quicksilver, weird, doesn't want to work for me
06:01:59 <eflister> you often see impure referring to non-IO monadic code, too.
06:01:59 <KBme> it would be
06:02:10 <KBme> import qualified Module as M (myFunc)?
06:02:21 <quicksilver> import qualified Module(myFunc) as M
06:02:25 <typoclass> eflister: right, IO, and by extension also other monads
06:02:27 <byorgey> dmwit: ah, that is a great quote.  I had never thought about a general categorical characterization of purity before.
06:02:28 <KBme> ah no space eh
06:02:34 <KBme> ok thanks
06:02:47 <dmwit> Yeah, it's Pretty Good.
06:02:54 <quicksilver> KBme: space doesn't matter
06:03:10 <eflister> typoclass: which is frustrating, cuz non-IO monads ARE referentially transparent, right?
06:03:10 <quicksilver> KBme: what matters is the import list comes after the module name, not after the 'shorthand name'
06:03:26 <quicksilver> (all monads are referentially transparent)
06:03:41 <quicksilver> I'm not sure that typoclass is right to suggest it's not helpful in *any* context to understand that all haskell is pure.
06:03:46 <dmwit> eflister: There are many monads m for which (Kleisli m) is not pure in the roconnor sense.
06:03:47 <quicksilver> I think it's quite important in some contexts.
06:04:13 <Saizan> dmwit: maybe would be pure, right?
06:04:25 <eflister> IO is not referentially transparent, if we are not hair-splittering, right?
06:04:27 <byorgey> yes, Maybe is pure, as is Reader
06:04:29 <byorgey> State is not
06:04:39 <byorgey> nor Writer
06:05:25 <Saizan> eflister: referential transparency is a property of the language as a whole, i'd say, and IO respects it
06:05:49 <typoclass> quicksilver: i still think it's largely the compile time/runtime split. but i don't think i've ever met anyone who got confused about it and (say) expected getLine to read a line from the compiler's stdin, or something like that. i think people are mostly clear on that
06:05:56 <byorgey> eflister: that's sort of an ill-defined question.  It depends on what "level" you are viewing things.
06:06:37 <byorgey> eflister: from the "outside", within Haskell itself, IO is referentially transparent.  When dealing with values of type (IO a) you can replace equals with equals, etc.
06:06:39 <dmwit> eflister: You aren't allowed to avoid hair-splitting until you can do the hair-splitting correct 100% of the time.
06:06:52 <dmwit> *correctly
06:07:22 <byorgey> eflister: if you're thinking "internally", i.e. the IO-language which is "embedded" into Haskell via the IO monad, that embedded language itself is not RT.
06:07:32 <dolio> It's an embedded language/meta language split.
06:07:38 * byorgey just split some hairs.
06:07:52 <dmwit> High five!
06:07:55 <KBme> quicksilver, i'll try it, thanks
06:08:05 * byorgey agrees with dolio
06:08:10 <Saizan> right, if you take <- in do-notation to be an equal, you lose ref. transparency
06:08:14 <eflister> a haskell program can do different things, given the same arguments, depending on the RealWorld, right, because of IO?  if RealWorld counts as an argument, then referential transparency doesn't mean anything and all languages have it.
06:08:32 <Saizan> though that's hardly the case even when you write in imperative langs
06:08:34 <maukd> eflister: there is no RealWorld
06:08:45 <maukd> have you ever seen one?
06:08:50 <merijn> eflister: The point is that haskell can't do anything with IO a
06:09:14 <byorgey> eflister: again it depends what you mean by "do".  If you just mean "a haskell program can evaluate to different things", that is false.  A Haskell program producing a value of type (IO a) will always produce the same (IO a) for the same inputs.
06:09:15 <merijn> eflister: The runtime (which is not referentially transparent) can execute IO a to do something, but haskell itself just sees it as an opaque box
06:09:19 <typoclass> maukd: you're not helping ...
06:09:43 <merijn> Naming question, what'd be a good name for "Ord k => a -> k"?
06:09:52 <byorgey> eflister: if you mean "execute", i.e. what the haskell runtime does when executing some IO action, that can produce different results for the same inputs.
06:09:56 <Jafet> name
06:10:19 <Saizan> eflister: an important difference is that other langs don't have a let x = foo which is guaranteed to be ref. transparent, they only have the equivalent of do x <- foo at best, which is not
06:10:23 <t7> linux directory names can have . in the middle of them right
06:10:25 * hackagebot DSH 0.8.2.1 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.8.2.1 (GeorgeGiorgidze)
06:10:34 <DanMere34567> evening people, have a quick question whats a nice GUI/window interface to use with haskell and windows that has some decent documentation thats fairly idiot proof?
06:10:34 <typoclass> t7: sure
06:10:40 <dmwit> merijn: That's an awfully funny-looking type.
06:10:43 <merijn> t7: Any character except / and NUL is allowed in unix filesystem
06:10:50 <merijn> dmwit: Well, it's part of a larger signature
06:10:53 <trotro> merijn, / is forbidden ?
06:11:03 <dmwit> DanMere34567: What GUI library do you already know? Use the Haskell bindings to that.
06:11:15 <Saizan> merijn: measure?
06:11:23 <dmwit> merijn: If it's an argument, perhaps "ordering".
06:11:23 <merijn> trotro: Yes, because it's the directory separator
06:11:30 <typoclass> trotro: yes, it separates directories and afaik can't occur in file names or directory names
06:11:34 * byorgey likes 'measure'
06:11:43 <DanMere34567> dmwit: i dont know any GUI library i just used to use the terminal output.
06:11:46 <trotro> it's a sham
06:11:52 <trotro> i would have authorize / in filename
06:12:12 <merijn> dmwit, Saizan: basically I have a wrapped Map that uses "Ord k => a -> k" to provide mappings for unmappable types a
06:12:35 <dmwit> DanMere34567: In that case, I recommend either gtk2hs or wxHaskell. Since you're on Windows, be sure to read the installation instructions carefully -- it can be a bit tricky if you try to do it blind.
06:12:38 <merijn> typoclass: There's no difference between file names and directory names, they're the same thing
06:12:50 <b__> anyone familiar with criterion?
06:12:52 <b__> when I profile the same function twice (in one defaultMain) with criterion, the second test is always faster, can I avoid this somehow?
06:12:55 <typoclass> merijn: yes, i was just spelling it out for him
06:12:55 <DanMere34567> dimwit: thanks i will look into that.
06:13:15 <Jafet> b: faster by how much?
06:13:32 <b__> ~4%
06:13:53 <merijn> dmwit, Saizan: I had convert before, but I guess I like name better
06:14:10 <Jafet> That's small, a number of things could be causing it
06:14:12 <DanMere34567> just wanted to say this is the friendlest comunity i have seen. you guys have been great.
06:14:16 <typoclass> b__: it might relate to the binary file being present in the operating system's caches, or something like that. what happens on the 3rd, 4th, ... measurement?
06:14:31 <b__> typoclass, I will have a look
06:15:10 <ClaudiusMaximus> b__: also look at the --help output, there's some options relating to garbage collection
06:15:49 <ClaudiusMaximus> also make sure it's not cpu frequency scaling related
06:15:51 <b__> ClaudiusMaximus, will do, thanks
06:23:40 <DanMere34567> hmmm wxhaskell didnt install so it looks like it will be gtk2hs... weird so many of the librarys appear to be broken on windows.
06:25:13 <Philippa> unfortunately windows users're in a minority here to the extent that a lot of lib maintenance doesn't quite happen adequately
06:25:58 <hpaste> merijn pasted “ExistentialQuantification help” at http://hpaste.org/76403
06:26:29 <merijn> Any better way of writing that code or should I just parameterise Broker over k as well?
06:26:32 <Jafet> The effort to get foreign libraries working on Windows is usually not worth it
06:26:48 <DanMere34567> I see.. :(
06:27:45 <dmwit> DanMere34567: I have successfully installed the current release of gtk2hs on several GHC/gtk combinations in a Windows XP VM using the instructions at http://code.haskell.org/gtk2hs/INSTALL
06:27:56 <dmwit> ...not GHC 7.6 though
06:28:01 <dmwit> plan to work on that today
06:28:25 <typoclass> dmwit: awesome work, thanks a lot
06:29:46 <DanMere34567> dimwit: its bomed on cairo, gio, glib, pango.
06:30:22 <dmwit> "bomed"?
06:30:26 * hackagebot perm 0.2.0.0 - permutation Applicative and Monad with many mtl instances  http://hackage.haskell.org/package/perm-0.2.0.0 (AndySonnenburg)
06:30:28 <DanMere34567> it has failed to install
06:31:31 <dmwit> If you want help, you're going to have to give more details than that.
06:31:54 <dmwit> ?hpaste the commands you ran and the error you got, for example
06:31:55 <lambdabot> Haskell pastebin: http://hpaste.org/
06:32:22 <DanMere34567> ok 2 secs
06:32:35 <DanMere34567> internet is slow today. :)
06:33:29 <Polarina> mm_freak, is there a reason as to why you have two wire constructors, WGen and WPure instead of just WGen (and have pure wires use the Identity monad)? If it's performance, wouldn't some specialize/inlineable pragmas help solve that?
06:34:14 <DanMere34567> http://hpaste.org/76404
06:35:19 <dmwit> DanMere34567: Did you follow the install instructions I linked you to and told you at least twice were important to follow carefully?
06:35:57 <DanMere34567> yes i downloaded the all in one package
06:36:00 --- mode: ChanServ set +o dmwit
06:36:08 <DanMere34567> but i dont understand what its telling about %path%
06:36:32 <Polarina> mm_freak, not that this would affect the general user in any way. just curious here, as it seems that it could simplify the code somewhat by only having WGen. :)
06:37:09 <dmwit> DanMere34567: Okay. You'll need to learn how to set environment variables for your Windows version.
06:37:19 <dmwit> (Google knows how to do this.)
06:37:37 <DanMere34567> okey
06:38:35 <dmwit> One variable in particular (named PATH, or escaped as %PATH% in the shell) controls where the system looks for executables by default.
06:38:59 <DanMere34567> ok i will look for that infomation now.
06:39:32 <Philippa> Polarina: you can do a lot to help the inliner along if you can feed it a little extra static info
06:40:01 <Polarina> Philippa, like what kind of static info?
06:40:25 <KBme> quicksilver, is the a ghc 7.6 feature?
06:40:44 <Philippa> Polarina: well, in the limit? You can write your own optimiser and effectively let the inliner run it for you
06:41:20 <typoclass> DanMere34567: i'm not sure how it is on windows, but you may need to restart cmd.exe after changing %path%. you can verify that it worked by running the "pkg-config" command
06:41:43 <Polarina> Philippa, I'm not sure we are on the same page here. I'm refering to mm_freak's netwire library.
06:41:55 <quicksilver> KBme: no, it's standard haskell feature I think it's been in every version of GHC since the beginning.
06:43:08 <KBme> quicksilver, tells me parse error on as
06:43:15 <dmwit> typoclass: Environment variables are much more global in Windows than they are in Linux. You don't even have to restart the shell for them to take effect.
06:43:42 <quicksilver> KBme: what exactly did you write?
06:45:09 <typoclass> dmwit: death to microsoft! bill gates is an incompet... er wait, what? oh yes. ah. well done then. i'm always annoyed in linux when i need to restart everything and the dog for a change to take effect
06:45:32 <Philippa> Polarina: sure. Which I don't have the source to handy. But there's plenty you can do with an extra constructor that helps where pragmas won't
06:45:33 <Botje> have you tried turning the dogg off and on?
06:45:37 <Philippa> (case/ctor!)
06:45:41 <portnov> hi all.
06:45:43 <DanMere34567> dimwit: ok i will do that.
06:45:56 <Jetbeard> Botje, depending on your jurisdiction that can be illegal
06:45:58 <Jetbeard> (sorry)
06:46:19 <Polarina> Philippa, I have no doubt that that's the case. I'm just trying to learn and understand here. That's why I asked. :)
06:46:35 <dmwit> It's a tradeoff. You can't have processes with different environments with the Windows way.
06:47:07 <portnov> Deewiant: Q: why does Glob package has «directory < 1.2» dependency? Is it really incompatible with more recent versions of directory package?
06:47:46 <dmwit> A: This is the recommended way, according to the PVP.
06:48:06 <KBme> quicksilver, http://sprunge.us/SPYZ
06:48:13 <yitz> typoclass: on windows, every installation and its kid brother sticks stuff onto your path. and there's no "which" by default. so you never really know what you're going to get when you type a command. otoh, who types commands on windows anyway.
06:48:13 <byorgey> portnov: in actual fact, directory 1.2 did introduce some changes that broke a lot of packages
06:48:15 <dmwit> Bonus A: If it compiles and works correctly with newer versions of directory, the maintainer will almost certainly accept a patch relaxing the dependency.
06:48:31 <byorgey> no idea whether it affects Glob in particular.
06:48:34 <portnov> byorgey: ok...
06:48:38 <DanMere34567> sorry internet is on the blink here.. :)
06:49:32 <typoclass> portnov: if you want to try it, you could do "cabal unpack Glob", edit Glob.cabal to remove the "< 1.2", and then try "cabal build" and see if it compiles and works
06:49:52 <DanMere34567> just out of intrest, if you were going to build a machine just to develop haskell on what kind of specs would you go for? and what operating system?
06:49:59 <portnov> typoclass: thanks.
06:50:18 <typoclass> portnov: and what byorgey says, the maintainer will be grateful if you do that and tell him about it :)
06:51:12 <merijn> And once again I'm reimplementing "withJust :: Maybe a -> (a -> m ()) -> m ()" :\
06:51:17 <quicksilver> KBme: hmm looks like you were right the first time, sorry :)
06:51:26 <quicksilver> KBme: apparently the syntax is import qualified Data.ByteString as B(ByteString)
06:51:30 <Philippa> DanMere34567: what kind of budget?
06:52:01 <KBme> hmm
06:52:19 <Philippa> (so personally? Hand me a shiny new ultrabook, windows as host OS and I'll poke around virtualising various linux distros... many would go for one of the macbook pro range for similar reasons)
06:52:32 <typoclass> merijn: interesting, is it like "when (isJust ...)" ?
06:53:04 <DanMere34567> i see
06:53:19 <merijn> typoclass: Almost, yeah
06:53:22 <typoclass> Philippa: nothing can compete with a lenovo T61 with hello kitty stickers on it
06:53:49 <shapr> byorgey: I've not done anything with heroku, but maybe I should?
06:53:54 <merijn> typoclass: Essentially just "maybe (return ())" (possibly flipped, depending on context)
06:54:06 <byorgey> shapr: dunno, it seems shiny
06:54:21 <shapr> Hm, I do like shiny.
06:54:21 <fmap> I'd use `\v a -> v^!traverse . act a'?
06:54:25 <byorgey> shapr: you can run simple (e.g. 1 thread?) apps for free
06:54:35 <byorgey> not sure what the restrictions are
06:54:58 <DanMere34567> (silently wipes the tears away as I look at the intel core 2 duo sat on the desk lol..)
06:55:21 <typoclass> merijn: i see, thanks
06:55:31 <byorgey> shapr: so I got ghclive all built inside my shiny new Ubuntu VM under virtualbox (so I could compile it for heroku), but sadly it seems there are still too many bugs/annoyances to really use it in my class tomorrow =(
06:55:47 <shapr> byorgey: Aw :-( what are the bugs annoyances?
06:57:24 <byorgey> shapr: three main things, from least to most annoying: (1) having to explicitly import Prelude and Network.Web.GHCLive.Display (2) having to declare a Display instance for custom data types in order to use them, with no clear guidance on how to do that (3) sometimes (after errors? at random?) the shared document would get deleted
06:57:27 <merijn> typoclass: I frequently have things like "Maybe (Chan a)" or similar where you want to write to them if they exist, but just do nothing if not
06:58:06 <shapr> byorgey: I see your point.
06:58:22 <byorgey> shapr: though in reference to (3) I did sometimes notice messages like 'ghclive: writev: invalid argument (Bad file descriptor)', not sure if that's related or if it means anything to you
06:58:53 <shapr> That sounds like the file caching part failed, but I haven't seen that before.
06:59:08 * shapr adds issue 3 to the tracker
06:59:34 <byorgey> shapr: how difficult would it be to make an alternative version of ghclive that just uses plain old Show instead of Display?
06:59:48 <byorgey> for the purposes of my class I'd rather have it act as much like ghci as possible
06:59:57 <byorgey> although Display is certainly neat
07:00:04 * shapr thinks
07:00:14 <byorgey> if it's not hard I might just edit my copy locally
07:00:28 <byorgey> but of course (3) is really a showstopper.
07:00:44 <shapr> Right, deleting the buffer is bad.
07:01:45 --- mode: dmwit set -o dmwit
07:01:47 <shapr> I think you'd have to change the "as" type and remove most of Display.
07:02:06 <byorgey> so I won't be using it in class tomorrow (when I'm introducing Haskell for the first time) but may still use it later in the semester if we can get these issues worked out.
07:02:25 <byorgey> I'm happy to provide any info/run it in super-verbose debugging mode/whatever
07:02:31 <yitz> byorgey: tryhaskell?
07:02:54 <byorgey> yitz: no, that's for evaluating expressions only
07:02:54 <shapr> Trying to make a result type a typeclass instance makes for weird code. Luite had an odd solution, and then edwardk came up with something else.
07:03:00 <byorgey> I really need the facility to declare new data types
07:03:08 <yitz> ah i see
07:03:26 <edwardk> ?
07:03:36 <edwardk> oh, the display/show/extendeddefaulting hack
07:03:36 <yitz> byorgey: remember overhead projectors? they worked.
07:04:12 <byorgey> yitz: you mean like the kind where you put a transparent plastic sheet on the glass plate and drew on it with a sharpie?
07:04:14 <edwardk> you could probably make a button to toggle whether it used show or display
07:04:14 * dmwit bets that byorgey already has a pretty good backup plan
07:04:14 <mm_freak> Polarina: yes, that's true…  the WGen/WPure split is for performance and makes some internals more complicated and less beautiful…  but inlining/rules don't quite solve the halting problem =)
07:04:18 <yitz> yep
07:04:20 <portnov> http://hpaste.org/66460
07:04:25 <edwardk> e.g. a checkbox that while checked used only show
07:04:28 <portnov> are there any ideas how to fix that?
07:04:38 <byorgey> yitz: =)
07:04:38 <edwardk> or try to evaluate it with display and if that failed to typecheck try show
07:04:58 <byorgey> edwardk: yes, that would be a nice feature
07:05:17 <byorgey> ooh, a Show fallback would be perfect
07:06:30 <byorgey> anyway, I'm off to bleach the shower mat
07:06:44 * shapr blinks
07:06:49 <fmap> edwardk: I have a lens question. What's the official™ way to get [1,3] out of [(1,2),(3,4)]? I've came up with `[(1,2),(3,4)] ^.. traverse . _1', is there a nicer way?
07:07:17 <byorgey> that isn't code for anything
07:07:25 <strebe> fmap: I'd tend to map fst yourlist
07:07:26 <edwardk> thats probably the nicest way
07:07:38 <strebe> oh, lens - sorry, nevermind
07:07:39 <copumpkin> byorgey: you clearly haven't looked that expression up on urbandictionary
07:07:40 * yitz agrees with strebe
07:08:07 <copumpkin> yitz: you agree with the "nevermind"?
07:08:10 <edwardk> i too would just tend to map fst ;)
07:08:13 <fmap> strebe: for such a simple task sure, actual problem is a bit more complex
07:08:17 <yitz> no :) map fst
07:08:45 <edwardk> [(1,2),(3,4)]^..traverse._1 would do the trick
07:09:06 <edwardk> er rather but it would
07:09:30 <yitz> why have lenses become so arcane? it seemed like such an elegant idea at first
07:09:55 <edwardk> yitz: ^.. is asking for all the targets of a fold. traverse is a valid traversal, _1 is a valid lens
07:10:08 <edwardk> yitz: its just the use of a few common combinators
07:10:16 <edwardk> you don't have to use all the extra stuff
07:10:16 <dmwit> How come all names for tuple projection are so awful? _1, fst, car
07:10:29 <copumpkin> dmwit: what would you use?
07:10:31 <edwardk> i rather like _1, _2
07:10:49 <edwardk> they are short, mostly vanish in a . sequence and are self-explanatory
07:11:05 <copumpkin> where's my _73
07:11:10 <typoclass> dmwit: what is car, some lispish thing?
07:11:17 <strebe> typoclass: yes, car is head
07:11:17 <edwardk> typoclass: yes
07:11:23 <dmwit> copumpkin: I don't know. pi1 looks pretty awful, too.
07:11:26 <nand`> dmwit: π1?
07:11:31 <copumpkin> :P
07:11:35 <nand`> uh sorry
07:11:38 <nand`> π₁
07:11:39 <yitz> copumpkin: _--..._...--
07:11:40 <nand`> much better
07:11:42 <nand`> I use that in C#
07:11:49 <typoclass> strebe: hm, but head isn't a tuple thing, it's for lists
07:11:51 <copumpkin> dmwit: clearly the answer is to just take the index as a number, with dependent types
07:11:51 <dmwit> nand`: beautiful =)
07:12:01 <dmwit> copumpkin: Yes, that seems like the non-awful way.
07:12:24 <copumpkin> of course, even with dependent types, you'd need a witness that the index is even present in the type
07:12:34 <strebe> typoclass: it's not my example. :-) But it is still a name chosen for historical reasons of a particular machine architecture's instruction set mnemonics, iirc
07:12:35 <copumpkin> which could be computed on the fly with a decision procedure, and included implicitly
07:12:38 <dmwit> Which actually answers my original question: all projections are awful because the price you pay for beauty is dependent types.
07:12:51 <typoclass> strebe: i see
07:13:17 <strebe> typoclass: where it gets silly is in composition; cdr is tail, and it's common to have things like cadr and worse defined
07:13:56 <copumpkin> cadddr
07:14:11 <Philippa> cdr is tail because lisp doesn't actually have lists per se :p
07:14:15 <typoclass> cadderall
07:14:24 <yitz> [cr|addd|]
07:14:38 <b__> what would be the fastest way to get all indices with value True for a STUArray s Int Bool?
07:14:39 <nand`> byorgey: line width in diagrams-svg seems to be a bit funky, ‘lw 5’ sets it to what seems like 5 pixels, regardless of the end size
07:14:56 <nand`> so the default of 0.03 or whatever is rather indistinguishable
07:15:27 * hackagebot hs-pkpass 0.4 - A library for Passbook pass creation & signing  http://hackage.haskell.org/package/hs-pkpass-0.4 (VincentAmbo)
07:15:40 <nand`> not sure what the correct behavior is, but the example diagrams rendered with the cairo backend seem to have much more visible lines
07:22:09 <matthiasgorgens> What's the recommended way to get started with GUIs in Haskell?
07:22:49 <matthiasgorgens> wxHaskell?  or something else?
07:22:51 <dmwit> Do you know a GUI library from another language?
07:23:01 <matthiasgorgens> I've played around with some in Python, ages ago.
07:23:04 <matthiasgorgens> So just assume, no.
07:23:22 <dmwit> Okay, then wxHaskell and gtk2hs are the two top contenders.
07:23:25 <matthiasgorgens> ok.
07:23:27 <matthiasgorgens> thanks.
07:23:43 <matthiasgorgens> and actually, I'm more interested in creating some graphics, not so much in forms and stuff.
07:23:46 <matthiasgorgens> (though that's also helpful.)
07:23:53 <matthiasgorgens> is cairo the right way to go for that?
07:24:02 <dmwit> There are also bindings to qt, sdl, opengl/glut, and win32, which is why I asked if you were already familiar with something.
07:24:09 <matthiasgorgens> e.g. a typical small project would be visualizing a game of life.
07:24:25 <ClaudiusMaximus> i had some success with gtk-toy-diagrams
07:24:42 <dmwit> cairo is the way to go if you intend to include the graphics in a GUI; diagrams is the way to go if you only need something static.
07:25:01 <dcoutts_> cairo can also generate png, pdf and svg
07:25:21 <matthiasgorgens> thanks!
07:25:29 <dmwit> dcoutts_: Yeah, but diagrams is a better interface than cairo. =)
07:25:52 <ClaudiusMaximus> diagrams can be interactive! https://github.com/mgsloan/gtk-toy-diagrams ; and http://img72.imageshack.us/img72/8853/gtktoymultiplelinks.png i made with that
07:26:13 <byorgey> nand`: thanks for the report.  I created https://github.com/diagrams/diagrams-svg/issues/24 , feel free to add to that ticket if you have some concrete examples
07:26:36 <byorgey> ClaudiusMaximus: ooh, nifty =)
07:26:39 <ClaudiusMaximus> i also had some success with gtkglext for opengl stuff
07:27:11 <matthiasgorgens> oh, too bad.  gtk-toy requires base < 4.6
07:27:14 <ClaudiusMaximus> byorgey: quite some time ago...
07:27:15 <matthiasgorgens> and I've already upgraded.
07:27:43 <ClaudiusMaximus> oh, i heard recently that gtk2hs still fails to build with 7.6 (but i haven't checked personally)
07:27:51 <byorgey> it's true
07:27:52 <matthiasgorgens> ok, I'll try cairo, then. :o)
07:28:03 <dmwit> That's correct. There are some patches available on the mailing list that are supposed to fix that.
07:28:14 <nand`> byorgey: also, what's the most idiomatic way, given a point, to draw a line defined by a vector from this point?
07:28:23 <nand`> p ~~ (p .+^ v) ?
07:28:32 <dmwit> ...I should get off IRC now or I'll never get around to vetting them.
07:28:33 <dmwit> bye
07:28:35 <byorgey> nand`: yes, that's what I would do
07:29:13 <byorgey> nand`: feel free to make a combinator  p ~~^ v = p ~~ (p .+^ v)  or something and submit a patch =)
07:29:41 <nand`> I figured a named combinator would be best; so I can visualize vectors via something like unitx # scaleX len # fromPoint p
07:29:54 <byorgey> oh, sure, that's a good idea too
07:30:04 <byorgey> though 'fromPoint' seems a little vague
07:36:27 <matthiasgorgens> It's the parameterized form of the equation for a line.
07:36:59 <matthiasgorgens> (there are also unparameterized equations.  in 2-D, it would be a point plus a vector perpendicular to that line.)
07:37:38 <matthiasgorgens> (parameterized p v) might be better, but it's still vague.
07:39:29 <matthiasgorgens> the equation is something like <(x - p), v > = 0. where <,> is the inner product.
07:41:11 <nand`> byorgey: are infinite diagrams supported?
07:41:22 <nand`> for example, where the backend will cut off computation in the sub-pixel areas
07:43:40 <ion> dcoutts_: http://skillsmatter.com/podcast/home/cloud-haskell was really nice.
07:43:52 <dcoutts_> glad you liked it
07:45:07 <quicksilver> dcoutts_: will cloud haskell feature as a library which works with a future version of GHC? Or will it require compiler support outside of mainline?
07:45:51 <Cale> quicksilver: cloud haskell doesn't require special compiler support, and it's apparently available now
07:45:54 <ion> dcoutts: I wrote some test code with the old remote package, but it had some bugs with a linked process dying that seemed really difficult to resolve and i didn’t have the energy. Your implementation’s clearly better code quality and well-defined semantics is are promising.
07:46:19 <dcoutts_> quicksilver: it works right now
07:46:28 <quicksilver> Cale: surely the closure stuff needs some kind of support
07:46:29 * quicksilver looks
07:46:30 <dcoutts_> quicksilver: it's not tied to a version of ghc
07:46:31 <Cale> http://hackage.haskell.org/package/distributed-process-0.4.0.1
07:46:39 <quicksilver> seems to be TH
07:46:40 <Cale> quicksilver: Template Haskell magic :)
07:46:44 <quicksilver> I guess that's a kind of compiler support  :)
07:46:59 <dcoutts_> you could do the closure conversion by hand if you prefer
07:47:03 <ion> Well… whatever TH can do you can do manually. :-P (In this case, some pain may be involved.)
07:47:04 <byorgey> nand`: no, not currently
07:47:27 <dcoutts_> ion: well if you try with the new code, let us know
07:47:44 <dcoutts_> ion: whether or not you find bugs :-)
07:47:56 <quicksilver> I must find an excuse to try it.
07:48:00 <ion> dcoutts: Alright. I don’t have a project that could take advantage of CH right now, but perhaps some day. :-)
07:48:03 <nand`> byorgey: what does main = defaultMain (unitCircle # lw 2) -- render like for you, as .svg and with -w 500 ?
07:48:03 <quicksilver> dcoutts_++
07:48:34 <dcoutts_> quicksilver: there's two uses of TH, one would go away with a language extension, but the closure conversion still needs something.
07:48:39 <byorgey> nand`: sorry, don't have time to try it now, sounds like my son is awake
07:48:40 <hpaste> merijn pasted “Don't understand why this doesn't compile” at http://hpaste.org/76408
07:48:43 <nand`> byorgey: alright
07:48:53 <nand`> byorgey: well, I'll upload mine for comparison
07:49:00 <merijn> I'm not sure why the function composition version of that paste doesn't compile?
07:49:01 <byorgey> sure, thanks
07:50:28 * hackagebot http-reverse-proxy 0.1.0.3 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.0.3 (MichaelSnoyman)
07:50:48 <ClaudiusMaximus> merijn: the usual pain with Rank2Types being awkward
07:50:58 <ClaudiusMaximus> merijn: plus ghc special-casing ($), perhaps
07:51:19 <merijn> Bla
07:51:28 <ClaudiusMaximus> merijn: at least in Hugs I had to convert   foo = runST $ do ...   to foo = runST (do ... )
07:51:45 <quicksilver> merijn: right. (.) can only compose rank 1 functions.
07:51:52 <quicksilver> haskell polymorphism doesn't scale to rank N
07:52:01 <quicksilver> if in doubt, for rank N, it's best to "just use" application.
07:52:06 <quicksilver> there is a hack for ($)
07:52:23 <merijn> This took me so long to find :(
07:52:26 <quicksilver> although I had some vague memory the hack worked for (.) in some cases.
07:53:26 <merijn> quicksilver: Yeah, at some point the code worked using (.), but then after some changing things it suddenly broke and I spend more than half an hour manually tracking the types only to find out that it should work >.>
07:53:38 <merijn> Then accidentally discovering $ fixed it
07:53:41 <ClaudiusMaximus> relatedly, is Rank2Types the way to go for this or is some other way better? http://hpaste.org/76392 -- spent hours on it...
07:53:46 <nand`> does it work if you add type signatures?
07:53:50 <ClaudiusMaximus> ..and got type levels miles long
07:53:50 <nand`> on line 12
07:53:53 <ClaudiusMaximus> *errors
07:54:05 <nand`> for example, (mask_ . forkWithUnmask :: ....)
07:55:28 * hackagebot keter 0.3.1 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.1 (MichaelSnoyman)
07:58:11 <byorgey> nand`: ah, yes, that is definitely wrong
07:58:22 <byorgey> the SVG output with lw 2 I mean
07:58:41 <quicksilver> nand`: I don't think type signatures alone will make (.) work
07:59:00 <quicksilver> nand`: although I think with type signatures you *can* define a special purpose higher-rank (.) for a particular case, if it's a common one
08:00:25 <sp3ctum> i notice when I use getChar in a loop (recursive function) that I get two characters. is there a better way to do this? i think the first one is the character the user inputs and the second a newline..
08:00:47 <quicksilver> that sounds like line-buffering
08:01:05 <quicksilver> if you turn off line-buffering then you'll get each character as soon as it is typed, not waiting for the newline
08:01:14 <quicksilver> @hoogle hSetBuffering
08:01:14 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
08:01:14 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
08:02:04 <sp3ctum> ah, I'll try. thanks
08:04:27 <sp3ctum> yes, it works. but does not integrate to emacs, although that is likely a problem of emacs + ghci integration. thanks!
08:05:03 <quicksilver> well not really emacs + ghci per se
08:05:07 <quicksilver> more comint
08:05:27 <Sculptor> hi!
08:05:29 <quicksilver> but if comint wasn't in line mode it wouldn't be able to intercept your normal emacs key bindings
08:05:35 <quicksilver> so C-x b would be send to your program
08:06:05 <quicksilver> maybe there is a clever emacs solution but I'm not aware of it
08:06:51 <sp3ctum> now that you mention it, i've used line/character buffers for different shells in emacs
08:07:02 <sp3ctum> "buffer" in a loose sense
08:09:39 <bitrust> I have a bare install of GHC 7.6.1 and want cabal-install, can't get it to install from bootstrap.sh, any hints?
08:10:18 <bitrust> I did manage to get cabal-install-1.16 but that version just seems to have all functionality as "not yet implemented", which is silly
08:12:54 <ion> dcoutts_: Erlang has per-process garbage collection AFAIU. I wonder if it would be useful for Cloud Haskell to have that, too?
08:13:09 <dcoutts_> ion: that's a much more radical change
08:13:14 <ion> yeah
08:13:25 <dcoutts_> since we're just using ordinary haskell threads
08:13:55 <dcoutts_> ion: but, this usage pattern should also give a heap pattern that is amenable to parallel collection
08:13:59 <bindy> I am trying to generate haddock for my local hackage server and I cannot figure it out. I don't understand how hackage-build works, it just always creates build-cache directory. Is that it? Should I point hackage to that directory or is hackage-build supposed to upload docs to my hackage directly? Please, anyone solved this?
08:14:01 <dcoutts_> and ghc does have a parallel gc
08:14:21 <ion> forkIOSeparateGCNoSharingReally :: IO () -> IO ThreadId :-P
08:15:09 <dcoutts_> bindy: honestly I don't know, I've not yet looked at the build client. Yes the mechanism is that they're uploaded to the server, but I don't know if the build client does that directly or if it's a separate script.
08:15:28 <dcoutts_> bindy: could do worse than to take a look at the code for that client, it's just one file
08:15:47 <dcoutts_> ion: but it's also a major RTS change, that's the big thing
08:16:39 <bindy> dcoutts_: I see, thanks for the info!
08:16:49 <ion> dcoutts_: Yeah, i realize that.
08:19:20 <dcoutts_> bindy: let me know how you get on. I'm working on getting the hackage server ready for deployment.
08:19:31 <bitrust> Anyone has cabal-install with GHC 7.6.1? Without platform
08:22:17 <ClaudiusMaximus> bitrust: i still have my cabal binary from before upgrading my other machine from 7.4 to 7.6, not sure if i tried cabal install cabal-install yet though
08:22:21 <bindy> dcoutts_: ok, I will. I have a few notes while I was trying to install the hackage server (like missing dependencies versions, etc). I will try to write it down and put somewhere online, so it can be helpful for others.
08:25:12 <KirinDave> If I want to do a lot of primality testing on Integers very fast
08:25:20 <KirinDave> What's the right library to reach for?
08:25:32 <dcoutts_> bindy: or just send me a patch
08:25:39 <dcoutts_> bindy: and I'll apply it
08:26:13 <bitrust> ClaudiusMaximus: I'm trying to install cabal-install on a machine with just GHC 7.6.1. Failing so far.
08:26:29 <monochrom> magic_incantation_does_what_you_want_just_because_the_name_says_so :: a
08:26:34 <bindy> dcoutts_: ok
08:26:46 <KirinDave> I'm solving Project Euler 58 for fun
08:26:52 <KirinDave> And for some reason my solution takes like 20m to execute
08:27:01 <KirinDave> That's only testing like 40k primes, takes 20m.
08:27:17 <monochrom> 20 minutes sounds right for trial division
08:27:25 <KirinDave> And profiling suggests isPrime from ath.NumberTheory.Primes.Testing is the problem.
08:27:43 <KirinDave> Should I just leap to RM?
08:28:28 <monochrom> but where does ath.NumberTheory.Primes.Testing come from?
08:28:53 <KirinDave> arithmoi
08:30:08 <b__> I have a problem with unsafeRead, where I am quite sure that I am within bounds, but it still silently fails
08:30:11 <hpaste> b__ pasted “Atkin” at http://hpaste.org/76410
08:30:41 <monochrom> that algorithm isn't slow
08:30:41 <b__> on line 13, if I replace readArray with unsafeRead, I get silent fail
08:31:29 <KirinDave> A friend claimed to get his solution "checking for all the primes"  down to 4 seconds with C.
08:31:37 <KirinDave> So I'm like, "This problem is easy w/ haskell, I should be able to..."
08:32:00 <trotro> do you use an erathosthen seive ?
08:32:11 <b__> I am implementing sieve of Atkin, see link
08:32:14 <KirinDave> trotro: Project Euler 58
08:32:17 <KirinDave> So no.
08:32:30 <b__> it is getting close to the usual fastest Haskell sieve
08:32:37 <KirinDave> I'm not generating primes
08:32:41 <trotro> ho, iread 50
08:32:47 <b__> but I want to use unsafeRead
08:32:56 <b__> anyone familiar with its behaviour?
08:39:12 <KirinDave> Just wish I knew why this was so slow… https://gist.github.com/4ccf9b03591d9e390385
08:39:15 <KirinDave> 20m seems like a long time
08:39:26 <KirinDave> and the profiler suggests Math.isPrime is >80% of my time.
08:39:35 <KirinDave> And I sorta contorted to the code to allow for strict values everywhere
08:39:37 <__name__> Is there any deep reason why replicate takes Int and not Integer?
08:39:58 <Cale> __name__: no
08:40:04 <c_wraith> __name__: no.  Just a boring pragmatic one
08:40:07 <Cale> and it sucks that it takes Int
08:40:25 <hvr> Cale: but taking Integer wouldn't make it much better...
08:40:38 <c_wraith> __name__: mostly that if you pass a value to it larger than you can store in an Int, you'll probably never reach the end of the list in practical terms
08:40:48 <yitz> KirinDave: haven't looked at PE for years, but my records show that i solved that particular problem in under a minute (on a much older machine) without using any math libraries
08:40:57 <Cale> It's a premature optimisation which screws with correctness
08:41:02 <KirinDave> yitz: So i am missing a math trick?
08:41:21 <Cale> hvr: Integer *would* be much better
08:41:27 <yitz> KirinDave: that's almost always the case in PE if your method is going too slow.
08:41:40 <hvr> Cale: what about Data.List.genericLength
08:41:48 <hvr> Cale: what about Data.List.genericReplicate
08:41:58 <Cale> hvr: Generalising things to Num would be good too
08:42:12 <c_wraith> don't you really want Integral?
08:42:16 <KirinDave> yitz: Well, I am just confused why https://gist.github.com/4ccf9b03591d9e390385 would take _20_ minutes.
08:42:18 <c_wraith> you can't have a list of length 3.5
08:42:19 <Cale> (or Integral, yeah)
08:42:30 <hvr> well, that's what genericReplicate does...
08:42:47 <rwbarton> KirinDave, roughly how large is the output?
08:42:52 <Cale> hvr: I just want Int out of the Prelude
08:43:02 <DanMere34567> with printf how can i print a list?
08:43:25 <hvr> Cale: yeah, it find it cleaner if Prelude.replicate was actually genericReplicate
08:43:34 <Cale> It doesn't belong in the Prelude, it's something which ought to be imported from a module in those rare cases that you'd need it
08:44:38 <hvr> I'd be curious to know the history of the Data.List.generic* functions
08:45:01 <Cale> DanMere34567: I guess you can use %s and show the list?
08:45:27 <Cale> DanMere34567: printf kinda sucks for multiple reasons
08:45:38 <rwbarton> this sounds rather like "with regular expressions how do I parse HTML"
08:45:46 <DanMere34567> cale: what i need is a pretty printing function
08:45:53 <Cale> Use show
08:45:57 <Cale> > show [1,2,3,4,5]
08:45:59 <lambdabot>   "[1,2,3,4,5]"
08:46:39 <Cale> Unless that's not how you want the list printed, in which case you should write your own function. There are libraries available for constructing sophisticated prettyprinters.
08:47:09 <Cale> http://hackage.haskell.org/package/wl-pprint-1.1
08:47:13 <Cale> is pretty good
08:47:25 <yitz> KirinDave: i think you are not counting correctly. isn't it the number of primes on the whole diagonal, not just the corners?
08:47:29 <DanMere34567> yea what i wanted to do was print a series of years across the screen then put the values from a list below them.
08:47:47 <geekosaur> printf is kinda a demo of how to do runtime parameter processing, it's not something I would want to use in practice
08:48:31 <DanMere34567> i have been getting frustrated with the printf function.
08:50:00 <rwbarton> KirinDave: oh. you are recomputing number of primes at a given layer for every square that contains it. making it O(n^2) isPrime calls when it should be O(n)
08:50:14 <DanMere34567> i think i will use the ansi terminal package i had to many problems trying to get the librarys of GUIs to work with windows lol. at least ansi terminal works out of the box. :D
08:50:44 <DanMere34567> nice wl-pprint just installed without a hitch :D
08:50:51 <ion> Hmm. I haven’t actually used <http://hackage.haskell.org/packages/archive/pretty/1.1.1.0/doc/html/Text-PrettyPrint.html> – can it generate the kind of a tabular layout DanMere is talking about?
08:50:56 <pingu> show [a,b,c]
08:51:02 <pingu> > show [a,b,c]
08:51:03 <lambdabot>   Ambiguous occurrence `a'
08:51:03 <lambdabot>  It could refer to either `L.a', defined at <local...
08:51:14 <pingu> > show [L.a,b,c]
08:51:16 <lambdabot>   "[4,b,c]"
08:51:31 <nand`> fund it: ‘diagrams’ for 2D Char matrices (generate and compose ASCII art and text documents)
08:51:34 <pingu> > show [L,b,c]
08:51:35 <lambdabot>   Not in scope: data constructor `L'
08:51:39 <pingu> > show [L.*,b,c]
08:51:40 <lambdabot>   <no location info>: parse error on input `,'
08:51:50 * Clint squints.
08:51:54 <yitz> DanMere34567: how about generating html? or markdown? or csv?
08:51:58 <ion> Hmm. Is wl-pprint better than pretty?
08:53:02 <hirsch_> wouldn't it save zillions of brackets if the (.) operator would have a higher precedence than function application?
08:53:13 <monochrom> this is why I don't use a profiler. it can't tell if I'm using a slow algorithm
08:53:26 <DanMere34567> yitz: i was wanting it to be intreactive. but then i am very behnid with the whole HTML developement. I understand that its interactive now..
08:54:07 * yitz agrees with monochrom 
08:54:19 <nand`> hirsch_: you'd need just as many brackets for (f x) . (g y)
08:54:23 <nand`> if not more
08:54:37 <nand`> besides, it's confusing to read; f x . g y doesn't really read as f (x . g) y
08:54:50 <nand`> unless you'd write it as:  f x∘g y
08:54:52 <nand`> or something
08:55:06 <hirsch_> nand`: hmm, that's point
08:55:33 <rwbarton> the profiler would tell you how many times isPrime is called, you could notice it's much too high compared to the answer
08:55:45 <monochrom> hehe
08:56:32 <monochrom> actually my real reason is that -prof -O don't mix well
08:57:23 <ion> nand: Being used to Haskell’s precedence rules, f x∘g y *still* looks like (f x)∘(g y) to me.
08:57:31 <monochrom> -O kills some profiling information, -prof kills some optimizations. worst of both worlds
08:57:38 <DanMere34567> :( man why is the documentation for these librarys its like half the time rain man has written the user guide (if any)
08:58:04 <monochrom> which libraries are "these" libraries?
08:58:06 <nand`> ion: it's ambiguous for me. If I imagine ∘ binding tighter than application, I can read it sanely
08:58:59 <DanMere34567> pprint
08:59:01 <DanMere34567> for a start
08:59:05 <portnov> application always has most possible precendence.
08:59:25 <monochrom> there is no pprint package
08:59:52 * monochrom is tempted to say: so yeah, it's written by rain man
09:00:25 <Sculptor> by rain, man
09:00:30 <Sculptor> or by rainman?
09:00:36 <monochrom> both :)
09:00:38 <DanMere34567> example all i wanted to do was get a GUI so i could write the program, nothing would load on windows. the only thing that worked was the ansi terminal. (that a least had a demo file with it...) http://hackage.haskell.org/package/wl-pprint-1.1... theres no examples just a bunch of definitons.
09:01:20 <nand`> the library looks reasonably documented to me at a first glance
09:01:23 <nand`> every function has a description
09:01:42 <nand`> well, most
09:01:54 <parcs`> there's a reference to the paper it was based on
09:02:00 <parcs`> what more do you want?!
09:02:27 <DanMere34567> most languages have a tutorial, that have example files so a beginer can play with it..
09:02:53 <DanMere34567> not just a list of definitions.
09:03:02 <parcs`> oh dear wl-pprint defines (<$>)
09:03:05 <nand`> the importance of tutorials and examples rises that more complex the library becomes, imo; for a single module I can understand not having one
09:03:05 <monochrom> ok I'm bowing out of this. too many questions raised, and I'm not sure which question you really want answered
09:03:17 <nand`> parcs`: it also uses <> and ‘empty’ but doesn't make Doc an instance of Monoid -- what?
09:03:27 <nand`> and yes, it's associative and empty is the identity
09:03:31 <rwbarton> it was written in the 90s
09:03:45 <DanMere34567> ok thanks for your advice.
09:03:45 <parcs`> wl-pprint is bad
09:03:48 <parcs`> don't use it
09:03:58 <nand`> so there's the first conflicting opinion :P
09:04:43 <b__> any math wonders willing to take a look at my first try at implementing the sieve of Atkin? http://hpaste.org/76410
09:05:04 <DanMere34567> what i liked about haskel was i was able to input lots of data with next to no time... but after i got the data into the program I realised I had no GUI framework..
09:05:10 <DanMere34567> haskell.
09:05:11 <DanMere34567> lol.
09:05:35 <nand`> “input lots of data with next to no time”? O.o
09:05:43 <nand`> you many lazy I/O?
09:05:45 <nand`> mean*
09:06:07 <DanMere34567> the program has 2,000 lists.
09:06:11 <DanMere34567> at the moment.
09:06:20 <monochrom> I don't understand why GUI and wl-pprint are in the same question
09:06:35 <dmwit> dcoutts: Send my compliments to whoever added --only-dependencies to cabal install.
09:06:44 <dcoutts_> you're welcome
09:07:17 <KirinDave> rwbarton: Yeah I told my wife as I walked in
09:07:25 <KirinDave> "I forgot haskell doesn't memoize pure functions the way it does IO actions"
09:07:29 <KirinDave> "I dread opening IRC"
09:07:33 <KirinDave> Dog walks: ideas shake loose
09:07:57 <nand`> I don't understand what a ‘GUI framework’ is, personally
09:08:03 <DanMere34567> monochrome: i wanted first to make a window interface for my program. after I couldnt get that to work, I figured I would just go old school and use a dos window.. so in the end i was left with ansi terminal. but realy I would like to use the data to generate charts that i can display on the screen from the data.
09:08:44 <yitz> DanMere34567: first generate the numbers. then worry about the pretty charts
09:08:49 <monochrom> wl-pprint does not produce charts. not even text-mode charts
09:08:52 <DanMere34567> nand: i want a nice window, where i can show charts based on the data sets the program has, let the user manipulate the data sets then generate charts from that data set.
09:09:03 <parcs`> generate a csv file and then load it through libreoffice
09:09:16 <yitz> DanMere34567: you are on windows. excel does a very good job of that.
09:09:19 <dmwit> Man. You just spell everyone's nick wrong.
09:09:25 <monochrom> haha
09:09:29 <dmwit> nand -> nand`, monochrome -> monochrom, dimwit -> dmwit
09:09:51 <srhb> I'd argue that he's spelling them right.
09:09:54 <srhb> :-)
09:09:57 <hiptobecubic> srhb, you'd be wrong :)
09:10:07 <dmwit> okay, srha
09:10:18 <monochrom> how to spell srhb right?
09:10:21 <DanMere34567> hmmm havent thought about that.
09:10:27 <srhb> Unpossible.
09:10:33 <dmwit> sarahbee
09:10:40 <srhb> Close.
09:10:54 <hiptobecubic> Señor Habeeb?
09:11:11 <parcs`> lol
09:11:24 <ion> I can’t seem to make a multicolumn layout with wl-pprint-extras. Perhaps it doesn’t support that or perhaps i’m just not familiar enough with it. The closest i got was (putDoc . fillSep . map (align . vcat)) [[pretty "foo", pretty 42], [pretty "bar", pretty 0], [pretty "baz", pretty "?"]]
09:11:30 <dmwit> I cheated; you told me what srh was before some time.
09:11:40 <dmwit> You probably told me what the b was for, too, but I forgot.
09:11:54 <srhb> I think it's in the /who anyway, so my stalker alarm didn't go off. :P
09:12:32 <monochrom> I don't think any pretty-printer has multicolumn in mind
09:12:33 <parcs`> ion: i don't think that's a design goal
09:13:41 <monochrom> pretty printer has always only meant: you have a long expression, where to break lines and add indentation?
09:13:47 <ion> Anyway, i was just looking out of curiosity; i’d most likely do HTML or CSV for what DanMere is asking.
09:14:09 <monochrom> and it's expression, math-like and code-like expression. not "data"
09:14:39 <nand`> DanMere34567: I'm not sure if Haskell is the best tool for that; as others have mentioned there are existing things like excel, libreoffice for exactly this task - of course maybe you want to generate the charts based on functions that you want to describe in Haskell. Maybe you could generate an ‘excel function’ from some sort of abstract representation of its operations? :)
09:14:58 <nand`> interesting project: reimplement excel in Haskell (think FRP)
09:15:03 <ion> monochrom: Yeah, i just saw things like hsep and vsep in the API and tried them to see exactly what they do. Not tabular layout, that’s clear. :-)
09:15:24 <hpaste> wmoss pasted “unsafeIOToSTM” at http://hpaste.org/76414
09:15:30 <rwbarton> ... oh. I was trying to figure out what "reoffice" was
09:15:41 <DanMere34567> yes what im wanting to do is generate functions in haskell and then generate the charts from that.
09:15:45 <nand`> monochrom: I think pretty-printers could be allowed to do things like draw ‘text diagrams’ for trees and stuff
09:15:51 <ion> I mean, it would be totally plausible for some API to result in a table with something like hsep . map vcat
09:16:10 <dmwit> ?quote ncalexan
09:16:10 <lambdabot> ncalexan says: Getting fed up with Haskell and picking up another language is like swapping your Greenpeace spouse for an abusive tyrant.  Boy, does vegan sound good after beatings.
09:16:17 <DanMere34567> alough that would be a great project to make a spreadsheet in haskell. but i think its a bit beyond my ability.
09:16:19 <wmoss> I'm trying to use unsafeIOToSTM and I know it has various restrictions about not holding any fds, etc. Is this okay? http://hpaste.org/76414
09:16:35 <ion> unsafeIOToSTM launchMissiles
09:16:41 <wmoss> ion: I know :(
09:16:53 <wmoss> I'm trying to track down something where I think I'm retying forever
09:17:06 <ion> wmoss: Does Debug.Trace.trace work?
09:17:21 <dmwit> wmoss: No, printing inside a transaction isn't really okay.
09:17:24 <wmoss> ion: I think it does, but I'm not sure it's safe
09:17:34 <dmwit> wmoss: However, your transaction can return a message to print (or even an IO action that does the print itself).
09:17:38 <wmoss> dmwit: is there any way to do it at all?
09:17:47 <DanMere34567> ahhh you people! giving me a crazy idea like a basic spreadsheet in haskell now i cant think about my orignal project. lol! hahaha.
09:17:48 <ion> It’s obviously not safe, but you’re only using it to debug, right?
09:17:52 <strebe> DanMere34567: there are haskell tutorials, and haskell books that gently introduce the language; a lot of them. See http://www.haskell.org/haskellwiki/Haskell - there are links to learning resources, books, and tutorials
09:17:57 <monochrom> nand`, there are many kinds of text diagrams for trees, and pretty printers won't do most of them
09:18:09 <wmoss> ion: true, but from here: http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/GHC-Conc.html#v:unsafeIOToSTM
09:18:23 <wmoss> "The STM implementation will abort transactions that are known to be invalid and need to be restarted. This may happen in the middle of unsafeIOToSTM, so make sure you don't acquire any resources that need releasing (exception handlers are ignored when aborting the transaction). That includes doing any IO using Handles, for example. Getting this wrong will probably lead to random deadlock
09:18:25 <wmoss> s."
09:18:41 <wmoss> so I'm trying to print w/o using IO handles...
09:18:53 <monochrom> there is one kind where the root is on top, horizontally centered, and its children are horizontally underneath. pretty printers don't do that
09:18:57 <merijn> wmoss: print (by definition) uses a handle inside
09:19:01 <wmoss> although I'm honestly not 100% sure what that means in the context of Haskell :-/
09:19:20 <dmwit> merijn: He's not using print.
09:19:26 <wmoss> merijn: right, which i why I was using fdWrite...figuring it maybe just dumped to C and was safer?
09:19:28 <monochrom> there is one kind where the root is on the left, vertically centered, and its children are vertically on the right. pretty printers don't do that
09:19:43 <rwbarton> it probably is safer
09:19:51 <wmoss> safer being defined as safe inside an unsafe statement :-/
09:20:06 <strebe> DanMere34567: and there are ways to chart in haskell; you might like http://hackage.haskell.org/package/Chart
09:20:19 <monochrom> finally, what pretty printers do: the root is at top left, children are vertically on the right
09:20:34 <C0d3r_> Hello
09:20:41 <DanMere34567> strebe: ah yes i found that but the problem is i cannot get it to install on windows.
09:20:43 <ion> > let loeb x = fmap ($ loeb x) x in loeb [ do a <- (!! 1); b <- (!! 2); c <- (!! 3); return (unwords [a, b, c]), const "Spreadsheet", const "in", reverse . (!! 4), const "lleksaH" ]
09:20:45 <lambdabot>   ["Spreadsheet in Haskell","Spreadsheet","in","Haskell","lleksaH"]
09:20:55 <strebe> DanMere34567: are you using cabal?
09:21:06 <DanMere34567> strebe: yes.
09:21:06 <rwbarton> oh that's where "leksah" comes from
09:21:07 <C0d3r_> Does anyone know how to sort a list from high to low? (opposite of the sort function)
09:21:13 <dmwit> ?hackage boxes can do some of those other variants, monochrom
09:21:13 <lambdabot> http://hackage.haskell.org/package/boxes can do some of those other variants, monochrom
09:21:18 <monochrom> after you think about it a bit, you realize that the pretty printer is treating the tree as a math expression, and just adding line breaks and indentations to that math expression
09:21:26 <Eduard_Munteanu> :t sortBy
09:21:26 <nand`> monochrom: I'm not sure what you mean by “pretty printers” in this context. To me, a pretty printer for α is fundamentally simply a function α -> String; which is totally plausible to generate something that, when printed out, would format a horizontally centered tree or whatnot
09:21:27 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
09:21:30 <wmoss> and nobody knows if there's something else "safer" for writing to stderr inside stm?
09:21:40 <strebe> DanMere34567: what's the error?
09:21:57 <Cale> wmoss: It's safer not to write to stderr inside STM
09:21:58 <obiwahn> how good is haskell as production language? i wonder because running the lamdabot is not always easy for me as soon as i get a new ghc i have to pary that it is still working
09:22:00 <Eduard_Munteanu> C0d3r_: either use sortBy, or reverse the list you get from sort.
09:22:02 <dmwit> I'm with nand`.
09:22:02 <DanMere34567> cairo and the other things will not install.
09:22:16 <wmoss> Cale: If you can figure out why my program is retying forever, I'm happy to stop doing it
09:22:19 <dmwit> DanMere34567: As before, if you want help, you have to give more details.
09:22:21 <C0d3r_> Aha okay thank you
09:22:23 <monochrom> pretty printer means what those "how to write a pretty printer" papers mean
09:22:37 <obiwahn> i have no big clue about haskell i have used it a bit but never wrote a real program.
09:22:38 <nand`> okay. then there was some miscommunication going on, I never even read those papers
09:22:40 <wmoss> otherwise, I'm going to try to debug my problem and the only tool I know in this are is printing
09:22:48 <nand`> obiwahn: depends on how well you write your programs, really
09:22:52 <nand`> and also how large they are
09:23:03 <nand`> but most importantly, how maintained; things change
09:23:06 <Cale> wmoss: Well, fair enough. You could also try Debug.Trace.trace, but that's similar.
09:23:06 <monochrom> yeah, never trust names
09:23:07 <obiwahn> nand`: is lamdabot a especially bad example?
09:23:14 <strebe> DanMere34567: go to http://hpaste.org/ and paste all the error messages you get when you try to install chart
09:23:17 <nand`> I don't think lambdabot is maintained that well
09:23:28 <Cale> nand`: It doesn't have a maintainer
09:23:37 <nand`> there you go
09:23:37 <obiwahn> is there something like c99 or c11
09:23:47 <companion_cube> c11 both exist
09:23:50 <companion_cube> -c11
09:23:51 <nand`> obiwahn: there's Haskell 98, which is a standard that you can expect to be fairly universal among Haskell implementations
09:23:54 <DanMere34567> strebe: ok will do.
09:23:59 <dmwit> wmoss: The other standard tactic is to try to make a minimal testcase that still dies. It's sometimes (always?) easier to spot bugs by inspection in minimal testcases.
09:24:03 <monochrom> if you're a category theorists, and you go into ##java and say "I haven't checked out what you mean by objects, to me objects mean..." it is not going to be fun
09:24:05 <nand`> there's also Haskell 2010, which is a fair bit more recent/powerful but less supported
09:24:06 <obiwahn> a haskell standard that is fixed so i can run the bot without caring much for changes?
09:24:24 <strebe> monochrom: but amusing
09:24:34 <wmoss> dmwit: true...and we tried...
09:24:38 <merijn> monochrom: Depends how you define fun :D
09:24:41 <monochrom> someone should try. please tell me so I can go watch!
09:24:47 <wmoss> we have a program that seems to deadlock on stm every two weeks or so
09:24:48 <obiwahn> nand`: does hgc support it?
09:24:57 <obiwahn> a recent one
09:24:58 <ion> monochrom: That would be fun to watch indeed.
09:25:01 <nand`> by hgc you mean ghc?
09:25:02 <wmoss> so it's rare and hard to reproduce :-/
09:25:12 <obiwahn> yes sorry:)
09:25:22 <merijn> obiwahn: GHC supports both Haskell98, Haskell2010 plus multiple extensions
09:25:29 <Cale> wmoss: are you sure it's proper deadlock?
09:25:30 * hackagebot file-location 0.4.5 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.5 (GregWeber)
09:25:37 <nand`> yes ghc is the de facto standard compiler and has, to my knowledge, the most implemented language extensions among haskell implementations
09:25:42 <dmwit> wmoss: (It's almost certainly a livelock, not a deadlock.)
09:25:44 <nand`> including all of haskell 98, haskell 2010 and a fair bit more
09:26:05 <Cale> wmoss: A deadlock in STM would be a compiler bug.
09:26:16 <Cale> (or STM-implementation bug, to be more precise)
09:26:18 <wmoss> Cale: true true
09:26:21 <wmoss> I misspoke
09:26:32 <dmwit> Cale: ...or using unsafeIOtoSTM incorrectly. ;-)
09:26:35 <nand`> the problem with libraries and updating GHC is twofold: 1. dependencies on ghc libraries that underwent an API change; 2. upper bounds on dependencies that are too strict
09:26:36 <Cale> haha
09:26:54 <wmoss> livelock indeed
09:26:54 <wmoss> well, I'm not using it yet :)
09:27:00 <wmoss> that's why I came here for help
09:27:10 <matthiasgorgens> cale, would a lone "retry" be classified as a lifelock?
09:27:15 <Cale> wmoss: So probably your STM actions are making "progress" overall, but shorter transactions are trampling a big important one?
09:27:19 <dmwit> matthiasgorgens: no
09:27:32 <dmwit> matthiasgorgens: A lone "retry" is not live. =)
09:27:35 <nand`> take GHC 7.6.1 for example; a lot of bundled-with-GHC libraries got their version bumped up and API changed, usually in minor ways, so every library had to be updated for the new version and API
09:27:45 <nand`> eg. Data.Bits.Bits no longer has a Num superclass constraint
09:27:47 <Cale> I guess you could have a transaction which is unsatisfiable
09:27:54 <monochrom> I don't know what's livelock. in fact I'm pretty sure people don't agree on what's livelock
09:27:55 <Cale> which is kind of like deadlock, in a way
09:28:06 <wmoss> Cale: Eventually it seems to be completely hosed. strace just showes it just doing FUTEX_WAIT which is what happens on a retry, I think
09:29:20 <Cale> monochrom: Well, perhaps, but my definition of livelock would be where you have one or more transactions which would complete, but are never able to because by the time the transaction is ready to commit, other processes in the system have written to the things they read.
09:30:20 <wmoss> Cale: right :) I'm pretty sure that's what we're doing
09:30:45 <wmoss> We have a lot of contention on one TVar...all the transactions are small but there are a lot of them
09:31:07 <wmoss> so usually it's fine, but every once in a while it seems they all manage to get in sync just enough to lock each other
09:31:31 <wmoss> honestly, I'm guessing I starting writing things out of stderr and that provides enough jitter that this never happens again
09:31:41 <wmoss> which will be unsatisfying, but I guess solve my problem
09:32:13 <Cale> It would be nice if STM provided some other functions STM a -> IO a
09:32:18 <obiwahn> is "real world haskell" a book a beginner should read?
09:32:37 <monochrom> probably not
09:32:50 <t7> whats it called when i write a report on the  requirements for something?
09:32:53 <C0d3r_> obiwahn
09:32:56 <t7> researching it too
09:33:03 <dmwit> matthiasgorgens: (A little less snarkily: a thread with "atomically retry" in it will be handed an exception and garbage collected.)
09:33:04 <C0d3r_> a good starter is learnyouahaskell
09:33:12 <monochrom> I now recommend the sequence: LYAH, then The Gentle Introduction. and then, maybe RWH if you need
09:33:42 <DanMere34567>  strebe:http://hpaste.org/76415
09:33:55 <Cale> It's too bad that YAHT stopped being updated
09:34:00 <strebe> can anyone think of a desktop application with at least a few handfuls of users in haskell, a gui, which runs cross-platform? I've glanced around but it's hard to tell much from package names
09:34:03 <obiwahn> C0d3r_: i had a lecture on functional programming. where haskell was used as example.
09:34:11 <Cale> strebe: xmonad?
09:34:15 <monochrom> t7: "requirements document" or "requirements specification"
09:34:22 <Cale> strebe: oh, I guess that's not cross platform
09:34:36 <obiwahn> C0d3r_: they showed us that there are monads but did not in depth description on them
09:34:44 <Cale> strebe: There's ThreadScope, if all you're looking for is a self-serving example :)
09:35:21 <strebe> Cale: hmm. I was thinking something that uses a graphics toolkit of some sort. I do use xmonad, and I've partially read the code, but I'd like to have an idea how much pain I'd be in for if I tried to write an end-user app in haskell to run on various major platforms
09:35:35 <obiwahn> C0d3r_: i think i got a basic idea of how haskell works
09:35:39 <Cale> strebe: I haven't tried Nymphaea on anything other than Linux, it has approximately zero users, and the GUI code isn't terribly clean, but it might be a reasonable example.
09:35:41 <monochrom> strebe: manatee, but I'm not sure whether it's cross-platform
09:35:53 <rwbarton> how many users does leksah have?
09:35:59 <Cale> Oh, yeah, leksah
09:36:17 <Cale> Shouldn't it be lleksah?
09:36:18 <Eduard_Munteanu> preflex: seen ManateeLazyCat
09:36:19 <preflex>  ManateeLazyCat was last seen on #haskell 94 days, 23 hours, 45 minutes and 58 seconds ago, saying: How about OCaml? I want to try it.
09:36:29 <rwbarton> guess manatee is written in ocaml now
09:36:30 <obiwahn> but i/o and anything related to monads is still a bit strange
09:36:35 <Eduard_Munteanu> :)
09:36:50 <Cale> Maybe that was too Welsh
09:36:57 <Cale> -sounding
09:37:20 <monochrom> IO is strange because no one listens to my IO story
09:37:31 <Cale> Your IO story?
09:37:46 <obiwahn> is there a good introduction to monads something that does not only tell me how to use them but gives me a bit more theory than staying it is needed to keep the rest of the language functional
09:38:12 <monochrom> "getLine :: IO String" does not mean "returns String". (clearly, "hGetLine :: blah -> IO String" returns IO String, not String)
09:38:13 <Cale> obiwahn: It's not really needed to keep the rest of the language functional
09:38:22 <Cale> obiwahn: That's a lie :)
09:38:47 <strebe> obiwahn: for instance, there's a list monad, but lists are functional
09:38:47 <monochrom> "getLine :: IO String" means, when used in "getLine >>= callback", the callback is called with a String
09:38:52 <obiwahn> so io could still be done without monads?
09:38:56 <ion> trace seems to work nicely at least in this test. λ> do v <- newEmptyTMVarIO; atomically ((trace "can i has debug?" <$> tryReadTMVar v) >>= maybe retry return) `concurrently` (threadDelay (10^6) >> atomically (putTMVar v 42))
09:39:07 <Cale> obiwahn: Yes, but you'd still have some values which correspond to IO actions.
09:39:09 <trotro> IO String means an action that will produce a string one day, maybe
09:39:10 <trotro> :)
09:39:14 <Clint> i'm doing I/O without monads right now
09:39:27 <trotro> unsafePerformIO ?
09:39:28 <strebe> obiwahn: http://sigfpe.blogspot.ch/2006/08/you-could-have-invented-monads-and.html might be a useful read for you
09:39:35 <ion> clint: What do you use to combine two IO actions?
09:39:47 <Cale> obiwahn: The fact that IO happens to be a monad just says a little something about the API which is provided for combining IO actions.
09:40:09 <Clint> ion: who said i had more than one IO action?
09:40:09 <obiwahn> when you use soem kind of action for io you use the concept of moands?!
09:40:17 <Cale> no
09:40:39 <Cale> In order for IO actions to become a monad, you need two things:
09:40:52 <strebe> DanMere34567: see http://stackoverflow.com/questions/5336865/cant-install-cairo-with-cabal-on-windows-how-to-get-pkg-config-on-win
09:40:56 <Cale> 1) A way to take any value and turn it into an IO action which produces that value as its result
09:41:01 <Cale> i.e. return :: a -> IO a
09:41:02 <Eduard_Munteanu> An alternative to monads for IO is linear types.
09:41:15 <Eduard_Munteanu> But that's not something Haskell does.
09:41:33 <ion> wmoss: See my comment about trace above.
09:41:34 <Cale> 2) A way to take an IO action producing some result of type a, and a function from values of type a to further IO actions with results of type b,
09:41:39 <b__> any math wonders willing to take a look at my first try at implementing the sieve of Atkin? http://hpaste.org/76410 General advice is also awesome.
09:41:57 <Cale> and chain these together in the obvious way into an IO action whose overall result has type b
09:42:13 <monochrom> I feel that asking fore more theory at this stage is premature. Piaget's theory. concrete before abstract. special before general. use IO first. use list comprehension first. use Maybe first. use Int -> (a, Int) first. then, maybe you'll be ready for the theory
09:42:19 <tac-tics> Are there any papers that discuss how to implement IO in a simple compiler?
09:42:39 <Cale> obiwahn: Having those two things tells you almost nothing about what I/O you can actually do
09:42:44 <Cale> obiwahn: right?
09:42:58 <Cale> obiwahn: and as it happens, there are lots of monads which have nothing to do with I/O
09:43:03 <Eduard_Munteanu> FWIW, this doesn't seem bad: http://en.wikipedia.org/wiki/Monad_(functional_programming)
09:43:03 <matthiasgorgens> obiwahn: you could do IO with linear typing (also called uniqueness typing) instead of Monads.  Clean uses that approach.
09:43:20 <obiwahn> i have to reread the 3 laws and bind and foo :)
09:43:25 <typoclass> monochrom++
09:43:29 <obiwahn> i have falshes from memory:)(
09:43:29 <Eduard_Munteanu> I thought uniqueness typing was a subset / a particular kind of linear types.
09:43:45 <tac-tics> If Clean is the only language that uses uniqueness types, and no one uses clean, then who uses uniqueness types? :P
09:43:46 <matthiasgorgens> Eduard_Munteanu: you probably now that stuff better than I do. :o)
09:43:49 <matthiasgorgens> it's been a while for me.
09:44:02 <wmoss> ion: I think trace works...
09:44:11 <matthiasgorgens> now -> know.
09:44:11 <wmoss> the issue is that ghc might abort the transaction whenever
09:44:17 <wmoss> and if it aborts inside trace
09:44:22 <wmoss> something terrible can happen
09:44:30 <wmoss> anyway, I've got to hop off the train
09:44:32 <wmoss> be back in a bit
09:44:32 <Cale> obiwahn: The really important thing that we're doing, which is separate from the monadic interface here, is separating the process of evaluation (i.e. reducing expressions to their values) from execution (i.e. carrying out the effects described by values of a certain type or types)
09:44:34 <wmoss> thanks for all the help!!
09:45:37 <Cale> obiwahn: That's what keeps evalution sane to think about -- the only visible thing that *evaluation* does is heat up your CPU and produce a result of the type that's specified.
09:45:41 <Eduard_Munteanu> But even with Clean's approach, they could probably still use monads.
09:45:48 <Cale> Eduard_Munteanu: indeed
09:46:03 <Cale> It's hard to avoid a system in which you can define an IO monad somehow.
09:46:04 <matthiasgorgens> cale, plus using memory.
09:46:11 <Cale> at least, once you have first class functions
09:46:12 <matthiasgorgens> Eduard_Munteanu: yes, clean could still use monads.
09:46:17 <Eduard_Munteanu> I mean, I found myself wanting monads in Erlang, so I guess that holds for Clean as well. Perhaps as a way to neatly pass the unique world parameter around?
09:46:20 <matthiasgorgens> and you can implement an IO monad on top of clean.
09:46:43 <Cale> obiwahn: Does that help?
09:47:00 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO  is a quick tutorial which gives you the basic details
09:47:02 <matthiasgorgens> one of the early papers about monadic IO talked about different approaches (e.g. linear typing) and how they relate to each other and to monads.
09:47:03 <dmwit> ion, wmoss: The fact that trace works when you try it once on a single thread with two transactions does not imply it will work in general.
09:47:20 <obiwahn> I remebmer that i have palyed with maybe but got very confused about it .. may you are right and i should go ahead and use it without thinking to much and then try to grasp the theoretical consturct
09:47:20 <dmwit> I have no idea whether fdWrite is safe or not, but trace almost certainly isn't.
09:47:32 <clahey> Am I wrong, or is (Const a) a functor?
09:47:39 <matthiasgorgens> dmwit: an introspection of the trace code (and the stm transaction aborting code) might be enlightening.
09:47:48 <matthiasgorgens> but it's probably not safe.
09:47:52 <Cale> obiwahn: It does this by introducing the monadic operations for IO without actually generalising them to arbitrary monads, because you really don't need to understand monads in general just to do IO.
09:47:56 <clahey> Oh, it is, there's the definition.
09:48:04 <matthiasgorgens> clahey: (Const a) can't be a functor.
09:48:10 <matthiasgorgens> clahey: at least not if you are paranoid.
09:48:21 <Cale> obiwahn: The best way to understand monads is first to just use about 10 of them.
09:48:23 <matthiasgorgens> oops, I mean pedantic.
09:48:37 <Eduard_Munteanu> obiwahn: I'd start looking at Maybe's definition as a monad
09:48:43 <Cale> obiwahn: Well, minimally, I think you could get by with a parsing monad, IO, and the list monad.
09:48:51 <matthiasgorgens> (oops, I read (const a), not Const a.)
09:48:58 <matthiasgorgens> What's Const?
09:49:02 <clahey> matthiasgorgens: Why not?
09:49:03 <Cale> If you understand those three, then you might have some chance of understanding the abstract definition.
09:49:12 <matthiasgorgens> (lower-case) const a is a value.
09:49:17 <dmwit> matthiasgorgens: type Const a b = b
09:49:19 <dmwit> roughly
09:49:21 <Cale> (without imposing too much extra structure from your imagination)
09:49:26 <dmwit> but with more newtype noise
09:49:35 <clahey> dmwit: No, type Const a b =
09:49:35 <Eduard_Munteanu> dmwit: don't you mean Const a b = a ?
09:49:36 <clahey> dmwit: No, type Const a b = a
09:49:42 <matthiasgorgens> dmwit, would newtype Const a b = a be better?
09:49:49 <watermind> what do you usually use to denote some generic binary operator, when defining higher order functions, if you want to use infix notation
09:49:56 <matthiasgorgens> yeah, that should be a (trivial) functor.
09:49:59 <Cale> obiwahn: A lot of people who try to understand what monads are tend to impose a lot of extra constraints which aren't really there, and end up describing something more complicated.
09:50:14 <matthiasgorgens> basically, isomorphic to newtype Trivial a = Trivial
09:50:22 <Polarina> :t (>>=)
09:50:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:50:37 <ion> newtype Const a b = Const a  (needs a data constructor)
09:50:37 <Cale> obiwahn: There's very very little which all monads have in common, and it's really just the two operations return and (>>=), (and the laws)
09:50:44 <watermind> e.g. if you want to define fold (*+*) e xs = ...     (*+*) look terrible...
09:50:52 <matthiasgorgens> watermind: in mathematics, we used to use a circle.
09:50:59 <matthiasgorgens> but I don't know about Haskell standard.
09:51:00 <watermind> matthiasgorgens: I know :S
09:51:07 <matthiasgorgens> or Haskell idioms.
09:51:08 <watermind> matthiasgorgens: I was trying to avoid unicode
09:51:29 <obiwahn> :) Cale the little things keep the world together :)
09:51:31 <Cale> watermind: Maybe * if it doesn't involve multiplication
09:51:39 <rwbarton> can use `op`
09:51:55 <matthiasgorgens> cale, it might be more enlightening, to talk about how Functors, Pointed Functors, Applicative (Pointed) Functors and Monads relate.
09:52:03 <watermind> Cale: I think it may be confusing to use pre defined arithmetic operators
09:52:10 <matthiasgorgens> and also to define Monads in term of fmap, return, ap and join.
09:52:12 <watermind> rwbarton: that's what I'm using right now actually
09:52:18 <Cale> watermind: depends on the length of the definition, I suppose
09:52:22 <Cale> @src on
09:52:22 <lambdabot> (*) `on` f = \x y -> f x * f y
09:52:22 <matthiasgorgens> (ap isn't really necessary, if you have fmap and join, if I remember right.)
09:52:33 <Cale> ^^ that's pretty cute, for instance.
09:52:58 <matthiasgorgens> compare `on` f = comparing f
09:53:00 <matthiasgorgens> doesn't it?
09:53:07 <Cale> yes
09:53:16 <watermind> Cale: yeap
09:53:21 <watermind> that is true
09:53:23 <matthiasgorgens> I never really liked comparing, since the on version seems more general.
09:53:43 <rwbarton> compare`ing`
09:53:50 <Cale> matthiasgorgens: I invented comparing before people generalised it to on
09:54:06 <matthiasgorgens> and I learned on first. :o)
09:54:11 <clahey> matthiasgorgens: I don't see how, since you can easily define fmap and join for Const a, but ap doesn't quite work.
09:54:31 <matthiasgorgens> clahey, why?
09:54:37 <matthiasgorgens> :t ap
09:54:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
09:54:50 <watermind> clahey: if you have fmap and join and return you have a monad
09:54:58 <clahey> Okay.  I'm wrong.
09:55:06 <watermind> clahey: you can get the bind from join and return
09:55:12 <watermind> clahey: always
09:55:17 <john_r_watson> @pl (\a -> if (f a) then (a:) else id)
09:55:17 <lambdabot> flip (liftM2 if' f (:)) id
09:55:35 <matthiasgorgens> john_r_watson: I'd use <$> and <*> instead of liftM2
09:55:36 <clahey> watermind: If you don't mind my asking, what is its form?
09:55:47 <john_r_watson> matthiasgorgens: sounds good
09:56:00 <john_r_watson> matthiasgorgens: what's if'?
09:56:06 <matthiasgorgens> @source if'
09:56:07 <lambdabot> if' not available
09:56:08 <watermind> clahey: actually you get bind from join and fmap, and of course you need return to have a monad
09:56:10 <Cale> matthiasgorgens: I think it's a little bit sad that "equating" just isn't the right term for ((==) `on`), and there doesn't seem to be a good word for that.
09:56:14 <matthiasgorgens> john_r_watson: it's a functional version of if.
09:56:25 <Eduard_Munteanu> You don't even need return to get (>>=).
09:56:38 <john_r_watson> matthiasgorgens: gotcha
09:56:42 <Eduard_Munteanu> x >>= f = join (fmap f x)
09:56:43 <Cale> Perhaps  'matching'
09:56:47 <matthiasgorgens> Cale: it's comparing by projection.
09:56:48 <Cale> but that's weird
09:56:53 <rwbarton> @src ap
09:56:53 <matthiasgorgens> (or rather, equating by projection.)
09:56:53 <lambdabot> ap = liftM2 id
09:56:54 <SegFaultAX|work> Being sick /and/ at work is the worst.
09:57:00 <watermind> clahey: Eduard_Munteanu was quicker :P
09:57:07 <matthiasgorgens> :t if'
09:57:08 <lambdabot> Not in scope: `if''
09:57:28 <Cale> matthiasgorgens: well, "equating" doesn't mean "testing equality"
09:57:30 <SegFaultAX|work> Realizing you feel too crappy to work /after/ your 45 minute commute is just dreadful.
09:57:33 <clahey> And x :: Const a b  means  fmap f x = x
09:57:35 <matthiasgorgens> cale, yeah.
09:58:01 <watermind> clahey: also personally I find it way simpler to construct monads using join and return as primitives
09:58:08 <matthiasgorgens> rwbarton: ap is also <*>
09:58:11 <watermind> clahey: they are easier to understand and design
09:58:16 <trotro> sometimes join is more intuitive
09:58:22 <matthiasgorgens> SegFaultAX|work: move closer to work.
09:58:28 <Cale> SegFaultAX|work: I am so happy that my commute is only about a metre from my bed.
09:58:56 <watermind> trotro: is there any case where it is not?
09:58:57 <matthiasgorgens> watermind: Wasn't >>= chosen for efficiency?
09:59:03 <watermind> matthiasgorgens: I think so
09:59:09 <SegFaultAX|work> matthiasgorgens: I like living out in the Easy Bay (I work in SF). More sqft/$$$ etc.
09:59:13 <trotro> watermind, good question
09:59:14 <SegFaultAX|work> Cale: Lucku man.
09:59:18 <SegFaultAX|work> Lucky*
09:59:18 <clahey> So, what does Functor (Const m) mean?
09:59:20 <matthiasgorgens> pedagogically join is the better route.
09:59:48 <matthiasgorgens> clahey: in the context of an instance declaration?
10:00:20 <Deewiant> portnov: I haven't got around to updating Glob, I'll probably do it tomorrow
10:00:23 <dmwit> > let !3 = 3 in "hi"
10:00:25 <lambdabot>   "hi"
10:00:31 <dmwit> > let !3 = 4 in "hi"
10:00:32 <lambdabot>   "*Exception: <interactive>:3:4-9: Non-exhaustive patterns in pattern binding
10:00:34 <portnov> Deewiant: thanks!
10:00:51 <dmwit> > let 3 = 4 in "hi"
10:00:52 <lambdabot>   "hi"
10:00:57 <matthiasgorgens> SegFaultAX|work: I read a study about commuters.  (Can try to find it again.)  Yes, commuters get more space per currency unit, but that didn't compensate for the loss of happiness caused by the commute.
10:00:58 <matthiasgorgens> ;o)
10:00:59 <clahey> matthiasgorgens: I'm just an idiot.  I was reading the parens as function application, but of course, they're just grouping.
10:01:08 <matthiasgorgens> of course, everybody has to make that decision for themselves.
10:01:23 <Cale> matthiasgorgens: Whether join or (>>=) is the pedagogically better route depends on which examples you're considering
10:01:24 <matthiasgorgens> clahey: parens are always just grouping in Haskell.
10:01:34 <matthiasgorgens> Cale: Where is >>= better?
10:01:36 <Cale> (>>=) is a far more natural operation on monads of computations
10:01:50 <matthiasgorgens> Like continuation?
10:01:54 <Cale> join is a weird operation to consider on most computational monads
10:01:55 <Cale> yeah
10:02:03 <nand`> what keeps Haskell pure is reification of side effectual computations; not monads
10:02:13 <matthiasgorgens> it's not too weird, if you come from the fmap route.
10:02:26 <matthiasgorgens> if you motivate it right, your students will ask about the flattening.
10:02:30 <matthiasgorgens> (i.e. join.)
10:02:42 <nand`> I think ‘join’ is easier to implement for a lot of monads
10:02:54 <strebe> matthiasgorgens: do you have any lecture notes that motivate it right?
10:02:57 <matthiasgorgens> join's type is also easier to motivate.
10:03:06 <Cale> I'm thinking about examples like Parser
10:03:31 <matthiasgorgens> strebe: no.  never had a single haskell lecture in my life. :o) but "Learn you a Haskell for Great Good" goes that route, if I remember right.
10:03:45 <Cale> There's nothing wrong with join for Parser, but it's not the first thing you'd think about when implementing a parsing library
10:03:46 <matthiasgorgens> Cale: let me dig out my toy combinatorial parser.
10:03:53 <nand`> right
10:03:55 <strebe> matthiasgorgens: ahh, was just wondering since you said 'your students' :-)
10:03:55 <nand`> same for State etc.
10:04:06 <matthiasgorgens> I implemented that with bind.  Let me see, if it becomes easier (or harder) to understand with join.
10:04:06 <Eduard_Munteanu> (>>=) makes more sense for computations with side effects I think.
10:04:09 <Eduard_Munteanu> :t (>>=)
10:04:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:04:17 <matthiasgorgens> strebe: should have said "one's students".
10:04:21 <Cale> matthiasgorgens: It shouldn't be too bad, just a little funny to explain :)
10:04:30 <matthiasgorgens> strebe: I taught some Haskell to co-workers, though.
10:05:09 <Cale> Of course, you could motivate join for Parser by explaining how to implement (>>=) with it first
10:05:10 <Eduard_Munteanu> (>>=) takes a computation with side-effects and feeds the value to another computation combining the side-effects appropriately.
10:06:07 <Cale> (>>=) takes a computation producing some result, and a function from possible results of that first computation to further computations, and connects them together into a single computation
10:06:18 <matthiasgorgens> Cale: yeah.
10:06:40 <nand`> for monads where >>= does some sort of sequencing; (>>=) can be seen as ‘sequencing from left to right’; whereas ‘join’ does ‘sequencing from outer to inner’; which is a bit harder to visualize imo
10:06:51 <matthiasgorgens> cale, parsers are an excellent example, since they are something simple that actually gets easier with functional programming.
10:06:54 <Cale> I've often found it can help some people to see (>>) first
10:07:00 <matthiasgorgens> but I don't know, whether they are good as "your first monad".
10:07:32 <Cale> and then say "it kind of sucks that we threw away the result of that first computation though... wouldn't it be nice if that could influence the rest of what we were going to do?"
10:07:40 <matthiasgorgens> cale, Eduard_Munteanu, you should probably replace "computation" with thingy.  Since it might also be a container, or something more weird. :o)
10:08:12 <Cale> matthiasgorgens: computation and container are both good basically-generic-enough terms
10:08:17 <matthiasgorgens> (>>) doesn't need >>=, if you have ap?
10:08:31 <Cale> Every computation is a container in some sense, and every container is a computation in another :)
10:08:37 <matthiasgorgens> yes.
10:08:48 <matthiasgorgens> You should probably start with an excursion into group theory.
10:08:56 <Cale> Group theory?
10:09:12 <matthiasgorgens> once people see that the rubik cube (or rather its transformations) and numbers and lots of other things are groups,
10:09:17 <nand`> a sufficient monad tutorial starts with the definition of natural numbers
10:09:23 <matthiasgorgens> they might be able to grasp the abstractness of monads, too.
10:09:26 <Cale> hmm
10:09:49 <Cale> I'm not sure whether groups are an easier or harder abstraction to grasp
10:09:53 <matthiasgorgens> suppose Haskell would display groups prominently.  Then we would have the same "But, what _is_ a group?" questions as we have about Monads.
10:10:04 <Cale> But... aren't there lots of abstractions people should already know?
10:10:18 <Cale> I guess a lot of them are things which people don't think of as abstractions
10:10:20 <nand`> well, we have Monoids and Rings, where are the ‘what _is_ a monoid/ring’ questions?
10:10:22 <Eduard_Munteanu> Groups are arguably a bit more concrete.
10:10:23 <Cale> like the natural numbers
10:10:55 <matthiasgorgens> Eduard_Munteanu: since Monads are essentially half-groups, they are more concrete by default. :o)
10:11:10 <strebe> nand`: I had plenty of those, I just didn't ask :D
10:11:11 <matthiasgorgens> I mean, groups are more concrete.
10:11:15 <matthiasgorgens> since they have slightly more structure.
10:11:33 <strebe> nand`: but monads show up everywhere, even in hello world, hence the prevalence of questions, I suspect
10:11:40 <Cale> If monads was your very first abstraction to try to understand, that indeed might be tricky.
10:11:47 <nand`> groups do too, if you know how to look for them :P
10:12:10 <nand`> arguably, ‘Num’ (aka Ring) pops up often enough too
10:12:15 <strebe> nand`: but I don', and I presume most new haskell users don't either, and it doesn't show up in type signatures and all over basic tutorials
10:12:31 <Cale> matthiasgorgens: I think it's important that people already understand type classes
10:12:49 <Cale> matthiasgorgens: If they don't get Eq, then they're not going to get Monad
10:13:07 <nand`> there's still a step up to higher order types
10:13:29 <nand`> eg. people may be familiar with languages which have something similar to typeclasses but not for higher order types
10:13:54 <trotro> typeclass ? you're sopeaking about class ?
10:14:04 <nand`> oh, of course as you say, if they don't get Eq, they won't get Monad either
10:16:17 <Cale> trotro: yeah
10:17:17 <Cale> trotro: If you don't understand what classes and instances are about, you're not likely to understand what monads are about (unless you're an algebraic topologist or something and already know category theory, but that's cheating)
10:17:21 <matthiasgorgens> Cale: I agree.
10:17:30 <trotro> :D
10:17:42 <matthiasgorgens> So, Learn you a haskell handles that relatively well.  (I just browsed the book recently.)
10:17:53 <matthiasgorgens> It's too bad I don't remember how I learned that stuff first.
10:17:54 <qwr> trotro: typeclass is more like interface for overloadable functions, than a OO class
10:18:08 <matthiasgorgens> qwr: I guess trotro was just pseudo-trolling.
10:18:11 <trotro> qwr, i know what the keyword class do :)
10:18:11 <Cale> I didn't understand what monads were really about until I learned how to use Parsec.
10:18:13 <matthiasgorgens> i.e. making a joke.
10:18:22 <Cale> and then it all made sense :)
10:18:23 <trotro> i just want to be sure you were talking about that
10:18:36 <matthiasgorgens> understanding monad transformers can be a good benchmark.
10:18:50 <matthiasgorgens> because if you understand transformers, even only barely, you have to have understood monads.
10:18:51 <strebe> Cale: I still don't feel like I understand monads, frankly
10:18:53 <trotro> matthiasgorgens, those things are cool
10:19:03 <Cale> A good benchmark maybe, but I kind of think monad transformers are overplayed
10:19:09 <matthiasgorgens> oh, yeah.
10:19:18 <Cale> They're *much* less important than the tutorials make out.
10:19:19 <strebe> I can use them, in a pinch I can write them, but they're not something I really feel I grok
10:19:35 <Cale> strebe: Have you read Monads As Computation?
10:19:44 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
10:19:47 <nand`> I remember at the time LYAH introducing the ‘container’ analogy, but immediately stressing that it's a highly limited/flawed analogy; so I remember being fairly comfortable with that at the time (accepting it as a faulty analogy but using it to explore some of the operations monads support)
10:19:49 <strebe> Cale: I haven't, I shall now
10:20:02 <Cale> strebe: I'm not sure you'll be enlightened, but it might help
10:20:18 <Cale> strebe: especially the first and last bit
10:20:20 <trotro> monad are magical values, and bind  is a wonder trick :D
10:20:39 <trotro> magic wand, not wonder
10:20:51 <nand`> quite frankly, I still don't understand what a lax 2-functor from a terminal bicategory is
10:20:51 <Cale> The whole point of monads is to be able to write a fair handful of things which work in any monad, and not have to write those things for every monad.
10:21:07 <Cale> Things like sequence and mapM
10:21:21 <nand`> the whole point of abstraction*
10:21:27 <Cale> Apart from that, monads are just functional programming as usual.
10:21:41 <Cale> nand`: Well, I'm talking about the *specific* things in this case, but yes.
10:21:42 <strebe> Cale: it'll have to click eventually. At -that- level, I understand monads, but working with them still feels awkward, and I don't spontaneously think of good places to make/use them
10:22:00 <trotro> strebe, how ? i see monads everywhere
10:22:13 <Cale> strebe: Nor should you. If you're creating a new library, don't set out to create a monad.
10:22:25 <nand`> agreed
10:22:27 <Cale> But perhaps look to see if one is there.
10:22:31 <nand`> some of the best libraries I've worked with don't have anything to do with monads
10:22:33 <trotro> exceptions are a good example of monad :)
10:22:36 <strebe> trotro: they -are- everywhere, but I'm not seeing them, and this is why I say I do not understand them.
10:22:37 <Cale> and if so, then great, you get Control.Monad for free
10:22:43 <Cale> If not, no big loss
10:22:45 <nand`> look for free monads :P
10:22:49 <trotro> strebe, :D
10:23:17 <Cale> You might still have a functor or an applicative, or an Arrow, or just a monoid, or none of the above
10:23:22 <strebe> nand`: the more I look at haskell and category theory, the more the word free terrifies me ;-)
10:23:35 <Cale> There are lots of abstractions and not all of them are going to apply to everything we do :)
10:23:42 * strebe is still entirely unfamiliar with applicative
10:23:53 <Cale> As much as the OO people would like to believe that everything is an object.
10:23:57 <qwr> most useful monads seem to already exists in the mtl
10:23:58 <nand`> byorgey: does diagrams have any support for gradients or other more complicated fill patterns? I wonder if I could create an (accurate) visualization of colorspaces using only diagrams
10:24:05 <strebe> Cale: yes, for sure, but having a good understanding of those abstractions tends to make understanding other people's systems a lot easier, and my own nicer
10:24:18 <nand`> ideally with the background being filled according to some projection function to the colorspace the renderer lives in
10:24:27 <strebe> Cale: everything -is- an object in smalltalk, some things just make better objects than others ;-)
10:24:29 <Cale> strebe: That's true! You should become familiar with what it implies that you can do when something turns out to be a monad.
10:24:29 <nand`> but in a pinch I'll be satisfied with some 3-gradient
10:25:07 <nand`> clearly, everything is a function :P
10:25:13 <strebe> Cale: among other things, yes :-) I don't want to shoehorn the world into monads, but I do want to recognize when they fall out naturally
10:25:23 <Cale> strebe: The main things you want to know about are replicateM, mapM/forM, sequence, and the _ versions of those, as well as basic do-notation stuff.
10:25:48 <Cale> If you get those, they'll carry you a long way working with monads.
10:26:01 <nand`> strebe: free stuff tends to be left adjoint to forgetful functors
10:26:06 <strebe> Cale: I know mapM/forM (_) and do notation
10:26:25 <Cale> yeah, that's probably actually sufficient for most of it :)
10:26:30 <strebe> nand': 'adjoint' is another word that keeps popping up everywhere. I'm a little daunted by one of my books on category theory saying it doesn't go that far
10:26:33 <nand`> ‘sequence’ is nice too
10:26:47 <nand`> heck, a ton of combinators are
10:27:07 <nand`> Cale: I actually found monads not that useful for writing parsers personally
10:27:09 <Cale> There's really not a whole lot to the story of monads-in-general which is crucial, but there are lots of little things that you can pick up as you go.
10:27:28 <nand`> I'm not big on linguistics, is there some complexity class that needs monadic parsers?
10:27:31 <Cale> nand`: It's really comfortable to be able to name the results of subparsers sometimes.
10:27:43 <Cale> nand`: Monadic parsers are context-sensitive
10:27:46 <nand`> I guess so, but the vast majority of my parsing has been doing fine with applicative
10:28:01 <Cale> Yeah, you can usually encode most of the parsers you want to write using Applicative
10:28:03 <ion> Applicative is enough for most parsers, but not for something like do c <- anyChar; (c:) <$> many1 (char c)
10:28:09 <strebe> nand': haskell seems to nicely get rid of tons of boilerplate that I hate writing in other languages, and allow really nice abstractions - but it's also a huge collection of combinations of these abstract tools, and it takes a while to get used to
10:28:23 <ion> or n <- number; replicateM n item
10:28:24 <nand`> I usually parse stuff into an ADT, then reprocess that later on, so my constructors conform to the order and manner in which parsers appear
10:28:44 <nand`> for individual syntax elements
10:28:57 <Cale> nand`: Yeah, and so you naturally end up with a context-free grammar
10:29:00 <nand`> ion: fair enough, eg. length fields?
10:29:07 <nand`> Cale: yeah
10:29:25 * nand` still has “don't use length fields” drilled into his skull
10:29:30 <ion> nand: Anything whose parse result affects which parser should be used next.
10:30:10 <nand`> makes sense, since that's how monads differ from applicatives after all
10:30:17 <dmwit> Data.Encoding.ISO88592 is provided by Data/Encoding/ISO88592.mapping (which is expanded to an hs file by a custom preprocessor). "cabal sdist" complains: Could not find module Data.Encoding.ISO88592 with any suffix: ["gc","chs","hsc","x","y","ly","cpphs","hs","lhs"]
10:30:18 <Cale> (and not in a sort of way that you can easily encode by the disjunction of finitely many parsers)
10:30:21 <dmwit> wat do?
10:30:27 <ion> Like in IO, Applicative is enough if the result of an IO action isn’t needed to decide which action to run next.
10:31:01 <dcoutts_> dmwit: use ./Setup sdist in this case as a workaround (I think)
10:31:29 <dmwit> Oh, cool.
10:31:34 <Brax> does hlint suppress a lot of suggestions if it's used without options?
10:31:59 <kirindave> There we go
10:32:01 <kirindave> 0.20 seconds
10:32:03 <nand`> ‘x’, ‘y’, ‘ly’ ?
10:32:06 <kirindave> Thank you, car ride
10:32:13 <Brax> can't believe there is only on suggestion in a larger file with lots of excercises in it
10:32:17 <Brax> *one
10:32:26 <Brax> *exercises
10:32:28 <Brax> geez
10:33:14 <shachaf> kirindave: Sounds like a fast car ride, if you're approaching the speed of c.
10:33:25 <Cale> nand`: but even so, I find myself using a fair mix of the two styles when I write parsers. If you find yourself applying a lambda using <$> then do-notation might be clearer.
10:33:27 <kirindave> shachaf: Ha.
10:33:41 <kirindave> shachaf: I was just assuming pure functions are memoized in haskell because, as you know, I am not that bright.
10:33:50 <kirindave> shachaf: Was really bugging me.
10:34:01 <Cale> nand`: Of course, in your case, you'd arrange that everything you apply with <$> is a constructor, and then you have no problem :)
10:34:06 <kirindave> shachaf: But I had to write tPlus (!a,!b) (!c,!d) = (a + c, b + d)
10:34:15 <kirindave> And I was thinking, "I am surprised I have to write this function.
10:34:23 <kirindave> And then we nearly hit a bus.
10:34:23 <nand`> Cale: exactly; also using monadic parsers in an Applicative style is entirely possible too
10:34:30 <shachaf> > (1,2) + (3,4)
10:34:31 <Cale> nand`: right
10:34:32 <lambdabot>   (4,6)
10:34:45 <nand`> a lot of my Parsec use probably falls into that category
10:34:48 <monochrom> someone has to write this function
10:35:21 <dmwit> dcoutts_: Hm, the generated tarball includes both the .mapping file and dist/build/.hs file it generates; is that expected behavior?
10:35:27 <Cale> kirindave: In the vector-space package, you'll find a module called something.NumInstances
10:35:42 * shachaf doesn't recommend using NumInstances.
10:35:44 <Cale> kirindave: and it has an instance of Num similar to that (not sure about strictness)
10:36:24 <nand`> surely vector-space has actual vector spaces like ℝ² you could use too, no?
10:36:52 <dmwit> Anyway, it's good enough.
10:36:59 <kirindave> nand`: Well part of the goal was to make things pretty fast, so there are nice optimizations with eager tuples to be plucked.
10:41:12 <nand`> ADTs give rise to an algebraic interpretation of data types as the cardinalities of sets; with (*), (+) and (^) corresponding to (,), Either and Flip (->) respectively; how do GADTs transform this picture? What new algebraic interpretations do they add, or do they break the system altogether? There's probably a ton of SO answers on this that I may or may not have seen before
10:41:18 <nand`> so a link would be fine
10:45:05 <shachaf> Well, GADTs give you existential types and equality constraints, which are probably two things you can consider separately.
10:50:33 * hackagebot encoding 0.6.7 - A library for various character encodings  http://hackage.haskell.org/package/encoding-0.6.7 (DanielWagner)
10:53:40 <Brax> i get this from using hlint on a file of mine: "unexpected end of input while lexing quasi-quoter"...ok, it's a bug, but apparently one that is not fixed?
10:56:40 <Brax> file compiles ok
10:58:09 <Brax> if i comment it out, the error jumps to the next line
11:00:34 * hackagebot encoding 0.6.7.1 - A library for various character encodings  http://hackage.haskell.org/package/encoding-0.6.7.1 (DanielWagner)
11:01:48 <typoclass> Brax: i think something about TH's quasiquoters changed quite recently (this year?). maybe your hlint version is a few months old? or the hlint maintainer hasn't updated it yet
11:04:12 <Brax> i got it today
11:04:35 <Brax> 1.8.31 for cabal
11:08:58 <typoclass> brax: looks like a bug then :(
11:15:20 <byorgey> nand`: no, not yet, though adding support for that shouldn't be too hard. See https://github.com/diagrams/diagrams-lib/issues/9
11:15:35 <nand`> byorgey: excellent
11:20:10 <jfischoff> pcapriot`: how would I use setup optparse-applicative to parse the last argument as string, with no flag? I.e. : resize -o outputPath.png inputPath.png
11:21:48 <typoclass> jfischoff: as an 'argument'? https://github.com/pcapriotti/optparse-applicative#arguments
11:22:10 <jfischoff> typoclass: oh cool didn't see that
11:22:38 <nand`> byorgey: also, after reading through the tutorial and user manual, I feel fairly confident about the myriad of type abstractions that I'm exposed to as an end user, but what I'd be interested in is the workings and theory behind QDiagram and Backends
11:22:46 <typoclass> jfischoff: no worries :) i'm not familiar with optparse-applicative, but it seems reasonably similar to the other packages that parse command lines
11:23:09 <typoclass> (there seems to be a whole cottage industry of them)
11:23:53 <jfischoff> typoclass: yeah they all slightly annoy me
11:24:11 * typoclass giggles
11:24:14 <byorgey> nand`: sure.  for some of the theory, see my recent Haskell Symposium paper, http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf, video of my talk here: http://www.youtube.com/watch?v=X-8NCkD2vOw
11:24:17 * fmap is waiting for command line parser based on lens
11:24:22 <byorgey> nand`: but I do plan to write more about that in the user manual
11:24:25 <jfischoff> typoclass: one day I will make my own and return the favor :)
11:26:00 <nand`> byorgey: good to hear, I'll check them out
11:39:24 <t7> whats the name of the lines between vertices ?
11:39:41 <copumpkin> edges?
11:39:55 <n-dolio> Starring Tony Hopkins.
11:40:54 <sipa> edges indeed
11:41:44 <matthiasgorgens> Does aspect oriented programming make any sense?  Or is it just something that seems worthwhile in lesser languages?
11:42:44 <hiptobecubic> what does it even mean?
11:42:46 <S11001001> matthiasgorgens: it's pretty great for languages with bad support for composition
11:43:09 <anna29> how can I instal haskell on mac
11:43:14 <matthiasgorgens> wikipedia links to http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.25.8262
11:43:18 <trotro> haskell-platfrom anna29
11:43:23 <matthiasgorgens> "Monads as a theoretical foundation for AOP (1997)"
11:44:57 <matthiasgorgens> S11001001: thanks.
11:58:49 <strange_loop> hello
11:59:03 <strange_loop> does haskell have a string library/
11:59:17 <strange_loop> standard* string library?
11:59:33 <Eduard_Munteanu> strange_loop: hi, there is stuff in the standard library. What sort of things are you looking for?
11:59:36 <matthiasgorgens> strange_loop: bytestring comes closest.
11:59:38 <rwbarton> there's Data.List
11:59:44 <Eduard_Munteanu> :t "Hello"
11:59:45 <lambdabot> [Char]
11:59:51 <arcatan> also text
11:59:53 <Eduard_Munteanu> String = [Char]
11:59:55 <strange_loop> I want something like str.replace in python
12:00:01 <matthiasgorgens> lambdabot should use overloaded string literals. :o)
12:00:01 <trotro> :D
12:00:42 <strange_loop> Data.Bytestring is different from [Char] right?
12:00:44 <srhb> @hoogle replace
12:00:45 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments Replace :: TextureFunction
12:00:45 <lambdabot> Data.Text replace :: Text -> Text -> Text -> Text
12:00:46 <lambdabot> Data.Text.Lazy replace :: Text -> Text -> Text -> Text
12:00:50 <srhb> Hm
12:00:56 <rwbarton> that looks pretty promising
12:01:02 <matthiasgorgens> @source Data.Text.replace
12:01:02 <lambdabot> Data.Text.replace not available
12:01:22 <strange_loop> I dont have Data.Text in my haskell implementation :(
12:01:36 <matthiasgorgens> strange_loop: do you have the cabal installer script?
12:01:46 <strange_loop> nope
12:01:49 <matthiasgorgens> strange_loop: or first, do you use ghc?
12:01:59 <matthiasgorgens> what os are you on?
12:02:05 <rwbarton> are you using a computer?
12:02:08 <strange_loop> yeah I installed ghc and cabal using archlinux's pacman
12:02:21 <matthiasgorgens> strange_loop: arch-linux also has the cabal install script.
12:02:28 <strange_loop> ah
12:02:33 <matthiasgorgens> extra/cabal-install
12:02:50 <matthiasgorgens> extra/haskell-text
12:02:58 <matthiasgorgens> you don't need cabal install in this case,
12:03:06 <matthiasgorgens> because arch has haskell-text as a package, too.
12:03:15 <strange_loop> xlent
12:03:24 <matthiasgorgens> (cabal install is for installing packages from hackage.  but in general you should prefer the packages from your distro.)
12:03:31 <rwbarton> presumably arch also has a haskell platform package and text is in it
12:03:31 <strange_loop> so Data.Text is haskell's equivakent of std::string?
12:03:44 <matthiasgorgens> i used "pacman -Ss haskell text" to search for the package.
12:03:53 <matthiasgorgens> strange_loop: what's std::string?  is that c++?
12:03:57 <strange_loop> yes
12:04:04 <matthiasgorgens> I don't know enough C++.
12:04:09 <strange_loop> ah sry
12:05:20 <matthiasgorgens> do you know how to use hoogle?
12:05:32 <strange_loop> yes ^^
12:05:39 <matthiasgorgens> excellent.
12:05:45 <rwbarton> String and Text are the types for dealing with text (as in Unicode strings). String is a little more convenient, but inefficient
12:06:02 <matthiasgorgens> String is basically a linked list of characters.
12:06:04 <strange_loop> working with plain [Char] seems inefficient and clumsy
12:06:10 <matthiasgorgens> Text is an actual data type.
12:06:24 <strange_loop> thanks for teaching me Text ^^
12:06:41 <matthiasgorgens> strange_loop: it's not necessarily inefficient.  if you can fuse [Char] away, it's not there at all.
12:06:49 <srhb> strange_loop: Sort of. The standard Strings use singly linked lists, and are not very good for any sort of real string processing. Data.Text gives you that.
12:07:01 <matthiasgorgens> srhb: I guess you'll have to repeath that when strange_loop comes back.
12:07:19 <srhb> matthiasgorgens: Eh, I think I just had a huge network lag
12:07:43 <matthiasgorgens> http://hackage.haskell.org/packages/archive/text/latest/doc/html/Data-Text.html#g:3 (about fusion)
12:08:00 <matthiasgorgens> that should impress those C++ types. :o)
12:08:33 <zzzzzbogus> Hi, are there newtype wrappers on hackage to treat Alternative a and MonadPlus a as monoids? Couldn't find and it seems strange.
12:08:50 <byorgey> nand`: also, why aren't you in #diagrams ? =)
12:09:11 <loser> hello
12:09:21 <byorgey> hello loser
12:09:32 <loser> thanks for showing me Data.Text
12:09:48 <loser> Ill use it to solve the MIU puzzle
12:09:56 <matthiasgorgens> zzzzzbogus: hayoo searches through more stuff than hoogle.  have you tried that?
12:10:03 <matthiasgorgens> MIU?
12:10:24 <loser> http://en.wikipedia.org/wiki/MU_puzzle
12:10:34 <matthiasgorgens> thanks.
12:10:54 <matthiasgorgens> but don't you have to give a proof to solve that puzzle?
12:11:02 <rwbarton> you spoiled it!
12:11:06 <loser> ah sorry
12:11:22 <zzzzzbogus> matthiasgorgens: I don't know what to put in search string
12:11:32 <matthiasgorgens> zzzzzbogus: yeah, that's a problem.
12:11:46 <matthiasgorgens> (I couldn't think of something myself.  that's why my first reply was so vague. :o)
12:11:52 <loser> I want to use haskell to generate an infinite list of all possible theorems
12:12:09 <loser> and then test if MU is a valid thm
12:12:19 <rephorm> hi, i'm new to haskell and am trying to install pandoc via cabal. i'm having issues with version conflicts ("reinstalls", see log: http://pastebin.com/gbGGWBYX). Is there a way to resolve this?
12:12:23 <maukd> The paste gbGGWBYX has been copied to http://hpaste.org/76420
12:12:24 <matthiasgorgens> have you proven that the list is infinite? ;o)
12:12:35 <loser> yeah
12:12:42 <loser> rule 2 implies that
12:12:52 <matthiasgorgens> yes.
12:13:03 <shachaf> Proving the "of all possible" part is rather trickier than the "infinite" part.
12:13:44 <matthiasgorgens> shachaf: yeah, you'd need some fairness.
12:13:54 <matthiasgorgens> though honestly, I'd produce an infinite tree
12:13:55 <matthiasgorgens> not a list.
12:13:58 <loser> you can build a tree, starting with "MI", and recursively map all rules to the theorems
12:13:59 <shachaf> typoclass: You should introduce the MEOW puzzle.
12:14:08 <loser> growing the tree
12:14:12 <matthiasgorgens> yeah.
12:14:24 <cYmen> It is a bit of an assumption that this would be a good place to ask this question but here goes anyway: If I wanted to learn about the properties and intricacies of programming languages, what would be a good start?
12:14:42 <matthiasgorgens> cYmen: in general, or for any specific one?
12:14:46 <typoclass> shachaf: purr, purr
12:14:49 <trotro> cYmen, google :)
12:14:53 <loser> cYmen: maybe a course from http:/udacity.com or http://coursera.org
12:14:54 <cYmen> matthiasgorgens: in general
12:15:14 <matthiasgorgens> cYmen: learning about compilers sounds like a good step.
12:15:26 <cYmen> trotro: Most articles I turned up with google had a heavy bias towards some language
12:15:34 <loser> yep, coursera has a compilers class that began a couple weeks ago
12:15:47 <loser> they implement some toy language
12:15:52 <rwbarton> rephorm, that looks rather bad
12:16:00 <trotro> cYmen, you don't want to learn a specific one ? just want to learn programming ?
12:16:01 <rwbarton> rephorm, oh I see you are using 7.6
12:16:04 <rwbarton> yes?
12:16:09 <rephorm> rwbarton: yes
12:16:10 <matthiasgorgens> I liked "Modern Compiler Design".
12:16:17 <matthiasgorgens> and didn't like the famous dragon book at all.
12:16:22 <rephorm> rwbarton: should i be using an older ghc?
12:16:29 <rwbarton> it would probably be a lot easier...
12:16:34 <zzzzzbogus> matthiasgorgens: Got the monadplus part. It's Data.Semigroup.MonadPlus from reducers package
12:16:37 <matthiasgorgens> cYmen: I assume you know how to program?
12:16:37 <shachaf> rephorm: I don't think pandoc is compatible with 7.6 as it is.
12:16:45 <shachaf> Or maybe pandoc's dependencies.
12:16:54 <shachaf> At any rate *something* wants containers-0.4, which is a bad idea.
12:17:14 <cYmen> I already know programming and several languages but the differences seem so huge that I'm intrigued by the general concepts and theoretical background.
12:17:15 <rwbarton> how can we fix this
12:17:30 <rephorm> shachaf: thanks. i didn't see any warnings about ghc versions on pandocs site. i can downgrade (i don't use haskell for anything else, yet)
12:17:44 <matthiasgorgens> cYmen: Modern Compiler Design by Grune, Bal, Jacobs and Langendoen is interesting.
12:17:50 <shachaf> rephorm: GHC 7.6 is pretty new -- some things haven't been updated yet.
12:18:03 <rwbarton> yeah, you will have a much easier time with 7.4 then
12:18:14 <matthiasgorgens> SICP is also worth a look.  they talk about different paradigms in the later chapters.
12:18:22 <shachaf> Of course, someone ought to be fixing pandoc or whichever of its dependencies is being problematic.
12:18:24 <n-dolio> matthiasgorgens: Modern Compiler Implementation in <language>? Or something else?
12:18:31 <cYmen> matthiasgorgens: yeah, sicp was great
12:18:49 <cYmen> http://www.amazon.com/Modern-Compiler-Design-D-Grune/dp/0471976970 isn't even that expensive
12:18:51 <zzzzzbogus> thank you edward kmett for all those nice things :) Data.Semigroup.Alternative is there too
12:18:57 <n-dolio> Oh, I see.
12:19:12 <edwardk> zzzzzbogus: you're welcome ;)
12:19:23 <matthiasgorgens> http://www.cs.cmu.edu/~jcr/tpl.html is also good.  if a bit heavy going.
12:19:38 <matthiasgorgens> n-dolio: what CYmen linked.
12:19:47 <n-dolio> Yeah.
12:19:51 <matthiasgorgens> (I just didn't want to single out Amazon. ;o)
12:20:10 <cYmen> matthiasgorgens: thanks
12:20:27 <cYmen> that should keep me busy for a while :)
12:20:49 <cYmen> loser: and thank you for reminding me of coursera
12:20:59 <JuanDaugherty> @hoogle "cabal package hell"
12:20:59 <lambdabot> Parse error:
12:20:59 <lambdabot>   "cabal package hell"
12:20:59 <lambdabot>   ^
12:21:03 <shachaf> Someone should write a book about "programming paradigms" called _Types of Programming Language_.
12:21:20 <matthiasgorgens> or Kinds of Programming Languages?
12:21:21 <JuanDaugherty> that was for you rephorm, google that
12:21:30 <loser> I think Lisp is the ultimate programming language
12:21:36 <matthiasgorgens> loser: nope.
12:21:36 <rwbarton> he is not in hell, just an alternate timeline
12:21:37 <Cale> Did anyone mention SPJ's book?
12:21:38 <matthiasgorgens> but it's cool.
12:21:44 <loser> where we can explore all other paradigms
12:21:48 <JuanDaugherty> @hoogle cabal package hell
12:21:49 <lambdabot> No results found
12:21:56 <shachaf> SPJ's book is good but I don't think it's the sort of thing cYmen is looking for?
12:21:58 <matthiasgorgens> Cale: no.  SPJ's book is good, but it focusses on one specific paradigm.
12:22:12 <matthiasgorgens> @google cabal package hell
12:22:14 <lambdabot> http://www.yesodweb.com/blog/2012/03/cabal-nirvana
12:22:14 <lambdabot> Title: Avoid cabal hell: find nirvana
12:22:28 <matthiasgorgens> On Lisp is also a great book.
12:22:33 <matthiasgorgens> but also focusses on one language.
12:22:46 <loser> so the name of Haskell's stdlib is Hackage?
12:22:46 <Cale> Yeah, I probably missed the context of this discussion.
12:23:08 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/ -- but if you want to understand how to implement functional programming languages, this is a nice read.
12:23:15 <merijn> @quite twb on.lisp
12:23:16 <lambdabot> Maybe you meant: quit quote
12:23:21 <matthiasgorgens> loser: Lisp is great, especially it's flexible syntax.  but semantic wise is quite boring by now: a family of (mostly) dynamically typed, non-pure strict functionally-flavoured languages.
12:23:22 <merijn> @quote twb on.lisp
12:23:23 <lambdabot> twb says: I liked _On Lisp_, but it should have been called _Dirty Things I Did With Macros_
12:23:40 <matthiasgorgens> loser: not really.  Hackage is probably something like CPAN (in the perl world).
12:23:43 <loser> ah
12:24:09 <matthiasgorgens> Cale: if you want to know how to implement _lazy_ functional languages _efficiently_.
12:24:09 <Cale> Calling Common Lisp a "functional programming language" is actually a bit of a stretch for me.
12:24:17 <shachaf> Cale: *Lazy* functional programming languages.
12:24:23 <rwbarton> lisp is -- get this -- a list processing language!
12:24:31 <shachaf> @quote monochrom lisp
12:24:32 <lambdabot> monochrom says: in retrospect, it seems lisp designers were more interested in list processing than functional programming
12:24:35 <matthiasgorgens> rwbarton: not really.
12:24:48 <trotro> i though it was to try lambda calcul
12:24:53 <matthiasgorgens> they have plenty of other data structures.
12:24:55 <Cale> A list processing language with a shitty list library that never seems to have the operations you want
12:25:05 <matthiasgorgens> trotro: they didn't really know what they were doing back then. :o)
12:25:08 <matthiasgorgens> it was all new.
12:25:08 <Cale> Okay, maybe that's mean :)
12:25:21 <loser> Lisp also seems advanced for being as old as COBOL
12:25:28 <matthiasgorgens> it's older than cobol.
12:25:35 <matthiasgorgens> it's basically as old as FORTRAN.
12:25:44 <matthiasgorgens> only Plankalkul is older.
12:25:46 <trotro> lisp is great, because you can easily embeded it in a software
12:25:51 <trotro> and learn lisp is quick
12:25:55 <trotro> it's simple
12:26:04 <matthiasgorgens> I'd rather embedd Forth. :o)
12:26:13 <Cale> trotro: Well, depends on what you mean by "lisp"
12:26:23 <matthiasgorgens> yeah.  common lisp is huge.
12:26:26 <Cale> If you mean "scheme" then yeah.
12:26:28 <trotro> something with ( words and ')
12:26:38 <trotro> something with few keywords
12:26:48 <Cale> Then Common Lisp doesn't really fit
12:26:53 <trotro> maybe it's scheme
12:27:05 <matthiasgorgens> modern scheme's have gotten pretty big, too.  like Racket.
12:27:15 <trotro> i already know camllight before encounter lisp so...
12:27:28 <matthiasgorgens> https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours is fun.
12:27:55 <matthiasgorgens> (though not recommended for the weak-of-heart beginner.)
12:27:59 <srhb> matthiasgorgens: I wish someone would rewrite that but "ok, now we use all of Haskells bells and whistles" to be able to see the difference
12:28:09 <shachaf> "I could do this with recursion, but since I'm doing this in Haskell, I'd like to understand the monads. The State Monad is probably the best for this job, I suppose?" :-(
12:28:29 <trotro> list monad is the best to understand monad
12:28:30 <srhb> shachaf: SO is hard.
12:28:31 <merijn> shachaf: Ouch :(
12:28:38 <merijn> shachaf: This hurts my brain
12:28:40 <trotro> and MAybe too
12:28:52 <shachaf> srhb: Are you that Sarah person?
12:29:01 <matthiasgorgens> trotro: It's best if you just meditate over the formal definition. :o)
12:29:01 <srhb> shachaf: Possibly.
12:29:05 <merijn> srhb: You mean GADTs+DataKinds wizardry? :p
12:29:12 <srhb> merijn: YES! :D
12:29:17 <merijn> Potentially some RankNTypes stuff
12:29:17 <trotro> matthiasgorgens, to understand the magic it's one of the best
12:29:17 <srhb> merijn: I'd love to see it.
12:29:30 <trotro> there is also the non existing Random monad
12:29:31 <merijn> srhb: Hmm, maybe I should do that in my copious spare time
12:29:40 <matthiasgorgens> trotro: a simple combinatorical parsing monad is also good.
12:29:50 <srhb> merijn: That sounds like a brilliant idea, I'll flattr you a horrible Danish pilsner for the effort ;)
12:29:56 <matthiasgorgens> you see the magic, and you see something where monads are actually better than naive imperative programming.
12:29:57 <trotro> matthiasgorgens, it's a special case of a state/list monad
12:30:04 <matthiasgorgens> (instead of just making purely functional programming bearable.)
12:30:10 <matthiasgorgens> trotro: in a sense, yes.
12:30:14 <merijn> srhb: I also take payment in leads to high paying haskell jobs/CS phd positions :p
12:30:15 <srhb> shachaf: I took one look at it and went "ugh, I can at least live this one comment, as long as I don't touch on the issue at hand..."
12:30:28 <trotro> and the exception monad
12:30:34 <trotro> (it exist in so many languages)
12:30:37 <merijn> I should go bug dons after his recent twitter announcement of wanting to hire people with mad FP skillz
12:30:40 <srhb> merijn: CS Ph.D.-positions? That seems like a geographical problem more than anything.
12:31:19 <matthiasgorgens> merijn: standard chartered has some open positions.
12:31:19 <merijn> srhb: Yeah, I know a few outside the country, it seems I'm out of luck if I wanted to stay here :\
12:31:44 <merijn> We have some great groups but they all appear to be broke...
12:31:48 <matthiasgorgens> merijn: you might be able to talk galois and MSR into providing funding for a PhD to unify HalVM and Mirage.
12:31:49 <srhb> merijn: That's how it usually works. :P
12:32:01 <matthiasgorgens> merijn: what's your country/
12:32:02 <matthiasgorgens> ?
12:32:05 <merijn> Netherlands
12:32:12 <srhb> "You can always get a Ph.D. if you want it - just not here" -- quote one of my professors
12:32:16 <shachaf> The only country that follows 'i's with 'j's.
12:32:17 <matthiasgorgens> I am just leaving one Haskell job for another Haskell job. :-D
12:32:31 <merijn> Swierstra's group in Utrecht is not doing so well, apparently' :\
12:33:02 <matthiasgorgens> merijn: you should get yourself to ICFP.
12:33:13 <matthiasgorgens> even if you have to pay for yourself.  just take the student option.
12:33:19 <matthiasgorgens> it's worth it for the networking alone.
12:33:46 <merijn> matthiasgorgens: When's that?
12:34:03 <matthiasgorgens> last ICFP was about a month ago in Copenhagen.
12:34:20 <matthiasgorgens> next one is Sep 2013 in China.
12:34:26 <matthiasgorgens> (ok, that's harder to get to on your own money.)
12:34:32 <shachaf> China? I thought someone said it was in Boston.
12:34:33 <matthiasgorgens> oops, wrong googling.
12:34:36 <matthiasgorgens> http://sklofp.zju.edu.cn/icfp2013/
12:34:37 <matthiasgorgens> ;o)
12:34:41 <matthiasgorgens> should have read the page.
12:34:52 <trotro> what happens at ICFP ?
12:35:00 <matthiasgorgens> International Conference on Fluid Power Transmission and Control. :o)
12:35:01 <trotro> people speak about FP ?
12:35:07 <matthiasgorgens> trotro: what happens at ICFP stays at ICFP. :o)
12:35:10 <trotro> :D
12:35:15 <loser> what's the best way to duplicate a tail of a list in Haskell? i.e. turn x:xs into x:(xs ++ xs) ?
12:35:18 <matthiasgorgens> trotro: yes.  it's the international conference on functional programming.
12:35:27 <matthiasgorgens> Haskell's big.  and OCaml, and Erlang, etc.
12:35:33 <trotro> ha maybe i should gp
12:35:39 <pettter> matthiasgorgens: Scala?
12:35:45 <rwbarton> apparently this 18 minute youtube video will tell me the location of ICFP 2013
12:35:46 <matthiasgorgens> loser: I don't know about best, but you just described a simple implementation.
12:35:53 <matthiasgorgens> pettter: yes, there was also some scala this year.
12:35:55 <rephorm> shachaf, rwbarton: thanks for the help.
12:36:00 <matthiasgorgens> the videos are online.
12:36:05 <pettter> nice
12:36:05 <matthiasgorgens> for this year and lots of past years.
12:36:18 <matthiasgorgens> easily locatable online.
12:36:19 <rwbarton> oh, but the answer was in the first 30 seconds. "Boston area"
12:36:31 <matthiasgorgens> e.g. on youtube.
12:36:31 <trotro> ha it's not in China :( I just understood
12:36:42 <matthiasgorgens> trotro: nope, that was my mistake.
12:36:47 <trotro> yes :)
12:36:47 <shachaf> rwbarton: You should go!
12:36:54 <rwbarton> perhaps I will!
12:37:20 <matthiasgorgens> I don't know where the next one will be.  Is it determined, yet?
12:37:42 <rwbarton> eloquently summed up in this tweet https://twitter.com/lambda_calculus/status/245912079758925824
12:37:54 <trotro> usually they are where ? in US ? in EUrope ? etc.
12:38:02 <matthiasgorgens> 2011 was in Japan.
12:38:07 <matthiasgorgens> 2009 was in Edinburgh.
12:38:17 <matthiasgorgens> 2010 was in USA somewhere, if I remember right.
12:38:35 <srhb> matthiasgorgens: It says TBD on the site, at least.
12:38:35 <shachaf> Baltimore.
12:39:19 <matthiasgorgens> rwbarton: I wonder if they mean Boston, Lincolnshire.
12:39:23 <trotro> it's well paid functional programmer ?
12:39:31 <trotro> compared to C# by example ?
12:39:34 <shachaf> No.
12:39:35 <clahey> rwbarton: It's in the Boston area?  I'm so going.
12:39:37 <clahey> When is it?
12:39:43 <shachaf> Presumably September.
12:39:43 <matthiasgorgens> trotro: depends more on industry than on language.
12:39:49 <trotro> i know
12:39:50 <srhb> All programmers are well paid. The employed ones make the most.
12:40:01 <trotro> because i'm fed up with imperative programming
12:40:01 <matthiasgorgens> srhb: no, the self-employed ones make more.
12:40:04 <matthiasgorgens> and the contractors.
12:40:06 <trotro> but there is money in exchange
12:40:08 <clahey> Was there one in 2012?
12:40:13 <matthiasgorgens> Copenhagen.
12:40:16 <matthiasgorgens> I went there.
12:40:19 <clahey> Cool.
12:40:34 <srhb> matthiasgorgens: Self-employed is employed, surely. :P
12:40:50 <clahey> I'll probably enter the ICFP competition using haskell.
12:40:54 <matthiasgorgens> (I would even admit to having given a talk.  But reviewing the video, there were way to many "Uhms" and "Eh" to 'fess up.)
12:41:03 <clahey> I've only done it once before, and that was in C.
12:41:03 <srhb> Oh, THAT one!
12:41:13 * srhb is just kidding. :-)
12:41:25 <clahey> (I'm in Cambridge, MA, for context)
12:41:29 <clahey> rwbarton: Are you in this area?
12:41:33 <rwbarton> yes, in arlington
12:41:34 <matthiasgorgens> clahey: I'm in the real Cambridge.
12:41:44 <shachaf> clahey: You could go to Hac Boston in Jan.
12:41:48 <loser> I love Text
12:41:51 <clahey> rwbarton: Oh, cool.
12:41:56 <matthiasgorgens> clahey: where ghc is made.
12:41:58 <shachaf> rwbarton: Pft, I thought that was in Virginia.
12:42:26 <clahey> rwbarton: I currently live in Woburn, but I close on a house in Somerville next month.
12:44:21 <matthiasgorgens> It's actually kind-of crazy that SPJ is treasurer in the church that's a five minutes walk away from my house.
12:44:33 <matthiasgorgens> haven't stalked him there (yet!).
12:45:14 <byorgey> matthiasgorgens: it would be *really* crazy if you lived somewhere like Moscow.
12:45:34 * matthiasgorgens agrees.
12:45:44 <arneis> Anyone here using EclipseFP? I'm struggling to get the auto-completion to work properly, certain modules are missing. (http://stackoverflow.com/questions/12942128/eclipsefp-auto-completion-intellisense-is-missing-items)
12:45:51 <matthiasgorgens> but then, it would be Chaskell.
12:46:24 <clahey> shachaf: Is Hac Boston a regular thing, and is it always MLK day weekend?
12:46:25 <matthiasgorgens> (where ch is to be pronounced like in Loch Ness.)
12:46:43 <shachaf> clahey: Well, it happened this year, and I think last year.
12:47:01 <matthiasgorgens> there was a haskell hackathon in Ghent a while ago.
12:47:01 <shachaf> I live a bit far so I don't know much about the Boston goings-on.
12:47:03 <matthiasgorgens> (last year or so.)
12:47:08 <shachaf> But I happened to be nearby in Jan.
12:47:54 <byorgey> clahey: ask edwardk, or dolio, or copumpkin, perhaps?
12:48:07 <edwardk> ?
12:48:12 <edwardk> oh hac boston
12:48:17 <loser> http://ideone.com/zZGLC anyone willing to criticize my code? ^^
12:48:24 <edwardk> i need to organize it again for this year
12:48:29 <dd> hi
12:48:33 <edwardk> the timing will depend o nwhen we can get the space from MIT
12:48:50 <shachaf> edwardk: Make sure to organize for when I happen to be nearby.
12:48:56 <byorgey> hi dd
12:49:12 <shachaf> Unfortunately I still don't know when that is.
12:49:14 <matthiasgorgens> loser: it seems you already send it through hlint?
12:49:19 <loser> not yet
12:49:25 <matthiasgorgens> hlint doesn't complain.
12:49:31 <matthiasgorgens> (that's why I suggested.)
12:49:37 <matthiasgorgens> I mean, assumed.
12:49:38 <loser> ^^
12:49:51 <lightquake> hey edwardk, can i bug you with a lens question?
12:49:56 <edwardk> well, send me your availability for january and february then
12:49:56 <edwardk> sure
12:50:24 <lightquake> i've got data World = World [Entity] and data Entity = Entity Position, with entities and position lenses
12:50:38 <edwardk> *nods*
12:50:39 <clahey> Ah, that's last years page...
12:50:40 <lightquake> what's the 'nicest' way to go from a World to the list of all Positions of its entities?
12:50:53 <matthiasgorgens> loser: I like
12:50:55 <matthiasgorgens> ruleTwo = T.cons <$> T.head <*> (T.append <$> T.tail <*> T.tail)
12:50:59 <matthiasgorgens> (with Control.Applicative)
12:51:02 <loser> right
12:51:05 <matthiasgorgens> but that's probably to point-less.
12:51:06 <edwardk> did you makeIso 'World'?
12:51:20 <lightquake> well, I actually have more state in World than what i just said
12:51:24 <edwardk> from world . traverse . position
12:51:26 <edwardk> ah
12:51:42 <edwardk> so you have a lens from World to [Entity]?
12:51:44 <lightquake> yeah
12:51:50 <lightquake> and a lens from Entity to Position
12:51:56 <edwardk> entities.traverse.position
12:51:58 <clahey> matthiasgorgens: That's in the -> functor?
12:52:00 <matthiasgorgens> loser: using Text isn't going to help you much, if you are converting to String all the time.
12:52:14 <matthiasgorgens> clahey: yeah.  (->) a is the best friend of pointless people.
12:52:29 <matthiasgorgens> and may lead to highly unreadable code.
12:52:35 <loser> is that what's happening? How do I convert it just once?
12:52:35 <lightquake> tried that, got an error about how Int isn't a monoid
12:52:51 <matthiasgorgens> loser: yeah, you are right.
12:52:51 <edwardk> what operation did you try to use on it?
12:52:54 <matthiasgorgens> loser: I wasn't awake enough.
12:52:58 <edwardk> ^.  ?
12:52:58 <lightquake> (world^.)
12:53:13 <loser> ah
12:53:13 <lightquake> is that not right?
12:53:21 <edwardk> you want ^.. to read all of the targets as a list. or otherwise you just get a monoidal summary of them
12:53:34 <matthiasgorgens> {-# LANGUAGE OverloadedStrings #-}
12:53:36 <edwardk> ^. can only give you back one answer =)
12:53:36 <matthiasgorgens> gives you:
12:53:41 <matthiasgorgens> ruleThree = T.replace "II" "U"
12:53:43 <loser> haskell takes a while to compile ^^
12:53:49 <edwardk> so it smashes them together with a monoid when you use it with a fold or traversal
12:53:51 <lightquake> edwardk: ahh
12:54:03 <edwardk> ^.. keeps them separate and just gives you the list
12:54:12 <lightquake> so if i did have a monoid instance, it would give me... the sum of all coordinates of all positions, or something
12:54:14 <clahey> matthiasgorgens: I'm going to have to work on understanding the different typeclasses of (->) a
12:54:18 <edwardk> yeah
12:54:23 <matthiasgorgens> loser: your rule three is not faithful.
12:54:25 <matthiasgorgens> to the original.
12:54:30 <matthiasgorgens> you replace all occurence.
12:54:33 <lightquake> cool :)
12:54:36 <matthiasgorgens> where the original allows you to replace any.
12:54:47 <edwardk> you can also do things like mapMOf to work over all of the positions, etc.
12:54:51 <matthiasgorgens> clahey: it's a good exercise.
12:54:58 <loser> matthiasgorgens: good point
12:55:03 <lightquake> the other thing is, i have something like World { _entities :: [Entity], _player :: Entity }; is there a nice way to also get the player's position in that list?
12:55:08 <matthiasgorgens> loser: are you familar with quickcheck?
12:55:16 <loser> matthiasgorgens: no :(
12:55:18 <matthiasgorgens> good.
12:55:19 <edwardk> sure. just make a custom traversal
12:55:23 <matthiasgorgens> time to get started. :o)
12:55:35 <loser> ^_^
12:55:43 <edwardk> allEntities f (World es p) = World <$> traverse f es <*> f p
12:56:03 <lightquake> neat :)
12:56:04 <matthiasgorgens> loser: though I wonder how best to formulate the properties here.
12:57:59 <hpaste> dd pasted “How to make this more functional/better?” at http://hpaste.org/76421
12:58:06 <lightquake> hm, that gives me an error " Couldn't match expected type `Entity' with actual type `t0 b0'"
12:58:25 <clahey> Why is it written Functor ((->) a) => Applicative ((->) a)   when we also have   Functor ((->) r)
12:58:30 <dd> I'm stuck on figuring out the best way to do a piece of code, can someone help me a bit please?
12:58:32 <clahey> Why not just Applicative ((->) a)
12:58:33 <matthiasgorgens> applyAllRules' t = Tree t (a (ruleOne t), a (ruleTwo t), a (ruleThree t), a (ruleFour t))
12:58:33 <matthiasgorgens>   where a = applyAllRules'
12:58:43 <matthiasgorgens> data Tree = Tree Theorem (Tree, Tree, Tree, Tree)
12:58:48 <shachaf> clahey: ?
12:58:49 <matthiasgorgens> loser: to get a tree of all theorems.
12:58:59 <clahey> shachaf: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
12:59:18 <dd> i have 4 more "if..then..else" that I have to embed in that code if I keep going down this route
12:59:20 <matthiasgorgens> dd: what's it supposed to do?
12:59:28 <lightquake> oh right, that's because i lied about the order of the arguments to World :)
12:59:38 <shachaf> clahey: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html#line-204
12:59:43 <dd> I'm parsing a file looking at the very first line which is a header and determining what kind of file it is from the header
13:00:00 <clahey> shachaf: Right, so why the difference in the docs?
13:00:01 <dd> so the header line can be ISA, GS, ICS, #, etc
13:00:08 <shachaf> clahey: Haddock is weird.
13:00:13 <clahey> shachaf: Okaies.
13:00:18 <matthiasgorgens> clahey: I guess it's written that way, so that asking for Applicative also gives you Functor?
13:00:44 <dd> I can see it marching off the right side of the page and it doesn't seem very functional to me, sort of mapping from the existing Java code to Haskell
13:00:47 <matthiasgorgens> dd: are you familar with haskell's parsing libraries?
13:01:06 <matthiasgorgens> dd: or just guards?
13:01:18 <dd> I've been playing with parsec
13:01:48 <dd> I know guards as well
13:02:01 <hpaste> “Matthias Goergens” annotated “How to make this more functional/better?” with “How to make this more functional/better? (annotation)” at http://hpaste.org/76421#a76422
13:02:28 <dd> wow, much nicer
13:02:44 <dd> sometimes I just get stuck trying to wrap my head around the style -)
13:03:48 <matthiasgorgens> dd, hlint is your friend.
13:04:01 <matthiasgorgens> just don't trust it blindly.
13:04:02 <dd> thanks, is that part of the ghc distro?
13:04:11 <loser> I love guards
13:04:29 <matthiasgorgens> dd, I don't know.
13:04:46 <matthiasgorgens> you can get it via the cabal installer script.
13:05:07 <dd> I was using parsec, but found that if I use this method to find the delims first, i can parse with:  map (splitOn firstdelim) . (endBy secondDelim)
13:05:22 <dd> phone, back in a bit
13:05:30 <matthiasgorgens> @hoogle splitOn
13:05:30 <lambdabot> Data.Text splitOn :: Text -> Text -> [Text]
13:05:30 <lambdabot> Data.Text.Lazy splitOn :: Text -> Text -> [Text]
13:05:53 <matthiasgorgens> I like the split package for very simple parsing jobs.
13:05:53 <clahey> matthiasgorgens, loser: It's also done automatically on whatever you put on hpaste.
13:05:57 <matthiasgorgens> http://hackage.haskell.org/package/split
13:06:12 <matthiasgorgens> clahey: oops, yes.
13:06:22 <matthiasgorgens> I would have just needed to click on the warning to expand it. :o)
13:06:45 <clahey> matthiasgorgens: Might have been slightly less work.  :)
13:07:13 <carter_> does anyone have any thoughts on how to write a layer for parsec, attoparsec or the like that adds support for the ideas here? http://michaeldadams.org/papers/layout_parsing/
13:07:29 <carter_> (basically a nice way of handling layout sensitive parsing)
13:07:51 <matthiasgorgens> carter_: no idea, but thanks for the link!
13:08:15 <carter> matthiasgorgens wasn't even looking at the current chatter
13:08:39 <matthiasgorgens> carter: what do you mean?
13:09:03 <carter> that y'all are currently chatting about parsing related bits :)
13:09:15 <matthiasgorgens> oh, yeah. :o)
13:09:33 <matthiasgorgens> but if you look at problems the right way, everything can be seen as parsing (or compiling).
13:09:55 <carter> i'm sort of hoping that i can nudge edwardk into getting his next version of trifecta out soon and magically add these ideas too that trifecta lib
13:10:09 <carter> matthiasgorgens if by that you mean having a nice composable algebraic character, yes
13:10:20 <edwardk> dibblego has been spending some time working with and on trifecta so the new version may be oming sooner than later
13:10:39 <carter> cool
13:10:49 <edwardk> but the parsing and/or compiling this is why i have trifecta and bound ;)
13:11:00 <edwardk> er s/this/thing
13:11:15 <matthiasgorgens> carter: I meant recognising some structure in a sequence (or tree), and transforming inputs from one language to outputs in another.
13:12:21 <carter> edwardk heence why i've asked ya about yer thoughts on the adams papers
13:12:23 <carter> paper
13:12:32 <edwardk> send me that link again?
13:12:41 <carter> edwardk http://michaeldadams.org/papers/layout_parsing/
13:12:46 <carter> also it apparently just got into popl
13:12:47 <edwardk> i'll see if i can find the time to read it while on the plane or out in CA
13:12:55 <carter> i'd really appreciate it :)
13:13:13 <edwardk> ah yes the layout rule one
13:13:19 <carter> because if theres a nice way of adding the ideas to a parser combinator lib
13:13:25 <edwardk> i'll need to compare it to what i do in trifecta/ermine
13:13:26 <nicoo> carter: I read « Under review » more like « Was submitted »
13:13:35 <nicoo> But I may be wrong
13:13:44 <carter> nicoo: on g+ mike just said the paper got int today
13:13:52 <carter> i've been staring at it reccurently for the past month
13:13:55 <carter> (not that i've had much time)
13:14:05 <carter> matthiasgorgens: not *everything* fits that pattern
13:14:23 <edwardk> maybe not everything but an alarming percentage ;)
13:14:29 <carter> yuep
13:14:49 <carter> i guess you could say that linear algebra gets that pattern when you try to distribute / parallelize it too
13:16:12 <matthiasgorgens> carter: yes.  but a surprisingly large chunk does.
13:25:38 * hackagebot graphbuilder 0.1.0.0 - A declarative, monadic graph construction language for small graphs  http://hackage.haskell.org/package/graphbuilder-0.1.0.0 (JosephAbrahamson)
13:28:21 <Tekmo> Is there a Haskell list shuffling that doesn't blow the stack for long lists?  I checked out Oleg's random shuffle but I get a Stack Overflow for lists over >500,000 elements.
13:28:22 <lambdabot> Tekmo: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:28:44 <crdueck> i want to do the equivalent of mapM_ but for Data.Map.map, how can i do this? "return $ Data.Map.map f theMap" isnt working
13:28:53 <loser> what's great about quickcheck?
13:29:18 <Ralith> :t sequence
13:29:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
13:29:26 <Ralith> @src sequence
13:29:26 <lambdabot> sequence []     = return []
13:29:26 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:29:26 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
13:29:47 <Ralith> crdueck: ^
13:30:01 <crdueck> Ralith: i dont quite follow
13:30:10 <Ralith> @src mapM
13:30:10 <lambdabot> mapM f as = sequence (map f as)
13:30:16 <Ralith> does that help?
13:30:16 <crdueck> ahh
13:30:21 <crdueck> yes :) thanks
13:30:24 <Ralith> ^^
13:30:26 <Ralith> have fun!
13:34:24 <damianeq89> hi
13:35:18 <damianeq89> anybody??
13:35:27 <MostAwesomeDude> damianeq89: Yes!
13:35:45 <merijn> loser: It can autogenerate test input for your tests
13:36:09 <merijn> @check \xs ys -> (xs :: Int) == ys
13:36:11 <lambdabot>   "Falsifiable, after 1 tests:\n0\n1\n"
13:36:16 <loser> ah
13:36:26 <dd> back aain
13:36:28 <dd> again
13:36:31 <damianeq89> i have a task to do could you help me??
13:36:52 <MostAwesomeDude> damianeq89: Potentially. What's up?
13:36:52 <merijn> @check \xs -> length xs == length (reverse xs)
13:36:54 <lambdabot>   "OK, passed 500 tests."
13:37:42 <damianeq89> i have to write a program in haskel that will return True if a numer is in a list and flase if it isn't
13:37:55 <damianeq89> any idea
13:37:57 <damianeq89> ??
13:38:23 <MostAwesomeDude> damianeq89: Homework?
13:38:30 <damianeq89> yea :P
13:38:38 <MostAwesomeDude> I'd ask your TA. What do you have so far?
13:38:39 <Ralith> you should probably refer to your notes, then.
13:39:20 <crdueck> Ralith: i'm not sure if I'm overlooking something, but
13:39:36 <crdueck> :t \f m -> sequence (Data.Map.map f m)
13:39:37 <lambdabot>     Couldn't match expected type `[m a]'
13:39:37 <lambdabot>            against inferred type `M.Map k b'
13:39:37 <lambdabot>     In the first argument of `sequence', namely `(M.map f m)'
13:40:00 <merijn> crdueck: You probably want Data.Traversable.sequence
13:40:21 <crdueck> :t \f m -> Data.Traversable.sequence (Data.Map.map f m)
13:40:22 <lambdabot> forall a (m :: * -> *) a1 k. (Monad m) => (a -> m a1) -> M.Map k a -> m (M.Map k a1)
13:40:29 <crdueck> merijn: perfect, thanks
13:40:55 <merijn> crdueck: Incidentally Data.Traversable.sequence over a Data.Map.map probably means you want Data.Traversable.mapM
13:41:03 <merijn> :t Data.Traversable.mapM
13:41:05 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
13:41:16 <crdueck> even better :)
13:41:27 <Ralith> crdueck: I was suggesting that you write a version of sequence that processes maps, but it looks like there's already a general version.
13:42:13 <damianeq89> element x l
13:42:18 <damianeq89> |l==[] = false
13:43:05 <damianeq89> now i want to you somehow drop and take to compare with x
13:43:50 <MostAwesomeDude> damianeq89: Do you understand how to recurse on lists?
13:44:38 <damianeq89> not really :P
13:45:38 <MostAwesomeDude> I'd go chat with your TA, then; I really don't want to give away the answers to homework.
13:47:12 <strebe> damianeq89: the general structure of recursion is that you have two things, a base case and a recursive case
13:47:32 <crdueck> @src mapM_
13:47:33 <lambdabot> mapM_ f as = sequence_ (map f as)
13:47:50 <CmrPantoufle> @src sequence_
13:47:50 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
13:48:12 <merijn> crdueck: Data.Foldable has generalised versions of mapM_ and sequence_
13:48:21 <strebe> so if you wanted to count the length of a list, for example, you could write something like
13:50:39 * hackagebot FixedPoint-simple 0.3.2 - Fixed point, large word, and large int numerical representations (types and common class instances)  http://hackage.haskell.org/package/FixedPoint-simple-0.3.2 (ThomasDuBuisson)
13:56:30 <strebe> let ml n xs = if null xs then n else ml0 (n+1) (tail xs)
13:56:32 <strebe> let mylength xs = ml 0 xs
13:57:30 <strebe> damianeq89: basically, your recursive function ('ml' in this example) checks if it's done recursing and there's nothing left to do (for instance, if a list is empty, or you're counting down to zero)
13:57:41 <strebe> if so, it does something (in this case, returns a counter)
13:58:04 <strebe> otherwise, it keeps chugging away, in this example by incrementing a counter and running itself on what's left of the list
13:58:57 <strebe> but the key concept is a base case, and a recursive case
14:00:18 <strebe> do you understand how this example works?
14:00:51 <damianeq89> yes
14:01:04 <strebe> then you understand recursion after all :-)
14:02:14 <damianeq89> tanks
14:02:35 <strebe> you're welcome
14:04:34 <damianeq89> but i don't know this haskell i mean functions etc., I had only one lesson and if i want to get one point for activity I have to do it till 23:59,
14:05:00 <damianeq89> fried told me about it an hour ago and I dont have much time
14:05:03 <ciaranm> sounds like you should learn haskell elsewhere
14:05:04 <damianeq89> but i'll try
14:05:13 <ciaranm> @lyah is a good start
14:05:13 <lambdabot> Unknown command, try @list
14:05:58 <strebe> you seem to be in north america, so you've got more than long enough to figure it out. :-)
14:06:16 <damianeq89> i'm from europe :P
14:06:22 <ciaranm> yeah, you can learn all of haskell in about three hours
14:06:41 <damianeq89> 11:06 pm
14:06:44 <damianeq89> :P
14:06:52 <strebe> ah, Poland, I looked at your irc server
14:06:53 <strebe> still
14:07:00 <strebe> long enough, you just have to focus a bit more :)
14:07:05 <strebe> ciaranm recommended learnyouahaskell.com
14:07:56 <ciaranm> two of those hours are to learn category theory, and you don't need that for your thing
14:08:26 <strebe> ciaranm: ehm, I wish I was as bright as you, I don't think I know category theory despite spending over 2 hours on it. :D
14:08:56 <ciaranm> all you really need to do is remember the phrase "a monad is just a monoid in the category of endofunctors. what's the problem?"
14:09:25 <strebe> ciaranm: my morphism objects? ;-)
14:09:28 <ciaranm> if you think someone might call your bluff, memorise a few one-line definitions for those words that make use of lots of other words
14:09:43 <CmrPantoufle> « You can’t understand monads if you don’t have the gonads »'
14:10:53 <strebe> CmrPantoufle: I think I preferred ciaranm's approach
14:11:31 <CmrPantoufle> strebe: I spent too much time on dis.4chan.org/prog
14:12:05 <strebe> ahh
14:12:20 <mixi> strebe: don't tell ciaranm that he's especially bright. he becomes insufferable after that
14:12:37 <strebe> mixi: technically, I didn't ;-)
14:12:46 <maukd> CmrPantoufle: have you read your SICP today?
14:13:02 <ciaranm> also, what kind of wimps set "do some stuff in a list" as a haskell exercise? the first haskell exercise i got set was to write a compiler
14:13:19 <strebe> ciaranm: ehm, probably a first class in programming
14:13:40 <mixi> told you so
14:13:48 <strebe> mixi: point taken
14:14:08 <merijn> ciaranm: Please don't say that to newbies
14:14:23 <loser> where does the 'have you read your sicp today?' joke come from?
14:14:27 <maukd> "compile brainfuck to C" is actually a good newbie exercise
14:14:31 <ciaranm> loser: MIT
14:14:39 <loser> ah
14:14:44 <merijn> ciaranm: The monad quote is only funny if you already know haskell and it just confuses and scares away newcomers
14:15:00 * merijn is in favour of flogging everyone who brings it up in conversation with newcomers...
14:15:18 <ciaranm> it's the most useful definition, though
14:15:27 <merijn> ciaranm: Most useful to whom?
14:15:54 <ciaranm> most useful if you ever want to understand or do non-trivial work with monads
14:16:00 <merijn> Bullshit
14:16:26 <merijn> I don't understand anything of the quote and I can do plenty of useful stuff with monads
14:16:43 <lort> how could i keep from a large string A..Z a some chars of other languages like ó and so on so far got this
14:16:54 <lort> qwert st = [x|x <- st, elem x ['A'..'Z']]
14:16:56 <CmrPantoufle> maukd: actually no
14:16:59 <loser> what quote? the 'monads are just monoids' one ?
14:17:06 <merijn> loser: yeah
14:17:06 <CmrPantoufle> But I am in it, first chapters
14:17:10 <CmrPantoufle> Really interesting
14:17:23 <CmrPantoufle> And I don’t play Touhou yet
14:18:03 <maukd> is that what's currently going on in /prog/?
14:18:14 <maukd> I left after "GRUNNUR"
14:18:37 <CmrPantoufle> lol
14:18:42 <CmrPantoufle> They hate Jews
14:18:48 <CmrPantoufle> Talk about Sussman
14:19:47 <loser> does haskell have String/Text slice operators like Python does?
14:20:09 <maukd> drop, take
14:20:39 * hackagebot perm 0.2.0.1 - permutation Applicative and Monad with many mtl instances  http://hackage.haskell.org/package/perm-0.2.0.1 (AndySonnenburg)
14:21:34 <loser> http://hpaste.org/76429 is there a cleaner way to rewrite this function?
14:22:05 <EvanR> loser: yeah, Text can drop from the end
14:22:11 <loser> ah
14:23:05 <EvanR> without first travesing to find length
14:24:36 <strebe> CmrPantoufle: not much of a laughing matter; I pretty much quit reading reddit because it was too full of that kind of nonsense
14:24:53 <CmrPantoufle> strebe: memes and jokes everywhere?
14:24:57 <lort> whats is char the char for tabs space and toher invisible ones
14:24:59 <lort> ??
14:25:07 <lort> ' ' = space
14:25:07 <strebe> CmrPantoufle: memes and jokes are one thing, but the sheer amount of bigotry got old
14:25:17 <EvanR> > '\t'
14:25:19 <lambdabot>   '\t'
14:25:32 <CmrPantoufle> strebe: bigotry :o?
14:25:39 <EvanR> > '\r':'\n':[]
14:25:40 <lambdabot>   "\r\n"
14:26:29 <strebe> CmrPantoufle: it varies by subreddit, but when a large percentage of the posts have unfunny jokes about jews/women/etc, it gets really tiresome after a while
14:26:33 <loser> syntactic sugar ftw
14:26:54 <EvanR> yes, prefer funny jokes about jews and women
14:27:02 <lort> why     lexical error in string/character literal at character '\n' ?
14:27:02 <CmrPantoufle> strebe: yes
14:27:21 <EvanR> loser: whats the whole string
14:27:28 <EvanR> lort: ^
14:27:46 <strebe> EvanR: even a joke that's funny once gets old
14:27:48 <lort> "a Lámina perpendicular Concha nasal media Concha nasal inferior Vómer Mandíbula"
14:28:02 <EvanR> strebe: in which case it has nothing to do with the content
14:28:07 <EvanR> just that its old
14:28:26 <strebe> EvanR: I don't really mind reading variations of 'first post' to the same degree
14:28:29 <loser> EvanR: "MI"
14:28:34 <ciaranm> you know what never gets old? dead babies
14:28:40 <EvanR> lol
14:28:55 <loser> > 'M':'I':[]
14:28:57 <lambdabot>   "MI"
14:29:06 <EvanR> lort: theres no \n in there
14:29:14 <EvanR> lort: are you trying to put it on more than one line?
14:29:19 <lort> i am tryng to keep A..Z and some spanish accent chars and of course tabs and spaces
14:29:23 <loser> > mapM_ putChar 'M':'I':[]
14:29:24 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:29:25 <lambdabot>         against inferred ty...
14:29:26 <EvanR> lort: for multiline string literals you need to put backslash and the beginning and end of the line
14:29:27 <merijn> Why does TChan need a newBroadCastChan but Chan apparently does not?
14:29:30 <lort> so far func fuck = [x|x <- fuck, elem x ['A'..'Z'] || elem x [' ','\t']]
14:29:50 <EvanR>  "like\
14:29:53 <EvanR>  \this"
14:30:04 <ciaranm> > let me = 'M':'E':me in me
14:30:06 <lambdabot>   "MEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEMEME...
14:30:07 <strebe> ciaranm: while I guess you were being tongue-in-cheek with your one-liner, that's actually the explanation of monads that has made most sense to me
14:30:26 <ciaranm> strebe: i agree entirely with that
14:30:28 <hpaste> mkramer pasted “why segfault?” at http://hpaste.org/76430
14:30:39 <EvanR> 'explanation of monads'
14:30:50 <EvanR> see typeclass definition and do sugar
14:31:03 <ciaranm> the typeclass definition of a monad is crap
14:31:05 <strebe> EvanR: yes. Both functors and monoids are -really- easy to understand, but monads keep not quite going into my head.
14:31:19 <EvanR> followed by the couple common monad instances
14:31:21 <ciaranm> the pure / join definition is a lot better
14:31:24 <EvanR> nothing to get
14:31:27 <strebe> EvanR: I can -use- monads, but I don't -understand- them, in the sense of seeing where the abstraction makes sense and where it falls out of my own design problems
14:31:45 <strebe> syntactic sugar is lovely to use, but doesn't massively help at that level
14:31:49 <EvanR> ciaranm: i cant argue with that, but tossing up two definitions will confuse new people
14:32:07 <EvanR> strebe: dont worry about coming up with totally new instances of monad
14:32:09 <strebe> EvanR: well, that bit was aimed at me anyhow, the new guy wanted to know how to recurse over a list
14:32:23 <ciaranm> monads are far easier to get once you realise that bind is something you get from fmap, pure and
14:32:36 <ciaranm> ...join, rather than something that defines a monad
14:33:11 <strebe> EvanR: it's my nature to want to be able to, and to understand the design decisions behind things like xmonad
14:33:26 <strebe> i'm not taking a class; I want to understand ;-)
14:33:32 <EvanR> i havent looked at xmonad, but isnt it just a StateT over IO
14:33:42 <EvanR> or something
14:35:06 <byorgey> the return/bind definition of monads has a long history, and is quite elegant in its own way
14:35:35 <byorgey> has a long history even within pure math circles, I mean
14:36:07 <ciaranm> pure math monads aren't assumed to be strong
14:36:11 <lightquake> why is there no (Num a) => Num (Sum a)?
14:36:36 <byorgey> lightquake: no good reason.
14:36:48 <lightquake> lame
14:36:57 <byorgey> agreed.
14:36:59 <merijn> lightquake: Define it yourself?
14:37:00 <EvanR> stuff like Sum was meant to be used to temporarily change the behavior of a type
14:37:23 <lightquake> merijn: i don't actually need it, i was just curious
14:37:41 <tromp> @src Sum
14:37:42 <lambdabot> Source not found. I've seen penguins that can type better than that.
14:37:49 <tromp> @hoogle Sum
14:37:49 <lambdabot> Prelude sum :: Num a => [a] -> a
14:37:50 <lambdabot> Data.List sum :: Num a => [a] -> a
14:37:50 <lambdabot> Data.Monoid Sum :: a -> Sum a
14:37:52 <EvanR> Sum is a newtype
14:37:59 <byorgey> fromInteger would be particularly nice with Sum
14:38:02 <EvanR> Sum :: a -> Sum a
14:38:25 <EvanR> > Sum 2 <> Sum 2
14:38:26 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
14:38:27 <lambdabot>         agains...
14:38:29 <mkramer> > logBase 2.0 0.3
14:38:31 <lambdabot>   -1.7369655941662063
14:38:33 <EvanR> >_<
14:38:34 <byorgey> EvanR: xmonad is ReaderT over StateT over IO, yes
14:38:37 <lightquake> > Sum 2 `mappend` Sum 3
14:38:38 <lambdabot>   Sum {getSum = 5}
14:38:42 <lightquake> > Product 2 `mappend` Product 3
14:38:43 <lambdabot>   Product {getProduct = 6}
14:38:52 <mkramer> that segfaults on my Macbook
14:39:03 <Attic> Hi, do I need to specify in the cabal config file if I want to be able to use haskell packages distributed by my OS?
14:39:12 <mkramer> > logBase 2.0 0.2
14:39:14 <lightquake> mkramer: what version?
14:39:14 <lambdabot>   -2.321928094887362
14:39:19 <merijn> Does anyone know why TChan needs a newBroadCastTChan to avoid space leaks when using a TChan as a write-only broadcast channel while Chan apparently doesn't need that? (There is no newBroadcastChan)
14:39:31 <lightquake> it wfm...
14:39:39 <dcoutts> Attic: no
14:39:44 <byorgey> Attic: you need to specify all the Haskell packages your project needs, regardless of how they are installed
14:39:45 <integral> out of interest, is there are name for the pattern, Sum . f . getSum (where Sum and getSum could be any constructor-deconstructor pair)?
14:40:05 <EvanR> integral: fmap ?
14:40:08 <lightquake> integral: it reminds me of a manual fmap
14:40:09 <mkramer> The Glorious Glasgow Haskell Compilation System, version 6.10.4
14:40:10 <dcoutts> Attic: what byorgey says :-)
14:40:18 <byorgey> integral: yes, 'over' from Control.Newptype, in the newtype package
14:40:30 <dcoutts> mkramer: ah, classic version
14:40:34 <byorgey> though I personally think 'under' would have been a better name =P
14:40:36 <integral> ah, thanks.
14:40:43 <Attic> byorgey: I installed haskell-gtk package on arch linux, but I can't import Graphics.UI.Gtk even though it's in that package
14:40:46 <lightquake> mkramer: have you tried installing a more recent GHC?
14:41:01 <lightquake> Attic: you need to list the package in your .cabal file
14:41:11 <lightquake> if that's what you mean
14:41:37 <Attic> lightquake: Yeah that's probably what I mean, how do I go about doing that?
14:41:52 <lightquake> use the build-depends field
14:42:11 <Attic> lightquake: It should be install here "usr/lib/ghc-7.6.1/site-local/gtk-0.12.3.1/"
14:42:26 <lightquake> Attic: what's the name of the package on hackage?
14:42:35 <lightquake> or, i guess, do ghc-pkg list | grep -i gtk
14:42:41 <lightquake> so you know what ghc calls it
14:42:43 <Attic> lightquake: gtk
14:42:58 <lightquake> so just put gtk in your build-depends
14:44:06 <Attic> lightquake: But when I go into ghci I cant import it, shouldn't I just be able to do that?
14:44:26 <lightquake> what error do you get?
14:44:39 <Attic> lightquake: I don't get an error, it just doesn't exist
14:45:04 <Attic> lightquake: I didn't install it through cabal, but through arch linux
14:45:14 <lightquake> so the glib answer is "don't do that"
14:45:27 <lightquake> because installing cabal packages through a package manager is a recipe for suffering
14:45:37 <byorgey> it SHOULD work though
14:45:43 <lightquake> yeah
14:45:50 <lightquake> can you paste the output of ghc-pkg list somewhere
14:45:50 <Attic> lightquake: Well I'd glady install it through cabal if it wasn't so broken
14:45:55 <byorgey> Attic: can you paste the output of 'ghc-pkg list' ?
14:45:58 <dcoutts> Attic: does "ghc-pkg list gtk" show that it's there?
14:46:39 <Attic> yeah it's in the list
14:47:17 <Attic> But whenever I try to install anything at all through cabal it just fails horribly
14:47:48 <lightquake> how does it fail?
14:50:29 <hiteki> w3m
14:50:55 <Attic> lightquake: It's mostly dependencies that mess it up
14:51:12 <lightquake> what do you mean?
14:52:19 <Attic> cabal install gtk2hs-buildtools >> There are files missing inthe process-1.1.0.2 package
14:52:46 <Attic> Also a lot of times when trying to install things I have to download the tarball and adjust the dependencies in order for them to actually install
14:52:51 <dcoutts> Attic: did you at any point do something like rm -r ~/.cabal  ?
14:53:14 <Attic> I removed my cabal dir yeah
14:53:18 <Attic> and then updated
14:53:49 <dcoutts> Attic: ok, the problem is that the package db is stored elsewhere so ghc still thinks those packages exist, but all the files for them have been deleted.
14:54:08 <marv> I did some googling, but I just can't find any puns tying together the Maybe monad and the song "Call Me Maybe".
14:54:09 <Attic> so i need to reinstall haskell-platform.
14:54:10 <Attic> >
14:54:11 <Attic> ?
14:54:14 <dcoutts> Attic: you can make ghc forget about all the packages you installed via cabal by doing rm -r ~/.ghc
14:54:25 <shachaf> marv: Let's keep it that way.
14:54:25 <dcoutts> Attic: no, your global system packages are fine
14:54:45 <Attic> dcoutts: Ah yeah now I'm getting different errors lol
14:55:21 <lightquake> don't use exceptions / control flow's crazy / so use a monad / (in haskell, Maybe)
14:56:41 <Attic> When trying to install packages I'm getting lots of foreign declaration errors, does that say anything to you guys?
15:00:08 <lightquake> Attic: doesn't sound familiar to me :/ if you rm -r ~/.ghc ~/.cabal and start from scratch do you still get those issues?
15:00:28 <Attic> lightquake: I'll try again haha
15:00:52 <Attic> Thanks for helping out btw
15:01:50 <Attic> still getting foreign declaration CInt, maybe the module for that type isnt being imported properly
15:02:04 <lightquake> what version of ghc are you using?
15:02:14 <Attic> 7.6.1
15:02:42 <lightquake> huh
15:02:58 <Saizan> can you paste the actual error'
15:03:02 <Saizan> ?
15:03:04 <Attic> Sure one sec
15:03:42 <Ismael_> hi guys, i'm trying to make a data constructor which accepts one, two, three or four parameters
15:04:02 <Ismael_> but "data Tuple a b c d = Tuple1 a | Tuple2 a b | Tuple3 a b c | Tuple4 a b c d" is not working
15:04:06 <Attic> http://pastie.org/5075617 Here you go
15:04:21 <Peaker> Ismael_, "Tuple" is a type constructor. Each of Tuple1..4 are data constructors
15:04:29 <shachaf> Is there a "log" type such that f (a,b) = Either (f a) (f b)?
15:05:17 <Saizan> Attic: oh, gtk2hs is known to not build  with 7.6.1 yet
15:05:39 <Attic> Saizan: Oh I see, which version do you suggest?
15:05:51 <Ismael_> ok Peaker, so is my expression incorrect ?
15:05:56 <Saizan> Ismael_: whatdo you mean by not working?
15:06:17 <Peaker> Ismael_, the declaration seems correct, just remarking about terminology
15:06:19 <Saizan> Attic: 7.4.2 i guess
15:06:35 <Attic> Saizan: Ok I'll try that, thanks
15:06:36 <Ismael_> when i type ":t Tuple 1 2 3", I get an error
15:06:37 <Peaker> Ismael_, what is the problem more specifically?
15:06:53 <Peaker> Ismael_, "Tuple" is a type constructor, not a value
15:06:56 <Mortchek> Ismael_, because you need to say Tuple3 1 2 3
15:07:32 <byorgey> shachaf: once upon a time I had this idea that log corresponded to "paths" in data structures
15:07:51 <byorgey> shachaf: e.g. a path to a value in an (a,b) structure is either a path to an a, or a path to a b.
15:08:18 <byorgey> shachaf: but I couldn't quite make it all work out nicely.  but I'm still convinced there's something interesting there.
15:08:27 <Ismael_> so correct me if I'm wrong, I can only use Tuple in types declaration
15:08:51 <Ismael_> anywhere else I need to use TupleN
15:09:29 <byorgey> oh, and it works for exponents too.  a path to an 'a' in an (b -> f a) structure is a b paired with a path to an 'a' in f.
15:09:43 <byorgey> log (f a)^b = b * log (f a)
15:10:18 <Ismael_> something like : "myFunc :: Tuple a b c d -> Bool"
15:13:00 <cmccann> shachaf, heh, that looks an awful lot like de morgan's law
15:13:01 <lambdabot> cmccann: You have 5 new messages. '/msg lambdabot @messages' to read them.
15:13:16 <cmccann> D:
15:14:17 <loser> ?
15:14:31 <shachaf> cmccann: I told elliott to stop making your life painful.
15:14:36 <Mortchek> Ismael_, if something expects a type, use Tuple; if something expects a value, use TupleN. So yes, type tags are one instance where you'd use Tuple.
15:14:54 <shachaf> Oh, and Phantom__Hoover.
15:15:09 <Ismael_> ok Mortchek
15:15:16 <cmccann> did elliott finally lose it after all those lambdabot messages and start spamming everyone? :D
15:16:06 <shachaf> cmccann: Hey, it does.
15:17:15 <byorgey> heh, so I guess f ~ ((->) Void)  works
15:17:23 <byorgey> probably not what shachaf was looking for.
15:17:37 <cmccann> also I don't think it works quite right
15:17:50 <shachaf> byorgey: Const Void also works, as elliott pointed out repeatedly.
15:17:58 <coldpizza72i> Write a data type declaration for the following description of an n-ary tree: … Isn't this the answer Data Tree a = Empty | a [Tree a] ?
15:18:02 <cmccann> because and and or have slightly different semantics in intuitionistic logic
15:18:04 <byorgey> er, not ((->) Void)
15:18:09 <byorgey> the flip of that
15:18:11 <coldpizza72i> A Tree a is either empty or a value of type a and a list of Trees, also of type a.
15:18:37 <byorgey> cmccann: oh, right, only one direction of de morgan holds
15:18:39 <Peaker> coldpizza72i, the "a" there after | is not a valid data constructor name, needs to be upper case
15:18:41 <shachaf> coldpizza72i: Type that into GHC and see if it accepts it. :-)
15:18:42 <cmccann> shachaf's identity would hold for linear negation though, for the appropriate choice of operations :P
15:18:45 <byorgey> but I always have to re-work out which one it is.
15:19:02 <shachaf> byorgey: It's the one that needs "Either" as the outermost thing.
15:19:05 <cmccann> my ongoing fascination with linear logic being why I noticed that resemblance, heh
15:19:17 <shachaf> byorgey: Because you can't figure out whether it's Left or Right without having more information.
15:19:27 <byorgey> coldpizza72i: you're very close, you just need a constructor in the second case
15:19:43 <byorgey> shachaf: ah, makes sense
15:19:44 <coldpizza72i> i see
15:20:20 * byorgey has a strange and unorthodox idea to teach beginners about algebraic data types using GADT syntax
15:20:39 <cmccann> byorgey, I kinda like that idea
15:20:41 <fliip> If you have a function foo x = foo2 (foo3 x) how do you go about prooving foo is strict if foo2 and foo3 are strict?
15:20:47 <shachaf> byorgey: That's not very unorthodox, is it?
15:21:03 <byorgey> shachaf: I don't know, I've never seen it done
15:21:15 <byorgey> mathematically speaking it is quite orthodox, of course
15:21:18 <shachaf> netj: Hey, you should go to bahaskell tomorrow! https://sites.google.com/site/bayareahaskell/
15:21:20 <byorgey> I just mean I've never seen it done in Haskell.
15:21:21 <Ismael_> Thanks to everyone who helped me :)
15:21:31 <maukd> fliip: seems trivial
15:21:34 <shachaf> I've seen it proposed before, at least.
15:21:39 <byorgey> ah, ok.
15:21:48 <fliip> ?
15:21:49 <shachaf> byorgey: (-> Void) = (0^), which is worryingly close to (const 0)
15:21:55 <byorgey> well, I'm going to try it on my class tomorrow.
15:22:07 <byorgey> but to be fair, I have already taught them about term algebras.
15:22:13 <shachaf> It doesn't really behave like a logarithm in terms of most things you expect from a logarithm, I think.
15:22:14 <maukd> fliip: I mean, where are you stuck?
15:22:18 <byorgey> so I expect it to work exceptionally well.
15:22:19 <fliip> maukd... Thanks for helping.
15:22:21 <shachaf> Then again it's hard to do that while staying discrete. :-)
15:22:35 <byorgey> shachaf: indeed.
15:22:36 <shachaf> byorgey: What class is this?
15:22:40 <ion> shachaf: So… any idea whether there’s a Google Hangout or whether edwardk’s talk will be recorded? I’d really love to see the talk.
15:22:55 <Kyraimion> Why does getAddrInfo throw an exception rather than return an empty list?
15:22:56 <byorgey> shachaf: http://www.cis.upenn.edu/~cis39903/
15:23:10 <shachaf> ion: A few people have said they could bring video cameras.
15:23:18 <shachaf> ion: I don't know more than what's on the list.
15:23:40 <Peaker> annoying that MonadReader has  (m -> r) fundep. Can't have an instance for a bunch of accessible attributes
15:23:50 <ion> I wonder if there is a PA system with recording capability? Camera microphones meters away aren’t so nice.
15:24:01 <shachaf> ion: It's possible.
15:24:03 <fliip> If you have a function foo x = foo2 (foo3 x) how do you go about prooving foo is strict if foo2 and foo3 are strict?
15:24:12 <shachaf> Apparently Google has been a little unfriendly about the prospect of recording?
15:24:21 <shachaf> edwardk mentioned something along those lines.
15:24:22 <maukd> fliip: where are you stuck?
15:24:36 <ion> *cough* Google Tech Talks
15:24:37 <Cale> It would be awesome if the answer to the maze on that syllabus page was "no"
15:24:58 <edwardk> Satnam Singh: Edward Kmett: I've talked to our operations people here. Sadly it is not possible for us to arrange a video of your talk (due to lack of lead time) and filming by visitors is not allowed inside Google. So I am sorry -- but we can't video your presentation.
15:25:09 <Kyraimion> byorgey:  I would think that GADT syntax is less confusing than the traditional one
15:25:15 <ion> Well, crap.
15:25:16 <shachaf> edwardk: :-(
15:25:17 <edwardk> ion: so no luck for you
15:25:31 <edwardk> I'll see about arranging to do a similar talk in New York or something
15:25:36 <edwardk> and maybe get video of that
15:25:42 <ion> That would be much appreciated.
15:25:51 <cmccann> shachaf, btw--see my http://hpaste.org/75222 line 144 :P
15:25:56 <edwardk> Edward Kmett, The Lens and Traversal Tour, 2012
15:26:09 <ion> The Lens and Traversal World Tour
15:26:19 <hvr> edwardk: are there tshirts and mugs yet?
15:26:30 <shachaf> hvr: There are stickers!
15:26:32 <shachaf> Lots of stickers.
15:26:35 <edwardk> if someone wants to fly me overseas to give a talk, i'm happy to go. S&P Capital IQ will even give me the time off work =P
15:26:41 <shachaf> I think 1200 stickers or something.
15:26:52 <edwardk> I'll only have a few hundred with me
15:27:04 * ion rowboats edwardk overseas.
15:27:18 * edwardk is afraid of the flying rowboat
15:27:19 <shachaf> ion: Now it's up to you how much you want to see the talk!
15:28:11 <jamiltron> Does the talk cost anything? I only see a time listed.
15:28:27 <shachaf> jamiltron: Only your soul.
15:28:30 <edwardk> no cost, just sending in that you'll be there to satnam and showing up
15:28:41 <edwardk> nah, i've got enough souls.
15:28:52 <edwardk> As an atheist its hard to figure out what to do with the damned things.
15:28:55 <jamiltron> Awesome, I am excited for it.
15:29:12 <byorgey> "the damned things" haha =)
15:29:14 <cmccann> shachaf, of course, de morgan's laws also convert in the other direction, plus the linear connectives probably don't really work as sums and products, but oh well :P
15:29:16 <edwardk> =)
15:29:49 <shachaf> cmccann: Oh, I missed your paste.
15:29:58 <shachaf> dmwit: cmccann is talking about you.
15:29:59 <cmccann> shachaf, it's just my linear logic thing from a while back
15:30:04 <shachaf> http://hpaste.org/75222#line144
15:30:09 <cmccann> hahaha
15:30:21 <cmccann> that actually occurred to me while writing it
15:30:29 <edwardk> At least I know that if I slack off on my slides I'll only be embarassing me to the people present, and not everyone on the internet in perpetuity
15:30:53 <shachaf> edwardk: I heard half the Internet will be there.
15:31:16 <cmccann> which half, though?
15:31:18 <zzing_> If I have two functions, isDigit and isAlpha, how can I make a function that does an or relationship with them without doing it manually?
15:31:19 * hackagebot morfeusz 0.4.0 - Bindings to the morphological analyser Morfeusz  http://hackage.haskell.org/package/morfeusz-0.4.0 (JakubWaszczuk)
15:31:20 <edwardk> Well, they kind of had to be. Its not like they can watch online ;)
15:31:50 <hvr> zzing_: what would be "manually"?
15:31:59 <shachaf> zzing_: liftM2 (||) isDigit isAlpha
15:32:05 <edwardk> And I'm feeling better so I can't beg off due to being sick. ;)
15:32:05 <zzing_> hvr, writing a function
15:32:13 <shachaf> @pl \x -> isDigit x || isAlpha x
15:32:14 <lambdabot> liftM2 (||) isDigit isAlpha
15:32:26 <shachaf> @ty \x -> any ($ x) [isDigit, isAlpha]
15:32:28 <lambdabot> Char -> Bool
15:32:33 <shachaf> @pl \x -> any ($ x) [isDigit, isAlpha]
15:32:33 <lambdabot> flip any [isDigit, isAlpha] . flip id
15:32:38 <shachaf> That's going a bit far.
15:32:41 <jamiltron> Is there a function similar to zip, but when zipping if one list is larger than the other, you can specify a default value for the resulting list?
15:32:52 <shachaf> @ty or . sequence [isDigit, isAlpha]
15:32:53 <lambdabot> Char -> Bool
15:33:00 <cmccann> shachaf, seems lambdabot is flipping you off
15:33:01 <Noldorin> hey Philippa
15:33:03 <shachaf> zzing_: ☝, for a list.
15:33:32 <shachaf> jamiltron: Not in the standard library.
15:33:51 <shachaf> jamiltron: If you know which list is smaller, you can (++ repeat foo), I guess...
15:35:00 <edwardk> jamiltron: it comes up now and again, but its always just rewritten each time
15:35:21 <zzing_> shachaf, thank you.
15:35:24 <jamiltron> edwardk: That's what  I was afraid of.
15:35:38 * cmccann seems to recall elliott helping him add stupidly generic versions of that to his "these" library
15:35:43 <shachaf> I, too, have nightmares about rewriting helper functions involving lists.
15:35:47 <zzing_> :t liftA2 not isDigit
15:35:49 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
15:35:49 <lambdabot>     In the first argument of `liftA2', namely `not'
15:35:49 <lambdabot>     In the expression: liftA2 not isDigit
15:35:57 <edwardk> jamiltron: see zipWith' in http://blog.sigfpe.com/2006/09/practical-synthetic-differential.html
15:36:08 <zzing_> :t liftA2 not $ isDigit
15:36:10 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
15:36:10 <lambdabot>     In the first argument of `liftA2', namely `not'
15:36:10 <lambdabot>     In the first argument of `($)', namely `liftA2 not'
15:36:14 <shachaf> cmccann: Make it even more generic: Use Maybe (These a b)!
15:36:18 <zzing_> :t liftA not $ isDigit
15:36:19 <lambdabot> Char -> Bool
15:36:27 <shachaf> With an infinite stream of Nothings at the end.
15:36:32 <zzing_> :t liftA not isDigit
15:36:34 <lambdabot> Char -> Bool
15:36:36 <cmccann> shachaf, that's a remarkable terrible type, congratulations
15:36:45 <shachaf> ...Then you can just use (Either a b, Either a b)
15:37:02 <shachaf> Hmm, no.
15:37:08 <shachaf> What am I saying?
15:37:12 <shachaf> (Maybe a, Maybe b)
15:37:15 <zzing_> How does not not try to bind to isDigit?
15:37:21 * cmccann waits for shachaf to finish confusing himself
15:37:33 <zzing_> Or is it (liftA not) isDigit?
15:37:37 <shachaf> cmccann: What's confusing here? Maybe (These a b) = (Maybe a, Maybe b), isn't it?
15:37:56 <cmccann> yes
15:38:09 <cmccann> just wanted to make sure you weren't about to launch off into some other weird tangent :P
15:38:27 <shachaf> cmccann: That reminds me. What's type-level tan()?
15:38:32 <cmccann> hahahahaha
15:39:36 <Saizan> i bet you don't even have sin yet
15:40:11 <cmccann> I thought type-level sin = IO
15:40:14 <cmccann> :D
15:40:20 <shachaf> cmccann beat me to it. :-(
15:40:24 <cmccann> booyeah
15:40:39 <shachaf> @@ @run (@where rot13) "cmccann"
15:40:41 <lambdabot>   "pzppnaa"
15:40:44 <cmccann> :[
15:40:46 <shachaf> That doesn't even make sense.
15:40:56 <cmccann> I can't even pronounce it
15:41:24 <shachaf> @@ @run (@where rot13) "shachaf"
15:41:26 <lambdabot>   "funpuns"
15:42:10 <MostAwesomeDude> Are you about to say that your actual name, or some portion/mangling of it, is also "shachaf"?
15:42:21 <shachaf> cmccann: So I guess type-level cos would be OI?
15:42:33 <cmccann> shachaf, sounds legit
15:42:36 <shachaf> MostAwesomeDude: I wasn't about to say it, but it's true.
15:42:47 <MostAwesomeDude> That's some GEB right there.
15:43:12 <cmccann> that's the general consensus I think
15:43:25 <shachaf> Do I get a say?
15:44:49 <MostAwesomeDude> Sure?
15:44:58 <cmccann> shachaf, only non-fictional people get a say in whether or not they're fictional characters from a Hofstadter book
15:45:20 <cmccann> so if we decide you're not fictional then you can argue otherwise
15:45:20 <shachaf> cmccann: I'm non-fictional!
15:45:32 <MostAwesomeDude> Well, I'm convinced.
15:45:46 <MostAwesomeDude> Fictional characters can't wield exclamation points.
15:46:12 <cmccann> I dunno.
15:46:18 <cmccann> I'm still suspicious.
15:46:46 <maukd> are total languages strict?
15:47:01 <cmccann> maukd, does it matter?
15:47:33 <elliott> maukd: mu
15:47:35 <cmccann> the behavior when encountering undefined terms seems sort of irrelevant to a total language
15:48:03 <elliott> maukd: you can't really say they have strict or non-strict semantics, since those are defined in terms of _|_ :p
15:48:10 <cmccann> yeah, elliott has the best answer  :P
15:48:21 <elliott> you can implement a total language with call-by-name or call-by-value or any other order you want
15:48:24 <shachaf> Is Mu strict?
15:48:26 <elliott> and they will all work
15:48:27 <shachaf> > fix undefined
15:48:28 <lambdabot>   *Exception: Prelude.undefined
15:48:31 <shachaf> I guess os.
15:48:33 <loser> what is mu?
15:48:44 <cmccann> the noise a cow makes.
15:48:59 * cmccann is unhelpful
15:49:37 <elliott> cmccann: did you ever figure out the plumbing with that linear logic stuff?
15:49:53 <cmccann> elliott, I haven't really gotten back to it recently
15:49:55 <MostAwesomeDude> Couldn't you have a total Haskell, for example, just by failing to compile any function with an incomplete pattern match or guard?
15:50:10 <cmccann> MostAwesomeDude, don't forget non-termination
15:50:14 <elliott> MostAwesomeDude: f x = f x -- no incomplete patterns
15:50:21 <MostAwesomeDude> Ah, good points.
15:50:28 <maukd> a total language contains no non-strict function, therefore it is strict
15:50:31 <elliott> (if you try to extend your criteria here you will run into the halting problem)
15:50:43 <cmccann> the criteria here IS the halting problem
15:50:43 <MostAwesomeDude> (Yeah, I could believe that.)
15:50:44 <elliott> maukd: a total langauge contains no strict function, therefore it is non-strict
15:50:56 <elliott> (how do you define a total language as containing no non-strict function?)
15:50:58 <loser> so unlike C. haskell is turing-complete?
15:51:10 <elliott> loser: yes
15:51:17 <shachaf> C is arguably Turing-complete if you're allowed file I/O and read the spec in a particular way.
15:51:20 <maukd> wait, what
15:51:54 <elliott> shachaf: i think i will ask the c committee to put some arbitrary bounds on IO just to break that
15:52:46 <shachaf> elliott: johnw is on the C++ committee, apparently. Maybe it can "trickle down" from there.
15:53:16 <elliott> shachaf: the joke is C++, right?
15:53:25 <shachaf> jokew
15:54:06 <byorgey> MostAwesomeDude: also, even figuring out whether a set of guards is incomplete is undecidable
15:54:22 <byorgey> because they can be arbitrary boolean expressions.
15:54:36 <acowley> byorgey: What's the distinction between an F-algebra and a term algebra?
15:54:37 <maukd> insist on | True
15:54:57 <shachaf> @guarr
15:54:58 <lambdabot> Maybe you meant: arr yarr
15:54:59 <acowley> (I just sat down and where my buffer left off was your mention of using GADT syntax to introduce ADTs)
15:55:01 <byorgey> acowley: a term algebra is a free F-algebra.
15:55:27 <acowley> good answer!
15:55:30 <byorgey> or, an initial F-algebra.
15:55:48 <EvanR> i was thinking about haskell as a 'first language', how would you explain to someone the qualitative differences between a list and a vector/bytestring
15:55:54 <EvanR> String vs Text for example
15:55:57 <acowley> Hm
15:56:12 <EvanR> it makes sense to someone who knows C
15:56:26 <acowley> does the coincidence of initial and final algebras resulting from data type definitions then confuse usage of term algebra?
15:56:38 <rwbarton> "a String is a Text that uses sixty times as much memory"?
15:56:43 <acowley> haha
15:56:44 <EvanR> :\
15:56:58 <loser> I think of haskell Lists as streams
15:56:59 <acowley> String is linked list
15:57:17 <loser> both singly-linked lists and streams*
15:57:19 <byorgey> acowley: possibly.  I haven't actually thought about it deeply.
15:57:24 <EvanR> yes, someone new will not get the properties of 'linked list' or (probably even less) 'vector's
15:57:26 <EvanR> arrays
15:57:41 <EvanR> immediately
15:57:49 <EvanR> not familiar concepts
15:57:51 <rwbarton> right
15:57:52 <acowley> byorgey: I've been working on a document largely for my own edification that fleshes out the development of edwardk's lenses in more detail (for noobs like me) than I've seen elsewhere
15:57:57 <cmccann> using Text is like having words printed on paper, while String is like spelling everything out using alpha-bits
15:58:05 <byorgey> acowley: cool!
15:58:05 <acowley> byorgey: so the confusion of all these things is very much on my mind!
15:58:12 <loser> for complete novices, even the idea of assigning to a variable can be hard to grok ^^
15:58:23 <rwbarton> cmccann: it's like those ransom notes where each letter is cut out individually
15:58:25 <loser> in imperative programming*
15:58:29 <byorgey> loser: fortunately we don't have that in Haskell! =)
15:58:30 <EvanR> heh
15:58:47 <EvanR> thats another subject
15:58:57 <cmccann> rwbarton, that's only what it looks like if you force the entire String
15:59:03 <loser> `int x = 3; x = x + 1;/ // but I thought x was equal to 3?
15:59:26 <byorgey> it's half a ransom note, plus a note telling you how to contact the kidnappers to get the rest of the note
15:59:31 <cmccann> hahaha
15:59:33 <cmccann> yes
16:01:05 <byorgey> loser: I happened to watch a bit of one of Khan academy's videos about programming, and it said, "now, these are variables.  Forget everything your math teacher ever told you about variables..."  and I screamed and stopped the video
16:01:18 <pordan30> have there been any attempts - scala aside - at implementing something close to full f-omega-sub
16:01:20 <loser> ^^
16:02:13 <cmccann> byorgey, that's just horrifying :[
16:02:36 <Attic> Saizan: Hey just came back to say that I install GHC 7.4.2 and all or working well now! Thanks a lot :)
16:02:46 <Attic> all is working well*
16:02:47 <acowley> Yet the whole stateful assignment usage in mainstream PLs makes it an understandable thing to say
16:03:08 <Saizan> Attic: cheers :)
16:03:11 <EvanR> byorgey: at least hes honest
16:03:17 <byorgey> EvanR: indeed!
16:03:18 <Cale> byorgey: Hey, at least it's honest
16:03:19 <xispirito> very cool band these MC5 eh
16:03:20 <EvanR> usually everyone confuses variables together
16:03:26 <xispirito> ops, sorry, wrong channel
16:03:35 <byorgey> Cale: indeed!
16:03:54 <shachaf> very cool website this enlargeyourmortgage.com
16:03:56 <shachaf> oops wrong channel
16:04:00 <loser> lol
16:04:14 <pikkumanu> hey, i'm trying to write a type class parametric in a constraint (i'm calling it HasCoproduct and i want an instance to be for example a coproduct for monoids). does anyone know if it's possible in ghc to say that an associated datatype of a class should have a constructor only needs to work if some constraints for the parameters are met and that the datatype it returns should also satisfy some constraints?
16:04:23 <xispirito> i human, sorry =D
16:05:01 <deech> Is it possible to call an Agda function from Haskell?
16:05:12 <elliott> shachaf: It's down. :(
16:05:16 <elliott> how can I enlarge my mortgate now
16:05:39 <shachaf> elliott: sorry :'(
16:05:40 <Cale> Talk to Señor Cardgage!
16:05:45 <acowley> You don't often see an Agda function run.
16:05:50 <byorgey> deech: well, you can compile Agda to Haskell and then call that
16:05:54 <rwbarton> pikkumanu: the second part, yes
16:05:58 <rwbarton> er
16:06:18 <rwbarton> as long as there is no extra quantification involved
16:06:21 <deech> People who bought before the real estate crisis hate this guy.
16:06:27 <shachaf> @quote runtime.*agda
16:06:27 <lambdabot> cmccann says: the most common solution to prevent runtime errors in Agda is by not running the program
16:06:33 <pordan30> it's pretty common to encounter mutable variables in standard math texts, though; for instance, the text my school used on logic usually presented algorithms for e.g., unification using mutable variables.
16:06:43 <rwbarton> pikkumanu: for the first part, data types can't really depend on constraints anyways.
16:07:07 <deech> byorgey: So the functions don't get mangled or anything?
16:07:20 <deech> s/functions/"function names"
16:07:40 <byorgey> deech: I don't actually know exactly how it works
16:07:46 <pikkumanu> rwbarton: that's true, would just have captured the logic of what i'm trying to do. what's the syntax for saying the second part?
16:07:49 <byorgey> I've never done it myself.,
16:07:56 <rwbarton> pikkumanu: let me try HasProduct, since it sounds easier, I want to write instace HasProduct Monoid where data Product m n = P m n ?
16:07:57 <cmccann> @quote agda.*script
16:07:58 <lambdabot> mm_freak says: <mm_freak> i'd love to have an embeddable Agda type checker and evaluator  <mm_freak> that would make a great scripting language for haskell programs
16:08:11 <elliott> by the way has anyone used arch's ghc 7.6.1/cabal-install packages? they seem to be on cabal library 1.16.0, rather than 1.16.0.1, which makes me suspicious as the former was broken with cabal-install for me
16:08:33 <rwbarton> pikkumanu: ah so I think in your case there is this extra quantification, if I understand what you want to do
16:08:48 <deech> byorgey: So maybe this isn't intended use? I'm just learning about dependently typed languages and looking to see if I can write parts of my codebase in Agda.
16:09:11 <Jafet> Agda has an evaluator?
16:09:14 <pikkumanu> rwbarton: yes, i want to say, if m and n have a monoid instance, P m n should have a Monoid instance
16:09:36 <byorgey> deech: no, I think that is intended use.  Write and check your code in Agda, and then "extract" some Haskell code which doesn't have any of the proofs
16:09:37 * cmccann hacked something together once to quasiquote agda using TH
16:09:41 <rwbarton> pikkumanu: so normally the syntax is like--for example if I want to have a class for things that can be put into a sequence (dumb example)--class Sequenceable s where type List s
16:09:45 <rwbarton> I want List s to be a monoid
16:09:54 <cmccann> was very incomplete but did manage the important parts, i.e., you could type check some agda but not use it for anything
16:09:58 <rwbarton> so I would write class (Monoid (List s)) => Sequenceable s where type List s
16:10:03 <byorgey> cmccann: haha
16:10:16 <shachaf> cmccann: That sounds pretty complete to me.
16:10:31 <rwbarton> in your case I guess you want to say
16:10:59 <rwbarton> "class (forall m n. (c m, c n) => c (Product m n)) => HasProduct c where type Product c ..."
16:11:10 <rwbarton> unfortunately such fancy contexts don't exist
16:11:16 <rwbarton> at least, you can't write them directly
16:11:20 * hackagebot monadcryptorandom 0.5 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.5 (ThomasDuBuisson)
16:11:23 <cmccann> shachaf, it worked better than my attempt to embed Haskell in a quasiquote
16:11:23 <elliott> you can with thingy
16:11:24 <deech> cmccann: That sounds insane. And by that I mean beyond my capabilities at this point :).
16:11:27 <rwbarton> Dict?
16:11:29 <elliott> right
16:11:33 <rwbarton> yes
16:11:37 <cmccann> GHC didn't appreciate my attempt to use the GHC API from inside a TH splice
16:12:07 <rwbarton> pikkumanu, am I making any sense?
16:12:12 <pikkumanu> rwbarton: yes, what you wrote looks like what i want.
16:12:23 <rwbarton> right, but unfortunately GHC won't accept it :)
16:12:27 <rwbarton> so what you can do instead is
16:12:54 <rwbarton> data Dict c where Dict :: c => Dict c -- might as well define this in general if you are already using ConstraintKinds, it is also in some ekmett package on hackage
16:13:04 <edwardk> 'constraints'
16:13:29 <rwbarton> class HasProduct c where { type Product c...; buildDict :: Dict (c m) -> Dict (c n) -> Dict (c (Product c m n)) }
16:13:55 <edwardk> rwbarton: and you can write that quantified madness by using Data.Constraint.Forall with some work
16:13:56 <rwbarton> then wherever you need the c dict for Product c m n, unpack the one produced by buildDict
16:13:59 <rwbarton> oh really
16:14:03 <rwbarton> I should look into that--after dinner
16:14:11 <rwbarton> that's in constraints too I assume?
16:14:14 <edwardk> yep
16:14:21 <elliott> note to self: add "it is also in some ekmett package on hackage" to all documentation of declarations in future
16:14:29 <elliott> since it is a priori true
16:14:30 <edwardk> working with nicholas frisby to put out a new version of that module
16:14:41 <rwbarton> is it like, you build a two-arg constructor X c m n = Implies (Both (Dict c m) (Dict c n)) (Dict (Product m n)) or something
16:15:20 <rwbarton> and then some type class/type family magic turns "Forall X" into a class with the right method?
16:15:37 <rwbarton> I guess I ought to just read what you wrote
16:16:02 <edwardk> rwbarton: basically there is an implication inst :: Forall p :- p a
16:17:09 <edwardk> where :- can be used as typeclass implication
16:18:25 <kurtis> Hey guys, I'm extremely new to Haskell. I've just been reading over an excellent Haskell "book" online. I am curious about one thing before I get in too deep though; since you can only implement lists of objects that are the same (e.g. all numbers), how would one go about working with lists (not in the technical term) of data that are not all the same?
16:18:53 <elliott> usually you don't need such a thing
16:19:00 <shachaf> kurtis: There are a few ways of doing it, depending on what you're actually trying to accomplish.
16:19:05 <elliott> when you do this in an OOP language like, say, Python, you access all members of the list with the same general interface
16:19:10 <elliott> (by calling the same methods on them, etc.)
16:19:23 <elliott> so you can just represent this interface as a data type (a record, usually), and have a list of those
16:19:28 <pordan30> if you know the types of the values in the list, you would usually use a sum type
16:19:31 <elliott> of course, it depends on exactly what you are trying to do like shachaf says
16:19:48 <elliott> but that is the general idea for when just doing data MyData = AnInt Int | AString String doesn't suffice
16:19:58 <shachaf> pordan30: That's not really true.
16:20:22 <kurtis> Yeah, I'm going to assume I need to learn to program differently. But; for an example, let's say I am parsing JSON which has lists of atomic types. Would I have to use a string parser, then build multiple data structures?
16:20:45 <shachaf> kurtis: For JSON you would probably use a sum type.
16:21:16 <elliott> kurtis: as far as JSON goes you'd just define a type to represent json
16:21:26 <elliott> data JSON = JSONString String | JSONArray [JSON] | ... or whatever
16:21:26 <hpc> if i was feeling evil, i would parse a JSON value to (Maybe Double, String)
16:21:32 <hpc> or similar
16:21:37 <elliott> kurtis: but then you'd want to convert that into a nicer structure to actually use it, of course
16:21:41 <elliott> (and packages like aeson have functionality for this)
16:21:42 <shachaf> kurtis: That's because JSON is pretty much fundamentally untyped data, thouggh.
16:22:06 <kurtis> hmm, I suppose that makes sense. Still trying to let all of this soak in :)
16:22:10 <shachaf> kurtis: In Haskell you can use JSON, but you often try to add more types as soon as you can to make working with your data easier.
16:22:18 <rwbarton> -fdefer-type-errors should have been named -funtyped
16:22:28 <hpc> @quote funbox
16:22:28 <lambdabot> Veinor says: <Veinor> can't spell -funbox without fun!  <djahandarie> Veinor, can't write LISP without defun :-(
16:22:50 <shachaf> @quote funsafe
16:22:51 <lambdabot> shachaf says: You can't spell "-funsafe" without "fun" and "safe".
16:23:15 <pordan30> shachaf: if the types of the values are known, why wouldn't the general solution be to use a sum / variant type? is there a better solution that doesn't require using e.g., heterogeneous lists?
16:23:35 <shachaf> pordan30: It depends on what operations you're going to be doing on your data.
16:23:42 <shachaf> It's just the expression problem, really. :-)
16:24:16 <hpc> ahaha! "-funfolding-fun-discount"
16:24:51 <pordan30> shachaf: makes sense
16:25:31 <Cale> pordan30: The other general solution is to take all the operations you want to be able to perform on the data in your list, and just apply them to all the elements, storing the results, which is then a homogeneous list.
16:25:38 <kurtis> Any recommendations on some documentation or even code examples on working with data that would typically be collected in a heterogenous data structure? It doesn't have to be JSON specific; that was just an example I threw out there.
16:26:05 <rwbarton> maybe that scheme interpreter text
16:26:17 <kurtis> good diea, rwbarton
16:26:26 <kurtis> idea*
16:26:26 <deech> Is there a tutorial for the various type class extensions? I get multi parameter typeclasses but I don't understand OverlappingInstances and UndecidableInstances.
16:26:31 <rwbarton> i forget the exact name, do you know the one?
16:26:38 <rwbarton> write yourself a scheme in 24 hours or something like that
16:26:40 <kurtis> yeah, something along the lines of 24 hours
16:26:49 <shachaf> 48 hours
16:27:00 <shachaf> That's pretty old, though.
16:27:00 <kurtis> haha, thanks guys
16:27:02 <Cale> kurtis: Whenever you're putting things into a list, unless you're just a shitty programmer, those things have something to do with one another -- there's implicitly some loop which is going to happen later to process the elements of the list.
16:27:14 <rwbarton> well yeah, nowadays you can do it in 24 ;)
16:27:22 <lightquake> i'm not sure how to organize my types. i have a World type which contains an [Entity], and each Entity has an aiUpdate member that has a function of type Entity -> World -> UpdateAction; each UpdateAction can spawn more Entities, so i have to have all of these type declarations in the same file
16:27:32 <shachaf> rwbarton: FSVO "scheme"
16:27:35 <Cale> kurtis: and so it comes down to: what is the thing that they have in common?
16:27:49 <shachaf> Cale: They're all instances of Typeable!
16:27:49 <rwbarton> sometimes lists are also used in certain languages to represent records (e.g. I "know"/hope the first element is an integer representing x, the second is an integer representing y, the third is a string for the name)
16:27:52 <Cale> kurtis: Maybe it's that they belong to a finite set of possible cases.
16:28:08 <ion> [ bananas, giraffe, shachaf, google, laptop ]
16:28:08 <Cale> kurtis: Maybe it's that certain operations are available to perform on them
16:28:20 <rwbarton> obviously in those cases you just wouldn't use a list in Haskell but instead a tuple or a proper record/data type
16:28:28 <ion> ++ [ blue, serious, accidentally ]
16:28:39 <lightquake> is there any way for me to break up mutually-recursive types?
16:28:42 <Cale> kurtis: In the first case, we can construct a new data type with constructors for each of the cases, so that we can discriminate which case we have when we take the elements out again
16:28:58 <typoclass1> kurtis: be aware that heterogenous lists are pretty unusual in haskell. somebody said the other day that to the beginner they look like they are a great solution for all kinds of things, and to the more experienced haskell they are pretty unnecessary and even harmful
16:29:01 <ion> lightquake: What do you mean by “break up”?
16:29:11 <pordan30> cale: unless i'm misunderstanding, isn't that the same idea; the only difference is that instead of discriminating on values of a sum type, you're performing case analysis somewhere else and eliminating the intermediate data structure?
16:29:18 <typoclass1> kurtis: so except for some special cases where you really have bizarre untyped-but-still-somehow-typed data that you just parsed from some external source ...
16:29:19 <kurtis> typoclass1, Yeah; I figured. That's why I came here to ask.
16:29:19 <Cale> kurtis: In the second, we can construct a type of record of all the operations we want to be able to perform on the data -- the uniform interface that they satisfy, and store the records of those operations instead.
16:29:23 <lightquake> like, right now i have all of them in a top-level Types module, so i 'import Types' and get World, Entity, UpdateAction, etc
16:29:31 <lightquake> but this seems... bad to me
16:29:37 <typoclass1> s/haskell/haskeller/, even :)
16:29:41 <elliott> lightquake: that's actually fairly common
16:29:45 <elliott> you can do ghc-only stuff with hs-boot files but it is gross
16:29:59 <Cale> pordan30: ummm... perhaps on some fundamental level that's true
16:29:59 <ion> .das-boot
16:30:21 <Cale> pordan30: but it looks and feels rather different when you're doing it.
16:30:30 <lightquake> elliott: huh, didn't know that exists
16:30:32 <pikkumanu> rwbarton: ok, thanks for pointers, i'll look at Data.Constraint.Forall also... and the dict thing... i'm having trouble reading that.. so, i'd say buildDict undefined::(Monoid [Int]) undefined::(Monoid [String]) and get Dict::(Monoid (Product [Int] [String])) and how do i use that?
16:30:36 <rwbarton> in theory (Haskell 98) you can just write mutually recursive modules
16:30:45 <lightquake> reminds me of .h files
16:30:47 <lightquake> wait, you can?
16:30:54 <rwbarton> pikkumanu: not undefined
16:31:02 <rwbarton> you use Dict, the constructor of Dict
16:31:18 <Cale> kurtis: does that all make sense?
16:31:22 <rwbarton> and it implicitly gets the appropriate class dictionary attached to it, if type inference is working well that day
16:31:26 <rwbarton> the way you use it is something like
16:31:40 <rwbarton> case buildDict Dict Dict of Dict -> {- here there will be an instance for c (Product c m n) -}
16:31:56 <Cale> kurtis: There are variations on these themes, like existential types and GADTs and such, but more or less, that's what it comes down to.
16:31:58 <rwbarton> if that doesn't work, add more (:: Dict foo) :)
16:32:45 <kurtis> Cale: Umm, sort of :) I'm definitely taking notes though. I think I might need to learn more about Haskell, or functional programming in general, before I feel confident that I understand what you're saying
16:33:29 <elliott> lightquake: you "can"
16:33:31 <elliott> but GHC won't like it
16:33:36 <Cale> kurtis: It does force you to think a little bit about what it is that you're doing. You can't just make up random conventions like "the last element of this list is some random thing which is unrelated to the others"
16:33:58 <Cale> kurtis: If you want to store other things, make a data type and store them alongside the list, or in another list.
16:34:57 <shachaf> "ddoublle lleterss are hard"
16:35:02 <shachaf> Wrong channel.
16:35:19 <kurtis> Cale: So let's say I pull in data from an external source and want to store it in some data structure (probably lists) to actually use the data. You're saying that I should figure out how I want to use the data before worrying about how/where to store it? Or am I totally off base there
16:35:34 <rwbarton> lightquake: it is a deficiency of GHC that it does not implement this part of the Haskell 98 standard
16:35:45 <elliott> i bet edwardk's compiler supports mutually-recursive modules
16:35:54 <edwardk> nope
16:35:59 <shachaf> I bet @ supports mutually-recursive modules.
16:36:01 <shachaf> Oh wait.
16:36:05 <Cale> kurtis: You should think of a list as the data structure form of a loop. Just like how a loop either doesn't run at all, or consists of a single iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
16:36:47 <edwardk> it probably _should_, but it doesn't
16:36:54 <Cale> kurtis: Well, either you have to decide up front what kinds of data your program is going to accept, *or* you have to find out what all the operations on that data you're going to need are.
16:37:08 <edwardk> shachaf: that looked like you wrote it during an earthquake
16:37:16 <Cale> There are various funny ways that you can get around making up your mind completely
16:37:21 <Cale> But basically this is true
16:37:28 <shachaf> Still not in Boston, edwardk. :-)
16:37:32 <typoclass1> kurtis: have you come across 'data' yet? basically you can say 'data Result = FileNotFound | AccessDenied | SomeOtherError | AllWentWell'. what is possible is a list of those, i.e. a [Result]. and any Result, from the list or from wherever, can be taken apart by pattern matching, so you could have an (admittedly slightly silly) function "isOK :: Result -> Bool" which could be implemented like this: "isOK AllWentWell = True", "isOK FileNot
16:37:48 <shachaf> data Result = False | True | FileNotFound
16:38:03 <typoclass1> shachaf: classic thedailywtf?
16:38:39 <kurtis> typoclass1, looking at the example, I don't believe I have. but it looks like something I should definitely be learning
16:38:54 <pikkumanu> rwbarton: just to see if i got this: any implementation of buildDict will have to be buildDict Dict Dict = Dict and an appropriate instance of for example Monoid (Product m n) will have to be in scope for ghc not to complain. but then why does pattern matching change anything about there being an instance?
16:39:07 <Cale> kurtis: Well, yeah, it'll help to understand data declarations :)
16:39:33 <Cale> kurtis: basically, you can define your own datatype somehow to be able to treat all the cases of the data you're stuffing into the list
16:39:42 <kurtis> Cale: haha yes! I've only been doing the basics so far. "implicit" declarations, lets, and of course lists + tuples. nothing advanced (or really even useful) yet
16:39:43 <typoclass1> kurtis: absolutely :) the 'data' keyword is much more used and much more basic than the complicated tricky stuff that gives you true heterogenous lists ...
16:40:24 <kurtis> So I could have a datatype that could contain a number or a string?
16:40:33 <Cale> kurtis: and what I was getting at before is that there are two fundamental ways to go about that (and they're sort of at the ends of a spectrum really)
16:40:42 <shachaf> Yes. Or you could use (Either Integer String), which already exists. :-)
16:40:44 <typoclass1> kurtis: here is the chapter on 'data' from a pretty good book (available free of charge) http://learnyouahaskell.com/making-our-own-types-and-typeclasses
16:41:02 <kurtis> typoclass1, Sweet, that's the book I've been reading on. I haven't gotten that far yet.
16:41:05 <shachaf> typoclass1: Understanding the expression problem thing is important here anyway.
16:41:12 <shachaf> "What are heterogeneous lists, really?"
16:41:13 <Cale> kurtis: You either define a datatype with cases for each of the things you want to be able to handle (and then the code that operates on these will look at which case it has for each element and do something based on that)
16:41:34 <typoclass1> shachaf: lemme google what the expression problem is
16:41:34 <kurtis> Cale: Yeah, that makes a *lot* more sense. I didn't think that was possible in haskell
16:41:40 <Cale> kurtis: Or, you'll figure out some common interface of functions your data supports, and make a record of *those*
16:41:51 <Cale> which should be familiar if you've done any OO programming
16:42:26 <kurtis> So in practicality, I can have a Heterogeneous list; I just need to define exactly what Types that list will include before I can use or construct it?
16:42:29 <rwbarton> pikkumanu: yes, that's right regarding the implementation.
16:42:37 <Cale> yes
16:42:48 <Cale> and all the elements of the list will then have the same type
16:42:50 <kurtis> sweetness! Thank you guys, that clears it up so much
16:42:53 <rwbarton> pikkumanu: if you want to use the Monoid (Product m n) instance somewhere and you know what m and n are, then you can just use it
16:42:53 <Cale> but that type will have many cases
16:43:02 <lispy> > do 5 -- /me is still worked about up about this
16:43:03 <lambdabot>   5
16:43:11 <lispy> It just ain't right.
16:43:11 <Cale> and you'll be putting explicit constructor tags on the data to say which case
16:43:31 <rwbarton> pikkumanu: however m and n are type variables and you just have Monoid m and Monoid n constraints, you can pattern match on the result of buildDict to obtain a dictionary for Monoid (Product m n)
16:43:34 <shachaf> > do y / do x
16:43:35 <lambdabot>   y / x
16:43:42 <rwbarton> of course you do not really change the existence of the instance
16:44:12 <rwbarton> you are just proving to ghc that it exists (or telling ghc how to produce it, depending on your view)
16:44:31 <startling> is there a way I can have a general is-this-made-with-this-constructor function?
16:44:34 <startling> maybe with th?
16:45:54 <Cale> kurtis: For example,   data Colour = RGB { red, green, blue :: Word8 } | CMYK { cyan, magenta, yellow, black :: Double } | Lab { lightness, labA, labB :: Double }  (this is maybe not the best approach, you might prefer a type parameter here)
16:46:38 <Cale> kurtis: Or even   data Tree a = Tip | Branch a (Tree a) (Tree a) -- a type for binary trees, whose branch nodes have values of type a
16:46:50 <kurtis> One more quick question; and I don't mean to cause a war or anything crazy like that. I just haven't had much luck with Google. I was torn between Clojure and Haskell. I've seen Clojure used in really cool projects but started learning Haskell because of its purity. Before I dig in too deep, are there any good reasons to choose one or the other as a general programming language? Or will I be fine if I keep going with Haskell?
16:47:18 <kurtis> Cale, thanks! Yeah that's what I kind of pictured in my head. You've definitely helped me understand quite a bit
16:47:19 <Cale> kurtis: You'll be fine. If you know Haskell, learning Clojure shouldn't be too much of a struggle.
16:47:21 <typoclass1> kurtis: clojure has no types, hasn't it?
16:47:41 <Cale> Right, Clojure is dynamically typed.
16:47:53 <joeyh> anyone know what PINNED is in a heap profile?
16:48:09 <roconnor> edwardk: what do you think of http://www.reddit.com/r/haskell/comments/11mnw5/wiggling_sums_a_somewhat_interesting_traversable/c6o0u5q ?
16:48:25 <Jafet> startling: toConstr
16:48:37 <edwardk> roconnor: nice =)
16:48:50 <kurtis> typoclass1, no clue. The only other FP I've ever actually used is Scheme back in the university :) From a practical standpoint, I can't say that I'm experienced enough with coding in multiple type systems to decide that is a reason for me to pick one language over another, other than to avoid runtime errors.
16:48:55 <startling> @hoogle toConstr
16:48:56 <lambdabot> Data.Data toConstr :: Data a => a -> Constr
16:49:02 <startling> Jafet: neat, thanks
16:49:04 <roconnor> edwardk: I'm not sure if I'm supposed to avoid holesOf
16:49:13 <edwardk> holesOf is pretty safe
16:49:28 <edwardk> and this is more or less its stated purpose
16:49:45 <roconnor> safety wasn't my concern.  My concern is that Plated is an interface provided for legacy purposes only
16:50:07 <typoclass1> kurtis: for me the impressive thing is that the haskell compiler is so helpful. it tells me all kinds of things that are wrong or might be wrong with my code. it really takes very good care of me. the overall effect is that it's hard to get things to compile, but once they do, there's rarely much more debugging to do. in contrast, in a dynamic language you're on your own, and once something runs, the "fun" only starts
16:50:32 <edwardk> nah, Plated provides a lot of combinators that were mostly inherited from uniplate, but many of which are very useful for other traversals
16:50:43 <edwardk> e.g. partsOf, holesOf, contextsOf, are all fairly general purpose
16:50:58 <pikkumanu> rwbarton: ok, so you are saying that ghc may not necessarily be able to find out how to get a Monoid (Product m n) instance... but isn't the only way to sucessfully write a HasProduct Monoid instance if i can write a buildDict implementation and for that to work there has to be something like instance (Monoid a, Monoid b) => Monoid (Product a b) in scope? actually exactly what i wanted, only took me a while, it's already a little 
16:51:32 <pikkumanu> i'm only wondering about your statement about telling ghc about this instance by case-matching
16:52:09 <edwardk> i don't view Plated as legacy at all. to me its an integral part of the lens api
16:52:22 <kurtis> typoclass1, haha I can completely agree. I work in Python a lot; I spend way too much time debugging. On the other hand when I used to work in C and Java a lot; typically if it compiled it was good to go. Of course Haskell is even better in that aspect (in my opinion) with the implicit typing. I just read the page about 'data' in the book, and I think it looks really cool
16:52:26 <roconnor> edwardk: oh good.
16:52:51 <edwardk> there are lots of things from that module you can't really do any other way
16:52:57 <edwardk> e.g. rewriteOf, etc.
16:52:58 <glguy> edwardk: maybe update reducers to not depend on bytestring < 0.10 at some point so we can try trifecta out on 7.6.1?
16:53:03 <rwbarton> pikkumanu: well it's only because of this buildDict that it is true at all that Monoid m and Monoid n together imply Monoid (Product m n), right
16:53:10 <edwardk> glguy: sure
16:53:29 <Peaker> kurtis, Haskell is much better in that regard not just because of the implicit typing. Also because of purity and generalized types -- the type checker checks much more of your logic
16:54:03 <rwbarton> how could GHC type check a function that uses the Monoid (Product m n) instance but only has Monoid m and Monoid n constraints otherwise
16:54:09 <edwardk> glguy: installing and testing now on 7.6.1
16:54:26 <typoclass1> Peaker: let's not forget Maybe, which looks like the smallest simplest thing, but actually eliminates a whole class of bugs (null pointer exceptions)
16:54:30 <glguy> edwardk: great, thanks for doing that
16:55:05 <edwardk> uploaded and pushed
16:55:09 <typoclass1> kurtis: yup :) then welcome aboard, and be aware that you might lose all interest in doing stuff in dynamic languages ;)
16:55:15 <Peaker> typoclass1, yeah, sum types allow for much more precise types which helps a lot too
16:55:24 <pikkumanu> rwbarton: because, because of the existence of buildDict there will have to be instance (Monoid a, Monoid b) => Monoid (Product a b) somewhere, won't there?
16:55:27 <Cale> kurtis: You'll feel that C and Java's type systems are too weak and don't prevent enough bugs once you've used Haskell for a while
16:55:32 <edwardk> droppingWhile may take until after my talk for me to get some bandwidth to figure it out
16:55:35 <glguy> edwardk: feel free to take your time if you have something else to do :-p
16:55:42 <Cale> kurtis: It's like the difference between Python and Java again
16:55:44 <kurtis> One more quick question from those of you who have built some decently complex programs in haskell. It took me a while of using Python to understand how truely slow it is. I love the language, but sometimes I find myself reverting to C. 90% of the time, Python is just fine though. Will I find this to be the same with GHC? Or will I get even better results in regards to performance at this stage of the GHC implementation?
16:55:45 <edwardk> thats what i'm doing with droppingWhile ;)
16:55:50 <rwbarton> pikkumanu: not really, I could implement buildDict Dict Dict = undefined
16:56:03 <kurtis> haha, awesome guys! I'm glad I jumped into Haskell
16:56:19 <rwbarton> it is only once I pattern match on the Dict constructor that I can be sure that the Monoid (Product m n) dictionary really exists
16:56:21 * hackagebot reducers 3.0.0.1 - Semigroups, specialized containers and a general map/reduce framework  http://hackage.haskell.org/package/reducers-3.0.0.1 (EdwardKmett)
16:56:26 <glguy> edwardk: How are you planning to implement that? Seemed tricky
16:56:27 <ion> “Oh, crap! I just stepped on Haskell.”
16:56:40 <edwardk> glguy: its just a paramorphism
16:57:00 <edwardk> just a different 'direction' of paramorphism than i offer through paraOf
16:57:04 <Jafet> Don't jump into a python
16:57:08 <typoclass1> kurtis: ghc is pretty clever, and afaik haskell is always near the top in those speed comparisons. i don't think it'll ever be as slow as python
16:57:12 <edwardk> that goes down from children, this needs to go laterally through the traversal
16:57:12 <Peaker> kurtis, generally the performance is far better than Python, except when you naively use the String type - then it can be much worse
16:57:13 <Cale> kurtis: Well, Haskell programs are compiled to native code. Once you start to understand how Haskell code actually evaluates, you'll be able to get things usually within a factor of 2 or 3 of C code without any trouble, and then refine things from there if needs be.
16:57:27 <tumdum> i tried hoogle but could not find anything like this: https://gist.github.com/f4dcac83d1d0749be69c is this already somewhere in standard libs?
16:57:31 <edwardk> its easy enough to implement efficiently with the bazaar, it just takes some serious thought.
16:57:48 <edwardk> roconnor could bang it out in a heartbeat ;)
16:57:55 <Cale> kurtis: But the tutorials are a bit bad at teaching this stuff still.
16:58:13 <edwardk> i can also implement it using foldrOf under the hood
16:58:15 <Peaker> kurtis, it's good enough that on my current project I spend a tiny fraction of my time worrying about performance, whereas with Python I spent a pretty large one
16:58:24 <typoclass1> Cale: yeah, performant haskell seems to be something of a black art
16:58:37 <edwardk> implementing dropWhile using foldr is a fun exercise. i seem to recall it came up in a monad reader article
16:58:44 <glguy> edwardk: "easy enough" … "serious thought" ...?
16:58:45 <edwardk> its basically using foldr as a fixed point
16:58:48 <Cale> It's not so much that it's particularly hard, it's just hard to teach, I think.
16:59:01 <kurtis> Very nice! I wrote a dirty problem solver using a Genetic Algorithm in Python. because of all of the recursive mem copies, it was insanely slow. I wrote the same program in C, just using simple 1-dimensional arrays and the speed boost was pretty extreme. Hopefully I don't get into any bad habits with Haskell while learning
16:59:09 <Cale> It's hard to teach how to write fast code in any language though.
16:59:11 <edwardk> glguy: meaning i know generally what to do and that its possible, just want to implement the most elegant and high performance solution
16:59:19 <glguy> Ah, OK.
16:59:55 <edwardk> basically once i know how to implement it the boring way, i can usually map that back to the bazaar by turning my brain inside out
17:00:19 <glguy> You mean the Bazaar type, right?
17:00:34 <Jafet> How do you do that in three dimensions
17:00:46 <typoclass1> tumdum: hm ... i think the "Nothing -> mzero" might be redundant. isn't there a MonadPlus instance for Maybe?
17:00:48 <shachaf> The famous "bazaar twist".
17:00:50 <typoclass1> @instances MonadPlus
17:00:51 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:00:58 <copumpkin> I still want a proof of the equivalence of the bazaar definitions
17:01:19 <copumpkin> I guess I could try proving it myself
17:01:25 <edwardk> copumpkin: i welcome you to code it up in coq or agda
17:01:34 <tumdum> typoclass1, its there to move from Maybe to any other monad+
17:01:35 <edwardk> glguy: yeah
17:01:39 <kurtis> typoclass1, Cale, Peaker: Thanks guys for all of the good information! I think I'm pretty set with Haskell. I might be back for some questions but I'll be sure to finish reading that book first. I appreciate the help
17:01:47 <roconnor> edwardk: hmm, the function doesn't work on infinite lists :(
17:01:49 <copumpkin> edwardk: I'd imagine it relies on parametricity to a degree
17:01:55 <edwardk> roconnor: doh
17:02:04 <edwardk> copumpkin: ok, miniagda ;)
17:02:10 <roconnor> I blame holesOf
17:02:12 <shachaf> What's miniagda?
17:02:12 <roconnor> not sure
17:02:13 <copumpkin> but I guess I could just carry the extra naturality proof
17:02:17 <cmccann> kurtis, which book are you reading?
17:02:27 <glguy> I thought that microadga was the one with parametricity
17:02:27 <edwardk> roconnor: yeah, its cute, but apparently limited
17:02:34 <kurtis> cmccann, http://learnyouahaskell.com/
17:02:35 <copumpkin> megagda
17:02:38 <edwardk> glguy: that could be it. i get confused
17:02:47 <Cale> kurtis: Check this out, this is from 2007, and the library it describes is now used as a foundation for a lot of other stuff: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.90.3166&rep=rep1&type=pdf
17:02:52 <roconnor> I'm not sure if it is possible to make holesOf lazy.
17:02:55 <cmccann> kurtis, yeah, that's pretty popular :]
17:03:10 <shachaf> cmccann: Weren't you going to write a Haskell book?
17:03:15 <edwardk> the issue i think is that holesOf isn't as lazy as it perhaps could be
17:03:18 <kurtis> Cale: Very nice, that'll come in handy
17:03:18 <Cale> kurtis: it's a great example of how you can get things to go fast in a high level language by taking advantage of your high-level knowledge of what's going on
17:03:21 <cmccann> shachaf, maybe one of these days
17:03:29 <shachaf> Maybe that was Cale.
17:03:34 <edwardk> roconnor: if you wanted to concoct a lazier version of holesOf, I'd welcome the patch
17:03:37 <cmccann> I'd need both a clear idea of what I want to do differently, and enough motivation to do it
17:04:04 <pikkumanu> rwbarton: ok... but the only situation where i will actually be needing to prove the existence of the dictionary in this way is if the function that i'm writing is actually polymorphic in the constraint as well - otherwise the instance i'm looking for either is in scope (and i have a proper buildDict implementation) or it isn't there and buildDict is implemented with undefined - true?
17:04:05 <ion> > let dw p = foldr (\x xs -> if p xs then xs else x:xs) [] in dw (<5) [0..]
17:04:06 <lambdabot>   No instance for (GHC.Num.Num [a])
17:04:06 <lambdabot>    arising from a use of `e_150' at <inte...
17:04:11 <Cale> shachaf: Perhaps it was me
17:04:12 <shachaf> cmccann: Instead of being bad, be good.
17:04:14 <cmccann> well, Cale has already written more than a book's worth on the subject helping people in #haskell
17:04:18 <kurtis> cmccann, Is that a good book to use? Or will I be picking up any bad habits or old teachings?
17:04:20 <shachaf> Cale: I think it was both of you.
17:04:23 <ion> > let dw p = foldr (\x xs -> if p x then xs else x:xs) [] in dw (<5) [0..]
17:04:24 <lambdabot>   [5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,3...
17:04:29 <cmccann> kurtis, LYAH is a fine place to start!
17:04:32 <edwardk> roconnor: it sounds like an interesting challenge. i'm just buried in trying to improve my slides before tomorrow's talk
17:04:37 <cmccann> it's one of  the most common recommendations for beginners
17:04:40 <rwbarton> pikkumanu: "the function you're writing" -- the one that wants to use buildDict?
17:04:47 <edwardk> i was sick all week and left the slide improvements to the last minute
17:04:47 <roconnor> edwardk: I'll look into it later
17:04:52 <shachaf> Cale: I heard you, monochrom and Gracenotes were going to merge into one super-IRCer by the name of "GraceCale"
17:04:54 <rwbarton> yes, you would only need buildDict when the function is polymorphic
17:05:01 <edwardk> Calenotes
17:05:13 <shachaf> edwardk: I don't think that gets monochrom into it.
17:05:23 <rwbarton> but who writes functions that aren't polymorphic?? :)
17:05:31 <kurtis> cmccann, That's great. I've found it really easy to follow so I was hoping it was decent :)
17:05:35 <pikkumanu> rwbarton: yes, the one that wants to use c (Product m n) - i'd only need the case-trick if the function is polymorphic in c
17:05:41 <cmccann> edwardk, that would be like cliffnotes, except with a few standard terms redefined in order to confuse newbies?
17:05:42 <rwbarton> or polymorphic in m & n
17:05:43 <edwardk> shachaf: ah
17:05:44 <cmccann> :t (.)
17:05:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:05:47 <shachaf> rwbarton: It's my #conduct!
17:06:10 <shachaf> No polymorphism.
17:06:25 <shachaf> Wait, Crawl was the thing you played.
17:06:26 <Jafet> Monomorphism restriction
17:06:37 <rwbarton> I've played "that other game" too.
17:07:12 <cmccann> shachaf, you'd like my profile here: http://gamedev.stackexchange.com/users/983/c-a-mccann
17:07:28 <pikkumanu> rwbarton: but if it's not polymorphic in c, then either there is an instance or there isn't - if there isn't, then i'd just be shifting a compile-time error to a runtime error when pattern matching Dict against undefined fails
17:07:33 <rwbarton> pikkumanu: I guess I see what you are saying, and indeed "case buildDict Dict Dict of Dict -> " is a sort of boilerplate which one would like to eliminate
17:07:43 <Cale> shachaf: It turns out that most of us are an AI program written by Simon Marlow to simulate users in this channel and drum up support for Haskell over time.
17:07:56 <ion> > let tw p = foldr (\x xs -> if p x then x:xs else []) [] in tw (< 5) [0..10]
17:07:57 <lambdabot>   [0,1,2,3,4]
17:07:58 <rwbarton> pikkumanu, oh
17:08:01 <shachaf> cmccann++
17:08:08 <rwbarton> pikkumanu: yes, I think you are right, sorry
17:08:29 <rwbarton> somewhere there is (presumably) an "instance (Monoid m, Monoid n) => Monoid (Product m n)" which you can use
17:08:44 <cmccann> shachaf, in hindsight I'm not sure why I didn't work in a better pun on "polymorph" though...
17:08:59 <rwbarton> so yeah, it's only polymorphic-in-c functions which would need buildDict
17:09:51 <edwardk> Cale: You're not supposed to directly admit it.
17:10:23 <pikkumanu> rwbarton: ok, thanks a lot! and thanks for being patient enough to discuss this with me until it made sense for me as well :-) will implement this tomorrow... now i'm going to bed, it's already late.
17:10:27 <shachaf> cmccann: A (0:0) wand of callCC? Do you get it back when you successfully wrest it?
17:10:32 <rwbarton> yep, no problem
17:12:12 <shachaf> cmccann: http://www.uptoisomorphism.com/ is kind of empty.
17:12:12 <cmccann> shachaf, probably like a 20% chance based on luck with a x2 modifier if you name your character "oleg" or something
17:12:34 <cmccann> yeah
17:12:39 <cmccann> I should make a website one of these days
17:12:54 <shachaf> cmccann: You should come to the lens talk tomorrow, by the way!
17:13:04 <Cale> Wands of callCC are very useful as a way to cheat death.
17:13:27 <Jafet> They cause confusion, though
17:13:47 * cmccann is still most amused by "blessed greased fixed point" 
17:13:59 <cmccann> a joke very few people in the world will ever get
17:14:04 <shachaf> cmccann: I got it!
17:14:40 <ion> > let br p = foldr (\x ~(as,bs) -> if p x then (x:as,bs) else ([],x:bs)) ([],[]) in br (<5) [0..]
17:14:41 <lambdabot>   ([0,1,2,3,4],[5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,...
17:15:17 <edwardk> Cale: It is better if you can just get a callCC innate ability using a wish or rakshasa or something. Then you don't have to rely on the external device to cause confusion, but can do so innately.
17:15:18 <acowley> Is it possible to have pandoc compile embedded LaTeX into image snippets that are then embedded in HTML output?
17:16:46 <rwbarton> callCC is basically savescumming I guess
17:16:47 <edwardk> Jafet: its also useful when you want to go off and learn the skills to finish the current fight, and then come back to where you left off later.
17:17:09 <shachaf> rwbarton: What are delimited continuations?
17:17:10 <rwbarton> oh, well it depends on what state is global
17:17:31 * cmccann assumed that wand charges would not be restored after invoking a continuation
17:17:35 <edwardk> rwbarton: its like coming across a locked door, then going off picking up a few levels of wizard or rogue, and then using knock or pick locks later
17:17:45 <cmccann> not that I really thought things through that much since I was just adding cheap jokes to my profile :P
17:17:56 <ion> acowley: Dunno, but i’d consider http://www.mathjax.org/
17:17:56 * shachaf suspects edwardk isn't talking about the same game here.
17:17:58 <Jafet> Clearly wands of callCC are broken
17:18:08 <Jafet> Perhaps they should be wands of shift/reset
17:18:31 <edwardk> Wands of delimited continuation could be pretty useful
17:19:07 <cmccann> delimited continuations would work better with the whole roguelike scenario yes
17:19:07 <acowley> ion: I don't know how LaTeX packages work out with mathjax output
17:19:49 <edwardk> cmccann: i think they should be one-shot continuations, too, just in case.
17:19:50 <acowley> edwardk: I couldn't find a good reference for F-algebroids (a -> f b) … do you have any suggestions?
17:19:53 <Jafet> Well, there would be a shift wand and a reset wand, and if you didn't have both you could be stuck in time.
17:19:59 <edwardk> acowley: roconnor made up the word =P
17:20:05 <acowley> I figured as much
17:20:14 <ion> acowley: That’s why i said “consider”, not “use”, not knowing your exact use case. :-)
17:20:23 <acowley> edwardk: I've been making up diagrams and such for everything that builds into lens
17:20:31 <dolio> Why is that an algebroid?
17:20:43 <cmccann> edwardk, and with restrictions similar to levelporting and wands of wishing, if this is still nethack-ish
17:20:43 <edwardk> there is a more principled foundation i think from talking through with cale and rwbarton, but i'm going to pass on working through it right now
17:20:56 <acowley> dolio: I gather it's some notion of an equivalence between F(A) and F(B)
17:20:56 <Saizan> coalgebroid, surely
17:21:05 <acowley> Saizan: yes, right
17:21:57 <acowley> Well, the good news is that things seems to work out fairly tidily
17:21:59 <rwbarton> I guess if you had a bunch of objects x_i, i in I and maps x_i -> F x_j for all i, j, that could be a sort of "F-algebroid"?
17:22:02 <edwardk> technically the a and b aren't completely independent there
17:22:22 <edwardk> they are instances of an indexed family of some sort
17:22:28 <roconnor> IIRC algebroids was in the n-category thingy
17:22:32 <rwbarton> however I have no idea what the context is so this is probably even farther afield
17:22:43 <acowley> edwardk: What does that restriction imply?
17:22:58 * Cale wonders how long until people are talking about lax 2-lenses
17:23:06 <acowley> roconnor: Yes n-cat describes them, but it didn't seem a direct connection to this application
17:23:08 <Cale> (whatever those are)
17:23:37 <acowley> edwardk: does that family impose some restrictions on its indices?
17:23:37 <edwardk> (c -> f d) -> a -> f b   is really (inner i -> f (inner j)) -> outer i -> f (outer j)   for a couple of type families inner and outer parameterized on arguments of the same kind
17:23:42 <edwardk> acowley: exactly
17:24:08 <shachaf> edwardk: What does it mean when you have more than one letter next to each other without a space?
17:24:11 <edwardk> that restriction means you should be able to choose i = j, and get (c -> f c) -> a -> f a for any legal lens or traversal
17:24:16 * shachaf isn't familiar with that syntactic element of types.
17:24:31 <shachaf> Is it just shorthand for "i n n e r"?
17:24:34 <edwardk> shachaf: i dunno. i never write types with more than one letter ;)
17:24:46 <acowley> So if we have, Inner : K -> *, and Outer : K -> *, I still don't really see what the material implications of that restriction are :/
17:24:47 <edwardk> i mean zed shaw went ballistic about it
17:25:33 <rwbarton> inner and outer are fixed data as part of the "(c -> f d) -> a -> f b" thing?
17:25:34 <edwardk> acowley: it means that _2 :: Functor f => (c -> f d) -> (a,c) -> f (a,d)      must be instantiable with c = d for _2 to be a legal lens
17:25:52 <edwardk> for any given lens
17:25:57 <acowley> Oh, oh, oh
17:26:03 <acowley> dammit, I wish I'd asked about this two days ago
17:26:22 <roconnor> acowley: hmm; i'm not sure I read the definition
17:26:23 <edwardk> this came up in my 'mirrored lenses' post
17:26:29 <roconnor> acowley: seems you might be right
17:26:36 <acowley> edwardk: Yes, my efforts are to unpack that post into terms that make sense to me
17:26:58 <acowley> edwardk: I have this document where I update sigfpe's old coalgebras post and then slide into mirrored lenses
17:27:14 <edwardk> fair nuff
17:27:53 <acowley> I skip over earlier lens constructions
17:27:56 <edwardk> right now i'm writing a slide or two about how setters subsume semantic editor combinators since conal will be in the audience
17:28:03 <acowley> as I think the story is clearer this way
17:28:22 <OODavo> I see there's been previous (not-exactly-serious) consideration of defining a Num instance for functions: http://www.haskell.org/haskellwiki/Num_instance_for_functions
17:28:22 <acowley> I'll probably ask you to take a look at it at some point if I feel like it's worth posting publicly
17:28:25 <OODavo> Has there been consideration of defining a Num instance for /lists/, such that (for example) [1,2,3] * 2 == [2,4,6], or [1,2,3] * [4,5,6] == [4, 10, 18] ?
17:28:48 <acowley> roconnor: So do we need a new name?
17:28:51 <shachaf> edwardk: It's a good thing SPJ isn't coming, or you'd just have to include some slides about how "lens" obsoletes Haskell.
17:29:12 <roconnor> acowley: I don't know; algebra is already overloaded so ...
17:29:31 <roconnor> really thes things are F-algebroids or rather F-coalgebroids
17:29:34 <Saizan> "there's actually a traversal that subsumes ghc"
17:29:54 <typoclass1> "work on hackage 2.0" -- "is it really worth continuing, given that lens obsoletes about 96% of packages"
17:29:59 <edwardk> OODavo: its been done many times but there is no such canonical instance, there are some minor issues of how to deal with the tails of those formal power series nicely that come up in practice.
17:29:59 <acowley> I just don't want edwardk to name them, because he'll choose a name like "x"
17:30:06 <edwardk> typoclass1: =P
17:30:14 <edwardk> acowley: hahahaha
17:30:21 <shachaf> @remember acowley I just don't want edwardk to name them, because he'll choose a name like "x"
17:30:22 <lambdabot> I will remember.
17:30:29 <edwardk> acowley: nah, i promise to leave you all the names of one letter.
17:30:39 <edwardk> 2 letter names, however are fair game.
17:30:54 <acowley> So you'll call them "go"
17:30:55 <edwardk> up, to...
17:31:02 <acowley> and break all the rest of my code
17:31:12 <shachaf> between :: Applicative m => m bra -> m ket -> m a -> m a
17:31:14 <edwardk> nah, go isn't a preposition
17:31:20 <acowley> ha
17:31:21 <EvanR> hmm im writing a function to take a sorted list and produce a list of intervals of consecutive Nums, consecutive means they all have difference 1 to their predecesor
17:31:30 <edwardk> basically if you use a name that is an english language preposition prepare to be disappointed. ;)
17:31:38 <EvanR> wondering if theres a celebrated cool way to do it
17:31:50 <typoclass1> @hoogle betwixt
17:31:51 <lambdabot> No results found
17:32:00 <edwardk> think of http://en.wikipedia.org/wiki/List_of_English_prepositions as the lens package's reserved keyword list.
17:32:27 <ivanm> edwardk: with using hsc2hs, do you know how to specify the main-is file if it's a .hsc one?
17:32:28 <edwardk> betwixt, anent, and athwart will all be coming soon
17:32:38 <shachaf> mapNotwithstanding
17:32:41 <ion> I want lest
17:32:41 <edwardk> ivanm: no idea
17:32:47 <acowley> that would be fantastic
17:32:59 <shachaf> ivanm: Does plain "main-is:" not work?
17:33:04 <acowley> ye olde betwixtegebroid
17:33:18 <shachaf> You can presumably always make a separate "Main.hs" that contains nothing but a call to an exported name.
17:33:20 <ivanm> shachaf: well, I'm not sure what extension to specify :)
17:33:23 <typoclass1> acowley: don't give him ideas
17:33:25 <ivanm> (admittedly I haven't tried it yet)
17:33:28 <EvanR> is there a word to means, sorted list of unique things
17:33:30 <shachaf> ivanm: Try it!
17:33:38 <ivanm> I will then!
17:33:41 <shachaf> I think ghc automatically figures it out, or something.
17:34:15 <acowley> edwardk: if the type families coincide for the same indices, why do we need two families (Inner and Outer)?
17:34:18 <rwbarton> strictly increasing sequence?
17:34:20 <edwardk> acowley: in all seriousness i do tend to try to find prepositions because those, gerunds and past tense names tend to be good declarative combinator names that are under-utilized
17:34:50 <edwardk> acowley: Outer '() = Text; Inner '() = Char
17:34:57 <EvanR> strictly increasing ya
17:35:06 <edwardk> Outer a = [a]; Inner a = a
17:35:30 <edwardk> for each algebroid there is one family involved.
17:35:43 <edwardk> (Inner i -> f (Inner j))
17:35:45 <dolio> Coalgebroid.
17:35:50 <edwardk> gets mapped to (Outer i -> f (Outer j))
17:35:53 <edwardk> yes, coalgebroid
17:36:31 <edwardk> anyways i try to avoid the coalgebroid vocabulary. i find it needlessly obtuse
17:36:40 <Saizan> maybe there should be a direct name for coalgebra
17:36:46 <edwardk> but the notion of those families seems to make sense
17:36:52 <ivanm> preflex: seen dcoutts
17:36:52 <preflex>  dcoutts was last seen on #haskell 2 hours, 42 minutes and 26 seconds ago, saying: Attic: no, your global system packages are fine
17:37:41 <shachaf> edwardk: Would Lens f oi oj ii ij = Functor f => (ii -> f ij) -> oi -> f oj be too much to ask?
17:37:51 <edwardk> yes
17:37:59 <shachaf> :-(
17:38:17 <shachaf> I still need to think every time I see a b c d.
17:38:18 <edwardk> 4 characters * 700 combinators * 5 example types each = a lot of typing to recolor a bikeshed a louder color
17:38:19 <acowley> shachaf: My document makes that part clear!
17:38:26 <acowley> bbl
17:38:35 <acowley> edwardk: Thanks for the help, I'll think about this more
17:39:25 * cmccann should start using more unicode identifiers
17:39:51 <edwardk> cmccann: thats one way to cut your installed user base to zero quickly
17:40:05 <dolio> Perfect.
17:40:21 <shachaf> cmccann: Twist: Every identifier you use is a Unicode identifier.
17:40:24 <typoclass1> edwardk: i see that it's a big ship to turn around, and that's probably reason enough. but if what shachaf said is just bikeshedding, then i guess things like adding documentation or writing blog posts is also just bikeshedding ...
17:41:13 <cmccann> edwardk, sounds useful for package internals
17:41:23 <cmccann> instead of just not exporting stuff, give everything horrible unicode names
17:41:36 <cmccann> that way you know nobody will use the internal stuff
17:42:48 <edwardk> cmccann: yep, and they will never send you any of those pesky bug reports either, because they cant figure out what's going on.
17:43:03 <dolio> Also perfect.
17:43:17 <shachaf> cmccann: Data.ByteString.<fraktur>Internal</fraktur>
17:43:25 <cmccann> hahahaha yes
17:43:47 <edwardk> typoclass1: well, the thing is i honestly prefer the shorter names. i actually turned down a request by someone who volunteered to alpha rename everything in a patch, because I didn't want to reprogram _my_ thinking to more verbose names.
17:44:03 <pordan30> it hasn't stopped anyone from using agda
17:44:09 <shachaf> What if they were just one-letter identifiers that were more informative?
17:44:23 <Cale> 𝔍𝔫𝔱𝔢𝔯𝔫𝔞𝔩
17:44:28 <Cale> so... classy...
17:44:29 <cmccann> edwardk, pf, I think you mean "α rename"
17:44:32 <edwardk> pordan30: i am a living breathing counterexample to that statement
17:44:49 <shachaf> Lens f o p i j = Functor f=> (i -> f j) -> o -> f p
17:44:59 <elliott> edwardk: you have 700 combinators?
17:44:59 <lambdabot> elliott: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:45:00 <davean> cmccann: I like how you think.
17:45:01 <edwardk> shachaf: i chose a and b to be next to each other and c and d to be next to each other for that reason
17:45:06 <Cale> 𝔇𝔞𝔱𝔞.𝔅𝔶𝔱𝔢𝔖𝔱𝔯𝔦𝔫𝔤.𝔍𝔫𝔱𝔢𝔯𝔫𝔞𝔩
17:45:10 * shachaf never verified that edwardk is actually breathing.
17:45:11 <dolio> Fnternal?
17:45:20 <shachaf> edwardk: Sigh...
17:45:30 <Cale> oh, I guess that's actually a J
17:45:32 <Cale> hmm
17:45:48 <Cale> the codepoint where I would be is unassigned
17:45:53 <dolio> Hah.
17:45:54 <edwardk> elliott: elliott : let me count with haddock
17:45:55 <davean> shachaf: I've seen him coughing, which implies breathing
17:45:58 <Cale> 𝔉 is F
17:46:07 <davean> shachaf: It might all be an act though
17:46:27 <shachaf> davean: Oh, you're the sticker person, aren't you.
17:46:38 <dolio> Those two look very similar at my font size.
17:46:57 <davean> shachaf: ... maybe?
17:47:02 <cmccann> hm
17:47:19 <Cale> It's weird, there are randomly missing letters... maybe they're elsewhere
17:47:23 <shachaf> hi uogl
17:47:26 <typoclass1> Cale: it's normal to use J for uppercase I in fraktur. in fact, around here it's been fairly common in any font to do that, well into the 20th century
17:47:43 <shachaf> uogl: Do you know about edwardk's exciting talk in SF tomorrow?
17:47:45 <cmccann> fraktur module names seem to work
17:47:49 <cmccann> awesome!
17:47:57 <shachaf> cmccann: What have I done. :-(
17:48:07 <Cale> typoclass1: There's a little difference though, in the depth of the curve
17:48:14 <shachaf> cmccann: What about ☃? I guess that's not alphabetic.
17:48:17 <Cale> 𝕴𝕵
17:48:22 <Cale> the bold variant has both
17:48:23 <cmccann> shachaf, yeah, that's a symbol
17:48:26 <cmccann> it's a valid operator though
17:48:31 <edwardk> > sum $ map (read :: String -> Int) $ words "5 48 11 5 3 13 51 16 29 21 13 11 53 21 22 3 11 31 3 3 58 31 8 64 37 33 30 23 7 2 11 21 5 5 2 5 7 2 4 13 11 3 3 2 3 3 7 13 5 2"
17:48:32 <lambdabot>   793
17:48:40 <cmccann> and yeah, for some reason I don't have a non-bold fraktur capital I either
17:48:41 <edwardk> elliott: nope, guess not. 793. my bad
17:49:20 <Cale> 𝕯𝖆𝖙𝖆.𝕭𝖞𝖙𝖊𝕾𝖙𝖗𝖎𝖓𝖌.𝕴𝖓𝖙𝖊𝖗𝖓𝖆𝖑
17:49:34 <elliott> edwardk: :/
17:49:43 * cmccann notes that unicode also includes "blackboard bold", "script" and "bold script" alphabets
17:49:47 <cmccann> so much potential!
17:49:59 <edwardk> elliott: that should be about equally split between combinators for using them and actual lenses/traversals
17:50:13 <Cale> I love the Fraktur S
17:50:30 <dolio> Data.ButeGtring.Fnternal
17:50:57 <Cale> The S is classy. The O and Q are somewhat poorly thought out
17:50:58 <edwardk> that reminds me i need to cut apart more of those stickers before i leave
17:51:04 <Cale> 𝔒𝔔
17:51:13 <Cale> 𝕺𝕼
17:51:31 <cmccann> fraktur Z is kinda weird too
17:51:35 <Cale> yeah
17:51:35 <elliott> edwardk: should i try to figure out control.lens one of these days
17:53:05 <elliott> Hmm, lens looks kind of like trifecta.
17:53:13 <elliott> in that it has shiny new versions of existing edwardk packages built in
17:53:13 <shachaf> parseOf
17:53:31 <cmccann> also I can't figure out 𝕻
17:53:33 <edwardk> elliott: hahahaha
17:53:44 <dolio> Is that B?
17:53:47 <Cale> P
17:53:51 <dolio> Seriously?
17:53:53 <shachaf> elliott: Also exciting conal packages and exciting pigworker/djahandarie packages and such.
17:53:53 <cmccann> yes.
17:54:05 <Cale> 𝕭 is B
17:54:10 <cmccann> behold: 𝕬 𝕭 𝕮 𝕯 𝕰 𝕱 𝕲 𝕳 𝕴 𝕵 𝕶 𝕷 𝕸 𝕹 𝕺 𝕻 𝕼 𝕽 𝕾 𝕿 𝖀 𝖁 𝖂 𝖃 𝖄 𝖅
17:54:14 <edwardk> shachaf: for a minute there i thought i had forgotten a lens combinator
17:54:31 <copumpkin> > ['𝕬'..]
17:54:32 <lambdabot>   "\120172\120173\120174\120175\120176\120177\120178\120179\120180\120181\120...
17:54:41 <copumpkin> > text (take 20 ['𝕬'..])
17:54:42 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
17:54:44 <edwardk> shachaf: only conal package that gets consumed by it is the semantic editor combinator stuff
17:54:46 <copumpkin> dammit
17:54:49 <cmccann> go lambdabot!
17:55:00 <edwardk> it does kind of take over for the newtype package though
17:55:11 <dolio> UBGDEFGSFFALMNOBQRGEUB Square X03
17:55:27 <dolio> Fraktur alphabet.
17:55:29 <shachaf> edwardk: Remember when you fought to keep data-lens Haskell 98?
17:55:42 <elliott> edwardk: it seems to take over that representable functions packages too
17:55:45 <edwardk> shachaf: yes. i have a very good reason for why i broke with that tradition
17:56:06 <edwardk> elliott: yep in a more polished way, using polymorphic lenses as a canonical choice of representation
17:56:15 <elliott> edwardk: is it to avoid hugs compatibility patches from smartasses
17:57:18 <edwardk> shachaf, elliott: nah, it was because a.) lens-family already did that, b.) dolio gave me a lot of shit about the practice and noted how much harder it was for end users to use broken up packages and c.) you can define a 'lens'-compatible lens without incurring any dependency on my package whatsoever.
17:57:41 <edwardk> so if you just want to _supply_ lenses. you are free to do so, in a completely haskell 98 manner without even needing to use my package
17:58:09 <edwardk> the major usecase for keeping packages 98 is that that way other packages can depend on it without incurring the obligation of other extensions
17:58:28 <edwardk> but it comes at the expense of a very high barrier to entry for users
17:58:37 <cmccann> so edwardk has abstracted things to the point where you can use his libraries without even installing them
17:58:42 <edwardk> here i wanted the lower barrier to entry and to come with batteries included
17:58:46 <edwardk> cmccann: exactly =)
17:59:10 <elliott> edwardk: pfft, i bet it was actually the hugs thing
17:59:10 <typoclass1> @remember cmccann so edwardk has abstracted things to the point where you can use his libraries without even installing them
17:59:11 <lambdabot> It is forever etched in my memory.
17:59:23 <shachaf> @quote syntaxglitch
17:59:23 <elliott> (I wonder if reflection even still works with hugs)
17:59:24 <lambdabot> syntaxglitch says: writing DRM isn't possible in Haskell, since it doesn't actually do anything useful GHC simply optimizes it away
17:59:37 <edwardk> elliott: it might have been
18:00:05 <ivanm> Cabal/hsc2hs doesn't seem to like it when I have my .hsc file and .h file in the same sub-directory and just inlude it as if it was in the same directory :s
18:00:42 <elliott> edwardk: lens has me sold mainly because your types diagram is pretty
18:00:48 <edwardk> elliott: =)
18:01:02 <edwardk> hah they gave me a week's worth of crap about that at the office.
18:01:12 <cmccann> elliott has a point, I may switch to using it for that reason alone
18:01:27 <cmccann> fancy diagrams are very persuasive
18:01:35 <elliott> you don't get those kind of gradients from any other lens package
18:01:50 <Saizan>  edwardk too UMLy?
18:01:50 <edwardk> its very 'yo dawg'. in that in haskell we can be so oop that even our accessors have UML diagrams describing their accessors.
18:02:01 <cmccann> hahaha
18:02:19 <edwardk> Saizan: exactly
18:02:47 <shachaf> cmccann: Is that why you're using byorgey's code?
18:02:48 <Cale> What happens to the Hebrew alphabet in my head because I don't know Hebrew: אבגדםווםםוםלםוםעםאםשח
18:03:10 <cmccann> shachaf, actually I haven't spent much time using the diagrams package :[
18:03:14 <edwardk> Saizan: it let me dig up my long-dead experience as a "sun certified enterprise architect" and put those skills to use ;)
18:03:40 <hpaste> Me pasted “Me” at http://hpaste.org/76432
18:03:53 <shachaf> Cale: I'm surprised you knew anything past א.
18:04:00 <shachaf> And maybe ב, I guess.
18:04:31 <edwardk> shachaf: clearly he just tapped in the unicode code points in order
18:04:41 <Saizan> edwardk: hah, here it just digs up freshman nightmares about pizzas and monster shows
18:04:52 <shachaf> edwardk: If you look closely, you'll notice that that has quite a few duplicates.
18:05:10 <shachaf> Freshman's nightmare? Is that (a+b)^2 = a^2 + 2ab + b^2?
18:05:17 <edwardk> shachaf: yep
18:05:28 <edwardk> they much prefer the freshman's dream
18:05:52 <edwardk> (a+b)^p = a^p + b^p -- in a field of characteristic p
18:06:17 <Nereid> or commutative ring
18:06:21 <edwardk> that too
18:06:22 * hackagebot template 0.2.0.8 - Simple string substitution  http://hackage.haskell.org/package/template-0.2.0.8 (JohanTibell)
18:06:44 * cmccann considers adding the offset for the hebrew alphabet to his unicode abuse script just to annoy shachaf
18:07:00 <sinelaw> question about code style: what makes you put a piece of code as a function in a 'where' vs. defining a  function at the module level?
18:07:02 <edwardk> ok, hiding and working on slides, packing, etc. ;)
18:07:03 <shachaf> cmccann: Offset? nicode abuse script?
18:07:07 <edwardk> bbiab
18:07:11 <Cale> Well, I actually do recognise aleph, bet, gimel, dalet, and then lamed and shin consistently, and to be honest, I can occasionally recognise a few of the others correctly, but I often end up looking them up even when I'm right.
18:07:25 <shachaf> I bet medfly is to blame.
18:07:35 <cmccann> shachaf, the program I use to write stuff in fraktur
18:07:42 <nyc> I guess I should bring up my extensive experience as Senior Executive Chief Fellow of Engineering Architecture, Emeritus a.k.a. homeless bum.
18:07:43 <cmccann> which just adds a fixed offset to the unicode code point
18:07:58 <sinelaw> למה מה קרה?
18:07:58 <Cale> Nah, when I was 5 or so, I used to love the appendix of the dictionary we had with all kinds of alphabets in it.
18:08:21 <mm_freak> @remember Jafet Agda has an evaluator?
18:08:21 <lambdabot> I will never forget.
18:08:21 <Cale> and probably if you asked me back then I could have named all the letters
18:08:51 <cmccann> but adding the offset of aleph is not quite as meaningful as adding the offset of fraktur "a"
18:08:59 <shachaf> Cale: My father tends to confuse lambda and gamma, and delta and lambda.
18:09:04 <sinelaw> Cale: שלד אבד בשלג
18:09:21 <cmccann> if I could remember all the names of the hebrew letters I'd add them to my SciTE abbreviations file though
18:09:53 <shachaf> cmccann: Conveniently, the name of every Hebrew letter starts with that letter.
18:10:33 <cmccann> that's not exactly a well-founded mnemonic...
18:10:59 <shachaf> cmccann: Mutual recursion would hardly be better.
18:16:51 <sinelaw> @hoogle (\f g (a,b) (c,d)) -> (f a, g d)
18:16:51 <lambdabot> Parse error:
18:16:51 <lambdabot>   (\f g (a,b) (c,d)) -> (f a, g d)
18:16:51 <lambdabot>     ^
18:17:08 <sinelaw> @hoogle (\f, g, (a,b), (c,d)) -> (f a, g d)
18:17:08 <lambdabot> Parse error:
18:17:08 <lambdabot>   (\f, g, (a,b), (c,d)) -> (f a, g d)
18:17:08 <lambdabot>     ^
18:17:17 <sinelaw> sorry, moving to private
18:18:20 <startling> does anyone know of a thing for type-safe monadic key-value pair dslery?
18:18:46 <startling> I've got a little prototype, but I'm wondering if it's already been done or whether I should use something else
18:18:48 <ivanm> with "cabal bench", what is the --benchmark-option flag used for?
18:19:22 <startling> N.B. what I'm asking for is more complicated than Writer Map -- I want differently-typed fields
18:20:36 <ivanm> startling: extensible records maybe?
18:20:53 <ZfeIlDuce> @hoogle (\f g (a,b) (c,d) -> (f a, g d))
18:20:54 <lambdabot> Parse error:
18:20:54 <lambdabot>   (\f g (a,b) (c,d) -> (f a, g d))
18:20:54 <lambdabot>     ^
18:21:13 <ZfeIlDuce> Hmm
18:21:24 <ivanm> ZfeIlDuce: hoogle does type-based search
18:21:30 <ivanm> did you want @pl or @type ?
18:21:31 <startling> ivanm: looks interesting, thanks
18:21:33 <Nereid> @type (\f g (a,b) (c,d) -> (f a, g d))
18:21:34 <lambdabot> forall t t1 t2 t3 t4 t5. (t -> t4) -> (t3 -> t5) -> (t, t1) -> (t2, t3) -> (t4, t5)
18:21:46 <Nereid> @pl (\f g (a,b) (c,d) -> (f a, g d))
18:21:47 <lambdabot> flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . (((.) . const) .)) .) . flip . (((.) . (,)) .)
18:21:49 <Nereid> disgusting
18:21:51 <ivanm> ZfeIlDuce: *** maybe?
18:21:51 <ZfeIlDuce> ivanm, no, I just wanted to know what sinelaw was searching for.
18:22:13 <ivanm> oh, missed that sinelaw was trying that
18:22:15 <ZfeIlDuce> and I was a bit pleasantly surprised that it could apparently search based on alpha aequivalance, but apparently it can't.
18:22:21 <Nereid> @type (***)
18:22:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:22:23 <ivanm> @pl \ f g (a,b) (c,d) -> (f a, g d)
18:22:24 <lambdabot> flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . (((.) . const) .)) .) . flip . (((.) . (,)) .)
18:22:41 <ivanm> oh, missed that Nereid already did that
18:22:43 <Nereid> ;D
18:23:00 <ivanm> and that's not arrow stuff anyway
18:23:05 <Nereid> mhm
18:23:31 <sinelaw> Nereid, yeah, (***) does it on pairs
18:23:39 <Nereid> it does it on one pair
18:23:42 <sinelaw> well
18:24:04 <ivanm> @hoogle unsafePerformIO
18:24:04 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
18:24:04 <lambdabot> Foreign unsafePerformIO :: IO a -> a
18:24:06 <Nereid> you could use (***) together with some (a,b) -> (c,d) -> (a,d)
18:24:10 <sinelaw> @type \f g -> (arr f) *** (arr g)
18:24:12 <lambdabot> forall b c (a :: * -> * -> *) b' c'. (Arrow a) => (b -> c) -> (b' -> c') -> a (b, b') (c, c')
18:24:19 <Nereid> @. pl djinn (a,b) -> (c,d) -> (a,d)
18:24:19 <lambdabot> f = (. snd) . (,) . fst
18:24:40 <shachaf> @@ @pl @pl @djinn @type fromMaybe
18:24:41 <sinelaw> @pl \f g -> (arr f) *** (arr g)
18:24:42 <lambdabot>  (line 3, column 19):
18:24:42 <lambdabot> unexpected ","
18:24:42 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
18:24:42 <lambdabot> (. arr) . (***) . arr
18:24:51 <shachaf> Pfooey.
18:25:04 <Nereid> you don't need arr to use the (->) arrow
18:25:07 <Nereid> (where arr = id)
18:25:21 <sinelaw> oh
18:25:29 <sinelaw> @type \f g -> f *** g
18:25:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:25:38 <sinelaw> oops, well ok
18:25:43 <Nereid> @type \f g x -> (f *** g) x
18:25:45 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
18:25:53 <sinelaw> that's right.
18:26:03 <sinelaw> thanks
18:26:22 * hackagebot cr 1.0 - Code review tool  http://hackage.haskell.org/package/cr-1.0 (AlexandruScvortov)
18:26:32 * bgamari can't imagine what the type errors from Control.Lens must look like
18:26:35 <sinelaw> now I need:
18:26:44 <sinelaw> @type \f g x -> (f x, g x)
18:26:45 <lambdabot> forall t t1 t2. (t -> t1) -> (t -> t2) -> t -> (t1, t2)
18:26:50 <shachaf> bgamari: edwardk pulled a few dirty tricks to make them a bit nicer.
18:26:53 <sinelaw> @pl \f g x -> (f x, g x)
18:26:53 <lambdabot> liftM2 (,)
18:26:56 <sinelaw> ok :)
18:27:06 <shachaf> Gratuitous type classes to turn things from unification errors to instance errors.
18:28:23 <rwbarton> @@ @hoogle @type \f g x -> (f x, g x)
18:28:25 <lambdabot>  No results found
18:28:31 <rwbarton> oh hoogle doesn't understand arrows anyways
18:28:33 <rwbarton> @hoogle (&&&)
18:28:33 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
18:28:48 <Nereid> @. hoogle type \f g x -> (f x, g x)
18:28:49 <lambdabot> Parse error:
18:28:49 <lambdabot>   forall t t1 t2. (t -> t1) -> (t -> t2) -> t -> (t1, t2)
18:28:49 <lambdabot>  
18:28:54 <Nereid> heh.
18:28:59 <Nereid> @hoogle (t -> t1) -> (t -> t2) -> t -> (t1, t2)
18:28:59 <lambdabot> No results found
18:29:01 <Nereid> aw.
18:29:09 <Nereid> @type liftA2 (,)
18:29:10 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
18:29:42 <Nereid> @pl \f g x -> (f x,g x)
18:29:43 <lambdabot> liftM2 (,)
18:29:46 <Nereid> yeah lol.
18:30:21 <shachaf> [(x,y) | x <- f, y <- g]
18:30:49 <latro`a_> @pl \f g -> [(x,y) | x <- f, y <- g]
18:30:49 <lambdabot> (. (return . (y <-))) . (:) . (((x, y) | x) <-)
18:30:54 <latro`a_> wait
18:30:54 <latro`a_> what
18:31:03 <rwbarton> you're not familiar with the (y <-) function?
18:31:10 <latro`a_> I am not...
18:31:15 <Nereid> haha
18:31:17 <latro`a_> or the |
18:31:24 <Nereid> pl doesn't know about list comprehensions.
18:31:27 <Peaker> do { x <- f ; y <- g ; return (x, y) }
18:31:28 <latro`a_> I see that
18:31:38 <shachaf> @@ @pl @undo [(x,y) | x <- f, y <- g]
18:31:38 <lambdabot>  (g >>=) . flip flip [] . ((:) .) . (,) =<< f
18:31:41 <startling> is there a way I can extend an enum-like type?
18:31:44 <Peaker> sinelaw, hey!
18:31:53 <Nereid> startling: what does that mean?
18:32:03 <sinelaw> Peaker, yo! You're up now?!
18:32:21 <shachaf> It's getting to be evening Peaker-time.
18:32:28 <Nereid> also, why can we only derive Enum for data with only nullary constructors? :(
18:32:31 <Peaker> sinelaw, :)
18:32:37 <Peaker> sinelaw, working on difficult code -- time is flying
18:32:53 <sinelaw> flying indeed...on a collision course with sunrise
18:32:53 <ParahSailin> @pl g >>= \y -> f >>= \x -> return (x,y)
18:32:53 <lambdabot> (`fmap` f) . flip (,) =<< g
18:33:08 <Peaker> sinelaw, about your where question -- Yair generally puts stuff in "where" if he can't make a sensible name for them outside (make no sense in outer scope), or puts it outside if it has meaning outside
18:33:10 <Nereid> @unpl liftM2 (flip (,))
18:33:10 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return ((,) a b))
18:33:19 <startling> Nereid: I want to do data E = A | B and then later add C :: E
18:33:27 <Peaker> sinelaw, but.. this causes a huge problem.. lots of stuff in "where" makes for a huge function where the where clauses are really far from where they are used
18:33:29 <sinelaw> Peaker, makes sense
18:33:38 <startling> Nereid: possibly in another file
18:33:48 <sinelaw> Peaker, and also you don't see the type signatures
18:33:48 <Peaker> sinelaw, so my rule of thumb is to actually put stuff outside as much as I can, if they don't depend on too much parameter passing (i.e: float wheres when easy)
18:33:53 <Peaker> sinelaw, just so that functions are bite-sized
18:34:21 <shachaf> I like to make my functions bite-aligned.
18:34:43 <Nereid> startling: why?
18:34:44 <Peaker> we work by a strict rule of no aligning to anything but indentation :)
18:35:06 <Peaker> Haskell code tends to hide beyond the right margin of the page -- because people align stuff to previous line spot
18:35:10 <startling> Nereid: because right now I've got one file with a huge freaking enum type and a bunch of submodules dealing with each constructor.
18:35:14 <shachaf> I work by a strict rule of spaces-then-tabs-then-spaces for indentation.
18:35:26 <startling> shachaf: ha
18:35:49 <shachaf> startling: (This style is used in GHC code. Probably not intentionally.)
18:36:09 <sinelaw> Peaker, I sensed that too many wheres go nowhere :)
18:36:24 <Nereid> startling: sounds gross
18:36:25 <Peaker> sinelaw, yeah, when a single function spans multiple pages it becomes extremely unmanageable
18:36:52 <cmccann> multiple pages vertically or horizontally? :D
18:36:53 <Peaker> sinelaw, the new computer I bought at nyc has a broken gpu apparently :(
18:37:14 <sinelaw> Peaker, that explains your driver issues?
18:37:15 <Peaker> cmccann, vertically.. we killed the horizontal issue by never aligning to prev-line..
18:37:24 <nyc> Peaker: What did I do this time?
18:37:34 <Peaker> nyc, you were good :)
18:37:51 <sinelaw> nyc, you're expensive
18:37:54 <Peaker> sinelaw, Yeah -- though to be honest I don't remember we talked about those :)
18:38:12 <sinelaw> Peaker, you were in pre-jetlag mode
18:38:43 <Peaker> sinelaw, it explains the Youtube doesn't work in Windows-out-of-the-box issue
18:38:45 <Nereid> startling: no other way to do what you want to do?
18:38:54 <Peaker> which I just attributed to the ever decreasing reliability of computing
18:39:04 <sinelaw> yeah, it sounded strange to me
18:39:55 <Peaker> You become numb to "strange, this doesn't work" after years of basic things not working :)
18:40:56 <Nereid> startling: kinda hard to suggest anything without much detail
18:41:03 <Nereid> what does 'dealing with' mean?
18:41:22 * hackagebot hopencc 0.1.0.0 - Haskell binding to libopencc  http://hackage.haskell.org/package/hopencc-0.1.0.0 (PaulMeng)
18:43:29 <joeyh> is there a table somewhere of all the cabal os() values?
18:45:41 <ivanm> joeyh: in the Cabal source as a sum-type?
18:46:05 <Nereid> startling: depending on what you want to do you you might be able to get away with a data family or something? but I dunno
18:46:36 <ivanm> is it possible to do profiling but _not_ use the profiling libs of a specific package?  I'm interested in what actual functions affect the runtime of a criterion benchmark, but the profiling result is dominated by all the mwc-random, statistics and criterion functions :s
18:47:06 <Nereid> speaking of which,
18:47:55 <joeyh> well, it's not.. I suppose it's coming from ghc, or perhaps elsewhere
18:48:04 <Nereid> never mind
18:51:29 <ion> https://raw.github.com/gist/3909430/377bfe9b1a62e1c74acac0ec32ca4261c66379cd/%F0%9D%94%93%F0%9D%94%AF%F0%9D%94%A2%F0%9D%94%A9%F0%9D%94%B2%F0%9D%94%A1%F0%9D%94%A2.hs
18:53:17 <copumpkin> very metal
18:56:20 <carter_> ion: is that unicode fonts?
18:56:28 <shachaf> carter: No fonts.
18:56:38 <Jafet> http://cdn-www.i-am-bored.com/media/SatanicMenu.jpg
18:56:53 <carter> nope, its showing very very nice fonts
18:57:00 <carter> so its not ascii
18:57:01 <carter> :)
18:57:09 <ion> ASCII can’t be displayed using nice fonts?
18:57:23 <shachaf> carter: Those are codepoints, man!
18:57:26 <shachaf> Semantic meaning!
18:57:28 <joeyh> yeah, System.Info.OS :: String, populated by ghc magic
18:57:34 <joeyh> er .os
18:58:06 <Jafet> It semantically means that you have too much time on your hands
18:58:23 <harrison> I like ascii, and I like ascii art, but I certainly won't post it here in this channel!
18:58:32 <ion> shachaf: https://gist.github.com/3909452
18:59:14 <Jafet> Double struck by awe
18:59:25 <shachaf> ￯�￯�￯�￯�￯�￯�, ￯�￯�￯�
19:00:05 <ion> I � Unicode
19:01:02 <shachaf> Unicode needs a "Unicode" codepoint.
19:01:04 <shachaf> Like \TeX
19:03:53 <Jafet> @remember ion I � Unicode
19:03:53 <lambdabot> It is stored.
19:04:31 <ion> jafet: That’s an old joke not invented by me.
19:05:28 <Jafet> Well, the quotes list is full of old jokes attributed to the wrong people
19:06:17 <shachaf> @quote Jafet
19:06:17 <lambdabot> Jafet says: it's more fashionable nowadays to do it [write code] the python way, pretend your code works when you write it and hope it works when you run it
19:06:30 <shachaf> @quote Jafet
19:06:30 <lambdabot> Jafet says: In soviet russia, State safely executes you
19:06:41 <ion> hah
19:07:22 <joeyh> that's ok, I invented it (possibly) and I don't care :) http://joeyh.name/blog/entry/wanted_on_a_bumper_sticker/
19:07:59 <shachaf> joeyh: http://www.cafepress.com/nucleartacos/317769 will sell it to you!
19:08:10 <ion> I saw it first in someone’s IRC quit message in 2006.
19:08:24 <joeyh> I know, keep meaning to buy one
19:08:28 <ion> Incidentally, that wasn’t supposed to be a joke: it was supposed to have a ♥, which is even funnier.
19:08:43 <joeyh> I posted that in 2006. otoh, I make no claim of ultimate originality
19:09:09 <cornihilio> hey, I have a weird problem: how do I extract specific digits out of an Int? Like, I want the first 2 numbers. Do I convert it to a string, split, and then read it back in?
19:09:22 <cornihilio> or is there an Int only way of dealing with that sort of a problem
19:09:34 <shachaf> cornihilio: Yes, and yes.
19:09:49 <shachaf> That's not a Haskell question, though, it's a mathematics question. :-)
19:11:31 <carter> shachaf, didn't i say unicode before? :)
19:11:44 <shachaf> carter: They're codepoints, not fonts.
19:11:54 <shachaf> 'a' is also Unicode, for what it's worth.
19:12:01 <carter> hence why I said unicode
19:12:03 <carter> just now
19:12:06 <carter> :)
19:12:47 * shachaf doesn't know what's going on anymore.
19:13:00 <carter> i never did
19:13:06 <mm_freak> Polarina: i'm trying to implement the manager wire, but i'm not sure what it should look like to be useful in general…  what do you expect of it?
19:14:34 <mm_freak> cornihilio: here is a fast way to convert to digits (least significant first):  map (`rem` 10) . takeWhile (> 0) . iterate (`quot` 10)
19:14:46 <mm_freak> > map (`rem` 10) . takeWhile (> 0) . iterate (`quot` 10) $ 12345
19:14:48 <lambdabot>   [5,4,3,2,1]
19:14:53 <mm_freak> > map (`rem` 10) . takeWhile (> 0) . iterate (`quot` 10) $ -12345
19:14:54 <EvanR> manager wire :|
19:14:55 <lambdabot>   []
19:15:00 <mm_freak> uh
19:15:03 <EvanR> sounds familiarly bad
19:15:11 <mm_freak> EvanR: ?
19:15:15 <EvanR> but its haskell so it cant be!
19:15:35 <mm_freak> EvanR: it isn't…  it's a useful thing, but i'm not sure what its interface should look like
19:16:23 * hackagebot dns 0.3.5 - DNS library in Haskell  http://hackage.haskell.org/package/dns-0.3.5 (KazuYamamoto)
19:16:47 <ion> > let swap (a,b) = (b,a) in unfoldr (\n -> swap (n `divMod` 10) <$ guard (n /= 0)) 12345
19:16:48 <lambdabot>   [5,4,3,2,1]
19:17:01 <ion> > let swap (a,b) = (b,a) in unfoldr (\n -> swap (n `divMod` 10) <$ guard (n /= 0)) (-12345)  -- not handled
19:17:02 <lambdabot>   [5,5,6,7,8,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,...
19:17:09 <ion> Wait… it wasn’t supposed to be that bad.
19:17:21 <ion> > let swap (a,b) = (b,a) in unfoldr (\n -> swap (n `quotRem` 10) <$ guard (n /= 0)) (-12345)
19:17:22 <lambdabot>   [-5,-4,-3,-2,-1]
19:18:12 <mm_freak> d'oh
19:18:22 <mm_freak> > map (`rem` 10) . takeWhile ((> 0) . abs) . iterate (`quot` 10) $ -12345
19:18:24 <lambdabot>   [-5,-4,-3,-2,-1]
19:18:36 <mm_freak> of course =)
19:19:20 <mm_freak> > uncurry (flip (,)) (3, 5)
19:19:22 <lambdabot>   (5,3)
19:20:32 <mm_freak> i'm being stupid today
19:20:41 <mm_freak> > map (`rem` 10) . takeWhile (/= 0) . iterate (`quot` 10) $ -12345
19:20:42 <lambdabot>   [-5,-4,-3,-2,-1]
19:20:46 <ion> swap is provided by base nowadays, but lambdabot doesn’t know about that. :-)
19:21:16 <mm_freak> oh, indeed
19:21:25 <mm_freak> about time =)
19:22:02 <shachaf> ion: whoa, dude
19:23:26 <shachaf> Up to 92 imports in my .ghci.
19:23:44 <ion> I only have 39 so far.
19:23:47 <parcs`> i bet ghci takes forever to load
19:23:51 <ion> parcs: Nope
19:23:55 <ion> It loads stuff on-demand.
19:24:10 <Nereid> lazy loading ;o
19:24:18 <mm_freak> do you guys have a way to stop GHCi from displaying all imports at every command line?
19:24:35 <parcs`> $ echo | time ghci ==> 0.396 total
19:24:35 <ion> mm_freak: :set prompt "λ> "
19:24:49 <ion> 0.333
19:25:10 <shachaf> real	0m0.552s
19:26:04 <mm_freak> thanks
19:27:23 <parcs`> ghc takes way too long to initialize
19:27:34 <parcs`> er, ghci
19:27:35 <shachaf> It used to be much worse.
19:27:44 <parcs`> $ echo | time python ==> 0.036 total
19:27:46 <shachaf> Half a second isn't bad.
19:28:03 <shachaf> You can start real	0m0.156s
19:28:04 <ion> sh  0,00s user 0,00s system 0% cpu 0,002 total
19:28:13 <shachaf> 0.156 without a .ghci
19:28:16 <parcs`> lua is in the milliseconds range
19:28:24 <parcs`> shachaf: how many packages do you have installed?
19:28:35 <shachaf> java is in the hours range. So what?
19:28:41 <ion> shachaf: I’d like to see your .ghci import list.
19:29:30 <parcs`> shachaf: if ghci were faster haskell would be a much more attractive scripting language
19:29:33 <shachaf> ion: http://slbkbs.org/ghci.txt
19:29:37 <ion> Thankes.
19:30:03 <parcs`> i have 300 packages installed at the moment. i think that's why ghci startup is so slow for me
19:30:24 <parcs`> the entire package database gets parsed and reconstructed during startup
19:30:35 <shachaf> shachaf@carbon:~$ ghc-pkg list | wc -l # 166
19:31:10 <shachaf> ion: Anything I should add?
19:31:15 <shachaf> Probably a few more extensions.
19:31:19 <parcs`> and all the text fields of the package database are parsed into Strings...
19:31:37 <parcs`> http://hackage.haskell.org/packages/archive/Cabal/1.16.0.1/doc/html/Distribution-PackageDescription.html
19:31:40 <shachaf> parcs`: It's a bit annoying, yes.
19:32:06 <shachaf> parcs`: Hmm, ghci doesn't know about Cabal, does it?
19:33:17 <ion> shachaf: My current .ghci. https://gist.github.com/3909552
19:33:21 <parcs`> shachaf: it does
19:34:16 <shachaf> ion: Can you diff them for me and tell me what I'm missing while you're at it? :-)
19:34:39 <parcs`> the package db is implemented using types in the Cabal library
19:34:50 <parcs`> and it's all terribly slow
19:34:53 <joeyh> ghci always seems to recompile modules from my project when I load them, even if a .o is sitting right next to the .hs. Is that normal?
19:35:20 <parcs`> i saw a couple of O(n^2) string lookups in the reconstruction code
19:35:28 <shachaf> joeyh: Reasonably normal, yes.
19:35:28 <parcs`> String, rather
19:35:49 <shachaf> joeyh: ghci uses some kind of bytecode format. I don't know whether it's compatible.
19:35:51 <parcs`> joeyh: is the .hs newer than the .o?
19:36:15 <joeyh> hmm, well I rebuilt one package and it stopped doing that. Perhaps I had some really old object files there
19:37:04 <joeyh> I have another where it always is, but I'm using -outputdir
19:38:42 <parcs`> my current .ghci: -set Wall
19:40:42 <ivanm> parcs`: don't you mean :set -Wall ?
19:41:50 <parcs`> er, yeah..
19:46:55 <fengshaun> hi all, I have a function that takes long arguments.  How can I break the arguments into multiple lines?
19:47:20 <shachaf> fengshaun: Just indent the arguments more than the function.
19:49:58 <fengshaun> shachaf: oh, thanks
19:52:30 <parcs`> joeyh: there's also a bug in ghci where if a :reload does not completely succeed, some modules get erroneously unloaded. perhaps you are getting bitten by that?
19:53:44 <joeyh> I think I've found my problem. I had :set -outputdir=tmp , and without that, ghci -outputdir=tmp is ok
19:53:51 <joeyh> :set -outputdir must screw it up
19:54:22 <parcs`> ah
19:54:35 <johnw> joeyh: your latest changes are still a no-go on OpenIndiana
19:54:37 <johnw> same error
19:54:48 <johnw> "fatal error: sys/event.h: No such file or directory"
19:54:52 <joeyh> so does :set -IUtility
19:55:00 <joeyh> maybe all set of options does, dunno
19:55:05 <johnw> I did "cabal update ; rm -fr dist ; git pull ; cabal install"
19:55:07 <sinelaw> what makes something Hashable?
19:56:04 <sinelaw> oh I see. need to define the instance manually.
19:57:40 <ion> shachaf: I added some modules from your .ghci to mine; i didn’t notice anything i have and you don’t, but i didn’t look that carefully.
19:58:33 <ion> groom seems nice.
19:59:07 * joeyh adds a ghci target to his Makefile that replicates his ghc flags :/ oh well, that works..
20:01:54 <rephorm> is it possible to build ghc 7.4.1 using ghc 7.6? I get missing deps: "base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6" (which seems unsatisfiable)
20:02:20 <johnw> base >= 4 && <3?
20:02:24 <johnw> that's not going to work
20:02:24 <rephorm> yup
20:02:50 <rephorm> or, alternatively, does anyone have an arch linux package of ghc 7.4.x?
20:08:43 <joeyh> johnw: did I get the wrong cabal os? It seemed to use Solaris, possibly
20:08:54 <ion> rephorm: How about the binary package on haskell.org?
20:09:15 <ion> rephorm: https://gist.github.com/2815423
20:09:25 <parcs`> rephorm: you may or may not have that package in your package cache
20:09:31 <rephorm> ion: i tried the binary distro, but it wanted libgmp 0.3 and i have 0.4
20:09:40 <rephorm> i found it on ARM (arch rollback machine)
20:10:10 <parcs`> install http://aur.archlinux.org/packages.php?ID=36512 to get the requisite version of gmp
20:11:06 <rephorm> parcs`: ahh. nice. thanks
20:17:00 <johnw> joeyh: oh, n/m my pull didn't work right
20:17:04 <johnw> joeyh: it's working now
20:17:32 <johnw> good job, thanks
20:17:42 <johnw> i now have almost 2T of data annexed :)
20:23:36 <joeyh> johnw: awesome
20:24:16 <joeyh> that zombie bug you found yesterday seems to be in either rsync or ssh btw. though I worked around it
20:31:28 <johnw> joeyh: thanks!
20:33:10 <johnw> joeyh: I think what you've done with git-annex is brilliant btw
20:33:23 <johnw> I'm a huge git fan, and this solves a problem I've long wanted to solve
20:33:29 <joeyh> tnx
20:34:38 <joeyh> feel free to contribute patches .. even trivial partial code fixes :)
20:38:52 <rephorm> parcs`: it looks like the old 7.4.1-2 package from ARM is working. thanks for your help, though
20:40:28 <EvanR> blast it all to hell! http://codepad.org/V8k38HAA
20:40:33 <EvanR> lol
20:41:28 <td123> rephorm: you can use the pkg on arm, but don't forget to report the incompatibility upstream
20:42:59 <Nisstyre> Could someone explain to me why the function fromReal' uses so much memory? http://ideone.com/xfG5t
20:43:06 <Nisstyre> Doesn't the head of the tree go out of scope?
20:43:58 <Nisstyre> FYI, I'm doing this: http://en.wikipedia.org/wiki/Stern%E2%80%93Brocot_tree
20:44:26 <nyc> Nisstyre: The mediant construction?
20:44:32 <Jafet> You're using only one tree, which you called sbTree, so it's always in scope.
20:44:34 <cornihilio> why does haskell let me import two libraries with the same qualified name?
20:44:34 <Nisstyre> nyc: you think that's why?
20:44:45 <Nisstyre> Jafet: oh, fair enough
20:44:49 <nyc> Nisstyre: No, it should just work.
20:44:55 <ion> cornihilio: Why not? It lets you import two modules into the default namespace, too.
20:44:58 <Nisstyre> Jafet: so that's getting evaluted more and more
20:45:03 <Nisstyre> and thus taking up lots of memory
20:45:27 <Jafet> > uncurry (%) <$> iterate (\(a,b) -> (b, a`div`b*b*2 - a + b)) (0,1)
20:45:28 <lambdabot>   [0 % 1,1 % 1,1 % 2,2 % 1,1 % 3,3 % 2,2 % 3,3 % 1,1 % 4,4 % 3,3 % 5,5 % 2,2 ...
20:45:55 <cornihilio> ion: I'd think giving two libraries the same nickname would cause issues, or cause the compiler to say something
20:46:07 <rephorm> td123: the fact that you can't build ghc 7.4.1 with 7.6? (Its quite an edge case...) I will let the pandoc people know that it won't install with 7.6, however (which is the better solution to my troubles)
20:46:08 <johnw> joeyh: will do!
20:46:15 <dolio> Why would you think that?
20:46:23 <ion> cornihilio: It’s not necessarily a nickname for a module.
20:46:25 <johnw> joeyh: what i'd love now is a a crashplan backend :)
20:47:02 <joeyh> backends tend to be easy if there's a good haskell library ;)
20:47:21 <cornihilio> ion: what should I call it then? and what else can it be
20:47:25 <cornihilio> be?*
20:47:49 <ion> cornihilio: For instance, you could import lazy and strict variants of multiple modules into the Lazy and Strict namespaces.
20:47:53 <nyc> ``The Stern–Brocot tree may itself be defined directly in terms of mediants: the left child of any number q is the mediant of q with its closest smaller ancestor, and the right child of q is the mediant of q with its closest larger ancestor.''
20:48:46 <johnw> joeyh: so, the one main area where git-annex doesn't work for me just yet is "document bundles"
20:48:47 <Jafet> > uncurry (%) <$> let sb 0 = [(1,0),(0,1)]; sb i = ap (zipWith (\(a,b) (c,d) -> (a+c,b+d))) tail . sortBy (\(a,b) (c,d)->compare (a*d) (b*c)) $ sb =<< [0..i-1] in tail $ concatMap sb [0..]
20:48:48 <lambdabot>   [0 % 1,1 % 1,1 % 2,2 % 1,1 % 3,2 % 3,3 % 2,3 % 1,1 % 4,2 % 5,3 % 5,3 % 4,4 ...
20:49:18 <cornihilio> ion: hmm, I think I'd have to know a bit more haskell to understand that :P
20:49:20 <johnw> things, like Keynote documents, that behave in the Finder like they're single files, but in reality are made up of lots of little files that change every time you even just open the document
20:49:29 <cornihilio> also, I'm having a bit of trouble with this: I have a UTCTime and I want to extract utctDayTime from it (or something like that). What should I do? Where should I be looking?
20:49:45 <johnw> but I can't think of any good way for the annex to address those
20:50:01 <johnw> it may just be that I have to commit those directly to Git
20:50:22 <sinelaw> ok, so my haskell program blows up my RAM
20:50:44 <johnw> sinelaw: many do at first, don't let it shock you
20:50:52 <Jafet> You must be using something terribly unsafe
20:51:16 <sinelaw> I tried adding some manual strict evaluation, didn't help
20:51:20 <ion> cornihilio: import qualified Foo.Lazy as Lazy; import qualified Foo.Strict as Strict; import qualified Bar.Lazy as Lazy; import qualified Bar.Strict as Strict
20:51:35 <sinelaw> Jafet, it reads a huge XML file and transforms it into some other structure
20:52:18 <Jafet> Well, a replacement DIMM is pretty cheap nowadays.
20:52:22 <nyc> Jafet: I think a binary tree must be constructed. I think Farey series are what that ends up constructing.
20:52:26 <sinelaw> actually the file is only 90MB, so it doesn't explain the ram issue
20:52:47 <johnw> sinelaw: then you need to find the right place for the strict evaluation
20:52:57 <johnw> sinelaw: can you show us some code?
20:52:57 <Jafet> > uncurry (%) <$> let sb 0 = [(1,0),(0,1)]; sb i = ap (zipWith (\(a,b) (c,d) -> (a+c,b+d))) tail . sortBy (\(a,b) (c,d)->compare (a*d) (b*c)) $ sb =<< [0..i-1] in tail $ map sb [0..]
20:52:58 <lambdabot>   Couldn't match expected type `(a, a)'
20:52:59 <lambdabot>         against inferred type `[(t, t...
20:53:06 <ion> > let foo n = map (\i -> (1+i,1+n-i)) [0..n]; bar (a,b) = (a % b) <$ guard (gcd a b == 1) in bar =<< foo =<< [0..]
20:53:07 <lambdabot>   [1 % 1,1 % 2,2 % 1,1 % 3,3 % 1,1 % 4,2 % 3,3 % 2,4 % 1,1 % 5,5 % 1,1 % 6,2 ...
20:53:14 <cornihilio> ion: oh, so it creates shared namespaces. but what if there is a collision?
20:53:28 <Jafet> Well, I'm pretty sure that prints the stern-brocot tree.
20:53:45 <Nisstyre> Jafet: you can't encode a number as a series of left/right instructions, though
20:53:47 <ion> cornihilio: The exact same thing happens as without qualified imports: you get a compile error if you try to use an ambiguous name.
20:53:49 <Nisstyre> can you?
20:53:56 <Nisstyre> Jafet: how would you find e or phi with that?
20:54:03 <sinelaw> johnw, https://github.com/sinelaw/abstract-meter/blob/master/src/xml2json/src/xml2json.hs
20:54:21 <johnw> sinelaw: have you done a heap profile?
20:54:27 <Jafet> Those aren't in the tree!
20:54:31 <lispy> sinelaw: What style of XML parsing do you use?
20:54:35 <Nisstyre> Jafet: sorry, approximations
20:54:38 <sinelaw> johnw, not yet...i'll do that
20:54:43 <sinelaw> lispy, using hxt
20:54:49 <Nisstyre> I know it only contains rational numbers
20:54:55 <Jafet> That code isn't the tree, but it walks the tree.
20:54:58 <lispy> sinelaw: So, not a SAX style parser?
20:55:04 <Nisstyre> Jafet: yeah
20:55:37 <sinelaw> lispy, nope, it's DOM
20:55:45 <sinelaw> maybe I should use a SAX parser indeed
20:55:46 <johnw> wow, xmlTreeToJSON is doing a lot of maps
20:55:52 <lispy> sinelaw: and String, ByteString, or Text?
20:55:57 <Jafet> > map (uncurry (%)) <$> let sb 0 = [(1,0),(0,1)]; sb i = ap (zipWith (\(a,b) (c,d) -> (a+c,b+d))) tail . sortBy (\(a,b) (c,d)->compare (a*d) (b*c)) $ sb =<< [0..i-1] in tail $ map sb [0..]
20:55:59 <lambdabot>   [[1 % 1],[1 % 2,2 % 1],[1 % 3,2 % 3,3 % 2,3 % 1],[1 % 4,2 % 5,3 % 5,3 % 4,4...
20:56:02 <sinelaw> lispy, Text
20:56:13 <johnw> I count 7, plus a fold
20:56:30 <johnw> It looks to me like you are building a LOT of thunks
20:56:34 <lispy> sinelaw: What often happens with something like XML is that you have thunks builtup all over the place and you can't really discharge enough of them until you get to </xml>.
20:57:04 <ion> > let foo n = map (\i -> (1+i,1+n-i)) [0..n]; bar (a,b) = (a % b) <$ guard (gcd a b == 1) in map (bar =<< foo) [0..]
20:57:05 <lambdabot>   Couldn't match expected type `(t, t)'
20:57:05 <lambdabot>         against inferred type `[(a, a...
20:57:10 <lispy> sinelaw: retainer profiling is likely to be helpful here
20:57:16 <ion> > let foo n = map (\i -> (1+i,1+n-i)) [0..n]; bar (a,b) = (a % b) <$ guard (gcd a b == 1) in map (bar <=< foo) [0..]
20:57:17 <cornihilio> sorry to repost, but: I have a UTCTime and I want to extract utctDayTime from it (or something like that). What should I do? Where should I be looking?
20:57:17 <lambdabot>   [[1 % 1],[1 % 2,2 % 1],[1 % 3,3 % 1],[1 % 4,2 % 3,3 % 2,4 % 1],[1 % 5,5 % 1...
20:57:22 <sinelaw> lispy, it's a 90MB file, I'm assuming that should fit in less than that but it goes to 6 Gigs
20:57:33 <Nisstyre> ion: nice
20:57:41 <johnw> oh, wow
20:57:47 <lispy> sinelaw: I've seen that before :)
20:57:48 <johnw> your 7maps+1fold is recursive!
20:57:56 <johnw> so you're doing that many maps and folds for *every child*
20:58:01 <johnw> no wonder
20:58:13 <lispy> sinelaw: You could try parsing it into memory just to print it and see how much memory that program takes.
20:58:29 <sinelaw> lispy, good idea, will do
20:58:36 <johnw> you need strictness in xmlTreeToJSON, otherwise it's going to build a truly massive thunk tree
20:58:55 * lispy agrees with johnw 
21:00:10 <lispy> sinelaw: good luck, I'm afk for a bit
21:00:14 <johnw> actually, 8 maps, 2 filters, 1 fold, per child
21:00:17 <sinelaw> johnw, i still feel like a noob - is there a better way to write something xmlTreeToJSON written badly? or are the multiple folds / maps OK in general but cause memory issues?
21:00:29 <johnw> they are fine, but you need some strictness
21:00:40 <johnw> did you try changing the $ to $! in xmlTreeToJSON?
21:00:51 <johnw> that will at least "collapse" children after they are processed
21:01:44 <johnw> but that may not help, since subtrees shouldn't be created until they are needed anyway
21:02:00 <johnw> ah
21:02:09 <johnw> instead of converting the entire tree to JSON and then doing a putStr
21:02:23 <johnw> putStr each section after its been converted
21:02:37 <johnw> or can you not Aeson.encode until you have the whole thing?
21:02:56 <sinelaw> johnw, yeah I did try $! there
21:03:11 <sinelaw> johnw, now I see that the memory issue starts before I even call that function, when I'm just reading the xml
21:03:12 <johnw> ok, then yeah, it's not taking effect until too late
21:03:22 <sinelaw> in main
21:03:23 <johnw> oh ryl?
21:03:30 <johnw> how do you determine that?
21:03:35 <sinelaw> i commented out the call to xml2json in main
21:03:39 <johnw> haha
21:03:41 <sinelaw> xmlTreeToJSON
21:03:48 <johnw> fair enough!
21:03:56 <johnw> but it's only a 90M XML file?
21:03:58 <sinelaw> so its the hxt stuff
21:04:01 <sinelaw> yes
21:04:10 <johnw> hmmm
21:04:22 <johnw> i'm not familiar with hxt yet
21:04:31 <johnw> what is getChildren >>> isElem supposed to yield?
21:04:36 <johnw> all children that are elements?
21:05:26 <sinelaw> yes
21:05:49 <sinelaw> I'm guessing that means parsing the entire file
21:05:58 <johnw> yeah, but even then
21:06:00 <johnw> 6G is egregious
21:06:14 <sinelaw> it doesn't stop there, i just have to kill it because my computer is trying to die
21:06:23 <johnw> something is not right here
21:06:34 <johnw> what if you try with a smaller XML file?
21:06:47 <sinelaw> sec
21:08:22 <johnw> btw, instead of map fromJust . filter isJust . map () ..., I would use foldMap to collect results in the List monoid
21:08:40 <johnw> i.e., foldMap (\x -> if isGood x then [x] else []) xs
21:09:12 <johnw> or, even better if you can foldr:
21:09:30 <johnw> foldr (\x acc -> if isGood x then (x:acc) else acc) xs
21:09:48 * shachaf :-( at naming the second argument to the foldr function "acc"
21:09:53 <latro`a_> ^
21:10:00 <sinelaw> johnw, for a 5.5M file it goes to 2gigs
21:10:11 <johnw> shachaf: :( at not suggesting a better alternative
21:10:14 <shachaf> Also, that looks a lot like filter...
21:10:17 <latro`a_> rest
21:10:36 <shachaf> Lots of things would be better.
21:10:37 <latro`a_> (as a name for the second argument)
21:10:37 <johnw> the accumulator is not "rest"
21:10:41 <latro`a_> it's not an accumulator
21:10:43 <latro`a_> that's the point
21:10:45 <shachaf> Even "xs", which is subtly incorrect, would be better.
21:10:54 <johnw> acc = accumulator
21:10:56 <shachaf> johnw: There's no accumulator.
21:10:59 <latro`a_> it's not an accumulator with foldr
21:11:00 <shachaf> foldr doesn't accumulate.
21:11:14 <johnw> it's what I've built up so far, no?
21:11:17 <latro`a_> no
21:11:21 <latro`a_> because you don't start at the end
21:11:26 <latro`a_> you start at the front
21:11:28 <glguy_> Now there's the #haskell I've come to expect :)
21:11:33 <shachaf> > foldr f z [a,b,c,d,e]
21:11:34 <johnw> ooooooohhhhhh
21:11:34 <lambdabot>   f a (f b (f c (f d (f e z))))
21:11:39 <latro`a_> yeah
21:11:42 <sinelaw> hehe
21:11:43 <johnw> omg, you just blew my mind
21:11:45 <johnw> thanks guys!!!!
21:11:48 <shachaf> The argument to "f a" isn't an accumulator. It's just foldr on the tail.
21:11:48 <latro`a_> lol
21:12:09 <johnw> how about "rem" for remainder?
21:12:14 <latro`a_> that's taken
21:12:16 <latro`a_> in the prelude
21:12:20 <cornihilio> I have a UTCTime and I want to extract utctDayTime from it (or something like that). What should I do? Where should I be looking?
21:12:22 <shachaf> ...To mean "remainder", in fact.
21:12:25 <latro`a_> well, locally you can override it I think, but please don't
21:12:28 <johnw> lol
21:12:38 <shachaf> I don't mind xs that much, even thought it's actually (foldr f z) of xs.
21:12:39 <johnw> ok, i'll stop using acc, point token
21:12:40 <johnw> taken
21:12:45 <sinelaw> so looks like hxt explodes on a 5MB file...this can't be true
21:12:47 <latro`a_> it's fine with foldl
21:12:51 <latro`a_> (mostly)
21:12:55 <johnw> yeah, in actual fact I rarely use foldr
21:12:55 <shachaf> foldl is never fine.
21:13:01 <latro`a_> true, ish
21:13:07 <shachaf> johnw: You should! It's much better than foldl.
21:13:07 <latro`a_> you wouldn't define, say, sum any other way
21:13:08 <johnw> but this was something I didn't understand properly, so this is an excellent tidbit
21:13:11 <shachaf> And it's often better than foldl'
21:13:17 <latro`a_> oh
21:13:19 <johnw> shachaf: I use foldl' mostly, and foldM
21:13:19 <latro`a_> you menat that
21:13:25 <latro`a_> I was assuming foldl' >.>
21:13:34 <shachaf> map f = foldr ((:).f) []
21:13:36 <latro`a_> *meant
21:13:37 <johnw> shachaf: well, now that you've helped me actually understand it, I probably will!
21:13:47 * johnw has newfound respect for foldr
21:14:01 <latro`a_> I still don't know how this right to left business gets into people's heads >.> <.<
21:14:02 <johnw> and now I get how it can work on infinite lists!
21:14:21 <latro`a_> f x (foldr z xs) <--- not right to left
21:14:44 <johnw> latro`a_: I wonder now too
21:14:48 <johnw> oh, it's the "r"
21:15:01 <shachaf> foldr means it's right-associative.
21:15:03 <latro`a_> no, that just specifies the associativity
21:15:06 <johnw> i totally thought it processed the list right-to-left in the same way that foldl does it left-to-right
21:15:08 <johnw> ahh
21:15:12 <johnw> see, I totally did not know that
21:15:21 <shachaf> foldr (+) 0 [a,b,c] = a + (b + (c + 0))
21:15:25 <johnw> so I always found myself wondering why the heck I'd want a fold from right-to-left
21:15:25 <latro`a_> if f is strict, then foldr is equivalent to foldl on a reversed list with the function flipped
21:15:30 <shachaf> foldl (+) 0 [a,b,c] = (((0 + a) + b) + c)
21:15:43 <latro`a_> but if f is not strict, foldl and foldr have completely different semantics
21:15:53 <shachaf> latro`a_: Strict?
21:15:59 <shachaf> Do you mean "associative" or something like that?
21:16:05 <shachaf> Oh, reversed.
21:16:12 <latro`a_> yeah
21:16:41 <shachaf> johnw: foldr is a much more fundamental function. foldl(') is just a utility, but foldr directly follows the structure of a list.
21:16:47 <johnw> i should write foldrReally, that folds in reverse :)
21:16:49 <latro`a_> i.e if f is strict it isn't entirely wrong to say that foldr proceeds right to left, because a function that actually *does* proceed right to left has the same observational semantics
21:16:51 <cornihilio> shachaf: why do you prefer foldr to foldl, especially foldl'? in rwh I remember something along the lines of use foldl' wherever possible to avoid a possible stack overflow
21:17:06 <johnw> shachaf: 100% understood now, thank you so much!!!
21:17:08 * johnw hugs shachaf
21:17:10 <shachaf> cornihilio: Use foldl' instead of foldl.
21:17:29 <cornihilio> but why do you prefer foldr to foldl/foldl'?
21:17:30 <shachaf> But if you can use foldr reasonably, you probably don't want foldl' at all.
21:17:33 <shachaf> Look at the wiki.
21:17:40 <johnw> and this is why people call foldr a catamorphism, but not foldl?
21:18:02 <shachaf> johnw: The "commoners' word" for catamorphism is fold.
21:18:09 <shachaf> foldl isn't actually a fold, in that sense. :-)
21:18:14 <johnw> I thought it was "iterate" :)
21:18:18 <shachaf> ?
21:18:25 <shachaf> johnw: Other examples of folds:
21:18:28 <shachaf> @ty maybe
21:18:28 <johnw> the commoner's word for catamorphism
21:18:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:18:32 <shachaf> @ty either
21:18:33 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
21:19:34 <johnw> i suddenly want to change all my uses of foldl' to foldr
21:19:51 <johnw> no wonder I was needed more strictness in some places
21:19:51 <shachaf> johnw: If foldl' is appropriate, foldr probably isn't appropriate.
21:19:55 <johnw> s/needed/needing
21:20:13 <johnw> yeah, but foldl' and : will never really get along, will they?
21:20:29 <spaceships> why not replace foldl with foldl' in prelude?
21:20:32 <johnw> not without me forcing evaluation in some way
21:20:35 <sinelaw> err...how do I build my cabal package for profiling? It can't find Prelude....
21:20:47 <latro`a_> if there were a convention for "minus prime"
21:20:48 <johnw> sinelaw: cabal configure --enable-library-profiling --enable-executable-profiling
21:20:50 <shachaf> johnw: ?
21:20:52 <sinelaw> do I need to install profiled versions of all packages ?
21:20:52 <latro`a_> that would be a good idea @ spaceships
21:20:52 <shachaf> @src reverse
21:20:53 <lambdabot> reverse = foldl (flip (:)) []
21:21:00 <latro`a_> because there IS actually a decent reason
21:21:05 <shachaf> I suspect that's better as foldl'
21:21:09 <latro`a_> having to do with issues of undefined
21:21:09 <latro`a_> uh
21:21:10 <latro`a_> no
21:21:16 <latro`a_> then you can't reverse [1,undefined]
21:21:21 <cornihilio> sorry to keep spamming but I really don't get this. I have a UTCTime and I want to extract utctDayTime from it (or something like that). What should I do? Where should I be looking?
21:21:27 <johnw> shachaf: other than that example :)
21:21:36 <shachaf> latro`a_: You can't?
21:21:39 <latro`a_> nope
21:21:45 <shachaf> > length $ foldl' (flip (:)) [] [1,undefined]
21:21:47 <johnw> foldl defeats laziness, so you need strictness to avoid thunk monsters
21:21:47 <lambdabot>   2
21:21:51 <sinelaw> johnw, it complains about missing prelude
21:21:53 <latro`a_> huh
21:22:00 <sinelaw> johnw, when I build
21:22:01 <latro`a_> uhh
21:22:12 <shachaf> latro`a_: It's the cons cells that are being forced here.
21:22:18 <johnw> sinelaw: you need all of the libraries to be built with profiling to use the profiler
21:22:28 <latro`a_> > length $ foldl' (flip (:)) [] [1,undefined,undefined]
21:22:28 <johnw> sounds like your core GHC libs don't have profiling enabled
21:22:29 <sinelaw> johnw, is there an easy way to do that?
21:22:31 <lambdabot>   3
21:22:32 <spaceships> maybe its similar to why map only works on lists
21:22:33 <latro`a_> huh
21:22:41 <johnw> sinelaw: not that I know of ; I had to rebuild my world
21:22:44 <latro`a_> why does that never seq the undefined
21:22:45 <sinelaw> :(
21:22:50 <johnw> I now make sure that *everything* builds a profiled variant, always
21:22:52 <shachaf> latro`a_: Because of what I said.
21:23:06 <Jafet> > length $ foldl' (flip (:)) [] (replicate 10000 undefined)
21:23:08 <lambdabot>   10000
21:23:11 <cornihilio> wow, really sorry for spamming this channel. Turns out my code was working, hslint froze or something.
21:23:20 <latro`a_> @src foldl'
21:23:20 <lambdabot> foldl' f a []     = a
21:23:20 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
21:23:26 <johnw> cornihilio: i shall forgive thee
21:23:28 <latro`a_> ohh
21:23:30 <latro`a_> right
21:23:30 <latro`a_> that
21:23:31 <latro`a_> k
21:23:39 <latro`a_> you're seq'ing a list, not the undefined
21:23:41 <latro`a_> right, right
21:23:51 <shachaf> johnw: Sometime you should work on getting your strictness-intuition beyond the "thunk monsters" level. :-)
21:24:13 <johnw> shachaf: i've got a moment now, how do I get there?
21:24:15 <latro`a_> and seq'ing a list isn't *deep*seq'ing a list
21:24:27 <latro`a_> so it only seqs the constructor
21:24:27 <latro`a_> k
21:24:31 <latro`a_> thanks
21:24:45 <shachaf> johnw: Take problematic code, figure out why it's problematic.
21:24:57 <shachaf> johnw: Get a good intuition for how graph reduction works and why strictness helps/hurts.
21:25:01 <johnw> why is the thunk monster intuition bad?
21:25:06 <shachaf> latro`a_: "deepseq" is a lie.
21:25:17 <randomclown> My program uses stdin for input, is there a way to fake stdin and call main while inside ghci?
21:25:24 <johnw> what I mean when I say that is that I see code going O(n) in terms of heap consumption
21:25:25 <latro`a_> I know, shachaf
21:25:28 <latro`a_> just
21:25:37 <latro`a_> you don't seq any further than just the constructor
21:25:38 <shachaf> whnf4lyf
21:25:39 <latro`a_> is the point
21:25:48 <latro`a_> by contrast if you define "last" as a left fold
21:25:55 <johnw> i actually do think in terms of whnf/hnf/nf
21:25:57 <latro`a_> doing it with foldl' causes undefineds to get seq'd
21:26:16 <johnw> after that discussion before you and I had about strictness and the meaning of _|_
21:26:28 <roconnor> @src traverse []
21:26:28 <lambdabot> Source not found.
21:26:29 <johnw> (or more aptly, lack of meaning)
21:26:38 <roconnor> @src Data.Traversable.traverse []
21:26:38 <lambdabot> Source not found. :(
21:26:48 <latro`a_> > let last = fold1l' (\_ x -> x) in (last [1,2,3],last [undefined,1])
21:26:49 <lambdabot>   Not in scope: `fold1l''
21:26:52 <latro`a_> err
21:26:58 <latro`a_> > let last = foldl1' (\_ x -> x) in (last [1,2,3],last [undefined,1])
21:26:59 <lambdabot>   (3,1)
21:27:01 <cornihilio>  so, if I have a DiffTime, how do I convert it into an Int? Hoogle is not helping me atm
21:27:14 <glguy_> cornihilio: try truncate
21:27:16 <latro`a_> ...do I need one more undefined
21:27:20 <latro`a_> > let last = foldl1' (\_ x -> x) in (last [1,2,3],last [undefined,undefined,1])
21:27:21 <lambdabot>   (3,*Exception: Prelude.undefined
21:27:23 <latro`a_> there we go
21:27:44 <latro`a_> > let last = foldl1 (\_ x -> x) in (last [1,2,3],last [undefined,undefined,1])
21:27:45 <lambdabot>   (3,1)
21:28:02 <latro`a_> :t truncate
21:28:03 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:28:05 <sinelaw> so how do I install a profiled version of, say, base?
21:28:09 <latro`a_> nm
21:28:43 <johnw> shachaf: take for example this definition of foldrM from Data.Foldable: "Monadic fold over the elements of a structure, associating to the right, i.e. from right to left."  That only strengthens the idea that it's the "foldr" part that means "from the right"
21:29:09 <latro`a_> @src foldrM
21:29:09 <lambdabot> Source not found. That's something I cannot allow to happen.
21:29:12 <latro`a_> bah
21:29:12 <johnw> I think what is meant here by "from right to left" is not the trivial reading
21:29:16 <dolio> shachaf: foldl' (flip (:)) [] is probably technically better, but it's also probably hard to notice.
21:29:24 <shachaf> dolio: Right.
21:29:38 <johnw> he means the associativity is from right to left, like $
21:29:58 <latro`a_> isn't $ actually infixl
21:30:06 <dolio> No.
21:30:09 <johnw> oldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
21:30:12 <johnw> f
21:30:32 <latro`a_> I stand corrected
21:30:40 <latro`a_> :info ftw
21:30:44 <shachaf> johnw: What foldr "really is" is one of those background knowledge things that you're expected to learn somehow. :-)
21:30:56 <shachaf> johnw: For some things, foldr and foldl are pretty similar. For example ByteString.
21:31:01 <Cale> johnw: somehow your remark made me think of some kind of befungification of Haskell
21:31:02 <shachaf> (Strict, that is.)
21:31:24 <shachaf> Cale: What a coïncidence. L.hs also makes me think of some kind of befungification of Haskell.
21:31:29 <Cale> Where your expressions can be wound up in 2D :)
21:31:32 <johnw> Cale: ?
21:31:39 <johnw> oh
21:31:40 <johnw> hahaha
21:31:50 <sinelaw> Cale, bufungification?
21:32:05 <Cale> sinelaw: i.e. more like the programming language befunge
21:32:16 <shachaf> 2D is passé. Fractal dimensions are where it's at.
21:32:17 <Cale> (which places instructions on a 2D grid)
21:32:58 <sinelaw> night all :)
21:33:01 <Cale> shachaf: If you're not programming infinite-dimensional reaction-diffusion systems, you're not really programming.
21:33:23 <latro`a_> ....
21:33:39 <latro`a_> depending on what you mean by infinite-dimensional that may or may not even make sense -_-
21:33:45 <johnw> someone the other day was telling me about a machine call "marbles" that executes instructions in a 3D grid: that is, the processor's instruction pointer doesn't just move forward, it can also go up, down, left, right, etc.  Allows for code packing of redundant paths
21:33:52 <shachaf> amateurgramming
21:34:13 <cornihilio> glguy_: that didn't work https://gist.github.com/3909865 but thank you for the suggestion
21:34:54 <johnw> I just discovered Foldable.find, a generic form of "lookup"
21:35:13 <glguy_> cornihilio: it would have worked but you didn't try it on the DiffTime you said
21:35:17 <shachaf> Foldable is overrated.
21:35:27 <johnw> now why would you say that?
21:35:52 <slack1256> split-obj is disregarded only for compilation times or are another aspect why is not recommended?
21:35:53 <shachaf> To confuse the enemy.
21:36:01 <johnw> ooh, good plan
21:36:08 <johnw> Foldable is just terrible
21:36:18 * shachaf isn't a big fan of Foldable.
21:36:28 <johnw> you are by definition not a big fan
21:36:53 <johnw> you're the twb of #haskell
21:36:57 * Cale isn't a big fan of a big foldable fans
21:39:19 <slack1256> *aspects
21:40:15 <cornihilio> glguy_: what am I missing? I don't understand what you are saying; the result of DTC.utctDayTime is a DiffTime, correct?
21:43:39 <glguy_> cornihilio: I don't know how you're trying to use "time", but you can definitely use truncate on a DiffTime
21:43:40 <glguy_> :t truncate $ utctDayTime undefined
21:43:40 <glguy_> truncate $ utctDayTime undefined :: forall b. Integral b => b
21:43:42 <lambdabot> Not in scope: `utctDayTime'
21:45:37 <cornihilio> I'm just subtracting a double from it
21:46:18 <cornihilio> here's the whole function: https://gist.github.com/3909898
21:47:02 <rwbarton> well no, you cannot call fromIntegral on a Double because Double is not Integral
21:47:05 <cornihilio> I don't think truncate works though: No instance for (RealFrac DTC.DiffTime) arising from a use of `truncate'
21:47:42 <rwbarton> and your type signature says you want a Double anyways, so just delete that fromIntegral
21:48:00 <rwbarton> DiffTime is an instance of RealFrac
21:48:23 <rwbarton> @type realToFrac
21:48:25 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
21:48:49 <rwbarton> how about "realToFrac time - seconds"
21:50:04 <rwbarton> no idea why you are getting that particular message
21:51:55 <rwbarton> or, perhaps "time - realToFrac seconds" if you want a result of type DiffTime
21:53:31 <cornihilio> well I want to return a Double overall, so I just removed the fromIntegral like you suggested. But the calculation of time is still a DiffTime.
21:53:54 <rwbarton> sure, you should be able to convert it to Double with realToFrac
21:54:06 <rwbarton> realToFrac is like the fromIntegral of fractional types
21:55:37 <cornihilio> rwbarton: thank you so much! that was it.
21:57:05 <cornihilio> I feel like I'm still don't understand certain parts of Haskell, primarily fromIntegral and realToFrac. Is this because I don't understand typeclasses fully? Or is it just advanced numerical conversion functions that are a bit complicated out of necessity for Haskell?
21:58:07 <geekosaur> numeric conversion issues come from strict tying; typeclasses try to relieve the pain a bit, but they only go so far if you're used to the kind of automatic type conversion in perl or python (or even C's type promotion)
21:58:23 <geekosaur> er, strict typing
21:58:46 <ion> I dislike the implicit number type conversions even otherwise strongly typed languages do.
22:00:47 <dolio> You know, that reminds me....
22:00:58 <dolio> I saw an example of typed racket last weekend.
22:01:19 <dolio> And one of the examples had some stuff where they were parsing into an Integer, and then eventually sqrting it.
22:01:29 <dolio> Getting a real number or something.
22:01:55 <dolio> And the guy said, "any questions?" And I wanted to ask, "when does the integer become not an integer?"
22:01:57 <dolio> But I didn't.
22:02:21 <ion> And then multiply the real number by a string.
22:02:42 <dolio> It might actually be a subtyping relationship there, though. Hard to say.
22:02:45 <shachaf> Silly dolio. Integers are real numbers.
22:03:02 <dolio> Nope.
22:03:13 <dolio> Not even ZF agrees with that.
22:04:03 <shachaf> typoclass would tell you how eleventy is also a real number.
22:06:13 <ion> or eleven hundred
22:06:14 <sinelaw> johnw, I just returned to update you that switching from hxt default (parsec) parser to an Expat backend solved the memory issue
22:06:24 <sinelaw> sucks that this is the situation
22:06:29 <johnw> hmm
22:06:37 <shachaf> ion: "eleven hundred" is a real number in American.
22:06:44 <sinelaw> at least hxt is cool enough to allow different parsers
22:06:55 <ion> shachaf: I know :-P
22:07:07 <johnw> what is wrong with eleven hundred?
22:07:08 <sinelaw> it's using about 10 times less memory
22:07:22 <sinelaw> that is all. night again!
22:08:30 <sm0ke> guys i have installed haskell platform...and trying to compile the first example here http://www.haskell.org/haskellwiki/OpenGLTutorial1
22:08:53 <sm0ke> but i get error error while loading shared libraries: glut32.dll: cannot open shared object file: No such file or directory
22:09:41 <sm0ke> so i dont understand haskell has opengl libs but no bindings?
22:14:03 <gienah> sm0ke: this might help: http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
22:14:37 <ivanm> sm0ke: you need to have the dll somewhere on your system
22:14:58 <ivanm> you can either have it in the correct PATH (forget the windows terminology) or else put a glut32.dll in the root directory of your project
22:14:59 <sm0ke> ok thanks let me try that
22:18:51 <Ralith> does windows even have a dynamic lib search path?
22:25:17 <cornihilio> hey, what does this runtime error signify?: parser.hs: Prelude.read: no parse
22:25:45 <rwbarton> > read "kablooie" :: Int
22:25:47 <lambdabot>   *Exception: Prelude.read: no parse
22:25:47 <shachaf> Prelude.read didn't parse.
22:27:56 <cornihilio> rwbarton: thanks for explaining it :)!
22:47:40 <startling> I saw this post and it's got my head spinning: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
22:48:22 <startling> I was thinking: if I wanted to write a game using comonads like that, how could I keep track of which parts have been generated already?
22:48:39 <startling> say, if I wanted to iterate over all the characters and let them move
22:49:29 <edwardk> change your worldview. don't iterate over all the characters. you have tiles. those tiles have state. now you generate a new board state by letting each tile investigate the state of its neighbors and determine a new state.
22:49:47 <edwardk> its not good for games like chess or things where you alternate and make a single move
22:49:57 <startling> hm, interesting
22:49:58 <edwardk> but it is good for games like life
22:50:20 <startling> wouldn't it spin infinitely if I just told it to go, though?
22:50:23 <edwardk> you can find a use for comonads in other settings, but you don't usually use them as the overall control structure
22:50:24 <startling> OH
22:50:29 <startling> only if I ask what's there
22:50:33 <edwardk> yep
22:50:37 <startling> neat
22:50:48 <edwardk> you just inspect what you can see from some camera or perspective
22:50:52 <edwardk> and there you go, demand driven
22:50:55 <startling> yeah. woah
22:51:00 <startling> that's really powerful
22:51:32 <edwardk> you can concoct ways to price financial derivatives this way, and generally play lots of simultaneous play games
22:52:09 <startling> it feels like it'd be noncomputable
22:52:23 <edwardk> well, consider a blur kernel
22:52:37 <edwardk> i just ask for say, the pixel above, left, below and to the right of me and average
22:52:43 <startling> yeah.
22:52:56 <edwardk> then extending that kernel takes an image to a new image
22:53:13 <edwardk> that operation works even for infinitely large images
22:53:31 <startling> but it'd take infinitely long, right?
22:53:35 <edwardk> to compute the new infinitely large image i only need one 1 larger to start with
22:53:45 <startling> (if you tried to do something with all of it, in haskell)
22:53:48 <edwardk> no, any one step of the diffusion can be inspected at any point
22:53:59 <startling> but not as a whole
22:54:04 <startling> right?
22:54:08 <edwardk> say i blur 5 times. it may be a little slow for me to inspect the value of some pixel
22:54:21 <edwardk> yeah but why would you ask for the value everywhere of something infinite? =)
22:54:29 <startling> indeed
22:54:33 <edwardk> pick a neighborhood and go
22:55:12 <startling> I'm gonna risk the possibility of bias and ask if I should use this: maybe you're biased, but should i use this?
22:55:14 <startling> bah
22:55:16 <startling> http://hackage.haskell.org/package/comonad
22:55:37 <startling> started using gui emacs, not used to system clipboard and emacs clipboard being the same
22:56:33 <mzero> anyone here have the windows haskell package installed?
22:56:37 <mzero> er
22:56:42 <mzero> windows haskell platform?
22:56:52 <edwardk> should you use the comonad package?
22:56:57 <edwardk> for comonads?
22:57:05 <startling> that's my question, yes
22:57:08 <startling> probably a little silly
22:57:15 <edwardk> if you have a comonad it is kind of the obvious place to go ;)
22:57:32 <edwardk> it was written to be the standardizable form of the comonad class
22:57:50 <edwardk> its pretty non-controversial
22:58:01 <startling> good to know!
22:58:13 <edwardk> if you wanted to ask about something like comonad-transformers they become a little more esoteric
22:58:22 <shachaf> Not to be confused with edwardk's effort to standardize all the common operators for automatic differentiation, "commonad".
22:58:24 <edwardk> but even there its pretty much 'the only definition that makes sense'
22:58:30 <edwardk> shachaf: hahaha
22:58:55 <edwardk> i've actually been working up slowly towards doing an 'ai' package
22:58:59 <startling> shachaf: heh
22:59:40 <edwardk> i've yet to descend to 1 character package names at least
22:59:52 <startling> hmmm, so it seems like the hardest part would be writing ways to generate stages
23:01:24 <edwardk> @remember shachaf [comonad] Not to be confused with edwardk's effort to standardize all the common operators for automatic differentiation, "commonad".
23:01:24 <lambdabot> It is stored.
23:05:32 <basdirks_> http://www.ioccc.org/2012/tromp/hint.html
23:16:19 <mzero> bizarre, GLUT-2.1.2.1 haddock won't build for me --- and haddock just dies, silently without generating anything!
23:18:58 <startling> edwardk: so what would I do if I wanted to serialize the state of one of these?
23:24:27 <hpaste> sheriff_ pasted “Moo” at http://hpaste.org/76434
23:24:32 <sheriff_> Hi
23:24:45 <sheriff_> With the above code, I get: Ambiguous type variable `var' in the constraint
23:24:55 <sheriff_> When I try and do: showMoo Boo
23:25:04 <sheriff_> I'm not sure why
23:25:13 <sheriff_> Or rather, I can guess why, but not sure on the best way of fixing it
23:25:55 <kosmikus> sheriff_: you'll need to provide a type signature for Boo in this context
23:26:12 <sheriff_> kosmikus: I'm not sure what you mean
23:26:26 <kosmikus> sheriff_: showMoo (Boo :: Moo Int)
23:26:57 <sheriff_> So a second type signature for ShowMoo?
23:27:28 <kosmikus> sheriff_: no. when you call showMoo, GHC has to know what type you apply it to.
23:27:41 <kosmikus> sheriff_: for Boo, it'll infer "Moo a" (without knowing the "a").
23:27:53 <kosmikus> sheriff_: but that's not enough to resolve the Show / Things constraints in this case.
23:28:07 <sheriff_> OK. It is - in fact - enough for it to resolve it for Show
23:28:14 <sheriff_> But not enough for my user-defined type class
23:28:37 <kosmikus> sheriff_: in GHCi, you get what's called "extended defaulting"
23:28:38 <sheriff_> Any idea why?
23:29:22 <sheriff_> ahhh
23:29:30 <sheriff_> So if I provide a mapping for unit
23:29:33 <sheriff_> Will I be ok?
23:29:55 <kosmikus> sheriff_: http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules
23:30:47 * sheriff_ looks
23:31:31 <sheriff_> ah, so it's magic for Show, Eq, and Ord
23:31:35 <sheriff_> That would explain it
23:32:12 <kosmikus> sheriff_: if you make a mapping for unit, it will indeed work (in GHCi, or if you enable extended defaulting)
23:32:20 <kosmikus> but yes, it's magic to a certain extent
23:33:34 <kosmikus> sheriff_: the presence of a Show constraint will make it try defaulting, and if you have an instance for "Things ()", then it will do it
23:34:09 <kosmikus> sheriff_: if you really want this behaviour (not just in GHCi), you'll have to add a LANGUAGE ExtendedDefaultRules pragma to your source file(s)
23:34:10 <hpaste> sheriff_ pasted “Moo” at http://hpaste.org/76435
23:34:28 <sheriff_> I've tried adding an instance for unit there - have I done it wrong?
23:35:18 <kosmikus> sheriff_: doesn't it work?
23:35:23 <sheriff_> It does not
23:35:37 <ZfeIlDuce> How come the fact that () both denotes a type and a value does not cause any ambiguities in Haskell's grammar/
23:35:41 <sheriff_> Not even with -XExtendedDefaultRules
23:35:45 <kosmikus> sheriff_: works for me
23:35:51 <sheriff_> kosmikus: ORLY
23:35:56 <shachaf> ZfeIlDuce: What's a place it could cause ambiguities?
23:35:57 <sheriff_> kosmikus: What version of GHCi?
23:36:06 <shachaf> Lots of things can be either types or values.
23:36:30 <ZfeIlDuce> shachaf, do you have an example?
23:36:34 <kosmikus> sheriff_: 7.4.2 in this example. but I'd be surprised if this changed recently.
23:36:41 <ZfeIlDuce> () is basically a nullary type constructor, right?
23:36:46 <kosmikus> sheriff_: what's yours?
23:36:48 <sheriff_> I have 6.12.1
23:36:52 <sheriff_> Is that terribly old?
23:37:17 <rwbarton> it is pretty old, about two years
23:37:28 <sheriff_> Old enough to be significant for why this isn't working?
23:37:51 <kosmikus> sheriff_: oh yes, quite
23:38:07 <kosmikus> sheriff_: let me see if I have something that old lying around
23:38:43 <kosmikus> sheriff_: ah yes, I do.
23:38:59 <kosmikus> sheriff_: it doesn't work with 6.12.1. I think this may be before extended defaulting was introduced.
23:39:22 <kosmikus> sheriff_: so then the type annotation is the only way.
23:39:26 <rwbarton> or maybe it just wasn't quite as extended
23:39:41 <sheriff_> OK. I will upgrade.
23:39:53 <kosmikus> sheriff_: note, though, that this isn't a huge problem in practice. it only occurs if you apply "showMoo" to a "Boo" directly, like you're trying here.
23:40:07 <sheriff_> Sadly this is homework related, and I'm trying to be clever and show off
23:40:18 <sheriff_> This has thwarted my ability to show off
23:40:21 <kosmikus> sheriff_: if you take the Boo out of a data structure, say a list or a tree, or a some compound datatype, then usually its type is statically known, and it'll just work.
23:40:34 <sheriff_> Not an option, sadly
23:40:36 <rwbarton> hmm, documentation for 6.12.1 is basically the same
23:41:17 <sheriff_> kosmikus: Thanks so much for your help!
23:41:22 * sheriff_ sets it building
23:41:45 <kosmikus> sheriff_: you should probably just install the latest Haskell Platform
23:42:04 <sheriff_> ... probably. I'll look in to that instead.
23:42:08 <kosmikus> sheriff_: http://www.haskell.org/platform/
23:42:23 <kosmikus> sheriff_: that'll give you ghc-7.4.1
23:45:04 <sm0ke> guys anyone using opengl + glut with haskell on windows? http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/  seems pretty outdated to me and it just wont work for me
23:45:52 <sm0ke> i already have glut and opengl libs and dlls which came with default windows sdk
23:46:31 <sm0ke> stil getting error while loading shared libraries: glut32.dll: cannot open shared object file: No such file or directory...althouh i even copied that dll to the working directory
23:51:29 * hackagebot linearEqSolver 1.0 - Solve linear systems of equations over integers.  http://hackage.haskell.org/package/linearEqSolver-1.0 (LeventErkok)
23:56:29 * hackagebot pushme 1.0.0 - Script I use for synchronizing my data among machines  http://hackage.haskell.org/package/pushme-1.0.0 (JohnWiegley)
