00:07:16 <startling> @hoogle (a -> Bool) -> [a] -> [a]
00:07:17 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
00:07:17 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
00:07:17 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
00:07:53 <startling> is there keepUntil ?
00:08:15 <shachaf> takeWhile (not . p)?
00:08:27 <startling> oh, that works. thanks
00:12:39 <Nereid> @type takeWhile .: not
00:12:40 <lambdabot>     Couldn't match expected type `g (a -> Bool)'
00:12:40 <lambdabot>            against inferred type `Bool'
00:12:40 <lambdabot>       Expected type: Bool -> g (a -> Bool)
00:12:42 <Nereid> oops.
00:12:47 <Nereid> @type takeWhile . (not.)
00:12:49 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:12:55 <startling> :t takeWhile . (.) not
00:12:56 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:12:58 <startling> is what I ended up doing
00:13:32 <startling> :t flip until tail
00:13:33 <lambdabot> forall a. ([a] -> Bool) -> [a] -> [a]
00:24:57 <cornihilio> excuse me, what is the best way to take the mod of a double?
00:25:10 <cornihilio> with another double, sorry
00:25:51 <srhb> a
00:26:16 <shachaf> Data.Fixed.mod'?
00:26:35 <flux> @hoogle Double -> Double -> Double
00:26:36 <lambdabot> Prelude asTypeOf :: a -> a -> a
00:26:36 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
00:26:36 <lambdabot> Control.DeepSeq deepseq :: NFData a => a -> b -> b
00:26:50 <flux> meh :)
00:27:09 <flux> I imagine there's a function to do that, somewhere
00:27:28 <flux> @hoogle Fractional -> Fractional -> Fractional
00:27:29 <lambdabot> Warning: Unknown type Fractional
00:27:29 <lambdabot> Prelude asTypeOf :: a -> a -> a
00:27:29 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
00:28:06 <sm0ke> oh yea ! got it working binaries from here http://www.transmissionzero.co.uk/software/freeglut-devel/
00:30:22 <cornihilio> thanks!
00:30:34 <cornihilio> I have this in my code: instance Ord PacketRaw where compare p1 p2 = compare (quoteAcceptTime p1) (quoteAcceptTime p2)
00:31:14 <cornihilio> but the problem is that sometimes it isn't accurate, specifically because the values overlap (it counts seconds in a day, so it might go back to 0)
00:31:36 <cornihilio> how do I make a compare statement that takes two values to check into account?
00:31:39 <cornihilio> I hope that makes sense.
00:33:54 <Claudius1aximus> :t mappend :: (a -> a -> Ordering) -> (a -> a -> Ordering) -> a -> a -> Ordering
00:33:55 <lambdabot> forall a. (a -> a -> Ordering) -> (a -> a -> Ordering) -> a -> a -> Ordering
00:35:23 <cornihilio> how does it work? the secondary ordering trumps the first?
00:35:44 <shachaf> cornihilio: Test it out!
00:35:55 <Claudius1aximus> i'm not sure
00:36:31 <Claudius1aximus> @src Ordering mappend
00:36:31 <lambdabot> Source not found. You speak an infinite deal of nothing
00:36:46 <cornihilio> thank you!
00:39:04 <Claudius1aximus> unfortunately the source links for Data.Ord on hackage are broken so i can't look - they have %01 %02 instead of something sensible :S
00:41:55 <Claudius1aximus> ah, it's here http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/src/Data-Monoid.html#line-138
00:43:02 <Claudius1aximus> lexicographical ordering - if the first differs, then use that, if the first equal, take the second
00:55:24 <startling> how do I make cabal build a module with hsc2hs that's not exposed?
00:56:04 <dcoutts> startling: it just works, remember: you have to list *all* modules either in exposed-modules, or other-modules.
00:56:16 <startling> oh, didn't know about other-modules
00:56:26 <startling> that would explain it. thanks!
00:57:58 <startling> this is, coincidentally, the first time I've written a .cabal file with hidden modules
01:24:24 <bartavelle> what is a good testing framework to build my "testing dsl" on top of ?
01:24:43 <bartavelle> it seems there are a lot of them
01:26:38 <Polarina> mm_freak, generally, I want to be able to control what wires are managed. Sometimes I'd want to remove or add just a single wire, sometimes I want to get rid of a lot of them at once. That is, I do not think a key based manager wire like in netwire-1 would be nice enough.
01:27:15 <startling> can I have a not-real-name nick as my username on hackage?
01:28:06 <startling> apparently not. man. :/
01:28:25 <Polarina> mm_freak, one way would be {  manager :: (Monoid b) => Wire e m ([Wire e m a (Bool, b)], a) b  }, where the managed wire itself decides to not wanted to be tracked anymore by outputting False in the output tuple.
01:28:41 <Polarina> mm_freak, the manager wire would then take a list of new wires to start to manage.
01:29:56 <Polarina> mm_freak, the type signature would obviously need some tweaking. But it still seems like a nice solution.
01:34:16 <Polarina> mm_freak, b <- manager -< ([newMonster], universe)   ---   newMonster = proc universe -> do ... returnA -< (isStillAlive, MonsterPosition ...)
01:38:42 <Polarina> mm_freak, I'm not sure how you'll like it, but another idea would be {  manager :: (Monoid e', Monoid b) => Wire e m ([Wire e' m a b], a) (e', b)  } where the managed wires that inhibit would no longer be tracked. So, when a monster inhibits, it dies. This way I could easily have a list of dying monsters.
01:39:41 <hoho> test
01:39:48 <Polarina> s/when a monster inhibits, it dies/when a monster should die, it inhibits/
01:40:40 <merijn> Is there some explanation of what inhibiting actually means in netwire? i.e. some sort of explanation how to use inhibitin? I don't think I've seen anything like that yet...
01:41:49 <Polarina> merijn, inhibitation is for example used for events. http://www.haskell.org/haskellwiki/Functional_Reactive_Programming has some examples.
01:42:58 <Polarina> merijn, it is used for the Alternative instance. Like { myLabel = fmap show time . keyDown Space <|> "Press space" }
01:43:24 <Polarina> merijn, keyDown inhibits when the key is not down (event didn't happen), acts as an identity wire (id) when the key is down.
01:43:41 <dmwit> shachaf: lies
01:43:52 <shachaf> dmwit: ?
01:43:57 <shachaf> Oh, cmccann's thing?
01:44:12 <dmwit> It actually took me a while to figure out what "dmwith" was supposed to be. =P
01:44:22 <shachaf> De Morgan with?
01:44:26 <dmwit> De Morgan with, I think.
01:44:26 <dmwit> yeah
01:44:43 <shachaf> dmwit: We were trying to figure out logarithms or something.
01:44:49 <shachaf> Maybe you know what those are.
01:45:09 <dmwit> noooo
01:45:22 <Polarina> merijn, this allows for easy composition as well, when you want to check for many events. A silly example would be { areAllArrowKeysDown = leftKeyDown . upKeyDown . rightKeyDown . downKeyDown }.
01:45:25 <companion_cube> logarithms are like monads, because they actually are nothing like burritos
01:45:33 <shachaf> dmwit: I think the conclusion was that (0^x) is actually log(x)
01:46:04 <dmwit> That... sounds a little strange.
01:46:38 <Polarina> merijn, did that make things any clearer for you? :/
01:46:53 <dmwit> I am assuming (^) is really (-o) here...?
01:47:04 <shachaf> -o?
01:47:14 <imperative_coder> hello
01:47:20 <dmwit> ⊸
01:47:39 <shachaf> Are you talking about linear logic or something?
01:47:51 <imperative_coder> where can I find the source for stdlib stuff like data.Text?
01:47:55 <imperative_coder> Data*
01:47:56 <Polarina> imperative_coder, hi.
01:48:01 <shachaf> imperative_coder: Hackage.
01:48:06 <shachaf> Alternatively: Google.
01:48:08 <srhb> imperative_coder: Hackage is always good, standard stuff can also be found on Hoogle
01:48:12 <dmwit> shachaf: Wait, were you not talking about linear logic?
01:48:19 <Polarina> imperative_coder, http://hackage.haskell.org/package/text
01:48:20 <shachaf> @google haskell data.text source
01:48:21 <lambdabot> http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text.html
01:48:22 <lambdabot> Title: Data.Text
01:48:23 <imperative_coder> thanka
01:48:27 <dmwit> cmccann's post is full of it.
01:48:30 <shachaf> dmwit: No, just regular Haskell types.
01:48:37 <shachaf> dmwit: Yes, but that only came about as incidental.
01:49:37 <dmwit> Okay. log(x) = 0^x still looks like a strange equation even as a plain Haskell type (where now I'm assuming (^) is (->)).
01:49:40 <imperative_coder> Trees are so natural in haskell cmpared to languages like C and C++ ^^
01:49:45 <shachaf> Someone pointed out that Log (a,b) == Either (Log a) (Log b) looked a lot like De Morgan's law.
01:49:59 <shachaf> With Log = Not, i.e. (-> Void), i.e. (0^)
01:50:18 <sopvop> how does one uses mapM with TH function? `mapM $generatePrinterParsers [''Foo, ''Bar]` does not typecheck. `$(generatePronerParsers ''Foo)` works.
01:50:22 <dmwit> Since then I would expect there is some type A such that A^log(x) = A^(0^x)...
01:50:45 <dmwit> ...= x
01:50:49 <shachaf> dmwit: What's a good law for Log that (Const Void) and/or (-> Void) don't satisfy?
01:51:02 <shachaf> I think talking about bases might be misleading.
01:51:03 <sipa> why call it Log?
01:51:36 <shachaf> Why not?
01:51:41 <Polarina> imperative_coder, haskell was designed around trees (and monads).
01:51:42 <dmwit> Didn't I just write a good law for Log that (-> Void) doesn't satisfy?
01:51:56 <dmwit> I don't think talking about bases is misleading. Logs have bases.
01:52:04 <shachaf> What if it's Ln?
01:52:17 <dmwit> ln has abase, too.
01:52:21 <shachaf> Once upon a time I thought Bag x was e^x, but that's wrong.
01:53:52 <merijn> Polarina: A little bit, yes
01:58:00 <dmwit> Anyway, there are two De Morgan laws, and only one of them looks like a Log law.
01:58:27 <dmwit> So I think that resemblance is just a coincidence.
02:00:27 <shachaf> dmwit: OK, so what *is* Log?
02:01:42 <dmwit> The inverse of (->), when it exists.
02:01:45 <shachaf> Hmm, Not (a,b) ==> Either (Not a) (Not b) is the one law that's not actually valid, isn't it?
02:01:50 <dmwit> (...boring, I know...)
02:02:44 <shachaf> C'mon, man.
02:03:21 <shachaf> d(log(x))/dx = 1/x
02:03:35 <shachaf> So what does that mean? like, whoa, dude
02:04:05 <dmwit> log takes two arguments, just like (->)
02:04:33 <dmwit> ...well, the log *I* want to talk about, anyway. ;-)
02:05:15 <shachaf> > log 5
02:05:16 <lambdabot>   1.6094379124341003
02:05:24 <dmwit> There is a paper that tries to make sense of negative and reciprocal types, if you're interested in that.
02:05:36 <shachaf> That was the "everything is continuations" paper?
02:05:45 <shachaf> Or something like that.
02:06:03 <paolino> hello, I just stepped on this, so I felt to share.  "runReader (sequence $ iterate (>>= return) (return 0)) 0" is slowing down on producing 0 linearly, while "runReader (sequence $ iterate (>>= const ask) (return 0)) 0" is producing at constant speed.
02:06:08 <dmwit> "Two Dualities of Computation" or something like that.
02:06:17 <dmwit> There's a copy on github.com/dmwit/pi-eta-epsilon.
02:06:51 <shachaf> dmwit: Q: Why is ε afraid of ζ?
02:07:02 <shachaf> A: Because ζηθ!
02:07:17 <dmwit> >_<
02:07:27 <hoho> ??
02:07:32 <merijn> What's ζ? I forgot
02:07:33 <Ralith> hahahah
02:07:37 <dmwit> zeta
02:08:21 <merijn> hoho: It reads "zeta eta theta"
02:08:39 <dmwit> "zeta ate a theta"
02:09:05 <imperative_coder> lol
02:09:35 <shachaf> I guess these belong in #-blah
02:09:44 <shachaf> But dmwit's not in there!
02:09:52 <dmwit> I wonder: do ESL folks know the "standard" jokes?
02:10:15 <dmwit> Yes, I have enough ways to procrastinate without that one. I could spend all day in there.
02:10:35 <shachaf> The "standard" jokes? Like miles, pounds, Fahrenheit?
02:11:31 * hackagebot idiii 0.1.3 - ID3v2 (tagging standard for MP3 files) library  http://hackage.haskell.org/package/idiii-0.1.3 (BartonMassey)
02:11:34 * hackagebot idiii 0.1.3.1 - ID3v2 (tagging standard for MP3 files) library  http://hackage.haskell.org/package/idiii-0.1.3.1 (BartonMassey)
02:11:42 <dmwit> Like the one your joke is referencing, obviously. =)
02:12:37 <Claudius1aximus> µha
02:14:54 <imperative_coder> I have a string that contains substrings "foo", which I may replace anytime with "bar", and I want to compute all the different ways I can replace each instance of foo with bar. How do I solve this?
02:16:57 <pettter> imperative_coder: sounds like something to be solved with recursion and a binary search tree
02:17:26 <Ralith> count the number of instances of 'foo', apply standard combinatorial methods, reconstruct output strings?
02:17:56 <dmwit> How did "compute all ways" become "count all ways"?
02:18:07 <Claudius1aximus> what if "bar" is really "" and you have "ffoooo" as input, what happens?
02:18:11 <Ralith> did it?
02:20:11 <dmwit> what if "foo" is really "ana" and you have "banana" as input, what happens?
02:21:27 <imperative_coder> dmwit: then you can have ["banana", "bbarna", "banbar"]
02:22:04 <dmwit> Anyway, this seems like a pretty straightforward dynamic-programming problem.
02:22:07 <imperative_coder> right
02:22:25 <imperative_coder> what is the name of this problem? I want to google it ^^
02:23:00 <imperative_coder> I'm too weak to figure out my own solution, so maybe there's a Math.Combinatorial library that will do the job for me ^^
02:23:27 <merijn> imperative_coder: dynamic programming (as dmwit says) is the term to Google
02:23:36 <imperative_coder> right
02:23:51 <imperative_coder> I think without DP this would be O(2^n) :(
02:24:11 <dmwit> It probably is even with DP.
02:24:26 <dmwit> I mean, the length of the output is O(2^n).
02:24:54 <imperative_coder> right
02:25:01 <dmwit> I guess that's not 100% fair because of sharing.
02:25:06 <imperative_coder> so I will need a tree structure
02:25:30 <sheriff_> I am truing to find a 'cheap' way to have a heterogenous list
02:25:32 <dmwit> Yeah, you'll probably get the tree structure for free if you're careful about it (though not observably so).
02:26:00 <dmwit> sheriff_: Switch to an untyped language.
02:26:01 <sheriff_> ah, my cunning plan won't work
02:26:07 <dmwit> no cheap ways in Haskell
02:26:08 <sheriff_> I had this crazy idea about lambdas
02:26:41 <Ralith> dmwit: expensive in what terms?
02:26:53 <sheriff_> :r
02:27:13 <dmwit> You're asking the wrong guy.
02:27:57 <imperative_coder> maybe if Haskell had an 'Anything' type
02:28:09 <imperative_coder> then we can have lists of [Anything]
02:28:15 <osfameron> sheriff_: why do y ou want a heterogenous list?
02:28:24 <dmwit> You can't do anything with a [Anything].
02:28:31 <dmwit> It's no better than [()].
02:29:08 <osfameron> http://www.haskell.org/haskellwiki/Heterogenous_collections
02:29:17 <startling> weird, if you use my ncurses bindings in runhaskell, it puts spaces in between all the addchs.
02:29:19 <dmwit> (We have Anything. It's spelled data Anything = forall a. Anything a, and it's not at all useful.)
02:29:28 <imperative_coder> ah
02:29:40 <Ralith> dmwit: looks like you made a cost judgement to me.
02:30:01 <osfameron> there's HList and Typeable and so on though?
02:30:23 * Ralith suspects that osfameron should stop giving sheriff_ Ys before finding out what his X is
02:30:41 <osfameron> Ralith: I asked him what his X was above ;-)  now I'm just musing
02:31:17 <Ralith> perhaps harmfully!
02:31:32 * hackagebot idiii 0.1.3.2 - ID3v2 (tagging standard for MP3 files) library  http://hackage.haskell.org/package/idiii-0.1.3.2 (BartonMassey)
02:31:36 <startling> what does runhaskell do differently?
02:31:39 <startling> does it print things?
02:31:55 <osfameron> Ralith: heh
02:32:09 <dmwit> startling: differently from what?
02:32:28 <startling> dmwit: differently from a compiled executable
02:32:40 <startling> my ncurses bindings are buggy under runhaskell
02:35:05 <imperative_coder> what's the most efficient way to transform something like "foobar" into [('a', 1), ('b', 1), ('f', 1), ('o', 2), ('r', 1)] ?
02:35:27 <dmwit> The manual seems to imply than runghc interprets your code. Perhaps this also implies that it uses the threaded runtime and no optimization.
02:35:29 <merijn> imperative_coder: fold with a map as accumulator
02:35:39 <dmwit> You might compare runghc to what ghci does.
02:36:17 <dmwit> The other big difference I know about is that ghci has a different default buffering than compiled code. No idea where runghc fits in there.
02:36:31 <imperative_coder> how would that look like?
02:36:49 <paolino> a *Map
02:37:02 <imperative_coder> ah
02:37:05 <dmwit> fromListWith (+) [(c, 1) | c <- "foobar"]
02:37:22 <imperative_coder> so I need a listcomp?
02:37:37 <dmwit> No. You never *need* a list comprehension.
02:37:55 <merijn> :t foldl
02:37:56 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:38:39 <merijn> imperative_coder: think of foldl as: "(Map Char Int -> Char -> Map Char Int) -> Map Char Int -> String -> Map Char Int"
02:38:41 <startling> dmwit: hmm, weird
02:39:07 <dmwit> merijn: Why would you use foldl instead of fromListWith or one of the API-provided accumulators?
02:39:22 <merijn> dmwit: Oh, I guess that'd work to
02:39:31 <merijn> dmwit: Mostly because I'm not that familiar with Map :p
02:39:36 <startling> dmwit: the buffering could be it. I don't think it'd be the threading or optimization, though
02:39:41 <startling> because all this stuff is in IO
02:42:02 <imperative_coder> why is listcomp considered poor style by some?
02:42:22 <startling> you can write long ugly lines in listcomps
02:42:26 <dmwit> Are list comprehensions considered poor style by some?
02:43:27 <Iceland_jack> dmwit: it depends very much on the problem
02:45:20 <dmwit> Badly styled list comprehensions are bad style. I doubt anyone would claim much more than that.
02:46:38 <dmwit> All the best tools can be used both for great beauty and for great evil.
02:46:49 <imperative_coder> what would the fromListWith (+) [(c, 1) | c <- "foobar"]
02:46:54 <imperative_coder> look like without listcomp*
02:47:37 <Iceland_jack> fromListWith (+) (map (\c -> (c, 1)) "foobar")
02:47:38 <dmwit> fromListWith (+) (map (\c -> (c, 1)) "foobar") -- one possible alternative spelling
02:48:03 <imperative_coder> ah
02:48:11 <imperative_coder> the listcomp looks more elegant
02:48:24 <Iceland_jack> I agree
02:48:43 <dmwit> fromListWith (+) (flip (,) 1 . "foobar") -- another
02:49:11 <imperative_coder> I don't understand how (.) works :(
02:49:16 <Iceland_jack> imperative_coder: Ignore that
02:49:25 <Iceland_jack> you wouldn't write it like that
02:49:32 * osfameron finds listcomps more confusing
02:49:38 <dmwit> Yes, this second one was mostly a joke.
02:49:41 <imperative_coder> lol
02:49:59 <Iceland_jack> > (,) 10 20
02:50:00 <lambdabot>   (10,20)
02:50:12 <dmwit> In particular because it relies on the somewhat questionable convention in lambdabot that (.) = fmap.
02:50:23 <imperative_coder> lol
02:51:51 <imperative_coder> http://ideone.com/uNoTf any ways I can improve this code?
02:54:01 <imperative_coder> is it alright to take advantage of the fact that where 'captures' the function argument?
02:54:18 <zomg> Looks alright to me but not really pro fp :)
02:54:36 <imperative_coder> :(
02:54:47 <zomg> I mean I'm not pro at fp
02:54:47 <zomg> :P
02:54:50 <imperative_coder> I'm still stuck in the imperative mindset
02:56:21 <ClaudiusMaximus> > inRange (1,5) 3
02:56:22 <lambdabot>   True
02:56:40 <sheriff_> osfameron: I am including some test data in an assignment
02:56:55 <ClaudiusMaximus> but defining between is ok
02:56:57 <ziman> imperative_coder, does it work?
02:57:04 <sheriff_> That's what I ended up with
02:57:16 <sheriff_> http://hpaste.org/76437
02:57:24 <ziman> imperative_coder, readLn returns a String but grade takes an Int
02:57:32 <ClaudiusMaximus> :t readLn
02:57:33 <lambdabot> forall a. (Read a) => IO a
02:57:39 <sheriff_> Actually, is how I give type signatures for bound version of simpleCheck sane there?
02:57:42 <sheriff_> Anyone?
02:57:52 <ziman> ah, I confused it with readLine, cool.
02:58:05 <ziman> (or is it getLine?)
02:58:38 <ClaudiusMaximus> :t getLine
02:58:39 <lambdabot> IO String
02:59:19 <ziman> @index readLn
02:59:19 <lambdabot> System.IO, Prelude
02:59:38 <fmap> sheriff_: do you really need type signatures here?
02:59:57 <sheriff_> fmap: Doesn't work without them
02:59:58 <fmap> sheriff_: also `foldr (&&) True' is Data.List.all
03:00:21 <fmap> oh
03:00:28 <sheriff_> fmap: I am intentionally implementing each function explicitly
03:00:28 <fmap> Data.List.and
03:01:22 <ClaudiusMaximus> imperative_coder: also, lazy evaluation will possibly only error out after you've finished entering all the marks, and try to print the collated table - which could get irritating if you're entering by hand
03:03:28 <fmap> sheriff_: and what's the error is if you omit type signatures?
03:03:45 <sheriff_> fmap: Ambiguous type signature
03:04:20 <sheriff_> well, if I try and use the same simpleCheck for each
03:05:31 <ClaudiusMaximus> imperative_coder: if you don't need a prompt, then something like this would be more fp-style   interact (show . M.fromListWith (+) . map (flip (,) 1 . grade . read) . lines)   -- despite the name, interact gets irritating for interactive use
03:08:39 <fmap> sheriff_: does it error even if you replace only ti and ts with simpleCheck?
03:12:42 <augustss> howdy
03:13:42 <augustss> Is there a cool way to write the function of type Maybe (a,b) -> (Maybe a, Maybe b)?
03:14:43 <int-e> @type fmap fst &&& fmap snd
03:14:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> (f a, f b)
03:15:05 <augustss> Yeah, but I was hoping for something even cooler. :)
03:15:20 <Jafet> Tuples aren't cool.
03:15:45 <augustss> These are pairs.  Pairs are cool.
03:16:26 <imperative_coder> thanks for the feedback
03:17:00 <imperative_coder> so readLn parses a String into something that is an instance of Read?
03:18:16 <int-e> augustss: http://hackage.haskell.org/packages/archive/TypeCompose/0.9.1/doc/html/Data-Zip.html ;-)
03:19:43 <Jafet> @hoogle strength
03:19:44 <lambdabot> No results found
03:19:57 <augustss> Aha, Data.Zip
03:20:58 <int-e> it's curious that Caleskell doesn't generalize unzip that way :)
03:21:00 <int-e> @type unzip
03:21:01 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
03:21:17 <int-e> @type (.)
03:21:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:21:21 <augustss> Don't tell Cale
03:21:21 <dcoutts_> augustss: or another general way to look at it is as a transpose
03:22:04 <startling> is there a takeWhile that takes the first one that fails, too?
03:23:06 <ClaudiusMaximus> :t span
03:23:07 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:23:27 <sheriff_> > ord '\0' = 0
03:23:28 <sheriff_> > ord x = 1 + ord (pred x)
03:23:29 <lambdabot>   <no location info>: parse error on input `='
03:23:29 <lambdabot>   can't find file: L.hs
03:23:35 <sheriff_> Would it be reasonlable to describe that as "Peano style"?
03:23:42 <int-e> @hoogle (a -> Bool) -> [a] -> ([a] -> [a], [a])
03:23:43 <lambdabot> No results found
03:23:55 <startling> ClaudiusMaximus, span includes the one that fails in the latter list
03:24:06 <startling> I could adjust it afterwards, but...
03:24:13 <Jafet> :t (listToMaybe *** listToMaybe) . unzip . maybeToList
03:24:14 <lambdabot> forall a a1. Maybe (a, a1) -> (Maybe a, Maybe a1)
03:24:16 <startling> sheriff_, mathematical induction!
03:24:22 <ClaudiusMaximus> startling: exactly, then you can pattern match on it
03:24:35 <ClaudiusMaximus> there might not be one that fails..
03:24:39 <startling> ClaudiusMaximus: fair enough.
03:25:33 <ClaudiusMaximus> startling: i think there is something like "takeWhileAndThen" to avoid repeated traversals, somewhere...
03:25:43 <augustss> Jafet, that works, but does not qualify as cool. :)
03:30:56 <merijn> There's no way to implement a Rank2Types version of read, right? i.e. "instance Read (Foo a) where" where read is "String -> forall a . Foo a"?
03:33:36 <int-e> merijn: well, if you have that instance, then you can write a readFoo of that type. But for the instance, a is pretty much forced to be a phantom type.
03:36:08 <int-e> (in fact,  readFoo :: String -> (forall a. Foo a) ; readFoo = read  works - contrary to my expectation that I'd have to eta-expand the equation to  readFoo s = read s. Why?)
03:36:56 <Jafet> Is that a rank-2 type
03:40:59 <int-e> on the face, yes, but ghc simplifies it to a normal HM polymorphic type, forall a. String -> Foo a
03:51:48 <GnomeStoleMyBike> @time
03:51:52 <lambdabot> Local time for GnomeStoleMyBike is Thu Oct 18 11:51:28 2012
04:04:28 <byorgey> String -> (forall a. Foo a)  is not a rank-2 type, even on its face.  The rank of a type is specifically defined as the deepest nesting of forall on the *left* of arrows.
04:05:16 <byorgey> i.e.  rank(forall a. T) = 0; rank(S -> T) = max (1 + rank S) (rank T)
04:07:51 <Nereid> byorgey: shouldn't rank(forall a. T) be 1?
04:08:06 <byorgey> uh, yes, sorry
04:08:28 <byorgey> and it's still not quite right, e.g. what if there are more foralls inside T?
04:08:35 <byorgey> but anyway, that's the idea
04:08:54 <Nereid> I guess the assumption was that S and T didn't have any quantifiers
04:10:07 <Nereid> er no.
04:11:38 <Nereid> ugh, why does portage want to downgrade ghc to 6.12.3
04:12:45 <Nereid> oh, some EAPI thing
04:18:58 <may3> "hello"
04:19:20 <byorgey> hi may3
04:19:56 <michael___> hi :)
04:20:37 <odi> in my code there are some pre-processor instructions e.g. #if !MIN_VERSION_base(4,6,0)
04:20:48 <odi> if i load it into ghci i got following error
04:20:59 <odi> error: missing binary operator before token "(" phase `C pre-processor' failed (exitcode = 1)
04:20:59 <odi>  
04:21:25 <odi> whats wrong, or how could i load this file into ghci?
04:22:04 <Nereid> regular ghc accepts it?>
04:23:28 <odi> yes if i compile it with cabal there is no problem
04:23:29 <Nereid> ah, no it doesn't
04:23:32 <Nereid> hm
04:23:46 <Nereid> plain ghc doesn't like that here.
04:24:29 <Nereid> hmm
04:24:31 <Nereid> you know
04:24:40 <Nereid> maybe that's because cabal defines MIN_VERSION_base
04:26:00 <Nereid> yeah that's it.
04:26:17 <Nereid> http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
04:26:22 <odi> oh, i see it will generate in cabal_macros.h
04:26:27 <Nereid> yeah.
04:28:11 <odi> but is there a way to load it in ghci though?
04:29:39 <Nereid> odi: I imagine you could tell ghci to include a .h
04:29:40 <hiptobecubic> go math
04:35:11 <merijn> int-e: In my case a *is* a phantom type
04:36:41 <Nereid> odi: or give ghci a flag like -DMIN_VERSION_base(x,y,z)=1
04:37:06 <Nereid> or something. hmm
04:37:33 <odi> Nereid: i'll try
04:39:06 <LordBrain> I'm looking at haskell source for a demo of distributed-process, i notice there is a directory inside of src called MasterSlave and that one of the source files in there has the line "import qualified MasterSlave" but there is no MasterSlave.hs, so can someone point me to the documentation i need or just explain it to me.  Is it importing the directory it is held in or something?
04:39:46 <LordBrain> You can grab what i am looking at using this command: cabal unpack http://well-typed.com/blog/aux/files/cloud-demos.tar.gz
04:40:21 <Nereid> odi: alternatively, you could use the file cabal generated by
04:40:31 <Nereid> -optP-includecabal_macros.h or so
04:40:41 <LordBrain> Must be something about haskell modules and search paths etc that i dont get?
04:40:53 <raymank26> Hi all. I model Petri Nets using haskell. But I faced problem. Is there some modification of state monad that returns list of pairs of result and new state? Or I should to write it?
04:41:34 <hpc> @unmtl StateT s [] a
04:41:34 <lambdabot> s -> [(a, s)]
04:41:53 <raymank26> Oh. Thanks!
04:41:53 <Nereid> LordBrain: I see a MasterSlave.hs
04:42:02 <LordBrain> where is it Nereid ?
04:42:06 <Nereid> in MasterSlave
04:42:12 <LordBrain> oh?
04:42:16 <odi> Nereid: thx it works!
04:42:40 <Nereid> LordBrain: are we looking at the same thing? https://github.com/haskell-distributed/distributed-process/tree/master/distributed-process-demos/src/MasterSlave
04:43:03 <LordBrain> weird
04:43:29 <LordBrain> maybe something failed when it was downloading/expanding and i didnt notice
04:44:56 <LordBrain> using the cabal unpack command it is still missing
04:45:41 <LordBrain> maybe there was an oversight on Duncan Coutts part when he uploaded that tarball
04:48:14 <Nereid> I should have a look at distributed-process at some point.
04:48:50 <LordBrain> hey i am just opening it up myself
04:49:24 <antistrom1> do you know a more elegant solution for this function: http://paste.ohai.su/1574/ ?
04:49:55 <Botje> antistrom1: you can get rid of the () by using . or $
04:50:07 <Botje> sum . map (^2) . tail . sort $ [x,y,z]
04:50:35 <LordBrain> isn't he disregarding x there
04:50:46 <LordBrain> or i mean the least
04:50:50 <Botje> indeed.
04:50:52 <LordBrain> i should say since it is after the sort
04:51:04 <Botje> so you could also write delete (min l) l where l = [x,y,z]
04:51:07 <Botje> uh
04:51:09 <Botje> minimum l
04:51:19 <antistrom1> LordBrain: that is intented
04:51:28 <LordBrain> ok then
04:56:11 <LordPinky> Gee LordBrain what are we going to do tonight?
04:56:35 * hackagebot monarch 0.8.1.3 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.8.1.3 (NoriyukiOhkawa)
04:58:23 <Jafet> Take over the world, innit
04:58:53 <LordBrain>  a^2 + b^2 where [_, a,b] = sort [x,y,z]
04:58:56 <LordBrain> heh
04:59:06 <Botje> LordBrain: ooh, that one is also nice.
05:00:07 <LordBrain> yeah, i dont think i improved much on yours tho
05:05:53 <atriq> Is there a type that's an unbounded non-negative integer?
05:06:01 <atriq> Something like UnboundedWord
05:07:22 <hpc> data Nat = Zero | Succ Nat
05:07:32 <atriq> How space-efficient is that?
05:07:39 <hpc> not even remotely
05:07:47 <hpc> unless you are representing infinity
05:07:58 <atriq> No, I think it will always be finite
05:08:11 <hpc> > fix Just
05:08:12 <lambdabot>   Occurs check: cannot construct the infinite type:
05:08:12 <lambdabot>    a = Data.Maybe.Maybe a
05:08:15 <hpc> pah
05:08:29 <hpc> try it in ghci with (fix Succ)
05:08:54 <zomg> ghci --fix-suck
05:08:56 <zomg> =)
05:09:04 <hpc> > fix error
05:09:05 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
05:10:14 <Jafet> > fix $ Just.In
05:10:15 <lambdabot>   Not in scope: data constructor `Just.In'
05:10:19 <Jafet> > fix $ Just .In
05:10:21 <lambdabot>   Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just ...
05:10:34 <atriq> But is there a nice UnboundedWord type?
05:10:44 <hpc> don't think so
05:11:17 <hpc> Integer uses GMP
05:11:36 <hpc> so maybe you could modify GMP to have an unsigned encoding of big numbers?
05:11:44 <hpc> i vote you call it "Wordeger"
05:11:50 <atriq> That sounds ridiculous and complicated
05:11:54 <atriq> And I agree on the name
05:12:09 <hpc> > map (++ "eger") ["Int", "Word", "Char"] -- unbounded alphabets!
05:12:11 <lambdabot>   ["Integer","Wordeger","Chareger"]
05:12:36 <atriq> A Chareger has appeared
05:12:43 <fmap> > maxBound :: Char
05:12:45 <lambdabot>   '\1114111'
05:12:48 <fmap> oh
05:12:59 <hpc> > floor (0/0) :: Integer
05:13:00 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
05:17:40 <atriq> @unmtl WriterT (StateT Maybe C) (Sum Integer) a
05:17:41 <lambdabot> Sum Integer (a, StateT Maybe C)
05:17:49 <atriq> Nope, that's not what I want
05:18:21 <Peaker> It's WriterT w m a,  not m w a
05:18:25 <atriq> Bah
05:18:35 <Peaker> atriq, all monad transformers have to end with the "m a" in the end
05:18:41 <Peaker> atriq, so they work with the MonadTrans class
05:18:44 <atriq> @unmtl WriterT (Sum Wordeger) (StateT Maybe C) a
05:18:44 <lambdabot> Maybe -> C (a, Sum Wordeger, Maybe)
05:18:52 <atriq> Oh, that's a hand thing that exists
05:18:54 <Peaker> so EitherT has the "l m a",  WriterT "w m a", ReaderT has "r m a", etc
05:18:56 <atriq> @unmtl WriterT (Sum Wordeger) (StateT C Maybe) a
05:18:57 <lambdabot> C -> Maybe (a, Sum Wordeger, C)
05:19:02 <atriq> There we go
05:19:20 <atriq> Closer, but not there yet
05:19:38 <atriq> @unmtl StateT C (WriterT (Sum Wordeger) Maybe) a
05:19:39 <lambdabot> C -> Maybe (a, C, Sum Wordeger)
05:20:00 <atriq> @unmtl StateT C (MaybeT (Writer (Sum Wordeger))) a
05:20:00 <lambdabot> C -> (Maybe (a, C), Sum Wordeger)
05:20:05 <atriq> Yessss
05:20:47 <atriq> That's ridiculous, but exactly what I want
05:25:04 <atriq> Hmm
05:25:09 <atriq> How can I add "IO" to that?
05:26:41 <Peaker> @unmtl StateT C (MaybeT (WriterT (Sum Wordeger) IO)) a
05:26:41 <lambdabot> C -> IO (Maybe (a, C), Sum Wordeger)
05:26:55 <atriq> Perfectly ridiculous
05:26:59 <Peaker> why?
05:27:26 <atriq> I'm writing an emulator for the DCPU from 0x10c
05:27:39 <Kyraimion> @unmtl RWST a
05:27:39 <lambdabot> Plugin `unmtl' failed with: `RWST a' is not applied to enough arguments, giving `/\A B C D. a -> B -> C (D, B, A)'
05:28:10 <atriq> @unmtl RWST () (Sum Wordeger) C Maybe a
05:28:10 <lambdabot> () -> C -> Maybe (a, C, Sum Wordeger)
05:28:28 <atriq> The Sum Wordeger ends up in the wrong place
05:28:32 <atriq> I want that outside the Maybe
05:31:12 <merijn> atriq: That's using Maybe as a monad
05:31:30 <atriq> The alternative being?
05:32:07 <merijn> atriq: Well, presumably if you want the Sum Wordeger outside of the maybe you didn't want the entire result inside the maybe...
05:32:15 <atriq> No, I did
05:32:28 <atriq> The Sum Wordeger is a "How long it takes"
05:32:43 <atriq> The Maybe is a "Might crash"
05:32:50 <atriq> "And catch fire and stuff"
05:38:19 <merijn> atriq: Well, if that's what you want why did you say "I want that outside the Maybe"?
05:38:43 <atriq> I was referring to the Sum Wordeger
05:38:44 <atriq> Which is time
05:38:49 <atriq> Which I DO want outside the Maybe
05:39:05 <merijn> Then using Maybe as the monad is wrong, like I just said
05:39:26 <Peaker> MaybeT m  is going to place the "m" stuff outside the Maybe, and any transformer around it will be in the maybe
05:39:29 <Zariel> is there a better shorthand for doing this? https://gist.github.com/25ecb2f0ea46ccd73543
05:39:45 <merijn> @unmtl RWST () (Sum Wordeger) C IO (Maybe a)
05:39:45 <lambdabot> () -> C -> IO (Maybe a, C, Sum Wordeger)
05:40:05 <atriq> I want the C inside the Maybe
05:40:07 <atriq> I see
05:40:18 <merijn> Then you can't use RWST, I think
05:40:39 <merijn> You have to make your own monadstack like the one Peaker suggested
05:40:50 <efie> do you have to consider something if you want to write a module which contains a dot in it's name? I have a module A (file: A.hs), but when I change it to A.B (file: A.B.hs) it does not work anymore (I changed A to A.B in the importing files too)
05:40:58 <atriq> @unmtl StateT C (MaybeT (WriterT (Sum Wordeger) IO)) a
05:40:59 <lambdabot> C -> IO (Maybe (a, C), Sum Wordeger)
05:41:18 <efie> Zariel: maybe hGetContents h >>= print . execute . runParser ?
05:41:43 <maukd> Zariel: stack <- execute . runParser <$> hGetContents h
05:41:54 <atriq> efie: it uses folders for qualification
05:41:57 <Kyraimion> efie:  put it into a subdirectory called A, so A/B.hs with module A.B
05:42:13 <efie> ah!
05:42:14 <efie> thanks
05:43:19 <Zariel> efie: maukd thanks was trying to use >>=
05:44:45 <Peaker> what happened to mauke?
05:47:02 <Botje> eaten by maukd.
05:47:11 <ziman> he's been decremented
05:51:33 <quicksilver> it's like doctor who, this is his next incarnation
05:54:15 <quicksilver> > foldl (\a b -> a*26 + b) 0 . map (subtract 97.ord) $ "maukd"
05:54:17 <lambdabot>   5497495
05:54:28 <quicksilver> less than 5.5 million incarnations to go
05:55:58 <osfameron> ah, I'd been going to say only 4
05:56:28 <maukd> preflex: calc 36'maukd
05:56:28 <preflex>  37457725
05:56:36 * hackagebot syntactic 1.4 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.4 (EmilAxelsson)
05:59:55 <akamaus> Hi, I'm looking for a function like catMaybes with a more polymorphic signature, something like [Maybe a] -> m a.
06:00:59 <mux> :t map return . catMaybes
06:01:00 <lambdabot> forall a (m :: * -> *). (Monad m) => [Maybe a] -> [m a]
06:01:11 <maukd> :t foldr mplus mzero
06:01:12 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
06:01:29 <mux> read that wrong
06:01:48 <maukd> :t foldr (mplus . return) mzero
06:01:49 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
06:03:57 <merijn> akamaus: Where does the m come from there?
06:04:24 <akamaus> merijn, I'd like to specify it in caller, I need maybes and lists
06:04:31 <matthiasgorgens> akamaus: how about m (f a ) -> f (m a) ?
06:04:45 <matthiasgorgens> @hoogle sequence
06:04:46 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
06:04:46 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
06:04:46 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
06:04:53 <akamaus> matthiasgorgens, looks like sequence
06:05:01 <matthiasgorgens> @hoogle sequenceA
06:05:02 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
06:05:02 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
06:05:36 <matthiasgorgens> @hoogle Data.Traversable.Sequence
06:05:36 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
06:05:37 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
06:05:37 <lambdabot> package data-list-sequences
06:05:50 <matthiasgorgens> Data.Traversable.sequence is what I thought of at first.
06:06:21 <matthiasgorgens> traversable and foldable have lots of nifty functions.
06:06:35 <matthiasgorgens> Control.Monad.Loops also deserves to be better known.
06:07:55 <akamaus> matthiasgorgens, seems sequence doesn't fit here.  t (f a) -> f (t a). In my case 'f' is fixed to Maybe on the left
06:09:07 <merijn> Does the detailed-1.0 test suite of cabal work or should I stick to exitcode-stdio?
06:11:09 <matthiasgorgens> akamaus: ok.
06:11:17 <matthiasgorgens> akamaus: then you need something like MonadPlus on the right?
06:11:31 <matthiasgorgens> :t msum . catMaybes
06:11:32 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [Maybe (m a)] -> m a
06:12:50 <matthiasgorgens> :t msum . fmap return . catMaybes
06:12:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [Maybe a] -> m a
06:13:19 <matthiasgorgens> if you can give furhter restrictions on your m, you can get your (m a)'s in a more interesting way than just by returning.
06:13:20 <akamaus> matthiasgorgens, wow! Perfect!
06:13:38 <akamaus> matthiasgorgens, m is [] or Maybe in my case
06:13:53 <matthiasgorgens> ok.
06:14:37 <matthiasgorgens> @djinn (MonadPlus m) => [Maybe a] -> m a
06:14:38 <lambdabot> Error: Undefined type []
06:15:57 <bobry> hello, is it possible to make this work with 'attoparsec': """parse ((show <$> signed decimal) <|> (show <$> double)) "-4.694705808989266""""
06:16:24 <bobry> for some reason decimal parser doesn't fall back, yielding Done ".694705808989266" "-4"
06:18:12 <matthiasgorgens> yeah.
06:18:18 <matthiasgorgens> because attoparsec doesn't parse the whole string.
06:18:26 <matthiasgorgens> so your signed decimal succeeds.
06:18:36 <matthiasgorgens> because there is a signed decimal to parse.
06:20:01 <matthiasgorgens> have you tried just using Attoparsec's Number data type?
06:20:06 <matthiasgorgens> "A numeric type that can represent integers accurately, and floating point numbers to the precision of a Double."?
06:20:15 <ThreeOfEight1> Hallo, I've got a question about the pointless command: @pl \x -> x*x gives me "join (*)" - what "join" function is this? It cannot be the join on monads, can it?
06:20:22 <quicksilver> yes, ThreeOfEight1
06:20:29 <quicksilver> it is the join on monads
06:20:35 <quicksilver> in this case on the (->) r monad.
06:20:36 <matthiasgorgens> ThreeOfEight1: it's probably the (->) a monad.
06:20:53 <ThreeOfEight1> but in ghci, I then get the type (Monad ((->) a), Num a) => a -> a
06:21:02 <atriq> ThreeOfEight1, try import Control.Monad.Instances
06:21:05 <ThreeOfEight1> and join (*) 2 gives me a "No instance for (Monad ((->) a0))
06:21:31 <ThreeOfEight1> Oh, interesting, thanks.
06:21:35 <matthiasgorgens> (or define the instance yourself as an exercise.)
06:21:38 <ThreeOfEight1> Could anybody explain this black magic to me, please?
06:21:50 <matthiasgorgens> try definging the instance yourself for 5 minutes. :o)
06:21:54 <matthiasgorgens> shouldn't be too hard.
06:22:21 <ThreeOfEight> I'm new to Haskell, so I have absolutely no idea how these instances work
06:22:25 <matthiasgorgens> you might want to write join directly, instead of going via a definition of (>>=).
06:22:31 <matthiasgorgens> ok.
06:22:39 <matthiasgorgens> so, do you know what a typeclass is?
06:22:45 <matthiasgorgens> it's basically an interface declaration.
06:22:49 <ThreeOfEight> I've worked with ML and Isabelle a lot, but Haskell has a lot of stuff that doesn't exist in either or is called differently
06:23:26 <ThreeOfEight> Yes, I know what a type class is. I also have a vague idea of what a monad is (i.e. I've used them constantly in theorem proving and I know the formal definition).
06:23:32 <matthiasgorgens> ok.
06:23:48 <matthiasgorgens> so for giving an instance definition, you have to give definitions of the required functions.
06:23:49 <ThreeOfEight> But I am a bit puzzled by this particular usage.
06:23:52 <matthiasgorgens> ok.
06:24:14 <matthiasgorgens> you will be slightly more enlightened, if you see how it's defined.
06:24:18 <ThreeOfEight> Ah, I see, so I need to define a return and bind operation for this particular monad?
06:24:23 <matthiasgorgens> yes.
06:24:36 <matthiasgorgens> but pedagogically it might be worthwhile to start with defining the Functor first.
06:24:38 <matthiasgorgens> (i.e. the fmap)
06:24:40 <ThreeOfEight> What does this -> monad do?
06:24:50 <matthiasgorgens> then the pointed functor, i.e. return.
06:24:51 <ThreeOfEight> I am unfamiliar with this type syntax
06:24:53 <matthiasgorgens> then ap.
06:25:07 <matthiasgorgens> oh, (->) a is a type function (I hope I got that right)
06:25:12 <matthiasgorgens> so -> is an operator.
06:25:17 <matthiasgorgens> it takes two type arguments.
06:25:22 <matthiasgorgens> (a -> b)
06:25:31 <ThreeOfEight> ah, I see, a type-level operator, so to sy
06:25:32 <ThreeOfEight> *say
06:25:33 <matthiasgorgens> which is equivalent syntactically to
06:25:36 <matthiasgorgens> (->) a b
06:25:37 <maukd> the type A -> B is equivalent to (->) A B
06:25:45 <matthiasgorgens> so (->) r is just curried.
06:25:53 <quicksilver> not curried, matthiasgorgens
06:25:55 <quicksilver> partially applied.
06:25:59 <matthiasgorgens> oh, yeah.
06:25:59 <maukd> which is equivalent to ((->) A) B
06:26:15 <matthiasgorgens> quicksilver: but the partial application only works, because the operator is curried, first.
06:26:29 <ThreeOfEight> Okay, I get this.
06:27:04 <matthiasgorgens> ThreeOfEight: do you know SKI calculus?
06:27:48 <matthiasgorgens> if yes, the methods for the (->) r monad will be very familar.
06:27:49 <ThreeOfEight> Afraid not
06:28:22 <ThreeOfEight> But I am very familiar with untyped lambda calculus, it says on wikipedia that this SKI calculus can be seen as a reduced version of that.
06:28:23 <matthiasgorgens> it's not that important.  but https://en.wikipedia.org/wiki/SKI_calculus might be fun.
06:28:28 <matthiasgorgens> yeah.
06:29:00 <matthiasgorgens> SKI calculus is basically pointless lambda calculus.
06:29:09 <atriq> It's basically you have S = (\x y z.xz(yz)), K = (\x y.x) and I = (\x.x)
06:29:23 <matthiasgorgens> and thus it's not a surprise that SKI calculus comes up when trying to make your functions pointless.
06:29:25 <atriq> You don't actually need I, because SKx = I
06:29:33 <matthiasgorgens> in haskell it comes up via the (->) r monad.
06:29:46 <maukd> :t ap return return
06:29:47 <lambdabot>     Ambiguous type variable `m' in the constraint:
06:29:47 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:10-15
06:29:47 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
06:29:57 <atriq> :t ap return return :: (a -> a)
06:29:58 <lambdabot>     Ambiguous type variable `m' in the constraint:
06:29:58 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:10-15
06:29:58 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
06:30:06 <atriq> :t (ap return return) :: (a -> a)
06:30:07 <lambdabot>     Ambiguous type variable `m' in the constraint:
06:30:07 <lambdabot>       `Monad m' arising from a use of `return' at <interactive>:1:11-16
06:30:08 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
06:30:12 <atriq> :t (ap return undefined) :: (a -> a)
06:30:13 <lambdabot> forall a. a -> a
06:30:18 <atriq> :t (ap return undefined) 1
06:30:19 <lambdabot> forall b. (Num b) => b
06:30:20 <atriq> (ap return undefined) 1
06:30:28 <atriq> > (ap return undefined) 1
06:30:29 <lambdabot>   1
06:30:33 <matthiasgorgens> yeah. :o)
06:30:44 <quicksilver> matthiasgorgens: [I don't want to distract from the discussion, because it's meaningless, but I'm not sure it's particularly clear what it means to suggest haskell type operators are curried. What else could they be? We don't have a syntax for two-parameter type functions, there really isn't a choice]
06:30:46 <matthiasgorgens> I hope that's not how id is defined in the prelude. :o)
06:31:00 <atriq> id = unsafeCoerce
06:31:22 <matthiasgorgens> quicksilver: you could let them all take tuples.
06:31:36 <atriq> id x = unsafePerformIO (launchMissiles >> return (unsafeCoerce x))
06:31:37 * hackagebot DSH 0.8.2.2 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.8.2.2 (GeorgeGiorgidze)
06:31:55 <matthiasgorgens> @pl id x = unsafePerformIO (launchMissiles >> return (unsafeCoerce x))
06:31:56 <lambdabot> id = unsafePerformIO . (launchMissiles >>) . return . unsafeCoerce
06:32:06 <quicksilver> matthiasgorgens: [a tuple woudl be one argument. one argument which is a tuple]
06:32:13 <matthiasgorgens> yes.  but no currying.
06:32:32 <matthiasgorgens> but yeah, there's no real choice, but it might need pointing out for beginners.
06:32:59 <atriq> Well, EclipseFP has failed me for the last itme
06:33:01 <atriq> *time
06:33:20 <ThreeOfEight> Well, I will look into this at some point. Thanks a lot.
06:33:35 <atriq> Is there a way I can learn emacs or vi or whatever on the go by using it to write Haskell?
06:33:39 <matthiasgorgens> bobry: did you get my answer about <|>?
06:33:50 <matthiasgorgens> atriq: yes.
06:33:53 <ThreeOfEight> I will probably need to generalise my understanding of what a monad is first.
06:34:02 <merijn> atriq: Yes, it'll be slightly frustrating (at least the vim case) at the start, though
06:34:12 <matthiasgorgens> ThreeOfEight: it's exactly what the axioms say.  but playing around with a few examples will help.
06:34:27 <ThreeOfEight> Yes, my /intuitive/ understanding of what a Monad is, I mean.
06:34:32 <atriq> merijn, I've written a factorial calculator using (<*>), pure and unsafeCoerce. I can handle frustrating.
06:34:52 <matthiasgorgens> ThreeOfEight: yeah.  Monad Transformers are a good thing to learn, because they force you to have your understanding of monads down.
06:34:58 <ThreeOfEight> So far, I've only worked with monads that encapsulated some kind of state or result
06:35:09 <matthiasgorgens> ThreeOfEight: but its more of a good test.  they can come up in practice, but they aren't always that important.
06:35:25 <ThreeOfEight> like nondeterministic result monads in Isabelle and the IO monad in Haskell
06:35:28 <matthiasgorgens> ThreeOfEight: the (->) r monad is equivalent to the reader monad.
06:35:33 <matthiasgorgens> there was a monad reader article about that.
06:35:41 <ThreeOfEight> I'm afraid I don't know the reader monad
06:36:07 <matthiasgorgens> https://themonadreader.wordpress.com/category/issues/
06:36:31 <matthiasgorgens> issue 17 has something about the Reader Monad.
06:36:38 <ThreeOfEight> thanks
06:36:39 <matthiasgorgens> (The name, monad reader is of course a pun.)
06:36:55 <merijn> ThreeOfEight: oh, it's a reasonably easy monad to understand (reader). It implements immutable "global" state
06:37:06 <matthiasgorgens> The Monad Reader is an excellent resource for furthering your understanding of haskell.
06:37:25 <matthiasgorgens> merijn: it's actually shadowable state.
06:37:32 <matthiasgorgens> so it's more like dynamically scoped variables.
06:37:45 <matthiasgorgens> :t local
06:37:47 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
06:37:52 <matthiasgorgens> because of that local function.
06:38:57 <matthiasgorgens> but yeah, the reader monad is one of the easier ones.  a good third or fourth monad to understand, after the trivial monad, the identity monad, and Maybe.
06:43:55 <atriq> What's different between emacs and vi, with regard to Haskell programming?
06:44:46 <maukd> emacs sucks, obviously
06:45:59 <matthiasgorgens> and vim, too.
06:46:03 <matthiasgorgens> I wouldn't advice vi.
06:46:22 <atriq> They're both probably better than Eclipse
06:46:26 <matthiasgorgens> atriq: just chose whatever you feel more comfortable with.
06:46:32 <kurtis> Not sure if this is relevant, but I saw ghc-mod which implements some stuff for emacs.
06:46:36 <atriq> I... don't really feel comfortable with either
06:46:56 <merijn> atriq: Not much, I think emacs has slightly better integration with ghci, but you can do the same with vim, tmux/screen and ghci
06:47:55 <atriq> Do either have on-the-fly type checking?
06:48:13 <kurtis> atriq: I use Sublime Text ... but an editor or IDE is probably just a matter of personal opinion for the most part. (At least that's what I've found with practically every other language)
06:48:17 <merijn> I think there's plugins for that, yeah
06:48:24 <Nereid> @type either
06:48:25 <byorgey> atriq: emacs does at least, if you install ghc-mod
06:48:25 <merijn> Although I personally don't use them
06:48:25 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
06:48:33 <byorgey> @package ghc-mod
06:48:33 <lambdabot> http://hackage.haskell.org/package/ghc-mod
06:48:51 <merijn> kurtis: As long as your personal opinion is either vim or emacs ;)
06:49:42 <matthiasgorgens> apparently, ghc-mod also works with vim?
06:49:44 <Nereid> look what I found https://github.com/eagletmt/ghcmod-vim
06:49:44 <kurtis> merijn: haha. Well the reason I brought up Sublime Text is because the haskell-specific extension/plugin uses ghc-mod and the editor itself is similar to emacs in that it's extensible (but uses Python instead of elisp)
06:50:30 <fmap> matthiasgorgens: afaiu ghc-mod is editor agnostic
06:50:30 <merijn> I just wish there was vim with emacs' extensibility :\ (first one to mention viper gets stabbed :p)
06:52:40 <kurtis> I like emacs. I even bought GNU's book. But when I'm working in a graphical environment, Sublime Text become too pleasant to pass up. When I'm in a text environment, I always use emacs (no-x). If emacs was pretty, then I'd use it graphically as well
06:52:55 <atriq> What's Sublime Text like?
06:53:58 <quicksilver> pretty, but not fully programmable I think/
06:54:00 <quicksilver> ?
06:54:05 <quicksilver> (also not source code available)
06:54:10 <atriq> Ugh
06:54:12 <atriq> $59
06:54:49 <quicksilver> emacs certainly has its flaws but I think a good programmer's editor needs to be fully programmable - the whole internals needs to be scriptable and modifyable
06:55:23 <quicksilver> there is also the sad fact that when you've spent 20 years learning one set of key bindings and work habits you don't much feel like changing.
06:56:22 <kurtis> atriq, I just copied + pasted some example code I found online and took a screenshot for you: http://i50.tinypic.com/2134z9u.jpg
06:56:52 <kurtis> atriq, The "trial" is free but it never runs out of time. You only have to pay if you want to.
06:57:19 <hpaste> dreugeworst pasted “stack overflow” at http://hpaste.org/76446
06:57:39 <quicksilver> kurtis: it would be illegal not to.
06:57:41 <merijn> Are there any examples of "cabal test" using detailed-1.0?
06:57:48 <quicksilver> depends what you think "if you want to" means
06:59:00 <matthiasgorgens> has anybody tried the plane9 editors?
06:59:39 <matthiasgorgens> -e.
06:59:47 <matthiasgorgens> sam and acme.
07:00:09 <matthiasgorgens> I've heard interesting things about them, but never tried.
07:00:15 <hpaste> dreugeworst annotated “stack overflow” with “stack overflow (annotation)” at http://hpaste.org/76446#a76447
07:04:23 <Sculptor> hi!
07:04:41 <Jafet> lo
07:06:44 <kurtis> Anyone with decent experience want to fill out this tutorial? I'm just learning Haskell but it would be helpful if this page were complete. http://thrift.apache.org/tutorial/hs/
07:08:07 <merijn> Ah, so I guess it's not implemented yet...time to go yell at dcoutts_ and the other cabal devs :p
07:08:20 <dcoutts_> or time to send us patches! ;-)
07:08:46 <merijn> dcoutts_: Maybe, depending how much still needs to be done for detailed-1.0...
07:08:59 <scooty-puff> should the major version (A.B) of a package be increased if an existing instance of an imported class for a defined-in-this-package datatype is changed to include an additional constraint?
07:09:08 <dcoutts_> merijn: ah, detailed testsuite interface, yes it's finished but the frameworks like test-framework have not yet been adapted to work with it
07:09:19 <dcoutts_> merijn: the interface is done we think
07:09:27 <scooty-puff> e.g. instance Applicative (A m) to Applicative m => Applicative (A m)
07:09:57 <merijn> dcoutts_: Does it make sense to write my own test code using detailed-0.9 or should I just use exitcode until the final stuff is done?
07:10:19 <dcoutts_> merijn: detailed-0.9, no 1.0 yes maybe
07:10:46 <merijn> dcoutts_: Yeah, but 1.0 is not in cabal-install, so that's rather hard to actually write code for :p
07:10:51 <dcoutts_> merijn: but coding direct to the interface is perhaps not so fun, it wants something on top
07:11:00 <dcoutts_> merijn: it is, it's in the latest release
07:11:09 <dcoutts_> I think, lemme check
07:11:15 <merijn> What's the latest? I'm using 1.16
07:11:55 <dcoutts_> oh, no, you're quite right, it's still labelled as 0.9
07:12:45 <dcoutts_> merijn: my suggestion is that if you're developing a testing framework then you should certainly look at the new interface, but if you're just writing a specific testsuite, then it's perhaps not worth it
07:13:01 <merijn> dcoutts_: That's what I feared :p
07:14:24 <merijn> I guess I'll have to implement something myself using exitcode
07:14:50 <dcoutts_> merijn: you can take a look at the test interface if you like of course
07:14:54 <dcoutts_> it's not that odd
07:15:09 <zzing> If I wanted to time the execution of an attoparsec parser, how might I do this?
07:15:27 <merijn> Yeah, it looked relatively sane, but a bit cumbersome to write from scratch. Then again, doing it all myself using exitcode will also be rather cumbersome :p
07:15:57 <dcoutts_> merijn: right, it's not designed for writing tests directly to it, it's an interface between test frameworks and test runners
07:16:38 * hackagebot yesod-platform 1.1.4.1 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.4.1 (MichaelSnoyman)
07:16:50 <dcoutts_> merijn: but e.g. a QC property -> TestInstance should be quite straightforward
07:23:09 <fmap> The function `f' is applied to one argument, but its type `(Int -> Int) -> Int' has only one
07:23:12 <fmap> nice
07:23:41 <Peaker> fmap, what code causes this?
07:23:49 <Polarina> Must be a bug.
07:24:31 <Eduard_Munteanu> What?
07:24:33 <atriq> Well, I'm using emacs now
07:24:33 <hpaste> fmap pasted “m” at http://hpaste.org/76448
07:30:02 <hiptobecubic> is this supposed to add 3 and 5?
07:30:12 <hiptobecubic> because it could use some optimization :)
07:31:12 <typoclass> fmap: i can't claim that i know what comonads are or that i can read that code very well :-) but =>> has the type f a -> (f a -> b) -> f b, yet in line 20 you apply it to 2 arguments that seem to have the same type, is this correct?
07:32:57 <fmap> typoclass: I have no idea what comonads are and was just experimenting :]
07:33:07 <fmap> anyway, error message is kinda funny
07:33:26 <typoclass> fmap: oh definitely, the message looks funky and is probably a bug
07:34:24 <typoclass> fmap: could you try "x = ((\f -> ...) =>>)" and in the next line "x (\f -> ...)" to determine which of the 2 arguments causes the error?
07:39:08 <Eduard_Munteanu> The (f a -> b) there actually gets two arguments.
07:39:20 <fmap> typoclass: sure
07:39:39 <hpaste> fmap annotated “m” with “m (annotation)” at http://hpaste.org/76448#a76449
07:39:58 <Eduard_Munteanu> (because you're working with (->) m
07:40:01 <Eduard_Munteanu> )
07:40:26 <Eduard_Munteanu> So your type annotation is wrong.
07:40:40 <Eduard_Munteanu> :t id :: Int
07:40:42 <lambdabot>     Couldn't match expected type `Int' against inferred type `a -> a'
07:40:42 <lambdabot>     In the expression: id :: Int
07:43:33 <typoclass> fmap: yeah ... i think that =>> as its second argument needs an (a -> x -> b). so that "f (5 :: Int)" thing is not going to fit :)
07:44:05 <typoclass> fmap: the 2nd error message makes this somewhat clear. but your 1st error message is clearly misleading and probably a but. report it on the ghc wiki?
07:44:19 <typoclass> i think they have a guest account, you don't even need to register
07:44:38 <typoclass> s/but/bug
07:45:45 <sm> byorgey, dmwit_: thanks for your help last weekend; the simple knot-tied account tree idea seems to work rather well
07:45:54 <byorgey> sm: excellent!
07:46:02 <sm> http://hub.darcs.net/simon/hledger/browse/hledger-lib/Hledger/Data/Types.hs#249 . I like how I can use it as a tree or a list at the same time!
07:47:03 <Cale> sm: Modifying such data is really tricky though
07:47:12 <Attic> Hey, I'm trying to create a GUI app with Glade and Gtk2Hs, but when I try to get a new widget I get get the error that I need a GkadeXML type instead of Maybe GladeXML. So I try to remove the Just like so: http://pastie.org/5079074 However I get the error: Non-exhaustive patterns in lambda
07:47:42 <sm> yes absolutely. The hope was that this data is almost always immutable in hledger, at least for now; later, move to a zipper
07:47:49 <Botje> Attic: you could do Just xml <- xmlNew ...
07:47:54 <Cale> Attic: When x :: Maybe t  it means that either x is Nothing or x is Just v for some value v :: t
07:48:01 <Botje> Attic: that way you get an IO error if xmlNew ever returns error
07:48:14 <Botje> Attic: alternatively, pattern match on xml to handle the Nothing case as well.
07:48:22 <Cale> Attic: So the problem is that xmlNew "hi.glade" might produce Nothing, and you need to be prepared for that
07:48:32 <Cale> case jxml of
07:48:39 <Cale>   Nothing -> ... handle failure ...
07:48:44 <Cale>   Just xml -> ...
07:49:06 <typoclass> Botje: i think his non-exhaustive thing indicates that gtk is indeed giving him a Nothing, for whatever reason
07:49:23 <Attic> When I do Just xml I get this error: user error (Pattern match failure in do expression at hello.hs:8:3-10)
07:49:30 <Botje> typoclass: ah, right.
07:49:34 <Attic> which is the line of the Just xml <- xmlNew "hi.glade"
07:49:35 <typoclass> Attic: ^^
07:49:39 <Botje> Attic: well, then what typoclass said
07:49:42 <Cale> Attic: Look at my code
07:50:10 <Cale> Attic: the problem is that jxml in your original code was not of the form  Just a  but instead must have been  Nothing
07:50:10 <Peaker> I hate that Haskell uses <- for partial/total pattern matches so that you get no warning on partiality, even if you meant for the pattern match to be total (e.g: a type had 1 constructor, now has 2). I avoid <- pattern matching for that reason :(
07:50:28 <Cale> Peaker: Haskell 1.4 did something much better
07:50:36 <sm> And.. I may be facing that problem sooner that expected. I've been banging my head on one remaining inefficiency for a couple of days. The balance report needs to display "boring" accounts in the tree differently. An account's boringness depends on the number of boring subaccounts anywhere below it. Doing this without lots of duplicated work with an immutable tree seems hard.
07:51:06 <typoclass> Peaker: oh wow, even with -Wall it doesn't warn? good catch then. i need to keep that in mind
07:51:09 <Cale> Peaker: which was that  pat <- x  translated differently for failable patterns than for non-failable ones, which showed up as a MonadZero constraint in the types
07:52:04 <typoclass> Cale: interesting. did they then add 'fail' to Monad and change that behavior ...?
07:52:29 <Lutin`> So is there a more idomatic way to do this?
07:52:32 <hpaste> Lutin` pasted “Prime Factors” at http://hpaste.org/76450
07:52:37 <merijn> Peaker, Attic: With GHC 7.6 you can use lambdacase to do "xmlNew "hi.glade" >>= se { Just x -> foo; Nothing -> bar }"
07:53:00 <merijn> hmm, irssi misbehaving on control characters >.<
07:53:14 <Cale> typoclass: yes, they messed it up with Haskell 98
07:53:16 <Botje> Lutin`: could use a guard instead.
07:53:23 <Lutin`> How is that better
07:53:30 <Cale> typoclass: It started with removing monad comprehensions
07:53:31 <Botje> primeFac' n (x:xs) | n`mod` x == 0 = ...
07:53:33 <sm> it seems like my best approach is to walk the tree from the bottom up and build a map of boring accounts. Must try harder.
07:53:39 <Lutin`> Again, how is that better
07:53:51 <typoclass> Attic: anyway, the errors you are seeing mean that jxml is Nothing, in other words 'xmlNew "hi.glade"' gave you a Nothing. check xmlNew's documentation (or source code). it might e.g. indicate that the file hi.glade cannot be found
07:54:05 <Botje> because you can list your cases alongside regular clauses
07:54:14 <typoclass> cale: very interesting. but monad comprehensions made a comeback recently, didn't they? any such plans for the MonadZero thing?
07:54:17 <Peaker> Cale, the Haskell 1.4 was indeed better, but also a badly-grained solution, because a "do" block might have multiple pattern matches. Some meant to be total, some partial
07:54:20 <Eduard_Munteanu> Why did they specifically remove monad comprehensions anyway?
07:54:37 <merijn> Eduard_Munteanu: Aren't they back now?
07:54:48 <typoclass> Eduard_Munteanu: monad comprehensions turned out to be incomprehensible :-)
07:54:50 <Cale> Eduard_Munteanu: Because waaah I don't want to explain monads to my students
07:55:05 <Cale> basically
07:55:05 <Eduard_Munteanu> Back how? Did Haskell2010 reinstate them? IIRC, no.
07:55:12 <Cale> no, but GHC did
07:55:15 <Eduard_Munteanu> GHC has an extension yeah.
07:55:21 <typoclass> Eduard_Munteanu: i thought there's -XMonadComprehensions now
07:55:23 <Cale> GHC is all that really matters
07:55:27 <Eduard_Munteanu> :)
07:55:42 <Eduard_Munteanu> Well, yes, as long as even mundane stuff like MPTCs isn't Haskell2010...
07:55:54 <Attic> Ok so if I understand correctly, this should work? : http://pastie.org/5079161
07:56:16 <Cale> Attic: well, kind of :)
07:56:25 <Cale> Attic: It should produce "Not valid"
07:56:36 <Cale> Attic: because we know that the xmlNew call is producing Nothing
07:56:58 <Attic> Cale: Yes it does, so the hi.glade file is wrong then?
07:57:06 <typoclass> Attic: i wrote you a message about that; scroll up a little :-)
07:57:29 <Cale> Attic: Probably. It's a bit weird that this is only giving us a Maybe and not some better indication of why that operation failed.
07:57:41 <Cale> What is xmlNew from?
07:57:57 <Attic> Graphics.UI.Gtk.Glade
07:59:01 <Cale> Okay, that's what happens when the underlying  glade_xml_new  C call gives a null pointer as its result
07:59:14 <Eduard_Munteanu> Attic: where's the file located?
07:59:19 <Cale> So at least it's not the binding's fault that you have no idea what's going on, the C library is really like that :P
07:59:32 <Cale> http://hackage.haskell.org/packages/archive/glade/0.12.0/doc/html/src/Graphics-UI-Gtk-Glade.html#xmlNew
07:59:37 <Cale> (I just looked at the source)
07:59:38 <Lutin`> Alright can I make this any better?
07:59:39 <Eduard_Munteanu> Maybe it's not in the current dir.
07:59:41 <hpaste> Lutin` pasted “Prime Factors (w/ guards)” at http://hpaste.org/76451
08:00:24 <Cale> Lutin`: How about instead of passing in the list [2..], pass in exactly the list of primes?
08:00:38 <Attic> Eduard_Munteanu: Same folder as the main.hs file
08:00:52 <Attic> Cale: Thanks
08:01:14 <typoclass> Cale: right. gtk doc for glade_xml_new says only "Returns the newly created GladeXML object, or NULL on failure" so that's useless as well :(
08:01:17 <typoclass> Attic: ^^
08:01:20 <Lutin`> Cale: Is there a cheap way to get that list?
08:01:45 <sm> Cale: incidentally, I'm also now using the efficiently-built tree you suggested last time I tried to optimise this (thx)  http://hub.darcs.net/simon/hledger/browse/hledger-lib/Hledger/Utils.hs#298
08:02:37 <Eduard_Munteanu> Attic: and your current working dir is correct?
08:03:30 <Lutin`> Cale: I considered doing 2:[3,5..]
08:03:41 <Jafet> primes = filter (null . drop 1 . flip primeFac primes)
08:03:42 <Eduard_Munteanu> Because if you're invoking it like foo/bar and you've got foo/hi.glade , it might fail.
08:03:43 <Lutin`> Just to get rid of multiples of 2
08:03:55 <Jafet> Wait, that won't work
08:04:06 <Cale> Lutin`: well, you already have a function which factors things into primes, so you can easily write a predicate which tests things for primality
08:04:38 <Attic> Eduard_Munteanu: I also tried writing the full path, still doesn't work
08:04:47 <Cale> Lutin`: e.g.  null . drop 1 . primeFac
08:04:50 <Attic> I might have messed up the .glade file
08:05:03 <Eduard_Munteanu> Attic: the full path to hi.glade?
08:05:10 <Attic> Yes
08:05:16 <Cale> Lutin`: well, let's give that a name:  isPrime = null . drop 1 . primeFac
08:05:18 <Eduard_Munteanu> Hm, that's also possible.
08:05:34 <Cale> Lutin`: and then you can write the list of primes like this:   primes = 2 : filter isPrime [3,5..]
08:05:35 <Eduard_Munteanu> Attic: make sure you're using a proper Glade, not GTK3's or something.
08:05:50 <Cale> Lutin`: but then you can use this list of primes in primeFac :)
08:05:52 <Eduard_Munteanu> You probably need to use the GTK2 glade.
08:06:19 <typoclass> gtk question -- is there some "GetLastError" function that tells you what went wrong with the most recent gtk function call? or a constant like errno?
08:06:21 <Eduard_Munteanu> Eww, errno :)
08:06:30 <Jafet> Cale: you can't, because it uses trial division to n to discover if n is prime
08:06:45 <Attic> Eduard_Munteanu: Just wrote the path wrong, and it now says that it can't find the file. so the glade file itself must not work
08:07:06 <Cale> Jafet: the list of divisors is sitting there, and could easily be replaced by primes
08:07:32 <Eduard_Munteanu> Attic: what version of Glade do you have?
08:07:52 <Jafet> Yes, but it needs to divide p by p in primes to see that p is in primes.
08:08:04 <Attic> Eduard_Munteanu: 3.12.1
08:09:08 <Eduard_Munteanu> Attic: http://www.ruby-forum.com/topic/2385140
08:09:10 <Cale> oh, yeah, we need to stop trying divisors sooner :)
08:09:18 <Eduard_Munteanu> Attic: "However, they are basically saying that glade 3.10 is for GTK3, and that "
08:09:21 <Eduard_Munteanu> it won't be fixed.
08:09:41 <Eduard_Munteanu> And they point you to Glade 3.8 if you want GTK2 compatibility.
08:10:47 <Attic> Ah I see now
08:11:02 <Attic> Eduard_Munteanu: Thanks I'll try install the 3.8 version and hope it works :)
08:11:43 <Lutin`> Cale: Would there be a better method to find the list of primes? besides inputting a list of primes
08:11:52 <Lutin`> list of prime factors*
08:12:18 <Cale> Lutin`: Well, there are all kinds of fancy methods
08:15:06 <Lutin`> Cale: True, I guess this is a well analyzed problem :{
08:15:08 <Lutin`> :P*
08:17:42 <hpaste> “ ” pasted “parsing a pair of floats” at http://hpaste.org/76453
08:17:47 <efie> could someone help me with this?
08:19:26 <merijn> efie: What's the type of parens?
08:19:39 <merijn> Parser a -> Parser a?
08:20:11 <merijn> Also, what's the definition of Parser?
08:23:15 <efie> ok I see that Parser a -> Parser a does not match
08:24:16 <Lutin`> Isn't that error saying that the m0 being passed is * instead of * -> *?
08:24:43 <merijn> Lutin`: Yes
08:26:16 <Lutin`> So to me that says something's wrong with emptyDef
08:26:32 <Lutin`> makeTokenParser :: Stream s m Char => GenLanguageDef s u m -> GenTokenParser s u m
08:26:51 <Cale> Lutin`: One cute way you might want to look at is this:
08:27:24 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
08:27:26 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
08:27:38 <Cale> (for finding primes)
08:28:13 <Cale> Lutin`: you can do something analogous with your program to produce a list of primes, and then use  (takeWhile (\p -> p*p <= n) primes) as your list of trial divisors
08:28:46 <Cale> It's somewhat more efficient to actually compute the square root of n and then test for p up to that limit, rather than computing the squares
08:28:52 <Lutin`> Bah I hate having to be on Windows for my classes
08:29:11 <Lutin`> Yeah I know
08:29:11 <Cale> but it's tricky to compute exact square roots quickly
08:29:14 <hiptobecubic> Lutin`, msys on a usb stick worked for me :)
08:29:19 <Lutin`> I was going to get to that
08:29:26 <Lutin`> By changing the input list
08:29:30 <Cale> right
08:29:57 <Lutin`> I can almost see the transformation from that program to mine
08:29:59 <Lutin`> haha
08:31:07 <Lutin`> Are there any existing sieve implementations?
08:31:26 <quicksilver> heh
08:31:29 <Lutin`> Why don't I get off my butt and google this
08:31:29 <quicksilver> "are there any"?
08:31:39 <quicksilver> there is an entire cottage industry of haskell sieve implementations
08:31:39 * hackagebot feldspar-language 0.6.0.2 - A functional embedded language for DSP and parallelism  http://hackage.haskell.org/package/feldspar-language-0.6.0.2 (AndersPersson)
08:31:53 <quicksilver> accompanied by many pages of discussion about whether they are "really" the famous algorithms or not
08:31:55 <Lutin`> I meant to say in HP
08:32:03 <quicksilver> no, there are none in the haskell platform
08:32:07 <quicksilver> it's not that kind of library set.
08:32:07 <Lutin`> k
08:32:23 <quicksilver> http://www.haskell.org/haskellwiki/Prime_numbers though
08:32:29 <Lutin`> That's what I figured
08:33:10 <Lutin`> I'm kind of out of it right now, I've already been to this page and looked at all of these :X
08:33:14 <Lutin`> But I totally forgot
08:33:57 <Lutin`> My internal memory seems to be volatile
08:34:02 <Cale> http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
08:34:07 <Cale> Have you seen that paper?
08:34:46 <atriq> Whoa, I think I can use lenses for this
08:34:48 <atriq> :D
08:35:15 <Lutin`> Wait what
08:35:32 <Lutin`> Oh
08:36:24 <Lutin`> Yeah that first implementation is horrible
08:36:33 <Lutin`> And defeats the point of the sieve
08:36:39 * hackagebot feldspar-compiler 0.6.0.2 - Compiler for the Feldspar language  http://hackage.haskell.org/package/feldspar-compiler-0.6.0.2 (AndersPersson)
08:36:53 <Lutin`> And obviously isn't the sieve
08:37:15 <matthiasgorgens> anybody interested in a non-dys-functional language users group in Cambridge, UK?
08:37:34 <matthiasgorgens> (not named just "Haskell users group" to include our local ocamlers, too.)
08:37:37 <sheriff_> matthiasgorgens: Citrix have a bunch of OCAML users there
08:37:48 <matthiasgorgens> sheriff_: yes, I used to be one.
08:38:04 <matthiasgorgens> I'm at Citrix at the moment.  (For one month more.)
08:38:05 <sheriff_> there you go
08:38:10 <matthiasgorgens> a co-worker of mine actually had the idea.
08:38:16 <matthiasgorgens> we also have haskellers, here.
08:38:16 <sheriff_> ah, I'm sat next to one of your coworkers
08:38:17 <matthiasgorgens> at citrix.
08:38:25 <matthiasgorgens> sheriff_: when, where?
08:38:39 <sheriff_> matthiasgorgens: Mike, who's on an Erlang course with me
08:38:44 <tromp> IOCCC 2012 source now available at http://www.ioccc.org/2012/whowon.html
08:38:47 <matthiasgorgens> I'm leaving for Standard Chartered in Singapore, but want to help set up the users group before I leave.
08:38:54 <matthiasgorgens> yeah, Mike had the idea for the users group.
08:39:02 <hiptobecubic> small world
08:39:06 <tac_> Is there anything notable about Erlang that couldn't be made into a straight well-typed Haskell port?
08:39:16 <matthiasgorgens> tac_: lots of libraries?
08:39:28 <hiptobecubic> that's the usual answer i think
08:39:32 <tac_> hm
08:39:35 <sheriff_> matthiasgorgens: he says hi
08:39:39 <nand`> the built-in binary templates or whatever?
08:39:48 <nand`> though similar things can be done with stuff like Get/Put
08:39:49 <hiptobecubic> sheriff_, shouldn't you be focusing on your class ;) ?
08:40:03 <quicksilver> the weakly coupled code version stuff
08:40:05 <matthiasgorgens> sheriff_: oh, is the erlang course running at the very moment?
08:40:06 <quicksilver> so you can upgrade live
08:40:16 <quicksilver> is a bit fiddly
08:40:32 <quicksilver> cloud haskell is a project targetting many of the virtues of the erlang infrastructure.
08:40:48 <matthiasgorgens> cloud haskell seems a bit hype-y at the moment.
08:40:56 <matthiasgorgens> but I hope they can live up to it.
08:41:05 <merijn> tac_: Hot code updates would probably be to hard to do in haskell to be worth it
08:41:18 <tac_> ah yeah, merijn
08:41:50 <matthiasgorgens> sheriff_: tell mike to prosetilyze for the users group!
08:42:13 <matthiasgorgens> (I hope I spelled that right.)
08:42:20 <nand`> aren't there a number of libraries that provide features like code recompiling/-loading during runtime, or watching source directories to update things in realtime as well?
08:42:25 <tac_> You'd need a nice IO (IO ())
08:42:35 <tac_> In Haskell to do Hotswaps
08:42:40 <matthiasgorgens> tac_: Fix IO?
08:42:45 <quicksilver> nand`: there are yes.
08:42:49 <merijn> tac_: Even then, what do you do with live IORef's, etc
08:42:57 <quicksilver> nand`: but they't don't solve the problem of new code and old data
08:42:57 <tac_> yeah
08:43:05 <quicksilver> nand`: especially if a type has changed, for example.
08:43:16 <nand`> ah
08:43:17 <quicksilver> we don't have versioned data types.
08:43:23 <quicksilver> mind you, erlang doesn't have data types at all.
08:43:24 <merijn> quicksilver: Yet ;)
08:43:27 <quicksilver> choose your poison.
08:43:33 <nand`> there are mechanisms for solving stuff like that too actually
08:43:46 <matthiasgorgens> merijn: Types help you to solve problems that you wouldn't have without.
08:43:54 <matthiasgorgens> (And also a few, that you would have without.)
08:43:59 <merijn> nand`: Sure, hence why I didn't say it's impossible, just hard enough to not be convenient :p
08:44:05 <nand`> for example, acid-state does data migration after type updates / program recompiles
08:44:22 <merijn> nand`: Yes, but only with a shutdown/restart of new binary, not live
08:44:34 <nand`> sure, but I'm saying it wouldn't take a lot to put two and two together
08:44:38 <matthiasgorgens> merijn: isn't that just an exec() call away?
08:44:52 <merijn> matthiasgorgens: Yes, but by definition that is not live
08:45:09 <nand`> acid-state's versioned data stores and update mechanism + existing live-reload mechanisms (that, to my knowledge, all serialize/deserialize shared information from/to the old/new binaries)
08:45:15 <merijn> matthiasgorgens: The reason Erlang has this is to be able to patch code without going down
08:45:44 <merijn> matthiasgorgens: Because shutting down a million connection telecom switch to patch it is unacceptably
08:46:09 <quicksilver> you shouldn't obesses about shutdown/restart of binary
08:46:17 <quicksilver> that's not the defining factor if something is live.
08:46:23 <quicksilver> the question is just how fast it is.
08:46:43 <quicksilver> if you can shutdown/restart the binary within say 1ms, and it retains all state - that might count as 'live' for some systems.
08:46:47 <quicksilver> and it might be too slow for others.
08:47:01 <merijn> quicksilver: Sure, but doing that in haskell is (as of yet) tricky :p
08:47:04 <typoclass> merijn: there's some places where you might need that, but ...
08:47:27 <matthiasgorgens> quicksilver: by that measure, xmonad does a pretty good job of being "live".
08:47:40 <merijn> typoclass: The question was "are there things that erlang can do that can't be simply implemented as a haskell library"
08:47:52 <matthiasgorgens> i.e. it restarts with all the previous state and new code fast enough.
08:47:55 <typoclass> i don't think that there's much to be gained from (say) changing xmonad to some erlangish thing that runs indefinitely
08:47:58 <merijn> typoclass: I'm just giving an example of something that is not easily implemented as a haskell library
08:48:22 <merijn> typoclass: I'm not saying it is relevant to all (or even many) programs
08:48:24 <matthiasgorgens> merijn: look at the cloud haskell material, they talked about what they needed to put directly into haskell.
08:48:30 <merijn> typoclass: But it is an answer
08:48:32 <matthiasgorgens> and what they could put into libraries.
08:48:45 <merijn> matthiasgorgens: cloud haskell doesn't do hot code updating either
08:48:45 <typoclass> merijn: right. i just meant that the question you addressed was very practical :) it's more of a nerd cred thing
08:49:18 * merijn thought it was a relatively practical answer
08:49:28 <strebe> being able to patch things nice is rather nice; it's one thing I really like about Smalltalk as well
08:49:28 <merijn> The answer was "not a lot, but there are some examples"
08:50:08 <Cale> The ability for anything to be patched by anything else at any time while the system runs over a long period of time is something that scared me about Smalltalk.
08:50:42 <strebe> Cale: it has to be used judiciously, but I know some people who have used it with great success
08:51:16 <quicksilver> strebe: that remark would be validly attached to a huge variety of programming techniques and indeed languages.
08:51:44 <Cale> Smalltalk is fun, but I found myself constantly amazed that the system somehow managed not to just shake itself to pieces, and I couldn't think of any reason in general that it wouldn't :)
08:51:57 <strebe> quicksilver: I'm not denying that. But it's not attached to -all- things people find scary; some genuinely are relatively useless
08:52:08 <S11001001> Cale: bad images die
08:52:59 <quicksilver> true
08:55:07 <strebe> Cale: yeah, there are a lot of warts lurking, but that seems to be less of one than it looks like in practice
08:56:33 <Cale> strebe: I'm the sort of person who likes to make as many static guarantees about behaviour as possible, and in smalltalk, the only guarantee you have is that there are no guarantees.
08:56:36 <Cale> :)
08:56:40 * hackagebot multiset-comb 0.2.3 - Combinatorial algorithms over multisets  http://hackage.haskell.org/package/multiset-comb-0.2.3 (BrentYorgey)
08:56:42 * hackagebot np-extras 0.3 - NumericPrelude extras  http://hackage.haskell.org/package/np-extras-0.3 (BrentYorgey)
08:57:18 <Cale> But that said, it does a lot of things the way that ruby and python ought to be doing them.
08:57:36 <raymank26> How write a function in StateT monad that is recursive and returns list all of results?
08:57:47 <raymank26> *of all results
08:58:14 <strebe> Cale: yeah; ruby and python have better libraries, and smalltalk guis tend to be nightmares, and don't get me started on concurrency - but aside from that, it's amazing in many ways
08:58:23 <Botje> pretty much the same way you'd write one without monads.
08:58:39 <Botje> raymank26: take a look at the definition of mapM, for example.
08:58:56 <raymank26> hm.. wait a second
09:00:51 <Peaker> I wish there was a project-wide tool to find dead code, unused exports, etc..
09:01:35 <raymank26> I need the same function but (i+1) element of list is based on i. In mapM this list is fixed.
09:01:47 <typoclass> Peaker: -Wall?
09:02:01 <Peaker> typoclass, that's module-specific, not project-wide
09:02:15 <Peaker> typoclass, if I export foo, but nobody ever uses it, I probably want to delete it as it's dead code I'm maintaining
09:02:24 <Peaker> (unless I'm a library, which I'm not)
09:02:28 <typoclass> Peaker: oooh i see
09:02:36 <Peaker> or maybe I want to make sure all my code is called from tests
09:02:59 <Peaker> (symbol-granularity coverage)
09:04:15 <typoclass> Peaker: the redneck approach might be to delete all of the export lists and the fix all the complaints, but that's obviously tedious :)
09:05:46 <Peaker> typoclass, yeah, I guess with -ddump-minimal-imports and then a bit of analysis on the imports files and reading the export lists it's rather easy to verify this
09:05:50 <typoclass> Peaker: ever used hpc? i've only just found the page, and it definitely looks neat http://www.haskell.org/haskellwiki/Haskell_program_coverage
09:05:53 <yitz> Peaker: hlint doesn't do that?
09:06:02 <Peaker> yitz, nope
09:06:08 <yitz> hmm
09:06:18 <Peaker> typoclass, that could be useful to detect dead code too, yeah
09:06:31 <typoclass> Peaker: right, good point, -ddump-minimal-imports shouldn't be forgotten
09:07:15 <Peaker> pet peeve: TH code that does late-binding, requiring me to import symbols only the TH I call uses
09:10:06 <Peaker> The derive library is guilty
09:10:11 <hpaste> magthe pasted “Std func for this?” at http://hpaste.org/76454
09:10:26 <typoclass> pity that zeroth hasn't been updated in so long ... http://hackage.haskell.org/package/zeroth
09:11:40 * hackagebot species 0.3.2.3 - Computational combinatorial species  http://hackage.haskell.org/package/species-0.3.2.3 (BrentYorgey)
09:12:01 <magthe> is there already a standard function that makes this easy? http://hpaste.org/76454
09:12:31 <Peaker> magthe, you could use takeWhile (not . null) instead of your break cond
09:12:58 <rwbarton> @type unfoldr
09:13:00 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
09:13:13 <rwbarton> is very close to your function
09:15:35 <magthe> Peaker: good suggestion, but instead of modifying 'untilCollect' I'd rather replace the whole thing with a function in some standard lib
09:16:11 <rwbarton> @type \t f v -> unfoldr (\x -> guard (t x) >> Just (f x)) v
09:16:12 <lambdabot> forall b a. (b -> Bool) -> (b -> (a, b)) -> b -> [a]
09:16:43 <bartavelle> is there something like Control.Concurrent.Chan, but with bounded channels ?
09:17:08 <typoclass> > let f ([],a) = Nothing; f (a,b) = Just (a,b) in unfoldr (f . splitAt 5) [1..11]
09:17:10 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11]]
09:17:15 <Cale> > map (take 5) . takeWhile (not . null) . iterate (drop 5) $ [1..11]
09:17:18 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11]]
09:17:29 <Cale> (not quite as efficient, but maybe you don't care)
09:17:31 <typoclass> > let iterate2 f xs = a : iterate2 f b where (a,b) = f xs in takeWhile (not . null) $ iterate2 (splitAt 5) [1..11]
09:17:34 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11]]
09:17:48 <typoclass> magthe: i suggest you add iterate2 to Prelude, and there you go
09:17:49 <typoclass> :)
09:18:00 <rwbarton> magthe: for the particular application in your last line there is the Data.List.Split library
09:18:08 <rwbarton> or the 'split' package on hackage, I should say
09:18:12 <Peaker> @type \t f -> takeWhile (not . t) . unfoldr (Just . f)
09:18:13 <raymank26> Botje: Ok. I have type of my function StateT a [] b. If state function returns [] I want to return [] from my function. How can I do it?
09:18:13 <lambdabot> forall a b. (a -> Bool) -> (b -> (a, b)) -> b -> [a]
09:18:22 <Polarina> typoclass, try mailing the maintainer.
09:19:06 <Cale> bartavelle: http://hackage.haskell.org/package/stm-chans
09:19:11 <magthe> Cale: the problem is that it's not quite as flexible... in my code the function I want to call repeatedly has the type 'ByteString -> (ByteString, ByteString)'
09:19:11 <typoclass> Polarina: i was being a little tongue in cheek :)
09:19:38 <bartavelle> Cale, thx
09:19:44 <Cale> magthe: Then typoclass' iterate2 looks like a good way to factor things
09:19:57 <Cale> bartavelle: disclaimer: I have not tried that package :)
09:19:59 <Polarina> typoclass, at least he'll know that some are still interested in that library. :)
09:20:03 <magthe> typoclass: iterate2??
09:20:23 <Cale> > let iterate2 f xs = a : iterate2 f b where (a,b) = f xs in takeWhile (not . null) $ iterate2 (splitAt 5) [1..11]
09:20:27 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11]]
09:20:27 <typoclass> magthe: see above (i had lambdabot execute it)
09:20:35 <typoclass> uh, yeah :)
09:21:30 <typoclass> maybe iterate2 should be called zipIterate ...
09:21:35 <Cale> :t let iterate2 f xs = a : iterate2 f b where (a,b) = f xs in iterate2
09:21:36 <lambdabot> forall t t1. (t -> (t1, t)) -> t -> [t1]
09:21:45 <Cale> :t unfoldr . (Just .)
09:21:46 <lambdabot> forall b a. (b -> (a, b)) -> b -> [a]
09:22:44 <Cale> > takeWhile (not . null) . unfoldr (Just . splitAt 5) $ [1..11]
09:22:46 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11]]
09:23:04 <typoclass> i mean, it's a common enough pattern, takeWhile (something) $ iterate (something). it's just that splitAt with its tuple return type doesn't fit in
09:23:55 <typoclass> Cale: ooh, that's the best idea i've seen
09:24:03 * Cale really wishes that mapAccumR didn't have its parameters screwed up too
09:24:38 <Cale> (If you don't know what I mean, see the diagrams here: http://cale.yi.org/share/Folds.svg)
09:26:15 <Cale> I'm pretty sure that it would be a safe change to make, given that nobody ever uses mapAccumR
09:26:33 <typoclass> maybe we should have an unfoldr variant without the Maybe, which keeps going infinitely (like iterate) ... ramble ramble
09:27:02 <shachaf> mapAccumL :: ((acc,x) -> (acc,y)) -> (acc,[x]) -> (acc,[y])
09:27:51 <magthe> Cale: that last one is very nice indeed
09:27:53 <shachaf> typoclass: We do. It's in Data.Stream.
09:28:27 <typoclass> shachaf: hmm interesting
09:28:43 <bgamari> Is anyone recording edwardk's talk today? (it is today, yes?)
09:28:50 <shachaf> typoclass: (Not for lists, though.)
09:28:59 <shachaf> bgamari: It's today but Google has a no-strangers-recording policy.
09:29:10 <bgamari> damn
09:29:15 <shachaf> And a we-don't-feel-like-recording-it-ourselves policy.
09:29:28 <hiptobecubic> can he record it himself then?
09:29:31 <bgamari> damn^2
09:29:32 <shapr> shachaf: aw
09:29:44 <shachaf> You should just show up!
09:29:49 <hiptobecubic> it's a long flight
09:30:03 <Cale> shachaf: Do they have a we-consider-the-speaker-we-asked-to-talk-a-stranger policy?
09:30:30 <shachaf> Cale: I expect so.
09:30:41 <shachaf> There will be several employees attending... But I bet they're strangers too.
09:30:59 <nand`> does there a exist a non-stranger?
09:31:46 <shachaf> I hear Rick Astley qualifies.
09:31:55 <strebe> shachaf: given what he pasted yesterday, more like a "external people are not allowed to record" policy
09:32:17 <shachaf> strebe: Yes, that's what I meant.
09:32:18 <nand`> (and what's edwardk's talk about?)
09:32:29 <shachaf> nand`: Lenses and other things.
09:32:53 <Cale> Is he giving it in Haskell?
09:33:01 <shachaf> @quote luite optic
09:33:01 <lambdabot> luite says: I'm really interested in both practice and theory of optics and wave mechanics, so I'll be coming over from Europe for Edward's lecture on lenses and transversals.
09:33:12 <Cale> Or did he translate everything into awkward Scala code in order to talk about it ;)
09:33:12 <shachaf> Yep.
09:33:17 <shachaf> No, Haskell.
09:33:34 <Cale> I'm just poking fun at the previously recorded talk :)
09:34:16 <nand`> haha
09:34:20 <nand`> optics and lenses :)
09:35:06 <nonymousa> hello
09:35:11 <hpaste> nonymousa pasted “parse.hs” at http://hpaste.org/76455
09:35:11 <Cale> hello
09:35:39 <hpaste> nonymousa pasted “cfg.json” at http://hpaste.org/76456
09:36:10 <nonymousa> this file parses to Nothing when trying to parseCfg, anyone know aeson well enough to halp?
09:37:07 <Cale> nonymousa: The first thing I would do is try to make a JSON document from a Cfg value, and see if it matches that format
09:37:16 <nonymousa> hmmm
09:37:20 <nonymousa> all right..
09:37:40 <nonymousa> so instantiate a Cfg and use ToJSON
09:37:45 <nonymousa> ok
09:40:02 <Cale> nonymousa: It might possibly include some representation of the Cfg constructor.
09:40:31 <nonymousa> Cale, what are you talking about? what may possibly include that?
09:40:42 <Cale> The expected/produced JSON format
09:41:05 <Cale> I don't really know the Aeson library well, or how these autogenerated instances are constructed.
09:41:51 <johnw> is there a function for getting the block size on a filesystem?
09:41:55 <Cale> But it stands to reason that if you were automatically translating Haskell datatypes into JSON, you'd want to include some representation of which data constructor was used to produce the data (unless they were really clever and noticed that the Cfg type has only one constructor as a special case)
09:42:15 <shachaf> johnw: Sounds a bit system-specific. Is there one in POSIX?
09:42:26 <johnw> i haven't found it yet...
09:42:32 <johnw> I'm using fileSize in System.Posix.Files
09:42:38 <johnw> but it's always the "apparent size"
09:42:50 <Cale> Why do you want to know this?
09:42:57 <johnw> i'm writing a "du" clone
09:43:08 <maukd> shachaf: stat?
09:43:09 <johnw> I know to know how much "df" output will change if I delete a reported directory
09:43:26 <maukd> hah, good luck getting df and du to agree
09:43:37 <johnw> it's really not that hard
09:43:47 <johnw> I've added a --block-size option to my program, and using a default of 4096 works just fine
09:43:50 <shachaf> maukd: Oh, yes.
09:43:54 <johnw> but it's going to be wrong on 512-byte block filesystems
09:44:01 <geekosaur> johnw, you'd be surprised
09:44:19 <johnw> let's take sparse files out of this discussion
09:44:36 <johnw> i don't care enough about those to deal with them just yet
09:44:46 <geekosaur> not even sparse files (du deals with those fine, actually, if you know what you're doing); I'm thinking of unlinked open files
09:45:30 <maukd> what, no blksize accessor?
09:45:34 <maukd> what is this
09:46:15 <typoclass> johnw: not exactly relevant, but you might enjoy http://www.reddit.com/r/haskell/comments/cs54i/how_would_you_write_du_in_haskell/
09:46:44 <johnw> interesting
09:46:52 <nonymousa> Cale, do you thhink newlines can harm the parsing?
09:47:00 <geekosaur> huh, nor even st_blocks
09:47:01 <geekosaur> fail
09:47:08 <johnw> my tool works now (in a manner equivalent to du --apparent-size), and has no space leaks, but now I want to match it to regular du a bit better
09:47:11 <nonymousa> the encoded value seems to be the same structure as my example json file
09:48:10 <johnw> i didn't use a find/fold approach, just a recursive tree walk (fused algorithm)
09:48:25 <Cale> nonymousa: I wouldn't expect the parser to be that bad
09:48:27 <geekosaur> I know older systems lack st_blksize, but they still have st_blocks and those systems all use st_blksize == 512
09:49:01 <nonymousa> right
09:49:08 <nonymousa> weird, it now works
09:49:23 <nonymousa> I copy-pasted the generated string into the example file, and now it parses it fine
09:49:30 <nonymousa> weirdanyways, good help, thanks
09:49:41 <johnw> so is this query just not possible in current haskell?  maybe I can answer it via FFI
09:49:45 <sclv_> this is a good question  about conduit (not mine). somebody should answer it! http://stackoverflow.com/questions/12935246/generic-serialization-in-haskell
09:50:13 <geekosaur> the current stat binding is omitting key information, yes
09:50:19 <johnw> ok
09:50:31 <johnw> just making sure I'm not going crazy
09:50:34 <joeyh> johnw: you need a stat*fs interface, which is sadly not available in any library on hackage. I have a lobotomised on inside git-annex in Utility.DiskFree, which could easily be modified to report f_bsize
09:51:03 <johnw> ah, st_blocks is exactly what I want
09:51:23 <typoclass> johnw: you could try out the ffi, it's really quite good
09:51:26 <johnw> joeyh: the reason I'm working on this tool today is that I want to make it git-annex aware
09:51:50 <johnw> "sizes" will report sizes within an annex as if there were no symlinks for annexed files (i.e., as though everything were unlocked)
09:51:54 <johnw> (err, locked)
09:52:03 <johnw> typoclass: yeah, I'll probably do that
09:52:34 <johnw> or maybe I should make a patch for "unix"
09:53:27 <joeyh> yes please, it'd be so nice.
09:53:50 <joeyh> it should not require the pain I've gone thru in order to check that your program is not going to overflow disk space :)
09:53:57 <johnw> yes
09:54:03 <johnw> this ia s "glaring omission"
09:54:18 <typoclass> the other day i ran into another weird omission in System.Posix.Files. it provides file modes 4000 and 2000, but not 1000
09:55:08 <clahey> I'm audioreading a book right now about a guy that goes back in time when he dies and he always has a heart attack at the same time.
09:55:10 <joeyh> btw, there's also a stat*fs interface inside xmobar, but I found its C struct unpacking was not very portable
09:55:21 <clahey> What do I decide I would do?  Learn haskell.
09:55:25 <joeyh> typoclass: heh, I've hit that one too. Easy to work around at least
09:55:58 <clahey> Well, the first time around I'd learn everything we know and then I'd introduce the topics earlier and let them develop and learn all the new things we discovered.
09:56:02 <clahey> And cycle like that.
09:56:14 <typoclass> joeyh: right, but still ... i mean they provide all the other constants (2 dozen?)
09:56:34 <shachaf> clahey: You could learn about continuations!
09:56:37 <clahey> I wonder if that's why Einstein had his annus mirabilis
09:57:08 <clahey> Maybe Newton too.
09:58:00 <johnw> joeyh: wow, that was an *easy* fix
09:58:12 <johnw> i guess i submit this to the GHC guys, yeah?
09:58:46 <clahey> It'd be weird.  I'm not 43 yet, but I can imagine going back to when I was 18 over and over again.
09:59:23 <clahey> I can imagine being 40 and studying intently what sort of things you could build with the infrastructure from when you were 18.
09:59:30 <clahey> I should switch to #haskell-blah, eh?
09:59:49 <johnw> if you have to ask... ;)
10:00:08 <johnw> so, fixing unix is easy; rebuilding it is going to be a monster
10:00:52 <Clint> is it really that big?
10:01:10 <johnw> well, I can't bump the version to 2.6.0.1
10:01:18 <johnw> too many core packages depend on ==2.6.0.0
10:01:24 <Clint> ah
10:01:26 <johnw> and if I rebuild 2.6.0.0, I need to rebuild >40 packages
10:01:31 <johnw> some of them very "core"
10:01:32 <typoclass> johnw: i think the ghc-libraries list or something
10:01:42 <Clint> i'd open a trac ticket
10:01:44 <typoclass> johnw: so cabal-dev then?
10:01:56 <johnw> i'm going to try extracting the code I added to unix, since it was as simple as: fileBlockSize (FileStatus stat) = unsafePerformIO $ withForeignPtr stat $ (#peek struct stat, st_blocks)
10:04:53 <geekosaur> johnw, that's incomplete.  you also want st_blksize
10:05:13 <johnw> Clint: agreed
10:11:20 <einsof> and then... there was nullspace
10:12:42 <johnw> http://hackage.haskell.org/trac/ghc/ticket/7345
10:13:02 <nonymousa> what's the idiomatic database library in haskell? is it HDBC or haskelldb?
10:13:11 <johnw> persistent!
10:13:22 <johnw> but probably haskelldb is more "idiomatic"
10:13:23 <zzing> I do not believe there really is one.
10:13:41 <johnw> if by that you mean "uses mathematics to such a degree that most people walk away in consternation"
10:13:57 <Starfire> I've heard good things about persistent.
10:14:31 <typoclass> @remember johnw but probably the other package is more "idiomatic". if by that you mean "uses mathematics to such a degree that most people walk away in consternation"
10:14:31 <lambdabot> I will never forget.
10:14:46 <rwbarton> johnw: did you write that diff by hand? the last part looks wrong
10:14:57 <johnw> no, i got it from git
10:15:03 <nand`> nonymousa: acid-state?
10:15:22 <rwbarton> well I think there is a bug in your git then
10:15:23 <nonymousa> nand`, yeah, I need to use a relational database..
10:15:27 <rwbarton> or you did something very funny
10:16:11 <typoclass> rwbarton: which part is the problem?
10:16:31 <rwbarton> +fileSize (FileStatus stat) =
10:16:31 <rwbarton> +  unsafePerformIO $ withForeignPtr stat $ (#peek struct stat, st_size)
10:16:38 <rwbarton> isn't that already there? i see it in the old export list
10:16:41 <rwbarton> meanwhile
10:16:52 <johnw> oh, strange
10:16:52 <rwbarton>  optimalBlockSize (FileStatus stat) =
10:16:52 <rwbarton>    unsafePerformIO $ withForeignPtr stat $ (#peek struct stat, st_blksize)
10:16:55 <rwbarton> these are actually new
10:17:02 <johnw> fixing now... thanks
10:18:25 <johnw> fixed, thank you
10:18:30 <typoclass> rwbarton: wow good catch
10:21:25 <johnw> does anyone know what "(#peek struct stat, st_blocks)" turns into?  Is it C code that can only appear in a .hsc?
10:22:36 <johnw> hmm.. i guess it computes the offset for peekElemOff
10:22:41 <rwbarton> you can look at the source for System.Posix.Files on hackage to see
10:22:48 <johnw> good idea
10:23:04 <rwbarton> the end result at least, if not the whole process...
10:23:22 <typoclass> johnw: see here http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/hsc2hs.html the thingy writes out a file that you can view (./dist/somewhere/)
10:23:29 <hpaste> con pasted “Nested wheres” at http://hpaste.org/76457
10:23:33 <typoclass> ... and yes, what's on hackage in the source view is the result
10:24:02 <johnw> (\hsc_ptr -> peekByteOff hsc_ptr 104)
10:24:14 <con> I have a question about nested where blocks and indentation: http://hpaste.org/76457
10:24:17 <johnw> that'll do for now, but will make my code horribly OS X dependent
10:25:13 <maukd> johnw: why?
10:25:27 <maukd> oh, are you hardcoding the offset?
10:25:30 <johnw> yeah
10:25:38 <johnw> I could always make my code into an .hsc file
10:25:44 <johnw> I'll likely do that
10:28:20 <johnw> hey, that worked
10:28:31 <johnw> now I just need a way to determine what the filesystem's block size is :)
10:29:35 <johnw> that's in statvfs
10:33:29 <nand`> one thing I've been becoming increasingly conscious of lately is that whenever I write Haskell, I include a ton of the kind of ‘unnecessary duplication’ I like to criticize other languages for - namely, I write every function name twice, once for the type signature and once for the implementation
10:33:46 <typoclass> nand`: ... and once for the export list
10:33:53 <nand`> I can't help but feel that one of these is superfluous if they're always adjacent to eachother either way (at least in my code)
10:34:51 <rwbarton> solution: make all your function names single letters to reduce the amount of duplication
10:35:27 <nand`> yes. I do actually feel it's one of the factors that drives me to finding function names that are “as short as possible” (but no shorter)
10:35:29 <ybit> what about readability?
10:35:30 <typoclass> nand`: i agree, it bugs me as well. while we're on it, i find it less than convenient that in "f :: ... eleventy arguments ... -> Hurgh -> ..."  the names of parameters are so far away
10:35:54 <typoclass> nand`: "as short as possible but no shorter" seems like the right thing anyway
10:35:55 <ybit> i guess comments could help in this regard
10:36:30 <maukd> >implying parameters need names
10:36:35 <gwern> nand`: it is annoying, but I find repetition in module imports even more annoying. 'import Data.Maybe, import Data.List, import Data.Tuple'...
10:36:36 <nand`> typoclass: no comment, I've never written a function with enough parameters for that to remotely become a problem, and I wouldn't like to use one either
10:36:52 <gwern> 'just let me indent after 'import Data.Maybe and write List, Tuple etc.'
10:37:17 <rwbarton> "map (import . (Data.))"
10:37:26 <parcs`> forM [List, Tuple, maybe] $ \x -> import Data.x
10:37:33 <nand`> I think the best solution for that would be to get rid of ‘Data.’, personally
10:37:40 <nand`> I've never liked the meaningless prefixes on a lot of those
10:37:43 <CmrPantoufle> OCaml can do this
10:37:45 <gwern> no, hierarchical is great, it's just not goo for typing
10:37:53 <CmrPantoufle> Module.(thing arg)
10:38:04 <nand`> it's a forced hierarchy that I'm not seeing the benefit of
10:38:16 <nand`> it only introduces questions like ‘What's the difference between Control. and Data.?’
10:38:21 <Cale> TimeZone tz = TimeZoneRegistryFactory.getInstance().createRegistry().getTimeZone(timeZoneId(that))
10:38:25 <parcs`> gwern: you can create a module that exports all the common modules and just import that
10:38:32 <gwern> parcs`: that's even worse...
10:38:41 <parcs`> in what way?
10:39:51 <CmrPantoufle> lol
10:40:35 <gwern> parcs`: it's both more work and also more unreadable
10:40:41 <maukd> import Hackage.Yes.All.Of.It
10:41:20 <Cale> It's a really good thing that we have a TimeZoneRegistryFactory to create our TimeZoneRegistry objects so that those can build our TimeZone objects for us. Where would we be without design patterns?
10:41:34 <nand`> maukd: except for the case of functions with only one possible well-behaved implementation; parameters need semantics - for example :: Int -> Int -> Int; even if I told you that the function does subtraction, you'd still need to know which argument corresponds to which operand (eg. (-) vs subtract)
10:41:38 <nand`> names can definitely help here
10:42:01 <typoclass> i think both things are useful. in most of my code "import Base" is the only import, which gives Data.Maybe and that kind of common stuff. but "import Data.Doodle" and then indenting and continuing with ".Quark" is useful also. you can't expect Base to contain everything in the world
10:42:39 <Kyraimion> Cale:  When you are paid by the hour this is actually dangerously concrete.
10:42:44 <Kyraimion> is*
10:42:51 <aleksandar_jovan> what would you use for a collection of mutable data
10:42:56 <aleksandar_jovan> IORef [a]
10:43:00 <nand`> I do selective imports (is that the terminology?) on almost everything either way, so I wouldn't want to use common ‘super-preludes’ like that
10:43:00 <aleksandar_jovan> or UArray
10:43:14 <nand`> (of course I could selectively import from the super-prelude, but I'd like to keep things distinct)
10:44:23 <nand`> aleksandar_jovan: depends on what context I need to mutate it in, and what semantics I'm assigning to it - if the collection is an indexable array, I'd probably use an array type. If it's an unordered set, I'd probably use Set
10:44:29 <typoclass> nand`: i did that once, but these days i just do "qualified as File", "qualified as T" etc. the advantages are better readability (you can tell something is not from here) and less hassle keeping the import lists in sync
10:44:36 <parcs`> typoclass: it would be more work to have to indent correctly and write .Quark than to copy and paste the line and replace Doodle with Quark
10:44:57 <typoclass> parcs`: hm ...
10:45:31 <parcs`> also it would look ugly
10:45:35 <crdueck> is there a function in Data.Map that takes a key, and deletes the key/value pair from the Map if it exists and returns the value as a Maybe Value if it was found in the map?
10:45:37 <nand`> I only use qualified imports for modules that deliberately use broad or conflicting names, like Data.Map
10:46:10 <parcs`> and it would make the order imports important
10:46:18 <crdueck> @hoogle Ord k => k -> Map k a -> (Map k a, Maybe a)
10:46:19 <lambdabot> No results found
10:46:57 <nand`> all of my imports are sorted alphabetically (for the most part), subdivided into blocks of the same prefix
10:47:00 <typoclass> parcs`: i think it doesn't have to be as fussy as requiring the exact number of spaces. it'd be ok to just say "any indented line is the same as the previous minus the last segment"
10:48:40 <con> Could anyone please help me with this indentation problem? http://hpaste.org/76457
10:48:53 <parcs`> i think the underlying issue is that the Control and Data hierarchies are stupid
10:49:19 <Kyraimion> @type updateLookupWithKey (const $ const Nothing)
10:49:20 <S11001001> con: where is not part of expression syntax
10:49:20 <lambdabot> Not in scope: `updateLookupWithKey'
10:49:49 <S11001001> con: stick the where below the otherwise line and exdented accordingly and you'll be fine
10:49:59 <Kyraimion> crdueck:  try updateLookupWithKey (\_ _ -> Nothgin)
10:50:04 <typoclass> parcs`: i think it's slightly related, but even if Data and Control were removed tomorrow, i'd still want to import System.Posix.Files.Whatnot pretty soon
10:50:34 <crdueck> :t Data.Map updateLookupWithKey (\_ _ -> Nothing)
10:50:35 <lambdabot> Couldn't find qualified module.
10:50:39 <crdueck> :t Data.Map.updateLookupWithKey (\_ _ -> Nothing)
10:50:40 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> (Maybe a, M.Map k a)
10:50:45 <parcs`> typoclass: the System hierarchy is stupid too :P
10:51:02 <con> S11001001: Both wheres or only the second one?
10:51:10 <alephomega> Both
10:51:18 <Cale> con: 'where' is part of the syntax of declarations, not part of the syntax of expressions
10:51:29 <crdueck> Kyraimion: wouldnt that just replace the value with Nothing, not remove it from the Map?
10:51:47 <Cale> con: So the first 'where' clause here, if any, will be attached to the definition of 'foo'
10:51:49 <S11001001> con: both
10:51:56 <Kyraimion> crdueck:  No, it's a Map k a, after all, not Map k (Maybe a)
10:52:06 <Cale> con: and then the one inside that will be attached to 'bar'
10:52:34 <crdueck> Kyraimion: okay, i need to look at updateLookupWithKey. thanks
10:53:02 <con> Cale, S11001001: Alright, thanks.
10:53:59 <b__25> is "readArray a i >>= writeArray a i . not" very efficient for flipping a Bool in a STUArray, or are there more specialised packages?
10:54:10 <typoclass> Cale: honestly, in terms of abstraction used for little to no gain, i'd rather have a small number of well-known "design patterns" used often, than a large number of obscure math concepts each used once or twice
10:54:31 <typoclass> Cale: i mean just in terms of cognitive overhead and teaching and reading other people's code
10:56:02 <Cale> typoclass: Except that's a false dichotomy
10:56:04 <b__25> but typoclass, you program Haskell
10:56:18 <Cale> Nobody uses a large number of obscure math concepts once or twice
10:56:42 * hackagebot Eq 1.1.2 - Render math formula in ASCII, and perform some simplifications  http://hackage.haskell.org/package/Eq-1.1.2 (VincentBerthoux)
10:57:10 <typoclass> b__25: yeah, exactly :-/
10:57:25 <b__25> so you secretly love those obscure concepts
10:58:25 <tac-tics> typoclass: I don't think anyone is happy with the module heirarchy in haskell
10:58:31 <typoclass> b__25: no i don't, i think it's one of haskell's weaker points
10:58:57 <b__25> I'll try to make my earlier question more general: for a bit array, is a MArray Int Bool the way to go?
10:59:54 <nand`> surely a bit array can be implemented under the hood as some Data.Bits WordN
11:00:15 <nand`> but semantically, that may not be what you're looking for
11:00:30 <alephomega> typoclass: what obscure math concepts are only used once or twice in Haskell?
11:00:55 <alephomega> Everything I can think of that´s actually used is used pretty regularly, unless I´m mistaken.
11:00:55 <Janthinidae> When a define an enum (e.g. data X = A | B | C) and then later use pattern matching, we don't I get a compile error if I don't implement them all and instead get a runtime error?
11:01:23 <roconnor> b__25: are the lengths of your bit arrays arbitrary, or always multiples of 8?
11:01:30 <b__25> arbitrary
11:01:34 <nand`> you *do* get a compiler warning, unless you turned it off (or it may be off by default, I forget)
11:01:47 <geekosaur> I believe it's off by defaulr
11:02:03 <roconnor> b__25: I'd use arrays of Bools, peferably with an interface abstracted by a module.
11:02:03 <Janthinidae> I just used runghc, no arguments, but thanks for the hint
11:02:08 <geekosaur> you can also use -Werror; some of us have requested a way to promote specific warnings to errors, but I don't think that's possible yet
11:02:18 <b__25> I need this bit array for a prime sieve where I toggle bits an arbitrary number of times
11:02:23 <roconnor> b__25: I'm no expert tough
11:02:36 <b__25> I have used STUArray s Int Bool now
11:02:40 <b__25> and it's pretty fast
11:02:46 <roconnor> that sounds pretty good
11:02:48 <nand`> I wonder if DataKinds could be used to implement an arbitrary-sized Word type, eg. Word 8; of course I'm not sure how you'd actually translate the Nat kind to some tangible value you can base computations on
11:02:54 <b__25> biting at the heals of the fastest sieves I found
11:03:02 <roconnor> b__25: I find it plausible that STUArrays like that are packed
11:03:07 <b__25> but I want to swallow them whole ;}
11:03:23 <b__25> roconnor, it seems so from having looked at the source
11:03:23 <roconnor> b__25: sounds like you already know more than me
11:03:49 <b__25> it is probably already faster if I would implement it with unsafe*
11:04:09 <b__25> but I want to optimise the algorithm first
11:04:32 <b__25> it will be my first public Haskell module/package \o/
11:05:19 <b__25> that will be exciting; my first real contribution to the Haskell community
11:06:05 <b__25> but roconnor your advice seems to correspond to my findings so far :} thanks
11:06:31 <roconnor> b__25: sounds awesome
11:09:46 <b__25> yes I want to repay my debt to this community :}
11:10:16 <b__25> since last summer I've received so much help here
11:10:30 <b__25> and now it's about time I repay it
11:13:37 <hiptobecubic> go on?
11:14:31 <b__25> what more is there to say?
11:14:48 <b__25> this channel and community is a source of knowledge greater than ever I found
11:15:35 <b__25> and I think a state-of-the-art-faster-than-C prime sieve would be a good way to give something back
11:16:18 <monochrom> @quote monochrom einstein
11:16:18 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
11:16:45 <johnw> joeyh: success!
11:17:02 <mm_freak> b__25: faster than C?  i'd love to see that
11:17:11 <johnw> I needed to make a Stat.hsc, hsStat.h and hsStat.c in my project, but now I can workaround the lack of those functions in unix until they appear there
11:17:19 <mm_freak> assuming faster than -O2 -fomit-frame-pointer gcc C
11:17:20 <hiptobecubic> b__25, have you written the algorithm in C as well?
11:17:26 <b__25> hiptobecubic, yes
11:17:51 <b__25> I am implementing optimisations in both languages at the same time
11:18:05 <hiptobecubic> that will be interesting to see for sure, then
11:18:07 <b__25> my reference is Bernstein's implementation of his own (and Atkin's) sieve
11:18:18 <b__25> aka primegen.c
11:19:41 <n-dolio> What about -O3 -fomit-frame-pointer -fpeel-loops -fsched-stalled-insns=12 -frename-registers -finline-limit=32768 -fbranch-target-load-optimize2 -ffast-math -funroll-loops -funroll-all-loops -funswitch-loops -fweb -finline-functions?
11:20:13 <nand`> add some -floop-* optimizations
11:22:04 <gentleben> just use the intel compiler
11:27:20 <parcs`> -Ofast
11:33:24 <hiptobecubic> doesn't -O3 do most of that by default?
11:35:07 <copumpkin> I don't think -O3 does anything on GHC beyond -O2
11:35:14 <n-dolio> hiptobecubic: Not most.
11:35:18 <n-dolio> copumpkin: GCC.
11:35:24 <copumpkin> oh
11:35:42 <copumpkin> I assumed we were talking about GHC, for some reason ;)
11:35:51 <n-dolio> That inline limit is probably insane. -ffast-math is unsafe in general...
11:36:00 <nand`> ghc -ffast-math
11:36:13 <hiptobecubic> -ffast-math is great
11:36:22 <n-dolio> unroll-all-loops does unrolling even when the compiler thinks it will be a pessimization, I think.
11:36:44 * hackagebot haskell-updater 1.2.0.8 - Rebuild Haskell dependencies in Gentoo  http://hackage.haskell.org/package/haskell-updater-1.2.0.8 (SergeiTrofimovich)
11:37:11 <n-dolio> I don't think omit-frame-pointer is on, either, unless it's changed since I actually used gentoo.
11:37:19 <n-dolio> Because that was something a lot of people did.
11:37:43 <shachaf> -fomit-instruction-pointer
11:37:56 <n-dolio> I don't even know what peel-loops and a couple of the others do.
11:38:01 <nand`> jumps are overrated
11:38:21 <clahey> Is ghc all written in haskell?
11:38:31 <nand`> the runtime is in C, afaik
11:38:56 <n-dolio> Some C some Cmm.
11:39:11 <geekosaur> and some haskell
11:43:48 <johnw> joeyh: ping
11:44:45 <shachaf> @remember copumpkin if I throw enough CT terms out there, one of them is bound to be right eventually
11:44:45 <lambdabot> Done.
11:44:47 <johnw> try out git://github.com/jwiegley/sizes.git, with the -A option is now "sees through" files linked into .git/annex, while ommitting .git/annex files, so that now the sizes are shifted around to be an equivalent report to the unannexed directory
11:49:45 <johnw> shachafmorphisms
11:51:43 <clahey> I can see why the run time would have to be in C.  What does the run time do?
11:51:58 * Clint squints.
11:52:53 <thoughtpolice> it contains things like the GC, the scheduler for threads, event management, some primops exist in the RTS in Cmm, also responsible for things like profiling/hpc/eventlog infrastructure
11:52:57 <thoughtpolice> basically: a ton of stuff
11:57:09 <clahey> Is the threading all cooperative?
11:57:37 <copumpkin> clahey: depends how you mean
11:57:54 <clahey> Or is it preemptive?
11:58:05 <Cale> It's preemptive
11:58:12 <shachaf> ...Usually.
11:58:16 <clahey> copumpkin: I saw some code in a gtk app where they created a timeout wherein they called yield.
11:58:27 <copumpkin> oh, gtk might be different
11:58:32 <clahey> copumpkin: Which made me afraid that if you stay in C land for too long, your threads don't run.
11:58:33 <copumpkin> they have all that funky event loop crap
11:58:41 <copumpkin> that's partially true
11:58:58 <clahey> copumpkin: Right, but as long as the event loop is in a different thread than the computational code, it shouldn't matter, I think.
11:59:09 <clahey> The whole lazy thing makes it a little confusing.
11:59:50 <n-dolio> Threads are preemptive, except the hooks for preempting are in the GHC memory allocator (and maybe some other places).
11:59:57 <rwbarton> this is a question I've had for a while and if I found out the answer I forgot
11:59:57 <n-dolio> So it's possible to write loops that can't be preempted.
12:00:17 <rwbarton> if I forkIO n threads that make long FFI calls to C, can that block all my Haskell threads if n is large
12:00:25 <rwbarton> or do they get new OS threads at some point
12:00:37 <parcs`> they get new OS threads i think
12:00:43 <parcs`> dmwit_ tested this
12:00:48 <rwbarton> by "large" I mean larger than the k in -Nk
12:00:48 <clahey> That sounds like it's not preemptive, it's cooperative with the run time yielding all the time.
12:01:18 <rwbarton> clahey: it is "preemptive" but implemented by the haskell runtime rather than the OS
12:01:21 <n-dolio> Sounds like preemptive isn't preemptive. It's cooperative with the kernel yielding all the time.
12:01:21 <parcs`> but only if the ffi calls are not marked unsafe
12:01:45 <rwbarton> clahey: you do not insert explicit "yield" into your Haskell code
12:01:50 <rwbarton> so in that sense it is preemptive
12:01:58 <clahey> In that sense it is preemptive, it's true.
12:02:13 <rwbarton> parcs`: okay, good
12:02:38 <rwbarton> marking "unsafe" is a sort of assertion that the ffi call will run quickly and successfully?
12:02:43 <clahey> Well, except that if it can only preempt when you allocate memory, I would suggest that that's not really preemptive.
12:02:50 <rwbarton> and that it won't try to call back into haskell for example
12:02:58 <maukd> rwbarton: yeah
12:03:03 <rwbarton> ok, cool
12:03:08 <clahey> I just discovered forkOS, so perhaps that is what you need to do to make gtk+ work properly.
12:03:11 <maukd> it lets the FFI cheat a bit when calling the function
12:03:15 <rwbarton> right
12:03:38 <rwbarton> if I am doing FFI to a single long computation, I wouldn't have any reason to want to mark it as unsafe
12:03:40 <Cale> clahey: forkOS likely does not do what you think it does, so read the description carefully
12:03:48 <clahey> It is a common misconception that you need to use forkOS instead of forkIO to avoid blocking all the Haskell threads when making a foreign call; this isn't the case. To allow foreign calls to be made without blocking all the Haskell threads (with GHC), it is only necessary to use the -threaded option when linking your program, and to make sure the foreign import is not marked unsafe.
12:03:55 <clahey> Cale: Yep.
12:04:13 <clahey> rwbarton: Yeay for documentation!
12:04:13 <rwbarton> or put on a ring
12:04:16 <rwbarton> oops
12:04:33 <shachaf> There are so many misconceptions about GHC threading.
12:04:44 <shachaf> Sometime someone should write a nice document explaining the whole thing.
12:04:58 <clahey> shachaf: I would if I understood it.
12:05:20 <Cale> shachaf: oh, you mean the haddock for Control.Concurrent?
12:05:42 <shachaf> Cale: The Haddock for Control.Concurrent is good but incomplete.
12:06:12 <rwbarton> Control.Concurrent, what's that? I thought everyone used Control.Concurrent.Async now :)
12:06:32 <shachaf> rwbarton: Pft, Control.Concurrent.Spawn is the future.
12:06:39 <rwbarton> Control.Concurrent.Cilk
12:07:44 <rwbarton> pool looks pretty neat
12:08:20 <rwbarton> though I feel like it might not be quite what I want when I want something it
12:08:55 <rwbarton> oh i see, it hands me a function to wrap things I want to limit
12:09:14 <rwbarton> so I can e.g. not make more than 10 concurrent requests to a website
12:09:32 <rwbarton> without worrying about other concurrent operations contributing to that total
12:10:11 * Polarina dislikes the GLfloat/GLdouble newtypes.
12:10:41 <fliip> If you have a function foo f x = f(f x), what happens when you call foo foo foo (foo2 x)?
12:10:42 <clahey> rwbarton: It does look pretty cool.
12:11:39 <parcs`> > let foo f x = f (f x) in foo foo foo f x
12:11:41 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))))))
12:11:44 <fliip> Will it run the function 2^3 times?
12:12:05 <rwbarton> 2^(2^2)
12:12:07 <parcs`> 2^2^2 times
12:12:17 <fliip> Ah I see. Ok thank you.
12:13:04 <parcs`> wait is it 2^(2^2) or (2^2)^2
12:13:22 <parcs`> > let foo f x = f (f x) in foo foo foo foo succ 0
12:13:24 <lambdabot>   65536
12:13:33 <rwbarton> oh heh
12:13:36 <rwbarton> they are the same, aren't they
12:13:54 <parcs`> > 2^2^2^2
12:13:55 <lambdabot>   65536
12:14:01 <clahey> That wasn't the question, was it?
12:14:13 <clahey> > let foo f x = f (f x) in foo foo foo (foo2 x)
12:14:14 <lambdabot>   Not in scope: `foo2'
12:14:23 <clahey> > let foo f x = f (f x) in foo foo foo (f x)
12:14:25 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
12:14:25 <lambdabot>    arising from a use of `...
12:14:36 <shachaf> clahey: (f x) would need to be a function for that to work.
12:14:42 <clahey> shachaf: Agreed.
12:14:46 <shachaf> So it does answer the question.
12:14:47 <Cale> > let foo f x = f (f x) in foo foo foo (f x) y
12:14:48 <lambdabot>   f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (f x (...
12:14:51 <maukd> > let foo f x = f (f x); foo2 = fun "foo2" :: Expr->Expr in foo foo foo (foo2 x)
12:14:53 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
12:14:53 <lambdabot>         against inferred ...
12:14:57 <maukd> oh, right
12:15:07 <clahey> It would give you foo (foo (foo (foo (f x)))), I think.
12:15:20 <clahey> I must have made a mistake of some sory.
12:15:26 <clahey> sort*
12:15:46 <shachaf> foo (foo (foo (foo ...))) is much more boring than foo foo foo foo ...
12:15:46 <nand`> foo = join (.)
12:16:12 <rwbarton> foo f is f . f, so foo foo is foo . foo and (foo . ... . foo) f {- n times -} is (f . ... . f) {- 2^n times -}
12:18:51 <fliip> If you have foo f x = f(f x) could you apply that to any function?
12:19:00 <fliip> Or does it have to follow some rule?
12:19:11 <shachaf> Well, it has to type-check.
12:19:23 <nand`> f has to be monomorphic, unless you give it some particular type signature
12:19:38 <fliip> Ah right. Thanks =)
12:20:10 <rwbarton> for a good time try :t foo foo foo (join (,))
12:20:30 <nand`> > show (show 3)
12:20:32 <lambdabot>   "\"3\""
12:20:35 <nand`> > let foo f x = f (f x) in foo show 3
12:20:37 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
12:20:37 <lambdabot>    arising from the literal `...
12:20:49 <rwbarton> oh it doesn't work
12:20:53 <nand`> example of what I meant
12:21:08 <rwbarton> need to spell out the foos
12:21:27 <clahey> Ah, because the two shows have different types.
12:21:42 <nand`> yes
12:21:51 <parcs`> > let foo f x = f (f x) in foo foo foo foo foo succ 0
12:21:53 <lambdabot>   *Exception: stack overflow
12:22:34 <clahey> > let foo f x = f (f x) in foo foo foo succ 0
12:22:36 <lambdabot>   16
12:22:38 <clahey> > let foo f x = f (f x) in foo foo foo foo succ 0
12:22:40 <lambdabot>   65536
12:22:53 <clahey> 2 ^ 2 ^ 2 ^ 2
12:23:05 <clahey> Got it.
12:24:01 <parcs`> a valid use for the tetration operator
12:25:40 <clahey> 2 ^^ 4?
12:27:14 <parcs`> 2↑↑4
12:27:33 <shachaf> 2↗↙4
12:27:40 <imperative_coder> hello
12:27:45 * shachaf >=> undefined
12:27:51 <imperative_coder> are there better string libraries than Data.Text/
12:28:08 <rwbarton> better for what
12:28:25 <imperative_coder> something for string processing like Python's native strings
12:28:40 <dmwit_> rwbarton: Yes, each Haskell capability has a thread pool that can grow if there are many outstanding FFI calls.
12:28:40 <rwbarton> that's not very specific
12:28:42 <imperative_coder> ah
12:28:57 <dmwit_> specifically, an OS-thread pool
12:30:10 <imperative_coder> Data.Text is alright though
12:30:16 <imperative_coder> but I'm new to Haskell
12:30:20 <clahey> imperative_coder: What do you want to do with them that python would allow?
12:30:42 <rwbarton> well Data.Text is just the type plus some basic stuff. but there are a lot of libraries that are built on top of Data.Text
12:30:42 <imperative_coder> clahey: ah im just implementing a string theory
12:30:47 <rwbarton> that's why I ask what you want to do
12:31:37 <clahey> imperative_coder: Um, like a low level physics theory, cause Text isn't going to be very useful for that.
12:31:40 <clahey> ?
12:31:56 <rwbarton> i doubt python has a standard library for string theory either, lol
12:32:01 <imperative_coder> nah just a formal system with theorems as string
12:32:11 <imperative_coder> strings*
12:32:12 <typoclass> imperative_coder: you're aware of the basic String type, right? a String is a [Char], meaning a list of Char. haskell has many functions available that process lists, and hence Strings
12:32:24 <rwbarton> are you the same person as the other guy who was talking about MIU
12:32:27 <clahey> rwbarton: import mbranes
12:32:30 <imperative_coder> yes
12:32:33 <maukd> MIU!
12:32:39 <maukd> good times
12:32:50 <imperative_coder> I want to solve miu
12:33:05 <typoclass> > map toUpper "lolcats" -- imperative_coder: an example of map, which is a function for lists, used on a String
12:33:06 <lambdabot>   "LOLCATS"
12:33:29 <clahey> > Text.map toUpper "lolcats"
12:33:30 <lambdabot>   Not in scope: `Text.map'
12:33:37 <dmwit> String (or Text) is a lousy representation of a term.
12:33:44 <dmwit> Make a real type.
12:33:46 <imperative_coder> right
12:33:52 <maukd> imperative_coder: heh, that was the reason I bought Gödel Escher Bach
12:33:56 <dmwit> Real types are cheap in Haskell.
12:33:59 <maukd> to learn the solution
12:34:25 <imperative_coder> so Text is not the way to go? :( what can i do instead ?
12:34:28 <Lutin_> Has anyone here done work with neural nets in haskell?
12:34:32 <dmwit> lern2data
12:34:58 <rwbarton> that would be a good troll, though. go into #perl and say "I've been reading some papers by Witten and want to try implementing some computations in string theory and I heard that perl is good at manipulating strings"
12:35:00 <imperative_coder> data Theorem = M | I | U A?
12:35:11 <imperative_coder> lol
12:35:26 <typoclass> imperative_coder: any haskell textbook will pretty quickly get to data types that are more expressive than strings. for example, lyah is available free of charge
12:35:28 <typoclass> @where lyah
12:35:29 <lambdabot> http://www.learnyouahaskell.com/
12:35:37 <fengshaun> hi all, is there a decent fractions module that can sort fractions?
12:35:46 <imperative_coder> ah thanks
12:35:46 <k00mi> Lutin_: yes
12:35:58 <Lutin_> k00mi: How did you encode it?
12:36:06 <dmwit> fengshaun: base has Data.Ratio
12:36:08 <rwbarton> > sort [1 % 5, 2 % 5, 1 % 3, 1 % 4]
12:36:09 <lambdabot>   [1 % 5,1 % 4,1 % 3,2 % 5]
12:36:25 <fengshaun> dmwit: thanks a lot
12:36:27 <k00mi> Lutin_: how did i encode what?
12:36:45 * hackagebot Glob 0.7.2 - Globbing library  http://hackage.haskell.org/package/Glob-0.7.2 (MattiNiemenmaa)
12:36:46 <Lutin_> k00mi: The weights and such
12:37:01 <Lutin_> Neurons as functions?
12:37:41 <typoclass> imperative_coder: you might want to start with the basic data structures in chapter 2, which are lists and tuples, and chapter 8, which describes the "data" keyword
12:37:57 <k00mi> Lutin_: no, a function is only part of them
12:38:22 <k00mi> Lutin_: my Neuron datatype consists of a list of weights, the threshold and the output function
12:38:26 <maukd> rwbarton: don't tempt me. the other day I implemented range compression ("1,2,3,5,9,10,11,12" -> "1-3,5,9-12") using only regex substitution
12:38:47 * rwbarton stares blankly
12:39:28 <dmwit> It seems like the hardest part of that is writing a regex that matches a number one higher than a previous match.
12:39:34 <maukd> yep
12:39:46 <maukd> I cheated by transforming all numbers to unary first
12:40:04 <Lutin_> k00mi: And do you just do like `type Layer = [Neuron]`
12:40:05 <strebe> I'm glad you were working with small numbers
12:40:13 <k00mi> Lutin_: yes
12:40:50 * typoclass once implemented run-length compression using nothing but a swiss army knife and a bit of cheese. a lesser man would have used a programming language.
12:41:21 <imperative_coder> real programmers use a magnetized needle and a steady hand
12:41:58 <dmwit> On the reshaping of all problems into nails once you have a hammer: http://oglaf.com/labyrinth/
12:42:06 <clahey> dmwit: SFW?
12:42:07 <dmwit> (One of the very few SFW Oglaf comics.)
12:42:16 <dmwit> Yes, just don't click anything.
12:42:26 <maukd> for reference: "1,2,3,5,7,8,9,10" =~ s/(\d+)/"x" x $1/rage =~ s/\b(x+)(?:,((?:\2|\1)x))+\b/$1..$2/gr =~ s/x+/$+[0]-$-[0]/erg
12:42:48 <Lutin_> k00mi: Well I have this idea in my head that network evaluation might be comonadic
12:43:02 <dmwit> All I read from that line was "rage, gr, erg"
12:43:15 <maukd> that was deliberate :-)
12:43:18 <thoughtpolice> clahey: the preempt on allocation thing is a reasonable tradeoff in practice. you're almost never going to have haskell code that doesn't allocate at some point, and allocations (the safe points) are very fast, so it's not a huge deal in practice. safe points could feasibly be anywhere, but that comes with a time/space tradeoff as well for the guarantee you will always have pre-emption
12:43:32 <dmwit> It was delightful.
12:43:52 <thoughtpolice> ezyang recently implemented this in GHC HEAD, with a new '-fno-omit-yields' that will cause yields to be inserted on procedure entries IIRC
12:44:26 <thoughtpolice> but i don't remember any details on metrics. unfortunately it's an entirely new way for ghc, i think, which means you'd have to recompile GHC + everything with it enabled
12:44:28 <clahey> thoughtpolice: I'm just worried about how it interacts with code in other languages.
12:44:32 <k00mi> Lutin_: i never even looked at comonads. my project was for school and i have to explain it to non-haskellers, so i stayed away from any serios abstractions
12:45:18 <Lutin_> k00mi: Ah alright
12:45:18 <clahey> dmwit: Apparently, the monitoring software my work uses doesn't let me see that page, even if it is SFW.
12:45:50 <clahey> Which makes total sense given that it tends to block things at a fairly high level.
12:46:05 <dmwit> I think marking all of oglaf.com as NSFW has a very low false positive rate. =)
12:46:06 <thoughtpolice> like i said, in practice you'll almost never have a loop that doesn't allocate, so safe points are regular and 'natural.' the only place i think this is actually a major-ish concern for the most part is e.g. safe haskell, where you may want to give some an interface for writing code, but they just write a non-allocating loop that deadlocks everything
12:46:14 <thoughtpolice> there are probably some other cases i'm not thinking of though
12:46:15 <thoughtpolice> but that's a big one
12:47:12 <clahey> dmwit: No disagreement.
12:47:29 <clahey> thoughtpolice: As long as FFIs get interrupted, I don't care.
12:48:05 <dmwit> FFI calls will never be interrupted from the Haskell side (unless they call back into Haskell, of course).
12:48:15 <k00mi> Lutin_: also, the code is pretty straight-forward as it is. running a network is two lines of code
12:48:22 <nonymousa> what happens when I import qualified a record? seems like it's accessors aren't importedhow can I import those too?
12:48:28 <clahey> dmwit: Even if they're run with forkIO?
12:48:35 <maukd> clahey: http://www.shrani.si/f/3Q/EM/2I97ZO7l/labyrinth.jpg
12:48:41 <nonymousa> i mean import qualified a record type from a module
12:48:42 <Lutin_> k00mi: Is it on github?
12:49:02 <k00mi> Lutin_: uhm yes, an somewhat older version
12:49:05 <clahey> nonymousa: It's something like (...), but I don't remember exactly.
12:49:11 <k00mi> Lutin_: https://github.com/k00mi/Seminararbeit/blob/master/hask/NeuralNet.hs
12:49:13 <dmwit> clahey: Even if they're called with forkIO.
12:49:18 <k00mi> Lutin_: comments are in german, sorry
12:49:26 <dmwit> clahey: That said, a forkIO'd call won't prevent *other* Haskell code from running.
12:49:34 <nonymousa> clahey, but then how do I use them?
12:49:34 <dmwit> clahey: (With the threaded runtime.)
12:49:35 <clahey> dmwit: Ah.
12:49:43 <clahey> nonymousa: Oh, no idea.
12:49:54 <nonymousa> ie Data Foo = Foo { bar :: int}
12:50:12 <nonymousa> import qualified FooModule as F (Foo(..))
12:50:12 <Lutin_> k00mi: Chrome autotranslated it :P
12:50:16 <nonymousa> and then what? ☺
12:50:18 <dmwit> Well, that's not accurate either.
12:50:23 <clahey> nonymousa: I could be totally wrong.
12:50:42 <nonymousa> no, i think that's it, but i can't figure out how to use them
12:50:42 <clahey> dmwit: So then, when my FFI calls back into haskell, it has the chance to be interrupted.  Makes total sense.
12:50:43 <k00mi> Lutin_: that's great :D
12:50:50 <dmwit> clahey: yes, exactly
12:50:50 <nonymousa> it should be F.bar i guess
12:51:12 <clahey> dmwit: But not for very long, unless someone somewhere does a loop with no allocation.
12:51:46 * hackagebot list-tries 0.4.3 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.4.3 (MattiNiemenmaa)
12:52:48 <chrisbuchholz> Evening folks
12:53:22 <clahey> dmwit: Thanks for helping me understand.
12:54:46 <dmwit> It's no problem. =)
12:54:47 <chrisbuchholz> im looking for some (presentation/talk) videos about doing (fun) stuff with haskell, e.g. from some user group or a conference or something. Can somebody hook me up with anything like that?
12:55:53 <clahey> In this: http://hackage.haskell.org/packages/archive/glib/0.12.3.1/doc/html/System-Glib-MainLoop.html  would the documentation for, say, timeoutAdd be more accurate if it said you passed in a computation to run at repeated intervals?
12:56:02 <clahey> Instead of a function that gets called at repeated intervals?
12:56:47 <dmwit> sure
12:57:13 <efie> I want to try out some of the profiling in RWH, if I compile my program with the needed flags, it says that I need to install the profiling libraries for Parsec. Doing this with "cabal install parsec --reinstall --enable-library-profiling" it says that I need to do for Data.Text, this again says I need to so for Control.Deepseq. Is there a command to say ... ok, reinstall whatever you need? Or how I do something similiar? I guess there are a fe
12:57:29 <dmwit> Also, beware: both gtk and glib provide timeoutAdd, and they're subtly different.
12:58:01 <dmwit> efie: Yeah, it's annoying. No, there's nothing automated right now.
12:58:10 <dmwit> (Patches almost certainly accepted if you feel up to a challenge.)
12:58:50 <dmwit> efie: I just turned on profiling in ~/.cabal/config before my last GHC upgrade and left it at that. =P
12:58:51 <efie> sorry, what do you mean by patches?
12:59:14 <dmwit> I mean: if you want to add some automation, I expect that the cabal-install folks would love some code that did that.
12:59:27 <efie> oh ok :)
13:01:19 <clahey> dmwit: I have some ideas for helper functions.
13:02:29 <clahey> dmwit: What sort of differences?  The main difference I can think of is that gtk adds a timeout to the gtk main loop whereas glib you can specify the main loop.
13:02:36 <clahey> Although that seems to be missing from glib haskell.
13:03:33 <clahey> Oh, I guess I'm wrong about that being there in the C version.
13:03:49 <dmwit> It's gtk2hs specific: gtk's timeoutAdd makes calls to grab the Gtk lock and release it.
13:04:13 <clahey> Oh, I didn't know there was a gtk+ lock.
13:04:15 <dmwit> i.e. gtk:timeoutAdd action ~= glib:timeoutAdd (grabLock >> action >> releaseLock)
13:04:26 <geekosaur> I was wondering; glib us a utility library, I don't see why it would have an event loop
13:04:33 <dmwit> http://dmwit.com/gtk2hs <- read this if you're interested in multithreaded gtk2hs programming, please
13:05:02 <clahey> geekosaur: It has a main loop library.
13:05:03 <dmwit> geekosaur: One of the utilities glib provides is a library for efficiently and correctly writing main loops.
13:05:13 <clahey> God bless Owen and Tim.
13:06:15 <clahey> dmwit: Yeah, I would have stuck on the gtk+ main thread.
13:06:23 <clahey> Rather, stuck gtk on a single thread.
13:06:38 <Eduard_Munteanu> Any news on gtk3hs? </prod>
13:06:47 <clahey> I usually have used g_timeout_add to send things to the main thread, but I suppose I'd need to use gtk_timeout_add.
13:06:59 <clahey> (In python, that's what I've used.
13:07:16 <ion> dmwit: Can you run initGUI and all the rest in some other thread?
13:07:30 <dmwit> ion: Yes, if it's a bound thread.
13:07:40 <ion> So… forkOS?
13:07:44 <dmwit> yes
13:07:49 <ion> Ok, thanks
13:08:39 <dmwit> clahey: postGUISync and postGUIAsync are the way to go in gtk2hs.
13:10:23 <clahey> dmwit: I believe, but I'm curious what they do that's different.
13:11:19 <dmwit> Uh, nothing, I think. It's just a convenience function.
13:11:59 <clahey> dmwit: Okay.
13:12:28 <dmwit> It just means you don't have to arrange to say the timer is done, and don't have to set up the MVar for communication yourself (for the Sync variant).
13:12:31 <rwbarton> dmwit: nice use of instance Enum Double
13:13:09 <clahey> dmwit: Gotcha.
13:13:32 <dmwit> rwbarton: Yeah, and also I checked beforehand to make sure last [1..2e8] would actually terminate. =P
13:13:44 <hpaste> DanBurton pasted “Comonad challenge” at http://hpaste.org/76460
13:14:25 <DanBurton> comonad gurus, here's a challenge for you ^'
13:15:41 <imperative_coder> http://ideone.com/Uu7hG how do I make the boxed prompts contain integers rather than doubles?
13:16:16 <imperative_coder> i.e. [1]: rather than [1.0]:
13:16:44 <hirschen> I'm playing with the NamedFieldPuns extension: Is it possible to match something like that: state@State{dbConn, size} <- readIORef stRef
13:16:54 <hirschen> I hope you understand what I mean
13:17:11 <hirschen> binding the whole record to a variable
13:17:17 <DanBurton> imperative_coder: with a type annotation, I imagine
13:17:19 <dmwit> state@(State {dbConn, size})
13:17:29 <hirschen> dmarker, really, cool
13:17:48 <clahey> dmwit: I think I had read some older stuff that said that you had to do the yield thing.  Thanks much for the page.
13:18:22 <dmwit> cl_social: Right, that's for the nonthreaded runtime.
13:18:40 <hirschen> dmwit: works, thank you
13:18:51 <thoughtpolice> hirschen: if you have RecordWildCards too, you can also just say state@State{..} <- ..., although sometimes you don't want necessarily everything to be bound in scope
13:19:11 <rwbarton> imperative_coder: well the thing is that since you later divide by n, n must be some fractional type and it defaults to Double
13:19:38 <DanBurton> imperative_coder: http://ideone.com/AnKG2
13:19:58 <zzing_> What should I be looking at to convert a Text to an Int?
13:19:58 <arthurmaciel> hello
13:19:59 <DanBurton> imperative_coder: so annotate it Int, then use fromIntegral to convert at the appropriate spot
13:20:00 <dmwit> thoughtpolice: still need parens
13:20:31 <imperative_coder> right
13:20:41 <imperative_coder> that worked! thanks
13:20:41 <thoughtpolice> oh, right. you can obviate the parens if you don't use the at-binding
13:21:37 <dmwit> zzing_: Data.Text.Read?
13:21:52 <rwbarton> DanBurton: this has nothing really to do with the fancy natural-indexed type, right
13:22:04 <rwbarton> just "how do you define a comonad instance for data X a = X [a] a [a]"
13:22:23 <zzing_> dmwit, thank you I didn't see that
13:23:08 <rwbarton> and isn't it just something like cojoin x = X (tail $ iterate left x) x (tail $ iterate right x)
13:23:25 <rwbarton> or in your case s/X/Dimension/
13:23:36 <rwbarton> also I might have left/right backwards
13:23:57 <DanBurton> rwbarton: no it sort of does have to do with the nats
13:24:31 <rwbarton> how so?
13:24:31 <dmwit> I would expect you need to write cojoin :: U n a -> U (S n) a, which is sort of the wrong type.
13:24:34 <DanBurton> U can be n-dimensional
13:24:42 <rwbarton> so what
13:24:46 <mcstar> hai
13:24:50 <rwbarton> X (X (X (X ...))) is still X (something)
13:24:59 <rwbarton> er
13:25:00 <rwbarton> hmm
13:25:03 <DanBurton> cojoin :: U n a -> U n (U n a)
13:25:17 <rwbarton> oh, I see right
13:25:42 <mcstar> i forgot, whats the way to profile haskell programs?
13:25:57 <mcstar> i dont mean memory profiling, i want call times
13:25:58 <rwbarton> probably this is easy with magic lens/zipper/traversal stuff
13:26:08 <DanBurton> lol
13:26:15 <Cale> mcstar: compile with -prof -auto-all and then run with +RTS -p
13:26:25 <mcstar> k
13:26:27 <Cale> mcstar: I think it might've changed in 7.6 though
13:26:33 <mcstar> Cale: im having trouble with sudoku
13:27:06 <mcstar> Cale: im really frustrated, i think my program should do better but it isnt :(
13:28:30 <mcstar> my first version of sudoku solver beats the one that uses the representation for the exact cover translation..
13:28:33 <nejucomo> Is (- ...) defined to be (negate ...) ?
13:28:35 <mcstar> thats disapointing too
13:28:53 <johnw> @src negate
13:28:53 <lambdabot> negate x = 0 - x
13:28:58 <johnw> @src (-)
13:28:58 <lambdabot> x - y = x + negate y
13:29:06 <johnw> hmm
13:29:16 <johnw> unary - is syntactic, I believe
13:29:20 <DanBurton> nejucomo: yes
13:29:35 <zzing_> Is there any map that supports stateful changes to keys and values such that the entire map does not have to be replaced if I need to change something?
13:29:37 <DanBurton> > (- (2 + 2))
13:29:38 <lambdabot>   -4
13:29:43 <DanBurton> (- (2 + 2)) 4
13:29:47 <DanBurton> > (- (2 + 2)) 4
13:29:48 <lambdabot>   -4
13:30:14 <DanBurton> that's an interesting Num instance o_O
13:30:27 <mcstar> Cale: are you willing to look at my codes, if i post them?
13:30:28 <Kyraimion> > 1 3
13:30:29 <lambdabot>   1
13:30:38 <ion> > (sin^2 + cos^2) 42 :: CReal
13:30:39 <lambdabot>   1.0
13:30:53 <DanBurton> a number "x" is the function "const x"... dat caleskell
13:31:16 <Kyraimion> > 2 * -3
13:31:17 <lambdabot>   Precedence parsing error
13:31:17 <lambdabot>      cannot mix `GHC.Num.*' [infixl 7] and prefix ...
13:31:23 <nejucomo> Hrm...  I have a class C in one module which specifies (**) and an instance in another module where (**) is only used in that definition...
13:31:32 <crdueck> @src Enum
13:31:33 <lambdabot> class  Enum a   where
13:31:33 <lambdabot>     succ                     :: a -> a
13:31:33 <lambdabot>     pred                     :: a -> a
13:31:33 <lambdabot>     toEnum                   :: Int -> a
13:31:33 <lambdabot>     fromEnum                 :: a -> Int
13:31:35 <lambdabot> [3 @more lines]
13:31:49 <nejucomo> But when I do: import M (C a, (**), b)
13:31:57 <nejucomo> -ghc complains that (**) is redundant.
13:32:05 <nejucomo> When I remove that import, it complains that it's not in scope.
13:32:20 <Cale> mcstar: I have low attention span atm, because of work, but you should post them so people can have a look and see if there are improvements
13:32:35 <DanBurton> does it complain that it is redundant, or ambiguous?
13:32:39 <DanBurton> because it is ambiguous
13:32:42 <mcstar> Cale: ok :)
13:32:46 <DanBurton> I think
13:33:16 <nejucomo> It seems as if I cannot explicitly import this class identifier.
13:33:41 <nejucomo> DanBurton: It complains it is redundant.
13:33:47 <DanBurton> @hoogle (**)
13:33:47 <lambdabot> Prelude (**) :: Floating a => a -> a -> a
13:33:47 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
13:33:47 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
13:33:53 <nejucomo> Ah, I see why it is ambiguous.
13:33:57 <DanBurton> so you're hiding the Prelude one?
13:34:04 <nejucomo> Ah, I also have: import Prelude hiding (null, map)
13:34:09 <nejucomo> Is that related?
13:34:19 <nejucomo> Hm... time to pick a new symbol.  I guess I'll just stick to an english identifier.
13:34:23 <DanBurton> try adding (**) to the list of hidden prelude things
13:34:25 <DanBurton> or that
13:34:56 <nejucomo> DanBurton: I'll try hiding (**) as a test, but I don't want to collide with the prelude.
13:35:11 <dmwit> import M (C((**)), b)
13:35:16 <arthurmaciel> I've started reading Real World Haskell. I started studying it just when I was going to implement a prototype of a web app in Scheme. Is there any easy-to-understand web framework in Haskell?
13:35:19 <nejucomo> Woah... if I add (**) to the hiding clause, *then* I get an ambiguous occurence failure.
13:35:47 <strebe> arthurmaciel: I keep hearing about yesod, but haven't tried it. There are some hello-worldy things on planet haskell
13:35:56 <nejucomo> Hrm.  Basically, ghc errors seem very confusing here, but I'm going to side-step them by just renaming anyway.
13:36:19 <dmwit> nejucomo: I think you are 1. not exporting what you think you're exporting and 2. not importing what you think you're importing.
13:36:36 <stepcut> arthurmaciel: happstack-lite is pretty easy to get started with, http://www.happstack.com/c/view-page-slug/9/happstack-lite
13:36:55 <Kyraimion> arthurmaciel:  The is yesod, happstack and snap
13:37:00 <dmwit> but Show Us Some Code
13:37:09 <stepcut> arthurmaciel: small, but usefully complete API
13:38:16 <hpaste> Nejucomo pasted “MultGroup” at http://hpaste.org/76461
13:38:42 <nejucomo> dmwit: That hpaste is the module with the class.
13:38:49 <nejucomo> I'm pretty unsure what this actually exports.
13:39:03 <nejucomo> What happens if foo is in scope and then you define a class with foo as a member?
13:40:05 <nonymousa> so…I havea function I pass a database connection configuration to, which connects to a database and then should just return a String. signature along these lines: myFunc :: Conf → String
13:40:19 <dmwit> This should not export any Prelude things.
13:40:27 <nonymousa> but because of the database connection, it complains about the type (IO Connection)
13:41:05 <dmwit> Although I must admit I'm a bit surprised this module doesn't give you an ambiguity error.
13:41:06 <Kyraimion> cabal-dev ghci gives me "cabal: ghcInvocation: the programVersion must not be Nothing", is this a cabal-dev bug or am I doing something wrong?
13:41:07 <nonymousa> what would the signature become?
13:41:34 <nejucomo> dmwit: I wish ghc would complain about (**) being ambiguous because it is both exported and defined.
13:41:47 <nejucomo> eh, maybe that's not "ambiguous" in the sense of *import* collisions, but it's a collision.
13:42:16 <Kyraimion> nonymousa:  If it does something with databases it should most likely be Conf -> IO String
13:43:03 <imperative_coder> http://ideone.com/mS9Rp how do I print out the fractional numbers to only two decimal places?
13:43:28 <nonymousa> Kyraimion, damn, that was simple. damn it I didn't think of it. thanks.
13:43:31 <dmwit> imperative_coder: printf, or use http://hackage.haskell.org/packages/archive/base/latest/doc/html/Numeric.html
13:43:38 <scp> Is there an easy way to serialize values in haskell that doesn't involve exceptions being thrown if things go wrong?
13:43:51 <EvanR> :t showFFloat
13:43:53 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
13:44:15 <arthurmaciel> thanks, Kyraimion and stepcut. I'll try them.
13:44:15 <EvanR> > showFFloat (Just 2) 3.14159 ""
13:44:16 <lambdabot>   "3.14"
13:44:32 <dmwit> > printf "%.2f" pi :: String
13:44:33 <maukd> this is a job for printf
13:44:34 <lambdabot>   "3.14"
13:44:45 <EvanR> > 3.14159 :: Centi
13:44:47 <lambdabot>   3.14
13:44:50 <EvanR> :3
13:44:53 <ion> @hoogle Centi
13:44:54 <lambdabot> Data.Fixed type Centi = Fixed E2
13:45:17 <scp> Is there like a 'maybeRead' or something that will return 'Nothing' on a parse error, instead of throwing 'no parse'?
13:45:22 <dmwit> scp: reads
13:45:34 <scp> :t reads
13:45:36 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:45:42 <rwbarton> or if you are living in the future, there is something like maybeRead
13:45:48 <dmwit> > reads "123 for example"
13:45:49 <lambdabot>   []
13:45:56 <dmwit> > reads "123 for example" :: [(Int, String)]
13:45:58 <lambdabot>   [(123," for example")]
13:46:20 <dmwit> There's a maybeRead in the safe package, but it seems silly to me.
13:46:23 <scp> >reads "nan" :: [(Int, String)]
13:46:23 <rwbarton> > reads "123 " :: [(Int, String)]
13:46:24 <lambdabot>   [(123," ")]
13:46:29 <rwbarton> > read "123 " :: Int
13:46:31 <lambdabot>   123
13:46:34 <scp> >reads "nan" :: [(Int, String)]
13:46:40 <Kyraimion> > reads "nan" :: [(Int, String)]
13:46:41 <lambdabot>   []
13:46:49 <typoclass> scp: there's some code on the faq page you can copy-paste
13:46:50 <scp> oh, I was missing a space x_X
13:47:03 <scp> why is it a list and not a maybe?
13:47:09 <EvanR> > reads "NaN" :: [(Float, String)]
13:47:11 <lambdabot>   [(NaN,"")]
13:47:15 <rwbarton> just in case
13:47:21 <EvanR> scp: to make parsers
13:47:22 <dmwit> scp: In case of ambiguous parses.
13:47:24 <hpaste> mcstar pasted “sudoku solver” at http://hpaste.org/76462
13:47:25 <rwbarton> (of ambiguous parsers)
13:47:57 <scp> I see
13:48:07 <mcstar> so, thats my naive solver
13:48:34 <scp> so, why didn't it give [(1, "23 for example"), (12, "3 for example"), (123, " for example")]?
13:48:34 <mcstar> and i cant make my solver based on the exact cover representation/algorithm as fast as this one
13:49:01 <dmwit> I would prefer if it did (though in the reverse order).
13:49:08 <typoclass> scp: i think it's historic, the list was intended for multiple possible parses but afaik it didn't go that way, nobody really uses it
13:49:11 <rwbarton> same reason 12 in haskell does not mean ambiguously 12 or 1 2
13:49:35 <scp> oh ya, I guess if it's parsing haskell syntax that makes sense
13:49:42 <shachaf> 1 2 base 8 which is 10 base 10 and you take away 3, that's 7
13:50:05 <dmwit> > 0o128 -- rwbarton ;-)
13:50:06 <lambdabot>   10
13:50:14 <typoclass> > let f =3 in (7f, 0x7f)
13:50:15 <lambdabot>   (7,127)
13:50:25 <rwbarton> > reads "0o128" :: [(Int,String)]
13:50:26 <lambdabot>   [(10,"8")]
13:50:29 <rwbarton> the system works!
13:50:32 <rwbarton> fsvo works.
13:50:38 <ivanm> preflex: seen TacticalGrace
13:50:39 <preflex>  TacticalGrace was last seen on #haskell 10 days, 9 hours, 2 minutes and 17 seconds ago, saying: ;)
13:51:00 <dmwit> Anyway, the choice to make reads' parser be "like Haskell" is just that: a choice.
13:51:09 <maukd> > 0x7f
13:51:10 <lambdabot>   127
13:51:12 <maukd> > 07f
13:51:13 <ski> > (reads :: ReadS Int) "123 for example"  -- scp,EvanR
13:51:14 <lambdabot>   Ambiguous type variable `a' in the constraint:
13:51:14 <lambdabot>    `SimpleReflect.FromExpr a...
13:51:14 <dmwit> I would have preferred another choice, and maybe so would others.
13:51:14 <lambdabot>   [(123," for example")]
13:54:14 <pordan30> Is "The Implementation of Functional Programming Languages" by SPJ the standard reference for constructing functional compilers, or is there other recommended material?
13:54:32 <Eduard_Munteanu> @where stg
13:54:32 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
13:54:53 <Eduard_Munteanu> @@ @google @where stg
13:54:54 <lambdabot>  http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
13:54:54 <lambdabot>  Title: CiteSeerX — Implementing lazy functional languages on stock hardware: the Spin ...
13:55:21 <shachaf> pordan30: It's a good book but a bit old.
13:55:31 <imperative_coder> http://ideone.com/hlCtA any style comments for my code? am I doing something wrong or dangerous? (hlint says its fine)
13:55:33 <shachaf> (It predates Haskell, for example.)
13:55:39 <imperative_coder> can I make it more efficient?
13:57:13 <pordan30> equard, shachaf: thanks; i'll look at the linked paper, too.
13:57:58 <shachaf> @google a fast curry
13:58:00 <lambdabot> http://research.microsoft.com/~simonpj/papers/eval-apply
13:58:00 <lambdabot> Title: How to make a fast curry
13:58:07 <shachaf> pordan30: That might also be relevant.
13:59:22 <hpaste> mcstar pasted “sudoku solver” at http://hpaste.org/76464
14:00:41 <ivanm> shachaf: fast to prepare + cook, fast to be eaten or fast to go through your system? :p
14:00:42 <pordan30> Before I dig in, is an appropriate audience someone who is familiar with the traditional computability theory and type systems (e.g., Pierce) background?
14:01:04 <mcstar> i cant believe, that i need to use mutable state to get close to the performance of the best solvers
14:01:12 <efie> making a function strict only makes sense if the garbage collector has a lot of work to do, doesn't it?
14:01:31 <shachaf> pordan30: Well, what's your goal?
14:01:46 <shachaf> I don't think the STG paper talks about type systems too much.
14:02:31 <shachaf> The sort of thing it talks about is mostly orthogonal, really.
14:03:07 <Eduard_Munteanu> I guess a little background on compilers helps.
14:04:33 <pordan30> the intended goal being to gain the knowledge required to write a functional compiler, assuming that the knowledge required to write a naive interpreter has already been acquired.
14:05:21 <shachaf> So things-other-than-type-checking?
14:06:19 <pordan30> things other than parsing, type checking, and so forth - yes.
14:06:29 <scp> So
14:06:31 <EvanR> code generator?
14:06:50 <shachaf> pordan30: The STG paper should be pretty good for figuring out how lazy languages are usually compiled, yes.
14:07:41 <pordan30> shachaf: okay, that sounds good then. thank you
14:07:50 <Eduard_Munteanu> FWIW, you might want to use something like Epic in the meanwhile.
14:07:54 <Eduard_Munteanu> @google epic compiler
14:07:56 <lambdabot> https://www.cs.st-andrews.ac.uk/~eb/epic.php
14:07:56 <lambdabot> Title: Epic - a Supercombinator Compiler
14:08:04 <EvanR> what does the G stand for in STG
14:08:12 <shachaf> G-machine, of course.
14:08:18 <EvanR> what does the G stand for in G-machine
14:08:19 <shachaf> Maybe graph?
14:08:22 <EvanR> ah
14:08:33 <shachaf> Being a graph reduction machine and all. But that's just a guess. :-)
14:09:28 <Eduard_Munteanu> e.g. you might want to compile stuff to a lower-level language like Epic provides, without worrying about too many details there.
14:09:36 <jonkri> can anyone recommend a simple library for haskell to send a (non-mime) e-mail from a unix environment? there seems to be a whole lot of libraries laying around :>
14:09:58 <hiptobecubic> fork mailx :)
14:10:09 <johnw> are you wanting to communicate directly with an SMTP server?
14:10:20 <johnw> otherwise, I'd just fork /usr/bin/sendmail
14:10:29 <johnw> or do you also want all the RFC822 stuff handled for you too?
14:10:36 <johnw> there are many different ways to solve this problem
14:10:36 <EvanR> smtp-client
14:10:51 <jonkri> johnw: yes, directly with an smtp server running on localhost
14:11:19 <johnw> http://hackage.haskell.org/package/SMTPClient
14:11:49 <mcstar> Cale: do you think i'd gain speed, if i wrote a custom function to replace a fold?
14:11:56 <pordan30> yes, epic looks like it might be a good option. i'll look into that also
14:12:15 <Eduard_Munteanu> There's ssmtp if you need a lightweight thing.
14:12:44 <typoclass> jonkri: i think i'd just use System.Process or System.Cmd to run "mail -s blah blah"
14:12:47 <Cale> mcstar: Often that loses speed, unless you're doing something which is actually better than what the fold is.
14:13:29 <jonkri> thanks all :)
14:13:42 <Eduard_Munteanu> Wait, nevermind my suggestion, I misread.
14:13:48 <mcstar> HS.foldl' (\pq r -> HS.foldl' (flip (Q.adjust pred)) pq (lookup r row_to_col))
14:13:55 <mcstar> ^^ this takes quite much time
14:15:05 <mcstar> maybe should just stay away from this problem for some tim
14:15:15 <mcstar> and later revisit it, its driving me mad...
14:15:52 <Cale> What module is HS?
14:15:59 <mcstar> Data.HashSet
14:16:18 <Cale> oh, hmm
14:16:23 <mcstar> Cale: i pasted both versions, if you want to ake a look at them :P
14:16:36 <Cale> Is Data.HashSet better than Data.IntSet or Data.Set?
14:16:47 <mcstar> by a little i think so
14:17:39 <rwbarton> if you have a HashSet Int that is storing 1-9 then you should probably just use a Word
14:17:54 <efie> Data.Map.lookup has O(log n), what about Prelude.lookup? Is it, since it's recursion over a list, O(n)?
14:18:10 <mcstar> yeah
14:18:17 <rwbarton> using some fancy data structure to store 9 bits is a little absurd
14:18:38 <shachaf> I need to store 65 bits. :-(
14:19:16 <rwbarton> okay, use two Words :)
14:19:26 <rwbarton> it is extensible!
14:19:28 <mcstar> that doesnt really matter
14:19:30 <ion> @hoogle Word96
14:19:31 <lambdabot> No results found
14:19:33 <ion> @hoogle Word128
14:19:34 <lambdabot> No results found
14:19:35 <typoclass> shachaf: youtube is up again, you could upload it
14:19:38 <ion> I’m pretty sure some module had those.
14:19:54 <mcstar> if you can use a byte instead of 4/8 it matters, if you have much data
14:19:56 <chris2> pair word and boot :P
14:19:57 <mcstar> but i dont have
14:20:08 <chris2> *bool
14:20:10 <mcstar> anyway, it would make a significant reduction in runtime
14:20:17 <mcstar> wouldnt****
14:20:26 <jix> data-dword defines WordN for N > 64
14:20:27 <rwbarton> i expect it would make a large difference
14:20:33 <mcstar> no
14:20:39 <hiptobecubic> write it to disk a string of 1's and 0's in ascii
14:20:42 <hiptobecubic> as a*
14:21:00 <mcstar> and before you say, that i should store my dense hashmap entries in a vector, i tried that
14:21:06 <mcstar> it doesnt make it faster
14:21:08 <hiptobecubic> or make 65 files, each with a 1 or 0 in them
14:21:28 <mcstar> i mean the constants, row_to_col,row_to_col_to_row, and col_to_row
14:21:38 <jonkri> can i use http://hackage.haskell.org/packages/archive/SMTPClient/1.0.4/doc/html/Network-SMTP-Simple.html to add optional e-mail headers?
14:21:48 <jonkri> are they perhaps part of the body?
14:21:53 <jonkri> sorry for the off-topic question, btw
14:24:50 <typoclass> jonkri: i don't know that package, but presumable if there's an SMTP.Simple module there'l be some other module where you can do more stuff and modify headers
14:25:10 <typoclass> jonkri: afaik headers and body are separated by a blank line, so it wouldn't help to put headers in the body
14:28:58 <Janthinidae> I like to write a simple compiler in Haskell without using Parsec. I've already written a lexer a now like to write a recursive descent parser. My grammar (expr -> e | X expr | Y expr Z expr) is quite simple but I'm currently somewhat stucks how to implement it as simple as possible (avoiding monads at the moment). I like to build a tree, while at the same time I have to maintain which tokens I've already consumed. Any hints or good
14:28:58 <Janthinidae> examples?
14:30:43 <stepcut> Janthinidae: why not use haskell-src-exts to do the parsing for you?
14:30:43 <c_wraith> You'll have to track the current input manually.
14:31:04 <stepcut> Janthinidae: parsing haskell is annoyingly difficult (though not anywhere as bad as C++)
14:31:10 <c_wraith> stepcut: he said "a compiler in haskell", not "a haskell compiler"
14:31:18 <stepcut> ah..
14:31:21 <rwbarton> expr -> e | X expr | Y expr Z expr is not the syntax of haskell :)
14:31:28 <c_wraith> You'll have to thread the state through all of the parsing functions manually.
14:31:33 * stepcut blames it on the dayquil
14:31:38 <c_wraith> it will need to be an extra argument to all the functions
14:31:47 <c_wraith> and it will need to be part of the return value from each function
14:32:03 <Kyraimion> @unmtl State a
14:32:04 <lambdabot> Plugin `unmtl' failed with: `State a' is not applied to enough arguments, giving `/\A. a -> (A, a)'
14:32:09 <c_wraith> There are patterns to simplify such tracking.  You've unfortunately rejected all of them already
14:32:11 <Kyraimion> @unmtl State  s a
14:32:11 <lambdabot> s -> (a, s)
14:32:59 <ski> Janthinidae : `parseExpr :: [Token] -> Maybe (Expr,[Token])' ?
14:35:07 <mizu_no_oto> A parser for Things is a function from Strings to Lists of Pairs of Things and Strings!
14:35:15 <mizu_no_oto> http://www.willamette.edu/~fruehr/haskell/seuss.html
14:36:02 <imperative_coder> ^^
14:36:10 <pordan30> if you want to avoid monadic parsing, other standard options are applicative and arrow based parsing. there is a paper by sweistra and duponcheel called "deterministic combinator parsers" that if i recall correctly builds a parser combinator library for ll(1) grammars using applicatives
14:37:07 <imperative_coder> what does applicative mean?
14:37:37 <mizu_no_oto> imperative_coder: are you familiar with Functors?
14:37:57 <mizu_no_oto> applicative means applicative functor
14:37:58 <imperative_coder> nope
14:38:42 <Janthinidae> Thanks for all the notes. I was already on the [Token] -> [(Token,Node)] approach, seems I'll follow that. (It's my Hello World app, so I'll try to stick to the basics for the moment)
14:38:50 <mizu_no_oto> So a functor is some data type which has a map function:  Functor f => (a -> b) -> (f a -> f b)
14:39:26 <Kyraimion> imperative_coder:  Do you know how type classes work?
14:39:47 <mizu_no_oto> For example, (a -> b) -> ([a] -> [b]), or (a->b) -> (Tree a -> Tree b) or (a -> b) -> ( IO a -> IO b)
14:40:43 <mizu_no_oto> Usually, a functor is either a data structure, or it's a computation inside a certain context, like IO or State
14:41:44 <sclv_> @remember spj "Our imperative colleagues do a lot of reasoning about their systems. Well, they have to."
14:41:44 <lambdabot> I will remember.
14:42:06 <mizu_no_oto> In the computation sense, it lets you get to the current value in the computation and transform it.  In the data structure sense, it lets you transform every element of the dat structure.
14:42:10 <ski> > map (map (^ 2)) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
14:42:11 <lambdabot>   [[],[0],[1,4],[9,16,25],[36,49,64,81]]
14:42:16 <ski> > fmap (fmap (^ 2)) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
14:42:17 <lambdabot>   [[],[0],[1,4],[9,16,25],[36,49,64,81]]
14:42:40 <ski> > fmap (fmap (^ 2)) [Nothing,Just 1,Nothing,Just 3,Just 4]
14:42:41 <lambdabot>   [Nothing,Just 1,Nothing,Just 9,Just 16]
14:42:51 <mizu_no_oto> imperative_coder: http://www.haskell.org/haskellwiki/Typeclassopedia
14:42:53 <ski> > fmap (fmap (^ 2)) (Just [0,1,2])
14:42:54 <lambdabot>   Just [0,1,4]
14:43:05 <ski> imperative_coder : do you understand those examples ?
14:43:07 <shachaf> > fmap fmap fmap  (^2) [Nothing,Just 1,Nothing,Just 3,Just 4]
14:43:09 <lambdabot>   [Nothing,Just 1,Nothing,Just 9,Just 16]
14:43:53 <shachaf> > fmap fmap fmap fmap fmap fmap fmap join (*) [Nothing,Just 1,Nothing,Just 3,Just 4]
14:43:54 <lambdabot>   [Nothing,Just 1,Nothing,Just 9,Just 16]
14:43:57 <ski> @src [] fmap
14:43:57 <lambdabot> fmap = map
14:43:58 <ski> @src Maybe fmap
14:43:59 <lambdabot> fmap _ Nothing       = Nothing
14:43:59 <lambdabot> fmap f (Just a)      = Just (f a)
14:44:05 <Ferdirand> > (.).(.) (^2) [Nothing, Just 1, Just 2]
14:44:06 <lambdabot>   Couldn't match expected type `a -> b'
14:44:06 <lambdabot>         against inferred type `Data.M...
14:44:19 <Ferdirand> argh
14:44:25 <shachaf> Sorry. :-(
14:44:25 <ski> > (^ 2) .: [Nothing, Just 1, Just 2]  -- itym
14:44:27 <lambdabot>   [Nothing,Just 1,Just 4]
14:50:24 <Peaker> I've got a 2-pass process I compose from lots of 2-pass pieces. I represent the 2 passes as two monads like:   pass1 (pass2 a)
14:50:42 <Peaker> Sometimes I want to treat the 2 passes composed as an Applicative like (:.) does
14:51:04 <Peaker> but sometimes I want to use the monad instance of pass1 regardless of pass2.. not sure how I can have both worlds
14:51:45 <Peaker> maybe a func like:  ((pass1 :. pass2) a -> (pass1 :. pass2) b) -> pass1 (pass2 a) -> pass1 (pass2 b)
14:52:07 <Peaker> so that I can do:  thatFunc sequenceA $ my2passComputation
14:52:21 <Peaker> anyone encountered anything similar?
15:02:16 <Hermit> I've been wondering for a while now: when declaring a function in terms of a function composition, the inferred type is much less general than when using an explicit argument?
15:02:43 <Hermit> eg:  function1 x = sum $ map (+1) x    gets    :: Num a => [a] -> a
15:03:02 <Hermit> while function2 = sum . map (+1)    gets    [Integer] -> Integer
15:03:05 <shachaf> Hermit: See "the monomorphism restriction".
15:03:09 <shachaf> @where dmr
15:03:10 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
15:03:15 <ParahSail1n> @ty sum $ map (+1) x gets
15:03:17 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
15:03:17 <lambdabot>     In the second argument of `map', namely `x'
15:03:17 <lambdabot>     In the second argument of `($)', namely `map (+ 1) x gets'
15:03:40 <shachaf> It's a bit of an ugly corner case of the language, but it has *some* justification.
15:03:40 <typoclass> Hermit: use moar {-# LANGUAGE NoMonomorphismRestriction #-}
15:03:41 <Kyraimion> Hermit:  You can either add an explicit type annotation or compile with -XNoMonomorphismRestriction
15:04:26 <typoclass> does hermit's case cause one of those "has defaulted to Integer" warnings that you get with -Wall?
15:04:29 <Hermit> schlaftier: I know, this has to do with the monomorphism restriction, but such restriction only makes sense for polymorphic values. In this case, the monomorphic restriction triggers an error due to this not-so-general inferred type
15:04:56 <shachaf> Hermit: What?
15:05:37 <Hermit> s/monomorphic restriction/compiler/2
15:06:03 <Peaker> Hermit, your function is polymorphic, not monomorphic
15:06:14 <Hermit> Peaker: only function1
15:06:17 <Peaker> Hermit, not-so-general <- monomorphic
15:06:18 <typoclass> Hermit: yeah, Num a => a -> a is a polymorphic (not monomorphic type)
15:06:29 <shachaf> Hermit: The monomorphism restriction is what's restricting function2 to be monomorphic. :-)
15:06:42 <Peaker> Hermit, function2 is supposed to be polymorphic, the MR is making it monomorphic
15:06:43 <shachaf> If you used NoMonomorphismRestriction, it would get the same type.
15:07:01 <shachaf> Similarly, if you eta-expanded it to function1 x = (sum . map (+1)) x
15:07:11 <Hermit> so, the question here is: if function1 and function2 are the same thing, why do they get different types? I can avoid the error putting an explicit type signature
15:07:25 <shachaf> Hermit: The answer is still the monomorphism restriction. :-)
15:07:29 <rwbarton> and the question was answered: due to the monomorphism restriction
15:07:29 <Peaker> Hermit, because they thought it would confuse if   x <no args> =    would be polymorphic and recompute for each type despite being assigned to a single name
15:07:32 <shachaf> Did you look at the wiki link?
15:07:41 <Peaker> instead, everybody is confused about this weird special case
15:08:16 <Peaker> law of unintended consequences
15:08:19 <typoclass> "The definition of the restriction is fairly technical, but to a first approximation it means that you often cannot overload a function unless you provide an explicit type signature." <- we overload functions now?
15:08:35 <shachaf> typoclass: Maybe that could be improved.
15:08:52 <Peaker> the full definition is not that hard to describe, I think
15:09:11 <Kyraimion> "It makes your code not compile for no good reason"
15:09:24 <typoclass> Peaker: no, wiki says it's "fairly technical" :-) lemme just change that to "fairly technical and badass"
15:09:42 <rwbarton> this has nothing to do with composition, btw. function1 = \x -> sum $ map (+1) x ; function2 x = (sum . map (+1)) x -- now the types are reversed
15:10:19 <Peaker> How about "A value whose type contains constrained type variables, and is also defined without parameters on its left hand side" ?
15:10:24 <typoclass> shachaf: don't look at me. i kinda know that for *this* kind of error message you turn off the DMR and things are peachy, but i couldn't put it into words i think
15:10:52 <typoclass> Peaker: interesting, do they need to be constrained? didn't know that
15:10:58 <Hermit> Peaker: what you mentioned about the function recomputing, wouldn't that happen only if the result were polymorphic? (I mean stuff like  genericLength something :: Int, genericLength something :: Double)
15:11:08 <shachaf> typoclass: foo = id works fine.
15:11:16 <rwbarton> if the types are not constrained there is no dictionary to pass
15:11:26 <rwbarton> alternatively: the definition works uniformly for all types
15:11:27 <shachaf> rwbarton: You still pass the type in, though!
15:11:37 <typoclass> shachaf: hmm
15:11:38 <shachaf> That's totally an argument.
15:11:59 <Kyraimion> Hermit:  "Num a => [a] -> a" is polymorphic
15:13:39 <typoclass> Peaker: i think a very clear explanation is f1 and f4 and f5 taken together
15:16:11 <Hermit> I've read about the monomorphism restriction, and it only makes sense to me in cases where a same value is used in different contexts, to avoid undesired specialization and recomputation. But it still doesn't make sense why should function1 and function2's inferred type differ.
15:16:54 <Hermit> (makes sense in the genericLength example posted in the wiki)
15:18:40 <rwbarton> if you use your function2 at any one particular type in your program, it will have that type inferred
15:18:54 <rwbarton> if you use it at more than one type, you will get a type error
15:19:11 <rwbarton> if you use it nowhere, then GHC will assign it a type through defaulting
15:19:25 <rwbarton> (or if you use it at an underspecified type)
15:19:53 <shachaf> Or it won't, presumably.
15:20:04 <rwbarton> well, I mean if you ask for the type
15:20:09 <rwbarton> in ghci
15:20:23 <Hermit> rwbarton: that's the behavior I've seen, but I'm still unaware of the reason why the MR will let function1 be polymorphic and not function2
15:20:29 <Hermit> being the same thing...
15:20:44 <rwbarton> did you read what the MR is?
15:20:52 <rwbarton> it applies to bindings that are not function bindings
15:21:09 <rwbarton> meaning they are not of the form f x [x' ...] = ...
15:21:16 <Hermit> I thought function2 was a function binding
15:21:23 <Hermit> I see
15:21:35 * shachaf wonders whether the MR makes sense for something that has a function type.
15:21:45 <Hermit> schlaftier: I second that
15:21:51 <rwbarton> sure, it can still have the form let blah = foo in ...
15:21:57 <rwbarton> let blah = foo in \x -> ...
15:22:26 <shachaf> It can, but that seems like a special enough case that you'd know what you're doing.
15:23:06 <rwbarton> or it could be something involving a memoizer
15:23:09 <rwbarton> that would be bad!
15:23:17 <shachaf> I guess.
15:23:36 <shachaf> Do polymorphic memoizers work?
15:25:14 <rwbarton> you can't write a memoizer for (forall a. Integral a => a -> a) but you can write one that can be applied to (a -> a) for any a that is Integral
15:25:22 <Hermit> MR should only apply to bindings whose type are not functions. This would prevent undesired recalculations due to unintended specialization of values/results, and stop bothering the programmer with useless errors.
15:26:33 <Hermit> right?
15:26:42 <shachaf> Not really.
15:26:46 <Hermit> why
15:26:49 * hackagebot perm 0.3.0.0 - permutation Applicative and Monad with many mtl instances  http://hackage.haskell.org/package/perm-0.3.0.0 (AndySonnenburg)
15:26:51 <ski> sometimes you want to cache the computation of a function
15:26:58 <rwbarton> there's no logical basis for that
15:27:01 <maukd> Hermit: how do you determine what's a function?
15:27:10 <rwbarton> also yeah, you may not know whether something is a function
15:27:17 <rwbarton> x :: MonadIO m => m Int
15:27:26 <Hermit> maukd: that's the compiler job. And it already does it pretty well...
15:27:33 <rwbarton> or better x :: Monad m => m Int
15:27:37 <maukd> Hermit: no, it doesn't
15:27:38 <rwbarton> is x a function
15:27:55 <maukd> Hermit: consider foo :: (Bar a) => a
15:28:33 <rwbarton> or if I wrap a function in a newtype, is it suddenly no longer a "function"?
15:29:15 <Hermit> sorry, I still haven't got to monads.. =/  I have a long way to go still, so I'll bury the argument.
15:29:45 <shachaf> The argument doesn't have much to do with monads.
15:29:49 <rwbarton> no
15:29:50 <shachaf> @arr gument
15:29:50 <lambdabot> I'll keel haul ya fer that!
15:30:03 <shachaf> @yarr gument
15:30:03 <lambdabot> Yo ho ho, and a bottle of rum!
15:30:06 <maukd> :t pi
15:30:08 <lambdabot> forall a. (Floating a) => a
15:30:14 <maukd> Hermit: consider pi :: (Floating a) => a
15:30:16 <maukd> is this a function?
15:30:26 <Hermit> maukd: no
15:30:31 <maukd> > pi ()
15:30:33 <lambdabot>   3.141592653589793
15:30:40 <Hermit> it's a hack...
15:30:42 <maukd> where is your god now?
15:30:47 <Hermit> it's a hack...
15:30:56 <Hermit> damned hack, same as unsafePerformIO
15:30:59 <maukd> > pi "this is not a hack" "dude"
15:31:00 <rwbarton> wut
15:31:00 <lambdabot>   3.141592653589793
15:31:19 <Hermit> err
15:31:31 <Hermit> disregard what I just said, pi is indeed a function
15:31:39 <Hermit> couldn't be polymorphic otherwise
15:31:53 <rwbarton> ...?
15:31:58 <rwbarton> lots of polymorphic things aren't functions
15:32:03 <Hermit> D:
15:32:05 <rwbarton> :t []
15:32:06 <lambdabot> forall a. [a]
15:32:09 <rwbarton> polymorphic
15:32:11 <typoclass> Hermit: no, values are also polymorphic in haskell, n0t just functions
15:32:12 <rwbarton> > [] 'x'
15:32:13 <lambdabot>   Couldn't match expected type `GHC.Types.Char -> t'
15:32:13 <lambdabot>         against inferred...
15:32:15 <rwbarton> not a function
15:32:16 <typoclass> > minBound ::Int
15:32:18 <lambdabot>   -9223372036854775808
15:32:22 <typoclass> ^^ example
15:32:48 <typoclass> > minBound :: Char
15:32:49 <lambdabot>   '\NUL'
15:32:58 <Hermit> holly...
15:33:21 <johnw> joeyh: ping
15:33:48 <typoclass> @src Bounded
15:33:48 <lambdabot> class  Bounded a  where
15:33:49 <lambdabot>     minBound, maxBound :: a
15:33:53 <Hermit> it's making sense now why the MR works the way it does
15:34:26 <Hermit> not easy at all to know if something is a function or not
15:34:37 <Hermit> is it even possible?
15:34:57 <maukd> haha
15:34:57 <typoclass> Hermit: ^^ this is how it's implemented. that typeclass, and it has several instances (e.g. instance Bounded Int where minBound = -9223...)
15:36:57 <Hermit> typoclass: I see
15:37:02 <typoclass> Hermit: in haskell, it really doesn't make much difference if something is a function or a value. for example you can pass functions around with no problem
15:37:46 <typoclass> Hermit: but normally, just look for any "->" in the type signature. "a -> a" is a function (1 argument), "a" has 0 arguments and therefore is not a function
15:39:37 <ski> (s/is a function/is a function type/)
15:40:09 <rwbarton> asking whether 'a' is a function is like asking whether 'n' is odd or even
15:40:51 <Hermit> right
15:41:05 <Hermit> all this discussion confused me a bit regarding functions
15:41:10 <Hermit> pi is NOT a function
15:41:17 <Hermit> right?
15:41:22 <shachaf> @ty id `asTypeIn` (\i -> i id id id id id id id id id id id)
15:41:24 <lambdabot> forall a. (((((((((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a
15:41:26 <lambdabot> -> a) -> ((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) ->
15:41:28 <lambdabot>  (((((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((((a
15:41:30 <lambdabot> -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((((((a -> a)
15:41:31 <Hermit> holly...
15:41:32 <lambdabot> -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> (((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((a -> a) -> a -> a) -> (a -> a) -> a -> a) -> ((((a -> a) -> a ->
15:41:34 <lambdabot> [119 @more lines]
15:41:54 <Earnestly> Haskell o/
15:42:00 <ciaranm> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:42:02 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59. a -> b ->
15:42:02 <lambdabot> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 -> t38 ->
15:42:02 <lambdabot> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q,
15:42:02 <lambdabot> r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59)
15:42:14 <shachaf> ciaranm: Pft. Mine is exponential and yours is linear.
15:42:16 <typoclass> Hermit: no, you can ignore that, he was playing a prank on you. there's some funky things turned on in lambdabot which allow the "pi x" thing. in normal haskell it's not allowed
15:42:28 <thoughtpolice> Hermit: no, but you don't know what instances of Fractional might exist, which is why you can do that, same with Monad. you can't say if "x :: Monad m => m Int" for example 'is a function or not' like rwbarton said, because it depends on the underlying monad.
15:42:29 <rwbarton> it is allowed
15:42:38 <shachaf> typoclass: No, maukd had a good point which he was demonstrating using a slightly silly feature of lambdabot.
15:42:40 <rwbarton> because you are allowed to write that instance
15:42:46 <Hermit> ¬¬ @ maukd
15:42:48 <shachaf> But the point applies in any Haskell code.
15:42:59 <thoughtpolice> if the 'm' you are using is the ((->) r) instance of monad, then you could say 'x 123' and 'x' is a function
15:43:07 <maukd> typoclass: lambdabot is normal haskell
15:43:15 <thoughtpolice> and you could write an instance of Fractional ((->) r) too
15:43:21 <crdueck> i have a list of functions [a -> b] and [a]. I want to apply the first function to the first a in [a], the second function to the second a in [a] and etc. I thought (<*>) was the answer, but it applies each function to every a in [a]
15:43:26 <Hermit> maukd: I tried the pi thing on ghci, and it errors
15:43:30 <shachaf> crdueck: sequence?
15:43:33 <ciaranm> > (*2) . [1, 2, 3]
15:43:34 <shachaf> Oh, no.
15:43:35 <lambdabot>   [2,4,6]
15:43:36 <shachaf> zipWith id
15:43:38 <ciaranm> not normal!
15:43:42 <rwbarton> aka zipWith ($)
15:43:47 <shachaf> monochrom: Sorry. :-(
15:43:54 * shachaf gets 0/10 again.
15:43:58 <maukd> Hermit: you need to import Data.NumInstances
15:44:11 <maukd> which is in NumInstances
15:44:28 <thoughtpolice> Hermit: lambdabot just has a lot of extra instances for the standard typeclasses out there, so it allows you to do some things you can't in regular GHCi, without some supporting code, which you could write yourself or re-use
15:44:39 <typoclass> shachaf: i dunno, i didn't get how pi x was related to his question if pi is a function or not, and (Floating a) => a, etc.
15:44:51 <maukd> ...
15:44:55 <shachaf> typoclass: mauke's point is that you can't know whether something is a function or not.
15:44:58 <shachaf> "pi" is incidental.
15:45:11 <shachaf> Also: data CReal = Data.Number.CReal.CR (Int -> Integer)
15:45:17 <shachaf> Is pi :: CReal a function? :-)
15:45:37 <Nereid> no, it's a data
15:45:51 <typoclass> shachaf: right, i see. i already pointed out to him that it's kind of unnecessary to ask that in haskell
15:45:55 <Nereid> better example would be numinstances
15:46:05 <maukd> Nereid: ...
15:46:16 <shachaf> typoclass: Yes, but maukd pointed it out with some concrete examples.
15:46:17 <Nereid> :V
15:46:28 <Nereid> > pi "hello"
15:46:28 <shachaf> Nereid: Read up a little bit.
15:46:29 <lambdabot>   3.141592653589793
15:46:35 <Nereid> :v
15:46:36 * shachaf sighs.
15:46:45 <typoclass> shachaf: yes, but you kids these days with your concrete examples are confusing me
15:46:55 <wilfredh> I've done `cabal install hunit` but doing `import HUnit` from ghci doesn't change the prompt and doesn't bring any HUnit things into scope. What am I doing wrong?
15:46:56 <Nereid> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:46:57 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
15:46:57 <typoclass> also with your Num instances
15:46:57 <lambdabot> t63. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 ->
15:46:57 <lambdabot> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> (a, b, c,
15:46:57 <lambdabot> d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53,
15:46:57 <lambdabot> t54, t55, t56, t57, t58, t59, t60, t61, t62, t63)
15:47:00 <Nereid> oh.
15:47:45 <Nereid> how come lambdabot is ok with huge tuples? :C
15:47:59 <shachaf> wilfredh: Test.HUnit?
15:48:00 <wilfredh> I can do `ghci -package HUnit` which says it's loaded HUnit, but I still can't import it
15:48:02 <crdueck> shachaf: i dont think sequence is what i want. that ends up being [a -> b] -> a -> [b] instead of [a -> b] -> [a] -> [b]
15:48:02 <rwbarton> that looks like a mere 62-tuple
15:48:10 <rwbarton> > length ",,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)"
15:48:11 <lambdabot>   62
15:48:14 <shachaf> sixty-twople
15:48:20 <rwbarton> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:48:21 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
15:48:21 <lambdabot> t63 t64 t65. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 ->
15:48:21 <lambdabot> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 ->
15:48:21 <lambdabot> t64 -> t65 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44, t45, t46, t47, t48,
15:48:21 <lambdabot> t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65)
15:48:24 <rwbarton> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
15:48:25 <lambdabot> forall a b c d e f g h i j k l m n o p q r s t u v w x y z t28 t29 t30 t31 t32 t33 t34 t35 t36 t37 t38 t39 t40 t41 t42 t43 t44 t45 t46 t47 t48 t49 t50 t51 t52 t53 t54 t55 t56 t57 t58 t59 t60 t61 t62
15:48:25 <lambdabot> t63 t64 t65 t66 t67. a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 ->
15:48:27 <lambdabot>  t35 -> t36 -> t37 -> t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 ->
15:48:29 <lambdabot> t63 -> t64 -> t65 -> t66 -> t67 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39, t40, t41, t42, t43, t44,
15:48:31 <lambdabot> t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67)
15:48:35 <shachaf> More, more, I'm still not satisfied!
15:48:42 <rwbarton> something about ghc automatically making more tuple types
15:48:44 <typoclass> guys, could we please wrap up the lambdabot spam ... thanks
15:48:56 <Hermit> would you all quit spamming with lambdabot?
15:49:07 <rwbarton> would you all quit spamming about spamming :P
15:49:18 <wilfredh> shachaf: bingo! Thanks. The docs just say `import HUnit` which threw me off.
15:49:34 <typoclass> wilfredh: oh, seems like a bug in the documentation then
15:51:15 <Kyraimion> cabal-dev ghci gives me "cabal: ghcInvocation: the programVersion must not be Nothing", is this a cabal-dev bug or am I doing something wrong?
15:51:50 * hackagebot aws 0.7.4 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.4 (AristidBreitkreuz)
15:54:14 <fmap> Kyraimion: cabal-install version?
15:54:42 <fmap> cabal-dev ghci doesn't work for me with cabal-install-1.16
15:54:48 <Kyraimion> fmap:  1.16.0
15:54:48 <typoclass> Kyraimion: not sure. you could look at the source code of cabal-dev and track down where that error message is produced. you can get the source code by doing "cabal unpack cabal-dev"
15:57:07 <fmap> Kyraimion: not sure if it's cabal-install or cabal-dev fault; i'm using cabal-install-1.14 with ghc-7.6.1, works fine
15:57:10 <raek> is it possible to write a data type that stores a description of an I/O action? I'm thinking about something like "data MyIO ___ = Return ___ | Bind ___ | GetLine ___ | PutStrLn ___"
15:57:20 <ezyang> raek: Sure!
15:57:28 <ezyang> Try looking up the "prompt monad"
15:57:39 <shachaf> @google r6.ca free io
15:57:40 <lambdabot> http://r6.ca/blog/20110520T220201Z.html
15:57:50 <Kyraimion> fmap:  Everything else works, it's just cabal-dev ghci that breaks
15:58:27 <raek> ezyang: shachaf: thanks for the pointers!
16:15:42 <Nereid> so guys.
16:15:58 <Nereid> snap or yesod? (or is there some other cool thing I haven't heard of)
16:16:11 <stepcut> happstack, of course
16:16:18 <Nereid> hmm, let's read a little about both.
16:16:31 <Nereid> I thought happstack was old and not preferred for new things.
16:16:54 <kirindave> I have a question about the functor laws.
16:16:58 <kirindave> Let's say I have a zipper-like context.
16:17:05 <kirindave> Context past present future.
16:17:24 <kirindave> Is Context still a functor if fmap only affects the future?
16:17:36 <kirindave> I don't see how it breaks the laws.
16:17:37 <stepcut> Nereid: it is the oldest, but it is still under active development
16:17:44 <kirindave> But I've just never seen an instance like that.
16:17:57 <rwbarton> if you try to write an instance like that you will see that it does not type check
16:18:02 <stepcut> Nereid: in fact, I am currently working on fay integeration, and a pipes based http backend for happstack, so..
16:18:46 <kirindave> rwbarton: I thought it did if the types of past, present and future were all the same.
16:18:59 <rwbarton> how about a simpler example
16:19:21 <rwbarton> or a more precisely-defined one
16:19:44 <rwbarton> "fmap" that only affects elements of a list after the first, is that the sort of thing you have in mind?
16:20:26 <Nereid> rwbarton: if fmap only changes the future, what does fmap f do if f :: a -> b?
16:20:30 <Nereid> (and a and b are different types)
16:20:41 <rwbarton> of course
16:20:44 <rwbarton> this is my point
16:20:48 <Nereid> oops, that was directed at kirindave
16:20:51 <rwbarton> ah ok
16:22:00 <kirindave> Nereid: This assumes that the Context exposes the types of the other two things, tho?
16:22:16 <Nereid> it's not clear to me what Context actually is.
16:22:24 <kirindave> Call it QQ if you like.
16:22:29 <Nereid> you have different types for past, present, and future?
16:22:38 <kirindave> I'm just curious if there are valid functors that describe history.
16:23:04 <Nereid> calling it something else doesn't tell me what it is.
16:23:11 <kirindave> Nereid: It is not a thing.
16:23:18 <rwbarton> is there a valid Haskell program that describes history?
16:23:25 <rwbarton> this isn't anything meaningful
16:23:30 <kirindave> rwbarton: A stack I guess.
16:24:32 <kirindave> The original question came because satisifying rule for Comonads requires that a ting is a functor. And I was curious if a comonad could represent the state of something along a timeline.
16:25:45 <kirindave> But I guess not.
16:25:53 <rwbarton> I don't understand
16:25:58 <Nereid> me either
16:25:59 <kirindave> That's okay, neither do I.
16:26:22 <rwbarton> let's take "the temperature outside my house in degrees F", is that a thing that has a "history"?
16:26:46 <rwbarton> I can "represent" it by Time -> DegreesF where Time = Double; DegreesF = Double
16:27:05 <kirindave> Well there is this notion of new information, i guess.
16:27:11 <rwbarton> if I want to convert to degrees C I can fmap over that with fToC
16:27:24 <rwbarton> because ((->) Time) is a functor
16:27:32 <rwbarton> no idea whether that has anything to do with what you are asking though!
16:27:38 <kirindave> rwbarton: But that changes the entire view of your history.
16:27:44 <rwbarton> well
16:27:46 <kirindave> What if there are _new_ rules
16:27:52 <rwbarton> I would say that I am looking at the history of a different (but related) thing
16:27:54 <kirindave> And those rules do NOT apply to the past.
16:28:10 <rwbarton> the "temperature outside my house in degrees C"
16:28:16 <kirindave> Like you're modeling a game of Magic (dat Gathering)
16:28:30 <kirindave> And there are new rules by which to evaluate cards past certain inflection points
16:28:43 <kirindave> But your previous representation of the game should not change.
16:28:53 <kirindave> And indeed you should be able to rewind and then replay from a different point.
16:29:06 <kirindave> This feels like a zipper to me, but I'm not sure how it'd typecheck ever.
16:29:11 <rwbarton> meh
16:29:13 <rwbarton> functor is just a technical thing
16:29:22 <rwbarton> write down some types if you want to know whether something is a functor :)
16:29:36 <rwbarton> there is no magic "intention" that relates comonads to history or anything
16:29:39 <kirindave> I only care because there are other instances that I'd love to apply
16:29:44 <rwbarton> these category notions are just tools that exist
16:29:45 <kirindave> You may recall I've been trying to play with comonads.
16:29:49 <kirindave> And I'm like, "Oh wait..."
16:29:56 <kirindave> "Can't write that. Am I missing something?"
16:30:23 <rwbarton> if you write down a comonad it will be a functor too but that doesn't mean that fmap is anything you're particularly interested in
16:30:29 <rwbarton> let alone a particular thing you are interested in
16:30:35 <rwbarton> you can still do other things with the comonad
16:31:15 <nicoo> kirindave: Modeling formal rules of Magic is fun; actually checking whether a move is valid is NP-hard :°(
16:31:16 <kirindave> I have been told sternly not to break them rules.
16:31:50 <kirindave> But I guess uh, if Context hides the types for everything but future.
16:31:55 <kirindave> Then it'd typecheck!
16:32:09 <rwbarton> my point is this whatever changing-rules function can still exist... it just won't be fmap
16:32:12 <rwbarton> and that's okay...
16:32:15 <kirindave> Yeah.
16:33:50 <rwbarton> or you can have something parameterized by several type variables
16:33:52 <rwbarton> e.g. (,)
16:34:19 <rwbarton> if you think of a pair as (past,future) (whatever that means) then fmap for (,) already only "affects the future"
16:34:23 <rwbarton> (whatever that means)
16:36:23 <kirindave> I suppose.
16:36:31 <kirindave> But you can see the allure of a one-hole context there.
16:43:16 <rwbarton> for those who lack the willpower to not press _ ?
16:43:19 <rwbarton> oh
16:46:14 <kirindave> Huh
16:50:54 <kirindave> Haha, maybe this truly is ill conceived.
16:51:16 <kirindave> I can make this work, but what I am doing is wicked.
16:52:39 <ew0> hey
16:52:47 <kirindave> rwbarton: https://gist.github.com/468ca06c9e94c41557ff
16:52:56 <ew0> I'm getting a stack space overflow when I run my program with -O2
16:52:58 <kirindave> rwbarton: In which I take a pile of garbage and mash it to make garbage paste.
16:53:04 <ew0> but when I run it with runghc, it runs fine
16:53:07 <ew0> xD
16:53:12 <rwbarton> hehe
16:53:50 <kirindave> rwbarton: The problem is that it'd have to carry a bunch of other functions to be usable as a zipper, and making those would be tedious.
16:54:08 <rwbarton> well if the future is a different type than the present, how do you "zip" it into the future
16:54:11 <rwbarton> or the past
16:54:12 <kirindave> Right
16:54:14 <rwbarton> unless you get lucky, and a = b
16:54:22 <kirindave> You _could_ do that.
16:54:31 <kirindave> It's not like the comonad laws know about "left" and "right"
16:54:41 <kirindave> Or "up" and "down"
16:54:44 <kirindave> They're domain specific.
16:55:33 <kirindave> But I've convinced myself that it's a bad plan.
16:56:17 <ew0> in my experience the past repeats itself
16:56:41 <kirindave> ew0: In your immediate experience, that happens on the stack. :)
16:56:45 <ew0> so you would do fine with a  repeat past
16:56:57 <ew0> ow yeah
16:57:21 <kirindave> I'd better eat and get over to this edwardk talk!
16:57:56 <edwardk> man so should i i'm looking forward to hearing him speak!
16:58:07 <johnw> lol
16:58:32 <MostAwesomeDude> Clearly I should have gone to the mentor summit this year.
16:59:45 <johnw> edwardk: videos links, stat!
17:00:04 <edwardk> johnw: afraid no video for this version, maybe the next one
17:00:09 <johnw> gah
17:00:43 <edwardk> et the new york guys to figure out a venue and i'll do a version down there and record it
17:01:11 <Hermit> @ty pi ()
17:01:12 <lambdabot> forall t. (Floating (() -> t)) => t
17:01:22 <Hermit> I _knew_ it!
17:01:33 <johnw> huh?
17:01:36 <johnw> :t pi
17:01:37 <lambdabot> forall a. (Floating a) => a
17:04:46 <jonkri> when i try to "cabal configure" my project, i get an error saying: Warning: This package indirectly depends on multiple versions of the same package. This is highly likely to cause a compile failure. package happstack-server-7.0.4 requires base64-bytestring-0.1.2.0, package pontarius-xmpp-0.1.0.0 requires base64-bytestring-1.0.0.0.
17:05:00 <jonkri> the thing here is that pontarius-xmpp depends on base64-bytestring -any, so i don't understand
17:05:23 <dcoutts> jonkri: cabal configure does not reinstall things to make them all consistent
17:05:47 <stepcut> jonkri: when pontarius-xmpp was first installed it was probably built against the older base64-bytestring
17:05:51 <dcoutts> jonkri: to force them to be consistent, try: cabal install --only-dependencies --dry-run
17:07:02 <stepcut> jonkri: backing up, do you already have pontarious-xmpp or happstack-server installed ?
17:07:21 <hpaste> jonkri pasted “dependency problems” at http://hpaste.org/76468
17:07:32 <jonkri> dcoutts: http://hpaste.org/76468
17:07:49 <jonkri> stepcut: i see
17:11:27 <dcoutts> jonkri: that looks fairly clear, happstack-server-7.0.7 needs libs that need a later version of base than what you have
17:13:05 <jonkri> dcoutts: i have a newer version of base, there's something wrong with cabal. ~/.cabal/bin is in my path. anyway, thanks
17:13:37 <dcoutts> jonkri: what does ghc-pkg list base say?
17:13:51 <stepcut> jonki: i often times just unregister packages until it is happy ;)
17:14:33 <jonkri> dcoutts: base-4.3.1.0
17:14:48 <dcoutts> jonkri: ok, so cabal is finding the right version
17:15:04 <jonkri> what does that mean? :)
17:15:13 <dcoutts> jonkri: so you'll want to stick with happstack-server-7.0.4
17:15:56 <Kyraimion> jonkri:  You need to upgrade ghc
17:16:07 <dcoutts> no, I don't think that's necessary
17:16:16 <dcoutts> it should work with the older happstack-server
17:16:25 <Kyraimion> dcoutts:  That doesn't work, because base64-bytestring is upper-bound bt happstack-server-7.0.4
17:16:39 <dcoutts> yeah that's fine
17:16:51 <Kyraimion> dcoutts:  and another packacge demands a higher minimum version
17:16:56 <dcoutts> which?
17:17:37 <Kyraimion> pontarius
17:17:54 <dcoutts> Kyraimion: no it has no constraint on base64-bytestring
17:17:59 <dcoutts> jonkri: try --constraint='happstack-server==7.0.4' --constraint='base64-bytestring < 1'
17:18:09 <Kyraimion> dcoutts:  He's working with an unreleased version
17:18:27 <dcoutts> oh, that does change things
17:19:19 <dcoutts> oh yes, a really old version
17:19:43 <jonkri> yeah
17:19:49 <jonkri> i'm working with https://github.com/jonkri/pontarius-xmpp
17:20:06 <Kyraimion> jonkri:  OTOH pontarius doesn't have a direct constraint on base64-bytestring either
17:20:15 <Kyraimion> I don't know whether one of it's dependencies has
17:20:26 <dcoutts> jonkri: so you need to let cabal reinstall pontarius-xmpp, so that it can make the deps consistent
17:21:04 <dcoutts> jonkri: so if you've got that as a local build tree, you need to do something like: cabal install ./ ../pontarius-xmpp --dry
17:21:50 <dcoutts> jonkri: if it rebuilds pontarius-xmpp then it can build it against a different base64-bytestring, which was the source of the conflict
17:24:45 <jonkri> thanks a lot, i will try it out :)
17:27:10 <dcoutts> jonkri: the general principle here is that cabal tries really hard to make sure we're only using a single version of each lib, in general to do that it has to be able to rebuild somethings. With hackage packages it knows where the source is, but for local packages you have to tell it where the source tree is, otherwise it cannot rebuild.
17:30:17 <weary_> getting this error     No instance for (Show (String -> String))       arising from a use of `print'     Possible fix:       add an instance declaration for (Show (String -> String))     In a stmt of an interactive GHCi command: print it
17:30:41 <Dashkal> You tried to print a function that takes a string and returns a string
17:31:05 <Dashkal> check your precidence.  print foo "bar" isn't what you want.  print $ foo "bar" may be closer.
17:32:12 <weary_> nice = "a Lámina perpendicular\ \Concha nasal media Concha nasal inferior\ \Vómer Mandíbula" func :: String -> String func _ = [x|x <- nice, elem x ['A'..'Z'] || elem x [' ','\t']]
17:33:02 <rwbarton> yes, and what did you type into ghci?
17:33:23 <weary_> func
17:33:43 <rwbarton> well yeah
17:33:46 <rwbarton> what did you expect it to do?
17:33:55 <rwbarton> func is a function. you can't print a function
17:34:07 <rwbarton> you can try
17:34:08 <rwbarton> func nice
17:34:27 <weary_> yeah that was dumb
17:35:27 <spaceships> instance Show (->) where ???????
17:35:50 <cmccann> > show const
17:35:51 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b -> a)
17:35:51 <lambdabot>    arising from a use...
17:35:53 <cmccann> pf
17:36:06 <cmccann> > show not
17:36:07 <lambdabot>   Overlapping instances for GHC.Show.Show
17:36:07 <lambdabot>                              (GHC.B...
17:36:18 <cmccann> lambdabot has too many weird instances.
17:36:57 <hpc> > 0xford
17:36:59 <lambdabot>   15
17:37:14 <weary_> hey how could i add accents to this
17:37:15 <spaceships> cute
17:37:18 <weary_> func _ = [x|x <- nice, elem x ['A'..'Z'] || elem x [' ','\t'] || elem x ['a'..'z']]
17:37:26 <weary_> from toher languages
17:37:38 <maukd> > let rd = () in 0xf0rd
17:37:40 <lambdabot>   240
17:38:02 <weary_> "a Lámina perpendicular\ \Concha nasal media Concha nasal inferior\ \Vómer Mandíbula" so this also contain accents a not delete them
17:38:11 <weary_> "a Lmina perpendicularConcha nasal media Concha nasal inferiorVmer Mandbula"
17:38:24 <jonkri> dcoutts: it first seemed to work, but it ended in: /home/jonkri/.cabal/lib/pontarius-xmpp-0.1.0.0/ghc-7.0.4/libHSpontarius-xmpp-0.1.0.0.a(Xmpp.o): In function `slKq_info': (.text+0xf37): undefined reference to `__stginit_pontariuszmxmppzm0zi1zi0zi0_NetworkziXmppziSaslziMechanisms_' :P
17:38:40 <hpc> weary_: sounds like you are looking for a function that turns 'á' into 'a', etc?
17:39:14 <hpc> > isAlpha 'á'
17:39:15 <lambdabot>   True
17:39:25 <weary_> no
17:39:30 <weary_> that keep them
17:39:37 <hpc> ah, to just keep them
17:39:40 <dcoutts> jonkri: that's because you didn't list that module in your .cabal file
17:39:40 <hpc> yeah, isAlpha, probably
17:39:44 <troydm> > putStrLn "hey there!"
17:39:45 <lambdabot>   <IO ()>
17:40:06 <jonkri> oh, okay :)
17:40:42 <weary_> i have a large text of woth weird chars like ■■■(HBH and i want to remove those
17:40:45 <hpc> > filter (\c -> isAlpha c || isSpace c) "a Lámina perpendicular\ \Concha nasal media Concha nasal inferior\ \Vómer Mandíbula"
17:40:47 <lambdabot>   "a L\225mina perpendicularConcha nasal media Concha nasal inferiorV\243mer ...
17:41:10 <hpc> > filter (\c -> isAlpha c || isSpace c) "a Lámina perpendicular 17 φλαωορ Ø"
17:41:11 <lambdabot>   "a L\225mina perpendicular  \966\955\945\969\959\961 \216"
17:41:19 <hpc> hmm
17:41:36 <hpc> > filter (\c -> isAlpha c || isSpace c) "a Lámina perpendicular 17 →"
17:41:37 <lambdabot>   "a L\225mina perpendicular  "
17:41:59 <hiptobecubic> > isAlpha "ä"
17:41:59 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
17:42:00 <lambdabot>         against inferred type...
17:42:12 <hiptobecubic> > isAlpha 'ä'
17:42:13 <lambdabot>   True
17:42:42 <ew_> so, is there a strict version of mapM_
17:42:43 <ew_> ?
17:42:54 <hpc> ew_: what kind of strict?
17:43:09 <weary_> there isnt and alphabet of accents to i can just
17:43:16 <ew_> one that evaluates the function mapped
17:43:34 <ew_> before running the sequence
17:43:43 <hpc> weary_: maybe try http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Char.html#t:GeneralCategory
17:43:44 <weary_> like [(accentChar)..(acentChar)]
17:43:52 <hpc> and matching on the specific unicode categories you want
17:43:59 <rwbarton> there are kind of a lot of "accented characters" in unicode
17:44:30 <hpc> there's a lot of everything in unicode
17:44:32 <weary_> ok just the spanish ones
17:44:47 <hpc> there's no "spanish accents"
17:44:59 <hpc> unless you enumerated all of them
17:45:22 <weary_> the vocals the ñ thats all
17:45:52 <hpc> sounds like you should just do it the tedious way
17:45:53 <weary_>  á, é, í, ó, ú, ý, à, è,
17:46:41 <hpc> > filter (`elem` "áéíóúýàèñ") "español"
17:46:42 <lambdabot>   "\241"
17:46:48 <hpc> > text $ filter (`elem` "áéíóúýàèñ") "español"
17:46:50 <lambdabot>   mueval-core: <stdout>: hPutChar: invalid argument (Invalid or incomplete mu...
17:46:52 <hpc> :(
17:47:09 <hpc> anyway, add an (x `elem` thatString) check to your original comprehension
17:47:17 <hpc> and you should theoretically be okay
17:48:35 <weary_> just get this /234 numbers
17:48:55 <hpc> > ord 'ñ'
17:48:56 <lambdabot>   241
17:49:01 <hpc> > "ñ"
17:49:02 <lambdabot>   "\241"
17:49:10 <hpc> yeah, that's unicode escaping
17:49:22 <weary_> wasnt haskell utf8 and stuff
17:49:34 <hpc> Char is unicode
17:49:44 <hpc> but Handles still default to other encodings
17:50:03 <hpc> (Char doesn't have to be utf8 either)
17:51:30 <weary_> maybe is terminal
17:51:36 <hpc> you might also be using print instead of putStrLn, now that i think about it
17:52:28 <startling> so I've got what amounts to an infinite list. can I serialize it somehow?
17:52:52 <hpc> startling: does it have a normal form?
17:53:01 <startling> hpc, I don't know what that means
17:53:05 <ksf_> @hackage vacuum
17:53:06 <lambdabot> http://hackage.haskell.org/package/vacuum
17:53:27 <lispy> startling: does it have structure you can exploit?
17:53:42 <lispy> > cycle [1,2,3] -- inifinite but repeating
17:53:44 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
17:54:07 <hpc> something circular like that can be represented as some kind of "newtype Circular a = Circular [a]"
17:54:10 <maukd> startling: serialize it as instructions to recreate the list
17:54:11 <hpc> for instance
17:54:20 <weary_> http://imgur.com/4xrkk
17:54:21 <startling> maukd, well, that's problematic
17:54:27 <startling> because user actions can affect the list
17:54:28 <weary_> Look http://imgur.com/4xrkk
17:54:40 <startling> so I'd need to serialize the list of user actions, and replay the game up until then
17:55:01 <startling> lispy: sort of, but nothing definite
17:55:11 <startling> I can restrict my generation, probably, if that's what it takes
17:55:51 <startling> ksf_: can you take one of those from a file and stick it back in a running process?
17:56:00 <ksf_> nope
17:56:08 <startling> I didn't think so.
17:56:10 <ksf_> it's more of a debug tool.
17:56:14 <startling> yeah
17:56:57 <ksf_> there's also http://hackage.haskell.org/package/data-reify
17:56:57 <startling> hmm, I guess I can just keep an array (?) of the parts the user has seen, and re-generate everything else
17:57:15 <ksf_> which is more work as you have to specify how to represent stuff, but it's going to give you a proper graph.
17:57:44 <startling> ksf_: interesting
17:58:16 <ksf_> the paper: http://www.ittc.ku.edu/csdl/fpg/Tools/IOReification  explains it relatively hands-on
17:58:27 <startling> the real story is that I've got this kind of comonad: data U a = [a] a [a]
17:58:33 <otters> I read that article too
17:58:40 <startling> otters: heh
17:58:50 <startling> and I'm trying to beat that into a roguelike
18:03:21 <startling> I suppose the only way is going to be keeping an (st)array of seen tiles and a seed
18:03:27 <startling> and regenerate + update at load time
18:04:12 <startling> or I can limit saves to in between levels and give some story reason why you can't go back
18:04:15 <startling> but that's no fun
18:05:11 <rwbarton> actually i know of a game that works that way, never occurred to me before why that might be heh
18:11:18 <cmccann> the original rogue didn't let you go back, if memory serves me
18:11:46 <cmccann> it didn't let you do a lot of stuff compared to the absurdity that is nethack
18:12:34 <amp3qua> how is a function that only has output
18:12:52 <rwbarton> preflex: zenc {good??}
18:12:53 <preflex>  z7bUgoodz3fUz3fUz7dU
18:13:51 <amp3qua> example
18:15:41 <startling> rwbarton: haha
18:15:53 <startling> cmccann: all I know about rogue is from that handful of nethack levels
18:16:20 <startling> it'd be really really cool to have a sprawling infinite cave system
18:17:39 <rwbarton> preflex: zenc a b c
18:17:40 <preflex>  az20Ubz20Uc
18:24:04 <sm> a sprawling infinite peristent networked cave system!
18:24:30 <sm> with lasers.
18:24:51 <startling> haha
18:25:13 <Ralith> generating good cave systems is a bit tricky
18:25:57 <Clint> is it?
18:26:10 <strebe> yes
18:26:26 <strebe> more than a bit, frankly
18:26:37 <startling> All I would really need where varying-sized circular-ish rooms with tunnels in between
18:26:38 * sm heard there's a system of caves underlying hackage
18:26:41 * strebe has spent far too much time with roguelikes
18:26:50 <startling> strebe: heh
18:26:55 <startling> well, rooms work too
18:27:27 <Nisstyre> Ralith: can't you use similar algorithms to the ones used for generating procedural landscapes
18:27:42 <strebe> there are a -lot- of ways to get it wrong, in the sense that the code works and you can theoretically navigate the cave system, but it's incredibly annoying
18:28:00 <strebe> even leaving out things like just putting someone in an unconnected room/cave with no staircase
18:28:22 <Ralith> Nisstyre: generating good procedural landscapes is massively tricky.
18:28:25 <strebe> generating an infinite series of caves is easy; generating one that doesn't suck to play? not so easy
18:28:34 <startling> strebe: oh. I'm planning on having nethack-esque pickaxes, anyway
18:28:39 <Nisstyre> Ralith: I'm not saying it isn't, just wondering if you could take the work done already on it
18:28:40 <startling> but fair enough
18:28:46 <Ralith> Nisstyre: oh, loosely, sure
18:28:56 <Ralith> Nisstyre: very interesting field, lots of existing work, lots of work to be done.
18:28:58 <strebe> startling: yeah, but it's still tedious to spend most of your time using pickaxes and then starving to death
18:29:11 <Nisstyre> Ralith: also Bethesda seem to have done a good job on this
18:29:18 <startling> maybe it could be more dwarf-fortress-like than anything
18:29:23 <Nisstyre> have you played Oblivion?
18:29:37 <Nisstyre> a lot of the landscapes and dungeons were procedurally generated
18:29:54 <Ralith> I fear you may have been misled by the advertising
18:30:02 <Nisstyre> Ralith: howso?
18:30:07 <startling> Nisstyre, but probably on a render farm and with a helping hand or two
18:30:09 <Nisstyre> I know the artwork was done manually
18:30:14 <Nisstyre> startling: sure
18:30:26 <Ralith> the only really major thing done procedurally were the trees.
18:30:31 <Nisstyre> oh, ok
18:30:39 <Nisstyre> I thought the dungeons were done procedurally as well
18:30:46 <Ralith> not to any great degree.
18:30:58 <Ralith> (unless I misremember)
18:30:59 <Nisstyre> okay, fair enough
18:31:11 <startling> anyway. how would I write a line-of-sight function on these weird two-dimensional zippers?
18:31:12 <Nisstyre> then there's no excuse for them being boring
18:31:19 <startling> Nisstyre: haha
18:31:20 <Ralith> yes, that's just bethesda for you.
18:31:28 <startling> Nisstyre: the trees are pretty cool, though!
18:31:30 <strebe> startling: I've written procedural level generation code before, and it reinforced my belief that it's a bit of a black art to make Not Suck :-)
18:31:31 <Nisstyre> sure
18:31:39 <Ralith> fun fact: they licensed the trees.
18:31:50 <Nisstyre> Ralith: what was the system called again?
18:31:51 <Ralith> http://www.speedtree.com/
18:31:54 <Nisstyre> yeah
18:31:55 <Ralith> very popular middleware these days
18:32:16 <startling> those are some good-looking trees
18:32:23 <Ralith> you can throw together a pretty decent version yourself based on L-systems
18:33:15 <Nisstyre> Ralith: that's interesting
18:33:30 <startling> strebe: maybe I'll come up with some functional paradigm that reduces the number of blood sacrifices necessary. :)
18:34:18 <Nisstyre> Ralith: this does look like something I could throw together fairly easily
18:34:32 <startling> Nisstyre: help me write my game instead
18:34:40 <Nisstyre> startling: what sort of game?
18:35:03 <Ralith> Nisstyre: give it a go! Graphics algorithms are always fun to play with.
18:35:05 <startling> Nisstyre: a roguelike on an infinite plane using comonads
18:35:17 <strebe> startling: eh, I wrote it in a lisp dialect in a pure-functional style, but maybe :-)
18:35:19 <Nisstyre> startling: not my cup of tea. I want to write an adventure game.
18:35:40 <Ralith> startling: sounds like fun to me!
18:35:42 <startling> Nisstyre: fair enough
18:35:56 <rwbarton> comonadius
18:35:57 <Nisstyre> Ralith: well I would probably just implement the logic first. Then find a graphics library to use it with.
18:35:58 <Ralith> I'd jump on that if I wasn't busy with a million other things
18:36:22 <Ralith> Nisstyre: it'd be easiest to just output some mesh format and load it in an existing model viewer
18:36:31 <Nisstyre> Ralith: any recommendations?
18:36:37 <startling> strebe: comonads look like they're going to simplify the movement code a ton, at least
18:36:44 <Ralith> .obj is very easy to generate
18:36:51 <Nisstyre> okay, cool
18:36:57 <Ralith> I don't know any others, though, so I may be biased
18:37:00 <Nisstyre> I'll try this when I get a free day
18:37:33 <Ralith> startling: the application of advanced functional programming techniques to roguelikes seems like a really interesting/fun problem, though
18:37:41 <strebe> startling: possibly - I don't understand comonads yet, but I want to
18:37:57 <Ralith> if I were a school I'd structure a course around that
18:38:06 <gwern> my gut feeling on roguelikes is that they're a small enough domain you should be able to come up with some beautiful abstractions
18:38:22 <Ralith> and their demands are simple enough that you can ignore performance issues entirely
18:38:26 <Ralith> (well, almost)
18:41:02 <startling> strebe: this was my inspiration: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
18:41:31 <startling> Ralith: yeah! it's really interesting
18:41:36 <startling> also, there are some Hard Problems
18:41:57 <Ralith> but not so many that you can't build fun things without writing a thesis in the process
18:41:59 <startling> which is nicer than trying to figure out how list directories in IO
18:42:04 <startling> Ralith: right
18:42:15 * sm doesn't believe you can ignore performance
18:42:38 <Nisstyre> startling: did you see the continuous version of conway's game of life?
18:42:43 <Nisstyre> smoothlife
18:42:49 <startling> Nisstyre, yeah. that was pretty cool
18:43:09 <startling> Nisstyre: I wish I had come up with it. it's such a simple idea obvious in retrospect
18:43:18 <Nisstyre> yeah it is
18:43:20 <Ralith> Nisstyre: oo, hadn't seen that
18:43:21 <Nisstyre> and it looks awesome
18:43:41 <Nisstyre> http://youtu.be/KJe9H6qS82I
18:44:07 <Ralith> already there
18:45:29 <startling> anyway, here's my line-of-sight code: https://github.com/startling/phial/blob/master/Phial/Tile.hs#L44 and I get things like http://i.imgur.com/1sitw.png
18:45:40 <startling> this is tricky because I can't really search along diagonals
18:46:02 <startling> N.B. that's a square room; the walls in the corners are invisible
18:46:12 <startling> to the player with the current line-of-sight code
18:46:27 <Nisstyre> startling: Haskell does seem ideal to model something like this
18:49:06 <startling> Nisstyre: indeed
18:50:17 <hpaste> jonkri pasted “haskell platform text build failure” at http://hpaste.org/76470
18:50:35 <jonkri> any idea why haskell platform (text) fails to build on debian: http://hpaste.org/76470
18:51:36 <Ralith> startling: game design wise, are you familiar with dungeon crawl: stone soup?
18:52:12 <startling> Ralith: I've played it but never looked at the code
18:52:24 <zzing> Q: Can Happy work with Text types?
18:52:27 <startling> I'm going for a similar "player is in the center, sprawling landscape" kind of thing
18:52:40 <Ralith> speaking about game design, that's all that's necessary
18:52:41 <Ralith> wonderful
18:53:01 <Ralith> crawl does a lot of things right that other roguelikes omit/screw up, imo
18:53:17 <startling> yeah. it's got a lot of variety, too
18:53:21 <Ralith> continuous-direcional projectile aim, arbitrary-size maps, autoexplore, etc
18:53:38 <Ralith> autoexplore in particular basically removes the tedium from the genre
18:53:46 <startling> yeah. it's less grindy, too
18:54:01 <startling> like, battles are fun and challenging throughout the whole game
18:54:13 <Ralith> one thing I'd worry about in yours is providing a sense of progression
18:54:18 <startling> in nethack, it's just "hit these grid bugs with my staff until one of us dies"
18:54:27 <Ralith> if your world is continuous and infinite, how will you prevent it from being on average uniform?
18:55:02 <startling> Ralith: yeah, I was wondering about that. I could be lazy and have it get less interesting the farther you get from the center
18:55:16 <startling> Ralith: and I'm considering differently-themed levels
18:55:39 <startling> ideally with some guarantee that the stairs down will be close to the center
18:55:58 <Ralith> oh, you didn't actually mean an infinite plane
18:56:04 <Ralith> you meant an infinite plane * n levels
18:56:07 <startling> well, multiple infinite planes
18:56:08 <startling> yeah
18:56:20 <Ralith> okay that's a lot easier to see
18:56:25 <startling> though an infinite plane could work out nicely too. we'll see
18:56:40 <Ralith> whatever it ends up as, it sounds fun!
18:56:41 <Ralith> good luck
18:56:50 <startling> thanks!
19:08:21 <startling> slight difficulty: what ways could I modify this structure to allow modifications to neighboring cells? http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
19:10:31 <Nisstyre> startling: you can access the "neighbourhood" from each cell no?
19:10:38 <Nisstyre> I don't know much about comonads though
19:10:41 <startling> Nisstyre, but you can't modify them
19:10:49 <Nisstyre> startling: you can functionally modify them
19:10:55 <Nisstyre> "modify"
19:11:08 <startling> Nisstyre, the rule function is U Tile -> Tile
19:11:37 <Nisstyre> startling: what is a Tile?
19:11:56 <startling> a Bool, in that example
19:12:02 <Nisstyre> I see
19:12:08 <startling> a single cell / whatever
19:12:22 <Nisstyre> startling: so each cell is a function of the preceding cell?
19:12:41 <startling> Nisstyre: of its surrounding cells
19:13:01 <Nisstyre> startling: wouldn't that require the type to be U Tile Neighbourhood -> Tile ?
19:13:09 <Nisstyre> or am I just stupid?
19:13:23 <startling> Nisstyre: the U Tile is centered on the tile in question
19:13:48 <Nisstyre> startling: you're using a zipper right?
19:14:02 <startling> hmm, I could do U Tile -> [(Monster, Action)] and then run those actions
19:14:34 <startling> Nisstyre: it's zipper-like. data U = [a] a [a]
19:14:44 <Nisstyre> startling: yeah
19:14:51 <Nisstyre> startling: so, can you not just go left or right?
19:15:18 <Nisstyre> and then go back
19:15:41 <startling> hm?
19:15:57 <Nisstyre> startling: okay, so you start out in some cell that is the focus
19:16:07 <Nisstyre> and you want to go to one of the neighbouring cells, right?
19:16:15 <startling> yeah
19:16:38 <Nisstyre> so can't you just pass some kind of information along that says what the next cell should be modified to?
19:16:40 <Nisstyre> I mean
19:16:56 <Nisstyre> I'm not sure I understand the problem
19:17:08 <startling> I think I've got it figured out, regardless
19:17:12 <startling> thanks anyway!
19:17:27 <Nisstyre> startling: one other thing
19:17:39 <Nisstyre> startling: can you only go left or right using this scheme?
19:18:01 <startling> Nisstyre: I have a two-dimensional data U a = [a] a [a]
19:18:09 <startling> U (U a)
19:18:15 <Nisstyre> okay
19:18:41 <Nisstyre> startling: I think the "Action" thing will work
19:18:50 <startling> yeah
19:19:03 <startling> and then I can validate against walls and stuff, too
19:19:38 <startling> rather than having each monster controller check that
19:21:07 <startling> oh! I just run the thing twice
19:21:15 <startling> I turn Tile into (Tile, Action)
19:21:33 <startling> and then each tile observes the possible actions into those tiles and changes
19:21:46 <startling> neat.
19:22:23 <mzero> 70+ people here at BayArea Haskell in S.F. listenting to Edward Kmett's talk on Lenses, Folds and Traversal !!!
19:23:13 <startling> nbd. he gets audiences upwards of 9k in this very channel
19:24:15 <mzero> well... I think 70+ is a record for BA Hask
19:24:37 <byorgey> 9k !?
19:25:00 <byorgey> mzero: awesome!
19:25:12 * Ralith wishes he was in the area
19:26:55 * hackagebot silently 1.2.3 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.2.3 (TrystanSpangler)
19:34:04 <jonkri> when i try to build the haskell platform on debian stable there are quite a few packages that fails to build, text, cabal-install, etc. is the latest haskell platform not supported for debian 6?
19:34:41 <monochrom> usually, that is because you use a very old ghc
19:34:56 <Nisstyre> Hmm, what's the best way to say that a certain type must be a subset of a larger (recursive) data type? Would that require dependent typing?
19:35:01 <mzero> lastest HP needs GHC 7.4.1
19:35:31 <monochrom> however, the haskell platform build script has a check on ghc version. so I don't know why you can get beyond that
19:35:47 <Clint> jonkri: you might want to upgrade to wheezy
19:36:10 <byorgey> Nisstyre: it's not easy.  One way is with a "data types a la carte" sort of approach
19:36:15 <mzero> monochrom: there is a flag for turning the check off.... and many instructions say to do so
19:36:22 <Nisstyre> byorgey: yeah
19:36:48 <Nisstyre> byorgey: maybe I can just let it be unsafe for now :\
19:36:55 <monochrom> people should follow my instruction only
19:37:30 <jonkri> monochrom: i have only 7.4.1 installed
19:37:39 <pdxleif> Is there a Special Place to go to ask about Cabal, or would this be the room?
19:37:45 <MostAwesomeDude> ~/.
19:37:52 <byorgey> jonkri: can you paste the error output somewhere?
19:38:02 <MostAwesomeDude> Derp.
19:38:20 <jonkri> byorgey: certainly. first off is for text: http://hpaste.org/76470
19:38:46 <byorgey> pdxleif: this is the place.
19:39:25 <jonkri> byorgey: and here is for cabal-install. http://hpaste.org/76471
19:39:30 * ski . o O ( refinement types )
19:39:30 <jonkri> the message doesn't seem very informative
19:39:35 <byorgey> that is a very strange error.  It's like there is no error.  It just... stops.
19:39:50 <jonkri> yeah :(
19:39:58 <monochrom> perhaps hardware problem
19:40:06 <jonkri> it's a vps from linode
19:40:09 <byorgey> huh, no clue
19:40:10 <jonkri> but yeah
19:40:33 <monochrom> out of memory? out of time quota? out of disk quota?
19:40:47 <mzero> what monochrom said
19:40:55 <jonkri> that's a good point
19:41:03 <jonkri> i have lots of free disk space, but only 512mb ram on the machine
19:41:03 <pdxleif> I thought I remember someone discussing the pros and cons of putting the {-# LANGUAGE OverloadedStrings #-} stuff at the top of the .hs files vs in the .cabal files...
19:41:51 <byorgey> pdxleif: if you put it in the default-extensions field in the .cabal file, it will be enabled for every module in the package
19:42:15 <byorgey> which can be convenient if you have a lot of modules and you need an extension in all of them, I suppose
19:42:32 <byorgey> on the other hand, it's nice for for each module to explicitly state which extensions it needs
19:42:54 <frio> i kind of prefer having extensions in the source files; it provides an immediacy to them that you can't miss when you come back to your code 6 months later
19:43:31 <frio> or, when comparing someone else's source to your own and wondering why yours doesn't work, you can see the extensions they've used/you've used as well
19:43:37 <pdxleif> Makes sense, thanks.
19:48:43 <startling> is there a Map somewhere that lets you provide defaults?
19:48:48 <startling> that's be cool for Monoids.
19:48:56 <startling> *'d
19:50:01 <jonkri> byorgey, Clint, monochrom: it was probably a memory issue. running make install five times in a row helped :)
19:50:07 <jonkri> make even
19:50:57 <pdxleif> I guess records let you provide defaults, but that's not quite the same.
19:52:04 <pdxleif> Update the default map w/ the new map?
19:53:12 <monochrom> "fromMaybe d (lookup x your_map)" may be close enough
19:55:56 <dolio> That's not going to be good for monoids.
20:02:15 <ion> @check let f :: [(String, String)] -> (String, String) -> Bool -> Bool; f list (key, val) add = M.findWithDefault val key table == fromMaybe val (M.lookup key table) where { table = M.fromList (if add then (key,val):list else list) } in f
20:02:17 <lambdabot>   "OK, passed 500 tests."
20:20:26 <hpaste> meh pasted “why is this so” at http://hpaste.org/76472
20:20:35 <dmj> hey
20:20:38 <dmj> can someone help me with that
20:20:40 <dmj> super noob here
20:21:18 <dmj> f x = 0, g x = f x, f x = 1.... but now g x gets evaluated as 0 still
20:21:58 <dmj> so even though I am redefining f x with the same name g x still has an older version? Isn't this called shadowing?
20:22:13 <ski> yes
20:22:21 <rwbarton> it is shadowing but it doesn't change g
20:22:24 <ski> it's also an example of lexical scope
20:22:29 <rwbarton> g uses the f that was in scope when/where g was defined
20:23:23 <Jafet> > do let f x = 0; let g x = 1; let f x = 1; return (f 5, g 2)
20:23:24 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:23:38 <Jafet> > do let { f x = 0 }; let { g x = 1 }; let { f x = 1 }; return (f 5, g 2)
20:23:39 <lambdabot>   No instance for (GHC.Show.Show (m (t, t1)))
20:23:39 <lambdabot>    arising from a use of `M1818...
20:23:47 <ski> > do let {f x = 0; g x = 1; f x = 1}; return (f 5, g 2)
20:23:48 <lambdabot>   Conflicting definitions for `f'
20:23:48 <lambdabot>  Bound at: <interactive>:1:8
20:23:48 <lambdabot>            <in...
20:23:54 <Jafet> > runIdentity $ do let { f x = 0 }; let { g x = 1 }; let { f x = 1 }; return (f 5, g 2)
20:23:55 <lambdabot>   (1,1)
20:24:17 <ski> > runIdentity $ do let { f x = 0 }; let { g x = f x }; let { f x = 1 }; return (f 5, g 2)
20:24:18 <lambdabot>   (1,0)
20:24:35 <dfeuer> I clearly do not understand Typeable.
20:24:59 <dfeuer> If x=3::Int,
20:25:12 <dfeuer> cast x :: (Integral a, Typeable a) => Maybe a
20:25:20 <dfeuer> gives Nothing.
20:25:30 <dfeuer> cast x :: (Bounded a, Typeable a) => Maybe a
20:25:35 <dfeuer> gives a type error.
20:25:44 <dmj> thanks ski
20:25:48 <ski> > cast (3 :: Int) :: (Integral a, Typeable a) => Maybe a
20:25:49 <lambdabot>   Nothing
20:25:50 <ski> > cast (3 :: Integer) :: (Integral a, Typeable a) => Maybe a
20:25:51 <lambdabot>   Just 3
20:26:05 <ski> it defaulted the `a' to `Integer'
20:26:19 <rwbarton> in the latter case there was no default rule to apply
20:26:27 <dmj> lexical scope ay. So is the original f x saved somewhere then? and then re-referenced when called upon through invocation of g x ?
20:26:28 <rwbarton> (dfeuer's latter case)
20:26:43 <ski> dmj : yes
20:26:53 <dmj> where is it stored>
20:26:56 <dmj> ?*
20:26:56 <lambdabot> Maybe you meant: . ? @ v
20:27:05 <rwbarton> the moon? where is anything stored
20:27:09 <ski> dmj : at no point is the only definition of `f' replaced by the new definition of `f'
20:27:21 <rwbarton> you can imagine that it is actually copied into g if you like
20:27:26 <dmj> so ghci has two versions in memory
20:27:43 <ski> s/only/old/
20:27:55 <ski> dmj : it has two different functions in memory
20:28:10 <ski> to it, there's no "versions" happening at all
20:28:11 <rwbarton> "the f defined on line 1" "the f defined on line 3"
20:28:24 <dmj> ski : on the stack ?
20:28:28 <rwbarton> g refers to "the f defined on line 1"
20:28:35 <rwbarton> while later uses of f will refer to "the f defined on line 3"
20:29:05 <dmj> I'm just trying to understand how ghci allocates symbols bound to functinons
20:29:13 <dmj> functions
20:29:25 <dmj> thanks rwbarton
20:31:40 <rwbarton> in other words, presuming ghci has some table somewhere of symbols and their values, there must be two different entries in the table corresponding to the two different "f"s, distinguished by their location of definition, or something like that
20:31:48 * ski remembers wondering (when learning it) whether Haskell used dynamic scoping -- stating the question in terms of analogy with CPP macros
20:32:55 <Nisstyre> ski: did you come from common lisp?
20:33:05 <ski> nope
20:33:16 <rwbarton> you can also do "let x = 0 in let y = x in let x = 1 in y" all in one expression
20:33:23 <Nisstyre> what other languages use dynamic scope? perl I think right?
20:33:52 <Jafet> EMACS LISP
20:33:54 * ski had only programmed BASIC,6502 asm,C,(a little Prolog),Java before Haskell
20:33:55 <rwbarton> perl has both lexical and dynamic scope introduced by different declaration types
20:34:03 <Nisstyre> rwbarton: figures
20:34:06 <rwbarton> hehe
20:34:08 <yorcs> yeah emacs lisp does
20:34:13 <Nisstyre> when faced with a choice, the perl designers choose both
20:34:41 <monochrom> now they have two problems
20:34:55 <rwbarton> and four solutions :)
20:35:01 <monochrom> hahaha
20:35:05 <Nisstyre> you do have to admire it solely because of that though
20:35:34 <Nisstyre> turing tarpit
20:36:07 <Nisstyre> well, not quite
20:36:13 <Nisstyre> it has the "Everything is possible" part
20:39:15 <ski> dmj : one way to think about it is to say that `g' keeps track of the environment that was in scope when it was defined. then when you make a new definition of `f', the "current environment" (in the interactor) gets the new binding for `f' added to it, but the environment that `g' refers to is still the old one
20:41:12 <dmj> thats really interesting
20:41:20 <dmj> it is stateful
20:41:28 <dmj> without a database
20:41:38 <ski> not really (except from the interactor)
20:41:57 * hackagebot sbv 2.4 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-2.4 (LeventErkok)
20:43:20 <tredontho> I don't know if this is the place to ask, but I'm having some issues installing ghc-mod
20:46:57 * hackagebot aeson-lens 0.1.0.0 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.1.0.0 (HideyukiTanaka)
20:47:34 <byorgey> tredontho: what sort of issues?
20:47:41 <copumpkin> Lens of Aeson sounds quite grand
20:48:17 <Jafet> It's a real spectacle
20:49:20 <tredontho> byorgey: I'm getting compiler errors when it tries to build Gap.hs
20:49:20 <dmwit> Lens of Aeson, +2 to perception checks, +5 to wisdom, -3 to charisma
20:49:27 * Clint twitches.
20:51:53 <tredontho> mostly on the same line. "Couldn't match type `PprStyle -> String' with `[Char]'"
20:53:21 <Jafet> Grants its bearer one Remote Procedure Call
20:54:51 <glguy_> rwbarton: regarding "perl has both lexical and dynamic scope introduced by different declaration types", is that different to how Haskell has both introduced by different declarations?
20:55:30 <glguy_> (I don't know how Perl works in this regard, so I'm actually asking)
20:56:12 <copumpkin> glguy_: too good for agda these days?? :(
20:56:30 <glguy_> I operate in phases :)
20:56:36 <copumpkin> we can now case split on multiple variables, so it's basically impossible not to want to write agda now
20:56:43 <glguy_> haha
20:56:52 <copumpkin> and we have pattern synonyms and copatterns and other awesome features
20:56:57 * hackagebot aeson-lens 0.1.0.1 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.1.0.1 (HideyukiTanaka)
20:56:59 <copumpkin> although the copatterns don't really work yet
20:57:02 <glguy_> I use Agda until proving things terminate pisses me off too much
20:57:10 <copumpkin> :)
20:57:11 <glguy_> and then I start using it again when I forget how frustrating that is
20:57:34 <copumpkin> we're still in search for the one true well-hung corecursion (as coined by xplat iirc)
20:57:41 <copumpkin> *in search of
20:58:14 <glguy_> I'll have to review the release notes. I don't know what these new features are.
20:58:55 <copumpkin> copatterns might be an awesome way to write corecursive definitions
20:59:00 <copumpkin> if they end up working
21:01:11 <glguy_> copumpkin: Have you heard of a game called Hidden in Plain Sight?
21:01:18 <copumpkin> hmm, don't think so
21:02:15 <glguy_> In my time not playing Agda Iavor and I made a clone of that XBox360 game. It's been called a "reverse Turing Test". You try to blend in with the randomly controlled NPCs as you attempt to visit the 5 special locations on the screen
21:03:00 <glguy_> If you think you know who someone is you can attack them, but only players attack, so you give yourself away. Anonymity can be restored with your single use smokebomb.
21:03:30 <glguy_> Anyway, it's fun, think about checking it out some time :) (github)
21:04:19 <tac> > repeat 1
21:04:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
21:04:21 <glguy_> We had a 9-person network match about a week or two ago over lunch at work :)
21:04:39 <tac> > concat .repeat $ [1, 2, 3]
21:04:42 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
21:04:52 <tac> > concat . repeat $ [1, 2, 3]
21:04:54 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
21:05:29 <tac> > concat . repeat $ [1,2,3]
21:05:31 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
21:05:40 <glguy_> weird, it keeps giving back the same value
21:05:53 <tac> > concat . repeat . (\x -> [1..x] ) $ 3
21:05:55 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
21:06:12 <tac> is there a standard library call for concat . repeat . (\x -> [1..x] ) ?
21:06:17 <tac> I'm guessing no
21:06:19 <glguy_> :t cycle
21:06:21 <lambdabot> forall a. [a] -> [a]
21:06:24 <tac> ah
21:06:33 <tac> very close
21:06:35 <tac> thanks glguy_
21:06:57 * hackagebot const-math-ghc-plugin 1.0.0.0 - Compiler plugin for constant math elimination  http://hackage.haskell.org/package/const-math-ghc-plugin-1.0.0.0 (ConradParker)
21:06:59 * hackagebot http-conduit-browser 1.6.2 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.6.2 (MylesMaxfield)
21:08:55 <fold> is there a reverse head/tail split, like instead of (x:xs) a function that returns (xs:x) where xs is everything except last element of list
21:09:23 <strebe> init returns everything but the last element
21:09:37 <byorgey> fold: no, you can use 'init' and 'last', or reverse the list and pattern-match on the head and tail
21:09:41 <fold> I want something like that but both
21:09:47 <Iceland_jack> fold: just so you know, (x:xs) is the same as (xs:x)
21:09:54 <strebe> (init xs, last xs)
21:09:55 <fold> I know
21:10:06 <fold> thnx, i'll just write out a function
21:10:11 <fold> cause otherwise it's two traversals
21:10:23 <Ralith> so what?
21:10:44 <glguy_> Maybe he's on a demo license of GHC, doesn't want to use up his traversals
21:10:50 <fold> i lose my boner
21:10:56 <strebe> tmi
21:11:07 <fold> he asked >>
21:14:28 <glguy_> > let initLast (x:xs) = let (f,y) = foldl' (\(f,x) y -> (f.(x:),y)) (id,x) xs in (f[],y) in initLast [1..10]
21:14:31 <lambdabot>   ([1,2,3,4,5,6,7,8,9],10)
21:14:32 <dmj> is it accurate to say that types are organized into classes
21:14:33 <glguy_> whee :)
21:14:35 <ski> > case "fubar" of ((init &&& last) -> (xs,x)) -> (xs,x)
21:14:36 <lambdabot>   ("fuba",'r')
21:15:00 <ski> dmj : classes are predicates on types
21:15:25 <startling> man, flip fmap / flip mapM are so useful
21:15:31 <fold> thanks glguy
21:15:39 <dmj> predicates meaning (a -> Bool)
21:15:41 <dmj> ?
21:15:58 <dmj> can you give me an example?
21:16:03 <dmj> a simple one
21:16:10 <ski> `Eq'
21:16:32 <ski> `Eq a' holds for the types `a' which have a declared equality
21:17:12 <ski> another way to think of this is as `Eq' being a set of some types, namely the types which support equality
21:17:47 <ski> then `instance Eq MyType where ...' means that you're declaring `MyType' to be a member of this set of types
21:18:03 <dmj> so Eq is a class, that works on a type
21:18:33 <dmj> is it a class or a type
21:18:50 <dmj> data MyType = SpecialType | BlandType
21:18:51 <ski> `Eq' is a class (i.e. a type class)
21:19:15 <dmj> MyType is a type tho, that is declared through a type constrcutor
21:19:21 <dmj> data constructor
21:19:36 <dmj> so "data" makes types and "instance
21:19:38 <ski> (in case you've heard of classes in languages like C++,Java,C#,Smalltalk, then you should know that type classes are quite different from those)
21:19:49 <dmj> " appends typeclasses to types
21:19:49 <rwbarton> MyType is a type (and also a type constructor)
21:19:57 <rwbarton> SpecialType and BlandType are data constructors
21:20:28 <dmj> I'm a C# guy mostly but dabble in python and javascript, I want to become pure haskell
21:20:35 <dmj> no pun intended
21:21:37 <rwbarton> but yes
21:21:37 <dmj> ok, so data makes types, instance binds typeclasses to types. Those binded typeclasses get applied to TypeConstructors right?
21:22:49 <rwbarton> not sure what that last part means
21:23:48 <dmj> the typeclasses "Eq" in our case, now works on the type constructors "SpecialType" "MyType"
21:24:10 <rwbarton> "SpecialType" "MyType" aren't type constructors
21:24:12 <rwbarton> they are values
21:24:14 <rwbarton> data constructors
21:24:16 <dmj> instance MyType Eq where SpecialType == BlandType = False
21:24:19 <rwbarton> yes
21:24:24 <rwbarton> er
21:24:27 <rwbarton> instance Eq MyType where ...
21:24:38 <dmj> oh so only MyType is a type constuctor?
21:24:39 <rwbarton> a type constructor is a part of a type
21:24:40 <rwbarton> yes
21:24:46 <rwbarton> like in Maybe Int, both Maybe and Int are type constructors
21:25:06 <rwbarton> the result Maybe Int is a type
21:25:19 <dmj> so is that the same as (Maybe . Int)
21:25:33 <dmj> so you are combining types
21:25:41 <rwbarton> you can't write Maybe . Int
21:25:47 <rwbarton> but it is the application of Maybe to Int
21:25:48 <dmj> types are functions tho right?
21:26:01 <rwbarton> well Maybe is a sort of "type function" if you like
21:26:09 <rwbarton> Int definitely isn't
21:26:38 <dmj> int just returns constants, Maybe has a Just x "function"
21:26:39 <rwbarton> Maybe is something you can apply to a type (e.g. Int) to get another type (e.g. Maybe Int) so in that capacity it is a "function on types"
21:27:06 <dmj> it is like Nullable<T>
21:27:11 <dmj> no?
21:27:22 <rwbarton> it is like that sort of thing yes
21:28:01 <dmj> so if I wanted my Maybe Int type to have the Eq typeclass would I do instance Eq Maybe Int where
21:28:05 <dmj> ...
21:28:22 <rwbarton> yes (except it's "instance Eq (Maybe Int) where ..." -- and also the instance is already defined)
21:29:50 <dmj> So then where does "Num" come into all of this
21:29:57 <dmj> is that a typeclass as well?
21:29:59 <rwbarton> yes
21:30:05 <ion> {-# LANGUAGE TypeOperators #-} type (a :. b) c = a (b c); xs :: ([] :. Maybe) Integer; n = [Just 42, Nothing]
21:30:27 <dmj> But is num defined with the "class" keyword?
21:30:35 <dmj> when do I use the class keyword
21:30:37 <rwbarton> yep
21:30:46 <rwbarton> well really it is defined in the language spec
21:30:58 <rwbarton> but in ghc you can see its definition here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Num.html#Num
21:31:09 <rwbarton> you use "class" when you want to define a new type class
21:31:38 <dmj> So if I wanted to define my own "class" called MyNum, would I use "instance" with it?
21:32:06 <dmj> I'm sorry, the word "class" is forever burned into my mind as something different from what haskell defines
21:32:28 <rwbarton> first you would "class MyNum a where {- declare a bunch of methods -}"; then for each type you want to make an instance of MyNum, have an instance MyNum MyType where {- definitions of the methods for MyType -}
21:33:09 <dmj> so was Eq defined with "class"?
21:33:14 <rwbarton> yes
21:33:16 <ion> @src Eq
21:33:17 <lambdabot> class  Eq a  where
21:33:17 <lambdabot>     (==), (/=)   :: a -> a -> Bool
21:33:21 <rwbarton> perfect :)
21:34:11 <dmj> can classes be hierarchical?
21:34:45 <rwbarton> sort of
21:35:01 <dmj> @src Int
21:35:01 <lambdabot> data Int = I# Int#
21:35:07 <dmj> @src Num
21:35:07 <lambdabot> class  (Eq a, Show a) => Num a  where
21:35:08 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:35:08 <lambdabot>     negate, abs, signum     :: a -> a
21:35:08 <lambdabot>     fromInteger             :: Integer -> a
21:35:15 <rwbarton> when you define a class you can declare that every instance of it should be an instance of some other class(es)
21:35:16 <dmj> @src Integer
21:35:17 <lambdabot> data Integer = S# Int#
21:35:17 <lambdabot>              | J# Int# ByteArray#
21:35:59 <dmj> so does haskell have a root element, like .net has object, and java (object?)
21:36:08 <rwbarton> no
21:36:09 <glguy_> dmj: Anything with a # is a GHC implementation detail and something you should ignore until you know why you shouldn't be ignoring it :)
21:36:53 <dmj> ah thanks, definitely looked a little weird
21:36:59 <byorgey> dmj: Haskell does not have subtyping at all, actually
21:37:21 <rwbarton> that's why I wanted to hedge about "can classes be hierarchical"
21:37:59 <dmj> so if I wanted to extend Num by defining my own class called MyNum, how would I ensure that I "inherit
21:38:05 <dmj> " everything from Num
21:38:49 <byorgey> class Num a => MyNum a where ...
21:39:10 <rwbarton> you should be careful to note that this is more like "inheritance" of interfaces (do they call it that?)
21:39:16 <rwbarton> I assume java/c# has that, right?
21:39:28 <byorgey> java does at least
21:39:37 <rwbarton> it's definitely not at all the same thing as class inheritance
21:40:43 <rwbarton> byorgey, is it called inheritance in java? because it seems like a pretty different concept to class inheritance to me
21:41:17 <rwbarton> oops, almost searched for "instance inheritance" :/
21:41:23 <dmj> C# has it too
21:41:27 <rwbarton> inTERFACE there we go. :)
21:41:56 <dmj> its like functionality inheritance as opposed to member inheritance
21:41:59 <rwbarton> dmj, so yeah, you can do that.
21:42:01 <rwbarton> yes
21:42:08 <rwbarton> here is a simple real example
21:42:10 <rwbarton> @src Ord
21:42:10 <lambdabot> class  (Eq a) => Ord a  where
21:42:10 <lambdabot>     compare      :: a -> a -> Ordering
21:42:10 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
21:42:10 <lambdabot>     max, min         :: a -> a -> a
21:42:34 <rwbarton> or indeed there are a lot of examples with Num too
21:42:39 <rwbarton> @src Fractional
21:42:39 <lambdabot> class  (Num a) => Fractional a  where
21:42:39 <lambdabot>     (/)             :: a -> a -> a
21:42:39 <lambdabot>     recip           :: a -> a
21:42:39 <lambdabot>     fromRational    :: Rational -> a
21:43:08 <rwbarton> so if a type is Fractional then I can divide values of that type but I can also add, subtract etc.
21:43:15 <rwbarton> because those are methods of Num
21:44:22 <rwbarton> similarly it doesn't really make sense to have values that I can compare for ordering with <= but not compare for equality with ==, so Eq is a "superclass" of Ord
21:45:31 <dmj> ahhh, so its just symbols bound to function signatures?
21:45:40 <dmj> classes that is
21:46:06 <dmj> I see the "inheritance" part
21:46:58 * hackagebot Data-Hash-Consistent 0.1.0 - Provide a simple consistent hashing mechanism  http://hackage.haskell.org/package/Data-Hash-Consistent-0.1.0 (BradClawsie)
21:47:04 <dmj> btw, http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Monad.html, is this the latest code? it says 2001
21:47:31 <rwbarton> yes
21:47:34 <rwbarton> it also says latest :)
21:47:37 <rwbarton> in the URL
21:48:06 <rwbarton> it is conceivable this file has not changed since 2001 but also very possible that the copyright notice was not updated
21:48:49 <rwbarton> I see another file that has definitely changed since the last year in the copyright notice.
21:48:59 <rwbarton> so I wouldn't put any stock in those
21:50:26 <dmj> didn't see that :)
21:50:54 <dmj> ok I have another question
21:51:10 <dmj> lets say I have a type (aka type constructor)
21:51:35 <dmj> data NaturalNumber = Zero | s NaturalNumber
21:51:52 <dmj> i then build up my nums like this
21:51:53 <dmj> let zero = Zero
21:52:01 <dmj> let one = S Zero
21:52:09 <dmj> let two = S one
21:52:13 <dmj> etc ...
21:52:17 <rwbarton> ok
21:52:24 <dmj> now I want to implement Ord on them
21:53:33 <dmj> instance Ord NaturalNumber where compare Zero Zero = EQ compare Zero S x LT compare S x Zero GT... what do I do for compare S x S y
21:53:58 <startling> compare x y
21:54:26 <djahandarie> Your type is recursive. That means everything which says anything interesting about values of your type is going to be recursive.
21:54:49 <dmj> yes
21:54:53 <djahandarie> Since this is a fairly simple recursive type, most of the recursion in your functions will also be simple.
21:55:12 <rwbarton> do you know how to write the definition as a stand-alone function?
21:55:20 <rwbarton> forgetting about the whole type classes/instance thing
21:55:20 <dmj> yes, I believe the implementation is complete but the pattern is not exhaustive
21:55:43 <dmj> :rwbarton I'm not sure
21:55:49 <dmj> rwbarton: not sure
21:55:54 <startling> dmj, we'd need to see your code to tell you
21:56:03 <dmj> don't know how to use irc either
21:56:14 <dmj> k let me hpaste
21:56:21 <dmwit> Didn't startling give the answer already?
21:56:56 <nand`> how do you solve 1+x < 1+y; 1+x = 1+x or 1+x > 1+y ?
21:57:59 <dmj> oh
21:58:33 <dmj> compare S x S y = x > y = LT
21:58:40 <dmj> GT*
21:58:53 <startling> no, that's silly
21:59:09 <dmj> :) I forgot some equal signs in my hpaste
21:59:32 <hpaste> meh annotated “NaturalNumber” with “NaturalNumber (annotation)” at http://hpaste.org/76473#a76474
22:00:24 <dmj> any idears?
22:00:57 <glguy_> dmj: everyone else knows the answer but they are holding back from just telling you, I suspect
22:00:58 <startling> you'll need some parens around (S x) and (S y)
22:01:04 <liyang> Annotated natural numbers? Why those are lists!
22:01:07 <startling> glguy_: no, we already told him
22:01:12 <dmj> ok ok
22:01:12 <dmj> don't tell me
22:01:18 <dmj> well I didn't get the hint
22:01:28 <startling> dmj, given some arbitrary numbers, how do you tell the ordering of them?
22:01:48 <startling> dmj, it wasn't a hint, I gave you literal code a pageful or so up
22:01:52 <rwbarton> nand`'s hint was a good one
22:01:57 <byorgey> that's probably not useful because no one thinks about numbers using the Peano axioms.
22:02:00 <dmj> I would use comparison operators
22:02:16 <rwbarton> yeah, that is a fair answer :)
22:02:26 <startling> okay. so how do you tell the ordering of (S x) and (S y) ?
22:02:31 <startling> hint: you already wrote the code
22:02:35 <nand`> dmj: is 1+x > 1+y if x > y ?
22:02:35 <rwbarton> < nand`> how do you solve 1+x < 1+y; 1+x = 1+x or 1+x > 1+y ?
22:02:52 <nand`> err, is 1+x < 1+ if x > y ?
22:02:55 <dmj> yes nand
22:03:20 <nand`> the first one is correct, I meant to type the latter; since that's what you did earlier (“compare (S x) (S y) | x > y = LT”)
22:03:22 <ion> Btw, compare S x S y parses as ((((compare S) x) S) y)
22:03:27 <nand`> remember, LT means that S x < S y
22:03:50 <rwbarton> he left out a lot of punctuation of all kinds. :)
22:04:10 <rwbarton> but it was obvious what was meant
22:04:17 <nand`> two pairs of parentheses and he swapped a | for a =, to be precise
22:04:23 <nand`> but yes
22:04:37 <rwbarton> oh i didn't notice his second bit of code
22:04:40 * lispy expected nand` to say, "but who's keeping track?"
22:05:32 <dmj> i need to use gaurds ?
22:05:42 <startling> not at all.
22:05:49 <hpaste> meh annotated “NaturalNumber” with “NaturalNumber (annotation) (annotation)” at http://hpaste.org/76473#a76475
22:06:09 <nand`> not necessarily, but I personally think guards would be a first approach, after which the ‘real’ solution becomes apparent
22:06:51 <startling> fair enough
22:07:19 <tac> @type forever
22:07:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
22:07:27 <hpaste> meh annotated “NaturalNumber” with “NaturalNumber (annotation) (annotation) (annotation)” at http://hpaste.org/76473#a76476
22:07:31 <dmj> I see
22:07:34 <tac> @type forever $ print "a"
22:07:36 <lambdabot> forall b. IO b
22:07:40 <dmj> i was wondering how I was going to do the <= part
22:07:56 <tac> isn't that a bit of a lie to say that forever f takes on IO b for all b? >___>
22:08:04 <dmj> i have to go to bed, haskell class tomorrow
22:08:22 <dmj> thanks nand
22:08:23 <ion> tac: It returns IO b for all b, yes.
22:08:27 <nand`> dmj: while the implementation behaves correctly, note that lines 8 and 9 contain a small redundancy
22:08:27 <dmj> and rwbarton
22:08:38 <tac> there's no b involved. It's a lie. In the most technical sense of the word!
22:08:38 <lispy> tac: it never produce the b
22:08:46 <tac> right
22:08:54 <nand`> dmj: in particular, if x/=y, then x <= y implies x < y
22:09:10 <lispy> tac: but that's different than taking on the type
22:09:20 <tac> yes, yes
22:09:26 <tac> it's a convenient lie
22:09:27 <tac> a white lie
22:09:46 <lispy> tac: are you familiar with the type of fix?
22:09:49 <lispy> :t fix
22:09:50 <lambdabot> forall a. (a -> a) -> a
22:10:03 <nand`> dmj: also, to perhaps wrap things up, the optimization you'd want to place on this is to note that ‘x == y  = EQ | x < y = LT | x > y = GT’ is exactly the operation ‘compare’ encapsulates
22:10:06 <nand`> so you can simply use = compare x y
22:10:32 <nand`> I hope he got that :(
22:10:32 <glguy_> It's not a lie, all of the values (there are none) that are produces have whatever type you want
22:11:06 <glguy_> Like "All of my fighter jets are blue"
22:11:12 <tac> lispy: oh yeah. Fix is the biggest liar of all.
22:11:21 <coldpizza72i> Can someone help me fix this error http://ideone.com/aFnF2
22:11:24 <tac> lispy: I'm writing up an article on total functional programming.
22:11:42 <tac> and I was curious about the type of forever in particular
22:11:49 <nand`> tac: it's actually not a lie if you go into denotational semantics and consider ⊥ as an additional member of every type
22:12:16 <tac> nand`: me and denotational semantics never got along. That's why I'm writing an article on TFP.
22:12:31 <nand`> eg. ‘Bool’ has True, False and ⊥ (indeterminate)
22:13:27 <nand`> so for example ‘undefined’ or ‘fix id’ can have types forall a. a  because they evaluate to ⊥ which is a member of every type
22:13:37 <nejucomo> Is there a standard / better way to do: mapTuple (f, g) (a, b) = (f a, g b)
22:13:43 <coldpizza72i> nermind i got it working
22:14:01 <nand`> (in fact, the type signature alone tells you that this is the only possible behavior they can have)
22:14:17 <ion> nejucomo: mapTuple = uncurry (***)
22:14:27 <nand`> which is advantageous in the case of forever; because even a non-english speaker could look at IO a -> forall b. IO b and understand that the action never terminates
22:14:37 <tac> nand`: right right.
22:14:49 <tac> However _|_ becomes the exception you have to always keep in mind
22:15:03 <tac> and always is a long time.
22:15:04 <nejucomo> ion: Woah.  Thanks.
22:15:08 * nejucomo rtfms (***)
22:15:13 <tac> Almost as long as forever, but not subject to CTRL+c
22:15:23 <nand`> if you're into total programming; forever :: IO a -> IO Void ?
22:15:52 <nand`> though that isn't total programming
22:15:55 * nejucomo hasn't run into Category or Arrow.
22:16:04 <nand`> I think..
22:16:05 <ion> nejucomo: Ignore the scary Arrow stuff for now, you can think of (***)as the following for this purpose:
22:16:15 <ion> @type (***) `asAppliedTo` (undefined :: a -> b)
22:16:16 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
22:16:22 <tac> nand`: ahhhhhhh
22:16:39 <tac> nand`: You may very well have caught a mistake of mine
22:17:14 <rwbarton> that is a good phrase
22:17:22 <nejucomo> ion: Awesome, thanks.
22:17:30 <aupif> hello.
22:17:37 <tac> although I'm not sure
22:17:47 <ion> nejucomo: Another useful function is
22:17:56 <ion> @type (&&&) `asAppliedTo` (undefined :: a -> b)
22:17:57 <lambdabot> forall b c c'. (b -> c) -> (b -> c') -> b -> (c, c')
22:18:21 <startling> &&& is so useful
22:18:23 <nejucomo> :i asAppliedTo
22:18:28 <lispy> nand`: There should be an analog in TFP to forever. It could, for instance, operate on co-data
22:18:30 <aupif> has anyone installed/used hmatrix here?
22:18:38 <mikeplus64> why is OverloadedStrings on by default in ghci, and not normal ghc? (ps, how do i make it on by default?)
22:18:38 <lispy> aupif: yes
22:18:49 <ion> asTypeIn :: a -> (a -> b) -> a ; a `asTypeIn` f = a where { _ = f a } ; infixl 0 `asTypeIn`; asAppliedTo :: (a -> b) -> a -> a -> b ; f `asAppliedTo` x = f `asTypeIn` ($ x) ; infixl 0 `asAppliedTo`
22:18:52 <nejucomo> Oh, yeah, I just needed (&&&) like three times on this same codebase.
22:19:10 <aupif> lispy: cool, I am having some trouble installing it with cabal right now, but I was wondering how people like it
22:19:14 <startling> (&&&) id is cool, too
22:19:16 <mikeplus64> i mean with ghc 7.6.1
22:19:20 * djahandarie doesn't use Control.Arrow stuff unless he's trying to golf
22:19:27 <nejucomo> Hrm.  So (***) is an operator, but it has three arguments?
22:19:30 <ion> startling: Or join (,)
22:19:32 <nejucomo> How does that work?
22:19:35 <lispy> aupif: it's fast and accurate
22:19:35 <aupif> lispy: should I persist and keeping trying to tame cabal?
22:19:48 <startling> ion: that's different, isn't it?
22:19:53 <aupif> lispy: that sounds like what I want from a numerical algebra library!
22:19:53 <startling> > join (,) 12
22:19:54 <lambdabot>   (12,12)
22:20:02 <startling> > (id &&& (+ 1)) 12
22:20:03 <lispy> aupif: what OS are you installing on? On OSX I had to do a trick to deal with iconv linking but it was otherwise easy
22:20:03 <lambdabot>   (12,13)
22:20:03 <aupif> lispy: did you use cabal for the install?
22:20:10 <ion> startling: Uh, indeed. Sorry.
22:20:11 <aupif> lispy: ubuntu
22:20:26 <lispy> aupif: did you install the "-dev" libraries that it needs?L
22:20:31 <rwbarton> nejucomo: well (***) takes two functions and returns a function
22:20:45 <startling> ion: \f -> fmap f . join (,)
22:21:02 <ion> nejucomo: (a ^-^ b) = (^-^) a b; therefore (a ^-^ b) c = (^-^) a b c
22:21:43 <startling> > let (-_-) = (+) in 1 -_- 2
22:21:45 <nejucomo> Ah, this looks best to me: (a *** b) c
22:21:46 <lambdabot>   <no location info>: Parse error in pattern
22:21:50 <startling> aw
22:22:14 <aupif> lispy: I think so, except I couldn't find libgs10-dev on apt-get
22:22:28 <aupif> lispy: trying to figure out what to replace it with
22:22:32 <lispy> aupif: what error are you getting?
22:24:04 <aupif> lispy: I just found libgs-dev, I'll try that. The error I get is simply "ExitFailure 1" from cabal.
22:24:15 <aupif> lispy: when I run cabal install hmatrix
22:24:42 <rwbarton> hopefully there will be a real error further up
22:24:51 <mikeplus64> is there an unsigned/only positive equivalent to Integer?
22:25:17 <aupif> lispy: I think this pacakage will fix it. out of curiosity, do you use matlab, numpy/scipy or octave day to day? Where does hmatrix fit in for you?
22:25:31 <lispy> mikeplus64: nothing in base, as far as I know. Maybe on hackage?
22:25:51 <ion> nejucomo: The fixity of -> in types is as follows: a -> b -> c -> d = a -> b -> (c -> d) = a -> (b -> (c -> d)). One can freely think of (***)’s type in the function case as (a->b) -> (c->d) -> ((a,c) -> (b,d)); the same applies to fmap: (a -> b) -> (f a -> f b) etc.
22:26:04 <startling> mikeplus64, word
22:26:06 <aupif> lispy: hmatrix-0.14.1.0 failed during the building phase. The exception was:
22:26:06 <aupif> ExitFailure 1
22:26:10 <startling> kind of
22:26:10 <lispy> aupif: I know of those but I don't use them. I got the same results from hmatrix as I did from R and found hmatrix more natural so I stopped using R
22:26:29 <aupif> lispy:  *** Sorry, I can't link GSL.
22:26:50 <lispy> startling: Word is not the same as Integer if mikeplus64 was hoping for arbitrary precision
22:26:56 <aupif> lispy: which is the library I'm having trouble with, although I jsut installed libgsl-dev
22:27:29 <mikeplus64> startling: lispy: yeah, i'm hoping for arbitrary precision
22:27:41 <aupif> lispy: oh damn, I thought one character was a 1, but it was the letter 'l'--this might do it!
22:28:09 <startling> mikeplus64: understood
22:28:12 <lispy> mikeplus64: I'd check hackage
22:28:17 <aupif> lispy: oh cool. I've used R, but I'm a hardcore numpy guy now. I'd like to use haskell more though, so I thought this would be cool to try
22:28:37 <lispy> mikeplus64: AFAIK, it doesn't exist and I'm not sure if gmp provides one or how much work it would be to link to it if it did.
22:28:47 <mikeplus64> lispy: there is largeword, but that's not arbitrary precision (if only hoogle was better at searching...)
22:29:13 <lispy> mikeplus64: But here is a trick you can use.
22:29:27 <lispy> mikeplus64: newtype Nat = Nat Integer
22:29:34 <startling> mikeplus64, you could wrap integers and only use constructors that cancel out negatives
22:29:38 <aupif> lispy: it worked! now I can play with linear algebra in haskell, yay.
22:29:40 <startling> or error on negatives
22:30:03 <lispy> mikeplus64: then you have mkNat n | n < 0 = error "Nope" | otherwise = Nat n
22:30:10 <mikeplus64> i might just use Word64, 2^64 is probably large enough
22:30:27 <mikeplus64> just erroring at runtime at negatives i couldn't bring myself to
22:30:34 <rwbarton> there is a Word128 on hackage
22:30:48 <lispy> mikeplus64: the point is that once you get into the Nat type you don't have to consider negatives
22:30:51 <nejucomo> ion: Right, I understood the fixity, but I suppose I meant more of a style question.  I thought: a <op> b c  looks weird because it looks like b and c are somehow "more closely" related.
22:31:20 <nejucomo> I like (a *** b) c  -in this case because it "makes sense" to me (building a new function out of a and b).
22:31:22 <lispy> aupif: have fun!
22:31:22 <ion> a ^-^ b c parses as (^-^) a (b c)
22:31:24 <rwbarton> nejucomo, usually the result of (***) is a function you pass to map or zipWith or something.
22:31:29 <rwbarton> probably not zipWith.
22:31:55 <rwbarton> e.g.
22:32:17 <rwbarton> > map (head &&& length) . group $ "...---..." -- oops this one was (&&&), but same idea
22:32:20 <lambdabot>   mueval-core: Time limit exceeded
22:32:23 <rwbarton> excellent
22:32:35 <rwbarton> > map (head &&& length) . group $ "...---..." -- oops this one was (&&&), but same idea
22:32:37 <lambdabot>   [('.',3),('-',3),('.',3)]
22:33:06 <nejucomo> Nice.
22:33:44 <rwbarton> mikeplus64, I would assume the whole reason to use Natural would be to get runtime errors on underflow
22:34:00 <rwbarton> unless you just don't want to allow (-) at all, but then that is annoying in its own way (can't use Num)
22:34:11 <ion> > zipWith (***) [pred, id, succ] [id, (*10), (*100)] <*> pure (5, 5)
22:34:12 <lambdabot>   [(4,5),(5,50),(6,500)]
22:34:23 <ivanm> aupif: lemme guess: you don't have the necessary C libraries installed?
22:34:44 <startling> > let a ^^^ b = b `ap` [a] in 12 ^^^ [(+ 1), (+ 2)]
22:34:44 <ivanm> or do you have GHC-7.6 and some changes were made which hmatrix doesn't support yet?
22:34:45 <lambdabot>   [13,14]
22:34:53 <startling> I've always felt that that would be a nice addition
22:35:01 <nejucomo> Now I'm trying to figure out what instance of Arrow I'm using...
22:35:08 <startling> nejucomo: (->)
22:35:30 <ion> λ> :i Arrow
22:35:32 <ion> instance Arrow (->) -- Defined in `Control.Arrow'
22:35:35 <aupif> ivanm: yeah, that's what happened. It's working now, though :)
22:36:12 <nejucomo> Ah (->).
22:36:15 <nejucomo> Right.
22:36:57 * nejucomo attempts to grok arr.  Need to play with other instances.
22:38:19 <byorgey> startling: (a ^^^) = map ($a)
22:38:27 <byorgey> > map ($12) [(+1), (+2)]
22:38:28 <lambdabot>   [13,14]
22:38:50 <startling> byorgey: oh, that's right
22:39:02 <byorgey> you can even write  (^^^) = map . ($)
22:39:07 <startling> :t arr
22:39:08 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
22:39:08 <byorgey> though that's pretty unreadable
22:39:23 <startling> nejucomo: it just lifts a function into an arrow
22:40:55 <ion> That doesn’t mean much if you haven’t studied arrows yet. :-)
22:41:09 <lispy> If I wanted to learn about type schemas, what is a good online introduction or paper? google is failing me (too much xml and other stuff)
22:41:43 <startling> ion: true, I guess
22:41:58 <byorgey> lispy: you mean type schemes? as in the things Hindley-Milner uses?
22:42:29 <lispy> byorgey: yes (sorry, I haven't even been able to find where they get defined/used)
22:42:44 <lispy> Maybe using schemes instead of schema I'll have better luck
22:43:11 <byorgey> lispy: well, there's really nothing to it: it just means polymorphic types where all the forall's must come at the beginning
22:43:20 <byorgey> i.e. no rank-n types for n > 1
22:43:31 <lispy> ah
22:44:08 <byorgey> lispy: for historical interest you may be interested in the original paper on Hindley-Milner, though it's actually rather difficult to follow because the notation is so foreign
22:45:03 <byorgey> Damas, Milner (1982), "Principal type-schemes for functional programs". 9th Symposium on Principles of programming languages (POPL'82)
22:46:27 <lispy> byorgey: thanks
22:46:45 <lispy> byorgey: I just found this and started reading it: http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/TYPE/BasicTypechecking.pdf
22:46:50 <lispy> byorgey: it seems like a nice survey
22:47:31 <byorgey> lispy: you can also read the wikipedia page on Hindley-Milner, it seems reasonable
22:47:38 <byorgey> ah, yes, that looks like a nice survey indeed
22:51:02 <nejucomo> Hrm...  I have two Maps, and I want a function like: unionMaybe :: (Maybe a -> Maybe b -> c) -> Map k a -> Map k b -> Map k c
22:51:36 <lpvb> does haskell have the kind of fault tolerent distributed concurrency that erlang has?
22:53:55 <ion> lpvb: See http://hackage.haskell.org/package/distributed-process
22:54:52 <lpvb> is that as powerful as erlang's implementation?
22:55:21 <rwbarton> probably not (yet). it is quite new
22:56:30 <applicative> lpvb they just put it on hackage recently and are writing a tutorial via blog posts http://www.well-typed.com/blog/
22:57:27 <johnw> I don't think it has the same process-restart behavior that erlang has
22:57:36 <johnw> but many of the concepts seem very similar
22:58:33 <ion> It doesn’t provide hot code updates or per-process garbage collection, but it’s modeled very closely like the Erlang implementation. OTOH, it will provide some things Erlang/OTP doesn’t, namely pluggable network backends and transports, static typing etc. You might find this talk interesting. http://skillsmatter.com/podcast/home/cloud-haskell
22:59:05 <ion> If you mean the OTP supervisor, someone will implement that using the primitives sooner or later. In OTP, it’s implemented using the same primitives.
23:01:08 <dagle> Whats the name of the package that lets you remove all parameters and lambdas from a function? (for fun etc)
23:01:21 <dagle> package / tool
23:01:32 <johnw> you mean, @pl?
23:01:37 <dagle> Yes.
23:01:38 <dibblego> dagle: cabal install pointfree
23:01:42 <sp3ctum> applicative, thanks for the link to the blog posts about cloud haskell. i'll read them too
23:01:42 <johnw> @pl \x -> x + y
23:01:42 <lambdabot> (y +)
23:01:45 <dagle> Ah, pointfree.
23:01:47 <dagle> ty
23:01:48 <johnw> yes
23:01:51 <startling> pointless
23:01:58 <johnw> it's called pointfree on hackage
23:02:00 <dagle> I even have it installed. :)
23:02:16 <startling> http://hackage.haskell.org/package/pointless-haskell is one, too. :)
23:02:24 <johnw> ah, good to know1
23:02:28 <dibblego> echo ":def pl \s -> return $ ":! pointfree \"" ++ s ++ "\""" >> ~/.ghci
23:02:39 <startling> oh, pointfree actually does the pl-ing, though
23:02:53 <startling> pointless is just a library for clever point-free functions
23:02:56 * lispy goes to watch the daily show, obama should be on
23:04:03 <johnw> yes
23:04:09 <johnw> you're thinking of Data.Function.Pointless
23:04:42 <dibblego> echo ":def pl \s -> return $ \":! pointfree \" ++ s ++ \"\\\"\"" >> ~/.ghci -- correction, sorry
23:06:28 <dagle> @pl \x -> flip (>>=) (print . (###) (length . lines, length . words, length)) (readFile p)
23:06:28 <lambdabot> const (print . ((length . lines, length . words, length) ###) =<< readFile p)
23:06:44 <dagle> @pl \x -> flip (>>=) (print . (###) (length . lines, length . words, length)) (readFile x)
23:06:44 <lambdabot> (print . ((length . lines, length . words, length) ###) =<<) . readFile
23:06:48 <dagle> :)
23:07:40 <johnw> next you'll need @unpl to make sense of your pointfree functions :)
23:07:49 <johnw> @upl (. f) . g
23:07:49 <lambdabot> Maybe you meant: pl unpl url
23:07:52 <johnw> @unpl (. f) . g
23:07:53 <lambdabot> (\ d i -> g d (f i))
23:08:48 <johnw> I want a bumper sticker that reads, "Haskell programmers do it in a monad."
23:09:04 <johnw> (quoting the Cloud Haskell talk)
23:09:54 <startling> johnw: "...and can't get out"
23:10:07 <johnw> i can get out of most monads
23:10:09 <johnw> just not IO!
23:10:34 <tac> I enjoy monads I can *sometimes* get out of
23:10:40 <tac> It makes for a nice surprise when I get stuck
23:10:55 <startling> johnw: something bind something bdsm
23:10:55 <Ralith> johnw: so what you're saying is you can get out so long as you haven't affected your partner?
23:11:12 <ion> lpvb: (Highlight. See my messages from a while ago.)
23:11:15 <tac> startling: Don't forget about http://www.haskell.org/haskellwiki/Tying_the_Knot
23:11:21 <johnw> i can get out when I'm ready to commit
23:11:24 <startling> tac: haha
23:12:13 <lpvb> ion: I saw them and bookmarked them for later, thanks
23:27:38 <ski> @djinn Maybe a -> a
23:27:38 <lambdabot> -- f cannot be realized.
23:28:57 <shachaf> @djinn Maybe (a -> a)
23:28:57 <lambdabot> f = Nothing
23:30:37 <johnw> @djinn a -> Maybe a
23:30:37 <lambdabot> f = Just
23:30:48 <Nisstyre> @djinn (Maybe a -> a) -> (Maybe a -> a)
23:30:48 <lambdabot> f a = a
23:31:13 <shachaf> @djinn Maybe ((Maybe a -> a) -> Maybe a -> a)
23:31:13 <lambdabot> f = Nothing
23:33:42 <pordan30> re djinn: so is there a standard empty data declaration for false, or are there no actually empty data declarations since bottom inhabits all of them?
23:33:52 <ski> @djinn Maybe (Maybe a -> a) -> Maybe a
23:33:52 <lambdabot> f a =
23:33:52 <lambdabot>     case a of
23:33:52 <lambdabot>     Nothing -> Nothing
23:33:52 <lambdabot>     Just b -> Just (b (Just (b Nothing)))
23:34:04 <rwbarton> bottom doesn't exist to djinn
23:34:23 <ski> djinn has `data Void', though
23:34:34 <shachaf> Yes, which is uninhabited.
23:34:38 <shachaf> (Unlike Haskell's data Void.)
23:34:53 <ski> (and `void :: Void -> a; void v = case v of {}')
23:35:03 <rwbarton> @djinn Void -> a
23:35:04 <lambdabot> f = void
23:35:30 <shachaf> Just b -> Just (b (Just (b Nothing)))
23:35:32 <shachaf> That's amusing.
23:36:11 <shachaf> I guess its heuristic is more complicated than I thought.
23:36:29 <tac> can djinn not solve any equation it parses?
23:36:40 <ski> @djinn a -> b
23:36:40 <lambdabot> -- f cannot be realized.
23:36:44 <ski> @djinn a -> a
23:36:44 <lambdabot> f a = a
23:36:50 <tac> not solve in that sense
23:36:54 <tac> prove or disprove
23:37:03 <ski> it can solve some, and can't solve some
23:37:09 <tac> can it decide any term it parses*
23:37:11 <shachaf> ski: I thought it could solve any?
23:37:19 <shachaf> In tac's sense.
23:37:25 <shachaf> Rank 1, of course.
23:37:29 <ski> (if by "solve" you mean "find a proof of")
23:37:45 <ski> afaic, it is total, yes
23:37:50 <tac> kk
23:38:01 <tac> It's just STLC + a few builtins
23:38:57 <pordan30> ski, rwbarton: thanks; i found the hackage package defining it
23:39:15 <ski> @where djinn
23:39:15 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
