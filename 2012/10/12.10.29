00:14:23 <gatlin> I was recently introduced to the concept of iteratees, and so now of course everything looks like one. However, I was also recently introduced to arrows. If an iteratee is an automaton in a given state that returns the next state for a given input, how could I frame arrows in relation?
00:16:51 <nand`> you mean like Automaton a b ~ a -> (b, Automaton a b) ?
00:25:31 <gatlin> nand`: Yes
00:25:57 <gatlin> This is predicated on me having a correct understanding of iteratees, but that's my understanding of them
00:27:54 <nand`> the only thing I know is that Automaton is an Arrow
00:30:12 <gatlin> I'm concurrently reading over definitions and explanations but it seems like arrows model the actual automaton, and iteratees model the transformations from one state to another (if we are using automata as a reference to define both)
00:30:24 <gatlin> but that seems to make sense
00:39:02 <shachaf> Hmm, I'm not sure what's going on here.
00:39:19 <shachaf> Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
00:40:05 <shachaf> holesOf :: ((c -> Bazaar c c c) -> a -> Bazaar c c a) -> a -> [Context c c a]
00:40:59 <shachaf> Why doesn't holeOf :: Lens a a c c -> a -> [Context c c a] unify?
00:41:12 <shachaf>     Couldn't match type `(c -> Bazaar c c c) -> a -> Bazaar c c a' with `forall (f :: * -> *). Functor f => (c -> f c) -> a -> f a'
00:41:46 <shachaf> Have I forgotten how rank2 types work or something?
00:42:50 <Saizan> if something is specialized to Bazaar it can't get the more general type
00:43:09 <nand`> let holeOf x = holesOf x; holeOf :: Lens a a c c -> a -> [Context c c a]
00:43:11 <nand`> works for me
00:43:15 <nand`> or is that not what you meant?
00:43:20 <shachaf> Saizan: It's rank-2.
00:43:38 <shachaf> Saizan: Taking a more specialized argument should make holesOf more general.
00:43:50 <shachaf> nand`: "holeOf" was just a typo.
00:44:03 <Saizan> yeah, but it won't work just by ::
00:44:13 <Saizan> you have to do like nand` and eta-expand
00:44:18 <shachaf> Right, that works.
00:44:23 <nand`> but yeah; \x -> holesOf x works
00:44:24 <shachaf> Thanks.
00:44:53 <Ralith> why is that necessary?
00:45:23 <nand`> I'm not too sure about the specifics of it; but it doesn't auto-specialize the rank-2 type or something I guess
00:47:57 <nand`> man; so many more more-or-less useless renamings - holesOf, holesOn, holesOnOf
00:48:25 <shachaf> waxOf waxOn waxOnOf
00:48:54 <nand`> switchOnOff
00:49:04 <Saizan> you can use :: to go from map to map @ Int @ Int but not from holesOf to \x -> holesOf (x @ (Bazaar c c)), it won't add lambdas
00:49:31 <shachaf> I don't like eta-expansion.
00:49:37 <Saizan> (where @ is explicit type application like in Core)
00:51:51 <nand`> (is there a reason you want to make it rank-2? Generally the nice thing about the lens combinators is that they accept a lot of lenslikes, eg. you can read out a traversal if what you're reading is a monoid; due to the applicative instance it pulls in)
00:51:58 <shachaf> compound5 l l' l'' l''' l'''' = lens (\(a, (a', (a'', (a''', a'''')))) -> (view l a, (view l' a', (view l'' a'', (view l''' a''', view l'''' a'''')))) ) (\(a, (a', (a'', (a''', a'''')))) (b, (b', (b'', (b''', b'''')))) -> (set l b a, (set l' b' a', (set l'' b'' a'', (set l''' b''' a''', set l'''' b'''' a'''')))) )
00:52:06 <shachaf> Ah, good old lens.
00:52:21 <nand`> is that an actual definition somewhere?
00:52:26 <shachaf> It's in a benchmark.
00:52:36 <shachaf> nand`: I'm changing the types in lens itself.
00:52:58 <shachaf> That's the actual type of holesOf, and its example is wrong.
00:53:05 <shachaf> Er, its specialization.
00:53:17 <shachaf> (Not wrong in this sense, wrong in the kind error sense.)
01:13:39 * hackagebot dns 0.3.6 - DNS library in Haskell  http://hackage.haskell.org/package/dns-0.3.6 (KazuYamamoto)
01:23:39 * hackagebot easy-file 0.1.1 - Cross-platform File handling  http://hackage.haskell.org/package/easy-file-0.1.1 (KazuYamamoto)
01:28:39 * hackagebot cryptohash 0.7.6 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.6 (VincentHanquez)
01:30:35 <Jafet> Hey, SHA-3 isn't in there.
01:35:34 <fishmanthing> quit
01:38:41 <pharaun> still a little soon i think :)
01:45:46 <hpaste> Test pasted ‚ÄúTest‚Äù at http://hpaste.org/76936
01:58:40 <beaky> http://www.txt.io/t-2kv5h
02:01:18 <beaky> cabal seems to be a headache :(
02:01:50 <Ralith> sounds like the author has a serious chip on his shoulder
02:03:17 <donri> beaky: did you write this crap?
02:04:10 <beaky> I didn't write it, but I just had similar experiences :(
02:04:40 <nand`> seems to be related more to cabal-install than cabal
02:05:26 <donri> oh it's that guy we helped the other day
02:06:27 <beaky> :D
02:06:57 <nand`> my catch-all solution to any and all packaging woes related to haskell has been to use portage
02:07:23 <gdeest> There is some truth to it ; that's why I have a VM ready for Yesod development, with all required packages installed
02:07:23 <Ralith> no good deed goes unpunished
02:08:22 <hamid> @src return
02:08:23 <lambdabot> Source not found. I am sorry.
02:08:30 <hamid> no source? :|
02:08:33 <nand`> @src Monad
02:08:34 <lambdabot> class  Monad m  where
02:08:34 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
02:08:34 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
02:08:34 <lambdabot>     return      :: a -> m a
02:08:34 <lambdabot>     fail        :: String -> m a
02:09:04 <hamid> Thank you nand`
02:09:17 <donri> gdeest: oh, sure. cabal has lots of issues, and yesod is especially difficult to build right. but the post is mostly ignorant FUD.
02:09:30 * nand` tries installing yesod from scratch
02:09:32 <nand`> just for fun
02:09:48 <beaky> how does yesod compare to node.js?
02:09:52 <nand`> well, ‚Äòfrom scratch‚Äô meaning ‚Äúin my current environment, as-is, without having yesod installed previously‚Äù
02:10:00 <dp_wiz> beaky, it doesn't
02:10:14 <zomg> beaky: node is a runtime, yesod is a web framework
02:12:42 <beaky> ah I thought node.js was a framework
02:13:53 <donri> nand`: me too, just for fun. it says it will break some 35 packages or so. doing a force reinstall. just for fun.
02:14:54 <zomg> beaky: yeah it's essentially a JS runtime with some low level networking libs and such
02:15:58 <nand`> hmm, it seems to build and install fine for me; but ‚Äòyesod devel‚Äô gives me an unnamed ‚ÄòBuild failure‚Äô
02:17:19 <nand`> that's odd; there's a .cabal file but no Setup.hs
02:18:20 <nand`> either way, it works fine up to this point: http://bpaste.net/show/54256/
02:24:30 <nand`> and here's the corresponding uninstall log: http://bpaste.net/show/54258/
02:24:38 <nand`> system still works fine afterwards
02:24:42 <donri> it failed for me \o/
02:24:52 <donri> http://www.reddit.com/r/programming/comments/127yok/why_inbreeding_is_bad_for_your_community/c6taeeb
02:25:20 <zomg> nand`: ghc version?
02:25:31 <nand`> 7.6.1
02:25:49 <zomg> Yeah I don't know if yesod really supports 7.6 yet
02:25:59 <zomg> Seems people have issues running it with that, it should work with 7.4
02:26:13 <nand`> okay
02:26:25 <nand`> If I really wanted to
02:26:36 <nand`> I could downgrade ghc to 7.4.2, install yesod, prove my point, and upgrade back to 7.6.1
02:26:41 <nand`> without breakage
02:27:11 <zomg> heh
02:28:11 <Danon> hey
02:33:40 * hackagebot btree-concurrent 0.1.0 - A backend agnostic, concurrent BTree  http://hackage.haskell.org/package/btree-concurrent-0.1.0 (JohanBrinch)
02:33:42 * hackagebot simple-config 1.2.0 - Simple config file parser generator  http://hackage.haskell.org/package/simple-config-1.2.0 (YusukeNomura)
02:35:19 <GnomeStoleMyBike> \o Hi All
02:38:40 * hackagebot btree-concurrent 0.1.1 - A backend agnostic, concurrent BTree  http://hackage.haskell.org/package/btree-concurrent-0.1.1 (JohanBrinch)
02:42:35 <ClaudiusMaximus> how to find a nullVector for a 2x2 real matrix in pure haskell?  hmatrix is a pretty heavy dependency, and looking at its source got me confused with various SVD calls and epsilon hints and such
02:43:41 * hackagebot simple-config 1.2.1 - Simple config file parser generator  http://hackage.haskell.org/package/simple-config-1.2.1 (YusukeNomura)
02:48:48 <nand`> After I'm done playing through Skyward Sword, I feel like making a haskell library for interacting with the Wii Remote+; preferably on a more higher level than the current hcwiid binding
02:49:01 <nand`> Would anybody be interested in contributing to or using a project like that?
02:49:28 <adimit> nand`: I would be!
02:49:43 <nand`> what would be great is to get the abstraction to a level where you basically just get a vector in ‚Ñù¬≥ corresponding to the wii remote's orientation
02:49:52 <adimit> I've been kicking arond the idea of actually writing something up to use my wii remote with linux.
02:50:18 <Jafet> ClaudiusMaximus: <0, 0>?
02:50:33 <adimit> the wii remote with motion plus is actually a very nice device.
02:54:18 <Stark> How can i Import Char in haskell?
02:54:36 <nand`> Char should be imported by default, it's in the Prelude
02:54:39 <ClaudiusMaximus> Jafet: it's a basis vector for a 1d kernel/null subspace
02:54:51 <pordan30> import Data.Char or use Char
02:54:52 <ClaudiusMaximus> Jafet: or something along those lines, not entirely sure how hmatrix does it
02:54:54 <nand`> but in case you explicitly want to, it's in Data.Char
02:55:00 <Stark> Because he cant find "toLower"
02:55:07 <nand`> oh, that's in Data.Char
02:55:13 <arvraepe> ^
02:55:30 <Stark> How should I write it ?
02:55:37 <Stark> "import Data.Char" ?
02:55:40 <nand`> import Data.Char (toLower)  -- the (toLower) is optional
02:55:42 <Jafet> ClaudiusMaximus: for a 2x2 matrix the rows have to be dependent
02:55:42 <shachaf> Stark: Try it!
02:55:51 <Jafet> So divide one by the other and you get the nullspace basis
02:56:06 <Stark> thx i try it now
03:00:03 <Stark> -.-
03:02:38 <Stark> -.-
03:03:02 <Stark> whois
03:03:05 <Stark> WHOIS
03:04:34 <nand`> that's a PRIVMSG, not a WHOIS
03:06:16 <ClaudiusMaximus> Jafet: well, if they are dependent i can just pick the one with largest magnitude ?  i should see what hmatrix actually gives for some real-world examples, maybe i can gain an intuition...
03:07:23 <ketil> Anybody know where cabal stores the list of available packages/metadata?
03:08:20 <ketil> Ah, found it: 00-blah blah
03:13:40 <Jafet> <column, k*column> * <1, x>^T = <0, 0>^T is the definition of a 1-d nullspace; solve for x
03:19:09 <ClaudiusMaximus> > let v = [1,2] in (\[x, y] -> [-y,x]) $ map (/ sqrt (sum (map (^2) v))) v   -- assuming matrix is fromList (v ++ map (k*) v), this seems to give the same results as hmatrix for my stupid tests
03:19:11 <lambdabot>   [-0.8944271909999159,0.4472135954999579]
03:27:19 <t7> > let ooo = 'o' : ooo in 'w' : ooo
03:27:20 <lambdabot>   "wooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
03:30:10 <t7> what is nullspace?
03:30:27 <Jafet> Something I found in your mom
03:31:56 <randomclown> Found a kernel in his mom?
03:32:47 <Jafet> It was very rank
03:33:46 <beaky> I llike C++
03:34:44 <Jafet> C++ so big, I can't even make a yo momma joke on it
03:34:46 <doomlord> heh wrong channel
03:35:14 <doomlord> c++ seems untouchable for its niche
03:35:19 <int-e> beaky: repeat after me: "I like C++, but I like Haskell better." :-))
03:35:49 <doomlord> If you want a garbage collected runtime, you have so much choice in languages. if you can't use GC runtime, you're stuck with C++
03:36:52 <Jafet> In C++, you are the garbage collector
03:36:58 <int-e> @quote high-level
03:36:59 <lambdabot> int-e says: C++ does make a reasonably usable high-level assembler
03:37:34 <tac> have the semantics of hClose changed at some point?
03:38:05 <tac> I'm going through RWH again and doing the exercises, and I noticed that hClose'ing the handle immediately after an hGetContents doesn't ruin my picnic
03:38:48 <tac> I guess, I lied a little bit. I inserted a "take 10 contents" between the two calls
03:41:03 <hpaste> tactics pasted ‚ÄúWhy does the first one return all the input and the second returns ""?‚Äù at http://hpaste.org/76940
03:41:11 <p1key> can haskell be used for iterative programming?
03:41:28 <tac> iterative in the software engineering sense? p1key?
03:41:44 <p1key> Just in general.
03:42:18 <tac> If you're asking if it's good for building up a program a little at a time, and does well in the face of a changing software specification, I'd say so.
03:42:42 <tac> The type system means you have to do a lot of massage if you're going to refactor, but it also catches a ton of potential bugs in the process
03:42:45 <shachaf> In general, no. There exists a definition of "iterative programming" such that Haskell is not good for it.
03:43:27 <Jafet> "The programming that Haskell is not good for"?
03:43:29 <pordan30> only classically, though
03:44:11 <tac> @faq Is Haskell able to be a paradox?
03:44:12 <lambdabot> The answer is: Yes! Haskell can do that.
03:44:29 <shachaf> I much prefer romantic logic to classical logic.
03:44:32 <Jafet> tac: see what happens when you hSetBuffering NoBuffering
03:44:46 <int-e> tac: how big is input.txt?
03:44:56 <tac> Jafet: ahhhhhhhh yeah
03:45:04 <shachaf> doomlord: There are many languages that aren't C++ that aren't GCed. :-(
03:45:06 <tac> Jafet: that explains it. I got back just the first line
03:45:19 <tac> int-e: it's a full Haskell file
03:45:19 <companion_cube> shachaf: which do you have in mind?
03:45:22 <tac> So yeah
03:45:23 <companion_cube> I only count C and C++
03:45:28 <companion_cube> which ones*
03:45:41 <tac> wait hmm
03:45:43 <doomlord> i gather fortran still has a use, but you wouldn't use fortran instead of c++
03:45:48 <doomlord> or pascal
03:45:57 <int-e> tac: http://hackage.haskell.org/packages/archive/base/latest/doc/html/System-IO.html#v:hGetContents is informative actually
03:46:14 <doomlord> pascal #define { begin #define } end
03:46:17 <osfameron> doomlord: well, you would use fortran in those cases that you use fortran
03:46:30 <int-e> tac: what it means is that you should not use hClose at all if you plan to read the full input
03:47:02 <doomlord> i gather it has special support for array processing but c++ templates are very good at low level datastructures
03:47:02 <int-e> tac: (if you only read part of the input, you should do your processing first and close the file after you're done. lazy IO is tricky.)
03:47:12 <Jafet> We know that. tac is asking the silly question of why he is lucky enough for his program to work anyway.
03:47:16 <pordan30> there are several packages for generic binding constructs with de bruijn conversion lying around. do any come recommended?
03:48:01 <tac> Jafet: bingo
03:48:15 <tac> Why something works when it shouldn't is as important as knowing why something doesn't work when it should :)
03:48:31 <Jafet> doomlord: show me the C++ template that produces vectorized Cray opcodes
03:48:52 <osfameron> why are we talking about c++ though?
03:49:00 <Jafet> Because we're in #haskell
03:49:13 <doomlord> well i've seen c++ templates help a lot with AOS friendly SIMD maths libraries
03:49:35 <doomlord> intrinsics aren't part of C++ standard but are part of many implementations
03:49:58 * osfameron only ever uses C++ for programming Arduino...
03:50:20 <Jafet> Poor arduino.
03:50:24 <doomlord> <someone says 'i like c++',its triggered language rant>
03:50:25 <osfameron> I wasn't very impressed with the haskell bindings for that... they seemed to mostly involve including string snippets of literal C++ to get anything done
03:50:34 <tac> Odd. I tried LineBuffering and NoBuffering, and I'm still getting back the full file (when I take 200 instead of take 20)
03:51:19 <Jafet> You have disabled Handle buffering, but not fd buffering
03:51:33 <Jafet> I believe they're independent
03:51:47 <tac> so not this one? 	hSetBuffering hin LineBuffering
03:52:21 <doomlord> (..vectorized c++ .. you can make a maths library work on an arbitrary type then feed it a class that handles a SIMD register to make vectorized maths )
03:53:22 <doomlord> anyway it would be nice to have a non-gc language with haskel style type-inference, tuples, no header files, interfaces like go, context free gramar etc
03:53:57 <Jafet> Make one then
03:54:16 <t7> doomlord i used to think this, but its nearly 2012. I dont think its worth manual memory allocation anymore
03:54:36 <t7> however, a strict by default Haskell would be fun
03:54:42 <t7> 2013*
03:55:30 <doomlord> doens't matter if its 2112 .. there's times when one needs to reason about resource allocation explicitely. and yes i conceed, for most programming you dont
03:55:41 <Jafet> No one even does manual memory allocation any more. I can't remember the last time I used mmap to allocate a bunch of pages from the operating system.
03:55:45 <Rogach> t7: [1..] wouldn't be fun in strict Haskell :)
03:55:46 <quicksilver> having GC doesn't mean y ou can't reason about resource allocation.
03:55:57 <Jafet> malloc is not manual memory management -- it tells you nothing about memory usage
03:55:58 <quicksilver> in fact in general it doesn't even make it harder
03:56:16 <doomlord> C++ is used in contexts without malloc sometimes
03:56:27 <dzhus> Deps versions change, API of my library does not. which of a.b.c.d digits shall I bump?
03:56:31 <Jafet> In fact possibly work has been done on garbage collection (see Baker et al)
03:56:39 <fmap> dcoutts: are there any plans to fix bzlib on ghc-7.6? (it seems rather trivial)
03:56:51 <dzhus> and iconv :3
03:57:00 <Jafet> possibly more work
03:57:18 <dcoutts> fmap, dzhus: right they're probably easy, just been rather busy.
03:57:18 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
03:57:28 <dcoutts> patches gladly accepted
03:57:37 <osfameron> manual memory management might still be important on constrained devices? (arduino and such)
03:57:41 <Jafet> dzhus: www.haskell.org/haskellwiki/Package_versioning_policy
03:57:54 <doomlord> efficiency is energy bills...
03:58:11 <Jafet> Yes. I'm saying C and C++ do not actually provide manual memory management
03:58:25 <Jafet> Which corresponds to something like brk or mmap
03:58:32 <osfameron> hmm?
03:58:34 <gienah> dcoutts: sed -e 's@bytestring == 0\.9\.\*@bytestring@'\ -i bzlib.cabal :-)
03:58:52 <dcoutts> gienah: have you tested, is that all that's needed?
03:59:06 <gienah> dcoutts: yeah, it builds with ghc 7.6.1
03:59:13 <doomlord> i suppose you could describe an algorithm in haskell and provide hints to generate a specific implementation that has differrent memory use
03:59:17 <pordan30> i'd rather have evaluation strategies as language primitives, or section declarations: lazy f = ..., strict f = ..., f = g (lazy x), and so forth, with some default evaluation strategy
03:59:18 <doomlord> size/speed tradeoffs
03:59:48 <doomlord> i think clojure divides itself up a bit like that, eager loops and lazy sequences
04:00:05 <Jafet> doomlord: You can already do that in many ways, such as using RULES, SPECIALIZE, or something like hermit
04:01:04 <nand`> GHC Haskell has some strictness constructs as a language feature
04:01:07 <Jafet> pordan30: lazy is the default, and seq, pseq and evaluate provide strict
04:01:12 <nand`> mainly, -XBangPatterns
04:01:25 <rribeiro> Hello to all! I'm with some doubts related to type theory. Let t and t' be two types, we say that t <= t' if there's a substitution s such that s t = t'. Is there any necessary and sufficient conditions to say that if t1 <= t1' and t2 <= t2' then t1 t2 <= t1' t2'.
04:01:30 <nand`> which allow you to write argument-strict functions in a natural way
04:01:46 <doomlord> can you get much feedback of visualization of what its doing... would it be possible to essentially generate a c program from haskell (i dont mean c emulating the STG.. but having used haskell as the highest level description of an algorithm with a c program running in predictable memory as an implementation
04:02:20 <doomlord> (eg with operations sorted into specific passes as a c programmer would have done it manually)
04:02:32 <Jafet> rribeiro: t1 and t1' are substitutions; what you mean when you say t1 <= t1'?
04:02:33 <doomlord> just thinking out loud
04:02:46 <p1key> http://pastie.org/pastes/5131779/text?key=v1ugy5xxtxkxtsjpqg27mq would this be correct? according to my guidelines? http://ideone.com/2IhorB
04:02:52 <nand`> doomlord: GHC has a (now defunct, I think) C back-end
04:03:06 <nand`> but it's not very intuitive code to read, and is in ways just a literal implementation of an STG in C
04:03:15 <doomlord> i'm told the C backend doesn't handle the STG well
04:03:25 <Jafet> doomlord: you can write programs in an embedded language that is translated to C.
04:03:48 <nand`> yeah, that would be my approach for ‚Äògenerating C via Haskell‚Äô; use some EDSL and in-Haskell interpretation functions
04:04:01 <rribeiro> Jafet: Sorry if I don't make clear my point. t1, t1', t2, t2' are types.
04:04:21 <Jafet> rribeiro: then, what does t1 t1' mean?
04:04:53 <p1key> Anyone?
04:05:12 <rribeiro> Jafet: The type formed by the application t1 t1'. For instance, let t1 = [ ] and t1' = Int, so t1 t1' = [Int]
04:05:35 <srhb> p1key: I'm assuming "read in a number" actually means that the program needs to read in a number (from the user)
04:05:59 <t7> is anyone using sized vectors yet?
04:06:30 <Jafet> Your condition is clearly necessary, I don't know if it's sufficient
04:06:46 <Jafet> Wait, it's the other way round
04:07:53 <p1key> srhb: yes
04:08:58 <srhb> p1key: The recursive step looks fine.
04:10:15 <tac> @hoogle Monad m => [a] -> (a -> m b) -> m [b]
04:10:16 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
04:10:16 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:10:17 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:10:29 <fmap> p1key: you count difference between n and guess, not between two guesses
04:10:32 <tac> is there a name for flip mapM?
04:10:58 <p1key> fmap: How could that be fixed?
04:11:34 <fmap> p1key: well, you'd need to pass previous guess to function
04:11:38 <srhb> tac: forM.
04:11:38 <nand`> tac: forM
04:11:40 <Jafet> @@ @hoogle @type flip mapM
04:11:41 <nand`> darn
04:11:41 <lambdabot>  Parse error:
04:11:42 <lambdabot>   forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
04:11:42 <lambdabot>            ^
04:12:17 <tac> @hoogle forM
04:12:17 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
04:12:17 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
04:12:17 <lambdabot> Data.Foldable forM_ :: (Foldable t, Monad m) => t a -> (a -> m b) -> m ()
04:12:40 <p1key> fmap: e.g?
04:12:45 <tac> wth. I swear I had Control.Monad important
04:12:46 <p1key> how would it look
04:12:47 <tac> imported*
04:13:08 <tac> anyway, ty guys
04:13:28 <srhb> fmap: Isn't that the g in the recursive call?
04:13:52 <srhb> The naming differene is slightly annoying, but it looks right. ;)
04:14:08 <p1key> sorry my vars changed :/
04:14:46 <fmap> srhb: `abs (g^2 - n) < 1e-7' doesn't look like comparing two guesses for me
04:15:00 <srhb> That's true.
04:15:12 <srhb> p1key: Ideally you'll have recGuess n pe = let ne in ...
04:15:24 <srhb> Where you let ne = the formula in your specification
04:15:37 <srhb> p1key: The specification translates very exactly to Haskell.
04:16:43 <p1key> srhb: Wait so how would it look?
04:17:27 <srhb> p1key: recGuess num pe = let ne = yourformula in if small then ne else recursive call
04:19:23 <shachaf> srhb: Using any lenses yet?
04:19:43 <srhb> shachaf: Oh, I do - understanding them is luckily not a prerequisite :P
04:19:56 <shachaf> You should understand them!
04:20:00 <srhb> Yes!
04:20:06 <shachaf> Are you talking about understanding lenses in general or "lens"-style lenses?
04:20:16 <srhb> lens-style lenses.
04:20:30 <p1key> srhb: main = print $ recGuess num pe = let ((g + n/g) / 2) = (g^2 - n) in if small then ((g + n/g) / 2) else recursive call
04:20:31 <shachaf> If you understand mapM you can understand lens-style lenses.
04:20:31 <p1key> ?
04:20:55 <shachaf> srhb: A lens-style lens is pretty much generalized mapM.
04:23:27 <shachaf> (I can elaborate if desired.)
04:23:39 <fmap> what I don't understand in lenses is why Const (i.e. Accessor) and Identity (i.e. Mutator) are useful and other functor are not
04:23:51 <fmap> s/functor/functors/
04:23:54 <shachaf> fmap: You can use other functors if you want.
04:24:12 <shachaf> For example you can use Writer, which combines Const and Identity.
04:24:43 <shachaf> But the two operations that people tend to care about with lenses, view and set, happen to correspond to Const and Identity.
04:25:29 <p1key> main = print $ recGuess num pe = let ((g + n/g) / 2) = (g^2 - n) in if small then ((g + n/g) / 2) else recSqrt n ((g + n/g) / 2) in recSqrt 144 70
04:25:32 <p1key> not working
04:25:47 <shachaf> Yes, that's a syntax error.
04:25:58 <shachaf> I think you should start by writing smaller Haskell programs. :-)
04:27:53 <mekeor> i wonder why the haddock-documentation on http://hackage.haskell.org/package/hakyll-3.4.2.1 is still not available.
04:32:32 <shachaf> What do you think of lenses, augustss?
04:32:55 <augustss> Quite cool!
04:33:23 <shachaf> I'm bikeshedding the names of the parameters.
04:33:42 <augustss> Hmmm, I have no opinion on that
04:33:46 <shachaf> Right now it's type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
04:34:26 <shachaf> I want Lens ? ? a b. edwardk vetoed any type variable longer than one character, so the choice seems to be mostly between c d a b and s t a b
04:34:32 <fmap> shachaf: so it just happens that operations provided by other functors besides Const and Id aren't interesting?
04:34:42 <fmap> mekeor: build failed
04:35:00 <mekeor> yup
04:35:01 <shachaf> fmap: Well, they are interesting! You're free to use them with your own Functors/Applicatives.
04:35:15 <shachaf> But for the standard library these seem to be the ones that matter.
04:35:18 <mekeor> fmap: just was said that in #hakyll already :P
04:35:57 <shachaf> (For the operations you typically want from a lens -- i.e., view and set.)
04:36:05 <fmap> shachaf: i guess "interesting only for me" == "not interesting" :]
04:36:14 <Philonous> Is there a package that implements the DIffie-Hellman key exchange?
04:37:13 <nand`> I don't see why it would be c d a b and not a b c d
04:37:19 <shachaf> @ty traverse
04:37:19 <lambdabot> Not in scope: `traverse'
04:37:25 <shachaf> @ty Data.Traversable.traverse
04:37:26 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
04:37:54 <nand`> fmap: some lens combinators use functors/applicatives other than (its renamed versions of) Const and Identity
04:38:03 <nand`> for example, the zipper stuff uses Bazaars
04:38:19 <shachaf> nand`: But only internally. :-)
04:38:35 <nand`> what do you mean, ‚Äúinternally‚Äù?
04:38:44 <shachaf> The type Bazaar isn't exposed anywhere.
04:39:23 <nand`> the type of ‚Äòwithin‚Äô accepts a LensLike (Bazaar c c)
04:39:26 <shachaf> So it doesn't really matter to you. It's as if it did traverseOf lens ...
04:39:38 <shachaf> nand`: So?
04:39:45 <shachaf> You always pass it something polymorphic.
04:39:56 <nand`> yeah; but that's the same as Const and Id then
04:39:57 <shachaf> Bazaar is in Control.Lens.Internal -- you never see it under normal use.
04:40:10 <nand`> fmap was asking about other interesting functors/applicatives one can use lens with other than Const/Id, no?
04:40:22 <shachaf> Well, I mentioned Writer. :-)
04:40:31 <shachaf> (Which is also the same as Const + Identity.)
04:42:48 <jetpac> Does anyone have a few minutes to have a quick look at some GADT related homework I'm working on?
04:42:51 <hpaste> jetpac pasted ‚ÄúGADT evaluator‚Äù at http://hpaste.org/76943
04:44:05 <shachaf> jetpac: hpaste has a bunch of nice suggestions for you. :-)
04:44:44 <shachaf> That's quite the large function you have there.
04:44:48 <jetpac> shachaf: ha just saw that :)
04:45:05 <jetpac> yea that's why I'm looking for some help, feels really messy
04:45:40 <jetpac> but can't figure out how to reduce the mess without passing the type constructor as a parameter to another function - which I couldn't seem to get to work
04:45:43 <shachaf> Seems like that's the sort of code that a monad could help with.
04:46:05 <shachaf> Passing the type constructor as a parameter to another function?
04:46:12 <shachaf> You should just be able to pass it. Assuming the types match.
04:47:10 * shachaf :-( at print.
04:47:32 <jetpac> haha that's not from me, thats from the lecturer!
04:48:12 <shachaf> Your lecturer sounds like the devil.
04:48:18 <shachaf> (No offense intended.)
04:48:41 <jetpac> Ha I presume he must have had some reason for it
04:49:17 * ion looks at the paste. ‡≤†_‡≤†
04:49:26 <ion> print x = unsafePerformIO $ do hPutStrLn stdout $ show x; return x
04:49:27 <fmap> I like mix of GADT-level type trickery and unsafePerformIO for print
04:51:53 <jetpac> so I guess what I'm trying to do (perhaps foolishly) is to move the 2 nested Either cases to a separate function that can be reused for each of the options in the outer case of partial_eval
04:51:58 <donri> hm, would it be sensible to use DefaultSignatures in Functor and Applicative falling back on Monad? ok so it saves four lines of code but still
04:53:42 <shachaf> donri: I'm sure you can find mailing list threads about that. :-)
04:56:50 <donri> in deed http://www.haskell.org/pipermail/libraries/2011-September/016775.html
04:58:06 <mekeor> So, Data.List.(\\) only deletes the first occurence, right? is there an alternative function which removes all occurences?
04:58:29 <shachaf> filter
04:58:39 <mekeor> oh right
04:58:51 <mekeor> filter (`elem`xs) ys‚Ä¶
04:59:07 <mekeor> or rather: filter (`notElem`xs) ys‚Ä¶
04:59:14 <mekeor> thanks
04:59:41 <dp_wiz> Is it possible to convert a 'Data.Attoparsec.ByteString.Parser a' to 'Data.Attoparsec.Text.Parser a'?
05:00:41 <shachaf> Does that make sense?
05:00:48 <shachaf> You mean by specifying an encoding?
05:01:05 * killy9999 just discovered -xc option for RTS
05:01:13 <shachaf> @where rts-xc
05:01:13 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
05:01:18 <killy9999> I thought we don't have stack traces in Haskel...
05:01:27 <shachaf> They don't work quite the way you think.
05:01:53 <killy9999> I don't know what do I think about them in fact
05:02:14 <killy9999> I was pretty sure that any stacktrace in a lazy language would make no much sense
05:03:02 <nand`> I'm personally not really sure why it wouldn't; it just wouldn't be an application stack but an evaluation stack - you get a history of which expression was forced by which other expression
05:03:27 <nand`> at least that's what I'd conceptualize in my mind
05:03:31 <killy9999> nand`: yes, but I guess that's not what most people expect from a stack trace
05:04:13 <jetpac> if it's possible to pass a type constructor as a parameter, what is the type of the type constructor?
05:04:19 <donri> http://www.youtube.com/watch?v=J0c4L-AURDQ
05:05:44 <killy9999> can anyone point me to a chapter in GHC documentation (or some paper, whatever) that describes different types of sparks?
05:05:47 <fmap> @kind Maybe
05:05:49 <lambdabot> * -> *
05:06:02 <killy9999> i managed to find descriptions of converted and priuned sparks
05:06:26 <killy9999> but I don't know what are fizzled, dud and overflowed sparks
05:06:40 <nand`> it's possible to pass a type constructor as a parameter?
05:09:08 <fmap> depends on definition of parameter i guess
05:10:24 <killy9999> I found answer to my question: http://www.haskell.org/haskellwiki/ThreadScope_Tour/SparkOverview
05:10:55 <nand`> a type parameter, sure
05:12:05 <shachaf> nand`: Why not?
05:14:11 <nand`> well, I thought this was about function parameters, ie. value level
05:20:23 <azm> if i have one core cpu, can the cpu be cosidered parallel if it uses slicing or only 2 and more cores are truly parallel ?
05:21:58 <zomg> azm: I guess it would depend.. I believe HyperThreading for example supports fully parallel execution
05:22:10 <zomg> I could be wrong though
05:23:44 * hackagebot idris 0.9.5 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.5 (EdwinBrady)
05:23:49 <nand`> CPUs use a lot of low level parallelism in their execution cores, mind
05:23:55 <nand`> it's important to consider the abstraction you're working with
05:25:05 <Jafet> My CPUs are parallel; they never touch each other.
05:25:27 <azm> I think Hyper-threading is the answer for what I was looking
05:25:28 <zomg> It's not gay unless the cores touch
05:25:30 <zomg> lol
05:26:00 <azm> #hardware said same as zomg
05:26:08 <zomg> haha really
05:26:13 <azm> wiki article confirmed..
05:26:19 <zomg> oh wait not about the cores touching I imagine
05:26:24 <azm> lol no
05:26:29 <hpaste> jetpac pasted ‚ÄúGADT evaluator attempt‚Äù at http://hpaste.org/76945
05:26:35 <azm> the first of your answers
05:26:38 <zomg> Yeah
05:26:53 <jetpac> if someone could have a look and see if that looks like it makes any sense I would be appreciative
05:27:03 <azm> but the cores never touch ?
05:27:13 <azm> or do they
05:27:18 <Jafet> > 1 + 2 -- all the bits are added in parallel
05:27:19 <lambdabot>   3
05:27:20 <zomg> haha no idea
05:27:31 <zomg> I just twisted the saying "it's not gay unless the balls touch" to suit the situation
05:27:34 <zomg> :P
05:27:43 <azm> omg.
05:28:11 <azm> and I thought #haskell is the proper channel.
05:28:18 <nand`> hyperthreading is basically a form of execution where instructions from two threads can be scheduled onto execution cores at the same time, using what would otherwise be ‚Äôidle time‚Äô for single-threaded evaluation
05:28:23 <quicksilver> Jafet: only they're not, because the carry bits have to propogate from one end of the adder to the other, so the adder circuit converges from one side to the other.
05:28:30 <azm> I always go to #haskell when nned life advice.
05:28:49 <zomg> azm: yeah usually it's proper but I just like bad humor
05:29:03 <nand`> http://sadpanda.us/images/1233501-9PBVT3X.png
05:29:18 <nand`> here's a diagram that I think visualizes the concept fairly well
05:30:24 <azm> nand`, cool and they cant put more stuff to one core anymore so they started to make more instead of ®bigger® ?
05:30:40 <b__> can I define an operator like this somehow: a @@ b c = foo $ a b c?
05:30:53 <b__> specifically, with the operator in that kind of position
05:31:02 <Jafet> :t let (f . g) x = f (g x) in (.)
05:31:03 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
05:31:27 <quicksilver> Jafet: FWIW, bitwise xor would have been a better example :)
05:32:10 <dzhus> shall I pick text-icu or encoding for UTF-8<->cp1251 conversions?
05:32:17 <nand`> azm: cores still routinely increase in complexity, but I'm not the best person to ask for this
05:32:29 <Jafet> > 1 .|. 2 -- unicorns and rainbows
05:32:30 <lambdabot>   Ambiguous type variable `a' in the constraint:
05:32:30 <lambdabot>    `Data.Bits.Bits a'
05:32:30 <lambdabot>      a...
05:32:36 <nand`> b__: no, only binary operators are supported
05:32:44 <b__> okay =]
05:32:49 <nand`> but you can do (@@) a b c and then you'd be able to call it like (a @@ b) c
05:32:56 <nand`> but not (a @@ b c), that would be a @@ (b c)
05:33:35 <strg> I think it has to do with the physical speed barrier of processors. Instead of trying to make processors faster (where they have hit a limit) they just put multiple of them on one die, and adjust the software to run concurrent.
05:34:11 <shachaf> This all seems off-topic (especially zomg).
05:35:14 <Jafet> Not really, #haskell is the best place to recycle old memes
05:38:33 <efie> in f $!! (g x), ($!!) means that (g x) is fully evaluated before f evaluates anything, but it does not mean that everything inside g x has to be strictly evaluated, does it?
05:38:54 <Jafet> jetpac: does it work?
05:39:20 <Jafet> efie: what does "strictly evaluated" mean?
05:40:08 <jetpac> Jafet: It compiles, and runs correctly. I'm not sure if it correctly does what its supposed to, which is return partially evaluated expressions if it cannot complete the evaluation
05:40:30 <dzhus> is Word8 has the same representation as Char?
05:40:33 <Jafet> Uh, test it then?
05:40:44 <quicksilver> dzhus: no.
05:41:04 <jetpac> But does the structure look ok - it feels like there's a better way to do it
05:41:07 <quicksilver> dzhus: Chars are architecture dependent but definitely contain more than 8 bits of information.
05:41:25 <jetpac> e.g. tmp and boo (bad names I know) are identical except for the type signatures
05:41:37 <efie> Jafet: not creating thunks? :)
05:42:13 <shachaf> quicksilver: I wouldn't be particularly surprised if GHC did represent them the same way internally.
05:42:19 <shachaf> (Although the primitive types are different.)
05:42:42 <jmcarthur> shachaf: Chars are unicode code points or somesuch, aren't they?
05:42:46 <jmcarthur> there's no way they could be the same
05:42:49 <Jafet> efie: the value of (g x) is evaluated using deepseq, using the same evaluation rules.
05:43:13 <quicksilver> shachaf: if by "represent them the same way" you mean "represent as bits stored in memory" then yes
05:43:21 <quicksilver> that doesn't seem a very useful thing to mean, to me.
05:43:54 <Jafet> They would be the same up to 255
05:44:03 <efie> Jafet: what do you mean by "using the same evaluation rules"? so inside (g x) thinks can be done lazily?
05:44:11 <efie> things*
05:44:28 <Jafet> Of course
05:46:00 <Jafet> unsafeCoerce 123456789 :: Char
05:46:03 <Jafet> '\123456789'
05:47:42 <merijn> dzhus: Char is a unicode codepoint, so by definition cannot map to an 8bit word
05:48:32 <eikke> is there any way to make cabal-dev build both profiling-enabled as well as non-profiling executables?
05:48:40 <Jafet> jetpac: why use boo, then?
05:49:53 <jetpac> Jafet: sorry I was having an issue with the types so I couldn't use tmp for the boolean types, but have since figured it out and removed boo
05:49:58 <jetpac> thanks for looking at it
05:50:19 <jetpac> I think I'm going to submit it, I think it works ok and have spent too much time on it already
05:50:29 <jmcarthur> according to http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/GHC-Prim.html , ghc chars are 31 bits
05:50:35 <Jafet> Heh, hlint doesn't recurse.
05:50:48 <Jafet> Found: hPutStrLn stdout $ show x   \   Why not: hPrint stdout x
05:51:15 <jetpac> My lecturer provided us with that code
05:51:44 <jetpac> it causes some consternation further up the chat a while ago
05:51:49 <jetpac> *caused
05:52:29 <fmap> eikke: cabal-dev install $name --enable-library-profiling?
05:53:00 <fmap> oh, executables
05:53:04 <Philonous> Jafet:  Why not just "print x" ?
05:53:05 <fmap> then another flag
05:53:14 <eikke> fmap: executables are contained in the same dev-tree, so I pass --enable-executable-profiling, which builds profilinf-enabled executables, but not non-profiling ones
05:53:31 <Jafet> Philonous: yes.
05:53:41 <fmap> hmm
05:53:50 <eikke> fmap: and the profiling ones are rather useless for benchmarking purposes, so I always need 2 cycles with a re-configuration in between, which is rather tedious
05:54:41 <Jafet> This seems to be a problem with Cabal.
05:54:56 <eikke> Jafet: could be, yes
05:55:15 <eikke> (or rather: most likely. maybe it's just a strange feature request, I dunno...)
05:55:24 <Jafet> Though, do you save much work by building both at the same time?
05:55:42 <dcoutts> eikke: right, we can build both prof and normal libs, but not exes, since we have the problem that there's only one place to put exes
05:55:51 <dcoutts> we don't do bin/blah.prof
05:56:17 <dcoutts> in principle it's obviously easy, but with the current UI expectations, it's expected there's a single binary
05:56:21 <eikke> dcoutts: any reason? when I'm in the ocaml sphere, we can do ocamlbuild foo.native or ocamlbuild foo.prof.native :)
05:56:31 <dcoutts> eikke: purely ui expectations
05:56:34 <Jafet> You can write a little script that Setup configure --program-suffix .prof
05:57:19 <eikke> Jafet: I guess, but if cabal gains parallel build support, that'd be a min :)
05:57:19 <dcoutts> eikke: also, while it's easy to see what the UI might be for a build, what should actually be installed?
05:57:43 <eikke> dcoutts: good point, although I don't really mind about 'install' when using cabal-dev :)
05:58:24 <dcoutts> eikke: unfortunately the person implementing the feature has to make it do something sensible in general
05:58:51 <Jafet> --enable-executable-vanilla
05:59:13 <Jafet> How to choose a second name, well, that's pretty arbitrary
06:00:56 <dcoutts> Jafet, eikke: if you can come up with what you think it a good ui, then file a ticket. The actual impl should be easy.
06:01:18 <eikke> dcoutts: will do (or maybe put something up on -cafe), thanks!
06:01:27 <ivanm> I want a more "sensible" Tree example to use for pretty-tree; can anyone think of any good Haskell-based hierarchy charts or something?
06:01:33 <dcoutts> eikke: ok, but do file a ticket or we probably will not notice
06:01:50 <ivanm> one alternative I've thought of is the Solid-arrow bit in the diagram in the typeclassopedia: http://www.haskell.org/haskellwiki/Typeclassopedia
06:02:05 <ivanm> (that is Functor, Applicative, Alternative, Monad, etc.)
06:03:10 <fmap> yesod dependecies tree?
06:03:29 <Jafet> By the way dcoutts, I get a linker error when building shared libraries: "relocation against undefined symbol can not be used when making a shared object; recompile with -fPIC"
06:03:50 <Jafet> Is this caused by cabal or ghc not compiling with -fPIC, or something else?
06:03:57 <ivanm> fmap: I figured one more central to Haskell, to avoid giving any kind of implicit preference to any web application framework :p
06:04:03 <ivanm> also, that'll probably change too quickly
06:04:16 <dcoutts> Jafet: would need more details, arch, os, what command you're running etc
06:05:01 <ivanm> can't do the numeric hierarchy; too many interactions
06:05:03 <Jafet> It's on 64-bit linux, happens on multiple libraries (like vector)
06:05:32 <Jafet> I'm just wondering if this message indicates a specific problem
06:11:23 <ivanm> dcoutts: is there some kind of hierarchy tree in Cabal for the processing stages or something I can use as an example?
06:11:59 <dcoutts> ivanm: bit more context or detail, what are you after exactly?
06:12:04 <bitonic> can I use multiple .cabal files in one directory?  I'd like to factor some modules out of my package but I still want to keep them in the same place...
06:12:29 <dcoutts> bitonic: no, have to use subdirs
06:12:31 <ivanm> I want a more "sensible" Tree example to use for pretty-tree; a Haskell-based example would be nice
06:12:48 <ivanm> the best I've come up with so far is the Functor/Applicative/Monad "hierarchy", though it's rather small
06:12:51 <bitonic> dcoutts: mhm.  is there a way to easily use all of them at the same time without having to `install' them?
06:13:16 <dcoutts> bitonic: you can install them all into a local package db, that's what cabal-dev does (by calling cabal with the right flags)
06:13:19 <jmcarthur> ivanm: output from vacuum?
06:13:32 <ivanm> jmcarthur: of what?  And sounds rather fiddly :)
06:13:40 <jmcarthur> dunno
06:13:44 <byorgey> bitonic: I like hsenv for that sort of thing, https://github.com/Paczesiowa/hsenv
06:13:45 <jmcarthur> i guess you can't handle cycles
06:13:52 <ivanm> I was hoping for something with some longer names, etc. (otherwise I'd make up a tree with a, b, c, etc. as labels)
06:13:55 <ivanm> yup
06:14:07 <jmcarthur> or even sharing?
06:14:10 <bitonic> dcoutts: thanks, I was hoping not to use `cabal-dev' and keep things simple, but OK
06:14:16 <ivanm> jmcarthur: yeah, just a tree
06:14:25 <Jafet> ivanm: its own source tree
06:14:34 <dcoutts> bitonic: you don't have to use cabal-dev, it's just configuring with a local --prefix, and --package-db
06:14:51 <bitonic> dcoutts: but `cabal-dev' eases that right?
06:14:55 <dcoutts> bitonic: yes
06:14:55 <ivanm> Jafet: heh, sounds a bit too meta though, especially if I have to update it every time I change the source
06:15:04 <dcoutts> bitonic: you can also have multiple exes in the same package
06:16:53 <ivanm> Jafet: oh, and I have recursion in my functions, which means it isn't a Tree
06:33:45 * hackagebot bk-tree 0.1 - BK-tree implementation  http://hackage.haskell.org/package/bk-tree-0.1 (FrancescoMazzoli)
06:33:47 * hackagebot tst 0.1 - BK-tree implementation  http://hackage.haskell.org/package/tst-0.1 (FrancescoMazzoli)
06:33:49 * hackagebot language-spelling 0.3 - Various tools to detect/correct mistakes in words  http://hackage.haskell.org/package/language-spelling-0.3 (FrancescoMazzoli)
06:38:46 * hackagebot bk-tree 0.1.1 - BK-tree implementation  http://hackage.haskell.org/package/bk-tree-0.1.1 (FrancescoMazzoli)
06:38:48 * hackagebot tst 0.1.1 - BK-tree implementation  http://hackage.haskell.org/package/tst-0.1.1 (FrancescoMazzoli)
06:43:50 * hackagebot language-spelling 0.3.1 - Various tools to detect/correct mistakes in words  http://hackage.haskell.org/package/language-spelling-0.3.1 (FrancescoMazzoli)
06:47:06 <ivanm> bitonic: you might want to check your synopsis of your tst package
06:47:41 <ivanm> also, did you know of the bktrees package before you wrote bk-tree ?
06:51:20 <donri> and the home page etc of both those packages
06:54:10 <DMcGill> lots of people here know math, is anybody familiar with the Finite Element Method? ##Math hasn't been able to help :(
06:54:48 <ivanm> is it too sad/pathetic to use Starcraft tech trees or something as a demonstration in Haddock docs? :p
06:55:59 <Jafet> Just make sure it includes Brood War
06:56:41 <Jafet> Can your program draw tech trees? They normally extend upwards
06:57:26 <hello__> hello
06:57:41 <ivanm> Jafet: nah, only doing downwards atm
06:57:44 <shachaf> Aren't those things more like tech graphs?
06:57:48 * ivanm waves in hello__'s general direction
06:58:06 <ivanm> shachaf: this one is a forest! http://www.themoderndaypirates.com/pirates/wp-content/uploads/2010/03/TechTree.png
06:58:25 <ivanm> an alternative is the filesystem hierarchy standard...
06:58:25 <shachaf> ivanm: You should draw Command & Conquer tech trees.
06:58:43 <ivanm> I was going to use West Roman Army high command structure, but it's way too wide :s
06:58:47 <ivanm> shachaf: why C&C?
06:59:27 <ivanm> maybe just http://en.wikipedia.org/wiki/Unix_directory_structure ?
06:59:52 <shachaf> Because I know C&C!
06:59:56 <ivanm> heh
07:00:17 <shachaf> C&C:RA2, in particular.
07:00:57 <ivanm> really can't think of interesting enough Haskell-based trees/hierarchies to use :s
07:01:21 <shachaf> Draw the Num hierarchy.
07:01:33 <ivanm> it's not a Tree
07:01:46 <ivanm> and I need a Tree (or a Forest)
07:02:02 <shachaf> What's a forest?
07:02:10 <ivanm> a collection of trees
07:02:16 <arvraepe> XD
07:02:27 <ivanm> in Data.Tree, type Forest a = [Tree a] ;)
07:03:01 <shachaf> data Tree a = (Tree a) [Tree a] -- gotta have both types of brackets.
07:03:07 <shachaf> (Actually that's a syntax error. :-( )
07:03:11 <ivanm> heh
07:03:41 <ivanm> bitonic: I don't know if you noticed, but donri and I spotted earlier that your .cabal files for bk-trees and tst aren't quite right (for the metadata)
07:03:43 <shachaf> data Tree = Tree [Tree] is pretty good.
07:03:46 * hackagebot crf-chain1-constrained 0.1.1 - First-order, constrained, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-constrained-0.1.1 (JakubWaszczuk)
07:04:55 <ivanm> OK, can't use history of unix; it's not a tree :s
07:05:08 <ivanm> (unless I simplify it)
07:05:40 <ivanm> well, data Tree a = Node a [Tree a]
07:05:47 <ivanm> (in Data.Tree)
07:06:05 <Jafet> @quote Cale Nature
07:06:05 <lambdabot> Cale says: data Nature = Rock | Stream Nature | Tree Nature Nature
07:06:12 <ivanm> shachaf: your definition only works if you want a structure without labels!
07:06:19 <shachaf> ivanm: Who needs labels?
07:06:23 <ivanm> a Stream of Rocks? :/
07:06:32 <shachaf> ivanm: It makes your job as a tree-drawing-person much easier.
07:06:37 <ivanm> shachaf: people usually carfe about what parts of a Tree/Graph/etc. actually represent!
07:06:38 <ivanm> heh
07:06:49 <zomg> ivanm: they are a stream when you have drawn a picture of the prophet and are getting stoned by a crown of angry muslims
07:06:55 <ivanm> I've fixed up my tree-drawing code; I just want a pretty diagram for the Haddock docs!
07:06:59 <ivanm> zomg: ahhhh
07:07:02 <zomg> *crowd
07:07:13 <ivanm> OK, how about a Stream (Stream (Tree (Stream Rock) Rock)) ? :p
07:07:44 <zomg> That would most likely involve some sort of multidimensional shenanigans
07:07:49 * shachaf wonders whether zomg has been doing anything other than trolling in here.
07:07:55 <zomg> haha
07:08:43 <zomg> I do sometimes talk about actual things but since most of the time the discussion here goes beyond my haskell-fu, it may seem like I'm usually just talking nonsense
07:08:49 <zomg> =)
07:08:56 <zomg> and I'm certainly not trolling
07:08:58 <zomg> just bad jokes
07:08:58 <zomg> :P
07:13:46 * hackagebot concraft 0.1.0 - Morphosyntactic tagging tool based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.1.0 (JakubWaszczuk)
07:14:26 <ivanm> @tell bitonic I don't know if you noticed, but donri and I spotted earlier that your .cabal files for bk-trees and tst aren't quite right (for the metadata); also, were you aware of the bktree package when you created bk-trees ?
07:14:27 <lambdabot> Consider it noted.
07:15:16 <ppremont> Hello. Anyone knows how to see the whole list of errors, instead of the last 10 lines, in cabal 1.16 ?
07:16:48 <ivanm> errors from what?
07:16:57 <ivanm> but I would guess --verbose would help
07:16:59 <ppremont> The build log
07:18:03 <donri> ppremont: build without -j, or with -j1, or read the logs in ~/.cabal/logs
07:18:46 * hackagebot wai-app-static 1.3.0.3 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.0.3 (MichaelSnoyman)
07:18:48 * hackagebot warp 1.3.4.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.4.2 (MichaelSnoyman)
07:22:19 <ppremont> Hmm. I have no -j, Even with -j1 I get the parallel-style output with the last 10 lines. I use cabal-dev but that shouldn't change anything.
07:24:51 <niteria> quick question: http://www.scs.stanford.edu/11au-cs240h/notes/zipper-slides.html#(47), where does the last step come from?
07:25:45 <AndrewMarsh> @pl \x y -> length x == length y
07:25:46 <lambdabot> (. length) . (==) . length
07:26:11 <donri> ppremont: do you have "jobs: something" in .cabal/config?
07:26:45 <ppremont> Yes I did. Just found it. Thanks for your help!
07:26:57 <AndrewMarsh> @pl \x y -> compare (length x) (length y)
07:26:57 <lambdabot> (. length) . compare . length
07:27:00 <shachaf> AndrewMarsh: ((==) `on` length)
07:27:14 <shachaf> But keep in mind that it'll traverse both lists entirely before returning.
07:27:22 <dada-cetacean> is there a function that composes other functions with themselves n times?
07:27:39 <shachaf> dada-cetacean: You can iterate f z !! n
07:31:51 <parcs`> niteria: 1/(1-x) = 1 + x + x^2 + x^3 + ... = n(x)
07:34:25 <byorgey> niteria: you could also derive it from the definition n(x) = 1 + x n(x)
07:34:31 <byorgey> just solve for n(x)
07:34:50 <shachaf> byorgey: That's a little bit on the fishy side...
07:34:51 <niteria> oh, taylor expansion
07:34:59 <byorgey> shachaf: what's on the fishy side?
07:35:10 <shachaf> "solving" for n(x)
07:35:48 <shachaf> Well, the whole idea of 1/(1-x), where x is a type.
07:35:52 <byorgey> on the face of it, yes, though it turns out it can be made entirely rigorous
07:36:03 <shachaf> As far as I know types-up-to-isomorphism behave like commutative semirings or something.
07:36:14 <shachaf> I don't know what divison and subtraction mean, and why you can justify them.
07:36:19 <shachaf> I'd be glad to find out. :-)
07:37:35 <shachaf> byorgey: I'm more or less falling asleep so if you know of a paper or something that I should read, you should mention it. :-)
07:37:42 <byorgey> shachaf: you can define subtraction via a Groethendieck construction, http://byorgey.wordpress.com/2010/11/24/species-subtraction-made-simple/
07:38:18 <byorgey> shachaf: alternatively, I'm pretty sure you can say that any proof which starts and ends with no subtraction or division, but uses subtraction and division along the way, can be "normalized" into a proof that does not use either
07:38:33 <shachaf> byorgey: That's really the normal subtraction, though, is it?
07:38:34 <byorgey> though I don't know of a reference for that offhand.
07:38:44 <shachaf> byorgey: That sounds like a very nifty thing, if true.
07:38:49 <shachaf> I'm suspicious of it.
07:38:56 <byorgey> shachaf: I don't know what you mean by "normal"
07:39:01 <byorgey> but I think the answer is yes
07:39:11 <shachaf> byorgey: By "normal subtraction" I mean e.g. a type -1 such that Either (-1) () ~ Void
07:39:17 <byorgey> I respect your suspicion.  It is very nifty. =)
07:39:17 <dada-cetacean> shachaf: is there a way to make something like iterate work with a function that has the type [a] -> [[a]]?
07:39:39 <shachaf> dada-cetacean: Yes, a thing called "parametric polymorphism" (or "unification"). :-)
07:39:44 <shachaf> Oh, wait.
07:39:46 * shachaf is too tired.
07:39:52 <autin> a newbie problem when  run gitit --wiki written in haskell :gitit: accept: unsupported operation (Function not implemented)
07:39:55 <autin> any help?
07:40:02 <shachaf> dada-cetacean: What would it mean for that to work? What would be the type of the thing it returns?
07:40:13 <byorgey> dada-cetacean: given   f : [a] -> [[a]],  concat . f   has type   [a] -> [a]
07:40:19 <byorgey> that's one possibility
07:40:34 <byorgey> so you can   iterate (concat . f)
07:40:54 * shachaf sighs.
07:41:01 <byorgey> > let f xs = [map (+1) xs, map (+2) xs, map (+3) xs]  in  iterate (concat . f) [1]
07:41:03 <lambdabot>   [[1],[2,3,4],[3,4,5,4,5,6,5,6,7],[4,5,6,5,6,7,6,7,8,5,6,7,6,7,8,7,8,9,6,7,8...
07:41:30 <shachaf> byorgey: Tell me if you have a reference for that claim.
07:41:41 <byorgey> shachaf: I'll see if I can dig one up
07:41:48 <shachaf> (And to what degree it can be generalized, if it's true.)
07:42:36 <AndrewMarsh> @ps \x -> (length (head x), x)
07:42:36 <lambdabot> (,) =<< length . head
07:42:40 <dada-cetacean> say something like layer [] = []; layer (x:xs) = [[x]] ++ (layer xs)
07:43:08 <dada-cetacean> can I do something to iterate to make iterate layer [1..5] !! 3 output the same thing as (layer.layer.layer) [1..5] ?
07:43:17 <shachaf> Ah, I see.
07:43:57 <shachaf> Unfortunately the answer is "not easily".
07:44:14 <dada-cetacean> ):
07:44:55 <byorgey> oh.  Yeah, the problem is that the type of the thing you're iterating on changes every iteration.
07:45:17 <byorgey> dada-cetacean: also, note   layer = map (:[])
07:45:34 <dada-cetacean> oh, heh
08:04:40 <rndm> generic pltheory question about hoare logic. How does the assignment rule work if the post/pre condition don't have a free variable. for instance {true} y:=0 {true}
08:05:39 <byorgey> rndm: if you make a substitution for y in an expression with no free occurrences of y, you just get the same expression back.
08:06:22 <byorgey> this reflects the idea that if P holds and then you assign to a variable which P does not mention, P still holds unchanged.
08:06:58 <rndm> byorgey: thanks. it sounds so obvious like that.
08:07:59 <byorgey> "Formally, let P be an expression in which the variable x is free." -- from the wikipedia page, this is bogus.  there's no need for x to occur free in P.
08:08:10 <byorgey> it should just say "Formally, let P be an expression."
08:08:53 <rndm> the wikipedia page is precisely why i'm here :)
08:09:08 <byorgey> I figured it might be =)
08:09:49 <byorgey> feel free to edit it.  I currently have wikipedia blocked (was looking at the google cached version for hoare logic)
08:10:25 <monochrom> hrm, hoare logic in #haskell? that's a bit too imperative :)
08:10:56 <byorgey> perhaps rndm is using the ST monad =)
08:10:56 <rndm> #hoarelogic was empty =)
08:11:12 <killy9999> is there some smart way of telling GHC "hey, all my integer literals are Int, not Integer"?
08:11:18 <byorgey> after all, Haskell is the world's finest imperative language.
08:11:25 <killy9999> or do I have to place explicit type annotations everywhere?
08:11:35 <Jafet> default Num Int
08:11:42 <Jafet> This is probably a bad idea
08:12:40 <killy9999> ?
08:13:18 <killy9999> you mean explicit type annotations are a bad idea?
08:13:21 <killy9999> or using default?
08:14:46 <Jafet> Type annotations are not a bad idea. But default is not inconvenient.
08:15:03 <Jafet> default (Int, Double)
08:17:50 <atriq> \s t -> execState $ at s <<.= Nothing >>= assign (at f)
08:18:02 <atriq> Evil with lenses with atriq
08:18:22 <atriq> Moves a value about in an At
08:18:29 <otters> > System.Info.os
08:18:31 <lambdabot>   Not in scope: `System.Info.os'
08:18:33 <otters> damn it
08:18:53 <otters> somebody on Linux, can you tell me your value of System.Info.os
08:19:07 <atriq> "linux"
08:19:14 <otters> simple enough
08:19:19 <shachaf> otters: It says "linux"
08:19:23 <shachaf> But you probably shouldn't use it.
08:19:42 <otters> Why
08:20:18 <shachaf> Well, it's evil, for one (should be IO String or something).
08:20:35 <killy9999> Jafet: either I'm doing something wrong, or defaule does not work
08:20:37 <otters> Okay, so what's the next thing
08:20:41 <otters> (also, what do I use instead)
08:20:42 <shachaf> atriq: I'm not sure what that code is doing, but it probably shouldn't be using State.
08:20:54 <shachaf> otters: I have no idea what you're doing.
08:21:08 <otters> shachaf: I want to know if the program is on Windows, Lunix, or OSX
08:21:24 <shachaf> Why?
08:21:36 <otters> Is that important?
08:21:51 <simpson> There might be a better solution to your *actual* problem.
08:22:14 <otters> the problem is printing "Windows" if it's running on Windows, "linux" if it's running on Linux, or "osx" if it's running on OSX
08:22:17 <otters> or nothing otherwise
08:22:19 <Jafet> Don't forget BSD, OS/2, Solaris, and ubuntu
08:22:46 <simpson> Ubuntu's a Linux. I'd hope that System.Info.os agrees with that.
08:22:57 <strg> AmigaOS
08:23:10 <otters> OS/2 is explicitly not supported
08:23:10 <Jafet> If you manage to port ghc to amiga, let us know
08:23:13 <simpson> otters: Does your program seriously just print the current OS as part of its startup?
08:23:21 <atriq> shachaf, it look creates a State thingy that looks up the value of the state at address s, returns that (setting it to Nothing), and then assigns it at address f
08:23:28 <otters> simpson: my problem simplifies to that
08:23:37 <otters> Actually, that's the whole program
08:23:44 <otters> I just want to know what best practice is
08:23:57 <simpson> otters: *Best* practice would be to not care about which OS you're on!
08:24:07 <otters> System.Info.os it is.
08:24:24 <otters> I'm not using any OS-specific code. I'm just printing the name of the OS.
08:24:53 <simpson> Okay.
08:28:35 <monochrom> you may find System.Info.os to be a hardcoded constant
08:28:48 * hackagebot graph-rewriting 0.7.4 - Monadic graph rewriting of hypergraphs with ports and multiedges  http://hackage.haskell.org/package/graph-rewriting-0.7.4 (JanRochel)
08:28:50 * hackagebot graph-rewriting-strategies 0.2.1 - Evaluation strategies for port-graph rewriting systems  http://hackage.haskell.org/package/graph-rewriting-strategies-0.2.1 (JanRochel)
08:28:52 * hackagebot aivika 0.4.2 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.4.2 (DavidSorokin)
08:29:20 <shachaf> I prefer to think of System.Info.os as nondeterministic, with a many-worlds interpretation.
08:30:11 <simpson> I'm gonna make my own OS, and I'm gonna set my OS name to "CorbinOS -- DROP TABLE 'data'; \b\NUL" just to spite people.
08:30:15 <srhb> shachaf: So we should allow for a distributed implementation of it? :-)
08:30:25 <simpson> Also hookers and blow.
08:37:46 <GnomeStoleMyBike> @nixon
08:37:46 <lambdabot> A public man must never forget that he loses his usefulness when he as an individual, rather than his policy, becomes the issue.
08:38:58 <srhb> What.
08:39:16 <Jafet> @vixen
08:39:16 <lambdabot> The second point is that coming out--coming back and saying that black Americans aren't as good as black Africans--most of them , basically, are just out of the trees.  Now, let's face it, they are.
08:39:24 * monochrom is displeased that such silly topic as "optimal line length in source code" is discussed in haskell-cafe.
08:40:19 <hiptobecubic> lambdabot, you're getting a bit saucy
08:40:33 <hiptobecubic> monochrom, it's an important topic
08:40:43 <monochrom> note that @vixen is typo-corrected to @nixon
08:41:04 <Jafet> It's now better than it ever was.
08:41:24 <hiptobecubic> Some people are still hacking away on their VTs
08:42:09 <monochrom> but do they write haskell?
08:43:13 <jerojasro> hiptobecubic: that's a silly rationalization. BUT, some people takes into account that readable lines of text (not only code) have at most 70-ish characters
08:43:34 <hiptobecubic> jerojasro, it was mostly a joke :)
08:43:51 <monochrom> ok, hahahaha
08:44:10 <jerojasro> and some people like to have multiple files/views side by side
08:44:14 <jerojasro> hiptobecubic: heh
08:44:34 <atriq> I program on a widescreen
08:44:44 <atriq> In a small font
08:44:50 <hiptobecubic> atriq, you've had no choice since about 2004
08:44:51 <fmap> monochrom: yeah, let's discuss it here too
08:44:56 <hiptobecubic> fmap, :D
08:45:43 <Jafet> Is there an indent for haskell?
08:45:50 <atriq> hiptobecubic, since I started programming in 2007, and seriously last year, I'm very glad I gave this widescreen
08:45:59 <Jafet> It should actually be easy to make one with src-exts.
08:46:19 <hiptobecubic> there is a pretty print mode i think?
08:46:49 <hiptobecubic> atriq, widescreen is nice for some things, yes
08:46:52 <Jafet> The idea is that if someone doesn't like your layout, they can stuff it up their... indent program.
08:47:20 <hiptobecubic> the problem with that is that it makes communicating difficult
08:48:30 <Jafet> I don't see why. You can extend the tool to indent commit messages and pull requests
08:48:48 * hackagebot http-conduit 1.8.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.2 (MichaelSnoyman)
08:51:40 <micahjohnston> @nixon
08:51:40 <lambdabot> A man who has never lost himself in a cause bigger than himself has missed one of life's mountaintop experiences. Only in losing himself does he find himself. Only then does he discover all the
08:51:40 <lambdabot> latent strengths he never knew he had and which otherwise would have remained dormant.
08:58:49 * hackagebot graph-rewriting-gl 0.7.2 - OpenGL interface for interactive port graph rewriting  http://hackage.haskell.org/package/graph-rewriting-gl-0.7.2 (JanRochel)
08:59:19 <byorgey> Jafet: there is stylish-haskell
08:59:34 <hiptobecubic> does that indent really? I thought it just fixed your imports mostly
09:01:52 <byorgey> hiptobecubic: oh, you're right
09:06:01 <bxx> what is the difference between (mappend (comparing length) compare) and (comparing length) ?   someone did the longer version in sortBy a while ago, but this works too.  sortBy (comparing length) (words "zzzz bb a ccc ")
09:07:17 <shachaf> bxx: One will sort by length and then lexicographically.
09:07:17 <quicksilver> bxx: behaviour on elements of the same length.
09:07:56 <bxx> ah
09:07:59 <bxx> thanks
09:08:33 <bxx> so it combines two comparators in a way
09:08:44 <bxx> what type is EQ GT and LT by the way?
09:08:49 * hackagebot graph-rewriting-lambdascope 0.5.3 - Implementation of Lambdascope as an interactive graph-rewriting system  http://hackage.haskell.org/package/graph-rewriting-lambdascope-0.5.3 (JanRochel)
09:09:12 <typoclass> @src Ordering
09:09:13 <lambdabot> data Ordering = LT | EQ | GT
09:09:15 <typoclass> bxx: ^^
09:09:15 <lambdabot> typoclass: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:09:45 <shachaf> bxx: :t and :i in ghci are very useful commands. :-)
09:10:37 <bxx> thanks, still pretty fresh
09:13:07 <Cale> bxx: Are you reading my reddit post? :)
09:14:07 <hiptobecubic> the monoid one?
09:14:11 <Cale> :)
09:14:47 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù pasted ‚ÄúDixon's factoring method: relation search step‚Äù at http://hpaste.org/76947
09:18:53 <hiptobecubic> is there any actual problem with having (++) = mappend and (.) = fmap?
09:19:03 <hiptobecubic> it won't break anything
09:19:15 <shachaf> It might.
09:19:17 <hpaste> ‚ÄúErtugrul S√∂ylemez‚Äù annotated ‚ÄúDixon's factoring method: relation search step‚Äù with ‚ÄúSlicker relation predicate‚Äù at http://hpaste.org/76947#a76948
09:19:28 <hiptobecubic> shachaf, i guess maybe you lose some type information?
09:19:35 <atriq> Monomorphy type stuff
09:19:53 <atriq> (.) = fmap breaks some Category stuff
09:20:01 <typoclass> hiptobecubic: a problem might be people not knowing what's going on
09:20:18 <monochrom> (.)=fmap is not so useful
09:20:22 <mm_freak> hiptobecubic: (.) = fmap is Caleskell and there is a better way to generalize (.)
09:20:26 <mm_freak> see Control.Category
09:20:42 <mm_freak> if anything, (.) and 'id' should be replaced by the Control.Category versions
09:20:51 <merijn> mm_freak: Word.
09:20:56 <monochrom> and today we have <$> if you want a symbol for fmap
09:21:12 <hiptobecubic> mm_freak, morphism composition you mean?
09:21:12 <nand`> or (.)
09:21:18 <mm_freak> hiptobecubic: yes
09:21:21 <nand`> oh
09:21:25 * nand` didn't read the conversation
09:21:42 <shachaf> And we have Èà∏ if you want cymbals for fmap.
09:21:58 <monochrom> (.)=fmap was a legacy when someone wanted a symbol for fmap, was too excited about Reader, and when (<$>) was not yet invented
09:22:00 <atriq> (<$>) is infix fmap, (<>) is infix mappend (already in base)
09:22:03 <shachaf> @let (Èà∏) = fmap
09:22:03 <lambdabot>   Illegal character ''\37432''
09:22:05 <nand`> doesn't Arrow a => a r give rise to a Functor? What about Category?
09:22:07 <shachaf> Pft.
09:22:09 <monochrom> hahaha shachaf
09:22:25 * copumpkin slaps shachaf 
09:22:32 <mm_freak> nand`: it does‚Ä¶  an applicative functor in fact
09:23:01 <mm_freak> nand`: except some CTists might add that it must obey some rules to be an applicative functor =)
09:23:28 <typoclass> outlaw applicative functor!
09:23:33 <nand`> (it still doesn't work for (.)=fmap I just realized, since the first argument to fmap is already specialized to (->))
09:23:49 * hackagebot file-location 0.4.5.1 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.5.1 (GregWeber)
09:23:52 <shachaf> Applicative Functor is evil because you couldn't make a Set instance of it even if you had a restricted/parameterized/whatever Set thing.
09:24:13 <Cale> shachaf: ?
09:24:20 <copumpkin> good luck making a Set of functions
09:24:24 <hiptobecubic> it's annoying to find the operator you want
09:24:28 <shachaf> Cale: What copumpkin said.
09:24:28 <hiptobecubic> Data or Control...
09:24:35 <copumpkin> it'd probably work more nicely if you used the non-exponential version
09:24:40 <copumpkin> with a liftA2 primitive
09:24:42 <nand`> would there be some sense in generalizing Functor to the form :: c a b -> c (f a) (f b) -- ?
09:24:43 <Cale> Oh, sure.
09:24:55 <shachaf> Or foo :: f a -> f b -> f (a,b)
09:25:12 <Cale> yeah, that's the more obvious formulation
09:25:13 <hiptobecubic> ok so no fmap
09:25:20 <monochrom> > Set.empty :: Set Int
09:25:22 <lambdabot>   Not in scope: type constructor or class `Set'Not in scope: `Set.empty'
09:25:30 <Cale> hiptobecubic: I have always hated those prefixes
09:25:34 <hiptobecubic> but (++)? it's much more reasonable that <>, what the hell does <> mean?
09:25:34 <monochrom> > S.empty :: Set Int
09:25:36 <lambdabot>   Not in scope: type constructor or class `Set'
09:25:41 <rwbarton> nand`, or even c a b -> d (f a) (f b)
09:25:52 <monochrom> ok, I don't know what Data.Set is called in lambdabot
09:25:55 <nand`> rwbarton: yeah
09:26:00 <mauke> > S.empty :: S.Set Int
09:26:01 <lambdabot>   fromList []
09:26:13 <monochrom> > S.empty :: S.Set (Int -> Int)
09:26:15 <lambdabot>   Overlapping instances for GHC.Show.Show
09:26:15 <lambdabot>                              (GHC.T...
09:26:30 <monochrom> there, set of functions :)
09:26:33 <Cale> hiptobecubic: When hierarchical modules were added, it seemed as if everyone went and stuck variously Data or Control on to the names of all the modules almost at random, almost as if just to say "hooray, hierarchical modules!"
09:26:50 <hiptobecubic> At first it looked like it made sense
09:26:57 <startling> I'm still confused about Data.Function.
09:27:01 <Cale> Well, it never really made sense
09:27:12 <nand`> rwbarton: with that formulation, and d as (->); it would be c a b -> f a -> f b; if f is some (c r) then c a b -> c r a -> c r b -- looks surprisingly like (.)
09:27:16 <hiptobecubic> Data was for data types, Control was for combinators
09:27:16 <Cale> Why is Data.Set any better than Set as a module name?
09:27:17 <hiptobecubic> but no.
09:27:43 <mauke> import DataSette
09:27:44 <hiptobecubic> import Data.Controls
09:28:26 <startling> you know what we should allow in the module hierarchy? symlinks
09:28:32 <monochrom> haha
09:28:38 <rwbarton> nand`, so you are saying you can generalize in both directions simultaneously
09:28:42 <startling> import Data.Control.Data.Control.Data.Control.List
09:28:56 <hpc> > "import " ++ cycle "Data."
09:28:58 <lambdabot>   "import Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Da...
09:28:59 <nand`> I'm just not sure it makes sense to define a Functor instance for some Category with the target being (->)
09:30:58 <shachaf> > "import " ++ cycl–µ "Data."
09:31:00 <lambdabot>   "import Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Mushroom.Mushroom...
09:31:17 <nand`> I... what?
09:31:20 <hpc> what the what
09:31:23 <nand`> Mushroom?
09:31:26 * typoclass giggles
09:31:27 <Cale> :t cycle
09:31:28 <lambdabot> forall a. [a] -> [a]
09:31:33 <Cale> hmm!
09:31:39 <nand`> > cycle "Data."
09:31:40 <lambdabot>   "Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data.Data...
09:31:42 <Adeon\SIGSEGV> :t cycl–µ
09:31:43 <lambdabot> Not in scope: `cycl'
09:31:43 <Cale> :t cycl–µ
09:31:44 <ziman> :t (++)
09:31:45 <lambdabot> Not in scope: `cycl'
09:31:45 <lambdabot> forall m. (Monoid m) => m -> m -> m
09:31:47 <Cale> heh
09:31:57 <Cale> That's a curious e
09:32:18 <nand`> did shachaf did something silly like using an alternative look-alike character?
09:32:20 <Adeon\SIGSEGV> > cycl–µ "Eggs"
09:32:22 <lambdabot>   "EggsEggsEggsEggsEggsEggsEggsEggsEggsEggsMushroom.Mushroom.EggsEggsEggsEggs...
09:32:23 <hpc> > ord '–µ'
09:32:24 <lambdabot>   1077
09:32:25 <Cale> yeah, cyrillic
09:32:26 <t7> :t cycle
09:32:27 <lambdabot> forall a. [a] -> [a]
09:32:29 <hpc> > ord 'e'
09:32:30 <lambdabot>   101
09:32:34 <hpc> that was well done
09:32:35 <hpaste> killy9999 pasted ‚ÄúRemoving `cast` from core‚Äù at http://hpaste.org/76949
09:32:45 <hpc> even my unicode-hating putty rendered an 'e'
09:32:50 <killy9999> is there a way to get rid of casts in the core?
09:32:51 <monochrom> shachaf++
09:32:52 <nand`> looks identical to e for me
09:33:04 <ziman> :t cycl–µ
09:33:05 <lambdabot> Not in scope: `cycl'
09:33:09 <ziman> ah
09:33:10 <killy9999> I tried adding type signatures, but it doesn't seem to help
09:33:24 <shachaf> killy9999: No, that's how Core is.
09:33:38 <shachaf> Are you just trying to get rid of them for pretty-printing's sake?
09:33:42 <shachaf> ghc-core will do that for you.
09:34:29 <monochrom> -dsuppress-coercions
09:34:31 <killy9999> shachaf: no, I'm wondering if these are runtime casts that hit performance
09:34:37 <t7> let abandon hindley milner and all use system F derivatives
09:34:39 <typoclass> i wonder if we could just reorganize the module hierarchy in a bold and wild fashion, and then make a package for backwards-compatibility. you'd do "cabal install old-hier", and then you could still use the current module names (Data, Control, ...). those would all just be reexports ...
09:34:42 <monochrom> also, I recomment -dsuppress-uniques
09:34:45 <shachaf> killy9999: No.
09:34:48 * killy9999 was thinking -dsuppress-all
09:35:02 <shachaf> Oh, I didn't know about -dsuppress
09:35:04 <killy9999> shachaf: Ah, OK. If the don't then I have no problem with them
09:35:17 <rwbarton> there are no types at runtime
09:35:18 <quicksilver> typoclass: probably you could yes. The hard part is actually getting people on board to do the re-org. Sounds like the bikeshed to end all bikesheds.
09:35:22 <shachaf> killy9999: They're casts, as in looking at the same piece of memory in a different way.
09:35:34 <shachaf> Languages like C annoyingly use the same term for two very different concepts.
09:35:38 <monochrom> the real question should be: how do I know about all these -dsuppress-bob thingies?
09:35:41 <typoclass> quicksilver: that's true :-)
09:36:07 <killy9999> monochrom: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/flag-reference.html
09:36:09 <rwbarton> right, it is like casting (int *) to (double *), not like casting int to double
09:36:21 <hiptobecubic> shachaf, you could do it one package at a time, by the maintainer. Have both by default even?
09:36:26 <monochrom> well, now you know
09:36:39 <shachaf> monochrom: Did you, like, read the manual, dude?
09:36:42 <shachaf> We don't do that here.
09:36:43 <monochrom> yes
09:37:05 <monochrom> also, if you install GHC on your disk, the GHC manual is also on your disk
09:37:08 <nand`> asking on IRC is easier than reading the manual
09:37:14 <nand`> I don't even understand why
09:37:17 <rwbarton> ew getitoffgetitoff!
09:37:35 <typoclass> "the manual? you mean, the manufacturer's opinion?"
09:37:41 <shachaf> monochrom: To be fair, I've read the code for ghc-core, which strips off the `cast`s manually.
09:37:42 <otters> asking on IRC is reading the manual
09:37:46 <otters> because lookup time is WAY faster
09:37:48 <shachaf> I assumed that dons had read the manual.
09:37:50 <otters> *better than
09:38:02 <rwbarton> i just took a look and -dsuppress-casts didn't exist in 6.12
09:38:10 <nand`> I misread that as -dsuppress-cats
09:39:16 <monochrom> asking is easy. getting a correct answer is not so easy. you are actually lucky in this case because I happen to be procrastinating real work and catch this question. If I were away, you would not get that answer
09:40:57 <portnov> hi all.
09:41:08 <portnov> http://www.downforeveryoneorjustme.com/haskellers.com :/
09:41:09 <killy9999> hm...
09:41:11 <rwbarton> wow, someone is proposing deprecating "deriving Typeable"
09:42:01 <rwbarton> as in, marking deprecated and then removing
09:42:17 <shachaf> rwbarton: Are they proposing an alternative?
09:42:23 <jfischoff> hmm that's odd
09:42:29 <rwbarton> oh yeah, automatic Typeable instances for everyone
09:42:38 <rwbarton> but still, can't it just be left as a no-op forever
09:42:52 <typoclass> quicksilver: but maybe the bikeshedding would not get terribly out of hand. probably people could agree on moving everything from Data and Control one level up, and i thought that's the most pressing criticism
09:42:57 <jmcarthur> well, it would break peoples' code anyway, no?
09:43:11 <jmcarthur> unless they enable overlapping instances or somesuch
09:43:20 <nand`> not like GHC upgrades should be compatible with older versions of packages or anything
09:43:43 <jmcarthur> i'm in favor of just deprecating Typeable if we are going to have auto Typeable instances anyway
09:43:51 <jmcarthur> *deprecating deriving Typeable
09:43:54 <jmcarthur> oh
09:44:06 <jmcarthur> now that i made that correction i realize what it was you actually said
09:44:11 <rwbarton> yes
09:44:13 <nand`> typoclass: personally I feel that the present hierarchy could be mostly maintained by simply deleting Control and Data entirely. Almost every package I know is either defined at the top level with its own namespace, or in one of those two
09:44:13 <jmcarthur> yeah, it could make sense to just make it noop
09:44:21 <nand`> at least that's the way it feels
09:44:29 <jmcarthur> and i was saying weird things in any case
09:44:58 <typoclass> nand`: yeah exactly, deleting Control and Data would really solve 80% of all criticism, wouldn't it
09:45:13 <quicksilver> I don't think millions of names at the top level feels like the right solution.
09:45:17 <monochrom> delete System for the other 20% :)
09:45:19 <quicksilver> NB I don't know what the right solution is.
09:45:20 <rwbarton> what module names are applications supposed to use?
09:45:24 <nand`> from my .ghci: 23 Control. imports, 44 Data. imports; and a few that are in their own namespace
09:45:30 <nand`> oh, and one System.
09:45:35 <rwbarton> I was vaguely under the impression that applications used top-level modules
09:45:38 <nand`> so it seems I'm not just delusional
09:45:46 <rwbarton> at least, mine do because I am too lazy :)
09:46:13 <nand`> rwbarton: sure, I agree that they should use a top-level module; not like it matters since they aren't going to be exported as libraries to other packages
09:46:51 <monochrom> I am not sure about automatic Typeable for everyone. Look at seq, that's the equivalent of automatic Seq for everyone, and people resent it
09:46:55 <rwbarton> but... base keeps adding more Data.* modules
09:47:04 <nand`> quicksilver: right now, we have millions of names at the second level, but you have to remember whether it was Control or Data
09:47:09 <rwbarton> say my application has a module named Function, perfectly reasonable
09:47:21 <rwbarton> now I update to ghc 6.12 or whatever and suddenly I have a collision with base
09:47:42 <rwbarton> in the hypothetical non-"Control.* Data.*" world
09:47:44 <nand`> rwbarton: oh, that's not what I meant
09:47:59 <shachaf> Stuff.Function
09:48:09 <nand`> rwbarton: I meant eg. you'd have a program name, like say I'm writing a Tetris clone, I'd use Tetris.Types, Tetris.Drawing, Tetris.Whatnot
09:48:14 <rwbarton> I see
09:48:22 <nand`> that's how I do it
09:48:24 <typoclass> rwbarton: i don't think top level modules are a problem, you're not polluting any global space or anything. (you might argue package names are a bigger problem, since once somebody uploads a "lens" package or whatever, that name is taken and blocked)
09:48:28 <rwbarton> I guess I am influenced by ghc's module naming also
09:48:38 <monochrom> automatic Seq brings you a way to distinguish ‚ä• and (\_ -> ‚ä•). this is a very minor glitch, and people already resent it
09:48:41 <shachaf> rwbarton: Have you been reading GHC code?
09:48:45 <shachaf> It's bad for your health.
09:48:48 <rwbarton> but then ghc predates hierarchical modules
09:48:57 <rwbarton> no, just vaguely aware of the "ghc" package
09:49:07 <shachaf> Most Haskell code predates hierarchical modules.
09:49:12 <shachaf> Because hierarchical modules don't exist. :-(
09:49:41 <Philippa> nested modules would be nice, yeah
09:49:41 <nand`> pseudo-hierarchical modules naming
09:49:43 <typoclass> rwbarton: collisions on updating ghc are a good point, but really, a compiler update can break any number of things in any number of ways
09:49:52 <Philippa> hell, a proper module system would be :p
09:50:04 <monochrom> automatic Typeable will bring you more. f :: a->a breaks parameteric polymorphism because f x = if (x has type Int) then x+1 else x
09:50:24 <typoclass> (... which is probably part of the problem anyway)
09:50:27 <shachaf> monochrom: No, you'd still need Typeable a =>, presumably.
09:50:29 <rwbarton> here is an example, ghc has a module Binary, there is also Data.Binary
09:50:33 <rwbarton> shachaf, yes
09:50:33 <shachaf> It would just be automatically derived.
09:50:47 <shachaf> monochrom: (Just like the Eval class in Haskell 1.4.)
09:51:05 <rwbarton> typoclass: well, it shouldn't!
09:51:13 <nand`> it's not automatic Typeable, it's automatic deriving Typeable
09:51:18 <rwbarton> not if I am not using any extensions
09:51:33 <shachaf> GHC is a little too break-things-happy.
09:51:35 <rwbarton> I guess then there is the "haskell98" package
09:51:47 <shachaf> ...And then the things they break aren't even the interesting ones!
09:52:14 <monochrom> oh, my "Seq" is really called Eval
09:52:17 <nand`> monochrom: wouldn't you still need unsafeCoerce to get the x+1 back into ‚Äòa‚Äô ?
09:52:43 <typoclass> yes, package ghc has a module Binary, but usually you don't depend on that package for no reason ...?
09:52:57 <rwbarton> typoclass, what if I am the developer of ghc
09:53:26 <rwbarton> and let's imagine that ghc is some other application as this example is a bit circular :)
09:53:36 <monochrom> well then, "just like the Eval class" is exactly right. see what happened between 1.4 and 98? because Eval is automatic, "(Eval a) =>" is waived too. The same will happen to "(Typeable a) =>", it will be waived, my example code will be accepted as valid
09:54:07 <shachaf> monochrom: Have you considered a career is dystopian fiction?
09:54:34 <monochrom> I can't do that as well as Husley did
09:54:46 <monochrom> Husley? Huxley?
09:55:07 <fruitFly> what is pattern matching?
09:55:54 <nand`> observing the constructor
09:58:00 <rwbarton> typoclass: anyways I don't think it is an issue as long as application developers are expected to use module names MyApp.*
09:58:09 <monochrom> nand` is right, I'm missing unsafeCoerce. but I have another card to play
09:58:13 <typoclass> fruitFly: it's for example having a function "f :: Maybe a -> Int" which is implemented as "f Nothing = 42", "f (Just _) = 37". the parts between "f" and "=" are the pattern matching parts
09:58:31 <nand`> monochrom: I guess you could cast it back to Maybe a (hooray, Typeable)
09:58:31 <typoclass> rwbarton: right
09:58:39 <fruitFly> I want to build a web app at that checks the prices of assets on exchanges. Do exchanges have api's that would work with haskell webframeworks--allowing me to do this?
09:58:51 <monochrom> f :: a->Bool; f x = (x has type Int). this breaks parametric polymorphism
09:58:52 <nand`> and get that back to an ‚Äòa‚Äô using the ‚Äòa‚Äô we already have (which, will never be used either way but makes the type happy) or just fromJust
09:59:00 <rwbarton> this is a pretty large step from "what is pattern matching"
09:59:37 <nand`> not to be confused with pattern recognition
09:59:40 <fruitFly> rwbarton: just want to know what's possible
10:00:00 <Cale> fruitFly: It might be a bit too much to ask for the exchanges themselves to provide Haskell APIs. There are a lot of people in finance who are using Haskell, so some bindings may have been written. However, by the nature of that sort of thing, a lot of it is likely private.
10:00:22 <nand`> monochrom: yeah, that's a good example
10:00:33 <Cale> fruitFly: If it's anything like a normal web API, then it should not be difficult to make a Haskell library to interact with it.
10:01:12 <monochrom> fruitFly is probably running several threads, one thread doing basic haskell, another thread writing a high profile webapp :)
10:01:15 <Cale> (and the only question is whether anyone's bothered to actually release whatever code they have written, or whether anyone's done it in the first place)
10:01:21 <nand`> monochrom: with auto-Typeable, we could do away with types in the first place and just use Dynamic
10:01:25 <typoclass> fruitFly: i think mostly, there'll be some api that involves constructing http requests with certain parameters (for example meaning "give me the price for ticker symbol ABC"). the service will answer the request with a reply that might be xml, or something less complex, or something more complex
10:01:34 <rwbarton> this is really a question "how do I get information about prices of assets on exchanges"--nothing to do with haskell
10:01:37 <nand`> just needs auto-casting as well where necessary
10:01:40 <nand`> and we're good to go
10:01:44 <monochrom> but "does an exchange tell you its API" depends on the actual exchange
10:01:50 <typoclass> fruitFly: so the first step will be to learn constructing and sending http requests with haskell :) you could start with the http-conduit package
10:02:02 <typoclass> @hackage http-conduit
10:02:03 <lambdabot> http://hackage.haskell.org/package/http-conduit
10:02:12 <Cale> rwbarton: Well, you can imagine in an ideal world, the exchanges themselves would provide Haskell code you could use to make queries :)
10:02:28 <nand`> depending on how broadly you define API; surely that must include the HTTP+HTML interface it provides?
10:02:38 <shachaf> I certainly hope Haskell isn't the language people would use in an ideal world.
10:02:46 <Cale> okay okay
10:03:10 <Cale> shachaf: Well, we might still call it Haskell :)
10:03:28 <nand`> wouldn't an ideal world imply every problem being solved, every bit of knowledge already being known, etc.?
10:03:35 <typoclass> fruitFly: oh and i forgot, apart from understanding http-conduit, if you have some basic understanding of what an http request looks like, that'll certainly be handy :)
10:03:37 <Cale> heh
10:03:38 <nand`> I don't know what an ‚Äòideal‚Äô world is in the first place
10:03:56 <nand`> probably one without humans
10:04:08 <rwbarton> f :: a -> a ; f = fromMaybe id (cast (\x -> x + 1 :: Int))
10:04:30 <fruitFly> Thanks typoclass: nand`: Cale: lambdabot: You guys are always an amazing help.
10:04:38 <Cale> It's a world which is downward closed and directed.
10:04:40 <Cale> ;)
10:05:27 <nand`> oh, I didn't realize functions are Typeable too; that works
10:05:56 <typoclass> fruitFly: you're welcome
10:06:24 <nand`> wait what; I ignore fruitFly's question and instead use it as inspiration for musing about ideal worlds and I get cited in the helper list?
10:07:43 <fruitFly> nand`: just your presence has helped me cogitate
10:08:02 <nand`> ah, fair enough
10:13:50 * hackagebot happstack-clientsession 7.2.2 - client-side session data  http://hackage.haskell.org/package/happstack-clientsession-7.2.2 (JeremyShaw)
10:19:54 <nand`> is indiscrete a synonym for continuous?
10:20:09 <atriq> I think so
10:20:15 <Cale> Not quite
10:20:35 <Cale> It's sort of the opposite of discrete where everything is lumped together in such a way as to be topologically indistinguishable
10:20:36 <byorgey> indiscreet is a synonym for a blabbermouth
10:20:41 <shachaf> Indiscrete as in indiscrete topology?
10:21:14 <saml> hey, monad
10:21:18 <typoclass> blabbermouth is a synonym for babbling continuously
10:22:36 <nand`> shachaf: in general; for example if I want to describe the difference between a quantized digital signal and a true sine wave; I could use ‚Äòindiscrete‚Äô to describe the latter
10:22:46 <Cale> nand`: I wouldn't
10:23:10 <shachaf> Well, "indiscrete topology" has a precise meaning.
10:23:35 <rwbarton> and there are other parallel uses of indiscrete like "indiscrete category"
10:23:41 <shachaf> Are you looking for precise-meanings or English-meanings? :-)
10:23:54 <Cale> A discrete space is one where every subset is open (and also closed), which means that every point is in some sense "far away" from other points. An indiscrete space is one in which only the empty set and the entire space are open (and closed), and so you can't separate the points from each other at all by open sets.
10:24:03 <RenJuan> so this isnt discrete vs contin?
10:24:18 <RenJuan> (uous)
10:24:21 <Cale> Geometrically, this means that all the points are "overlapping" from the perspective of the topology
10:24:23 <rwbarton> indiscrete does not mean "not discrete"
10:24:43 <RenJuan> that would be too easy
10:24:48 <Cale> Not just connected smoothly, but so strongly connected that you can't tell them apart.
10:24:50 <rwbarton> also useless
10:25:55 <Cale> It's possible, in a topological space, to have two points such that any open set containing one of them will contain the other as well.
10:26:10 <rwbarton> (because (1) you hardly ever need to specify that something is *not* discrete (2) if you do you can just use the phrase "not discrete")
10:26:49 <rwbarton> nand`: can you just describe it as 'continuous'?
10:27:11 <lispy> Cale: is that equivalent to a dedekind cut?
10:27:12 <rwbarton> or are you looking to understand a use of the word 'indiscrete'
10:27:14 <Cale> Perhaps the word you're looking for is "connected"?
10:27:27 <Cale> lispy: The real numbers don't have any such points
10:27:36 <nand`> rwbarton: the former; I'm just curious about how I internalize my (non-mathematical) interpretation of the word ‚Äòindiscrete‚Äô
10:27:42 <lispy> Cale: oh, I guess I totally misunderstood :)
10:28:06 <lispy> Cale: I guess you mean 'any' as in forall?
10:28:07 <rwbarton> I see
10:28:33 <Cale> lispy: In fact, more is true: if you have any two distinct real numbers x and y say, then it's possible to choose disjoint open sets U and V where x is in U and y is in V.
10:28:36 <rwbarton> 'indiscrete' happens to be a technical term with the meaning Cale described (which is fairly exotic in a sense)
10:28:37 <nand`> if ‚Äòindiscrete‚Äô has a totally separate meaning in topology or somewhere else then I could avoid it when speaking about mathematics
10:29:03 <Cale> nand`: Yes, it has various technical senses throughout mathematics which stem from its use in topology.
10:29:41 <Cale> In category theory, an indiscrete category on a set of objects is one which for any pair of objects there is exactly one arrow between them, making all the objects isomorphic in a unique way.
10:30:11 <Cale> By contrast, the discrete category on a set of objects is one which only has the identity arrows.
10:30:26 <Cale> (and no two distinct objects are connected by an arrow)
10:31:36 <rwbarton> any subspace of euclidean n-space, say, can never be indiscrete
10:31:48 <rwbarton> so in that sense "indiscreteness" is far from our physical experience
10:32:14 <rwbarton> more of a technical term that has to do with a particular formalization of topology
10:32:15 <Cale> except possibly a single point
10:32:30 <Cale> (which is indiscrete in a trivial sort of way)
10:33:25 <Cale> You can also analogously define these terms for preorders, in a similar way that you do for categories.
10:33:46 <Sculptor> hi!
10:33:49 <Cale> The discrete preorder on a set has all elements incomparable to anything but themselves.
10:34:17 <Cale> The indiscrete preorder has all elements comparable, but x <= y and y <= x
10:34:40 <Cale> (which ruins the chances of this being a partial order when x and y are not equal)
10:41:57 <Palmik> Hmm, is there any difference between the terms "type family" and "indexed type family" or can their use interchangeable?
10:42:43 <nand`> so indiscrete is distinct from ‚Äúnot discrete‚Äù in CT?
10:43:16 <Rotaerk_> not divided or divisible into parts; "layers that were fused into an indiscrete mass"
10:43:36 <Rotaerk_> oh, technical term
10:45:44 <rwbarton> nand`: I think the best term for the idea you want, though it's not totally satisfactory either, is just "continuous"
10:46:52 <nand`> yeah
10:46:59 <nand`> or differentiable, if I want to exclude sharp corners too
10:47:16 <rwbarton> well, I don't even mean that your signal needs to be a continuous function
10:47:28 <rwbarton> just that it is defined over the real numbers, rather than over the integers
10:47:54 <rwbarton> that's why I say the term isn't exactly right
10:49:33 <rwbarton> ah
10:49:36 <rwbarton> http://en.wikipedia.org/wiki/Continuous_signal
10:51:11 <nand`> surely a square wave is a continuous signal too by that definition
10:51:39 <nand`> f 0 = 0; f _ = 1 -- domain is a connected interval of the reals
10:51:58 <nand`> which doesn't capture the essence here I think
10:53:37 <shachaf> What essence are you trying to capture?
10:54:04 <nand`> the essence of not being divisible into clearly identifiable, homogenous regions
10:54:11 <nand`> like for example pixels on an image
10:54:28 <nand`> or a square wave
10:54:55 <shachaf> "smooth", maybe?
10:54:59 <Cale> an ideal square wave is not a continuous function
10:55:17 <nand`> Cale: right, but it apparently is a continuous signal, by that wiki article
10:55:18 <shachaf> Cale: Yes, but it's a continuous signal. :-)
10:55:21 <Cale> right
10:55:33 <rwbarton> (it's also rather unphysical)
10:55:54 <nand`> though the usage of ‚Äòcontinuous‚Äô here still captures the same essence if you think about it
10:55:59 <nand`> just in a different domain
10:56:04 <Cale> So what you're looking for is perhaps "discontinuous" or even perhaps "locally constant"
10:56:20 <shachaf> distinuous
10:56:23 <shachaf> (As opposed to concrete.)
10:57:25 <nand`> I could go with ‚Äòpixelated‚Äô; everybody knows what that means
10:57:55 <Cale> Or perhaps "aliased"
10:58:14 <Philippa> "discretely sampled"?
10:58:31 <nand`> sampled sounds good, actually
10:58:51 <rwbarton> sampling is exactly what that wikipedia page I linked to is about
10:59:10 <nand`> ‚ÄúIn signal processing, sampling is the reduction of a continuous signal to a discrete signal.‚Äù <- maybe they meant ‚Äòcontinuous function‚Äô, not ‚Äòcontinuous signal‚Äô?
10:59:21 <nand`> oh
10:59:23 <nand`> no, they did not
10:59:51 <rwbarton> you can also imagine a "dual" notion. "posterized"
10:59:54 <nand`> yes, I see what it means now; chopping up the time domain - which is very related but not identical to what I was describing
11:00:24 <nand`> ‚ÄúPosterization of an image entails conversion of a continuous gradation of tone to several regions of fewer tones, with abrupt changes from one tone to another.‚Äù
11:00:26 <nand`> yes this sounds good
11:00:35 <Cale> yeah, perhaps you're looking for a term for having a discrete codomain
11:00:40 <rwbarton> domain can still be continuous, but only a (small) finite number of possible outputs
11:01:05 <nand`> Cale: pretty much
11:01:26 <nand`> how about ‚ÄúA function on ‚Ñù with a finite codomain‚Äù?
11:01:37 <nand`> surely that can't have any ‚Äòsmoothness‚Äô or ‚Äòslants‚Äô as it were
11:02:02 <nand`> ah, but it excludes something like ‚Äòfloor‚Äô
11:02:15 <nand`> I'll go with posterized
11:02:21 <shachaf> Countable codomain? :-)
11:02:26 <rwbarton> discrete codomain like Cale said
11:02:50 <nand`> is that ‚Äòdiscrete‚Äô a topology term?
11:03:07 <Cale> yes
11:03:07 <rwbarton> yes
11:03:22 <rwbarton> but it is also one which corresponds well to intuition about discreteness
11:03:35 <nand`> that sounds healthy
11:03:58 <nand`> excellent. Now I can work it into my explanation of how real world image sensors work; ‚Äòwith a discrete codomain‚Äô
11:05:29 <Jafet> "wtf is a discrete codomain"
11:05:58 <nand`> a discrete codomain is just an orientable multiset whose elements are computable bijections
11:06:01 <nand`> what's the problem?
11:06:20 <otters> phew, they're computable
11:06:23 <otters> I was worried
11:06:26 <rwbarton> you've been at that site again, haven't you ;)
11:06:28 <hiptobecubic> why do they have to be bijections?
11:06:48 <otters> I once had a bijection to prevent tetanus
11:06:49 <Cale> Heh, if you're an engineer I guess it's a continuous one where we've used amplifiers to reduce the width of the bands where it lies in particular forbidden intervals
11:07:01 <Jafet> That site needs to tack on "what's the problem"
11:07:24 <nand`> rwbarton: an excellent site
11:07:48 <nand`> useful for whenever I need to insert generic spooky-sounding mathematical lingo
11:07:57 <nand`> for comedic or dramatic effect
11:08:00 <otters> which site?
11:08:04 <nand`> http://theproofistrivial.com/
11:08:22 <Cale> hiptobecubic: because randomness decided it
11:08:40 <nand`> I think hiptobecubic was making a joke
11:08:54 <nand`> ‚Äúplaying along‚Äù, so to say
11:09:48 <hiptobecubic> this sites needs a bit more 'wrapping'
11:10:44 <nand`> I want that site as a haskell function
11:10:48 <nand`> IO String
11:10:55 <otters> should be trivial
11:10:57 <nand`> s/function/action/ to make shachaf happy
11:11:05 <otters> just view the webpage as a countable metric space whose elements are prime tournaments
11:11:10 <johnw> wait, there's a way to make shachaf happy?
11:11:17 <nand`> s/happy/less grumpy/
11:11:23 <johnw> :)
11:11:35 * shachaf is pretty grumpy right now, not having gotten any sleep this night.
11:11:50 <copumpkin> shachaf: just drink 5 red bulls
11:11:53 <hiptobecubic> nand`, just make it String :)
11:11:59 <nand`> shachaf sleeps? I thought he lurks
11:12:15 <nand`> hiptobecubic: String ‚âÖ ‚Ñï ‚Üí Char
11:12:17 <nand`> function
11:12:19 <nand`> done
11:12:32 <nand`> well, not quite
11:12:34 <johnw> when his brain starts lurking in his own head, we call it his sleep state
11:12:42 <nand`> but some subset of ‚Ñï at any rate
11:13:02 <shachaf> ((n:‚Ñï),Fin n) ‚Üí Char
11:13:03 <copumpkin> nand`: not really
11:13:07 <copumpkin> yeah, that
11:13:08 <hiptobecubic> f = unsafePerformIO $ newQuote -- Now it's deterministic :)
11:13:11 <Eduard_Munteanu> Stream ‚âÖ ‚Ñï ‚Üí Char ?
11:13:21 <copumpkin> StreamOfChars = Nat -> Char
11:13:24 <copumpkin> :P
11:14:14 <nand`> Stream ‚âÖ (‚Üí) ‚Ñï
11:14:20 <shachaf> copumpkin: I think I got my parenthesis wrong.
11:14:24 <shachaf> ((n:‚Ñï),Fin n ‚Üí Char)
11:14:29 <hiptobecubic> oh... the string is generated client side.
11:14:31 <Jafet> StreamOfChars = Net -> Char
11:15:30 <copumpkin> shachaf: shouldn't really matter there
11:15:34 <copumpkin> I don't think?
11:15:47 <shachaf> copumpkin: The first version lets the caller pick the length, doesn't it?
11:16:14 <copumpkin> oh, true
11:17:00 <shachaf> It's a pyramid of strings.
11:17:20 <nand`> or a stream
11:17:21 <danr> pyramid of chars?
11:17:31 <nand`> ..which is also a pyramid
11:17:33 <nand`> so yeah
11:19:05 <shachaf> Well, an infinite pyramid.
11:19:30 <shachaf> i do not know where family doctors ...
11:20:03 <nand`> (is there a more technical term for this? something like a diagonal matrix but with one side filled as well)
11:20:32 <nand`> if bidiagonal means there's an extra line next to the diagonal, then maybe n-diagonal
11:21:03 <copumpkin> tridiagonal means you have both sides filled
11:21:09 <copumpkin> on each side of the diagonal
11:21:12 <nand`> okay
11:21:20 <copumpkin> not sure people generally generalize that
11:21:23 <copumpkin> but possibly?
11:21:24 <nand`> ‚Äòtriangular matrix‚Äô?
11:21:25 <hiptobecubic> banded
11:21:29 <copumpkin> that's different
11:21:33 <shachaf> copumpkin: That's normally called a "rectangle"
11:21:40 <simpson> Heh.
11:22:08 <hiptobecubic> you can have bands at any diagonal, tridiagonal is just the special case of offsets (-1, 0, 1)
11:22:08 <nand`> A square matrix is called lower triangular if all the entries above the main diagonal are zero. Conversely a square matrix is called upper triangular if all the entries below the main diagonal are zero.
11:22:21 <hiptobecubic> oh you mean the whole half-matrix filled
11:22:40 <nand`> okay; so it's an infinite triangular matrix
11:22:41 <nand`> of chars
11:23:35 <gwern> @quote
11:23:35 <lambdabot> HaskellLove says: your Phd supervisor is my uncle, watch out !
11:28:18 <jmcarthur> ah HaskellLove...
11:28:39 <troydm> @quote
11:28:39 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
11:29:20 <Palmik> Hmm, would you say this sentence makes sense: "The contructors of GADT can carry more type information than the contrstructor of regular ADT -- this for example allows for type refinement by pattern matching the GADT's constructor." I'm not quite happy with the first part, but I guess you get the idea.
11:30:24 <Palmik> Can anyone think of more formal way of expressing the idea of the first (part of the) sentence without being too verbose?
11:30:26 <fruitFly> tell :: (Show a) => [a] -> String   tell [] = "The list is empty"   tell (x:[]) = "The list has one element: " ++ show x   tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y   tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y   This function is safe because it takes care of the empty list, a singleton list, a list with two elements and a list with more than two
11:30:31 <byorgey> Palmik: it makes sense, though it's somewhat vague, and I don't think it would help anyone who didn't already know what GADTs are
11:30:44 <fruitFly> sorry
11:30:58 <Palmik> byorgey, yes, I accompany it with an example, but I would like to find a better formulation as well.
11:32:05 <fruitFly> http://learnyouahaskell.com/syntax-in-functions why can't you rewrite it like that? search the second instance of rewrite on that page if you want to help.. simple stuff
11:32:30 <byorgey> Palmik: how about something like "The constructors of a GADT can restrict the arguments to the type"
11:33:43 <byorgey> fruitFly: because the pattern [x:y:_] means a list containing a single element, which is itself a list containing at least two elements
11:33:52 * hackagebot montage 0.1.1 - Riak Resolution Proxy  http://hackage.haskell.org/package/montage-0.1.1 (ErinDahlgren)
11:33:54 * hackagebot montage-client 0.1.1 - Riak Resolution Proxy Client  http://hackage.haskell.org/package/montage-client-0.1.1 (ErinDahlgren)
11:33:56 <rwbarton> fruitFly: because any list literal or list pattern written with [x,y,...,z] has a fixed length
11:33:59 <byorgey> fruitFly: the pattern [p] always means a singleton list whose single element matches the pattern p
11:34:49 <fruitFly> rwbarton: thanks!
11:35:25 <fruitFly> byorgey: Thanks
11:36:48 <fruitFly> so rwbarton: (x,y,_) is a subset of a list [x,y,_,...]?
11:37:29 <Palmik> byorgey, that souds quite good, I will write it down and ponder about it for a while. .)
11:37:47 <rwbarton> fruitFly, I don't understand
11:39:26 <byorgey> fruitFly: (x,y,_) is a pattern that matches a three-tuple, it has nothing to do with lists at all
11:39:35 <byorgey> (x:y:_) matches any list with at least two elements
11:40:00 <byorgey> i.e.  [x, y, ...]
11:41:18 <GHAI> aye
11:41:55 <byorgey> in my opinion LYAH makes a grave mistake by not emphasizing the inductive structure of lists.
11:42:02 <GHAI> i wonder if the debugger in ghci is any good to get something like a tree of stackframes for educative purposes while haskell is used in a functional programming 101 university cource
11:42:03 <byorgey> or shall we say misses a great opportunity.
11:42:06 <GHAI> course
11:42:21 <byorgey> GHAI: no, it isn't
11:42:29 <GHAI> is it good for anything?
11:42:36 <byorgey> GHAI: in fact, there is no such thing as stackframes during Haskell runtime evaluation
11:42:47 <GHAI> it should be with recursion
11:42:54 <typoclass> fruitFly: the important thing to look for is the ":" which indicates a list, and the "," which indicates a tuple. the parens are just for grouping
11:43:15 <GHAI> if its not tail recursion, there is got be some stack used - on the assembler level
11:43:53 <byorgey> GHAI: yes, there is a stack used when evaluating expressions, but recovering it with the debugger is not possible
11:43:57 <Cale> GHAI: there is no call stack
11:44:09 <GHAI> or, other way round: are there any reasonable ways to get such an output?
11:44:28 <GHAI> i'ld like to see where i shoot myself in the foot with a given recursion
11:44:30 <fruitFly> byorgey: rwbarton: so the function accepts a list but in the function definition the parameter is written in parens NOT as a tuple, right, just for grouping. Why need the parens. And can you not rewrite (x,y,_z) in that function as [x,y,_] because it implies only 3 emelms?
11:44:34 <Cale> At some level there is a stack of case expressions (or pattern matches, if you prefer), who are waiting for their scrutinee to be sufficiently evaluated to match
11:44:45 <Nereid> fruitFly: no, because they have completely different types
11:44:59 <Cale> But unfortunately we have very few tools to observe this. I don't really know why that is.
11:45:12 <GHAI> and i wonder if i can schoenfinkel values into functions
11:45:23 <fruitFly> Nereid: http://learnyouahaskell.com/syntax-in-functions search for the second instance of rewrite
11:45:26 <Cale> That wouldn't be the right word...
11:45:30 <GHAI> or rather what it looks like, the other functional language had a way to express lambda
11:45:50 <Nereid> fruitFly: yes, (x:y:_) is very different from (x,y,_)
11:45:54 <Cale> Currying/Schoenfinkeling means to take a function of a tuple, and turn it into a function which results in another function
11:45:57 <Cale> :t curry
11:45:59 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:46:02 <Cale> like that
11:46:14 <Cale> the parentheses go like this:
11:46:24 <Cale> ((a,b) -> c) -> (a -> (b -> c))
11:47:07 <GHAI> (with "other functional language" being OPAL)
11:47:15 <Cale> Normally we do not think of non-function values as functions. However, it might be an attractive prospect for some people, because in terms of the low level representation, values are pointers to code.
11:47:18 <Palmik> byorgey, how about this: "The constructors of GADT can restrict the domain of arguments of the type, thus they can carry more type information than constructors of regular ADT -- this for example allows for type refinement by pattern matching the on the GADT's constructors."
11:47:38 <Cale> (and some people are used to thinking of any chunk of code as a "function" even if it has no parameters)
11:47:42 <hiptobecubic> schoenfinkel :D
11:47:47 <typoclass> > let f = map pred in f [1..4] -- GHAI, here's an argument being curried onto the function map. it still expects its second argument, which we give it later as [1..4]
11:47:48 <lambdabot>   [0,1,2,3]
11:47:50 <fruitFly> sorry I was writing it wrong. [x,y] is syntactic sugar for (x:y:[])... so why can't I rewrite (x:y:_) as [x,y,_]
11:48:14 <GHAI> hm
11:48:23 <hiptobecubic> fruitFly, what would _ be?
11:48:26 <GHAI> looks quite a bit different
11:48:31 <Cale> GHAI: It's more useful in ordinary work, when trying to understand the performance of code, to think about expressions being rewritten at runtime.
11:48:38 <Ferdirand> because [x,y,_] is x:y:_:[]
11:48:43 <rwbarton> fruitFly: because [x,y,_] is sy... yes, that.
11:49:07 <geekosaur> and if you ask why that does not make sense, ask yourself the type of _ there
11:49:10 <Cale> GHAI: and the pointers to code are just a funny way of representing expressions at runtime which happens to be reasonably efficient
11:49:35 <GHAI> yup, the rewriting process would be closer to lambda replacements...
11:49:40 <Cale> yes
11:49:43 <Nereid> @where stg
11:49:43 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
11:50:06 <Cale> and if you want to get really fine about things, you might want to be careful about the exact graph structure of the expressions, rather than thinking of them as trees
11:50:17 <GHAI> i am still a little annoyed by the space based blocks
11:50:18 <Cale> because you can have things like  let x = 5 + 5 in x + x
11:50:23 <fruitFly> rwbarton: Ooooooooooh... Thanks and hiptobecubic: and Ferdirand:
11:50:26 <byorgey> Palmik: I still don't think you need the part about "carry more type information" -- it is so vague as to be meaningless
11:50:28 <Nereid> or graph reduction yeah
11:50:55 <Cale> which will end up looking like + with two arcs to the same node representing x, which will be a + with two arcs to 5
11:50:55 <GHAI> Cale and that would bring 5 and 5 in x+x?
11:51:04 <byorgey> Palmik: also, what is the intended audience?
11:51:14 <hiptobecubic> GHAI, there is ghc-vis
11:51:15 <Cale> and once x is computed, its result will be reused, and not computed again
11:51:18 <Jafet> @where stepeval
11:51:18 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
11:51:21 <fruitFly> Is _ like a keywoard. What is its functionality?
11:51:35 <hiptobecubic> GHAI, it doesn't show what you really want, but it shows values and things well
11:51:35 <rwbarton> it is a pattern which matches anything
11:51:43 <Nereid> fruitFly: in a pattern, _ is just like any other variable
11:51:47 <Cale> fruitFly: In patterns, _ is a wildcard which matches anything and does not bind a variable
11:51:57 <GHAI> hiptobecubic looks like a full ghci-session
11:51:58 <bfgun> hello, what is a container with O(1) random access that has the closest possible interface with lists?
11:52:07 <fruitFly> Nereid: Cale: Thanks!
11:52:10 <hiptobecubic> GHAI, can be used as a library also
11:52:19 <Cale> bfgun: Such a thing does not exist, even theoretically
11:52:21 <Nereid> so you can replace _ with any variable that doesn't appear elsewhere and you'll get the exact same thing
11:52:35 <centrinia> > let iszero 0 = True; iszero x = False in map iszero [-10..10]
11:52:36 <lambdabot>   [False,False,False,False,False,False,False,False,False,False,True,False,Fal...
11:52:41 <Cale> bfig: However, you can get logarithmic access
11:52:46 <parcs`> bfig: Seq maybe
11:53:00 <Cale> bfig: Seq, and Array, and so on :)
11:53:04 <GHAI> that looked usefull
11:53:13 <Cale> Seq has something fairly close to lists
11:53:19 <GHAI> it would be nice if i could use that locally with all the .hs-files
11:53:32 <Palmik> byorgey, hmm -- this part is about brief coverage of technologies (in this case language extensions) used to develop certain library -- this section also includes short examples of code (for example the type refinement). The intended audience should know what ADTs are.
11:53:34 <Cale> But it has log time splitting and concatenation, and constant time access to the ends
11:53:45 <hiptobecubic> is Seq a finger tree implementation?
11:53:47 <Cale> and it also doesn't allow infinitely long sequences
11:53:48 <Cale> yeah
11:53:56 <Cale> Seq is a specialised finger tree
11:54:29 <fruitFly> why does tell (x:y:_) have to be in parens?
11:54:30 <Cale> Seq will have worse constant factors than lists if you use it in only the same way that you'd use a list though
11:54:54 <afarmer> fruitFly: because : is an infix constructor
11:54:57 <Cale> fruitFly: because  tell x:y:_ parses as (tell x):y:_
11:55:10 <Cale> because function application consistently binds tighter than any infix operator
11:55:13 <afarmer> it has lower precidence than function application
11:55:33 <afarmer> op, I'll butt out
11:55:59 <fruitFly> Cale: you always give the most amazing responses :) and thank you too afarmer:
11:57:05 <typoclass> fruitFly: might also have to do with (x:y) being no different from (x : y), but in a function argument list, it might be hard to see what's going on if you could write "tell x : y = ..."
11:58:06 <refried_> newbie question..  how do nested "do" blocks work out, type-wise, with only a single return?  I'm looking at the function on line 8.   http://pastebin.com/m8SBqHrE
11:58:10 <mauke> The paste m8SBqHrE has been copied to http://hpaste.org/76950
11:58:20 <refried_> oh that's nice
11:59:01 <Cale> refried_: you should think of a do-expression as gluing together many small actions to construct a larger one
11:59:19 <refried_> Cale: *nod*
11:59:27 <Cale> refried_: each of the lines of the do-block will have on it another action (or a let with some declarations)
11:59:44 <Cale> That action can itself be described perhaps using another do-block
11:59:45 <tac> refried_: When you have a <- to the left of a do block, you "extract" the value produced by the *last* command in the block
12:00:12 <Cale> right, the result of a whole do-block is the result of the last action in it, always
12:00:35 <refried_> so the last action doesn't have to be return, then ?   just it usually will be, to make the types work out ?
12:00:44 <Cale> well, yeah
12:00:52 <Cale> What return does is to give you an action which does nothing, except return the given value
12:01:18 <Cale> If you put a return in the middle of a do-block, you'll notice that it doesn't have the usual control effect that return in most imperative languages has.
12:01:34 <refried_> oh, hm
12:01:36 <Cale> return v is *just* an action which returns v and does nothing else
12:02:00 <Cale> and so gluing it into the middle of a do-block (and most likely ignoring its result) will accomplish nothing
12:02:06 <refried_> right
12:02:11 <refried_> ok.
12:02:23 <Cale> i.e.  do v <- return w; f v  is the same as  f w
12:02:32 <tac> refried_: It might help to think of it like this. If you execute "getLine" and it gets the string "This is my line", it works the same as if you had written: return "This is my line"
12:02:38 <Cale> also,  do v <- x; return v  is the same as  x
12:03:00 <centrinia> :t \x -> do v <- x; return v
12:03:01 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> m b
12:07:34 <starurchin> "cabal install gtk2hs-buildtools" fails - c2hs/toplevel/C2HSConfig.hs:110:1: Unacceptable result type in foreign declaration: CInt When checking declaration: foreign import ccall safe "static bitfield_padding" bitfield_padding :: CInt - now what?
12:08:29 <geekosaur> this is 1.6 being pedantic about the standard, IIRC.  you need to edit C2HSConfig.hs to import something (Foreign.C.Types, I think?)
12:09:33 <starurchin> Version 1.6 of what?  Is that a typo for ghc 7.6 ?
12:10:14 <beaky> hello
12:10:54 <geekosaur> sorry, yes
12:11:01 <fmap> I'd just download and apply patch for c2hs from gentoo-haskell
12:11:04 <hiptobecubic> hi beaky
12:11:05 <geekosaur> switched gears too quickly, 1.6 is something else, I meant 7.6.1
12:11:49 <hiptobecubic> it's possible to work directly with CInts in haskell right?
12:12:15 <fmap> (gtk2hs-buildtools won't build on 7.6.1 too)
12:12:35 <hiptobecubic> So why isn't Int ~ CInt?
12:12:54 <rwbarton> well for one thing on my system Int is 64 bits and CInt is 32 bits
12:13:08 <starurchin> How do I get at C2HSConfig.hs to patch it?  cabal-install just downloads everything and builds it. How do I intervene?
12:13:24 <geekosaur> cabal unpack <foo>
12:13:25 <hiptobecubic> Int32 and Int64 then
12:13:37 <geekosaur> "cd" into the unpacked directory, edit the file, "cabal install" (without a package name)
12:13:57 <fmap> hiptobecubic: because CInt isn't Int32?
12:14:14 <hiptobecubic> fmap, but why not i mean
12:14:29 <geekosaur> hiptobecubic, how do you determine which one is correct for your platform?
12:14:31 <rwbarton> well maybe on some other system C ints are 64 bits
12:14:50 <fmap> hiptobecubic: because C standard doesn't say int is 32 bit
12:14:50 <hiptobecubic> that was my next question
12:14:56 <rwbarton> CInt is by definition whatever 'int' means in C
12:14:57 <hiptobecubic> ok then all questions answered
12:15:02 <rwbarton> Int is whatever ghc finds convenient
12:15:09 <starurchin> OK, "cabal unpack" worked - where do I get the patch?
12:15:09 <beaky> how do you test a [Char] for palindromes?
12:15:23 <Cale> beaky: xs == reverse xs ?
12:15:26 <hiptobecubic> well almost, when is CInt defined then? when you build Foreign.C ?
12:15:42 <beaky> ah its that simple?
12:15:49 <Cale> Well, that works
12:15:56 <hiptobecubic> beaky, isn't it? What's the definition of a palindrome
12:16:18 <Cale> You can make it more complicated if you want to skip half of the test in the case that it really is a palindrome.
12:16:19 <beaky> a palindrome is something that reads the same in reverse
12:16:44 <nand`> xs == reverse xs is honestly what I would do
12:16:46 <hiptobecubic> beaky, so you just encode that into haskell directly.
12:17:09 <jerojasro> is there a way of getting a function given its name as a string?
12:17:12 * typoclass refrains from bringing up <*>
12:17:20 <hiptobecubic> nand`, yes. I can't see this being your perfomance bottleneck unless the whole application centers around testing for palindromes.
12:17:31 <jerojasro> e.g., "+" -> +
12:17:51 <typoclass> jerojasro: not really, not without major trickery. what do you need it for? probably there's other (better) ways
12:18:23 <jerojasro> typoclass: I wanted to convert '+', '-', ... to their corresponding functions
12:18:51 <starurchin> C2HSConfig.hs already imports Foreign (Ptr, FunPtr) , Foreign  (Storable(sizeOf, alignment), toBool) and Foreign.C (CInt)
12:19:02 <typoclass> jerojasro: if it's just a few of them, you could always have a map where the keys are those strings ("+" ...) and the values are the functions ...
12:19:15 <jerojasro> typoclass: what I did was a list, and lookup
12:19:22 <jerojasro> list of tuples ...
12:19:26 <typoclass> jerojasro: yup, that's what i mean :)
12:19:34 <nand`> hiptobecubic: I'm not sure how I would attempt to make it more efficient either waqy
12:19:50 <nand`> maybe you could stop at the center
12:20:22 <nand`> jerojasro: a Map is more efficient for lookups
12:20:34 <jerojasro> typoclass: and those functions *have* to have the same type signature ... heh
12:20:56 <typoclass> jerojasro: yes, and they have to have, you couldn't cram them in the same list otherwise :)
12:20:59 <nand`> yeah; but in the case of dyads over ‚Ñù that should be a given
12:21:03 <jerojasro> nand`: yup, you're right, but this is just a silly exercise, and the list has 4 items ;)
12:21:06 <nand`> (is that a valid term here? dyad? for dyadic function?)
12:21:49 <typoclass> nand`: i suspect if he had so many elements that Map vs. list plays a role, he'd have long since gotten tired of maintaining that list anyway
12:21:51 <nand`> jerojasro: I would still use a Map for a silly exercise, not only because it has more appropriate semantics, but also because the type looks less intimidating at an immediate first glance
12:21:55 <nand`> [(a,b)] vs Map a b
12:21:55 <jerojasro> "Dyadic is to binary as Aphrodite is to Venus." ... -_-
12:22:28 <fmap> starurchin: yeah, the problem is ghc 7.6.1 ignores conditional compilation IIRC
12:23:02 <hiptobecubic> nand`, you could stop at the center yes.
12:23:04 <jerojasro> typoclass: I take it that's the reason why haskell can't serialize functions ...
12:23:17 <fmap> starurchin: see https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/c2hs/files/c2hs-0.16.3-ghc-7.6.patch
12:24:17 <nand`> hiptobecubic: the trivial way of doing that would be via length; in which case you'd still need a separate traversal to calculate that. I guess you could calculate the length in the same operation and lazily pass it backwards in time to the calculations
12:24:45 <fmap> oh, no, conditional compilation is unrelated here
12:24:47 <fmap> anyway
12:24:47 <nand`> so it only seems sensible if comparison is costly
12:24:48 <typoclass> jerojasro: i think it's more that function are first class, they're ordinary values, so you can stick them in lists, Maps, or wherever. (a language like java would have trouble with this.) serialization is about turning a function into a String, for writing to a file or similar
12:25:06 <starurchin> fmap - thanks!  Will try the patch later and check back in.  Need to eat first!
12:27:20 <nand`> some functions can be serialized
12:30:48 <dented42> an odd question, what would need to be true in order to be able to type check a compiled program/library?
12:32:19 <typoclass> dented42: to type-check, you'd need the source code i guess? :-/ types are erased at compile time; at runtime you can't get at them
12:32:59 <rwbarton> question needs more details of some kind
12:33:37 <clahey> typoclass, It has to keep the types of libraries, no?
12:33:38 <typoclass> dented42: (when i say "types are erased", that refers to haskell, meaning what you're asking for is not possible with haskell. other languages might do it differently.)
12:34:06 <rwbarton> or depending on how you look at it, it is trivial with Haskell--if you have a compiled program then it has already type checked
12:34:44 <dented42> typoclass: I know it's not possible. I'm asking what would need to be different to make it possible. It's a thought experiment.
12:34:52 <nand`> depends on the language it's compiled to
12:35:31 <nand`> for example, I can write a compiler from Haskell to Core; then type-check that
12:35:46 <Cale> In the case of GHC, there is a typed intermediate language called Core...
12:35:47 <Cale> right
12:35:47 <dented42> I'm imagining a hypothetical operating system which doesn't load/run a program until it's verified that the program is safe.
12:36:54 <Cale> dented42: So what you may want to do is to distribute code in some appropriate typed lambda calculus, and compile that when loading the program.
12:37:00 <nand`> dented42: like x86?
12:37:07 <nand`> trivially, all x86 programs are type safe
12:37:13 <rwbarton> what does "safe" mean to you
12:37:49 <nand`> they're also safe in a material sense since they won't make the processor explode or anything, other than normal usage deterioration
12:37:57 <typoclass> dented42: you could muck around with .hi files somehow ...
12:37:57 <centrinia> All typeless languages are type safe. :)
12:37:57 <dented42> right
12:38:23 <dented42> true
12:38:24 <beaky> safety in Haskell means that a function with an Int -> Int type signature has no chance of launching missiles
12:38:34 <typoclass> centrinia: oh sure :) type safe in the sense that they are guaranteed not to blow up at compile time. not so many guarantees about runtime
12:38:34 <dented42> beaky: that's what I mean
12:38:57 <nand`> for me, safety also means that it can't break the type system
12:39:14 <beaky> unsafePerformIO ftw
12:39:17 <nand`> which may be entirely distinct from unsafePerformIO
12:39:24 <beaky> :(
12:40:31 <rwbarton> if your OS wants to stop a userspace program from launching missiles then it can just return EPERM for the launch_missiles system call
12:40:46 <dented42> Cale's idea seems like an interesting one
12:41:07 <rwbarton> assuming you have a typical privilege system
12:41:28 <nand`> but here's my thinking
12:42:40 <efie> I have something of type HashMap Text (HashMap Text Float) and I want to write it to a file. By now I use the toList-function to turn the map into a list, and thereby use fshow to show the Float values. Then I 'show' the whole list to produce a String and use writeFile to write the file. Turning the map into a String takes 80% of the time and writing into the file takes 12%, and all in all this takes 80% of allocated memory... how can this bett
12:42:50 <dented42> rwbarton: well I was thinking that if the operating system could verify that a program is safe, then one wouldn't need to have a typical privilege system.
12:43:08 <rwbarton> ok, good.
12:43:14 <nand`> instead of checking for type safety (which may or may not actually tell you anything about what the program's doing); surely you want to enforce other kinds of safety instead - for example won't exceed its memory bounds, or touch other programs; then to the OS, the program can do what it wants
12:43:22 <rwbarton> I think there are some research systems like this
12:43:25 <nand`> it can unsafeCoerce and crash as far as the OS is concerned
12:43:48 <dented42> nand`: not if those functions weren't allowed
12:43:52 <nand`> and how do you check that a program is safe?
12:44:01 <typoclass> efie: hello, you got cut off at "how can this bett"
12:44:05 <nand`> for example, I want to write a program that access files in my home directory; surely it must be able to access those somehow
12:44:10 <hiptobecubic> lets not forget Halt-and-Catch-Fire
12:44:36 <efie> typoclass: oh, thanks for the hint: "... how can this be better done?"
12:44:36 <nand`> dented42: yes, which is why enforcing them statically via a well-designed language is a good approach, imo
12:44:56 <nand`> permissions systems are there to determine what is safe; I can write a type-safe program to launch missiles
12:45:25 <nand`> the concepts are orthogonal, if you ask me
12:46:03 <typoclass> efie: you're welcome. about the content of your question, i have no clue, sorry :-/
12:47:11 <nand`> dented42: there's also the theoretical problem of software upgrades
12:47:14 <nand`> if an OS is capable of updating itself via user-space programs (a web browser, for example) + some mechanism; it can potentially be subverted
12:47:40 <dented42> nand: well I was thinking that, using haskell as an example, instead of an IO monad like we currently have, there would be a FileSystem monad, a Network monad, and so on. it wouldn't forbid 'unsafe' programs per se, it would just make sure that the program does what it says
12:48:09 <simpson> dented42: What about the general paradigm of file descriptors?
12:48:10 <jfischoff> dented42: you might want to read Data Types a la Carte
12:49:35 <dented42> simpson: I don't know, I haven't thought this all the way through, perhaps the network monad and filesystem monad would be used to produce file descriptors that would be written and read from in a file descriptor monad, or maybe something else would be used instead of file descriptors.
12:49:48 <dented42> jfischoff: I've not heard of it, who's the author?
12:50:07 <simpson> dented42: Have you read the thesis behind E yet? It might be interesting.
12:50:16 <dented42> no I haven't
12:50:23 <rwbarton> dented42: I think the general concept you are interested in is called "proof-carrying code"
12:50:30 <simpson> dented42: Also the theory behind Android's treatment of interfaces as contracts is pretty nifty.
12:50:35 <jfischoff> dented42: http://www.cs.tufts.edu/~nr/cs257/archive/wouter-swierstra/DataTypesALaCarte.pdf
12:50:41 <dented42> rwbarton: that sounds about right
12:50:59 <jfischoff> ah I thought you were interested in more precise effect systems
12:51:20 <dented42> jfischoff: what is the distinction?
12:51:44 <jfischoff> proof carry code is a much more powerful idea
12:52:27 <jfischoff> more precise effect systems usually means you build up a monad for effects by composing smaller free monads
12:53:02 <dented42> but more precise effect systems would make verification much simpler, wouldn't it?
12:53:09 <jfischoff> sure
12:53:44 <nand`> surely any language augmented with assumed true proofs can be transformed into an equivalent language which by design enforces those proofs statically; but does anybody know how practical this is? say I have some deterministic, halting parser for the former language; can I create a deterministic, halting parser for the ‚Äònew language‚Äô? I guess it would hinge on the ability to prove the properties
12:53:47 <nand`> expressable in the proofs system algorithmically
12:54:02 <nand`> hmm, I can construct a counter-example: a language together with halting proofs
13:00:11 <dented42> hm
13:06:02 <beaky> http://www.txt.io/t-2kv5h
13:06:47 <nand`> old
13:07:03 <Ralith> beaky: you linked that yesterday.
13:08:43 <simpson> beaky: Cool story.
13:09:47 <hpaste> scooty-puff pasted ‚Äúmfix data structure - at all useful?‚Äù at http://hpaste.org/76954
13:10:16 <pauser> hi, is there any function that finds the same elements of 2 lists ?
13:10:40 <dented42> pauser: Data.List
13:10:54 <dented42> I think there's an intersect function in there
13:12:34 <scooty-puff> pauser: Data.Set and Data.HashSet may be useful, if you are willing to change the data structure you are using
13:13:43 <pauser> the is no intersect in my ghci, just in google
13:14:18 <dented42> pauser: did you import Data.List ?
13:14:48 <parcs`> what terrible, terrible typesetting
13:15:37 <scooty-puff> pauser: type "import Data.List" into ghci
13:16:25 <dented42> it's a habit. if the last word of a sentence is a quotation of some kind, then I put a space in between the word and the ending punctuation to avoid ambiguity. it started when a friend kept misinterpreting an exclamation mark for a factorial :-/
13:16:25 <pauser> ist works , thank you people very much
13:18:56 <kini> dented42: that's a good habit
13:19:26 <kini> especially for things like URLs which IRC clients tend to cause to slurp up ending punctuation
13:19:48 <typoclass> dented42: i suspect parcs` was referring to the www.txt.io link from above
13:20:12 <dented42> oh ewww
13:20:22 <dented42> yes, that's rather‚Ä¶ distasteful
13:23:57 <Palmik> beaky, wow, quite a rude and pointless article. Surely I could turn off my brain and try to use anything and then complain that it does not work as "expected", but what's the point?
13:25:34 <dented42> to be fair, cabal can be extremely frustrating
13:26:10 <beaky> yeah the article is a bit on the FUD side
13:27:45 <Palmik> dented42, yes, but it seems that the author ignored all tutorials and documentation there is.
13:27:59 <koala_man> it should be intuitive!
13:28:17 <Palmik> That's almost as if I have downloaded random C++ library and complained that g++ *.cpp does not work.
13:28:42 <typoclass> Palmik: he did clear out ~/.ghc and ~/.cabal, which is fairly standard advice ...
13:28:44 <Palmik> Or executable, rather.
13:29:03 <Palmik> typoclass, yes, I do that as well from time to time.
13:29:43 <dented42> Palmik: yes, but that doesn't change the fact that cabal is rather cavalier about messing up dependencies
13:29:47 <Palmik> But I mostly use self contained cabal-dev package databases.
13:30:09 <typoclass> how did he come up with "cd yesod; cabal-dev install"? is that advised in some yesod tutorial? (i have no clue about yesod)
13:30:29 <byorgey> dented42: it used to be.  it is MUCH better now.
13:30:51 <typoclass> byorgey: you mean 1.16?
13:30:53 <sm> yes, current cabal does not mess up dependencies unless you tell it to
13:30:55 <byorgey> yes
13:31:08 <sm> nobody should use an older cabal-install now
13:33:13 <typoclass> i suspect the guy's first error was that "cabal install cabal-install" caused it to be put in some place that he didn't have in PATH
13:33:30 * sm reads the article.. yes that is a cool story :)
13:33:47 <clahey> What is cabal-install?
13:33:57 <rwbarton> the "cabal" executable
13:34:35 <clahey> Is there any reason not to just use the installed copy?
13:34:43 <clahey> The distro copy, that is?
13:35:11 <dented42> clahey: because it can get out of date?
13:35:26 <dented42> bug fixes, new features, and so on
13:35:29 <otters> can you make cabal haddock print undocumented declarations
13:35:47 <sm> yesod might just be the haskell package installed most often by non-experts.. and it has possibly the highest number of dependencies on hackage (back-of-napkin calculations, market surveys show, ymmv)
13:36:07 <stepkut> :)
13:36:56 <stepkut> I plan to fix that by making clckwrks the package most installed by non-experts
13:37:02 <sm> go stepkut
13:37:10 <stepkut> integrating the new plugins stuff now ;)
13:37:13 <scooty-puff> otters: haddock will show a percent that is documented, but that is not exactly what you want
13:37:20 <otters> that is not exactly what I want
13:37:31 <typoclass> i think the article is a bit on the profanity side, but really, it's an important problem. he does have a point
13:37:37 <sm> agreed
13:37:41 <uniquenick> I am running a function that returns IO Int, but I don't care about the Int, I just want it to return IO True, what is the operator I want?
13:38:12 <sm> stepkut: I find myself wanting a user activity feed on hub to see what you're up to
13:38:13 <nand`> I maintain my counterposition of ‚Äúdon't use cabal-install‚Äù
13:38:25 <nand`> I installed and subsequently uninstalled yesod just fine
13:38:27 <scooty-puff> uniquenick: m >> return True
13:38:28 <sm> nand`, that's crazy talk
13:38:38 <scooty-puff> uniquenick: or liftM (const True) m
13:38:41 <monochrom> what article? the one that says "apparently you people haven't heard of semantic versioning"?
13:38:44 <scooty-puff> where "m" is the action you have
13:38:46 <nand`> monochrom: yeah
13:38:49 <nand`> I think
13:39:00 <nand`> I only saw ‚Äúi think the article is a bit on the profanity side‚Äù and assumed so
13:39:03 <sm> the txt.io rant linked above
13:39:04 <typoclass> nand`: how do you mean? you used your distro package manager?
13:39:07 <monochrom> that writer knows nothing about code optimizations breaking semantic versioning
13:39:09 <nand`> typoclass: yeah
13:39:20 <stepkut> sm: well, you better add one then :p
13:39:33 <sm> beaky: did you write it ?
13:39:43 <stepkut> sm: I will, of course, make blog posts when I have things working enough to write about them
13:39:44 <nand`> http://bpaste.net/show/54256/  and  http://bpaste.net/show/54258/
13:39:50 <monochrom> apparently, that writer has not heard of cross-package code inlining
13:40:04 <beaky> sm: no I found it on reddit
13:40:54 <monochrom> the only way to solve GHC's "have to rebuild things so often" is to defeat all GHC optimizations
13:41:14 <beaky> how do I add cabal to my path?
13:41:32 <beaky> this whole time I've been doing "~/.cabal/bin/hlint *.hs"
13:41:39 <monochrom> other than that, the other complaint, about some packages being picky about versions, is just specific to certain packages
13:41:45 <nand`> export PATH=$PATH:~/.cabal/bin I guess
13:42:14 <sm> TL;DR: after he figured out installing yesod requires a clean package sandbox, a huge number of packages installed perfectly, if not fast enough for him, but yesod devel rebuilt stuff and then failed due to cabal-devel weirdness
13:42:25 <typoclass> monochrom: it is unlikely that new kinds of optimizations were introduced into ghc in the five minutes between his "cabal install" command and his "cabal-dev install" command
13:42:54 <fruitFly> why do you guys use haskell?
13:43:10 <nand`> fruitFly: because I like it more than other languages
13:43:11 <sm> fruitFly: I got tired of fix bugs over and over
13:43:14 <sm> fixing
13:43:14 <stepkut> fruitFly: because agda is not ready for prime time yet..
13:43:28 <nand`> but if I were to summarize;
13:43:45 <monochrom> typoclass: sorry, I don't understand your point
13:44:16 <nand`> 1. great community, great wealth of packages; 2. reasonable type system; 3. purity and laziness; 4. somewhat more human-friendly syntax
13:44:24 <fruitFly> stepkut: everyone is making me feel like agda is the best ever, what's so great about it? what can it do? web apps? why is t not ready for prime time?
13:44:45 <hpc> fruitFly: it has no libraries, really
13:44:51 <monochrom> I use haskell because #haskell tells me to use haskell
13:44:56 <hpc> it has loads of theorems, but nothing you would actually program with
13:44:59 <sm> fruitFly: agda's for proving correctness, not for building applications
13:45:01 <typoclass> monochrom: the article complained that he needed to wait so much for things to compile; you said that ghc needs to recompile often to enable new optimizations
13:45:01 <nand`> fruitFly: it has dependent types
13:45:17 <djahandarie> Agda can't do anything for a normal programmer right now. Why would anyone even mention it.
13:45:34 <fruitFly> hpc: I'm highly ignorant
13:45:37 <monochrom> oh, the article has many complaints, I'm addressing the "semantic versioning" part
13:45:38 <johnw> how does Agda handle IO?
13:45:54 <hpaste> uniquenick pasted ‚Äúhow do I shot monad?‚Äù at http://hpaste.org/76955
13:45:54 <nand`> I think Haskell is a bit of a double-edged sword; it trades rigor and idealism for real-world relevance
13:46:01 <copumpkin> johnw: not beautifully :)
13:46:01 <nand`> for example, unsafePerformIO
13:46:08 <monochrom> and you misread what I said
13:46:10 <djahandarie> johnw, you can definitely get questions like that better answered in #agda btw
13:46:13 <copumpkin> johnw: by FFI-ing to haskell
13:46:18 <hpc> johnw: it "foreign imports" haskell IO actions
13:46:21 <johnw> yeah, but I thought it was appropriate at this juncture
13:46:28 <hpc> and lifts those actions into its own IO type
13:46:38 <hpc> it's very ugly
13:46:50 <uniquenick> scooty-puff: that paste is my code and error, I don't know what it is telling me I did wrong
13:46:53 <copumpkin> mostly because of the interleaved coinduction
13:46:56 <copumpkin> to allow infinite IO actions
13:47:59 <scooty-puff> uniquenick: the type should be delete :: Int64 -> IO Bool, assuming HasPostgres IO, or changed in other ways to use MonadIO instead of IO direclty
13:48:20 <mrBG> what is ascii of G ?
13:48:27 <scooty-puff> uniquenick: o, ic
13:48:33 <sm> beaky: is that thing posted at http://www.reddit.com/r/haskell ?
13:48:35 <scooty-puff> ok, the $ has lower precendence than >>
13:48:46 <copumpkin> > ord 'G'
13:48:47 <lambdabot>   71
13:48:50 <copumpkin> mrBG: does that help?
13:48:59 <stepkut> agda can do IO and be used a fair bit like Haskell.. here is an irc bot I wrote, http://hub.darcs.net/stepcut/agdabot
13:49:07 <beaky> sm: I found it on http://reddit.com/r/programming
13:49:17 <sm> aha
13:49:28 <hpaste> scooty-puff annotated ‚Äúhow do I shot monad?‚Äù with ‚Äúhow do I shot monad? (annotation)‚Äù at http://hpaste.org/76955#a76956
13:49:33 <scooty-puff> uniquenick: try that
13:49:33 <stepkut> check out IRC.agda nad Main.agda
13:49:46 <copumpkin> stepkut: you turned off the termination checker there, though, didn't you
13:49:55 <scooty-puff> i assume HasPostgres implies MonadIO
13:49:58 <stepkut> copumpkin: yeah, haven't gotten around to fixing that yet
13:49:59 <copumpkin> whoa, that was augustss on IRC
13:50:18 <stepkut> copumpkin: patches accepted ;)
13:50:37 <copumpkin> the termination is what makes a lot of it uglier :)
13:50:53 <eikke> anyone ever read the "Power of Pi" paper about dependent types?
13:50:56 <copumpkin> and I don't know how to make the productivity annotations less ugly
13:51:05 <stepkut> copumpkin: yeah, though I think it shouldn't be to hard in that case, the troublesome spot is the messageLoop
13:51:16 <copumpkin> eikke: many have, but you'll find more of them concentrated in #agda or #idris
13:51:17 <uniquenick> that sounds reasonable.  I don't know anything, but any time I need to pass a HasPostgres into something that wants an IO, I can just liftIO it and it works
13:51:42 <eikke> copumpkin: sure, but question is not about the paper itself :)
13:51:56 <nand`> copumpkin: idris?
13:52:00 <nand`> as in, the operating system?
13:52:07 <copumpkin> no, the language
13:52:18 <nand`> not listed on wikipedia :(
13:52:29 <eikke> while reading about the Data.Record thing which was on Reddit recently, using type-level literals, I was wondering whether the database interface presented in the paper can't be implemented using GHC nowadays
14:16:48 <Saizan> eikke: yeah, maybe we reached the point where it'd be nice enough
14:19:28 <eikke> Saizan: I guess I should try it out :-D
14:23:32 <Rainey> Hi Hi Hi
14:25:48 <NougatRillettes> Hi guys
14:26:00 <NougatRillettes> I'm having some issue with a code I can't understand
14:26:06 <NougatRillettes> (http://paste.awesom.eu/NougatRillettes/oKQ&ln)
14:26:06 <beaky> should I use {\sffamily foo} or \textsf{foo}?
14:26:44 <NougatRillettes> as said in comment, when iter and main are commented everything works fine
14:27:00 <NougatRillettes> and the type of save is the one written is the code
14:27:53 <NougatRillettes> but for some resaon, when I uncomment them everything starts to fuck up
14:28:34 <NougatRillettes> ie GHC suddenly wants xmin, ymin, a and b to be Int
14:28:53 <rwbarton> it's because of the monomorphism restriction
14:29:03 <hiptobecubic> i hate that thing
14:29:06 <rwbarton> well
14:29:09 <rwbarton> not 100% sure
14:29:30 <fmap> errors aren't from pasted code?
14:29:49 <nand`> it can't be type defaulting, since Int is not a defaultable type; so it has to be the monomorphism restriction or rank-n types, no? (I didn't look at the code)
14:30:21 <rwbarton> the type errors could just be in the commented code
14:30:57 <rwbarton> anyways I suggest writing more type declarations for top-level bindings
14:31:25 <NougatRillettes> fmap: oops, my bad, I had hard-tagged the type to see if it changes something
14:31:26 <rwbarton> like xmin, xmax, ...
14:31:39 <NougatRillettes> but the erro is the same with or without
14:32:02 <NougatRillettes> rwbarton: you mean like xmin = -10 :: Double ?
14:32:21 <rwbarton> well I was thinking more like xmin :: Double; xmin = -10
14:32:37 <NougatRillettes> well if I launch the code in GHCi (buggy part commented) all those values have the right type (aka Double)
14:32:40 <rwbarton> you can combine them too
14:32:54 <rwbarton> the thing is that in main probably they are used as though they are Ints or something
14:32:59 <rwbarton> then it doesn't know which part of your code is wrong
14:33:19 <NougatRillettes> yep, you're right
14:33:21 <rwbarton> right, see main definitely uses xres,yres as Ints
14:33:28 <Eduard_Munteanu> Yeah, sounds like MR is part of the problem.
14:33:28 <NougatRillettes> i've found it thank you !
14:33:30 <rwbarton> but elsewhere you treat them as Double
14:33:37 <NougatRillettes> thc very much
14:37:47 <gwern> @quote
14:37:47 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
14:38:43 <rwbarton> Wise words.
14:50:26 <MrFenix> pointfree (\ f x -> f <$> x <*> x)
14:50:27 <clahey> mcstar: Around?
14:50:48 <clahey> I guess he's not logged in.
14:51:05 <clahey> @pl \f x -> f <$> x <*> x)
14:51:05 <lambdabot> (line 1, column 22):
14:51:05 <lambdabot> unexpected ")"
14:51:06 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or end of input
14:51:08 <clahey> @pl \f x -> f <$> x <*> x
14:51:08 <lambdabot> (. join (<*>)) . (<$>)
14:51:41 <hiptobecubic> yuck
14:52:04 <MrFenix> yuck indeed ;)
14:52:10 <c_wraith> um.
14:52:31 <fmap> @pl \f x -> liftM2 f x x
14:52:31 <lambdabot> join . liftM2
14:52:39 <c_wraith> cabal sdist is simultaneously telling me it doesn't know what this 'source-repository' section is, and that I should consider adding a 'source-repository' section
14:52:41 <c_wraith> what?
14:53:46 <c_wraith> Hmm, is source-repository supposed to be nested inside something?
14:53:58 * hackagebot lens 3.0.6 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.0.6 (EdwardKmett)
14:55:07 <fmap> c_wraith: no
14:55:41 <hpaste> ‚ÄúJonathan Fischoff‚Äù pasted ‚ÄúDataKind question‚Äù at http://hpaste.org/76960
14:56:09 <c_wraith> hmm.  do I need to specify a higher cabal version?
14:56:19 <jfischoff> ^ I would like t constrain a polymorphic type in a GADT to a certain kind, but I'm running into problems
14:56:54 <c_wraith> oh!  man, that's a unique syntax
14:56:58 <c_wraith> I see what I'm doing wrong
14:57:50 <jfischoff> any ideas on how I an constrain the 'a' in the Shader definition to be of kind ShaderType ? http://hpaste.org/76960
14:58:58 * hackagebot scion-browser 0.2.12 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.12 (JeanPhilippeMoresmau)
14:59:42 <c_wraith> By the way, unique syntaxes are bad. :(
15:01:42 <parcs`> jfischoff: remove the *ShaderType fields
15:02:57 <jfischoff> parks`: thanks
15:03:13 <jfischoff> parcs`: thanks I mean
15:03:16 <parcs`> the user can specify the shader type with a type annotation
15:03:55 <jfischoff> yeah your right its not a value thing
15:03:59 * hackagebot lrucache 1.1.1.1 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-1.1.1.1 (CarlHowells)
15:05:36 <jfischoff> parcs`: you might find what I working on interesting. Making OpenGL programming more type safe basically
15:06:02 <hpaste> ‚ÄúJonathan Fischoff‚Äù annotated ‚ÄúDataKind question‚Äù with ‚ÄúDataKind question (annotation)‚Äù at http://hpaste.org/76960#a76961
15:16:07 <rwbarton> how do I figure out what to put in the "cabal-version" field of a cabal file?
15:17:13 <sm> rwbarton: look at some cabals on hackage ?
15:17:31 <sm> nowadays I can't imagine anyone using less than 1.8
15:18:08 <rwbarton> this version of cabal's "cabal init" suggested 1.2
15:18:11 <rwbarton> I find that dubious
15:18:59 * hackagebot SegmentTree 0.3 - Data structure for querying the set (or count) of intervals covering given point  http://hackage.haskell.org/package/SegmentTree-0.3 (DmitryAstapov)
15:22:19 <Saizan> rwbarton: i think check should tell you if you're using featuers of later cabal versions
15:22:33 <rwbarton> oh neat
15:22:35 <rwbarton> let me try that
15:28:37 <pauser> how can i access any element of a tuple, i know fst and snd but i need to access the n'th element how can i do that ?
15:29:05 <rwbarton> pattern matching
15:29:07 <Luig1> Hello
15:29:16 <Luig1> I'm doing Try Haskell, just so you know
15:29:22 <Luig1> I'll be here for a few minutes
15:29:40 <c_wraith> Luig1: excellent. If you have any questions, feel free to ask
15:30:23 <Luig1> Okay. I did the first few chapters of HtDP with Racket about a year ago
15:30:35 <Luig1> I can't remember most of it but I'd be interested to know how this will be similar?
15:31:55 <sm> Luig1: I've forgotten that too but I think.. not too similar
15:32:07 <byorgey> Luig1: it's similar-ish, with emphases on recursion and algebraic data types
15:32:14 <byorgey> Luig1: the biggest difference is types
15:32:23 <Luig1> Scheme also has an emphasis on recursion
15:32:29 <Luig1> Tail calls, yeah?
15:32:36 <Luig1> So this will have that too, okay
15:32:49 <Luig1> Data types, never used those
15:33:05 <byorgey> Luig1: Haskell is a strongly typed language, whereas scheme/racket is untyped
15:33:12 <byorgey> unless you use typed racket, but HtDP doesn't
15:33:26 <Luig1> Yeah, I saw it in DrRacket but I never used it
15:33:30 <byorgey> Luig1: if you did HtDP you *have* used algebraic data types... they just weren't called that =)
15:33:44 <byorgey> like when you define a struct or whatever it's called in racket
15:34:04 <byorgey> "a foozle is either a number or a pair of colors..."
15:34:08 <Luig1> I can't remember :\
15:34:16 <Luig1> But I've heard great things about Haskell
15:34:17 <byorgey> ok, well, maybe it will come back to you =)
15:34:21 <Luig1> I'm happy this is here
15:34:26 <Luig1> This being TryHaskell
15:34:44 <byorgey> yeah, TryHaskell is great =)
15:35:01 <byorgey> though it doesn't go all that deep.  But if you like it then you can move on to something like Learn You a Haskell
15:35:04 <byorgey> @where lyah
15:35:04 <lambdabot> http://www.learnyouahaskell.com/
15:35:20 <Luig1> Great, thanks
15:35:42 <ivanm> I wonder whether the "write a scheme in haskell" tutorial would help Luig1 with the transition or just confuse him :p
15:36:36 <Luig1> Well I'm not waist-deep into Scheme
15:36:36 <byorgey> probably just confuse
15:36:43 <Luig1> I remember it about as much as I remember French
15:36:54 <Luig1> Which I haven't touched in years :'(
15:36:54 <byorgey> *implementing* scheme is very different than *learning* it.
15:38:01 <c_wraith> can I implement scheme in scheme as "eval"?
15:38:35 <byorgey> yes
15:38:45 <byorgey> that's, like, the whole point of scheme ;-)
15:38:54 <c_wraith> ok.  Worst scheme implementation ever, coming up!
15:39:09 <cmccann> hey byorgey, been enjoying the weather today?
15:40:06 <clahey> I went out earlier.
15:40:15 <clahey> byorgey, Where are you?
15:41:13 <byorgey> cmccann: does sitting inside drinking hot chocolate count as enjoying the weather?
15:41:34 <cmccann> byorgey, for the weather I assume you've been getting
15:41:35 <cmccann> yes
15:41:45 <byorgey> clahey: Philadelphia, i.e. in a few hours I will be directly in the middle of Hurricane Sandy
15:42:06 <byorgey> yes, so far lots of rain and wind
15:42:22 <cmccann> at least hurricanes fizzle pretty fast once they hit land
15:42:34 <cmccann> 40 mph winds are better than 70 or 80 or whatever
15:42:40 <byorgey> yeah, and Philly is far enough from the coast that it shouldn't be too bad
15:42:51 <byorgey> we're supposed to possibly get 60 mph gusts
15:43:00 <byorgey> but not sustained
15:43:06 <clahey> I'm in Somerville right now, which is pretty windy.
15:43:09 <clahey> About the same as that.
15:43:11 <cmccann> yeah that's pretty much what I'm gonna see as well
15:43:20 <cmccann> like an hour or two after you I suppose?
15:43:26 <Luig1> Oh, looks like I already have to go
15:43:28 <byorgey> cmccann: oh, where are you?
15:43:33 <Luig1> I'll definitely be back tomorrow
15:43:34 <cmccann> pittsburgh
15:43:42 <byorgey> Luig1: ok, see you tomorrow!
15:44:04 <Luig1> Bye :)
15:44:21 <byorgey> cmccann: ah, yeah, I guess pittsburgh is supposed to get sort of sideswiped as it turns north
15:44:58 <cmccann> a few inches of rain, 30 mph winds gusting to 50+ mph, stuff like that
15:45:01 <cmccann> could've been worse
15:45:07 <byorgey> yep
15:45:27 <byorgey> anyway, so far everything seems OK, we'll see if the power stays on
15:45:35 <byorgey> if I log out of IRC you'll know why =)
15:45:53 <cmccann> yeah :D
15:46:04 <cmccann> at least it'll mostly be passing through overnight, moreso for me
15:51:20 <beaky> So if I separate my program into separate modules, GHC will not only optimize each one individually, but do some kind of link-time optimization or whole-program optimization?
15:54:18 <monochrom> not link-time. compile-time inlining to see more opportunities. this is somewhat whole-program but not fully
15:59:49 <ivanm> byorgey: with boxes, now I have to work out what looks better, center1 or center2 alignment... thank you _so much_ for giving us options! :p
16:00:02 <byorgey> hehe
16:00:45 <byorgey> beaky: when compiling each module it may try to inline stuff from previously compiled modules.
16:01:47 <ivanm> oh, I just noticed that someone sent Eelis a pull request for boxes 10 months ago with no response, so maybe I won't get a response either :s
16:03:03 <nohonor> what do the double bars mean in the type annotations in the "Banans and Lenses" paper
16:03:21 <nohonor> g :: B -> A || B
16:03:31 <hpaste> int80_h pasted ‚ÄúAdvice on how to proceed with cabal installation‚Äù at http://hpaste.org/76963
16:03:53 <mekeor> nohonor: i'd GUESS it's like "Either A B"... does that seem legit?
16:03:56 <byorgey> nohonor: looks like a coproduct, i.e. sum, i.e. Either
16:04:13 <hpaste> ivanm pasted ‚ÄúComparing diagrams‚Äù at http://hpaste.org/76964
16:04:26 <mekeor> ha! i was right! =)
16:04:35 <nohonor> mekeor, byorgey, i'm not sure
16:04:39 <ivanm> ^^ can people tell me whether they prefer the left-biased or right-biased diagrams?
16:04:54 <kirindave> Hey folks. I need to write a program that does a bunch of updates to records inside lists.
16:05:08 <kirindave> So i need to select a single record from a list and update it.
16:05:14 <nohonor> e.g. there's an operator :: A || B -> B and it looks like "A to B to B"
16:05:16 <byorgey> nohonor: oh, wait, no, it is a product
16:05:22 <ivanm> int80_h: if you're only going to use the new version of all those packages, then use --force-reinstalls
16:05:33 <kirindave> I saw edwardk's lens talk and it seems like that's exactly what I want, but I'm not sure how to use it to select a specific item from a list and update it.
16:05:33 <nohonor> product meaning... tuple?
16:05:35 <byorgey> nohonor: it's defined at the bottom of page 6
16:05:37 <kirindave> Anyone have any advice?
16:05:41 <byorgey> nohonor: yes
16:05:49 <ivanm> kirindave: I don't think you use lens to pick an element of a list
16:05:59 <byorgey> nohonor: you write  B -> A || B  which is why I was confused, you cannot implement that for tuples
16:06:02 <mekeor> ivanm: me neither
16:06:03 <kirindave> ivanm: Because it has to be a Maybe?
16:06:07 <dibblego> ivanm: sure you do
16:06:18 <ivanm> kirindave: if you want to pick a specific element from a list and update it - and do this often - then you're probably using the wrong data structure :)
16:06:33 <dibblego> kirindave: Control.Lens.Traversal
16:06:33 <ivanm> dibblego: oh? edwardk has a lens for that? *shrug*
16:06:35 * mekeor nods
16:06:55 <nohonor> byorgey, thanks :-)
16:06:56 <dibblego> kirindave: prior to Ed's lenses, we used a zipper, which is another way
16:07:01 <byorgey> surely you *can* use a lens to modify an item in a list.  whether you *want* to is a different question.
16:07:03 * mekeor didn't nod because of what dibblego said... nevermind
16:07:08 <ivanm> kirindave: updating a single element of a list is O(n)
16:07:11 <ivanm> mekeor: heh
16:07:17 <kirindave> dibblego: yeah, I was gonna say the zipper is the other way and I know edwardk's library gives everyone a free zipper over everything.
16:07:32 <kirindave> ivanm: I have an unbounded collection of named entities.
16:07:37 <nicoo> ivanm: Technically, updating the k-th element is O(k)
16:07:37 <kirindave> ivanm: I could use a Map.
16:07:41 <lispy> zippers for free sounds like a good paper title
16:07:47 <lispy> (maybe it already is?)
16:07:51 <kirindave> lispy: Well actually it's sort of redundant. :)
16:07:52 <ivanm> nicoo: sure, but you typically specify worst case or some kind of amortised case, right?
16:08:12 <mekeor> fast question: is there a better way for "reverse . sortBy (comparing foo)"?
16:08:31 <dibblego> look up MultiLens, which was a predecessor in data-lens to Ed's work
16:08:32 <ivanm> mekeor: sortBy (flip $ comparing foo)
16:08:34 <nicoo> ivanm: If you know that in the algorithm, k is O(1) or O(log n), this seems sane
16:08:46 <mekeor> ivanm: oh right =) thanks
16:11:10 <fmap> ivanm: pasted diagrams look the same, no?
16:11:48 <kirindave> dibblego: Oh so line traverse the list with a predicate? Using like mapM?
16:12:14 <int80_h> Can anyone advise me on my install problem? I'm willing to blow away all packages and start over if that's the most efficient way to do this.
16:12:17 <dibblego> kirindave: I am not sure what you asked, but traverse=mapM
16:12:35 <Guest63876> hi, i'm stuck on this recursion thing: i have two recursive expressions (one of them calls the other - sort of imitating a 'while' and the body of a while). in the body of the while-like-expression, i push an value onto a stack, perform some operations of that value, then pop it. how would you go about passing this value to the outer recursive function?
16:12:35 <kirindave> dibblego: Ahh I see an example in the wiki.
16:12:40 <kirindave> mapMOf (traverse._2) (\xs -> length xs <$ putStrLn xs) [(42,"hello"),(56,"world")]
16:12:44 <kirindave> All that needs is a predicate
16:13:29 <ivanm> fmap: there's differing alignments; see for example where the line joins the root node
16:13:32 <kirindave> You could write mapMWhere pretty easily, I guess.
16:13:33 <ivanm> int80_h: I already did up above!
16:13:45 <ivanm> <ivanm> int80_h: if you're only going to use the new version of all those packages, then use --force-reinstalls
16:14:38 <Cale> Guest63876: could you rephrase your question? What are you trying to compute?
16:14:55 <int80_h> ivanm: oops. did not see
16:15:39 <Cale> Guest63876: If all you have are functions, you can only pass values around in one of two ways: they are either the results of functions, or they are the parameters to functions.
16:16:49 <int80_h> ivanm: I'm not sure if all libraries I will have installed will use the newest version of everything. How would I check in the most efficient way?
16:18:08 <ivanm> int80_h: ghc-pkg check, and then rebuild the broken packages
16:18:19 <ivanm> but I believe this is why people recommended cabal-dev for yesod :)
16:18:44 <Nereid> I learned about cabal-dev recently and it made me happy.
16:18:56 <Nereid> it should make you happy too.
16:19:20 <ivanm> fmap: do you see the difference now?
16:19:46 <int80_h> Nereid: I'll try it and see what happens.
16:20:11 <pauser> im having troubles with a the function here. I can not find out why this function gives me just the first tuple  http://pastebin.com/nrqRtL5P  .
16:20:14 <mauke> The paste nrqRtL5P has been copied to http://hpaste.org/76965
16:20:54 <ivanm> pauser: first of all, I highly suggest you don't do it that way :)
16:21:13 <pauser> witch way should i do it?
16:21:36 <ivanm> well, if you're allowed to use higher-order functions, that looks like a prime candidate for a map + filter (or a list comprehension)
16:21:53 <ivanm> otherwise, pattern match on rs rather than using rs == []
16:22:23 <ivanm> actually, line 3 is redundant
16:22:24 <Nereid> pauser: and the "otherwise" case doesn't look like it does the right thing.
16:22:35 <ivanm> Nereid: oh? why not?
16:22:45 <Nereid> I'm guessing.
16:22:51 <Nereid> because the recursion stops there.
16:22:52 <fmap> ivanm: yeah, but it's not very significant
16:22:53 <pauser> btw Database is a list
16:23:01 <ivanm> pauser: yes, we can tell :)
16:23:15 <ivanm> pauser: can you give us an example usage that you think is wrong?
16:23:34 <ivanm> fmap: sure, but I figured I should check what people think before I upload the new version of my package :p
16:24:52 <pauser> http://hpaste.org/76966  , flights db "Anton"
16:25:15 <ivanm> oh, right, I get what's wrong
16:25:15 <kirindave> Man, there is basically no limit to how awesome edwardk's lens library is.
16:25:21 <Nereid> as I said, the otherwise case.
16:25:25 <ivanm> you don't say what to do if n /= name
16:25:37 <Nereid> yes he does, he's saying the recursion ends there.
16:25:42 <ivanm> Nereid: yeah, I was too busy focussing on the structure :)
16:25:51 <ivanm> Nereid: OK, but I don't think that's what he intended :p
16:25:53 <Nereid> me either.
16:26:29 <pauser> me: facepalm
16:26:30 <hpaste> ivanm annotated ‚Äúpastebin.com/nrqRtL5P‚Äù with ‚ÄúCleaner version of pauser's code‚Äù at http://hpaste.org/76965#a76968
16:26:48 <SilvioBerluscone> Cale, broseph, so if I define foo = show . read, this function is basically unusuable or is there a way to make foo usuable in context?
16:27:03 <ivanm> pauser: that's basically a merged map + filter implemented there ^^
16:27:17 <ivanm> SilvioBerluscone: do you know what type you'll be reading in?
16:27:23 <ivanm> or do you want it to work magically for any type?
16:27:35 <SilvioBerluscone> ivanm, that's the point, I can't tell it that any more I think
16:27:35 <ivanm> if the former, you can get it to work using asTypeOf or an explicit type annotation
16:27:38 <ivanm> in the latter, not really
16:27:51 <SilvioBerluscone> ivanm, asTypeOf, teach me how that works
16:27:58 <SilvioBerluscone> the type annotation I'm not sure how to make it work on foo.
16:28:00 <Nereid> a list comprehension will do it nicely too: flights db name = [(f,a) | (n,f,pd,d,a) <- flights, n == name]
16:28:05 <SilvioBerluscone> Because the type of foo is String -> String
16:28:17 <SilvioBerluscone> :t show . read
16:28:18 <lambdabot> String -> String
16:28:28 <Nereid> > (show . read) "5"
16:28:29 <ivanm> @type show . (`asTypeOf` (undefined :: Int)) . read
16:28:30 <lambdabot> String -> String
16:28:30 <lambdabot>   "*Exception: Prelude.read: no parse
16:28:30 <SilvioBerluscone> Like, it typechecks, it will just raise an exception in code I think
16:28:46 <ivanm> > let f = show . (`asTypeOf` (undefined :: Int)) . read in f "5"
16:28:48 <lambdabot>   "5"
16:28:49 <ivanm> SilvioBerluscone: ^^
16:28:49 <SilvioBerluscone> ivanm, of couse, but I mean once I already defined it as foo.
16:28:53 <Nereid> > (show . (id :: Int -> Int) . read) "5"
16:28:54 <lambdabot>   "5"
16:28:56 <SilvioBerluscone> Yeah, I know that
16:29:04 <ivanm> well, that's the only thing you can do
16:29:06 <SilvioBerluscone> But I mean, can I make foo work after I defined it like that.
16:29:07 <SilvioBerluscone> Hmm
16:29:15 <ivanm> with just "show . read" you can't do anything
16:29:21 <SilvioBerluscone> so once I did foo = show . read, there is basically no way any more to make foo be useful?
16:29:23 <ivanm> because it doesn't know which Read instance to pick
16:29:29 <SilvioBerluscone> Yeah, obviously.
16:29:42 <SilvioBerluscone> I just wanted to kow if haskell syntax has a way to inject that into an already bound variable.
16:29:53 <SilvioBerluscone> (I'm just using this as an example)
16:30:02 <SilvioBerluscone> It is after all a pretty useless fuction.
16:30:07 <Nereid> foo :: (...) => Proxy t -> t -> t
16:30:18 <Nereid> silliness
16:30:21 <ivanm> Nereid: oh? what's Proxy?
16:30:23 <SilvioBerluscone> Nereid, explain how that works.
16:30:44 <rwbarton> Proxy t -> String -> String ?
16:30:53 <pauser> thank you very much people. the function is functioning now :D
16:30:58 <Nereid> oh, yes.
16:31:02 <Nereid> rwbarton
16:31:08 <Nereid> not read . show :p
16:31:17 <Nereid> uh what's it.
16:31:21 <dzhus> is there GHC 7.6.1 for Ubuntu?
16:31:22 <Nereid> data Proxy t = Proxy
16:31:24 <Nereid> or something
16:31:31 <Nereid> so then you feed foo a (Proxy :: Int)
16:31:34 <Nereid> er, Proxy :: Proxy Int
16:31:44 <parcs`> dzhus: yes http://www.haskell.org/ghc/download_ghc_7_6_1#x86_64linux
16:32:59 <ivanm> Nereid: oh, to force a type?
16:33:02 <Nereid> yeah
16:33:19 <rwbarton> then you need to do some work in the definition of foo too
16:33:25 <ivanm> how can you get show . read to use that type though?
16:33:25 <Nereid> a little.
16:33:35 <ivanm> since SilvioBerluscone didn't want the definition to change
16:33:46 <Nereid> well you can't literally write show . read
16:34:01 <Nereid> because, as noted earlier, that's useless.
16:34:04 <Nereid> but you could say write
16:34:18 <Nereid> foo :: (...) => Proxy t -> String -> String; foo _ = show . (read :: String -> t)
16:34:35 <SilvioBerluscone> It's purely of theoretial interest I might add, I just want to know if there is a way to force instances or whatever in such a function where the type inference has no way to infer the instance.
16:34:58 <Nereid> not really?
16:35:41 <SilvioBerluscone> Yeah, I'd have assumed so, doesn't hurt to ask though.
16:35:57 <SilvioBerluscone> So which of you fine gents is going to add composite types to the langauge to make it happen?
16:36:00 <Nereid> or foo p = show . (`asProxyTypeOf` p) . read
16:36:13 <Nereid> from http://hackage.haskell.org/packages/archive/tagged/0.4.2.1/doc/html/Data-Proxy.html
16:36:39 <SilvioBerluscone> To be able to do (foo :: String ->> Int ->> String) "3" or something to mae it happen.
16:37:23 <Nereid> once you write the expression (show . read) anywhere, it's completely useless
16:37:28 <rwbarton> you can probably do it if you are allowed to redefine (.) :P
16:37:35 <rwbarton> f . g = (f, g)
16:37:39 <rwbarton> or similar
16:37:43 <Nereid> anything that could possibly affect the intermediate type there would violate referential transparency or something
16:38:03 <SilvioBerluscone> Nereid, well, t's just an example I used, only one I could think of.
16:38:31 <SilvioBerluscone> I basically mean in the general case where you get this with typeclass instances that the type checker has no way to infer which instance inside a function but it still typechecks because that
16:38:34 <SilvioBerluscone> 's how stuff goes.
16:38:59 <Nereid> > show . read $ "()"
16:39:01 <lambdabot>   "()"
16:39:16 <sm> int80_h: got it installed ?
16:39:21 <SilvioBerluscone> :t read "()"
16:39:22 <lambdabot> forall a. (Read a) => a
16:39:27 <ivanm> SilvioBerluscone: then you use a trick like Proxy or something to be able to let it know which type to use
16:39:31 <SilvioBerluscone> I am confused.
16:39:41 <ivanm> SilvioBerluscone: it doesn't know which parser to bring in!
16:40:01 <ivanm> after all, I can define data Unit = Unit but have it's Show/Read instances be the same as for ()
16:40:18 <rwbarton> show . read has type (Show a, Read a) => String -> String and then the variable a gets defaulted to ()
16:40:37 <int80_h> sm: trying to upgrade ghc 7.4.1 to 7.4.2 first. I'm proceeding slowly as I want to minimize what I mess up.
16:40:51 <int80_h> sm: I can't find any instructions on how to do this upgrade.
16:40:54 <SilvioBerluscone> rwbarton, ahh, I see
16:41:13 <ivanm> rwbarton: only in ghci though, right?
16:41:18 <SilvioBerluscone> So basically the intance on () is used when it has no proof to another one?
16:41:26 <rwbarton> or whenever ExtendedDefaultingRules is in effect
16:41:35 <SilvioBerluscone> And it cannot parse  "a unit"out of  "3"  wich is what the error causes?
16:41:39 <ivanm> int80_h: 1) uninstall old ghc, 2) install new ghc, 3) install the packages you want
16:41:52 <ivanm> you can now do "cabal install world" to install all the packages you previously had installed
16:41:54 <Nereid> yes, show . read is normally an error
16:42:02 <ivanm> but I don't know how correct/safe it is
16:42:19 <ivanm> SilvioBerluscone: ghci has lots of extra rules to help it pick a "correct" type
16:42:19 <ocharles> I have a 2 dimensional repa array, that is around 1024x1024. I need to take the 40 elements that have the highest magnitude. That is, naively, take 40 . sort . toList
16:42:28 <acowley> does anyone have any pointers to recent (P)HOAS code?
16:42:31 <ivanm> like how integral literals become Integer values if no type is specified
16:42:40 <ocharles> there's presumably better ways, perhaps something with O(1) insertion - I have no need for lookup, other than getting the final 40 elements
16:43:24 <ocharles> maybe O(1) is optimistic, but fast insertion :)
16:43:28 <Nereid> O(40) insertion
16:43:37 <Nereid> :)
16:43:51 <ocharles> that wolud be O(1)
16:43:52 <ivanm> ocharles: without knowing anything more about the structure of your array, I wouldn't have a clue as to how you'd find the 40 elements with highest magnitude :/
16:43:57 <Nereid> yes but if you changed the 40
16:44:16 <Nereid> I don't think the structure of the array matters, since you need to look at the entire array anyway?
16:44:25 <ocharles> right.
16:44:33 <rwbarton> only if you want to parallelize somehow
16:44:40 <c_wraith> if it's sorted, you can do better. :)
16:44:42 <Nereid> but if 40 is small compared to the size of the array it's probably fine just to keep a running list of the top 40 you've seen so far as you traverse it
16:44:46 <rwbarton> you can run the toList of the array through a priority queue
16:44:46 <ocharles> but what I'm doing is: multi-resolution decomposition of an image to haar wavelet coefficients
16:44:51 <ocharles> i have that bit done fast with repa
16:44:51 <ivanm> Nereid: that's what I meant; if he had some kind of structured data that would let you guess where the highest values are, then you could factor that in
16:44:56 <Nereid> mhm
16:44:59 <ocharles> rwbarton: right, that was my plan
16:45:10 <ocharles> the toList thing takes longer than the algorithm, but i can probably live with that
16:45:14 <rwbarton> heh :(
16:45:26 <ocharles> are there any good implementations of priority queues I can take off the shelf?
16:45:33 <ocharles> i'm ok with this not being blazingly fast for this prototyping
16:45:39 <Nereid> I know of PSQueue
16:46:08 <ocharles> just not what I wrote above, which takes at least an order of magnitude longer than the haar algorithm itself
16:46:10 <sn131678> process sharing
16:46:12 <ocharles> i'll have a look at that
16:46:43 <rwbarton> how about using one of the foldAll functions
16:47:03 <ocharles> a fold does sound like it could help
16:47:17 <ocharles> folding with an ordered list?
16:47:34 <rwbarton> operation is taking the union and then truncating to top 40 elements
16:47:37 <acowley> Yes, do a fold with an ordered list
16:47:39 <rwbarton> however you wany to represent it
16:47:43 <ocharles> \(x:xs) y -> if y > x then take 40 (y:x:xs) else (x:xs) or something?
16:48:06 <acowley> you need to insert the y in sorted order
16:48:13 <ocharles> i am, at the head
16:48:15 <rwbarton> well the foldAll* functions expect an associative operation so they can do parallelization
16:48:23 <Nereid> oh I totally skipped over the part where you said repa
16:48:28 <ocharles> oh! and the starting point of the fold is []
16:48:31 <ocharles> that's where I got stuck before
16:48:41 <ocharles> because (Int,max) is a semigroup, not a monoid
16:48:48 <rwbarton> hm
16:48:53 <ocharles> but [] totally makes sense
16:48:58 <rwbarton> it only seems to want to let you fold over unboxable values though
16:49:02 <acowley> The point is, if the list is big endian or little endian, you need to insert new elements in the right place
16:49:07 <ocharles> right
16:49:17 <acowley> if it's little endian, then the y > x comparison makes sense, but then you can't assume y is the new least element
16:49:49 <ocharles> rwbarton: not the end of the world, there is an Unbox Double instance
16:50:41 <ocharles> oh wait, a fold doesn't solve the final problem...
16:50:52 <ocharles> which is that I want the coordinate of the top 40 coefficients, not the coefficients themselves..
16:50:53 <ocharles> hm
16:51:33 <rwbarton> I wouldn't expect to do much better than a fold with a priority queue
16:52:03 <rwbarton> how can toList be that slow?
16:52:21 <Nereid> rwbarton: e.g. a sparse array
16:52:38 <rwbarton> repa doesn't have sparse arrays does it
16:52:43 <ocharles> sholud I run toList through criterion?
16:52:48 <rwbarton> I guess it has P arrays
16:52:49 <Nereid> rwbarton: doesn't seem like it
16:52:50 * ocharles does that to give you some real numbers
16:52:57 <Nereid> what's a P.
16:53:02 <rwbarton> do something more realistic like foldl' (+) 0 . toList
16:53:07 <ocharles> ok
16:53:16 <rwbarton> "Arrays that are partitioned into several representations" whatever that means
16:53:18 <shachaf> Which toList is this?
16:53:22 <rwbarton> repa's
16:53:24 <sm> ivanm: I've never had to uninstall an old version of ghc to upgrade it. Just install the new one, it will become the default
16:53:31 <ocharles> Data.Array.Repa.toList
16:53:47 <rwbarton> this is repa 3 right?
16:53:47 <sm> if using the ghc binary packages
16:54:18 <ivanm> sm: true, but you're going to uninstall it you might as well do it beforehand so that files don't mix up/clash
16:54:34 <nohonor> is an operator over types a type?
16:54:51 <acowley> It's a type constructor
16:54:53 <Nereid> nohonor: depends on what you mean by "type"
16:55:06 <Nereid> but yeah a type function/type constructor.
16:55:11 <nohonor> Nereid, a set of values
16:55:11 <acowley> but we run out of words and it gets kind of fiddly quite quickly
16:55:12 <sm> they won't.. I usually keep a few old ghc's around for testing
16:55:17 <Nereid> because type usually refers to something of kind *
16:55:32 <ocharles> rwbarton: installed a few days ago, so I think so
16:55:34 <Nereid> but sometimes people just say "type" to mean a member of any kind
16:55:49 <nohonor> Nereid, interesting
16:55:59 <rwbarton> and i assume the output of your computation (i.e. the thing you call toList) on is in a manifest representation (U/V/B/F)
16:56:04 <Nereid> so [] is a "type" of kind * -> *
16:56:05 <nohonor> what is the precise definition?
16:56:18 <ocharles> rwbarton: toList isn't the slow bit, the sort and take 40 is it seems
16:56:19 <rwbarton> depends on who you ask
16:56:22 <ocharles> no, my result is delayed
16:56:24 <rwbarton> ocharles: oh, ok
16:56:26 <nohonor> i mean, is a -> a a type or a type expression
16:56:27 <rwbarton> oh
16:56:34 <ocharles> i'll paste what I'm working with
16:56:54 <Nereid> nohonor: it's a string of characters that denotes a type?
16:56:55 <acowley> a -> a is a type
16:56:57 <Nereid> (parametrized by a)
16:57:08 <ocharles> https://gist.github.com/2bf6f247907a7229d3ec is what i have so far
16:57:10 * sm currently has.. 6.12.3, 7.0.2, 7.0.4, 7.2.2, 7.4.1, 7.4.2, uh more than I need
16:57:23 <acowley> (->) :: * -> * -> *  ‚Ä¶ as it were
16:57:30 <Nereid> @kind (->)
16:57:31 <lambdabot> ?? -> ? -> *
16:57:40 <Nereid> oh right that business.
16:57:46 <nohonor> ok, so it's the set of all functions from any set to itself
16:57:58 <nohonor> but what about Maybe?
16:58:01 <nohonor> what set is that
16:58:01 <rwbarton> ocharles: oh, well, that all does no computation up front
16:58:19 <ocharles> right
16:58:26 <ocharles> so should I computeP or something?
16:58:28 <Nereid> nohonor: it can be convenient to think of types as sets, although they're actually not, I guess.
16:58:34 <rwbarton> so make sure you aren't counting the computeP or whatever time in your benchmark, is all
16:58:37 <acowley> Maybe's kind is * -> *
16:58:40 <ocharles> ok
16:58:49 <nohonor> Nereid, what are they then?
16:58:57 <nohonor> if not sets of values
16:59:27 <acowley> If a type is a set, then what is the type of type?
16:59:37 <rwbarton> nohonor, types of course :)
17:00:42 <nohonor> acowley, a type is not a value i guess, so it doesn't have one
17:00:55 <acowley> Everything has a type!
17:01:03 <monochrom> everything is a set
17:01:09 <acowley> monochrom is a set
17:01:14 <nohonor> darn
17:01:24 <nohonor> i'm just trying to grok what the type system is about
17:01:25 <monochrom> I am just mocking set theorists
17:01:44 <nohonor> but i can't seem to even find a consistent set of definitions to work with
17:01:45 <acowley> nohonor: Take a look at http://en.wikipedia.org/wiki/Russell's_paradox to see why we run aground
17:02:04 <acowley> nohonor: For simplicity, in Haskell we say that values have types, and types have kinds
17:02:13 <acowley> if you ask any more questions, then people get cross with you
17:02:18 <acowley> (that's a joke)
17:02:26 <simpson> And kinds have sorts, don't they? At least in GHC?
17:02:37 <acowley> Yes, probably, but my eyes start rolling at that point
17:02:54 <Nereid> simpson: but there is only one sort
17:02:56 <Nereid> at least in GHC
17:03:15 <simpson> Nereid: Right, but the idea is that there's no "type of types" to cause problems.
17:03:50 <Nereid> well you can deal with them, as any dependent type system must
17:03:53 <acowley> I really wish I could pass a type family
17:04:16 <acowley> This is the kind of friction that drives people to madness (aka Coq/Agda/etc)
17:06:41 <Nereid> I should learn coq
17:06:54 <ocharles> how the hell do you use criterion so it DOESNT say "variance is severely inflated by outliers" ?
17:06:56 <Nereid> I could start by installing it I guess
17:07:07 <ocharles> just keep bumping up cfgSamples ?
17:08:44 <roconnor> So is Safe haskell simply an exercise is authors writing "Trustworthy" everywhere?
17:09:44 <c_wraith> roconnor: yes
17:09:50 <pauser> how do i return a empty tuple, just like the [] to end the recursion ?
17:09:58 <ocharles> jeez, I collected 10k samples in 80 seconds and it's still severely inflated
17:09:59 <c_wraith> pauser: there is no such thing
17:10:11 <Nereid> pauser: you don't
17:10:25 <roconnor> pauser: () ?
17:10:27 <pauser> ah i need an extra function then
17:10:31 <Nereid> no you don't
17:10:49 <Nereid> unless you're trying to do something different now
17:10:51 <c_wraith> roconnor: safe haskell requires that the person executing the code trust the packages they have installed
17:10:51 <SilvioBerluscone> pauser, basically () and (1,1) and (1) are as different a type as "string" and 3 :: Float
17:11:19 <SilvioBerluscone> There is no general function which for instance takes an n-tuple as arguemnt and produces an n+1-tuple as return value
17:11:27 <roconnor> c_wraith: is there an explicit step to trust packages?
17:11:42 <c_wraith> roconnor: if you trust that the packages you have installed all mark things trustworthy/safe/unsafe properly, then you trust that you can run code that compiles as safe
17:11:55 <c_wraith>  doesn't do anything harmful
17:12:05 <pauser> i get it no () :D
17:12:11 <roconnor> c_wraith: but I don't trust things that I randomly cabal install
17:12:22 <kirindave> Grumble grumble
17:12:24 <c_wraith> roconnor: then safe haskell isn't going to do much for you
17:12:31 <c_wraith> roconnor: that's not the use case it's designed for
17:12:32 <kirindave> I tell cabal main-is: labprompt
17:12:39 <kirindave> Warning: output was redirected with -o, but no output will be generated because there is no Main module.
17:12:44 <kirindave> But it builds.
17:12:50 <kirindave> It just doesn't output the executable
17:13:12 <Nereid> kirindave: put .hs on it?
17:13:21 <Nereid> main-is: labprompt.hs
17:13:26 <kirindave> I did.
17:13:28 <roconnor> c_wraith: I don't understand what the use case is.
17:13:32 <Nereid> well who knows.
17:13:52 <roconnor> c_wraith: I don't see how anything I install will not pass --safe
17:13:55 <c_wraith> roconnor: primarily compiling/running third-party code
17:14:02 <c_wraith> roconnor: not packages, code.  like plugins
17:14:10 <roconnor> ah
17:14:15 <roconnor> too bad
17:14:31 <fryguybob> kirindave: I had that recently and added    ghc-options:       -main-is MyModule.Name
17:14:44 <kirindave> fryguybob: I was just about it
17:14:49 <kirindave> Becuase evidently this feature is just not working right.
17:15:37 <c_wraith> roconnor: and of course, you can set the visible packages at compile time.  If you do that, you keep packages you don't trust to have gotten their safe haskell things correct installed without interfering
17:25:00 <ashleyp> 21‚Ñ¢¬°
17:29:59 <ocharles> rwbarton: even a fold doesn't really work, because the fold in repa is (a -> a -> a)
17:30:24 <ocharles> at least, I don't think it does..
17:30:32 <ocharles> because i'd have to wrap every element in an array first
17:38:27 <kirindave> Can I suppress a specific type of warning for a specific value?
17:38:45 <kirindave> Like if I am making a "smart constructor" for a data and I deliberately want to leave 1 field undefined so the user has to define it, but otherwise make default values
17:39:02 * hackagebot DAV 0.0.1 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.0.1 (ClintAdams)
17:39:04 <kirindave> I was taught to say someData = SomeData {field1 = 1, field2 = 2}
17:39:13 <kirindave> And then someData {field2 = 5} works.
17:39:22 <kirindave> But it gives me a big warning in compile
17:39:56 <Nereid> what's the warning?
17:40:05 <geekosaur> I don't think you can suppress for a single field, and even if you could I don't think the compiler will keep track of "user must initialize this one component"
17:40:13 <kirindave> Warning: Fields of `SomeThing' not initialised: _id
17:40:16 <Nereid> geekosaur: but it's a record update
17:40:16 <kirindave> Which is correct. :)
17:40:23 <Nereid> _id?
17:40:35 <kirindave> Yeah semantics.
17:40:48 <rwbarton> ocharles: right, so you would want toList and a regular foldl'
17:40:50 <Nereid> or did you mean SomeData {field2 = 5}
17:40:54 <beaky> can you have currying without closures?
17:41:06 <kirindave> Nereid: Can't really talk about the specific domain.
17:41:11 <Nereid> beaky: not really
17:42:30 <Nereid> beaky: well, partial application in general
17:46:16 <nand`> I hate the ‚Äòwarning: fields not initialized‚Äô warning when writing lens-y code like Foo # field1 .~ 1 # field2 .~ 2
17:47:08 <Nereid> is # like a flipped $?
17:48:03 <Nereid> wait
17:48:06 <nand`> slightly higher precedence, but yeah
17:48:12 <nand`> wait, where is #?
17:48:13 <Nereid> then you'd need Foo {} # ...
17:48:17 <Nereid> good question
17:48:17 <nand`> I don't seem to have it right now
17:48:19 <nand`> Nereid: oh, you do?
17:48:23 <nand`> oh
17:48:27 <nand`> I meant % not #
17:48:31 <nand`> diagrams has been getting to me
17:48:36 <Nereid> I'm told it's a keyword.
17:48:37 <Nereid> ah.
17:48:49 <nand`> diagrams exports (#), also as flip ($); but with a higher precedence
17:48:52 <nand`> fairly high in fact
17:48:58 <nand`> but (%) is fairly low, but above ($)
17:49:14 <Nereid> infixl 1, yeah
17:49:27 <nand`> Nereid: # a keyword? Only thing I know is -XMagicHash which allows it for names but that's it
17:49:36 <Nereid> yeah, with -XMagicHash
17:49:42 <nand`> but that isn't a keyword is it?
17:49:46 <nand`> just a special name char, like _ or '
17:49:52 <Nereid> it's the kind of unboxed types
17:49:56 <nand`> oh
17:50:01 <nand`> I did not know that
17:50:09 <Nereid> but * isn't a keyword...
17:50:54 <Nereid> ah, we can still use (#) even with -XMagicHash.
17:50:56 <Nereid> so never mind.
17:53:16 <beaky> can you do OOP in haskell?
17:53:23 <nand`> Nereid: also you're right, it's Foo{} and not Foo; I forgot Foo was still :: Field1 -> Field2 -> ... -> Type for records
17:53:41 <nand`> (a symptom of my excessive tiredness, I should hope)
17:53:58 <Nereid> beaky: that's kind of a poorly posed question
17:54:02 <nand`> beaky: first you should probably define what you mean by ‚ÄòOOP‚Äô, since it isn't exactly clear
17:54:15 <nand`> then surely somebody will step in and show how to implement those concepts in Haskell
17:54:16 <Nereid> @where OOP
17:54:16 <lambdabot> I know nothing about oop.
17:54:22 <Nereid> hehe
17:54:27 <geekosaur> "oop"s?
17:54:28 <beaky> ah
17:54:35 <beaky> I don't understand OOP myself :(
17:54:57 <guidj0s> ski: 'You there?
17:54:58 <Nereid> neither do java programmers
17:55:07 <beaky> I'm still checking out a programming language called smalltalk to find out what OOP is
17:55:09 <nand`> then it probably isn't a good idea to ask whether or not you can do it in Haskell, and rather focus on concrete problems
17:55:17 <Nereid> smalltalk is pretty oop.
17:55:54 <nand`> fairly
17:55:56 <nand`> is smalltalk an object?
17:56:06 <beaky> in smalltalk, everything is an object
17:56:10 <beaky> even the IDE is an object
17:56:20 <Nereid> beaky: basically it's not a good idea to try to map concepts in other languages to concepts in haskell
17:56:30 <beaky> right
17:56:39 <Nereid> sure, there are analogies
17:56:50 <nand`> unless you're writing a compiler from some language to Haskell
17:56:55 <Nereid> lol
17:57:03 <Nereid> then you're mapping more than concepts. :v
17:57:25 <nand`> you're still mapping concepts; just all of them
17:57:45 <Nereid> well, all concepts are kan extensions
17:58:16 <nand`> what's the proper term for a morphism between kan extensions?
17:58:29 <Nereid> what's the proper term for a morphism between initial objects?
17:58:39 <ryanos> beaky: you can't do "oop" in haskell - you can do much better though - can use functional programming..
17:59:09 <nand`> Nereid: isomorphism, surely
17:59:19 <Nereid> no, that's too broad
17:59:20 <beaky> folks keep saying that OOP is the way folks naturally think; how is functional programming related to the way we think?
17:59:26 <nand`> indeed
17:59:31 <simpson> I think that it's a false dichotomy.
17:59:40 <ryanos> beaky: i don't know how u think ... so can't answer that question
17:59:55 <nand`> I think about programs as functions
18:00:16 <ryanos> beaky: ppl say oop is good to "model" systems because you can map concepts from the object world into the oop model
18:00:23 <nand`> (as in, even for non-functional programming)
18:00:30 <ryanos> beaky: but you can do the same in fp
18:00:43 <nand`> can you map a wave function into OOP?
18:00:47 <simpson> ryanos: Nah. I say it's largely useful because you can encapsulate both state and functionality in units.
18:00:53 <Nereid> or perhaps haskell is the ultimate oop language :v
18:01:02 <Nereid> just as it is the ultimate imperative language
18:01:12 <ryanos> simpson: that's right also. didn't want to get in details
18:01:27 <simpson> Also, can we stop saying "object-oriented" and "functional" without reasonable definitions? I think that people are thinking "Java" and "Haskell" when they say these words, and it's not useful.
18:01:27 <nand`> Haskell is good at EDSLs, I would guess it wouldn't be too far-fetched for somebody to have implemented a dynamically typed, object-oriented EDSL
18:02:10 <ryanos> simpson: what we discussed applies to any oop from smalltalk to c++/java/etc
18:02:59 <nand`> think https://github.com/mmirman/ImperativeHaskell/blob/master/Main.hs but more backwards
18:03:12 <ryanos> i have a lot more experience with oop systems than haskell (like decades vs months :) )but i like haskell a lot better (so far :) )
18:03:18 <nand`> I just realized I'm on a 15 second ping, I should probably stop chatting and go to sleep
18:04:30 <ryanos> to beaky's point - one thing i'm not clear yet with either - how to handle and maintain states in v large haskell systems
18:04:31 <Nereid> nand`: oh my
18:04:35 <Nereid> :)
18:04:39 <nand`> simpson: like (a, b -> a) -- look, state and functionality at the same time!
18:05:31 <ryanos> in oop systems maintaining state is trivial - hence ppl use it a lot and start running into synchronization issues/threading issues/etc
18:05:53 <ryanos> from what i've seen haskell / fp is a rad modeling shift
18:06:03 <ryanos> you have to think a lot more stateless
18:06:08 <ryanos> which is a good thing
18:06:14 <roconnor> ryanos: yep
18:06:20 <ryanos> (in a high scale, high throughput environment)
18:07:40 <ryanos> roconnor: which one is the "yep" ? :)
18:08:00 <roconnor> ryanos: from "in opp systems" onwards
18:08:15 <ryanos> sounds good, tx :)
18:08:55 <roconnor> We had a race condition at work;  I cannot help but think there would be no race condition if there was no global mutable state.
18:09:16 <ryanos> roconnor: there are always race conditions at work :)
18:09:24 <Nereid> RL race condition?
18:10:09 <ryanos> roconnor: the challenge is - how do you rearchitect these huge oop systems into fp (from oop monsters to fp monsters? :) )
18:10:38 <Saizan> toplevel IORef's of course
18:10:46 <Nereid> :D
18:10:57 <nand`> sure you can have state; whether via s -> (a, s); or via something like automaton arrows
18:11:04 <nand`> they just tend to have nice properties alongside them
18:11:09 <ryanos> hmmm... have you tried that on a thousand classes/hundread tables system ?
18:12:09 <nand`> with a Java to Haskell compiler, clearly
18:12:31 <ryanos> nand': that would be awesome.. when ca we hope for one ?
18:12:32 <roconnor> ryanos: I'm not sure.
18:13:01 <nand`> ryanos: I'm not too sure it'd be awesome
18:13:03 <ryanos> roconnor: me neither.. but still digging.. i want to get much better with haskell to be able to appreciate the pros/cons
18:13:12 <ryanos> nand': why not ??
18:13:16 <roconnor> ryanos: in principle it isn't so hard; just rewrite the functions to pass the state in and out; but in practice it doesn't seem so easy.
18:13:17 <nand`> it would probably produce a lot of illegible code, sort of like what stuff like ghcjs outputs
18:13:24 <Saizan> ryanos: the first thing we have to teach to people coming from oop is to define fewer entities (i.e. types and type-classes) and use more functions
18:14:17 <ryanos> Saizan: agree with the statement.. but how do u deal with large systems where u have many entities.. you have to have a "common type denominator" i guess
18:14:39 <ryanos> how do you determine that in a large system ?
18:14:49 <ryanos> many of them are organically grown
18:14:52 <ryanos> over time
18:14:55 <Saizan> what i'm saying is that they might not be intrinsic to the problem
18:14:58 <ryanos> sometimes by generations
18:15:27 <ryanos> Saizan: (?) no comprende
18:15:37 <ryanos> (i don't understand)
18:16:41 <ryanos> roconnor: agree, pass the state in and out BUT that means that you fully understand how the system works AND what are the side effects of the larger system
18:16:41 <Saizan> ryanos: i mean that you might be able to model the problem you're trying to solve without this growing number of entities
18:16:43 <simon> are there any tricks to annotating an AST with positions without infecting my datatypes with additional parameters everywhere?
18:17:07 <simon> maybe something like a template-generated wrapper type, or maybe something even neater that I can't imagine.
18:17:15 <ryanos> Saizan: agree, if you start with a fp system. if you try to convert an old one.. i'm at a loss what's the best approach
18:17:26 <Saizan> ryanos: maybe avoiding making distinctions when there's no need, e.g. different behaviour doesn't need a new type, you just need to pass a different function
18:19:25 <nand`> I like to say that functions can always abstract over functions; so if you use functions a lot, you will be able to re-use more code than if you rely on higher-level mechanisms
18:19:27 <ryanos> Saizan: from what i've seen diff behaviours are not implemented with new types in oop..
18:19:58 <Cale> ryanos: Yeah, I'm going to echo Saizan here because I feel quite strongly about this point. There's an extent to which typed functional programming languages are able to do a better job of capturing the spririt of object oriented programming than most typed object oriented languages (i.e. those designed for the purpose) are able to do
18:20:01 <ryanos> nand': agreed.. and in a lot more predictable way (fewer side effects)
18:20:25 <guidj0s> ryanos: The notion of `type` is strange in object-oriented environments.
18:20:32 <ryanos> Cale: i *feel* that sometiems but don't have a clue how do achieve that yet :)
18:20:33 <Cale> In most typed OO languages, the method implementations are tied directly to the classes, which are types of values.
18:21:03 <Cale> and so in order to make objects which have the same interface, but behave differently, you need to make new types
18:21:08 <ryanos> Cale: true... and the argument is "beter isolation, ownerwhip"
18:21:22 <Saizan> ryanos: i meant like when you define a new subclass of some abstract class or interface to make something with the same API that behaves differently
18:21:44 <ryanos> Saizan: eventually got it after Cale's comment too..
18:21:49 <ryanos> makes sense what u say
18:21:50 <Saizan> ah, Cale beat me to it
18:22:25 <ryanos> so what you say is because of the way the types are defined there is a proliferation of types
18:22:39 <Cale> But this subclassing just to change implementation is really spurious. The whole point of object oriented programming is that objects are determined by how they respond to messages (or how they implement methods, to use a slightly different terminology)
18:22:49 <Cale> yeah
18:23:15 <Cale> There's a lot of extra class structure which ought not to really be there
18:23:52 <ryanos> Cale: i think it is there from the idea of "reuse"
18:24:11 <Cale> It's because people didn't know how to implement first class functions efficiently, they instead went with this vtable approach
18:24:12 <ryanos> Cale: inheritance/polymorphism/etc
18:24:37 <ryanos> Cale: Stroustroup would slap you for that.. :)
18:24:39 <Cale> and that put a limitation on how flexible objects could be -- you couldn't just make up a new object by providing methods of the right types anymore
18:24:51 <Cale> (like you could in Smalltalk)
18:25:00 <nand`> yeah the whole point of object oriented programming is that methods are associated with values; and not types
18:25:04 <nand`> Java seems to have gloriously missed it
18:25:22 <ryanos> nand': not sure i get your points
18:25:59 <nand`> say I have some class Quacker with a method named ‚Äòquack‚Äô; I could create different instances of this class; one that quacks like a duck and one that quacks like a dog
18:26:05 <nand`> each value has its own ‚Äòquack‚Äô
18:26:06 <Cale> and all this funny business about inheritance is just scrambling to try to recover some of the flexibility which was lost, and most of it is nonessential to the heart of OO
18:26:23 <nand`> but in, say, Java, methods are statically bound to the types; they just get an implicit reference to the instance they live in
18:26:26 <nand`> (for values)
18:26:49 <nand`> so I'd have to subclass Quacker; with a DogQuacker and a DuckQuacker, and implement ‚Äòquack‚Äô differently
18:27:23 <nand`> but this is, for example, static; I can't create a new sort of Quacker at runtime, I'd have to abstract that into a GeneralizedQuacker; daresay a QuackerFactory
18:27:33 <Cale> yes
18:27:41 <ryanos> Cale: agree BUT not a big fan of smalltalk either (not abt oop) but about how is used
18:28:10 <Nereid> I tried smalltalk once but my OCD side couldn't get around the whole image business
18:28:21 <Nereid> gotta start clean
18:28:35 <startling> yeah, that's odd. not sure I like that.
18:29:05 <Nereid> I like lua.
18:29:23 <Cale> ryanos: Well, yeah, there are lots of other downsides to the way that Smalltalk works, but some things about OO, it got a bit more right than many of the typed OO languages that came after (those drew inspiration from the Modula family of languages)
18:30:14 <nand`> of course, Haskell has both
18:30:29 <nand`> class Quacker q where quack :: Proxy q -> String -- associated with types
18:30:30 <ryanos> nand': ok.. so not sure i get what u say.. ruby can do the quacking as you want also :)
18:30:42 <nand`> newtype Quacker = Quack String -- associated with values
18:31:02 <Cale> ryanos: So, there's this whole different way that OO tends to work in these dynamically typed OO languages, where although you don't have types as such as enforced by the language, the types which are in your head merely consist of which operations each object supports.
18:31:15 <nand`> oh right, I wanted to sleep
18:31:23 <Cale> (and what the types of those operations are)
18:31:41 <Cale> and don't necessarily say *what the operations do*
18:31:45 <ryanos> Cale: agree, made the point abt ruby just to bring a counter example for nand
18:32:01 <nand`> (I don't know ruby, can't argue, can't interpret point)
18:32:02 <ryanos> (i don't think dynamic typing / duck typing is a good thing)
18:32:09 <Cale> Whereas in Java if you need different behaviour, you have to make a new type regardless of whether there's any new interface.
18:32:33 <Cale> One could imagine an OO language which does things a bit differently though
18:32:39 <ryanos> nand': "duck typing" is a typical example used in ruby to show the power
18:32:58 <Cale> Just make the types of objects specify *only* which methods and which types those methods have.
18:33:14 <Cale> and all the method implementations go into the construction of the objects
18:33:27 <Cale> (you need first class procedures to make that work though)
18:33:34 <Nereid> I like lua.
18:33:55 <Nafai> lua's...interesting.
18:34:05 <Cale> ryanos: It's kind of like having only interfaces, and no "classes" in the traditional sense.
18:34:07 <ryanos> Cale: "Whereas in Java.." - agreed
18:34:08 <simpson> Lua's 1-indexed. :T
18:34:30 <Cale> ryanos: and if this is closer to your ideal OO programming language, then you'll find Haskell does an admirable job of modelling it
18:34:36 <Nereid> I like how it does exactly what it set out to do.
18:34:38 <Nereid> no funny business.
18:34:54 <ryanos> Cale: i don't think dynamic typing languages are ideal at all.
18:34:56 <Cale> ryanos: Because we can indeed have records of functions (maybe involving IO actions, maybe pure)
18:35:05 <ryanos> very flexible indeed but not ideal
18:35:12 <Cale> ryanos: I'm not talking about dynamically typed languages anymore
18:35:35 <Cale> I'm talking about a language where the type of an object only specifies: 1) Which methods it supports and 2) Their types.
18:35:49 <ryanos> Cale: have a hard time keepign up with you and nand' - you guys have a higher throughput than i can handle :)
18:36:06 <ryanos> so let me focus on you now that nand is sleeping
18:36:06 <Cale> So you still do static typechecking, but method implementations are no longer part of class declarations
18:36:32 <Nereid> sounds like haskell.
18:36:36 <Cale> So you need some new primitive way to construct objects of a given type by providing implementations of all the methods
18:36:48 <ryanos> Nereid: exactly my thought
18:36:52 <Nereid> ;)
18:37:04 <Cale> and yeah, if this sounds like Haskell, well, you can see how Haskell can be an OO language :)
18:37:38 <Cale> and this model of OO is actually better in a lot of cases than the one which most of the typed OO languages are providing.
18:38:05 <Cale> in that you don't have this proliferation of nonsense structure just to provide slightly different method implementations, or the need for "factory" classes
18:38:53 <Cale> I think there might be an obscure typed imperative OO language or two which makes this separation as well.
18:39:34 <Nereid> could you do some vtable silliness in C++ maybe
18:39:58 <Cale> Oh, by directly messing with the vtables? I don't know.
18:40:09 <Cale> Maybe.
18:40:22 <ryanos> in a way if you use templates in c++ u can do teh same, no ?
18:40:24 <Nereid> maybe. sounds disgusting, though
18:40:37 <Nereid> templates?
18:40:59 <Cale> Well, yeah, *kinda*
18:41:17 <Nereid> well, you could probably still do it more neatly than that in C++.
18:41:18 <Cale> In that C++ templates let you systematically construct lots of classes at compile time
18:41:25 <startling> sort of off-topic, but I'm scratching my head wrt reading "Figure 1" on the second page of this. Any help? http://strictlypositive.org/Easy.pdf
18:41:30 <Nereid> or other languages.
18:41:31 <Cale> and maybe sidestep some of the awkwardness of the fact that they're separate types
18:41:43 <Cale> (though they really are separate types still)
18:41:45 <Nereid> replace methods with function-valued fields or something
18:41:53 <startling> I get the ‚áì thing, I don't get what the horizontal bars mean.
18:42:20 <pordan30> speaking of oo-style programming in haskell, is it possible to model bounded quantification using type-class bounded polymorphism?
18:42:25 <ryanos> Cale: the templates + generics could be close to what u say... what's haskell advantage over that ?
18:42:41 <Cale> startling: read it as "if the conditions above the bar are true, then we can infer from them the consequences below the bar"
18:42:54 <Cale> ryanos: Well, I'm not even talking about generics
18:43:11 <daniel> hi I tried to install funGen on a win 7 (http://joyful.com/fungen/) but dont get it to work
18:43:11 <Cale> ryanos: I'm talking about the case where you have a bunch of classes with the exact same methods with the exact same types
18:43:22 <Cale> ryanos: except the method implementations are different
18:43:30 <ryanos> Cale: so you are talking about inheritance
18:43:36 <daniel> when i write cabal install FunGEn in cmd this error comes up
18:43:40 <ryanos> and polymorphic use?
18:43:49 <daniel> Resolving dependencies... Configuring FunGEn-0.3... Building FunGEn-0.3... Preprocessing library FunGEn-0.3...  Graphics\UI\Fungen.hs:1:1:     Ambiguous module name `Prelude':       it was found in multiple packages: base haskell98-2.0.0.1 cabal.exe: Error: some packages failed to install: FunGEn-0.3 failed during the building phase. The exception was: ExitFailure 1
18:44:04 * hackagebot plot-gtk 0.1.0.11 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.1.0.11 (VivianMcPhail)
18:44:04 <Cale> I'm talking about a problem which inheritance is sort of a bandage to try to slow the bleeding from.
18:44:07 <startling> Cale: so if something matches e ‚áì v, it evaluates to e :: œÑ ‚áì v ?
18:44:07 <daniel> any one know how to solve the problem?
18:44:36 <Cale> startling: If it is known that e evaluates to v, then it can be inferred that (e :: t) evaluates to v
18:44:59 <Cale> startling: That is, it's saying explicit type signatures don't affect evaluation.
18:45:06 <startling> Cale: ah. makes sense.
18:45:44 <ryanos> Cale: not sure i completely got u.. but don't want to generate too much traffic - and i see you are in demand here :)
18:46:07 <Cale> daniel: You'll have to mess around a bit... that package is probably old. The base and haskell98 packages have been mutually exclusive for a while now.
18:46:39 <ryanos> Cale: let me know when you are in the norcal and we can go for a beer to iron out all the vtable issues ;)
18:47:01 <Cale> ryanos: Well, let me provide an example of how you might do OO in this style in Haskell
18:47:01 <startling> Cale: thanks for your help, that clears things up considerably.
18:47:07 <Cale> startling: no problem :)
18:47:12 <Nereid> daniel: you might have better luck with the darcs version
18:47:18 <Nereid> which supposedly works on 7.4.1
18:47:30 <Cale> ryanos: Okay, so suppose we're making some game or animation thing, and we have a bunch of various objects of some types.
18:47:45 <ryanos> Cale: the "draw" method example ?
18:47:52 <ryanos> (for polymorphic call)
18:47:53 <Cale> yeah, have you seen this before?
18:48:15 <Cale> So, the first thing which might come to mind if you'd just read your first Haskell tutorial
18:48:20 <ryanos> Cale: everybody who did some oop in life seen that
18:48:29 <Cale> is to make a datatype with constructors for each type of objects
18:48:31 <Cale> -s
18:48:48 <Nereid> gross
18:48:56 <Cale> data Object = Ball Position Velocity Acceleration | SpaceShip ... | ...
18:49:02 <ryanos> Cale: actually i've just read my second haskell tutorial
18:49:04 <ryanos> :
18:49:07 <Nereid> lol
18:49:09 <ryanos> :)
18:49:29 <Cale> and then you'd have various functions which use pattern matching to scrutinise what type of object it is and handle each case
18:50:10 <ryanos> Cale: you read my mind.. that's as far as i could go after tutorial++
18:50:12 <Cale> The advantage of this approach is that it's easy to add new functions which act on the data -- you have all the information about what the data *is*, so extending it with new operations is easy.
18:50:25 <Cale> But for a game, this frequently sucks
18:50:33 <Cale> Because you know up front what your operations are going to be
18:50:43 <Cale> But you're going to want to add new types of objects to the environment
18:51:09 <Cale> i.e. you'll have at least something like
18:51:37 <Cale> step :: DeltaTime -> Object -> [Object] -- perhaps a list in order for things to split apart or die
18:51:57 <Cale> and   draw :: Object -> IO ()
18:52:03 <Cale> and maybe a few others
18:52:27 <Cale> But then what we could also do is just to say that an object is simply a specification of what these things are:
18:52:48 <Cale> data Object = O { step :: DeltaTime -> [Object], draw :: IO (), ... }
18:53:15 <Cale> note that each of the methods loses an Object argument, because the idea is that it's already applied to that argument
18:53:38 <Nereid> (and you end up with functions step :: Object -> DeltaTime -> [Object] and so on
18:53:48 <Nereid> deconstructors
18:53:49 <Cale> Now, what happens to the position/velocity/etc. arguments to Ball?
18:54:02 <Cale> Well, they turn into function parameters to the function which constructs balls.
18:54:27 <Cale> ball position velocity acceleration radius = O { .. } -- RecordWildCards syntax
18:54:29 <Nereid> question.
18:54:35 <Nereid> oops never mind.
18:55:10 <hpaste> Raisdead pasted ‚ÄúHaskell Platform Build Failure‚Äù at http://hpaste.org/76971
18:55:29 <Cale>   where step dt = ball (position ^+^ (dt *^ velocity) ^+^ (1/2 * dt^2) *^ acceleration) ...
18:55:54 <Cale>         draw = drawCircle position radius
18:55:58 <Cale> or whatever
18:56:16 <Cale> actually, that should have been a list in the result of step, but you get the idea
18:56:37 <Cale> ryanos: does that roughly make sense as a sketch of how things go?
18:56:41 <Raisdead> I am trying to install haskell-platform form the AUR and got http://hpaste.org/76971 as the error. If anyone could help me, I would appreciate it.
18:56:58 <Nereid> I wonder why it's building such an old version of OpenGL?
18:57:01 <Cale> ryanos: We can use recursion quite often in place of mutation, but if you want to use mutation and IORefs, that's possible too.
18:57:04 <ryanos> Cale: i think you are about 30,000 ft above me with haskell :)
18:57:27 <Cale> ryanos: and yeah, don't mind all the vector arithmetic physics-y stuff I wrote
18:57:33 <Cale> with the ^+^ and such
18:57:38 <ryanos> Cale:i'll need to read 5-6 more intros to understand that :)
18:57:53 <Nereid> that stuff is just from some VectorSpace class or something
18:57:53 <Cale> Well, okay, maybe I should use a little less syntax sugar
18:58:06 <ryanos> Cale: math/physics is my strong hat
18:58:12 <ryanos> haskell is what i'm digging into
18:58:23 <ocharles> jumping in with record wildcards and the vector package is quite a leap from a second tutorial :)
18:58:36 <Cale> O { .. }  just means O { step = step, draw = draw }, where the latter name is bound to whatever is in scope with that name
18:58:39 <ocharles> it's not rocket science, but it's more to juggle in your head when you only have limited hands
18:58:39 <ryanos> ocharles: you hear my pain :)
18:58:57 <Cale> ryanos: which lets us put the fields into the where clause
18:59:08 <Nereid> he could have written O { step dt = ..., draw = ... } but that's kind of unwieldy
18:59:23 <Cale> and I couldn't even write  O { step dt = ... }
18:59:27 <Cale> I'd have to use lambda
18:59:31 <Nereid> er yeah
18:59:33 <Cale> which is a silly syntactic point
18:59:52 <ryanos> Cale: i am good at understanding things top-down
18:59:55 <Cale> O { step = \dt -> ball ..., draw = ... }
19:00:03 <ryanos> so can you please explain top down what u r trying to say?
19:00:21 <ryanos> haskell code is not so enlightening for me (as i said i'm +2 tutorials)
19:00:36 <ryanos> but can understand v well oop/math/phys
19:00:47 <Cale> ryanos: The idea is that instead of using a data type with many cases for each type of object, and then defining a few functions which act on those cases
19:01:21 <Cale> ryanos: We define a data type with one case, whose fields are the results of those functions
19:02:16 <Cale> and then we construct our various objects of this latter data type by providing functions which accept any "internal" or "private" data as parameters, and produce from that a record of the "method implementations"
19:03:24 <Cale> and when you do this, you quickly start to realise that this is really what OO programming is, boiled down to its core, once you strip away all the stuff about subtyping and inheritance and all that
19:03:41 <Cale> You're defining your values in terms of how they behave in response to messages.
19:03:51 <ryanos> Cale: isn't that as a factory? :)
19:03:58 <ryanos> (a ooop factory)
19:04:15 <Cale> and yeah, you can also simultaneously think of this *kind* of like a factory
19:04:31 <ryanos> but it is more like a type factory
19:04:32 <Cale> though the factory itself needn't be an "object", it's just a single function
19:04:54 <Cale> and you don't need lots of extra boilerplate -- the factory is invisible
19:04:59 <gertc> "Enter `haskell-doc-mode' for showing fct types in the echo area." What are fct types?
19:05:16 <ryanos> Cale: like a class type ?
19:05:30 <rwbarton> gertc, I think it means "types of functions"
19:05:53 <Cale> ryanos: Our object type is kind of like a class, except that it doesn't say how the methods work, just what types they have.
19:06:02 <ryanos> (i meant type class)
19:06:06 <rwbarton> what it does is if your insertion point is over the word "foldr", it will show the type signature of foldr in the minibuffer
19:06:34 <Cale> ryanos: Well, I haven't even involved type classes yet. You can go even further with this idea using type classes and something called "existential types"
19:06:35 <gertc> ok thx
19:07:25 <Cale> ryanos: You define an interface with a type class, and then the existential gives you an easy way to make a data type which wraps up anything that implements that interface, and forgets which type it was originally.
19:07:43 <ivanm> gertc: I think that's meant to be function
19:08:02 <Cale> ryanos: Which is another approach to this, but I'm partial to just using good ol' functional programming where it will do the job well enough.
19:08:23 <Cale> ryanos: because in some sense, that puts you right back into the mistake that the OO languages all made
19:08:30 <gertc> ok thx
19:08:36 <Cale> you're only allowed one instance of a type class per data type
19:08:42 <ryanos> Cale: that's what i was gonna ask - it's almost like you invent a lot of complexity
19:08:51 <Cale> and so you end up making spurious data types just to implement the type classes in more ways
19:08:54 <ryanos> and is difficult for me to asses what are the tradeoffs
19:09:03 <Cale> while really all you need are records of the methods
19:09:04 <otters> how do you haddock-document stuff created by TH?
19:09:36 <ivanm> otters: add type sigs with haddock docs to your code and let TH just generate the body? *shrug*
19:09:57 <ryanos> Cale: i think you are a great teacher, unfortunately the student is not up to par :)
19:10:07 <otters> ivanm: well, I'm speaking of stuff created by Control.Lens here
19:10:09 <ryanos> Cale: i need to read more and will ping you again
19:10:31 <Cale> ryanos: I'm kicking myself right now because at one point I had a nice tutorial which explained this and fleshed out the examples a little better
19:10:38 <ivanm> otters: *shrug*
19:10:45 <otters> eh
19:10:48 <otters> no big deal
19:10:50 <ryanos> Cale: that would be a great one indeed..
19:11:14 <Cale> But it was on my old hard drive, and I don't have a working machine that can interface with it, and I'm not sure whether the drive itself is failing or what, because that machine doesn't boot.
19:11:39 <Cale> I should have put it on the Haskell wiki somewhere :)
19:11:49 <ryanos> Cale: if you are in physical distance i can help you - i have a "hd recovery" toolset
19:12:04 <Cale> I'm in Brantford, Ontario
19:12:07 <pordan30> fyi, there is a well-known paper by kiselyov & lammel on oo embeddings in haskell: http://homepages.cwi.nl/~ralf/OOHaskell/
19:12:08 <ryanos> (can read physically damaged stuff if required)
19:12:20 <ryanos> Cale: only 3000 miles.. :)
19:12:36 <Cale> That OOHaskell stuff goes *way* overboard compared to my picture of OO in Haskell
19:12:45 <ryanos> pordan30: thanks much, i was just trying to understand how oop compares with haskell
19:12:55 <shachaf> Type-level _ would be nice.
19:13:00 <Raisdead> I reinstalled libgl and freeglut (after updating the package list) and it still failed just like above
19:13:01 <Cale> I would propose that the real heart of OO can be accomplished with very very little in the way of fancy hackery with the type system.
19:13:45 <ryanos> Cale: i don't really need to reach oop nirvana in haskell.. just need to understand well how to transfer concepts from oop world into the haskell world
19:13:50 <Cale> They get into the whole problem of how to do subtyping and all that
19:14:09 <saml> [('a',3), ('b', 2)]  ==>  [('a', 1), ('a', 2), ('a', 3), ('b', 1), ('b', 2)]
19:14:18 <saml> do I use scanl for this type of thing?
19:14:32 <Cale> and subtyping is occasionally nice, but you'd be surprised how little you need it once you can switch out your method implementations without changing the type
19:14:55 <Cale> saml: A list comprehension can do that really nicely
19:15:36 <Cale> > let foo ps = [(x,y) | (x,n) <- ps, y <- [1..n]] in foo [('a',3), ('b',2)]
19:15:37 <lambdabot>   [('a',1),('a',2),('a',3),('b',1),('b',2)]
19:15:55 <pordan30> Cale: re: the real heart of oo-style programming can be accomplished without fancy types: i agree. however, it's a good discussion of the issues for the interested reader who is comfortable with the simple approach.
19:16:13 <Cale> right, I'd agree about that
19:17:24 <Cale> The OOHaskell paper is all about how closely we can model all the features in detail of these typed OO languages, even the ones which may or may not be a great idea in the first place. :)
19:17:31 <saml> Cale, thanks
19:18:29 <ryanos> Cale:/pordan30: i'm not looking at writing the next best oop progr, just translating the concepts from oop to fp
19:18:55 <shachaf> ryanos: You're best off not trying to do that.
19:19:00 <ryanos> Cale: thanks for your great input..
19:19:19 <ryanos> shachaf: ideally yes, IF you start fresh - is that what you are saying ?
19:19:35 <Cale> I've sort of come to the opinion that many of the features of typed OO which people fixate on, like inheritance in particular, are really only important because of the way in which method implementations are tied directly to the types.
19:20:11 <ryanos> Cale: nowadays (last 5 years) oop ppl are not that fixated on inheritance anymore
19:20:21 <Cale> ryanos: Well, you're not always going to get a well-designed Haskell program by translating a design which would have come naturally thinking from a hard-line OO perspective.
19:20:27 <ryanos> Cale: it is more "composition" than "inheritance"
19:20:37 <Cale> Yeah, they're all slowly coming to agree with me.
19:20:42 <Cale> :)
19:20:48 <ryanos> :)
19:21:21 <ryanos> Cale: agree on the translation part. not looking at designing haskell programs in oop-emulation mode
19:21:56 <ryanos> just try to understand how to best *convert* oop progrs into fp/haskell (large progrs)
19:21:58 <Cale> It is really good to know how to translate OO and even just plain imperative code into purely functional code in a variety of ways though.
19:22:03 <Cale> yeah
19:22:25 <ryanos> Cale: right. i feel that would help me
19:22:39 <rwbarton> certainly it is better to go "i want to use a class in Java" -> "perhaps I want a sum type of terms, or maybe a record of functions" rather than "i want to use a class in Java" -> "???????"
19:22:41 <Cale> One thing which I've occasionally done in the past in order to better understand an imperative program was to start out by translating it line-by-line into a horrible functional one in a mechanical way.
19:22:53 <pordan30> based on my experience seeing others come to haskell from oo-style languages, the feature missed most is structural subtyping over records / sum types, which i wouldn't consider a /bad/ idea
19:23:14 <Cale> and then simplifying the functional program using equational reasoning until I had a better grasp of what the imperative program was actually doing
19:23:41 <Cale> What you can do is to turn all the local mutable variables of an imperative program into function parameters, and turn each statement into a separate function.
19:23:53 <Cale> and have the functions call each other according to how the control flow works
19:24:03 <Cale> with the updated values of the local variables
19:24:28 <Cale> So you explicitly form loops by either passing control to statement 3 or statement 8 or whatever, depending on the loop condition.
19:24:48 <Cale> and that amounts to calling function 3 or function 8 with whatever parameters :)
19:25:16 <Cale> and you end up with some horrible mutual recursion, but it's usually something which simplifies down rapidly
19:26:05 <Cale> If that makes any sense
19:26:08 <ryanos> Cale: i'll digest that for tomorrow/breakfast :)
19:26:30 <ryanos> gtg now but thanks everybody for great input..
19:26:45 <Cale> (and normally, function n will call function n+1 because you run the statements in sequence)
19:26:53 <Cale> okay, see you!
19:27:12 <ryanos> see you too !
19:27:25 <ryanos> you guys are great, thanks all for awesome input !
19:28:35 <h4199> Is there a more general resource on methodologies for larger scale "translation" between paradigms?
19:30:48 <Cale> h4199: I should really write this up, because I don't know if I've seen it written down explicitly anywhere, this sort of mechanical way to translate from imperative to functional. You might say that it's like implementing an interpreter or compiler for an imperative language, which is true, but when you're doing it by hand, it's a little different.
19:31:09 <Cale> and once you see how to do it perfectly mechanically, you also tend to start to understand how to do it better, but less mechanically
19:35:12 <Raisdead> I am trying to install haskell-platform form the AUR and got http://hpaste.org/76971 as the error, I have tried to reinstall libgl and freeglut. If anyone could help me, I would appreciate it.
19:35:19 <h4199> hmm, that is what I was thinking too, a complex interpretation process, but it seems like a task that a human is best suited to. Understanding intent and other facets of the program. Still a general writeup on how to build proficiency is something that I would love to read.
19:35:44 <JoeyA> The GHC download page says: "should work for Microsoft Windows 2000 or later"  Has anyone actually tried it on Windows 2000?
19:35:57 <h4199> Isn't AUR for HP outdated?
19:37:44 <JoeyA> One time I tried to run GHC 6.6 (I think) on Windows 95, and when I tried to run ghci, it was missing a system call that was introduced in Windows XP.
19:38:22 <Raisdead> AUR has haskell-platform 2012.2.0.0-3 and downloads from http://lambda.haskell.org/platform/download/2012.2.0.0/haskell-platform-2012.2.0.0.tar.gz That looks like the latest to me
19:38:40 <JoeyA> A more constructive question: would anyone whine if the next version of GHC drops support for Windows 2000?
19:42:03 <shachaf> JoeyA: As long as it still works on 98 I don't mind.
19:42:36 <JoeyA> shachaf: Is that a joke, or do you mean it?
19:43:41 <dolio> Does GHC support Windows 2000?
19:43:56 <JoeyA> The download page says it does: http://www.haskell.org/ghc/download_ghc_7_6_1
19:44:09 <JoeyA> I'm wondering if it actually does.
19:44:14 <shachaf> JoeyA: I don't mean it.
19:51:52 <beaky> :t (&&&)
19:51:54 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:52:22 <beaky> > ((\x -> x - 1) &&& (+1)) 1
19:52:24 <lambdabot>   (0,2)
19:53:43 <h4199> Raisedead: https://aur.archlinux.org/packages.php?ID=56992 You are not the only one with the problem, no good solution there though.
19:59:03 <Raisdead> h4199: I just found that myself. I was hoping that someone here would have an idea on how to start to debug the problem in an attempt to help the maintainer
19:59:59 <shachaf> Raisdead: There's a channel for Arch and Haskell.
20:01:14 <Raisdead> shachaf: That I did not know. Thanks, I''ll try #arch-haskell
20:18:26 <scooty-puff> is there any difference between:
20:18:36 <scooty-puff> (\ ~(a, b) -> b) x
20:18:41 <scooty-puff> and snd x
20:19:26 <rwbarton> no
20:19:50 <scooty-puff> k
20:19:55 <Jafet> Nice pattern
20:21:12 <Nereid> @src snd
20:21:12 <lambdabot> snd (_,y) =  y
20:28:51 <mm_freak> scooty-puff: newtype patterns are always irrefutable
20:30:11 <mm_freak> scooty-puff: but there may be an operational difference, if it should ever happen that your compiler doesn't recognize your lambda as a supercombinator
20:44:44 <tac> Are there any solutions to GHCI freezing on you in windows?
20:44:57 <tac> as far as I can tell, it forces you to kill the whole damn console :(
20:45:41 <pordan30> is this a bug of some sort, or am i missing something? <http://hpaste.org/76972>
20:46:49 <tac> pordan30: looks like a scary function def :[
20:47:13 <geekosaur> I think that's right; TokenParser is a constructor which takes a bunch of token parsers, it's not really intended for direct use
20:47:23 <rwbarton> constructor for a record type with lots of fields
20:48:38 <geekosaur> Text.Parsec.Language has a bunch of predefined parsers which are likely to be more appropriate starting points
20:50:37 <pordan30> i see: so one should always construct such values using the predefined makeX functions
20:50:45 <geekosaur> probably
20:53:16 <JoeyA> tac: Can you elaborate?  What causes it to freeze?
20:53:47 <tac> JoeyA: I wrote a parsec parser which had a loop in it
20:53:57 <tac> I evaluated a term and it froze
20:56:07 <JoeyA> Are you running it in GHCi, or did you compile it?
20:56:20 <tac> ghci
20:56:45 <JoeyA> Is it an infinite loop that spins the CPU?
20:57:18 <tac> It's just a parser which has a loop in it
20:57:29 <JoeyA> If so, it might be one of those dreaded non-allocating loops: http://hackage.haskell.org/trac/ghc/ticket/5784
20:57:36 <JoeyA> But that seems unlikely for non-optimized code.
20:57:42 <tac> p1 = p2 <|> other stuff; p2 = p1 <|> ...
21:10:13 <tac> How do I turn off the monomorphism restriction from inside a file?
21:10:32 <JoeyA> {-# LANGUAGE NoMonomorphismRestriction #-}
21:10:34 <tac> is it {-# -XNoMonomorphismRestriction #-} or something?
21:10:36 <tac> ah
21:10:37 <tac> thank you
21:11:00 <tac> Those kinds of things are always hard to find answers to on google
21:15:08 <ivanm> @google enable haskell pragma per-module
21:15:09 <lambdabot> http://stackoverflow.com/questions/8638035/xtypeoperators-extension-doesnt-work-as-pragma
21:15:09 <lambdabot> Title: haskell - XTypeOperators extension doesn't work as pragma - Stack Overflow
21:15:19 <ivanm> hmmmm
21:21:13 <tac> allright folks
21:21:18 <tac> JoeyA: thanks for the help
21:21:21 <tac> later all
21:21:24 <JoeyA> Later
21:23:20 <statusfailed> Hmm, i want to read pcap files with Haskell to get HTTP data, but I don't particularly want to reassemble TCP packets, does there exist stuff to do this for me?
21:24:13 <ivanm> I think I've seen a pcap package on hackage
21:24:15 <ivanm> have you checked?
21:24:39 <statusfailed> Yeah, Network.Pcap, but it's just a libpcap wrapper, won't do reassembly
21:25:09 <statusfailed> Scapy (python) looks like it might be what I want, but I prefer using haskell :P
21:29:07 * hackagebot timeplot 1.0.15 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.15 (EugeneKirpichov)
21:34:07 * hackagebot splot 0.3.5 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.3.5 (EugeneKirpichov)
21:54:07 * hackagebot tls 1.0.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.0.1 (VincentHanquez)
21:54:28 <lispy> hello
21:56:31 <mzero> yo
21:56:31 <lambdabot> mzero: You have 1 new message. '/msg lambdabot @messages' to read it.
21:58:37 <csigusz> hei
21:59:11 <mzero> yo
21:59:54 <shachaf> hi lispy
22:10:23 <synonymous> is it possible to build just one executable in the cabal file which has several?
22:10:38 <statusfailed> has several what?
22:10:50 <synonymous> executables (targets)
22:11:11 <statusfailed> oh I see, you mean one executable section with multiple resulting binary files?
22:12:06 <synonymous> well, i have several `Executable' sections each building an binary
22:15:29 <ivanm> synonymous: unless you have different flags, each of which enables/disables each possible Executable stanza, no
22:16:36 <synonymous> thanks, no worries
22:19:08 * hackagebot plat 0.1.0.0 - Simple templating library  http://hackage.haskell.org/package/plat-0.1.0.0 (MiguelMitrofanov)
22:23:24 <ivanm> for some reason I can load my FFI-based file into ghci
22:23:41 <ivanm> but as soon as I try and compile it with ghc, I get all these "multiple definition of" errors :s
22:25:15 <ivanm> and all the errors seem to be about the _Haskell_ side :s
22:27:54 <Nereid> synonymous: so maybe that's a hint to use flags
22:38:38 <fruitFly> what do you use haskell for?
22:38:49 <fruitFly> is haskell just the sheezy?
22:39:38 <Jafet> @protontorpedo
22:39:38 <lambdabot> check otu squeak seems dope
22:39:54 <synonymous> Nereid, oh yes i took note of this method
22:40:07 <Nereid> :p
22:41:42 <frx> sorry for a newbie question but is there an equivalent of following that will automatically declare Eq function? data Suit = Spade | Club | Heart | Diamond
22:41:58 <Ralith> newbie questions are fine!
22:42:13 <Ralith> just add "deriving (Eq)" to the end of that.
22:42:22 <frx> ok thanks!
22:42:26 <frx> that was simple
22:42:44 <Ralith> contrary to its reputatoin, haskell usually turns out to be!
22:42:52 <Ralith> are you following a tutorial?
22:48:15 * ivanm facepalms
22:48:28 <ivanm> having your haskell source file and C source file have the same base name is a really stupid idea...
22:48:41 <frx> I skimmed through http://www.haskell.org/tutorial/ , and I'm reading some code etc. I will go through entire tutorial when I find the time
22:49:51 <donri> @where lyah
22:49:51 <lambdabot> http://www.learnyouahaskell.com/
22:49:59 <Ralith> frx: ^
22:50:46 <ivanm> @where tryhaskell
22:50:46 <lambdabot> http://tryhaskell.org/
22:50:49 <ivanm> @where yaht
22:50:50 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III,<http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://hal3.name/docs/daume02yaht.p(df|s)>,<http://darcs.haskell.org/
22:50:50 <lambdabot> yaht/yaht.p(df|s)>
22:50:56 <ivanm> @where wikibook
22:50:56 <lambdabot> http://en.wikibooks.org/wiki/Haskell
22:51:25 <donri> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#derived-instances
22:51:31 <mauke> @where carmen sandiego
22:51:31 <lambdabot> I know nothing about carmen.
22:52:23 <ivanm> @where wally
22:52:23 <lambdabot> I know nothing about wally.
22:53:04 <Nereid> @where waldo
22:53:04 <lambdabot> http://planet.haskell.org
22:53:18 <Nereid> eh
22:53:28 <ivanm> :o
22:57:30 <donri> @hoogle waldo
22:57:30 <lambdabot> No results found
22:58:50 <ivanm> lispy: it seems that my FFI corruption issues only stop occuring when I compile _with_ optimisations :s
22:59:37 <mauke> ah, the old trade-off between speed and incorrectness
22:59:42 <ivanm> heh
22:59:55 <ivanm> mauke: well, when you're trying to use ghci to see if your code works...
23:00:59 <donri> see also: occurs check
23:03:15 <ivanm> dammit, the version of containers that ships with ghc 7.4.2 doesn't have an NFData instance
23:07:03 <ivanm> lispy: or not; it just happened in my criterion run *sighs*
23:10:40 <pordan30> are there any libraries with standard prelude functions, e.g.: indexing functions, parameterised by integral or (more generally) linear recursive types?
23:10:56 <ivanm> well, Data.List has several generic* functions
23:13:22 <Nereid> that yaht is pretty outdated
23:14:37 <pordan30> ivanm: i didn't realize that, thanks.
23:14:57 <ivanm> np
23:18:55 <Nereid> then again, I think yaht was like the first thing on haskell I ever read.
23:19:13 <Nereid> I don't remember, though. it was ages ago.
23:19:23 <Nereid> and then I was confused and I didn't touch haskell for a while.
23:21:48 <startling> am I using quickcheck incorrectly? I keep writing a "smaller m = sized $ \i -> resize (i `div` 2) m" whenever I want a Gen for a recursive data structure.
23:22:31 <startling> and then arbitrary = oneof [ Single <$> arbitrary, Recursive <$> smaller arbitrary ]
23:26:09 <Zoxc> How does Haskell do type inference for mutually recursive functions? Does the compiler detect these cases and process them simultaneously?
23:26:24 <Ralith> yep.
23:26:47 <Ralith> at least, that is one way to do it; there may be others.
23:26:55 <shachaf> Not so for polymorphic recursion, unfortunately. :-(
23:26:58 * Ralith isn't sure which way the latest version of ghc uses.
23:27:03 <startling> Zoxc, it lets the universe choose a stable time loop.
23:29:52 <startling> Zoxc: on a more serious note: note that the x = x and similar things get to be whatever type they like, so the compiler doesn't worry about those.
23:30:21 <startling> so x = y and y = x always typecheck successfully
23:34:06 <lispy> ivanm: if changing compiler optimization flags changes the behavior, it's usually that's more or less subtle with one setting. It's rare that one setting makes it go away completely.
23:34:15 <lispy> ivanm: at least, that's been my experience
23:34:17 * lispy goes to bed
23:39:03 <signalsea> hi. is there something like ($) that implies parentheses around the whole expression to the left
23:39:15 <signalsea> ?
23:40:12 <nomadmonad> which would be good books or tutorials to go through to understand how to _use_ more complex data structures within Haskell?
23:40:24 <mauke> @where okasaki
23:40:25 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
23:40:33 <shachaf> Using complex data structures isn't necessarily complex. :-)
23:41:03 <Cale> nomadmonad: well, what do you mean by "more complex" -- what are you currently using?
23:41:37 <Cale> After lists and basic stuff like that, Map and Set are pretty important, but easy to pick up from the haddock documentation.
23:43:45 <Jafet> signalsea: f ‚Ç¨ x = f x; infixl 0 ‚Ç¨
23:43:46 <nomadmonad> oh, I checked Okasaki briefly last time around and it's nice. Back then I needed priority queues and for some reason ended up with Scala, for which I found a library or two but with bugs and eventually used some other language
23:45:05 <Nereid> haha ‚Ç¨
23:45:12 <Nereid> > generalCategory '‚Ç¨'
23:45:13 <lambdabot>   CurrencySymbol
23:45:30 <startling> nomadmonad, well, you find a nice abstraction like Monad or Comonad to apply to your complex data structure and go for it
23:46:45 <nomadmonad> with more Complex I mean normal CS structures, nothing fancy. Useful trees, queues, hashes, bigger than memory structures with reasonable caching in main mem and some reasonable deterministic behavior to predict how big part fits constantly in the mem,  all that get updated and other normal mutable datastructure features.
23:47:09 <Jafet> You want to implement them in haskell?
23:47:32 <startling> nomadmonad: are you really asking "how do I have mutable data structures in haskell?"
23:48:00 <nomadmonad> Jafet, nope, I prefer to leave that for experts. Instead I'd love to _use_ them, to make Haskell useful for me, for normal, simple problems I encounter.
23:48:21 <Jafet> Then download them from hackage and use them.
23:48:31 <nomadmonad> startling: I'm really asking "which would be good books or tutorials" for me to read to understand how to use
23:49:10 * hackagebot diet 0.0.1 - Discrete Interval Encoding Tree  http://hackage.haskell.org/package/diet-0.0.1 (TonyMorris)
23:50:04 <startling> nomadmonad, do you have a specific thing you want to use?
23:50:09 <Jafet> Most practical problems can be solved with lists; most of the remaining problems can be solved with Map, Set, ByteString and Vector. Otherwise look for a data structure on hackage.
23:50:13 <nomadmonad> for example Wikibooks for Haskell has Other data structures chapter a bit about Mapping and Folding, but Haskell Performance / Data structures is empty. Yeah, and from the outset, I'm not sure if that is a good resource or awful one.
23:50:29 <nomadmonad> Jafet: thanks!
23:51:10 <signalsea> thanks Jafet. alternately, is there there an existing prelude function  f a b = (b a),  the b argument being a function?
23:51:24 <Nereid> flip id
23:51:30 <Nereid> = flip ($)
23:51:34 <Jafet> :t (<<<)
23:51:35 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
23:51:42 <Jafet> Wait no
23:51:51 <shachaf> signalsea: Often you write that as ($ x)
23:55:21 <nomadmonad> startling: they come and go. Few days ago it was a simple problem of finding (partially matching) elements from two lists. The elements were strings and for "matching" there could be multiple distance functions to be used. To make it fast enough, I'd calculated distances of often found strings in a (weak) hash which size was LFU bound to 1 GB.
23:56:30 <nomadmonad> now I'm after something easy reading to "let me in using Haskell in real world settings" instead of toying with simple functions or complex abstractions over no real data
23:56:49 <startling> nomadmonad, well, maybe write a real-world program. :)
23:59:00 <nomadmonad> Data.Edison, for example, isn't easy enough for me to fathom from source or accompanying docs
