00:00:10 <Nereid> if your working directory is /foo/bar, then baz refers to /foo/bar/baz, while / refers to the root /
00:00:28 <Cale> strebe: let me know once you've caught up, or if anything doesn't make sense
00:00:37 <strebe> <Cale> So a natural transformation eta: F -> G assigns to each object X in C, some arrow eta_X: FX -> GX in D <-- what are the types of F and X? Both functors?
00:00:47 <Cale> X is an object in C
00:00:52 <Cale> F is a functor C -> D
00:00:53 <Nereid> F and G are functors from C to D
00:00:55 <Palmik> Cale, whal lemma/theorem are you explaining?
00:01:02 <Nereid> Palmik: definition of natural transformation
00:01:05 <Cale> Palmik: I am explaining the definition of a natural transformation
00:01:14 <Palmik> OK.
00:01:29 <Nereid> I should figure out kan extensions at some point
00:01:33 <Nereid> I'm sure I've seen a bunch already.
00:01:51 <Palmik> I think there is a nice explanaition in terms of haskell somewhere.
00:01:59 <Palmik> I have just recently stumbled on the article.
00:02:03 <Nereid> sure but more generally than haskell.
00:02:22 <Palmik> (I meand about the nat. tr.)
00:02:29 <Nereid> ah.
00:02:44 <Palmik> http://lukepalmer.wordpress.com/2008/04/28/whats-a-natural-transformation/
00:02:44 <Nereid> aren't derived functors kan extensions or osmething?
00:02:45 <Cale> Well, there are probably lots, I've even written one
00:03:16 <Palmik> Cale, care to share? :)
00:03:30 <Cale> http://analogical-engine.com/wordpress/?p=20 -- wordpress seems to have decided to mangle things a bit since I wrote it
00:03:40 <Cale> but it's still mostly readable
00:03:54 <Palmik> Thanks. :)
00:03:54 <strebe> Cale: ahh, so C and D are just any categories, rather than specifically categories where the objects are functors, and hence X can be whatever that category happens to contain, rather than necessarily a functor?
00:04:03 <Nereid> yes
00:04:06 <Cale> yes
00:04:15 <Nereid> oops, I'm not Cale.
00:04:20 <strebe> Ahh, ok, I'll reread with that in mind.
00:04:49 <Cale> strebe: In the end, we'll be able to form a category of all functors C -> D, whose arrows will be natural transformations
00:04:59 <strebe> yes
00:05:04 <Nereid> and objects are functors
00:05:57 <Nereid> I think it helps to have lots of examples of categories. but most of the ones I have in mind come from math I guess.
00:06:31 <strebe> Nereid: likely. Mine are pretty much all set-based, as I don't know much group or graph theory
00:06:56 <Nereid> the category of vector spaces over some field is nice.
00:07:14 <strebe> sadly, I don't even know that
00:07:34 <Cale> The category corresponding to a preorder and the category corresponding to a monoid are both good examples
00:07:45 <Cale> (and Awodey covers those near the beginning)
00:07:51 <Nereid> ok, sure.
00:08:21 <Cale> and even if you've never heard the words preorder or monoid before, you can start to think of examples of those :)
00:08:37 <Nereid> :)
00:08:54 <strebe> Yes, I've read those two, and think I'm starting to understand them (I ended up digging out "Conceptual mathematics" for the monoid one, since I wasn't quite understanding what the object should be, and that made it concrete with an example of *, and arrows that I'm thinking of like the Haskell functions (3*) and so forth
00:09:23 <Cale> strebe: well, the object isn't anything in particular in that category
00:09:42 <strebe> yes, but seeing one that it could be brushed aside some previous confusion
00:09:48 <Cale> strebe: The objects of a category only exist in order to tell you which arrows you're allowed to compose
00:10:15 <Nereid> in fact one can define categories by only mentioning arrows.
00:10:30 <Cale> and the arrows themselves are in some sense only there to provide composition something to operate on :)
00:10:32 <Nereid> although I wouldn't do it.
00:10:38 <Nereid> it's not as pretty.
00:10:46 <Nereid> cool exercise:
00:10:50 <Nereid> say you have monoids M and N.
00:11:03 <Nereid> let BM and BN be the corresponding one-object categories.
00:11:10 <strebe> Cale: makes sense. I was thinking of objects beforehand, and was running into trouble by trying to imagine the trivial object of a monoid as an integer
00:11:42 <Nereid> so, monoid homomorphisms M -> N correspond to functors BM -> BN. (I guess this is a decent exercise by itself)
00:11:43 <Nereid> now
00:11:56 <Cale> strebe: There's also the category of all monoids, with monoid homomorphisms as the arrows between them, but that's quite different.
00:11:56 <Nereid> say you have two functors BM -> BN.
00:12:12 <Nereid> what is a natural transformation between them, in terms of monoids?
00:12:37 <cornihilio> a word32 is 4 bytes, right?
00:12:39 <Nereid> yes
00:12:41 <strebe> Nereid: you're saying a lot of cool stuff, and I hope I can understand it next week, but I'm trying to bootstrap the stuff it's built on and so it's rather difficult to follow; it's kind of like posing exercises in 3-digit multiplication to someone who's trying to learn 1-digit addition
00:12:59 <Nereid> strebe: yes, feel free to think about what I say at your own convenience.
00:13:05 <strebe> aka it should be easy, but it's not going to make any sense yet :-)
00:13:09 <strebe> shall do
00:13:15 <Ralith> cornihilio: wordN is N bits, a byte is 8 bits
00:13:26 <Nereid> lots of things in category theory are pretty trivial.
00:13:27 <Nereid> yet useful.
00:13:57 <Nereid> the Yoneda lemma has a trivial proof but its meaning is pretty significant.
00:14:05 <Nereid> (for example)
00:16:29 <Cale> strebe: okay, so back to what I was saying, does it make sense?
00:16:35 <Cale> strebe: Maybe I should repeat it
00:16:43 <strebe> I was just rereading it :-)
00:17:22 <strebe> <Cale> So a natural transformation eta: F -> G assigns to each object X in C, some arrow eta_X: FX -> GX in D
00:17:53 <Cale> We have two categories C and D, and two functors F and G from C to D. We're thinking of each functor as providing a (perhaps somewhat distorted or squished) picture of the category C inside of the category D, and we're trying to say what it might mean for there to be a connection from the picture which F gives to the picture which G gives
00:18:28 <strebe> how distorted or squished can it be?
00:18:39 <cornihilio> Ralith: thanks!
00:18:45 <strebe> (I think this would be easier if I understood functors fully)
00:19:03 <Cale> Pretty much arbitrarily so. In fact, there's always the functor which sends every object of C to some particular object of D, and all the arrows to the identity arrow on that object.
00:19:08 <Cale> (the constant functor)
00:19:19 <strebe> Ok; I was wondering if that was the case. That clears things up a bit :-)
00:19:26 <Cale> That exists so long as D has an object
00:19:35 <Nereid> and you get one for each object of D.
00:19:39 <strebe> so there can be no functors to empty categories?
00:19:46 <strebe> (except perhaps from empty categories?)
00:19:48 <Nereid> strebe: unless the source category is also empty
00:19:49 <Nereid> yeah
00:19:57 <strebe> ok, clear
00:20:03 <Nereid> anyway
00:20:23 <Cale> Okay, so our eta_X is providing a path in D from FX to GX
00:20:48 <Nereid> I find it hard to think of functors F: C -> D as "pictures" of C in D when C is some "big" category.
00:20:51 <strebe> by 'path', you mean an arrow between FX and GX?
00:20:57 <Nereid> usually C would be like
00:20:57 <Cale> yes
00:21:05 <Cale> eta_X *is* an arrow FX -> GX
00:21:19 <Nereid> *, or * -> *, or the infinite category * -> * -> * -> ...
00:21:27 <Nereid> or * <- * -> *, or ...
00:21:28 <Cale> Nereid: I like to think of categories as essentially topological things
00:21:32 <strebe> ok, I think natural transformations suddenly make sense
00:21:49 <cornihilio> how would I print the hex value of a word32?
00:21:51 <Nereid> Cale: ok, the simplex category too
00:21:51 <Cale> Natural transformations are secretly homotopies :)
00:22:02 * strebe wikipedias homotopie
00:22:08 <Cale> homotopy*
00:22:30 <Cale> but really, if you don't know what that is, I'm basically trying to get the idea across here
00:22:50 <Nereid> strebe: it's a topological thing, so don't worry about it too much
00:22:58 <Cale> right
00:23:03 <strebe> Nereid: yeah, was just glancing at what the idea was :-)
00:23:07 <Nereid> :)
00:23:38 <Cale> So, these mappings eta_X from FX to GX would hardly be a connection between pictures of C if they had nothing to do with the arrows of C, right?
00:23:50 <Cale> So we need something more
00:24:02 <strebe> well, in the trivial case where you're squishing things extremely they would be, but I see your point in the general case
00:24:05 <Cale> For each arrow a: X -> Y in C
00:24:27 <Cale> we have corresponding arrows: Fa: FX -> FY, and  Ga: GX -> GY
00:24:32 <Cale> (those are in D)
00:24:37 <strebe> (yes)
00:25:02 <Cale> and we want the maps given by eta to somehow connect these
00:25:08 <Cale> we have eta_X: FX -> GX
00:25:13 <Cale> and eta_Y: FY -> GY
00:25:17 <Nereid> so
00:25:24 <Cale> so you can draw those and form a square
00:25:36 <Cale> whose corners are FX, FY, GX, and GY
00:26:10 <Cale> and there are two paths from FX to GY in that square -- we can take one pair of sides or the other
00:26:32 <Cale> and the thing we want in order for this to really be a natural transformation is for those to be equal
00:26:37 <strebe> basically, following the arrow in C and then applying the functor, or applying the functor and then following the arrow in D?
00:26:45 <Nereid> yes
00:26:47 <Nereid> er
00:26:50 <Nereid> no
00:26:55 <Nereid> all of the arrows are in D.
00:26:56 <strebe> and arriving at the same place regardless of which of the two you pick
00:27:21 <Cale> eta_Y . Fa = Ga . eta_X
00:27:38 <Nereid> in other words
00:27:43 <strebe> Nereid: I mean for one particular input; then it generalizes back out to all the inputs in C. And all the arrows I'd want to look at as the second line of the square are in D, yes
00:27:50 <Nereid> the two paths you get by FX -> FY -> GY and FX -> GX -> GY compose to the same thing.
00:27:52 <Cale> http://analogical-engine.com/wordpress/wp-content/cache/tex_62499e3c609ba117a6f42a3f21d6cbc0.png
00:28:05 <strebe> Nereid: yes
00:28:11 <JL_> hi guys, I am a newbie to haskell, would like to ask how do I get the first list element from a lists of list. I need something like the head :: [[a]] -> [a]
00:28:14 <Cale> strebe: see that picture ^^
00:28:27 <Nereid> JL_: the first list in the list of lists? head.
00:28:28 <Cale> JL_: there is head
00:28:41 <JL_> list of lists *
00:28:43 <Cale> JL_: but you should usually be pattern matching
00:28:51 <strebe> cale: yep, that's basically my mental image at this point :-)
00:28:51 <Cale> > head [[1,2,3],[4,5],[6,7,8]]
00:28:53 <lambdabot>   [1,2,3]
00:28:54 <Nereid> yeah, hed is unsafe.
00:28:56 <Nereid> head*
00:28:58 <Cale> > head []
00:29:00 <lambdabot>   *Exception: Prelude.head: empty list
00:29:04 <merijn> JL_: There's no difference between a list of X and a list of list of X
00:29:11 <Nereid> merijn: ???
00:29:16 <merijn> (At least not from the list perception)
00:29:27 <Nereid> are your two Xes different
00:29:28 <Cale> ^^ If you use head a lot, you will learn to hate the message "*Exception: Prelude.head: empty list"
00:29:31 <merijn> Nereid: I meant that lists in lists don't do anything magical that break things
00:30:01 <JL_> oh darn
00:30:04 <merijn> Nereid: But maybe that was a confusing way to try and say that
00:30:15 <Nereid> indeed
00:30:23 <JL_> i kept trying head [[1,2],3] , no wonder it didn't work
00:30:26 <Nereid> oops
00:30:32 <merijn> JL_: xD
00:30:59 <JL_> thanks anyway
00:31:02 <strebe> merijn: well, it's clear that you mean that [b] is a valid a for [a], but it could also be read as [[x]] == [x], which would be a bit odd
00:31:28 <cornihilio> how would I print the hex value of a word32?
00:31:32 <Cale> strebe: okay, so in the topological viewpoint (which you don't really have to take very seriously for now), you can think of the square commuting as meaning like that there's some sort of "sheet" in that square across which we can deform one pair of arrows into the other.
00:32:15 <strebe> Cale: hmm. Go on, I'll figure out whether or not that makes sense by what you say next
00:33:12 <Cale> i.e. if there was a "hole" there, we might not be able to continuously bend one path to the other without leaving the surface of this geometric object :)
00:33:20 <strebe> (I'm fairly sure I understand the deforming pairs of arrows, but the concept of a sheet is a bit odd; I've been thinking of the edges of the square)
00:33:23 <strebe> ahhh, hmm
00:34:04 <Nereid> well the topological picture comes in like this:
00:34:11 <Nereid> if you have two arrows f: A -> B and g: B -> C
00:34:18 <Nereid> you get a composite gf: A -> C
00:34:40 <Nereid> well the arrows form the edges of a triangle
00:34:49 <Nereid> and the act of composing "fills in" the triangle I guess
00:34:58 <strebe> Nereid: ok
00:35:03 <Cale> well, the equation does
00:35:10 <Nereid> well whatever
00:35:17 <Cale> you can imagine a more generalised thing than an equation fitting in there, perhaps
00:35:33 <Nereid> no, I stand by what I said.
00:35:40 <Cale> and in fact, that's EXACTLY THE SORT OF THING WE'VE BEEN DOING TO OUR CATEGORY OF CATEGORIES :)
00:35:56 <Cale> Let's look at our category of categories now
00:36:09 <Cale> We have zero-dimensional objects, which are themselves categories
00:36:14 <Nereid> anyway, this generalizes to let you get a geometric object out of any category, called its nerve
00:36:22 <Cale> We have 1-dimensional arrows between them, those are functors
00:36:25 <Nereid> but let's not digress too far
00:36:26 <strebe> Cale: what would a hole be, exactly?
00:37:02 <Cale> and now we have natural transformations between the functors, which you can think of as 2-dimensional, but directed, sheets connecting the arrows
00:37:19 <strebe> ahh
00:37:43 <Cale> (you can also think of them as just other arrows between the arrows, but the geometric picture is prettier, maybe)
00:38:03 <Nereid> you can only move one way along the sheet though
00:38:06 <Cale> right
00:38:15 <Nereid> I guess that's why you said directed.
00:38:18 <Cale> equations you can freely move across in both directions
00:39:20 <Nereid> don't confuse this picture of a natural transformation as a 2-cell in Cat with the picture of uh
00:39:24 <Nereid> sheets connecting pictures of C in D.
00:39:45 <Cale> yeah, there *is* something similar going on, but it's not exactly the same thing
00:39:46 <Nereid> one is in Cat, and the other is in D.
00:39:51 <strebe> Nereid: ehm, what's a cell in this context?
00:40:01 <Nereid> I just mean that sheet thing.
00:40:05 <Cale> strebe: a 2-cell is a generic 2-dimensional thingy
00:40:25 <Cale> A disc, up to deformation
00:40:52 * strebe wonders if this would be a lot easier with a background in topology
00:40:55 <Cale> We say "n-cell" for an n-dimensional sort of blob
00:41:03 <strebe> hmm, ok
00:41:08 <Nereid> strebe: well it's all just pictures at this point.
00:41:13 <Cale> Well, it's not super important that you get the topological stuff at this point, yeah
00:41:20 <Cale> You can understand everything without that.
00:41:23 <Nereid> mhm
00:41:38 <Nereid> topology is cool though
00:41:39 <Cale> But it's just a nice picture to have in your head, perhaps helping to remember how it all goes
00:42:19 <strebe> sorry, which of the pictures? the directed square with two paths from FX to GY?
00:42:33 <Nereid> all of the pictures. I dunno.
00:42:43 <Nereid> that square isn't directed, btw.
00:42:48 <Cale> strebe: that particular diagram, without discussing the 2-dimensional sheet, you should really strive to understand
00:43:01 <Cale> (he means the edges are directed)
00:43:05 <Nereid> oh, ok.
00:43:09 <strebe> http://analogical-engine.com/wordpress/wp-content/cache/tex_62499e3c609ba117a6f42a3f21d6cbc0.png <-- isn't it? But functors aren't necessarily invertible
00:43:22 <strebe> s/(/(s/
00:43:27 <Nereid> yeah I thought you were talking about the filled-in part being directed.
00:43:28 <Nereid> so never mind.
00:44:24 <Cale> Really all that is being said here is that η_Y . Fa = Ga . η_X
00:44:32 <Cale> i.e. taking either path around the square is the same
00:44:35 <strebe> Cale: that diagram makes sense, as does that equation
00:44:53 <strebe> it's the concept of a sheet that's still eluding me
00:44:59 <Nereid> don't worry about it.
00:45:11 <strebe> hm, ok. I shan't for now
00:46:22 <strebe> Cale, Nereid: thank you. I guess I'll check out the Catster videos now and see whether they make sense :-)
00:46:34 <Cale> But since the original category theorists were all topologists and topologists like to talk about things being the same up to continuous deformations, there's this idea that the square is somehow filled in with space, and isn't a vacuum, so that you can move the "rope" which goes along one pair of edges to the other pair
00:46:37 <Nereid> what's a catster?
00:46:45 <Cale> http://www.youtube.com/watch?v=FZSUwqWjHCU
00:46:45 <Nereid> Cale: I thought Mac Lane was an algebraist.
00:47:14 <strebe> Cale: ahhh
00:47:16 <Nereid> "Saunders Mac Lane (...) was an American mathematician who cofounded category theory with Samuel Eilenberg."
00:47:36 <Nereid> is it bad that I stopped for a second at the word "cofounded"
00:47:37 <Cale> Nereid: After introducing, via the Eilenberg-Steenrod axioms, the abstract approach to homology theory, he and Eilenberg originated category theory in 1945.
00:48:10 <Cale> (of course, abstract homology has no shortage of algebraic interpretations)
00:48:24 <Nereid> Cale: I thought the Eilenberg-Steenrod axioms were introduced by Eilenberg and Steenrod.
00:49:12 <Cale> I'm pretty sure that's to be read as saying that he generalised them to a more abstract setting
00:49:27 <Nereid> oops I missed the word "via"
00:49:36 <strebe> ahh. remembering the morphism is a synonym for arrow would have made things a bit easier
00:49:43 <Nereid> "abstract approach to homology theory" sounds like homological algbera.
00:49:45 <Cale> So he was stealing the work that the topologists were doing and applying it to algebra
00:49:52 <Nereid> yes.
00:50:03 <Nereid> strebe: I tend to say "morphism" more often myself.
00:50:20 <Nereid> Cale: so he was an algebraist, as I said.
00:50:21 <Nereid> :p
00:50:43 <strebe> Nereid: in the sea of swirling new definitions, it had slipped my mind, but I looked it up as it keeps popping up every 5 seconds (including in the first 10 seconds of the video Cale linked to)
00:51:00 <Nereid> well, primarily. one shouldn't put someone in a box.
00:53:24 <Cale> Nereid: Perhaps the topology is somehow in a negative position with respect to his work, so he was some sort of algebraic cotopologist? :)
00:54:00 <Nereid> :v
00:54:00 <Cale> He was taking a bunch of topology and producing abstract algebra from it
00:58:55 <cornihilio> hey, sorry my system crashed, but how do I print out a word32 in hex?
00:59:16 <ClaudiusMaximus> @hoogle showHex
00:59:17 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
00:59:42 <ClaudiusMaximus> > showHex (12345 :: Word32) " and the rest"
00:59:43 <lambdabot>   "3039 and the rest"
00:59:56 <Cale> strebe: also see http://www.youtube.com/watch?v=XnrqHd39Cl0&feature=relmfu
01:01:43 <Cale> strebe: at this point it might be worth noting that many examples of natural transformations occur between functors in Haskell as polymorphic functions
01:02:20 <Cale> strebe: If F and G are functors Hask -> Hask, then a natural transformation between them is just a polymorphic function of type  forall a. F a -> G a
01:02:43 <strebe> Cale: shall do. I woke up with a horrible headache this morning, and I've managed to get 2/3rds of the way through the first video, but the buzzing in the video plus my headache plus the speaker's accent is making it a bit of a losing battle to acoustically catch some important bits of what the speaker says
01:02:51 <Nereid> (the proof of naturality in <= uses parametricity)
01:03:28 <Nereid> Cale: eh, aren't there some natural transformations that can't be represented like that?
01:04:07 <Cale> Nereid: well, possibly. I probably should have stated that the other way around.
01:04:11 <Nereid> heh.
01:04:25 <Nereid> I might be wrong.
01:04:25 <Cale> I don't know of any good examples of that though.
01:04:30 <strebe> what does 'Hask' stand for here exactly?
01:04:39 <Nereid> the category of Haskell types and functions
01:04:48 <strebe> ok
01:05:20 <Nereid> I wish Hask had pullbacks.
01:05:55 <Nereid> hmm
01:06:21 <Cale> I wish my database software had pushouts
01:06:26 <Nereid> lol
01:06:42 <Nereid> = joins?
01:07:51 <Cale> Well, really what I'm wishing for is that I could construct limits and colimits by various queries, and have those be treated as honest-to-goodness first class tables, and then I could have a column whose foreign key constraint was one of those.
01:08:46 <Cale> For example, even just the discriminated union of tables would be very very useful
01:08:51 <Nereid> I should have a proper look at Spivak's papers at some point.
01:08:53 <Nereid> on that.
01:09:10 <Cale> To be able to say: this column is either a key into table A or into table B, and I know which.
01:09:14 <Nereid> yeah.
01:10:44 <Cale> Currently whenever this comes up, you either use the horrible approximation that (A + 1) x (B + 1) = 1 + A + B + AxB <- A + B, and use two nullable columns
01:10:58 <Nereid> gross.
01:11:10 <Cale> (and hope that / install triggers to prevent the case that you don't end up with 1 or AxB
01:11:12 <Cale> )
01:11:19 <Cale> or you use multiple auxiliary tables
01:11:27 <Cale> and it's even worse
01:11:44 <Cale> (but you can come somewhat closer to expressing the constraint, even then it's not perfect)
01:11:46 <Nereid> also, I think parametricity "clicked" for me last night, hooray.
01:13:48 <Saizan> if you have free monads in C you should also have them in C^I, right?
01:14:19 <t7> i thought you need higher order type classes for monads?
01:14:21 <Nereid> Saizan: what exactly do you mean by "monads in C"?
01:14:32 <Nereid> is C a 2-category or
01:14:40 <t7> c99
01:14:48 <t7> 89 ?
01:14:53 <Nereid> t7: explain C^I then
01:14:57 <Saizan> i mean monads as functors C -> C
01:15:02 <Nereid> oh, monads *on* C.
01:15:21 <t7> ^I looks like my irc client cant render a codepoint or something
01:15:38 <Saizan> ok, on :)
01:16:40 <Nereid> Saizan: well free monads always exist, so ...?
01:16:52 <Nereid> er
01:16:56 <Nereid> no wait.
01:17:43 <Nereid> Saizan: I'm not sure what to make of your question, in any case.
01:19:03 <Saizan> if they always exist that'd be fine for me
01:19:16 <Nereid> no, there's some condition on the functor.
01:19:28 <Nereid> http://ncatlab.org/nlab/show/free+monad
01:22:20 <cornihilio> I have this in my code trace (N.showHex (packetSizeWord) " is the hex value") but it's printing out "0 is the hex value", which doesn't make any sense. Ideally, it should be printint out 80135b4d. A word32 can store a value such as that, correct?
01:22:37 <Nereid> yes it can.
01:23:06 <Nereid> are you sure packetSizeWord isn't actually 0?
01:25:18 <cornihilio> Nereid: nope, not sure at all. But if that's true, than I am definitely reading the wrong place in the file. Thank you!
01:26:25 <Saizan> Nereid: if i specify that the forgetful functor is the Mnd(D) -> End(D) one my question seems to stand
01:26:40 <Nereid> ??
01:28:34 <cornihilio> does data.bytestring.take take an int representing bits or bytes? I can't tell via the api
01:29:09 <Cale> bytes
01:29:10 <Nereid> cornihilio: the answer is in the name of the library
01:29:21 <cornihilio> thanks!
01:38:50 <JL_> Hi, could someone help me with this, I suppose to split a list into list of list seperate by +ve and -ve numbers using foldr, example : [1,2,-3,-4,5,-6] should give the answer [[1,2],[-3,-4],[5],[-6]] , I am very close to it, but don't understand why I am getting this error, below is my solution
01:38:58 <JL_> foldr (\ x y -> if null y then [[x]] ++ y else (if (signum x == signum (head (head y))) then [x] ++ head y else [[x]] ++ y)) [] [1,2,-3,-4,5,-6]
01:39:11 <JL_> <interactive>:371:95:     Occurs check: cannot construct the infinite type: a0 = [a0]     In the expression: x     In the first argument of `(++)', namely `[x]'     In the expression: [x] ++ head y
01:40:41 <fmap> @hpaste
01:40:42 <lambdabot> Haskell pastebin: http://hpaste.org/
01:40:53 <fmap> JL ^, don't paste in channel please
01:42:00 <ClaudiusMaximus> :t head []
01:42:01 <lambdabot> forall a. a
01:42:07 <ClaudiusMaximus> :t (++)
01:42:09 <lambdabot> forall m. (Monoid m) => m -> m -> m
01:42:16 <ClaudiusMaximus> :t (Prelude.++)
01:42:17 <lambdabot> forall a. [a] -> [a] -> [a]
01:42:36 <ClaudiusMaximus> > [] ++ head []
01:42:38 <lambdabot>   *Exception: Prelude.head: empty list
01:43:11 <ClaudiusMaximus> > "" ++ head "" -- better, forcing the same type (String)
01:43:12 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
01:43:13 <lambdabot>         against inferred ty...
01:43:40 <fmap> also, right tool for the job would be groupBy
01:43:54 <ClaudiusMaximus> anyway, that sub-expression is the problem, either too many or too few wrapping in lists
01:43:57 <fmap> > groupBy (\x y -> x * y > 0) [1,2,-3,-4,5,-6]
01:43:59 <lambdabot>   [[1,2],[-3,-4],[5],[-6]]
01:44:30 <JL_> sorry for posting here, won't do it again
01:44:31 <ClaudiusMaximus> sounds like a homework exercise to implement groupBy using foldr
01:44:35 <ClaudiusMaximus> :)
01:44:50 <JL_> ya, i am not asking for the answer
01:45:30 <Nereid> > groupBy (\x y -> x * y < 0) [1,2,-3,-4,5,-6]
01:45:31 <lambdabot>   [[1],[2,-3,-4],[5,-6]]
01:45:35 <JL_> how do i debugger in winghci ?
01:46:03 <ClaudiusMaximus> also using if / null / head might be better with pattern matching (either with a function in a let or where clause, or case expression in the lambda)
01:46:12 <Nereid> debugger? I hardly even knew 'er!
01:46:15 <Nereid> I mean
01:46:27 <t7> booo
01:46:31 <Nereid> yeah I know
01:46:47 <ClaudiusMaximus> first get something that typechecks, then see if it works
01:46:49 <t7> i did smile
01:48:47 <ClaudiusMaximus> JL_: [x] ++ head y   and   [[x]] ++ y  have different types, so can't possibly be used in different branches of the same if
01:49:06 <ClaudiusMaximus> :t \b t f -> if b then t else f
01:49:08 <lambdabot> forall t. Bool -> t -> t -> t
01:49:24 <Nereid> I wish we had a bool :: t -> t -> Bool -> t
01:49:29 * ClaudiusMaximus too
01:49:43 <Nereid> actually I wish we could automatically derive a function like this from any ADT
01:49:44 <ClaudiusMaximus> @hoogle t -> t -> Bool -> t
01:49:45 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
01:49:45 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
01:49:45 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
01:50:09 <Nereid> I wish foldr was flipped
01:50:10 <Nereid> etc.
01:50:23 <ClaudiusMaximus> @djinn t -> t -> Bool -> t
01:50:24 <lambdabot> f a b c =
01:50:24 <lambdabot>     case c of
01:50:24 <lambdabot>     False -> b
01:50:24 <lambdabot>     True -> a
01:50:32 <Nereid> close.
01:50:33 <Nereid> :)
01:51:19 <startling> isn't that right?
01:51:36 <ClaudiusMaximus> yeah, it does something, but unpredictably :)  reminds me i should hack on djinn-th a bit more and make it support classes etc
01:51:54 <ClaudiusMaximus> but v.low priority, when i get bored...
01:52:02 <Nereid> startling: no, it ought to be flipped.
01:52:13 <startling> Nereid: with False first? why?
01:52:24 <Nereid> because False is the first constructor of Bool
01:52:28 <JL_> claudiusmaximus how do i tag someone like you tag me
01:52:51 <startling> JL_: begin to type their name and press tab
01:52:56 <startling> Nereid: oh. well
01:53:06 <JL_> startling: got it
01:53:07 <ClaudiusMaximus> JL_: just start the message with the nick, like you did then
01:53:15 <startling> JL_: yep. :)
01:53:40 <ClaudiusMaximus> (anyway, http://www.haskell.org/pipermail/haskell-cafe/2010-August/081363.html for my mini djinn-th announce)
01:53:44 <Nereid> and I also feel like having the false argument first would make it more useful for partial application.
01:53:47 <ClaudiusMaximus> not touched it since...
01:54:11 <ClaudiusMaximus> Nereid: you could probably do something with Data.Data.Data
01:54:26 <Nereid> and TH, yeah probably
01:54:29 <JL_> ClaudiusMaximus: according to your last msg: you are saying [x] and head y are different type ? so i can't do [x] ++ head y ?
01:54:34 <ClaudiusMaximus> JL_: no
01:54:48 <startling> :t head [1, 2, 3]
01:54:50 <lambdabot> forall t. (Num t) => t
01:54:51 <ClaudiusMaximus> JL_: [[x]] and [x] are different types
01:55:10 <Nereid> JL_: in "if b then x else y", x and y have to have the same type.
01:55:18 <Nereid> (which will be the type of the whole if)
01:55:25 <JL_> Nereid: oh
01:56:35 <hpaste> Nereid pasted “djinn bool” at http://hpaste.org/76175
01:57:00 <Nereid> heh
01:58:00 <JL_> Should i use switch instead ?
01:59:01 <startling> JL_: you mean case?
01:59:13 <startling> JL_: case has the same limitation
01:59:58 <JL_> startling: ahhh
02:00:19 <startling> heh
02:05:00 <ClaudiusMaximus> :t \x -> [[x]] == [x] -- infinite type error
02:05:02 <lambdabot>     Occurs check: cannot construct the infinite type: t = [t]
02:05:02 <lambdabot>       Expected type: [t]
02:05:02 <lambdabot>       Inferred type: t
02:06:29 <Nereid> what about Mu []
02:20:52 <merijn> What was the original question? I missed it, comparing two lists of different types?
02:22:03 <quicksilver> no.
02:22:10 <quicksilver> just building a list of lists with foldr
02:22:21 <hvr> curl -i http://hackage.haskell.org/packages/archive/recent.html returns Content-Length:0 :-(
02:22:22 <quicksilver> and getting confused by : x and : [x] and x : and [x] :
02:24:09 <startling> does there exist a th thing that creates types from classes?
02:24:28 <startling> I want to do mkType [''A, ''B]
02:24:32 <startling> out of classes like
02:24:38 <startling> class A a where a :: a
02:24:46 <startling> and class B b where b :: String -> b
02:25:53 <ClaudiusMaximus> you can write one, though i found it a bit of headache getting the layers of quotation / antiquotation correct, and it changes subtly with ghc releases so my prior hax stopped working
02:27:02 <startling> ClaudiusMaximus: yeah, I'm mostly done with writing one actually
02:27:10 <startling> but I thought I should ask. :3
02:27:17 <ClaudiusMaximus> it sounds quite a specific thing - what should the type be?
02:27:32 <ClaudiusMaximus> how should the instances be implemented?
02:28:24 <startling> data SomeType = SomeTypeA | SomeTypeB String
02:28:25 <ClaudiusMaximus> or is more like "create a record with class methods so you can manually pass dictionaries around with high-level type hackery"
02:28:31 <ClaudiusMaximus> ah ok
02:28:46 <startling> ClaudiusMaximus: I'm trying to write a type-safe dsl
02:29:01 <startling> for css. and "inherit" can be in a lot of things.
02:29:16 <ClaudiusMaximus> oh god, that sounds like a nightmare
02:29:20 <startling> ikr
02:29:21 <ClaudiusMaximus> css is too complicated
02:29:43 <ClaudiusMaximus> but a dsl so i can reuse things instead of copy/pasting would be awesome, if you get it done
02:30:04 <startling> right now I've got mkProperty "position" ["absolute", "fixed", "inherit", "auto"] working
02:30:27 <startling> but there are things like percentages and absolute lengths and relative lengths that show up everywhere
02:30:36 <ClaudiusMaximus> does w3 provide machine-readable specs?
02:30:48 <startling> I don't think so.
02:31:44 <startling> and then you can do position absolute :: Properties ()
02:33:32 <t7> is the category of sets-and-functions-on-them isomorphic to the simply typed lambda calc?
02:37:46 <merijn> startling: This sounds like a usecase for abusing DataKinds and GADTs in cool ways :p
02:37:49 <Nereid> t7: no
02:38:05 <Nereid> and not even equivalent.
02:38:37 <t7> i mean the type lanuage
02:38:50 <Nereid> ?
02:39:03 <t7> f : A -> B
02:39:07 <startling> merijn: how do you mean?
02:39:19 <t7> its like prop logic
02:39:29 <Nereid> t7: I assumed you meant the category whose objects are types and arrows A -> B are terms of type A -> B
02:40:35 <hpaste> JL pasted “foldr” at http://hpaste.org/76176
02:41:55 <startling> merijn: gadts I could see, but I'm not sure how data kinds could tie in
02:42:29 <hpaste> JL pasted “foldr” at http://hpaste.org/76177
02:42:59 <merijn> startling: I'm not sure entirely how you plan to implement things. But I find myself using datakinds to do phantom types in GADTs quite often
02:43:05 <HugoDaniel> is there going to be any haskell hackaton ?
02:43:27 <HugoDaniel> brb reboot
02:44:09 <merijn> JL_: That looks like it could benefit from some let/where naming
02:44:10 <startling> merijn: I'm not even sure what that would look like
02:44:47 <merijn> startling: Take a look at RecType and Record here: https://github.com/merijn/SNet2.0/blob/master/SNet/Types.hs
02:45:22 <merijn> DataKinds phantom type to indicate Data and Control records
02:47:27 <startling> merijn: oh, interesting
02:47:36 <startling> not sure how that would work with css properties, though
02:47:51 <merijn> startling: Me neither, but "abuse" like that is fun :p
02:47:53 <alpounet> merijn, snet looks cool :)
02:48:05 <startling> merijn: haha
02:48:21 <startling> right now I've just got a new type for each property and classes where they overlap
02:48:29 <startling> so there's certainly room for improvement
02:50:37 <t7> what is a pre-catagory ? :(
02:50:43 <t7> category*
02:51:28 <t7> so many contradictions
02:53:41 <t7> "if the requirement of unique-type is dropped in the definition of category, then one gets the definition of a pre-category" "then prove that [pre-category] is a category" you just said it doesn't satisfy the axioms !?
02:55:33 <quicksilver> pre-categories don't have composition
02:55:40 <quicksilver> so they aren't categories.
02:56:06 <quicksilver> however you can generate a category from a precategory just by definining all paths in the pre-cat to be morphisms of the cat.
02:56:15 <quicksilver> it's like making a free monoid from a set.
02:59:25 <t7> free monoid sounds like a power set, but filter out the wrong oder sets
03:00:40 <t7> is it just a subset?
03:00:47 <t7> i have no idea what i am doing
03:01:04 <t7> set of subsets
03:03:58 <t7> Set A = {1,2,3}; freemonoid(A) = {{}, {1}, {1,2}, {1,3}, {1,2,3}, {2}, {2,3}, {3}}; ??
03:05:14 <b__> if I am generating sequences of unique numbers, is there a better/more efficient/interesting type to use outside of [Integer]?
03:05:39 <b__> and IntSet won't do because I need something bigger than Int
03:06:11 <t7> b__: well if its ordered you need a list or vector or something
03:06:29 <b__> it's not ordered
03:06:32 <t7> otherwise Data.Set.Set Integer
03:06:37 <b__> okay :}
03:07:53 <fmap> > maxBound :: Int
03:07:54 <lambdabot>   9223372036854775807
03:08:25 <b__> yes, for some sequences it is enough, but not for all
03:09:03 <quicksilver> t7: no.
03:09:13 <hdev> I just had a look at acid-state with a simple counter application, which counts from 1-100 in 60seconds, is it me or is that incredibly slow? also iotop shows 100% io use, cpu load is 0%, is this normal?
03:09:37 <quicksilver> t7: A = {1,2,3}, freemonoid(A) = {e,1,2,3,11,12,13,21,22,23,31,32,33,111,112,....}
03:09:47 <quicksilver> t7: "all strings from the alphabet 1,2,3"
03:10:01 <t7> aaah thankyou :)
03:10:02 <quicksilver> e represents the empty string.
03:10:42 <quicksilver> > [0..] >>= flip replicateM ['1','2','3']
03:10:44 <lambdabot>   ["","1","2","3","11","12","13","21","22","23","31","32","33","111","112","1...
03:10:54 <quicksilver> ^^ free monoid construction courtesy of the list monad :)
03:15:27 <GnomeStoleMyBike> Hello
03:15:55 <srhb> GnomeStoleMyBike: Hi
03:17:59 <t7> ah so if there is  f : A -> B and f : A' -> B'  A /= A' then is pre category. so you make new morphisms f : A -> B and f' : A' -> B' and now its a category
03:23:31 <JL_> is it possible to include where in the function of foldr ?
03:27:48 <fmap> no, where is not an expression
03:28:10 <fmap> (if I understand what you asked)
03:32:25 <JL_> fmap: ok
03:34:01 <fmap> @botsnack
03:47:53 <qasi> http://www.sfgate.com/news/article/Softball-sized-eyeball-washes-up-on-Florida-beach-3940514.php#photo-3577835
03:47:53 <Saizan> hdev: not sure, but you have to expect some I/O because of the writing of the log
03:47:55 <Saizan> 100 transactions shouldn't take 60 seconds though..
04:00:34 <dobblego> what was that project that allows you to sandbox packages for different ghc installations?
04:01:09 <zomg> cabal-dev or something like that?
04:02:14 <quicksilver> no project is required for that surely?
04:02:25 <quicksilver> different ghc installations inherently have different packages
04:02:49 <quicksilver> cabal-dev lets you have different sets of packages for different projects (within one ghc version)
04:03:11 <dobblego> I'd like to upgrade to 7.6 but I find that some packages do not compile
04:03:46 <gienah> dobblego: true, but there might be patches for some
04:03:49 <dobblego> is cabal-dev helpful for that? to forego some packages?
04:04:13 <dobblego> or patch them for 7.6?
04:04:27 <quicksilver> install 7.6 in a different directory
04:04:44 <quicksilver> doesn't sound like a problem cabal-dev particularly helps with
04:04:45 <dobblego> it is, but it still uses ~/.ghc and ~/.cabal
04:05:27 <donri> dobblego: virthualenv?
04:05:36 <JuanDaugherty> isn't cabal-dev to cause problems, not relieve them?
04:06:20 <JuanDaugherty> maybe there's an inversion of some sort
04:06:56 <JuanDaugherty> from the normal sense of "dev" vs. its other
04:07:24 * gienah figures why use a hammer when a sledgehammer is available: uses one linux chroot for each ghc version
04:07:44 <dobblego> haha, that might actually be a good idea
04:09:04 <applicative> dobblego: I don't find it's that big a deal just to have two ghc's one locally installed. You need to make it convenient to give the different commands
04:09:40 <dobblego> applicative: I have 7.0.4 installed, which is the only way I can get cabal-install and xmonad installed for example
04:11:27 <hdev> Saizan: i ran the same program on a tmpfs and i'm getting 4k transactions per second there
04:16:18 <killy9999> I have sich code: force = runIdentity . computeP  where computeP returns a monad and force returns value returned by computeP unwrapped from a monad
04:16:24 <killy9999> how the hell does this work?
04:16:50 <dobblego> killy9999: code doesn't "return a monad"
04:17:03 <dobblego> killy9999: what is the type of computeP?
04:17:37 <killy9999> Array r1 sh e -> m (Array r2 sh e)
04:17:43 <killy9999> plus some type class constrint
04:17:59 <killy9999> s/constrint/constraints/
04:18:14 <dobblego> ok, so when you do runIdentity on that result, it means m=Identity
04:18:25 <merijn> dobblego: It uses a different name for different ghc version with .ghc and .cabal
04:18:27 <dobblego> and runIdentity has the type :: Identity a -> a
04:18:39 <dobblego> merijn: what is "it" here?
04:18:51 <merijn> dobblego: At least on my system ghc 7.4 installs under ghc-7.4.2/libs and ghc 7.6 installs under ghc-7.6.1/libs
04:18:57 <killy9999> ok, the part I don't understand is why m=Identity
04:19:11 <dobblego> killy9999: m is inferred to Identity because of the call to runIdentity
04:19:14 <killy9999> I mean why does composition cause this
04:19:26 <killy9999> Oh, I see
04:19:37 <killy9999> m is forced to be Identity by the typechecker
04:19:43 <killy9999> got it!
04:19:53 <quicksilver> but that won't be useful
04:19:59 <killy9999> I was scraching my head since yesterday because of this
04:20:07 <quicksilver> because there are no interesting Array instances which work when m == Identity.
04:20:17 <quicksilver> the interesting Array instances require m == IO or ST.
04:21:28 <killy9999> quicksilver: but taking result out of ST monad might be useful, right?
04:23:21 <quicksilver> killy9999: yes, but you can't do that with runIdentity.
04:23:24 <quicksilver> you do it with runST.
04:23:37 <killy9999> right
04:23:44 <killy9999> but
04:24:21 <killy9999> if I understand correclty monad constraint in computeP is only to force sequential computation of the result
04:24:42 <killy9999> so it might be that I don't really care about the monad and just want to get the array calculated
04:25:48 <notdan> http://www.haskell.org/haskellwiki/List_of_partial_functions length is a partial function?
04:26:02 <dobblego> notdan: length [1..]
04:26:30 <osfameron> that gives the correct response in linear time ;-)
04:26:31 <hpaste> JL pasted “Foldr” at http://hpaste.org/76181
04:26:58 <JL_> Could someone help me, I don't even know if I am on the right track
04:27:03 <tumdum> where should I put unit tests for module? In the module itself?
04:27:16 <fmap> > head == []
04:27:17 <lambdabot>   Couldn't match expected type `[a] -> a'
04:27:18 <lambdabot>         against inferred type `[a1]'
04:27:19 <notdan> dobblego: oh, that is true
04:27:49 <fmap> JL_: pasted functions aren't same
04:28:17 <fmap> that's why one works and another doesn't work
04:28:35 <rfw> @pl \x -> guard (x /=2) >> return x
04:28:35 <lambdabot> ap ((>>) . guard . (2 /=)) return
04:28:41 <killy9999> tumdum: http://ics.p.lodz.pl/~stolarek/blog/2012/10/code-testing-in-haskell/
04:29:27 <JL_> ahhh F, can't cut and paste
04:29:51 <tumdum> killy9999: thanks :)
04:30:34 <hpaste> JL annotated “Foldr” with “Foldr (edit)” at http://hpaste.org/76181#a76182
04:31:34 <killy9999> tumdum: no problem. It will take a moment to read, but it should help in organizing tests
04:32:29 <tumdum> killy9999: yes, it looks like you had exactly the same problem as I do right now
04:32:42 <fujisan> @tell killy9999 Hi, killy9999 talk again and lamdabot will tell a spilly for billy because it's so chilly ;)
04:32:43 <lambdabot> Consider it noted.
04:33:39 <fmap> JL_: did you try to read the error message?
04:33:39 <quicksilver> killy9999: no, that won't work.
04:33:48 <quicksilver> killy9999: there is no way to "just get the array computed I don't care about the monad"
04:34:01 <quicksilver> you must care about the monad to run the action - different monads get run in different ways.
04:34:41 <JL_> fmap: yes, and the only thing i understand is, the error is somewhere here -> head y == []
04:35:08 <JL_> fmap: and those message above, I don't get it
04:36:01 <JL_> fmap: maybe I can't use the == operator, but i get it why
04:37:42 <fmap> :t (==)
04:37:44 <lambdabot> forall a. (Eq a) => a -> a -> Bool
04:37:46 <killy9999> quicksilver: the repa paper which describes computeP says:
04:37:47 <lambdabot> killy9999: You have 1 new message. '/msg lambdabot @messages' to read it.
04:37:50 <killy9999> Note that computeMP is parametric in the monad as we only need a well deﬁned notion of sequence, rather than a particular monadic effect.
04:38:08 <fmap> JL_: to use (==) you need Eq constraint on type
04:38:28 <fujisan> killy9999:  type @messages
04:38:42 <fmap> JL_: and split is (because of monomorphism restriction) `∷ [a] → [[a]]'
04:38:54 <quicksilver> killy9999: hmmm. I don't really understand what they're talking about but fair enough :)
04:38:55 <killy9999> @messages
04:38:55 <lambdabot> You don't have any new messages.
04:39:15 <fmap> JL_: right type would be `split ∷ Eq a ⇒ [a] → [[a]]'
04:39:16 <fujisan> @tell killy9999 you have 1 new message
04:39:17 <lambdabot> Consider it noted.
04:39:23 <fujisan> try again killy9999
04:39:26 <killy9999> @messages
04:39:27 <lambdabot> fujisan said 10s ago: you have 1 new message
04:39:29 <fujisan> :D
04:39:32 <killy9999> ?
04:39:36 <fujisan> hehe sorry
04:41:17 <JL_> fmap: but i (think? - please correct me) i wrote the same thing on ghci, and it worked there
04:41:19 <killy9999> quicksilver: the point is that they want to ensure array values are calculated before they are further processed
04:41:40 <quicksilver> killy9999: it sounds to me like they've misunderstood what a monad is
04:41:47 <quicksilver> although that seems unlikely because the repa guys are smart.
04:42:15 <quicksilver> but the "sequencing" of an arbitrary monad is a very abstract notion and it's not linked to forcing computation.
04:42:22 <quicksilver> just look at the reverse state monad for example
04:42:44 <fujisan> @tell quicksilver /truewilde
04:42:45 <lambdabot> Consider it noted.
04:43:20 <killy9999> quicksilver: there is quite a big possibility that I misunderstood something :0
04:43:22 <killy9999> :)
04:45:17 <fmap> JL_: because monomorphism restriction only applies to top-level bindings
04:45:37 <fujisan> @all-dict monomorphism
04:45:38 <lambdabot> No match for "monomorphism".
04:45:58 <fujisan> @tell fmap What does monomorphism mean?
04:45:59 <lambdabot> Consider it noted.
04:46:32 <fmap> JL_: if you turn off extended defaults rules in ghci (:set -XNoExtendedDefaultRules), and then try to `let split let f = foldr (\ x y -> if head y == ([] :: [a]) then [x]:y else [x]:y) [[]]', you will get the same error in ghci
04:46:33 <lambdabot> fmap: You have 1 new message. '/msg lambdabot @messages' to read it.
04:46:47 <fujisan> fmap type @messages
04:47:02 <fujisan> monomorphism
04:47:19 <killy9999> fujisan: are you having fun?
04:47:26 <fujisan> haha
04:47:28 <JL_> fmap: thanks. this jargon are too much for me now. *headache*
04:47:33 <fujisan> well he is using terms i can't find
04:47:34 <fmap> JL_: rule of thumb is to provide type signatures for all top-level functions
04:47:37 <fujisan> equally annoying
04:47:55 <killy9999> if you want to play with lambdabot consider using an off-line version
04:48:44 <fujisan> @tell killy9999 this is my last message @type messages to selfdestruct *KABLOOM* selfdestruct completed successfully
04:48:44 <lambdabot> Consider it noted.
04:49:00 <fmap> JL_: if you provide incorrct type signature (for example, split :: [a] -> [[a]]), you will get more useful error message
04:52:11 <fujisan> fmap are you a genius?
04:52:19 <fujisan> @all-dict genius savant
04:52:21 <lambdabot> *** "Genius" gcide "The Collaborative International Dictionary of English v.0.48"
04:52:21 <lambdabot> Genius \Gen"ius\, n.; pl. E. {Geniuses}; in sense 1, L. {Genii}.
04:52:21 <lambdabot>    [L. genius, prop., the superior or divine nature which is
04:52:21 <lambdabot>    innate in everything, the spirit, the tutelar deity or genius
04:52:21 <lambdabot>    of a person or place, taste, talent, genius, from genere,
04:52:22 <lambdabot> [183 @more lines]
04:53:00 <fujisan> this bot is the best thing ever
04:53:30 * JuanDaugherty suggest fujisan get out more.
04:53:42 <fujisan> i have a social phobia
04:53:50 <fujisan> plus i read the 48 laws of power
04:53:55 <killy9999> fujisan: cabal install lambdabot
04:53:56 <JuanDaugherty> i c
04:53:59 <fujisan> people scare me esp. politics
04:54:09 <fujisan> can i use lamdabot in terminal?
04:54:11 <fujisan> on OS X?
04:54:21 <merijn> fujisan: lambdabot also works in privmsg
04:54:37 <merijn> fujisan: I think there's a commandline lambdabot program, but I haven't use it and don't remember the name...
04:54:52 <fujisan> Hello, merijn are you dutch or dutch of dutch heritage, or dutch speaking?
04:55:12 <JuanDaugherty> *suggests
04:55:27 <merijn> Yes, yes and yes :p
04:55:39 <fujisan> gah i messed up that sentence sleep deprived
04:55:42 <fujisan> im kinda dutch
04:56:21 <fujisan> Anyone who is capable of getting themselves made President should on no account be allowed to do the job.
04:56:55 <fujisan> sorry about the bot usage
04:58:47 <killy9999> @remember fujisan Anyone who is capable of getting themselves made President should on no account be allowed to do the job.
04:58:47 <lambdabot> Okay.
04:58:59 <killy9999> http://code.haskell.org/lambdabot/COMMANDS
04:59:14 <fujisan> killy9999:  :)
04:59:28 <fujisan> is haskell as much fun as lamdabot?
04:59:35 <killy9999> better
05:02:33 <fujisan> Spotify not running
05:02:47 <fujisan> 7 days, 16:19
05:02:47 <sipa> should it?
05:02:54 <fujisan> oh silly me
05:03:00 <fujisan> it's a script for adium
05:03:15 <fujisan> i wish it wouldn't display in public
05:03:19 <sipa> haha
05:03:25 <fujisan> would be nice to have it whispered
05:03:32 <fujisan> how do you call that on IRC?
05:03:41 <sipa> notice?
05:03:42 <fujisan> visible to only you
05:03:49 <sipa> pm?
05:03:53 <fujisan> yeah i guess so notice yeah that's it
05:03:54 <fujisan> thanks
05:04:48 <ion> You can message channels and users, and you can NOTICE channels and users. NOTICE was created to prevent bot loops because compliant bots *only* respond to PRIVMSGs (normal messages) and *only* send messages using NOTICE.
05:05:03 <sipa> ^
05:05:41 <ion> There’s no conceptual difference between PRIVMSG and NOTICE other than one being the “human message” command and the other being the “bot message” command.
05:06:08 <hirsch_> I need a container for storing FilePaths and FileSizes which is automatically sorted by the sizes, do you have any hints?
05:06:31 <sipa> and due to the fact that notices are way less common, they are often treated specially by irc clients
05:06:48 <sipa> while they should be treated "less special"
05:06:52 <ion> Yeah
05:15:41 <merijn> hirsch_: How many? (i.e. does performance matter?)
05:16:03 <fujisan> merijn so are you a professional programmer?
05:16:14 <merijn> define professional and define programmer :p
05:16:15 <fujisan> if you dont mind me asking
05:16:23 <fujisan> i mean informaticus
05:16:53 <hirsch_> merijn: Yes it's for a fuse based filesystem
05:17:13 <fujisan> computer engineer
05:17:20 <fujisan> i don't know what else to call it
05:18:01 <merijn> hirsch_: I was gonna suggest an ordered list, but I guess that's ruled out then :p
05:18:14 <quicksilver> IntMap, hirsch_
05:18:14 <lambdabot> quicksilver: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:18:20 <quicksilver> @messages
05:18:20 <lambdabot> elliott said 6m 10d 14m 13s ago: yay
05:18:20 <lambdabot> fujisan said 35m 35s ago: /truewilde
05:18:45 <quicksilver> assuming your filesizes will find inside native Ints on your chosen platform
05:18:46 <hirsch_> merijn: but perhaps I take an Map with a Data.Unique key
05:19:33 <merijn> hirsch_: oh, did you mean "grouped by size" when you said "sorted by size"?
05:19:37 <hirsch_> I was wrong in my first question, the key which should be sorted is the timestamp of the file
05:19:57 <merijn> Maps have no order, so using Map makes no sense
05:20:07 <fujisan> 'It is a very sad thing that nowadays there is so little useless information.' ~ Oscar Wilde
05:20:15 <quicksilver> merijn: what?
05:20:26 <quicksilver> merijn: Maps are inherently sorted by key
05:20:38 <quicksilver> that's why they require an Ord constraint on the key.
05:21:14 <merijn> quicksilver: What's the first element of a Map, then?
05:21:34 <quicksilver> the one with the lowest key, merijn
05:21:52 <fujisan> The idea that Bill Gates has appeared like a knight in shining armour to lead all customers out of a mire of technological chaos neatly ignores the fact that it was he who, by peddling second-rate technology, led them into it in the first place.
05:22:01 <hirsch_> To give you the background. It's a fuse-based scratch filesystem which has a size limit and deletes the oldest files when the limit is exceeded
05:22:58 <quicksilver> fujisan: neither of your last two remarks seem relevant to (a) recent discussions or (b) the topic of the channel.
05:23:24 <hirsch_> As the filesystem knows all file creations, it can use a simple incremential Int key I think
05:23:24 <fujisan> true not for the laymen
05:23:37 <fujisan> it's a code for haskell
05:24:06 <fujisan> i want to teach it a natural language algorithm
05:24:46 <fujisan> quicksilver:  but i understand not everyone can appreciate mystic and creativity
05:25:03 <quicksilver> fujisan: ok, well please keep your conversion to topics that the layman would understand to be related to the topic of the channel.
05:25:26 <fujisan> trying to be unique is often paired with a cul-de-sac of narrow minded non-lateral thinking peoples
05:25:40 <maukd> fujisan: stop being noise
05:25:44 <fujisan> i'm sorry for being unique
05:26:38 <quicksilver> hirsch_: it sounds like you want a structure ordered by time but also caching total sizes
05:26:43 <fujisan> i'm sorry
05:27:09 <fujisan> i was being fallaciloquent to test the foppotees
05:27:11 <quicksilver> hirsch_: you can do that quite naively just by storing a Map keyed by time (or a strictly increasing integer to proxy for time, as you say) and also storing total size with it.
05:27:20 <quicksilver> fujisan: final warning.
05:27:49 <hirsch_> quicksilver: Yes I sum up the size of all created files and store the times and paths in an IntMap
05:27:57 * quicksilver nods
05:28:00 <quicksilver> sounds reasonable to me.
05:28:08 <fujisan> but please i will stay on topic but no more acrasial behaviour please, i just want to learn haskell and be part of your community, im a nice person if i get the chance to prove that im greatfull, i guess im sorry
05:28:23 <quicksilver> I'm pleased to hear it.
05:28:23 <hirsch_> perhaps serializing them to disk for faster startup
05:29:16 <killy9999> argh... does anyone here have experience with testing Repa code using QuickCheck?
05:29:45 <killy9999> the short question is: do I have to write my own data geneators ?
05:31:03 <fujisan> haskell doesn't have libraries?
05:31:33 <maukd> fujisan: yes/no/what
05:31:33 <quicksilver> you almost always have to write generators when writing QC code for your own work
05:31:44 <quicksilver> because you are inevitably using types of your own
05:31:52 <quicksilver> however, fortunately, that's really easy to do.
05:31:55 <killy9999> hm... I guess that's a point
05:32:05 <fujisan> so haskell has no libraries then?
05:32:20 <srhb> fujisan: What do you mean by libraries?
05:32:24 <quicksilver> fujisan: http://www.haskell.org/haskellwiki/Libraries_and_tools
05:32:31 <killy9999> fujisan: http://hackage.haskell.org/packages/archive/pkg-list.html
05:33:13 <fujisan> i'm not a programmer i guess i should selfstudy before chatting
05:33:28 <JL_> Trying to solve this error -> add (Num a) to the context of the type signature for split :: Eq a => [a] -> [[a]]
05:33:37 <srhb> fujisan: That would probably make your questions easier to answer. :)
05:33:48 <fujisan> aye
05:34:04 <srhb> fujisan: Just beginning? Have you read any of the suggested books like LYAH?
05:34:22 <fujisan> oxytocin is a tricky substance guess it makes me jabber sometimes
05:34:28 <fujisan> im green yes
05:34:56 <ski> JL_ : what is `split' supposed to do ?
05:35:21 <maukd> JL_: what's the error message?
05:35:40 <fujisan> srhb:  i haven't read anything on the haskell syllabus yet the aforementioned included
05:35:42 <srhb> fujisan: You should have a go at LYAH then. :)
05:35:47 <ski> @where LYAH
05:35:48 <lambdabot> http://www.learnyouahaskell.com/
05:35:51 <fujisan> thanks
05:36:01 <JL_> ski: [1,2,-3,-4,5] to [[1,2],[-3,-4],[5]] , i have write it using foldr
05:36:54 <ski> it's not clear to me what the condition for breaking the list is
05:37:19 <ski> JL_ : perhaps you want to paste your code (and the error message) ?
05:37:23 <maukd> [1,5,3] ==> ?
05:37:32 <maukd> and don't forget the error message
05:37:50 <ski> (presumably `concat . split = id')
05:42:15 <fujisan>  Samuel Haskell (1779-1829)
05:51:22 <Philonous> > groupBy ((==) `on` signum) [1, -3, -5 ,2 ,4 ,-9]
05:51:23 <lambdabot>   [[1],[-3,-5],[2,4],[-9]]
06:01:55 <hpaste> JL pasted “Need advice for this question” at http://hpaste.org/76183
06:03:09 <maukd> JL_: what's the assignment?
06:03:34 <quicksilver> JL_: the main problem that error is complaining about is merely the type signature split :: Eq a => [a] -> [[a]]
06:03:49 <quicksilver> as you said at the bottom
06:03:59 <quicksilver> the syntax you want lookis Num a, Eq a =>
06:04:16 <maukd> quicksilver: fail
06:05:37 <JL_> quicksilver: I tried Num a, Eq a => before, it throw parse error on input ','
06:06:52 <ski>   split :: (Num a,Eq a) => [a] -> [[a]]
06:07:46 <JL_> ski: thanks, onwards ....
06:07:54 <killy9999> does anyone know any Swiss universities that do research on functional programming?
06:07:58 <ski> instead of comparing for equality with `[]', it's better to use `null'
06:08:24 <donri> ski: why?
06:08:38 <JL_> ski: you mean if null y or null (head y) ?
06:08:57 <alpounet> killy9999, EPFL?
06:09:02 <ski> i mean `foo == []' is better written as `null foo'
06:09:05 <maukd> :t null
06:09:07 <lambdabot> forall a. [a] -> Bool
06:09:11 <maukd> :t (== [])
06:09:12 <alpounet> (for Scala, for sure, and maybe other stuffs)
06:09:12 <lambdabot> forall a. (Eq a) => [a] -> Bool
06:09:13 <ski> in your case `foo' was `head y'
06:09:21 <donri> == isn't pattern matching
06:09:46 <killy9999> alpounet: silly me, I thought it was French
06:10:26 <ski> JL_ : it's not good to use `head' unless you know the argument is not empty
06:10:46 <alpounet> no, we Frenchies have... OCaml, yay...
06:10:52 <JL_> ski: y is for sure [ [ ] ]
06:10:53 <ski> and better than using `null' and `head' is to use pattern-matching
06:11:19 <JL_> ski: some folk here has asked me to use pattern matching like few hours back
06:11:21 <donri> length x == 0 -- AWESOME
06:11:29 <JL_> ski: but i don't get it
06:12:27 <ski> donri : s/length/genericLength/ with lazy naturals :)
06:12:56 <ski> JL_ : do you know `let ... in ...' ?
06:13:01 <JL_> ski: instead of if else if else, should i actually use something like [x:xs] to decompose and join lists ?
06:13:32 <ski> JL_ : that would probably be nicer, yes
06:13:54 <JL_> ski: ya i can know let .. in .. but like only a simple case
06:15:31 <ski> you could define a helper function inside the `let', pattern-matching on its arguments, and then call it on `y'
06:16:16 <JL_> ski: should i think recusively, i haven't been thinking recusively because i am not sure if that is the right track
06:16:44 <ski> JL_ : but using `if'-`then'-`else' with `null',`head' would also be possible, though imo awkward
06:17:02 <ski> JL_ : the only recursion present should be the one inside `foldr'
06:17:43 <Jeanne-Kamikaze> is it me or did amazon.com just die
06:18:15 <luite> it works from here
06:18:16 <JL_> ski: got it, thanks, *thinking*
06:18:51 <Jeanne-Kamikaze> ah, it's back up now
06:18:52 <ski> JL_ : anyway, your last `then' and `else' branch are identical, but presumably shouldn't be -- i assume you're aware of this, though
06:20:28 <JL_> ski: yes, it's just a placeholder, it is suppose to be "then x:head y else [x]:y" which i foresee a type error, because then and else branches have to have same types
06:20:57 <JL_> ski: guess if else won't work, need plan b
06:21:21 <ski> surely not `x:head y' -- that doesn't even typecheck
06:28:17 <DanMer38485> got a question, is a list of integers the best way to represent date + population data? or is there a better way to structure the data?
06:28:40 <DanMer38485> geo_CD_Pop_Burma = [[33.588,1980],[35.035,1981],[34.946,1982],[35.545,1983],[36.343,1984],[37.042,1985],[37.841,1986],[38.54,1987],[39.3,1988],[40.03,1989],[40.79,1990]]
06:29:08 <Iceland_jack> DanMer38485: You might want to use a map
06:29:25 <fujisan> HASKELL
06:29:53 <DanMer38485> ok I will look into that thanks.
06:30:22 <Iceland_jack> If you aren't fimilar with it, search for: Data.Map
06:30:45 <dino-> I think it may depend heavily on what needs to be done with the data.
06:31:23 <DanMer38485> It was for a economic model
06:31:39 <dino-> DanMer38485: But how will it be accessed, I mean.
06:32:06 <dino-> Always sequentially, doing something with all of it. Or needing so pluck out a pair based on date (map is good for this)
06:32:52 <DanMer38485> ahh yes I would want to take elements of the list and work on them.
06:33:03 <DanMer38485> not a sequential operation
06:33:30 <dino-> Map is a good idea, then.
06:33:32 * hackagebot const-math-ghc-plugin 0.3.0.1 - Compiler plugin for constant math elimination  http://hackage.haskell.org/package/const-math-ghc-plugin-0.3.0.1 (ConradParker)
06:33:35 * hackagebot transformers-runnable 0.1.0.0 - A unified interface for the run operation of monad transformers  http://hackage.haskell.org/package/transformers-runnable-0.1.0.0 (JanBessai)
06:33:37 * hackagebot cakyrespa 0.0.22 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.22 (YoshikuniJujo)
06:33:42 <DanMer38485> i have been starting to worry about the long term performance trade-offs if i just use lists. yea thanks.
06:34:24 <applicative> DanMer38485: shouldn't that be lists of pairs anyway?
06:34:50 <fujisan> @dict-all presets
06:34:51 <lambdabot> Unknown command, try @list
06:35:13 <applicative> keeping with a listlike structure, you can also make an unboxed vector of pairs or an array
06:35:18 <DanMer38485> one thing i noticed is its not displaying the population corectly, its displaying exponent. I was trying to remember how to force it to display the number without exponent value.
06:35:46 <fujisan> Hello, DanMer38485
06:36:03 <applicative> DanMer38485: yes I hate that, there are various expedients
06:36:05 <DanMer38485> hello fujisan
06:38:01 <DanMer38485> hmmm lots of newbie questions, i kind of found the launguage by accident. someone told me haskell was realy good for economic models. At least its easyer to understand compaired to lisp.
06:38:13 <mux> is it now?
06:38:37 <DanMer38485> just my opinion but I find it to be easyer to understand.
06:38:38 * hackagebot cakyrespa 0.0.23 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.23 (YoshikuniJujo)
06:38:41 * hackagebot syntactic 1.3 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.3 (EmilAxelsson)
06:38:43 * hackagebot aws-sdk 0.3.0.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.3.0.0 (YusukeNomura)
06:38:45 * hackagebot yesod-routes 1.1.0.2 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.1.0.2 (MichaelSnoyman)
06:38:47 * hackagebot hakyll-contrib-links 0.2.0.0 - A hakyll library that helps maintain a separate links database.  http://hackage.haskell.org/package/hakyll-contrib-links-0.2.0.0 (PiyushKurur)
06:40:38 <tumdum> is it normal that cabal needs more then 256 MB of ram?
06:40:55 * killy9999 checks tumdum's question
06:41:10 <fmap> needs for what?
06:41:15 <gautam> exit
06:41:27 <tumdum> for "cabal update"
06:42:05 <ski> > listArray (1980,1990) [33.588,35.035,34.946,35.545,36.343,37.042,37.841,38.54,39.3,40.03,40.79]
06:42:06 <lambdabot>   array (1980,1990) [(1980,33.588),(1981,35.035),(1982,34.946),(1983,35.545),...
06:42:40 <ski> DanMer38485 : arrays might be another choice
06:43:20 <DanMer38485> ski : ahh thats a exelent idea. I didnt realise that could be done (egg on my face..)
06:43:49 * hackagebot warp 1.3.4 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.4 (MichaelSnoyman)
06:43:51 * hackagebot http-reverse-proxy 0.1.0.2 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.0.2 (MichaelSnoyman)
06:43:53 * hackagebot warp 1.3.4.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.4.1 (MichaelSnoyman)
06:43:55 * hackagebot enummapmap 0.0.2 - Map of maps using Enum types as keys  http://hackage.haskell.org/package/enummapmap-0.0.2 (MatthewWest)
06:43:57 * hackagebot crf-chain1 0.2.1 - First-order, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-0.2.1 (JakubWaszczuk)
06:44:48 <applicative> DanMer38485: here are typical expedients http://stackoverflow.com/questions/8098457/how-do-i-get-to-haskell-to-output-numbers-not-in-scientific-notation
06:44:49 <killy9999> tumdum:  yup
06:45:05 <applicative> printf is kind of nasty if you ask me....
06:45:59 <hpaste> killy9999 pasted “package dependency problem” at http://hpaste.org/76186
06:46:18 <killy9999> what should I place in my .cabal file to avoid this warning?
06:46:20 <DanMer38485> cheers you guys have been awesome.
06:48:22 <applicative> killy9999: update to repa 3.2.2?
06:48:49 <maukd> killy9999: reinstall repa?
06:48:59 * hackagebot data-named 0.5.0 - Data types for named entities  http://hackage.haskell.org/package/data-named-0.5.0 (JakubWaszczuk)
06:49:01 * hackagebot language-c-quote 0.4.2 - C/CUDA/OpenCL quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.4.2 (GeoffreyMainland)
06:49:03 * hackagebot adict 0.2.0 - Approximate dictionary searching  http://hackage.haskell.org/package/adict-0.2.0 (JakubWaszczuk)
06:49:05 * hackagebot nerf 0.1.0 - Nerf, the named entity recognition tool based on linear-chain CRFs  http://hackage.haskell.org/package/nerf-0.1.0 (JakubWaszczuk)
06:49:42 <killy9999> ok, I will try
06:50:13 <killy9999> but aside from that - if that would not solve the problem - what should I do to eliminate this warning?
06:50:57 <maukd> find out why reinstalling repa didn't fix it
06:53:44 <killy9999> I'm not saying it didn't - I'm in the proces of recompiling
06:53:56 <killy9999> but I'm asking out of curiosity
06:54:12 <killy9999> is there any way for a package maintainer to manage this kind of problesm?
06:55:23 <maukd> ... yeah, don't install multiple versions of the same package
06:55:40 <fujisan> can i use Otto to run haskell code?
06:55:46 <fujisan> or to program
06:56:29 <killy9999> Oh shi....
06:56:41 <killy9999> I didn't notce that
06:57:27 <killy9999> hm.. that's weird. I unregistered repa, removed it from disk and after installing I still got version 3.2.1.1 instead of 3.2.2.1
06:57:33 <killy9999> and yes, I did cabal update
07:00:40 <fmap> killy9999: why do you think it should install some another version of repa?
07:00:53 <fmap> s/some//
07:01:12 <killy9999> becuase there is newer version while I got older
07:01:39 <killy9999> I tracked the reason - new repa requires newer base (GHC 7.6), while I have GHC 7.4
07:01:51 <killy9999> so the question remains
07:02:30 <maukd> why are you trying to install a newer version?
07:02:59 <fmap> you should care what QuickCheck version does repa depends on, not what repa version is installed
07:04:42 <killy9999> maukd: I followed applicative's advice
07:04:46 <killy9999> and your's
07:05:01 <maukd> I didn't say anything about a newer version
07:05:09 <killy9999> applicative did
07:05:28 <killy9999> and I assumed that if I remove a package and install it again I will get newer version if it's available
07:05:31 <applicative> ah i see killy9999
07:05:34 <killy9999> but that doesn't matter I guess
07:05:50 <maukd> yeah, but I don't understand why
07:06:05 <killy9999> the thing is that my cabal file says QuickCheck >= 2.4.2
07:06:19 <applicative> so something needs to be done about test-framework-quickcheck2-0.2.12.3 QuickCheck-2.5
07:07:01 <killy9999> applicative: test-framework-quickcheck2-0.2.12.3 depends on: QuickCheck >= 2.4 && < 2.6
07:07:22 <killy9999> that's what the cabal file for that package says
07:07:31 <applicative> and the ghc7.4 repa needs QuickCheck (≥2.3 & <2.5)
07:07:52 <killy9999> yes
07:07:59 <maukd> ah
07:08:05 <applicative> is it that you have both versions of quickcheck?
07:08:08 <maukd> what does wavelet-hs need?
07:08:25 <applicative> package wavelet-hs-0.0.1 requires QuickCheck-2.5
07:08:31 <killy9999> applicative: yes, because of dependencies of different packages that I have
07:08:33 <maukd> you're fucked
07:08:37 <applicative> but i take it not explicitly
07:08:48 <applicative> is wavelet your package?
07:08:49 <killy9999> applicative: it doesn't say so in my cabal file
07:08:54 <killy9999> wavelet-hs
07:08:58 <killy9999> yes
07:09:17 <applicative> yeah.  does ghc-pkg list s how two quickchecks?
07:09:44 <killy9999> at first I wrote only "QuickCheck" in cabal file, then I added "QuickCheck >= 2.4.2 && < 2.6" for clarity, but that doesn't help
07:09:48 <killy9999> qpplicative: yes
07:09:57 <applicative> killy9999: thats the problem
07:10:18 <maukd> killy9999: what does wavelet-hs.cabal specify?
07:10:35 <applicative> he just said, it's his package
07:10:59 <hpaste> killy9999 pasted “wavelet cabal” at http://hpaste.org/76188
07:11:10 <killy9999> hm.. strange
07:11:15 <maukd> ah, good
07:11:34 <killy9999> ghc-pkg claims that test-framework-quickcheck2 depends on QuickCheck 2.5
07:11:47 <killy9999> despite cabal file for that package claiming otherwise
07:11:57 <applicative> if you try to unregister the NEW quickccheck, which repa cant tolerate, youll be okay i think
07:12:14 <maukd> have to rebuild test-framework-quickcheck2, then
07:12:20 <applicative> you will have to get rid of test-framework-quickcheck2  so it builds with the old one
07:12:29 <killy9999> OK, I'll try that
07:12:52 <killy9999> I guess that's what dependency hell is... I forgot what it's like
07:13:03 <maukd> @where sicp
07:13:04 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | "Structure and Interpretation of Computer Programs" | http://www.vex.net/~trebla/haskell/sicp.
07:13:04 <lambdabot> xhtml | "Storage and Identification of Cabalized Packages"
07:13:11 <applicative> repa is your problem, but it looks like the other dependencies can build with repa-consisstent quickcheck
07:13:11 <maukd> dammit
07:13:18 <killy9999> last time I experienced this was with Mandrake
07:13:23 <killy9999> applicative: why repa?
07:13:41 <fujisan> repa is repo plural ?
07:13:47 <maukd> @where+ sicp http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
07:13:48 <lambdabot> I will never forget.
07:13:49 <applicative> that you need that version of repa means you need to be using that version of quickcheck for all those deps
07:13:59 <fujisan> @messages
07:13:59 <lambdabot> You don't have any new messages.
07:14:03 <maukd> @where sicp
07:14:04 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
07:14:17 <fujisan> @yarr
07:14:17 <lambdabot> Prepare to be boarded!
07:14:56 <applicative> killy9999: did cabal know that it couldn't build the more recent repa with ghc-7.4 or did it just fail?
07:15:44 <strebe> maukd: the vex.net sicp url 404s
07:15:46 <applicative> right, it knows from the  version of base
07:16:02 <killy9999> applicative: it just downloaded older version, without any error messages or prompts
07:16:17 <strebe> maukd: looks like it should be http://www.vex.net/~trebla/haskell/sicp.xhtml
07:16:28 <killy9999> ok, removing test-framework, QC 2.5 and then installing test-framework helped
07:16:41 <killy9999> anyway, I am still a bit disturbed
07:16:53 <applicative> killy9999: it's not so bad, its just that you had 2 quickchecks. If you obliterate all quickchecks + repa + test-framework-quickcheck2 and then cabal install, it will do the right thing
07:16:54 <maukd> strebe: ... that's what it is?
07:17:00 <killy9999> I can see how all these package dependencies get completely out of control with a biggger project
07:17:28 <killy9999> applicative: doesn't seem like a very sane way of doing things
07:17:36 <strebe> maukd: hmm!
07:17:41 <killy9999> I mean it takes a bit of effort to ensure that all the dependencies are correct
07:17:47 <applicative> killy9999: no, I was thinking from the user point of view, not advising doing it.
07:17:51 <killy9999> I wish cabal was a package manager
07:17:58 <t7> i like vi key binding but hate vim script, and i want an extensible editor... what do?
07:17:58 <strebe> maukd: ah, user error on my part. Oops. :-)
07:18:11 <killy9999> t7: emacs?
07:18:23 <taruti> t7: emacs has vi emulation :)
07:18:29 <t7> emacs is a bit heavy
07:18:34 <killy9999> anyway, is there a way to manage this kind of package dependencies reasonably?
07:18:36 <maukd> t7: script it in mzscheme
07:18:40 <applicative> killy9999: it's a pain, but I don't find reasoning about your  case too hard any more, though before it just seemed likehell admittedly
07:18:49 <strebe> t7: extensible editors tend to be, and it's light compared to IDEs
07:18:56 <killy9999> I know there are some project that aim to solve this problem
07:18:59 <merijn> t7: Vim can be scripted in python or ruby
07:19:02 <t7> i want something between vim and emacs
07:19:10 <geekosaur> nvi can be scripted to some extent in perl, python, and/or tcl depending on how it was built
07:19:15 <killy9999> vimacs :)
07:19:35 <geekosaur> some commercial editors have vi and/or emacs overlays, also
07:19:42 <applicative> i think if you have cabal-dev and use it inside the directory, it will do everything perfectly -- installing new versions of everything, but the right ones
07:19:45 <t7> im gonna make vihaskell
07:19:53 <applicative> killy9999: ^^^
07:19:56 <t7> the world need more text editors
07:20:32 <geekosaur> wait, yi started out as a vi clone...
07:20:50 <killy9999> applicative: ok, I guess I'll give cabal-dev a try sometime soon
07:20:51 * applicative scripts textmate in haskell, though maybe you won't call it scripting
07:21:22 <applicative> killy9999: the main thing was just your pre existing pile of packages.  in particular the two quickchecks
07:21:24 <t7> mine is gonna be webscale web 3.0
07:21:47 <t7> typescript
07:21:53 <t7> on node.js
07:22:09 <Cale> t7: Does it support sharding?
07:22:15 <applicative> sharding?
07:22:23 <t7> sharting is supported
07:22:51 <clahey> t7, Is it asyncronous?
07:22:55 <Cale> Sharding is the secret sauce that makes it webscale
07:23:00 <applicative> ah
07:23:01 <killy9999> applicative: I would say that "it wasn't my fault"
07:23:11 <t7> clahey: yeah its all inline callbacks
07:23:16 <killy9999> I mean I install packages using cabal and let it handle dependencies
07:23:17 <t7> completely unreadable
07:23:32 <killy9999> I didn't notice that at some point it installed two versions of quickcheck
07:23:35 <applicative> killy9999: yes, it does that perfectly on one condition
07:23:45 <applicative> killy9999: that you never use cabal update again
07:23:48 <strebe> t7: will it have full emulation of other editors available?
07:24:01 <killy9999> applicative: doesn't sound like a realistic use case
07:24:08 <fujisan> what kind of apps do you folks code with haskell?
07:24:17 <t7> strebe: no fork it
07:24:23 <killy9999> especially that it gives warning when database is older than 15 days
07:24:51 <applicative> killy9999: yeah. you just have to watch for when you get several installs of something, especially something fundamental
07:25:11 <quicksilver> applicative: surely cabal update is fine?
07:25:18 <quicksilver> it's cabal upgrade you should avoid?
07:25:31 <applicative> quicksilver: no, i'm saying somethign different
07:25:49 <quicksilver> you're saying root yourself in time at the point where it worked
07:25:50 <killy9999> cabal upgrade is disabled I think
07:25:52 <quicksilver> and it won't stop working?
07:25:58 <strebe> fujisan: http://hackage.haskell.org/packages/archive/pkg-list.html
07:26:01 <applicative> cabal is perfect at synchronic installs
07:26:24 <applicative> if it has one picture of hackage, it does right
07:26:49 <applicative> if you build a lot of things with that picture, then start building with another one, things get messy
07:27:23 <Soultaker> is there a version of 'minimum' that returns a Maybe (and returns Nothing if the argument is empty?)
07:27:55 <ClaudiusMaximus> Soultaker: http://www.haskell.org/hoogle/?q=minimum%20%2Bsafe
07:27:56 <applicative> @type minimum
07:27:58 <lambdabot> forall a. (Ord a) => [a] -> a
07:28:04 <applicative> > minimum []
07:28:06 <lambdabot>   *Exception: Prelude.minimum: empty list
07:28:07 <fujisan> @time
07:28:09 <applicative> ick
07:28:12 <qasi> :t minimum
07:28:13 <lambdabot> forall a. (Ord a) => [a] -> a
07:28:24 <qasi> there's no difference between :t and @type I guess?
07:28:32 <qasi> applicative, well, head and tail are the same, really.
07:28:38 <Soultaker> ClaudiusMaximus: ahh, but that's not a standard package is it?
07:28:44 <Cale> fujisan: I was working for a startup on an action RPG for iPhones and other mobile devices -- that's quite close to completion, but the company is on hiatus while the founder gets together some more funding. I've also been working for skedge.me, and we're starting to rebuild the entire back-end of the application in Haskell. A long time ago, I spent a bit of time at McMaster University working on part of a compiler for
07:28:44 <Cale>  a domain specific language for signal processing applications written in Haskell.
07:29:04 <quicksilver> Soultaker: depends what you consider 'standard'.
07:29:07 <ClaudiusMaximus> Soultaker: no, but it's got safer versions of lots of things that really should have been in the Prelude
07:29:10 <applicative> qasi: yes.
07:29:14 * killy9999 is away
07:29:14 <quicksilver> I thinke the 'safe' package is quite a standard answer to this kind of question.
07:29:21 <applicative> qasi: oh i see it is in safe
07:29:30 <quicksilver> there is also minimum . map Just
07:29:34 <quicksilver> :t minimum . map Just
07:29:35 <lambdabot> forall a. (Ord a) => [a] -> Maybe a
07:29:40 <fujisan> oh okay Cale that's cool
07:29:59 <Cale> fujisan: I've also used it for countless smaller things.
07:30:03 <ClaudiusMaximus> >minimum . map Just $ ""
07:30:07 <ClaudiusMaximus> > minimum . map Just $ ""
07:30:10 <lambdabot>   *Exception: Prelude.minimum: empty list
07:30:12 <Puffton> Why isn't the names foldl and foldl' switched? foldl' is quicker, right? So why not use it by default and only fall back to the current implementation of foldl if need be?
07:30:16 <Puffton> Or is there something I'm missing?
07:30:19 <quicksilver> ClaudiusMaximus: oops
07:30:21 <applicative> someone said readMay or whatever was soon to be the Prelude or something
07:30:30 <quicksilver> I mean minimum . (:Nothing) . map Just
07:30:34 <quicksilver> or something
07:30:38 <quicksilver> actually I don't know what I mean :)
07:30:54 <applicative> Puffton, yes foldl should be just thrown out :)
07:30:55 <ClaudiusMaximus> > minimum . (Nothing:) . map Just $ ""
07:30:57 <mux> I don't know either
07:30:57 <lambdabot>   Nothing
07:31:02 <ClaudiusMaximus> wait
07:31:02 <mux> and I've tried understanding
07:31:09 <ClaudiusMaximus> that'll always return Nothing
07:31:13 <Soultaker> ClaudiusMaximus: that doesn't work either, because Nothing is less than Just x, so you always get Nothing
07:31:19 <mux> that would compare maybes
07:31:26 <Soultaker> you can do it with maximum and invert the comparison but it gets really ugly.
07:31:40 <Puffton> applicative, what I meant was just the choice of calling foldl, foldl… and not foldl' (and vice versa)… are you following? :D
07:31:52 <ClaudiusMaximus> @instances Monoid
07:31:53 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
07:32:04 <Puffton> i.e. make foldl the quick implementation and foldl' the one with delayed evaluation or whatnot
07:32:08 <Cale> Puffton: The original thinking when the Haskell Prelude was first being written was that it's the compiler's job to turn foldl into foldl' when appropriate.
07:32:12 <ClaudiusMaximus> @instances Semigroup
07:32:13 <lambdabot> Couldn't find class `Semigroup'. Try @instances-importing
07:32:19 <ClaudiusMaximus> @instances-importing Data.Semigroup
07:32:20 <lambdabot> Couldn't find class `Data.Semigroup'. Try @instances-importing
07:32:25 <applicative> Puffton: but foldl' is a bit dangerous.  I think I advise explicit recursion in that case, because its crucial that  the folded operation be totally strict.
07:32:28 <ClaudiusMaximus> @instances-importing Semigroup Data.Semigroup
07:32:29 <lambdabot> Couldn't find class `Data.Semigroup'. Try @instances-importing
07:32:31 <quicksilver> ClaudiusMaximus: minimum . (++[Nothing]) . map Just ?
07:32:39 <quicksilver> ClaudiusMaximus: I'm sure we'll get there eventually :)
07:32:41 <applicative> Puffton: not that i pretend to be an expert
07:32:45 <ClaudiusMaximus> quicksilver: Nothing <= Just x
07:32:53 <quicksilver> oh, right
07:32:58 <Puffton> oh ok
07:33:01 <Cale> I think I disagree. If you can write something as a foldl', please do :)
07:33:15 * applicative agrees with Cale in principle
07:33:17 <Puffton> Cale, but the heuristics came out a bit more complex than they had first thought?
07:33:21 <merijn> Cale: You being a math guy I have a question for you (which you may or may not be any help with)
07:33:51 <applicative> I'm just emphasizing what I take to be the precondition of rational use of it, which is an operation strict in both arguments, so there is genuine accumulation
07:33:52 <qasi> @src foldl
07:33:52 <lambdabot> foldl f z []     = z
07:33:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
07:33:54 <qasi> @src foldl'
07:33:54 <lambdabot> foldl' f a []     = a
07:33:54 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
07:34:33 <applicative> right, you dont  want f a x to be e.g. a ++ x
07:34:40 <merijn> Cale: I'm formalising an algorithm as an abstract machine consisting of a set of transitions between states. I have a set of nodes and a state associated with every node and some transitions need to modify the state of a node (so, essentially a Map). What's the most convenient/traditional math notation for this sort of thing?
07:35:00 <Cale> Well, okay, if f is not strict in both arguments, you'd be better off with foldl or even foldr
07:35:50 <merijn> Someone suggested having a set of (node, node state), but that'd require a bunch of notational juggling and doesn't guarantee only one state per node, etc.
07:35:57 <Cale> merijn: Is it computationally any more powerful than a DFA?
07:36:04 <ClaudiusMaximus> Soultaker: http://hackage.haskell.org/packages/archive/semigroups/0.8.4.1/doc/html/Data-Semigroup.html#t:Min
07:36:15 <quicksilver> ClaudiusMaximus: there should be a standard Monoid wrapper for "Less" and "Greater"
07:36:32 <quicksilver> ClaudiusMaximus: then we could solve this with an mconcat
07:36:35 <merijn> Cale: Possible number of states is infinite, so I think so?
07:36:42 <quicksilver> ClaudiusMaximus: (maybe call them Join and Meet, I dunno)
07:36:46 <applicative> Cale right. you're better off with foldr by default because of ghc's optimizations
07:36:57 <Cale> ah, but otherwise, you can imagine just splitting each node into its possible states?
07:37:02 <Cale> oh, no, I see
07:37:13 <ClaudiusMaximus> quicksilver: yes, i've been looking but it's missing it seems
07:37:20 <Cale> It's not local, you want to recover the state when you re-arrive at that node
07:37:48 <applicative> Puffton: have you read those slides of tibbe about 'high performance haskell' or whatever?
07:38:01 <Puffton> no, where are they?
07:38:14 <merijn> Cale: I'mt trying to describe the global state of a distributed system, which means some way of refering to the state on a specific node in the system
07:38:16 <applicative> @google tibbe high performance haskell
07:38:17 <Cale> applicative: Not just that, but simple lazy evaluation will treat it better
07:38:18 <lambdabot> http://www.slideshare.net/tibbe/highperformance-haskell
07:38:18 <lambdabot> Title: High-Performance Haskell
07:38:19 <Cale> (typically)
07:38:23 <quicksilver> ClaudiusMaximus: http://www.haskell.org/pipermail/libraries/2010-September/014349.html
07:39:01 <applicative> Puffton: there are more recent variants of the talk, I learned a ton from them -- again not that I pretend to genuine expertise :)
07:39:28 <quicksilver> ClaudiusMaximus: (more bike shed colours at http://www.haskell.org/pipermail/libraries/2010-September/014360.html )
07:39:33 <Puffton> Oh ok, I'll have a look!
07:39:35 <Cale> merijn: and transitions depend on the state of the node we're in?
07:40:38 <Cale> It's actually pretty awkward that we're calling what would be states nodes and then states are something else :)
07:40:45 <Cale> but that's okay :)
07:41:05 <mux> foldr (\x y -> if isNothing y then return x else min x <$> y) Nothing "bcde"
07:41:12 <mux> > foldr (\x y -> if isNothing y then return x else min x <$> y) Nothing "bcde"
07:41:13 <lambdabot>   Just 'b'
07:41:16 <mux> > foldr (\x y -> if isNothing y then return x else min x <$> y) Nothing ""
07:41:18 <lambdabot>   Nothing
07:41:30 <applicative> Puffton: see also e.g http://www.slideshare.net/tibbe/reasoning-about-laziness and a sort of case study http://johantibell.com/files/stanford-2011/performance.html#(1)
07:41:32 <merijn> Cale: There is no notion of being in a node. I'm describing global state transitions. i.e. I have multiple transitions with zero or more preconditions. Given a initial global state s in which all of t's preconditions hold, t is a transition from s to the new global state s'
07:41:41 <mux> quicksilver: how about that one for a safe minimum?
07:41:45 <Puffton> Who is this Tibble guy? Some kind of Haskell God?
07:41:54 <quicksilver> mux: yes, quite.
07:42:05 <Puffton> Tibell*
07:42:12 <quicksilver> mux: I was trying to avoid the direct definition for no particular reason.
07:42:15 <mux> it took me a surprisingly large amount of time to write
07:42:29 <applicative> Puffton: I think he's very reputable.
07:42:58 <mux> @pl \x y -> if isNothing y then return x else min x <$> y
07:42:58 <lambdabot> ap (ap . flip (if' . isNothing) . return) ((<$>) . min)
07:43:00 <ski> preflex: xseen tibbe
07:43:00 <preflex>  tibbe was last seen on freenode/#ghc 20 hours, 42 minutes and 4 seconds ago, saying: dcoutts_: so I guess this should be changed?
07:43:08 <merijn> Cale: So I want to say that if the state for a particular node n is a in the initial state I'm replacing the state of node n with some state b in s'
07:43:33 <merijn> Cale: I just don't know a sensible way of writing that in any sort of mathematical sense
07:43:59 <mux> I have that nagging feeling that there's a much more beautiful and simple definition
07:44:30 <Cale> merijn: okay, so you have some set N of nodes, and some set S of states, and you have some mapping s: N -> S
07:44:34 <Cale> merijn: yes?
07:44:51 <merijn> Cale: Yes, or rather I don't know how to describe that mapping s : N -> S :)
07:44:59 <Cale> you also have some initial state i in S
07:45:22 <Cale> er, maybe not?
07:45:36 <Cale> I'm trying to pick things out of what you're saying and formalise them
07:46:00 <Cale> We have transitions and they have preconditions...
07:46:36 <merijn> My global state s is a set N of nodes, a set NS of states with a bijective mapping between N and NS and some other sets in the global state s.
07:46:57 <Cale> So each transition perhaps consists of some subset P of S (encoding the precondition in which it applies) together with a mapping P -> S saying what the new state becomes?
07:47:22 <Cale> oh, interesting
07:47:31 <Cale> So no two nodes are allowed to have the same state?
07:47:34 <merijn> Cale: No, I'm describing transitions between global states only
07:47:50 <merijn> Cale: No, that wouldn't make any semantic sense
07:48:54 <quicksilver> if all the nodes are not allowed to have the same state
07:48:58 <quicksilver> isn't that a petri net?
07:49:24 <quicksilver> a petri net is a state transition system where you put 'counters' on nodes so you can stop two counters going on the same nodes, or something like that.
07:49:35 <quicksilver> there are lots of variants but one kind was used to give a semantics to linear logic.
07:50:32 <merijn> The point is that just modifying a state is not really possible in set notation (my state is basically just some tuple of sets). So I don't know how to say that the state of a node n (which is in NS) is now some other state (that means somehow specifying a "new" bijective mapping between N and NS since node n now maps to a different state)
07:50:47 <Cale> Oh, that's interesting. I've never really bothered to figure out why people care about Petri nets, but modelling linear logic sounds useful.
07:51:34 <merijn> Someone suggested having a set of node, node state tuples and using that as a relation, but that means more details to proof (like ensure that a nodes and states have 1-to-1 mappings)
07:51:57 <watermind> is there anything like   Java's JML  or  C's ACSL  or   ADA's Spark  for Haskell...
07:52:28 <watermind> some annotation language to specify pre conditions, post conditions, and the like
07:52:38 <merijn> I have a feeling this shouldn't be so damn difficult...
07:52:39 <Cale> merijn: you have a set of functions from nodes to states, and your transitions are moving from one function to another according to some conditions.
07:52:58 <Cale> does that sound right?
07:53:56 <merijn> Cale: My transition would replace 0 or more of those node to state functions with different functions (i.e. to represent the state of a node having changed)
07:53:56 <Cale> We know there are as many possible states as there are nodes, because you're forming bijections between them
07:54:23 <quicksilver> watermind: notionally you don't need preconditions and postconditions for functional programs. You just have equations which describe your functions.
07:54:34 <quicksilver> that's why they're better for reasoning.
07:54:35 <Cale> So each possible state of the nodes is more or less a permutation
07:54:39 <merijn> Initially I didn't even bother doing it this complicated I just used node state directly instead of having a notion of nodes. But that is very unclean, as then it becomes impossible for values in the model to refer to a specific node)
07:55:15 <Cale> merijn: You said at one point that the number of possible states of the system is infinite
07:55:20 <merijn> Cale: Just add/removing some elements from a set (well, replacing the original set with a set union/difference)
07:55:23 <Cale> but I don't see how that could be, given what you said
07:55:45 <Cale> Because you have some nodes, and some states, and the state of the system is encoded by a bijection between them
07:55:54 <parcs`> > foldr (\x y -> min x <$> y <|> pure x) Nothing "bcda"
07:55:55 <Cale> and if there are n nodes then, there are n! possible states?
07:55:56 <lambdabot>   Just 'a'
07:56:32 <merijn> I think this conversation suffers from to many different meanings of state >.>
07:57:11 <merijn> Let's try haskell terms instead
07:57:15 <Cale> Maybe you ought to just describe what you're talking about
07:57:34 <watermind> quicksilver: I know... but we can still talk about pre and post conditions, i.e. given arguments satisfying these (pre) conditions the result will satisfy this (post) condition
07:59:08 <quicksilver> P(a) ===> Q(f(a))
07:59:15 <quicksilver> I wouldn't call that pre and post
07:59:18 <quicksilver> it's just logical implication
07:59:39 <quicksilver> but anyway, if your question is "is there a well-defined system of annotations and perhaps a tool to help check them" I thnk the answer is no
07:59:48 <quicksilver> although clearly quickcheck is in this general area.
08:00:21 <Cale> SPJ is working on something like that, apparently
08:00:55 <quicksilver> there do seem to be a few papers in the area
08:00:56 <watermind> maybe you're right about terminology... I used the pre/post conditions because in languages like ACSL, if you have a pure function performing no assignements, that's still what you call them
08:01:02 <watermind> (I think...)
08:01:11 <quicksilver> http://www.haskell.org/haskellwiki/Research_papers/Testing_and_correctness#Verifying_Haskell_programs
08:01:24 <watermind> Oh I missed that, cool
08:01:51 <merijn> Haskell notation attempt: I have "Map Node (Set a)" plus some other sets, I'm trying to find a notation that given some "m :: Map Node (Set a)", "n :: Node" (guaranteed to be in m) and "v :: Set a" let's me express "insert n (union v (m!n)) m"
08:02:22 <merijn> (Or, in some cases "insert n (difference v (m!n)) m")
08:03:26 * ski . o O ( `forall a. Q (f a) => P a' )
08:03:33 <merijn> Except that I don't know what the correct way to represent Map, insert and lookup would be
08:03:40 <attic> Is there a way to import modules with a complete path to the module location?
08:04:15 <Cale> Puffton: oh, I wanted to point out that you really *can* use foldl instead of foldl' a lot of the time in GHC, so long as you make sure to turn optimisations on
08:04:47 <quicksilver> attic: no, that's not how modules are supposed to work, they're too abstract to know about file system location.
08:04:50 <watermind> ski: least pre-conditions?
08:04:51 <Cale> Puffton: Perhaps it's not the wisest thing to rely on compiler optimisations for the program to not eat all the stack and die.
08:04:58 <quicksilver> attic: instead you give the compiler a list of locations to search.
08:05:20 <attic> quiksilver: Ah I see, I'll check that out. thanks
08:05:28 <Cale> Puffton: but that is sort of what is most in line with how the original function was written
08:05:50 <ski> watermind : sorry ?
08:07:24 <watermind> ski: seemed like you were taking a predicate on the result of a function and inferring which conditions its arguments must satisfy... that reminded me of Dijkstra's apprach to Hoare's logic, of calculating least pre-conditions
08:09:14 <Cale> Puffton: but if you write a program like  myLength = foldl (+) 0; main = print (myLength [1..10000000])  and then compile with -ddump-simpl -ddump-simpl-stats
08:09:43 <watermind> quicksilver: by the way http://libra.msra.cn/Publication/4139397/extended-static-checking-for-haskell
08:10:02 <watermind> quicksilver: "One novelty is our use of Haskell as the specifica tion lan- guage itself for pre/post conditions"
08:10:19 <watermind> quicksilver: so apparently this terminology is also used here
08:11:12 <quicksilver> Xu might be talking about IO code and it might really be pre/post :)
08:11:16 <quicksilver> but you could be right.
08:12:05 <quicksilver> The reason I made my point is that it seems relevant to remark that they key reasons that make Hoare logic hard (or interesting) and force you to think about minimal and pre and post and so on are inherently concerns about imperative programs.
08:12:27 <quicksilver> you don't *need* such complicatons to reason about functional programs.
08:12:30 <tac> Is there any particular reason there aren't any (read: I don't know of any) languages which make use of Hoare logic?
08:13:11 <companion_cube> analysing programs often makes use of Hoare logic, but languages themselves seldom do
08:13:17 <Cale> Puffton: you can see that it unfolds the definition of foldl, and the strictness analyser infers that the unfolded definition is strict. (you should see something like "Str=DmdType SS")
08:14:28 <donri> dreixel: sorry for bugging you :) any pointers for generic read? say I have ["Just","5"] and want to turn that into a (Just 5), via Generic and not using Read?
08:15:51 <Phlogistique> Is there anything in Haskell similar to http://www.seas.upenn.edu/~harmony/ "Boomerang is a programming language for writing lenses—well-behaved bidirectional transformations—that operate on ad-hoc, textual data formats." ?
08:16:17 <watermind> quicksilver: I do agree Hoare logic concerns state changes and these kind of complications are something we're free of in pure FP of course (thankfully :P )
08:16:19 <donri> Phlogistique: that anything like the "boomerang" package?
08:16:53 <Phlogistique> donri: ...yes!
08:17:10 <companion_cube> reasoning about haskell may not be particularly simple, though, you have to provide proof that you terminate despite (maybe) infinite values
08:17:25 <ski> watermind : well, i was just imagining that sometimes it could be nice to state for a function that if some condition holds on its result, then some other condition must hold for the input -- thereby turning your "given arguments satisfying these (pre) conditions the resul will satisfy this (post) condition" on its head :)
08:17:32 <quicksilver> Phlogistique: also http://hackage.haskell.org/package/invertible-syntax
08:18:00 <donri> also Zwaluw, which boomerang is a generalization of
08:18:17 <watermind> quicksilver: that said to specify say, a linear search in a sorted list, what you'd do is specify that the argument is a sorted list (pre condition), and the result is true if the element is in the list and false if it isn't (post)... I'm not sure how pure FP would make this any simpler
08:18:31 <watermind> quicksilver: maybe I'm not understanding what you mean
08:18:38 <quicksilver> watermind: sure. But that is a pure function you're specifying.
08:18:40 * hackagebot hat 2.7.0.2 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.2 (OlafChitil)
08:18:48 <quicksilver> so the specification will indeed be the same in either case :)
08:18:53 <watermind> ski: yes that's what I meant by least preconditions
08:19:16 <quicksilver> the tricky thing in the state-modifying setting is how do you specify "And nothing else changes"
08:19:23 <ski> watermind : i'm not sure where the "least" comes in
08:19:34 <quicksilver> whichis the frame problem
08:19:54 <companion_cube> well, with frame axioms :)
08:20:09 <Phlogistique> donri, quicksilver: thanks!
08:20:22 <watermind> quicksilver: yes I think we agree with everything, it's just a matter of terminology, I call those specifications pre and post conditions (not wanting implying any sort of hoare logic system or anything of the sort)...
08:22:51 <watermind> ski: sorry it's not "least" it's "weakest"
08:22:54 <watermind> ski: my bad
08:23:02 <ski> same question remains
08:23:21 <Phlogistique> donri, quicksilver: no Boomerang.ByteString though. Is it a good idea implementing one for binary data manipulation?
08:23:42 * hackagebot catch-fd 0.2.0.2 - MonadThrow and MonadCatch, using functional dependencies  http://hackage.haskell.org/package/catch-fd-0.2.0.2 (AndySonnenburg)
08:23:44 * hackagebot monarch 0.8.1.1 - Monadic interface for TokyoTyrant.  http://hackage.haskell.org/package/monarch-0.8.1.1 (NoriyukiOhkawa)
08:23:45 <Phlogistique> Also, is there any rationale wrt Boomerang vs. invertible-syntax?
08:23:52 <donri> Phlogistique: possibly; talk to stepcut
08:23:52 <watermind> ski: well when you compute the necessary condition on your inputs you want it to be as weak as possible, otherwise you've got some junk there...
08:23:53 <ski> watermind : two examples : `forall x y. x == y = True => x = y',`forall x. even (square x) = True => even x = True'
08:24:26 <ski> (in the first case, the function is `(==)', in the second case it's `square')
08:24:28 <quicksilver> ski: weakest precondition gives you the most "powerful" function
08:24:42 <quicksilver> you want permission to apply your function to the largest possible set of input states.
08:24:45 <quicksilver> I should say 'procedure'
08:24:58 <ski> ok
08:25:14 <ski> i don't see what that has to do with the reversed implication, though
08:25:22 <merijn> Cale: Did you see my haskell-ish description?
08:25:29 <quicksilver> Pierce explains better than I http://www.cis.upenn.edu/~bcpierce/sf/Hoare.html
08:25:41 <quicksilver> ski: I'm afraid I'm only following 32% of the conversation.
08:25:51 <quicksilver> ski: I may be guilty of uttering irrelevant truths.
08:25:57 <Phlogistique> donri: thanks.
08:26:22 <donri> Phlogistique: is the format not generic?
08:26:23 <ski> quicksilver : possibly the same (first sentence) is true for me, too ..
08:27:01 <Cale> merijn: Maps are functions whose domain is a finite set
08:27:16 <Cale> merijn: you can describe functions in terms of one another in lots of ways...
08:28:03 <ski> quicksilver : it appears watermind is seeing some connection to "least preconditions" in my "head turning" "counterexample" of a proposition about a function (headturning in that the implication goes from a property of the function result to a property of the function argument)
08:28:11 <watermind> ski: I think I got you
08:28:23 <watermind> ski: so you are inferring 'some property on the input'
08:28:38 <ski> i'm not inferring anything
08:29:01 <watermind> ski: `forall x. even (square x) = True => even x = True'     isn't that inferring that x must be True?
08:29:31 <watermind> ski: s/x/even x
08:29:32 <merijn> Cale: I have no clue about convenient notations for describing functions, though. (Well, other than exhaustive enumeration)
08:29:47 <ski> that's stating the property that if the square of an integer is even, then the number must also be even
08:30:07 <ski> it's an example of `forall x. Q (f x) => P x'
08:30:18 <Phlogistique> 17:25:58 < donri> Phlogistique: is the format not generic <- what format?
08:30:21 <watermind> ski: exactly, so it's inferring, from a property on the ouptut, a necessary condition in the input
08:30:28 <donri> Phlogistique: that you're parsing/printing
08:30:36 <Phlogistique> no it isn't
08:30:45 <Phlogistique> It's data
08:30:48 <Phlogistique> hum
08:30:53 <ski> watermind : *using* that proposition could be inferring. the proposition itself just is, it doesn't do anything
08:30:56 <donri> a lot of data is generic :)
08:31:02 <Phlogistique> I hit enter too early :)
08:31:26 <ski> watermind : also, by "inferring" i thought you were asking whether i was inferring *what* proposition `P' to use here
08:31:49 <Phlogistique> donri: What I'm seeking to replace is the kind of things you would do with C bitfields
08:32:01 <donri> i don't speak C
08:32:08 <Phlogistique> I find the typical solutions in other languages rather inelegant
08:32:11 <watermind> ski: gotcha
08:32:21 <ski> (watermind : iow, given a property on the result of a function "infer the weakest property on the argument that implies the former" -- or something like that)
08:32:39 <watermind> ski: yes that is exactly what I was thinking about
08:32:49 <donri> the binary package is best for binary data, but if the data isn't structured generically you'd have to write the encoding and decoding functions separately
08:33:08 <Soultaker> I have a recursive function that looks something like:
08:33:10 <Soultaker>   run []   = return someValue
08:33:10 <Soultaker>   run list = (someTransformation list) >>= run
08:33:11 <Phlogistique> donri: in C, you can define a datatype and its memory layout in a very concise and straightforward way
08:33:23 <Soultaker> is there a more high-level way to express this?  It looks like it should be a somewhat common pattern.
08:33:26 <Phlogistique> donri: what do you mean "structured generically"?
08:33:29 <donri> though, something like boomerang+binary might be an interesting idea
08:33:32 <ski> well, that's a different sense of "infer" than already being given the whole proposition `forall x. Q (f x) => P x', and then knowing that `Q (f t)' is true, *infer* that `P t' must also be true
08:33:40 <nand`> Phlogistique: Haskell also has well-behaved bidirectional lenses, Control.Lens.Iso :P
08:33:41 <ski> watermind ^
08:34:09 <donri> Phlogistique: i mean e.g. an integer is always represented the same way etc
08:34:32 <watermind> ski: yes true, I was thinking of the former rather than the latter
08:34:40 <nand`> Haskell doesn't have a concept of memory, what should it have a concept of memory layout?
08:34:45 <nand`> why*
08:34:46 <ski> @hoogle until
08:34:46 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
08:34:49 <ski> @hoogle untilM
08:34:50 <lambdabot> No results found
08:35:06 <efie> I want to read a file and format its input. Regarding efficiency, it is better to do several maps and filters or to use Parsec? I prefer  Parsec as I know then that the file's input really is structured the way I need it, but I'd like to know if its (as) efficient for large input files (as "basic" functions like maps, etc.?)
08:35:15 <nominolo> anyone know of a Cabal package that binds to C++?
08:35:17 <ClaudiusMaximus> ski: http://www.haskell.org/hoogle/?hoogle=untilM+%2Bmonad-loops
08:35:21 <donri> Phlogistique: you can derive the encoder and decoder for binary with generics or templates, but that doesn't work well if the data isn't structured generically
08:35:22 <nominolo> i'm looking for an example
08:35:27 <ski> Soultaker : i you can't find any, i suppose you could define `untilM :: Monad m => (a -> m Bool) -> (a -> m a) -> (a -> m a)'
08:35:43 <Phlogistique> donri: oh, that's something I missed
08:36:01 <ski> or `untilM :: Monad m => (a -> m (Either b a)) -> (a -> m a) -> (a -> m b)' or something
08:36:03 <donri> Phlogistique: that's sort of the use case for boomerang; parsing/printing of arbitrary syntax/structures
08:36:12 <quicksilver> donri: that part of the problem has kind of been solved by aeson, though?
08:36:16 <Soultaker> ClaudiusMaximus, ski: thanks, that looks usuable!
08:36:33 <donri> quicksilver: how?
08:36:42 <quicksilver> donri: I mean they've worked through the general notion of abstracting the relationships between haskell types and semi-structured (a.k.a. generic) representations.
08:36:53 <ski> watermind : "so it's inferring, from a property on the ouptut, a necessary condition in the input" seemed to be you thinking of the latter -- but i probably misinterpreted you
08:36:55 <quicksilver> donri: they happen to use JSON for the final step, but that is conceptually seperate
08:37:01 <quicksilver> final step could have been something else.
08:37:10 <donri> quicksilver: these are all solved problems. duno aeson
08:37:24 <quicksilver> ok :) well it's probably the same as what you said, then.
08:39:33 <atriq> Has there been a big Haskell thing since the lens package?
08:39:37 <augur> ski: that string diagram stuff behaves weirdly for classical SC
08:40:50 <donri> atriq: ghc 7.6? :P
08:40:59 <atriq> Okay, yeah
08:40:59 <atriq> That
08:41:12 <ski> ClaudiusMaximus : it seems none of the ones there fit Soultaker's case that closely
08:41:17 <atriq> Just it seems everyone was all "wow, lenses" for a while
08:41:20 <atriq> And it seems to have died down?
08:41:46 <merijn> atriq: No, lenses are still wow :)
08:41:51 <ski> augur : ?
08:41:53 <merijn> But now most people already know about them ;)
08:41:59 <atriq> Oh, that makes sense
08:42:03 <donri> lenses, that's so yesterday
08:42:13 <augur> ski: if you do it with the classical sequent calculus, you possibly get disconnected diagrams
08:42:22 <atriq> I've worked out what's up with Lens, Getter, and Setter, and maybe Iso
08:42:24 <atriq> The others, not so much
08:42:39 <watermind> ski: yes that's it, and typically when we do that we want the weakest condition on the input... therefore calling it the "weakest pre condition"
08:43:23 <watermind> ski: that was my guess when I saw your thought bubble, but I understand now that's not what you were thinking about
08:43:30 <ski> augur : by "string diagram" you mean the arrows back and forth on your sentence ?
08:44:08 <ski> watermind : yes, but i think "weakest pre condition" applies to the `forall x. P x => Q (f x)' case, no ?
08:44:12 <augur> ski: the string diagrams we talked about back in august! for deriving syntax of ITT/IL from the proof theory!
08:44:16 <smash> hello all.. any known format suggestion moduleto use for persistent data in a Hasekll program? (maybe json or xml in a text file)
08:45:23 <ski> augur : this was from some paper draft of yours ?
08:45:34 <watermind> ski: yes, you're right the implication would be in that direction of couse... your notation was pretty clear but I wasn't reading it formally (which I always should do in this channel :P )
08:45:41 <augur> ski: nah, we were just talking about graph representations of proofs instead of tree representations
08:45:51 * ski vaguely recalls talking with augur about something in august, but can't recall details
08:45:54 <augur> :(
08:46:04 <watermind> ski: I was just reading the arrow as something you want to compute, not as logical implication
08:46:04 <augur> we talked for like hours and hours and hours!
08:46:16 <augur> ski: and i wrote a Curry-Howard tutorial and everything!
08:46:26 <ski> (i.e. if you remind me what we talked about, i probably can recall talking about it, but i can't connect it to the specific time)
08:46:27 <watermind> ski: Q (f x ) == compute some condition ==> P x
08:46:43 <ski> watermind : ok, i see
08:47:08 <ski> watermind : iiuc, one of the main reasons for this in Hoare logic is that the rule for assignment is "backwards"
08:47:09 <efie> smash: do you want to use a database?
08:47:14 <augur> ski: it was just about graph proofs and stuff. you told me about this book about multiple-conclusion logic or something like that too
08:47:31 <ski> oh, those
08:48:04 <smash> efie: using a databse would be plan B, I would prefer something that uses a plain text file
08:48:19 <augur> ski: msggg
08:48:34 <ski> augur : but i'm not sure how this connects to string diagrams. perhaps this is because i'm not quite sure what a "string diagram" is
08:49:07 <watermind> ski: yes that's my understanding too
08:52:03 <efie> smash: sorry, I can't tell you anything about this
08:52:29 <applicative> smash the json library aeson is very easy to use and fast
08:52:34 <applicative> @where aeson
08:52:35 <lambdabot> I know nothing about aeson.
08:52:49 <applicative> duh
08:52:55 <maukd> @hackage aeson
08:52:55 <lambdabot> http://hackage.haskell.org/package/aeson
08:53:20 <applicative> https://github.com/bos/aeson and hackage
08:55:15 <smash> applicative: that is a n option, can it infer the JSON format from the data type definitions?
08:56:10 <applicative> smash, yes it uses a template haskell incantation, see the micro example -- https://github.com/bos/aeson/blob/master/examples/TemplateHaskell.hs
08:56:11 <Cale> augur: are you talking about string diagrams in the same sense as the string diagrams for a weak 2-category?
08:56:40 <augur> Cale: a little bit but not quite
08:58:31 <smash> applicative: very nice, I will take a look, thank you
08:58:42 * hackagebot haskelldb 2.2.1 - A library of combinators for generating and executing SQL statements.  http://hackage.haskell.org/package/haskelldb-2.2.1 (JustinBailey)
09:08:43 * hackagebot alpha 0.9.0.2 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9.0.2 (MarcCoiffier)
09:12:20 <applicative> smash: here's a complicated example with handwritten instances https://github.com/MichaelXavier/Campfire/blob/master/Web/Campfire/Types.hs
09:13:43 * hackagebot alpha 0.9.0.3 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9.0.3 (MarcCoiffier)
09:15:55 <strebe> Cale: http://scienceblogs.com/goodmath/2006/06/19/category-theory-natural-transf/ seems to be a particularly concise yet readable explanation of natural transformations (I stumbled across it by chance, not looking for natural transformation stuff) :-)
09:17:06 <Cale> yep
09:18:51 <Cale> strebe: Really, that's pretty much all there is to it -- you have some collection of arrows which go between the images of the two functors, and they "commute" with applications of the functors to arrows.
09:19:28 <Cale> strebe: Here's an example in Haskell. Suppose you have a datatype like some parametric tree type:
09:19:37 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
09:19:42 <Cale> instance Functor Tree where
09:19:47 <Cale>   fmap f Tip = Tip
09:19:55 <strebe> Cale: yes, but this is by far the most clear explanation I've seen of it, although I got it already - I'm now reading the previous article on functors in hopes that they end up clicking too
09:20:04 <Cale>   fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmal f r)
09:20:22 <Cale> So this Tree is a functor on our category of Haskell types and functions
09:20:47 <Cale> The mapping on objects is provided by Tree itself -- it sends each type t to a type Tree t of trees of values of type t
09:21:08 <Cale> and the mapping on arrows is provided by  fmap :: (a -> b) -> (Tree a -> Tree b)
09:21:13 <Cale> yeah?
09:21:21 <Cale> Now consider a function like:
09:21:27 <Cale> inorder :: Tree a -> [a]
09:21:37 <Cale> which does an inorder traversal of the tree structure
09:21:43 <Cale> something like:
09:21:47 <Cale> inorder Tip = []
09:22:00 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
09:22:21 * strebe nods
09:22:24 <Cale> (that's not as efficient as it could be, but that's not the point I'm worrying about)
09:22:40 <Cale> Now, the type constructor for lists is also a functor
09:22:48 <Cale> and fmap for that functor is just map
09:23:00 <Cale> fmap :: (a -> b) -> ([a] -> [b])
09:23:09 <strebe> yeah; "real world haskell" mentions that briefly
09:23:12 <Cale> inorder has a nice property
09:23:24 <Cale> inorder . fmap f = fmap f . inorder
09:23:30 <ocharles> is there anyway to write 'instance (FromRow a, FromField (Ref (Revision a))) => FromRow (CoreEntity a)' without resorting to UndecidableInstances? Sadly, I still it seems I still don't quite understand type class instance resolution
09:23:30 <smash> applicative: thks, trying the "derived instances" first
09:23:42 <tac> @kind ([])
09:23:43 <lambdabot> * -> *
09:23:47 <tac> @kind ([]) -> Either
09:23:48 <lambdabot>     `[]' is not applied to enough type arguments
09:23:49 <lambdabot>     Expected kind `??', but `[]' has kind `* -> *'
09:23:49 <lambdabot>     In the type `([]) -> Either'
09:23:51 <Cale> Haskell's notation is very quiet, all the types involved are not mentioned here :)
09:23:58 <ocharles> oh wait
09:24:07 <Cale> but this is exactly the requirement for inorder to be a natural transformation
09:24:14 <ocharles> this is my bad because I don't have instances of FromField (Ref (Revision a)) anywhere! oops.
09:24:19 <Cale> for each type a, it provides a map  Tree a -> [a]
09:24:28 <Cale> between the images of these two functors
09:24:52 <strebe> ahhh, its composability with fmap? I can see how the two definitions would represent the two paths around the square
09:25:19 <Cale> fmap f is the same thing as Ff or Gf in the category theoretical notation, where the functor involved is made implicit
09:25:58 <ski> strebe : yes, the point is that `inorder' doesn't care about the *elements* of the tree -- so it doesn't matter if we swap the elements before, with `fmap' on `Tree', or after, with `fmap' on `[]'
09:26:39 <strebe> ski: yes, aka it's an instance of a natural transformation
09:27:32 <ski> given `inorder_A : Tree A -> [A]' we can say `inorder : Tree -> []', which doesn't mention `A'
09:27:33 <Cale> strebe: There *might* be natural transformations between Haskell functors which aren't completely polymorphic like this, but it would be hard to write them as ordinary functions in Haskell. I also don't know of any examples of them.
09:28:34 <strebe> Cale: i'll need to start thinking in terms of them; do you know any small bits of haskell code that use them particularly heavily? :)
09:29:05 <Cale> But the implication in the other direction works nicely: for any two functors F and G, any polymorphic function forall a. F a -> G a is a natural transformation
09:29:20 <strebe> cool :)
09:29:39 <quicksilver> Cale: well a natural transformation composed with a natural isomorphism is a natural transformation
09:30:08 <quicksilver> Cale: so if you restrict to types which have obvious automorphisms it should be easy to construct examples
09:30:13 <Cale> hmm
09:30:18 <quicksilver> can't see a canoncial way of doing that over all types though
09:30:25 <Cale> yeah, it's tricky
09:30:25 <quicksilver> (and functors apply to "All types" always)
09:30:29 <Cale> right
09:39:42 <rwbarton> well here is a really lame "example"
09:39:58 <hpaste> efie pasted “Parsec Problem” at http://hpaste.org/76193
09:40:08 <efie> can someone help me with this?
09:40:47 <rwbarton> if I have data Stream a = Stream a (Stream a), and a !! n is the nth element of the Stream, then given f :: Nat -> Nat I get a natural transformation g :: Stream a -> Stream a where (g xs) !! n = xs !! (f n)
09:41:17 <rwbarton> but, even when f is not a computable function I still have such a natural transformation that I just can't write in Haskell
09:42:08 <pckt> efie: http://www.haskell.org/haskellwiki/Data.List.Split spliton
09:43:43 * hackagebot haskelldb-dynamic 1.0.0 - HaskellDB support for the dynamically loaded drivers.  http://hackage.haskell.org/package/haskelldb-dynamic-1.0.0 (JustinBailey)
09:43:45 * hackagebot haskelldb-flat 1.0.1 - An experimental HaskellDB back-end in pure Haskell (no SQL)  http://hackage.haskell.org/package/haskelldb-flat-1.0.1 (JustinBailey)
09:48:44 * hackagebot yesod-text-markdown 0.1.0.0 - Yesod support for Text.Markdown.  http://hackage.haskell.org/package/yesod-text-markdown-0.1.0.0 (ArashRouhani)
09:48:46 * hackagebot highlighting-kate 0.5.3.3 - Syntax highlighting  http://hackage.haskell.org/package/highlighting-kate-0.5.3.3 (JohnMacFarlane)
09:48:54 <efie> pckt:  I'm not sure how this helps me, could you explain it?
09:49:03 <Cale> rwbarton: are you sure? The components of a natural transformation have to be Haskell functions.
09:49:43 <rwbarton> well, okay
09:49:54 <rwbarton> you would need to be a lot more precise about what you think "Hask" is
09:50:06 <rwbarton> before you can try to even ask this question
09:50:32 <hpaste> newbiee pasted “code not working” at http://hpaste.org/76196
09:50:32 <nand`> “the category of haskell functions under (.)” isn't precise enough?
09:50:47 <rwbarton> haha no
09:51:10 <pckt> efie: splitOn(==" ") YOURSTING would return a list of char split by " ", you just then need to filter the list by characters matching [a-z]
09:51:14 <rwbarton> e.g., what exactly are the objects
09:51:16 <rwbarton> this is a big mess
09:51:30 <ski> do we only count total functions ? if not, is `seq' included ?
09:52:02 <n-dolio> Objects are haskell types.
09:52:08 <rwbarton> what is a haskell type
09:52:21 <rwbarton> like can you give a set-theoretic definition of the set of haskell types
09:52:29 <nand`> I would think the objects are irrelevant; only some arbitrary set that directly corresponds to which compositions typecheck
09:53:00 <killy9999> how do I define instances of others' type classes so that they are not orphans?
09:53:33 <killy9999> I found some advices on using newtype, but I don't know how should I use it :/
09:53:42 <nand`> killy9999: by defining it in the same module as the type, I guess
09:54:40 <quicksilver> killy9999: don't worry about them being orphans
09:55:19 <newbiee> can someone look at my post 76196 and help me fix my code?
09:55:22 <efie> pckt: but if the string is not structured the way I want it to be, I don't want to filter anything, I'd like to know that the syntax is wrong / that parsing failed, like Parsec says
09:55:23 <rwbarton> ultimately I think you cannot give really precise definitions anyways because (.) will fail to be unital etc.
09:55:28 <efie> so I guess this function does not help me
09:55:29 <killy9999> nand`: I can't, I declare instances of classes that are not from my module
09:55:48 <rwbarton> > (id . undefined) `seq` ()
09:55:49 <lambdabot>   Ambiguous type variable `f' in the constraint:
09:55:49 <lambdabot>    `GHC.Base.Functor f'
09:55:49 <lambdabot>     ...
09:55:51 <killy9999> quicksilver: I've seen some pretty convincing advice NOT to ignore them
09:55:55 <rwbarton> > (id . undefined :: Int -> Int) `seq` ()
09:55:57 <lambdabot>   ()
09:56:09 <killy9999> so the question is how to use newtype so that the problem does not arise
09:56:20 <n-dolio> Get rid of seq.
09:56:27 <rwbarton> okay, that is a start
09:56:39 <n-dolio> This is not a new revelation, really.
09:56:43 <hpaste> killy9999 pasted “killy's instances” at http://hpaste.org/76198
09:56:47 <rwbarton> no, of course not
09:56:56 <quicksilver> create your own types, killy9999, and make instances of *those* instead of instances of the original type
09:57:04 <donri> killy9999: there's basically only one way to use newtypes, so not sure what you're asking
09:57:11 <quicksilver> killy9999: but honestly, orphan instances are not a problem in application code
09:57:17 <quicksilver> they're a slight issue in libraries that's all
09:57:28 <Cale> killy9999: If C is a type class, and T is a type, the instance C T is considered an orphan when it is in a module where neither the class C nor the type T it involves are defined.
09:57:28 * killy9999 is writing a library
09:57:40 <n-dolio> If you want to get really particular, you probably have to close some universe of data types that you care about for any program.
09:57:42 <rwbarton> I am just saying any question like "does every natural transformation in my model of Haskell come from an actual polymorphic function" is doomed because you have to introduce approximations in the model anyways
09:57:47 <rwbarton> n-dolio, yes
09:58:01 <n-dolio> But anything you talk about will be closed under arbitrary extension by other data types that are acceptable.
09:58:02 <rwbarton> so Hask depends on the set of newtype/data declarations in the program
09:58:09 <JL_> i find it weird that (max 1) 2 is actually max :: (Ord a) => a -> (a -> a)
09:58:19 <killy9999> quicksilver: but if I create newtypes won't I be forced to use them everywhere in my code?
09:58:25 <killy9999> not only in the testing part?
09:58:28 <n-dolio> So that isn't really an interesting limitation.
09:58:32 <JL_> instead of (a -> a) -> a
09:58:33 <efie> newbiee: "show x" instead of just "x", you need to turn it into a string
09:58:43 <donri> killy9999: you'll have to use the new type when you want to use the instance defined for that type, yes
09:58:44 <efie> in the Left ( ...)
09:58:45 <Cale> killy9999: What instance are you defining?
09:58:51 <n-dolio> "... will be valid ..."
09:59:23 <killy9999> Cale: http://hpaste.org/76198
09:59:30 <quicksilver> Cale: he's trying to define an Arbitrary instance for a REPA type
09:59:39 <quicksilver> I'm really not sure why you think the orphan matters, killy9999
09:59:40 <killy9999> exactly
09:59:52 <quicksilver> but you could not bother with Abitrary at all, and just use 'forAll'
09:59:54 <Cale> Oh, then a newtype is perfect
09:59:56 <quicksilver> it's just a little more verbose
10:00:14 <Cale> because in your QuickCheck tests, you can just pattern match away the newtype constructor
10:00:16 <killy9999> quicksilver: http://stackoverflow.com/questions/3079537/orphaned-instances-in-haskell
10:00:23 <killy9999> I guess this convinced me
10:00:27 <newbiee> efie "show x" as in squareRoot (show x)?
10:00:30 <donri> killy9999: for Arbitrary, orphans are pretty much standard
10:01:02 <killy9999> quicksilver: how should I use forAll?
10:01:06 <Sculptor> hi!
10:01:07 <Cale> killy9999: So long as this Arbitrary instance is in the code you're using to *test* the library, and not in the library itself, you should be fine :)
10:01:21 <Cale> But yeah, you could also use forAll :)
10:01:39 <donri> yea, the main problem is that instances "leak", but you're unlikely to import from the test suite, or define Arbitrary instances outside the test suite
10:01:47 <n-dolio> rwbarton: If you come up with a functor that can't be written in Haskell, I imagine that would give rise easily to natural transformations that can't be written as polymorphic functions in Haskell pretty easily.
10:01:49 * killy9999 looks at forAll haddock and tries to understand how it works
10:01:54 <n-dolio> I don't know if that's within the rules of the contest.
10:01:54 <Cale> forAll :: (Show a, Testable prop) => Gen a -> (a -> prop) -> Property
10:02:06 <newbiee> efie thanks got it :)
10:02:06 <kirindave> You know, I love #haskell. #haskell is awesome.
10:02:13 <kirindave> But sometimes I wish there was a #haskell-in-industry.
10:02:19 <Cale> killy9999: so you provide an explicit generator (like the code you've written for arbitrary)
10:02:19 <Cale> killy9999: and a property
10:02:21 <rwbarton> I think they were supposed to be Haskell Functors (i.e. data constructors)
10:02:28 <rwbarton> uh type constructors
10:02:28 <n-dolio> Oh well.
10:02:32 <Cale> (well, a function giving a property)
10:02:33 <quicksilver> yitz's arguments don't apply to you killy9999
10:02:48 <killy9999> Cale: but that does not relieve me from writing an Arbitrary instance?
10:02:55 <Cale> killy9999: Why not?
10:02:57 <quicksilver> you are not going to 'suddenly find' that some other library you use 'suddenly starts providing' an Abitrary instance
10:03:05 <quicksilver> and if you did find that, it's ust a bug and you fix it.
10:03:09 <Cale> killy9999: the type a here will be  (Array U DIM1 Double)
10:03:18 <quicksilver> no different from any other bug you might get if another library 'suddenly' does something different.
10:03:32 <efie> newbiee: you're welcome :)
10:03:34 <Cale> killy9999: Do you have the code of the property you're trying to check?
10:03:45 <killy9999> sure
10:03:46 <Cale> We can rewrite it to use forAll
10:03:54 <n-dolio> Man, I said "easily" twice in there.
10:04:02 <killy9999> give me a sec
10:04:38 <hpaste> killy9999 annotated “killy's instances” with “killy's instances (annotation)” at http://hpaste.org/76198#a76199
10:04:40 <quicksilver> you can make an argument that 'Abitrary' is a poor typeclass anyway and that using forAll is a better idea.
10:04:49 <quicksilver> admittedly Arbitrary is convenient.
10:05:01 <bos> preflex: seen kmett
10:05:01 <preflex>  Sorry, I haven't seen kmett
10:05:16 <quicksilver> but it's more convenient for simple types where there is obviously only one sensible generator - for more complex types, forAll is much more plausible
10:05:24 <quicksilver> forAll'ed gens can be parameterised.
10:05:31 <quicksilver> preflex: seen edwardk
10:05:31 <preflex>  edwardk was last seen on #haskell 10 hours, 58 minutes and 6 seconds ago, saying: e.g. dataChar = noneOf "<&>" <?> "character"
10:05:33 <quicksilver> bos ^^
10:05:34 <Cale> propPairsIdentity1 = forAll myGenerator (\xs -> (even . size . extent $ xs) ==> computeS (fromPairs (toPairs xs)) == xs)
10:05:41 <n-dolio> bos: He's sick today.
10:05:51 <hpaste> newbiee pasted “rewrite function” at http://hpaste.org/76200
10:06:01 <killy9999> and myGenerator is?
10:06:04 <nand`> when I'm sick, I spend more time than usual on IRC :P
10:06:18 <newbiee> efie I have another question, how do I rewrite the function in my post 76200?
10:06:30 <n-dolio> He might actually be sleeping. Or at the doctor.
10:06:31 <Cale>   where myGenerator = do el <- listOf1 $ ... ...
10:06:45 <killy9999> I see
10:06:51 <killy9999> makes sense
10:06:53 <bos> n-dolio: ah
10:07:12 <killy9999> I guess I'll have to rethink that, but I get the point
10:07:16 <killy9999> thanks guys!
10:07:17 <hpaste> Cale annotated “rewrite function” with “rewrite function (annotation)” at http://hpaste.org/76200#a76201
10:07:23 <bos> apparently he's visiting the bay area next week, just as i leave for a bit :-(
10:07:31 <n-dolio> Yeah.
10:07:41 <Cale> newbiee: ^^
10:08:20 <killy9999> though I think that defining Properties relying on Arbitrary instance is slightly less verbose
10:08:27 <Cale> newbiee: also, in the non-recursive case, your special casing of the empty list is redundant
10:08:46 <Cale> newbiee: if ls = [], then zip [] (map f []) = []
10:09:06 <shachaf> bos: When do you get back?
10:09:21 <bos> shachaf: week after next
10:09:25 <newbiee> cale: ah .. ok... thanks... let me try to fix it
10:09:44 <Cale> newbiee: you can just delete that line and it'll still work
10:09:59 <Cale> newbiee: so simply   combine f ls = zip ls (map f ls)
10:10:49 <Cale> newbiee: yet another way to write this function is  combine f ls = [(x,f x) | x <- ls]
10:12:32 <newbiee> cale actually the function take 2 argument a function and a list, if the list is empty, without the ls = [] it will give this error : ERROR - Unresolved overloading
10:13:43 <Cale> newbiee: what?
10:14:08 <Cale> > let combine f ls = zip ls (map f ls) in combine (*2) []
10:14:10 <lambdabot>   []
10:14:13 <Cale> seems to work
10:14:16 <newbiee> cale for example if we do, combine succ []
10:14:22 <Cale> > let combine f ls = zip ls (map f ls) in combine succ []
10:14:23 <lambdabot>   []
10:14:37 <newbiee> ha
10:14:40 <newbiee> that's funny
10:16:02 <shachaf> @ty map . ap (,)
10:16:03 <lambdabot> forall a a1. (a -> a1) -> [a] -> [(a, a1)]
10:16:39 <latro`a_> > (map . ap (,)) (+1) [1..10]
10:16:41 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
10:16:44 <latro`a_> \o/
10:16:46 <latro`a_> neat
10:16:59 <newbiee> cale: i try it in hugs and it kept giving me this error: ERROR - Unresolved overloading *** Type       : Enum a => [(a,a)] *** Expression : combine succ []
10:17:49 <b__> is there an easy/newb-friendly explanation for what forall is, or should I go go read the relevant articles at haskell.org to find out for myself? (I don't mind either)
10:18:09 <shachaf> @google mainisusuallyafunction quantification
10:18:11 <lambdabot> http://topsy.com/s?q=mainisusuallyafunction.blogspot.com
10:18:11 <lambdabot> Title: mainisusuallyafunction.blogspot.com – Topsy
10:18:15 <shachaf> Bah.
10:18:15 <quicksilver> b__: well to start with, it's not part of haskell
10:18:21 <shachaf> @google mainisusuallyafunction quantification forall
10:18:21 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
10:18:25 <quicksilver> it's an extension
10:18:27 <shachaf> quicksilver: No, but it should be!
10:18:35 <b__> I see it quite often though
10:18:45 * hackagebot sgd 0.2.2 - Stochastic gradient descent  http://hackage.haskell.org/package/sgd-0.2.2 (JakubWaszczuk)
10:18:46 <quicksilver> a haskell type signature like "map :: (a -> b) -> [a] -> [b]"
10:18:50 <b__> shachaf: thanks, I will read this article :]
10:18:57 <quicksilver> carries with it implicitly the idea that that works for all possible types a and ba
10:19:06 <quicksilver> b__: ^^ hopefully you are fmailiar with that idea?
10:19:12 <b__> yes :]
10:19:21 <kirindave> shachaf: That map . ap (,) is hurting my head-insides.
10:19:25 <quicksilver> well "forall" int he first place is jsut a way to make that explicit.
10:19:27 <quicksilver> :t map
10:19:28 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:19:35 <shachaf> kirindave: ap x y z = x z (y z)
10:19:39 <quicksilver> ^^ lambdabot has the extension turned on, so it writes the 'forall'
10:19:43 <quicksilver> but it's the *same thing*
10:19:57 <quicksilver> so, haskell says you can omit the forall, but an extension lets you write it if you want to.
10:20:17 <shachaf> It gets interesting when you start writing foralls at places other than right next to the ::
10:20:20 <quicksilver> Why would you want to? Well, because if you want to put it inside parens it actualy makes something different.
10:20:30 <quicksilver> these are called 'higher-rank' types
10:20:34 <quicksilver> and once again they're not haskell
10:20:39 <killy9999> how can I tell quickCheck "give me any Double"
10:20:41 <quicksilver> but they're a popular - useful - extension.
10:20:44 <shachaf> forall is used for a lot of other things too.
10:20:50 <b__> but what is the advantage of declaring the type with forall?
10:20:57 <shachaf> Existential types, scoped type variables, and so on.
10:20:58 <quicksilver> there is none, b__
10:21:03 <killy9999> I use choose(-100,100) :: Gen Double
10:21:04 <hpaste> JL pasted “Counter_Intuitive function types” at http://hpaste.org/76202
10:21:08 <shachaf> b__: There isn't much of one when it's also a type you can write without the forall.
10:21:08 <kirindave> shachaf: I thought it was m (a -> b) -> m a -> m b?
10:21:08 <b__> I often see forall in signatures
10:21:12 <shachaf> Other than being more explicit.
10:21:16 <shachaf> kirindave: m = (r ->)
10:21:19 <killy9999> but that's not exactly waht I want
10:21:21 <b__> but when I put it without forall, it compiles just as well
10:21:21 <kirindave> shachaf: Or is that just its interpretation in ->
10:21:31 <newbiee> let combine f ls = zip ls (map f ls) in combine (sqrt) []
10:21:37 <shachaf> kirindave: Also known as "S".
10:21:59 <S11001001> :t second
10:22:00 <newbiee> let combine f ls = zip ls (map f ls) in combine (succ) []
10:22:01 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
10:22:01 <shachaf> b__: Usually those foralls are implied.
10:22:20 <shachaf> Some uses of forall aren't implied, but probably none that you'd get from lambdabot.
10:22:25 <b__> it is not haskell-like to write down something that does not \do -> something
10:22:25 <kirindave> shachaf: Using the monad functions in the (r ->) context always throws me for a loop.
10:22:40 <shachaf> kirindave: Loop? Who said anything about MonadFix?
10:22:45 <b__> so why do people use it?
10:22:50 <kirindave> shachaf: Womp womp.
10:23:03 <shachaf> b__: It's more explicit.
10:23:33 <shachaf> A type signature has all sorts of not-really-explicit information.
10:23:47 <b__> but is it just a piece of information, or does it change how code is compiled/run?
10:23:52 <shachaf> For example whether a word starts with a lowercase or uppercase letter.
10:23:55 <b__> is it for humans or the compiler?
10:23:59 <shachaf> It's for humans.
10:24:20 <b__> okay, but could I write forall in a type signature when it is not true?
10:24:28 <shachaf> What does that mean?
10:24:40 <newbiee> Does anyone knows why this code " combine f ls = zip ls (map f ls) " give this error ERROR - Unresolved overloading *** Type       : Enum a => [(a,a)] *** Expression : combine succ [] in hugs?
10:24:42 <b__> well, I guess that means no
10:24:53 <n-dolio> Cale, rwbarton: So, here's an idea. A natural transformation that could be written using a polymorphic function, but actually uses type information to compute the same function differently at different types.
10:25:12 <shachaf> b__: The "outermost" foralls, the type that lambdabot gives you that you could drop anyway, are mostly there for humans. Other uses of forall change the semantics of the program so they do more than that.
10:25:22 <n-dolio> That sort of assumes that you're not taking morphisms to be equivalence classes of programs that compute the same function, but rather the expressions themselves.
10:25:30 <shachaf> newbiee: Give succ an explicit type signature.
10:25:40 <shachaf> newbiee: Also, use GHC instead of Hugs.
10:25:42 <b__> ah ok shachaf
10:25:43 <b__> :]
10:25:52 <b__> time to read up on it
10:26:17 <newbiee> shachaf why does it work in ghc and not hugs?
10:26:27 <Cale> newbiee: I'd consider that a bug in Hugs.
10:26:42 <bitonic> is there a way to generate automatic links in pandoc?
10:26:43 <rwbarton> n-dolio, I assumed equality for functions means that they are the same function on the associated DCPO
10:26:49 <shachaf> newbiee: Some kind of defaulting, maybe. It doesn't really matter -- I told you to use GHC because Hugs is old and more or less unmaintained.
10:26:51 <Cale> newbiee: Though, oh, I guess I can forgive it slightly
10:26:58 <bitonic> when generating markdown
10:27:12 <Cale> newbiee: Try this:   combine succ [] :: [Integer]
10:27:29 <n-dolio> rwbarton: Yeah, I guess that would require a much more intensional equality than normally used.
10:27:35 <n-dolio> And ruin parametricity, for instance.
10:27:37 <Cale> newbiee: It's because Hugs is not as aggressive about defaulting the types in expressions you enter
10:27:39 <newbiee> Cale, shachaf: i see.  Thank you.
10:28:13 <Cale> newbiee: ghci will default types to () in various cases where hugs will give up and complain that it doesn't know which type you mean
10:28:46 * hackagebot haskelldb-hdbc 2.2.1 - HaskellDB support for HDBC.  http://hackage.haskell.org/package/haskelldb-hdbc-2.2.1 (JustinBailey)
10:28:48 * hackagebot haskelldb-hdbc-odbc 2.1.1 - HaskellDB support for the HDBC ODBC driver.  http://hackage.haskell.org/package/haskelldb-hdbc-odbc-2.1.1 (JustinBailey)
10:28:50 * hackagebot haskelldb-hdbc-postgresql 2.1.1 - HaskellDB support for the HDBC PostgreSQL driver.  http://hackage.haskell.org/package/haskelldb-hdbc-postgresql-2.1.1 (JustinBailey)
10:28:51 <newbiee> cale: that makes sense.
10:28:52 * hackagebot haskelldb-hdbc-sqlite3 2.1.1 - HaskellDB support for the HDBC SQLite driver.  http://hackage.haskell.org/package/haskelldb-hdbc-sqlite3-2.1.1 (JustinBailey)
10:28:54 * hackagebot haskelldb-hsql 1.0.0 - HaskellDB support for HSQL.  http://hackage.haskell.org/package/haskelldb-hsql-1.0.0 (JustinBailey)
10:29:02 <Cale> newbiee: because you're using succ, and succ is implemented differently at different types, hugs demands to know which type you're using it at.
10:29:35 <Cale> newbiee: You might think that since there are no elements in the list, it shouldn't matter, but it does this before actually attempting to run the code.
10:30:01 <Cale> and because there are no elements in the list, the type of the elements which would be there is hard to infer :)
10:30:26 <Cale> So you have to tell it explicitly somehow
10:30:38 <newbiee> cale: ah, ok.
10:30:58 <n-dolio> rwbarton: Anyhow, otherwise I don't see how to do it. You need to have a family of Haskell functions that does something different at at least one type, but that would kill naturality.
10:31:04 <newbiee> cale: but there is no way you can hard code it in the function so hugs would not complain?
10:31:25 <Cale> newbiee: Not really, this is to do with succ, not with your function.
10:31:35 <n-dolio> Because I'm skeptical that you could do something different but just have it happen to work out to commuting with maps.
10:31:36 <newbiee> cale: got it. Thx.
10:31:51 <rwbarton> it does seem really hard
10:33:19 <S11001001> newbiee: are you writing a function?
10:33:40 <newbiee> yeah
10:33:56 * hackagebot haskelldb-hsql-mysql 1.0.0 - HaskellDB support for the HSQL MySQL driver.  http://hackage.haskell.org/package/haskelldb-hsql-mysql-1.0.0 (JustinBailey)
10:33:58 * hackagebot haskelldb-hsql-odbc 1.0.0 - HaskellDB support for the HSQL ODBC driver.  http://hackage.haskell.org/package/haskelldb-hsql-odbc-1.0.0 (JustinBailey)
10:34:00 * hackagebot haskelldb-hsql-oracle 1.0.0 - HaskellDB support for the HSQL Oracle driver.  http://hackage.haskell.org/package/haskelldb-hsql-oracle-1.0.0 (JustinBailey)
10:34:02 * hackagebot haskelldb-hsql-postgresql 1.0.0 - HaskellDB support for the HSQL PostgreSQL driver.  http://hackage.haskell.org/package/haskelldb-hsql-postgresql-1.0.0 (JustinBailey)
10:34:03 <nand`> can (++) be written as a fold?
10:34:04 * hackagebot haskelldb-hsql-sqlite 1.0.0 - HaskellDB support for the HSQL SQLite driver.  http://hackage.haskell.org/package/haskelldb-hsql-sqlite-1.0.0 (JustinBailey)
10:34:21 <JL_> Could someone explain to me why function types are right associative and function calls are left associative ?
10:35:19 <shachaf> @src (++)
10:35:19 <lambdabot> []     ++ ys = ys
10:35:19 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
10:35:20 <lambdabot> -- OR
10:35:22 <lambdabot> xs ++ ys = foldr (:) ys xs
10:35:35 <shachaf> JL_: Because it works out nicely. :-)
10:35:40 <n-dolio> JL_: It works out perfectly for representing multi-argument functions as functions-that-return-functions that way.
10:36:16 <n-dolio> Otherwise you'd need more parentheses for that, but it's the common case.
10:37:00 <JL_> for example max 2 3 can be written as (max 2) 3 -- i understand this
10:37:22 <JL_> what i can't comprehand is the type are written a -> (a -> (a -> a) )
10:37:26 <Saizan> JL_: given f :: A -> B -> C; then f (a :: A) :: B -> C; and so  f a b = (f a :: B -> C) (b :: B) :: C
10:37:35 <nand`> JL_: ‘because it's more convenient’?
10:37:58 <JL_> why isn't it ( (a -> a) -> a ) -> a
10:38:17 <n-dolio> That says that 2 :: (a -> a) -> a
10:38:20 <otters> because it's more convenient
10:38:22 <Cale> JL_: because the latter would mean a function which takes a function of type ((a -> a) -> a) as an argument
10:38:23 <n-dolio> Does that sound right?
10:38:39 <Cale> JL_: and produces a result of type a
10:39:06 * hackagebot haskelldb-hsql-sqlite3 1.0.0 - HaskellDB support for the HSQL SQLite3 driver.  http://hackage.haskell.org/package/haskelldb-hsql-sqlite3-1.0.0 (JustinBailey)
10:39:08 * hackagebot haskelldb-wx 1.0.0 - HaskellDB support for WXHaskell.  http://hackage.haskell.org/package/haskelldb-wx-1.0.0 (JustinBailey)
10:39:09 <Cale> JL_: we want a function which takes an a and produces another function (to take the next argument)
10:39:34 <Puffton> speaking of which, is currying adding any overhead, compared to natively allowing multi-parameter functions for instance?
10:39:46 <JL_> Cale: yup understand that point, that y i understand (max 2) 3
10:40:11 <Puffton> I mean there will be more function calls, right? in recursion I guess it could become a substantial delay?
10:40:12 <djahandarie> Puffton, no.
10:40:16 <shachaf> JL_: max :: Int -> something; something 3 :: Int
10:40:18 <Cale> JL_: So does that make sense now?
10:40:19 <n-dolio> Puffton: People have done work making currying just as fast as not currying for Haskell.
10:40:21 <shachaf> Therefore something = (Int -> Int)
10:40:27 <Cale> maybe we should use different letters
10:40:34 <Puffton> oh ok
10:40:45 <JL_> http://hpaste.org/76202
10:40:52 <Cale> Suppose we want a function which takes parameters of types A, B and C respectively, and produces a result of type D
10:40:58 <djahandarie> Puffton, the naive implementation would result in that, yeah, but all that gets optimized away to make it entirely free.
10:41:13 <n-dolio> Puffton: Amusingly, people had to do similar work for ML back in the day, making functions that take tuples just as efficient as functions that have some kind of baked-in multi-arguments.
10:41:26 <Cale> so, if f is our function, and x :: A, and y :: B, and z :: C, then we want f x y z :: D
10:41:32 <shachaf> n-dolio: It sounds easier to do for tuples.
10:41:39 <n-dolio> Maybe.
10:41:41 <Cale> Well, f x y z = ((f x) y) z, as you know
10:41:57 <Puffton> But in Haskell now, is it identical cost, or is it *close* to?
10:42:00 <n-dolio> shachaf: But then, Scala still has the distinction, and using tuples is way slower presumably.
10:42:06 <ksf_> JL_, yep, line 25 is the same as line 26
10:42:08 <Puffton> I mean I can't see how you would solve it with 0 overhead
10:42:10 <JL_> Cale: f x y z = ((f x) y) z -- i understand, but the types is like opposite
10:42:18 <Cale> So ((f x) y) had better be a function which is capable of taking z :: C as a parameter and producing a result of type D
10:42:21 <Puffton> But I guess I could imagine it be optimized down to *very small* overhead?
10:42:25 <Cale> So (f x) y :: C -> D
10:42:32 <n-dolio> Puffton: Should be identical. The low-level representation has multi-aplication sort of.
10:42:36 <shachaf> @google how to make a fast curry
10:42:37 <lambdabot> http://research.microsoft.com/~simonpj/papers/eval-apply
10:42:37 <lambdabot> Title: How to make a fast curry
10:42:40 <n-dolio> Puffton: It just figures it out automatically.
10:42:48 <n-dolio> And you only pay when you want to partially apply things.
10:42:57 <Cale> and then f x itself had better be a function which is capable of taking y :: B as a parameter, and producing a function C -> D
10:43:09 <Cale> So f x :: B -> (C -> D)
10:43:28 <Cale> and then f itself had better be a function which is capable of taking x :: A as a parameter, and producing a function of type B -> (C -> D)
10:43:30 <n-dolio> Puffton: There are things you can do to defeat it, but it'd be unusual to do so.
10:43:33 * shachaf has the feeling that Cale's explanation is confusing.
10:43:35 <Cale> So f :: A -> (B -> (C -> D))
10:43:50 <Cale> I'm just doing what the typechecker would do to infer the type of f
10:43:50 <n-dolio> Like writing 'f x = let ... in \y -> ...' instead of 'f x y = let ... in ...'.
10:44:14 <Cale> Looking at each function application, and the types of the things that we know, in order to infer the types of the functions involved.
10:44:14 <n-dolio> That kind of splits the argument list.
10:44:21 <Puffton> Oh, writing your own currying you mean?
10:44:26 <n-dolio> Of course, there are occasionally reasons for wanting to do that.
10:44:32 <JL_> Cale: i will take your example so B -> (C -> D), the parameter is on the left side of the return function ?
10:44:49 <shachaf> n-dolio: To be fair, I probably *want* "partial application" of some sort when I write that.
10:45:03 <Cale> JL_: when you write a type like A -> B, the A is the type of the parameter to the function, and the B is the type of the result.
10:45:06 <JL_> Cale: but ((f x) y), you see y is a parameter on the Right side of the reutnr function
10:45:27 <n-dolio> Puffton: Yeah, if you manually specify separate lambdas, I don't know how much coalescing it does. And it gives license to lift things out that wouldn't be possible without the manual lambdas.
10:45:29 <Cale> (f x) y means that we are applying the function (f x) to the argument y
10:45:30 <ksf_> JL_, you can read "->" as "implies"
10:45:32 <otters> so code generation to C causes deprecation?
10:45:35 <otters> errr...
10:45:37 <otters> is deprecated?
10:45:51 <ksf_> so Int -> String means: "if it is the case that there is some Int, there is also a String"
10:45:54 <otters> my brain thought something and my hands typed something entirely different
10:46:08 <n-dolio> Puffton: So, if you write 'foo x y = let ... in ...' it won't turn it into 'foo x = let ... in \y -> ...' even if it could. But if you write 'f x = \y -> let ... in ...' it might.
10:46:16 <Cale> I'm not sure that JL_ is ready for the Curry-Howard isomorphism :)
10:46:22 <n-dolio> shachaf: Yeah.
10:46:27 <JL_> ksf_: so Int is the parameter and String is the result ?
10:46:36 <ksf_> yep.
10:46:37 <Cale> JL_: yes
10:46:58 <JL_> Cale: OMGGGG this is insane!!! Still counter intuitive to me
10:47:04 <ksf_> just follow the arrow :)
10:47:43 <JL_> the argument is on the left of the return function for function types !!!!!
10:47:44 <ksf_> type a <- b = b -> a
10:47:51 <n-dolio> Puffton: Anyhow 'f x y z = ...' should be just as efficient as you'd expect 'f(x, y, z) = ...' to be.
10:48:03 <Cale> JL_: yeah, it's sort of flipped over
10:48:06 <Puffton> ok, cool
10:48:09 <Cale> JL_: because of Newton
10:48:34 <Cale> JL_: we write the parameter to a function on the right side of a function
10:48:44 <JL_> Cale: yes
10:48:52 <Cale> So if f :: A -> B, and x :: A, then we have f x :: B
10:49:03 <ksf_> also, if we wrote x y z f people would think we're coding forth.
10:49:04 <shachaf> n-dolio: f (x,y,z) is probably less efficient than you'd expect f(x,y,z) to be.
10:49:16 <lispy> preflex: seen Heffalump
10:49:16 <preflex>  Heffalump was last seen on #darcs 20 hours, 35 minutes and 6 seconds ago, saying: owst_: trying to introduce the MonadDarcs class to code that uses the Haskeline monad transformer, I've ended up replacing it with a type family and now I get lots of can't match 'InputT m' against 'InputT m5'
10:49:33 <Puffton> why shachaf?
10:49:35 <Cale> JL_: we could have chosen to put the arrows the other way around, and write something like:
10:49:43 <shachaf> Puffton: Because tuples are lifted.
10:49:51 <Puffton> what's that?
10:49:56 <Cale> If f :: B <- A, and x :: A, then f x :: B
10:50:02 <notdan> Hi! Can someone recommend me the preferable solution to the following problem: I've installed haskell-platform some time ago, and now cabal-install tells me that ther is a new version of cabal-install, however, when I install it, it installs locally, in my home dir, whilst the haskell-platform features executable @ /usr/bin/cabal
10:50:16 <notdan> What's the best way to resolve this/
10:50:17 <notdan> ?
10:50:24 <Cale> JL_: and then the <- would be left-associative to match function application
10:50:33 <ksf_> notdan, don't resolve it?
10:50:45 <ksf_> it won't break anything.
10:50:47 <notdan> ksf_: hm, and use old cabal?
10:50:48 <notdan> okay
10:50:50 <Cale> JL_: but that's also a little counterintuitive somehow, for people who write things from left to right
10:50:56 <rwbarton> notdan: put ~/.cabal/bin on your PATH or put a symlink to ~/.cabal/bin/cabal somewhere that is on your PATH
10:51:06 <ksf_> well, your $HOME/.cabal/bin should be in path before the global one.
10:51:10 <Puffton> Cale, is it possible in Haskell? Left arrow?
10:51:17 <Cale> Puffton: no
10:51:26 <JL_> Cale: the arrows are fine
10:51:32 <Cale> Puffton: I'm saying it's something which could have been done when designing the language initially
10:51:33 <JL_> Cale: it's the brackets
10:51:38 <shachaf> Cale: Application should be "x f" rather than "f x".
10:52:23 <Cale> shachaf: Of course *you'd* want to write things backwards!
10:52:23 <Cale> :)
10:52:39 <notdan> ok, thanks rwbarton, ksf_
10:52:43 <Cale> JL_: okay, so let's try to think of what a function of type (A -> B) -> C does
10:52:54 <JL_> Cale:  to me
10:52:59 <Cale> JL_: this is something which demands as a parameter, another function of type A -> B
10:52:59 <shachaf> Cale: Pft. More like I want to write them forwards.
10:53:12 <Cale> JL_: and produces as a result, some value of type C
10:53:15 <ski> in a definition, we prefer `f (..complex pattern..) = ..definiens..' to `(..complex pattern..) f = ..definiens..', so that we see the name of the thing being defined at the front
10:53:35 <ski> also, in expressions, it's more common for `x' to be a large expression in `f x' than for `f' to be one
10:53:59 <JL_> Cale: hold on, is it the function that takes in A, return B and then takes in C again ?
10:54:05 <Cale> no
10:54:20 <Cale> It's a function whose argument is required to be another function
10:54:22 <JL_> Cale: hold on, is it the function that takes in A and B and then takes in C again ?
10:54:27 <Cale> no
10:54:34 <JL_> AHHH
10:54:53 <Cale> It's a function which takes (a function from A to B) as its argument, and produces a result of type C
10:55:20 <ksf_> (which is impossible in general)
10:55:23 <ski> @let foo f = not (f 'a')
10:55:26 <lambdabot>  Defined.
10:55:29 <ski> @type foo
10:55:31 <lambdabot> (Char -> Bool) -> Bool
10:55:59 <JL_> so (A -> B) returns a function that can take in C
10:56:02 <shachaf> Cont Bool Char
10:56:31 <qwr> @eval foo isLetter
10:56:43 <ski> @run foo isLetter
10:56:46 <lambdabot>   False
10:56:50 <qwr> > foo isLetter
10:56:52 <lambdabot>   False
10:56:56 <Cale> JL_: consider the function filter :: (a -> Bool) -> [a] -> [a]
10:57:14 <Cale> JL_: this takes a function from a to Bool, and a list of values of type a
10:57:20 <Cale> and produces a list of values of type a
10:57:36 <qwr> > filter isAlpha "foo bar"
10:57:37 <lambdabot>   "foobar"
10:57:40 <Cale> It does this by applying the function to each element of the list, and constructing a list of the values for which the function gave true.
10:57:45 <Cale> True, rather :)
10:57:50 <Cale> (with a capital T)
10:57:53 <JL_> Cale: ok i know this, it takes in a condition and a list, goes through the list, and return those true
10:57:57 <Cale> yes
10:58:24 <Cale> So that parameter to filter needs to be a *function* which takes in an a, and produces a Bool result
10:58:24 <qwr> JL_: and the condition is a function
10:58:39 <Cale> and then filter can apply this function as many times as it wants, to the elements of the list
10:58:42 <JL_> Cale: ok i get that
10:58:59 <Cale> So, there's another way we can look at the type of filter:
10:59:04 <Cale> filter :: (a -> Bool) -> ([a] -> [a])
10:59:13 <JL_> Cale: omg
10:59:37 <Cale> filter is a function which takes as its parameter some condition-expressing function of type a -> Bool
10:59:37 <johnw> JL_: I know, aren't first-class functions amazing?
10:59:41 <Cale> and produces as its result
10:59:49 <Cale> a function which eats a list and gives another list
10:59:56 <Cale> of type [a] -> [a]
11:00:03 <qwr> > (filter isAlpha) "foo bar"
11:00:04 <lambdabot>   "foobar"
11:00:11 <johnw> filter succ is a function that transforms any list in a list of succeeding elements
11:00:21 <ski> > [filter even [0],filter even [1,2],filter even [3,4,5],filter even [6,7,8,9]]
11:00:22 <johnw> oops
11:00:23 <lambdabot>   [[0],[2],[4],[6,8]]
11:00:23 <Cale> johnw: itym map
11:00:25 <ski> > map (filter even) [[0],[1,2],[3,4,5],[6,7,8,9]]
11:00:27 <lambdabot>   [[0],[2],[4],[6,8]]
11:00:49 <ski> > map f [a,b,c,d]                :: [Expr]
11:00:51 <lambdabot>   [f a,f b,f c,f d]
11:00:58 <Cale> JL_: see, the nice thing about this, is that we can take some other function like map which wants a function as its argument
11:01:01 <johnw> sorry, was thinking of map
11:01:04 <johnw> i don't use filter often
11:01:08 <johnw> map succ
11:01:13 <johnw> :t map succ
11:01:14 <lambdabot> forall a. (Enum a) => [a] -> [a]
11:01:25 <shapr> johnw: Would fold succ filter a list to only the second of any 'pairs' ?
11:01:28 <JL_> Cale: ah, is that the reason why function types brackets start from the right ?
11:01:30 * shapr thinks
11:01:47 <johnw> :t fold succ
11:01:48 <clahey> JL_: Exactly!
11:01:48 <lambdabot> Not in scope: `fold'
11:01:49 <johnw> :t foldl succ
11:01:50 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
11:01:50 <lambdabot>     Probable cause: `succ' is applied to too many arguments
11:01:51 <lambdabot>     In the first argument of `foldl', namely `succ'
11:01:55 <johnw> :t foldl1 succ
11:01:56 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
11:01:57 <lambdabot>     Probable cause: `succ' is applied to too many arguments
11:01:59 <lambdabot>     In the first argument of `foldl1', namely `succ'
11:02:03 <johnw> succ doesn't take an accumulator
11:02:06 <shapr> :t foldr succ
11:02:08 <alpounet> foldl expects a two argument function
11:02:08 <lambdabot> forall b. (Enum (b -> b)) => b -> [b -> b] -> b
11:02:11 <Cale> JL_: they start from the right because we more frequently want functions with multiple parameters than we want functions which take (functions which take functions as parameters) as parameters
11:02:11 <clahey> :t succ
11:02:12 <lambdabot> forall a. (Enum a) => a -> a
11:02:42 <Cale> JL_: I mean, it's awkward to even talk about those, if you start nesting like that :)
11:03:26 <Cale> f :: ((A -> B) -> C) -> D  means that f is a function which takes as its parameter a function of type (A -> B) -> C, which is itself a function which takes as its parameter a function of type A -> B
11:03:49 <Cale> and this maybe starts to make your head swim
11:03:52 <Cale> :)
11:04:05 <Cale> Well, that would be why they associate the other way by defaul
11:04:07 <Cale> t
11:04:51 <Cale> To *use* a function of type A -> (B -> (C -> D)), you don't need another function, you just need a value of type A
11:05:07 <Cale> (and then maybe some values of type B and C as well if you like)
11:05:31 <Cale> But to use a function of type ((A -> B) -> C) -> D, you need to provide a function of type (A -> B) -> C
11:05:34 <clahey> I have more trouble with the fact that function application is left associative.  I know I would have trouble if it were the other way, but I constantly make mistakes that way.
11:06:03 <Cale> (and those are maybe a little more work to come by)
11:06:04 <JL_> Cale: hold on, i think i m getting something
11:06:33 <clahey> Cale: I'm trying to even think of a useful function (a -> b) -> c, much less ((a -> b) -> c) -> d)
11:06:38 <clahey> (Too many )
11:06:43 <Cale> clahey: Don't think of it as polymorphic
11:06:53 <ksf_> (a -> b) -> c is easy.
11:06:57 <ksf_> there's only one of those.
11:07:02 <ksf_> f _ = undefined
11:07:25 <Cale> For specific types A, B, and C, there are lots of functions of type (A -> B) -> C in general
11:07:43 <shachaf> ksf_: No, there's also f = undefined
11:07:49 * ski thinks we need not bring polymorphism into this atm, perhaps confusing JL_ more
11:08:02 <ksf_> FAST AND LOOSE REASONING IS MORALLY CORRECT
11:08:07 <Cale> yeah, I don't want to really get into parametricity here
11:08:18 <clahey> Cale: I wasn't trying to think of it as polymorphic.  I just wasn't even thinking of them at all.
11:08:25 <Cale> clahey: map
11:08:41 <Cale> map :: (a -> b) -> ([a] -> [b])
11:08:50 <clahey> True.
11:08:57 <clahey> I was trying to think of one that returned a non function.
11:08:58 <Cale> so where C = [a] -> [b], that creates lots of examples
11:09:06 <clahey> Cale: Agreed.
11:09:08 <Cale> \f -> map f [1..10]
11:09:09 <ski> or my `foo' above (perhaps not very useful, though)
11:09:09 <Cale> ;)
11:09:16 <clahey> Cale: True.
11:09:29 <clahey> JL_: Anyway, sorry for distracting.  You were getting something?
11:09:34 <Cale> But also, lots of practical examples come up all the time
11:09:56 <ksf_> @pl \f -> map f [1..10]
11:09:56 <lambdabot> flip map [1..10]
11:09:58 <Cale> well... usually there are more parameters hanging around somewhere
11:10:33 <ksf_> (somehow, all my uses of "flip" are in front of runXXX functions)
11:10:51 <JL_> Ok let me try to convert this to english, f x y z is also f :: x -> (y -> z) is a function that take x, returns a function that takes y and returns a function that takes z
11:10:51 <shachaf> ksf_: (`runFoo` arg)
11:11:17 <shachaf> That's correct except for the "f x y z is also" part.
11:11:23 <ksf_> JL_, "f x y z" is not a function, it's a value.
11:11:29 <clahey> JL_: I make that mistake sometimes, but there's no function taking z.
11:11:33 <clahey> JL_: z is the final result.
11:11:33 <ksf_> "f" is the function.
11:11:48 <shachaf> ksf_: f x y z is only a value if z = a -> b
11:12:24 <ksf_> yep.
11:12:45 <ksf_> "f x y" is the actual value.
11:12:46 <JL_> when i see f :: a -> b -> c -> d -> e, i always see it as a function that takes in 4 parameters and return something of type e
11:12:58 <ksf_> that's a perfectly fine way to see it.
11:12:59 <JL_> right ?
11:13:05 <clahey> JL_: Yes.
11:13:33 <clahey> JL_: So if you had objects of that type, f a' b' c' d' :: e
11:13:38 <JL_> now it is at the same time also similar to this f :: a -> (b -> (c -> (d -> e)))
11:13:47 * hackagebot numbers 3000.1.0.1 - Various number types  http://hackage.haskell.org/package/numbers-3000.1.0.1 (DanBurton)
11:13:49 <ksf_> but then, f x y = x + y   is the same as f x = \y -> x + y
11:13:51 <clahey> More than similar.
11:14:20 <clahey> In haskell, they're exactly the same.
11:14:30 <ksf_> modulo sharing, yes.
11:14:36 <JL_> f :: a -> (b -> (c -> (d -> e))) makes me feel like the answer is evaluate from inside out
11:14:36 <clahey> sharing?
11:14:37 <c_wraith> exactly the same denotationally
11:14:47 <c_wraith> ghc might have slightly different operational semantics for them
11:14:48 <JL_> so (d -> e) gets evaluated first
11:15:12 <c_wraith> Which it's allowed to do, provided they always have the same result value.
11:15:18 <clahey> JL_: It sort of is.
11:15:18 <ksf_> parenthesis don't apply anything
11:15:25 <ksf_> they're really only grouping.
11:15:44 <clahey> JL_: I don't know how accurate this is, but think of a type statement as being code to build a type.
11:16:10 <clahey> JL_: So, yes, (d -> e) is a type which is required to build the bigger type c -> (d -> e)
11:16:36 <clahey> JL_: Function application itself is left associative.
11:16:38 <ksf_> ...just like 1 : (2: (3 : [])))
11:16:55 <clahey> So f a' b' c' d' ===== (((f a') b') c') d
11:17:13 <JL_> ok so (d -> e) get evaluate first, when you see f :: a -> b -> c -> d -> e, do you see f a getting evluated first or f e ?
11:17:36 <ksf_> JL_, neither :)
11:17:38 <ksf_> haskell is lazy.
11:17:41 <clahey> JL_: When writing code to apply functions, I see f a getting evaluated first.
11:18:07 <shachaf> Things don't happen "first".
11:18:07 <JL_> clahey: yeah just like (max 2) 3 right ?
11:18:48 <Ken`> how can I print a dot . with lhs2TeX? if I just type a . it gives me \circ
11:18:50 <clahey> Right, in terms of space and time constraints you have to remember that it's lazy, but you can choose to ignore that when it will make it easier for you to understand your code.
11:19:03 <clahey> JL_: Exactly.
11:19:20 <clahey> JL_: When writing a type signature though, you're not writing code.
11:19:29 <ksf_> just because "a -> b -> c" says "the function (b -> c) needs an "a" to exist", doesn't mean that "a" really gets evaluated before "b". the logical meaning here is different from the evaluation order.
11:19:30 <clahey> JL_: What is the type of max 2?
11:19:51 <ksf_> :t max 2
11:19:52 <lambdabot> forall t. (Num t, Ord t) => t -> t
11:20:10 <clahey> ksf_: I wasn't asking lambda bot.  :)
11:20:13 <JL_> clahey: it returns a function that take num as a para ?
11:20:44 <ksf_> it *is* a function that takes a Num a as parameter.
11:20:47 <clahey> JL_: Simplify your statement there.  Does max 2 return something or "is" it sometiong?
11:21:01 <clahey> something*
11:21:26 <clahey> :t max (2 :: Int)
11:21:27 <lambdabot> Int -> Int
11:21:33 <JL_> clahey: it returns a function that could take the next parameter as NUM
11:21:43 <JL_> or Int
11:21:45 <JL_> not sure
11:22:02 <JL_> actually
11:22:03 <JL_> no
11:22:18 <clahey> JL_: That's the polymorphism thing Cale didn't want to bring in yet.
11:22:20 <JL_> it returns a function that could take the next parameter of type ORD
11:22:41 <clahey> JL_: The next type has to be of type Ord and of type Num.
11:22:52 <clahey> :t max
11:22:53 <shachaf> clahey: That's not what "of type" means. :-(
11:22:53 <lambdabot> forall a. (Ord a) => a -> a -> a
11:22:57 <clahey> :t 2
11:22:58 <lambdabot> forall t. (Num t) => t
11:23:04 <JL_> it shows ORD only though ?
11:23:05 <shachaf> Anyway, type classes seriously don't belong in this discussion.
11:23:34 <ski> @let maxInteger :: Integer -> Integer -> Integer; maxInteger = max
11:23:35 <lambdabot>  Defined.
11:23:43 <ski> there, use `maxInteger' instead
11:23:48 * hackagebot git-annex 3.20121010 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20121010 (JoeyHess)
11:23:50 <clahey> I had no idea you could do that.  :)
11:23:58 <clahey> :t maxInteger 2
11:23:59 <lambdabot> Integer -> Integer
11:24:21 <clahey> shachaf: Perhaps later you will tell me what I said wrong with "type of".
11:24:34 <clahey> JL_: So, how do you write the type of maxInteger 2?
11:24:35 <ski> clahey : `Ord' is not a type, it's a type class
11:24:49 <shachaf> clahey: "x is of type y" means "x :: y"
11:24:50 <clahey> ski: Ah.
11:25:03 <shachaf> Confusing types and type classes is a bad idea and leads to a lot of confusion.
11:25:14 <clahey> shachaf: Yeah, it's a problem I have.
11:25:23 <ski> (alternatively, `x :: y' means "`x' is of type `y'")
11:25:29 <JL_> clahey: maxInteger :: (Num a) -> a -> a -> a ?
11:25:44 <JL_> clahey: or maxInteger :: (Integer a) -> a -> a -> a ?
11:25:45 <shachaf> "x is of type y" iff "x :: y"
11:25:48 <ski> clahey : forget `Num' and `a', use `Integer'
11:25:53 <jonkri> does anyone know why sign takes a (ByteString -> ByteString) random number generator function, and how am i supposed to define it? http://hackage.haskell.org/packages/archive/cryptocipher/0.3.0/doc/html/Crypto-Cipher-DSA.html
11:25:59 <clahey> JL_: Forget Num and a as they said.
11:26:06 <clahey> JL_: That's type classes getting in the way.
11:26:10 <ski> JL_ : er, what i mistakenly directed to clahey above
11:26:18 <ksf_> JL_, we'll stuff you full of typeclasses and polymorphism as soon as you admit to understanding parameter ordering :)
11:26:36 <JL_> ksf_: lol HASKELL man
11:27:09 <JL_> Thanks for all the help !!!!!!!!!!!!!!!!!!!!!! Back to re-wiring my brain
11:27:38 <shachaf> jonkri: If you don't understand your cryptography library or how to use it, it's almost certainly too low-level and so you'll probably get it wrong if you do use it.
11:27:39 <ksf_> jonkri, no idea, but you might try "id"
11:27:56 <shachaf> I recommend looking for a library with a simpler interface.
11:28:05 <shachaf> ksf_: id is wrong there.
11:28:14 <ksf_> jonkri, the source says it's a hash function.
11:28:17 <shachaf> The name of the parameter is "hash". It probably wants a hash function.
11:29:24 <jonkri> ksf_: that's right. i thought it was an rng in addition to the gen :) now it all makes more sense :) thanks
11:30:00 <shachaf> Mark my words, man.
11:30:47 <clahey> Use a simpler library.
11:31:05 <jonkri> shachaf: i'm just prototyping. i'll leave it to experts to validate the security of any security-sensitive application down the line
11:31:43 * ksf_ recommends augmenting that source with -- AUDIT THIS
11:32:58 <clahey> jonkri: Do the experts know haskell?
11:33:19 <clahey> I suspect haskell is harder to learn than is figuring out which crypto library to use.
11:33:40 <shachaf> Why are people reïmplementing cryptographic code in pure Haskell?
11:34:07 <clahey> shachaf: It's fun?
11:34:12 <jonkri> i'm sure it will be alright :)
11:34:34 <clahey> jonkri: What company are you doing this for?
11:34:43 <jonkri> just myself
11:34:57 <clahey> Oay.
11:34:58 <clahey> Okay.
11:35:09 <shachaf> jonkri: What are you doing?
11:35:40 <jonkri> nothing in particular. at the moment, just trying out dsa :)
11:36:08 <jonkri> i work mainly with javascript at the moment, but i prefer to test it out using haskell
11:36:38 <shachaf> JavaScript cryptography?
11:37:33 <jonkri> i know, i know :)
11:37:54 <shachaf> What are you doing in JS?
11:38:46 <jonkri> shachaf: uncentralized end-to-end cryptography using an authenticated diffie-hellman key exchange and socialist millionaire's protocol
11:38:49 * hackagebot markdown-unlit 0.1.0 - Literate Haskell support for GitHub's Markdown flavor  http://hackage.haskell.org/package/markdown-unlit-0.1.0 (SimonHengel)
11:39:19 <shachaf> jonkri: In the browser?
11:39:38 <jonkri> shachaf: among other environments
11:39:50 <jonkri> phones too
11:40:47 <watermind> isn't there a mconcatMap  for monoids?  mconcatMap f = mconcat . map f
11:41:41 <shachaf> watermind: Because you can write mconcat . map f, presumably.
11:42:13 <watermind> shachaf: well you can also write concat . map f and there is concatMap
11:42:34 <shachaf> concatMap probably exists because of (>>=)
11:45:01 <watermind> shachaf: maybe...
11:57:51 <clahey> So teach me about type classes vs. types.
11:58:25 <clahey> And kinds.
11:58:33 <Cale> clahey: So think about a function to sort a list
11:58:56 <Cale> You'd want the function to work for many different types of elements in your list
11:59:00 <clahey> Cale: sort :: Ord a => [a] -> [a]
11:59:07 <Cale> But [a] -> [a] doesn't quite work
11:59:28 <Cale> because if a is just any type whatsoever, then it might be one without a defined ordering
11:59:36 <clahey> Cale: I get that.
11:59:41 <Cale> So we need a way to restrict the types which the type variable a ranges over
11:59:42 <shachaf> sort :: (?cmp :: a -> a -> Ordering) => [a] -> [a]
11:59:42 <ksf_> ...but (a -> a -> Ordering) -> [a] -> [a] works.
12:00:03 <clahey> shachaf: Okay, what's that?
12:00:05 <Cale> Yes, we *could* say, just take another function parameter
12:00:11 <Cale> but that's also not so convenient
12:00:28 <shachaf> clahey: Sorry, that's nonsense. It's an extra parameter.
12:00:29 <Cale> (also: thanks guys, for ruining my tutorial, I appreciate it!)
12:00:30 <HugoDaniel> hi
12:01:05 <shachaf> Cale: I don't think clahey is asking the question you think he's asking.
12:01:07 <HugoDaniel> im trying to use postgresql-simple with my own datatypes from postgresql, and i notice that fromField always gets a text representation
12:01:16 <HugoDaniel> isn't that a bit bad performance wise ?
12:01:40 <HugoDaniel> im creating attoparsec parsers that produce my datatypes in the fromField
12:02:07 <Cale> clahey: so, type classes do this, and you already know the proper type of sort
12:02:19 <clahey> Cale: So yeah, I get how to use type classes and vaguely how they work.
12:02:27 <HugoDaniel> but still, the postgresql binary -> postgresql-simple text -> attoparsec -> haskell datatype seems a bit too much :/
12:02:33 <clahey> I guess I just want to understand the mathematical underpinnings better.
12:02:37 <HugoDaniel> is there any other way to this ?
12:02:59 <Cale> Well, they're not just a straightforward translation of something from mathematics, as far as I know
12:03:25 <nand`> @ask edwardk so what does a /generalized/ zygohistoprepro look like?
12:03:26 <lambdabot> Consider it noted.
12:03:41 <Cale> But many mathematical abstractions are easily expressed using type classes -- allowing us to define the operations which some type is meant to be implicitly equipped with
12:04:00 <clahey> Ord, Num, Rational
12:04:02 <shachaf> Why are you trolling the poor sick edwardk?
12:04:04 <HugoDaniel> lpsmith: u there ?
12:04:12 <clahey> RealFrac
12:04:21 <trolling> he's not trolling
12:04:22 <Cale> All the time in mathematics, we do this thing where the operations on a structure are attached to it in a sort of implicit way
12:04:24 <trolling> I'm trolling
12:04:49 <lpsmith> HugoDaniel, what's up?
12:04:54 <Cale> So we say for example, that a vector space is a set V together with operations of addition and scalar multiplication satisfying laws
12:05:10 <clahey> Cale: Yeah, I get that.
12:05:18 <nand`> shachaf: no, I'm genuinely curious; I was thinking about implementing them in C# just because
12:05:18 <Cale> and we tend not to write vector spaces as (V,+,*) or whatever, but just as V, with the implicit understanding that the other stuff is around
12:05:30 <Cale> and that's kind of what typeclasses let us do
12:05:42 <shachaf> Type classes are kind of annoying for expressing algebraic structures.
12:05:47 <HugoDaniel> lpsmith: some questions about postgresql-simple
12:05:49 <clahey> shachaf: Why?
12:05:50 <HugoDaniel> lpsmith: im creating attoparsec parsers that produce my datatypes in the fromField
12:05:54 <shachaf> Because the structure isn't *really* associated with the type.
12:05:54 <Cale> say what the implicit default operations of various sorts are
12:06:11 <shachaf> E.g. (Integer,0,+) and (Integer,1,*) are both valid Monoid instances.
12:06:13 <nand`> clahey: type classes are just a mechanism for automatically threading extra arguments through calls so you don't have to write all of the boilerplate yourself
12:06:25 <nand`> clahey: you could just as well use regular higher order functions like sortBy
12:06:30 <shachaf> nand`:  They give you more guarantees than that.
12:06:40 <lpsmith> HugoDaniel, sure
12:06:41 <nand`> (it gets a bit more complicated than that when you add various language extensions also)
12:06:49 <rwbarton> they work well when everyone agrees what the sensible algebraic structure on the type is
12:07:04 <lpsmith> (out of curiousity, which postgresql datatypes are you adding support for,  if I may ask?)
12:07:07 <clahey> shachaf: Hence Product and Sum.
12:07:11 <HugoDaniel> lpsmith: because whenever i call a plpgsql function that returns an existing table, i get a different type, then that type shows up in postgresql-simple with a text representation in fromField, after this i try to convert to a haskell datatype with attoparsec
12:07:11 <Cale> yeah, you can imagine implementing type classes using extra function parameters, and instances as providing values of the appropriate type (or in the case that the instance itself depends on other classes, functions)
12:07:22 <shachaf> clahey: Right. hence annoying.
12:07:25 <Cale> So, when you write:
12:07:38 <clahey> shachaf: is there a Ring type class?
12:07:39 <shachaf> rwbarton: Yes. I like type classes like Functor where there's really only one instance.
12:07:54 <shachaf> clahey: I'm sure someone has defined one.
12:08:00 <Cale> instance Show a => Show [a] where show (x:xs) = ... use (show x) ...
12:08:06 <rwbarton> Num is basically Ring
12:08:15 <nand`> rwbarton: except with fromInteger
12:08:21 <rwbarton> rings have fromInteger
12:08:26 <Cale> then it's defining a function which takes the instance of Show for a, and transforms it into an instance of Show for [a]
12:08:29 <rwbarton> it is automatic from 0 and 1 and +
12:08:39 <nand`> oh, right
12:08:55 <rwbarton> but they don't have any of that abs or signum nonsense :)
12:09:15 <arbn> http://hackage.haskell.org/package/algebra ?
12:09:36 <clahey> And monoid is group.
12:09:54 <clahey> Oh, no it's not.
12:09:58 <clahey> There's no inverse?
12:10:00 <clahey> .
12:10:04 <nand`> no, not in Monoid
12:10:39 <shachaf> You'd think that Haskell people would be more sympathetic to semirings.
12:10:43 <nand`> rwbarton: does Num actually require (*) to distribute over (+) ?
12:11:06 <shachaf> nand`: Num doesn't require anything.
12:11:11 <shachaf> Evidence: instance Num Double
12:11:16 <nand`> fair enough
12:11:25 <rwbarton> there's also the issue of commutativity of (*)
12:11:34 <nand`> I never quote got around Ord Double either
12:11:37 <nand`> or Enum Double
12:11:41 <rwbarton> whether you think Num "requires" it and whether you think "ring" requires it
12:12:00 <clahey> rwbarton: Ring certainly doesn't.
12:12:14 <lpsmith> HugoDaniel, ok...  sounds good so far.
12:12:17 <clahey> rwbarton: Square matrices are one of the primary examples of a ring.
12:12:33 <rwbarton> of course there are noncommutative rings and commutative rings
12:12:37 <lpsmith> HugoDaniel, though you can flatten composite types in your SQL, which might be an easier way of dealing with things.
12:12:44 <rwbarton> but for many people ring means commutative ring
12:12:57 <HugoDaniel> lpsmith: check: http://hpaste.org/76207
12:13:26 <shachaf> Clearly those should be called crings.
12:13:33 <shachaf> And commutative semirings should be called crigs.
12:13:39 <nand`> rwbarton: the only definitions I've read claim ‘ring’s non-commutative; and I think I would prefer something like ‘abelian ring’ for commutative ones
12:13:54 <nand`> for analog with eg. ‘group / abelian group’
12:14:05 <rwbarton> for some reason "commutative monoid" "abelian group" "commutative ring" are absolutely standard
12:14:05 <nand`> abstract algebra needs more consistency
12:14:12 <HugoDaniel> lpsmith: maybe i could try to turn FromField into a generic datatyp that could be derivable for these cases
12:14:17 <rwbarton> I guess you might hear "abelian monoid" but never "abelian ring"
12:14:30 <nand`> shachaf: I like
12:14:35 <shachaf> http://slbkbs.org/out.pdf
12:14:41 <shachaf> Hmm, I don't have rings on there.
12:14:50 <nand`> I actually like ‘rig’ more than ‘semiring’ because the name immediately tells me ‘without negation’
12:14:52 <shachaf> Also I have a mistake somewhere along the left side.
12:15:05 <nand`> so ‘cring’ would be good for the same reason
12:15:13 <shachaf> Oh, I kept it to one operation.
12:15:18 <lpsmith> HugoDaniel, I don't understand why you are using pl/pgsql here;  you can write this as a join.
12:15:43 <nand`> there's a somewhat handy template at https://en.wikipedia.org/wiki/Template:Group-like_structures as well, though I don't like its inclusion of the categories
12:16:03 <shachaf> Categories are just like monoids!
12:16:23 <nand`> but they aren't ‘monoids without totality’, as the table implies
12:16:31 <nand`> I mean, they are;
12:16:33 <nand`> but the reverse is not true
12:16:38 <rwbarton> in practice if you are doing commutative algebra/algebraic geometry maybe you mention that "ring" means "commutative ring with 1" at the start
12:16:43 <clahey> What's an example of a proper semiring?
12:16:48 <lpsmith> Regardless, you should be able to write  "SELECT x.* FROM getProfileByAuthId(?,?) x" and have the backend flatten the composite type for you.
12:16:53 <shachaf> clahey: Types in Haskell!
12:17:01 <shachaf> Well, that's commutative.
12:17:03 <nand`> natural numbers?
12:17:08 <nand`> commutative too
12:17:15 <clahey> nand`: Point.
12:17:19 <lpsmith> Which would save the complication of writing a parser for the Profile type
12:17:23 <clahey> shachaf: What are the two types?
12:17:29 <shachaf> Two types?
12:17:32 <clahey> shachaf: The two operations, I mean.
12:17:39 <HugoDaniel> lpsmith: let me try that :)
12:17:40 <nand`> Void, (), Either, (,)
12:17:41 <shachaf> Either and (,)
12:17:45 <nand`> 0 1 + *
12:17:47 <lpsmith> Though I'd like to add support for Composite types at some point.
12:18:04 <nand`> of course it gets muddled up since Haskell isn't exactly total
12:18:18 <shachaf> Haskell is totally partial
12:18:35 <c_wraith> meh. that one paper proved you can ignore totality except in the cases you can't.
12:18:40 <clahey> Either Void x == x?
12:18:52 <rwbarton> for some value of "=="
12:19:16 <gaze__> http://stackoverflow.com/questions/12865623/list-of-multiple-types-in-haskell Hey guys, mind having a look at my question about having a list with stuff of different types?
12:19:29 <shachaf> clahey: You can implicitly add "up to isomorphism" to every sentence when people start talkinng about types.
12:19:40 <shachaf> gaze__: Did you see the FAQ entry on this?
12:19:41 <ksf_> gaze__, use an existential
12:19:45 <HugoDaniel> lpsmith: aren't joins bad ?
12:19:50 <HugoDaniel> lpsmith: it worked :) thanks
12:19:57 <lpsmith> HugoDaniel, not necessarily
12:20:06 <shachaf> gaze__: People will tell you to use an existential type but that's probably the wrong answer.
12:20:06 <ksf_> http://www.haskell.org/haskellwiki/Existential_type
12:20:12 <clahey> shachaf: Okay, so that would suggest that Either Void is an isomorphism, right?
12:20:14 <nand`> s/==/≅/
12:20:15 <shachaf> gaze__: The right answer is probably [IO ()]
12:20:15 <HugoDaniel> i never know which to choose from, joins, subselects, functions :/
12:20:27 <lpsmith> you are basically doing a join as is,  except the postgresql optimizer can't see into what you are doing,  for better or worse (probably often worse).
12:20:37 <nand`> clahey: if you ignore partiality, it is; since you can never construct Left (x :: Void) in a total way, you're only left with Right for the forward and unRight for the backward
12:20:54 <lpsmith> HugoDaniel, in any case, you are welcome.
12:20:54 <kizzo> I'm trying to follow this guide: http://xmonad.org/xmonad-docs/xmonad-contrib/XMonad-Actions-SwapWorkspaces.html
12:21:01 <gaze__> shachaf: Why is an existential type the wrong way to go? Or does it just not apply?
12:21:06 <gaze__> and what FAQ entry?
12:21:11 <kizzo> But a part of its code references a function called modm - where the hell is that defined?
12:21:12 <shachaf> @where faq
12:21:12 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
12:21:14 <rwbarton> "is bad" is bad
12:21:20 <nand`> you can actually have lists with multiple types now, without existentials
12:21:30 <kizzo> defined/imported
12:21:38 <gaze__> oh crap I'm so sorry
12:21:49 <gaze__> I'll read up on that, thanks!
12:21:55 <shachaf> gaze__: It'll work but it's more awkward than what you want.
12:22:02 <kizzo> [((modm .|. controlMask, k), windows $ swapWithCurrent i)
12:22:10 <lpsmith> The real problem with joins is that people don't understand when they are expensive and when they are cheap.   Which seems to be a problem with SQL in general.   Joins aren't necessarily a bad thing.
12:22:17 <clahey> nand`: Let me read wikipedia:totality.
12:22:19 <fmap> kizzo: modm is your modMask
12:22:22 <lpsmith> They can in fact be a very good thing
12:22:33 <shachaf> gaze__: "Some languages require a new type for each new behavior. In Haskell, behaviors are functions or IO actions, which are first-class values."
12:22:34 <rwbarton> kizzo: in general there is #xmonad for xmonad questions
12:22:45 <nand`> clahey: a partial function/value is one that diverges
12:22:52 <kizzo> fmap: Cool thanks I'll take that into account.
12:22:59 <nand`> in other words, never computes; either due to ‘error’ or simply never returning
12:23:00 <kizzo> rwbarton: Acknowledged.
12:23:04 <nand`> (eg. fix id)
12:23:20 <rwbarton> sounds like you got your answer here though, no worries, just #xmonad may be more helpful in the future
12:23:44 <kizzo> True.
12:24:41 <lpsmith> HugoDaniel, actually you don't even need a join here,  nested SQL is sufficient.
12:25:38 <gaze__> shachaf: data Obj = forall a. (Foo a) => Obj a ; [Obj A {a="a"}, Obj B {b="b"}] or something... this doesn't seem terribly awkward
12:26:47 <rwbarton> it's no less awkward than [foo A {a="a"}, foo B {b="b"}]
12:26:51 <shachaf> gaze__: But consider that the *only* thing you can do with x :: Obj is to "foo" it.
12:27:08 <clahey> To define Types as a semiring, we need a 5-tuple.  (set of types, Void, (), Either, (,))
12:27:13 <shachaf> So you might as well "foo" it directly and get some "IO ()"s to put in the list.
12:27:19 <gaze__> that seems like a very reasonable restriction
12:27:25 <gaze__> considering that's all I know I can do with it
12:27:33 <shachaf> Right. So why have it in the first place?
12:27:39 <shachaf> Just make the IO () directly.
12:27:43 <gaze__> since that's all I'll ever do with it
12:27:44 <nand`> existentials work, but they're unnecessary complexity
12:27:54 <nand`> he's saying the alternative is simpler, in conceptual terms
12:27:59 <clahey> Obviously Either and (,) aren't correct here, so we make it a semi-ring of equivalence classes in some way?
12:27:59 <HugoDaniel> lpsmith: i still feel that wrapping sql functions in plpgsql is a good thing
12:28:01 <gaze__> eh I just don't really wanna drag IO () around
12:28:17 <shachaf> "Some languages require a new type for each new behavior. In Haskell, behaviors are functions or IO actions, which are first-class values. So you can store behaviors in an ordinary data type"
12:28:34 <shachaf> gaze__: Huh? What's the difference between draggin IO () around and dragging Obj around?
12:29:30 <clahey> Oh, the equivalence class is between types which can have a bijection between their possible values?
12:29:47 <shachaf> clahey: Yes.
12:29:58 <clahey> Except it's slightly more than a bijection.
12:30:14 <lpsmith> HugoDaniel, it may make a lot more sense to use straight SQL stored procedures, avoiding plpgsql.
12:30:14 <nand`> ‘a ring in which laws are only preserved under isomorphism’ ?
12:30:25 <rwbarton> yes. really those bijections should be part of the big tuple defining a "semiring" too
12:30:26 <gaze__> I suppose I still don't have a very good feel at all for when an IO action executes
12:30:29 <nand`> rig*
12:30:47 <nand`> gaze__: there's only one IO action that ever executes
12:30:53 <clahey> rwbarton: The objects of the semiring are equivalence classes.
12:30:57 <clahey> main!
12:30:58 <nand`> it's called ‘main’, and it executes when you run the program
12:31:13 <shachaf> nand`: That's sort of a useless thing to say.
12:31:14 <rwbarton> but you might not want to identify say Integer and (Bool, Integer)
12:31:34 <rwbarton> even though there is a bijection between them
12:32:08 <clahey> rwbarton: I know.  Perhaps some sort of linearity restriction?
12:32:27 <clahey> Some sort of structure preservation.
12:32:32 <acowley> edwardk is exporting the kitchen sink from Contorl.Lens
12:32:32 <nand`> well, the point is that an IO action only executes when you, for example, >>=/>> it to something in ‘main’
12:33:00 <shachaf> gaze__: Getting a sense of how IO actions work is valuable if you want to be writing any actual programs. :-)
12:33:03 <clahey> But it's not useful to require that functions be liftable, cause you can just write a generic version.
12:33:20 <clahey> lift f = iso . f . iso'
12:33:24 <shachaf> They only get executed when you explicitly run them from another IO action.
12:33:47 <clahey> shachaf: Which itself is getting run.
12:33:56 <nand`> yes, understanding IO is very important for getting anything done at all; otherwise what you can program is limited to CPU heaters :)
12:34:01 <shachaf> nand`: I mean that saying "only one IO action ever gets executed in Haskell" is like saying "only one function ever gets called in C".
12:34:03 <gaze__> shachaf: that makes complete sense... you actually have to >> it
12:34:12 <lpsmith> HugoDaniel, http://hpaste.org/76207
12:34:15 <acowley> shachaf: Yesterday you asked about my question about injective type level functions needing fundeps if I want to re-use a type
12:34:20 <clahey> shachaf: Which is also a useful thing to say.
12:34:31 <shachaf> gaze__: Yep. On its own an action doesn't do anything; it has to be executed.
12:34:32 <shachaf> @quote /bin/ls
12:34:33 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
12:34:46 <nand`> well, I guess I was sort of trying to emphasize that IO actions don't execute themselves unless they're somehow directly connected to / bound by ‘main’
12:34:59 <acowley> shachaf: My use case was that I want to have classes C and D, that are each injectively associated with, say, Int.
12:35:12 <clahey> Can someone explain forall to me?
12:35:14 <HugoDaniel> lpsmith: is this better ? i never know when to use subqueries or joins or nothing :/
12:35:28 <acowley> shachaf: with fundeps I can say, class C f x | x -> f where… and class D g x | x -> g where ...
12:35:36 <shachaf> @google mainisusuallyafunction forall quantification
12:35:38 <lambdabot> http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
12:35:47 <lpsmith> HugoDaniel, it's less opaque to the PostgreSQL optimizer
12:36:05 <acowley> shachaf: But with type families, I can't say class C f where data instance X = foobarbpie
12:36:06 <HugoDaniel> cool :)
12:36:07 <nand`> gaze__: an IO () on itself is completely harmless; even if it launches missiles. You can pass it around, store it in lists, duplicate it, forget about it, bind it, whatever; the moment it gets executed is when ‘main’ somehow tells it to; or another IO action that ‘main’ told to execute tells it to
12:36:19 <HugoDaniel> lpsmith: and its preferable to joins, regarding performance ?
12:36:39 <nand`> (or rather, when the RTS does, via main)
12:36:41 <lpsmith> HugoDaniel, I don't know;  unfortunately that's above my pay grade =)
12:36:47 <HugoDaniel> :D
12:36:57 <HugoDaniel> ok, this is great, many thanks :D
12:36:57 <shachaf> acowley: Why not?
12:37:07 <gaze__> nand` okay that makes complete sense. Thanks!
12:37:32 <rwbarton> normally I would expect "class C f x | x -> f where" to turn into "class C x where type F x = ..."
12:37:38 <rwbarton> minus the =
12:37:38 <nand`> shachaf's /bin/ls quote is really superb, you can think of passing around IO () like passing around an executable program - harmless until you actually decide to execute it
12:37:51 <acowley> shachaf: The problem is that the "data instance…" line is defining a new type, so I can't use the same type to associate with two classes
12:38:07 <acowley> shachaf: I can't write data instance X f = Int
12:38:21 <acowley> at least I don't think I cand
12:38:27 <gaze__> I suppose one other reason I'm trying to do something like this is because I'd like to serialize my Foos to files, and then foo them if the program crashes...
12:39:04 <shachaf> acowley: Right, it's an actual data declaration.
12:39:16 <shachaf> Are you trying to do something like class C f x | x -> f, f -> x?
12:39:51 <acowley> shachaf: Luckily I just needed the first fundep, x -> f
12:40:04 <acowley> so I was able to turn things around and make x the instance head, and f an associated type synonym
12:40:46 <acowley> I was porting fundep code and the dependency seemed so intuitive, so I missed the easy solution at first :/
12:41:01 <shachaf> But you're wondering what to do in more complicated cases?
12:42:42 <mcstar> i wrote a sudoku solver
12:42:52 <mcstar> but now i see the haskell wiki on sudoku
12:42:56 <acowley> Well, I'm not going to worry about it, but it seems like a shortcoming of type families vs. fundeps. It's kind of like general typeclass resolution funny business where we just want to the compiler to tell us if we've given it something impossible without a priori ruling out too many interesting programs.
12:42:59 <mcstar> theres a bunch already :(
12:43:22 <acowley> One of the Oxford guys wrote a fantastic functional pearl on a sudoko solver
12:43:25 <acowley> I think it was Richard Bird
12:44:06 <shachaf> gaze__: OK, but then you'd have more methods in your type class.
12:44:23 <shachaf> gaze__: Which would be equivalent to adding more values to your record, of course. :-)
12:45:39 <shachaf> gaze__: This approach has nothing to do with IO, by the way. The most common example of this sort of thing Show: Instead of data ShowVal = forall a. Show a => ShowVal a; [ShowVal 5, ShowVal True] :: ShowVal, you just use [show 5, show True] :: String
12:46:26 <gaze__> That makes complete sense. But how do you then know what to call on your read value?
12:47:03 <shachaf> ?
12:48:44 <gaze__> can I just map (\x -> foo (read x)) [show A, show B]
12:49:19 <shachaf> Well, it's just a list of strings.
12:49:19 <Kyraimion> gaze__:  The type information is lost once you convert it to string
12:49:38 <gaze__> yeah yeah! I need to figure out how to get it back
12:49:50 <acowley> parser :: String -> MyTypes
12:49:53 <gaze__> or store it and switch on it later or something
12:50:25 <malorie> I have a list of n values and I'd like to map m functions over it. the thing is, that I'm only interested in the end-result of a certain value, e.g., the first one. iiuc, there are thunks created for all the values I'm not interested in too. so, can I somehow prevent this?
12:50:27 <shachaf> gaze__: Well, you have this problem anyway.
12:50:34 <Cale> gaze__: yeah, the general solution is to make a data type with cases for all the types you want to be able to handle
12:50:47 <Cale> gaze__: and then map things to and from that
12:51:02 <shachaf> malorie: Get rid of the values you're not interested in?
12:51:19 <Kyraimion> gaze__:  The easiest way to do that is generate a new type: "data Foo = FooInt Int | FooBool Bool | ... deriving (read, show)", then you can just read it back and pattern match on the constructor
12:51:42 <peano_player> hello
12:51:58 <gaze__> kyraimion: okay. that makes complete sense.
12:52:00 <peano_player> are Haskell typeclasses the only way to achieve polymorphism?
12:52:01 <Kyraimion> gaze__:  Of course that only works when you know what types you will have. But you have to have _some_ idea what types you want to work with anyway
12:52:02 <malorie> shachaf: well, I'd like to be able to inspect all of them, ultimatel. it's just, that I'm interested in only one at a time, if that makes sense
12:52:29 <Mortchek> peano_player, no. A function whose signature contains a type variable is polymorphic.
12:52:29 <nand`> ‘data A = A String; data B = B String;  ... do { push (A "x"); push (B "y") }’  <- this makes me think ‘why not data AB = A String | B String’
12:52:41 <Mortchek> :t fmap
12:52:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:52:46 <shachaf> malorie: You'll have to be more specific about what the problem is.
12:52:47 <nand`> peano_player: I love your name
12:53:21 <nand`> peano_player: polymorphism is more or less orthogonal to typeclasses
12:53:27 <peano_player> ah
12:53:57 <nand`> you can just as well do something like ‘forall a. Foo a -> a -> b’; which doesn't use typeclasses at all; instead of something like ‘forall a. Foo a => a -> b’
12:54:01 <Kyraimion> peano_player:  type classes are for ad-hoc polymorphis, but you can also have parametric polymorphism
12:54:14 <nand`> (that's using separate Foo definitions though)
12:54:34 <peano_player> can I have a single
12:54:54 <clahey> So, what does the * do there?
12:54:59 <nand`> I was just giving an example of how you can achieve the same effects without typeclasses; in practice you'd use typeclasses
12:55:11 <clahey> In f :: *->*
12:55:12 <Mortchek> clahey, * means a concrete type.
12:55:15 <peano_player> can I have a single function 'foo' that does something different depending on wheter it receives objects of different types?
12:55:25 <Mortchek> * -> * means a type constructor taking a concrete type and returning a concrete type.
12:55:44 <shachaf> nand`: Except when you wouldn't.
12:55:45 <nand`> would it be accurate to say ‘* is the kind of every inhabitable type’ ?
12:55:47 <clahey> Ah, in a forall statement, you're defining types.
12:56:00 <peano_player> like `speak Cat -> "meow"` and `speak 3 = '3'`?
12:56:04 <malorie> shachaf: I think I just figured it out, while trying to better phrase my question. so thanks :-)
12:56:06 <nand`> counting ‘Void’ as inhabitable, of course
12:56:12 <Mortchek> clahey, my example was probably not that great.
12:56:36 <clahey> Mortchek: I get it though.  f is a type constructor there, not a type or a function.
12:56:52 <nand`> clahey: ‘forall’ is an abstraction over a type; as the name implies, you can fill in anything you want for ‘a’ when you actually apply the function
12:56:58 <nand`> :t id
12:57:00 <lambdabot> forall a. a -> a
12:57:39 <Mortchek> You can also use typeclasses to restrict what can fill a given type variable, as (Functor f) => … does above
12:57:44 <Mortchek> So f must be of typeclass Functor
12:57:52 <Kyraimion> clahey:  It seems to be a controversial issue whether type constructors are types or not.
12:58:03 <nand`> peano_player: no, you can't ‘pattern match on types’, so to say
12:58:11 <gaze__> nand`: It's an API
12:58:24 <clahey> So you can have type classes on concrete types or type constructors.
12:58:37 <Mortchek> @where Functor
12:58:37 <lambdabot> I know nothing about functor.
12:58:56 <gaze__> users should be able to provide their own record types
12:58:59 * Mortchek does not know most of the bot's functionality. :P
12:59:00 <Kyraimion> peano_player:  You can have a type class with a function "speak" and make Cats and Ints an instance of that
12:59:08 <peano_player> ah
12:59:16 <peano_player> that works
12:59:26 <monochrom> but that strictly speaking is not "one single function"
12:59:34 <Mortchek> clahey, yes, a type constructor can be an instance of a typeclass.
12:59:42 <Kyraimion> peano_player:  "class Speaking a where speak :: a -> String" and "instance Speaking Cat where speak _ = "Meow!" "
12:59:53 <Mortchek> e.g., Functor Maybe, Monad Maybe, Functor [], etc.
13:00:25 <ski> `Functor (Either e)'
13:00:44 <clahey> Mortchek: Can you have a type class which can have instances that are both type constructors and concrete types?
13:01:29 <nand`> (what kinds of types can type classes abstract over? just stuff consisting of * and -> or would something like ‘Constraint’ or a promoted kind be theoretically possible as well?)
13:01:54 <Kyraimion> clahey:  In haskll 98, no, in GHC haskell, yes
13:02:24 <shachaf> You can?
13:02:35 <rwbarton> with PolyKinds I imagine so
13:02:49 <nand`> I thought that just lets you abstract over the ‘argument’ of a type constructor
13:02:50 <rwbarton> class CoolType t where {}
13:02:52 <clahey> :t printf
13:02:53 <lambdabot> forall r. (PrintfType r) => String -> r
13:02:58 <nand`> oh, fair enough
13:03:04 <nand`> any non-trivial class?
13:03:06 <rwbarton> Laws: Instances of CoolType must be cool
13:03:07 <Kyraimion> shachaf:  http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/kind-polymorphism-and-promotion.html
13:03:15 <edwardk> nand`: you can make classes that take classes, or even some fairly exotic kinds as arguments
13:03:16 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:03:43 <nand`> edwardk: heh, interesting
13:03:49 <hpaste> peano_player pasted “foo” at http://hpaste.org/76210
13:03:53 <nand`> so type classes can abstract over any conceivable type?
13:03:58 <rwbarton> class X a t where x :: a t
13:04:01 <Clint> jaspervd1: is websockets going to stick with -enumerator packages?
13:04:11 <nand`> or is there a limit to the exoticness
13:04:12 <rwbarton> t could be either a concrete type or something with a higher kind
13:04:26 <rwbarton> still a pretty lame example
13:04:36 <edwardk> nand`: pretty much.
13:04:41 <Kyraimion> peano_player:  putStrLn is an IO action that writes something on the terminal, it does not produce a String
13:04:45 <shachaf> Ah, I guess.
13:04:55 <Kyraimion> peano_player:  Excuse me, it creates IO actions
13:05:01 <peano_player> oops
13:05:01 <edwardk> nand`: you can't make instances for higher rank types, thats about it
13:05:01 <shachaf> When people say "GHC Haskell" I don't tend to think of the newer extensions.
13:05:47 <hpaste> peano_player pasted “Foo2” at http://hpaste.org/76211
13:05:49 <nand`> oh
13:05:58 <nand`> class Typeable a where typeOf :: Proxy a -> TypeRep
13:06:01 <nand`> of course
13:06:13 <nand`> non-lame example rwbarton
13:06:20 <acowley> edwardk: This is a minor point, but all the things you're exporting from Control.Lens now are making imports a little dicier. In particular, the addition of the Zipper lenses gave me a lot of name clashes.
13:06:24 <peano_player> so I can do OOP in Haskell? ^_^ i just did the animal example of polymorphism
13:06:37 <edwardk> nand`: or even class Typeable a where typeOf :: proxy a -> TypeRep -- no need to force it to take an actual Proxy
13:06:45 <edwardk> acowley: =/
13:06:47 <nand`> edwardk: neat
13:06:56 <edwardk> acowley: the up, down ones?
13:07:00 <acowley> edwardk: you're using names like width, right, up
13:07:03 <acowley> yeah
13:07:04 <Kyraimion> peano_player:  You can at least simulate it, but ad-hoc polymorphism is only one aspect of OO, and not in any sense exclusive to it
13:07:04 <nand`> typeOf [True] => ‘Bool’ ?
13:07:13 <edwardk> width i feel kind of guilty about ;)
13:07:24 <clahey> Kyraimion: It returns IO actions?
13:07:32 <peano_player> what exactly is exclusive to OOP?
13:07:33 <edwardk> right, up and down, i think perhaps the zipper usecase is strong enough to justify grabbing the valuable names
13:07:39 <acowley> I'm sure they make working with zipper lenses more convenient, but it means that import Control.Lens is virtually guaranteed to cause me problems
13:07:40 <nand`> edwardk: I think it would be better off to keep Zippers in a separate namespace; for example the (%) clashes horribly with Data.Ratio
13:07:45 <clahey> Kyraimion: Or creates?
13:07:59 <nand`> I mean ‘not re-export it from Control.Lens’
13:08:00 <Kyraimion> peano_player:  Objects, I would presume
13:08:06 <edwardk> nand`: (%) is used by a lot of stuff other than zippers
13:08:09 <Kyraimion> clahey:  I don't see the difference
13:08:12 <clahey> peano_player: The name?
13:08:16 <nand`> edwardk: okay. for example?
13:08:19 <monochrom> you can do OO in haskell. by using records and functions, not type classes
13:08:24 <edwardk> makeLenses uses it
13:08:26 <clahey> Kyraimion: How you think about the laziness of it.
13:08:32 <edwardk> foo % bar .~ baz
13:08:34 <nand`> oh, you mean in lens
13:08:37 <acowley> edwardk: I'm sure my needs are weird, but I very often have things called "up" and "down"
13:08:50 <acowley> that refer to the concrete concepts :)
13:08:51 <nand`> I thought you mean in other libraries
13:08:59 <clahey> Kyraimion: It's not a big deal.
13:09:14 <acowley> edwardk: Maybe have a reexport API that just has the core getter and setter symbols?
13:09:16 <edwardk> acowley: i'm somewhat torn. your concerns echo some of the ones i had when i exported it. the reason i ultimately decided to bake it in are fairly complicated
13:09:28 <ski> @where object-oriented
13:09:29 <lambdabot> http://community.schemewiki.org/?object-oriented-programming
13:09:30 <ski> peano_player ^
13:09:36 <edwardk> in particular Control.Lens.* are all exported by Control.Lens so exporting Control.Lens.Zipper separately would be strange
13:09:41 <peano_player> ill check that out
13:09:55 <Kyraimion> clahey:  Well, maybe I was being imprecise. My point just was that putStrLn is not an IO action in itself, but rather a function that returns one.
13:09:58 <edwardk> the only module under Control.Lens that _isn't_ re-exported by Control.Lens is Control.Lens.Internal
13:10:13 <acowley> edwardk: I'm sure you have thought about it, but I wanted to make sure you were at least aware that the pain caused by that decision is not entirely in your imagination :)
13:10:29 <acowley> My imports are now fairly hideous, so I might do my own Control.Lens wrapper
13:10:31 <edwardk> and if i move it off to the side so i don't break that rule then there isn't a good place to put it and its a harder case for including it in the lib
13:10:31 <nand`> ‘zup’ ‘zdown’ hmm, too ugly
13:10:32 <clahey> Kyraimion: I know.  I just figured since you were being more precise than the previous speaker, I would try to make it even more precise.
13:10:35 <edwardk> acowley: =(
13:10:48 <acowley> It's not so bad
13:10:56 <clahey> Kyraimion: Sorry for being pedantic.
13:10:59 <nand`> my only pain was having to import Data.Ratio hiding ((%)) to make room for the glorious lenses
13:11:07 <acowley> Most sufficiently large projects end up with a reexport module for a bunch of interesting things like Word8
13:11:10 <acowley> and Monoid
13:11:16 <edwardk> nand`: that one was deliberate ;)
13:11:43 <acowley> edwardk: How would you feel about having a Control.Lens.SmallAPI or something
13:11:51 <edwardk> and i have managed to avoid randomly mangling my names with prefix
13:12:06 <edwardk> i'd actually be kind of against it
13:12:15 <edwardk> it becomes another thing for folks to learn the shape and boundaries of
13:12:21 <nand`> the (%) thing really doesn't matter though since (/) works just as well
13:12:33 <acowley> I agree, but you're current strategy can't scale much further
13:12:39 <acowley> s/you're/your
13:12:41 <peano_player> what is the difference between data, type, and newtype?
13:12:50 <edwardk> sure, but i dont intend on randomly adding much more to it ;)
13:13:10 <nand`> peano_player: ‘data’ any algebraic data type; ‘type’ a simple type synonym - doesn't actually create a new type, just makes it easier for you to type out certain types
13:13:11 <edwardk> the issues list currently open is pretty much all i intend to extend the api with, and none of those take up precious names
13:13:23 <Kyraimion> clahey:  Don't be. I just think that "create sounds like it actually produces something from scratch, while "return" is more neutral to the question where it actually comes from, it might have been shared or what not.
13:13:48 <nand`> ‘newtype’ like ‘data’ but can only have a single constructor with a single field; and comes with no extra runtime overhead - basically, giving a type a different name without actually changing it (but this allows you to eg. give it different instances, or hide the constructor or whatnot)
13:13:55 <clahey> Kyraimion: Another reason to prefer return, yeah.
13:13:59 <acowley> edwardk: So why do you think the Zipper use case will be so universal?
13:14:15 <clahey> Kyraimion: My thinking was more that "creating" seems like an action, whereas "return" isn't quite as actiony.
13:14:17 <edwardk> i apologize for the pain caused to you by exporting Zipper, but i _really_ want to encourage their use
13:14:19 <acowley> I haven't looked at it yet
13:14:30 <edwardk> acowley: the zippers are the best thing in that library to me =P
13:14:34 <acowley> I'll muddle through
13:14:36 <Kyraimion> clahey:  Ah, I said "creates" I thought I said "returns". Fair point, then.
13:14:57 <edwardk> acowley: have you seen any examples of them yet?
13:15:05 <acowley> edwardk: I saw one the other night
13:15:10 <acowley> edwardk: but I couldn't unpack it
13:15:17 <edwardk> lets baby step through it
13:15:21 <acowley> I can't now
13:15:24 <acowley> I have a meeting in a little bit
13:15:35 <edwardk> zipper ("hello","world")   makes a zipper:  Top :> (String,String)
13:15:40 <nand`> I've been trying to weasel them in somewhere
13:15:42 <edwardk> down, adds to the breadcrumb
13:15:46 <acowley> but I will don my baby shoes soon
13:16:02 <edwardk> zipper ("hello","world") % down _1  :: Top :> (String, String) :> String
13:16:08 <nand`> unfortunately my current project doesn't really have any use case for lenses or zippers
13:16:22 <edwardk> but the interesting thing is you can move down into a traversal rather than just a lens
13:16:31 <edwardk> zipper ("hello","world") % fromWithin both  :: Top :> (String, String) :> String
13:16:31 <acowley> hah, this is fantastic: "Construct a zipper that can explore anything."
13:16:39 <edwardk> now left and right focuses on the strings in turn
13:16:52 <edwardk> it starts focused on the leftmost string
13:17:08 <nand`> zippers are like the line of string that let you explore mazes and best minotaurs without getting lost?
13:17:15 <edwardk> we an chain these, and you can move 'down' into composed traversals, this lets you move horizontally within _any_ slice of any structure
13:17:37 <acowley> A use of zippers I made recently involved lazily constructing the rose tree, moving the cursor around, then transplanting the cursor into another data structure defined by a different generator
13:17:41 <edwardk> nand`: yep. or the hansel and gretel breadrumb trail
13:18:10 <edwardk> acowley: save grabs the current 'cursor' path, and you can later restore it in another structure
13:18:30 <acowley> edwardk: The restoration must walk back down from Top, though?
13:18:34 <edwardk> yep
13:18:35 <nand`> yeah, and it can fail
13:18:41 <edwardk> there are 3 versions of restore
13:18:42 <acowley> edwardk: What I was doing was really just picking up the tree by the cursor and letting the branches dangle down
13:19:05 <acowley> It required patching some things up, and was almost really cool, but I eventually deemed it pointless
13:19:15 <edwardk> one that walks down from Top to exactly the element, one that walks down from Top and 'clamps' in case the traversal has fewer elements and an unsafe version
13:19:36 <acowley> I'm sure the unsafe one is the one I'd use :P
13:19:55 <edwardk> basically moving down into a traversal only works if the traversal is non-empty
13:20:24 <acowley> edwardk: Well, I agree that the zipper stuff looks exciting
13:20:25 <edwardk> within :: Simple Traversal b c -> (a :> b) -> Maybe (a :> b :> c)
13:20:42 <kosmikus> Ken`: in what context do you need to print a dot? forall?
13:20:44 <edwardk> fromWithin :: Simple Traversal b c -> (a :> b) -> a :> b :> c
13:21:00 <acowley> edwardk: But I really wish there were a better way around the name clashes
13:21:07 <edwardk> the latter assumes the traversal traversals a non-0 number of elements
13:21:20 <edwardk> clearly the best solution is to rename all your combinators ;)
13:21:29 <acowley> In this household, up is up!
13:21:37 <acowley> I very often have an up vector
13:21:50 <nand`> codown
13:22:14 <acowley> I could hide the zipper pieces, but then I could get burned again, so I switched to explicit imports.
13:22:45 <edwardk> up, upwards, rise, raise, lift, ...
13:22:46 <peano_player> when should I use an Array over a Vector and vice-versa?
13:23:15 <lispy> peano_player: array is multidimensional
13:23:25 <lispy> peano_player: vector is single dimensional
13:23:34 <acowley> edwardk: What parts of Control.Comonad did you use?
13:23:50 <lispy> peano_player: many of the places where vector is a win involve storing values that can be unpacked like Double, Int, and such.
13:23:55 * hackagebot ottparse-pretty 0.1.2.3 - Pretty-printer for Ott parse trees  http://hackage.haskell.org/package/ottparse-pretty-0.1.2.3 (BrentYorgey)
13:24:03 <edwardk> acowley: Context and Bazaar are comonads
13:24:20 <Ken`> kosmikus: I already solved it, but thanks
13:24:22 <acowley> Bazaar is a Store with a zipper?
13:24:27 <peano_player> so I use a Vector wherever I would use a C++ std::vector?
13:24:37 <lispy> peano_player: vector has more support for automatic fusion. That's where you do transformations like this: map f . map g => map (f . g)
13:24:47 <peano_player> ah
13:25:36 <nand`> I thought a Bazaar is just a traversal
13:25:43 <lispy> peano_player: Personally, I've always had better luck with vector. Even in the multidimensional case (I just make a wrapper around indexing to simulate the multidimensional case).
13:25:44 <acowley> I hadn't seen Control.Parallel.Strategies.Lens!
13:26:02 <edwardk> A bazaar is a bunch of stores where you can easily traverse it and add more
13:26:19 <acowley> I was close! It's a good name.
13:26:24 <nand`> I.. oh. Now I figured out the name
13:26:28 <nand`> ‘store’ as in shop
13:26:32 <lispy> peano_player: but yeah, C++ std::vector and Haskell Data.Vector are somewhat similar.
13:27:42 <edwardk> A Bazaar characterizes a traversal.
13:27:54 <peano_player> is there a "simplest Haskell program" that's essentially a noop like C's `int main(void) { return 0; }'?
13:28:06 <MostAwesomeDude> peano_player: main = return ()
13:28:11 <peano_player> ah
13:28:30 <pikhq> peano_player: Also, that's waaay over-verbose.
13:28:33 <pikhq> "int main(){}"
13:28:34 <pikhq> :)
13:28:39 <clahey> Now I want Hoogle for the rest of my world.
13:28:40 <peano_player> right
13:28:41 <edwardk> You can instantiate a Traversal to the type: (c -> Bazaar c d d) -> a -> Bazaar c d b     and a -> Bazaar c d b  plays the same role that a -> Store c d b  plays for a lens
13:28:47 <lispy> clahey: heh
13:28:49 <nand`> peano_player: main = return ()
13:28:49 <kosmikus> Ken`: there's forall.fmt that specifically handles the "forall" situation while still typesetting composition correctly. that's why I was asking.
13:28:55 <nand`> oh
13:28:56 <nand`> I'm very slow
13:28:57 <clahey> I want to search for a function that takes a GdK::Window and returns a Gdk::Screen.
13:29:15 <rwbarton> use hoogle on the gtk bindings :P
13:29:15 <clahey> I guess since it's object oriented, I just have to look at the docs page for Gdk::Window, eh?
13:29:33 <rwbarton> oh but this is C++ or something, not C
13:29:40 <MostAwesomeDude> pikhq: To be fair... int main(void) { exit(EXIT_SUCCESS); } /* C'mon, have some respect for the standard! */
13:30:00 <pikhq> MostAwesomeDude: My example was strictly conformant C99. Yours is not.
13:30:04 <peano_player> hoogle, hackage, cabal, and darcs ^_^
13:30:17 <MostAwesomeDude> pikhq: Hey, most of the world's stuck on C89. :3
13:30:31 <pikhq> I don't care about Microsoft's brain damage.
13:30:42 <edwardk> another way to think about the relatioship between Store and Lens is to flip the arguments to a lens
13:30:50 <pikhq> That the most popular C compiler is the IE6 of compilers is none of *my* concern.
13:30:53 <pikhq> :)
13:31:38 <edwardk> forall f. Functor f => (c -> f b) -> a -> f b     becomes a -> forall f. Functor f => (c -> f d) -> f b   -- if we ball that up into a newtype newtype Store c d b = Store (forall f. Functor f => (c -> f d) -> f b) is a perfectly good store comonad
13:31:52 <edwardk> when you repeat the same construction for a Traversal you get the type I use for Bazaar
13:32:13 <nand`>  after rdeepseq traverse :: Traversable t => Strategy a -> Strategy [a] -- did you mean t a or something?
13:32:30 <acowley> I am very tempted to use John Baez's line "The French are so sexy that even their computer system for doing mathematical proofs sounds dirty: it's called Coq." the next time I talk to someone about my research.
13:32:56 <edwardk> acowley: hah
13:33:10 <typoclass> "The French are so chicken that even ... sounds chicken."
13:33:19 <peano_player> hehe
13:33:19 <acowley> It really does cause me a fair bit of trouble. Consider it another name clash :)
13:34:04 <peano_player> I'm thinking of doing all of the K&R problems in Haskell
13:34:16 <peano_player> so that I learn both C and Haskell
13:34:44 <typoclass> peano_player: sounds like an interesting exercise!
13:34:51 <nand`> as long as you don't try to implementing them with for loops and whatnot in haskell :P
13:34:55 <nand`> -to
13:35:06 <arbn> "coq" doesn't really sound so dirty in English if you pronounce the vowel Frenchly.
13:35:13 <nand`> indeed
13:35:25 <acowley> If I try to pronounce something Frenchly, they'll think I'm having a stroke.
13:35:49 <clahey> rwbarton: hoogle on the gtk bindings would give me a good hint.  They tend to be very similar from language to language, and in particular from C to C++.
13:35:59 <acowley> Also, I've heard a lot of Americans try to exploit the vowel sound loophole, and it tends to just draw attention to the term
13:38:19 <arbn> Pronouncing it like "coke" sounds closer, to my ears, then "cock", but that's just me.
13:38:42 <troydm> arbn: lol
13:38:52 <arbn> :P
13:39:05 * troydm saw an opportunity for a joke but decided not to
13:39:11 <acowley> I usually try to have a slide with a picture of a rooster
13:39:17 <clahey> I've always heard coke o vawn, not cock o vawn.
13:39:48 <MostAwesomeDude> "Cock aw vine"j
13:39:52 <MostAwesomeDude> Welcome to the West Coas.t
13:39:52 <arbn> clahey: Exactly. So, I don't know why proof people have decided to say "cock".
13:40:01 <MostAwesomeDude> WTF keyboard, stop being sticky.j
13:40:23 <clahey> I can't tell if that last one was a joke j.
13:40:24 <Clint> cocoa van
13:40:37 <MostAwesomeDude> clahey: We may never know.j
13:40:53 <MostAwesomeDude> (On QWERTY, j and . are nowhere near each other. I think.)
13:42:37 <rwbarton> clahey: yeah, actually; I was thinking you would look at the source of the Haskell function you found, see what C-imported function it calls, but probably just its name would be a sufficient hint
13:43:35 <clahey> rwbarton: Exactly.
13:43:52 <clahey> rwbarton: And even if I did look at the C-imported function, that name would almost certainly be identical to the C++ function name.
13:46:21 <shachaf> GHC-generated assembly is so annoying to read.
13:48:16 <nand`> clearly you must write a GHC-generated-assembly mpiler to get it back into Haskell
13:49:52 <swarley> so, I was trying to think of a way to implement my own way to bifurcate arrays
13:50:02 <swarley> This is the way i wanted to do it, (pretty sure its wrong)
13:50:20 <swarley> bifurcate f xs = (filter ((==True) f xs), filter ((==False) f xs))
13:50:31 <swarley> can someone tell me how they would do it?
13:51:07 <typoclass> > partition isUpper "LolCats" --swarley, try something like this
13:51:09 <lambdabot>   ("LC","olats")
13:51:32 <swarley> Yeah, but i wanted to see if i could figure it out on my own
13:51:39 <swarley> as an exercise on currying and filters
13:51:41 <Saizan> edwardk: ever wanted free monads to be functorial in the index too? (maybe not on Hask)
13:52:11 <edwardk> you mean indexed free monads?
13:52:15 <ksf_> partition f xs = (filter f xs, filter (not . f) xs)
13:52:23 <swarley> oh
13:52:35 <pordan30> Why haven't recent "industrial-standard" functional-inspired languages adopted currying and whitespace for functional application as standard, ala Haskell?
13:52:36 <Saizan> edwardk: yep, sorry
13:53:01 <edwardk> Saizan: i think i started adding them to the 'indexed' pakage
13:53:03 <ksf_> pordan30, they mostly do.
13:53:11 <typoclass> pordan30: good question, which language(s) do you have in mind?
13:53:16 <ksf_> well, the ones that aspire to be industrial-standard.
13:53:33 <ksf_> all the actually widely used functional languages that aren't haskell are older.
13:53:52 <ksf_> (scala being an exception, but also a black sheep)
13:54:08 <pordan30> I picked up an introduction to Scala recently, and was surprised that none of the functions were curried and the syntax for application was C-like.
13:54:36 <ksf_> it's very javaesque, yes.
13:54:39 <typoclass> pordan30: hm, i guess that's scala's java heritage showing ...
13:54:48 <qasi> it's also a really... big language
13:55:38 <Puffton> are there any downsides with unpacking?
13:56:05 <ksf_> Puffton, what do you mean with unpacking?
13:56:17 <pordan30> Also, Erlang and most of the logic languages with functional features. That is the "logic" heritage showing, I suppose.
13:56:18 * ksf_ is slow today, it seems.
13:56:25 <ksf_> Puffton, it changes semantics a bit.
13:56:30 <Puffton> ksf_ {-# UNPACK #-}
13:56:32 <pordan30> ksf, typoclass: that makes sense.
13:56:33 <ksf_> you get differences wrt. bottoms.
13:56:52 <nand`> pordan30: ‘industral-standard functional-inspired languages’ tend to be imperative languages that begin moving in a functional direction. some traditions die hard
13:56:57 <ksf_> and in some cases it might make things slower. be sure to benchmark.
13:57:04 <arbn> I think the reason is, many language prefer explicit lambdas with free variables, for partial application, to keep the syntax simple. That's true for the LISPs, at least.
13:57:11 <Eduard_Munteanu> Puffton: well, it only helps you if you don't need to repack values often
13:57:40 <doomlord> industrial-standard languages will tend to remain multi-paradigm?
13:57:41 <Puffton> Eduard_Munteanu, could you give an example of where repacking is necessary?
13:57:46 <Eduard_Munteanu> There's a compiler flag that unpacks all strict fields, but that's not enabled by default.
13:58:00 <Saizan> edwardk: yeah, you have indexed free monads, but nothing like KFunctor k (Free f a) which would give you kfmap :: (KFunctor k a, Category k) => (k i j) -> Free f a i -> Free f a j, i guess you haven't found a need (i'm not even sure for which f's that's possible)
13:58:18 <Puffton> oh ok
13:58:29 <Puffton> but non-strict fields will be re-packed automatically, or? :p
13:58:42 <rwbarton> all the unpacking/repacking happens automatically
13:58:43 <edwardk> yeah i tend to work without manipulating the indices directly in there if i need to work with them then i use At or Coat
13:58:46 <pordan30> "industrial standard" is probably a misleading term to have used, however; as pointed out, it essentially means "imperative with functional features."
13:58:49 <scooty-puff> are there any examples of applicatives/monads where *> != >>?
13:58:58 <edwardk> scooty-puff: there better not be =P
13:59:04 <johnw> :t (*>)
13:59:05 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
13:59:07 <johnw> :t (>>)
13:59:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:59:14 <johnw> *> is just the Applicative version of >>
13:59:25 <edwardk> scooty-puff: The Applicative is always assumed to be compatible with the Monad.
13:59:27 <scooty-puff> k
13:59:52 <scooty-puff> the particular case is for a permutation parser that i'm trying to add a Monad instance to - pretty much copying http://hackage.haskell.org/packages/archive/uu-parsinglib/2.7.3.4/doc/html/Text-ParserCombinators-UU-MergeAndPermute.html
14:00:14 <scooty-puff> >> could be overridden to be like *>, but it would leave >>= being..
14:00:15 <scooty-puff> well
14:00:20 <scooty-puff> odd
14:00:29 <qasi> I really like SYB
14:00:35 <edwardk> >>= _would_ be odd for that monad.
14:01:13 <edwardk> the lack of monad for that is one reason why i didn't adopt the merge and permute style for 'parsers' actually
14:01:38 <edwardk> i just have the boring: http://hackage.haskell.org/packages/archive/parsers/0.3/doc/html/Text-Parser-Permutation.html
14:02:26 <edwardk> qasi: what boilerplate are you scrapping?
14:03:46 <rwbarton> edwardk: you wrote the ado quasiquoter thing, right?
14:04:15 <edwardk> rwbarton: i wrote one in scheme. don't remember if i put one together in haskell or not.
14:04:18 <qasi> edwardk, currently none, though I did use it for a interpreter+compiler of a small functional toy language (yet another lambda-descendent). it made some things really simple, elegant and beautiful. lambda-lifting for example.
14:04:19 <rwbarton> oh
14:04:32 <rwbarton> there was one posted to hackage recently I thought
14:04:42 <edwardk> rwbarton: if it was recent it wasn't me
14:04:42 <qasi> edwardk, but today and yesterday I took the time to read the original paper and see how it's really implemented. and it's just neat.
14:05:24 <rwbarton> oh, I misread this "Applicative do. Philippa Cowderoy's idea, some explanations due Edward Kmett"
14:05:32 <johnw> qasi: what are you doing with syb?
14:05:54 <edwardk> qasi: ah. 'rewriteOf uniplate' makes that sort of thing rather disturbingly easy with lens, and is built on SYB under the hood ;)
14:06:06 <qasi> johnw, just explained it to edwardk. compiler-stuff
14:06:20 <qasi> edwardk, ah, so you're saying I should look into it? 8)
14:06:25 <johnw> ooh, nice, i do compiler stuff
14:06:36 <qasi> compiler stuff is always nice!
14:06:37 <edwardk> qasi: hinting unsubtly, yes ;)
14:07:01 <qasi> heheh
14:07:59 <nand`> it would be interesting if GHCi's autocompletion would recognize package imports and only show modules from that package, if remotely possible
14:07:59 <qasi> edwardk, I guess that's it? http://hackage.haskell.org/packages/archive/lenses/0.1.2/doc/html/Data-Lenses.html
14:08:05 <edwardk> qasi: http://hackage.haskell.org/packages/archive/lens/3.0.2/doc/html/Data-Data-Lens.html#t:uniplate (and biplate) provide a traversal for getting to the first-level descendants with the same (or a different) type.
14:08:10 <edwardk> lens not lenses
14:08:30 <edwardk> now the interesting part is that there are a ton of combinators you can use with a traversal
14:08:59 <hpaste> ciaranm pasted “Are bang patterns necessary?” at http://hpaste.org/76212
14:09:00 <edwardk> e.g. http://hackage.haskell.org/packages/archive/lens/3.0.2/doc/html/Control-Lens-Plated.html#v:rewriteOf
14:09:11 <ciaranm> ^^ can i do what's in that paste without a bang pattern?
14:09:26 <ciaranm> specifically, i'd like the 42 not to be outputted if the input isn't valid
14:09:56 <maukd> ciaranm: readLn
14:09:58 <rwbarton> "evaluate y"
14:10:07 <edwardk> This means that things like 'rewriteOf uniplate :: Data a => (a -> m (Maybe a)) -> a -> m a' recursively applies a rewrite rule over and over from the bottom up until it can no longer be applied.
14:10:15 <Cale> case reads x :: Int of
14:10:18 <rwbarton> readLn is good for this particular case yes
14:10:27 <qasi> edwardk, cool. any paper I could read about it? (not saying that the documentation is bad, it seems very good at first glance, but I like reading about stuff like that)
14:10:31 <Cale>   [(y,[])] -> putStrLn (show y)
14:10:31 <scooty-puff> edwardk: here is the version i have: https://github.com/sonyandy/perm/blob/master/Control/Applicative/Perm/Internal.hs - instead of addOpt or atomOpt, <|> pure is used - though i haven't bothered to check if this is correct
14:10:42 <edwardk> er rewriteOf uniplate :: Data a => (a -> Maybe a) -> a -> a
14:10:44 <Cale>   _ -> ... something else ...
14:10:49 <ciaranm> this particular case is a bit more complicated than what i pasted, unfortunately, so readLn isn't going to help
14:10:52 <Cale> er
14:10:57 <Cale> sorry, not reads x :: Int
14:11:02 <ion> case (reads :: ReadS Integer) x of
14:11:04 <Cale> yes
14:11:20 <rwbarton> you can also stick in a y `seq` something
14:11:40 <Cale> Whenever you have   x <- return ...
14:11:48 <Cale> you can replace it with   let x = ...
14:11:54 <edwardk> qasi: it is based on Neil Mitchell's 'uniplate' whih is rather thoroughly documented. the notion of traversals and lenses that it is adapted to is documented in the readme + wiki at https://github.com/ekmett/lens#examples and https://github.com/ekmett/lens/wiki
14:11:55 <Cale> and  !x <- return ...
14:12:36 <Cale> could be replaced by a case expression, though I guess if you're not actually matching against constructors, it can't really
14:12:45 <qasi> edwardk, wow that looks very awesome, thanks
14:12:48 <Cale> (at least, not without the bang)
14:13:10 <Cale> But in this case, you want to use reads or something which actually lets you know that the parse failed
14:14:39 <ciaranm> i don't really mind the barfing. i just want it to barf before doing output that's supposed to come later.
14:15:01 <edwardk> bbiab
14:23:36 <ciaranm> hrm. i think i want $!.
14:24:13 <qasi> @type ($!)
14:24:14 <lambdabot> forall a b. (a -> b) -> a -> b
14:24:22 <rwbarton> y <- return $! foo will also work, yeah
14:24:22 <qasi> ah. strict application. okay.
14:24:29 <lispy> qasi: right
14:24:36 <maukd> ciaranm: what was wrong with evaluate?
14:24:56 <ciaranm> maukd: the place where i want to do it doesn't realise it's in IO
14:25:10 <rwbarton> do it right after the y <- ...
14:27:45 <JL_> Yes finally finish my haskell assignment so happy!
14:28:08 <johnw> JL_: congrats!
14:29:01 <kyagrd> Is anyone experienceing cabal probem? http://hpaste.org/76164 I am having this problem
14:29:20 <kyagrd> It's not a paste I wrote but someone seems to be having the same problem
14:29:44 <rwbarton> kyagrd: are you using cabal 0.10 ?
14:29:51 <kyagrd> yes
14:30:27 <kyagrd> cabal told me that I should upgrade and tried "cabal install cabal-install" but that doesn't work either :(
14:30:31 <rwbarton> right
14:30:32 <rwbarton> hang on
14:30:37 <typoclass> kyagrd: i think the problem was that an older cabal chokes on some of those new files (like warp.cabal). here is a fix: http://haskell.1045720.n5.nabble.com/cabal-update-retrieves-broken-index-warp-1-3-3-x-cabal-not-readable-td5718441.html
14:31:03 <rwbarton> yeah that's what I was looking for, thanks
14:31:13 <rwbarton> (does google not index logs of this channel?)
14:31:15 <kyagrd> typoclass: thanks
14:31:38 <typoclass> rwbarton: yw. i think it doesn't index it rightaway
14:31:40 <hpc> rwbarton: it definitely indexes, because i have found logs before
14:31:54 <hpc> it's delayed, and google doesn't give it a high ranking
14:31:54 <rwbarton> not enough pagerank maybe
14:31:56 <rwbarton> yeah
14:32:12 <rwbarton> pretty sure I have seen StackOverflow get indexed very quickly for instance
14:32:14 <hpc> pagerank strongly correlates to how many relevant other pages are linked and linked from
14:32:35 <johnw> why are several things that were warnings in 7.4 now errors in 7.6?
14:32:36 <rwbarton> didn't realize the spider frequency was based on that but it makes sense
14:32:42 <johnw> for example: Top-level binding with no type signature
14:32:55 <johnw> I don't have -Werror in my .cabal
14:32:59 <nand`> huh? I have some files that I compile with top-level bindings with missing type signatures just fine
14:33:04 <hpc> maybe a new cabal thing?
14:33:21 <johnw> but I'm using ghc directly via ghc-mod to do passive syntax checking
14:33:28 <johnw> hmm
14:33:29 <hpc> try ghc -fno-code
14:33:32 <johnw> ok
14:34:01 <hpc> and do it on a reference file with just one definition
14:34:07 <hpc> no imports, language pragmas, etc
14:35:03 <hpaste> JL pasted “Advice for more elegant way of writing this ?” at http://hpaste.org/76215
14:35:03 <johnw> huh, can't get it to happen on the command like with ghc -Wall Main.hs
14:35:14 <johnw> maybe this is a change in ghc-mod
14:35:23 <johnw> I am using an experimental ghc-7.6-compat branch...
14:36:57 <lpsmith> HugoDaniel, by the way you can flatten the value in your case with "SELECT * FROM fun(?)";  you don't need the alias thrown in there and whatnot
14:39:16 <dcoutts> kyagrd: btw, if you cabal update, the issue should now be fixed
14:39:19 <johnw> yeah, this a ghc-mod thing
14:39:41 <kyagrd> dcoutts: I just upgraded cabal-install 1.16.
14:39:49 <typoclass> > groupBy ((==) `on` signum)  [1,2,3,4,-1,-2,-3,4,3,4,2,-5,-4,-3,-3,-2,-1,10] -- JL_, here's a suggestion, although might not be what you're looking for
14:39:51 <lambdabot>   [[1,2,3,4],[-1,-2,-3],[4,3,4,2],[-5,-4,-3,-3,-2,-1],[10]]
14:39:55 <dcoutts> kyagrd: oh ok, that works too :-)
14:40:23 <JL_> typoclass: yup i can't use groupby, have to use foldr :/
14:41:03 <JL_> typoclass: i finally got the answer for foldr, looking for a probably more elegant way of writing it if possible
14:44:31 <kyagrd> does ghc 7.6 have the *:* extension?
14:46:10 <Cale> kyagrd: what is that?
14:46:13 <HugoDaniel> lpsmith: thanks :D i was looking into that
14:46:21 <kyagrd> DataKind and PolyKinds allows me to translate Conor McBride's example (not the last satge but one previous)  in his ICFP '12 talk.
14:47:02 <HugoDaniel> lpsmith: do you have any idea if this is better/worse (regarding performance) than parsing the text output with postgresql-simple in fromField ?
14:47:11 <kyagrd> HugoDaniel: oh when you have datatype promotion and kind polymorphism you might want stratified universes *:*1:*2:...
14:47:43 <HugoDaniel> kyagrd: i didn't understand :) sorry
14:47:49 <HugoDaniel> my haskell skillz are not that high yet
14:48:02 <lpsmith> HugoDaniel, I would guess that it's probably faster,  though I'd guess that the integer -> decimal -> integer conversion is probably dominates parsing that sort of record.
14:48:10 <clahey> :t fmap
14:48:11 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:48:22 <clahey> Why is the (:: * -> *) necessary?
14:48:31 <clahey> Doesn't Functor f imply that?
14:48:46 <kyagrd> You can program this kind of thing with datatype promotion http://kyagrd.tumblr.com/post/30998514801/untyped-de-bruijn-lambda-term-evaluator-using-datatype
14:48:55 <Cale> clahey: It does imply that
14:48:55 <lpsmith> So the difference probably isn't too remarkable.
14:49:07 <Cale> clahey: It's not necessary, just explicit
14:49:25 <clahey> Cale: So forall a b f. ... would be equivalent?
14:49:31 <Cale> yes
14:49:35 <clahey> Cool.  Thanks.
14:49:41 <lpsmith> (I'd guess that flattening the composite value is faster, I mean.)
14:49:52 <maukd> the entire "forall" section is not necessary
14:50:03 <kyagrd> HugoDaniel: that's a code translated from Shin Cheng Mu's Agda code. The new datatpe promotion thing lets you use data values in types.
14:50:05 <clahey> Okay, next question.
14:50:07 <clahey> @src Functor
14:50:08 <lambdabot> class  Functor f  where
14:50:08 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:50:35 <clahey> What part of that lets the compiler know that Functor f implies (f :: * -> *)
14:51:00 <clahey> The fact that it uses f a as a concrete type in the definition of fmap?
14:51:05 <hpc> clahey: yes
14:51:05 <maukd> yes
14:51:27 <rwbarton> kind inference, it sees f is applied to something and returns a type (because f a is the left-hand argument to ->), also a itself is a type because a is also the left-hand argument to ->
14:51:32 <clahey> So if the definition followed that with fakeMakeFunc :: (a -> b) -> f
14:51:36 <hpc> clahey: a simplified explanation would be that GHC builds a system of constraints from everything in the program
14:51:51 <clahey> If the definition had that, it wouldn't compile.
14:51:52 <hpc> "class Functor f" defines some "f" at the type-level
14:51:56 <rwbarton> correct
14:51:57 <Cale> You will get a kind error
14:52:02 <clahey> Because of competing constraints.
14:52:08 <Cale> right
14:52:08 <hpc> and the usage of "f a" implies f :: * -> (some sort of kind)
14:52:11 <HugoDaniel> lpsmith: :)
14:52:13 <hpc> er, well
14:52:21 <Cale> yeah
14:52:28 <hpc> f :: (the kind of a) -> *
14:52:28 <johnw> it would appear the GHCApi is doing this to me
14:52:29 <clahey> s/competing/conflicting/
14:52:48 <Cale> the usage of f a implies that f has kind k1 -> k2 for some kinds k1 and k2
14:52:50 <hpc> then "a" has no constraints except that it's a type, so GHC lumps it into *
14:52:53 <hpc> f :: * -> *
14:53:12 <clahey> hpc: Well, it's constrined to being concrete because of a -> b...
14:53:13 <Cale> and then the fact that this occurs as a parameter to (->) implies that k2 = *
14:53:41 <clahey> Cale: And the fact that a does implies that k1 = *.
14:53:42 <Cale> and the fact that a occurs as a parameter to (->) implies that a :: * and k1 = * as well
14:53:47 <hpc> clahey: ah, that too
14:53:47 <Cale> yeah
14:53:56 <hpc> :k (->)
14:53:57 <lambdabot> ?? -> ? -> *
14:54:10 <hpc> ?? and ? are boxing crap, and you can treat them like *
14:54:10 <lambdabot> Plugin `compose' failed with: Unknown command: ""
14:54:27 <Cale> In fact, in newer ghcs you won't even see the ?? and ?
14:54:27 <byorgey> wait, what version of GHC is lambdabot built with?
14:54:32 <Cale> though I think they're still there
14:54:35 <Cale> 6.12.3
14:54:42 <byorgey> GHC 7.4 and later actually show  :k (->)  as  * -> * -> *
14:54:52 <byorgey> wow, yikes
14:55:01 <byorgey> =)
14:55:23 <hpc> byorgey: is that truncated information, or did they unify the boxed and unboxed kinds?
14:55:54 <clahey> :k (*)
14:55:56 <lambdabot> parse error on input `*'
14:55:57 <byorgey> hpc: I'm actually not sure.
14:55:59 <johnw> found my fix: https://github.com/cartazio/ghc-mod/pull/2
14:56:03 <clahey> :k a
14:56:04 <lambdabot> Not in scope: type variable `a'
14:56:09 <clahey> :k Functor
14:56:10 <lambdabot>     Class `Functor' used as a type
14:56:10 <lambdabot>     In the type `Functor'
14:56:10 <byorgey> hpc: if I had to guess I'd say the former.
14:56:13 <Cale> I think it's just truncated
14:56:13 <Cale> It's pretty hard to imagine actually unifying those kinds
14:56:15 <clahey> :k Integer
14:56:17 <lambdabot> *
14:56:36 <clahey> :k Monad
14:56:37 <lambdabot>     Class `Monad' used as a type
14:56:37 <lambdabot>     In the type `Monad'
14:56:41 <clahey> That's a Class.
14:56:49 <clahey> :k StateT
14:56:51 <lambdabot> * -> (* -> *) -> * -> *
14:57:04 <clahey> Brain 'asplode.
14:57:17 <Cale> It's not that complicated
14:57:28 * homie trigger the trigger
14:57:29 <clahey> I'll get it.  It was just more than I was expecting.
14:57:35 <byorgey> clahey: in recent GHCs, :k Monad  yields  (* -> *) -> Constraint
14:57:44 <Cale> It takes the state type (of kind *), and then another monad, of kind (* -> *), and then the type of the result, which has kind *
14:57:45 <homie> for the cause->effect effect
14:57:54 <homie> lol
14:57:56 <Cale> and produces a type of computations of kind *
14:58:18 <clahey> Cale: I forgot about the state type.
14:58:21 <rwbarton> or you can read it as * -> (* -> *) -> (* -> *)
14:58:37 <clahey> It takes a state and a monad and returns a monad.
14:58:54 <clahey> state type*
14:58:58 <rwbarton> right
14:59:20 <ski> byorgey : what if you have the unboxed extension enabled ?
14:59:29 * homie butters his monad slices
15:04:41 <nand`> byorgey: I thought that was only with -XConstraintKinds, guess I was wrong
15:05:10 <hpc> 7.4.1 does it too
15:05:41 <hpc> (from another network)
15:05:41 <hpc> 18:05 < Spock> ?kind (->)
15:05:41 <hpc> 18:05 <@Data> * -> * -> *
15:06:03 <nand`> now we just need lambdabot updated to GHC 7.6.1
15:10:32 <jonkri> what should i do if i want to use the non-monadic functions of binary serialisation, perhaps by using [ http://hackage.haskell.org/packages/archive/binary/0.6.2.0/doc/html/Data-Binary.html ], but with strict bytestrings?
15:13:24 <jonkri> can i use binary-strict with involving monads?
15:24:41 <uLge> how to add executables PATH. this directory /Users/XXXXXXX/Library/Haskell/ghc-7.4.1/lib/elm-server-0.4.0.4/bin
15:25:36 <uLge> ??
15:27:05 <belowthesky> `export PATH=$PATH:/Users/XXXXXXX/Library/Haskell/ghc-7.4.1/lib/elm-server-0.4.0.4/bin`
15:27:38 <uLge> THNX
15:28:14 <rwbarton> Whatever happened to people using single question marks and vowels?
15:28:25 <belowthesky> you'll have to put that in your bashrc/zshrc for it to persist
15:28:41 <acubidu> Or your .profile
15:28:44 <typoclass> rwbarton: i think they're all working for the new yorker magazine or something
15:28:50 <scooty-puff> WHT???
15:28:50 <rwbarton> haha
15:28:50 <uLge> ?? how
15:28:51 <lambdabot>  how
15:29:05 <scooty-puff> ?? 1 + 2
15:29:05 <lambdabot>  1 + 2
15:29:09 <scooty-puff> ok what is "??"?
15:29:24 <scooty-puff> ?? $("test")
15:29:25 <lambdabot>  $("test")
15:29:30 <acubidu> scooty-puff: You seem as excited as I was when I first discovered my pubic hair
15:31:17 <DrNautilust> Hohohoho
15:31:48 <ski> ???yhjulwwiefzojcbxybbruweejw
15:32:08 * ski stares at lambdabot
15:32:14 <rwbarton> ?? info
15:32:15 <lambdabot>  info
15:32:19 <rwbarton> ??@info
15:32:27 <Ferdirand> i'm disappointed. I kinda expected this to output "yet another Haskell hacker" in some mysterious magical way
15:32:49 <homie> waaahahahahahahaha
15:34:08 <shapr> uLge: Do you play games on xbox, ps3, or other multiplayer online game?
15:34:11 <Ferdirand> !! foobar
15:34:26 <shapr> I think I recognize that particular flavor of pidgin English from that culture.
15:34:35 <uLge> ny nick is random
15:36:35 <typoclass> shapr: cats get offended if you call the language of their captions "pigeon english"
15:39:01 * hackagebot discount 0.1.1 - Haskell bindings to the discount Markdown library.  http://hackage.haskell.org/package/discount-0.1.1 (PatrickHurst)
15:41:18 <mloskot> Hi, forgive me if this a trivia, but what does the convention of A suffix in xxxA name mean?
15:41:37 <Eridius> mloskot: convention where? I've never seen that
15:42:10 <Eduard_Munteanu> mloskot: Applicative, if it's liftA...?
15:42:13 <mloskot> I'm playing with Hakyll's config file, hakyll.hs and I see construction like
15:42:30 <Eridius> oh sorry, I thought this was a different channel. I have seen that in haskell. Apologies for the noise
15:42:36 <mloskot> myMetaA = (trySetField "homeurl" "/")
15:43:50 <mloskot> I guess it's similar to constA
15:44:07 <rwbarton> wild guess but maybe from the a tag?
15:44:12 <rwbarton> in html
15:45:05 <mloskot> Eduard_Munteanu: thx
15:45:36 <mloskot> rwbarton: perhaps, I guess I'll be better asking author of hakyll.hs I'm learning from.
15:45:51 <mloskot> I've just started learning Haskell, and I'm just curious
15:50:23 <cornihilio> I've never done testing really. What should I do? I've only heard of quickcheck, not sure if that's what I should be using.
15:51:12 <typoclass> cornihilio: doctest doctest doctest! :-)
15:51:33 <Cale> cornihilio: Yes, you should use QuickCheck :)
15:52:29 <rwbarton> you are writing some kind of parser right? so you can maybe write a simple unparser and check that they are inverses with quickcheck
15:52:54 <typoclass> cornihilio: you just put lines like ">>> foo 42" and "1" in your haddock comments, and the doctest tool will verify that doing "foo 42" indeed gives "1". they double as documentation of course, showing examples of how to use your stuff
15:54:10 <cornihilio> rwbarton: oh god what do you mean :(
15:55:23 <cornihilio> I also finally managed to get the parser working, so you guys won't have to put up with my stupid data.binary and attoparsec questions :P.
15:55:54 <cornihilio> thank you all so much! I certainly would have given up by now if I hadn't found this channel.
15:56:14 <mcstar> i think my sudoku solver is not that slow compared to some from the haskell wiki page
15:56:28 <mcstar> but in general they are all slow
15:56:44 <startling> cornihilio: an unparser would take your structure and make a string
15:56:53 <typoclass> cornihilio: you're welcome, and don't forget the goat. sacrifice day is coming up next week
15:57:47 <cornihilio> startling: okay, but would that be done by something magically introspecting how my parser works, or would that be me figuring out how to generate random valid input? if so, isn't that just quickcheck anyway?
15:58:01 <startling> cornihilio: well yes
15:59:01 <cornihilio> typoclass: not sure I can do a goat.
15:59:49 <osfameron> a whole goat?
16:00:30 <watermind> I was looking at this post on Yoneda Lemma in Haskell... it's easy to follow, but the last part confuses me a bit. It says polymorphic functions work as a natural transformation. I get the idea, but don't you need Functors to have natural transformations?
16:00:40 <cornihilio> I was hoping more for a symbolic sacrifice; possibly a poorly drawn picture of a lambda.
16:01:04 <watermind> and by this post, I mean this post http://stackoverflow.com/a/10457816/1442575
16:01:13 <osfameron> perhaps a poorly drawn picture of a goat would be a good compromise
16:01:24 <cornihilio> even better
16:02:49 <osfameron> what does the ~ mean in that post?
16:02:56 <watermind> osfameron: isomorphic
16:02:59 <typoclass> cornihilio: to reiterate, you could take your parse function and one input, or a few of them, and verify that it gives the expected output. testing is as simple as "doctest foo.hs". if that's not enough anymore, you can always take it to the next level, adding quickcheck properties and generating random valid strings and all that stuff
16:03:32 <osfameron> watermind: and what does that mean?
16:03:50 <watermind> my guess is that that diagram can be written in the presence of type constructors which are Functors... but I'm not sure if I'm missing something
16:04:29 <watermind> osfameron: it's similar to having a bijection
16:04:44 * osfameron gives up
16:05:12 <rwbarton> basically it means that having a value of the one type amounts to the same thing as having a value of the other type
16:05:25 <rwbarton> specifically, you can convert in each direction with no information loss
16:05:31 <watermind> osfameron: A ~  B  if you can write  f: A->B and g:B->A such that f.g = g.f = id
16:05:34 <osfameron> how is (a,b) like a * b ?
16:05:49 <rwbarton> oh that is something else
16:06:04 <rwbarton> "~" = analogy between types and algebra
16:06:25 <rwbarton> how are they similar? well for one thing if there are a values of a type A and b values of a type B then there are a * b values of type (A, B)
16:06:48 <watermind> osfameron: oh I thought you referring to the ~ further below, down below it denotes an isomorphism
16:07:56 <osfameron> ah
16:09:37 <watermind> another thing I don't understand in that post is, how does he translate  id :: forall a . a -> a   to id :: forall a . (() -> a) -> a  ?
16:09:55 <latro`a> () -> a is isomorphic to a
16:10:25 <watermind> latro`a: ah
16:10:25 <jonkri> how can i convert a bytestring to an unsigned big-endian Integer?
16:10:44 <latro`a> since () has only one value (rather two, but you can think of the bottom one corresponding to the bottom of a)
16:10:50 <rwbarton> @hoogle foldr
16:10:50 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
16:10:50 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
16:10:51 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
16:11:04 <rwbarton> @hoogle foldr :: ByteString -- how lazy can I be I wonder
16:11:04 <lambdabot> Parse error:
16:11:04 <lambdabot>   foldr :: ByteString -- how lazy can I be I wonder
16:11:04 <lambdabot>         ^
16:11:07 <rwbarton> aw
16:11:39 <mizu_no_oto> I'm trying to install hash able via cabal, but it's failing with "hashable-1.1.2.5 failed while unpacking the package. The exception was: user error (truncated tar archive)".  http://www.haskell.org/pipermail/haskell-cafe/2012-July/102102.html suggests running rm  ~/.cabal/packages/hackage.haskell.org/... but the only thing in my ~/.cabal is config and config.platform.  Ideas?
16:11:43 <rwbarton> jonkri: anyways I think there is a foldr for ByteString, if not, unpack and then do foldr
16:12:03 <typoclass> jonkri: possibly Data.Binary?
16:12:30 <watermind> that is pretty cool
16:12:35 <jonkri> rwbarton: thanks
16:12:36 <jonkri> typoclass: Data.Binary doesn't work as it was not an Integer to begin with. i get the following error: demandInput: not enough bytes
16:12:52 <typoclass> jonkri: i see
16:13:01 <rwbarton> mizu_no_oto: "cabal update" maybe?
16:13:11 <mizu_no_oto> Already tried
16:13:19 <jonkri> thanks
16:13:20 <rwbarton> there should be more stuff in ~/.cabal/ if you've cabal updated...
16:13:26 <trolling> quick question chaps, has anyone done anything with writing code for microcontrollers in haskell?
16:14:12 <mizu_no_oto> Is there another folder it's likely using on a mac?
16:14:52 <typoclass> mizu_no_oto: try running your cabal command with "-v3" to get more information. look for the tar file that it is trying to extract and that is corrupt. maybe delete it or something, to force cabal to download it again
16:15:15 <Eduard_Munteanu> trolling: check atom
16:15:17 <typoclass> trolling: this might be relevant to your interests. not sure http://hackage.haskell.org/package/atom
16:15:17 <Eduard_Munteanu> @hackage atom
16:15:17 <lambdabot> http://hackage.haskell.org/package/atom
16:15:22 <Eduard_Munteanu> :)
16:15:41 <typoclass> Eduard_Munteanu: you're being isomorphic to me
16:15:47 <trolling> ooh
16:15:49 <trolling> grand, thanks
16:15:58 <typoclass> trolling: yw
16:16:14 <mizu_no_oto> ah, it's looking at /Users/mizunoto/Library/Haskell/repo-cache/hackage.haskell.org/hashable/1.1.2.5/hashable-1.1.2.5.tar.gz
16:16:47 <typoclass> mizu_no_oto: the path sounds plausible for a mac. that's probably the broken file
16:18:40 <mizu_no_oto> typoclass:  It was.  You have to love how the fs structure is randomly changed on a mac from the norms of other unicies.
16:19:00 <typoclass> mizu_no_oto: it's all magic an revolutionary, and very intuitive
16:19:17 <typoclass> and*
16:24:45 <watermind> latro`a: probably doesn't matter in this context, but in general  () -> A is not isomorphic to A,  because you can make the constant functions lazy or strict
16:25:01 <latro`a> true
16:25:23 <latro`a> actually
16:25:28 <latro`a> are you sure?
16:25:51 <latro`a> a () -> a can take in either () or undefined
16:25:54 <latro`a> ah I see
16:26:01 <latro`a> you can make the undefined return an a instead of undefined
16:26:11 <latro`a> OK yeah a strict () -> a is isomorphic to a
16:41:24 <jonkri> rwbarton: do you mind telling me how you would implement the foldr you mentioned above?
16:43:07 <startling> what web thing should I use for just an api?
16:43:36 <shachaf> jonkri: What foldr?
16:45:22 <jonkri> shachaf: i want to convert a bytestring of an arbitrary length to an unsigned big-endian Integer, and rwbarton suggested to use foldr on it
16:45:39 <shachaf> Oh. Makes sense.
16:45:45 <shachaf> The same way you'd do it for a list of bytes, I guess.
16:46:01 <startling> jonkri: doesn't Data.ByteString have a foldr?
16:46:09 <shachaf> It does.
16:46:22 <jonkri> startling: it does, i just don't know how to implement it, be it on a bytestring or a list :)
16:46:33 <shachaf> WOuldn't it be a foldl?
16:46:46 <startling> jonkri: implement what?
16:46:46 <watermind> latro`a: yeap, that's it :)
16:46:53 <shachaf> > foldl (\x y -> x * 10 + y) 0 [1,2,3,4]
16:46:54 <lambdabot>   1234
16:47:10 <shachaf> Like that, except with 256 and BS.foldl' and more fromIntegrals
16:47:41 <startling> do you want * 10?
16:47:53 * ion will try to wake up before 5 AM on 19th for edwardk’s talk.
16:47:54 <jonkri> startling: implement a function, ByteString -> Integer, where the integer is Big-Endian-encoded
16:48:08 <jonkri> the ByteString even :)
16:48:24 <startling> jonkri: oh! thought you meant "how do I implement foldr"
16:48:25 <startling> got it.
16:48:38 <Eduard_Munteanu> What does big-endian Integer even mean?
16:48:55 <shachaf> Eduard_Munteanu: The integer is encoded into the ByteString in a big-endian way.
16:49:06 <shachaf> The Integer value itself has no relevant endianness, of course.
16:49:07 <jonkri> Eduard_Munteanu: i'm meant to refer to the ByteString
16:49:23 <shachaf> jonkri: Anyway, what I said should work.
16:49:27 <startling> if I want a web server that does different stuff on different paths and returns some json, what should I use?
16:49:48 <Eduard_Munteanu> jonkri: why do you want to convert the *whole* Bytestring, btw?
16:49:55 <Eduard_Munteanu> Does it encode some huge number?
16:50:01 <jonkri> Eduard_Munteanu: yes
16:50:08 <shachaf> SB.foldl' (\x y -> x * 256 + fromIntegral y) 0
16:50:33 <startling> wai looks pretty dense, and it seems like yesod and snap are pretty web-application-y
16:50:34 <Eduard_Munteanu> jonkri: and how do you get that BS to begin with? Maybe you're starting with an integer.
16:50:49 <Eduard_Munteanu> (in which case something like Cereal might do)
16:50:55 <jonkri> Eduard_Munteanu: genBytes 40 :)
16:50:55 <shachaf> Wait, you're that cryptography person, aren't you?
16:51:11 <shachaf> I shouldn't be giving you advice on that.
16:51:43 <Eduard_Munteanu> jonkri: mm, randomly-generated?
16:51:45 <jonkri> shachaf: i am
16:51:49 <jonkri> Eduard_Munteanu: yes
16:52:01 <Eduard_Munteanu> jonkri: then why do you care about endianness? :D
16:52:14 <shachaf> Eduard_Munteanu++ has a point.
16:52:27 <jonkri> Eduard_Munteanu: because i need to treat the integer as a big-endian number, because that's how it will be treated by other implementations
16:52:45 <jonkri> the bytestring, i mean :P
16:52:47 <shachaf> jonkri: Didn't you just say it was random bytes?
16:53:35 <jonkri> oh, right, of course
16:53:50 <jonkri> i'm a little tired. sorry. i meant to say that the  integer was unsigned :)
16:54:02 <jonkri> s/was/were to be
16:54:13 <jonkri> good point Eduard_Munteanu :)
16:55:11 <Eduard_Munteanu> (of course that only applies if it's high-quality entropy, otherwise I guess endianness might make a difference)
16:55:43 <Eduard_Munteanu> For example, if something's meant to discard n most significant bits.
16:55:58 <jonkri> yeah
16:56:04 <jonkri> i just need to get an Integer out of it :)
16:56:07 <jonkri> for now
17:05:57 <startling> any opinions on "scotty"
17:05:58 <startling> ?
17:07:44 <sm> looks awesome
17:07:59 <sm> don't expect it to fill all your needs, is all
17:09:02 <startling> yeah. I just want a tiny restful json api; seems like it'll be sufficient
17:09:09 <startling> I like that it's wai-handler-agnostic, too
17:09:32 <sm> wai++ !
17:09:43 <rwbarton> jonkri: oops yeah it should be a foldl', sorry
17:11:43 <shachaf> Real programmers express foldl in terms of foldr..
17:11:51 <shachaf> ...Even with ByteString, where it doesn't make any sense.
17:12:22 <startling> shachaf: doesn't make sense to you? you must not be a real programmer
17:19:40 <kdridi> is there any way to discover easily the methods of a class in ghci
17:19:49 <shachaf> kdridi: :i
17:20:26 <kdridi> shachaf, you save my life !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
17:20:58 <lightquake> i wonder if it's worth upgrading to ghc 7.6
17:21:02 <kdridi> shachaf, why i didn't think about that before ? :)
17:21:16 <shachaf> lightquake: Of course it is.
17:21:27 <shachaf> I can't imagine life without 7.6.
17:21:45 <lightquake> I have no clue if you're being serious or not
17:23:14 <shachaf> lightquake: The statement is technically accurate in that I'm so used to 7.6 that I've forgotten what it introduced.
17:23:51 <Cale> technical accuracy is the best kind of accuracy
17:24:56 <lightquake> the thing i'm excited about is -fdefer-type-errors
17:25:03 <shachaf> Ew.
17:25:38 <lightquake> wait, what's ExplicitNamespaces do?
17:25:44 <scooty-puff> is it possible to have hackage provide the associated instances with a type synonym if the original type isn't exported from the module (also, how customizable is this in general?)?
17:27:21 <lightquake> eh i think i'll do it anyway; i have to do it at some point so i might as well
17:27:24 <lightquake> well, 'have' to
17:28:02 <shachaf> It breaks a lot of packages, lightquake.
17:28:21 <lightquake> like?
17:28:32 <shachaf> Anything that uses Control.OldException
17:28:43 <shachaf> Slowly things are getting fixed. cabal-install was only fixed recentlish.
17:28:51 <lightquake> ah
17:28:58 <lightquake> what broke cabal?
17:29:33 <shachaf> I don't know.
17:29:35 <lightquake> also i think i might give it a month or two then
17:29:51 <shachaf> lightquake: It has all these great extensions!!!!!
17:30:04 <shachaf> Also you can have multiple versions of GHC installed at once, so what's the worst that could happen, right?
17:30:44 <lightquake> haha
17:52:35 <crdueck> @hoogle Maybe [a] -> [a]
17:52:35 <lambdabot> Data.Foldable concat :: Foldable t => t [a] -> [a]
17:52:35 <lambdabot> Prelude cycle :: [a] -> [a]
17:52:35 <lambdabot> Data.List cycle :: [a] -> [a]
17:53:49 <dgpratt> what would a dual to the Hask category look like? does that even make sense as a concept?
17:54:04 <shachaf> @ty join . maybeToList
17:54:06 <lambdabot> forall a. Maybe [a] -> [a]
17:55:54 <shachaf> @ty fromMaybe []
17:55:55 <lambdabot> forall a. Maybe [a] -> [a]
17:56:11 <rwbarton> "dual" is one of those tricky context-sensitive words.
17:56:38 <shachaf> @quote dual
17:56:38 <lambdabot> cmccann says: C++ is dual to Haskell in a sense: it's much too hard for the average programmer to use safely, but they do anyway with disastrous results; whereas Haskell isn't actually that difficult
17:56:38 <lambdabot> to use but people don't even try
17:57:37 <Dashkal> Hask (op) doesn't seem all that sensical to me.  Hask but with all the arrows reversed.  So a model of haskell where computation flows backwords?
18:00:07 <dgpratt> I am reading a description of the Yoneda lemma; dual categories seem to be part and parcel of the whole scheme
18:00:56 <shachaf> Yodon'tneda lemma!
18:05:07 <Saizan> Dashkal: nah, it's just a category where arrows X -> Y correspond to functions Y -> X in haskell
18:21:44 <dobblego> !seen paczesiowa
18:22:36 <shachaf> preflex: seen paczesiowa
18:22:36 <preflex>  Sorry, I haven't seen paczesiowa
18:22:40 <shachaf> @quote paczesiowa
18:22:41 <lambdabot> paczesiowa says: my friends (evil, imperative and objectionable) from university laugh at me that I love haskell and I wont find any job as haskell programmer. I get sad when I start to believe them.
18:22:41 <lambdabot>  but then I look at some java code and I'm all happy again
18:27:47 <startling> I want to represent a three-dimensional grid in haskell. I want to be able to say "get the plane where x = 12" or similary.
18:28:06 <startling> I'd also like to be able to make them grow on request.
18:28:08 <startling> any ideas?
18:28:16 <startling> all the Arrays seem kind of clumsy
18:30:24 <shachaf> Cale: Linode just had some trouble -- might want to restart lambdabot.
18:34:40 <startling> isn't there a writing-games-in-haskell channel somewhere?
18:36:57 <clahey> :t empty
18:37:18 <startling> clahey: lambdabot is awol at the moment
18:37:25 <clahey> Oi.
18:37:46 <startling> it's Alternative a => a, though
18:37:53 <clahey> Thanks.  :)
18:38:23 <startling> er, Alternative a => a b
18:39:14 <startling> slow day here, huh.
18:39:44 <shachaf> > 1
18:39:54 <kappabot>   1
18:41:16 <startling> shachaf: wow, kappabot has questionable loyalty
18:41:40 <shachaf> I think kappabot is dead.
18:41:44 <shachaf> thanks a lot, kappabot
18:52:58 <jonkri> > 2^920200957910967272295176306733928239831078447145060140800134339743569564664961222890135291934035 `mod` 24103124269210325885520760221975660748569505485024599426541169419581088316826122288900938582613416146732271414779040121965036489570505826319427307068050092230627347453410734066962460145893616597740410271692494532003787294341703258437786591981437631937768598695240889401955773461198435453015470437472077499697637500843089263392955599688824578724129938101
18:52:58 <jonkri> 29130294592999947926365264059284647209730384947211681434464714438488520940127459844288859336526896320919633919
18:53:05 <jonkri> oops :)
18:56:01 <jonkri> arithmoi seems good :)
18:58:36 <shapr> yow!
18:58:44 <shapr> preflex: seen TheHunter
18:58:44 <preflex>  Sorry, I haven't seen TheHunter
18:59:31 <startling> preflex: seen preflex
18:59:31 <preflex>  what
18:59:35 <startling> haha
18:59:45 <shachaf> preflex: seen mauke
18:59:45 <preflex>  mauke was last seen on #perl 41 days, 13 hours, 20 minutes and 23 seconds ago, saying: where's your sudo?
19:01:23 <dreixel> @tell
19:01:51 <dreixel> uhm.
19:05:46 <maukd> the hell
19:06:51 <dreixel> preflex: tell
19:06:51 <preflex>  what
19:06:59 <dreixel> preflex: tell donri
19:06:59 <preflex>  Consider it noted.
19:07:38 <dreixel> preflex: tell donri perhaps it's best you email me or the generics mailing list? I'm not reading IRC very often...
19:07:38 <preflex>  Consider it noted.
19:08:02 <shachaf> preflex: seen augustss
19:08:02 <preflex>  Sorry, I haven't seen augustss
19:08:48 <DanBurton> hey guys, I have a monad transformer, and I want a few more eyes to look it over and make sure it obeys monad laws
19:09:04 <shachaf> It's not that state thing, is it?
19:09:14 <hpaste> DanBurton pasted “Continuation Mark Monad” at http://hpaste.org/76217
19:09:20 <DanBurton> nope
19:09:23 <DanBurton> it's continuation marks
19:09:37 <shachaf> What's that?
19:09:50 <DanBurton> it's sort of a stack inspection thingey
19:10:23 <DanBurton> http://docs.racket-lang.org/reference/contmarks.html
19:11:50 <maukd> preflex: seen god
19:11:50 <preflex>  god was last seen on ##c++ 3 years, 10 days, 3 hours, 5 minutes and 47 seconds ago, saying: I don't really know either actually
19:13:07 <shachaf> I don't understand it.
19:13:15 <shachaf> What's the Bool?
19:13:52 <shachaf> What's Lift and CM?
19:15:49 <DanBurton> the Bool is a flag for whether or not a thing is in "tail call" position
19:15:53 <jonkri> does anyone know if there is a library that can convert a big (hundreds of digits) Integer to an unsigned big-endian ByteString?
19:16:16 <DanBurton> got to go now :P be back later maybe
19:17:17 <maukd> :t unfoldr
19:17:18 <shachaf> jonkri: Spoilers: ByteString.unfoldr
19:17:37 <shachaf> Or maybe unfoldl if it has that.
19:18:53 <jonkri> good function :)
19:18:57 <jonkri> thanks
19:19:14 <jonkri> did i kill lambdabot earlier? :S
19:19:19 <jonkri> > 1 + 1
19:19:19 <shachaf> No.
19:19:28 <shachaf> For once it's not you.
19:20:16 <pharaun> you can kill the bot? :(
19:20:18 <pharaun> poor guy
19:20:33 <maukd> preflex: seen Cale
19:20:33 <preflex>  Cale was last seen on #haskell 1 hour, 56 minutes and 34 seconds ago, saying: technical accuracy is the best kind of accuracy
19:20:36 <dmwit> hundreds of digits is not big by today's standarsd
19:20:46 <shachaf> dmwit: It is if you want to count that high!
19:22:07 <jonkri> i gave it a quite extensive modpow calculation to perform earlier. since then, it's been dead quiet :(
19:23:20 <shachaf> There was already no lambdabot.
19:24:04 <startling> I want a bunch of nested quadtrees such that QuadTree 0 a = Q a a a a and QuadTree n a = Q (QuadTree (n - 1) a) (QuadTree (n - 1) a) (QuadTree (n - 1) a) (QuadTree (n - 1) a)
19:24:12 <startling> is this possible with data kinds or something?
19:24:38 <maukd> preflex: seen lambdabot
19:24:38 <preflex>  lambdabot was last seen on #haskell 1 hour, 1 minute and 53 seconds ago, saying:  but then I look at some java code and I'm all happy again
19:24:48 <dmwit> startling: It is possible with no special extensions.
19:25:04 <startling> dmwit: oh really?
19:25:08 <startling> interesting
19:25:12 <shachaf> dmwit: You mean a complete 4-tree, or one with a size known at compile-time?
19:25:27 <dmwit> data QuadTree a = Zero a | Succ (QuadTree (a, a, a, a))
19:25:30 <shachaf> In a convenient way, that is.
19:25:36 * shachaf knew dmwit was going to say that.
19:25:47 <startling> dmwit: I want the size encoded in the type
19:26:05 <maukd> tuples?
19:27:07 <dmwit> Okay, then, yes, you need some type-level stuff. Data kinds would be quite useful, though not required.
19:28:05 <startling> how would I special-case the members of QuadTree 0, though?
19:29:03 <startling> really I have no idea how this would work.
19:29:12 <maukd> data QuadTree n a where Zero :: a -> QuadTree Z a; Succ :: QuadTree n (a, a, a, a) -> QuadTree (S n) a
19:29:24 <startling> maybe I should do something simpler first? like length-encoded lists
19:29:35 <startling> maukd: is that gadts? interesting
19:30:27 <shachaf> data family QuadTree (n::Nat) a; data instance QuadTree 0 a = Q a a a a; data instance QuadTree (1+n) a = Q (QuadTree n a) (QuadTree n a) (QuadTree n a) (QuadTree n a) -- almost exactly what startling wrote. :-)
19:30:48 <shachaf> But the GADT is probably nicer.
19:32:25 <mietek> I have a problem with cabal-install-0.16
19:32:46 <mietek> After the initial cabal-update, an invalid .cabal/config is created
19:32:49 <startling> shachaf: what extensions does that use?
19:32:58 <shachaf> startling: TypeFamilies
19:33:04 <mietek> Looks like the line "jobs: 2" is causing a problem
19:33:06 <mietek> "cabal: Command.optionToFieldDescr: feature not implemented"
19:33:06 <shachaf> And GHC Nats in 7.6
19:33:24 <mietek> Has anyone else seen this?
19:34:01 <startling> shachaf: I'm getting "parse error on input `0'" from data instance  QuadTree 0...
19:34:14 <mietek> https://bbs.archlinux.org/viewtopic.php?pid=1174205
19:34:14 <shachaf> And you're using 7.6?
19:34:41 <startling> shachaf: oh, nope, thought I was
19:34:51 <shachaf> OK, then data Nat = Zero | Succ Nat
19:35:03 <shachaf> (Uh, 7.4 had DataKinds, right?)
19:35:27 <startling> shachaf: (it doesn't throw up on {-# Language DataKinds #-} at least)
19:35:41 <shachaf> OK, then use DataKinds.
19:35:45 <swarley> I was wondering, how do  frameworks in haskell work generally? Since you can't (to my knowledge) just do something like addEventHook \ x -> doSomethingWith x
19:35:48 <startling> where do I import Nat from?
19:35:51 <shachaf> (It would work without DataKinds too.)
19:35:58 <shachaf> You make it as I showed above.
19:36:01 <dmwit> DataKinds is buggy in 7.4.
19:36:14 <shachaf> dmwit: Even for a simple thing like this?
19:36:14 <dmwit> (It wasn't an advertised feature yet.)
19:36:20 <dmwit> Probably not?
19:36:24 <dmwit> But "probably" is scary.
19:36:29 <startling> shachaf: oh, didn't realize that was code and not explanation
19:36:31 <shachaf> Anyway, if DataKinds doesn't work, you can do without it.
19:36:48 <shachaf> @remember startling oh, didn't realize that was code and not explanation
19:36:51 <shachaf> Bah.
19:36:58 <startling> haha
19:37:02 <Eduard_Munteanu> swarley: yes, why not?
19:37:26 <jaspervd1> Clint: Probably not in the long term
19:37:47 <jaspervd1> but I'm waiting for the landscape to stabilize a bit
19:37:51 <swarley> Since values arent mutable generally
19:38:32 <swarley> you cant just dynamically add an event hook (but maybe you can, that's why i'm asking)
19:38:54 <startling> swarley: you'd use something like State
19:39:04 <Eduard_Munteanu> swarley: sure you can, addEventHook can modify an internal state.
19:39:22 <swarley> I thought that state modification took away purity?
19:39:23 <Eduard_Munteanu> E.g. it can be an IORef if it's something in IO.
19:39:39 <startling> swarley: nope!
19:39:45 <swarley> oh okay
19:39:47 <startling> swarley, learn about the State monads
19:39:47 <Eduard_Munteanu> swarley: it doesn't. But are you familiar with the state monad?
19:40:01 <swarley> No, I've had trouble learning monads in the past
19:40:14 <swarley> I keep attempting to.
19:40:15 <shachaf> No one said anything about "learning monads", whatever that means. They said State.
19:40:24 <sm_> evening all. Is there a library function or idiom to filter out subtrees of a Tree all of whose nodes satisfy a predicate ? Eg, a tree of integers, I'd like to discard all the 0 leaves and their 0 parents
19:40:27 <swarley> Well, no i know nothing about state
19:40:40 <swarley> I can barely write a program lol
19:40:45 <swarley> in haskell *
19:40:46 <Eduard_Munteanu> swarley: you might want to start looking at Maybe first, it's a bit simpler than State.
19:40:54 <gertc> what is Shim support in yi?
19:41:38 <Eduard_Munteanu> swarley: but anyways, a simple way to modify some state is to just pass around different arguments.
19:42:06 <startling> shachaf: I'm getting "Not in scope: type constructor or class" for 'Z' and 'S', when I have data Nat = Z | S Nat right there
19:42:14 <Eduard_Munteanu> For example, you can have a function f :: MyState -> (SomeValue, MyState).
19:42:14 <swarley> like, what i'm looking to do is something like, addEvent (\ x -> putStrLn x) \n addEvent (\ x -> putStrLn reverse x) \n callEvents "hello world"
19:42:30 <dmwit> sm: Don't know of one, but it should be easy to write.
19:42:45 <shachaf> startling: Sounds like you don't have DataKinds.
19:43:11 <shachaf> Or something. I don't know. You're not vague to GHC; why be vague to IRC?
19:43:12 <dmwit> f :: Tree Int -> Forest Int; f (Leaf 0 _) = []; f (Leaf x children) = Leaf x (children >>= f) -- something like this
19:43:13 <Eduard_Munteanu> swarley: ok, can you tell the type of addEvent?
19:43:19 <startling> shachaf: wow, you're psychic
19:43:28 <shachaf> startling: I wish I didn't have to be. :-(
19:43:42 <swarley> Well, thats just pseudo code
19:43:45 <startling> shachaf: in the future, remind me that I don't need to show you code. :)
19:43:50 <shachaf> IRC should be as strict as GHC about certain things.
19:44:04 <shachaf> Like seeing code before printing messages abou tit.
19:44:32 <Eduard_Munteanu> swarley: not necessarily, it's almost valid Haskell, provided correct definitions for addEvent and callEvents.
19:45:07 <startling> swarley, learn to use Maybe and thence Reader, Writer, and State
19:45:13 <swarley> I just am not entirely clear as to how all of the lambda's added with addEvent are stored for callEvent to see
19:45:22 <sm> dmwit: it seems so.. thanks
19:45:25 <startling> swarley, a thing monads can do is hide some state
19:45:27 <swarley> not that real code exists
19:45:44 <Eduard_Munteanu> swarley: well, addEvent :: String -> IO (), it can use IORefs since it lives in IO land.
19:45:52 <Eduard_Munteanu> Erm.
19:46:02 <Eduard_Munteanu> addEvent :: (String -> IO ()) -> IO ()
19:46:15 <startling> swarley: it's the same as if all of your functions were [Events] -> a -> ([Events], a)
19:46:49 <shachaf> ContT () IO a
19:46:51 <startling> swarley: addEvent events event = (event:events, event)
19:47:02 <startling> or (event:events, ())
19:47:10 <swarley> why the tuple?
19:47:23 <startling> swarley: the first element is your list of events
19:47:37 <startling> swarley: if you used the state monad, it would hide the first element
19:48:28 <swarley> so,
19:48:35 <sm> dmwit: how would Leaf x (children >>= f) work there ?
19:49:05 <swarley> could i get a basic example of code that changes state on function call?
19:49:12 <startling> swarley: sec
19:49:16 <swarley> Sorry, i'm just new to functional languages
19:49:19 <swarley> Not programming
19:49:36 <dmwit> sm: It might be easier to understand if you spell it Leaf x (concatMap f children) or even Leaf x (concat (map f children)).
19:50:20 <Eduard_Munteanu> :t newIORef
19:50:35 <Eduard_Munteanu> Grr.
19:50:37 <dmwit> sm: Mostly, though, it's just a trick for spelling "filter" in a funny way. =)
19:51:02 <shachaf> Hmm...
19:51:03 <shachaf> newtype Rec a = InR { outR :: Rec a -> a }
19:51:09 <shachaf> That's sort of like Curry's paradox.
19:51:46 <dmwit> > let funnyPredicate x | even x = [] | odd x = [x] in [1..5] >>= funnyPredicate
19:51:54 <dmwit> Oh, right, no bot.
19:52:06 <Eduard_Munteanu> swarley: if you're in IO, you can do stuff like   do { ref <- newIORef 5; modifyIORef ref (+1); v <- readIORef ref; putStrLn (show v) }
19:53:18 <shachaf> newtype Wreck b a = InW { outW :: Wreck b a -> b }
19:53:21 <shachaf> Does that have a name?
19:54:20 <Eduard_Munteanu> shachaf: what's the point of 'a'?
19:54:21 <shachaf> Wait, that's silly.
19:54:32 <shachaf> Never mind. :-)
19:54:38 <shachaf> So Rec *is* Curry's paradox.
19:54:50 <sm> dmwit: that's trippy.. what monad is that >>= in ?
19:55:03 <shachaf> sm: Just look at the type of (>>=)
19:55:06 <Eduard_Munteanu> sm: the tree monad for that particular tree type
19:55:09 <dmwit> sm: [] monad
19:55:09 <startling> swarley: sorry for the wait: https://gist.github.com/291c88e22b63650fc82c
19:55:14 <shachaf> Eduard_Munteanu: No, just []
19:55:20 <swarley> oh thank you very much
19:55:31 <Eduard_Munteanu> Oops.
19:55:58 <swarley> so modify is from the Monad.State?
19:56:06 <startling> Control.Monad.State, yeah
19:56:20 <Eduard_Munteanu> swarley: don't mix up State and IORefs.
19:56:29 <startling> and when you "(execState someFunction [])", you're giving it an initial value
19:56:40 <sm> I'll have to take your word for it.. thanks for the pointer
19:56:50 <startling> Eduard_Munteanu: he asked for an example using the State monad, I gave him one
19:57:34 <Eduard_Munteanu> sm: you don't have to :). dmwit above mentioned concat (map f children), that's just x >>= f = join (fmap f x) specialized to lists.
19:57:35 <swarley> you know, that makes a lot more sense
19:57:50 <swarley> as to how frameworks can be possible
19:58:24 <startling> @unmtl Event -> State [Event] ()
19:58:30 <startling> oh right, no bot
19:58:39 <Eduard_Munteanu> swarley: you can always mimic what State does yourself.
19:58:48 <shachaf> Cale: The people are suffering here!
19:58:56 <Eduard_Munteanu> It's just argument passing in a fancier way.
19:58:57 <swarley> what does it do exactly?
19:59:28 <shachaf> roconnor: You mentioned Rec in your talk, right?
19:59:47 <startling> swarley: my "addEvent" would be addEvent state evt = (evt:state, ())
19:59:58 <swarley> ohh
19:59:58 <Eduard_Munteanu> swarley: it takes care of threading s -> (a, s) functions for you
20:00:03 <sm> I see it now, Forest is [Tree].. thanks
20:00:05 <startling> swarley: it's the same as explicitly passing around the state
20:00:21 <startling> sm: there's a proverb about that
20:00:38 <solrize> @src liftA2
20:00:40 <Eduard_Munteanu> swarley: that is, functions which read some state, and output a (possibly different) one, along with a return value.
20:02:33 <startlebot> solrize: liftA2 f a b = f <$> a <*> b
20:02:53 <Eduard_Munteanu> @botsnack
20:03:04 <startlebot> Eduard_Munteanu: yum!
20:03:08 <Eduard_Munteanu> :)
20:07:53 <solrize> @pl
20:08:08 <solrize> @pl \p1 p2 x -> p1 x && p2 x
20:08:17 <dmwit> liftM2 (&&)
20:08:19 <geekosaur> bot's down
20:08:34 <solrize> dmwit :)
20:08:35 <solrize> thanks
20:08:54 <solrize> there's got to be some other way to do that though
20:09:07 <rwbarton> what was the name of that little package for pretty printing Show output?
20:09:09 <solrize> i mean, what monad does that even refer to?
20:09:17 <startlebot> solrize: uncurry (&&) . (p1 &&& p2)
20:09:22 <shachaf> rwbarton: groom
20:10:04 <rwbarton> thanks
20:16:20 <JunkBee> Heya, I am reading this tutorial http://blog.moertel.com/articles/2004/03/13/concurrent-port-scanner-in-haskell
20:16:26 <rwbarton> turns out when your record has fields with names generated by bindings-dsl, the output is still ugly ;)
20:16:39 <JunkBee> However; the article is a little out of date and wont compile due to the last line with handle
20:16:44 <JunkBee> How to handle this handle?
20:16:54 <rwbarton> there should be a Text.Groom.print
20:17:00 <shachaf> whoa, dude, 2004
20:17:09 <shachaf> Haskell existed in 2004?
20:17:16 <mietek> Is installing documentation with hyperlinked sources still exactly as much pain as it was in 2009?
20:17:20 <JunkBee> There is a Haskell version 98 no?
20:17:29 <shachaf> Crazy, man.
20:17:53 <shachaf> JunkBee: Anyway, "wont compile" isn't a very helpful thing to say when you're asking a question.
20:18:04 <shachaf> Unless you mean "wont to compile", in which case there's no problem. :-)
20:18:10 <dmwit> mietek: "pain"?
20:18:11 <JunkBee> shachaf: I get ' No instance for (Exception e0) arising from a use of `handle''
20:18:19 <dmwit> mietek: It's "cabal haddock" and you're done.
20:18:25 <rwbarton> does Control.OldException still exist?
20:18:31 <shachaf> Not in 7.6
20:18:36 <mietek> dmwit: for every dependency of every package I "cabal install"?
20:18:51 <dmwit> mietek: Just turn on "documentation: True" in ~/.cabal/config
20:18:53 <shachaf> JunkBee: Try (\(_::IOException) -> return defaultVal) instead of (const $ return defaultVal)
20:19:04 <shachaf> You might need to add {-# LANGUAGE ScopedTypeVariables #-} to the top of the file.
20:19:08 <dmwit> But yes, if you want hyperlinks to other documentation, you must have that other documentation.
20:19:16 <dmwit> Hard to imagine how that could be any different.
20:19:29 <mietek> dmwit: http://hackage.haskell.org/trac/hackage/ticket/534
20:19:33 <rwbarton> I think mietek wants links to hscolour source...?
20:19:38 <mietek> dmwit: and http://hackage.haskell.org/trac/hackage/ticket/517
20:19:42 <rwbarton> if not, I was also just wondering how to do that
20:19:59 <mietek> These two tickets suggest that generating hyperlinks to sources in documentation isn't possible via the configuration file
20:20:22 <mietek> Or via "cabal install" at all
20:20:23 <rwbarton> and now I know!
20:20:30 <mietek> rwbarton: I found http://vorotylo.livejournal.com/68074.html
20:20:37 <mietek> Which is a manual workaround from 2009
20:20:47 <mietek> Also, pain
20:21:01 <rwbarton> I already have a horrible "cabal configure && cabal build && ..." thing going on anyways for my project
20:22:12 <JunkBee> Couldn't match type `IOException -> m0 (Maybe a1)' with `IO (Maybe a2). Is the new output. What does the {-##-} do?
20:22:26 <rwbarton> @type handle
20:22:28 <shachaf> Never mind the {-# #-}
20:22:46 <shachaf> rwbarton: It's really unsatisfying, isn't it?
20:22:50 <rwbarton> oh
20:22:53 <rwbarton> .... hah.
20:22:57 <shachaf> You just wait for something to happen and it never does.
20:23:02 <rwbarton> so used to it anyways
20:23:10 <shachaf> handle :: forall e a. Exception e => (e -> IO a) -> IO a -> IO a
20:23:17 <startlebot> k, so I've got size-encoded quadtrees. I probably want some polymorphic lookup function.
20:23:23 <startlebot> how would I do that?
20:23:26 <startlebot> do I need a typeclass?
20:23:35 <shachaf> startlebot: A function to do what?
20:24:04 <JunkBee> shachaf: It yells at me that I should put the ScopedTypeVariables back now.
20:24:20 <startlebot> shachaf: I'm using a quadtree to represent a two-dimensional grid
20:25:03 <shachaf> JunkBee: Works for me with the change I said.
20:25:11 <shachaf> Which means you probably didn't make the change I said. :-)
20:25:17 <shachaf> (By works I mean compiles.)
20:25:27 <rwbarton> it is wont to compile for shachaf
20:25:55 <shachaf> preflex: rot13 shachaf
20:25:55 <preflex>  funpuns
20:25:59 <startlebot> can I do lookup :: x -> x -> QuadTree n m -> Maybe m, such that x <= (n - 1)^2?
20:26:14 <startlebot> or is that out of the type-checker's capacity?
20:26:51 <startlebot> er, 2^(n + 1), sorry
20:26:59 <rwbarton> assuming you mean what I think you mean, I think it is possible but you probably don't want to really do it (except maybe in 7.6)
20:27:38 <startlebot> k. then I can just use Nothing to also mean "out of bounds"
20:27:53 <rwbarton> well, maybe it is not so bad
20:28:08 <rwbarton> if n is never going to be very large
20:28:27 <JunkBee> shachaf: Oh it did compile, I am not use to ghc.. I was thinking the error messages ment failed to compile; however, success is denoted above the failures.
20:28:27 <Eduard_Munteanu> What, type-level naturals?
20:28:30 <rwbarton> Fin n is effectively unary right?
20:28:39 <shachaf> "you must construct additional bounds!"
20:29:04 <shachaf> Hmm, can you do something cleverer than unary?
20:29:05 <Eduard_Munteanu> rwbarton: if it's anything like Agda's Fin. :/
20:29:11 <shachaf> Given that GHC's new Nat isn't unary.
20:29:25 <startlebot> but anyway, how would I write a lookup function on QuadTree n m for all n?
20:29:28 <rwbarton> doesn't e.g. idris do something cleverer than unary?
20:29:42 <startlebot> can I get the n as a value-level Nat somehow?
20:30:02 <shachaf> Those crazy idrisians and their "real world" nonsense.
20:30:12 <rwbarton> pretty sure for Nat, not sure for Fin n
20:30:22 <Eduard_Munteanu> Who cares, it's compile-time anyway. :P
20:30:41 <dolio> Unless he's done it since last year, Nat unary in idris.
20:30:48 <rwbarton> oh really, hmm
20:30:58 <dolio> Because making it not unary is too trivial to bother with.
20:30:58 <rwbarton> this "information" is from january, so I guess it is wrong
20:31:03 <rwbarton> heh
20:31:09 <rwbarton> oh right, there was a term for that
20:31:18 <dolio> The "Thorsten future".
20:31:21 <rwbarton> yes
20:32:04 <shachaf> I remember the term but I'm not sure what "Thorsten" is.
20:32:46 <maukd> a name
20:33:25 <shachaf> How is it related to the future?
20:33:58 <dolio> The whole phrase was something like, "In the Thorsten future, idris will have naturals backed by GMP."
20:34:34 <dolio> Which is a hypothetical future where people have implemented all the stuff that's so trivial that no one wants to bother implementing it.
20:34:52 <dolio> Referencing Thorsten Altenkirch somehow.
20:34:58 <dolio> I think.
20:36:02 <dmwit> This aligns with my memory of the Boston Hackathon talk.
20:36:28 <shachaf> It aligns with mine also.
20:36:35 <startlebot> so I can't really write a "lookup" function polymorphic over QuadTree (n :: Nat) m, can I
20:36:52 <dmwit> can't imagine why not
20:36:55 <dolio> Anyhow, maybe he implemented it since then, but I don't remember it showing up on the list.
20:37:06 <dolio> And I think he's been busy rewriting a bunch of other stuff.
20:37:17 <dmwit> though that's probably a testament to my terrible imagination rather than your lack of skill
20:37:18 <shachaf> dolio: Is it all one function like Agda?
20:37:32 <dolio> One function is the way to go.
20:37:40 <dolio> I'm going to rewrite vector-algorithms that way.
20:37:49 <shachaf> dmwit: Do you mean skill or lack of skill?
20:38:06 <dolio> I've been using INLINE too much.
20:38:21 <dmwit> I think I said what I meant.
20:38:33 <startlebot> https://gist.github.com/28765fbd8f94bb4b14c8 <- this is a type error
20:38:44 <startlebot> do I need to make a typeclass for lookup up from?
20:38:48 <startlebot> *looking
20:39:18 <startlebot> or can I make it work for any QuadTree (n :: Nat) somehow?
20:40:42 <dmwit> Yes, make a type class, and for bonus points make this data family an associated one.
20:40:48 <dmwit> Or use the GADT approach outlined some time ago.
20:41:05 <shachaf> The GADT is probably nicer.
20:41:32 <dolio> You could take a GADT indexed by the natural, match on that to figure out what the natural is, which will allow you to match on the data family.
20:41:41 <dolio> But, you know, why bother at that point?
20:42:24 <maukd> ain't no such thing as too much overkill
20:43:05 <startlebot> dmwit: what do you mean "make this data family an associated one"?
20:43:23 <startlebot> but yeah, gadts might be a good idea
20:44:40 <dmwit> class Foo a where data Bar a
20:48:30 <startlebot> how would the GADT approach simply "get"?
20:51:45 <dolio> get would work, instead of not working.
20:52:17 <startlebot> oh, weird
20:52:30 <startlebot> why's that?
20:52:50 * hackagebot repa 3.2.2.2 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.2.2.2 (BenLippmeier)
20:52:51 <dolio> Because that's how GADTs are, and not how data families are.
20:52:59 <startlebot> fair enough
20:53:52 <dolio> GADTs are like, "here's constructors for T n, as a whole family; certain constructors work for particular n."
20:54:04 <startlebot> ah
20:54:24 <dolio> Then, when you have a T n, you can match on those constructors, to recover information about n.
20:54:36 <dolio> Data families are like, "here's how you define T n by recursion on n."
20:55:01 <dolio> So, you have to look at n, at which point you know how T was defined for that particular n.
20:55:31 <startlebot> interesting, thanks
21:02:22 <solrize> is there a builtin like   mcheck prop x = if prop then Just x else Nothing      ?
21:02:40 <maukd> :t when
21:03:16 <dmwit> guard
21:03:27 <dmwit> when's a tiny bit different, I think
21:03:46 <solrize> dmwit thanks i think guard is what i want
21:04:04 <dmwit> I rather like ensure p x = guard (p x) >> return x, myself.
21:04:44 <solrize> hmm
21:05:43 <solrize> > let n = 3 in guard (even n) >> return n    :: Maybe Int
21:06:07 <solrize> still a little too much machinery
21:11:52 <fizzbang> is there some reason why (~#) causes a parse error? i'm trying to use ~# as a name in a typeclass
21:15:48 <rwbarton> that is a very good question
21:16:01 <peano_player> does haskell support class-based inheritance?
21:16:22 <mm_freak> fizzbang: GHC?  if yes, which version?
21:16:35 <mm_freak> and what is your ~#?  a type?  a type variable?
21:16:39 <mm_freak> a class?
21:16:53 <dmwit> Haskell doesn't support inheritance at all, class-based or otherwise.
21:17:01 <peano_player> oh :(
21:17:11 <mm_freak> peano_player: haskell does not have java-style OO, if that's what you're asking
21:17:16 <mm_freak> not builtin at least
21:17:49 <fizzbang> mm_freak: ghc 7.4.1, and i'm trying to use (~#) as a function on a typeclass which measures the "similarity" of two inputs
21:18:09 <mm_freak> > let (~#) = (+) in 3 ~# 4
21:18:22 <mm_freak> oh, lambdabot is gone
21:18:30 <rwbarton> ghc 6.10 allows (~#)
21:18:39 <startlebot> mm_freak: 7
21:18:44 <rwbarton> even 7.2
21:18:51 <rwbarton> just not 7.4
21:18:54 <peano_player> what does `return` do?
21:18:56 <mm_freak> weird
21:19:09 <mm_freak> peano_player: "return 3" is the action that results in 3 when executed
21:19:19 <mm_freak> to speak in IO terms at least
21:19:39 <dmwit> unsuccessful troll is unsuccessful
21:20:00 <startlebot> my weird quadtree project is giving me a weird error that I don't understand. anyone care to take a look? https://gist.github.com/28765fbd8f94bb4b14c8
21:20:21 <rwbarton> fizzbang, I'm having difficulty imagining how it isn't a bug
21:20:22 <hpaste> peano_player pasted “return ” at http://hpaste.org/76218
21:20:48 <dmwit> startlebot: Polymorphic recursion requires explicit type signatures.
21:20:52 <peano_player> how come allPlus works just fine over a list?
21:21:03 <startlebot> dmwit: oh. where?
21:21:05 <mm_freak> startlebot: write the type signature for 'get'
21:21:07 <peano_player> without explicit recursion or looping?
21:21:16 <dmwit> startlebot: get is polymorphically recursive
21:21:17 <peano_player> or a map of some sort?
21:21:23 <startlebot> mm_freak: oh, got it
21:21:26 <maukd> peano_player: <- is a loop in []
21:21:31 <peano_player> ah
21:21:41 <fizzbang> rwbarton: it looks like mm_freak was able to do it a few seconds ago
21:21:52 <startlebot> mm_freak: that did it, thanks
21:21:54 <rwbarton> well the IRC channel accepted it :P
21:21:56 <fizzbang> rwbarton: maybe i had a syntax error somewhere else
21:21:59 <maukd> peano_player: more specifically, it hides a concatMap
21:22:03 <dolio> startlebot: Any function that does matching on GADTs should get a type signature.
21:22:11 <startlebot> dolio: good to know, thanks
21:22:21 <mm_freak> peano_player: 'do'-notation for lists is mostly just list comprehension
21:22:22 <rwbarton> fizzbang: no, it's really a parse error
21:22:30 <peano_player> right
21:22:32 <startlebot> fizzbang: I'm not really a bot
21:22:52 <mm_freak> > ((do x <- [1..10]; return (x^2)), [ x^2 | x <- [1..10] ])
21:22:54 <mm_freak> ah
21:22:58 <startlebot> fizzbang: well, not a haskell bot at least
21:23:09 <mm_freak> whatever, you get the point =)
21:23:10 <fizzbang> rwbarton: oh.
21:23:13 <fizzbang> startlebot: oh.
21:23:14 <rwbarton> oh, I see :)
21:23:43 <startlebot> fizzbang: executing haskell by hand is bound to lead to syntax differences!
21:23:45 <mm_freak> fizzbang: i'm guessing that it has to do with GHC misparsing as a refutable pattern
21:23:56 <mm_freak> irrefutable
21:24:14 <rwbarton> if I make any change I can think of it works though
21:24:24 <rwbarton> seems to be very specific to (~#)
21:24:27 <fizzbang> let (~#) = (-) gives a parse error
21:24:33 <fizzbang> so does let (~) = (-)
21:24:41 <rwbarton> you can even just try entering them at top level
21:24:42 <rwbarton> in ghci
21:24:46 <dolio> ~ is not a valid operator name.
21:24:52 <rwbarton> see whether you get a parse error or a not in scope error
21:24:55 <fizzbang> dolio: where can i find this information?
21:24:56 <dolio> So the second one isn't surprising.
21:25:02 <dolio> The Haskell report.
21:25:05 <fizzbang> wee!
21:25:21 <fizzbang> RTFTHR. Got it.
21:25:28 <dolio> ~# should be oka as far as I know, though.
21:25:36 <dolio> Okay, even.
21:25:54 <rwbarton> maybe ~# is a new constructor for equality of unboxed types, or something
21:25:56 <dolio> So that's probably a bug.
21:26:01 <mm_freak> ~~#, ~## and ~#~ are all fine to GHC
21:26:07 <mm_freak> it only complains about ~#
21:26:13 <rwbarton> Prelude> :k (~#)
21:26:13 <rwbarton> (~#) :: AnyK -> AnyK -> #
21:26:17 <mm_freak> looks like a bug to me, too
21:26:25 <mm_freak> huh?
21:26:27 <rwbarton> oh, the reverse
21:26:36 <dolio> Are those extensions on?
21:26:54 <rwbarton> no extensions
21:26:55 <mm_freak> i get the same with no extensions
21:26:59 <dolio> It'd be weird for that to result in a parse error, though.
21:27:14 <rwbarton> yes, that part is still a bug, but at least it makes a little sense now
21:27:28 <mm_freak> what is that (~#) thing then?
21:27:50 <fizzbang> um...
21:27:56 <mm_freak> judging from the "#" suffix it's probably something i shouldn't care about
21:28:03 <mm_freak> as a GHC user
21:28:07 <fizzbang> a similarity function, ~ sounds like similarity and # sounds like magnitude to me...
21:28:15 <dmwit> In the papers, they use ~# for unboxed coercions.
21:28:20 <fizzbang> oh
21:28:29 <fizzbang> what would you use for a measure of similarity?
21:28:35 <mm_freak> how?  that thing is a type constructor
21:29:22 <fizzbang> umm?? i was trying to use it as a function in a typeclass
21:29:33 <mm_freak> what is an AnyK?  something of any kind?
21:29:42 <mm_freak> turning on PolyKinds does not change the kind signature
21:29:53 <dmwit> AnyK is undefined at the kind level, I believe.
21:30:03 <dmwit> Just like Any is undefined at the type level.
21:30:03 <rwbarton> presumably a ~# b is the type of unboxed coercions from a to b, whatever those are
21:30:06 <startlebot> is it a sort?
21:30:18 <startlebot> http://www.haskell.org/pipermail/cvs-ghc/2011-October/066997.html
21:30:23 <startlebot> "documentation to come"
21:30:40 <mm_freak> startlebot: at has to be a kind, since it's on the kind level
21:30:50 <dolio> AnyK is what they have instead of forall a. a -> a -> #.
21:31:07 <mm_freak> then i wonder why PolyKinds doesn't "improve" the kind signature
21:31:10 <startlebot> @src anyK
21:31:12 <maukd> AnyK SkyWalker
21:31:21 <startlebot> startlebot: primtype AnyK
21:31:24 <mm_freak> perhaps it's the AnyK
21:31:27 <fizzbang> unrelated question: can you write a lambda in point-free style?
21:31:28 <mm_freak> "Press AnyK to continue"
21:31:30 <startlebot> startlebot: { JPM Todo }
21:31:35 <startlebot> mm_freak: haha
21:31:47 <startlebot> fizzbang: it depends on the lambda, of course
21:31:51 <mm_freak> fizzbang: that's a contradiction
21:32:01 <mm_freak> if it doesn't have a point, it's not a lambda
21:32:11 <jonkri_> please forgive the ugly code: http://hpaste.org/76219 :) ... if anyone would like to speculate around what causes this code to use 100% cpu, feel free :)
21:32:33 <mm_freak> fizzbang: to answer a related question:  you can perform abstraction elimination by translating your program to SK combinator style
21:32:37 <jonkri_> see the comment in the top
21:33:24 <mm_freak> jonkri_: you're exhausting the range of Double
21:33:28 <rwbarton> jonkri_: I notice that big number is rather close to maxBound :: Double
21:33:41 <fizzbang> mm_freak: what's a point? :D
21:33:43 <jonkri_> oh :)
21:33:51 <dmwit> :t divMod
21:33:55 <mm_freak> fizzbang: the opposite of "point-free" ;)
21:34:04 <dmwit> Anyway, use divMod/quotRem instead.
21:34:13 <mm_freak> fizzbang: think of a function graph:  f x = …, where "x" is your point
21:34:19 <jonkri_> thanks!
21:34:24 <dmwit> fizzbang: A point is a named argument for a function.
21:34:29 <mm_freak> in that sense the lambda's argument is a "point"…  an argument
21:34:41 <fizzbang> okay...
21:34:49 <fizzbang> point == argument
21:34:55 <fizzbang> so point-free just means argument free, got it
21:34:56 <mm_freak> named argument
21:35:04 <mm_freak> the point-free version still takes an argument, but doesn't name it
21:35:07 <fizzbang> oh, so writing a lambda in point free is stupid
21:35:16 <fizzbang> i'd just use composition
21:35:21 <mm_freak> it's not stupid…  it's not possible
21:35:44 <fizzbang> you're so gracious
21:35:58 <rwbarton> You can write an equivalent expression that is point free.
21:36:36 <mm_freak> f x = sin (tan x);  f = sin . tan
21:36:42 <mm_freak> same function, takes one argument
21:38:29 <fizzbang> i guess i'm getting ahead of myself, but thank your for explaining
21:40:05 <mm_freak> fizzbang: just see how (.) is defined
21:40:11 <Clint> jaspervdj: going to conduits or something else?
21:40:15 <mm_freak> (f . g) x = f (g x)
21:40:40 <mm_freak> so (sin . tan) x = sin (tan x)
21:41:11 <Sculptor> binding modifier
21:41:20 <fizzbang> mm_freak: yes, i understand (.) ... i guess i just forgot that point free basically meant composition
21:41:39 <mm_freak> fizzbang: point-free just means:  no variables
21:42:14 <peano_player> you can also do f x = sin $ tan x
21:42:38 <peano_player> :t ($)
21:42:55 <mm_freak> you can also write f x = sin `id` tan x
21:43:09 <peano_player> right
21:43:09 <mm_freak> but both are not point-free, and both are rather ugly
21:43:29 <peano_player> yeah; prefer using . over $ or ()
21:43:49 <mm_freak> parens are not evil
21:44:01 <mm_freak> ($) is evil, but acceptable in some spots
21:44:48 <Sculptor> with haskell, you never know whethere it's a real code or an ascii art
21:44:52 <Sculptor> whether
21:45:52 <mm_freak> [asciiArt| :-) |]
21:46:02 <startlebot> heh
21:46:48 <mm_freak> would be interesting to write a quasiquoter that turns ASCII art in source code into an image =)
21:46:54 <mm_freak> could be useful for user interfaces
21:47:38 <mm_freak> http://projects.haskell.org/diagrams/gallery/Sierpinski.html
21:47:44 <mm_freak> look at the image, then see the code
21:47:53 <mm_freak> with haskell you don't need quasiquotes to have ASCII art code =)
21:55:56 <fizzbang> is there not a way to combine a binary op (which takes two numbers and produces one number) with a section (which takes one number, and produces another number)? I'm failing at things like "(+ 1) . (*)"
21:56:23 <fizzbang> seems like the signature of (.) says it only works on single-argument functions.. (:
21:56:28 <fizzbang> :( **
21:56:33 <Jafet> > ((+1) .: (*)) 1 2
21:56:46 <Jafet> 3
21:56:55 <Jafet> preflex, seen lambdabot
21:56:55 <preflex>  lambdabot was last seen on #haskell 3 hours, 34 minutes and 8 seconds ago, saying:  but then I look at some java code and I'm all happy again
21:57:40 <Jafet> @src (.:)
21:57:47 <Jafet> f .: g = \x y -> f (g x y)
21:57:59 <fizzbang> Jafet: i'm not finding (.:) on hoogle
21:59:15 <fizzbang> i am finding confusing looking sections using (.) on google though...
21:59:34 <Jafet> f .: g = (f.) . g
22:00:09 <mm_freak> fizzbang: f x y = (x * y) + 1;  f x y = (+ 1) ((*) x y);  f x = (+ 1) . (*) x;  f x = (.) (+ 1) ((*) x);  f = (.) (+ 1) . (*)
22:00:28 <peano_player> O.o
22:00:45 <mm_freak> in other words:  don't remove points from an inherently binary function ;)
22:01:05 <mm_freak> f x y = (x * y) + 1
22:01:07 <mm_freak> much easier to read
22:02:11 <Jafet> f = (*) + 1
22:03:47 <fizzbang> mm_freak: point well taken
22:04:14 <fizzbang> why do we call arguments points in haskell?
22:04:29 <mm_freak> fizzbang: you have to see if there is a 'data flow' going on…  if not, it's probably better not to remove points, and if there is, it's usually best to remove only one of multiple points
22:04:46 <Jafet> Because Haskell is really all about abstract topology
22:04:52 <mm_freak> example:  chunksOf n = takeWhile (not . null) . map (take n) . iterate (drop n)
22:05:00 <Jafet> (All that stuff about categories is a lie.)
22:05:09 <mm_freak> that's a "binary" function, where i have removed one point through composition…  well readable
22:05:47 <mm_freak> removing both points would render the function unreadable, and the fully pointy version isn't very readable either
22:06:37 <mm_freak> and the term "point" comes from math
22:06:55 <mm_freak> we also call an 'x' with f x = x a fixed point of f
22:08:01 <peano_player> let fixedPoint f x = if x == f x then x else fixedPoint f (f x)
22:08:01 <startlebot> is there a head :: [a] -> Maybe a somewhere?
22:08:07 <fizzbang> yes, i remember hearing quite a bit about fixed points without ever questioning why we use the word "point" because i thought it just meant something didn't move
22:08:14 <fizzbang> whops
22:08:15 <johnw> startlebot: yes, it's in the "safe" package
22:09:08 <startlebot> johnw: thanks
22:09:23 <mm_freak> startlebot: both versions of 'head' are kinda broken
22:09:35 <mm_freak> head :: List (S n) a -> a
22:10:09 <startling> heh
22:10:55 <Jafet> Yeah, their kinds are broken.
22:11:31 <fizzbang> mm_freak: just understood your chunksOf .... that's awesomeness :)
22:11:58 <startling> what random-number monad should I use?
22:12:05 <mm_freak> startling: none
22:12:10 <startling> mm_freak: :(
22:12:16 <johnw> startling: just pick a different one each time ;)
22:12:20 <startling> haha
22:12:29 <startling> mm_freak: why not?
22:12:37 <mm_freak> startling: i always write it like this:  myFunc :: (forall a. (Random a) => m a) -> m Integer
22:12:55 <mm_freak> for IO just pass 'randomIO'
22:13:03 <mm_freak> for your own monad pass whatever is appropriate
22:13:06 <startling> oh, Random is a class ? didn't realize that.
22:13:25 <mm_freak> Random is the class of types that support random value generation
22:13:40 <startling> uh-huh. is there a monad for creating random whatevers?
22:13:57 <mm_freak> all the packages i have seen for that are ugly
22:13:59 <mm_freak> or broken
22:14:06 <mm_freak> MonadRandom is one of them
22:14:21 <startling> damn. it's such a nice idea, too
22:14:30 <mm_freak> i don't find it that nice
22:15:06 <mm_freak> my experience is that it's a bad idea to bind random number generation to a particular monad
22:15:19 <startling> k.
22:15:38 <mm_freak> myRandomFunc :: (Monad m) => (forall a. (Random a) => m a) -> m (Integer, Double)
22:15:53 <mm_freak> myRandomFunc getRandom = liftA2 (,) getRandom getRandom
22:15:57 <mm_freak> it's that simple
22:16:00 <mm_freak> uhm
22:16:07 <mm_freak> except liftM2 instead of liftA2 =)
22:16:35 <jaspervdj> Clint: conduit is a possibility
22:16:37 <fizzbang> okay, i just wrote my function the way i would in python or js... (\ a b -> ((offset a) - (offset b)) ^ 2)
22:16:43 <mm_freak> in IO you would call it like:  myRandomFunc randomIO
22:16:53 <jaspervdj> I'm waiting for what direction snap will go in, though I think I have a fair idea
22:16:54 <fizzbang> but honestly i though there'd be a nicer way to write it in haskell
22:17:02 <dmwit> fizzbang: Looks good to me, what don't you like?
22:17:11 <dmwit> Only thing I'd say is drop some parentheses. =)
22:17:32 <Jafet> (^2) .: (-) `on` offset
22:17:38 <mm_freak> \a b -> (offset a - offset b)^2
22:18:20 <rwbarton> MonadRandom includes a class MonadRandom which that code is the dictionary-passing translation of. the method is even called getRandom
22:18:42 <mm_freak> rwbarton: MonadRandom is broken
22:18:50 <fizzbang> mm_freak: that makes sense, because my applications have higher precedence than - i guess
22:18:52 <rwbarton> that doesn't even make sense
22:18:53 <Jafet> Shouldn't it be a monad transformer?
22:18:57 <rwbarton> it's a class
22:19:25 <rwbarton> (the MonadRandom package also includes a monad transformer)
22:19:26 <mm_freak> rwbarton: it's broken in another sense:  it insists that the random number generating monad is either Rand(T) or IO
22:19:30 <fizzbang> Jafet: yours is going to take me a bit
22:19:31 <rwbarton> what?
22:19:42 <mm_freak> rwbarton: try to define a MonadRandom instance for your own state monad
22:19:51 <Jafet> fizzbang: don't write code you can't read.
22:20:02 <rwbarton> is this something to do with getRandoms?
22:20:30 <fizzbang> Jafet: i'm trying to learn the conventions for how haskell is written, and thereby find useful things in prelude to learn about
22:20:42 <mm_freak> rwbarton: no, it's not broken by design or aesthetics…  it's just unusable in a custom monad transformer stack, unless you add Rand(T) or IO
22:20:59 <rwbarton> instance MonadRandom (State s) where getRandom = state random
22:21:00 <mm_freak> unless you want to wrap your transformer stack up in a newtype
22:21:01 <fizzbang> Jafet: unless your example is an antipattern :P
22:21:07 <mm_freak> rwbarton: overlapping instance
22:21:15 <rwbarton> oh
22:21:19 <rwbarton> well I make a newtype of State then
22:21:32 <rwbarton> also I forgot the RandomGen constraint
22:21:46 <mm_freak> i don't see the advantage of depending on that library
22:22:02 <mm_freak> the explicit version is quite convenient and flexible
22:22:06 <rwbarton> why do I even bother
22:22:26 <peano_player> how much has Haskell been inspired by APL?
22:22:40 <Jafet> Not enough!
22:23:50 <fizzbang> Jafet: ooooh.. i like `on` .. thanks for showing me that
22:23:56 <mm_freak> anyway, i think transformer stacks are out…  free monads rule the world
22:25:41 <carter> hello everyone :)
22:25:50 <mm_freak> hi there
22:25:55 <maukd> hello, dr. nick
22:25:56 <peano_player> hello
22:27:49 <startling> is there a nice sparse two-dimensional array somewhere?
22:27:56 <maukd> Data.Map
22:28:08 <startling> oh, hum.
22:28:23 <maukd> Data.Map (Int, Int) T
22:28:30 <startling> right. neat idea
22:28:46 <startling> it'd be cool if there were a wrapper for it, given a default value
22:29:35 <startling> it could be a functor, too, given Eq
22:29:40 <Jafet> Sparse arrays also normally allow accessing rows and columns
22:30:14 <startling> Jafet: yeah, that's the annoying thing about Data.Array.whatevers, too
22:30:46 <carter> startling: i've some array libs work i'm slowly chewing on that will be made available at some time™
22:31:13 <startling> carter: good to know
22:32:09 <carter> though you may want to play wiht DPH as another point in the sparse array engineering space
22:32:31 <startling> DPH?
22:32:52 <carter> data parallel haskell
22:33:01 <startling> oh
22:33:30 <carter> if you're on 7.4, the hackage version is worth trying out
22:33:39 <carter> i think the next dph hackage update won't be till 7.8
22:33:53 <carter> (or so i'm told)
22:33:59 <carter> whats the use case you're wanting to do?
22:34:10 <evincar> So I made a probably useless thing. https://github.com/evincarofautumn/extra
22:34:24 <evincar> On the off chance someone cares.
22:34:33 <startling> carter: I'm writing a game. a lot of levels in this game will be all one kind of tile, until the player interacts with it
22:35:05 <carter> hrm... you may just want to have a more topological data structure then?
22:35:17 <startling> like what?
22:35:20 <carter> well
22:35:26 <carter> say its a digging game
22:35:35 <startling> it is, kind of
22:35:41 <carter> you only need to represent the current boundary
22:35:49 <carter> everything in the interior is "open"
22:35:53 <carter> eveything outside is "rock"
22:36:03 <carter> idk
22:36:08 <carter> just throwing out ideas :)
22:36:10 <startling> haha, alright
22:36:23 <carter> but if you can write down properties like that
22:36:42 <carter> probably would be a nice basis for a quickcheck suite!
22:36:57 <carter> and the less you need to test the game by playing it
22:37:01 <carter> the easier it'd be to make changes, right?
22:37:10 <carter> unless its testing for funn
22:37:15 <carter> funness
22:37:32 <carter> whatever that word is for stateful programs people enjoy using
22:37:47 <carter> that have complicated IO monad stuff
22:37:49 <carter> fun?
22:38:20 <carter> have fun with the game dev!
22:38:29 <carter> which libs are you considering for the graphics?
22:38:50 <hpaste> “Ertugrul Söylemez” pasted “Generating DSA primes” at http://hpaste.org/76220
22:40:29 <startling> carter: thanks!
22:40:37 <carter> np
22:40:40 <startling> carter: this is a server backend; the frontend is going to be web
22:40:43 <carter> ahhh
22:40:47 <carter> so Fay? :)
22:41:06 <carter> I wonder if anyone's done Fay bindings for webgl?
22:41:08 <startling> maybe! haven't quite gotten there yet
22:41:10 <carter> mwhahahaha
22:41:20 <carter> webgl is apparently a bit tricky to use
22:41:23 <startling> carter: from what I understand, Fay can call javascript trivially
22:41:27 <carter> ye
22:41:28 <carter> s
22:41:33 <carter> but apparently webgl is a pain :)
22:41:48 <carter> by the power of haskell / fay, abstraction?!
22:43:11 <johnw> By The Power of Hayskull!
22:43:17 <carter> https://github.com/cscheid/facet is a DSEL for webgl in js
22:43:22 <carter> johnw yup
22:43:33 <carter> maybe a nicer layer via fay could be done
22:43:39 <carter> with facet as a reference starting point?
22:45:05 <carter> https://github.com/cscheid/facet/tree/master/src
22:45:17 <carter> the author, carlos, is an awesome dude at at&t labs
22:46:25 <carter> ok, looking at the source, its got a *lot* of by hand inlining because js probably doesnt
22:49:44 <carter> ok
22:49:58 <carter> 'night all
22:50:02 <carter> :p
23:12:48 <JoeyA> Is there a convenience combinator to retry if an STM action returns False?
23:13:06 <JoeyA> 'check' is pretty close, but: check b = if b then return undefined else retry
23:13:14 <JoeyA> Why does it return undefined?
23:14:21 <lewurm> 8
23:14:53 <JoeyA> Ah: http://stackoverflow.com/questions/8364903/haskell-stm-check-function-returning-undefined
23:15:01 <lewurm> oops, sorry :-)  wrong keys
23:17:18 <shachaf> @ty (>>= guard)
23:17:23 <shachaf> Bah.
23:17:27 <shachaf> JoeyA: Anyway, that might do it.
23:18:21 <JoeyA> Thanks
23:18:28 <shachaf> Wait, check isn't the right type at all.
23:23:48 <hpaste> “Ertugrul Söylemez” annotated “Generating DSA primes” with “DSA primes + generator” at http://hpaste.org/76220#a76221
23:26:39 <johnw> did the options for profiling executables change with cabal-
23:26:42 <johnw> install 1.16?
23:26:53 <johnw> I can get my libs to build with prof, but not my executables
23:32:57 * hackagebot markdown-unlit 0.2.0 - Literate Haskell support for GitHub's Markdown flavor  http://hackage.haskell.org/package/markdown-unlit-0.2.0 (SimonHengel)
23:33:47 <johnw> this is so strange.  I have cabal configure --enable-executable-profiling, and I can see my library compiling profiled versions, but cabal build -v2 shows me that -prof is nowhere being passed
23:51:38 <startling> preflex: seen dylukes
23:51:39 <preflex>  dylukes was last seen on #haskell-blah 1 day, 4 hours, 26 minutes and 23 seconds ago, saying: what was?
23:55:28 <Attic> Is there any version manager for modules? Or can I only use Cabal?
23:56:21 <startling> Attic: Cabal is sort of a version manager
23:56:37 <johnw> Attic: you can use Nix
23:56:42 <johnw> that is a version manager for package, including Haskell
23:56:48 <johnw> packages
23:57:44 <Attic> How can I specify which version I want in a program with cabal then? Or do I specify it in Ghc?
23:58:36 <johnw> you specify it in your .cabal file
23:58:42 <johnw> like, foo.cabal
23:59:03 <Attic> In the root of your program you mean?
23:59:07 <startling> yes
23:59:22 <Attic> Ah ok, I'll try that out, thanks
