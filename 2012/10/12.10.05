00:06:36 <DrSyzygy> shapr: It turns out that homotopy type theory is not, actually, the kind of thing I do.
00:07:11 <DrSyzygy> shapr: I had a chat with Voevodsky a few years ago, and the conclusion is while awesome, HTT is not what I was under an impression it would be, and it won't serve my own personal petty goals. :-)
00:16:25 <mietek> cabal still doesn't know binaries like happy can be dependencies...
00:17:21 <dmwit> That is not an accurate description.
00:17:45 <mietek> Oh?
00:17:50 <dmwit> The truth is that cabal still doesn't have a mapping from ExecutableName to Maybe PackageName, which is much more reasonable.
00:21:12 <Ralith> wouldn't it be more like [PackageName]?
00:21:40 * dmwit nods agreeably
00:55:48 <hpaste> sopvop pasted “Can undecidable instances be avoided here?” at http://hpaste.org/75802
00:56:05 <sopvop> Are undecidable instances really scary?
00:58:46 <Saizan> the worst that can happen is make ghc loop when resolving instances
00:59:05 <sopvop> Never happened to me yet
01:00:03 <coldpizza72i> Can someone help me with this error http://ideone.com/r0GAe
01:00:52 <sopvop> maybe (show $ str i j) or (show . str $ i j)?
01:01:16 <coldpizza72i> what does that mean
01:01:24 <coldpizza72i> the $
01:01:29 <sopvop> show has one argument
01:01:38 <sopvop> show $ foo bar = show (foo bar)
01:01:50 <dmwit> ?src ($)
01:01:51 <lambdabot> f $ x = f x
01:02:03 <coldpizza72i> when i finish my chess game ill give it a try
01:02:07 <sipa> a $ b $ c d    ===     a (b (c d()
01:02:20 <hiptobecubic> > ($) (+1) 1
01:02:22 <lambdabot>   2
01:02:36 <Saizan> str :: Rope
01:02:41 <Saizan> it doesn't take any argument
01:02:59 <sipa> ?
01:03:00 <hiptobecubic> The only benefit to ($) as prefix? I wouldn't think so.
01:03:15 <dmwit> coldpizza72i: At a guess, you want something like show str ++ show i ++ show j
01:03:28 <dmwit> or concatMap show [str, i, j] if you prefer =)
01:04:26 <dmwit> hiptobecubic: Prefix ($) can be useful as an argument to higher-order functions.
01:04:41 <sopvop> dmwit: i, j :: Int; str :: Rope
01:04:44 <Saizan> or just "show (SubRope str i j) = take (fromIntegral j) (drop (fromIntegral i) (show str))"
01:04:50 <hiptobecubic> dmwit, ah yeah. ok sure
01:05:02 <sopvop> concat $ intercalate " "  [show str, show i, show j]
01:05:10 <hiptobecubic> zipWith ($) fs args   i guess
01:05:14 <startling> > [(+ 1), (+ 3), (* 12)] <$> ($ 13)
01:05:15 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
01:05:24 <startling> err
01:05:38 <startling> > ($ 13) <$> [(+ 1), (+ 3), (* 12)]
01:05:39 <lambdabot>   [14,16,156]
01:06:09 <sopvop> startling: And everyone else reading your code will hate you :)
01:06:14 <hiptobecubic> startling, indeed
01:06:17 <startling> haha
01:06:25 <startling> but ($ whatever) is certainly useful
01:06:32 <sopvop> Indeed
01:06:59 <hiptobecubic> @src zipWith3
01:06:59 <lambdabot> Source not found. You type like i drive.
01:07:09 <hiptobecubic> Guess not
01:10:27 <LambdaDusk> anyone has a tutorial on how to write a indention-based parser in attoparsec? or parsec, if it's impossible
01:11:33 <merijn> The Kleisl implementation of >>> is just >=>, right?
01:11:42 <startling> LambdaDusk: one thing that helped me was tokenizing to get INDENT and DEDENT tokens
01:12:12 <LambdaDusk> startling: Indent would be just '\t' right?
01:12:22 <startling> LambdaDusk: nah
01:12:35 <startling> \t\t\t can be INDENT too, depending on context
01:12:39 <charliesome> i'm trying to unpack a lazy bytestring into a [Word8], and I'm getting a type error saying that it can't match the expected type BL.ByteString (BL is my Data.ByteString.Lazy) with actual type Data.ByteString.Internal.ByteString
01:12:44 <charliesome> if it matters i'm using Get
01:13:00 <dmwit> Haskell's indentation rules are context-sensitive.
01:13:01 <startling> LambdaDusk: you almost convert it to a curly-brace style language
01:13:12 <startling> in fact, haskell does!
01:13:53 <merijn> dmwit, startling: I'm thinking his question is more along the lines of "how do I implement the indentation tracking for an indentation-based parser"
01:13:55 <LambdaDusk> I am aware the resulting language is context-sensitive... So how do I parse for indent or oudent?
01:14:30 <dmwit> You keep a context around and consult it when tokenizing the initial whitespace on each line.
01:14:30 <LambdaDusk> Yes, I am a little aware of the theory but I need guidance in the actual implementation =/
01:15:02 <dmwit> You emit outdent tokens when the initial whitespace is smaller than your context says it ought to be, and indent tokens when it's larger.
01:16:00 <dmwit> merijn: My point is that the question "indent would just be '\t' right?" is easily answered as "no" because the language {"\t"} is not context-sensitive.
01:16:19 <dmwit> But this answer is only easy if you already know that the indentation language is context-sensitive.
01:16:34 <startling> ^ right. you keep a running count of how deeply indented you are at the moment
01:16:46 <dmwit> I guess I'm being a little lax here; I should have said "not context-free" everywhere I actually said "context-sensitive".
01:16:58 <startling> context-expensive
01:17:00 <LambdaDusk> So I would need parsec, for its ParsecT transformer monad
01:17:34 <startling> LambdaDusk: sure, and you could keep your context in State or whatever
01:17:48 <dmwit> The Parsec monad already allows user state.
01:17:56 <startling> does it? whoops
01:18:14 <dmwit> (...which is actually a bit of a wart, I think.)
01:18:24 <ClaudiusMaximus> @type Parsec
01:18:25 <lambdabot> Not in scope: data constructor `Parsec'
01:18:29 <startling> yeah, that seems odd
01:18:34 <ClaudiusMaximus> @kind Parsec
01:18:36 <lambdabot> Not in scope: type constructor or class `Parsec'
01:18:52 <LambdaDusk> @kind Text.Parsec.Parsec
01:18:53 <lambdabot> Couldn't find qualified module.
01:18:57 <ClaudiusMaximus> something like Foo s u m a
01:19:06 <ClaudiusMaximus> where the u is user state or something
01:19:07 <LambdaDusk> @hoogle ParsecT
01:19:07 <lambdabot> Text.Parsec.Prim data ParsecT s u m a
01:19:07 <lambdabot> package ParsecTools
01:19:07 <lambdabot> Text.Parsec.Prim runParsecT :: Monad m => ParsecT s u m a -> State s u -> m (Consumed (m (Reply s u a)))
01:19:13 <LambdaDusk> @hoogle Parsec
01:19:13 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
01:19:13 <lambdabot> package parsec
01:19:13 <lambdabot> package parsec-extra
01:19:27 <charliesome> alright so I solved my bytestring issue before. Now I'm wondering if there's a nicer way to parse binary data in haskell than this: https://gist.github.com/3838712
01:20:09 <dmwit> That looks pretty clean to me.
01:20:16 <dmwit> What could you want to be nicer?
01:21:01 <charliesome> dmwit: i don't like line 41 and I'm thinking there might be a way to avoid specifying the struct twice
01:21:22 <dmwit> twice?
01:21:39 <dmwit> You could consider:
01:21:44 <charliesome> once in lines 8 - 22, and then effectively again from lines 26 to 40
01:22:07 <charliesome> so i'm wondering if there's some fancy introspection thing that i can use
01:22:12 <dmwit> parseBPB = runGet $ MakeBPB <$> (skip . >> oemBytes >>= blah blah blah) <*> getWord16le <*> getWord8 <*> ...
01:22:34 <LambdaDusk> that'd be less clean to me
01:22:49 <prophile> anyone with any knowledge of algebraic structures aware of a variation of a ring which has + as a commutative monoid rather than an abelian group?
01:23:58 <dmwit> charliesome: I don't see that as specifying the structure twice. I see it as specifying the structure once and how to parse it once, and can't imagine doing much better.
01:24:15 <dmwit> ...especially considering this "skip 3" and "getBytes 5" stuff.
01:24:24 <charliesome> yeah
01:24:25 <charliesome> i suppose
01:24:29 <ClaudiusMaximus> magic preprocessor that would be more general and complex than a oneoff thingy
01:24:59 <sopvop> why the hell there is no voidM? adding (Functor m, Monad m) => instead of only (Monad m) is not nice. yet another function for Foo.Utils, or >> return ()  :(
01:25:16 <charliesome> if this were C i suppose i could have char ignored[3]; char oem[5]; and then the rest of the members in a packed struct
01:25:21 <charliesome> and just copy into that
01:25:50 <LambdaDusk> Parsec isn't a MonadState, is it?
01:25:56 <dmwit> ...and then your code would break when you compiled on an architecture with different layout.
01:26:01 <dmwit> LambdaDusk: Unfortunately, no.
01:26:12 <dmwit> LambdaDusk: But it has all the things you would need to write a MonadState yourself.
01:26:21 <dmwit> ...MonadState instance
01:27:07 <LambdaDusk> dmwit: And Parsec isn't made a MonadState instance by default because...?
01:27:56 <dmwit> hysterical raisins
01:28:06 <LambdaDusk> makes sense
01:28:26 <coldpizza72i> Can someone tell me if the believe i should make a module called Linear from what this description says http://www.cs.rit.edu/usr/local/pub/jeh/courses/FP/Labs/CedarRope/
01:30:43 <dmwit> coldpizza72i: The instructions seem quite clear on that point: you are to create a type class called Linear.
01:31:01 <coldpizza72i> dmwit: using the class keyword?
01:31:11 <dmwit> That's what the class keyword is for, yes.
01:33:04 <merijn> The implementation of >>> for Kleisli is just >=> for the relevant monad, right?
01:33:21 <opqdonut> yeah
01:33:32 <opqdonut> modulo wrapping/unwrapping
01:33:43 <maurer> Hey, am I correct in my understanding that template-haskell cannot generate arrow notation code?
01:34:10 <merijn> And the only real reason we need the Kleisli newtype is because (lacking type level lambda/composition) it is impossible to write a type constructor that takes a/b and returns "a -> m b", right?
01:34:18 <zomg> maurer: "arrow notation"?
01:34:26 <opqdonut> merijn: well, yeah
01:34:29 <maurer> zomg: http://www.haskell.org/arrows/syntax.html
01:34:43 <opqdonut> one might argue that the newtype is more explicit
01:34:43 <zomg> Oh nevermind I'm being daft :P
01:34:44 <hiptobecubic> Someone was asking yesterday about Tardis and whether or not anyone had actually used it for anything other than demonstrating how Tardis works. Did anyone have something?
01:34:54 <coldpizza72i> dmwit: am i doing something wrong here?
01:35:08 <merijn> Which means that defining "instance Monad m => Arrow (\a b -> a -> m b)" (using my fictional type lambda syntax :p) is impossible
01:35:14 <coldpizza72i> http://ideone.com/1Mep3
01:35:16 * merijn smartness++
01:36:18 <dmwit> coldpizza72i: Given the fact that there are compiler errors, the answer is obviously yes. =)
01:36:24 * dmwit awaits a better question
01:36:30 <merijn> coldpizza72i: You are defining dissect and sizeOf as top level functions...
01:36:48 <merijn> coldpizza72i: Compare your Show instance to your complete lack of Linear instance
01:40:24 <dmwit> :t mconcat
01:40:26 <lambdabot> forall a. (Monoid a) => [a] -> a
01:41:28 <coldpizza72i> merijn: so i need to implement an instance Show Linear where ...?
01:41:42 * hackagebot blaze-html-truncate 0.2.0.0 - A truncator for blaze-html  http://hackage.haskell.org/package/blaze-html-truncate-0.2.0.0 (MarcelRuegenberg)
01:41:47 <sopvop> Why compiler does not complain about show in Linear?
01:42:39 <sopvop> coldpizza72i: you need instance Linear Rope where dissect..; sizeOf..
01:43:04 <sopvop> Also, delete show from Linear class
01:43:23 <sopvop> Or delete linear class
01:43:41 <dmwit> The assignment requires this class.
01:43:47 <sopvop> Oh
01:43:48 <dmwit> (It's a weird requirement, I agree.)
01:44:08 <sopvop> Is it this bos school thing?
01:44:19 <coldpizza72i> bos?
01:44:31 <dmwit> I doubt very much bos would make such a weird assignment. =)
01:44:55 <sopvop> bos = Bryan O'Sullivan
01:45:04 <merijn> coldpizza72i: Yes, and then have your function definitions inside
01:45:58 <garrensmith> morning
01:46:42 * hackagebot graph-visit 0.1 - Graph walk abstraction  http://hackage.haskell.org/package/graph-visit-0.1 (AtzeDijkstra)
01:46:52 <hpaste> sopvop pasted “for coldpizza72i” at http://hpaste.org/75804
01:48:04 <coldpizza72i> do i just cut my definitions on the bottom and put them in there?
01:48:09 <coldpizza72i> paste them in*
01:48:23 * sopvop back to `making shit done`. Lazy and with style.
01:48:27 <sopvop> Sort of
01:48:36 <coldpizza72i> what do you mean
01:49:32 <sopvop> coldpizza72i: http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101 try reading this.
01:50:57 <sopvop> Linear is a type class, sizeOf, dissect, i_th are the class functions. You implement class instance for Rope with 'instance Linear Rope where' and write functions in the body of instance.
01:51:58 <lightquake> figures. i finally get started programming in haskell in sublime text and the indentation support is awful
01:55:02 <merijn> lightquake: Good excuse to attempt to learn vim or emacs? ;)
01:55:18 <coldpizza72i> sopvop: how does this look? http://ideone.com/NE8CR Im not getting any errors and it appears to be working :)
01:55:51 <merijn> lightquake: On a more serious note, does Sublime not support auto indenting new lines as much as the previous ones? That's about the only autoindent function I usually really end up relying on in Haskell
01:56:44 <sopvop> coldpizza72i: Looks right
01:58:19 <lightquake> merijn: i already know emacs, i'm considering switching away
01:59:20 <lightquake> also, it does
01:59:59 <lightquake> but when i want to do something like a multi-line record declaration, i have to manually align everything
02:00:49 <maurer> Is there a good way to use arrow notation with template haskell, or should I just give up and generate it the awkward way?
02:02:29 <sopvop> maurer: according to reddit  TH is bad, and you should feel bad.
02:03:17 <lightquake> also, the syntax highlighting is pretty subpar
02:03:25 <maurer> sopvop: How else would you suggest generating haskell code from asm that has been lifted to an intermediate language?
02:03:40 <maurer> Pretty sure TH is the right choice here
02:04:16 <merijn> maurer: He was just being flippant\
02:05:14 <t7> crypto random will only give me a random number that has a max bound of x/8 bits, but i need a random number that has a max bound on n
02:05:57 <merijn> Hmm, I know a trailing underscore indicates an ignored result, but what do I when I have a function producing two results and I want wrappers for each scenario where one is dropped
02:06:13 <merijn> But then I don't know how to name those modified versions >.>
02:08:37 <Ralith> t7: so scale it?
02:09:00 <dmwit> merijn: invent a convention
02:09:01 * merijn slaps Ralith
02:09:09 <dmwit> for example, vv, v_, _v, and __ would work pretty well
02:09:09 <Ralith> ow :(
02:09:21 <t7> i might just use normal random
02:09:23 <merijn> You don't "just scale" or otherwise "just x" random numbers for crypto use
02:09:42 <merijn> Unless you have a phd in crypto, in which case you probably still don't >.>
02:10:36 <dmwit> "Man, I don't understand crypto. Instead of making an egregious mistake, I just won't encrypt anything."
02:10:51 <Ralith> merijn: okay, if you have a random number with the appropriate characteristics and bound X, and you want one with the same characteristics but bound Y for Y < X, what does scaling it down break?
02:11:41 <dmwit> Ralith: Insufficient data for meaningful answer.
02:11:45 <Ralith> I agree that "don't touch crypto math without a doctorate" is good advice but this seems perhaps a bit extreme.
02:12:02 <Ralith> dmwit: invent a few assignments which give rise to educational answers.
02:12:29 <dmwit> I choose an appropriate characteristic which is not scale-invariant. The characteristic breaks.
02:12:54 <Ralith> let me rephrase my question
02:13:04 <merijn> Ralith: You might accidentally decrease the entropy in your random number
02:13:08 <Ralith> ...actually
02:13:16 <Ralith> the real correct response to t7 here is
02:13:19 <Ralith> "what do you want it for"
02:13:25 <merijn> Thus weakening a key, for example
02:13:26 <dmwit> Now you're getting the picture.
02:13:29 <Ralith> :D
02:14:09 <Ralith> merijn: I presumed t7 would know better than to be messing about at that level.
02:14:35 <Ralith> which I guess is a dangerous assumption.
02:14:40 * Ralith appropriately chastised
02:14:56 <frerich> I think any advice along the lines of "don't touch x without y" tends to ignore the benefits of failure. :)
02:15:01 <t7> im writing crypto lelelel
02:15:26 <t7> i dont trust the haskell APIs
02:15:34 <opqdonut> :D
02:16:31 <Ralith> frerich: failure in cryptography doesn't tend to be beneficial.
02:16:38 <dmwit> frerich: Yeah, that was sort of what I was trying to get at (but failing) with my "I won't encrypt anything" joke. =)
02:16:42 <Ralith> it tends to go unnoticed until it becomes a serious mistake.
02:17:14 <Ralith> (presuming your work is ever distributed)
02:17:53 <t7> im only writing payment backend stuff dont worry
02:33:19 <merijn> bah
02:33:30 <merijn> GHC is refusing to compile perfectly sensible code :(
02:35:22 <t7> 10 : x = rand (0, 1)    20 : if x == 0 then GOTO 10    <- would you say that is guaranteed to terminate? (if it was a true random source like Geiger counter)
02:36:31 <t7> also i wish there was a way to set breakpoints in the IO monad so you could halt and mess with stuff in scope at a specific point
02:37:44 <osfameron> a random stream could randomly return an infinite series of 1s
02:37:54 <osfameron> empirically, it won't
02:37:57 <hpaste> merijn pasted “GHC not cooperating” at http://hpaste.org/75805
02:38:11 <merijn> I have no clue why this code won't compile :(
02:39:48 <merijn> It's complaining about missing monoid instance, but I don't see where/why it'd need one?
02:40:47 <merijn> Or is () not a monoid instance?
02:41:21 <Jafet> All computations terminate on the heat death of the universe.
02:41:38 <Jafet> @instances Monoid
02:41:39 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:41:43 <augur> Jafet: heat death isnt a point in time but an idea
02:41:45 * hackagebot graph-visit 0.1.0.1 - Graph walk abstraction  http://hackage.haskell.org/package/graph-visit-0.1.0.1 (AtzeDijkstra)
02:41:47 <quicksilver> merijn: it needs to know which Writer you're using.
02:41:49 <arcatan> t7: you *can* set breakpoints in the IO monad
02:41:59 <merijn> quicksilver: What needs to know which writer I'm using?
02:42:21 <Jafet> augur: pfft, they're asymptotically equivalent
02:42:23 <quicksilver> merijn: I don't know. What's the type of 'readStream'
02:42:39 <augur> Jafet: asymptotically you get weird behavior
02:42:43 <quicksilver> merijn: (it's not really complaining about a *missing* Monoid instance, it's complain about an unspecified type)
02:42:59 <merijn> quicksilver: "MonadIO m => Stream -> (forall r . r -> m a) -> m a"
02:43:08 <augur> if you think of the heat death as the limit as time goes to infinity, then computation terminates, but only because it goes on forever!
02:43:13 <merijn> quicksilver: The code (minus stuff I'm coding now) is here: https://github.com/merijn/SNet2.0/blob/master/SNet/Stream.hs
02:43:19 <Jafet> I assume a Boltzmann-type law would limit the amount of computation in the universe
02:43:30 <augur> probably
02:44:02 <arcatan> t7: though i don't think you can mess with the scope
02:44:38 <Jafet> So asymptotically, only terminating computations are possible. (The limit is a finite computation that doesn't terminate!)
02:44:59 <merijn> And RWST should be MonadIO provided that the writer is a Monoid. My Writer is just () so I don't see what is missing?
02:46:20 <merijn> Maybe I should just define it myself using ReaderT and StateT instead of RWST and hope that avoids the whining about Monoid since only WriterT needs monoid anyway...
02:47:15 <quicksilver> merijn: I don't understand, no
02:47:26 <mikeplus64> where is the (a -> b) instance for Monoid?
02:47:28 <quicksilver> don't see how a Monoid constraint can arise from a use of readStream
02:47:29 <maurer> So, hoogle doesn't come up with anything, but does anyone know how I could construct something of the form
02:47:32 <maurer> Arrow a => (i -> a () o) -> a i o
02:47:35 <maurer> or if that even makes sense?
02:47:41 <merijn> quicksilver: Good, at least I'm not crazy then
02:47:56 <maurer> (my goal here is that since I am generating Arrows with TH, which doesn't have arrow syntax, I'm trying to figure out the most convenient way to write them)
02:48:23 <merijn> I'll make a snapshot of my src dir and maybe try to derive a minimal example to bug the GHC people with
02:53:42 <absence> if i use an expression in a function that is foreign exported, the gc seems to keep that expression alive even if the function is never used, causing a space leak. by simply commenting out the foreign export line (leaving the actual function) the space leak disappears. unfortunately i will need to call this function from c later, so is there a way to avoid this problem?
02:54:16 <absence> i know the function will be called from c only once and that the gc doesn't have to keep the expression alive, but obviously ghc doesn't know that
02:54:55 <absence> so i guess it has to be forced via some unsafe stuff somehow
02:55:44 <quicksilver> well I can think of some tricks, absence
02:55:53 <quicksilver> is the foreign function in IO anyway?
02:56:02 <absence> quicksilver: yes
02:56:10 <Jafet> I would guess the usual indirection x ==> (x ())
02:56:12 <quicksilver> stick the expression in an MVar
02:56:17 <quicksilver> and empty after you use it
02:56:46 * hackagebot sugarhaskell 0.1 - Library-based syntactic extensibility for Haskell  http://hackage.haskell.org/package/sugarhaskell-0.1 (SebastianErdweg)
02:56:51 <absence> quicksilver: it's the entry point called from c (haskell is used in a dll)
02:57:02 <absence> quicksilver: merely refering to the expression keeps it alive it seems
02:57:21 <quicksilver> then try jafet's approach
02:57:37 <quicksilver> hide the expression inside a function which "calculates it" afresh each time
02:57:45 <quicksilver> f () = <...expr...>
02:57:59 <quicksilver> (add free variables as parameters to f if there are any)
02:58:11 <absence> let me try that..
03:00:11 <absence> quicksilver: still doesn't work. i did "getSynth () = synthW" and replaced synthW with "(getSynth ())". did i misunderstand?
03:00:54 <Jafet> Hmm. {-# NOINLINE getSynth #-}
03:01:58 <absence> Jafet: still leaks :/
03:02:06 <ClaudiusMaximus> how about manually forcing GC?
03:02:12 <ClaudiusMaximus> maybe that'll trick it
03:02:16 * ClaudiusMaximus guesses wildly
03:02:52 <quicksilver> I don't think so, ClaudiusMaximus
03:03:01 <quicksilver> as far as haskell knows, that function could be called again
03:03:08 <ClaudiusMaximus> true, i suppose
03:03:09 <quicksilver> so it considers the data still 'reachable'
03:03:10 <Jafet> http://tvtropes.org/pmwiki/pmwiki.php/Main/WildMassGuessing
03:03:17 <quicksilver> foreign exports are always reachable.
03:03:28 <absence> is there a way to override that?
03:03:56 <quicksilver> not that I know of.
03:04:23 <absence> hm, that's a bit of a showstopper :/
03:04:45 <quicksilver> how about getSynth :: () -> IO Synth; getSynth () = return synthW
03:04:55 <quicksilver> IO functions are harder to inline or lambda lift.
03:05:00 <GnomeStoleMyBike> hi all
03:05:17 <quicksilver> absence: also, try moving 'getSynth' into a different module from your main entry point.
03:05:35 <quicksilver> s/lambda lift/lambda float/ I think I meant to say.
03:07:13 <plat0> maurer: That's one half of "What is a monad, really?" http://web.jaguarpaw.co.uk/~tom/blog/2012/09/02/what-is-a-monad-really.html
03:08:10 <absence> quicksilver: io in same module didn't work, even with noinline. trying different module now
03:20:55 <absence> quicksilver: seems ghc is pretty good at propagating reachability recursively - doesn't work in a separate module with io either
03:26:01 <quicksilver> absence: I think you will need a GHC implementor to help :( JaffaCake doesnt' appear to be around, you could send an email to glasgow-haskell-users
03:26:30 * JaffaCake begs to differ
03:26:36 <absence> :D
03:26:58 <absence> JaffaCake: got a minute?
03:27:10 <JaffaCake> what seems to be the problem?
03:27:40 <absence> if i use an expression in a function that is foreign exported, the gc seems to keep that expression alive even if the function is never used, causing a space leak. by simply commenting out the foreign export line (leaving the actual function) the space leak disappears. unfortunately i will need to call this function from c later, so is there a way to avoid this problem?
03:28:26 <JaffaCake> hmm
03:28:33 <absence> after suggestions from quicksilver and Jafet i've tried making an io action that returns the expression instead of using it directly
03:28:40 <absence> but ghc is too clever :|
03:28:47 <JaffaCake> the GC retains the expression because you might need it again... what do you want to happen?
03:29:20 <absence> JaffaCake: i want to force the gc to collect it, because i know it won't be needed again
03:29:38 <absence> JaffaCake: that c function is an entry point (haskell is in a dll) and will only be called once
03:30:04 <absence> JaffaCake: of course, ghc can't know that and considers the expression reachable in case the foreign exported function is called agai
03:30:07 <absence> n
03:30:39 <JaffaCake> I think you might be able to call revertCAFs() in the RTS, which will discard all CAFs
03:31:37 <JaffaCake> hmm, except that won't work
03:33:04 <statusfailed> Does anyone drink Rose Hip tea? I have a bet on
03:33:32 <absence> statusfailed: as in ever, or regularly? :P
03:33:39 <statusfailed> regularly :P
03:33:57 <absence> nm then ;)
03:34:17 <JaffaCake> absence: I think the answer is that we could in theory provide a way to tell the GC to discard that CAF, but there isn't currently a way to do it
03:34:33 <statusfailed> absence: on my way to winning this bet :P
03:34:34 <absence> JaffaCake: would it be possible to "construct" the haskell expression using the c api and pass it to the entry point?
03:35:17 <JaffaCake> I'm not sure - I'd need to see the code
03:36:17 <absence> JaffaCake: come to think of it, that won't work. the expression is basically The Program (frp network)
03:36:52 <absence> JaffaCake: and of course, expressing it in haskell and using the c runtime to obtain it requires a foreign export and makes it into a caf :P
03:37:23 <hpaste> dvf pasted “Weird validate error” at http://hpaste.org/75810
03:37:44 <dvf> GHC hackers: running sh validate on a fresh pull from github/ghc/ghc on Windows, I get errors such as just posted.
03:38:15 <dvf> Known issue?
03:38:19 <absence> JaffaCake: so the unfortunate conclusion is that currently ghc can't do this?
03:40:01 <t7> whats the standard way to read [Word8] or ByteString (as a base 256 Int) to an Integer ?
03:40:11 <t7> do i have to do it myself?
03:40:39 <JaffaCake> absence: well the annoying this is that it can, just that I haven't provided a function you can call to do it
03:40:55 <JaffaCake> s/this/thing
03:42:07 <absence> JaffaCake: bummer :) adding that function means recompiling ghc?
03:42:57 <JaffaCake> maybe not, but I'd still have to write (and test) it, unfortunately I don't have time right now
03:46:20 <absence> JaffaCake: would you mind sending me an email with a quick update when you get time to look at it? if it's a "quick fix" i'd love to try it out, but otherwise it's a bit of a showstopper for now
03:47:01 <JaffaCake> absence: you could submit a feature request, that way I won't forget
03:47:17 <JaffaCake> it's not hard to do, we could get it into 7.8.1
03:48:10 <merijn> hmm, how do I run a "ReaderT a (StateT s IO) ()"? just runReaderT on the top level? If so, how do I pass in the initial state?
03:48:20 <absence> JaffaCake: http://hackage.haskell.org/trac/ghc/newticket?type=feature+request <- here right?
03:49:06 <jdnavarro> I'm trying to understand safe imports but I don't get it
03:49:56 <jdnavarro> for example, this module http://hackage.haskell.org/packages/archive/wai-logger/0.3.0/doc/html/Network-Wai-Logger-Utils.html is importing Network.Socket which is unsafe but it's flagged as safe-inferred
03:50:09 <quicksilver> merijn: runReaderT and runStateT
03:50:19 <quicksilver> you may wish to provide your own run function
03:50:51 <absence> JaffaCake: that captcha for registering is really difficult. fourth try ... :P
03:50:59 <absence> and counting
03:51:13 <merijn> quicksilver: I figured, but runStateT returns the return value, I'm unsure what I'm expected to pass to runReaderT then...
03:51:55 <absence> wohoo, made it
03:53:34 <merijn> quicksilver: "runReaderT start ??" and "runStateT state ??" given my "ReaderT a (StateT s IO) ()" i'm not sure where to plug in my value and how to connect them...
03:53:46 <quicksilver> :t \r s a ->  runStateT (runReaderT a r) s
03:53:47 <lambdabot> forall r s (m :: * -> *) a. r -> s -> ReaderT r (StateT s m) a -> m (a, s)
03:54:02 <quicksilver> merijn: ^^
03:54:06 <merijn> Ah, thanks
03:54:16 <t7> am i allowed a character ON column 80 ?
03:54:26 <t7> counting from 1
03:54:57 <jdnavarro> I'm aware of safe inference (http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/safe-haskell.html#safe-inference) but how do I check if a package can inferred as safe?
03:54:58 <Botje> ghc doesn't care
03:57:05 <merijn> quicksilver: Right, replacing "RWST r () s IO ()" with "ReaderT r (StateT s IO) ()" solves the monoid complaints. Still completely baffled why that didn't work, though...
03:57:54 <dmwit> t7: Who's making the rules? Presumably you.
04:00:08 <byorgey> t7: no, you have to skip that column
04:00:14 <byorgey> t7: otherwise GHC deletes your .hs file
04:00:34 <byorgey> column 81 is OK though
04:01:57 <Playground> I have GHC 7.6.1 and cabal-install-1.16. When I first run "cabal update", it downloads the latest list of packages as it should. But, after that, whenever I run cabal again, I get the error "Command.optionToFieldDescr: feature not implemented", no matter what option I use (cabal list, cabal install, whatever).
04:02:06 <Playground> Has anyone else had the same problem as well?
04:03:23 <dcoutts> Playground: anything odd in your ~/.cabal/config?
04:03:24 <merijn> Playground: Are you sure you want to be using 7.6?
04:04:01 <Playground> dcoutts: The first run of "cabal update" just generated the default ~/.cabal/config file.
04:04:16 <Playground> merijn: Would you recommend that I downgrade to 7.4.2 for the time being?
04:04:24 <dcoutts> Playground: oh hmm, can you hpaste it please?
04:04:36 <Playground> dcoutts: Sure. Please wait a minute.
04:04:55 <merijn> Playground: I would recommend sticking to Haskell Platform unless you know very clearly why you need something newer
04:06:18 <Playground> dcoutts: Oh, it seems the file does not even exist. when I run "cabal update", it says "Writing default configuration to /home/.../.cabal/config, but it does not write anything at all.
04:06:32 <Playground> No, wait, I was in the wrong directory, lol.
04:06:38 <dcoutts> phew! :-)
04:08:51 <hpaste> Playground pasted “~/.cabal/config” at http://hpaste.org/75811
04:09:10 <Playground> dcoutts: Okay, done!
04:09:38 <apple_user> what do I do if readIO fails?
04:09:45 <apple_user> what should I do * if readIO fails
04:09:46 <MasseR> \o/. Got wife to buy me Okasakis purely functional data structures
04:10:18 <dcoutts> Playground: ok and that is the default one generated, you never modified it?
04:10:29 <Playground> dcoutts: Yep.
04:10:42 <Playground> dcoutts: I never modified it.
04:10:48 <dcoutts> Playground: ok thanks. The temp workaround is to comment out like 60, the jobs one.
04:10:53 <dcoutts> like/line
04:11:29 <Playground> dcoutts: Thank you! I'm gonna try it.
04:11:59 <merijn> apple_user: What do you mean by "what should I do"?
04:12:05 <merijn> apple_user: It depends on your program...
04:12:08 <Playground> dcoutts: Thanks, it works!
04:24:06 <quicksilver> merijn: would be interesting to have a minimal example.
04:24:25 <quicksilver> merijn: the time I'd *expect* to get that error was if you were using runRWST on something with no explicitly given type
04:24:33 <quicksilver> (and it couldn't infer the writer)
04:24:45 <quicksilver> however I thuoght you only used it on things annotated to have type 'Task'
04:26:38 <merijn> quicksilver: I do, but maybe the GADT pattern match in the case breaks things?
04:27:41 <quicksilver> maybe
04:28:34 <merijn> But I'm not sure enough how Rank2Types and GADTs affect type inferrence to say anything sensible
04:29:55 <quicksilver> if you can't say anything sensible, just sakzhljkhslkajhflkadjhfglskdfhglskhfgslkdfhgsldkjfnmbad,mnbemntbaso
04:30:21 <zomg> sakzhljkhslkajhflkadjhfglskdfhglskhfgslkdfhgsldkjfnmbad,mnbemntbaso!
04:30:43 <MasseR> What is the property called that \x -> x == (undo . do) x
04:31:50 <absence> JaffaCake: ticket opened, thanks for the help!
04:37:54 <merijn> Awww
04:38:08 <merijn> Why does Data.Traversable define mapM but not mapM_? :(
04:38:23 <quicksilver> merijn: because mapM_ doesnt' require Traversable.
04:38:27 <quicksilver> merijn: it's in Foldable.
04:38:48 <merijn> really?
04:39:11 <merijn> Why doesn't it reexport it then? Now I need to add an extra import line for nothing
04:39:31 <quicksilver> why should it re-export it? :)
04:40:24 <merijn> because traversable depends on foldable anyway?
04:40:41 <quicksilver> if Foo depends on Bar, should Foo re-export all of Bars functions?
04:40:49 <quicksilver> normally they don't.
04:41:05 <merijn> It just makes no sense to have a module export mapM but not mapM_, imo
04:41:31 <quicksilver> they're only legacy functions anyway
04:42:01 <quicksilver> traverse and traverse_ are more general
04:42:47 <merijn> traverse_ doesn't exist in Data.Traversable either :p
04:42:54 <quicksilver> no, it's in Data.Foldable
04:43:01 <quicksilver> because traverse_ doesn't require Traversable
04:43:12 <quicksilver> you are trapped in a moebius strip of haskell type signatures
04:43:14 * merijn reverse back to his earlier complaint :p
04:49:31 <merijn> Is there a search engine for the logs?
04:49:46 <ClaudiusMaximus> merijn: not afaik, but you can download them all and grep
04:49:58 <ClaudiusMaximus> merijn: totals several hundred mb
04:50:22 <ClaudiusMaximus> merijn: that's what i used for my Haskell IRC Fractal
04:50:33 <merijn> Bah
04:51:01 <merijn> I just want to quickly find a code snippet I posted at some point a few weeks back, but apparently that means I have to grab everything :\
04:51:27 <ClaudiusMaximus> download the index html and wget -i or so
04:51:54 * hackagebot data-named 0.4.0 - Data types for named entities  http://hackage.haskell.org/package/data-named-0.4.0 (JakubWaszczuk)
04:51:56 * hackagebot nkjp 0.2.0 - Manipulating the National Corpus of Polish (NKJP)  http://hackage.haskell.org/package/nkjp-0.2.0 (JakubWaszczuk)
04:51:59 <ClaudiusMaximus> might need baseurl settings or so
04:52:24 <merijn> Then I first need to get wget etc too :p
04:56:01 <quicksilver> ClaudiusMaximus: haskell IRC fractal?
05:02:59 <apple_user> what is the difference between a homomorphism and an isomorphism?
05:03:49 <hpc> an isomorphism is a type of homomorphism
05:04:05 <hpc> In abstract algebra, an isomorphism[1] is a bijective homomorphism.[2]
05:04:13 <hpc> so,
05:04:24 <hpc> homomorphism: structure-preserving map between two types
05:04:34 <hpc> isomorphism: homomorphism that you can reverse
05:05:09 <hpc> (structure-preserving has a fairly specific definition that i can't do justice without a lot of reading)
05:06:04 <apple_user> right
05:06:15 <hpc> "A function which preserves addition should have this property: f(a + b) = f(a) + f(b)"
05:06:26 <hpc> that's as good an example as any, of structure-preserving
05:08:43 <ClaudiusMaximus> quicksilver: http://archive.org/details/ClaudiusMaximus_-_Haskell_IRC_Fractal
05:08:49 <int-e> for example if a,b > 0, then log(a * b) = log(a) + log(b)
05:09:25 <hpc> or for matrices
05:09:34 <ClaudiusMaximus> quicksilver: https://gitorious.org/maximus/graphgrow/trees/v0.haskell-irc-fractal code
05:09:36 <hpc> for all a, b that are real numbers
05:09:47 <hpc> [a + b] = [a] + [b]
05:18:47 <ion> claudiusmaximus: Cool
05:19:24 <ClaudiusMaximus> ion: ta
05:21:55 * hackagebot luachunk 0.1.0.0 - Library functions for reading and writing Lua chunks  http://hackage.haskell.org/package/luachunk-0.1.0.0 (AnupamJain)
05:21:56 <alpounet> ClaudiusMaximus, hah fun
05:24:40 <LambdaDusk> @faq can haskell sort my life and lift me out of depression?
05:24:40 <lambdabot> The answer is: Yes! Haskell can do that.
05:24:45 <LambdaDusk> great
05:27:01 <t7> whats the function  0 = 0   1 = 1    2 = 1  ...
05:27:14 <t7> wait
05:28:10 <t7> if ln `mod` 8 == 0 then ln `div` 8 else ln `div` 8 + 1
05:31:56 <hpc> t7: look at what it does to specific bit patterns?
05:33:18 <t7> i thought there might be a function like scalar unit rather than (/= 0)
05:36:20 * sopvop watching bald and bearded people on haskell symposium videos.
05:41:01 <merijn> In true Lens style I've written code that works, but can't possibly provide the correct signature for >.>
05:43:12 <fmap> where >.> is some lens operator?
05:43:26 <Iceland_jack> <.<
05:44:33 <merijn> fmap: :p
05:47:52 <t7> someone help me write a bleedin' commutative padding scheme
05:47:59 <t7> im hungover
05:49:12 <merijn> GHC assures me the type I want is the simple: Zoom m n k (Maybe c) t => SimpleLensLike (k c) t (Maybe c) -> m c -> n c
05:51:11 <sopvop> merjin: Does it accept it?
05:53:05 <merijn> sopvop: That's what the type inferrer *says* it should be
05:53:12 <merijn> No clue what it means though xD
05:54:37 <sopvop> lets summon edwardk. Anyone know the spell?
05:54:47 <sopvop> Would probably require sacrifice of sorts.
05:54:53 * ClaudiusMaximus sings uptown type ranking
05:55:50 <ClaudiusMaximus> http://www.youtube.com/watch?v=7iD_qZ3hTDo
05:57:51 * sopvop just watched byorgey talk about monoids. Now I see monoids everywhere.
05:57:58 <ion> URL?
05:58:06 <sopvop> http://www.youtube.com/watch?v=X-8NCkD2vOw
05:58:08 <ion> Thanks
05:58:21 <sopvop> all talks are here http://www.haskell.org/haskell-symposium/2012/index.html
05:59:19 <quicksilver> sopvop: do you also see byorgey everywhere?
05:59:50 <sopvop> Not yet, should I?
06:00:55 <quicksilver> just wondered how deeply the talk had affected you :)
06:01:49 <sopvop> I had a vision, and it was revealed to me - it's all monoidal!
06:01:59 <xrchz> what's the difference between Float and Double? is there a nice webpage summarising this somewhere?
06:02:19 <sopvop> Float is 32 bits on most platforms, Double is 64
06:03:02 <xrchz> ... thanks sopvop but I guess I also meant is there a summary of reasons one might choose one over the other
06:03:30 <sopvop> Oh. Float takes less space. Double maybe faster to compute.
06:03:30 <fmap> > (1.00000001 :: Float, 1.00000001 :: Double)
06:03:32 <lambdabot>   (1.0,1.00000001)
06:04:05 <xrchz> hmm
06:04:08 <xrchz> thanks
06:04:15 <k00mi> xrchz: you may have a look at this: http://www.haskell.org/haskellwiki/Performance/Floating_point
06:04:39 <xrchz> k00mi: thanks!
06:04:54 <k00mi> no problem
06:05:33 <ClaudiusMaximus> looks obsolete apart from the first section
06:06:00 <k00mi> but its the first section thats interesting ;)
06:06:13 <ClaudiusMaximus> for speedy unboxed/fused float stuff, vector/repa/etc are good
06:06:14 <k00mi> regarding xrchzs question atleast
06:08:35 <t7> do people use semigroups in haskell?
06:09:31 <ClaudiusMaximus> http://packdeps.haskellers.com/reverse/semigroups says yes
06:12:12 <sopvop> at least third of these packages are by edwardk, author of semigroups :)
06:12:32 <sopvop> more like half even
06:13:22 <t7> whats the difference between a ring and an abelian group?
06:13:33 <t7> oh inverse?
06:15:12 <plat0> A ring has two operations.
06:15:29 <Shapeshifter> Hi. Beginner here. I wrote this rot13 http://hpaste.org/75812 function as an exercise and I have one question: The where clause gets evaluated each time in the recursion, right? So if I wanted lower and upper only to be evaluated once (which is sufficient because it's always the same), I would definitely declare it outside of the function?
06:15:29 <plat0> Well, two binary operations.
06:15:35 <plat0> An abelian group only has one.
06:15:39 <Shapeshifter> Or is there some way to have it be part of the function but only evaluated once?
06:16:15 <t7> abelian has + and * ? or is * defined using + ?
06:16:34 <plat0> No an, abelian group has only one
06:16:37 <plat0> you can call it +
06:16:39 <plat0> or you can call it *
06:16:42 <plat0> but there's only one of them.
06:17:15 <frerich> Shapeshifter: 'lower' and 'upper' are only evaluated once I think - the first time they are used (which is the first time its caller is evaluated, which is the first time the caller of the caller is evaluated.....); the result is then memorized.
06:17:25 <fmap> I'd guess people use Monoid even if Semigroup is technically enough
06:17:44 <frerich> Shapeshifter: 'lower' and '
06:17:45 <frerich> err
06:17:59 <ClaudiusMaximus> use upper = Debug.Trace.trace "i'm actually evaluating" [...]
06:18:02 <ClaudiusMaximus> to verify
06:18:17 <Shapeshifter> frerich: really? I thought it would be evaluated every time, since charnum for example is different every step in the recursion.
06:18:36 <frerich> Shapeshifter: Yes, but charnum depends on 'x' which is different for each recursion step.
06:18:45 <Shapeshifter> so basically haskell is smart enough to know that the list remains the same. how very clever!
06:19:00 <ClaudiusMaximus> this kind of thing can be affected by optimisations, so, be sure to check
06:19:11 <xrchz> does haskell have field name punning for record pattern matching?
06:19:41 <ClaudiusMaximus> ghc -supported-languages | grep -i pun   -- or similar
06:19:43 <fmap> Shapeshifter: s/haskell/ghc/
06:19:44 <sopvop> Shapeshifter: if you want to make sure, put body of rot13 into function (usually named "go") in rot13 where clause, and recurse with it.
06:19:55 <fmap> I don't think haskell report specifies this?
06:20:02 <Shapeshifter> fmap: ah yes.
06:20:17 <xrchz> data Foo = Foo {bar :: Int}; f (Foo {bar}) = bar + 1
06:20:28 <xrchz> ClaudiusMaximus: thanks... hm no results
06:20:47 <xrchz> ClaudiusMaximus: oh wait, I needed grep -i
06:20:49 <xrchz> :)
06:20:58 <ClaudiusMaximus> xrchz: try RecordWildCards perhaps if you want people to hate you
06:21:26 <fmap> xrchz: if you try your example in ghci it should suggest you the right extension
06:21:39 <ClaudiusMaximus> f Foo{..} = bar + 1  -- incomprehensible without knowing all the code, if i got the direction correct
06:22:09 <xrchz> cheers
06:22:51 <Shapeshifter> ClaudiusMaximus: well if I use trace it fires on each step of the recursion. But couldn't this be simply because of the use of trace?
06:23:25 <ClaudiusMaximus> shouldn't - so you should do as sopvop suggested i guess
06:23:36 <ClaudiusMaximus> shouldn't be because of trace, i mean
06:25:26 <Philonous> The stream-fusion library seems rather bit-rotted, is there a canonical path to update a library that depends on it?
06:26:08 <psii> Shapeshifter: ghc -ddump-simple -O2 shows, that lower and upper are relocated to the toplevel.
06:26:43 <sopvop> this rot13, isn't it just map? I avoid writing recursive functions preferring library folds
06:26:48 <Shapeshifter> But then I can conclude that ghc will always run everything used in the where clause each step of the recursion. (Which is what I was guessing). Even this evaluates for each character: http://hpaste.org/75814
06:27:34 <Shapeshifter> Even though 26 is clearly constant.
06:27:46 <ClaudiusMaximus> :t 26
06:27:48 <lambdabot> forall t. (Num t) => t
06:27:54 <sopvop> maybe trace is strict?
06:29:23 <Shapeshifter> the docs say it's "not referentially transparent".
06:30:31 <luite> Shapeshifter: lower and upper will be evaluated once at least with optimization, since they have no local free variables they'll be let floated out
06:30:57 <alpounet> Shapeshifter, if your constants are not polymorphic it won't
06:31:14 <luite> oh right polymorphism is a problem
06:31:33 <luite> but they must be [Int] to fit the types, right?
06:32:39 <Philonous> Shapeshifter:  Compiling you program without optimization indeed evaluates it 4 times, with -O (and -O2) it doesn't
06:32:39 <xrchz> is there an argmax function in standard libraries somewhere?
06:33:00 <xrchz> (or idiomatic way to do argmax)
06:33:27 <Shapeshifter> Philonous: I see, thanks
06:33:51 <copumpkin> xrchz: fst . maximumBy (comparing snd) . zip [0..]
06:34:05 <hpaste> sopvop pasted “to Shapeshifter” at http://hpaste.org/75815
06:35:04 <Philonous> @type maximumBy . comparing
06:35:05 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> a
06:35:36 <Shapeshifter> sopvop: thanks
06:36:38 <sopvop> Shapeshifter: you can also change `go (x:xs)' to `go x' and `rot13 d = map go'
06:37:00 <sopvop> Prefer library functions. They are really optimized
06:37:00 <garrensmith> anyone else find learnyouahaskell.com is down?
06:37:16 <Shapeshifter> sopvop: I shall try that. I'm still learning ;)
06:37:19 <xrchz> copumpkin: cheers. maximumBy is the main thing I guess :)
06:37:53 <xrchz> oh actually comparing is awesome too. cool.
06:38:04 <sopvop> garrensmith: http://www.downforeveryoneorjustme.com/learnyouahaskell.com
06:38:15 <garrensmith> sopvop: thanks
06:38:58 * sopvop gets back to coding boring stuff
06:39:42 <garrensmith> yup seems down.
06:41:29 <xrchz> easy way to get a list of all constructors of an enumerated type, within the language..?
06:43:37 <Philonous> xrchz:  When the type is member of Enum and Bounded: [minBound .. maxBound] :: [YourType]
06:43:52 <xrchz> Philonous: ooh, nice... can I derive Enum and Bounded automatically?
06:44:04 <shachaf> Try it!
06:44:11 * xrchz will try it :p
06:44:28 <Philonous> xrchz:  Yes you can
06:44:43 <bfig> what's the problem with this sentence: instance (Polygon a) => (Show a)
06:44:46 <xrchz> awesome! thanks Philonous, shachaf
06:44:51 <Shapeshifter> I just realized that rot13 doesn't need a direction. both directions are the same in a 26 letter alphabet >.<
06:46:19 <ClaudiusMaximus> bfig: it means that given Show, you promise to supply Polygon
06:47:12 <ClaudiusMaximus> wait, i mean that you require Polygon to construct the Show for any type a
06:47:16 <bfig> Shapeshifter, that's why it's 13, so (f.f) a == a
06:47:22 <ClaudiusMaximus> which overlaps horrily with everyhint
06:47:27 <Shapeshifter> bfig: yep
06:47:29 * ClaudiusMaximus should rest
06:48:16 <bfig> i had to add flexibleinstances and undecidableinstances to compile that line
06:48:21 <hpaste> sopvop pasted “Shapeshifter: thats more like haskellers write I guess” at http://hpaste.org/75816
06:49:28 <shachaf> bfig: That might be GHC's way of telling you you shouldn't be writing that line.
06:49:50 <bfig> i don't understand, what is the problem?
06:50:23 <shachaf> What happens if someone makes a polygon instance for Bool?
06:50:29 <bfig> i want all polygons to be Show, but show is pretty generic, so i only take the name, a point array and print those
06:50:49 <bfig> what happens is he is an idiot
06:51:08 <shachaf> "no u" -- Mr. Someone
06:51:31 <bfig> this is for code that won't be used by the public in any meaningful way
06:51:34 <shachaf> The point is that anyone can add any instance.
06:51:44 <shachaf> Are you sure a type class is the right thing to use here?
06:51:58 <bfig> what else do i have for this?
06:52:07 <xrchz> can I make ghc append .exe to executables it generates?
06:52:11 <shachaf> I don't know what you're doing.
06:52:13 <xrchz> (this would help catch them with a .gitignore)
06:52:21 <merijn> bfig: You could add a show function to Polygon?
06:52:21 <shachaf> xrchz: Doesn't it do it automatically on Windows?
06:52:22 <bfig> code for my grad thesis
06:52:32 <xrchz> shachaf: don't know. I don't use Windows.
06:52:37 <shachaf> Oh.
06:52:49 <bfig> merijn, i don't want to rewrite the show every damn time, that's the whole point
06:53:02 <sopvop> bfig: Why polygon is a typeclass? Why not data Polygon?
06:53:02 <ClaudiusMaximus> @t showList
06:53:02 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
06:53:05 <bfig> this is just for debugging purposes
06:53:15 <ClaudiusMaximus> @src Show
06:53:16 <lambdabot> class  Show a  where
06:53:16 <lambdabot>     showsPrec :: Int -> a -> ShowS
06:53:16 <lambdabot>     show      :: a   -> String
06:53:16 <lambdabot>     showList  :: [a] -> ShowS
06:53:17 <bfig> sopvop, there are several types of polygons
06:53:18 <xrchz> or can i make it write to a.out?
06:53:28 <shachaf> I suspect merijn means something like showPolygon :: Polygon a => a -> String?
06:53:30 <bfig> (they all have different representations)
06:53:31 <xrchz> which I suppose is ok for a one-program project only..
06:53:47 <ClaudiusMaximus> newtype SPolygon = S Polygon ; instance Show SPolygon where ...
06:54:09 <ClaudiusMaximus> would that help?
06:54:10 <shachaf> ClaudiusMaximus: Polygon isn't a type.
06:54:13 <bfig> wait... what's wrong with what i did?
06:54:13 <ClaudiusMaximus> oh doh
06:54:36 <merijn> bfig: As shachaf says, what happens if someone writes a Polygon instances for something that already has a show instance?
06:54:40 <shachaf> bfig: What's wrong is that what if someone makes a Polygon instance for something that has a Show instance?
06:54:49 <fmap> there should be some page that describes why `instance C1 a => C2 a' are bad
06:54:49 <bfig> i don't think that problem can be avoided for any kind of genericity used unless you put something in the middle that makes everything ugly
06:55:01 <bfig> also, i'm the only person who will be adding any of this
06:55:12 <bfig> if i need to change it at some other point i'll refactor and that's it
06:55:14 <merijn> bfig: Why not just do "class Show a => Polygon a where"?
06:55:25 <merijn> That restricts the Polygon to things that are printable
06:55:39 <bfig> but i don't want to do that
06:55:42 <shachaf> merijn: bfig wants to provide a show implementation to Polygon instances.
06:55:46 <shachaf> bfig: Type classes are open.
06:55:52 <shachaf> Are you sure type classes are what you want?
06:55:55 <merijn> shachaf: Yes, but clearly that's not going to work
06:56:03 <bfig> pretty sure i want polygons to print themselves
06:56:13 <bfig> pretty sure i need to derive the operations automagically
06:56:15 <bitonic> bfig: if you have a `instance Show a => Foo a' every other instance of Foo will overlap
06:56:17 <sopvop> bfig: Don't listen to them, It's ok to use UndecidableInstnaces as long as you control it.
06:56:21 <ClaudiusMaximus> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-overlap
06:56:25 <msr_> Is this sentence accurate: "Programming itself refers to “concept-formation”. A concept here really just refers to the mental integration of two or more singular units, isolated according to specific characteristics (as abstractions), and united by specific definitions (as integrations). We can refer to both of them combined, as a paradigm."
06:56:25 <Digit> hi, just a curiosity question... probably better suited to mailing list or somewhere with a long lasting public presence, like stackoverflow or a forum, but...
06:56:26 <Digit> can Haskell's FFI be used with, R or Falcon? ( ~ for examples of lesser-known multi-paradigm programming languages )
06:56:26 <Digit> more generally, the question is: is the haskell capable of bridging and binding with any lanuage, or are there issues of incompatibility/obscurity/complexity/inhibition?  ( ~ er, i think i prefer the original specific question)
06:56:43 <xrchz> like -osuf but for the final exe
06:56:47 <bitonic> Digit: as long as you wrap the calls to that lang in C
06:56:51 <fmap> sopvop: undecidable instances are not the problem here
06:56:53 <bitonic> which is probably possible
06:56:56 <merijn> Digit: If your language supports a C FFI then you can go through C to do it
06:57:03 <Digit> lol. msr_ that could almost be be an answer to my question too.
06:57:09 <merijn> Digit: i.e. Haskell -> C -> YourLang
06:57:46 <msr_> Digit: I'm just writing a paper on something similar, and that sentence feels like it could be misconstrued.
06:57:48 <merijn> (Which is coincidentally something I'm using right now :p)
06:57:58 <msr_> merijn: YourLang you mean?
06:58:02 <Digit> oh, is the FFI soley C?  like C has to be an intermediary?  ... how i read about it in Real World Haskell gave me the impression you could marry any language, more directly with haskell.
06:58:25 <sopvop> C is the best language for being intermediary.
06:58:36 <Digit> msr_: indeed.  it's vagueness gives it a bredth of interpretation.
06:58:50 <msr_> sopvop: It's more or less a high-level assembler.
06:58:58 <sopvop> msr_: Right!
06:59:05 <bitonic> Digit: that impression is wrong, the Haskell report leaves space for any language, but in practice is C
06:59:17 * Digit nods
06:59:21 <ClaudiusMaximus> Digit: FFI can be to other languages, like primitives in C-- or javascript for ghcjs or whatever other compilers exist
07:00:06 <merijn> Digit: The spec allows any language, but not many compilers implement anything other than C
07:00:07 <ClaudiusMaximus> in practice (ie, regular ghc) there's ccall and stdcall and confusion between them can be awkward on Windows, mainly, going from osmosis
07:01:04 <merijn> Digit: If you're willing to implement a direct binding for your language without C in the middle then that is an option, yes. But in practice not many people find the investment worthwhile when compared to going through C
07:04:23 <maurer>     Probable cause: the inferred type is ambiguous
07:04:35 <maurer> Where should I look to try to figure out how to dodge this?
07:04:56 <maurer> (Note: Writing annotations isn't a choice, because I'm trying to use ghc's type inference engine to solve something - I don't know what type goes there when generating the code)
07:05:10 <Digit> well it's all still very much just concept and theory for me at my level of programming savvy.  actually touching the likes of FFI seems a long way off for me.  but as i had power-read my way ahead to encounter it in rwh, it keeps ringing in the back of my mind.
07:09:09 <merijn> Digit: tbh, the FFI is not all that hard (assuming you're familiar with C, of course :p)
07:09:10 <Digit> the mere existence of something like FFI, to my layman perspective suggests Haskell has an increased ability to be an everyman of languages.  the ever elusive "one language to rule them all", that the multi-paradigm languages like R and falcon are striving to be.
07:11:54 <sopvop> Why Fridays are always so silent?
07:13:25 <gargawel> Potesne latine loqui, cognominal ?
07:14:21 * sopvop answers with few spells: corp por, corp cop, in vas flam
07:14:23 <Digit> thanks for your responses, bitonic, merijn, sopvop, and ClaudiusMaximus.  :)  i'll stop letting my muse munch on curiosities for now and get back to something more in my immediate reach... like xmonad configurations.  ^_^
07:15:25 <bitonic> Digit: "Haskell has FFI" means 1) there is a framework to include FFI to whatever in the report 2) GHC has FFI to C
07:15:40 <bitonic> 3) some other compiler has some experimental support for some other language
07:15:55 <mux> quick unimportant style question: do you prefer f <$> g <$> m or (f . g) <$> m ?
07:16:03 <bitonic> but generally the only reliable FFI is to C, and that's true in general
07:16:10 <b__> can one sort an intset without converting it first?
07:16:14 <cognominal> gargawel, at least someone that got one of the meaning of my pseudo. And sorry, I am not really a latinist.
07:16:16 <merijn> mux: "f . g <$> m"
07:16:26 <bitonic> b__: what?
07:16:33 <b__> etc sorry
07:16:35 <b__> intmap
07:16:40 <b__> by value
07:16:43 <merijn> b__: Sets and Maps have no ordering
07:16:50 <merijn> b__: So your question is nonsensical
07:16:50 <b__> ah right
07:16:51 <bitonic> b__: you need to go through the list
07:16:52 <b__> : D
07:17:08 <b__> ok thanks, going back to sleep : D
07:17:15 <bitonic> b__: that is, if you want to sort the values.  the intmap knows nothing about the values
07:17:50 <bitonic> they're fully polymorphic, no constraints
07:17:56 <merijn> bitonic: I think he was asking whether you're forced to do "sort . toList" instead of "sort" on the map itself
07:18:04 <bitonic> merijn: yes
07:18:13 <gargawel> cognominal: No problem !
07:18:28 <b__> merijn, yeah, but I wasn't thinking straight
07:20:21 <nicoo> cognominal: I assume one of the others would be that you are a fictionnal cog
07:20:35 <Cale> hpc, apple_user: a better definition of an isomorphism is that it's a homomorphism which has an inverse that is also a homomorphism. i.e. a homomorphism f: A -> B is an isomorphism when there is some homomorphism g: B -> A such that g . f = id and f . g = id
07:20:57 <Cale> Just saying that it's bijective is enough to ensure this in many settings, but breaks down in some
07:21:35 <nicoo> copumpkin: And don't worry, I'm sitting right next to gargawel without remembering much Latin; he is not (too) close-minded ;)
07:22:01 <copumpkin> you mean cognominal?
07:22:05 <merijn> LambdaCase but no LambdaIf? :(
07:22:08 <nicoo> copumpkin: Yes
07:22:13 <nicoo> Sorry :$
07:22:29 <gargawel> Anyway, is it reasonable to speak latin in a world of lambdas ?
07:22:40 <Digit> http://dallas.salonseeker.com/TX/Haskell/Osmosis.html lol.  not what i was looking for.
07:22:40 <nicoo> ><'
07:23:04 <nicoo> Digit: Nice one
07:27:03 <merijn> Where can I find an overview of test-suite's supported by cabal and what they're good for?
07:27:39 <dcoutts> merijn: you mean the different test-types?
07:27:46 <merijn> Yeah
07:27:58 <dcoutts> currently it's just exitcode-stdio-1.0
07:28:26 <dcoutts> we have another one out in Cabal-1.16 but that's very new and it's not yet supported by libs like test-framework
07:28:38 <dcoutts> but once it is, then that should be quite nice
07:29:07 <dcoutts> merijn: so unless you're developing something like test-framework and want to support the new cabal test interface, just stick to the basic one
07:29:08 <merijn> Mostly I just need to add some testing to my package and it'd be nice if I can integrate it with cabal, but I have no clue where to start looking
07:29:56 <dcoutts> merijn: it's in the cabal user guide
07:29:56 <dcoutts> http://www.haskell.org/cabal/users-guide/developing-packages.html#test-suites
07:30:12 <merijn> Yeah, I'm reading that already :)
07:30:25 <dcoutts> ok good good
07:36:24 <merijn> I'm guessing it'll just try to compile the file I pass to main-is and run the result?
07:43:42 <bartavelle> merijn, yes, and will display program output if it fails
07:44:06 <bartavelle> it will compile with "cabal build" and run with "cabal test"
07:44:09 <merijn> Is enabling Rank2Types to do something like "type Output = MonadIO m => MVar () -> m Stream" a bad idea?
07:44:23 <bartavelle> I wish "cabal test" would do all of "cabal configure --enable-text && cabal build && cabal test"
07:44:34 <bartavelle> s/text/test/ obviously
07:45:04 <Eduard_Munteanu> merijn: not if you really want a rank 2 type
07:45:17 <merijn> Eduard_Munteanu: I don't think it matters in my scenario?
07:45:37 <merijn> The m doesn't appear anywhere else in type signatures I use
07:46:07 <Eduard_Munteanu> Yeah, I guess it's fine.
07:46:31 <merijn> afaik there's not real semantic difference between "MonadIO m => Foo m -> a -> b -> c" and "(MonadIO m => Foo m) -> a -> b -> c"
07:46:57 <shachaf> There isn't?
07:49:47 <merijn> shachaf: Well, is there?
07:49:53 <Saizan> you can go fron the latter to the former, vice-versa is not guaranteed
07:50:00 <Eduard_Munteanu> > let f :: a -> Int; f a = a in f 5
07:50:01 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:50:01 <lambdabot>         against inferred type ...
07:50:05 <Eduard_Munteanu> > let f :: (forall a. (Num a) => a) -> Int; f a = a in f 5
07:50:06 <lambdabot>   5
07:50:25 <Eduard_Munteanu> Erm.
07:50:43 <Eduard_Munteanu> > let f :: Num a => a -> Int; f a = a in f 5
07:50:44 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:50:44 <lambdabot>         against inferred type ...
07:51:30 <Eduard_Munteanu> merijn: see? ^^
07:54:57 <merijn> Saizan: Right, and since the former is what I have currently and the latter is what I'd get when I clean up the type signatures I'm fine
07:56:46 <Eduard_Munteanu> merijn: yes, you're probably fine with your original type synonym
07:58:58 <DMcGill>  /msg lambdabot @pl f b = g b . h
07:59:17 <merijn> Some of my code has more lines of imports/exports than actual source >.>
07:59:26 <DMcGill> @pl f b = g b . h
07:59:27 <lambdabot> f = (. h) . g
07:59:34 <msr_> merijn: Sounds only normal.
08:14:03 <bfig> shachaf, in the end i will use something like showPolygon >_>
08:14:31 <bfig> no pretty way to do the typeclass thing like you said :|
08:20:10 <merijn> Is there a way to get more info beyond "thread blocked indefinitely in an MVar operation"?
08:20:52 <ClaudiusMaximus> threadscope / lots of debug prints?
08:21:13 * ClaudiusMaximus guessing againg
08:21:18 <ClaudiusMaximus> and can't type
08:21:38 <bfig> question: what is the most painless way to do linear algebra?
08:22:30 <ClaudiusMaximus> i've once used hmatrix for implementing "as rigid as possible" interpolation of affine transformations in 2d, was quite simple to get working
08:23:03 <ClaudiusMaximus> i've also used Vec for low-dimensional (<=4) stuff
08:23:28 <ClaudiusMaximus> neither is particulalrly painless (especially Vec the types get really hairy; and hmatrix only goes up to Double iirc)
08:24:43 <ClaudiusMaximus> hmatrix also uses foreign libraries for the heavy lifting, and at one time had issues in ghci
08:25:18 <bfig> that's not nice
08:25:25 <bfig> i just want basic 2-dimensional linear algebra
08:25:40 <bfig> definitions for two dimensional vectors, inner product and some other minimal stuff
08:25:47 <maurer> Is there a way to tell haskell to "close" a typeclass so that its inference engine will know that one of the instances currently in scope must be used to satisfy a constraint?
08:26:05 <merijn> maurer: Nope
08:26:12 <maurer> :(
08:26:16 <merijn> maurer: I know
08:26:37 <maurer> Looks like I need to use coq or agda or something for this
08:28:57 <ppseafield> fuck you php-mode >_>
08:29:14 <ppseafield> Wrong channel, excuse me.
08:29:39 <mroman> Now we know you hate php .
08:29:55 <maukd> "mode" sounds more like emacs
08:30:29 <ppseafield> "mode" is emacs, and since it's common to write php interspersed with html, js, and occasionally css, it doesn't work that great
08:32:01 <Eduard_Munteanu> ppseafield: try Snap or Yesod for a change ;)
08:32:09 <aayana> @src length
08:32:09 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:32:36 <ppseafield> Eduard_Munteanu: I am learning Snap at the moment, but I don't think my place of employment would like to use haskell unfortunately
08:32:45 <maukd> length = foldl' (\z _ -> z + 1) 0
08:35:20 <Shapeshifter> When cabal fails half way, it still doesn't roll back to the start. What do I need to do to clean up? E.g. now I did 'cabal install gtk2hs-cast-gtk' which failed at the end with two ExitFailure 1 messages. Yet now I already have gtk2hs-cast-th in ghc-pkg list and there's stuff in .cabal/packages/hackage.haskell.org/ that wasn't there before.
08:36:09 <byorgey> Shapeshifter: don't worry about the stuff in .cabal/packages.  That's just a cache.
08:36:31 <byorgey> Shapeshifter: if you want to uninstall gtk2hs-cast-th you can do:  ghc-pkg unregister gtk2hs-cast-th
08:36:58 <merijn> Wait...does getChanContents produce an infinite list?
08:37:05 <byorgey> Shapeshifter: I agree it would be nice to have some sort of ability to specify "transactions", i.e. "only install these packages if all of them build successfully"
08:37:11 <Shapeshifter> byorgey: does this also delete the library files?
08:37:19 <byorgey> Shapeshifter: no, it doesn't.
08:37:54 <maurer> merijn: I think it ends when there are no longer any possibility of writes
08:37:59 <Shapeshifter> byorgey: so I delete them from .home/.cabal/lib/. Is there anything else to be deleted?
08:38:20 * maurer still annoyed at the lack of some way to close typeclasses, it would have been so perfect
08:38:49 <rwbarton> not rolling back is nice because it means when you fix whatever's stopping your package from installing you don't need to wait another 10 minutes for all its dependencies to install again
08:39:12 <Nafai> maurer: what do you mean by "close" typeclasses?  Allowing no other instances of the typeclass?
08:39:22 <byorgey> Shapeshifter: I don't know.  I don't think so.
08:39:37 <maurer> Nafai: Yes, with the typechecker understanding this and being able to use it to do better inference
08:40:09 <maurer> Nafai: e.g. "There are exactly 3 instances of this typeclass, and already concretized types rule out 2 of them, so now I know what the other types are.
08:40:19 <Nafai> makes sense
08:43:01 <rwbarton> you could emulate closed type classes to a degree with DataKinds but I think even then the solver will not do this kind of branching logic
08:43:56 <rwbarton> well hmm
08:44:02 <rwbarton> it might depend on what your use site looks like
08:44:34 <nerob> hi everyone
08:45:30 <nerob> how would i write this in haskell, or something similar: int x = printf("hello"); if (x == 0) printf("we printed hello"); else printf("we didn't print hello");
08:45:51 <maukd> putStr "hello"
08:46:00 <maukd> and if it fails, it throws an exception
08:46:03 <ben> I'm not sure we have a printf function that returns whether it succeeded
08:46:15 <nerob> maukd: yeah. I figured that there was no way to check for that
08:46:19 <nerob> ben: heh
08:46:24 <nerob> bummer
08:46:43 <ClaudiusMaximus> @hoogle hPutBuf
08:46:43 <byorgey> can putStr throw an exception?
08:46:44 <lambdabot> System.IO hPutBuf :: Handle -> Ptr a -> Int -> IO ()
08:46:44 <lambdabot> GHC.IO.Handle hPutBuf :: Handle -> Ptr a -> Int -> IO ()
08:46:44 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
08:46:44 <merijn> Exceptions are superior for IO failures anyway
08:46:54 <merijn> byorgey: of course
08:47:20 <byorgey> in what situation?
08:47:20 <ben> I'm thinking you'd start with x <- catch (putStr "hello" >> return True) (const $ return False)
08:47:39 <ben> but you can probably squeeze it into the exception handling without the helper variable
08:47:42 <maukd> byorgey: any time the underlying write(2) fails, I'd imagine
08:47:47 <Clint> <stdout>: hFlush: invalid argument (Invalid argument)
08:48:09 <typoclass> nerob: as far as i know, printf returns the number of bytes printed, so if it gives 0 that would indicate an error. and yes, in haskell that's often handled via exceptions (there's a few other mechanisms available too). we prefer that because you can't accidentally forget to check it, which is a common source of bugs in c code
08:48:16 <rwbarton> e.g. your output was redirected to a file and you just ran out of disk space
08:48:38 <rwbarton> or maybe if you were writing to a pipe whose reader end has been closed, not sure
08:48:47 <Clint> or stdout is just closed
08:48:49 <merijn> Socket and your kernel runs out of mbufs
08:48:49 <typoclass> byorgey: i bet if you close stdout before doing the putStr, it'll throw
08:48:54 * byorgey tries it
08:48:57 <rwbarton> is that an exception?
08:49:03 <Clint> <stdout>: hFlush: invalid argument (Invalid argument)
08:49:45 <maukd> EDESTADDRREQ, EFBIG, EINVAL, EIO, ENOSPC, EPIPE
08:49:48 <ben> bracketOnError (putStr "hello") (const $ putStr "we didn't print hello") (const $ putStr "we printed hello")
08:49:51 <ben> This looks pretty good
08:49:55 <byorgey> WriteFail: <stdout>: hPutStr: illegal operation (handle is closed)
08:50:17 <typoclass> byorgey: right. is that an exception or some other thing?
08:50:20 <ClaudiusMaximus> rwbarton: http://sourceforge.net/tracker/index.php?func=detail&aid=3303222&group_id=55736&atid=478072 for your first example
08:50:41 <ben> I can't think of an error condition for putStr where the subsequent printf would succeed though.
08:50:51 <byorgey> I don't know of any other things
08:51:09 <Clint> ben: shouldn't that also be true in the C?
08:51:10 <merijn> byorgey: I just assume any and all IO can throw errors :p
08:51:24 <merijn> w00t, my test seems to run too \o/
08:51:31 <ben> Clint: probably
08:51:31 <rwbarton> ben: someone can delete a file on the filesystem between the printf calls :)
08:51:51 <ben> Maybe you can get interrupted by an asynchronous exception?
08:52:01 <typoclass> agreed, for putStr it all sounds a bit far-fetched. for hPutStr it's more plausible
08:53:33 <quicksilver> rwbarton: although with traditional unix semantics that's not an error.
08:53:57 <quicksilver> (you can continue to write just fine to deleted files; it's one idiom for private temp files to open and unlink)
08:54:50 <merijn> quicksilver: He meant disk space full > file gets deleted so disk space free
08:55:03 <quicksilver> oh, sorry
08:55:04 <merijn> quicksilver: In the error scenario where stdout is redirected and you fail due to lack of disk space
08:55:05 * quicksilver nods
08:55:25 <quicksilver> if you write to an FD and get a device out of space condition
08:55:42 <quicksilver> it's pretty hard to recover from it
08:55:48 <quicksilver> because you might have written partial data
08:56:04 <quicksilver> (even if space does later get freed as you say)
08:56:33 <jane__> I thinks IO type is evaluated to a value like a pointer to a function.
08:56:40 <jane__> is right?
08:56:43 <rwbarton> yeah, it seems like future writes really ought to be an error if you have gotten ENOSPC before, but I bet they aren't
08:57:06 * hackagebot macosx-make-standalone 0.1 - Make a macosx app standalone deployable  http://hackage.haskell.org/package/macosx-make-standalone-0.1 (AtzeDijkstra)
08:57:19 <typoclass> now i wonder if the standard putStr actually checks the number of bytes written ... i recall that for unix sockets ('send' or whatever it's called), it gave me an Int and i had to do that myself
08:57:27 <jane__> i have a question about IO type.
08:57:39 <jane__> I thinks IO type is evaluated to a value like a pointer to a function. is right?
08:58:04 <nerob> <ben> bracketOnError (putStr "hello") (const $ putStr "we didn't print hello") (const $ putStr "we printed hello")
08:58:05 <nerob> mmm
08:58:49 <nerob> I don't even know how to interpret that.
08:58:53 <nerob> lol
08:58:56 <rwbarton> jane__: you mean a function like in the C sense of function?
08:59:04 <nerob> I guess I can main = bracketOnError ...
08:59:23 <jane__> rwbarton : a pointer value to a fuction
08:59:45 <rwbarton> but what does "function" mean, surely not a function like in Haskell
08:59:50 <ben> nerob: I'm not sure it's right
09:00:02 <jane__> like c function.
09:00:14 <rwbarton> yes, then I think it's an okay way to think about IO
09:00:22 <jane__> hmm..
09:00:27 <nerob> or not
09:00:38 <jane__> thanks rwbarton.
09:00:40 <Sculptor> hi!
09:00:44 <nerob> ben: get a hello.hs:1:8: Not in scope: `bracketOnError'
09:00:53 <ben> Sorry, it's from Control.Exception
09:00:53 <typoclass> nerob: i think you have to import Control.Exception first. also, see http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Exception.html#v:bracketOnError
09:00:53 <rwbarton> in C the closest equivalent to IO Int would be int (*)(void)
09:01:00 <ben> but my code is wrong
09:01:11 <nerob> oh cool
09:01:14 <jane__> it is not crrect haskell code.  but i think like this..
09:01:15 <typoclass> nerob: i think ben had it switched around, but you can see it in the docs
09:01:15 <nerob> oh ok
09:01:20 <jane__> type IO = (Int, Int)
09:01:26 <jane__> putStrLn :: String -> IO ()
09:01:32 <jane__> putStrLn s = (address_of_putStrLn, address_of_s)
09:01:33 <merijn> I need some way to output a list one element at a time, passed through. I was using a Chan but that's not really convenient because there's no way to determine when you're finished receiving said list
09:01:51 <rwbarton> that is a possible implementation strategy yes
09:01:53 <merijn> The other solution I can think of is to have an MVar containing a list, but continuosly appending would be inefficient..
09:01:54 <jane__> and..expression "putStrLn "abc"" will be evaluateed  like this
09:02:09 <jane__> putStrLn "abc" => 	[0xaabbccdd, "abc"]
09:03:11 <typoclass> nerob: the primary thing to look at in those documentation pages is the type signature (written after the ::). "String -> Int -> Char" means it's a function that takes a String and an Int and gives back a Char
09:03:17 <typoclass> :t bracketOnError
09:03:18 <lambdabot> Not in scope: `bracketOnError'
09:03:19 <quicksilver> merijn: Chan (Maybe a)
09:03:24 <typoclass> oh great ... :-/
09:03:26 <quicksilver> merijn: and pass a Nothing when done?
09:04:43 <rwbarton> jane__: if you want to think at this low level there are a lot of other details to work out (like what is (>>=), return etc. and how does the runtime system actually execute these values)
09:04:46 <Baughn> @hoogle rwhnf
09:04:46 <lambdabot> Control.Parallel.Strategies rwhnf :: Strategy a
09:04:54 <rwbarton> but it won't give you a wrong idea about IO in my opinion
09:05:27 <nerob> typoclass: lol
09:05:31 <nerob> thanks
09:05:33 <nerob> :D
09:05:51 <nerob> ben: when i import Control.Exception, it seems to work, but maybe that's undefined behaviour.
09:06:31 <ben> nerob: It works when putStr prints correctly, but he exception handling bit actually only covers the last putStr call when I thought it might also cover the first :/
09:06:43 <ben> so when you get an exception, it just errors and doesn't actually print the last bit
09:07:03 <ben> err, the failure-mode bit anyway
09:08:48 <nerob> ben: oh, mm
09:10:09 <typoclass> i think i'd write something like «do { putStr "lolcat" ; putStr "printing succeeded" } `onException` (putStr "printing failed")», modulo indentation and newlines
09:10:33 <nerob> is do { } a function?
09:10:40 <ben> That's not entirely equivalent since I could theoretically see something like "lolcatprinting succprinting failed"
09:10:43 <quicksilver> no, it's special syntax
09:10:56 <Baughn> nerob: Why do you ask?
09:11:24 <quicksilver> ben: standard file IO is really not atomic or transactional.
09:11:37 <quicksilver> you need higher level constructs (typically some kind of journal format) if that's what you need.
09:11:40 <ben> of course that's the best case behavior that i was going to get from bracketOnError anyway even if it did work like i thought it might
09:11:50 <nerob> be back in a bit
09:12:13 <rwbarton> what was wrong with the catch / return True/False version?
09:12:14 <ben> quicksilver: I mean in the original C snippet it'd only print the "didn't print" message if the first message didn't print, not if the second message got interrupted~
09:12:31 <ben> rwbarton: variables are gross!
09:12:58 <apple_user> http://www.willamette.edu/~fruehr/haskell/evolution.html ^_^
09:13:11 <quicksilver> ben: *nod*
09:14:46 <typoclass> ben: right, but i think your bracketOnError thing would allow half-printed strings as well. and i found it a little, uh, creative to put the main action in the 'acquire resource' parameter ... :-)
09:14:57 <ben> Yeah
09:15:04 <Cale> <nerob> is do { } a function?  -- sometimes beginners ask really interesting questions :)
09:15:16 <ben> I got confused where bracketOnError was putting the exception catching bits
09:15:38 <ben> I'm surprised there's not actually a function that is basically try { } catch ( ) else { }
09:15:41 <ben> + { }
09:15:48 <typoclass> Cale: i think he meant «does "do {}" declare a function» :-)
09:16:33 <typoclass> ben: absolutely, the bracketXYZ functions' parameters always felt somehow out of order to me
09:17:00 <rwbarton> is there a way to put a constraint on all instances of a standalone type family?
09:17:00 <Cale> typoclass: Well, apart from what he meant by the question, the actual question of whether there is a single function which captures everything that the do-notation does is interesting :)
09:17:10 <ben> typoclass: I can see bracket (malloc 1024) (free) $ \myActualMemory -> do ... looking quite nice
09:17:37 <typoclass> ben: sure, once you get the hang of it, it makes sense ...
09:17:51 <ben> yeah, I just got enough hang of it to hang myself just now~
09:18:36 <Cale> (of course, >>= in some sense is an answer to the question as well)
09:18:51 <rwbarton> something like type family (Num (T a)) => T a :: *
09:22:31 <Cale> edwardk: Have you looked much at what can be done in terms of new-style "lenses" which perhaps don't meet the laws? The fact that the thing has to work for an arbitrary functor on its own implies a fair amount of structure...
09:22:59 <mysticc> I have a datatype here http://hpaste.org/75821 .. I want to capture a series of computations of this datatype so I thought of defining a monad instance for this, but I also need to be able to store the series of computations persistently. Can anybody help me with that ?
09:23:19 <edwardk> i mostly ignore unlawful lenses. i find that in practice almost everything someone wants to do in a way that breaks the laws can be done more usefully in a way that preserves them
09:24:06 <statusfailed> edwardk: Do you have a reference for the motivation behind your "Machines" package? We're trying to figure out exactly what it abstracts :D
09:24:09 <edwardk> i get requests about one every two days for something like that, and all but one of those i've been able to defuse by pointing to an existing combinator or different way to put the thing together
09:24:31 <edwardk> statusfailed: i should probably write something up about it ;)
09:24:34 <Cale> I don't have any practical motivation here.
09:25:00 <statusfailed> We're kinda sorta feeling that it would be good for stream processing but having a lot of trouble grokking it
09:25:10 <edwardk> statusfailed: the gist is it abstracts over the notion of input to the point where you can have machines that take multiple inputs, unlike pipes/conduits
09:25:18 <edwardk> statusfailed: thats exactly what its for
09:25:33 <edwardk> statusfailed: we use it to munge a bunch of relational algebra data here
09:25:57 <edwardk> merging streams doing joins, hash joins, merge joins, filtering and shuffling data around, etc.
09:26:27 <statusfailed> I don't suppose you have any toy examples I could have a look at? That sounds like the sort of thing i'd like to use it for :)
09:27:21 <edwardk> basically the idea is a machine is a composable widget, you can build machines from plans that are written in monadic style, and then you compose them as machines by wiring up inputs to sources, either pure sources where you 'preload' it with data like a hopper for a machine, or monadic sources which know how to get their own data and you then run the composite machine
09:27:29 <luite> anyone working on language-ecmascript here?
09:28:13 <edwardk> statusfailed: i think Apocalisp has an example or two in the scala port that shows how to do some simple stuff
09:28:50 <statusfailed> edwardk: ah, brilliant, thanks! I'll check that out
09:28:59 <edwardk> https://github.com/runarorama/scala-machines/blob/master/src/main/scala/com/clarifi/machines/Example.scala shows a wordcount/linecount/etc example
09:29:41 <Cale> But for example, there's this widget:  bilens :: (a -> c) -> (d -> b) -> Lens a b c d; bilens g h = \f -> fmap h . f . g
09:29:45 <edwardk> the model is a bit differently in scala because it lacks the monadic machine plumbing, and there a machine is just a Plan[Nothing]
09:30:13 <Cale> which looks almost too simple not to be somehow useful, even if it seems extremely unlikely that it satisfies the laws unless g and h are special
09:30:16 <edwardk> Cale: have you looked at Iso?
09:30:43 <Cale> Right, so if those two maps are isomorphisms, it's actually a lens
09:30:59 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Iso.hs#L87
09:31:01 <edwardk> yep
09:31:51 <edwardk> and to comply with the lens laws your 'bilens' type would need to be instantiable with types that could make them an isomorphism
09:32:45 <edwardk> if you can't pick a = b, c = d, thats a good sign that you don't have a lens ;)
09:33:45 <edwardk> i can't enforce that because of the way the type system works, but all the laws assume that
09:34:17 <johnw> edwardk: what would the type system need to enforce something like that?
09:34:54 <typoclass> {-# LANGUAGE Oleg #-}
09:35:58 <edwardk> johnw: its messy =P. basically the correct type of a lens would be something like type Lens outer inner = forall i j f. Functor f => (inner i -> f (inner j)) -> outer i -> f (outer j) -- where inner and outer are type _families_
09:36:19 <edwardk> but then the composition of lenses leads to a particularly hairy type family equation
09:36:44 <Cale> I'm sort of interested in seeing what happens if you start breaking the laws. It wouldn't be so interesting in the old style of lens libraries, but I feel like the new type of Lens still imposes quite a bit of structure, and it would be nice to know exactly how much.
09:37:05 <edwardk> i look forward to the results of your research ;)
09:37:19 <rwbarton> isn't it exactly as much as the old-style lens-without-laws
09:37:27 <edwardk> in practice i use the laws to keep sane, so I hope you don't mind if I don't follow you on your journey ;)
09:38:13 <typoclass> cabal install insane-lenses
09:38:22 <Baughn> Was there some way to get strictness data for functions out of .hi files?
09:38:22 <Cale> rwbarton: I'm uncertain. You need things to work out for any choice of functor at all, and you have that implicit naturality law that we discussed before.
09:38:43 <rwbarton> what new-style lens type are you considering exactly?
09:38:45 <Baughn> (To explain: I'm debugging a time leak in xmonad, but I've currently got it isolated to a /function call/. This disturbs me.)
09:38:54 <Cale> rwbarton: The one from Edward's library
09:38:56 <thoughtpolice> Baughn: there are annotations in the .hi that mark function strictness, but i don't know how you'd programatically grab that
09:38:58 <rwbarton> ugh
09:39:01 <apple_user> is Control.Monad.forM_ like a for-loop in C?
09:39:04 <Baughn> thoughtpolice: I'd settle for manually.
09:39:07 <rwbarton> I mean, write it here :P
09:39:14 <thoughtpolice> a contrived way to do it would be to use --show-iface and just parse
09:39:18 <rwbarton> otherwise how can I know which of the 10000 types you are talking about
09:39:21 <thoughtpolice> lemme see
09:39:32 <Cale> type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
09:39:37 <rwbarton> okay
09:39:56 <johnw> apple_user: I'd have to squint my eyes really hard to see that connection
09:39:57 <copumpkin> Cale: how would you weaken it?
09:39:58 <edwardk> apple_user: more or less
09:39:58 <apple_user> forM_ [1..10] do putStrLn "foo"
09:40:03 <Cale> Now, you may be right, in that we do have:  lens :: (a -> c) -> (a -> d -> b) -> Lens a b c d
09:40:08 <apple_user> > forM_ [1..10] do putStrLn "foo"
09:40:09 <lambdabot>   <no location info>: parse error on input `do'
09:40:12 <rwbarton> those are the only possibilities
09:40:12 <apple_user> :(
09:40:13 <johnw> there's no initialization expression, and no mutated iteration variable
09:40:24 <apple_user> ah right
09:40:37 <rwbarton> the only way I can produce f b is from f d and a function b -> d, with a also in scope
09:40:39 <johnw> it's a bit more like std::for_each in C++
09:40:48 <rwbarton> and the only way I can produce f d is from c, with a also in scope
09:40:50 <edwardk> Cale: the new lens formulation and the old formulation are equivalent. you can pass it "Context id" and get the data-lens style lens-family
09:40:54 <edwardk> a -> Context c d b
09:40:57 <johnw> or a range-based for in C++11
09:41:10 <apple_user> right
09:41:11 <edwardk> that choice of functor completely characterizes a lens
09:41:24 <apple_user> I thought mapM_ was like std::for_each though
09:41:25 <edwardk> just like passing it a Bazaar can completely characterize a traversal
09:41:27 <rwbarton> so my only choices are a -> c and a -> d -> b (I see I wrote it backwards "b -> d" above)
09:41:32 <johnw> apple_user: forM_
09:41:37 <johnw> forM_ == flip mapM_
09:41:45 <thoughtpolice> Baughn: so, if you use --show-iface on some .hi file, and you look at the dumps of functions/data types etc, you'll see right under the type signature something like this:
09:41:48 <thoughtpolice> {- Arity: 2, HasNoCafRefs, Strictness: LS,
09:41:50 <mysticc> undefined is of any type so I can give any value undefined .. now suppose I had a function f :: (SomeClass a) => a -> b .. now when I give "f undefined" it complains ..?
09:41:54 <apple_user> ah
09:42:12 <johnw> undefined: it's a bit more correct to say that every type has its own undefined
09:42:15 <thoughtpolice> Baughn: i can't remember what the letters correspond to however, they've changed in the past and whatnot
09:42:21 <apple_user> so forM_ is mapM_ with the arguments reversed ^_^
09:42:22 <johnw> two differently types undefined's are not equivalent
09:42:26 <thoughtpolice> Baughn: probably worth asking in #ghc where that code is
09:42:29 <rwbarton> mysticc: well yeah, what do you expect
09:42:49 <Cale> rwbarton: yes, I see what you're saying
09:42:50 <rwbarton> different choices of the type a (instances of SomeClass) may produce different values of type b
09:42:57 <johnw> apple_user: yeah, mainly because it's convenient to say: forM_ [1.10] $ \i -> putStrLn (show i)
09:43:03 <mysticc> rwbarton: I just wanted to typecheck my code .. What to do .. I haven't defined any instance for SomeClass right now ..
09:43:28 <rwbarton> hmm
09:43:30 <edwardk> another way to see that is a particular odd way to write a store comonad is newtype Store c d b = Store { runStore :: forall f. Functor f => (c -> f d) -> f b } and then it becomes obvious that the new lenses and the old store based lenses are equivalent. the new ones are just flipped
09:43:40 <typoclass> mysticc: are you doing "f undefined" or "f _ = undefined"?
09:43:54 <mysticc> typoclass: f undefined inside a code ..
09:44:13 <johnw> mysticc: can you pastie the code and the whole complaint?
09:44:21 <rwbarton> well I think if you get an Ambiguous type variable error, that means your code typechecked otherwise
09:44:28 <rwbarton> not wholly satisfactory though
09:46:58 <johnw> mysticc: I use "undefined" as a placeholder all over, so there may be another subtlety at work here.  Because undefined can be "any type", sometimes it's not enough to nail down an inferred type in cases where multiple types might be acceptable
09:46:59 <apple_user> so you can overload any operator in Haskell?
09:47:00 <mysticc> johnw: here is the code http://hpaste.org/75823 .. here is the monad instance http://hpaste.org/75822
09:47:14 <johnw> apple_user: there is no overloading in Haskell in the C++ sense
09:47:21 <johnw> there are type classes
09:47:34 <johnw> two functions with the same name will give an ambiguity error
09:47:48 <johnw> two instances of the same type class can define functions of the same name within that type class
09:48:07 <johnw> this gives the feel of operator overloading, but via a wholly different mechanism
09:48:12 <atriq> And a lot of common functions are in type classes
09:48:20 <atriq> For instance, almost all numerical functions
09:48:24 <atriq> :t (+)
09:48:25 <lambdabot> forall a. (Num a) => a -> a -> a
09:48:31 <atriq> :t mod
09:48:32 <lambdabot> forall a. (Integral a) => a -> a -> a
09:48:58 <johnw> mysticc: what type will the arguments to notify typically be?
09:49:18 <johnw> mysticc: you can always do: notify (undefined :: Type1) (undefined :: Type2)
09:49:58 <mroman> nTimes = mapM (const $ ...) [1..n] is very slow?
09:50:18 <johnw> mroman: is that a question, or something you've observed?
09:50:24 <dimka> How can I figure out that process with pid ∷ ProcessID is running now?
09:50:58 <johnw> mroman: also, you can use: replicate n ...
09:50:59 <maukd> find out how to call 'kill' from haskell, send it signal 0
09:51:01 <johnw> or replicateM
09:51:27 <mysticc> johnw: They can be of anytype until they have instance to the class... http://hpaste.org/75822 .. see the definition of the datatype here
09:51:53 <mysticc> johnw: The problem is I have still not defined any instance of those typeclasses
09:52:03 <johnw> maukd: does http://hackage.haskell.org/packages/archive/unix/2.6.0.0/doc/html/System-Posix-Process.html help?
09:52:10 <mroman> johnw: It's an observation.
09:52:15 <mroman> It's too slow to be practical.
09:52:21 <johnw> mysticc: ah, then you may need type annotations to be able to use undefined there
09:52:27 <rwbarton> you could also just stat /proc/nnn assuming this is not supposed to be portable
09:52:28 <johnw> otherwise, it's entirely ambiguous
09:53:04 <maukd> :t signalProcess nullSignal
09:53:06 <lambdabot> Not in scope: `signalProcess'
09:53:06 <lambdabot> Not in scope: `nullSignal'
09:53:13 <mroman> http://codepad.org/YR4zV6xA
09:53:42 <mroman> It's so slow you can go to the cellar and get a beer.
09:53:51 <johnw> mroman: well, mapM is the same as doing "sequence $ map", so you are building a list of monadic actions, and then evaluating them all to build a list of their results within the monad.  Depending on the size of n, this can be rather expensive, as the resulting list cannot be lazily consumed
09:54:19 <johnw> @src replicateM
09:54:20 <lambdabot> replicateM n x = sequence (replicate n x)
09:54:31 <rwbarton> runs in 0.1 second here
09:54:34 <dimka> mroman: signalProcess :: Signal -> System.Posix.Types.ProcessID -> IO ()
09:54:35 <mysticc> johnw: Is there a way of doing that without defining the instances for the typeclasses ..
09:54:39 <johnw> replicateM is probably just as bad, depending on the "..." in your example
09:54:41 <rwbarton> or less rather
09:54:46 <dimka> It's not really helpfull because of IO ()
09:55:02 <mysticc> isn't there any type which is instance of all the typeclasses by default .. something like undefined ..
09:55:11 <maukd> dimka: it'll throw an exception if the process doesn't exist
09:55:23 <johnw> mysticc: which type classes?  Person and Storable?
09:55:32 <mysticc> johnw: Both ..
09:55:33 <mroman> :t replicateM
09:55:34 <dimka> Is there an analog with IO Bool return type?
09:55:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
09:56:16 <mysticc> johnw: I just started writing the code and I am long way from defining instances for those so until then I just wanted to see my code typecheck ..
09:56:41 <johnw> mysticc: i don't think you can get away without defining some instances
09:56:59 <rwbarton> well write your own type data UndefinedPerson; instance Person UndefinedPerson; data UndefinedStorable; instance Storable UndefinedStorable; undefinedPerson = undefined :: Person; ...
09:57:00 <johnw> otherwise, the type checker has no way of ensuring that b c are of those type classes!
09:57:12 <johnw> yeah, I'd do what rwbarton suggests
09:57:27 <mroman> still incredibly slow @replicateM
09:57:38 <mysticc> rwbarton: I think I will do that .. Thanks ..
09:57:39 <rwbarton> mroman: your program runs in 0.06 seconds
09:57:54 <mroman> Really?
09:57:55 <rwbarton> also why do you think it is slow due to replicateM specifically?
09:57:56 <johnw> mroman: how big is n, and what is "..."?
09:58:00 <rwbarton> yeah I ran it here
09:58:06 <rwbarton> why, how long does it take for you
09:58:11 <mroman> runsN 10000 100 is what I'm using
09:58:16 <rwbarton> oh
09:58:33 <mroman> 15s
09:58:43 <rwbarton> okay, 10s about the same
09:58:46 <johnw> mysticc: (\i -> rest i >>= f) == (rest >=> f), btw
09:59:06 <mroman> Target is runsN 1000000 1000
09:59:15 <johnw> you can go to your cellar and get a beer in 10s?
09:59:32 <mroman> I guess it's possible in 15s
09:59:37 <rwbarton> haha
09:59:58 <johnw> mroman: what OS are you on?
10:00:02 <mroman> Windows.
10:00:04 <mroman> Win7
10:00:08 <mroman> to be more specific.
10:00:10 <rwbarton> don't you think it's more likely that randomIO is what's slow
10:00:13 <johnw> are you interacting with your machine while the test runs?
10:00:24 <rwbarton> I mean you are generating a million random numbers
10:00:27 <johnw> if not, the entropy generator may be very slow waiting for system events to drive the randomizer
10:00:30 <rwbarton> two million rather
10:00:49 <johnw> try twirling the mouse around while your program runs
10:00:57 <johnw> ssh-keygen has this same problem
10:01:08 <rwbarton> randomRIO is just a pure haskell PRNG
10:01:19 <johnw> but it's in IO, why is that?
10:01:27 <rwbarton> for global random number state
10:01:32 <johnw> ah
10:01:47 <rwbarton> and for automatic random seeding (but this doesn't require tons of randomness and probably just uses the process id and the time)
10:02:05 <johnw> acuatlly, the docs for System.Random say "or Linux's kernel random number generator"
10:02:13 <johnw> so maybe it uses the system random generator if present
10:02:27 <rwbarton> right but it doesn't read two million words from it
10:02:34 <johnw> gotcha
10:02:48 <johnw> so it's a true random seed, if available, but a PRNG sequence
10:02:49 <mroman> johnw: I can create 1000000 random values with randomRIO in less than a second.
10:02:54 <rwbarton> anyways it is taking 9.157 user time here
10:03:37 <mroman> Takes about 7s for 10000000
10:03:38 <johnw> have you timed just the randomN function?
10:03:47 <pnielsen> johnw, rwbarton: that's /dev/urandom, not /dev/random, IIRC. urandom doesn't block
10:03:53 <mroman> (replicateM 10000000 (randomRIO (-100,100)) >>= return.length that is.
10:03:57 <mroman> )
10:04:03 <johnw> because you are calling randomN n * n * t times
10:04:24 <rwbarton> isn't it just 2*n*t?
10:04:34 <johnw> not in the list monad
10:04:36 <apple_user> how do I curry the second argument of a function instead of the first
10:04:39 <johnw> y <- randomN n is evaluated for every x
10:05:03 <rwbarton> he's not using the list monad
10:05:07 <rwbarton> he's using the IO monad :P
10:05:12 <johnw> randomCoordsN
10:05:13 <mroman> n * n * t?
10:05:18 <mroman> 2n*t?
10:05:23 <johnw> oh, randomN returns IO []
10:05:29 <mroman> hm no.
10:05:42 <mroman> oh.
10:05:43 <mroman> so
10:05:47 <mroman> hm.
10:05:48 <rwbarton> anyways it is true that all this putting a bunch of random numbers into lists and then processing the lists is likely to have some overhead
10:05:51 <mroman> Let me add type signatures
10:06:31 <rwbarton> but I don't know how much that overhead will be compared to generating a bunch of random numbers and converting them to doubles and squaring and adding and squarerooting them
10:07:16 <johnw> also, mroman, the result value from randomCoordsN is not evaluated until you print, so you are generating a rather large number of thunks here from what I can see
10:07:29 <johnw> have you observed your heap profile?
10:07:44 <mroman> I'm not very familiar with profiling ghci
10:08:00 <johnw> ohh, you are running this all in ghci
10:08:03 <johnw> ?
10:08:41 <johnw> i'll profile it for you here
10:09:15 <mroman> Ok
10:09:16 <johnw> your program runs in 3.1 here
10:09:56 <rwbarton> btw using Integer is probably not exactly ideal
10:10:06 <apple_user> sorry wrong channel
10:10:10 <apple_user> oops* wrong channel again
10:10:13 <apple_user> http://ideone.com/2Vdy7 any way to accomplish what line 6 does without using a lambda?
10:10:18 <mroman> randomN has 63.9% time
10:10:26 <mroman> and 64.4% alloc
10:10:29 <johnw> oh, n/m, I didn't change the numbers in main
10:10:37 <shachaf> apple_user: where f x = ...
10:10:41 <mroman> next cost centres are x_delta and y_delta in distance
10:10:42 <apple_user> oh
10:10:58 <maukd> map (flip percentage)
10:11:19 <apple_user> maukd: that works!
10:11:26 <maukd> but I forgot the 100
10:11:27 <apple_user> no need for where clause
10:11:32 <apple_user> thanks guys
10:11:36 <shachaf> map (`percentage` 100)
10:11:46 <mroman> total time = 4.33 secs
10:11:58 <mroman> (for 10000 100)
10:12:02 <mroman> faster then ghci
10:12:05 <rwbarton> what happened to 15 seconds?
10:12:06 <rwbarton> oh
10:12:06 <mroman> *than
10:12:10 * hackagebot fb 0.13 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.13 (FelipeLessa)
10:12:12 * hackagebot yesod-fb 0.2.1 - Useful glue functions between the fb library and Yesod.  http://hackage.haskell.org/package/yesod-fb-0.2.1 (FelipeLessa)
10:12:14 * hackagebot fb-persistent 0.2 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.2 (FelipeLessa)
10:12:16 * hackagebot yesod-auth-fb 1.3 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.3 (FelipeLessa)
10:12:16 <shachaf> @ty ((/) `on` fromIntegral)
10:12:17 <lambdabot> forall b a. (Fractional b, Integral a) => a -> a -> b
10:12:19 <rwbarton> wow ghci was only a factor of 3 slower?
10:12:28 <apple_user> shachaf: no need for flip ^_^
10:12:56 <apple_user> http://ideone.com/u9aJD
10:15:35 <apple_user> http://ideone.com/Nyiti why is my fizzbuzz implementation incorrect?
10:16:02 <mroman> 3.25s with -O3
10:16:18 <MostAwesomeDude> apple_user: Guards are matched in order.
10:16:28 <johnw> mroman: ok, it's as I thought
10:16:37 <apple_user> http://ideone.com/WLu49 ah that fixed it
10:16:39 <atriq> apple_user, whenever it should be FizzBuzz, it's seeing, "wow, n `mod` 3 is 0! Let's go down that path!"
10:16:40 <MostAwesomeDude> apple_user: http://ideone.com/AbKtW
10:16:42 <johnw> within the first 0.5s your program allocates 225 MB of memory
10:16:54 <johnw> and then gradually frees it all over the next 4 seconds
10:16:56 <mroman> o_O
10:17:18 <johnw> and that 225 MB is allocated evenly over the whole 0.5s
10:17:20 <mroman> > 1000000 * 4 / 1024 / 1024
10:17:21 <lambdabot>   3.814697265625
10:17:37 <rwbarton> * 4, what
10:17:44 <johnw> interesting, that close to how much time it takes to run here
10:17:48 <mroman> 32bit Int ;)
10:17:56 <rwbarton> you are a very optimistic person
10:18:04 <mroman> Integer is unboended though
10:20:32 <mroman> hm
10:20:42 <mroman> having randomRIO generating (Double,Double)...
10:20:43 <mroman> well
10:20:47 <mroman> 8s :)
10:20:54 <rwbarton> try Int
10:21:11 <rwbarton> Double changes the meaning anyways
10:21:36 <rwbarton> (probably in a good way, but still, not really valid to compare times)
10:22:15 <mroman> Switching to Int makes it 0.1s faster
10:22:16 <mroman> 2.9s
10:22:44 <rwbarton> I guess that makes sense because you don't really do any arithmetic on the Ints
10:22:50 <rwbarton> or Integers rather
10:23:45 <rwbarton> try defining return' x = x `seq` return x and using return' in place of return on line 25
10:24:04 <shachaf> Or «return $! x»
10:24:08 <rwbarton> that should avoid the 225 MB of simultaneous space usage
10:24:16 <rwbarton> yeah but it is in an awful composition pipeline
10:24:24 <shachaf> Oh, I didn't see the context.
10:24:34 * shachaf looks for context.
10:24:47 <rwbarton> http://codepad.org/YR4zV6xA
10:25:18 <rwbarton> I guess you can write (return $!)
10:25:32 <rwbarton> hmm is this even what I want
10:25:34 <johnw> trying that here
10:25:44 <mroman> hm yeah.
10:25:47 <rwbarton> I think so
10:25:50 <mroman> Now I see the heap profile.
10:25:50 <rwbarton> @type evaluate
10:25:51 <johnw> my current runtime is 38s (I was measuring the wrong number)
10:25:52 <lambdabot> Not in scope: `evaluate'
10:25:55 <johnw> return $! brings it down to 9s
10:25:56 <rwbarton> @hoogle evaluate
10:25:57 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
10:25:57 <lambdabot> Control.Exception evaluate :: a -> IO a
10:25:57 <lambdabot> Control.OldException evaluate :: a -> IO a
10:26:07 <johnw> and it eliminates the heap consumption
10:26:21 <johnw> now max allocation stays < 4 MB, and the pattern is evenly spread
10:26:36 <rwbarton> it's still sort of silly to do so much heap allocation
10:26:44 <rwbarton> but it would require more intrusive changes to fix that
10:27:11 * hackagebot stream-fusion 0.1.2.4 - Faster Haskell lists using stream fusion  http://hackage.haskell.org/package/stream-fusion-0.1.2.4 (KidoTakahiro)
10:27:13 <rwbarton> well, not that intrusive I guess. 'result' needs to change
10:27:19 <mroman> return $! in the line return $ (sum runs) / ..?
10:27:24 <rwbarton> no
10:27:25 <johnw> heap profiler suggests it's the lists used in, and returned from, randomCoordsN which are now consuming all the memory
10:27:26 <rwbarton> the line above that one
10:27:36 <johnw> (return $!) .
10:27:40 <rwbarton> right
10:27:42 <johnw> after the >>=
10:27:50 <mroman> ok
10:28:27 <johnw> also, randomCoordsN is a classic cry for applicative: randomCoordsN n = zip <$> randomN n <*> randomN n
10:28:46 <tdammers> hey
10:28:54 <tdammers> suppose I have a text file somewhere
10:29:04 <johnw> i refuse
10:29:09 <johnw> all your files are binary
10:29:12 <tdammers> and I want to compile its contents into my haskell source, as a string literal or similar
10:29:14 <mroman> Yes.
10:29:20 <mroman> It cuts down the memory usage
10:29:26 <mroman> but my 10000 100 run is still 2.9s
10:29:28 <tdammers> how would I go about that, ideally?
10:29:36 <mroman> so I did not speed up things for 10000 100
10:29:54 <tdammers> I thought about making a tiny quasiquoter for that
10:29:57 <rwbarton> tdammers: probably with TH
10:30:06 <typoclass> tdammers: possibly TH. there's 1 or 2 on hackage at least, but i forgot the name(s)
10:30:10 <rwbarton> $(LitE . StringL <$> readFile whatever)
10:30:15 <tdammers> yeah
10:30:21 <tdammers> that's what I figured so far
10:30:24 <atriq> I love how brilliant Haskell is as a language
10:30:41 <tdammers> maybe I'm a bit spoiled lately, but isn't there a more elegant way?
10:30:42 <atriq> :D
10:30:47 <typoclass> tdammers: http://hackage.haskell.org/package/file-embed <- could be relevant to your interests
10:30:47 <atriq> Sometimes I just have to say that
10:31:17 <tdammers> typoclass: the name at least sounds promising, let me look at that
10:31:18 <mroman> And it crashes for 1000000 1000 with a stack overflow
10:31:38 <luite> yeah file-embed is useful for this
10:31:56 <johnw> mroman: this helped speed by over 20% here:
10:31:57 <johnw> randomCoordsN n = replicateM n $ (,) <$> randomRIO (-100,100) <*> randomRIO (-100,100)
10:32:03 <luite> embedding binary files is tricky, since the string literal assumes utf8 encoding
10:32:05 <johnw> getting rid of the intermediate lists
10:32:24 <johnw> and the heap profile stays in the 3MB range, rather than the 4MB range now
10:32:50 <tdammers> I'm embedding javascript and PHP source, in case that matters
10:32:50 <rwbarton> yeah that is a lot better
10:32:54 <tdammers> and possibly python later
10:33:13 <rwbarton> actually
10:33:17 <rwbarton> it is a little better :)
10:33:25 <johnw> it's 20% better :)
10:33:31 <tdammers> so no binary embedding there
10:33:34 <luite> tdammers: file-embed should work for binary files though
10:33:35 <rwbarton> a lot better would be to use vector and vector-random
10:33:41 <johnw> randomCoordsN is taking 66% of the total runtime
10:33:43 <tdammers> it seems to work on bytestrings
10:33:50 <tdammers> so yes, that's what I figured
10:33:51 <johnw> and 72% of the total allocation
10:34:02 <johnw> so yeah, anything to improve it's characteristics will have a major impact
10:34:12 <mroman> @hoogle <$>
10:34:13 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
10:34:13 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
10:34:26 <mroman> @hoogle <*>
10:34:26 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
10:34:33 <hpaste> johnw pasted “myraw.hs” at http://hpaste.org/75825
10:35:01 <rwbarton> the point is you can't do any processing on the result of replicateM n (randomRIO (-100,100)) until you have generated all the random numbers
10:35:02 <johnw> mroman: f <$> a <*> b == liftM2 f a b
10:35:10 <johnw> rwbarton: yep
10:35:14 <rwbarton> which requires a bunch of allocation
10:35:18 <johnw> it's an inherent bottleneck
10:35:19 <mroman> Yeah.
10:35:21 <mroman> 2.59s now.
10:35:28 <mroman> for 10000 100
10:35:35 <johnw> mroman: try vector-random
10:35:38 <rwbarton> even if you just switched to a State monad I think you could do better
10:35:51 <rwbarton> but yeah, vector/vector-random will be much better (partly because it has a faster RNG)
10:35:53 <johnw> G.random <$> newPureMT <*&> pure 100000
10:35:58 <johnw> will generate 100000 random doubles
10:36:07 <johnw> s/<*&>/<*>
10:36:37 <johnw> and if you don't *need* them in tuple pair, generate two separate lists and consume them as lists
10:36:45 <mroman> but it takes forever just for 100000 100
10:36:47 <johnw> from what I can see, you are building tuples simple to deconstruct them elsewhere
10:36:51 <shachaf> <*&$%>
10:36:55 <johnw> lol
10:37:14 <johnw> err, s/lists/vectors
10:37:17 <mroman> 26s
10:37:18 <mroman> yeah.
10:37:24 <mroman> I guess I can skip the tuples.
10:37:48 <johnw> i love performance golfing
10:37:52 <johnw> I could do this all day
10:39:32 <atriq> I'm the kind of person who enjoys golfing the number of unique functions.
10:39:44 <atriq> Makes for some crazy obfuscation
10:40:09 <johnw> as a C++ person, I'm used to writing ugly code for maximal speed, so golfing for code beauty isn't part of my makeup yet, while golfing for minimal runtime is a years-long tradition :)
10:40:29 <bfgun> what do you think about typesynonyminstances ?
10:40:42 <shachaf> johnw: Remember when they called "golfing" "optimization"?
10:40:54 <johnw> shachaf: man, that was days ago
10:40:54 <atriq> I'm an esoteric programming person, which I suppose explains my attitude
10:41:11 <johnw> bgamari: you mean data vs. newtype?
10:41:46 <Lutin`> johnw: It's a GHC extension
10:42:02 <johnw> oh, TypeSynonymInstances?
10:42:21 <Lutin`> Yes
10:42:22 <shachaf> Not to be confused with the well-known GHC extension TypesynOnyminStances
10:42:22 <Saizan> bfgun: semantically they don't change anything, they are just convenient to save some typing
10:42:29 <johnw> haha
10:42:30 <Lutin`> lol shachaf
10:42:32 <shachaf> ==Saizan
10:42:36 <rwbarton> TypeSynonymInstances was my example of an extension no one could possibly object to and then someone promptly objected to it
10:43:15 <Saizan> rwbarton: hah, why? readability?
10:43:22 <bfgun> lol
10:43:34 <rwbarton> I think they were confusing it with another extension, possibly
10:43:35 <Lutin`> I can't even find out what exactly the extension does
10:43:41 <rwbarton> but I was still amused
10:43:46 <Lutin`> Only places listing it
10:43:51 <bfgun> it allows you to instance typeclasses over 'type' declarations
10:44:09 <bfgun> ie, type X = Y; instance Cl X where...
10:44:10 <shachaf> {-# LANGUAGE Glasgow #-}
10:44:24 <Lutin`> Ah
10:44:40 <Lutin`> Yeah I need to learn all the glasgow-exts
10:44:49 <Saizan> shachaf: that prints out type errors in scottish slang, right?
10:44:55 <shachaf> An alternative to TypesynonymInstances is CPP
10:44:59 <shachaf> #define X Y
10:45:03 <shachaf> instance Cl X where
10:45:08 <shachaf> It totally works.
10:45:20 <Lutin`> not sure if serious...
10:45:32 <rwbarton> this is when I was (mostly jokingly) suggesting language options -X1, -X2, -X3 to go along with -O1, -O2, -O3
10:45:32 <shachaf> #haskell is never serious.
10:45:53 <tommd> No, but the people inside sometimes are...
10:46:26 <tdammers> shachaf: as opposed to #haskell-blah
10:46:37 <tdammers> which is like, totally serious.
10:48:14 <johnw> ok, who else has space leaks, bring 'em in!
10:48:31 <johnw> I've yet to come across a legitimate need for lazy patterns
10:49:29 <shachaf> @remember ShelSilverstein Lazy Lazy Lazy Lazy Lazy Lazy Jane. She wants a drink of water so she waits and waits and waits and waits and waits for it to rain.
10:49:29 <lambdabot> Done.
10:50:54 <mroman> I got it down to 2.30s
10:50:59 <shapr> johnw: Is that the irrevocable match things with a tilde?
10:51:07 <mysticc>  @hoogle (>=>)
10:51:18 <shapr> johnw: If so, I do know of a good use for them.
10:52:12 * hackagebot TypeCompose 0.9.5 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.9.5 (ConalElliott)
10:52:31 <tommd> johnw: Are you serious?  I use lazy patterns frequently when the actual value being passed in is undefined.
10:53:24 <callen> http://dpaste.de/VEHJb/ alright, what gives?
10:54:01 <shachaf> callen: What's the actual type URI?
10:54:11 <shachaf> Oh, this isn't your program.
10:54:11 <geekosaur> what gives is you have multiple versins of the network package installed
10:54:12 <callen> shachaf: this is from trying to cabal install cabal-install
10:54:15 <callen> shachaf: this isn't my code.
10:54:17 <mroman> Let me switch to a state monad :)
10:54:23 <shachaf> callen: What version of GHC?
10:54:32 <callen> 7.4.1
10:57:39 <dcoutts> tibbe: lets make sure we have the network constraint right in the next point release, see ^^
10:58:04 <tibbe> dcoutts: I missed the chat, was offline
10:58:06 <clahey> I'm using xml-conduit's readFile to parse XML.
10:58:13 <tibbe> dcoutts: if someone could file a bug that'd be great
10:58:21 <dcoutts> tibbe: http://dpaste.de/VEHJb/
10:58:28 <clahey> I did mapM on a list of paths to get a list of results.
10:58:31 <dcoutts> though actually, I can't see why that's happening
10:58:53 <clahey> I was expecting that it would continue with the second item in the list even if the first one failed, but that wasn't the case.
10:58:56 <rwbarton> I didn't think you could ever get into this situation with cabal-install
10:58:59 <clahey> Is there a way to do this?
10:59:11 <mroman> :t replicateM_
10:59:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
10:59:16 <dcoutts> callen: how are you building cabal-install?
10:59:43 <shapr> tommd: Got a good demo of lazy patterns?
10:59:52 <tibbe> dcoutts: what should the constraint be?
11:00:13 <dcoutts> tibbe: actually I don't see what's going wrong in this example, so I'm not sure it's a constraint problem
11:00:17 <tibbe> dcoutts: I don't remember changing the constraint, but it looks like cabal-install already had a too liberal constrain
11:00:39 <tibbe> dcoutts: who reported the problem?
11:00:42 <dcoutts> tibbe: yeah, lets just check what it really should be by testing
11:00:47 <dcoutts> tibbe: callen
11:01:05 <tibbe> callen: Could you please file a bug at https://github.com/haskell/cabal issues?
11:01:17 <tibbe> callen: include the error and the output of cabal install -v
11:01:26 <tibbe> callen: the -v will tell us which package versions were picked
11:01:46 <tibbe> callen: so cabal install -v cabal-install-1.16.0
11:06:46 <mroman> http://codepad.org/eeRTL8k6
11:06:52 <mroman> ^- I thought it would be faster
11:09:37 <rwbarton> use modify' where modify' f = do { x <- get; put $! f x }
11:09:49 <rwbarton> or I guess better would be, uh
11:09:50 <rwbarton> @type state
11:09:52 <lambdabot> forall s a. (s -> (a, s)) -> State s a
11:10:03 <tommd> shapr:  bitSize ~(BigWord h l) = bitSize h + bitSize l
11:10:31 <rwbarton> modify' f = state $ \s -> let s' = f s in s' `seq` ((), s')
11:10:41 <mroman> runs in 2.25s
11:10:46 <mroman> allocates continously MB
11:10:49 <mroman> (up to 8)
11:10:55 <mroman> and frees all 8MB at program end
11:11:28 <rwbarton> this isn't the real program is it?
11:11:41 <rwbarton> where is the other loop
11:11:45 <clahey> @hoogle err -> IO a -> IO Either err a
11:11:46 <lambdabot> Did you mean: err -> IO a -> IO (Either err err)
11:11:46 <lambdabot> No results found
11:11:55 <clahey> @hoogle err -> IO a -> IO (Either err a)
11:11:56 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
11:11:56 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
11:11:56 <lambdabot> Network.TCP writeBlock :: HStream bufType => HandleStream bufType -> bufType -> IO (Result ())
11:12:01 <mroman> 2.25s for 1000000 coordinates
11:12:05 <tdammers> yep, FileEmbed does the trick
11:12:07 <clahey> @hoogle a -> IO b -> IO (Either a b)
11:12:08 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
11:12:08 <tdammers> works like a charm
11:12:08 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
11:12:08 <lambdabot> Network.TCP writeBlock :: HStream bufType => HandleStream bufType -> bufType -> IO (Result ())
11:12:12 <mroman> rwbarton: I removed the"aveerage" loop
11:12:17 <clahey> @hoogle IO b -> a -> IO (Either a b)
11:12:17 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
11:12:18 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
11:12:18 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
11:12:25 <rwbarton> I see
11:12:31 <rwbarton> and you are running with parN = 1000000
11:13:36 <kirindave_> http://www.well-typed.com/blog/71
11:13:42 <kirindave_> So excited to see more public-facing talk about CH.
11:13:51 <kirindave_> I've been lurking on the mailing list and it's crazy exciting.
11:14:41 <mroman> doesn't do much @modify
11:15:04 <clahey> :t handle
11:15:05 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
11:15:09 <rwbarton> i got a stack overflow for your paste here (with parN = 1000000)
11:15:42 <mroman> Yes.
11:15:45 <rwbarton> also my second definition of modify' should have been modify' f = StateT $ \s -> let s' = f s in s' `seq` return ((), s')
11:15:54 <mroman> I had to increase with -KSize
11:16:40 <rwbarton> well here with that second modify' it runs in 1.6s
11:16:43 <rwbarton> so I don't know what happened
11:16:50 <rwbarton> since I was getting times like 7s for the previous version
11:17:13 * hackagebot DeepArrow 0.3.7 - Arrows for "deep application"  http://hackage.haskell.org/package/DeepArrow-0.3.7 (ConalElliott)
11:18:17 <mroman> Runs in 21.98 secs for parN=10000000 (with modify')
11:18:46 <rwbarton> I wonder why that made such a huge difference here but not for you
11:19:56 <mroman> Thanks for your help.
11:20:41 <mroman> I wished it would at least get the first two digits right :D
11:20:45 <mroman> but it does not.
11:21:56 <mroman> The method is to blame :)
11:23:18 <lispy> what is the correct way to get the current user on windows?
11:23:31 <lispy> eg., the equivalent of getEnv "USER"
11:24:01 <mroman> GetUserName?
11:24:06 <ksf> getCurrentUser(NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL);
11:24:45 <lispy> hmmm
11:24:49 * lispy looks at the docs
11:25:06 <mroman> Although that is WINAPI
11:25:13 <mroman> Not sure how good bindings to WINAPI are in Haskell.
11:27:22 <hpaste> mroman annotated “GetUserName” with “GetUserName (annotation)” at http://hpaste.org/41521#a75828
11:27:31 <mroman> Code by google :)
11:29:44 <lispy> cool, I was going to say getUserName doesn't seem to be bound in the Win32 bindings on hackage
11:31:03 <mroman> lispy: Or use getEvnt "USERNAME"
11:31:24 <mroman> the environment variable holding the name of the user on windows is USERNAME
11:31:39 <mroman> If getEnv supports windows.
11:31:53 <mroman> @hoogle getEnv
11:31:53 <lambdabot> System.Environment getEnv :: String -> IO String
11:31:53 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
11:31:53 <lambdabot> System.Posix.Env getEnv :: String -> IO (Maybe String)
11:32:14 <lispy> mroman: it does.
11:32:27 <mroman> Prelude System.Environment> getEnv "USERNAME"
11:32:29 <mroman> "mroman"
11:32:31 <mroman> Works :)
11:32:40 <thelarry> Hi! I am new to haskell, just reading something about it in 'learn you some haskell'. I found a type called "maybe". What is it? And what is it for?
11:32:44 <clahey> :t tryJust
11:32:45 <lambdabot> Not in scope: `tryJust'
11:32:59 <mroman> thelarry: It *maybe* contains a result, or nothing.
11:33:28 <thelarry> thx!
11:33:31 <mroman> Sometimes used to indicate errors.
11:33:39 <thelarry> ok
11:33:52 <mroman> > let div a b = if (b == 0) then Nothing else (a / b) in div 10 2
11:33:53 <lambdabot>   No instance for (GHC.Real.Fractional (Data.Maybe.Maybe a))
11:33:54 <lambdabot>    arising from ...
11:34:03 <mroman> > let div a b = if (b == 0) then Nothing else Just (a / b) in div 10 2
11:34:04 <lambdabot>   Just 5.0
11:34:08 <mroman> > let div a b = if (b == 0) then Nothing else Just (a / b) in div 10 0
11:34:08 <thelarry> so something that can be bound or unbound....?
11:34:09 <lambdabot>   Nothing
11:34:41 <mroman> "Yes".
11:35:56 <mroman> > map (fromMaybe "Default") [Just "John",Nothing,Just "Jane"]
11:35:57 <lambdabot>   ["John","Default","Jane"]
11:37:13 * hackagebot TypeCompose 0.9.6 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.9.6 (ConalElliott)
11:37:27 <rwbarton> something that can be something or unsomething
11:38:02 <tromp> how can something be unsomething??
11:38:06 <lispy> thelarry: in ML they called Maybe the "option type"
11:38:25 <tdammers> in the .NET world, it's called a nullable type
11:38:31 <lispy> thelarry: are you familiar with pointers ala C?
11:38:39 <mroman> In Java it's probably a class!
11:39:04 <lispy> thelarry: pointers are similar in spirit to the Maybe type. You can have a NULL pointer (like Nothing) or a pointer that points to a "real" address.
11:39:33 <lispy> (in reality, all pointers point to real addresses, so this analogy does break down)
11:40:11 <tromp> Maybe is the solution to java's "billion dollar mistake", the null reference
11:40:45 <lispy> tromp: the billion dollar mistake? Is this the title of an essay or something?
11:40:56 <tromp> http://qconlondon.com/london-2009/presentation/Null+References:+The+Billion+Dollar+Mistake
11:41:06 <lispy> thanks
11:44:24 <mroman> http://codepad.org/zt8Bp7ve
11:45:00 <mroman> Something like that probably :D
11:45:35 <thelarry> oh thx again. i understood.
11:46:29 <mroman> Java has NULL-Objects
11:47:23 <mroman> I like that.
11:47:45 <mroman> I like how OOP languages create huge problems you can circumvent with more OOP.
11:47:45 <danharaj> Are there any theoretical problems with the fact that (Cont r) is not universally quantified over r?
11:48:13 <mroman> And I like how Haskell has no OOP and people circumventing that by trying to create something like OOP :)
11:48:26 <geekosaur> "OOP solves all problems"
11:48:27 <danharaj> No one seriously uses anything like OOP in serious Haskell code.
11:48:31 <mroman> So
11:48:37 <Cale> danharaj: Not quite true
11:48:47 <danharaj> Cale: Boo :<
11:48:57 <mroman> Theorem I: If $Language has no OOP, someone will attempt to simulate it in $Language.
11:49:17 <dimka> Is there a way to make a function :: IO () -> IO Bool that return False if argument function raise any exception and return True otherwise?
11:49:21 <mroman> Theorem II: There might be an actual need for OOP in non-OOP languages.
11:49:46 <Cale> You can capture what I consider to be the essence of OO with simple record types (consisting primarily of functions) and functions which construct those.
11:49:50 <clahey> dimka: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
11:49:58 <danharaj> dimka: You probably do not want to catch all exceptions.
11:50:01 <Ke> can someone explain to me, what is OOP anyways
11:50:05 <Cale> Just by thinking about it a certain way.
11:50:07 <conal> http://harmful.cat-v.org/software/OO_programming/why_oo_sucks  -- joe armstrong
11:50:07 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
11:50:17 <lispy> dimka: yeah, you want to look at the exception support
11:50:19 <Ke> a while ago someone said OOP was virtual functions
11:50:19 <mroman> Cale: And lenses to simulate getter/setters?
11:50:20 <danharaj> Cale: I don't think that's really OOP but yes that is reasonable.
11:50:23 <Cale> You lose all the sucky things about OO
11:50:37 <Cale> i.e. implementation inheritance and subclassing
11:50:50 <Eduard_Munteanu> danharaj: http://comonad.com/reader/2008/kan-extensions/ see Ran and Cont there
11:50:53 <lispy> dimka: I always forget the module names. Control.Monad.Exception or Control.Exceptior or some such
11:50:55 <Cale> but you keep the essence of it, which is that objects are determined by the manner in which they respond to messages
11:50:55 <clahey> :t catch (return False) (const return False)
11:50:57 <lambdabot>     Couldn't match expected type `Bool'
11:50:57 <lambdabot>            against inferred type `GHC.IO.Exception.IOException'
11:50:57 <lambdabot>       Expected type: IO Bool
11:51:05 * lispy also can't type
11:51:25 <mroman> People hacked OOP into C
11:51:27 <Cale> and moreover, you tend to need subclassing a whole lot less
11:51:44 <mroman> So there is obviously at least some need for the "essence" of OOP in non OOP languages.
11:52:03 <conal> i like joe armstrong's story about why IBM prolog got OO extensions
11:52:04 <Cale> The reason that you need subclasses so much in most typed OO languages is that method implementations are attached to the class declarations
11:52:07 <clahey> :t catch (myFunction >>= const (return True)) (const (return False))
11:52:08 <lambdabot> Not in scope: `myFunction'
11:52:08 <lispy> interfaces and abstraction is always useful when humans design things
11:52:10 <Cale> which in my mind is kind of absurd
11:52:19 <clahey> :t catch (putStrLn "hello" >>= const (return True)) (const (return False))
11:52:21 <lambdabot> IO Bool
11:52:26 <tac> I remember when I was learning OOP, subclassing seemed like the least useful thing ever.
11:52:28 <Cale> OO classes ought to be types of objects
11:52:35 <clahey> dimka: Something like that?
11:52:35 <mroman> And it allows you to do fancy decorator, proxy stuff
11:53:00 <Cale> i.e. the class ought to say which messages are being responded to, and what the types of the messages and responses are
11:53:03 <mroman> which can probably be done in Haskell in its own way too.
11:53:12 <Cale> and not say *how* the object does this
11:53:34 <clahey> So, I'd like to just use typeclasses in my code.
11:53:57 <clahey> But it's not possible to have a list of different types of the same class, is it?
11:54:26 <clahey> And it's certainly not possible to downcast with a test.
11:54:27 <Cale> clahey: not without an existential
11:54:39 <apple_user> would a function like flip be possible in a non-functional language?
11:54:42 <maukd> :t cast
11:54:43 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
11:54:45 <apple_user> :t flip
11:54:46 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:54:48 <ksf> rust can do that.
11:54:49 <Cale> :D
11:54:53 <danharaj> oh caleskell
11:54:55 <danharaj> how we love you so
11:54:55 <dimka> clahey: yes, but http://hpaste.org/75829
11:54:56 <ksf> downcast objects to an interface.
11:54:58 <maukd> apple_user: define "non-functional language"
11:55:07 <apple_user> a language like C
11:55:13 <maukd> that's not a definition
11:55:17 <ksf> ...at the same time bundling them up with the appropriate vtables.
11:55:17 <clahey> apple_user: It's possible in C++.
11:55:17 <maukd> every language is like C
11:55:21 <Clint> c has lots of functions
11:55:50 <Cale> Most C "functions" aren't functions.
11:55:52 <ksf> ...that is, in the same way that haskell can do it with existentials.
11:55:59 <maukd> #define FLIP(F) F FLIP_
11:56:06 <maukd> #define FLIP_(X, Y) (Y, X)
11:56:12 <maukd> // super untested
11:56:15 <apple_user> wow
11:56:29 <danharaj> Cale: I don't think that generalization should bear the name 'flip' :P
11:56:48 <Cale> danharaj: ski pointed it out to me and so I included it
11:58:15 <maukd> sub flip { my ($f) = @_; sub { $f->($_[1], $_[0]) } }
12:02:27 <clahey> template<class Type1, class Type2>
12:02:32 <clahey> sigc::slot<Type2, Type1>
12:02:37 <clahey> flip(sigc::slot<Type1, Type2> fun)
12:02:43 <clahey> {
12:02:46 <clahey>   return sigc::group(fun, sigc::_2, sigc::_1);
12:02:46 <clahey> }
12:03:34 <clahey> / Totally untested, but should actually work and be type safe.
12:03:38 <clahey> // Totally untested, but should actually work and be type safe.
12:04:14 <maukd> what is sigc?
12:04:26 <byorgey> It doesn't work, you have a lexical error around "/ Totally ..."
12:04:29 <byorgey> ;-)
12:04:48 <maukd> and why does this template have two parameters?
12:05:17 <clahey> I'm pretty sure there's a way to do it with std since C++11.
12:05:20 <byorgey> @type flip
12:05:20 <tdammers> wait hold on, what happened? C++?
12:05:21 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
12:05:31 <byorgey> @type P.flip
12:05:32 <lambdabot> Couldn't find qualified module.
12:06:13 <clahey> maukd: The same reason @type flip has a and b?
12:06:21 <maukd> :t Prelude.flip
12:06:23 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
12:06:25 <maukd> clahey: a b c
12:06:34 <jfischoff> how should I convert a bytestring to cstring of hexadecimal printed characters?
12:06:35 <clahey> Oh.
12:06:45 <clahey> Right.  It should have 3 parameters.
12:07:18 <jfischoff> printf and then convert the string to a cstring?
12:07:24 <clahey> template <class Type1, class Type2, class Type3> sigc::slot<Type1, Type3, Type2> flip(sigc::slot<Type1, Type2, Type3>
12:07:37 <clahey> That's what it should have been.
12:07:50 <clahey> I think...
12:09:24 <clahey> maukd: sigc is a library implementing functions as first class objects with a bunch of useful operations.
12:09:42 <clahey> But I guess the interesting point is that C++ is not a "non-functional" language.
12:09:47 <maukd> [#regex] <ViicT> Hi guys, we have an pseudo-code language at my work, and we are trying to get all text between two <!-- #if# --> <!-- #endif# --> we use PHP to parse it as it will generate an javascript file, we are trying with '/<!-- #if \(([a-zA-Z0-9\'\"\_]+) ([=|!|<|>]+) ([a-zA-Z0-9\'\"\_]+)\)# -->([^`]*?)<!-- #endif# -->/' but we don't want 2
12:09:52 <maukd>  inherit <!-- #if# --> how can we do this? (i've even treid lookahead and stuff)
12:10:58 * ksf prefers INTERCAL over C++. It's less obfuscated.
12:11:12 <clahey> dimka: I don't know the answer, but if you figure it out, I'd love to know.  I don't understand exceptions at all.
12:11:32 <dimka> clahey: catch (putStrLn "hello" >>= const (return True)) (\(SomeException _) -> return False)
12:11:39 <maukd> :t try
12:11:40 <lambdabot> Not in scope: `try'
12:11:45 <maukd> @hoogle try
12:11:45 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
12:11:45 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
12:11:45 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
12:11:58 <maukd> :t System.IO.Error.try
12:11:59 <lambdabot> forall a. IO a -> IO (Either IOError a)
12:20:52 <clahey> dimka: Would it work to do (const (return False) :: SomeException -> IO Bool)
12:23:11 <bfgun> i get a 'non exhaustive patterns' error, how can i see the data that triggered that?
12:23:17 <mroman> :t iterateM
12:23:18 <lambdabot> Not in scope: `iterateM'
12:26:15 <mroman> I don't really need replicateM
12:26:38 <ksf> bfgun, add a pattern.
12:26:39 <mroman> I don't want to generate a list with thousands of () in it.
12:26:46 <ksf> x -> error (show x)
12:27:13 <fmap> bfgun: -fwarn-incomplete-patterns
12:27:19 <fmap> or simply -Wall
12:27:34 <bfgun> awesome :)
12:27:54 <bfgun> i don't mind incomplete patterns, i wanted to see what was causing the error
12:28:09 <bfgun> found it :)
12:29:56 <fmap> @hackage monad-loops
12:29:56 <lambdabot> http://hackage.haskell.org/package/monad-loops
12:29:58 <fmap> mroman: ^
12:32:15 * hackagebot happstack-authenticate 0.9.5 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.9.5 (JeremyShaw)
12:33:17 <bfgun> how can i sortBy? (a->a->Ordering)->[a]->[a] ? (for using a non standard ordering function)
12:34:35 <bfgun> nevermind i just need to learn to understand what i'm saying
12:34:55 <bfgun> (found the function in hayoo but got confused :p
12:34:57 <bfgun> )
12:34:59 <theplanet> what does "5 /= 4" mean
12:35:16 <theplanet> apparently it is True
12:35:28 <Tordek> not-equal
12:35:44 <theplanet> oh
12:36:42 <mroman> It's slightly faster using my own iterateM than using replicateM
12:37:18 * hackagebot hpaco-lib 0.11.0.6 - Modular template compiler library  http://hackage.haskell.org/package/hpaco-lib-0.11.0.6 (TobiasDammers)
12:37:19 * hackagebot hpaco 0.11.0.6 - Modular template compiler  http://hackage.haskell.org/package/hpaco-0.11.0.6 (TobiasDammers)
12:37:51 <bfgun> i'm having trouble compiling the altfloat package, it complains about unsafePerformIO being called ambiguously
12:38:07 <hpaste> Melissa pasted “huffman” at http://hpaste.org/75831
12:39:27 <theplanet> what was melissa  trying to accomplish there
12:39:44 <theplanet> i'm trying to run the code she pasted there in the ghci
12:39:44 <theplanet> not working
12:40:55 <Tordek> on the one hand, you're missing half a function up there
12:41:10 <Tordek> what's mapsmallest?
12:44:13 <Tordek> Data.List.insert is missing an argument, I gather, theplanet. it takes a -> [a] -> [a], but you're passing it (Data.List.insert (mapsmallest x y) ts)
12:44:25 <Tordek> wait what
12:44:28 <Tordek> i'm a idios
12:44:31 <Tordek> nevermind
12:45:14 <theplanet> i dont know
12:45:30 <Tordek> no, I got that signature mixed up, sorry
12:45:38 <theplanet> how do i load a module
12:46:12 <theplanet> trying to figure out what this does https://github.com/chrisdone/hpaste/blob/master/src/Data/Maybe/Extra.hs
12:46:15 <Tordek> buildNode takes a list of HuffmanTree and... hypothetically... sorts it
12:47:34 <byorgey> theplanet: run ghci, then  :load "filename"
12:49:51 <theplanet> i don't seem to have module Data.Maybe.Extra
12:50:30 <Cale> theplanet: you give it a value of type Maybe t, and a function f which takes a value of type t and produces an action, and if the Maybe value was Nothing, then it just does nothing, but if the Maybe value is (Just x) it applies f to x and performs the resulting action.
12:50:45 <byorgey> theplanet: you wouldn't have it by default.  It is part of the source code of hpaste.
12:50:53 <byorgey> you can download it from that link you pasted.
12:50:54 <hpaste> Melissa pasted “huffman” at http://hpaste.org/75832
12:52:14 <theplanet> wonder if this latest mel paste runs
12:52:42 <byorgey> no, it doesn't
12:52:51 <shachaf> It's not even copied from the text editor properly.
12:52:59 <byorgey> the right side seems to be cut off with $ symbols
12:53:02 <jamiltron> Any emacs gurus in here? I'm getting an error in emacs when I try to run haskell-mode-stylish-buffer, saying that it cannot find stylish-haskell, even though its in my path.
12:53:03 * shachaf wonders why it uses Double for probabilities.
12:53:12 <mroman> ah.
12:53:24 <mroman> increasing the radius results in better precision.
12:53:51 <byorgey> jamiltron: was it in the path in whatever environment emacs was started from?
12:54:07 <Eduard_Munteanu> Grr, no preflex.
12:54:12 <byorgey> (I don't actually know if that makes a difference)
12:54:37 <Eduard_Munteanu> maukd: what happened to preflex?
12:54:51 <jamiltron> byorgey: I believe so. I'm just opening emacs under my usual user account. Any way to check for that?
12:55:34 <byorgey> jamiltron: should be fine then.  I don't really know.
12:55:50 <jamiltron> byorgey: Thanks for trying to help. I'll dig around some more.
12:55:55 <byorgey> jamiltron: you could look at the source code for haskell-mode-stylish-buffer to see what it is doing.
12:57:17 * hackagebot happstack-authenticate 0.9.6 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.9.6 (JeremyShaw)
13:00:31 <tac> @type join . join
13:00:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
13:00:34 <tac> @type join . join . join
13:00:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m (m a))) -> m a
13:01:56 <sanjoyd> @type fix join
13:02:00 <lambdabot>     Occurs check: cannot construct the infinite type: a = m a
13:02:05 <lambdabot>       Expected type: m (m a)
13:02:09 <lambdabot>       Inferred type: m a
13:02:16 <sanjoyd> Damn!
13:02:17 * hackagebot catch-fd 0.2.0.1 - MonadThrow and MonadCatch, using functional dependencies  http://hackage.haskell.org/package/catch-fd-0.2.0.1 (AndySonnenburg)
13:02:34 <shachaf> Oh, this is a fun error message.
13:02:35 <shachaf>     The function `fmap' is applied to five arguments,
13:02:43 <shachaf> but its type [...] has only six
13:03:30 <shachaf> This whole error message is great, in ghci 7.6.1: :t fmap fmap fmap join join join
13:04:51 <thoughtpolice> oh look, it's shachaf
13:04:59 <nejucomo> :t join
13:05:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:05:20 <shachaf> oh look, it's thoughtpolice
13:07:40 <dmwit> shachaf: strange
13:09:21 <shachaf> shachaf, adj.: strange
13:09:43 <ion> (shachaf, adj) .: strange
13:09:46 <ion> Fixed the syntax for you.
13:09:49 <dmwit> I think I'd call that a bug (even if it's a minor one).
13:10:05 <Cale> shachaf: ahaha
13:10:11 <shachaf> @ty fmap fmap fmap fmap fmap join join join -- just for thoughtpolice
13:10:12 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m (m a))) -> m a
13:10:16 <byorgey> someone should file a ticket with the subject "6 < 5"
13:10:35 <dmwit> You know the danger of the phrase "someone should"...
13:10:39 <shachaf> byorgey: Better get "<3" into it somewhere.
13:10:50 <ion> > 9000
13:10:51 <lambdabot>   9000
13:13:23 <ion> The speakers used a PA system but the Haskell Symposium videos were recorded with the camera mic. :-(
13:14:58 <byorgey> ion: oh, really?  that's too bad.
13:15:51 <byorgey> there was a sophisticated setup to capture the video from the slides being projected, I would have thought the same was being done with the sound
13:15:57 <byorgey> but perhaps not.
13:16:39 <pnielsen> oh, nice. If anyone's wondering where the vids are: http://www.haskell.org/haskell-symposium/2012/#schedule
13:16:47 <shachaf> Bah, this bug is really hard to narrow down.
13:17:14 <pnielsen> ah, they were on r/haskell too. I guess I'm not on reddit enough
13:21:56 <byorgey> pnielsen: it is impossible to not be on reddit enough.
13:22:50 <shachaf> Hah, this is funny.
13:22:55 <shachaf> g :: Functor f => f ~ (->) r => f (b -> c) -> f ((a -> b) -> a -> c)
13:22:59 <shachaf> g :: (r -> b -> c) -> (r -> (a -> b) -> a -> c)
13:23:06 <shachaf> You'd expect those to be the same, wouldn't you?
13:23:12 <shachaf> ghci gives the same :t for them.
13:27:25 <dimka> What name could have a `maybe (return False)` function?
13:27:31 <byorgey> shachaf: wait, why is it funny?  I don't get it.
13:28:06 <shachaf> byorgey: "g (.) undefined join join" gives the weird error message for one of them and not the other.
13:28:49 <byorgey> shachaf: ah, I see
13:29:13 <byorgey> so the types get printed the same with :t, but internally they are somehow represented differently
13:29:21 <bfgun> can i do something like this: (x:x':xs) = somelist ?
13:29:34 <shachaf> bfgun: Try it!
13:29:54 <shachaf> byorgey: Or maybe they're not completely simplified during type checking, or something.
13:29:55 <bfgun> dammit it is valid haskell :)
13:30:13 <byorgey> shachaf: right, maybe so
13:30:29 <gfredericks> is it roughly accurate to say that any function that does not return something of the IO type cannot possibly side-effect anything? (i.e., no hidden side-effects are possible)
13:30:29 <shachaf> With let j f x = f x x, it can be simplified down to fmap (.) (.) undefined j j
13:30:51 <shachaf> gfredericks: No function can cause side effects, including functions that return IO actions.
13:30:56 <byorgey> bfgun: declarations are always of the form  <pattern> = <expression>
13:31:12 <hpaste> “Jonathan Fischoff” pasted “Hash a C array and return to C” at http://hpaste.org/75836
13:31:30 <gfredericks> shachaf: yeah I had a hard time including that distinction in my question :)
13:31:58 <jfischoff> I'm curious what people think of one of my first adventures in writing a function that gets called from C here http://hpaste.org/75836
13:32:02 <bfgun> sure, but i never thought you could pattern match on assignment for some reason :)
13:32:09 <shachaf> gfredericks: Or, rather, the *evaluation* of any function won't cause any IO to happen.
13:32:13 <byorgey> gfredericks: to a first approximation, running IO actions is the only way to cause side effects.
13:32:17 <jfischoff> looking for any feedback good or bad
13:32:26 <shachaf> A function can return an IO action which can be executed (by the RTS), but that's a separate step.
13:32:41 <byorgey> gfredericks: but there is also ST.  And what counts as "side effects" depends on the point of view.
13:32:55 <gfredericks> ST?
13:33:11 <byorgey> The ST monad.  It's for localized mutable state.
13:33:24 <gfredericks> is this different from the state monad?
13:33:40 <hpc> yes
13:33:57 <byorgey> it is really honest-to-goodness mutable state. The State monad just "simulates" mutable state by passing the current state as an argument and returning a new state.
13:34:06 <hpc> ignore ST, it is fairly magical if you dont speak ghc
13:34:17 <byorgey> so is IO.
13:34:31 <byorgey> my point was just that there *are* other things that can cause side effects other than IO.
13:34:34 * gfredericks googles
13:34:42 <gfredericks> how popular is haskell prime?
13:35:11 <hpc> haskell prime is just the "report beta"
13:35:14 <bgamari> Where is the Crypto repository now kept?
13:35:21 <gfredericks> ST reminds me of clojure transients
13:35:27 <gfredericks> or at least the justification
13:36:05 <bgamari> I can find exactly zero references to Crypto on the web at this point
13:36:16 <hpc> @hoogle crypto
13:36:16 <lambdabot> package Crypto
13:36:17 <lambdabot> package crypto-api
13:36:17 <lambdabot> package crypto-api-tests
13:36:19 <bgamari> the two URLs I can find in the latest version tarball are both broken
13:36:27 <hpc> @hackage Crypto
13:36:28 <lambdabot> http://hackage.haskell.org/package/Crypto
13:36:45 <bgamari> hpc, Yes, I know
13:36:48 <hpc> oh, the repo
13:36:58 <bgamari> yep
13:37:08 <bgamari> the darcs repo is a 404
13:37:28 <shachaf> That's Haskell cryptography for you.
13:37:53 <hpc> https://github.com/wmoss/haskell-Crypto
13:37:56 <hpc> ?
13:38:20 <bgamari> hpaste, I think that's someone who took the tarball and created a repo out of it
13:38:31 <hpc> oh
13:38:47 <Clint> cryptocipher et al. get more love
13:39:13 <bgamari> Clint, Crypto is broken on ghc 4.6
13:39:19 <bgamari> I was hoping to get a patch upstream
13:39:28 <Clint> it was broken on 7.4 too
13:39:31 <bgamari> oh man
13:39:47 <maukd> ghc 4.6? o shi-
13:39:48 <bgamari> there are a hope string of packages that depend upon it
13:40:08 <bgamari> whole*
13:40:19 <Clint> they should switch
13:40:20 <bgamari> and I guess s/are/is/
13:40:26 <bgamari> to cryptocipher?
13:40:40 * Clint shrugs.
13:40:55 <shachaf> All the Haskell cryptography packages are bad. :-(
13:42:26 <bgamari> that is quite unfortunate
13:42:29 <bgamari> and a bit unexpected
13:43:15 <gfredericks> so I should forget my plans to do some crypto stuff with haskell in the near future?
13:43:53 <shachaf> Don't listen to me on this. I haven't used any of them.
13:44:03 <shachaf> I just didn't like what I saw much when I did look.
13:44:43 <Clint> gfredericks: no
13:56:51 <callen> tibbe: I mean, I'll do that, but I really shouldn't have to.
13:57:32 <tibbe> callen: the issue is that the error message doesn't tell me which version of network was picked
13:57:49 <tibbe> callen: this doesn't happen on my machine so I need to try to figure out the state of your machine
13:58:38 <zzo38> In attempting to make a hardware description alnguage with Haskell, called FamicomHDL, is this OK types to use?   type Mapper = ContT [Command] ((->) Int); data Command = Case Word8 (Word8 -> [Command]) | Command ByteString | Wire Pin Pin Connection | Part x => Part Int x;
13:59:26 <danharaj> Why use (->) Int instead of Reader Int?
13:59:32 <callen> tibbe: https://github.com/haskell/cabal/issues/1060
13:59:41 <shachaf> danharaj: Why use Reader Int instead of (->) Int?
13:59:47 <danharaj> Because sugar.
13:59:57 <zzo38> danharaj: It makes some functions simpler since no newtype wrapping.
14:00:02 <shachaf> danharaj: What sugar?
14:00:02 <danharaj> fair enough
14:00:23 <danharaj> shachaf: ask/asks
14:00:26 <zzo38> Why did I addressed to you?
14:00:38 <zzo38> Who was asking what...?
14:00:44 <maukd> > (do x <- asks sqrt; return (x + 1)) 4
14:00:45 <lambdabot>   3.0
14:00:45 <zzo38> Well, it doesn't matter.
14:00:51 <danharaj> :t asks
14:00:52 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
14:00:56 <danharaj> Ah, nevermind.
14:01:08 <maukd> > ask 'y'
14:01:09 <lambdabot>   'y'
14:01:14 <zzo38> If you do not need ReaderT, I don't know why you would ever use Reader for anything.
14:01:25 <danharaj> I didn't know ask(s) had a more general type.
14:02:08 <shachaf> If it didn't, you could just use the function you wanted instead.
14:02:16 <shachaf> > (do x <- sqrt; return (x + 1)) 4
14:02:17 <lambdabot>   3.0
14:02:22 <maukd> :t [ask, asks]
14:02:24 <lambdabot> forall r a. [(r -> a) -> r -> a]
14:02:30 <maukd> :t [ask, asks, ($), id]
14:02:31 <lambdabot> forall r a. [(r -> a) -> r -> a]
14:02:40 <maukd> THIS IS ALL THE SAME CRAP
14:02:53 <maukd> I PAID GOOD MONEY FOR THIS LIBRARY AND THIS IS ALL I GET?!
14:03:02 <zzo38> You could just as well use    type Mapper = Cont (Int -> [Command]);    but using ContT means there is no Identity wrapper so you can use the ContT constructor in a pattern directly, and with ContT you can also use lift (although I probably don't need it).
14:03:16 <hpc> maukd: bahaha
14:03:26 <zzo38> maukd: Using ask/asks is useful when you used the transformer ReaderT, and ($) is useful for infix application.
14:03:39 <maukd> > sqrt `ask` 2
14:03:40 <lambdabot>   1.4142135623730951
14:03:46 <rwbarton> :t [join, concat, msum, Data.Foldable.asum, mconcat]
14:03:47 <lambdabot> forall a. [[[a]] -> [a]]
14:04:03 <maukd> :t [join, head]
14:04:04 <lambdabot> forall a. [[[a]] -> [a]]
14:04:12 <hpc> :t [(.), id]
14:04:13 <lambdabot>     Occurs check: cannot construct the infinite type: a = f a
14:04:13 <lambdabot>       Expected type: f a -> f b
14:04:13 <lambdabot>       Inferred type: a -> b
14:04:17 <hpc> :(
14:04:34 <zzo38> But yes it does work, concat is just the monadic join operation on the list monad
14:04:52 <maukd> > (do x <- ask sqrt; return (x + 1)) 4
14:04:53 <lambdabot>   3.0
14:05:09 <zzo38> join and head differ but can be used with the same type.
14:05:51 <hpc> :t [ask, asks, ($), id, 15, sqrt, (+)] -- i take your ask and raise you a terrible Num instance!
14:05:53 <lambdabot>     Occurs check: cannot construct the infinite type: r = r -> a
14:05:53 <lambdabot>     Probable cause: `+' is applied to too few arguments
14:05:53 <lambdabot>     In the expression: (+)
14:06:03 <hpc> or not
14:06:14 <zzo38> Do you think the types I mentioned is OK for hardware description (FamicomHDL, specifically) in Haskell?
14:06:25 <maukd> :t [ask, 15]
14:06:26 <lambdabot> forall (m :: * -> *) r. (MonadReader r m, Num (m r)) => [m r]
14:06:50 <maukd> :t [ask, 15, id]
14:06:51 <lambdabot> forall a. (Num a) => [a -> a]
14:06:51 <danharaj> I'm not sure the constructor Part x => Part Int x does what you want.
14:07:03 <hpc> :t [ask, asks, ($), id, 15, sqrt]
14:07:04 <lambdabot> forall r a. (Floating a) => [(r -> a) -> r -> a]
14:07:09 <zzo38> danharaj: Then, what does it do?
14:07:24 <hpc> :t [ask, asks, ($), id, 15, sqrt, (<*>)]
14:07:25 <lambdabot>     Occurs check: cannot construct the infinite type: r = r -> a
14:07:25 <lambdabot>       Expected type: (r -> a -> b) -> r -> a -> b
14:07:26 <lambdabot>       Inferred type: (r -> a -> b) -> (r -> a) -> r -> b
14:07:46 <maukd> (<*>) is ap
14:08:06 <zzo38> Actually yes I think I done that constructor wrong sorry
14:08:07 <maukd> and ap is the opposite of =<<
14:08:16 <callen> why does cabal break everytime I try to go back to using Haskell again?
14:08:23 <zzo38> How is ap the opposite of =<<
14:08:26 <danharaj> I guess it does do what you want.
14:08:30 <danharaj> I was thinking of something else.
14:08:32 <callen> I end up having to pay this penalty for not keeping up with it or something.
14:08:53 <maukd> > ap (,) length "asdf"
14:08:54 <lambdabot>   ("asdf",4)
14:08:59 <maukd> > (=<<) (,) length "asdf"
14:09:00 <zzo38> But even ignoring the Part constructor, is it OK?
14:09:00 <lambdabot>   (4,"asdf")
14:09:18 <zzo38> maukd: OK
14:09:31 <danharaj> I'm not sure. I'm a bit distracted right now.
14:10:00 <applicative> callen what's wrong? or perhaps you were discussing it earlier
14:10:38 <danharaj> zzo38: you want a GADT by the way. That won't work as is.
14:10:53 <zzo38> danharaj: Yes I was thinking that too, I think you are very correct.
14:10:54 <applicative> callen do you have the same ghc you had the last time you were using haskell?
14:11:57 <callen> applicative: I was bringing up my errors earlier, I did a simple cabal update; cabal install cabal-install to bring everything up to date, and like every other time I seem to want to use cabal, it broke.
14:12:10 <callen> I seem to scarcely be able to install a package or update my existing ones without it falling apart
14:12:17 <callen> I don't think leiningen to my memory has *ever* broken
14:12:21 <callen> and I've used it more than cabal.
14:12:37 <zzo38> And then perhaps operations could be:   addPart x = ContT $ \f s -> Part s x : f s (succ s);   and so on.
14:12:42 <callen> I'm having a really, really hard time getting into Haskell if I'm going to have spend a bunch of time battling cabal just to get something to work
14:13:03 <callen> and this isn't even going into the issues I had parsing XML last time I wrote some Haskell code, holy hell that was bewildering.
14:13:15 <callen> monad transformers just so I can do the equivalent of a one-liner in jQuery's sizzle syntax?
14:13:27 <maukd> heh
14:13:33 <applicative> callen: doing cabal update after a long period (and then making some installs) is pretty dangerous.  cabal-install is trying to make the latest and greatest fit with what you have
14:13:36 <maukd> how is jquery simpler than monad transformers?
14:13:46 <callen> Don't get me wrong, I love monads, I use them in Python, but christ the entire library and language ecosystem seems designed to waste my time.
14:13:48 <zzo38> What does jQuery have to do with it?
14:13:56 <callen> zzo38: DOM/document querying.
14:13:59 <callen> zzo38: Sizzle.
14:14:09 <callen> zzo38: I wanted Sizzle-style document querying for XML
14:14:20 <callen> zzo38: or, failing that, a minidom-style parser
14:14:26 <callen> zzo38: or failing that, a SAX-style parser
14:14:44 <callen> instead I'm writing a parser combinator I don't understand just so I can extract some text from an XML document.
14:15:03 <zzo38> I use Parsec for parsing in Haskell, it works fine for me
14:15:03 <callen> applicative: I already submitted an issue, per somebody else's recommendation, for the cabal stuff.
14:15:11 <applicative> what xml library are you using
14:15:11 <callen> right uh, that's what I'm talking about.
14:15:34 <callen> this was awhile back, last time I wrote Haskell code. I can't tell you what's going on right now because cabal doesn't work.
14:16:01 <callen> if I recall, I was using TagSoup or HaXml.
14:16:16 <zzo38> Monad transformers can make up one monad from another using homomorphism, or (lift .) as a functor from one Kleisli category to another, perhaps.
14:16:19 <callen> in fact, I'm pretty sure it's HaXml because it seems to use that combinator pattern.
14:16:44 <callen> zzo38: I've heard this meme before, "monads are just monoids in the endofunctor category, what's the big deal?", thank you.
14:18:12 <zzo38> Actually I don't know what a endofunctor category is either; I know a category, I know a endofunctor, I know a monad, and I know a monoid, though (and a monad always is a endofunctor, including return and join operations satisfying certain laws)
14:18:52 <ksf> join is the monoid operation
14:18:56 <callen> the impression I've gotten from most other people I know that have some FP experience and spent time in Haskell is that it never seemed to become more productive than anything else they used. They could reach the point where they were getting things done faster than when they started, but they never surpassed what they could do in other languages.
14:19:25 <callen> this summary includes one guy that spent like 3 years working with Haskell full-time and trying to get fast/good at it. he never got any faster than he was in his side-languages.
14:19:48 <applicative> presumably the other languages have millions of users?
14:19:58 <zzo38> Perhaps it is true, and the reason perhaps is that they lack macros. It is one thing I wanted to make for Ibtlfmm programming language to include macros and that stuff, or perhaps even Haskell with these kind of macros would help too
14:19:59 <callen> not all, no.
14:20:01 <Cale> zzo38: Given any category C, we can form a category whose objects are the endofunctors C -> C
14:20:11 <zzo38> Cale: O, OK.
14:20:11 <applicative> anyway,  I think the xml  library is the going one http://hackage.haskell.org/packages/archive/xml/1.3.12/doc/html/Text-XML-Light-Input.html
14:20:14 <Cale> zzo38: and whose arrows a: F -> G are natural transformations
14:20:16 <callen> applicative: it was compared unfavourably with Clojure, Python, and others.
14:20:35 <callen> applicative: Erlang was described as being quirky but still having a faster flash-to-bang at the equivalent experience level, sometimes even when you have less.
14:20:36 <thoughtpolice> @seen edwardk
14:20:37 <lambdabot> Unknown command, try @list
14:20:49 <thoughtpolice> preflex: seen edwardk
14:20:49 <preflex>  edwardk was last seen on #haskell 5 days, 13 hours, 55 minutes and 28 seconds ago, saying: thats probably pretty painful, yes
14:20:53 <Cale> zzo38: This has a strict monoidal category structure using composition of functors as the monoidal operation on objects, and of course, the identity functor being the identity of that monoid.
14:20:56 <danharaj> e.g. `(Functor f, Functor g) => f a -> g a`
14:21:06 <applicative> I see callen he's an untyped kind of guy :)
14:21:07 <danharaj> (are natural transformations after you throw out bottoms because of parametricity)
14:21:28 <callen> applicative: I want to take advantage of a useful typesystem
14:21:58 <thoughtpolice> didn't lambdabot have @seen at one point? what happened to that?
14:22:01 <zzo38> Yes I can see how these are natural transformation , these things, now.
14:22:21 <callen> applicative: I really do, but if I can't get to be as productive or more so in Haskell I'm not going to be able to stick with it.
14:22:34 <applicative> callen I think if you dont find it pleasant, or strange and wonderful, or beautiful or otherwise attractive, I think it's not likely to work out well
14:22:53 <Cale> The 1000-mile view is that there's a way to generalise the definition of a monoid (being a set with an associative operation having an identity) to any monoidal category
14:22:57 <zzo38> callen: Do you think they would be better with the macros like you find in Lisp and Scheme and Forth?
14:23:15 <callen> zzo38: I think it'd be better with some libraries I can understand and a simpler way to comprehend what's going on.
14:23:34 <Cale> where instead of a distinguished unit element (which we look at as a map from a one-element set) 1 -> M, and multiplication M x M -> M
14:23:38 <callen> zzo38: the libraries seem to be demos for the author to show off how good they are at making ridiculous type hierarchies and structures rather than to solve problems.
14:23:38 * applicative only has real experience with macros in latex, what a hideous chamber of horrors
14:23:56 <zzo38> callen: I think the libraries help.
14:24:00 <Cale> we instead replace the Cartesian product with our monoidal operation on objects in our monoidal category
14:24:13 <applicative> callen: many of the libraries are like that, sure. sort of theoretical or illustrative
14:24:27 <callen> zzo38: I need to be able to import an xml library, query for a tag name, get a sequence of objects with the type "tag", recurse over them to get the text I want, and be fucking done with it.
14:24:28 <Cale> and the one element set (the "identity" for Cartesian product) with the identity object in our monoidal category
14:24:38 <callen> zzo38: what I do *not* need is to be assembling parser combinators
14:24:47 * ksf recommends http://dave.fayr.am/posts/2012-10-4-finding-fizzbuzz.html as an intro into haskellthink.
14:25:02 <Cale> So, in our category of endofunctors, this means we need natural transformations 1 -> T, where 1 is now the identity functor
14:25:07 <Cale> and T . T -> T
14:25:13 <Cale> where that's composition of functors
14:25:27 <zzo38> callen: You shouldn't need to be, if you already use the XML library, if you want to use something like   data XML = Tag TagName [XML] | Text String;   or something like that
14:25:32 <Cale> and so in Haskell, these are polymorphic functions a -> T a, and T (T a) -> T a
14:25:36 <zzo38> Cale: O, yes, and that is the one we have monads now
14:25:44 <Cale> and that looks like return and join now
14:25:46 <zzo38> I can understand it.
14:26:03 <Cale> and the laws for monoids in Set, actually carry over and give us the laws for monads
14:26:18 <dada_cetacean> what's wrong with the syntax in this function? listlength [] = 0; listlength x:xs = 1 + (listlength xs)
14:26:27 <Cale> dada_cetacean: missed parens around (x:xs)
14:26:31 <thoughtpolice> dada_cetacean: you need parenthesis around x:xs
14:26:34 <ksf> dada_cetacean, (x:xs)
14:26:37 <zzo38> data_cetacean: You need parehtneses
14:26:40 <Cale> :D
14:26:48 <ksf> quadrophonic!
14:27:11 <dada_cetacean> oh, herpaderp
14:27:14 <Cale> We're up to 950 users which apparently means that any beginner question is now answered by 4 people.
14:27:51 <dada_cetacean> forgot that ":" is also a function
14:28:00 <ksf> no it isn't, it's a constructor.
14:28:00 <shachaf>  @remember Cale We're up to 950 users which apparently means that any beginner question is now answered by 4 people.
14:28:06 <shachaf> The Return of Stereo
14:28:15 <ksf> mere functions cannot be matched against.
14:28:30 <shachaf> Cale: Remember the days of @quote stereo?
14:28:32 <zzo38> Yes : is a constructor, and a reserved word because : is considered uppercase
14:28:38 <shachaf> It was just dying off when I joined.
14:28:38 <Cale> shachaf: of course
14:28:47 <shachaf> Those were the days.
14:28:58 <thoughtpolice> heh
14:28:59 <Cale> Ben Lippmeier's talk at the Haskell Symposium was really good
14:29:07 <Cale> http://www.youtube.com/watch?v=YmZtP11mBho&feature=relmfu
14:29:11 <Cale> just watched it :)
14:29:27 <ksf> ...and there I was, hoping for a talk about disciple.
14:29:32 <Cale> also, Brent's talk made me smile.
14:29:44 <callen> zzo38: it doesn't seem to me, to be so much to ask to get something that can be understood and worked through smoothly. The experience of writing Haskell code is like jumping off a cliff into a pungee pit of spikes over and over until it suddenly compiles for arcane reasons you never understood to begin with.
14:30:08 <hpc> Cale: Welcome to #haskell, where your questions are answered in glorious 7.1 surround sound
14:30:19 <thoughtpolice> i've been meaning to watch Brent's talk
14:30:21 <Cale> It's really nice to see algebraic structures influencing the design of practical work
14:30:22 <zzo38> callen: As far as I know that is not the case. But, maybe if you learn the mathematics, and use GHCi for testing as well, then it can understand why.
14:30:26 <thoughtpolice> i also still haven't read his pearl in TMR either
14:30:39 <thoughtpolice> it's on a stack, i should move it to the top, it's only a few pages
14:30:41 <zzo38> At least, this is how I do it.
14:30:43 <shachaf> Which pearl?
14:30:45 <shachaf> Monoids?
14:30:56 <callen> zzo38: I don't want to learn mathematics, I want to write code. Monads can be used and understood independent of mathematics.
14:31:04 <callen> zzo38: why insist on the necessary parts?
14:31:07 <callen> unnecessary*
14:31:22 <zzo38> callen: Well, yes it can be used without mathematics but I do not think it can be understood without mathematics.
14:31:25 <thoughtpolice> shachaf: hmmmm, lemme find it
14:31:48 <Cale> callen: That's fine, and you can do that.
14:31:55 <ksf> a rough understanding of logic and lots of squinting suffice for understanding monads.
14:32:00 <ksf> oh, and humility.
14:32:02 <Cale> callen: But it's important to understand that the edge is fuzzy
14:32:08 <shachaf> Cale: You should come to Seattle this weekend!
14:32:12 <thoughtpolice> shachaf: oh, it wasn't in TMR, but here's the paper http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
14:32:21 <callen> Cale: except I can't, because I'm confronted with category theory to just use an XML library.
14:32:24 <ksf> understanding monads won't be an aha-moment. it will be a doh-moment.
14:32:29 <Cale> callen: Which XML library?
14:32:32 <callen> Cale: so I'm left scrambling to find a grad student just to parse some XML.
14:32:38 <callen> Cale: HaXml I believe is the culprit here.
14:32:40 <shachaf> thoughtpolice: OK, yep, monoids.
14:32:42 <shachaf> Read it!
14:32:43 <Cale> callen: whoa
14:32:44 <zzo38> callen: Then use a different programming language, there are a lot
14:32:46 <callen> Cale: It was an immense pain.
14:32:47 <Cale> what?
14:32:57 <zzo38> I do not always use the same programming language either
14:32:59 <Cale> What documentation were you reading?
14:32:59 <thoughtpolice> shachaf: VERY WELL, THEN
14:33:13 <callen> Cale: all of it.
14:33:15 <Cale> callen: Also, maybe consider hexpat-pickle
14:33:22 <zzo38> I use many programmning languages, including C, Haskell, Forth, 6502 assembly language, TeX, QBASIC, etc
14:33:24 <callen> Cale: I was scrambling to just get the damned text to extract from the XML document.
14:33:41 <ksf> TeX shivers me bones.
14:33:43 <shachaf> preflex: seen ddarius
14:33:43 <preflex>  ddarius was last seen on #haskell 5 days, 14 hours, 29 minutes and 6 seconds ago, saying: pnielsen: It mostly isn't.  To the extent that it is, it's equally related to Java.
14:33:47 <callen> Cale: I turned around and did it in Python with minidom in ~5 minutes after spending 6-8 hours bashing my head against that wall with Haskell.
14:34:00 <callen> Cale: you cannot begin to know the deep, all-consuming despair this gave me about Haskell.
14:34:00 <thoughtpolice> shachaf: tell me what happened to lambdabot @seen! i'm not crazy, imagining that feature, am i?
14:34:01 <Cale> If there's difficulty in understanding HaXML and HXT it's not because of the abstractions being used, it's really because XML is horrifyingly complicated if you really want to present it in an exacting way.
14:34:20 <shachaf> thoughtpolice: It was taken out because of Issues.
14:34:21 <zzo38> callen: Use Python if that is what you like, then; there are different kind of programming language different use
14:34:24 <callen> Cale: except I was able to extract what I wanted in Python in 5 minutes.
14:34:28 <callen> zzo38: i want a real type system.
14:34:30 <shachaf> thoughtpolice: Hey, you're the one writing Lambdabot 2.0, right?
14:34:32 <shachaf> You should add it in!
14:34:36 <thoughtpolice> shachaf: lol
14:34:37 <ksf> callen, try tagsoup.
14:34:38 <callen> zzo38: and I'd rather not build on Scala or a corpse like OCaml.
14:34:39 <monochrom> there are now a million xml libraries on hackage, and only one of them uses category theory, and that's HXT, not HaXML
14:34:45 <Cale> callen: Well, okay, what exactly were you trying to do?
14:34:48 <shachaf> thoughtpolice: (Seriously. If you wrote Lambdabot 2.0, Cale would switch to it.)
14:34:56 <hpc> thoughtpolice: ooh, lambdabot 2.0? i have a feature request
14:35:00 <thoughtpolice> i have no doubts :)
14:35:13 <hpc> "ability to compile with just cabal-install"
14:35:14 <callen> Cale: extract series of data from an XML document that contained things approximately to typed arrays.
14:35:21 <callen> Cale: the data itself being just text inside the tags.
14:35:23 <callen> that's. it.
14:35:25 <thoughtpolice> hpc: hahaha, you're telling me
14:35:27 <Cale> callen: Well, that doesn't sound too bad at all.
14:35:32 <thoughtpolice> i haven't compiled lambdabot in like, years
14:35:35 <Cale> I could certainly do that in 5 minutes :)
14:35:42 <callen> Cale: yeah except I spent ages trying to get it to work in Haskell and I never really got it working.
14:35:50 <Cale> I'm not sure that I'd use HaXML
14:35:59 <monochrom> you can use tagsoup in 5 minutes
14:36:00 <callen> Cale: well that's all well and good, but I know other Haskell users with a background similar to mine that had the same trouble I had.
14:36:09 <hpc> thoughtpolice: on a more serious note, add the duckduckgo api
14:36:21 <hpc> way handier than @google
14:36:29 <monochrom> but I'm not going to write code for you
14:36:31 <Cale> callen: okay, well, probably what we really need is more information on how friendly various libraries are going to be
14:36:33 <shachaf> Also, redo the whole module system.
14:37:00 <callen> Cale: that would be true. A "recommended for new people" list of libraries would be great.
14:37:06 <ksf> also, add a category-babble generator.
14:37:08 <Cale> callen: HaXML and HXT are big monsters that you might care to use if you were really concerned about every detail of the XML spec.
14:37:21 <callen> Cale: I never am.
14:37:28 <applicative> callen,, I don't see whats wrong with 'Text.XML.Light'
14:37:29 <ksf> ...and link it to @faq
14:37:41 <callen> applicative: I recall trying that one too.
14:37:41 <Cale> Yeah, so those aren't the ones you probably want. XML Light is one of the simpler ones.
14:37:52 <Cale> hexpat-pickle tends to be really nice
14:38:03 <callen> I tried XML.Light, that was vietnam too.
14:38:20 <Cale> heh
14:38:32 <monochrom> which package name has Text.XML.Light?
14:38:41 <Cale> http://hackage.haskell.org/package/xml-1.3.12
14:39:28 <Cale> callen: Do you still have the Python code?
14:39:42 <monochrom> that looks like 5 minutes
14:39:51 <thoughtpolice> shachaf: do i need to add ponies, as well?
14:39:58 <callen> Cale: aye, I do.
14:40:02 <monochrom> and uses no theory
14:40:10 <callen> Cale: want an example?
14:40:12 <applicative> with Text.XML.Light, getting what you want is a matter of reading the document with fmap parseXML . readFile , and then doing some stupid Data.List manipulations. I don't suppose it's all powerfoul
14:40:27 <Cale> callen: Yeah, if you want, I'll translate :)
14:40:30 <callen> Cale: http://dpaste.de/ayNwB/
14:41:04 <callen> Cale: [tags], [date_object], [string]
14:43:24 <callen> Cale: see why that's so attractive?
14:43:55 <Cale> um, I don't see how this is much different from what I'd write in Haskell
14:44:07 <Cale> I mean, the function names are a little different
14:44:19 <rwbarton> what is aggregate_times_for_layouts
14:44:22 <Cale> But otherwise, I'd be writing much the same thing using xml-light
14:44:39 <zzo38> There is many library in Haskell, for parsing, for XML, for LLVM, for graphics, for other stuff, but I find nothing for ephemeris!
14:44:40 <callen> Cale: nevertheless, the "UX" of writing Haskell cod emade it extremely difficult to figure out how to do in Haskell even for somebody who's done plenty of FP and Lisp, albeit not strong typed FP
14:44:42 <Cale> Yeah, I'm assuming that's some other part of callen's program
14:44:54 <callen> Cale: very little in the way "affordances" or indications that you were on the right path at any given time.
14:45:05 <zzo38> Ephemeris is one thing I want to use with Haskell programming.
14:45:25 <zzo38> Has anyone else wanting ephemeris in Haskell? I wondered.
14:45:36 <monochrom> findElements
14:45:41 <Cale> right
14:45:57 <callen> Cale: what may be instructive, is a time-series of efforts of a noobie (2-years-sparse-experience) making a stab at getting such a program to work, and watch what they get stuck on.
14:46:16 <callen> Cale: I'd be willing to attempt it again, and record the keystrokes or something.
14:46:22 <callen> or take snapshots of the code at each stopping point.
14:46:24 <atriq> Has anyone else tried to paste Haskell code onto Tumblr?
14:46:29 <monochrom> they get stuck in depth-first search. that's what they get stuck in. I already observed and knew.
14:46:41 <atriq> Or is that something so patently ridiculous only I would try it
14:46:46 <Cale> If you want, I'll explain how I'd approach this problem. Scanning quickly through the documentation of Text.XML.Light, I find:
14:46:55 <callen> Cale: it's also worth noting that I already write my code in a non-mutation oriented way, so it's not like I'm trying to circle a square peg in a pure language.
14:46:57 <Cale> findElements :: QName -> Element -> [Element]
14:46:57 <Cale> Find all non-nested occurances of an element. (i.e., once we have found an element, we do not search for more occurances among the element's children).
14:47:11 <callen> Cale: I was using findElements in my last attempt
14:47:14 <Cale> which sounds like what we need
14:47:21 <callen> Cale: finding it is fine, getting it to work and extracting the data was the hard part.
14:47:24 <Cale> So in order to use this I need a QName
14:47:28 <Cale> and an Element
14:47:33 <Cale> So if I click on QName
14:47:34 <callen> QName I got stuck on for a bit.
14:48:09 <callen> Cale: I got pretty far in terms of getting it to work, it was just kidney-rupturingly painful and I couldn't close the proverbial loop and get something that was production-ready.
14:48:18 <callen> it also took 8 hours.
14:48:25 <Cale> I see that to make a QName, there might be some better way, but at the very least, I can apply this QName constructor to a String and some Maybe Strings for the URI and Prefix
14:48:47 <Cale> QName "time-layout" Nothing Nothing
14:48:47 <rwbarton> hayoo String -> QName suggests unqual
14:48:51 <Cale> aha
14:48:58 <Cale> So there really is a better way :)
14:49:00 <callen> right uh, I'd gotten that far.
14:49:04 <callen> that's not the point.
14:49:17 <callen> it might be easier to guide this on the basis of the snapshotting/voyeur thing
14:49:20 <Cale> Now I need to get an Element, and presumably from parsing my XML
14:49:21 <monochrom> then the next question is what rwbarton said
14:49:30 <callen> I'm trying to tell you
14:49:32 <Cale> parseXMLDoc :: XmlSource s => s -> Maybe Element -- looks about right
14:49:33 <callen> that i already overcame these parts
14:49:36 <callen> seriously.
14:49:42 <zzo38> Do you know anything about ephemeris please?
14:49:47 <rwbarton> well your paste doesn't have anything else in it
14:49:49 <monochrom> ok, so it is not an XML problem
14:49:52 <Cale> what are the instances of XmlSource? Clicking that, String is in there
14:49:55 <rwbarton> so maybe show us some more relevant python code?
14:50:09 <Cale> so I can apply  parseXMLDoc  to the contents of my XML file
14:50:24 <callen> rwbarton: I'd rather just reprise my Haskell attempt.
14:50:48 <Cale> and then case on whether it parsed, and use findElements (unqual "time-layout")
14:50:50 <rwbarton> sounds good
14:50:56 <Cale> on the result
14:50:58 <callen> but i'm telling you
14:51:00 <Cale> not so bad
14:51:03 <callen> if I do, there will be blood and tears.
14:51:05 <callen> and sorrow.
14:51:09 <callen> my cabal doesn't even work right now.
14:51:10 <callen> remember?
14:51:12 <rwbarton> well with that attitude sure
14:51:15 <callen> I can't even compile if I wanted to.
14:51:20 <callen> rwbarton: tell that to my fucking cabal.
14:51:27 <callen> rwbarton: I had to file an issue on github.
14:51:35 <Cale> callen: What platform are you on?
14:52:05 <callen> and now I just sit here with a broken haskell install because some network library I don't understand is broken.
14:52:08 <callen> Cale: Mac OS X
14:52:15 <callen> Cale: https://github.com/haskell/cabal/issues/1060
14:52:54 <callen> Cale: cabal breaks *every* time I come back to Haskell after a break.
14:52:56 <callen> invariably.
14:53:16 <Cale> oh, you apparently have an at least mostly working cabal install and the upgrade fails?
14:53:45 <callen> Cale: oh who even knows. I'll make a stab at the XML parsing thing again in a few hours.
14:53:55 <callen> if I can build the project, I can at least do that.
14:53:59 <aristid-ipad> callen: why do you always come back if it is so painful that you ivariably launch into a tirade?
14:54:08 <callen> aristid-ipad: I want a real type system.
14:54:20 <callen> Scala is contemptible, OCaml is run by frogs.
14:54:33 <callen> so here I am, 2 years of occaisional battle.
14:54:52 <Cale> cabal --version
14:54:57 <monochrom> my understanding is that you are past the XML parsing problem. you have already got elements of the tag name of your choice.
14:55:06 <callen> cabal-install version 0.14.0
14:55:13 <Cale> That's the one I'm presently using
14:55:16 <Cale> just stick with that one
14:55:28 <callen> I was instructed to upgrade by an instal.
14:55:29 <callen> install*
14:55:35 <callen> am I to mistrust cabal?
14:55:44 <Cale> oh, what were you installing?
14:56:09 <monochrom> I am not going to argue whether "there is a new version. to upgrade: ..." is informative or normative
14:56:19 <callen> Cale: I don't remember anymore.
14:56:43 <aristid-ipad> monochrom: i appreciate knowing what you will not argue
14:56:59 <callen> aristid-ipad: chillax.
14:57:07 <Cale> callen: Versions of cabal-install are tied to specific versions of the Cabal library, which in turn are pretty much tied to specific versions of GHC, unless you're weird.
14:57:17 <rwbarton> lol
14:57:24 <aristid-ipad> callen: ? i am relaxed and smiling
14:57:28 <imphasing> callen: just get good bro
14:58:07 <zzo38> Does anyone on here astronomy and/or astrology perhaps knows about ephemeris?
14:58:08 <Cale> callen: So the best thing to do if you already have a working cabal-install, is just to leave it. If something seems to require newer libraries than you have, then it may very well be the case that it was meant to work with GHC 7.6.1
14:58:17 <callen> imphasing: it would be nice if Haskell could be gotten into without a huge amount of upfront research.
14:58:21 <monochrom> but I am arguing that you are past XML parsing problems. perhaps I shouldn't argue that either.
14:58:24 <zzo38> (Including geometry and physics involved in ephemeris)
14:58:31 <Cale> (and choosing an older version of the package would be better then)
14:58:40 <imphasing> you call a parsing function, iterate document tree
14:58:43 <imphasing> BAM
14:58:58 <Cale> zzo38: LOOOOOL astrology
14:59:36 <zzo38> Cale: Do you know ephemeris? If you know, can we make up the Haskell program for ephemeris someone who does know?
15:00:01 <Taslem> What is the time-complexity of the !! operator?
15:00:09 <aristid-ipad> monochrom: the safest position is to argue nothing at all. but that'd be too boring, so compromise is needed ;)
15:00:11 <monochrom> exponential
15:00:20 <Cale> Taslem: xs !! n takes O(n) steps to reduce
15:00:21 <gfredericks> Taslem: I expect linear
15:00:21 <zzo38> Taslem: I guess, whatever the number on the right is.
15:00:23 <maukd> O(n^1)
15:00:30 <theplanet> zzo38, wtf? make up??
15:00:37 <Taslem> Okay, just checking.
15:00:43 <gfredericks> hey that "four answers" thing came up again
15:01:04 <zzo38> theplanet: Do you know of ephemeris? How to make it with Haskell?
15:01:31 <zzo38> Or, do you mean elsewhere?
15:01:34 <theplanet> zzo38, it can be done with haskell
15:01:37 <theplanet> maybe it has been done already
15:01:50 <zzo38> theplanet: Yes I know it can be done, but I have not find it has been done already.
15:02:23 <theplanet> what ´kind of features do you want in it?
15:02:59 <theplanet> somethign like http://tech.groups.yahoo.com/group/swisseph/message/293
15:03:57 <zzo38> theplanet: Well, at basic form, have something to ask for the object wanted, and get the XYZ coordinates for the center, the pole, and the zero longitude/latitude, to calculate rotation; and then from that, add on physics, coordinate transformation, tropical/sidereal/J2000, spherical geometry, speed of light, nutation, ecliptic/equatorial, etc
15:04:09 <zzo38> Is this OK?
15:04:31 <Cale> zzo38: Looking at this, the main difficulty in parsing these files is just going to be interpreting the data in various ways and doing the geometry. The file formats used by the JPL are very simple.
15:05:41 <zzo38> Cale: Yes OK, but JPL ephemeris seems to only have the center of planets, not the rotation, or other objects such as asteroids and dwarf planets (except Pluto) and so on
15:06:57 <zzo38> But the other data I wanted to include is artificial satellites, and apparent diameters of objects, fixed stars, custom orbits, etc
15:07:31 <Cale> Well, find a file format you want to parse :)
15:07:38 <theplanet> why must it be haskell?
15:08:10 <Cale> You're unlikely to find Haskell code for this. I haven't seen any astronomical software in Haskell, anyway.
15:08:24 <Cale> But there's plenty of good stuff for parsing.
15:09:26 <zzo38> Because I wanted to do with Haskell; with C I can find some stuff but even then seem to miss some things; but I want to do calculation with in Haskell, we can make one and then there will be an astronomical software library in Haskell.
15:09:50 <Cale> zzo38: You might consider just doing some FFI to one of the C libraries
15:11:52 <Cale> zzo38: Depending of course on how complicated it really is
15:11:52 <zzo38> Cale: Yes I did once consider that, but even then, one C library I found, include many objects but lack measuring the rotation of objects, and so on
15:12:11 <t7> can i have multiple .cabal files in one directory
15:12:22 * hackagebot package-o-tron 0.1.0.0 - Utilities for working with cabal packages and your package database  http://hackage.haskell.org/package/package-o-tron-0.1.0.0 (JakeWheat)
15:13:27 <Cale> t7: good question
15:13:31 <Cale> t7: I've never tried that
15:13:50 <zzo38> I would think, have one function to calculate geometric rectangular coordinates for center/equator/pole and the velocity of all three, and then another file uses that to calculate all the geometry, for recentering, spherical, intersections, speed of light, precession, nutation, aberration, houses, and whatever
15:19:23 <alpounet> tibbe, any reason why parseURI doesn't like [ and ] in URIs ?
15:20:03 <shachaf> alpounet: I don't think that's valid in a URI.
15:20:18 <alpounet> wget, my browser etc do accept it though
15:20:33 <shachaf> Yes, but the spec doesn't.
15:20:38 <rwbarton> the curse of Postel
15:21:00 <shachaf> The Postel service.
15:21:10 <sfogarty> @hoogle (a -> b -> Maybe c) -> Maybe a -> Maybe b -> Maybe c
15:21:10 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
15:21:10 <lambdabot> Data.Foldable foldrM :: (Foldable t, Monad m) => (a -> b -> m b) -> b -> t a -> m b
15:21:28 <sfogarty> No, that's not quite right
15:21:37 <sfogarty> Is there a clean way to do double-monad-binding like that?
15:21:58 <shachaf> I don't think that's in the standard library.
15:22:04 <maukd> :t join .: liftM2
15:22:06 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
15:22:06 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
15:22:06 <lambdabot>     In the second argument of `(.:)', namely `liftM2'
15:22:09 <stepcut> how can i tell if I have 32-bit or 64-bit ghc installed on OS X?
15:22:10 <shachaf> But you can do that.
15:22:11 <zzo38> And then I suppose from these thing you could calculate how much is obliquity of the ecliptic, so you know the tropics.
15:22:21 <shachaf> @ty (join .) .: liftM2
15:22:22 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
15:22:31 <shachaf> stepcut: ghc --info
15:22:36 <sfogarty> Ah, yes, thanks
15:23:04 <stepcut>  ,("Ld Linker flags","[\"-arch\",\"i386\"]")
15:23:17 <typoclass> alpounet: i think it'll not be very difficult; you just have to add a call to the function for url encoding. if you don't have one handy, i think the web-encodings package has one
15:23:22 <sfogarty> @ty liftM
15:23:24 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:23:25 <shachaf> stepcut: It doesn't have a "target arch"?
15:23:29 <alpounet> typoclass, tried that
15:23:41 <stepcut> ,("target arch","ArchX86")
15:23:42 <alpounet> hm
15:23:42 <alpounet> wait
15:24:01 <shachaf> stepcut: Looks 32-bit.
15:24:04 <stepcut> k
15:24:20 <alpounet> typoclass, yeah doesn't seem to work
15:24:33 <stepcut> I think I am having trouble install magic because libmagic is built for x86_64, but ghc is building for i386
15:24:46 <alpounet> typoclass, parseURI $ urlEncode "http://foo.com/bar[baz]"  returns Nothing
15:25:08 <sfogarty> hunh. Why does liftM expect an a1 -> r, but liftM2 expects an a1 -> a2 -> m r?
15:25:22 <zzo38> (Even if you do not know the obliquity of the ecliptic directly, you can convert ecliptic coordinates (the tropics are named after the coordinates you need) into equatorial, to figure it out; but it would probably be better to have it calculated directly.)
15:25:36 <maukd> sfogarty: what?
15:25:37 <rwbarton> sfogarty, liftM2 doesn't expect an a1 -> a2 -> m r
15:25:40 <sfogarty> @ty liftM2
15:25:41 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:25:43 <sfogarty> Well that would be why
15:26:19 <shachaf> This is just a generalization of m >>= f = join (liftM f m)
15:26:50 <sfogarty> Aah
15:27:01 <rwbarton> that was the point of the 'join'
15:27:22 * hackagebot tls-extra 0.4.7 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.4.7 (VincentHanquez)
15:27:57 <sfogarty> @ty (join . liftM2)
15:27:58 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (a2 -> a2 -> r) -> m a2 -> m r
15:28:32 <zzo38> @ty join .: fmap
15:28:33 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
15:28:57 <sfogarty> ... what is .: ?
15:29:09 <alpounet> f .: g = (f .) . g
15:29:23 <alpounet> (f .) . g = \x y -> f (g x y)
15:29:28 <rwbarton> "f .: g = compose the two-argument function g with the one-argument function f"
15:29:44 <rwbarton> due to currying you have to jump through these extra hoops
15:29:44 <sfogarty> aha
15:30:27 <zzo38> You could say the definition of (=<<) is to be (join .: fmap) but you could also say (=<<) act as a functor from a Kleisli category.
15:31:22 <sfogarty> where is .: defined? Hoogle doesn't seem to find it
15:31:29 <typoclass> this may sound silly, but given an installed module, how do figure out which package offers it?
15:31:33 <maukd> sfogarty: lambdabot
15:31:48 <zzo38> sfogarty: Prelude.Generalize defines it but other packages might have it too.
15:32:08 <rwbarton> typoclass: ghc-pkg find-module
15:32:13 <typoclass> sfogarty: afaik it's not in the standard library (yet)
15:32:20 <typoclass> rwbarton: thank you
15:32:40 <zzo38> Therefore use it in the non-standard library, or just define it yourself in your program
15:32:59 <rwbarton> @type (.::)
15:33:01 <lambdabot> Not in scope: `.::'
15:34:26 <theplanet> zzo38, will you write a haskell ephemerides
15:34:38 <shachaf> @let (.::) = (.:).(.)
15:34:40 <lambdabot>  Defined.
15:34:48 <shachaf> @let (.:::) = fmap fmap fmap fmap fmap fmap fmap
15:34:50 <lambdabot>  Defined.
15:34:50 <theplanet> shachaf, what the hell is that
15:34:58 <zzo38> theplanet: I should try, but I don't know everything about it to do; I am not a astronomer.
15:35:32 <shachaf> @nixon
15:35:33 <lambdabot> It is necessary for me to establish a winner image. Therefore, I have to beat somebody.
15:35:35 <zzo38> That is why, people should work together to make it.
15:35:55 <theplanet> zzo38, i dont know either
15:36:03 <Shapeshifter> How can I modify a value I "get" using "<-" before storing it in a variable? E.g. this is wrong: let apps = sort $ merge <- sequence $ map getDirectoryContents paths
15:36:09 <bfgun> @shachaf
15:36:09 <lambdabot> Unknown command, try @list
15:36:12 <theplanet> do you imagine it to be more accurate than the jpl ephemeris?
15:36:18 <theplanet> @list
15:36:18 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:36:32 <zzo38> theplanet: JPL ephemeris seems to lack much of the features I was looking for, though.
15:36:35 <Shapeshifter> but what I want is to run sort $ merge on the list returned by <- before saving it to apps.
15:37:14 <zzo38> Shapeshifter: Is it in a do-notation?
15:37:30 <applicative> Shapeshifter: do list <-  <- sequence $ map getDirectoryContents paths; return $ sort $ merge list
15:37:37 <applicative> Shapeshifter: or the like...
15:37:39 <typoclass> Shapeshifter: i recommend having one line with "foo <- sequence $ map ..." and on the next line have "let bar = sort $ merge foo"
15:37:45 <zzo38> You can also use <$>
15:37:59 <applicative> like typoclass said rather than my dim return
15:38:01 <Shapeshifter> zzo38: yes. I can do temp <- sequence $ map getDirectoryContents paths; let apps = sort $ merge temp but that seems unnecessary.
15:38:25 <madisson> hi guys... i have 1 problem related with my server on linux
15:38:26 <zzo38> Shapeshifter:   apps = sort . merge <$> map getDirectoryContents paths;
15:38:43 <zzo38> Shapeshifter:   apps = sort . merge <$> sequence (getDirectoryContents <$> paths);
15:38:45 <applicative> that cant be quite right
15:38:47 <zzo38> Oops!
15:39:07 <zzo38> Shapeshifter:   apps <- sort . merge <$> sequence (getDirectoryContents <$> paths);     I think is it.
15:39:42 <Shapeshifter> zzo38: nice, thanks. applicative!
15:41:39 <madisson> samp03svr: amx/amxfile.c:222: fputs_cell: Assertion `fp!=((void *)0)' failed.Aborted
15:41:46 <madisson> any idea whyy?
15:41:47 <madisson> :(
15:42:10 <zzo38> It is what the <$> (the infix operator for fmap) does, for endofunctors and all monads is endofunctors so it works.
15:43:18 <maukd> madisson: how is that a haskell question?
15:43:30 <typoclass> madisson: hello, this channel is about the programming language haskell. i'm not sure what your error message refers to, but i think it doesn't have anything to do with haskell
15:43:56 <madisson> im sorry
15:44:00 <madisson> do you guys know where i can ask
15:44:06 <madisson> slackware related question
15:44:30 <maukd> madisson: how is that a haskell question?
15:44:35 <applicative>    madisson /join slackware  ?
15:45:01 <applicative> madisson: they're chatting away I see
15:45:03 <madisson> applicative already in but seems that all are busy
15:45:07 <typoclass> madisson: not sure; look around on the slackware homepage if they talk about an irc channel, or google for "slackware irc channel" or some such
15:46:39 <yw0> hello, has anybody here used K semantic framework?
15:53:11 <typoclass> alpounet: anyway, i looked around a little what i have installed, and http-types has an urlEncode function that seems to work for me http://hackage.haskell.org/packages/archive/http-types/latest/doc/html/Network-HTTP-Types.html#v:urlEncode i used «urlEncode True $ pack "http://whatever[abc]"» with Data.ByteString.Char8 imported. not sure if that's really the way to go ...
15:54:56 <Quantumplation> So, i'm simulating combat in a small game.  two players have a certain number of ships, and each player also has a weapons research level.  The combat proceeds in rounds, and in each round one player does their weapons research level amount of damage to the other, destroying that many ships.  I've got a solution that works, but it's kind of ugly.  Can anyone come up with a nice, haskelly way to implement this?
15:55:15 <alpounet> typoclass, so parseURI likes "http://foo.com/bla[baz]" with that?
15:56:04 <Quantumplation> combat :: (Int, Int) -> (Int, Int) -> Either Int -- (techlevel, ships) -> (techlevel, ships) -> Either remainingships is what i've come up with for the type signature
15:56:14 <Quantumplation> Either Int Int
15:56:57 <typoclass> alpounet: haven't tried, but it produced stuff like "foo.com%2Fbar%5Bbaz%5D", i.e. it encoded the []s to %5B and %5D. you'd probably have to take care only to encode the part after the host ("bla[baz]" in your example)
15:57:18 <alpounet> typoclass, yeah i'll work around my problem with that
16:06:34 <Luke> anyone have experience statically linking against libcurl? I'm getting all these undefined references when I try
16:08:21 <nwf> In the new ConstraintKinds world, (Constraint,Constraint) is Constraint, yes?  Is it possible to build terms like the former in TH and have it work?  (Using Tuples results in "Predicate used as a type", while using Promoted Tuples results in "Type of kind (,) Constraint Constraint used as a constraint")
16:09:05 <rwbarton> I don't think (Constraint,Constraint) is Constraint
16:09:21 <rwbarton> but if x :: Constraint and y :: Constraint then (x,y) :: Constraint
16:09:28 <nwf> Sorry, yes, that's what I meant.
16:09:39 <rwbarton> hmm
16:10:20 <nwf> Oh, maybe I don't need TH for this... just a moment.
16:11:58 <nwf> Indeed, writing it out works.  Sorry for the noise. :)
16:22:48 <Quantumplation> hrm... I need to combine fold and takeWhile in some way.  i need to loop over elements, summing up some property of them (which varies from element to element) and then take the list only up until that sum exceeds a certain value.  is there a built in function to do this, or should I write it myself?
16:23:46 <rwbarton> sounds like you want some kind of scanl + takeWhile
16:32:19 <alpounet> typoclass, alright, managed to get it to work
16:32:30 <alpounet> with http-types' urlEncode
16:32:31 <alpounet> thanks!
16:32:40 <typoclass> alpounet: good to hear :) you're welcome
16:41:04 <gabor> rwbarton: random q. when I define an instance Cl (x,y), (x,y) being a constraint, then will it be recognized as the instance on (y,x) also? I.e. are permutations/repetitions canonicalized away?
16:42:39 <hpaste> ronwalf pasted “Hurk (segfault with floor)” at http://hpaste.org/75843
16:43:10 <ronwalf> Lord, that segfault hurts
16:43:38 <ronwalf> Can anyone else reproduce it?
16:44:01 <shachaf> Nope.
16:44:05 <shachaf> Not in 7.6.1 or 7.4.1
16:44:08 <avpx> I'm on 7.4.1, and nope
16:44:20 <ronwalf> I'm just extra special
16:44:33 <ronwalf> (OSX 10.8.2)
16:44:46 <shachaf> Does someone here have 7.4.2?
16:45:00 <typoclass> could that be some kind of gmp issue? or possibly 64-bit issue?
16:45:38 <ronwalf> typoclass: Whatever it is, it's ghci specific (doesn't happen in the compiled code)
16:46:11 <typoclass> ronwalf: that is ... certainly interesting
16:46:47 <ronwalf> oh, it happens on 7.4.1 on my machine, too
16:49:17 <ronwalf> Also segfaults for ceiling and round
16:49:35 <ronwalf> Maybe I should just nuke this laptop from orbit
16:50:41 <ronwalf> It's AppleCare's revenge
16:52:33 <ronwalf> Aha, properFraction segfaults returning the fractional part
16:53:25 <shachaf> Sounds like something is rather messed up.
16:53:27 <geekosaur> so I have 7.4.1 64bit on 10.7.5 and no coredump
16:54:26 <typoclass> ronwalf: have you tried rebooting? (no seriously)
16:55:42 <hpaste> “Eduard - Gabriel Munteanu” pasted “Traced monoidal categories” at http://hpaste.org/75844
16:55:57 <ronwalf> typoclass: Here goes.  If my laptop doesn't reboot and I have to until Monday for the help desk, I'm blaming you :)
16:56:24 <shachaf> Maybe a bit got flipped in your page cache somewhere!
16:56:24 <Eduard_Munteanu> Is there a more interesting traced monoidal category I can construct in Haskell? Anybody played with this stuff? http://hpaste.org/75844
16:56:26 <shachaf> I read about that once.
16:56:44 <Eduard_Munteanu> (assuming I got the definitions right)
16:57:08 <absence> does anyone know of a currently working way to get audio output from haskell in windows? portaudio crashes, and jack-bindings doesn't build
16:57:32 * Eduard_Munteanu summons minions of category theorists!
16:58:18 <Eduard_Munteanu> I wonder if it's a useful abstraction for arrows / FRP / younameit.
16:59:55 <rwbarton> I thought a more traditional definition for tr for (->) would be let (b, u) = f (a, u) in b
17:00:50 <hpaste> Luke pasted “Static Linking” at http://hpaste.org/75845
17:00:50 <Eduard_Munteanu> Hm.
17:01:18 <Luke> ^^ can anyone help with some static linking issues? paste above
17:01:24 <rwbarton> there's also the category of vector spaces, if you can encode that somehow
17:01:26 <Eduard_Munteanu> rwbarton: right, but mine isn't any less defined is it?
17:01:43 <rwbarton> it looks less defined
17:01:46 <Eduard_Munteanu> Hm, I'll think of that.
17:02:17 <Eduard_Munteanu> Yeah, I think you're right.
17:02:40 <rwbarton> e.g. f (a, u) = (u, a : u)
17:02:44 <cornihilio> hello everyone! I'm trying to get this code using attoparsec to work, but I'm not sure if it will. could you perhaps please help me?: https://gist.github.com/3843154. Basically, as it's parsing a packet, it fails, but I don't know where to put in the extra call for count when it fails, or more importantly, how I'm supposed to tell the difference between returning nothing because of a parse error and nothing for finding the end of the
17:02:44 <cornihilio> stream.
17:02:57 <rwbarton> er
17:03:16 <rwbarton> oh yeah that's fine
17:03:38 <typoclass> Luke: if you have ghc 6: have you tried passing --make to ghc?
17:03:48 <rwbarton> > let tr f a = let (b, u) = f (a, u) in b in tr (\~(a, u) -> (u, a : u)) 'x'
17:03:49 <lambdabot>   <no location info>: parse error on input `->'
17:03:55 <rwbarton> > let tr f a = let (b, u) = f (a, u) in b in tr (\(~(a, u)) -> (u, a : u)) 'x'
17:03:57 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
17:04:04 <rwbarton> > let tr f a = let (b, u) = f (a, u) in b in tr (\(a, u) -> (u, a : u)) 'x'
17:04:05 <lambdabot>   "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
17:04:10 <Eduard_Munteanu> Cool, that's actually a working definition.
17:04:22 <Luke> typoclass: how can I do that with cabal?
17:04:32 <Luke> typoclass: i've seen that in my googling but didn't know how it'd apply
17:04:49 <Eduard_Munteanu> rwbarton: has this stuff been studied in functional programming?
17:05:21 <rwbarton> I don't know
17:05:39 <typoclass> Luke: i think if you're using cabal, you're fine :) are you sure you have libcurl installed? i'm not really sure, i'm kind of guessing
17:05:58 <Luke> typoclass: definitely - it works with dynamic linking just fine
17:05:59 <Eduard_Munteanu> Thanks, I'll think of vector spaces, or other stuff now.
17:06:48 <rwbarton> for that you will need some DataKinds magic most likely
17:07:06 <Luke> typoclass: i've been looking at this: http://www.cs.virginia.edu/~wh5a/blog/Some%20GHC%20notes%20for%20myself.html
17:07:15 <typoclass> i wonder if it makes a difference that cabal is looking for libcurl.a while ldd is listing libcurl.so ...
17:08:27 <Luke> oh good eye
17:08:30 <Luke> that is weird
17:08:32 <hpaste> plhk pasted “Can I limit t to be a member of a typeclass?” at http://hpaste.org/75846
17:08:47 <Eduard_Munteanu> rwbarton: did you play with this stuff before? You used "traditional" above.
17:09:04 <rwbarton> well I think ArrowLoop has that definition
17:09:16 <Eduard_Munteanu> Hrm.
17:09:32 <rwbarton> instance ArrowLoop (->) where loop f b = let (c,d) = f (b,d) in c
17:10:01 <Eduard_Munteanu> Hah, so basically it's the same thing disguised under arrow terminology?
17:10:17 <rwbarton> Luke: this looks relevant to you http://curl.haxx.se/mail/lib-2007-05/0155.html
17:10:30 <Eduard_Munteanu> Though the theoretical origins of arrows are Freyd categories I thought.
17:10:47 <Eduard_Munteanu> I wonder if there's a relation between these things.
17:10:49 <typoclass> Luke: i bet it's some issue with dynamic vs. static linking. unfortunately i have little clue about linking and all that witchcraft. the link you pasted is very interesting, in the sense that it confuses me further :)
17:11:17 <geekosaur> mosrt of those missing symbols are from openssl.  some from sasl, some from heimdal (base and gssapi), and curl is missing stuff from libidn
17:11:35 <rwbarton> the link I pasted suggests "-lcurl -lidn -ldl -lz -static"
17:12:04 <typoclass> geekosaur: ah, is that what the stuff in parens means? "libcurl.a(strerror.o)"
17:12:05 <rwbarton> I guess only -lidn is needed perhaps
17:12:07 <rwbarton> plus other stuff
17:12:30 <geekosaur> that;s where the error was *found*; the missing symbols are of the form idn_* which are from libidn
17:12:49 <rwbarton> typoclass: that means the static library libcurl.a was formed by linking together several object files including strerror.o
17:12:58 <geekosaur> libcurl.a(strerror.o) means the object file strerror.o contained in the static archive libcurl.a
17:13:12 <typoclass> i see. thanks guys
17:13:15 <geekosaur> it *found* that, otherwise it would not be naming it there
17:13:33 <geekosaur> but that wants a symbol from libidn, which is *not* being found for some reason
17:13:48 <rwbarton> probably because you didn't tell the compiler to link against it
17:13:48 <geekosaur> possibly because transitive dependencies aren't being found, posisbly because they're in the wrong order
17:13:52 <Luke> rwbarton: good try - no love with the -lcurl stuff though =/
17:14:00 <rwbarton> well how are you building your project
17:14:11 <rwbarton> cabal? can you paste the .cabal file?
17:14:21 <geekosaur> yes, show what you're actually doing
17:14:25 <typoclass> Luke: tangentially, i've used haskell's curl thingy once or twice and it was a little shaky and tended to crash. however i have had no issues with the http-conduit package, which is easy to use and well-documented and seems pretty thought-through
17:14:50 <rwbarton> my guess is you have "extra-libs: curl" and you need to add more stuff there. not sure though
17:14:52 <Luke> typoclass: yeah this is a dep of another lib i'm using - just trying to get things up and running first
17:15:06 <typoclass> Luke: right, never mind then :)
17:15:09 <Luke> rwbarton: I was thinking the same thing. is it "extra-libraries:" or "extra-libs"?
17:15:10 <ronwalf> typoclass: No luck with the reboot.
17:15:15 <Luke> "extra-libraries" doesn't seem to do it
17:15:26 <rwbarton> isn't curl already in there?
17:15:31 <rwbarton> what are you doing
17:15:36 <geekosaur> curl is not the problem
17:15:38 <geekosaur> curl is found
17:15:42 <rwbarton> right but ...
17:15:49 <rwbarton> how does it know to look for curl
17:15:57 <rwbarton> however it knows, add idn etc.
17:16:01 <Luke> oh i see it is "libraries"
17:16:04 <rwbarton> that's what I would try
17:16:09 <geekosaur> the problem is likely that shared libraries store transitive dependencies but static ones od not
17:16:14 <typoclass> ronwalf: your problem is definitely very funky and unexpected :-/
17:16:31 <geekosaur> that is, libcurl.so knows to add a dependency on libidn.so automatically, but there is nowhere in a .a to put that information
17:16:39 <geekosaur> you must add it manually
17:16:43 <ronwalf> typoclass: The world would be much darker, otherwise.
17:17:01 <ronwalf> typoclass: It's failing on any negative double
17:17:02 <Luke> geekosaur: how can I find all the libs I need to add manually?
17:17:03 <Eduard_Munteanu> Hm, 5.3 in http://www.cs.gunma-u.ac.jp/~hamana/Papers/loop.pdf seems to point me somewhere.
17:18:12 <geekosaur> you got most of them from the ldd list, I think. arguably something should have included them explicitly anyway --- not all systems, not even all ELF-based systems (I'm looking at you, Solaris), can do transitive dependencies --- but Linux lets programmers get away with laziness
17:18:37 <geekosaur> this is therefore really a bug in the curl bindings for haskell just assuming that the transitive dependencies will deal with themselves
17:18:43 <rwbarton> I would just guess from the symbol names and the ldd output, yeah
17:18:58 <Luke> geekosaur: gotcha - that makes a lot of sense
17:18:59 <geekosaur> anyway you will have to work around by doing that
17:19:01 <Luke> rwbarton: thanks
17:19:14 <geekosaur> add in another library, see what fails, try to guess at the source based on the symbol names
17:19:33 <geekosaur> (or grep in the symbol tables of libraries listed by ldd; see "nm --dynamic")
17:21:05 <typoclass> ronwalf: i somehow have a hunch that it's a 32 vs. 64-bit issue, i don't really know why ...
17:21:25 <rwbarton> wouldn't the dependencies of curl depend on what flavor of curl you have installed though
17:21:34 <shachaf> typoclass: What, the segfault thing?
17:21:45 <rwbarton> e.g. does every version of curl have kerberos support?
17:21:51 * shachaf hasn't been following but it doesn't sound right...
17:21:57 <shachaf> ronwalf: Have you tried gdbing it?
17:22:04 <geekosaur> not sure the kerberos stuff is from curl though
17:22:18 <geekosaur> I see for example ldap stuff, which can also pull in sasl which can pull in kerberos
17:23:33 <geekosaur> would libcurl really depend on ldap?
17:23:47 <Eduard_Munteanu> This clarifies things further: http://www.cs.ut.ee/~varmo/tday-kaariku/hamana-slides.pdf (actually, copumpkin linked me to it, but I should've had a closer look)
17:23:49 <rwbarton> my curl binary depends on ldap (and sasl and krb5)
17:24:15 <typoclass> shachaf: sure, could well be wrong. i just thought some code gives a 64 bit number, other code wrongly cuts off stuff and uses it as 32 bit, some sort of overflow, two's complement setting high bits to 1, who knows ...
17:24:16 <geekosaur> yeh, and I just realized why (CRLs)
17:24:58 <geekosaur> oh, so thats a way to see what you need, in fact
17:25:02 <Eduard_Munteanu> Now, if this has already been done, I should look for other CT stuff to mess with :)
17:25:19 <geekosaur> find the .so for a library, use ldd to see its dependencies, add the static versions of those
17:25:34 <geekosaur> this can be transitive so you need to check the dependencies of those as well, recursively
17:25:45 <rwbarton> $ ldd /usr/lib/libcurl.so.4 | wc -l
17:25:45 <rwbarton> 25
17:25:46 <t7> you guys seem the program extraction from proof video from haskell symposium ?
17:26:34 <geekosaur> maybe they can make the next version depend on gnome so they can add aonother couple hundred to that :p
17:27:12 <byorgey> t7: yes, what about it?
17:27:22 <t7> its cool
17:27:29 <byorgey> indeed =)
17:27:47 <t7> i cant find much about the HOL4 theorem prover mind you
17:28:53 <ronwalf> Tracking down the actual GHC binary on mac is a pain
17:28:58 <cornihilio> are there any good tutorials or examples of attoparsec? I'm sucking at finding something I can wrap my head around
17:30:15 <byorgey> t7: http://hol.sourceforge.net/ ?
17:31:16 <mikeplus64> cornihilio: do { string "foo "; word <- takeTill isSpace; string " bar"; return word } -- here's one :)
17:31:32 <mikeplus64> to parse "foo <word> bar"
17:32:36 <ronwalf> typoclass: gdb gives me nothing, other than that it was a null pointer exception
17:32:59 <shachaf> ronwalf: A null pointer exception in what?
17:33:22 <ronwalf> In #0  0x04707071 in ?? ()
17:33:27 <ronwalf> (not very helpful)
17:33:38 <ronwalf> Or maybe I don't remember how to use gdb all that well
17:33:43 <typoclass> ronwalf: hm interesting, so the backtrace is only 1 line long?
17:33:46 <shachaf> bt?
17:33:54 <ronwalf> 2 lines, but then it gives Previous frame inner to this frame (gdb could not unwind past this frame)
17:35:38 <napping> Eduard_Munteanu: those slides look pretty cool
17:36:04 <kirindave_> Wow, cabal has gotten way better in the last few versions
17:36:26 <ronwalf> typoclass: This is 32bit ghc, btw.
17:36:27 <shachaf> cabal -j!
17:36:35 <shachaf> ronwalf: On a 64-bit computer?
17:36:38 <ronwalf> Yes
17:36:40 <cornihilio> well... I guess my problem is more with advanced lazy streams. I'd like to make it so that in my code, after a failed parse returning nothing it calls itself on the remainder of the stream, but that doesn't work once it actually reaches the end of the stream.
17:40:10 <Rosenasty> oh wow, it's been a while since I did IRC chat
17:40:14 <cornihilio> I mean... I just don't know what to do if it seems like nothing can be the signal for two different things that I want to act differently on.
17:40:51 <Eduard_Munteanu> Rosenasty: welcome back then
17:46:27 <cornihilio> this has been the most helpful tutorial so far but I'm having trouble because he gets to use foldl' over [L.ByteString] but I am stuck with just one big L.ByteString
17:46:44 <cornihilio> sorry, forgot the link: http://variadic.me/posts/2012-02-25-adventures-in-parsec-attoparsec.html
17:48:36 <Luke> this ld crap is really not going well
17:48:53 <Luke> it seems it fixed some of the complaints but a lot of the kerberos stuff isn't working
17:48:58 <Luke> says I need the -dev version (which I have)
17:50:11 <t7> higher order logic =>(curry howard isomorphism) dependently typed lambda calc?
17:52:24 <Eduard_Munteanu> Not necessarily dependent I think.
17:52:45 <Eduard_Munteanu> Just higher sorts?
17:53:51 <byorgey> t7: yeah, it's not necessarily dependent.  I think it corresponds to polymorphism over things with kinds other than *
17:54:33 <t7> ah ok
17:58:11 <dolio> Depends on the higher-order logic.
17:59:03 <Eduard_Munteanu> I guess Agda is an ω-order logic?
17:59:22 <dolio> First-order logic is dependent types.
17:59:53 <dolio> So if your higher-order logic is an extension of that, it has dependent types.
18:00:18 <Eduard_Munteanu> I suppose so, just not due to the higher-order bit.
18:00:26 <dolio> Right.
18:01:01 <dolio> F_omega is essentially a higher-order logic, except you can't do first-order quantification.
18:01:07 <dolio> Which is weird, but....
18:07:10 <cornihilio> are there any examples in general for dealing with lazy streams? how do you handle a failing match vs finding the end of the stream/
18:08:21 <Eduard_Munteanu> cornihilio: the end of the stream coincides with the end of your list or BS.
18:09:13 <Eduard_Munteanu> But that model sometimes break down and you reach for other abstractions like iteratees.
18:09:21 <Eduard_Munteanu> *breaks
18:09:52 <Eduard_Munteanu> For simple stuff, lazy I/O is ok though.
18:11:52 <jmcarthur> cornihilio: what do you mean by a failing match? why wouldn't you just pattern match every possible case?
18:12:22 <cmccann> it's not so much "simple stuff" as a certain class of stuff where lazy IO works ok
18:13:01 <jmcarthur> cornihilio: or perhaps you mean "what if you reach the end of a list where you don't expect an end at all?" in which case i would say you shouldn't be using that type at all. something like this would be appropriate for that:   data Stream a = Stream a (Stream a)
18:13:10 <cmccann> if you're only reading input from one place, and all you're doing is processing it and writing it back out, and don't really care about the details of reading/writing, then ok
18:13:35 <cornihilio> Eduard_Munteanu: no, I'm trying to use AttoParsec.Lazy parse on a Parser I made, but since it only matches half of it, it returns nothing in the first 10% of the file. I don't know how to call the parser again, because since it is returning nothing I don't know where in the stream to start off again. Here's a link of my code atm: https://gist.github.com/3843340
18:13:39 <YayMer> jmcarthur: How is that particularly different from a list?
18:13:48 <jmcarthur> YayMer: note the lack of []
18:14:03 <YayMer> jmcarthur: Yes but I mean, semantically isn't that basically how the [] is built?
18:14:15 <jmcarthur> YayMer: how do you write [] with that type?
18:14:20 <YayMer> jmcarthur: I ask because I've been imagining lately in my head how the [] lists are made and that is how I figure
18:14:26 <cmccann> @src []
18:14:27 <lambdabot> data [] a = [] | a : [a]
18:14:38 <YayMer> whoa
18:14:39 <jmcarthur> i mean [] the value, not [] the type constructor
18:14:49 <theplanet> cmccann, can you explain the output lambdabot just gave
18:14:52 <theplanet> what's it mean and such
18:14:53 <cmccann> what jmcarthur wrote amounts to "data [] a = a : [a]"
18:14:56 <jmcarthur> YayMer: that Stream type has no "empty"
18:15:05 <YayMer> jmcarthur: right, that's the only thing I see missing
18:15:09 <jmcarthur> YayMer: it is necessarily infinite
18:15:29 <cmccann> theplanet, it's just the definition of the data type [], which part are you wondering about?
18:15:32 <YayMer> jmcarthur: Sorry I mean to say, aside from an empty it is exactly what I expected the [] type to look like
18:15:40 <jmcarthur> YayMer: my point was that if you never expect to see the end of the list, why allow it in the type?
18:15:43 <cmccann> note that it's wonky because lists have magic baked-in syntax
18:15:44 <YayMer> jmcarthur: However it turns out the actual definition of the [] type is far more confusing to me
18:15:48 <theplanet> cmccann, i'm wondering if "[] a = [] | a : [a]" has a special meaning
18:15:56 <jmcarthur> YayMer: that's not its actual definition since it's not valid syntax
18:15:57 <YayMer> jmcarthur: Oh, sorry
18:16:03 <cmccann> it's equivalent to data "List a = Nil | Cons a (List a)"
18:16:06 <jmcarthur> YayMer: [] is special
18:16:20 <YayMe> that's what I thought jmcarthur
18:16:26 <jmcarthur> i wish that it was at least just syntax sugar for something else, but no, it's actually not definable :(
18:16:33 <YayMe> cmccann: Yeah, that makes sense
18:16:41 <cmccann> theplanet, other than the special syntax it gets there's nothing special going on
18:17:19 <cmccann> same goes for e.g. tuples, (,) is equivalent to "data Tuple2 a b = Tuple2 a b"
18:17:25 <YayMe> when thinking about list I was expecting something like data [] a = [] | : a []
18:17:44 <cmccann> YayMe, other than (:) being written infix, yeah
18:17:50 <jmcarthur> you mean data [] a = [] | (:) a []
18:18:04 <cmccann> note that "data [] a = [] | (:) a ([] a)" would also work
18:18:06 <YayMe> jmcarthur: Plus another a at the end I forgot
18:18:17 <jmcarthur> you mean data [] a = [] | (:) a ([] a)
18:18:18 <YayMe> right that's what I was imagining in my head
18:18:30 <jmcarthur> yeah, it's just infixed and mixfixed
18:18:32 <YayMe> but apparently it's defined more... insanely?
18:18:38 <cmccann> @src (,,,,,,,,)
18:18:38 <lambdabot> Source not found. There are some things that I just don't know.
18:18:39 <YayMe> jmcarthur: maxfixed!
18:18:41 <cmccann> @src (,,,,,)
18:18:41 <lambdabot> Source not found. Just try something else.
18:18:41 <jmcarthur> it's not defined that way at all
18:18:44 <cmccann> @src (,,,)
18:18:44 <lambdabot> Source not found. :(
18:18:46 <cmccann> bah
18:18:47 <jmcarthur> it's just lambdabot magic
18:19:00 <jmcarthur> YayMe: there is no syntactic definition for the sugary lists in haskell
18:19:03 <YayMe> lambdabot is smarter than me, which is a scary thought
18:19:40 <YayMe> jmcarthur: I kinda figured, I couldn't imagine in my head how you would define that notation with haskell
18:19:55 <jmcarthur> you get "Illegal binding of built-in syntax" if you try it yourself
18:19:59 <YayMe> you might get *close* but type constructors still need spaces
18:20:07 <jmcarthur> huh?
18:20:16 <YayMe> or rather I guess not
18:20:22 <YayMe> infix stuff doesn't need a space
18:20:28 <jmcarthur> right
18:21:06 <jmcarthur> data(a:+b)=L(a)|R(b)  -- no spaces!
18:21:26 <cmccann> actually if you want to see where that definition comes from: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/src/GHC-Types.html
18:21:26 <jmcarthur> the parens are kind of cheating
18:21:44 <jmcarthur> oh
18:22:03 <cmccann> that also has the definitions for other magic or primitive types
18:22:04 <YayMe> data ([]) a = ([) a ([] a) | (]) | (,) a ([] a)
18:22:07 * YayMe ponders
18:22:27 <jmcarthur> cmccann: but wait. how is that built?
18:22:34 <cmccann> magic
18:22:41 <cmccann> note the package is "ghc-prim"
18:22:50 <theplanet> i don't seem to have Control.Monad.State but i do have Control.Monad.ST
18:22:52 <cmccann> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/src/GHC-Tuple.html remains hilarious
18:22:58 <jmcarthur> the rest of it looks perfectly valid though
18:23:20 <soapyillusions> Is there a simple way to `map readFile [FilePath]` to a [String] instead of [IO String]? I'm doing this action within a do-block.
18:23:25 <jmcarthur> "Manuel says: Including one more declaration gives a segmentation fault."  heh
18:24:01 <jmcarthur> soapyillusions: try mapM instead of map
18:24:06 <YayMe> cmccann: Wth? that isn't a real bit of the prelude is it?
18:24:08 <jmcarthur> soapyillusions: that will give you an IO [String]
18:24:16 <cmccann> YayMe, no, it's part of GHC
18:24:19 <soapyillusions> jmcarthur oh wow awesome
18:24:28 <YayMe> awesome
18:24:34 <Ralith> soapyillusions: for reference:
18:24:36 <Ralith> :t sequence
18:24:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:24:37 <jmcarthur> @src mapM
18:24:38 <lambdabot> mapM f as = sequence (map f as)
18:24:45 * Ralith high fives jmcarthur 
18:24:51 <jmcarthur> yay cooperation!
18:24:58 <YayMe> cmccann: Is there a part somewhere that's like "data Int = -..., -..., ..., 0, 1, 2, ...
18:25:04 * jmcarthur saw it coming
18:25:09 <Ralith> hey, does lambdabot have
18:25:11 <Ralith> @src sequence
18:25:12 <lambdabot> sequence []     = return []
18:25:12 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
18:25:12 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
18:25:15 <Ralith> yay
18:25:21 <soapyillusions> haha lambdabot is really cool
18:25:36 <cmccann> YayMe, no, that gets defined in terms of more magic-y internal magic stuff
18:25:40 <jmcarthur> @undo do {v <- x; vs <- sequence xs; return (v:vs)}
18:25:41 <lambdabot> x >>= \ v -> sequence xs >>= \ vs -> return (v : vs)
18:25:48 <Ralith> soapyillusions: so as you can see, none of these are magic black boxes or anything, just convenience functions for simple use of the primitives.
18:25:59 <cmccann> YayMe, you can browse http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/src/ if you want
18:26:19 <jmcarthur> YayMe: i advise that you don't take ghc primitives as any sort of explanation of what things are, though
18:26:28 <jmcarthur> YayMe: for example, the implementation of IO is misleading
18:26:31 <jmcarthur> @src IO
18:26:31 <lambdabot> Source not found. You untyped fool!
18:26:39 <jmcarthur> (just in case...)
18:26:40 <cmccann> most stuff that's actually just built-in still has dummy definitions
18:26:44 <YayMe> that's it, from now on I'm writing code only in haskell, my company will just have to deal. the compiler has a module GHC.Magic, that's all I needed to know
18:26:57 <YayMe> the language is in fact MAGIC. How could anyone choose a different language? The magic is built right in!
18:27:04 <jmcarthur> data IO a = IO# (RealWorld# -> (# RealWorld#, a #)    -- something like this
18:27:27 <cmccann> IO is defined near the bottom of GHC.Types
18:27:40 <jmcarthur> )
18:27:42 <cmccann> just above the definition of (~) which baffles me
18:27:50 <jmcarthur> (~)!
18:27:51 <cmccann> yes, ~ as in the equality constraint
18:27:51 <YayMe> jmcarthur: I wouldn't particularly understand most of it anyway, I'm just curious
18:28:23 <jmcarthur> cmccann: i had no idea ~ was a type constructor
18:28:37 <theplanet> "this language is purely functional"
18:28:48 <cmccann> jmcarthur, well it makes sense really
18:28:55 <cmccann> it would have kind * -> * -> Constraint
18:29:04 <YayMe> theplanet: That's an inaccurate statement, it would be better to say "it is a pure functional language"
18:29:19 <jmcarthur> cmccann: the documentation claims it has kind (? -> ? -> Fact)
18:29:29 <cmccann> that sounds out of date
18:29:34 <theplanet> YayMe, i dont see a difference actually
18:29:36 <jmcarthur> cmccann: Constraint can't guide type inference
18:29:44 <rwbarton> ghci 7.4.1 says (~) :: AnyK -> AnyK -> Constraint
18:29:48 <jmcarthur> huh
18:29:52 <cmccann> since Fact got renamed to Constraint at some point
18:29:56 <cmccann> if memory serves me
18:30:05 <jmcarthur> Constraint can actually constrain types??
18:30:06 <YayMe> theplanet: It took me a good bit to understand what "pure" means when people are talking about functional, but it isn't what you would initially think
18:30:19 <jmcarthur> (ignoring defaulting)
18:30:29 <cmccann> and yes, GHCi tells me "(~) :: * -> * -> Constraint"
18:30:36 <jmcarthur> crazy!
18:30:43 <rwbarton> that's somehow not the true kind though, it does demand its argument types have the same kind somehow
18:30:48 <Ralith> theplanet: 'pure' here means 'has no side effects'
18:30:57 <jmcarthur> rwbarton: yeah that's what i find confusing
18:31:14 <YayMe> theplanet: It doesn't mean purely functional, because it's multi-paradigm, you can write awesome imperative code in haskell
18:31:27 <rwbarton> ([] ~ Maybe) does work while (Int ~ Maybe) and (Maybe ~ Int) give two different sorts of error messages
18:31:41 <typoclass> is there kind variables, akin to type variables?
18:31:46 <jmcarthur> [] ~ Maybe works? ...
18:31:49 <cmccann> GHCi doesn't always give sensible error messages for very new stuff
18:31:55 <theplanet> nothign but the english in here makes sense to me
18:31:58 <rwbarton> *Main> :k (~) ~ (~)
18:31:58 <rwbarton> (~) ~ (~) :: Constraint
18:32:00 <rwbarton> hehe
18:32:02 <cmccann> :D
18:32:06 <jmcarthur> :o
18:32:11 <danharaj> :k (~)
18:32:12 <lambdabot> parse error on input `~'
18:32:18 <YayMe> theplanet: Are you learning haskell? Have you started reading LYAH or interested?
18:32:29 <rwbarton> there are no kind variables yet I guess?
18:32:32 <rwbarton> but I thought there were
18:32:38 <theplanet> YayMe, lyah? nah never heard of it but im interested
18:32:49 <typoclass> @where lyah
18:32:50 <lambdabot> http://www.learnyouahaskell.com/
18:33:05 <typoclass> theplanet: check it out, it's a pretty good book and available free of charge
18:33:10 <jmcarthur> rwbarton: i was under the impression there were, too, at least in ghc 7.6
18:33:14 <YayMe> http://learnyouahaskell.com/ and http://tryhaskell.org/
18:33:18 <theplanet> that is good
18:33:28 <rwbarton> ah well I've been testing 7.4.1
18:33:35 <theplanet> i'll get back to you in a few months ;)
18:33:40 <rwbarton> it seems to like AnyK a lot
18:33:41 <cmccann> GHCi tells me "(~) :: k -> k -> Constraint"
18:33:45 <cmccann> if I set -XPolyKinds first
18:33:53 <YayMe> theplanet: the first url there for reading, the second for poking until you install local
18:33:53 <rwbarton> you have a shinier ghci
18:34:10 <cmccann> yes, I'm using 7.6.1, obviously
18:34:12 <theplanet> YayMe, sure i have everytning installed :)
18:34:18 <jmcarthur> yay PolyKinds!
18:34:31 <theplanet> im using 6.12
18:34:36 <rwbarton> well PolyKinds seems to sort of work in 7.4 also
18:34:42 <theplanet> am i behind a  lot?
18:34:52 <cmccann> 6.12 is a couple years old I think
18:34:54 <danharaj> 6.12 is hella old
18:34:54 <jmcarthur> theplanet: getting a bit old, but should be reasonable until you try the more recent stuff
18:35:07 <cmccann> and there's a lot of new features since then, most of which are completely irrelevant to someone learning the language
18:35:08 <rwbarton> :set -XPolyKinds, data X a where X :: X a, :k X => X :: AnyK -> *
18:35:19 <jmcarthur> theplanet: ghc moves really fast, but no beginner tutorial i know of will rely on recent features
18:35:19 <theplanet> do you have an ubuntu package link jmcarthur
18:35:36 <jmcarthur> theplanet: i wouldn't worry about it for now
18:35:41 <typoclass> theplanet: yeah it's a little old, but i wouldn't worry much about it. you're not likely to start out haskell and rightaway need the newest, most complicated stuff :) but be prepared to upgrade at some point
18:35:44 <rwbarton> sufficiently new ubuntu has 7.4.1
18:35:50 <YayMe> theplanet: ah, well LYAH is the place to start for understanding haskell. Haskell is... a whole new way to think about programming.
18:35:52 <cmccann> people who want to stay up to date with GHC usually install it directly
18:36:08 <cmccann> it seems to get updates faster than distro release cycles, heh
18:36:08 <jmcarthur> or they use arch (which of course still doesn't have 7.6...)
18:36:27 <jmcarthur> i guess gentoo also fits the bill
18:36:32 <rwbarton> at this particular point in time ubuntu has the latest version you are likely to want to use
18:36:45 <YayMe> theplanet: When I first started playing with haskell I could barely sleep for 2 days because of how confused it made me.. true story :D doesn't that sound fun??
18:36:56 <rwbarton> since as I understand it trying to get many packages to work with 7.6 is "an experience"
18:36:57 <jmcarthur> YayMe: wait until you try agda!
18:37:01 <Eduard_Munteanu> jmcarthur: don't be so sure, the last stable version in Gentoo is 6.12.3 :)
18:37:01 <typoclass> YayMe: very entertaining :) thanks
18:37:15 <jmcarthur> Eduard_Munteanu: :o i knew there was a reason i went to arch
18:37:21 <Eduard_Munteanu> Keyword masked 7.4.1, but that's ok.
18:37:27 <typoclass> @remember YayMe When I first started playing with haskell I could barely sleep for 2 days because of how confused it made me
18:37:28 <lambdabot> I will never forget.
18:37:29 <cmccann> pf, gentoo needs to funroll their loops harder
18:37:37 <YayMe> jmcarthur: I have learned from haskell to be careful before I start studying something
18:37:48 <theplanet> YayMe, good that bit about whole new way to think about programming becaue i have never programmed!
18:37:56 <theplanet> it wont be a major switch for me;)
18:38:26 <YayMe> ah, I've always been curious what it would be like for someone who learned haskell as their first language
18:38:30 <YayMe> has anyone else here done that?
18:38:47 <YayMe> I know some unis teach it first but not many
18:38:55 <theplanet> ubuntu has the old packages!
18:39:24 <theplanet> YayMe, you've *always* been curious about that? ;)
18:39:47 <YayMe> theplanet: since time immemorial
18:40:08 <theplanet> ooh, i bet
18:40:18 <cmccann> I see theplanet is already being pedantic about quantification, clearly going to be good friends with GHC
18:40:32 <jmcarthur> YayMe: my wife thinks the idea of mutation is weird
18:41:08 <jmcarthur> she gets it, but she doesn't see how it could be managable
18:41:11 <typoclass> jmcarthur: don't tell her about Control.Concurrent.MVar
18:41:17 <BMeph> jmcarthur: ...and you don't? ;)
18:41:34 <YayMe> jmcarthur: Err? Your wife programs or is mathy or?
18:41:37 <jmcarthur> BMeph: the point is she didn't know anything about programming before being exposed to haskell
18:41:48 <jmcarthur> YayMe: she's kind of a techy artist kind of person
18:42:10 <YayMe> oh.. haskell first means mutation is weird.. that is a strange thought
18:42:25 <jmcarthur> i would say that necessarily is true in general
18:42:28 <jmcarthur> *wouldn't
18:42:37 <YayMe> she understands computer programming as a truly declarative thing
18:42:44 <cmccann> YayMe, and imagine getting used to type inference then moving to most other languages
18:43:02 <YayMe> cmccann: oh yeah, that would be weird
18:43:06 <jmcarthur> YayMe: i also don't think i would say that, necessarily
18:43:26 <jmcarthur> YayMe: it's not that she doesn't get it. she just doesn't see how it could be a reasonable level of abstraction to work with
18:44:00 <cmccann> anyway, I really think that in many ways it'd be easier to learn Haskell without any prior notions about programming
18:44:02 <YayMe> jmcarthur: imagine 200 years from now when people program their housebot by telling it what to do, and then exposing them to C++
18:44:11 <cmccann> so I'm looking forward to seeing how well theplanet does!
18:44:31 <theplanet> like i need more pressure ;/
18:44:33 <jmcarthur> YayMe: i don't have to imagine. there are tons of people that don't learn C++ as a first language and then it's shoved in their faces
18:44:41 <cmccann> YayMe, imagine today, right now, exposing someone to C++. the horrors!
18:44:58 <YayMe> cmccann: heh true, I feel that when I see C++ as a C# developer
18:44:58 <cmccann> theplanet, heh, don't worry, I'll probably forget entirely by morning :P
18:45:08 <theplanet> that's better ;)
18:45:12 <cmccann> yeah, I've been doing C# for years now
18:45:15 <cmccann> I know the feeling
18:45:30 <donri> jmcarthur: and of course she was introduced to mutation by someone completely unbiased on the subject ;)
18:46:01 <jmcarthur> donri: right. there's definitely some selection bias in this observation
18:46:01 <Koterpillar> What's the name of the extension which allows you to define a related data type in a typeclass? E.g. I want every instance of MyClass to specify the return type of someFunc :: MyClass -> MyResult
18:46:04 <YayMe> theplanet: I agree with cmccann, I think it will be easier for you to learn haskell than it has been for me after writing imperative code for 10 years
18:46:04 <cmccann> after working in C# for so long, then I see people defending C++ and all I can think is that it sounds like stockholm syndrome
18:46:23 <danharaj> I used to like C++
18:46:32 <danharaj> Then I didn't.
18:46:46 <donri> after working in agda for so long, then I see people defending haskell
18:46:51 <jmcarthur> i never really liked it. i just learned it before i knew enough to hate it
18:46:51 <cmccann> hahaha
18:47:12 <danharaj> People don't run agda programs do they? :P
18:47:19 <jmcarthur> i've run one before!
18:47:33 <jmcarthur> just to confirm that it was possible
18:47:38 <YayMe> cmccann: haha yeah, I hear ya.. the only space I see it make any sense is systems programming, but after learning haskell I've decided I think the simplicity of C is actually a better choice even though it becomes a mess in it's own way, I think it's mess would be better
18:47:51 <cmccann> I liked the agda-to-haskell compiler that seemed to implement everything in terms of nested calls to unsafeCoerce
18:48:11 <cmccann> yeah, for super low-level stuff I'd stick with C personally
18:48:27 <YayMe> donri: Is agda supposed to be a new haskell?
18:48:27 <cmccann> anything that would justify using C++ over C seems like it would justify using something better instead
18:48:32 <jmcarthur> same here, or perhaps C++ as C with my two or three favorite extensions
18:48:41 <donri> YayMe: yep, haskell ain't cool no more
18:49:15 <jmcarthur> YayMe: agda is the new hotness. haskell fail to avoid success, so agda has come along to take up the mantle
18:49:19 <jmcarthur> *failed
18:49:21 <YayMe> donri: I know nothing of agda, why would I use it instead?
18:49:27 <cmccann> you wouldn't
18:49:51 <jmcarthur> YayMe: in a nutshell, you can basically program the type system at will
18:49:53 <YayMe> jmcarthur: Ah, well if it's a version of haskell that I could get C# folks to move to, I'm all for it.
18:50:20 <cmccann> agda is kinda "more haskell than haskell" as far as comparison to other languages go
18:50:26 <YayMe> oh
18:50:35 <YayMe> oh I misunderstood what jmcarthur said
18:50:39 <donri> clearly the selling feature is mixfix! you thought operator precedence was messy in haskell?
18:50:46 <cmccann> @quote mixfix
18:50:46 <lambdabot> kmc says: ghc -XMixfixOperators -XDependentTypes -XMakeMeASandwich
18:50:48 <cmccann> @quote mixfix
18:50:48 <lambdabot> kmc says: ghc -XMixfixOperators -XDependentTypes -XMakeMeASandwich
18:50:52 <cmccann> @quote mixfix
18:50:52 <lambdabot> kmc says: ghc -XMixfixOperators -XDependentTypes -XMakeMeASandwich
18:50:52 <cmccann> bah
18:50:53 <YayMe> I thought he was saying agda was coming to get the success haskell was avoiding
18:51:02 <jmcarthur> no, quite the opposite
18:51:08 <cmccann> yeah
18:51:23 <jmcarthur> agda is coming to fill the void that haskell has left in the space of unsuccessful languages
18:51:39 <YayMe> I could be crazy, but haskell is still avoiding success quite successfully in the eyes of real-world devs I've met
18:51:55 <jmcarthur> i'm running into more and more people using it for real work
18:51:56 <donri> (not compared to agda ;))
18:51:57 <YayMe> maybe I spent too much time with bad developers though..
18:52:12 <jmcarthur> and yeah, agda is... really not there
18:52:23 <danharaj> why does Agda -> Haskell emit all the unsafeCoerces instead of erasing dependent types?
18:52:26 <Ralith> jmcarthur: how so?
18:52:32 <jmcarthur> Ralith: in terms of success
18:52:35 <Ralith> oh
18:52:46 <cmccann> danharaj, I dunno, but the result is hilarious
18:52:50 <jmcarthur> Ralith: but i could go into some technical limitations of it, if you wish
18:53:00 <Ralith> jmcarthur: I'd like to hear that
18:53:03 <danharaj> :t unsafeCoerce unsafeCoerce unsafeCoerce
18:53:04 <lambdabot> Not in scope: `unsafeCoerce'
18:53:05 <lambdabot> Not in scope: `unsafeCoerce'
18:53:05 <lambdabot> Not in scope: `unsafeCoerce'
18:53:12 <jmcarthur> nice, lambdabot
18:53:15 <YayMe> jmcarthur: Would agda basically be the choice for people who want to do even more brain-bending haskelly stuff than haskell allows?
18:53:16 <cmccann> @quote unsafeCoerce
18:53:16 <lambdabot> elliott says: <elliott> I like how edwardk's answer to every question always goes "most abstract solution to the problem possible --> microoptimisation details". <elliott> I swear I've seen him go
18:53:17 <lambdabot> from category theory to unboxed types and unsafeCoerce in a single line of IRC.
18:53:23 <jmcarthur> YayMe: yes
18:53:37 <YayMe> jmcarthur: So, become good at haskell before bothering
18:53:55 <rwbarton> it would certainly help
18:54:00 <YayMe> jmcarthur: How does it perform in comparison? same? slower due to immaturity?
18:54:00 <jmcarthur> YayMe: that certainly wouldn't hurt, but i wouldn't say it's quite necessary
18:54:02 <napping> danharaj: you can't erase all the dependent types, in general
18:54:03 <rwbarton> I mean that is probably the easiest way to get into agda
18:54:10 <danharaj> YayMe: No one *runs* Agda code :P
18:54:14 <jmcarthur> YayMe: perform? you mean you want to *run* agda code?
18:54:20 <cmccann> yeah, the thing about not running agda code is not really a joke
18:54:27 <Ralith> cmccann: why's that?
18:54:28 <jmcarthur> YayMe: most are satisfied with getting their code to type check
18:54:29 <cmccann> it's more a theorem prover than a programming language in practice
18:54:46 <danharaj> ATS actually gets run but its got abysmal syntax.
18:54:52 <cmccann> once you type check successfully, i.e. your proof is valid, you don't usually care about running it
18:54:56 <YayMe> jmcarthur: haha, you all are the programming version of that old adage "math for math's sake"
18:54:58 <Ralith> YayMe: Idris is an attempt to build a dependently typed language for actual use.
18:55:04 <napping> I guess performance is inversely proportional to niceness of syntax
18:55:07 <jmcarthur> YayMe: that's right!
18:55:14 <Ralith> YayMe: come help develop it!
18:55:15 <dolio> Agda is an attempt to build a dependently typed language for actual use.
18:55:18 <YayMe> Ralith: I saw a link to that today..
18:55:18 <danharaj> Haskell has way nicer syntax than Ruby/Python/Java/...
18:55:22 <danharaj> And it runs betterer
18:55:25 <jmcarthur> the closest i've gotten to running useful agda code is porting it to haskell or ocaml
18:55:32 <YayMe> Ralith: I'd have to be a much better developer and mather for that matter
18:55:34 <donri> agda compiles to haskell, so might not perform *that* bad, depending on what haskell it generates :p
18:55:35 <Ralith> dolio: I should say execution
18:55:48 <Ralith> YayMe: one way to grow!
18:55:49 <applicative> i  was going to say, it's clear Agda is meant as a prototype for a real programming language
18:55:58 <cmccann> agda basically has an FFI to haskell, right? so I'd assume you could always use both together
18:55:58 <Ralith> applicative: why is that clear?
18:56:03 <jmcarthur> i use agda for prototyping things with tricky types because agda-mode is amazing
18:56:07 <dolio> Yes, it does.
18:56:23 <donri> YayMe: https://github.com/liamoc/learn-you-an-agda glhf
18:56:27 <cmccann> hahahaha
18:56:30 <dolio> Some of the compilers might have other FFI options, too. I'm not sure.
18:56:32 <YayMe> applicative: it's the imagination of a meta-language for writing meta-languages?
18:56:37 <Eduard_Munteanu> Or to C, or to JS... just pick :)
18:56:46 <jmcarthur> i have even used agda at work to prototype some code that is actually being used in production now
18:56:56 <Eduard_Munteanu> Nice.
18:57:07 <theplanet> eh what is meant by prototyping code
18:57:10 <danharaj> Coq has a way to emit Haskell code too, doesn't it?
18:57:18 <applicative> Ralith if it were a theorem proving machinery, it would be focussed on Prop and so on, but it's all about exotic data structures
18:57:19 <dolio> There is some Agda code out there that people have run, too. Some guy did some web stuff in it.
18:57:24 <jmcarthur> theplanet: exploring the design space until i find a place i like
18:57:27 <Eduard_Munteanu> donri, YayMe: you probably want to start with Ulf's tutorial though
18:57:42 <donri> Eduard_Munteanu: link or it didn't happen
18:57:43 <Eduard_Munteanu> LYAA is pretty much work in progress, YMMV.
18:57:44 <applicative> the javascript backend it the limit of agda-madness
18:57:59 * geekosaur used to prototype complex pricing rules in prolog... weirded his then boss and coworkers out
18:58:05 <Eduard_Munteanu> donri, YayMe: http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf
18:58:10 <napping> danharaj: that's not too useful for exploring weird types. It's actually pretty annoying to write programs that manipulated dependently typed data in Coq
18:58:24 <YayMe> Eduard_Munteanu: I don't expect to bother with agda any time soon, I still need to work my way through the typeclassopedia
18:58:27 <danharaj> napping: gotcha.
18:58:49 <donri> so, does agda have bottom? does the halting problem mean it has to?
18:58:58 <napping> It can be pretty darn useful, but only pays off to help automate complicated proofs - CPDT explains all the tricks
18:59:04 <cmccann> what does the halting problem have to do with agda? :P
18:59:05 <jmcarthur> donri: agda is strongly normalizing
18:59:06 <Eduard_Munteanu> donri: no and no :)
18:59:10 <jmcarthur> donri: it's not even turing complete
18:59:17 <donri> huh!
18:59:31 <YayMe> theplanet: Most the people here talk about stuff that won't make any sense to well.. anyone (sometimes I think they couldn't even understand what they're saying) so don't worry about a lot of what's said here. Though do ask all the questions you want in here as they're helpful and talk like normal people when you need help
18:59:36 <jmcarthur> (well, it is, but with big fat warnings if the termination checker can't tell whether your program terminates)
18:59:56 <byorgey> Does anyone know if you can implement the Ackermann function in Agda?
19:00:02 <jmcarthur> YayMe: always feel free to ask questions. we are an unusually patient bunch
19:00:08 <byorgey> out of curiosity.  Maybe I should ask in #agda.
19:00:09 <jmcarthur> byorgey: you can
19:00:13 <byorgey> cool
19:00:26 <YayMe> jmcarthur: Oh I've learned that, Cale spent like 4 hours the other night teaching me what a group was heh
19:00:38 <YayMe> made me feel kind of like a jerk for taking his time heh
19:00:44 <jmcarthur> YayMe: cale is basically a #haskell role model :)
19:00:45 <cmccann> if you take the ackermann function apart it's basically just a bunch of recursion on natural numbers, isn't it?
19:00:45 <theplanet> YayMe, oh thank god! (i was really worried)
19:01:00 <dolio> byorgey: Ackermann is primitive recursive in the presence of higher-order functions.
19:01:13 <cmccann> it's really not that hard to set upper bounds on each step of evaluating the ackermann function, I'd think
19:01:19 <luite> YayMe: see it this way, Cale used 4 hours of your time to sharpen his explain-what-a-group-is skills ;p
19:01:46 <jmcarthur> cmccann: but in agda you don't even have to jump through any hoops, iirc. you can just use the standard definition
19:01:52 <dolio> cmccann: The difficulty is that it's not primitive recursive if you don't have higher-order functions.
19:01:53 <cmccann> fair enough
19:01:57 <Eduard_Munteanu> In #haskell, free advices takes you! :P
19:02:01 <Eduard_Munteanu> *advice
19:02:50 <danharaj> System F can express rather complex arithmetic functions, I'm sure Agda can express far beyond Peano Arithmetic, and everything practical.
19:02:51 <YayMe> luite: I could also think about it like this: Cale committed a torture upon me by explaining something to me that after understanding, I couldn't get out of my head for days
19:03:18 * cmccann tried a couple times to implement the ackermann function with church numerals using just type synonyms, just to see where it fails
19:03:35 <cmccann> I think if I had rank-N polykinds I could make it work :[
19:04:02 <jmcarthur> agda accepts this. it's even in the documentation as an example of how the termination checker works.    ack : (x y : Nat) -> Nat; ack zero n = s n; ack (suc m) zero = ack m (suc zero); ack (suc m) (suc n) = ack m (ack (suc m) n)
19:04:11 <jmcarthur> http://wiki.portal.chalmers.se/agda/agda.php?n=ReferenceManual.TerminationChecker
19:04:17 <dolio> cmccann: Value-level Church numerals or type-level?
19:04:31 <cmccann> dolio, type-level, using just "type". no type families.
19:04:34 <dolio> Heh.
19:04:59 <dolio> I'm not sure it's possible.
19:05:11 <cmccann> I'm nearly certain it's impossible.
19:05:41 <dolio> Well, certainly you're screwed without actually being able to define Church numerals, I think.
19:05:42 <cmccann> if memory serves me I had polymorphic hyperoperations but was thwarted by lack of higher-rank polymorphism
19:05:47 <dolio> With the quantifier.
19:05:52 <applicative> Ralith: here's a random tirade by pigworker that brings out the difference between an all-proof-all-the-time system, obsessed with Prop, and a system like agda which invites florid datatypes http://www.reddit.com/r/dependent_types/comments/b0vb7/agda_vs_coq_by_wouter_swierstra_with_some_input/
19:05:59 <cmccann> (note that this is assuming LiberalTypeSynonyms)
19:07:11 * danharaj would like a book for dependent types like Pierce is for System F
19:07:22 <jmcarthur> YayMe: here's a perfectly reasonable (albeit arbitrary) agda function:     foo : (p : Bool) -> if p then String else Nat ;   foo true = "It was true!"; foo false = 5
19:07:29 <jmcarthur> YayMe: note the lack of anything like Either...
19:07:36 * applicative recommends the bibliopolis book of course
19:07:46 <jmcarthur> YayMe: and the fact that the result type depends on the *value* of the argument
19:07:54 <cmccann> of course the other problem is that GHC gets really, really slow when you start computing even church numeral exponentiation with type synonyms
19:08:12 <cmccann> just 3^3 took like... 10 seconds I think
19:08:25 <YayMe> I'm the only person here who doesn't have any math background me thinks.. I'm not thinking I'll ever understand the crazy stuff like "ackerman gibberjab in plural churches" because of that missing foundation.
19:08:45 <YayMe> jmcarthur: That is very interesting indeed
19:08:51 <jmcarthur> YayMe: i lack that foundation too. i still lag behind some of the geniuses around here, but i've managed to keep up for the most part
19:09:08 <jmcarthur> YayMe: you will end up learning a lot of math if you hang around, of course
19:09:22 * cmccann lacks any foundation, and mostly tries to jump into progressively deeper deep ends as often as possible
19:09:23 <donri> does agda have type inference at all?
19:09:30 <applicative> Ralith, note further for what it's worth that pigworkers 'agda-curious' lecture at the functional programming whatever was a detailed construction of a genuine program by stages; he was disapponted when he had to have recourse to a proof
19:09:41 <jmcarthur> donri: well... top-level types are required
19:09:43 <applicative> if it didn't have some inference, you wouldn't make it very far
19:09:50 <YayMe> cmccann: Yeah that's been my approach as well.. nothing but a GED here
19:09:56 <jmcarthur> donri: it has inference in the sense that you don't have to add type annotations to *everything*
19:10:00 <Eduard_Munteanu> donri: sorta, barely
19:10:13 <Ralith> applicative: hm, thanks
19:10:15 <jmcarthur> donri: but it fundamentally can't infer everything
19:10:23 <YayMe> cmccann: How long have you been in all this crazy to understand the type theory stuff?
19:10:39 <cmccann> eh... two years or so? I dunno.
19:10:43 <Ralith> YayMe: my 'math foundation' is a few undergrad CS courses and reading books.
19:10:52 <Ralith> YayMe: I recommend Pierce for starters.
19:10:53 <Eduard_Munteanu> donri: you can sometimes do stuff like foo : _  foo = ...  and if the type can be deduced from the context, Agda won't complain about that _.
19:11:03 <avpx> YayMe: I learn more from this channel than a lot of my university classes. Being motivated to learn, and seeking out the resources that have what you want, is much more effective than schooling anyway.
19:11:08 <donri> alright
19:11:22 <jmcarthur> YayMe: Ralith is probably referring to Types and Programming Languages. great book
19:11:22 <avpx> YayMe: I *did* take a course in abstract algebra last semester, and that was very helpful for understanding some of this stuff.
19:11:23 <Eduard_Munteanu> donri: it's not as much type inference as metavariables.
19:11:27 <typoclass> YayMe: i'm another one who doesn't have a math background, and i have my doubts if that really has much bearing on actual haskell programming
19:11:34 <cmccann> YayMe, actually probably around three years since I first started trying to learn Haskell
19:11:38 <cmccann> but it was slow going for a while
19:12:10 <jmcarthur> YayMe: it's less mathy and more type theory-y though. i guess there's also some category theory book he wrote? haven't read that, if i'm even right
19:12:14 <applicative> Peirce would be better if it got rid of all the oo stuff ;)
19:12:57 <Eduard_Munteanu> He did write a CT book.
19:13:00 <YayMe> avpx: I've been thinking about doing that, just hard to commit to stuff after work when that's the only time with my lad :/ but if it would be helpful enough I might do it
19:13:07 <Eduard_Munteanu> Not sure how it compares to Awodey's though.
19:13:24 <Ralith> YayMe: do you have a commute?
19:13:39 <jmcarthur> i think one of my coworkers has his CT book. he says he doesn't really like it, if i've even identified it correctly
19:13:44 <cmccann> YayMe, if you learn better through coursework than on your own it might be worth it
19:13:48 <avpx> YayMe: It's tough. I find that, more than anything, my courses actually get in the way of my learning this semester. During the summer I had a good amount of time to devote to this kind of stuff.
19:14:00 <Eduard_Munteanu> applicative: well, I wish he focused more on dependent types and that sort of stuff, but it probably belongs to ATTAPL
19:14:07 <cmccann> I've learned more hanging around in here and trying to figure stuff out than I ever did in college
19:14:17 <applicative> havent seen attapl
19:14:31 <jmcarthur> attapl is a bit more random, but definitely has some good chapters
19:14:48 <luite> cmccann: hm, am i the only one who did learn something in college? :p
19:14:51 <jmcarthur> my favorite bits are substructural types and regions
19:14:58 <jmcarthur> i learned almost nothing in college
19:15:06 <cmccann> I went to a pretty terrible college
19:15:08 <Eduard_Munteanu> ATTAPL is basically a bunch of articles AFAIH :)
19:15:08 <jmcarthur> it was a waste of time and money, IMO
19:15:18 <jmcarthur> Eduard_Munteanu: that's basically right
19:15:27 <jmcarthur> Eduard_Munteanu: they are quite disjoint, at least
19:15:27 <cmccann> in my case I at least didn't waste any money (had a scholarship)
19:15:35 <YayMe> cmccann: I never did which is why I don't have the degree, but still I wonder about the things I don't know about because I haven't been through a curriculum that would expose me to it
19:15:49 <applicative> the problem with a textbook discussion of dependent types is that the whole business is in permanent crisis.  martin-loef's system is presumably sound enough, for his purposes
19:15:58 <jmcarthur> cmccann: oh, i had a scholarship too, but i still spent money on things apart from tuition/dorm/books/etc.
19:16:12 * Eduard_Munteanu should definitely polish his MLTT knowledge
19:16:14 <elliott> cabal: Command.optionToFieldDescr: feature not implemented
19:16:19 <elliott> is cabal-install 1.16.0 broken or something
19:16:27 <YayMe> Ralith: Yeah I have a commute, why?
19:16:32 <cmccann> throw new NotImplementedException()
19:16:34 <cmccann> :[
19:16:39 <elliott> i get this when trying to do anything (e.g. cabal update or cabal install foo) if I have a ~/.cabal/config
19:16:44 <elliott> including the ~/.cabal/config that cabal update creates on first run
19:16:48 <Ralith> YayMe: find a way to do it by public transit, and spend it reading up on type theory!
19:16:49 <elliott> (GHC 7.6.1)
19:16:53 <cmccann> jmcarthur, I lived with my parents and had an on-campus job that made up the difference
19:16:54 <shapr> I'm enjoying ATTaPL, I just got a copy yesterday!
19:16:57 <typoclass> applicative: how do you mean permanent crisis? it's too new to have solidified ...?
19:17:01 <jmcarthur> shapr: yay!
19:17:24 <shapr> First time someone actually bought me something from my Amazon wishlist.
19:17:25 <cmccann> YayMe, nothing you can't pick up by other means, trust me
19:17:25 <jmcarthur> oh, another good book sitting right in front of me! Algebra of Programming
19:17:32 <shapr> I haven't read that one yet!
19:17:34 <donri> elliott: hm i think there was some bug involving .cabal/config and Cabal the library
19:17:39 <dolio> jmcarthur: I don't think Pierce's category theory book is very good for learning category theory.
19:17:42 <donri> elliott: got latest Cabal?
19:17:52 <applicative> martin loef has been writing for more than 30 years.
19:17:52 <elliott> donri: cabal --version says it's using the same version of the library
19:17:56 <cmccann> YayMe, the key thing is to try to keep up with stuff in here (or elsewhere) that's at the limit of what you understand, ask people to point you toward information, and try to figure things out
19:17:56 <shapr> I recently got Polya's "How To Solve It" but I haven't even started it.
19:18:03 <dolio> It has a few bits about how it relates back to programming that are okay if you already know the basics, though.
19:18:07 <jmcarthur> dolio: is it good for some other goal one might have that you can think of?
19:18:07 <elliott> donri: googling suggests that this problem arised in the past when using an invalid config option due to the default config skeleton being wrong http://hackage.haskell.org/trac/hackage/ticket/368
19:18:09 <donri> elliott: well there's a 1.16.0.1
19:18:11 <applicative> typoclass ^^^
19:18:13 <elliott> ah, hm
19:18:29 <dolio> jmcarthur: Like F-algebras and data types.
19:18:29 <typoclass> applicative: hm okay
19:18:30 <elliott> perhaps I need that then
19:18:33 <jmcarthur> ah
19:18:41 <elliott> it has been a while, I have forgotten whether it is OK to update Cabal separately to GHC :(
19:18:56 <applicative> hah, english spelling is behind your trouble elliott?
19:18:59 <jmcarthur> dolio: so then if i've already been working through Algebra of Programming it doesn't sound like there would be much point in going through Pierce's book then?
19:19:02 <donri> should be
19:19:23 <elliott> applicative: well, same error, but it appears the root cause is different :) no "optimisation" in my config
19:19:40 <dolio> jmcarthur: Probably not.
19:19:49 <jmcarthur> good to know. thanks
19:20:05 <applicative> elliot I guess d coutts is asleep :)
19:20:27 <applicative> ,,, dreaming about cloud haskell?
19:21:08 <elliott> I guess this is what I get for not using the Haskell Platform
19:21:19 <elliott> "no, I know what I'm doing", I tell myself, "this will be just fine"
19:21:34 <donri> also #hackage is less noisy for cabal issues
19:22:02 <applicative> what cabal-install and ghc are you using elliot, just wondering
19:22:21 <elliott> applicative: GHC 7.6.1, cabal-install 1.16.0
19:22:26 <elliott> (Cabal 1.16.0 but I'm upgrading that)
19:22:59 <YayMe> applicative: That idea is what brought me to haskell, working on a SOA at my last job I realized side effect free services would be pretty spectacular way of scaling our complex processing (and failed to convince anyone that we should create side effect free services)
19:23:19 <theplanet> can someone give me one of those --> pointy characters
19:23:31 <theplanet> a solid ->
19:23:36 <donri> →
19:23:40 <applicative> but Cabal-1.16.0 is the one ghc-7.6.1 uses, no?
19:23:40 <theplanet> thanks
19:23:50 * YayMe wonders what theplanet is going to do with that
19:24:06 <donri> ☺
19:24:08 <elliott> point at things with it
19:24:22 <elliott> donri: be careful about giving away those or you will run out of →s
19:24:25 <YayMe> I sure hope he's defining a function with it
19:24:25 <Eduard_Munteanu> Gee, be careful, you can poke an eye with that thing.
19:24:28 <typoclass> theplanet: you can also just google "arrows" :) wikipedia has a whole table of them for copy-pasting
19:24:40 <elliott> applicative: indeed
19:24:41 <applicative> YayMe: you mean 'cloud haskell'?
19:24:42 <theplanet> typoclass, excellent
19:24:52 <donri> elliott: it's alright, i've got lots of reserve arrows
19:25:10 <applicative> elliott: but I thought that meant you didn't want to update it -- i mean the Cabal lib of course
19:25:12 <Eduard_Munteanu> Or copy them from your Agda code ;)
19:25:14 <YayMe> applicative: Yeah, just the whole side effect free thing made me think it made sense for mesh processing
19:25:18 <donri> ↣↠↪↱↻⇉
19:25:22 <YayMe> or whatever other buzzword you want to use for it
19:25:44 <elliott> applicative: that's what I thought too! but then donri said it was OK
19:25:47 * cmccann thinks people would be terrified by his SciTE abbreviations file
19:25:49 <elliott> so if it all breaks, I know who to blame
19:26:07 <applicative> I just get trouble, but he would know better, I'd think
19:26:08 * shapr blames donri 
19:26:36 <donri> theplanet: doesn't your OS have a character map application, or a way to configure a compose key?
19:26:41 <applicative> elliot is it that  you want to install the head version of cabal-install?
19:26:45 <theplanet> ↑↑↑
19:26:47 <theplanet> donri, i tried that
19:27:03 <theplanet> donri, im sure it can compose keys. i'll look into that later
19:27:10 * Eduard_Munteanu uses SCIM for IRC stuff
19:27:16 <Ralith> donri: trying to navigate unicode with something like windows' character map tool sounds painful.
19:27:36 <applicative> the character utility on os x is pretty impractical. i think they wrote it in the seventies and keep porting it
19:27:42 <donri> i hit menu key - >
19:27:50 <hpaste> “C. McCann” pasted “this is all very useful no really” at http://hpaste.org/75848
19:27:50 <YayMe> Ralith: Oh hush, charmap was my favorite game in windows 3
19:27:50 <Eduard_Munteanu> So I can type α, β, ↣ etc. without coming up with compose combos.
19:27:57 * donri ♥ compose key
19:28:01 <YayMe> Ralith: Second only to the wing dings font in mspaint
19:28:11 <monochrom> I use SCIM too
19:28:22 <elliott> cmccann: i like how you have abbreviations to turn untypeable codepoints into other untypeable codepoints
19:28:28 <applicative> among other things, it doesn't have the idea of focus, and is thus on top of whatever you wanted to copy a char to.
19:28:32 <elliott> incredibly useful
19:28:37 <Eduard_Munteanu> I think I actually started using SCIM when monochrom mentioned it.
19:28:40 <cmccann> elliott, I'm not responsible for your font being suboptimal
19:28:57 <donri> or altgr+i with swedish layout
19:28:58 <elliott> cmccann: well in "•=·" don't you have to type • to get that
19:29:12 <elliott> wait you also have "·=•" I don't get it
19:29:18 <cmccann> that's so I can keep hitting ctrl-B and cycle through different dots
19:29:20 <cmccann> because
19:29:22 <elliott> is the idea to hang your editor with an infinite replacement loop :P
19:29:24 <cmccann> sometimes I need different ones
19:29:37 <cmccann> no, each ctrl-B keypress is a single step
19:29:40 <elliott> ah
19:29:40 * applicative wonders if he can make an umlaut via this interface: Martin-Löf
19:29:46 <Eduard_Munteanu> donri: yeah, though you have to remember all those weird mappings, SCIM instead lets you type Latex-ish sequences.
19:29:48 <elliott> so this is basically as powerful as Thue
19:29:49 <applicative> seems to have worked
19:29:56 <elliott> so you could write a universal turing machine with scite replacements
19:29:59 <elliott> and Ctrl+B would step it
19:30:05 <Eduard_Munteanu> \alpha gives me α
19:30:06 <cmccann> hahaha
19:30:17 <elliott> I'm just saying, if you ever end up with far more time than you know what to do with, you could do that
19:30:35 <cmccann> it would not be the most ridiculous programming language I'd ever used
19:30:45 <shachaf> Ctrl-Shift-U 3 B 1 <space> gives me α
19:30:54 <shachaf> hi elliott
19:31:04 <monochrom> yeah, but now you need to remember 3B1
19:31:15 <shachaf> But I already remember that one.
19:31:20 <shachaf> (Thanks to sorear!)
19:31:22 <YayMe> cmccann: I like that file just because it explains a lot of math symbols I ignore when I see them, like the upside down a and the backwards e
19:31:54 <donri> i just make vim display stuff as unicode without actually writing it to the file https://github.com/dag/vim2hs/blob/master/autoload/vim2hs/haskell/conceal.vim
19:32:01 <monochrom> 2200 for ∀ :)
19:32:23 <elliott> cmccann: I like "there4", I should use that in conversation
19:32:24 <cmccann> note that some of the symbols in there aren't even legal in Haskell :[
19:32:32 <elliott> there4 u can see that 2 + 2 = 4
19:32:33 <cmccann> as in, they're a lexical error
19:32:40 <elliott> *u can c, I suppose
19:32:43 <cmccann> :D
19:32:47 <shachaf> monochrom: Also useful: 2203 2208 220e
19:32:57 <YayMe> it's half the fun though, not knowing what those symbols are and trying to decipher what the mathy gibber means
19:33:05 <shachaf> Also, I can press Win-U to get a list of all Unicode symbols.
19:33:18 * YayMe must not be very focussed on productive
19:33:32 <cmccann> YayMe, my abbreviations are half mnemonic or actual name, half something short enough that I want to type it :P
19:33:36 <monochrom> that is a very long list
19:33:49 <shachaf> Fortunately it's searchable.
19:34:16 <monochrom> hrm, how do you search it? if you can't type in ∀ yet, you can't search for ∀. chicken and egg.
19:34:43 <shachaf> FOR ALL
19:34:56 <monochrom> alright, that works if you know the official names
19:35:02 <shachaf> Usually you can guess.
19:35:09 <shachaf> Alternatively, you can look for related symbols.
19:35:23 <cmccann> on the bright side having all those abbreviations makes it relatively painless to write stuff like linear logic or use blackboard letters for type names :D
19:36:04 <cmccann> or use greek letters in random places to make things look more like maths, which is clearly important
19:36:21 <typoclass> shachaf: what tool gives you the searchable list?
19:36:34 <elliott> does anyone have nice programs they can use to search unicode and find out character info from the command line, by the way
19:36:41 <elliott> I distinctly recall seeing people use such things and wanting them
19:36:58 <shachaf> typoclass: less -R ~/UNIDATA/unic.txt
19:37:27 * cmccann decides the most important abbreviation in there is "snowman=☃"
19:37:30 <shachaf> Which I generated from a text file you can download from unicode.org.
19:38:04 <typoclass> elliott: you can get the data from unicode.org and do "grep LAMBDA unicode/UnicodeData.txt". it's not terribly convenient, but it's okay for a start
19:38:32 <shachaf> typoclass: See also http://slbkbs.org/unic.txt
19:38:46 <cmccann> I should use snowman more often in my haskell programs.
19:38:47 <shachaf> Er, that's a Perl script that'll search for Unicode.
19:39:00 <elliott> typoclass: sure
19:39:02 <shachaf> Nothing to do with *my* unic.txt
19:39:06 <elliott> so much less fancy though
19:39:20 <napping> elliott: I haven't seen command-line, but emacs has M-x describe-char
19:39:32 <applicative> > let (☃) = foldr in (+) ☃ 0 $ [1..10]
19:39:34 <lambdabot>   55
19:39:35 <napping> which also tells you how to type it, if you can
19:39:53 <typoclass> shachaf: i think we should make an XMonad.Prompt thingy that inserts the character
19:40:14 <shachaf> typoclass: Why does that belong in my window manager?
19:40:36 <monochrom> xmonad is the new sin bin :)
19:41:01 <shachaf> System.IO.XMonad
19:41:17 <shachaf> I wonder where I got that Perl script from.
19:41:21 <typoclass> shachaf: of course it doesn't, but it has a good facility for searching and selecting textish things
19:41:31 <shachaf> Apparently it was written by Larry Wall.
19:41:43 <monochrom> in 2014, xmonad will support XMonad.STM, which lets you update several windows transactionally!
19:41:48 <applicative> > let (☃) = flip runContT in  show ☃ (return 3)
19:41:50 <lambdabot>   "3"
19:41:57 <cmccann> elliott, oh btw you were uh collecting stream processing libraries or something, weren't you?
19:42:20 <YayMe> monochrom: Was that sarcastic?
19:42:28 <monochrom> no
19:42:49 <Jafet> That actually almost sounds useful
19:42:51 <YayMe> xmonad has plans through 2014? Isn't that pretty amazing for open source?
19:42:51 <typoclass> and honestly, i think xmonad is pretty well-structured. it's not like XMonad.Prompt.SomeNewModule is likely to have unpredictable, uncontrollable effects on all of the other modules
19:43:29 <YayMe> typoclass: Isn't that the true of most haskell though? (not the organization part, but the lack of uncontrollable fire-hose effects
19:43:42 <Jafet> But you couldn't use IO to update windows then
19:43:44 <elliott> cmccann: something like that, yes :)
19:44:11 <typoclass> and honestly, i fail to see how adding a well-contained, functional, pure, neat, cute haskell module is so much worse than muddling around with perl scripts :)
19:44:20 <typoclass> YayMe: sure is
19:44:22 <cmccann> elliott, I think I finally ironed out the design mistakes in that library I was working on but haven't had time to go back through and implement everything correctly yet
19:45:24 <elliott> cmccann: neat
19:45:32 <cmccann> elliott, when I do I'll try to remember to toss it at you so you can preserve it in formaldehyde and put it on a shelf or whatever it is you do with these libraries
19:45:46 <elliott> cmccann: I run a stream processing museum
19:46:03 <applicative> are there any familiar cases of someone using cps, in particular Control.Monad.Cont, to good ends in Haskell?
19:46:08 <cmccann> unfortunately the implementation I ended up with will probably make the API more awkward than I'd hoped
19:46:34 <elliott> cmccann: "early functional period, circa early 2000s; primary composed of Haskell and types"
19:46:40 <cmccann> :D
19:47:09 <shachaf> applicative: No use of Control.Monad.Cont ends well.
19:47:23 * applicative has almost overcome his cps - blindness, but is looking for a use...
19:47:27 <shachaf> Anyway, the point of Cont is *not* to use CPS.
19:47:31 <applicative> shachaf: why?
19:48:03 <shachaf> applicative: That's an exaggeration. Many things that people do with Cont can be done with a simpler monad.
19:48:12 <cmccann> elliott, at least trying to build a stream processing library structured around linear logic is moderately novel I think
19:48:16 <applicative> you dont explicitly use it, and you don't use e.g. 'real call-cc', but hm, I'm a neophyte as I said
19:48:53 <applicative> shachaf: yes, I am familiar with such things, and am more interested in them really, e.g. the applications of 'codensity'
19:49:07 <shachaf> applicative: Did you see ezyang's exercises on Codensity?
19:49:40 <shachaf> ...Well, it was pretty much taking a paper and replacing all the definitions with undefined.
19:49:42 <applicative> shachaf: yes, excellent.  it's much more intelligible somehow
19:50:18 <cmccann> applicative, since I was just mentioning it, you could try making sense of my linear logic implementation. :D it's pretty much quasi-CPS transforms all the way down.
19:50:52 <applicative> but again, for example, I would like to  see a codensitized program, where its utility is plain, and so on. the one I know, strangely is in the examples file for the she preprocessor
19:51:17 * cmccann is still hoping to trick someone into figuring out how to implement the exponential operators for his linear logic stuff. :[
19:51:33 <shachaf> What are the exponential operators!
19:51:48 <cmccann> shachaf, ?!
19:52:33 <shachaf> cmccann: Better use ⸘
19:52:42 <shachaf> Maybe I mean ‽
19:52:46 <ahkurtz> interrobang
19:52:50 <cmccann> no, both
19:52:54 <cmccann> one is the dual of the other, obviously
19:52:59 <cmccann> makes sense to me
19:53:04 * applicative knows jack about linear logic.  there is a quotation from L. Lamport which turned  me against it a priori, if groundlessly
19:53:23 <cmccann> applicative, how so? :T
19:53:33 <elliott> @tell donri it works now, thanks!
19:53:33 <lambdabot> Consider it noted.
19:53:52 <elliott> whoah
19:53:57 <elliott> cabal-install doesn't spam about packages building nowadays?
19:54:01 <elliott> it truly is the future
19:54:27 <applicative> cmccann: it was an attack on logicians and philosophers, telling him he can't have a linear logic, when they were wrong about the disposition of the earth and sun....
19:54:28 <shachaf> @telliott hi
19:54:28 <lambdabot> Unknown command, try @list
19:55:29 <monochrom> but you ought to know Phil Wadler's quote, too. it's a paper title, actually. "linear types can change the world!"
19:55:54 <cmccann> Wadler's papers on linear logic are pretty fun
19:56:57 * cmccann doesn't remember seeing anything relevant to linear logic from lamport though?
20:00:40 <applicative> it was just a tirade from umpteen years ago, i think it was on peter hancock's website but it looks like he's retired
20:00:51 <applicative> as an example, I think, of idiocy
20:01:19 <cmccann> are you sure it was about linear logic? seems like lamport's interests are largely unrelated variations of logic
20:03:04 <elliott> google turns up some lamport stuff about temporal logic
20:03:40 <cmccann> which is a very different sort of thing, I believe
20:04:17 * Cale still waiting for cmccann's implementation of Locus Solum to show up on hackage ;)
20:04:53 <Cale> cmccann: Have you seen that paper?
20:05:16 <Cale> http://www.spacelike.net/sites/spacelike.net/IMG/pdf/girard-locus.pdf :)
20:05:55 <Cale> I've never quite been able to decide if it's serious or the most elaborate joke ever.
20:06:16 <cmccann> it can't be both?
20:06:18 * cmccann looks
20:06:25 <Cale> It's probably both
20:07:25 <YayMe> cmccann: You're a C# dev, how do you feel about an attoparsec parser that would identify every namespace, class, and class-reference in a C# code base? I've been playing with the idea as I'm learning attoparsec and had a purpose for such a tool in the past, would you think of purposes for such?
20:07:46 <cornihilio> in Data.Attoparsec.Lazy, what is the String that eitherResult returns?
20:08:06 <shachaf> How long has LTU been down?
20:08:11 <cmccann> YayMe, hm, in theory sure, but in practice it'd probably take more time than I can spare to produce anything of immediate practical use
20:08:42 <cmccann> but having a C# parser written in haskell seems like something that could be useful at some point, sure
20:10:03 <applicative> cmccann: i'm not coming up with anything, maybe i am mixing two things  up; I still don't think so though.
20:10:11 <YayMe> cmccann: I'm not learning haskell for practicality, so it's as good a waste of time for me as anything else :) I've always wanted a way of looking at a bunch of C# that would present it as a code-base diagram, I know these exist, but I've wanted to write one that would allow one to move classes between namespaces/projects quickly, like when we're refactoring a class and move methods around, only at a much higher level
20:11:17 <cmccann> YayMe, then go for it, C# shouldn't be too hard to work with in that regard
20:11:20 <applicative> girard is wonderful
20:11:40 <cmccann> applicative, shrug, not a big deal I guess, but linear logic is pretty neat if you ask me :P
20:12:14 <applicative> cmcann, i have no view of course, just a prejudice that is seeming increasingly groundless :)
20:12:59 <cmccann> applicative, yeah I'm really thinking that whatever you're recalling was about some sort of temporal logic :P
20:13:44 <YayMe> cmccann: aye, curious if you can think of other uses for a C# parse-tree generator as someone who works with it as well
20:13:45 <cmccann> as far as I can tell linear logic is mostly girard's invention with some development by other people
20:13:51 <applicative> cmccann: yes that's the kind of logic he principally goes in for.  I think though that it was not from a paper, but an off the cuff remark recorded by someone.
20:14:12 <cmccann> YayMe, only in the context of more involved static analysis which is a much bigger can of worms than merely parsing it
20:15:06 <cmccann> applicative, fwiw I recall stuff referred to as "linear temporal logic" or such that, from what I can see, have nothing to do with girard's linear logic
20:15:10 <YayMe> cmccann: like what? You just mean static analysis to present some of the guarantees haskell gives?
20:15:16 <Ghoul> Oh god the haskell channel
20:15:21 <Ghoul> giving me headaches on a daily basis
20:15:25 <YayMe> haha
20:15:28 <Ghoul> You use big words like static
20:15:30 <Ghoul> and analysis.
20:15:33 <Ghoul> All at once.
20:15:47 <applicative> cmccann: yes, this thought has occurred to me
20:16:07 <cmccann> YayMe, not to that degree necessarily, but maybe along similar lines
20:16:28 <cmccann> dunno, nothing specific in mind
20:16:40 <cmccann> it'd be a much bigger project than I have time for to do anything useful
20:17:47 <YayMe> cmccann: Another thought that came to mind when playing with this idea recently has been to pre-compile C# so you could write it...differently.. and the parse tree could be spit back out similarly to how it came in, just with..more so you could write C# more tersely
20:18:19 <cmccann> Cale, so anyway... what exactly in here should I be trying to implement? :P
20:18:22 <applicative> yipe here is erik meijer interviewing him.
20:18:40 <Cale> cmccann: I'm really joking, that thing is insane
20:18:46 <cmccann> hahaha
20:19:34 <cmccann> YayMe, well, if memory serves me there's plans to have a lot more transparent access to the compiler in a future release of the language
20:19:51 <cmccann> so some of this you might get officially
20:19:56 <YayMe> cmccann: Yeah, i saw stuff about that at devconnections last year, compiler as a service is coming
20:19:58 <shapr> thetallguy1: Did you ever get dabbrev-expand or hippie-expand working for you?
20:20:52 <cmccann> Cale, I don't know, I could definitely come to like some of the terminology he introduces here. :D
20:21:26 <OceanSpray> GHC 7.6.1 changed type families such that my code won't compile anymore
20:21:43 <OceanSpray> that is, it requires type families to be always fully applied
20:21:51 <OceanSpray> is there a way I can get around this?
20:22:20 * cmccann would need a lot more time to make any sense of this paper though, that's for sure.
20:22:40 <cmccann> OceanSpray, hpaste an example? pretty sure that was always required.
20:22:43 <cornihilio> I'm trying to use eitherResult instead of maybeResult because I want to call the parser again if the stream isn't finished, but eitherResult only returns a String. What should I do? If I use maybeResult I am condemned to getting Nothing and not having a clue as to where to reapply the parse.
20:22:50 <cornihilio> this is in attoparsec
20:23:00 <Cale> cmccann: Yeah, I mean, I think he's actually defining stuff, and it's not just complete gibberish, and on the other hand it seems almost impossible to follow because he just keeps defining more and more and more notation.
20:23:12 <cornihilio> http://hackage.haskell.org/packages/archive/attoparsec/0.8.3.0/doc/html/Data-Attoparsec-Lazy.html
20:23:21 <OceanSpray> https://raw.github.com/niuk/Hammer/master/Common.hs
20:23:25 <OceanSpray> cmccann, this file right here
20:23:35 <OceanSpray> it compiles in 7.4, but not 7.6
20:23:53 <cmccann> Cale, I can get about eight or nine pages in before the notation stops looking familiar :[
20:24:28 <Cale> cmccann: Make sure to check out the glossary
20:24:56 <cmccann> OceanSpray, which line(s)?
20:24:57 <Cale> (which starts about halfway through)
20:25:17 <Cale> LOL "Appendix A. A pure waste of paper"
20:25:28 <OceanSpray> cmccann, 183, 188, 243, 253, 260
20:25:34 <YayMe> I just looked at the table of contents and.. between page 87 and 173 did he just go straight off the rails into the pit of marbles?
20:25:57 <Cale> YayMe: ahahaha
20:26:03 <OceanSpray> ShowArg was defined on line 174
20:26:21 <cmccann> Cale, hahaha
20:26:31 <applicative> cmccann: here is a description of a conference appearance of girard by an acquaintance http://notofcon.blogspot.com/2009/05/martin-lof-conference-on-foundations-of_08.html
20:27:01 <applicative> "For years I’ve wanted to see Girard in action, in fact I’ve been to an event or two to see him only to find that he couldn’t make it."
20:27:28 <applicative> “You have to become commutative to have a notion of mistake”...  -- Girard
20:27:40 <cmccann> girard sounds like an interesting individual
20:29:09 <applicative> cmccann: where is this cpsified linear logic business?  i could do with examples in any case
20:29:27 <cmccann> applicative, just something I hpaste'd a while ago, lemme find it
20:29:43 <cmccann> here: http://hpaste.org/75222
20:30:08 <applicative> ha, youve got the symbols
20:30:09 <shachaf> Get your Agda outta here, man.
20:30:18 <shachaf> This is a wholesome civilized channel.
20:30:30 <cmccann> note that my linear implication is roughly (forall r. a -> (b -> r) -> r)
20:30:35 <applicative> get your agda outa my haskell!
20:30:41 <cmccann> if you strip out the symmetric encoding fluff
20:30:49 <cmccann> and yes
20:30:55 <cmccann> you saw my abbreviations file, right? :P
20:31:06 <shachaf> cmccann: Isn't that isomorphic to (a -> b)?
20:31:28 <shachaf> Well, unless you choose a specific r, I guess.
20:31:33 <applicative> yes, but with a difference
20:32:00 <cmccann> shachaf, I make heavy use of a specific r
20:32:07 <cmccann> I just don't care what that specific r is
20:32:25 <cmccann> that's what all the complicated crap is about
20:32:40 <shachaf> You should flip it: (forall r. (a -> r) -> (b -> r))
20:33:04 <cmccann> you mean (b -> r) -> (a -> r), surely.
20:33:16 <shachaf> Er, yes.
20:33:17 <cmccann> and yes, that's how I actually have it
20:33:20 <cmccann> if you look at the code :P
20:33:23 <shachaf> Yay!
20:33:37 <shachaf> @let cps f = (Prelude.. f)
20:33:38 <lambdabot>  <local>:3:9: Not in scope: `Prelude..'
20:33:44 <shachaf> @let cps f = (P.. f)
20:33:45 <lambdabot>  <local>:3:9: Not in scope: `P..'
20:33:52 <shachaf> @ty (.)
20:33:53 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:33:59 <shachaf> @ty (Prelude..)
20:34:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:34:11 <shachaf> @let cps f = (. f)
20:34:13 <lambdabot>  Defined.
20:34:26 <shachaf> @ty cps
20:34:28 <cmccann> i.e. linear implication (A -o B) is written as (Not A -> Not B) where the resulting CPS-ish encoding lets me abuse things to get the linear logic connectives
20:34:28 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f a -> (a -> b) -> f b
20:34:47 <applicative> haha
20:34:58 <shachaf> newtype Not f r = Not { getNot :: f r -> r }
20:35:09 <shachaf> Hmm.
20:35:24 <cmccann> basically the four connectives work out as (((a, b) -> r) -> r), ((Either a b -> r) -> r), ((a -> r, b -> r) -> r), and (Either (a -> r) (b -> r) -> r)
20:35:31 <applicative> also known as coalgebra?
20:35:37 <applicative> algebra
20:35:41 <cmccann> which are all distinct under the assumption that arguments are used linearly
20:35:55 <shachaf> cmccann: Is there an operator where you have (Either a b) and you can choose either a or b, and the other one becomes false?
20:36:09 <cmccann> not exactly
20:36:18 <shachaf> elliott: ☝
20:36:35 <cmccann> it's more that you can have an (A or B) where you provide a counterexample to one and receive the other as true
20:36:52 <cmccann> i.e., choose one to disprove and the other becomes true
20:36:56 <shachaf> Well, you get that in classical logic too, right?
20:37:06 <cmccann> yes, but here it's constructive
20:37:14 <shachaf> ...By double negation.
20:37:33 <shachaf> Or maybe not.
20:37:38 <cmccann> the law of the excluded middle is another way of writing the identity function in linear logic :]
20:37:40 <bfgun> is there any meaningful concept of debugging for functional languages? ie, an alternative to gdb?
20:37:40 <OceanSpray> okay I am stumped
20:37:52 <bfgun> s/debugging/stepping through code
20:37:59 <shachaf> bfgun: ghci has a debugger but it's kind of weird.
20:38:18 <bfgun> what's weird about it?
20:38:27 <cmccann> OceanSpray, sorry, kinda distracted, not sure what your issue is :T
20:39:00 <cmccann> OceanSpray, what happens if you turn on LiberalTypeSynonyms?
20:39:09 <OceanSpray> cmccann, my issue is that GHC 7.6 pulled the rug out from under me by strictly enforcing the "type synonyms must be always fully applied" rule
20:39:23 <OceanSpray> cmccann, did they add that extension in GHC 7.6 or something?
20:39:31 <cmccann> no, it's been around for ages
20:39:40 <OceanSpray> huh
20:39:43 <cmccann> and I'm not seeing why your code would have worked before
20:39:45 <OceanSpray> never had to use it until now
20:39:49 <OceanSpray> well, it did
20:39:50 <rwbarton> perhaps it is no longer implicitly turned on by some other extension?
20:39:55 <cmccann> that could be!
20:40:12 <rwbarton> that tends to happen (but note i have not even seen your code)
20:40:20 <cmccann> shachaf, anyway it's sort of double negation, depending on what kind of negation you mean
20:40:45 <OceanSpray> nope
20:40:49 <OceanSpray> still doesn't work
20:41:07 <cmccann> shachaf, intuitionistic implication is similar enough to linear implication that it can be a sort of use-by-proxy of the multiplicative disjunction
20:41:11 <rwbarton> where is the paste?
20:41:25 <OceanSpray> rwbarton, https://raw.github.com/niuk/Hammer/master/Common.hs
20:41:32 <OceanSpray> I am working on a small example
20:41:52 * shachaf should probably actually read cmccann's code.
20:42:00 <cmccann> shachaf, thus the arbitrary-but-specific "r" effectively stands in for multiplicative falsehood
20:42:25 <cmccann> so within the linear logic expressions (A -> r) is the linear negation of A
20:43:49 <cmccann> but remains distinct from negation in the intuitionistic sense of implying an uninhabited type, which is the additive falsehood in linear logic
20:44:22 <cmccann> also I'm not sure if anyone else actually cares about any of this :[
20:44:57 * shachaf thinks it's interesting but isn't quite in a position to concentrate right now.
20:45:54 <rwbarton> so why can't I write diag :: x ⊢ x ⊗ x? or can I?
20:46:12 <cmccann> no, because you can't duplicate terms
20:46:29 <OceanSpray> it seems that type classes a.k.a. constraints can be partially applied but type synonyms that result in Constraint can't
20:46:42 <cmccann> I mean, you could write that by putting nonsense inside the Lin constructor, but it's not correct
20:46:54 <cmccann> sadly I can't enforce linear use of terms
20:47:12 <OceanSpray> cmccann, isn't that like
20:47:19 <OceanSpray> 90% of the power of linear logic
20:47:26 <OceanSpray> the enforcement of linear use?
20:47:41 <rwbarton> okay
20:47:54 <cmccann> yes, and 90% of the power of Data.Map is that you can find things because the tree is sorted
20:48:06 <rwbarton> is there some basis of exported terms I can use to build all legitimate values of these "linear" types?
20:48:14 <cmccann> you still have to maintain that invariant yourself when you muck with the representation
20:48:24 <OceanSpray> now hold on
20:48:31 <Tekmo> Can you hide the Lin constructor to guarantee correctness?
20:48:38 <Tekmo> Are the primitives you provided sufficient?
20:48:51 <cmccann> if the Lin constructor is hidden then yes, I think everything should be correct
20:48:53 <rwbarton> I guess it's not clear to me why I can't just write Lin = (->)
20:48:57 <OceanSpray> cmccann, okay then
20:49:05 <rwbarton> what advantage does all this have
20:49:05 <cmccann> though I dunno, you can probably break stuff because of undefined, as always
20:49:08 <dolio> How come for all A, hom(A, A ⊗ A) doesn't have an element in every symmetric monoidal category?
20:49:09 <rwbarton> sure
20:49:34 <OceanSpray> rwbarton, because (->) isn't linear lambda
20:49:35 <cmccann> Tekmo, and I think I might be missing a few primitives just because I got sick of writing out structural rules
20:49:37 <rwbarton> dolio: right, that is my question, I can write the Lin value for it manually
20:49:57 <OceanSpray> (I only skimmed cmccann's code)
20:49:58 <rwbarton> OceanSpray: but...
20:50:05 <rwbarton> I guess I just don't understand what problem exactly this is trying to solve
20:50:17 <cmccann> it's solving a problem? :]
20:50:19 <OceanSpray> the "problem" is resource management
20:50:25 <cmccann> this code was just me tinkering, mostly
20:50:30 <Tekmo> rwbarton
20:50:31 <rwbarton> right, ok
20:50:32 <OceanSpray> when you have some sort of thing that should only be used exactly once
20:50:38 <Tekmo> Imagine how you would "hide" a value brought into scope in Haskell
20:50:39 <cmccann> I have some ideas for practical use of linear logic but this is not one of them
20:50:40 <OceanSpray> that's when you use linear logic
20:50:47 <OceanSpray> like, say
20:50:55 <Tekmo> Like a Handle
20:50:59 <OceanSpray> the pointer you get from malloc
20:51:00 <Tekmo> Once a Handle is dead
20:51:09 <Tekmo> you want there to be no references to the Handle in scope
20:51:15 <rwbarton> right, I am generally vaguely familiar with linear logic (and much more so with symmetric monoidal categories)
20:51:21 <rwbarton> I just don't understand what *this code* is trying to do
20:51:49 <cmccann> rwbarton, if the Lin constructor is hidden it is (or should be) a complete model of linear logic's computational content
20:51:50 <Tekmo> He's trying to implement linear logic in Haskell
20:52:03 <rwbarton> that is not a very specific statement :)
20:52:05 <Tekmo> Presumably, you might even be able to generalize it to some monadic version
20:52:14 <OceanSpray> alright
20:52:17 <Tekmo> to implement type-safe resource closing
20:52:18 <OceanSpray> who here still runs ghc 7.4?
20:52:22 <Tekmo> Me
20:52:30 <rwbarton> the statement should be of the form "the values I can construct of type ___ using the operations ___ are all those valid values of the form ___"
20:52:50 <JoeyA> Me
20:52:53 <rwbarton> or whatever similar form of statement is applicable
20:52:54 <OceanSpray> okay, hold
20:53:32 <hpaste> OceanSpray pasted “compiles in 7.4 but doesn't in 7.6” at http://hpaste.org/75849
20:53:39 <OceanSpray> Tekmo, JoeyA
20:53:44 <OceanSpray> try compiling that hpaste
20:53:48 <cmccann> rwbarton, without access to the Lin constructor the values you can construct using the primitives should be all (and only) values representing true formulas of linear logic
20:53:49 <OceanSpray> tell me what you get
20:54:02 <JoeyA> Some of us have multiple GHCs installed
20:54:11 <rwbarton> cmccann: okay, thanks
20:54:20 <OceanSpray> well, try it in 7.4 and 7.6 and tell me what they say
20:54:27 <Ghoul> Haskell is so technical
20:54:35 <Tekmo> OceanSpray: Compiles without a hitch
20:54:35 <cmccann> rwbarton, which is the logic of a *-autonomous category according to nlab
20:54:37 <Ghoul> yet somehow much slower than other languages in benchmarks
20:54:38 <OceanSpray> SEE
20:54:41 <OceanSpray> I TOLD YOU
20:54:53 <OceanSpray> Tekmo has confirmed: 7.6 messed things up
20:55:01 <JoeyA> I get the same thing.  Works in 7.4, but not in 7.6
20:55:01 <cmccann> although the representation I used is more based on the description in terms of "polycategories" I found on nlab
20:55:02 <rwbarton> OceanSpray: where in the code is the error reported by 7.6?
20:55:06 <JoeyA> compiles, that is
20:55:10 <cmccann> which is the same thing in the end apparently
20:55:29 <OceanSpray> rwbarton, in that hpaste, should be line 15
20:55:43 <OceanSpray> where it tries to apply the type synonym for the constraint
20:55:48 <JoeyA> "Type synonym `Bar' should have 1 argument, but has been given none"
20:56:27 <OceanSpray> thing is, I can't even manually expand the synonym in my actual code
20:56:31 <JoeyA> Compiles if you say "type Bar = Ord" instead of "type Bar a = Ord a"
20:56:48 <OceanSpray> well
20:57:08 <OceanSpray> in my code I have "type Bar a = (Baz a, Quux a)"
20:57:15 <OceanSpray> so I can't really use that transformation
20:57:24 <cmccann> rwbarton, and fwiw the primary motivation for it was because I wanted an intuition-building exercise for computational interpretation of linear logic
20:57:51 <OceanSpray> unless there's some weird type-level combinator that does that for me
20:58:10 <JoeyA> I think the issue is that you can't partially apply type aliases.  Right?
20:58:17 <Tekmo> Right
20:58:26 <OceanSpray> well, I could before and suddenly I can't and now I'm sad
20:58:33 <Tekmo> I'm surprised you could before
20:58:51 <OceanSpray> the code worked, too
20:58:55 <Tekmo> This is why I have to keep all my type synonyms as minimal as possible
20:58:56 <OceanSpray> like, ran exactly as expected
20:59:04 <rwbarton> instance forall a. Top a ShowArg => Show (Case a) where -- this is the offending line in the file from github?
20:59:10 <OceanSpray> rwbarton, yes
20:59:13 <OceanSpray> and several others like it
20:59:22 * cmccann is still in the "doesn't see why OceanSpray's code ever compiled in the first place" camp.
20:59:33 <rwbarton> I didn't know you could put "forall a." there
20:59:34 <JoeyA> You could submit a bug report, so some guy named Simon Peyton Jones can look into it.
20:59:36 <rwbarton> incidentally
20:59:40 <JoeyA> I heard he's really into Haskell.
20:59:59 <OceanSpray> I guess I could rewrite my definition of "Top" to hardcode my constraints
21:00:09 <OceanSpray> but that's really fucking ugly
21:00:14 <cmccann> I'll take your word that it did compile before but it still surprises me
21:00:28 <OceanSpray> the hpaste compiled, so why wouldn't my code?
21:00:30 <rwbarton> well the ironic thing is that Top is itself a closed type family and you could expand the occurrences of f in each RHS and then the whole thing is fine
21:00:42 <rwbarton> your code compiled in 7.4 for me yeah
21:01:24 <rwbarton> oh
21:01:59 <OceanSpray> alternatively, I could write instead:
21:02:09 <JoeyA> Has anyone made a library for tainting IO actions with various properties?  E.g. interruptible, never blocks, etc.
21:02:24 <JoeyA> Atomic
21:02:35 <acyed> hello everyone. Can someone tell me how to write a let expression in a where block?
21:02:37 <Tekmo> What would be the use for it?
21:02:38 <OceanSpray> forall a. (Top a From, Top a (Show . Arg)) => ...
21:02:56 <Tekmo> A let expression should work just fine in a where block
21:03:02 <OceanSpray> except that (Show . Arg) thing
21:03:05 <Tekmo> It's just a matter of getting indentation correct
21:03:07 <OceanSpray> gah
21:03:41 <OceanSpray> no, I think he's acyed is actually asking for a let expression in his where block
21:03:44 <rwbarton> well I started writing this out and it got way out of control
21:03:47 <OceanSpray> like, not as part of an expression inside it
21:03:47 <Tekmo> you mean like:
21:03:52 <Tekmo> where let a = ...
21:03:54 <OceanSpray> yes
21:03:56 <Tekmo> Oh
21:03:57 <acyed> yes
21:04:05 <acyed> is that possible?
21:04:06 <OceanSpray> which is, actually, kind of...
21:04:09 <OceanSpray> incomprehensible
21:04:13 <rwbarton> but if ghc expands the type family Top twice, and then substitutes the definition of ShowArg, everything is hunky-dory
21:04:13 <OceanSpray> why would anyone want that?
21:04:20 <Tekmo> I think the best explanation is that it's not sensible
21:04:25 <Tekmo> I'm trying to figure out how to explain it
21:04:29 <OceanSpray> rwbarton, what do you mean
21:04:37 <Tekmo> It would sort of be like saying
21:04:41 <Tekmo> "where where ..."
21:04:44 <OceanSpray> acyed, "let" makes an expression
21:04:55 <OceanSpray> acyed, "where" is used for declarations
21:05:14 <Tekmo> Here's how I think of it
21:05:19 <OceanSpray> if you want to have a "sub-scope" within your let, just use another let
21:05:22 <rwbarton> well what LiberalTypeSynonyms does is it means that if I try to pass a partially-applied type synonym to another type synonym, it will expand the outer type synonym first, and if that causes the original partially-applied type synonym to be fully applied, it accepts the expansion
21:05:22 <Tekmo> where is like a let expression
21:05:27 <Tekmo> it expect something of the form:
21:05:27 <hpaste> Acyed pasted “where let” at http://hpaste.org/75850
21:05:30 <rwbarton> right?
21:05:31 <Tekmo> where var = expr
21:05:40 <Tekmo> "lets" can go in the "expr" part
21:05:42 <OceanSpray> rwbarton, I don't know
21:05:44 <Tekmo> but not the "var" part
21:05:48 <elliott> LiberalTypeSynonyms is yucky
21:05:54 <OceanSpray> I've never used, or had to use, liberaltypesynonyms
21:06:00 <cmccann> LiberalTypeSynonyms is fun :D
21:06:09 <acyed> sorry for the noob questions
21:06:15 <cmccann> even if I can't write the ackermann function on church numerals with it :[
21:06:16 <Tekmo> No need to apologize!
21:06:18 <elliott> OceanSpray: you are using it by way of relying on its behaviour
21:06:21 <Tekmo> Noob questions are the best questions!
21:06:27 <elliott> even if you didn't explicitly turn it on, I guess something else did for you
21:06:29 <OceanSpray> rwbarton, can you paste some code that shows it in action?
21:06:40 <rwbarton> so I start with Top a ShowArg, that is (by expanding the Top type family "synonym" twice) some unholy mess involving lots of occurrences of ShowArg, but in every occurrence it is applied to an argument, so after that type synonym expansion can continue and expand all the occurrences of ShowArg
21:06:45 <rwbarton> sure, one moment
21:07:17 <OceanSpray> rwbarton, but I turned on liberal type synonyms and Common.hs still wouldn't compile
21:07:47 <OceanSpray> neither does the hpaste, for that matter
21:07:54 <hpaste> rwbarton pasted “LiberalTypeSynonyms example” at http://hpaste.org/75851
21:08:12 <rwbarton> so the difference in your case is that Top is a type family
21:08:26 <rwbarton> sorry, not Top, Level
21:08:44 <rwbarton> everywhere I said "Top type family" read "Level type family"
21:09:06 <acyed> so how would I define len in my paste?
21:09:40 <rwbarton> if type family expansion is interleaved with type synonym expansion then I would expect your program to be accepted
21:09:59 <Tekmo> acyed: just remove the "let"
21:10:05 <OceanSpray> then I guess that's what they changed in 7.6
21:10:09 <Tekmo> the "where" acts like a "let"
21:11:28 <OceanSpray> I honestly don't know what to do anymore
21:11:36 <Tekmo> "myExpr = let y = 2 in y" is the same thing as "myExpr = y where y = 2"
21:11:45 <OceanSpray> I really really don't want to manually expand the constraint synonym
21:11:53 <rwbarton> let me see if I can cook up a minimal example of your issue
21:11:54 <cornihilio> I'm having a lot of trouble figuring out how lazy attoparsec works. Specifically, I don't get how I'm supposed to use maybeResult, since a failed parse will only return Nothing, and in the perfect world I'd think I'd want to be using something that returned the parse stream in case I wished to continue parsing despite a single failed match.
21:12:06 <applicative> OceanSpray: hah, I tried LiberalTypeSynonyms on your file a while back
21:12:41 <Tekmo> cornihilio: Do you mean keep parsing when it runs out of input or keep parsing if it failed in the middle of the parse?
21:12:59 <applicative> cornihilio: do you have somethign you could paste on hpaste.org  people are likely to get a clearer idea
21:13:21 <cornihilio> Tekmo: well that's my entire problem really. It seems like I get the Nothing either way.
21:13:35 <Tekmo> The correct solution in principle is to use "<|>" or some equivalent
21:13:43 <Tekmo> That's how you define alternative parsers to try if one fails
21:13:54 <Tekmo> You can import "<|>" from Control.Applicative
21:13:58 <cornihilio> sorry, here's a gist: https://gist.github.com/3843790
21:14:49 <hpaste> rwbarton annotated “compiles in 7.4 but doesn't in 7.6” with “compiles in 7.4 but doesn't in 7.6 (annotation)” at http://hpaste.org/75849#a75852
21:14:52 <Tekmo> So let's assume that I have two parsers, p1 and p2.  I want to use p2 if p1 fails.
21:14:52 <cornihilio> I just hoogled <|> and that page is meaningless to me. If wanted to look it up in rwh, where would I find it?
21:15:05 <Tekmo> The way you express that is to say p1 <|> p2
21:15:13 <Tekmo> For parsers, it signifies "Try p2 if p1 fails"
21:15:14 <rwbarton> OceanSpray, curiously this very similar example doesn't work for me in 7.4
21:15:40 <cornihilio> so I want something like foo stream = bar stream <|> foo stream?
21:15:45 <dada_cetacean> omg, the height of a tree is just treeDepth (Node x (y) (z)) = 1 + max (treeDepth y) (treeDepth z)
21:15:47 <dada_cetacean> it's like magic!
21:15:49 <OceanSpray> rwbarton, does liberal type synonyms work?
21:15:53 <rwbarton> oh
21:15:53 <Tekmo> Here's an example:
21:15:54 <rwbarton> haha
21:16:05 <Tekmo> string "foo" <|> string "bar"
21:16:08 <rwbarton> no, it didn't help
21:16:23 <Tekmo> That will try to parse the string "foo", and if that fails it will instead backtrack and try to parse the string "bar" instead
21:16:49 <OceanSpray> I don't like how "<|>" seems like it's commutative but it's not
21:16:54 <Tekmo> Yeah
21:16:55 <Tekmo> I hate that
21:17:01 <OceanSpray> they should use a non-symmetric operator symbol
21:17:53 <cornihilio> Tekmo: ah, well that certainly is helping me understand it. but what do you mean when you mention backtracking?
21:18:24 <Tekmo> cornhilio: Backtracking means it returns to the location in the input it started the first failed parse at
21:18:46 <Tekmo> cornhilio: So let's say I have the following text to parse" somethingfooxx
21:18:59 <Tekmo> and the parse "cursor" is between something and foo, like this:
21:19:02 <Tekmo> something*fooxx
21:19:09 <YayMe> OceanSpray: just (<[>) = <|>
21:19:21 <YayMe> OceanSpray: problem solved. and a good idea actually.. I like it..
21:19:24 <Tekmo> If I gave it the parser: string "bar" <|> string "foo"
21:19:32 <OceanSpray> I don't think brackets are allowed in operators, dude
21:19:35 <Tekmo> it would first attempt to parse "bar"
21:19:43 <Tekmo> in this case, it does not consume any input in the failed attempt
21:19:53 <Tekmo> Here, let me use an example that does
21:20:02 <Tekmo> string "for" <|> string "foo"
21:20:07 <cornihilio> well, no I think I get a much better idea of it.
21:20:14 <Tekmo> You could imagine that the first parser consumes "fo" before failing
21:20:22 <Tekmo> if it fails, it returns back to before the "f"
21:20:27 <Tekmo> and then tries to parse "foo" instead
21:21:00 <Tekmo> In practice, the "string" operator in attoparsec is atomic, so there is no partial consumption of input
21:21:05 <Tekmo> ... but you still get the idea
21:21:16 <OceanSpray> maybe I should just rewrite the whole thing in Agda
21:21:24 <OceanSpray> that'd make things so much simpler
21:21:36 <Tekmo> Haskell: The gateway drug to Agda
21:21:41 <YayMe> @src Either
21:21:41 <lambdabot> Source not found. Wrong!  You cheating scum!
21:21:50 <hpaste> Acyed annotated “where let” with “where let (annotation)” at http://hpaste.org/75850#a75853
21:21:57 <acyed> success!
21:22:07 <cornihilio> ah, thank you. that has been very helpful. however, I don't really get how that works in my case. for me, since I'm only looking for a specific parse object (or one foo) what should I do? string "foo" <|> string "foo"?
21:22:13 <OceanSpray> I certainly won't have to wrestle with a type system that won't let me use lambdas anymore
21:22:16 <Tekmo> acyed: Congratulations!
21:22:27 <Tekmo> acyed: Just remember that "where" is just a post-fix "let"
21:22:35 <elliott> (except that "where" is not an expression)
21:22:46 <YayMe> > Either "bla"
21:22:47 <lambdabot>   Not in scope: data constructor `Either'
21:22:48 <OceanSpray> yeah you can't write (x where x = 42)
21:22:58 <elliott> OceanSpray: though you could in very old versions of Haskell
21:23:04 <elliott> and there was no "let", I think, just "where" expressions
21:23:11 <acyed> Tekmo, thanks! I'm sure there's a simpler solution
21:23:14 <Tekmo> If you are only looking for one specific parse, then just put that parse: string "foo"
21:23:28 <Tekmo> cornihilio: If the parse fails, the entire parser should fail
21:23:49 <Tekmo> cornhilio: The idea is that you specify the entire parser up front before you parse anything
21:25:19 <dada_cetacean> is there a way to define a type for trees with arbitrary and varying numbers of children at each level, besides taking the maximum number of children at any given level and simply describing it as a very large n-ary tree with lots of empty nodes?
21:25:42 <Tekmo> Can you just keep a list of children?
21:26:01 <Tekmo> data Tree a = Node a [Tree a] | Leaf
21:26:45 <cornihilio> Tekmo: well in my code I have "AL.parse packetValue p", but I really want to say keep parsing even if a parse fails, but I can't do that in the return statement because I'm using maybeResult.
21:26:51 <OceanSpray> man, the agda devs must be so very frustrated
21:27:21 <OceanSpray> "hey I'll just use <advanced type technique> here OH WAIT I FORGOT I WAS IN HASKELL"
21:27:34 <dada_cetacean> Tekmo: thanks!
21:27:47 <Tekmo> dada_cetacean: You're welcome!
21:28:19 <Tekmo> cornihilio: Ok, just give me a second to study your code more closely
21:29:46 <rwbarton> OceanSpray, does http://hpaste.org/75854 build for you?
21:29:58 <rwbarton> replacing the definitions of Level and Top
21:30:32 <Tekmo> cornihilio: Instead of "satisfy (== 'A')", you can use "char 'A'"
21:30:35 <OceanSpray> rwbarton, nope
21:30:45 <OceanSpray> wait
21:30:47 <Tekmo> Or it might have a different name
21:30:55 <OceanSpray> you want me to replace my code with this snippet
21:30:58 <OceanSpray> okay hold
21:31:00 <rwbarton> and with LiberalTypeSynonyms I guess
21:31:02 <rwbarton> yes
21:31:17 <cornihilio> Tekmo: thank you so much for taking your time to help me with this! I feel terrible pestering this channel, but this material is so over my head at times I feel like I'm doing xenolinguistics.
21:31:34 <Tekmo> cornhilio: Don't worry.  I felt the same way when I first learned Haskell
21:31:37 <Ralith> cornihilio: we've all been there.
21:31:48 <OceanSpray> rwbarton, wait
21:31:50 <Ralith> and we're happy to help, so don't stress
21:31:53 <OceanSpray> I don't understand what the change is
21:31:58 <OceanSpray> besides swapping around the parameters
21:32:05 <Tekmo> cornihilio: The "char" function here is simpler than satisfy: http://hackage.haskell.org/packages/archive/attoparsec/0.10.2.0/doc/html/Data-Attoparsec-ByteString-Char8.html#v:char
21:32:09 <OceanSpray> so that the natural is first instead of last
21:32:49 <rwbarton> well I also made it into an associated type of a class...
21:32:53 <Tekmo> cornihilio: Ok, here's what you do
21:32:56 <rwbarton> and made f not be an index of the type family
21:33:00 <OceanSpray> OH
21:33:02 <OceanSpray> now I see it
21:33:04 <Tekmo> cornihilio: If you want to count the packets, you can do it directly within the parser
21:33:10 <rwbarton> because I don't understand standalone type families really
21:33:24 <OceanSpray> funny
21:33:30 <rwbarton> I can provide a patch instead if you like
21:33:34 <OceanSpray> I don't understand type family indices
21:33:58 <Tekmo> cornihilio: Give me a second to get the definition correct.  Hold on
21:34:28 <OceanSpray> somehow I always mistakenly try to use the associated type outside of the typeclass
21:34:31 <rwbarton> well the reason I thought it might work is that if I see "class Foo a where type Bar a b c" I know I don't need to know what c is to expand the type family if I know a
21:34:44 <rwbarton> I don't know how to express that with standalone type families
21:34:46 <OceanSpray> resulting in me just turning every associated type into a standalone type family
21:35:02 <Tekmo> cornihilio: Define this: howMany p = fmap length (many p)
21:35:08 <rwbarton> did it work?
21:35:16 <OceanSpray> rwbarton, hold
21:35:55 <Tekmo> cornihilio: That "howMany" function takes a parser "p", it uses the "many" function to apply it as many times as possible, returning a list with one element per successful parse, and then just calculates the length of that list
21:37:10 <dolio> rwbarton: That's not true.
21:37:14 <OceanSpray> rwbarton, nope
21:37:25 <OceanSpray> didn't work, same error
21:37:28 <cornihilio> Tekmo: is that a curried function expecting the stream implicitly?
21:37:29 <rwbarton> what is not true?
21:37:32 <OceanSpray> looks like I have to manually expand
21:37:48 <OceanSpray> this is... less than optimal
21:38:02 <Tekmo> cornihilio: Let me first write the general type of the function, then specialize it to parsers.
21:38:18 <dolio> rwbarton: GHC has no problem with "instance Foo Int where type Bar Int String String = String ; type Bar Int String Char = Char ; ...".
21:38:20 <Tekmo> cornihilio: The general type of "howMany" is: howMany :: Alternative f => f a -> f Int
21:38:31 <rwbarton> oh
21:38:46 <Tekmo> cornihilio: For the specific case of parsers, "f = Parser", so the type specializes to: howMany :: Parser a -> Parser Int
21:39:14 <rwbarton> dolio: that seems odd to me but okay
21:39:22 <dolio> Unless that changed in 7.6
21:39:48 <Tekmo> cornihilio: So the trick is you actually move the "countpackets" logic directly into the parser
21:40:02 <dolio> It complains if you don't put any instance at all, but that just seems to be a warning.
21:40:03 <Tekmo> cornihilio: You would just write
21:40:07 <rwbarton> I wish all this type family stuff was documented a lot better
21:40:19 <rwbarton> or maybe I have just not looked in the right places
21:40:35 <Tekmo> cornihilio: countPackets = AL.parse (howMany parsePacket)
21:40:49 <Tekmo> Or something pretty close to that
21:41:39 <dada_cetacean> is there a standard function in Haskell analogous to Mathematica's Part[xs,i] function?
21:41:55 <Tekmo> What does Part do?
21:42:08 <Tekmo> @src splitAt
21:42:08 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
21:42:10 <dada_cetacean> take the i'th element of a list
21:42:21 <dada_cetacean> oh, that works
21:42:21 <Tekmo> @src (!!)
21:42:22 <lambdabot> xs     !! n | n < 0 = undefined
21:42:22 <lambdabot> []     !! _         = undefined
21:42:22 <lambdabot> (x:_)  !! 0         = x
21:42:22 <lambdabot> (_:xs) !! n         = xs !! (n-1)
21:42:29 <cornihilio> Tekmo: thank you so much! the idea of moving the counting into the parser is insane.
21:42:51 <Tekmo> cornihilio: Yeah, it's pretty cool.  Parsers don't have to just return Strings.   They can return anything, because they are monads
21:43:23 <dada_cetacean> heh, drop (n-1) (take n xs)
21:44:11 <Tekmo> dada_cetacean: If you just want the ith element, then use (!!)
21:44:21 <Tekmo> dada_cetacean: But I should warn you that indexing into lists is not idiomatic Haskell
21:48:22 <Tekmo> cmccann: I'm on my laptop with the broken mouse, so I can't see the message you just sent
21:48:27 <cmccann> heh
21:48:59 <cmccann> was just wondering if you were interested in seeing any of my work-in-progress stuff on stream processing
21:49:06 <Tekmo> Of course I am
21:49:22 <cmccann> figure that if anyone could give practical feedback at the moment it'd be you :P
21:49:48 <Tekmo> Just paste the link.  I can still type it out by hand
21:50:40 <cmccann> ok, gonna extract a snippet that shows the rough idea without some of the junk I was experimenting with
21:51:48 <hpaste> “C. McCann” pasted “half-baked stream processing stuff” at http://hpaste.org/75855
21:52:23 <cmccann> if memory serves me there was something in this that didn't really work quite right but it's been a while since I had time to tinker with it
21:52:59 <cmccann> pretty sure the basic structure is fine though
21:53:42 <Tekmo> Ok, so I'll just sort of talk out loud as I study it
21:54:16 <cmccann> also the naming scheme is weird due to being a holdover from a much earlier version of the whole thing before I realized that linear logic would be a good model for what I was doing
21:54:53 <Tekmo> If you universally quantify r, you'd have something isomorphic to "data Linear f a = Free? (f (Linear f a)) | Something? a (Linear f a)
21:55:43 <Tekmo> It resembles a free monad, except you have an extra term in the "Pure" constructor
21:56:03 <cmccann> I had repeated headaches involving where to draw the line of quantifying over the result type
21:56:42 <Tekmo> You would quantify it as if it were the church encoding of the above type
21:56:55 <Tekmo> Linear { getLinear :: forall r . ... }
21:57:20 <cmccann> that doesn't work though
21:57:29 <cmccann> I need the "r" to be consistent through an entire stream, not just a step
21:58:33 <cmccann> so the quantifier has to be outside the Free/Fix that stacks them up
21:58:48 <Tekmo> Let me study await and yield to get the gist of what you are doing
21:59:12 <cmccann> the non-stream encoding from before is probably clearer
21:59:43 <cmccann> as I said in one of the comment blocks, there's an extra disjunction in there
22:00:06 <Tekmo> It's ok, just give me some time
22:00:08 <Tekmo> I'll figure it out
22:00:55 <cmccann> and (Linear f r a) here is equivalent to (Lin (f ⅋ Var a)) except the "r" isn't universally quantified
22:01:48 <cmccann> and it really bugs me that I can't figure out how the exponentials should fit into this because it (seems (?)) obvious that something in this encoding relates to them :T
22:03:33 <cmccann> in particular the endless disjunction this expands to is pretty much what the ? operator means, I think
22:03:43 <BENGY77> http://posatori.com/videos/Naughty-Babysitter-loves-to-play/
22:04:18 <cornihilio> wanting to turn countPackets :: L.ByteString -> AL.Result Int into countPackets :: L.ByteString -> Int is called lifing, right?
22:04:29 <Tekmo> cmccann: The part that seems weird is that you special case the "yield" case
22:04:53 <cmccann> Tekmo, how so?
22:05:07 <Tekmo> So here's how I understand your type
22:05:21 <Tekmo> Your Linear type basically says that you either "yield" or you step through the functor "f"
22:05:25 <Tekmo> and there is no "pure"
22:05:34 <cmccann> not quite
22:05:36 <Tekmo> I mean
22:05:39 <Tekmo> I get that Free adds it
22:05:39 <cmccann> it more says that you do both
22:05:44 <Tekmo> So it's a single step of the free monad
22:05:50 <Tekmo> And the right continuation
22:05:53 <Tekmo> is your yield continuation
22:06:00 <Tekmo> and the left continuation is some parametrizable functor
22:06:11 <cmccann> and note that there is actually an Applicative instance for Linear here, which surprised me
22:06:33 <cmccann> the "f" in Linear is not a functor, actually
22:06:42 <cmccann> I mean, it might be, but in general it isn't
22:07:12 <Tekmo> Well, it needs to be for the monad instance when you wrap it in Free
22:07:28 <Tekmo> The way I understand your linear type, it is basically
22:07:28 <cmccann> no, the "f" in Linear is unrelated to that
22:07:39 <Tekmo> Oh
22:07:59 <cmccann> and yes I realize this is confusing
22:08:42 <cmccann> I still have a hard time convincing myself that the whole thing actually works but all the simple test streams I've constructed by hand did what they claimed
22:09:18 <dada_cetacean> how do I write a type signature for a function with a conditional expression that gives type A when true and type B when false?
22:10:16 <Tekmo> dada_cetacean: Use "Either" to wrap the values
22:10:17 <JoeyA> dada_cetacean: You can use Either
22:10:26 <Tekmo> dada_cetacean: Wrap one value in "Left" and the other in "Right"
22:10:46 <cmccann> Tekmo, remember that each step is a multiplicative disjunction, which means something like "give a counterexample to one half to extract the other". running the stream assigns the element type as the final result, which sort of makes them self-negating in a way
22:10:47 <JoeyA> > let f False = Left "string"; f True = Right 5 in (f False, f True)
22:10:48 <lambdabot>   (Left "string",Right 5)
22:11:09 <cmccann> and using that it can recursively extract the other half, which is a "result" value together with the tail of the stream
22:11:25 <Tekmo> cmccann: I prefer not to think about what it "means".  I just follow the flow of symbols
22:11:36 <dada_cetacean> tekmo'
22:11:38 <dada_cetacean> is a formalist
22:12:23 <cmccann> ok then, but following the flow is tricky here :P
22:13:49 <Tekmo> cmccann: I've debugged worse code.  Don't worry :)
22:14:03 <cmccann> you might have more luck starting from the bottom, where I define a simple stream and a specialized "runStream" function
22:15:31 <cmccann> (it might also help to look at the actual logical rules of linear logic, without the clutter introduced by my encoding)
22:16:35 <cmccann> the presentation used in http://plato.stanford.edu/entries/logic-linear/ is probably the most helpful in this context I think
22:16:46 <Tekmo> cmccann: Yeah, I'm studying your stream functions
22:21:37 <Tekmo_> camccann: I have to go right now, but I will discuss it more tomorrow
22:21:45 <cmccann> heh, ok.
22:21:50 <cmccann> I should head to bed anyway.
22:21:59 <Tekmo_> Alright, see you later
22:24:11 <Nereid> discovery of the day: Text.InterpolatedString.Perl6
22:28:06 <cornihilio> what is wanting to turn "countPackets :: L.ByteString -> AL.Result Int" into "countPackets :: L.ByteString -> Int" called?
22:29:44 <johnw> I think your question is, what is AL.Result Int -> Int called?
22:29:51 <johnw> because then you can compose that with the first function
22:30:05 <johnw> if AL.Result were a Comonad, the name would be "extract"
22:30:09 <cornihilio> yes, that is my question. what do you mean by compose?
22:30:22 <johnw> countPackets . yourNewFunction :: L.ByteString -> Int
22:31:25 <cornihilio> should I want to compose? or should I try and find a method for turning the original function into that?
22:31:32 <johnw> you should compose
22:31:38 <johnw> that is the nature of the functional style
22:31:51 <cornihilio> what do you mean?
22:32:02 <johnw> if you have one function a -> b, and another function b -> c, composition lets you very simply create a new function a -> c
22:32:20 <cornihilio> but why not just make a function that does a -> b -> c?
22:32:32 <Nereid> because that's not what you think it is
22:32:50 <cornihilio> err a -> c?
22:32:57 <Nereid> you are
22:33:03 <Nereid> by composing a -> b and b -> c
22:33:49 <johnw> where a :: L.ByteString, b :: AL.Result Int, and c :: Int
22:33:52 <cornihilio> but what's the point of introducing b if you just want to get rid of it?
22:34:06 <Nereid> you already have a -> b
22:34:07 <johnw> because that way you don't have to write a brand new function :)
22:34:23 <johnw> however, if going directly from a -> c truly is more optimal, sometimes you do want to write that function anew
22:34:32 <Nereid> surely it's easier to write AL.Result Int -> Int and composite than to rewrite countPackets
22:34:35 <johnw> but that is fairly rare, in my experience
22:34:39 <Nereid> compose it*
22:34:40 <Nereid> not composite
22:35:29 <johnw> assuming AL.Result were a Comonad, all you'd have to write here would be: countPackets . extract, and boom, you have the original function you wanted
22:36:01 <Nereid> what if it was the identity comonad?
22:36:06 <johnw> and once the compiler's optimizer gets a look at everything, it's going to be pretty optimal
22:36:26 <johnw> Nereid: even then it would have the correct type
22:36:30 <BMeph> johnw: The other way around. :)
22:36:34 <Nereid> I know, I'm being silly.
22:36:38 <Nereid> but anyway
22:36:41 <johnw> BMeph: ?
22:36:48 <Nereid> I'm guess AL.Result is Dada.Attoparsec.Lazy.Result
22:36:50 <Nereid> in which case
22:36:50 <johnw> oh, sorry
22:36:51 <Nereid> you can't
22:36:54 <johnw> extract . countPackets
22:36:56 <Nereid> Data*
22:37:07 * BMeph nods
22:37:07 <johnw> i was thinking in the wrong direction!
22:37:17 <Nereid> I was going to say something about that but meh
22:37:33 <Nereid> cornihilio: there's a reason it returns an AL.Result
22:37:47 <Nereid> ... AL.Result Int
22:38:47 <cornihilio> Nereid: how does the type being attoparsec's lazy result influence what you were trying to say about composition?
22:39:32 <Nereid> cornihilio: because what if the result is failure
22:44:19 <cornihilio> okay, well now I am back to where I was when I came into this channel :( https://gist.github.com/3844093
22:44:50 <cornihilio> after the first failed parse it gives up. am I misusing maybeResult?
22:45:17 <cornihilio> the function I am stuck on is called countPackets
22:47:05 <johnw> case x of Just x -> x; Nothing -> 0 can be written: fromMaybe 0 x
22:47:26 <johnw> i should have use case y there
22:47:30 <johnw> the x's are not the same
22:47:53 <johnw> anyway, are you perhaps throwing away the remainder of the input?
22:48:14 <johnw> i'm not sure what's happening here
22:48:30 <Puffton> Does infix operators only work on functions with two arguments?
22:48:48 <Puffton> I mean using a function "infix"
22:49:23 <rwbarton> well in a line of text a thing cannot be between more than two other things
22:49:26 <rwbarton> so yes
22:49:34 <rwbarton> but you can write (a % b) c
22:49:58 <Puffton> what does that mean?
22:49:59 <Nereid> @type maybe id 0
22:50:01 <lambdabot> forall a a1. (Num a) => Maybe a1 -> a -> a
22:50:05 <Nereid> oops.
22:50:09 <johnw> a % b yields a function taking one argument
22:50:10 <rwbarton> it is just the application of (a % b) to c naturally
22:50:16 <Nereid> @type maybe 0 id
22:50:17 <lambdabot> forall a. (Num a) => Maybe a -> a
22:50:17 <rwbarton> so it could also be written (%) a b c
22:50:37 <Nereid> > map (maybe 0 id) [Just 3, Just 5, Nothing]
22:50:38 <lambdabot>   [3,5,0]
22:51:05 <rwbarton> so it's "what happens when you try to use infix for a three-argument function"
22:51:26 <Nereid> oh
22:51:28 <Nereid> @type fromMaybe
22:51:29 <lambdabot> forall a. a -> Maybe a -> a
22:51:31 <Nereid> even better.
22:51:43 <Nereid> @type maybe id id
22:51:44 <lambdabot> forall a. Maybe (a -> a) -> a -> a
22:51:59 <Nereid> @type id id id
22:52:00 <lambdabot> forall a. a -> a
22:52:12 <Nereid> a game
22:52:16 <Nereid> step 1. pick your favourite function
22:52:23 <Nereid> step 2. put in id for all its arguments and see what comes out.
22:53:07 <Nereid> you lose if it doesn't typecheck, and you get more points for a more interesting/useful function.
22:53:16 <Nereid> :s
22:54:13 <clahey> >(.) id id
22:54:18 <clahey> > (.) id id
22:54:20 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
22:54:20 <lambdabot>    arising from a use of `...
22:54:24 <johnw> > (+) id id
22:54:25 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
22:54:25 <clahey> :t id id
22:54:25 <lambdabot>    arising from a use of `...
22:54:27 <lambdabot> forall a. a -> a
22:54:30 <Nereid> > (Prelude..) id id
22:54:31 <lambdabot>   Not in scope: `Prelude..'
22:54:34 <Nereid> oh right.
22:54:35 <clahey> :t (.) id id
22:54:37 <lambdabot> forall a. a -> a
22:54:37 <Nereid> well it's just id anyway.
22:54:57 <johnw> id <*> id $ id
22:55:00 <johnw> > id <*> id $ id
22:55:01 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
22:55:12 <Nereid> @type id <*> id
22:55:13 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
22:55:13 <lambdabot>     Probable cause: `id' is applied to too few arguments
22:55:13 <lambdabot>     In the second argument of `(<*>)', namely `id'
22:55:15 <Nereid> heh.
22:55:22 <johnw> heh
22:55:27 <Nereid> @type id >> id
22:55:28 <lambdabot> forall a. a -> a
22:55:29 <johnw> the left has to take two arguments
22:55:37 <johnw> :t id <$> id
22:55:38 <Nereid> @type either id id
22:55:38 <lambdabot> forall a. a -> a
22:55:39 <lambdabot> forall b. Either b b -> b
22:55:52 <johnw> i'm wondering now why this fun
22:55:52 <Nereid> @type foldr id id
22:55:53 <lambdabot> forall a. [(a -> a) -> a -> a] -> a -> a
22:56:03 <johnw> :t fix id
22:56:04 <lambdabot> forall a. a
22:56:10 <johnw> :t const id
22:56:10 <Nereid> @type foldr id
22:56:11 <lambdabot> forall a b. b -> a -> a
22:56:12 <lambdabot> forall b. b -> [b -> b] -> b
22:56:18 <Nereid> cool
22:56:44 <Nereid> @type scanl id
22:56:46 <lambdabot>     Occurs check: cannot construct the infinite type: a = b -> a
22:56:46 <lambdabot>     Probable cause: `id' is applied to too many arguments
22:56:46 <Puffton> If you have double-recursion in Haskell, for example, will Haskell do the recursions concurrently automatically?
22:56:46 <lambdabot>     In the first argument of `scanl', namely `id'
22:56:48 <Puffton> Or is it a setting?
22:56:49 <Nereid> @type scanr id
22:56:51 <lambdabot> forall b. b -> [b -> b] -> [b]
22:57:04 <Nereid> > scanr id 0 [(+1),(*3),(^2)]
22:57:05 <lambdabot>   [1,0,0,0]
22:57:11 <Nereid> damn
22:57:18 <Nereid> > scanr id 0 [(^2),(*3),(+1)]
22:57:20 <lambdabot>   [9,3,1,0]
22:58:24 <hpaste> clahey pasted “Dance.hs” at http://hpaste.org/75856
22:59:04 <Nereid> > flip id
22:59:05 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> (a -> b) -> b)
22:59:05 <lambdabot>    arising fro...
22:59:09 <Nereid> @type flip id
22:59:10 <lambdabot> forall a b. a -> (a -> b) -> b
22:59:14 <Nereid> well yeah.
22:59:36 <johnw> :t id Nereid
22:59:37 <lambdabot> Not in scope: data constructor `Nereid'
23:00:34 <clahey> I'm curious if anyone has any comments on the style of my Dance.hs, and whether there's more haskelly ways to do some of the stuff I'm trying to do.
23:01:43 <johnw> clahey: what is &/?
23:02:14 <clahey> johnw, It's basically >>= child >>=
23:02:31 <johnw> :t (&/)
23:02:33 <lambdabot> Not in scope: `&/'
23:02:36 <clahey> Or maybe that's not quite right, but something like that.
23:02:38 <johnw> where is it from?
23:02:42 <clahey> It's in xml-conduit.
23:02:46 <johnw> ah
23:04:47 <clahey> It's basically emulating some of the stuff that goes on in xpath.
23:05:49 <zzo38> Is this OK?   http://sprunge.us/PSTg
23:06:27 <johnw> zzo38: what are you asking?
23:08:00 <zzo38> Is it OK how it is now? Some things I am not entirely sure how to do. It is a definition of a hardware description language, are all the definitions OK, and then when I want to call runPart to combine and evaluate the used parts what is the way to do?
23:08:11 <zzo38> Should the class definition for Part be changed?
23:08:44 <johnw> does it work?
23:08:47 <zzo38> Is anything else on here, is no good?
23:09:04 * hackagebot regex-tdfa-text 1.0 - Text interface for regex-tdfa  http://hackage.haskell.org/package/regex-tdfa-text-1.0 (KidoTakahiro)
23:09:05 <zzo38> It appears to work how it currently is written; I have tested it a little bit.
23:09:12 <johnw> then it's good
23:09:13 <zzo38> But that still does not answer all of these questions.
23:09:17 <Ralith> you're overusing {} but that's just a style concern
23:09:21 <johnw> maybe it could be better, but working is the first part of good
23:11:04 <zzo38> Ralith: I don't really like the indentation sensitive syntax, so I turned it off, a few people don't like the layout mode. Nevertheless that isn't important.
23:11:37 <johnw> i don't get why people dislike indentation sensitivity
23:11:41 <johnw> i've never understood that
23:11:52 <johnw> people have been whining about it in Python for years, but it never once bothered me
23:12:12 <johnw> even if I have braces and semi-colons, I _still_ write my code with consistent indentation
23:12:26 <johnw> it's like just the knowledge that the compiler pays attention keeps some people from sleeping at night
23:13:41 <zzo38> Actually recently I found some article by Yin Wang about indentation sensitivity, I think, when looking for the stuff about the Yin Yang of continuations on Wikipedia
23:16:36 <zzo38> Do you know some things about hardware description language and about Famicom?
23:17:18 <johnw> no
23:17:36 <zzo38> OK
23:20:46 <zzo38> I just wonder two questions: [1] Does anything in this program seems wrong to you? [2] Is the Part class OK and how to then evaluate them from the resulting list of Command containing Part constructors?
23:22:40 <johnw> i'm afraid i'd have to understand it more than I'm willing to right now
23:22:58 <zzo38> Is it understandable or not?
23:23:08 <johnw> i don't see anything obviously wrong
23:25:21 <zzo38> I intend to work it, after the list of Command type, is converted to all Command constructor, the byte strings are concatenated and put into a binary file.
23:26:26 <Ghoul> Hi
23:26:36 <Ghoul> I need some help with making an enumerator
23:26:47 <zzo38> What are you enumerating?
23:26:54 <Ghoul> Well, I have 3 game modes
23:26:59 <Ghoul> survival, adventure, creative
23:27:11 <Ghoul> and its stored in a byte
23:27:20 <Ghoul> so I just make an enumerator and make serialization methods thats fine
23:27:31 <Ghoul> but theres also another special case
23:27:39 <Ghoul> where the 3rd bit means "hardcore"
23:27:54 <Ghoul> im not sure how to incorporate that into the enumerator
23:28:06 <Ghoul> can enumerators be dual-state?
23:28:07 <zzo38> You could use something like:   data GameMode = Survival | Adventure | Creative deriving (Eq, Enum, Ord, Show);   You can then have something like   (Bool, GameMode)   if you have a boolean to indicate hardcore or not
23:28:37 <jfischoff> JoeyA: thanks for the help on Code Review
23:28:50 <zzo38> What do you mean dual-state enumerator?
23:29:02 <Ghoul> like can an enumerator have another variable
23:29:07 <Ghoul> like a bool
23:29:11 <Ghoul> im really new to haskell.
23:30:02 <JoeyA> jfischoff: No problem
23:30:03 <zzo38> The Enum class doesn't, but you can just use a type like (Bool, GameMode) and if you have a class to enumerate all possibilities that is simply the product type so it is just (liftA2 (,))
23:30:06 <johnw> I'd have another data type containing a GameMode
23:30:19 <zzo38> I don't know if this makes sense to you, or if it is what you are attempting to do.
23:30:25 <johnw> data Game = Game { gameMode :: GameMode, hardCore :: Bool }
23:30:36 <Ghoul> Oh okay
23:30:45 <Ghoul> so make 2 data types
23:30:48 <Ghoul> an enum
23:30:59 <Ghoul> and a larger picture for another type that has the 2 types inside
23:31:04 <johnw> yes
23:31:09 <zzo38> I don't think you can derive Enum with that, but you could define the Enum class yourself; you can still derive Eq.
23:31:26 <johnw> well, only your GameMode need to be a member of Enum
23:31:29 <Ghoul> thanks :)
23:31:31 <johnw> because it truly is an Enum
23:31:37 <johnw> while Game would be a member of Eq and Show
23:32:01 <jfischoff> JoeyA: in general it seems like passing in a pointer for a output value is better then using the return value of a function (unless it is primitive)
23:34:10 <JoeyA> jfischoff: Indeed.  But what do you do when output is an array of variable length?
23:34:18 <lightquake> i keep running into lens name conflicts
23:34:35 <lightquake> i have, for example, a player lens that lenses a player from the world, and I want to write functions that take in a player
23:35:13 <jfischoff> JoeyA: If you want clear memory ownership, split it up into functions, but that could have a performance penalty
23:36:26 <JoeyA> Split what up into functions?
23:37:06 <jfischoff> one for the length, so the caller can allocate a buffer, and one to pass in the buffer and get the result
23:37:29 <Ghoul> Any idea what
23:37:46 <Ghoul> a number might be
23:37:50 <Ghoul> if it's 3rd bit is a 1
23:37:52 <Ghoul> and the rest are zero
23:38:05 <JoeyA> jfischoff: In that case, I would probably just allocate the buffer Haskell-side using malloc (in Foreign.Marshal.Alloc).
23:38:08 <Ghoul> Is it 7?
23:38:41 <JoeyA> If the least significant bit is 0, it's even, meaning it can't be 7.
23:38:47 <Ghoul> oh derp
23:38:48 <jfischoff> JoeyA: add have a free function haskell side the C would call (passing back the pointer)?
23:38:48 <Ghoul> its 4.
23:38:50 <Ghoul> im stupid
23:38:52 <Ghoul> dont worry, lol
23:39:01 <JoeyA> zero-based or one-based?
23:39:02 <JoeyA> > bit 3
23:39:04 <lambdabot>   Ambiguous type variable `a' in the constraint:
23:39:04 <lambdabot>    `Data.Bits.Bits a'
23:39:04 <lambdabot>      a...
23:39:07 <JoeyA> > bit 3 :: Int
23:39:09 <lambdabot>   8
23:39:22 <Ghoul> How
23:39:23 <JoeyA> > map bit [-1..5] :: [Int]
23:39:25 <lambdabot>   [0,1,2,4,8,16,32]
23:39:30 <JoeyA> > map bit [-2..5] :: [Int]
23:39:30 <Ghoul> I just calculated it in calculator
23:39:31 <lambdabot>   [0,0,1,2,4,8,16,32]
23:39:45 <shachaf> @check \x -> x <= 0 || (bit x::Int) == 2^x
23:39:46 <lambdabot>   "OK, passed 500 tests."
23:40:21 <JoeyA> jfischoff: I suppose you could, but then how do you free the free function?
23:40:59 <jfischoff> ?
23:41:04 <shachaf> fix free
23:41:11 * shachaf looks up for context.
23:41:20 <shachaf> Is someone importing wrapper?
23:41:23 <shachaf> Oh, never mind.
23:41:52 <JoeyA> jfischoff: How would you define a free function for C to call?
23:42:01 <JoeyA> What type would it be?
23:42:15 <jfischoff> Ptr a -> IO
23:43:19 <jfischoff> does anyone get permission errors when using cabal-macosx?
23:43:22 <JoeyA> I'm pretty sure you have to make it a FunPtr to call it from C...
23:44:01 <jfischoff> I think we are talking about to different things. Isn't FunPtr for a pointer to a function?
23:44:06 <jfischoff> *two
23:44:15 <JoeyA> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Ptr.html#t:FunPtr
23:44:41 <jfischoff> yeah
23:45:00 <JoeyA> You can't simply stick (Ptr a -> IO ()) in an FFI signature.  I think you'll get a compile-time error.
23:45:17 <jfischoff> oh no I wasn't saying you should
23:45:23 <shachaf> Wait, what's the question here?
23:45:39 <jfischoff> hsFree :: Ptr a -> IO
23:45:53 <Ghoul> How can I declare a typeclass that isn't an enumerator
23:45:56 <JoeyA> You mean Ptr a -> IO ()
23:45:57 <Ghoul> but can only be a Word32
23:46:03 <jfischoff> yeah
23:46:07 <Ghoul> is it like
23:46:14 <Ghoul> data KeepAlive = Word32
23:47:34 <jfischoff> anyone know anything about cabal-macosx?
23:49:59 <JoeyA> I have a machine with Mac OS 10.4, so for me, the answer is no.
23:50:23 <jfischoff> Oh does it not work for later version of Mac OS?
23:50:33 <jfischoff> I think figured it out anyway ...
23:51:15 <JoeyA> Ghoul: What do you mean by "typeclass" and "enumerator" ?
23:51:37 <JoeyA> A "type class" in Haskell is much different from a "class" in C++-style languages.
23:52:20 <JoeyA> In C++, instances of a class are objects, and a class is a type.
23:52:30 <JoeyA> In Haskell, instances of a class are types.
23:52:45 <jfischoff> Is possible to build a 32bit executable with the 64bit ghc or vice-a-versa?
23:53:14 <shachaf> I don't think so.
23:53:33 <jfischoff> me either :(
23:58:27 <hpaste> ghoul pasted “minecraft” at http://hpaste.org/75857
23:58:27 <dada_cetacean> is there an analogue of the mathematica "@@" infix operator in haskell?
23:58:30 <fenton> any recommendations for web pages with info about haskell editing in emacs?
23:58:47 <fenton> people use flymake? hslint?
23:58:48 <Ghoul> JoeyA: Here's what I mean
23:58:54 <Ghoul> http://hpaste.org/75857
23:58:58 <Ghoul> Are my declerations of
23:59:08 <ivanm> dada_cetacean: what does it do?
23:59:19 <ivanm> fenton: there's a page on the wiki
23:59:22 <ivanm> but I think it's out of date
23:59:32 <Ghoul> data ChatMessage = bUcs2 correct?
23:59:46 <dada_cetacean> makes a list into the inputs of a function
