00:06:54 <apple_user> hello
00:07:31 <apple_user> http://ideone.com/cqZeL I want to emulate class-based polymorphism in Haskell. Why won't my code work though?
00:08:53 <avpx> The first problem is indentation.
00:09:05 <avpx> Indent "vocalize"
00:09:13 <avpx> (Line 4)
00:09:16 <apple_user> right
00:09:23 <avpx> The second problem is that the types Cat and Dog are not in scope.
00:10:37 <avpx> Actually, there are just lots of problems here.
00:10:51 <avpx> (Not trying to be cruel, but what you're trying to do doesn't really make sense)
00:10:53 <Eduard_Munteanu> And you probably want existentials to deal with heterogenous lists.
00:10:53 <lambdabot> Eduard_Munteanu: You have 1 new message. '/msg lambdabot @messages' to read it.
00:11:01 <apple_user> ah
00:11:02 <avpx> Eduard_Munteanu: Oh god no
00:11:36 <apple_user> so even if I get them right, I can't just mapM_ the vocalize method to a list of Animals?
00:11:49 <shachaf> avpx: That's not how you emulate "class-based polymorphism". :-(
00:11:54 <avpx> apple_user: The issue is that "Cat" and "Dog" are not objects; they are "types"
00:11:55 <apple_user> but if I just said `data Animal = Cat | Dog` and then everything works alright
00:12:00 <apple_user> avpx: ah
00:12:00 <shachaf> s/vpx/pple_user/
00:12:07 <shachaf> apple_user: Did you see the FAQ entry on this?
00:12:11 <shachaf> @where faq
00:12:11 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
00:12:15 <apple_user> I'll check
00:12:25 <avpx> apple_user: The difference there is that in data Animal = Cat | Dog, Cat :: Animal and Dog :: Animal.
00:12:55 <avpx> That is, Cat and Dog in that are not types, but type *constructors*, which is to say they are elements of the type Animal.
00:13:09 <shachaf> «data Animal = Cat | Dog; talk Cat = "Meow"; talk Dog = "Bark"» is one approach.
00:13:28 <apple_user> so in the `data Animal = Cat | Dog`they are more like objects rather than classes?
00:13:34 <shachaf> «data Animal = Animal { talk :: String }; cat = Animal "Meow"; dog = Animal "Bark"» is another.
00:13:37 <apple_user> Cat and Dog* are more like objects
00:13:47 <shachaf> The latter is perhaps closer to what you're looking for.
00:13:48 <avpx> There is a way you can do this with types/instances/existential types, but that's a bit advanced.
00:13:54 <apple_user> right
00:13:55 <avpx> Erm, classes/instances*
00:14:10 <shachaf> apple_user: But I'd strongly recommend that you stop trying to fit existing concepts from OO onto Haskell.
00:14:18 <avpx> Indeed. It's a bad idea.
00:14:26 <shachaf> First learn Haskell on its terms, then figure out how to do these things.
00:14:44 <apple_user> right
00:14:54 <Eduard_Munteanu> It can be instructive if you already know those bits though, but for other reasons (existentials etc.).
00:14:55 <shachaf> Did you see the two approaches I gave above?
00:15:06 <apple_user> yes ^_^
00:15:21 <shachaf> See also "the expression problem"
00:16:16 <Ghoul> putStrLn (show (head (filter (\x -> x > 10) (map (addAllOddSqUpto) [1..]))))
00:16:27 <apple_user> http://ideone.com/rMOZn works well
00:16:41 <Ghoul> Trying to find how many iterations required before the number output is larger than, ie: 10
00:16:46 <apple_user> but it feels not exactly the same as how it would be done in an OOP language,
00:16:51 <Ghoul> But I've only managed to find the actual number output
00:16:52 <shachaf> dropWhile
00:16:57 <Ghoul> Any suggestions?
00:16:57 <apple_user> what's the expression problem?
00:17:01 <avpx> apple_user: Of course. This shouldn't feel like OOP, because it's not OOP.
00:17:23 <shachaf> @google what's the expression problem?
00:17:23 <lambdabot> http://en.wikipedia.org/wiki/Expression_problem
00:17:23 <lambdabot> Title: Expression problem - Wikipedia, the free encyclopedia
00:17:40 <apple_user> thanks
00:18:26 <apple_user> so how does Haskell solve the expression problem compared to how Python or C or C++ or Java solves it?
00:18:53 <shachaf> It's not a language thing.
00:19:03 <Sculptor> what
00:19:05 <shachaf> It's also not really solvable.
00:19:08 <apple_user> seems a problem in analytic philosophy
00:19:14 <Sculptor> there can be only one
00:19:22 <shachaf> I don't know what that means.
00:19:30 <Ghoul> is there a way to get the number of iterations
00:19:31 <lightquake> yeah, the 'no recompiling' restriction seems to make it really difficult to solve
00:19:34 <Ghoul> that have been made using map
00:19:40 <Ghoul> given that the second argument is a lazy infinite list
00:19:47 <shachaf> lightquake: It doesn't have so much to do with compilation as with APIs.
00:20:11 <avpx> Ghoul: "Number of iterations made using map?"
00:20:13 <Eduard_Munteanu> Ghoul: if you're using filter, you can use length on the result
00:20:16 <Ghoul> putStrLn (show (head (filter (\x -> x > 10) (map (addAllOddSqUpto) [1..]))))
00:20:17 <lightquake> Ghoul: you can use zipWith [0..] to make a list of tuples, where the first element of the tuple is the index and the second element is the item itself
00:20:26 <shachaf> You want to be able to (a) add new animals (b) add new actions for animals.
00:20:34 <Ghoul> ah, lightquake that might work
00:21:02 <avpx> Ghoul: You should make use of function composition, by the way.
00:21:22 <avpx> putStrLn . show . head . filter (> 10) . map addAllOddSqUpTo $ [1..]
00:21:34 <Eduard_Munteanu> Ah, nvm, I noticed it's '>'.
00:21:46 <sp3ctum> isn't print the same as putStrLn . show ?
00:21:56 <apple_user> shachaf: yes; in C++ adding new animals can be done with inheritance, while adding new Animal actions can be done by adding more pure virtual methods in the Animal class declaration.
00:21:59 <lightquake> so something like print $ head . filter (\x -> snd x > 10) . map addAllOddSqUpTo $ [1..]
00:22:00 <avpx> sp3ctum: Not quite.
00:22:04 <Eduard_Munteanu> @src print
00:22:04 <lambdabot> print x = putStrLn (show x)
00:22:08 <avpx> Oh wait
00:22:13 <avpx> I was remembering falsely apparently :(
00:22:18 <lightquake> er
00:22:30 <shachaf> apple_user: You can't modify the class declaration.a
00:22:40 <lightquake> so something like print $ head . filter (\x -> snd x > 10) . map (\(i, x) -> (i, addAllOddSqUpTo x)) $ zip [0..] [1..]
00:23:20 <avpx> And some of the awkward tuple handling can be resolved by using functions in Control.Arrow
00:23:23 <Ghoul> I am so lost.
00:23:31 <lightquake> although to be honest i'd rather filter the list using the predicate (\x -> addAllOddSqUpTo x > 10) directly
00:23:40 <shachaf> lightquake: That first $ can be a . too. :-)
00:23:58 <avpx> Ghoul: Welcome to the channel :p
00:24:03 <lightquake> shachaf: yeah, but i like the $ more for some reason
00:24:09 <sp3ctum> is there an advantage to using x $ y $ a ; or x . y $ a ?
00:24:21 <shachaf> lightquake: Cale will get you.
00:24:31 <avpx> sp3ctum: Not really, but the latter is more idiomatic
00:24:35 <Ghoul> putStrLn (show ((\ (a,b) -> head a) (filter (\x -> x > 10) (zipWith [1..] (map (addAllOddSqUpto) [1..])))))
00:24:36 <lightquake> if it's a really long composition block i'll typically use the $s to separate 'related' functions
00:24:38 <Ghoul> <________________<
00:24:40 <shachaf> sp3ctum: The latter lets you take "x . y" and give it its own name.
00:24:50 <Cale> suppose you have  f $ g $ h $ x
00:24:59 <Cale> g $ h is meaningless here
00:25:08 <sp3ctum> ah, i didn't think about that shachaf.
00:25:11 <Cale> Now consider f . g . h $ x
00:25:18 <Cale> g . h means something on its own
00:25:29 <lightquake> Cale: good point
00:25:36 <lightquake> anyway someone help Ghoul, i need to go to bed
00:25:36 <Ghoul> What's . and $ mean
00:25:46 <avpx> Ghoul: . is function composition.
00:25:48 <Cale> In a sense, the composite has more "effective subexpressions" which you can pull apart to understand how it works
00:25:57 <avpx> @type (.)
00:25:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:26:05 <avpx> ... okay, that's not as helpful as I had hoped
00:26:19 <Ghoul> Yeah
00:26:21 <Ghoul> confused.
00:26:25 <Ghoul> lol
00:26:26 <Cale> haha
00:26:33 <Cale> ($) :: (a -> b) -> a -> b
00:26:33 <avpx> Ghoul: lambdabot has weird definitions for things.
00:26:42 <Cale> (.) :: (b -> c) -> (a -> b) -> (a -> c)
00:26:48 <Ghoul> So uh
00:26:51 <Eduard_Munteanu> > (*2) . (+1) $ 3
00:26:53 <lambdabot>   8
00:26:54 <Ghoul> what's a . b 5
00:26:59 <Ghoul> ooh
00:27:00 <Ghoul> sec
00:27:09 <Cale> (f . g) x = f (g x)
00:27:10 <Ghoul> so its right to left
00:27:13 <Ghoul> order of operations?
00:27:18 <Cale> um...
00:27:19 <Eduard_Munteanu> Yeah.
00:27:19 <YayMe> avpx: I think lambdabot occasionally makes things up to maintain entropy around here
00:27:25 <Ghoul> (+3) . (+2) . (*8) $ 9
00:27:25 <Cale> Depends on how you think of things
00:27:31 <Ghoul> > (+3) . (+2) . (*8) $ 9
00:27:32 <avpx> Ghoul: It's the same as the mathematical operator. f(g(x)) is (f . g)(x)
00:27:34 <lambdabot>   77
00:27:40 <Ghoul> > 9*8
00:27:41 <lambdabot>   72
00:27:50 <Cale> Really when you evaluate f (g x), this evaluates f first
00:27:51 <Ghoul> > (^3) . (+2) . (*8) $ 9
00:27:52 <avpx> I think of (.) as backwards because I see values get fed in from the right and propagate to functions on the left.
00:27:53 <Cale> and plugs in g x
00:27:53 <lambdabot>   405224
00:27:57 <Ghoul> sweet
00:27:59 <Ghoul> understand now
00:28:01 <Ghoul> thanks, lol
00:28:12 <Cale> So it is in a more real way left to right
00:28:24 <Ghoul> Oh but
00:28:26 <Eduard_Munteanu> Evaluation-wise.
00:28:27 <Cale> But a lot of people like to think of the data flow in a strict-evaluation sort of way
00:28:30 <Ghoul> what if functions take more arguments
00:28:34 <Ghoul> like
00:28:38 <Ghoul> a . b . c
00:28:40 <Ghoul> but b takes 2 args
00:28:42 <YayMe> avpx: yeah, that was one of the first aha moments for me with haskell was realizing I had to start reading code right to left after years of reading it left to right
00:28:42 <Ghoul> how do you do that
00:28:44 <Cale> Ghoul: Every function really takes exactly one argument
00:29:08 <Cale> Ghoul: a will get a function parameter in that case
00:29:09 <Eduard_Munteanu> a -> b -> c == a -> (b -> c)
00:29:38 <merijn> Ghoul: if b takes 2 arguments it really takes one argument and returns a function taking one argument. In the a . b . c composition a will just get that new function as input argument
00:29:45 <Cale> (if b produces a function in a . b . c, then a needs to take a function)
00:30:14 <YayMe> Ghoul: if b is a -> b -> c and you give it one parameter it returns (b -> c) so  in your example if a accepts (b -> c) as it's first parameter, it would work
00:30:18 <Ghoul> Uh okay
00:30:25 <Ghoul> Is it automatic recognition
00:30:34 <merijn> Ghoul: Concrete example time. Let's replace "a . b . c" with actual functions where the middle one takes two arguments
00:30:34 <Ghoul> like
00:30:37 <Axman6> recognition of what?
00:30:44 <merijn> :t filter . (==) . (+1)
00:30:44 <Ghoul> Uh
00:30:45 <lambdabot> forall a. (Num a) => a -> [a] -> [a]
00:30:52 <YayMe> a would have to be a :: (b -> c) -> something
00:30:57 <Ghoul> Wait
00:31:03 <Ghoul> Let me test some stuff on my own
00:31:06 <Ghoul> lol ~
00:31:12 <Axman6> :t map
00:31:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:31:24 <Axman6> :t map toUpper
00:31:25 <lambdabot> [Char] -> [Char]
00:31:30 <Axman6> :t map toUpper "Hello"
00:31:32 <lambdabot> [Char]
00:31:37 <Cale> > \f -> foldr ((:) . f) []
00:31:39 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> a1) -> [a] -> [a1])
00:31:39 <lambdabot>    arisi...
00:31:40 <Cale> :t \f -> foldr ((:) . f) []
00:31:42 <lambdabot> forall a a1. (a1 -> a) -> [a1] -> [a]
00:32:01 <YayMe> Cale: does the generic term "associativity" mean "left associative and right associative"?
00:32:10 <merijn> Ghoul: a = filter, b = (==) and c = (+1). The composition takes one argument (an Int), increments it and then passes that argument to ==, == returns a function that compares a value against the original Int + 1. Filter than uses this function to remove elements of a list
00:32:23 <avpx> YayMe: I'm glad I'm not the only one who's had that experience. I personally think it would make sense to write composition the other way, just so you can read from left-to-right what the sequence of function applications is.
00:32:29 <Cale> YayMe: If * is associative it means that a * (b * c) = (a * b) * c
00:32:36 <merijn> YayMe: The generic term associative operator means that "(a + b) + c = a + (b + c)"
00:32:41 <Eduard_Munteanu> YayMe: mm, no, usually it means (a * b) * c == a * (b * c)
00:32:46 <avpx> YayMe: But I guess that's why we have, for instance, (<=<) as well as (>=>)
00:32:58 <Eduard_Munteanu> OTOH, left/right associativity is a definitional thingy.
00:33:03 <YayMe> Cale: I understand that from our previous conversations, I'm curious about the definition of the terms "left associative" and "right associative" because I see them thrown around
00:33:09 <Eduard_Munteanu> It merely says how you parse things.
00:33:35 <Ghoul> merijn: ty
00:33:38 <Cale> YayMe: Those are terms applied to operators which aren't associative to express what our convention is so that we sometimes don't have to write the parens
00:33:41 <merijn> YayMe: left associative essentially means "read these operators left to right" whereas right associative means the reverse
00:33:52 <Eduard_Munteanu> While plain associativity is a property of certain operators, regardless of what left/right associativity conventions you're using.
00:34:18 <merijn> Left associative x means "a x b x c x d" brackets as "((a x b) x c) x d"
00:34:18 <YayMe> avpx: Eh, I kind of like reading it from the right to left, the parameter goes at the end so it makes sense, reading it left to right would feel like the parameter goes to the left at the beginning which would be strange
00:34:26 <Ghoul> Why do I have to use $
00:34:31 <Ghoul> putStrLn . show . sum $ [1..9] works
00:34:34 <Cale> Ghoul: you never do
00:34:37 <Ghoul> but putStrLn . show . sum [1..9] doesn't
00:34:40 <merijn> Right associative x means "a x b x c x d" brackets as "a x (b x (c x d))"
00:34:46 <Cale> Ghoul: you need to put the composite function in parens
00:34:47 <avpx> YayMe: It's just a matter of wanting to read left-to-right.
00:34:56 <merijn> Ghoul: Because function application has higher precedence than operators
00:34:57 <YayMe> merijn: so then what I said is true, if something meets the law of "associativity" it's right and left associative
00:35:04 <Cale> Ghoul: Important thing to remember: function application binds tighter than any infix operator
00:35:26 <Cale> So that's  putStrLn . show . (sum [1..9])
00:35:27 <EvanR2> putStrLn . show = print
00:35:33 <merijn> Ghoul: "putStrLn . show . sum [1..9]" parses as "(putStrLn . show) . (sum [1..9])"
00:35:52 <Cale> which is putStrLn . show . 45
00:35:56 <avpx> Ghoul: $ is often a handy way to save on parens.
00:36:02 <Cale> which doesn't make sense
00:36:04 <Cale> unless 45 is a function :)
00:36:07 <merijn> Ghoul: But "sum [1..9]" is not a function, it's an Int. And . (.) expect Int's, so what you typed is a type error :)
00:36:15 <merijn> eh
00:36:19 <merijn> (.) expects functions...
00:36:23 <merijn> Stupid brain
00:36:23 <Ghoul> hm
00:36:33 <merijn> This does work
00:36:37 <EvanR2> Ghoul are you overwhelmed by several people explaining at once ;)
00:36:44 <EvanR2> the same thing
00:36:47 <merijn> > (putStrLn . show . sum) [1..9]
00:36:49 <lambdabot>   <IO ()>
00:36:51 <Jafet> @quote stereo
00:36:52 <lambdabot> lambdabot says: omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
00:36:57 <merijn> (Except lambdabot doesn't print)
00:37:08 <merijn> (And also "putStrLn . show = print" :p
00:37:11 <Ghoul> Uh
00:37:13 <YayMe> Either a lot of you are international or haskell tends to attract insomniacs
00:37:14 <Ghoul> Okay
00:37:17 <EvanR2> merijn: i just said that
00:37:19 <apple_user> guess I don't need existential types then
00:37:31 <avpx> YayMe: Not to be nitpicky, but is anyone really "international?"
00:37:31 <Ghoul> How about
00:37:35 <EvanR2> haha international == not american
00:37:35 <merijn> YayMe: I'm pretty sure I'm not international, I only have one nationality :p
00:37:37 <avpx> YayMe: It's like saying someone has an accent.
00:37:41 <Ghoul> A simple explanation of $
00:37:47 <YayMe> I realized the mistake as soon as I typed it
00:37:51 <Ghoul> I don't quite know what it means
00:37:53 <Jafet> EvanR2: or mexicans
00:37:54 <avpx> YayMe: Well I hope you've learned something :op
00:37:57 <merijn> Ghoul: ($) is an operator that does this: "f $ x = f x"
00:37:58 <YayMe> it's late here, forgive me heh
00:38:02 <avpx> Which I meant to type as :p
00:38:04 <EvanR2> Ghoul: its low precedence function application
00:38:11 <Ghoul> Oh I see
00:38:12 <EvanR2> Jafet: what? no, mexicans dont have internet
00:38:37 <YayMe> @src ($)
00:38:37 <lambdabot> f $ x = f x
00:38:44 <YayMe> oh, huh
00:38:46 <merijn> Ghoul: The trick is that ($) has the lowest precedence of any operator, so if "f" consists of an expression (for example with .) the operators in that expression will have higher precedence
00:39:11 <YayMe> @src (.)
00:39:11 <lambdabot> (f . g) x = f (g x)
00:39:11 <lambdabot> NB: In lambdabot,  (.) = fmap
00:39:16 <merijn> Ghoul: Avoiding the "accidentally applying sum to [1..9] instead of the . operator"-problem
00:39:25 <Ghoul> gotcha
00:39:33 <apple_user> can haskell chain comparison operators like in python? i.e. x < y < z == x < y && y < z ?
00:39:43 <merijn> apple_user: No, unfortunately not
00:39:43 <Axman6> no
00:39:44 <avpx> apple_user: Nope.
00:39:52 <avpx> I think it's fortunate.
00:39:55 <Jafet> For a suitable definition of <
00:39:59 <Axman6> someone should fix that, make Ord a MPTC
00:40:09 <merijn> Axman6: I'm on it :)
00:40:14 <Axman6> so we can have Ord resType comparisonType
00:40:33 <Axman6> not quite sure how to make it work though
00:40:46 <merijn> Where do I submit my pull request to Cool.People.Prelude?
00:41:57 <merijn> I guess that requires a more elaborate Bool type
00:42:17 <avpx> But there's really nothing to stop you from just using between x y z = (x < y) && (y < z)
00:42:20 <EvanR2> > compare (1,2) (3,4)
00:42:20 <merijn> Maybe we should solve the problem by introducing a Bool type classes to avoid Boolean blindness...
00:42:21 <lambdabot>   LT
00:42:25 <EvanR2> > compare (1,2) (2,1)
00:42:26 <lambdabot>   LT
00:42:33 <Ghoul> Can this be done any more compactly
00:42:34 <Ghoul> putStrLn . show . sum $ (map (^2) [1..100])
00:42:45 <Ghoul> Thats the lowest I could get it
00:42:48 <Ghoul> without syntax erros
00:42:53 <avpx> Continue to realize that putStrLn . show = print
00:42:54 <merijn> print . sum . map (^2) $ [1..100]
00:43:00 <Jafet> print $ 2^101 - 1
00:43:04 <Jafet> -2
00:43:07 <Jafet> Oops
00:43:34 <EvanR2> > compare (1 :+ 2) (2 :+ 1)
00:43:35 <lambdabot>   No instance for (GHC.Classes.Ord (Data.Complex.Complex t))
00:43:35 <lambdabot>    arising from ...
00:43:38 <merijn> Ghoul: Note that here I make use of "map (^2)" having higher precedence than (.)
00:43:39 <EvanR2> sweet
00:44:46 <Jafet> > 0 === ""
00:44:48 <lambdabot>  Terminated
00:44:59 * hackagebot nkjp 0.1.1 - Manipulating the National Corpus of Polish (NKJP)  http://hackage.haskell.org/package/nkjp-0.1.1 (JakubWaszczuk)
00:45:04 <Jafet> > "" === 0
00:45:07 <lambdabot>   False
00:45:35 <Ghoul> hgax
00:45:37 <Ghoul> *hax
00:45:38 <EvanR2> :t (===)
00:45:40 <lambdabot> forall a a1. (Show a1, Show a) => a -> a1 -> Bool
00:46:43 <avpx> @src (===)
00:46:44 <lambdabot> Source not found.
00:46:57 <avpx> I'm guessing it's a === b = show a == show b
00:47:13 <EvanR2> except for Terminated
00:47:18 <Ghoul> What about putStrLn . show . sum . map (^2) $ ([1..] take 5)
00:47:19 <avpx> Yeah
00:47:25 <Ghoul> That gives me an error near take
00:47:37 <Jafet> > 1 === True
00:47:39 <lambdabot>   True
00:47:40 <YayMe> Ghoul: what is take 5 being applied to?
00:47:45 <Ghoul> [1..
00:47:49 <avpx> Does it do some sort of coercion?
00:47:50 <EvanR2> backwards
00:48:02 <EvanR2> > (take 5 [1..])
00:48:03 <lambdabot>   [1,2,3,4,5]
00:48:29 <YayMe> :t take
00:48:31 <lambdabot> forall a. Int -> [a] -> [a]
00:48:31 <EvanR2> VERB SUBJECT OBJECT ;)
00:48:42 <Ghoul> oh okay
00:48:47 <Ghoul> im used to using it like
00:48:51 <Ghoul> list take number
00:48:53 <fmap> @src print
00:48:54 <lambdabot> print x = putStrLn (show x)
00:48:55 <Jafet> NOUN NOUN NOUN
00:48:55 <Ghoul> which usually works
00:49:05 <EvanR2> usually?
00:49:20 <EvanR2> also theres
00:49:35 <EvanR2> > [1..] <$ (take 5)
00:49:36 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [t])
00:49:36 <lambdabot>    arising from a use ...
00:49:39 <avpx> > "" === False
00:49:41 <lambdabot>   False
00:49:42 <EvanR2> haha
00:49:52 <YayMe> > show False
00:49:53 <lambdabot>   "False"
00:50:07 <EvanR2> > let (<$) = flip ($) in [1..] <$ (take 5)
00:50:09 <lambdabot>   [1,2,3,4,5]
00:50:20 <EvanR2> however <$ is already taken by Functor now i think
00:50:30 <Ghoul> putStrLn . show . sum . map (^2) $ map (\x -> x) $ take 6 [1..]
00:50:32 <Ghoul> So cool.
00:50:41 <EvanR2> (\x -> x) = id
00:50:45 <Axman6> what is the identity map for?
00:50:47 <avpx> map id = id
00:50:51 <Ghoul> Oh
00:50:52 <EvanR2> hah
00:50:54 <Ghoul> I was testing
00:50:56 <Ghoul> \x = x + 1
00:51:03 <Ghoul> to see if the order of operations worked
00:51:03 <avpx> You can write that as just (+1)
00:51:14 <Ghoul> herp
00:51:19 <avpx> Or even succ
00:51:19 <EvanR2> \x -> x + 1 = (+1)
00:51:25 <Ghoul> originally I tried (+1) without map
00:51:26 <Ghoul> :P
00:51:28 <YayMe> > take 5 $ foldl1 (+1) [1,1..]
00:51:29 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
00:51:37 <EvanR2> but its faster if you write it out long hand! </hide>
00:51:46 <EvanR2> kidding
00:52:08 <YayMe> > foldl1 (+1) $ take 5 [1,1..]
00:52:09 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
00:52:12 <Ghoul> ugh
00:52:14 <Ghoul> succ doesnt work on lists?
00:52:16 <Ghoul> :C
00:52:23 <EvanR2> > map succ [1..]
00:52:24 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
00:52:38 <Ghoul> yeah I was hoping it was automatic though :P
00:52:43 * YayMe is confused where the infinite type is
00:52:51 <avpx> Ghoul: It's not like an array language or something. It can't just deduce how a function a -> b applies to an argument of type [a]
00:53:04 <avpx> You use map to do this.
00:53:10 <EvanR2> 'do what i mean not what i say' lol
00:53:25 <avpx> EvanR2: See: my issues with many existing programming languages.
00:53:30 <avpx> I'm looking at you, JavaScript and PHP.
00:53:41 <EvanR2> in those cases often it does neither
00:53:56 <YayMe> avpx: as a rule of thumb I prefer not to look at either of them
00:54:11 <avpx> EvanR2: I learned recently that in PHP, if integers get too big, they are automatically promoted to floats. But that's no problem because type coercion, brah.
00:54:15 <chrisdone> i think i may already have asked, did anyone write a project to scan a codebase and and point out partial functions or use thereof?
00:54:16 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
00:54:40 <EvanR2> javascript has a semi non offensive subset
00:54:59 <avpx> The subset that's basically a mildly sugared lambda calculus?
00:55:15 <EvanR2> yeah
00:55:37 <EvanR2> where recursion causes stack overflow by definition
00:55:42 <EvanR2> haha
00:55:50 <chrisdone> also the immutable strings (implemented as ropes) are nice
00:56:05 <EvanR2> definitely
00:56:30 <Ferdirand> if all functions were implicitely mapped over lists, what would be the result of "length [[1,2,3],[4,5,6]]" ?
00:56:35 <EvanR2> immutable strings in javascript is the one thing which can convince people that immutable data makes sense in any way
00:57:07 <YayMe> I hate it when I forget $ isn't lesser precedence than other operators
00:57:21 <EvanR2> Ferdirand: exactly, at this point both make sense, so if it chose either it would be confounding a portion of the users
00:57:56 <EvanR2> the more things that are allowed the less the computer can help you avoid nonsense
00:58:00 <avpx> YayMe: That's basically the only thing you need to know about ($)
00:58:44 <avpx> Bingo. Error messages are good. Compilers telling you that you're full of crap is good.
01:00:21 <YayMe> avpx: err it's precedence isn't always clear to me sometimes, like here: space *> many1 $ string "a" <|> string "b"
01:00:48 <Ghoul> addAllOddSqUpto z = sum . map (^2) $ (filter odd [0..z])
01:00:57 <Ghoul> bitch please, LYAH.
01:01:00 <YayMe> avpx: $ no worky there because the <|> get's a lesser precedence
01:01:25 <avpx> YayMe: Surprising.
01:01:26 <apple_user> so unlike virtually all other non-purely functional programming languages, Haskell has no pointers at all thanks to its referential transparency?
01:01:28 <chrisdone> YayMe: that really bothers me about operators in general. i tend to favor parens over relying on precedence these days
01:01:36 <apple_user> like how Java 'objects' are actually pointers
01:02:18 <Ferdirand> what do you think pointer means ?
01:02:31 <apple_user> a pointer is a value that denotes a reference to another value
01:02:33 <chrisdone> apple_user: yeah, no pointers. ghc and other compilers can give you different types of pointers, but that's compiler-specific
01:02:38 <YayMe> apple_user: there's likely pointers underneath it, you just don't play with them unless doing FFI or having explicit reason to
01:02:58 <Ghoul> are there any haskell minecraft servers
01:03:02 <ivanm> hey chrisdone
01:03:11 <chrisdone> o/
01:03:25 <YayMe> Ghoul: wow.. where did that even come from? Did someone do a port?
01:03:46 <ivanm> chrisdone: next time you're hacking on hpaste, can you consider adding a "plain text" mode to just get the raw paste?
01:04:09 <zomg> YayMe: Minecraft server is like the new cool server to write
01:04:10 <zomg> or something
01:04:34 <avpx> apple_user: I think the big difference here is that in other languages, you have to think carefully about whether you're talking about a value, or some reference to the memory where that value resides.
01:04:41 <chrisdone> ivanm: you can leave the language blank
01:04:48 <YayMe> zomg: people rewrite the minecraft server for kicks? I guess it can't be the hardest but.. huh..
01:05:09 <Ghoul> YayMe: I started writing one in pure C
01:05:09 <zomg> there are at least two written for nodejs and two in C++ I think..
01:05:13 <Ghoul> and my eventual haskell goal
01:05:16 <Ghoul> is to write one in haskell
01:05:30 <ivanm> chrisdone: no, I mean without all the html around it (line numbers, other links, etc.)
01:05:33 <YayMe> Ghoul: is the protocol and file structure particularly simple?
01:05:34 <ivanm> just the plain text
01:05:40 <zomg> Too bad none of the custom servers will be running much plugins
01:05:42 <Ghoul> YayMe: the protocol is pretty simple
01:05:48 <Ghoul> YayMe: it's AES encrypted though
01:05:49 <ivanm> makes it easier to download pastes, etc.
01:05:51 <Ghoul> that was a bitch in C
01:05:54 <zomg> Well not plugins but mods
01:05:55 <Ghoul> but haskell has libs for it
01:05:56 <Ghoul> I think
01:05:58 <chrisdone> ivanm: there is the raw link
01:06:13 <Ghoul> And imo, haskell server would use less memory than the fat java one
01:06:15 <chrisdone> ivanm: is that not good?
01:06:17 <Ghoul> the java one uses 50mb/player
01:06:22 <Ghoul> Im sure a haskell server could do much better than that.
01:06:23 <YayMe> Ghoul: Do people do the map generation in the original?
01:06:30 <ivanm> oh? must have missed that when I was looking for it...
01:06:30 <Ghoul> Nope
01:06:33 <zomg> Most mods will always be written for the official client/server combo especially since that will allow reuse of code between the client and server
01:06:35 <Ghoul> Just get the ripped code
01:06:36 <YayMe> haha that's horrible
01:06:37 <Ghoul> and re-implement it
01:06:44 <zomg> But yeah I guess if you just want to play vanilla mc =)
01:06:53 <GnomeStoleMyBike> vanilla mc ?
01:07:00 <zomg> GnomeStoleMyBike: Minecraft with no mods
01:07:12 <ivanm> chrisdone: where is the raw link here? http://hpaste.org/53106
01:07:19 <Ghoul> but yeah
01:07:22 <ivanm> I want to be able to download just the text
01:07:22 <Ghoul> I gotta learn haskell
01:07:28 <Ghoul> before I figure out how to write a server in it
01:07:29 <Ghoul> <_<
01:07:30 <GnomeStoleMyBike> how we went from haskell to c and end up with minecraft :D what kind of sorcery is that :D
01:07:38 <EvanR2> the assumption that haskell will use less memory than java is interesting
01:07:43 <Ghoul> GnomeStoleMyBike: I was writing a pure C server
01:07:43 <chrisdone> ivanm: click expand
01:07:49 <zomg> GnomeStoleMyBike: he said he wanted to write an mc server in haskell so yeah =)
01:07:50 <Ghoul> because C was the languae I used most before
01:07:51 <avpx> Haskell's memory usage is... hard to reason about.
01:07:52 <apple_user> C is alright, since in C references are a first-class object
01:08:06 <ivanm> chrisdone: oh... I thought "expand" was part of the step-through evaluation or something :)
01:08:09 <ivanm> nvm me then :)
01:08:10 <GnomeStoleMyBike> everyone will hate me now but why not Erlang for servers ?you have out of the box ready item to build it.
01:08:10 <Ghoul> avpx: I looked at java versus haskell benchmarks
01:08:20 <ivanm> GnomeStoleMyBike: why will everyone hate you?
01:08:27 <YayMe> Ghoul: Cheers, I've been at this for 4? 5 months? It's like learning to program all over again. I forgot how long it took the first time..
01:08:28 <Ghoul> and haskell used like 50x less memory in every single test
01:08:36 <EvanR2> benchmarks are games
01:08:38 <ivanm> IIRC, hasn't someone already written a MC server in Haskell?
01:08:38 <zomg> Erlangherd!
01:08:41 <GnomeStoleMyBike> because this is haskell channel :D and i jsut suggested different language :)
01:08:48 <ivanm> @google minecraft haskell
01:08:49 <lambdabot> http://blog.acfoltzer.net/2010/12/minecraft-data-api-for-haskell-haskellnbt/
01:08:49 <lambdabot> Title: Minecraft data API for Haskell: HaskellNBT « Adam Foltzer's Blog
01:08:50 <Ghoul> ivanm: I'd be interested to know
01:08:58 <ivanm> @google minecraft server haskell
01:08:59 <lambdabot> http://www.youtube.com/watch?v=65_v59j3jY0
01:09:04 <avpx> GnomeStoleMyBike: How dare you suggest that other languages exist and/or may be useful
01:09:04 <apple_user> well Haskell doesn't have to load up a whole Virtual Machine with an embedded JIT
01:09:17 <EvanR2> haskell has a pretty giant runtime
01:09:29 <YayMe> I can't imagine why minecraft was written in java to begin with..
01:09:38 <EvanR2> because the developer was a java guy
01:09:43 <Dtgr> YayMe: because notch likes java
01:10:02 <Dtgr> i can't imagine how someone actually likes that language...
01:10:04 <YayMe> I'm a C# guy and I like C# but I know some things shouldn't be done in C#
01:10:05 <zomg> notch apparently isn't even that good a programmer from what I hear :P
01:10:13 <EvanR2> and its cancerous, many people that now like minecraft now like java
01:10:21 <GnomeStoleMyBike> Nothing should be done in C#
01:10:23 <ivanm> I once worked on something that was written in Java because the main dev didn't know much programming, and thought Java sounded better/more popular than C (that the prototype was written in by someone else)
01:10:36 <zomg> JVM is alright but Java as a language is pretty annoying =)
01:10:41 <Ghoul> haskell also performs the same speed as java
01:10:43 <Ghoul> but without the laggy GC
01:10:48 <osfameron> from the mouths of bots: "I had a problem. Then I studied Java.  Now I have a ProblemFactory."
01:10:54 <avpx> Err, Ghoul, Haskell also has GC
01:10:55 <Dtgr> osfameron: :)
01:10:55 <apple_user> if only Haskell became a wide success for application development, then we would see tons of amazing applications and games and operating systems and libraries in Haskell ^_^
01:10:55 <EvanR2> benchmark games
01:11:06 <Ghoul> avpx: But isn't it parralell?
01:11:09 <GnomeStoleMyBike> ivanm: actually java sounds better than C. I'm doing C every day and trust me char* people come back fromt he dead in utf-8 age.
01:11:10 <YayMe> EvanR2: High-five yourself for knowing people who think java is a game programming language aren't competition to you in the job market
01:11:31 <EvanR2> YayMe: not in my job market
01:11:53 <Ghoul> haskell also makes multithreading ridic easy
01:11:56 <GnomeStoleMyBike> ivanm: in C++ for instance there are 4 classes in each project to represent String and each lib has its own String representation that is sick.
01:11:57 <YayMe> EvanR2: That's what I think when I hear about stuff like that spreading virally "look, a bunch more people who will create messes that I can get a job fixing"
01:12:08 <Ghoul> last time I checked bukkit was single threaded because java doesn't have a great level of abstraction
01:12:08 <ivanm> GnomeStoleMyBike: sure, I would agree that Java > C in many cases; unfortunately he was learning Java as he wrote  this... :s
01:12:38 <EvanR2> i dont think minecraft would have been better to write in C
01:12:57 <Ghoul> Oh it would be much faster
01:13:01 <Ghoul> he could use a VBO
01:13:05 <Ghoul> and render chunks on the gpu
01:13:05 <EvanR2> its plenty fast
01:13:07 <YayMe> Ghoul: the concurrent aspects are what brought me to haskell after dealing with all the lock synchronization in C#, got good at it but still thought there had to be a better way
01:13:09 <Ghoul> by passing their infromation as textures
01:13:14 <Ghoul> It'd be upwards of 20x faster
01:13:25 <EvanR2> it already runs at more fps than my monitor refresh
01:13:39 <GnomeStoleMyBike> i can imagine server fo minecraft in C and a person on chat typing in Polish :D
01:13:40 <Ghoul> It kind of fails on my A8-3500M a little
01:13:44 <Ghoul> more choppy than it needs to be
01:13:45 <GnomeStoleMyBike> server goes crazy
01:13:58 <EvanR2> that doesnt merit change the programming language
01:14:13 <Ghoul> Java + VBO's = da-dun.
01:14:26 <Ghoul> especially trying to buffer data into a texture with java
01:14:27 <EvanR2> arithemtic exception
01:14:30 <Ghoul> gonna be a grande headache.
01:14:53 <EvanR2> why such a thing needs to happen in minecraft i do not know
01:15:00 <EvanR2> #haskell-blah
01:15:10 <GnomeStoleMyBike> minecraft anyway is written in java yes ?
01:15:46 <apple_user> so the things defined by the `data` keyword in Haskell are algebraic data types (which are like C's structs, unions, and enums but more awesome)?
01:16:01 <apple_user> what does algebraic mean in that context though?
01:16:04 <EvanR2> it can do those three things plus more
01:16:09 <GnomeStoleMyBike> ADT is cool
01:16:26 <EvanR2> apple_user: they are described by an algebra
01:16:35 <apple_user> and why is it different from C++/Java's classes?
01:16:37 <EvanR2> where as in C they are described by operational semantics
01:16:41 <apple_user> ah
01:16:49 <Ghoul> Basically the point is
01:16:51 <apple_user> I still don't get it >.<
01:16:54 <Ghoul> people are writing one in python
01:16:55 <Ghoul> and one in asm
01:16:56 <mcstar> EvanR2: what?
01:17:00 <Ghoul> so why can't I write one in haskell
01:17:08 <EvanR2> they being structs and unions
01:17:19 <YayMe> @src <|
01:17:19 <lambdabot> Source not found. Sorry.
01:17:41 <YayMe> Ghoul: I'm guessing someone has already done it in erlang the quintessential language built for stuff like that?
01:18:05 <Ghoul> not that i heard of
01:19:07 <apple_user> if haskell isn't the "typical functional programming language", then what is? is it ML?
01:19:17 <opqdonut> yes
01:19:21 <avpx> Typical? In what regard?
01:19:24 <earthy> ML or lisp
01:19:31 <EvanR2> javascript
01:19:34 <EvanR2> haha
01:19:38 <apple_user> http://www.haskell.org/haskellwiki/FAQ#Is_learning_Haskell_the_best_way_to_learn_functional_programming.3F
01:19:47 <avpx> Learning Haskell is the best way to learn Haskell
01:19:51 <shurikas> typescript
01:20:03 <avpx> C++ templates
01:20:09 <YayMe> basic!
01:20:19 <apple_user> I'm learning FP through Scala, but it seems much easier to do in Haskell than scala
01:20:30 <shurikas> Haskell has an extremely active community of people teaching, doing research, writing libraries, etc. Haskell is where interesting things happen in the FP space, so it's an exciting place to jump in.
01:20:35 <shurikas> that's the main reason why haskell is awesome
01:20:36 <apple_user> right
01:20:37 <EvanR2> scala seems like an imperative language
01:20:42 <YayMe> wait what? No, I definitely think haskell is the best way, I feel slightly brain damaged from it, but I don't know any other language that makes it so non-idiomatic to do imperative
01:20:59 <shurikas> i love the brain damage haskell gives me
01:21:06 * shurikas is a bit masochistic in that manner
01:21:31 <avpx> It's the kind of brain damage that makes me study category theory when I get spare time.
01:21:50 <apple_user> what's category theory/
01:21:53 <GnomeStoleMyBike> typescript is just a lie
01:22:12 <Eduard_Munteanu> Mm... huffing paint or learning Haskell? Learning Haskell it is... :P
01:22:34 <GnomeStoleMyBike> you don't even have types in typescript
01:23:07 <EvanR2> TypeScript is a language for application-scale JavaScript development.
01:23:09 <avpx> apple_user: It was created in the 40s by a time travelling algebraist who wanted to create a better way to do computations in functional languages like Haskell.
01:23:10 <Eduard_Munteanu> apple_user: a branch of mathematics concerned with abstract representations of various other branches of math
01:23:14 <EvanR2> "blank-scale"
01:23:20 <YayMe> "application-scale" hah what?
01:23:29 <GnomeStoleMyBike> EvanR2: thats a lie
01:23:49 <EvanR2> i guess-scale scale-scale is the new-scale drop-in-scale jargon
01:23:53 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Category_theory
01:24:12 <Eduard_Munteanu> Also, ##categorytheory :P
01:24:13 <shurikas> GnomeStoleMyBike, but you have to type
01:24:21 <shurikas> and you get script out of it
01:24:26 <shurikas> therefore typescript
01:24:56 <GnomeStoleMyBike> EvanR2: maybe js_of_ocaml, haskell "fay" or coffeeScript is a solution.
01:25:07 <EvanR2> fuck coffeescript
01:25:21 <GnomeStoleMyBike> shurikas: typeScript is just a thing that m$ will push forward and leave to die next year or two
01:25:29 <avpx> Eduard_Munteanu: Wait, there's a separate channel for category theory?
01:25:51 <Ralith> YayMe: that's a strange thing to say
01:26:00 <Ralith> because I don't know any other language that makes it so idiomatic to do imperative.
01:26:02 <shurikas> GnomeStoleMyBike, I actually like it's features so far
01:26:04 <Eduard_Munteanu> avpx: sure, founded by people in here :)
01:26:05 <GnomeStoleMyBike> EvanR2: learning typescript is waste of time. Because like every thing that microsoft and google do in field of new languages will be killed in two years.
01:26:07 <shurikas> its*
01:26:22 <avpx> Eduard_Munteanu: Well I guess that makes sense.
01:26:26 <Ralith> GnomeStoleMyBike: why do you say that?
01:26:31 <shurikas> he is a hater
01:26:33 <trotro> GnomeStoleMyBike, totally agree... only C#.net survuved :)
01:26:34 <shurikas> :D
01:26:50 <GnomeStoleMyBike> trotro: WinRT can be possible .NET killer
01:26:51 <hiptobecubic> F# as well
01:26:52 <EvanR2> survuval of the fittest
01:26:53 <Dtgr> f# and go are going strong as well...
01:27:09 <EvanR2> lol
01:27:16 <EvanR2> what is written in go
01:27:20 <GnomeStoleMyBike> Ralith: from the history Iron Ruby, Iron Python, J#, J++ and so many other examples
01:27:22 <shurikas> f# is freakish :/
01:27:28 <shurikas> it's like haskell but bad...
01:27:34 <Ralith> shurikas: why is it bad?
01:27:40 <Ralith> GnomeStoleMyBike: that's not very strong evidence.
01:27:42 <GnomeStoleMyBike> also Google Go, Dart...all dead things that why i don't touch F# i love Haskell
01:27:52 <Ralith> Go is anything but dead.
01:27:57 <YayMe> Ralith: I agree haskell's imperative facilities are pretty spectacular, but basically any reading or learning you try to do in haskell will have the functional parts jammed down your gullet, I went to read some erlang books and some snippets to get a feel for it; probably 80% of it is imperativeish
01:27:59 <shurikas> Ralith, the only thing I remember from it is it's happy operator ':>'
01:28:00 <Ralith> misguided, perhaps, but quite lively.
01:28:11 <shurikas> but I find syntax being quite ugly
01:28:12 <hiptobecubic> I think It's like haskell in a sense, but they ignored the fact that it's like haskell and tried to frame it as "able to mimic C#"
01:28:21 <trotro> if you look closely the languages that survive are the one with a unified graphics interface
01:28:23 <GnomeStoleMyBike> Ralith: if m$ killing all except .NET is not strong, i think you should learn type script :)
01:28:29 <Ghoul> .NET won't die
01:28:31 <Ralith> YayMe: oh, yes, in that regard I agree entirely.
01:28:31 <Ghoul> Go look at Proton
01:28:33 <Ghoul> It's incredible.
01:28:38 <shurikas> and also it's functional, but you are encouraged to have bugs
01:28:39 <trotro> (at the time of terminal, it was those who got a unified console interface)
01:28:42 <EvanR2> some things youd consider easy in imperative languages are annoying in haskell, like 'return'ing
01:28:48 <Ghoul> It's an operating system with an inbuilt asm jit
01:28:50 <Ghoul> for IL languages
01:28:54 <Ghoul> absolutely incredible
01:29:00 <GnomeStoleMyBike> Go was dead from start because it did not had pattern matching :)
01:29:01 <Ghoul> rapes mono by 2-3x in terms of speed.
01:29:23 <Ghoul> Or so, theoretically
01:29:26 <shurikas> GnomeStoleMyBike, it's funny how they say go is to be used by system programmers!
01:29:29 <Ghoul> with the latest commits
01:29:42 <GnomeStoleMyBike> if someone creates a language after 1980 without pattern matching he is doing stuff wrong :D ( my own opinion )
01:29:46 <Ralith> ah, theoretical speed.
01:29:47 <Ghoul> I wonder when it'll be ready.
01:29:49 <Ralith> my favorite kind!
01:29:53 <Ghoul> Well
01:29:57 <Ghoul> using a brute force GC
01:30:00 <Ghoul> and a ton of unoptimised shit
01:30:01 <notdan> lol
01:30:04 <trotro> GnomeStoleMyBike, maybe... but the language could be used
01:30:05 <YayMe> Ralith: I like theoretical slow, it's more relaxing
01:30:06 <GnomeStoleMyBike> shanem:  +1
01:30:06 <Ghoul> it performed at the same speed as mono
01:30:16 <Ghoul> slightly faster
01:30:23 <Ralith> YayMe: hm, a compelling point.
01:30:25 <shanem> GnomeStoleMyBike: Excuse me?
01:30:25 <shurikas> Ralith, you have a point
01:30:27 <shurikas> it's theoretical
01:30:31 <shurikas> but it's also SYSTEM programming
01:30:31 <EvanR2> fast and loose language implementation bashing
01:30:32 <EvanR2> nice
01:30:34 <Ghoul> Since then they improved on the parts that were the slowest
01:30:37 <Ghoul> namely the GC
01:30:39 <shurikas> not front-end application programming
01:30:42 <GnomeStoleMyBike> trotro: i work in a company that used to control satelites using system written in Perl i belive anything can be used anywhere :)
01:30:54 <kamekura> hi all.  Haskell's and C's printf has different defaults, is there a nice way to make Haskell's printf behaviour?
01:30:55 <shurikas> hmm ,ok
01:30:59 <Ghoul> Can't be tested yet though
01:31:03 <Ghoul> since they went too far into dev
01:31:04 <GnomeStoleMyBike> shanem: sorry mate i wanted to +1 shurikas
01:31:05 <YayMe> shurikas: f# is supposed to be more akin to ocaml as I understand it, though I do agree that I don't care for it's syntax
01:31:05 <trotro> GnomeStoleMyBike, :)
01:31:12 <Ghoul> Gotta rewrite corlib now
01:31:14 <EvanR2> kamekura: concat [pieces, of, your, string]
01:31:16 <Ghoul> before the next benchmark can be made
01:31:22 <Ralith> kamekura: what do you need this for?
01:31:25 <shanem> GnomeStoleMyBike: Ah no worries
01:31:32 <shurikas> GnomeStoleMyBike, +1 on what?
01:31:37 <notdan> F# is quite nice, I like their computational expressions (monads), their async monad and type providers
01:31:39 <YayMe> shurikas: I did find value in playing with it though to broaden my understanding of how functional languages can also have redundant syntax like imperative ones do
01:31:45 * shurikas gets disconnected frequently
01:31:50 <kamekura> namely, in C printf ("%f", 0.1) will print 0.100000 but in Haskell the equivalent will print "0.1"
01:31:55 <trotro> notdan, please dn't call them monads, use the word workflows
01:32:05 <trotro> monads are bettre than thoses things
01:32:06 <apple_user> kamekura: what's the equivalent in haskell?
01:32:12 <notdan> trotro: in what way?
01:32:14 <apple_user> :t printf
01:32:15 <lambdabot> forall r. (PrintfType r) => String -> r
01:32:28 <EvanR2> kamekura: use specific formatting functions rather than printf, which you wont have as much control over
01:32:31 <kamekura> apple_user: samething : printf "%f" 0.1
01:32:35 <YayMe> notdan: the async stuff was pretty easy, I did like the <| and |>, though I could implement those in haskell in like 10 characters
01:32:48 <trotro> notdan, class of monads doesn't exist un F#
01:32:52 <Ralith> kamekura: printf is probably not the best way to get what you actually want.
01:32:56 <YayMe> notdan: the redirects that is, not the async obviously
01:32:58 <trotro> your code has to be bound to a specific instance
01:33:00 <Ghoul> Does haskell do automatic threadpooling
01:33:01 <kamekura> EvanR2: currently I'm using concat
01:33:02 <notdan> YayMe: yeah, but it's nice to have them in the standard library
01:33:06 <trotro> i never bound my code to specific instance, only to class
01:33:15 <trotro> F# is uncapable of doing that
01:33:17 <kamekura> but I thought printf would be nicer
01:33:32 <trotro> (I hate IO, because it's an instance and not a class)
01:33:36 <Ralith> kamekura: printf is not very idiomatic haskell.
01:33:41 <shurikas> oh yeah, that's true. Haskell types are universal compared to F#
01:33:48 <kamekura> Ralith: thanks. I'm using it for printing postscript
01:34:08 <Ralith> kamekura: you should write your own formatting stack with the specific behavior you require.
01:34:13 <EvanR2> kamekura: well in any case you dont have to relyon the default precision
01:34:17 <YayMe> notdan: Those were probably my only take aways from F#, I do recall at one point seeing "active pattern matching" or something it was called that was interesting, otherwise I just chalked it up to "nice to have a functional language on CLR", then went and found ela
01:34:24 <EvanR2> kamekura: i mean %.2f is like the whole point of using printf
01:34:41 <notdan> trotro: I see, fair enough
01:34:50 <notdan> YayMe: yea, active pattern matching is fun too
01:35:07 <EvanR2> also note that 0.1 as a float resulting in "0.1" is pretty suspicious ;)
01:35:16 <EvanR2> > 0.1
01:35:17 <lambdabot>   0.1
01:35:21 <EvanR2> > show 0.1
01:35:21 <kamekura> EvanR2: I know about the modifiers.. but I'd rather not write "%.6f" every time, but instead write a wrapper that does this
01:35:22 <lambdabot>   "0.1"
01:35:29 <Ghoul> > 0.1 + 0
01:35:31 <lambdabot>   0.1
01:35:39 <Ghoul> > 7 + 0.0
01:35:40 <lambdabot>   7.0
01:35:43 <Ralith> :t 0.1
01:35:45 <lambdabot> forall t. (Fractional t) => t
01:35:46 <EvanR2> kamekura: ok, wrapper x = printf "%.6f" x
01:35:47 <YayMe> notdan: oh, actually one big bonus: fparsec will be my go to if I ever have to do parsing in C# again, I'll just do it in that and I can call it from C#, so long as I can convince people at work.
01:35:49 <Ralith> doesn't look like a float to me
01:36:25 <notdan> YayMe: I haven't worked with parsec at all tbh, but I guess it's nice that there are functional parsers for .net
01:36:33 <kamekura> 0.1 is normal...
01:36:43 <Ghoul> > 0.1 << 1
01:36:45 <lambdabot>   Not in scope: `<<'
01:36:53 <Ghoul> ah poo
01:36:58 <Ghoul> there aren't any binary operators
01:37:12 <ion> > 3 `shiftL` 2
01:37:13 <lambdabot>   Ambiguous type variable `a' in the constraint:
01:37:13 <lambdabot>    `Data.Bits.Bits a'
01:37:14 <lambdabot>      a...
01:37:16 <merijn> Ghoul: There are, I think they're just not the usual ones
01:37:18 <ion> > 3 `shiftL` 2 :: Integer
01:37:20 <lambdabot>   12
01:37:23 <YayMe> notdan: have you worked on a large state machine style parser before? I have, they should all just be forced to carry around the attribute [Defective] in case people aren't aware..
01:37:29 <Ghoul> > 3 `shiftL` 16
01:37:31 <lambdabot>   Ambiguous type variable `a' in the constraint:
01:37:31 <lambdabot>    `Data.Bits.Bits a'
01:37:31 <lambdabot>      a...
01:37:34 <Ghoul> > 3 `shiftL` 16 :: Integer
01:37:36 <lambdabot>   196608
01:37:40 <merijn> Ghoul: You want Data.Bits :)
01:37:45 <EvanR2> > floatToDigits 10 0.1
01:37:46 <lambdabot>   ([1],0)
01:37:51 <EvanR2> > floatToDigits 100 0.1
01:37:52 <lambdabot>   ([10],0)
01:38:15 <Ghoul> floatToDigits 10 0.001
01:38:22 <Ghoul> > floatToDigits 10 0.001
01:38:24 <lambdabot>   ([1],-2)
01:38:26 <EvanR2> > floatToDigits 100 (0.1 :: Float)
01:38:27 <lambdabot>   ([10],0)
01:38:30 <Ghoul> wot
01:38:55 <merijn> :t floatToDigits
01:38:56 <lambdabot> forall a. (RealFloat a) => Integer -> a -> ([Int], Int)
01:39:23 * merijn has no clue what that does
01:39:30 <Jafet> > decodeFloat 0.01
01:39:32 <lambdabot>   (5764607523034235,-59)
01:39:43 <mats_> lol wtf
01:39:44 <ion> > floatToDigits 10000000000000000000000000000000000000000000 pi
01:39:45 <lambdabot>   ([3,-2056961399497127966],1)
01:40:03 * hackagebot test-framework-golden 1.1 - Golden tests support for test-framework  http://hackage.haskell.org/package/test-framework-golden-1.1 (RomanCheplyaka)
01:40:14 <EvanR2> > toRational (0.1 :: Float)
01:40:15 <lambdabot>   13421773 % 134217728
01:40:24 <EvanR2> > toRational (0.1 :: Double)
01:40:25 <lambdabot>   3602879701896397 % 36028797018963968
01:40:27 <Jafet> @where pi_10
01:40:27 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
01:40:37 <EvanR2> > toRational (0.1 :: CReal)
01:40:39 <lambdabot>   *Exception: CReal.toRational
01:41:02 <EvanR2> ah i forgot, there are non rational reals ;
01:41:03 <EvanR2> )
01:41:23 <Jafet> > approxRational 0.1 (0.01 :: CReal)
01:41:25 <lambdabot>   *Exception: CReal.toRational
01:41:48 <EvanR2> can i has isRational :: CReal -> Bool
01:41:50 <apple_user> is length O(n)?
01:41:54 <apple_user> length of a list
01:41:56 <EvanR2> yes
01:42:44 <apple_user> how would I implement binary search in Haskell
01:43:03 <EvanR2> with a recursive function
01:43:10 <EvanR2> and a tree
01:43:19 <apple_user> a tree? ah
01:43:37 <EvanR2> @src Tree a
01:43:38 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:43:52 <EvanR2> @src Tree
01:43:52 <lambdabot> Source not found. I've seen penguins that can type better than that.
01:43:57 <EvanR2> @src Maybe
01:43:57 <lambdabot> data Maybe a = Nothing | Just a
01:44:31 <EvanR2> data Tree a = Leaf a | Branch a (Tree a) (Tree a)
01:44:39 <Jafet> "It is obvious that irrationals are uninteresting to the engineer, since he is only concerned with approximations and all approximations are rational."
01:45:02 <merijn> @remember ManuelChakravarty We used to say, "Learn Haskell, it makes you a better Java programmer." Now we say, "Learn Agda, it makes you a better Haskell programmer."
01:45:02 <lambdabot> Done.
01:45:56 <earthy> :)
01:46:48 <ion> “$” overload https://github.com/feuerbach/test-framework-golden/blob/master/Test/Framework/Providers/Golden/Advanced.hs
01:47:30 <kamekura> @quote ManuelChakravarty
01:47:30 <lambdabot> ManuelChakravarty says: We used to say, "Learn Haskell, it makes you a better Java programmer." Now we say, "Learn Agda, it makes you a better Haskell programmer."
01:47:40 <EvanR2> bling overload
01:47:54 <kamekura> @quote fogus
01:47:55 <lambdabot> No quotes match. That's something I cannot allow to happen.
01:48:40 <Jafet> I thought you were talking about overloading $.
01:49:06 <EvanR2> ah, he means perl/php string substitution
01:49:12 <EvanR2> 'string interpolation'
01:49:34 <EvanR2> maybe
01:49:38 <Jafet> @hoogle ($$)
01:49:39 <lambdabot> Text.PrettyPrint.HughesPJ ($$) :: Doc -> Doc -> Doc
01:49:39 <lambdabot> Text.PrettyPrint ($$) :: Doc -> Doc -> Doc
01:49:39 <lambdabot> Language.Haskell.TH.PprLib ($$) :: Doc -> Doc -> Doc
01:49:43 <Jafet> @hoogle ($$$)
01:49:44 <lambdabot> No results found
01:49:50 <EvanR2> @hoogle (<>)
01:49:50 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
01:49:51 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
01:49:51 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
01:50:37 <EvanR2> > [0] <> [0]
01:50:39 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
01:50:39 <lambdabot>         agains...
01:50:51 <EvanR2> why is that in lambdabot >_<
01:51:05 <Jafet> > text ":-)"
01:51:07 <lambdabot>   :-)
01:51:45 <Jafet> Is interpolation controlled by Interpol?
01:52:05 <apple_user> so it doesn't make sense to binarySearch a Haskell linked-list?
01:52:14 <EvanR2> no
01:52:25 <EvanR2> or in any other language linked-list
01:52:26 <osfameron> an array maybe?
01:52:32 <Jafet> Sure it does
01:52:33 <apple_user> makes sense to search a Data.Array I guess
01:52:50 <apple_user> why use Data.Arrays though?
01:53:05 <EvanR2> it makes sense to binary search a binary search tree
01:53:23 <apple_user> right
01:53:42 <apple_user> I think Data.Map is ideal ^_^
01:53:52 <EvanR2> IntMap ;)
01:54:24 <EvanR2> also HashMap
01:55:03 <EvanR2> it would be fun to have a haskell module for php arrays
01:55:13 <EvanR2> with all the nonsense methods
01:55:14 <Ralith> apple_user: it makes sense to binary search whatever data structure you need to perform a binary search within.
01:55:15 <killy9999> :t extent
01:55:16 <lambdabot> Not in scope: `extent'
01:55:21 <apple_user> right
01:55:25 <killy9999> :t Data.Array.Repa.extent
01:55:26 <lambdabot> Couldn't find qualified module.
01:55:56 <zomg> EvanR2: Let's port PHP.JS to Haskell! PHP.hs
01:55:58 <zomg> :P
01:56:37 <EvanR2> on it
01:57:02 <killy9999> http://hackage.haskell.org/packages/archive/repa/latest/doc/html/Data-Array-Repa.html
01:57:14 <Jafet> > "1" === True
01:57:16 <lambdabot>   True
01:57:17 <killy9999> doecumentation gives type of extent as Shape sh => Array r sh e -> sh
01:57:35 <killy9999> while ghci gives it as (Shape sh, Source r e) => Array r sh e -> sh
01:57:40 <killy9999> why the difference?
01:58:06 <Jafet> Because you have a different version of repa
01:58:34 <killy9999> is it becuse extent is dfined in Source typeclass and Source is implictly assumed in the docs
01:58:35 <killy9999> hm
01:58:38 <Jafet> Or that
01:59:21 <Jafet> Okay, no other version has that anyways
01:59:34 <killy9999> Jafet: I have repa 3.2.1.1, doc is for repa 3.2.2.1 :)
02:00:04 * hackagebot GLFW-b 0.1.0.4 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.1.0.4 (BrianLewis)
02:00:25 <merijn> @hoogle (Monad m, Traversable t) => a -> t (a -> m b) -> m (t b)
02:00:26 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
02:00:26 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:00:26 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
02:11:32 <rking> I suck. https://gist.github.com/0e51c35996451877d077
02:12:24 <rking> I know I need to actually learn Haskell, really. But still.
02:13:23 <Nereid> if you just want it to work then you could be horrible and stick an unsafePerformIO there
02:13:42 <sp3ctum> rking, lokos like your myModMask function doesn't return the correct type.
02:13:56 <sp3ctum> i concur with Nereid, probably the easiest
02:14:57 <rking> Hehe, sounds fun.
02:15:06 <fmap> or call `system' before `xmonad' in xmonad.hs
02:15:10 <sp3ctum> what would be another way?
02:15:24 <zomg> unsafePerformIO best function in Haskell
02:15:26 <zomg> lol
02:15:52 <rking> fmap: Whoa, wouldn't have guessed that as being an answer. I thought the order kind of didn't matter
02:16:02 <zomg> also unsafeCoerce
02:16:16 <maukd> rking: what are you trying to do?
02:16:35 <trotro> the function you-know-wich-one beurk
02:16:39 <fmap> rking: the whole point of IO is that order matters
02:18:54 <rking> maukd: It's just a safety check. I generally map caps lock to be mod3 in my ~/.Xmodmap, but if it isn't mapped, and I say myModMask = mod3Mask,  I end up with a basically dead Xmonad.
02:19:55 <maukd> rking: so what are you trying to do?
02:20:37 <rking> Check to see if any key is bound to mod3. If yes, use mod3Mask, else, fall back to mod1Mask.
02:20:52 <maukd> when?
02:22:21 <rking> Chronologically?  What-when?
02:22:37 <maukd> when is this check supposed to occur?
02:23:02 <rking> Just whenever Xmonad starts. The .Xmodmap already did its thing by that point.
02:24:05 <maukd> determineModMask = do r <- system "..."; return (if r == ExitSuccess then mod3Mask else mod1Mask)
02:24:41 <maukd> main = do myModMask <- determineModMask; xmonad $ defaultConfig{ modMask = myModMask, ...
02:25:05 * hackagebot xml2json 0.2.0.0 - translate xml to json  http://hackage.haskell.org/package/xml2json-0.2.0.0 (YiHuang)
02:25:25 <sp3ctum> yes
02:32:34 <rking> maukd: Oh sorry, just now saw that. Checking.
02:33:18 <rking> Now I see what is meant by "call system before xmonad"
02:37:25 <hpaste> killy9999 pasted “Repa problem” at http://hpaste.org/75750
02:37:43 <killy9999> Any ideas how to write this code properly?
02:38:14 <rking> I feel like I'm getting close, but not quite: https://gist.github.com/279913c139201a1ce91a
02:39:13 <maukd> rking: put a newline after each 'do', replace ';' by newline
02:39:28 <maukd> indent the '{' part more than 'xmonad'
02:39:54 <killy9999> I guess that ; only work if you place whole do-expression in { }
02:40:04 <Nereid> correct
02:40:56 <killy9999> any idead abut my repa error?
02:41:12 <killy9999> I'm just can't figure out why doesnt enumFromN return unboxed vector...
02:41:44 <maukd> killy9999: no
02:41:49 <maukd> you can use ; anywhere
02:41:50 <rking> maukd: Hehe, don't know what I did but there went Xmonad
02:42:34 <rking> "waitForProcess: does not exist (no child process)"
02:42:41 <maukd> oh, right
02:42:45 <maukd> system doesn't work in xmonad
02:43:14 <maukd> except it should because you haven't even started xmonad yet at that point
02:45:38 <maukd> rking: try adding 'installHandler processStatusChanged Default Nothing' as the first statement in main
02:45:59 <rking> maukd: OK
02:46:02 <maukd> if that complains about identifiers not being in scope, add 'import System.Posix.Signals'
02:47:27 <rking> maukd: Hey, wow… it didn't error or exit Xmonad.
02:47:36 <rking> Now to test it with a broken mod3
02:48:04 <maukd> nice
02:49:51 <kamekura> @quote dons
02:49:51 <lambdabot> dons says: note to self: grep only works on disks
02:51:02 <rking> maukd: Hrm, no, when the grep fails I end up with no usable mapping
02:51:50 <jaxcx> hello. can someone recommend me a portable gui library? ideally it would work on linux, osx and windows
02:53:14 <jaxcx> my first instinct was qt but http://qthaskell.berlios.de/  wasn't updated in 2 years
02:53:31 <zomg> GTK maybe? No idea of any haskell bindings though
02:53:40 <TheBrayn> tk, gtk, qt
02:53:46 <maukd> @where gtk2hs
02:53:46 <lambdabot> http://haskell.org/gtk2hs/
02:54:53 <astry> gtk2hs is good
02:55:21 <jaxcx> what about qt bindings?  between the three i'd prefer qt unless haskell bindings aren't the best
02:56:12 <astry> you want gtk
03:01:56 <earthy> qt haskell exists.
03:02:07 <earthy> that's about as far as it goes. :)
03:02:54 <earthy> (it isn't really maintained, even)
03:03:49 <alpounet> i don't think it's been updated in a while
03:03:52 <alpounet> and even back in the time
03:03:56 <alpounet> it wasn't all that great
03:04:11 <alpounet> gtk2hs might be a better shot honestly
03:04:17 <maukd> rking: well, you could add 'print myModMask' and see what it's selected
03:04:39 <rking> maukd: Aha!  printf() debugging. Now we're talking familiar ground.
03:04:58 <maukd> heh
03:05:10 <rking> Where would that go, though?
03:05:30 <rking> As a line in main after myModMask <- determineModMask  ?
03:05:59 <maukd> yes
03:06:11 <rking> OK I should sleep but I can't let this go just yet.
03:08:51 <rking> Heh, prints "32" in the successful case.
03:08:56 <rking> Not sure what that number would mean.
03:09:22 <maukd> mod3Mask
03:09:43 <maukd> I checked in ghci by doing 'import XMonad', then 'mod3Mask'
03:09:53 <maukd> mod1Mask is 8 here
03:09:57 <rking> Yeah
03:10:06 <rking> I added those as plain prints above it
03:10:12 <rking> Cool to know you can use ghci like that though
03:17:14 <rking> maukd: Awesome.
03:17:26 <rking> My grep was off. I was checking for /^mod3\s*\S*/
03:17:53 <rking> Which the output of xmodmap is like this when there's no mapping: "mod3 <nothing here>"
03:17:58 <maukd> ah
03:18:05 <rking> I took the 2nd asterisk off and it works exactly as it's supposed to.
03:19:23 <rking> OK, I think I vaguely understand the core idea here.
03:20:33 <rking> main "is an IO", which means *something mumble I get that it pertains to pure function stuff mumble*, so when determineModMask is called from there it somehow inherits the IOness
03:20:48 <rking> Or, it's called before the xmonad part
03:20:57 <rking> Yeah
03:21:16 <rking> If it happens after "xmonad" the IOness is gone, but here it happens before.
03:21:26 <akamaus> I'm trying to make a simple framework for serializing and deserializing different versions of a data type and migration between them. This is that I have so far: http://hpaste.org/75751 Am I on a right way?
03:21:39 <rking> Anyhow, there's enough in this file that once I understand more about Haskell I'll be able to get what you did.
03:21:41 <rking> So thanks.
03:23:44 <rking> No, there's still the processStatusChanged part I don't really understand. But I'll get it later.
03:24:57 <merijn> ok, I need some help doing vile stuff
03:25:51 <merijn> I need to assign unique (at compile time) identifiers to some expressions, preferably without having to handwrite the code. Any good tricks to use?
03:26:06 <fmap> rking: modMask determination is an IO action, XMonad launch in another IO action, main is an IO action which combines previous two with some order
03:26:09 <merijn> Or is the trick just "you're screwed, pass the values in explicitly"?
03:26:26 <zomg> merijn: I guess you could do that with template haskell or something
03:26:49 <merijn> zomg: That's what I figured, I was hoping for some slightly more specific clues ;)
03:27:05 <zomg> Yeah haven't really used it besides glancing over it a couple of times =)
03:27:17 <bls> merijn: i'm unlikely to be able to help, but could you help me understand the problem?
03:27:20 <bls> ;)
03:28:06 * bls is an ok rubber duck
03:28:22 <merijn> bls: I have a program that instantiates a process tree, the program runs concurrently on multiple nodes, I need consistent unique identifiers for tree sections
03:28:38 <bls> literal processes?
03:28:55 <merijn> bls: Well, threads, but more or less, yes
03:29:29 <bls> so the identifiers are essentially names?
03:29:51 <bls> do you need to be able to address things between nodes without a central registry?
03:29:54 <merijn> Some tree branches unfold dynamically, so a simple counter is not sufficient as the tree is not always walked in the same order on different nodes. I want to assign identifiers to the dynamic branches at compile time so that they're *always* consistent
03:30:18 <bls> could you assign labels walking down the tree?
03:30:48 <merijn> The rest unfolds deterministically, so as long as I have known unique identifier for the roots of the dynamic parts I can provide deterministic naming as I instantiate tree sections
03:32:01 <merijn> bls: Yes, but I can't guarantee dynamic sections inside dynamic sections get instantiated in the right order. So I need unique naming at compile time for those dynamic sections. Be it through passing an identifier in by hand or  by autogenerating it
03:32:54 <bls> so i guess there is no property of the dynamic sections you can use for naming purposes?
03:33:23 <maukd> rking: the signal stuff resets the action for SIGCHLD to SIG_DFL. this may not make sense if you don't know unix :-)
03:33:29 <merijn> bls: Nope
03:33:35 <alpounet> merijn, GHC has a library for stable names
03:33:41 <alpounet> but that requires going in IO...
03:33:53 <merijn> alpounet: All my code is in IO anyway...
03:34:09 <bls> merijn: thanks for playing along; I guess I don't understand your problem well enough to be useful
03:34:11 <alpounet> it's not compile-time though
03:34:23 <osa1> when writing wrappers around C FFI functions, I should convert CFloats to Haskell Floats, and CDoubles to Haskell Doubles, right ? Or are Haskell Floats big enough for converting CDoubles to Haskell Floats to be safe ?
03:34:35 <merijn> alpounet: I don't see how you could solve the problem at runtime?
03:35:14 <merijn> osa1: I don't think Float is a datatype in Haskell? I think there's just the Floating typeclass (which has Double in it)
03:35:49 <alpounet> merijn, may also be relevant http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Data-Unique.html
03:35:57 <alpounet> but that still is in IO and is not performed at compile time
03:35:58 <Saizan> > 1 :: Float
03:35:59 <osa1> merijn: data Float = GHC.Types.F# GHC.Prim.Float# it looks like a data type
03:35:59 <lambdabot>   1.0
03:36:15 <Saizan> osa1: i'm pretty sure Float is single precision
03:36:43 <osa1> Saizan: OK so CDouble's Haskell equivalent is Double, right ?
03:37:39 <bls>  merijn: one more silly thought: are the branches of your tree orderable in any way?
03:37:49 <bls> like could you force an ordering?
03:38:54 <merijn> bls: In theory, yes. But in practice I don't unfold the tree on all nodes and without doing that you can't really base anything on the structure of it
03:39:13 <merijn> osa1: Ok, I stand corrected :p
03:39:24 <Saizan> osa1: yeah
03:39:34 <merijn> alpounet: Ah, thanks but that's not really suited to what I meant :)
03:40:06 <alpounet> merijn, yeah i think i see what you mean now
03:40:54 <bls> merijn: i guess i don't understand how you could have the problem of needing to assign names to things at compile time which are computed dynamically
03:42:49 <jaxcx> on gtk.org it says "Note that you need Cabal 1.8 to get ghci support."
03:42:54 <osa1> Saizan: what about CLong and CLLong ? how wide is Haskell's Int and Integer ?
03:43:07 <jaxcx> does that mean i wont be able to use GTK in ghci without cabal 1.8 ?
03:43:10 <bls> merijn: apologise if I'm wasting your time...
03:43:44 <maukd> Int is like 30 bits, Integer is unbounded
03:44:15 <maukd> for CLong you could use Int32 and for CLLong Int64, or you could just say fuck it and use Integer everywhere
03:44:34 <osa1> maukd: nice, thanks.
03:44:36 <maukd> well, Int is actually 32/64 bits in ghc
03:44:51 <maukd> but the standard says some bits may be reserved in some implementations
03:44:54 <osa1> maukd: isn't CLong is wider than 32bits?
03:45:05 <osa1> maukd: because Int is already 32bit ?
03:45:16 <maukd> the C standard says a long int is at least 32 bits wide, and int at least 16 bits
03:45:35 <maukd> so actually I'm wrong here
03:45:49 <maukd> a C implementation could use 128 bit integers for everything, including char
03:45:55 <osa1> wow
03:45:57 <alpounet> CLong corresponds to Int64 in Haskell
03:46:04 <maukd> alpounet: except where it doesn't
03:46:11 <alpounet> (doc says)
03:46:13 <maukd> like on my PC, where it's 32 bits wide
03:46:20 <maukd> 'long int', that is
03:47:14 <merijn> bls: I have dynamic unfoldings inside dynamic unfoldings. But different sections may be unfolded on different nodes. As such it's not possible to know (at runtime) all the dynamic sections (at least not without unfolding them all). At compile time I can easily see (inside my data structure) which sections are dynamic. If I label them there there's no longer any race where naming depends on the order in which dynamic sections get unfolded within a dyna
03:47:56 <osa1> alpounet: can you refer me to that docs ? I think I'll leave that Integer for now.
03:47:58 <maukd> I guess you need to distinguish between C->Haskell and Haskell->C
03:48:13 <merijn> alpounet: CLong corresponds to whatever the compiler decides is a long int on your architecture
03:49:05 <merijn> If you want guarantees on bit lengths you're probably better using Data.Word
03:49:15 <alpounet> osa1, no actually what i said is stupid, it's the case on the computer hosting the docs, that's all :)
03:49:31 <merijn> > maxBound :: CLong
03:49:32 <lambdabot>   Not in scope: type constructor or class `CLong'
03:49:55 <alpounet> CLong just guarantees to represent C's long int
03:50:24 <alpounet> however wide it is
03:50:40 <osa1> merijn: wow thanks for the tip. maxBound should help.
03:50:59 <absence> why isn't -split-objs default? are there problems with it?
03:51:06 <merijn> > maxBound :: Word32
03:51:07 <lambdabot>   4294967295
03:51:11 <merijn> > maxBound :: Word64
03:51:13 <lambdabot>   18446744073709551615
03:51:54 <bls> merijn: right; OK, so pretend it were a chess move tree right; at position on the board there are a finite number of possible moves. I might not know how many moves from a given board position at compile time. But I could label the possible moves from a given position uniquely -- but only using the structure of the problem itself, e.g. assigning a weight to each piece, and a weight to each board position, and deriving a label from t
03:51:55 <bls> hat
03:52:28 <bls> hmmm weight is not the best move... but
03:52:30 <Saizan> absence: it makes the linker work much harder
03:53:24 <bls> merijn: i guess what i'm saying is, i can't see how you could derive unique and predictable labels without using the structure of the problem
03:53:31 <merijn> bls: Chess move trees are not at all similar as they're not unfolding dynamically. You can compute them lazily/on demand
03:53:56 <alpounet> merijn, some code could help here
03:54:05 <alpounet> i'm not sure why Data.Unique doesn't work for you
03:54:26 <merijn> bls: Simple, label the first dynamic unfolding 1, the second 2, etc. number relative to parent dynamic unfolder
03:54:42 <absence> Saizan: so it's a performance vs size thing? but still, haven't c compilers been doing this forever, or is that different due to haskell-specific obstacles?
03:54:52 <merijn> alpounet: Because generating unique names is not my problem. I can trivially use ints. *assigning* said names is my problem :p
03:55:18 <merijn> Or rather, the fact that I don't want to litter the code with explicit annotations, because I'm a masochist that rather solves it the difficult but pretty way :p
03:55:32 <alpounet> merijn, can't you thrown the id to a node at the moment it's created?
03:55:49 <merijn> alpounet: Sure, but than my id's are not consistent across nodes
03:56:05 <bls> merijn: if the number of unfoldings is countable, it should be solvable right?  i mean is it based on some data which is hashable?
03:56:28 <merijn> bls: No, my data are forkIO threads
03:56:31 <Saizan> absence: have they? i only know that ld/gold can take a lot of time and memory to link code generated by GHC and split-objs for every lib would make it worse
03:57:16 <bls> merijn: right, but those things shouldn't really have a predictable identity; what i mean is, they should probably be *doing* something, and isn't it the *something* that they are working on which should have a name, rather than the thread?
03:58:10 <merijn> bls: I have a graph of them, their position in the graph has a name
03:58:56 <bls> merijn: how come that doesn't work?
03:59:57 <merijn> Because without providing an anchor in the form of a name for the dynamic bits I don't have a good way of determining their position in the graph...
04:00:05 <merijn> Anyway, I have a meeting now..
04:00:08 <absence> Saizan: i think so. a statically linked hello world in c is 50k here, and that's a lot smaller than the c lib :) but it makes sence if ld is having a hard time of course
04:00:16 <bls> merijn: thanks for that
04:03:49 <Jafet> <dcoutts> the real problem is that ghc's .a files contain 10s of 1000s of .o files, and that makes ld cry.
04:13:31 <absence> does anyone know which file i can add :script stuff to for winghci?
04:19:23 <bls> merijn: when u get back, i just remembered gensym from my lisp days, then i looked up what the Haskell equivalent is, apparently someone else has needed this: http://stackoverflow.com/questions/6271285/does-haskell-have-something-like-gensym-in-racket -- but u never need this outside metaprogramming e.g. template haskell
04:27:43 <myname_> @pl \a -> (toLower (head a)) : (tail a)
04:27:43 <lambdabot> ap ((:) . toLower . head) tail
04:29:50 <myname_> what the hell is ap?
04:30:07 <Nereid> @src ap
04:30:07 <lambdabot> ap = liftM2 id
04:30:09 <Nereid> heh.
04:30:27 <Nereid> ap f g x = f x (g x)
04:30:52 <sanjoyd> *le S combinator
04:31:07 <sanjoyd> @src liftM2
04:31:08 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:31:13 <myname_> but it doesn't compile
04:31:15 <myname_> No instance for (Monad ((->) [Char]))
04:31:33 <myname_> ap ((:) . toLower . head) tail $ "test"
04:31:53 <fmap> > _head %~ toLower $ "HELLO"
04:31:54 <lambdabot>   Not in scope: `_head'Not in scope: `%~'
04:31:58 <fmap> okay :(
04:32:39 <quuuux> myname_: you need to import Control.Monad.Instances for that instance
04:34:12 <myname_> i imported ap from from Control.Monad
04:34:31 <myname_> `Control.Monad.Instances' does not export `ap'
04:35:23 <quuuux> yes. ap is defined in Control.Monad. Monad ((->) r) is defined in Control.Monad.Instances.
04:36:24 <myname_> ah, now it works, thx quuux
04:37:57 <dd> hi
04:55:39 <otters> there's a package called "old-locale" but I can't find the "new locale package"
04:55:42 <otters> that old-locale advises me to use
04:56:59 <Igloo> otters: there isn't one. Use old-locale
04:58:40 <dd> can I ask some newbie questions in here?
04:59:46 <otters> well that seems silly
05:01:10 <ivanm> dd: sure
05:01:27 <ivanm> otters: I think the intention was "this package isn't that great, so let's re-name it so someone gets the urge to write a new one"
05:01:32 <ivanm> but no-one can be bothered :)
05:01:42 <otters> oh
05:02:13 <oZt> Hello, I'm new to haskell and I have a problem with cabal. "Ambiguous occurrence `left'" -- it seems to be defined in two different places. This gives ExitFailure 1 when trying to install errors-1.1.1. Does anyone know if there is a solution to this or if there's something I miss? I'm on Arch, with a freshly installed ghc and cabal. cabal install errors-1.1.1 is the failing command.
05:02:35 <quuuux> dealing with locales is generally horrible anyway, I can understand why no-one wants to put the shift in
05:03:39 <otters> yeah
05:03:51 <otters> I'm trying to figure out how to adjust this UTCTime to be EST instead of UTC
05:03:54 <dd> I have a calculation i'm going to use multiple times:  sqrt 3.  I've defined a function sqrt3 = sqrt 3.  Does haskell keep calculating this over and over again or does it cache the result once it calculates it once?
05:04:58 <ClaudiusMaximus> dd: test it with Debug.Trace, but it should be floated out as a constant (depending on if it has a monomorphic type, and possibly other things)
05:04:58 <quuuux> oZt: 'cabal install errors' works for me, but it fetches version 1.3.1. Try 'cabal update' and then trying again?
05:05:11 <magicman> @type utcToZonedTime -- otters
05:05:12 <lambdabot> Not in scope: `utcToZonedTime'
05:05:17 <magicman> v_v
05:05:29 <magicman> @hoogle utcToZonedTime
05:05:29 <lambdabot> Data.Time.LocalTime utcToZonedTime :: TimeZone -> UTCTime -> ZonedTime
05:05:43 <alpounet> @type Data.Time.LocalTime.utcToZonedTime
05:05:44 <lambdabot> time-1.1.4:Data.Time.LocalTime.TimeZone.TimeZone -> time-1.1.4:Data.Time.Clock.UTC.UTCTime -> time-1.1.4:Data.Time.LocalTime.LocalTime.ZonedTime
05:05:53 <otters> yeah, found it
05:06:03 <ivanm> oZt: can you give us any more information?
05:06:04 <alpounet> admittedly handy
05:06:14 <ivanm> otters: isn't that just part of the time package?
05:06:47 <ivanm> dd: if you define that value (and it's not a function!) with a definite type sig (e.g. sqrt3 :: Double) then it will cache the result
05:06:49 <dd> Thanks!  My other question is one of style.  If I have another function:  foobar i = 2 * i.  Should I define it that way or foobar = (*) 2 ??
05:06:57 <ivanm> if you leave it polymorphic then it won't be cached
05:07:18 <opqdonut> dd: both are fine
05:07:36 <opqdonut> dd: in this particular case the former is more clear
05:07:46 <sanjoyd> Is there some idiom to have mutually recursive functions in separate modules?
05:07:52 <dd> so point-free only if it reads better?
05:07:56 <sanjoyd> I get stuck with a cyclic import.
05:07:56 <opqdonut> but for example "foo = filter p" might be preferable to "foo xs = filter p xs"
05:08:09 <opqdonut> dd: yeah
05:08:39 <opqdonut> but it's a matter of taste. some people strongly prefer point-free, other people don't
05:09:27 <hiptobecubic> i like it because it makes me think about the functions instead of the results
05:10:13 * hackagebot spatial-math 0.1.7 - 3d math including quaternions/euler angles/dcms and utility functions  http://hackage.haskell.org/package/spatial-math-0.1.7 (GregHorn)
05:10:36 <sanjoyd> Point-free makes you think hard about _what_ a function does. I really like that.
05:10:56 <Jafet> sanjoyd: well, you can do cyclic imports
05:11:16 <Jafet> You can also make the recursion a parameter.
05:11:39 <sanjoyd> Jafet: how do I do a cyclic import?
05:11:44 <dd> I see that and I like that, right now though, I'm stuck thinking about the types so my little toy program compiles
05:11:45 <sanjoyd> Any reason why that isn't the default?
05:11:48 <Jafet> Painfully.
05:13:13 <hiptobecubic> sanjoyd, out of curiosity, why are mutually recursive functions in different modules?
05:13:16 <Jafet> You have to go to a cobbler and obtain bootstraps, then tie them around ghc while incanting old Gaelic fairy tales.
05:13:25 <sanjoyd> Jafet: :(
05:13:30 <int-e> sanjoyd: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
05:13:31 <quuuux> sanjoyd: consult the GHC manual
05:13:51 <sanjoyd> I think parameterizing the recursiveness is the best idea then.
05:14:02 <sanjoyd> hiptobecubic: I need it in a toy project.
05:15:32 <oZt> ivanm: I have a an cabal-install-file that lists error-1.1.1 as a dependency, and it fails to install. But I found that there was a newer version of errors, 1.3.* that installed effortlessly and it works now.
05:15:40 <oZt> Thanks anyway!
05:16:00 <ivanm> np
05:16:09 <quuuux> the dreaded package upper bound strikes again
05:16:16 <dd> Is there some way to turn on implicit type conversion so I can work with Int and Doubles without using fromIntegral and truncate all over the place or is that frowned upon?
05:16:38 <alpounet> quuuux, hah, just the other day i was bitten by the lack of upper bounds :(
05:16:40 <sanjoyd> I have a hunch that it will be frowned upon.
05:16:41 <ivanm> no
05:16:57 <quuuux> alpounet: the dreaded lack of package upper bounds strikes again!
05:17:09 <alpounet> heh
05:17:10 <ivanm> dd: but you can always define a shortcut function (e.g. fI = fromIntegral; I tend to use this a fair amount when dealing with different numeric types)
05:17:31 <int-e> sanjoyd: a possible approach for making the recursion a parameter is to have a record containing the functions you want to define, data Foo = Foo { fooR :: a -> b -> c, barR :: d -> e }, then define foo0 :: Foo -> a -> b -> c and bar0 :: Foo -> d -> e, and finally let (foo, bar, r) = (foo0 (fooR r), bar0 (barR r), Foo foo bar). I suppose one can also do it with a type class.
05:18:12 <merijn> dd: The other solution is not use Int but Num a so GHC will use Double everywhere automatically :p
05:18:17 <sanjoyd> int-e: Right now I just want two recursive functions, so I'll just have the first one take a function of the second type as a parameter.
05:18:19 <int-e> sanjoyd: oops. foo0 (fooR r) -> foo0 r (I was thinking too much about 'fix')
05:18:27 <merijn> dd: Is there a specific reason why your functions need to use Int?
05:18:31 <sanjoyd> int-e: this also makes my code cleaner.
05:20:19 <dd> My ints are array indices and my doubles are from doing sqrt, /, etc.  I'm just using a toy program I use for all the new languages I learn.
05:20:42 <hpaste> otters pasted “calling printf from another function” at http://hpaste.org/75755
05:20:51 <Jafet> A record? That sounds very coh-da.
05:21:04 <quuuux> dd: are you sure you're not just being bitten by the monomorphism restriction (unless you're doing a lot of Int <-> Double conversions)?
05:21:07 <hpaste> otters annotated “calling printf from another function” with “calling printf from another function (annotation)” at http://hpaste.org/75755#a75756
05:21:17 <otters> there we go, the error message
05:22:46 <dd> The specifics are creeping in from doing i `rem` 2 * h / 2.  If i is even, this becomes 0 and if it is odd, becomes h/2.  I was doing that instead of an if..then kind of thing
05:25:51 <dd> I got it to work with fromIntergral and truncates in other places, the code is just a whole lot uglier (to me).
05:27:00 <int-e> otters: That can't be done without messing with Text.Printf (there is no way to relate an arbitrary PrintfType instances to IO). I'd just define  log :: LogLevel -> String -> IO ()
05:28:19 <merijn> dd: Why not the define the fromIntegral/truncated values in a separate where/let clause so the main formula stays readable?
05:28:36 <dd> That is what I did eventually
05:28:54 <dd> I have a let .. in .. now
05:29:20 <dd> I just like asking around to see if I'm off-base with things or I'm on the right track
05:30:21 <dd> I am impressed so far, I really like this language
05:31:52 <merijn> dd: It can be annoying sometimes, but in general it's a small price to pay and doesn't happen that often
05:34:20 <dd> Does anyone use Haskell at work in an Enterprise setting?
05:34:31 <Iceland_jack> dd: lol
05:34:48 <sanjoyd> dd: Haskell's motto is "avoid success at all costs".
05:35:03 <sanjoyd> dd: lately, though, some doubt has been cast on how to paranthesize that expression.
05:35:04 <merijn> sanjoyd: You're misreading the bracket according to Simon Marlow
05:35:10 <sanjoyd> merijn: yeah, :P
05:35:53 <merijn> I'm sure there's people using haskell in an enterprise setting. The question is: Are they telling their boss :p
05:36:04 <sanjoyd> dd: you could look up Galois.
05:36:09 <quuuux> dd: some banks/auditors/big scary financial multinationals do. I was looking at a job listing at Standard Chartered the other day, and I know there are at least a few others I can't recall off the top of my head
05:36:20 <sanjoyd> dd: credit suisse uses Haskell, I think.
05:37:34 <dd> some interesting answers
05:39:32 <dd> We've brought in a number of other languages one being erlang
05:39:47 * quuuux wonders why there's no MonadSTM á la MonadIO
05:41:09 <otters> aww
05:43:40 <merijn> Is state is an instance of MonadReader?
05:44:19 <otters> wow, and I can't even write my own PrintfArg instance
05:44:24 <otters> why the hell not
05:44:38 <Axman6> dd: i've used it in industry before, at Tsuru Capital in Tokyo
05:44:39 <merijn> minus one is in that question, I guess
05:45:14 * hackagebot parallel-io 0.3.2.1 - Combinators for executing IO actions in parallel on a thread pool.  http://hackage.haskell.org/package/parallel-io-0.3.2.1 (MaxBolingbroke)
05:45:16 * hackagebot temporary 1.1.2.4 - Portable temporary file and directory support for Windows and Unix, based on code from Cabal  http://hackage.haskell.org/package/temporary-1.1.2.4 (MaxBolingbroke)
05:45:31 <fmap> MonadReader instance for State is kinda defeating the purpose of Monad* typeclasses, no?
05:45:38 <merijn> fmap: I guess :p
05:47:00 * Axman6 -> sleep
05:47:36 <ski> merijn : `instance MonadReader r m => MonadReader r (StateT s m)' ?
05:49:03 <merijn> ski: It was a silly question, nvm :)
05:50:13 <dd> Axman6:  did you help bring it in or was it already there?
05:50:40 <ski> dd : yet another way is `foobar = (2 *)'
05:51:46 <dd> Thanks ski
05:52:07 <dd> I have to say, I really love '$'.  has to be my favorite operator so far
05:52:25 * ski thinks `$' should be used sparingly
05:52:36 <Botje> you should try € sometime. it's 40% more powerful!
05:52:40 <ion> Yeah. Please don’t overuse it.
05:52:41 <Eduard_Munteanu> Who doesn't like $$$? Even PHP etc. love them. :P
05:52:42 <quuuux> now I hate to interrupt, and I'll let you finish, but (>>=) is one of the best operators of all time
05:52:54 <ski> (mostly when immediately followed by a keyword (also counting `\'))
05:55:15 * hackagebot edit-distance 0.2.1.1 - Levenshtein and restricted Damerau-Levenshtein edit distances  http://hackage.haskell.org/package/edit-distance-0.2.1.1 (MaxBolingbroke)
05:55:51 <merijn> edwardk: If I use makeLenses is there a way to (using TemplateHaskell) add the generated lenses to the module exports or do I have to manually enumerate them?
05:56:30 <edwardk> You can manually enumerate them. If you use makeClassy and your type has no arguments, then they will all be in the HasFoo class, then you can export them all at once with HasFoo(..)
05:57:10 <merijn> edwardk: Naah, it's not that big a deal. Just curious :)
05:57:16 <edwardk> that the only tool haskell gives me for clustering them though
05:57:45 <Ghoul> So
05:58:06 <Ghoul> How might I store a 16*16*16 3d representation of a voxel in haskel
05:58:18 <Ghoul> I look at its data type and it doesn't seem as flexible as a C struct
05:58:23 <merijn> heh
05:58:36 <mikeplus64> Ghoul: look at vector, repa and array packages
05:58:46 <Ghoul> oke.
05:59:06 <ion> Haskell data types are more powerful than C structs.
06:00:15 * hackagebot hakyll-contrib-links 0.1.0.0 - A hakyll library that helps maintain a separate links database.  http://hackage.haskell.org/package/hakyll-contrib-links-0.1.0.0 (PiyushKurur)
06:00:42 <Jafet> Yes, but they're so inflexible.
06:02:01 <Ghoul> Ahhh headrape http://www.haskell.org/tutorial/arrays.html
06:02:20 <Ghoul> "A Gentle Introduction to Haskell"
06:03:30 <ski> Ghoul : the "gentle" instroduction is known to not be so gentle for newbies to FP
06:03:57 <merijn> @quote brickbat
06:03:57 <merijn> @quote shapr brick
06:03:57 <merijn> lambdabot hangs :(
06:03:57 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
06:03:57 <lambdabot> shapr says: [Regarding Hudak's so-called 'Gentle' introduction] Yeah, the mental brickbat of doom is a bit closer.
06:04:02 <merijn> or not...
06:04:11 <merijn> @quote Brend gentle
06:04:12 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
06:04:15 <liyang> Ghoul: don't use those arrays. Try vector (or the REPA stuff) instead.
06:05:05 <Ghoul> Oh good lord
06:05:07 <Ghoul> Those quotes
06:05:36 <ion> merijn: The lag might have been on your side: i received your two @quote lines and the “lambdabot hangs” line within the same second, followed by lambdabot’s responses still during the same second.
06:05:38 <Eduard_Munteanu> FWIW, the Gentle Introduction ain't bad as a quick reference.
06:05:41 <Ghoul> If I use a vector will the memory usage still be low-ish
06:06:09 <Ghoul> Like, if I use a structure in C the size of that structure is kind of low when I allocate it.
06:06:15 <Ghoul> Im not sure what the memory usage of haskell is
06:06:18 <Ghoul> in regards to common types
06:06:19 <liyang> Probably lower than Array if you use Unboxed vectors for the innermost slice.
06:06:37 <Eduard_Munteanu> ion, merijn: nope, same lag here: merijn's quote commands, followed by his remark, then lambdabot's response
06:06:50 <Ghoul> Uh I'll take a look
06:06:53 <Ghoul> that went over my head
06:06:55 <liyang> Ghoul: http://hackage.haskell.org/package/vector
06:07:05 <ski> Eduard_Munteanu : perhaps lag between network servers .. ?
06:07:16 <Eduard_Munteanu> Hm, maybe.
06:07:25 <liyang> Ghoul: certainly not over double the amount C would use.
06:07:37 <Eduard_Munteanu> Ghoul: if you use unboxed arrays, they're pretty close to C's arrays in terms of size.
06:08:10 <Eduard_Munteanu> And layout.
06:08:24 <liyang> Ghoul: although REPA is technically better, it's probably harder to understand. If you want to try though: http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial
06:09:15 <bartavelle> anybody ever wrote a function that converts "Sep 10 09:03:02" to some time structure ?
06:09:28 <ClaudiusMaximus> @hoogle rfc
06:09:28 <lambdabot> package rfc3339
06:09:28 <lambdabot> System.Locale rfc822DateFormat :: String
06:09:33 <bartavelle> thx
06:09:40 <ClaudiusMaximus> might have something useful, maybe not
06:09:54 <ski> @hackage rfc3339
06:09:54 <lambdabot> http://hackage.haskell.org/package/rfc3339
06:09:59 <merijn> there's also some datetime packages with parsing functions
06:10:00 <Eduard_Munteanu> (Except unboxed arrays also keep some metadata and accesses are bounds-checked.)
06:10:21 <Ghoul> Sweet
06:11:22 <liyang> Actually REPA might be worth the trouble. It's designed for regular (i.e. fixed size) multi-dimensional arrays, and it'll parallelise your code for you (on GPUs, even) if you ask it nicely enough.
06:11:23 <bartavelle> ClaudiusMaximus, at first glance this seems more versatile, but was sitting just next to yours on hackage http://hackage.haskell.org/package/time-http
06:11:46 <ClaudiusMaximus> bartavelle: glad you found something hopefully useful
06:11:50 <Ghoul> Oh sweet
06:11:55 <liyang> Ghoul: I'm not so familiar with it, versus vector which I use on a daily basis.
06:11:58 <Ghoul> unboxed is exactly what I was looking for
06:12:08 <Ghoul> works prettymuch like the C array
06:12:14 <Ghoul> which is perfect for storing tons of data
06:12:31 <liyang> Ghoul: Yup. :3
06:13:06 <Ghoul> hmm
06:13:17 <Eduard_Munteanu> Ghoul: note vector has its own, different unboxed arrays, so there's no real need to stick to standard arrays.
06:13:26 <liyang> Ghoul: if you need to define class Unbox instances for your own types, there's http://hackage.haskell.org/package/vector-th-unbox
06:13:29 <Eduard_Munteanu> (standard as in stdlib)
06:13:48 <liyang> </plug>
06:14:38 <Ghoul> Hm
06:14:49 <Ghoul> Could I have lazy chunk loading (and eventual unloading)
06:14:54 <Ghoul> is it possible to have a list that unloads automatically?
06:15:04 <ClaudiusMaximus> @hoogle bytestring-mmap
06:15:04 <lambdabot> package bytestring-mmap
06:15:11 <ion> Nooo, don’t use bytestring-mmap
06:15:15 <ClaudiusMaximus> oh, ok
06:15:31 * ClaudiusMaximus never used it
06:15:35 <Ghoul> It'll be a list of unboxed entities
06:15:36 <Eduard_Munteanu> Lazy bytestrings are like that.
06:15:52 <liyang> ion: why not?
06:15:55 <ClaudiusMaximus> lazy best for streaming
06:15:55 <Ghoul> is it possible to hook the load/unload
06:16:08 <ion> Memory access on mmapped memory can block the whole OS thread AFAIU.
06:16:10 <ClaudiusMaximus> finalizers exist for foreign things
06:16:13 <Ghoul> Well I know the load can be hooked
06:16:27 <Ghoul> What's a finalizer
06:16:31 <ClaudiusMaximus> but no guarantees about them being run etc
06:16:41 <liyang> ion: O I C. :-/
06:16:55 <ClaudiusMaximus> some code that runs when something gets out of scope and is garbage collected
06:16:59 <liyang> Ghoul: e.g. free(3)
06:17:07 <merijn> ion: Only for as long as it takes to resolve the pagefault, no?
06:17:31 <merijn> Makes no sense to block otherwise...
06:17:32 <ion> merijn: yeah
06:17:45 <Ghoul> ClaudiusMaximus: I see
06:17:54 <Ghoul> Is it this? http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Foreign-ForeignPtr.html
06:18:02 <liyang> ion: I did a benchmark once of some hashing code, and bytestring-mmap beat lazy bytestrings by a mile…
06:18:54 <Ghoul> keep in mind parralelism is a big deal liyang
06:19:05 <merijn> ion: IMO that means "don't use that unless you are aware of mmap behaviour" rather than "don't use it" :)
06:19:05 <Ghoul> it'll be accessed hundreds of times per second by different threads.
06:19:15 <ion> I was exaggerating. Feel free to use bytestring-mmap but be sure to know how mmapped memory access can interfere with your other threads.
06:19:30 <liyang> ion: Buyer Beware.
06:21:18 <Ghoul> hmm
06:21:31 <Ghoul> Im not sure mmap will actually work
06:21:38 <Ghoul> since it says the spines are pre-cached
06:21:43 <Ghoul> but what im storing is morphic
06:21:57 <Ghoul> Things will need to be added frequently an infinite number of times
06:22:30 <liyang> Use lazy bytestrings or something for now, and get a working program before micro-optimising. :)
06:24:05 <Eduard_Munteanu> Lazy bytestrings basically are lists of strict chunks of data.
06:24:54 <Ghoul> Not used to the haskell way of doing things yet
06:24:55 <Eduard_Munteanu> Ghoul: what are you working on, anyway?
06:24:59 <Ghoul> It looks like most types can be interchanged
06:25:02 <Ghoul> in like 3 seconds
06:25:17 <Ghoul> They all function with the same typeclasses
06:25:17 <Ghoul> :S
06:25:38 <Ghoul> Eduard_Munteanu: well at the moment im learning
06:25:56 <Ghoul> but in about a months time im gonna start making a minecraft server
06:27:56 <ion> ghoul: https://github.com/MostAwesomeDude/baskerville
06:39:47 <rampion> anyone have a minute to help me out with cabal-install issues? Packages I'm installing with cabal-install aren't showing up when I do ghc-pkg list
06:40:38 <rampion> (and I can't find them when using ghc/ghci)
06:40:41 <rampion> % cabal --version
06:40:41 <rampion> cabal-install version 0.10.2
06:40:41 <rampion> using version 1.10.1.0 of the Cabal library
06:40:41 <rampion> % ghc-pkg --version
06:40:41 <rampion> GHC package manager version 7.6.1
06:40:41 <rampion> % ghc --version
06:40:41 <rampion> The Glorious Glasgow Haskell Compilation System, version 7.6.1
06:41:03 <merijn> rampion: Why are you using 7.6?
06:41:18 <rampion> it's the last one I installed.
06:41:28 <rampion> which one are all the cool kids using these days?
06:41:37 <sopvop> cool kids use platform
06:41:38 <merijn> It's not really recommended to use unless you know what you're doing.
06:41:39 <quuuux> that's quite an old version of cabal, especially contrasted with ghc 7.6
06:41:53 <merijn> Haskell Platform is the usual recommended approach
06:42:05 <rampion> oh, right, I was using 7.6 so I could play with Symbol kinds
06:42:18 <sopvop> maybe you installed platform with --prefix?
06:42:21 * nand` is using ghc 7.6.1
06:42:27 <sopvop> nand is not cool.
06:42:32 <merijn> ah, in that case: Are the ghc/cabal binaries the right ones? :p
06:42:44 <rampion> who knows
06:42:50 <rampion> I'll just revert to platform
06:42:54 * merijn is using 7.6 too, mostly because his code doesn't compile with 7.4 :p
06:43:03 <merijn> rampion: Run "which ghc" and "which cabal"?
06:43:04 <dcoutts> rampion: specifically what did you install with cabal, and does ghc-pkg list now show it?
06:43:22 * sopvop is using 7.4.2 because lots of packages don't yet compile with 7.6.1
06:43:58 <nand`> might as well switch to 7.6.1 and patch everything that fails to compile for you
06:44:35 <rampion> I want to avoid that level of yak-shaving right now
06:45:01 <fmap> my code does compile with 7.4 but cannot be executed :(
06:45:53 * merijn just fixed all his dependencies or yelled at their maintainers to fix them :)
06:45:54 <quuuux> fmap: from a referentially transparent perspective, what's the problem?
06:46:09 <sopvop> nand`: And then send parch to maintainer and be ignored and disappointed?
06:46:12 <sopvop> patch
06:46:20 <nand`> diverge from upstream, of course
06:47:04 <sopvop> Sounds dirty
06:47:18 * quuuux fondly recalls dealing with a dozen or so libraries patched to use mtl2
06:48:16 <fmap> 5
06:48:25 <fmap> sorry
06:50:23 * hackagebot yesod 1.1.1.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.1.2 (MichaelSnoyman)
06:51:23 <merijn> Hmm, what's a good verb/word to describe walking a specific tree to determine its structure?
06:52:26 <quicksilver> walking is quite a good one
06:52:35 <kranius> to go through ? or walking
06:52:53 <quicksilver> "visiting" is much beloved by certain congregations
06:53:41 <merijn> quicksilver: In my case I have one initial traversal that just determines the structure and a later one that will actually process the tree. So I want to clearly distinguish the two kinds of tree walks/traversals
06:53:45 <quuuux> cartography, perhaps, but that doesn't verb very well
06:54:11 <quuuux> or perhaps just call one of them 'exploratory'
06:54:54 <ceii> I'd g for "explore" or "survey"
06:55:03 <ceii> s/g/go/
06:55:27 <byorgey> "spinal tap"
06:55:45 <merijn> byorgey: >.>
06:56:15 <quuuux> byorgey: there'd be a risk of overflow if that was used, unless you're careful to go up to 11
06:56:28 <byorgey> good point
06:59:06 <mux> sometimes I think the haskell libraries conspire against me; they always seem to have nearly exactly the function I need, except not quite
06:59:48 <t7> write a patch
06:59:53 <ceii> right, and massaging their arguments the right way takes more space than writing the one you want from scratch
07:00:14 <mux> ceii: that's the feeling yeah
07:00:23 * hackagebot fb 0.12.9 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.12.9 (FelipeLessa)
07:01:00 <sopvop> The worst part is choosing name for a function, especially if one "almost like it" is in scope
07:01:07 <merijn> mux: Word
07:01:33 <merijn> And then I suggest adding said function and I get a complaint about how it "breaks the laws for that abstraction" >.>
07:02:13 <opqdonut> :>
07:02:34 <otters> can I trace what functions are getting called when my parser runs
07:02:43 <otters> because it's in some kind of infinite loop
07:02:52 <mux> merijn: or that it already exists deep in Control.Category, because it's actually just a comonoidal endofunctorial natural transformation of a zygomorphism
07:03:00 * mux grins
07:03:12 <merijn> I could live with that one
07:03:22 <merijn> otters: Debug.Trace?
07:03:42 <otters> I was thinking one that would allow me to not have to add manual trace statements everywhere, but that works too
07:04:19 <absence> i'm trying to understand space leaks. what's wrong with the two first cases here? http://hpaste.org/75757
07:04:19 <quuuux> otters: depending on how deep it is in the code, GHCi's debugger might help
07:05:56 <otters> I might need that
07:07:18 <Saizan> absence: are you compiling with -O2 ?
07:08:22 <Saizan> or -O at least
07:09:42 <sopvop> Style question . Suppose . you have . a long . function composition . When wrapping lines, do you leave (.) at the end of previous line, or start new line with (.) ?
07:10:09 <zzing_> Is there a function like C's tempnam to get a unique filename?
07:11:03 <opqdonut> sopvop: start the new line with .
07:11:11 <opqdonut> same thing for other operators
07:11:19 <quuuux> @hoogle openTempFile
07:11:19 <lambdabot> System.IO openTempFile :: FilePath -> String -> IO (FilePath, Handle)
07:11:19 <lambdabot> System.IO openTempFileWithDefaultPermissions :: FilePath -> String -> IO (FilePath, Handle)
07:11:47 <sopvop> opqdonut: some people prefer to put <*> and <$> at the end
07:12:26 <merijn> sopvop: Split it into section using where clauses
07:12:50 <merijn> sopvop: Presumably the entire composition consists of parts you can logically group
07:13:05 <zzing_> merci
07:13:48 <zzing_> Anyone know if the platform is moving to 7.6 in the next release (whenever that might be)?
07:13:52 <sopvop> zzing_: you may also need http://hackage.haskell.org/packages/archive/directory/1.1.0.2/doc/html/System-Directory.html#v:getTemporaryDirectory
07:14:39 <zzing_> good to have both
07:14:56 <fmap> there is also "temporary" package
07:15:02 <merijn> zzing_: Next release, presumably so somewhere in the next quarter I'd guess?
07:15:15 <fryguybob> zzing_: I'm pretty sure it will not be 7.6.
07:15:37 <absence> Saizan: yes
07:17:12 <edwardk> zzing_: the current plan is 7.4.2
07:17:34 <edwardk> i was very saddened by this
07:17:43 <zzing_> ok, I would so love 7.6, but can live with a point upgrade :P
07:17:52 <quuuux> when is 7.8 pencilled in for release?
07:18:03 <edwardk> just means i have another year before i can finally fix all my categories code
07:18:07 <zzing_> I have been forced to support the haskell platform because of yesod, and so far love it being 'stable'
07:18:16 <edwardk> quuuux: probably next year at this time
07:18:59 <sopvop> why not 7.6.1? Libraries have not stabilized 7.6.1 support?
07:19:21 <ion> why not Zoidberg?
07:19:32 <sopvop> its never zoidberg
07:19:35 <byorgey> sopvop: exactly
07:19:59 <edwardk> sopvop: too much stuff still doesn't build there
07:20:15 <byorgey> for example, gtk2hs
07:20:17 <Saizan> absence: weird, i thought the inliner would see through step at least
07:20:24 * hackagebot distributed-process 0.4.0.1 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.4.0.1 (EdskoDeVries)
07:20:29 * sopvop is afraid of gtk2hs
07:20:33 <quuuux> most of the breakage is due to the Prelude changes, right?
07:20:33 <byorgey> temporary is finally updated.
07:20:46 * luite also saddened if 7.4.2 ends up in hp
07:20:46 <byorgey> quuuux: yes, in my experience
07:20:55 <absence> Saizan: regardless of that, why would the function call allocate so much memory?
07:21:08 <absence> Saizan: cause so much memory to be allocated i mean
07:21:56 <sopvop> I don't use platform anyway.
07:22:12 <Saizan> ?src replicateM_
07:22:12 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
07:22:34 <Saizan> ?src sequence_
07:22:35 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
07:22:43 <edwardk> quuuux: the breaking of catch being included in the Prelude really hurts a lot of packages
07:23:07 <quuuux> edwardk: yes, that was my assumption, I just wasn't sure if there was some other big thing I was missing
07:23:32 <edwardk> quuuux: the change with TypeOperators also breaks some arrow-like packages
07:23:38 <gienah> byorgey: there's a patch for gtk2hs: http://sourceforge.net/mailarchive/forum.php?thread_name=5066E2D4.8000207%40gmail.com&forum_name=gtk2hs-devel
07:23:59 <Saizan> absence: my guess is because we're accumulating thunks in the state and/or tuple containing it
07:24:21 <byorgey> gienah: I know.  It was just an example of a package that hasn't yet had a release updating it to work with 7.6.
07:24:42 <Saizan> absence: let me experiment
07:24:47 * quuuux wonders if 7.6.2 could ship with 'hiding' bogus things being only a warning
07:24:53 <gienah> byorgey: ok, guess I was slow to catch on (only heard of it tonight)
07:25:05 <edwardk> quuuux: its already that way i think
07:25:12 <byorgey> quuuux: hmm, I thought 7.6.1 already did that?  I guess not?
07:25:15 <edwardk> i think that went in in 7.6.1
07:25:25 <quuuux> oh, is it? I might be too used to -Werror
07:25:27 <sopvop> quuuux: I think current attitude is "just use CPP"
07:26:02 <edwardk> My problem with 7.6 was there was a fairly gratiutous change to the -package-db flag that causes it to emit a warning whenever you use it with an older cabal
07:26:08 <edwardk> so -Werror because completely useless
07:26:21 <absence> Saizan: even in the case with the strict state monad? thanks for looking into it
07:26:23 <edwardk> since I can't _upgrade_ cabal, since i can't build it on 7.6.1 ;)
07:26:32 <edwardk> er -Werror became
07:26:50 <quuuux> it's sort of funny how now alternating even GHC releases have these rough edges
07:26:52 <sopvop> whoa, new cabal-install fails on ghc-7.6.1?
07:27:10 <Saizan> absence: i can't reproduce those numbers though..
07:28:12 <absence> Saizan: this is the command-line: ghc --make -O2 -rtsopts -prof -auto-all -caf-all -fforce-recomp test.hs
07:29:07 <Saizan> absence: ah, that explains why step doesn't get inlined
07:29:23 <absence> Saizan: also version is 7.4.1
07:29:25 <Saizan> absence: under profiling a bunch of optimizations can't quite work the same
07:30:00 <Saizan> absence: anyhow, about State.Strict one should know that it's only strict in the tuple holding the state and the result, not the state itself
07:30:58 <absence> Saizan: that makes sense... i still don't understand why it uses memory when it doesn't inline though. the state isn't even used, it's even undefined
07:31:12 <Saizan> absence: you need to do something like do s <- get; s `seq` return () to force it
07:33:08 <absence> Saizan: now it's stricter all right, crashes on undefined :) still, replacing undefined with an integer doesn't improve memory use
07:33:10 <Saizan> absence: btw 600MB is the total allocated? or peak memory use
07:33:20 <absence> Saizan: total
07:33:43 <absence> Saizan: as reported in the prof file
07:33:48 <Saizan> and peak memory?
07:34:02 <Saizan> it's staying under 1MB here
07:34:24 <absence> Saizan: it doesn't say, how can i find out?
07:35:22 <Saizan> absence: run with +RTS -s
07:35:23 <Lemmih> absence: Run with +RTS -s -RTS
07:35:51 <quicksilver> allocation doesn't necessarily matter
07:36:10 <absence> 1,000,037,244 bytes allocated in the heap, but also 1 MB total memory in use (0 MB lost due to fragmentation)
07:36:37 <quicksilver> allocation is just a pointer bump within a cache line - it's effectively "free" if your code bottlenecks elsewhere
07:36:58 <merijn> bah, I have a value coming from a monadic action that I need in a helper function and now I need to pass that value to all branches cluttering the code...
07:37:00 <hpaste> merijn pasted “Monadic actions and helpers” at http://hpaste.org/75758
07:37:01 <quicksilver> although causing minor GCs more often is a performance cost.
07:37:04 <absence> quicksilver: it doesn't make the gc work a lot?
07:37:11 <merijn> Anyway I can make that helper cleaner?
07:38:21 <quuuux> merijn: input >=> loop?
07:38:24 <merijn> (Cleaner being without the needless repetition of val)
07:38:39 <quicksilver> absence: yes it does, quite so. It only matters if it matters :)
07:39:00 <merijn> quuuux: Oh, unlucky simplification. "forkIO $ loop val input" is more like the real code
07:41:35 <merijn> quuuux: Also, that doesn't simplify the helper at all...
07:43:00 <quuuux> merijn: yeah, I don't think that helper's going to get much better. It's already pretty dense
07:45:17 <merijn> quuuux: Well, the val wasn't there before. But I find myself needing to allow an init procedure that produces that val parameter. I'm unhappy with its effect on the code, though :\
07:45:19 <apple_user> hello
07:45:26 * hackagebot not-gloss 0.5.0 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.5.0 (GregHorn)
07:45:28 * hackagebot not-gloss-examples 0.3.0 - examples for not-gloss  http://hackage.haskell.org/package/not-gloss-examples-0.3.0 (GregHorn)
07:45:31 <zzing_> Would it be possible to have an IO monad that has a real 'return' value that will pass the value all the way to the end of the monad actions bypassing everything else? I don't know how exceptions work, but it seems similar functionality to me.
07:46:32 <quuuux> merijn: hmm. ReaderT?
07:46:53 <merijn> quuuux: hmm, might be an idea
07:47:23 <merijn> zzing_: You mean you don't want to evaluate the rest? Or you want to evaluate the rest but ignore the results of it?
07:47:46 <rwbarton> what's "the end of the monad actions"?
07:47:59 <zzing_> merijn, do not want to evaluate the rest. Effectively, it would be like a return statement in the regular imperative languages.
07:48:02 <rwbarton> you can call exitWith, that will bypass a lot
07:48:23 <merijn> zzing_: when?
07:48:29 <zzing_> rwbarton, bypass a little too much :P
07:48:35 <merijn> :t when
07:48:37 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:48:41 <merijn> Or maybe
07:48:55 <merijn> :t \b -> when b . void
07:48:57 <lambdabot> Not in scope: `void'
07:49:48 <rwbarton> there are no "regions" to "return" from defined implicitly by function boundaries like in imperative languages. that would violate substitutability
07:50:26 <rwbarton> you can define explicit "regions" using exceptions or EitherT or ContT
07:50:26 * hackagebot yesod-core 1.1.2.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.2.1 (MichaelSnoyman)
07:51:23 <MostAwesomeDude> @tell Ghoul Hi! I wrote Bravo, and got started on Baskerville before quitting. Let me know if I can answer any questions for you.
07:51:23 <lambdabot> Consider it noted.
07:55:28 * hackagebot yesod-default 1.1.0.1 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-1.1.0.1 (MichaelSnoyman)
07:55:30 * hackagebot yesod-routes 1.1.0.1 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.1.0.1 (MichaelSnoyman)
07:55:32 * hackagebot json2yaml 0.3.2.1 - Utility to convert a file from JSON to YAML format.  http://hackage.haskell.org/package/json2yaml-0.3.2.1 (MichaelSnoyman)
07:55:52 <hpaste> quuuux annotated “Monadic actions and helpers” with “Monadic actions and helpers (annotation)” at http://hpaste.org/75758#a75759
07:56:03 <quuuux> merijn: I don't suggest either of those for actual use :)
07:56:18 <zzing_> rwbarton, do you know any places where this has been done by example?
07:56:40 <rwbarton> not off-hand
07:56:45 <jim_> ls
07:57:05 <jim_> [42,13,22]
08:05:50 <frerich> Hmm, is anybody aware of a Haskell framework (or program) which can generate typesafe combinators for some XML-based language out of a DTD? I.e. if the DTD has '<!ELEMENT book (author, chapter+)>` the program would generate combinators for 'book', 'author' and 'chapter' - and you need one author and one or more chapters to create a 'book'.
08:06:31 <frerich> I'm generating XML documents in Haskell (currently SVG actually) and wonder whether I can get some type safety by considering the DTD. The idea is that if the code compiles, I can't generate invalid documents.
08:06:59 <rwbarton> no but I want one too
08:10:58 <quicksilver> frerich: rather hard to implement
08:11:00 <dimka> Could someone tell is luqui aka Luke Palmer here and if he is what is his nickname?
08:11:23 <quicksilver> even ignoring the boring (but certainly hard) question of parsing DTDs and applying all the rules
08:11:36 <quicksilver> there is the question of the right haskell formulation to implement that.
08:11:44 <frerich> quicksilver: As far as I can tell dtd-text as well as dtd-types can parse DTDs already
08:11:49 <frerich> Didn't try it though.
08:12:05 <quicksilver> taking your example, it's presumably Author -> Chapter -> [Chapter] -> Book
08:12:14 <quicksilver> or is it:
08:12:27 <quicksilver>  Author -> (Chapter,[Chapter]( -> Book
08:12:32 <quicksilver> etc.
08:12:50 <quicksilver> lots of choices. and some of the possible DTD constructs are hard to translate into things the type-checker can check statically.
08:13:19 <killy9999> a stupid question. When I'm in ghci am I inside IO monad?
08:13:30 <trotro> yes
08:13:33 <armlesshobo|work> yes
08:13:35 <quicksilver> frerich: so, with all those warnings in place, have you see HaXml and it's DTDToHaskell
08:13:39 <killy9999> that calms me down
08:13:40 <killy9999> thanks
08:13:42 <quicksilver> killy9999: not really, but it acts as if you were.
08:13:52 <trotro> ghci is just to test&play
08:14:10 <quuuux> killy9999: sort of. Expressions of type 'IO a' will be 'run' (whatever that actually means)
08:14:39 <frerich> quicksilver: I did use HaXml for generating SVG before byorgey pointed out blaze-svg to me, yes. I didn't know about DTDToHaskell though, will have a look. blaze-svg works well, but the fact that all attributes and everything takes strings even though the SVG DTD says only some strings (or numbers) are valid is alittle unsatisfactory(sp?)
08:14:46 <armlesshobo|work> quuuux: that right there. what is this (whatever that actually means)? where does that come from?
08:14:55 <killy9999> I did: x <- readImageFromBMP "/dane/download/test24.bmp"
08:15:07 <killy9999> and was wondering how the hell am I getting sth out of IO monad
08:15:28 * hackagebot http-conduit 1.6.1.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.6.1.1 (MichaelSnoyman)
08:15:56 <aleator> killy9999: You don't. You just put the rest of the stuff also in the IO monad.
08:17:00 <tromp> No-vun ezcapez  ze IO monad!
08:17:02 <killy9999> aleator: hence my question
08:17:23 <pingu> wtf
08:17:25 <trotro> killy9999, you're in the "io monad" so you don't need to escape
08:17:34 <pingu> there are more haskell coders than in #perl
08:17:49 <trotro> perl is an old dying language
08:17:57 <pingu> perl?
08:18:00 <pingu> no way...
08:18:03 <pingu> perl is unix
08:18:07 <tromp> not really, but haskell coders feel more like discussing their language
08:18:10 <rwbarton> I was imagining something more like blaze-html's 'img ! src "foo.png" ! alt "A foo image."' but where the whole mass will type check only if the xml schema is satisfied
08:18:11 <trotro> perl is diying, don't deny it
08:18:13 <killy9999> does anyone here know REPA?
08:18:30 <pingu> trotro: perl is alive and strong..... dont say bs
08:18:45 <trotro> i strongly doubt
08:18:56 <t7> > find ((== 1) . lcm (16 * 10)) [1..(16*10)]
08:18:58 <lambdabot>   Nothing
08:19:42 <t7> lcm != lcd then?
08:20:03 <pingu> trotro: BBC is all perl
08:20:11 <pingu> NYT too
08:20:28 * hackagebot mega-sdist 0.2.0.4 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.2.0.4 (MichaelSnoyman)
08:20:42 <pingu> and , i personally dont know any haskell coder (in person) and most of my friends have even heard of haskell
08:20:44 <trotro> pingu, i don't say perl is dead
08:20:48 <osfameron> BBC isn't all Perl -- it's a bastard mix of Perl, adobe, Java, Ruby, PHP and other stuff
08:20:57 <osfameron> but there's a fair amount of Perl guys working there
08:21:11 <pingu> osfameron: they even have perlcoding guidelines
08:21:29 <frerich> rwbarton: that's exactly what I was envisioning, e.g. right now I have to write 'S.rect ! A.width "120"' but what I'd like to be (forced to) write is 'S.rect ! A.width 120' or maybe even 'S.rect (A.width 120)' or so.
08:21:30 <trotro> perlcoding guidelines... heresy
08:25:34 <mysticc> I want to have something similar to Data.Map k a , but my type a can vary (maybe I can restrict it to a typeclass or something). is it possible ?
08:25:51 * quuuux has discovered it is impossible to use TMVars without typoing 50% of them to STMVars
08:26:33 * osfameron discovers it is impossible to say quuuux without typing 50% of him to quuux 
08:26:42 <bartavelle> mysticc, I don't think you can, you will have to put it in an algebraic type
08:27:07 <quicksilver> you say that like it's a bad thing :)
08:27:25 <quicksilver> sure the answer is: Yes, you can, just design an appropriate algebraic type for the possibilities you need.
08:27:35 <rwbarton> depending on what you actually want to do there may be alternatives
08:27:35 <bartavelle> not at all, I like them
08:28:48 <rwbarton> for example if you are trying to use such a "Map" to implement ST then you can instead use the built-in implementation of ST :)
08:29:43 <jlop> Is there any currency library that works? I.e., should be possible to recognize multiple major currencies and pretty print amounts, do basic arithmetic on them, etc.
08:30:09 <t7> @hoogle divmod
08:30:09 <lambdabot> Prelude divMod :: Integral a => a -> a -> (a, a)
08:30:09 <lambdabot> Data.Fixed divMod' :: (Real a, Integral b) => a -> a -> (b, a)
08:30:29 <jlop> Ironically the only cash package on Hackage is a computer algebra shell.
08:31:35 <nand`> Have there been any efforts towards a Haskell type for C# programs?
08:34:51 <quuuux> jlop: something under http://hackage.haskell.org/packages/archive/pkg-list.html#cat:finance might be usable, but I have no idea how good/useful those are
08:35:25 <pingu> is there some nice tutorial
08:35:28 <pingu> for haskell?
08:35:34 <FridgeTARDIS> Cale, sweetie, why aren't you in blah?
08:35:34 <pingu> basic data structures..
08:35:36 <FridgeTARDIS> You're like my buddy
08:35:42 <pingu> loops
08:35:44 <pingu> etc
08:35:46 <soapyillusions> Is there a channel for Haskell beginners to ask really simple questions?
08:35:55 <Cale> soapyillusions: that's here
08:36:00 <trotro> soapyillusions, you're there
08:36:29 <tdammers> soapyillusions: don't let the incredibly brainy discussions scare you off
08:37:21 <ion> soapyillusions: Don’t let the incredibly brainless discussions scare you off either.
08:37:39 <soapyillusions> cool, just a simple question: I have f :: [a] -> [a]     f (x:xs) = … function code … If within 'function code' I want to reference the whole list, not the dereferenced parts is that possible?
08:38:04 <tdammers> ion: those would belong on -blah though, right?
08:38:05 <Cale> soapyillusions: yeah, you can write  f (xxs@(x:xs)) = ...
08:38:17 <kranius> f all@(x:xs)
08:38:32 <quuuux> soapyillusions: what Cale said. If you do that, 'xxs' is bound to the entire list and you can refer to it by that name
08:38:43 <Cale> > let f xxs@(x:xs) = (xxs,x,xs) in f [1,2,3,4,5]
08:38:44 <lambdabot>   ([1,2,3,4,5],1,[2,3,4,5])
08:39:09 <soapyillusions> Cale, awesome exactly what I was looking for, thanks. And kind of along the same lines if I have xxs can I dereference it later within a let block?
08:39:24 <nand`> pingu: learnyouahaskell.com :)
08:39:37 <soapyillusions> nand` haha that's what I'm reading
08:39:43 <Cale> soapyillusions: You can pattern match it with case or let, yeah
08:39:51 <soapyillusions> ohh ok perfect, thanks a lot
08:39:56 <Cale> soapyillusions: preferably case if you don't know whether it's empty or not
08:40:23 <soapyillusions> ya I'm reading learnyouahaskell and trying to complete http://www.haskell.org/haskellwiki/99_questions at the same time
08:41:52 <t7> @hoogle pow
08:41:53 <lambdabot> package powermate
08:41:53 <lambdabot> package powerpc
08:41:53 <lambdabot> package traypoweroff
08:42:15 <t7> > (2 :: Integer) ** 8
08:42:16 <lambdabot>   No instance for (GHC.Float.Floating GHC.Integer.Type.Integer)
08:42:16 <Cale> t7: Perhaps you're looking for one or more of (^), (^^), (**)
08:42:17 <lambdabot>    arising fr...
08:42:30 <Cale> > (2 :: Integer)^8
08:42:32 <lambdabot>   256
08:42:51 <tac> > (2 :: Float) ^ 8
08:42:53 <lambdabot>   256.0
08:44:21 <Cale> t7: These three operators correspond to different definitions of exponentiation which work at varying levels of generality. (^) allows its base to be any numeric type at all, but requires a nonnegative integral exponent, (^^) needs a fractional-typed base, but allows negative exponents, and (**) requires a floating point base, and allows floating point exponents.
08:44:44 <t7> ah cool
08:44:51 <t7> thanks Cale
08:44:59 <Cale> No problem
08:45:29 * hackagebot blaze-html-truncate 0.1.0.0 - A truncator for blaze-html  http://hackage.haskell.org/package/blaze-html-truncate-0.1.0.0 (MarcelRuegenberg)
08:46:01 <quicksilver> somewhat unfortunate that (**) requires floating point but, well, there you go.
08:46:32 <t7> i need a random item in the list:   filter ((== 1) . gcd phi) [1..phi]
08:46:43 <t7> where phi is too big to calculate them all fast enough
08:47:33 <t7> i guess i could start searching at some random n where (n < phi)
08:47:41 <bartavelle> take random items in [1..phi] until one of them matches ?
08:47:41 <t7> yeah that will work :)
08:47:50 <frerich> You could pick some threshold value, then compute a random value for each element and as soon as an element has a random value which is larger than your threshhold, you take that.
08:48:04 <bartavelle> this will not work if the "holes" are not randomly spaced/sized
08:48:09 <bartavelle> you will have biases
08:48:10 <hiptobecubic> right
08:48:36 <t7> bartavelle: so i should pick random values until they match?
08:48:49 <bartavelle> IDK, I'm no mathematician, but I feel it would be more faire
08:48:49 <hiptobecubic> if you want to be fair about the randomness
08:48:50 <bartavelle> fair
08:48:54 <bartavelle> might be totally wrong though
08:48:59 <hiptobecubic> no it's ok i think
08:49:08 <Cale> quicksilver: Well, it requires "Floating", which is basically "exp and log and related trigonometric stuff"
08:49:12 <hiptobecubic> items which are not coprime with phi will fail the test anyway
08:49:26 <hiptobecubic> the rest have a 1/numcoprime chance of being first
08:51:40 <quicksilver> Cale: yes, I know. It's just mildly unfortunate.
08:52:05 <quicksilver> but there are plenty of compromises however you do it
08:52:16 <rwbarton> what alternative could there be?
08:52:54 <tac> Can someone remind me what the base calculus Haskell is based on? I thought it was a System F_*something* and it had coercion types or something in it.
08:53:23 <merijn> tac: Omega is probably the something you were looking for
08:53:41 <merijn> System F_omega
08:53:43 <fmap> Are there any workarounds to get "cabal-dev ghci" to work with cabal-install-1.16.0?
08:54:44 <Cale> F_c
08:55:05 <merijn> Cale: I'm wrong? :(
08:55:43 <tac> Cale: F_c sounds a little more correct than F_omega
08:55:46 <tac> but thank you both
08:56:07 <merijn> Curse my human memory
08:56:59 <tac> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/fc-new-tyco.pdf <- yup
08:57:10 <jlop> merijn: yes, you are wrong.
08:57:59 <jlop> merijn: I think nobody knows what GHC is based on anymore, though.
08:58:08 <jlop> merijn: perhaps on hope?
08:58:50 <Cale> ah, okay, they just called it FC, that's right
08:59:23 <nand`> F_omega also exists, though
09:00:11 <Cale> Now that I know that there's a connection between Martin-Löf type theory and homotopy types, I can't look at these papers on type theory the same way anymore.
09:00:32 <Cale> Who knows what sorts of geometry these things might describe? :)
09:01:31 <Eduard_Munteanu> Oh, look, a donut type :P
09:02:35 <Eduard_Munteanu> I should probably read some more on MLTT and HTT too.
09:03:13 <shapr> Cale: write blog posts about the connections?
09:03:57 <Cale> shapr: There are lots of people who understand it better than I do who are: http://homotopytypetheory.org/links/
09:04:13 <Eduard_Munteanu> shapr, Cale: better, write a book on HTT for ordinary Haskellers :)
09:04:38 <Cale> I highly recommend the videos 1 and 3 by Awodey and Voevodsky at the top of that page
09:04:41 <shapr> Is this the sort of thing DrSyzygy does?
09:05:02 <Cale> I've been meaning to ask him if he's looked at this
09:05:05 <zzing> Does I want to use Crypto.Hash if I need to do a quick checksum so I can see if a file has changed or not later?
09:05:15 <shapr> DrSyzygy: HALLOO!
09:05:22 <Cale> shapr: dolio does this stuff though :)
09:05:24 <byorgey> shapr: not directly at least
09:05:28 <shapr> oh, ok
09:05:32 <SegFaultAX|work> So I have a question born of ignorance: are monads an imperative construct?
09:05:33 <Polarina> zzing, can't you just use the modified attribute on the file?
09:05:39 <Cale> SegFaultAX|work: no
09:05:41 <byorgey> SegFaultAX|work: no
09:05:48 <rwbarton> SegFaultAX|work, that is a very complicated question
09:05:50 <Polarina> SegFaultAX|work, they are not.
09:06:01 <zzing> Polarina, I need to detect of the file actually changed instead of resaving the same contnet
09:06:05 <SegFaultAX|work> Let me tell you why I ask such an odd question...
09:06:24 <Cale> SegFaultAX|work: But many imperative languages can somehow be explained by monads.
09:06:36 <Cale> SegFaultAX|work: as various special cases
09:06:40 <Eduard_Munteanu> Cale: what does dolio do with that? Work or just fun?
09:06:45 <absence> http://hpaste.org/75760 <- another noob space leak question: how come the second version of main blows up?
09:06:52 <SegFaultAX|work> Cale: Hmm, I see. So what exactly is your definition of imperative then?
09:07:04 <SegFaultAX|work> The line gets fuzzier and fuzzier the longer I stay on the functional side of it.
09:07:24 <rwbarton> absence, is it really a *stack* overflow/
09:07:25 <jlop> How can I construct a value of type  Fixed e (Data.Number.Fixed) from a string?
09:07:25 <Cale> SegFaultAX|work: Well, it's not a clearly defined term to begin with
09:07:53 <jlop> For any e, not 'forall'.
09:08:00 <SegFaultAX|work> Cale: Right. And I've heard the argument that the ; operator in other languages is something like a monad (in that it allows you to chain side effects together)
09:08:01 <Cale> SegFaultAX|work: (while monad is, so it's tempting to just go and say monad = imperative, but if you do that, you get a lot of surprising things)
09:08:01 <absence> rwbarton: what do you mean "really"?
09:08:23 <rwbarton> uh
09:08:25 <SegFaultAX|work> Which makes me wonder if monads are imperative. Or just that imperative code can be described by monads.
09:08:30 <nand`> all functional programming can be arbitrarily lifted into the identity monad. functional = imperative!1
09:08:34 <tdammers> monad do not magically introduce side effects into haskell
09:08:37 <Cale> SegFaultAX|work: Do you understand monads well already?
09:08:41 <rwbarton> well, you said "space leak" here but then "stack overflow" in the paste
09:08:42 <Eduard_Munteanu> SegFaultAX|work: the latter
09:09:09 <MostAwesomeDude> Does "imperative" just mean "one thing, and then the other thing, in that order?"
09:09:10 <SegFaultAX|work> nand`: I'm not trying to be combative. I really want to understand this.
09:09:13 <Cale> tdammers: Well, you can explain effects in a purely functional way, like we do with the State monad.
09:09:22 <nand`> SegFaultAX|work: I was replying to Cale
09:09:27 <absence> rwbarton: oh right. i also said "noob" :D i assumed the stack overflow was caused by space leak
09:09:31 <Cale> nand`: hehe
09:09:35 <tdammers> Cale: exactly
09:09:40 <SegFaultAX|work> Cale: I believe I do.
09:09:49 <rwbarton> absence: so your program really prints "Exception: stack overflow"? okay
09:09:50 <Cale> SegFaultAX|work: So, is the list monad imperative?
09:09:56 <tdammers> that doesn't however make haskell impure in some magical way
09:10:19 <SegFaultAX|work> Cale: I guess I can't answer that without knowing what imperative is defined as in this context.
09:10:30 <Cale> SegFaultAX|work: But you used that word first! :)
09:10:31 <nand`> SegFaultAX|work: monads are, at least partially, about (associative) composition
09:10:48 <SegFaultAX|work> Cale: Then yes, I think the List monad is.
09:10:58 <nand`> eg. composing imperative ‘statements’ together such that { a; b}; c describes the same program as a; {b; c}
09:11:03 <SegFaultAX|work> Cale: Based on my current understanding of imperative.
09:11:05 <absence> rwbarton: almost. it says "Stack space overflow: current size 8388608 bytes."
09:11:06 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
09:11:08 <lambdabot>   [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2...
09:11:11 <rwbarton> okay
09:12:14 <Cale> SegFaultAX|work: on the one hand, we're making choices in a given order, but on the other, the program is running in an order which is only weakly attached to the lexical order in which we've put the statements.
09:12:44 <SegFaultAX|work> Cale: I can't tell which one of those two facts is more important for deciding imperativeness.
09:12:56 <SegFaultAX|work> Cale: Changing the order would certainly change the result, for example.
09:13:10 <Cale> right
09:13:13 <absence> rwbarton: ah right. the strictness i introduced to make the first "main" work now causes trouble for the second main. if i make the state lazy again it works fine, but if i change "head" into "last" it runs out of memory :P'
09:13:19 <Cale> and then you have commutative monads, where it doesn't :)
09:13:49 <nand`> ‘imperative’, if you look at what the word means in other contexts, is about ‘commands’ <- imperative programs are collections of ‘commands’ to be performed (eg. by a suitable interpreter)
09:13:53 <Cale> (which is mostly reader and identity and things built from them, in practical terms)
09:13:55 <SegFaultAX|work> Cale: So the List monad /is/ an example of an imperative monad?
09:13:57 <nand`> in my opinion*
09:14:15 <Cale> SegFaultAX|work: Because we have no formal definition of what imperative means here, we can't say.
09:14:22 <nand`> something is in imperative style, when it consists of commands to be performed by something
09:14:24 <jlop> Why does read "55":: Fixed Eps1 return 54?
09:14:25 <Eduard_Munteanu> > [1,2,3] >>= return . succ
09:14:27 <lambdabot>   [2,3,4]
09:14:28 <Lutin`> nand`: Yes I would agree
09:14:38 <nand`> “set x to 5” “add 2 to x”
09:14:46 <Cale> SegFaultAX|work: there's something vaguely imperative about every monad, but many monads would surprise an imperative programmer
09:14:50 <Cale> in terms of their behaviour
09:14:54 <Lutin`> do this do that
09:14:54 <SegFaultAX|work> Cale: So really, my confusion is at least partially due to the fact that these terms have very little meaning...
09:14:56 <Eduard_Munteanu> It's do notation that makes it look more imperative.
09:15:09 <nand`> at the opposite end is declarative programming, which is about defining what things are, no commands involved
09:15:11 <Cale> Eduard_Munteanu: Well, it's the chaining of >>=
09:15:17 <nand`> (of course, you could define something to be a set of commands)
09:15:27 <SegFaultAX|work> nand`: Declarative style feels much easier to spot.
09:15:27 <Eduard_Munteanu> Or that, yeah.
09:15:42 <SegFaultAX|work> nand`: But then, my mental model of that is related to Datalog.
09:16:00 <SegFaultAX|work> nand`: Or SQL, to a certain degree.
09:16:02 <Lutin`> Well haskell is declarative
09:16:44 <Lutin`> The biggest connection between do notation and imperative programming is just the chaining
09:16:53 <Lutin`> The concept of steps or an order
09:17:05 <SegFaultAX|work> Lutin`: Isn't that a key characteristic of the imperative style?
09:17:18 <nand`> arguably, SQL programs are imperative; they're a set of commands (eg. “SELECT something FROM somewhere”) to be performed by an SQL interpreter
09:17:18 <Lutin`> But it's not really a notion that always exists
09:17:29 <Lutin`> When you consider laziness
09:17:50 <soapyillusions> another silly question: In 'Learn You A Haskell' the author writes ``` Just (+3) <*> Just 3 ``` but if I try that in ghci <*> is not in my scope. Does it need to be imported?
09:18:02 <nand`> soapyillusions: import Control.Applicative
09:18:04 <Lutin`> Control.Applicative
09:18:05 <nand`> LYAH should have mentioned this, I think
09:18:09 <Lutin`> ninja'd! >:[
09:18:55 <SegFaultAX|work> nand`: That's an exceptionally loose definition of imperativeness, then.
09:19:21 <trotro> SQL is functional, not imperative
09:19:21 <nand`> such things are hard to define with rigor
09:19:27 <nand`> I tend to go for ‘simple, general’ definitions
09:19:34 <SegFaultAX|work> trotro: Declarative, even.
09:19:35 <trotro> but it lacks recursivity
09:19:52 <trotro> functional without recur
09:19:57 <trotro> a table is a function in SQL
09:20:04 <SegFaultAX|work> I don't know if I would call SQL functional in the sense that it's basic unit of composition isn't really a function.
09:20:06 <trotro> stangre functions, but functions
09:20:33 <trotro> a function is nothing more than a table with a primary key :D
09:20:41 <trotro> (an infinite table in some cases)
09:21:15 <Cale> SegFaultAX|work: But fundamentally, the important thing about the monad abstraction is just that it's a shape which occurs in a bunch of libraries -- many libraries define some type constructor M and appropriate a -> M a and M a -> (a -> M b) -> M b, and we abstract over that so that we can write code which works with all the libraries.
09:21:22 <trotro> (but nothing forbid infinite table in sql
09:21:26 <quicksilver> INSERT and UPDATE are extremely imperative IMO.
09:21:37 <Cale> Are those libraries fundamentally imperative because of that? Maybe in some vague way.
09:21:39 <trotro> quicksilver, IO too
09:21:45 <tac> quicksilver: can something be only "a little" imperative :)
09:21:45 <quicksilver> the SELECT fragment however, is, very much a functional language.
09:21:57 <Cale> But most of them are classic examples of functional programming
09:22:06 <Cale> so it's a little funny to say that they're imperative as well :)
09:22:16 <SegFaultAX|work> quicksilver: Is consing a value onto a list imperative?
09:22:28 <quicksilver> it's all a matter of perspective.
09:22:42 <trotro> and, imperative = functional, they're just dual pov
09:22:57 <nand`> I fail to see much difference between “x = y” (“SET x TO y”) and something like “INSERT INTO x VALUES y”
09:22:58 <Cale> SegFaultAX|work: when you cons an element onto a list, you get a new list, and the old one is still available
09:22:59 <quicksilver> whilst it's a matter of POV that doesnt' mean imperative = functional
09:23:15 <quicksilver> it might be hard to be precise about what you mean by each
09:23:15 <SegFaultAX|work> Cale: Right, and that's exactly the case with the relational model.
09:23:16 <Cale> SegFaultAX|work: when you execute an INSERT or UPDATE or DELETE, you lose the old database table
09:23:19 <trotro> i see no real diff between the twos, when I was young yes, but today no
09:23:21 <quicksilver> but that doesn't make the terms meaningless
09:23:25 <SegFaultAX|work> Nevermind how it's implemented in modern RDBMS
09:23:43 <Cale> SegFaultAX|work: well, SQL is what it is
09:23:55 <quicksilver> simple imperative languages can often be given a semantics in terms of "Heap -> Heap"
09:23:56 <trotro> an old language inherited from basuc
09:24:01 <trotro> s/basuc/basic/
09:24:01 <quicksilver> but that doesn't make them functional languages
09:24:21 <jlop> Does anyone know the numbers library and the Fixed data type?
09:24:25 <jlop> Why does read "55":: Fixed Eps1 return 54?
09:24:26 <trotro> there is a way to transform imperative into functional and the opposite
09:24:37 <Cale> SegFaultAX|work: I'm all for databases which have better, more faithful semantics, by the way.
09:24:47 <NadiaYvette> Continuation-passing style, monads, and the like.
09:24:57 <jlop> There are no decimals, so it should just return 55, right?
09:25:11 <Cale> jlop: hah, that's interesting
09:25:14 <SegFaultAX|work> Cale: I guess my argument is the age old "relational model vs. SQL" If we're talking straight relational theory, then each table is a value.
09:25:24 <SegFaultAX|work> Cale: There is no update/insert/delete.
09:25:33 * hackagebot hspec 1.3.0.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.3.0.1 (SimonHengel)
09:25:38 <Cale> jlop: Wait, what's Eps1?
09:25:46 <jlop> Cale: means 0 decimals.
09:26:00 <Cale> jlop: I don't see that in Data.Fixed
09:26:09 <jlop> Cale: data.number.fixed
09:26:09 <SegFaultAX|work> nand`: Have you done any logic programming?
09:26:13 <Cale> jlop: oh
09:26:15 <Cale> errr...
09:26:20 <jlop> Cale: in the numbers package.
09:26:35 <nand`> SegFaultAX|work: I'm not sure what logic programming refers to
09:26:58 <SegFaultAX|work> nand`: Have you ever used Prolog, for instance?
09:27:00 <quicksilver> trotro: there is a way to transform all programs into numbers, and vice verse. But prgrams are not just numbers. That's not a very useful logical approach.
09:27:02 <nand`> SegFaultAX|work: no
09:27:13 <zzing> Is there a parser that operates on Text instead of String or ByteString?
09:27:16 <SegFaultAX|work> nand`: Have you ever used Clojure?
09:27:19 <trotro> quicksilver, i should show you how
09:27:23 <nand`> SegFaultAX|work: no
09:27:58 <SegFaultAX|work> nand`: Ah. Well if you're interested, check out Prolog and Datalog. If you'd like to see something a little more modern, Clojure has a logic library based on Datalog called core.logic.
09:28:06 <nand`> I looked at Mercury once
09:28:11 <nand`> I haven't been able to give it much time though
09:28:12 <Cale> nand`: In Prolog, instead of encoding things in terms of functions, you encode them as predicates or relations between a bunch of things
09:28:39 <SegFaultAX|work> Which is really what SQL is. That's why I lump it more into the declarative camp than simply functional.
09:28:56 <trotro> quicksilver, its hard to explain but there is a duality between the both, when i read a functional program I see the imperative and the functional at the same time
09:28:59 <Cale> nand`: For example, rather than a function to concatenate a pair of lists, you might have a relation  concat(Xs,Ys,Zs)  meaning that Zs is the concatenation of Xs and Ys when it's true.
09:29:01 <tac> What does "declarative" even mean?
09:29:13 <SegFaultAX|work> tac: Something like what Cale just said.
09:29:23 <trotro> tac, it means you specify what are the things, not what they do
09:29:24 <quicksilver> trotro: I believe I do know what you mean, and yet, it doesn't mean the distinction is meaningless.
09:29:25 <Cale> nand`: The language will then solve for Zs in much the same way as a function would compute the concatenation.
09:29:34 <trotro> quicksilver, i totally agree
09:29:36 <Cale> nand`: But it can also solve in the other direction
09:29:48 <trotro> quicksilver, and i rather like functional :)
09:29:48 <Cale> nand`: for example, given Xs and Zs, it can find Ys.
09:29:59 <quicksilver> trotro: there are naturally ways to translate between paradigms - they're both implemented on the same kinds of machines. But at the level of "today I want to write a program" the difference means something.
09:30:06 <tsou> SegFaultAX|work: so you can do some actual logic programming in clojure? (!)
09:30:11 <Cale> nand`: Or, given Zs alone, it can find all choices of Xs and Ys which will concatenate to Zs.
09:30:20 <trotro> but when that duality is understood, it's really esay to handle haskell lazyness
09:30:28 <SegFaultAX|work> tsou: Core.logic is really neat. Check it out.
09:30:30 <tac> So declarative is just a functional language with broken evaluation semantics?
09:30:42 <tac> You can always tell how SQL will evaluate
09:30:42 <trotro> because you'll think, what my program will do and everythiong become clear
09:30:50 <tac> there is no constraint solving involved, is there?
09:30:52 <SegFaultAX|work> If you're interested in some logic programming in Lisp, check out this quick intro video: http://vimeo.com/45128721
09:31:29 <Cale> Declarative vs. imperative is a gradient, and it's somewhat subjective
09:31:55 <nand`> Cale: it certainly seems highly interesting
09:32:22 <SegFaultAX|work> Cale: It's also fairly functional in a lot of instances.
09:32:29 <Cale> We say that something is declarative when we mean that it lets you express more what you are trying to compute, or what is true about the things you're trying to compute, rather than *how* exactly to compute the thing.
09:32:54 <absence> http://hpaste.org/75761 <- how can i make case 3 work?
09:32:58 <SegFaultAX|work> nand`: Check out that video I posted. It really got me started down this rabbit hole.
09:33:11 <SegFaultAX|work> nand`: Even if you have no interest in Clojure, it's a cool demonstration.
09:33:12 <tsou> SegFaultAX|work: i don't speak clojure, but from a quick look, it feels quite non-logical
09:33:24 <nand`> I don't know a thing about lisp, except that it's ugly
09:33:31 <nand`> but I'll have a look (later)
09:33:45 <SegFaultAX|work> nand`: That's a matter of opinion. :D
09:33:57 <Cale> absence: I bet that it has something to do with the fact that you're evaluating the last element of that list without evaluating the others.
09:34:07 <Cale> absence: try... well, I'll paste
09:35:09 <SegFaultAX|work> tsou: I don't know what you mean.
09:35:43 <tsou> SegFaultAX|work: I mean that it doesn't have the feeling of logic programming, it has the feeling of lisp trying to do some LP
09:35:54 <hpaste> Cale annotated “ngfnsfgh” with “ngfnsfgh (annotation)” at http://hpaste.org/75761#a75762
09:36:05 <Cale> absence: ^^ that might help
09:36:26 <Cale> (I can't really tell for sure because I obviously can't build that code)
09:36:57 <SegFaultAX|work> tsou: "Lisp trying to do LP" It sounds like you have a strong bias against lisp syntax, but don't really understand it. If you prefer a different syntax, check out Prolog.
09:37:42 <tsou> SegFaultAX|work: no, nothing against Lisp.  I know prolog, but since you recommended it to someone not familiar with logic programming, i was expecting something.. well..
09:37:45 <zzing> I prefer whitespace as my logic programming language of choice.
09:37:49 <tsou> logic-programming in nature
09:37:52 <Lutin`> Clojure is on JVM right?
09:37:57 <SegFaultAX|work> Lutin`: Yup.
09:38:02 <Lutin`> Yeah I'll pass
09:38:11 <Lutin`> I have bad memories of Java
09:38:18 <Cale> absence: any luck?
09:38:31 <tsou> SegFaultAX|work: somewhat like suggesting to someone to check the "functional programming features" of python, when what they want is to get an idea of functional programming
09:38:40 <absence> Cale: yay, it works :) you're my hero
09:38:46 <Cale> absence: great!
09:38:58 <tsou> Lutin`: that's a good reason to not pass :P
09:39:04 <absence> Cale: so without strictList it fills memory with thunks?
09:39:24 <Cale> absence: So that tells me that the problem is that your list was full of expressions where one expression was built in terms of the expression in the previous list element
09:39:25 <Lutin`> tsou: You're saying it can resolve me of those horrors?
09:39:49 <Lutin`> I guess it's worth a try...
09:40:07 <tsou> Lutin`: i'm saying that it just runs on the JVM, but it's a lisp-based language, not a new-java-wannabe
09:40:15 <absence> Cale: right. and in the State.Strict case it probably tried to calculate the entire list at once, going too deep in the stack?
09:40:41 <Cale> absence: Well, State.Strict doesn't force the evaluation of the actual state or the result
09:40:47 <tsou> Lutin`: and it's convenient that you can use such a language and compile it into the beast that's called JVM..
09:40:51 <Cale> absence: That's a more subtle thing...
09:41:05 <absence> Cale: there's a $! for the state in the common function though
09:41:20 <statusfailed> > @djinn a -> a
09:41:21 <Lutin`> tsou: Is it self-compiling?
09:41:22 <lambdabot>   <no location info>: parse error on input `@'
09:41:31 <statusfailed> @djinn a -> a
09:41:32 <lambdabot> f a = a
09:41:35 <statusfailed> coolbeans
09:41:42 <tsou> Lutin`: same is true for Scala, but from what I've seen scala stinks too much of java..
09:42:01 <geekosaur> scala's supposed to.
09:42:12 <Lutin`> Yes I tried some Scala and it scared me away back to the warm embraces of Haskell
09:42:15 <Eduard_Munteanu> State.Lazy only differs in that the state pair is irrefutably matched.
09:42:22 <nand`> from what I've heard, scala is about as much of an improvement over java as F# is over C#
09:42:24 <nand`> aka: none whatsoever
09:42:27 <Boreeas> Scala looks horrible
09:42:41 <n-dolio> No, scala is definitely better than java.
09:42:42 <Cale> absence: http://cale.yi.org/share/Folds.svg -- have a look here at the diagrams for scanl
09:42:44 <tsou> nand`: that's not true
09:42:48 <Lutin`> Yeah
09:42:51 <Boreeas> Nah, I like Java, I don't like Scala
09:42:52 <rking> Being better than Java is a very low standard.
09:43:05 <Cale> absence: (you may prefer the pulled apart version which looks a bit like a harp to the coiled up one)
09:43:06 <Lutin`> I would also argue that F# does have improvements over C#
09:43:17 <rking> Boreeas: Why is that?
09:43:32 <nand`> I guess its improvement is that it requires less syntactic overhead for programming in a sort-of functional style
09:43:32 <Cale> absence: your list looked something roughly like the result of a scanl
09:43:41 <Boreeas> rking: I don't know, that Scala syntax doesn't look really appealing to me
09:43:42 <Cale> absence: where f is a strict function
09:43:54 <Cale> absence: (in the case of the strict State monad)
09:44:03 <tsou> Lutin`: you mean if its compiler is written in clojure?
09:44:11 <n-dolio> The thing about that comparison is that C# is now way better than Java.
09:44:21 <jlop> Cale: do you get it?
09:44:22 <trotro> n-dolio, +1
09:44:22 <Cale> absence: and what happened is that last walked down to the last (:) in the list, and it pulled out the whole expression at once
09:44:33 <n-dolio> So, scala gets you all the improvements that C# has and Java hasn't bothered putting in.
09:44:38 <n-dolio> Plus some extra, maybe.
09:45:04 <Cale> jlop: yes, I do. It looks like a bug
09:45:10 <Cale> jlop: Consider using Data.Fixed
09:45:14 <n-dolio> And Scala is okay if all you want is that level of improvement over Java.
09:45:33 <Cale> absence: are you looking at that diagram?
09:45:54 <hpaste> plhk pasted “works("timeout") in ghci, "select failed" when compiled” at http://hpaste.org/75763
09:45:59 <Cale> absence: So the thing which last pulled out looked like the complete result of a foldl
09:46:11 <Lutin`> tsou: Yes
09:46:19 <tsou> Lutin`: no clue :P
09:46:58 <nand`> I always assumed Java was the same language as C#. Then I looked at Java, and was stunned by how it managed to be even more amazingly primitive
09:47:01 <jlop> Cale: wasn't Data.Number.Fixed written by an ex-professor in Functional Programming?
09:47:03 <Cale> absence: and then when that got evaluated, each f did a pattern match (against pairs, as it happens, in the case of the strict state monad, inside the definition of bind), and all those case expressions got put on a stack waiting for the next one to be done evaluating
09:47:27 <Cale> jlop: Yeah, Lennart is a smart guy, but he's human too :)
09:47:37 <jlop> Cale: and doesn't he now works at a bank? Let's just hope that they got their accounting not based on this library then...
09:47:48 <jlop> er work
09:47:51 <Cale> jlop: and I don't know how much this library has ever been used for real world anything
09:47:55 <tac> C# is actually pretty modern
09:47:59 <n-dolio> nand`: Yeah, C# has evolved, and Java hasn't much.
09:48:21 <jlop> If you want an expressive language, use Common Lisp.
09:48:25 <n-dolio> Maybe they'll get first-class functions in version 8, whenever that's happening.
09:48:29 <trotro> C# implemented "lambda"
09:48:33 <trotro> that's the difference
09:48:37 <jlop> read-syntax and a ton of implementations.
09:49:38 <Boreeas> n-dolio: First-class functions aren't planned afaik, but lambdas are
09:49:39 <tac> trotro: I believe C# (and .NET) don't perform type erasure on compilation, and properties are the sane way to do fields.
09:49:49 <nand`> n-dolio: Java seems to be perpetually stuck where C# 1.0 was
09:49:51 <trotro> tac, they can't do that
09:50:00 <n-dolio> Boreeas: That sentence doesn't make any sense to me.
09:50:00 <trotro> .net s dynamic typed
09:50:04 <nand`> wait, Java doesn't have first class functions?
09:50:09 <trotro> every optimization is forbidden in .net
09:50:21 <jlop> Cale: these kinds of things would almost switch me to use Coq. I mean: if you cannot trust the libraries, you basically have to write everything yourself or check everything meticulously.
09:50:41 <jlop> Cale: at least Perl has MetaCPAN.
09:50:43 <absence> Cale: ooooh. right, i see
09:50:55 <Boreeas> n-dolio: Maybe we have different definitions then. First class functions =>  functions outside of classes, in the "top level" of a file. Lambdas will still needed to be defined inside a class.
09:51:17 <n-dolio> That is not what "first-class functions" means.
09:51:35 <Boreeas> That's what I learned it does, sorr<y
09:51:46 <nand`> first class functions ≅ functions are values
09:51:47 <absence> Cale: so without the strictList it's a bit like foldl, and with strictList it's a bit like foldl' ?
09:51:50 <Lutin`> I've also heard first class functions called that in Java
09:51:50 <rwbarton> BASIC has no classes, therefore BASIC has first-class functions?
09:51:51 <nand`> values like any other
09:51:54 <Lutin`> And it's horrid
09:52:36 <nand`> first class functions are, I think, inseparable from higher-order functions, which means functions that can accept or return functions
09:52:40 <tac> @type (>>= id)
09:52:41 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
09:52:46 <rwbarton> I guess from a java-only viewpoint that definition makes a certain amount of sense
09:54:13 <Lutin`> Yes
09:54:26 <Lutin`> Because you're interpreting it as "functions that are in the first class"
09:54:50 <Lutin`> So the 'root' class?
09:55:18 <absence> Cale: those are very useful diagrams btw :)
09:55:18 <Lutin`> first class functions lets you bind parameters to functions
09:56:46 <tac> Isn't there a function in haskell defined as (>>= id) ?
09:56:59 <nand`> join
09:57:00 <trotro> tac, join
09:57:00 <Eduard_Munteanu> :t join
09:57:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
09:57:03 <tac> ty
09:57:14 <trotro> @hoogle m (m a) -> m a
09:57:15 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
09:57:15 <lambdabot> Test.QuickCheck.Property joinRose :: Rose (Rose a) -> Rose a
09:57:15 <lambdabot> Prelude concat :: [[a]] -> [a]
09:57:21 <trotro> tac, that's how you search :)
09:57:30 <Cale> absence: yeah, with the strictList, as the last function walks down the list, it evaluates each element, so that by the time it actually gets to the last element, not much work needs to be done
09:58:08 <tac> trotro: searching is a partial decision procedure. If I ask, I'll always get back Just an answer or Nothing
09:58:17 <trotro> what ?
09:58:39 <trotro> i just give you an hint for your future questions
09:58:55 <trotro> it's faster to ask to hoogle than ask here
09:59:05 <trotro> but if hoogle isn't your friend #haskell is
09:59:23 <Cale> Don't listen to trotro, you can just ask us if you want :)
09:59:25 <Cale> lol
09:59:43 <trotro> i don't say him not to aks
09:59:55 <Cale> (I'm slightly joking)
09:59:56 <trotro> i say him that it could get an answer fatser wityh hoogle
09:59:59 <Cale> yeah
10:00:10 <trotro> it's for him, not for me i say that
10:00:18 <Cale> It's good to know about things like hoogle -- also that hoogle has a website which is nicer than using it through the bot
10:00:25 <trotro> yes
10:00:32 <trotro> @hoogle hoogle
10:00:32 <lambdabot> Can't think of anything more interesting to search for?
10:00:32 <lambdabot> package hoogle
10:00:45 <Cale> http://www.haskell.org/hoogle/
10:00:46 <Eduard_Munteanu> And tac was joking too ;)
10:00:47 <rwbarton> @@ @hoogle @type (>>= id)
10:00:48 <lambdabot>  Parse error:
10:00:48 <lambdabot>   forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
10:00:48 <lambdabot>          ^
10:00:52 <rwbarton> grr
10:01:18 <Cale> haha
10:01:25 <tac> I just didn't think to look it up by its type
10:01:30 <tgeeky> @@ @hoogle @type ((>>=) id)
10:01:32 <lambdabot>  Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
10:01:33 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
10:01:33 <lambdabot> Prelude foldl1 :: (a -> a -> a) -> [a] -> a
10:01:35 <tgeeky> ^^
10:01:36 <absence> Cale: great, that clears things up a lot. thanks :)
10:01:50 <Cale> absence: no problem
10:01:53 <tac> I'm trying to figure out a problem (I think dolio or someone?) gave me a while back.
10:02:01 <rwbarton> tac wasn't asking about ((>>=) id)
10:02:02 <tac> why does runST $ do x <- newSTRef (return ()); writeSTRef x (do y <- readSTRef x; y); y <- readSTRef x; y loop?
10:02:13 <rwbarton> @type ((>>=) id)
10:02:15 <lambdabot> forall a b. (a -> a -> b) -> a -> b
10:02:25 <rwbarton> I guess it's the kind signature that Hoogle doesn't like
10:02:30 <Cale> right
10:02:51 <rwbarton> if only we didn't have such a recent ghc in lambdabot
10:02:53 <tgeeky> we gotsta update our tools
10:03:01 <tgeeky> hehe
10:03:06 <Cale> rwbarton: lol
10:05:08 <zzing> If I want to construct a series of parts of a data structure (say Document x y z) but I don't want to have to do them together or in any particular order, what would be the best way to do it, and examples are a plus.
10:05:16 <Eduard_Munteanu> tac: that STRef contains another ST action
10:05:41 <Eduard_Munteanu> tac: that action reads the 'x' STRef and runs it.
10:06:00 <rwbarton> it is recursion via mutation
10:06:10 <rwbarton> or self-reference via mutation
10:06:25 <Eduard_Munteanu> But x contains the same action.
10:14:11 <rwbarton> even the latest hoogle on hackage doesn't like the kind signature
10:16:41 <rwbarton> oh it uses its own little parsec parser for types
10:18:38 <tac> Eduard_Munteanu: so if I were to translate the ST program into Coq or Agda or some total language
10:18:53 <tac> The problem would be that the type wouldn't be well-founded?
10:19:07 <tac> in some sense*
10:21:26 <tac> @type writeSTRef x (do y <- readSTRef x; y)
10:21:27 <lambdabot>     Couldn't match expected type `STRef s a'
10:21:27 <lambdabot>            against inferred type `Expr'
10:21:28 <lambdabot>     In the first argument of `writeSTRef', namely `x'
10:21:45 <tac> oh woops
10:22:05 <zzing> If I have a list containing an algebraic data structure with different constructors, is it possible to determine if it has a certain type? Say one of my constructors was Title Text, I don't care what the text is just, want see if it contains a Title.
10:24:02 <rwbarton> you mean "determine whether it contains an element built with a particular data constructor", right? not "type"
10:24:20 <rwbarton> hasTitle = any isTitle where isTitle Title{} = True; isTitle _ = False
10:24:42 <zzing> rwbarton, yes
10:25:00 <Eduard_Munteanu> tac: assuming you had something like ST in Agda :/
10:25:16 <zzing> rwbarton, thank you mine would not have looked nice like that
10:28:26 <tac> Eduard_Munteanu: what about ST keeps it from being realizable in Agda?
10:30:06 <zzing> If I have a list of functions, and I want to apply a bound variable to them, what would be the easiest way? It seems like map, but kind of a reversal
10:30:43 <rwbarton> how would you represent ST in agda?
10:30:49 <fmap> > sequence [succ, pred, const 0] 1
10:30:49 <lambdabot>   [2,0,0]
10:31:51 <Eduard_Munteanu> You can't simply come up with ST, you'd have to write bindings for it. And they'll be opaque at compile-time.
10:32:06 <rwbarton> if you try to write a term algebra (e.g. a constructor for return, (>>=), newSTRef, ...) with an interpreter I think you will find right away that the interpreter is nonterminating for reasons that have very little to do with ST specifically
10:32:21 <rwbarton> hmm
10:34:00 <Eduard_Munteanu> Or well, I guess you can fake ST.
10:34:17 <rwbarton> even if I just have data Foo a where Return :: a -> Foo a; Bind :: Foo a -> (a -> Foo b) -> Foo b and I try to define eval (Return a) = a, eval (Bind x f) = f (eval x)... that second equation is a problem I think
10:34:17 <Saizan> http://code.haskell.org/~Saizan/ST/ST.agda <- my ST in agda+parametricity
10:34:42 <Saizan> STRefs have to stick to a closed universe of types there, but i'm not doing any "runtime" type comparison
10:34:59 <Eduard_Munteanu> rwbarton: that seems size-decreasing so it might work
10:35:20 <rwbarton> but you don't know what horrors lie in f
10:35:22 <Saizan> eval (Bind x f) = eval (f (eval x)) is fine
10:35:27 <Eduard_Munteanu> Yeah.
10:35:30 <rwbarton> sorry, hat
10:35:31 <rwbarton> that
10:35:45 <Cale> You know you're programming in Agda when in order to implement ST, you open a module with stuff for commutative semirings.
10:36:00 <rwbarton> why is it fine?
10:36:01 <Lutin`> hmmm
10:36:24 <tac> Cale: indeed :P
10:36:25 <Saizan> rwbarton: you can think of the f in (Bind x f) as an infinitary product of subtrees
10:36:33 <Lutin`> @pl f a c d = f a b c d
10:36:34 <lambdabot> f = fix (flip flip b)
10:36:50 <Saizan> rwbarton: so f (eval x) is just one subtree, hence structurally smaller
10:36:59 <Lutin`> @pl f a b d = f a b c d
10:36:59 <lambdabot> f = fix (flip flip c . (flip .))
10:37:02 <Lutin`> Oh god
10:37:20 <jlop> Cale: how can Data.Fixed be used to convert a string into a Fixed value?
10:37:24 * tac wishes there was a Hoogle for Agda
10:37:29 <tac> Hagda?
10:37:36 <rwbarton> Aooga
10:37:36 <Eduard_Munteanu> tac: copumpkin :P
10:37:42 <Lutin`> Googda
10:37:56 <Eduard_Munteanu> (he's the self-proclaimed Agda hoogle :P)
10:37:58 <Cale> ghci> read "437289" :: Fixed E0
10:37:58 <Cale> 437289.0
10:38:02 <Lutin`> Agoogda
10:38:12 <jlop> Cale: where is the read instance?
10:38:19 <Cale> In Data.Fixed
10:38:21 <Cale> apparently
10:38:37 <Cale> instance HasResolution a => Read (Fixed a)
10:38:38 <Cale>   -- Defined in `Data.Fixed'
10:39:49 <jlop> Cale: http://hackage.haskell.org/packages/archive/base/4.2.0.0/doc/html/Data-Fixed.html doesn't list it
10:39:52 <rwbarton> I see, if I tried to translate this ST loop example to State then I would get a circular type, but in ST the types of my refs don't appear in the type of the computation
10:40:08 <Lutin`> Yes it does, jlop
10:40:33 <Lutin`> Oh wait
10:40:42 <Lutin`> 4.2.0.0
10:40:45 <Lutin`> is old
10:41:00 <Lutin`> 4.6.0.0 is newest
10:41:42 <Lutin`> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Fixed.html#Fixed
10:44:37 <tac> what is with this line of agda? It uses a dotted pattern in the type signature of \==-relevant
10:44:59 <signalsea> hi, anyone know of an existing function to discard the x most significant bits or digits of a big Integer? I want to find the least significant n digits of an intensive calculation
10:45:00 <Eduard_Munteanu> tac: that's irrelevance, not a dot pattern
10:45:29 <tac> oh
10:45:31 <tac> what does it do?
10:46:12 <Eduard_Munteanu> tac: it declares that parameter as computationally-irrelevant
10:46:33 <tac> So does it not affect the semantics? It just affects how it gets compiled?
10:46:54 <rwbarton> Saizan: so what happens if you try to encode the ST loop example with your ST implementation? some kind of universe inference failure?
10:47:22 <tac> (Now that I think about it, it may have been Saizan who gave me the Haskell example)
10:48:12 <Eduard_Munteanu> tac: it's used to get erasure of proofs among other things, but there it's related to parametricity AFAIU
10:48:40 <tac> Parametricity is another one of those things I've heard, but never heard explained.
10:49:23 <zzing> If I have a list of functions [(a->b)] and a list of things I want them applied to [a], and I want a 1:1 list of the list of functions to my result [b], would <*> be the right thing to do?
10:49:55 <Eduard_Munteanu> tac: see Wadler's paper on it
10:49:56 <typoclass> signalsea: i guess you could do `mod` 512 to get the 9 least significant bits, for example
10:49:59 <Eduard_Munteanu> @google theorems for free
10:50:00 <lambdabot> http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf
10:50:01 <lambdabot> Title: Theorems for free Philip Wadler University of Glasgow* June 1989 Abstract From t ...
10:50:23 <rwbarton> > 6 .&. 5 :: Integer
10:50:24 <lambdabot>   4
10:50:32 <rwbarton> signalsea: see also Data.Bits
10:50:52 <Eduard_Munteanu> zzing: zipWith ($)  ?
10:50:59 <Eduard_Munteanu> :t zipWith ($)
10:51:00 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
10:51:35 <rwbarton> zzing, it would be <*> if you wrapped/unwrapped everything with ZipList
10:51:42 <jfischoff> how tricky is to make shared libraries with ghc for osx?
10:51:51 <jfischoff> are there any gotcha's to watch out for?
10:52:01 <Saizan> rwbarton: with the code above you can't put a ST action inside an STRef, and yeah you'd get a type error about universes if you tried to allow it
10:52:16 <zzing> zip might be it
10:52:22 <Lutin`> @hoogle [a->b]->[a]->[b]
10:52:22 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
10:52:23 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
10:52:23 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
10:52:27 <Lutin`> Bam
10:52:50 <jlop> How can Data.Number.Fixed.convertFixed be translated to Data.Fixed?
10:52:59 <Eduard_Munteanu> Saizan, rwbarton: and with a universe-polymorphic set I guess that means you'd only be able to put a "smaller" ST action into a STRef, no?
10:53:13 <Eduard_Munteanu> *universe-polymorphic ST
10:53:47 <Saizan> Eduard_Munteanu: possibly, we'd have to try
10:56:17 <zzing> What does ($) do to zipWith exactly?
10:56:47 <Eduard_Munteanu> > zipWith ($) [f, g, h] [1,2,3]
10:56:48 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:56:49 <lambdabot>    `SimpleReflect.FromExpr ...
10:57:30 <Eduard_Munteanu> zzing: nothing, just applies functions to parameters
10:57:41 <Eduard_Munteanu> :t ($)
10:57:42 <lambdabot> forall a b. (a -> b) -> a -> b
10:58:16 <Eduard_Munteanu> :t zipWith id
10:58:17 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
10:58:25 <jlop> > (100::Uni)
10:58:27 <lambdabot>   100.0
10:58:28 <Eduard_Munteanu> Same thing :)
10:58:37 <MostAwesomeDude> So has anybody invented a practical use for Tardis yet?
10:58:38 <jlop> Cale: why doesn't that return 100?
10:59:02 <jlop> Cale: the documentation says it's the same as Integer.
10:59:06 <jlop> > 100::Integer
10:59:07 <lambdabot>   100
10:59:10 <zzing> can template haskell be used in modules imported into it? (related: Yesod/Persistent)
11:02:16 <Cale> jlop: It's just a display thing
11:03:27 <jfischoff> has anyone ever built an .so with ghc?
11:03:38 <jfischoff> here in the chat room that is
11:05:58 <jlop> Cale: I'd say it's a bug too.
11:07:56 <Cale> jlop: how so?
11:08:13 <Cale> jlop: It's entirely equivalent
11:08:24 <Cale> jlop: If you write 100.0 :: Uni
11:08:27 <Cale> it should work
11:09:19 <Cale> jlop: Perhaps it should display as 100. or something, so as not to be misleading about the level of precision.
11:09:38 <Cale> but 100. wouldn't parse as Haskell
11:09:48 <identity> @src foldl
11:09:48 <lambdabot> foldl f z []     = z
11:09:48 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:09:49 <Cale> Of course, you could just chop that off altogether
11:09:50 <identity> eh
11:09:53 <identity> @src maximum
11:09:53 <lambdabot> maximum [] = undefined
11:09:53 <lambdabot> maximum xs = foldl1 max xs
11:09:57 <identity> I thought so
11:10:00 <Cale> But I don't think it's a big deal in any case
11:10:05 <identity> @src maximumBy
11:10:05 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:10:21 <identity> isn't maximum implemented in terms of maximumBy which in turn is implemented in terms of foldl?
11:10:24 <danharaj> edwardk: Were you the dude with the library for HOAS in DSLs?
11:11:00 <identity> I remember seeing that anyawy
11:12:13 <cglazner> is there a way to search for instance declarations of a particular typeclass?
11:13:30 <shapr> cglazner: :info Num in ghci
11:13:34 <shapr> @info Num
11:13:35 <lambdabot> Num
11:13:40 <shapr> not what I meant
11:13:53 <Lutin`> Or hoogle/hayoo
11:15:36 <jlop> > (120::Uni)/ (2::Centi)
11:15:38 <lambdabot>   Couldn't match expected type `Data.Fixed.E0'
11:15:38 <lambdabot>         against inferred type ...
11:15:46 <jlop> Cale: how can I do something like that?
11:16:02 <jlop> Cale: Data.Number.Fixed was able to do that via convertFixed
11:16:47 <cglazner> thanks
11:25:05 <clahey> :t fromListWith
11:25:06 <lambdabot> Not in scope: `fromListWith'
11:25:11 <clahey> @hoogle fromListWith
11:25:11 <lambdabot> Data.IntMap fromListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
11:25:11 <lambdabot> Data.Map fromListWith :: Ord k => (a -> a -> a) -> [(k, a)] -> Map k a
11:25:12 <lambdabot> Data.IntMap fromListWithKey :: (Key -> a -> a -> a) -> [(Key, a)] -> IntMap a
11:29:47 <mkaito> hey there o/
11:31:39 <identity> eh, I'm trying to compile a program with profiling on, and it says it can't find Prelude, suggesting I have installed the profiling libs for base
11:31:42 <identity> how do I do this?
11:35:26 <identity> Aaanyone?
11:36:37 <jlop> How do I use dataCast1?
11:38:27 <zzing> If I have a main module being built by cabal in util/ and it wants to import a util/FileHandler.hs should I name this module Util.FileHandler or just FileHandler? I have tried both and can't seem to get it to find the module.
11:40:50 <gka> hi
11:43:50 <zzing> It appears it wanted the directory to be Util instead of util
11:45:33 <coldpizza72i> For my haskell project i was thinking of implementing four purely functional data structures. RB trees, splay heaps, binary random access lists, and I'm not sure of a fourth
11:45:44 <coldpizza72i> does anyone have any suggestions
11:47:54 <zomg> coldpizza72i: linked list!
11:47:55 <zomg> =)
11:49:21 <jlop> Mediate types and unary type constructors. In Data instances of the form T a, dataCast1 should be defined as gcast1.  The default definition is const Nothing, which is appropriate for non-unary type constructors.
11:49:29 <jlop> What does this gibberish mean?
11:49:45 <coldpizza72i> zomg: seriouslly
11:49:58 <zomg> haha =)
11:50:00 <jlop> coldpizza72i: all of those structures already exist.
11:50:04 <jlop> coldpizza72i: what's the point?
11:50:06 <zomg> No idea tbh, I don't even know what all of those things you listed are...
11:50:07 <zomg> lol
11:50:47 <clahey> So, if I have code that loads with :l, but haskell-compiler has linking complaints, what's going on?
11:51:05 <clahey> Specifically, it seems to not be able to find the object files for Maps and Sets.
11:51:10 <coldpizza72i> jlop: does the point matter?
11:52:24 <clahey> :t ..
11:52:26 <lambdabot> parse error on input `..'
11:52:42 <clahey> Is it possible to create a .. operator?
11:52:56 <shapr> :t (..)
11:52:58 <lambdabot> parse error on input `..'
11:53:06 <clahey> :t (<>=)
11:53:07 <lambdabot> Not in scope: `<>='
11:53:12 <clahey> Apparently not.
11:53:13 <int-e> clahey: no, .. it's taken by the list comprehesion syntax
11:53:20 <clahey> Ah.
11:53:26 <int-e> > ([1..4], [1,3..10])
11:53:28 <lambdabot>   ([1,2,3,4],[1,3,5,7,9])
11:54:13 <int-e> :t (--)
11:54:14 <lambdabot> parse error (possibly incorrect indentation)
11:54:16 <int-e> :t (---)
11:54:17 <lambdabot> parse error (possibly incorrect indentation)
11:54:22 <Botje> clahey: have you tried ghc --make?
11:54:43 <int-e> :t (--!)
11:54:44 <lambdabot> parse error (possibly incorrect indentation)
11:54:57 <int-e> that last one should be accepted :)
11:55:49 <clahey> Botje: I hadn't.  That worked.
12:02:06 <edwardk> danharaj: i've done HOAS based DSLs, now I tend towards using 'bound'
12:02:32 <edwardk> but its still nice to get sharing with hoas and the trick from nikola
12:03:18 <danharaj> yes, I am interested in HOAS for implementing sharing because other methods of sharing don't resonate with me.
12:03:56 <jlop> int-e: do you know how to use dataCast1 to convert two different types of Fixed e into each other?
12:04:43 <jlop> More specifically, I'd hope that it's possible to do so in one direction.
12:08:46 <dmwit> > let x --- y = "hi" in 3 --- 4
12:08:48 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:09:01 <dmwit> oh, derp
12:10:18 <dmwit> wait, underp
12:10:23 <dmwit> Why is that not okay?
12:10:34 <dmwit> > let x --> y = "hi" in 3 --> 4
12:10:35 <lambdabot>   "hi"
12:11:20 <dmwit> I mean, I understand that "---" is somehow parsing as a comment delimiter and a minus sign, but why?
12:13:06 <shachaf> dmwit: Because the report special-cases it.
12:13:09 <dmwit> clahey: You should upgrade GHC. --make has been the default for like a year and a half now. =)
12:13:19 <dmwit> oh
12:13:23 <shachaf> dashes → -- {-}
12:13:29 <shachaf> ({} means zom)
12:13:42 <dmwit> Oh, so that you can write ----------------------------------------- to delimit sections or something?
12:13:45 <dmwit> ok
12:14:05 <edwardk> danharaj: have you read the nikola paper?
12:14:29 <edwardk> http://www.eecs.harvard.edu/~mainland/publications/mainland10nikola.pdf
12:14:39 <danharaj> edwardk: alas google is awfully unresponsive for me to- oh thanks
12:15:09 <edwardk> i really like their observable applications
12:17:36 <danharaj> this paper is very relevant to my interests.
12:17:48 <edwardk> =)
12:18:42 <edwardk> i presume you've read http://ittc.ku.edu/~andygill/papers/reifyGraph.pdf
12:19:00 <edwardk> the ability to observe structural sharing and function applications leads to a very nice DSL
12:19:16 <danharaj> yes I looked at that paper, but I didn't quite like it.
12:19:30 <edwardk> its ugly, but effective
12:20:13 <edwardk> i use the two approaches just linked to capture the sharing information, and then manipulate the code using something like https://github.com/ekmett/bound
12:20:44 <danharaj> You should totally write a post about that!
12:20:57 <edwardk> well, the details vary from dsl to dsl
12:21:07 <edwardk> i've yet to extract a common 'core'
12:21:53 <danharaj> A case study would be interesting as well, though I do know you like to make posts about things that can be attacked from on high.
12:22:20 <edwardk> but its handy for SAT/SMT, probabilistic programming, DSLs for remote computation or compiling to LLVM or GPU work, etc.
12:22:59 <danharaj> Perhaps an improvement on the bindings dons made for that one smt solver?
12:23:10 <edwardk> more like a different set of bindings
12:23:20 <edwardk> i started a set a few years back and then got distracted
12:23:39 <edwardk> now that z3's source has been released i may go play in SAT/SMT land again
12:23:48 <edwardk> it'd be nice to have a decent haskell SMT implementation
12:24:02 <clahey> dmwit: Yeah, I'll stick with what I have on this machine.
12:24:03 <danharaj> The raw power of SMT solvers intrigues me.
12:24:03 <edwardk> maybe use trifecta to parse the SMT-LIB input, and then do some decent tactics
12:24:40 <danharaj> I find myself distracted by all the ideas there are to examine through Haskell.
12:24:51 <edwardk> there is this funny space of non-standard semantics for things like SMT, probabilistic programming, remote computation, etc. where the problems are almost all the same
12:25:22 <edwardk> http://www.mit.edu/~ast/papers/nonstandard-interpretations-nips2011.pdf is a great example
12:25:46 <edwardk> it has some great examples of non-standard interpretation
12:27:02 <edwardk> even uses automatic differentiation and my favorite pet monte carlo method
12:27:02 <danharaj> I noticed something today: There's a library on hackage called MonadPrompt that exports an uglier, weaker version of the IO monad you derived way back when.
12:27:28 <edwardk> not surprised, its a fairly common invention
12:28:00 <aristid-ipad> danharaj: afaik the free package is considered slightly better for that pupose
12:29:09 <danharaj> aristid-ipad: I'm not sure I see the need for the dependency. The definition is so lightweight it can be derived by hand in a few minutes.
12:29:15 <edwardk> danharaj: if you look at my machines library its more or less a funny take on the prompt/free monad stuff
12:29:17 <danharaj> It's probably the prettiest monad I've seen.
12:30:15 <edwardk> interestingly if you check the code for Prompt and compare it to the code for my Plan monad its very similar
12:30:27 <edwardk> right down to the trick i use to avoid defaulting problems
12:30:32 <absence> Cale: you still there?
12:30:42 <edwardk> i hadn't noticed anybody else solving that before, good on them
12:33:10 <danharaj> edwardk: What's the trick?
12:33:20 <danharaj> (well, maybe I could guess the trick if I know the problem!)
12:33:26 <edwardk> danharaj: it involves using a rank 3 type for the CPS'd form
12:33:53 <edwardk> https://github.com/ekmett/machines/blob/master/src/Data/Machine/Plan.hs#L51
12:34:10 <edwardk> without the rank 3 type you can make it all work but you need a Functor for k to proceed.
12:34:14 <danharaj> I was just looking at the signature for runPlanT, it is larger than I would expect.
12:34:22 <edwardk> but that means that you need to know what k is.
12:34:24 <danharaj> s/larger/longer
12:34:29 <edwardk> which when you are working with a source you don't
12:34:51 <edwardk> the price of efficiency ;)
12:35:55 <edwardk> e.g. the wait constructor could be cps'd as (k (m r) -> m r -> m r) -> … but that doesn't >>=, etc. well at all
12:36:53 <absence> http://hpaste.org/75761 <- in the bottom annotation, is the problem that the first line of main's do block cause testW to not be garbage collected, and somehow that means none of the other mutations of it are collected either?
12:37:33 <absence> (i.e. giant space leak -> crash)
12:38:29 <sanjoyd> My haskell program stops with the error <<loop>>.
12:38:35 <sanjoyd> Why is that?
12:39:03 <danharaj> you have a definition that looks like `x = x` and it is simple enough that the compiler could figure it out.
12:39:09 <thoughtpolice> that's why GHC tries to evaluate a thunk again in the middle of it's evaluation. like, 'let x = x in x'
12:39:12 <thoughtpolice> *when
12:39:19 <edwardk> sanjoyd: because the answer to what you computed needs to compute the answer to compute the answer. very 'yo dawg'
12:39:30 <danharaj> a yo dawg of fractal dimension 1.
12:39:38 <sanjoyd> Hmm, so it basically it figured out an obvious infinite loop.
12:39:46 <edwardk> sanjoyd: basically ghc detected that you have an infinite loop and saved you from yourself
12:39:49 <edwardk> yep
12:39:51 <sanjoyd> But shouldn't segfault or something like other nice languages?
12:40:10 <sanjoyd> I was expecting at least a stack overflow.
12:40:19 <edwardk> lets walk through how it detected it
12:40:21 <sanjoyd> Anyways, this'll do.
12:40:22 <edwardk> and then it'll become clear
12:40:35 <edwardk> are you familiar with the idea of a memo-thunk?
12:40:43 <sanjoyd> No.
12:40:56 <sanjoyd> I know sort-of know a thunk -- unevaluated code in the STG.
12:41:02 <edwardk> in haskell if you say x = 2 + 3, x starts life as a calculation that will compute the sum of 2 + 3, but hasn't done any work yet
12:41:03 <sanjoyd> Which will self update when evaluated.
12:41:08 <edwardk> when you look at it, itll go compute that answer
12:41:13 <edwardk> and then replace itself with the answer
12:41:19 <edwardk> so far so good?
12:41:23 <sanjoyd> Yeah.
12:41:32 <edwardk> basically all it does is set up the forwarding pointer to point to what it computed
12:41:50 <edwardk> and then the garbage collector gets rid of the now finished computation and other stuff just gets forwarded to the answer in the meantime
12:42:00 <danharaj> GHC computes Haskell stuff awfully similar to how you'd use scratch paper to reduce math equations.
12:42:35 <edwardk> now, when it starts computing 2 + 3, the first thing it does is swap in a 'hey i'm working on this' blackhole for the computation
12:42:48 <tac> danharaj: I always computer my math expressions in applicative order.
12:43:10 <edwardk> and then if it encounters a blackhole, we check to see if we are the thread that created it, if so, we can't block waiting on ourself to complete, so we indicate that it'd spin forever by giving you a <<loop>>
12:43:25 <edwardk> if its blocked waiting for someone else, we just queue up and wait for the other thread to finish its work
12:43:35 <shachaf> Hmm, why does GHC use blackholes with the non-threaded RTS?
12:43:39 <sanjoyd> But then how does let x = 1:x work ?
12:44:00 <sanjoyd> I get an infinite list of ones, which is what I'd expect.
12:44:04 <ion> (:) is lazy.
12:44:06 <edwardk> shachaf: well, we have both 'lazy' and 'strict' blackholing, which you can toggle between
12:44:06 <int-e> shachaf: to collect more data during garbage collection. just imagine  last [1..1000000]
12:44:16 <edwardk> in the strict model, what i said is 'strictly' true
12:44:31 <edwardk> in the lazy model we wait and only do it during the set up for garbage collection
12:44:45 <edwardk> when we detect the cycle then we crap out with the <<loop>>
12:44:47 <int-e> shachaf: it starts as a thunk; without blackholing, that thunk would keep the whole list alive until the last element is found
12:44:48 <shachaf> Ah, makes sense.
12:45:06 <edwardk> that may spin more, and it takes longer to detect the loop, but it removes almost all of the overhead
12:45:21 <edwardk> what int-e said is also important
12:45:40 <edwardk> we need this stuff to avoid space leaks, not just for programmer convenience
12:45:50 <sanjoyd> I have stuff stuff like let recursiveEnv = addBindings env (ident, evaluate recursiveEnv ast) all over the place.
12:45:58 <sanjoyd> I was expecting this to work like let x = 1:x
12:45:59 <danharaj> edwardk: I think I have almost deciphered PlanT
12:46:17 <edwardk> danharaj: Almost congratulations ;)
12:47:28 <danharaj> edwardk: I think I am being confused by (forall z. (z -> mr)...) because the z is in the opposite position I'd expect a universally quantified type to be in.
12:47:56 <danharaj> in CPS code that is.
12:48:32 <edwardk> danharaj: think of it as an existential because of its position
12:48:50 <edwardk> there exists a z, such that you have a k z and a function from z -> m r
12:58:44 <hpaste> int-e annotated “ngfnsfgh” with “version of countFrom that avoids the leak” at http://hpaste.org/75761#a75773
12:58:59 <n00b_> Is this bug known ( 7.4.2 )? loading this: data Person = Person    { firstName :: String , age :: Int } deriving (show)
12:59:04 <n00b_> into ghci
12:59:11 <n00b_> returns [1 of 1] Compiling Main             ( baby.hs, interpreted ) ghc: panic! (the 'impossible' happened)
12:59:15 <shachaf> nogginBasher: Yes.
12:59:21 <shachaf> n00b_, rather.
12:59:47 <int-e> absence: I don't know whether you're using netwire as intended, but one can fix the leak (see annotation)
12:59:51 <shachaf> @google "ghc: panic! (the 'impossible' happened)" "deriving show"
12:59:53 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/6141
12:59:53 <lambdabot> Title: #6141 (ghc: panic! (the 'impossible' happened)) – GHC
13:00:23 <typoclass> n00b_: anyway, thanks for telling people about it
13:00:34 <n00b_> ok, thanks for answering
13:01:26 <shachaf> n00b_: (The "show" has to be uppercase, in case that didn't clarify it.)
13:02:48 <monochrom> interesting, if you write "show" instead of "(show)", no panic
13:04:46 <monochrom> anyway, it's 5961 and is fixed in 7.6.1 if I read correctly
13:05:02 <shachaf> Yep.
13:08:27 <danharaj> edwardk: huzzah. I think I got it. :P The third argument to runPlanT is "Here is the continuation for this machine: it takes a value, but I can't tell you the type. But I have a value that can tell you that type: pattern match on it to find out what you need to give me. If you can't give me the input I need, use this last input to fail."
13:15:08 <Swizec> hey guys, I have a monads question ...
13:15:09 <edwardk> danharaj: correct
13:19:12 <danharaj> edwardk: is this related to those monadic traversals I asked for a while back? You mentioned a rank-3 type there too, although I imagine it was for a different reason than efficiency.
13:19:37 <Cale> Swizec: ask away, btw
13:20:30 <Swizec> I want to simplify/prettify this code: https://github.com/Swizec/random-coding/blob/master/aho-corasick.hs
13:20:46 <Swizec> the problem is that half of the functions depend on two hashtables (that are constructed at runtime)
13:20:56 <Swizec> I want to implicitly pass them into the functions that use them
13:20:58 * hackagebot conduit 0.5.2.5 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.2.5 (MichaelSnoyman)
13:21:00 * hackagebot http-reverse-proxy 0.1.0.0 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.0.0 (MichaelSnoyman)
13:21:02 * hackagebot network-conduit 0.6.0 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.6.0 (MichaelSnoyman)
13:21:08 <qnikst> hello, what is the best way to use eventfd in haskell?
13:21:20 <edwardk> i think the motivation is rather different
13:21:57 <danharaj> I am only a 2-rank programmer, so motivations for 3-rank types are of interest.
13:22:01 <Swizec> so, I guess I want to know how to call functions within the context of the main (that's the IO monad right?) so things I define within main with a "let", will still be defined inside the function
13:22:20 <danharaj> Swizec: welcome to the configurations problem.
13:22:45 <Swizec> danharaj the what now?
13:22:48 <nurpax> I often find myself doing "maybe (return ()) someMonadAction maybeValue"..  so I've defined "maybeWhen :: Monad m => Maybe a -> (a -> m ()) -> m ()" .. is there really no such function in any of the standard base libraries?  it's quite similar to when and unless
13:22:56 <Cale> Swizec: You may want to use the State (Map (Int, Char) Int) monad
13:23:03 <danharaj> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
13:23:15 <Cale> Swizec: Or possibly just Reader
13:23:17 <Swizec> Cale any good resource on how to do that?
13:23:41 <typoclass> Swizec: have you looked into implicit parameters? there's a chapter in the ghc user manual that describes them
13:24:05 * Swizec looks into that
13:24:16 <Cale> Swizec: I actually have to run to the store, but if nobody has explained it adequately by the time I get back, I'll run you through how it works.
13:24:29 <Cale> (or perhaps even if they have)
13:26:04 * hackagebot network-conduit-tls 0.5.0 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-0.5.0 (MichaelSnoyman)
13:26:06 * hackagebot unix-process-conduit 0.1.0 - Run processes on Unix systems, with a conduit interface  http://hackage.haskell.org/package/unix-process-conduit-0.1.0 (MichaelSnoyman)
13:26:08 * hackagebot warp 1.3.3.1 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.3.1 (MichaelSnoyman)
13:26:10 * hackagebot warp-tls 1.3.1.1 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.3.1.1 (MichaelSnoyman)
13:26:12 * hackagebot yesod-default 1.1.0.2 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-1.1.0.2 (MichaelSnoyman)
13:30:37 <identity> How does one install profiling versions of base and everything else if it didn't come with the platform for some reason?
13:31:44 <johnw> cabal install --reinstall base
13:31:49 <johnw> ?
13:32:01 <johnw> I added --enable-library-profiling to my cabal-install bootstrap.sh file
13:32:43 <johnw> oh, never mind
13:32:47 <johnw> apparently my GHC build included profiling libs
13:34:54 <shachaf> identity: It should come with GHC.
13:35:02 <shachaf> You generally don't build base yourself.
13:35:28 <johnw> BASE, how long can you go...
13:35:30 <johnw> s/long/low
13:36:09 <identity> shachaf: I just installed the haskell platform from ubuntu repos
13:42:39 <merijn> Modular architecture question time!
13:43:45 <merijn> Suppose I have a single socket per client carrying a bunch of different message types (that I want to easily extend in the future), is there a way I can wrap and direct them without needing an ADT that encompasses all possible message types?
13:46:43 <typoclass> merijn: so when a new message type comes up, is changing the ADT acceptable or not?
13:47:55 <merijn> typoclass: I would prefer not to. I was thinking just having thread per message class to deal with the requests and then a dispatcher to dispatch incoming messages to the right thread...
13:48:32 <merijn> I guess I could try to tag the serialised data, dispatch on that and just postpone deserialisation until I'm in the right thread...
13:49:43 <typoclass> merijn: hm, then i guess then your code needs to be written such that it doesn't know or need to know about the message type ...
13:51:14 <merijn> Yeah, like I said. Having a tagged bytestring and deserialising in the relevant destination thread is probably the nicest approach...
13:52:48 <typoclass1> yeah
13:59:13 <hpaste> macrover pasted “quickcheck” at http://hpaste.org/75780
14:00:42 <macrover> quickCheck error, see http://hpaste.org/75780
14:04:35 <soapyillusions> If anyone has a second, could they give me a hand with this: https://gist.github.com/3836440     I'm trying to define application constants then use them in an error message
14:04:53 <byorgey> macrover: you are doing nothing wrong with quickcheck, you are doing something wrong with math =)
14:05:22 <byorgey> macrover: (cube . square) x = cube (square x) = cube (x*x) = (x*x) * (x*x) * (x*x)
14:05:45 <macrover> byorgey, duh, thank you.
14:05:51 <shapr> byorgey: nice catch :-)
14:05:56 <byorgey> quickcheck is just doing its job =)
14:05:59 <cjdavies> just starting out, trying to define a function to check whether a list of Bool is all true, what is the correct syntax for the last line here? --> http://paste2.org/p/2300969
14:06:05 <absence> soapyillusions: try this: putStrLn $ "* " ++ config ++ " cannot be found"
14:06:15 <cjdavies> eg if the first element is true & then there are more elements, return False
14:06:40 <byorgey> cjdavies: allTrue (False:xs) = ...
14:06:45 <Cale> soapyillusions: or, wrap the whole parameter to putStrLn in parens
14:06:50 <byorgey> cjdavies: that means, give the name xs to the rest of the elements
14:06:58 <Cale> Swizec: still around?
14:07:10 <byorgey> cjdavies: in fact, since you don't care what they are, you can also write   allTrue (False:_) = ...
14:07:21 <byorgey> _ indicates a value you don't care about
14:07:23 <soapyillusions> absence that worked thanks… do you care to explain what was going wrong?
14:07:27 <Swizec> Cale yep, got it looking much better with implicit arguments
14:07:33 <Cale> Swizec: ah, okay
14:07:39 <Swizec> now I'm figuring out how to define types to make it even better
14:07:40 <Cale> Swizec: so yeah, that's one approach
14:07:49 <cjdavies> byorgey: I swore I tried that but then the next case didn't work, but now it does... eg allTrue (True:xs) = allTrue xs
14:08:08 <byorgey> cjdavies: yep, that looks right
14:08:30 <Cale> Swizec: So, you are clearly already familiar with the idiom of working with stateful things in a purely functional way by using an additional parameter, and producing an extra result tupled with your ordinary one
14:08:34 <byorgey> cjdavies: now see if you can simplify your definition at all
14:08:50 <Swizec> Cale yes, but it got unwieldy in this case
14:08:56 <Cale> Swizec: The State monad captures this idea and tidies it up
14:09:21 <Cale> What we do is to define the type of computations we're going to be putting together:
14:09:33 <Cale> newtype State s a = S (s -> (s,a))
14:09:34 <cjdavies> byorgey: I don't need allTrue (False:[]) because [] is captured by xs
14:09:52 <Cale> So a value of type State s a is a computation which acts on a state of type s, and produces a result of type a
14:09:55 <byorgey> cjdavies: good
14:10:02 <absence> soapyillusions: sure. it's the same as putStrLn ("* " ++ config ++ " cannot be found"). without the $ or parens, haskell thinks you mean (putStrLn "* ") ++ config ++ " cannot be found". this is because function application has higher precedence than ++
14:10:10 <Cale> and we're modelling that as a function from the initial state to a pair of the final state and result
14:10:11 <byorgey> cjdavies: what else?
14:10:27 <soapyillusions> absence ohhh that makes a ton of sense, thanks!
14:10:36 <cjdavies> byorgey: hmmm
14:10:37 <absence> soapyillusions: anytime :)
14:10:53 <cjdavies> byorgey: hang on, trying something...
14:11:00 <Cale> What we're going to do is build up a language of primitive State computations and ways to combine them, and as part of that language, we'll have something of the right type to make State s into a monad.
14:11:10 <byorgey> cjdavies: sure, take your time =)
14:11:19 <Swizec> Cale okay, that sounds really useful actaully
14:11:47 <cjdavies> byorgey: I don't need allTrue (True:[]) because the empty list is covered by xs so it recurses & gets caught by the [] case
14:11:56 <byorgey> cjdavies: right
14:12:05 <Cale> actually, to prevent flooding this channel with all the code, let's go to #haskell-overflow
14:12:28 <cjdavies> byorgey: thanks for mentioning simplification btw, I probably would've just left it if you hadn't
14:12:48 <Alex______> hello
14:12:59 <Alex______> Shalla I learn Ada or Haskell?
14:13:04 <parcs`> yes!
14:13:08 <absence> int-e: hm.. i don't think countFrom is leaking, because it works with the regular countFrom if i remove the stable pointer
14:13:17 <byorgey> cjdavies: sure.  It's a good habit to get into.  I always do it.  I write a function and focus on getting it to work.  Then once it works I think about whether it can be simplified.
14:13:32 <byorgey> usually it can.
14:14:59 <cjdavies> byorgey: I've just gone back & removed a line from the previous function I implemented too :)
14:15:03 * cjdavies is learning
14:15:27 <byorgey> excellent =)
14:16:10 <merijn> cjdavies: Also, check out hlint
14:16:25 <merijn> cjdavies: It catches many style errors/simplifications that you can learn from as newcomer
14:16:39 <cjdavies> merijn: thanks, will take a look
14:17:22 <merijn> byorgey: You forgot the party where you figure out your entire function can be replaced by composing two existing library functions and a helper :p
14:17:28 <merijn> s/party/part
14:17:31 <cjdavies> \o/
14:17:43 <byorgey> hehe
14:18:17 <byorgey> well, in cjdavies case, allTrue is already a single existing library function =)
14:18:22 <byorgey> but I figured the point was to learn
14:18:38 <byorgey> merijn: it often really is a party though
14:18:51 <cjdavies> byorgey: yup, working through an introductory tutorial for university
14:19:34 <merijn> Skip the tutorial, power through LYAH and blow everyone's brain with your command of advanced haskell trickery ;)
14:19:54 <cjdavies> merijn: I have actually been reading a bit of LYAH
14:20:14 <cjdavies> it is less intimidating than the textbook I tried reading
14:20:21 <cjdavies> the confusing selection of pictures helps
14:20:23 <coldpizza72i> Is there a function to get a substring of a string… or must i write it myself?
14:20:55 <shachaf> Option 3: You must not write it yourself.
14:21:05 <coldpizza72i> huh
14:22:10 <coldpizza72i> shachaf: ?
14:22:56 <shachaf> You might consider using Data.Text instead of String.
14:23:15 <shachaf> Anyway, there's take and drop.
14:41:06 <Lutin`> So I spent a few hours with clojure
14:41:16 <Lutin`> I just miss Haskell too much
14:42:17 <frio> clojure's frustrating
14:42:23 <frio> some parts of it are very nice
14:42:46 <frio> and it lets me stub out ideas that i can later translate to haskell easily (sometimes it's nice not having a type checker getting in my face!)
14:43:14 <frio> but the java warts are frustrating (for instance, needing to both use/require *and* import another class when you defrecord, try/catch, etc.)
14:43:52 <tac-tics> frio: That type checker rescued a bunch of orphans from a burning building.
14:44:10 <tac-tics> (honestly, though, holes in Haskell will be the most amazing feature ever)
14:44:22 <clahey> What are holes?
14:44:30 <clahey> Other than the opposite of electrons?
14:45:33 <tac-tics> clahey: What are holes??? Well I'll tell you
14:45:39 <frio> tac-tics: don't get me wrong, i love haskell's static typing.  not having it is like living one of those "oh no i am naked in front of everyone" type nightmares
14:45:54 <tac-tics> A new feature in the latest Haskell release, I believe, that's been available for a while in many dependently typed languages (Agda, Epigram)
14:46:04 <tac-tics> that allow you to leave part of your program "in progress"
14:46:14 <frio> but when im just trying to hash an idea out, it can be frustrating having to battle my code into correctness, when all i want is to hack around :)
14:46:20 <tac-tics> and you can fill it in as you go, and you're able to inspect the typing context as you do it
14:46:55 <frio> dynamic typing for prototypes, static typing with some actual design work for the Real Thing (tm)
14:47:12 <clahey> Okay.
14:47:14 <clahey> Question.
14:47:24 <clahey> Is there some way to automate switching between Strings and Texts?
14:47:33 <clahey> (Holes sound cool, btw)
14:47:36 <frio> OverloadedStrings
14:47:38 <merijn> clahey: For the literals you type?
14:48:15 <merijn> tac-tics: Wait holes are already in 7.6?
14:48:30 <shachaf> merijn: No, they just got into HEAD.
14:48:37 <merijn> Awww :(
14:48:39 <int-e> absence: well the same code does not leak with the modified countFrom
14:48:41 <merijn> I got all excited...
14:49:01 <frio> clahey: {#- LANGUAGE OverloadedStrings -#} (may have the -s and the #s the wrong way round) at the top of your source file
14:49:10 <clahey> Yeah, I have that.
14:49:16 <frio> then just make sure you import wherever fromString is defined in Data.Text
14:49:32 <clahey> Right.
14:49:39 <clahey> That let's me mix literals with Text.
14:49:49 <clahey> Oh, is there a replacement for ++?
14:49:52 <clahey> <> or something?
14:49:52 <frio> should do :)
14:50:12 <clahey> Next time I'm working on that project I'll switch to all Texts and switch the ++ to <>.
14:50:17 <clahey> That was why I thought I needed strings.
14:50:21 <frio> clahey: see http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text.html
14:50:44 <frio> it looks like you're after append?
14:51:17 <int-e> absence: and I can explain the behaviour, too - the netwire countFrom is the equivalent to mine without the 'NOINLINE' pragma. What happens then is that the (Right n, countFrom' (succ n)) pair gets floated out of the constant function - and then by holding on to the initial countFrom closure (using the stable pointer), this behaves like generating a list (the pairs act as cons cells) at run time, and all of those pairs are...
14:51:23 <int-e> ...kept alive.
14:51:39 <tgeeky> still alive ...
14:52:05 <clahey> :t (<>)
14:52:07 <lambdabot> Doc -> Doc -> Doc
14:52:15 <clahey> Oh, that's for Docs.  What's a Doc?
14:52:35 <shachaf> That's not the real <>
14:52:43 <shachaf> The real <> :: Monoid m => m -> m -> m
14:52:44 <frio> http://www.haskell.org/hoogle/ :)
14:52:57 <int-e> :t (Data.Monoid.<>)
14:52:58 <lambdabot> Not in scope: `Data.Monoid.<>'
14:53:59 <int-e> Cale: hmm are you hiding that (<>) for lambdabot or is the ghc version too old?
14:54:15 <Cale> lambdabot is on ghc 6.12.3
14:54:20 <clahey> And Text is a Monoid, so it'll work just fine, it looks like.
14:54:29 <int-e> Cale: I see, thanks
14:54:38 <Cale> I really ought to update it at some point
14:54:49 <Cale> Maybe talk to lispy about doing that
14:54:56 <Cale> it's his machine
14:55:03 <zeiris> Is there some easy way to build easy-to-distribute binary packages from cabal, if you don't want the full GHC + libs toolchain running on a server machine? All the code dependencies get nicely statically linked into one binary, but I can't figure out a sane way to wrangle all the share dependencies into /usr/local instead of ~/.cabal
14:55:17 <clahey> newtype Endo a: The monoid of endomorphisms under composition.   Oh my god, the math geekery, I love it.
14:55:32 <dcoutts_> zeiris: cabal copy --destdir=image/
14:56:02 <dcoutts_> zeiris: ie you configure, build as normal, but instead of installing locally, you make an install image
14:56:38 <zeiris> dcoutts_: I've got to do that recursively for all the dependencies that have external files, though. And I'm not sure how deep that rabbit hole goes.
14:56:50 <dcoutts_> zeiris: you'll also want to change the --prefix when you configure, so it matches the layout you want for the target machine
14:57:18 <zeiris> Yeah, that works nicely for a single package. I'm wondering if there's any automagic scripts for recursively doing it to all the dependencies first.
14:57:28 <dcoutts_> zeiris: it's true, libs with data files are a bit of a pain that way. Fortunately, most libs don't have data files, usually only exes.
14:58:01 <dcoutts_> zeiris: since we do static linking by default, so usually one does not need to worry about libs
14:58:18 <zeiris> Hm. I guess I'll see if I can manually discover all the dependencies with data files, there shouldn't be that many.
14:59:55 <frio> oooh dcoutts_
14:59:58 <frio> I didn't know about that
15:00:11 <frio> -> is off to eagerly update some packages
15:00:27 <dcoutts_> it's the same as make install DESTDIR=blah/
15:00:49 <dcoutts_> it's a feature that's been there since the very beginning
15:01:08 <dcoutts_> when it was all modelled on  ./configure; make; make install
15:01:32 <frio> I had no idea (im just lifting stuff out of dist/build/ atm)
15:03:57 <apple_user> how do i turn a list ["Foo","Foo","Foo"] into a tuple ("Foo", 3) ?
15:04:35 <acowley> Where does the 3 come from?
15:04:38 <shachaf> (\_ -> ("Foo", 3))
15:04:45 <apple_user> the number of "Foo"s in the list
15:04:51 <GnomeStoleMyBike> zipWith ?
15:04:53 <shachaf> What does ["Foo","Bar","Foo","hi"] turn into?
15:04:56 <acowley> And how do you code that up in haskell?
15:04:57 <shachaf> What about []?
15:05:02 <apple_user> I don't know :(
15:05:11 <acowley> What functions on list do you know?
15:05:14 <apple_user> :t zipWith
15:05:16 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
15:05:18 <shachaf> Well, figure that out first. :-)
15:05:20 <apple_user> just map, foldl, and zip
15:05:24 <GnomeStoleMyBike> :t zip
15:05:26 <apple_user> and group
15:05:27 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
15:05:32 <int-e> length?
15:05:38 <apple_user> length too
15:05:43 <int-e> head? tail? (!!)? lookup?
15:05:53 <apple_user> those too ^_^
15:06:02 <acowley> so how do you get 3 from ["Foo","Foo","Foo"]?
15:06:15 <GnomeStoleMyBike> > let lol l = (head l, length l)
15:06:17 <lambdabot>   not an expression: `let lol l = (head l, length l)'
15:06:23 <apple_user> lol
15:06:37 <monochrom> length (head ["Foo", "Foo", "Foo"]) is 3
15:06:50 <int-e> monochrom: good one
15:06:58 <int-e> but oh so nasty
15:07:09 <acowley> Crap, I have a rather complicated bit of low level code that segfaults when compiled with the LLVM backend but not the NCG.
15:07:18 <int-e> > transpose ["Foo", "Foo", "Foo"]
15:07:19 <lambdabot>   ["FFF","ooo","ooo"]
15:07:22 <shachaf> acowley: Oh, that sounds exciting.
15:07:25 <shachaf> Is it @pastable?
15:08:13 <acowley> shachaf: no… but I accidentally the interesting part: it only segfaults some times with the llvm backend, but never(?) with the nag.
15:08:38 <shachaf> Ah, so there's some non-determinism involved.
15:08:45 <acowley> shachaf: It does a bunch of asynchronous DMAs from OpenGL
15:08:53 <acowley> it shouldn't be nondeterministic
15:08:58 <lispy> hmm
15:09:01 <acowley> yet the evidence suggests otherwise
15:09:21 <lispy> ghc-core to the rescue?
15:09:27 <acowley> It doesn't want to segfault in gdb
15:09:33 <int-e> sounds like fun.
15:09:43 <geekosaur> is it me or is opengl often at the root of these kinds of things?
15:10:07 <Eduard_Munteanu> Well, as long as it can spread its mess all over your memory...
15:10:31 <Eduard_Munteanu> Some drivers have been known not to check the command stream properly.
15:11:03 * hackagebot FixedPoint-simple 0.3.1 - Fixed point, large word, and large int numerical representations (types and common class instances)  http://hackage.haskell.org/package/FixedPoint-simple-0.3.1 (ThomasDuBuisson)
15:12:14 <acowley> Well this is (not) promising
15:12:16 <acowley> (gdb) bt
15:12:16 <acowley> #0  0x00007fff96b9765d in longcopy ()
15:12:17 <acowley> #1  0x00007fff96b82f8f in memmove$VARIANT$sse3x ()
15:12:18 <acowley> #2  0x000000010000f978 in sUbZ_info ()
15:12:53 <lispy> acowley: does frame 0 have any more information, about say the arguments?
15:13:26 <lispy> acowley: does your program use threads?
15:13:42 <lispy> acowley: if so, does it amke OpenGL calls from threads other than the main thread
15:13:53 <acowley> lispy: No, it's single-threaded
15:15:09 <lispy> 0x00007fff96b9765d <-- looks like the address for a shared library?
15:15:55 <shachaf> lispy: I would assume that memmove is in a shared library.
15:15:59 <Eduard_Munteanu> longcopy may be a red herring, it could've simply received a bad argument (e.g. destination pointer)
15:16:10 <shachaf> Yes, I doubt it's memmove's fault.
15:16:14 <acowley> yeah
15:16:27 <acowley> but then it's probably in vector
15:16:27 <lispy> yeah, that's what I was trying to point out by saying it loosk like a shared object address
15:16:46 <lispy> (but then I got a phone call and couldn't complete the thought :)
15:17:06 <lispy> does sUbZ zdecode into anything interesting?
15:17:10 <lispy> I'm guessing no
15:17:26 <shachaf> It's just a fresh name.
15:17:44 <shachaf> Would be nice if GHC generated meaningful names.
15:18:22 <maukd> now this is a story all about how
15:18:42 * cmccann patches GHC so that fresh names are generated by selecting names of #haskell users
15:18:51 * int-e wonders whether one can reasonably inspect the ghc stack from gdb
15:19:40 <Eduard_Munteanu> I wonder if GHC could reasonably provide a mode for emitting easy-to-debug code.
15:20:17 <int-e> (and heap objects, hmm. something that interprets the bitmap and tells you which parts are pointers and which are data.)
15:20:27 <acowley> lispy: You were right about the shared lib, it's libsystem_c.dylib
15:21:06 <int-e> Eduard_Munteanu: the CPS transform seems an effective way to prevent that :)
15:21:39 <shachaf> cmccann: Twist: They'll all be named after cmccann
15:21:44 <cmccann> D:
15:21:52 <acowley> lldb is more helpful here (perhaps unsurprisingly), and it seems like I'm getting a bad destination address called from Main
15:22:01 <acowley> which isn't super helpful
15:22:06 <Eduard_Munteanu> lldb?
15:22:11 <acowley> llvm's debugger
15:22:19 <Eduard_Munteanu> Ah, sorry, I just googled.
15:22:27 <acowley> it's like gdb, but spelled slightly differently!
15:23:33 <apple_user> :t forM_
15:23:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
15:23:39 <int-e> hmm, lldb has no debian package
15:23:41 * Eduard_Munteanu wonders if LLDB has a JIT interface like gdb has, *looks*
15:24:06 <shachaf> gdb has a JIT interface?
15:24:32 <Eduard_Munteanu> shachaf: yeah, it lets JIT compilers insert debugging information at runtime
15:24:45 <Tordek> what advantage is there in writing CPS?
15:25:30 <shachaf> You can PCs to different places.
15:25:30 <absence> int-e: i have the same problem with other wires too though, not just countFrom. is it for the same reason?
15:25:34 <int-e> Tordek: as I understand it, it gets rid of one control stack, pushing it to the heap.
15:26:29 <int-e> absence: I imagine all pure wires (that are implemented as  mkPure (\_ -> ...)) suffer from the same problem.
15:26:55 <int-e> absence: and allow the same sort fix.
15:28:07 <apple_user> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
15:28:53 <int-e> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
15:28:56 <Tordek> shachaf: hmm, how do you mean?
15:29:41 <absence> int-e: mkPureFix too?
15:31:04 <monochrom> virthualenv has become hsenv, is that right? but I can't find hsenv on hackage
15:31:17 <absence> int-e: oh right, it calls mkPure
15:32:02 <absence> int-e: i see something similar in this code. is it for the same reason? http://hpaste.org/75782
15:33:20 <absence> int-e: you'd think that after forcing the last value of the returned list, forcing the last state would be free rather than costing 300 MB :/
15:39:05 <shachaf> Is there any proposal for an extension/pragma to formalize "minimal complete definition"?
15:39:19 <shachaf> (For class instances.)
15:49:03 <acowley> Wooo, bug found! lldb more consistently let my program crash, and I was able to track down a pointer manipulation bug (maybe the world's first?)
15:49:13 <acowley> Now my asynchronous DMAs from the GPU are doubling throughput
15:50:31 <shachaf> The world's first pointer manipulation bug?
15:51:27 <typoclass1> shachaf: statistically we won't see another one in decades. good job he found it
15:52:14 <shachaf> typoclass1: Eh, you know how quickly things change.
15:52:23 <shachaf> We might see one as soon as a few years from now.
15:52:58 <tdammers> aren't 50% or more of the world's bugs pointer manipulation related?
15:53:29 <typoclass1> tdammers: sure :) we're kidding around. i believe acowley's parenthesis was pure sarcasm
15:53:45 <acowley> Yeah, when in doubt, I was being sarcastic
15:53:50 <acowley> sorry for the confusion
15:54:02 <Tordek> were you being sarcasting in your remark aboutbeing sarcastic?
15:54:05 <shachaf> Cockroaches are pointer-manipulation related.
15:54:11 <acowley> it was my way of smacking myself upside the head for always dropping down into bits and bytes
15:54:17 <shachaf> So are mosquitoes.
15:54:25 <shachaf> Bats aren't, though.
15:54:27 <int-e> absence: it's different. using replicateM is asking for trouble, very hard to control strictness when using it. I've annotated your code with a version that uses Control.Monad.State.Strict and replicateM_ instead.
15:54:31 <acowley> Tordek: Oh that's a great question
15:54:42 <monochrom> it's undecidable
15:54:47 <int-e> absence: which runs fine, both in terms of stack and in terms of heap space
15:54:59 <monochrom> when in doubt, it's undecidable :)
15:54:59 <acowley> bats are debuggers
15:56:17 <shachaf> Decidability is undecidable. :-(
15:56:23 <quchen> Hello everyone. First time in the Haskell IRC, didn't want to bother stackexchange with my chatty question. So here we go: I'm trying to reinstall my packages for dynamic linking. Parsec is my test package.
15:56:50 <acowley> shachaf: We haven't actually decided that yet
15:57:07 <Eduard_Munteanu> quchen: hi and welcome
15:57:24 <quchen> Therefore I'm running 'cabal install --reinstall --enable-shared parsec'. Building takes 25/25 steps and works, the next run would be what compiles the shared libs I suppose. However, that step doesn't work:
15:57:39 <cmccann> Exercise 1: Prove the undecidability of Batman.
15:57:45 <quchen> Could not find module `Control.Monad.Error.Class' Perhaps you haven't installed the "dyn" libraries for package `mtl-2.1.1'?
15:58:01 <monochrom> well, then, you need to rebuild mtl first
15:58:05 <dcoutts_> quchen: dyn libs have to depend on other dyn libs
15:58:33 <quchen> Right, exactly what I thought. This led me to running
15:58:36 <monochrom> only things that do not need rebuild: what comes with GHC, they already have dynamic linking enabled
15:58:50 <quchen> cabal install --reinstall --enable-shared --dry-run world
15:59:01 <monochrom> world may be too large
15:59:23 <quchen> I'm not even sure what 'world' is, except stuff that's in my .cabal/world.
15:59:30 <acowley> I have still never had any luck reinstalling world with profiling enabled on a new cabal install. That is supposed to work these days, isn't it? I always end up reinstalling each package manually.
15:59:34 <int-e> absence: (in your version, a large thunk is built for w, incrementally. without the line printing w, that gets garbage collected along the way; the w `seq` print "bye" expression keeps that whole thunk alive - hence the blowup in memory use. This is really quite subtle. It may even work when the optimizer gets lucky, because of a very limited short-circuit evaluation for record selectors in the garbage collector, but we...
15:59:35 <quchen> I didn't put it there, and my cabal knowledge is fairly nonexistent
15:59:40 <int-e> ...didn't get that lucky.
15:59:42 <monochrom> it is not world, it is history, it contains junk that you have left behind since
15:59:53 <dcoutts_> quchen: that's exactly what it is. It's all the things you ever explicitly asked to install.
16:00:17 <quchen> Sooo in order to install Parsec, I have to run 'cabal install --enable-
16:00:29 <quchen> -shared ... mtl first?
16:00:44 <quchen> As in 'tell my packager by hand'? Hmm.
16:00:57 <Eduard_Munteanu> quchen: --reinstall too
16:01:10 <monochrom> or you first shrink world to what you actually want
16:01:30 <Eduard_Munteanu> Even so, maybe world doesn't install them in the right order?
16:01:32 <quchen> 'cabal install --reinstall --enable-shared mtl' results in ' Could not find module `Control.Monad.Trans.Cont'
16:01:34 <quchen>     Perhaps you haven't installed the "dyn" libraries for package `transformers-0.3.0.0'?
16:01:45 <monochrom> oh, cabal will sort them into the right order
16:01:51 <quchen> So this really is a large chunk of installing packages manually?
16:01:51 <Eduard_Munteanu> quchen: then go with transformers first, then mtl then...
16:02:29 <quchen> Well that would be the jackhammer method, but since I'm not sure for how many packages I'd like to do that I was looking for an automated way
16:02:45 <quchen> That's what cabal-install is there for after all if I'm not wrong :x
16:03:05 <monochrom> "world" is the most automated way. I just say it contains junk you no longer user
16:03:08 <monochrom> s/user/use/
16:03:19 <dcoutts_> quchen: sorry, in this case cabal does not actually know if the profiling or dynamic libs for each package are installed or not. So it's not very helpful for this situation.
16:03:58 <lightquake> aw, you can't do polymorphic/qualified types in instance declarations?
16:04:06 <lightquake> :(
16:04:20 <monochrom> while you're rebuidling everything, consider enabling profiling and documentation too, not just dynamic linking
16:04:31 <dcoutts_> quchen: the longer term plan is for each "way" of a package (static, dynamic, profiling etc) to be registered with ghc-pkg independently. Then we'll have the information to do the right thing.
16:04:56 <int-e> lightquake: standard question: what are you trying to do?
16:05:08 <quchen> Alright then, next problem: Reinstalling 'world' doesn't work either: 'cabal install --reinstall --enable-shared --dry-run world' ==> rejecting: hashable-1.1.2.3/installed-272... (package is broken)
16:05:22 <quchen> This is where I'm stuck. The previous stuff was a walkthrough of what I've tried already ;-)
16:05:28 <lightquake> int-e: i was trying to be silly and make a Typeable instance for polymorphic types
16:05:43 <Eduard_Munteanu> quchen: if all else fails, purging ~/.cabal and ~/.ghc should do
16:05:52 <quchen> (Installing transformers manually again tells me I shouldn't do that because it'll break a ton of other dependencies by the way.)
16:06:03 <int-e> lightquake: oh, you were scolded for being naughty. you got what you deserved then ;)
16:06:12 <lightquake> haha
16:06:12 <quchen> So my actual question would be "How to repair (or reinstall) broken packages"
16:07:10 <int-e> quchen: unregister them (ghc-pkg unregister), optionally remove their files
16:07:36 <int-e> quchen: run ghc-pkg check first - it should find the culprits
16:07:41 <dcoutts_> actually it's simpler, just ask to install the broken one, cabal should happily reinstall it
16:08:21 * int-e wonders how much having user + global package db complicates that approach
16:08:36 <quchen> dcoutts_: cabal --reinstall ... hashtable results in "there's no such package".
16:08:50 <quchen> I'm now googling what on Earth ghc-pkg is. :-)
16:09:31 <int-e> ghc's own program for managing ghc's packages. afaik, cabal even uses it internally
16:09:49 <quchen> Empirically, ghc-pkg is a program to print screens full of warnings. No errors though, and the warnings are about docs.
16:09:57 <absence> int-e: is there a way to get my version to not build up a large thunk, but still keep the final state? unfortunately i need all the results of stepWireMst calculations, not just the final one, so replicateM_ won't work. i don't understand why it has to build up a huge thunk if i want to keep the final state - the code has to calculate it anyway in order to obtain the final result
16:10:53 <dcoutts_> quchen: there really is no package called hashtable, perhaps you meant hashable?
16:11:20 <int-e> absence: hmm, it kind of defeats the purpose of the state monad, but you could put return (w',y)  in  stepWireMst  and force both elements of the tuple in  strictList
16:12:07 <absence> int-e: i.e. the last time stepWireMst is called, the final state is the argument of put. why does returning that value via runStateT prevent the gc from collecting the previous states?
16:13:38 <int-e> absence: because it has to go through a sequence of about 50000000 calls to >>= that each deconstruct and construct a pair.
16:14:09 <absence> int-e: but it's doing that anyway, isn't it?
16:14:19 <absence> int-e: it needs the state to calculate the values
16:14:44 <int-e> absence: that's the cost of the lazy state monad; you get a result immediately, but the state that is returned will just be a thunk for a long time.
16:15:27 <quchen> Aha! So I got Parsec to run now, after installing mtl+transformers with --force-reinstall. I hope my stuff still compiles, otherwise I'll get a free GHC upgrade in my home folder. ;-)
16:15:46 <quchen> Up next: Trying to rebuild world, because why not learn some more.
16:15:51 <int-e> absence: it's really a chain looking like  id (id (id (id (id (id (... (id <final state>) ... )))))) (I'm not 100% sure how that 'id' function looks like in detail - would have to look at the core. and I'm too tired for that.)
16:16:06 * hackagebot blaze-html-truncate 0.1.0.1 - A truncator for blaze-html  http://hackage.haskell.org/package/blaze-html-truncate-0.1.0.1 (MarcelRuegenberg)
16:17:17 <absence> int-e: i understand that. forcing the result is however not a problem - via strictList i can get the last item of the list without using more than 1 MB. while doing that, it simultaneously has to evaluate the state, because each result relies on state. so it reaches the final state fine. it's only when i use this already-calculated value that all of a sudden this 300 MB thunk shows up
16:18:17 <absence> hmmm.. id
16:19:07 <absence> int-e: that's due to the actual passing around of the state inside the state monad is it?
16:19:22 <int-e> absence: you're missing the point. Yes, you have a fully evaluated state *somewhere on the heap*. But 'w' does not point there - it points to the thunk it got from the evalStateT call. And that points to another thunk from the first step in the replicateM loop. And that thunk points to another one from the second iteration, and so on, until a final thunk that points to the state.
16:20:04 <absence> int-e: ah okay, now i see
16:20:55 <absence> int-e: and there's no way to make it traverse that thunk tree simultaneously as the result list?
16:21:06 <quchen> Is there any disadvantage in installing all packages for profiling as well? Will there be special libs for profiling needs so there's no performance impact?
16:21:25 <shachaf> quchen: Yes.
16:21:33 <shachaf> Profiling libraries aren't used unless you compile with -prof
16:21:53 <shachaf> But if you do you need all of them, so you'd better add library-profiling: true to ~/.cabal/config
16:22:04 <quchen> That's where I am :-)
16:22:13 <absence> int-e: i guess that's what your suggestion of bypassing the entire state monad does ...
16:23:42 <quchen> Is there any danger in reinstalling packages? When I try to, cabal complains about a couple of packages this may break.
16:23:44 <absence> int-e: so bottom line is the state monad isn't really suitable here? lazy version gets a huge thunk for the state, and strict version gets stack overflow because it attempts to traverse to the end
16:23:54 <quchen> I mean a reinstallation shouldn't change anything.
16:25:24 <int-e> absence: I think so, yes.
16:26:09 <int-e> quchen: compilation using ghc is not deterministic.
16:26:43 <absence> int-e: that's too bad, but at least i learned a lot :) thanks
16:26:45 <int-e> quchen: which means the apparent abi usually changes (some identifiers may be different), and that will break other packages.
16:27:13 <quchen> abi?
16:27:23 <int-e> application binary interface
16:27:54 <int-e> But I think I wanted API here. I mean the functions that are exported and their argumetns.
16:28:16 <quchen> Really? A --reinstall may change the API?
16:28:22 <quchen> How's that possible?
16:28:42 <quchen> Anyway, I did it already, let's see if I can still compile something :s
16:29:31 <quchen> Works. Seems I was lucky.
16:30:07 <soapyillusions> Is there a more idiomatic way of writing this: https://gist.github.com/3837109 It's a nested case statement as both return values are Maybes. And if ever the result is Nothing I would want the whole expression to return Nothing
16:30:53 <int-e> quchen: it's just that ghc is very aggressive about inlining - parts of a function defined may be inlined elsewhere, while other parts of the same function will still be called from the library - and those parts may have random names.
16:30:58 <shachaf> soapyillusions: lookupYLString = do { val <- lookupYL key yaml; bytes <- unStr val; return (Just (unpack bytes)) }
16:31:01 <maukd> you could have invented monads
16:31:08 <shachaf> Er, with no Just, I guess.
16:31:11 <int-e> (afaik ghc HQ is working on making compilation more predictable)
16:31:26 <shachaf> Also with more arguments.
16:31:28 <quchen> int-e: I see. Thanks for all the help!
16:31:32 <shachaf> In conclusion, I messed that up completely.
16:31:59 <shachaf> lookupYLString key yaml = do { val <- lookupYL key yaml; bytes <- unStr val; return (unpack bytes) }
16:32:11 <quchen> Good thing I'm using Haskell for fun only, so breaking GHC+friends is only annoying and not neck-breaking.
16:32:30 <shachaf> lookupYLString key yaml = unpack <$> unStr =<< lookupYL key yaml -- maybe
16:32:48 <soapyillusions> shachaf awesome, that looks much better
16:33:02 <maukd> :t \key yaml -> ?lookupYL key yaml >>= fmap ?unpack . ?unStr
16:33:03 <lambdabot> forall t t1 (m :: * -> *) a a1 b. (?lookupYL::t -> t1 -> m a, ?unpack::a1 -> b, Functor m, ?unStr::a -> m a1, Monad m) => t -> t1 -> m b
16:33:11 <soapyillusions> maukd haha I figured Monads made sense here (still wrapping my head around those)
16:33:37 <maukd> they don't really, though
16:33:46 <maukd> just one particular monad works here: Maybe
16:35:21 <JoeyA> Is there a simple drawing library built on, say, cairo?
16:35:41 <JoeyA> I would look at diagrams, but I'm immediately greeted with functions like this:
16:35:45 <JoeyA> freeze :: forall v b m. (HasLinearMap v, InnerSpace v, OrderedField (Scalar v), Monoid m) => QDiagram b v m -> QDiagram b v m
16:36:34 <dcoutts_> JoeyA: perhaps read the tutorial, I understand it's quite simple
16:36:39 <int-e> absence: As I hinted at before, ghc is in principle equipped to make this work, by evaluating certain 'id' functions during GC. But this only works in one case: a record selector (like snd) that has an evaluated tuple as its argument. So if it finds  snd (a,b)  on the heap, the GC will turn that into just b. But the optimizer likes to rearrange code in ways that obscure record selectors, and when that happens, the GC will...
16:36:45 <int-e> ...copy the corresponding thunks. I've played around with this, and I think this feature is far too unpredictable to rely on.
16:38:58 <JoeyA> dcoutts: Well, with diagrams, you compose graphics by giving relative positions.  I wouldn't call it simple.
16:39:35 <JoeyA> Powerful, maybe, but not something you can do a quick doodle with without a lot of learning.
16:39:59 <dcoutts_> JoeyA: if you want something very concrete perhaps just use cairo direct.
16:41:05 <JoeyA> Cairo is close, but you have to do it imperative-style (moveTo, stroke, etc.).
16:42:06 <JoeyA> I'd rather have something like: main = draw 800 600 [segment (x,0) (x, 600) | x <- [0,20..800]]
16:42:38 <JoeyA> (Elm's drawing support is like this)
16:42:48 <JoeyA> You just give it a list of things to draw.
16:44:22 <monochrom> int-e: my http://www.vex.net/~trebla/haskell/sicp.xhtml has the full story
16:46:07 * hackagebot mime 0.3.4 - Working with MIME types.  http://hackage.haskell.org/package/mime-0.3.4 (IavorDiatchki)
16:46:08 <int-e> monochrom: I think I know most of that - it's just that I'm avoiding some of the darker spots of the problem by not using a user package database, so I lack the experience to predict the behaviour of the combination.
16:46:39 <int-e> (on the downside I've destroyed a couple of ghc installations by accident)
16:47:21 <monochrom> it also talks about ABI mutations due to rebuilding
16:47:47 <int-e> (but it has not happend so often since cabal has started to warn about reinstallations of existing packages. yay!)
16:48:37 <Axman6> JoeyA: seen Gloss?
17:01:21 <arch_is_awesome> Hey, I was wondering if I could have help attempting to rewrite the Functor instance of Data.Map
17:01:27 <arch_is_awesome> .Map
17:02:06 <shachaf> Only if you say what the problem is.
17:02:20 <arch_is_awesome> I have this so far: http://pastie.org/4911495 but it's giving me an error: Not in scope: data constructor `Map.Map'
17:02:44 <arch_is_awesome> And Not in scope: `v'
17:03:21 <Axman6> arch_is_awesome: you're using a constructor that doesn't exist
17:03:24 <geekosaur> Map doesn't expose any data constructors
17:03:26 <shachaf> I'm not sure why you expect that to work. What are you trying to do?
17:04:50 <arch_is_awesome> In learn you a haskell on page 150 it says "As an exercise, you can try to figure out how Map k is made an instance of Functor by yourself!" and that's what I'm trying to do and since I can't obviously I don't really 'get' instances very well.
17:05:32 <shachaf> I don't think they mean the implementation.
17:05:36 <Axman6> arch_is_awesome: it's probably asking you to see if you can find a frunction that already does what the Functor class does for Maps
17:05:45 <Axman6> frunction
17:05:54 <shachaf> If they do, they probably just mean something silly like Data.Map.map
17:05:55 <monochrom> I will have to read that page to see what Map means there
17:06:12 <arch_is_awesome> It is Data.Map.Map
17:06:25 <shachaf> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
17:06:29 <monochrom> but now I have to figure out page 150 is which chapter which section
17:06:41 <monochrom> thanks
17:06:50 <shachaf> arch_is_awesome: Data.Map.Map is a type, not a value.
17:06:56 <arch_is_awesome> shachaf: Thanks, I forgot there was a web version
17:07:03 <arch_is_awesome> shachaf: Type or Type Class?
17:07:10 <shachaf> Type.
17:07:15 <shachaf> Forget about type classes. They're not important.
17:07:19 <arch_is_awesome> Ah, that would be why.
17:07:20 <shachaf> (Other than Functor.)
17:07:43 <monochrom> I can't find "as an exercise" or "figure out"
17:08:01 <shachaf> monochrom: Search for "by yourself"
17:08:12 <shachaf> I imagine the phrasing was changed a bit in the book, or something.
17:08:27 <shachaf> "Maps from Data.Map can also be made a functor because they hold values (or not!)." :-(
17:08:53 <rwbarton> I think you are just intended to explain in English what fmap f is supposed to do to a Map.
17:09:27 <rwbarton> e.g. "if m is the Map with keys ... and values ... then fmap f m is the Map with keys ... and values ..."
17:09:29 <arch_is_awesome> Wouldn't it just map the function to each value?
17:10:06 <shachaf> I think confusing types and values is one of the most common and most confusing mistakes that people make when they start learning Haskell.
17:10:22 <monochrom> you can, in fact, write fmap for it without needing Data.Map's implementation details
17:10:27 <rwbarton> arch_is_awesome, yes
17:10:38 <danharaj> I think distinguishing types and values is one of the most common and most confusing mistakes that people make when they start learning Agda
17:10:43 <rwbarton> now you can try to write that function using functions you know from Data.Map
17:10:52 <rwbarton> if you like
17:11:19 <monochrom> no no no. distinguishing types and values is one of the most common and most distinguishing mistakes that people make when they start learning Agda. hehehe!
17:11:22 <shachaf> danharaj: I'd think that distinguishing them is even more important there.
17:11:42 <arch_is_awesome> But I'd like to do it the way the book wants me to so that I make sure I know how the whole instance thing works
17:12:05 <arch_is_awesome> I'm saying how would I make http://pastie.org/4911495 work?
17:12:07 <monochrom> what does the book want you to do, and how do you know?
17:12:29 <shachaf> arch_is_awesome: You won't be able to write "the meat of the function" -- you'll have to use other things that Data.Map gives you to do it.
17:12:34 <arch_is_awesome> monochrom: Because of what the book was just talking about
17:12:48 <arch_is_awesome> shachaf: Ah, I see.
17:13:03 <rwbarton> arch_is_awesome: you can't pattern match on a Map because it is an abstract data type (definition not exported from Data.Map)
17:13:18 <arch_is_awesome> rwbarton: Oh.
17:13:45 <shachaf> It doesn't help that people tend to name types and constructors the exact same thing.
17:13:55 <rwbarton> but hopefully the book has already taught you some functions for working with Maps
17:14:01 <shachaf> Cale: When you write your Haskell book, you should make sure to point out how different types and values are!
17:14:04 <monochrom> right, it is why I don't write "data X = X" to beginners
17:14:20 <arch_is_awesome> shachaf: It did.
17:14:25 <shachaf> monochrom: What do you write?
17:14:32 <monochrom> "data X = Ctor"
17:14:32 <shachaf> I don't like MkX much either.
17:14:37 <rwbarton> it is another extremely common mistake to start out every function definition with pattern matching
17:14:49 <arch_is_awesome> http://learnyouahaskell.com/modules#data-map
17:14:57 <monochrom> "data Y = Case1 X | Case2 | Case0 Y Y"
17:15:30 <arch_is_awesome> Do I at least have this part right? : instance Functor (Map.Map v) where
17:15:51 <monochrom> v? k?
17:15:55 <rwbarton> well I probably wouldn't name that variable v :) but otherwise yes
17:15:58 <Nisstyre> monochrom: is Y a type variable in that example?
17:16:11 <monochrom> Y is a type name
17:16:12 <shachaf> There are no type variables in that example.
17:16:15 <Nisstyre> ok
17:16:28 <rwbarton> nothing that starts with a capital letter is ever a variable
17:16:31 <Nisstyre> I wasn't sure if you'd capitalized it for some other reason
17:16:34 <JoeyA> Axman6: Thanks.  gloss looks like a good API.
17:16:41 <absence> int-e: i see. well, returning (y,w') seems to have done the trick, thanks a bunch :)
17:16:48 <monochrom> "data <variable> = ..." is an error
17:16:55 <arch_is_awesome> So, afterwards the fmap function should start with
17:17:01 <arch_is_awesome> fmap f Map.Map =
17:17:05 <Axman6> no
17:17:08 <shachaf> No.
17:17:09 <arch_is_awesome> :/
17:17:17 <shachaf> arch_is_awesome: Start with the type of fmap.
17:17:18 * arch_is_awesome is now confused
17:17:31 <shachaf> Forget about classes, just write "mymapmapthing :: ...; mymapmapthing = ..."
17:17:45 * shachaf would typically suggest rereading an earlier part of the book at this point.
17:17:58 <Nisstyre> monochrom: sorry, I'm a bit out of it atm :P
17:18:21 <monochrom> I bet it will just get you to "mymapmapthing f Map.Map = ...", i.e., the mixing up of type and value is still there
17:18:37 * BMeph believes that shachaf is STILL, suggesting rereading an earlier part of "the book"... ;)
17:19:09 <monochrom> and so, in fact, it is also why I do not write "f :: a -> a; f a = a"
17:19:30 <arch_is_awesome> So mymapthing is something like  Map.fromList([(4, "Four")])
17:19:31 <arch_is_awesome> ?
17:19:32 <shachaf> BMeph: I haven't read the book so I don't know.
17:19:39 <shachaf> monochrom: Yep.
17:19:51 <monochrom> I write "f :: a -> a; f x = x" on a good day
17:19:52 <arch_is_awesome> As an example...
17:20:09 <monochrom> and on a bad day, "f :: x -> x; f a = a"
17:20:38 <Nisstyre> arch_is_awesome: do you have an idea of the difference between a type constructor and a data constructor?
17:20:43 <monochrom> also, on a bad day, "let h be a monoid, G be a homomorphism..."
17:20:56 <shachaf> f :: a -> a; f = a where a a = a
17:21:06 <shachaf> What kind of day is that?
17:21:20 <arch_is_awesome> Nisstyre: A type constructor is something like []
17:21:22 <monochrom> that would be April 1st :)
17:21:45 <Nisstyre> arch_is_awesome: a type constructor is something you can potentially build more complex types out of yes
17:21:51 <shachaf> "[]" is also an empty list. :-(
17:21:53 <Nisstyre> like []
17:22:06 <shachaf> (Unrelatedly.)
17:22:15 <int-e> Maybe is a type constructor. Just and Nothing are data constructors
17:22:18 <Nisstyre> arch_is_awesome: so you understand that you can only pattern match on data constructors right?
17:22:53 <arch_is_awesome> Ye
17:23:02 <arch_is_awesome> s
17:23:14 <Nisstyre> arch_is_awesome: okay, so just keep in mind which one is which when you try to write a function
17:23:22 <monochrom> think outside pattern-matching
17:23:28 <rwbarton> you shouldn't/can't pattern match at all here. same way you did not pattern match on f
17:24:02 <arch_is_awesome> Okay
17:24:40 <shachaf> I,I fmap f (M.blah f -> x) = x
17:26:30 <arch_is_awesome> So... Map.Map is a type. Functor is a type class. Map.Map can become an instance of the Functor. Am I right so far?
17:26:53 <JoeyA> Yes
17:26:58 <shachaf> No, (Map.Map k) is an instane of Functor.
17:27:00 <shachaf> For any type k
17:27:14 <arch_is_awesome> Oh, okay.
17:27:20 <Nisstyre> k is the parameter
17:27:23 <danharaj> :k (Data.Map.Map)
17:27:24 <lambdabot> * -> * -> *
17:27:43 * shachaf would typically advise not worrying about type classes yet.
17:28:01 <arch_is_awesome> I understand type classes but not instances
17:28:04 <shachaf> There are much more fundamental parts of Haskell that one should understand pretty well before worrying about them.
17:28:15 <shachaf> arch_is_awesome: That doesn't make sense.
17:28:35 <arch_is_awesome> ...mostly
17:28:54 <shachaf> Do you know what the type of the function you're trying to write here is?
17:28:56 <arch_is_awesome> Type classes except for adding instances. There.
17:29:05 <shachaf> No, that still doesn't make sense. :-)
17:29:11 <arch_is_awesome> D:
17:29:39 <danharaj> You can't really understand what a type class is without knowing how to write an instance.
17:29:41 <arch_is_awesome> Functor f => (a -> b) -> f a -> f b
17:30:13 <shachaf> No, that's general-purpose fmap.
17:30:22 <shachaf> You're writing a special fmap here. Do you know what its type should be?
17:30:41 <arch_is_awesome> Thinking...
17:30:56 <danharaj> You are trying to turn a type f into a functor.
17:31:03 <danharaj> what is the type f?
17:31:09 <shachaf> danharaj: What?
17:31:31 <shachaf> Oh, you mean "make a Functor instance for a type"
17:32:14 <int-e> or type constructor
17:32:20 <arch_is_awesome> (Functor f) => (a -> b) -> f Map.Map k v -> f Map.Map k o
17:32:22 <arch_is_awesome> I guess
17:32:35 <int-e> ?!
17:32:35 <lambdabot> Maybe you meant: . ? @ v
17:32:42 <arch_is_awesome> Either that or I've seriously got to read the section again
17:32:45 <int-e> lambdabot: defintely not
17:32:58 <shachaf> arch_is_awesome: You've seriously got to read either this section or an earlier section again.
17:33:05 <cmccann> hey shachaf, I'm thinking of writing all my programs as nothing but type classes. do you think that's a good idea?
17:33:08 <int-e> arch_is_awesome: the f I can understand, but what are v and o?
17:33:10 <cmccann> :D
17:33:18 <int-e> arch_is_awesome: (the f is wrong though)
17:33:19 <shachaf> cmccann: For anyone else, I'd say no.
17:33:26 <cmccann> heh
17:33:30 <shachaf> cmccann: But I remember that SKI evaluator you wrote.
17:33:41 <shachaf> So sure, why not.
17:33:50 <cmccann> pf, that used type families. not the same thing at all.
17:34:01 <Nisstyre> arch_is_awesome: what book are you working through RWH?
17:34:05 <Nisstyre> LYAH?
17:34:11 <arch_is_awesome> LYAH
17:34:18 <Nisstyre> cool
17:34:27 <cmccann> anyway most of my old type hackery is probably obsolete these days with all the new GHC extensions
17:34:31 <arch_is_awesome> Chapter 7 is super confusing, though
17:34:46 <Nisstyre> arch_is_awesome: I don't think you will really grok Haskell's type system until you understand the process of unification
17:34:55 <Nisstyre> so keep at it
17:34:58 <shachaf> It's the Simon conspiracy! Putting honest hard-working type hackers out of work!
17:35:32 <arch_is_awesome> Nisstyre: Of course, not that I know what the process of unification in Haskell is...
17:35:33 <rwbarton> nah, it ensures job security
17:35:56 <shachaf> Unification is important to understand.
17:36:06 <shachaf> And it doesn't have much to do with type classes. :-)
17:36:23 <shachaf> cmccann: I'm just a h8r anyway. Don't listen to me.
17:36:25 <arch_is_awesome> Honestly, I'm not enjoying Haskell too much at the moment. I'm having to force myself to finish Chapter 7.
17:36:37 <BMeph> That made such little sense, that it kind-of makes sense to say it the other way, actually. :/
17:36:53 <int-e> shachaf: it's not even unification, it's plain instantiation
17:36:54 <cmccann> type classes stole shachaf's lunch money every day when he was younger.
17:37:34 <shachaf> int-e: Unification is important to understand anyway!
17:37:44 <int-e> shachaf: sure
17:37:59 <int-e> shachaf: I wasn't disagreeing with that part
17:37:59 <shachaf> arch_is_awesome: The following two types are the same: (a -> Int) and (Char -> b)
17:38:05 <shachaf> What are a and b?
17:38:23 <Nisstyre> hehe
17:38:46 <Nisstyre> hint: put one of them above the other
17:38:54 <Nisstyre> makes it easier to see the solution
17:39:00 <arch_is_awesome> a is Char and b is Int?
17:39:06 <shachaf> Yep!
17:39:16 <Nisstyre> that is unification
17:39:34 <shachaf> The following two types are the same: [a] -> Maybe b and String -> f Char
17:39:38 <shachaf> What are a, b, and f?
17:40:02 <arch_is_awesome> a is a Char
17:40:19 <centrinia> b is Char
17:40:21 <centrinia> f is Maybe
17:40:37 <arch_is_awesome> But a would also be Char, right?
17:40:47 <centrinia> Sure.
17:40:59 <centrinia> :t String
17:41:00 <lambdabot> Not in scope: data constructor `String'
17:41:10 <Nisstyre> arch_is_awesome: essentially, building a set of constraints and trying to find a type that fills all of them
17:41:53 <shachaf> You can also go the other way. a is Int, b is Char, f is Map k. What's (a -> b) -> f a -> f b?
17:42:00 <Cale> arch_is_awesome: Feel free to ask any questions you might have
17:42:22 <shachaf> I wouldn't take advice from Cale if I was you.
17:42:25 <arch_is_awesome> one second, phone call...
17:42:41 <shachaf> You might get kicked from Freenode for flooding.
17:42:48 <shachaf> (You should take advice from Cale.)
17:43:02 <Cale> wat
17:43:28 <Cale> apparently I've been super lagged
17:47:34 <danharaj> I wish there were a cabal nuke option that would just nuke all my installed libraries
17:47:49 <danharaj> cabal firezemissiles works too
17:48:37 <shachaf> mkdir ~/junk; mv ~/.cabal ~/.ghc ~/junk/
17:48:55 <gfredericks> what does !! mean? I'm reading the memoization page on the haskell wiki
17:49:01 <danharaj> :t !!
17:49:03 <lambdabot> parse error on input `!!'
17:49:06 <danharaj> :t (!!)
17:49:08 <lambdabot> forall a. [a] -> Int -> a
17:49:26 <gfredericks> oh I knew that
17:49:29 <gfredericks> thanks :)
17:49:47 <JoeyA> shachaf: I don't think you need to move .cabal
17:50:01 <JoeyA> On the other hand, .cabal/bin contains compiled programs.
17:50:32 <JoeyA> I usually just rename ~/.ghc/x86_64-linux-7.4.2
17:50:39 <shachaf> JoeyA: Yes, but it'll keep taking up space.
17:50:41 <arch_is_awesome> Sorry.
17:50:49 <shachaf> shachaf@carbon:~$ du -sh GHC-OLD/
17:50:52 <shachaf> 1.8G	GHC-OLD/
17:51:27 <JoeyA> That's because you keep dropping copies of .cabal in there :P
17:51:46 <shachaf> It has one copy of .cabal
17:51:51 <JoeyA> Oh
17:52:40 <rwbarton> yeah but there's also GHC-OLD/GHC-OLD/.cabal
17:53:42 <danharaj> does the latest version of cabal have sandboxing ala cabal-dev yet?
17:53:52 <JoeyA> Last time I checked, my .cabal had about 300,000 files.
17:54:24 <shachaf> That's a lot.
17:54:25 <latro`a> O.O
17:54:36 <shachaf> About 30 times as many as mine.
17:56:12 <YayMe> Does anybody else find haskell just too mind bending to keep at every day? Do you ever get over that?
17:56:32 <arch_is_awesome> shachaf: Off the phone. Currently thinking about "What's (a -> b) -> f a -> f b?"
17:56:54 <YayMe> I don't ever remember feeling such brain pain when I learned other languages.. never felt the explicit need to take a break from them but maybe my memory's just not good enough
17:57:00 <copumpkin> YayMe: of course you get over it :)
17:57:11 <copumpkin> YayMe: that's because most other languages don't teach you much beyond a new syntax and standard library
17:57:13 <arch_is_awesome> f is a data comstructor.
17:57:24 <arch_is_awesome> a and b are types
17:57:26 <Catnaroek> data?
17:57:46 <Catnaroek> f looks like a type constructor
17:58:05 <arch_is_awesome> Ugh. Mixed them again.
17:58:10 <YayMe> copumpkin: True but I don't even remember this sensation with my first programming language which would have been more than just new syntax, though maybe it was just too long ago
17:58:30 <crdueck> arch_is_awesome: :t fmap
17:58:35 <crdueck> :t fmap
17:58:37 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:58:51 <arch_is_awesome> fmap :: Functor f => (a -> b) -> f a -> f b
17:58:53 <YayMe> either way, I think I need to go shoot zombies or something before I work on my parser anymore..
17:59:08 <john_r_watson> @pl (\_ -> isPentagonal (p' - p) && isPentagonal (p' + p))
17:59:08 <lambdabot> const (isPentagonal (p' - p) && isPentagonal (p' + p))
17:59:29 <arch_is_awesome> Haskell is by far the hardest language I've done so far... (I have not done many though... C++ Python Bash)
17:59:34 <john_r_watson> @pl (\p' p -> isPentagonal (p' - p) && isPentagonal (p' + p))
17:59:35 <lambdabot> ap (ap . (((&&) . isPentagonal) .) . (-)) ((isPentagonal .) . (+))
18:00:04 <john_r_watson> @pl (\p' p -> all isPentagonal [p' - p, p' + p])
18:00:05 <lambdabot> (all isPentagonal .) . ap (ap . ((:) .) . (-)) (flip flip [] . ((:) .) . (+))
18:01:32 <YayMe> just because I can never keep it straight in my head; can I do data Bla a = Har a | Lala a Har a
18:01:45 <latro`a> er, no
18:01:47 <YayMe> the Lala needs to be Lala a Bla a right?
18:02:01 <latro`a> data Bla a = Har a | Lala a (Bla a) a
18:02:01 <rwbarton> you can but it probably doesn't do what you mean?
18:02:02 <latro`a> is valid
18:02:03 <YayMe> was curious if I could constrain it down further
18:02:05 <rwbarton> but also what you mean is very unclear
18:02:29 <YayMe> well here I'll show what I'm trying to do
18:02:48 <rwbarton> no, there is no type that is "Bla a but only stuff constructed with the Har constructor"
18:03:00 <latro`a> nor should there be
18:03:15 <latro`a> (this is a feature, not a bug)
18:03:23 <YayMe> data CSharp a = Comment a | Statement a | Block [CSharp a] | Namespace (Block a)
18:03:30 <YayMe> the last one being my curiosity
18:03:39 <latro`a> if Block is a type constructor then that's fine
18:03:42 <YayMe> I want to constrain it down to saying a namespace comes with a block specifically
18:03:43 <latro`a> but confusing
18:03:50 <rwbarton> you probably want those to be separate types
18:03:54 <YayMe> ok
18:03:55 <latro`a> because it's also a data constructor for a type that isn't Block
18:03:59 <rwbarton> rather than constructors of a single type "mash of C# code"
18:04:05 <YayMe> I *can* do it, but it's bad practice, is what you're saying?
18:04:24 <Nisstyre> GADTs are supposedly good for doing that sort of thing
18:04:34 <Nisstyre> I haven't used them for it myself
18:04:35 <latro`a> there isn't a way to create a type that is the instances of a specific type but only with certain data constructors
18:04:43 <latro`a> (except perhaps with unsafe stuff)
18:04:43 * YayMe has heard of GADTs but doesn't know what they exactly are
18:04:48 <Cale> arch_is_awesome: I'd say C++ is way more complicated than Haskell really.
18:04:48 <rwbarton> "data CSharp a = Comment a | Statement a | Block [CSharp a] | Namespace (Block a)" does not mean what you want it to mean. there Block a is being used as a wholly separate type in the argument to Namespace
18:04:54 <Nisstyre> YayMe: there is a good wikibooks explanation
18:05:29 <YayMe> rwbarton: Ah, I gotcha
18:05:32 <Cale> arch_is_awesome: But Haskell is a very different language.
18:05:38 <arch_is_awesome> Cale: No, even things like maclloc and arrays/strings didn't make it hard
18:05:42 <arch_is_awesome> (as haskell)
18:05:48 <Cale> So it's more like learning to program again
18:05:52 <Cale> from scratch
18:05:56 <alpounet> the C++ langage itself is much more complicated definitely
18:06:01 <Nisstyre> YayMe: http://en.wikibooks.org/wiki/Haskell/GADT
18:06:17 <monochrom> type class in c++ would be just as hard as type class in haskell
18:06:31 <arch_is_awesome> But there is no need for type class in c++
18:06:34 <alpounet> many undefined behaviors, a complicated syntax for many stuffs
18:06:39 <alpounet> that's called concepts
18:06:44 <alpounet> and it didn't make it for C++11
18:06:49 <Catnaroek> arch_is_awesome: Oh, really? Why were they trying to hack concepts into C++, then?
18:07:18 <YayMe> "C++ is an octopus made by nailing legs to a dog" this is how C++ appears to me and what makes me think it would actually be extremely hard, it just has.. SO MUCH...
18:07:20 <monochrom> you can write a lot of haskell code without being very aware of type class, either
18:07:47 <Catnaroek> monochrom: By explicitly passing vtables around instead, you mean?
18:07:50 <arch_is_awesome> Eh. Anyways, even though it's hard I'm still going to at least finish the book before judging Haskell
18:07:58 <Cale> The C++ standard is 1356 pages, maybe you could take out 100-150 if you didn't count the indices
18:08:06 <YayMe> haha
18:08:14 <danharaj> The Haskell report is hella tiny.
18:08:20 <Nisstyre> YayMe: do you think GADTs would help you here?
18:08:21 <monochrom> you're looking at: "writing a Functor instance for Data.Map is hard". ok, it is hard in both Haskell and C++
18:08:25 <Cale> The Haskell 2010 standard is 329 pages (296 without the indices)
18:08:30 <YayMe> danharaj: Really? I never actually even looked at it, assumed it was huge
18:08:34 <Cale> and the GHC User's Guide is 300 pages
18:08:44 <Cale> So combined that's still less than half
18:08:47 <danharaj> Cale: Something seems off about the standard being that long.
18:08:56 <monochrom> then you say, "C++ does not need me to write a Functor instance for Data.Map". ok, but haskell does not need you to write that either
18:09:00 <danharaj> I swear it was <100 pages. How long is the description of the prelude etc.?
18:09:04 <rwbarton> it covers a bunch of libraries now
18:09:08 <danharaj> oh. indeed.
18:09:24 <arch_is_awesome> Okay, whatever. I quit comparing Haskell to C++ ATM. I'm trying to learn Haskell, not c++
18:09:26 <Cale> Yeah, if I was talking about Haskell 98, it'd be smaller
18:09:48 * arch_is_awesome should not have said anything about c++
18:09:57 <danharaj> At least you didn't say anything about ruby.
18:10:04 <arch_is_awesome> I don't know ruby
18:10:14 <Cale> The context free grammar that the C++ standard provides is about 20 pages long, and a similarly detailed grammar for Haskell from the report is 5 pages, and the 5th page is mostly blank.
18:10:18 <YayMe> Nisstyre: Ah yeah that does look about right. Though now I would be concerned I'm using a more advanced technique where it's not necessary?
18:10:26 <monochrom> I'm saying you are doing an unfair comparison. you pick a challenging job in haskell, something that you never did for c++, then you say it's harder than c++
18:10:38 <Nisstyre> YayMe: dunno, I don't think there's much possibility of shooting yourself in the foot here
18:10:39 <mapreduce> It's odd how Haskell gets compared to C++ more often than to C# or Java (anecdotal)
18:10:41 <arch_is_awesome> monochrom: Okay then. Here it is: I was wrong.
18:10:46 <Nisstyre> YayMe: you can always change it back pretty easily
18:11:41 <Cale> arch_is_awesome: Anyway, I'm not trying to be hard on you, I just thought it was interesting to compare :)
18:12:07 <arch_is_awesome> I was talking to monochrom
18:12:25 <YayMe> mapreduce: plausibly related to the willingness to accept difficulty of C#/java devs vs C++ devs, C++ folks are used to complicated difficult things every day, a decent C# dev's most difficult task is deciding how to define a contract a lot of times
18:12:30 <arch_is_awesome> But after comparing them I just realized it was stupid to because both languages are so different
18:13:05 <Cale> arch_is_awesome: Yeah, most of the difficulty of initially learning Haskell is forgetting that you already know how to program and learning to do it in another way.
18:13:08 <YayMe> mapreduce: It seems a lot of folks in here have experience with systems level development at the lower level like C/C++, that is quite uncommon of C#/java developers these days
18:13:46 <YayMe> mapreduce: That said, I think haskell has far more in common with C# than C++
18:13:47 <arch_is_awesome> I don't know C# or Java. Reason is: I've hated stuff made in java and don't really like mon
18:13:49 <arch_is_awesome> *mono
18:14:14 <arch_is_awesome> Okay, back to Functors and Data.Map...
18:14:34 <Jafet> http://www.vex.net/~trebla/humour/Nightmare.java
18:15:03 <YayMe> Nisstyre: Of course, I'm not worried about shooting myself in the foot so much as doing things in a pleasantly idiomatic fashion, after all I write haskell to practice and improve not produce
18:15:12 <Ghoul> ion: Thanks for the link last night
18:15:13 <lambdabot> Ghoul: You have 1 new message. '/msg lambdabot @messages' to read it.
18:15:17 <arch_is_awesome> What would be the type constructor I would use for Map in the line after instance Functor (Map.Map v) where
18:15:19 <Jafet> Someone should do that with like C# generics
18:15:45 <arch_is_awesome> the fmap f (whateverinedd) =
18:15:54 <arch_is_awesome> *whateverineed
18:15:54 <Ghoul> MostAwesomeDude: Hiya
18:16:17 <Jafet> fmap f x =
18:16:22 <Cale> arch_is_awesome: If you were writing an instance for Data.Map, you'd just match the Map as a variable
18:16:23 <monochrom> you need a parameter name, not a type constructor, there
18:16:44 <Cale> The data constructors for Data.Map are hidden by the module
18:16:53 <Cale> (it's an abstract type)
18:17:06 <arch_is_awesome> Oh, yeah. Someone said that a few hundred lines ago...
18:18:13 <Cale> and the idea is that you want to apply the function to all the elements of the map
18:18:37 <arch_is_awesome> Wouldn't that have to be a recursive function?
18:18:42 <Cale> you could just use the map function which is exported by Data.Map
18:18:54 <monochrom> depends on what else you use
18:19:15 <alpounet> arch_is_awesome, under the hood, it is going to be one yes
18:19:21 <Cale> or you could turn the Map into a list of pairs, with toAscList, and then apply the function to the second parts of those pairs, and use fromAscList to turn it back again
18:19:27 <alpounet> however, you can only manipulate it through the functions it exports
18:20:13 <Cale> http://hackage.haskell.org/packages/archive/containers/0.4.2.1/doc/html/Data-Map.html
18:20:14 <arch_is_awesome> alpounet: Thanks
18:20:28 <Cale> Have a look at the documentation there to see what's available
18:20:28 <monochrom> have you read the docs of Data.Map? do you know what operations are available?
18:20:43 <alpounet> you don't have access to its internals, just the functions you can see in the link Cale just gave
18:21:27 <alpounet> and with that, you have to, like Cale said a few lines ago, apply some function to all the elements
18:21:37 <Cale> Just using the map function which is provided is a little cheesy perhaps, but it's probably the expected thing.
18:21:38 <arch_is_awesome> If I do that I might as well use Data.Map.map
18:21:42 <Cale> yeah
18:21:45 <alpounet> arch_is_awesome, what would be the type of fmap when the Functor in question is Map ?
18:21:51 <Cale> This isn't a great exercise :)
18:22:02 <arch_is_awesome> One second. Another phone call... stupid birthday
18:22:04 <Cale> though I guess it might be considered an exercise in documentation :)
18:23:05 <jfischoff> where is HsFFI.h located?
18:23:33 <monochrom> must you know?
18:23:54 <monochrom> something like <prefix>/lib/ghc-7.4.1/include
18:24:01 <jfischoff> ah
18:24:07 <alpounet> arch_is_awesome, a better exercise would be to define a 'Tree a' type, and define a functor instance for it
18:24:24 <monochrom> but you must not know. you must just say "ghc c-code.c" and it will know
18:24:50 <YayMe> alpounet: I've been pondering exactly that lately.. it's trickier than I expected..
18:25:06 <arch_is_awesome> Cale: Doesn't it serve it's purpose though?
18:25:08 <alpounet> YayMe, alright, what are you waiting to try then? :)
18:25:35 <Cale> arch_is_awesome: Well, so long as you get some idea of what's going on, I suppose it does :)
18:25:56 <jfischoff> monochrom: I calling Haskell from c
18:26:23 <monochrom> yes, use ghc to compile c code, I am serious
18:26:30 <danharaj> blah, cabal-install shouldn't spew warnings on x86-64 :[
18:26:31 <YayMe> alpounet: Plenty of other things to be trying at first :) though I find myself running into similar things as that.. earlier today I had to figure out how to write a filter on a data CSharp = Unidentified a | Block [CSharp a] to filter the unidentified's out at each nested level
18:26:35 <danharaj> (while building)
18:26:51 <arch_is_awesome> Duplicate instance declarations
18:26:53 <YayMe> alpounet: it took a lot more mental trickery than I had expected..
18:27:03 <Cale> arch_is_awesome: yeah, the instance already exists
18:27:11 <arch_is_awesome> How do I override it?
18:27:12 <jfischoff> monochrom: can ghc make .bundle files for osx?
18:27:16 <alpounet> YayMe, yeah, you should definitely try to write a Functor instance for a Tree type
18:27:20 <Cale> You actually can't
18:27:29 <jfischoff> actually
18:27:30 <monochrom> I don't know
18:27:33 <jfischoff> that doesn't matter
18:27:35 <jfischoff> okay
18:27:43 <jfischoff> I'll take your advice
18:28:04 <danharaj> ughblughguh why does HTTP have a version constraint on GHC itself.
18:28:17 <Cale> arch_is_awesome: There's a very silly type I like to use as an example every once in a while -- it can be made an instance of Functor and Monad and we can write a catamorphism for it and lots of other neat things
18:28:25 <alpounet> YayMe, that will help with reasonning about inductive types
18:28:28 <YayMe> alpounet: Why? will it suddenly click and I won't have to think about it next time? I wrote a snippet that walked a graph a while back and relied on some of the similar thought process for figuring out the filtering
18:28:47 <arch_is_awesome> Cale: Right, but how do I know if my instance works?
18:28:49 <alpounet> well, figuring this out will help for sure
18:29:20 <Cale> arch_is_awesome: one thing you could do is make a newtype of Data.Map and implement the instance for the newtype (you'll need an extra data constructor)
18:29:25 <monochrom> at least you need ghc at link time. you need to link in the haskell runtime system, and ghc knows how to do it.
18:29:26 <alpounet> when learning haskell you have a bunch of things you have to understand and do that you don't have to with other languages
18:29:47 <arch_is_awesome> Cale: I have no learned about newtype yet
18:29:51 <arch_is_awesome> *not
18:29:56 <Cale> have you learned about data?
18:30:02 <arch_is_awesome> Yes
18:30:08 <Cale> okay, then you could write:
18:30:17 <Cale> data MyMap a b = MM (Map a b)
18:30:35 <Cale> and write an instance Functor (MyMap a)
18:30:38 <danharaj> ... apparently the latest version of HTTP was built on GHC 7.6 while having a .cabal that explicitly rejects GHC versions >= 7.6.
18:30:54 <danharaj> How does that happen.
18:31:44 <arch_is_awesome> Couldn't match expected type `MyMap x b'
18:31:56 <arch_is_awesome> with actual type `Map.Map k0 b0'
18:32:07 <Cale> arch_is_awesome: right, you'll need to unwrap and rewrap the MM constructor
18:32:12 <monochrom> fmap f (MM x) = ...
18:32:16 <Cale> so  fmap f (MM x) = MM ...
18:32:46 <Tekmo> danharaj: I don't see where it forbids GHC >= 7.6
18:32:51 <Tekmo> I only see that in the Tests sefction
18:32:56 <Cale> arch_is_awesome: newtype is the same as data, but it only allows one constructor with one field, and has a small semantic difference that enables the compiler to implement it without any extra overhead over the original type
18:33:30 <arch_is_awesome> http://pastie.org/4911730 is not working :/
18:33:31 <Cale> arch_is_awesome: So pattern matching against the constructor of the newtype doesn't cost anything, and neither does it take up any space in memory
18:33:37 <arch_is_awesome> Sorry for being so ignorant
18:33:46 * arch_is_awesome feels like an idiot
18:33:56 <Cale> arch_is_awesome: You'll want to wrap the right hand side in  MM (...)  too
18:34:12 <Cale> Let's do a better example...
18:34:33 <rwbarton> this is all way afield from what you were reading about in LYAH really
18:34:46 <arch_is_awesome> Thanks...
18:34:51 <Tekmo> The best kind of afield!
18:35:15 <Cale> data Nature a = Rock a | Stream (Nature a) | Bush (Nature a) (Nature a)
18:35:16 <arch_is_awesome> LYAH has Tree so that won't help...
18:35:24 <Cale> Let's make a Functor instance for Nature
18:35:32 <hpaste> YayMe pasted “Trainwreck graphwalker” at http://hpaste.org/75788
18:35:33 <copumpkin> deriving (Functor)
18:35:40 <Tekmo> lol
18:35:44 <Cale> copumpkin: DON"T RUIN OUR FUN
18:35:51 <copumpkin> :)
18:35:59 <arch_is_awesome> I already knew about deriving
18:36:01 <Tekmo> instance Functor Nature where fmap = fmap
18:36:10 <copumpkin> excellent
18:36:29 <copumpkin> that's because = is reflexive
18:36:29 <copumpkin> definitional equality is reflexive, so Tekmo's solution works
18:36:30 <copumpkin> duh
18:36:33 <arch_is_awesome> Darn... that did ruin it.
18:36:34 <YayMe> I remember having a version of that walkGraph written that would accurately walk back up the tree too
18:36:41 <YayMe> that version just visits each node
18:36:51 * copumpkin shuts up
18:36:52 <Cale> arch_is_awesome: heh, but no, we get to write a recursive fmap here
18:37:02 <Cale> instance Functor Nature where
18:37:11 <Cale>   fmap f (Rock x) = ...
18:37:16 <arch_is_awesome> Wait... let me get the data thing first...
18:37:31 <Tekmo> If it makes you feel better
18:37:32 <Cale> okay, yeah, maybe try to understand what these data structures look like
18:37:39 <Tekmo> Haskell's type notation was really confusing to me, too
18:37:41 <Cale> I'll give you an example of a Nature Integer
18:37:48 <arch_is_awesome> So Rock can be any type
18:37:50 <arch_is_awesome> Rock 4
18:37:53 <arch_is_awesome> Rock "Stringy"
18:37:54 <YayMe> alpounet: how terribly did I reason my way through my graph? :D
18:37:58 <arch_is_awesome> Yes?
18:38:01 <Jafet> @remember Cale data Nature a = Rock a | Stream (Nature a) | Bush (Nature a) (Nature a)
18:38:02 <lambdabot> I will never forget.
18:38:03 <Tekmo> Rock 4 :: Nature Int
18:38:09 <Tekmo> Rock "Stringy" :: Nature String
18:38:25 <Cale> Bush (Bush (Rock 1) (Stream (Rock 2))) (Stream (Stream (Bush (Rock 3) (Rock 4))))
18:38:28 <arch_is_awesome> So what's the difference between Rock and Stream?
18:38:40 <Tekmo> A Stream holds another nature inside of it
18:38:42 <Cale> Stream takes a single argument which is another Nature
18:38:43 <arch_is_awesome> Stream has (Nature a) instead of just a
18:38:45 <arch_is_awesome> Oh, I see
18:38:54 <arch_is_awesome> And Bush takes two?
18:38:56 <Cale> yeah
18:38:57 <Tekmo> Yes
18:39:17 <arch_is_awesome> Interesting. So you can store two Streams in a Bush?
18:39:17 <YayMe> arch_is_awesome: but it's not worth as much as one in the hand
18:39:21 <Cale> yeah
18:39:38 <arch_is_awesome> I obviously shold not be trying to picture this...
18:39:41 <arch_is_awesome> *should
18:39:42 <Cale> Bush (Stream (Rock 1)) (Stream (Stream (Stream (Rock 3))))
18:39:42 <Tekmo> lol
18:39:52 <Tekmo> Keep it simple for now
18:39:54 <YayMe> arch_is_awesome: you can also store a bush in each of those 2 streams
18:40:01 <Tekmo> Stream (Rock 4) :: Nature Int
18:40:06 <Tekmo> Rock 4 :: Nature Int
18:40:12 <Tekmo> Stream (Stream (Rock 4)) :: Nature Int
18:40:13 <Cale> heh, I should add this type to lambdabot temporarily
18:40:28 <YayMe> f = Stream f
18:40:32 <Tekmo> Bush (Rock 4) (Rock 4) :: Nature INt
18:40:36 <Cale> :t Stream
18:40:38 <lambdabot> Not in scope: data constructor `Stream'
18:40:41 <Cale> okay good :)
18:40:53 <Tekmo> Bush (Stream (Rock 4)) (Rock 4) :: Nature Int
18:41:06 <Tekmo> Bush (Rock 4) (Stream (Rock 4)) :: Nature Int
18:41:08 <arch_is_awesome> More b-day calls
18:41:13 * hackagebot wai-util 0.1 - Collection of utility functions for use with WAI  http://hackage.haskell.org/package/wai-util-0.1 (StephenWeber)
18:41:26 <Cale> @undefine
18:41:33 <Cale> :t Bush (Stream (Rock 4)) (Rock 4)
18:41:35 <lambdabot> forall t. (Num t) => Nature t
18:41:44 <Tekmo> Here
18:42:04 <Tekmo> Use Chars instead
18:42:07 <Tekmo> :t Rock 'A'
18:42:09 <lambdabot> Nature Char
18:42:16 <Tekmo> :t Stream (Rock 'A')
18:42:17 <lambdabot> Nature Char
18:42:23 <arch_is_awesome> That was quick
18:42:24 <Tekmo> :t Stream (Stream (Rock 'A'))
18:42:25 <lambdabot> Nature Char
18:42:33 <Cale> :t Rock (Rock 'a')
18:42:35 <lambdabot> Nature (Nature Char)
18:42:35 <arch_is_awesome> Back
18:42:59 <Tekmo> Perhaps this is not a good example
18:43:04 <Tekmo> How do you define data types?
18:43:08 <arch_is_awesome> Okay, now I should probably be using deriving Show...
18:43:08 <Tekmo> for lambdabot?
18:43:15 <YayMe> alpounet: Actually, my graph walker is almost a perfect functor (it's not perfectly so on purpose), am I wrong? (asside from the "perfect" part where my implementation is terrible)
18:43:21 <Cale> arch_is_awesome: yeah, if you want to play with this
18:43:31 <Cale> Tekmo: I just added the definition to lambdabot's prelude
18:43:35 <Tekmo> lol
18:43:39 <Cale> (directly)
18:43:52 <arch_is_awesome> Okay....
18:43:59 <arch_is_awesome> ls
18:44:00 <YayMe> > Rock 4
18:44:02 <lambdabot>   Rock 4
18:44:13 <Cale> > Bush (Stream (Rock 1)) (Stream (Stream (Stream (Rock 3))))
18:44:16 <lambdabot>   Bush (Stream (Rock 1)) (Stream (Stream (Stream (Rock 3))))
18:44:16 <arch_is_awesome> Sorry, my window manager seems to have died....
18:44:44 <YayMe> > Bush (Stream $ Bush (Rock 1) (Rock 2)) (Stream $ Rock 3)
18:44:46 <lambdabot>   Bush (Stream (Bush (Rock 1) (Rock 2))) (Stream (Rock 3))
18:44:55 <Tekmo> I remember my first introduction to Haskell data types
18:45:00 <Tekmo> was Real World Haskell
18:45:10 <YayMe> whoa, no lyah then?
18:45:12 <Tekmo> I was so utterly confused
18:45:20 <Tekmo> Back then I didn't know about LYAH
18:45:39 <Tekmo> I was like "I have no idea what I'm doing"
18:45:45 <YayMe> I can't imagine haskell without lyah.. actually I can, it goes like this: "What? Hmm... Uh?? Screw this."
18:45:47 <Tekmo> Stuff like
18:45:54 <Tekmo> data Tree a = Tree (Just a) (Just a)
18:46:07 <Cale> > let rocks (Rock x) = [x]; rocks (Stream n) = rocks n; rocks (Bush n n') = rocks n ++ rocks n' in rocks $ Bush (Bush (Rock 1) (Stream (Rock 2))) (Stream (Stream (Bush (Rock 3) (Rock 4))))
18:46:10 <lambdabot>   [1,2,3,4]
18:46:31 <Tekmo> I just ended up typing random assortments of Just and Maybe until it finally type-checked
18:46:40 <Tekmo> then I went "Welp, that was a disaster"
18:47:14 <hpc> Tekmo: i like how when people switch to haskell, they have an enormous amount of trouble separating types and values
18:47:31 <Tekmo> hpc: Yeah, that was exactly my problem
18:48:01 <Tekmo> What makes it really confusing
18:48:05 <hpc> to be fair, "dataconstr type type type" doesn't help
18:48:07 <Tekmo> is the convention of naming some constructors after the type
18:48:26 <YayMe> Tekmo: Which I'm told is a good practice?
18:48:34 <Tekmo> Well, it is convention
18:48:58 <Tekmo> At least for many newtypes
18:49:17 <Cale> http://imgur.com/j9M4x hahaha
18:49:24 <copumpkin> in Agda, data Tree (A : Set) : Set where Tree : Maybe A -> Maybe A -> Tree A is an empty type
18:49:45 <arch_is_awesome_> Sorry, my computer just went kaput
18:49:55 <arch_is_awesome_> It obviously does not like streams and rocks.
18:50:10 <Tekmo> Well, let's stick to a simpler type
18:50:12 <Tekmo> How about this
18:50:32 <Tekmo> data NaturalNumber = Zero | Successor NaturalNumber
18:50:54 <Tekmo> I guess his computer doesn't like natural numbers either
18:50:57 <Cale> That won't quite do, if we want to talk about Functor
18:50:59 <copumpkin> lol
18:51:03 <Cale> because it has no type parameter
18:51:05 <arch_is_awesome_> I'll stick with stream
18:51:09 <Tekmo> Oh yeah
18:51:10 <YayMe> I suggest keeping rocks and streams clear of the computing device
18:51:11 <Tekmo> This is about functors
18:51:13 <arch_is_awesome_> I think it was a problem with gnome shell
18:51:16 <copumpkin> data Nat a = Zero | Suc a
18:51:17 <copumpkin> there you go
18:51:28 <Tekmo> Except then it's confusing
18:51:37 <Tekmo> How about starting with the simplest functor, Identity?
18:51:37 <copumpkin> :k Mu Maybe
18:51:38 <lambdabot> *
18:51:43 <arch_is_awesome_> Isn't that the same thing as maybe?
18:51:47 <Cale> arch_is_awesome_: I'm still on Ubuntu 11.04 because I can't stand any of the new Gnome 3 or Unity garbage.
18:51:51 <copumpkin> arch_is_awesome_: yep!
18:52:08 <Tekmo> Here, consider the simplest functor type:
18:52:15 <arch_is_awesome_> I'll just do the Stream, Rock, Bush thing. It looks fine.
18:52:17 <Tekmo> data MyType a = Constructor a
18:52:18 <Cale> arch_is_awesome_: copumpkin is being kinda confusing :)
18:52:20 <Cale> yeah
18:52:24 <copumpkin> sorry :(
18:52:25 <Cale> just do my example :)
18:52:34 <arch_is_awesome_> Okay.
18:52:58 <arch_is_awesome_> data Nature = Rock a | Stream (Nature a) | Bush (Nature a) (Nature a)
18:53:00 <arch_is_awesome_> Yes?
18:53:07 <Cale> yeah
18:53:09 <Cale> err
18:53:15 <Cale> data Nature a = Rock a | Stream (Nature a) | Bush (Nature a) (Nature a)
18:53:23 <arch_is_awesome_> Ah, forgot the a :)
18:53:30 <danharaj> So I take it that the sandbox-* commands haven't made it into the latest cabal-install release :(
18:53:38 <danharaj> I thought that patch went through a while ago!
18:54:56 <arch_is_awesome_> Okay, so now to make it Functor?
18:55:03 <YayMe> How long does it take for haskell to stop giving me an outright headache? 1 year? 2?
18:55:04 <Cale> yeah
18:55:34 <Cale> so just treat one constructor at a time, and handle it recursively
18:56:03 <arch_is_awesome_> What would fmap actually do?
18:56:40 <Tekmo> Look at the type:
18:56:47 <Tekmo> fmap :: (a -> b) -> Nature a -> Nature b
18:56:49 <arch_is_awesome_> Like what action would it perform?
18:56:58 <Tekmo> You give fmap a function "f"
18:57:03 <Tekmo> that converts "a"s into "b"s
18:57:13 <Tekmo> and anywhere you find an "a" in your Nature
18:57:19 <Tekmo> you apply "f" to convert it to a "b"
18:57:30 <Tekmo> Nature only holds "a"s in one place
18:57:35 <Tekmo> which is the Rock constructor
18:57:43 <Axman6> YayMe: month or two
18:57:46 <YayMe> arch_is_awesome_: start by turning a Num into a String
18:57:47 <arch_is_awesome_> One second... phone call
18:57:55 <YayMe> Axman6: Bull, I've been at this for like 6 :(
18:57:58 <Cale> YayMe: ...
18:58:07 <Axman6> YayMe: try harder :P
18:58:31 <danharaj> I've been at Haskell for 4 years and it still takes me 20 minutes of staring to grok an edwardk module.
18:58:34 <danharaj> (Per line)
18:58:39 <Axman6> nah there's always things that will give you a headache, it's a language where the top of the abstraction tree is very high, and people keep adding shit to it
18:58:47 <arch_is_awesome_> Okay, of the phone again...
18:58:54 <arch_is_awesome_> *off
18:59:06 <YayMe> Axman6: That's what I figure..
18:59:24 <arch_is_awesome_> Tekmo: Right but say we have Rock 4... what would I have it do to the Rock?
18:59:33 <arch_is_awesome_> Add one if it's an integer?
18:59:38 <Axman6> YayMe: edwardk and Oleg have a lot to blame for this
18:59:42 <Tekmo> Your argument is of type "Nature a"
18:59:42 <Cale> arch_is_awesome_: You apply the function that you are give
18:59:43 <Cale> n
18:59:46 <Tekmo> not "Nature Int"
18:59:50 <Tekmo> So what you have is:
18:59:54 <danharaj> arch_is_awesome_: Use what you are given. fmap takes a function.
18:59:56 <Tekmo> Rock (somevalue :: a)
19:00:06 <Tekmo> All you know about the value inside Rock
19:00:08 <Tekmo> is that it has type "a"
19:00:15 <Cale> Here, I'll secretly write the instance into the bot so we can apply it and see what it would do :)
19:00:30 <danharaj> Cale: assuming direct control?
19:00:32 <Axman6> :t Rock
19:00:33 <lambdabot> forall a. a -> Nature a
19:00:37 <Axman6> heh
19:01:16 <arch_is_awesome_> Okay.
19:01:29 <Axman6> :t Bush
19:01:30 <lambdabot> forall a. Nature a -> Nature a -> Nature a
19:01:36 <Tekmo> So if I'm writing a case for fmap
19:01:38 <Cale> @let garden = Bush (Bush (Rock 1) (Stream (Rock 2))) (Stream (Stream (Bush (Rock 3) (Rock 4))))
19:01:39 <Tekmo> It would begin like
19:01:40 <lambdabot>  Defined.
19:01:46 <Tekmo> fmap f (Rock a) = ...
19:01:47 <Cale> > fmap (*10) garden
19:01:48 <lambdabot>   No instance for (GHC.Base.Functor L.Nature)
19:01:48 <lambdabot>    arising from a use of `GHC.B...
19:01:48 <Axman6> :t garden
19:01:50 <lambdabot> forall t. (Num t) => Nature t
19:01:51 <Cale> oh
19:01:53 <Cale> @undefine
19:01:54 <Tekmo> The "f" would have type "a -> b"
19:01:58 <Cale> @let garden = Bush (Bush (Rock 1) (Stream (Rock 2))) (Stream (Stream (Bush (Rock 3) (Rock 4))))
19:02:00 <lambdabot>  Defined.
19:02:01 <Tekmo> The "a" would have type "a"
19:02:02 <Cale> > fmap (*10) garden
19:02:04 <lambdabot>   Bush (Bush (Rock 10) (Stream (Rock 20))) (Stream (Stream (Bush (Rock 30) (R...
19:02:09 <YayMe> > fmap show garden
19:02:11 <lambdabot>   Bush (Bush (Rock "1") (Stream (Rock "2"))) (Stream (Stream (Bush (Rock "3")...
19:02:29 <hpaste> arch_is_awesome pasted “None” at http://hpaste.org/75789
19:02:30 <Cale> (maybe I should have picked something a little shorter)
19:02:35 <YayMe> heh
19:02:43 <arch_is_awesome_> So, at least I have this right: http://hpaste.org/75789
19:02:46 <arch_is_awesome_> (Yes?)
19:02:51 <coldpizza72i> Can someone help me with this error http://ideone.com/ymQeg
19:02:59 <Tekmo> I think it would help
19:03:02 <Tekmo> if we used the Identity functor
19:03:16 <Cale> yes
19:03:38 <Axman6> coldpizza72i: you probably want TextRope, not Rope right?
19:03:55 <arch_is_awesome_> Cale: So far it's right, yes?
19:04:00 <Cale> arch_is_awesome_: yeah
19:04:13 <arch_is_awesome_> Good, that should be the easy part....
19:04:19 <coldpizza72i> Axman6: but i want it to support SubRopes too
19:04:27 <arch_is_awesome_> Then fmap f (Nature a) =
19:04:32 <Cale> nope!
19:04:39 <arch_is_awesome_> No... fmap f x =
19:04:39 <Cale> Nature is a type constructor
19:04:46 <Cale> Rock, Stream, Bush
19:04:48 <Tekmo> Then do this
19:04:49 <Cale> are the data constructors
19:04:51 <arch_is_awesome_> Oh, yeah :)
19:04:54 <Cale> which you'll pattern match
19:04:55 <Axman6> coldpizza72i: I'm not sure I understand what you want then
19:05:03 <arch_is_awesome_> Oh! I get it now!
19:05:06 <Tekmo> data ConcatRope r = ConcatRope (Rope r) (Rope r)
19:05:19 <acyed> does anyone have any good references for learning the type system? I've read LYAHFGG and RWH, even the haskell report, but I'm still not getting defining and using classes and instances
19:05:32 <arch_is_awesome_> fmap f (Bush b)
19:05:40 <Tekmo> You could try the Gentle Introduction to Haskell
19:05:46 <Cale> arch_is_awesome_: start with Rock, and work your way up
19:05:54 <Axman6> coldpizza72i: also, if this is for that exercise you showed yesterday, you are almost certainly not going about it the right way. Rope should be a single type which has SubRope, TextRope and ConcatRope as constructors
19:05:59 <Cale> arch_is_awesome_: Bush is the trickiest case
19:06:12 <Tekmo> coldpizza721: parameterize your ConcatRope type on "r"
19:06:15 <donri> data ConcatRope = forall r. Rope r => ConcatRope r r -- ? :D
19:06:36 <arch_is_awesome_> I still don't get what I'm supposed to map to the actual object
19:06:41 <arch_is_awesome_> Like....
19:06:50 <Cale> arch_is_awesome_: you have a function f, and some Nature data structure
19:07:06 <arch_is_awesome_> fmap (*3) (Rock 9) would give 27?
19:07:09 <Cale> arch_is_awesome_: and your goal is to apply that function f to all the elements of type a in the Nature
19:07:20 <Tekmo> No
19:07:21 <Cale> It would give Rock 27
19:07:23 <Tekmo> Rock 27
19:07:23 <maukd> > fmap (* 3) (Rock 9)
19:07:26 <lambdabot>   Rock 27
19:07:28 <arch_is_awesome_> Oh, yeah. Rock 27
19:07:57 <arch_is_awesome_>  fmap f (Rock r) = Rock $ f r
19:08:03 <Cale> good :)
19:08:04 <Tekmo> Correct
19:08:12 <arch_is_awesome_> Finally. I'm slow...
19:08:23 <Tekmo> Take your time!
19:08:27 <Tekmo> There is no hurry
19:08:29 <coldpizza72i> Axman6: so is it Data Rope = TextRope |  SubRope | ConcatRope ?
19:08:54 <arch_is_awesome_> Would it be fmap f (Stream r) =
19:08:58 <Cale> sure
19:09:03 <Cale> and what type does r have there?
19:09:09 <arch_is_awesome_> fmap f (Stream (Rock r))
19:09:19 <arch_is_awesome_> Maybe...
19:09:21 <Cale> nope, just handle one constructor at a time
19:09:57 <arch_is_awesome_> fmap f (Stream r) = Stream $ fmap f r
19:09:57 <Cale> You've already taken care of Rock, so let the recursion sort out all the other Rocks that might appear
19:10:02 <Tekmo> Bingo!
19:10:03 <Cale> Indeed!
19:10:31 <arch_is_awesome_>  fmap f (Bush r) = Bush $ fmap f r
19:10:36 <Tekmo> Not quite
19:10:38 <Cale> Bush has two parameters
19:10:39 <Tekmo> That's a type error
19:10:40 <arch_is_awesome_> Oh, r and a
19:11:07 <arch_is_awesome_> fmap f (Bush r a) = Bush (fmap f r) (fmap f a)
19:11:11 <Tekmo> Right!
19:11:27 <arch_is_awesome_> Kind mis-match
19:11:29 <Tekmo> And that's it!
19:11:32 <MostAwesomeDude> Ghoul: Howdy.
19:11:37 <Cale> oh, hah, sorry, I lied, there was a problem
19:11:45 <Cale> instance Functor Nature where
19:11:47 <Cale> ^^
19:11:59 <arch_is_awesome_> IT WORKS!
19:12:00 <Cale> Nature itself, the type constructor, is what is an instance of Functor
19:12:07 <Tekmo> The awesome part
19:12:13 <Tekmo> is that once you define how to handle all three constructors
19:12:20 <Tekmo> it automatically handles every case by virtue of recursion
19:13:29 <arch_is_awesome_> *Main> fmap (*3) $ Bush (Stream (Rock 4)) (Rock 9)
19:13:36 <arch_is_awesome_> Bush (Stream (Rock 12)) (Rock 27)
19:13:54 <Tekmo> > fmap (\_ -> ()) $ Bush (Rock 4) (Rock 5)
19:13:57 <lambdabot>   Bush (Rock ()) (Rock ())
19:14:17 <Tekmo> fmap (\() -> 4) $ Rock ()
19:14:22 <Tekmo> > fmap (\() -> 4) $ Rock ()
19:14:25 <lambdabot>   Rock 4
19:14:53 <Cale> > fmap reverse $ Bush (Stream (Rock "hello")) (Rock "there")
19:14:55 <lambdabot>   Bush (Stream (Rock "olleh")) (Rock "ereht")
19:15:14 <coldpizza72i> Axman6: you still there?
19:15:51 <arch_is_awesome_> Perfect. I get it now :D
19:15:55 <Cale> arch_is_awesome_: Of course, this Nature type is a little contrived, but there are many real world data structures which look like it
19:16:15 <arch_is_awesome_> But what I don't get is the way LYAH does Either...
19:16:19 * hackagebot husk-scheme 3.5.7 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.5.7 (JustinEthier)
19:16:48 <Cale> Okay, so to understand the Functor instance for Either e, you need to look at the types carefully
19:16:58 <Cale> In general, we have
19:17:05 <hpaste> arch_is_awesome pasted “LYAH Either Functor” at http://hpaste.org/75790
19:17:10 <Cale> fmap :: (Functor f) => (a -> b) -> (f a -> f b)
19:17:16 <Cale> right?
19:17:21 <Tekmo> Right
19:17:22 <arch_is_awesome_> Yes
19:17:22 <Cale> now if f = Either e
19:17:27 <Tekmo> So what is the "f"
19:17:28 <Cale> then
19:17:43 <Cale> fmap :: (a -> b) -> (Either e a -> Either e b)
19:18:19 <Cale> So it's going to take a function from a's to b's, and an Either e a, and it needs to produce an Either e b
19:18:34 <Cale> Well, if the Either e a value that it gets is  Left x
19:18:38 <Cale> where x :: e
19:18:44 <Cale> then it can't use the function f :: a -> b
19:18:51 <arch_is_awesome_> So why is Right done differently than left?
19:18:57 <arch_is_awesome_> *Left
19:18:59 <Cale> I am explaining that :)
19:19:25 <Tekmo> I find it helps to name the variables after their types
19:19:27 <Cale> So the only thing it can do in the Left case is essentially nothing -- just result in  Left x  again
19:19:34 <Tekmo> So, the Right case would be
19:19:39 <Tekmo> Right a -> Right (f a)
19:19:46 <Cale> I want to do as much as possible to reduce confusion between types and values here
19:19:56 <Tekmo> Alright
19:20:01 <arch_is_awesome_> :D
19:20:19 <Cale> So if the value of type Either e a is  Right y where y :: a  then
19:20:34 <Cale> and it needs to produce something of type  Either e b
19:20:40 <arch_is_awesome> So in fmap :: (a -> b) -> (Either e a -> Either e b)
19:20:41 <Cale> There's only one real choice
19:20:49 <arch_is_awesome> a and b must be of type e?
19:20:55 <Tekmo> No
19:20:55 <maukd> no
19:20:58 <maukd> a and b are types
19:20:59 <Cale> nope, they're separate types
19:21:07 <Cale> e, a, and b are all types
19:21:20 <Tekmo> And you can't assume they are the same
19:21:21 <maukd> the cases are treated differently because Functor only varies the last type parameter
19:21:21 * hackagebot catch-fd 0.2.0.0 - MonadThrow and MonadCatch, using functional dependencies  http://hackage.haskell.org/package/catch-fd-0.2.0.0 (AndySonnenburg)
19:21:31 <maukd> and Either has two
19:21:39 <arch_is_awesome> Right and Left
19:21:43 <maukd> a and b
19:21:45 <Tekmo> The value inside the Left constructor
19:21:49 <maukd> well, no
19:21:50 <Tekmo> has type "e"
19:21:54 <Tekmo> You can't apply "f" to that value
19:22:00 <Tekmo> because "f" only accepts values of type "a"
19:22:08 <arch_is_awesome> Of, I see. data Either a b = Left a | Right b
19:22:14 <Cale> right :)
19:22:20 <Cale> It helps to have that in front of you
19:22:23 <maukd> data Either a b <- this is the critical part
19:22:50 <arch_is_awesome> So this fmap changes the type to Right?
19:22:54 <maukd> Functor varies the last parameter, which is called 'b' here
19:22:57 <arch_is_awesome> Now I'm really confused
19:22:58 <maukd> Right is not a type
19:23:17 <arch_is_awesome> Right :: b -> Either a b
19:23:22 <Cale> Types: e, a, b, Either e a, Either e b
19:23:25 <maukd> possibly because we have two different 'a's and 'b's here
19:23:34 <Tekmo> Yeah, it's confusing
19:23:44 <arch_is_awesome> So really it could be
19:23:46 <Cale> Values: x, y, Left x, Right y
19:23:53 <arch_is_awesome> Ah, okay
19:24:09 <Cale> (just some examples)
19:24:10 <maukd> data Either q r = Left q | Right r
19:24:18 <arch_is_awesome> Ah, okay
19:24:18 <Tekmo> Or
19:24:24 <maukd> (freshly harvested variables)
19:24:25 <Tekmo> data Either l r = Left l | Right r
19:24:38 <Ghoul> MostAwesomeDude: Woops, was afk.
19:25:12 <Tekmo> data Either behind away = Left behind | Right away
19:25:14 <Cale> heh
19:25:21 <Cale> let's go with l and r
19:25:26 <arch_is_awesome> Yes...
19:25:40 <Cale> So we have  fmap :: (r -> r') -> Either l r -> Either l r'
19:25:54 <Cale> r' is another variable :)
19:26:09 <Cale> Do you see now why it handles the right case differently? :)
19:26:10 <arch_is_awesome> And now I get it
19:26:11 <maukd> fmap :: (r1 -> r2) -> Either l r1 -> Either l r2
19:26:27 <arch_is_awesome> So r' is the modified r
19:26:31 <Ghoul> :t put
19:26:33 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
19:26:36 <Tekmo> Right
19:26:37 <Cale> yeah, at the type level
19:26:44 <maukd> > let r₁ = r₂; r₂ = "d2" in r₁
19:26:46 <lambdabot>   <no location info>: lexical error at character '\8321'
19:26:47 <Cale> It's the type of the modified r
19:26:54 <Ghoul> Can someone explain what 'put' does here
19:26:55 <Ghoul> https://github.com/MostAwesomeDude/baskerville/blob/master/Baskerville/Beta/Packets.hs#L278
19:26:57 <Cale> > fmap show (Left 6)
19:26:59 <lambdabot>   Left 6
19:27:01 <Cale> > fmap show (Right 6)
19:27:03 <lambdabot>   Right "6"
19:27:11 <Tekmo> That's a different put
19:27:17 <Cale> The type can be changed by the function we apply
19:27:21 <Tekmo> It's a method of the Serialize class
19:27:38 <Tekmo> It takes any type that implements the Serialize class and serializes it
19:27:44 <Cale> > fmap length (Bush (Rock "hello") (Rock "lengths"))
19:27:46 <lambdabot>   Bush (Rock 5) (Rock 7)
19:28:19 <Cale> So here, we're using  fmap :: (String -> Int) -> (Nature String -> Nature Int)
19:28:43 <arch_is_awesome> Ah.
19:28:52 <arch_is_awesome> Yes.
19:30:15 <maukd> > fmap (fmap length) [Left 1, Right "two", Left 42, Left 0, Right ""]
19:30:16 <lambdabot>   [Left 1,Right 3,Left 42,Left 0,Right 0]
19:31:16 <arch_is_awesome> fmap length  [Left 1, Right "two", Left 42, Left 0, Right ""]
19:31:31 <arch_is_awesome> lambdabot hates me...
19:31:37 <Tekmo> Put a ">" before it
19:31:44 <maukd> did you mean: "> "
19:31:47 <Tekmo> Yes
19:32:16 <Cale> that will be a type error though, because length will want a list, but will be getting Either values
19:32:49 <arch_is_awesome> Ah.
19:33:03 <arch_is_awesome> I seriously seem to be lacking in the brain dept. tonight...
19:33:10 <Cale> Oh, that other thing maukd wrote probably would have been a type error anyway
19:33:18 <Cale> but apparently there's some IsString instance about
19:33:24 <Cale> err
19:33:37 <Cale> or Num for String?
19:33:46 <Tekmo> He used two fmaps
19:33:47 <maukd> Cale: ?
19:33:47 <Cale> oh, no, lol
19:33:53 <Cale> I misread
19:33:54 <arch_is_awesome> Okay. So in http://hpaste.org/75790 a is Right or Left?
19:34:05 <Cale> I thought there were more Rights than there were :)
19:34:08 <arch_is_awesome> Yes?
19:34:17 <maukd> arch_is_awesome: no
19:34:26 <maukd> arch_is_awesome: a is a type
19:34:27 <Tekmo> Just change the "a" to "l" to be consistent with Cale's naming convention
19:34:34 <arch_is_awesome> Like Int
19:34:39 <Cale> arch_is_awesome: right
19:34:54 <Cale> arch_is_awesome: right, it's like Int, not like Right ;)
19:35:12 <Cale> Right and Left are not types, but values
19:35:22 <Cale> they live in the world on the left of ::
19:35:35 <Cale> Either and Int and String are type constructors
19:35:41 <Cale> and live on the right of ::
19:36:12 <maukd> 0, 1, 2, 3, ... are to Int as Left/Right are to Either
19:36:15 <maukd> if you squint hard
19:36:30 <Tekmo> It would be more correct to say "The type variable corresponding to the Right constructor"
19:36:41 <Tekmo> Or
19:36:44 <Tekmo> perhaps a better way to say
19:36:45 <Tekmo> would be
19:36:47 <arch_is_awesome> Okay. So Either a is saying...
19:36:54 <arch_is_awesome> Either Int for example?
19:36:54 <Tekmo> "The type variable associated with the Right constructor"
19:36:58 <Cale> yes
19:37:12 <maukd> there's an implicit universal quantification
19:37:15 <Cale> It's saying that for any type a, the type constructor Either a is a Functor
19:37:30 <arch_is_awesome> Then on line 2 Right x is like Right Int?
19:37:37 <Axman6> coldpizza72i: what you pasted to me was close, but missing some things
19:37:46 <Cale> which means that for any types b and c, and given any function b -> c, we can get a function Either a b -> Either a c
19:37:48 <nexion> hey guys, is there a library to load an image into a pixel matrix?
19:37:56 <Cale> arch_is_awesome: x is a value
19:38:01 <Cale> Int isn't a value
19:38:04 <Cale> Int is a type
19:38:04 <coldpizza72i> Axman6: what about … data Rope = TextRope String | SubRope TextRope Integer Integer | ConcatRope Rope Rope
19:38:09 <arch_is_awesome> So something like Right 4
19:38:12 <Cale> yes
19:38:18 <parcs`> nexion: there's stb-image and JuicyPixels
19:38:22 <Tekmo> :t Right (4 :: Int)
19:38:24 <lambdabot> forall a. Either a Int
19:38:32 <arch_is_awesome> So...
19:38:40 <arch_is_awesome> With fmap f (Right x) = Right (f x)
19:38:46 <maukd> :t Left 'x'
19:38:47 <lambdabot> forall b. Either Char b
19:38:53 <arch_is_awesome> And the example of 4
19:38:58 <arch_is_awesome> Function 12
19:39:08 <Cale> 12 is a weird function :)
19:39:09 <arch_is_awesome> You would end up with Right 12
19:39:13 <Cale> but yeah
19:39:23 <Cale> If you mean the constant function which always produces 12
19:39:30 <arch_is_awesome> Er...
19:39:37 <Tekmo> arch
19:39:38 <maukd> > fmap (\_ -> 12) (Right 4)
19:39:39 <lambdabot>   Right 12
19:39:49 <Tekmo> When defining a function, just focus on the type of the function
19:39:52 <jfischoff> is there any way to get a 64 bit version of ghc to build 32 bit shared libraries on osx?
19:39:54 <Tekmo> Not the type of the class that it is in
19:39:57 <arch_is_awesome> fmap f (Right x) = Right (f x) with (*3) as the function (f) and 4 as x would give 12?
19:40:02 <Cale> Lambdabot has a function instance for Num, so you can actually write fmap 12 (Right 4), and have it work
19:40:08 <maukd> > fmap (3 *) (Right 4)
19:40:09 <lambdabot>   Right 12
19:40:16 <arch_is_awesome> Yes...
19:40:19 <maukd> > fmap (3 *) (Left 4)
19:40:20 <lambdabot>   Left 4
19:40:24 <nexion> parcs`, thanks :)
19:40:25 <Axman6> arch_is_awesome: looks good :)
19:40:30 <arch_is_awesome> So left...
19:40:39 <maukd> > fmap (3 *) (Left "this isn't even a number")
19:40:39 <arch_is_awesome> fmap f (Left x) = Left x
19:40:40 <lambdabot>   Left "this isn't even a number"
19:40:55 <arch_is_awesome> > fmap (3*) (Left 4)
19:40:56 <lambdabot>   Left 4
19:41:04 <Tekmo> arch, just think about the types for a second
19:41:04 <Cale> maukd: how'd your name get decremented anyway?
19:41:05 <arch_is_awesome> It doesn't perform it on Left
19:41:08 <Tekmo> The type of fmap is:
19:41:13 <maukd> Cale: hardware failure
19:41:21 <Tekmo> fmap :: (r -> r') -> Either l r -> Either l r'
19:41:23 <Axman6> arch_is_awesome: to understand why, you need to look at the types carefully
19:41:28 <Tekmo> Then you are given a Left
19:41:31 <Tekmo> That Left has the type
19:41:38 <Tekmo> SOrry, that Left x has the type
19:41:40 <Axman6> @src Either
19:41:41 <lambdabot> Source not found. You type like i drive.
19:41:41 <Tekmo> Left x :: Either l r
19:41:46 <Tekmo> Which means that
19:41:47 <Axman6> :|
19:41:48 <Tekmo> x has the type
19:41:50 <Tekmo> x :: l
19:41:58 <Tekmo> The function you are mapping has the type
19:42:00 <Tekmo> f :: r' -> r
19:42:05 <Tekmo> So you can't use it on x
19:42:11 <Tekmo> But, fortunately you don't have to
19:42:15 <Cale> f :: r -> r'  actually
19:42:16 <arch_is_awesome> Oh! I see.
19:42:17 <Tekmo> because the result you must produce
19:42:19 <Tekmo> has type
19:42:22 <Tekmo> Either l r'
19:42:28 <maukd> it would be the other way around if Either was defined like this: data Either r l = Left l | Right r
19:42:30 <Tekmo> So you can just rewrap the value you were given
19:42:35 <Tekmo> and it will satisfy that result
19:42:39 <Tekmo> Left x :: Either l r'
19:42:46 <arch_is_awesome> So why not allow usage on left?
19:42:55 <maukd> arch_is_awesome: how?
19:42:55 <Cale> arch_is_awesome: You would need two functions then
19:42:55 <Tekmo> allow usage of what?
19:42:59 <Cale> You can write a function
19:43:09 <Tekmo> You mean something like:
19:43:10 <arch_is_awesome> lfmap?
19:43:17 <Cale> bimap :: (l -> l') -> (r -> r') -> Either l r -> Either l' r'
19:43:18 <maukd> :t either
19:43:19 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:43:35 <Tekmo> fmapL :: (l -> l') -> Either l r -> Either l' r
19:43:37 <Tekmo> You mean that?
19:43:45 <arch_is_awesome> Something like that
19:43:47 <Tekmo> You sure can
19:43:49 <maukd> :t \f g -> either (Left . f) (Right . g)
19:43:51 <lambdabot> forall a b a1 b1. (a1 -> a) -> (b1 -> b) -> Either a1 b1 -> Either a b
19:43:59 <Tekmo> But you can't make it an instance of the Functor class
19:44:02 <Cale> arch_is_awesome: You can write those things, but they don't quite satisfy the interface for Functor
19:44:04 <Tekmo> just because of the way the class is set up
19:44:04 <Ghoul> Tekmo: heh, I cant find the documentation on "put"
19:44:11 <Ghoul> I can only find putWord8, etc
19:44:12 <maukd> @pl \f g -> either (Left . f) (Right . g)
19:44:13 <lambdabot> (. (Right .)) . either . (Left .)
19:44:25 <Tekmo> Ghoul: Let me help you.  I'll find a link
19:44:35 <Cale> They'd actually otherwise provide absolutely fine functor instances, in terms of the laws that it has to satisfy
19:44:54 <Tekmo> Ghoul: The definition is here: http://hackage.haskell.org/packages/archive/cereal/0.3.5.2/doc/html/Data-Serialize.html#v:put
19:45:03 <Tekmo> Ghoul: The documentation is sparse, but I can explain how to use it
19:45:15 <JoeyA> Just curious, if you have a top-level interleaved action: foo = unsafePerformIO getSomething  {-# NOINLINE foo #-} , is it guaranteed to not be evaluated until foo is forced?
19:45:17 <Ghoul> Oh thanks
19:45:21 <Cale> arch_is_awesome: In case nobody has mentioned the laws for Functor, the fmap you give is supposed to satisfy the equations that:
19:45:24 <Cale> fmap id = id
19:45:33 <Ghoul> Tekmo: It's cool, theres great usage of it here
19:45:34 <Ghoul> :)
19:45:35 <Cale> fmap (f . g) = (fmap f) . (fmap g)
19:45:50 <Tekmo> Ghoul: Alright.  Good luck!  If you have any more questions, then feel free to ask
19:45:59 <Cale> or to write those another way:
19:46:05 <Cale> fmap id x = x
19:46:15 <Cale> fmap (f . g) x = fmap f (fmap g x)
19:46:28 <Tekmo> There's a reason we have these laws
19:46:31 <arch_is_awesome> Okay. I think I get it but one last thing....
19:46:47 <arch_is_awesome> Why is instance Functor (Either a) where necessary instead of instance Functor Either where
19:46:57 <arch_is_awesome> Because it's Either a b?
19:46:57 <danharaj> :k Either
19:46:59 <lambdabot> * -> * -> *
19:47:00 <Cale> arch_is_awesome: Basically, what these say is that fmap doesn't touch the surrounding structure of the data, only applies the function to all the elements
19:47:02 <Tekmo> Think about what that would do to the type of fmap
19:47:06 <Tekmo> if you set the "f" to Either
19:47:08 <Cale> arch_is_awesome: yeah
19:47:09 <Tekmo> the signature would read
19:47:21 <Tekmo> fmap :: (r -> r') -> Either r -> Either r'
19:47:24 <Cale> arch_is_awesome: Instances of Functor need to take exactly one type parameter
19:47:25 <arch_is_awesome> So basically it's saying "Forget a"
19:47:27 <Tekmo> But "Either r" is not a valid type
19:47:30 <Tekmo> nor is "Either r'"
19:47:55 <Tekmo> The important part about a type class
19:47:58 <arch_is_awesome> Because that's not what functor wants?
19:48:16 <Cale> arch_is_awesome: Okay, so just like values have types, types have kinds
19:48:18 <Tekmo> Whatever you put in that top part
19:48:24 <Tekmo> the type class substitutes that for "f"
19:48:24 <Ghoul> Tekmo: :)
19:48:29 <jude> how do i fix ambiguous occurance show in http://ideone.com/wZn9Y
19:48:37 <shapr> SHAZAM!
19:48:37 <Cale> arch_is_awesome: There is a kind called * which has all the types with actual values in them
19:49:19 <arch_is_awesome> Ah.
19:49:22 <arch_is_awesome> Thank you.
19:49:22 <Cale> arch_is_awesome: and then whenever k1 and k2 are kinds, there is a kind k1 -> k2, which is the kind of type constructors which take a parameter of kind k1, and produce a resulting type-level thingy of kind k2
19:49:34 <maukd> :k Int
19:49:35 <lambdabot> *
19:49:41 <Cale> Every instance of Functor needs to have kind * -> *
19:49:42 <maukd> :k Int Char
19:49:43 <lambdabot>     `Int' is applied to too many type arguments
19:49:43 <lambdabot>     In the type `Int Char'
19:49:44 <Tekmo> jude: Indent the show definition
19:49:54 <jfischoff> :k Monad
19:49:56 <lambdabot>     Class `Monad' used as a type
19:49:56 <lambdabot>     In the type `Monad'
19:49:59 <Cale> Either has kind * -> (* -> *)
19:50:01 <jfischoff> :p
19:50:11 <Tekmo> jude: When you begin the definition at the first column, the compiler misconstrues it as a top-level new definition for "show", rather than the definition for your "Show" instance
19:50:12 <Cale> and so for any l, we have  Either l :: * -> *
19:50:18 <cmccann> :k ReaderT
19:50:20 <lambdabot> * -> (* -> *) -> * -> *
19:50:25 <Cale> which is the right kind for Functor :)
19:50:41 <Tekmo> Or you can just remember
19:50:46 <Tekmo> that "Either r" does not make sense
19:50:51 <arch_is_awesome> Oh, I think I completely get it now...
19:51:13 <danharaj> `Either r` makes perfect sense I don't see why we have to lie about that.
19:51:22 <Tekmo> Ok, I will rephrase that
19:51:26 <Tekmo> "Either r" is not a valid type
19:51:36 <cmccann> it's a valid type. just not of kind *.
19:51:39 <Cale> hahaha
19:51:43 <Tekmo> Type constructor!
19:51:47 <Cale> OUR TERMINOLOGY SUCKS
19:51:51 <arch_is_awesome> :D
19:51:57 <danharaj> Might as well swallow the kind pill early on.
19:52:00 * Axman6 finds that a confusing thing to tell someone when we do use (Either r) in the instance declaration of Functor for Either 
19:52:22 <Cale> arch_is_awesome: There's an interesting shift in terminology going on now that extensions are making the kind level more interesting
19:52:36 <arch_is_awesome> I see...
19:52:45 <Axman6> as for "What are kinds?", you can ignore them
19:52:55 <Axman6> except in their most basic form
19:52:59 <Cale> Axman6: Well, I just explained what kinds were
19:53:03 <arch_is_awesome> I think I might be able to get thorough Chapter 7 now...
19:53:05 <Tekmo> At least until you get a kind error from GHC
19:53:06 <Cale> in Haskell 98 anyway :)
19:53:12 <Axman6> like Either has kind * -> * -> *, because it takes two type arguments to form a type
19:53:19 <Cale> yeah
19:53:25 <jude> so if i add two spaces it should fix it? It appers to not change? http://ideone.com/1meRk
19:53:33 <danharaj> the kind extensions in the latest ghc make me a bit uneasy.
19:53:41 <Cale> danharaj: Why is that?
19:53:45 <Tekmo> jude: Correct.  That should fix it
19:53:52 <danharaj> The syntax doesn't sit well with me for, e.g. datakinds.
19:53:56 <Tekmo> Oh
19:53:58 <Cale> oh, yeah
19:53:59 <Tekmo> jude: Your new problem
19:54:11 <Cale> The optional quoting thing is a bit out of character
19:54:14 <danharaj> I feel like if Haskell were designed from the ground up with kinds in mind, it would be cleaner.
19:54:14 <Tekmo> jude: Is that 'show' is not a method of Show
19:54:15 <monochrom> eh? why are you not importing Show and Int and String?
19:54:23 <Tekmo> jude: Define 'shows' or 'showsPrec'
19:54:29 * cmccann also complains about the syntax of comments while we're at it
19:54:47 <maukd> one line comments should nest
19:54:52 <cmccann> hahahaha
19:55:03 <Tekmo> What kind of comments do you guys write?
19:55:13 <arch_is_awesome> I need to go to bed. Thank you all!
19:55:14 <danharaj> Will we get extensions for programming at the comment level soon?
19:55:16 <maukd> sarcastic ones
19:55:19 <Cale> maukd: what to you mean by that?
19:55:29 <Tekmo> Next thing you know
19:55:30 <maukd> danharaj: {-# ... #-}
19:55:32 <Axman6> scumbag Gimp: claims to be a native OS X app, puts up an opening pane that can;t be moved and always sits on top
19:55:38 <danharaj> maukd: touche
19:55:43 <Cale> {-# RULES ... #-}
19:55:46 <Tekmo> maukd will be complaining that comments are limited to 203290348290458 characters
19:55:47 <Cale> in particular
19:56:06 <maukd> Cale: start = "--", end = "\n"
19:56:14 <jude> so do i just change show to shows? like http://ideone.com/dv8IJ
19:56:30 <cbts> does anyone have any idea why when I "cabal install cabal-install" then "cabal update" it still says I need to cabal install again? (OSX)
19:56:35 <monochrom> no, you have to import Show and Int and String, and you don't need shows
19:56:58 <Cale> jude: is there a reason you're explicitly importing Prelude?
19:56:58 <monochrom> but since I am invisible, I call it a night
19:57:23 <Cale> monochrom: Maybe you should choose a more colourful nick
19:57:28 <Axman6> cbts: you probably need to cvhange your path to point to where cabal-install is now installed
19:57:37 <jude> @cale i thought i was to get the show ability
19:57:37 <lambdabot> Unknown command, try @list
19:57:56 <Cale> jude: If you leave off the explicit import, everything from the Prelude is imported by default
19:58:19 <arch_is_awesome> @version
19:58:20 <lambdabot> lambdabot 4.2.2.1
19:58:20 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:58:26 <jude> thanks cale
19:58:31 <monochrom> I should become infrared or ultraviolet
19:58:38 <arch_is_awesome> Thanks, Cale !
19:58:45 <arch_is_awesome> I will be going now
19:58:46 <Tekmo> jude: Try "showsPrec _ (... contents ...) = shows contents
19:58:48 <Cale> arch_is_awesome: no problem
19:58:49 <monochrom> thanks Cale
19:58:54 <Axman6> jude: "import Prelude (show)" says "I only want to import the function show from the prelude, nothing else"
19:59:00 <Cale> monochrom: :D
19:59:28 <Tekmo> Oh wow, I didn't catch that
19:59:45 <cmccann> thanking Cale is the new Haskell-user secret handshake
20:00:46 <Axman6> you've got to write a monad tutorial to get into the club first though
20:01:20 <jude> so if I add Main.show is that closer? http://ideone.com/lcAsO
20:01:37 <monochrom> no, that's further
20:01:46 <Tekmo> Don't qualify it
20:01:50 <Tekmo> just "show"
20:01:56 <jude> with qoutes?
20:02:01 <Cale> without
20:02:02 <Tekmo> Right, without quotes
20:02:12 <Tekmo> You want it to use the Prelude's show
20:02:13 <monochrom> it is show or Prelude.show
20:02:26 <Cale> jude: It will know which show to use based on the type
20:03:11 <Tekmo> Same show function, different instance
20:03:24 <monochrom> the point is "who coined the name" rather than "who wrote the implementation". Prelude coined the name.
20:03:36 <coldpizza72i> Axman6: should i use data Rope = TextRope String | SubRope TextRope Integer Integer | ConcatRope Rope Rope  ?
20:03:43 <cmccann> Tekmo: oh btw, I got disconnected last night when I was leaving anyway so I might've missed stuff, but I'll just assume everything I was rambling about made perfect sense and that no further clarification was needed
20:03:49 <Axman6> coldpizza72i: yes
20:03:53 <Tekmo> Everything made sense
20:04:16 <jude> So how do i dis ambiguify it with Prelude? http://ideone.com/z2B5q
20:04:23 <Tekmo> You don't
20:04:23 <cmccann> ok, making sense is good
20:04:43 <monochrom> there is no ambiguity
20:04:43 <cbts> Axman6: thanks, moved some stuff around and fixed it.
20:04:54 <Tekmo> jude: The idea behind type classes
20:05:05 <Tekmo> jude: is that the show function is selected based on the type alone
20:05:13 <maukd> @src show
20:05:13 <lambdabot> show x = shows x ""
20:05:24 <maukd> there is only one show and Prelude is its prophet
20:05:45 <Cale> jude: One way to think of it is that you're extending the Prelude's show with an implementation for your type, not defining an entirely new separate function.
20:05:45 <coldpizza72i> Axman then how do i define like sizeOf… instance sizeOf Rope where ?
20:05:46 <Tekmo> So when you define a class like "Show" with a method called "show"
20:06:05 <Tekmo> When you define a class, you bring just one name into scope
20:06:13 <Tekmo> "show" in this case
20:06:18 <Tekmo> Everybody uses that show function
20:06:25 <Tekmo> there aren't multiple show functions
20:06:26 <Tekmo> just one
20:06:38 <Tekmo> There are multiple INSTANCES of it
20:06:42 <Tekmo> but they all share the same name
20:06:54 <Tekmo> and there is no name resolution conflict
20:06:58 <zzing> :t ($!)
20:06:59 <lambdabot> forall a b. (a -> b) -> a -> b
20:07:14 <Tekmo> For example
20:07:16 <Tekmo> When you add numbers
20:07:24 <Tekmo> (+)
20:07:27 <jude> now its telling me that Main is undefined? do i need a main? http://ideone.com/LY4dZ
20:07:29 <coldpizza72i> Axman6: you there
20:07:48 <maukd> Tekmo: there aren't multiple instances of show
20:07:48 <monochrom> you don't need a main. it's just ideone.
20:08:01 <maukd> Tekmo: and the enter key isn't punctuation
20:08:06 <Tekmo> Sorry, multiple instances of "Show"
20:08:12 <zzing> Is that ($!) the same $! used here: ov f = getLast $! (mappend `on` (Last . f)) a b    (from http://hackage.haskell.org/packages/archive/snap-server/0.9.2.3/doc/html/src/Snap-Internal-Http-Server-Config.html#Config )   It is in an mappend implementation for partially constructing configurations.
20:08:20 <Tekmo> maukd: Says the guy who just split his sentence over two lines
20:08:41 <Cale> zzing: Most likely, yes
20:08:44 <maukd> Tekmo: they were two separate sentences
20:08:52 <monochrom> how about me saying it? the enter key isn't punctuation. thank you very much.
20:08:56 <zzing> Trying to figure out what the heck that does
20:08:56 <maukd> and yes, I like to start sentences with "and"
20:09:05 <Tekmo> It's the style that's most natural for me
20:09:12 <Cale> zzing: note that the type of $! doesn't reveal its entire meaning, because it's like $ only strict
20:09:13 <zzing> maukd, "And yes, …" :p
20:09:18 <Cale> @src ($!)
20:09:18 <lambdabot> f $! x = x `seq` f x
20:09:30 <zzing> oh ok
20:09:43 <jude> thanks soo much tekmo, cale, ... it works in ghci!
20:09:45 <zzing> So I can treat it as $ for purposes of understanding?
20:09:53 <Tekmo> Yes
20:10:05 <Cale> zzing: yes, unless you want to finely understand the performance characteristics of the thing
20:10:20 <zzing> Now the function getLast is supposed to be getLast :: Maybe a    so how can it take an parameters?
20:10:36 <Tekmo> :t getLast
20:10:37 <lambdabot> forall a. Last a -> Maybe a
20:10:49 <maukd> @src Last
20:10:50 <zzing> This would disagree: file:///Library/Frameworks/GHC.framework/Versions/7.4.1-i386/usr/share/doc/ghc/html/libraries/base-4.5.0.0/Data-Monoid.html
20:10:50 <lambdabot> Source not found. I've seen penguins that can type better than that.
20:11:00 <maukd> zzing: you're reading it wrong
20:11:06 <zzing> Of that I have no doubt
20:11:07 <Tekmo> When you define it like that
20:11:08 <Cale> zzing: The field names of records are automatically functions for extracting fields of the given types
20:11:23 <Tekmo> It's confusing notation, I know
20:11:27 <Cale> zzing: So when you write   data Employee = Empl { name :: String, salary :: Integer }
20:11:38 <Tekmo> That definition does not mean that getLast has that type
20:11:39 <zzing> name :: Employee -> String
20:11:40 <Cale> zzing: This defines functions  name :: Employee -> String
20:11:43 <Cale> yeah
20:11:46 <maukd> @src Identity
20:11:46 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
20:11:52 <maukd> :t runIdentity
20:11:53 <lambdabot> forall a. Identity a -> a
20:12:11 <Cale> zzing: So people use that record syntax just to handily define the function sometimes.
20:12:33 <Tekmo> It's just an unfortunate choice of syntax
20:12:43 <Cale> Well...
20:13:07 <Cale> Ideally, they would define lenses or something, but that would still give them different types than the ones you'd want to list.
20:13:11 <zzing> Is there anything written that can help me understand how this partial configuration monoid works? I really want to use it because it fits my problem so well, but I am afraid that its meaning avoids me.
20:13:23 <Tekmo> partial configuration?
20:13:34 <zzing> http://hackage.haskell.org/packages/archive/snap-server/0.9.2.3/doc/html/src/Snap-Internal-Http-Server-Config.html#Config
20:13:34 <Tekmo> Oh, you mean Last
20:13:44 <Tekmo> One thing
20:13:51 <Tekmo> I just want to caution you about the use of partial configurations
20:13:53 <Cale> zzing: Basically, the idea is that your configuration is a bunch of optionally provided values
20:13:55 <Tekmo> Usually there is a better solution
20:13:58 <Cale> that's the "partial" bit
20:14:08 <Tekmo> For example, if I have a type that has some field, which I will name "someField"
20:14:16 <Tekmo> which I want to be optional
20:14:27 <zzing> ok, I should probably describe my problem then before I assume this is the best solution.
20:14:28 <Tekmo> I will instead parametrize the type on that field
20:14:43 <Cale> and you can combine any two partial configurations by having any provided detail override the absence of one, or if both are provided, select the later
20:14:43 <Tekmo> data SomeContrivedType field = Contrived Type1 Type2 field
20:14:53 <Tekmo> Then if I want to get rid of the field
20:14:58 <Tekmo> I set the type variable "field" to ()
20:15:04 <Tekmo> but if I want to store an "Int" in it
20:15:10 <Tekmo> I set the type variable "field" to Int
20:15:42 <Tekmo> The advantage of this is that the type reflects the status of that field
20:15:52 <Tekmo> and allows you to easily extend or shrink the field as necessary
20:16:14 <Cale> Tekmo: you seem to be describing something different.
20:16:23 <Cale> Tekmo: did you look at the source link?
20:16:26 <zzing> I have a type Document that has the pieces of a webpage (title, author, content, etc.). I am reading in a file that has a series of fields: "Title:  …"  "Author: …"   and after the headings it contains the content. I cannot guarantee an order to the headings, so I wanted to put them together in whatever order - so I though monoid.
20:16:52 <Cale> oh, or you just don't like the way that code works?
20:17:32 <Cale> zzing: Oh, you may very well have a document monoid
20:17:55 <Cale> zzing: It's only tangentially related, but have you seen the design of prettyprinting libraries?
20:18:03 <zzing> no
20:18:29 <Cale> http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
20:18:29 <Tekmo> Do all the fields have the same type?
20:18:41 <Tekmo> I can't click the link at the moment because my mouse isn't working
20:19:08 <Cale> Tekmo: they all have Maybe types
20:19:16 <Tekmo> I mean
20:19:19 <Tekmo> the content of the Maybes
20:19:36 <Cale> no, they're mostly different
20:20:03 <Tekmo> Is there any reason you need to store the result in the same type throughout the parsing process?
20:20:14 <zzing> Tekmo, they are all Text. Oh one thing I should mention — I want all of the fields specified. Partial only refers to progressive building.
20:20:38 <Cale> (oh, you're talking about zzing's type)
20:20:51 <Tekmo> I'll describe a simple example of what I have in mind
20:21:01 <Tekmo> So let's assume you had just two fields that you want to parse, but in an unspecified order
20:21:04 <zzing> ok, I am trying not to be distracted :P
20:21:38 <cbts> does anyone know if you can view the files of the packages you install through cabal install and where they might be on OSX?
20:21:50 <Tekmo> What I do in that particular situation is just tuples to store temporary intermediate values until I have the full type assembled
20:22:08 <Tekmo> So for example, if I encounter the first value, I just store it as itself until I have the second value in hand
20:22:25 <Tekmo> On the other hand, if I encounter the second value first, then I just store it as itself until I have the other value in hand
20:22:34 <Tekmo> Once I have both, I assemble the full type
20:22:47 <Tekmo> There is no reason to prematurely assemble the type before you have all the values
20:23:36 <zzing> CAle, that pretty printer is describing a monoid isn't it?
20:24:42 <luite> cbts: depends on whether you installed ghc or haskell platform, ghc has them in ~/.cabal, haskell platform somewhere in ~/Library
20:25:23 <zzing> Tekmo, I am not sure about your solution. I am dealing with 5 things right now that could easily balloon into a few more. How do you keep the tuples in order?
20:25:57 <cbts> luite: thanks found it in ~/Library
20:26:41 <Tekmo> zzing: I have no idea, short of writing 120 parsing paths :)
20:26:54 <zzing> A monoid it is then
20:28:26 <rwbarton> I've never used it myself but there's http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Perm.html
20:28:41 <cmccann> it's a little scary.
20:30:24 <acyed> can someone show me how to make an instance of Show for data Fart a = Toot a | Poot a?
20:31:40 <johnw> zzing: what are you doing?
20:32:17 <zzing> johnw, I am constructing a document from fields that are not in any particular order. It can be compared to a configuration file
20:32:34 <johnw> ah
20:33:33 <johnw> anything I can help you with?
20:34:14 <zzing> johnw, well, I am trying to figure out how this works: ov f = getLast $! (mappend `on` (Last . f)) a b  from   http://hackage.haskell.org/packages/archive/snap-server/0.9.2.3/doc/html/src/Snap-Internal-Http-Server-Config.html#Config
20:34:21 <zzing> This just happens to be the model I am going by
20:34:50 <johnw> what do you mean "how it works"?
20:34:57 <johnw> do you not understand what's happening in the expression?
20:35:03 <rwbarton> getLast $! ...? how odd, isn't getLast a newtype deconstructor?
20:35:19 <johnw> it is
20:35:26 <johnw> it undoes the Last in Last .f
20:35:27 <zzing> johnw, I do not really no
20:35:41 <rwbarton> so the ! is quite irrelevant then
20:35:43 <johnw> zzing: ok, where do a b come from?
20:35:58 <zzing> a <> b
20:36:12 <johnw> I mean, how does this function definition have access to a b?
20:36:15 <johnw> how are they in lexical scope?
20:36:20 <zzing> a where clause
20:36:25 <johnw> ah
20:36:43 <johnw> so, it's basically doing this: getLast $ Last (f a) <> Last (f b)
20:37:01 <johnw> if f b is non-Nothing, the final value is f b
20:37:04 <johnw> otherwise, it's f a
20:37:29 <johnw> that's how the Last Monoid works
20:37:47 <Tekmo> It takes the Last value
20:37:49 <zzing> I really don't know, I have never even heard of the last monoid before today :P
20:37:58 <johnw> in non-Monoid form: let x = f b in if isJust x then x else f a
20:38:10 <Tekmo> > mconcat [Last 1, Last 2, Last 3]
20:38:12 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
20:38:12 <lambdabot>    arising from a use of...
20:38:20 <cmccann> rwbarton, might as well put some strictness annotations on the newtype itself as well, right
20:38:20 <johnw> there are lots of really nice Monoids for working with Maybe values
20:38:22 <Tekmo> Ohyeah
20:38:24 <johnw> Last, First, Any, All
20:38:36 <cmccann> (note: GHC doesn't actually let you do that because it would be silly)
20:38:36 <zzing> Any place I can read about them?
20:38:43 <johnw> zzing: LYAH has a great chapter on them
20:38:51 <johnw> with some nice examples of using Any and All
20:38:59 <rwbarton> unbox the newtype for extra speeeeeeeed
20:39:20 <newsham> avoid the monoid
20:39:25 <cmccann> yes, unboxed newtypes, this is a very important optimization
20:39:49 <zzing> johnw, the chapter on monoids in general I assume?
20:39:53 <johnw> yes
20:39:57 <johnw> search the text for "getAny"
20:40:00 <zzing> I will read up on it
20:40:01 <johnw> the discussion starts around there
20:40:02 <YayMe> does LYAH get updated with newer version of GHC?
20:40:07 <johnw> that's where I learned this stuff :)
20:40:21 <johnw> YayMe: I have no idea
20:40:30 <zzing> newsham, monoids are good for you though
20:40:33 <johnw> there are lots of things LYAH doesn't talk abuot
20:47:04 <zzing> johnw, that is what typeclassopedia is for!
20:47:27 <YayMe> typeclassopedia?
20:48:35 <rwbarton> @where typeclassopedia
20:48:35 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
20:49:27 <YayMe> whoa, cool, I should totally read that
20:49:44 <YayMe> maybe up to category anyway
20:49:53 <YayMe> and not including
20:50:04 <Tekmo> I'm just warning you
20:50:08 <Tekmo> This is a very deep rabbit hole
20:50:19 <zzing> But it is a revealing one
20:50:25 <YayMe> Tekmo: dude.. haskell is a very deep rabbit hole
20:50:30 <Tekmo> Yes
20:50:42 <YayMe> At this point more rabbit holes are my only hope of getting out of this one :|
20:51:23 <copumpkin> YayMe: I got sucked in at the end of 2008 and I still haven't found the bottom
20:51:39 <KirinDave> If I have an alternative instance of a typeclass that overlaps with a more general one, how do I make that compile and prefer my instance?
20:51:42 <YayMe> That's why I stop at category?
20:51:42 <copumpkin> now I live under a bridge
20:51:43 <hpaste> Acyed pasted “Instance of Show” at http://hpaste.org/75791
20:51:49 <fryguybob> copumpkin: bottom = bottom
20:51:49 <KirinDave> Strictly speaking my instance is more specific.
20:52:00 <KirinDave> I've just never done this before, not sure what the syntax/extension I need is.
20:52:09 <copumpkin> KirinDave: if you really want, use OverlappingInstances, but it's not recommended
20:52:19 <acyed> I just want to simply define a type that can be shown and I can't figure it out
20:52:26 <KirinDave> copumpkin: Is there a better way to do it then? A newtype perhaps?
20:52:30 <applicative> copumpkin, same here. it was a little later.  nice bridge though.
20:52:41 <YayMe> copumpkin: spraypainting the kleisli triple on the sides of cargo trains? A rough life..
20:52:45 <copumpkin> KirinDave: possibly, depends on what you're doing
20:52:46 <Tekmo> KirinDave: Using a newtype is no better than just defining a custom function
20:52:47 <KirinDave> copumpkin: The monoid instance for Data.Map is … an unfortunate choice.
20:53:09 <copumpkin> YayMe: yeah, but someone's gotta do it
20:53:09 <copumpkin> Tekmo: it kind of is
20:53:25 <jfischoff> Got "Symbol not found: _stg_MUT_ARR_PTRS_DIRTY_info" when trying to load a shared library built with ghc. Any ideas?
20:53:51 <KirinDave> Tekmo: I want to make a smarter instance of Monoid for Data.Map for (Monoid v) => Map k v
20:54:05 <applicative> acyed: It looks like you need to indent the line that defines show?  line 4.  The constraint seems odd
20:54:07 <KirinDave> Where instead of preferring the left v, it mappends.
20:54:17 <copumpkin> yeah, that's nicer
20:54:17 <rwbarton> > M.fromList [(3,5)]
20:54:18 <lambdabot>   fromList [(3,5)]
20:54:29 <rwbarton> > M.fromList [(3,Sum 5)] `mappend` M.fromList [(3, Sum 7)]
20:54:30 <lambdabot>   fromList [(3,Sum {getSum = 5})]
20:54:38 <Tekmo> I'd recommend newtype/custom function over OverlappingInstances
20:54:55 <rwbarton> @type M.unionWith
20:54:56 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
20:55:07 <johnw> rwbarton: it's mappend'ing key/value pairs in the manner of First, not the values behind keys, right?
20:55:09 <copumpkin> :t M.intersectionWith
20:55:10 <lambdabot> forall a b c k. (Ord k) => (a -> b -> c) -> M.Map k a -> M.Map k b -> M.Map k c
20:55:15 <copumpkin> much bettar
20:55:33 <johnw> > M.fromList [(3,Sum 5)] `M.intersectionWith` M.fromList [(3, Sum 7)]
20:55:35 <lambdabot>   Couldn't match expected type `a -> b -> c'
20:55:35 <lambdabot>         against inferred type `D...
20:55:47 <johnw> > M.fromList [(3,Sum 5)] `M.unionWith` M.fromList [(3, Sum 7)]
20:55:48 <lambdabot>   Couldn't match expected type `a -> a -> a'
20:55:48 <lambdabot>         against inferred type `D...
20:55:50 <YayMe> introduction on typeclassopedia basically describes where I am.. maybe I shouldn't open this chapter of haskell yet
20:55:55 <rwbarton> > let op = M.unionWith mappend in M.fromList [(3,Sum 5)] `op` M.fromList [(3, Sum 7)]
20:55:56 <lambdabot>   fromList [(3,Sum {getSum = 12})]
20:55:57 <johnw> oh, missing the function
20:55:58 <acyed> applicative, wow! I wasn't indenting correctly. That's a learning point for sure
20:56:02 * YayMe fears he's going to find out there is no spoon
20:56:08 <acyed> applicative, thanks for the help
20:56:11 <copumpkin> there's never a spoon
20:56:15 <rwbarton> > M.fromList [(3,Sum 5)] `mappend` M.fromList [(4, Sum 7)]
20:56:15 <hpaste> applicative annotated “Instance of Show” with “Instance of Show (annotation)” at http://hpaste.org/75791#a75792
20:56:16 <lambdabot>   fromList [(3,Sum {getSum = 5}),(4,Sum {getSum = 7})]
20:56:27 <rwbarton> johnw: I'm not sure I understand
20:56:42 <rwbarton> but yeah, it is not using the mappend on values if that is what you mean?
20:57:02 <johnw> yes
20:57:09 <johnw> it's not a recursive mappend
20:57:09 <fryguybob> @hackage spoon -- no spoon here.
20:57:09 <lambdabot> http://hackage.haskell.org/package/spoon -- no spoon here.
20:57:15 <johnw> haha
20:57:31 <rwbarton> which is surprising
20:57:38 <johnw> that is a cool little class
20:58:08 <rwbarton> well, really you should be working with Semigroup here I guess
20:59:59 <shachaf> preflex: seen preflex
21:00:02 <shachaf> preflex: seen mgsloan
21:00:02 <johnw> all that does is drop the mempty requirement, right?
21:00:26 <rwbarton> yes
21:01:20 <shachaf> Are there any monads which have a sensible mplus without mzero?
21:01:37 <johnw> MonadSemi? :)
21:01:43 <rwbarton> with First semigroups you could recover the current Map mappend instance
21:02:06 <rwbarton> nonempty list monad
21:02:17 <rwbarton> for computations that can branch but never fail
21:03:10 <rwbarton> or you can define x `mplus` y = x but I guess that doesn't count as "sensible" :)
21:04:14 <YayMe> lol @ putting words in euclid's mouth
21:04:26 <jfischoff> okay so I was able to get around my last problem by adding the -lHSrts-ghc7.6.1 when I build, but now I am getting: Library not loaded: /Users/ian/zz32/ghc-7.6.1/libffi/build/inst/lib/libffi.6.dylib. I have no idea who ian is. Any ideas on how to fix?
21:04:37 * YayMe truly must be surrounded by mathtronauts if they made jokes like that
21:05:08 <jfischoff> it is reference from the rts appearantly
21:05:16 <Cale> YayMe: where's the joke?
21:06:01 <Cale> oh
21:06:03 <Cale> I see
21:08:10 <applicative> hah, ian is a ghc developer
21:08:58 <rwbarton> clearly the solution is mkdir -p /Users/ian/zz32/ghc-7.6.1/libffi/build/inst/lib/; ln -s [whatever] /Users/ian/zz32/ghc-7.6.1/libffi/build/inst/lib/
21:09:51 <shachaf> Ian as in Igloo?
21:11:48 <KirinDave> Hmm
21:12:03 <KirinDave> So, could someone give me some performance advice on how to fix this program so that it does not run out of stack space?
21:12:04 <KirinDave> https://gist.github.com/921aad56cae865852d3f
21:12:16 <KirinDave> Running it over 10000 inputs breaks.
21:12:23 <johnw> ah, I love these
21:12:29 <johnw> it's like chess puzzles
21:12:37 <KirinDave> Err, over 100000
21:12:41 <KirinDave> is foldM the answer?
21:13:40 <rwbarton> @src mconcat
21:13:40 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
21:13:49 <rwbarton> oh it's a class method you silly
21:14:21 <KirinDave> Arbitrary rule
21:14:25 <KirinDave> fizzbuzz cannot be touched or moved.
21:15:08 <jfischoff> okay export DYLD_LIBRARY_PATH=/usr/local/lib/ghc-7.6.1/ seems to have made things work…maybe.
21:15:12 <johnw> I would would make the result of mconcat strict
21:15:30 <YayMe> haha that is the most insane fizzbuzz I've ever seen
21:15:42 <rwbarton> I wonder why Data.Map bothers to define its own foldl'
21:15:43 <YayMe> I would love to see someone construct that in an interview on the spot
21:15:49 <johnw> your 'results' list right now is a huge thunk tree
21:16:07 <KirinDave> johnw: Does that actually fix it?
21:16:21 <johnw> KirinDave: i didn't compile it here, give it a shot
21:16:37 <johnw> but I can see that nothing is forcing the evaluation of anything here until the putStrLn
21:16:49 <rwbarton> this is kind of hard to read with no type signatures
21:17:09 <johnw> so anything you're doing will just keep building O(N) thunks for your input value
21:17:30 <rwbarton> oh and MonadComprehensions ugh
21:17:37 <applicative> jfischoff: the binary distribution I am using has 1800 references to /Users/ian/zz32/ghc-7.6.1 but strangely I haven't been having a problem.  Something I noticed once.
21:17:54 <KirinDave> rwbarton: Complain to c_wraith.
21:18:11 <rwbarton> doesn't this code actually not use any of those extensions
21:18:17 <rwbarton> well, except the last
21:18:32 <KirinDave> Um, I think it does for the instance Decl?
21:18:32 <rwbarton> oh there is yet another comprehension
21:18:35 <shachaf> type.signatures++
21:18:37 <jfischoff> applicative: likewise, but I haven't tried to make plugins with ghc before either
21:18:40 <rwbarton> oh it's a type
21:18:44 <rwbarton> ugh this is the worst code ever
21:19:07 <KirinDave> rwbarton: Ouch.
21:19:15 <rwbarton> type inference is supposed to be the compiler's job, not the reader's job
21:19:30 <shachaf> @remember rwbarton type inference is supposed to be the compiler's job, not the reader's job
21:19:30 <lambdabot> Nice!
21:19:38 <shachaf> That's a great way of putting it.
21:19:39 <luite> johnw: building thunks won't blow the stack though
21:19:49 <rwbarton> it's not like anything here is actually general, it is all just a huge puzzle of "guess what type it is running at"
21:19:58 <johnw> luite: if you keep building them, you're limited by stack size as to how high the input value can be
21:20:03 <johnw> so, 100000 in this case
21:20:28 <KirinDave> rwbarton: What do you want annotated?
21:20:36 <KirinDave> rwbarton: rules :: [(Integer -> Maybe Counter)]
21:20:51 <Ghoul> Is a monad kind of like a class
21:20:53 <KirinDave> rwbarton: Or do you REALLY want to see that heinous type signature for fizzbuzz?
21:20:55 <luite> i think it's the non-tailrecursive nature of the Maybe monad, that will need to build every item until it can decide whether the final result is Just x or Nothing
21:21:07 <KirinDave> Ghoul: Not really, if you mean like in Ruby or Java.
21:21:13 <rwbarton> oh right and Maybe has that screwy Monoid instance
21:21:26 <KirinDave> rwbarton: An actually very good monoid instance.
21:21:35 <Ghoul> Is "instance" related to monad.
21:21:47 <KirinDave> Ghoul: It's related to typeclasses.
21:22:07 <johnw> luite: interesting thought
21:22:21 <johnw> luite: the lack of type signatures led me to not think about the fact that he's in the Maybe monad
21:22:54 <rwbarton> it doesn't anywhere use the Maybe *monad* except in that trivial inner monad comprehension, does it
21:23:01 <johnw> shachaf: a function without a type signature shows up as a blue line (warning) for me in Emacs, so I add them even for simple variables
21:23:03 <KirinDave> johnw: Didnt' seem to hep, btw.
21:23:07 <KirinDave> rwbarton: Right.
21:23:13 <KirinDave> rwbarton: Well, actually no.
21:23:18 <shachaf> johnw: It generally shows up as a warning in my head.
21:23:20 <luite> johnw: i meant that new thunks don't necessarily end up on the stack, the stack only grows if you have a non-tailrecursive function that is forcing something
21:23:35 <rwbarton> so mconcat for Maybe Counter is a foldr
21:23:42 <Ghoul> https://github.com/MostAwesomeDude/baskerville/blob/master/Baskerville/Beta/Packets.hs#L54
21:23:44 <KirinDave> yeah I saw.
21:23:47 <KirinDave> It's wy it fell down.
21:23:47 <rwbarton> it doesn't use mconcat for Counter
21:23:48 <Ghoul> I see what's going on here and its quite cool
21:23:50 <johnw> KirinDave: ok, it was a guess, you just have to find out who is building the thunk chain and use a well-placed seq to collapse it as it's being built
21:24:03 <Ghoul> but what does the instance Serialize Difficulty where part really tell hask
21:24:10 <rwbarton> what if you just replace mconcat by foldl' mappend
21:24:11 <KirinDave> johnw: I just wonder what's causing the stack descent…
21:24:18 <rwbarton> uh, foldl' mappend mempty
21:24:24 <johnw> KirinDave: what luite said may be the answer
21:24:46 <rwbarton> to be clear I mean the one on line 30
21:25:19 <shachaf> What's all this code supposed to be doing?
21:25:32 <johnw> a lot of fizzing and buzzing
21:25:34 <KirinDave> luite: So what I should do is ditch the outer maybe.
21:25:38 <KirinDave> Which is easy enough.
21:25:56 <rwbarton> also yeah, can't you just use an empty Map
21:26:21 <rwbarton> or actually
21:26:27 <rwbarton> can it ever be Nothing?
21:26:29 <KirinDave> rwbarton: I do.
21:26:32 <KirinDave> rwbarton: No.
21:26:44 <johnw> does mconcat lazily consume the "elements" of the argument?
21:26:47 <YayMe> Ghoul: in that line, "Serialize" is a type class, "Difficulty" is a data type, and the "instance" is defining Difficulty to be a member of the Serialize type class. You asked about a monad a moment again, Monad is a type class (among other things I don't really know) and many data types are defined as members of the Monad type class by having instance definitions
21:26:48 <KirinDave> luite:   foldl' mappend mempty [ fromJust $ fizzbuzz (const mempty) i | i <- [1..upTo] ] -- doesn't fix.
21:27:07 <KirinDave> I sorta don't get why.
21:27:12 <KirinDave> Where is my cold fusion.
21:27:36 <rwbarton> you still get a stack overflow specifically?
21:27:41 <KirinDave> Yes
21:27:49 <KirinDave>  ~/P/h/fb-toys > time ./fbg3 1000000
21:27:49 <KirinDave> Stack space overflow: current size 8388608 bytes.
21:27:52 <rwbarton> I mean you are building a Map with a ton of elements so you are always going to have a "space leak" compared to doing this in a reasonable way
21:27:57 <KirinDave> Sure.
21:28:00 <Ghoul> YayMe: Oh sweet
21:28:01 <rwbarton> okay, right
21:28:05 <KirinDave> "Reasonable way?"
21:28:08 <jude> I am trying to have Show call a function that does the same thing as the commented lines? http://ideone.com/98TEW
21:28:37 <rwbarton> well I'm not sure what exactly you are trying to do with this Map but how about a list or just a bunch of separate putStrLns?
21:28:41 <KirinDave> I am trying to build counters for how often the predicates occur.
21:28:50 <rwbarton> oh
21:29:06 <KirinDave> So like normal output is fromList [("bazz",1428),("buzz",2000),("fizz",3333)]
21:29:25 <rwbarton> ohhh okay.
21:29:27 <rwbarton> use Data.Map.Strict
21:29:31 <KirinDave> (And yes, you could just do it naturally with math. But.)
21:30:24 <KirinDave> Oh wow
21:30:26 <KirinDave> That fixed it
21:30:36 <KirinDave> Haha, that means that the stack blow is in Data.Map.
21:30:41 <rwbarton> sort of
21:30:50 <luite> hm good one
21:30:54 <shachaf> You could also force values before inserting them yourself, presumably.
21:30:57 <KirinDave> rwbarton: I literally just changed the Counter type.
21:31:04 <KirinDave> That is suuuper weird.
21:31:11 <rwbarton> you are just building a map fromList [("bazz",1+(1+(1+...))},...]
21:31:29 <Ghoul> There was a note in LYAH
21:31:34 <rwbarton> that is just how Data.Map works, it never forces the values of themap
21:31:36 <rwbarton> the Map
21:31:37 <Ghoul> about lazy types and infinite lists
21:31:55 <KirinDave> rwbarton: interesting.
21:31:58 <Ghoul> its better to use strict types when feeding in infinite lists
21:32:15 <Ghoul> because apparently sometimes lazy types like to iterate the entire list before checking the conditions
21:32:22 <Ghoul> which with infinite lists can be a bad idea.
21:32:28 <Ghoul> or something like that.
21:32:34 <rwbarton> Data.Map.Strict has the same Map type but the operations like unionWith (and adjust and so on) force the new element which has been inserted
21:32:37 <jude> I am trying to have Show call a function that does the same thing as the commented lines why does my call to dissect not work? http://ideone.com/98TEW
21:32:37 <rwbarton> before returning
21:32:43 <KirinDave> Data.HashMap.Strict
21:32:48 <mgsloan> dmwit: here?  Have  fixups for gtk2hs on ghc7.6 been done?  I'm considering doing it
21:33:08 <johnw> :t <|>
21:33:10 <lambdabot> parse error on input `<|>'
21:33:14 <johnw> :t (<|>)
21:33:16 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
21:33:22 <Ghoul> What's the C code generated by ghc look like
21:33:26 <Ghoul> is there an example somewhere
21:33:34 <shachaf> GHC doesn't usually generate C code.
21:33:34 <rwbarton> KirinDave: you probably still needed the foldl' mappend mempty change though, right?
21:33:44 <KirinDave> rwbarton: Nope
21:33:52 <Ghoul> Oh okay
21:33:57 <Ghoul> straight to asm then?
21:34:01 <johnw> is <|> just the Applicative form of <>?
21:34:02 <Ghoul> or is it still interpreted.
21:34:20 <rwbarton> well was this after you got rid of the Maybe in Maybe Counter? because that would also be enough
21:34:33 <rwbarton> but the original "mconcat [ fizzbuzz (const mempty) i | i <- [1..upTo] ] :: Maybe Counter" seems like it would be bad
21:34:35 <KirinDave> Yes I did get rid of that.
21:35:05 <YayMe> What types implement alternative other than either?
21:35:06 <KirinDave> Oh. Interesting.
21:35:25 <rwbarton> so originally you had two stack overflows :)
21:35:29 <YayMe> sorry, what types are in the alternative type class
21:35:31 <johnw> ha
21:36:48 <rwbarton> YayMe: []
21:36:56 <rwbarton> probably a lot of others
21:37:03 <rwbarton> parsers, typically
21:37:32 <zzing> :t on
21:37:34 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:37:38 <zzing> @src on
21:37:39 <lambdabot> (*) `on` f = \x y -> f x * f y
21:38:37 <jude> i figured my last question out
21:38:39 <applicative> Ghoul: ghc has a native code generator, but it can also compile via the LLVM with -fllvm.  I think the C machinery still exists, for porting ghc to new platforms, but I'm not sure why I htink that
21:39:21 <applicative> Ghoul: the jhc writes C
21:39:55 <zzing> :t Last
21:39:56 <lambdabot> forall a. Maybe a -> Last a
21:41:18 <zzing> :t (.)
21:41:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:41:28 <zzing> :t Prelude..
21:41:29 <lambdabot> parse error on input `Prelude..'
21:41:29 <applicative> Ghoul there is an outline of such things here http://www.aosabook.org/en/ghc.html
21:41:32 <zzing> :t Prelude.(.)
21:41:33 <lambdabot> Not in scope: data constructor `Prelude'
21:42:30 <rwbarton> :t (Prelude..)
21:42:32 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:42:41 <zzing> bless you sir
21:43:36 <shachaf> (.) :: Category k => k b c -> k a b -> k a c
21:43:55 <applicative> "GHC can produce ordinary C code. This route produces significantly slower code than the other two routes, but can be useful for porting GHC to new platforms."
21:44:34 <shachaf> GHC used to go through C a while ago.
21:44:50 <shachaf> (Even for optimized code. But it was very different C from the unoptimized code.)
21:45:16 <Ghoul> I cant even begin to imagine how you generate native code out of hask
21:45:17 <Ghoul> :S
21:45:43 <shachaf> There's a paper about it if you want to begin to imagine.
21:45:51 <shachaf> @google spineless tagless g-machine
21:45:52 <lambdabot> http://research.microsoft.com/pubs/67083/spineless-tagless-gmachine.ps.gz
21:46:37 <zzing> Well, I think I figured out the type for this:    ov f = getLast $! (mappend `on` (Last . f)) a b     Seems to be  the type of the monoid a: a -> a -> a. No idea what it really does though
21:53:11 <applicative> Ghoul: if you do ghc mymodule.hs ddump-asm the asm will spill into stdout
21:53:20 <applicative> -ddump-asm rather
21:54:09 <johnw> zzing: I un-Monoided that code for you before, did that not help_?
21:54:37 <johnw> it just looks like a glorified `if'
21:56:35 <zzing> umm, I must have missed it one sec, let me check.
21:58:32 <zzing> johnw, I just looked back an hour and i didn't see anything. I must have missed it, I apologize if that is the case.
21:58:48 <johnw> in non-Monoid form: let x = f b in if isJust x then x else f a
21:59:19 <johnw> i think that getLast expression is overly cute
22:00:26 <zzing> ok, I think I have to make that a little cleaner...
22:00:42 <zzing> if isJust (f b) then (f b) else (f a)
22:01:16 <zzing> Does this qualify? case (f b) of  { Just _ -> f b; Nothing -> f a }
22:01:17 <johnw> shachaf: do you know if it's 100% certain that the two calls to f b will be unified?
22:01:40 <johnw> zzing: case f b of x@(Just _) -> x; Nothing -> f a
22:01:57 <johnw> that's actually how I would have written it
22:02:18 <zzing> Why would the s n a p people write that overly complex thing I wonder
22:02:31 <johnw> mabye they'd learned about the Last monoid that morning :)
22:03:02 <zzing> I could believe it. Is there a point to writing code like that?
22:03:15 <johnw> to make sure you're reader can't read the code very easily
22:03:26 <johnw> no, there is no benefit
22:03:28 <zzing> Like me
22:03:48 <zzing> I will have to ask mighty byte about that :-)
22:03:50 <johnw> using the Last monoid can have benefits when mapping or folding, but to use it just for a pair of values like this is overkill imho
22:03:59 <shachaf> johnw: ?
22:04:06 <johnw> if isJust (f b) then (f b) else (f a)
22:04:16 <johnw> is it guaranteed that f will only be called once?
22:04:18 <shachaf> No.
22:04:21 <johnw> or, rather, twice
22:04:27 <shachaf> There are no guarantees about how many times f will be called.
22:04:28 <johnw> or, rather, once or twice
22:04:29 <johnw> ok
22:04:32 <johnw> that's what I thought
22:05:01 <johnw> I've been in the habit of binding my intermediaries when function calls are involved, from my imperative background
22:05:06 <johnw> just wasn't sure that was a false approach or not
22:05:11 <shachaf> GHC tends not to do all that much CSE, I think.
22:05:14 <shachaf> It's a reasonable approach.
22:05:33 <shachaf> Of course, there are no guarantees in let x = f b in ...x...x...
22:05:33 <johnw> thanks
22:05:47 <shachaf> But in practice in GHC that's pretty much a guarantee. :-)
22:06:02 <zzing> Is this reasonable? http://hpaste.org/75793
22:06:27 <johnw> you can just say: then f b else f a
22:06:31 <johnw> you don't need parens there
22:06:38 <shachaf> By the way, anything of the form "if isJust x then ... else ..." should probably be written as case-of
22:06:55 <johnw> :)
22:07:08 <zzing> So this: case f b of x@(Just _) -> x; Nothing -> f a
22:07:15 <zzing> Remind me what the x@ does...
22:07:17 * shachaf wonders whether the Monoid instance for Maybe doesn't already do what you want...
22:07:24 <johnw> binds the matched pattern to x
22:07:39 <johnw> > Just 4 <> Nothing
22:07:40 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
22:07:40 <lambdabot>         agains...
22:07:46 <johnw> shachaf: no
22:07:55 <johnw> a Nothing on either side results in Nothing
22:08:01 <zenware> One of these days, I'm going to have to learn me a haskell...
22:08:05 <johnw> Last gives you the last non-Nothing avlues
22:08:23 <shachaf> That @paste doesn't have any reference to Last.
22:08:33 <johnw> it was something he pasted before
22:08:47 <johnw> (well, just into the channel)
22:08:56 <zzing> http://hackage.haskell.org/packages/archive/snap-server/0.9.2.3/doc/html/src/Snap-Internal-Http-Server-Config.html#Config    look for ov f = getLast ...
22:09:41 <shachaf> @ty let ov f = if isJust (f b) then (f b) else (f a) in ov
22:09:42 <lambdabot> forall a. (Expr -> Maybe a) -> Maybe a
22:09:44 <shachaf> Bah, a and b.
22:10:53 <shachaf> Anyway, I see.
22:11:21 <zzing> So if I do "a <> b"   and both a and b have one of the fields containing a Just, am I correct to believe it will take the one from b?
22:12:31 <johnw> zzing: try it out in ghci
22:16:32 * hackagebot Interpolation 0.3.0 - Multiline strings, interpolation and templating.  http://hackage.haskell.org/package/Interpolation-0.3.0 (VilleTirronen)
22:21:14 <shachaf>     Ambiguous occurrence `*'  It could refer to either `GHC.TypeLits.*', imported from `GHC.TypeLits'  or `*', imported from `GHC.Prim'
22:21:31 <johnw> in what context?
22:21:34 <zzing> (Just 5) <> (Just 6)  does work,     Ambiguous type variable `a0' in the constraints:
22:21:35 <shachaf> ghci
22:21:44 <latro`a> that mention of the monoid for maybe thing reminds me of the silliness of those incompatible sets of MonadPlus laws
22:21:46 <zzing> doesn't rather
22:22:41 <johnw> huh
22:22:52 <johnw> Maybe's mappend applies mappend to the contents of the Just
22:22:55 <johnw> > Just (Product 3) <> Just (Product 4)
22:22:57 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
22:22:57 <lambdabot>         agains...
22:23:03 <johnw> I get: Just (Product {getProduct = 12})
22:23:44 <zzing> I will have to test my data structure tomorrow I guess
22:23:55 <zzing> Time to sleep, and I need to have blood work done tomorrow. Joys.
22:24:08 <johnw> night!
22:24:56 <zzing> thank you for your helps
22:26:57 <startling> johnw: there are two possible Monoids otherwise
22:27:05 <johnw> yeah?
22:27:25 <startling> like And and Or
22:27:40 <johnw> ah
22:27:50 <johnw> Any, All, And, Or, Last, First
22:27:55 <johnw> Mabye is a pretty cool typ
22:28:19 <johnw> or rather, boolean Monoids are cool ;)
22:28:27 <startling> hehe
22:29:20 <shachaf> Did you see byorgey's paper on monoids?
22:29:24 <shachaf> And other things.
22:29:26 <johnw> no!  link me!
22:29:28 <shachaf> @google byorgey monoids
22:29:30 <lambdabot> http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
22:29:31 <lambdabot> Title: ≡ ] , , [
22:29:39 <johnw> i finished reading all the haskell articles on my kindle (like 50 of them)
22:29:45 <johnw> i'm now looking for more
22:29:46 <shachaf> AAA++++ title would @google again
22:30:25 <johnw> thanks, shachaf, i'll read this with interest
22:30:29 <evincar> johnw: Haskell articles specifically, or things that people who like Haskell may also like?
22:30:49 <johnw> it was anything haskell related, articles, blogs, etc.
22:31:00 <johnw> the answer to your question is: both
22:31:01 <shachaf> johnw: That's your strategy for not getting too many papers piling up, huh?
22:31:01 <evincar> Hm, can't help you.
22:31:08 <johnw> shachaf: what is?
22:31:12 <shachaf> Interest.
22:31:17 <johnw> ah, yes
22:31:20 <johnw> Interest rules my world
22:31:32 * hackagebot lifted-base 0.2 - lifted IO operations from the base library  http://hackage.haskell.org/package/lifted-base-0.2 (BasVanDijk)
22:31:32 <johnw> I know I've lost interest in something when the articles start piling up on me
22:32:13 <johnw> but I've gotten so into these Haskell articles, that my scifi books have been absolutely languishing.  that's very rare
22:32:31 <johnw> usually entertaining trumps technical at bedtime
22:32:33 * shachaf was just making a pointless pun. :-(
22:32:55 <johnw> make a pointfree pun and I'd get it
22:45:36 <jfischoff> Success! I Finally have a Flash plugin written with Haskell (plus c glue code).
22:45:51 <lispy> jfischoff: interesting!
22:46:13 <jfischoff> I see it as very good alternative to jsfl
22:53:45 <Nisstyre> jfischoff: does it work?
22:54:34 <jfischoff> Yeah, but it might not be what you think it is. It is for Flash CS not Flash Player, does that make sense?
22:56:28 <Nisstyre> jfischoff: flash CS?
22:57:42 <jfischoff> yes as in the content creation app. This is for to facilitate the exporting of fla files
23:00:56 <hpaste> obk pasted “let vs. do scopes” at http://hpaste.org/75795
23:06:42 <evincar> obk: I think recursive 'do' will do that. -XDoRec
23:08:06 <obk> evincar: Yes, I just discovered it. Seems I need to add rec { ... } but now I get strange parse errors.
23:10:01 <hpaste> “mysterious person” annotated “let vs. do scopes” with “let vs. do scopes (annotation)” at http://hpaste.org/75795#a75796
23:10:17 <obk> evincar: Ah, no I have to add ';' between the statements. Now it works. Thanks.
23:10:58 <shachaf> obk: Or use indentation.
23:11:08 <shachaf> See what that mysterious person up there wrote.
23:12:44 <obk> Perfect! Thanks "mysterious stranger"!
23:15:53 <minotaur> ?
23:16:17 <Cale> hello
23:26:11 <jfischoff> So I have pointer to array of bytes from C and I want to pass it to haskell and have to converted to ByteString, would I use unsafePackAddressLen to do that?
23:29:20 <Axman6> sounds reasonable to me
23:29:36 <jfischoff> cool
23:33:03 <jfischoff> so If I want to pass back four bytes what is the easiest way to do that?
23:34:22 <shachaf> Pass back?
23:35:53 <jfischoff> So I am call a function foo :: CInt -> Addr# -> Four Bytes from C
23:36:05 <jfischoff> I want to know what I should make the return type in haskell
23:37:35 <lightquake> has anybody here played around with the upcoming cabal environments feature?
23:37:39 <shachaf> Depends on what the bytes mean.
23:37:47 <startling> jfischoff: ByteString, (Word8, Word8, Word8, Word8), Word32?
23:37:56 <shachaf> ByteString, [Word8], (Word8,Word8,Word8,Word8), Word32, etc.
23:38:03 <jfischoff> whoops I might
23:38:14 <shachaf> (Not that any of those are very meaningful types...)
23:38:41 <jfischoff> 4 * 32 so 128 bit = 16 Bytes
23:39:28 <jfischoff> yeah 16 bytes not four
23:39:36 <startling> I'd just do a ByteString, unless it's very important that you can prove that there are only 16 bytes
23:40:09 <jfischoff> is that tricky to convert on the C side?
23:40:30 <jfischoff> what about WordPtr, that looks like ti has potential
23:41:30 <startling> I think ByteString is just a length and a pointer underneath? I might be thinking of something else, though
23:42:35 <shachaf> And offset.
23:44:30 <ClaudiusMaximus> @hoogle Large
23:44:31 <lambdabot> package largeword
23:44:31 <lambdabot> GHC.Constants oFFSET_generation_n_new_large_blocks :: Int
23:44:31 <lambdabot> GHC.Constants oFFSET_StgLargeBitmap_bitmap :: Int
23:45:26 <jfischoff> the large words aren't storable though
23:46:08 <jfischoff> nor is bytestring
23:46:13 <ClaudiusMaximus> woe
23:46:29 <ClaudiusMaximus> guess you have to pick an endianness
23:47:24 <jfischoff> newArray will probably work
