00:00:09 <mm_freak> could be improved
00:00:53 <mm_freak> in Control.Monad { import State; import Writer }
00:01:21 <sp3ctum> gitk
00:01:23 <sp3ctum> sry
00:01:30 <Rc43> Hi, guys.
00:01:37 <mm_freak> hi there
00:01:58 <Rc43> What libs are named "rt" and "dl"?
00:02:09 <Rc43> Package "unix" requires them.
00:02:20 <Rc43> But I can't find them and install with cygwin.
00:04:06 <mm_freak> i see neither the dependency nor the libraries
00:04:20 <Rc43> Does "dl" stand for "dynamic loading/linking"?
00:04:46 <mm_freak> good question, could stand for anything; as said i don't see the dependency
00:04:56 <rwbarton> these are C libraries
00:04:57 <Rc43> mm_freak, `cabal install unix` gives messages from autoconf ("Missing C libraries: rt, dl")
00:05:07 <mm_freak> ah, that's entirely different =)
00:05:10 <rwbarton> librt is for realtime stuff, libdl for dynamic loading
00:05:20 <rwbarton> where to get them on windows? no idea
00:05:22 <Rc43> mm_freak, yeah; I forgot to tell about that they are C libs
00:05:27 <mm_freak> does the unix package work on cygwin?
00:05:45 <Rc43> mm_freak, hackage tells that yes
00:06:19 <Rc43> hackage: "The package is not supported under Windows (except under Cygwin)."
00:06:30 <mm_freak> i see
00:06:42 <mm_freak> well, probably just need to install some cygwin packages
00:07:26 <Rc43> mm_freak, tried to find them :) #cygwin keeps silence as yet
00:11:48 <mm_freak> Rc43: do you need an actual windows?  if not, it may be easier to install linux in a VM
00:11:50 <Rc43> Hmmm, on man on #cygwin tells that rt and dl are included in cygwin itself.
00:12:08 <mm_freak> then you need to tell the configure script how to find them
00:12:24 <Rc43> mm_freak, it is easier, but not very good performance
00:12:50 <mm_freak> see cabal configure --help and look for --configure-option
00:12:58 <mm_freak> there you can pass options to the configure script
00:13:21 <mm_freak> i remember that cygwin has such a bad performance that a VM actually outperformed it
00:13:26 <Rc43> mm_freak, so I should install this package manually with `cabal unpack ..` and then `cabal configure`?
00:14:30 <mm_freak> probably, unless "cabal install" allows passing the options, too
00:14:50 <Rc43> mm_freak, don't know about cygwin performance; I used msys + gnuwin32 and some people said me that cygwin is more convinient and not slower
00:15:16 <randomclown> honza.ca/2012/10/haskell-strings
00:15:20 <mm_freak> what are you doing?
00:15:25 <randomclown> flamebait incoming
00:17:13 <MostAwesomeDude> randomclown: It won't load for me.
00:18:02 <saiko-chriskun> loads fine here
00:18:24 <randomclown> press f5 a couple of times, it's linked from reddit
00:18:58 <MostAwesomeDude> There we go.
00:20:30 <mm_freak> i've read that…  not sure if that's a useful post
00:22:15 <randomclown> somebody needs to write a version with unsafe bytestrings
00:22:28 <mm_freak> no, just a proper haskell version
00:22:30 <MostAwesomeDude> He doesn't mention PyPy. Casual.
00:22:40 <MostAwesomeDude> Anyway, what's the right way to do it in Haskell?
00:22:54 <mm_freak> this is stream processing, so process it as a stream
00:23:09 <mm_freak> there are many libraries for that, like conduit, enumerator, iteratee, pipes, etc.
00:23:23 <MostAwesomeDude> And are those actually going to be performant?
00:23:28 <mm_freak> yes
00:24:35 <mm_freak> otherwise snap and warp wouldn't outperform node.js =)
00:25:08 <MostAwesomeDude> Node's performance is pitiful regardless.
00:25:37 <randomclown> backed by v8 it's alright
00:25:42 <zomg> MostAwesomeDude: I'd say it's pretty good if it can handle 1500 concurrent connections that constantly send and receive data
00:25:53 <zomg> on a cheap VPS that is
00:26:06 <MostAwesomeDude> zomg: Twisted, the thing that inspired Node, still regularly cleans its clock when backed by PyPy.
00:26:33 <zomg> Yeah I used twisted but it's been years, I can't really say it's as simple to use as node is for certain things
00:27:03 <mm_freak> node is just poor man's snap
00:27:05 <MostAwesomeDude> Well, when you want certain things to *work*, yes, you have to sacrifice some simplicity. Does Node do UDP, threads, subprocesses, or stdio yet? :3
00:27:07 <zomg> Node might not be the fastest option but at least it's decently quick and the big pro is that certain things are just really straighforward to do with it
00:28:28 <mm_freak> that's a matter of libraries…  the core of node is very similar to snap, but unlike snap it's not backed by a powerful type system and RTS
00:29:26 <mm_freak> also it's missing high level features, so ultimately node.js code slowly converges to PHP over time
00:29:44 <zomg> That's a pretty silly argument since it's nothing like PHP :P
00:29:56 <MostAwesomeDude> zomg: Have you *seen* JS's and PHP's types?
00:30:03 <MostAwesomeDude> They're so similar.
00:30:14 <mm_freak> and the module systems are also pretty similar
00:30:42 <mm_freak> in fact i fail to see a difference between JS and PHP
00:31:05 <zomg> I'm sorry but that's a really ignorant statement :P
00:31:32 <mm_freak> please tell me any major difference
00:31:39 <MostAwesomeDude> mm_freak: $$$
00:31:50 <mm_freak> yeah, ok
00:31:53 <mm_freak> what else?
00:31:55 <zomg> Well for starters, superglobals
00:32:06 <mm_freak> any fundamental difference?
00:32:15 <randomclown> php standard library is complete crap
00:32:16 <zomg> The class system in PHP
00:32:25 <zomg> Doesn't exist like that at all in JS
00:32:29 <b_work__> if I have a type synonym for a type that already has an instance Show defined, can I override this instance? I do not want a silly datatype like "data MyNum = MyNum { mynum :: Integer }" or something like that.
00:32:42 <zomg> JS doesn't have namespaces unlike recent versions of PHP
00:32:49 <mm_freak> please don't argue that a feature sucks in PHP, if JS doesn't have that feature at all, unless the sole presence of the feature is bad ;)
00:32:52 <lightquake> b_work__: no; type Foo = Bar means that the type Foo is equivalent in every way to the type Bar
00:33:15 <lightquake> you can use a newtype declaration to do what you want; newtype MyNum = MyNum Integer
00:33:20 <randomclown> @google php fractal of bad design
00:33:21 <lambdabot> http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/
00:33:21 <lambdabot> Title: PHP: a fractal of bad design - fuzzy notepad
00:33:22 <b_work__> okay
00:33:25 <mm_freak> b_work__: you can use newtype with GeneralizedNewtypeDeriving
00:33:30 <zomg> JS is a prototypic language... in JS everything is an object..
00:33:45 <zomg> randomclown: that's just a stupid article tbh
00:33:58 <MostAwesomeDude> zomg: What's stupid about it? I can go tell him.
00:34:13 <zomg> it has some ok points but overall it's just another of these populistic HEY LET'S HATE PHP! things
00:34:13 <mm_freak> zomg: to be fair, i'm not a fan of OO, so "everything is an object" puts me off, but yes, i get your point
00:34:22 <mm_freak> anyway, i'm just teasing you
00:34:25 <lightquake> zomg: nah the article's pretty spot on
00:34:37 <zomg> mm_freak: figured as much cause it started sounding so silly ;)
00:34:48 <mm_freak> but seriously even though PHP has many bad properties, fundametally there is little difference between JS and PHP
00:35:03 <zomg> Certain parts are similar I give you that
00:35:13 <mm_freak> verbose syntax, weird semantics, no type system, etc.
00:35:16 <statusfailed> Where's the reddit thread for that haskell strings post?
00:35:22 <MostAwesomeDude> zomg: But seriously. If you find any inaccuracies in that blog post, eevee's a friend and I could relay it.
00:35:43 <lightquake> mm_freak: it totally has a type system! it's just not a strong or static one
00:36:05 <randomclown> statusfailed: go to reddit.com/r/haskell
00:36:13 <mm_freak> lightquake: it has data types, but not types, much less a type system
00:36:24 <zomg> MostAwesomeDude: tbh it's been ages since I read it and it just had the overall negative feeling that you get from most people writing that sort of posts who just hate things for no reason
00:36:47 <randomclown> mm_freak: JS has a very nice hash/object type system, first class functions, closures etc.
00:36:49 <MostAwesomeDude> zomg: No, I'm pretty sure he hates PHP for the same reason I do: it causes brain damage.
00:37:14 <zomg> It doesn't though, unless you're already prone to retardation for some biological reason
00:37:19 <zomg> :P
00:37:21 <lightquake> js sucks. php sucks. they suck for different reasons and they're not really equivalent
00:37:24 <mm_freak> randomclown: that's not a type /system/…  type checking alone doesn't give you a type /system/
00:37:41 <MostAwesomeDude> zomg: It permanently impairs programmers who learn it first.
00:38:14 <mm_freak> zomg: i've used PHP for years and i can second every word in that article…  it may sound like a big rant, but it's a reasonable one
00:38:29 <pharaun> hah i work with eevee
00:38:38 <zomg> MostAwesomeDude: oh thank you, I'm permanently impaired then huh
00:38:50 <randomclown> mm_freak: dynamically typed counts a type system
00:38:50 <randomclown> as a*
00:38:50 <randomclown> also it's almost homoiconmorphic i.e. json
00:39:21 <MostAwesomeDude> zomg: Have you considered unlearning PHP?
00:39:22 <statusfailed> randomclown: did so, thanks
00:39:24 <zomg> Maybe I'll just give up my life and stay to writing spaghetti php with html then.
00:39:28 <mm_freak> randomclown: apples and oranges…  haskell is dynamically typed as well
00:39:36 <zomg> which is obviously the only thing you can do with as bad language as PHP is
00:40:23 <mm_freak> randomclown: a type system is a /system/…  by definition a arbitrary set of random rules is not a /system/
00:40:30 <mm_freak> but that's precisely what JS and PHP both do
00:40:44 <randomclown> I meant to say dynamic typing but w/e
00:41:01 <mm_freak> dynamic typing is just a feature, which even haskell has
00:41:32 * hackagebot digestive-functors-snap 0.5.0.2 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.5.0.2 (JasperVanDerJeugt)
00:41:52 <randomclown> I'm don't really want to argue clearly set out definitions that are easily checkable from wikipedia
00:42:42 <zomg> And MostAwesomeDude's comments pretty much just summed up why PHP hate is so moronic
00:43:10 <zomg> People who haven't even really used it generally just go OMG ZOMG U ALL SUCK BCOZ THIS ARTICLE ON THE INTERNET SAYS SO
00:43:19 <zomg> It's the cool thing to do
00:43:31 <mm_freak> there is no formal definition of dynamic typing or type system, but there is such a definition of "system"
00:43:40 <zomg> It's not a perfect language that's for sure but it gets the job done
00:43:44 <mm_freak> anyway, i'm done
00:43:55 <zomg> And if you go around saying people who use it are retarded, then maybe you should go get some help for your own retardation first
00:43:58 <zomg> :P
00:43:59 <MostAwesomeDude> zomg: I PHP'd for four years.
00:44:21 <zomg> And it sounds like you didn't learn anything while doing that
00:44:34 <MostAwesomeDude> zomg: Well, I learned PHP, but that's hardly a thing that one learns. >:3
00:44:36 <mm_freak> zomg: i used PHP for around six years
00:44:42 <mm_freak> commercially
00:44:51 <pharaun> i mean you can do good secure system in php
00:45:05 <mm_freak> you can't
00:45:05 <pharaun> but its not like the language exactly encourages it by default with all of the edge cases and exceptions
00:45:16 <zomg> MostAwesomeDude: learning the syntax vs actually learning is somewhat different I'd say
00:45:40 <randomclown> mm_freak: conduits vs pipes vs ?
00:45:43 <zomg> It's on the same level as children's "I don't want to eat vegetables"
00:45:46 <zomg> tbh.
00:45:46 <zomg> :P
00:45:52 <pharaun> mm_freak: probably can if you're willing to go read the source code, then be deeply involved with the whole php stack/interpreter/etc
00:45:55 <MostAwesomeDude> zomg: Uh, no, I wrote and deployed sites.
00:46:00 <mm_freak> randomclown: ?
00:46:03 <MostAwesomeDude> zomg: But go ahead, move the goalposts some more.
00:46:06 <zomg> MostAwesomeDude: big deal. So do most bad PHP programmers
00:46:14 <randomclown> mm_freak: major differences?
00:46:19 <mm_freak> pharaun: i can't, because i'm human
00:46:47 <MostAwesomeDude> zomg: ...Man, you're just on the ball. I can't possibly have emitted good PHP code, right? Nobody who knows PHP well and is good with the language would ever dislike it, right?
00:46:59 <zomg> MostAwesomeDude: Now I'm not saying you were one of those. Just that you're making ridiculously dumb claims
00:47:00 <mm_freak> there is a maximum size for a system to be secure in PHP, which depends on the capacity of your short term memory, which is very limited
00:47:09 <MostAwesomeDude> zomg: http://www.phpwtf.org/
00:47:17 <mm_freak> that maximum size with all the pecularities of PHP is quickly reached
00:47:24 <MostAwesomeDude> zomg: This site is maintained by chx. You might know him. He does Drupal.
00:47:26 <pharaun> mm_freak: there's that, then you could probably argue that most system can't be "secure" past a certain varying size cos we're all humans :)
00:47:28 <mm_freak> so only very small things can be secure in PHP
00:47:46 <MostAwesomeDude> zomg: My employer *hosts* Drupal. I am surrounded by Drupal and Moodle and all sorts of PHP-based phenomena.
00:47:49 <mm_freak> pharaun: you're wrong, because other languages allow you to view things in isolation
00:47:52 <mm_freak> like haskell
00:48:00 <mm_freak> PHP fundamentally forbids that
00:48:28 <zomg> How exactly? :P
00:48:31 <MostAwesomeDude> zomg: At any rate, I'm tired of this. Have a nice night.
00:48:33 <pharaun> mm_freak: even with isolation there still can be things that you are not aware of, ie the old problem of not being aware of what you're not aware of
00:48:50 <zomg> MostAwesomeDude: yeah not like you had anything useful to say to begin with
00:49:02 <mm_freak> pharaun: what do i need to be aware of other than the definition of [] to implement foldr?
00:49:38 <pharaun> mm_freak: heh there's that but ultimately you'll for... most system will need a way to take in and spit out data for a system to be useful
00:49:41 <pharaun> and that's the vector
00:49:58 <mm_freak> please answer my question…  anything else i need to be aware of?
00:50:38 <pharaun> for foldr a simple example, probably not, but you could implement it in a manner that leads to space leak or do dumb things
00:51:18 <mm_freak> yes, you need to understand the language semantics, but let's go on:  what about foldM?
00:51:30 <mm_freak> i need to know Monad and [], and that's it
00:51:41 <mm_freak> but foldM is actually a pretty complicated function, when you consider what it does
00:51:58 <pharaun> however there is IO monad
00:52:35 <mm_freak> haskell is very good at allowing you to view things in isolation
00:52:46 <pharaun> for ex, i'm working on some stuff that deals with the filesystem and i've been bitten by fun issues in the filesystem layer, not haskell itself
00:52:49 <mm_freak> both the language and the libraries are designed to support that
00:52:49 <pharaun> that i've had to take in accord
00:53:06 <pharaun> its fortunately mostly isolated to those modules
00:53:16 <mm_freak> PHP is exactly the opposite:  you need to keep track of a lot of state simply to be able to reason what something as simple as "echo" does
00:53:56 <pharaun> but it is still *something* someone would need to consider if you wrote one of those module, can't just go naive and say do random X, can end up with security issue, i mean IE you can tie into openssl, which could also have security issue, and that's outside haskell scope
00:54:26 <zomg> I like how functional programmers make it sound like having state is like a big bull who just wants to smash everything
00:54:29 <pharaun> so it can still be a consideration, in pure haskell, i'm lots less worried and it helps massivly in making all of my parts more smaller/isolated you are right
00:54:34 <zomg> To ridiculous proportions
00:54:45 <pharaun> so i find it much easier to keep in mind and be aware of the edge cases that i need to care of and contain it
00:54:49 <zomg> Some of them anyway, or when attempting to make some silly point
00:54:51 <zomg> :p
00:54:52 <mm_freak> the thing is:  you consider those things that count…  not a huge environment of weird langauge/RTS features
00:55:21 <mm_freak> zomg: having state is fine…  having uncontrolled state is the big bull
00:55:40 <zomg> I don't usually have uncontrolled state in my PHP applications so I dunno
00:55:42 <pharaun> mm_freak: as in i consider it on a per point/contact basis? as in I can trust the general system to back me unless i do something dumb?
00:55:45 <zomg> well, obviously besides superglobals
00:55:46 <zomg> :P
00:55:57 <pharaun> mm_freak: unlike what is it the whole ==/null?/whatever in php?
00:56:02 <Rc43> How to get haskell platform under cygwin?
00:56:10 <Rc43> I mean not windows version.
00:56:13 <mm_freak> zomg: and ob_* and how "fatal errors" are handled, because they are special in PHP, etc.
00:56:20 <mm_freak> you have a lot of uncontrolled state
00:56:31 <mm_freak> unless you control it using "if …"
00:56:44 <kodaws> hi, i have a question regarding a cabal script
00:56:50 <zomg> you can just disable automatic output buffering, I believe it might be disabled by default actually
00:56:52 <pharaun> mm_freak: can't you still try to write the code in a modular/functional approach, IE don't muck with global state, so on?
00:56:59 <pharaun> which seems like it would help
00:57:14 <kodaws> can i list the build-depends for certain operating systems only?
00:57:14 <zomg> fatal errors aren't really such a big deal since having a fatal error crashes the application anyway
00:57:28 <kodaws> eg. use the unix package only on unix and not on windows?
00:57:44 <mm_freak> pharaun: that's what i was doing, but ultimately, especially when you're in a team which you don't lead, PHP sooner or later becomes a maintainance hell
00:57:45 <tgirod> hi. Running ghc 7.6.1 on archlinux here. When I try to manually compile a library (not using cabal install), I get the following error : "Could not find module `Distribution.Simple'. it's like Cabal is not in ghc's path anymore ... what could be the cause ?
00:57:53 <mm_freak> and then the security problems start
00:58:07 <zomg> mm_freak: yeah that's absolutely true :P
00:58:20 <zomg> you need to have good programmers in your team
00:58:28 <pharaun> mm_freak: point taken, got similar experience with some other large system, it sucks
00:58:30 <zomg> or at least ones who are capable of listening to what you tell them about their shitty code and how to fix it..
00:58:56 <zomg> Unfortunately I had a bad programmer, a bad programmer incapable of listening, and one good programmer in my team
00:59:07 <pharaun> zomg: well if the language also *helps* you to write secure/contained/isolate by default
00:59:20 <pharaun> it can go a long way to help, but yes bad coder exists in all language
00:59:23 <zomg> Keyword had. Now it's just me so it's fine
00:59:24 <zomg> lol
00:59:39 <mm_freak> zomg: i don't blame the programmers…  they were good imperative programmers…  it's simply that conceptual problems slip through, and that i'm just a human as well
01:00:03 <mm_freak> in a commercial setting you sometimes get feature requests you can't really map to your current system
01:00:14 <mm_freak> so you start patching
01:00:19 <mm_freak> you know the problem
01:00:39 <pharaun> you can think about it, which would you rather have? a system/environment that encourages/makes the secure/solid/good path the low friction one, and the hacky one being the higher friction, or the other way around?
01:00:54 <pharaun> i would prefer to code in a language that makes doing things in a solid/secure manner as *easy* as possible
01:00:58 <pharaun> yes i can still screw up
01:01:02 <zomg> If you have solid foundation you can write things in modular non hacky fashion in PHP too
01:01:12 <zomg> But obviously it requires you to first understand what you're doing pretty well
01:01:23 <pharaun> yes that is true, but at the same time you will need to make sure to keep in mind xyz for everything you use
01:01:33 * hackagebot Elm 0.5.0 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.5.0 (EvanCzaplicki)
01:01:33 <pharaun> versus a smaller core isolated chunk at a time
01:01:38 <zomg> and it seems about 95% of the PHP haters are completely incapable of grasping subjects like structured programming, modularity or ioc
01:01:45 <dmwit> I have never before been so curious about the context of a quote.
01:01:55 <zomg> or any of the other OOP concepts like law of demeter etc.
01:01:57 <dmwit> spj: "You do the category theory, and you talk to Gordon. And he talks to Phil. And Phil talks to me."
01:02:25 <Jafet> The way people continue to defend PHP is astonishing.
01:02:25 <pharaun> zomg: hm? i work on several very very large system in python and while it has some issues its still fairly solid, it uses lots of the good code base management tricks/etc to try to isolate/contain/etc
01:02:37 <zomg> so because they just happened to live in a land with totally shitty code they just go like yeah the language is a turd because all I lived in was a turd :P
01:02:59 <mm_freak> zomg: i don't think PHP supports modularity that well…  OOP as done in PHP is very stateful, to a degree where you lose track of the state, and the problems can be banal
01:03:12 <zomg> pharaun: sure, that's what I'm saying. It just takes some effort to put it together and discipline to not slap hacks all over the place
01:03:24 <mm_freak> for example PDO by default reports errors through return values, and you forgot to set it to use exceptions instead
01:03:28 <mm_freak> that happened to me countless times
01:03:41 <zomg> it doesn't have any more state in the OOP implementation than Java
01:03:44 <mm_freak> now even the type of error reporting is state
01:03:47 <mm_freak> it's madness
01:03:50 <pharaun> zomg: this is true :) i think in general i would prefer a language that encourages that discipline by default than the other way around, makes it easier to bring new hires onboard and new people onboard, so on
01:04:00 <zomg> you can talk about specific libraries of course but those are issues with the libs, and you can always use some better library
01:04:04 <pharaun> but as always ymmv
01:04:46 <mm_freak> zomg: the non-stateful variant is either too slow or your colleagues don't understand it
01:04:56 <zomg> pharaun: availability of people who know a language makes it easier to bring onboard hires and that's why PHP is being used sadly
01:04:59 <zomg> lol
01:05:19 <mm_freak> i remember implementing iteratees in PHP to tackle stream processing
01:05:43 <zomg> mm_freak: not having any problems using Doctrine 2 which throws errors as exceptions, and even the most inexperienced programmer in our team had no problems with it after some initial hand holding =)
01:05:45 <mm_freak> it worked very well, but the code was long and ugly, and my colleagues didn't get it
01:05:58 <pharaun> zomg: well eh, at my workplace, we don't require knowledge in python, just... proof of good quality code in any XYZ similar language and we can usually train them up no problem
01:06:25 <zomg> But yeah I bet it's pretty easy to get stuck with pretty poor programmers in PHP-land if you're unlucky :P
01:06:32 <mm_freak> anyway, i think we agree that PHP is an unfortunate choice =)
01:06:38 <pharaun> zomg: i mean its easier if they already know the language, if not, its still worth it to train them cos typically most folks we hire already know several language so they can be decent at picking up new ones
01:06:49 <zomg> thankfully the old CTO knew his way around code and such so he was capable of hiring people who knew what they were doing to at least a degree
01:07:00 <zomg> mm_freak: yeah that I can agree on, lol
01:07:25 <zomg> here it's just a crapton easier to find people who are decent in PHP than in most alternatives...
01:07:28 <zomg> sadly
01:07:39 <Jafet> It's probably a worse idea to hire PHP programmers than, say, ruby programmers.
01:07:58 <zomg> I haven't seen a single job ad for ruby programmers here
01:08:01 <zomg> Not a single one.
01:08:05 <Jafet> Then make one.
01:08:08 <pharaun> heh
01:08:30 <zomg> Jafet: yeah I'll just rewrite our application entirely in Ruby which I have never used
01:08:33 <zomg> lol
01:08:56 <pharaun> well to a certain degree no matter what language you put out for hiring you will almost always get crap, average, great folks applying, also lots of other... incentives can adjust that
01:09:09 <zomg> http://www.youtube.com/watch?v=nVE09yyznfc
01:09:51 <mm_freak> if you hire haskell programmers and verify that they can actually write haskell code, chances are it's a good programmer
01:09:57 <Jafet> If you find yourself writing PHP for a living, you should really ask yourself what you are doing with your life.
01:10:04 <Jafet> I am not kidding
01:10:10 <zomg> Yay another moron
01:10:18 <mm_freak> a good programmer isn't someone who can do everything…  it's someone who can /learn/ everything
01:10:31 <pharaun> mm_freak: dunno, i haven't had a chance yet to interview a haskell programmer who has applied yet :)
01:10:51 <zomg> If I wanted to work with haskell I'd have to move to Helsinki
01:10:55 <zomg> Not very interested
01:11:01 <mm_freak> pharaun: if your company is near stuttgart, germany, let me know ;)
01:11:07 <pharaun> no remote work options?
01:11:13 <mm_freak> sure
01:11:20 <pharaun> mm_freak: hehe unfortunately not
01:11:33 <zomg> Remoting? Finnish companies have never heard of such
01:11:45 <pharaun> ah that's unfortunate
01:11:45 <zomg> Is it like with your telly where you press buttons on a thingy and it changes channels?
01:11:48 <zomg> lol
01:12:20 <zomg> Hell I wouldn't mind working for some foreign company but remoting options are pretty limited with most jobs
01:12:38 <mm_freak> i mostly work remote anyway
01:13:12 <zomg> Yeah the positions exist but they're pretty rare in comparison to the non-remote ones
01:13:13 <ziman> what's the usual approach to parsing layout-based code (like haskell or python)? google is not especially enlightening
01:13:15 <Jafet> zomg: you don't need to use Haskell in particular, just any language with some trace of culture. PHP is like one of those island tribal languages -- yay, you can count to five.
01:14:05 <mm_freak> ziman: trifecta, probably
01:14:09 <nicoo> ziman: http://michaeldadams.org/papers/layout_parsing/
01:14:14 <zomg> Jafet: yes, thank you for this clever remark. I have used PHP, JS, TCL, Python, Perl, C, C#, Java, Scala, Lua, Prolog, Haskell, Scheme, Clojure and probably some others I forgot
01:14:37 <pharaun> mm_freak: heh been meaning to ask but is the mm_ in your name inspired by _mm_* intrinsics for simd/sse?
01:15:01 <ziman> mm_freak, nicoo, thanks, I'll have a look
01:16:19 <mm_freak> pharaun: no, it doesn't really have a meaning
01:16:41 <pharaun> aha heh figures :) was just wondering, ive done simd programming before
01:17:34 <nicoo> pharaun: I admit I asked myself the same question ;)
01:17:42 <pharaun> i find it funny that it took me a little bit to wrap my head around conduits and so on but its not too bad now that i'm used to it
01:17:59 <pharaun> nicoo: :D glad to know i'm not the only one that wondered that
01:18:44 <mm_freak> pharaun: feel free to read it as "M&Ms", the german candy =)
01:19:12 <pharaun> haha :)
01:19:34 <mm_freak> or as MM, the sekt ;)
01:19:55 <Jafet> I wonder what "freak" means then
01:20:04 <t7> how do i do long division ?
01:20:09 <nicoo> mm_freak: Or as Memory Managment ?
01:20:10 <osfameron> M&Ms are German?
01:20:24 <mm_freak> t7: as in?  Integer division?  div?
01:20:34 <t7> on paper
01:20:39 <osfameron> "M&M's originated in the United States in 1941" according to wikipedia
01:20:54 <pharaun> t7: uh been years since i've done that, check the wiki?
01:20:57 <nicoo> t7: Are you sure this is the right place to ask, then ?
01:21:13 <t7> lets say i am writing a haskell program to emulate doing divion on paper
01:21:27 <pharaun> t7: aha, then i think wikipedia has an article on that
01:21:31 * nicoo just cannot be bothered to explain, and points at http://en.wikipedia.org/wiki/Long_division#Basic_procedure_for_long_division_by_longhand
01:21:37 <mm_freak> t7: wikipedia explains that very well
01:21:42 <Ferdirand> do it it binary, it's much easier !
01:22:13 <nicoo> Ferdirand: Most people who can convert easily between decimal and binary know how to do long div :p
01:22:21 <Ferdirand> nicoo: shhhh
01:22:30 <Nereid> long division can be done over any euclidean domain, you should write a general one for that :p
01:23:06 <Nereid> hmm
01:23:10 <Jafet> If you remove the type signature, it would probably already work over any euclidean domain
01:23:22 <t7> i have to calculate greatest multiple in my head
01:23:28 <t7> this sucks
01:23:49 <mm_freak> > let myDiv x y | x < y = 0 | otherwise = 1 + myDiv (x - y) y in myDiv 17 5
01:23:50 <lambdabot>   3
01:23:52 <Nereid> long division of integers is a bit different though
01:23:58 <mm_freak> long division, where long is in terms of time =)
01:24:06 <Nereid> haha
01:24:13 <t7> what about chinese remainder ?
01:24:27 <Jafet> @src div
01:24:27 <lambdabot> Source not found. My brain just exploded
01:24:33 <pharaun> haha
01:24:35 <mm_freak> CRT is easy enough in software
01:25:05 <Jafet> Why do people say they're implementing a theorem
01:25:14 <t7> im thinking of russian peasants algorythm or something
01:25:14 <Jafet> The name always seems strange
01:25:25 <Nereid> you're right, they should say they're implementing a proof instead.
01:25:31 <t7> oh its multiplication :(
01:26:03 <hpaste> “Ertugrul Söylemez” pasted “Chinese Remainer Theorem Solver” at http://hpaste.org/76747
01:26:04 <Ferdirand> by the way, i was amazed to learn from a french school pupil that they are taught to compute gcd with Euclid's algorithm now (used to be full factor decomposition)
01:26:16 <Ferdirand> as a side effect, they are no longer taught about prime numbers before college :/
01:26:19 <mm_freak> t7: see the paste…  that's my variant
01:26:33 * hackagebot elm-server 0.5.0 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.5.0 (EvanCzaplicki)
01:26:56 <Jafet> Oh, I thought you were amazed that they were taught about the gcd
01:27:22 <nicoo> Ferdirand: Yeah, that's kinda stupid.
01:27:51 <nicoo> A teacher was once surprised I knew algorithm X for simplifying integer square roots.
01:27:56 <Jafet> Well, Euclid's algorithm runs in polynomial time
01:28:00 <Ferdirand> no, i was taught in primary school about gcd by doing complete prime factor decomposition and picking the intersection by hand
01:28:04 <nicoo> I didn't, I just knew how to factor.
01:28:12 <mm_freak> Ferdirand: me too
01:28:18 <Ferdirand> so when much later on I learnt about Euclid, boy I was so pissed off
01:28:27 <mm_freak> but i think that's fine
01:28:37 <nicoo> Jafet: Humans brains just give up before one reaches asymptotic complexity ;)
01:28:47 <mm_freak> when given small numbers i still do it that way
01:29:01 <mm_freak> only for large numbers i do euclid's algorithm
01:29:08 <mm_freak> and not the original one =)
01:29:53 <Jafet> nicoo: not when they didn't have electronics
01:30:07 <Ferdirand> but apparently they consider the only usefulness of prime numbers was to compute gcds, and introducing Euclid's alg. in the cursus made them irrelevant
01:30:12 <Ferdirand> which I find kind of sad
01:30:22 <mm_freak> > let originalGCD x 0 = x; originalGCD x y | x < y = originalGCD y x; originalGCD x y = originalGCD (x - y) y in originalGCD 12 15
01:30:25 <lambdabot>   3
01:30:44 <Jafet> I thought the Original Algorithm used division.
01:31:00 <Jafet> And that was, Knuth's rebuttal or something
01:31:34 <mm_freak> the original algorithm gets along with comparison and subtraction
01:32:38 <nicoo> Ferdirand: Btw, French students learn about primes in high school, not college ;)
01:33:49 <Ferdirand> nicoo: well maybe that depends on the school. I was helping a pupil with her maths the other day, she was near the end of high school and didn't know about prime numbers
01:34:22 <Ferdirand> also, they ask them to compute derivatives but they weren't told that sqrt(x) is x^(1/2) or that 1/x is x^(-1)
01:35:40 <Jafet> nicoo: http://en.wikipedia.org/wiki/Frank_Nelson_Cole
01:41:54 <nyc> Why not employ quotRem?
01:43:14 <Jafet> People don't know that sqrt(x) is x^(1/2)? Hmm.
01:44:15 <nicoo> Ferdirand: Suckish teacher, then
01:44:36 <Ferdirand> most likely, yes
01:45:23 <nicoo> Jafet: Wow
01:46:21 <Jafet> (Imagine if Cole had known about the rho method!)
01:50:11 <t7> > 2481946 `mod` 16
01:50:13 <lambdabot>   10
01:50:40 <t7> > 2481946 `div` 16
01:50:42 <lambdabot>   155121
01:50:50 <t7> i cant do long division
01:50:58 <t7> my modulo was correct
01:51:02 <t7> modulus ?
01:51:21 <Jafet> Remainder?
01:51:47 <hpaste> t7 pasted “long division failure ” at http://hpaste.org/76748
01:51:54 <Jafet> Subtrahend? I'm not sure why we keep using these archaic names
01:52:38 <Nereid> t7: 2481946 is not 6481946
01:52:55 <Nereid> > 6481946 `divMod` 16
01:52:56 <lambdabot>   (405121,10)
01:53:08 <nicoo> Jafet: He would have gotten repetitive strain injury from rolling dices ;)
01:53:56 * Nereid thinks about how one would do long division in other filtered rings
01:54:26 <nyc> Minuends and subtrahends are out there.
01:55:15 <Jafet> Cole would have gotten the factor after 5527 rounds, using the generator x^2+1
01:56:38 <Nereid> I wonder if there's some norm-like thing on pairs of numbers that tells you how many steps the euclidean algorithm would take on them.
01:56:50 <Nereid> or if anyone cares.
01:57:24 <Jafet> Are you sure it would be a norm
01:57:30 <Jafet> I'm doubting it
01:57:57 <Nereid> hence -like
01:58:13 <Ferdirand> the worst case is when you take numbers from the fibonacci sequence, right ?
01:58:28 <Jafet> Yes, that is used to give the time complexity
01:58:29 <Nereid> yeah
02:01:36 <t7> oh lol :) its early and i have a headache
02:04:52 <t7> > divMod 725842 15
02:04:53 <lambdabot>   (48389,7)
02:05:06 <t7> close :S
02:06:27 <Nereid> protip:
02:06:39 <Nereid> so you can represent any integer as a finite sequence of digits.
02:06:58 <Nereid> er, wee the positive ones you can.
02:07:00 <Nereid> well*
02:07:16 <Nereid> and you can define addition and multiplication by the usual digit-by-digit things.
02:07:18 <Nereid> with currying and whatnot.
02:07:30 <Nereid> now the cool part:
02:07:47 <Nereid> you can actually extend this to sequences that are infinite to the left.
02:08:01 <Nereid> i.e. you have a ones digit, a tens digit, ... a 10^n's digit,
02:08:14 <Nereid> but no more restriction that only finitely many of these are nonzero.
02:08:36 <randomclown> where is the Condit constructor
02:08:39 <Nereid> and what you end up with is the 10-adic numbers.
02:08:44 <randomclown> conduit*
02:08:48 <gehmehgeh> whois Philonous_
02:09:08 <Nereid> er, 10-adic integers
02:12:42 <Nereid> and you get stuff like ...999 + 1 = 0 (because adding 1 gives you a 0 with a carry, and ..., and the carry goes infinitely off to the left and you are left with all zeros
02:13:51 <Nereid> and ...6667 * 3 = 1, so 1/3 = ...6667
02:14:52 <Nereid> except 10 isn't a very good base to work in, because you have zero divisors.
02:15:02 <Nereid> you want a prime instead of 10.
02:22:51 <Nereid> for instance, ...890625 * ...109376 = ...000000
02:24:10 <Nereid> (the the first factor 1 mod every power of 2, and divisible by every power of 5; the second is 1 mod every power of 5 and divisible by every power of 2.)
02:24:31 <Nereid> (so their product must be divisible by every power of 10, so all its digits are 0.)
02:27:36 <yitz> Nereid: two interesting exercises for you. 1. construct two non-zero 10-adic numbers whose product is 0. 2. what is the smallest non-square integer that has a square root in the 10-adic integers?
02:27:49 <yitz> ah you did #1 already
02:30:05 <yitz> Nereid: you can represent negative numbers too. e.g. -3 = ...9997
02:30:12 <Nereid> I did say that.
02:30:28 <Nereid> working on 2. just computing a couple things :v
02:31:15 <Nereid> it's 20, isn't it.
02:32:27 <Nereid> I don't care enough to write out the square root though.
02:32:46 <statusfailed> Hmm.. The default Arbitrary instance for Double seems to always give zero
02:33:14 <Nereid> @check (\x -> x == 0) :: Double -> Bool
02:33:15 <lambdabot>   Couldn't match expected type `GHC.Types.Double -> GHC.Bool.Bool'
02:33:29 <Nereid> wh
02:33:45 <Nereid> @check ((\x -> x == 0) :: Double -> Bool)
02:33:46 <lambdabot>   "Falsifiable, after 1 tests:\n1.0\n"
02:34:45 <Nereid> yitz: I forget exactly why we can lift square roots in Z/8Z to Z_2, but yeah.
02:34:58 <Nereid> just take the smallest integer that has a square root both mod 8 and mod 5.
02:37:11 <statusfailed> Nereid: how do I get a single value of Double using Arbitrary
02:37:22 <statusfailed> I'm using sample' but it seems like that's wrong
02:37:30 <statusfailed> i'm using it to generate random data, not test
02:38:47 <statusfailed> wow ok. sample' generates 0.0 as the first item in the list always
02:38:49 <statusfailed> but the rest are random
02:38:50 <statusfailed> bizarre
02:39:25 <Nereid> interesting
02:39:52 <Nereid> well 0 is always a nice one to check.
02:40:05 <statusfailed> sure, I think i'm probably using sample' in a way it's not supposed to be used
02:40:08 <statusfailed> rather than that being a bug
02:47:02 <t7> is there a gnu matlab clone thing?
02:47:09 <Nereid> octave?
02:47:21 <t7> will it tell me if n is prime
02:47:34 <Nereid> there is an isprime function
02:47:46 <dzhus> you can you factor program as well
02:47:55 <dzhus> *use
02:56:35 * hackagebot process-conduit 0.5.0.3 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-0.5.0.3 (HideyukiTanaka)
03:06:11 <maus_> hi, I tried to derive a Binary instance for my data type with UTCTime field. I've got an error saying there is no Binary instance for UTCTime. Well, that's expected. But after I tried to derive it too I got  "Not in scope: data constructor `MkDiffTime'". It seems to be a private constructor buried in the library. How to circumvent this?
03:07:20 <maus_> forgot to say, I used a Data.Derive library to generate instances
03:10:15 <hpaste> snickerz777 pasted “wxc build error 2” at http://hpaste.org/76749
03:11:09 <snickerz777> is there anyone, wo can help me building wxhaskell
03:14:56 <lhk> im just following this incredible tutorial tryhaskell.org
03:17:59 <t7> 1μg = 0.000001 ?
03:18:04 <t7> or 6 zeros
03:18:21 <shachaf> I think you missed a g.
03:19:46 <lhk> ive got a problem following the tutorial
03:19:48 <lhk> let var = expression in body
03:19:56 <lhk> what is the sense of body
03:20:08 <lhk> for example what does this do `?
03:20:13 <t7> lhk: body is the important part
03:20:16 <lhk> let x = 8 * 10 in x + x
03:20:28 <t7> > let x = 8 * 10 in x + x
03:20:29 <lambdabot>   160
03:20:38 <lhk> i dont get it
03:20:50 <lhk> if i try to access x after that its "not in scope"
03:21:01 <lhk> why cant i just declare a variable
03:21:02 <shachaf> lhk: It's only in scope for the "in" part.
03:21:08 <shachaf> lhk: You can, but not in tryhaskell.org
03:21:29 <lhk> so it executes the in part with the variable declared in the let part ?
03:21:35 <shachaf> Pretty much.
03:21:57 <lhk> do i need this outside of tryhaskell.org too ?
03:22:17 <shachaf> "let ... in ..." is part of Haskell, and useful everywhere.
03:22:23 <shachaf> You need to understand it.
03:22:50 <lhk> so far i see only one use case: if i need to bind a value to a name for just one expression
03:23:04 <lhk> and want the value to be "deleted" afterwards
03:23:04 <shachaf> Yep, that's the only use case.
03:23:12 <shachaf> Well, there's no notion of "afterwards".
03:23:13 <lhk> ok, thanks
03:23:21 <shachaf> But it's a very useful use case, as it turns out.
03:23:41 <lhk> interesting. its really great to follow the tutorial and chat at the same time
03:24:17 <shachaf> This isn't a channel just for tryhaskell.org, mind you.
03:24:24 <shachaf> Most people here have never used that. :-)
03:31:38 <Nereid> lhk: tryhaskell.org is limited to one-liners, so there's a lot of cool stuff you can't do on there
03:32:09 <shachaf> Things like... Two-liners.
03:32:12 <shachaf> Or three-liners.
03:32:14 <Nereid> :D
03:32:28 <Nereid> lhk: you should go get the haskell platform, which includes ghc, which includes ghci
03:32:43 <shachaf> My Haskell Platform didn't include GHC. :-(
03:32:55 <lhk> im at an internet terminal killing time , no way to install ghci
03:33:02 <Nereid> ghci is an interactive interface, but you can define variables and load other modules and stuff...
03:33:03 <Nereid> ah.
03:33:21 <Nereid> ...and you can do IO.
03:33:21 <lhk> ill give it a try when im home
03:33:26 <Nereid> @where platform
03:33:26 <lambdabot> http://hackage.haskell.org/platform/
03:33:30 <Nereid> ^ there's the link.
03:33:46 <randomclown> with conduits, how do you write a split function?
03:33:51 <Nereid> what's a split function?
03:33:51 <deech> Hi all, is there a compiler plugin or utility that shows a trace of deductions made by the type checker in case of a compiler error?
03:34:18 <Jafet> Compiler error? Your compiler has an error?
03:34:19 <hamid> hmm pattern matching works in a top-down way. :??
03:34:41 <Jafet> It works in a pattern matching way.
03:34:47 <nikita-0> Why does the following typecheck:
03:34:48 <randomclown> Nereid: i.e. bytestring goes in, send out a sections of a bytestring
03:34:48 <deech> Jafet: Nope. I meant the error spit out by the compiler.
03:34:50 <nikita-0> data XY = Xrec { a :: Int } | Yrec { a :: Int, b :: Int }
03:34:50 <nikita-0>         deriving (Eq, Ord, Show, Read);
03:34:50 <nikita-0> fxy :: XY -> XY
03:34:50 <nikita-0> fxy t = t { a = (a t) + 1, b = (b t) + 2 * (a t) };
03:34:58 <hamid> Jafet, Warning: Pattern match(es) are overlapped
03:35:05 <nikita-0> It's clearly unsafe to call fxy Xrec { a = 0 }
03:35:15 <nikita-0> ?
03:35:23 <Jafet> Ok, yes. Pattern matches are tried from the top one.
03:35:34 <randomclown> Nereid: I'm looking at their lines function and trying to copy it, it's super confusing though
03:35:43 <shachaf> nikita-0: Because "b" is an unsafe function.
03:35:55 <Jafet> deech: I don't know one, but the usual way is to add type signatures to parts of the program.
03:35:56 <shachaf> GHC generates unsafe accessors automatically.
03:36:23 <nikita-0> shachaf: I mean, this is a loophole in a static type system. Why does it exist?
03:36:35 <Nereid> the types are fine.
03:36:36 * hackagebot mongoDB 1.3.1 - Driver (client) for MongoDB, a free, scalable, fast, document  DBMS  http://hackage.haskell.org/package/mongoDB-1.3.1 (FedorGogolev)
03:36:39 <shachaf> nikita-0: Why does GHC generate unsafe accessors?
03:36:41 <shachaf> For convenience.
03:37:01 <Philonous> nikita-0:  It's not a loophole in the type system. You can write non-exhaustive pattern matches by hand
03:37:02 <shachaf> They will crash your program if you use them.
03:37:07 <Nereid> it exists for the same reason non-exhaustive pattern lists exist.
03:37:14 <nikita-0> Why does the language standard allows statically unsafe expressions, that can easily be rejected.
03:37:21 <shachaf> Nereid: To be fair, GHC won't generate a compiler warning for an unsafe accessor.
03:37:26 <Nereid> fair.
03:37:30 <Nereid> maybe it should.
03:37:49 <shachaf> Well, it's only unsafe to use it as a function, not for pattern-matching.
03:37:56 <shachaf> So figuring out where to put the warning is tricky.
03:38:08 <Nereid> hmm.
03:38:29 <Jafet> Place the warning where it is used as a function.
03:38:48 <shachaf> That could be quite a lot of warnings.
03:38:49 <nikita-0> Philonous: it's a loophole in the same sense as C union or cast is a loophole.
03:39:18 <shachaf> Well, this'll crash your program with a ⊥ value, not segfault. :-)
03:39:18 <Nereid> solution: don't use accessors for sum types in the first place.
03:39:49 <nikita-0> shachaf: bottom is undistinguishable from non-termination as they say. :-)
03:39:53 <Philonous> nikita-0:  But you're not casting anything. Everything has the right type, it's just that you have a partial function
03:40:09 <jix> nikita-0: but bottom is a valid value for Int, so the types of your example are perfectly fine
03:40:27 <shachaf> nikita-0: When you write your data declaration, GHC generates this code: b :: XY -> Int; b (Yrec _ x) = x; b _ = error "oh no!"
03:40:30 <Nereid> data XY = X X | Y Y; data X = Xrec { a :: Int }; data Y = Yrec { b :: Int, c :: Int }
03:40:36 <nikita-0> Philonous: by that argument Smalltalk is staticly types, it's just that some functions end with "descriptor not found".
03:40:40 <Nereid> then you can still use a and b for patterns
03:40:41 <beaky> hello
03:40:45 <nikita-0> s/types/typed/
03:40:54 <Nereid> f (X Xrec {a = a}) = ...
03:41:24 <shachaf> nikita-0: Haskell is statically typed but unsafe functions will indeed allow you to make invalid code type-check.
03:41:27 <beaky> this isn't specifically haskell, but what parts of FP will help me become a better imperative programmer?
03:41:28 <shachaf> That's why they're called unsafe.
03:41:33 <nikita-0> Nereid: I known how to avoid the issue. I an wondering why it was introduced in the language in the first place.
03:41:47 <shachaf> It's a bit unfortunate that the Report requires GHC to generate unsafe functions.
03:42:01 <Nereid> nikita-0: for the same reason they let you write non-exhaustive patterns.
03:42:11 <nikita-0> Hmm.. OK. :-)
03:42:28 <jix> nikita-0: or for the same reason the prelude has the head and tail functions
03:42:44 <Nereid> data XY = X {a :: Int} | Y {b :: Int} is just as unsafe as
03:42:45 <bxc> anyone here was at the london HUG last night?
03:43:03 <Nereid> data XY = X Int | Y Int; a (X a') = a'; b (Y b') = b'
03:43:44 <Jafet> Why is (b t) even evaluated, anyway?
03:43:55 <Jafet> The record being updated has no b.
03:43:56 <Philonous> nikita-0:  That has nothing to do with dynamic typing. You can either have a guaranteed bottom-free language or a turing-complete one. It's unfortunate that ghc generates a partial function for you and doesn't even emit a warning, but there is nothing wrong with partial functions in principal
03:44:19 <Philonous> principle*
03:44:55 <shachaf> Hah, Jafet is correct.
03:45:28 <nikita-0> 3.15.3: "An execution error occurs when the value being updated does not contain all of the specified labels."
03:45:35 <Philonous> Jafet:  YRec has a b field
03:45:54 <shachaf> Philonous: Yes, but in that case there's no problem.
03:46:06 <nand`> nikita-0: Haskell rejects some bits of purity and safety in favor of convenience. You can see it as hypocritical if you want, but at the end of the day, it's what lets Haskell be relevant for real world usage rather than just an academic toy
03:46:30 <Jafet> That is a stupid argument
03:46:44 <nikita-0> nand`: I agree. It is just seems that this particular bit is not at all that critical.
03:47:08 <nand`> I think so too; I think partial record fields should be rejected at compile time. I've never needed one personally
03:47:16 <t7> agreed
03:47:30 <nikita-0> Philonous: this definitely looks like a dynamica typing: the presense of a field is checked at run-time.
03:47:46 <merijn> nikita-0: No it isn't
03:47:47 <yitz> Nereid: sorry wasn't watching. no it couldn't be 20. if 20 has a sqrt then so does 5.
03:47:48 <t7> LETs march on Cambridge!
03:47:53 <merijn> nikita-0: The presence of a field isn't checked at all
03:48:08 <nikita-0> merijn: the standard say so, see quote above.
03:48:12 <nikita-0> says.
03:48:22 <shachaf> merijn: Sure it is.
03:48:23 <nand`> nikita-0: but it's not checked at runtime
03:48:25 <t7> also, div should be total
03:48:27 <Nereid> yitz: why?
03:48:33 <nand`> well, depending on what you mean by ‘checked’
03:48:57 <nand`> the quote just truthfully says that an error occurs when you try to access or update a non-present field
03:49:04 <yitz> multiply by 0.5
03:49:05 <merijn> shachaf: How so? I wouldn't call this checking: "accessor (XRec _ y) = y; accessor _ = undefined"
03:49:05 <Nereid> yitz: why should the square root of 20 be divisible by 2?
03:49:16 <Nereid> there is no 0.5 in the 10-adics
03:49:28 <Nereid> integers
03:49:30 <fenton> how do i determine or set the path that ghc looks for libraries in/at?
03:49:32 <yitz> there is now :).
03:49:36 <Nereid> nope
03:49:41 <shachaf> strace!
03:49:47 <Philonous> nikita-0:  Dynamic typing means the types are checked at run time, but ghc doesn't even keep them, they get erased during compilation. This is merely pattern matching.
03:50:22 <merijn> fenton: Usually you'd use cabal and let cabal worry about where to find libraries
03:50:29 <shachaf> GHC isn't checking types at runtime, but it's checking values at runtime.
03:50:38 <nand`> ^
03:50:40 <Nereid> yitz: you don't have me convinced at all.
03:50:44 <Jafet> GHC! In mah runtime!
03:50:46 <nikita-0> Philonous: access to a record or method is *the* standard case to tell static typing from dynamic. All textbooks on type systems treat this.
03:50:48 <Nereid> you can't juts say "there is now".
03:50:48 <merijn> shachaf: Not even that, it's just pattern matching...
03:50:52 <Nereid> just*
03:50:54 <nand`> GHC is pattern matching; pattern matching is inevitably done at runtime
03:50:58 <shachaf> merijn: That seems a whole lot like "checking values" to me.
03:51:02 <merijn> nikita-0: There is no such thing as method
03:51:06 <yitz> Nereid: if 20 has a sqrt in z_10[1/10] then the sqrt must actually be in z_10, so that's a proof. anyway, not needed, just try to compute me a sqrt for 20, you won't get very far.
03:51:08 <shachaf> Nothing is inevitable, nand`
03:51:17 <merijn> nikita-0: record syntax is just syntactic sugar for generating functions that work like accessors
03:51:22 <nikita-0> merijn: in Haskell there isn't. In textbooks there is.
03:51:41 <Philonous> nikita-0:  That's nonsense. What's going on behind the scene is that you pattern match the value and when you end up with one that (statically) doesn't have the field you throw an error
03:51:44 <shachaf> nikita-0: If you want to call Haskell dynamically typed, you're allowed to do that.
03:51:45 <merijn> nikita-0: There is no notion of "records" in the types and thus no notion of methods, fields, etc.
03:51:49 <shachaf> nikita-0: The words don't matter here.
03:52:02 <nand`> the textbook difference between static typing and dynamic typing is that static typing erases types at compilation, if you ask me
03:52:09 <Philonous> nikita-0:  b{x=t} would be statically rejected
03:52:22 <nikita-0> merijn: you can claim the same way that types don't exist, because they are erased "behind the scene" anyway.
03:52:35 <shachaf> nand`: That's a rather operational definition...
03:52:37 <fenton> is it okay to have many versions of the same package installed with cabal install?
03:52:57 <merijn> fenton: Sure
03:52:58 <nikita-0> Records are an abstraction presented by the language.
03:53:06 <fenton> merijn: thank you!!!
03:53:14 <nand`> shachaf: it's not a definition, it's an observational difference
03:53:14 <nikita-0> If compiler reduces them to some other kernel construction internally, this is a compiler business.
03:53:15 <merijn> nikita-0: No, they're syntax presented by the language
03:53:17 <Nereid> yitz: ok, well I was wrong about something, then. because it doesn't have a square root in Z/(32)
03:53:27 <nand`> I don't know how to define it, for starters because I don't know what model would be applicable to reason about such things
03:53:41 <yitz> Nereid: ok that works too
03:53:42 <Nereid> 2 sucks.
03:53:51 * shachaf senses an argument about words going on here.
03:53:58 <shachaf> Words are worthless.
03:54:03 <nikita-0> merijn: are you arguing that a haskell program should be understood by first mentally translating it into the kernel?
03:54:33 <shachaf> The argument that you're having will bring no joy to your lives.
03:55:15 <Jafet> @quote argument
03:55:18 <lambdabot> ex0r says: if map was a woman she could probably handle infinite arguments
03:55:27 <companion_cube> -_-
03:56:04 <Nereid> yitz: 41, then.
03:56:04 <shachaf> Not a very good quote.
03:56:12 <shachaf> I move to @forget
03:56:13 <yitz> Nereid: yay!
03:56:30 <merijn> shachaf: Yeah, I'm tapping out and getting back to my life
03:56:35 <companion_cube> funny, but maybe offensive
03:56:40 <Philonous> nikita-0:  Btw. there is an argument that dynamicly typed languages are really statically typed languages with just one type (Uni-typed) and a lot of pattern matching. If you want to buy into that argument is for you to decide, it doesn't make haskell dynamically typed, though.
03:56:42 <Jafet> @quote words
03:56:42 <lambdabot> geheimdienst says: pictures are for wussies. just write a thousand words instead
03:56:59 <Jafet> @quote Wittgenstein
03:56:59 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
03:57:10 <companion_cube> @quote recursion
03:57:10 <Nereid> yitz: for some reason I thought something was a square in Z_2 iff it was a square in Z/8, but obviously that's wrong
03:57:11 <lambdabot> elliott says: Explicit recursion should generally be avoided. Also, general recursion should be explicitly avoided!
03:57:42 <skchrko> Philonous: it's not merely an argument, it the truth!
03:57:49 <skchrko> *it's
03:57:58 <Philonous> skchrko:  Fair enough
03:58:21 <Nereid> but ok, I'm told an odd element of Z_2 is a square iff it is 1 mod 8.
03:58:45 <nand`> in a sense, that's what Dynamic corresponds to
03:58:49 <merijn> skchrko: For certain values of truth
03:59:21 <nand`> a single type that encodes some arbitrarily typed value together with its typing information that you can pattern match against in order to safely cast something (or not)
03:59:31 <nand`> “pattern match”*, it's not exposed
04:00:03 <yitz> Nereid: people generally ignore n-adics for n non-prime because of them not being integral domains. but it was fun to discover that they can actually be interesting.
04:00:07 <Jafet> That's not a useful way to think about dynamic typing.
04:00:31 <Nereid> yitz: well, for n non-prime you can decompose it as a product of p-adics for p prime
04:00:35 <Nereid> Z_10 = Z_2 x Z_5
04:01:03 <Nereid> so still not that interesting :p
04:02:05 <Nereid> ah here, a slight generalization of hensel's lemma.
04:02:32 <Nereid> in the notation of http://en.wikipedia.org/wiki/Hensel%27s_lemma
04:02:37 <Nereid> it suffices to have |f(r)| < |f'(r)^2|
04:02:50 <yitz> Nereid: that decomposition is not totally trivial. both components consist of numbers that all have infinitely many digits, except zero. but yeah i guess so.
04:02:51 <Nereid> in Z_p
04:03:04 <nikita-0> Philonous: for me, static typing is a syntactic discipline that prevents certain types of program behaviour from happening. Dereferencing a non-existing "selector" is a classical example of such nehaviour.
04:03:05 <Nereid> yitz: but it's an obvious decomposition by the CRT.
04:03:15 <yitz> Nereid: i guess that also motivates why the adeles are not totally ad hoc
04:03:51 <yitz> Nereid: even though at first it seems like you are just artificially gluing all the places together into a big lump
04:03:56 <nand`> nikita-0: the problem here is that the type can't tell you whether a selector exists or not
04:04:31 <Philonous> nikita-0:  Than you have a heterodox understanding of what "static typing" means.
04:04:34 <nand`> so that would be the domain of other sorts of static program analysis; but not static typing
04:04:50 <Philonous> Then*
04:05:05 <Nereid> yitz: I don't know if that's much of a motivation.
04:05:47 <Nereid> I admit I never dug very far into that area.
04:08:57 <nikita-0> A type system is a tractable syntactic method for proving the
04:08:57 <nikita-0> absence of certain program behaviors by classifying phrases
04:08:57 <nikita-0> according to the kinds of values they compute.
04:08:57 <nikita-0>     -- Types and Programming Languages, Benjamin C. Pierce
04:09:10 <nand`> (actually, what I said is not quite true - the type *can* tell you that some selectors don't exist; eg. ‘x’ in your example above)
04:09:25 <nand`> and indeed Haskell doesn't allow those
04:10:05 <mrg> hi
04:10:55 <nikita-0> (I concur my spelling of "behaviour" is heterodox. :-) )
04:11:54 <yitz> Nereid: personally i think the the ring Q ⊗ A is interesting, where A ⊂ Z((X)) is the subring of Laurent series whose sequence of coefficients is absolutely bounded by a polynomial
04:11:56 <nand`> yes, and in this case the type is telling you (indirectly) “has an ‘a’ field; and either has a ‘b’ field or not”
04:12:10 <nand`> if that's not the behavior you want
04:12:15 <nand`> then you need to separate the sum type
04:12:21 <yitz> Nereid: that ring, like the adele, has all the local rings as its places.
04:12:36 <yitz> Nereid: but i don't think anyone has ever studied it very much
04:12:40 <nand`> it's as simple as that; types are a tool for specifying the kinds of behavior you want - they don't stop you from specifying invalid behaviors; though as I've mentioned I feel Haskell should just straight up reject those kinds of situations
04:12:53 <yitz> *adeles
04:13:12 <yitz> Nereid: and with that we sign off this topic, unless you want to move to blah
04:13:21 <Nereid> I'm done. :p
04:13:31 <mrg> i am dealing with an algebraic datatype describing some commands, now i'd like to extend the datatype with new commands without touching the old definitions. any idea how to manage this?
04:14:42 <shachaf> mrg: Describe commands by behaviors instead of as a sum type.
04:15:00 <nikita-0> nand`: yes, this makes perfect sense.
04:15:15 <shachaf> data Cmd = Cmd { execute :: IO (), blahify :: Int -> Command, ... }
04:15:21 <shachaf> Now commands are first-class values.
04:19:47 <mrg> shachaf: i cant see how this could work for me as i have a list of commands which are evaluated by a function using pattern matching
04:20:04 <shachaf> mrg: Then don't use pattern matching. :-)
04:20:23 <randomclown> why can't I C.cons ((C.head bs) + 1) (C.tail bs)?
04:20:36 <randomclown> no instance for (Num char)
04:20:51 <randomclown> C = Data.ByteString.Char8
04:20:59 <randomclown> wait I want word8 right?
04:21:07 <nand`> mrg: instead of having a CommandA Foo Bar and a CommandB Bat Baz and pattern matching Command :: IO () with behaviors specified per match; write the behaviors as injection functions commandA :: Foo Bar -> ShachafCommand; commandB :: Bat Baz -> ShachafCommand
04:22:08 <nand`> I see it as a sort of difference in extensibility; having static commands and pattern matching on them allows you to add arbitrary new behaviors; but using first-class commands and static behaviors allows you to add arbitrary new commands
04:22:26 <shachaf> It's called "the expresion problem".
04:22:32 <nand`> sorry; I meant ‘pattern matching’ Commands -> IO ()
04:22:50 <nand`> and I managed to introduce two typos in that correction :(
04:24:49 <mrg> shachaf: lets say ive got data Cmd = Cmd ... how could i extend this without touching its definition?
04:26:49 <Philonous> mrg:  Unfortunately, you can't
04:27:02 <Philonous> Or fortunately, depending on you position
04:27:19 <shachaf> You can choose how to extend it.
04:27:29 <shachaf> Let's take a simpler example.
04:27:38 <mrg> what would solve my problem is a redefinition of that type
04:27:48 <shachaf> data Shape = Circle Int Int | Square Int
04:28:10 <mrg> ok
04:28:16 <shachaf> Now you can write things like perimeter :: Shape -> Int
04:28:19 <shachaf> (pi = 3, by the way)
04:28:31 <shachaf> Now, there are two things that you might want to extend:
04:28:37 <Philonous> For certain values of 3
04:28:41 <shachaf> The number of operations that you have, and the number of shapes that you have.
04:29:03 <mrg> right... in my case the number of shapes
04:29:04 <shachaf> In this model of shape, it's easy to extend operations: I can write area :: Shape -> Int, and it'll just pattern-match on each possible shape.
04:29:11 <shachaf> But it's hard to extend shapes.
04:29:28 <shachaf> You can also model shapes like this: data Shape = Shape { perimeter :: Int, area :: Int }
04:29:56 <merijn> mrg: Can you give a bit more intuition about what type of commands you'd like to have?
04:30:12 <shachaf> Now you can say: mkSquare :: Int -> Shape; mkSquare side = Shape { perimeter = side * 4, area = side * side }
04:30:14 * nand` .oO( Point R2 -> Bool )
04:30:40 <shachaf> And it's easy to extend this with new Shapes, but it's hard to extend it with new operations.
04:30:48 <shachaf> This is a pretty fundamental choice about your data.
04:31:06 <shachaf> You have to make it in Haskell, and you have to make it in OO languages (which have a different default).
04:32:30 <mrg> ok... got that... ih think using the first approach is fine for me... maybe i focused on the wrong aspect of the problem
04:32:47 <shachaf> In your case, it's something similar.
04:33:05 <shachaf> data Cmd = ForwardCmd Int | RotateCmd Angle
04:33:13 <shachaf> runCmd :: Cmd -> IO ()
04:33:14 <shachaf> Vs.
04:33:26 <shachaf> data Cmd = Cmd { run :: IO () }
04:33:42 <shachaf> mkForwardCmd n = ...
04:33:53 <shachaf> mkRotateCmd :: Angle -> Cmd; mkRotateCmd = ...
04:34:47 <shachaf> (IO () is probably not how you want to represent Cmd, of course.)
04:37:07 <mrg> my commands are used in a kind of structure say type Struc = (Command, Int) and there are functions using this type like foo :: Struc -> Bar. Defining a new type CommandB extending Command makes it impossible to use them althoug Command is subset of CommandB
04:38:27 <mrg> i think the problem is independet of the two approaches you descriped
04:38:44 <shachaf> I don't.
04:38:54 <mrg> btw: sorry for the typos
04:45:20 <mrg> my idea was using a parameter like type Struc a = (a, Int) but given a Struc CmdB the problem is still the same when i want to call foo :: Struc Cmd -> Bar i have to translate CmdB to Cmd
04:47:00 <Abso> Why is this not working http://dpaste.com/818132/ ?
04:47:29 <shachaf> Abso: Because (:) constructs a list from an element and another list.
04:47:35 <shachaf> @type (:)
04:47:37 <lambdabot> forall a. a -> [a] -> [a]
04:47:43 <Abso> ah
04:47:52 <shachaf> There are ways to "append to the end" of a list, but it's often a bad idea.
04:47:58 <Abso> how do I append to the end of the list then ?
04:47:59 <Abso> why?
04:48:01 <shachaf> ("list ++ [x]")
04:48:10 <shachaf> For one, it's rather inefficient.
04:48:17 <shachaf> It's also inelegant.
04:48:38 <ion> If you want to append to the end, a list is most likely the wrong data type.
04:49:05 <Abso> Hm I want to keep it simple
04:49:25 <t7> from the quotes of the week; "Jafet: Agda has an evaluator?". Is this funny because "no one runs agda code lel" or because he doesn't know enough about dependent type checking to know that code has to be evaluated whilst type checking. or none of the above?
04:49:29 <Abso> Also efficency is irrelevant
04:51:14 <Abso> but thanks anyways
05:11:08 <ski> Abso : in case order doesn't matter, one can simply add to the front instead. if it matters, one can often still add to the front, and do a final reverse when done. sometimes one can restructure the code to compute the elements in the "natural order" instead
05:13:01 <ski> Abso : .. it's hard to say whether any of these applyn without seeing more context, i.e. where is `addAlphToString' called from ?
05:29:44 <Abso> ski: its not yet called from anywhere since my function is not done yet
05:30:34 <citizen93> Dear all, I have a small question. I am trying to understand Type Classes and Overloading (from A Gentle Introduction to Haskell, version 98). It says:
05:30:50 <citizen93> class Functor f where fmap :: (a->b) -> f a -> f b
05:30:57 <ski> Abso : why are you defining the function ? what job will it be a piece of ?
05:31:19 <citizen93> wait I will paste the code in pastebin
05:31:30 <eikke> would anyone care to explain why these instances 'overlap'? https://gist.github.com/528bbcf638a6118b8457
05:31:50 <Abso> ski: I will pass an alphabet to a function and a number, then it should output all words which are possible with this alphabet and the length
05:32:44 <t7> what do i call; [literal 123, eax, sp - 4]   ?  operands ?
05:33:10 <ski> t7 : possibly
05:33:18 <citizen93> My question is, suppose I have this: http://pastebin.com/dNyW4N4C, what does Leaf (f x) actually do? How can one apply a type variable to the x? :(
05:33:21 <mauke> The paste dNyW4N4C has been copied to http://hpaste.org/76755
05:33:26 <citizen93> I don't quite understand that part.
05:33:58 <ski> citizen93 : `f' there isn't a type variable, but a value variable, of type `a -> b'
05:34:28 <citizen93> how do you see that?
05:34:31 <randomclown> are stuarrays faster than normal operations on bytearrays?
05:34:36 <ski> (types expressions and value expressions live in different namespaces)
05:34:51 <Abso> is there a fast way to apply a function on something n amount of times ?
05:34:54 <randomclown> bytestrings*
05:35:16 <randomclown> Abso: look at the (->) monad
05:35:19 <ski> citizen93 : because `fmap f (Leaf x)         = Leaf (f x)' is (part of) a definition, it contains things that live on the value level (unless there'd be any `::' in there, which there isn't)
05:36:03 <ski> > replicateM 2 "abc"
05:36:04 <lambdabot>   ["aa","ab","ac","ba","bb","bc","ca","cb","cc"]
05:36:05 <ski> > replicateM 3 "ab"
05:36:06 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
05:36:17 <citizen93> so what you are saying is that the f inside the class Functor f is not the same as the f used in the function definition?
05:36:22 <ski> Abso : do you mean something like that ?
05:36:28 <ski> citizen93 : yes
05:36:39 <Abso> yea
05:37:16 <ski> Abso : ok, so i think adding to the front will work just fine in your case
05:37:31 <ski> think of it as constructing the word from the end, if you like
05:37:53 <citizen93> alright, so uhm I'm trying to understand fmap function, (a->b) I get that that's a function from a to b, but how do I apply that to a?
05:38:03 <citizen93> as it says (a->b) -> f a -> f b
05:38:12 <ski> well, the general signature is
05:38:21 <ski>   fmap :: (a -> b) -> f a -> f b
05:38:24 <ski> (really meaning
05:38:25 <citizen93> yes
05:38:30 <ski>   fmap :: forall a b. (a -> b) -> f a -> f b
05:38:30 <ski> )
05:38:45 <ski> in this specific case, `f' is `Tree', meaning we must here implement
05:38:53 <ski>   fmap :: (a -> b) -> Tree a -> Tree b
05:39:05 <citizen93> oh brilliant!
05:39:13 <ski> looking at
05:39:18 <ski>   fmap f (Leaf x)       = ..x..
05:39:24 <ski> we know that we must have
05:39:28 <ski>   f :: a -> b
05:39:32 <ski>   Leaf x :: Tree a
05:39:35 <ski> and
05:39:41 <ski>   fmap f (Leaf x) :: Tree b
05:39:51 <ski> and therefore also the result must be of the same type
05:39:54 <ski>   ..x.. :: Tree b
05:40:00 <ski> now, the only way
05:40:02 <ski>   Leaf x :: Tree a
05:40:09 <ski> could hold is in case
05:40:11 <ski>   x :: a
05:40:55 <citizen93> I think I get it now =), thank you for the clear explanation ski!
05:40:56 <ski> (because of how the data type `Tree' is defined -- specifically, `Leaf' is a data constructor that given any element of type `a' yields a value of type `Tree a'. iow `Leaf :: a -> Tree a')
05:41:23 <ski> citizen93 : you can apply similar reasoning to derive the type of `t1' and `t2' in the other defining equation
05:41:41 <citizen93> yes, another small question about your notation that you just introduced the notation of forall a b.
05:42:05 <ski> well, consider
05:42:06 <citizen93> what is that called "forall a b." (the notation or. ..)?
05:42:23 <Eduard_Munteanu> citizen93: it means "given any types a and b ..."
05:42:26 <ski>   length :: [a] -> Int
05:42:34 <ski> here `a' is a type variable
05:42:35 <Eduard_Munteanu> Contrast that to 'f', which is known.
05:43:02 <ski> in some cases, a type variable stands for some specific given concrete type, like `f' above
05:43:21 <Eduard_Munteanu> The foralls aren't really needed, they're normally implicit.
05:43:24 <ski> (this is because `f' occurs as a parameter of the type class `Functor')
05:43:45 <citizen93> oh, this makes sense
05:43:48 <Jafet> Does ghc still say "(rigid; skolem) type variable"?
05:43:50 <ski> but in the case of `length', we really mean that `length' will work for *any* choice of actual type, replacing `a'
05:43:52 <Eduard_Munteanu> So length :: [a] -> Int is the same thing as length :: forall a. [a] -> Int
05:44:14 <citizen93> icic
05:44:26 <ski> yes, `length :: [a] -> Int' is a shorthand notation for writing the full `length :: forall a. [a] -> Int'
05:44:48 <ski> and it really means that `length' can assume any of the types in the following signatures
05:44:54 <ski>   length :: [Int] -> Int
05:44:58 <ski>   length :: [String] -> Int
05:45:02 <ski>   length :: [Int -> Bool] -> Int
05:45:10 <citizen93> yes
05:45:18 <ski>   length :: [([String],String -> IO Int)] -> Int
05:45:22 <ski>   &c.
05:45:44 <ski> and we express this by writing
05:45:50 <ski>   length :: forall a. [a] -> Int
05:46:00 <otters> length :: [Free Maybe Int]
05:46:23 <ski> now, in this case, `forall a. ' occurs just after the `::' -- and in *that* case, we can omit it
05:46:31 <ski> so, when i said
05:46:34 <merijn> Except haskell programmers are notoriously lazy and thus the compiler will automatically insert any missing lefthand side forall's and so we get away with writing "[a] -> Int"
05:46:36 <ski>   fmap :: forall a b. (a -> b) -> f a -> f b
05:46:46 <citizen93> so if I have this (==), do I write it as this (==) :: (Eq a) => forall a. a -> a -> Bool?
05:47:00 <Jafet> They are so lazy, they didn't even put forall syntax in the report!
05:47:02 <Nereid> citizen93: the forall has to come before the constraint
05:47:04 <ski> i meant that `fmap' should be able to work for *any* types `a' and `b', and some specific given type `f' (in this case `Tree')
05:47:06 <Nereid> else what is a?
05:47:12 <merijn> citizen93: No, "forall a . Eq a => a -> a -> Bool"
05:47:13 <Eduard_Munteanu> citizen93: no, that should be  forall a. (Eq a) => a -> a -> Bool.
05:47:18 <citizen93> ok thanks!
05:47:21 <ski> citizen93 : `(==) :: forall a. Eq a => a -> a -> Bool'
05:47:29 <Jafet> @quote stereo
05:47:29 <lambdabot> geheimdienst says: data Stereoloid = BanachTyvski | CoBanachTyvski
05:47:43 <merijn> citizen93: i.e. "for all a's, *if* Eq a *then* == has type a -> a -> Bool"
05:47:51 * ski . o O ( "Tyvski" ? )
05:47:52 <otters> so uh, free monads
05:48:13 <citizen93> Thank you guys, I get it now I think
05:49:38 <ski> citizen93 : in the case of `fmap', `f' is already in scope (from `Functor f'), but `a' and `b' are not, which is why `fmap :: (a -> b) -> f a -> f b' there will be interpreted as `fmap :: forall a b. (a -> b) -> f a -> f b'
05:50:27 <ski> .. and when you want to express `fmap' like any function, not specifically as a method of `Functor f', then we get `fmap :: forall f a b. Functor f => (a -> b) -> f a -> f b'
05:50:45 <citizen93> yes I see!
05:50:48 <randomclown> is there a way to turn a bytestring into a mutable array?
05:50:54 <randomclown> in the st monad
05:50:56 <randomclown> with no copying
05:51:42 <Eduard_Munteanu> randomclown: mm, I don't think it's possible for a lazy bytestring, since it's basically a list of strict chunks.
05:52:01 <randomclown> obviously a strict bytestring
05:52:10 <randomclown> so just that 32kb section
05:53:42 <randomclown> Eduard_Munteanu:
05:53:44 <t7> why do microsoft have their own stupid calling conventions :(
05:54:33 <ivanm> randomclown: I think bytestring uses its own form of pinning memory on the heap or something
05:54:44 <ivanm> t7: just to annoy you
05:55:13 <ivanm> Microsoft's entire business strategy has been carefully developed over the decades for the sole purpose of irritating you both as a developer for the platform and as an end user
05:55:14 <ivanm> ;)
05:55:28 <randomclown> I thought MS is all about developers
05:55:40 <Eduard_Munteanu> Mm, there's unsafeUseAsCString :: ByteString -> (CString -> IO a) -> IO a
05:57:08 <randomclown> Eduard_Munteanu: no way to write?
05:57:48 <citizen93> I have another question, how can I determine a kind (and is there some way in GHC that I can get kinds from types?)?
05:58:00 <citizen93> I know that for example the kind of Integer is *
05:58:27 <citizen93> and Tree is * -> * as it takes a type as argument
05:58:46 <sp3ctum> citizen93, not sure if you meant it, but in ghci you can (interactively) use :kind
05:59:09 <citizen93> Oh cool!
05:59:10 <citizen93> that works!
05:59:36 <citizen93> thanks!
05:59:42 <sp3ctum> np
06:01:33 <merijn> :k Data.Map.Map
06:01:34 <lambdabot> * -> * -> *
06:02:09 <citizen93> @merijn how do you "speak" to lambdabot?
06:02:09 <lambdabot> Unknown command, try @list
06:02:15 <citizen93> oh with an @
06:02:27 <citizen93> @:kind Functor
06:02:28 <lambdabot>     Class `Functor' used as a type
06:02:29 <lambdabot>     In the type `Functor'
06:03:12 <citizen93> @:k Integer
06:03:12 <lambdabot> Maybe you meant: . ? @ ask bf do ft id pl rc v wn
06:03:18 <citizen93> @:kind Integer
06:03:19 <lambdabot> *
06:03:36 <alcz> citizen93: ^^
06:03:38 <alcz> @list
06:03:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:03:44 <citizen93> @:kind List
06:03:45 <lambdabot> Not in scope: type constructor or class `List'
06:03:56 <citizen93> @:kind (:)
06:03:57 <lambdabot> parse error on input `:'
06:04:23 <maloi0> citizen93: u can play with her in a query ;)
06:04:56 <merijn> citizen93: ":kind" works without prefix
06:05:02 <merijn> Just type it in the channel
06:05:10 <merijn> :k (:)
06:05:11 <lambdabot> parse error on input `:'
06:05:14 <merijn> hmm
06:05:22 <merijn> Oh, duh
06:05:25 <Ferdirand> but (:) is not a type
06:05:27 <merijn> That's a constructor, not a type
06:05:28 <citizen93> indeed
06:05:32 <citizen93> I figured that too XD
06:05:34 <Abso> ski: this is my solution: http://dpaste.com/818153/
06:05:40 <merijn> :k Maybe
06:05:42 <lambdabot> * -> *
06:05:46 <merijn> :t (:)
06:05:47 <lambdabot> forall a. a -> [a] -> [a]
06:05:56 <citizen93> :k Either
06:05:57 <lambdabot> * -> * -> *
06:06:40 <merijn> As maloi0 mentioned lambdabot also responds to privmsg
06:06:41 <citizen93> @:import GHC.Generics
06:06:41 <lambdabot> Unknown command, try @list
06:06:53 <citizen93> hmm.. I can't import things apparently
06:06:56 <citizen93> @list
06:06:57 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
06:06:59 <merijn> You can't, no
06:07:03 <merijn> Also no IO
06:07:11 <merijn> > putStrLn "foo"
06:07:12 <lambdabot>   <IO ()>
06:07:55 <citizen93> can I use lambdabot to define datatypes?
06:08:02 <Eduard_Munteanu> Nope.
06:08:12 <Eduard_Munteanu> You can just define values/functions.
06:08:23 <Eduard_Munteanu> @let foo = "foo"
06:08:25 <lambdabot>  Defined.
06:08:29 <Eduard_Munteanu> > foo
06:08:31 <lambdabot>   "foo"
06:08:36 <Eduard_Munteanu> @undefine
06:08:46 <Nereid> > foo
06:08:47 <lambdabot>   Not in scope: `foo'
06:10:27 <ski> Abso : the first equation for `addAlphToString' is a special case of the second one
06:10:57 <citizen93> can you define a function with guards with lambdabot? I don't think that's actually possible :(
06:11:24 <ivanm> > let isThree x | x == 3 then "Yes!" | otherwise = "No"
06:11:25 <lambdabot>   <no location info>: parse error on input `then'
06:11:28 <ivanm> > let isThree x | x == 3 then "Yes!" | otherwise = "No" in isThree 3
06:11:29 <lambdabot>   <no location info>: parse error on input `then'
06:11:36 <ivanm> > let isThree x | x == 3 = "Yes!" | otherwise = "No" in isThree 3
06:11:37 <lambdabot>   "Yes!"
06:11:41 <ivanm> citizen93: ^^
06:11:45 <citizen93> oh icic ^^
06:12:16 <ski> Abso : btw, note that `[Char]' could be abbreviated as `String', if you like
06:12:59 <ski> Abso : otherwise, it looks fine
06:13:08 <Abso> ski: Ah, good to know, what do you mean the first equation is a special one ?
06:13:08 <ion> > (length "[Char]", length "String")
06:13:09 <lambdabot>   (6,6)
06:13:10 <ivanm> ski: "abbreviated"? the length is the same!
06:13:26 <Eduard_Munteanu> Heh.
06:13:48 <ski> Abso : i mean that if you remove the first equation, then the second equation will give the same result as the first one would have, in cases it would have triggered
06:14:00 <ski> Abso : iow, the first equation is redundant, the second is enough
06:14:07 <citizen93> I gtg now ^^ cya guys!
06:14:11 <citizen93> thanks for everything!
06:14:11 <Abso> ah yeah I see, thanks :D
06:14:26 <ski> ivanm :) the number of tokens differ
06:14:58 <ivanm> what are you referring to as "tokens" in this sense?
06:15:05 <Nereid> > replicateM 3 "ab"
06:15:06 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
06:15:43 <ski> ivanm : `[',`Char',`]' vs. `String' ?
06:15:56 <ivanm> why are [ and ] distinct from Char?
06:16:21 <ivanm> when you say a type alias is an "abbreviation", I would figure what would matter is how many characters it takes you to type
06:16:45 <ivanm> so, unless you've set up your editor to auto-insert a closing bracket whenever you type in an opening one, they take just as long to type
06:16:48 <amazingHaskell> I am writing the most beautiful code i have ever written.. Haskell is great <3
06:17:02 <Nereid> > map (:"str") "abc"
06:17:03 <lambdabot>   ["astr","bstr","cstr"]
06:17:06 <ion> My keyboard has four keys: “String”, “[”, “Char” and “]”.
06:17:16 <Ferdirand> depending on your keyboard layout [ and ] can be more painful to type than letters
06:17:22 <shapr> amazingHaskell: It's addictive too! Once you go Haskell, it's hard to go back to C++ or Java
06:17:30 <ivanm> Ferdirand: and that
06:17:31 <shapr> Ferdirand: Tried programmer dvorak?
06:17:51 * ivanm -> hits the sack
06:17:54 <ion> ferdirand: Yeah, my “native” keyboard layout is horrible. I’m using US International (AltGr dead keys) which is like the US layout but still lets me type ä and ö.
06:18:00 <ski> ivanm : hehe, i was more thinking about reading the code than writing
06:18:26 <ivanm> ski: String is then shorter as you don't have to read "list of" and "Char"!
06:18:33 <Ferdirand> well, i use altgr + é/à for []
06:18:42 <Ferdirand> for some reason i find that hand position painful
06:18:44 <amazingHaskell> <sharp> : yes it is!
06:18:45 * ski has `{',`[',`]',`}' on the `7',`8',`9',`0' keys here
06:19:06 <Entroacceptor> I'm using the international keyboard with compöse key for my umlauts
06:19:07 <ski> ivanm : right
06:19:21 <Entroacceptor> it's okayish so far
06:19:23 <ivanm> oh, right, that was your point :)
06:19:27 * ivanm really needs sleep
06:19:51 <amazingHaskell> Things are so easier with haskell.. anybody here new to haskell like me?
06:20:02 <Abso> me! :D
06:20:50 <amazingHaskell> how is experience with haskell till now ?
06:21:41 <Abso> I like it so far, but I still like python more
06:22:26 <amazingHaskell> python is next on my list
06:22:51 <Abso> so what language did you code in before?
06:23:07 <amazingHaskell> c and c++
06:23:21 <Ferdirand> so, do you prefer python's yield or haskell's lazy lists ?
06:23:45 <ski> Abso : btw .. your code *could* be simplified a bit more -- but in case you don't want to, i think it's fine
06:23:55 <Abso> I didnt use any lazy lists yet
06:24:46 <amazingHaskell> 100 lines of code in c++ can be easily reduced to 30 in haskell
06:25:18 <Abso> ski: how so?
06:25:47 <Abso> I hope that it could be simplified more, because I don't like my solution much
06:25:58 <Abso> but atleast it's working..
06:26:20 <amazingHaskell> no need to declare types,variables, no need for memory allocation,pattern matching,recursion,Lists....so much win!
06:26:27 <ski> Abso : well, `addAlphToString' could be unfolded
06:26:54 <ski> (Abso : btw, your `wordsOfLength' and `declare types,variables, no need for memory allocation,pattern matching,recursion,Lists....so much win!
06:26:57 <Eduard_Munteanu> amazingHaskell: it's considered good practice to add type signatures though
06:26:58 <ski> oops
06:27:25 <ski> (Abso : btw, your `wordsOfLength' and `addAlphToString' are using lazy lists all over the place)
06:27:45 <amazingHaskell> yes! thanks you!
06:28:06 <Nereid> after all, the types tell you a lot about what a function does and how you can use it.
06:28:27 <Abso> how can I unfold the addAlphToString function?
06:28:52 <Nereid> Abso: you can write it in terms of "map"
06:29:10 <Abso> ah yeah
06:29:13 <Nereid> (not really an answer but yeah)
06:29:40 <Abso> I know
06:29:46 <ski> Abso : replace the call to `addAlphToString' inside (the definition of) `wordsOfLength' with the body of `addAlphToString', with the actual parameters of the call substituted for the formal parameters
06:30:11 <ski> (and with some renaming of local variables, in this case)
06:31:19 <ski> in this case, the call (inside `wordsOfLength') is `addAlphToString alphabet x', the definiendum (left-hand side) in the definition is `addAlphToString alphabet str' and the definiens (right-hand side) is `[ x:str | x <- alphabet ]'
06:31:47 <ski> so, we need to replace `alphabet' with `alphabet', and `str' with `x', in `[ x:str | x <- alphabet ]'
06:32:04 <Nereid> except not the same x
06:32:14 <ski> however, there's already a local variable `x' in there, so let's first rename it to `y' (e.g.), so `[ y:str | y <- alphabet ]'
06:32:40 <ski> and after the replacement, we get `[ y:x | y <- alphabet ]'
06:33:13 <ski> therefore, the call `addAlphToString alphabet x' (inside `wordsOfLength') can be replaced by `[ y:x | y <- alphabet ]'
06:33:17 <ski> so, we go from
06:33:18 <ski>   wordsOfLength alphabet n = concat [ addAlphToString alphabet x | x <- wordsOfLength alphabet (n-1)]
06:33:21 <ski> to
06:33:30 <ski>   wordsOfLength alphabet n = concat [ [ y:x | y <- alphabet ] | x <- wordsOfLength alphabet (n-1)]
06:33:33 <ski> Abso : ok ?
06:34:04 <Abso> yeah, but there is no big difference yet imo
06:34:12 <ski> right, this is just the first step
06:34:14 <Abso> I'd like to get rid of the concat
06:34:17 <ski> now, we could go two ways here
06:35:11 <ski> one way is to note (as Nereid suggested), that `[ y:x | y <- alphabet ]' could be phrased as `map (:x) alphabet'
06:35:26 <Nereid> but that's not any easier to manipulate
06:35:27 <Abso> yup
06:35:33 <ski> so, we'd get
06:35:49 <ski>   wordsOfLength alphabet n = concat [ map (:x) alphabet | x <- wordsOfLength alphabet (n-1)]
06:36:06 <ski> similarly, the other list comprehension here could also be replaced by a `map' call
06:36:25 <t7> does  add ebx, ecx  store result in eax or ebx?
06:36:37 <ski>   wordsOfLength alphabet n = concat (map (\x -> map (:x) alphabet) (wordsOfLength alphabet (n-1)))
06:36:37 <Nereid> t7: certainly not eax
06:36:41 <ski> Abso : do you follow ?
06:36:45 <Nereid> t7: ;)
06:36:54 <Abso> ski: yea
06:36:55 <t7> thanks
06:36:57 <Abso> easy so far
06:37:00 <Nereid> t7: no, reread what you wrote.
06:37:03 <ski> now, we can use
06:37:07 <ski> @src concatMap
06:37:07 <lambdabot> concatMap f = foldr ((++) . f) []
06:37:15 <t7> Nereid: i thought it went in eax regardless
06:37:17 <ski> er, that's not the definition i had in mind :)
06:37:28 <ski>   concatMap f as = concat (map f as)
06:37:29 <Nereid> t7: no, add ebx, ecx puts ebx+ecx into ebx
06:37:31 <ski> (is equivalent)
06:37:35 <ski> so, we can now reach
06:37:45 <ski>   wordsOfLength alphabet n = concatMap (\x -> map (:x) alphabet) (wordsOfLength alphabet (n-1))
06:38:13 <ski> Abso : so now, there's no extra `concat' step "at the end", we concatenate as we go
06:38:25 <Abso> yeah
06:38:41 <merijn> And if you split "(\x -> map (:x) alphabet)" to a function in the where clause with a nice meaningful name everything becomes more readable too :)
06:38:47 <ski> this is more or less the final form of this first alternative
06:38:53 <ski> merijn : yeah, one could do that
06:39:05 <ski> Abso : now, let's go back to
06:39:07 <ski>   wordsOfLength alphabet n = concat [ [ y:x | y <- alphabet ] | x <- wordsOfLength alphabet (n-1)]
06:39:12 <ski> and consider the other alternative
06:40:02 <ski> note that the `x <-' and `y <-' here in some sense acts like "`for'-loops" -- in fact nested such
06:40:05 <Abso> ski I'll brb
06:40:14 <Nereid> replicateM !
06:40:23 <Abso> just a second or two
06:40:36 <ski> for each `x' in the list `wordsOfLength alphabet (n-1)' we'll generate one output element `[ y:x | y <- alphabet ]' (which will also be a list)
06:40:59 <ski> and for each `y' in the list `alphabet', we'll generate one element `y:x'
06:41:08 <ski> so, we generate a list of lists here
06:41:24 <ski> and *then*, at the end, we concatenate all these lists together
06:41:47 <Ferdirand> > replicateM 4 "ab"
06:41:48 <lambdabot>   ["aaaa","aaab","aaba","aabb","abaa","abab","abba","abbb","baaa","baab","bab...
06:41:51 <ski> instead of doing this, we can use a list comprehension with *multiple* generators
06:41:53 <Ferdirand> black magick
06:42:28 <nyc> This might actually teach me something I can understand.
06:42:51 <ski> > [[x ++ " " ++ y | y <- ["you","world"]] | x <- ["hello","goodbye"]]
06:42:53 <lambdabot>   [["hello you","hello world"],["goodbye you","goodbye world"]]
06:42:58 <ski> > concat [[x ++ " " ++ y | y <- ["you","world"]] | x <- ["hello","goodbye"]]
06:43:00 <lambdabot>   ["hello you","hello world","goodbye you","goodbye world"]
06:43:14 <ski> > [x ++ " " ++ y | x <- ["hello","goodbye"] , y <- ["you","world"]]
06:43:16 <lambdabot>   ["hello you","hello world","goodbye you","goodbye world"]
06:43:38 <Nereid> [x y | x <- [f,g], y <- [a,b]] :: [Expr]
06:43:40 * merijn suspects on oncoming field trip to the list monad
06:43:41 <ski> in the latter case, we generate a single list directly, without the need for using `concat' at the end
06:43:42 <Nereid> > [x y | x <- [f,g], y <- [a,b]] :: [Expr]
06:43:44 <lambdabot>   [f a,f b,g a,g b]
06:43:59 <Nereid> merijn: too late :D
06:44:04 <ski> using this insight for the above, we get
06:44:29 <ski>   wordsOfLength alphabet n = [ y:x | x <- wordsOfLength alphabet (n-1) , y <- alphabet ]
06:45:01 <Eduard_Munteanu> nyc: hm?
06:45:31 <ski> Abso : i'll wait here for your return
06:45:53 <merijn> :t let wordsOfLength alphabet n = do { x <- wordsOfLength alphabet (n-1); y <- alphabet; return (y:x) } in wordsOfLength
06:45:54 <lambdabot> forall (m :: * -> *) t a. (Monad m, Num a) => m t -> a -> m [t]
06:47:34 <Ferdirand> @src replicateM
06:47:34 <lambdabot> replicateM n x = sequence (replicate n x)
06:47:58 <Ferdirand> @src sequence
06:47:58 <lambdabot> sequence []     = return []
06:47:59 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
06:47:59 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
06:48:14 <Ferdirand> meh.. isn't there a cuter expression for sequence ?
06:48:36 <ski> .. the `foldr' one just above ?
06:49:08 <merijn> Ferdirand: Sure, in Data.Traversable :p
06:49:15 <merijn> :t Data.Traversable.sequence
06:49:15 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
06:50:12 <Ferdirand> ski: i don't know, i don't like liftM2 much
06:50:16 <merijn> I wish Prelude just exported those so I wouldn't have to hide, sequence,mapM and friends from Prelude and Control.Monad every time I use those modules :\
06:50:33 <otters> :instances Traversable
06:50:38 <otters> damn it
06:50:44 <merijn> :i Traversable
06:50:57 <merijn> @info Data.Traversable.Taversable
06:50:57 <lambdabot> Data.Traversable.Taversable
06:50:58 <yitz> merijn: import qualified Data.Traversable as T
06:51:02 <merijn> oh, blah
06:51:09 <ski> @instances-importing Data.Traversable Traversable
06:51:10 <lambdabot> Maybe, []
06:51:16 <merijn> yitz: Qualified imports are freaking ugly :(
06:51:49 <merijn> yitz: Especially since the functions from Data.Traversable and Data.Foldable are fully compatible with the existing ones in Control.Monad and Prelude
06:51:57 <yitz> merijn: yeah. but in my opinion better than hiding stuff from the prelude
06:52:06 * yitz nods
06:52:09 <merijn> So there's no reason to use the Prelude ones if you import the ones from Traversable
06:53:02 <merijn> GHC needs to be extended so you can provide multiple type signatures per function with a difficulty level, then provide a "difficulty level" knob that lets you twiddle how generic a function it tries to use :p
06:53:08 <yitz> merijn: i'm never sure if you lose optimizations when you do that unnecessarily though
06:53:48 <merijn> Then Prelude could just export "Data.Traversable.sequence" with a "newbie level: sequence :: [m a] -> m [a]"
06:54:31 <merijn> And I could just use "pro level: sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)" without messing around with imports
06:55:27 <fmap> {-# LANGUAGE Nightmare #-}
06:56:29 <Eduard_Munteanu> And if you play it in hardcore mode, a single type error erases your entire program and you have to start over. :P
06:56:42 <ski> merijn : well, one could imagine being able to export an operation, but with a restricted type signature
06:57:36 <merijn> ski: That's what I just suggested, isn't it? :)
06:57:56 <ski> hm .. then if you import `sequence' from both `Prelude' and `Data.Sequence', the most general one wins (since it's really the same function from the start) -- i suppose because there *is* a most general one in this case
06:58:36 <ski> merijn : no, you suggested an extra "difficult level" knob, apart from just selecting which module to use, afaiu :)
06:58:52 <ski> (but perhaps you meant something like what i elaborated)
07:00:24 <merijn> ski: I could live with that, I was just thinking of making the selection of how general to be a knob twiddle-able by the user based on how brave/experienced he/she feels
07:00:41 <merijn> Instead of just selecting the most general one that is imported
07:01:32 <merijn> Which seems like it should be simpler to implement because the compiler doesn't need to determine what the most general is, you just require the user to tell you
07:03:07 <Polarina> How about just NoImplicitPrelude?
07:05:39 <hpaste> killy9999 pasted “Poor cabal file” at http://hpaste.org/76757
07:05:43 <merijn> Polarina: I've considered doing "NoImplicitPrelude" and then having my own file importing Prelude hidden and stuff like Data.Traversable/Foldable and reexporting all that as "local" Prelude. But so far I haven't tried yet
07:05:49 <killy9999> can anyone help me rewrite my cabal file?
07:06:16 <killy9999> right now I need to specify ghc-options in two sections
07:06:23 <killy9999> and my intention is that they are always the same
07:06:27 <Polarina> merijn, that's pretty much what I'll do when Prelude starts bugging me enough.
07:07:21 <ski> merijn : ok, you mean more like DrScheme's^WRacket's language levels ?
07:07:45 <dcoutts_> killy9999: you can make the benchmark depend on the lib.
07:08:17 <killy9999> dcoutts: in build-depends?
07:08:28 <merijn> ski: Yes
07:08:48 <merijn> ski: Those sounded imminently sensible to me when I heard of them
07:08:49 <dcoutts_> killy9999: yes, but then you also need to put your benchmark in a different subdir, or it'll pick up the modules from the .hs files rather than the lib
07:08:56 <killy9999> I did that but it looks like that my source files are built separately by the benchmark
07:09:00 <ski> Helium was sortof that, with just a single language level
07:09:14 <dcoutts_> killy9999: note what I said about the subdir
07:09:15 <merijn> Especially since the most proposed argument for keeping Prelude ungeneral is newbie complexity
07:09:23 <killy9999> hm...
07:09:40 <killy9999> libraray files are in src, benchmarking code is in bench and it uses files from src
07:09:48 <killy9999> is that correct?
07:09:53 <dcoutts_> killy9999: since local .hs always is used in prefrence to a module from a package/lib
07:10:06 <killy9999> hm...
07:10:08 <dcoutts_> killy9999: so in this case you have to separate the source search paths
07:10:29 <killy9999> hs-source-dirs: bench  ??
07:10:31 <killy9999> instead of
07:10:33 <killy9999> hs-source-dirs:   src, bench
07:10:36 <dcoutts_> right
07:10:42 * killy9999 tries that
07:11:46 <killy9999> cabal complains that it can't find modules
07:11:56 <killy9999> oh wait
07:12:06 <killy9999> silly me, I didn't expose them :)
07:12:26 <dcoutts_> killy9999: right, when you use it via the lib, you can only use the public api
07:12:48 <dcoutts_> killy9999: if you want to test or benchmakr internal modules, you have to use the .hs files directly.
07:12:54 <killy9999> correct me if I'm wrong, but now I will have to manually build my libraray and install it
07:13:17 <killy9999> and only then I will be able to build the benchmark and run it
07:13:26 <dcoutts_> killy9999: no, it'll just work
07:13:46 <killy9999> it will rebuild the library by itself when I change the code?
07:13:57 <dcoutts_> yes
07:14:03 <killy9999> OK
07:14:08 <killy9999> sounds good
07:14:13 <killy9999> brb
07:14:19 <killy9999> thanks!
07:15:29 <qnikst> hello, is it possible to load list of configure options using configurator package
07:17:15 <Abso> ski: I'm back, that function looks way better
07:18:15 <Cale> qnikst: Not sure what you're asking
07:20:08 <ski> Abso : ok
07:20:38 <ski> looking at
07:20:39 <ski>   wordsOfLength alphabet n = [ y:x | x <- wordsOfLength alphabet (n-1) , y <- alphabet ]
07:20:44 <Abso> yes
07:20:52 <ski> you could at this point consider changing the order of the generators
07:21:00 <ski> this will "swap the nested loops"
07:21:09 <ski> so that you'll generate the words in a different order
07:21:41 <qnikst> Cale: I'm using configurator package, and there is possibility to create an option that contains a list of values, i.e foo = [1,2,3] but it seems there is no api to extract such a values
07:21:59 <ski> but possibly you aren't married to your current order, so the other order might also be ok
07:22:35 <Abso> yeah the order is okay
07:22:47 <ski> so, if we change it to
07:22:49 <Cale> qnikst: The Value type has a List constructor with a parameter of type [Value]
07:22:58 <ski>   wordsOfLength alphabet n = [ y:x | y <- alphabet , x <- wordsOfLength alphabet (n-1) ]
07:23:37 <ski> then it reads as : select a character `y' from the alphabet as first letter in the word, and select a word `x' of length `n-1' as the rest of the whole word
07:23:59 <qnikst> Cale, to extract a Value there is only getMap, that work over all config, and using it is ugly
07:24:04 <ski> Abso : ok ?
07:24:23 <Abso> yep
07:24:39 <ski> do you know anything about monads ?
07:24:51 <Abso> no, not yet, I just started with haskell on friday
07:25:21 <ski> ok, then i think we'll stop here
07:25:34 <Abso> ok thanks a bunch
07:25:39 <Abso> you are awesome :D
07:25:45 <Cale> qnikst: Value is an instance of Configured
07:26:00 <Cale> qnikst: So you can also use all the lookup stuff
07:26:04 <ski> i'll just mention that there's something called the "list monad", and the list comprehensions you're using here are basically the same thing as that -- therefore one could shorten the code somewhat more using monadic operations
07:26:37 <ski> (what what i just said really means will have to wait until a later time)
07:27:07 <qnikst> Cale: hm..
07:27:08 <ski> Abso : lastly, please remember to have *fun* when programming !
07:27:31 <osfameron> if you are not having fun, please check your computer: you may be programming COBOL!
07:27:39 <otters> or java
07:27:47 * osfameron has had fun programming java
07:27:52 <osfameron> though the IDE helped a lot there...
07:28:09 <otters> yeah it really isn't that bad
07:28:14 <otters> all my experiences with java have been on windows though
07:28:21 <Cale> TimeZoneRegistryFactory.getInstance().createRegistry().getTimeZone(timeZoneId(that))
07:28:40 <srhb> *twitch*
07:28:52 <qnikst> Cale, thanks
07:29:48 <Abso> ski: yeah I do :D thanks again ;)
07:35:42 <ion> Man, i thought the Data.Time API was bad.
07:36:05 <ion> I thought that’s one of them exaggerations of Java-style APIs at first, but it seems that wasn’t ajoke.
07:36:22 <ion> +' '
07:42:28 <Sculptor> hi!
07:43:56 <ski> lo?
07:45:40 <Sculptor> no, hi
07:46:23 <byorgey> mid
07:51:42 * hackagebot shelly 0.14.2.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.14.2.1 (GregWeber)
07:52:53 <typoclass> cale: do you think people would consider it weird if i put a discussion/talk/opinion kind of page on the haskellwiki? (you sometimes talked about the wiki in the old days having been different, with discussion going on)
07:53:56 <dsdeiz> heya, trying to read learnyouahaskell and wondering, is it possible make my own function of [1..10]? i'm just currently on ch. 5 though.
07:54:08 <ski> typoclass : i'd suggest : try it and see !
07:54:16 <Cale> typoclass: No, that would be great, apart from the fact that it's a bit tricky to get an account on the wiki these days as well, so I'm not sure how many people will use it.
07:54:22 <ski> dsdeiz : you could write a function that does that, yes
07:54:31 <ski> > enumFromTo 1 10
07:54:32 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:54:36 <typoclass> ok thanks guys
07:54:45 <ski> is what `[1..10]' desugars to
07:55:17 <dsdeiz> some thing that say takes an Int parameter and returns a list from 1 .. Int
07:55:40 <srhb> dsdeiz: Right.
07:55:51 <Cale> > let range n m | n > m = []  | otherwise = n : range (n+1) m in range 1 10
07:55:52 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:55:54 <typoclass> dsdeiz: yes you can easily have that. it'd be something like "f limit = [1..limit]"
07:56:17 <Cale> > let range n = [1..n] in range 10
07:56:18 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:57:25 <dsdeiz> ah sweet. thanks. hopefully i can use this in project euler's 2nd problem xD
07:58:13 <dsdeiz> hm, or should i finish the whole tutorial first before diving into any exercises?
07:58:44 <signalsea> Question: Is there a way I can declare a type synonym of an associated type synonym, inside of a class? Like "Class Combinable elem coll where; type Collect elem c :: * -> *; type Foo = (Collect elem c)", so i can save myself some keystrokes in signatures
07:58:48 <srhb> dsdeiz: You're at a point where you can probably benefit a lot from exercises. But I would argue that it's always good to exercise with whatever material is current.
07:59:09 <signalsea> typo: "type Collect elem c" should read "type Collect elem coll"
08:00:30 <Cale> dsdeiz: You should probably try to write small programs as you go
08:01:43 <dsdeiz> ok, thanks. i'd probably just finish the whole tutorial but try out the examples as I go along..
08:01:52 <typoclass> dsdeiz: i think the right way is to have lyah open in the left half of the screen and have ghci open in the right half, for constant fiddling :-) . it's up to you whether you just try out single functions and single lines, or if you work on some larger problems like from project euler
08:04:13 <bartavelle> is there a more idiomatic way to do "xx >>= \x -> unless x (throwError xxx)"
08:05:35 <mm_freak> signalsea: if it's always the same type, then there is really little reason to declare it inside the class
08:05:44 <typoclass> bartavelle: i think most people write their own whenM and unlessM functions which take an m Bool. there's also a hackage package with that
08:06:09 <typoclass> (... or probably several)
08:06:10 <bartavelle> typoclass, thanks
08:06:42 * hackagebot hsparql 0.2.1 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  http://hackage.haskell.org/package/hsparql-0.2.1 (RobStewart)
08:07:21 <donri> @pf xx >>= \x -> unless x (throwError xxx)
08:07:21 <lambdabot> Maybe you meant: bf pl
08:07:27 <donri> @pl xx >>= \x -> unless x (throwError xxx)
08:07:28 <lambdabot> flip unless (throwError xxx) =<< xx
08:08:01 <signalsea> mmfreak: I would just like to be able to write "funfoo ::  a -> Foo x -> Foo x" instead of "nofunfoo :: a -> (Collect elem c) elem -> (Collect elem c) elem"
08:08:50 <signalsea> (since "type Collect elem c :: * -> *")
08:12:51 <uhhh> So I'm trying Haskell for the first time. Is Num a union?
08:13:34 <typoclass> @instances
08:13:34 <lambdabot> Couldn't find class `'. Try @instances-importing
08:13:38 <typoclass> @instances Num
08:13:38 <lambdabot> Double, Float, Int, Integer
08:14:04 <typoclass> uhhh: hello. Num is a typeclass. its basic instances are those ^^
08:14:05 <tac> uhhh: It's a type class.
08:14:09 <uhhh> Thanks lambdabot
08:14:37 <S11001001> uhhh: not really.  There's no good analogue
08:14:57 <signalsea> uhhh: You should read about typeclasses. the instances of Num implement its functionality
08:15:07 <uhhh> A typeclass? That's a new word for me as well. But I won't throw a bunch a questions at you guys :)
08:15:18 <uhhh> *of
08:15:19 <tac> typeclasses are *kinda* like interfaces from Java
08:15:21 <tac> but more powerful
08:15:25 <nicoo> S11001001: Well, you can see typeclasses as implicit ML-style functors
08:15:26 <Eduard_Munteanu> uhhh: they're basically sets of types which share certain methods.
08:15:28 <typoclass> @src Num
08:15:28 <lambdabot> class  (Eq a, Show a) => Num a  where
08:15:28 <lambdabot>     (+), (-), (*)           :: a -> a -> a
08:15:28 <lambdabot>     negate, abs, signum     :: a -> a
08:15:28 <lambdabot>     fromInteger             :: Integer -> a
08:15:33 <mm_freak> signalsea: yes, define a type synonym outside of the class
08:15:37 <ski> bartavelle :  xx >>= (`unless` throwError xxx)  perhaps
08:15:46 <mm_freak> signalsea: oh wait
08:15:57 <mm_freak> signalsea: i get it now…  no, that's not possible
08:16:06 <mm_freak> you can't get rid of the variables
08:16:13 <uhhh> Eduard: That makes sense to me.
08:16:15 <typoclass> uhhh: here are the six functions that the typeclass Num requires ^^. each instance (e.g. the Num instance for Int) needs to provide an implementation for them
08:16:28 <S11001001> uhhh: the #1 mistake of understanding typeclasses is being surprised when they turn out to be quite different from java interfaces :)
08:16:28 <mm_freak> signalsea: the only way to get rid of them is to make them associated type synonyms as well
08:16:42 <ski> (seven)
08:16:47 <jfischoff> Under what circumstances does ghc unbox primitives? I assumed f :: Int -> Int; f !x = x + x would be turned into f :: Int# -> Int# … no dice
08:17:00 <merijn> I always like to bring up Bounded as an example typeclass that's different from Java interfaces
08:17:15 <nicoo> @src Bounded
08:17:16 <lambdabot> class  Bounded a  where
08:17:16 <lambdabot>     minBound, maxBound :: a
08:17:20 <nicoo> :)
08:17:27 <bartavelle> ski: nice !
08:17:44 <typoclass> S11001001: could you explain how they're different?
08:17:49 <ski> bartavelle : you could use `... =<< xx', if you prefer
08:17:59 <ski> (e.g. if `xx' is large)
08:18:02 <bartavelle> the reverse fish scares me
08:18:12 <bartavelle> I never used it
08:18:15 <merijn> typoclass: Java interfaces can't do polymorphic constants like minBound/maxBound
08:18:20 <ski>   y <- f =<< g x
08:18:24 <ski> reads more naturally than
08:18:26 * nicoo stabs bartavelle with a swordfish.
08:18:28 <ski>   y <- g x >>= f
08:18:29 <ski> imo
08:18:36 <S11001001> nicoo: that's good
08:18:43 <bartavelle> I am used to doing it the other way around
08:18:45 <merijn> > minBound :: Int
08:18:46 <lambdabot>   -9223372036854775808
08:18:51 <merijn> > minBound :: Char
08:18:52 <lambdabot>   '\NUL'
08:19:01 <merijn> > minBound :: Bool
08:19:02 <lambdabot>   False
08:19:02 <ski> > minBound + 1
08:19:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:19:04 <lambdabot>    `GHC.Num.Num a'
08:19:04 <lambdabot>      ari...
08:19:07 <typoclass> merijn: right, but that's more that haskell has polymorphism, not so much an issue with typeclasses
08:19:12 <signalsea> mm_freak: thanks
08:19:18 <ski> hm
08:19:22 <merijn> typoclass: EDOESNOTPARSE
08:19:49 <S11001001> :t (+ 2)
08:19:50 <ski> > minBound || True
08:19:50 <lambdabot> forall a. (Num a) => a -> a
08:19:51 <lambdabot>   True
08:20:14 <merijn> typoclass: You asked "how are haskell typeclasses different from interfaces", I provide an example of something typeclasses can do and interfaces can't and then you say that doesn't have anything to do with typeclasses?
08:20:15 <uhhh> So ... Num a => a ... can be read as takes Int, Integer, Float, or Double and returns the value given? I'm trying to figure out when I see => as opposed to ->
08:20:29 <S11001001> typoclass: if you give (+ 2) an Int, you get an Int back, at the type level; interfaces don't do that
08:20:53 <S11001001> uhhh: it means "given that a has a Num instance, this has type a"
08:20:58 <nicoo> uhhh: It means that a is a type variable that must be in typeclass Num
08:21:08 <merijn> uhhh: "(+) :: (Num a) => a -> a -> a" should be read as "(+) has type "a -> a -> a" for any 'a' that is an instance of Num"
08:21:20 <applicative> uhhh: "Num a => " means:  the following works for any number type a
08:21:36 <ski> uhhh : `sum :: Num a => [a] -> a', means that `sum' takes a list of `a's as input, and returns an `a', *provided* that `a' is a "number type" (i.e. is in the type class `Num')
08:21:43 <applicative> @quote fugue
08:21:43 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
08:21:46 <merijn> uhhh: Int, Integer, Float and Double are all (for obvious reasons) instances of Num, but you can write your own
08:22:01 <merijn> For example, lambdabot has a num instance for tuples
08:22:11 <applicative> instance Num Char where fromInteger = chr
08:22:12 <merijn> > (2,2) + (3,5)
08:22:13 <lambdabot>   (5,7)
08:22:30 <ski> S11001001 : hm, can't you get that with a `This' type ?
08:22:54 <merijn> @src elem
08:22:54 <lambdabot> elem x    =  any (== x)
08:22:55 <uhhh> You guys are helpful! Thanks.
08:23:13 <ski> we try to :)
08:23:20 <mroman> @hoogle Int -> Integer
08:23:21 <merijn> @quote megahelpful
08:23:21 <lambdabot> Data.Bits bit :: Bits a => Int -> a
08:23:21 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
08:23:21 <lambdabot> Data.Bits complementBit :: Bits a => a -> Int -> a
08:23:21 <lambdabot> MyCatVerbs says: [talking about #haskell] seriously, it's like the entire planet got mutant powers and many all the people here just happened to get Psychic MegaHelpFulness.
08:23:23 <S11001001> typoclass: another difference: constrained instances aren't like subclassing, because you can write things like instance Semigroup a => Monoid (Maybe a) where mempty = Nothing mappend = liftA2 (<>)
08:23:23 <applicative> is there some function or simple device for going Monoid a => Maybe a -> a ?
08:23:41 <merijn> applicative: maybe + empty?
08:23:56 <merijn> :t maybe
08:23:57 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:24:10 <ski> @type fromMaybe mempty
08:24:11 <lambdabot> forall a. (Monoid a) => Maybe a -> a
08:24:21 <applicative> merijn: yeah, I was using that, but it seemed too long, I was thinking something like mcat Nothing = mempty ; mcat (Just a) = a would be nice
08:24:43 <uhhh> Does Haskell have abstract functions?
08:24:47 <applicative> maybeCat ?
08:24:47 <ski> S11001001 : subclassing is (somewhat) more like subclassing :)
08:24:51 <merijn> uhhh: What does that mean?
08:24:53 <S11001001> er, not liftA2 (<>)
08:24:58 <nicoo> uhhh: What do you mean ?
08:25:21 <uhhh> Well... something like... (fun x -> x) ()
08:25:24 <nicoo> uhhh: My Psychic MegaHelpFulness is not enough to remotely read you mind :°(
08:25:26 <S11001001> ski: that's the thing; what looks like subclassing is just a special case of constrained instances, so isn't worth separately considering
08:25:37 <atriq> :t \x -> x --uhhh
08:25:38 <Eduard_Munteanu> uhhh: ah, lambdas, yes.
08:25:38 <lambdabot> forall t. t -> t
08:25:39 <merijn> uhhh: You mean lambda's?
08:25:51 <atriq> :t (\x -> x) "uhhh"
08:25:53 <lambdabot> [Char]
08:25:54 <nicoo> uhhh: We have lambdas and polymorphism
08:25:55 <atriq> > (\x -> x) "uhhh"
08:25:56 <S11001001> ski: so the analogy will lead you to thinking you can't do things you can do
08:25:57 <lambdabot>   "uhhh"
08:25:59 <merijn> :t (\x -> 1 + x)
08:26:00 <lambdabot> forall t. (Num t) => t -> t
08:26:08 <merijn> > (\x -> 1 + x) 5
08:26:09 <lambdabot>   6
08:26:17 <uhhh> merijn: Yes. I guess that is what I mean. Like lambda expressions
08:26:36 <merijn> As you can see the answer is yes ;)
08:26:36 <ski> S11001001 : note that `class Foo a => Bar a' is different from `instance Foo a => Bar (..a..)' (as i assume you know)
08:26:39 <hpaste> applicative annotated “thingie” with “thingie -- builder variant” at http://hpaste.org/76752#a76758
08:26:48 <S11001001> ski: doh :)
08:26:52 <merijn> (Man, half of #haskell is sitting around bored waiting to answer simple questions ;)
08:27:02 <S11001001> merijn: yeah
08:27:21 <applicative> merijn: of course, we're evangelical Haskellers
08:27:40 <Philippa> merijn: that or polling the chan intermittently, yeah
08:27:50 <uhhh> So I typed (\x -> 1 + x) 1 in tryhaskell console and got terminated
08:27:53 <uhhh> :(
08:27:53 <ski> uhhh : was `(fun x -> x) ()' meant to be OCaml ?
08:28:05 <merijn> Quick question for our resident academics: Does anyone know how to unbreak the description environment in the IEEEtran LaTeX class
08:28:30 <uhhh> ski: I haven't tried OCaml. But I have used F#
08:28:34 <typoclass> merijn: what i meant is this -- haskell's map function couldn't really be done in traditional java, because (written in our syntax) you'd end up with something like "map :: (Object -> Object) -> [Object] -> [Object]". you couldn't have the compiler enforcing that the 1st and 3rd "Object" in that signature are the same type, and that the 2nd and 4th are. in my view, this is because java lacks haskell's polymorphism. it is not because java l
08:28:34 <ski> ok
08:28:39 <applicative> here's my contribution to the faster-than-python-but-still-idiot-simple competition ^^^ following dcoutts_ and chrisdone ^^^
08:28:41 <ski> (close enough)
08:28:48 <merijn> uhhh: hmm, that's not right...if you download haskell platform you get ghci which lets you evaluate expressions on the commandline, which is probably a bit more robust
08:28:52 <nicoo> merijn: Never even used it
08:28:52 <uhhh> Lol. That's what I've read
08:28:52 <typoclass> merijn: that's what i meant above when i said it's about polymorphism not typeclasses
08:29:04 <Cale> typoclass: "it is not because java" -- you got cut off
08:29:19 <uhhh> merijn: Thanks! Will try that
08:29:23 <typoclass> sorry; "it is not because java lacks haskell's typeclasses"
08:29:56 <ski> @quote please.talk
08:29:56 <lambdabot> Dave_Benjamin says: please talk to your son or daughter about parametric polymorphism
08:30:07 <merijn> uhhh: You can also evaluate haskell expression via lambdabot by prefixing them with "> " (lambdabot also respodns to privmsg)
08:30:19 <tac> > 1 + 2
08:30:20 <lambdabot>   3
08:30:21 <nicoo> typoclass: You can, actually, by instianciating some Map<A,B> class, then using some applpy method
08:30:23 <jesyspa> typoclass: Do Java generics differ from C++ templates so much, then?  I could see map being defined in C++ fairly easily.
08:30:25 <nicoo> Ugly though
08:30:25 <merijn> uhhh: But lambdabot doesn't let you do IO and has some non-standard extensions that can confuse people :)
08:30:34 * applicative hadnt realized how smooth the monoid instance makes these Builders till he saw dcoutts' use of them
08:30:45 <tac> jesyspa: C++ templates are much more powerful than generics.
08:30:52 <uhhh> (\x -> x + 1) 1 gives parsing error on ->
08:31:04 <jesyspa> template<typename T> map(function<T(T)>, list<T>, list<T>) // they can't even do this? O_o
08:31:05 <typoclass> jesyspa: i'm not really familiar with java generics, and less with c++ templates
08:31:16 <tac> > (\x -> x + 1) 1
08:31:17 <lambdabot>   2
08:31:28 <tac> >(\x -> x + 1) 1
08:31:43 <tac> > has to be at the very start, and there has to be a space after it.
08:31:44 <lambdabot>   <no location info>: parse error on input `,'
08:31:54 <jesyspa> typoclass: Ah, you meant with runtime polymorphism.  I see.
08:32:07 <typoclass> jesyspa: my hunch is that generics get you a step closer to haskell's polymorphism
08:32:44 <typoclass> jesyspa: (in you signature you'd have to have a T and an S, but that doesn't change your larger point :-) )
08:32:49 <typoclass> :t map
08:32:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:33:36 <S11001001> jesyspa: generics in java are typechecked independently of their uses
08:34:27 <S11001001> jesyspa: as with haskell, as typoclass alludes
08:34:28 <typoclass> nicoo: right, i meant traditional java. since it got generics things have changed a little
08:38:43 <mroman> main.hs: <stdout>: commitBuffer: invalid argument (invalid character)
08:38:44 <mroman> :(
08:38:46 <ski> jesyspa : yes, you can do `map' with generics in Java (1.5)
08:40:36 <uhhh> I think I really like this language. Is digging in to Real World Haskell a good place to start?
08:41:04 <typoclass> uhhh: glad to hear it ;) lyah is a good textbook available free of charge
08:41:05 <typoclass> @where lyah
08:41:05 <lambdabot> http://www.learnyouahaskell.com/
08:41:56 <uhhh> LOL!
08:42:13 <uhhh> Sorry that site is funny
08:42:35 <nicoo> uhhh: It is designed to look « playful »
08:42:46 <typoclass> uhhh: right, the authoer explains haskell pretty well and also has a quirky humor
08:43:07 <uhhh> Right on. The site and title is pretty funny
08:43:12 <mroman> interesting.
08:43:27 <mroman> Haskeline seems not to have a problem with that
08:44:21 <typoclass> mroman: the "invalid character" might be cause by some encoding thing, utf8 problems or whatever
08:44:36 <dsdeiz> one thing i find hard about learning this language is because i seem to have bad habits with php xD
08:45:10 <uhhh> I look at php one time. Too many $ signs all over the place
08:45:20 <uhhh> *looked
08:46:23 <uhhh> I bet everyone loves php and I shouldn't have said anything
08:46:45 <typoclass> dsdeiz: no worries :) everyone has some bad habits
08:47:01 <dsdeiz> uhhh: i have a feeling no one does in this channel
08:47:07 <nicoo> uhhh: Nobody with any sense likes PHP
08:47:24 <uhhh> Ok. I don't feel as bad now
08:47:36 <nicoo> PHP is non-sensival by design
08:47:54 * nicoo retrains himself and stops the upcoming rant
08:48:24 <uhhh> I just started using another OS (other than Windows) and I don't know why it has taken me this long to see the other side
08:48:41 * ski . o O ( <http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/> )
08:48:47 <nicoo> Yessssssssssssssss, come to the dark side :)
08:48:54 <uhhh> Lol
08:48:59 <nicoo> We have monaaaaadsssssssssssssss
08:49:21 * CptCaptain evil laughter
08:49:41 <tac> ski hah
08:50:04 <jeff_s1> I ported aeson to use Fixed instead of the custom Number type. Should I upload that as a package on hackage, maybe named aeson-fixed?
08:50:08 <uhhh> The only thing I'm having trouble with so far is my GPU
08:50:18 <uhhh> So drivers or something
08:50:20 <jeff_s1> I should probably changed the module names, too
08:50:39 <uhhh> *slow
08:50:48 <uhhh> To many typos today
08:50:52 <uhhh> *too
08:50:54 <uhhh> lol
08:51:23 <nicoo> Is there a Cookie monad ?
08:51:27 <nicoo> @hoogle cookie
08:51:27 <lambdabot> Network.CGI.Cookie Cookie :: String -> String -> Maybe CalendarTime -> Maybe String -> Maybe String -> Bool -> Cookie
08:51:28 <lambdabot> Network.CGI Cookie :: String -> String -> Maybe CalendarTime -> Maybe String -> Maybe String -> Bool -> Cookie
08:51:28 <lambdabot> Network.HTTP.Cookie data Cookie
08:51:47 * nicoo is so disappointed
08:57:32 <Polarina> What would a Cookie monad do? Carry cookies?
08:57:57 <exFalso> If i keep tossing a coin, will i provably get a head at some point?
08:57:57 <typoclass> Polarina: be consumed by the Monster monad
08:59:19 <osfameron> I think rosencrantz and guildenstern proved that you might not
08:59:46 <Polarina> exFalso, maybe, maybe not. Welcome to the world of probabilites, where it's probable you'll probably never get a head on a coin in your whole lifetime.
09:00:37 <k00mi> Polarina: he asked "proVably"
09:00:41 * Polarina makes up bad jokes.
09:00:42 <k00mi> not probably
09:00:51 <Polarina> k00mi, my bad.
09:01:26 <signalsea> is there a way to group function signature declarations in a class so they can all share the same context?
09:02:01 <Cale> exFalso: You get a head eventually with probability 1. But obviously, there is a sequence of coin flips wherein you flip tails forever. It's just that this sequence has probability 0 (which is not the same as saying it can't happen)
09:02:35 <Cale> Every other individual sequence also has probability zero, and yet one of them will happen.
09:02:51 <parcs`> @check or
09:02:53 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
09:03:02 <Eduard_Munteanu> I guess any infinite sequence has zero probability.
09:03:13 <Cale> right
09:03:21 <typoclass> there's a nonzero probability of getting tails 1000 times. also there's a nonzero probability of getting tails a million billion dozen bazillions
09:03:25 <parcs`> @check \xs -> null xs || or xs
09:03:26 <lambdabot>   "Falsifiable, after 1 tests:\n[False,False]\n"
09:03:43 <exFalso> I see
09:03:49 <Cale> signalsea: I'm not sure what you mean by that
09:05:02 <jeff_s1> @check \z -> z > 3
09:05:03 <signalsea> Cale: something like (Foo a) => {fun1 :: String -> Foo a;   fun2 :: Bool -> Foo a}
09:05:03 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
09:05:11 <jeff_s1> That's neat.
09:05:31 <Cale> signalsea: You have Foo as both a class and a type there...
09:05:39 <typoclass> signalsea: you mean you have some functions that all need the same values? there's a few standard approaches for that, like passing around a record or using the Reader monad
09:05:58 <parcs`> > unwords . lines $ "Falsifiable, after 0 tests:\n0\n"
09:06:00 <lambdabot>   "Falsifiable, after 0 tests: 0"
09:06:28 <exFalso> signalsea: you can put a context on the class itself which will be shared
09:06:34 <jfischoff> having trouble compiling unix-2.6.0.0 on mac with ghc 7.4.2 64. Errors look like warning: dereferencing ‘void *’ pointer
09:06:37 <jfischoff> any ideas?
09:06:52 <jfischoff> seems to work fine with 7.6.1
09:07:05 <exFalso> like class (Functor m) => Monad m where :D
09:09:04 <cornihilio> hey, I want to deploy something that's basically a webapp. what should I use, yesod or snap? yesod seems to be built on the rails mentality, but I'm really impressed by the warp benchmarks. is it easy to deploy a single-page web app in yesod? could I find an example anywhere?
09:09:43 <astor> how do I visualize a foo.prof file?
09:09:47 <Cale> cornihilio: Those are both suitable for web applications.
09:09:54 <jeff_s1> cornihilio: You can use warp without the rest of yesod.
09:10:01 <Cale> cornihilio: You might also want to check out happstack
09:10:04 <signalsea> Ok, more involved "hypothetical synax":  class Bar a b where; type TypSym a b :: * -> *;  let (Bar a b ~ sometyp) in (foo :: sometyp x -> b; foo2 :: sometyp x -> String)
09:10:36 <jeff_s1> Here's some syntax I'd like: import qualified Data.* as *
09:11:29 <Cale> signalsea: you mean  foo :: sometyp x => b
09:11:41 <Cale> errr
09:11:42 <rwbarton> even that does not kind check
09:11:48 <rwbarton> perhaps sometype => x -> b
09:11:53 <Cale> Yeah, you'd need type TypSym a b :: * -> Constraint
09:12:08 <rwbarton> but uh... class methods have that particular constraint anyways
09:12:09 <Cale> actually, wait, you didn't use that
09:12:13 <fari> Hi, I am kind of interested in this Haskell/webapps thing. Has anyone further experiences with webapp development under Haskell? Snap possibly?
09:12:15 <rwbarton> signalsea: try again
09:12:19 <signalsea> I asked a question earlier about putting type synonyms on the RHS so i could save myself keystrokes; the answer to that seems to be "you can't do that", but i found i can do it in function contexts using the (~) operator, so i was wondering if there's a way to do it that way
09:12:25 <Cale> Yeah, I don't understand what you're trying to do here
09:12:49 <Cale> You seem to be confused about whether Bar is a class or a type
09:13:16 <signalsea> i'm not, I just want to declare a context once inside a class and use it for several signatures
09:13:35 <typoclass> signalsea: i think you should tell us more about what you're trying to accomplish. you'll get better advice that way
09:13:58 <typoclass> signalsea: do you meant "context" in the haskell sense? ("the stuff between :: and =>")
09:14:09 <Cale> also, all the signatures of values in a class declaration are already implicitly constrained by the class
09:14:10 <signalsea> typoclass: yes
09:14:10 <typoclass> s/meant/mean
09:14:55 <Cale> Using ConstraintKinds, you can define type synonyms of kind Constraint
09:16:11 <rwbarton> anyways i think the answer is no, you cannot do exactly what you are trying to do, but if you give a realistic example we might be able to give suggestions of other ways to reduce the duplication
09:16:39 <Cale> Yeah, what does your actual program look like?
09:16:44 <Cale> Can you paste it on hpaste?
09:16:49 <signalsea> Is there a type constructor that takes a Constraint and adds it to a type?
09:16:58 <Cale> =>
09:17:09 <typoclass> signalsea: is this relevant at all? https://plus.google.com/110988559818762092753/posts/CERuTQbM2F5 ignore the implicit param thing and the IORef, the point is how he uses the context
09:18:08 <elliott> that thing looks like a good use-case for reflection :p
09:18:10 <Cale> I don't think that's the problem signalsea is having
09:18:10 <signalsea> Cale: is => a type constructor? how can i output its kind?
09:18:13 <Cale> Though I don't know
09:18:33 <elliott> (=>) :: Constraint -> a -> a, I think.
09:18:37 <Cale> signalsea: Well, I'm not sure it's really a proper type constructor (but maybe with ConstraintKinds turned on...)
09:18:48 <signalsea> I will put my code on hpaste... i actually am not in great need of this feature, but i was wondering about if i could do it
09:18:51 <elliott> Yeah, (=>) is a syntax error.
09:19:02 <signalsea> elliott: yeah that is what i got too
09:19:02 <elliott> But I think you can define type Foo a b = a => b and that'll have a proper kind.
09:19:17 <signalsea> really? that is cool
09:19:40 <Cale> signalsea: Basically, you'll have to turn on a very new and relatively untested extension though :)
09:19:44 <dixie_> > sum $ repeat 0
09:19:49 <lambdabot>   mueval-core: Time limit exceeded
09:19:52 <elliott> anyway I don't know the context but it sounds like doing this is a bad idea
09:19:55 <beaky> http://ideone.com/TpejKR how do I let the user enter the integers on both separate lines and on a single line?
09:20:02 <beaky> like how a C++ version would work
09:21:10 <madjestic> hey guys, trying to clean up some broken dependencies.  Running ghci -v shows me a bunch of "hiding pacakage bla-bla.0.8 to avoid conflict with later version bla-bla.0.9". Is it safe to ignore it, or should that be resolved?
09:21:38 <madjestic> or is there a more appropriate channel for ghc-related questions?
09:22:26 <Cale> madjestic: Depending on what it is, it might be better to try to ensure you only have one version of most, if not all packages.
09:22:48 <Cale> madjestic: But of course be careful about that :)
09:23:17 <Cale> madjestic: One rule of thumb is to try to avoid installing newer versions of any of the packages that come with GHC.
09:23:24 <madjestic> Cale, yeah, I see some cross dependencies there (got it broken through installing xmobar (for xmonad sake))
09:23:56 <madjestic> kept my fingers crossed, I guess I should try sacrificing a chicken next time
09:26:10 <hpaste> signalsea pasted “cxt sharing?” at http://hpaste.org/76760
09:27:08 <signalsea> there you are, if you are interested in what I'm doing; Like I said, no big need for this feature atm, i was just wondering
09:28:05 <signalsea> lines 18-22 are what i was thinking about
09:29:57 <clahey> beaky: What happens when you write them on separate lines?
09:30:13 <rwbarton> isn't "combine" unusable due to elem and c being unreachable from its type?
09:30:37 * ski thinks signalsea wants something like SML's `local <decls> in <decls> end'
09:30:41 <rwbarton> (I realize this is somewhat off-topic)
09:31:50 <signalsea> rwbarton: what do you mean? I am actually testing whether it all works atm, i will see
09:31:51 <ski> (plus the ability to define synonyms with (some) tyvars in the body not bound in the definiendum, assuming they're still in scope)
09:32:05 <rwbarton> well you will see then :)
09:32:11 <signalsea> it all compiled with no warnings
09:32:16 <signalsea> but ill see
09:33:18 <beaky> clahey: the one I just pasted just stops getting input after hitting newline :(
09:33:28 <rwbarton> of course using fundeps you would have the name "coll" for free...
09:33:39 <rwbarton> class Combinable elem c coll | elem c -> coll where ...
09:33:47 <rwbarton> not that I am endorsing using fundeps
09:34:22 <Cale> Sometimes fundeps are nicer syntactically.
09:39:00 <beaky> now that I know what >>= does (and what >> does), what does return do?
09:39:23 <Orungutango> what is the class and the bits used for netid and hostid of the up-address 194.24.17.4 ?
09:39:38 <troydm> beaky: return is just a -> IO a
09:39:39 <ski> beaky : `return x' is a "trivial action" that "does nothing, apart from yielding `x' as a result
09:40:11 <ski> beaky : correspondingly, `return x >>= foo' is the same as just `foo x', and `blah >>= return' is the same as just `blah'
09:40:39 <Cale> In other words, return v is the action which does nothing except to return v ;)
09:41:44 <beaky> so it's just like return in C?
09:41:47 <Cale> no
09:41:53 <clahey> beaky: Not at all.
09:42:01 <Ferdirand> absolutely not
09:42:04 <Cale> It's just like a procedure with only a single return in it
09:42:13 <Ferdirand> (sorry heavy lag)
09:42:33 <clahey> Well it often comes at the end of a do block, so it's similar in that way, but that's a pretty trivial similarity.
09:43:01 <Cale> beaky: return in C has a control effect, making it not like other C procedures
09:43:27 <ski> (.. making it a non-procedure, in fact)
09:43:32 <trotro> the return keyword of haskell is a trap
09:43:42 <Cale> Haskell doesn't have a return keyword.
09:43:45 <trotro> why that word whas chosen ?
09:43:51 <trotro> sorry the retrun function
09:43:57 <rwbarton> "return v is the action which does nothing except to return v"
09:43:58 <beaky> haskell doesn't really have any control structures besides recursion ^^
09:44:00 <Cale> For the reason I gave
09:44:07 <beaky> @src return
09:44:07 <lambdabot> Source not found. Where did you learn to type?
09:44:10 <beaky> lol
09:44:16 <beaky> :t return
09:44:17 <Cale> "return v is the action which does nothing except to return v"
09:44:17 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:44:18 <ski> @src Maybe return
09:44:18 <lambdabot> return              = Just
09:44:28 <ski> @src Either return
09:44:28 <lambdabot> return        = Right
09:44:32 <beaky> so return introduces impurities to a pure thing?
09:44:42 <rwbarton> uh
09:44:48 <Cale> beaky: That's an awkward way to think about it
09:44:56 * ski . o O ( `return' is just right and proper )
09:45:13 <typoclass> ski: i liek 'pure' moar!!1!
09:45:16 <Cale> but it produces a computation which does nothing, and produces the given result when run (whatever running means in context)
09:45:32 <Cale> > return 6 :: [Integer]
09:45:33 <lambdabot>   [6]
09:45:33 <trotro> i thuink that unit would have been a better name
09:45:38 <Cale> ^^ is that an impurity?
09:45:42 <beaky> return 0 :: IO Int
09:45:46 <beaky> > return 0 :: IO Int
09:45:47 <ski> beaky : `return' is a way to "fake" an effectful computation, by providing one that doesn't actually represent any effects
09:45:48 <lambdabot>   <IO Int>
09:45:57 <beaky> ah
09:45:58 <typoclass> beaky: "return 4" is sometimes read as wrapping 4 into whatever monad you're using, e.g. the list monad as cale demonstrated
09:46:00 <jesyspa> beaky: I think in C++ terms, return may be best described as a constructor call.  (Nothing to do with Haskell constructors.)  You have a type IO<Int> and return a is like IO<Int>(a), except it's generic about what it calls.
09:46:06 <Cale> trotro: unit would say nothing about what return actually does.
09:46:14 <beaky> ah
09:46:16 <trotro> it represents the unit value
09:46:21 <beaky> so return just wraps something in a monad
09:46:22 <jesyspa> (This may be entirely wrong, but it's worked for me up till now.)
09:46:25 <ski> > length [return x :: IO Int | x <- [1,4,2,8,5,7]]
09:46:26 <clahey> trotro: No, the unit value is (), right?
09:46:26 <lambdabot>   6
09:46:28 <clahey> beaky: Yep.
09:46:36 <trotro> clahey, i'am speaking about something else
09:46:37 <beaky> I get it now! I finally understand monads
09:46:45 <Cale> trotro: Sure, it's the unit for the monad, but in order to actually understand why it's a "unit" in any sense, you need to understand the category of endofunctors and monoid objects...
09:46:50 <clahey> beaky: Oh, how many times I've said that.
09:46:53 <trotro> return 4 means one value
09:47:13 <clahey> Oh, I see why it would be unit.  Got it.
09:47:13 <beaky> a monad is just a thingy that contains a function
09:47:18 <Cale> beaky: lol
09:47:30 <beaky> and if you >>= a monad, you get to use the function
09:47:42 <Cale> beaky: you never >>= a monad
09:47:55 <clahey> beaky: Replace function with computation and monad with monadic value to get a lot closer.
09:47:55 <Cale> IO is a monad, getLine is not a monad
09:48:01 <beaky> right
09:48:07 <clahey> I think.
09:48:21 <ski> beaky : (a) a monad is a thing that lives on the type level, not on the value level. e.g. `return 0' and `getLine' are not monads, they're monadic *actions*; (b) the monadic action `return 0 :: Maybe Int' doesn't contain a function
09:48:28 <rwbarton> you should also distinguish "i am learning about monads" from "i am learning about IO"
09:48:57 <Cale> Yeah, IO happens to be a monad, but the fact that it's a monad is relatively unimportant, and tells you very little about how to write IO actions.
09:49:23 <Cale> (it does tell you something about what things you can do to compose IO actions, but not everything)
09:50:39 <clahey> Is IO a monoid?  No, because there's no mzero.
09:50:52 <trotro> a monad can't be a monoid
09:51:07 <jesyspa> Eh?  List isn't a monoid?
09:51:11 <trotro> no
09:51:12 <clahey> trotro: Sorry, is IO a a monoid was the question I meant to ask.
09:51:13 <Jafet> @quote endofunctors
09:51:13 <lambdabot> hfaafb says: mopeds are just mopoids in the category of endofunctors
09:51:15 <trotro> list int is a monoid :D
09:51:18 <rwbarton> "is a monoid" is also a dangerous phrase
09:51:20 <jesyspa> Ohh, of course.
09:51:33 <Cale> > mzero :: IO ()
09:51:35 <lambdabot>   <IO ()>
09:52:29 <rwbarton> since there are normally several ways to give a type a monoid structure
09:53:02 <clahey> Oh, Monoid a => instance Monoid IO a
09:53:06 <clahey> ?
09:53:40 <ski> trotro : `[a]' is a monoid, for every type `a', yes
09:53:42 <Cale> clahey: That's probably the reasonable instance to give, but it's not in Data.Monoid
09:54:07 <clahey> Cale: Nor in IO?
09:54:12 * ski isn't really sure `Monoid (IO a)' is that sensible at all
09:54:56 <trotro> ski, yes, and ?
09:55:25 <Cale> return mempty / liftM2 mappend  give a proper monoid structure...
09:56:10 <clahey> Oh, is that true of all monads?
09:56:31 <clahey> I suppose so.
09:56:42 <rwbarton> well IO isn't known for satisfying a bunch of special laws
09:56:43 <ski> trotro ?
09:56:54 <trotro> <ski> trotro : `[a]' is a monoid, for every type `a', yes >> i was just reacting to that
09:57:09 <yitz> rwbarton: in fact, IO is known for breaking a bunch of special laws
09:57:30 * copumpkin calls in the monad police
09:57:30 <signalsea> rwbarton: yeah  I see now why combine doesn't work; it's arguments don't infer what elem and c are, and this what Collect elem c should be.
09:58:01 <MonadPolice> what is your emergency?
09:58:07 <copumpkin> MonadPolice: IO IS BREAKING THE LAWS
09:58:10 <signalsea> ski: do you have any reference for that SML feature you mentioned? Sometimes I dream of having arbitrary namespace declarations in Haskell
09:58:10 <clahey> Cale: One issue would be that some of the other Monads generate Monoids in their own way, so there would be duplicate definitions of, for example, [a] as a Monoid.
09:58:23 <yitz> haha
09:58:25 <MonadPolice> copumpkin: I will investigate
09:58:47 <MonadPolice> IO: you are under arrest
09:58:53 <IO> noooooo
09:59:00 * MonadPolice chases after IO
10:00:53 <ski> signalsea : in SML you can write `local fun f x = ..x..f.. in fun g y = ..y..f..g.. end' where `g' has access to `f', but this whole declaration only "exports" `g' -- and yes you can have multiple declarations (of types and values) both before and after the `in'
10:01:19 <ski> signalsea : it's like a `let'-`in'-`end', but for declarations (between the `in' and `end') instead of expressions
10:02:06 <killy9999> does it make sense to build library using -eventlog and -rtsopts options?
10:02:32 <ski> signalsea : <http://homepages.inf.ed.ac.uk/stg/NOTES/node16.html> apparently has an example use
10:02:48 <killy9999> dcoutts: I managed to rewrite my cabal file, thanks for help earlier today :)
10:03:32 <ski> (of course the "Definition of Standard ML" and "Commentary on Standard ML" explains it, but those are unfortunately not available freely on the web)
10:03:48 <beaky> functions are fun
10:03:51 <clahey> beaky: main = main' [] where main' acc = firstTwoLines of your code >> if length acc ++ xs < 3 then main acc ++ xs
10:04:14 <clahey> beaky: Or rather xs = acc ++ ... and then pass xs to main'.
10:04:32 <beaky> right
10:04:34 <clahey> That's what I might do.
10:05:03 <beaky> http://ideone.com/P6jFr1 my readInts doesn't work :(
10:05:59 <deech> I've seen the Proxy type used in code as a "witness". What does it mean to witness a type and why is it necessary?
10:07:22 <Cale> beaky: Perhaps you want to write a variant of getLine which just eats up to and including any whitespace character?
10:08:52 <beaky> yes
10:09:12 <clahey> beaky: Instead of all that messing about with getLine, why not just do take 3 . map read . words <$> getContents ?
10:09:45 <beaky> lol
10:09:48 <clahey> Add in a type definition somewhere.
10:09:53 <beaky> what does <$> and getContents do
10:10:21 <beaky> :t take 3 . map read . words <$> getContents
10:10:22 <lambdabot> forall a. (Read a) => IO [a]
10:10:41 <beaky> how did you come up with that
10:10:57 <clahey> So, with things you already know, make it:
10:11:06 <clahey> :t return . take 3 . map read . words =<< getContents
10:11:08 <lambdabot> forall a. (Read a) => IO [a]
10:11:25 <clahey> getContents returns all user input as a string.
10:11:42 <clahey> But it returns it as it needs it.
10:12:35 <clahey> <$> is one of the applicative functor operators.
10:12:37 <clahey> :t (<$>)
10:12:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:12:42 <beaky> what's that
10:13:13 <clahey> So basically, (<$>) a b = b >>= return . a
10:13:20 <beaky> ah
10:13:43 <beaky> :q
10:13:51 <clahey> So whatever thing b returns gets processed by a and then rewrapped as a monad in your current way of thinking about things.
10:14:20 <clahey> Oh, I think (<$>) = fmap?
10:14:51 <clahey> :t fmap
10:14:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:16:19 <clahey> I wonder what happens if you execute getContents twice.  I bet you get the same values both times.
10:16:28 <beaky> http://ideone.com/ebAB7F doesn't work :(
10:17:19 <rwbarton> get rid of that getLine
10:17:38 <rwbarton> you're throwing the numbers away...
10:17:39 <elliott> clahey: You don't.
10:17:44 <clahey> elliott: Crash.
10:17:53 <elliott> Well, an error.
10:17:59 <elliott> Not really a crash as in an everything-explodes crash.
10:18:10 <clahey> An exception.
10:18:21 <rwbarton> i think your program just doesn't work properly
10:18:24 <elliott> yitz: btw, what laws does IO break?
10:18:41 <elliott> AFAIK the only monad law IO "breaks" is also broken by Reader and is basically a case of reading the laws too strictly (by involving _|_)
10:19:37 <rwbarton> oh you actually get an exception on the second getContents, that is nice
10:20:07 <beaky> http://ideone.com/pzJ3MN
10:20:11 <beaky> it works!
10:20:12 <beaky> thanks guys
10:21:40 <clahey> I love that you can pass the value returned from getContents to a pure function.
10:22:12 <beaky> http://ideone.com/6N1bb3 tis is the C++ version
10:23:25 <otters> which priority queue package should I use
10:25:20 <clahey> beaky: The C++ version is so functional.
10:25:38 <clahey> Maybe more functional than the haskell version.
10:26:39 <clahey> (Just because you built sum and product in the C++ version, but they were already there in haskell.)
10:26:50 <beaky> right
10:30:36 <beaky> http://ideone.com/V7Mbb5 C version
10:31:46 * hackagebot haskelldb 2.2.2 - A library of combinators for generating and executing SQL statements.  http://hackage.haskell.org/package/haskelldb-2.2.2 (JustinBailey)
10:31:48 * hackagebot haskelldb-hdbc 2.2.2 - HaskellDB support for HDBC.  http://hackage.haskell.org/package/haskelldb-hdbc-2.2.2 (JustinBailey)
10:31:50 * hackagebot haskelldb-hdbc-odbc 2.1.2 - HaskellDB support for the HDBC ODBC driver.  http://hackage.haskell.org/package/haskelldb-hdbc-odbc-2.1.2 (JustinBailey)
10:31:52 * hackagebot haskelldb-hdbc-postgresql 2.1.2 - HaskellDB support for the HDBC PostgreSQL driver.  http://hackage.haskell.org/package/haskelldb-hdbc-postgresql-2.1.2 (JustinBailey)
10:31:54 * hackagebot haskelldb-hdbc-sqlite3 2.1.2 - HaskellDB support for the HDBC SQLite driver.  http://hackage.haskell.org/package/haskelldb-hdbc-sqlite3-2.1.2 (JustinBailey)
10:32:27 <Philonous> I wonder how to properly handle a "dependently-typed" C-function like setsockopt
10:33:08 <clahey> beaky: Could you send me the link for the latest version of your turing machine?  Haskell would be easiest to read.
10:33:13 <mauke> worst case: separate functions per type
10:33:15 <Cale> beaky: I never knew that scanf handled whitespace like that. Quite odd.
10:34:00 <Cale> (I would have expected it to treat whitespace characters like other ordinary characters)
10:34:10 <clahey> beaky: Oh, I found it.
10:34:12 <geekosaur> scanf is pretty scary
10:34:25 <mauke> rule of thumb: anyone who uses scanf doesn't know how it works because people who do generally don't use scanf
10:34:46 <geekosaur> ^^
10:34:56 <typoclass1> cale: you mean this? scanf(" \n\t%d \t\n%d \t\n%d" ...). it's news to me as well. got to be "one of"
10:35:10 <parcs`> Philonous: you mean in that the type of the value of the option depends on the option?
10:35:22 <Philonous> parcs`:  Yes
10:35:33 <parcs`> Philonous: easy, using GADTs with a phantom type
10:35:46 <Cale> typoclass1: It apparently matches each sequence of whitespace characters in its format with one or more occurrences of any of those characters in the user input.
10:36:23 <rwbarton> yeah you don't have to write " \n\t"
10:36:23 <lispy> Philonous: You can think of setsockopt as defining a family of API functions and then represent those as different Haskell functions.
10:36:23 <parcs`> Philonous: data SockOpt a where SockOpt1 :: SocOpt Bool; SockOpt2 :: SocOpt Int; etc.. and then setSockOpt :: SockOpt a -> a -> IO ()
10:36:35 <typoclass> Cale: right, like doing oneOf " \n\t" in parsec
10:36:54 <Cale> Like   many1 (oneOf " \n\t")
10:36:56 * hackagebot JuicyPixels 2.0.2 - Picture loading/serialization (in png, jpeg, bitmap and gif)  http://hackage.haskell.org/package/JuicyPixels-2.0.2 (VincentBerthoux)
10:37:30 <rwbarton> scanf(" %d") matches tabs and newlines already
10:37:45 <Cale> * A sequence of white-space characters (space, tab, newline, etc.; see isspace(3)).  This directive matches any amount of white space, including none, in the input.
10:37:47 <Cale> aha
10:37:52 <geekosaur> re setsockopt, it's complicated by the fact that thefunction depends on the level, but that just means you include that in the same type
10:37:57 <rwbarton> or better example I guess, scanf(" %s", buf)
10:38:07 <Philonous> parcs`:  Ah, setSockOpt :: Serialize a => SockOpt a -> a -> IO ()
10:38:13 <typoclass> rwbarton: that's a cheap "ltrim"?
10:38:15 <rwbarton> oh even %s skips over whitespace apparently
10:38:27 <parcs`> Philonous: doesn't even have to have the Serialize a constraint
10:38:32 <Cale> rwbarton: lol
10:39:03 <geekosaur> yeh, you need to use %c or %[] to match whitespace explicitly
10:39:15 <rwbarton> okay, really better example. scanf("%s ", buf); then use getchar()
10:39:43 <rwbarton> that trailing " " will eat any whitespace after your string so that getchar() sees the next non-whitespace character
10:39:54 <Philonous> parcs`:  How so?
10:40:21 <Cale> s      Matches a sequence of non-white-space characters; the next pointer must be a pointer to character array that is long enough to hold the input sequence and the terminating null character ('\0'), which is added automatically.  The input string stops at white space or at the maximum field width, whichever occurs first.
10:40:58 <rwbarton> so in conclusion, all of the whitespace in that format string is unnecessary
10:41:15 <ski> Philonous : in each particular case, `a' will actually be one of `Bool',`Int',&c., which are presumably already known to be in the class `Serializable'
10:41:18 <rwbarton> can just be scanf("%d%d%d", &a, &b, &c)
10:41:25 <ski> s/able//
10:41:30 <parcs`> Philonous: because it's a GADT. when you pattern match on a particular constructor then the type of the 2nd argument to setSockOpt is statically known and so are its instances
10:41:51 <ski> .. we need a Haskell version of `scanf'
10:41:52 <Philonous> parcs`:  Ah, right, of course pattern matching will fix the type
10:42:02 <rwbarton> ski, yeah it would be nice
10:42:09 <Cale> ski: *This* is what you're taking away from this discussion? :)
10:42:16 <typoclass> rwbarton: putting a space in between them will be more readable, though. but yeah, the \n and \t should be taken out
10:42:19 <geekosaur> scanf?!  getitoffgetitoffgetitoffame!
10:42:40 <ski> Cale : how would we otherwise compete with the brittleness of C ?
10:42:46 <Cale> haha
10:43:31 <Cale> Yeah, we definitely need one with a %s that can buffer overflow, because buffer overflow exploits are totally cool.
10:43:49 <Philonous> parcs`:  Should for for getSockOpt :: Socket -> SockOpt a -> IO a just as well, shouldn't it?
10:44:05 <Philonous> work*
10:44:06 <rwbarton> seriously though it shouldn't be a challenge to write the equivalent of scanf("%d",&a); in haskell
10:44:56 <ski> a CPSed version might be nicer
10:44:58 <c_wraith> :t readLine
10:44:59 <lambdabot> Not in scope: `readLine'
10:45:04 <parcs`> Philonous: that should work
10:45:11 <applicative> @type readLn
10:45:12 <lambdabot> forall a. (Read a) => IO a
10:45:24 <mauke> rwbarton: yes, it should
10:45:29 <rwbarton> lol
10:45:36 <ski>   withScanf "%d%d%d" $ \a b c -> ...
10:45:38 <mauke> scanf("%d", &a); is not a sensible thing to do
10:45:39 <kirindave> Finally wrote a Conduit that is faster than that Python script for capitalization
10:45:51 <kirindave> And then I realize Reddit already has a version using Lazy I/O that does it just as well.
10:46:08 <c_wraith> oh
10:46:09 <rwbarton> applicative: readLn is not the same, it is line based, scanf can read part of a line
10:46:11 <c_wraith> :t readLn
10:46:12 <lambdabot> forall a. (Read a) => IO a
10:46:14 <otters> THAT's what cps style is?
10:46:19 <applicative> rwbarton: ah
10:46:28 <studybo__> :t getLine
10:46:29 <lambdabot> IO String
10:47:35 <applicative> with a readLine supply a scanf incantation
10:47:38 <applicative> ?
10:48:01 <mauke> I'm not even sure you can implement scanf in Haskell
10:48:06 <mauke> do we have ungetc()?
10:48:51 <applicative> mauke has oleg done it? http://okmij.org/ftp/typed-formatting/index.html
10:49:18 <mauke> no
10:49:23 <mauke> scanf isn't typesafe
10:49:31 <rwbarton> I'm not even talking about the formatting stuff really
10:49:40 <rwbarton> I just want to be able to accept an input which is a bunch of numbers on a single line
10:49:43 <rwbarton> and read them in individually
10:49:45 <copumpkin> let's write scanf in Agda
10:49:58 <copumpkin> also, I want the haskell printf to support the %n specifier so I can get format string vulns
10:50:06 <copumpkin> (so it can't just use IORefs or any of that crap)
10:50:10 <mauke> "The same descriptor can be used both for printing and for parsing."  <- complete failure
10:50:32 <ski> otters : sortof
10:50:39 <mauke> scanf's and printf's format specifiers aren't even close in C
10:50:40 <typoclass> i don't get it, why do we need scanf? we have parsec and all that, don't we? and even just 'words', 'lines', and 'read' are quite adequate for quite a lot
10:50:53 <beaky> right
10:51:07 <beaky> C's scanf and printf are unsafe :D
10:51:14 <Philonous> typoclass:  Yeah, but we don't have scanf
10:51:25 <typoclass> Philonous: oh good point. carry on then
10:51:54 <ski> typoclass : we need it for unsafeness, and for code which is harder to maintain
10:52:13 <mauke> (trivial example: printf %f takes a double, scanf %f takes a pointer to float)
10:52:30 <lispy> kirindave: lazy IO or lazy text?
10:52:34 <SLi> printf is unsafe too, just there happens to be a way to get Haskell to accept that unsafeness.
10:52:47 <lispy> kirindave: When I saw that my first thought was "strict text is all wrong" and didn't bother to read the comments
10:53:06 <joevar> Is the purpose of ($) to control the fix point for binary functions?
10:53:14 <kirindave> lispy: Strict text is not wrong at all
10:53:21 <mauke> joevar: what?
10:53:27 <typoclass> joevar: it's mostly used just to save some parens
10:53:41 <kirindave> lispy: What's _wrong_ is trying to use naive functional rebuilding of big data structures.
10:53:46 <typoclass> > map succ (reverse "cat")
10:53:47 <lambdabot>   "ubd"
10:53:54 <typoclass> > map succ $ reverse "cat" -- joevar
10:53:55 <lambdabot>   "ubd"
10:53:58 <kirindave> lispy: The C code is fast because the C code has buffering baked into its libraries for this operation, which python then leverages.
10:54:09 <SLi> But somehow printing and reading in Haskell seems moderately less clunky to me than the C++ way (which, even having used C++ extensively, seems a horrible backstep from printf, except that it happens to be more type-safe).
10:54:10 * ski prefers the non-`$'-version there
10:54:11 <kirindave> lispy: But if you throw an 8gb file at the python, it will die.
10:54:36 <rwbarton> mauke: there is hLookAhead
10:54:40 <mauke> SLi: depends on how you do it
10:54:40 <rwbarton> that's good enough, right?
10:54:41 <mauke> rwbarton: ah
10:55:09 <mauke> SLi: cin >> foo is about equivalent to scanf, except less flexible/readable/blargh
10:55:47 <SLi> mauke, yes. I do that when writing C++, but always want to go back to scanf :)
10:55:56 <mauke> why do you do that in C++?
10:55:57 <joevar> typoclass, I'm trying to understand the Applicative's interchange law. The ($) looks like it's used to change order of the fix point.
10:56:07 <mauke> it's frickin' crazy
10:56:07 <Lutin`> joevar: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-36- Says it pretty well
10:56:09 <kirindave> lispy: Haskell is actually way ahead here in many ways, in that we've all realized that streaming is where I/O is at for nearly all cases where performance is interesting.
10:56:10 <parcs`> > case Just () of !(Just ()) -> ()
10:56:11 <lambdabot>   ()
10:56:25 <copumpkin> parcs`: that ! won't do anything
10:56:26 <mauke> char foo[20]; cin >> foo; is just as bad as scanf("%s", foo); buffer overflows and all
10:56:46 <typoclass> joevar: i don't know about applicative and its laws in partciular, but not that $ is not the same as <$> . they're two different functions
10:56:54 <typoclass> s/not/note
10:57:01 <kirindave> lispy: Because our entire goal is to get everything about I/O to fit in cache on one CPU. Then we'll be solely limited by the number of copies we do, and then approaches like Apache Kafka's or LMAX Disruptor's let us get to absurd throughput if needed.
10:57:05 <SLi> mauke, well, for one thing, you may want to read one part of the input into a std::string, which isn't possible with <cstdio>s scanf.
10:57:13 <parcs`> > case Just () of !(Just) () -> ()
10:57:14 <lambdabot>   <no location info>: parse error on input `('
10:57:37 <SLi> Then you will have to have a temporary char array, and you will have to worry about its bounds, and so on.
10:57:40 <mauke> SLi: yes, but in that case I'd use std::getline
10:57:51 <SLi> Only if you want to get the entire line. :)
10:57:56 <mauke> I do
10:58:15 <ski> joevar : i think there's no fix point in there
10:58:20 <Lutin`> joevar: Ah you mean in `u <*> pure y = pure ($ y) <*> u`
10:58:26 <SLi> Or of course it's the sane way in C too to get the entire line and then use sscanf in most cases.
10:58:33 <joevar> Lutin', yes.
10:58:42 <ski> > map ($ a) [f,g,h] :: [Expr]
10:58:43 <lambdabot>   [f a,g a,h a]
10:58:59 <parcs`> > let a | error "foo" = error "bar" where !b = error "baz" in a
10:59:00 <lambdabot>   *Exception: baz
10:59:02 <rwbarton> SLi, depends on whether there are a fixed number of fields in the line
10:59:10 <ski> joevar : `($ y)' is just another way of writing `(\f -> f y)'
10:59:12 <Philonous> joevar:  ($ y) is the same as (\f -> f y)
10:59:32 * ski grins at Philonous
10:59:33 <parcs`> > let a | error "foo" = error "bar"; !b = error "baz" in a
10:59:34 <lambdabot>   *Exception: baz
10:59:36 <SLi> But if you want to do something like sscanf(str, "%n %s %s %n", ...), you either need to use cin >> ... or sscanf with temporary char arrays.
10:59:37 <kirindave> lispy: https://gist.github.com/663d603cf77d38d642f3
10:59:48 <kirindave> Even though conduits code tends to be ugly,
10:59:54 <parcs`> > let !a | error "foo" = error "bar"; !b = error "baz" in a
10:59:55 <lambdabot>   *Exception: baz
10:59:59 <kirindave> I think the python and haskell versions are equally awkward.
11:00:06 <SLi> Though I suspect Boost would have more niceties for this case too than I've cared to research, like a way to split on spaces. :)
11:00:11 <CmrPantoufle> What is "!a" ?
11:00:39 <CmrPantoufle> I mean, what does the ! stand for?
11:00:57 <Lutin`> kirindave: In that I like the python version better
11:01:11 <kirindave> Lutin`: Yeah well I am not a Conduits pro.
11:01:19 <Lutin`> Me neither
11:01:21 <Lutin`> Never used em
11:01:22 <kirindave> Lutin`: That is my first custom conduit in like 2 years.
11:01:33 <SLi> rwbarton, well, if you know that there is a fixed number of fields in a line, and that your scanf format string always gets them all correctly. But that usually just leads to madness. If you know it
11:01:34 <kirindave> Last time I wrote one was way earlier in the library
11:01:36 <ski> CmrPantoufle : strict pattern
11:01:50 <kirindave> Lutin`: Pipes/Frames are much prettier, but  they don't come with so many batteries
11:01:51 <rwbarton> oh, I see
11:01:56 <rwbarton> sure
11:02:01 <SLi> rwbarton, 's line based, it's better IMO to read a line at a time and then to check that you converted the correct number of things.
11:02:12 <parcs`> CmrPantoufle: it means to force 'a' when evaluating the expression that 'a' is defined in.
11:02:31 <kirindave> Lutin`: Also, the python version has _stupid_ bugs.
11:02:31 <CmrPantoufle> Ok
11:02:44 <rwbarton> my scanf() usage is in programming contests or other situations where you can be assured the input is correctly formatted
11:02:49 <SLi> I don't yet quite understand why (fairly simmple) reading and printing feels less clunky in Haskell than in C++.
11:03:02 <kirindave> Lutin`: It was only supposed to capitalize the input wordwise. It instead also crunches whitespace, which is dumb.
11:03:08 <ski> CmrPantoufle : actually, it means, when matching a value with the pattern `a', to force the value at that point
11:03:21 <typoclass> joevar: if the ($ y) thing confuses you as much as it confused me: it's like (++ y). it's a "section" with the first argument left out, i.e. the same as (\x -> ($) x y), i.e. (\x -> x $ y), i.e. simply (\x -> x y). so x has to be a function that takes a y
11:03:22 <Lutin`> kirindave: What's the issue with (lines . upper . unlines)?
11:03:27 <CmrPantoufle> I got it, thank you :)
11:03:31 <kirindave> Lutin`: It's insanely slow?
11:03:48 <Lutin`> Even with bytestring?
11:03:50 <kirindave> Yes.
11:03:55 <kirindave> Actually bytestring makes it worse.
11:03:59 <Lutin`> Damn
11:04:01 <kirindave> Without builder
11:04:02 <kirindave> Yeah well
11:04:14 <kirindave> You _can_ make listwise IO fast with scanl.
11:04:15 <parcs`> > let foo !a b = () in foo undefined `seq` ()
11:04:16 <lambdabot>   ()
11:04:19 <Philonous> joevar:  Also, f $ x = f x
11:04:22 <ski> CmrPantoufle : iow, the pattern `!(Foo x y)' is the same as `Foo x y', since the corresponding value being matched would be forced anyway in this case
11:04:27 <kirindave> but the naive implementation is not.
11:04:28 <astor> I am trying to understand how to get Typeable derived in this example: newtype P m a = MkP (ReaderT Int m a) deriving (Typeable).  I can't find comprehensible examples, although I find this old post from SPJ indicating that this case should be handled by GHC. http://www.haskell.org/pipermail/glasgow-haskell-users/2011-July/020574.html
11:04:38 <kirindave> Lutin`: You should read the reddit thread. It is illustrative.
11:04:47 <Lutin`> kirindave: Is it on the front page?
11:04:51 <kirindave> Of haskell, yes.
11:04:53 <Lutin`> k
11:04:55 <kirindave> Should still be entry #1
11:05:08 <Lutin`> Well if it's on the front of haskell it's on my frontpage :P
11:05:08 <kirindave> Someone quitting haskel becuase it's "bad at string processing"
11:05:14 <rwbarton> astor, I think you want "deriving (Typeable2)" because P is a two-argument constructor
11:05:23 <Lutin`> He should use perl
11:05:28 <kirindave> He uses python.
11:05:29 <Lutin`> I hear they're good at string processing :P
11:05:31 <rwbarton> astor, not 100% sure though
11:05:38 <kirindave> But basically Haskell's entire I/O library needs to be reconsidered. :\
11:05:48 <parcs`> Lutin`: my perl implementation is 2x slower than teh python one :(
11:05:57 <Lutin`> sad faec
11:05:59 <kirindave> There is basically no credible argument against iteratees that cannot be addressed by API refinement.
11:06:02 <SLi> Though formatted printing in Haskell is (at least the way I do it) cluttered by needing to have "show" everywhere. Hmm. Perhaps I should learn template haskell and figure out if there's a way to make a print function that automatically uses show for the non-string elements.
11:06:17 <SLi> Learning TH might be a good idea anyway :)
11:06:22 <Lutin`> kirindave: A lot of Haskell needs a little spring cleaning
11:06:26 <SLi> And apparently not too difficult?
11:06:32 <kirindave> Lutin`: Monad zippers instead of transformers?
11:06:46 <kirindave> I dunno if we're all supposed to start writing indexed monads now too.
11:06:49 <kirindave> Pipesbro seems to think so.
11:07:02 <mauke> parcs`: do you have a benchmark?
11:07:29 <monochrom> SLi: there is Text.Printf (comes with GHC), it should help. it's also a bit magical, but not needing TH yet :)
11:07:31 <kirindave> Anyways the reason mine is fast despite the B.unpack is because with -O2 the foldMap and scanl seem to get fused.
11:07:32 <astor> rwbarton: doesn't seem to work, it expects an argument of kind *->*->*, while Typeable only wants to see *.
11:07:41 <kirindave> I _think_ that's what the Core is saying.
11:07:46 <mauke> SLi: Text.Printf.Mauke has a TH version
11:08:06 <rwbarton> astor: I guess I should have started with: what is the error message
11:08:19 <joevar> So, the purpose of the Interchange law to confirm that functions inside functors will still output the same thing if the functions are given the same input. Correct?
11:08:27 <rwbarton> astor: oh, I see
11:08:47 <SLi> monochrom, hmm, yes, I've actually used that, now that I think. I guess I have the same reason why I don't use it than why I don't use printf often in C++: Things start simple enough to not need it, and then I'm too lazy to convert when they get cluttered :-)
11:08:58 <joevar> And the ($) was used for brevity to show this.
11:09:00 <parcs`> mauke: yeah it's a 24MB lorem ipsum document, compressed to 20KB
11:09:17 <mauke> parcs`: is this online somewhere?
11:09:23 <parcs`> i can dcc it to you
11:09:28 <mauke> SLi: use printf early, and use it often :-)
11:09:32 <kirindave> Man the Python program over 1GB input takes 4gb. :\
11:09:57 <mauke> parcs`: ok
11:09:59 <nahiluhmot> assuming i have the data definition `newtype Mu f = In { out :: f (Mu f) }` and the function `cata phi = phi . fmap (cata phi) . out`, with the type signature `cata :: Functor f => (f a -> a) -> Mu f -> a`, how would I write a function called cata2 with the type signature `cata2 :: (f a -> f a -> a) -> Mu f -> a` that applies a binary function to every value?
11:10:07 <kirindave> Anyways, COFFIN NAILED CLOSED.
11:10:09 <astor> rwbarton: Can't make a derived instance of `Typeable (P m a)': `P' must only have arguments of kind `*'.  So because m is * -> *.
11:10:14 <kirindave> Cannot devote more cycles to this stupid problem.
11:10:31 <kirindave> This may be an argument against taking pramiracetam. Problems like this REALLY bother me when on it.
11:10:43 <rwbarton> astor, yeah I see the problem now
11:11:05 <mauke> parcs`: and the code?
11:11:11 <rwbarton> astor, I don't know what to do about it, sorry. I think a future GHC will have a unified Typeable class for all kinds
11:11:42 <SLi> mauke, but I think it's fair to argue that it's not entirely type safe, and thus slightly un-haskellic? :P Or is everything haskellic that can be implemented in Haskell so that you actually only get type errors at runtime?
11:12:05 <astor> rwbarton: Do you know how I can write an explicit instance? I can't find a comprehensible article.
11:12:17 <rwbarton> no, sorry
11:12:27 <mauke> SLi: the TH version is type safe
11:12:33 <astor> rwbarton: ok. thanks anyways.
11:12:51 <mauke> but I normally don't care because I very rarely make type errors in printf
11:12:52 <SLi> mauke, ah, that makes sense.
11:13:07 <parcs`> er, i could've just hpasted the code
11:13:12 <mauke> parcs`: thanks
11:13:54 <hpaste> nooodl pasted “randWord” at http://hpaste.org/76766
11:14:03 <rwbarton> astor: here is a relevant-looking example though: http://www.haskell.org/pipermail/haskell-cafe/2011-February/088837.html
11:14:41 <nooodl> ^ there's some code up there i wrote for generating random words, but it generates results like this: ["bld","ldjs","djsy","jsyqin","syqinb",...
11:15:25 <nooodl> how do i fix my code to not get such an overlap? i somehow need to return an entirely different generator than gen'
11:15:30 <astor> rwbarton: thanks, looks relevant.
11:16:13 <joevar> typoclass, Lutin', ski, and Philonous thanks. I understand the law now.  The ($) had little to do with it.
11:16:34 <typoclass> joevar: you're welcome
11:16:34 <mauke> baseline: python: 3.5s, perl: 4.4s
11:17:58 <herpladee> should i use apt-get to install cabal?
11:18:09 <herpladee> or do i need to use apt-get to get cabal-install and then use that to ... well i don't know
11:18:13 <herpladee> it's a little confusing :P
11:18:14 <b__> how can I show a Float/Double with all decimal places shown (instead of, for long numbers i.e. 3.200001e9)?
11:18:35 <Lutin`> herpladee: Once you get cabal-install it can update itself
11:18:43 <Lutin`> Using `cabal install cabal-install`
11:18:52 <parcs`> mauke: i have python2: 1.5s and perl5.14: 3.5s. are you using python 3?
11:18:59 <herpladee> i am getting errors when i do cabal install cabal-install though
11:19:10 <herpladee> and i think this is weird because i just install cabal with apt-get
11:19:26 <Lutin`> Ubuntu I assume?
11:19:29 <monochrom> exact error message?
11:19:38 <typoclass> herpladee: do you have the haskell platform? i thought it's recommended to just get the platform, unless you have reason not to
11:19:51 <herpladee> the platform?
11:19:53 <herpladee> yes ubuntu
11:20:17 <typoclass> herpladee: no, the "haskell platform" is a package that includes the basic haskell stuff to get you started
11:20:18 <clahey> beaky: Here's my C++ version of your turing machine:
11:20:19 <clahey> http://ideone.com/Fz66v1
11:20:26 <aluink> the docs for UTCTime on hackage list a Show instance, yet when I pull that module up in ghci, it has none.  I looked through the code some and don't see any.  Is there one? If so, where is it?
11:20:30 <mauke> parcs`: 2.6.6
11:20:31 <rwbarton> nooodl: either use 'split' or don't use 'randomRs'
11:20:35 <mauke> parcs`: perl is 5.16.1
11:20:42 <aluink> Data.Time.Clock
11:20:52 <conal> i'd like some advice on building ghc from source. i have 7.4.1 installed from haskell package, and i just built 7.6.1 from sources. 7.4.1 is in /usr/bin, while 7.6.1 got put into /usr/local/bin. i used "sudo uninstall-hs thru 7.4.1 --remove" to remove old versions, but then i found myself without cabal. i've reinstalled 7.4.1, but i don't know what's the smoothest path to get fully onto 7.6.1.
11:20:53 <mauke> parcs`: also, your perl code doubles newlines and your python code destroys formatting
11:20:58 <clahey> beaky: I did have to do a bunch of stuff to make it work, I'll admit.
11:21:00 <herpladee> so what do i do?
11:21:08 <typoclass> aluink: i think the trick is to import Data.Time, it will pull in all the stuff commonly used, including (i think) the Show instance in question
11:21:09 <jeff_s1> aluink: what version of the time package do you have installed?
11:21:13 <clahey> beaky: But I'm curious if it's faster or slower than your haskell version.
11:21:33 <aluink> typoclass: i'll try that
11:21:38 <nooodl> rwbarton: so just (fst . split) gen' or something?
11:21:51 <conal> i'm upgrading ghc on my mac, but i'll next do the same on my redhat linux work machine.
11:21:56 <aluink> jeff_s1: i just killed my ~/.ghc recently. so i'll assume the latest...checking
11:22:02 <Lutin`> clahey: I can link you his haskell version if you want to test yoursel
11:22:23 <herpladee> hey if i just want to make some small programs in haskell on ubuntu is there some package i can install using apt-get?
11:22:25 <Lutin`> clahey: http://ideone.com/KCU4o2
11:22:26 <parcs`> mauke: oops
11:22:27 <jeff_s1> aluink - you can do ghc-pkg list time
11:22:39 <rwbarton> nooodl: no no
11:22:41 <aluink> jeff_s1: 1.4. Though, my research was done all online
11:22:53 <rwbarton> use both sides of the split, otherwise it is pointless
11:23:04 <mcstar> whats the current lets-make-this-haskell-program-as-fast-as-c task?
11:23:07 <aluink> jeff_s1: so my question doesn't depend on my installation
11:23:22 <jeff_s1> oh ok, never mind
11:23:28 <Lutin`> mcstar: http://honza.ca/2012/10/haskell-strings
11:23:35 <beaky> clahey: i'll try it out on my machine :D
11:23:39 <mcstar> oh, from yesterday
11:23:45 <aluink> typoclass: that did it. thx
11:23:52 <typoclass> aluink: you're welcome
11:24:09 <Lutin`> mcstar: I just got in here and that's what they were doing
11:24:26 <mcstar> Lutin`: weird folks, arent they?
11:24:27 <beaky> clahey: it's about as fast as your Haskell version
11:24:42 <rwbarton> nooodl: for example don't have randWord return a "new" generator. use split in randWords to pass independent generators to randWord and to the recursive call
11:24:43 <Lutin`> mcstar: Yes we are.
11:25:04 <rwbarton> nooodl: or alternatively use split in randWord to return a generator which is independent from the one you passed to randomRs
11:25:22 <clahey> beaky: Unless I forget to turn on optimizations.  :)
11:26:15 <clahey> beaky: In which case the haskell one has a stack overflow.
11:26:28 <mcstar> i wonder why didnt my challenge of making my sudoku solver caught on
11:26:32 <herpladee> why does the haskell platform tell me that i need ghc to install and ghc tells me that i should just install haskell platform because it includes ghc
11:26:35 <herpladee> i'm confused
11:27:00 <mcstar> maybe it is a tad more complex than capitalizing some characters
11:27:09 <beaky> why would the stack blow out in the  Haskell version? :(
11:27:21 <jeff_s1> @hoogle :: Centi -> Milli
11:27:22 <lambdabot> Data.Generics.Aliases ext0 :: (Typeable a, Typeable b) => c a -> c b -> c a
11:27:22 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
11:27:22 <lambdabot> Data.Generics.Aliases mkR :: (MonadPlus m, Typeable a, Typeable b) => m b -> m a
11:27:22 <clahey> mcstar: Is there a sudoku challenge?
11:27:28 <Lutin`> mcstar: It's cause your problem didn't insult the perfectness of Haskell
11:27:30 <nooodl> rwbarton: it's working great now, thanks
11:27:32 <mcstar> making it faster*
11:27:50 <rwbarton> herpladee: you are on ubuntu? this is what I recommend. (1) apt-get install ghc cabal-install (2) use cabal-install to install all Haskell libraries (always locally, never with --global), don't apt-get install anything else
11:28:06 <ezyang> Do people still like cmdargs?
11:28:17 <rwbarton> (1') apt-get install haskell-platform should be okay too
11:29:20 <mcstar> clahey: http://attractivechaos.wordpress.com/2011/06/19/an-incomplete-review-of-sudoku-solver-implementations/ compete with these implementations
11:29:35 <beaky> the C version is twice as fast as the C++ version though :D
11:29:45 <beaky> C is the king of all programming languages
11:30:04 <clahey> beaky: Twice as fast as my C++ version?  Hmm.
11:30:07 <mcstar> lets change that to gnik
11:30:16 <mcstar> C is the gnik of all programming languages
11:30:24 <mauke> king sadim
11:30:32 <herpladee> rwbarton, how do i install a package using cabal?
11:30:43 <rwbarton> cabal install foo
11:30:55 <mcstar> @hoogle foo
11:30:56 <lambdabot> package foo
11:30:56 <lambdabot> Text.XHtml.Strict tfoot :: Html -> Html
11:30:56 <lambdabot> Text.XHtml.Frameset tfoot :: Html -> Html
11:31:03 <rwbarton> hey it even exists :)
11:31:03 <mcstar> heh
11:31:14 <parcs`> conal: can't you locally install the latest version of cabal via 'cabal install cabal-install' and then remove ghc 7.4.2?
11:32:18 <ocharles> hey, we're trying to deploy a haskell app that was developed on Ubuntu 12.04 to Ubuntu 10.04, but that fails because libgmp.so.10 doesn't exist (10.04 has .so.3). what's the best way to correct this?
11:32:23 <ocharles> -optl-static fails miserably
11:32:35 <parcs`> conal: afterwards you can locally reinstall cabal against ghc 7.6 if you'd like
11:32:38 <typoclass> beaky: not sure if you're being serious, but if c is the "king" because it's fast, then we should all be using assembler for everything. or even better we should abolish software and make custom hardware for everything
11:32:45 <beaky> right
11:33:13 <Lutin`> fuck microprocessors
11:33:15 <parcs`> i heard fpgas are really fast
11:33:22 <pckt> They are
11:33:26 <Lutin`> Do everything logic gate by logic gate
11:33:30 <geekosaur> wire-wrapped custom logic :)
11:33:37 <beaky> I think that we should use the right tool for the write job and use what language is most appropriate for the task at hand rather than what's fastest :D
11:33:48 <herpladee> rwbarton, okay i did apt-get install ghc cabal-install and then cabal-install told me to do cabal install cabal-install and that gives me errors
11:33:59 <Lutin`> herpladee: WHAT ERRORS
11:33:59 <rwbarton> you don't have to do what cabal-install tells you to do
11:34:03 <rwbarton> however, what are the errors
11:34:12 <Lutin`> Sorry caps
11:34:18 <hpaste> herpladee pasted “errors” at http://hpaste.org/76767
11:34:20 <beaky> but would be cool if one day we all have "hardware compilers" that takes our source code and outputs a custom circuit that performs the task we want
11:34:20 <rwbarton> I think the caps are appropriate :)
11:34:28 <Lutin`> Fair enough :P
11:34:37 <rwbarton> herpladee: paste all the output
11:34:44 <Lutin`> beaky: Yeah that already exists kind of
11:34:45 <herpladee> _all_ ?
11:34:47 <herpladee> there's like a ton of output
11:34:48 <rwbarton> sure
11:34:52 <rwbarton> that's fine
11:35:09 <rwbarton> if you run it again there will be less output but the same error, most likely
11:35:10 <geekosaur> you pasted the part that said that something previous failed.  notably, it omits the details of what failed and how
11:35:12 <hpaste> herpladee pasted “all of it” at http://hpaste.org/76768
11:35:17 <herpladee> there we go
11:35:22 <clahey> rwbarton: Are you attractivechaos then?
11:35:24 <SLi> typoclass, I'm not sure you can say "assembler is faster than C". Very few people nowadays can write assembler that is faster than the code produced from mediocre C code by a good compiler.
11:35:30 <mcstar> beaky: i think you are chasing an imagined tail
11:35:48 <rwbarton> clahey: no
11:35:56 <rwbarton> dunno what that is
11:36:29 <rwbarton> "Installing library in /home/simon/.cabal/lib/deepseq-1.3.0.1/ghc-6.12.1" what is this
11:36:40 <herpladee> i hope you're not asking me :)
11:36:44 <clahey> rwbarton: I'm sorry.
11:36:47 <herpladee> i just did cabal install cabal-install
11:36:48 <rwbarton> herpladee: ghc --version
11:36:51 <clahey> mcstar: You're attractivechaos then?
11:36:56 <herpladee> 6.12.1
11:36:58 <geekosaur> that;s a pretty ancient ghc version, yeh
11:36:59 <rwbarton> oh dear
11:36:59 <mcstar> clahey: no
11:37:02 <mcstar> dunno what that is
11:37:07 <herpladee> i just did apt-get install ghc :(
11:37:12 <rwbarton> I sort of assumed you were using a recent ubuntu
11:37:17 <herpladee> 10.04 server
11:37:19 <rwbarton> okay hmm
11:37:19 <typoclass> herpladee: no worries :) it's not your fault
11:37:27 <mcstar> clahey: its a blog a friend of mine found when we were solving sudokus
11:37:38 <rwbarton> it's now past 12.04, #haskell no longer provides support for 10.04 :P
11:37:39 <mcstar> well, writring solvers that is
11:37:54 <rwbarton> um so
11:37:58 <herpladee> so i'm screwed?
11:38:02 <rwbarton> no
11:38:13 <typoclass> rwbarton: the long-term versions from ubuntu have a life of at least 3 years
11:38:16 <mcstar> its 12:08 btw
11:38:27 <rwbarton> well, maybe
11:38:31 <typoclass> herpladee: it just means that rwbarton doesn't want to help you :-/
11:38:32 <herpladee> 10.04 is LTS and it's supported until april 2013 by canonical :)
11:38:51 <rwbarton> oh i see they overlap
11:39:08 <herpladee> anyway i don't think i'm allowed to update ubuntu
11:39:36 <clahey> herpladee: I refuse to.  I like gnome 2 too much.
11:39:43 <typoclass> SLi: alright, "we should all be using assembler" -> "we should all be using assembler after becoming experts on writing performant assembler"
11:39:46 <Cale> herpladee: I usually don't rely on Ubuntu's haskell-related stuff, and just grab the generic linux binary from the GHC website.
11:39:58 <Cale> clahey: We're in the same boat
11:40:05 <herpladee> yea i like gnome over unity too
11:40:08 <beaky> I like xmonad
11:40:17 <rwbarton> herpladee: download the relevant linux binary from http://www.haskell.org/ghc/download_ghc_7_4_1
11:40:21 <Cale> clahey: Though I don't know whether it's that I like Gnome 2, or just *hate* Gnome 3 and Unity.
11:40:24 <mcstar> lol, i had to use osx today
11:40:29 <rwbarton> herpladee: then download the source from http://www.haskell.org/platform/linux.html
11:40:34 <Palmik> Hmm, what is the term for function that is less generic: for example `id' is as generic as it gets, whereas I would call foo :: Int -> Int 'most specialized', but surely there is a proper term. For example the type of of foo is probably subtype of 'id', but is there a better term to describe it?
11:40:40 <mcstar> i couldnt move windows, maximize them, or even scroll them
11:40:46 <mcstar> i was helpless
11:40:54 <mcstar> it was like being in a cage
11:40:55 <beaky> osx is alright, but is weird that you cant maximize or tile windows
11:40:57 <mauke> Palmik: instance
11:41:00 <typoclass> Palmik: monomorphic? not sure
11:41:05 <mcstar> my collegue had to bring a regular mouse for me
11:41:11 <Palmik> I would like to say something along the lines "GADT induced type refinement allows us to use more specialized functions"
11:41:22 <herpladee> rwbarton, but the haskell-platform tells me that i need ghc to install, and the ghc page tells me that i should just install the platform, what should i do?
11:41:32 <rwbarton> do what i said lol :P
11:41:36 <rwbarton> i already told you
11:41:55 <rwbarton> you could install the haskell platform directly, if the version included in your distro wasn't ancient
11:42:00 <mcstar> beaky: i used 10.5 for at least a year, i was still screwed with the 'advances' that came since
11:42:44 <rwbarton> I don't know why there isn't a generic binary linux haskell platform download though
11:42:56 <mcstar> how stupid is to change the scrolling direction of the contents of windows???
11:43:13 <herpladee> alright i hope i can make it work :) thanks for your help
11:43:19 <typoclass> mcstar: it's magic and revolutionary. it's all very intuitive
11:43:29 <S11001001> Palmik: how about "monomorphic"
11:43:35 <mcstar> thats why ill stick to linux, thank you
11:43:51 <rwbarton> herpladee: personally I like to install the ghc binary download with --prefix=$HOME so that it ends up in ~/bin and ~/lib and so on
11:43:56 <S11001001> I'm just going to repeat what typoclass says for the rest of the day
11:43:56 <beaky> I like windows 8
11:44:10 <mcstar> i just hate the feeling of being locked in
11:44:30 <rwbarton> I think Palmik is asking the question "Int -> Int is a _______ of a -> a"
11:44:40 <rwbarton> is that right?
11:44:44 * typoclass is just going to repeat what S11001001 says for the rest of the day :-D
11:45:09 <nicoo> typoclass: Quine !
11:45:28 <Palmik> rwbarton, indeed.
11:45:46 <mcstar> why not instance?
11:45:59 <rwbarton> I am not an expert on type system terminology but I would have guessed "specialization"
11:46:06 <mcstar> you fill in Int for a, you instantiate the type variables
11:46:09 <rwbarton> or perhaps "instantiation"
11:46:15 <tac-tics> specialization or instantiation both sound right to me
11:46:49 <rwbarton> maybe "instance" too but in the context of Haskell that could be confusing
11:46:52 <herpladee> rwbarton, why not just /bin and /lib ?
11:47:33 <rwbarton> doesn't require root privileges, easier to clean up, won't interfere with a system ghc etc.
11:47:39 <clahey> Cale: I prefer Gnome 3 over Unity.
11:47:57 <rwbarton> you can even use --prefix=$HOME/ghc
11:47:58 <clahey> Cale: If I could set the number of desktops, I might be okay with gnome 3 classic.
11:48:04 <rwbarton> then everything will get installed in one place
11:48:15 <rwbarton> then add $HOME/ghc/bin to your path
11:50:32 <Palmik> rwbarton, mcstar, tac-tics I will use "specialization" then, thanks. :)
11:50:47 <herpladee> can i use --prefix=$HOME/.ghc ?
11:50:52 <rwbarton> no
11:50:54 <rwbarton> well maybe
11:51:00 <rwbarton> but ghc is going to store stuff in $HOME/.ghc when it runs
11:51:05 <rwbarton> so it sounds like a bad plan
11:51:14 <typoclass> herpladee: i think ghc needs that particular directory. better use ~/.haskell
11:52:27 <rwbarton> also "rm -rf ~/.ghc" is fairly common advice
11:52:56 <ion> herpladee: How i install my Haskell stuff: https://gist.github.com/2815423
11:53:31 <tac-tics> (interesting fact: in some languages, such as Agda or System F, "specialization" is just passing a type *as* a parameter .... and sometimes implicitly)
11:54:33 <rwbarton> apparently --prefix=$HOME/.ghc is ion-approved
11:58:17 <BrettB> http://v.gd/CEBRVo
11:58:28 <BrettB> [42,13,22]
11:58:57 <mcstar> is that a kind of link i shouldnt click?
12:00:12 <c_wraith> It claims to be a redirect to http://www.haskell.org/ghc/download_ghc_7_6_1
12:00:23 <c_wraith> I'm not sure why you wouldn't just paste that link
12:00:30 <herpladee> ion, why not just install platform instead of cabal?
12:00:36 <mcstar> ah
12:00:40 <mcstar> its in the /topic
12:00:57 <c_wraith> ah, that makes some sense in the topic
12:01:11 <fliip> In lambda for each closed term s, how do you construct a closed term t where t=ts?
12:01:14 <c_wraith> herpladee: I never touch the platform. It's just not flexible enough
12:01:26 <ion> herpladee: Sometimes i want a newer version of GHC.
12:01:30 <beaky> I'm using archlinux and I keep getting errors when trying to install haskell libraries/applications using either the packamge manager or cabal-install :(
12:01:39 <beaky> I can't even get darcs to install
12:01:53 <mcstar> beaky: use pacman only to intsall ghc
12:02:01 <mcstar> everything else, through cabal
12:02:06 <beaky> right
12:02:32 <mcstar> and add turn on the build profiling libs and documentation options in the cabal config file
12:02:35 <mcstar> -add
12:02:57 <typoclass> beaky: that's unfortunate. i use pacman to get ghc, cabal for everything else. it works kinda well so far (darcs is running, for example). paste the output that cabal produces when it fails to build darcs
12:03:02 * mcstar thinks these should be on by default
12:03:22 <BrettB> so is haskell and interpreted language?
12:03:31 <mcstar> surely
12:03:37 <mcstar> when it is, it is
12:03:39 <johnw> BrettB: it is also a compiled language
12:03:41 <mcstar> otherwise, compiled
12:03:43 <hpaste> beaky pasted “cabal-install: failed to install darcs” at http://hpaste.org/76770
12:03:51 <typoclass> BrettB: no, it's usually compiled and only rarely used in interpreted mode
12:04:28 <mcstar> also, it is easy to write code that runs at the speed of interpreted laguages
12:04:34 <mcstar> big bonus
12:05:10 <drrckln> hmm. what's a good resource for learning Haskell as a newbie to programming in general? (not LYAH, really)
12:05:14 <beaky> yeah the startup time of haskell interpreters is too much :(
12:05:25 <romildo> I am surprised with the value of the following expression:
12:05:29 <romildo> reads "10.11-30.45" :: [(Int,String)]
12:05:31 <romildo> []
12:05:43 <typoclass> man those messages in the hpaste are weird ... global instances? "installed-eac..." ?
12:05:54 <romildo> I think it sould be [(10," .11-30.45")]
12:06:05 <romildo> Is this a bug?
12:06:06 <BrettB> does it compile x86 executables?
12:06:06 <mcstar> :t reads
12:06:08 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:06:12 <johnw> BrettB: yes
12:06:20 <johnw> BrettB: even static ones, if you need that
12:06:23 <beaky> BrettB: yes, and those executables are pretty fast :D
12:06:36 <johnw> they are extremely fast, on par with C much of the time
12:06:40 <mcstar> > reads "10.11-30.45" :: [(10," .11-30.45")]
12:06:42 <lambdabot>   <no location info>: parse error on input `"'
12:06:43 <callen> welp. cabal broke again from a fresh install on Mac.
12:06:46 <applicative> drrckln: whats  wrong with LYAH?
12:06:51 <callen> seriously, what in the hell is the deal with cabal?
12:06:54 <jeff_s1> @hoogle :: Char -> Word8
12:06:54 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:06:54 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
12:06:54 <lambdabot> Prelude error :: [Char] -> a
12:06:58 <mcstar> > reads "10.11-30.45" :: [(Int,String)]
12:07:00 <lambdabot>   []
12:07:02 <callen> I've never seen a packaging system be more reliable at breaking than functioning.
12:07:08 <beaky> lol
12:07:08 <applicative> cabal is  awesome
12:07:17 <johnw> callen: which version of cabal are you using?
12:07:24 <johnw> 1.16 has solved nearly all the issues I had with it
12:07:30 <callen> today's fresh hell is: cabal-install version 0.14.0
12:07:35 <johnw> that, plus using cabal-dev for installing tools, and cabal for installing libs
12:07:41 <BrettB> what was haskell written in?
12:07:50 <Cale> BrettB: Haskell
12:07:51 <johnw> BrettB: I'll give you one guess :)
12:07:54 <applicative> what version of ghc do you have, callen?
12:07:58 <typoclass> BrettB: it's mostly written in haskell itself, and a small part is written in c
12:08:06 <callen> applicative: I don't know anymore, I just uninstalled it in a fit of pique
12:08:16 <callen> applicative: this is the third way (homebrew) I've tried to install Haskell on Mac OS X
12:08:18 <drrckln> applicative: nothing, but all the references to imperative languages confused me when I was trying to do that
12:08:26 <tac-tics> cabal is lovely when it works
12:08:28 <typoclass> beaky: could you paste again the output of cabal with "-v3"?
12:08:31 <callen> applicative: the two previous ways were manual source install, and Haskell framework pkg.
12:08:34 <callen> applicative: both broke.
12:08:36 <typoclass> (just amend the previous paste)
12:08:40 <tac-tics> drrckln: are you new to Haskell?
12:08:42 <BrettB> heh
12:08:45 <mcstar> romildo: the . after 10 interferes with 10 being interpreted as an Int
12:08:50 <callen> applicative: the homebrew version installed, but cabal is still about as reliable as an old man's bowels.
12:08:52 <BrettB> haskell is capable of compiling itself?
12:09:06 <applicative> hm, I haven't had a problem but i'm on the older os x
12:09:10 <tac-tics> BrettB: The GHC Haskell compiler is written in Haskell
12:09:11 <drrckln> tac-tics: not at this point! but not very good with it either
12:09:14 <johnw> BrettB: it is turing complete, yes
12:09:17 <romildo> mcstar, yes, I saw that. But it does not make sense, as I want an integer, and a dot cannot be part of an integer.
12:09:17 <callen> applicative: 10.8.2
12:09:32 <tac-tics> drrckln: cool.
12:09:33 <drrckln> tac-tics: trying to lure a friend in, though
12:09:34 <Cale> BrettB: Well, you need GHC to be able to compile GHC, specifically.
12:09:44 <mcstar> romildo: no, it looks like a float, it isnt an integer
12:09:44 <Cale> BrettB: It's written mostly in GHC Haskell
12:09:47 <tac-tics> drrckln: what did you try to lure him with? :)
12:09:56 <Cale> (another Haskell compiler won't quite do now)
12:10:07 <romildo>  > reads "10,11-30.45" :: [(Int,String)]
12:10:08 <mcstar> romildo: if you want proper parsing, do proper parsing
12:10:46 <drrckln> tac-tics: i told him Haskell is the sexiest most mindblowing computer language and if you learn it first everything else will seem easy
12:10:53 <drrckln> tac-tics: well.. i wish i'd said that, ha
12:10:56 <BrettB> on what platforms can you make software in haskell?
12:10:58 <tac-tics> heh
12:11:07 <romildo> mcstar, I want a function that makes sense in the standard library. It should parse an integer properly or it is buggy.
12:11:59 <johnw> BrettB: you can even make iPhone apps with Haskell, so pretty much anywhere you'd like (unless you're working on exotic embedded systems)
12:12:02 <mcstar> Read is kind of the inverse of Show
12:12:11 <applicative> callen: if it's just cabal install nonsense people here can usually figure it out
12:12:19 <mcstar> read . show . read == id
12:12:23 <typoclass> romildo: i can see how it's confusing. "10." fails, "10," works. unfortunately i don't have a good explanation either, sorry
12:12:23 <Cale> BrettB: Well, x86 and x86_64 (Windows, Linux, MacOS X), and there are PowerPC builds of older GHCs. There's also some support for ARM
12:12:39 <hpaste> beaky pasted “cabal-install dump” at http://hpaste.org/76771
12:12:43 <Cale> BrettB: and yeah, there's cross compilation to iPhone if you're willing to go to a bit of trouble
12:12:43 <mcstar> typoclass: it makes sense
12:12:51 <clahey> My guess would be that it's interpreting 10. as a floating point number.
12:12:54 <typoclass> mcstar: how so?
12:12:57 <tac-tics> drrckln: was it effective?
12:12:58 <mcstar> it wasnt supposed to read ints from arbitrary strings...
12:12:59 <Cale> (which is ARM, but also some setup surrounding that)
12:13:03 <BrettB> android?
12:13:16 <applicative> callen: the only real problem I have on OS X is with gui libraries
12:13:18 <typoclass> clahey: it shouldn't, he gave the type annotation ":: Int"
12:13:20 <johnw> i'm trying to cabal install "cab", and I'm getting "Bad interface file" from template-haskell-2.7.0.0
12:13:23 <Cale> BrettB: I think someone got Android working before, I'm not sure what the state of that is presently.
12:13:24 <johnw> even though TH 2.7 installs just fine
12:13:32 <mcstar> 10 is an int, 10x isnt, 10. isnt, 10sdfjsdf isnt, sadfsd10 isnt
12:13:54 <clahey> typoclass: I'm just guessing as to why it does it.
12:14:00 <typoclass> mcstar: yes, but "10," isn't an int either
12:14:08 <clahey> typoclass: I kinda got the idea that read is meant to be used to parse haskell.
12:14:17 <drrckln> tac-tics: not at all. barely got one friend to try Scheme, let alone Haskell
12:14:23 <mcstar> typoclass: Exception: Prelude.read: no parse on "10,"
12:14:30 <drrckln> tac-tics: beyond tryhaskell, anyway
12:14:46 <typoclass> clahey: that's right, but it doesn't figure out the types by itself. it needs you to put in an annotation
12:14:46 <tac-tics> Those were my experiences as well
12:14:48 <mcstar> typoclass: well, that was read, not reads
12:14:53 <typoclass> > reads "10,11-30.45" :: [(Int,String)] -- mcstar, this is the question
12:14:54 <lambdabot>   [(10,",11-30.45")]
12:14:55 <hpaste> johnw pasted “TH install failure” at http://hpaste.org/76772
12:15:05 <typoclass> > reads "10.11-30.45" :: [(Int,String)] -- as opposed to this
12:15:06 <lambdabot>   []
12:15:07 <rwbarton> "10.11" is a single Haskell lexeme, "10,11" is not
12:15:12 <mcstar> typoclass: i know
12:15:40 <mcstar> anyway, "10," can be seen as part of a list of Ints
12:15:43 <typoclass> mcstar: you said «Exception: Prelude.read: no parse on "10,"», so i repeated what i was talking about
12:15:53 <mcstar> typoclass: i said, that was for read, not reads
12:15:55 <typoclass> rwbarton: i see :-/ kind of weird
12:16:04 <BrettB> what kind of libraries does haskell have?
12:16:38 <applicative> many?
12:17:20 <herpladee> okay now i downloaded ghc 7.4.1 and then i downloaded the cabal source tarball and then i ran ./bootstrap.sh ... and now i get more errors
12:17:26 <c_wraith> What kind of libraries exist?  Haskell probabl has them.
12:17:31 <rwbarton> hpaste!
12:17:32 <drrckln> tac-tics: well, it's tough enough to learn haskell yourself..
12:17:43 <typoclass> romildo: so, the answer is apparently what rwbarton said ^^
12:17:58 <hpaste> herpladee pasted “more errors” at http://hpaste.org/76773
12:18:09 <tac-tics> Haskell pedagogy feels somewhat like climbing a vertical wall at times.
12:18:11 <fliip> In lambda calculus for each closed term s, how do you construct a closed term t where t=ts?
12:18:25 <aravart> @pl \x y -> (fst . fst) x == (fst . fst) y
12:18:25 <lambdabot> (. (fst . fst)) . (==) . fst . fst
12:18:41 <tac-tics> drrckln: It's only saving grace is people get passionate about types, and that leads to a lot of well-written (and a lot of poorly written, but well-intending) blog articles
12:18:59 <herpladee> i mean why does it just fail in some random package with some error i have no idea what to do :/
12:19:29 <mcstar> we call horizontal walls, roads
12:19:40 <tromp> that's called omega, fliip
12:19:42 <drrckln> tac-tics: certainly I like static typing as Haskell does it, now. but _using_ the language is extremely tough still
12:19:59 <tromp> e.g. omega = (\x. x x) (\x. x x)
12:20:20 <tac-tics> @kind Fix
12:20:22 <lambdabot> Not in scope: type constructor or class `Fix'
12:20:26 <fliip> Oh ok thanks.
12:20:33 <tromp> it doesn't depend on s
12:20:46 <tromp> maybe you meant t = s t
12:21:01 <fliip> No. It says t = ts
12:21:04 <Cale> tromp: But can you really get  omega f = omega?
12:21:29 <tromp> no, but they're equally undefined:(
12:21:39 <tac-tics> tromp: depends on what equality you're using.
12:21:49 <tac-tics> omega is well defined. it just doesn't normalize.
12:21:52 <Cale> Let's say alpha/beta/eta equivalence
12:22:06 <romildo> mcstar, rwbarton, it does not make sense to me the idea that (reads "10.") fails because it is not a Haskell token. reads is intended to parse a value of the desired type from the beginning of a string, and return a pair containing the parsed value, and the suffix of the string that was not used.
12:22:20 <rwbarton> reads is intended to be used in writing read instances
12:22:28 <rwbarton> and read instances are intended to parse Haskell syntax
12:22:29 <mcstar> ^^
12:23:18 <romildo> rwbarton, is that stated in some documentation?
12:24:22 <romildo> rwbarton, what I understand is that reads should be able to parse a string resulting from show.
12:24:27 <typoclass> romildo: i don't know about the theory behind it, but in my code, i don't usually parse "from the beginning of the string". it's either the whole string or nothing. i find it more predictable, and i find it more clear for the user to reject a string instead of parsing some part of it, silently ignoring the rest ...
12:24:40 <rwbarton> yes and the output of show is intended to be Haskell syntax
12:24:50 <rwbarton> anyways, you probably want a proper parser library
12:25:02 <Cale> y (\this -> (\x -> this)) s = (\this -> (\x -> this)) (y (\this -> (\x -> this))) s = (\x -> (y (\this -> (\x -> this)))) s = y (\this -> (\x -> this))
12:25:15 <mcstar> clearer?
12:25:35 <romildo> I want to parse a string like "10.11-30.45" into a datatype of mine: Pos Int Int Int Int.
12:25:55 <typoclass> romildo: right, read and show are largely (entirely?) symmetrical. but it is necessary that the annotation on read (":: [(Int, ...)]") exactly reflects the type of the value that you "show"ed. read cannot figure out the type by itself
12:26:08 <Cale> fliip: ^^
12:26:11 <romildo> This type is to represent a position in source code: left line and column, and right line and column.
12:26:32 <ion> romildo: Use Parsec.
12:26:46 <herpladee> does anybody know why cabal bootstrap shell script fails at data.text.lazy?
12:26:58 <typoclass> romildo: the cheap way to do that is with something like "takeWhile (/= '.')". the more fancy way is with one of the parsec libraries
12:27:01 <romildo> ion, Parsec is too much for such a simple parsing.
12:27:05 <ion> Why?
12:27:13 <mauke> > (reads :: ReadS Int) ""
12:27:14 <lambdabot>   []
12:27:44 <applicative> hah, now a faster-than-c 'titlecasing' program http://www.reddit.com/r/haskell/comments/120h6i/why_is_this_simple_text_processing_program_so/c6rns0b
12:27:49 <mauke> I think it's a bug in reads
12:28:04 <beaky> if I create my own datatype module, should my module name be "module Data.datatype where" ?
12:28:18 <ski> mauke : why ?
12:28:21 <mcstar> > splitBy (\c -> c == '.' || c == '-') "10.11-30.45"
12:28:23 <lambdabot>   Not in scope: `splitBy'
12:28:32 <mcstar> well, im sure there is a similar function
12:28:33 <romildo> ion, because I do not want to add Parsec to the dependencies of the project. It is not difficult do parse positions without parsec. There are other ways of doing it. I just thought that reads should work in this case.
12:28:41 <typoclass> beaky: you can put it in Data, yes. but module names always start with a capital letter, so it's got to be Data.Something
12:28:45 <herpladee> ion, did you ever get this problem when installing caball?
12:28:56 <romildo> mauke, I also think it is a bug in reads.
12:28:58 <mauke> ski: because reads should parse a prefix of the string where it can
12:29:12 <beaky> http://ideone.com/qEbgCP so this works?
12:29:21 <mauke> > (reads :: ReadS Int) "1%2"
12:29:22 <lambdabot>   [(1,"%2")]
12:29:28 <mauke> > (reads :: ReadS Int) "0.5"
12:29:29 <lambdabot>   []
12:29:32 <rwbarton> it doesn't just parse any old prefix though
12:29:39 <rwbarton> > (reads :: ReadS Int) "12"
12:29:40 <lambdabot>   [(12,"")]
12:29:41 <mauke> yes, and that's the bug
12:29:41 <typoclass> beaky: (also, if you say "module Data.Something where ...", this must be in a file "Data/Something.hs". note the subdirectory)
12:29:44 <b__> > realFracToDecimal 2 12.49499999999999
12:29:45 <lambdabot>   Not in scope: `realFracToDecimal'
12:29:49 <rwbarton> not [(12,""),(1,"2")]
12:29:52 <rwbarton> is that also a bug?
12:29:57 <mauke> rwbarton: not necessarily
12:30:04 <mauke> that could be explained as maximal munch
12:30:05 <Cale> fliip: The key idea is that we're trying to solve the equation t = (\x -> t), because t s = t
12:30:06 <ion> herpladee: Which problem?
12:30:14 <ski> mauke : so are you arguing `(reads :: ReadS Int) ""' should not be `[]', or only that `(reads :: ReadS Int) "0.5"' should not be `[]'m ?
12:30:19 <b__> realFracToDecimal 2 12.49499999999999 == 12.49
12:30:19 <b__> realFracToDecimal 2 12.494999999999999999999999 == 12.50
12:30:23 <typoclass> beaky: but really, it's probably more convenient to just do "module Tape"
12:30:23 <ski> s/m //
12:30:30 <mauke> ski: "0.5" should parse as [(0, ".5")]
12:30:31 <clahey> mcstar: I'm planning on working on a sudoku solver tonight.
12:30:39 <herpladee> ion, this one: ttp://hpaste.org/76773
12:30:43 <typoclass> ion: he pasted his cabal output a while back. it is puzzling
12:30:45 <herpladee> woops, http://hpaste.org/76773
12:30:46 <clahey> mcstar: What would you suggest for a bit map of length 9?
12:30:47 <applicative> beaky so put it in a subdir Data and then in the outer dir do cabal init then you can install it with cabal install ,  for example
12:30:49 <Cale> fliip: And fix (\t -> t') is a solution to the equation t = t'
12:30:49 <mcstar> clahey: watch out, i spent a massive amount of time on it
12:30:51 <ski> > lex "0.5"
12:30:52 <lambdabot>   [("0.5","")]
12:31:00 <clahey> mcstar: I've done a C++ one.  Maybe I'll adapt it.
12:31:03 <beaky> I will submit it to hackage!
12:31:08 <mcstar> clahey: i wrote quickly a first version, and spent all the time on another one
12:31:15 <clahey> mcstar: Oh yeah, of course.
12:31:17 <ion> herpladee: Huh. I haven’t had that problem.
12:31:25 <herpladee> meh :/
12:31:26 <Cale> fliip: So  fix (\t -> (\x -> t))  should be a solution for t in  t s = t
12:31:29 <herpladee> i'll never get this to work
12:31:34 <herpladee> why does it fail for no reason in some random package
12:31:35 <applicative> beaky: i'm thinking the api leaves a little to be desired
12:31:45 <tromp> which is fix const
12:31:53 <beaky> applicative: right; what should I add to it?
12:32:05 <ion> herpladee: I take it it fails consistently in the same place?
12:32:26 <typoclass> herpladee: could you retry the failing command, but make it more verbose? i think the switch is "-v3" for cabal
12:32:26 <PSV> Why doesn't #haskell require identifying?
12:32:33 <ski> mauke : should `(reads :: ReadS Int) "123"' yield `[(1,"23"),(12,"3"),(123,"")]' (perhaps with different ordering) ?
12:32:37 <Cale> fliip: does that make sense? Are you still here?
12:32:43 <herpladee> yes i tried it twice, both at data.text.lazy
12:32:51 <mauke> ski: no
12:32:55 <clahey> mcstar: But yeah, data structure, Int?
12:33:17 <clahey> I'm prematurely optimizing, aren't I?
12:33:26 <ski> PSV : i think the tryhaskell thing would preclude identifying, in the usual case
12:33:26 <herpladee> typoclass, it's the boostrap.sh script from the cabal source tarball, there are no switches i think
12:33:40 <clahey> Actually, this would be a great chance to learn about optimizing.
12:33:49 <Cale> PSV: If it doesn't, then it's because we're not currently in idiot-defense-mode
12:34:00 <mcstar> clahey: the joke is, that my first version is 2x as fast as the 'better' one
12:34:01 <ski> mauke : then why should `(0,".5")' be a valid parse result from `"0.5"', parsing an `Int' ?
12:34:17 * ion is in idiot mode.
12:34:19 <clahey> mcstar: Oi.  Did you change algorithms?
12:34:23 <mcstar> yes
12:34:36 <clahey> mcstar: From and to?
12:34:36 <mcstar> but to a supposedly better one..
12:34:42 <mauke> ski: because "0" is a valid Int
12:34:48 <Cale> Usually you only turn that on when someone with a lot of zombie machines is flooding the channel with joins
12:35:04 <ski> mauke : and so is `"12"' in the `(reads :: ReadS Int) "123"' example
12:35:13 <mauke> ski: yes, but see maximal munch
12:35:48 <mcstar> clahey: the first one, just updated the sets of possible values of cells of the connected units, when i fixed a number, and took care of hidden singles
12:36:01 <ski> mauke : btw, are you here talking about how you believe the report specifies things, or about how you think things ought to happen ?
12:36:15 <mcstar> clahey: the better one, used the exact cover representation of the game, the 729 choices+324 constraints
12:36:27 <mcstar> all the really fast solvers are based on this i believe
12:36:32 <typoclass> is cabal-install 0.14.0 really the current version?
12:36:59 <mauke> ski: the latter
12:37:14 <mauke> if it's working as designed, then the design is bad
12:37:14 <mcstar> clahey: both of the versions are fully immutable
12:37:18 <beaky> how do I write my own shell in haskell
12:37:29 <Clint> carefully
12:37:41 <clahey> mcstar: No IO.
12:37:43 <beaky> I'm going to abandon the turing machine for now
12:37:52 <mcstar> no mutable state
12:37:56 <beaky> and work on another haskell project :D
12:38:05 <typoclass> herpladee: ok, try running "VERBOSE=1  ./bootstrap.sh" in your shell
12:38:23 <clahey> beaky: Write a sudoku solver.
12:38:33 <beaky> that sounds trivial to do in Haskell
12:38:34 <herpladee> alright, trying that
12:38:54 <herpladee> unrecognized flags before it even began :)
12:39:08 <mcstar> if you dont use any help, i dont think it is trivial, but yeah, not too hard
12:39:25 <mcstar> but if you want it fast, you have to be a bit clever
12:39:26 <hpaste> herpladee pasted “with VERBOSE=1” at http://hpaste.org/76776
12:39:37 <mcstar> if you want it really fast, well, i didnt manage that
12:40:35 <clahey> What do you do when adding profiling kills performance by orders of magnitude?
12:40:53 <mcstar> run it on smaller input
12:41:28 <clahey> The profiling doesn't change which parts are slow because it can't optimize as well?
12:41:29 <tac-tics> clahey: prove it things about the runtime behavior statically
12:41:37 <clahey> tac-tics: Haha.  :)
12:41:41 <tac-tics> :P
12:41:56 <clahey> tac-tics: You can only really prove things about the optimal runtime behavior, no?
12:42:08 <clahey> tac-tics: Or can you prove things about the ghc -O2 run time behavior?
12:42:27 <tac-tics> To prove anything about runtime behavior requires knowing what magic GHC does to your code.
12:42:28 <mcstar> effing black box, thats what ghc is
12:42:51 <tac-tics> In other words, you're better off trying to write a faster program using a random number generator than to prove anything.
12:42:55 <clahey> So perhaps Core is the way to do that.
12:42:56 <ski> mauke : i want to argue something like that if we continue parsing from `".5"', getting `.' and `5', we'd have parsed an infix operator expression, but to correctly show that, we must insert spaces (in this case) -- and i'm not sure where the real difference is between this case, and the `"123"' case above
12:43:08 <clahey> A good way to optimize things, I mean.
12:43:19 <ski> (i'm sorry that i wasn't able to phrase that in a more coherent fashion)
12:43:36 <typoclass> herpladee: sorry for that, it was wrong. i figured it out however. it has to be "VERBOSE=-v3 ./bootstrap.sh"
12:43:39 <mcstar> clahey: core is not easy to read
12:43:45 <mcstar> you cant skip actual profiling
12:43:47 <mcstar> imho
12:44:12 <mauke> ski: read doesn't parse haskell expressions
12:44:18 <mauke> and show doesn't show them
12:44:27 <ski> mauke : but should they ?
12:44:33 <mauke> no
12:44:49 <ski> (even some restricted variant, with no lambdas, no `case', no comments, &c.)
12:45:18 <b__> is there a library or module for printing Rational numbers as decimal numbers of a specified precision?
12:45:39 <Cale> b__: You could convert them to fixed point numbers using Data.Fixed
12:46:11 <herpladee> typoclass, okay it comes up with some huge output now, can't paste it all and it's not finishe yet
12:46:20 <ski> > printf "%0.4f" pi :: String  -- ho hum
12:46:21 <lambdabot>   "3.1416"
12:46:33 <hiptobecubic> "lowercasing both strings before a comparison is not a case-insensitive comparison"    Can anyone explain why not? I must be missing something
12:46:34 <lambdabot> hiptobecubic: You have 1 new message. '/msg lambdabot @messages' to read it.
12:46:44 <b__> ski this does not round, and I need it to
12:46:50 <Cale> > printf "%0.4f" (4123789401237890627859123657819651728956128915628 % 43781904732891057382915073892105782390157289501237589) :: String
12:46:51 <lambdabot>   No instance for (Text.Printf.PrintfArg (GHC.Real.Ratio t))
12:46:52 <lambdabot>    arising from ...
12:47:31 <Cale> > realToFrac (4123789401237890627859123657819651728956128915628 % 43781904732891057382915073892105782390157289501237589) :: Fixed E9
12:47:32 <lambdabot>   0.000094189
12:47:38 <Cale> > realToFrac (4123789401237890627859123657819651728956128915628 % 43781904732891057382915073892105782390157289501237589) :: Fixed E12
12:47:39 <lambdabot>   0.000094189355
12:48:12 <rwbarton> > printf "%0.4f" (2/3) :: String
12:48:12 <lambdabot>   "0.6667"
12:48:15 <rwbarton> doh
12:48:17 <rwbarton> > printf "%0.4f" (2%3) :: String
12:48:18 <lambdabot>   No instance for (Text.Printf.PrintfArg (GHC.Real.Ratio t))
12:48:18 <lambdabot>    arising from ...
12:48:21 <rwbarton> alas
12:48:32 <mauke> works with Text.Printf.Mauke
12:48:36 <mauke> also, stop using %0
12:48:38 <hpaste> herpladee pasted “VERBOSE=-v3” at http://hpaste.org/76777
12:48:45 <herpladee> typoclass, you think you can make something out of that?
12:49:41 <mcstar> hiptobecubic: typo?
12:49:57 <clahey> hiptobecubic: The lower case versions could be in a different order than the uppercase versions?
12:50:02 <clahey> hiptobecubic: Where are you reading that from?
12:50:40 <mauke> hiptobecubic: "Straße", "STRASSE"
12:50:54 <typoclass> hiptobecubic: seems to me like it's a popular way to do it
12:51:14 <mauke> also consider Σ/σ/ς
12:51:19 * mcstar dont want to learn about text encoding
12:51:32 <mauke> go back to 1994
12:51:35 <mcstar> k
12:51:39 <mcstar> with pleasure
12:51:54 <mcstar> i know its a bad attitude, thank god, im not a real programmer
12:51:55 <mauke> and AOL!
12:52:08 <Clint> there was probably still a little bit of EBCDIC around in 1994
12:52:09 <clahey> mcstar: Or alternatively, thank god you use a language that basically gets it right.
12:52:23 <mauke> >implying Haskell gets it right
12:53:01 <clahey> mauke: That is my implication.
12:53:20 <clahey> mauke: Though I mostly mean that Char is a unicode point and not a byte.
12:53:27 <b__> ok mauke that Printf library of yours is pretty awesome
12:53:37 <mauke> clahey: that's just the bare minimum
12:53:57 <clahey> mauke: I know.
12:54:01 <mauke> you still have no way to deal with characters, case conversion, case folding, collation, ...
12:54:14 <clahey> mauke: canonical form.
12:54:23 <mauke> what?
12:54:44 <clahey> http://en.wikipedia.org/wiki/Unicode_equivalence
12:54:46 <tsou> mauke: speaking of Σ/σ/ς, do you know if there is a way to correctly upper/lower-case words containing sigmas?
12:55:15 <typoclass> herpladee: i'm sorry, your newest hpaste is even more puzzling to me :-(
12:55:31 <clahey> mauke: Apparently I meant to say normalization.
12:55:40 <mauke> tsou: I guess that depends on how you define "correctly"
12:56:14 <tsou> mauke: σ if it's followed by a letter, ς otherwise..  or something along those lines
12:56:40 <mauke> well, you could write a function for it
12:56:57 <mauke> the tricky part is "followed by a letter"
12:56:58 <typoclass> herpladee: could you file a bug against cabal? the tracker is at https://github.com/haskell/cabal/issues?labels=cabal-install&state=open . be sure to include both links to hpaste. tell them the exact url that you used (http://...cabal-0.1...tar.gz)
12:57:05 <tsou> heh of course, I meant if there is a 'built-in' way to do it correctly
12:57:16 <mauke> I don't know any
12:57:28 <mauke> maybe check hackage for unicode libraries
12:57:33 <typoclass> herpladee: (and bonus points if you could extract your tar.gz again to a clean directory and re-run "VERBOSE=-v3 sh bootstrap.sh", and hpaste the output)
12:57:34 <tsou> because it's no longer a per-character conversion as the usual mapping of toLower over a string..
12:58:04 <mauke> toLower only really works for english/ascii
12:58:13 <typoclass> herpladee: i'm sorry that this is giving you so much trouble. haskell is a very good language, but unfortunately the installation part is brittle and sometimes complicated :-/
12:58:18 <herpladee> i'll just do it all over and then paste it
12:58:33 <typoclass> herpladee: thanks, that sounds great
12:58:41 <herpladee> yea i like haskell too, it's just so hard to install .. this isn't the first time i had these kinds of problems :)
12:59:21 <tsou> mauke: indeed.. i'll check for unicode libs in hackage hopefully i'll find something 'smarter'
12:59:52 <mauke> are you greek?
12:59:54 <tsou> mauke: cause my function would deal with greek correctly, as I'm greek, but I suppose that there are more tricky parts for other languages than that
13:00:00 <clahey> I think one major problem is that the rules for tolower and toupper depend on the language, and not just on the characters.
13:00:06 <mauke> it's flat out impossible for german
13:00:16 <tsou> mauke: why is that?
13:00:22 <mauke> "MASSE" could be both "Masse" (mass) and "Maße" (measurements)
13:00:36 <mauke> now you need semantic analysis
13:00:46 <typoclass> tsou: text-icu?
13:01:00 <tsou> ah, I thought that ß was something like a ligature for the double s, did not know that both could exist with different meanings...
13:01:21 <tsou> typoclass: thanks
13:01:22 <mauke> it's also locale dependent because swiss german doesn't have ß and uses ss everywhere
13:02:15 <mauke> the difference between ß and ss is that ss (like any double consonant) makes the preceding vowel short
13:02:19 <tsou> such a simple-sounding thing, converting upper/lower case..
13:02:24 * ski heard someone say that "ß" could always safely be replaced with "ss"
13:02:41 <mauke> depends on what you mean by "always" and "safely" :-)
13:03:03 <tsou> from what mauke says, it might be always and safely but not everywhere :P
13:03:18 <ski> well, where the new sentence has at least the same interpretations as the old one
13:03:19 <typoclass> ski: it's a helper thing that you'd use if you don't have the character available for some weird reason. it'd be like "well in a telegram you can only use upper case and have no punctuation" or something
13:03:19 <tsou> so you can always do so safely in switzerland apparently :P
13:03:49 <mauke> e.g. if you're in an environment where ß is not available (ascii only/it's not on your keyboard/etc), then yes, substituting ss is the right thing to do
13:03:51 <mcstar> haskell has a tshirtcoming
13:03:59 <spaceships> mcstar: yay!
13:04:16 <mcstar> are you sure? it is a very subtle joke
13:04:21 <tsou> mauke: so the lower->upper conversion is never problematic, right?
13:04:32 <mauke> hah
13:04:37 <mauke> I wouldn't bet on it
13:04:42 <tsou> heheh ok..
13:04:50 <mauke> behold: ẞ
13:05:25 <tac-tics> ẞehold
13:05:30 <mcstar> we are beholding, but nothing happens
13:05:36 <typoclass> ski: i guess that's a decent way to put it -- it'd be like saying "in english you can safely switch everything to lower case". you can, but some information is lost, and if you want to produce writing of any quality, you should use a technology that offers both lower and upper case :)
13:05:40 <mauke> it's an uppercase ß
13:05:45 <mcstar> oh
13:05:50 <tac-tics> New lambda calculus equivalence relation: ẞ-reduction
13:05:58 <mauke> which no one uses, not even the official uppercase/lowercase algorithms
13:06:20 <tsou> mauke: then you safely never use it on your lower->upper conversion, right?
13:06:46 <mauke> I don't even know
13:07:11 <mauke> I mean, is "STRAẞE" case insensitively equal to "Straße"?
13:07:26 <mauke> it depends
13:07:35 <tsou> hyou mean STRASSE, right?
13:07:38 <dmwit> Bah, I thought folds on vectors were supposed to compile to tight loops.
13:07:45 <mauke> no
13:08:27 <tsou> hmm I think my terminal is showing something wrongly
13:08:34 <tsou> i saw "STRAE", you probably typed something else
13:09:05 <DrSyzygy> mauke: Whoa. Uppercase ß? Now THAT's crazy talk. :-P
13:09:08 <tsou> ah, yes, apparently the uppercase ß is invis.
13:09:19 <DrSyzygy> I see it. It actually looks kinda ugly. :-P
13:09:22 <mauke> U+1E9E (e1 ba 9e): LATIN CAPITAL LETTER SHARP S [ẞ]
13:11:02 <mcstar> Bẞ
13:11:02 <tsou> ..and I thought that Σσς and accents in greek were annoying for upper/lower-ing...
13:11:07 <mcstar> kind of close
13:12:45 <mauke> ς̈
13:12:55 <mauke> sigma umlaut~
13:13:42 <DrSyzygy> I see your sigma umlaut and raise you a \frac{\bar\Xi}{\bar\Xi}
13:15:15 <hiptobecubic> oh sorry, guys. didn't realize people were talking to me. It was from this tread. http://www.reddit.com/r/haskell/comments/120h6i/why_is_this_simple_text_processing_program_so/
13:15:35 <hiptobecubic> To be more specific http://www.reddit.com/r/haskell/comments/120h6i/why_is_this_simple_text_processing_program_so/c6r5a0s
13:19:39 <copumpkin> EvanR: tanking
13:20:23 <herpladee> okay now it suddenly worked
13:20:26 <herpladee> wtf
13:23:55 <ebpanic> For the folks who develop on OSX… do you guys prefer using MacPorts or Homebrew as your package manager?
13:24:41 <conal> parcs`: about your earlier question/suggestion (almost 2 hours ago), if I 'cabal install cabal-install' and then remove ghc 7.4, I still lose cabal, because the 'cabal install cabal-install' places cabal into a directory that it then blows away.
13:25:04 <conal> parcs`: oops. i mean a directory that uninstall-hs then removes
13:25:09 <hiptobecubic> I'm sure there's a great reason that the AD package uses some of these crazy abstractions, but I don't know it :)
13:25:26 <EvanR> copumpkin: tankering
13:25:31 <EvanR> cotanking
13:26:22 <copumpkin> :O
13:27:04 * applicative notices a 2 x difference for  some of these 'titlecase' programs according as one uses a 64 or 32 bit ghc
13:28:38 <DrSyzygy> ebpanic: Neither. They both break my environment.
13:29:23 <herpladee> okay i just installed cabal 1.14 from http://www.haskell.org/cabal/download.html but now i can't run "cabal"
13:29:55 <herpladee> i did all that "ghc --make Setup.hs", "./Setup configure", "./Setup build", "./Setup install"
13:30:00 <dmwit> The "cabal" executable is provided by the cabal-install package, not the Cabal library.
13:30:06 <dmwit> Perhaps that is your problem.
13:30:06 <herpladee> oh god
13:30:07 <ebpanic> DrSyzygy, I see… I've been using macports for awhile now, but I'm sick of how long it takes to upgrade everything if I fall behind on updates.
13:30:21 <dmwit> Also possible: perhaps you have not yet correctly munged your PATH.
13:30:35 <herpladee> no it's not in /usr/local
13:30:37 <herpladee> as it said it would be
13:31:13 <ebpanic> DrSyzgy, I've been moving more toward functional javascript and was going to use haskell as reference, so I thought I'd see what you guys were using to keep you dev environment up to date.
13:31:23 <herpladee> what did i do when i installed cabal then?
13:31:26 <herpladee> did i ruin everything?
13:31:51 <dmwit> Is there a reason to believe you ruined everything?
13:32:05 <dmwit> Probably the answer to the first question is merely "you installed Cabal".
13:32:24 <herpladee> no i'm just having a lot of problems
13:32:29 <herpladee> what is cabal then?
13:32:43 <ebpanic> DrSyzygy, are keeping track of dependencies yourself?
13:32:48 <ParahSail1n> example of lazy evaluation: < dmwit> Probably the answer to the first question is merely "you installed Cabal".
13:32:57 <conal> oh, i see. download & build cabal explicitly: http://www.haskell.org/cabal/download.html
13:33:02 <applicative> a library that the cabal executable depends on, herpladee -- as do other things
13:33:19 <conal> just like we used to do before cabal.
13:33:30 <PSV> What does it take to port haskell to an embedded system? How big is the runtime environment?
13:33:36 <applicative> herpladee: does  ghc-pkg list show two Cabal libs
13:33:39 <ebpanic> DrSyzygy, or do you have another package manager for OSX that you use? I only know of Homebrew, Macports, and Fink
13:33:41 <herpladee> i'd use cabal for it conal, but it doesn't work
13:33:52 <DrSyzygy> ebpanic: Why would I need a package manager?
13:34:06 <dmwit> You really, really need to give more details, herpladee.
13:34:24 <conal> herpladee: sry. different thread. i'm installing ghc 7.6.1 and wondering how to get cabal installed or remaining after removing 7.4.1
13:35:00 <applicative> herpladee: or 'ghc-pkg list Cabal'
13:35:57 <ebpanic> DrSyzygy, hmmmm… I guess I've just always used one for my dev environment… maybe I should rethink it..
13:36:13 <ebpanic> I'm relatively new to developing on a mac...
13:36:25 <herpladee> one second, the server is hanging
13:36:43 <typoclass> herpladee: cabal-install is the command line tool, which uses the library named cabal. you may have 2 problems: the library is there but you still need to build the command line tool; and/or your PATH might not contain the directory that contains the cabal binary (sometimes ~/.cabal/bin/)
13:36:51 <typoclass> dmwit: about 2 hours ago he has walked in here asking "i have ubuntu, i'd like to use haskell, what should i install". since then he's been debugging :-/
13:37:13 <dmwit> Ubuntu has the Platform, no?
13:37:21 <rwbarton> turns out he has stone age ubuntu
13:37:29 <ebpanic> DrSyzygy,  I guess for keeping gcc up to date and other tools like that?
13:37:41 <DrSyzygy> ebpanic: I use gcc from XCode.
13:37:43 <herpladee> no i didn't install cabal-install
13:37:54 <typoclass> rwbarton: it's one of those long-term releases and i really don't see what the problem is with that
13:38:03 <DrSyzygy> ebpanic: Then I use the Haskell platform, which comes with a MacOS installer.
13:38:31 <DrSyzygy> For the few things that aren't packaged for MacOSX that I end up needing, I tend to build them the good old way: download tarball, ./configure, make, make install
13:38:48 <typoclass> dmwit: you might want to check the logs ... he says ghc told him to get the platform, and the platform told him to get ghc
13:38:49 <DrSyzygy> (which btw is why homebrew fails; the damn thing thinks it can monopolize /usr/local with impunity)
13:39:07 <rwbarton> typoclass: well sure, nothing wrong with it but "just install haskell platform through apt" is not the solution then
13:39:36 <ebpanic> DrSyzygy, I am developing node.js apps and macports was recommended to me… so I've been using it ever since.
13:39:58 <typoclass> rwbarton: right
13:40:40 <citizen93> Dear I just stumbled upon the concept of GHC.Generics and I was experimenting with it... http://pastebin.com/nLGF0ZA7
13:40:43 <mauke> The paste nLGF0ZA7 has been copied to http://hpaste.org/76779
13:40:56 <citizen93> now my question is actually
13:40:59 <DrSyzygy> ebpanic: Good for you, if it works foryou all power to you. Asking us what we use, my response is no package manager.
13:41:00 <citizen93> how can I use the put function?
13:41:10 <citizen93> I can't seem to get the idea behind Generics :(
13:41:51 * hackagebot dyre 0.8.10 - Dynamic reconfiguration in Haskell  http://hackage.haskell.org/package/dyre-0.8.10 (WillDonnelly)
13:41:52 <ebpanic> DrSyzygy, thanks! I appreciate the info… I'm still learning.
13:42:30 <citizen93> can someone give me an example of the usage of the put function as described (http://pastebin.com/nLGF0ZA7)?
13:42:30 <mauke> The paste nLGF0ZA7 has been copied to http://hpaste.org/76779
13:43:02 <rwbarton> put True
13:44:15 <citizen93> does that work?
13:44:18 <citizen93> lets see
13:44:33 <rwbarton> are you familiar with type classes generally?
13:45:13 <citizen93> uhm I know the basics
13:45:27 <rwbarton> well put is just a class method of Serialize
13:45:27 <citizen93> they're used for overloading right?
13:45:33 <citizen93> yes
13:45:36 <rwbarton> so you can call put on anything that is an instance of Serialize
13:45:39 <citizen93> yes
13:45:51 <rwbarton> and the last four lines define four instances of Serialize
13:46:01 <citizen93> yes, but if I do put 5
13:46:04 <citizen93> it fails :(
13:46:07 <rwbarton> it won't know which instance to use
13:46:14 <rwbarton> because put is overloaded, and 5 is overloaded
13:46:17 <rwbarton> put (5 :: Int)
13:46:19 <citizen93> OH!
13:46:50 <dmwit> (If you read the error carefully, it should say pretty much what rwbarton just said, but without the (5 :: Int) suggestion.)
13:47:13 <hiptobecubic> Does anyone understand the Cofree [] a comonad? It works like some kind of infinitely nested structure of infinite lists?
13:47:14 <citizen93> ic ic
13:47:20 <beaky> http://ideone.com/sw7Nxv I've optimized my C turing machine.
13:47:28 <conal> what's a convenient technique for switching back & forth between ghc versions? just modify the 'ghc' symlink?
13:47:43 <beaky> Ive cut the linecount by a factor of 7
13:47:44 <dmwit> conal: stow
13:48:01 <dmwit> http://www.gnu.org/software/stow/
13:48:18 <conal> dmwit: thx. i hadn't heard of stow.
13:48:49 <dmwit> conal: Or cabal install --with-compiler =ghc-7.x.y with a good shell. ;-)
13:49:11 <conal> dmwit: oh, sure. thx.
13:49:30 <thoughtpolice> these days i just use hsenv for pretty much everything
13:49:36 <thoughtpolice> although it's pretty broken with new cabal :(
13:49:57 <conal> thoughtpolice: also new to me. thx.
13:50:00 <GnomeStoleMyBike> > let ( <===== ) _ _ = "immma shoootin ma lazooor"
13:50:01 <lambdabot>   not an expression: `let ( <===== ) _ _ = "immma shoootin ma lazooor"'
13:50:22 <dmwit> firin', and also you need an in clause
13:50:37 <rwbarton> or @let
13:50:42 <GnomeStoleMyBike> it is custom combinator :)
13:50:44 <thoughtpolice> conal: i mostly like it because you cannot 'forget' things, i've forgotten the --with-ghc flags, or said 'cabal' instead of 'cabal-dev' plenty of times doing development and that sucks. since it just overrides part of your shell, i think it works a lot more 'consistently'
13:50:57 <GnomeStoleMyBike> cabal-dev is cool
13:50:57 <herpladee> hey i kinda did ghc-pkg unregister Cabal
13:51:04 <herpladee> and i don't think that was a good idea, how do i undo it?
13:51:09 <citizen93> I have another small question, but this time regarding classes, can someone give me an idea when someone would want to use multiparameterized type classes?
13:51:11 <startling> ouch.
13:51:25 <conal> thoughtpolice: sounds great
13:51:26 <startling> citizen93, MonadWriter is one
13:51:47 <startling> citizen93, say I wrote a type that always wanted to write lists of strings
13:51:48 <thoughtpolice> conal: also it's really useful for making my own GHC builds and testing them, since you can just point it at a .tar.bz2 file and whoosh, 'ghc' is now your special copy
13:51:52 <rwbarton> herpladee: ghc-pkg register <something>
13:52:03 <thoughtpolice> makes it super easy to test hackage or something against newer GHCs
13:52:11 <herpladee> rwbarton, Reading package info from "Cabal" ... ghc-pkg: Cabal: openFile: does not exist (No such file or directory)
13:52:16 <startling> citizen93, you could parametrize it but not always
13:52:18 <thoughtpolice> conal: but like i said it's broken with cabal 1.16 atm, there are patches but nothing official
13:52:18 <dmwit> herpladee: Use ghc-pkg register describe to find out where things are probably stored.
13:52:18 <rwbarton> for me <something> = ~/.ghc/x86_64-linux-7.4.2/package.conf.d/Cabal-1.16.0.1-eea52ab0fd57b6ba356189546b4dbd24.conf
13:52:28 <conal> thoughtpolice: hrmf
13:52:45 <citizen93> startling: would the header be class SomeType f String where ...?
13:52:51 <dmwit> herpladee: Also, read the documentation before blindly typing commands. Then you would know that "ghc-pkg register Cabal" would not have been enough.
13:53:10 <startling> citizen93: nah. you'd do class MonadWriter m w where tell :: w -> m ()
13:53:10 <hiptobecubic> .... I bet i'm supposed to be using lenses
13:53:16 <thoughtpolice> conal: yeah :(
13:53:26 <startling> citizen93: and then my type would be instance MonadWriter MyType [String]
13:53:57 <PSV> What does it take to port haskell to an embedded system? How big is the runtime environment?
13:54:04 <startling> I flipped the type variables, but you get the idea
13:54:11 <citizen93> oh I see! Thank yoU!
13:54:55 <startling> citizen93: they also use FunctionalDependencies to resolve some ambiguities, btw
13:55:42 <hiptobecubic> If i have things which are "likely to be broken by reinstalls" is it enough to just reinstall those ethings?
13:56:35 <hiptobecubic> i think i borked everything
13:56:50 <startling> hiptobecubic, have you tried --reinstall  ?
13:56:55 <hiptobecubic> IS 7.6 safe to move to yet?
13:57:42 <fmap> hiptobecubic: if you don't mind patching packages
13:58:29 <dmwit> hiptobecubic: Yes, the usual fix for "likely to be broken" is to cabal install both the things you want and the things that need to be reinstalled in one transaction.
13:59:20 <dmwit> ...in particular, it is often not enough to first install the things you want and then reinstall the broken things in a second transaction.
13:59:36 <hiptobecubic> hm
14:00:01 <hiptobecubic> comonads-fd-3.0 is failing to build now
14:00:08 <hiptobecubic> actually... only the profiling library
14:00:21 <dmwit> (The rule is very simple: you tell cabal install *all* the things you want to be installed every time. As a shortcut, sometimes you can omit almost all of them.)
14:08:10 <beaky> yes! my turing machine runs at 2GHz
14:14:13 <citizen93> Hello, I'm trying to write a sort of generalized map using generic deriving as an exercise to see whether I get it, I am kind of stuck at the following http://pastebin.com/kNAqCAub
14:14:16 <mauke> The paste kNAqCAub has been copied to http://hpaste.org/76780
14:14:32 <mcstar> pastebin.com sucks
14:14:33 <citizen93> my first question is whether my class section is correct
14:14:46 <citizen93> I want, class GApply f g (two different types
14:15:17 <citizen93> and if you use me_apply :: f a -> g b it will transform from type f to type g
14:15:27 <citizen93> is this correct?
14:15:30 <dmwit> Your class declaration is fine, but your instances are wrong.
14:15:37 <citizen93> yeah I figured that out
14:15:43 <citizen93> the first one
14:15:47 <citizen93> there is a problem
14:15:57 <citizen93> because I do not know what to return? do I do the id function?
14:16:01 <dmwit> Also, I wouldn't exactly call this a "generalized map" unless you plan on giving me_apply an (a -> b) argument.
14:16:17 <hpaste> “Ertugrul Söylemez” pasted “Simple region example” at http://hpaste.org/76781
14:16:28 <citizen93> I want for example map it over like a tree or something
14:16:36 <dmwit> :t fmap
14:16:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:16:45 <dmwit> Is there something wrong with this already-existing class?
14:16:49 <citizen93> no
14:16:56 <dmwit> So... problem solved?
14:16:58 <citizen93> I mentioned that I wanted to do this as an exercise
14:17:20 <dmwit> Okay, then the problem with this existing class is you don't understand it. =)
14:17:25 <dmwit> Which is fine.
14:18:03 <dmwit> So, let me point out a few red flags I noticed when I was reading your definition of the GApply class.
14:18:32 <dmwit> 1. The type variables "a" and "b" aren't connected at all, meaning if you're viewing 'g' as a container-type constructor, you'll always have to return empty containers.
14:18:59 <citizen93> oh icic
14:19:03 <citizen93> indeed
14:19:18 <dmwit> 2. The type variables "f" and "g" aren't connected at all (except by the type class), meaning you'll probably have to give a lot of explicit type declarations when using this function.
14:20:01 <dmwit> 3. You declare this class to abstract over two types of kind (* -> *), but below you seem to be trying to use it as though it were abstracted over two types of kind *.
14:20:37 <dmwit> Well, your kinding as all over the board, really.
14:21:04 <citizen93> Thank you for your help, I'm going to try again
14:25:08 <lightquake> wow, switching to an ssd really made my builds faster
14:25:35 <shachaf> lightquake: What about getting more RAM?
14:26:05 <lightquake> doubtful, I have 8GB and i'm not hitting swap
14:26:13 <lightquake> (plus with an SSD hitting swap is also much less painful)
14:26:28 <shachaf> The question isn't whether you're hitting swap but whether your page cache has all the things you're using in it.
14:26:28 <herpladee> typoclass, okay it works now for some reason i have no idea ... i was trying to replicate the bug so that i could report the issue on github but then i got an earlier error, i googled it and it said it was because of lack of memory. then i put in 2gb ram in the server and now it's working alright... it's really weird though that it should run out of memory at the same place twice in a row but the memory is the only thing i chan
14:26:41 <lightquake> true
14:27:10 <dmwit> I would think the page cache only mattered for repeated builds.
14:27:12 <shachaf> What if you do the build on a ramdisk?
14:27:23 <dmwit> The first build is going to have to drag things in from the disk anyway.
14:27:25 <shachaf> Well, yes.
14:27:33 <typoclass> herpladee: wow, that sounds like a weird situation
14:27:36 <lightquake> then i'd have to figure out how to do a ramdisk in os x
14:27:49 <herpladee> yea i have a tendency to end up in weird situations
14:28:12 <herpladee> usually with nonsensical bugs i can replicate n times and then suddenly i can't replicate them anymore :(
14:28:14 <strebe> dmwit: not necessarily, there's always linus's trick of running grep -ri on the root directory of your codebase when you start work for the day, assuming you have ample ram
14:28:18 <hiptobecubic> I went a little overboard on ram this time :)
14:29:11 <herpladee> hey how do i install Control.Parallel.Strategies with cabal?
14:29:22 <herpladee> i mean that's not the package name i have to type in it seems
14:29:42 <dmwit> The package is named parallel. You can learn this by asking Hoogle:
14:29:46 <typoclass> herpladee: first step is to figure out what package offers that module. use hayoo for that
14:29:46 <dmwit> http://www.haskell.org/hoogle/?q=Control.Parallel.Strategies
14:29:48 <typoclass> @where hayoo
14:29:49 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:30:33 <jakubmal> now if we got some cabal masters here...
14:30:41 <mcstar> -i?
14:30:59 <jakubmal> ive been trying to install a few packages lately with cabal
14:31:08 <jakubmal> and they all fail...
14:31:22 <jakubmal> compile mainly
14:31:32 <mcstar> and, doesnt that take too much time? grep lists everything to stdout
14:31:34 <jakubmal> is there something wrong with haskell-platform on debian 6?
14:31:51 <dmwit> mcstar: Just >/dev/null
14:32:07 <mcstar> that doesnt make the effort effortless
14:32:11 <typoclass> jakubmal: do you have any details? could you put cabal's output of the failing build on hpaste?
14:32:13 <typoclass> @where hpaste
14:32:13 <lambdabot> http://hpaste.org/
14:32:14 <mcstar> just hides the output from you
14:32:51 <dmwit> mcstar: It actually pretty much does. You should compare how long it takes to cat a thing to a terminal and how long it takes to cat it to /dev/null some time.
14:33:24 <mcstar> dmwit: yeah, since you HIDE the output
14:33:31 <mcstar> but the program still outputs it
14:33:43 <mcstar> its just that your slow terminal doesnt have to display it
14:33:54 <dmwit> Yes, that's right.
14:34:00 <dmwit> What's the complaint, then?
14:34:17 <beaky> http://www.youtube.com/watch?v=iSmkqocn0oQ
14:34:24 <mcstar> grep -ri seems like too constly just to cache directories
14:34:26 <mcstar> imho
14:34:31 <mcstar> costly*
14:35:18 <mauke> what's the task?
14:35:37 <mcstar> "not necessarily, there's always linus's trick of running grep -ri on the root directory of your..."
14:35:57 <rwbarton> prefetching a bunch of files into ram
14:36:24 <mauke> cat * >/dev/null
14:36:35 <mauke> find / -exec cat {} + >/dev/null
14:38:22 <hpaste> jakubmal pasted “happstack installation fails” at http://hpaste.org/76782
14:38:52 <jakubmal> but the problem really is that so many packages fail during install with weirdo errors
14:39:10 <typoclass> jakubmal: hmm ... could you run that command again with "-v3"? that should give you more output
14:39:33 <rwbarton> what version of ghc are you using?
14:39:38 <rwbarton> (ghc --version)
14:40:08 <rwbarton>   if impl(ghc < 7.0)
14:40:09 <rwbarton>     buildable: False
14:40:18 <rwbarton> from happstack-server.cabal
14:40:35 <typoclass> rwbarton: ok then that's the problem (see line 2 of his paste)
14:40:52 <typoclass> jakubmal: looks like you need to update your ghc
14:41:08 <jakubmal> sec
14:42:00 <jakubmal> yeah ghc 6.12
14:42:20 <stepcut> GHC 6.12 is 2-3 years old
14:42:20 <rwbarton> you could try an older version of happstack-server I guess, or update ghc
14:42:21 <jakubmal> but then debian repos suck
14:42:57 <jakubmal> @rwbarton where is that  if impl(ghc < 7.0) code?
14:42:57 <lambdabot> Unknown command, try @list
14:43:05 <rwbarton> http://hackage.haskell.org/packages/archive/happstack-server/7.1.0/happstack-server.cabal
14:44:01 <jakubmal> thanks
14:44:23 <jakubmal> what you think would be best then, compile from source?
14:44:32 <jakubmal> the whole haskell-platform
14:45:02 <rwbarton> this just came up actually, one moment
14:45:02 <mauke> install ghc in your home directory, install packages as needed
14:45:03 <typoclass> jakubmal: if you can, use the binary. there's rarely any reason to compile ghc from source
14:45:11 <stepcut> jakubmal: or install a recent haskell platform binary ?
14:45:12 <rwbarton> https://gist.github.com/2815423
14:45:45 <stepcut> in general, it is a terrible idea to mix debian packaging + cabal-install anyway.
14:46:52 * hackagebot ScratchFs 0.1.0.0 - Size limited temp filesystem based on fuse  http://hackage.haskell.org/package/ScratchFs-0.1.0.0 (FalcoHirschenberger)
14:47:04 <jakubmal> yeah, but even opengl couldnt compile
14:47:11 <jakubmal> so it seems ghc6 is the problem
14:47:35 <jakubmal> @rwbarton will this work at say /opt/haskell ?
14:47:36 <lambdabot> Unknown command, try @list
14:47:42 <rwbarton> sure
14:47:44 <jakubmal> I need to share it for a few users
14:47:54 <rwbarton> also this isn't twitter, you don't need to start every line with @ :P
14:48:03 <mauke> the binary tarball lets you specify a directory prefix
14:48:59 <jakubmal> yeah, but I had a lot of problems with sharing rvm for many users
14:49:11 <jakubmal> so thats what I'm asking about
14:49:26 <copumpkin> omg rwbarton is on twitter
14:49:46 <mauke> I don't think it should cause problems
14:49:56 <mauke> you just have to make sure the binaries appear first in the path
14:50:30 <jakubmal> great
14:51:39 <jakubmal> now I cant remove ghc with apt-get
14:52:02 <mcstar> apt-get uninstall apt-get
14:52:23 <mauke> heh
14:52:32 <mauke> what's the error?
14:54:09 <jakubmal> nevermind I started removing whatever sounds like haskell and it finally worked
14:54:28 <__name__> is that ubuntu?
14:54:37 <jakubmal> debian
14:54:41 <Clint> you could have just done aptitude purge ghc
14:55:33 <hpaste> hiptobecubic pasted “How can I generalize this lens pattern?” at http://hpaste.org/76783
14:56:01 <hiptobecubic> It's a short sample, but I think that's all you need to understand what I'm trying to do
14:56:08 <hiptobecubic> g is a Cofree [] Double
14:56:52 * hackagebot scotty 0.4.6 - Haskell web framework inspired by Ruby's Sinatra, using WAI and Warp  http://hackage.haskell.org/package/scotty-0.4.6 (AndrewFarmer)
14:58:12 <fmap> hiptobecubic: you can compose lenses with (.)
14:58:21 <fmap> hiptobecubic: also there are _head and _tail
14:58:36 <fmap> (in Data.List.Lens)
14:59:12 <hiptobecubic> This is the first time i've tried using lenses. The swap for _head and _tail is easy enough, but I had a problem trying to isolate "unwrapped ^. _head"
15:00:44 <fmap> hiptobecubic: well, `let f = unwrapped . _head in ... f ...' should work
15:01:03 <hiptobecubic> fmap, yes i just realized what you meant by "you can compose lenses with ."
15:01:09 <rwbarton> clearly what's needed is @lens-pl/@lens-djinn
15:01:22 <hiptobecubic> rwbarton, yes
15:01:36 <elliott> rwbarton: lens package lenses are just ordinary functions so maybe @pl/@djinn can be used for the task
15:01:38 <citizen93> I have another question regarding types, does this make sense:     class Test f g b where
15:01:38 <citizen93>       Test :: f a -> (a -> b) -> b
15:01:56 <elliott> rwbarton: though I doubt djinn supports types like (forall f. (Functor f) => (a -> f b) -> c -> f d)
15:02:00 <hiptobecubic> fmap, so what was i doing? instead of making a lens to the element i want, I was just peeling one layer at a time and applying a new lens to each?
15:02:15 <elliott> er (c -> f d) -> a -> f b rather but who cares
15:02:15 <rwbarton> but @pl won't write things in terms of the functions defined in lens
15:02:22 <elliott> rwbarton: fair enough
15:02:24 <elliott> but it could fairly easily
15:02:26 <elliott> it's quite general
15:02:50 <hiptobecubic> it's weird to compose them with (.) because the flow is backwrads
15:02:57 <hiptobecubic> backwards too
15:03:20 <elliott> hiptobecubic: you can use (>>>)
15:03:24 <elliott> or wait
15:03:30 <elliott> doesn't Control.Lens export (%) as flip (.)
15:03:32 <elliott> maybe it's flip ($)
15:04:01 <shachaf> It's flip ($)
15:04:19 <hiptobecubic> @hoogle Data.List.Lens
15:04:20 <lambdabot> package lenses
15:04:20 <lambdabot> package data-lens
15:04:20 <lambdabot> package data-lens-fd
15:05:06 <startling> `lens` has it too I think
15:05:39 <startling> yep
15:05:45 <beaky> :t flip ($)
15:05:46 <lambdabot> forall a b. a -> (a -> b) -> b
15:05:59 <beaky> print (flip $) "foo"
15:06:34 <startling> > let (%) = flip ($) in (+) 1 % 2
15:06:38 <lambdabot>   mueval-core: Time limit exceeded
15:06:52 * hackagebot ScratchFs 0.1.0.1 - Size limited temp filesystem based on fuse  http://hackage.haskell.org/package/ScratchFs-0.1.0.1 (FalcoHirschenberger)
15:07:04 <beaky> > let i = i in i
15:07:07 <lambdabot>   mueval-core: Time limit exceeded
15:08:11 <hiptobecubic> lens is one of those words that starts looking weird
15:08:25 <hiptobecubic> after looking at it for awhile, i mean.
15:08:41 <startling> mappend is another
15:08:42 <hiptobecubic> It feels like it's missing a vowel or something.
15:08:52 <hiptobecubic> lense
15:09:01 <ciaranm> lense.cx
15:09:06 <startling> lenseses
15:09:34 <beaky> @pl sum [i | i <- [1..10], i /= 3 && i /= 6]
15:09:34 <lambdabot> i | i <- [1..10] + (i /= 3 && i /= 6)
15:09:47 <rwbarton> haha
15:10:00 <beaky> ? what is that
15:10:08 <rwbarton> @@ @pl @undo sum [i | i <- [1..10], i /= 3 && i /= 6]
15:10:08 <lambdabot>  sum (=<<) (flip (ap (if' . liftM2 (&&) (3 /=) (6 /=)) return) []) [1..10]
15:10:14 <hpaste> hiptobecubic annotated “How can I generalize this lens pattern?” with “How can I generalize this lens pattern? (annotation)” at http://hpaste.org/76783#a76784
15:10:19 <hiptobecubic> fmap, how about now?
15:10:29 <rwbarton> pl doesn't know about list comprehensions so it thinks that is a list with two elements "i | i <- [1..10]" and "i /= 3 && i /= 6" and it added them for you
15:10:35 <b__> how is the following formatting inconsistency in GHCI even possible:
15:10:36 <b__>   321932222,00
15:10:37 <b__> *Finance.General> EUR 321932222
15:10:37 <b__> 321932222,00
15:10:55 <b__> calling same function twice
15:11:02 <b__> different output
15:11:22 <nicoo> b__: Not the same context, it would seem
15:11:30 <nicoo> (And 'night, lads and ladies)
15:11:33 <b__> yes same context
15:11:51 <rwbarton> maybe something different about the types
15:11:54 <rwbarton> you didn't paste the first input
15:12:20 <beaky> > (sum . (filter (liftM@ (&&) (/= 3) (/= 6)))) [1..10]
15:12:21 <b__> *Finance.General> EUR 321932222
15:12:21 <b__>   321932222,00
15:12:22 <lambdabot>   Pattern syntax in expression context: liftM@(&&)
15:12:22 <b__> *Finance.General> EUR 321932222
15:12:22 <b__> 321932222,00
15:12:25 <beaky> > (sum . (filter (liftM2 (&&) (/= 3) (/= 6)))) [1..10]
15:12:27 <lambdabot>   46
15:12:33 <beaky> @pl (sum . (filter (liftM2 (&&) (/= 3) (/= 6)))) [1..10]
15:12:33 <lambdabot> sum (filter (liftM2 (&&) (3 /=) (6 /=)) [1..10])
15:12:38 <b__> it's the exact same functino
15:12:58 <ciaranm> and the exact same output!
15:13:17 <rwbarton> they don't look the same to me
15:13:30 <b__> they are not the same
15:13:37 <ciaranm> oh, so you're saying i'm racist now?
15:14:08 <tsou> b__: how do you trigger the difference?
15:14:21 <b__> *Finance.General> EUR 321932222
15:14:21 <b__> 3  21932222,00
15:14:21 <b__> *Finance.General> EUR 321932222
15:14:21 <b__>   321932222,00
15:14:27 <b__> here's another variation
15:14:44 <b__> I have no idea how I trigger it
15:14:46 <stobix> yo peeps. Is there a nice and quick tree module/hastable module one can use? (Data.Hashtable is deprecated, and Data.Tree makes my brain hurt.)
15:14:47 <tsou> b__: maybe a terminal/unicode problem?
15:14:48 <beaky> what does liftM2 do
15:14:54 <b__> tsou, possibly
15:14:58 <mauke> stobix: Data.Map?
15:15:13 <rwbarton> is Finance.General on hackage or your own module?
15:15:27 <b__> my own
15:15:28 <hiptobecubic> must be his own, i don't see it
15:15:46 <rwbarton> i mean, i can invent explanations
15:15:51 <hiptobecubic> beaky, lifts a 2 argument func into a monad
15:15:55 <rwbarton> "your Show instance is using unsafePerformIO and threads"
15:15:56 <hiptobecubic> :t liftM2
15:15:57 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:16:06 <beaky> ah
15:16:15 <b__> I will hpaste the Show instance, 1 sec
15:16:15 <tsou> b__: try outputting it to a file, and test if it always outputs the same thing
15:16:17 <hiptobecubic> > liftM2 (+) (Just 5) (Just 2)
15:16:18 <beaky> so it turns a binary function into a monad?
15:16:19 <lambdabot>   Just 7
15:16:24 <mauke> beaky: no
15:16:25 <hiptobecubic> I'm getting better at this :)
15:16:26 <jakubmal> libgmp3 should do as libgmp-dev or it's too old or something?
15:16:34 <beaky> :t liftM2 (&&)
15:16:35 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
15:16:44 <stobix> mauke: hm. And using foldr as a lookup function? Might work.
15:16:50 <tsou> b__: it screams "i'm a terminal/unicode problem" :P
15:16:52 <rwbarton> b__: here's another thing you could try -- show (EUR 321932222)
15:16:55 <mauke> stobix: ?
15:16:58 <hiptobecubic> beaky, it turns a binary function into a function on two monadic values
15:17:01 <beaky> ah
15:17:19 <b__> "\8364\&321932222,00"
15:17:30 <hiptobecubic> I'm on shaky legs with the vocabulary, is that even correct mauke ?
15:17:39 <startling> beaky, liftM is essentially fmap
15:17:43 <beaky> ah
15:17:45 <beaky> :t liftM
15:17:47 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:17:51 <startling> :t fmap
15:17:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:17:53 <beaky> :t (<$>)
15:17:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:18:00 <Cale> Or to put it another way,  liftM2 f x y  is an action which runs x and y in turn, and then returns the result of applying f to both of their results.
15:18:11 <startling> beaky, you can use it to write the Functor instance for any given Monad.
15:18:11 <beaky> ah now I get it
15:18:16 <Cale> i.e.  liftM2 f x y = do u <- x; v <- y; return (f x y)
15:18:21 <rwbarton> b__: well that seems right
15:18:24 <beaky> so liftM2 is basically a higher-order function
15:18:26 <beaky> pretty neat
15:18:31 <rwbarton> my guess is your terminal is broken
15:18:48 <b__> hm, okay
15:19:07 <hiptobecubic> Cale, doesn't the 'action' intuition break down if we're not talking about IO?
15:19:23 <Cale> actually, it doesn't
15:19:28 <Cale> Even with lists, it still works
15:19:34 <b__> rwbarton, it appears to be tmux (for Mac) that's causing it
15:19:38 <beaky> http://ideone.com/ffmEBb
15:19:43 <b__> without tmux it shows up fine
15:19:46 <rwbarton> b__: mmm
15:19:49 <Cale> Running a list means to select an item from it (in all possible ways)
15:19:51 <stobix> mauke: ah, nevermind. Found some more functions to play with. Thanks! :)
15:20:03 <b__> thanks for helping me debug
15:20:16 <Cale> > do x <- [1,2,3]; y <- [40,50]; return (x + y)
15:20:17 <lambdabot>   [41,51,42,52,43,53]
15:20:38 <Cale> > liftM2 (+) [1,2,3] [40,50]
15:20:39 <lambdabot>   [41,51,42,52,43,53]
15:20:50 <hiptobecubic> hm
15:20:57 <startling> b__: I have a suspicion that os x's termcap or terminfo is slightly wrong
15:21:21 <startling> emacs' m-x ansi-term and tmux never seem to work 100%
15:21:36 <hiptobecubic> I the first example seemed natural, but for some reason i was still surprised by liftM2 (+) [1,2,3] [40,50]
15:21:42 <hiptobecubic> even though they are the same
15:22:11 <b__> startling, I also often have problems with certain vim scripts in Mac OSX terminal
15:22:15 <b__> so yeah
15:22:19 <startling> b__: yeah. :/
15:22:32 <Cale> Well, we run [1,2,3], and we run [40,50] and we add the results together. That is, we pick an element from [1,2,3] and from [40,50], and we add them together in all possible ways.
15:23:02 <startling> b__, have you tried iterm2? it solved some (but not all) of the problems for me
15:23:02 <Cale> The sequence function takes a list of actions, and produces an action which runs each of them in turn, returning a list of their results.
15:23:16 <b__> I have yes, and use it often
15:23:19 <Cale> In the list monad, that means it takes a list of lists, and picks one element from each of them, in all possible ways.
15:23:27 <b__> but like you said, it doesn't solve everything
15:23:32 <startling> mhm.
15:23:34 <Cale> Which is to say, it computes the cartesian product of the lists.
15:23:46 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
15:23:47 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
15:23:49 <hiptobecubic> Cale, i 'get' it. But not without careful thought everytime still
15:24:28 <Cale> To some extent, you can solve that problem through memorisation, but careful thought is always good when you can't remember how things specialise :)
15:24:54 <mcstar> @src sequence
15:24:54 <lambdabot> sequence []     = return []
15:24:54 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
15:24:54 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
15:25:03 <hiptobecubic> well I think i successfully lensed something finally
15:25:05 <mcstar> OR?
15:25:07 <cmccann> "Civilization advances by extending the number of operations which we can perform without thinking about them."
15:25:08 <cmccann> :P
15:25:26 <Cale> The analogy to computation generally won't break down though. There will always be some funny way to interpret the values of your monad as computations for some abstract machine to execute, and v <- x as giving a name v to the "results" of those "actions".
15:25:46 <Cale> rather to the "result" of the "action" x
15:26:18 <hiptobecubic> It is just a new way for me to think about it
15:26:25 <startling> hiptobecubic, have you used applicative style at all?
15:26:29 <hiptobecubic> is this idiomatic yet? http://hpaste.org/76783
15:26:52 <startling> e.g liftM (+) x y is (+) <$> x <*> y
15:27:01 <hiptobecubic> startling, not deftly. I've aped it in some simple cases when it was obvious or I had no choice, like xmonad config
15:27:24 <hiptobecubic> I find applicative style to be pretty obfuscating
15:27:44 <startling> hiptobecubic, if your thing is a monad you can always use do notation
15:27:49 <ciaranm> only until you learn how to read <$> and <*> and <* and so on
15:28:26 <hiptobecubic> ciaranm, sure, but memorizing more terse operators takes time
15:28:32 <cmccann> @quote idiom.brackets
15:28:32 <lambdabot> cmccann says: Idiom brackets are where you consume a mixture of alcohol and Conor McBride papers until your vision gets blurry enough that you can't actually see the Applicative operators anymore.
15:28:47 <hiptobecubic> fmap is easier to understand immediately than <$>
15:29:21 <ciaranm> hiptobecubic: i'm not so sure. <$> is like $ but up one level.
15:29:38 <startling> haha
15:29:41 <hiptobecubic> well, in some contexts yes. <$> seems natural
15:30:00 <startling> > let (^$) = fmap in (+ 1) ^$ [1, 2, 3]
15:30:01 <lambdabot>   [2,3,4]
15:30:02 <ciaranm> and <* and *> point the way you take things
15:30:54 <startling> > let (^^$) = fmap . fmap in (+ 1) ^^$ [Just 1, Nothing, Just 3, Just 12]
15:30:56 <lambdabot>   [Just 2,Nothing,Just 4,Just 13]
15:31:03 <startling> that's a neat way to think of it.
15:31:14 <startling> "up one level", I mean.
15:31:55 <hiptobecubic> this looks more like what lenses are for
15:32:12 <ciaranm> and lifts take you up a level
15:32:16 <tac-tics> startling: lots of things in type theory work like that, "one level up" from another thing.
15:32:18 <ciaranm> unless you're american
15:32:36 <tac-tics> startling: Like kinds in Haskell. Kinds are (more or less) just the simply typed lambda calculus, performed by the compiler at compile time
15:33:46 <startling> ciaranm, if you're american, they just make you stronger
15:33:54 <startling> tac-tics: neat.
15:34:13 <tac-tics> Instead of (lambda x:A x) y --> y : A
15:34:38 <tac-tics> You get (List :: * -> *) (A :: *) -> List A :: *
15:34:57 <tac-tics> (that -> is supposed to be an evaluation, not a function type)
15:35:11 <startling> yeah. cool.
15:36:42 <hiptobecubic> is there a lensey way to index a list?
15:36:55 <hiptobecubic> i see _!, but it doesn't... do
15:37:01 * hiptobecubic squints
15:39:26 <startling> hiptobecubic, it can't be a lens
15:40:17 <hiptobecubic> let whatbouthtis i = to (!! i) in [1,2,3] ^. whatabouthis 1
15:40:19 <hiptobecubic> > let whatbouthtis i = to (!! i) in [1,2,3] ^. whatabouthis 1
15:40:21 <lambdabot>   Not in scope: `to'Not in scope: `whatabouthis'Not in scope: `^.'
15:40:26 <hiptobecubic> hmph
15:40:52 <startling> it can be a Traversal, though, I think.
15:42:26 <hiptobecubic> i just want to avoid _tail . _tail . _tail . _head
15:43:51 <fmap> hiptobecubic: `element'
15:45:01 <beaky> http://ideone.com/jFApKh is this liftM2 or is it actually different?
15:45:41 <hpc> > liftM2 f g h x
15:45:42 <lambdabot>   Ambiguous type variable `a1' in the constraints:
15:45:42 <lambdabot>    `GHC.Show.Show a1'
15:45:43 <lambdabot>     ...
15:45:49 <hpc> > liftM2 f g h x :: Expr
15:45:50 <lambdabot>   Ambiguous type variable `a1' in the constraints:
15:45:50 <lambdabot>    `SimpleReflect.FromExpr...
15:45:57 <hpc> :(
15:46:19 <startling> beaky: haha
15:46:51 <startling> beaky: that's on from Data.Function
15:46:54 <stobix> hm. Is there a standard function which does something in the lines of runFIfMaybeIsAJustElseReturnDefault f maybe default ?
15:47:02 <beaky> @src liftM2
15:47:02 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:47:09 <hpc> > liftM2 (&&) (< 3) (> 5) 0
15:47:10 <lambdabot>   False
15:47:18 <hpc> beaky: yeah, it's liftM2
15:47:22 <rwbarton> @type maybe
15:47:23 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:47:28 <rwbarton> stobix: ^
15:47:36 <rwbarton> if i read that monstrosity correctly
15:47:36 <hpc> startling: it's not on
15:47:41 <startling> > ((+) `on` head) [1, 2] [3, 4]
15:47:42 <lambdabot>   4
15:47:43 <hpc> :t on
15:47:44 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
15:48:01 <startling> oh, it takes different unary functions
15:48:04 <hpc> startling: on takes two values, a binary and a single unary function
15:48:12 <startling> right, right
15:48:14 <hpc> liftM2 takes two values, one binary, one unary func
15:48:18 <hpc> :P
15:48:24 <startling> > join liftM2
15:48:25 <lambdabot>   Overlapping instances for GHC.Show.Show
15:48:26 <lambdabot>                              (((a2 ...
15:48:28 <startling> :t join liftM2
15:48:30 <lambdabot> forall a2 r. ((a2 -> r) -> a2 -> r) -> ((a2 -> r) -> a2) -> (a2 -> r) -> r
15:48:39 <stobix> rwbarton: exactly. Is there a standard function :: (Maybe a -> b) -> Maybe a -> b -> b that works the way I said?
15:48:46 <hpc> :t \f g -> join (liftM2 f g)
15:48:47 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
15:48:47 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
15:48:47 <lambdabot>     In the first argument of `join', namely `(liftM2 f g)'
15:48:51 <hpc> noooo
15:49:09 <rwbarton> 'maybe' is it, except with arguments in a more sensible order and without that extraneous "Maybe" in the type of the function
15:49:27 <startling> :t \x y -> liftM2 y x x
15:49:28 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> (a1 -> a1 -> r) -> m r
15:49:34 <stobix> rwbarton: oh. nice.
15:49:37 <hpc> :t maybe
15:49:38 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:49:40 <startling> urgh. something like that
15:49:52 <strebe> stobix: http://book.realworldhaskell.org/read/monads.html
15:50:27 <startling> :t \x -> liftM2 x x
15:50:28 <lambdabot> forall a2 r. ((a2 -> r) -> a2 -> r) -> ((a2 -> r) -> a2) -> (a2 -> r) -> r
15:50:55 <startling> okay, I give up
15:51:02 <startling> @src on
15:51:03 <lambdabot> (*) `on` f = \x y -> f x * f y
15:56:26 <startling> :t \a b c d e -> c (a d) (b e)
15:56:27 <lambdabot> forall t t1 t2 t3 t4. (t -> t2) -> (t1 -> t3) -> (t2 -> t3 -> t4) -> t -> t1 -> t4
15:56:36 <startling> :t liftM2
15:56:37 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:57:24 <startling> :t \a b c d e -> a (b d) (c e)
15:57:25 <lambdabot> forall t t1 t2 t3 t4. (t2 -> t3 -> t4) -> (t -> t2) -> (t1 -> t3) -> t -> t1 -> t4
15:57:31 <startling> there we go.
15:58:37 <strebe> Hm. Something I'm running into a lot is wanting to be able to explicitly deal with an incrementing index as well as the data in a list at the same time. At the moment, I'm tending to work around this using zip, rather than explicitly writing out recursive functions, but I'm wondering if I'm missing an obvious way to write things more cleanly. Here's an example:
15:58:40 <strebe> triangles = 1 : [x + y | (x, y) <- zip triangles [2..]]
16:03:22 <Nereid> triangles = 1 : zipWith (+) triangles
16:03:26 <Nereid> er
16:03:27 <Nereid> [2..]
16:04:02 <hiptobecubic> fmap, thanks
16:04:08 <Nereid> triangles = scanl (+) 1 [2..]
16:04:14 <Nereid> > scanl (+) 1 [2..]
16:04:16 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
16:04:21 <Nereid> strebe: ^
16:04:53 <strebe> ahh, time to start using scanl... thank you :-)
16:05:37 <Nereid> strebe: also zipWith.
16:06:13 <strebe> I use zipWith occasionally, but yeah, it should have come to mind and didn't - I got a bit stuck in "hm. I can't reasonably express this with fold or map..."
16:07:07 <strebe> It's the downside of trying to rewire basic idioms while tired :-)
16:07:50 <Nereid> scanl is like foldl but collects the intermediate results in a list.
16:07:59 <Nereid> so foldl f z l = last (scanl f z l)
16:08:13 <hpc> :t scanl
16:08:14 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:08:32 <hpc> Nereid: except when productivity is involved ;)
16:08:45 <Nereid> ?
16:08:51 <hpc> when l is infinite and f is productive, you can't get last of the scan
16:08:57 <hpc> but... you said foldl
16:08:58 <Nereid> and foldl doesn't terminate
16:08:59 <Nereid> :p
16:08:59 * hpc shuts up
16:09:43 <strebe> Nereid: yes, I just reread the relevant bit of the prelude; thank you
16:10:58 <Nereid> > let f = 0 : scanl (+) 1 f in f
16:11:00 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
16:18:45 <beaky> can't wait to get my hands on Microsoft Windows 8 Professional Enterprise Ultimate Edition(r), and load up Microsoft Office Professional Enterprise Edition v. 15.0
16:18:55 <beaky> oops wrong channel
16:20:27 <citizen93> lol
16:21:41 <agorist_> How are the frameworks for building web applications with haskell?
16:22:42 <typoclass> agorist_: i think the major options are yesod, happstack, and snap
16:23:05 <saiko-chriskun> that would be them
16:23:09 <sm> they're great. Also scotty
16:23:11 <stepcut> As the maintainer of Happstack, I recommend Happstack
16:23:19 <stepcut> though I was about to mention scotty as well
16:23:19 <saiko-chriskun> hehe :P
16:23:43 <stepcut> I've haven't used scotty yet.. but I intend to steal all the good ideas and add them to happstack :)
16:23:47 <saiko-chriskun> :)
16:23:50 <sm> I never hear anyone who has, but it's our sinatra..
16:24:16 <stepcut> shapr considered using it for his GSoC project. Not sure what made him change
16:24:31 <typoclass> sm: sinatra is a ruby thing, right?
16:24:43 <lispy> agorist_: the only one I've used is snap. I've been happy with it. I don't know if they added IPv6 support yet, but that was on odd omission.
16:24:48 <sm> yes, scotty is analogous in being extremely terse and simple
16:26:02 <stepcut> lispy: probably because the network library is (or was) broken in regards to IPv6 support. Specifically, the API changes depending on whether or not the system has IPv6 enabled and there is no way to depend on the version with ipv6 enabled
16:26:08 <stepcut> so you have to do crazy things
16:26:30 <stepcut> in Happstack we have template haskell code that inspects the constructors of some type that network exports and uses that to determine if ipv6 is available
16:26:47 <lispy> stepcut: yikes. I didn't know that.
16:26:53 <stepcut> we also have a variant of simpleHTTP that allows you to pass in an already initialized socket
16:27:18 <stepcut> tibbe asked on G+ how to deal with that sort of thing correctly, so perhaps it will get fixed some day (Or maybe it already is?)
16:27:29 <frelux> hi all! anyone know what the latest is with cross-compilation in ghc? (i.e. compiling for ARM/iPhone)? https://github.com/ghc-ios/ghc hasn't seen much activity lately
16:27:53 <stepcut> to be fair, I expect network is not the only library that has this fault.. and it became more apparent after cabal was invented
16:27:58 <tibbe> stepcut: fixed for some top-level data types, alas not ipv6 yet
16:28:19 <stepcut> tibbe: Do you plan to fix the IPv6 stuff eventually?
16:28:42 <stepcut> handling ipv6 is the only template haskell code in happstack-server :)
16:30:53 <stepcut> gotta run, bbl
16:31:48 <lispy> frelux: I don't know the state of it, but sometimes I hear a little buzz about it.
16:32:13 <lispy> frelux: most of the pieces are there. I get the impression it's mostly about finding a champion to keep it working and otherwise maintain it.
16:32:31 <lispy> frelux: I mean, maintaining that aspect of GHC (not maintaining ghc-ios)
16:34:48 <lispy> frelux: did you already find this? http://hackage.haskell.org/trac/ghc/wiki/CrossCompilation
16:36:24 <frelux> lispy: aha — yeah, I've gotten ghc-ios working before with some basic tests and it seemed to work great — I'm about to try getting a large project running on my iPad so I just wanted to be sure I was working with the latest progress : )
16:43:14 <lispy> frelux: fun. It would be interesting to hear your results.
16:45:20 <hpaste> abizern pasted “read and print” at http://hpaste.org/76786
16:45:23 <tibbe> stepcut: yes, just need some time
16:45:32 <tibbe> stepcut: to sort out the #ifdef mess that's there now
16:45:32 <abizern> Hello.
16:45:49 <abizern> I've just pasted a snippet from hpaste.
16:46:03 <abizern> When I run the snippet with this input
16:46:22 <geekosaur> :t readLn
16:46:23 <lambdabot> forall a. (Read a) => IO a
16:46:54 <hpaste> abizern pasted “read and print” at http://hpaste.org/76787
16:47:31 <abizern> I get [(),(),()] as the list line of output
16:48:07 <abizern> I assume it's got something to do with the return type of IO (), but I've no idea how prevent it.
16:48:35 <geekosaur> [(),(),()] is what you get from the mapM
16:48:45 <scooty-puff> you want mapM_
16:48:51 <geekosaur> (when you don;t care about the result of a monadic action you want mapM_)
16:49:02 <abizern> Do'h
16:49:15 <abizern> I get it, mapM_ throws away the result.
16:49:25 <rwbarton> your main actually has type IO [()]
16:49:29 <scooty-puff> :t void
16:49:31 <lambdabot> Not in scope: `void'
16:49:38 <scooty-puff> > import Data.Functor
16:49:40 <lambdabot>   <no location info>: parse error on input `import'
16:49:49 <scooty-puff> +m Data.Functor
16:49:51 <scooty-puff> ok i give
16:50:15 <abizern> thanks geekosaur, that makes it much clearer.
16:51:25 <scooty-puff> you can use void on other things, if you don't feel like _ <- action; though that is fewer characters than void $ action (i assume action is many actions)
16:51:38 <scooty-puff> void :: Functor m => m a -> m ()
16:51:39 <scooty-puff> if i remember correctly
16:52:10 <hpc> scooty-puff: i just do "action;"
16:52:19 <agorist_> So I'm ignorant, interested in learning programming and want to build scalable web applications. I was told in #scala that haskell is great for learning, scales better than scala and is easier to deploy create web apps in than many other frameworks for other languages. I was thinking think about learning node.js so as to start quickly building my ideas, but they made me feel node is that efficient and the best for learning so I'm h
16:52:25 <scooty-puff> "Warning: ..."
16:52:30 <hpc> (still on 7.4.1 though)
16:52:38 <scooty-puff> o
16:53:15 <hpc> agorist_: if you want to dive into webdev right away, check out happstack
16:53:37 <hpc> you probably want to learn the language first though, and the best tutorial out there right now is
16:53:40 <hpc> @where lyah
16:53:40 <lambdabot> http://www.learnyouahaskell.com/
16:53:42 <agorist_> Should I learn haskell over languages like  agda idris boomerang and erlang with learning programming and and building web applications right away? Why might one use the others?
16:53:59 <hpc> agda you definitely don't want
16:54:11 <scooty-puff> erlang might be, depending on what type of application you're thinking about
16:54:14 <hpc> agda and idris are both theorem provers at heart
16:54:14 <scooty-puff> but probably not..
16:54:17 <hpc> dunno what boomerang is
16:54:34 <hpc> erlang you likely don't want
16:54:49 <hpc> (if you wanted erlang, you would probably already know that you wanted it)
16:54:50 <agorist_> why probably not erlang?
16:55:01 <agorist_> sound true hpc
16:55:03 <hpc> erlang is focused more at distributed computing
16:55:25 <scooty-puff> would be cool to right a distributed mmo in it, but, well, cheaters, etc.
16:55:32 <scooty-puff> err, *write
16:55:55 <hpc> erlang you probably wouldn't do websites with
16:56:04 <hpc> but yeah, an MMO would be pretty close to what it's best at
16:56:17 <agorist_> I just see my app having lots of users, data on those users and users being able to customize queries... pretty data intensive. I just want it to be able to scale
16:56:19 * typoclass thinks erlang doesn't have a helpful type system, so it's unattractive to start with
16:57:12 <scooty-puff> it sounds like how the data is stored and queried may be more important than what is actually pulling it or handling the web page generation
16:57:36 <hpc> one attractive feature of haskell that you would like is the ability to write EDSLs very easily
16:57:42 <hpc> (embedded domain specific language)
16:58:03 <agorist_> you guys are so nice
16:58:03 <hpc> you're essentially writing a "sublanguage" library that is valid haskell
16:58:24 <hpc> so a 5-minute website might be written something like this:
16:58:41 <hpc> wrap before after mid = do {putStr before; mid; putStr after;}
16:58:48 <hpc> html = wrap "<html>" "</html>"
16:58:49 <hpc> ...
16:58:54 <hpc> document = do
16:58:56 <hpc>   doctype
16:58:58 <hpc>   html $ do
16:59:01 <agorist_> so is haskell good at utilizing mutiple processor core, is it up there in laguages that teach functional concepts, is it just the shit and I should learn it?
16:59:01 <hpc>     head $ do ...
16:59:05 <monochrom> intelligent design for scaling scales better. perhaps executing a well-designed plan (if you have one) is easier in haskell than in other languages, but don't take it to mean that any program you write in haskell scales
16:59:45 <adu> agorist_: you should learn Haskell because it will make you a better programmer, AND because it's the shit
17:00:02 <agorist_> won't any program in haskell scale, but maybe not as well as some other languages
17:00:03 <hpc> and most importantly, you should learn it because we tell you to ;)
17:00:11 <agorist_> adu Thanks!
17:00:20 <hpc> agorist_: no language can fix all bad code :P
17:00:35 <hpc> (nobody mention agda!)
17:00:36 <agorist_> you guys are making me feel all bubbly inside
17:00:54 <adu> but thinking about data the Haskell way made me realize how screwed up other datatypes are
17:00:57 <agorist_> I was about to start learning node.js but now I'm here in haskell
17:01:00 <monochrom> ok, but please don't foam in mouth...
17:01:01 <agorist_> where do I start!!!!!!!!!!!!!!!!
17:01:06 <hpc> @where lyah
17:01:06 <lambdabot> http://www.learnyouahaskell.com/
17:01:06 <agorist_> too late
17:01:19 <agorist_> aaah... that's what lyah means
17:01:29 <agorist_> so you mean I don't have to buy an expensive books to get started
17:01:34 <agorist_> that was always the fun part
17:01:36 <agorist_> jk lol
17:02:09 <rwbarton> agorist_: http://nostarch.com/lyah.htm
17:02:13 <monochrom> you can read it free. you can pay some money to buy (paper and ebook both available). I think even the latter isn't too expensive
17:02:46 <adu> agorist_: Haskell's datatypes are so pure
17:02:53 <agorist_> so the html is free... why would I buy the ebook?
17:02:56 <adu> for example: Haskell's data X = Y | Z vs, C's enum X { Y, Z }
17:03:28 <agorist_> well I don't know C... but you're making me horny
17:03:43 <Iceland_jack> agorist_: You can torrent just about any book, some people prefer owning the books or paying their dues to the author
17:04:04 <adu> but to do "data X = Y y1 y2 | Z z1 z2" in C you'd need 3 structs and 1 enum
17:05:45 <tac> @djinn a -> ()
17:05:46 <lambdabot> f _ = ()
17:05:59 <tac> @djinn (( () -> a) -> a) -> a
17:05:59 <lambdabot> -- f cannot be realized.
17:07:34 <tac> @type const
17:07:35 <lambdabot> forall a b. a -> b -> a
17:08:07 <jfischoff> is there a snap chat room on irc?
17:08:09 <agorist_> so basically.. I can conquer the world with haskell
17:08:50 <startling> agorist_: basically
17:09:07 <Ferdirand> @faq can you conquer the world with haskell ?
17:09:07 <lambdabot> The answer is: Yes! Haskell can do that.
17:09:30 <parcs`> jfischoff: #snapframework
17:09:34 <agorist_> Seriously guys... what is better than haskell? ANYTHING????? What competes?
17:09:50 <tac> agorist_: Better is a funny word
17:09:53 <tac> What are you optimizing for?
17:10:12 <tac> If you want to conquer the world, try Agda :P
17:10:16 <jfischoff> parcs`: thanks
17:10:29 <agorist_> haskell vs agda?
17:10:32 <agorist_> FIGHT!
17:10:48 <tac> Agda always finishes a fight (unless you do --set-in-set or something)
17:12:19 <monochrom> agda proves that you may conquer the world
17:13:48 <tac> (in recent news, monochrom discovered Agda's new RealWorld# extension allows you to prove bottom)
17:13:49 <tac> :P
17:13:56 <Twey> Ha
17:14:14 <agorist_> so why is agda better at conquering the world and never loses a fight?
17:14:45 <Twey> Dependent types.
17:14:50 <agorist_> soaking cucumbers in lemon and dill make the best healthiest pickles #betterThanVinegar
17:15:09 <agorist_> so why are we all in haskell and not #Agda?
17:15:22 <tac> Because no one ever runs Agda programs
17:15:24 <tac> They only compile them
17:15:34 <monochrom> because I haven't learned agda
17:15:35 <tac> Like monks in a monestary
17:16:19 <agorist_> so qhat are haskell's competitors for learning functional programming and creating scalable web apps?
17:16:19 <tac> They ponder the deeper questions about the universe, detached from the practical needs of men
17:16:46 <tac> For example, I'm trying to figure out how many inhabitants there are in the type Exists X. (X -> X) * X
17:17:44 <tac> The answer is either 1 or an infinity. But I think I've come to doubt my intuitions.
17:17:50 <Twey> tac: X^X × X
17:18:19 <agorist_> what is Exists X?
17:18:36 <tac> It is the existential binder for types.
17:18:43 <tac> http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt explains it in the middle
17:18:45 <agorist_> What are haskell's competitors for learning functional programming and creating scalable web apps?
17:18:46 <Twey> agorist_: It's a pair of a type and a value in that type
17:19:02 <Twey> Scala and Clojure are popular too.
17:19:08 <tac> So perhaps it would be 1 witness for every type X in your system
17:20:05 <Twey> tac: But that's quite trivially infinity if you have anything like vectors around.
17:20:06 <agorist_> twey agda is not suited to scalable web applications? what about idris, boomerang or something else?
17:20:48 <typoclass> agorist_: possibly scala, although i hear it's more chaotic
17:20:51 <Iceland_jack> agorist_: Agda for scalable web applications?
17:20:56 <Iceland_jack> Not at all
17:21:13 <Twey> agorist_: Agda is not really used for practical applications much.  It's designed primarily as a proof assistant (you learn/prove things by having its type-checker check your assertions for you, rather than building running programs).
17:21:31 <typoclass> agorist_: and yes, clojure, but that doesn't have types, so you'll automatically have a hard time (imho)
17:21:37 <agorist_> I just came from scala... I looking for that pure functional shit to get me that high of learning legit skillz that killz
17:21:40 <Twey> agorist_: Idris aims to be usable for that sort of thing.  It's pretty new, but there might be some support by now; ask edwinb, maybe.
17:22:20 <agorist_> so is haskell just the best? good trade offs, best community?
17:22:32 <agorist_> great at scaling?
17:22:37 <tac> Haskell is the effective core of the functional programming community.
17:22:59 <agorist_> Tac... you have a career in sales
17:22:59 <tac> it's very fully featured, pretty mature, kinda heavy-weight
17:23:00 <Iceland_jack> agorist_: Do yourself a favour and stop such black-and-white thinking
17:23:01 <agorist_> you sold me
17:23:40 <tac> I work for Marketing at my company
17:24:06 <agorist_> Iceland_jack I don't normally. I'm just on my wits end of doing ignorant research now and just want to start learning and coding
17:24:18 <agorist_> love you iceland_jack <3
17:24:20 <Twey> agorist_: Go and LYAH then
17:24:22 <agorist_> thanks for all the help guys
17:24:28 <Iceland_jack> If you want to learn functional programming with types, Haskell is the way to go
17:24:34 <agorist_> what is a type?
17:24:55 <tac> Twey: Do you really think there are an infinite number of inhabitants? You can't actually observe that fact, I don't believe, under the definition of Exists X. T given by Wadler (in the link above)
17:25:04 <typoclass> agorist_: (hint: you want types. they make programming easier.)
17:25:16 <Lutin`> Any good c++ers in here? I know it's not ##c++ but I like you guys better
17:25:20 <Iceland_jack> (hint: #haskell might be biased) ;)
17:25:34 <hpc> Lutin`: ask in -blah
17:25:47 <Lutin`> k
17:25:53 <agorist_> Question of my life: Do I want types or not not not?
17:25:57 <hpaste> “Jonathan Fischoff” pasted “link error” at http://hpaste.org/76788
17:26:04 <jfischoff> getting an odd link error with ghc 7.0.3 ^
17:26:31 <agorist_> anymore research and I'm going to suicide. I need you guys to dictate my immediate programming future
17:26:37 <jfischoff> any ideas?
17:26:42 <agorist_> I need emotional and immediate technical feedback
17:27:07 <Iceland_jack> Don't mention suicide so frivolously
17:27:32 <agorist_> I wont; don't want to give others ideas
17:27:42 <agorist_> but I wont
17:27:52 <agorist_> because I love you guys too much
17:29:45 <sshaginyan> I love you too man
17:44:59 <Entroacceptor> agorist_: I don't feel like reading the backlog, but I feel sure giving commands. What are your choices again?
17:45:15 <Entroacceptor> and what do you know already?
17:46:40 <pordan30> is there an accepted solution to the "precision problem," in which the shape of a type too closely reflects the shape of data, when using open functions and data?
17:48:00 <agorist_> I ignorant with very limited java/scala/js experience. I want to learn programming, functional I believe because it's elegant and I've heard it's great for utilizing all processor cores.. not sure how guru I want to get though.I want to apply my knowledge to make to make scalable, data intensive user queryable web applications.
17:48:13 <agorist_> entroacceptor
17:48:51 <Iceland_jack> agorist_: Start reading Learn You a Haskell
17:50:04 <agorist_> I was told over in #scala haskell might be for me. I was thinking about doing node.js because I thought I would be able to deploy things more quickly especially considering I'm unemployed. But I was made to node is a joke. So Ias of an hour ago I've started learning haskell
17:50:22 <dmwit> agorist_: Write an IRC bot. Solve Sudoku. Create a ray tracer. Work through Project Euler. Reimplement Haskell in Haskell.
17:50:22 <agorist_> but I was just wondering what might be it's competitors in the functional scalable web app realm
17:50:45 <agorist_> Iceland_jack I have! Thanks for all your help
17:50:47 <Ralith> dmwit: bit of a jump in difficulty there :P
17:50:50 <Iceland_jack> Stop worrying about finding the best thing to learn and just learn..
17:50:54 <pordan30> agorist_: the haskell website has lots of introductory material here: <http://www.haskell.org/haskellwiki/Learning_Haskell>
17:50:56 <Entroacceptor> what Iceland_jack said
17:50:56 <scooty-puff> @pl \ a b -> const b
17:50:57 <lambdabot> const const
17:51:10 <dmwit> Ralith: Okay, reimplement the untyped lambda calculus in Haskell.
17:51:12 <Entroacceptor> haskell is a whole new world compared to java
17:51:21 <agorist_> I agree.. I have... Hiphip!
17:51:24 <agorist_> HURAAAAAY!
17:51:28 <agorist_> HIPHIP
17:51:31 <Entroacceptor> it's like learning to speak a foreign language or learning how to program for the first time again
17:51:33 <agorist_> HURAAAAAAAAAAAY!
17:51:41 <Entroacceptor> but it's a worthwile experience
17:51:53 <Entroacceptor> just don't expect to make it into $$$ right away :)
17:52:10 <Entroacceptor> for that I'd suggest typoscript, ruby or php ;)
17:52:16 <Ralith> dmwit: that's better ^^
17:52:21 <agorist_> and just as long as I can make scalable web apps I'm happy. Was just curious about it's competitors though, doesn't seem that many and any probably doesn't have as good a community as you guys #awwww
17:52:45 <dmwit> Ralith: ...at the type level.
17:52:52 <pordan30> agorist_: i believe that yesod is popular for web development in haskell, although i don't use it: <http://www.yesodweb.com/>. apparently there's a book from o'reilly on developing web applications using yesod in haskell: <http://www.yesodweb.com/book>
17:52:54 <Entroacceptor> for scalable web apps ruby is ok, it just scales in  a weird way :)
17:52:58 <Ralith> dmwit: >.<
17:53:11 <Entroacceptor> and for haskell there's snap, yesod and happstack
17:53:15 <Entroacceptor> they all work
17:53:57 <d_m> hey folks, if i want to install ghc and other haskell stuff on osx, do people recommend the "haskell platform for mac osx"?
17:54:04 <d_m> or am i better off installing via fink or something else?
17:54:21 <agorist_> when you say don't expect it to make in the money do you just mean that there's less haskell in industry? what if I started writing the application myself, are you implying haskell talent out there is so dry it would be diffuculty developing my app?
17:54:39 <agorist_> entroacceptor
17:56:08 <Entroacceptor> I don't know much about the industry, especially for haskell programmers
17:56:47 <Entroacceptor> but I got a job administrating a typo3 site with minimal knowledge, but I don't think I could sell myself as a haskell programmer
17:56:53 <Entroacceptor> (and keep the job)
17:57:17 <agorist_> so why don't you think I'll make it in the money more slowly than php, ruby, etc.
17:57:21 <Entroacceptor> and I know there are tons of PHP jobs
17:57:26 <agorist_> and what are it's purely functional competitors?
17:57:50 <agorist_> I want to create my own haskell job, I'm sure it's tough, but I have a lifetime
17:58:04 <Entroacceptor> well then, go for it
17:58:13 <Iceland_jack> Have you ever programmed in Haskell agorist_?
17:58:22 <agorist_> no... just a little scala
17:58:34 <Iceland_jack> And you want to create your own Haskell job?
17:58:41 <agorist_> yes
17:58:42 <Entroacceptor> my command is this: go and learn Haskell, write a small tool in it, a small website and a medium web app
17:59:00 <Iceland_jack> I don't even know what to say to that
17:59:08 <Entroacceptor> after that come back to the gurus in #haskell and tell them if you're worthy, you will know by then ;)
17:59:16 <otters> @pl \a b -> (fromIntegral a, fromIntegral b)
17:59:16 <lambdabot> (. fromIntegral) . (,) . fromIntegral
17:59:18 <agorist_> thanks Iceland_jack
17:59:49 <Iceland_jack> No thank you agorist_
17:59:53 <Iceland_jack> For how long have you known about Haskell?
18:00:01 <Entroacceptor> I know of some people here who wanted to make web apps in Haskell, but to make money they threw together some ruby apps firs
18:00:04 <Entroacceptor> t
18:01:08 <agorist_> I just want to learn good principles and I've been led to believe that haskell is efficient at implementing ideas and it's feasible to build web applications with? Is it ludocris to think I might be able to initiate a web app and with the help of others help it grow ad be successful.
18:01:40 <Iceland_jack> Are you familiar with the concept of ‘baby steps’?
18:03:13 <agorist_> what do you suggest I do? use node.js for web apps, go back to imperative programming? I learned some functional principles in scala and wrote some simple apps. But I want to learn something that will aid my critical thinking skill and make me a good programmer. I think haskell might be the tool for the job
18:03:23 <agorist_> Iceland_jack
18:03:42 <tac> Iceland_jack: Please be courteous to newcomers.
18:04:05 <Iceland_jack> I will keep it in mind.
18:04:13 <tac> thanks
18:04:23 <Iceland_jack> agorist_: Try programming in Haskell, then ask here again.
18:04:54 <tac> Yes. agorist_, I would save any kind of web programming until you've done console programming
18:05:24 <tac> Even if you've done web programming before in the past, Haskell makes working with even basics IO weird relative to what you're used to
18:05:59 <agorist_> thanks tac, thanks iceland_jack .. if you've made me think about anything it's that takling new beasts of purley functional programming and deploying ideas into production is not easy... and you just motivate me more to do it
18:06:00 <tac> If you're gung-ho to do web development, though, Yesod seems to be the best-supported web platform.
18:06:06 <Iceland_jack> I personally cannot grasp having made plans about a language one has never used before
18:06:06 <agorist_> tac what you mean console programming
18:06:42 <tac> agorist_: http://en.wikipedia.org/wiki/Command_line_interface
18:06:43 <frio> tac: i'd personally recommend scotty as a starting web framework
18:06:43 <agorist_> I don't have plans. I have an idea for an application. I want it to be scalable, and I want to learn functional programming.
18:06:50 <frio> yesod is big and has lots to learn in it
18:06:51 <zeiris> Are you trying to learn different awesome programming mindsets, or run a business here?
18:07:02 <agorist_> both
18:07:05 <tac> frio: I've never heard of it. And yeah. Yesod is not an easy nut to crack for a beginner.
18:07:05 <Entroacceptor> happstack is pretty easy to get into
18:07:16 <zeiris> CloudHaskell has awesome ideas for anything "web", due to tackling parallelism. Although it may be a bit immature for some beginners.
18:07:20 <frio> scotty's nice tac -- it's a sinatra-alike
18:07:31 <frio> so your whole thing can basically be
18:07:37 <frio> main :: scotty $ do
18:07:47 <frio>     get "/your/url/:here" $ do
18:07:53 <frio>         html $ someFunc
18:08:06 <tac> that looks pretty dainty. I might try it out myself :)
18:08:07 <zeiris> Web generally equals embarassing parallelism and distribution, which I really like cloudhaskell + whatever that recent re-make's approach for.
18:08:38 <frio> https://github.com/xich/scotty (it's in cabal too!)
18:08:45 <frio> (hackage, i should say)
18:09:08 <agorist_> Please guys.. what's so impossible about putting things into to production with haskell? Is it the lack of talent out there? Or are you assuming my mind will not fully grasp purley functional concepts and I am more suited to a language with more imperative conepts?
18:09:23 <frio> agorist_: putting stuff into production is hard anyway
18:09:37 <frio> haskell will, for a long time, present some significant stumbling blocks
18:09:47 <frio> it's a noble goal and one it's absolutely worth shooting for
18:09:56 <frio> all we're saying is take a breath, and learn to walk before you try to run :)
18:09:56 <Iceland_jack> agorist_: I think the only objection people raised was your inexperience with the language
18:10:09 <agorist_> I'm brand new
18:10:34 <beekor> as a beginner, i'll say yeah, it's a bitch at times.
18:11:07 <beekor> i'd say more. but that's all im qualified for currently.
18:11:10 <zeiris> Many things deemed "production" are copy-pasted together out of PHP and javascript examples off google. Which works well, and doesn't require learning anything :p
18:11:32 <zeiris> Haskell doesn't let you copy-paste examples off of Google, but excels at solving actual problems that require thought.
18:11:35 <frio> beekor: i can write software in haskell now, but i'd still consider myself a beginner
18:11:45 <frio> it's got a steep curve, that just keeps on going :(
18:11:47 <agorist_> not just to haskell, but I'm new to all other languages as well. I've haven't really learned a whole laguage well. Only SOME java, SOME scala, SOME php, SOME javascript... I want to settle down... learn a language and a web framwork to try and make something of my ideas. I AM inexperienced. But I feel belittled for for trying to accomplish this.
18:12:25 <Iceland_jack> agorist_: Then why are you not programming in Haskell instead of talking about wanting to? :)
18:12:28 <zeiris> Trying lots of different ones is a great way to get started - you're on a great path. It keeps your mind from over-focusing, and getting stuck in a valley. :)
18:12:59 <agorist_> Thanks GUYS!
18:13:04 <agorist_> I already torrented the book
18:13:13 <agorist_> I'm on my way!
18:13:15 <Iceland_jack> The book is available online
18:13:23 <Iceland_jack> if you're talking about LYAH
18:13:29 <agorist_> I got that open too
18:14:05 <agorist_> the only reason I came back here because someone was mentioning they would give me a great recommendation
18:14:35 <beekor> there is a wikibooks haskell book that I like.
18:14:51 <agorist_> so I was just wondering what are good highly/purley functional languages compared to haskell for developing webapps
18:15:01 <frio> i still like RWH, although i understand it's fallen a little out of fashion these days
18:15:20 <startling> agorist_, maybe racket or ml? I think haskell is the most widely used though
18:15:26 <startling> oh, do you mean frontend stuff?
18:15:34 <Iceland_jack> Didn't someone answer this question?
18:15:34 <Iceland_jack> 00:18 < agorist_> What are haskell's competitors for learning functional programming and creating scalable web apps?
18:15:38 <Iceland_jack> 00:18 < Twey> agorist_: It's a pair of a type and a value in that type
18:15:40 <Iceland_jack> 00:18 < Twey> Scala and Clojure are popular too.
18:15:44 <frio> agorist_: erlang is technically functional, although it doesn't enforce purity or use static typing like haskell
18:15:53 <frio> and erlang's webmachine framework is quite awesome
18:16:01 <startling> oh yeah, clojure and scala. clojure isn't very much like haskell, though
18:16:07 <frio> i really like clojure too
18:16:12 <lispy> and lemmamachine in Agda
18:16:14 <Nereid> clojure is more lisp-like, no?
18:16:14 <agorist_> Iceland_jack they're not as functional though, from my limited knowledge
18:16:16 <startling> a big part of haskell's awesomeness is the static typing
18:16:22 <startling> Nereid: it's a lisp, yeah
18:16:23 <pordan30> curry really pushes web programming too, but it probably isn't ready for "production-level" stuff
18:16:24 <frio> ive been meaning to try that lispy
18:16:26 <Iceland_jack> agorist_: they're not pure but they are functional
18:16:29 <otters> for bytestrings, is breakOn n str = (take n str, drop n str) slow?
18:16:45 <frio> well, try/ogle and think "my that's pretty" before slinking back to python
18:16:54 <startling> otters, you're iterating twice
18:16:57 <agorist_> startling yes, I want functional backend (educational and efficiency purposes) to easily link to a pretty front end
18:17:04 <otters> startling: that's what I was asking
18:17:05 <otters> what should I do
18:17:16 <lispy> https://github.com/larrytheliquid/Lemmachine <-- webapp framework in Agda. Yes, Agda.
18:17:42 <frio> agorist_: what do you actually want to make?
18:17:43 <Iceland_jack> lispy: (they might think you're making an actual suggestion to learn Agda for production stuff)
18:17:49 <agorist_> iceland_jack but is there any really advantage in their web frameworks? From the advice I've been given thus far not really, not enough to lose the benefits of learning haskell
18:18:01 <frio> you're picking your tools before you pick a project
18:18:05 <startling> otters: breakOn 0 str = ("", str) and then recurse to there
18:18:12 <lispy> Iceland_jack: Maybe I am?
18:18:15 <Iceland_jack> heh..
18:18:23 * lispy isn't sure
18:18:30 <Iceland_jack> Well now I'm worried
18:18:57 * lispy goes back to his copy of Real-World Agda, ;)
18:19:08 <startling> is that a book?
18:19:11 <Iceland_jack> haha, I'd love that copy lispy
18:19:20 <Iceland_jack> I have an exam on Agda tomorrow
18:19:33 <frio> looking at the source lispy, oh god the unicode
18:19:43 <startling> maybe I should try agda again. I actually grok emacs now.
18:19:56 <startling> frio, it comes with an emacs-mode specifically for that
18:20:00 <startling> hilariously
18:20:05 <frio> hahahahaha
18:20:08 <frio> well, that's a good thing
18:20:16 <frio> it's very pretty but im imagining tearing my keyboard in two already
18:20:22 <lispy> startling: write your own and then play with Agda: http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
18:20:29 <Iceland_jack> The Agda Wiki includes a .Xcompose file
18:20:45 <Iceland_jack> I think uploaded by Guilhem
18:21:07 <startling> lispy: neat!
18:21:24 <startling> is there a decent compiler yet?
18:21:47 <lispy> startling: that paper has scaffolding code available to implement a ghci style read-eval-print loop
18:21:56 * hackagebot timeplot 1.0.13 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.13 (EugeneKirpichov)
18:21:58 * hackagebot timeplot 1.0.14 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.14 (EugeneKirpichov)
18:22:02 <agorist_> is ogle a programming language?
18:22:04 <lispy> startling: just go up one level: http://www.andres-loeh.de/LambdaPi
18:22:45 <lispy> startling: I started with that paper and now I'm taking a diversion into type schemes to make a higher-order logic
18:22:46 <agorist_> so competitors to haskell for learning functional and deploying web apps might be lemmamachine in Agda and ogle?
18:22:53 <startling> lispy: heh
18:23:02 <startling> agorist_: no. there's no real competitors
18:23:03 <Iceland_jack> agorist_: Agda is *not* a competitor to Haskell
18:23:04 <lispy> startling: I plan to go back to the lambda pi paper and then explore the DTLC branch
18:23:13 <startling> it's largely unexplored terrain.
18:23:37 <startling> scala maybe, but as I understand a good portion of its usefulness is integration with java.
18:23:38 <agorist_> startling what's unexplored? agda
18:23:40 <startling> clojure, too.
18:23:51 <startling> agorist_, function web applications.
18:23:52 <agorist_> ok
18:23:59 <startling> *functional
18:24:04 <agorist_> thanks guys
18:24:32 <agorist_> I have used a little scala, but I think I'm going to go with haskell because I feel it's a great educational tool
18:24:49 <agorist_> and equally good at producing web apps as the scala/clojure frameworks
18:24:55 <pordan30> Can I use type families to uncurry the definition of fold here <http://hpaste.org/76790>. I think I should be able to use the class trick for variadic functions, but i'm pretty unclear of the execution.
18:25:53 <agorist_> Thanks startling iceland_jack ! lispy ! everyone for helping me.. you I really appreciate all your help!
18:26:01 <pordan30> (like, say - recursively generate the left hand side of a function type by feeding it the tuple arguments, and have the rhs be the return type of the fold?)
18:26:33 <pordan30> *curry, not uncurry
18:28:13 <startling> how do I get into theorem-proving with agda?
18:28:34 <Iceland_jack> http://www.cse.chalmers.se/edu/course/DAT140_Types/ you can check this page out
18:28:58 <Iceland_jack> http://www.cse.chalmers.se/edu/course/DAT140_Types/PropositionalLogic.agda this is a simple start
18:29:30 <startling> Iceland_jack: thanks!
18:29:44 <Iceland_jack> no problem :) you can always join #agda but it's not super active
18:29:59 <startling> I can see using it similar to how I use haskell, but I'm curious how I get to theorem-proving from there.
18:30:09 <jmcarthur> very quickly
18:30:25 <Iceland_jack> Agda is closer to programming though,
18:30:41 <startling> data âŠ¤ : Set where ...
18:30:41 <Iceland_jack>   if you want to get into more serious theorem proving I'd look at Coq
18:30:42 <startling> :S
18:30:45 <pordan30> some people might disagree, but if you aren't proving theorems the proof of which follows the shape of your data, agda might not be the best choice
18:30:49 <Iceland_jack> startling: (set your encoding)
18:31:00 <otters> startling: it's bytestring, so I can't uncons
18:31:15 <startling> otters, oh, right
18:31:31 <startling> doesn't it have folds though?
18:31:48 <otters> owait
18:32:11 <otters> yeah, it does
18:32:44 <startling> yeah, use those then.
18:33:52 <otters> wouldn't that end up evaluating the whole string
18:34:47 <startling> sure?
18:35:11 <otters> oh wait, of course it wouldn't
18:35:14 <startling> It wouldn't magically force a lazy bytestring, though
18:39:55 <jmcarthur> was this project abandoned? http://www.cs.berkeley.edu/~megacz/garrows/using.html
18:40:14 <Cale> pordan30: Of course, some people might say that there aren't any proofs which don't (at least in some sense) follow the shape of your data :)
18:45:17 <pordan30> Cale: True. However, the parenthetical betrays the practical point. :)
18:50:23 <ski> jmcarthur : hm, sounds perhaps similar to MetaML/MetaOCaml ..
18:52:28 <ski> hm, the way they use the environment classifier similarly to `s' in `ST s' is interesting
18:54:08 <jmcarthur> i'm tired of arr always getting in my way, and i heard about this project maybe a year ago and was excited at the time
18:55:01 <ski> `GuestLanguageBool' at <http://www.cs.berkeley.edu/~megacz/garrows/regex.hs> sounds strange, how can they say `<[ true ]>       :: <[ Bool ]>@c' as a method signature for `GuestLanguageBool c' ?
18:57:51 <jmcarthur> i'm not sure i see the problem with it
18:58:39 <jmcarthur> it probably desugars to something that would look like     true :: c () Bool   with a normal Arrow, no?
18:59:21 <jmcarthur> i'm not actually sure what the <[ true ]> bit desugars to
19:03:59 * ski doesn't see either where arrows enter the picture here
19:05:40 <jmcarthur> ski: http://www.cs.berkeley.edu/~megacz/garrows/
19:06:37 <jmcarthur> ski: it's just Arrow without arr, basically
19:06:54 <ski> interesting
19:07:03 <jmcarthur> but with a choice of methods that is convenient for that lambda desugaring
19:09:28 <ski> i wonder if the new compiler pass mentioned is an extra pass for (a thus modified variant of) GHC
19:13:16 <jmcarthur> ski: it is
19:14:08 <otters> say I want to convert a byte array to a double
19:14:53 <otters> where the byte array is [Word8]
19:14:57 <jmcarthur> I want to convert a byte array to a double
19:15:11 <otters> what do I do
19:15:55 <jmcarthur> when you says "where the byte array is [Word8], do you mean you are holding a normal haskell list of Word8s?
19:15:58 <jmcarthur> *say
19:16:03 <otters> yeah
19:17:53 <jmcarthur> otters: i think i would do some research first, but my gut reaction would be to look into writing the Word8s to an STUArray, then using Data.Array.Unsafe.castSTUArray and reading a Double out of it
19:18:03 <jmcarthur> things like byte order and stuff would make me hesitate though
19:18:28 <rwbarton> how about using Storable
19:18:34 <jmcarthur> that would also work
19:18:46 <rwbarton> maybe binary also but I think it might use its own goofy format
19:18:49 <gwern> https://news.ycombinator.com/item?id=4700160 pretty cool how many pandoc users there are
19:18:52 <rwbarton> (you never told us what format you intended btw)
19:19:11 <rwbarton> byteArrayToDouble [a,b,c,d,e,f,g,h] = fromIntegral a
19:19:13 <otters> heh well I'm trying to translate a program that's written in C
19:19:32 <otters> where there's some char buf[8] = { ... }
19:19:41 <otters> and then double s = *(double *)buf
19:19:53 <rwbarton> I see
19:20:16 <otters> I'm not really sure
19:20:36 <otters> sizeof(double) is 8
19:20:58 <geekosaur> depending on what exactly you;re doing with that stuff, you may want the binary or cereal packages
19:21:01 <rwbarton> @hoogle [a] -> (Ptr a -> IO b) -> IO b
19:21:02 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
19:21:02 <lambdabot> Foreign.Marshal.Array withArray0 :: Storable a => a -> [a] -> (Ptr a -> IO b) -> IO b
19:21:02 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
19:21:16 <otters> in this example, "/G9)<\6d@" translates to 160.195
19:21:18 <rwbarton> withArray xs $ \p -> peek (castPtr p :: Ptr Double)
19:23:12 <otters> wow, that did it
19:23:19 <otters> I hope it's cross platform
19:23:32 <rwbarton> well it should be equally cross platform as your C program :P
19:23:49 <otters> no idea about that one, I didn't write it
19:38:03 <tShamanoid> hello
19:38:23 <tShamanoid> guys i am having a problem with a non-exhaustive pattern error
19:39:38 <hpaste> tShamanoid pasted “Non-exhaustive error” at http://hpaste.org/76794
19:40:47 <ski> tShamanoid : `null (i:is)' is always `False'
19:41:01 <rwbarton> you should use pattern matching instead of all those guards
19:41:41 <rwbarton> (but this is not directly related to your error)
19:41:55 <tShamanoid> i would love to, it is just guards fit better with the algorithms i write on paper
19:42:12 <rwbarton> split string [] p output = output
19:42:21 <rwbarton> split string (i:is) p [] = ...
19:42:22 <rwbarton> ...
19:42:34 <tShamanoid> ?
19:42:40 <rwbarton> "?"?
19:43:07 <tShamanoid> i am really sorry. i don''t see my mitake
19:43:10 <rwbarton> this is just a very direct translation of the guards into pattern matching while fixing your error in the process
19:43:12 <tShamanoid> mistake*
19:43:19 <rwbarton> the mistake is you match on (i:is)
19:43:24 <rwbarton> never consider the case where that parameter is empty
19:44:16 <rwbarton> split string (i:is) p output | ... -- doesn't matter what guards you write, this will never match split string [] p output
19:44:23 <rwbarton> because (i:is) is a list with at least one element
19:44:23 <tShamanoid> it is just from what i've been googling about this error,most people found solutions by catching more situations = adding more guards
19:44:55 <tShamanoid> ohhh i see
19:45:26 <tShamanoid> so you think i should use    split string xs p output
19:45:40 <rwbarton> well, that is one way to fix it
19:45:41 <tShamanoid> and then use a where clause at the end to define the componenets of the list?
19:45:53 <rwbarton> what i think you should do is what i told you to do before, use pattern matching :)
19:45:54 <guidj0s> Any stylistic suggestions for https://gist.github.com/3950427 ?
19:46:13 <rwbarton> since all your guards can easily be expressed as pattern matches
19:46:13 <tShamanoid> alright thank you very much
19:46:30 <rwbarton> if you have things like "... | odd i = ...", then the guard is unavoidable
19:46:31 <tShamanoid> i will try to do it and see if i face any problems
19:46:41 <tShamanoid> i see
19:47:03 <tShamanoid> null can be expressed as an empty list? right?
19:47:07 <tShamanoid> null xs
19:47:20 <guidj0s> tShamanoid: xs == [].
19:47:26 <ski> guidj0s : instead of `null',`head',`tail', you too should use pattern-matching
19:47:39 <rwbarton> Pattern matching hour!
19:48:01 <rwbarton> exercise: rewrite each other's programs using pattern matching
19:48:05 <ski> tShamanoid,guidj0s : `null xs' is strictly better than `xs == []', but pattern-matching `xs' on `[]' is even better
19:48:08 <tShamanoid> hahahahah
19:48:28 <tShamanoid> is it a performance-wise advantage?
19:48:30 <guidj0s> ski: I wanted to avoid repeating the function name.
19:49:33 <rwbarton> try it the other way and see what you think
19:49:34 <ski> if you insist on that, then use `case ... of ...' for pattern-matching
19:49:41 <rwbarton> here you are repeating the name 'list' many times instead
19:49:54 <ski> (but i think multiple defining equations would be more readable)
19:50:25 <ski> guidj0s : instead of using `fst' and `snd', you should match the `restSearch' argument with a pair pattern directly
19:51:20 <guidj0s> ski: Oh, seems like that would be a lot better.
19:51:25 <ski> guidj0s : note that `delete' only removes a single occurance from the list -- perhaps you assume the lists don't contain duplicates, in which case this wouldn't be a problem
19:51:47 <guidj0s> ski: Yeah -- insertion doesn't duplicate either.
19:52:07 <ski> (yes, i noticed)
19:52:39 <ski> `search' is also badly in need of pattern-matching
19:53:40 <lightquake> is there ay interesting difference between Reader t a and t -> a?
19:53:40 <tShamanoid> guys how can you pattern match a guard that says | length xs == 1
19:53:55 <lightquake> tShamanoid: f [x] = ...
19:54:12 <tShamanoid> lightquake: thank you :D
19:54:29 <lightquake> also, if i stack monad transformers, does the order make a difference?
19:54:37 <rwbarton> lightquake, in general, yes
19:54:47 <ski> guidj0s : and `elt : (h : tt)' could be written as `elt : h : tt', no brackets needed
19:54:47 <rwbarton> but not always
19:55:26 <ski> @unmtl StateT s (WriterT w m) a
19:55:26 <lambdabot> s -> m (a, s, w)
19:55:38 <ski> @unmtl WriterT w (StateT s m) a
19:55:38 <lambdabot> s -> m (a, w, s)
19:55:46 <ski> those are basically the same, e.g.
19:55:49 <lightquake> yeah
19:56:03 <ski> but try using `ContT o' instead, e.g.
19:56:13 <guidj0s> ski: reWrap notIt (result, rest) = (result, notIt : rest)
19:56:18 <guidj0s> Is this what you had in mind?
19:56:23 <ski> yes, better
19:56:27 <guidj0s> Indeed.
19:56:33 <rwbarton> @unmtl MaybeT (Writer T w m) a
19:56:33 <lambdabot> Plugin `unmtl' failed with: `(w, T)' is not a type function.
19:56:36 <rwbarton> @unmtl MaybeT (WriterT w m) a
19:56:37 <lambdabot> m (Maybe a, w)
19:56:38 <guidj0s> I'll try and work on search.
19:56:44 <rwbarton> @unmtl WriterT w (MaybeT m) a
19:56:44 <lambdabot> m (Maybe (a, w))
19:56:56 <rwbarton> ^ different
19:57:02 <lightquake> interesting
19:57:04 * ski nods gravely
19:57:48 <hpaste> tShamanoid pasted “New with Pattern Matching” at http://hpaste.org/76796
19:57:50 <ski> in the first case, even if there's an "exception" (`Nothing' generated), the previous log `w' is not lost
19:57:55 <ski> in the latter case, it is lost
19:58:14 <lightquake> @unmtl MaybeT m a
19:58:14 <lambdabot> m (Maybe a)
19:58:29 <tShamanoid> guys what do you think of the pattern matched one
19:58:29 <lightquake> @unmtl WriterT w m a
19:58:29 <lambdabot> m (a, w)
19:58:39 <guidj0s> ski: for search, Would I have to match (x:y:ys), and then care for (x:xs) and _ separately?
19:58:41 <rwbarton> tShamanoid: yes exactly, much better
19:58:42 <tShamanoid> are there any more additions i can do to make it better
19:58:47 <ski> tShamanoid : next time, please *annotate* the original paste with updates, using the "Annotate" button
19:58:55 <tShamanoid> rwbarton: thank you very much, you were a great help
19:59:11 <tShamanoid> ski: sorry, i didn't know you can do that
19:59:21 <ski> now you know :)
19:59:25 <ski> guidj0s : `x:y:ys' would be one case yes
19:59:56 <guidj0s> ski: My concern are the other two, and whether they'd be necessary to cover all cases.
20:02:15 <lightquake> the context of all this is: right now I'm thinking about how to do AI design in this game I'm sort-of working on. my idea was for each entity to have an aiUpdate function that's something like StateT StdGen (Reader World) [EntityAction]
20:03:01 <ski> tShamanoid : ok, looks a little bit better now -- still, the left-nested `++' calls in the `output' accumulator looks bad
20:03:32 <tShamanoid> ski: can you kindly suggest a way to make it better?
20:04:26 <ski> guidj0s : well, in the `null list' case, you'd instead get `[]', not `_'
20:04:51 <ski> guidj0s : and in the `null t' case, you'd get  `x:[]', which is the same as `[x]', not `x:xs'
20:05:21 <guidj0s> But i'd need the two additional equations, correct?
20:05:34 <ski> guidj0s : and these three would be exhaustive, covering all cases, since a list is either empty, or has one element, or has at least two elements
20:05:53 <ski> guidj0s : that, or a `case list of ...' with three branches, yes
20:06:14 <ski> tShamanoid : pondering it
20:06:16 <guidj0s> ski: Good. Thanks for all the advice ;-)
20:06:43 <rwbarton> it looks like you can just un-tail-recursion it
20:06:54 <ski> tShamanoid : i'm wondering in which cases `output' can be empty
20:07:11 <ski> rwbarton : yeah, i'm hoping for it
20:08:08 <ski> hm, right, the `output' accumulator is only ever added to
20:08:36 <rwbarton> i'm not sure though
20:08:59 <ski> and judging from the comment "If this is First Instantiation", that will only happen on first call to `split' (from somewhere else, setting the accumulator to `[]')
20:09:12 <ski> but perhaps in some other case, zero elements are added to `output' ?
20:09:14 <tShamanoid> ski: output should be empty if the string doesnt contain any dots
20:09:36 <tShamanoid> ski: i've removed this pattern, i noticed it is useless
20:09:43 <ski> which ?
20:09:54 <tShamanoid> ski: actually no hold on, that isn't the one
20:10:12 <tShamanoid> ski: i removed the patter at line 9
20:10:39 <rwbarton> line 10?
20:10:55 <tShamanoid> yup
20:11:11 <parcs`> wat
20:11:14 <tShamanoid> p is supposed to be (p+1)
20:11:23 <YayMe> Anybody around willing to help a newb try to define a specific monad? This may already exist; I can't figure out how to implement a monad that will effectively be like Thingy v (v -> v) and I want bind to just compose each function so at a later point you can pass v to the function and it will pass through all the compositions
20:11:23 <parcs`> compare the size of source tarball in http://www.haskell.org/ghc/download_ghc_7_4_1#sources and http://www.haskell.org/ghc/download_ghc_7_6_1#sources
20:11:29 <ski> tShamanoid : *oh*
20:11:30 <tShamanoid> with this change, it becomes the exact same as the one below it
20:11:33 <ski> right
20:11:48 <shachaf> rwbarton: Is http://hpaste.org/76732 still relevant?
20:11:52 <ski> (or rather, it becomes an *instance*, a special case, of it)
20:11:55 <roconnor> edwardk: ping
20:11:57 <rwbarton> shachaf, sure
20:12:01 <rwbarton> haven't played with it since yesterday
20:12:11 <edwardk> heya
20:12:13 <YayMe> something like (Thingy v e) >>= f = Thingy v (e . f) but that doesn't work because f is (a -> Thingy v b) so is no good
20:12:39 <tShamanoid> ski: the one starting at line 13 will eventually collide with the same instance
20:12:39 <rwbarton> parcs`: interesting
20:12:47 <tShamanoid> ski: and it will do the exact same thing
20:12:55 <roconnor> edwardk: I seem to recall you saying (in a talk) that your company replaced a whole bunch of mutable crap in Scala with lenses and things got better.
20:13:20 <ski> tShamanoid : assuming you replace `drop p' by `drop (p+1)' in the former one, yes
20:13:32 <ski> YayMe : how is `Thingy' defined ?
20:13:35 <roconnor> edwardk: was this mutable crap multithreaded full of locks and race-conditions.
20:13:39 <roconnor> s/./?
20:13:42 <rwbarton> i guess the idea would be to prove "split string is p output = output ++ split' string is p" for some split'
20:13:45 <lightquake> parcs`: wat indeed
20:14:02 <elliott> edwardk: for a partial lens with control.lens you'd want a traversal, right?
20:14:16 <edwardk> elliott: correct. or a projection
20:14:17 <ski> rwbarton : yes
20:14:22 <YayMe> ski: Thingy v (v -> v) but that's just a guess, the goal is a value, and a function that can act on that value, so you can then compose a bunch of other functions onto it through bind
20:14:25 <elliott> edwardk: right
20:14:28 <tShamanoid> ski: yeh, that is the case
20:14:30 <elliott> edwardk: I think I am getting the hang of this library :)
20:14:35 <ski> YayMe : that's not a data type definition
20:14:50 <rwbarton> then "split string (i:is) p output = split string is i (output ++ [drop (p+1) (take (i+1) string)]) = output ++ [drop (p+1) (take (i+1) string)] ++ split' string is i" so "split' string (i:is) p = [drop (p+1) (take (i+1) string)] ++ split' string is i"
20:14:52 <tShamanoid> ski: may i ask, what exactly is pondering?
20:15:05 <parcs`> 81M     x86_64-w64-mingw32-gcc-4.6.3-release-win64_rubenvb.tar.bz2
20:15:06 <YayMe> ski: No? It seemed to work...
20:15:32 <rwbarton> @wn pondering
20:15:34 <lambdabot> *** "pondering" wn "WordNet (r) 3.0 (2006)"
20:15:36 <lambdabot> pondering
20:15:38 <lambdabot>     adj 1: deeply or seriously thoughtful; "Byron lives on not only
20:15:40 <lambdabot>            in his poetry, but also in his creation of the 'Byronic
20:15:42 <lambdabot>            hero' - the persona of a brooding melancholy young man";
20:15:44 <lambdabot> [3 @more lines]
20:15:49 <tShamanoid> yes
20:15:49 <edwardk> roconnor: hrmm, trying to remember the issue in question. we do use lenses. we had a project that flattened a bunch of data out to database rows, it wasn't particularly lock heavy, but it did have issues with the fact that the code used scala's ephemeral streams which don't memoize and effectively go call-by-name.
20:15:58 <elliott> edwardk: one thing I wonder about the zippers is if there would be some way to relax the Simple constraint on down/within/fromWithin... like you can do (zipper myHashMap % fromWithin traverse) but not (zipper myHashMap % fromWithin HM.traverseWithKey)... where you'd be able to read the key and value but only write the value back
20:16:01 <edwardk> elliott: good =)
20:16:19 <ski> YayMe : i can't say yea or nay, until you tell me how `Thingy' is defined
20:16:24 <roconnor> edwardk: interesting.  ok.
20:16:46 <YayMe> ski: That was the definition I used.. data Thingy v = Thingy v (v -> v)
20:16:59 <edwardk> the problem with empowering the traversal to change types is two-fold. you need to visit every element of the traversal, and you can't come back up until you change it, so you can't dip down and back up
20:17:01 <YayMe> it compiled
20:17:08 <ski> YayMe : ty, now this is a valid definition
20:17:16 <aa_> hi everyone, I am pretty much a newbie, but I need to generate some data types and functions from a serialized schema. Basically, template haskell, right?
20:17:16 <elliott> edwardk: mm
20:17:17 <sordina> Hey Haskellers.
20:17:24 <edwardk> er three-fold, because there isn't a good notation for the breadcrumb type, either.
20:17:24 <elliott> edwardk: I would be ok if it was just partial
20:17:29 <tShamanoid> rwbarton: actually i am trying to split a list of strings into a list of list strings seperated by dots
20:17:34 <edwardk> probably not =P
20:17:37 <elliott> edwardk: i.e. (c -> f d) -> a -> f a or such
20:17:43 <ski> YayMe : so, why did you say "f is (a -> Thingy v b)" ? according to that definition, `Thingy v b' is an invalid type
20:17:45 <tShamanoid> rwbarton: That is, every entry in the list ends with a dot
20:17:50 <elliott> so that the overall type can't change but the element types can -- would that make sense?
20:17:53 <sordina> I might be missing something, but is there a way to autocomplete the methods from the module loaded as if it were an imported module?
20:17:53 <YayMe> ski: does this idea of a monad I'm talking about make sense?
20:17:54 <elliott> then you'd set c = (k,v), d = v
20:17:58 <edwardk> that is pretty hideous though, because you need to change all the targets still
20:18:03 <elliott> right :(
20:18:10 <edwardk> i can't pass the unused 'c's as 'd's
20:18:11 <elliott> it seems like it would be really nice for zippering around maps though
20:18:18 <YayMe> ski: Here, I'll do an hpaste in a moment
20:18:28 <ski> YayMe : not as stated no, since `Thingy' is not covariant
20:18:31 <sordina> Like >ghci Poly.hs , import Poly , Poly.<tab>
20:18:35 <elliott> edwardk: I guess you'd need a "default" (c -> d) along with it or something?
20:18:39 <edwardk> i spent a couple days trying to beat that into a usable API
20:18:44 <YayMe> ski: Covariant?
20:18:48 <ski> YayMe : perhaps some modification of it, that still expresses the idea you wanted, would work, though
20:18:50 <edwardk> i gave up in the end, all the variants don't feel right
20:18:59 <elliott> mm
20:19:09 <ski> YayMe : it's impossible to define `fmap :: (a -> b) -> Thingy a -> Thingy b'
20:19:31 <ski> if `Thingy' is to be a monad, it must be possible to define that (all monads are functors)
20:19:34 <YayMe> ski: Oh, covariant is a term for functor?
20:19:47 <ski> rather : "functor" is short for "covariant functor"
20:20:20 <YayMe> ski: learn something new every day, thanks :)
20:20:21 <ski> (there are also "contravariant functors", which are different .. but your `Thingy' is neither covariant nor contravariant (and monads must be covariant functors, anyway))
20:20:54 <ski> YayMe : these concepts "covariant" and "contravariant" also turn up in object-oriented programming (subtyping), in case you're interested
20:21:16 <elliott> edwardk: hm, just now I realise the function I wanted to get added to Data.Map to support an efficient lens implementation for them that wasn't dependent on any particular lens library is in fact the control.lens version :)
20:21:41 <shachaf> rwbarton: If I split that file into two files, one which defines the data type and the conversion functions and another which defines rangeMap and uses it, and compile the former with -O2 and the latter with -O0, it works.
20:21:50 <elliott> (it was something like (Applicative f) => ((k, a) -> f a) -> f (Map k a) -> f (Map k a) iirc)
20:22:12 <shachaf> rwbarton: So maybe the optimizer is messing with the data definition in some way that's exported through the .hi file? Since Data.Map is compiled with -O2, presumably.
20:23:22 <YayMe> ski: Yeah, I've heard "covariant" and "contravariant" referred to as additional features of .net 4 regarding generics being able to follow inheritance I believe
20:24:30 <edwardk> elliott: *nods*
20:24:36 <astor> I'm trying to make the IO monad modular, and I'm stuck on implementing Monad m => m a -> IO a.  Shouldn't that be easy?
20:24:50 <dmwit> no?
20:24:53 <ski> YayMe : if `Foo' is covariant, then if `A' is a subtype of `B', then `Foo<A>' is a subtype of `Foo<B>'
20:24:58 <edwardk> elliott: i leave that untupled, and wrap it in a newtype, but its otherwise right ;)
20:25:02 <ski> YayMe : if `Foo' is contravariant, then if `A' is a subtype of `B', then `Foo<B>' is a subtype of `Foo<A>'
20:25:10 <dmwit> How do you expect to turn, say, an [a] into an IO a?
20:25:23 <acowley> edwardk: Do you have any suggestions as to how to write zipWith for the finite dimensional vector code?
20:25:27 <tShamanoid> guys, i read a file using readFile and ended up with IO String data, i made a lot of functions that manipulate Strings. How can i bridge between them
20:25:41 <ski> YayMe : compare the first one of these to `fmap :: (a -> b) -> (f a -> f b)' and the second to `cofmap :: (a -> b) -> (f b -> f a)'
20:25:45 <edwardk> acowley: hahaha you mean the roman version?
20:25:49 <acowley> edwardk: Yes
20:25:54 <dmwit> If you meant (forall m. Monad m => m a) -> IO a, then yes, that should be easy.
20:25:56 <dmwit> f x = x
20:25:59 <acowley> edwardk: I've been doing battle with it. It's been painful.
20:26:01 <elliott> edwardk: right, i just meant that fits the traversal type
20:26:02 <edwardk> acowley: i recall working it out bak when the post was first written and then promptly forgetting it
20:26:09 <elliott> traversal (k, a) a (Map k a) (Map k a)
20:26:12 <elliott> *Traversal
20:26:15 <elliott> (but of course it can be generalised further)
20:26:18 <edwardk> elliott: that isn't a legal traversal
20:26:23 <elliott> oh, hmm
20:26:26 <dmwit> :t id :: (forall m. Monad m => m a) -> IO a -- hmmm
20:26:28 <lambdabot> forall a. (forall (m :: * -> *). (Monad m) => m a) -> IO a
20:26:29 <elliott> stupid laws
20:26:32 <edwardk> (k, a) and a can't be instantiated to the same type
20:26:34 <dmwit> huh.
20:26:36 <edwardk> elliott: =P
20:26:42 <ski> astor : having `Monad m => m a -> IO a' would mean that `IO' in some sense contained every other monad -- i fail to see how `IO' could be modular then
20:26:46 <dmwit> I can't believe that works.
20:26:49 <edwardk> also i think you have the arg backwards ;)
20:26:53 <elliott> dmwit: ... why not?
20:27:09 <acowley> edwardk: The problem I have is that, fundamentally, the code treats a vector of dimension n as something that can feed a function of arity n. It feeds all vector elements to the function in sequence. So how to squeeze in a redirection to suck down an element from another vector?
20:27:23 <dmwit> elliott: Well, because that means it's trying to unify both (forall m. Monad m => m a) and (IO a) with a single unification variable.
20:27:26 <dmwit> ...and succeeding.
20:27:40 <elliott> right
20:27:41 <edwardk> acowley: iirc it took roman about 3 hours to work it out, so expect to beat your head against it a while ;)
20:27:46 <shachaf> Hmm, is there a nice way to look at the contents of .hi files?
20:27:47 <acowley> hah
20:27:57 <acowley> Well, I'm almost at 3 hours, and I'm not there yet
20:28:02 <elliott> shachaf: probably just vi
20:28:10 <acowley> I keep thinking I have an idea, then running aground before getting to the endzone
20:28:11 <ski> tShamanoid : also, please don't use `TAB's in Haskell source :)
20:28:20 <edwardk> heh, well, if you are still desperate when i return from vacation i'll try to rederive it ;)
20:28:30 <shachaf> elliott: Not much good. :-(
20:28:35 <acowley> I want a hint, not a solution! :)
20:28:43 <dmwit> elliott: I don't know, I mean, isn't it surprising to you that id can have a type whose argument and result are not syntactically identical (after type alias substitutions)?
20:28:44 <hpaste> YayMe pasted “thingy” at http://hpaste.org/76800
20:29:04 <tShamanoid> ski: i remember you gave me such an advise a long time ago
20:29:11 <elliott> dmwit: I think I've gotten things like that to work before, so I guess that's why I'm not so surprised
20:29:21 <tShamanoid> ski: i was trying to remember it but with n luck, thanks for reminding me
20:29:25 <nyc> I need not hear all parties save myself conflate column positions and spaces yet again.
20:30:28 <shachaf> elliott: Oh, ghc --show-iface
20:30:31 <YayMe> ski: I understand why it complains and why it won't type check, but what I can't figure out is how to do what I'm talking about.. I'll keep trying to think through it
20:30:32 <astor> The practial problem is that for example I want to create the class Monad m => MonadMVarIO which contains the MVar functions.  So I have withMVarIO :: MVar a -> (a -> m b) -> m b  instead of IO.  This again to make the code testable by mocking MVars for example.  But the (a -> m b) must be converted to (a -> IO b) for the MonadIO instance.
20:30:39 <shachaf> elliott: In fact there are options to diff ifaces and everything.
20:30:58 <elliott> shachaf: Well that's too fancy.
20:31:13 <elliott> astor: that is the monadcontrolio problem
20:31:17 <elliott> (does it have a better name than that?)
20:31:22 * dmwit high fives nyc
20:32:49 <tShamanoid> guys, i read a file using readFile and ended up with IO String data, i made a lot of functions that manipulate Strings. How can i bridge between them
20:33:34 <dmwit> acowley: maybe http://okmij.org/ftp/Algorithms.html#zip-folds ?
20:34:01 <acowley> dmwit: that looks super-promising, thanks!
20:34:51 <shachaf> rwbarton: Netcraft confirms it.
20:35:03 <dmwit> tShamanoid: fmap turns a (String -> a) into an (IO String -> IO a); (>>=) turns a (String -> IO a) into an (IO String -> IO a).
20:35:06 <shachaf> rwbarton: Some unpacking is going on only with the -O2.
20:35:26 <elliott> what is rwbarton trying to do?
20:35:26 <acowley> My heart flutters whenever Oleg says, "trivial."
20:35:40 <shachaf> elliott: Something that looks like a Data.Map but is secretly lazily loaded from disk.
20:35:48 <dmwit> trivial = I hope you have another three hours ;-)
20:36:28 <tShamanoid> dmwit: i need to turn an IO String into a normal String
20:36:37 <dmwit> tShamanoid: No you don't.
20:36:42 <elliott> shachaf: that sounds roughly approximating evil :(
20:37:04 <astor> but i
20:37:09 <shachaf> elliott: He wants to do even more evil things than that.
20:37:33 <elliott> edwardk: btw, I know that Lens a b -> Lens a c -> Lens a (b,c) isn't valid because the two lenses could overlap... is there some kind of "restricted" lens where they cannot overlap, e.g. enforced through a (presumably more "expressive" than haskell's) type system?
20:37:45 <elliott> shachaf: representing a network database as a Map or something?
20:37:49 <tShamanoid> dmwit: hahaah, yeh for some reason googling this always tells meit isn't possible
20:37:51 <shachaf> elliott: Like some kind of "GC" of the Map nodes, since you can always load them back from the compact disk representation.
20:38:01 <shachaf> elliott: No, I suspect that's too evil even for rwbarton.
20:38:02 <elliott> shachaf: but i had that idea too :/
20:38:02 <edwardk> you can use 'alongside' and a pair of isos
20:38:18 <elliott> tShamanoid: please read: http://www.haskell.org/haskellwiki/FAQ#How_do_I_convert_IO_Int_to_Int.3F
20:38:19 <dmwit> tShamanoid: Instead of turning an IO String into a String, turn the functions that are going to consume that String into functions that will consume an IO String (using the functions I suggested earlier).
20:38:25 <elliott> and the introduction it links
20:38:26 <edwardk> that is what mgsloan does with lenq iirc
20:38:55 <acowley> Have you defined betwixt yet?
20:39:05 <edwardk> alas, no
20:39:11 <edwardk> still no good use for lest either.
20:39:14 <elliott> edwardk: i guess that works
20:39:19 <elliott> still seems dissatisfying somehow
20:39:20 <acowley> Also, I want anon for concurrency
20:39:24 <edwardk> elliott: yep
20:39:29 <edwardk> acowley: heh
20:39:53 <edwardk> acowley: there are a couple of things in Control.Parallel.Strategies.Lens that i forget
20:40:10 <acowley> forsooth??!
20:40:18 <elliott> i guess you could express it dependently by having some kind of disjoint a b proof argument where a and b are the two lens functions, but I have no idea what disjoint would actually say about the lenses :)
20:40:18 <edwardk> after and throughout
20:40:28 <elliott> is there a wherefore yet
20:40:38 <edwardk> elliott: yeah, the problem is i can't figure out how to make that not suck terribly
20:40:46 <acowley> Proofs of disjointness are awful
20:40:47 <edwardk> especially when they an involve things like keys into maps, etc.
20:41:01 <edwardk> so for now i just ruled it out of scope
20:41:08 <astor> I was hoping to have a modular IO without having MonadIO as a constraint.  It would be better to be able to mock an MVar without touching IO.
20:41:46 <edwardk> if you want to mock io then make a class for the operations you want to use from io, make an instance of it for IO, then make a mock implementation of the same class
20:41:51 <elliott> edwardk: well i doubt it can be done nicely in haskell
20:42:03 <edwardk> elliott: exactly why i didn't do it ;)
20:42:12 <elliott> since the essential requirement is about the functions themselves which seems pretty solidly dependent territory
20:42:15 <edwardk> lens tries to hit a good power to weight ratio ;)
20:42:20 <elliott> but i don't even know what you'd want to require of the functions
20:42:37 <tShamanoid> dmwit: can you kindly clarify how i might be able to use those functions?
20:42:39 <elliott> i guess something about modifying with a not affecting b and vice versa
20:42:44 <astor> edwardk: that's what I am doing, but I made an instance for MonadIO m instead.
20:42:57 <edwardk> astor: bad idea
20:43:04 <edwardk> that instance now overlaps with ANY other possible instance
20:43:10 <dmwit> tShamanoid: I thought I was pretty clear. Can you tell me which bits you didn't understand?
20:43:11 <edwardk> you have to make the instances individually
20:43:20 <edwardk> it sucks, but thats what you need to do
20:43:23 <astor> edwardk: ok. thanks.
20:43:40 <edwardk> you can make the implementation easier by using DefaultSignatures and providing a default signature that leans on MonadIO
20:44:21 <edwardk> but you have to have an explicit instance line for each monad you want to work with if you also want any non-io instances to work _correctly_
20:44:40 <elliott> wasn't the problem that it won't work with monadio anyway
20:44:43 <elliott> since it involves callbacks
20:44:46 <edwardk> (i say correctly because overlapping instances will kinda sorta half-ass work unless you look at it cross-eyed)
20:44:58 <ski> tShamanoid : in the initial call to `split', what is `p' ?
20:45:07 <astor> elliott: I think that is my problem.
20:45:12 <tShamanoid> dmwit: Sorry i'm kinda newbie at haskell, i think i got i.
20:45:14 <YayMe> So Monadic types are to be covariant?
20:45:46 <dmwit> Monadic types can appear in contravariant positions in a type.
20:45:51 <astor> edwardk: can you see if that would work on for example withMVar?
20:45:54 <elliott> edwardk: pfft, acknowledging overlapping instances even exists
20:46:00 <tShamanoid> p should be initialized to 0
20:46:04 <elliott> astor: it wouldn't help but even if it would you don't want to do that
20:46:05 <tShamanoid> ski: p should be initialized to 0
20:46:48 <edwardk> astor: to deal with MVars i would make a class assoiciated type or type family that named the FooVar for whatever monad. and instantiate it to MVar for IO, and whatever else for your mocked monad
20:50:43 <astor> edwardk: ok, I can do that, but I wonder about your DefaultSignatures and "leaning on MonadIO".  Because I can't get MonadIO m => MVar a -> (a -> m b) -> m b  to match up with the signature for withMVar for example, because I need the (a -> m b) thing to become (a -> IO b).  I think you're all telling me that it isn't possible, but since you brought up "lean on MonadIO" for the default implementation, maybe there is a way?
20:51:20 <edwardk> MonadIO isn't going to be enough for that one
20:51:31 <edwardk> the user would have to supply a method all their own for that
20:51:56 <edwardk> i meant lean on it for most of the other mvar operations, you can provide defaultsignatures for most of them, just not all
20:52:05 <YayMe> ski: What exactly makes my Thingy not covariant?
20:52:07 <edwardk> withMVar will need some hand-holding ;)
20:53:07 <edwardk> YayMe: that sounds like variance-reassignment surgery. are you sure you want to go through with that? the social stigma associated with it outside of the haskell community is strong.
20:53:10 <astor> edwardk: so hold my hand will you :-) How should the user supply a method?
20:53:45 <elliott> astor: I really doubt you want MonadIO here.
20:53:47 <elliott> Why can't you just use IO?
20:53:55 <edwardk> put the signature in the class. make the instance for IO, make the instance for your mock later on if you can, and deal with the fact that you can't do it for MonadIO, but only some few monads
20:54:21 <edwardk> e.g. you can do it for ReaderT of something else that you can apply it to, but probably not state, etc.
20:54:35 <rwbarton> shachaf: only -O2, not even -O? or -O also
20:54:44 <shachaf> rwbarton: I didn't check -O
20:54:46 <rwbarton> okay
20:54:52 <rwbarton> good to know that the theory was correct
20:54:53 <shachaf> rwbarton: But it looks like it doesn't respect {-# UNPACK #-} with -O0
20:54:53 <YayMe> edwardk: I can't help it, I'm a variant trapped in an invariant body :(
20:54:55 <rwbarton> how did you confirm?
20:55:17 <shachaf> rwbarton: ghc --show-iface on a .hi with nothing but a data declaration, and later looking at the generated assembly.
20:55:24 <rwbarton> oh i think perhaps i had already confirmed that using TH's reify
20:55:33 <shachaf> (Though I might've gotten something wrong in the latter bit.)
20:55:38 <rwbarton> but yeah
20:55:38 <rwbarton> neat
20:56:05 <rwbarton> another weird thing I noticed is that reify can only show me unexported constructors when I build with -O (or -O2)
20:56:13 <rwbarton> build the "target module" so in this case Data/Map.hs
20:56:14 <edwardk> YayMe: Very well. I'm sure ski can counsel you through the transition. Just be careful about where you get the code changed. You don't want some hack job you'll regret for the rest of your life.
20:57:22 <astor> elliott, edwardk: thanks. I'll go back and wrestle with ghc a little more.
20:58:12 <shachaf> rwbarton: This seems extremely fragile.
20:58:44 <shachaf> rwbarton: Is there a strong reason you want people to be able to use Data.Map functions?
21:00:57 <ski> YayMe : you had
21:01:02 <ski>   data Thingy v = Thingy v (v -> v)
21:01:12 <ski>                             ^  -- this `v' occurs contravariantly in the body
21:01:23 <ski> the other two `v's occur covariantly
21:01:49 <ski> as a consequence, `Thingy v' itself is neither co- nor contra- variant in `v'
21:02:09 <YayMe> Right so Thingy v (v -> b) make any more sense?
21:02:21 <elliott> that is still neither co nor contra
21:02:32 <elliott> you have a v in a contravariant position (v -> b) and a v in a covariant position (v)
21:02:38 <elliott> v (b -> v) would be covariant, for instance
21:02:47 <shachaf> Can we call things that are neither covariant nor contravariant "ntravariant"?
21:02:49 <ski>   data Thingy s v = Thingy v (s -> v)
21:02:52 <ski> might make sense
21:02:56 <ski>   data Thingy s v = Thingy s (s -> v)
21:02:58 <ski> as well
21:03:07 <rwbarton> shachaf: well just because Data.Map is a popular data structure and it's fairly wasteful of space
21:03:08 <ski>   data Thingy v = forall s. Thingy s (s -> v) -- and this
21:03:10 <shachaf> data Thingy s v = Thingy s (s -> s)
21:03:36 <ski> and what shachaf said, trivially, since it is both covariant and contravariant in `v' (since it doesn't mention `v') :)
21:04:05 <elliott> rwbarton: isn't "GCing memory by putting it on disk and loading it later" the definition of swap
21:04:19 <rwbarton> the main goal here is to compress the data
21:04:26 <YayMe> ski: I think I get it..
21:04:44 <rwbarton> while retaining random access
21:04:50 <edwardk> data Thingy s v = Thingy s (s -> v) makes a very nice comonad, too
21:04:51 <ski> YayMe : perhaps you can explain what you wanted to express with `Thingy' ?
21:04:58 <rwbarton> and a transparent API
21:05:03 <elliott> edwardk: the thingy comonad
21:06:00 <ski> elliott : hm, didn't Matlab do that thing at some point in time ?
21:06:01 <edwardk> i'm sorry, but i don't know you well enough to help you extract anything from your Thingy or learn how to extend it.
21:06:14 <YayMe> ski: I want a value, and a function, each bind composes the right side of the bind to the function, at a later time you then can pass that value to that function which will be the composition of all the binds
21:06:35 <edwardk> that said, duplicating it would definitely raise eyebrows
21:06:35 <elliott> ski: which thing?
21:06:39 <shachaf> YayMe: All I wanted was a pony, and they call *me* crazy?
21:06:51 <ski> elliott : the "GCing memory by putting it on disk and loading it later" one
21:06:56 <elliott> quite possibly
21:07:01 <elliott> I know little about matlab
21:07:17 <YayMe> shachaf: I never claimed to know what I'm up to with haskell, this has been 4 months of spaghetti testing so far
21:07:37 <shachaf> elliott: The point is that GHC's in-memory representation of data is very expensive.
21:07:52 <shachaf> rwbarton: Your thing doesn't behave like a Data.Map in a lot of ways.
21:07:59 <rwbarton> oh? what thing
21:08:01 <shachaf> rwbarton: For example I assume that any inserts would break it horribly.
21:08:20 <shachaf> Well, maybe not...
21:08:48 <rwbarton> insertion is O(log n) so it can only touch the stuff it needs to
21:08:53 <rwbarton> within a constant factor
21:09:08 <rwbarton> so i will get a modified hybrid strict/lazy sort of thing
21:09:13 <shachaf> Right.
21:09:14 <rwbarton> but that's okay
21:09:21 <ski> YayMe : how about `data Thingy a = Return a | forall b. Bind (Thingy b) (b -> Thingy a)' ?
21:09:21 <shachaf> I guess that's what you want.
21:09:26 <rwbarton> of course if i want to repack that, that is a challenge perhaps
21:09:29 <rwbarton> to do it efficiently
21:09:48 <ski> YayMe : or possibly `data Thingy a = Return a | forall b. BindReturn b (b -> Thingy a)'
21:10:14 <rwbarton> but at least I can still use the modified one and I only pay the memory costs of the original packed format + the unpacked data structures representing my changes
21:10:23 <shachaf> Right.
21:10:47 <shachaf> I guess I was assuming that you want to repack it.
21:10:51 <elliott> rwbarton: wouldn't, like, patching ghc be easier than this or something
21:10:54 <YayMe> ski: I don't understand the forall in that context
21:10:56 <rwbarton> hehe
21:11:10 <YayMe> ski: I've only seen it in type signatures before
21:11:23 <shachaf> elliott: Patching GHC to do what?
21:11:48 <rwbarton> i believe i can do the repack using only maybe a factor of 2 extra space compared to the size of the result
21:12:10 <rwbarton> by traversing it lazily, as long as it can be gc'ed afterwards (which would be tricky to ensure)
21:12:38 <dibblego> koala_man: oy!
21:12:45 <elliott> shachaf: i have no idea
21:12:48 <elliott> this unsafeCoerce business
21:12:53 <koala_man> dibblego!!
21:13:22 <shachaf> rwbarton: It seems like a specialized API would be much less of a headache.
21:13:28 <shachaf> But maybe not.
21:13:33 <shachaf> What are you going to do with it?
21:13:53 <rwbarton> i forget specifically what :)
21:14:46 <rwbarton> but yeah, in the case of Data.Map I guess I could clone the whole module source, remove the strictness annotations and replace all the constructor applications by strict ones
21:14:49 <rwbarton> if that's what you mean?
21:14:59 <elliott> rwbarton: i thought you wanted "abi"-compatibility
21:15:15 <rwbarton> well I do want that
21:15:21 <rwbarton> but I might give up on it
21:15:37 <ski> YayMe : it's an "existential data type"
21:15:52 <astor> hmm.. it seems that I could solve this using TypeFamilies.  So MonadMVarIO m would have a type family CallbackMonad m :: * -> *, and then the signature of withMVarIO becomes: MVar a -> (a -> (CallbackMonad m) b) -> m b, and in the MonadIO instance, CallbackMonad m = IO.  Does this sound reasonable?
21:16:02 <shachaf> The way Data.Map means both "a specific data structure" and "any key-value mapping" is a bit annoying.
21:16:12 <shachaf> On the other hand, Haskell has another way to mean "a key-value mapping". :-)
21:16:25 <ski> YayMe : `BindReturn' is polymorphic, taking an argument of type `b', and one of type `b -> Thingy a', and constructing one of type `Thing a' -- note that `a' is not mentioned in the result type
21:17:34 <ski> YayMe : this means that if you have a value of type `Thingy Int' (e.g.), and match at against a pattern `BindReturn y f', then you know `y :: b' and `f :: b -> Thingy Int', but you have *no* idea what the type `b' here is -- it is some "secret" type which exists internally to the value
21:18:04 <rwbarton> shachaf: you mean a function?
21:18:15 <ski> the only thing you know here is that it's the *same* type `b' in `y :: b' and in `f :: b -> Thingy Int', iow you know you can pass `y' as argument to `f'
21:18:32 <shachaf> Yep.
21:19:03 <ski> YayMe : also, if you have two (possibly) different values of type `Thingy Int', you can't be sure that it's the *same* type `b' inside the one and the other, it could well be two different `b'-types
21:20:02 <ski> YayMe : an altnerative way of defining `Thingy', with the same result, is writing in GADT syntax, `data Thingy a where Return :: a -> Thingy a; BindReturn :: b -> (b -> Thingy a) -> Thingy a'
21:22:31 <rwbarton> shachaf: the headache I'm supposed to be avoiding by using my own API is the one of discovering the definition of Map and unsafeCoercing between my copy of it and the real one?
21:22:37 <rwbarton> or do you mean a more general headache
21:22:52 <shachaf> I meant that one.
21:22:55 <shachaf> Maybe it's not so huge.
21:22:58 <rwbarton> it's true this part to do with Data.Map specifically is not such a high priority
21:23:17 <rwbarton> but it's nice that it seems to be solvable (*fingers crossed*)
21:23:41 <rwbarton> but yeah, a user who doesn't like this black magic can just not use the instance Packable Map or whatever.
21:23:52 <shachaf> rwbarton: As far as I can tell it's perfectly valid of GHC to start optimizing by assuming tagged pointers for Map.
21:24:25 <rwbarton> I agree
21:28:03 <rwbarton> I'll just have to start using my "pointer into unmapped page with a page fault handler" trick ;)
21:29:15 <shachaf> rwbarton: That's sure to make your code portable across GHC versions!
21:29:22 <rwbarton> hehe
21:29:31 <rwbarton> what could go wrong??
21:30:53 <geekosaur> anyone got an original MC68000 running ghc? :)
21:31:04 <rwbarton> ha
21:32:09 <shachaf> «Those who remember the early days of workstations no doubt also remember the raft of "Dual Processor Motorola 68K" offerings. The reason they had two processors was that the original M68K handled a page fault incorrectly (it could not correctly restart the instruction that generated the fault). The only solution -- until the next rev chip was released -- was to add a SECOND chip, running the same code, so that on a page fault the system ...
21:32:15 <shachaf> ... switched to the OTHER chip. Hence, the ubiquitous "Dual Processor" claims. Another bug became a "feature".»
21:32:18 <shachaf> Hmm.
21:33:08 <rwbarton> oh, I just assumed they didn't have any form of virtual memory
21:34:00 <rwbarton> though I guess Mac OS classic did have swap
21:34:20 <geekosaur> virtual memory yes, demand paging no
21:49:42 <YayMe> ski: hmm, that doesn't quite sound like the intent, an example of usage would be like Thingy 3 id >>= (\x -> x+2 >>= (+5)) would result in a Thingy 3 (id . (\x -> x+2) . (+5))
21:50:38 <shachaf> That looks like a type error.
21:50:41 <YayMe> ski: and you could continue binding that to other functions that are Int -> Int in that particular case and each new function would be composed onto the other
21:51:37 <ion> I have a 68000 calculator and a 68060 computer.
21:52:05 <YayMe> shachaf: It probably is, which is why I'm trying to figure out how to accomplish that concept, I haven't yet figured out how as that way doesn't work
21:53:24 <YayMe> ski: The ways you were showing it sounded like would have applied the function to the value rather than just composing the functions to be used on the value later?
21:53:40 <rwbarton> how can you tell the difference?
21:55:12 <YayMe> rwbarton: Perhaps you can't? This was just a thought I had to try and put together, though it may be irrational to the point of unimplementable..
21:55:59 <ski> YayMe : what would be the use of `Thingy', except to finally pass the value to the function ?
21:56:40 <rwbarton> it's not so much unimplementable as it is not useful
21:56:41 <ski> (YayMe : and no, the ones i was thinking about before would not apply the function to the value prematurely)
21:57:15 <rwbarton> at least, as far as i can see
21:57:29 <YayMe> rwbarton: Aye perhaps so
21:57:47 <rwbarton> I think also that Monad isn't quite the interface that you want.
21:57:59 <rwbarton> as shachaf said, your example is a type error
21:58:06 <ski> hm, perhaps `data Thingy s a = MkThingy s (s -> a)' would work ..
21:58:06 <YayMe> rwbarton: Yeah I'm thinking the same
21:58:35 <ski> but we'd need something for `return'
21:58:40 <shachaf> YayMe: #haskell is so brainwashed that they won't even understand what you're trying to say when you provide code that's a type error.
21:58:57 <shachaf> They'll just sit there and stare at it, uncomprehending.
21:59:13 <ski> shachaf : surely if there's a type error, it's meaningless :)
21:59:20 <rwbarton> it looks more like you want a Functor
21:59:32 <shachaf> @quote SaulGorn
21:59:33 <lambdabot> SaulGorn says: A formalist is one who cannot understand a theory unless it is meaningless.
21:59:57 <ski> hehe, nice
22:02:17 <shachaf> Hmm, (\x -> x, "snd") is valid syntax.
22:06:12 <YayMe> alright time for me to hit the hay, I'll play with this more tomorrow and probably have more questions after work in how I might go about what I'm unsure I'm trying to do..
22:06:18 <YayMe> Thanks a lot ski, rwbarton
22:07:28 <dmj> Any osx users try to cabal install pcre-light-0.4? This regex library seems to be broke... mysql-simple depends on it. Any suggestions would be grand. (besides don't use osx)
22:10:35 <dmj> nm, i forgot to brew install the dependencies, seems to be working
22:11:58 <pharaun> Can I do IO inside a GConduit? in conduit?
22:12:58 * ivanm guesses you use liftIO
22:13:15 <dibblego> pharaun: is it an instance of MonadIO?
22:13:16 <rwbarton> if it's a GConduit built on m = IO
22:13:24 <rwbarton> then I should certainly hope so
22:13:28 <pharaun> dibblego: yeah its MonadIO
22:13:41 <dibblego> pharaun: liftIO :: IO a -> GConduit a
22:13:48 <pharaun> ah
22:15:18 <agorist_> what about lisp?
22:15:52 <agorist_> dibleggo what's up man!
22:16:01 <agorist_> dibblego what's up man!
22:16:22 <agorist_> I started learning haskell, what's up with lisp though?
22:17:58 <flonum> Is there a standard shorthand for [minBound .. maxBound] ?
22:18:53 <pharaun> dibblego: that did the trick, thanks that's what i was missing to get it to type check and run
22:20:24 <Ralith> agorist_: it has nice metaprogramming.
22:20:54 <agorist_> can't haskell do that meta shiznit also?
22:21:16 <agorist_> should I continue learning haskell because it's just the shizzle
22:23:51 <Nereid> flonum: [minBound..] works
22:24:07 <Nereid> agorist_: haskell and lisp a pretty different
22:24:09 <pharaun> agorist_: there's TH if its up your alley
22:24:13 <Nereid> are*
22:24:24 <agorist_> TH?
22:24:28 <Nereid> template haskell
22:24:38 <agorist_> which is better for making web apps?
22:25:13 <Nereid> I don't know what lisp has to offer, but you should try haskell ;)
22:25:39 <pharaun> Nereid: the whole s-expr and some of the macro and others seems nifty
22:25:47 <ParahSailin> agorist_, you in here because haskell is opposed to state?
22:25:51 <pharaun> but eh you can do lots of that via TH or qq anyway i suppose
22:25:52 <flonum> Nereid: yeah, I guess that's the best ... I was hoping there'd be something in a library like
22:25:52 <flonum> "enumeration :: (Enum a, Bounded a) => [a]" which is more elegant than explicit minBound
22:26:09 <flonum> thanks
22:26:09 <Nereid> flonum: write it! ;)
22:26:19 <flonum> yeah
22:26:42 <flonum> but I was hoping I could introduce a dependency on some graph library or something into my parser just to import it ...
22:26:47 <agorist_> ParahSailin I'm try to use haskell to crush the state
22:27:00 <flonum> ;)
22:27:02 <Nereid> haha
22:27:24 <lispy> At the risk of spamming people, important OpenGL api change: http://www.haskell.org/pipermail/hopengl/2012-October/001097.html
22:27:26 <pharaun> agorist_: state isn't always bad you know. Haskell does provide you with some nice tools to help you manage your state
22:28:14 <Nereid> haskell is all about controlling state, not doing away with it.
22:28:16 <Nereid> ;)
22:28:44 <agorist_> haha lol... I'm talking about the state that steals and locks people in cages
22:28:53 <Nereid> haha.
22:28:59 <ski> @quote no.state
22:28:59 <lambdabot> MonadState says: Do not try to change the state; that's impossible. Instead only try to realize the truth: There is no state.
22:30:10 <pharaun> you change the entire universe to hide the state from yourself :D
22:30:11 <agorist_> I don't even get how pure functional programming creates a state, but I only against the evil state
22:30:26 <pharaun> heh
22:30:45 <pharaun> there's mvar/ioref/tvar, then there's state/io/etc
22:30:52 <Nereid> State is the easiest one to understand.
22:30:55 <pharaun> and a few others that i'm probably forgetting
22:31:04 <Nereid> ST?
22:31:08 <agorist_> someone made a really funny joke about my name... because it is anti state, but I'm not against programming state lol
22:31:35 <pharaun> Nereid: the... free modify a region in ram thing? ah right that one yeah
22:31:39 <agorist_> anti state aka anti government
22:32:29 <shachaf> Any idea what's going on with http://hackage.haskell.org/package/regex-pcre-builtin ?
22:32:49 <shachaf> Looks like audreyt uploaded the most recent versions. Is the maintainer still maintaining?
22:33:04 <pharaun> and you could technically argue that if you externalize your state to a file and your program just takes the file and process it line by line and output a new file, then you run another program to do something else to the said file, your state is in the file :)
22:37:08 <agorist_> have you guys met any cute girls that are good at haskell?
22:38:58 <shachaf> Please stop trolling. :-)
22:38:59 <JoeyA> Does Foreign.Marshal.Alloc.alloca zero the memory?
22:39:09 <shachaf> JoeyA: I would assume not.
22:39:55 <agorist_> shachaf I'm not even trolling
22:40:02 <agorist_> maybe someone has
22:40:05 <shachaf> Is that like "not even wrong"?
22:40:30 <dmj> girls dont write haskell
22:40:41 <Ralith> everyone knows that!
22:40:44 <agorist_> ok ... has anyone met a cute female programmer (not even haskell)?
22:40:54 <dmj> they write in coffeescript or python
22:41:05 <agorist_> dmj... lol so true
22:41:20 <dmj> in my databases class there are cute girls
22:41:45 <dmj> its mysql though, not postgres...
22:41:51 <agorist_> have you tried any transactions with them
22:41:52 <shachaf> Y'all're off-topic.
22:47:06 <lispy> pharaun: STM is also about state management
22:47:29 <pharaun> yup
22:47:34 <pharaun> hence me listing it :)
22:47:37 <pharaun> (tvars)
22:47:42 <lispy> ah, sorry
22:47:46 <pharaun> heh np :)
22:47:59 <pharaun> i mean there's many many way to hide states and manage it
22:48:06 <lispy> definitely
22:48:11 <pharaun> could even just use a set of pipe/queue to stuff it in or whatever
22:48:28 <pordan30> can the variables on the lhs of a type family declaration be constrained by a type class? for instance, type family (C a) => T a :: *.
22:49:19 <shachaf> Wouldn't that be about as useful as datatype contexts?
22:52:07 <lispy> shachaf: possibly. But if it works (dunno if it does) hopefully the mistakes of the past haven't been repeated. But then, implicit constraints seem evil too.
22:52:17 <lispy> But but but.
22:52:24 <pordan30> well, the use would be to restrict the class of types over which T can be defined by restricting a, so that senseless instance declarations couldn't occur
22:55:45 <randomclown> @pl \(a,b) -> length (edges M.! a) > 1 && length (preds M.! b) > 1
22:55:45 <lambdabot> uncurry ((. ((> 1) . length . (preds M. !))) . (&&) . (> 1) . length . (edges M. !))
22:55:50 <randomclown> oh jesus
22:56:20 <randomclown> @pl \(a,b) -> length (edges M.! a) + length (preds M.! b) > 2
22:56:20 <lambdabot> uncurry (flip flip 2 . ((>) .) . (. (length . (preds M. !))) . (+) . length . (edges M. !))
22:59:18 <pharaun> hahaha pl is useless sometime :)
22:59:28 <pharaun> cos some of those pointfree are just >_<
22:59:55 <randomclown> @pl \(a,b) -> length (edges ! a) + length (preds ! b) > 2
22:59:55 <lambdabot> uncurry (flip flip 2 . ((>) .) . (. (length . (preds !))) . (+) . length . (edges !))
23:00:38 <pordan30> hmm, liftM2 (&&) (f preds . fst) (f edges . snd) where f g = (> 1) . f M.! ? or something
23:00:51 <pordan30> err g*, not f
23:01:59 <ski> s/sometime/mostly/
23:02:01 <flonum> pharaun: >< is pf as well ... (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
23:02:26 <flonum> Incidentally, why doesn't Haskell include these combinators for sums/products in Data.Tuple/Data.Either?
23:02:38 <ski> > ((^ 2) *** (^ 3)) (3,2)
23:02:40 <lambdabot>   (9,8)
23:02:54 <ski> > ((^ 2) *** (^ 3)) (3,2) :: (Expr,Expr)
23:02:55 <lambdabot>   (3 * 3,2 * 2 * 2)
23:03:01 <flonum> @pl \x -> (f x, g x)
23:03:01 <lambdabot> liftM2 (,) f g
23:03:14 <ski> aka `f &&& g'
23:03:36 <flonum> @pl \(f,g)->\(x,y) -> (f x,g y)
23:03:36 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
23:03:42 <randomclown> why are people now intentionally doing `this'?
23:04:04 * ski has been doing it for many years
23:04:07 <rking> randomclown: Why not?  It provides a nested way to quote.
23:04:13 <rking> Better is Unicode quotes, but that's close enough.
23:05:22 <ski> randomclown : fyi, the two things being greater than `1' isn't equivalent to the sum being greater than `2'
23:05:28 <tShamanoid> guys i want to remove all characters y who don't fall in the index range [x..y] of a specific string
23:05:38 <tShamanoid> what is the most efficient way to do this?
23:05:57 <shachaf> If you really care about efficiency you probably shouldn't be using String.
23:06:07 <shachaf> If you're using String, "filter" is probably enough.
23:06:26 <lispy> what is x?
23:06:27 <tShamanoid> i was tryign to do something like [y | y <- x, .....
23:06:42 <tShamanoid> x is a number, an Int to be specific
23:06:45 <lispy> > [y | y <- "abc" ]
23:06:46 <lambdabot>   "abc"
23:07:02 * hackagebot dbus 0.10.3 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.3 (JohnMillikin)
23:07:04 <lispy> in "y <- x" above, you need x to be a list
23:07:12 <pordan30> you will need to traverse the string, and then delete according to a range check, so the naive implementation would have linear assuming your range check is fine. that seems par for course for string operations
23:07:14 <tShamanoid> yup x is a string
23:07:27 * lispy thought x was an INt
23:07:52 <tShamanoid> actually i thought he was referring to the x in the range [x..y]
23:08:25 <lispy> oh, so [x .. y :: Int], but in [ y | y <- x ...], x is a list?
23:08:28 <ivanm> AllHailW3Schools: wait, I thought everyone hated W3 schools! :o
23:08:41 <tShamanoid> lispy: Exactly!
23:08:43 <AllHailW3Schools> ivanm, it is pretty shitty honestly.
23:08:45 <ivanm> lispy: if you want it to type-check... :p
23:08:55 <ivanm> AllHailW3Schools: so why are you hailing it?
23:08:58 <rwbarton> {-# LANGUAGE Overloadedx #-}
23:09:05 <AllHailW3Schools> I do in some cases uses it if I want a really quick reference if I don't remember something like order or arguments.
23:09:06 <ivanm> rwbarton: heh
23:09:24 <tShamanoid> lispy: i jsut chose random variables here,  in my code they are actually functions that return int
23:09:29 <AllHailW3Schools> ivanm, to toy with the XML Activity lead over at #xml. I'm trying to blackmail him into addopting me.
23:09:45 <lispy> tShamanoid: alpha renaming is your friend :)
23:09:49 <ivanm> why do you want to be adopted?  don't you like your parents? ;-)
23:10:18 <AllHailW3Schools> My mother doesn't understand XML and Haskell, he does.
23:10:20 <pordan30> tShamanoid: use a filter, e.g.: filter (not . inRange)
23:10:25 <lispy> tShamanoid: anyway...If you want to remove then from a change, then the list notation probably isn't so great unless you do something like pairing the elements with their index
23:10:35 <AllHailW3Schools> Also, my mother tries to get me to wear shoos, he encourages not wearing it.
23:10:46 <lispy> > zip "abc" [1..]
23:10:48 <lambdabot>   [('a',1),('b',2),('c',3)]
23:11:53 <lispy> > takeWhile (\x ->  length (snd x) < 2) (zip "abcdefg" [1..]
23:11:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
23:12:09 <lispy> > takeWhile (\x ->  length (snd x) < 2) (zip "abcdefg" [1..])
23:12:10 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
23:12:10 <lambdabot>    arising from a use...
23:12:11 <ivanm> does anyone know of an existing binary tree pretty-printing function?  If not I'll write one, but I would prefer a top-down approach rather than Data.Tree's left-to-right approach
23:12:15 <lispy> anyway, you get the idea
23:12:28 * lispy can't be bothered to fix his own type errors ;)
23:12:28 <tShamanoid> pordan30: thank you. I will give that a try
23:12:46 <ivanm> tShamanoid: by "in range", are you converting the Chars into an Int or something?
23:12:50 <shachaf> I just used "darcs send" and it told me "successfully sent patch bundle".
23:12:52 <ivanm> or are you using position in the String?
23:12:57 <shachaf> I don't have sending email set up on this machine.
23:13:01 <shachaf> Should I assume that it failed silently?
23:13:04 <lispy> shachaf: Isn't that awesome
23:13:09 <tShamanoid> ivanm: i am using position in a string
23:13:17 <shachaf> lispy: What, did it succeed somehow?
23:13:25 <ivanm> tShamanoid: yeah, as lispy said, that's probalby not the best way then
23:13:31 <lispy> shachaf: it's because programs like sendmail accept your message and since it was able to queue it successfully it returned exit status 0.
23:13:35 <tShamanoid> Lispy thank you for the awesome suggestions!
23:13:48 <shachaf> lispy: How do I just get a dpatch file that I can email dons?
23:13:50 <rwbarton> probably you will get a local unix mail message telling you that it was unable to deliver your email
23:13:51 <ivanm> unless you are indeed using a contiguous range, then use a combination of take, drop, splitAt, etc.
23:14:02 <tShamanoid> ivan: i have no other choice, i already have all my functions set
23:14:04 <shachaf> rwbarton: Oh, so I did.
23:14:09 <lispy> shachaf: darcs send -O
23:14:11 <ivanm> shachaf: darcs send -a ? it's been a while since I had to do that
23:14:48 <shachaf> lispy: Ah, thanks.
23:14:54 <shachaf> darcs's UI is so confusing.
23:14:59 <shachaf> Why can't it just be like git? :-)
23:15:07 <lispy> > takeWhile (\x -> (snd x) < 2) (zip "abcdefg" [1..])
23:15:09 <lambdabot>   [('a',1)]
23:15:18 <lispy> tShamanoid: Not sure why I had the length in there. I'm tired?
23:15:26 <ivanm> @slap shachaf
23:15:26 * lambdabot hits shachaf with a hammer, so they breaks into a thousand pieces
23:15:38 <rwbarton> they breaks?
23:15:41 <lispy> tShamanoid: and the suggestion to use filter would still work here.
23:15:53 <rwbarton> shachaf: someone should really fix lambdabot. i mean look at that
23:15:56 <ivanm> rwbarton: non-gender specific pronoun usage is my guess
23:16:04 <shachaf> rwbarton: I know, right?
23:16:06 <lispy> rwbarton: "they" as a genderless pronoun is good enough for facebook. Good enough for lambdabot.
23:16:06 <tShamanoid> Lispy: trust me, i haven't slept for 39 hours now and counting
23:16:14 <shachaf> rwbarton: I'm glad we have selfless volunteers like you.
23:16:40 <tShamanoid> lispy: i am starting to hallucinate :S Invisible bee that i can't find
23:17:01 <pordan30> ...so hen breaks into a thousand pieces?
23:17:09 <lispy> tShamanoid: I'm well acquianted with sleep deprevation. Please treat yourself better.
23:17:57 <tShamanoid> lispy: don't worry it is rare such a thing happens, i will keep your advice in mind
23:18:15 <lispy> tShamanoid: cheers
23:18:35 <tShamanoid> lispy: cheers :D
23:18:51 <lispy> On that note, I should go bed myself as it's late in $localtimezone
23:18:56 <lispy> @time lispy
23:18:59 <lambdabot> Local time for lispy is Thu Oct 25 23:18:35 2012
23:19:13 <ivanm> oh, is _that_ all?
23:19:23 <lispy> ivanm: you forget I'm an old man :)
23:19:31 <ivanm> @age lispy
23:19:31 <ivanm> :p
23:19:32 <lambdabot> Maybe you meant: arr ask
23:19:36 <ivanm> @arr
23:19:36 <lambdabot> I want me grog!
23:19:57 <ivanm> tShamanoid: you sure you're not suffering from tinnitus?
23:20:00 <ivanm> but yes, sleep is good
23:20:02 * lispy waves
23:20:05 <ivanm> definitely better than not sleep
23:20:07 <shachaf> lispy: Pft, I'm in the same time zone.
23:20:08 <ivanm> cya lispy
23:20:19 <ivanm> shachaf: yes, but are you as old a man as lispy?
23:20:20 <shachaf> I practically just woke up!
23:20:29 <shachaf> lispy: ♞
23:21:51 <ParahSailin> shachaf, damn you i was trying to rub that off of my screen
23:24:42 <shachaf> rwbarton: I just sent dons an email with a patch to fix ghc-core!
23:24:50 <shachaf> That's my good deed for the day.
23:25:05 <shachaf> rwbarton: Your good deed is fixing lambdabot.
23:26:14 <tShamanoid> ivanm: nope. Never had this before. First time i deprive myself of sleep.
23:26:35 <ivanm> well, let this be a lesson to you; don't do it again!
23:26:36 <ivanm> ;)
23:29:11 <tShamanoid> ivanm: Will try my best :D
23:31:01 <randomclown> @pl \(x,y) -> (x,[y])
23:31:01 <lambdabot> second return
23:31:20 <ivanm> using (:[]) to create a singleton list will probably help avoid problems down the track
23:31:29 <tShamanoid> omg this is getting really depressing
23:31:57 <tShamanoid> i hate those non-exhaustive patterns errors
23:32:38 <mikeplus64> @src many
23:32:38 <lambdabot> Source not found. :(
23:32:39 <flonum> shachaf: I did that a couple days ago
23:32:42 <Nereid> write more exhaustive patterns then
23:32:46 <flonum> Nothing Happens
23:32:58 <shachaf> flonum: Did what, sent dons an email about ghc-core?
23:33:02 <flonum> yeah
23:33:05 <shachaf> Oh. :-(
23:33:08 <jfischoff> my favorite ghc function name of the day: reallyUnsafePtrEquality#
23:33:09 <shachaf> Did you send it to dons00@?
23:33:15 <flonum> yeah
23:33:18 <shachaf> Hmm.
23:33:26 <randomclown> @pl \x -> (x,[])
23:33:26 <lambdabot> flip (,) []
23:33:33 <shachaf> flonum: Should someone just upload a new version over the old version?
23:33:50 <ivanm> any emacs users here use some kind of snippet/template/skeleton system for haskell code?  I notice that a few people like tibbe have repos for yasnippet on github, but don't know which to choose :p
23:33:51 <pordan30> (, []) = \x -> (x, [])
23:34:07 <jfischoff> how does one create an Int from Int#?
23:34:17 <shachaf> I#
23:34:17 <mikeplus64> jfischoff: I# x
23:34:25 <shachaf> jfischoff: See ":i Int"
23:34:29 <jfischoff> where is that located?
23:34:34 <flonum> shachaf: this is a patch for Control.OldException?
23:34:34 <shachaf> GHC.Something
23:34:34 <mikeplus64> GHC.Base
23:34:37 <shachaf> Types, Prim, Exts
23:34:38 <hpaste> tShamanoid pasted “Shittiest Code 2012” at http://hpaste.org/76803
23:34:38 <shachaf> Base
23:34:41 <shachaf> Whatever.
23:34:44 <shachaf> flonum: Yep.
23:34:59 <shachaf> rwbarton: What's the policy on NMUs again?
23:35:07 <tShamanoid> guys do i deserve this award?
23:35:13 <mikeplus64> tShamanoid: what is that supposed to be doing
23:35:19 <ivanm> tShamanoid: if it compiles, then it's not the shittiest
23:35:21 <rwbarton> no idea
23:35:31 <rwbarton> but they seem to exist
23:35:32 <ivanm> depends on what findDoubleDash, etc. are
23:35:36 <ivanm> and what you're trying to do
23:35:42 <ivanm> I take it this is homework though?
23:35:44 <MostAwesomeDude> tShamanoid: Well, hlint alone should be giving you some useful hints.
23:35:48 <tShamanoid> it is supposed to get a list of string, find comments in each string and remove it!
23:35:55 <shachaf> dmwit is on the committee or something. Maybe he knows.
23:36:02 <shachaf> dmwit!
23:36:18 <ivanm> tShamanoid: so each comment is in just one String?
23:36:24 <tShamanoid> MostAwesomeDude: noticed, it's gonna be a huge change
23:36:37 <MostAwesomeDude> tShamanoid: So why can't you just map a comment-remover over the list?
23:36:43 <ivanm> tShamanoid: if so, write a String -> String function to remove comments from each String
23:37:00 <MostAwesomeDude> tShamanoid: Feel like sharing the rest of the code? (Is this homework?)
23:37:05 <ivanm> then just map it over the list (with a filter (not . null) or osmething if necessary)
23:37:44 <tShamanoid> ivan: no, each string may contain one or more comment. That is a string like "abcd--hahah\n why have you --forsaken me\n" should return a new string without the two comments
23:38:24 <ivanm> tShamanoid: sure, but can you have a comment that starts in one String and ends in another?
23:38:34 <ivanm> if no, then write a String -> String function first
23:38:40 <tShamanoid> ivanm: thankfully, no.
23:38:48 <MostAwesomeDude> tShamanoid: Consider: filterComment (x:xs) | hasDoubleDash x = ...;
23:38:48 <jfischoff> so 1# makes and Int# and 1## makes a Double# is there a way to make a Float#?
23:39:13 <ivanm> right, so split out the concept of "remove comments from this string" from "do something to each string"
23:39:14 <tShamanoid> MostAwesomeDude: should i use guards instead?
23:39:21 <rwbarton> @src Float
23:39:21 <lambdabot> data Float = F# Float#
23:39:25 <shachaf> Well, there's a double2Float# function...
23:39:26 <rwbarton> oh
23:39:50 <jfischoff> god this code is getting ugly
23:39:51 <MostAwesomeDude> tShamanoid: I'm not super-sure what the best way to do this is yet.
23:40:00 <shachaf> jfischoff: No, that's not right.
23:40:09 <shachaf> 5# :: Int#; 5## :: Word#
23:40:15 <jfischoff> oh
23:40:15 <rwbarton> @hoogle a -> Float#
23:40:16 <lambdabot> Prelude id :: a -> a
23:40:16 <lambdabot> Data.Function id :: a -> a
23:40:16 <lambdabot> GHC.Exts breakpoint :: a -> a
23:40:18 <shachaf> 5.0# :: Float#; 5.0## :: Double#
23:40:34 <jfischoff> ahj
23:40:48 <shachaf> This Useful Information information brought to you by: ghci, and: the letter t
23:41:14 <jfischoff> he
23:41:15 <ivanm> @remember shachaf This Useful Information information brought to you by: ghci, and: the letter t
23:41:16 <lambdabot> Okay.
23:41:22 <tShamanoid> let me try writing a String -> String function then
23:47:55 <hpaste> MAD pasted “Derpin' hard for tShamanoid” at http://hpaste.org/76805
23:48:01 <MostAwesomeDude> tShamanoid: ^^
23:48:11 <MostAwesomeDude> Very derptastic, but it does the job.
23:49:31 <tShamanoid> MostAwesomeDude: Mother of God! This code is amazing
23:49:43 <MostAwesomeDude> tShamanoid: Uh.
23:50:12 <tShamanoid> MostAwesomeDude: can i ask you a personal question?
23:50:46 <MostAwesomeDude> tShamanoid: Sure.
23:51:09 <tShamanoid> MostAwesomeDude: for how long have you been coding in Haskell?
23:51:45 <MostAwesomeDude> tShamanoid: Eh. Hard to say. Maybe a year and a half? And it hasn't been consistent. I've had a love-hate relationship going on, where I try to be practical in Haskell but it falls apart and I go back to Python.
23:52:11 <tShamanoid> MostAwesomeDude: Ohhh i see
23:55:24 <tShamanoid> MostAwesomeDude: Thank you very much for the help man, highly appreciated.
23:55:27 <MostAwesomeDude> tShamanoid: Sure.
23:55:32 <mroman> @hoogle String -> ByteString
23:55:33 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
23:55:33 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
23:55:33 <lambdabot> Data.String fromString :: IsString a => String -> a
