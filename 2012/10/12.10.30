00:15:25 <sjcoles> d
00:30:32 <pnielsen> Any resources on Win32 IPC (C++ with GHC Haskell) -- preferably (NT) named pipes?
00:31:12 <Ralith> what is 'C++ with haskell'?
00:31:25 <Ralith> you mean you want a C++ program to communicate with a haskell program?
00:31:45 <pnielsen> correct
00:32:15 <pnielsen> between C++ and GHC Haskell*
00:32:34 <Ralith> why should that matter?
00:33:00 <pnielsen> What?
00:33:19 <pnielsen> I'm curious if there are any resources on doing IPC with GHC Haskell from C++
00:33:59 <Ralith> in what way do you expect that to differ from doing IPC with haskell as compiled or executed by something else, or with another language entirely?
00:34:33 <Ralith> you may also have better luck asking how to do things from C++ involving the windows API in either a C++ or a windows channel.
00:37:24 <pnielsen> I don't know how to be clearer. Does anyone know of any resources/examples on using Windows named pipes in Haskell, plus points if the client is C++.
00:38:04 <pnielsen> I don't care that you can do IPC in other languages
00:38:23 <Ralith> oh, you're doing it from Haskell, not C++.
00:38:46 <pnielsen> eh? :)
00:38:54 <Ralith> you said you were doing it from C++ before.
00:39:00 <pnielsen> C++ client, Haskell server
00:39:09 <pnielsen> Haskell needs to create the named pipe
00:39:11 * hackagebot ghc-mod 1.11.2 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.11.2 (KazuYamamoto)
00:39:28 <Ralith> have you searched hackage for a binding of the relevant API?
00:39:33 <pnielsen> yes, or I wouldn't be asking
00:39:59 <Ralith> is it too complex to easily bind yourself?
00:40:05 <srhb> This question has been raised multiple times in this channel and on Stackoverflow. I can only assume that making named pipes in Haskell on Windows is not possible right now. Probably no one made the relevant interop stuff.
00:40:27 <pnielsen> srhb: ouch, okay. Thanks for the information
00:40:28 <Ralith> surely it's just a matter of making the right foreign calls.
00:40:33 <srhb> Ralith: Yep.
00:40:41 <Ralith> so, hardly "not possible"
00:40:41 <srhb> But I guess the bindings just are not there yet.
00:40:48 <Ralith> right
00:40:49 <pnielsen> Ralith: that's what I wanted to avoid
00:40:53 <Ralith> but low level bindings are easy
00:40:58 <Ralith> tedious, at worst
00:40:59 <pnielsen> hence why I'm asking
00:41:16 <srhb> pnielsen: I don't think you can avoid doing it yourself. On the plus side, I'm sure the community will appreciate it. :-)
00:41:25 <Ralith> what I'm saying is, this shouldn't stop you.
00:42:06 <pnielsen> srhb, Ralith: sure, and I will make it available if I proceed. And it won't. I just didn't want to reimplement the wheel if somebody had already done this work
00:42:29 * Ralith nod
00:42:53 <Ralith> I guess I'm a bit nonplussed because I find myself doing that sort of work almost constantly
00:43:06 <pnielsen> there's no reason why it has to be GHC-specific, that's just what I'm using. Sorry for the confusion
00:43:36 <Ralith> right, I just misunderstood your initial question
00:43:46 <pnielsen> Ralith: I try to write as little C++ as humanly possible
00:44:00 <Ralith> I think we can all endorse that!
00:44:24 <shachaf> HA HA C++ IS SUCH A BAD LANGUAGE, AM I RIGHT
00:44:28 <pnielsen> my real question is actually if anyone's ever played with interaction between an NDIS filter driver and a Haskell application, because that's what I intend to do
00:44:35 <pnielsen> although I suspect that's relatively unexplored territory
00:45:06 <srhb> shachaf: Still no sleep? :P
00:45:23 <pnielsen> (NDIS 6)
00:45:26 <pnielsen> shachaf: C++ yes, C no :)
00:45:36 <pnielsen> although I find myself writing less and less C, too
00:49:23 <srhb> So, since I haven't an idea: Is this what you would have to make FFI bindings for? http://msdn.microsoft.com/en-us/library/aa365150.aspx
00:49:42 <pnielsen> and the IO on it, yes
00:49:48 <srhb> Right.
00:52:29 <pnielsen> http://hackage.haskell.org/packages/archive/unix/2.4.2.0/doc/html/System-Posix-Files.html#g:7
00:53:00 <larss> is there a way to do this without lambda? (\x -> func 1 x 2)
00:53:44 <Nereid> @pl \x -> func 1 x 2
00:53:44 <lambdabot> flip (func 1) 2
00:55:15 <srhb> pnielsen: But that's unixy! :P
00:55:17 <pnielsen> srhb, Ralith: here's a full-fledged C++ implemention http://msdn.microsoft.com/en-us/library/aa365588.aspx so yeah, it's certainly not the end of the world
00:55:35 <Nereid> larss: ^
00:55:36 <srhb> Neat.
00:55:42 <pnielsen> srhb: yes, if only I were writing for posix or NT with the POSIX subsystem :)
00:56:03 <larss> Nereid: is that it? I could swar there was a more concise way than lambda
00:56:12 <larss> swear
00:56:56 <srhb> larss: Not really.
00:56:56 <pnielsen> although I can't remember if Interix supports named pipes
00:57:15 <srhb> pnielsen: The worst part is, this could all be mostly transparent to the developer.. Or should.
00:57:18 <pnielsen> anyway, it'll surely be easier to just write the binding
00:57:23 <srhb> Yeah.
00:57:25 <pnielsen> srhb: yup
01:29:50 <larss> this is every day stuff to all of you, but I am very new to haskell and the simplicity and power of this simple declaration just blew me away. http:/​/​hpaste.org/​76983
01:31:38 <donri> you messed up that link methinks
01:31:48 <shachaf> Link looks fine to me.
01:31:48 <fmap> hmm, interesting, link isn't highlighted
01:31:54 <sp3ctum> for me neither
01:32:08 <sp3ctum> points to http://%e2%80%8bhpaste.org/%E2%80%8B76983
01:32:21 <sp3ctum> which isn't valid
01:32:22 <donri> http://hpaste.org/76983 FTFY
01:32:48 <larss> yes my client messed it up
01:34:17 <donri> [minBound ..] works too btw. upper bound is optional
01:34:37 <shachaf> larss: Type classes are pretty nice, but not as nice as the parts of Haskell that aren't type classes.
01:35:07 <sp3ctum> :D
01:35:15 <shachaf> The fact that the compiler is hard-wired to generate some code  for you isn't *that* interesting. The interesting parts are the things you can do yourself.
01:35:16 <donri> like unsafePerformIO
01:35:53 <Jafet> Wait till you derive Typeable, dude
01:36:14 <shachaf> Wait till you GeneralizedNewtypeDeriving.
01:36:17 <Jafet> (Though, as shachaf says, it's more interesting if you do it yourself)
01:37:23 <larss> Still, knowing how much code I would have to manually write in languages I usually use this is pretty awesome
01:37:50 <mkaito> google is giving me the cold shoulder on the subject... what is the typical development cycle while writing haskell? load Main into ghci, run it, use the debugger, etc?
01:38:10 <shachaf> mkaito: That's what I often do, minus the debugger.
01:38:26 <sp3ctum> tests, tests, tests
01:38:28 <shachaf> But you'll have to ask more specific questions.
01:38:51 <mkaito> well, I come from ruby. testing is big in ruby. what I do is have inotify watch files and run test cases every time I save a source file. fast feedback on what is wrong, you see.
01:38:59 <donri> cabal build --ghc-option=-fno-code
01:39:04 <mkaito> I've been trying to approach haskell with that kind of mindset
01:39:48 <mkaito> but the lack of resources on the subject suggest that: a) I'm doing it wrong. b) I'm stupid and it's obvious and that's why nobody writes about it.
01:39:49 <donri> i run that via vim to type check a project, and then cabal install --enable-tests every now and then
01:39:51 <Jafet> That's because ruby has essentially no way to guarantee program correctness apart from testing
01:40:19 <mkaito> hm cabal
01:40:29 <mkaito> you see, cabal looks like a contrived mess that apports very little to me.
01:40:42 <donri> mkaito: i also use syntastic in vim which gives in-buffer annotations for type errors and such. faster than inotify tests ;)
01:40:55 <mkaito> hm that sounds tasty
01:40:58 <mkaito> syntastic
01:41:08 <donri> sintastyc
01:41:24 <mkaito> https://github.com/scrooloose/syntastic ?
01:41:27 <donri> yep
01:41:29 <mkaito> :)
01:41:48 <donri> also need cabal install ghc-mod
01:41:56 <mkaito> anyways, the basic idea with haskell is to load the stuff you're writing in ghci and poke at it, right?
01:42:14 <sp3ctum> mkaito, yes, but what you poke is important
01:42:17 <arcatan> that's popular, but if you like using tests, there's nothing wrong with that
01:42:17 <shachaf> mkaito: Look, there are a lot of ways to write software.
01:42:24 <donri> depends who you're asking. that workflow appears to be more common in emacs than vim, and some do it directly in the terminal.
01:42:26 <mkaito> evidently
01:42:30 <shachaf> You're not going to find a One True Way in here.
01:42:49 <srhb> mkaito: There are plenty of ways to test Haskell, if you want to test Haskell. Have you looked at Quickheck for instance?
01:42:51 <mkaito> I'm not asking for the holy grail, shachaf, just asking around hoping people share their approach
01:43:05 <Jafet> Another way is in fact to write your code in ghci, and copy it to the program.
01:43:07 <mkaito> yes I've had a quick look at quickcheck
01:43:12 <sp3ctum> i like to write tests for things that can be tested with moderate ease. then poke at code until it compiles, :load to ghci and run tests in ghci
01:43:21 <srhb> mkaito: It's easier to write correct software in Haskell than in Ruby, so you'll probably see most people only test more advanced things.
01:43:33 <donri> there's a gsoc for "live coding" i.e. with file-watched recompilation
01:43:36 <mkaito> yeah the type system is kinda amazing
01:43:44 <arcatan> i don't write quickcheck tests too often. maybe i'm doing something wrong, but i often feel that writing tests is very tedious.
01:43:50 <donri> it's common in web frameworks to recompile and reload the app server
01:43:57 <donri> could be generalized outside web
01:44:18 <mkaito> should be interesting, donri
01:44:38 <mkaito> alright, thanks for the input, kind folks :) I'll poke at some of these ideas and find my way.
01:44:39 <sp3ctum> test coverage can be a programmer preference thing as well. no one true way
01:44:45 <arcatan> maybe doing a bit of TDD in Haskell would make me a better programmer :P
01:44:54 <shachaf> My computer has a pretty amazing type system.
01:44:57 <shachaf> 103 keys!
01:44:58 <mkaito> well, test coverage is more important in languages like ruby, where everything has side effects and nothing is ever guaranteed.
01:45:07 <donri> mine only has 87 keys!
01:45:08 <Ralith> we can totally come up with a One True Way in here!
01:45:16 <Ralith> it just might be selected at random.
01:45:19 <Ralith> no promises.
01:45:39 <Jafet> oneTrueWay :: IO Way
01:45:39 <mkaito> TDD seems the one true way in imperative programming, but I can see functional programming being a completely different beast in that regard.
01:45:46 <sp3ctum> mkaito, i encourage you to play with quickcheck. it's a very novel and inspiring approach to testing for me
01:46:11 <mkaito> I'll do that
01:46:36 <mkaito> thanks again
01:46:38 <mkaito> :)
01:46:39 <donri> somewhat ironically perhaps, testing tends to be easier in haskell
01:46:52 <shachaf> mkaito: I suspect that most programs that you use weren't written "TDDfully".
01:47:10 <mkaito> nah, it's a newfag thing :P
01:47:23 <pnielsen> TDD is useful when you want to implement a specification, and the test suite is the specification
01:47:28 <pnielsen> IMO
01:47:33 <sp3ctum> using quickCheck has made me very unsure of whether traditional unit tests actually help or not. I almost loathe them :D
01:47:34 <donri> isn't that BDD
01:47:34 <pnielsen> Haskell's type system already gives you that for free
01:47:44 <Jafet> shachaf: no, the best way to test a program is to release it
01:47:45 <mkaito> every app has a specification, even if nobody ever writes it down or writes tests for it
01:48:03 <pnielsen> mkaito: hence my second statement
01:48:14 <mkaito> certainly
01:48:17 <Jafet> You even tend to get automatic regression suites and everything.
01:48:30 <mkaito> most of the things I've ever tested for are pretty much ruled out by the compiler in haskell
01:48:42 <pnielsen> mkaito: ditto
01:48:47 <donri> i for one think unit (and property) testing haskell code complements the types nicely.
01:49:04 <mkaito> generally "make sure this fucntion doesn't explode and tear the server down when given something weird as argument"
01:49:07 <mkaito> and others
01:49:34 <pordan30> is there an efficient natural number type in haskell? for instance, a mapping from an inductive definition of the natural numbers to the positive integers, implementing as machine integers?
01:49:34 <pnielsen> you still might have to test behavior on ranges of input and similar, and that's why I love QuickCheck
01:49:43 <donri> even agda code can type check and do the wrong thing. types mostly prevent runtime exceptions, less so faulty logic
01:50:08 <pnielsen> you don't test for something specific, you test all kinds of possible inputs to something -- it's much closer to what's fashionable in the security field nowadays for finding vulnerabilities/bugs
01:50:11 <shachaf> donri: Well-typed programs can't be blamed!
01:50:36 <pnielsen> i.e. fuzzing
01:50:58 <pordan30> however, one cannot write a program in agda, type check the program, and have the program behave differently than the type specifies, assuming the machine hasn't erred.
01:51:07 <donri> http://cleantypecheck.wordpress.com/2012/10/27/hte-in-practice-quickmutate/ this looks like fun too
01:51:14 <Jafet> Fuzzing is a pretty dumb method in security testing
01:51:23 <statusfailed> aw, Network.Pcap is missing pcap_inject??
01:51:34 <Jafet> It should be something that doesn't work any more, but somehow still does.
01:51:52 <donri> pordan30: but it is up to you what you cover with the types
01:52:31 <donri> someone should make a purely typed language, such that you only write the types and the program itself is djinn'ed
01:52:34 <pnielsen> Jafet: no it's not. Not for user input/file format testing, anyway
01:52:50 <pnielsen> Jafet: I'll wager it's by far the most common and effective method of finding issues in the field
01:52:57 <Cale> Jafet: you mean of the sort that quickcheck provides?
01:53:31 <Jafet> If fuzzing works, that means your program has a large probability of failing anyway
01:53:38 <pnielsen> most programs do
01:53:42 <Jafet> Which, I suppose, is often true
01:53:45 <pnielsen> almost always
01:53:45 <Cale> Throwing random data at something and ensuring that some property holds of the results can be quite effective. When there are counterexamples to something, there are usually a fair number of them.
01:53:45 <pnielsen> :)
01:53:47 <Jafet> but shouldn't be
01:53:50 <pnielsen> agreed
01:54:04 <Jafet> Cale: but in the context of security testing
01:54:56 <pordan30> donri: that's an odd argument, however: if the user hasn't written programs with the correct types, and merely has the intended meaning in mind, there isn't a well-defined notion of "wrong" beyond "doesn't behave according to my intention when run."
01:55:16 <Cale> Jafet: I guess it also depends on exactly what you're looking for
01:55:19 <donri> hm what was that tool called that finds potential properties in existing code, i.e. kinda the inverse of quickcheck? quickspec or something?
01:55:24 <srhb> I have to say it feels like the type system destroys a lot of "this particular value will make your program go bonkers" which leaves the faulty logic when there's an error, and that usually is just not "one thing" that will trigger it, making the "fling random things at program" approach work quite well.
01:55:29 <Jafet> @google quickspec
01:55:36 <lambdabot> http://h18000.www1.hp.com/products/quickspecs/division/division.html
01:55:36 <lambdabot> Title: Worldwide QuickSpecs
01:55:51 <Jafet> Wow, they commercialized it already
01:56:08 <donri> http://publications.lib.chalmers.se/records/fulltext/local_125255.pdf
01:56:15 <pnielsen> http://publications.lib.chalmers.se/records/fulltext/local_125255.pdf
01:56:17 <pnielsen> hah
01:56:24 <donri> :)
01:57:40 <pnielsen> Jafet: but yeah, totally agree. Format fuzzers are pretty useless for testing well-written software. Problem is most industry software isn't
01:59:04 <pnielsen> I like QuickCheck not so much for its security properties (esp in Haskell), but because for most things I don't need to set up a bunch of different test cases/parameters
01:59:24 <donri> pordan30: that's why testing complement types nicely, because you can encode concretely those expectations. types are abstract encodings.
02:00:43 <donri> while we're on the subject of quickcheck. is there a technical or philosophical reason against using GHC.Generics for Arbitrary, or just that no one has done it yet?
02:00:51 <pnielsen> that's when I find myself writing tests in Haskell, when the program might behave differently even if it satisfies the type system
02:01:08 <pnielsen> granted that's far, far less often than I write tests in most other languages
02:01:12 <dreixel> donri: it's certainly been done...
02:02:07 <donri> dreixel: oh, i missed the generics branch when i looked in git
02:02:25 <dreixel> donri: but I actually don't know where that is :P where did you find it?
02:02:48 <donri> https://github.com/nick8325/quickcheck/blob/generics/Test/QuickCheck/Arbitrary.hs#L105f
02:02:53 <donri> 1https://github.com/nick8325/quickcheck/blob/generics/Test/QuickCheck/Arbitrary.hs#L105
02:02:55 <donri> argh
02:02:57 <donri> https://github.com/nick8325/quickcheck/blob/generics/Test/QuickCheck/Arbitrary.hs#L105
02:04:17 <dreixel> donri: ok, I don't know this code, I think
02:04:49 <dreixel> donri: this is what I wrote, a long time ago: https://github.com/dreixel/regular-extras/blob/master/src/Generics/Regular/Functions/Arbitrary.hs
02:04:56 <donri> added 9 months ago but never released on hackage :(
02:05:10 <dreixel> donri: granted, it's not GHC.Generics, but it should be trivial to port. and it supports giving a probability for each constructor.
02:06:33 <donri> the above is a branch of the official quickcheck git
02:06:52 <nohonor> can anyone help me with an example of when one would need to pass a type constructor to another type constructor
02:07:00 <nohonor> as discussed here: http://pastebin.com/kBAiX1e2
02:07:31 <mkaito> when the first type wraps the second? like Maybe.
02:08:01 <nohonor> but Maybe wraps concrete types
02:08:08 <mkaito> nah, maybe wraps anything
02:08:21 <nohonor> :k Maybe Maybe
02:08:22 <lambdabot>     `Maybe' is not applied to enough type arguments
02:08:22 <lambdabot>     The first argument of `Maybe' should have kind `*',
02:08:22 <lambdabot>     but `Maybe' has kind `* -> *'
02:08:45 <ClaudiusMaximus> i saw some "higher kinded either" once, like  data Either1 f g a b = Left1 (f a) | Right1 (g b)   can't remember why it was useful
02:09:26 <larss> Why are parenthesis required around !! ?   (!!) "foo" 1
02:09:46 <nohonor> larss, because it's used as prefix operator
02:09:49 <fmap> nohonor: monad transformers?
02:10:36 <shachaf> ClaudiusMaximus: GHC.Generics has data (:+:) f g p = L1 (f p) | R1 (g p)
02:10:41 <nohonor> fmap, i see :-)
02:10:41 <shachaf> Not quite the same.
02:11:27 <nohonor> that makes sense
02:12:11 <nohonor> the paper i was reading was talking about passing List<> to List<> which was absurd, these examples however are something entirely different
02:13:36 <nohonor> :k GHC.Generics.(:+:)
02:13:37 <lambdabot>     Illegal symbol '.' in type
02:13:37 <lambdabot>     Perhaps you intended -XRankNTypes or similar flag
02:13:37 <lambdabot>     to enable explicit-forall syntax: forall <tvs>. <type>
02:14:39 <nohonor> ok, another question: how do i query the kind of a qualified type
02:15:05 <ClaudiusMaximus> shachaf: that might be what i saw, makes more sense than my misrememberance at least
02:15:37 <ClaudiusMaximus> :k (GHC.Generics.:+:)
02:15:39 <lambdabot> * -> * -> *
02:15:58 <pordan30> like :k Data.Set.Set :: * -> *?
02:16:27 <shachaf> nohonor: Your question is how to qualify an infix operator.
02:16:31 <shachaf> It has nothing to do with types.
02:16:34 <shachaf> And now you know. :-)
02:16:49 <nohonor> shachaf, i stand corrected :-)
02:17:37 <srhb> Huh, was <$ always a part of the Functor class? I never noticed it before.
02:17:54 <dreixel> :k (GHC.Generics.:+:)
02:17:55 <lambdabot> * -> * -> *
02:17:58 <dreixel> that kind is wrong.
02:18:13 <shachaf> srhb: It's not part of the Functor class, even today.
02:18:17 <dreixel> :k (GHC.Generics.:*:)
02:18:18 <lambdabot> * -> * -> *
02:18:23 <dreixel> :k (GHC.Generics.U1)
02:18:24 <lambdabot>     Not in scope: type constructor or class `GHC.Generics.U1'
02:18:31 <dreixel> right, it's using an old GHC.
02:18:41 <shachaf> Yes, it's actually (* -> *) -> (* -> *) -> * -> *
02:18:44 <nohonor> indeed, if "Data (:+:) f g p = L1 (f p) | R1 (g p)", (:+:) is hardly *->*->*
02:18:56 <dreixel> shachaf: yes
02:19:36 <nohonor> shachaf, then why does it report it like that?
02:20:04 <dreixel> nohonor: it's using a pre-7.4 version of the compiler, which had a completely different thing in GHC.Generics
02:20:30 <larss> why doesn't this work? allEnums = [minBound .. maxBound]
02:21:10 <Lemmih> larss: Most likely because of the monomorphism restriction.
02:21:12 <nohonor> dreixel, i see... thank you :-)
02:21:48 <srhb> > [minBound .. maxBound] :: [Bool]
02:21:49 <lambdabot>   [False,True]
02:22:10 <Lemmih> larss: Try with -XNoMonomorphismRestriction.
02:22:50 <larss> I have tried this too. did something wrong it seems. allEnums :: Enum a :-> [a] allEnums = [minBound .. maxBound] :: [a]
02:23:07 <larss> Lemmih: I'll try
02:27:21 <merijn> larss: That type signature doesn't look right
02:27:27 <merijn> larss: Enum doesn't enforce Bounded
02:28:10 <larss> Yeah I see
02:28:42 <merijn>  > let allEnums :: (Enum a, Bounded a) => [a]; allEnums = [minBound .. maxBound] in allEnums :: [Bool]
02:29:19 <merijn> hmm
02:29:33 <merijn>  > let allEnums = [minBound .. maxBound] in allEnums :: [Bool]
02:29:52 <donri> one too many spaces
02:30:09 <merijn> doh
02:30:14 <merijn> > let allEnums :: (Enum a, Bounded a) => [a]; allEnums = [minBound .. maxBound] in allEnums :: [Bool]
02:30:16 <lambdabot>   [False,True]
02:30:21 <merijn> > let allEnums :: (Enum a, Bounded a) => [a]; allEnums = [minBound .. maxBound] in allEnums :: [Int]
02:30:23 <lambdabot>   [-9223372036854775808,-9223372036854775807,-9223372036854775806,-9223372036...
02:30:43 <merijn> > let allEnums :: (Enum a) => [a]; allEnums = [minBound .. maxBound] in allEnums :: [Bool]
02:30:45 <lambdabot>   Could not deduce (GHC.Enum.Bounded a)
02:30:45 <lambdabot>    from the context (GHC.Enum.Enum a)...
02:30:53 <donri> larss: =>, not :->
02:34:12 <larss> What if I wanted to make it a function, can it be done without -XNoMonomorphismRestriction?
02:36:11 <donri> larss: use the type signature merijn used
02:36:12 <larss> Is always using that flag desireable?
02:36:26 <donri> allEnums :: (Enum a, Bounded a) => [a]
02:37:26 <merijn> larss: The reason for the MonomorphismRestriction is this: If you define "allEnums" at the top-level, you might expect it to be a constant list. However, due to it's polymorphism it would have to be computed from scratch every time it's used
02:38:01 <merijn> larss: So to avoid that pitfall GHC automatically makes top level things like it a single constant list by enforcing monomorphism (i.e. it can be only one type)
02:38:37 <merijn> larss: The two ways to avoid it are 1) explicitly provide a type signature, this forces the compiler to keep it polymorphic or 2) disable MMR
02:38:56 <merijn> larss: In general disabling the MMR is not a bad thing, but it should be preferrable to specify a type signature
02:39:11 <Ralith> explicitly providing type signatures for top level decls is often considered to be good style anyway
02:40:36 <larss> Okay thanks. I usually put the decl but couldnt figure out a proper one
02:47:21 <larss> I cant get it to work. Getting "Parse error on input 'in'". I guess I am missing some import and "in" isnt easy to google
02:48:33 <shachaf> "in" is syntax.
02:49:14 * hackagebot BNFC-meta 0.4.0.1 - Deriving Parsers and Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.4.0.1 (JonasDuregard)
02:49:16 * hackagebot simple-log 0.1.6 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.1.6 (AlexandrRuchkin)
02:49:22 <shachaf> larss: You should probably read an introduction to Haskell and get used to the syntax a bit. :-)
02:50:01 <shachaf> larss: If it says "Parse error on input 'in'", there must be an "in" somewhere in your program.
02:50:05 <larss> Yes you are right
02:50:15 <shachaf> You put it there for a reason; what do you intend it to do?
02:56:30 <larss> I'll go back to reading here's the error and code: http:/​/​hpaste.org/​76985
02:56:34 <mcstar> i was wondering if you can make IO an instance of Functor, without making it an instance of Monad first, i guess not
02:56:49 <larss> Ill go back to reading tutorial after this, even
02:57:15 <mcstar> larss: 'in' is nothing like Python's in
02:57:22 <mcstar> you dont test for membership with it
02:57:40 <mcstar> you introduce bindings with 'let ... in ...'
02:58:04 <shachaf> larss: That's an interesting question -- what *are* you doing with those links?
02:58:08 <shachaf> mcstar: Sure you can.
02:58:28 <larss> mcstar ah I see
02:59:04 <merijn> mcstar: Unfortunately you can
02:59:05 <mcstar> shachaf: but intance Functor IO uses bind and return
02:59:20 <larss> shachaf: I am just copy/pasting them, my client is messing up the link for some reason
02:59:22 <merijn> mcstar: Yes, but any monad has to be a functor (if it obeys the law)
02:59:29 <shachaf> mcstar: Not necessarily.
03:00:30 <mcstar> fmap f x = x >>= (return . f)
03:00:46 <mcstar> so, how can you rewrite this, without reuturn, bind, or do notation?
03:01:50 <shachaf> fmap f x = fmapIO f x
03:03:17 <mcstar> would fmapio be written with the help of unsafe functions?
03:03:32 <shachaf> Maybe. Maybe not.
03:04:58 <donri> fmap f x = pure f <*> x
03:05:10 <mcstar> i can imagine doing it with unsafeCoerce and unsafePerformIO
03:05:57 <mcstar> since you cant pattern match on the IO constructor...
03:06:06 <mcstar> for good reasons
03:06:43 <shachaf> The instance comes predefined for you, so don't worry about it.
03:07:03 <mcstar> shachaf: so, now i cant be curious? or what?
03:07:28 <mcstar> ive been here for quite some time, i think i can be curious about such things
03:07:38 <shachaf> Huh?
03:07:54 <mcstar> are you trying to scare me with that?
03:08:08 <mcstar> (with 'huh?')
03:08:11 <shachaf> I don't get it.
03:08:29 <shachaf> The instance comes predefined for you. Every Haskell implementation will do it differently.
03:08:39 <shachaf> In GHC it's probably done by pattern-matching on the IO constructor.
03:08:57 <mcstar> i see
03:10:25 <kliko> Hey guys
03:10:33 <kliko> can someone explain how to use the -ddump-deriv?
03:10:43 <kliko> I want to see the instances, but I can't actually get the dump :(
03:11:23 <shachaf> kliko: Works for me.
03:12:02 <shachaf> $ echo 'module Z where data Foo = Foo deriving Eq' > Z.hs; ghc -ddump-deriv Z.hs
03:21:46 <fmap> larss: is there some invisible symbol between two slashes in your link?
03:23:03 <ivanm> fmap: I see a box after all three slashes in his link
03:30:48 <larss> Fmap yes, for whatever reason I have 0x200b character after every slash
03:31:56 <larss> And I do not see them when I am pasting the link
03:44:10 <mcstar> did ghc always have monadic io?
03:44:54 <GeneralButtnaked> is there no datacommunication channel?
03:46:18 <fmap> mcstar: no
03:46:35 <fmap> mcstar: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm might be interesting
03:49:54 <mcstar> thanks
03:50:25 <mcstar> im wondering about the early monadic IO performance
03:51:10 <mcstar> in IO a, a is a function taking the world, returning the world and some value
03:51:43 <mcstar> so, by concatenating IO actions, you build up a series of nested functions, dont you?
03:52:35 <mcstar> but ultimately, this is not necessary, since you dont really change the world argument, it is just there for sequencing
03:53:01 <mcstar> but IO must be lazy, like all of haskell, so you must build the thunks
03:53:47 <mcstar> the question is, was IO slower than pure lazy evaluation?
03:57:21 <nus> "pure"?
03:57:35 <mcstar> yeah
03:57:49 <mcstar> but probably it wasnt
03:58:09 <nus> yeah what, what do you mean by pure?
03:58:33 <mcstar> what other ppl mean by pure
03:58:49 <mcstar> normal haskell evaluation
04:00:36 <nus> other people usually mean lack of side-effects by that
04:01:34 <mcstar> and normal haskell evaluation lacks side effects
04:09:21 <nus> if there's no IO, there's no evaluation, so IO is "normal" by that measure
04:11:31 <mcstar> if every IO action were a 'return some', then yes, it would be, but they usually do more than that
04:12:22 <mcstar> anyway, i wanted to separate IO and non IO, thats why the 'pure'
04:12:27 <mcstar> lets not argue about this
04:14:37 <mcstar> i was just thinking about, whether or not the sequencing of state makes IO slower, than the fastest it could be, while still being lazy, or is it the same as lazy evaluation
04:15:03 <mcstar> and i think, it is the same, otherwise, it wouldnt be lazy
04:34:16 * hackagebot btree-concurrent 0.1.3 - A backend agnostic, concurrent BTree  http://hackage.haskell.org/package/btree-concurrent-0.1.3 (JohanBrinch)
04:41:31 <efie> is it true that changing recursive functions to tail-recursive functions will GHC allow to optimize more and save space?
04:41:56 <efie> (or is this optimizing process already done when compiling with -02?)
04:42:06 <shachaf> It's true that it's not that simple.
04:43:08 <efie> how difficult is it?
04:44:16 * hackagebot plat 0.1.0.1 - Simple templating library  http://hackage.haskell.org/package/plat-0.1.0.1 (MiguelMitrofanov)
04:44:57 <merijn> efie: Tail recursion is overrated, it simply doesn't help all that much in a lazy language
04:45:33 <merijn> efie: In a strict language tail recursion will allow constant space usage for your recursion, which makes it important in languages like scheme and ML
04:46:02 <merijn> efie: However, laziness can cause non-tail recursive functions to be constant space anyway
04:46:32 <merijn> Take for example map, which requires constant stack space (well, it depends on whether you keep the result of mapping around or not...)
04:46:38 <merijn> @src map
04:46:39 <lambdabot> map _ []     = []
04:46:40 <lambdabot> map f (x:xs) = f x : map f xs
04:46:45 <merijn> Not tail recursive at all
04:49:33 <efie> hm ok
04:49:49 <efie> my program takes a lot of space, I thought this is because I use a lot of recursions and laziness may build a lot of thunks ... so adding strictness and then making the recursive functions tail recursive might help?
04:51:10 <Ferdirand> i think sometimes tail recursion can even make it worse ?
04:52:11 <fmap> @src foldl
04:52:12 <lambdabot> foldl f z []     = z
04:52:12 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:52:40 <merijn> efie: tail recursion has approximately zero correlation with space usage due to thunk building
04:52:53 <merijn> efie: Have you profiled what's using the space?
04:52:54 <fmap> efie: tail recursion doesn't save you from building large thunks at all
04:53:26 <merijn> Less guessing, more measuring
05:00:17 <mapf>  can someone explain where i should use lazy writer and where strict? all the difference between strict and lazy versions is when we bind two writers to one. so i don't understand why it's useful to have ~(a, w) <- runWriterT
05:00:50 <mapf> lazy matching here just let us to evaluate a tuple later
05:00:59 <mapf> but not 'a' or 'w'
05:01:41 <atriq> Internal memory representation, I suppose
05:01:47 <atriq> Thunks and that
05:02:57 <mapf> so, but one use case when we need lazy matching on tuple is when we can have undefined istead of tuple, right?
05:03:40 <mapf> atriq: yep, but how it helps? i can't see
05:04:18 <atriq> Maybe if you're using something like Writer (Sum Int), you'd want strict, but Writer [Int], you'd want lazy?
05:04:25 <ivanm> lazy matching is good for cases like in partition
05:04:26 <atriq> I don't really know, I'll be honest
05:04:28 <ivanm> @src partition
05:04:28 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
05:04:28 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
05:04:28 <lambdabot>                               | otherwise = (ts, x:fs)
05:04:42 <ivanm> when you don't really need to evaluate the results of the recursive call until later
05:05:17 <ivanm> (e.g. if you want take 3 . fst . partition p $ xs, then after it finds three values it doesn't bother recursing)
05:05:24 <efie> merijn: profiling yields that inserting a key value pair in a (large) map takes the most space, is this because the whole map has to be copied due to nonmutable data?
05:07:00 <fmap> efie: what if you use strict Map?
05:07:20 <mapf> atriq: isn't strict Writer (Sum Int) will accumulate a thunk?
05:07:30 <efie> fmap: I already do, if I use lazy Map it takes too much RAM (I get Killed)
05:07:50 <mapf> thunk in 'w' i mean
05:08:00 <mcstar> maybe you have a lot of data...
05:09:52 <mapf> ivanm: good exsample
05:10:16 <KBme> hello
05:10:20 <ivanm> mapf: I spent about two weeks trying to debug a case that was in hindsight rather similar :)
05:10:29 <KBme> has anyone tried to install configfile on windows?
05:12:17 <efie> mcstar: I read two 1 MB files in, produce a Map and print the map to a file, this file then is 500MB big (-s says "376 MB total memory in use"). But the task is to read two 15 MB files in, and if I do that I get "Killed" because the all of RAM is used after a few seconds... so I'm searching for ways to reduce the function to take up that much memory, but I don't really know how to do it
05:12:52 <hpaste> KBme pasted “installing dependency of configfile on win32 (win7)” at http://hpaste.org/76987
05:12:56 <mcstar> efie: what is the type of the map?
05:12:56 <Jafet> Quit using Strings.
05:13:05 <mapf> ivanm: well today i accidently have something like that: ind :: Maybe Int; ind = (1 :) <$> ind
05:13:07 <efie> mcstar: Data.HashMap.Strict
05:13:19 <mcstar> thats not the full type
05:13:27 <mapf> sorry, Maybe [Int]
05:13:27 <efie> oh
05:13:29 <efie> ups
05:13:46 <KBme> does anyone know how I could install configfile on win32?
05:13:56 <ivanm> KBme: what's the error?
05:14:16 <KBme> http://hpaste.org/76987
05:14:17 <ivanm> oh, you pasted it earlier
05:14:20 <efie> mcstar: Data.HashMap.Strict as M ... the type is M.HashMap Text (M.HashMap Text Float)
05:14:29 <mapf> but infinity forest instead of infinity list, and ErrorT instead of Maybe
05:14:48 <KBme> well, the real problem is with the missingh package, which seems to be a dependency of configfile
05:14:52 <ivanm> KBme: looks like it might be a version mismatch
05:14:57 <ivanm> what does "ghc-pkg list time" say?
05:15:00 <ivanm> and ghc-pkg check
05:15:31 <KBme> time-1.4
05:16:08 <mcstar> efie: what are your keys? lines? to what? other lines? im just trying to get a feel for how many elements that map must have
05:16:18 <mapf> it's well known to cause looping, but i had a headache for a half of evening all the same
05:16:28 <hpaste> KBme pasted “ghc-pkg check” at http://hpaste.org/76988
05:16:38 <KBme> ivanm, ^
05:17:01 <ivanm> KBme: only 1.4 for time?
05:17:09 <KBme> yep
05:18:01 <ivanm> OK, I don't think there's anything Win32 specific going on here
05:18:31 <KBme> should I try installing time with cabal?
05:18:45 * KBme tries
05:19:01 <KBme> latest is 1.4.0.1
05:19:29 <KBme> nope, that doesn't help
05:19:52 <KBme> ivanm, i think it's win32 specific, because I can install configfile on my linux box without a problem
05:19:56 <ivanm> at a guess, one of MissingH's deps switched from using old-time to time for one of its packages
05:20:01 <KBme> and the error is at the win32 compat module of missingh
05:20:01 <efie> mcstar: there are 4000 keys in the map, a key is an english word, for every key, the value is a map of 4000 keys (words from a foreign language) with a Float value
05:20:22 <ivanm> KBme: OK, to be more specific: it's not directly due to some funky weird Win32 thing
05:20:33 <KBme> oh, sure, probably not ☺
05:20:51 <KBme> though it seems to me that it might be due to windows not storing time in utc
05:20:55 <ivanm> we have a winner
05:21:02 <mcstar> efie: you have a LOT of overhead
05:21:07 <ivanm> directory switched from old-time to time with 1.2.0.0
05:21:17 <ivanm> I forget, is directory a boot package?
05:21:22 <KBme> oh, interesting
05:21:24 <mcstar> i think you should formulate your problem better
05:21:34 <ivanm> KBme: which version of ghc?
05:22:01 <Philippa> efie: is it the same 4000 foreign words each time, just with different frequencies?
05:22:13 <efie> Philippa: yes
05:22:15 <KBme> ivanm, afaik latest stable gimme a sec
05:22:24 <KBme> 7.4.1
05:22:24 <ivanm> what does "latest stable" mean? :p
05:22:25 <mcstar> use a vector
05:22:29 <Philippa> efie: you should be able to save some space by only storing those once, then
05:22:32 <ivanm> KBme: `ghc-pkg list directory' ?
05:23:22 <Philippa> one ForeignWord -> Index map, one vector per EnglishWord or similar
05:23:31 <fmap> ivanm: yes, directory is a boot package
05:23:36 <ivanm> thought so
05:23:53 <KBme> GAH
05:23:56 <ivanm> KBme: I need to hit the sack, but if you have directory-1.2 then you shouldn't have it as it's one of the packages you shouldn't upgrade
05:24:00 <KBme> i can't copy from the windows terminal now
05:24:12 <ivanm> so get down to the one that should ship with that version of ghc
05:24:16 <KBme> ivanm, I do have it
05:24:21 <KBme> and I have to hit it too
05:24:28 <KBme> what would be the solution?
05:24:55 <ivanm> KBme: OK, when you are able to, one solution is (I think this is the right command): cabal install MissingH --constraint "directory < 1.2.0.0"
05:24:58 <ivanm> then install ConfigFile
05:25:07 <ivanm> might need --constraint=
05:25:13 <KBme> ok
05:25:16 <KBme> thanks a bunch!
05:25:24 <ivanm> np
05:25:27 <KBme> i'll try that
05:25:40 <efie> Philippa: sorry I don't get what you mean, for each foreignWord I have a map from ....?
05:26:46 <mcstar> first of all, you dont need to store the 4000 foreign words 4000 times
05:27:13 <mcstar> you can just use a vector of 4000 elements for every english key
05:27:42 <mcstar> so you use a bit of indirection, but you use less space
05:28:21 <Philippa> right. Then you need a map from your foreign words to indices in that vector, so you can do a word->vector position lookup still
05:29:17 * hackagebot CurryDB 0.1.0.0 - CurryDB: In-memory Key/Value Database  http://hackage.haskell.org/package/CurryDB-0.1.0.0 (HideyukiTanaka)
05:34:16 <efie> so for each of the 4000 english words, I have a different vector of 4000 float values, but I don't need to save the foreign word each time (in these vectors)?
05:36:24 <nand`> Cale: re: funny imperative OO languages that make these distinctions; C# might be a good example for exploring these since it's been progressing a bit towards the C++ concept of “let's just have everything”, you now have dynamic duck typing, dynamic strong typing, dynamic weak typing, static strong typing and static weak typing (where weak/strong here refers to the presence or nonpresence of implicit
05:36:26 <nand`> coercions)
05:36:38 <efie> Philippa: mcstar: could you check I got this right? :)
05:37:09 <nand`> and since it has first class procedures, functions, lazy expressions and whatnot you can just go with the “behavioral” approach by having your classes be collections of first class methods, then providing those when constructing a class instance
05:37:29 <nand`> together with automatic inheritance and all, while not going the ‘full way’ and just using generalized duck typing
05:39:17 * hackagebot btree-concurrent 0.1.4 - A backend agnostic, concurrent BTree  http://hackage.haskell.org/package/btree-concurrent-0.1.4 (JohanBrinch)
05:42:13 <mm_freak> cabal's world file really doesn't have any comment syntax?!
05:42:35 <Jafet> This is haskell, who needs 'em
05:44:30 <mm_freak> i need them, because each time i upgrade GHC i need to comment out things…  right now i'm putting them in a separate file, which is stupid
05:45:02 <Jafet> Hmm
05:45:03 <mcstar> efie: yes
05:45:14 <efie> ok.. thank you very much!
05:45:32 <Jafet> I'm writing a program with an output format that is only used to save work when the program dumps core
05:45:37 <Jafet> And it has comment syntax
05:46:58 <mm_freak> any machine-readable text format should have comment syntax
05:47:37 <mm_freak> i mean, hell, even /etc/shells has comment syntax!
05:49:11 <nand`> mm_freak: agree, it's silly not to have one for cabal's world file
05:50:12 <nand`> (once again, not using cabal-install fixes this; I can use as many comments as I want in my world file)
05:52:51 <efie> mcstar: which of the modules at vector-0.7.0.1 would you suggest for my use? My guess would be, for storing Float values, Data.Vector.Unboxed is the best?
05:53:31 <mcstar> yeah, thats ok, you can use Data.Array too
05:54:18 <mm_freak> nand`: what's the alternative to cabal-install modulo cabal-dev?
05:54:39 <nand`> what do you mean by ‘modulo cabal-dev’?
05:56:44 <mm_freak> nand`: stripping off products involving cabal-dev
05:56:55 <mm_freak> in other words:  please don't suggest cabal-dev =)
05:57:11 <nand`> oh
05:57:13 <nand`> I use portage
05:58:16 <mm_freak> efie: could you summarize your problem?
05:58:36 <mm_freak> (more often than not one wants boxed vectors/arrays instead of unboxed)
06:05:21 <efie> mm_freak: I have data of type HashMap Text ( ... ) where ( ... ) contains a lot of Float values. Then I need to apply a function repeatedly over that data to make the data 'better', which means to change all float values for all keys slightly in every function call
06:06:10 <mm_freak> that's not enough information to decide between boxed and unboxed variants
06:08:38 <efie> mm_freak I read on haskell.org that boxed arrays are better for complex Haskell types, whereas unboxed are more efficient for values like Float
06:08:43 <efie> what else do you have to consider?
06:08:55 <efie> types like Float *
06:09:41 <smithw> I often have the necessity to do simple tasks on every file on a directory tree. Most of the time the tasks are restricted to a simple FilePath -> IO a function, a being another FilePath or just (). this structure sounds suspiciously like a monad, a fold or at least a functor, to me. do you folks think it's possible to implement this monad/fold/functor explicitly?
06:09:55 <nand`> sounds like a traversal to me
06:10:17 <nand`> traverse :: (FilePath -> IO a) -> [FilePath] -> IO [a]
06:10:53 <mm_freak> efie: this is not about efficiency, but about algorithm expression…  if an element in an iteration depends on another element from the same iteration, a boxed data structure is better, even for Float
06:10:55 <smithw> nand`, that's precisely what I was looking for. thanks!
06:12:50 <shachaf> nand`: Also mapM. :-)
06:13:20 <Jafet> I believe efie is doing what some call "linear algebra".
06:13:26 <nand`> shachaf: oh, right
06:14:29 <nand`> Is mapM exported by Prelude?
06:14:41 <nand`> ah, it is
06:14:45 <Jafet> :t Prelude.mapM
06:14:47 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:17:20 <efie> mm_freak: hm yes, every iteration I produce a value and add / divide it to / by a float value, this result then becomes the new float value
06:25:17 <Philippa> so I need to generalise the Functor class and a suspiciously functor-like one that was built to work on fixpoints of datatypes (and fixpoints-with-extras)
06:25:33 <Philippa> the latter can't be Functor because the kinds don't pan out
06:26:06 <Philippa> I'm also not very awake and haven't played with the relevant GHC extensions. Anyone wanna do my homework for me?
06:28:06 <mcstar> mm_freak: what do you mean by, a boxed vector being better depending on the algorithm?
06:32:15 <efie> mcstar: I think he explained it at 02:10:34
06:32:40 <mcstar> 02:10:34 doesnt mean anything to me
06:33:40 <merijn> mcstar: Presumably the time he answer, but not knowing efie's localtime that's hardly helpful :p
06:33:51 <mcstar> i know it is the time
06:34:05 <efie> oh :)
06:34:13 <mcstar> but different timezones + my clock is skewd god knows how much... so go figure
06:34:51 <mcstar> and i read what mm_freak said, and that made me ask the question
06:35:01 <mcstar> so i hardly think that i will find my answer there
06:35:50 <Philippa> dolio: I need to figure out how to generalise Functor (but probably not functors) to cover another typeclass I have whose raison d'etre is to let Fix be an instance. Any ideas?
06:36:11 <Philippa> (aside from "you're using a new version of GHC than before, RTFM"?)
06:37:31 <dolio> Fix :: (* -> *) -> *? With the obvious implementation?
06:38:39 <Philippa> yeah
06:39:03 <Philippa> oh, the generalisation needs to account for cases where the function being lifted might be constrained, in this case to an endofunction
06:39:19 * hackagebot hakyll 3.5.0.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.5.0.0 (JasperVanDerJeugt)
06:42:41 <dmwit> maybe:
06:42:47 <Philippa> hmm. Actually, I can live with an endofunction every time, so I think I'm looking at a 2-parm polykinded class
06:43:19 <dmwit> class Functor f where type Dom f a :: *; type Cod f a :: *; type Ctxt f a b :: Constraint; fmap' :: Ctxt f a b => (Dom a -> Cod b) -> (f a -> f b)
06:43:27 <dmwit> with {-# LANGUAGE KindPolymorphism #-}
06:44:22 <dolio> class Functor (f :: k -> *) where type IHom f :: k -> k -> * ; map :: IHom a b -> f a -> f b?
06:44:52 <Philippa> I shall start throwing stuff through GHC! Thanks
06:46:13 <dolio> I haven't used the kind polymorphism stuff much, as I just tracked down a fedora repo for 7.6 recently.
06:46:19 <dolio> So I don't know what all works.
06:46:31 <dolio> That looks pretty tame, though.
06:47:04 <merijn> Is there somewhere I can read up on the ":: Constraint" bit?
06:47:30 <nand`> page for -XConstraintKinds would be a first bet, no?
06:47:55 <Philippa> ...hah, because I don't need to cover functions in general I can probably just go with a boring 2-parm class with no polykinds
06:48:03 <Philippa> wait, no, still need the polykinds, fair enough
06:48:56 <simon> what's the point in using the 'tok' helper function in http://darcs.haskell.org/alex/tests/tokens_posn.x ?
06:49:24 <merijn> oh!
06:49:36 <merijn> I'm so gonna abuse the shit out of ConstraintKinds!
06:53:16 <t7> url me
06:54:50 <hpaste> “Ertugrul Söylemez” pasted “Lazy vector Fibonacci function” at http://hpaste.org/76991
06:54:55 <mm_freak> mcstar: see paste
06:55:50 <mm_freak> individual elements of the vector reference the vector itself, which is impossible for unboxed vectors
07:07:54 <Philippa> ah, I can't do what I want on GHC7.4.2
07:08:01 <Philippa> 7.6, sure
07:09:44 <dolio> Yeah, 7.4 was kind of wonky.
07:10:26 <Philippa> mmm. That's... annoying, from a "try to stick with the Platform" perspective
07:10:59 <Philippa> though hopefully not for too much longer
07:11:47 <Philippa> in case you're wondering WTF I'm up to, I'm beefing up the setup I've been using for constraint programming a bit
07:12:10 <Philippa> didn't want to have to piss about with fixpoint stuff for non-recursive datatypes, for example
07:14:22 <dolio> Heh, well, 'stick with the platform' and 'use super bleeding edge stuff that still isn't all there' are kind of contradictory goals. :)
07:16:07 <Philippa> yeah, just I've been hearing about polykinds long enough I didn't think they were bleeding edge any more :p
07:16:31 <dolio> Nah, they still have some serious stuff to work out.
07:16:40 <Philippa> fair enough
07:16:41 <dolio> Even in 7.6.
07:16:56 <dolio> I mean, you can use them, probably use them for your problem in 7.6.
07:17:16 <Philippa> yeah, I'm pretty sure my problem falls easily in 7.6 - I'm only missing the ability to write a kind annotation in the first place
07:22:31 <t7> > 25 * 8
07:22:33 <lambdabot>   200
07:23:01 <t7> someone make a z3 plugin for hoogle plox
07:25:03 <t7> i mean lambdabot
07:25:29 <copumpkin> so you can ask z3 to compute 25 * 8?
07:25:37 <osfameron> z3?
07:25:37 <t7> no other things
07:25:46 <Magnap> @help
07:25:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:26:01 <t7> so i dont have to rearrange equations
07:28:50 <AndrewMarsh> @pl \x y -> compare (length x) (length y)
07:28:51 <lambdabot> (. length) . compare . length
07:29:23 <osfameron> so much cleare
07:29:25 <osfameron> +r
07:32:35 <Magnap> @pl riddle x = (((((x-2)/2)-2)/2)-2/2)
07:32:36 <lambdabot> riddle = subtract (2 / 2) . (/ 2) . subtract 2 . (/ 2) . subtract 2
07:34:30 <Jafet> :t comparing length
07:34:31 <lambdabot> forall a. [a] -> [a] -> Ordering
07:39:45 <osfameron> where is comparing from?
07:39:52 <clahey> @hoogle comparing
07:39:53 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
07:40:13 <Magnap> @pl riddle x = ((x/2-(1/2))/2-(1/2))/2-(1/2)
07:40:14 <lambdabot> riddle = subtract (1 / 2) . (/ 2) . subtract (1 / 2) . (/ 2) . subtract (1 / 2) . (/ 2)
07:40:14 <scooty-puff> i'm having trouble seeing why snd $ fix $ \ (a, b) -> (a, 1) loops, but snd $ fix $ \ ~(a, b) -> (a, 1) does not
07:40:24 <clahey> Someone should make lmhtfy.  :)
07:40:43 <scooty-puff> it looks to me like the (,) call is obvious, and it would only loop if (!a, b)
07:40:47 <dolio> scooty-puff: fix is such that if f _|_ = _|_, then fix f = _|_.
07:41:00 <osfameron> clahey: ta
07:41:17 <dolio> Because _|_ is always least, so if it is the fixed point, then it is the least fixed point.
07:41:42 <dolio> If it is a fixed point, ven.
07:41:53 <clahey> What is (\ ~(a, b) -> (a, 1)) _|_?
07:42:09 <Cale> scooty-puff: yeah, this thing is the subtle property which people are talking about when they say that (,) is "lifted". _|_ as a pair is a different value from (_|_, _|_)
07:42:11 <dolio> (_|_, 1)
07:42:35 <scooty-puff> k
07:42:39 <scooty-puff> hmm
07:42:40 <parcs`> > fix $ \ ~(a,b) -> (1,b)
07:42:45 <lambdabot>   mueval-core: Time limit exceeded
07:42:45 <lambdabot> parcs`: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:42:59 <scooty-puff> > snd $ fix $ \ ~(a, b) -> (1, b)
07:43:03 <lambdabot>   mueval-core: Time limit exceeded
07:43:10 <scooty-puff> err, woops
07:43:18 <scooty-puff> > snd $ fix $ \ ~(a, b) -> (a, 1)
07:43:19 <lambdabot>   1
07:43:20 <Aune> When running "cabal install cabal-install" "cabal: Couldn't read cabal file "warp/1.3.4.2/warp.cabal", what do?
07:43:44 <Cale> It seems like some questionable (but mostly pragmatic) decisions have been made here and there throughout Haskell with regard to how certain values are semantically distinguishable from _|_
07:43:46 <clahey> > (\(a, b) -> (1, b)) undefined
07:43:47 <lambdabot>   *Exception: Prelude.undefined
07:43:55 <clahey> > (\ ~(a, b) -> (1, b)) undefined
07:43:56 <lambdabot>   (1,*Exception: Prelude.undefined
07:44:07 <hpc> > (\ ~(a, b) -> (1, a)) undefined
07:44:10 <lambdabot>   (1,*Exception: Prelude.undefined
07:44:13 <Cale> This is in some ways similar to how the function  const undefined  is a separate thing from  undefined
07:44:36 <Cale> (though you need seq to tell those apart)
07:44:37 <dolio> Well, actually implementing unlifted products that behave correctly in the presence of seq is a bad idea.
07:44:49 <scooty-puff> (a, b) ~~ (forall r . (a -> b -> r) -> r)
07:45:08 <clahey> Oh, I had to look up what ~ was again, but now I get it.
07:45:15 <dolio> Other than seq you could do it, and Miranda did.
07:45:43 <clahey> scooty-puff: Does it make sense now?
07:46:43 <clahey> scooty-puff: I think it's not the right side of the equation that causes the problem, but instead the left side.
07:46:45 <scooty-puff> clahey: as a rule for "fix", yes
07:47:20 <clahey> scooty-puff: Ah, that wasn't the part I was confused about.  :)
07:47:53 <scooty-puff> it still bothers me that f may unconditional produce (,), but still be considered _|_
07:47:57 <scooty-puff> but i guess i'm ignoring
07:48:01 <scooty-puff> that its not unconditional
07:48:12 <scooty-puff> whatever i might mean by "unconditional"
07:48:40 <Cale> scooty-puff: Without actually looking inside the function, you can't really tell that it's unconditional :)
07:48:46 <smithw> if I only have the constraints (Applicative f, Monad m), is there a function that can do this => m (f a) -> f (m a) ? Searching Hoogle seem to imply at least one of them have to be traversable...
07:48:56 <scooty-puff> or rather i ignore the implied order - that the match on (,) is required before the constructor call of (,) is performed
07:49:49 <Cale> smithw: Yeah, there's no perfectly general thing of that sort.
07:49:55 <clahey> scooty-puff: Right.  You don't need _|_ there.
07:50:04 <scooty-puff> but then thinking about it as ordering is probably not correct either - could it really be \ x -> x `seq` (fst x, 1)
07:50:09 <clahey> > (\(a, b) -> (1, b)) 6
07:50:10 <lambdabot>   (1,6)
07:50:12 <Cale> smithw: Only operations of that type for specific choices of m and f
07:50:21 <clahey> Um, what?
07:50:31 <scooty-puff> brb
07:50:33 <smithw> Cale, I see... thanks
07:50:47 <clahey> > (\~(a, b) -> (1, b)) 6
07:50:48 <lambdabot>   <no location info>: parse error on input `->'
07:50:49 <Cale> smithw: sequence / sequenceA  being one of them
07:51:01 <clahey> > (\ ~(a, b) -> (1, b)) 6
07:51:02 <lambdabot>   (1,6)
07:51:08 <clahey> > (\ ~(a, b) -> (1, b)) (5, 6)
07:51:10 <lambdabot>   (1,6)
07:51:33 <clahey> Can anyone explain that to me?
07:51:50 <Cale> > 6 :: (Integer, Integer)
07:51:52 <lambdabot>   (6,6)
07:52:05 <clahey> > (\(a, b) -> (1, b)) "Hello"
07:52:06 <lambdabot>   Couldn't match expected type `(t, t1)'
07:52:06 <lambdabot>         against inferred type `[GHC....
07:52:08 <nominolo> clahey: stupid lambdabot magic
07:52:10 <Cale> > 6 * (1,2) + 1
07:52:12 <lambdabot>   (7,13)
07:52:12 <clahey> > (\ ~(a, b) -> (1, b)) "Hello"
07:52:13 <lambdabot>   Couldn't match expected type `(t, t1)'
07:52:13 <lambdabot>         against inferred type `[GHC....
07:52:30 <clahey> > fst . (\ ~(a, b) -> (1, b)) $ "Hello"
07:52:31 <lambdabot>   Couldn't match expected type `(t, b)'
07:52:31 <lambdabot>         against inferred type `[GHC.T...
07:52:38 <Cale> It's just the natural pair instance for Num
07:52:50 <nominolo> Cale: it's not necessarily natural
07:52:56 <clahey> Now, why doesn't that work?
07:53:03 <Cale> nominolo: In what way?
07:53:33 <clahey> Oh, because of types.  It figures out the type of the function, even though I put in the ~?
07:53:37 <nominolo> Cale: there was a library proposal.  There are other instances that fit the expected laws
07:53:41 <Cale> Sure the rings you get aren't so nice. There are zero divisors, but other than that, there's not much reason to hate them.
07:53:56 <clahey> nominolo: Example?
07:54:10 <Cale> But it is at least analogous to the categorical product of rings
07:54:33 <Cale> (not to say that Num really needs to be based entirely on what rings do)
07:54:48 <filkr> Question: Is there a way I can do concatMap on a Monad? I'm trying to supply the first argument as type [String] -> IO [String]
07:55:06 <quicksilver> @hoogle concatMapM
07:55:07 <lambdabot> No results found
07:55:23 <quicksilver> @type \f -> concat <$> mapM f
07:55:25 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
07:55:54 <filkr> I'm going to try and parse that for a second
07:55:56 <filkr> But thanks
07:55:58 <Cale> errr
07:55:59 <quicksilver> @type \f -> concat . mapM f
07:56:00 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
07:56:07 <quicksilver> I got it wrong anyway
07:56:16 <quicksilver> @type mapM
07:56:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
07:56:44 <filkr> Should I just use concatM $ mapM $ ... ?
07:56:53 <quicksilver> yes
07:57:02 <rwbarton> @hoogle concatM
07:57:02 <lambdabot> Prelude concatMap :: (a -> [b]) -> [a] -> [b]
07:57:03 <lambdabot> Data.List concatMap :: (a -> [b]) -> [a] -> [b]
07:57:03 <lambdabot> Data.Foldable concatMap :: Foldable t => (a -> [b]) -> t a -> [b]
07:57:32 <clahey> Cale: What's another example of how it could be done?
07:57:36 <filkr> Thanks
07:57:41 <clahey> 5 :: (Int, Int) = (5, 0)?
07:57:58 <Cale> :t \f xs -> fmap concat (mapM f xs)
07:57:59 <lambdabot> forall a a1 (f :: * -> *). (Monad f, Functor f) => (a1 -> f [a]) -> [a1] -> f [a]
07:58:05 <scooty-puff> back
07:58:55 <Cale> clahey: Yeah, the tricky part is how should multiplication work then?
07:59:04 <Cale> Because if 1 is (1,0)
07:59:11 <Cale> then you want 1 * (x,y) = (x,y)
07:59:12 <Cale> somehow
07:59:35 <Cale> You could do the funny thing which we do for complex numbers.
07:59:44 <Cale> which works only for pairs
08:00:00 <clahey> And if you did (x, 1) then addition is broken.
08:00:08 <Cale> right
08:00:41 <clahey> Where are the laws listed?
08:00:48 <Cale> So you could have (a,b) * (c,d) = (a*c - b*d, a*d + b*c)
08:00:48 <clahey> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html#7
08:00:54 <clahey> Only has the list of things wanted.
08:00:57 <Cale> Num doesn't really have good laws
08:01:01 <Cale> Because Float
08:01:18 <latro`a> floating point ruins all formal reasoning :|
08:01:22 <latro`a> except error analysis
08:01:26 <Jafet> We could just say RealFrac has diplomatic immunity.
08:01:38 <Cale> clahey: *but* you can look up the laws for a ring
08:01:40 <Jafet> (and legislate around them)
08:01:44 <Cale> and those are a reasonable guide
08:01:50 <clahey> Cale: I don't need to look up the laws for a ring.  :)
08:01:58 <latro`a> doesn't CReal actually obey laws?
08:02:09 <Cale> latro`a: yes
08:02:19 <clahey> Cale: I do have one thought though.  Ring doesn't imply commutative.
08:02:24 <Cale> latro`a: It's also unreasonably slow for many simple calculations :)
08:02:31 <latro`a> of course
08:02:40 <clahey> (x, y) * (x', y') = (x * x', y') would work.
08:02:44 <Cale> > sum [1..1000] :: CReal
08:02:48 <lambdabot>   mueval-core: Time limit exceeded
08:02:51 <latro`a> wow
08:03:47 <Jafet> > (pi :: CReal) == exp (pi * sqrt 163)
08:03:48 <lambdabot>   False
08:03:53 <Jafet> Pffft
08:04:22 <latro`a> wait, what
08:04:24 <latro`a> > sqrt 163
08:04:26 <lambdabot>   12.767145334803704
08:04:32 <latro`a> I don't get it
08:04:37 <latro`a> > exp (pi * sqrt 163)
08:04:39 <lambdabot>   2.6253741264076826e17
08:04:42 <pnielsen> don't ask questions you don't want the answer to
08:04:43 <latro`a> ...
08:04:53 <Jafet> Oh
08:04:54 <Cale> Jafet is misremembering the interesting thing about this number
08:05:02 <Cale> It's extraordinarily close to an integer
08:05:09 <Cale> > exp (pi * sqrt 163) :: CReal
08:05:10 <lambdabot>   262537412640768743.9999999999992500725971981856888793538563
08:05:15 <Jafet> I was going to type something else that is almost pi
08:05:16 <latro`a> ah
08:05:25 <pnielsen> > 9223372036854775807.0 == 9223372036854775808
08:05:26 <lambdabot>   True
08:05:40 <latro`a> > truncate (exp (pi * sqrt 163)) == exp (pi * sqrt 163)
08:05:42 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:05:42 <lambdabot>    `GHC.Real.Integral a'
08:05:42 <lambdabot>   ...
08:05:44 <latro`a> err
08:05:45 <latro`a> bah
08:05:46 <Sculptor> o/
08:06:11 <Jafet> That reminds me, I need to actually learn about class fields
08:06:33 <clahey> Cale: Oh, I wondered if my definition would correctly handle distributive rules, but I think it does.
08:07:14 <Cale> There is apparently an explanation of this phenomenon which comes down to Q(sqrt(-163)) being the last Q(sqrt(-d)) whose ring of algebraic integers have unique factorisation.
08:08:14 <Cale> (But I don't understand it well)
08:09:20 <clahey> Q(sqrt(x)) = (Q, Q) / (x, x^2) ?
08:09:21 * hackagebot shelly 0.14.2.2 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.14.2.2 (GregWeber)
08:10:33 <Cale> Q(sqrt(d)) = Q(x)/<x^2 - d>
08:12:03 <Cale> Or you can just think of it as the subfield of C which is generated by Q and sqrt(d)
08:12:49 <Cale> (or just sqrt(d) rather, because every subfield of C contains Q)
08:13:23 <jfischoff> I am playing around with representing state transitions with GADTs
08:13:35 <jfischoff> I'm wondering if anyone else has done something similar?
08:13:41 <Cale> jfischoff: I have
08:13:48 <Cale> jfischoff: Using the Prompt monad
08:13:53 <jesyspa> Why isn't Integer an instance of Monoid by default?  Ambiguous operation?
08:13:54 <jfischoff> Cale: I have a question then
08:14:00 <Cale> and a GADT with Get and Put constructors
08:14:09 <Cale> jesyspa: right
08:14:30 <Cale> jesyspa: Every instance of Num is (at least morally) an instance of monoid in at least two ways
08:14:55 <Cale> jesyspa: and there are newtypes Sum and Product for selecting which one you want
08:15:05 <jesyspa> Ah, okay.  I see, thanks.
08:15:15 <jesyspa> Still have to learn about newtypes properly.
08:15:37 <jfischoff> Cale: Did you type classes to help with nesting?
08:15:46 <jfischoff> * you use
08:15:50 <Cale> jfischoff: I did nothing fancy
08:16:10 <jfischoff> yeah I want to find a fancy example
08:16:17 <Jafet> There's an example in the reflection package that shows how to manufacture local monoid instances
08:17:49 <Cale> jesyspa: Newtypes basically are the same thing as data but restricted to one constructor with one field. The semantics of pattern matching are adjusted a bit so that the compiler has the option of compiling newtypes to the same thing as values of the original type. However, the type system will treat them as an entirely separate type.
08:18:07 <Cale> (unlike type aliases defined by 'type' which just give another name for an existing type)
08:18:15 <jesyspa> Cale: Does that mean it's primarily an optimisation feature?
08:18:23 <Cale> jesyspa: You could say that
08:18:43 <Cale> There is a real difference in how pattern matching behaves semantically though
08:18:58 <Cale> If I have:
08:19:04 <Cale> data D = D Integer
08:19:09 <Cale> newtype N = N Integer
08:19:16 <Cale> then
08:19:26 <Cale> case undefined of D x -> 0
08:19:29 <Cale> will be undefined
08:19:57 <Cale> Operationally, pattern matching against that constructor will force the evaluation of the scrutinee, and the program will end.
08:20:03 <Cale> But
08:20:09 <Cale> case undefined of N x -> 0
08:20:13 <Cale> will result in 0
08:20:39 <jesyspa> Ah, so you could say the D is a thicker wrapper around the value, while the N is almost non-existant?
08:20:40 <Cale> pattern matching against a newtype constructor doesn't "do any work"
08:20:42 <Cale> yeah
08:20:50 <nominolo> > case (Sum undefined) of Sum x -> 0
08:20:52 <lambdabot>   0
08:20:54 <jesyspa> Thanks, I see.
08:21:07 <nominolo> > case undefined of Sum x -> 0
08:21:09 <lambdabot>   0
08:22:08 <jesyspa> So when I want to treat a list of Nums as a monoid under addition, I should use Sum <$> mylist?
08:22:43 <nominolo> > mconcat (Sum <$> [1..20])
08:22:45 <lambdabot>   Sum {getSum = 210}
08:22:53 <Volatile> O_o
08:23:04 <Cale> Unfortunately, there is a real cost to <$> here
08:23:11 <Cale> (or, less fancily, map)
08:23:12 <Volatile> > case undefined of _ -> this
08:23:13 <lambdabot>   Not in scope: `this'
08:23:20 <Cale> > mconcat (map Sum [1..20])
08:23:22 <lambdabot>   Sum {getSum = 210}
08:23:35 * Volatile laughs at himself for mixing haskell and erlang syntax
08:23:36 <nominolo> Cale: well, it's "map id"
08:23:41 <Cale> Even though the Sum is implemented like "id"
08:23:42 <Cale> yes
08:23:49 <refried_> is "return" defined in the language or in a library?
08:23:56 <Cale> refried_: both
08:24:10 <merijn> refried_: Depends on which return :)
08:24:20 <refried_> makes sense :)
08:24:25 <jesyspa> Cale: Do you mean a performance cost, or something else?
08:24:26 <rwbarton> a language-specified library
08:24:41 <refried_> I'm looking at this simple example in Data.Enumerator:
08:24:44 <Cale> jesyspa: Yeah, a performance cost
08:24:46 <refried_> returnI :: Monad m => Step a m b -> Iteratee a m b
08:24:46 <refried_> returnI = Iteratee . return
08:25:01 <refried_> and trying to understand how return is associated with m
08:25:13 <refried_> and not, say, some other Monad, or whatever
08:25:19 <jesyspa> Will keep that in mind; focusing on understanding Foldable/Applicative/Alternative at the moment. :)
08:25:26 <rwbarton> well you would need to know the type of Iteratee
08:25:32 <merijn> refried_: Which return is used depends on the Monad m
08:25:33 <Cale> jesyspa: Some people, when this cost really matters, will do a fairly ugly thing and add a rewrite rule to turn  map MyNewtype  into  unsafeCoerce
08:25:56 <Cale> jesyspa: Which is probably something I shouldn't even be mentioning
08:25:59 <Cale> :)
08:26:16 <merijn> refried_: That signature is basically saying that you can use the code with any Monad m, as long as Step and Iteratee use the same one
08:26:25 <jesyspa> Hehe, alright.
08:26:26 <donri> > F.foldMap Sum [1..20]
08:26:27 <lambdabot>   Not in scope: `F.foldMap'
08:26:38 <donri> > Data.Foldable.foldMap Sum [1..20]
08:26:39 <lambdabot>   Sum {getSum = 210}
08:27:00 <Jafet> {-# RULES forall x. getSum (mconcat (map Sum x)) = sum x #-}
08:27:01 <merijn> refried_: And the way that gets determined is by the type checker and the way typeclasses are implemented
08:28:17 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in product (take 4 primes)
08:28:19 <lambdabot>   210
08:28:29 <merijn> Man, when will we get simple type level composition :( I need to write all sorts of ugly hacks using phantom parameters to be able to write the typeclass instances I want...
08:28:43 <rwbarton> never, see preceding 1000 discussions
08:29:38 <refried_> merijn: hmm *nod*  i guess that's what i'm trying to understand.  is it that there may be multiple "return"s defined, that each have different type arguments?  i don't mind switching to a simpler typeclass to understand this, if it would help  (and if you/someone doesn't mind walking me through it).  i'm coming from Scala, but typeclasses and type checking are a little different there
08:29:48 <merijn> rwbarton: I disagree, I think special casing some simple cases is totally worth it, even if GHC can't support full blown type level lambda's
08:29:58 <rwbarton> refried_: you need to know the type of Iteratee
08:30:06 <rwbarton> what is it?
08:30:16 <merijn> rwbarton: tbh I don't think he needs to know the type of Iteratee to answer his question
08:30:21 <rwbarton> he sure does
08:30:31 <jesyspa> Do I understand correctly that some [1, 2] will non-lazily build a list consisting of [1, 2, 1, 2, 1, 2, ...]?
08:30:35 <Cale> refried_: Understanding Iteratee before you understand monads is probably going to be stupidly difficult.
08:30:54 <rwbarton> this is also true
08:30:56 <refried_> well, here it is regardless: newtype Iteratee a m b = Iteratee { runIteratee :: m (Step a m b) }
08:31:02 <merijn> rwbarton: He asked how the compiler determines which return gets used. Seems to me that only depends on typeclasses and not at all on the Iteratee type
08:31:10 <rwbarton> well, that is not the case...
08:31:39 <refried_> Cale: I think I understand Monads, just not Monads in haskell necessarily… i think my question is more about how function calls get resolved to typeclasses, rather than about monads or iteratees
08:31:41 <Cale> jesyspa: cycle [1,2]?
08:31:50 <Cale> refried_: ah, okay
08:31:52 <merijn> rwbarton: Why not? The type he listed had "Monad m =>", how does the iteratee type influence which return is selected?
08:31:53 <rwbarton> if Iteratee had a type like Iteratee :: Reader Int m (Step a m b) then it would use the Monad instance for Reader Int m ...
08:31:57 <rwbarton> er
08:32:04 <rwbarton> Iteratee :: Reader Int m (Step a m b) -> Iteratee a m b
08:32:05 <Cale> refried_: So yeah, return is a method of the Monad type class.
08:32:09 <Cale> We have:
08:32:11 <jesyspa> Cale: Er, I'm trying to understand some and many; don't actually need the list.
08:32:13 <Cale> class Monad m where
08:32:18 <Cale>   return :: a -> m a
08:32:26 <Cale>   (>>=) :: m a -> (a -> m b) -> m b
08:32:44 <refried_> *nod*
08:32:59 <merijn> rwbarton: Then you'd require more constraints
08:33:18 <rwbarton> ugh I mean s/Reader/ReaderT/ as well of course
08:33:19 <merijn> rwbarton: That requires a "Monad (Reader m)" constraint
08:33:30 <merijn> Well, readert, you get what I mean
08:33:42 <rwbarton> which would of course be discharged by the Monad m => Monad (ReaderT r m) instance in scope
08:33:49 <rwbarton> leaving a Monad m constraint
08:34:11 <rwbarton> you cannot assume that "Monad m => " means "return" is used only for m
08:34:14 <clahey> Cale: I was distracted by real life, but I think what I meant to say was Q(sqrt(d)) = (Q, Q) / (1, d)
08:34:22 <merijn> rwbarton: I wasn't, but that wasn't his question
08:34:45 <mcstar> mm_freak: i thought that you meant some case with lazy initialization, but this is actually suprising to me, that it doesnt work with an unboxed vector, even if you specialize the elements to other than (Num a), like Int
08:35:02 <merijn> He asked *how* does return get selected, not *which* return gets selected
08:35:29 <clahey> No, that's not right either.  Whatever.  :)
08:35:36 <Cale> jesyspa: some and many make the most sense in the case of parsers
08:35:47 <Cale> er
08:35:59 <rwbarton> and the "how" is by inferring the expected type of that "return", which in turn will depend on the type of Iteratee
08:36:06 <Cale> yes
08:36:33 <clahey> Cale: Ha, I looked for 163 on the wikipedia page for pi and it shows up 5 times, but none of them are the one I'm looking for.  :)
08:37:10 <Cale> http://en.wikipedia.org/wiki/Heegner_number
08:37:12 <merijn> refried_: Basically, GHC has a collection of class instances (for example "instance Monad Maybe"), when you use a typeclass method (like return), GHC will look at the type, which monad you are using and use the instance for that type
08:37:46 <merijn> refried_: The simplest example of this is "read :: Read a => String -> a", GHC will try to tell from the typing context which instance of Read you meant
08:37:53 <merijn> Which, is also why this fails:
08:37:56 <merijn> > read "3"
08:37:57 <lambdabot>   *Exception: Prelude.read: no parse
08:38:04 <merijn> but this doesn't
08:38:09 <merijn> > read "3" :: Int
08:38:11 <lambdabot>   3
08:38:26 <jesyspa> Cale: Ah, so I should see many v as "parse at some v or nothing", and some v as "parse one v and then many v"?
08:38:34 <merijn> refried_: GHC infers from the type "Int" that we intend to use the "Int" instance of Read.
08:38:37 <Cale> jesyspa: yes
08:38:42 <refried_> merijn: ok.. so if I had Monad m and Monad n and the result was expecting m something, then using "return" would automatically select m's return
08:38:52 <merijn> Similarly for monads and return
08:38:55 <merijn> > return 3
08:38:57 <lambdabot>   No instance for (GHC.Show.Show (m t))
08:38:57 <lambdabot>    arising from a use of `M6063506160...
08:39:01 <merijn> > return 3 :: Maybe Int
08:39:03 <lambdabot>   Just 3
08:39:05 <Cale> refried_: that's right
08:39:06 <merijn> However
08:39:12 <merijn> > return 3 :: [Int]
08:39:13 <lambdabot>   [3]
08:39:17 <refried_> merijn: ah!
08:39:21 <refried_> *scratches head*
08:39:32 <refried_> what if i had a return function defined outside of the typeclass as well
08:39:40 <Cale> refried_: and if you use it out of a context which demands a particular m, then you get something polymorphic
08:39:42 <jesyspa> And then the parse failure actually occurs during some v, but as that's called from many v, I get an empty and the parse is treated as valid?
08:39:45 <merijn> refried_: You get a compile error due to name duplication
08:39:49 <Cale> refried_: The name is taken
08:39:52 <refried_> would that be ok, and the compiler would select whichever one matched the expected return type?  oh.
08:39:58 <clahey> > return . return $ 5 :: Maybe (Either String Int)
08:40:00 <lambdabot>   Just (Right 5)
08:40:15 <refried_> are all the names defined in all the typeclasses that i may have imported also taken?
08:40:18 <Cale> refried_: There's no ad-hoc polymorphism
08:40:28 <merijn> refried_: Yes
08:40:36 <clahey> refried_: Often you can specify which one you mean though.
08:40:52 <Cale> refried_: Of course, there is a module system which you can use to define things with the same name and disambiguate
08:41:00 <refried_> Cale: i forget which kind of polymorphism that is
08:41:03 <typoclass> refried_: well, you can always hide them of course :) "import ... hiding (return)"
08:41:04 <Cale> But then you have to write qualified names
08:41:33 <Cale> refried_: i.e. the sort of polymorphism you were talking about where you just define something multiple times and the compiler selects one based on the type at the usage site.
08:41:50 <Cale> refried_: What typeclasses provide is something a bit more structured and a lot more powerful than that
08:42:13 <refried_> i see examples of qualified type names, but not qualified function names
08:42:15 <refried_> Cale: ah
08:42:47 <refried_> thanks a lot everyone
08:43:03 <merijn> refried_: You can just do "import qualified Foo as Bar" and then call functions from Foo by writing "Bar.functionName" in your code
08:43:44 <merijn> refried_: qualified names are the same for everything, I think. Types, functions, values, etc. just prefix them with "Bar."
08:43:46 <clahey> Or just import Foo and then do "Foo.functionName"
08:44:02 <clahey> Or import qualified Foo or import Foo as Bar.
08:44:09 <refried_> ok, so if I had Monad and Foo both define "return", I might (or would definitely?) need to use Monad.return or Foo.return
08:44:20 <Cale> right
08:44:33 <clahey> Well, except that qualified means that it doesn't add it to the top level name space.
08:44:34 <mm_freak> mcstar: simple data dependency:  the vector depends on all elements, and one element depends on the vector → loop
08:44:39 <refried_> I guess that also means there has to be a space before and after composition .
08:44:41 <Cale> refried_: It all depends on how you import things
08:44:53 <clahey> So if you did import Control.Monad and import qualified Foo, you could do return and Foo.return.
08:44:55 <Cale> refried_: yeah, it's the dumbest choice of module path separator every
08:44:57 <Cale> ever*
08:45:03 <refried_> Cale haha
08:45:06 <mcstar> mm_freak: but why does that have to do with unboxing?
08:45:08 <refried_> clahey ah *nod*
08:45:20 <Cale> "Let's take the most used operator symbol and use that as the module path separator! That won't be horrible!"
08:45:22 <mm_freak> mcstar: because unboxed values are always evaluated
08:45:46 <mm_freak> in normal form that is…  an unboxed value is never unevaluated
08:45:51 <clahey> refried_: There's a ton of data structures that define map and so forth.  I usually do things like import qualified Data.Map as M
08:46:08 <Cale> refried_: So this point about polymorphism...
08:46:17 <Cale> refried_: We have a type class called Ord for example
08:46:25 <refried_> clahey: ah
08:46:26 <Cale> Which defines ordering comparison operations
08:46:31 <Cale> Such as (<=)
08:46:34 <refried_> *nod*
08:46:45 <Cale> We also have  sort :: (Ord a) => [a] -> [a]
08:46:52 <Cale> which was written after the fact
08:47:01 <refried_> *nod*
08:47:03 <Cale> and is not something you have to provide when you write an instance of Ord
08:47:12 <Cale> It's polymorphic just because it uses the Ord operations
08:47:15 <refried_> ok sure
08:47:31 <clahey> Cale: So, I see how it's more typesafe, but how is it more powerful than ad-hoc?
08:47:44 <Cale> So that's a difference between what's going on with typeclasses and what happens in some programming languages where you're just allowed to define the same name multiple times and have it pick which one based on the type.
08:48:05 <refried_> isn't it polymorphic just because it uses 'a'? or is that a different kind of polymorphism than using Ord
08:48:15 <Cale> clahey: Well, think about it. If ad-hoc polymorphism was used, we'd have to write sort over and over with the same definition.
08:48:25 <refried_> Cale: based on type of the arguments, etc
08:48:41 <Cale> Well, we're constraining the set of types over which the 'a' ranges
08:48:48 <mm_freak> the difference between sort and sortBy is that for the former the compiler selects which comparison operator to pass
08:48:49 <Cale> So it's kind of a constrained parametric polymorphism
08:48:58 <refried_> *nod*..err sure, to the ones that have an Ord instance?
08:49:00 <clahey> Cale: Why?  You define sort based on <= and then sort will work on any function which has <= defined.
08:49:01 <mm_freak> :t (sort, sortBy)
08:49:03 <lambdabot> forall a a1. (Ord a) => ([a] -> [a], (a1 -> a1 -> Ordering) -> [a1] -> [a1])
08:49:04 <Cale> yes
08:49:14 <Cale> clahey: What would the type be?
08:49:19 <clahey> Cale: Or is ad-hoc polymorphism not the same as duck typing?
08:49:47 <Cale> clahey: ad-hoc polymorphism is like that feature of C where you statically select an implementation based on the type
08:49:59 <tac> I think more emphasis should be put on the term "ad-hoc"
08:50:05 <mm_freak> clahey: parametric polymorphism:  one piece of code working for multiple types…  ad hoc polymorphism:  multiple pieces of code each working for a single type
08:50:07 <ziman> it's called overloading in c++
08:50:18 <Jafet> @quote walks.and.quacks
08:50:18 <lambdabot> No quotes match. You untyped fool!
08:50:29 <Jafet> @quote walks.like.poly
08:50:30 <lambdabot> syntaxfree says: it isn't polymorphism per se, but walks like polymorphism and quacks like polymorphism.
08:50:32 <Cale> clahey: It's not the same thing as structural subtyping.
08:50:39 <refried_> mm_freak: ah
08:50:42 <clahey> mm_freak: Ah, so python has both and they interact in interesting ways.
08:50:58 <Cale> clahey: Well, python doesn't really have a type system
08:51:01 <Jafet> python has neither
08:51:03 <companion_cube> clahey: pythohn has no parametric polymorphism
08:51:06 <clahey> mm_freak: So you would say that <= had ad-hoc polymorphism and sort had parametric polymorphism?
08:51:06 <companion_cube> -h
08:51:08 <Cale> (at least not in the sense that we would mean)
08:51:28 <clahey> Cale: Ah, and polymorphism requires a type system.  :)
08:51:39 <tac> ad-hoc has the connotation of disorganization. It suggests a sloppy-but-practical solution.
08:51:40 <Cale> clahey: We'd say that they're both typeclass polymorphic
08:51:46 <mauke> Cale: C has no polymorphism at all
08:51:58 <Cale> mauke: Oh, am I misremembering what you're allowed to do?
08:52:11 <quicksilver> I think Cale was thinking of C++ function overloading
08:52:12 <mm_freak> clahey: well, you could say that, but i wouldn't go as far as to classify them…  remember what a type class really is:  it's just a hidden argument chosen by the compiler
08:52:16 <Jafet> mauke: until you get some polymorphic shellcode past a buffer!
08:52:19 <Cale> yes, perhaps that's what I'm thinking of
08:52:45 <mauke> C89 gives you one definition per external identifier (and 6 significant characters per identifier (case insensitive)) :-)
08:52:55 <Cale> mauke: lol
08:53:02 <clahey> Would having a function that takes different types based on the value of the earlier arguments be considered polymorphism of some sort?
08:53:18 <companion_cube> mauke: c89 is obsolete by two standards
08:53:20 <Cale> clahey: That's dependent typing
08:53:34 <clahey> So, even C89 has that.
08:53:40 <simon> can Happy be used to generate LALR(2) parsers?
08:53:47 <Cale> clahey: No it doesn't.
08:53:56 <Cale> Theorem provers like Agda and Coq have that.
08:54:04 <tac> clahey: Something like Printf can be typed properly with dependent types.
08:54:10 <copumpkin> you can sort of do it in Haskell
08:54:14 <copumpkin> but it's much uglier
08:54:20 <tac> ^ indeed this is true
08:54:27 <clahey> tac: I was actually referring to open, but yeah.
08:54:30 <moment> can a type be an instance of a class? like can i do "instance Show MyType where ..." for "type MyType = SomeType"?
08:54:33 <copumpkin> you end up having to reflect parts of the value into the type
08:54:35 <mm_freak> clahey: a definition is polymorphic, when it has a "forall" in the type…  your example has a dependent forall, but in a dependently typed language types are usually passed explicitly…  i'd still call that polymorphism, but i'm not sure there
08:54:42 <Jafet> printf(3) is not really considered typed
08:54:57 <Jafet> int printf(char const*, ... // someone got lazy here
08:54:58 <copumpkin> we often write a typed one in agda though
08:55:01 <Cale> clahey: You're referring to things like   replicate :: (n :: Integer) -> a -> Vec n a
08:55:13 <copumpkin> Jafet: then compiler-specific extensions were made to help you ensure it was well typed
08:55:16 <simon> moment, if you do, you get a warning that can be suppressed.
08:55:22 <Cale> clahey: Where the length of the vector is mentioned in the type, and occurs as a value parameter to the thing?
08:55:26 <copumpkin> Cale: damn, can I have negative-length vectors??
08:55:29 * copumpkin runs
08:55:32 <Cale> copumpkin: heh
08:55:37 <Jafet> covectors
08:55:39 <quicksilver> copumpkin: there's not much else do do in Agda, after all. So you might as well pass the time writing printf over and over again.
08:55:50 <copumpkin> I wonder
08:55:56 <copumpkin> if the grothendieck group can be extended to lists
08:55:57 <tac> quicksilver: ;P
08:56:02 <copumpkin> in a meaningful way
08:56:08 <simon> moment, you need the TypeSynonymInstances compile flag.
08:56:09 <copumpkin> it seems like it should be
08:56:18 <clahey> Cale: I'm referring to a function that takes a different number of arguments based on the value of earlier arguments.
08:56:29 <simon> moment, or instead use newtype MyType = MyType SomeType
08:56:29 <Cale> copumpkin: y u no just free group?
08:56:47 <clahey> Cale: f(n), but if n == 0, you need to call f(0, "More info")
08:56:54 <simon> moment, the latter is more idiomatic, I think.
08:56:55 <mcstar> mm_freak: is there a difference between a thunk and a boxed value in ghc?
08:56:59 <copumpkin> Cale: is that different?
08:57:05 <mcstar> i.e. the boxing itself...
08:57:14 <mm_freak> mcstar: boxing is a concept, a thunk is an implementation detail
08:57:17 <Jafet> > printf "%d%s" 8 "-)" :: String
08:57:18 <lambdabot>   "8-)"
08:57:33 <Cale> copumpkin: Grothendieck group is similar, but builds an abelian group from a commutative monoid, rather than a group from a set.
08:57:35 <mm_freak> mcstar: boxing really just means that a value may be unevaluated
08:57:44 <copumpkin> oh, and lists aren't commutative
08:57:47 <copumpkin> silly me
08:57:53 <fmap> moment: note you can't have different instances for MyType and SomeType
08:58:00 <mcstar> mm_freak: but dont these concepts coincide with ghc?
08:58:04 <Cale> But they're both adjoints, surely.
08:58:07 <clahey> Cale: But they always return the same value.
08:58:07 <fmap> moment: even with extensions
08:58:15 <clahey> Cale: It really doesn't matter if it has a name though.
08:58:43 <copumpkin> Cale: do you know how the grothendieck group works for getting the rationals out of the integers? the special treatment of a 0 denominator is annoying, but it seems like it could be overcome
08:58:49 <mm_freak> mcstar: "is there a difference between a building and the city hall?"
08:59:18 <mcstar> usually there is
08:59:18 <Cale> copumpkin: The Grothendieck group construction is left adjoint to the functor which forgets that an abelian group is anything more than a commutative monoid, and the free group is left adjoint to the functor which forgets that a group is anything more than a set.
08:59:24 <clahey> refried_: Sorry about the tangent from what haskell actually has.
08:59:26 <mcstar> since not every building is a city hall
08:59:28 <copumpkin> Cale: yeah
08:59:31 <copumpkin> I get that
08:59:36 <tac> > printf "%s%d" ":" "("
08:59:38 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:59:38 <lambdabot>    `GHC.Show.Show a'
08:59:38 <lambdabot>      a...
08:59:42 <mm_freak> mcstar: but you get the point…  thunks are how GHC implements boxing
08:59:53 <ziman> > (+1)
08:59:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
08:59:55 <lambdabot>    arising from a use of `...
08:59:56 <mm_freak> in other compilers you may get entirely different things
08:59:59 <dmwit> > printf "%s%d" ":" "(" :: String
09:00:00 <lambdabot>   ":*Exception: Printf.printf: bad argument
09:00:04 <mcstar> mm_freak: thanks! to the point at last... XD
09:00:06 <mm_freak> but they are implementation details
09:00:18 <Cale> copumpkin: Well, hmm
09:00:35 <Cale> copumpkin: So if we start from the commutative monoid of integers under multiplication, you mean?
09:00:38 <Jafet> In C, you can pass the wrong types to printf. In Haskell, you can pass the wrong format string to printf.
09:00:42 <mm_freak> mcstar: it's just that your question didn't really make sense to me =)
09:00:45 <copumpkin> Cale: yeah
09:00:57 <copumpkin> Cale: the pattern seems almost identical to how you take a pair of naturals and quotient it
09:00:57 <HugoDaniel> does isEmptyChan blocks on a empty chan ?
09:01:08 <copumpkin> Cale: but I haven't seen it included as an example on the wikipedia page
09:01:12 <copumpkin> so perhaps it doesn't quite work out
09:01:23 <tac> Haskell's type safety is mostly for show and pragmatism. It's so easy to break :)
09:01:37 <dmwit> HugoDaniel: I should think not.
09:01:38 <copumpkin> HugoDaniel: that'd be pretty useless if it did :P
09:02:02 <Tehnix> does anybody know of any good documentation of the lambdabot? like the configuration and such :/
09:02:08 <HugoDaniel> :)
09:04:34 <Cale> copumpkin: I think maybe we get something a bit weird. After all, what's the image of 0?
09:04:49 <copumpkin> that's the thing
09:04:56 <copumpkin> it _almost_ works, except around 0
09:05:04 <Cale> copumpkin: Everything has an inverse in the image, so there will be a [0]^-1
09:05:06 <copumpkin> which is frustrating :P
09:05:42 <watwat> i have a list of elements and would like to perform an operation on only one of those elements, how would you suggest i do that?
09:06:06 <tac> @type (!!)
09:06:07 <dmwit> step 1: rethink your program design
09:06:09 <lambdabot> forall a. [a] -> Int -> a
09:06:14 <rwbarton> if you just try to group complete {integers under multiplication} you get 0 yes
09:06:16 <Cale> watwat: break the list into parts, apply the operation, and put the list back together again. You can make a function to do this, but it's an unnatural thing to do to a list.
09:06:55 <Cale> (so if you need to do it a lot, you may want some other data structure instead)
09:07:06 <clahey> Perhaps a Zipper on the list?
09:07:08 <dmwit> Isn't the Grothendieck construction general enough to complete other structures? Like... fields?
09:07:24 <watwat> Cale: why is this unnatural?
09:07:58 <clahey> watwat: Lists in haskell are an immutable singly linked list.
09:08:04 <Cale> watwat: A list is a bit like a loop which hasn't happened yet. This operation is similar to "how do I make the 5th iteration of my loop do something different from the others?"
09:08:06 <dmwit> Unnatural is the wrong word, because it's so subjective. O(n) is the right word; it's very objective.
09:08:23 <copumpkin> @remember Cale A list is a bit like a loop which hasn't happened yet. This operation is similar to "how do I make the 5th iteration of my loop do something different from the others?"
09:08:23 <lambdabot> Good to know.
09:08:32 <rwbarton> which suggests another way to do it
09:08:45 <clahey> Oh, right, they're a lazy immutable singly linked list.  Good point.
09:08:58 <rwbarton> zipWith (\i x -> if i == i0 then f x else x) [0..] xs
09:09:26 <byorgey> looks like an indexed traversal =)
09:09:53 <typoclass> watwat: could you give us a little more details what you're planning to do?
09:11:03 <clahey> rwbarton: Which is basically O(n) since it adds at least 1 evaluation for every list element.
09:11:07 <tac> copumpkin: if (i == 4) break;
09:11:16 <tac> Good old trusty reliable break :)
09:11:24 <copumpkin> well, you don't want to break
09:11:27 <clahey> rwbarton: If you define it by hand, you can easily get O(k)
09:11:28 <copumpkin> you just want it to do something different
09:11:36 <tac> indeed
09:11:40 <dmwit> take 5 is a bit like if (i == 4) break;
09:11:53 <tac> copumpkin: I could imagine doing something like that with a careful use of goto
09:11:59 <dmwit> Incidentally, Take Five is also a sublime piece of music.
09:12:11 <tac> Or, since this is a functional language, let's just use continuations :P
09:12:26 * copumpkin continues to use continuations
09:13:08 * mm_freak ntinuations to use ntinues
09:13:34 <clahey> I'm curious.  Is splitAt n efficient in only iterating over the first n elements one time?
09:13:43 * tac still hasn't wrapped his head around Haskell's Cont monad :<
09:13:49 <typoclass> > (\(xs, y:ys) -> xs ++ (toUpper y) : ys) (splitAt 5 "lolcats") -- watwat, you might simply use something like this
09:13:51 <lambdabot>   "lolcaTs"
09:13:54 <dmwit> It is in GHC, though it's not required to be by the spec.
09:14:02 <Cale> watwat: To sort of flesh out this analogy, a loop either never occurs (because its condition isn't met), or it consists of a single iteration followed by another loop. This is analogous to how a list is either empty, or consists of a single element followed by another list.
09:14:06 <clahey> :t (***)
09:14:07 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:14:14 <clahey> The definition as splitAt n = take n &&& drop n seems like it would
09:14:15 <watwat> i have lists of type [[(String, Numeric)]] -- let's say [ [ ("nnn", 1) ]. [ ("nnn", 2), ("iii", 3) ] ]  --- and want to perform an update on this list to change the first occurrence of "iii"
09:14:21 <clahey> would iterate over them all twice.
09:14:25 <mm_freak> tac: newtype Cont r a = Cont ((a -> r) -> r)…  it's a function that passes its result to a continuation instead of just returning it
09:14:27 <tac> Though I'd really like to try Cont in idris or something, since Cale mentioned a while back that callCC has the "wrong type" in Haskell
09:14:37 <dmwit> clahey: Hence my comment re: GHC vs. the spec.
09:14:37 <Cale> tac: wait, what?
09:14:45 <clahey> dmwit: Got it.
09:14:45 <copumpkin> what's wrong with it?
09:14:49 <Cale> tac: I'm not sure I would have said that :)
09:14:57 <Cale> tac: But it is in some way true.
09:14:58 <tac> It was a long time ago, Cale. You mentioned that callCC was not as polymorphic as it could be in the stdlibs
09:14:59 <clahey> dmwit: Even at -O0 -prof or do you not know?
09:15:07 <tac> Cale: it requires rank-2 poly
09:15:19 <copumpkin> well
09:15:28 <dmwit> clahey: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#splitAt
09:15:30 <Cale> Well, yeah, this is true.
09:15:31 <dmwit> enjoy
09:15:49 <tac> I think it was related to this?
09:15:50 <tac> http://www.haskell.org/haskellwiki/MonadCont_done_right
09:15:51 <Cale> In a way, anyway
09:15:59 <dmwit> clahey: grep for splitAt (I# n#) if you want to get straight to it.
09:16:00 <tac>     callCC :: ((a -> (forall b. m b)) -> m a) -> m a
09:16:36 <clahey> dmwit: Ah, and USE_REPORT_PRELUDE says "make it inefficient" basically (in this case.)
09:16:49 <Cale> tac: At the same time, the callCC which is in the libraries has deep connections to a bunch of other stuff, which I'm not sure is true about the generalised one.
09:16:51 * dmwit nods affirmatively
09:16:52 <clahey> watwat: Why do you want to do that?
09:17:00 <Jafet> @src sortBy
09:17:00 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
09:17:13 <tac> @type callCC
09:17:16 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
09:17:45 <watwat> clahey: after reading new values from input
09:17:47 <Cale> It hurts my head to think about what it really means to move the forall b inward like that, when you generalise this.
09:17:49 <hiptobecubic> callCC is confusing
09:17:58 <tac> Cale: indeed :)
09:18:05 <tac> I'd like to try writing it up in Agda or Idris some time.
09:18:08 <tromp__> call-with-current-confusion
09:18:14 <clahey> watwat: Ah, so you have input and you want to do this single step in processing and then output the rest?
09:18:25 <Eduard_Munteanu> Hrm, I wonder if it's related to Ran?
09:18:26 <mcstar> if you have trouble, callCC-1-800!
09:18:33 <Cale> tac: I'm talking about how this actually means something with respect to vector spaces and the double dual, and all that sort of thing :)
09:18:51 <clahey> callCC-busters
09:19:00 <watwat> clahey: yes
09:19:05 <clahey> watwat: Is this for a class?
09:19:34 <tac> Cale: How do callCC and continuations look in Category Theory? Are they relevant at all?
09:19:39 <tac> (Aren't they related to Yoneda?)
09:20:10 <Cale> tac: Well, there's this thing called the codensity functor
09:20:27 <watwat> clahey: well, it could be :D
09:20:30 * nand` wonders if zippers could be used for watwat's use case; by constructing a modified version of a traversal that only matches elements based on a certain predicate
09:20:33 <Cale> hmm
09:20:51 <Eduard_Munteanu> http://comonad.com/reader/2008/kan-extensions/ also shows a similarity.
09:21:04 <nand`> something like (a -> Bool) -> Simple Traversal s a -> Simple Traversal s a
09:21:06 <Cale> tac: See, now you've got me worrying about where all the foralls go :)
09:21:12 <tac> hehehe
09:21:19 <clahey> watwat: So you want to write a function called changeFirstIII
09:21:28 <clahey> watwat: So start writing it.  What's the type?
09:21:55 <rwbarton> if it is for a class then presumably you are expected to write it with explicit recursion
09:22:30 <rwbarton> rather than using the lens library
09:22:32 <clahey> rwbarton: That was my plan.
09:22:40 <watwat> changeFirstIII :: String -> Integer -> [[(String, Integer)]] -> [[(String, Integer)]] i suppose
09:22:59 <clahey> rwbarton: Sure, but after he does, will you teach me how to do it using lenses please?  :)
09:23:07 <clahey> watwat: What is the first string there?
09:23:10 <mcstar> are haskellers disappointed, when people stop them on the street, and ask, excuse me sir, whats the t....
09:23:15 <mcstar> time?
09:23:16 <Cale> tac: But yeah, there are all kinds of connections with Yoneda and Kan extensions too. Edward Kmett has looked at that in more detail than I have.
09:23:39 <typoclass> watwat: that looks good so far
09:23:49 <clahey> typoclass?
09:24:05 <Cale> tac: But for example, if you think about vector spaces, the double dual of a vector space is the space of linear maps (V -> F) -> F, which is obviously just Cont F V ;)
09:24:27 <rwbarton> speaking of which, has anyone used Codensity IO to do FFI marshalling stuff
09:24:29 <clahey> watwat: Actually, I have guesses about the first two parameters, but what does [[(String, Integer)]] mean?
09:24:38 <Cale> tac: and the return for that monad is just the embedding V -> Cont F V into the double dual
09:24:57 <tac> I'm not sure what that means :)
09:25:02 <Cale> tac: Oh, okay
09:25:14 * lispy waves to the good people of #haskell
09:25:16 <mcstar> clahey: [[a]] is correct, according to his inline paste
09:25:16 <lispy> hello!
09:25:20 <tac> You mentioned vector spaces earlier, too, and I didn't know how continuations apply to vectors
09:25:23 <moment> is there an online haskell interpreter somewhere?
09:25:34 <lispy> moment: tryhaskell.org
09:25:34 <Cale> tac: Okay, so do you know what the dual space of a vector space is?
09:25:39 <lispy> moment: also, lambdabot
09:25:44 <clahey> mcstar: Oh, in that case I don't know what the function should do.
09:25:47 <lispy> > [1..3] -- moment
09:25:48 <lambdabot>   [1,2,3]
09:25:53 <tac> Cale: The dual of a vectorspace is a linear operator to R
09:26:04 <tac> a partially-applied dot product
09:26:06 <Cale> tac: The space of all linear functionals
09:26:08 <moment> thanks!
09:26:09 <tac> yeah
09:26:14 <Cale> from the vector space to the underlying field
09:26:20 <Cale> (which might be R)
09:26:25 <Cale> But I'm going to use F :)
09:26:26 <moment> > take 4 [(x,y) | x <- [1..] , y <- [1..]]
09:26:27 <lambdabot>   [(1,1),(1,2),(1,3),(1,4)]
09:26:45 <tac> ah yeah
09:26:45 <clahey> watwat: What is changeFirst "iii" 5 [[("xxx", 3), ("iii", 7)], [("iii", 3)]]
09:26:52 <Cale> So in the category of vector spaces, that's all the linear maps V -> F
09:26:53 <tac> It just needs to be a field
09:26:56 <clahey> mcstar: Good catch though.
09:26:56 <tac> yep
09:26:59 <Cale> which themselves form a vector space
09:27:19 <Cale> Now, there's no natural way to take a vector in V and turn it into a functional V -> F
09:27:27 <watwat> clahey: [[("xxx", 3), ("iii", 5)], [("iii", 3)]]
09:27:31 <Cale> (unless you have an inner product, as you pointed out)
09:27:41 <tac> yeah
09:27:53 <tac> "natural" as in a universal construction?
09:27:56 <clahey> watwat: Interesting.
09:27:59 <Cale> However, there is a natural way, independent of any details of what V is, to take a vector in V and get a functional in the *double* dual
09:28:04 <Cale> (V -> F) -> F
09:28:19 <clahey> watwat: So, yeah, you got the type right and I got it wrong.  :)
09:28:45 <tac> Cale: is that just id?
09:28:50 <Cale> well, no
09:28:57 <clahey> watwat: So, to calculate the value for the top level list, what do you need to know about the first lower level list?
09:29:14 <Cale> We're writing a function whose "type" is  V -> ((V -> F) -> F)
09:29:23 <Cale> or, more classically, V -> V**
09:29:27 <tac> yeah
09:29:54 <Cale> So with our Haskell-caps on, we know that the easy way to think of this is as a function of two parameters
09:30:06 <Cale> embed v f = ...
09:30:08 <tac> yeah
09:30:09 <tac> f v
09:30:12 <Cale> right :)
09:30:24 <nand`> looks like the yoneda lemma
09:30:27 <watwat> clahey: well, nothing, really ... it should just modify the first value matching a given key
09:30:46 <tac> nand`: I don't know what the yoneda lemma is, but it looks like it would be the yoneda lemma to me too
09:31:14 <Cale> and often in linear algebra courses, you'll even prove that this is natural in a particular sense (though often it isn't explained too clearly what natural means in full generality)
09:31:17 <clahey> watwat: What does modify mean though in a pure functional language?
09:31:26 <clahey> watwat: You can't modify the value.  You're returning a different value.
09:31:43 <mcstar> watwat: a list is always immutable, dont say modify, you need to reconstruct the list up to the point you want to change
09:31:56 <clahey> You need to reconstruct the whole list.
09:32:01 <mcstar> no
09:32:03 <Cale> But what we have here is a natural transformation from the identity functor on the category of F vector spaces to the double dual functor.
09:32:05 <clahey> It just might be a trivial reconstruction.
09:32:07 <mcstar> the tail is untouched
09:32:09 <Cale> (and indeed, it is a functor!)
09:32:26 <tac> Cale: nice
09:32:39 <nand`> yoneda lemma is that for some functor f; f a ≅ Reader a → f; no?
09:33:03 <clahey> mcstar: In the actual computer, the memory is untouched, but you still need to define a value for the rest of the list, even if it's id.
09:33:15 <Cale> For finite dimensional vector spaces, you can show that V is isomorphic to V -> F, because they have the same dimension, but there's no natural map which does that -- you have to choose a basis.
09:33:21 <clahey> That's how I would think of it when trying to come up with an answer.
09:33:39 <mcstar> i dont follow
09:33:39 <nand`> in Haskell; f a ⇔ forall b. (a -> b) -> f b
09:33:48 <Cale> (for infinite dimensional spaces, V -> F is always higher dimension than V)
09:33:49 <typoclass> > map (\x -> if x == 7 then 333 else x) [1..10] -- watwat, here is an example how you can "modify" a list. this takes the list [1..10] and produces a new list, which is mostly the same but with one element changed
09:33:51 <lambdabot>   [1,2,3,4,5,6,333,8,9,10]
09:34:07 <clahey> typoclass: Yeah, but map isn't useful here.
09:34:20 <clahey> typoclass: I'm not sure any of the built in recursion systems are, but I could be wrong.
09:34:21 <mcstar> > let t = [2..5] in (1:t, 0:t)
09:34:22 <lambdabot>   ([1,2,3,4,5],[0,2,3,4,5])
09:34:31 <Cale> tac: Now, we can interpret this all in another way too
09:34:34 <mcstar> t is shared between the two lists in the pair
09:34:43 <clahey> mcstar: It doesn't look like it's shared.
09:34:54 <clahey> mcstar: There's no way to tell from the output that it's shared, only from the execution time.
09:34:56 <clahey> and memory.
09:34:57 <Cale> tac: Let's stare at (V -> F) -> F again, and this time interpret F as "False"
09:35:03 <Cale> and -> as implication
09:35:07 <clahey> mcstar: That's what I mean.
09:35:14 <mcstar> clahey: it is shared, since i used the same tail for both
09:35:19 <Cale> tac: V -> F then means "not V"
09:35:25 <watwat> clahey: yes, you're right, it's just a trivial reconstruction... i'm a noob, you see :D
09:35:29 <clahey> mcstar: But that's an implementation detail.
09:35:32 <Cale> tac: and (V -> F) -> F is "not (not V)"
09:35:33 <mcstar> it is not just an implementation detail
09:35:49 <clahey> mcstar: Let's help watwat and then continue this discussion?
09:35:53 <Jafet> mcstar: it is an implementation detail of haskell
09:35:54 <Cale> tac: and now return :: V -> not (not V)
09:35:55 <tac> double negation D:
09:36:08 <Jafet> But all implementations use it
09:36:09 <tac> Can you go the other way, too??
09:36:09 <mcstar> Jafet: of ghc or of haskell?
09:36:15 <Cale> nope!
09:36:20 <tac> (thank god!)
09:36:27 <typoclass> watwat: have you seen the code i wrote above?
09:36:31 <Cale> HOWEVER
09:36:39 <watwat> clahey: thanks, i figured it out based on your answers
09:36:39 <clahey> watwat: So, let's first write a function to change a single list instead of a nested list.
09:36:50 <clahey> watwat: Oh, want to paste your solution?
09:36:52 <Cale> You do have join
09:36:58 <Jafet> GHC implements Haskell, and sharing is an implementation detail.
09:37:15 <clahey> watwat: I'd love to see it.
09:37:15 <Cale> join :: not (not (not (not V))) -> not (not V)
09:37:47 <mm_freak> sharing isn't an implementation detail…  it's actually quite observable
09:37:55 <tac> ahhh
09:37:55 <mm_freak> it's just semantically insignificant
09:37:58 <Cale> tac: So once you've already double negated, you can remove additional double negations :)
09:38:01 <clahey> mm_freak: How is it observable?
09:38:03 * nand` .oO( join :: not (not V) -> not V -- thank god it isn't that )
09:38:15 <Jafet> It's observable outside of pure fluffy haskell land
09:38:15 <Cale> tac: and this is how classical logic embeds into intuitionist logic
09:38:17 <tac> Cale: that's why monads require you to go from T^3 -> T^1
09:38:30 <Cale> T^2 -> T
09:38:32 <mm_freak> clahey: let me write an example
09:38:43 <tac> well, I mean in the laws, Cale
09:39:00 <mm_freak> clahey: my earlier paste is actually a very good example
09:39:03 <mm_freak> http://hpaste.org/76991
09:39:05 <mcstar> also, heh
09:39:07 <mcstar> -also
09:39:11 <tac> Cale: http://upload.wikimedia.org/wikipedia/commons/thumb/2/2b/Monad_multiplication_explicit.svg/246px-Monad_multiplication_explicit.svg.png
09:39:12 <Cale> oh, well, yeah, but T^3 V here is not (not (not (not (not (not V)))))
09:39:13 <tac> ^ there
09:39:24 <tac> but I see what you mean
09:39:25 <mm_freak> clahey: [4~that code has O(n) complexity…  without sharing it would have O(n²) complexity
09:39:38 <tac> You embed classical into intuition by double-negating everything first
09:39:43 <Cale> yeah
09:39:46 <copumpkin> sort of
09:39:46 <tac> COOL!
09:39:51 <copumpkin> not quite everything
09:39:53 <tac> copumpkin: don't be a debbie downer
09:39:55 <clahey> mm_freak: Yes, so when evaluating efficiency, you need to take into account sharing, but when evaluating return value, you don't.
09:39:58 <tac> copumpkin: :) What is missing?
09:40:08 <clahey> mm_freak: Does the Haskell spec specify computational efficiency?
09:40:18 <mm_freak> dunno, but i doubt it
09:40:21 <copumpkin> the double negation of (forall a. Either a (Not a)) is Not (Not (forall a. Either a (Not a)))
09:40:24 <Jafet> Does anyone use the Haskell spec?
09:40:25 <copumpkin> and that isn't provable intuitionistically either
09:40:26 <clahey> mm_freak: Then it's an implementation detail.
09:40:30 <clahey> Jafet: This is true.
09:40:37 <mm_freak> but practically haskell programmers rely on sharing a lot
09:40:41 <clahey> mm_freak: True.
09:40:41 <copumpkin> forall a. Not (Not (Either a (Not a))) is
09:41:04 <mm_freak> so it's anywhere from unfair to dangerous to call sharing an implementation detail
09:41:05 <Cale> Yeah, I've been ignoring quantifiers
09:41:13 <mm_freak> i'd say a non-sharing compiler is actually quite useless
09:41:30 <nand`> I thought Haskell, in its defined operational semantics, distinguished itself from regular nonstrictness to actual laziness, which implies sharing of results
09:41:32 <Jafet> Well, stepeval doesn't do sharing, but benm probably considers that a bug.
09:41:38 <Cale> So if we're just talking about just propositional logic, it's easy :)
09:41:41 <nand`> but I've never actually checked
09:41:45 <tac> copumpkin: Cale: I suspect there's a full embedding that's just slightly more involved with quantifiers?
09:41:48 <Jafet> nand: what operational semantics
09:42:05 <mm_freak> nand`: sharing is little to do with laziness/strictness
09:42:08 <clahey> mm_freak: Even as a pedagogical tool when you're first starting with the language?
09:42:10 <mm_freak> is → has
09:42:23 <Jafet> clahey: yes
09:42:33 <Cale> Another thing is that there ought to be an interpretation of callCC in terms of vector spaces
09:42:37 <clahey> Jafet: It's dangerous as a pedagogical tool?  Okay.
09:42:44 <Cale> But nobody ever talks about that
09:42:44 <Jafet> This isn't agda, people actually run programs written in haskell.
09:42:49 <copumpkin> tac: more info here: http://en.wikipedia.org/wiki/Double-negation_translation
09:42:58 <Jafet> And sharing is an important detail.
09:43:13 <clahey> Jafet: Oh, I definitely think it should be taught.  I'm just not sure it should be taught on the first day.
09:43:18 <watwat> clahey: i did something like this http://hpaste.org/76999, any suggestions on how to improve this will be greatly appreciated
09:44:30 <Jafet> There is no first day learner around here
09:44:45 <Jafet> So I don't know who you're referring to
09:44:50 <tac> copumpkin: ty
09:44:56 <clahey> Jafet: Fair enough.
09:45:22 <clahey> watwat: Firstly, instead of using head and tail, I would use a pattern match using :.
09:45:25 <Cale> tac: Haskell's notation is *really* clean when it comes to polymorphic and higher-order things, even cleaner than most mathematical notation, so it lets us talk about some things which would be messy to discuss with ordinary notation.
09:46:36 <tac> Cale: indeed. I've done Agda, so I know how much implicit "plumbing" is done by the unification algorithm
09:47:05 <tac> (which shows up in things like "let" and value restrictions on mutable vars)
09:47:22 <Cale> (on the other hand, it can make it more work for the reader to typecheck some things because so many things are left implicit)
09:48:02 <Jafet> data EnvFrames a = EnvFrames (Map Var Int) (Map Int (Map Var a))
09:48:12 <Jafet> lets you look up variables
09:48:26 <tac> Cale: it's definitely a double-edged sword
09:48:38 <tac> anyway, I have to get lunch, and then a meeting
09:48:42 <Jafet> watwat: use Data.Map instead
09:48:49 <tac> Thanks for your time explaining that analogy Cale
09:48:54 <Cale> tac: But yeah, even the join for this monad is never discussed in elementary linear algebra courses :)
09:49:04 <marzy> hello. can I have a data type similar to this one?   data Value = 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | Jack | Queen | King | Ace
09:49:37 <clahey> Jafet: Why use Data.Map?  That's still gonna be O(n log n) where defining it yourself recursively is going to be O(n) with a fairly small constant?
09:49:39 <Cale> marzy: yes, if you stick some capital letter before the numbers
09:49:53 <hpc> data Value = V2 | V3 | ...
09:49:56 <marzy> Cale ah I see
09:49:58 <marzy> thanks
09:49:59 <Jafet> clahey: what
09:50:07 <hpc> or personally i would go with data Value = Two | Three | ...
09:50:14 <Jafet> What is still going to be O(n log n) and what is n?
09:50:19 <marzy> yes it make sense, 2 has to differ from integer 2
09:50:33 <marzy> hpc yeah probably nicer
09:50:39 <clahey> Jafet: You were gonna build maps, change a value in the map, and then turn it back into a list, right?
09:51:00 <Jafet> That's what watwat is doing
09:51:05 <Jafet> If you think it's dumb, tell him
09:51:14 <clahey> Jafet: I will.
09:51:20 <clahey> Jafet: But I was starting with low hanging fruit.
09:51:23 <typoclass> watwat: nice paste, not bad. i agree with clahey on using a little more pattern matching, i think it'll get prettier. secondly, it's a little funky because you mix using a Data.Map and a regular list, converting between them. (see the fromList and toList)
09:51:34 <mcstar> dumbbell
09:52:44 <clahey> watwat: So, specifically, after mentioning pattern matching, I was going to suggest that instead of using alter and fromList and so forth that you write your own function to alter the individual lists.
09:52:47 <nand`> mm_freak: oh, I had a slighlty flawed understanding of the term ‘lazy’; there is a distinction between ‘lazy’ and ‘non-strict’ but it isn't as great as I thought
09:53:19 <clahey> The sub lists.
09:53:48 <nand`> the opposite of ‘lazy’ would be ‘eager’, no?
09:54:03 <Jafet> Nearly all the functions that you need to work on lists have already been written
09:54:06 <Jafet> :t break
09:54:07 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
09:54:29 <Jafet> If you (or worse, your instructor) insist on using lists for this
09:55:13 <quicksilver> nand`: the words aren't used consistently.
09:55:35 <moment> is there a function Double -> Int ?
09:55:42 <srhb> nand`: What I have learned from the discussion is that the antonym of lazy is nonlazy and the antonym of strict is non-strict and that there is no morphism that can possibly bring you from one of the lazies to one of the stricts.
09:55:49 <srhb> But I mostly use that rule to avoid ridicule.
09:55:50 <hpc> :t floor -- moment
09:55:52 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
09:55:56 <quicksilver> nand`: some people suggest that lazy means 'evaluate at the last possible moment'; other people suggest it means 'maximal sharing of evaluated results'
09:56:16 <hpc> > (floor 5.0) :: Int
09:56:17 <lambdabot>   5
09:56:33 <nand`> according to the definitions I just read <http://www.haskell.org/haskellwiki/Lazy_vs._non-strict> it means the former
09:56:34 <hpc> > floor (0/0) :: Int -- yay NaN!
09:56:36 <lambdabot>   0
09:56:42 <hpc> > floor (0/0) :: Integer -- yay NaN!
09:56:43 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
09:56:45 <nand`> I think a fair term for the latter is ‘sharing’, not ‘laziness’
09:57:58 <nand`> by my current understanding, strictness = evaluating from within outwards; nonstrictness = evaluating from outside inwards; laziness = evaluate at the last possible moment; eagerness = evaluate as soon as possible
09:58:32 <quicksilver> nand`: but compare the well-known (and standardised name) "full laziness transform"
09:58:42 <quicksilver> nand`: which is all about sharing and not really at all about reduction order.
09:58:57 <clahey> Jafet, watwat: And for the record, I was never going to say dumb, just inefficient.
09:59:14 <quicksilver> nand`: also the paper "Complete Laziness"
09:59:16 <nand`> but more broadly; I think ‘laziness’ makes sense as ‘avoid unnecesasry computations’, which encompasses both sharing and non-eagerness
09:59:34 <clahey> Jafet: It throws me off that ++ is somewhat efficient.
09:59:39 <quicksilver> nand`: (my point is - haskellwiki is non canonical, that's just one consistent point of view but other people definitely use the words in different senses)
10:00:01 <clahey> Jafet: I feel like using break and ++ still doubles the number of reductions you need to do, but perhaps the compiler optimizes that away.
10:00:27 <dada-cetacean> is there a way to have lambdabot process "let" commands like ghci does, for remembering functions?
10:00:45 <clahey> Oh, ++ isn't efficient.  It's just lazy.  I think I may have just had a revelation.
10:00:58 <typoclass> dada-cetacean: yes, you can use @let to some extent
10:01:09 <Jafet> clahey: the only reason to use lists for this is because you can't bother to use something like Map, so it's pretty irrelevant what the constant factors are
10:01:46 <clahey> Jafet: Why would you use Map if you were reading it from a file and writing to another file?
10:02:20 <nand`> there's a @let command
10:02:22 <nand`> (half of lambdabot actually uses mueval which is unrelated to ghci, the other half uses GHCi; it's a bit tricky to get definitions to be consistent in both)
10:02:41 <Jafet> Who is reading from a file and writing to another file?
10:03:34 <clahey> Jafet: That's true.  We don't know who defined the type of the function as being [[]] -> [[]].
10:03:41 <hpc> the ghci parts allow more definitions than mueval
10:03:48 <hpc> because type/kind queries don't execute code
10:03:50 <watwat> clahey, Jafet: thanks for the help, i'll try and write some less dumb code ;)
10:04:23 * hackagebot language-boogie 0.1 - Interpreter and language infrastructure for Boogie.  http://hackage.haskell.org/package/language-boogie-0.1 (NadiaPolikarpova)
10:04:38 <clahey> watwat: I'm curious to see how close your final result is to what I imagined.
10:05:05 <clahey> rwbarton: Now, how would lenses help here?
10:05:09 <clahey> rwbarton: If you don't mind my asking.
10:05:19 <mm_freak> clahey: (++) isn't inefficient
10:05:22 <rwbarton> I haven't used lenses :P
10:05:28 <rwbarton> but, let's see!
10:05:52 <nand`> how would lenses help with what?
10:05:57 <mm_freak> clahey: it's just that you may be abusing lists =)
10:06:02 <clahey> mm_freak: I had the idea that it was free because of laziness, but it's still O(n) it's just that the n is spread out over the evaluation?
10:06:18 <mm_freak> yeah
10:06:26 <mm_freak> > cycle "abc"
10:06:27 <lambdabot>   "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
10:06:29 <mcstar> i think that problem needs a bit of the list monad
10:06:31 <mm_freak> @src cycle
10:06:31 <lambdabot> cycle [] = undefined
10:06:31 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
10:06:43 <mcstar> it is an interesting compositional problem
10:06:50 <mcstar> it is a double map
10:07:01 <mcstar> but as soon as a condition succeeded, you have to just id the rest
10:07:21 <clahey> mcstar: Not a double map, just a list of maps, n'est?
10:07:36 <mcstar> map (map..)
10:07:43 <mcstar> conceptually
10:07:55 <clahey> Wouldn't that be [(a, [(b, c)]]
10:07:58 <clahey> Wouldn't that be [(a, [(b, c)])]
10:08:08 <clahey> Instead of [[(a, b)]]?
10:08:12 <mcstar> no
10:08:22 <mcstar> it is a list of lists
10:08:27 <mcstar> of pairs
10:09:17 <mcstar> im sure this can be generalized nicely to arbitrary nested lists, and given number of substitutions, not just one
10:09:29 <scp> Haskellians
10:09:49 <scp> Is it possible to have a type take a function as a parameter?
10:09:57 <clahey> mcstar: Perhaps the State monad would be useful.
10:10:16 <mcstar> maybe, im not sure
10:10:21 <scp> For example, BinarySearchTree (k -> k -> Bool) k v
10:10:30 <nand`> perhaps to arbitrary traversals; maybe plated would come in handy also
10:10:41 <quicksilver> scp: yes.
10:10:41 <nand`> uh, not plated
10:10:43 <nand`> those generic traversals
10:10:54 <scp> quicksilver: have a google-able keyword for me? =]
10:11:00 <quicksilver> data BinarySearchTree k v = BST (k -> k -> Bool) k v
10:11:07 <quicksilver> is a perfectly valid data type
10:11:11 <quicksilver> if that is indeed what you meant.
10:11:23 <mcstar> "type take a function"
10:11:30 <scp> in retrospect
10:11:33 <scp> my idea doesn't make sense
10:11:39 <quicksilver> often the case
10:11:43 <quicksilver> don't be disheartened
10:11:46 <scp> =] thanks though
10:11:53 <quicksilver> just use the experience to form a better idea
10:12:03 <scp> indeed
10:12:11 <mcstar> i like sshfs over scp personally...
10:12:40 <scp> mcstar: =P
10:12:49 <nand`> sshfs? does that let me mount a remote partition as if it were local?
10:12:58 <scp> ironically, I'm an rsync guy myself
10:13:02 <rwbarton> I want to filter a Traversal but I don't see how and I'm not sure it even makes sense
10:13:02 <scp> nand`: yes
10:13:10 <nand`> that sounds super handy; I hate having to use scp
10:13:28 <mcstar> nand`: well, not partition, but folders
10:13:45 <nand`> rwbarton: I've been thinking about how to implement (a -> Bool) -> Simple Traversal s a -> Simple Traversal s a
10:13:50 <scp> ya, you can mount an arbitrary folder from a remote file system
10:13:55 <rwbarton> that sounds like what I want, yes
10:14:19 <ocharles> rwbarton: A traversal can't change the amount of elements, iirc
10:14:22 <ocharles> I think you want a fold, no?
10:14:39 <nand`> rwbarton: I have an idea; let me try
10:15:06 <rwbarton> I don't want to change the number of elements of the structure
10:15:13 <rwbarton> I want to "change the number of elements of the Traversal"
10:15:55 <ocharles> you want to perform 'id x' on some elements, and 'f x' on others, depending on the result of 'p x' ?
10:16:01 <rwbarton> yes
10:16:03 <ocharles> ah, ok
10:16:06 <rwbarton> exactly
10:16:12 <rwbarton> well
10:16:16 <rwbarton> not *quite* exactly
10:16:30 <rwbarton> I want to perform f on the first element that satisfies p
10:16:57 <ocharles> hmm
10:18:02 <Desert> hi
10:18:14 <mcstar> rwbarton: you accepted the challenge? XD
10:18:30 <hiptobecubic> for the list case, you mean something like [if p x then f x else x | x <- mylist] ?
10:18:30 <Desert> what challenge?
10:18:38 <Jafet> http://hpaste.org/77002 even simpler than using lists
10:19:18 <ocharles> rwbarton: I guess you could either use a traversal with state, or zip every element against their index, map and take fst
10:19:20 <mcstar> darpa ai robotics challenge
10:19:33 <c_wraith> isn't there some sort of "first" traversal?
10:19:35 <ocharles> mapAccumLOf might let you get that 'first element' state
10:19:43 <hiptobecubic> @let fWhenP f p x = if p x then f x else x
10:19:45 <lambdabot>  Defined.
10:19:56 <Desert> nope
10:20:09 <nand`> rwbarton: success
10:20:13 <rwbarton> ah?
10:20:16 <ocharles> oh, there is a Data.List.Lens._head, maybe that'd help?
10:20:22 <hiptobecubic> > fmap (fWhenP negate odd) [1..]
10:20:25 <lambdabot>   [-1,2,-3,4,-5,6,-7,8,-9,10,-11,12,-13,14,-15,16,-17,18,-19,20,-21,22,-23,24...
10:20:35 <hpaste> nand` pasted “restricted traversal” at http://hpaste.org/77003
10:20:39 <ocharles> there is also traverseHead :: SimpleIndexedTraversal Int [a] a
10:20:43 <marzy> is there a way to index enum type?  to get the Nth entry
10:20:51 <typoclass> c_wraith: lenses has "_1", not sure if that helps. Control.Arrow provides "first" if you have a 2-tuple
10:20:54 <rwbarton> @type toEnum
10:20:56 <lambdabot> forall a. (Enum a) => Int -> a
10:20:58 <nand`> rwbarton: restrict (>5) traverse %~ negate $ [1..10]  ==> [1,2,3,4,5,-6,-7,-8,-9,-10]
10:21:06 <marzy> thanks
10:21:10 <rwbarton> nand`, nice
10:21:29 <hpaste> “Ertugrul Söylemez” pasted “Printing right-aligned” at http://hpaste.org/77004
10:21:33 <ocharles> nand`: but rwbarton wants to apply f only to first element that satisfies that predicate
10:21:40 <ocharles> or i misunderstood the question
10:21:43 <clahey> rwbarton: I was imagining apply f x = do found <- get; if not found && p x then put True >> return (f x) else return x
10:21:48 <ocharles> also, _head is useless for that so ignore me :)
10:21:51 <hiptobecubic> nand`, that is sexy
10:22:03 <nh2> hi, how would I convert a bytestring to UArray Int Word8 (fast)?
10:22:06 <nand`> ocharles: yeah, but you can now use _head or a zipper or something
10:22:26 <Jafet> nh2: very unsafely
10:22:33 <rwbarton> > (elementOf (restrict even (traverse.traverse)) 0 .~ 4) [[1],[2,3]]
10:22:33 <rwbarton> [[1],[4,3]]
10:22:34 <lambdabot>   Not in scope: `elementOf'Not in scope: `restrict'Not in scope: `traverse'No...
10:22:39 <rwbarton> nand`: it worked ^
10:22:42 <nand`> λ zipper ["foo", "bar", "iii", "iii", "bat"] % fromWithin (restrict (=="iii") traverse) % focus .~ "ooo" % rezip
10:22:44 <nand`> ["foo","bar","ooo","iii","bat"]
10:22:57 <hiptobecubic> rwbarton, what is the 0 for there?
10:23:08 <rwbarton> to just modify the first matching element
10:23:22 <Jafet> nh2: you can probably use the pointer directly to create a UArray
10:23:44 <hiptobecubic> nand`, that is pretty terse...
10:24:00 <clahey> rwbarton, nand` Is there a tutorial for traverse and %~ and .~?
10:24:14 <rwbarton> I heard shachaf was writing one!
10:24:20 <nand`> I think elementOf makes more sense in this context; but with the zipper you can do some more navigating
10:24:46 <nand`> there should be something like elementOf but for the first element, yknow?
10:24:55 <rwbarton> iknow.
10:25:34 <nand`> clahey: there are some pages on the lens wiki
10:25:40 <nh2> Jafet: you mean unsafeCoerce?
10:26:03 <nand`> “More information on the care and feeding of lenses” <- oh edwardk
10:26:43 <Jafet> Lens does need some clear, polished documentation.
10:26:59 <clahey> So, are many people on here in the Boston metropolitan area?  And do you ever get together in person for drinks or anything?
10:27:19 <rwbarton> Jafet: hehe
10:27:25 * Volatile lives in Kållered. It's not in the vicinity.
10:27:52 <Jafet> nh2: no, that wouldn't work
10:28:18 <c_wraith> bgamari: thanks for the patch for lrucache, but you were about 18 hours late. :)
10:28:37 <scp> clahey: all of our bars were blown away yesterday night o_O
10:28:51 <Jafet> It seems that bytestring uses ForeignPtr and UArray just uses ByteArray#, I don't know know if you can make a ByteArray# from a Ptr.
10:29:11 <nh2> Jafet: which then?
10:29:34 <rwbarton> my understanding (very high chance of being wrong) is that the GC can move a ByteArray# but not a ForeignPtr
10:30:55 <rwbarton> nh2: does it really have to be a UArray? array also includes Data.Array.Storable, is that good enough? you can make one of those from a ByteString without copying
10:30:57 <mcstar> there are storable arrays
10:31:05 <c_wraith> rwbarton: well, the ForeignPtr can be moved.  As can the Ptr it wraps.  But Ptr structure is treated as opaque, and GHC doesn't know anything about the memory it points at.
10:31:22 <nand`> oh, the rank 2 type can be relaxed
10:31:24 <rwbarton> sorry, right
10:31:29 <rwbarton> the memory pointed to by the (Foreign)Ptr
10:31:32 <Jafet> Probably the only way to make a ByteArray# is to allocate memory from ghc
10:31:41 <Jafet> So you can't cast things to UArrays
10:31:53 <nh2> rwbarton: I'm afraid yes, because I want to plug it into a library that takes an Uarray
10:32:28 <rwbarton> then i think you need to copy it or be super duper ultra careful with black magic
10:32:50 <clahey> scp: /join #haskell-blah
10:33:55 <nand`> clahey: oh, I forgot to link: https://github.com/ekmett/lens/wiki
10:34:03 <nand`> lens documentation
10:34:55 <bgamari> c_wraith, Thanks!
10:35:29 <bgamari> c_wraith, would a simple patch switching out "undefined" for (error "$SOME_MORE_MEANINGFUL_ERROR_MESSAGE") be acceptable?
10:35:37 <clahey> nand`: Yeah, I found it.
10:35:39 <clahey> nand`: Crazy stuff.
10:36:01 <c_wraith> bgamari: yeah, just make sure you make it against the 1.1-maintenance branch
10:36:02 <clahey> I think Edward Kmett might be a wizard.
10:36:25 <marzy> what is the reason why one can' t use typeclasses as types in declaration?  ie  compare :: Ord -> Ord -> Ordering
10:36:31 <c_wraith> bgamari: mostly because the other branches are in all kinds of experimental-broken states
10:36:36 <mcstar> > case [] of (x:xs) -> 3
10:36:38 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
10:36:41 <mcstar> > case [] of ~(x:xs) -> 3
10:36:42 <lambdabot>   3
10:36:50 <mcstar> now i understand ~ i think
10:36:57 <hpaste> nand` annotated “restricted traversal” with “Restricted Traversal” at http://hpaste.org/77003#a77005
10:37:12 <nh2> rwbarton: I rather copy then. What way should I do this? I can imagine that there are better ways than IArray.array/listArray
10:37:17 <rwbarton> hm
10:37:52 <bgamari> c_wraith, good to know; thanks!
10:38:34 <nand`> latest paste contains an example that's similar to the “replace leftmost iii” thing :)
10:39:00 <rwbarton> nh2: well I guess you could use one of the freeze/thaw functions perhaps
10:39:12 <mcstar> marzy: because, a typeclass is something a type can be part of, but it is not a type in itself
10:39:26 <nand`> @tell edwardk http://hpaste.org/77005
10:39:26 <lambdabot> Consider it noted.
10:39:46 <mcstar> a typeclass doesnt have kinds either, if im correct
10:40:07 <rwbarton> nand`: what happens with the zipper/rightmost stuff if the restricted Traversal is empty?
10:40:22 <Saizan> mcstar: they do now
10:40:29 <Saizan> mcstar: Ord :: * -> Constraint
10:40:33 <mcstar> :(
10:40:51 <mcstar> Saizan: and can they be used as marzy suggests?
10:40:53 <nand`> rwbarton: fromWithin errors; part of its semantics
10:40:57 <Saizan> mcstar: nope
10:41:03 <nand`> the normal ‘within’ would return Nothing
10:41:30 <rwbarton> can you write an example which would, say, modify the rightmost element if there is one but otherwise leave  the structure unchanged?
10:41:54 <rwbarton> or alternatively, return Nothing in that case (otherwise wrap in Just)
10:42:47 <nand`> oh, forgot to import Applicative in the example
10:43:03 <rwbarton> nh2: hm
10:43:07 <rwbarton> possibly you can do this after all
10:43:36 <rwbarton> er, no, never mind
10:44:24 * hackagebot ua-parser 0.2.1 - Port of ua-parser in Haskell  http://hackage.haskell.org/package/ua-parser-0.2.1 (OzgunAtaman)
10:44:26 * hackagebot csv-conduit 0.3.0.3 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.3.0.3 (OzgunAtaman)
10:46:31 <nand`> rwbarton: conceptually, something like case zipper [1,3,5] % within (restrict even traverse) of Just t -> t % rightmost % focus .~ 100 % rezip; Nothing -> error "No such element!!1"
10:46:34 <nand`> you could probably tidy it up with Maybe combinators
10:46:36 <nand`> but then the line becomes awfully long, in a real program I'd split that up
10:47:08 <rwbarton> ah, i see
10:47:57 <nand`> oh, there's a SimpleLensLike synonym
10:48:06 <nand`> so I didn't need Simple (LensLike f) :(
10:48:54 <hpaste> nand` annotated “restricted traversal” with “Restricted Traversal (annotation)” at http://hpaste.org/77003#a77007
10:50:37 <Jafet> Apparently, you *can* convert bytestrings to UArrays
10:51:27 <Jafet> UArray 1 n n (unsafeCoerce# ((\(Ptr x) -> x) $ (`plusPtr` negate 8) $ unsafeForeignPtrToPtr $ (\(x, _, _) -> x) $ toForeignPtr $ BS.pack str)) :: UArray Int Word8
10:53:02 <rwbarton> I was just looking at the source of freezeSTUArray.
10:53:07 <rwbarton> what is unsafeCoerce#?
10:53:53 <rwbarton> oh, I get it
10:54:15 <mcstar> well, there are lot of # in low level code
10:54:18 <mcstar> lots*
10:54:24 <nand`> GHC's primitive version of the exact same function
10:54:30 <mcstar> Int# is uboxed int, that i know
10:54:46 <mcstar> but what is (# Int#, Int# #)?
10:55:01 <marzy> is there a function that shuffles a list in standard lib or should I juse use these?  http://www.haskell.org/haskellwiki/Random_shuffle
10:55:04 <rwbarton> two unboxed ints
10:55:06 <nand`> unboxed tuple
10:55:22 <mcstar> but the use of the outer # is weird
10:55:33 <nand`> (# a #) is the syntax for that
10:55:43 <mcstar> yeah, i guess, it is just weird for me :)
10:56:05 <nand`> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html#unboxed-tuples
10:56:15 <rwbarton> Jafet: The (`plusPtr` negate 8) is very convincing.
10:56:45 <mcstar> i wish i had known about haskell years ago!
10:56:47 <tac> Cale: I just noticed that that alternative definition to callCC is based on a more polymorphic version of Cont as well
10:56:48 <Jafet> rwbarton: works for me dude
10:57:05 <nand`> mcstar: me too
10:57:07 <mcstar> you know what? i hate you all, that you didnt come, and tell me about haskell
10:57:12 <mcstar> XD
10:57:12 <nand`> me too
10:57:20 <nand`> but I still love you all
10:57:25 <mcstar> me too
10:57:32 <tac> (I think?)
10:57:33 <Jafet> I wonder if it's skipping something important, like allocation information.
10:57:59 <nand`> only one way to find out
10:58:21 <Cale> tac: right
10:58:23 <tac> Cale: Nevermind, I take that back. I misread it.
10:58:24 <Jafet> Perhaps the Addr# used by ByteString was also allocated as a fooArray#, and so all is well
10:58:29 <rwbarton> did you just try it without and find that it was missing the first 8 characters of the string?
10:58:32 <Cale> er
10:58:52 <tac> but the key point is that a cannot be instantiated the same as b in the "improved" callCC.
10:59:09 <marzy> I have a Card data, containing card Suit and Value. Value is Ord but Suit isn't.  should I just make Suit ord too, or would it be prefered to define a custom one?
10:59:14 <Cale> oh, I guess it's not
10:59:29 <nand`> marzy: they can reasonably be ordered; so I don't see why not
10:59:30 <marzy> the goal is to make Card Ord
10:59:38 <Jafet> rwbarton: of course
10:59:44 <Jafet> It's a reliable ritual
11:00:01 <rwbarton> try forcing that UArray and doing a performGC or whatever
11:00:05 <nand`> isn't there some sort of definition you can call back to for this? what order does a “sorted deck” have its suits in?
11:00:05 <rwbarton> then print it out
11:00:23 <marzy> nand kind of weird though that Card Two Heart would be < or > to Card Two Spade
11:00:29 <marzy> instead of ==
11:00:31 <ocharles> any lens'ers used projections yet?
11:00:34 <ocharles> I can't quite figure them out...
11:00:47 <marzy> well it can't be == either
11:00:50 <nand`> marzy: but two of hearts isn't equal to two of spades, I'd argue
11:00:58 <marzy> indeed :)
11:00:59 <nand`> can Ord and Eq differ?
11:01:25 <c_wraith> There is probably a lot of code out there that assumes they don't
11:01:34 <Jafet> @hoogle performGC
11:01:34 <lambdabot> System.Mem performGC :: IO ()
11:01:52 <nand`> oh, Eq is a superclass of Ord; based on the default definition of (==) = (Eq==) .: compare; no?
11:01:55 <Jafet> rwbarton: same array
11:02:00 <nand`> EQ*
11:02:05 <c_wraith> nand`: yes
11:02:13 <nand`> then yeah, I'd argue they can't differ
11:02:18 <rwbarton> I guess it works then!
11:02:36 <Jafet> (==) isn't actually used in Ord, as far as I know
11:02:47 <Jafet> So while we're on the topic of unsafe things, yes you can probably make them inconsistent
11:02:49 <nand`> marzy: okay here's what I'd do in a rigorous application; have the default Eq/Ord (if any) take the suit into account
11:02:58 <nand`> marzy: then provide a newtype wrapper for ignoring the suit
11:03:18 <nand`> (or just use Value in the first place, come to think of it)
11:05:22 <marzy> yes I think I'll make Suit Ord and just use Value when I need to
11:05:24 <nand`> marzy: https://en.wikipedia.org/wiki/Suit_(cards)#Ordering_suits
11:05:49 <nejucomo> Ord and (==) remind me of a common desire I have to say: "Any instance of class C is also an instance of D by this definition..."
11:06:01 <nejucomo> -which I think is not possible with type classes.  True/False?
11:06:03 <nand`> based on that article, I wouldn't make Suit (hence Card) Ord
11:06:16 <Jafet> instance Monad m => Functor m where fmap = liftM
11:06:20 <latro`a> nejucomo, no it is not, because of the way insntance matching works
11:06:30 <nejucomo> let ordBasedEq a b = if a `compare` b == Eq then True else False
11:06:34 <nand`> unless you're implementing a specific game, in which case, if it's clear that it's in that namespace and not general, I would adhere to that game's sorting rules
11:06:50 <latro`a> it is technically possible, but the result is that you can't make any other instances
11:07:01 <latro`a> *instance matching
11:07:13 <Jafet> Sure you can, you just need OverlappingInstances.
11:07:27 <nand`> yeah; but it's a whole can of worms imo
11:07:38 <nand`> there's a proper solution for this
11:07:39 <latro`a> that leads to its own disasters
11:07:40 <nand`> wait no
11:07:42 <nand`> there isn't, but a few proposals iirc
11:07:56 <Jafet> Something about early birds
11:08:00 <nejucomo> Hrm.  I still hope for some development that shows it's possible to have ordBaseEq for all Ord instances, but normal Eq instances otherwise, both of which use a symbol (==)...
11:08:07 <nand`> basically; the ideal would imo be to provide a default for Eq if Ord is found
11:08:36 <nand`> or perhaps in the definition of Ord; when pulling in the superclass constraint, to say that it can be automatically derived
11:08:39 <nejucomo> I mean, "some development in type theory with type classes which maintains a consistent/safe/sane type system with modular compilation".  :-)
11:08:41 <latro`a> a shame you can't have disjunctive constraints
11:08:46 <Jafet> Ord necessarily subsumes Eq, so that's quite pointless. Unless you have another use case.
11:08:46 <nand`> yes I think that would make sense
11:08:51 <nejucomo> nand`: Yes, that would suffice.
11:08:53 <nand`> instance Suit Ord deriving Eq where ...
11:08:55 <nand`> ^- would this make sense?
11:09:11 <nand`> s/make sense/look good/
11:09:18 <latro`a> though disjunctive constraints would quickly become hideous
11:09:30 <Jafet> Like two classes with mutual recursion
11:09:46 <Jafet> latro: haven't you always wanted to see a sat solver in haskell!
11:09:57 <latro`a> what's a sat solver
11:10:19 <copumpkin> Jafet: I wrote a verified QSAT solver in Agda
11:10:26 <copumpkin> (the dumbest way possible)
11:10:31 <copumpkin> the code basically wrote itself
11:10:32 <mcstar> determines if a boolen expression can be satisfied i think
11:11:40 <startling> is there a way to have an Either-like monad evaluate as much as it can and give me *all* the Lefts?
11:11:55 <Jafet> Satisfiability Modulo Unifying Types
11:12:25 <Jafet> From whence do you obtain all these Lefts
11:12:43 <mcstar> lol @ "the code basically wrote itself", were you using template haskell?
11:12:49 <copumpkin> no, agda
11:13:05 <mcstar> ah, missed that
11:13:09 <startling> Jafet: are you trying to show me the error of my ways, or are you really asking?
11:13:10 <copumpkin> :)
11:14:01 <startling> if it's the latter: I have a monad that's composed of many smaller independent actions; it'd be cool if I could get all the errors at once rather than get one, fix stuff, get another, fix more stuff, etc etc
11:14:22 <Jafet> So that's like, the list monad
11:14:52 <startling> ...oh. right.
11:14:54 <simpson> startling: Hm. So is this still the development cycle?
11:15:04 <rwbarton> startling: you can do that with an Applicative
11:15:18 <startling> simpson: yes, but it'd be nicer for the final stages too.
11:15:26 <startling> rwbarton, what kind of applicative?
11:15:46 <rwbarton> well basically Either e where e is a Monoid
11:16:15 <startling> rwbarton: but then won't it short-circuit as soon as I get a Left [any errors] ?
11:16:18 <simpson> But Either's instances don't do that already, do they?
11:16:19 <rwbarton> but you'd need a newtype (or a new type) because Either e already has a different one
11:16:27 <startling> rwbarton: ah, okay
11:16:42 <Jafet> Newt type
11:16:57 <startling> it'll go well with my Eye of Salamander type.
11:17:02 <simpson> Othor a b = Loft a | Roght b
11:17:22 <startling> is there a type like this somewhere already? I feel like there should be
11:18:39 <rwbarton> probably but i don't know where
11:18:50 <startling> I feel like it'd be a common thing for error-handling.
11:18:54 <startling> ah well.
11:19:05 <clahey> Isn't that the Writer Monad?
11:19:10 <nand`> startling: if you get one error somewhere, how should the computation continue?
11:19:10 <Cale> startling: Just a point about terminology -- "a monad" refers to the type constructor, not the values whose type involves that constructor.
11:19:24 <nand`> like wouldn't the error mean that you can't produce some sensible value during some intermediate step?
11:19:34 <nand`> oh
11:19:39 <nand`> “many small independent actions”
11:19:45 <startling> nand`: yeah
11:19:45 <Cale> startling: "I have an action that's composed of many smaller independent actions"
11:19:54 <startling> Cale: good to know, thanks
11:20:03 <startling> "monadic value"?
11:20:08 <Cale> yeah, that works too
11:20:13 <startling> k.
11:20:18 <nand`> ‘action’ seems to fit best here
11:20:47 <Cale> "action" is a reasonable word to use with any monad you're going to encounter in Haskell
11:20:49 <nand`> don't mathematicians just make up names when faced with situations like these?
11:21:11 <startling> "I've got a burrito composed of many smaller burritos."
11:21:11 <rwbarton> here though the best way i know to deal with this is to *not* use a monad
11:22:18 <latro`a> ...dammit startling
11:22:21 <latro`a> now I want a burrito
11:22:27 <latro`a> but the roads are probably still fairly flooded
11:22:29 <latro`a> >:|
11:22:33 <latro`a> :p
11:22:50 <clahey> startling: Actually, the more I think about it, if you return a Left, what is the input to the next function?
11:23:05 <clahey> startling: I.e., what is Left x >>= y
11:23:21 <bfgun> Cale, hey, mind if i pm?
11:23:25 <johnw> startling: maybe we really should start using "warm fuzzies"
11:23:26 <clahey> (Or in applicative, what is Left  x <*> Right y ?)
11:23:31 <latro`a> in Either, or in startling's thing?
11:23:38 <clahey> latro`a: In startling's thing.
11:23:43 <startling> clahey, can't it figure out if y is strict on x?
11:23:49 <Cale> bfig: I don't mind
11:24:05 <startling> clahey, like I want to be able to do Left x >>= const y
11:24:18 <startling> but Left x >>= someFn would get me a Left x.
11:24:34 <startling> Left x >> y is the same as the former, I guess.
11:24:38 <clahey> And Left x >>= const Left y would give you Left x ++ y or something?
11:24:45 <startling> yeah
11:24:53 <rwbarton> I suppose you could break the >>/>>= law but ew
11:25:06 <startling> rwbarton: that breaks the laws?
11:25:10 <eric_niebler> hello, haskell noob here. want to learn haskell by using it for some shell scripting. what's the best way of munging text line-by-line? I can read lines into a Lazy.Text. If this were perl, I'd use regex with replacements ...
11:25:11 <nand`> I'm going with “if you have many independent actions, then the actions should probably be independent”; ie. [Action]
11:25:17 <rwbarton> I mean you could define x >> y as something other than x >>= const y
11:25:25 <startling> rwbarton: oh heh
11:25:35 <rwbarton> that would "solve" your problem
11:25:47 <startling> nand`: yeah, I thought about that. hmmm
11:26:05 <startling> I'd really like to have the niceness of do notation for this project, though. :|
11:26:06 <nand`> eric_niebler: I wrote something for that the other day, but it's probably not going to be helpful if you're a newcomer
11:26:27 <rwbarton> you needn't give up completely and use [Action], there is Applicative
11:26:45 <nand`> startling: you could use free monad corresponding to lists
11:26:45 <startling> rwbarton: what would the applicative instance look like? I'm not seeing it
11:26:47 <clahey> You want do x; y; z instead of [x, y, z] ?
11:26:48 <eric_niebler> nand`: i've got Text.ICU.Regex working, but it doesn't do substitutions.
11:26:57 <nand`> startling: then you'd be able to use do notation to concatenate
11:27:09 <nand`> sort of like how you can use do notation to concatenate IO actions
11:27:31 <nand`> eric_niebler: well, I meant for the “applying something line by line”
11:27:38 <rwbarton> data E e a = Err e | OK a ; instance Monoid e => Applicative (E e) where Err e1 <*> Err e2 = Err (e1 `mappend` e2); Err e1 <*> OK _ = Err e1; OK _ <*> Err e2 = Err e2; OK f <*> OK x = OK (f x)
11:27:41 <startling> nand`, what's the free monad corresponding to lists? data X a = Single a | ListOf [a] ?
11:27:44 <rwbarton> plus other more boring stuff
11:27:44 <Cale> eric_niebler: It's usually way more satisfying and reasonable to use a proper parsing library than anything which implements regex notation.
11:28:08 <johnw> hey eric_niebler!
11:28:10 <eric_niebler> Cale: can you recommend one?
11:28:17 <Cale> eric_niebler: For example, split the input into lines and then use a simple Parsec parser on it to extract and rework the bits however you want
11:28:17 <eric_niebler> hey johnw!
11:28:19 <startling> rwbarton: OH! neat.
11:28:23 <rwbarton> eric_niebler: for "line-by-line munging" there is T.unlines . map munge . T.lines
11:28:24 <Silox|> Can I install Quickcheck on windows? And if yes: how?
11:28:59 <eric_niebler> rwbarton: input is huge. must read it line-by-line.
11:29:02 <rwbarton> startling: but then you can't use do notation since there is no Monad instance
11:29:06 <rwbarton> eric_niebler: yes that will do that
11:29:08 <startling> rwbarton: indeed.
11:29:10 <eric_niebler> ok
11:29:13 <Cale> Silox|: yes, use "cabal install QuickCheck" to install it
11:29:21 <Cale> Silox|: assuming you've installed cabal-install
11:29:21 <startling> maybe I can sacrifice that, though. that's compelling.
11:29:23 <nand`> startling: type List a = Free ((,) a) ()
11:29:33 <Silox|> Cale: on Windhows? :p
11:29:36 <rwbarton> startling: there is an "ado notation" for Applicative using TH
11:29:41 <Cale> Silox|: yes, even on windows
11:29:45 <Silox|> Ah I see, thanks!
11:29:51 <johnw> eric_niebler: laziness is your friend in such large parsing tasks
11:29:53 <startling> nand`: oh, right.
11:30:01 <startling> rwbarton: o rly. where?
11:30:12 <eric_niebler> off to read Parsec docs, thanks.
11:30:14 <rwbarton> http://hackage.haskell.org/packages/archive/applicative-quoters/0.1.0.7/doc/html/Control-Applicative-QQ-ADo.html
11:30:14 <clahey> Except if you have independent actions, you don't want f <*> x.
11:30:26 <clahey> You want x >> f, which is very different.
11:30:33 <startling> that's true.
11:30:34 <rwbarton> if you have independent actions you can use, uh
11:30:36 <rwbarton> @type sequenceA
11:30:38 <lambdabot> Not in scope: `sequenceA'
11:30:39 <johnw> eric_niebler: if you need help with Parsec, let me know
11:30:46 <rwbarton> @type Data.Traversable.sequence
11:30:47 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
11:30:47 <johnw> eric_niebler: I've written a couple of Parsec parsers now
11:30:51 <eric_niebler> johnw: thx
11:30:55 <rwbarton> argh
11:31:06 <rwbarton> @hoogle Applicative f => [f a] -> f [a]
11:31:06 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
11:31:06 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
11:31:07 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
11:31:22 <rwbarton> or
11:31:25 <rwbarton> @hoogle (*>)
11:31:25 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
11:31:26 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
11:31:26 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:31:27 <nand`> byLines = lens T.lines (const T.unlines).traverse
11:31:52 <niteria> what class of grammars does Parsec deal with?
11:31:54 <nand`> "file" ^! act readFile.byLines.to f.act putStrLn -- hooray for lenses
11:31:59 <nand`> niteria: context sensitive
11:32:12 <nand`> actually, not sure if it does TC
11:32:14 <nand`> but it definitely does CSGs
11:32:22 <rwbarton> nand`: I need to learn this "lens" programming language some time
11:32:31 <nand`> rwbarton: you do
11:32:35 <startling> rwbarton, nand`, clahey: thanks for the discussion, I've got lots of things to try now.
11:32:39 <nand`> rwbarton: it's like APL, but cooler
11:32:44 <startling> haha
11:32:46 <clahey> What if you define  x >>= f = combine x (f undefined) where combine (Loft x) (Loft y) = Loft (x `mappend` y); combine(Loft x) (Roght y) = Loft x?
11:32:49 <nand`> in terms of syntax noise
11:33:12 <clahey> Then >> does what you want and follows the monad rule.
11:33:37 <startling> clahey: yeah, but I'd like to have a working >>= too
11:33:58 <niteria> ok I asked a wrong question, isn't Parsec sort of equivalent to recursive descent parser?
11:34:06 <johnw> niteria: yes
11:34:08 <rwbarton> ideally you could "mix and match" independent and dependent computations without huge syntactic overhead
11:34:11 <clahey> startling: define Loft x >>= f = combine x (f undefined); Roght x >>= f = f x
11:34:31 <startling> clahey: oh, right
11:34:31 <johnw> niteria: although it's a bit handier, as you can do backtracking much more easily
11:34:35 <startling> fail can help with that too
11:34:45 <clahey> startling: fail = Loft and return = Roght.
11:35:01 <startling> wait, undefined doesn't call fail, does it
11:35:07 <nino> ciao
11:35:08 <niteria> recursive descent parsers deal deal with some kinds of grammars better and on some they can even go into infinite loop
11:35:09 <clahey> No.
11:35:10 <nand`> no
11:35:14 <nand`> error
11:35:20 <startling> right
11:35:42 <clahey> That's true, you don't want it to halt in that case.  Perhaps add exception handling there?
11:36:02 <startling> clahey: that might be fruitful
11:36:09 <niteria> why would I use Parsec when I can give more general grammar to some kind of parser generator?
11:36:28 <startling> but I'm not keen on adding exception-handling to my exception-handling. :S
11:36:35 <niteria> bc afaik you have to factor the grammar before using it with Parsec
11:36:37 <clahey> You can't write combine x undefined = x, right?
11:36:39 <nand`> because Parsec is an EDSL, means you can construct your grammar using the full power of Haskell
11:36:41 <startling> niteria, "more general grammar"?
11:36:59 <startling> clahey: correct
11:37:20 <clahey> So you have to put a catch around the f undefined.
11:37:36 <clahey> startling: But one advantage is that you only have to do it once in the definition of the monad and then you get it for free from then on.
11:38:18 <startling> clahey: fair enough
11:38:18 <niteria> there are these classes, LL(n), LALR, SLR, there are parser generators that deal with most general ones, but with recursive descent parsers you have to use less general one, LL(n) I think
11:39:06 <startling> niteria, parsec is more general than recursive-descent.
11:39:32 <johnw> startling: how is that?
11:39:42 <johnw> can it do LALR?
11:39:47 <niteria> it may be, but still with rule A :== Ax | x it will just loop, right?
11:40:12 <startling> johnw: uhhh maybe I'm mixing terms
11:40:12 <Philippa> it can do LL(omega) without breaking a sweat, and if we're getting picky it's turing complete as a parser
11:40:15 <startling> gimme a sec
11:41:03 <Philippa> (proof: shove the tape in a StateT on top of it and call an appropriate tape-frobbing function every time you consume a character)
11:41:14 <nand`> heh
11:41:55 <Philippa> it can do a fair range of other useful classes in slightly less ridiculous manner, though right recursion needs translating out
11:42:40 <Philippa> er, left recursion, even
11:42:45 <Philippa> (my brain, it is functioning today, honest)
11:43:14 <Saizan> the *LR ones need right-recursion translated out, no?
11:47:44 <niteria> is there a library in Haskell for finite automata? Is there a formally verified one?
11:47:54 <marzy> is there no join function in standard library that concatenate a list of strings?
11:48:26 <rwbarton> concat
11:48:28 <niteria> > concat ["adas", "Assda", "dsad"]
11:48:29 <lambdabot>   "adasAssdadsad"
11:48:37 <copumpkin> conveniently, join works too
11:48:44 <copumpkin> > join ["adas, "Assda", "dsad"]
11:48:45 <lambdabot>   <no location info>:
11:48:46 <lambdabot>      lexical error in string/character literal at end o...
11:48:52 <copumpkin> > join ["adas", "Assda", "dsad"]
11:48:54 <Philippa> niteria: I'm sure I've seen at least one lib on HackageDB, but most of us don't have much use for one. Not sure about formal verification
11:48:54 <lambdabot>   "adasAssdadsad"
11:49:25 <marzy> I wanted to add a joining character. I have googled join before and it appears to be a third party module Data.String.Utils
11:49:35 <marzy> in a*
11:49:35 <hiptobecubic> @src (>>=)
11:49:36 <lambdabot> Source not found. That's something I cannot allow to happen.
11:49:47 <hiptobecubic> @src (>>=) [])
11:49:48 <lambdabot> Source not found. You speak an infinite deal of nothing
11:49:49 <hiptobecubic> @src (>>=) []
11:49:49 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:49:55 <clahey> @src [] (>>=)
11:49:55 <lambdabot> xs >>= f     = concatMap f xs
11:49:57 <rwbarton> marzy:
11:50:00 <hiptobecubic> clahey, thanks.
11:50:11 <rwbarton> @hoogle a -> [[a]] -> [a]
11:50:12 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
11:50:12 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
11:50:12 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
11:51:02 <rwbarton> > intercalate "," ["adas", "Assda", "dsad"]
11:51:04 <lambdabot>   "adas,Assda,dsad"
11:51:30 <marzy> thanks
11:51:38 <clahey> intercalate = concat . intersperse?
11:52:04 <rwbarton> except not actually because of currying
11:52:05 <byorgey> well, (concat .) . intersperse
11:52:07 <byorgey> but yes
11:52:56 <Gurragchaa> How would you go about making something like a dynamic Markov chatbot without any state?
11:53:33 <clahey> Right.
11:55:26 <nand`> What's a Markov chatbot?
11:55:59 <bgamari> Gurragchaa, If I'm not mistaken, you'd by definition need some amount of state, given it's a Markov process
11:56:06 <clahey> Gurragchaa: I think IO implies state and a chatbot isn't any good without any IO, right?
11:56:34 <nand`> sure a chatbot is good without IO
11:56:49 <bgamari> Gurragchaa, You at least need to know the last state
11:56:52 <clahey> nand`: Well, define good.  :)
11:57:15 <nand`> Markov ≅ String -> (String, Markov)
11:57:21 <nand`> can chat with it just fine
11:57:46 <Gurragchaa> I'll read more about the State monad, I'm admittedly pretty new to this
11:58:01 <clahey> nand`: Actually, I like that quite a bit.
11:58:22 <clahey> nand`: Why ≅?
11:58:22 <nand`> you can even have a related Markov' ≅ (String, String -> Markov')
11:58:23 <bgamari> Gurragchaa, nand` pretty much wrote down your state monad
11:58:26 <nand`> and have them communicate
11:58:32 <clahey> Is that type =?
11:58:32 <nand`> bgamari: that's not a state monad, mind
11:58:42 <nand`> they're mealy/moore machines
11:58:56 <nand`> clahey: because I was too lazy to write ‘newtype Markov = Markov { ... }’
11:59:14 <clahey> nand`: Cool.  I just had never seen it used that way before.
11:59:24 <bgamari> nand`, Up to "pretty much" ;)
11:59:25 <nand`> ≅ means ‘is isomorphic to’
11:59:28 * hackagebot jarfind 0.1.0.3 - Tool for searching java classes, members and fields in classfiles and JAR archives  http://hackage.haskell.org/package/jarfind-0.1.0.3 (EugeneKirpichov)
11:59:32 <bgamari> but point taken
11:59:37 <clahey> nand`: Ah.
11:59:48 <clahey> I guess I had it confused with appx equals.
11:59:51 <tac> How do you turn on Rank2 Polymorphism via a pragma?
12:00:01 <nand`> and trivially every newtype is isomorphism to its sole field
12:00:04 <nand`> mic*
12:00:14 <nand`> -XRank2Types
12:00:16 <nand`> uh
12:00:18 <nand`> {-# LANGUAGE Rank2Types #-}
12:00:19 <rwbarton> {-# LANGUAGE Rank2Types #-}
12:00:23 <marzy> did I completely misunderstand how cabal works?  I am getting "cabal: The file does not exist" for cabal install Data.String.Utils
12:00:27 <tac> ty guys
12:00:38 <bgamari> nand`, rwbarton, RankNTypes now
12:00:42 <rwbarton> marzy: yes but you probably don't want to install that anyways
12:00:51 <bgamari> SPJ just remarked that Rank2Types is soon to be deprecated
12:00:52 <dcoutts> marzy: it'd be nice if it did module names, but actually it only does package names.
12:00:55 <rwbarton> marzy: but it is "cabal install <package>"
12:01:04 <nand`> ah okay
12:01:09 <nand`> did not know that
12:01:19 <marzy> rwbarton anything wrong with that package or?
12:01:29 <marzy> since you say I shouldn't install it
12:01:38 <nand`> I thought Rank2Types was there in the interest of future work theoretically being able to infer rank 2 types
12:01:40 <dcoutts> marzy: that's a module, not a package. A package contains a bunch of modules.
12:01:56 <dcoutts> marzy: you want the package that provides that module
12:02:01 <rwbarton> well it is quite ancient
12:02:11 <marzy> dcoutts got it
12:02:13 <rwbarton> most of these functions are in base by now
12:02:33 <rwbarton> I guess it is still being maintained though
12:02:56 <bgamari> nand`, rwbarton: Alright, correction. It seems it was decided to make Rank2Types a synonym for RankNTypes instead of deprecating it
12:03:10 <rwbarton> bgamari: ah
12:03:27 <rwbarton> that sounds more reasonable
12:03:27 <bgamari> rwbarton, nand` http://www.haskell.org/pipermail/cvs-ghc/2012-October/077596.html
12:04:01 <nohonor> evening, haskellians :-)
12:04:15 <Cale> hello nohonor :)
12:04:22 <bgamari> The concern was that it would be too onerous to verify that a module *only* needs rank 2 types
12:04:49 <nohonor> i'm still meditating on the type system, could anyone explain to me what the compiler wants in this error message: http://pastebin.com/uV7vSsBX
12:04:52 <mauke> The paste uV7vSsBX has been copied to http://hpaste.org/77013
12:05:45 <nohonor> what does the Num typeclass have to do with anything
12:05:54 <clahey> nand`: CombinedMarkov (m, m') str = CombinedMarkov (second (m',) (m str))
12:06:17 <rwbarton> nohonor, it has to do with '1'
12:06:17 <bgamari> nohonor, The easy answer is that it wants, unbound :: Num b => a -> b
12:06:20 <lispy> Anyone know some tools for taking Antlr and generating Haskell or haskell bindings? I found antlrc on hackage, but it appears to require yoeu to embed your haskell inside a C program (which is not what I want)
12:06:29 <bgamari> nohonor, It needs to get from the literal 1 to a b
12:06:33 <nohonor> i'm afraid i have no use for the easy answer :-)
12:06:43 <bgamari> nohonor, which requires fromIntegral
12:06:46 <bgamari> which is in Num
12:06:51 <clahey> nand`: Oh, no, that's not quite right.  They combined markov isn't a markov chatbot, it's just a generator.
12:07:01 <bgamari> fromInteger*
12:07:07 <nohonor> ok then, let's forget numbers, if i put a char literal there
12:07:16 <nohonor> i get Couldn't match type `b' with `Char'
12:07:25 <nohonor> what does this mean?
12:07:32 <nohonor> what is it trying to match and how?
12:07:53 <rwbarton> you wrote: "unbound :: a -> b"
12:07:59 <rwbarton> a and b are type variables
12:08:09 <clahey> combineMarkovs m m' str = str : combineMarkovs m' m'' str' where (str', m'') = m str
12:08:10 <Cale> nohonor: you said that for any types a and b that I choose, I can use your function  unbound  on my value of type a and get a value of type b
12:08:19 <clahey> nand`: Is that close?
12:08:27 <Cale> nohonor: but your implementation doesn't actually do this
12:08:35 <nand`> I have no idea what the combined markov is; don't ask em
12:08:38 <nand`> me*
12:09:20 <nohonor> Cale, interesting...
12:09:21 <Cale> nohonor: In fact, the only reasonable thing for your function to do is to go into an infinite loop and neglect to deliver a value of type b (or crash in some other way), because as the implementor of such a specification, you know absolutely nothing about what you need to produce
12:09:45 <clahey> nand`: My goal is to generate the conversation starting with a given string.
12:09:59 <clahey> nand`: I don't know if it's a real thing.
12:10:00 <nohonor> so if the return type is unbound, it's the caller who chooses the return type
12:10:03 <nand`> clahey: well, my type above was the type of a generalized chatbot
12:10:23 <rwbarton> any type variables in the type are determined by the caller
12:10:23 <nand`> given a starting input, you can trivially turn a mealy machine into a moore machine then hook them together and watch it unfold
12:10:32 <Cale> nohonor: Well, the caller chooses to instantiate all the type variables
12:10:35 <rwbarton> same as e.g.
12:10:38 <rwbarton> @type length
12:10:39 <lambdabot> forall a. [a] -> Int
12:10:44 <clahey> nand`: Ah, I should read up.
12:10:46 <nohonor> Cale, or not instantiate them
12:10:49 <clahey> Except I have real work to do.
12:10:56 <clahey> Dang you #haskell for being so fascinating!
12:11:07 <Cale> nohonor: Yeah, which it does by taking another type parameter, and supplying that
12:11:34 <nand`> type Chatbot = Mealy String String
12:11:35 <Cale> nohonor: (in the internal core language that Haskell is compiled to by GHC, there are explicit type parameters being passed around like extra function parameters)
12:12:03 <tac> Hell yeah
12:12:11 <nand`> from https://github.com/ekmett/machines/blob/master/src/Data/Machine/Mealy.hs
12:12:12 <tac> callCC :: forall r. forall a. ((a -> forall b. Cont r b) -> Cont r a) -> Cont r a
12:12:13 <tac> callCC f = Cont $ \ka -> fromCont (f (\x -> Cont $ \kb -> ka x)) ka
12:12:16 * bgamari is finding a compulsion to throw sharp objects at compiz is becoming more and more frequent
12:12:17 <nohonor> this is intriguing
12:12:19 <tac> typechecked :O
12:12:33 <nohonor> anyway,  i think i'm getting closer
12:12:56 <nohonor> so would i be correct in saying that H's type system is not really based on hierarchies
12:13:01 <nohonor> it's based on pattern matching
12:13:22 <Cale> nohonor: Well, unification
12:13:44 <Cale> nohonor: The typechecker works by collecting lots of equations between the types of various things
12:13:52 <Cale> nohonor: and then tries to solve those equations
12:14:13 <Cale> (well, really it probably does both at the same time to a large extent)
12:15:25 <nohonor> so it's all about defining how expressions can be combined
12:15:36 <Cale> Indeed, that too :)
12:15:46 <nohonor> come to think about it, that's what all type systems are about, but in OOP it's much obscured
12:15:52 <Cale> yes
12:16:14 <nohonor> Cale, thank you
12:16:24 <Cale> Especially since a lot of typed OO languages make the mistake (imo) of tying method implementations to the classes (which are types)
12:16:39 <Exilepilot> I'm very new to haskell lol
12:16:57 <Cale> Which confuses the line between interface and implementation and makes for stupid hierarchies where there shouldn't be any.
12:17:14 <Cale> and also results in all that Factory-pattern nonsense
12:17:20 <nohonor> amen
12:17:42 <Exilepilot> Um... Could anyone guide me to a good site to start haskell?
12:17:42 <Vq> agreed
12:17:54 <nohonor> Exilepilot, google "learn you a haskell"
12:17:55 <nohonor> hands down
12:18:17 <nohonor> out of 5 or so tutorials and books that's the clearest and most up to the point
12:18:21 <sipa> @where lyah
12:18:21 <lambdabot> http://www.learnyouahaskell.com/
12:18:24 <Vq> or perhaps tryhaskell.org
12:18:34 <Philippa> yeah, tryhaskell is good if you haven't had a play with it yet
12:19:54 <mcstar> lets say, i want to display the contents of a sql database in a browser, now, if im correct, a database server must be running on the server side, and i must write CGI program, in haskell for example, that interfaces between web requests and the database server, and something with the data in the browser(in js for example), am i close?
12:20:08 <clahey> Cale: How would you handle the stuff that they handle with shared implementation?
12:20:18 <clahey> Cale: Actually, I feel like haskell has some of this in type classes.
12:20:34 <clahey> Cale: Since you can define functions in the class definition and then override them in your instance.
12:20:56 <mcstar> and do something*
12:21:22 <clahey> mcstar: You can either send json over the line and have js on the client process it or just send html.
12:21:33 <mcstar> no, json
12:21:43 <mcstar> since it needs to be plotted, and tabulated
12:22:05 <mcstar> and the connection must work backwards too, i.e. changing stuff in the browser affects the database
12:22:10 <clahey> mcstar: Sounds pretty right to me.
12:22:14 <clahey> mcstar: Which means sending json up.
12:22:20 <mcstar> yep
12:22:32 <clahey> mcstar: I'm tempting to try one of the haskell js compilers next time I do something webby.
12:22:34 <mcstar> im totally new to webtech, thats why im asking
12:22:40 <clahey> tempted*
12:22:49 <mcstar> and i just got this job offer...
12:22:55 <mcstar> maybe i can fit in some haskell
12:23:47 <mcstar> also, i havent written a single line of js XD
12:24:52 <mcstar> now honestly, would it be easier for me to try to write this cgi program in haskell, or in python, for example?
12:25:09 <niteria> in python
12:25:10 <niteria> :D
12:25:29 <mcstar> im not a haskell wizard, thats why im asking, i know haskell is great, but im not :)
12:25:39 <Vq> mcstar: Do you know Python?
12:25:59 <mcstar> wrote some stuff in it, im not an expert
12:26:01 <niteria> if you have to do it now, then python is a better choice
12:26:22 <nand`> I would go with Haskell, personally; but I don't know python
12:26:32 <niteria> if you have more time then writting it in haskell is good opportunity to learn
12:26:40 <Vq> mcstar: My guess is that you would have something working in Python faster.
12:26:48 <nand`> I'm not interested in “works now” or “quick and dirty” solutions, ever; my ideology is to write the “right thing” once
12:27:04 <mcstar> heh, so many things to consider
12:27:32 <niteria> python is my favorite getting-things-done language
12:28:13 <mcstar> this is my level of python knowledge https://github.com/liquid-phynix/okular-session-restore/blob/master/okular_session_manager.py
12:28:29 <niteria> coding in python is like writting prose, coding in haskell is like writting poetry
12:28:40 <niteria> you have to think about every word
12:28:53 <Vq> Python also has a lot of good web libs going for it.
12:28:55 <nand`> you constantly stare at your definitions and think about how to make them prettier?
12:29:33 <nand`> the worst part is when something's exactly 81 chars long and I have to figure out how to make it fit into 80col again without making it too ugly
12:29:52 <mcstar> nand`: kidding, right?
12:30:06 <Vq> mcstar: No, he isn't. :)
12:30:19 <nand`> mcstar: I wish; I do actually adhere to strict 80col
12:31:30 <niteria> 80col is there for a reason, that reason is invalid now, but there are better reasons anyway
12:31:48 <shergill> mcstar: if you have time, use it as a pretext to learn some haskell. if not, go with python
12:31:50 <marzy> I am trying to print uncidode string. is this article still relevant? (it's from 2007).  http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html
12:32:35 <mcstar> shergill: pretext?
12:32:53 <shergill> mcstar: case study. working example. toy project. whatever
12:33:06 <copumpkin> mcstar: excuse that is not true
12:33:12 <mcstar> shergill: i looked up the word in the meantime :) it make sense
12:33:12 <rwbarton> marzy, no
12:33:14 <copumpkin> :P
12:33:19 <rwbarton> it should just work
12:33:37 <marzy> just print should work?
12:33:46 <marzy> I'll double check my encodings then
12:33:52 <rwbarton> putStrLn
12:34:00 <rwbarton> or putStr
12:34:34 <rwbarton> print will display the Haskell string literal syntax for the string
12:35:31 <dmwit> "It should just work" is correct on systems that have a full Unicode locale.
12:35:48 <rwbarton> yes and a system should have a full unicode locale ;)
12:35:51 <dmwit> By default, most Linux installations have this (via some UTF-8 locale), and most Windows installations do not.
12:36:02 <dmwit> Just something to be aware of.
12:37:05 <dada-cetacean> how do I write the list comprehension [(x,y) | x <- [1..10], y <- [1..10]] in do notation?
12:37:30 <dmwit> > do { x <- [1..10]; y <- [1..10]; return (x,y) }
12:37:39 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
12:38:29 <dada-cetacean> thanks!
12:38:48 <dmwit> marzy: Also, when you know better than the current locale what encoding is expected, Hackage's encoding package (suggested in the linked article) and the Text analogue are both still quite relevant and useful.
12:39:08 <dmwit> e.g. when you're writing to the network or disk in some well-specified format
12:40:27 <rwbarton> you can also use hSetEncoding, right
12:40:45 <dmwit> sounds plausible, and is definitely something I had forgotten about
12:41:26 <dmwit> Unicode is hard. =(
12:42:12 <ladr0n> so I know the current haskell-platform is based on ghc 7.4, but will it build under ghc 7.6?
12:42:37 <clahey> How do I write do { x <- [1..10]; let y = x * 2; return (x, y) } in list comprehension notation?
12:43:39 <dmwit> > [(x,y) | x <- [1..10], let y = x*2]
12:43:40 <lambdabot>   [(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20)]
12:43:50 <clahey> dmwit: Thank you.
12:44:11 <clahey> I thought I'd tried that.  Maybe I accidentally used ; instead of ,
12:44:52 <ladr0n> Let me rephrase that: I'm trying to build the current haskell-platform with ghc 7.6, and it's not working. Is that because I'm using ghc 7.6?
12:44:58 <geekosaur> yes
12:45:19 <dmwit> You're still asking the wrong question.
12:45:32 <dmwit> The right question is, "Here's my command line and the error I get. Wat do?".
12:45:56 <geekosaur> :p
12:47:35 <ladr0n> lol okay. well I'm installing haskell-platform so I can get yesod set up.
12:48:07 <dmwit> Strange. Why wouldn't you install yesod if that's your end goal?
12:48:15 <shergill> ladr0n: you don't *need* haskell-platform for yesod
12:48:16 <b44> Which binding is executed first here?  First the right bracket is executed, then 'y' is replaced by let, then 'x', and at last the parameter given with g x is put in?      g x = x + (let y = x * 2; x = 5 * 5 in (let x = f x 2 in x + y))
12:49:10 <acowley> I'm confused by page 5 and 6 here, http://www.iro.umontreal.ca/~monnier/tct.pdf
12:49:11 <conal> byorgey: ping
12:49:16 <scp> Is there a function in the standard library that does the same as this?
12:49:17 <ladr0n> ah! the yesod website recommends using haskell-platform, so I thought that might be the path of least resistance
12:49:31 <acowley> It seems like a :: * -> *, but then they instantiate it at [String] -> String in the example
12:49:57 <acowley> (this is a basic PHOAS issue)
12:50:16 <scp> wait a minute..
12:50:29 <dmwit> acowley: That's ExpF
12:50:39 <acowley> Yes, and if Exp is an existential wrapper
12:50:40 <dmwit> err
12:50:44 <acowley> I still have the same kind problem
12:50:59 <dmwit> ah
12:51:19 <dmwit> You're confused because the a in data ExpF a and the a in Lam :: (a t1 -> a t2) -> ExpF (a (t1 -> t2)) aren't related.
12:51:26 <acowley> !
12:51:30 <acowley> dammit!
12:51:45 <dmwit> Which is weird and the authors should feel weird.
12:52:03 <acowley> Hm. Well I'm still confused then
12:52:12 <dmwit> b44: "first" is a tricky subject in Haskell =)
12:52:13 <acowley> where does the a in the the constructors come from?
12:52:19 <copumpkin> existential
12:52:24 <dmwit> universal
12:52:32 <dmwit> ;-)
12:52:34 <copumpkin> depends which side you look at it from :P
12:52:53 <copumpkin> but yeah, it's anything, as long as it's reflected in the final type
12:52:53 <acowley> Right, okay
12:53:10 <acowley> so I'm not having a kinding issue, but my code is still broken.
12:53:35 <acowley> dmwit: thank you for clearing that up! It seemed like an impossibly egregious error but I couldn't see where I was misreading it.
12:53:50 <copumpkin> why do they separate b and t in Rec?
12:54:04 <acowley> A frustrating thing about the paper is that there is way too little code.
12:54:18 <dmwit> copumpkin: I guess it can be handy for parameterized recursive types (like [])?
12:54:27 <dmwit> or... wait
12:54:32 <dmwit> That b is not what I thought it was.
12:54:50 <mcstar> also, haskell has these web frameworks i keep hearing about, happstack, snap, yesod, whatever, cant they do what i want? interfacing with an sql server, and serving pages the way i want?
12:55:01 <rwbarton> maybe they want to use "Rec a b"
12:55:10 <copumpkin> I guess they must
12:55:18 <copumpkin> I just haven't found it yet :)
12:55:39 <copumpkin> type ExpK a = Rec ExpKF a Z
12:55:41 <copumpkin> there we go
12:56:23 <rwbarton> couldn't it equally well have been type ExpK a = Rec ExpKF (a Z)
12:56:39 <copumpkin> yeah, you're right
12:56:44 <copumpkin> who knows
12:56:52 <copumpkin> perhaps they use the partially applied version elsewhere
12:56:54 <rwbarton> i don't see Rec a b used as a parameter to anything
12:56:57 <rwbarton> but maybe
12:58:10 <scp> okay, so I have a function insert :: k -> v -> Container k v
12:58:49 <scp> I want to insert a list of items into a container, and I only care about the key (k), not about the value (v)
12:59:08 <shergill> mcstar: they can. but haskell also has a steeper learning curve than, say, python. depends on how fast you want to get it done
12:59:10 <scp> so I do "map (flip insert ())"
12:59:22 <scp> and that inserts a list of keys with unit value
12:59:32 <scp> err, sorry
12:59:34 <mcstar> shergill: i guess, you can answer this, what does yesod provide?
12:59:52 <mcstar> is it a full featured webserver, like apache?
12:59:55 <scp> insert :: k -> v -> Container k v -> Container k v
13:00:02 <scp> I'll use hpaste =[, brb
13:00:26 <Zfrg> Is there a common library function for (\xs -> sequence (map print xs)) :: Show a => [a] -> IO ()?
13:00:36 <shergill> mcstar: yesod-platform includes warp which is a full featured webserver. but i use it behind nginx
13:00:40 <Zfrg> As in, does it have a name?
13:00:48 <simon> scp, map (flip insert ()) gives you a list of containers with one element in each. you probably want foldr?
13:02:35 <rwbarton> mcstar, basically it gives you a standalone web server where, rather than having pages served from disk, you write code to handle each URL/request
13:02:45 <rwbarton> perhaps there are other modes of operation, but that's the basic one
13:03:23 <byorgey> hi conal
13:03:52 <conal> byorgey: hi. do you use InnerSpace (from Data.VectorSpace)? i'm trying out a tweak that adds AdditiveGroup (Scalar v) as a superclass constraint for InnerSpace v, and I wonder how/whether it will affect other uses.
13:04:31 <mcstar> is the yesod screencast any good? i think im gonna watch it
13:04:51 <conal> byorgey: this change simplifies instances and misc functions.
13:07:37 <byorgey> conal: I do use InnerSpace
13:08:07 <byorgey> conal: I'm pretty sure everywhere I have an InnerSpace v constraint I also have an AdditiveGroup (Scalar v) constraint.
13:08:38 <byorgey> conal: but if you want to point me to a darcs repo with the proposed changes I could try them out.
13:10:07 <conal> byorgey: oh! good idea. done. see https://github.com/conal/vector-space/
13:10:16 <mcstar> heh, im soo not into web-dev, but this is interesting!
13:10:32 <conal> byorgey: i hope you can now remove those AdditiveGroup constraints.
13:10:46 <conal> byorgey: if it works for you, i'll release to hackage
13:11:03 <byorgey> conal: right. I will try it out.  I won't be able to do it until tomorrow though.
13:11:11 <conal> byorgey: okay.
13:13:12 <Cale> Shouldn't Scalar v almost always be a lot more than an additive group?
13:14:31 <conal> Cale: yes.
13:14:34 <nejucomo> Is it possible in ghc (with recent kind additions) to represent an associativity constraint in the type system?
13:15:01 <Cale> nejucomo: Possible? Probably. Reasonable? More questionable.
13:15:06 <hpc> maybe with GADTs as well
13:15:10 <hpc> and data kinds
13:15:24 <hpc> because that gets you value-level Refl
13:15:36 <hpc> "value-level" in fake-quotes
13:16:11 <rwbarton> associativity constraint on what kind of thing?
13:16:44 <rwbarton> a regular function?
13:17:05 <Cale> It's still not easy to take some arbitrary equation and turn it into a type of proofs.
13:17:15 <dolio> The problem with something like an 'associativity constraint' is that all 'proving' you do in Haskell relies on things about types meaning things about terms by construction.
13:18:30 <dolio> And there's no way to state that that 'by construction' property must hold.
13:19:12 <kirindave> edwardk: Ping for a question about your lens library?
13:19:17 <rwbarton> I was going to say you could put an associativity constraint on an associated type, but I guess without quantified constraints you can't really
13:21:18 <dmwit> You can ask for a proof that the type family is associative for the particular arguments you're interested in at the moment.
13:21:30 <kirindave> Maybe today there is someone here who can give me guidance  on this.
13:21:34 <dolio> I can make a leaf binary tree indexed by the list of types at the leaves, and the list appending will be associative, but that doesn't mean that the tree appending will be.
13:21:39 <nejucomo> I am pretty fuzzy here on PL theory, I just wondered if it would be possible to say: "Dear compiler: see this implementation of (+)?  Please ensure it is associative."
13:21:40 <dmwit> F a (F b c) ~ F (F a b) c => {- your type here -}
13:21:52 <Cale> kirindave: Yeah, there are lots of people who can probably help if they know what your question is :)
13:22:01 <kirindave> I'd like to use edwardk's library to write a composable lens that will select/set things inside a traversal, according to a predicate.
13:22:06 <dmwit> nejucomo: Oh, that's much harder.
13:22:12 <nejucomo> -and then "Hey compiler, see this class declaration of (+)?  Please require all implementations are associative."
13:22:19 <kirindave> For example, if I have a list of records where some date > 30 days ago, I'd like to do an action on all them at once.
13:22:23 <rwbarton> see: agda
13:22:27 <nejucomo> I figured it might be.
13:22:28 <dmwit> nejucomo: I think it would be sane to write something like that in Coq and then extract Haskell code from it.
13:22:35 <dmwit> ...or Agda, yes.
13:22:36 <kirindave> I'd really like this to be a composable lens so that I can write my other update functions in terms of a lens
13:22:51 <rwbarton> kirindave: if i understand correctly, that came up earlier today
13:22:54 <nejucomo> rwbarton: hehe..  Ok.  I haven't looked at it yet.  I saw a conference presentation on Coq.  That's about my only exposure to that world.
13:22:59 <kirindave> I did ask about it yesterday
13:23:02 <rwbarton> http://hpaste.org/77003
13:23:03 <kirindave> I found _a_ way to do it with a traversal
13:23:31 <kirindave> Whooah
13:23:43 <kirindave> Exactly what I want!
13:23:48 <kirindave> That should go in the lib.
13:23:50 <copumpkin> those traversals have infinite powah
13:24:09 <copumpkin> a filter traversal?
13:24:43 <copumpkin> I guess filter would be misleading
13:24:45 <edwardk> kirindave: the predicate indexing is tricky. its not a legal traversal
13:24:45 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:24:46 <rwbarton> or a traversal filter
13:24:52 <kirindave> edwardk: oh?
13:24:59 <kirindave> edwardk: Should I not use it?
13:25:19 <edwardk> at least you need to use the caveat that you aren't allowed to replace the target with a value that _fails_ the predicate, because what happens then is the traversal fusion law fails
13:25:35 <edwardk> this is why we don't have such a traversal in the lens package now
13:25:35 <tac> @djinn a -> not (not a)
13:25:37 <lambdabot> -- f cannot be realized.
13:25:37 <copumpkin> aha
13:25:44 <kirindave> edwardk: Oh.
13:25:47 <copumpkin> @djinn a -> Not (Not a)
13:25:47 <lambdabot> f a b = b a
13:25:53 <rwbarton> is there some way to "freeze" the traversal to the particular value
13:25:53 <kirindave> edwardk: Because that's exactly what I want to do.
13:25:57 <rwbarton> or does that not make sense
13:26:06 <edwardk> yeah, thats not a legal traversal, sadly
13:26:12 <kirindave> edwardk: But I guess selecting on a distinct immutable feature is fair?
13:26:16 <copumpkin> now we need something that is almost a traversal ;)
13:26:21 <edwardk> yep. thats what iwhereOf does for instance
13:26:23 <Cale> TraversalLike
13:26:26 <edwardk> e.g. it selects on index
13:26:27 <Cale> heh
13:26:33 <kirindave> edwardk: Hum.
13:26:46 <kirindave> edwardk: I guess I didn't know I could sink my claws into what is considered indexing.
13:26:51 <tac> copumpkin: thank you. I just realized I was messing that up :)
13:27:16 <kirindave> edwardk: "Find an entity named banjo in this list and feed it a banana and update its hunger status" is analogous to what I want to do.
13:27:24 <edwardk> kirindave: but my main point is i deliberately rejected adding the wanna-be traversal you asked for and rejected it ;)
13:27:32 <rwbarton> that was basically the example that came up today
13:27:38 <rwbarton> updating a value in a list of environments
13:27:41 <kirindave> edwardk: I see.
13:27:56 <kirindave> edwardk: I will be careful to not break the law.
13:27:58 <edwardk> you can get a list of one  hole contexts using holesOf, filter the list to find the one you want and update it
13:28:06 <copumpkin> the traversal police will hunt you down
13:28:10 <edwardk> yep
13:28:24 <kirindave> edwardk: Because it's just so awkward to update nested records or lists of records. :(
13:28:41 <kirindave> edwardk: Anything to make it better; I will takeit.
13:28:50 <edwardk> you can make a pseudo-traversal that does what you want. i just can't bring myself to put it in the library
13:29:10 <rwbarton> maybe a little section in the library documentation would stop people from trying to write one
13:29:14 <rwbarton> explaining what you just said
13:29:18 <rwbarton> how to do it instead
13:29:25 <Cale> edwardk: Perhaps you should have another name for generalised things of that sort.
13:29:39 <fruitFly> I'm in the pattern matching chapter of lyah. What programs should I write to get basic experience :D
13:29:48 <edwardk> feel free to concoct a patch for the traversal docs that describe the issue and the workaround ;)
13:29:52 <fruitFly> Hey cale: :)
13:29:59 <clahey> :t (+=)
13:30:01 <lambdabot> Not in scope: `+='
13:30:23 <kirindave> edwardk: If there are alternatives in Lens.Plated, it might be worth pointing docs there?
13:30:26 <edwardk> Cale: i'm not sure i want to. all my combinators will work with them and do _something_, but i've bent over backwards to work within those laws
13:30:26 <mauke> fruitFly: something with lists or trees
13:30:50 <kirindave> edwardk: I see some examples but since I don't know uniplate already it's a bit opaque.
13:31:02 <edwardk> i need more plated examples -- i freely admit
13:31:19 <fruitFly> mauke: I understand what they are. But just curious of ideas of what to o with them.
13:31:23 <fruitFly> to do*
13:31:30 <kirindave> Cuz I want to traverse a list updating entities that match a predicate
13:31:43 <kirindave> Oh, and I want to have monadic side effects as I do so.
13:31:46 <kirindave> Also, I want a pony.
13:31:56 <elliott> haha i come in to ask edwardk a question about lens
13:31:58 <elliott> and what is everyone talking about
13:32:22 <edwardk> =)
13:32:29 <edwardk> elliott: what can i do for you?
13:33:21 <elliott> edwardk: I was wondering whether the "standard" TH-deriving function is meant to be makeLenses or makeClassy, if I just want to generally use lens as a better record system
13:33:43 <edwardk> I use makeClassy whenever it doesn't have an argument, and makeLenses when it does
13:33:55 <edwardk> if you want to be able to use makeClassy all the time, there is an open issue to be resolved ;)
13:34:14 <elliott> er, what kind of argument?
13:34:40 <edwardk> data Foo = Foo { …. }  ; makeClassy ''Foo    data Bar a = Bar { … }; makeLenses ''Bar
13:34:42 <fruitFly> What basic programs should I write to get experience. I'm in the 3rd (pattern matching) chapter of LYAH.
13:34:50 <elliott> oh!
13:34:51 <elliott> right
13:34:59 <elliott> so makeClassy can't handle type arguments
13:35:07 <elliott> oh, it even says so
13:35:18 <clahey> edwardk: Have you thought about doing .&.= and .&.~?
13:35:23 <edwardk> there is an improvement request in to improve makeClassy to support the MPTC/fundeps needed to make it work
13:35:27 <edwardk> clahey: check Data.Bits.Lens
13:35:52 <elliott> edwardk: hmm, does it really need fundeps, not just type families?
13:36:11 <edwardk> elliott: i could probably concoct a type family, it'd just be longer type sigs
13:36:39 <edwardk> its one of those things where both are equivalent for the problem, but the FD version is less verbose
13:36:54 <elliott> edwardk: yeah... it would be nice if TFs were less awkward in type signatures
13:37:37 <edwardk> kirindave: you know you can always fuse the predicate into the function you are traversing with
13:37:50 <kirindave> edwardk: Oh?
13:37:59 <kirindave> edwardk: What is the type of such a predicate then?
13:38:11 <clahey> edwardk: And to have one lens take another, I just compose?
13:38:17 <edwardk> kirindave: myTraversal (\a -> if isFoo a then zap a else pure a)
13:38:20 <edwardk> or whatever
13:38:27 <kirindave> Oh yeah
13:38:31 <kirindave> I discoverd that yesterday
13:38:34 <edwardk> clahey: one lens take another?
13:39:07 <clahey> edwardk: I guess I want to do lens a += lens b
13:39:15 <kirindave> edwardk: That miiight work.
13:39:22 <kirindave> This plate api is fascintating tho.
13:39:25 <edwardk> clahey: you want to read from one lens and write to the other?
13:39:29 <clahey> And have it be set lens a (get lens a + get lens b)
13:39:53 <edwardk> clahey: do t <- use b; a += t
13:39:56 <elliott> hm, if (+=) took a getter that would work, right?
13:40:00 <clahey> edwardk: That's got incorrect grouping, but I think you understand what I mean.
13:40:09 <elliott> though I guess it'd make using a constant increment more ugly
13:40:21 <edwardk> elliott: exactly
13:40:30 <clahey> edwardk: Right.  I think I was thinking lensa ~+ lensb
13:40:45 <elliott> edwardk: clear solution: Getterish typeclass. or a Num instance for Getter. what could possibly go wrong?
13:40:46 <edwardk> maybe ~+~ or something
13:41:01 <clahey> edwardk: That would make sense.
13:41:36 <clahey> Oh, it's +~, isn't it?
13:41:36 <edwardk> =+= is kinda ugly though and this is a LOT of extra combinators to add
13:41:42 <clahey> ~+ might make more sense though.
13:41:46 <clahey> As would =+
13:41:52 <clahey> Though it looks less like C.
13:42:00 <clahey> edwardk: Right.
13:42:06 <clahey> edwardk: So I figured there would be something like:
13:42:11 <edwardk> i have a meaning for ~ prefixed operators without the suffix that doesn't match this already in use in a limited capacity
13:42:13 <clahey> +~ . get
13:42:17 <edwardk> the ~ marks the side taking a lens
13:42:26 <edwardk> so ~+~ fits my semiotics
13:42:44 <clahey> But a +~ b has a lens on the left and an Int on the right, no?
13:42:52 <elliott> Control.Lens.Semiotics
13:43:22 <edwardk> clahey: i suppose you are write, it marks the other side. that unfortunately means the operator would be + ;)
13:43:30 <edwardk> er you are right
13:43:40 <elliott> hm, (Num a) => Num (Lens s a) would actually work, right?
13:43:46 <elliott> oh, no fromInteger
13:44:33 <edwardk> elliott: can't work, sadly
13:44:40 <edwardk> expand lens in that
13:44:47 <clahey> How about (Num a) => Num(Getter s a)?
13:44:50 <edwardk> then try to establish the meanings of the laws
13:44:57 <edwardk> clahey: same problem
13:45:36 <clahey> edwardk: Why can't I search hoogle for things in your library?
13:45:56 <byorgey> clahey: try  adding +lens to the end of your queries
13:46:02 <kirindave> myTraversal (\a -> if isFoo a then pure $ zap a else pure a)
13:46:05 <byorgey> clahey: Hoogle doesn't search all packages on Hackage by default
13:46:16 <kirindave> Seems right.
13:46:19 <byorgey> but you can tell it to search in a particular package
13:46:32 <edwardk> kirindave: if you use pure in both branches there is no monadic/applicative effect
13:46:41 <kirindave> edwardk: Ah.
13:46:42 <edwardk> over mytraversal (\a -> if isFoo a then zap a else a)
13:46:45 <dmwit> stinky default
13:46:53 <clahey> byorgey: (+=) +lens
13:46:56 <clahey> byorgey: No dice.
13:47:05 <elliott> edwardk: oh, right, I guess it doesn't make much sense
13:47:07 <elliott> edwardk: but it should!
13:47:13 <kirindave> Oh oh oh oh.
13:47:15 <kirindave> Okay I get it now.
13:47:17 <dmwit> clahey: It's also possible (likely) that Hoogle doesn't index lens (yet).
13:47:31 <kirindave> lens is gonna false-positive on basically every type query
13:47:34 <edwardk> if hoogle runs an old ghc it may not work at all
13:47:39 <edwardk> kirindave: hahahaha
13:47:54 <edwardk> my advertising strategy will be complete!
13:47:55 <kirindave> edwardk: Enjoy your newfound fame.
13:48:07 <elliott> well you don't need any other packages than lens
13:48:11 <elliott> so it's not wrong
13:48:13 <edwardk> elliott: exactly
13:48:29 <edwardk> its a tool for haskell golf. use it wisely
13:48:31 <byorgey> oh, yeah, I guess hoogle doesn't index lens yet for some reason
13:48:46 <edwardk> right down to the short names and actively discouraging the use of spaces.
13:48:52 <elliott> edwardk: it's not long until it sprouts another module sub-tree and gets trifecta :: Quasitraversal ...
13:49:06 <kirindave> The cryfecta.
13:49:25 <clahey> edwardk: So, is there a wiki page about how one might use the lens library to do a fold?
13:49:49 <edwardk> clahey: you mean write a custom Fold or just foldr etc with a traversal or fold?
13:50:29 <clahey> edwardk: I mean (a->a -> a) -> [a] -> a
13:50:44 <edwardk> foldrOf :: Getting (Endo e) a b c d -> (c -> e -> e) -> e -> a -> e
13:50:47 <clahey> edwardk: Not sure which of your options that is.
13:51:05 <edwardk> you want a foldr, for a particular fold, just use foldrOf ;)
13:51:25 <edwardk> in general if you know the combinator from Data.Foldable, just bolt 'Of' on the end of it and pass it the Fold explicitly
13:52:44 <elliott> I wonder why Foldable bothers me but Control.Lens.Fold.Fold doesn't.
13:52:53 <edwardk> allOf :: Getting All a b c d -> (c -> Bool) -> a -> Bool
13:52:56 <edwardk> etc.
13:52:59 <edwardk> elliott: =)
13:53:11 <edwardk> I actually like Foldable quite a bit
13:53:19 <nohonor> Cale, can I ask a brief follow-up question?
13:53:28 <Cale> nohonor: sure
13:53:28 <nohonor> what about http://hpaste.org/77020
13:53:33 <edwardk> i do love the fact that when you have a Getter, you can use the combinators from C.L.Fold.Fold without any obligations though
13:53:46 <edwardk> sumOf _2 (1,"hello")   ==> "hello"
13:54:04 <nohonor> for any instantiation of a this function returns an Int
13:54:07 <Cale> nohonor: Aha, yes, the other thing about types is that they're not around at runtime
13:54:13 <elliott> I don't mind Foldable's fold but I wish it didn't have foldr/foldl and so on in it, I guess
13:54:33 <clahey> edwardk: So, what's an example of a Fold that isn't a Foldable?
13:54:43 <edwardk> clahey: foldMap.foldMap
13:54:45 <Cale> nohonor: and so when a function has type  a -> Int,  it's a guarantee that it doesn't look at its argument
13:54:48 <nohonor> aha, so it's a practical consideration
13:54:59 <Cale> nohonor: Partly, but this is also quite useful
13:55:07 <edwardk> clahey: _2.traverse.folded._1.traverse
13:55:08 <Cale> nohonor: consider something like the type of map
13:55:15 <nand`> edwardk: does the combinator I sent you break any traversal laws? (too lazy to check)
13:55:15 <Cale> map :: (a -> b) -> [a] -> [b]
13:55:16 <edwardk> clahey: er not foldMap.foldMap i meant folded.folded
13:55:30 <edwardk> nand`: link?
13:55:51 <Cale> this type ensures that every element of the resulting list must consist of the function applied (exactly once!) to some element of the input list
13:56:18 <Cale> It makes it very hard to screw up the definition without actively trying to screw it up.
13:56:30 <nand`> edwardk: http://hpaste.org/77007
13:56:33 <clahey> edwardk: foldrOf ((folded . folded) ([[a, b], c])) = foldr [a, b, c] ?
13:56:50 <Cale> You might duplicate elements or leave them out of the output, or get them in the wrong order
13:56:54 <edwardk> you need [c] in the input but then yes
13:56:54 <copumpkin> how does that typecheck?
13:56:58 <Cale> but that's all that can go wrong
13:57:05 <Cale> If I were to write
13:57:09 <clahey> edwardk: foldrOf ((folded . folded) ([[a, b], [c]])) = foldr [a, b, c] ?
13:57:11 <clahey> Right.
13:57:16 <Cale> map [] = []; map f (x:xs) = x : map f xs
13:57:17 <edwardk> clahey: yep
13:57:22 <Cale> then the typechecker will complain!
13:57:28 <Cale> (given that type signature)
13:57:33 <edwardk> nand`: it fails
13:57:47 <copumpkin> map [] = []; map f (x:xs) = f x : f x : f x : map f xs
13:57:58 <edwardk> nand`: its convenient but illegal. what happens when you change the target to a new value that fails the predicate?
13:58:05 <clahey> edwardk: So, folded claims to take a Foldable and return a Fold.
13:58:07 <Cale> but yes, you can write things like copumpkin wrote
13:58:10 <edwardk> clahey: yep
13:58:10 <clahey> edwardk: Is every Fold a Foldable?
13:58:24 <edwardk> clahey: no. folded.folded isn't a Foldable result
13:58:26 <nand`> edwardk: I'm not sure what you mean
13:58:29 <nand`> example?
13:58:51 <clahey> edwardk: But if folded takes a Foldable, how can you pass the return value to itself?
13:59:05 <Cale> nohonor: So polymorphic types end up revealing quite a bit about their values.
13:59:14 <Cale> nohonor: does that make sense?
13:59:34 <nohonor> Cale, i'm trying to understand it :-)
13:59:36 <clahey> edwardk: For x . x to type check, doesn't x have to be of type a -> a?
13:59:40 <Cale> (I didn't really explain the type of map very carefully, so if you haven't seen the type of a higher order function yet, it might be confusing)
13:59:45 <edwardk> nand`: let evens = restrict even traverse in  foo % evens %~ (+1) % evens %~ (+1)       doesn't equal foo % evens %~ (+1) . (+1)
13:59:50 <Cale> map :: (a -> b) -> [a] -> [b]
13:59:57 <Cale> means that it takes a function of type (a -> b)
14:00:00 <edwardk> over l f . over l g = over l (f . g) fails
14:00:02 <Cale> and a list of values of type a
14:00:07 <Cale> and produces a list of values of type b
14:00:20 <nand`> edwardk: ah, that makes sense
14:00:22 <nand`> shame
14:00:37 <Cale> and since it doesn't know what the types a and b are, the only place it can get values of type a is from the list
14:00:48 <nohonor> Cale, actually i'm quite comfortable with functional programming per se
14:00:48 <edwardk> :t Data.Foldable.foldMap . Data.Foldable.foldMap
14:00:49 <Cale> and the only place it can get values of type b is by using the function on values of type a
14:00:50 <lambdabot> forall m (t :: * -> *) a (t1 :: * -> *). (Data.Foldable.Foldable t, Monoid m, Data.Foldable.Foldable t1) => (a -> m) -> t (t1 a) -> m
14:01:03 <edwardk> the definition in question is similar to that with some newtypes on the m's
14:01:07 <nohonor> just trying to conceptualize the HM type system is taking some time
14:01:20 <edwardk> :t Data.Foldable.foldMap . Data.Foldable.foldMap . Data.Foldable.foldMap
14:01:21 <lambdabot> forall (t :: * -> *) m (t1 :: * -> *) a (t2 :: * -> *). (Data.Foldable.Foldable t, Monoid m, Data.Foldable.Foldable t1, Data.Foldable.Foldable t2) => (a -> m) -> t (t1 (t2 a)) -> m
14:01:30 <edwardk> :t Data.Foldable.foldMap . Data.Foldable.foldMap . Data.Foldable.foldMap . Data.Foldable.foldMap
14:01:31 <lambdabot> forall (t :: * -> *) (t1 :: * -> *) m (t2 :: * -> *) a (t3 :: * -> *). (Data.Foldable.Foldable t, Monoid m, Data.Foldable.Foldable t1, Data.Foldable.Foldable t2, Data.Foldable.Foldable t3) => (a ->
14:01:32 <lambdabot> m) -> t (t1 (t2 (t3 a))) -> m
14:01:36 <Cale> and so you're guaranteed that the values in the resulting list *must* have come from applying the function to the values in the input list
14:01:36 <tac> nohonor: HM is confusing when it doesn't work.
14:01:47 <Cale> Does that make sense?
14:01:55 <nohonor> i get that part
14:01:56 <edwardk> to be Foldable that t (t1 (t2 (t3 a)))) would have to have a different form, e.g. balled up in a newtype
14:02:01 <dmwit> HM can be confusing even when it does work.
14:02:07 <acowley> edwardk: You wrote about some HOAS stuff in the past, do you have any libraries for dealing with it?
14:02:12 * dmwit tries to recall the example that confused him the other day
14:02:21 <edwardk> acowley: i use 'bound' rather than hoas mostly
14:02:34 <tac> dmwit: :)
14:02:42 <edwardk> and occasionally use hoas as a starting point to get into that form
14:02:45 <nohonor> so the lack of RTTI means there's no way to pattern match against something if you don't know its type
14:02:52 <nohonor> statically
14:02:52 <Cale> right
14:02:59 <tac> at its heart, Hindley-Milner is filling in invisible parts of your program with things it's decided need to be there.
14:03:04 <dmwit> :t id :: (forall m. Monad m => m a) -> IO a -- grep remembers better than I do
14:03:05 <lambdabot> forall a. (forall (m :: * -> *). (Monad m) => m a) -> IO a
14:03:16 <edwardk> nohonor: correct. you can put a 'Typeable' constraint on it, to get a sort of opt-in RTTI going, but you can see it cleanly in the signatures
14:03:25 <Cale> and this is not just a pragmatic issue of memory usage, but it's actually *convenient* because it makes types mean more than they otherwise would
14:03:41 <clahey> edwardk: So foldMap . foldMap has to take a Foldable (Foldable t)
14:03:55 <Cale> If we could check which type 'a' was and have map do something different, then the type wouldn't be as meaningful
14:03:58 <clahey> Oh.  I thought folded was a function.  My bad.
14:04:05 <dmwit> tac: So riddle me this: what value is HM plugging in for the "forall" in "forall a. a -> a" that is id's type? =)
14:04:12 <dmwit> s/value/type/ I guess
14:04:18 <acowley> edwardk: This doesn't seem as elegantly robust as PHOAS. But the fact that it is working (I assume) code votes tremendously in its favor.
14:04:19 <edwardk> folded _is_ a function. Fold, Lens, Traversal are just aliases for functions of a given form
14:04:21 <acowley> edwardk: thanks
14:04:31 * hackagebot network-house 0.1.0.0 - data and parsers for Ethernet, TCP, UDP, IPv4, IPv6, ICMP, DHCP, TFTP  http://hackage.haskell.org/package/network-house-0.1.0.0 (NiklasHambuechen)
14:04:34 <nohonor> Cale, yes, indeed
14:04:36 <tac> dmwit: It's plugging in some suitable type. It's also context-dependent
14:04:36 <clahey> edwardk: Starting to get it.
14:04:36 <nohonor> i see
14:04:37 <edwardk> acowley: phoas is a fairly big pain in the ass to work with
14:04:46 <simpson> NETWORK HOUSE!
14:04:47 <acowley> edwardk: It's basically impossible is what I'm discovering!
14:04:51 <clahey> edwardk: And the combinators take some functions and combine them in interesting ways.
14:04:51 <copumpkin> faux ass
14:04:56 <edwardk> acowley: phoas is?
14:04:57 <dmwit> tac: "some suitable type"? I gave the context.
14:05:08 <tac> for id "hello world", it passes in String for a
14:05:14 <tac> id {a = String} "hello world
14:05:15 <tac> "
14:05:16 <edwardk> i find the need to write all my one-off traversals with phoas/weak hoas to be damning enough that i stopped
14:05:17 <acowley> edwardk: So many papers that don't come with code, and a tendency to work in extensions of an existing language
14:05:22 <clahey> edwardk: Where is Folding defined?
14:05:31 <edwardk> acowley: bound uses only haskell 98
14:05:31 <dmwit> tac: id :: (forall m. Monad m => m a) -> IO a works, see above
14:05:45 <tac> oh, I didn't see the example
14:05:53 <dmwit> Despite the fact that there's no single type you can plug in that results in that. =P
14:05:56 <edwardk> acowley: and encapsulates all of the details of capture avoiding substitution in combinators that fit on a slide =P
14:06:13 <edwardk> acowley: did you see the bound slides?
14:06:18 <nohonor> thanks everyone, i'm saving this log :-D
14:06:19 <acowley> edwardk: no
14:06:20 <dmwit> I guess HM isn't really involved there.
14:06:24 <dmwit> But I find it surprising anyway.
14:06:34 <edwardk> acowley: start with http://www.slideshare.net/ekmett/bound-making-de-bruijn-succ-less and the haddocks
14:06:38 <edwardk> @hackage bound
14:06:39 <lambdabot> http://hackage.haskell.org/package/bound
14:06:39 <dmwit> No matter whose job it is.
14:06:53 <edwardk> there are 3 examples in the examples folder of incremental complexity.
14:07:06 <edwardk> i recommend looking first at Simple and then at Deriving for how to automate some of the boilerplate
14:07:08 <nohonor> and definitely thank you, Cale
14:07:17 <edwardk> and for a more complicated example including pattern matching
14:07:28 <tac> dmwit: in that example, there are two implicit applications
14:07:49 <tac> id {a = forall m. Monad m => m a } :: (forall m. Monad m => m a) -> (forall m. Monad m => m a)
14:07:50 <edwardk> acowley: if you need to work in coq though, you are probably screwed ;)
14:08:00 <tac> then, it fills in the second m with IO
14:08:01 <edwardk> and its back to the phoas mines with you
14:08:02 <acowley> edwardk: This is for some DSL thing I wanted to exist
14:08:07 <acowley> in Haskell
14:08:21 <edwardk> acowley: let me see if i have an example of how to convert from finally tagless to bound here
14:08:35 <tac> id {a = forall m. Monad m => m a } foo {m = IO}
14:08:49 <dmwit> I didn't say foo anywhere. =)
14:08:54 <dmwit> But yes, it floats all foralls implicitly.
14:09:23 <tac> dmwit: heh, then it would be a little more delicate, but I think you can still get it working
14:09:37 <dmwit> Yeah, it's the usual surprising thing with GHC: foralls get juggled crazily.
14:09:43 <dmwit> Okay, I feel much less confused now, thanks!
14:09:47 <tac> dmwit: actually, you know what. you don't give *enough* context here, I don't think :)
14:10:02 <elliott> edwardk: ooh, bound looks fancy
14:10:09 <edwardk> @hpaste
14:10:10 <lambdabot> Haskell pastebin: http://hpaste.org/
14:10:16 <dmwit> hm
14:10:26 <hpaste> edwardk pasted “hoas-to-bound for acowley” at http://hpaste.org/77021
14:10:30 <dmwit> > (id :: (forall m. Monad m => m a) -> [a]) (return 3)
14:10:32 <lambdabot>   [3]
14:10:37 <tac> dmwit: \x -> id {a = forall m. Monad m => m a } x {m = IO}
14:10:43 <elliott> edwardk: heh, your Exp example for LC is the same as my favourite definition
14:10:46 <edwardk> acowley: the conversion there is a bit ugly i admit
14:10:46 <dmwit> Strange, I can't get this to typecheck on my own ghci. =P
14:10:46 <elliott> (expanding out Scope)
14:11:03 <elliott> (data Term a = Var a | Apply (Term a) (Term a) | Abstract (Term (Maybe a)))
14:11:07 <acowley> edwardk: this is great!
14:11:08 <dmwit> tac: Nah, it's just id {a = forall m. Monad m => m a } {m = IO}
14:11:09 <edwardk> elliott: yeah, its the nice polymorphic recursive definition, i just factored out the capture avoiding substitution
14:11:19 <tac> dmwit: there's two m's
14:11:22 <edwardk> elliott: there is one benefit to mine over yours though… mines faster ;)
14:11:31 <dmwit> tac: With the observation that (forall m. Monad m => m a) -> (forall m. Monad m => m a) = forall m. (forall m. Monad m => m a) -> m a
14:11:37 <tac> dmwit: and in my mental model, I'm treating forall m. the same way agda would do {m : Set} ->
14:11:46 <edwardk> i'm using what is effectively Abstract (Term (Maybe (Term a)))  in it. that lets me 'succ' entire trees rather than just leaves
14:11:56 <tac> but Haskell's model is more liberal in how it's done
14:12:02 <edwardk> this means i get O(1) weakening, and i _also_ get faster instantiation
14:12:06 <elliott> edwardk: hrm, are you really
14:12:08 <acowley> edwardk: you used McBride's syntax in your slides
14:12:12 <dmwit> tac: Which is the kind of translation that GHC does all the time, implicitly and invisibly and without allowing the user any control over when it's done and when it isn't (which causes problems sometimes).
14:12:12 <acowley> edwardk: :((((((
14:12:17 <edwardk> acowley: deliberately =)
14:12:19 <dmwit> tac: right
14:12:30 <elliott> Lam (Scope () Exp a) -> Lam (Exp (Var () (Exp a)))
14:12:32 <acowley> edwardk: I was reading it last night and decided it was mocking me
14:12:39 <edwardk> acowley: hahahaha
14:12:40 <elliott> Lam (Scope () Exp a) -> Lam (Exp (Maybe (Exp a)))
14:12:42 <elliott> edwardk: so you are. cheating!
14:12:45 <edwardk> the letmeb this stuff?
14:12:48 <acowley> yes
14:12:49 <tac> dmwit: Although, to give HM credit, that produces a rank-2 type
14:12:55 <elliott> edwardk: however I think mine has a nicer definition of whnf using the monad instance
14:12:56 <tac> and HM doesn't touch rank-2 on its own
14:12:57 <clahey> edwardk: I'm really trying to get this.  Where are Folding and Getting defined?
14:13:00 <edwardk> elliott: its _generalized de bruijn_ not _de bruijn_
14:13:02 <elliott> edwardk: though I forget what that definition actually is
14:13:03 <dmwit> tac: Yeah, I realized that HM isn't involved at all here, really.
14:13:16 <dmwit> tac: Though I wonder what extensions lambdabot has on, because I can't get this to work in ghci. =P
14:13:16 <edwardk> elliott: the key here is you can't screw it up
14:13:28 <elliott> mm
14:13:34 <tac> dmwit: I had that same problem earlier when I was re-inventing the "better" Cont Monad
14:13:47 <edwardk> elliott: i have to use fromScope and toScope in nf, but otherwise everything is faster
14:13:55 <tac> Trying reason about ((a -> forall b. Cont r b) -> Cont r a) -> Cont r a is kinda hard :)
14:13:56 <edwardk> the speed difference can be considerable, too
14:14:03 <dmwit> Yeah, the only way to prevent GHC from juggling foralls is to add data or newtype. Way annoying.
14:14:06 <edwardk> and the definition of the monad is much easier for the end user
14:14:08 <tac> add to it that Cont r x is a newtype
14:14:08 <acowley> It's obfuscation through some kind of nursery rhyme meter
14:14:19 <edwardk> you could make a version of Scope that used EitherT, but it'd just be slower
14:14:40 <edwardk> acowley: sorry. just look at the def in my library. i used it in the slides mostly for humor
14:14:40 <elliott> edwardk: mm
14:14:42 <dmwit> ?where lambdabot
14:14:42 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
14:14:51 <acowley> It was the contraction apostrophes that pushed me over the edge yesterday :P
14:15:06 <tac> dmwit: With higher-rank polymorphism, it quickly becomes important that you have a good IDE
14:15:08 <elliott> edwardk: mine is simpler though! so it's better for impressing people on IRC when they ask you how to represent the LC
14:15:11 <elliott> which happens, like, every day
14:15:15 <acowley> edwardk: Yeah, I know, I just didn't get a chance to complain about it on irc yesterday  :P
14:15:20 <edwardk> tac: reasoning tip. figure out what forall b. Cont r b is equivalent to first
14:15:44 <tac> edwardk: it's iso to r
14:15:48 <tac> I believe
14:16:09 <nand`> edwardk: I wonder if it would possible to, in the spirit of restrict; write a function that works like it but memoizes the actual positions for some particular input, then keeps those fixed no matter how they change
14:16:11 <edwardk> elliott: mine is a lot easier to use, harder to screw up, is encapsulated so you don't have to redo all the thinking for each instance and is faster. ;) overall i think thats a good trade-off for a library =)
14:16:19 <nand`> not as useful, but still works in some use cases
14:16:27 <nand`> memorizes, even
14:16:45 <tac> edwardk: You can't produce a value for b, so it can't produce an r through the (b -> r) it's given
14:16:48 <tac> so it obviously must be r
14:16:54 <elliott> edwardk: yes, it looks very cool
14:17:17 <edwardk> nand`: doesn't really work though. you might be able to take one that takes a traversal and a predicate and a value and gives you a new traversal, but then you have to pass in a value (presumably the same?) all over again
14:17:28 <tac> It's basically that which means that callCC must throw away the current continuation when 'exit' is invoked
14:17:48 <edwardk> tac: great, now plug in r for forall b. Cont r b    and your def is easier to think about
14:17:50 <nand`> edwardk: yeah, that's what I meant
14:17:58 <tac> edwardk: I did it the hard way
14:18:14 <tac> luckily, it's one of those things where you're given *exactly* enough to solve it
14:18:15 <tac> and no more
14:18:22 <edwardk> tac: so did i at first. dolio taught me to think about it the other way though ;)
14:18:30 <Cale> nohonor: Oh, it should be pointed out though, that if you really want an operation which acts at different types, like for example 'show', then that's what the whole story of type classes is about.
14:18:51 <edwardk> acowley: hahaha
14:19:10 <Cale> nohonor: Those give you a way to constrain the types over which the type variables range to just those which implement a given interface.
14:19:54 <Cale> nohonor: So you get things like  sort :: (Ord a) => [a] -> [a]  which says that a can't just be any type, but must be a type for which the ordering operations like (<=) have been defined.
14:20:03 <nohonor> but you still can't pattern-match against them
14:20:31 <Cale> right, though when you write instances of a type class, you provide the implementation for one type at a time
14:20:48 <nohonor> yes, i think i get it
14:20:50 <nohonor> pretty neat
14:21:05 <Cale> and then other things which use the stuff that you provide in the instances, like sort, become polymorphic just by making use of the operations
14:21:10 <dmwit> :t id
14:21:11 <lambdabot> forall a. a -> a
14:21:25 <tac> edwardk: I'll think about that.
14:22:26 <Cale> i.e. you don't actually have to write a new implementation of sort for every type -- when defining an instance of Ord for your data type, you just define (<=) (or more likely an operation called compare)
14:23:01 <nohonor> but you can still reason about the behavior of the function from its type signature alone
14:23:08 <Cale> yeah, you can
14:23:29 <Cale> For example, I know that sort can't put any items in the resulting list which weren't in the given one
14:23:32 <edwardk> nand`: you can of course find the indices where the predicate passes pretty easily
14:23:49 <edwardk> matches l p = setOf (ifiltered p (indexed l))
14:24:02 <Cale> and it can't really do anything with those elements apart from comparing them using the ordering and equality operations
14:24:05 <edwardk> then you can use the matches that you got from that with elementsOf
14:24:12 <nand`> ah
14:24:22 <edwardk> er iwhereOf
14:25:00 <nohonor> Cale, is that useful in practice?
14:25:01 <edwardk> iwhereOf l (\i -> mySet^.contains i)
14:25:29 <Cale> nohonor: Yeah
14:25:44 <Cale> nohonor: I've had really nontrivial bugs detected in my code this way.
14:25:44 <edwardk> matches constructs a set using the traversal as a fold, then you use that set to make another valid traversal for subsequent edits
14:26:06 <edwardk> then traversal fusion holds
14:26:16 <Cale> nohonor: Where I actually had the wrong algorithm, and the type system was able to tell me that I was full of shit :)
14:26:57 <edwardk> acowley: how goes the dive into bound's docs?
14:27:11 <davorb> is there a way to zip two lists, where if one list is shorter than the other the result will be the same length as the longer list?
14:27:12 <nohonor> very curious
14:27:41 <edwardk> davorb: its not in the standard library, but you can of course write it
14:27:47 <Cale> It doesn't catch everything, but the more constraints and such that end up in your types, the more complicated things you can prove about your code. Of course, it's a tradeoff -- there are often prices that you pay in how much (keyboard) typing you need to do to prove to the compiler that your code is right.
14:27:59 <davorb> edwardk: ok, thanks.
14:28:07 <edwardk> davorb: you need to figure out what to do to map the remnants appropriately
14:28:20 <Cale> But you can often strike a good balance which saves you from most of your debugging time :)
14:28:40 <edwardk> e.g. zipWithTails :: (a -> b -> c) -> (a -> c) -> (b -> c) -> [a] -> [b] -> [c]
14:28:46 <nohonor> i look forward to reaping its benefits then :-)
14:29:06 <davorb> btw is there a way to iterate over a list from "behind" without having to use reverse and doing it from the front on that?
14:29:26 <copumpkin> "iterate"?
14:29:52 <copumpkin> davorb: keep in mind that it's a singly linked list, so the end of the list doesn't know about the things "in front of" it
14:29:55 <scp> why does this take tons of memory:
14:30:01 <davorb> well, when i go through a list i might do so using (x:xs). that way i start with the first element and work back.
14:30:03 <Cale> davorb: Sometimes there's a way to avoid having to traverse the list in reverse at all.
14:30:03 <edwardk> davorb: reverse or an appropriate foldr probably does what you want. if you want pattern matching on the right of the list you need to reverse, if you are smart about it you can usually turn the code into a careful foldr though
14:30:07 <scp> foldl (+) 0 [9999999999,9999999998..1]
14:30:20 <edwardk> scp: try foldl'
14:30:37 <Cale> Well, foldr is going through in the sane order
14:30:41 <Cale> foldl is backwards :)
14:30:58 <scp> wait, foldl is backwards?
14:31:02 <scp> I thought foldr was x_X
14:31:05 <Cale> (in reference to davorb's question)
14:31:07 <edwardk> scp: for a lazy language, it is
14:31:13 <nohonor> scp, foldr folds the list in the order of construction
14:31:16 <scp> ohhhh.... of course
14:31:25 <scp> ok, then I haven't been writing bad erlang for years  =]
14:32:01 <Cale> but I also mean backwards in the sense that
14:32:12 <Cale> foldr (:) []  is id
14:32:19 <Cale> while  foldl (flip (:)) []  is reverse
14:32:53 <scp> let me think on that for a minute x_X
14:33:04 <Cale> > foldr (:) [] [1..]
14:33:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:33:13 <Cale> > foldl (flip (:)) [] [1..10]
14:33:15 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
14:33:25 <`Jake`> > foldl (flip (:)) [] [1..]
14:33:26 <acowley> edwardk: I went through the slides, and it looks good. I'm still trying to fight through some of the problems I'm having with this PHOAS code, though, because I can't figure out how to fix it.
14:33:30 <lambdabot>   mueval-core: Time limit exceeded
14:34:12 <scp> wait, foldr starts from the right of the list
14:34:13 <acowley> I think I'm just tripping over existential binding land mines
14:34:17 <scp> and works left, right?
14:34:23 <scp> (err, correct?)
14:34:50 <dmwit> foldr uses a right-associative operation
14:35:01 <dmwit> "starts from" is an ill-defined term
14:35:03 <mauke> scp: no
14:35:37 <scp> in terms of addition
14:35:39 <nohonor> both folds start from the left
14:36:02 <scp> foldl (I thought) is ((((a + b) + c) + d) + e)
14:36:13 <scp> and foldr (a + (b + (c + (d + e))))
14:36:19 <rwbarton> yes
14:36:23 <dmwit> Those two statements I can get behind.
14:36:26 <dmwit> The other ones, not as much.
14:36:31 <nohonor> yes, but the a element is considered first in both cases
14:36:38 <acowley> dmwit: behind is an ill-defined term
14:36:39 <acowley> :P
14:36:43 <dmwit> =D
14:37:27 <scp> so, with foldr, you must compute d+e before you have anything to do with a
14:37:45 <scp> which means you must evaluate the last element of the list (in this case e)
14:37:52 <Jetbeard> scp, in terms of foldr, yes, but not in the general case
14:38:04 <scp> Jetbeard: what do you mean? o_O
14:38:11 <nohonor> scp, not with lazy evaluation
14:38:15 <Jetbeard> > foldr const undefined [1..]
14:38:17 <lambdabot>   1
14:38:26 <dmwit> "you must compute d+e before you have anything to do with a" <- can't get behind this
14:38:28 <Jetbeard> i meant, uh, in terms of *addition*
14:38:33 <Jetbeard> sorry, it's late and i'm not sober
14:38:47 <scp> Jetbeard: no problem =]
14:39:02 <Jetbeard> but if the operator used with foldr is lazy, then the rest of the list won't necessarily have to be evaluated
14:39:03 <scp> dmwit: assuming '+' is an arbitrary right-associative operation
14:39:19 <dmwit> scp: I'm happy assuming that. still can't get behind it
14:39:31 <scp> dmwit: Can you explain?
14:39:31 * hackagebot language-ecmascript 0.10 - JavaScript analysis tools  http://hackage.haskell.org/package/language-ecmascript-0.10 (AndreyChudnov)
14:39:37 <Jetbeard> scp, the right argument to (+) will be d+e
14:39:38 <nohonor> foldr f z [a, b, c ...] = f a (foldr f z [b, c ...])
14:39:46 <Jetbeard> but that doesn't mean that d+e will necessarily be evaluated
14:39:48 <dmwit> Perhaps there exists some right-associative operator where that is true, but not all right-associative operators make that true.
14:40:01 <vroca> hi guys! ¿do you know there is a good support for cassandra CQL V3 in haskell? thanks
14:40:13 <nohonor> and in the case of (:) in a lazy evaluation model you can start returning the result even though it's an infinite list
14:40:14 <dmwit> For example, as demonstrated above, if the operator is const. =)
14:40:28 <nohonor> before bottoming out the recursion
14:40:55 <dmwit> vroca: Hackage seems to have a few Cassandra packages; have you looked at them?
14:41:12 <scp> yes but dmwit, foldr (or ghc) can't deduce whether or not that is true for a particular operator (in the general case)
14:41:20 <Jetbeard> (i enjoy pathological examples more than easy-to-understand ones, 'const' seemed like the most peverse operator to use)
14:41:44 <dmwit> scp: Why would it try to?
14:41:54 <tac> edwardk: Isn't the iso between r and forall b. (b -> r) -> r what the Yoneda Lemma says?
14:41:59 <vroca> dmwit: I'm a newbie. just asking to see if I get a strong answer.
14:42:05 <Jetbeard> scp, in the general case, the right-hand argument will only be evaluated if the operator depends on it
14:42:14 <edwardk> tac: yes, thats basically Yoneda Identity
14:42:21 <Jetbeard> ghc doesn't have to statically deduce whether or not an operator is lazy
14:42:30 <edwardk> newtype Yoneda f a = Yoneda (forall r. (a -> r) -> f r)
14:42:45 <edwardk> er
14:42:48 <edwardk> actually no
14:42:56 <edwardk> its not in this case. notice the quantifier is on the wrong thing
14:43:28 <tac> edwardk: oops, I got it wrong
14:43:35 <tac> forall b. Cont r b *
14:43:40 <tac> wait..
14:43:42 <scp> Well, I'm sure it does in order to produce code for it x_X
14:43:56 <tac> oh well, I'll think about it
14:43:57 <scp> but, I see what you mean
14:44:25 <elliott> it doesn't really have to statically infer such a thing to know how to produce code
14:44:29 <dmwit> scp: Reevaluate your assumptions. The thing you are sure of is incorrect.
14:44:30 <elliott> or at least
14:44:34 <elliott> probably not in the way you are thinking
14:45:40 <clahey> Effect m r a is sorta like Const (m r) a?
14:46:25 <clahey> Gettable is a class with kind * -> * ?
14:47:47 <scp> ok, here is a question that might have a more telling answer
14:48:11 <scp> whi does 'foldl const undefined [1..]' hang?
14:48:16 <scp> s/whi/why
14:48:34 <Silox|> Is there a way I can tell ghci to not calculate stuff, but to show all the function calls etc?
14:48:40 <Silox|> like factorial 3 would result in: 3 * 2 * 1?
14:48:48 <Silox|> or 3 * factorial 2 * factorial 1?
14:49:01 <Jetbeard> scp foldl f e (x:xs) = foldl f (e `f` x) xs
14:49:14 <Jetbeard> so in the case of foldl, e (in this case, undefined) is the left argument to const
14:49:26 <Jetbeard> and const undefined _ = undefined
14:49:28 <acowley> Okay, I need a hint: how can I define xmapExpF from page 6 of http://www.iro.umontreal.ca/~monnier/tct.pdf
14:49:41 <acowley> I'm just chasing my tail on it
14:49:46 <rwbarton> const never actually even gets evaluated at all
14:50:14 <rwbarton> because it needs to find the end of the list to apply the outermost const, and there isn't one
14:50:38 <scooty-puff> Silox|: try searching on hackage for simple-reflect
14:50:39 <rwbarton> it just builds up a bigger and bigger expression in the second argument forever, eating up all your memory
14:50:47 <acowley> The lambda case always leaves me at a type error like, "Could not deduce (t ~ (t10 -> t20)) from the context (a t ~ r (t1 -> t2))"
14:50:47 <Jetbeard> oh yeah, duh
14:51:04 <edwardk> clahey: yes, except in a form that lets me compose it with pure Const-like results
14:51:08 <dmwit> scp: Because foldl is tail-recursive. =)
14:51:22 <Jetbeard> > foldl const undefined [1]
14:51:24 <lambdabot>   *Exception: Prelude.undefined
14:51:36 <Silox|> scooty-puff: Great, thanks!
14:52:08 <scp> am I correct in assuming that [n..] = n:[(n+1)..]
14:52:18 <scp> if that were valid syntax
14:52:21 <dmwit> scp: close enough to correct, yes
14:52:27 <rwbarton> Reasonably correct.
14:52:39 <edwardk> clahey: I use 'Gettable' rather than Const directly because it enables more combinators to work with more lens-like constructions
14:52:42 <clahey> edwardk: Accessor is a newtype that has a bunch of classes.  Since Getting is a type and not a class or newtype and since it's just a function, there are functions that are of both type.
14:52:47 <scp> so, maybe I misunderstand laziness in a fundamental way or something
14:52:49 <Jetbeard> > take 10 [1..]
14:52:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:52:52 <dmwit> ?src Integer enumFrom
14:52:52 <lambdabot> Source not found.
14:52:57 <mauke> > let n = 1 in n:[(n+1)..]
14:52:58 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:53:01 <mauke> it is valid syntax
14:53:11 <Jetbeard> mauke, the right hand is
14:53:25 <clahey> edwardk: Right, Gettable is a class that generalizes Const in the same way that Functor is a class that generalizes []
14:53:34 <rwbarton> that would be "cool" if you could define enumFrom that way
14:53:43 <edwardk> clahey: Functor generalizes more than []
14:54:03 <mauke> > let n = 1 in n : [succ n ..]
14:54:03 <scp> and we did say that foldl f acc (x:xs) = foldl f (f acc x) xs, right?
14:54:04 <clahey> edwardk: It is a generalization of [] as well as a generalization of other things, perhaps?
14:54:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:54:12 <scp> that was foldL, not foldR
14:54:18 <edwardk> Gettable models an 'anyvariant' functor, one where the type argument is purely phantom
14:54:29 <dmwit> ?src foldl
14:54:29 <edwardk> the law for it is fmap f = coerce for any Gettable functor
14:54:29 <lambdabot> foldl f z []     = z
14:54:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:54:42 <dmwit> scp: looks good
14:54:45 <edwardk> newtype Const r a = Const r  obviously satisfies this law.
14:55:17 <clahey> edwardk: But when learning Functors as being [] or Maybe or Either and seeing how they each work.
14:55:18 <edwardk> but if you have something like newtype Backwards f a = Backwards (f a); then you can make instance Gettable f => Gettable (Backwards f)
14:55:36 <scp> ok, just a sec, need to fiddle in ghci to make sure I'm not crazy
14:55:36 <edwardk> sure, but all of those examples are also traversable
14:55:48 <clahey> edwardk: So for now, whenever I see Gettable I'll think, "Const, but generalized" and it will help me remember what a Gettable is.
14:55:52 <edwardk> the target of a function space is where you start being something that is functor but not traversable
14:56:10 <clahey> edwardk: That's too advanced for where I am.
14:56:12 <dmwit> scp: So, foldl const undefined [1..] = foldl const undefined (1:[2..]) = foldl const (const undefined 1) [2..] = {- ... -} = foldl const (const (const undefined 1) 2) [3..] = ...
14:56:30 <clahey> I need to start writing Learn You The Lenses
14:56:53 <dmwit> scp: You never quite get to the part where you start evaluating that deeply-nested (const (const (const (const ... (const undefined 1) 2) 3) ...) thunk, because you just keep walking down the list looking for the end.
14:56:56 <edwardk> functors can update an uncountably infinite number of targets. traversals only can update countably many (and to some folks' mind, only finitely many)
14:57:08 <scp> but but but
14:57:14 <scp> the whole point of a fold is that it can accumulate
14:57:38 <dmwit> If you're wondering how come we don't evaluate that deeply-nested thunk as we go, the answer is, we could, and it wouldn't help.
14:57:42 <dmwit> What we'd get then is:
14:57:57 <dmwit> foldl const undefined [1..] = foldl const 1 [2..] = foldl const 2 [3..] = ...
14:58:03 <clahey> edwardk: Yeah, I know what Functors are.  I was just using that as an analogy to the learning style for learning Functors.
14:58:04 <dmwit> which still never finds the end of the list. =)
14:58:07 <scp> that is true
14:58:12 <geekosaur> scp: it is accumulating.  it's accumulating unevaluated expressions
14:58:13 <scp> but I'm okay with that, I don't expect it to
14:58:28 <dmwit> Okay, so, question answered?
14:58:32 <clahey> edwardk: And why I'm going to just think Const for now.
14:58:47 <dmwit> 17:47 < scp> whi does 'foldl const undefined [1..]' hang? <- well, now you expect it to hang =)
14:59:01 <edwardk> *nods* just drawing the distinction, because the library does. Something Functor-like is a Setter, something Traversable-like is a Traversal, something Foldable-like is a Fold, something function-like is a Getter.
14:59:08 <edwardk> a Lens is simply the simplest thing that is all of those things
14:59:19 <scp> sorry, I meant "why does it eat my ram"
14:59:37 <`Jake`> I don't think it's possible, but is there a way to find the ip address of your router without connecting to another server?
14:59:51 <dmwit> scp: Oh, that part is because we're not evaluating the thunk.
15:00:06 <dmwit> scp: Try importing Data.List and using foldl' instead of foldl, and you'll see a tight, non-RAM-eating loop.
15:00:22 <dmwit> scp: (foldl is almost never preferable to foldl')
15:00:32 <clahey> All Getters are Gettings?
15:00:42 <scp> oh man
15:00:57 <scp> so, foldl is preferable when your operator is like (++)
15:01:04 <edwardk> we like programming with all of these things individually, functors, foldables, traversables and functions make up a huge percentage of haskell types. so its not surprising that a library that generalizes these things to make them easier to work with each other and which magically does the right thing when passed any one of them is well received ;)
15:01:05 <scp> so that you can get a lazy list out of the bargain?
15:01:08 <dmwit> No, foldr is preferable when your operator is lazy.
15:01:19 <dmwit> foldl' is preferable when your operator is strict.
15:01:27 <dmwit> foldl is preferable when you're committing a mistake.
15:01:45 <scp> okok
15:02:03 <clahey> edwardk: Makes sense.
15:02:13 <clahey> edwardk: Which is why I'm striving to understand it.  :)
15:02:15 <scp> ?src foldr
15:02:15 <lambdabot> foldr f z []     = z
15:02:15 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
15:02:19 <edwardk> clahey: you can instantiate any 'Getter s a' as a 'Getting a s s a a'
15:02:39 <edwardk> Getting is more liberal because you can try 'Getting' from a Fold as well
15:02:50 * dmwit -> dinner
15:02:53 <edwardk> or from a Traversal where the arguments don't match up as a Simple Traversal
15:02:58 <clahey> instantiate?
15:03:15 <edwardk> the type of Getter is rank 2
15:03:17 <Cale> scp: You can see from that, that foldr will immediately pass control to f in the recursive case
15:03:27 <Cale> (after all, it's the first thing after the = sign isn't it? :)
15:03:36 <edwardk> so you can choose the 'Gettable' 'f' you want to use at each invocation site
15:03:39 <scp> ok, but how does f possibly do anything?
15:04:03 <scp> it requires the subsequent foldr(s) to evaluate in order to perform any computation
15:04:09 <dmwit> wrong
15:04:09 <Cale> If f can just use its first argument to produce some part of its result, then the recursion might just stop there
15:04:11 <dmwit> (possibly)
15:04:14 <scp> it appears to, I mean
15:05:09 <edwardk> scp: remember in haskell we're lazy i can pass a function an _unevaluated argument_ and it won't get evaluated until you look at it
15:05:10 <Cale> f might immediately choose to produce some data constructor applied to arguments (which might involve the second parameter in some way)
15:05:14 <Jetbeard> scp:
15:05:17 <Jetbeard> > const 1 undefined
15:05:18 <lambdabot>   1
15:05:28 <edwardk> > const 12 (fix (+1))
15:05:30 <lambdabot>   12
15:05:31 <scp> ok, I know that much
15:05:34 <edwardk> > fix (+1)
15:05:38 <lambdabot>   mueval-core: Time limit exceeded
15:05:53 <edwardk> note the former terminated, but the latter spun forever.
15:06:00 <edwardk> consider foldr through that same lens
15:06:12 <edwardk> you usually care that foldr produces its answer 'productively'
15:06:14 <scp> but I really though laziness was also useful for generating lists like 'biglist n = n:biglist (n+1)'
15:06:16 <edwardk> i can foldr infinite lists
15:06:22 <Cale> scp: Evaluation is driven forward by pattern matching -- at some level, the only reason that any expression is ever evaluated is that it is the scrutinee of a case expression trying to pattern match against a constructor
15:06:27 <edwardk> > take 100 $ foldr (:) [] [1..]
15:06:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:06:35 <scp> cant I then do 'take 10 $ biglist 0'
15:06:39 <edwardk> note that didn't spin forever
15:06:41 <clahey> edwardk: Ah, so if you have a Getter, it automatically becomes a Getting for any type f?
15:06:52 <Cale> scp: and so evaluation proceeds up to the point where you have an expression which is of the form C x y z ... where C is a data constructor, and x, y, z are arbitrary expressions
15:07:21 <Cale> (or until you have an unapplied lambda, but that doesn't really come up unless seq is involved)
15:07:24 <edwardk> type Getting r a b c d = (c -> Accessor r d) -> a -> Accessor r b
15:07:42 <edwardk> type Getter a c = Gettable f => (c -> f c) -> a -> f a
15:07:45 <Cale> scp: you sure can
15:07:58 <edwardk> choose f = Accessor r.
15:08:02 <scp> ?src foldl
15:08:02 <lambdabot> foldl f z []     = z
15:08:02 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:08:12 <shachaf> rwbarton: I'm writing what, an introduction to lens?
15:08:15 <Cale> > let biglist n = n : biglist (n+1) in take 10 $ biglist 0
15:08:17 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
15:08:17 <clahey> edwardk: Right.
15:08:18 <edwardk> instance Gettable (Accessor r) where coerce (Accessor r) = Accessor r
15:08:20 <Jetbeard> > let const x y = x in const 1 undefined
15:08:22 <lambdabot>   1
15:08:22 <shachaf> rwbarton: Looks that edwardk is doing that right now, in-channel!
15:08:32 <Jetbeard> <Cale> scp: at some level, the only reason that any expression is ever evaluated is that it is the scrutinee of a case expression trying to pattern match against a constructor
15:08:32 <shachaf> s/that/like/
15:08:41 <edwardk> i've done better intros to lenses than this ;)
15:08:43 <scp> ok, I think this may be coming to light
15:08:54 <Cale> scp: Now you can see from the definition of foldl that foldl just passes control to itself over and over until it hits the end of the list
15:08:56 <scp> that thing you said about 'first thing after the equals sign' was serious?
15:09:06 <clahey> edwardk: I see how the types are related there.  I'm just trying to understand what that means for usage.
15:09:06 <Cale> giving f no opportunity to produce any part of a result
15:09:18 <Cale> scp: yes, well, not in the presence of infix operators :)
15:09:32 <Cale> scp: But lazy evaluation is outermost-first
15:09:35 <clahey> It means if you write a function that takes a Getting, then you can pass it a Getter.
15:09:41 <edwardk> clahey: it means that combinators that _consume_ a Getting will do the right thing when passed a Getter or a Fold
15:09:41 <clahey> But you can also pass it a Lens.
15:09:48 <scp> ok, just a second here
15:10:14 <edwardk> it'll pick up a Monoidal obligation on the r in Getting r a b c d if its a Fold, but not if its a Getter
15:10:28 <clahey> edwardk: Gotcha.
15:10:31 <scp> hmm, this requires a little thinking
15:10:37 <scp> thanks a lot Cale
15:10:40 <edwardk> [Sum 1, Sum 2, Sum 3]^.traverse    magically gives back Sum 6
15:10:43 <shachaf> When you first see "view" folding things out of nowhere that's a bit surprising.
15:10:43 <Cale> scp: no problem :)
15:10:45 <scp> basically, that's the method to the compiler's madness
15:10:58 <Cale> scp: Now, GHC doesn't *just* do lazy evaluation
15:11:05 <Cale> scp: but it's a better model than anything else
15:11:32 <edwardk> i'm going to vanish into an airplane in a few minutes though
15:11:33 <Cale> scp: GHC will actually prove that it's okay to do strict (innermost first) evaluation sometimes, and do that instead where it's better.
15:11:39 <edwardk> so be forewarned ;)
15:11:53 <Cale> scp: But *most* of the time you can expect things to generally perform similarly to lazy evaluation.
15:11:59 <Cale> (or better)
15:12:21 <scp> ?src foldl'
15:12:22 <lambdabot> foldl' f a []     = a
15:12:22 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:12:35 <scp> and that's why seq exists
15:12:41 <Cale> and certainly, if you don't turn optimisations on, you'll basically get lazy evaluation everywhere
15:13:01 <edwardk> and of course it'd be perfectly valid for a 'parallel haskell' implementation to choose to spawn threads for calculations rather than evaluate them lazily, etc. so long as the non-strict semantics are preserved
15:13:28 <Cale> (but that isn't done, because it's hard to do it well)
15:13:38 <scp> This is all pretty cool
15:14:09 <Cale> Once you start thinking of evaluation in terms of rewriting expressions at runtime
15:14:23 <Cale> Everything starts gradually becoming more familiar
15:14:25 <scp> I spend a _lot_ of my time on writing compilers for imperative languages
15:14:26 <clahey> edwardk: If l ^$ s = view l s, why not define it that way instead of redefining it?
15:14:32 <scp> so this is a whole new way of thinking of things
15:14:33 <Cale> It still takes quite a long time to get used to
15:14:35 <Cale> yeah
15:14:40 <edwardk> clahey: less dependence on the inliner
15:14:51 <Cale> Basically all your intuition about what performs well is gone
15:14:56 <edwardk> and it means the reader of the code isn't running all over trying to figure out what crap means
15:14:59 <Cale> and you have to form new intuitions :)
15:15:06 <clahey> edwardk: Speeding up compilation by a minute amount, right?
15:15:14 <clahey> edwardk: I find that it's making it harder to read for me.
15:15:25 <Cale> but it is possible, contrary to what some people would have you believe :)
15:15:26 <clahey> edwardk: Especially since the definitions aren't identical.
15:15:26 <shachaf> clahey: Presumably speeding-up-compiled-code, if anything.
15:15:50 <clahey> shachaf: I would have thought inlining would make that identical?
15:16:04 <edwardk> clahey: its more about the fact that the definition is trivially short, and making the user go run around in a 1000 line file looking for the other version of it is a bit of a dick move ;)
15:16:18 <edwardk> clahey: only if inlining happens
15:16:32 <edwardk> if i chain too many inline requests eventually it may not happen =P
15:16:33 <acowley> How can I convince GHC I have an injective type function?
15:16:38 <clahey> edwardk: I agree that we're both arguing for it being more readable, but your idea of readable is different than mine in this case.  :)
15:16:43 <scp> So, if the function doesn't "short circuit" when given the first argument
15:16:46 <scp> then foldr is bad
15:16:47 <edwardk> yes, but i wrote the library. ;)
15:16:49 <scp> even if things are lazy
15:16:51 <edwardk> on that note. i have to go
15:16:55 <clahey> edwardk: Of course.
15:17:02 <shachaf> clahey: The definitions look complicated until you get used to them.
15:17:18 <clahey> shachaf: Idea.  What about combining the definitions and only having one comment block?
15:17:46 <Saizan> acowley: currently i think you need to make it a data family instead
15:17:46 <clahey> shachaf: I don't mean making the definitions dependent on one another.  I just mean moving definitions that are dependent on one another closer together.
15:17:52 <Cale> scp: well, in a sense...
15:17:55 <shachaf> clahey: It's not a big deal unless you're modifying the library.
15:18:04 <shachaf> I mean, the documentation for ^. says -- This is the same operation as 'view' with the arguments flipped.
15:18:07 <Cale> scp: (:) for example, needs to be considered to "short circuit" for that to be true :)
15:18:20 <clahey> shachaf: The other thing I noticed was in the definitions of += and ~= that there's not much consistency in ordering of which functions are in which order.
15:18:31 <scp> Cale: so like...
15:18:31 <shachaf> clahey: Having just spent recently modifying about a thousand lines of the library, I don't mind it. :-)
15:18:33 <Cale> scp: after all, foldr (:) [] works fine :)
15:18:39 <clahey> shachaf: Fair enough.
15:18:54 <Cale> and you can tweak that into lots of other things which work well:
15:18:58 <clahey> shachaf: Since there's no real tutorial, I'm learning the deeps of it by reading the code, so these are just my comments as a reader of the code.
15:19:01 <shachaf> clahey: (To be fair, I was modifying the types.)
15:19:02 <Cale> foldr ((:) . f) [] = map
15:19:05 <scp> wait, isn't (:) a special case
15:19:26 <shachaf> clahey: edwardk welcomes patches, if you have one which you think will improve the code. :-)
15:19:31 <scp> or is it possible for me to make a "lazy tree" or other data constructor?
15:19:32 * hackagebot simple 0.2.0 - A minimalist web framework for the WAI server interface  http://hackage.haskell.org/package/simple-0.2.0 (AmitLevy)
15:19:37 <Cale> foldr (\x xs -> if p x then x:xs else xs) [] = filter p
15:19:48 <Cale> yep, or you can make trees
15:19:51 <shachaf> clahey: rwbarton claims that I'm going to write something, but you can't trust rwbarton.
15:19:59 <shachaf> Cale: Now write dropWhile with foldr. :-(
15:20:23 <Cale> foldr (\x xs -> Branch x Leaf xs) Tip
15:20:29 <clahey> shachaf: Naw, I'm just complaining.  Too lazy to do anything else.
15:20:40 <clahey> shachaf: And also concerned about copyright if I do change the code.
15:20:41 <shachaf> clahey: What's your intuition for lenses right now? Maybe I can help by describing my intuition for them, if it's different. :-)
15:21:02 <clahey> shachaf: My intuition is that they're a way to access parts of an object, both for reading and for writing.
15:21:13 <clahey> shachaf: But right now, I'm just working on my intuition for Getting.
15:21:20 <hpaste> acowley pasted “phoas phury” at http://hpaste.org/77022
15:21:29 <shachaf> clahey: I think Traversal is the central concept of the library.
15:21:33 <acowley> Somebody please shove me back onto the right track!
15:21:36 <shachaf> clahey: Do you know the function mapM?
15:21:37 <shachaf> @ty mapM
15:21:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:21:47 <clahey> shachaf: I have in fact used it.
15:21:50 <acowley> The paper I'm referencing is http://www.iro.umontreal.ca/~monnier/tct.pdf
15:21:55 <shachaf> clahey: A lens is just a generalized mapM
15:22:02 <Cale> scp: anything which immediately produces a constructor -> foldr is good
15:22:18 <shachaf> (Well, a traversal. But whatever.)
15:22:25 <scp> Cale: and if xs was an infinite list, I could evaluate that tree lazily?
15:22:31 <scp> and not crash
15:22:31 <Cale> yep
15:22:38 <scp> ok, that's cool
15:22:42 <clahey> shachaf: I don't think this is gonna help.  I think I have to understand it in pieces.
15:22:43 <Cale> foldr (\x xs -> Branch x Leaf xs) Tip [0..]
15:22:57 <shachaf> clahey: Let's say you have a list. If you just want to modify every element of it, you can just mapM with a boring function:
15:23:00 <Cale> = (\x xs -> Branch x Leaf xs) 0 (foldr (\x xs -> Branch x Leaf xs) Tip [1..])
15:23:12 <shachaf> mapM (\x -> return (x + 1)) [1,2,3]
15:23:12 <Cale> = Branch 0 Leaf (foldr (\x xs -> Branch x Leaf xs) Tip [1..])
15:23:14 <clahey> Why are monads involved?
15:23:24 <shachaf> clahey: It's actually Applicative, not Monad.
15:23:25 <scp> alas, I've been at work for an hour too long.
15:23:30 <Cale> and now if you have a case expression matching on this, it will match Branch x l r
15:23:34 <shachaf> clahey: OK, let's start a bit earlier, with fmap. You know fmap?
15:23:41 <scp> Cale: thanks a ton, you have expanded my mind =P
15:23:46 <Cale> and set x = 0, l = Leaf, r = (foldr (\x xs -> Branch x Leaf xs) Tip [1..])
15:23:48 <clahey> shachaf: I know fmap, I know monads, I know <*>.
15:23:55 <Cale> and only if you case on r will it continue the foldr
15:23:59 <scp> I see, so in haskell
15:24:06 <scp> a case is like an "evaluation primitive"
15:24:09 <Cale> yes
15:24:12 <shachaf> clahey: OK. fmap :: (a -> b) -> f a -> f b, right?
15:24:14 <Cale> and we don't have a call stack in GHC
15:24:16 <clahey> shachaf: I know Applicative.
15:24:20 <Cale> we have a stack of case expressions
15:24:22 <shachaf> So fmap (+1) [1,2,3] = [4,5,6]
15:24:29 <clahey> shachaf: Yeah, I know fmap.
15:24:30 <Cale> waiting for their scrutinee to be evaluated enough to pattern match
15:24:32 * hackagebot wai-lite 0.2.0.0 - DEPCRECATED (use package "simple" instead) A minimalist web framework for WAI web applications  http://hackage.haskell.org/package/wai-lite-0.2.0.0 (AmitLevy)
15:24:39 <Cale> So if you ever get a stack overflow, remember that :)
15:24:43 <shachaf> clahey: Maybe we should go into #haskell-overflow. :-)
15:24:44 <scp> ok
15:24:44 <scp> so
15:24:46 <scp> case expr of
15:24:50 <scp> expr is being evaluated
15:24:55 <Cale> yes
15:24:55 <scp> that's the next stack frame
15:25:01 <scp> neato
15:25:50 <Cale> This is why you'll see people hem and haw whenever someone brings up the matter of TCO
15:26:06 <Cale> because it's like, what does TCO even mean when you don't have a call stack
15:26:16 <nand`> my intuition for lenses is that they focus from some larger structure onto some parts of it
15:26:38 <acowley> "simple" is a package that does something for WAI servers?
15:26:55 <acowley> I'm thinking the name would be vastly improved by adding a "-wai" suffix
15:27:26 <Cale> But if you write functions which force the evaluation of their parameters before recursing, and are tail recursive, then you'll get good behaviour.
15:27:50 <Cale> In a similar way as you would in a strict language implementation
15:27:51 <elliott> acowley: eventually we will get package names like "thing"
15:28:06 <acowley> and it will something ultra-specialized that has 1.2 users
15:28:07 <Cale> seq x y is basically like using case to match on x before resulting in y unconditionally
15:28:10 <elliott> I am shocked nobody took "lens" before edwardk actually
15:28:25 <shachaf> elliott: Well, he wanted "lenses", but that was taken.
15:28:29 <acowley> lens library: A package for tracking the prescription of your eye glasses
15:29:04 <acowley> I think "lens" is a heck of a lot better than "simple" for what the two things are
15:29:20 <Cale> lens: computational optics via quantum electrodynamics
15:29:45 <acowley> Good package names are invaluable. For instance, anyone looking for it would instantly find http://hackage.haskell.org/package/acme-colosson
15:29:45 <scp> Cale: I need to drive a hundred miles, and must leave #haskell begrudgingly. Thanks again =P
15:31:06 <acowley> I wish I made more frequent use of http://hackage.haskell.org/packages/archive/acme-dont/1.1/doc/html/Acme-Dont.html
15:31:31 <c_wraith> I don't see why you don't
15:32:05 <otterdam> Who needs comments? I don't
15:33:16 <scooty-puff> i think that package has more documentation than most of mine..
15:35:32 <acowley> Has anyone looked at my phoas hpaste of misery?
15:42:06 <acowley> The paper doesn't come with source code, so I suppose it's possible that the given presentation never actually worked
15:43:33 <Saizan> link?
15:43:50 <Saizan> i found some Coq's phoas code once
15:45:09 <Saizan> http://code.haskell.org/~Saizan/SystemFpred.agda <- and i got that far in agda
15:45:31 <acowley> Saizan: The paper is this one http://www.iro.umontreal.ca/~monnier/tct.pdf
15:46:02 <acowley> Saizan: All the existentials are causing trouble
15:46:27 <pmade> Would someone please point me to a tutorial/explanation of what it means to "run inside the IO Monad".  I don't understand how functions that return state wrapped in an IO work, or how ghci evaluates what you type inside the IO Monad.
15:48:42 <Rotaerk> pmade, think of an IO as a *value* that *describes* an IO operation... you can have a function that returns such a description, but you don't have any way of executing it
15:48:50 <Saizan> acowley: EFun would be more useful as a record type with two polymorphic components
15:48:55 <applicative> pmade: when you are inside ghci you are 'inside the IO monad" if that means anything
15:49:02 <Rotaerk> pmade, you can create new IO values by chaining them with other IO values...
15:49:27 <Rotaerk> and thus a program can be thought of as one massive chain of IO operations, bundled into one value describing it...
15:49:35 <acowley> Saizan: Yes, I just tried switching to a pair of EFuns with newtype EFun a b = EFun {forall t. a t -> b t}
15:49:40 <applicative> pmade: when you ask it to evaluate the 'pure' expression  2 + 3, really you are demanding the action print (2+3)
15:49:41 <Rotaerk> create such a value and call it "main", and that's what becomes the entry point
15:50:18 <acowley> But I think this is genuinely hopeless
15:50:47 <pmade> Rotaerk: maybe the problem I'm having is with nomenclature.  I don't quite get what it means to be "in a Monad" vs calling a function that must return a Monad.  Like foo :: (Monad m) => m.  Is foo in m, or returning m?
15:50:50 <acowley> We want pattern matching on the Lam constructor to unify (r (t1 -> t2)) with a t
15:51:12 <acowley> but GHC doesn't just skip ahead and say that, okay, a ~ r and t ~ (t1 -> t2)
15:51:20 <Saizan> acowley: also, you want to make 'r' a parameter of ExpF
15:51:33 <acowley> Saizan: Yes, that makes things type check
15:51:36 <applicative> pmade: 'in a monad' is pretty misleading jargon, but it could be explained
15:51:44 <acowley> Saizan: But it seems a pretty serious deviation from the presentation in the paper
15:51:52 <applicative> pmade, LIST is a monad, so anything of the form [a] is 'in' that monad
15:51:59 <pmade> applicative: Where's a good place to go ready about this?
15:52:13 <pmade> s/ready/read/
15:52:29 <applicative> pmade, MAYBE is a monad, so Just 17 is in the monad, the Maybe monad
15:52:41 <pmade> applicative: in my mind I see [a] and I think `a' is inside the list monad.  Is that right?
15:53:01 <applicative> pmade: Learn you a haskell?  I'm not sure what the sticking point is for you...
15:53:23 <pmade> applicative: I've read that twice now, but I feel like it doesn't go deep enough.
15:53:28 <Nereid> there won't be any one thing you read that'll make monads make sense for you :v
15:53:41 <Saizan> acowley: is the paper abstracting the recursion out like you're doing here?
15:53:57 <applicative> pmade: yea it doesn't go too far, but I'm not sure what you are finding mysterious, not that it isn't a little difficult in some ways
15:54:04 <acowley> Saizan: You mean the Rec stuff?
15:54:10 <Saizan> acowley: yeah
15:54:12 <acowley> Saizan: Yes, that's from the paper
15:54:28 <applicative> pmade: of course the 'typeclassopedia'  I take it youve seen
15:54:33 * hackagebot simple-config 1.2.2 - Simple config file parser generator  http://hackage.haskell.org/package/simple-config-1.2.2 (YusukeNomura)
15:54:38 <Rotaerk> pmade, say you monad M, and a value of type M t... monads aren't required (but are allowed) to provide access to the t value "inside" the M t
15:54:39 <Nereid> I think you just have to see it from a bunch of different viewpoints and then play with them yourself and then at some point you'll figure them out.
15:54:44 <Rotaerk> you have a monad *
15:55:00 <pmade> I *think* I understand monads, but I get lost when I see function type signatures that don't seem to mention the monad but in their bodies I see stuff like liftM and I don't know which monad it's working with.  Maybe due to currying?
15:55:18 <Nereid> liftM = fmap
15:55:22 <Saizan> acowley: ok, i guess i've to read that first, i'm used to a different presentation
15:55:23 <merijn> pmade: The trick is that those functions work with every monad
15:55:27 <pmade> I've not seen typeclassopedia, what's that?
15:55:30 <merijn> pmade: Let's do a simpler example
15:55:50 <Rotaerk> pmade, the t can only be accessed when passing it to a function of type t -> M u, via bind
15:55:59 <Rotaerk> so you could think of the t as being trapped within the context of the monad
15:55:59 <acowley> Saizan: I just came upon this one searching for recent Haskell treatments of PHOAS, and it looked nice enough but it's really not panning out at all
15:56:05 <merijn> pmade: I assume you're familiar with the Eq typeclass? i.e. the one providing "(==) :: Eq a => a -> a -> Bool"?
15:56:08 <Rotaerk> which I think is why it's said to be "in" the monad
15:56:22 <pmade> Rotaerk: yes, that makes sense to me.
15:56:25 <pmade> merijn: Yes, I am.
15:56:27 <applicative> pmade: if the monad is Maybe, why shouldn't I have a function 'Int -> Int' that goes by way of a function to Maybe Char, then liftM's something over that, and so on
15:56:40 <applicative> > liftM (+1) [1..10]
15:56:41 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
15:56:53 <merijn> pmade: Now, clearly GHC is selecting which actual implementation to use based on the type of "a", right?
15:56:55 <Nereid> > liftM (+1) (Just 3)
15:56:56 <applicative> ^^^ here is liftM in the [] monad
15:56:56 <lambdabot>   Just 4
15:57:15 <pmade> merijn: yes.
15:57:44 <applicative> pmade: if the liftM is being used for IO somewhere in the middle there will be trouble getting a pure function Int -> Int out
15:57:56 <applicative> there could be trivial cases
15:58:54 <pmade> Honestly, I think possibility that `do' notation confuses me the most because I don't *see* the monad entering the chain like I do with >>= and >>
15:59:09 <ivanm> KBme: did you end up getting ConfigFile installed?
15:59:11 <merijn> pmade: If I write a function like "elem :: Eq a => a -> [a] -> Bool" which should be something like "elem v (x:xs) = if v == x then True else elem v xs", i.e. we compare the entire list element by element. Now how does it know which Eq the type signature for elem refers to?
15:59:28 <Rotaerk> call me Maybe
15:59:35 <ivanm> merijn: returning True like that is a code smell! :p
15:59:53 <merijn> pmade: By seeing where (==) is used and looking at the types it is used with. The same goes for something "liftM"
16:00:03 <merijn> ivanm: I thought using any might obscure the point
16:00:03 <pmade> merijn: no, I can see there where the compiler would pick the correct implantation based on the type of `a'
16:00:08 <merijn> :t liftM
16:00:09 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:00:28 <ivanm> merijn: = (v == x) || elem vs xs ? ;-)
16:00:44 <pmade> merijn: Thank you.  I think for me the point is I need to find out where these functions are being applied and with what data, and then in that instance I can know which monad is being used.
16:00:50 <merijn> pmade: If I have "liftM f x = x >>= return . f"
16:01:05 <applicative> > let l n = length $ liftM (liftM (const 3)  (map putChar) ['a'..'c']
16:01:06 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
16:01:15 <applicative> no didn't finish
16:01:28 <merijn> pmade: Then GHC can determine which monad it is by inspecting to the type of x (because >>= is applied to it) and then select >>= and return based on that
16:01:57 <pmade> merijn: that makes sense.
16:02:05 <merijn> pmade: Correct, you can see this in action when you try to run "return 3" without any context, for example
16:02:14 <merijn> > return 3 -- GHC can't tell which monad this is
16:02:15 <lambdabot>   No instance for (GHC.Show.Show (m t))
16:02:15 <lambdabot>    arising from a use of `M4438977989...
16:02:30 <merijn> > return 3 :: [Int] -- This is fine
16:02:31 <lambdabot>   [3]
16:02:45 <merijn> > return 3 :: Maybe Int -- So is this
16:02:47 <lambdabot>   Just 3
16:03:02 <ivanm> @type return 3
16:03:03 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
16:03:09 <ivanm> ^^ currently _any_ monad
16:03:16 <merijn> > return 3 :: Either String Int -- or even this
16:03:17 <lambdabot>   Right 3
16:03:30 <pmade> I see.
16:03:51 <pmade> Thank you everyone for being so helpful.
16:03:55 <merijn> pmade: btw, if you have trouble seeing how do notation works in terms of >>= and return you can privmsg lambdabot with @undo
16:04:13 <merijn> @undo do {x <- foo; bar x; baz }
16:04:13 <lambdabot> foo >>= \ x -> bar x >> baz
16:04:15 <pmade> merijn: fantastic, I'll do that, thank you.
16:04:25 <pmade> That's great!
16:04:58 <Saizan> acowley: tbf, i thought we could derive a ~ b and f ~ g from f a ~ g b
16:05:04 <merijn> Basically, "x <- foo" will just introduce an extra lambda function for the entire do body and pass x in as input argument
16:05:17 <merijn> To take the above example it'd become
16:05:46 <merijn> "foo >>= \x -> do { bar x ; baz }", and then the rest of the do block gets recursively desugared
16:06:10 <elliott> Saizan: only if you don't allow f and g to be type families
16:06:25 <elliott> er... also you have to require f and g don't ignore their argument
16:06:47 <pmade> merijn: Thank you.
16:07:05 <merijn> pmade: Personally I think it's very helpful to skip do-notation until you have an "aha!" moment while using >>= and >>
16:07:08 <acowley> Saizan: type family F a :: *; type instance F Int = Int; type instance F Char = Bool; type family G a :: *; type instance G Int = Int; type instance G Char = Float
16:07:23 <acowley> F Int ~ G Int, but F and G are not ~
16:07:35 <merijn> Anyhoo, time for bed!
16:07:41 <dmwit> > [()..]
16:07:42 <acowley> and of course it can be made much more perverse
16:07:42 <lambdabot>   [()]
16:07:48 <pmade> merijn: Exactly.  I need to stop reading and start writing more code.
16:08:15 <ivanm> merijn: as in "aha! using >>= and >> all the type is a right royal PITA!"? :p
16:10:44 <Saizan> acowley: but a type variable can't be instantiated to a type family
16:10:58 <acowley> Saizan: true!
16:11:48 <deech> Hi all, has there been any research done on IDE's for statically typed purely functional PL's? AFAIT Agda is leading the way here.
16:12:30 <hpaste> Saizan annotated “phoas phury” with “phoas phury (annotation)” at http://hpaste.org/77022#a77023
16:12:42 <Saizan> acowley: in fact it's provable ^^^
16:13:24 <hpaste> acowley annotated “phoas phury” with “phoas phury (annotation)” at http://hpaste.org/77022#a77024
16:13:41 <acowley> Saizan: So what's happening when that paste fails to type check?
16:13:42 * applicative isn't sure Agda's emacs machinery counts as research, even into IDE's
16:14:27 <applicative> deech have you noticed this pleasantly mad plan https://github.com/Peaker/bottle
16:14:33 * hackagebot java-character 0.0.4 - Functions to simulate Java's Character class.  http://hackage.haskell.org/package/java-character-0.0.4 (TonyMorris)
16:14:38 <Saizan> acowley: i'm wondering too, maybe ghc got more timid about solving these constraints at some point?
16:14:54 <acowley> applicative: I think it kind of does. The idea of holes presenting a prompt with all available type information is really powerful.
16:14:58 <Saizan> acowley: which version are you testing on?
16:15:01 <acowley> Saizan: 7.6.1
16:15:19 <Saizan> acowley: i'm on 7.4.1 and it's the same
16:15:35 <applicative> acowley: hm, ok I take it back.
16:15:41 <deech> applicative: No sir! I haven't. Do you have a screencast or talk out there?
16:15:50 <pmade> So, when someone says "f runs inside the m monad" can I translate that to "the correct implantation for f will be selected automatically based on m"?
16:15:55 <dmwit> Saizan: Wait, you can't conclude f ~ g from f a ~ g b?
16:16:24 <applicative> deech some things are mentioned on the github site; Peaker is on here from time to time
16:16:42 <dmwit> huh, I guess not
16:16:46 <dmwit> I'm very surprised.
16:17:31 <deech> applicative: Doesn't depend on GTK. Yay!
16:17:54 <Saizan> dmwit: you can but not directly
16:18:10 <Saizan> acowley: i think the problem is considering r a rigid variable there, for example
16:18:11 <applicative> deech: I managed to build it some time ago on OSX so it can't be too horrible.
16:18:12 <Nereid> pmade: there's a difference between ... -> M a, for a fixed monad m, and forall m. Monad m => ... -> m a, which is polymorphic in m
16:18:17 <dmwit> pmade: I would think you need more context to conclude that.
16:18:17 <Nereid> fixed monad M*
16:18:24 <dibblego> bos: I just noticed you are writing a DIET — I did so too just a few hours ago
16:18:29 <dibblego> @tell bos I just noticed you are writing a DIET — I did so too just a few hours ago
16:18:29 <lambdabot> Consider it noted.
16:18:41 <acowley> Saizan: How can I make it otherwise?
16:18:45 <pmade> Okay, sound like I need to do some more digging ;)
16:18:51 <dibblego> @tell bos http://hackage.haskell.org/package/diet
16:18:51 <lambdabot> Consider it noted.
16:19:09 <acowley> and now I'm really perplexed about this f a ~ g b ==> f ~ g /\ a ~ b thing
16:19:23 <ivanm> dibblego: re-implementation? or packaging of Irwin's work?
16:19:32 <Nereid> pmade: things like (>>=) and liftM and such work on any monad, so they must be defined in terms of the monad operations (and basic functions)
16:19:36 <acowley> I thought ~ was more or less syntactic equivalence in today's GHC?
16:19:51 <Saizan> acowley: i don't think we can
16:20:02 <Nereid> what are f and g?
16:20:26 <dibblego> ivanm: I just went from Erwig's paper, which is in ML
16:20:27 <Saizan> yeah source-level ~ should be syntactic, modulo reduction of type families
16:20:34 <Saizan> Nereid: type variables
16:20:35 <Nereid> I guess they have to be type constructors.
16:20:41 <acowley> Nereid: right
16:21:03 <thoughtpolice> dibblego: he actually has a basic, reference haskell implementation (it's not mentioned in the paper, but it's on the page -for- the paper)
16:21:25 <thoughtpolice> but it's basically what you would expect
16:21:27 <acowley> Saizan: So the ~ provided by the type checker is treated differently?
16:21:29 <dibblego> yeah I saw that, I only skimmed it
16:21:44 <acowley> Saizan: i.e. equivalences that arise during unification are treated differently?
16:21:59 <Nereid> I mean, as opposed to type synonyms or type families or something.
16:22:35 <acowley> Nereid: Since we can't pass a family by name, and we can't pass unsaturated type synonyms, I think it *has* to be a type constructor
16:22:41 <Nereid> exactly.
16:22:56 <Saizan> acowley: they aren't i think, but newtypes introduce extra axioms so the status of ~ is a bit dodgy atm, they have plan to sort this out though
16:23:25 <acowley> Saizan: Should I complain in an official way somehow or just take my ball and go home?
16:23:26 <dmwit> oh ho
16:23:43 <acowley> palindromic exclamation!
16:23:46 <Nereid> so it sounds like if f a ~ g a then f ~ g.
16:23:53 <Nereid> even if we can't prove it in haskell.
16:24:04 <Saizan> acowley: i think the former
16:24:14 <dmwit> Here's the rule I was thinking of: \Gamma |- \gamma : (K1 => t1) ~ (K2 => t2) ==> \Gamma |- left \gamma : K1 ~ K2
16:24:16 <Saizan> acowley: it's either a bug or a fairly obscure corner case
16:24:16 <acowley> Maybe if I can get enough signatures I can present the type checker with a petition
16:24:24 <dmwit> So it only applies to (->) equalities.
16:24:45 <acowley> Saizan: Do you think the annotated paste is boiled down enough?
16:25:23 <Saizan> acowley: maybe it's simpler to ask why inversion Refl = (Refl , Refl) doesn't typecheck
16:25:28 <dmwit> oh no
16:25:41 <acowley> Saizan: Yeah, okay, I just noticed that code in the paste
16:25:45 <dmwit> That's the rule for leftc, the rule for left looks like it should apply here:
16:26:18 <dmwit> \Gamma |- \gamma : s1 s2 ~ t1 t2 ==> \Gamma |- left \gamma : s1 ~ t1
16:26:23 <dmwit> (and similarly for right)
16:26:46 <acowley> dmwit: that suggests this is a legitimate bug, then
16:26:49 <dmwit> From the figure on page 5 of "System F with type equality coercions".
16:27:06 <Saizan> acowley: as written it needs {-# LANGUAGE GADTs, TypeOperators, KindSignatures, PolyKinds, TypeFamilies #-}
16:27:20 <dmwit> If so, it's a pretty egregious one, since foo :: f a ~ g b => f () -> g (); foo x = x throws an error, too.
16:28:27 <acowley> Saizan: and RankNTypes
16:29:09 <Saizan> acowley: ah, yeah, for the forall
16:30:02 <acowley> Geese, I wasted too much time on this
16:32:03 <acowley> I appreciate your help Saizan and dmwit, I was going crazy trying to make that work
16:33:53 <Saizan> acowley: np, link back the post or ticket when you make one :)
16:35:35 <acowley> Saizan: http://hackage.haskell.org/trac/ghc/ticket/7377
16:37:48 <dmwit> Wow, wait, throwing in the type families makes it work?
16:37:49 <dmwit> haha
16:39:11 <dmwit> No... that doesn't work here.
16:39:34 <acowley> The code in the ticket doesn't type check for you?
16:39:49 <dmwit> I'm so confused.
16:40:10 <Saizan> i've checked it on 7.4.1
16:40:18 <acowley> I checked it on 7.6.1
16:40:26 <dmwit> Oh, I didn't alpha-vary it sufficiently vigorously.
16:41:10 <acowley> I'm actually really impressed with that TF hack. It's all Saizan.
16:41:23 <dmwit> So, it also fails if you give congArg the type annotation congArg :: f x :=: g y -> Arg (f x) :=: Arg (g y). =)
16:41:31 <Saizan> it's easier when you think in Agda :)
16:41:47 <acowley> I need to stop thinking in PHP
16:42:02 <Saizan> yeah, you bump into the same problem there
16:42:06 <djahandarie> You do need to stop thinking in PHP.
16:42:42 <acowley> But I like SQL injection attacks in my higher kinded meta programming!
16:42:48 <djahandarie> x :: <?php echo 'Refl'; ?>
16:42:52 <acowley> hahaha
16:43:01 <Saizan> (well, in Agda you couldn't write those families on types directly, you'd have to build a syntax for them explicitly)
16:43:14 <typoclass> > x :: <?php echo 'Refl'; ?>
16:43:15 <lambdabot>   <no location info>: parse error on input `<?'
16:45:18 <Saizan> btw, anyone knows what's the right syntax for type family Func (x :: k) :: k -> k ?
16:45:56 <Saizan> it says parse error on input k
16:46:20 <acowley> you need spaces
16:46:57 <Saizan> around what?
16:47:00 <acowley> actually never mind, that parsed fine for me
16:47:20 <acowley> With kind signatures involving *, a lack of spaces leads to ::* being treated as a single token
16:47:21 <Saizan> ah, i should upgrade to 7.6.1
16:47:51 <acowley> I keep typing ::*, so that answer was already on the tip of my tongue :)
16:48:19 <Saizan> :)
16:48:27 <dmwit> Who else thinks PolyKinds should automatically enable KindSignatures?
16:49:05 <acowley> I'm more bothered by the Constraint kind not being imported when ConstraintKinds is in effect
16:49:44 <dmwit> Oh, PolyKinds does imply KindSignatures.
16:49:46 <acowley> That whole area of the language needs polish, but I figured the polish was coming post 7.6 since that's when things started working
16:54:49 <acowley> Well, my brain has shut down. Why can't I define a class for types of a particular kind?
16:55:16 * Saizan can't help there
16:55:32 <acowley> What language is it that I apparently want to be programming in?
16:56:22 <Saizan> so e.g. class C (a :: * -> *) doesn't work?
16:56:38 <acowley> I wanted class C (a::T) where
16:56:56 <sinelaw> Peaker, yo
16:57:09 <Peaker> sinelaw, yo yo.. how are you surviving?
16:57:34 <sinelaw> all good, i have power & internet
16:57:41 <sinelaw> bread and water of the 21st century
16:58:04 <Peaker> cool, the news had  me thinking you are swimming in your house
16:58:18 <Saizan> acowley: seems to work here with DataKinds
16:58:52 <sinelaw> Peaker, yeah I saw that stuff in the news...fortunately  not in my area
16:59:26 <acowley> Saizan: I wanted to write class C (a::T) where foo :: a -> Int
16:59:50 <Saizan> acowley: you need a to be of kind * to use it like that
17:00:09 <acowley> That's what the type checker keeps telling me
17:00:20 <Saizan> acowley: maybe you want foo :: Proxy a -> Int, given data Proxy a = Proxy
17:00:27 <acowley> Yeah, probably
17:00:31 <acowley> In fact, yes.
17:00:36 <Saizan> or even just foo :: forall f. f a -> Int
17:00:42 <acowley> I've done that in several places and just plumb forgot
17:02:00 <acowley> the forall makes it hard to recurse
17:05:17 <cofox> is it possible to have a data type that can hold any type from class Num?
17:05:28 <dolio> Yes.
17:05:35 <startling> cofox, yes, but you probably don't want it
17:05:37 <mauke> sadly
17:06:10 <startling> especially because most of Num's functions are binary, and you can't add arbitrary Nums together.
17:07:07 <dolio> You can do all kinds of cool stuff.
17:07:07 <cofox> startling: ok, so how could i declare a type that can hold only Integer/Double but still have Nums functions?
17:07:18 <dolio> Like multiply the stored number by itself, and add the result to itself.
17:07:25 <dolio> And then subtract 5.
17:07:31 <startling> dolio, fair enough.
17:07:42 <startling> cofox, uhhh sort of
17:08:02 <startling> cofox: you can do data Mynum = MyInteger Integer | MyDouble Double
17:08:08 <startling> and then write a Num instance for that.
17:24:39 <cofox> how do i write my own instance of Num for a data type I've defined?
17:25:58 <nand`> I would guess by exploiting the fact that fromInteger can be used as a pseudo-injection into Double
17:26:10 <mauke> as usual
17:27:34 <Nereid> cofox: instance Num Mynum where ...
17:27:48 <Jetbeard> cofox, the functions you need to implement: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num
17:27:50 <Nereid> and then you implement all those Num methods.
17:30:03 <gwern> instance Nom Mynom where cat = cycle "nyan"
17:30:27 <mauke> did you mean: cycle "nya"
17:30:41 <Nereid> > cycle "nya"
17:30:42 <lambdabot>   "nyanyanyanyanyanyanyanyanyanyanyanyanyanyanyanyanyanyanyanyanyanyanyanyany...
17:30:50 <gwern> mauke: no one's perfecct
17:31:11 <Nereid> @src cycle
17:31:11 <lambdabot> cycle [] = undefined
17:31:11 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
17:32:08 <ion> > let f 'n' = "ya"; f 'y' = "ny"; f 'a' = "n" in fix (('n':) . (=<< f))
17:32:09 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
17:32:09 <lambdabot>         against inferred ty...
17:32:40 <ion> > let f 'n' = "ya"; f 'y' = "ny"; f 'a' = "n" in fix (('n':) . (f =<<))
17:32:42 <lambdabot>   "nyanynyanyyanynyanynynyanyyanynyanyyanyyanynyanynynyanyyanynyanynynyanynyn...
17:32:57 <Nereid> lol
17:34:23 <mauke> > let f 'A' = "CAT"; f c = [c] in iterate (concatMap f) "A"
17:34:24 <lambdabot>   ["A","CAT","CCATT","CCCATTT","CCCCATTTT","CCCCCATTTTT","CCCCCCATTTTTT","CCC...
17:34:36 <mauke> > let f 'A' = "CAT"; f c = [c] in iterate (concatMap f) "A CAT"
17:34:37 <lambdabot>   ["A CAT","CAT CCATT","CCATT CCCATTT","CCCATTT CCCCATTTT","CCCCATTTT CCCCCAT...
17:35:43 <ion> > let f 'A' = 'A CAT'; f c = [c] in iterate (concatMap f) "A"
17:35:44 <lambdabot>   <no location info>:
17:35:44 <lambdabot>      lexical error in string/character literal at chara...
17:35:53 <ion> > let f 'A' = "A CAT"; f c = [c] in iterate (concatMap f) "A"
17:35:54 <lambdabot>   ["A","A CAT","A CAT CA CATT","A CAT CA CATT CA CAT CA CATTT","A CAT CA CATT...
17:38:30 <ion> > let f 'n' = "ya"; f 'y' = "nc"; f 'a' = "at"; f c = [c,c] in fix (('n':) . (f =<<))
17:38:32 <lambdabot>   "nyancatyaccatttncatccccatttttttyaccatttccccccccatttttttttttttttncatccccatt...
17:39:11 <mauke> > let f 'A' = "A CAT"; f c = [c] in iterate (concatMap f) "A"
17:39:13 <lambdabot>   ["A","A CAT","A CAT CA CATT","A CAT CA CATT CA CAT CA CATTT","A CAT CA CATT...
17:40:55 <mauke> > concatMap (\s@(c:_) -> show (length s) ++ [c]) . group $ "11"
17:40:56 <lambdabot>   "21"
17:41:08 <mauke> > iterate (concatMap (\s@(c:_) -> show (length s) ++ [c]) . group) "1"
17:41:10 <lambdabot>   ["1","11","21","1211","111221","312211","13112221","1113213211","3113121113...
17:43:17 <ion> > let f 'n' = "yan"; f 'y' = "cat"; f 'a' = "nyan"; f 'c' = "cat"; f 't' = "cat"; f c = [c, chr (ord 'a' + (ord c - ord 'a' + 1) `mod` (ord 'z' - ord 'a' + 1))] in fix (('n':) . (f =<<))
17:43:19 <lambdabot>   "nyancatnyanyancatnyancatyancatnyanyancatnyanyancatnyancatyancatnyanyancatn...
17:43:44 <ion> whoops, accidental repetition.
17:44:04 <ion> Oh, not quite repetition.
17:45:55 <marzy> when simulating card game dealing in languages I usually use I would just mutate list of cards and pop 2 cards from it for each player. in haskell I'm doing awkward things like `take 2 deck` for first player, then `take 2 $ drop 2 deck` for second, etc. what would be a more idiomatic way of writing this?
17:46:46 <mauke> use something like the State monad to store the deck
17:46:51 <typoclass> marzy: it's not perfect, but i think it'd be a step in the right direction to do splitAt
17:46:59 <mauke> define a draw action that pops off the first element
17:47:04 <mauke> call runState with a shuffled deck
17:47:05 <Petit_Dejeuner__> recurse until the deck is empty and then return a list of the hands?
17:47:06 <typoclass> > splitAt 2 "lolcats" -- do this repeatedly
17:47:07 <lambdabot>   ("lo","lcats")
17:47:29 <mauke> oh, it's not interactive
17:47:48 <mauke> in that case, shuffle the deck and look at Data.List.Split
17:49:10 <gwern> @quote
17:49:11 <lambdabot> srhb says: I think that's going into space rather than diving into the deep end.
17:49:28 <gwern> obviosuly we need a space cadet keyboard specialized for haskell
17:52:01 <spckd> not sure if its topical but I am using haskell-mode for emacs and I am getting argument hints in buffers but not in repl. How to get it in both?  also indentation seems very awkward
17:56:35 <clahey> I like the State monad thing.
17:58:18 <Ralith> how do you get argument hints in haskell-mode at all?
17:58:27 <typoclass> spckd: i'm not familiar with emacs, but if that repl is anything like ghci, you could always do ":t" so you know at least the type of the function arguments
17:58:29 <typoclass> :t map
17:58:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:58:31 <Ralith> indentation is always awkward, though, due to layout.
17:58:53 <geekosaur> the repl *is* ghci, usually
18:03:01 <spckd> Ralith: looking at my config it seems turn-on-haskell-doc-mod controls that
18:03:57 <spckd> And yes typing that while in repl got it working. Heh
18:04:29 <spckd> Now if only I had symbol completion I would be all set
18:05:02 <Ralith> spckd: hm, that doesn't seem to have had any effect on my file buffer
18:05:18 <cofox> what should the indentation be for 'instance Num NewType where ... "? i cant' seem to figure it out
18:06:23 <typoclass> cofox: i'd use one line for "instance Num ... where", and indent one step for the rest of the lines in your instance
18:07:14 <cofox> typoclass, yes, that's what i'm doing, i still get misplaced type signature
18:07:51 <spckd> Ralith: does it work if you type say length without space? I am getting function declaration in minibuffer. After pressing space it is no longer there, so I will try to tweak that a bit
18:08:12 <typoclass> cofox: hmm ... you don't normally put type signatures inside an instance (they go in the typeclass). put your problematic code on hpaste for us to look at
18:08:15 <typoclass> @where hpaste
18:08:15 <lambdabot> http://hpaste.org/
18:08:47 <Ralith> spckd: ah; in lisp-mode, the equivalent only happens *after* you type a space (and the arguments are hilighted as you enter them)
18:09:05 <Ralith> if I don't space it works; thanks!
18:09:49 <spckd> Lisp-mode sounds nicer, I'll give it a try. Thanks too
18:10:04 <Ralith> lisp-mode is, well, for lisp.
18:10:29 <Ralith> it (as provided by SLIME) is extremely nice, but lisp is known for having extremely nice editor support, particularly from emacs.
18:10:30 <spckd> Indeed, brain fart :)
18:10:43 <Ralith> I would be very happy indeed if haskell-mode even began to approach that.
18:11:25 <typoclass> spckd: you might hang around until you run into john, he's the resident emacs expert and has spent quite some time getting a good setup for haskell hacking together. he's around pretty often
18:11:30 <typoclass> spckd: johnw that is
18:12:16 <spckd> typoclass: ok I will stick around
18:15:33 <spckd> Ralith I have seen some pretty impressive things done in SLIME, such as recomping code live without restarting the program. Wonder if something like that would be possible in haskell-mode
18:15:44 <byorgey> conal: ping
18:16:13 <Ralith> spckd: that's got next to nothing to do with SLIME; it's just how common lisp works.
18:16:51 <spckd> Yeah I see
18:16:55 <byorgey> conal: I actually just got a chance to try it out, and it works great.  I was indeed able to remove a few now-redundant AdditiveGroup (Scalar v) constraints.
18:17:03 <Ralith> you might not want that for Haskell; open source compilers for Common Lisp took decades to become good-quality, perhaps in part due to the complexity that sort of feature entails.
18:17:10 <conal> byorgey: thanks!
18:17:53 <Ralith> also, I expect doing so in Haskell would violate some important invariants
18:21:02 <jaskamiin> oh god
18:21:03 <jaskamiin> new here
18:21:04 <jaskamiin> help
18:21:27 <mauke> hmm?
18:21:31 <typoclass> jaskamiin: hello, what's up?
18:21:45 <typoclass> jaskamiin: this channel is for discussing the programming language haskell
18:21:49 <jaskamiin> Dunno. I'm new to Haskell. Wanted to see what it's about
18:22:04 <jaskamiin> I am rather comfortable with C++, if that helps
18:22:29 <typoclass> jaskamiin: it's pretty awesome, as any number of people in here will attest ;-) have you seen lyah? it's a pretty good book available free of charge
18:22:30 <jrajav> Haskell's different from C++ in some pretty fundamental ways
18:22:31 <typoclass> @where lyah
18:22:31 <lambdabot> http://www.learnyouahaskell.com/
18:23:26 <jaskamiin> May be a broad question, but what's it's big purpose? I.E C++ is pretty famous for game and software development
18:23:36 <jaskamiin> Java for everything on Carl Sagan's good earth
18:23:38 <jaskamiin> etc
18:24:04 <typoclass> jaskamiin: what haskell is about, for me, is that the compiler is unbelievably helpful. it points out damn near everything that can go wrong with your code. it's very hard to get things to compile in haskell, but once it does, there's rarely many bugs left. in other languages, once something compiles, you're just starting out with the hours and days of tracking down bugs
18:24:18 <dolio> Heh, C++ is famous for software development, eh?
18:24:26 <Ralith> Haskell is "famous for" being powerfully expressive, I suppose.
18:24:29 <geekosaur> infamous, you might say
18:24:29 <djahandarie> jaskamiin, Haskell is general purpose, but has historically been used by people who want good relability guarentees about the program. Haskell automates a lot of reliability checks (through its type systems).
18:24:40 * hackagebot vector-space 0.8.4 - Vector & affine spaces, linear maps, and derivatives  http://hackage.haskell.org/package/vector-space-0.8.4 (ConalElliott)
18:25:09 <troydm> still i sometimes feel like the only thing haskell lacks is oop objects
18:25:19 <jaskamiin> That's at least my impressin, dolio :P and isn't Haskell more of a functional than procedural language?
18:25:26 <jaskamiin> impression*
18:25:35 <djahandarie> troydm, http://homepages.cwi.nl/~ralf/OOHaskell/
18:25:47 <djahandarie> troydm, (it isn't actually used). I don't feel a need for objects.
18:25:56 <dolio> I prefer a programming language that isn't famous for software development. That's why I use Agda.
18:26:17 <Ralith> troydm: why could you possibly want those?
18:26:20 <djahandarie> You prefer languages that are famous for being so obscure for software development?
18:26:26 <Ralith> dolio: haha
18:26:28 <marzy> can i pretend i am mutating things somehow? by reassigning the variable to a different value without actually changing the object it points to.  something like  x = "foobar"; x = first* $ splitAt 2 x
18:26:42 <jaskamiin> he's hipster, don't worry
18:26:58 <djahandarie> hipolio
18:26:58 <dolio> djahandarie: You probably haven't heard of it.
18:26:59 <troydm> Ralith: well the more complicated software needs become the more complicated it is to write in functional style
18:27:03 <Eduard_Munteanu> Hah.
18:27:05 <dolio> Oh wait.
18:27:06 <Ralith> marzy: you should read LYAH.
18:27:19 <Ralith> troydm: that is nonsense.
18:27:33 <marzy> yes I am reading it, but I keep stopping to apply what I've learned thus far
18:27:45 <jaskamiin> Brainfuck.
18:27:45 <troydm> Ralith: why is it?
18:27:50 <typoclass> jaskamiin: a simple example is that most languages conflate pointers and NULL, i.e. to be absolutely sure, you'd need to do "if (o != NULL)" all the time. in haskell, those are separated, and the compiler can tell. a String in haskell is definitely a String and cannot be NULL. for something that can be NULL, we have another representation called a Maybe. so: no null pointer exceptions in haskell, ever! :-)
18:27:59 <jrajav> troydm: And there's a paradigm that makes the code simpler as the software becomes more complicated?
18:28:00 <Eduard_Munteanu> marzy: no, but you can just use the second x's definition.
18:28:05 <typoclass> jaskamiin: and yes, haskell is very far on the functional end of the spectrum
18:28:12 <jaskamiin> no...pointers...?
18:28:16 <jaskamiin> *boner alert*
18:28:25 <Ralith> troydm: there is nothing magic about OOP that makes software simpler under it. In fact, it's widely reputed for making things far more verbose than necessary.
18:28:26 <jaskamiin> i might learn me a haskell
18:28:34 <troydm> jrajav: atleast it's simpler with oop than without it
18:28:37 <marzy> Eduard_Munteanu what do you mean by second x's definition?
18:28:45 <jrajav> troydm: That's arguable
18:28:56 <Ralith> troydm: this indicates that you know OOP better, not that OOP is better.
18:29:07 <troydm> scala is nearing the perfect ratio of oop functional programming language
18:29:09 <typoclass> jaskamiin: do it! :-) learn you a haskell. it will make you a better programmer in any language, whether you end up using haskell or not
18:29:25 <jaskamiin> Sounds good
18:29:32 <jaskamiin> I like that it has this little community
18:29:39 <Ralith> little?
18:29:42 <Eduard_Munteanu> marzy: if you have x = "foobar" and some other thing that's splitAt 2 x, just use splitAt 2 x.
18:29:42 <jaskamiin> erm
18:29:46 <troydm> Ralith: i do know oop better because i've did numerous big complex projects in oop style
18:29:47 <`Jake`> Well, it's growing
18:29:47 <Ralith> this is one of the larger channels on freenode >_>
18:29:47 <jaskamiin> you know what i mean
18:29:47 <jrajav> troydm: OOP is a useful abstraction, but functional programming is more useful, especially when you use it to the exclusion of OOP
18:30:18 <typoclass> whatever the size, the point is that we've so far managed to keep the yelling to a minimum
18:30:22 <jrajav> troydm: I would argue that the more clean, modular, and idiomatic your OOP organization, the closer it's getting to simply being functional programming with the object being an implicit argument
18:30:22 <marzy> Eduard_Munteanu I am splitting several times though
18:30:36 <troydm> i think functional programming doesn't implies exclusion of oop
18:30:47 <simpson> Is it that time again?
18:30:58 <Eduard_Munteanu> marzy: recursively? If so, you can pass a modified parameter onto the next call.
18:31:10 <jrajav> troydm: That's fine, but not what I said.
18:31:30 <typoclass> marzy: that is very often done by a function calling itself (known as recursion). you have argument "x", do something, then you call the function with some new value for x
18:33:02 <Eduard_Munteanu> marzy: consider fact 0 = 1; fact n = n * fact (n - 1). Instead of thinking you mutate 'n', you're just passing around *another* n.
18:33:29 <dolio> That's maybe not so clean an example.
18:33:29 <Eduard_Munteanu> (which is the factorial function)
18:34:00 <dolio> But factAcc r 0 = r ; factAcc r n = factAcc (r*n) (n-1) more obviously illustrates it.
18:34:12 <dolio> Instead of a loop with mutation.
18:34:31 <Eduard_Munteanu> Right.
18:34:32 <Nereid> hmm
18:34:48 <dolio> I meant to say 'clear' too. Somehow I typed clean.
18:34:58 <Nereid> so I've got some f :: (forall b. F b -> F b) -> F a -> F a
18:35:04 * typoclass isn't entirely sure what's more obvious about that ...
18:35:20 <Nereid> and I want to write fix f, but I get some type error.
18:35:25 <Nereid> what do I do
18:35:25 <Eduard_Munteanu> typoclass: "updating" an accumulator.
18:35:42 <Eduard_Munteanu> :t fix
18:35:43 <lambdabot> forall a. (a -> a) -> a
18:35:48 <typoclass> Eduard_Munteanu: hmm okay
18:36:25 <Nereid> if I had f :: (F a -> F a) -> F a -> F a then fix f would be fine
18:37:17 <Nereid> oh I guess I can write fix f = f (fix f)
18:37:39 <Nereid> er I mean
18:37:45 <Nereid> g = f g
18:37:48 <Nereid> and g would be the fix f I want.
18:38:12 <dolio> Nereid: GHC's inference/checking got a bit worse at that kind of thing recently.
18:39:36 <dolio> Does '(fix :: ((forall b. F b -> F b) -> (forall b. F b -> F b)) -> (forall b. F b -> F b)) f' work?
18:39:41 * hackagebot range-space 0.1.0.2 - A Range type with vector-space instances  http://hackage.haskell.org/package/range-space-0.1.0.2 (JohnLato)
18:41:08 <Nereid> nope
18:41:13 <dolio> Hmm.
18:42:38 <Nereid> hang on let me paste some code.
18:42:40 <marzy> I don't see how recursion would fit in here. here is what I am doing.  I tried to apply suggestions I got earlier but it didn't make things any clearer.  here is the code:  http://hpaste.org/77028
18:43:44 <marzy> as I said earlier in languages I'm used to I would just mutate list and pop cards off it. so I am abit confused how to do this cleanly  without the ability to mutate things
18:44:22 <Eduard_Munteanu> marzy: you can use the State monad to implement a deck you can draw from.
18:45:15 <dolio> Nereid: You can wrap it in a newtype.
18:45:20 <dolio> But that's annoying.
18:45:24 <Nereid> hmm
18:46:10 <Eduard_Munteanu> dolio: doesn't that call for an impredicative 'fix'?
18:46:39 <dolio> It calls for an impredicative instantiation of fix, which GHC doesn't do anymore.
18:46:43 <Eduard_Munteanu> f :: (forall a. F a -> F a) -> (forall a. F a -> F a), you'd have to instantiate 'a' to something polymorphic.
18:46:48 <Eduard_Munteanu> (the 'a' in fix)
18:46:53 <dolio> Right.
18:47:47 <marzy> Eduard_Munteanu I'll try. that's probaly way over my head though, I just've only read few chapters in at the moment. I am on second chapter in LYAH
18:48:06 <Eduard_Munteanu> Did it ever do it? I thought it never did, since stuff like runST was never composable.
18:48:16 <marzy> sorry for messed up sentence my client is acting weird
18:48:18 <dolio> Yeah, it did do it.
18:48:29 <Eduard_Munteanu> marzy: ah, leave the monads for later then.
18:48:35 <dolio> Not always well.
18:48:43 <marzy> that's how it would be done in haskell though?  simulating mutability with State monad?
18:48:44 <Eduard_Munteanu> dolio: hm, special cases perhaps?
18:49:01 <dolio> Eduard_Munteanu: It certainly used to do it if you gave it an explicit signature.
18:49:12 <dolio> And there are ways to check it correctly.
18:49:27 <dolio> Expecting it to happen automatically like with 'runST $ ...' is dicier.
18:50:17 <dolio> For that, it did do it at two separate points (maybe it still does), but with a total hack.
18:50:21 <dolio> Actually, two hacks, I think.
18:50:38 <typoclass> marzy: could you tell us a little about how you later use player1, player2, etc.?
18:50:40 <Eduard_Munteanu> I remember some discussion on haskellwiki about that.
18:51:02 <dolio> The first hack was 'left-to-right' instantiation, so 'runST $ ...' works, but if you had a flipped ($), it wouldn't work '... |> runST'.
18:51:16 <dolio> And more recently they just special cased $.
18:51:29 <Eduard_Munteanu> Yeah, that's pretty ugly. :(
18:51:32 <dolio> So 'runST $ ...' worked, but 'runST `id` ...' did not.
18:51:38 <dolio> Or any other operator name.
18:51:44 <dolio> Which is super ugly. I don't know if that's gone.
18:52:28 <dolio> Nope, $ is still special.
18:52:52 <marzy> typoclass I want to calculate odds of winning for each player at everystage of the game (flop, turn, river)
18:53:12 <shachaf> dolio: It's not the name, it's the type.
18:54:01 <Eduard_Munteanu> dolio: it kinda makes me wonder if a universe hierarcy like Agda's might save the day for Haskell too, especially since AFAIU you can't really control impredicative instantiation.
18:54:07 <shachaf> > let foo :: a -> a; foo x = x in runST `foo` return 5
18:54:08 <lambdabot>   Couldn't match expected type `m t'
18:54:08 <lambdabot>         against inferred type `forall s....
18:54:10 <shachaf> > let foo :: (a -> b) -> (a -> b); foo x = x in runST `foo` return 5
18:54:11 <lambdabot>   5
18:54:16 <dolio> shachaf: No, it isn't.
18:54:35 <shachaf> dolio: Well, the above seems to work...
18:54:42 * hackagebot range-space 0.1.0.3 - A Range type with vector-space instances  http://hackage.haskell.org/package/range-space-0.1.0.3 (JohnLato)
18:54:53 <dolio> shachaf: If it's the type, then it's specific to (a -> b) -> a -> b.
18:55:09 <shachaf> That's still better than being specific to the name "$".
18:55:12 <dolio> I defined it in GHCi, and the inferred type was (t1 -> t) -> t1 -> t and it didn't work.
18:55:36 <marzy> typoclass to do that I need acces to all the variables. player1 cards, player2 cards, and community cards
18:55:44 <shachaf> dolio: Oh, that's weird.
18:56:02 <dolio> Nope, (a -> b) -> a -> b doesn't work, either.
18:56:24 <shachaf> It seemed to work just above...
18:56:25 <Nereid> basically, I'm trying to make polymorphic recursion explicit.
18:56:33 <shachaf> Oh, GHC 7.whatever broke it.
18:56:38 <dolio> Well, I don't know what version of GHC lambdabot is on.
18:56:42 <shachaf> 6.12
18:56:43 <dolio> I'm on 7.6.1.
18:56:50 <shachaf> Yes, I see the same behavior on 7.6
18:57:23 <Eduard_Munteanu> I wonder if impredicativity is always safe, or sound. Should everything be allowed to get instantiated to polymorphic stuff?
18:57:41 <dolio> It's safe.
18:57:51 <dolio> But checking it is hard, and has tradeoffs.
18:57:53 <shachaf> Eduard_Munteanu: I don't know whether it's safe or sound, but I know it sounds safe.
18:57:59 <Eduard_Munteanu> :)
18:58:03 <shachaf> What are the tradeoffs?
18:58:26 <Eduard_Munteanu> Maybe similar reasons as for rank-2 inference apply?
18:58:26 <typoclass> shachaf: the technical term is soufe
18:58:34 <dolio> Well, in HMF, you have to annotate stuff for it to work sometimes.
18:58:37 <`Jake`> @pl zipWith (+) (cycle [0..9]) (concat $ map (replicate 10) [0..9])
18:58:38 <lambdabot> zipWith (+) (cycle [0..9]) (replicate 10 =<< [0..9])
18:58:58 <dolio> MLF might be able to work it out better, but that requires non-standard extensions to the type system.
18:59:10 <Eduard_Munteanu> By that I mean tougher type inference and cryptic error messages unless you really meant to use rank-2 types.
18:59:12 <dolio> That you probably wouldn't want showing up in GHC.
18:59:35 <`Jake`> @pl zipWith (+) $ cycle [0..9] $ replicate 10 =<< [0..9]
18:59:35 <lambdabot> zipWith (+) (cycle [0..9] (replicate 10 =<< [0..9]))
18:59:36 <dolio> And I think the reason they got rid of what little they had before was that it interacts poorly with their fancy new local constraints stuff for GADTs.
18:59:43 <dolio> In ways I don't really understand.
19:00:13 <shachaf> `Jake`: @pl isn't going to do too much when you don't have any points.
19:00:24 <dolio> Oh, and HMF takes a lot of work. Like, you need to make sure you sort all quantifiers in a canonical order.
19:00:25 <Eduard_Munteanu> dolio: does ImpredicativeTypes control any of that? Or is it just for stuff like Maybe (forall a. a)?
19:01:07 <dolio> But, that order is hard to do if you have stuff like type class contexts, which are fundamentally unordered.
19:01:12 <`Jake`> shachaf: I didn't really expect something the first time, but it did simplify it, so you can never know ;) (or at least I can never know...)
19:01:18 <dolio> Eduard_Munteanu: ImpredicativeTypes is kind of unrelated.
19:01:32 <dolio> It's just for the Maybe (forall a. a -> a) stuff.
19:01:41 <Eduard_Munteanu> Ah.
19:02:18 <dolio> GHC used to do the (forall a. a -> a) ==> (forall a. a) -> (forall a. a) type instantiations whether or not that was on.
19:02:22 <dolio> Now it just bombs.
19:02:47 <shachaf> :-(
19:03:25 * Eduard_Munteanu crawls back in Agda's arms :P
19:03:49 <dolio> Because it normalizes the latter type to forall b. (forall a. a) -> b, and then I think naively instantiates both outer quantifiers, and ends up finding that (forall a. a) doesn't match a skolem.
19:05:16 <spckd> Would it be possible to write a show thingy for all the functions, so that I am not getting errors in ghci when a function is returned
19:05:55 <Eduard_Munteanu> spckd: not really, not something meaningful at least.
19:06:37 <Ralith> > id
19:06:38 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:06:38 <lambdabot>    arising from a use of `...
19:06:49 <Ralith> overlapping? huh.
19:06:57 <Ralith> > (+)
19:06:58 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
19:06:58 <lambdabot>    arising from a use...
19:07:01 <Ralith> oh well
19:07:06 <Ralith> used to work
19:07:25 <Eduard_Munteanu> @query lambdabot
19:07:25 <lambdabot> Unknown command, try @list
19:07:32 <Eduard_Munteanu> Oops.
19:08:13 <Ralith> hah
19:09:04 <Eduard_Munteanu> I wondered why tab-completion was getting "query" done, but for some reason I insisted. :D
19:09:08 <Eduard_Munteanu> *wasn't
19:14:57 <Nereid> @src iterate
19:14:57 <lambdabot> iterate f x =  x : iterate f (f x)
19:22:21 <roconnor> @where
19:22:21 <lambdabot>  @where <key>, return element associated with key
19:22:23 <roconnor> @where TTFP
19:22:23 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
19:25:04 <hpaste> typoclass annotated “m” with “m (annotation)” at http://hpaste.org/77028#a77030
19:25:21 <typoclass> marzy: hmm, so i've come up with something, but it's not terribly beautiful :)
19:25:33 <typoclass> now i'm annoyed that i didn't manage anything better
19:25:40 <broombs> STM Newbie: I must be using these functions wrongly, because I can't get the following to do what I expect it "should" do:
19:25:43 <broombs> let x = newTVar 3
19:25:43 <broombs> atomically $ do { v <- x; readTVar v }
19:25:46 <broombs> atomically $ do { v <- x; writeTVar v 4 }
19:26:02 <broombs> (In ghci)
19:26:17 <shachaf> broombs: Yes, you want to *execute* newTVar.
19:26:22 <typoclass> broombs: welcome to haskell. we have hpaste available for sharing code > 1 line
19:26:25 <typoclass> @where hpaste
19:26:25 <lambdabot> http://hpaste.org/
19:26:30 <shachaf> v <- atomically (newTVar 3)
19:26:41 <shachaf> atomically $ readTVar v
19:26:48 <shachaf> atomically $ writeTVar v 4
19:26:54 <marzy> typoclass I'd be interested to see. I have ben trying to do something like this  let (player1 : player2: ...) splitManyAt [2,2,..] ..
19:27:09 <shachaf> broombs: "newTVar 3" is an STM action that, when executed, will create a new TVar with a value of 3.
19:27:17 <shachaf> If you execute it N times, you get N new TVars. :-)
19:27:39 <typoclass> marzy: oh sorry, you didn't see the link? http://hpaste.org/77028
19:27:40 <broombs> Ah.
19:27:56 <shachaf> @ty splitAt
19:27:57 <lambdabot> forall a. Int -> [a] -> ([a], [a])
19:28:02 <typoclass> marzy: it's basically the same as your "let (player1 : player2)" idea!
19:28:10 <shachaf> typoclass: ⛝☝
19:28:34 <johnw> shachaf: that one didn't display here
19:29:04 <typoclass> shachaf: yup, thanks, but i stuck with take an drop because that's what he already knows and splitAt is nearly no improvement in this case (i first had splitAt, then changed it to the current)
19:29:06 <marzy> typoclass hah yes. it is nicer than what I had earlier.
19:30:17 <marzy> and your take' is a lot cleaner than the messs I made with splitManyAt. have to figure out how it works
19:30:44 <typoclass> shachaf: and that displayed as a little box containing "26DD", which i don't feel is appropriate in a family-friendly channel, followed by and a hand pointing up, which may have been i shudder to think where
19:31:50 <shachaf> This channel is meant to be family-friendly?
19:32:06 <typoclass> marzy: thanks, but i'm not reeeally happy with it; and it's not really shorter than your initial version. the trick in take' is the recursion (as discussed earlier). you know the 'where' syntax?
19:32:08 <johnw> that really depends on the family
19:32:35 <typoclass> -XTypeFamily
19:33:11 <dolio> The first thing is a box with an x in it.
19:33:12 <marzy> I will look it up. it looks similar to let
19:33:18 <espringe> What's wrong with this really simple code: http://hpaste.org/77031
19:33:19 <espringe> I'm just passing in a function that I'm ignoring, I don't understand the compile error
19:33:36 <typoclass> marzy: yeah, 'let' and 'where' are very very similar
19:36:26 <rwbarton> espringe: that error basically means it doesn't know which type to use digit at
19:36:42 <rwbarton> and it doesn't realize that in this case it doesn't matter
19:37:05 <espringe> hm, i see
19:38:13 <espringe> Thanks, i think i get it now
19:38:38 <johnw> rwbarton: is that really the problem?
19:38:49 <johnw> I don't see why a Parsec type class is involved in the error message
19:38:57 <johnw> unless this example is missing some context
19:38:59 <espringe> oh, digit is a parsec function
19:39:15 <espringe> *Main> :t digit
19:39:15 <espringe> digit
19:39:16 <espringe>   :: Text.Parsec.Prim.Stream s m Char =>
19:39:16 <espringe>      Text.Parsec.Prim.ParsecT s u m Char
19:39:49 <johnw> because if I just paste that code into a haskell file, sans Parsec, it works fine
19:39:51 <rwbarton> yeah, so if it had a single instance Text.Parsec.Prim.Stream s m Char that worked for all s and m, then it could know to use that instance
19:40:06 <rwbarton> that's why the error message is worded thus
19:40:14 <johnw> yes, the actual type of digit requires a type "context"
19:40:17 <johnw> but there is none here
19:40:26 <espringe> sorry about that
19:40:29 <johnw> because the argument is not used in any way
19:40:39 <johnw> so the specific type cannot be inferred
19:41:27 <espringe> I'm finding it really annoying, because I can't go something like:
19:41:27 <espringe> manyDigits = many digit
19:41:31 <espringe> because it can't infer the arguments
19:41:31 <johnw> espringe: this is exactly the same problem you'd run into if you used (read "foo") here
19:41:42 <johnw> it would get a type inference error as well
19:41:55 <shachaf> djahandarie: #-blah misses you.
19:42:42 <rwbarton> espringe, that looks like a different problem--the MR
19:42:51 <espringe> So something like:
19:42:51 <espringe> foo = digit
19:42:52 <espringe> doesn't compile, unless I add "foo :: GenParser Char s Char"
19:42:57 <espringe> which is rather confusing
19:43:10 <johnw> the type of foo should be: Parser Integer, shouldn't it?
19:43:12 <johnw> and not just "Integer"
19:43:26 <rwbarton> the example you pasted really doesn't compile
19:43:32 <espringe> foo :: GenParser Char m0 Char
19:43:32 <espringe> foo = digit
19:43:34 <espringe> that would compile
19:43:41 <espringe> but:
19:43:41 <espringe> foo = digit
19:43:42 <espringe> wouldn't
19:43:42 <johnw> GenParser Char m0 Char == Parser Char
19:43:46 <rwbarton> these new examples you can make compile with {-# LANGUAGE NoMonomorphismRestriction #-} (or as you noted, a type signature)
19:43:47 <shachaf> {-# LANGUAGE NoMonomorphismRestriction #-}
19:43:55 <johnw> (unless I'm missing something about the use of generic parsers)
19:43:59 <espringe> Oh cool
19:44:05 <shachaf> {-# LANGUAGE Curses, FoiledAgain #-}
19:44:07 <espringe> thanks, i'll use that
19:45:14 <shachaf> {-# LANGUAGE Drat, DoubleDrat, RankNDrat #-}
19:46:10 <gfredericks> is `sudo apt-get install cabal-install` a bad idea?
19:46:23 <johnw> it's not a bad idea
19:46:28 <johnw> i did it just a few days ago
19:46:29 <gfredericks> okay it sounds easy.
19:46:32 <shachaf> gfredericks: Not especially.
19:46:36 <shachaf> It might not get you the latest version.
19:46:43 <shachaf> You can always cabal install cabal-install to get that, though.
19:46:46 <gfredericks> I'm not looking for edgy stuff
19:46:51 <gfredericks> just a way to get some libs
19:46:52 <johnw> oh, apt-get install
19:46:56 <johnw> i didn't see that
19:47:01 <johnw> i thought he said "cabal install"
19:47:11 <typoclass> gfredericks: you might want to make sure you get the 1.16, which people say is way better than the older stuff
19:47:29 * gfredericks does it
19:47:52 * gfredericks holds his breath
19:48:07 <gfredericks> 0.10.2-3 is the version it logged
19:48:20 <gfredericks> is that a plausible version number? and a terrible one?
19:48:45 <lispy> hello
19:48:49 <rwbarton> plausible yes
19:49:10 <gfredericks> cabal --version
19:49:11 <gfredericks> cabal-install version 0.10.2
19:49:11 <gfredericks> using version 1.10.1.0 of the Cabal library
19:49:17 <lispy> Anyone here interested in doing static analysis of fortran code?
19:49:24 <shachaf> hi lispy
19:49:38 <typoclass> lispy: hai
19:49:41 <johnw> lispy: all depends on how much you're paying
19:49:52 <lispy> A bunch of us met in person today and one thing we talked about was making a parser/AST in Haskell
19:49:56 <gfredericks> so if I now `cabal install cabal-install` it will somehow install a separate cabal that takes priority oven the one I just installed?
19:50:04 <espringe> if you add it to your PATH
19:50:13 <shachaf> gfredericks: A separate cabal-install, not a separate cabal.
19:50:14 <espringe> use "which cabal" to see what it's picking up
19:50:20 <shachaf> gfredericks: cabal-install is just a program.
19:50:28 <gfredericks> what is cabal then?
19:50:32 <lispy> johnw: we have a grant to work on fortran tools, that's how I'm involved
19:50:33 <gfredericks> the whole system?
19:50:35 <gfredericks> not a program?
19:51:09 <johnw> for half a mil yearly I'll work on a static analyzer for fortran in Haskell
19:52:23 <johnw> and mind you, writing static analyzer is something I already get paid to do; it's just the fortran part that makes it less palatable
19:52:51 <espringe> does the "in haskell" part make up for it, though?
19:52:59 <johnw> yes, that's what makes me even offer
19:53:20 <shachaf> johnw: Using any lenses yet?
19:53:31 <johnw> shachaf: are you making fun of me?
19:54:11 <shachaf> johnw: No?
19:54:17 <shachaf> I'm making fun of myself if anything.
19:54:25 <johnw> :)  I have used lenses very recently, yes
19:54:50 <johnw> i'm starting to find that for very shallow structures, they do not add much clarity, and even take some away
19:54:57 <johnw> but for deeper structures, the win can get big
19:55:07 <gfredericks> whoop got 'cabal: Couldn't read cabal file "warp/1.3.4.2/warp.cabal"'
19:55:19 <gfredericks> yay
19:55:29 <lispy> gfredericks: oh, I know this one
19:55:31 <shachaf> gfredericks: Oh, I remember that.
19:55:32 <gfredericks> this is exactly how I remember dealing with haskell stuff to be
19:55:45 <johnw> gfredericks: you mean, older versions of cabal?
19:55:48 <gfredericks> probably
19:55:49 <lispy> gfredericks: We have to get you upgraded to a new cabal ASAP
19:55:56 <lispy> it's a bug
19:55:59 <gfredericks> lispy: that's what I was trying to do :)
19:56:07 <gfredericks> `cabal install cabal-install` was what produced this
19:56:25 <lispy> gfredericks: http://haskell.1045720.n5.nabble.com/cabal-update-retrieves-broken-index-warp-1-3-3-x-cabal-not-readable-td5718441.html
19:56:26 <gfredericks> so I want to back out of the whole thing and install cabal-install manually?
19:56:43 <lispy> gfredericks: repeat that command substituting the broken warp version
19:56:59 <typoclass> gfredericks: no, it's fairly easy to fix. "tar something something" and you're good
19:57:00 <lispy> then do the cabal install
19:57:11 <lispy> tar -f 00-index.tar --delete warp/1.3.3
19:57:16 <johnw> shachaf: how about you, any lenses lately?
19:57:22 <lispy> in your case, warp/1.3.4.2
19:57:44 <lispy> find ~/.cabal -name "00-index.tar"
19:57:54 <lispy> I never can remember where to find that
19:58:09 <shachaf> Can someone fix warp's .cabal file?
19:58:20 <lispy> shachaf: I don't think it's broken
19:58:30 <shachaf> lispy: Wasn't it using some invalid new extension?
19:58:36 <shachaf> Which no other cabal file is using?
19:58:47 <lispy> shachaf: even so, you'd have to rewrite history on hackage
19:58:49 <gfredericks> okay here we go
19:58:58 <shachaf> lispy: Yes.
19:59:10 <lispy> shachaf: we're purely functional
19:59:10 <shachaf> But on the other hand telling people to tar --delete is pretty awful.
19:59:24 <shachaf> lispy: Consider it a form of GC. :-)
19:59:25 <typoclass> shachaf: i thought it's 2-3 files, not just warp.cabal, but i dunno
19:59:36 <shachaf> lispy: git is purely functional, and still lets you rewrite history.
19:59:56 <lispy> and unsafePerformRebase
19:59:59 <typoclass> shachaf: sure, git is purely functional, and it also is everything else in the world
20:00:01 <gfredericks> by rewriting the whole repo
20:00:17 <shachaf> lispy: rebase isn't really unsafe?
20:00:38 <shachaf> A git repository is by its nature a purely functional data structure.
20:00:46 <lispy> shachaf: you can do things to the history such that when you push to master and others pull they have b0rked repos
20:00:51 <johnw> when you rebase, you don't rewrite history, you create a new history
20:01:03 <johnw> the hard part is convincing everyone else to use it
20:01:15 <shachaf> lispy: Right, by design.
20:01:39 <shachaf> That's not really related, though.
20:02:26 <lispy> It just feels wrong to rewrite hackage because of a buggy cabal release.
20:02:29 <danharaj> how does one extend a free monad into a free monadfix?
20:02:50 <shachaf> You mean how to write instance MonadFix (Free f)?
20:02:53 <typoclass> > (++ "fix") "free monad" -- danharaj
20:02:55 <lambdabot>   "free monadfix"
20:03:21 <monochrom> is it possible?
20:03:27 <lispy> danharaj: nothing is free.
20:03:33 <johnw> i'm sure edwardk would know the answer in his sleep
20:03:55 <shachaf> johnw: Last time the question was asked of edwardk, he said he wasn't sure.
20:03:57 <danharaj> shachaf: I doubt an arbitrary free monad is also a monadfix.
20:03:59 <Ralith> free the monads
20:04:02 <johnw> ah
20:04:22 <typoclass> lispy: i agree it feels wrong, but it'd probably amount to, in one central place, doing the same 3 tar commands that all the users are now doing on 100 computers
20:04:30 <shachaf> danharaj: Ah, you're wondering what you need to add to always have it be monadfix?
20:04:34 <danharaj> yes
20:04:43 <danharaj> the freest monadfix, in fact.
20:08:40 <lispy> gfredericks: any luck with cabal?
20:09:39 <typoclass> lispy: and i bet that for everyone who asks about that thing in here, there's a dozen who muck around ineffectively and end up thinking that haskell is frustrating and unsound :-(
20:09:50 <gfredericks> well it seems to be doing a lot more serious stuff this time
20:09:56 <gfredericks> including hosing up my OS for a couple minutes
20:09:58 <typoclass> lispy: so my 2 cents are, you had an excellent idea, changing the tar file on hackage.haskell.org
20:10:13 <gfredericks> but it's still going
20:10:39 <lispy> typoclass: it wasn't my idea. I think that was someone else.
20:11:16 <typoclass> ok, whoever's idea it was, it's excellent
20:11:28 <gwern> @wn anent
20:11:29 <lambdabot> No match for "anent".
20:11:32 <marzy> well this is interesting. it appears you CAN reassign variables. thought you couldn't.  foo = do let x = 10 print x let x = 20 print x
20:11:52 <gwern> just shadowing
20:12:00 <johnw> that's not reassigning
20:12:01 <shachaf> I thought lispy was against changing the tar file?
20:12:07 <johnw> each line of a "do" block introduces a new lexical scope
20:12:15 <gwern> marzy: desugar the do notation and you'll see it's just lexical scoping
20:12:18 <johnw> so they are not the same "x"
20:12:20 <marzy> it doesn't like let x = x + 1 though :))
20:12:23 <marzy> infinite loop
20:12:33 <lukexi> I just got distributed-process (aka Cloud Haskell) running on iPhone!!!
20:12:38 <johnw> oh, it likes it just fine; it's just that you don't like the result :)
20:12:39 <lispy> > let x = 1 + x in x
20:12:43 <lambdabot>   mueval-core: Time limit exceeded
20:12:51 <gfredericks> that's a funny difference from clojure
20:12:52 <typoclass> marzy: you can do that, but it's not exactly reassigning :-) the outer x stays unchanged, and any place where you use the outer x will continue to see the "old" value. (it's not really old, it's just _the_ value)
20:12:57 <johnw> the result is _|_
20:13:10 <marzy> yeah I got it
20:13:11 <typoclass> lukexi: oh wow, sounds nice
20:13:51 <broombs> Does Haskell's have a function that syncs on a collection of 'events' (say TChan's) and pseudo-randomly chooses one of the events that are ready?
20:14:03 <broombs> (Haskell's -> Haskell)
20:14:13 <johnw> you mean, like doing a "select" on multiple sockets?
20:14:14 <marzy> can you use outer x after second let x declaration?
20:14:15 <beaky> hello
20:14:29 <lukexi> typoclass: yeah, i'm very excited : D
20:14:43 <johnw> marzy: by the name "x", no
20:14:45 <rwbarton> does orElse do this?
20:15:17 <fryguybob> broombs: If you mean non-deterministically, then you are probably looking for `orElse`.
20:15:36 <beaky> what does [x | x <- xs, x /= 3 && x /= 6] desugar to? is it filter (\x -> x /= 3 && x /= 6) (xs >>= \x -> return x)
20:15:37 <rwbarton> yes, it's not really "pseudo-random"
20:15:50 <rwbarton> @undo [x | x <- xs, x /= 3 && x /= 6]
20:15:51 <lambdabot> concatMap (\ x -> if x /= 3 && x /= 6 then [x] else []) xs
20:16:00 <rwbarton> pretty much
20:16:04 <marzy> johnw then how is it wrong to think of this as a mutation of x variable?
20:16:45 <johnw> marzy: if you bound the outer x to y, with let y = x, before creating the inner x, and then you change the
20:16:47 <broombs> fryguybob: orElse is biased in favor of its first argument.  I was hoping for something symmetric (i.e., 'fair').  Thoughts?
20:16:51 <beaky> > let xs = [1..10] in xs >>= \x -> if x /= 3 && x /= 6 then return x else return
20:16:52 <lambdabot>   Couldn't match expected type `[a]'
20:16:53 <lambdabot>         against inferred type `a1 -> m a1'
20:16:53 <johnw> "x" throw shadowing, "y" will not change
20:16:55 <beaky> :(
20:17:03 <johnw> thinking in terms of mutation would imply that y would change too
20:17:11 <johnw> s/throw/threw
20:17:15 <johnw> s/threw/through
20:17:26 <lil`nbv4> what is better, using apt-get or cabal for installing haskel libs?
20:17:39 <typoclass> > let x = 4 in ((let x = 7 in x), x) -- marzy, this may or may not clarify things
20:17:40 <lambdabot>   (7,4)
20:17:46 <marzy> johnw I wouldn't think it would change y. I think of x as a pointer that points to some object. wechange what it poins to, not the actual object
20:17:49 <Rogach> lil`nbv4: Cabal.
20:18:08 <johnw> marzy: well, now you're imposing a memory model too to suit your interpretation.  If it were Java, I would expect it to change
20:18:08 <gfredericks> marzy: you could also make y a function that refers to x
20:18:13 <fryguybob> broombs: Perhaps you want something like this: http://www.cs.rit.edu/~mtf/research/tx-events/index.html
20:18:15 <gfredericks> marzy: and it would still refer to the "old" one
20:18:29 <johnw> but there is no copying going on
20:18:30 <gfredericks> johnw: I wouldn't expect it to change in java
20:18:38 <gfredericks> johnw: not if you do basic assignment
20:18:40 <johnw> the outer x and y refer to the same value
20:18:53 <johnw> the inner x refers to a separate value
20:19:03 <marzy> gfredericks you mean if a function closed over x, that function would still refer to old x
20:19:07 <gfredericks> int x = 10; int y = x; x++; // y == 10
20:19:13 <gfredericks> marzy: exactly
20:19:13 <johnw> yes
20:19:19 <marzy> ok makes sense
20:19:37 <gfredericks> marzy: so in any sense you can come up with, the old x is still there
20:19:47 <rwbarton> do { let {x = 10}; print x; let {x = 20}; print x } might as well be do { let {x = 10}; print x; let {x' = 20}; print x' }.
20:19:49 <marzy> you're right it's not a mutation then
20:19:51 <gfredericks> it's just some code can't see it directly
20:20:21 <gfredericks> and like rwbarton points out, any code that does shadowing like that can be trivially rewritten to not do shadowing
20:20:26 <rwbarton> right
20:20:43 <gfredericks> it's all just a lexical issue
20:21:09 <johnw> marzy: but I do see where you're coming from, it's a commonly asked question
20:21:16 <johnw> it can look and feel like mutation
20:22:16 <gfredericks> erlang's approach is interesting; the compiler doesn't allow it at all.
20:22:33 <johnw> shadowing?
20:22:46 <gfredericks> yeah
20:22:49 <johnw> huh
20:22:51 <gfredericks> it doesn't have a let syntax though
20:22:55 <gfredericks> it looks just like assignment
20:23:00 <johnw> ah
20:23:19 <broombs> fryguybob: I'm looking for the asynchronous version of that.
20:23:29 <johnw> declaration = initialization, a lot of scripting languages do that too
20:23:35 <gfredericks> okay so `cabal install cabal-install` finally finished; `which cabal` still refers to the old one
20:23:43 <typoclass> ghc gives a warning about shadowing if you do -Wall, iirc
20:23:46 <gfredericks> so I want to make sure that ~/.cabal/bin is earlier in my path, right?
20:23:50 <johnw> typoclass: yes
20:24:47 * hackagebot xml-to-json 0.1.1.0 - Simple command line tool for converting XML files to json  http://hackage.haskell.org/package/xml-to-json-0.1.1.0 (NoamLewis)
20:25:37 <gfredericks> yay I can haz cabal 1.16
20:25:47 <johnw> congrats!
20:25:50 <gfredericks> am I safe to apt-get uninstall?
20:25:57 <gfredericks> or should I keep that one around for deps?
20:26:35 <johnw> can't hurt to leave it around for deps
20:26:47 <gfredericks> okay
20:26:51 <gfredericks> thanks folks
20:28:53 <beaky> What monad tutorial would you guys recommend?
20:29:00 <johnw> none of them
20:29:04 <Iceland_jack> Good call
20:29:24 <gfredericks> beaky: using haskell is what did it for me
20:29:25 <johnw> seriously, not even my own
20:29:27 <beaky> ah, but how am I going to master them :(
20:29:33 <johnw> now, if you want to name a particular monad, perhaps I can help you
20:29:47 <beaky> the one I use the most is the list monad
20:30:02 <johnw> LYAH has a pretty good section on the list monad
20:30:06 <beaky> right
20:30:07 <typoclass> beaky: i would write code, use IO, use Maybe, etc. the understanding will come by itself
20:30:49 <johnw> i think the monads everyone should be comfortable with are State, Writer, Maybe, List and IO
20:30:57 <jrnl> probably reading LYAH and playing with all the examples is a reasonably thorough intro, then write code and try to incorporate what you've learned
20:31:19 <beaky> right. for now I will avoid syntactic sugar and do-notation so that I understand what's going on with the monads
20:31:35 <lispy> johnw: I would replace Writer with Reader, but that's a good list
20:31:44 <johnw> i never have a use for Reader
20:31:47 <typoclass> beaky: yes, do that, good call :)
20:32:00 <gfredericks> beaky: I've only used do-notation so far
20:32:10 <gfredericks> maybe the main consequence is that I don't know how to do monadic stuff without it :)
20:32:15 <gfredericks> maybe that means I don't understand monads
20:32:18 <lispy> beaky: I found it instructive to implemente a mini-parsec
20:32:28 <lispy> beaky: my monad-fu went up considerably
20:32:32 <beaky> parsers seem tricky
20:32:39 <beaky> I never understood how they work :(
20:32:52 <lispy> beaky: sounds like a good challenge :)
20:33:00 <beaky> right
20:33:08 <gfredericks> if all else fails, a monad is like a buritto
20:33:12 <johnw> lol
20:33:21 <lispy> gfredericks: best with guacamole?
20:33:30 <gfredericks> yes that
20:34:09 <gfredericks> so now that I have cabal-install does it behoove me to install a ghc with it?
20:34:20 <johnw> no
20:34:33 <johnw> that will invalidate all the packages your newly minted cabal install just installed
20:35:13 <lispy> gfredericks: you can use the new parallel build feature
20:35:21 <johnw> i love that feature
20:35:51 <gfredericks> oh geez so I am stuck with
20:35:54 <typoclass> beaky: also, look at the implementation of e.g. the Maybe monad http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/src/Data-Maybe.html#line-73 it's really not magic. once the ">>=" chain gets to a Nothing, it stops and just gives back Nothing. do syntax can be translated mechanically into a bunch of ">>"s
20:36:02 <gfredericks> 7.0.3
20:36:12 <typoclass> beaky: that tiny bit of code you see there is really all that's going on :-)
20:36:43 <gfredericks> if I start `ghci` by itself  will it have cabal packages on the load path?
20:36:49 <johnw> gfredericks: then build a new GHC, and cabal install --reinstall world
20:37:11 <gfredericks> johnw: I was hoping cabal could build a GHC for me :)
20:37:23 <johnw> gfredericks: i've never even thought to try that
20:37:27 <johnw> i somehow doubti t
20:37:32 <geekosaur> it can;t
20:37:45 <gfredericks> every time I try to do something manually I spend four hours resizing my vm :P
20:37:49 <johnw> i use homebrew to build ghc these days
20:38:03 <lispy> beaky: Have you worked through the examples here? http://www.haskell.org/haskellwiki/All_About_Monads
20:38:20 <typoclass> gfredericks: are you sure you need to build ghc form source? afaik it's rarely necessary
20:38:58 <lispy> beaky: and this is also a favorite of mine: http://www.cs.virginia.edu/~wh5a/personal/Transformers.pdf
20:39:53 <gfredericks> typoclass: not at all sure
20:40:19 <lispy> beaky: Also, put applicative functors on your reading list :)
20:40:21 <typoclass> gfredericks: i think you can do yourself a favor and just go with the binary :)
20:40:27 <gfredericks> woah ghci magically knew about the cabal packages
20:40:33 <gfredericks> does that mean ghci knows about cabal?
20:40:40 <johnw> beaky: once you use monads enough, they will seem simple to you; it's just that there is no shortcut
20:40:56 <rwbarton> cabal's purpose is to build and register packages with ghc
20:41:00 <geekosaur> gfredericks, cabal is a wrapper around ghc-pkg
20:41:09 <johnw> <-- took several years to become happy with Monad
20:41:54 <johnw> bleh, I hate it when I can't resolve cabal dependency issues
20:42:20 <typoclass> gfredericks: you can get it through apt obviously, or you can get the binary package from the ghc website. i heard they're surprisingly easy to install (e.g. into a directory below your home)
20:42:35 <geekosaur> note that if you use the old "runhaskell Setup.[l]hs" method of building packages, they will by default constrain ghc to look only at its global package database, whereas cabal-install installs into theuser package database by default.  You can pass the --user option to Setup.hs to make it use the user package database (cabal-install does this)
20:42:53 <gfredericks> typoclass: okay cool; I'll look into that another day; this day is now over.
20:43:03 * gfredericks goes to bed
20:43:28 <spckd> Is there something like ans in ghci? Fetching last value
20:43:40 <typoclass> spckd: i think it's "it"
20:43:51 <beaky> @hoogle Monad m => m t -> m (t, t)
20:43:53 <lambdabot> Data.Graph.Inductive.Query.Monad applyWith :: Monad m => (a -> b) -> GT m g a -> m g -> m (b, g)
20:43:53 <lambdabot> Data.Graph.Inductive.Query.Monad apply :: GT m g a -> m g -> m (a, g)
20:43:53 <lambdabot> Data.Graph.Inductive.Query.Monad apply' :: Monad m => GT m g a -> g -> m (a, g)
20:44:07 <spckd> It is thanks
20:44:22 <monotheist> does anybody read sicp?
20:44:36 <startling> monotheist: I have.
20:45:14 <monotheist> we should do all of the exercises
20:45:51 <beaky> sicp teaches beginner programming with no built-in control statements, no loops, and no assignment :D
20:46:07 <monotheist> in haskell
20:46:27 <johnw> i wouldn't mind a copy of SICP in Haskell
20:46:58 <beaky> I wonder if all of SICP can be done with Haskell
20:47:16 <Cale> A lot of SICP has been formalised into Haskell
20:47:20 <johnw> http://stackoverflow.com/questions/5489432/sicp-equivalent-for-haskell
20:47:21 <ivanm> beaky: the implementation of streams in Haskell would be interested :p
20:47:21 <rwbarton> @faq can all of SICP be done in Haskell?
20:47:22 <lambdabot> The answer is: Yes! Haskell can do that.
20:47:23 <beaky> like the "roll your own logic DSL" or "write a scheme interpreter" parts :D
20:47:26 <ivanm> *interesting
20:47:38 <startling> gwern did some stuff: http://www.gwern.net/sicp/Introduction
20:47:43 <beaky> aren't streams just lazy lists?
20:47:46 <ivanm> beaky: there's a "write yourself a scheme" tutorial for Haskell already
20:47:51 <Cale> beaky: absolutely, those are easy enough :)
20:47:57 <gwern> bleh that reminds me that I need to do more work on sicp
20:47:59 <ivanm> beaky: yes, hence why it would be an interesting chapter :p
20:48:05 <Cale> In fact, they might even be easier to manage than in scheme :P
20:48:08 <Cale> because pattern matching
20:48:09 <startling> gwern: oh hi
20:48:20 <gwern> I feel embarassed to have not finished
20:48:22 <beaky> I wonder what SICP would be like in Java
20:48:23 <johnw> Cale: what is motivation for using conduits over just lazy lists?  is it all about safe resource finalization?
20:48:31 <Cale> johnw: yes
20:48:37 <johnw> ok
20:49:09 <Cale> johnw: I'm a funny person to ask too, because I'm really picky and don't care much for any of the existing iteratee libraries.
20:49:26 <ivanm> Cale: oh? what do you use then?
20:49:36 <cmears> beaky: maybe you want "liftM (join (,))"  (for your hoogle enquiry)
20:49:38 <Cale> I just use lazy I/O and hope.
20:49:40 <Cale> lol
20:49:43 <lispy> Cale: I'm going to install 7.6 on the linode
20:49:47 <ivanm> Cale: heh
20:49:55 <ivanm> @type fmap (join (,))
20:49:55 <lispy> Cale: I won't delete the older GHCs
20:50:02 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f (a, a)
20:50:03 <Cale> lispy: oh, cool
20:50:04 <lispy> Cale: do you know what the status of lambdabot is for 7.6?
20:50:07 <beaky> cmears: right
20:50:12 <Cale> lispy: Broken
20:50:23 <ivanm> @pl join (,)
20:50:25 <Cale> lispy: actually if you do 7.4, I at least have a working version for 7.4
20:50:30 <lambdabot> join (,)
20:50:33 <ivanm> duh, @pl won't do anything to that
20:50:34 <lispy> Cale: hmm...
20:50:39 <johnw> @unpl join (,)
20:50:40 <lambdabot> ((,) >>= \ a -> a)
20:50:40 <ivanm> was hoping for an Arrow-based solution
20:50:49 <ivanm> @pl \ a -> (a,a)
20:50:49 <lambdabot> join (,)
20:50:50 <startling> heh.
20:51:06 <ivanm> @type id &&& id
20:51:07 <Cale> But I guess if you install 7.6, I can try and struggle to make it work, but a lot of libraries haven't updated yet, from what I understand.
20:51:10 <lambdabot> forall b. b -> (b, b)
20:51:12 <startling> :t (,) >>= id
20:51:13 <lambdabot> forall b. b -> (b, b)
20:51:19 <ivanm> that's what I was after!
20:51:24 <lispy> Cale: I can do 7.4. I just need something new enough to build idris :)
20:51:38 <beaky> @pl xs >>= \x -> xs >>= \y -> return (x,y)
20:51:38 <lambdabot> (`fmap` xs) . (,) =<< xs
20:52:17 <latro`a> :t join (,)
20:52:19 <lambdabot> forall a. a -> (a, a)
20:52:40 <beaky> > join (,) [1..10]
20:52:41 <johnw> @djinn forall a. a -> (a, a)
20:52:41 <lambdabot> f a = (a, a)
20:52:43 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9,10])
20:52:50 <lispy> Cale: new version of cabal installed at /usr/local/bin/cabal-1.16. Okay to make that the default cabal?
20:53:05 <lispy> Cale: I can move the current cabal out of the way and make a symlink
20:54:01 * lispy has cabal in his homedir
20:55:29 <Cale> yeah, okay
20:55:57 <monotheist> noob question:  can haskell be used in a browser?  similar to jsc or php?
20:55:58 <Cale> > 1
20:56:02 <lambdabot>   mueval-core: Time limit exceeded
20:56:07 <Clint> unlambda was the problem child, right?
20:56:10 <beaky> :t concatMap
20:56:12 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
20:56:12 <johnw> monotheist: you mean, on server side to generate HTML?
20:56:14 <beaky> :t (>>=)
20:56:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:56:16 <Cale> monotheist: yes?
20:56:17 <startling> "Immediately one recognizes the distinction between constructive and non-constructive definitions! It’s a long way from asserting that something exists (cf. the Axiom of Choice) and being able to create or demonstrate that something. This is a very profound distinction, and extremely important because any bit of logic which is constructive (Intuitionistic) can be mechanically turned into a working program, of which all the same log
20:56:18 <startling> properties hold! This is the famous Curry-Howard isomorphism, and it’s very important for both Haskellers and FPers in general."
20:56:20 <startling> interesting.
20:56:21 <johnw> monotheist: see Yesod
20:56:35 <Cale> monotheist: There are multiple well-developed web frameworks for Haskell
20:56:44 <Cale> at least, on the server-side
20:56:54 <johnw> startling: where is that from?
20:57:06 <Cale> There are also a lot of projects attempting to compile (usually various subsets of) Haskell to Javascript
20:57:07 <johnw> there is even a Haskell->Javascript complier
20:57:11 <Cale> to be able to use it client-side
20:57:16 <johnw> :)
20:57:26 <Cale> Yeah, there's not even just one Haskell -> Javascript compiler
20:57:41 <lispy> ghc-cabal: eventfd: unsupported operation (Function not implemented)
20:57:48 <startling> johnw: gwern's sicp thing: http://www.gwern.net/sicp/Chapter%201.1
20:58:13 <Cale> http://zelda.designacourse.com/codeworld.html -- this is a program compiled from Haskell to Javascript
20:58:22 <lispy> Cale: not sure what to do about that eventfd thing
21:00:32 <lispy> > 1 + 1
21:00:34 <lambdabot>   2
21:00:41 <johnw> lispy: you're #7 in the intro resources :)
21:00:43 <lispy> Cale: I'll try building from source
21:00:51 <lispy> johnw: say what?
21:01:00 <johnw> check out the intro page
21:01:03 <johnw> bbiab
21:01:11 <lispy> intro page?
21:02:13 <startling> lispy: http://www.gwern.net/sicp/Introduction 7. A blogger named Lispy is occasionally working through SICP.
21:02:42 <lispy> oh, that's not me
21:03:13 <lispy> This is my blog: http://blog.codersbase.com/
21:03:37 <startling> this is the linked blogger: http://lispy.wordpress.com/
21:03:46 <ivanm> lispy: btw, I'm starting on my 4th (or 5th?) attempt: rather than trying to be fancy, I'm giving in and hard-coding the array sizes in to the C side
21:03:57 <ivanm> hopefully this means I don't have to bother with ForeignPtrs...
21:04:32 <lispy> ivanm: it will make being faster than C harder :)
21:04:38 <lispy> ivanm: but yeah, should make certain things easier
21:05:15 <ivanm> well, my approach was to try and allocate the fixed size of memory before running the C anyway
21:05:48 <ivanm> because even with the ForeignPtr stuff, I was getting corruption (first thing in the C method I was calling via FFI was a printing function; it would get into endless loops :s)
21:06:18 <ivanm> what's the best way of defining those values? #define or just a top-level variable in C?
21:06:44 <lispy> the array sizes?
21:06:54 <lispy> I'd use a #define
21:07:51 <ivanm> I'm currently defining my array sizes in Haskell using numeric expressions, including integer division; I guess it's better to just pre-calculate it for a #define?
21:08:20 <lispy> lambdabot may be a bit slow, building a new ghc from source
21:08:47 <Jafet> For lambdabot!?
21:09:07 <lispy> ivanm: I can't really tell from the question
21:09:21 <lispy> Jafet: for the server lambdabot is on in general. But also for lambdabot.
21:09:42 <ivanm> lispy: OK, in Haskell I currently have as top-level values, I have: d = 5, n = 17, b = 2 * (n-2) `div` (d-2) - 1
21:09:49 <Jafet> "A change is comin'..."
21:09:59 <ivanm> in C, would I be better off as solving the value for b myself for the #define ?
21:10:13 <lispy> ivanm: oh, you could have them in a header and #include the #defines in both Haskell and C?
21:10:24 <ivanm> yeah, that's the plan
21:10:27 <lispy> ivanm: you can use an expression
21:10:40 <copumpkin> that b will be computed once per run of your program
21:10:44 <copumpkin> I wouldn't prematurely optimize :P
21:10:44 <lispy> ivanm: #define is just text substitution, so if your C compiler can fold the constant you're good
21:11:01 <Jafet> If this is an ephemeral thing, just stick in any number for testing
21:11:09 <copumpkin> and if your compiler is enthusiastic enough, it'll compute it on the spot anyway
21:11:21 <Jafet> arraysize = 1337
21:11:37 <ivanm> Jafet: nah, the number matters
21:11:44 <lispy> hmm...this build may not finish until morning
21:11:56 <ivanm> I just wasn't sure how safe/sane/sensible it was to do such a computation in a #define
21:12:12 <lispy> (or yet, I may not be able to tell that this build is done until morning)
21:12:25 <Jafet> Actually, the preprocessor has to do arithmetic as well. But you can't obtain the result from it.
21:12:57 <ivanm> what's the equivalent of div in C? IIUC from my copy of C a reference manual, div from stdlib returns the remainder as well
21:13:08 <lispy> ivanm: /
21:13:13 <Jafet> That's the other thing, perhaps
21:13:16 <Jafet> div is /
21:13:19 <copumpkin> mod is %
21:13:23 <copumpkin> or rather, rem is
21:13:28 <ivanm> lispy: how do I make sure it does integer division then?
21:13:34 <ivanm> copumpkin: about to say; already was tripped up by that
21:13:39 <marzy> ivanm by using two integers
21:13:50 <lispy> ivanm: it will default to int. You have to really want floats/doubles to get that.
21:13:57 <ivanm> lispy: ahhh, good-o
21:14:09 <ivanm> because I can't work out how to add type annotations to #define statements :p
21:14:36 <Cale> btw, does anyone know off-hand if there's a way to subscribe to a playlist on youtube? NDdotEDU has this really cool playlist: http://www.youtube.com/course?list=EC80A29806A2EA6B1A
21:14:59 <Clint> does Ørjan Johansen come here?
21:15:55 <ivanm> Cale: hmmmm... "Add to -> Favourites" ?
21:15:57 <Cale> (I definitely wouldn't want to subscribe to the rest of their junk though :P)
21:16:02 <ivanm> depends on what you mean by subscribe
21:16:05 <lispy> Cale: go to this page and click the subscribe button and then deal with the spam for updates you don't care about? http://www.youtube.com/user/NDdotEDU?feature=edu
21:16:11 <Cale> ivanm: hmm, maybe that'll work
21:16:27 <Jafet> @seen oerjan
21:16:28 <lambdabot> Unknown command, try @list
21:16:44 <Cale> lispy: I don't care about 99% of their videos though
21:19:13 <ivanm> lispy: is using a Ptr still the FFI translation of a C array?
21:19:31 <lispy> ivanm: if you had needed to insert the type it would look something like this (int)(2 * ... -1), not sure if the second set of parens are critical
21:19:44 <ivanm> hmmmm
21:19:48 <lispy> ivanm: I don't know. Never tried it.
21:21:57 <lispy> ivanm: C has terrible casting syntax, IMO. Terrible because I can never remember what all it wraps. C++ introduced a change of notation here, so you would say, int(...) and it cast the ... to an int.
21:22:06 <ivanm> *nod*
21:22:16 <ivanm> s/casting// :p
21:22:23 <afshar> hi, I know this is a very subjective question, but what is the best web framework and why? I looked at getting started guides for snap, happstack and yesod
21:22:44 <lispy> afshar: I have used snap and had no problems
21:22:46 <afshar> well, I mean the answers wil be subjective
21:22:57 <afshar> one for snap
21:23:03 <lispy> afshar: I've heard people say yesod is nice but hard to build
21:23:18 <afshar> yesod seems to have the best api to me, but seems very heavy
21:23:22 <jaskamiin> any russians here
21:23:23 <ivanm> I haven't used any; but yesod is aimed a lot more at auto-generation of values that you need
21:23:23 <lispy> afshar: BTW, this smells like a question that would have a good answer on stackoverflow
21:23:37 <stepcut> I vote for Happstack, it offers pretty much everything yesod does but is more modular, uses less template haskell, and is easier to install
21:23:39 <afshar> it's probably been asked actually
21:23:43 <ivanm> jaskamiin: there are some I believe that pop in and out now and then, as well as people who live in other CIS countries; why?
21:23:55 <lispy> afshar: http://stackoverflow.com/questions/5645168/comparing-haskells-snap-and-yesod-web-frameworks
21:23:56 <jaskamiin> i live in Belarus now
21:24:00 <jaskamiin> And just curious
21:24:05 <ivanm> there's a few more from Belarus
21:24:15 <jaskamiin> That's awesome
21:24:18 <afshar> stepcut: that baffled me about yesod, it seems to use th when it doesn't really need it
21:24:22 <ivanm> slyfox for one, though he hangs out in #gentoo-haskell more than here
21:24:24 <afshar> lispy: thanks
21:24:29 <jaskamiin> I'm actually visiting my family in the states now, but just curious :)
21:24:29 <ivanm> afshar: there have been various responses to that
21:24:31 <jaskamiin> and thanks!
21:24:38 <lispy> afshar: I think happstack is losing popularity, but I've never tried it. I think it's less popular because it does less for you. Also, Yesod has a book.
21:24:41 <ivanm> afshar: and some work by the yesod team to provide alternatives
21:24:51 <lispy> afshar: http://www.yesodweb.com/book
21:24:52 <afshar> saw that yesod-pure thing
21:25:01 <stepcut> afshar: yup. yesod comes from a rails background whereas happstack comes from a haskell background
21:25:18 <afshar> that makes so much sense, using happstack actually looked painful
21:25:31 <jaskamiin> stepcut, I've heard a bit about it, what is the Rails framework?
21:25:41 <stepcut> afshar: painful in what way?
21:25:42 <ivanm> the yesod argument seems to be "if we generate it all for you with TH, there's less chance you'll mess up the configuration by forgetting to change something when you sould have"
21:25:59 <ivanm> jaskamiin: Ruby on Rails is a very popular web framework
21:26:04 <stepcut> ivanm: which works fine until you need to do something the generator doesn't do
21:26:09 <ivanm> *nod*
21:26:14 <afshar> stepcut: I am pretty much a haskell newbie, it just looked alien and kludgy to write that code. All my own perception vs snap and yesod code.
21:26:29 <ivanm> lispy: looks like you do need Ptr for arrays, seeing as how CString is a type alias for Ptr CChar :/
21:26:41 <jaskamiin> is haskell OOP language? Sorry for dumb questions...
21:26:48 <ivanm> afshar: happstack is a lot older, and methodology and techniques have moved on since
21:26:48 <stepcut> afshar: alien in what way? it's pretty much just normal Haskell code aside from any HSP stuff
21:26:58 <ivanm> jaskamiin: nope; Haskell is a pure Functional Programming language
21:26:59 <afshar> let me find an example
21:27:15 <lispy> afshar: The time I used snap (just once) was for an internal web page at work that had dynamic content generated by a Haskell library
21:27:23 <stepcut> ivanm: happstack is a lot order, but that doesn't mean stagnant. In Happstack 8 there will be essentially no code left from Happstack 0.1
21:27:25 <Sonarpulse> Hello, #Haskell. I have done a lot of scheme and C, but I am very new to haskell. For my first program I am trying to implement an hashing function of sorts as specified here: http://freecnc.org/dev/mix-format/
21:27:32 <jaskamiin> and you'd reccommend lyah to learn?
21:27:58 <ivanm> stepcut: *nod* though how much of the underlying principles are reminicsent of Haskell from the 0.1 days?
21:27:59 <stepcut> ivanm: do you have examples of specific techniques and methodology that you think is 'out of date' ?
21:28:05 <afshar> stepcut: oh I see now, it was all those  input ! type_ "text" ! A.id "msg" ! name "msg"
21:28:11 <afshar> I just balked at that
21:28:13 <Sonarpulse> does anybody have any experience working with binary data and haskell?
21:28:17 <ivanm> jaskamiin: LYAH is meant to be pretty good (my brother still has my copy so I've never read it)
21:28:25 <Clint> Sonarpulse: sure
21:28:27 <stepcut> afshar: ah.. that is just blaze-html, which is pure haskel.. I prefer HSP myself as it looks like HTML and is easier to read
21:28:27 <ivanm> stepcut: nope; I'm just pondering aloud :)
21:28:31 <afshar> stepcut: so really I was not being fair, because I am sure you can totally live without that
21:28:58 <lispy> Sonarpulse: binary and cereal are both good packages for parsing binary data (you can get them on hackage)
21:29:02 <Sonarpulse> Clint: cool, I guess my first question is rotating. I've looked up Data.Word and Data.Bit
21:29:17 <lispy> oh, maybe I misunderstood what you meant by binary
21:29:33 <stepcut> ivanm: well.. a lot has changed, and that which hasn't is pretty darn similar to what is in snap and yesod..
21:29:40 <afshar> saddest thing here is that whatever framework I use, most of the app will still be javascript :)
21:29:43 <ivanm> stepcut: fair enough :)
21:29:45 <Sonarpulse> Perhaps this is a mistake, but I first wanna do things a bit more "manually"
21:29:55 <stepcut> afshar: not if you use fay
21:29:58 <ivanm> stepcut: I don't want to touch web dev, or anything else dealing with UIs :p
21:29:59 <Sonarpulse> then try some of the binary parsing packages
21:30:08 * afshar looks up fay
21:30:23 <ivanm> afshar: Michael Snoyman just wrote a blog post about using Fay in Yesod
21:30:26 <stepcut> afshar: fay-lang.org and #fay
21:30:37 <Sonarpulse> basically I am trying to implement a tar like format -- I choose haskell because i wanted to learn it and needed an excuse, and because it seems like inbuilt lazy would make this much more efficient
21:31:03 <afshar> wow, that looks amazin. As long as it has ways to talk to third-party libraries and actual js, that would be cool
21:31:15 * stepcut is going to post about happstack+acid-state+fay really soon now
21:31:15 <ivanm> Sonarpulse: binary and cereal are good if you know bit by bit what's what
21:31:25 <ivanm> if you need more parsing control, see attoparsec
21:31:30 <afshar> +acid -state :)
21:31:39 <AfC> heh
21:31:41 <ivanm> heh
21:31:44 <Sonarpulse> this is a pretty simple format, so i guess i will use binary or cereal
21:31:49 <Sonarpulse> which would you reccomend?
21:32:03 <ivanm> binary is older; cereal is a strict fork
21:32:09 <lispy> still in the stage1 of ghc...
21:32:10 <ivanm> but binary is improving
21:32:18 <ivanm> lispy: :o how slow is this machine?
21:32:42 <stepcut> oddly, despite all the development, yesod does very little that happstack did not already do when yesod was started :-l
21:33:17 <ivanm> stepcut: oh? what can happstack do that yesod doesn't?
21:33:23 <lispy> ivanm: it's a virtual machine. It's not meant to be fast :)
21:33:31 <ivanm> ahhhh
21:33:40 <ivanm> you can't just use a pre-built GHC binary?
21:33:47 <Sonarpulse> well I guess I already imported a conponent of Binary, and I want laziness so I will stick with that
21:33:58 <lispy> ivanm: nope, they all assume eventfd
21:34:09 <lispy> ivanm: Someday I will upgrade the OS :)
21:34:11 <ivanm> lispy: I have nfi what eventfd is :)
21:34:23 <stepcut> ivanm: in general, it is more flexible and built around extensible combinators instead of limited, custom template haskell syntaxes
21:34:25 <lispy> ivanm: same here actually, but I infer that it is syscall related
21:34:40 <ivanm> Sonarpulse: there's also binary-bits, which if your use-case supports it is a bit faster (it integrates with binary)
21:35:02 <ivanm> stepcut: so it doesn't support it because they chose to take a different route?
21:35:06 <stepcut> on the surface, they are very similar.. you have to dig down deeper to see the differences in design philosophies and how that plays out
21:36:02 <lispy> Sonarpulse: BTW, you could use Data.ByteString.Word8 (or whatever it's called) to get a stream of bytes from a file and twiddle away on it
21:36:10 <stepcut> ivanm: yes.. if you look at yesod, they offer exactly one form of type safe url routing, which requires that you use their QQ system for routing. web-routes, used by happstack, supports a number of methods such as boomerang, TH, generics, and if you like, the yesod-style qq stuff
21:36:17 <lispy> Sonarpulse: Then realize it's madness to do so without nice absractions :)
21:36:34 <ivanm> stepcut: I thought Yesod also allowed you to use different approaches, they just don't always integrate as well
21:36:57 <Jafet> Data.ByteString.Lazy
21:37:02 <stepcut> with something like boomerang, you get extensible combinators.. so you can, for example, define a combinator that parses a route like, year/mm/dd, and easily reuse that. In yesod, it is not so pretty
21:37:26 <Sonarpulse> binary-bits seems to be a very barebones, yet unintrusive stuff on top
21:37:43 <ivanm> yup
21:38:01 <Sonarpulse> for just making the ideas I'll just need a plain old function, so I can put off all those monadic considerations
21:38:19 <stepcut> ivanm: perhaps.. but you are in no mans land, with no documentation or support. In Happstack we actually document and support the various methods
21:38:21 <Sonarpulse> But when I actually want to compose the rest of the mix efficiently I guess I will return to that
21:38:32 <ivanm> stepcut: every single possible option? :p
21:38:43 <ivanm> or just how to use generic types to integrate other methods in
21:39:22 <stepcut> ivanm: no. But a good selection of different options that meet different needs. And we try to make sure it is easy to do your own thing of none of those are right.
21:40:39 <Sonarpulse> hmm, http://www.haskell.org/haskellwiki/DealingWithBinaryData#Simple_file_IO mentions things like `shiftL`
21:40:52 <Sonarpulse> are the backticks for infix notatino or something?
21:40:59 <ivanm> yes
21:41:02 <ivanm> > 5 `mod` 2
21:41:04 <lispy> stepcut: do you know how snap/yesod/happstack compare performancewise?
21:41:05 <lambdabot>   1
21:41:10 <ivanm> > mod 5 2
21:41:11 <lambdabot>   1
21:41:11 <Sonarpulse> thanks
21:43:15 <stepcut> lispy: pretty darn close in the limited benchmarks that exist today. snap and happstack are pretty much on par. Yesod is maybe 2x faster. Though, the happstack backend is currently being rewritten using pipes. Our experiments with acme-http were much faster than any current implementation… though we will not be able to retain all the speed when we include timeout handling code
21:44:25 <lispy> Sonarpulse: you should checkout this png parser I got from the haskell wiki as an example of bit twiddling: https://github.com/dagit/haray/blob/c351a5f171a1c6f62b88ca4a385f9149d58915a4/src/Graphics/Rendering/Haray/PNG.hs
21:45:18 <stepcut> one reason that happstack is not limited by being old is that we add new features via new, independent libraries. So, for example, when we wanted to add type-safe routing (which we did before yesod existed), we created a new library (web-routes) that you can used with happstack (or snap or yesod). And for type-safe form processing, we created reform (which is also backend independent).
21:45:37 <Sonarpulse> another basic question
21:45:53 <Sonarpulse> for somethign like "func a b c"
21:46:05 <beaky> are monads like design patterns?
21:46:06 <Sonarpulse> is the currinh mean the rightmost is the first argument?
21:46:10 <lispy> stepcut: cool. I've only tried snap. I was under the impression no one uses happstack anymore. Good to hear that it's still doing well.
21:46:20 <ivanm> lispy: as much as I'm trying to avoid it, maybe the solution is that I need to bring in Vector solely for the conversion, as all the examples nowadays seem to use that :s
21:46:32 <ivanm> Sonarpulse: sorry, can you re-phrase that?
21:46:33 <Sonarpulse> beaky: http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
21:46:36 <lispy> beaky: not really no
21:46:49 <stepcut> lispy: people do use it, and submit patches too :) It is under active development (as in, work being done on a nearly daily basis)
21:47:05 <statusfailed> Is there a good way to handle dealing with very small binary fields? (2 - 4 bits)
21:47:06 <Sonarpulse> ivanm, I thought I learned that in haskell, all functions  just take one argument so that you use currying instead
21:47:10 <ivanm> well, hackage uses happstack... ;)
21:47:12 <statusfailed> dealing with as in storing in a data struture
21:47:13 <stepcut> obviously, we should talk about what is going on with happstack more often :)
21:47:22 <statusfailed> I was considering lenses and bit twiddling, but seems like overkill
21:47:22 <ivanm> Sonarpulse: not quite
21:47:38 <ivanm> Sonarpulse: let's take mod as an example
21:47:39 <ivanm> @type mod
21:47:41 <lambdabot> forall a. (Integral a) => a -> a -> a
21:47:57 <Sonarpulse> ok
21:48:08 <ivanm> Sonarpulse: ^^ you can read that as mod is a function that takes an `a', and returns a function of type (a -> a) [where a is an instance of Integral]
21:48:21 <ivanm> that's what's meant by "Haskell functions only take one argument"
21:48:22 <lispy> stepcut: Doesn't look like anyone has worked on it since before April: https://github.com/silkapp/happstack/graphs/contributors
21:48:29 <ivanm> so, "mod 5" is a function
21:48:31 <ivanm> @type mod 5
21:48:32 <lambdabot> forall t. (Integral t) => t -> t
21:48:39 <Sonarpulse> yeah, isn't that currying?
21:48:53 <stepcut> lispy: that is silks fork of happstack, happstack is maintained in darcs
21:48:58 * ivanm suddenly flashes back to a previous discussion about this...
21:49:00 <lispy> ivanm: I thought hackage2 uses happstack, not hackage as we know it
21:49:02 <ivanm> Sonarpulse: ... maybe? ;)
21:49:14 <ivanm> Sonarpulse: it's usually referred to as "partial application"
21:49:16 <lispy> stepcut: ah
21:49:19 <ivanm> lispy: ahhhh
21:49:25 <stepcut> yeah, hackage2 uses happstack, hackage1 is perl or something awful
21:49:28 <ivanm> lispy: what does hackage1 use?
21:49:42 <ivanm> stepcut: so it's a wonder it doesn't crash more often? :p
21:49:50 <Sonarpulse> ok :)
21:50:40 <Sonarpulse> is there anything like @rotate for ghci?
21:50:43 <lispy> stepcut: I bet it would help with happstack's visibility if you folks had an active mirror on github
21:50:50 <ivanm> Sonarpulse: what's @rotate?
21:50:55 <ivanm> @help rotate
21:50:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:50:56 <Sonarpulse> sorry, meant @type
21:50:59 <ivanm> ahhh
21:51:00 <ivanm> Sonarpulse: :type
21:51:03 <ivanm> :type mod 5
21:51:13 <Sonarpulse> oh good
21:51:16 <lispy> You can shorten to :t
21:51:19 <lispy> :t mod 5
21:51:20 <lambdabot> forall t. (Integral t) => t -> t
21:51:22 <Sonarpulse> even better
21:51:27 <stepcut> lispy: possibly. I am hoping darcs-bridge gets up to snuff soon. Or that hub.darcs.net gets more popular :)
21:51:31 <ivanm> OK, looks like lambdabot only knows the short version...
21:52:00 <lispy> ivanm: yeah, dons added :t as a hack. It has to be exactly ":t" and it only works in channels not /msg
21:52:01 <Sonarpulse> but if the type signiture is left to right, application is right to left?
21:52:20 <lispy> Sonarpulse: close. You have the orders reversed
21:52:31 <lispy> a -> b -> c = a -> (b -> c)
21:52:52 <ivanm> func a b c = ((func a) b) c
21:53:17 <spckd> How to declare a function that takes [a] a d returns nothing?
21:53:29 <Sonarpulse> ok
21:53:33 <Iceland_jack> Returns nothing?
21:53:38 <ivanm> spckd: all functions have to return _something_
21:53:38 <Sonarpulse> parens help ;D
21:53:41 <ivanm> even if it's just ()
21:53:48 <lispy> @djinn [a] -> a -> d -> ()
21:53:48 <lambdabot> Error: Undefined type []
21:53:52 <lispy> @djinn [a] -> a -> d -> Maybe ()
21:53:52 <lambdabot> Error: Undefined type []
21:53:57 <lispy> oh, right no lists
21:54:01 <rwbarton> i think 'a d' was a typo for 'and'
21:54:02 <spckd> what is ()?
21:54:06 <startling> Maybe () ?
21:54:10 <startling> isn't that just Bool?
21:54:10 <randomclown> spckd: empty tuple
21:54:15 <otters> :i ()
21:54:16 <ivanm> unless you're trying to use seq or something, anything of type "a -> ()" is rather useless
21:54:45 <ivanm> @src ()
21:54:45 <lambdabot> data () = ()
21:54:45 <spckd> Right
21:54:45 <ivanm> spckd: unless you're wanting side-effects, in which case it's probably IO ()
21:54:45 <lispy> startling: pretty much. I was confused about the error message
21:54:46 <ivanm> @djinn a -> ()
21:54:47 <lambdabot> f _ = ()
21:54:52 <ivanm> @djinn a -> b -> ()
21:54:52 <lambdabot> f _ _ = ()
21:55:24 <startling> lispy: oh, right
21:55:33 * lispy has a vague recollection of djinn not supporting recursive types like list
21:55:54 <Nereid> spckd: what is it you really want to do?
21:56:34 <Iceland_jack> (↑ correct question)
21:57:10 <ivanm> lispy: this might explain why I kept having memory issues :s http://hackage.haskell.org/trac/ghc/ticket/2917
21:58:35 <Sonarpulse> ok, getting the hang of it (I'ved used type inference  before too, thank goodness)
21:58:57 <lispy> ivanm: hmm
21:58:59 <beaky> how
21:59:00 <Sonarpulse> but it seems like :t and the type signutures you would right in your code are quite different
21:59:06 <lispy> ivanm: does that bug cause crashes or just waited memory?
21:59:12 <ivanm> not sure
21:59:16 <ivanm> it's a bit technical for me :p
21:59:17 <beaky> how do you define the y combinator in haskell
21:59:48 <ivanm> beaky: you can't
21:59:51 <ivanm> the closest is fix
21:59:52 <ivanm> @src fix
21:59:52 <lambdabot> fix f = let x = f x in x
22:00:09 <ivanm> IIRC, the type for the Y combinator isn't expressible in Haskell
22:00:31 <beaky> > let y f x = f (y f x) in y (+1) 3
22:00:34 <lambdabot>   *Exception: stack overflow
22:00:51 <ivanm> @type let y f x = f (y f x) in y
22:00:56 <spckd> Nereid: nothing in particular. I was curious how it would be declared. So there is no void equivalent
22:00:56 <lambdabot> forall t t1. (t -> t) -> t1 -> t
22:01:10 <Nereid> spckd: the equivalent of C's void is ()
22:01:12 <ivanm> ^^ it ignores the `x'
22:01:19 <Nereid> the type () has just one value, namely ()
22:01:21 <Nereid> :t ()
22:01:23 <lambdabot> ()
22:01:33 <ivanm> spckd: well, in C you use void when your method has side-effects, right?
22:01:40 <ivanm> so the moral Haskell equivalent would be IO ()
22:01:44 <Nereid> but as noted above, any function of type a -> () is worthless
22:01:50 <Nereid> because it can't have side effects
22:01:51 <beaky> lol
22:02:47 <Nereid> yes, an IO value of type IO () represents "do some stuff, and provide no information for a return value"
22:03:52 <spckd> yeah i see. That seems to be what main returns too
22:04:20 <Nereid> spckd: there is also a type Void (from Data.Void) with *no* values (so there are no total functions of type a -> Void if a is a nonempty type)
22:04:57 <Nereid> it's not useful directly, but it can make sense to have Void as an argument to some other type constructors.
22:05:12 <Nereid> e.g. IO Void could represent an IO action that never terminates
22:05:19 <Nereid> Either Void a is isomorphic to a
22:05:20 <Nereid> etc.
22:05:43 <Nereid> but don't get it confused with ()
22:07:07 <Nereid> (often, () is called the unit type)
22:08:59 <lispy> Either Void a ~ a? to (Left _) = undefined; to (Right a) = a; from a = Right a
22:09:05 <lispy> ?
22:09:09 <lispy> That what you had in mind?
22:09:24 <Nereid> lispy: you don't even have to handle the Left case
22:09:29 <Nereid> because there are no values of the form Left _
22:09:57 <Nereid> so, this is sufficient: to (Right a) = a
22:10:58 <Nereid> hm
22:11:10 <liyang> Void is 0, () is 1. Either is +, (,) is *.
22:11:23 <Nereid> as another example, a conduit/pipe/whatever whose output type is Void represents a pipe that is only open on the input end.
22:12:04 <lispy> liyang: I've seen people refer to [a] as 1 + X. Is that using different assumptions?
22:12:16 <Nereid> no, that's just wrong
22:12:21 <Nereid> [a] = 1 + a*[a]
22:12:24 <Nereid> = 1 + a + a^2 + ...
22:12:43 <Jafet> = 1/(1-a)
22:12:45 <nyc> 1/(1-a)
22:12:45 <lambdabot> nyc: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:13:05 <Nereid> I intentionally didn't go there.
22:13:11 <shachaf> lispy: Maybe X = 1 + X
22:13:13 <Nereid> I'm not sure what 1-a is or what dividing by it means.
22:13:20 <Nereid> ah yes, that's true of Maybe.
22:13:23 <Nereid> so Maybe Void ~ ()
22:13:28 * edwardk waves hello.
22:13:31 <shachaf> hedwardk
22:13:34 <lispy> oh, so maybe I misremembered the example
22:13:39 <nyc> \mu t . 1 + t
22:13:42 <edwardk> haichaf
22:13:51 <Nereid> and [Void] ~ () too.
22:13:51 <otters> @src ap
22:13:52 <lambdabot> ap = liftM2 id
22:13:57 <shachaf> edwardk: So is there a way to make filtered be a thing you compose, rather than something that takes a lens?
22:13:59 <nyc> \mu is oft forgotten.
22:14:01 <lispy> if you substitute x for [a], you'd have x = 1 a*x
22:14:03 <ivanm> hey edwardk
22:14:17 <shachaf> That would sure be nice.
22:14:21 <edwardk> shachaf: hrmm, quite possibly
22:14:32 <shachaf> s/lens/traversal/
22:14:38 <edwardk> yep
22:14:44 <edwardk> i see where you are going with it
22:14:49 <edwardk> its not hard to write
22:15:10 <shachaf> OK, I was wondering if you'd already thought about it and decided it was impossible or something. :-)
22:15:23 <edwardk> filtered p f a | p a = f a; | otherwise = pure a
22:15:36 <edwardk> no, hadn't considered it properly
22:15:41 <edwardk> i'm willing to flip over
22:15:47 <edwardk> its nicer this way
22:16:07 <shachaf> λ> toListOf (both.traverse.filt isUpper) ("why HELLO there","to YOU")
22:16:07 <shachaf> "HELLOYOU"
22:16:21 <shachaf> I think that style should be added.
22:17:04 <beaky> I like the lo bost
22:17:07 <lispy> shachaf: you don't care what module you're in?
22:17:12 <beaky> blog post* about monads
22:17:30 <lispy> beaky: did you get the links I pasted earlier?
22:17:37 <Jafet> There is... more than one blog post about monads.
22:17:39 <beaky> yes
22:17:41 <lispy> beaky: all about monads and the step by step monad transformer paper?
22:18:00 <shachaf> lispy: Prelude Control.Applicative Control.Monad Control.Monad.Instances Data.Char Data.Function Data.List Data.Maybe Data.Monoid Data.String Data.Either Data.Bits System.IO System.Environment Text.Printf Unsafe.Coerce System.IO.Unsafe Control.Concurrent Network.Socket Control.Monad.Identity Control.Monad.Cont System.Process System.Exit Control.Concurrent.STM Control.Concurrent.STM.TVar Foreign System.Directory GHC.Exts Data.Ix Data.IORef ...
22:18:00 <lispy> beaky: those were my favorites when I was young and less naive
22:18:06 <startling> is ask >>= tell somewhere?
22:18:06 <shachaf> ... GHC.Conc.Sync Data.Ord Debug.Trace System.Mem System.FilePath Data.Time Data.Time.Clock Data.Time.Clock.POSIX Data.Typeable Data.Data System.Random Foreign.C.Types System.Posix.IO System.Posix.Types Network Data.Generics Foreign.C.String Control.Monad.ST Control.Parallel.Strategies Text.Groom Control.Concurrent.Spawn Control.Monad.Loops GHC.Word Data.Dynamic System.Mem.StableName GHC.Prim Numeric Control.Lens Control.DeepSeq ...
22:18:11 <shachaf> ... Data.Number.CReal Data.Void Data.Functor.Contravariant GHC.Types GHC.IO System.Timeout Text.Read Data.List.Split GHC.TypeLits Data.Complex Control.Spoon Data.Tuple Control.Exception Data.Ratio LB8 SB8 LB SB T TL TE M S IM Control.Arrow State Reader Writer Fol Tra QC>
22:18:12 <startling> @hoogle ask >>= tell
22:18:12 <lambdabot> Warning: Unknown type >>=
22:18:13 <lambdabot> Control.Applicative unwrapArrow :: WrappedArrow a b c -> a b c
22:18:13 <lambdabot> Data.Graph.Inductive.Graph empty :: Graph gr => gr a b
22:18:16 <edwardk> i can make filtered have the more general signature that will allow it to be used with a traversal as well. just stating in the signature that the composition with it and a traversal isn't a legal traversal
22:18:20 <lispy> shachaf: ;)
22:18:57 <shachaf> edwardk: Hmm?
22:19:06 <shachaf> You mean the existing filtered?
22:19:11 <edwardk> shachaf: yeah
22:19:19 <edwardk> well, i mean that i can make
22:19:35 <Sonarpulse> ok, new question: how can I add two different Word Sizes?
22:19:47 <edwardk> filtered :: Applicative f => (a -> Bool) -> (a -> f a) -> s -> f s
22:19:56 <edwardk> but only state that it is a valid fold
22:20:00 <Nereid> Sonarpulse: like adding a Word16 value with a Word32 value? first convert one to the other's type
22:20:05 <Nereid> with, say, fromIntegral
22:20:06 <shachaf> It's not a valid traversal?
22:20:09 <edwardk> nope
22:20:31 <edwardk> if the predicate changes from true to false, then subsequent traversals miss the elemnet, so traversal fusion fails
22:20:39 <nyc> I've still NFI about lenses.
22:20:45 <beaky> what is the origin of the "a monad is a burrito" analogy?
22:20:53 <beaky> that everyone is making fun of? :D
22:21:01 <PatrickRobotham> beaky: A satirical example written by Brent Yorgey.
22:21:04 <Nereid> beaky: originally http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
22:21:12 <beaky> ah
22:21:16 <Sonarpulse> thanks
22:21:30 <startling> nyc, they're just functional getter/setter pairs
22:21:35 <donri> (which however is a good read)
22:21:54 <startling> `lens` writes them as functions with typeclass constraints, but you don't need to worry about that.
22:22:47 <Nereid> nyc: a basic Lens might look like
22:23:21 <Nereid> data Lens a b = Lens { get :: a -> b, set :: b -> a -> b }
22:23:34 <nyc> startling: The confusing bit about the setter part is whether it's a setting monad or not.
22:23:41 <shachaf> data Lens s t a b = Lens { get :: s -> a, set :: b -> s -> t }
22:23:48 <shachaf> nyc: No monads involved.
22:23:58 <Nereid> sure, for polymorphic ones.
22:24:01 <startling> nyc, setting monad? it's just a b -> a -> b type function; it doesn't modify anything
22:24:02 <nyc> startling: Like MonadRWST or sme such.
22:24:19 <johnw> also, the getter/setter is fused in some lens libraries
22:24:36 <shachaf> getter/setter? I don't even know 'er!
22:24:39 <startling> nyc: right. no, it just returns a new version of x with the lens'd field changed
22:24:49 <edwardk> fused they look like s -> (a, b -> t)
22:25:01 <startling> nyc, you can use them in reader, writer, and state though
22:25:07 <edwardk> where commonly a = b, s = t
22:25:14 <Sonarpulse> thanks, again. Wow, that is much easier than converting to a bitvector or something
22:25:55 <startling> > fromIntegral 256 :: Word8
22:25:59 <lambdabot>   0
22:26:12 <startling> Sonarpulse: ^ just watch out for things like that
22:26:31 <shachaf> I,I @let fromIntegral = differentiate
22:26:37 <Nereid> startling: that shouldn't surprise anyone though
22:26:52 <otters> lol
22:27:22 <startling> Nereid: it's slightly easier to accidentally fromIntegral to a smaller type, though
22:27:31 <Nereid> true
22:27:40 <Nereid> so if you have x :: Word8 and y :: Word16
22:27:56 <Nereid> you probably want (fromIntegral x + y :: Word16
22:28:01 <Nereid> )
22:28:16 <Nereid> as opposed to x + fromIntegral y, which is a Word8
22:29:18 <shachaf> edwardk: What's an example of it being invalid?
22:29:58 * hackagebot timeplot 1.0.16 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.16 (EugeneKirpichov)
22:30:19 <edwardk> shachaf: evens = filtered even; over evens succ . over evens succ /= over evens (succ . succ)
22:30:20 <beaky> :t (<*>)
22:30:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
22:30:34 <beaky> :t (<$>)
22:30:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:30:43 <Nereid> (<$>) = fmap
22:31:05 <Nereid> (for lawful applicative instances, anyway)
22:31:52 <shachaf> edwardk: Oh, I see what you mean.
22:31:53 <shachaf> Right. :-(
22:32:33 <edwardk> the domain of the traversal is only things where the predicate STILL holds after it is edited
22:32:44 <edwardk> e.g. with evens, you can (+2) all you want
22:33:12 <shachaf> Yes, it has to stay the same shape.
22:33:42 <beaky> > [(+1), (+2)] <*> [1..3]
22:33:44 <lambdabot>   [2,3,4,3,4,5]
22:33:50 <Sonarpulse> is there fold in Haskell?
22:33:56 <johnw> edwardk: is there a category within Hask where the objects are values and the morphism are transformations from one value to another?
22:34:02 <Nereid> > foldr (+) 0 [a,b,c,d]
22:34:04 <lambdabot>   a + (b + (c + (d + 0)))
22:34:12 <shachaf> edwardk: Is there something like a traversal but a bit more relaxed that would allow that?
22:34:12 <Sonarpulse> yea!
22:34:18 <Jafet> :t (foldr, foldl, foldr1, foldl1, foldl', foldM, foldMap)
22:34:20 <lambdabot> Not in scope: `foldMap'
22:34:22 <beaky> > foldr (+) 0 [a,b,c,d]
22:34:24 <lambdabot>   a + (b + (c + (d + 0)))
22:34:30 <Nereid> > foldl (+) 0 [a,b,c,d]
22:34:31 <lambdabot>   0 + a + b + c + d
22:34:34 <Nereid> heh.
22:34:48 <beaky> whats the difference between foldl and foldr?
22:34:58 <Nereid> a lot
22:34:58 <Jafet> http://foldr.com http://foldl.com
22:34:59 * hackagebot network-data 0.4 - Library for network data structures (ex: ethernet/ip/udp/tcp headers and helper functions)  http://hackage.haskell.org/package/network-data-0.4 (ThomasDuBuisson)
22:35:05 <johnw> beaky: left-associative vs. right-associative
22:35:07 <beaky> ah
22:35:08 <shachaf> > foldr (-) 0 [a,b,c,d]
22:35:10 <lambdabot>   a - (b - (c - (d - 0)))
22:35:11 <shachaf> > foldl (-) 0 [a,b,c,d]
22:35:12 <lambdabot>   0 - a - b - c - d
22:35:21 <beaky> why is foldr a catamorphism, while foldl isn't?
22:35:25 <Nereid> > foldl (==) True [a,b,c,d]
22:35:25 <edwardk> johnw: 'sorta'. watch http://www.youtube.com/watch?v=wJIpI0Fj6Hg  David uses a construction that is what you just stated more or less
22:35:26 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
22:35:27 <lambdabot>         against inferred type ...
22:35:28 <Nereid> hm
22:35:34 <Nereid> > foldl (<) z [a,b,c,d]
22:35:35 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
22:35:35 <lambdabot>         against inferred type ...
22:35:37 <Nereid> silly.
22:36:01 <Nereid> @where fold
22:36:01 <lambdabot> I know nothing about fold.
22:36:04 <Nereid> @where foldr
22:36:04 <lambdabot> I know nothing about foldr.
22:36:06 <Nereid> come on.
22:36:07 <Nereid> http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl%27
22:36:33 <beaky> > foldl' (*) 0 [1..1000]
22:36:34 <lambdabot>   0
22:36:41 <beaky> > foldl' (*) 1 [1..1000]
22:36:43 <lambdabot>   402387260077093773543702433923003985719374864210714632543799910429938512398...
22:37:49 <edwardk> johnw: The construction he uses (starting in the second video) is called the Grothendieck construction: http://en.wikipedia.org/wiki/Grothendieck_construction
22:38:27 <johnw> beaky: it's probably not called a catamorphism in Haskell because unless you use foldl', foldl will build a data structure of equal size to represent your calculation before reducing it, whereas foldr is reduced "as you go"
22:38:28 <edwardk> shachaf: i don't package up lawless versions of my types
22:38:46 <edwardk> shachaf: you can use the weaker filtered i just built as a fake traversal and the combinators won't stop you
22:38:53 <johnw> but that all depends a lot on which function are folding with
22:39:00 <shachaf> edwardk: I mean a sensible set of laws that would allow it.
22:39:07 <edwardk> but you can't reason about them sanely
22:39:09 <shachaf> But, really, that law is a pretty important one to have.
22:39:28 <Sonarpulse> Ok, now for the kicker, I need to convert a string to [word32], so that 0s are added to string untill it's length is a interger multiple of 32bits
22:39:39 <johnw> beaky: in the case of (+), it's more of a homomorphism followed by a catamorphism
22:39:57 <Nereid> Sonarpulse: but Char is a unicode character.
22:40:02 <edwardk> without that you just have a crappy free theorem and the identity law
22:40:38 <shachaf> Right.
22:40:47 <Nereid> Sonarpulse: which takes up more than 16 bits.
22:40:48 <Sonarpulse> Neried, well yes then I need to convert it to ascii first, and either single an error or make a hanlder per failing character
22:40:59 <Sonarpulse> *Nereid
22:41:46 <Nereid> ok, so say you've got a list of Word8s, then.
22:42:22 <csigusz> hmm,  I think I should give up on trying to learn natural languages and just try to learn new programming languages, much easier to pick up :p
22:43:00 <Sonarpulse> hmm?
22:43:18 <Sonarpulse> yess if lets say I have 5 Word8s
22:43:18 <beaky> wouldnt it be cool if we could compile natural language into machine code?
22:43:31 <Nereid> sorry, gotta go
22:43:40 <Sonarpulse> then I need to "round" that to 8 word8s
22:44:36 <Sonarpulse> in case you were wondering, I don't hate unicode, I am just trying to implement http://freecnc.org/dev/mix-format/ http://xhp.xwis.net/documents/MIX_Format.html
22:44:44 <csigusz> natural languages are too irregular and require the development of reading/writing + listening/speaking, whereas with a programming language it is only reading and writing...
22:44:45 <Sonarpulse> thanks! cya
22:44:50 <csigusz> the winner: programming languages
22:44:55 <Jafet> beaky: do it then
22:45:02 <otters> surely Haskell has multiline strings
22:45:21 <shachaf> It has multi(line strings)
22:45:26 <shachaf> That's something, right?
22:46:05 <nyc> Backslashes are magical in Haskell string literals.
22:47:36 <shachaf> Yes, you can use \s.
22:59:59 * hackagebot aws-sdk 0.5.0.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.5.0.0 (YusukeNomura)
23:03:03 <edwardk> shachaf: ok, a 3.1 release candidate is on github
23:04:22 <shachaf> Why "ing" for the indexed version?
23:05:14 <Sonarpulse> Does anybody know why "filename2id a = foldl rotsum (map fromIntegral (map ord a))" has the type of a two-argument function?
23:05:25 <Sonarpulse> rotsum a b = a + (b `rotateL` 1)
23:05:41 <shachaf> Sonarpulse: It takes an initial value forthe accumulator.
23:05:48 <shachaf> Just look at the type of foldl.
23:05:51 <shachaf> @ty foldl
23:05:52 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:05:53 <Sonarpulse> oh yeah, duh
23:05:57 <shachaf> Oh, wait.
23:06:00 <edwardk> it doesn't match the usage convention of filtered. and takingWhile, droppingWhile indicate using the gerund that they are parameterized on another lens/traversal/etc
23:06:04 <shachaf> No, I'm wrong.
23:06:08 <edwardk> so it fits their naming convention
23:06:39 <Sonarpulse> well foldl needs a 3rd argument
23:06:43 <shachaf> edwardk: Is there a version of filtering that lets you filter only on the index?
23:06:47 <shachaf> Presumably that would preserve the laws.
23:06:51 <edwardk> shachaf: iwhereOf
23:07:03 <shachaf> Oh, right.
23:07:23 <edwardk> i thought about elementsOf, but that meant the version for traversableWithIndex would be 'elements' and that is too common a name to take
23:07:41 <edwardk> at least that was my original motivation for the less intuitive name
23:08:21 <Sonarpulse> filename2id a = foldl rotsum 0 (map fromIntegral (map ord a))
23:08:25 <Sonarpulse> oh good that words
23:09:00 <edwardk> filename2id = foldl rotsum 0 . map (fromIntegral . ord)
23:09:18 <edwardk> then you can fuse the fromIntegral . ord into the foldl argument
23:09:19 <shachaf> Can droppingWhile be a traversal or does it have the same issue?
23:09:23 <shachaf> Or maybe drop?
23:09:28 <Sonarpulse> aha!
23:09:30 <edwardk> same problem
23:09:34 <Sonarpulse> learn new syntax everyday
23:09:48 <edwardk> :t (Prelude..)
23:09:49 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
23:09:50 <shachaf> This library has too many names to keep in my short-term memory. :-(
23:09:57 <edwardk> shachaf: =)
23:10:17 <edwardk> you can make one that takes the first n elements of the a traveral
23:10:29 <lispy> (b -> c) -> (a -> b) -> (a -> c) -- you really have to add the last parens to see the elegance of that type
23:10:36 <shachaf> Is that in the library?
23:11:07 <edwardk> i had _thought_ i had taking and dropping, but i guess i don't
23:11:33 <shachaf> You could also have a "splitAt" that applies two diffrent traversals to the two sections, or something like that.
23:11:40 <shachaf> I'm not sure how useful that would be. :-)
23:12:07 <edwardk> =P
23:12:25 <lispy> there are so many things on hackage
23:12:46 <Sonarpulse>  
23:12:46 <Sonarpulse> <shachaf> You could also have a "splitAt" that applies two diffrent traversals
23:12:46 <Sonarpulse> 	  to the two sections, or something like that.
23:12:46 <Sonarpulse> <shachaf> I'm not sure how useful that would be. :-)
23:12:49 <Sonarpulse> <edwardk> =P
23:12:53 <Sonarpulse> <lispy> there are so many things on hackage  [02:12]
23:12:56 <Sonarpulse> ERC> what exactly does . do?
23:12:59 <Sonarpulse> whoops
23:13:01 <Sonarpulse> oh emacs/erc...
23:13:42 <lispy> Sonarpulse: . is function composition
23:14:00 <lispy> > (head . tail) [1..3]
23:14:03 <lambdabot>   mueval-core: Time limit exceeded
23:14:08 <lispy> > (head . tail) [1..3]
23:14:10 <lambdabot>   2
23:14:48 <Sonarpulse> how does that compare to $ ?
23:14:56 <lispy> Cale: <sigh> I can't build ghc-7.4
23:15:05 <lispy> Sonarpulse: ($) is function application
23:15:10 <shachaf> lispy: Why would you build 7.4?
23:15:12 <shachaf> Get the binary.
23:15:24 <lispy> shachaf: I can't. Both of them need eventfd
23:15:29 <Cale> http://www.youtube.com/watch?v=cw5_JLFI0HQ -- this is a great intro to higher category theory for people interested in it
23:15:30 <lispy> shachaf: same with 7.6
23:15:34 <shachaf> lispy: ?
23:15:36 <Sonarpulse> so . is vaguely like a higher order $ ?
23:15:45 <lispy> Sonarpulse: nope.
23:15:59 <lispy> (f . g) x = f (g x)
23:16:10 <lispy> Sonarpulse: ($) = id
23:16:24 <Sonarpulse> oh yeah
23:16:29 <shachaf> lispy: Why would you confuse a poor person with ($) = id?
23:16:54 <Sonarpulse> (f . g) x = f $ g $ x
23:16:55 <Sonarpulse> ?
23:17:04 <Sonarpulse> or at least f $ g x
23:17:04 <lispy> Sonarpulse: yeah :)
23:17:06 <shachaf> Sonarpulse: Don't be gross.
23:17:07 <marzy> f $ g x
23:17:11 <shachaf> f (g x)
23:17:26 <Cale> Sonarpulse: that's true, but only because $ associates to the right, which is probably the wrong thing for it to really do
23:17:27 <lispy> f `id` g x
23:17:34 <Cale> (the f $ g $ x one)
23:17:51 <Cale> (f . g) x = f (g x)
23:17:54 <Cale> and f $ x = f x
23:17:55 <lispy> :t zipWith ($)
23:17:57 <lambdabot> forall b b1. [b -> b1] -> [b] -> [b1]
23:17:57 <shachaf> Cale: Do you have a /hilight on any line on IRC that has more than one $ in it?
23:18:00 <lispy> :t zipWith (.)
23:18:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => [a -> b] -> [f a] -> [f b]
23:18:02 <Cale> shachaf: lol
23:18:09 <Sonarpulse> hmm
23:18:11 <lispy> :t zipWith (Prelude..)
23:18:12 <lambdabot> forall b c a. [b -> c] -> [a -> b] -> [a -> c]
23:18:29 <Cale> shachaf: I was trying to post a video about higher category theory, and I am barraged with $'s
23:19:07 <lispy> Cale: sad face about ghc
23:19:15 <Cale> lispy: yeah, weird
23:19:20 <Cale> lispy: what architecture?
23:19:20 <shachaf> Cale: Higher category theory? Where instead of having left adjoint somewhere, they left several?
23:19:21 <lispy> Cale: I guess I'm forced to upgrade something. But what? The kernel?
23:19:32 <lispy> debian x86_64
23:19:37 * yitz $ rebinds $ the $ space $ bar $ on $ his $ keyboard
23:19:42 <Cale> shachaf: Where do you *get* these things?
23:19:45 <Cale> lol
23:19:51 <shachaf> Cale: ?
23:19:55 <shachaf> lispy: Why can't you get the binary again?
23:19:59 <shachaf> It works for me on Debian.
23:20:18 <lispy> shachaf: because I tried that and it wouldn't install correctly or build things corretly.
23:20:19 <Cale> shachaf: the jokes
23:20:38 <shachaf> Cale: echo shachaf | rot13
23:20:52 <shachaf> lispy: You should try again.
23:20:56 <shachaf> Building GHC is a big headache.
23:21:10 <lispy> shachaf: I assume you're trolling me?
23:21:15 <shachaf> lispy: No?
23:21:28 <lispy> I really did try the binary. Building from source is no trouble at all
23:21:43 <lispy> But, building from source failed for the same reason the binary build fails
23:21:50 <lispy> I have to upgrade
23:21:51 <shachaf> Says lispy, while asking #haskell for help with building GHC.
23:21:56 <lispy> http://debian.2.n7.nabble.com/quot-epollCreate-unsupported-operation-quot-on-buildd-hosts-td1036314.html
23:22:05 <shachaf> Wait, how old is this Debian?
23:22:11 <shachaf> uname -r?
23:22:48 <lispy> let's just say, this install should have grandchildren by now
23:22:58 <shachaf> I vaguely remember something about epoll_create1() problems being fixed.
23:23:06 <Sonarpulse> ok, well now for my last problem for this function: as opposed to converting 1 Word8 to a Word32 with fromIntegral, how can I instead convert 4 Word8 into one 32
23:23:19 <lispy> Cale: A reboot may be in our future
23:24:25 <Cale> Sonarpulse: You could use the operations in Data.Bits to do the appropriate shifts and ors after converting each...
23:24:28 <edwardk> shachaf: ok, taking and dropping are added
23:24:36 <shachaf> Yay!
23:24:42 <Cale> Sonarpulse: but also, I seem to recall some package which had this sort of thing...
23:24:43 <shachaf> Maybe I should've added them instead of complaining...
23:24:45 <shachaf> Ah, well.
23:24:53 <Sonarpulse> that would be nicer than that
23:25:02 <shachaf> (Did you push?)
23:25:11 <edwardk> in half a sec
23:25:20 <Sonarpulse> probably the bytestrings can do a pretty good Word concatenate
23:25:30 <edwardk> now i have
23:25:41 <Jafet> Cale: he doesn't want to use Binary
23:26:19 <Cale> Jafet: I recall seeing a package somewhere, maybe related to crypto, which had a bunch of operations for concatenating words of various sizes.
23:27:57 <edwardk> they could be implemented with something like: elementsOf (indexed l) (<n)   just as easily i suppose
23:28:52 <marzy> can't I specialize class in a list of something?  instance Foo [Int] where
23:28:57 <shachaf> Can it be smarter for some structures?
23:29:02 <marzy> on a*
23:29:05 <Jafet> > (`showHex` "") $ foldr ((Data.Bits..|.) .: (`shiftL` 8)) 0 $ fromEnum <$> [1..4 :: Word8]
23:29:07 <shachaf> E.g. logarithmic time with Data.Sequence.
23:29:07 <lambdabot>   Couldn't match expected type `(a -> a) -> a'
23:29:07 <lambdabot>         against inferred type ...
23:29:25 <edwardk> shachaf: the problem with that is that in general you need to make some kind of magic index type
23:29:30 <lispy> Cale: fixedpoint-simple or something like that?
23:29:47 <lispy> http://hackage.haskell.org/package/FixedPoint-simple
23:29:51 <Cale> http://hackage.haskell.org/packages/archive/random-source/latest/doc/html/Data-Random-Internal-Words.html
23:29:58 <shachaf> edwardk: Well, you can do Last in logarithmic time pretty easily with the monoid instance.
23:30:04 <edwardk> sure
23:30:09 <shachaf> It would be nice if that generalized somehow but it sounds pretty tricky.
23:30:12 <Cale> well, there's one, though it's obviously not the best place for this stuff
23:30:21 <Cale> from random-source
23:30:21 <edwardk> but i have no way to 'move' within the index space
23:30:30 <edwardk> i just get them one after another
23:30:35 <shachaf> Right.
23:30:58 <Cale> also, these versions kinda suck about not making guarantees about the result
23:31:23 <Jafet> > (`showHex` "") $ foldr ((Data.Bits..|.) . (`shiftL` 8)) 0 $ fromEnum <$> [1..4 :: Word8]
23:31:26 <lambdabot>   "700"
23:31:40 <nyc> Rank-ordered trees would help all that.
23:32:54 <edwardk> nyc: moving in index space?
23:33:22 <edwardk> nyc: most of the 'indices' here aren't what you usually think of as indices. they can be representations for representable functors, or other craziness
23:33:26 <nyc> edwardk: Just a balanced tree where each item is indexed by its ordinal position.
23:33:45 <edwardk> nyc: i can't give you a binary tree that indexes an infinite structure
23:33:51 <edwardk> at least not a balanced one
23:34:08 <edwardk> and i can't know if a list is infinite until its too late to stop shuffling the root
23:34:30 <edwardk> so this fails the test even for the simple TraversableWithIndex instance for []
23:34:51 <edwardk> i can't implement that and support infinite lazy data structures
23:35:12 <edwardk> that generality is more important to me in this library than a hack
23:35:23 <lispy> edwardk: what about supporting infinitely lazy programmers?
23:35:28 <nyc> They're necessarily strict.
23:35:47 <edwardk> which pretty much rules it out for this application =)
23:36:19 <edwardk> i have enough trouble with the over-strictness i have on one combinator causing me grief ;)
23:37:14 <shachaf> holesOf?
23:37:15 <edwardk> shachaf did you get a chance to look into destrictifying holesOf?
23:37:18 <shachaf> I forgot about that.
23:37:36 <Sonarpulse> ok, well I don't wanna be premature optimzing, but is GHC smart enough to make linked lists vectors?
23:37:40 <shachaf> edwardk: Did you look into strictifying $EVERYTHING? :-)
23:37:52 <Sonarpulse> and how are tuples represented?
23:37:56 <shachaf> Sonarpulse: That's not really a matter of "smart enough".
23:38:25 <edwardk> shachaf: your eta-reduction approach?
23:38:31 <shachaf> Right.
23:38:38 <Sonarpulse> Well, I know the racket compiler does that sometimes
23:38:39 <shachaf> I guess that's sort of blocking on the GHC bug I reported right now.
23:38:41 <edwardk> shachaf: thats clearly going to be your next 'patch everything' patch. ;)
23:38:48 <shachaf> :-(
23:38:49 <edwardk> but i suppose it needs the ghc bug fixed
23:38:50 <Sonarpulse> and how are tuples stored?
23:38:58 <shachaf> edwardk: The unsafeCoerce approach doesn't!
23:39:12 <shachaf> But I'm not crazy enough to actually do that.
23:39:27 <Sonarpulse> this hashing function only works on 8.3 DOS filenames anyways so i could just give it (Word32 Word32 Word32)
23:39:34 <shachaf> edwardk: Oh, putting holesOf into my inbox, that's your trick now?
23:39:46 <shachaf> Next I'll start getting physical mail about lens bugs.
23:39:57 <lispy> Sonarpulse: haskell lists are really streams
23:40:13 <edwardk> Sonarpulse: we don't do that autovectorization optimization in ghc. the problem is it is a big special case for the garbage collector, and we don't have a special cons cell type that gets used for 90% of our cells
23:40:19 <lispy> Sonarpulse: changing a stream into a vector wouldn't make sense in enough cases to be a win
23:40:34 <shachaf> edwardk: You should add the test case to the bug report.
23:40:43 <Sonarpulse> ok, then i guess the tuple method is best
23:40:44 <edwardk> shachaf: feel free i lost it ;)
23:40:50 <shachaf> So did I!
23:40:57 <edwardk> ahaha
23:41:04 <Sonarpulse> the situation doesn't really warrent full on bytevectors
23:41:11 <Sonarpulse> and they are much uglier too
23:41:22 <lispy> Sonarpulse: Maybe? Expert haskellers actually tend to write to the semantics of the problem and optimize later if/when it matters.
23:41:37 <Sonarpulse> I totally agree
23:41:43 <lispy> Sonarpulse: ghc can do some pretty amazing transformations
23:41:45 <edwardk> Sonarpulse: keep in mind, an "Int" in haskell isn't the actual machine word like you'd expect, its a thunk that when forced will compute one
23:42:01 <Sonarpulse> well yes, lazy by default
23:42:03 <lispy> Sonarpulse: fusion and deforestation do a lot to turn list processing code into nice tight machine representations
23:42:20 <edwardk> Sonarpulse: so much of the optimizations you've come to know and love in other settings really honestly don't apply. in exchange you get entirely new ones available to you
23:42:43 <Sonarpulse> I would just take the most elegant route, but the fact that i need to convert a string into either a list, tuple or bytevector of Word32 forces me to do something ugly
23:43:30 <lispy> Sonarpulse: well, what would be the most convenient for processing? Start there and then worry about converting the input to that
23:43:44 <lispy> Often the transformation can be limited to some small function
23:43:49 <Sonarpulse> [Word32], unless i can fold over a tuple
23:44:03 <Sonarpulse> so now i just need string -> [Word32]
23:44:13 <lispy> right
23:44:38 <Sonarpulse> i can map ord like before, but then i need to combine the word8s into Word32s
23:44:40 <lispy> I haven't used Traversable/Foldable enough to know if tuples are supported
23:44:56 <edwardk> lispy: the instances are annoyingly missing for some common types
23:44:56 <Sonarpulse> I doubt it, and the type signture said no
23:45:15 <Jafet> Sonarpulse: the unicode-nonawareness that you have come to know and love in other settings really honestly does not apply in haskell
23:45:25 <Sonarpulse> It's not my design
23:45:45 <Sonarpulse> I am implemented a "tarball" from a 90s videogame
23:46:13 <edwardk> Sonarpulse: a wad file or something?
23:46:21 <Sonarpulse> mix, from Command and Conquer
23:46:23 <edwardk> ah
23:46:27 <Jafet> Why are you using String at all?
23:46:41 <edwardk> then string is an irrelevant distraction as jafet said
23:46:48 <edwardk> work with bytestrings or some such
23:47:06 <Sonarpulse> the string is for filenames
23:47:25 <Jafet> Isn't mix a giant binary blob containing all the game data?
23:47:42 <Sonarpulse> http://freecnc.org/dev/mix-format/ http://xhp.xwis.net/documents/MIX_Format.html
23:47:56 <Sonarpulse> yeah, an uncompressed archive
23:48:15 <edwardk> then why are you so concerned about overoptimizing them? the time fighting with the data blocks will dwarf your filename manipulation time.
23:48:24 <Sonarpulse> I am writing now the "hashing" function they used so they could reference things with longs instead of 8.3 filenames
23:48:39 <Sonarpulse> for the actual data i will certainly use lazy bytevectors
23:48:46 <edwardk> and even the filenames in there, if they are the internal mix file names will be bytestring'ish anyways
23:48:57 <Jafet> If these "filenames" are internal to the archive, then the filenames are also bytestrings and have nothing to do with String.
23:49:31 <Sonarpulse> well at this stage, the filenames I am starting with will be fed from a directory listing, and I am guessing whatever interface haskell uses for that will be native strings
23:49:51 <Sonarpulse> If it's a wrapper to some C thing, then yes, I could go Cstring -> bytevector
23:49:58 <edwardk> mix file names used some horrible hack to just get the 32 bit id directly from the name iirc
23:50:15 <Sonarpulse> yup, that's what i am implementing :D
23:51:13 <Sonarpulse> though i must say, even for this hack: clearly just somebody puking about 8 lines of C and calling it a day, still looks better functionally via foldl
23:51:14 <edwardk> Sonarpulse: ok, so you'll wind up working with a bytestring, probably by using Data.ByteString.Char8.pack because unicode chars don't mean anything in this format. you only work with ascii
23:51:49 <edwardk> now that you have that you can write something that can read 4 bytes at a time off of it padded with 0's
23:52:08 <edwardk> and then do the rotate and add
23:52:09 <Sonarpulse>  Well the idea is I'd make something like Codec.Archive.Tar and a command line utility to go with it
23:52:32 <Sonarpulse> the later mix archive types which would be cool to eventually support might be a bit smarterd
23:52:56 <Sonarpulse> so to keep a continuous interface, I am thinking native string might be better
23:53:01 <edwardk> thats fine
23:53:13 <edwardk> it doesn't materially affect things to work in the string ;)
23:53:23 <shachaf> No one's responded to my GHC bug. :-(
23:54:21 <Sonarpulse> thinking down the road, what is the package i should use for things like unix ls
23:54:50 <Sonarpulse> so i can make the utility take a directory and then get the filenames from there
23:57:08 <donri> @hackage directory
23:57:08 <lambdabot> http://hackage.haskell.org/package/directory
23:58:04 <Sonarpulse> cool, thanks
23:59:29 <Sonarpulse> back to my hashing function, how would I do something like "f({x:[1,4]}) =..."
