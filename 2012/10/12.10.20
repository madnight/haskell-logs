00:02:18 <startling> @hoogle (a, b) -> (a -> c, b -> d) -> (c, d)
00:02:18 <lambdabot> No results found
00:03:09 <shachaf> @ty \(x,y) -> ($ x) *** ($ y)
00:03:10 <lambdabot> forall a b a1 b1. (a, a1) -> (a -> b, a1 -> b1) -> (b, b1)
00:18:26 <hard_coder> hello
00:18:34 <johnw> hi
00:18:47 <shachaf> hard_coder: It would be nice if you just stuck with "beaky".
00:18:52 <shachaf> Or with any nick, for that matter.
00:19:04 <hard_coder> right
00:19:07 <johnw> yes, you are clearly not hard coded :)
00:19:27 <hard_coder> ^^ alright
00:24:19 <shachaf> What's a nice way of taking a cartesian product without the diagonal?
00:25:17 <maukd> which diagonal?
00:25:46 <shachaf> (a,a),(b,b),...
00:27:06 <maukd> I don't get it
00:27:21 <shachaf> Oh, in this case it's a cartesian product of a list with itself.
00:27:32 <shachaf> I guess it's important to mention that. :-)
00:28:20 <hard_coder> > let cartesianProduct a b = [(x, y) | x <- a, y <- b] in cartesianProduct [1..10] [1..10]
00:28:21 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(...
00:28:36 <shachaf> > join (liftM2 (,)) "abc"
00:28:37 <lambdabot>   [('a','a'),('a','b'),('a','c'),('b','a'),('b','b'),('b','c'),('c','a'),('c'...
00:29:16 <shachaf> > filter (uncurry (/=)) $ join (liftM2 (,)) "abc"
00:29:17 <lambdabot>   [('a','b'),('a','c'),('b','a'),('b','c'),('c','a'),('c','b')]
00:29:34 <shachaf> That, except without the ==
00:30:28 <johnw> so, for every element in the list, you want its product with the same list minus that element
00:30:48 <maukd> if you say it like that, it sounds trivial
00:31:08 <maukd> :t select
00:31:10 <lambdabot> Not in scope: `select'
00:31:46 <dmwit> shachaf: This was on StackOverflow like... two days ago.
00:33:18 <dmwit> http://stackoverflow.com/q/12869097/791604
00:33:50 <maukd> > let select [] = []; select (x : xs) = (x, xs) : map (fmap (x :)) select xs in select "abc"
00:33:51 <lambdabot>   Couldn't match expected type `[f [t]]'
00:33:51 <lambdabot>         against inferred type `[t] -...
00:33:56 <shachaf> dmwit: I knew it was pigworker!
00:33:59 <shachaf> You were right.
00:34:34 <dmwit> You can always tell a pigworker answer.
00:34:49 <shachaf> > liftA2 (++) inits tails "abcd" -- I wonder whether this is useful for anything.
00:34:51 <lambdabot>   ["","a","ab","abc","abcd","abcd","bcd","cd","d",""]
00:34:55 <maukd> > let select [] = []; select (x : xs) = (x, xs) : map (fmap (x :)) (select xs) in select "abc"
00:34:56 <lambdabot>   [('a',"bc"),('b',"ac"),('c',"ab")]
00:35:09 <shachaf> maukd: I guess that's the sensible way of doing it.
00:35:14 <maukd> @let select [] = []; select (x : xs) = (x, xs) : map (fmap (x :)) (select xs)
00:35:15 <lambdabot>  Defined.
00:35:49 <maukd> > [ (x,y) | (x, ys) <- select "abc", y <- ys ]
00:35:51 <lambdabot>   [('a','b'),('a','c'),('b','a'),('b','c'),('c','a'),('c','b')]
00:36:06 <maukd> @undo [ (x,y) | (x, ys) <- select "abc", y <- ys ]
00:36:06 <lambdabot> concatMap (\ (x, ys) -> concatMap (\ y -> [(x, y)]) ys) select "abc"
00:37:20 <shachaf> Thanks, mauke++
00:38:15 <srhb> Differential datatypes... What_!
00:38:22 <shachaf> srhb: ?
00:38:24 <shachaf> Zippers?
00:38:29 <maukd> :t select
00:38:30 <lambdabot> forall t. [t] -> [(t, [t])]
00:38:35 <srhb> In what way are they differential datatypes?
00:38:44 <shachaf> Oh, pigworker's answer.
00:39:15 <srhb> I guess it requires reading a paper. I wonder if it's ever relevant :P
00:39:16 <shachaf> Right, I guess select is like a derivative. :-)
00:39:18 <dmwit> srhb: If you haven't seen it before, it can seem a bit bewildering. Let me see if I can find a good introductory link.
00:39:23 <shachaf> Except it doesn't mark where the hole is?
00:39:36 <dmwit> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.8611 maybe?
00:40:06 <maukd> :t StateT
00:40:07 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
00:40:15 <maukd> :t StateT select
00:40:16 <lambdabot> forall a. StateT [a] [] a
00:40:24 <srhb> Yes, I found that here, thanks http://strictlypositive.org/diff.pdf
00:40:43 <rwbarton> what happens with the 'foreign import ccall "wrapper"' mechanism when an exception occurs in the exported function?
00:40:43 <srhb> @index select
00:40:43 <lambdabot> Text.Html
00:40:52 <srhb> Certainly a lie
00:41:02 <shachaf> rwbarton: Is it different from regular foreign export?
00:41:15 <rwbarton> what happens then?
00:41:41 <rwbarton> the C stack gets unwound to wherever we entered the C function from Haskell?
00:41:51 <dmwit> srhb: (I guess you already knew that pigworker/Conor McBride/strictlypositive.org are all connected.)
00:41:56 <rwbarton> and then the exception gets sent to the Haskell thread that called the C function?
00:42:01 <srhb> dmwit: I just found out. :)
00:42:05 <rwbarton> or is it like, "undefined behavior"
00:42:06 <shachaf> I don't know. :-) But I'd vaguely hope that they're the same.
00:42:20 <rwbarton> i've never used foreign export
00:42:29 <dmwit> rwbarton: Just read the paper already.
00:42:45 <dmwit> http://community.haskell.org/~simonmar/bib/concffi04_abstract.html
00:43:09 <shachaf> Does that paper say anything about exceptions?
00:43:13 <rwbarton> ^F excep doesn't say anything
00:43:22 <rwbarton> but i found something else that claims it is undefined
00:43:25 <dmwit> Maybe not, maybe the previous (non-threaded runtime) one is the one that covers that.
00:43:28 <dmwit> moment
00:43:38 <rwbarton> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html at the bottom
00:44:20 <shachaf> Ah, OK.
00:44:22 <rwbarton> but maybe ghc implements something specific nicer etc.
00:45:15 <srhb> Bam, hit in the head by academia -- and before coffee too!
00:45:55 <shachaf> srhb: It's only as academic as you want it to be.
00:46:10 <dmwit> Huh, the earlier one doesn't mention exceptions either.
00:46:50 <srhb> shachaf: Yes, I'm using it in the derisive way because I understand nothing. Which probably has to do with coffee as well :P He actually appears to be very clear in his writings.
00:47:12 <shachaf> srhb: Do you know how zippers work?
00:47:25 <srhb> shachaf: The data structure?
00:47:36 <shachaf> Yes.
00:47:46 <srhb> shachaf: Yeah :)
00:48:04 <hard_coder> http://ideone.com/vXybEQ what's a good way to remember the original string?
00:48:12 <shachaf> srhb: You know how that's like a "hole"?
00:48:48 <srhb> shachaf: Not sure, no.
00:49:13 <shachaf> For example, for lists, with "abcdefgh", you might have "" "bcdefgh", or "a" "cdefgh", or "ab" "defgh"
00:49:20 <srhb> Right.
00:49:29 <shachaf> (Usually the list on the left is reversed for efficiency.)
00:49:47 <dmwit> hard_coder: "remember"?
00:49:58 <shachaf> So you can have a hole in one of eight places, there.
00:50:20 <srhb> shachaf: Because there are seven elements, and it's a flat structure..
00:50:26 <mroman> now I went through the whole chat buffer just to see someone highlighting me by accident :(
00:50:42 <shachaf> srhb: Well, even if it wasn't flat, there's one of eight places you could put the hole. :-)
00:50:49 <dmwit> mroman: grep -C10, man
00:51:01 <srhb> shachaf: Oh, I thought they were "conceptually" at the links.
00:51:06 <johnw> I'm suprised pigworker's answer doesn't really mention zippers, except to use it as a verb
00:51:21 <shachaf> srhb: Another way to think of that is a number between 0 and 7, and a list. So (0,"bcdefgh"), or (5,"abcdegh")
00:51:27 <johnw> is there a more fundamental notion of which zippers are a member?
00:51:29 <dmwit> johnw: "zipper" is just, like, a name, man
00:51:44 <shachaf> dmwit: whoa, dude. grep -A + grep -B = grep -C
00:51:46 <dmwit> He didn't use that name, but he was talking about them the whole time.
00:51:48 <shachaf> √, man!
00:51:53 <johnw> oh, I thought it was some kind of math concept
00:51:54 <dmwit> shachaf: I know! It's awesome.
00:52:10 <shachaf> srhb: Can you see how that's isomorphic to the normal representation?
00:52:29 <shachaf> (It might be less efficient but who cares.)
00:52:35 <srhb> Er. Maybe.
00:52:36 <johnw> but yeah, his derivative thing, and Connor's paper, is a great connection
00:52:53 <dmwit> johnw: pigworker = Conor (one 'n')
00:52:54 <shachaf> srhb: OK, let's take a simpler example. :-)
00:53:13 <srhb> No, I'm just not sure I understand exactly how you're using isomorphic in this example
00:53:13 <shachaf> If you take (a,a), and you put a hole in it, you can either put it on the first element or the second.
00:53:19 <srhb> Yeah.
00:53:28 <shachaf> So (x,y) -> (_,y) or (x,_)
00:53:33 <srhb> Right.
00:53:35 <johnw> dmwit: haha!  cool!
00:53:46 <shachaf> srhb: One way to represent that is (Bool,a)
00:53:57 <shachaf> The Bool is for "was it the first element or the second element?".
00:54:01 <srhb> Right.
00:54:17 <Ralith> dmwit: for a few seconds I was wondering what a Co-nor was, and why it was being used as a data constructor.
00:54:23 <shachaf> For (a,a,a), you can use data Foo = One | Two | Three, and then (Foo,a,a)
00:54:31 <srhb> Yes. :)
00:54:33 <srhb> And so forth.
00:54:53 <shachaf> srhb: So for a list of length n, you can take (NumberFrom1toN, ListOfLengthNMinus1)
00:54:54 <dmwit> For a^n, you can use n * a^(n-1).
00:54:56 <dmwit> Look familiar?
00:55:11 <srhb> Yes, I see the derivative likeness, I just don't understand what a hole is.
00:55:18 <srhb> A hole is something that is where an element is not? What?
00:55:28 <dmwit> Oh, yes.
00:55:31 <shachaf> srhb: take some existing structure and take one element out, but remember where you took it from.
00:55:36 <shachaf> So you can put it back in later.
00:55:55 <srhb> So a hole is a position and the element I took out? Or the position without the element? Or more abstract yet?
00:56:10 <shachaf> A "hole" isn't a thing on its own.
00:56:29 <shachaf> But an "(a,a,a) with a hole" might be represented as "(Foo,a,a)"
00:56:37 <dmwit> eh
00:56:53 <dmwit> I think the whole "hole" thing is meant as an intuition. If it's not a helpful intuition, you can ignore it and stare at definitions instead.
00:57:00 <shachaf> Right.
00:57:10 <srhb> OK. I guess it's not helping me. :P
00:57:17 <johnw> srhb: he's defining another data structure which identifies the hole, and "all but the hole" from the original structure
00:57:39 <johnw> and there is more than one way to do that
00:58:29 <johnw> srhb: Learn You a Haskell has a chapter on this concept titled "Zippers"
00:58:38 <srhb> johnw: Yes, I've read that.
00:58:40 <johnw> ok
00:58:42 <srhb> Albeit some time ago.
00:58:54 <srhb> I thought I understood how zippers work, but maybe not. :P
00:59:05 <johnw> a zipper is the sort of thing shachaf is proposing
00:59:12 <shachaf> You probably do. This is just a different way of looking at them.
00:59:51 <johnw> srhb: you might want to play around with: a way of taking some structure f, and extracting an element while remember
00:59:55 <johnw> (sorry, http://hackage.haskell.org/packages/archive/ListZipper/1.2.0.2/doc/html/Data-List-Zipper.html)
01:00:00 <johnw> list zippers are easy to think about
01:01:07 <shachaf> srhb: You understood the thing with (a,a,a) and so on, right?
01:01:14 <srhb> shachaf: Yes :)
01:01:46 <dmwit> srhb: Can I take a shot?
01:01:57 <shachaf> dmwit: Do it!
01:02:04 <srhb> Ok :(
01:02:08 <shachaf> ?
01:02:08 <srhb> :)*
01:02:10 <srhb> Sorry :P
01:02:20 <dmwit> Imagine we're working in a dynamically typed language.
01:02:23 <srhb> (Switching between Danish and English keyboards does that since () are shifted by one)
01:02:27 <dmwit> Create a brand new type data Hole = Hole.
01:02:44 <dmwit> Take any container, and replace one of the contained items with Hole.
01:02:45 <shachaf> (Hmm, D(a,b) = Either (a,Db) (b,Da) is completely obvious. For some reason I didn't see that before.)
01:03:21 <srhb> dmwit: With you so far.
01:03:23 <dmwit> So, for example, [a, b, c, d, e] might become [a, b, c, Hole, e], or Branch 1 (Branch 2 Leaf Leaf) (Branch 3 Leaf Leaf) might become (Branch 1 (Branch Hole Leaf Leaf) (Branch 3 Leaf Leaf).
01:03:33 <srhb> Right.
01:03:43 <dmwit> Call the "Hole" part a "hole".
01:03:46 <dmwit> Done. (?)
01:04:00 <srhb> Okay. :P
01:04:04 <srhb> Well that seems trivial.
01:04:09 <dmwit> it kind of is, yes
01:04:13 <shachaf> Yep, there's nothing really complicated here.
01:04:26 <johnw> now you might explain how a typed language makes it _seem_ a bit more complex
01:04:30 <shachaf> srhb: It's a little more interesting when you think of what it's like in a non-dynamically-typed language.
01:04:39 <dmwit> Okay, the next two steps are:
01:04:46 <shachaf> Oops, dmwit is still going.
01:04:56 <dmwit> 1. yes, we'd like to work in a typed language, and we want the type to ensure there's exactly one Hole
01:05:13 <dmwit> 2. we want to be able to efficiently move the hole around, e.g. left and right in the list or up and down in the tree
01:05:30 <srhb> Which is easy for lists, say.
01:05:45 <dmwit> So, the question is: how do we take a given type (constructor), and create a new type (constructor) that has holes and meets those two criteria?
01:05:49 <johnw> (and we want to be able to fill in the hole and get back a new value with that element filled in)
01:05:49 <dmwit> Right, it's easy for lists.
01:06:21 <dmwit> And we can generalize quite a bit, and it turns out that the generalization *happens* to look like a derivative when we're talking about "polynomial" type (constructors).
01:06:45 <shachaf> dmwit: I don't think the idea of a derivative makes it easy to make an *efficient* zipper, does it?
01:07:08 <dmwit> Uh. I was under the impression that was sort of the point.
01:07:13 * shachaf doesn't know what a zipper for a two-dimensional grid with constant-time UDLR would look like.
01:07:33 <dmwit> The movements aren't necessarily intuitive ones.
01:07:43 <shachaf> dmwit: It's the point of zippers, but for example a pair of lists where the first one isn't reversed is a perfectly valid list-zipper.
01:07:52 <dmwit> The obvious way to write down a 2D-grid gives you movements along diagonals.
01:08:02 <shachaf> All the derivative tells you is that D[a] = ([a],[a])
01:08:18 <srhb> So, wait, are you saying that given a sum datatype, there's a derivative-like other sum datatype which represents a way of representing a hole and the "rest"?
01:08:30 <dmwit> srhb: Yep!
01:08:33 <srhb> ... wow!
01:08:46 <srhb> That's... Weird!
01:08:50 <dmwit> Yep!
01:09:10 <shachaf> srhb: Given a pair (a,b) of some types a and b, if you want to stick a hole *somewhere* in it, that's equivalent to either sticking it in the a or sticking it in the b, right?
01:09:18 <srhb> Yes.
01:09:21 <shachaf> So you can say D(a,b) = Either (a,Db) (b,Da)
01:09:28 <shachaf> Where "D" means "stick a hole in it".
01:09:33 <srhb> Right.
01:09:40 <Nereid> I'd rather say (Da,b) for the second :v
01:09:51 <dmwit> d(A+B) = dA + dB -- a hole in an A+B is either a hole in an A or a hole in a B
01:09:59 <shachaf> Right.
01:10:05 <srhb> hang on, what is A + B type
01:10:08 <shachaf> + = Either
01:10:09 <srhb> The abstraction threw me off
01:10:10 <Nereid> Either A B
01:10:14 <srhb> Okay.
01:10:32 <Nereid> (and A * B = (A,B))
01:10:39 <srhb> Right.
01:10:53 <srhb> Ah.
01:10:55 <srhb> How curious.
01:11:07 <shachaf> srhb: (For example, Bool = False | True; Ordering = LT | EQ | GT; the number of things of type "Either Bool Ordering" is the sum of the number of things of those types.)
01:11:09 <zygoloid_> d(A * B) = a * dB + dA * B
01:11:10 <shachaf> (So 5 in this case.)
01:12:29 <srhb> OK, I think I get it. Sort of.
01:12:30 * shachaf would still like to see an intuitive connection between this and "derivatives as limits of continuous functions".
01:12:35 <srhb> Yes :P
01:12:43 <zygoloid_> johnw: small world :)
01:12:51 <johnw> zygoloid_: Hello!
01:12:57 <shachaf> clang?
01:13:02 <johnw> zygoloid: my plane actually broke, so I'm stuck here another day
01:13:11 <zygoloid> johnw: you back in the hotel?
01:13:21 <johnw> another hotel
01:13:23 <zygoloid> shachaf: wg21 too :)
01:13:52 <shachaf> zygoloid: Oh, yes.
01:14:06 <shachaf> Were you two in Portland or something for the same reason?
01:14:14 <zygoloid> yup, still are :)
01:14:20 <zygoloid> making c++ bette^Wdifferent
01:14:24 <johnw> lol
01:14:28 <shachaf> "more C++y"
01:14:36 <johnw> we had dinner together last night
01:14:40 <zygoloid> "more C++1y"
01:14:49 <shachaf> dmwit: Do you happen to have one?
01:15:21 <shachaf> srhb: By the way, if Either is + and (,) is *, (->) is (flipped) (^)
01:15:34 <johnw> is there a basic dictionary of how derivatives apply?  I didn't follow zygoloid got to "d(A * B) = a * dB + dA * B"
01:15:35 <srhb> -> the basis?
01:15:37 <dmwit> No, I was sort of under the impression that it was just a coincidence that things lined up so neatly.
01:15:45 <srhb> Or what's it called in English..
01:15:53 <shachaf> dmwit: :-(
01:15:54 <Nereid> johnw: same as in calculus
01:16:03 <johnw> ah
01:16:07 <srhb> dmwit: Can't be! :P
01:16:09 <shachaf> https://en.wikipedia.org/wiki/Derivation_(abstract_algebra)
01:16:13 <johnw> I knew I should have paid attention back then...
01:16:22 <johnw> shachaf: thanks!
01:16:34 <srhb> johnw: That's called the product rule, strangely.
01:16:37 <shachaf> johnw: Oh, I'm not sure that link will help you.
01:16:42 <shachaf> johnw: Well, you can figure it out by thinking about holes.
01:16:44 <johnw> i've found a local cat theory prof who mentors independent study, here's hoping he has some time this winter...
01:16:51 <dmwit> johnw: You could always try deriving the rule from first principles. The product rule happens to be one of the easier ones.
01:16:59 <shachaf> johnw: A hole in (a,b) is either in the a or in the b, with the other one remaining untouched.
01:17:26 <shachaf> So D(a,b) = Either (Da,b) (a,Db)
01:17:27 <johnw> ah, that's where the "+" came in
01:17:34 <johnw> (Da,b) = Da * b
01:17:37 <johnw> Either = +
01:17:41 <hard_coder> @pl \x y z -> _ _ x = x
01:17:41 <Nereid> yeah
01:17:41 <lambdabot> (line 1, column 11):
01:17:41 <lambdabot> unexpected "_"
01:17:41 <lambdabot> expecting lambda abstraction or expression
01:17:42 <johnw> thus, what zygoloid said
01:17:43 <shachaf> Right.
01:17:52 <hard_coder> @pl \x y z -> _ _ z = z
01:17:52 <lambdabot> (line 1, column 11):
01:17:52 <lambdabot> unexpected "_"
01:17:52 <lambdabot> expecting lambda abstraction or expression
01:18:00 <Nereid> @pl \_ _ z -> z
01:18:00 <lambdabot> const (const id)
01:18:07 <ion> What’s D(Integer)?
01:18:08 <hard_coder> ah
01:18:20 <ion> ()?
01:18:21 <srhb> ion: Deriving a constant, I assume
01:18:23 <shachaf> ion: Void, I guess?
01:18:45 <shachaf> Well, DBool would be Void. Integer is one of those weird infinite types.
01:19:01 <srhb> What?
01:19:03 <hard_coder> what magic does `deriving Show` do to turn names into showable strings?
01:19:16 <johnw> hard_coder: it uses the Show instance of the contained types
01:19:27 <dmwit> ion: Normally, you take derivatives of containers (that is, types of kind * -> *).
01:19:43 <shachaf> srhb: This sum-product-exponent thing can be pretty nice for reasoning about types. (Bool -> Either a b) = (a+b)^2 = (a+b)(a+b) = a^2 + 2ab + b^2 = Either3 (a,a) (Bool,a,b) (b,b)
01:19:44 <ion> dmwit: ok
01:19:46 <hard_coder> `data Foo = Foo deriving Show; putStrLn Foo`
01:19:47 <nand`> the ‘hole-sticking’ is with respect to some type parameter (eg. ‘x’)
01:19:50 <shachaf> So you can tell that those two types are isomorphic.
01:19:51 <dmwit> You can define data Foo a = Foo Integer, in which case the derivative is data Void x.
01:19:53 <hard_coder> > data Foo = Foo deriving Show; putStrLn Foo
01:19:54 <nand`> no type parameters, no holes; Void
01:19:54 <lambdabot>   <no location info>: parse error on input `data'
01:19:58 <johnw> ah
01:19:59 <hard_coder> :(
01:20:27 <Nereid> so it's more like Const Void :: * -> *
01:20:28 <nand`> sort of how you differentiate a function with respect to some parameter as well
01:20:44 <shachaf> Right. We've been handwaving a bit.
01:20:57 <shachaf> (As people do when derivatives are involved, because it's such a hassle not to.)
01:21:13 <johnw> hard_coder: good question, is that then a feature of the compiler?  Without "deriving Show" you could accomplish the same thing with TH in as little syntax
01:21:16 <ion> What are these kind of derivatives useful for?
01:21:25 <nand`> ..sticking holes :P
01:21:28 <dmwit> aaaand we come full circle.
01:21:32 <shachaf> ion: Well, zippers. :-)
01:21:34 <johnw> ion: generalizing zippers
01:21:39 <ion> Ok, interesting.
01:21:39 <srhb> shachaf: HOw exactly are you saying that that shows isomorphism?
01:21:51 <shachaf> srhb: Well, that doesn't really "show" anything.
01:21:58 <shachaf> It just lets you apply a different intuition. :-)
01:22:02 <srhb> shachaf: OK.
01:22:09 <shachaf> (But you can see that those are isomorphic, right?)
01:22:17 <ion> hard_coder: data Foo = Foo; instance Show Foo where shows Foo = showString "Foo"
01:22:25 <hard_coder> ah
01:22:30 <hard_coder> so its some template magic?
01:22:31 <ion> hard_coder: That’s essentially what gets generated.
01:22:52 <ion> Err, i’m not sure if either “template” or “magic” applies.
01:22:56 <nand`> well, I guess it's built into the compiler in this case; and not done via TH internally
01:23:01 <shachaf> ion: It's pretty magic.
01:23:02 <srhb> shachaf: Yes.
01:23:03 <hard_coder> ah
01:23:05 <johnw> hard_coder: there are other magical deriving-able types, if you add LANGUAGE DeriveFunctor, for example
01:23:18 <shachaf> srhb: Well, it's more than intuition, really. Types-up-to-isomorphism are a commutative semiring, or something along those lines, so you can use all your hard-earned theorems about commutative semirings to reason about types.
01:23:24 <srhb> The inverse is obviously type integration. <_<
01:23:32 <nand`> but certainly people have used TH to auto-derive their own classes
01:23:41 <shachaf> srhb: Oh, () = 1, and Void = 0
01:23:42 <nand`> that the compiler doesn't know about
01:23:58 <shachaf> srhb: Here's one for you: data List a = Nil | Cons a (List a); L(a) = 1 + a*L(a)
01:24:04 <srhb> shachaf: I reasoned my way to that all by myself. Or rather () = k
01:24:10 <shachaf> srhb: No, () = 1
01:24:15 <srhb> Hm, why?
01:24:16 <shachaf> Either () () = 2 = Bool
01:24:22 <shachaf> srhb: Because it has one inhabitant.
01:24:27 <srhb> Ack.. Okay.
01:24:33 <nand`> shachaf: I like how when you work it out, it turns out as 1 + a + a² + a³ + a⁴ ...
01:24:53 <shachaf> Now handwave and "solve" for L to get L(a) = 1/(1-a), and then "expand" to get the infinite series nand gave.
01:25:06 <Nereid> formal power series
01:25:08 <nand`> which really makes sense
01:25:16 <shachaf> And as it happens, a list is either empty (1) or has one element (a) or has two elements (a,a) or so on.
01:25:17 <Nereid> (over a semiring...)
01:25:20 <nand`> a list of something is either a 0-sequence, a 1-sequence, a 2-sequence, a 3-sequence, etc.
01:25:23 <johnw> hard_coder: see also http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/deriving.html
01:25:30 <shachaf> Nereid likes to do it the non-handwavy way.
01:25:32 <shachaf> See also
01:25:34 <shachaf> @where haskell2010
01:25:35 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/
01:27:04 <nand`> and, differentiating those (each separately due to the sum rules); you get something like 0 + 1 + 2*a + 3*a² + ...  -- intuitively, a 3-sequence has a hole at one of three positions (3*) plus the remaining two elements (a²)
01:28:17 <morel> preflex: seen mekeor
01:28:18 <preflex>  mekeor was last seen on #haskell-blah 52 days, 23 hours, 24 minutes and 52 seconds ago, saying: http://youtu.be/9ivd3emwXuU
01:29:14 <hard_coder> preflex: seen beaky
01:29:15 <preflex>  beaky was last seen on #haskell 6 days, 12 hours, 6 minutes and 42 seconds ago, saying: How does Miranda relate to Haskell? Both languages seem to have quite similar syntax, and both are purely-functional
01:29:37 <hard_coder> seems Miranda is dying?
01:30:12 <johnw> googling for Miranda doesn't even turn up the language on the first page
01:30:27 <nand`> another neat thing about these semirings is that exponentiation is like functions; a^b ≅ b -> a; which gives a neat visualization of the notion that a function Bool -> a is like an (a,a) indexed by bools; a² = a*a
01:30:37 <morel> well, you could say Haskell is Miranda's son (or daughter?)
01:31:04 <johnw> the history of haskell paper, by SPJ, talks a lot about Miranda's influence on Haskell's development
01:31:27 <srhb> nand`: Yes, shachaf said that :-)
01:31:30 <johnw> and that originally, they wanted to just use Miranda as a starting point
01:31:31 <nand`> ah, okay :)
01:31:53 <shachaf> srhb: Next up, logarithms!
01:32:02 <srhb> Whoa whoa. :P
01:32:04 <Jafet> Is Miranda still a trademark of Research Software Ltd?
01:32:12 * shachaf has no idea what logarithms correspond to, if anything.
01:32:16 <Nereid> lol
01:32:18 <hamid> guys i'm a beginner i want to implement a functions which gets a list of numbers and returns the even numbers as a list. how do i do that?
01:32:29 <nand`> next up, multiplicative or additive inverse types? :P
01:32:35 <johnw> D(logb) == ?
01:32:36 <srhb> hamid: filter even list
01:32:39 <Nereid> hamid: how much do you want to do from scratch?
01:32:40 <nand`> fund it
01:32:47 <srhb> But yeah, you probably want something cleaner
01:32:52 <Nereid> > filter even [1..10]
01:32:53 <lambdabot>   [2,4,6,8,10]
01:32:53 <srhb> and basic'er :P
01:33:03 <srhb> shachaf: Why is the series expansion interesting again
01:33:12 <shachaf> srhb: Of what?
01:33:19 <hamid> aha!
01:33:29 <hamid> srhb, thanks :)
01:33:41 <shachaf> "filter even" is the most useless thing when you want to be learning.
01:33:47 <mekeor> Hi guys :) I missed you… soo much! D: ;(
01:33:50 <srhb> L(a) = 1/(1-a)
01:33:50 <Nereid> which is why I asked.
01:33:51 <shachaf> Your exercise is to write it on your own, man!
01:34:04 <hamid> Nereid, just trying to surf and learn comming from c++ background :P
01:34:06 <srhb> hamid: Yeah, implement filter is a nice choice
01:34:06 <shachaf> srhb: Because you can see how it corresponds to a sum of n "a"s, for some n!
01:35:03 <Nereid> I wonder, can we have some silly types where a /= 0 but a^n = 0 for some n?
01:35:08 <ion> A = exp (log A)
01:35:26 <ion> = log (exp A)
01:35:31 <srhb> *boggle*
01:35:45 <Nereid> like say
01:35:57 <opqdonut> Nereid: http://blog.sigfpe.com/2006/09/infinitesimal-types.html ?
01:36:01 <shachaf> Nereid: So a /= Void, but T -> a = Void?
01:36:07 <shachaf> Er, I don't know why I said Void.
01:36:12 <hamid> srhb, i'm just curious how do we implement filter itself?
01:36:12 <shachaf> Er, never mind.
01:36:23 <shachaf> Nereid: Anyway, you can always just take (const x), can't you?
01:36:26 <Nereid> opqdonut: yeah, like that
01:36:34 <Jafet> @src filter
01:36:35 <lambdabot> filter _ []     = []
01:36:35 <lambdabot> filter p (x:xs)
01:36:35 <lambdabot>     | p x       = x : filter p xs
01:36:35 <lambdabot>     | otherwise = filter p xs
01:36:44 <Nereid> shachaf: what is it and how is it nilpotent?
01:36:48 <hamid> awesome bot!
01:36:51 <srhb> hamid: Think about it abstractly first. filter takes a "predicate function" and a list and preserves all the elements for which the predicate is true
01:36:54 <shachaf> Nereid: ?
01:37:01 <shachaf> What's what?
01:37:02 <Nereid> what is const x.
01:37:03 <srhb> hamid: You're gonna gain more from actually doing it yourself, so don't read that source :P
01:37:18 <shachaf> Nereid: x :: a
01:37:23 <shachaf> Where a is your type.
01:37:33 <Nereid> well by type I mean "type"
01:37:52 <hamid> srhb, i know it but i tried to write it as in filter (x:xs) but i got stuck in what about x :P
01:38:16 <srhb> hamid: Well, if p is true for x, then we want to include x in our list
01:38:27 <srhb> hamid: consed onto the rest of our filtered list, whatever that may be
01:39:08 <hamid> srhb, still didn't read that code. ;) let me try what you say :) thanks
01:39:14 <Jafet> Don't forget even: even 0 = True; even n = odd (n-1); odd 0 = False; odd n = even (n-1)
01:39:30 <Nereid> but say
01:39:36 <shachaf> even (-1) = ?
01:39:49 <hamid> Jafet, recursive :|
01:39:52 <hamid> Jafet, ok thx
01:39:57 * srhb needs more abstract algebra
01:39:59 <Nereid> some type a which has n values, but any time two such values occur in an expression, they must be distinct.
01:40:02 <Jafet> shachaf: (-1) = ?
01:40:06 <srhb> hamid: filter is, too. Everything is recursive here :P
01:40:09 <Nereid> so a^k has n choose k values.
01:40:31 <Nereid> no wait.
01:40:32 <shachaf> Jafet: (-1) :: Num a => a; (-1) = negate 1
01:40:34 <Nereid> k! (n choose k)
01:40:43 <Nereid> well whatever. that thing.
01:41:05 <hamid> srhb, yeah i know sometimes it's expensive in my thoughts! but i'm gonna throw away what ever i believe :P
01:41:47 <srhb> hamid: Haskell has ways of making recursion not expensive.
01:41:50 <Jafet> > let (-1) = negate 1 in negate 1
01:41:51 <lambdabot>   -1
01:42:24 <shachaf> > let negate 1 = -1 in negate 1
01:42:26 <lambdabot>   -1
01:42:48 <Nereid> > let negate 3 = "elephant" in negate 3
01:42:49 <lambdabot>   "elephant"
01:43:09 <Nereid> > -x
01:43:10 <lambdabot>   negate x
01:43:13 <hamid> srhb, you mean in compiler or in code the way programmers implement or both? :P
01:43:42 <srhb> shachaf, dmwit, nand`, others: Thanks for the intro, by the way. I'll continue this when my brain is more accepting of new ideas :P
01:44:00 <srhb> hamid: WEll, both, but simple recursion by the compiler.
01:44:02 <shachaf> srhb is feeling bigoted.
01:44:09 <srhb> Bigoted? :(
01:44:13 <srhb> Oh
01:44:14 <srhb> Haha
01:44:33 <johnw> hamid: in general, throw away your notions of "what the computer does" when thinking about Haskell, and focus instead on values and how they are defined.  Things will work out the way you'd want them to most of the time, and you can learn about how to deal with the exceptional cases later on
01:44:44 <srhb> I'll have you know I've accepted all the social ideas there are to accept. Math is just beyond me. :P
01:44:49 <Jafet> If recursion is too expensive, try buying the chinese recursions
01:44:57 <shachaf> srhb: I doubt that.
01:45:04 <srhb> shachaf: Really? ;-)
01:45:09 <srhb> I thought I sounded very convincing.
01:45:52 <hamid> johnw, sure. but it's hard. cause i'm used to learn this way.
01:46:02 <johnw> hamid: I know, believe me, I know :)
01:46:11 <arcatan> are there any interesting functors that are not applicative?
01:46:18 <nand`> ‘bigoted’ doesn't mean ‘rejecting new ideas’; does it? just ‘forming opinions without just cause; strongly prejudiced’
01:46:29 <hamid> johnw, lol
01:46:46 <johnw> somewhere Yoda is still telling me to unlearn what I have learned
01:47:12 <johnw>  nand`: "having or revealing an obstinate belief in the superiority of one's own opinions and a prejudiced intolerance of the opinions of others"
01:48:30 <johnw> arcatan: I tried a few days ago, but couldn't not come up with any functor which is not also applicative
01:48:43 <johnw> anything that can hold a type in Hask can hold a function type, thus, applicative
01:48:48 <nand`> arcatan: some thoughts on that here: http://stackoverflow.com/questions/7220436/good-examples-of-not-a-functor-functor-applicative-monad ; I don't know of any
01:50:28 <arcatan> hmm, okay
01:50:54 <johnw> arcatan: do you understand the relationship of Applicative to Functor?
01:51:32 <dmwit> :t (<*>)
01:51:34 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
01:51:51 <arcatan> not very well
01:52:07 <Nereid> johnw: (,) t is quite not applicative
01:52:14 <johnw> Functor lifts a function a -> b into the functor, giving f a -> f b.  Applicative taken a function in the functor, f (a -> b) and gives f a -> f b
01:52:49 <Nereid> arcatan: (,) t is not applicative
01:52:56 <nand`> (,) t can be made an applicative though given a suitable monoid constraint
01:53:01 <Nereid> sure
01:53:09 <Nereid> but in general you can't
01:53:25 <Nereid> (,) t is in fact a monad if t is a monoid.
01:53:26 <nand`> but yeah, that's a good point; (,) T where T can not be made Monoid would fit
01:53:48 <Nereid> silly example: t = Void
01:54:12 <nand`> surely the monoids laws vacantly hold on Void
01:54:17 <shachaf> No.
01:54:18 <nand`> vacuously*
01:54:21 <Nereid> nand`: what's mempty?
01:54:25 <shachaf> Void is a semigroup but not a monoid.
01:54:33 <nand`> oh, right
01:55:00 <shachaf> ((,) w) is a monad iff w is a monoid.
01:55:07 <shachaf> And the three monad laws correspond exactly to the three monoid laws.
01:55:14 <Nereid> yup
01:56:13 <Nereid> anyway, (,) Void = Const Void is a pretty silly functor
01:58:41 <johnw> arcatan: Without Applicative, you could not partially apply a binary function to a functor (using fmap) and then apply *that* to another functor.
01:58:46 <johnw> arcatan: For example: fmap (+) [3] becomes [(+3)], but how do I apply that to [4] to get [7]?
01:58:48 <johnw> arcatan: There is no way, not without knowing it's a list and calling `head` to extract the function and then use fmap again.
01:58:53 <johnw> arcatan: Applicative lets general code use <*> to perform such applications (hence the name)
01:59:28 <Nereid> although [] _is_ applicative
01:59:34 <Nereid> (in two different ways)
01:59:53 <johnw> even without the type class?
02:00:01 <Nereid> huh
02:00:10 <arcatan> johnw: yes, that much i know
02:00:33 <johnw> Nereid: how do I write fmap (+) [3] <*> [4] without <*> for lists?
02:00:55 <johnw> arcatan: then you understand Applicative :)
02:00:57 <Nereid> I don't understand the question.
02:01:07 <johnw> you said [] is applicative
02:01:13 <johnw> maybe I misunderstood the statement
02:01:23 <Nereid> there are at least two valid Applicative instances for it
02:01:27 <johnw> but I thought that it meant it gives me a way to apply [(+3)] to another value in a list
02:01:31 <johnw> oh, sure
02:01:35 <Nereid> that is what I meant
02:01:53 <johnw> I was talking about functions which know nothing about *which* applicative they're dealing with, but only know it is some Applicative a
02:02:26 <Nereid> oh, sure.
02:03:37 <johnw> A funny thing about Haskell is that understanding what something is is only like 5% of understanding what it can be used for and why it's cool
02:03:58 <srhb> It tends to go the other way for me :P
02:04:12 <srhb> "This thing, which is a black box, can be used for these things!"
02:04:20 <johnw> Applicative borders on trivial, and only provides <*>, but there are so many combinators and cool things you can do with it, that it SEEMS like a complex feature
02:06:49 <johnw> I came to this same realization about Arrow this week
02:07:02 <johnw> will blog on it tomorrow
02:08:13 <danr> johnw: [ x + y
02:08:22 <johnw> it's almost as though some kind of human sacrifice is happening in a dark room somewhere, giving Haskell all of this *power* out of something as simple as mere functional application :) -- which nearly all of its feature boil down to
02:08:24 <danr> johnw: [ x + y | x <- [3], y <- [4] ] ?
02:08:32 <johnw> danr!
02:08:58 <johnw> how mature is your constraint checking library?
02:09:33 <johnw> i mean, contracts checking
02:09:53 <johnw> (and your list comprehension doesn't deal with a function embedded in the list)
02:10:19 <danr> not super-mature, I'm afraid
02:10:25 <johnw> i love the idea
02:10:31 <danr> feel free to play around with it :)
02:10:39 <johnw> Microsoft's presentation is from 2007
02:10:39 <Nereid> > [ x y | x <- [(3+)], y <- [4]]
02:10:40 <lambdabot>   [7]
02:10:47 <johnw> so I gather this field of research isn't moving along very quickly?
02:10:58 <danr> which presentation are your referring to?
02:11:17 <johnw> danr: http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/Contracts-Dec07.pdf
02:11:31 <johnw> seemed awfully similar to your work
02:11:57 <danr> yes, so it's been a long-running project which I've only been involved in the last half year or so
02:12:12 <johnw> what kind of help might you need?
02:12:19 <danr> Dana Xu's PhD thesis is about contract checking, but she's doing it for cbv (o'caml) recently
02:13:03 <danr> there are various bits that need a lot of work :)
02:13:11 <johnw> Boost just got a new Contracts library for C++, which should be in 1.52; not quite as pretty as the Haskell version, though
02:13:21 <johnw> danr: are the best docs in contracts-docs?
02:13:23 <danr> oh, I should check that out
02:13:25 <hard_coder> http://ideone.com/3lW0jL my algorithm is almost complete, but I need a little help debugging it :( what's wrong with it?
02:13:44 <danr> johnw: the popl revision is being done in a branch is that repo
02:14:13 <danr> and some other various bits, try making the pldi-paper.tex, and there are two presentations there too
02:14:38 <Nereid> hard_coder: what's it supposed to do? give all possible results of replacing, or not, foo with bar?
02:14:46 <hard_coder> yes
02:14:58 <Nereid> what should combReplace "aaa" "aa" "b" be?
02:15:10 <danr> johnw: breakfast time here now, feel free to drop me a line at danr@student.chalmers.se about whatever comes to your mind
02:15:21 <johnw> ok!  thanks, Dan
02:15:22 <hard_coder> ["aa, "ba", "ab"]
02:15:36 <Nereid> aaa, I hope. hmm
02:15:51 <hard_coder> oops first one is "aaa"
02:20:40 <Nereid> hard_coder: I think you'll have to rethink line 4 somewhat. combReplace "aaaaa" "a" "b" gives completely the wrong thing
02:20:57 <Nereid> presumably the resulting list should have 32 elements, but it only has 10.
02:26:24 <Nereid> hard_coder: fwiw I think your base case is wrong too: we should have combReplace [] _ _ = [[]]
02:31:56 <Nereid> hard_coder: when you recurse in line 4, you'll want to make two calls to combReplace
02:32:03 <hard_coder> right
02:36:19 <MvGulik> Launching winghci(Haskell Platform\2012.2.0.0) from program launcher(TurboLanch) fails. ?
02:36:19 <MvGulik> CreateGHCiProcess failed with failed with error 0: De bewerking is voltooid.
02:36:19 <MvGulik> CreateGHCiProcess failed with failed with error 0: The operation completed.
02:36:39 <MvGulik> Anyone having some idea about this.
02:37:37 <hpaste> piccan pasted “ECAN init” at http://hpaste.org/76524
02:39:26 <Nereid> hard_coder: and for debugging stuff, it may be helpful to load your file into ghci and play in there
02:39:29 <MvGulik> Windos Xp ... ?
02:42:02 <k0ral> Hello
02:42:15 <MvGulik> winghci works, when starting it from the installed shortcut, just not when launched from that program launcher. (odd)
02:42:52 <Nereid> MvGulik: some working directory thing perhaps? is ghci in your PATH?
02:43:35 <k0ral> I'm trying to parse commandline options like these: my_programe -a A -b B -c C FREE_TEXT
02:43:55 <hard_coder> http://ideone.com/dR0oqM not quite right, but almost ^^ I tink I'm doing an off-by-one error
02:43:56 <k0ral> I'm using cmdargs and couldn't figure how to parse the "FREE_TEXT" part
02:44:30 <k0ral> from what I've understood, each options has to be defined with a prefix flag like -a/-b/-c
02:44:52 <k0ral> how can I parse the trailing option that comes without any flag ?
02:46:37 <Nereid> k0ral: args?
02:46:47 <MvGulik> Yes its in my path.
02:46:47 <MvGulik> User PATH: C:\Documents and Settings\<name>\Application Data\cabal\bin
02:46:47 <MvGulik> Sys PATH: C:\Program Files\Haskell\bin;C:\PROG_XP\Haskell Platform\2012.2.0.0\lib\extralibs\bin;C:\PROG_XP\Haskell Platform\2012.2.0.0\bin;...
02:46:47 <MvGulik> Mmm. think that "Program Files" also should be "PROG_XP"
02:49:15 <MvGulik> Working directory is picked up as its used in the shortcut.
02:50:52 <k0ral> Nereid: how could I miss it ? :) thank you
02:51:10 <k0ral> by the way, has anyone an opinion on the difference between cmdargs and cmdlib ?
02:55:33 <Nereid> I'm just looking.
02:55:38 <Nereid> cmdargs is impure? scary.
02:59:02 <k0ral> is that enough to discard it ?
02:59:04 <k0ral> :)
03:00:36 <Nereid> very scary.
03:02:00 <Nereid> and mysterious.
03:08:07 <MvGulik> Starting shortcut directly from launcher ... same error.
03:08:07 <MvGulik> Ditching target folder from working shortcut ... shortcut still working.
03:08:07 <MvGulik> I give up. Its not making any sense.
03:12:41 <hard_coder> http://ideone.com/QHRu2B why won't this compile?
03:13:14 <dibblego> hard_coder: you are declaring two constructors called String
03:13:30 <dibblego> maybe you want data Foo a = Foo a and data Bar a = Bar a
03:13:36 <Nereid> or Foo a = Foo String a
03:13:39 <Nereid> ?
03:13:52 <dibblego> maybe you want data Foo a = Foo String a and data Bar a = Bar String a
03:17:07 <Nereid> whaaaaaat.
03:17:16 <Nereid> if I have some record constructor Record { ... }
03:17:26 <Nereid> then the expression f Record {...} parses as f (Record {...})
03:17:28 <Nereid> ??????
03:19:17 <Nereid> and not just the constructor, record updates do that too.
03:19:29 <ion> yep
03:19:39 <Nereid> what.
03:19:44 <ion> foo { } binds tighter than function application.
03:19:56 <ion> I add () in that case for clarity, though.
03:20:15 <Nereid> I don't understand why it is this way.
03:20:54 <Nereid> I feel like they ought to have the same fixity.
03:21:20 <Nereid> i.e. f x {...} y = ((f x) {...}) y
03:30:31 <shachaf> ion: Both types of foo {}
03:30:43 <shachaf> (Construction and update.)
03:31:03 <ion> yeah
03:40:14 <hard_coder> http://ideone.com/QKG6vf yay! I've finally got my algorithm right
03:40:19 <hard_coder> what should I name it?
03:42:46 <shachaf> Does it matter? It'll be a different name tomorrow anyway.
03:43:15 <hard_coder> :(
03:45:49 <ion> hard_coder: “QKG6vf”.
03:46:31 <hard_coder> it seems to be a basic string algorithm so I'm sure there's a name for it in some reference somewhere
03:46:40 <fmap> f is pretty good
03:48:20 <hard_coder> it's O(2^n) though :( so not suitable for practical use
03:49:19 <hard_coder> at least now I can solve the MIU puzzle ^^
03:50:47 <FUZxxl> Hello!
03:50:57 <FUZxxl> How many packages are available on Hackage right now?
03:52:39 <hard_coder> what do lambdas lack vs normal functions?
03:52:59 <companion_cube> nothing
03:53:10 <Botje> a name.
03:53:18 <FUZxxl> hard_coder: You can't do pattern guards with lambdas. You have to add an extra case to do that.
03:53:38 <Botje> not even with lambdacase?
03:53:39 <hard_coder> right
03:53:59 <shachaf> lambdacase isn't like multiple equations of a function.
03:54:23 <m3ga> FUZxxl: http://www.modulecounts.com/ (make sure you click Haskell on the right
03:55:03 <hard_coder> http://ideone.com/QKG6vf how would I condense g and f together to have just one function?
03:55:03 <FUZxxl> m3ga: Thank you!
03:55:13 <FUZxxl> Botje: Lambda case adds this feature.
03:55:14 <edwardk> > 4400/80
03:55:16 <lambdabot>   55.0
03:55:19 <FUZxxl> Even multiple equations
03:55:30 <shachaf> hedwardk
03:55:32 <edwardk> > 1/55
03:55:34 <lambdabot>   1.818181818181818e-2
03:55:55 <edwardk> sweet. i represent 1.8% =)
03:55:59 <shachaf> > 1.4 / 14 ** exp 2
03:56:00 <lambdabot>   4.7568962951825275e-9
03:56:05 <shachaf> 1.8% of what?
03:56:21 <edwardk> http://www.modulecounts.com/ said 4400 modules
03:56:30 <shachaf> Oh, on Hackage.
03:56:54 <merijn> > 1/4400
03:56:55 <lambdabot>   2.2727272727272727e-4
03:57:06 <merijn> I represent 0.000227% :p
03:57:08 <hard_coder> > 0 / 4400
03:57:09 <lambdabot>   0.0
03:57:12 <hard_coder> :(
03:57:21 <shachaf> > (-1) / 4400
03:57:23 <lambdabot>   -2.2727272727272727e-4
03:57:26 <shachaf> Aw, man!
03:57:27 <merijn> I need to split my code in more separate packages xD
03:57:48 <shachaf> GHC supports mutual recursion between packages, I hope.
03:57:50 <shachaf> It's only reasonable.
03:57:59 <shachaf> foo.cabal-boot
03:59:13 <hard_coder> when should I use Maybe vs Either/
04:03:42 * hackagebot llvm-tf 3.0.0.0 - Bindings to the LLVM compiler toolkit using type families.  http://hackage.haskell.org/package/llvm-tf-3.0.0.0 (HenningThielemann)
04:14:52 <hiptobecubic> hard_coder, if the failure needs to bring some information with it
04:17:54 <Kyraimion> hard_coder:  I'd say it depends on whether you want to encode values that can have either of two types or if you just need an additional element.
04:25:46 <Polarina> shachaf, GHC dosn't even do mutually recursive imports of modules.
04:26:13 <maukd> preflex uses cyclic imports
04:26:56 <Polarina> maukd, that's odd, I've always gotten an error stating I can't do that.
04:27:04 <merijn> Polarina: It does, but only with some ugly hack import files, I think
04:27:14 <maukd> you need to write a .hs-boot file
04:27:21 <Polarina> Ah.
04:37:03 <profligacy> What is Haskell?
04:37:31 <merijn> profligacy: A general purpose programming language
04:37:34 <strebe> It's a programming language. How technical of an answer do you want? Would comparing it with others help?
04:38:00 <shachaf> A biblical prophet.
04:38:33 <dzhus> Cake is a lie
04:38:39 <profligacy> It's not a server-side language, is it?
04:38:43 * hackagebot language-puppet 0.2.0.1 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.2.0.1 (SimonMarechal)
04:38:53 <dzhus> profligacy: you can use it to write server-side applications
04:39:00 <Polarina> profligacy, it can be if you want it to be.
04:39:02 <dzhus> see snap or yesod frameworks
04:39:03 <strebe> profligacy: it's general-purpose; it can be used server-side, and there are also web frameworks in it, etc
04:39:03 <bartavelle> where is the hackage build log for my packet ? haddocks were not generated :(
04:39:26 <dzhus> bartavelle: see under «build failure»
04:39:58 <merijn> profligacy: What does "server-side language" mean?
04:40:08 <profligacy> Under what scenarios would someone opt to familiarize himself/herself with Haskell over another HLL?
04:40:18 <bartavelle> dzhus, where exactly ?
04:40:38 <dzhus> bartavelle: on the hackage page of your package
04:40:58 <strebe> profligacy: http://www.haskell.org/haskellwiki/Web
04:41:06 <bartavelle> it doesn't seem to be there : http://hackage.haskell.org/package/language-puppet
04:41:31 <dibblego> bartavelle: it doesn't build immediately
04:41:36 <strebe> profligacy: it's got a higher initial learning curve than most HLLs, but also tends to make it easier to write less-buggy code once you get used to it
04:41:36 <bartavelle> ah !
04:41:41 * bartavelle will check later
04:41:45 <dibblego> bartavelle: give it 24 hours
04:41:54 <profligacy> thanks strebe
04:41:59 <bartavelle> thanks
04:42:06 <profligacy> im going to start looking into it.
04:42:31 <strebe> profligacy: I keep hearing good things about http://learnyouahaskell.com/ but haven't used that tutorial/book myself
04:42:45 <profligacy> thanks again.
04:42:53 <strebe> you're welcome; good luck and enjoy
04:44:47 <Kyraimion> Ah, I got cabal-dev ghci to work with cabal-install 1.16
04:52:30 <Chaze> meh, i'm trying to recover a link of a nice overview of haskell functions in prelude and some basic modules.
04:52:38 <Chaze> it had examples for each function
04:52:41 <Chaze> and a bit of prose
04:53:01 <Chaze> (it wasn't anywhere on haskell.org)
04:54:37 <Kyraimion> Chaze:  like this: http://ww2.cs.mu.oz.au/172/Haskell/tourofprelude.html ?
04:55:05 <Chaze> Kyraimion: not what i meant, but that's nice
05:12:21 <plat0> m
05:17:45 * Emmycakes pokes srhb`
05:18:45 <k0ral> what's the policy regarding the upload of packages in hackage of which one is not the maintainer ?
05:19:16 <k0ral> I have several dependencies that have stopped to work with GHC 7-6, and fixes are pretty straightforward
05:19:32 <k0ral> maintainers have already been contacted
05:19:59 <k0ral> to what extend am I allowed to upload a fix for such packages I'm not the maintainer of ?
05:21:03 <hard_coder> I love recursion
05:21:25 <merijn> k0ral: Well, I don't think hackage has any checks, but it's considered fairly (if not incredibly) rude to upload things without prior maintainer permission
05:21:52 <Jafet> These things should be written down somewhere
05:22:38 <hard_coder> http://ideone.com/szvwEY how would I refactor this to use Data.Text instead of [Char]?
05:24:59 <k0ral> merijn: well, if the maintainer keeps silent, maybe I'll consider getting rude :)
05:25:19 <merijn> k0ral: How long ago did you e-mail them?
05:26:06 <merijn> I'd say you should probably give them at least 1-2 weeks to respond
05:26:14 <Kyraimion> k0ral:  You could upload it under a different name
05:27:14 <k0ral> Kyraimion: hardly, getting a new name needs some people's approval
05:27:58 <merijn> k0ral: What do you mean?
05:28:23 <k0ral> merijn: it's been a week now, and I didn't email personally, it's a friend of mine who made a pull request on the github project of the library
05:28:45 <merijn> k0ral: I'd email the guy using the address listed on hackage
05:29:07 <merijn> k0ral: Not everyone pays attention to pull requests on github
05:29:09 <k0ral> merijn: well as far as I remember, to get a hackage account, I had to justify to hackage people which project I'm working on
05:29:19 <merijn> And by "not everyone" I mean "a whole lot of people"
05:29:34 <k0ral> merijn: pull requests trigger mails so that sounds redundant to me
05:29:47 <merijn> k0ral: Not if you disable github emails like me and many others
05:29:48 <Kyraimion> That depends on you github settings
05:30:04 <haskellnoob> min [10,5,3]
05:30:14 <Kyraimion> > min [10,5,3]
05:30:15 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
05:30:15 <lambdabot>    arising from a use ...
05:30:38 <merijn> min doesn't take a list
05:30:44 <merijn> > min 1 5
05:30:45 <lambdabot>   1
05:30:46 <Kyraimion> > minimum [1,2,3]
05:30:47 <lambdabot>   1
05:31:19 <k0ral> > foldl min 3 [1, 2]
05:31:20 <lambdabot>   1
05:31:29 <Jafet> hard_coder: http://hpaste.org/76525
05:31:30 <hiptobecubic> foldl1 min [1,2,3]
05:31:32 <hiptobecubic> > foldl1 min [1,2,3]
05:31:33 <lambdabot>   1
05:34:18 <Kyraimion> k0ral:  Also, the github-mail doesn't necessarily arrive at the same address. In any case, sending an email to the officially listed address avoids all the guesswork.
05:34:57 <k0ral> all right, let's write a mail
05:38:09 <Kyraimion> k0ral:  Btw. by "different name" I meant a different name for the package, not anonymously
05:38:47 <k0ral> Kyraimion: oh, right :)
05:41:04 <k0ral> oh god, glib still doesn't compile with latest GHC
05:41:23 <k0ral> this one I cannot fix locally
05:41:57 <Kyraimion> k0ral:  There is an arch package of haskell-glib for ghc 7.6.1, so there has to be a working version somewhere
05:43:05 <haskellnoob> how can i make a function which does this : min3 :: Int -> Int -> Int -> Int?
05:44:32 <Kyraimion> @djinn Int -> Int -> Int -> Int
05:44:32 <lambdabot> Error: Undefined type Int
05:44:43 <Kyraimion> @djinn a -> a -> a -> a
05:44:43 <lambdabot> f _ _ a = a
05:45:38 <maukd> :t flip (.) min (.) . min
05:45:39 <lambdabot> forall (f :: * -> *) a. (Ord a, Functor f) => a -> f (a -> a) -> f (a -> a)
05:45:59 <Kyraimion> haskellnoob:  How would you do it if you where tasked with doing it by hand?
05:46:17 <hard_coder> :t liftM2
05:46:18 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:46:40 <haskellnoob> minimum [1,2,3]
05:46:42 <hard_coder> liftM2 (&&) \x -> x == 3
05:46:50 <hard_coder> > liftM2 (&&) \x -> x == 3 4
05:46:51 <lambdabot>   <no location info>: parse error on input `\'
05:47:16 <Kyraimion> @type \x y y -> minimum [x,y,z]
05:47:17 <lambdabot>     Conflicting definitions for `y'
05:47:17 <lambdabot>     Bound at: <interactive>:1:3
05:47:17 <lambdabot>               <interactive>:1:5
05:47:21 <Kyraimion> @type \x y z -> minimum [x,y,z]
05:47:22 <lambdabot> forall a. (Ord a) => a -> a -> a -> a
05:47:29 <maukd> :t (.) min . ((.) . min)
05:47:30 <lambdabot> forall b (f :: * -> *). (Ord (f b), Functor f, Ord b) => b -> f b -> f b -> f b
05:48:26 <maukd> :t flip (.) min . ((.) . min)
05:48:27 <lambdabot> forall b. (Ord b) => b -> b -> b -> b
05:48:32 <maukd> phew
05:49:32 <maukd> :t (.)(.min)((.)(.)min)
05:49:33 <lambdabot> forall b. (Ord b) => b -> b -> b -> b
05:49:45 <maukd> @pl \min->(.)(.min)((.)(.)min)
05:49:45 <lambdabot> ap ((.) . flip (.)) ((.) .)
05:50:25 <maukd> :t ap((.)(.)(flip(.)))((.)(.))
05:50:26 <lambdabot> forall (f :: * -> *) a. (Functor f) => f (a -> a) -> f (f (a -> a))
05:51:53 <merijn> hard_coder: "min3 x y z = if x < y then min x z else min y z"? (although guards might be nicer then if/else)
05:52:50 <maukd> merijn: or you could use the unpl'd version of my code :-)
05:53:01 <maukd> @unpl (.)(.min)((.)(.)min)
05:53:01 <lambdabot> (\ c m j -> min c (min m j))
06:00:32 <b__> what's a good datatype for a numeric grid/matrix? Currently I have Array Int [Int] but is there a more sophisticated API for this?
06:01:54 <Eduard_Munteanu> b__: depends, do you intend to do linear algebra on it?
06:01:57 <b__> ye
06:02:12 <hiptobecubic> hmatrix
06:02:16 <Eduard_Munteanu> @hackage hmatrix
06:02:16 <lambdabot> http://hackage.haskell.org/package/hmatrix
06:02:47 <b__> ah thanks :}
06:03:04 <ClaudiusMaximus> you can also have   Array (Int, Int) Int   if you should want to write your own matrix library
06:03:58 <b__> aye
06:04:05 <Eduard_Munteanu> There are a few alternatives if you want to implement your own stuff... vector, repa...
06:05:21 <hpaste> heatsink pasted “Why is 'error' in a CAF?” at http://hpaste.org/76527
06:05:51 <hiptobecubic> b__, I did some playing around with repa, hmatrix is very fast it is hard to beat
06:05:57 <heatsink> I don't understand why stack traces sometimes end in CAFs
06:06:42 <b__> it uses GSL and lapack though, and I'm not super fond of that kind of dependency
06:07:03 <hiptobecubic> that is, in fact, why it's fast
06:07:09 <b__> yeah
06:08:12 <heatsink> If I run the program I pasted with +RTS -xc, it reports Main.CAF as the only entry in the stack trace.
06:08:35 <ceii> heatsink, isn't that because foo got inlined?
06:08:42 <heatsink> Since the error message depends on run-time input, I don't understand how it can be a CAF.
06:08:58 <heatsink> ceii, I get the same thing with a NOINLINE pragma on foo
06:09:08 <ceii> oh, then I've no idea
06:09:12 <hpc> compiled with profiling?
06:09:21 <heatsink> yeah, -prof -rtsopts
06:09:27 <hpc> also make sure you are putting a cost center on foo
06:09:32 <hpc> iirc, -prof isn't enough to do that
06:09:45 <hiptobecubic> need -fprof-auto-all i think?
06:10:11 <hpc> -fprof-auto... that
06:10:19 <heatsink> Ah, -auto made a difference
06:10:33 <hpc> if your GHC tab-completes, -fprof-<tab><tab>
06:10:51 <heatsink> Now I'm seeing the expected stack trace, with Main.CAF at the end
06:11:28 <heatsink> Apparently the code that calls main counts as a CAF
06:14:53 <heatsink> That clears up one thing, at least.
06:15:45 <parcs`> my ghc doesn't tab complete :(
06:15:49 * heatsink is trying to learn better techniques for tracking down errors
06:16:45 <hpc> parcs`: http://hackage.haskell.org/package/ghc-man-completion
06:18:29 <heatsink> I turned off the extra tab completion features, because the shell freezes up while the completion program runs.
06:19:04 <hpc> bummer
06:23:32 <startling> comonads can be used to represent cells that change based on the state around them. is there some neat way to represent changes that fold out from the center?
06:24:27 <startling> Specifically, I'm using a nested data U a = U [a] a [a]
06:27:41 <bartavelle> is there a way to tell hackage not to build my package with ghc 7.6 ? There is a build error with "catch" not being in scope with a dependency (hslua) ...
06:28:56 <bartavelle> iconv wont build either :/ bah I suppose there is way too much to do to fix it all
06:29:34 <startling> does 7.6 use a different base?
06:29:38 <startling> you could try that
06:30:11 <bartavelle> I am not sure what you mean, have a hard upper limit on the base package so that hackage understands it is for 7.4 ?
06:30:24 <startling> yeah
06:30:28 <parcs`> hpc: nice
06:30:30 <bartavelle> worth a try
06:31:13 <heatsink> Is that a zipper, startling?
06:31:30 <startling> heatsink: yeah
06:32:38 <heatsink> idk about how to use comonads.
06:33:18 <startling> heatsink, http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html was enlightening for me
06:33:45 * hackagebot xdot 0.2.2 - Parse Graphviz xdot files and interactively view them using GTK and Cairo  http://hackage.haskell.org/package/xdot-0.2.2 (DennisFelsing)
06:33:47 * hackagebot ghc-vis 0.5 - Live visualization of data structures in GHCi  http://hackage.haskell.org/package/ghc-vis-0.5 (DennisFelsing)
06:33:49 * hackagebot language-puppet 0.2.0.2 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.2.0.2 (SimonMarechal)
06:39:02 <heatsink> I see
06:40:13 <heatsink> My feeling is that if the change propagates information from one cell to the next like scanl does, there won't be an elegant way of writing it.
06:40:45 <startling> yeah. I was thinking I could implement a separate "spiral" function that spirals out from the center
06:40:55 <startling> and use that for the things I need
06:55:20 <hard_coder> how well does Haskell support structured programming?
06:56:06 <strebe> depends what you mean by structured programming, though I'd be tempted to say "very well" for most concepts of it?
06:56:48 <int-e> how well does an apple support gravity?
07:08:27 <mysticc> How to install a package from cabal with profiling enabled
07:09:59 <applicative> mysticc: it should probably be in your cabal config file
07:10:28 <applicative> since everything it depends on also needs to be compiled with -prof
07:23:42 <wereHamster> so download does not support basic auth, and download-curl does not follow redirects. What is the next best library I could use to simply download a file from a http server?
07:25:07 <Saizan> wereHamster: HTTP? a curl binding?
07:26:23 <wereHamster> I was hoping for something as simple as openURI that is provided by download/download-curl, but that would properly work.
07:31:03 <alpounet> wereHamster, actually the curl binding can follow redirects
07:31:18 <alpounet> and supports https
07:32:46 <alpounet> wereHamster, curlGetString url [CurlFollowLocation True, other options...]
07:33:13 <arcatan> http-enumerator used to be quite simple. i guess http-conduit has replaced it?
07:33:53 <wereHamster> what's the name of this package: http://hackage.haskell.org/package/HTTP-4000.2.5? The name that I can put into 'Build-depends'
07:34:07 <wereHamster> I tried both 'http' and 'HTTP' and neither works.
07:34:29 <alpounet> it's HTTP: http://hackage.haskell.org/package/HTTP
07:35:19 <wereHamster> nope, doesn't work: cabal: At least the following dependencies are missing: HTTP -any
07:36:31 <Saizan> which command are you using?
07:36:55 <Kyraimion> wereHamster:  try cabal install --only-dependencies or cabal-dev install-deps
07:36:55 <alpounet> wereHamster, this is one of the packages that come with haskell platform
07:37:19 <wereHamster> I put 'Build-depends:  HTTP >= 0' into my .cabal file and then ran 'cabal build'
07:37:37 <Kyraimion> wereHamster:  build does not fetch/install dependencies
07:37:38 <Saizan> cabal build won't pull the dependencies from hackage
07:38:07 <Kyraimion> wereHamster:  try cabal install --only-dependencies
07:38:13 <wereHamster> hm.. cabal has a long way to go to be user friendly...
07:38:41 <wereHamster> I, as a developer, shouldn't have to know these things. 'cabal build' should DWIM. period.
07:39:43 <Kyraimion> wereHamster:  cabal-dev build should arguably install dependencies, but it would be surprising(tm) if merely building a package changed the user-wide package database
07:41:31 <parcs`> you, as a developer, shouldn't have to know the intricacies of your build system?
07:43:56 <gripau> hi guys
07:44:00 <wereHamster> adding a 'build-depends' line to my cabal file worked before. Now it didn't. That was unexpected.
07:44:58 <byorgey> hi gripau
07:46:39 <gripau> i need help, i have a types problem in my function
07:46:49 <gripau> i'm noob
07:46:59 <gripau> can i paste the code here?
07:47:20 <Adeon> use one of the pasting services
07:47:23 <Adeon> ergh, I forgot th eurls
07:47:46 <Kyraimion> @where paste
07:47:47 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
07:48:03 <gripau> is very simply, only one line
07:48:17 <Adeon> one line should be fine to paste here, I believe
07:48:18 <Iceland_jack> gripau: you can paste one line
07:48:27 <gripau> thanks
07:48:32 <Iceland_jack> Asking whether you can paste it already takes up more space ;P
07:48:45 <gripau> calcPi n = 4*(sum [((-1)^x)/((2*x)+1) | x<-[1..100] , x<=n ])
07:49:17 <byorgey> gripau: what is the type of n?
07:49:24 <soiamso> callen: must be real
07:49:25 <gripau> n is Integer
07:49:44 <byorgey> gripau: ok, then the problem is that you can't use division (/) on integers
07:49:51 <byorgey> gripau: only on floating-point numbers
07:49:56 <parcs`> gripau: change <= n to <= fromInteger n
07:50:01 <byorgey> gripau: you can use 'fromIntegral' to convert from Integer to Double
07:50:22 <byorgey> @quote fromIntegral
07:50:22 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
07:50:28 <parcs`> > calcPi n = 4*(sum [((-1)^x)/((2*x)+1) | x<-[1..100] , x<=n ]) in calcPi 100
07:50:30 <lambdabot>   <no location info>: parse error on input `='
07:50:37 <parcs`> > let calcPi n = 4*(sum [((-1)^x)/((2*x)+1) | x<-[1..100] , x<=n ]) in calcPi 100
07:50:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:50:39 <lambdabot>    `GHC.Real.Integral a'
07:50:39 <lambdabot>   ...
07:50:48 <parcs`> > let calcPi n = 4*(sum [((-1)^x)/((2*x)+1) | x<-[1..100] , x<=fromInteger n ]) in calcPi 100
07:50:49 <lambdabot>   Ambiguous type variable `a' in the constraints:
07:50:50 <lambdabot>    `GHC.Real.Fractional a'
07:50:50 <lambdabot> ...
07:51:16 <parcs`> > let calcPi n = 4*(sum [((-1)**x)/((2*x)+1) | x<-[1..100] , x<=fromInteger n ]) in calcPi 100
07:51:17 <lambdabot>   -0.8485065989290095
07:51:31 <byorgey> aha, good catch
07:51:38 <byorgey> (^) is only for integral exponents
07:52:05 <gripau> thanks
07:52:13 <wereHamster> wow. HTTP does not support https. So that's out of the picture. What else http clients are there...
07:52:15 <gripau> :)
07:53:06 <wereHamster> so 'curlGetString' returns the contents as a String. Is that binary safe?
07:53:52 <drostie> somehow that doesn't seem to be calculating pi. :<
07:56:03 <gripau> drostie: it's an aproximattion for Leibniz
07:56:03 <gripau> http://en.wikipedia.org/wiki/Leibniz_formula_for_%CF%80
07:56:46 <drostie> gienah: aha, "Calculating π to 10 correct decimal places using direct summation of the series requires about 5,000,000,000 terms"
07:57:03 <drostie> er.
07:57:07 <drostie> gripau: ^
07:57:07 <hard_coder> how did you enter that π symbol
07:57:28 <drostie> hard_coder: congratulations, your IRC client is unicode-compliant. Not all are.
07:58:23 <nicoo> drostie: All decent clients are ;)
07:58:38 <hard_coder> Haskell is unicode-compliant
07:58:41 <nicoo> (as well as all decent terminals)
07:58:44 <hard_coder> maybe we should write an IRC client in Haskell ^^
07:59:16 <parcs`> > let calcPi n = 4*(sum [((-1)^x)/((2*fromIntegral x)+1) | x<-[1..100] , x<=n ]) in calcPi 100
07:59:17 <lambdabot>   -0.8485065989290095
07:59:22 <hard_coder> I'm not sure that my terminal/client is really unicode-compliant though because I keep seeing <?> symbols
07:59:31 <MostAwesomeDude> hard_coder: These days, it's usually the terminal that can't handle it.
07:59:31 <hard_coder> lol
07:59:38 <nicoo> hard_coder: A friend is writing an Haskell lib for writing IRC bots; the painful part is the protocol
08:00:09 <nicoo> Lots of different messages types to handle
08:00:41 <parcs`> > let calcPi n = 4*(sum [((-1)^x)/((2*fromIntegral x)+1) | x<-[1..n] ]) in calcPi 10000
08:00:43 <lambdabot>   -0.858307356409462
08:01:23 <nyc> parcs`: Use the continued fraction or Machin series.
08:01:43 <cmccann> hard_coder: 𝕬𝖍, 𝖇𝖚𝖙 𝖈𝖆𝖓 𝖞𝖔𝖚 𝖗𝖊𝖆𝖉 𝖙𝖍𝖎𝖘?
08:02:15 <hard_coder> cmccann: yes those
08:02:21 <nyc> parcs`: You'll just get tons of roundoff error.
08:02:24 <hard_coder> why can't I see those? :(
08:02:37 <cmccann> hard_coder, because they're a bunch of ridiculous code points
08:02:38 <parcs`> > let calcPi n = 4*(sum [((-1)^x)/((2*fromIntegral x)+1) | x<-[0..n] ]) in calcPi 10000
08:02:40 <lambdabot>   3.1416926435905346
08:02:44 <parcs`> off by one error :)
08:02:54 <hard_coder> if I paste those in my browser, I can see them fine though ^^
08:02:54 <gripau> yes
08:02:56 <gripau> 100 is n
08:03:06 <gripau> parcs`:  :)
08:03:17 <Kyraimion> cmccann:  You are very fond of fraktur, aren't you?
08:03:22 <nicoo> > let calcPi' n = sqrt $ 6*(sum [1/(fromIntegral x^2) | x<-[1..n]])
08:03:23 <lambdabot>   not an expression: `let calcPi' n = sqrt $ 6*(sum [1/(fromIntegral x^2) | x...
08:03:31 <nicoo> > let calcPi' n = sqrt $ 6*(sum [1/(fromIntegral x^2) | x<-[1..n]]) in calcPi' 1000
08:03:32 <lambdabot>   3.1406380562059946
08:03:36 <cmccann> hard_coder, hard to say whether it's the terminal, client, or font that doesn't support my stupid fraktur text though
08:03:51 <cmccann> Kyraimion, it's very stylish
08:04:00 <hard_coder> let n = 100000 in 4*(sum [((-1)^x/((2*fromIntegral x)+1) | x<-[0..n]])
08:04:12 <hard_coder> I think it's my consolas font ^^
08:04:16 <nicoo> hard_coder: YOu forgot the >
08:04:18 <hard_coder> > let n = 100000 in 4*(sum [((-1)^x/((2*fromIntegral x)+1) | x<-[0..n]])
08:04:20 <lambdabot>   <no location info>: parse error on input `|'
08:04:22 <Rc43> Hi, guys.
08:04:27 <cmccann> also I find it hilarious that unicode has code points for specific typefaces because mathematicians are weird
08:04:28 <byorgey> hi Rc43
08:04:36 <Rc43> Is package data-category OK?
08:04:44 <Kyraimion> cmccann:  I just wonder why there are code points for specific fonts. It's not a writing system of it's own, is it?
08:04:52 <byorgey> Rc43: what do you mean by "OK"?
08:05:00 <cmccann> Kyraimion, because of mathematicians, like I said
08:05:07 <nicoo> cmccann: Which monospaced font do you use for fraktur ?
08:05:27 <Rc43> It's build fails with message `Expecting two more arguments to `Dom f``.
08:05:39 <byorgey> Rc43: what version of GHC?
08:05:48 <Kyraimion> Blimey. And who let the mathematicians into the Unicode committee?
08:05:59 <Rc43> byorgey, 7.4.1 (hackage tals that it builded on 7.0)
08:06:03 <nicoo> Kyraimion: fraktur is a style, not a font ;)
08:06:04 <Rc43> *tells
08:06:12 <cmccann> Kyraimion, mathematical notation often uses different typefaces to denote different types of mathematical object, and the stuff in unicode are the ones mathematicians often use
08:06:21 <nicoo> Kyraimion: They let all kind of weirdos in the Unicode comitee
08:06:23 <byorgey> Rc43: probably because of some changes in kind defaulting, I'm guessing some type arguments need kind annotations
08:06:28 <parcs`> > let calcPi n = pi in calcPi 1000
08:06:29 <lambdabot>   3.141592653589793
08:06:33 <byorgey> Rc43: have you tried contacting the maintainer?
08:06:44 <Rc43> byorgey, not yet
08:06:48 <cmccann> nicoo, I have no idea. I installed a bunch of fonts so the fallback mechanism fills in gaps from whatever font has a symbol
08:06:50 <nicoo> Kyraimion: cf http://www.fileformat.info/info/unicode/char/1f4a9/index.htm
08:07:46 <nicoo> cmccann: I use a few fonts for my term (ordered by preference), but it's the first time I cannot display some Unicode characters :(
08:07:47 <drostie> parcs`: that's cheating. :P
08:08:03 <nicoo> drostie: I like his solution
08:08:30 <cmccann> nicoo, I deliberately installed a least two "full of obscure non-BMP code points" fonts
08:08:59 <Kyraimion> nicoo:  Yeah, well, it's a bit like saying we need different code points for sans and serif glyphs
08:09:05 <parcs`> > showCReal 1000 pi
08:09:07 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
08:09:12 <Kyraimion> Oh, I hope I'm not giving them ideas...
08:09:48 <cmccann> Kyraimion, Japanese has two phonetic scripts that are essentially identical, yet both are included
08:10:06 <cmccann> because each phonetic script is used for different grammatical or semantic purposes
08:10:23 <Kyraimion> cmccann:  At least they are different in principle, not just two ways of rendering the same letters
08:10:32 <CmrPantoufle> cmccann: are you talking about hiragana and katakana?
08:10:35 <drostie> parcs`: okay, that one finally has given you more digits of pi than I know. :P
08:10:40 <nicoo> cmccann: Which « full of obscure glyph » did you put ?
08:10:41 <cmccann> for that matter, why include upper and lower case letters at all? just pick one of each.
08:10:43 <nand`> I have a few upper case blackboard bold glyphs in my fonts but apparently no fraktur, nor the majority of blackboard bold letters
08:10:47 <drostie> I concede defeat.
08:10:55 <nand`> I wonder if there's some font I can use to “have them all”
08:11:06 <cmccann> nand`, sounds like you're only getting BMP code points
08:11:07 <parcs`> hehe :)
08:11:26 <cmccann> not seeing stuff outside the BMP can also be a rendering issue, not just a lack of fonts, I think
08:11:38 <drostie> I have a file for creating unicode glyphs in text files when I'm too lazy to use LaTeX. :D
08:11:39 <nand`> Maybe. How would I best test this?
08:11:40 <cmccann> CmrPantoufle, yes
08:12:08 <drostie> It includes the following blackboard bold chars: ℂℍℕℙℚℝℤ
08:12:16 <strebe> cmccann: upper and lower-case letters are important, as there's not a 1:1 relationship between them
08:12:21 <nand`> yes I see all of those
08:12:25 <cmccann> Kyraimion, anyway, the point is, as mathematical notation (which is what the fraktur letters are!) they ARE different in principle
08:12:37 <strebe> drostie: I see those
08:12:49 <nand`> A ⇔ a; B ⇔ b; C ⇔ c ... Z ⇔ z; of course there's a 1:1 relationship between them :P
08:13:15 <strebe> nand`: in English, yes; not in all languages that use something based on the Latin alphabet
08:13:22 <Palmik> Would you guys call partial functions (like head) type safe? I'm writing about a library of mine and in one of the paragraphs/chapters I would like to talk about safe interfaces & compare it with its predecessors (whose interfaces were not as safe -- some of the functions were for example partial) and I would like to use the "correct" terminology.
08:13:23 <drostie> nand`: the remaining ones are then missing because they're at U+1D5__.
08:13:35 <drostie> nand`: these ones are at U+21__ or so.
08:13:44 <drostie> nand`: see also https://en.wikipedia.org/wiki/Blackboard_bold
08:14:01 <nand`> I should note that I see most of those example symbols in firefox
08:14:05 <byorgey> One Font to rule them all, One Font to find them.  One Font for Unicode which all the glyphs defined them.
08:14:07 <nand`> so I at least have some font that can render them
08:14:20 <nand`> and by most I mean all
08:14:25 <cmccann> byorgey, I don't think there are disks big enough to store such a font yet
08:14:38 <nand`> I just don't see them over IRC / my terminal
08:14:40 <strebe> byorgey: really a bad idea, unfortunately
08:14:47 <byorgey> cmccann: you just need a Disk of Power
08:15:27 <byorgey> strebe: strange coincidence, the One Ring turned out to be a bad idea too
08:15:49 <Kyraimion> byorgey:  Bad for some, but not for others.
08:15:59 <drostie> nand`: ah. Well DejaVu Sans Mono and Ubuntu both seem to be okay with displaying 𝔸 for me.
08:16:19 <strebe> drostie: that's the combination I'm using too
08:16:29 <cmccann> byorgey, I hear they fixed that in a later release, and the One-Point-Three-Service-Pack-Two Ring is perfectly safe
08:16:29 <byorgey> now if we got into a discussion of moral relativism in Tolkien I suppose that would *really* be getting off topic.
08:16:31 <strebe> I switched my irc client to use DejaVu Sans Mono yesterday
08:16:42 <byorgey> cmccann: ahh, excellent
08:16:57 <drostie> Mine still displays in Ubuntu but my text editor is DejaVu Sans Mono. :D
08:17:46 <strebe> drostie: <pedantic mode>that's a font, not a text editor</>
08:18:13 <byorgey> That's not a text editor.  That's a space station!
08:18:19 <cmccann> 𝕆𝕙 𝕪𝕖𝕒𝕙, 𝕒𝕝𝕤𝕠, 𝕙𝕒𝕧𝕖 𝕤𝕠𝕞𝕖 𝕓𝕝𝕒𝕔𝕜𝕓𝕠𝕒𝕣𝕕 𝕓𝕠𝕝𝕕.
08:18:24 <strebe> byorgey: omg, it's full of unicode :D
08:18:55 <drostie> "At the farmer's market with my so-called girlfriend / she hands me her cell phone, says it's my dad / maaaan, this ain't my dad, this is a cell phone! / I took it, and threw it on the GROUUUUUND."
08:19:09 <Boreeas> cmccann: Beautiful.
08:19:30 <cmccann> 𝓣𝓱𝓮𝓻𝓮'𝓼 𝓪𝓵𝓼𝓸 𝓽𝓱𝓲𝓼, 𝔀𝓱𝓲𝓬𝓱 𝓲𝓼 𝓹𝓻𝓮𝓽𝓽𝔂 𝓷𝓲𝓬𝓮 𝓽𝓸𝓸.
08:19:45 <strebe> wow
08:20:39 <hard_coder> how come it doesn't display on my terminal, but displays fine in gvim?
08:20:53 <Kyraimion> Is there a way to deactivate Unicode rendering and retain the (unfortunately unicode-aware) font?
08:20:57 <cmccann> 𝔞𝔫𝔡 𝔱𝔥𝔦𝔰 𝔦𝔰 𝔱𝔬𝔱𝔞𝔩𝔩𝔶 𝔬𝔫-𝔱𝔬𝔭𝔦𝔠 𝔟𝔢𝔠𝔞𝔲𝔰𝔢 𝔍'𝔪 𝔲𝔰𝔦𝔫𝔤 𝔞 𝔥𝔞𝔰𝔨𝔢𝔩𝔩 𝔭𝔯𝔬𝔤𝔯𝔞𝔪 𝔱𝔬 𝔡𝔬 𝔱𝔥𝔢 𝔠𝔬𝔫𝔳𝔢𝔯𝔰𝔦𝔬𝔫. 𝔥𝔢𝔥.
08:21:13 <strebe> cmccann: tell me more
08:21:34 <drostie> Kyraimion: you mean convert the characters to whatever they're "supposed to be"?
08:21:37 <strebe> hard_coder: do you have a unicode-friendly terminal?
08:21:50 <CmrPantoufle> Apparently tmux has some issues with fonts
08:22:04 <hard_coder> strebe: I'm using uxterm
08:22:05 <cmccann> ion made a better program though: https://gist.github.com/3909452#file_styles.hs
08:22:17 <Kyraimion> drostie:  No, I just don't want to see the nonsense. I guess liberal amounts of scotch will do the trick.
08:22:44 <drostie> Kyraimion: that function is best served with banhammers unfortunately. :<
08:23:54 <strebe> hard_coder: odd
08:24:15 <strebe> cmccann: what's the program called?
08:24:21 <nand`> hmm, seems firefox is unable to open my #haskell IRC log
08:24:43 <cmccann> strebe, mine is just a quick hack in a file called UnicodeAbuse.hs :P
08:24:53 <Kyraimion> Aptly named!
08:25:02 <strebe> cmccann: any chance of hpaste'ing it? ;-)
08:25:04 <cmccann> truth in advertising
08:25:15 <cmccann> strebe, see that gist link I gave
08:25:17 <cmccann> it's better than mine
08:25:22 <strebe> Ahh, missed it
08:25:47 <cmccann> on the bright side, all this fraktur and other nonsense are still classified as letters by unicode
08:25:52 <cmccann> which means they're valid for identifiers in Haskell
08:26:01 <cmccann> so you can make your code look awesome!
08:26:11 <cmccann> (disclaimer: may not actually be awesome in practice)
08:26:14 <b__> except it gets super annoying to type after a while
08:26:18 <b__> yes
08:26:29 <nand`> cmccann: I used vim to paste the lines you wrote earlier into a separate file, opened that in firefox, and was able to read it all
08:26:30 <cmccann> where a while is about three letters
08:26:38 <nand`> so at least weechat seems to be getting it from the server and saving it correctly
08:26:41 <nand`> I guess it's my temrinal
08:26:43 <nand`> terminal*
08:26:56 <strebe> cmccann: I'd *hope* fraktur would be classified as letters! I have a fair number of books written in it
08:27:18 <Kyraimion> I wonder if it wouldn't be better to have code-points that set the style for following characters, so they could be ignored by clients that don't support it
08:27:39 <cmccann> strebe, well they're mathematical notation as far as unicode is concerned, so it wouldn't be unreasonable to not classify them as letters in the use-these-to-write-words sense
08:27:54 <parcs`> cmccann: your unicode broke weechat :(
08:27:57 <strebe> Kyraimion: hmm. that starts going down a dark path of embedding a styling markup language into unicode
08:28:16 <cmccann> writing actual text with the fraktur or whatever is a complete and utter misuse of the whole thing
08:28:28 <strebe> cmccann: bizarre choice for classification. I use them more as letters than as math symbols
08:28:40 <cmccann> if you want text that looks like that, that's what fonts are for, not code points
08:28:50 <strebe> cmccann: not if you're into older German texts...
08:29:39 <strebe> give me ſ and ß or watch me be sad ;-)
08:29:42 <klr> how is haskell's length function written?
08:29:48 <nand`> hmm, I enabled the ‘unicode3’ patch for my terminal to use 21 bits instead of 16 for unicode characters; but it doesn't seem to have changed a thing
08:29:55 <cmccann> strebe, I'd still expect you'd have a fraktur font for something like that
08:29:59 <nand`> @src length
08:30:00 <lambdabot> Source not found. I've seen penguins that can type better than that.
08:30:12 <nand`> length [] = 0; length (x:xs) = 1 + length xs -- I guess
08:30:16 <strebe> nand`: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#length
08:30:21 <klr> ok
08:30:24 <klr> thanks4
08:30:25 <cmccann> and the mathematical symbols don't include those other letters you mentioned which I'm too lazy to copy+paste
08:30:36 <nand`> ah, it uses some hacks for efficiency it seems
08:30:50 <nand`> + tail recursion with an added parameter to accumulate the sum
08:31:07 <strebe> cmccann: yeah, they're part of Fraktur, but I haven't seen them used in math
08:31:18 <Kyraimion> ß is a normal German letter
08:31:47 <strebe> Kyraimion: yes, and a variant of it was a normal German letter when German was generally written in Fraktur too
08:32:25 <strebe> http://en.wikipedia.org/wiki/Fraktur
08:32:26 <cmccann> it originated as a ligature of some sort for "ss", didn't it?
08:32:33 <strebe> cmccann: essentially
08:32:38 <a215> what's a good BSD/MIT/etc starting point for an HOpenGL app?
08:32:55 <Kyraimion> cmccann:  It used to be a ligature of long s (ſ) and z
08:33:02 <cmccann> ah, that makes sense
08:33:16 * cmccann wishes long s was still a thing in english, it looks neat
08:33:18 <a215> :t foldl'
08:33:19 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:33:21 <joeysd> Can I ask Cabal questions in here? I installed haskell-platform, did cabal update, and was told "there is a new version of cabal-install available", so I did "cabal install cabal-install", no errors, but then i still get told to upgrade. Any idea why the new version might not be 'sticking'?
08:33:43 <a215> mmn
08:33:44 <klr> what does @ means in "capital all@(x:xs) = "The first letter of " ++ all ++ " is " ++ [x] " ?
08:33:46 <dcoutts> joeyh: your existing version is first on your $PATH
08:33:59 <joeysd> dcoutts: make sense, cheers
08:34:02 <strebe> klr: you can refer to the whole list x:xs as 'all'
08:34:12 <hpc> joeysd: "which cabal" will probably point to /usr/local/...
08:34:16 <Eduard_Munteanu> klr: it's an at-pattern. It names (x:xs) as "all".
08:34:23 <hpc> you can upgrade that version by doing sudo cabal install cabal-install --global
08:34:34 <hpc> or you can add your .ghc/bin (iirc) to your path
08:34:43 <strebe> so you don't have to reconstruct x:xs and make a new list to display all
08:34:44 <klr> okey, strange that learn you a haskell using @ without explaining it...
08:34:56 <nand`> “Enable direct support for displaying unicode codepoints above 65535 (the basic multilingual page). This increases storage requirements per character from 2 to 4 bytes. X11 fonts do not yet support these extra characters, but Xft does.”
08:34:57 <klr> ups it des
08:35:00 <klr> does*
08:35:02 <klr> sry !
08:35:20 <nand`> I use Xft for fonts, so that shouldn't be the issue.. hmm
08:41:05 <hpaste> nomeata pasted “failure” at http://hpaste.org/76529
08:42:06 <nomeata> Hi. I don’t understand the error message in  http://hpaste.org/76529, given these two imports – to me, it seems that both types ought to be the same:
08:42:15 <nomeata> import Language.JavaScript.Parser.Lexer
08:42:16 <nomeata> import qualified Language.JavaScript.Parser.AST as AST
08:43:50 * hackagebot tuple-hlist 0.1.0.0 - Functions to convert between tuples and HLists.  http://hackage.haskell.org/package/tuple-hlist-0.1.0.0 (NicolasDudebout)
08:46:55 <byorgey> nomeata: looks like the two types are coming from different versions of the package
08:47:05 <byorgey> nomeata: some sort of diamond dependency problem, perhaps
08:47:10 <nomeata> byorgey: yes; just saw that this is actualyl the test suit that is failing
08:47:29 <nomeata> byorgey: so it is using partly the previously built library and partly the sources of the library.
08:47:36 <byorgey> right, makes sense
08:48:08 <strebe> cmccann: dumb question: are you able to see unicode characters in ghci? using gist shows me codepoints with \
08:49:05 <cmccann> try using putStrLn instead of just letting it echo stuff back to you
08:49:27 <strebe> cmccann: ahh, awesome, thank you
08:49:48 <strebe> cmccann: knowing that is going to save me *so* much aggravation
08:50:05 <cmccann> it's "show" that's doing the codepoint escaping I think
08:50:29 <a215> wait...is Cube written in haskell?
08:50:37 <cmccann> note the difference between typing "\\foo" at the GHCi prompt vs. putStrLn "\\foo"
08:50:38 <strebe> makes sense. I hadn't realized that, and it frequently caused me some annoyance
08:50:55 <a215> o n/m lambdacube
08:51:04 <strebe> cmccann: nice :)
09:01:58 <Oscar> Hii ! can someone help me with a haskell parser function :)
09:05:45 <a215> in order to store something in state, and occasionally generate something to append onto it, in a 3d program... does that mean the entire display loop has to be recursive?
09:06:02 <a215> trying to understand the FRP approach
09:08:21 <Kyraimion> Is there a testing framework that works well with cabals detailed-1.0 test test interface?
09:08:54 <byorgey> Oscar: just paste your code somewhere (e.g. hpaste.org) and ask your question
09:08:59 <byorgey> if someone can answer it, they will
09:09:16 <Oscar> okey thx ! sec
09:09:22 <PcManiac92> hi ski!
09:15:35 <benjamin`> hello
09:18:35 <byorgey> hi benjamin`
09:20:16 <benjamin`> i have a somewhat difficult question (i think)
09:20:43 <benjamin`> i'm trying to implement tarjan's fast union-find algorithm in haskell
09:21:13 <a215> :t ($=)
09:21:14 <lambdabot> Not in scope: `$='
09:21:27 <a215> anyone know what that means $=
09:21:29 <benjamin`> and i'm not sure how to begin
09:21:57 <benjamin`> because it seems like it would need destructive updates
09:22:10 <geekosaur> a215, it's not a standard operator, what it means depends on what package defines it
09:22:15 <benjamin`> i can do it naively, but i want to achieve close to maximal effeciency
09:22:15 <a215> hopengl
09:22:24 <a215> i guess it overwrites something in state?
09:23:21 <a215> is there something equivalent to ".inspect" in haskell, where i can dump the type and contents of something to console?
09:24:00 <geekosaur> I am guessing it's http://hackage.haskell.org/packages/archive/StateVar/latest/doc/html/Data-StateVar.html#v:-36--61-
09:24:19 <a215> interesting
09:24:38 <a215> and i suppose this 'get' function does the reverse
09:25:06 <geekosaur> as for inspection, typically you use deriving (Show) on your own types.  some things, like IORefs, do not have Show instances
09:25:34 <a215> hmm
09:25:53 <byorgey> benjamin`: yes, union-find is tricky in Haskell.  It may well actually require destructive updates.
09:26:20 <a215> what about IO bO
09:26:24 <a215> how do i coerce that to string?
09:26:36 <byorgey> a215: you can't.
09:26:40 <a215> sucks
09:26:44 <benjamin`> damn i don't know hwo to use irc
09:27:24 <byorgey> a215: something of type   IO a   is a description of an imperative computation that, when run, may have some side effects and then return a value of type a.
09:27:34 <nand`> cmccann: which font are you using to display the blackboard bold, fraktur etc. stuff again? And is it monospace?
09:27:34 <a215> oh
09:27:36 <byorgey> a215: In particular an   IO String   and a   String   are completely different things.
09:28:04 <geekosaur> @quote ls
09:28:04 <lambdabot> cheezey says: photography, cocktails, motorcycling, girls.they're all within reach once you quit irc
09:28:06 <cmccann> @quote extract.*IO
09:28:06 <lambdabot> monochrom says: How do you extract the IO out of IO String?
09:28:07 <geekosaur> hm
09:28:13 <geekosaur> @quote ls.*files
09:28:14 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
09:28:36 <cmccann> nand`, I have no idea what font it's getting those from, sorry
09:29:51 <PcManiac92> Aufgabe 2.1 (4 Punkte). Schreiben Sie ein Haskell-Modul mit 2 Funktionen, die die Anzahl der Autos bzw. der Motorräder auf einem Parkplatz berechnen. Die Eingabe ist jeweils die Anzahl der Fahrzeuge und die Anzahl der Räder. Wie in der Vorlesung besprochen sollen die Funktionen die Anforderungen an die Eingabe überprüfen und im Fehlerfall die Verletzung melden.
09:30:44 <benjamin`> @run do {x <- [1,2]; y <- [3,4]; return (x*x,y*y)}
09:30:45 <lambdabot>   [(1,9),(1,16),(4,9),(4,16)]
09:30:50 <Eduard_Munteanu> PcManiac92: can you translate that?
09:31:02 <a215> oh wow, so preservingMatrix handles all this
09:31:05 <a215> amazinngggg
09:31:36 <PcManiac92> Exercise 2.1 (4 points). Write a Haskell module with 2 functions that the Calculate the number of cars or motorcycles on a parking lot. entering each is the number of vehicles and the number of wheels. As in the lecture discussed, the functions check the requirements to the input and in the Failure to report the injury.
09:33:56 <Eduard_Munteanu> PcManiac92: ok, what are you having trouble with?
09:34:28 <PcManiac92> i dont know how to start
09:34:38 <a215> 4x + 2y = wheels, x+y=vehicles, solve for x and y
09:41:46 <PcManiac92> how do i solve for x and y?
09:43:01 <Eduard_Munteanu> PcManiac92: wheels and vehicles are your inputs, you can consider those knowns. It's a pretty simple system of simultaneous equations.
09:44:49 <Eduard_Munteanu> PcManiac92: do you know how to solve such simultaneous equations?
09:45:40 <wires> try to rewrite eqns into x=.. and y=.. ; 4x+2y=wheels => 4x=wheels-2y -> x=(wheels-2y)/4, y=vehicles-x, you know x, so subst into y
09:45:52 <drostie> In case anyone is curious here is the "O(1)" Fibonaccis algorithm in Haskell:  https://gist.github.com/3923947
09:46:09 <wires> hm i'm giving away the answer.. sorry
09:46:39 <drostie> I was absolutely stunned when it actually started working for small n. ^_^
09:46:45 <wires> better if you try to figure this out yourself, or it won't be an exercise :)
09:47:26 <MostAwesomeDude> PcManiac92: This is homework, isn't it?
09:47:52 <PcManiac92> yup
09:48:15 <MostAwesomeDude> Go ask your TA.
09:50:11 <fmap> drostie: that's not O(1)
09:50:29 <PcManiac92> but i want to ask my friends from haskell irc :)
09:51:25 <drostie> fmap: the output of fibs(n) has size O(2^n), there is no O(1) solution; this is the "O(1)" solution. ^_^
09:52:33 <sipa> drostie: i'd say it's O(n)
09:52:39 <drostie> it is the solution which does not compute all of the fibs from 1 to 1 million to tell you fibs(1 million).
09:52:45 <cmccann> is this "O(1) if you pretend that arithmetic and exponentiation are free"?
09:53:20 <cmccann> kind of like how hash tables are "O(1) if you pretend computing hash functions is free"
09:53:33 <drostie> right, if you pretend that arithmetic and exponentiation on long integers are free then this is O(1). In reality even exponentiation goes like log(n)
09:53:55 <Eduard_Munteanu> PcManiac92: well, you got a few answers, there really isn't much else we could do besides giving away the solution.
09:54:37 <Eduard_Munteanu> (which we pretty much did, except for the Haskell implementation)
09:55:32 * cmccann has a minor pet peeve about using big-O while treating as constant-time operations that very much depend on some feature of the input data
09:55:51 <ryanos> just curious - why not give him the haskell implementation also ?
09:56:04 <MostAwesomeDude> It's homework.
09:56:27 <ryanos> understand but.. at least he tried to find some place to vent his pain :)
09:56:41 <ryanos> most don't even do that
09:56:56 <MostAwesomeDude> No, no, I mean, it's not really helpful to learning to give people answers to homework.
09:57:09 <parcs`> > let fib n = (((1 + sqrt 5)/2)^n - ((1 - sqrt 5)/2)^n)/sqrt 5 in map fib [0..10]
09:57:10 <lambdabot>   [0.0,1.0,1.0,2.0,3.0,5.0,8.0,13.0,21.0,34.0,54.99999999999999]
09:57:13 <cmccann> it's kinda the opposite of helpful
09:57:35 <ryanos> then what's a better learnin heuristic for them? let them stab in the dark for a long time ?
09:57:37 <sipa> > let fib n = (((1 + sqrt 5)/2)^n + ((1 - sqrt 5)/2)^n)/sqrt 5 in map fib [0..10]
09:57:38 <lambdabot>   [0.8944271909999159,0.4472135954999579,1.3416407864998738,1.788854381999831...
09:57:49 <Eduard_Munteanu> Well, IDK if he actually undestands the answer (which would be helpful even if given away), but at this point it's so simple it makes me think he's missing some background.
09:58:24 <ryanos> imho would have been an awesome occasion to awe him on how easy haskell can actually solve all of that for him...
09:58:36 <bizzle_> hi guys
09:58:49 <ryanos> and hopefully inspire him (?)
09:58:58 <Eduard_Munteanu> It's as much a simple math problem, as a Haskell thing.
09:58:59 <bizzle_> just trying to learn some haskell
09:59:00 <Eduard_Munteanu> bizzle_: hi
09:59:17 <bizzle_> hry Eduard
09:59:21 <bizzle_> *hey
09:59:25 <drostie> > let fib n = (((1 + sqrt 5)/2)**n - ((1 - sqrt 5)/2)**n)/sqrt 5 in map fib [0..10]
09:59:27 <lambdabot>   [0.0,1.0,1.0,2.0,3.0000000000000004,5.000000000000001,8.000000000000002,13....
09:59:35 <drostie> sipa: ^
09:59:46 <ryanos> thx ed: point is not about how complicated it is but how helpful/inspiring is one approach or another..
10:00:09 <benjamin`> > let fib n = (((1 + sqrt 5)/2)**n - ((1 - sqrt 5)/2)**n)/sqrt 5 in
10:00:09 <benjamin`> 	  map (round . fib) [0..10]
10:00:10 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:00:17 <benjamin`> > let fib n = (((1 + sqrt 5)/2)**n - ((1 - sqrt 5)/2)**n)/sqrt 5 in
10:00:17 <benjamin`> 	   map (round . fib) [0..10]
10:00:18 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
10:00:28 <benjamin`> > let fib n = (((1 + sqrt 5)/2)**n - ((1 - sqrt 5)/2)**n)/sqrt 5 in map (round . fib) [0..10]
10:00:31 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55]
10:00:41 <benjamin`> stupid indentation
10:01:17 <drostie> benjamin`: you can actually skip the second part if you round.
10:01:20 <drostie> > let fib n = (((1 + sqrt 5)/2)**n)/sqrt 5 in map (round . fib) [0..10]
10:01:23 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55]
10:02:01 <Eduard_Munteanu> Floating point stuff should be really cheap though.
10:02:18 <Eduard_Munteanu> (especially say exponentiation)
10:02:29 <benjamin`> nice
10:03:49 <drostie> Eduard_Munteanu: the fibs grow like phi^n meaning that floating points will fail to be accurate enough to give you the proper integer after at least 50-60 terms, hence the GoldenPair type in my gist.
10:04:34 <cmccann> if you limit your fib function to outputs that fit in typical finite-precision types, I think it's hard to justify any implementation other than "precomputed look-up table".
10:04:45 <cmccann> because you won't need to store very many values
10:07:01 <wereHamster> is there an existing IO+Maybe monat transformer or do I have to write one myself?
10:07:26 <drostie> cmccann: apparently 94 to reach 64-bit unsigned.
10:07:31 <Eduard_Munteanu> wereHamster: there's MaybeT. And IO can't be a transformer.
10:08:14 <Eduard_Munteanu> @unmtl MaybeT IO
10:08:14 <lambdabot> Plugin `unmtl' failed with: `MaybeT IO' is not applied to enough arguments, giving `/\A. IO (Maybe A)'
10:08:17 <Eduard_Munteanu> @unmtl MaybeT IO a
10:08:17 <lambdabot> IO (Maybe a)
10:08:43 <drostie> I like how fibs(10 million) takes a few seconds to calculate but about half a minute to print to the terminal though. :D
10:10:27 <drostie> It is apparently 2 089 877 decimal digits long
10:10:30 <cmccann> haha
10:10:49 <hard_coder> how do I use haskell to scan my .history files and generate statistics? (find out which is my most-executed program)?
10:12:34 <drostie> hard_coder: first, you learn Haskell... :P
10:12:49 <hard_coder> haskell takes a while to learn :(
10:13:14 <hiptobecubic> it does
10:13:21 <hard_coder> still beats perl though ^^
10:13:21 <parcs`> use perl
10:13:25 <parcs`> :P
10:13:39 <hiptobecubic> cat .bash_history  | awk '{ print $1 }' | sort | uniq -c | sort
10:13:44 <cmccann> just write perl in haskell, then use that
10:13:52 * hackagebot pandoc 1.9.4.3 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.4.3 (JohnMacFarlane)
10:14:12 <parcs`> hiptobecubic: oh you pragmatist
10:14:39 <hiptobecubic> 119 ls, 76, cd, 65 vim, 32 ./main  :)
10:15:17 <parcs`> this works for .histfile (zsh) cat .histfile | sort | uniq -c | sort -n
10:15:49 <parcs`> 659 git log
10:15:53 <hiptobecubic> the -n isn't needed i don't think
10:15:55 <parcs`> 415 ..
10:16:05 <int-e> @type interact $ unlines . reverse . map show . take 10 . sort . map (length &&& sort) . group . sort . map (head . words) . lines
10:16:06 <parcs`> hiptobecubic: it is for me
10:16:07 <lambdabot> IO ()
10:16:21 <hiptobecubic> your uniq -c doesn't output whitespace?
10:16:29 <int-e> uhm. length &&& head. mmpf :)
10:16:42 <wmeyer> hello, I'm having a weird cabal problem. All I want to do to install pandoc: http://pastebin.com/TDVJBJdX. Thanks for any help!
10:16:45 <maukd> The paste TDVJBJdX has been copied to http://hpaste.org/76531
10:17:08 <parcs`> hiptobecubic: it does "    658 git-log"
10:17:50 <hard_coder> my favorite program seems to be vim :(
10:18:11 <int-e> funny. 86 python 84 time 41 cvc4 ... what have I been up to?
10:18:12 <portnov> hi all
10:18:56 <parcs`> 2271 cd, 783 git :(
10:18:59 <portnov> Q: how to add xmlns: declaration to XML node using HXT?
10:19:17 <portnov> for example, I need <node xmlns="...">
10:19:19 <rwbarton> 55 ls 39 cd 32 ghc
10:19:34 <parcs`> people still manually type ls?
10:19:44 <cmccann> heh, my most common commands are cd, ls, exit, and ghc in roughly that order
10:19:52 <cmccann> this probably tells you a lot about what I do with terminal windows
10:19:54 <portnov> mkqelem (mkQName "" "node" "...") creates <node> :/
10:20:06 <rwbarton> I guess ctrl-D does not show up in .bash_history
10:20:24 <int-e> (500 lines of history is not nearly enough to give a fair picture)
10:20:31 <parcs`> if you use zsh and type ls manually, please add this to your rc file right now  'function chpwd() { ls }'
10:21:04 <parcs`> it runs ls every time you change directories
10:21:15 <fmap> parcs`: if you use zsh and type cd manually, …
10:21:22 <parcs`> indeed
10:21:28 <parcs`> 'setopt autocd'
10:22:02 <parcs`> makes it so that you can just type DIR to change directories instead of cd DIR
10:22:26 * cmccann wonders why ghci isn't higher on the list, then recalls that he usually ends up with two or three terminal windows running ghci perpetually
10:22:40 <wmeyer> anybody knows how to install pandoc
10:23:01 <wmeyer> we also have a package manager similar to cabal.
10:23:16 <wmeyer> removing .cabal didn't work
10:23:31 <dcoutts> wmeyer: so what that error is saying is this: pandoc needs json, json needs a later syb, but you cannot upgrade your syb because base needs the existing version, and base itself cannot be upgraded.
10:23:52 * hackagebot categories 1.0.4 - Categories  http://hackage.haskell.org/package/categories-1.0.4 (EdwardKmett)
10:23:54 * hackagebot happstack-yui 7373.5.3 - Utilities for using YUI3 with Happstack.  http://hackage.haskell.org/package/happstack-yui-7373.5.3 (DagOdenhall)
10:23:59 <dcoutts> wmeyer: so in summary, that version of pandoc really only works with later versions of base, and hence later versions of ghc
10:24:05 <wmeyer> dcoutts: thanks a lot! that solves my problem :-)
10:24:26 * cmccann wonders if dcoutts's IRC client pings him whenever someone mentions cabal
10:24:49 <dcoutts> wmeyer: you might be able to install an older pandoc. Note that if you use the latest version of cabal, it's solver is better at working things out in situations where you need to install older versions of things.
10:25:00 <int-e> dcoutts: or an earlier version of json? (I don't know, just going by what you said)
10:25:17 <dcoutts> int-e: maybe, the new cabal solver might do better.
10:25:35 <edwardk> cmccann: given the ability for the word cabal to bring dcoutts out of days of hibernation, like how lens brings me out of days of hibernation i'd hazard a guess that the answer is yes. ;)
10:26:29 <cmccann> edwardk, yeah he seems to materialize with surprising regularity to deftly solve problems with cabal
10:26:39 <wmeyer> dcoutts: thanks, can we install ghc via cabal?
10:27:05 <dcoutts> wmeyer: no, but you can upgrade cabal using cabal
10:27:14 <edwardk> i'm torn. my usual trollish nature wants to form a cabal of people who talk about being in a cabal all the time, but I can't bring myself to do it. ;)
10:27:17 <dcoutts> cabal install cabal-install
10:27:37 <dcoutts> edwardk: you'd be breaking the first rule
10:27:49 <edwardk> hah
10:28:03 <hard_coder> > let x = 5
10:28:04 <lambdabot>   not an expression: `let x = 5'
10:28:23 <hard_coder> but LYAH says that let bindings are expressions
10:28:47 <edwardk> you see thats why i wouldn't just such a cabal, just hypothesize about its existence, since it has the same net effect on your poor IRC client. hopefully their bylaws can't bind non-members ;)
10:28:52 <cmccann> > let x = 5 in x
10:28:53 <lambdabot>   5
10:28:57 <wmeyer> dcoutts: what cabal-install buys me? I'll then download a ghc tarball ;-)
10:29:09 <parcs`> "let BINDINGS in EXPR" is an expression
10:29:16 <hard_coder> ah
10:29:26 <edwardk> er wouldn't join such
10:29:32 <cmccann> running "cabal install cabal-install" always feels so terribly meta
10:29:41 <rwbarton> I never noticed before that error message wasn't just "parse error" or some such
10:29:47 <rwbarton> > module Foo where {}
10:29:48 <lambdabot>   <no location info>: parse error on input `module'
10:29:48 <hard_coder> I like where clauses better than let
10:29:48 <hiptobecubic> > let x = let y = x in y
10:29:50 <lambdabot>   not an expression: `let x = let y = x in y'
10:29:54 <hiptobecubic> > let x = let y = x in y in x
10:29:58 <lambdabot>   mueval-core: Time limit exceeded
10:30:05 <rwbarton> > data X = X Int
10:30:06 <lambdabot>   <no location info>: parse error on input `data'
10:30:21 <dcoutts> wmeyer: if it's easy enough for you to upgrade ghc, then fine. Just saying that it's possible to work with an older ghc, and older other packages, and that a new cabal will make that easier to do.
10:30:43 <rwbarton> why is "let x = 5" "not an expression" while this other stuff is "parse error"
10:30:49 <wmeyer> dcoutts: no it's not a problem to upgrade, thanks.
10:31:09 <cmccann> rwbarton, because "let x = 5" parses fine
10:31:13 <cmccann> and makes sense in a do block
10:31:19 <cmccann> would be my guess, at least
10:31:23 <rwbarton> but it doesn't parse fine as an expression
10:31:30 <rwbarton> hmm
10:31:32 <rwbarton> > x = 5
10:31:33 <lambdabot>   <no location info>: parse error on input `='
10:31:40 <hiptobecubic> it 'lexes' fine, i guess
10:31:54 <rwbarton> that one makes sense in a where block
10:32:01 <rwbarton> weird
10:32:04 <hiptobecubic> but where is special
10:32:05 <cmccann> > do let x = 5
10:32:06 <lambdabot>   <no location info>:
10:32:06 <lambdabot>      The last statement in a 'do' construct must be an ...
10:32:14 <hiptobecubic> > do 3
10:32:15 <lambdabot>   3
10:32:16 <rwbarton> > x <- 5
10:32:17 <lambdabot>   not an expression: `x <- 5'
10:32:20 <hiptobecubic> which monad was that?
10:32:21 <rwbarton> huh
10:32:25 <cmccann> rwbarton, aha
10:32:28 <hiptobecubic> @type do 3
10:32:29 <lambdabot> forall t. (Num t) => t
10:32:45 <rwbarton> so I guess it parses things-that-can-be-in-do-blocks
10:32:49 <rwbarton> for some reason
10:32:54 <Ralith> :t do return
10:32:55 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:32:56 <rwbarton> and then rejects the ones that aren't expressions
10:33:06 <parcs`> yep
10:33:21 <cmccann> rwbarton, they're called "statements" or something in GHC's syntax data types I think
10:33:22 <rwbarton> I guess that is a little friendlier error-message-wise
10:33:24 <PcManiac92> a :: Int -> Int -> Int ; a x y = y-(x-2*y)/2   why doesnt this work? :(
10:33:25 <rwbarton> right
10:33:30 <cmccann> same distinction is made in TH
10:33:43 <hiptobecubic> PcManiac92, because integers don't have (/)
10:34:15 <PcManiac92> so i have to use Float?
10:34:15 <hiptobecubic> :t (/)
10:34:16 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:34:20 <hiptobecubic> :t fromIntegral
10:34:21 <lambdabot> forall a b. (Integral a, Num b) => a -> b
10:34:39 <hiptobecubic> > fromIntegral 4 / 2
10:34:40 <lambdabot>   2.0
10:36:31 <hard_coder> > print $ x + 1 where x = -1
10:36:32 <lambdabot>   <no location info>: parse error on input `where'
10:46:06 <hpaste> int-e pasted “cabal install pandoc dryruns” at http://hpaste.org/76532
10:46:36 <int-e> can I coerce cabal into telling me which flags it wants to build those packages with?
10:47:21 <int-e> (I could run with -v3 but that's very tedious)(I know about -v3 b
10:48:32 <dcoutts> int-e: -v shows you
10:48:43 <dcoutts> e.g. digest-0.0.1.1 -bytestring-in-base (new package)
10:49:19 <dcoutts> int-e: oh hmm, but that's only non-default flags
10:49:21 <dcoutts> I think
10:51:21 <donri> hm, does stream fusion require -O2? http://bos.github.com/reaktor-dev-day-2012/reaktor-talk-slides.html#%2851%29
10:52:19 <int-e> dcoutts: oh, it picks a different version of pandoc - mystery solved.
10:55:30 <wereHamster> Eduard_Munteanu: why can't IO be a transformer?
10:57:09 <int-e> dcoutts: so sorry for the noise; printing non-default flags is good enough to spot different choices, I was looking in the wrong place.
10:58:08 <Eduard_Munteanu> wereHamster: same reason ST can't, it breaks referential transparency when combined with certain monads, like the list monad.
10:59:42 <fmap> . o O (runIO ∷ IO m a → m a)
11:00:01 <fmap> IOT rather
11:00:56 <wereHamster> Eduard_Munteanu: what is ST?
11:04:20 <strebe> speaking of cabal, I installed a package via it earlier, then wanted to install profiling, and ran cabal install --reinstall thatpackage, but was warned it was unsafe. I've changed my cabal config file now so I won't run into needing to deal with getting profiling libs later, but is there a better way to deal with changes than --reinstall?
11:05:15 <int-e> wereHamster: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-ST.html - "state thread" monad. It allows mutable data structures in an isolated context, allowing such computation to be invoked safely from pure code.
11:05:32 <Eduard_Munteanu> wereHamster: a monad that provides just stuff like IORefs, IOArrays etc., called STRefs, STArrays
11:06:18 <hard_coder> state transformer monad
11:07:00 <int-e> I don't like that name at all.
11:07:11 <tac> int-e: state monad transformer?
11:07:33 <drostie> we could call it the magic kittens.
11:07:36 <int-e> tac: yes, that's why I don't like that name for ST.
11:07:53 <int-e> tac: because it's something almost entirely different.
11:07:59 <tac> I'm sure you could write STT
11:08:10 <Eduard_Munteanu> fmap: I guess runIO :: IOT m a -> IO (m a) would make more sense, though it'd be just as bad.
11:08:13 <wereHamster> I'll stick to IO and Maybe for the time being. that's engough to digest for me at this time.
11:08:58 <int-e> tac: it's been done and comes with a HUGE warning label: http://hackage.haskell.org/package/STMonadTrans-0.3.1
11:09:19 <hamid> i'm getting this haskell works but the whole return thing( where there's not "return" word) is so confusing for me :P
11:09:26 <tac> int-e: oh interesting.
11:10:10 <tac> I'm guessing that's a "bug" of some sort
11:10:17 <tac> a bug in the theory behind ST
11:10:24 <Eduard_Munteanu> hamid: yeah, better not think of it as "return" from other languages, it's almost nothing like that.
11:10:32 <int-e> tac: nope.
11:11:10 <tac> What I'm saying is, the ST theory did not take transformers into account
11:11:30 <Eduard_Munteanu> I wonder if a dependently-typed STT might avoid that problem nicely.
11:11:34 <tac> and it fails to meet the requirements of transformerhood
11:11:37 <int-e> tac: the theory is sound - the model is a single thread of execution. but in a monad transformer the manner of computation is dictated by the underlying monad which may not be linear, so the assumptions break down.
11:11:49 <tac> Eduard_Munteanu: To Agda! 8D
11:11:58 <Eduard_Munteanu> @yarr
11:11:58 <lambdabot> Get out o' me way, yeh landlubber
11:12:20 <int-e> tac: and that's why ST is *not* a monad transformer. (same for IO)
11:12:37 <hamid> Eduard_Munteanu, i'm kinda trying but when i see something like a function i have no idea the function is returned or the evaluted value from it's computing! :|
11:12:37 <tac> I gotcha
11:12:52 <tac> I'm actually planning on learning more about transformers coming up
11:12:58 <hamid> Eduard_Munteanu, am i missing something?
11:13:22 <ion> cmccann: Mine is just a quick hack, too. :-P
11:13:25 <tac> So I'll keep that thought in mind
11:13:43 <cmccann> ion, yes, but a BETTER quick hack
11:13:49 <Eduard_Munteanu> hamid: return simply packs a pure value into a monadic computation.
11:14:06 <Eduard_Munteanu> :t return
11:14:08 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
11:15:12 <Eduard_Munteanu> hamid: but what sort of function are you looking at?
11:15:24 <Eduard_Munteanu> (return is a function too, btw, if that wasn't clear)
11:16:06 <hamid> Eduard_Munteanu, yep but i meant the return like this :P int func( return 0; ) not the function one
11:16:09 <ion> cmccann: I started writing this <https://gist.github.com/3909430> (but got bored quickly), as a side effect the text converter popped out. The input file looked something like {type} Bool = {Bool}; false = {False}; …
11:16:29 <cmccann> hahahaha
11:16:33 <cmccann> that's beautiful
11:16:45 <tac> hamid: Just to clarify, "return" isn't a keyword in Haskell. Like Eduard_Munteanu said, it's a regular function, like "map" or "tail"
11:17:05 <tac> (it's pretty much the worst-named function in all of Haskll)
11:17:13 <Eduard_Munteanu> hamid: certain monads let you implement something like "return' from other languages. One example is Maybe, another more contrived one is Cont.
11:17:37 <ion> It’s *not* “something like return from other languages”. That’s an important thing to realize.
11:17:40 <tac> (is that really the etimology? Eduard_Munteanu?)
11:17:43 <Eduard_Munteanu> In Maybe, the computation can fail and effectively take a shortcut out.
11:17:51 <hamid> @src filter
11:17:51 <lambdabot> filter _ []     = []
11:17:52 <lambdabot> filter p (x:xs)
11:17:52 <lambdabot>     | p x       = x : filter p xs
11:17:52 <lambdabot>     | otherwise = filter p xs
11:17:57 <hpc> Cont gives you an almost-exact implementation of other languages' "return", but it involves a lot of setup
11:18:04 <hamid> @src max
11:18:04 <lambdabot> max x y = if x <= y then y else x
11:18:10 <Eduard_Munteanu> tac: what etymology?
11:18:19 <rwbarton> I think hamid's question is way simpler than anything involving "return".
11:18:26 <hamid> rwbarton, +1
11:18:28 <hamid> :))
11:18:44 <hamid> Eduard_Munteanu, i confused you as hell :)
11:18:47 <tac> Eduard_Munteanu: is that why return is called return and not unit or something?
11:18:48 <rwbarton> btw "int func( return 0; )" is not valid C or any other language that I know of
11:19:00 <EvanR> return == pure
11:19:06 <leino> I am having some cabal trouble: trying to do 'cabal install cpython', but it seems to depend on the "pkc-config package" python-3.1. I am on debian wheezy, which only supplies a 'python3' package python 3.2. Why does cpython require 'python-3.1', specifically?
11:19:13 <Eduard_Munteanu> tac: yeah, I suspect it comes from imperative languages
11:19:33 <EvanR> you use it sort of like return
11:19:36 <hamid> oops int func(){return 0; }
11:19:36 <Eduard_Munteanu> If it were CT all the way down, they would have called it 'unit' or something :)
11:19:43 <rwbarton> func = 0
11:19:46 <ion> cmccann: The incredible template engine (or something – it only lets you protect some sections from conversion with {…}): https://gist.github.com/3909452#file_conv.hs
11:20:06 <rwbarton> what is "returned" from a Haskell function is the entire expression after the =
11:20:35 <cmccann> ion, I should convert all my code to be in fraktur
11:20:37 <cmccann> that would be fun
11:20:38 <EvanR> with the variable substituted
11:20:45 <hamid> rwbarton, so it means i don't understand expressions :D
11:20:54 <rwbarton> quite possibly
11:24:13 <hamid> rwbarton, i just heard that it's pure and there are no exceptions what if i call error(haskell one). is it catchable or something like in c++/java?
11:24:51 <rwbarton> sort of but normally you shouldn't catch it
11:25:26 <hamid> rwbarton, you mean i assume it as a bug and fix it in compile time ?
11:26:21 <strebe> there are times you want to catch it (around things like file I/O), but you rarely want to write calls to error yourself
11:26:37 <Eduard_Munteanu> hamid: normally pure functions shouldn't error out like that. You'd use something like Maybe to indicate failure.
11:26:45 <rwbarton> right, it should indicate a bug and normally you want to abort your program if it has a bug
11:27:08 <rwbarton> if you are writing a web server or something that processes many requests, maybe you only want to abort a single request and then you would want to catch errors
11:27:29 <mysticc> Are these two different data A = forall a. Someclass a => A a and data A = A (forall a . Someclass a => a) .. If yes then how ?
11:27:55 <Eduard_Munteanu> mysticc: sure, the first one is existential, and the second just rank-2.
11:28:39 <rwbarton> mysticc, can I rename them to A1 and A2?
11:28:49 <hamid> thank you guys.
11:28:52 <Eduard_Munteanu> mysticc: the second one is a datatype which contains *polymorphic* values.
11:28:59 <rwbarton> if you give me an A1 then all I know is I have a value of some type which is an instance of Someclass, but I have no way to find out which type
11:29:17 <rwbarton> if you give me an A2 then I have a value which I can instantiate at any type of my choice that is an instance Someclass
11:29:27 <rwbarton> *of Someclass
11:31:53 <mysticc> rwbarton: Lets say constructors are AC1 and AC2. Now if I have AC1 a and AC2 a, how are these two a's different ?
11:32:06 <rwbarton> just like i said
11:32:28 <rwbarton> if i am the recipient of AC1 a, i don't know what type a has, all i know is that it's an instance of Someclass
11:32:44 <mysticc> yeah that I understand
11:32:44 <rwbarton> if i am the recipient of AC2 a, i effectively get to choose the type of a, as long as my choice is an instance of Someclass
11:32:54 <mysticc> ohh
11:32:57 <rwbarton> a is polymorphic
11:33:00 <Eduard_Munteanu> mysticc: you can say AC1 x where x :: Int, but AC2 requires a polymorphic value.
11:33:14 <mysticc> ok. thanks
11:33:16 <rwbarton> because the type of AC2 will be (forall a . Someclass a => a) -> A2
11:34:06 <startling> can I compose two Iso (from `lens`) to get an Iso somehow?
11:34:12 <rwbarton> I can even take the a from AC2 a and use a at multiple types
11:34:20 <Eduard_Munteanu> mysticc: alternatively you can think of existentials as pairing a hidden type with your datatype. Say A1 ~ (a :: *, <some definition using that hidden, but fixed a>)
11:35:03 <Eduard_Munteanu> (well, ignoring the class constraint)
11:35:27 <rwbarton> and similarly in A2, the value is really a "hidden function"
11:35:42 <rwbarton> ((a :: *) -> (some value of type a))
11:36:06 <Eduard_Munteanu> Right, it's much like dependent sum vs dependent product.
11:41:59 <gabor> does 7.6.1 support type *variable* promotion (to be a kind variable)?
11:42:44 <gabor> i.e. class Foo t where data Bar t :: t -> *; ...
11:47:08 <Polarina> Why would I be getting this error from ghci? "ReadConsoleInput: resource exhausted (Not enough storage is available to process this command.)"
11:48:51 <startling> Polarina, are you in a shell? try closing and opening it
11:48:59 <startling> sometimes weird stuff happens to stdin/stdout
11:49:18 <startling> is there an identity lens in `lens` somewhere?
11:49:30 <Cale> startling: It's just id from Prelude
11:49:35 <Polarina> startling, that didn't solve it.
11:49:44 <startling> Cale: ...woah, man
11:50:51 <Cale> startling: Same as how you compose lenses with (.) from Prelude :)
11:51:24 <startling> yeah
11:51:29 <startling> that's pretty cool
11:51:34 <startling> it makes a lot of sense, though
11:51:52 * Polarina likes id and (.) from Control.Category better.
11:52:10 <Cale> It's one of the benefits of using type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b  as the representation
11:52:16 <startling> yeah
11:52:18 <Cale> Though, composition is kinda flipped
11:53:01 <zzing> Are there any other libraries that are like heist, blaze, etc. that deal with html, but most especially can load it at runtime to deal with its structure?
11:53:17 <startling> zzing: I'm wondering about that too
11:53:57 <zzing> I am looking at something like heist, but I don't necessarily need all of its structure, mainly processing of specific nodes
11:54:28 <Shapeshifter> I have a question about acid-state. In case of a power outage, how can the application pick up where it left of, if the entire database was residing in memory at the point of the power outage?
11:54:56 <zzing> I thought acid state used transactions
11:55:07 <Lemmih> Shapeshifter: There's a transaction log on disk. It will be replayed to restore your state.
11:55:24 <Cale> Shapeshifter: It wasn't *just* in memory :)
11:55:31 <Shapeshifter> I also don't understand how applications start when using acid-state. Will the entire history of the state changes be replayed every time it starts? Doesn't this take forever?
11:55:59 <Shapeshifter> Lemmih: so the data resides in ram, but the log is writte to disk on every state change?
11:56:47 <Lemmih> Shapeshifter: Checkpoints (state snapshots, that is) can be written to disk when the event log becomes too long.
11:57:07 <otters> does anybody know what exception connectTo throws if it can't connect
11:57:11 <Shapeshifter> I see
11:57:16 <Lemmih> Shapeshifter: Yes, just like any other database with a transaction log.
12:00:55 <lispy> Lemmih: how do you feel about moving some for repos to github?
12:01:00 <zzing> otters, it looks like it closes it
12:01:09 <zzing> It seems to use bracketOnError
12:01:10 <Shapeshifter> acid-state sounds pretty amazing. What's the catch? Other than it may need lots of ram?
12:01:23 <lispy> Lemmih: someone I work with was hacking some of your SDL bindings, but I don't think he wanted to send you darcs patches
12:01:44 <lispy> Shapeshifter: it's actually kind of terrible for production
12:01:45 <zzing> I looked at the source code, might make sense to do the same
12:02:01 <otters> zzing: yeah but I want to make a handler for it that doesn't catch SomeException
12:02:03 <otters> ._.
12:02:09 <lispy> Shapeshifter: it has some neat ideas and it is cool. But I wouldn't risk my reputation on using it in a production setting.
12:03:07 <Shapeshifter> lispy: just because it doesn't have a safe-harbour reputation, yet or do you have specific reasons to say so?
12:03:13 <zzing> Persistent might be worth looking at, although I am personally just moving to yaml files
12:03:37 <zzing> otters, try to test in ghci with bad connections and good connections
12:03:43 <otters> okay
12:04:13 <Cale> It throws an IOException
12:04:29 <Cale> ghci> try (connectTo "notthere" (PortNumber 80)) :: IO (Either SomeException Handle)
12:04:29 <Cale> Left getAddrInfo: does not exist (No address associated with hostname)
12:04:29 <Cale> ghci> case it of Left (SomeException e) -> typeOf e
12:04:29 <Cale> IOException
12:04:38 <lispy> Shapeshifter: It seems to need too much memory. I've heard people say you lose some of the ACID properties if you try to reduce the memory usage. Also, SQL databases really aren't that bad. Years of research and practical experience means that things like postgres really are quite nice.
12:04:45 <otters> oh typeof
12:04:47 <otters> of course
12:05:40 <Cale> The Show instances for exceptions are a little annoying
12:06:07 <Shapeshifter> lispy: I see.
12:06:32 <Cale> lispy: Lemmih is *right* there
12:06:54 <Cale> ;)
12:06:56 <donri> Shapeshifter: meh, don't listen to lispy
12:07:49 <Cale> But honestly, acid-state is perhaps not totally ready for production, but it's really something that I wish I could use for production.
12:08:02 <donri> well, if you need replication or sharding, sure
12:08:03 * lispy nods at Cale 
12:08:33 <startling> how evil is it to write some lenses on what amount to lists if I only expect to be dealing with infinite lists?
12:08:54 <Cale> Yeah, the network server stuff looks a little bit underdeveloped? I haven't actually tried it, so that might be unjustified.
12:09:31 <lispy> Shapeshifter: You could try out acid-state and see if it meets your needs.
12:09:47 <donri> if you need to ask if acid-state meets your needs, it does ;)
12:09:49 <lispy> Shapeshifter: Could be that it wasn't developed with large datasets in mind
12:10:06 <lispy> and that might explain the complaints about memory usage
12:10:12 <Cale> lispy: Well, RAM is really cheap these days
12:10:25 <Shapeshifter> I'm only just learning haskell. I've just finished reading lyah
12:11:45 * startling wishes there were a well-used always-infinite list type.
12:11:54 * lispy hopes Lemmih isn't taking what he's saying personally. Lemmih does a good job.
12:12:10 <lispy> startling: colist?
12:12:32 <donri> isn't colist a fold? :)
12:13:07 <hard_coder> a colist is just a colloid in the category of...
12:13:12 <otters> milk
12:13:19 <startling> what does a colist look like? I can't imagine what the dual of [] would be
12:13:40 <Cale> I would really like to have a database which enforced more constraints on my data than SQL databases tend to make easy.
12:14:23 <nooodl> startling: ][
12:14:38 <Cale> I want to be able to have columns which are like foreign key columns into an arbitrary query, so that whatever data is stored there must satisfy the conditions of that query.
12:15:05 <startling> nooodl: heh
12:15:12 <donri> Cale: you should talk to Palmik who is writing the new ixset
12:15:44 <donri> not sure if possible/relevant to that, but might be?
12:15:55 <startling> oh, is colist just data CoList a = (:) a (CoList a)?
12:16:06 <rwbarton> I just want a database with sum types
12:16:21 <killy9999> csr xs = last xs : init xs
12:16:23 <lispy> startling: oh, I called it colist because it sounded like you're describing codata.
12:16:24 <donri> rwbarton: acid-state!
12:16:28 <killy9999> halp, I haz memory leak :<
12:16:36 <Cale> You can't tell the difference between colists and lists in Haskell...
12:16:37 <lispy> startling: maybe colist already has a different definition
12:16:44 <rwbarton> well yes, but I wanted it for a project using python :P
12:16:46 <killy9999> any way to rewrite such expression?
12:17:02 <b44> Any example on how to use type Down in Data.Ord ?
12:17:04 <donri> rwbarton: custom object hack + zodb!
12:17:07 <nooodl> i think colist == list? colist would be a comonad right
12:17:25 <djahandarie> > let in 123
12:17:26 <lambdabot>   123
12:17:26 <startling> lispy: codata?
12:18:00 <Cale> The distinction between codata and data only becomes relevant once you start trying to prove that things terminate
12:18:15 <Cale> In Haskell, they're identified, and both called data
12:18:27 <nooodl> i... wh... "codata"
12:18:46 <donri> b44: the haddock suggests using http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#generalised-list-comprehensions
12:18:47 <Palmik> donri, hmm, that could possibly be built on top of data-store, but single data-store value represents 1 table. So, there would have to be some type that encodes the relationships between "tables". I will write this idea down.
12:19:56 <Cale> startling: But yeah, to really get to your question, you want data Stream a = S a (Stream a) or something
12:20:38 <donri> > sortWith Down [1,3,2]
12:20:39 <lambdabot>   Not in scope: `sortWith'Not in scope: data constructor `Down'
12:20:44 <donri> > GHC.Exts.sortWith Down [1,3,2]
12:20:46 <lambdabot>   Not in scope: `GHC.Exts.sortWith'Not in scope: data constructor `Down'
12:20:49 <donri> :(
12:21:32 <startling> I guess you could do data Finite = Nil | Cons a !(Finite a), too
12:21:49 <startling> that's not terribly useful, though
12:23:30 <Cale> Edward has so many packages now that it's hard to find some things
12:23:41 <Cale> He needs his own package index
12:24:12 <Cale> with a haddock module list of all his packages together
12:24:20 <startling> the portable edwardk: a summary of his works
12:24:36 <donri> b44: sortBy (comparing Down) [1,3,2]  -- I think. can't test it because my base is too old
12:24:38 <b44> donri: right paragraph? can't see any relation to "Down"
12:24:52 <b44> hm okay
12:24:57 <b44> I'll try
12:25:08 <donri> "This is particularly useful when sorting in generalised list comprehensions, as in: then sortWith by Down x"
12:25:31 <donri> but should work with sortBy and comparing, too
12:25:57 <Cale> The generalised list comprehensions stuff is kinda weird :)
12:26:13 <b44> I see, thank you donri
12:26:19 <Cale> startling: http://hackage.haskell.org/package/streams
12:26:24 <donri> in deed, but apparently it allows for some optimization that's otherwise difficult?
12:26:50 <startling> Cale: neat
12:27:31 <zzing> startling, found the library that heist uses: http://hackage.haskell.org/packages/archive/xmlhtml/0.2.0.3/doc/html/Text-XmlHtml.html
12:28:06 <startling> zzing: I've seen that too, but it's not as nice as blaze for dslery
12:28:09 <Cale> "Data.Stream.Infinite provides a coinductive infinite anti-causal stream." dat terminology
12:28:26 <zzing> dslery?
12:28:27 <startling> Cale, it lets me time travel?
12:28:50 <rwbarton> @faq can Haskell let me time travel?
12:28:50 <lambdabot> The answer is: Yes! Haskell can do that.
12:28:58 <startling> zzing: dsl == domain-specific language
12:29:13 <zzing> I know what DSL is
12:29:46 <zzing> It looks like this library uses blaze to build things to actual html
12:30:00 <startling> zzing: right, but I don't think it's as nice to write
12:32:37 <hard_coder> @faq is haskell faster than C?
12:32:37 <lambdabot> The answer is: Yes! Haskell can do that.
12:33:16 * Cale looks for a particular paper regarding various types of streams and comonads... there seem to be a lot of them which are not the most accessible.
12:33:49 <Cale> I think it *was* by these Uustalu and Vene guys, but not the ones that I'm finding by them
12:34:30 <Cale> There was a good paper which explained the terms causality and anticausality
12:35:58 <zzing> When that guy created the Time monad, I remember everyone was excited. But when that other guy created the Time comonad, that is when things became really exciting. Everyone dreamed of writing the action that would kill hitler.
12:36:09 <Cale> http://www.cs.ioc.ee/~tarmo/papers/aplas05.pdf
12:36:26 <Cale> I'm not sure that's what I'm thinking of, but that at least explains the concept
12:36:51 <nand`> @quote einstein
12:36:52 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
12:37:08 <nand`> hard_coder, looks like you're out of luck
12:38:25 <zzing> Cale, in that paper what is fby?
12:38:28 <hard_coder> doesn't say it can't be as fast as C though ^_^ there's still hope!
12:39:16 <nand`> poor Haskell Curry can never exceed the speed of light
12:40:00 <Cale> zzing: It's kind of like cons
12:40:19 <Cale> (the language in that first snippet isn't Haskell)
12:40:21 <hpaste> killy9999 pasted “cyclic shofts” at http://hpaste.org/76535
12:40:30 <killy9999> s/shofts/shifts
12:40:33 <zzing> Cale, it looks like it is an example only
12:40:48 <killy9999> any idea how to rewrtie the second function so that performance is similar?
12:41:01 <zzing> Cale, sorry I should have read the paragraph, now I understand that code simply
12:41:07 <Cale> zzing: yeah, the idea is that  pos = 0 fby (pos + 1)  defines a stream of nonnegative integers
12:41:47 <zzing> Cale, is this mode of thinking practical?
12:41:57 <Cale> It can be
12:42:29 <dzhus> killy9999: use constant-time access container instead of list
12:43:08 <Cale> killy9999: Those are just fundamentally bad operations on lists, and if you need to do that sort of thing, you're better off with another datastructure.
12:43:59 <Cale> killy9999: xs ++ ys takes O(length xs) steps to evaluate
12:44:08 <Cale> last xs and init xs both do as well
12:44:10 * killy9999 knows
12:44:26 <Cale> Now, 9 times slower, that's a little bit funny
12:44:33 <killy9999> why funny?
12:44:42 <Cale> somewhere close to twice as slow would be what I'd expect
12:44:56 <killy9999> wanna see results from criterion?
12:45:08 <killy9999> 2ms vs. 18ms
12:45:10 <dzhus> it's X times slower where X depends on list size; moreover it's incorrect to compare different algorithms
12:45:11 <lpvb> would code that responds to time be impure, or is time just viewed as another input?
12:45:34 <dzhus> lpvb: define «responds to time»
12:45:46 <Cale> Well, there are different constant factors involved...
12:45:50 <sipa> lpvb: depends whether it depends on actual time, or takes an explicit input that is supposed to represent time
12:45:53 <killy9999> actually I'm implementing one algorithm using different data structures
12:46:03 <killy9999> and compare which implementation is the fasetes
12:46:17 <killy9999> that's the reason why this two operations are done on lists
12:46:17 <dzhus> killy9999: so use vector here
12:46:19 <zzing> Cale, do you know what this mean? "Remarkably, we get higher-order language designs with almost no eﬀort whereas the traditional dataﬂow languages are ﬁrst-order and the question of the meaningfulness or right meaning of higher-order dataﬂow has been seen as controversial. "   Specifically, what makes things first order vs. higher order?
12:46:25 <Cale> But the number of reduction steps involved is about 2x in the second case. However, the second one will use more memory in general
12:46:33 <Cale> and so perhaps that has something to do with it
12:46:42 <Cale> (the extra work that the GC has to do)
12:47:02 <killy9999> dzhus: I have another implementation in Repa, but yes - I will also do one with Vector
12:47:20 <killy9999> Cale: according to Threadscope there's a lot of GC going on in there
12:47:22 <dzhus> killy9999: Repa has no its own containers, so you must have already used vector.
12:47:34 <Cale> zzing: It was so long ago that I read this paper, give me a moment to figure out what they meant by that :)
12:47:36 <killy9999> dzhus: yes, but repa uses parallelism
12:47:45 <dzhus> killy9999: so
12:47:50 <killy9999> this is of no use for these two functions
12:48:00 <Cale> zzing: Probably in the sense of higher order functions -- so you'd have streams of stream transformers and so on.
12:48:01 <killy9999> but these are only a part of a larger whole
12:48:24 <dzhus> killy9999: how is this relevant here where you only accessing a head and tail of list?
12:48:33 <killy9999> I said it's not
12:48:45 <killy9999> for these two funcions it's irrelevant
12:48:54 <killy9999> but for a whole algorithm it is
12:49:21 <zzing> I don't think I will likely be able to comprehend much of the paper it says: "denotational semantics and the Lambek-Lawvere correspondence between typed lambda calculi and cartesian closed categories (the types-as-objects, terms-as-morphisms correspondence)."    I don't know how much of this stuff I have actually touched in haskell without knowing it, but can't even describe what these things are :P
12:50:23 <zzing> The denotational semantics wikipedia article looks very interesting though.
12:50:35 <Cale> zzing: I didn't know much about that when I read the paper either.
12:50:54 <Cale> zzing: Still, just the basic stuff about various sorts of streams is interesting :)
12:51:53 <killy9999> OK, the slowdown definitely depends on list length
12:51:54 <Cale> zzing: Are you familiar with the Curry-Howard isomorphism?
12:52:04 <zzing> Cale, no, but I have heard the term
12:52:20 <killy9999> for a list of 1024 elements csr is 5,5 times slower, for length 8192 it is 9 times slower
12:52:48 <merijn> zzing: Are you familiar with proposition logic?
12:52:51 <Cale> zzing: Okay, so that's a connection between types and statements, and programs and proofs.
12:53:11 <zzing> merijn, I have only ever done prepositional, and first order (course this semester)
12:53:22 <zzing> I might have my terms wrong there
12:53:41 <zzing> nope right term
12:53:45 <Cale> In logic, when you set out to prove that A -> B (that is, A implies B), you assume that A, and construct from it somehow a proof that B.
12:53:54 <zzing> yes
12:54:05 <merijn> zzing: Curry-Howard is basically the notion that propisition logic is isomorphic (for flexible definitions of isomorphism ;) to functional programs
12:54:19 <zzing> What does isomorphic mean
12:54:21 <merijn> or rather
12:54:27 <merijn> functional program types
12:54:43 <Cale> In lambda calculus, when you set out to construct a function of type A -> B, you write a lambda term wherein you assume that you have a value x of type A, and construct from it somehow a value y of type B.
12:54:45 <merijn> zzing: translatable 1-to-1 given a specific translation scheme
12:54:49 <Cale> (Getting (\x -> y))
12:55:26 <zzing> ok
12:55:26 <merijn> zzing: i.e. you can construct a mapping from types to proofs and vice versa and "toType(toProof(x)) == x" and vice versa
12:56:01 <Cale> In this case, "isomorphism" is perhaps a little loosely applied, rather than being a hard technical term like it usually is, because the details of the correspondence differ corrresponding to the logics and lambda calculi you're talking about
12:56:03 <zzing> ok, is that like an identity definitino?
12:56:37 <zzing> morphism - a change in something, iso - one,   "one change"?
12:56:44 <Cale> zzing: It says that toProgram and toProof are inverses
12:56:57 <Cale> (I'm renaming toType to toProgram ;)
12:57:04 <zzing> :-)
12:57:24 <merijn> zzing: It means there's a mapping from A to B and a mapping from B to A where both are complete and each others inverses
12:57:26 <b44> What has to be true, so that a recursive function can be transformed into a linear or tail-recursive one?
12:57:32 <Eduard_Munteanu> zzing: just like with math functions, f is an isomorphism if f . f^-1 = f^-1 . f = id
12:57:37 <Cale> But the more important thing is to actually look at what's going on
12:57:43 <zzing> I will need to figure some of this stuff out soon, I am doing some set theory now and graph theory soon. Would be good to go into that shortly after.
12:57:55 <merijn> zzing: A simple example to illustrate, [()] is isomorphic to the natural number 1 <-> [()], 2 <-> [(),()], etc.
12:57:59 <Cale> Don't get caught up in the term "isomorphism" too much here -- "correspondence" is perhaps better in this case.
12:58:33 <Cale> So, in logic, if you know that (A -> B) and you know that A, then you can get a proof of B
12:58:55 * hackagebot HTTP 4000.2.6 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.2.6 (BryanOSullivan)
12:59:05 <merijn> (Well isomorphic depending on which operations you include. For example (+) could map to (++), but finding a translation for (-) could be tricky
12:59:06 <Cale> and similarly, in a typed lambda calculus, if you have a term f :: A -> B, and a term x :: A, then you get  f x :: B
12:59:16 <zzing> Cale, I cannot help but notice that if I have a function f : a -> b   and I give it 'a', I get b :P
12:59:21 <Cale> So function application corresponds to modus ponens
12:59:27 <Eduard_Munteanu> Hence the isomorphism :)
12:59:46 <zzing> Oh dear, this is nice to know :-)
13:00:00 <merijn> b44: tail recursive in general or did you mean "which recursions take constant space?"
13:00:02 <zzing> I have finally connected something I have learned in math to programming
13:00:17 <Eduard_Munteanu> As far as logic is concerned, you care whether a type is inhabited or not.
13:00:18 <Cale> There's a way to generalise this whole process to an arbitrary category in which enough widgets of specific sorts exist (called a Cartesian closed category)
13:00:38 <Eduard_Munteanu> An inhabitant of a type is a (constructive) proof of the corresponding theorem.
13:01:14 <b44> merijn: I read that tail recursion is a necessary criteria for a recursion to be space efficient. So both would interest me
13:01:27 <merijn> b44: The is only true in strict languages
13:01:46 <b44> merijn: the ?
13:01:55 <merijn> b44: Eh, that :p
13:02:08 <zzing> I will be doing categories eventually, it must be done!
13:02:31 <lpvb> I'm trying to make a function that only executes an IO action if a certain amount of time has passed since the last execution, and I don't know the best way to do that
13:02:34 <merijn> b44: For example, "map f (x:xs) = f x : map f xs" is not tail recursive, because the ":" cannot return until the recursive call finishes, right?
13:02:44 <`Jake`> is there a way to write "a <- getLine" with a let expression? (Outside of a do block)
13:02:53 <merijn> b44: As a result, that definition of map will blow the stack in a strict language.
13:02:55 <strebe> zzing: yes :-)
13:03:18 <b44> merijn: yes, and in haskell?
13:03:24 <merijn> b44: However, haskell is lazy which means that (:) basically returns "f x : <some recursive computation that we're not executing yet>"
13:03:36 <Eduard_Munteanu> `Jake`: that alone doesn't make much sense
13:04:11 <Eduard_Munteanu> `Jake`: but you can look at the way do notation is desugared.
13:04:22 <merijn> b44: As a result map returns in constant space, because it can return without doing the recursive call at all. If you later try to look at the tail it will do the recursive call *then*, the new recursive call of course also returns immediately
13:04:24 <Eduard_Munteanu> @undo { a <- getLine; foo a }
13:04:24 <lambdabot>  Parse error at "{" (column 1)
13:04:28 <Eduard_Munteanu> @undo do { a <- getLine; foo a }
13:04:28 <lambdabot> getLine >>= \ a -> foo a
13:04:36 <strebe> `Jake`: getLine >>= \a -> putStrLn a  does the same thing as a <- getLine  and then ... what lambdabot said
13:04:55 <b44> merijn: ah.. ok, thanks
13:05:05 <strebe> it'll still be in a monadic impure function, though
13:05:10 <merijn> b44: (In reality it doesn't even return "f x : <something>" but more "<thunk for f x> : <thunk for map f xs>", where a thunk is sort of a pointer to a computation that can be done but hasn't run yet)
13:05:15 <`Jake`> Eduard_Munteanu: yeah, I know that, but I was just interested if you could do something like "let (Just a) = {something}" with IO
13:05:40 <merijn> b44: In haskell the non tail-recursive definition of map is actually the most efficient one available :)
13:05:50 <Eduard_Munteanu> `Jake`: ah, no, you're not supposed to "peek" inside IO.
13:05:56 <`Jake`> Eduard_Munteanu: ok, thanks
13:07:09 <merijn> strebe: "getLine >>= \a -> putStrLn a" doesn't really make sense, though. That'd just be "getLine >>= putStrLn" :)
13:07:25 <monochrom> you should empirically measure "length (map f [1..n])" to see that it takes constant space, before you opine about how much space it takes. scientific method vs opinionative method
13:08:03 <strebe> merijn: true, it pointfrees nicely, but I was trying to preserve the use of a variable a to make the desugaring clearer :)
13:08:22 <b44> merijn: Okay ^^ And how about linear recursion? It has the same importance in strict/ non-strict languages ?
13:09:28 <merijn> b44: I'm not really familiar with the term linear recursion? Is that when you just do one recursive call rather than two or more (for example, the usual stupid recursive fibonacci definition)?
13:09:46 <b44> yes
13:10:17 <b44> exactly... the better fibonacci version is linear recursive and tail-recursive
13:10:25 <b44> using accumulators
13:10:38 <merijn> b44: It depends, if you actually use all results then they will have the same complexity penalty. However, in a non-strict language you'll be faster if you don't traverse into some of the branches
13:10:39 <monochrom> that depends on the actual algorithm and actual data types used
13:11:49 <merijn> b44: If you have a non-linear recursion that returns (for example) a tree, then you could potentially avoid generating large parts of the tree if you never descend into those branches to force the thunks that'd generate them
13:12:27 <monochrom> see my http://www.vex.net/~trebla/haskell/lazy.xhtml . you have to re-learn and re-build your whole cost model. there is no correct "short diff" from the eager cost model
13:13:09 <b44> merijn: hm... I see. And which non-linear recursions can be transformed into linear ones, even if all branches of that recursion-tree are entered?
13:14:34 <b44> merijn: my teacher said something like: "Not every recursive function can be made linear/tail recursive". That's why I'm asking about that ...
13:15:18 <merijn> b44: It's highly algorithm and data specific, there's no one single answer to give you, unfortunately
13:15:48 <byorgey> b44: that's false.  You can always make anything tail recursive by converting it into continuation-passing style.
13:16:21 <byorgey> well, in languages that support first-class functions, that is.
13:17:04 <byorgey> but even in languages that don't support continuations directly you can often "reify" the different sorts of continuations needed for a particular algorithm as a data structure
13:18:01 <hard_coder> what is CPS?
13:19:32 <hard_coder> > let f = \x -> if x == 0 then 1 else x * f (x - 1) in f 6
13:19:34 <lambdabot>   720
13:20:31 <byorgey> > let f x k = if x == 0 then k 1 else f (x - 1) (\r -> x * r)  in f 6 id
13:20:32 <lambdabot>   1
13:20:44 <byorgey> whoops
13:20:44 <hard_coder> O.o
13:20:59 <hard_coder> is that CPS?
13:21:14 <byorgey> clearly not, because it didn't work
13:21:37 <jix> byorgey: you are not using k in the else part
13:21:39 <byorgey> but the idea is simple: instead of returning the answer directly, you take an extra argument which is a function that specifies what to do with the result
13:21:48 <byorgey> jix: ah! right, thanks =)
13:21:51 <atriq> > let f r x = if x == 0 then 1 else x * r (x - 1) in fix f 6
13:21:52 <lambdabot>   720
13:22:00 <maukd> > let f x k = if x == 0 then k 1 else f (x - 1) (\r -> k (x * r))  in f 6 id
13:22:01 <lambdabot>   720
13:22:05 <byorgey> > let f x k = if x == 0 then k 1 else f (x - 1) ((x*) . k)  in f 6 id
13:22:07 <lambdabot>   720
13:22:08 <nand`> CPS is nothing special, it's just the trivial form of the yoneda lemma for the identity functor, no?
13:22:09 <hard_coder> lol
13:22:20 <byorgey> nand`: hahaha
13:22:35 <atriq> Quick question.
13:22:41 <atriq> Do I need to care about the Yoneda lemma?
13:23:08 <nand`> probably not, but it can be used for certain kinds of performance gains
13:23:32 <byorgey> atriq: no.  you need food, water, shelter, and human relationships.  that's about it really.
13:23:39 <nand`> (of course, if anything, you'd just need to care about what the yoneda lemma looks like in Haskell)
13:24:07 <nand`> to that effect, here's an article that helped me: http://blog.sigfpe.com/2006/11/yoneda-lemma.html
13:32:47 <Shapeshifter> The happstack documentation pages should probably use a fixed width font for their code samples. Sometimes they even refer to the indentation but it's all over the place.
13:33:16 <Shapeshifter> specifically, theme.css:213 font-family is set to sans-serif, which should be a fixed width font.
13:33:46 <stepcut> Shapeshifter: hmm, do you have an example? They should be fixed width already..
13:34:01 * stepcut investigates
13:34:09 <Shapeshifter> stepcut: I just realized it specifies ubuntu mono as the font.
13:34:10 <nand`> they're fixed width for me
13:34:12 <nand`> admittedly, everything is
13:34:24 <Shapeshifter> never heard of that font ^^
13:34:39 <stepcut> Shapeshifter: comes from the google font thing
13:35:15 <Shapeshifter> stepcut: I think it should be font-family:monospace
13:35:18 <Shapeshifter> stepcut: instead of sans-serif
13:35:36 <Shapeshifter> stepcut: that way people who have ubuntu mono see that, others see whatever monospace font they have on the system.
13:35:44 <stepcut> http://www.google.com/webfonts/specimen/Ubuntu+Mono
13:36:20 <stepcut> well, they browser should get the font automatically online, but obviously it should also be set to monospace, so I will fix that
13:38:51 <`Jake`> The problem with ubuntu mono is that some unicode characters aren't displayed correctly. At least not in my terminal
13:39:10 <stepcut> fortunately, there is no unicode in the happstack doc examples :)
13:39:27 <Shapeshifter> honestly, I don't understand how this is a mono font. g ubuntu mono
13:39:34 <stepcut> except for one place that where I have °F, but I had to take that out because it made pandoc choke
13:39:34 <Shapeshifter> oops wrong window
13:40:51 <Shapeshifter> Nah I get it. something's wrong with my firefox. It's set to allow pages to use their own fonts but apparently it's not doing so.
13:41:01 <`Jake`> I think ° should'nt be a probem, but things like  ← are
13:41:25 <merijn> `Jake`: Have you looked into Adobe's new monospace font? Probably will have much better unicode coverage than stuff like Ubuntu's fonts
13:41:50 <stepcut> Shapeshifter: should be fixed now
13:42:07 <Shapeshifter> stepcut: thank you very much, fantastic.
13:42:08 <`Jake`> merijn: I haven't, but I use DejaVu Sans Mono right now, and that seems to work just fine
13:42:34 <Shapeshifter> `Jake`: why not simply set a fallback font? I use DejaVu with Code2000 as fallback in urxvt.
13:43:27 <`Jake`> Shapeshifter: I've never heard of that. I'm guessing it replaces dangerous characters with another font? That would be cool.
13:44:29 <Shapeshifter> `Jake`: Yes. You provide a list of fonts and if a higher priority font doesn't have a glyph it tries the next font.
13:45:00 <Shapeshifter> `Jake`: http://pastie.org/5090431 you can use this e.g. in .Xdefaults
13:45:06 <`Jake`> Shapeshifter: Cool! I'm gonna look into that, thanks
13:45:13 <watermind> I was looking at this SO post on creating tuples with elements of a list using comonads and calculus http://stackoverflow.com/a/12872133/1442575
13:45:15 <Cale> Also, if you're using anything which uses Freetype 2, that will automatically do substitutions when the font you're using lacks a glyph, trying to find a similar font that has it.
13:45:18 <merijn> `Jake`: http://blogs.adobe.com/typblography/2012/09/source-code-pro.html it's part of Adobe's recent open source font work, they released a bunch of other fonts in that family too, but those aren't monospace
13:45:19 <watermind> So many questions :S
13:45:27 <Shapeshifter> provided you have code2000. which is a font that tries to contain every font there is. even klingon and silly stuff like that ;)
13:45:34 <watermind> e.g. This notion of derivative... where can I read more about it?
13:45:50 <`Jake`> Wow.
13:46:25 <watermind> I know calculus and I can get the intuition behind it but still... in calculus derivatives have a precise definition based on limits
13:46:29 <Cale> watermind: Well, the real name of the person who wrote that post is Conor McBride
13:46:37 <Cale> watermind: Yeah, ignore that for a moment
13:46:39 <merijn> Cale: uh-oh :D
13:46:42 <`Jake`> merijn: It does look kinda nice.
13:46:52 <watermind> Cale: oh I know, from Epigram right?
13:46:56 <Cale> yes
13:47:17 <dmwit_> watermind: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.22.8611&rep=rep1&type=pdf
13:47:26 <Cale> watermind: The derivative of x^3 = xxx is 3 x^2 because there are three ways of deleting an x, and each way gives you x^2
13:47:35 <dmwit_> Or just chat up Cale and he'll type the whole paper at you from memory via IRC.
13:47:35 <watermind> thanks dmwit_
13:47:43 <watermind> Cale: yes
13:48:04 <watermind> Cale: I get how to calculate them...
13:48:05 <merijn> dmwit: Cale is likely more understandable than Conor :p
13:48:20 <dmwit> The paper is quite readable. Don't knock it until you try it.
13:48:30 <Shapeshifter> I tried source code pro and while individual letters look nice, I found it way too nervous. I can understand that in theory, e.g. the height of similar letters is a good indicator to tell them apart. but it looks like a rollercoaster.
13:48:34 <jmcarthur> i wish there was a tool for taking the outputs from two separate compilations using -ddump-simpl and showing me the difference
13:48:44 <watermind> Cale: knowing calculus and understanding the algebraic operations it is easy to guess
13:48:45 <dmwit> The advantage of IRC is primarily interaction, not explanatory power.
13:49:02 <drostie> Okay my earlier code can be simplified considerably because it turns out ^ does exponentiation by squaring. :D
13:49:08 <Cale> watermind: The idea is that there is this formal operation on structures which has many of the same properties as the derivative from Calculus, but which has nothing obvious to do with limits.
13:49:31 <watermind> Cale: right
13:49:54 <watermind> Cale: so what are these derivatives... do they have some sort of 'meaning'?
13:50:25 <Cale> watermind: In particular, the product rule:  D(xy) = D(x)y + xD(y) can be interpreted as saying that if we delete some substructure from xy, then we either delete it from x or we delete it from y.
13:51:00 <watermind> Cale: Ah I see
13:51:19 <nooodl> why is the "or" equal to addition though
13:52:37 <Cale> nooodl: There are a lot of ways to answer that question depending on your background...
13:53:02 <monochrom> jmcarthur: you have to add -dsuppress-uniques to help that
13:53:24 <watermind> Cale: I can see how this could be useful to establish isomorphisms between data structures
13:53:29 <Cale> If we think about data types, or sets, just in terms of their cardinality (the number of structures of a given type)
13:54:05 <watermind> Cale: but are there other applications, as in problems you solve by calculating 'derivatives' of datatypes?
13:54:17 <Cale> Then addition of cardinalities corresponds nicely to disjoint union and multiplication of cardinalities corresponds to Cartesian product
13:54:24 <Eduard_Munteanu> watermind: it's useful for building zippers formally.
13:54:45 <jmcarthur> monochrom: oh, i didn't know about that. looking it up. thanks!
13:54:45 <watermind> Eduard_Munteanu: ah cool
13:54:48 <Eduard_Munteanu> watermind: or generalizing them to n-hole contexts (taking the derivative multiple times).
13:54:58 <aniero> hey, i'm having some difficulty doing even the simplest thing. i'm trying to read in a csv file... and then print it back out
13:55:06 <watermind> Eduard_Munteanu: right
13:55:31 <Eduard_Munteanu> aniero: how so?
13:55:38 <Cale> aniero: and you want to actually parse the fields out, or are you just trying to get reading and writing of arbitrary files to work?
13:55:45 <aniero> Cale: one thing at a time, yeah
13:55:46 <aniero> i'm trying to extract the csv enumerator code into a separate function that will just return either [] if there was an error, or [MapRow] if it was ok
13:55:50 <nooodl> Cale: i vaguely understand
13:55:57 <aniero> but im getting type mismatches. lemme paste the code, 1m
13:57:06 <elliott> is there a way to refer to (,) :: Constraint -> Constraint -> Constraint and () :: Constraint at the type level with GHC 7.6.1?
13:57:18 <elliott> I can do class (a, b) => Both a b; instance (a, b) => Both a b; and class (a ~ ()) => OK a; instance OK ()
13:57:19 <Eduard_Munteanu> nooodl: another way is thinking of what Either a b ~ a + b means via the Curry-Howard isomorphism. That's true if you can prove 'a' or prove 'b'.
13:57:23 <elliott> and use Both for (,) and (OK ()) for ()
13:57:29 <elliott> but that's kind of ugly, having to replicate them like that
13:57:34 <jmcarthur> monochrom: it's still pretty noisy though :\
13:57:38 <elliott> (I'd like to pass them as an argument to a higher-order type function)
13:57:48 <jmcarthur> it's okay. i'll just take this opportunity to write a diff tool i've been wanting to write for a while
13:58:05 <jmcarthur> not as powerful as the one i really want in this case, but should help at least
13:58:09 <hpaste> aniero pasted “csv read parse” at http://hpaste.org/76539
13:58:16 <elliott> oh!
13:58:18 <elliott> (() :: Constraint) works
13:58:32 <hpc> elliott: heh, was about to say...
13:58:33 <elliott> but ((,) :: Constraint -> Constraint -> Constraint) doesn't :(
13:58:39 <elliott> so now I only have one question rather than two
13:58:52 <hpc> elliott: (foo, bar) :: Constraint
13:59:05 <aniero> Cale: i imagine i'm making a very basic mistake
13:59:18 <elliott> hpc: that doesn't work -- like I said, I want to pass it to a higher-order type function
13:59:22 <hpc> if you want (,) directly, ah
13:59:27 <hpc> yeah, gonna have to use Both, then
13:59:34 <elliott> if I could write (\foo bar -> (foo, bar) :: Constraint) or whatever that would work, but there aren't any type lambdas :)
13:59:35 <elliott> right
13:59:45 <dmwit> Overloading (,) seems like a reasonable feature request for the Trac.
13:59:56 <Cale> aniero: You want to mapM over the results of the action wtf
14:00:02 <elliott> well, it's already overloaded as in (a, b), just not (,) itself
14:00:21 <Cale> aniero: mapM_ :: (a -> IO b) -> [a] -> IO ()
14:00:21 <elliott> I hear the overloading of (a, b) itself is already quite a big hack, seems like there could easily be big issues with overloading just (,)
14:00:29 <elliott> aw, "type OK = () :: Constraint" doesn't work
14:00:34 <Cale> aniero: but wtf :: IO [MapRow]
14:00:42 <hpc> clearly we need general-purpose level inference :P
14:00:47 <elliott> aha
14:00:48 <monochrom> jmcarthur: with -dsuppress-uniques, names no longer have randomized suffixes, so diff should be a bit more successful. there are also a couple of other -d options to reduce output
14:00:50 <aniero> Cale: hmm.
14:00:50 <elliott> type family OK :: Constraint; type instance OK = ()
14:00:51 <elliott> that works
14:00:59 <elliott> oh I can probably define Both as a type family too
14:01:03 <Cale> aniero: So it's not a suitable second parameter to mapM_, but it is an IO action, which if we ran it, would give us one.
14:01:05 <aniero> Cale: lol, "wtf" is a terrible name for a function, i keep reading it as commentary
14:01:19 <aniero> Cale: ok, thanks, i'll take a look. back in a few
14:01:23 <Cale> Also, wtf is not a function :)
14:01:46 <int-e> @let wtf = "sure is"
14:01:47 <lambdabot>  Defined.
14:02:11 <elliott> oh, I can't define it as a type family... since you can't partially apply it
14:02:17 <dmwit> Other languages use "function" to mean "reusable code block". I think that's sort of the place that the confusion arises.
14:02:46 <elliott> *Main> :k Foldr Pair Unit (Map Show '[Int, String])
14:02:46 <elliott> Foldr Pair Unit (Map Show '[Int, String]) :: Constraint
14:02:46 <elliott> :)
14:02:59 <jmcarthur> monochrom: i'm making a diff tool that shows which parts of each chunk is the difference with colors, which should help me to pick out what changes are just identifiers and what changes are more significant, i think
14:03:08 <dmwit> elliott: You might like :k!
14:03:26 <dmwit> :kind! I mean
14:03:32 <dmwit> It's a shame that :k! doesn't work.
14:03:44 <elliott> Right, :kind! is cool.
14:03:52 <elliott> but :k! doesn't work, so I never remember to use it :)
14:03:57 * hackagebot tuple-hlist 0.1.0.1 - Functions to convert between tuples and HLists.  http://hackage.haskell.org/package/tuple-hlist-0.1.0.1 (NicolasDudebout)
14:04:05 <Eduard_Munteanu> Customers who bought :k also bought: :kind!
14:04:40 <Cale> aniero: Let me know when you're back and I'll finish explaining
14:06:39 <elliott> dmwit: It's also a shame that :k doesn't work on partially-applied stuff.
14:07:14 <dmwit> It doesn't?
14:07:28 <dmwit> I guess you meant partially applied type {families,aliases}.
14:07:29 <nand`> what is :kind! supposed to be doing?
14:07:40 <dmwit> nand`: It does type-level evaluation.
14:07:47 <nand`> oh
14:09:11 <nand`> :def k! return . (":kind! "++)
14:09:41 <nand`> drop that in .ghci elliott :)
14:10:08 <elliott> oh cool
14:10:10 <elliott> thank you!
14:10:19 <elliott> dmwit: if I define type All p xs = Foldr Pair Unit (Map p xs)
14:10:30 <elliott> then :k All -> Type synonym `All' should have 3 arguments, but has been given
14:10:36 <elliott> ok, it involves type families, but -- none of them partially applied
14:10:45 <nand`> partially applied type alias
14:10:53 <elliott> er, right, it is an alias
14:11:10 <dmwit> Sorry, I used the wrong term. I said alias when I meant synonym.
14:11:18 <elliott> right
14:11:27 <dmwit> nand`: That's cute, thanks. Now I can use :k!
14:11:57 <elliott> turns out `mapElimH :: (All c ts) => (forall a. (c a) => a -> r) -> HList ts -> [r]` is significantly trickier to write...
14:12:11 <nand`> it has come in handy for :def T return . (":t "++) -- because I constantly mistype that
14:12:13 <magthe> can I use doctest together with FFI?
14:12:52 <dmwit> I don't see why not.
14:14:56 <magthe> dmwit: the problem I have is to somehow get it to load the .o file... that is when running `doctest foo.hs`, which requires foo.o to be loaded too
14:20:01 <nand`> what's the performance of parsec on CFGs like?
14:20:27 <nand`> I wonder how it compares to eg. shift/reduce
14:22:44 <elliott> hm, apparently I have no idea how constraint propagation works in GHC
14:23:04 <aniero> Cale: back, sorry. alright... so i need to do:    result <- wtf    and then  mapM over result ?
14:23:18 <Cale> aniero: yes
14:23:22 <aniero> and if wtf isn't a function, what is it?
14:23:28 <Cale> It's an IO action
14:23:30 <otters> a monadic action
14:23:36 <aniero> ahhh ok
14:23:38 <Cale> s/monadic/IO/
14:23:44 <otters> IO is a monad
14:23:46 <Cale> No need to be generic here
14:23:51 <otters> finally!
14:23:56 <Cale> IO is a monad, but that is not so relevant :)
14:24:04 <aniero> ok, that makes sense. thanks!
14:24:15 <nooodl> wikipedia/haskellwiki on kinds: 'A kind system is essentially a simply typed lambda calculus "one level up" [...]'
14:24:17 <otters> lambdabot: quote
14:24:20 <nooodl> what if you go "two levels up"?
14:24:23 <Cale> aniero: It has no parameters, so it can't be a function. :)
14:24:39 <aniero> Cale: oh, er, right... my intent was the filename as a parameter, i just left that out
14:24:42 <Cale> aniero: We call something a function when it has type A -> B where A and B are some types
14:25:05 <Lemmih> lispy: Hm, maybe.
14:25:07 <aniero> yeah, gotcha. this just has type IO [MapRow] then
14:25:10 <Cale> right
14:25:52 <b_jonas> and an IO action is something that has type (IO a) for some type a, right?
14:26:57 <merijn> b_jonas: Yes
14:28:32 <gwern>  http://ro-che.info/ccc/15.html bwahaha
14:30:19 <lpvb> I still have no idea how to make this work :(
14:30:21 <raek> I wrote this recently, feedback is welcome: http://blog.raek.se/2012/10/19/haskell-io-in-five-minutes/
14:30:40 <int-e> gwern: Oh yes.
14:31:10 <int-e> gwern: Is that supposed to be funny? ;-)
14:32:11 <lpvb> Really need a function that takes an IO action and delay, and only executes the action if the current time is greater than time time since the last execution + delay
14:34:47 <gabor> byorgey: does 7.6.1 support type *variable* promotion (to be a kind variable)?
14:34:57 <gabor> byorgey: i.e. class Foo t where data Bar t :: t -> *; ...
14:36:35 <elliott> hm
14:37:00 <Kyraimion> lpvb:  \delay action -> threadDelay delay >> action ?
14:37:13 <hpaste> elliott pasted “hlist type hackery” at http://hpaste.org/76540
14:37:27 <elliott> does anyone know why the simpler definition of mapElimH there doesn't work? ^
14:37:39 <elliott> the (p a) constraint in the forall seems to be leaking out when I use it as an argument to mapElimH
14:37:40 <elliott> but I can't figure out why
14:38:44 <lpvb> Kyraimion: that definitely will execute action eventually, what I want is the execution to be conditional on time so that it doesn't do anything if the current time is not delay + last execution time
14:39:34 <elliott> huh. and I can't even define the working one as mapElimH' and do mapElimH :: (All p ts) => (forall a. (p a) => a -> r) -> HList ts -> [r]; mapElimH f = mapElimH' (To f)
14:39:37 <elliott> can anyone explain this behaviour?
14:40:34 <aniero> yeah, gotcha. this just has type IO [MapRow] then
14:40:35 <aniero> ae.
14:40:36 <aniero> ahem.
14:40:44 <aniero> up-arrow-enter + irc *sigh*
14:41:06 <lispy> Lemmih: He got it working on windows
14:41:55 <jmcarthur> gabor: isn't that just PolyKinds?
14:42:44 <gabor> jmcarthur: no, observe hat 't' appears in type 'and' kind position
14:43:11 <gabor> *and*
14:43:19 <elliott> wtf!
14:43:28 <elliott> I can do
14:43:53 <elliott> wrap :: (To p r -> k) -> (forall a. (p a) => a -> r) -> k; wrap f g = f (To g); mapElimH :: forall p ts r. (All p ts) => (forall a. (p a) => a -> r) -> HList ts -> [r]; mapElimH = wrap mapElimH'
14:43:58 <elliott> but not
14:43:59 <elliott> mapElimH :: (All p ts) => (forall a. (p a) => a -> r) -> HList ts -> [r]; mapElimH f = mapElimH' (To f)
14:44:20 <elliott> I guess I really do not understand how GHC's fanciest type system extensions work at all
14:44:27 <lispy> Lemmih: If you're open to putting the repo on github (or a mirror of it), then I can help (putting that offer out there)
14:45:05 <lispy> Lemmih: IIRC, byorgey does darcs and git copies of his stuff
14:45:11 <lispy> Or maybe it was neil?
14:45:14 * lispy has a bad memory
14:45:42 <Twey> Is there a good introduction to fgl around?
14:46:04 <lispy> Twey: you want ivanm
14:46:46 <lispy> Twey: I think it's out of date, but the original author Martin Erwig might have something here: http://web.engr.oregonstate.edu/~erwig/fgl/
14:47:03 <Twey> Hugely out of date — says it's from 2001
14:47:14 <jmcarthur> gabor: oh i see
14:47:23 <jmcarthur> let's try it!
14:47:50 <jmcarthur> gabor: "Type variable `t' used in a kind\nIn the kind `t -> *'"
14:47:53 <Twey> http://web.engr.oregonstate.edu/~erwig/fgl/haskell/ is slightly newer
14:48:14 <lispy> Twey: yikes :( But, hey the paper that is the foundation for it may still prove useful for understanding the intent of the API: http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP01
14:48:35 <Twey> Maybe — thanks ☺
14:49:14 <Twey> I'm trying to find all the possible paths in a given graph.  I thought fgl might be helpful.
14:49:44 <lispy> Twey: yeah, I bet it can do that (never used it). ivanm could tell you for certain
14:49:52 <lispy> preflex: seen ivanm
14:49:52 <preflex>  ivanm was last seen on #haskell 2 days, 49 minutes and 9 seconds ago, saying: shachaf: fast to prepare + cook, fast to be eaten or fast to go through your system? :p
14:51:49 <lispy> my goal for hacking today is to see if I can implement some limited notion of parametric polymorphism
14:52:02 <Twey> In what?
14:52:02 <lispy> But, I've had a terrible time locating the code for my STLC implementation
14:52:24 <Twey> Oh
14:52:33 <lispy> Twey: I have some code I wrote following very closely with the dependently typed lambda calculus tutorial
14:52:41 <Twey> ‘A Tutorial Implementation’?
14:52:50 <lispy> Twey: http://www.andres-loeh.de/LambdaPi/
14:52:53 <Twey> Yes
14:53:02 <Twey> That already includes parametric polymorphism, though
14:53:21 <lispy> So far I've only followed along to the point of implementing STLC
14:53:24 <Twey> Oh, right
14:53:49 <lispy> I wanted to deviate from them a bit and add just enough polymorphism to try writing HOL on top of it
14:54:00 <lispy> Instead of going all the way to dependent types right off the bat
14:54:04 <Twey> Mm
14:54:15 <Twey> It's not really a stepping-stone, though
14:54:27 <lispy> oh?
14:54:39 <Twey> Löh implements dependent types à la Agda, with types-as-values and then functions from values to types
14:54:50 <lispy> But HOL uses the STLC + a few polymorphic axioms
14:54:54 <`Jake`> raek: I think reddit is better than irc to get feedback.
14:54:59 <Twey> Which completely sidesteps having type-to-type functions as a special case
14:56:14 <lispy> Twey: I hope we're talking about different things.
14:56:29 <Twey> I don't *think* we are
14:56:46 <lispy> Twey: My plan was to implement the STLC and then add just enough polymorphism to give the axioms that HOL Light uses
14:56:55 <Twey> Right
14:57:29 <lispy> So, if I take their STLC and add what I think is called rank 1 types, that should be enough to give the HOL Light axioms, righ?
14:57:35 <lispy> Or am I missing something?
14:57:35 <Twey> Sure
14:58:05 <Twey> No no, you're quite right; it's just that that's not a component of what Löh does next, if your aim is to use it as a half-way point towards dependent types
14:58:15 <hpaste> lpvb pasted “global state problem” at http://hpaste.org/76541
14:58:17 <lispy> OH
14:58:27 <lispy> Twey: yeah, no I plan to completely branch from the DTs
14:58:29 <Twey> The paper implements parametric polymorphism in a completely different (and more elegant) way
14:58:29 <lpvb> ^^ anyone know how to fix that ugliness?
14:58:33 <Twey> Ah, okay
14:58:44 <Twey> Carry on then ☺
14:58:58 * hackagebot yst 0.3 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.3 (JohnMacFarlane)
14:59:04 <lispy> Twey: eventually I'd like to follow both paths (having a HOL Light from scratch and a DTLC from scratch)
14:59:21 <Twey> Why's that?
14:59:29 <lispy> Learning exercise
14:59:33 <danharaj> lispy: do you know where to get the header files from which the openglraw bindings are derived?
14:59:36 <Twey> Fair enough
15:00:14 <lispy> danharaj: You mean like the OpenGL specification, their example .h files, or do you need it for compilation?
15:01:12 <roconnor> edwardk: Any slides available?
15:01:28 <elliott> AIUI the header files are standardised
15:01:37 <elliott> so you can just use the ones from the opengl website
15:02:33 <danharaj> lispy: I want to poke around OpenGLRaw and in particular getting a compact version that only exports opengl 4, so I figure I should start by understanding how to write and build raw from scratch.
15:02:34 <lispy> elliott: that's roughly my understanding too. I think I ran into a case once where the vendors added extra CPP magic for their platform.
15:03:18 <lispy> danharaj: They publish the full API with version info in an xml form
15:03:49 <lispy> danharaj: http://www.opengl.org/registry/
15:05:37 <lispy> danharaj: Someone was writing a tool to automatically generate the OpenGLRaw package
15:05:43 <lispy> danharaj: You might want to take a look at it
15:06:06 <danharaj> lispy: ah ok, and I take it glcorearb.h is what I asked for
15:06:53 <gabor> jmcarthur: that is a pity. probably byorgey did not think of this kind of promotion ;-)
15:07:50 <lispy> danharaj: Sure :) (I actually don't know that, but if you inferred that from my link then I'm sure you're right)
15:08:16 <danharaj> lispy: I am not very good at being right. :P
15:08:33 <lispy> danharaj: https://github.com/Laar/OpenGLRawgen
15:08:39 <danharaj> oh cool
15:08:51 <danharaj> I was about to dig into the mailing list archives because I remembered seeing it there :P
15:08:55 <danharaj> you saved me a few minutes indeed.
15:09:07 <dmwit> lpvb: main = forever (threadDelay 5000000 >> putStrLn "Action")
15:09:24 <dmwit> bonus: it won't busy-loop when it's not doing anything
15:09:38 <lispy> danharaj: gmail search is nice
15:11:21 <osfameron> yup.  much nicer than, well, any native client I've ever used...
15:12:46 <lpvb> dmwit: I'm not looking for a replication of the main loop effects, what I'm interested in is the whenTimePassedDo function. I have code that needs to only execute conditionally based on current time and do nothing otherwise. forever (threadDelay 5000000 >> putStrLn "Action") will always execute action and is not dependant on time.
15:13:28 <lispy> lpvb: Just glancing at what you have here, it feels like you would benefit from a custom monad
15:14:00 <lispy> lpvb: specifically, one that carries around this timer as part of the context
15:14:55 <dmwit> A custom State monad would be one way. Having one thread managing timing and the main thread passing off action requests would be another.
15:15:31 <merijn> Doesn't this sound like wanting FRP?
15:15:49 * dmwit doesn't know enough about FRP to judge
15:16:15 <lispy> merijn: Hm...like dmwit I don't know enough to judge, but it sounds reasonable to me
15:16:35 <lpvb> If I used a state monad, how would I keep track of the last execution times for any aciton I want to pass?
15:17:10 <lpvb> I don't want to explicitly keep creating new state variables for each action I want
15:17:40 <lispy> lpvb: Wouldn't you store the state in the monad and then reference it as needed?
15:17:58 <lispy> where the state is the IORef you have now
15:18:25 <lpvb> but that IORef only holds one execution time for one action
15:18:27 <merijn> lpvb: FRP lets you write things like "do X every Y time units" but learning FRP might be a bit of work with no experience :p
15:19:02 <lpvb> I want "do X if time since last X > delay"
15:19:22 <lpvb> can FRP do that?
15:19:29 <hpaste> dmwit annotated “global state problem” with “global state problem (annotation)” at http://hpaste.org/76541#a76543
15:19:34 <dmwit> Look ma, no global state!
15:19:56 <dmwit> oh wait
15:20:36 <dmwit> I suppose an MVar is enough. No need for a Chan.
15:20:45 <dmwit> (And in fact you probably don't want a Chan.)
15:21:43 <elliott> there is no way to construct a Const :: * -> * -> * such that (Const a) (i.e. partial application) is valid and (Const a b ~ a), right?
15:21:50 <elliott> because that would be very convenient :/
15:22:05 <dolio> elliott: Correct.
15:22:55 <ryant5000> is there a typeclass for determining whether two values are "adjacent"?  I.e.: a and b are adjacent iff there is no value c such that a < c < b
15:23:33 <elliott> dolio: not even with GHC type hackery? :(
15:23:39 <elliott> I guess it would mess stuff up
15:24:02 <roconnor> ryant5000: if Enum weren't so stupid you could compare (succ x) and y.
15:24:11 <roconnor> (and (succ y) and x
15:24:21 <ryant5000> roconnor: yeah, i thought about that; but for some types, e.g., Rational, there's no succ or pred anyway
15:24:32 <ryant5000> (so, isAdjacent would always return false, but that would make sense)
15:24:37 <roconnor> ryant5000: ya, those shouldn't be in Enum
15:24:40 <ryant5000> right
15:24:53 <ryant5000> i find myself writing a type for intervals
15:25:06 <ryant5000> and i realized that, for discrete types, i can't determine whether a range is empty or not
15:25:12 <roconnor> ryant5000: I think you are on your own
15:25:24 <ryant5000> ok, cool; that's no problem, just wanted to use something existing if there was anything
15:25:38 <lpvb> dmwit: it has a space leak, and how would you do it with MVar? I haven't read up on Chan yet
15:26:18 <jmcarthur> ryant5000: wouldn't it be more useful to define ranges as [a,b) instead of (a,b)? it would at least make your problem easier
15:26:52 <ryant5000> jmcarthur: i'm allowing any openness on either side
15:26:57 <jmcarthur> ah
15:27:16 <ryant5000> i might scrap that if it's too much trouble
15:27:36 <ryant5000> but i need to be compatible with the Postgres range types
15:27:41 <jmcarthur> oh
15:27:43 <ryant5000> and they support all opennesses
15:31:02 <wereHamster> what's the name of the bot or command that can simplify terms?
15:31:22 <lpvb> @pl (\x y -> x + y)
15:31:22 <lambdabot> (+)
15:31:25 <lpvb> ?
15:31:36 <wereHamster> thanks.
15:31:52 <lpvb> there's also a command in http://hackage.haskell.org/package/pointfree
15:32:01 <int-e> @pl \s i m p l e -> m e s i l p
15:32:02 <lambdabot> (((flip . (flip .) . flip) .) .) . flip . (flip .) . flip flip
15:33:13 <Polarina> int-e, is in intentional that you reversed simple incorrectly?
15:33:34 <int-e> Polarina: yes (I aimed for a random order)
15:33:47 <Polarina> int-e, ah, just checking. :)
15:34:35 <int-e> @. unpl pl (\x y -> x + y, \s i m p l e -> m e s i l p)
15:34:35 <lambdabot> ((+), (\ ab ar au b c f -> au f ab ar c b))
15:35:19 <lpvb> merijn: what are some recommended FRP libraries?
15:36:25 <Polarina> lpvb, reactive-banana is nice for beginners -- has good examples, etc. netwire is another recent one.
15:37:51 <b_jonas> "ab ar au b c f"? where did it get those names?
15:38:04 <b_jonas> ah, unpl pl
15:38:09 <b_jonas> @pl (\x y -> x + y, \s i m p l e -> m e s i l p)
15:38:09 <lambdabot> ((+), (((flip . (flip .) . flip) .) .) . flip . (flip .) . flip flip)
15:38:43 <Polarina> lpvb, if you want to take a look at netwire, look at the version here: http://darcs.ertes.de/netwire -- it's more recent and in development.
15:39:39 <int-e> b_jonas: @. unpl pl  is a bit closer to what I'd consider a simplification than @unpl alone. But the results will be a bit more pointy that I like :)
15:39:41 <lpvb> Polarina: thanks
15:40:01 <elliott> augh.hs:40:13: Couldn't match kind `k' against `k'
15:40:05 <int-e> b_jonas: err @pl alone. (sorry, it's past midnight. I should sleep)
15:40:12 <elliott> Kind incompatibility when matching types: b :: k; c0 :: k
15:40:19 <elliott> does this set a new record for least helpful GHC type error message ever
15:40:23 <elliott> well it's a kind error but
15:40:25 <shachaf> elliott: type Foo k a = Int
15:40:26 <shachaf> :i Foo
15:40:29 <shachaf> type Foo k k k a = Int 	-- Defined at <interactive>:2:6
15:40:50 <Polarina> elliott, my worst is "parse error (possibly incorrect indentation)"
15:40:51 <b_jonas> elliott: what code?
15:41:01 <shachaf> GHC has this "thing" where it likes to name every kind variable k.
15:41:16 <b_jonas> since when do we have kind variables?
15:41:24 <elliott> b_jonas: class IsConst a b where proof :: (forall c. (b ~ Const a c) => r) -> r
15:41:28 <elliott> instance IsConst a (Const a b) where proof k = k
15:42:03 <b_jonas> I see
15:43:25 <heatsink> Isn't the type of proof ambiguous, since a and b can't be determined from r?
15:44:35 <b_jonas> heatsink: elliott showed what he's got an error message for. it's not meant to be correct code.
15:44:46 <heatsink> ok
15:44:50 <zzing> If I had a YAML file that contained data I wanted to extract to a specific data type, would it make sense to have somethiing like  withYamlFile "blah.yaml" $ do …    where it picks out what it wants and returns a datastructure you need?
15:47:32 <heatsink> Where do you prefer to put a comment that describes one branch of an if or case expression?
15:48:09 <merijn> lpvb: netwire and reactive-banana seem to be the current popular ones
15:49:16 <merijn> zzing: Sure, why not. Maybe wrap it in a maybe/either to indicate possible errors
15:53:57 <zzing> merijn, that could work very well. Most of the time I have heard people talk about using EitherT for errors I believe. I wouldn't mind that one as a good one to try.
15:54:57 <elliott> <heatsink> Isn't the type of proof ambiguous, since a and b can't be determined from r?
15:55:05 <elliott> Adding p a -> p b -> doesn't help, and it wouldn't be a kind error anyway.
15:55:15 <elliott> (I think it is actually OK, since you have a and b in the context, anyway.)
16:00:45 <edwardk> @tell roconnor check the bahaskell mailing list
16:00:46 <lambdabot> Consider it noted.
16:02:20 <heatsink> Oh I see, GHC is generalizing over kinds
16:03:59 * hackagebot algebra 3.0.1 - Constructive abstract algebra  http://hackage.haskell.org/package/algebra-3.0.1 (EdwardKmett)
16:11:27 <djahandarie> Does anyone know what sort of interesting algorithmic things you can do with a module over a ring?
16:13:49 <joshcheek> Hi, I'm reading "Programming in Haskell", the author pattern matches like this `drop (n+1) [] = []` but when I try, I get "recursive-functions.hs:10:7: Parse error in pattern: n + 1"
16:14:17 <ezyang> joshcheeck: n+1 patterns were dropped from the language
16:14:33 <ezyang> so replace n+1 with n and any instances in the body with n-1
16:15:10 <ion> joshcheek: Are you familiar with LYAH?
16:15:12 <ion> @where lyah
16:15:12 <lambdabot> http://www.learnyouahaskell.com/
16:15:21 <joshcheek> ezyang: Okay, thank you. Does the language move fast enough that this book should be considered out of date? (e.g. I usually work w/ Ruby/Rails, and I wouldn't read a book from an older version)
16:15:55 <joshcheek> ion: Yes, I bought that one too, but it's a lot longer, so I wanted to go with the one I was most likely to complete.
16:17:34 <slack1256> the option ':set +s' shown on ghci with every computation. How accurate is?
16:22:20 <fmap> slack1256: you shouldn't profile with `:set +s' in ghci, if that's what you ask
16:23:36 <slack1256> I thought so.
16:24:07 <lpvb> joshcheek: lyah took me about a week to read
16:32:24 <augur> i know SPJ gave a talk once that explains how type classes factor into quickcheck
16:32:31 <augur> anyone remember which talk this was in?
16:34:51 <Cale> augur: I think it was part of a general introduction to Haskell talk that he gave
16:35:27 <Cale> augur: The "A Taste of Haskell" talks, I think
16:36:03 <augur> ill check it out, thanks
16:36:15 <Cale> He didn't go into too much detail
16:36:30 <Cale> It's probably not the easiest way to figure out how QuickCheck uses its typeclasses.
16:37:24 <Cale> http://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf
16:37:43 <jmcarthur> i don't think it was A Taste of Haskell
16:38:02 <jmcarthur> i remember a dark room
16:38:12 <jmcarthur> and some sort of graph algorithm
16:38:29 <jmcarthur> sounds like the beginning of a geeky text adventure game
16:38:38 <augur> jmcarthur: was it that talk? i know he talks about it there but i also have a distinct memory of the talk giving nice clear details that were easy to see on the screen :p
16:38:44 <Cale> Well, he does have a way of recycling slides
16:38:45 <augur> and that one isnt easy to read!
16:38:56 <augur> jmcarthur: http://video.google.com/videoplay?docid=-4991530385753299192 btw
16:39:02 <jmcarthur> i remember quickcheck in that talk and not in taste of haskell
16:39:17 <jmcarthur> but it's been a while since seeing either
16:39:42 <jmcarthur> yeah this is the talk i'm thinking of, but not necessarly the talk you are looking for
16:41:31 <augur> i dont think it was this one tho because i remember he actually explains how quickcheck does its magic
16:43:16 <lispy> joshcheek:
16:43:26 <joshcheek> lispy: yes?
16:59:18 <augur> Cale: which talk was it where SPJ talked about things like type variables in classes, etc. as a new feature?
17:01:33 <pordan30> is there any reason to tokenize input using parsec when parsing simple languages (e.g., core), as opposed to directly parsing an input stream?
17:04:35 <Cale> pordan30: Sometimes it can be nice to be able to write your parsers without worrying about some details of the lexical syntax
17:04:52 <Cale> pordan30: Like, worrying about eating spaces around tokens correctly
17:05:00 <danharaj> it's really a separation of concerns
17:05:04 <Cale> augur: Type variables in classes?
17:05:55 <augur> yeah theres some new thing where you can define a type "variable" in a type class
17:06:41 <Cale> Do you mean class associated types?
17:06:54 <augur> maybe!
17:07:13 <pordan30> cale: if its a design decision, not a limitation of the parsec library, then that's acceptable. thanks :)
17:09:02 <augur> gwern: haha you were credited for contributing to GHC in simons HIW slides as "gwern"
17:09:03 <augur> ahaha
17:12:27 <fliip> Erm, not a haskell question but maybe someone can help me! What does the following lambda substitute to? (\x.yx)[yz/x]
17:13:16 <hpaste> dmwit annotated “global state problem” with “global state problem (annotation) (annotation)” at http://hpaste.org/76541#a76547
17:13:27 <dmwit> lpvb: That shows how to use an MVar.
17:13:37 <dmwit> Chan had a space leak because the requester was racing ahead of the consumer.
17:13:46 <dmwit> (Which is why I suggested MVar would be better.)
17:14:11 <dmwit> It also shows how to make startTimerThread's API independent of its implementation technique, which I should have done with the Chan version, too.
17:14:52 <dmwit> fliip: That exact substitution results in (\x.yx).
17:15:15 <dmwit> If you meant "what does (yx)[yz/x]" do, then it would be (y(yz)).
17:15:42 <fliip> No sorry. I was asking what it substitutes to. Is it because x is not a free variable?
17:15:57 <dmwit> I don't understand the question.
17:16:11 <dmwit> Or rather, I don't understand how your corrected question clarifies what I was asking about your question.
17:16:22 <fliip> eg) (\x.yx)[zz/y] = \x.zzx?
17:16:36 <augur> fliip: correct
17:16:37 <dmwit> yes
17:16:46 <fliip> So because x is bound, it cant be substituted?
17:16:51 <fliip> Ok I get it! Thanks =)
17:17:13 <augur> substitution does not pass under binders for the same variable, yeah.
17:17:16 <augur> the rules for substitution are
17:17:41 <augur> v[a/x] = a if v == x, and v otherwise
17:17:57 <augur> (m n)[a/x] = m[a/x] n[a/x]
17:18:13 <a215> :t (+)
17:18:14 <lambdabot> forall a. (Num a) => a -> a -> a
17:18:23 <a215> :t +
17:18:24 <augur> (\v.m)[a/x] = \v.m if v == x, and \v.m[a/x] otherwise
17:18:24 <lambdabot> parse error on input `+'
17:18:41 <dmwit> That last rule needs another condition saying v does not appear free in a.
17:18:43 <a215> can someone explain that to me
17:18:45 <a215> the first one
17:18:55 <augur> dmwit: that too. :)
17:19:05 <fliip> Thanks for that.
17:19:13 <dmwit> a215: Addition is a function which takes any numeric type, and returns a function from another value of that type to a final result of that type.
17:19:41 <Cale> > let addOne = (+) 1 in addOne 5
17:19:42 <lambdabot>   6
17:19:55 <Cale> > ((+) 1) 5
17:19:56 <lambdabot>   6
17:20:06 <fliip> So does (\y.xy)[yx/x] = \z.yxz?
17:20:08 <strebe> > (+1) 5
17:20:09 <lambdabot>   6
17:20:10 <a215> oh right
17:20:11 <a215> currying
17:20:22 <dmwit> fliip: right
17:20:27 <fliip> Got it! Cheers :D
17:23:03 <fliip> Sorry just one more to make sure I have the jist of things... Im not sure which scope to apply this following one to:
17:23:43 <fliip> (\z.(\x.yx)xz)[zx/x] = \p.(\x.yx)zxp
17:23:51 <fliip> ?
17:24:23 <dmwit> That looks right, yes.
17:24:35 <fliip> Cool, so you only apply it to the outside scope?
17:24:53 <dmwit> What is "it"?
17:24:56 <fliip> Or... Was it just because the x was bound in the inner scope?
17:25:02 <fliip> Ok I guess it was.
17:25:07 <rwbarton> yes
17:25:17 <fliip> Sorry, yeh. Obvious. lol
17:25:19 <fliip> Thanks =)
17:25:49 <augur> fliip: you should work with the explicit definition a bit
17:25:56 <augur> throw some random things at it and see what it does
17:26:12 <augur> just to get a more concrete feel for how the thing works formally
17:27:02 <fliip> Sorry what?
17:27:08 <fliip> Explicit definition?
17:28:25 <otters> I've written an IRC bot in Haskell, and I want to make plugins that are either interpreted or compiled and loaded
17:28:37 <dmwit> ?hackage hlint
17:28:38 <lambdabot> http://hackage.haskell.org/package/hlint
17:28:38 <dmwit> ?hackage ghc
17:28:39 <lambdabot> http://hackage.haskell.org/package/ghc
17:28:57 <otters> so if the plugins are compiled, the bot itself doesn't have to be available on the system as a library, right?
17:29:24 <dmwit> Seems the documentation for the GHC API isn't on Hackage.
17:29:27 <dmwit> So that's a shame.
17:30:09 <otters> I'm not really sure how linking works with binaries created by GHC
17:30:50 <otters> like if I compile a program that depends on, say, Attoparsec, can the binary run on a system that doesn't have haskell platform or that package?
17:31:04 <shachaf> Yes.
17:31:49 <otters> So if plugins depend on the bot library to install, I can distribute compiled binaries of them that people can use without needing the bot on the system as a library.
17:32:39 <`Jake`> Is there a difference for lambdabot between '?' and '@'?
17:33:15 <dmwit> no
17:33:22 <`Jake`> tahnks
17:35:30 <gwern> augur: simon can credit me as gwern all he likes, I'm not ashamed of my nick!
17:35:37 <augur> :)
17:36:58 <Cale> It was funny to see this list with everyone's full name except for gwern
17:37:10 <shachaf> Cale: gwern and that one other person.
17:37:41 <shachaf> "shelarcy"
17:37:55 <gwern> see? isn't that an uglier nick than 'gwern'
17:38:05 <dmwit> <sad gum guy>Nobody ever credits ME by by nick.</sad gum guy>
17:38:32 <gwern> dmwit: probably because it's too easy to look your name up
17:38:59 <shachaf> dmwit: Should I credit you by by nick?
17:39:17 <otters> if you specify a library and an executable in a .cabal file, and don't define the build-depends for one of them, does cabal use the build-depends for the other automatically?
17:39:38 <dmwit> I don't think so.
17:39:56 <dmwit> Seems like any easy thing to test if you care to, though.
17:40:00 <otters> Yeah.
17:40:15 <shachaf> dmwit: The easy way to test things is to ask them in #haskell!
17:40:41 <otters> Well, I did just test it, and it behaved as though the answer to my question was yes
17:40:51 <otters> but I was making sure I wasn't missing any edge case that would catch me off guard
17:41:21 <dmwit> Hm. Are you sure that's how it behaved?
17:41:53 * dmwit runs his own test
17:42:00 <mm_freak> stackoverflow deleted my answer again for no apparent reason…  i'm stopping haskell support on SO
17:43:41 <otters> dmwit: I'm pretty sure. I just listed the exposed/other modules in the Library section
17:43:47 <otters> Build-depends and ghc-options were in the Executable section
17:44:01 * hackagebot pappy 0.1.0.2 - Packrat parsing; linear-time parsers for grammars in TDPL.  http://hackage.haskell.org/package/pappy-0.1.0.2 (ChrisDone)
17:44:56 <monochrom> I bet software error losing your post is more likely than some moderator deleting your post
17:45:26 <dmwit> Huh, it does seem to act that way.
17:45:50 <dmwit> mm_freak: Which question?
17:46:03 <monochrom> after all, it's called Stack Overflow :)
17:46:16 <mm_freak> dmwit: http://stackoverflow.com/questions/4191424/where-can-i-get-a-good-tutorial-about-how-to-use-arrows
17:46:38 <dmwit> Are you ertes?
17:46:42 <mm_freak> yes
17:47:22 <mm_freak> notice that there are probably hundreds of unregistered accounts with the name 'ertes'…  they are all me =)
17:47:55 <monochrom> why do you have hundreds of unregistered accounts?
17:48:23 <dmwit> Hm. Well, I tried to vote to undelete it (it seems no worse than, say, stephen tetley's answer), but it seems moderators overrule trusted users.
17:50:02 <mm_freak> monochrom: because i don't want to register
17:50:39 <monochrom> that's cool, but why hundreds, not just one?
17:50:54 <mm_freak> monochrom: because cookies expire when i close my browser
17:51:21 <monochrom> and it makes you create a new account after that?
17:51:55 <dmwit> mm_freak: I flagged it for moderator attention; perhaps it will become undeleted eventually.
17:52:00 <cmccann> apparently mm_freak is determined to make it inconvenient for other people to find his contributions on SO.
17:52:05 <mm_freak> monochrom: i just post…  the account is created automatically
17:52:24 <joeyh> stateless haskell support
17:52:28 <mm_freak> cmccann: i think i explained to you why i don't want to register =)
17:52:35 <cmccann> yes.
17:52:35 <dmwit> "Because I don't want to" seems like a perfectly cromulent reason not to register.
17:52:39 <cmccann> I continue to disagree.
17:52:59 <monochrom> well, strange system
17:53:07 <cmccann> but if that's how you want to do it, such is life.
17:53:08 <mm_freak> cmccann: there is really no room for agreement here, as this is a personal thing
17:53:49 <mm_freak> "i don't want to drink orange juice" — "i disagree"
17:54:54 <cmccann> I'll try to remember that next time someone declines a beverage.
17:54:57 <cmccann> it would be funny.
17:54:57 <monochrom> well, I was hoping that the moderators are reasonable. but if they turn out to be unreasonable, I'm more than happy to see SO crash and burn
17:55:11 <mm_freak> dmwit: anyway, if you don't post within five minutes after the question has been asked, your answer doesn't get much attention anyway, regardless of its quality =)
17:55:17 <mm_freak> that's another reason why i don't like SO
17:55:23 <danharaj> I have a question on SO that still has no answers ._.
17:55:32 <danharaj> after many days.
17:55:33 <dmwit> I dunno. I've had a few answers do well when everybody else's were missing the point.
17:55:50 <cmccann> late answers do ok. just not on trivial questions.
17:56:24 <cmccann> "my thingie don't work" "ok do this" &c. late answers to specific stuff like that get ignored.
17:56:25 <otters> Okay so after more research, if I have a Library section and an Executable section, no matter where I put Extensions, they get ignored
17:57:03 <dmwit> otters: In modern Cabal, there's two kinds of extensions declarations.
17:57:10 <cmccann> answers to trickier questions, particularly ones that get a lot of google traffic, continue to get votes for a long time
17:57:18 <dmwit> One says "this code uses these extensions". The other says "use these extensions on all my code".
17:57:28 <dmwit> Perhaps you're using the former when you wanted the latter.
17:57:39 <mm_freak> especially with haskell that often leads to bad answers receiving the green thing
17:57:45 <cmccann> I've even seen questioners change the accepted answer months later on a few occasions
17:57:57 <mm_freak> basic questions trigger hordes of bad answers
17:58:01 <otters> okay, cabal-dev is REALLY confused now
17:58:13 <mm_freak> "how do i turn IO String to String?" — "use unsafePerformIO"
17:58:20 <cmccann> mm_freak, especially with bad questions, not just "basic" ones
17:58:25 <mm_freak> yeah
17:58:38 <cmccann> (obviously the correct answer there is unsafeCoerce, right)
17:58:40 <mm_freak> anyway, i'm done with SO
17:58:44 <cmccann> :[
17:58:57 <dmwit> Good, more karma for me. :3
17:58:59 <shachaf> cmccann: Surely you mean (const "cmccann was here")
17:59:14 <strebe> KirinDave: I solved 58, btw
17:59:34 <cmccann> dmwit, you've got a ways to go if you want #6 on the haskell tag high score table :D
17:59:43 <cmccann> er, #5
18:00:31 <dmwit> There's a high score table?
18:00:37 <cmccann> http://stackoverflow.com/tags/haskell/topusers
18:00:55 <cmccann> nobody will ever catch up to dons
18:00:57 <shachaf> cmccann: It'll take you a very long time to beat my 3 points!
18:01:00 <shachaf> (Lower is better, right?)
18:01:07 <cmccann> sure
18:01:11 <cmccann> we'll go with that
18:01:30 <b_jonas> mm_freak: that's not specific to SO. on any forum, it's only early answers that get attention. it's only more apparently on sites with voting.
18:01:31 <shachaf> cmccann: I've asked two Haskell questions on SO, and dons answered both of them with incorrect and/or irrelevant answers. :-(
18:01:47 <dmwit> neat
18:02:07 <cmccann> I think dons wrote a lot of answers super-fast while waiting for something to compile
18:02:14 <cmccann> so he occasionally misses the point, heh
18:03:08 <dmwit> Anyway, I long ago resigned myself to the fact that any pursuit I try, there'll be lots of people better than me. =)
18:03:50 <cmccann> dmwit, pf, are you really gonna accept being the second-rate daniel?
18:04:22 <dmwit> Oh, hell no. I'm much more like fifth-rate (just ask Google!). ;-)
18:04:34 <cmccann> heh
18:04:36 <shachaf> dmwit: I think the standard solution is to specialize.
18:04:42 <dmwit> I'm not even the first result for "Daniel Wagner UPenn"...
18:04:45 <shachaf> You can be the best at something so obscure that no one else cares about it.
18:05:05 <Saizan> danharaj: which question?
18:05:19 <b_jonas> shachaf: yes, that's how you get a PhD
18:05:28 <dmwit> Although I am the top dmwit in the world.
18:05:47 <cmccann> I don't think I even show up in the google results for my name these days
18:06:10 <b_jonas> you invent something useless that nobody has studied yet, write articles about its properties, put them to dissertation, get PhD
18:06:17 <b_jonas> it's a good recipe
18:06:30 <shachaf> cmccann: Well, you make a special effort to hide. :-(
18:06:44 <cmccann> yeah using initials probably doesn't really help there
18:07:45 <dmwit> Joel Spolsky told me one day that the only way to survive the Internet age is to flood the Internet with information about you and hope your flood beats out the flood of incorrect information about you generated by other people.
18:08:24 <cmccann> (haha
18:08:26 <cmccann> hm
18:08:30 <cmccann> where did that ( come from
18:09:00 <shachaf> Yawgs!
18:09:09 <shachaf> is there a ~ that means "can unify with"?
18:09:36 <cmccann> "can unify with"? or "must unify with"?
18:10:04 <cmccann> if you want to check that without actually causing the types to unify, good luck
18:10:25 <shachaf> cmccann: Ask elliott.
18:11:12 <cmccann> why, what did he do now
18:11:22 <cmccann> I guess I could send him a message with lambdabot
18:11:25 <cmccann> or maybe ten messages
18:12:05 <elliott> (I was wondering whether there was something that let you do something like foo :: (f ~ Int -> String, f ~ Bool -> String) => f -> String; foo f = f 42 ++ f True.)
18:12:15 <elliott> (And then (show :: forall a. (Show a) => a -> String) would be a valid argument to foo.)
18:12:29 <Saizan> "can unify with" is not(not(X = Y)) in prolog, maybe oleg can translate that :)
18:12:37 <shachaf> @ask elliott hi elliott
18:12:37 <lambdabot> Consider it noted.
18:12:44 <cmccann> heh
18:13:17 <elliott> cmccann: (I want this so I can write a fully general map over HLists with DataKinds)
18:13:17 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
18:13:18 <cmccann> elliott, I would strongly suspect that's impossible as of one or two GHC versions ago
18:13:22 <elliott> @clear-messages
18:13:23 <lambdabot> Messages cleared.
18:13:29 <cmccann> whether the recent stuff has changed that I can't say
18:14:09 <cmccann> in particular I'm fairly certain that Oleg's dusty old TypeEq stuff won't help in the slightest
18:14:55 <dmwit> foo :: (Either Int Bool -> String) -> String
18:15:03 <dmwit> No need for anything fancy.
18:15:11 <shachaf> dmwit: I think that was just an example.
18:15:27 <dmwit> I'm aware. I'm just saying I think people jump to fancy stuff too quickly.
18:16:06 <b_jonas> but don't function arguments have to be monotyped anyway?
18:16:41 <dmwit> Not with Rank{2,N}Types.
18:17:04 <cmccann> you could possibly do something goofy with HList-style hackery based on nested sums instead of products
18:17:35 <cmccann> almost all the type-level machinery would be the same, I expect
18:21:00 <mm_freak> b_jonas: compared to most forums SO is /very/ short-lived
18:21:35 <mm_freak> that's not a complaint about missing attention of my posts (they are usually voted quite high), but really a complaint about the whole idea
18:21:47 <mm_freak> SO is like a role-playing game
18:22:17 <Saizan> foo :: forall c. All c (String : Bool : []) => (forall c. c a -> String) -> String <- that would be cute
18:23:21 <Saizan> s/forall c. c a ->/forall a. c a => a ->/
18:26:27 <elliott> <Saizan> foo :: forall c. All c (String : Bool : []) => (forall c. c a -> String) -> String <- that would be cute
18:26:33 <elliott> this is actually more or less what I have
18:26:43 <elliott> mapElimH :: (All p ts) => (forall a. (p a) => a -> r) -> HList ts -> [r]
18:26:56 <elliott> type All p xs = Foldr Pair Unit (Map p xs)
18:27:15 <elliott> dmwit: btw, I know you don't need this fancy stuff... I'm type-hacking for the sake of it
18:48:17 <donri> Tekmo: ohai. will there be any blog post about the motivation for pipes, concrete problems they solve better than other methods?
18:49:24 <zzo38> I think automatic classes would be useful, and I think Typeable should be one (although you can also define your own, using Template Haskell, perhaps)
18:50:39 <donri> zzo38: -XDeriveDataTypeable? -XDeriveGeneric?
18:50:54 <zzo38> donri: Not quite what I mean.
18:51:02 <zzo38> But, similar to that.
18:52:34 <zzo38> I mean that such classes, like Typeable (I don't know of any other existing classes that would be), they automatically have instances for various types, and you cannot define your own instances in other modules either.
18:58:47 <callen> soiamso: wat.
19:00:00 <donri> zzo38: there are tricks to make public classes not instantiable
19:00:04 <donri> not sure what you're after though
19:00:52 <zzo38> I thought I am being clear
19:02:14 <brunonery> hello guys!
19:02:19 <zzo38> I think I understand how you might be able to make public classes not instantiable, but this is not the only thing I mean by this.
19:02:31 <brunonery> I'm looking for a way to lazily process an HTTP response
19:02:45 <brunonery> but I can't seem to find my way to a simple example of http-monad
19:03:11 <mzero> I'm wondering in what sense you mean "lazily process"
19:03:43 <mzero> In any event, if you want just the simplest possible way to handle a HTTP request, you could use Network.CGI
19:03:51 <mzero> for FastCGI and serve it from Apache
19:04:06 <Nereid> a response, not a request
19:04:09 <mzero> Or, using Snap's server is pretty simple
19:04:12 <brunonery> actually I'm looking into writing a client
19:04:15 <mzero> d'oh!
19:04:22 <brunonery> to process twitter streams
19:04:36 <brunonery> but they never finish, so Network.HTTP is out of question
19:04:46 <mzero> never mind silly ol' me
19:04:49 <Nereid> lazy IO is scary.
19:04:56 <Nereid> brunonery: have you looked into something like http-conduit?
19:04:59 <brunonery> why is lazy IO scary, Nereid?
19:05:06 <brunonery> hadn't heard of conduit
19:05:11 <Nereid> it's difficult to predict.
19:05:19 <mzero> brunonery: how can they never finish? The return a chunk encoded body that never ends?
19:05:20 <brunonery> only mini-http (deprecated) and monad (can't get my head around it)
19:05:27 <augur> ahaha
19:05:30 <augur> cartesian closed comic
19:05:48 <brunonery> mr zero, https://dev.twitter.com/docs/streaming-apis
19:05:56 <stepcut> mzero: yeah, like a streaming mp3 of an online radio station..
19:07:02 <brunonery> exactly, stepcut
19:08:33 <stepcut> brunonery: http-conduit is probably the best developed option at this point. There are some http client libraries that use lazy bytestrings I think.. but I don't think they get as much attention
19:09:04 <brunonery> thanks, stepcut
19:09:35 <stepcut> brunonery: though I am not convinced that the HTTP is out of the question either
19:09:45 <shachaf> djahandarie: You broke it!
19:09:56 <mzero> wow - that's some API!
19:10:18 <nooodl> what's something cool i can do in haskell in about 15-20 lines of code? i want to try to program something small as elegantly as possible
19:10:20 <mzero> It is transfer-encoding: chunked.... only you can request a *second* layer of length information inserted into the data stream!
19:10:43 <mzero> In either case, the biggest thing to find out is how any HTTP lib handled chunked encoding
19:11:54 <iroiro> good evening sirs
19:12:21 <Tekmo> Hi!
19:12:27 <djahandarie> iroiroattesa.
19:12:58 <mzero> nooodl: utf8 encode/decode?
19:13:15 <mzero> nooodl: simple expression parser and evaluator?
19:13:31 <shachaf> Hmm, Cayenne is quite old.
19:13:45 <mzero> nooodl: anagram generator
19:21:52 <shachaf> Hmm. Why is "data Foo a where Foo :: a -> Foo a" fine but "data Foo a where Foo :: forall b. a -> Foo a" says that a isn't in scope?
19:22:19 <shachaf> Oh, er, never mind.
19:24:42 <Tekmo> nooodl: If you want simple challenges that are roughly 15-20 lines long, visit reddit.com/r/dailyprogrammer
19:26:21 <ion> It looks like he has been posting many of them. :-P
19:26:28 <nooodl> yep :)
19:27:06 <nooodl> the reason i didn't pick one from there is a) i was really looking for something that haskell is good at specifically, and b) i wrote a third of them myself
19:27:23 <shachaf> Haskell is pretty much only good at Fibonacci numbers.
19:27:24 <Tekmo> nooodl: Oh yeah!  That's why I recognized your name :)
19:27:34 <shachaf> If you want something more complicated, like prime numbers, you need Agda.
19:27:47 <Tekmo> nooodl: Haskell is good at everything specifically
19:28:01 <ion> tekmo: I hear it isn’t very good at prime numbers.
19:28:05 <Tekmo> lol
19:28:12 <Tekmo> Seriously
19:28:15 <Tekmo> I am so sick of Project Euler
19:28:30 <nooodl> shachaf: aw dang, people before me have studied the problem of writing a fibs function elegantly for years
19:28:38 <shachaf> @quote _pizza_
19:28:39 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
19:28:55 <Jafet> @where evolution
19:28:56 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
19:29:07 <strebe> _pizza_ is clearly correct
19:29:21 <nooodl> i'll never top the (1 : 1 : zip ...) one. might as well quit
19:29:33 <shachaf> > fix$(1:).scanl(+)1
19:29:36 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:29:52 <Tekmo> nooodl: If you want problems tailored to functional programming languages you can try the ICFP contests
19:29:55 <Jafet> You could try to top pi_10.
19:30:02 <Tekmo> nooodl: and perhaps dumb them down a bit
19:30:15 <shachaf> Yes!
19:30:17 <shachaf> nooodl: Top pi_10
19:30:19 <shachaf> @where pi_10
19:30:20 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
19:30:28 <shachaf> Or e_10, actually.
19:30:30 <shachaf> @where e_10
19:30:31 <lambdabot> (!!2)<$>transpose[show$sum$scanl div(10^2^n)[1..2^n]|n<-[0..]]
19:30:45 <shachaf> @@ @run @where e_10
19:30:47 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
19:31:06 <nooodl> how many digits does that accurately generate
19:31:18 <nooodl> an infinite amount of them?
19:31:39 <ion> nooodl: 1, 1, …? Everyone knows the Fibonacci sequence begins with 89, -55.
19:31:44 <Tekmo> Only one way to find out
19:32:53 <nooodl> > ((!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]) !! 500000000000
19:32:57 <lambdabot>   mueval-core: Time limit exceeded
19:33:32 <nooodl> bad lambdabot! it's '8'
19:33:47 <Tekmo> > 8
19:33:49 <lambdabot>   8
19:34:07 <roconnor> can I tell cabal-dev to use a my distribution installed version of network?
19:34:08 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
19:35:54 <donri> roconnor: you could pass --constraint="network == x.y.z"
19:36:45 <Jafet> > repeat '8' !! 500000000000
19:36:51 <lambdabot>   mueval: ExitFailure 1
19:36:51 <lambdabot>  mueval: Prelude.undefined
19:37:04 <roconnor> donri: will that let cabal-dev see the global install?
19:37:22 <donri> roconnor: it already sees the global installs, that's the default behavior
19:38:16 <roconnor> oh
19:38:22 <roconnor> crap, then it is a nix thing
19:39:24 <donri> roconnor: not necessarily... might still try to upgrade network locally by default? try cabal-dev ghc-pkg list
19:39:55 <mzero> bah.... it's a trap!   (/r/dailyprogrammer)
19:40:03 <roconnor> /home/roconnor/.nix-profile/bin/../lib/ghc-pkgs/ghc-7.4.1/network-2.3.0.13.installedconf
19:40:06 <roconnor>    network-2.3.0.13
19:40:22 <roconnor> amoung other stuff
19:41:51 <donri> you'd normally have two package configurations in that list... duno nix
19:42:11 <roconnor> Ya, it is listed twice
19:42:15 <roconnor> one after another
19:44:02 <roconnor> I don't know why
19:44:10 <elliott> nix has to separate out every package I think
19:44:17 <elliott> since it has the whole isolation thing going on
19:44:36 <donri> didn't know it does that at the cabal/ghc-pkg level
19:45:06 <roconnor> this particular network is packaged by nix
19:45:07 <roconnor> not by cabal
19:46:41 <Xezlec> Is it possible to read an infinite data structure using lazy IO?
19:46:52 <Tekmo> The file is infinite?
19:47:00 <Xezlec> Yes.  It's a stream.
19:47:03 <Tekmo> Yes
19:47:22 <Tekmo> Lazy IO doesn't care how big the file is
19:47:24 <Xezlec> OK, because the Stack Overflow people sound a little pessimistic about it
19:47:30 <Nereid> doesn't mean it's a good idea though.
19:47:30 <roconnor> can I tell cabal dev to "use" /home/roconnor/.nix-profile/bin/../lib/ghc-pkgs/ghc-7.4.1/network-2.3.0.13.installedconf ?
19:47:41 <rwbarton> disliking lazy IO is the cool thing to do
19:47:50 <shachaf> I've conclusively decided what the Fibonacci sequence starts with.
19:47:57 <roconnor> shachaf: 0
19:48:00 <Nereid> 0
19:48:02 <shachaf> > let fibs = 1 : phi : zipWith (+) fibs (tail fibs) in fibs
19:48:04 <lambdabot>   [1.0,1.618033988749895,2.618033988749895,4.23606797749979,6.854101966249685...
19:48:04 <Xezlec> I tried using "sequence" in a Get monad and that didn't work, for reasons I now think I understand
19:48:10 <Nereid> shachaf: no.
19:48:27 <Xezlec> rwbarton: define "cool"
19:48:29 <donri> roconnor: it already is, if that's listed by cabal-dev ghc-pkg
19:48:34 <rwbarton> popular
19:48:39 <Jafet> > fix $ (1:) . scanl (+) x
19:48:42 <lambdabot>   [1,x,x + 1,x + 1 + x,x + 1 + x + (x + 1),x + 1 + x + (x + 1) + (x + 1 + x),...
19:48:49 <Xezlec> Then I take it you don't sign onto that view
19:48:57 <rwbarton> it's overstated
19:49:17 <Tekmo> Some of us don't like IO exceptions being thrown in pure code
19:49:29 <rwbarton> there are situations where it is bad, that's why we have developed new tools to deal with those situations, doesn't mean the old tools are automatically useless always
19:49:30 <roconnor> donri: the problem with nix's install of ghc is that ghc-pkg is wrapped so that it can see these packages, but anyone that uses ghc as a library cannot see them.
19:49:36 <roconnor> donri: it's kinda annoying
19:49:40 <Xezlec> The idea of writing my code as a pipeline of function composition was one of the things that attracted me to Haskell
19:49:48 <elliott> to be fair, lazy IO is really semantically iffy
19:49:50 <roconnor> donri: thanks for your help anyways
19:50:02 <Tekmo> Xezlec: You still can: with pipes :)
19:50:07 <elliott> Xezlec: well there are other compositional approaches to IO... they're not perfect but they still maintain the compositional style, it's just in a different category to (->)
19:50:09 <shachaf> Nereid: You're wrong.
19:50:11 <shachaf> Sorry. :-(
19:50:17 <donri> roconnor: it's controlled by an env var, GHC_PACKAGE_PATH or something like that
19:50:26 <elliott> conduit (almost a category), the 9342834 variants on pipes,
19:50:30 <elliott> iteratees to a lesser degree
19:50:57 <donri> roconnor: http://www.haskell.org/ghc/docs/latest/html/users_guide/packages.html#ghc-package-path
19:51:22 <Xezlec> Well, we've always used pipes at work (the OS kind), and my experience with them has been about as bad as I can imagine anything being
19:51:46 <rwbarton> one disadvantage of the new approaches is that there are 9342836 to choose from
19:51:55 <Tekmo> Xezlec: I meant the "pipes" library
19:52:14 <shachaf> rwbarton++ # 9342836
19:52:19 <Xezlec> Tekmo: I guess I'll have to check it out, but the name doesn't sound exciting at all.
19:52:44 <Tekmo> Xezlec: Sorry for not having a sexy name
19:53:19 <copumpkin> a series of pipes
19:53:25 <Xezlec> Tekmo: You mean Control.Pipe?
19:53:31 <Tekmo> Yes
19:53:43 <shachaf> copumpkin: Is there even an iteratee library called tubes?
19:53:53 <copumpkin> not that I know of
19:53:59 <copumpkin> shachaf: there's an opportunity for you
19:54:02 <Tekmo> If you guys want more names for things that other things flow through I have plenty to spare
19:54:03 <shachaf> Oh, xplat took it.
19:54:06 <copumpkin> oh
19:54:09 <shachaf> https://github.com/xplat/tubular
19:54:17 <shachaf> That looks complete.
19:54:24 <copumpkin> sounds totally tubular, duude
19:54:29 <Nereid> one moment.
19:54:33 <shachaf> In fact that code provides everything I want from an iteratee library.
19:54:37 <Nereid> @let pow e (*) x 0 = e; pow e (*) x 1 = x; pow e (*) x n = (if even n then id else (*) x) (let y = pow e (*) x (n `div` 2) in y*y)
19:54:38 <lambdabot>  Defined.
19:54:43 <copumpkin> shachaf: nice!
19:55:05 <Tekmo> Damn, that IS a nice library
19:55:13 <Xezlec> Well, I wasn't really complaining about the name, just hoping it doesn't mean that it is, in fact, a vanilla implementation of the concept of pipes as I know them.
19:55:16 <copumpkin> xplat is pretty excellent
19:55:33 <Nereid> > let (a,b)**(c,d) = (a*c+b*d,a*d+b*c+b*d) in map (snd . pow (1,0) (**) (0,1)) [0..]
19:55:34 <shachaf> xcellentplat
19:55:35 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
19:55:40 <shachaf> xceplat
19:56:32 <Nereid> > let (a,b)**(c,d) = (a*c+b*d,a*d+b*c+b*d) in snd . pow (1,0) (**) (0,1) $ 100
19:56:34 <lambdabot>   354224848179261915075
19:56:42 <Nereid> > let (a,b)**(c,d) = (a*c+b*d,a*d+b*c+b*d) in snd . pow (1,0) (**) (0,1) $ 1000
19:56:44 <lambdabot>   434665576869374564356885276750406258025646605173717804024817290895365554179...
19:56:48 <Nereid> oops.
19:57:15 <shachaf> beep beep zam pow!
19:57:15 <copumpkin> :t pow
19:57:16 <lambdabot> forall a t. (Integral t) => a -> (a -> a -> a) -> a -> t -> a
19:57:51 <Nereid> exponentiation by squaring for any unital power-associative binary operation.
19:58:17 <roconnor> w00t: cabal-dev install http --constraint network==2.3.0.13 --constraint parsec==3.1.2 --constraint mtl==2.0.1.0 worked
19:58:49 <Cale> Xezlec: The "pipes" library? It's about as far from unix pipes as you could get while still rightly being called the same thing and solving some of the same problems.
19:59:04 * hackagebot sbv 2.7 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-2.7 (LeventErkok)
19:59:05 <Nereid> meanwhile, computing fibonacci numbers using powers of phi in the ring Z[phi].
20:01:23 <Nereid> > let (a,b)**(c,d) = (a*c+2*b*d,a*d+b*c) in map (pow (1,0) (**) (0,1)) [0..] -- Z[sqrt 2], how boring
20:01:25 <Xezlec> OK, I was just reading about it, but how do you branch those pipes?
20:01:25 <lambdabot>   [(1,0),(0,1),(2,0),(0,2),(4,0),(0,4),(8,0),(0,8),(16,0),(0,16),(32,0),(0,32...
20:01:37 <Tekmo> What do you mean by branch?
20:01:43 <Tekmo> As in read from two different sources?
20:01:44 <Nereid> > let (a,b)**(c,d) = (a*c+2*b*d,a*d+b*c) in map (pow (1,0) (**) (1,1)) [0..]
20:01:46 <lambdabot>   [(1,0),(1,1),(3,2),(7,5),(17,12),(41,29),(99,70),(239,169),(577,408),(1393,...
20:02:07 <Xezlec> Tekmo: yes, like the equivalent of a function with two arguments.
20:02:07 <Nereid> ah, approximants to sqrt(2)?
20:02:13 <brunonery> hi guys
20:02:19 <brunonery> I'm trying to run this example here: http://hackage.haskell.org/packages/archive/http-conduit/1.6.1.2/doc/html/Network-HTTP-Conduit.html
20:02:22 <brunonery> from http-conduit
20:02:27 <Tekmo> Xezlec: I'm glad you asked
20:02:35 <Nereid> convergents*
20:02:38 <Tekmo> Xezlec: One second while I pull up the link to a Stack Overflow answer of mine
20:02:38 <brunonery> but it  tells me simpleHttp isn't on scope
20:03:21 <Cale> brunonery: Do you *have* to use the conduit version of this library?
20:03:26 <Tekmo> http://stackoverflow.com/questions/12496654/is-there-an-iteratee-like-concept-which-pulls-data-from-multiple-sources
20:03:46 <brunonery> yes, Cale - I need to download a never ending HTML document
20:04:03 <Nereid> > let (a,b)**(c,d) = (a*c+2*b*d,a*d+b*c) in map (uncurry (/) . pow (1,0) (**) (1,1)) [0..]
20:04:05 <lambdabot>   [Infinity,1.0,1.5,1.4,1.4166666666666667,1.4137931034482758,1.4142857142857...
20:04:22 <Cale> brunonery: hmm
20:04:32 <Tekmo> Fine, I will go ahead and finish my parsing library
20:04:49 <Tekmo> This is getting pretty ridiculous
20:04:52 <Jafet> Sounds like Sisyphus, condemned to upload a POST form for all eternity
20:05:06 <Nereid> brunonery: simpleHttp won't satisfy your requirements though
20:05:11 <Xezlec> ok, thanks, I get the general idea I think
20:05:16 <Nereid> brunonery: you'll actually need to use conduits
20:05:25 <strebe> Tekmo: why are you sick of project Euler?
20:05:39 <Nereid> simpleHttp puts the entire response into a single bytestring, without lazy IO
20:05:41 <brunonery> conduits, Nereid? how hard are they to use? is there a good tutorial?
20:05:54 <Tekmo> Tekmo: I feel there are better ways to learn a programming language than doing math
20:05:57 <Tekmo> Gah
20:05:58 <brunonery> I just wanted to try the library before going deeper
20:06:00 <Tekmo> Why do I do that?
20:06:16 <Nereid> there ought to be some conduit tutorial out there.
20:06:19 <Tekmo> strebe: Project Euler is more about math than programming
20:06:36 <brunonery> but first, I need to understand why http's conduit example doesn't work
20:06:53 <strebe> Tekmo: ahh. I mainly agree with you, but Project Euler is kind of fun for its own sake, and being able to mildly improve at some basics in a less-familiar PL while at it is just a minor side bonus
20:06:58 <Tekmo> brunonery: Here, I'll check out your link
20:07:43 <Xezlec> So, just for the sake of continuing in the direction from whence I began, how DO you read an infinite list from lazy IO?  (Even if it's a bad idea)
20:07:53 <Tekmo> strebe: I also like to encourage people to solve real-world problems with Haskell instead of finding another way to calculate fibonnaci numbers
20:08:08 <Tekmo> Xezlec: Here's how you do it with pipes
20:08:10 <Cale> Xezlec: Well, there are various primitives which do lazy IO to begin with
20:08:17 <Cale> Like hGetContents
20:08:24 <Tekmo> Xezlec: forever $ lift readOperation >>= yield
20:08:33 <Tekmo> Xezlec: That will stream the data
20:08:38 <strebe> Tekmo: I have to say haskell is the most daunting language I've ever seen for that, even taking books like Real World Haskell into account
20:08:45 <Cale> If you mean that you'd like to build those from scratch, there's unsafeInterleaveIO :: IO a -> IO a
20:08:48 <strebe> (and excluding things like intercal)
20:09:03 <Tekmo> strebe: What do you have trouble using it for?
20:09:04 * hackagebot xdg-basedir 0.2.2 - A basic implementation of the XDG Base Directory specification.  http://hackage.haskell.org/package/xdg-basedir-0.2.2 (WillDonnelly)
20:09:08 <shachaf> safeInterleaveEvaluation :: a -> a
20:09:14 <Cale> which turns any IO action into one which finishes immediately, producing a result whose evaluation will trigger the I/O to really occur
20:09:20 <Xezlec> Tekmo: OK
20:09:53 <Tekmo> Xezlec: You can then consume it incrementally downstream using something like:
20:10:00 <Cale> and that's the primitive on top of which the magic lazy I/O stuff is built
20:10:01 <Tekmo> Xezlec: forever $ await >>= doSomethingWithit
20:10:09 <Xezlec> Cale: I was trying to figure out how to use the Get monad to parse the bytestring returned by a getContents, but maybe that was the part that was wrong.
20:10:24 <strebe> Tekmo: as a total newbie, not infecting way too much code with impurity was a huge problem, due to not really understanding things like lifting; a few days ago, I was foolish enough to use readFile and get a String representation of a 34 meg file (which required a good deal more ram than this machine has; I ended up profiling the code on another machine)
20:10:39 <Tekmo> strebe: I do large file operations all the time
20:10:43 <Tekmo> strebe: I ahve this labmate of mine
20:10:51 <Tekmo> strebe: He just dumps 20 GB files on me
20:10:58 <Tekmo> strebe: My computer has 1GB of RAM
20:11:03 <Tekmo> strebe: then he asks me to parse them
20:11:04 <strebe> Tekmo: large file operations in haskell are perfectly fine, but as a naive newbie it's easy to get them horribly wrong
20:11:30 <strebe> I'm not saying that this can't be done in Haskell, I'm saying Haskell makes it exceptionally easy to shoot yourself in the foot in this regard if you don't know better
20:11:35 <Xezlec> Tekmo: I guess I was hoping to do it the bad way for now and learn pipes/other-kinds-of-pipes later, as that requires a whole new ramp-up period.
20:11:52 <Cale> strebe: Right, and we don't teach beginners how evaluation occure
20:11:53 <strebe> I ended up switching to ByteString and life was good
20:11:54 <Tekmo> Xezlec: Nothing wrong with the bad way if it currently works for you
20:11:55 <Cale> occurs*
20:12:09 <strebe> Cale: hm, what about it?
20:12:09 <Tekmo> strebe: Are you using lazy IO?
20:12:39 <Cale> strebe: Producing programs which are space-efficient while using types like String is hard if you don't know how the program evaluates in detail.
20:12:59 <strebe> Tekmo: in this particular case, no, strict; I was hoping to represent the data compactly enough that I could reasonably fit it in ram
20:13:17 <strebe> Cale: do you know any good writeups of how evaluation occurs in Haskell?
20:13:22 <Tekmo> strebe: In that case, familiarize yourself with Storable and UNPACK
20:13:32 <Tekmo> strebe: They are the two best tricks for making data types smaller
20:13:40 <strebe> Tekmo: thank you
20:13:42 <Cale> strebe: Well, the extra tricky part is that it's not defined by the spec :)
20:13:52 <Cale> strebe: But lazy evaluation is a good approximation
20:14:00 <Tekmo> strebe: With UNPACK, you can remove the space overhead from indirection (and also get rid of thunks)
20:14:03 <Cale> (It is not what GHC actually does though)
20:14:18 <Tekmo> strebe: With Storable, you can convert your data type directly into a C-based representation, which is as efficient as it gets
20:14:48 <strebe> Tekmo: hm, cool. That might save me from having to bother messing around with dumping the data into a database and running queries instead of keeping everything in ram
20:14:49 <Tekmo> strebe: In fact, I can give you some code examples to show you how to do it
20:14:58 <Tekmo> strebe: I just had this problem myself
20:15:00 <strebe> Tekmo: sure :-)
20:15:09 <Tekmo> strebe: I basically indexed the entire protein data base
20:15:15 <Tekmo> strebe: and I needed to keep it in RAM
20:15:22 <Tekmo> strebe: So this is all fresh on my mind
20:15:28 <strebe> Tekmo: similar to what I'm doing
20:15:32 <Cale> Lazy evaluation is outermost-first evaluation + sharing: when you have a function application f x, you evaluate f first, plugging x into the body of f without examining it, but with the proviso that the parameter to f is evaluated at most once, and then the result of that evaluation shared between any occurrences in the body of f.
20:16:11 <Cale> (x here can be any expression)
20:16:37 <strebe> Cale: I understand that much of it, but don't really have a good idea of when thunks are building up, etc; my mental model of what's going on is still patchy :/
20:16:56 <Cale> Good examples to look at are what happens when you use foldr and foldl
20:17:01 <Xezlec> Sorry to continue banging on this, but can we agree that the Get monad will not let me parse infinite data? and get an infinite list out of runGet?
20:17:01 <Cale> in various cases
20:17:07 <hpaste> “Gabriel Gonzalez” pasted “Packing a Point” at http://hpaste.org/76552
20:17:12 <Cale> Xezlec: Which Get monad are you talking about?
20:17:13 <rwbarton> Xezlec, which Get monad?
20:17:22 <Tekmo> strebe: That hpaste has an example for a 3-D Point data type
20:17:22 <Xezlec> Data.Binary.Get
20:17:26 <Tekmo> strebe: It demonstrates both tricks
20:17:58 <Tekmo> strebe: The data type is declared using UNPACK pragmas, which store the values directly within the constructor instead of adding a layer of indirection
20:18:04 <strebe> Tekmo: thank you
20:18:13 <Tekmo> strebe: However, if you really want to pack the type, you can define a storable instance
20:18:23 <Tekmo> strebe: Then you can stick it in a Storable Vector (from Data.Vector.Storable)
20:18:30 <Tekmo> strebe: Which is just a packed array of C-structs
20:18:36 <Tekmo> strebe: That's as efficient as it gets
20:19:11 <Cale> strebe: So, let's look at some examples:
20:19:17 <Cale> foldl (+) 0 [1,2,3]
20:19:21 <Cale> @src foldl
20:19:22 <lambdabot> foldl f z []     = z
20:19:22 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:19:34 <Cale> -> foldl (+) (0 + 1) [2,3]
20:19:42 <Tekmo> brunonery: You said the example wasn't working for you, right?  How did it fail when you tried it out?
20:19:43 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
20:19:50 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
20:20:00 <Cale> -> ((0 + 1) + 2) + 3
20:20:21 <brunonery> Noi in scope/; simpleHttp, Tekmo
20:21:06 <Xezlec> I guess I'd have to use an incremental Get, and kind of write my own thing to make it infinite.
20:21:22 <Cale> strebe: So far, in GHC's evaluator, this would have required basically no stack space: all of our pattern matches haven't required much, if any, evaluation to determine that we're going to proceed by applying foldl to some new arguments.
20:21:25 <Tekmo> brunonery: Try importing "Network.HTTP".  That exports the "simpleHTTP" function
20:21:58 <Cale> But now we do need the stack (which is not a call stack, but a stack of pattern matches waiting for their scrutinee to be evaluated enough to match)
20:22:07 <brunonery> tried that. that one requires Request io, not String
20:22:09 <rwbarton> Xezlec: there is a problem that the result of a Get action is contained in a constructor that indicates that the parse succeeded, but a parse can also fail
20:22:27 <Cale> (+) needs to match (evaluate) both its arguments to know what result to produce
20:22:42 <rwbarton> so there is no way to start returning data early, since a later Get action could still fail
20:22:50 <Cale> So essentially, something akin to (...) + 3 is put on the stack, and we recurse down this expression
20:23:02 <Xezlec> rwbarton: right, hence the incremental idea, just do it piece by piece.
20:23:03 <Cale> evaluating (0 + 1) + 2
20:23:11 <Cale> and then (...) + 2 is put on the stack
20:23:12 <rwbarton> that's why you can't extract an output from a single "infinitely long" Get action
20:23:21 <rwbarton> yeah
20:23:26 <rwbarton> if you know where the piece boundaries are
20:23:29 <Cale> and then 0 + 1 evaluates to 1, and 1 + 2 evaluates to 3 and 3 + 3 evaluates to 6
20:23:51 <Cale> strebe: Cool?
20:23:55 <strebe> Yep
20:24:07 <brunonery> I'm clueless here, Tekmo
20:24:13 <Cale> So, in order to fix that, you can add extra strictness: there's a foldl'
20:24:15 <Cale> @src foldl'
20:24:15 <lambdabot> foldl' f a []     = a
20:24:15 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:24:35 <strebe> cale: yep, and I can see where that goes
20:24:37 <Tekmo> Xezlec: Well, you can, just not using that library
20:24:38 <rwbarton> why is this documentation telling me to use runGetPartial instead of runGetState when there is no runGetPartial
20:24:48 <Xezlec> rwbarton: you know, it's funny, I thought "oh, another programming language, I can probably learn it in a couple weeks"
20:24:50 <strebe> I understand seq, and have used foldl', though hadn't looked at the implementation
20:25:02 <Tekmo> Xezlec: You need a parser that at some point commits so that it can incrementally send some of the result to the user
20:25:20 <Xezlec> rwbarton: but here a few weeks later, I still feel like I'm in my first ever computer class.
20:25:27 <strebe> it's understanding where to use seq in general that makes me fall down a bit still :-)
20:25:37 <Cale> strebe: You can also rely to some extent on GHC's strictness analyser if optimisations are turned on
20:25:51 <Tekmo> brunonery: Did you copy the example exactly?
20:25:52 <Xezlec> Tekmo: yeah.
20:26:35 <Cale> It can correctly discover that some things can be strict without any danger of changing nontermination behaviour and evaluate in another order
20:26:49 <Cale> Do you understand why foldl won't work on infinite lists, but foldr will?
20:26:56 <Cale> (sometimes)
20:27:05 <Cale> @src foldl
20:27:05 <lambdabot> foldl f z []     = z
20:27:05 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:27:23 <strebe> @src foldr
20:27:23 <lambdabot> foldr f z []     = z
20:27:24 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:27:28 <Cale> Applied to an infinite list, foldl will never terminate, because all it will do is pass control to itself
20:27:30 <Tekmo> Don't make Cale break out the ASCII diagram of foldl's evaluation tree
20:27:33 <brunonery> I typed it (a vm here), but it reads the same, Tekmo
20:27:34 <Nereid> brunonery: hey, here's an example of using http-conduit with aeson to get and parse twitter streams
20:27:39 <Nereid> sorry it's in japanese but  http://d.hatena.ne.jp/KrdLab/20120521/1337529701
20:27:40 <Nereid> :v
20:27:49 <Cale> However, foldr immediately passes control to f
20:28:04 <Xezlec> > foldr (+) 0 [1..]
20:28:05 <lambdabot>   *Exception: stack overflow
20:28:09 <Xezlec> Oh oops
20:28:13 <brunonery> awesome, Nereid
20:28:14 <Cale> and then f gets to decide whether the evaluation of the foldr proceeds, which it opts to do by pattern matching on its second parameter
20:28:22 <brunonery> ar least its haskell
20:28:30 <Cale> > foldr (\x xs -> x : x : xs) [] [1..]
20:28:32 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
20:29:05 * hackagebot vty 4.7.0.18 - A simple terminal UI library  http://hackage.haskell.org/package/vty-4.7.0.18 (CoreyOConnor)
20:29:06 <Cale> (or simply leaving its second parameter somewhere in the data structure it produces, like in that case)
20:29:26 * strebe nods
20:29:37 <Nereid> strebe: http://www.haskell.org/haskellwiki/Fold pictures!
20:29:55 <Cale> http://cale.yi.org/share/Folds.svg  MOAR
20:30:14 <Cale> Those don't really explain the evaluation terribly well though
20:30:18 <Cale> More just the result
20:30:54 <Cale> However, it should be somewhat obvious that foldl on an infinite list is impossible, because the top level application of f is to some expression and the last element of the list
20:30:58 <Nereid> even so, it lets you see how foldl can't ever produce anything on an infinite list
20:31:00 <Nereid> yeah
20:31:06 <lispy> Ah, the joy of finding that someone made a web comic based on a joke you made in #haskell
20:31:11 <Cale> and an infinite list has no last element
20:31:15 * strebe nods
20:32:02 <lispy> Cale: You've been active a lot lately (or maybe I'm just noticing).
20:32:09 <lispy> Cale: I take it that means things are going well?
20:32:21 <Cale> I suppose so :)
20:32:40 <lispy> preflex: seen dons
20:32:40 <preflex>  dons was last seen on #ghc 108 days, 10 hours, 14 minutes and 8 seconds ago, saying: i don't recall a time that the hetzner's been down before
20:32:45 <Cale> I don't know if there was ever a period where I was particularly inactive
20:33:15 <Cale> dons pls
20:33:38 <lispy> that gentleman on the other hand has not been around
20:34:17 <Cale> lispy: My waking hours are substantially more regular than they were with my old job though
20:34:31 <lispy> ah, that might be the difference
20:34:42 <strebe> Cale: foldl/foldr semantics on this fully understood
20:34:48 <Cale> strebe: great :)
20:34:59 <Nereid> is there ever a reason to use foldl instead of foldl'?
20:35:11 <Cale> Nereid: It's slightly better in the case of reverse
20:35:18 <strebe> Nereid: hmm. If you're not going to use the result?
20:35:29 <shachaf> Nereid: Someone mentioned "last" here recently.
20:35:37 <Nereid> hmm.
20:35:46 <Nereid> @src foldl'
20:35:46 <lambdabot> foldl' f a []     = a
20:35:46 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
20:35:59 <shachaf> > foldl (\x y -> y) (error "end") [1,2,undefined,3,4]
20:36:00 <Xezlec> strebe: Not going to use the.... this is a purely functional language, right?
20:36:01 <lambdabot>   4
20:36:01 <shachaf> > foldl' (\x y -> y) (error "end") [1,2,undefined,3,4]
20:36:03 <lambdabot>   *Exception: Prelude.undefined
20:36:16 <lispy> Nereid: the strict foldl should probably be the defaulte since it's usually what we want. But, if we named renamed them that would break with convention of the strict one ending in '
20:36:16 <Nereid> yeah, that would do it.
20:36:17 <Cale> The reason that foldl is not strict by default is that in almost all cases where you'd need it to be strict, it would also be valid for a compiler to compile the plain foldl into the equivalent of foldl'
20:36:44 <Cale> In a sense, it's a bit of a compiler design challenge built into the standard library :)
20:36:51 <nifr> hi all
20:36:53 <lispy> heh
20:37:19 <strebe> Xezlec: yes? And it still has let clauses, and it's downright idiomatic in haskell to only use parts of infinite lists (which you really don't want to strictly try to evaluate entirely), etc?
20:37:22 <Cale> GHC actually does surprisingly well, so long as you actually turn on optimisations
20:37:24 <nifr> quick question: I have this foggy memory of Oleg saying something like "constructor classes considered harmful" --- anyone else remember that? I can't find it now
20:37:36 <Cale> nifr: WAT
20:37:47 <lispy> nifr: constructor classes? as in Functor and Monad?
20:37:52 <Cale> yeah
20:37:56 <Xezlec> strebe: I see, different meaning of "result" I guess
20:37:59 <strebe> nifr: he just wrote something about call/cc being harmful, but you presumably don't mean that
20:38:41 <nifr> something like you can usually get the same functionality by just lightly wrapping classes that only have * kinded arguments?
20:38:53 <Tekmo> Actually, that's probably what he meant
20:39:13 <Tekmo> except he confused the cc with constructor classes
20:39:21 <Xezlec> Although I guess it's not *purely* functional, what with "error" and all... but that would explain why people don't like lazy IO
20:39:22 <Cale> 2007-01-19 22:36:39 <sorear> if possible call it foldMap ... constructor classes considered harmful.
20:39:22 <nifr> not the case, Tekmo
20:39:39 <shachaf> I think Oleg wrote an article saying that it's *possible*, but not that constructor classes are bad?
20:39:42 <shachaf> I don't remember.
20:39:44 <Tekmo> Don't use error
20:39:53 <shachaf> whoa, dude, remember sorear? Those were the days.
20:39:54 <nifr> yeah, shachaf, me neither --- this was a while ago, I think
20:40:06 <strebe> http://www.google.co.jp/#hl=ja&q=site:okmij.org+harmful&oq=site:okmij.org+harmful <-- slim pickings
20:40:11 <nifr> ha
20:40:11 <Nereid> brunonery: I presume you found the github link for the complete code.
20:40:12 <Xezlec> Tekmo: :)
20:40:33 <Tekmo> Xezlec: error is asking for a lot of trouble
20:40:49 <nifr> sorry: "considered harmful" was just my paraphrase, not the shape of the statement I'm trying to recall
20:41:01 <Tekmo> Xezlec: Take the time to learn to use Maybe or Either effectively and you'll save yourself a lot of frustration down the road
20:41:02 <Xezlec> Tekmo: I've used it in a couple of places in my project where I think it makes perfect sense, and you might even agree
20:41:13 <Tekmo> Xezlec: I've never used error in my code, ever
20:41:30 <Xezlec> Tekmo: I needed to do math with complex integers
20:41:32 <lispy> I use error when debugging
20:41:36 <Cale> Stefan O'Rear apparently criticised constructor classes for being overly restrictive, because instances often need to be too polymorphic.
20:41:49 <nifr> that's the idea, Cale
20:42:00 <Nereid> what is a complex integer?
20:42:14 <Cale> Nereid: A Gaussian integer?
20:42:22 <Tekmo> Nereid: It's complicated
20:42:24 <copumpkin> http://okmij.org/ftp/Haskell/Haskell1/Haskell1.txt
20:42:26 <Nereid> maybe. the term is kind of ambiguous though
20:42:26 <Xezlec> Tekmo: therefore I needed complex integers to be Num, therefore I needed to define abs for them, which doesn't exist, so it becomes an error.
20:42:27 <nifr> something like the only type you *need* a constructor class is in some context where you're already dealing with some other constructor class
20:42:28 <copumpkin> he doesn't say they're harmful
20:42:34 <copumpkin> but he does say typeclases are unnecessary
20:42:34 <lispy> Cale: oh, is that when Oleg showed how to embed extra context in the type class so that users can add constraints in the instances?
20:42:49 <Nereid> @Cale.
20:42:49 <lambdabot> Unknown command, try @list
20:42:52 <Nereid> oops.
20:42:53 <Xezlec> Nereid: a complex number whose real and imaginary parts are integers
20:42:59 <Nereid> so, a gaussian integer.
20:43:01 <nifr> just read that, copumpkin --- interesting, but not about the same topic
20:43:06 <Tekmo> Xezlec: I suppose that is okay, although in those cases I will hide the Prelude Num class and define my own
20:43:07 <copumpkin> yup
20:43:20 <nifr> (I realize this is a real vague request, hence the crowd sourcing --- thanks for playing along)
20:43:43 <nifr> also, in that link, I learned that __ is a valid identifier
20:43:54 <Cale> http://www.haskell.org/pipermail/haskell-cafe/2007-December/035975.html -- Stefan refers to his post here, but I haven't located the original
20:44:05 * hackagebot dyre 0.8.9 - Dynamic reconfiguration in Haskell  http://hackage.haskell.org/package/dyre-0.8.9 (WillDonnelly)
20:44:07 <Xezlec> Tekmo: Second case: I created a class, only a few of whose defaults I wanted to override in the instances.
20:44:32 <shachaf> copumpkin: I think that's the article I was thinking of.
20:44:35 <nifr> well crap, I should have just googled for my paraphrase… thanks cale
20:45:07 <Xezlec> Tekmo: But there were some of them (due to the way I defined the type arguments) that were literally impossible to write defaults for the general case.  So their defaults became error.
20:45:21 <Cale> nifr: I think generally that I disagree with that viewpoint. Constructor classes are great :)
20:45:22 <rwbarton> you can just not write a default...
20:45:26 <byorgey> @tell gabor that is not supported, because only certain types can be promoted to kinds, and there is no way to restrict a type variable to only be instantiated to those types which are OK to promote
20:45:26 <lambdabot> Consider it noted.
20:45:33 <Tekmo> Xezlec: Classes don't even need to have defaults
20:45:53 <Tekmo> Xezlec: If they have a default implementation, it sort of defeats the point of the class
20:45:58 <rwbarton> though it amounts to the same thing really
20:46:12 <rwbarton> except you get a warning when you forget to implement them, which is nice
20:46:14 <Xezlec> rwbarton, Tekmo: I swear I had a reason at the time, but now it doesn't make sense.
20:46:17 <rwbarton> (if you don't define a default)
20:46:19 <byorgey> lispy: I don't mirror any repos anymore, that was an experiment --- darcs-bridge has bugs that make it impossible
20:46:25 <Tekmo> Xezlec: Fair enough :)
20:46:31 <Cale> nifr: and while there are restrictions of Monad and such which would be nice, like having an instance for Set which requires Ord, it's obvious when you start to think about it why it's hard to deal with those without planning ahead.
20:46:33 <byorgey> lispy: all the diagrams repos are on github now, and all my personal stuff is on hub.darcs.net
20:46:58 <nifr> Cale: I'm trying to investigate the issue -- lots of positives (especially clarity), but I can't remember the negatives
20:47:01 <lispy> byorgey: good to know even though it was a negative result
20:47:14 <Xezlec> rwbarton, Tekmo: Now I remember!  I didn't want to *have* to override them because some instances wouldn't use them.
20:47:35 <Cale> nifr: There really aren't many negatives, and I'm pretty sure that the "considered harmful" would have to be taken in at least a half-joking sense.
20:47:43 <weasels> has anybody here used plugins
20:47:45 <Tekmo> Xezlec: As far as I'm concerned, type classes are the cause of and solution to all of Haskell's problems
20:47:45 <weasels> (the package)
20:47:56 <Cale> nifr: I mean, Functor and Applicative and Monad are all wildly successful.
20:48:18 <Nereid> Xezlec: then put error in the instance declarations, not the class?
20:48:25 <rwbarton> also doesn't the RMonad thing not really work in practice
20:48:27 <Cale> nifr: and the alternative of explicit parameter passing of dictionaries, quite frankly sucks
20:48:35 <Xezlec> Tekmo: Haskell is the problem.  Haskell is the solution.  Fear Haskell.  Love Haskell.  Haskell is watching.
20:48:57 <Nereid> I tried writing a thing like typeclasses with explicit dictionaries.
20:48:58 <Nereid> it sucked.
20:49:03 <rwbarton> like if I want to do liftM2 (+) set1 set2, won't I need an instance Ord (Set -> Set) or something
20:49:11 <nifr> Cale: two things: 1) pointer to a list of the negatives you have in mind
20:49:27 <rwbarton> or rather if I want to do (+) <$> set1 <*> set2
20:49:33 <nifr> 2) is explicit dictionary passing the only alternative? I don't quite follow that jump
20:49:41 <Cale> Nereid: Well, there are cases where it's obviously okay, or even more desirable than using typeclasses
20:49:42 <Tekmo> Well, type classes evolved from dictionary passing
20:49:55 <Xezlec> Nereid: that defeats the purpose though.  I didn't want to have to define them in the instances.
20:50:21 <Cale> But there are also cases where it's just horrible, and you can't construct nearly as good notations that way
20:50:25 <Tekmo> Tekmo: I still think dictionary passing is okay, but I'm not about to buck the community's trend
20:50:30 <Tekmo> Gah
20:50:45 <Tekmo> I need to stop addressing myself
20:50:46 <Nereid> Xezlec: well you don't, you'll just get a warning then.
20:50:50 <elliott> cmccann: this may amuse and/or horrify you: http://hpaste.org/76553
20:50:51 <Xezlec> Tekmo: is that a speech impediment?
20:51:05 <Tekmo> Xezlec: It is now
20:51:08 <byorgey> lispy: at one point owst was trying to get the bugs fixed but I think they turned out to be quite hairy and insurmountable.
20:51:08 <nifr> sorry: Cale: 1) *do you have some sort of* pointer to a list of the negatives you have in mind*?*
20:51:17 <Xezlec> Nereid: my boss considers "warning" and "error" synonyms ;)
20:51:24 <byorgey> but anyway, darcs-bridge still works great for turning darcs repos into git.
20:51:24 <Cale> Cale: Remind Tekmo to remind you to remind him to stop addressing himself.
20:51:28 <lispy> byorgey: you already mentioned it was using darcs ;)
20:51:39 <Tekmo> Here, let me:
20:51:44 <brunonery> Tekmo: simpleHttp is not simpleHTTP
20:51:45 <brunonery> damn me
20:51:51 <elliott> rwbarton: yes
20:51:51 <Tekmo> Tekmo: Xezlec: Tekmo: Stop talking to yourself
20:52:09 <elliott> rwbarton: a monad that you can't use in applicative style, truly one of the finer joys in life
20:52:12 <Tekmo> brunonery: Haha
20:52:21 <Cale> nifr: Not really, except that there are certain data types like Set, which is "morally" a Monad, and yet if you try to write an instance, you'll find that you immediately run into a problem.
20:52:24 <elliott> rwbarton: but I think liftM2 will actually work
20:52:25 <Tekmo> brunonery: Good catch
20:52:35 <byorgey> lispy: heh, my sense was that their models were so fundamentally different it was just really difficult to translate, especially in a way that supported incremental back-and-forth
20:52:48 <rwbarton> depends on the implementation of liftM2 I suppose?
20:53:00 <rwbarton> basically you have to start being super careful about the style you write thing sin
20:53:02 <Tekmo> I'm not totally convinced a Monad with constraints is "morally" a monad
20:53:06 <lispy> Cale: oh, this is what the discussion has reminded me of
20:53:11 <lispy> Cale: http://okmij.org/ftp/Haskell/types.html#restricted-datatypes
20:53:12 <rwbarton> @src liftM2
20:53:12 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:53:15 <rwbarton> like that looks fine
20:53:17 <cmccann> "import GHC.Exts; import Unsafe.Coerce" oh boy
20:53:24 <rwbarton> hmm
20:53:35 <elliott> rwbarton: yes, you basically can't use (<*>)
20:53:47 <elliott> cmccann: GHC.Exts is just for Constraint, I think
20:53:54 <cmccann> I figured
20:53:55 <cmccann> it
20:54:02 <lispy> byorgey: I think the models can be unified (at lesat in theory) as delimited continuations, but I doubt it becomes easy (decidable?) using that model
20:54:05 <cmccann> it's just amusing
20:54:09 <elliott> cmccann: also, Foldr and FoldR are actually very different
20:54:12 <byorgey> lispy: haha, yikes
20:54:17 <elliott> not the most clean code
20:54:19 <Cale> nifr: It's a bit hard to see this as something which is explicitly bad about constructor classes, because in a sense, there is no known alternative which is better.
20:54:24 <key> re
20:54:44 <otters> ugh I don't understand linking
20:54:58 <nifr> Cale, lispy: thanks; based on your references, I'm pretty sure it was his parameterized monad writings I was foggily recalling
20:55:09 <Xezlec> In case anyone was wondering, my reason for wanting lazy IO so bad was that I want to read a file into a complicated data structure ultimately containing infinite lists as the leaf nodes, representing different information in the data stream.
20:55:22 <key> anyone here a fossil user? i'm having trouble finding best practice on organizing multiple sub projects under an umbrella project. (2 programs include a library) should i have 3 repositories, or 1?
20:55:23 <lispy> byorgey: something simpler might exist, it just occured to me once upon a time that delimited cont. should be powerful enough. I think you can also model version control as affine vector spaces where the number of dimensions is unbounded, but your vectors always have finite dimension.
20:55:49 <Cale> key: What's fossil?
20:55:49 <Xezlec> Perhaps I am insane.
20:55:59 <Cale> Xezlec: that doesn't sound bad
20:56:01 <key> fossil is a DVCS
20:56:04 <byorgey> lispy: sounds fun!
20:56:06 <key> www.fossil-scm.org
20:56:17 <elliott> isn't there a #fossil?
20:56:20 <Tekmo> Xezlec: That's perfectly doable
20:56:25 <nifr> Cale: something like "constructor classes" as just a convention around *-based classes --- former instances become polymorphic instances
20:56:27 <Tekmo> Xezlec: Although, perhaps not with an iteratee library
20:56:31 <nifr> I'll try to whip something up real quick
20:56:33 <key> nope elliott
20:56:33 <cmccann> elliott, so what exactly is this doing? I haven't had enough coffee to figure this shit out right now
20:56:39 <elliott> Xezlec: that's an inherently lazy IO sort of thing, yes
20:56:40 <cmccann> but it looks hilarious and/or terrifying yes
20:56:51 <Tekmo> Xezlec: You just change the leaves to be generators
20:56:56 <copumpkin> [23:56:30] <nolyc> I tried to buy a Renault in a Renault shop, but there were no salesmen available, so I came into this Ford shop. Why won't you sell me a Renault?!
20:57:02 <Xezlec> Tekmo: I'm going to attempt it using iterative Get and carefully-thought-out magic.
20:57:03 <Tekmo> Xezlec: So that you can demand as much information from them as you want
20:57:12 <Tekmo> Xezlec: Just use generators
20:57:15 <elliott> cmccann: well it is the standard HList construction but using automatically-lifted type-level lists as the list of types
20:57:19 <Tekmo> Xezlec: import Control.Monad.Trans.Free
20:57:22 <lispy> byorgey: basically, the path to the bytes that are different form a sort of basis and then the affine bit just has to do with vector differences (the change/diff)
20:57:26 <Tekmo> Xezlec: type Generator a = FreeT ((,) a)
20:57:32 <elliott> cmccann: plus kind-polymorphic type families implementing "polymorphic" higher-order stuff like map and foldr on the type lists
20:57:42 <Tekmo> Xezlec: yield :: (Monad m) => a -> Generator a m ()
20:57:51 <lispy> byorgey: sometimes I think of it this way, but I don't think it's of an practical value
20:57:53 <Tekmo> Xezlec: yield a = liftF (a, ())
20:57:54 <elliott> cmccann: which it then combines with constraint kinds to give you All :: (a -> Constraint) -> [a] -> Constraint
20:58:03 <cmccann> ah, nice
20:58:08 <elliott> cmccann: so you can do things like define (All Show ts) => HList ts -> [String]
20:58:25 <Tekmo> Xezlec: Then you make each leaf a generator that demands more of the file the deeper you query the list
20:58:25 <cmccann> so much less stupid than how the original HList stuff worked
20:58:27 <elliott> and then it goes completely off the deep end as I define map/foldr on HLists as generally as possible :P
20:58:49 <Cale> elliott: haha
20:58:54 <Tekmo> Xezlec: Maybe I should just write a generator tutorial
20:58:58 <elliott> the foldrH there is actually as general as you can get (it's the induction scheme you get from the list ADT in Agda/Coq/whatever)
20:59:05 <cmccann> hahaha nice
20:59:35 <Xezlec> Tekmo: but would that require me to be in a Monad context when I query the generator?  (Pardon my ignorance)
20:59:52 <cmccann> elliott, did you see my weird "non-constructable constructor" tagging stuff from a while ago?
21:00:00 <elliott> cmccann: nope... sounds interesting
21:00:07 <Tekmo> Xezlec: Yes
21:00:13 <Tekmo> Xezlec: The action is not referentially transparent
21:00:16 <cmccann> lemme find it, someone else fixed it up a bit from my original form
21:00:19 <Tekmo> Xezlec: So it must be bound in the IO monad
21:00:39 <Xezlec> Tekmo: that seems like a big disadvantage compared to infinite lists
21:00:42 <cmccann> elliott: ok, here. http://hpaste.org/76248
21:00:49 <nifr> Cale, copumpkin, lispy: it comes full circle… the Haskell1 post copumpkin linked has definitions of return and bind as wrappers around instances of a non-constructor class
21:00:53 <Tekmo> Xezlec: The problem is that you're reading the file at the moment you query the list
21:00:58 <Tekmo> Xezlec: Reading the file is a side effect
21:01:02 <cmccann> variations on creating data structures that you can pattern match on freely, but can't freely reconstruct
21:01:10 <Tekmo> Xezlec: which is why querying the list even deeper must occur in the IO monad
21:01:12 <nifr> the question becomes: how usable are those wrappers in practice compared to the Monad constructor class?
21:01:13 <Xezlec> Tekmo: that's debatable.
21:01:19 <cmccann> so with a runST-style function you can inspect the result to know which parts of a structure are unchanged
21:01:30 <Cale> nifr: Yeah, except that non-constructor class version of Monad is unsatisfying in other ways.
21:01:31 <elliott> cmccann: oh, cool
21:01:34 <cmccann> so you could e.g. short-circuit on a structural equality check
21:01:35 <otters> so I'm trying to load a symbol from my plugin object file, Test.o, and it fails when trying to locate `_LexieziPlugin_Message_closure'
21:01:37 <Tekmo> Xezlec: Everything is debatable :)
21:01:43 <elliott> "Tree (~) ((~) t)" nice
21:01:48 <otters> nm says that libHSlexie-0.1.a has _lexiezm0zi1_LexieziPlugin_Message_closure
21:02:04 <otters> can someone explain to me how I fix this
21:02:07 <Xezlec> Tekmo: In any case, at that point I'm just writing imperative code, and Haskell buys me nothing.
21:02:20 <otters> hang on I can paste the files
21:02:22 <copumpkin> Xezlec: that's not true
21:02:24 <Tekmo> Xezlec: Not quite
21:02:26 <cmccann> elliott, yeah there's a bunch of weirdly quantified constraints that it requires to be awkwardly polymorphic
21:02:42 <copumpkin> Xezlec: haskell does imperative code very well, by letting you abstract over imperative actions
21:02:42 <rwbarton> depending on your scenario you can also just bytestring-mmap the file and go nuts
21:02:45 <Tekmo> Xezlec: For example, the point of my "pipes" library was that you could do these kinds of endless IO operations but still keep a compositional style
21:02:46 <cmccann> elliott: then at the end the runST-style function goes "lol every constraint is just ~"
21:02:54 <rwbarton> if it is a real file of course
21:02:59 <copumpkin> even if you don't use iteratees
21:03:11 <copumpkin> you can write nice reusable code
21:03:11 <Cale> nifr: actually, I haven't thought much about this particular rendering...
21:03:23 <hpaste> otters pasted “help me learn to linker” at http://hpaste.org/76554
21:03:47 <Xezlec> I can always write reusable code in any language
21:03:50 <Tekmo> Xezlec: I repeatedly argue that compositionality matters more thanpurity
21:03:51 <nifr> Cale: disclaimer: me neither, since you all just now helped me rescue the post from my memory
21:04:07 <copumpkin> Xezlec: can you make lists of imperative actions with closures in most languages, easily?
21:04:09 <cmccann> elliott, the polymorphic constraints give you a kind of weird version of parametricity that reflects the structure of the data type being marked
21:04:09 <Tekmo> Xezlec: Imperative code is bad not because it has side effects, but because it's not compositional
21:04:21 <cmccann> 'cept that I don't think you can even cheat here like you can with undefined
21:04:32 <copumpkin> Xezlec: I can send an infinite stream of IO actions to another thread, which can consume them and run them
21:04:43 <copumpkin> I can do that fancy Cale-ism
21:04:49 <Cale> nifr: One thing you want to be careful about though is that the normal definition of Monad ensures that return and join are natural transformations for free, through polymorphism. Other restrictions might require you to check the additional laws for yourself.
21:04:49 <copumpkin> I can make things that automatically free their resources
21:04:52 <Xezlec> copumpkin
21:04:52 <copumpkin> with a Cont-like monad
21:04:58 <cmccann> I can't figure out how to satisfy the existential constraints without using the one that's forced to be polymorphic
21:05:10 <copumpkin> again, even without iteratees or pipes or whatever
21:05:56 <elliott> cmccann: yeah
21:06:07 <Cale> nifr: Which might be fine, of course, but we wouldn't want to lose that guarantee for ordinary unrestricted monads.
21:06:11 <elliott> cmccann: I'm not quite sure what the (All p ts) is really doing there semantically
21:06:13 <jcp> I'm fairly new to Haskell, and I've got some modules I want to import in ghci, but when I'm in a different path, so I want something roughly equivalent to Python's PYTHONPATH
21:06:15 <Tekmo> Xezlec: Pretending that impure things aren't impure won't solve your problems
21:06:15 <Xezlec> copumpkin: these things aren't that useful to me.  But maybe I never really had a good reason for trying Haskell.  Somehoe I thought it would make composing streaming code easier, but now I don't know if I was thinking clearly about that.
21:06:23 <Nereid> Tekmo: purity is kind of a prerequisite to compositionality no?
21:06:24 <elliott> it seems like a weaker guarantee than you want to give for something like foldH
21:06:30 <Tekmo> Nereid: No
21:06:30 <jcp> Trouble is, I've tried using -i, which seems to be similar, but it doesn't work (ghci acts as if the packages don't exist). Any suggestions?
21:06:42 <nifr> Cale: sure, but I think it's still in the instances, in a sense: they are suitably polymorphic wrt to the relevant type variables, yeah?
21:06:44 <Tekmo> Nereid: My "pipes" library is pretty much the counter-example
21:06:48 <copumpkin> Xezlec: if you're used to using a hammer to solve all your problems, if someone hands you a screwdriver, you might not know what to do with it at first :)
21:06:56 <Nereid> what's impure about it?
21:06:59 <copumpkin> Xezlec: that doesn't mean it isn't useful for what you're doing
21:06:59 <Cale> nifr: Yeah, at least, if you're non-evil about it
21:07:17 <Tekmo> Nereid: You can lift impure actions from the base monad
21:07:22 <Tekmo> Nereid: But you can still compose pipes
21:07:25 <Cale> nifr: Another approach to the same problem is using Codensity, though that has performance implications which are sometimes unsatisfying for things like Set.
21:07:35 <Xezlec> copumpkin: but it does have very serious drawbacks, so unless there's a big obvious advantage...
21:07:46 <cmccann> elliott, anyway I'm still kinda boggling at "class (p a) => Foo p a"
21:07:48 <cmccann> it's just
21:07:50 <cmccann> what
21:07:51 <spiderweb> anyone able to compile ghc on netbsd 6.0 amd64 somehow?
21:08:15 <copumpkin> Xezlec: there is a big obvious advantage, but if you're looking for a short-term solution haskell isn't it
21:08:18 <copumpkin> it'll help you in the long term though
21:08:28 <nifr> Cale: you mean "another approach" wrt the free theorems?
21:08:34 <Tekmo> Xezlec: Haskell insists on these things for a reason
21:08:36 <Xezlec> copumpkin: what's the obvious advantage?
21:08:44 <Cale> I mean another approach to dealing with what would otherwise be a restricted monad
21:08:51 <copumpkin> Xezlec: it will completely change how you view programming, for the better :)
21:08:51 <Tekmo> Xezlec: The obvious advantage is not having side effects contaminate your pure code
21:09:11 <Xezlec> copumpkin: that is not obvious.
21:09:17 <Tekmo> Xezlec: Imagine summing a list of integers and suddenly getting a resource exhaustion exception
21:09:26 <Tekmo> Xezlec: That's the danger of unsafePerformIO
21:09:34 <Xezlec> Tekmo: I don't see why that is an advantage.
21:09:37 <rwbarton> that can happen without unsafePerformIO :P
21:09:41 * cmccann still likes STM as an example of the advantages of purity-by-default
21:09:47 <Tekmo> Xezlec: Enforcing strict purity makes it much easier to reason about code
21:09:52 <Nereid> Tekmo: I guess I had the wrong idea of what purity was.
21:09:58 <Xezlec> Tekmo: No, that's the danger of lazy evaluation.
21:10:14 <Cale> nifr: There's an instance Monad (Codensity f) which is unrestricted, and works for any f :)
21:10:22 <copumpkin> Xezlec: well, tell us what you would consider an advantage, because we can tell you that it shits ponies and rainbows and cures world hunger and you could keep telling us "I don't see that as an advantage"
21:10:30 <elliott> cmccann: basically that is a class newtype :p
21:10:43 <elliott> cmccann: like doing newtype Foo a = Foo a just so you can give instances for Foo
21:10:50 <Xezlec> copumpkin: all I said was that it isn't obvious.
21:10:54 <elliott> cmccann: except in this case it's being used to give type family instances instead
21:10:59 <cmccann> elliott, yeah, it just looks bizarre
21:11:06 <copumpkin> Xezlec: I'm saying that our approach here isn't efficient. Tell us what you're looking for.
21:11:19 <copumpkin> it's stupid to try to brute force your definition of useful out of you
21:11:25 <elliott> cmccann: the only reason it uses type families is because you can use them to "partially apply" type synonyms
21:11:28 <copumpkin> by exhaustively trying everything
21:11:29 <Tekmo> Xezlec: Not lazy evaluation.  You wouldn't expect that computing a list of fibonacci numbers would cause a database transaction to occur
21:11:35 <Cale> nifr: So instead of using an instance of Monad for Set, say, you could use one for Codensity Set
21:12:01 <elliott> cmccann: by carrying around a token (here, conveniently, the class) and just applying it as TypeSynonymFamily token blah, you can treat token as an unapplied type synonym
21:12:04 <elliott> which you can't otherwise pass around
21:12:14 <nifr> Cale: i'm trying to remember the semantics of Codensity's argument; does dropping in Set like that give you a monad isomorphic to the intended vanilla Set monad?
21:12:26 <cmccann> elliott, neat!
21:12:26 <Tekmo> Xezlec: Haskell forces you to do things a certain way because the other way lies chaos
21:12:28 <elliott> (hence you can pass around the type-level equivalent of (const blah), in this case (const String) for show)
21:12:34 <Cale> It's not quite the same, but the Set monad embeds into it
21:12:36 <Tekmo> Xezlec: The types prevent you from making mistakes
21:12:54 <Tekmo> Xezlec: And forcing side effects into pure computations is one of those mistakes
21:12:55 <copumpkin> the types can also guide your programming
21:12:56 <Xezlec> copumpkin: I don't have some definition of useful that I'm claiming Haskell doesn't fit.  I'm saying its benefits aren't *obvious* to me, so I don't know whether its the right tool for anything I'm currently working on, when there are an ocean of languages out there.
21:13:27 <nifr> Cale: ok… knee-jerk question: how generalizable is that? Is Set quite the special case?
21:13:29 <copumpkin> Xezlec: the ocean of languages is mostly composed of superficial variations on one language
21:13:30 <Xezlec> Tekmo: Resource exhaustion comes from inifinite data structures.  I can (and have) make that happen without any IO at all.
21:13:52 <Cale> nifr: It applies to all cases, but you usually don't quite get what you wanted.
21:14:07 <lispy> Xezlec: that's true, but that's different than what Tekmo is trying to explain
21:14:28 <Xezlec> copumpkin: If you say so, but they don't seem to have the same problems I'm running into with Haskell.
21:14:39 <lispy> Xezlec: you're familiar with separation of concerns, right?
21:14:41 <Cale> nifr: For example, in the case of Set, from what I understand, you don't get any "collapsing" of equal elements, so in the end it amounts to the same thing as using the list monad and applying Set.fromList at the end.
21:14:45 <nifr> elliott: this use of TypeSynonymFamily feels like type-level defunctionalization…is that a safe perspective?
21:14:55 <Xezlec> lispy: Tekmo is trying to explain a lot of things at once and I'm trying to take them one at a time.
21:15:01 <Tekmo> Xezlec: Sorry about that :)
21:15:16 <Tekmo> Xezlec: I just mean you want to keep your pure code free of side effects
21:15:27 <elliott> nifr: yes
21:15:36 <latermuse> do any of you guys study pure category theory to understand haskell better?
21:15:42 <copumpkin> Xezlec: that's likely because they're all a lot closer to the languages you already know (which are in the same family), which makes the concepts more familiar and thus easier to you. Haskell is fundamentally different in so many ways (even from other "functional" languages like ocaml or scheme) that it's a shock to people coming from most other languages
21:15:44 <Tekmo> latermuse: Other way around
21:15:46 <elliott> nifr: more or less anyway
21:16:01 <Cale> latermuse: I study it not just to understand Haskell better, but to understand mathematics better as well.
21:16:11 <nifr> elliott: ha, it's the blurry wiggle room I'm concerned about :)
21:16:14 <copumpkin> Xezlec: I know it took me several months before I felt even remotely comfortable with what it could do
21:16:23 <copumpkin> and that was fairly intense fooling around
21:16:24 <Xezlec> copumpkin: I'm not shocked.  Just running into issues that even people here have had trouble helping me solve.
21:16:25 <lispy> Xezlec: pure code lets you separate how you compute (and what you get as a result) from the observable changes you make in the world and also allows separation from how the real-world gives you data.
21:16:44 <elliott> cmccann: anyway given that this works I guess partially-applied type synonyms (and hence type lambdas) would actually work OK provided the compiler is as distrustful of them as type families
21:16:49 <elliott> in terms of constantly worrying they're not injective and so on
21:16:57 <Cale> latermuse: and it's not so much Haskell in particular as data and computation in general
21:16:58 <rwbarton> btw HList should just exist in some standard ghc library
21:17:04 <rwbarton> except it should have a name like "Product"
21:17:19 <cmccann> rwbarton, what, you don't like oleg's naming conventions?
21:17:21 <rwbarton> it would be pretty dumb for everyone to write their own Product constructor
21:17:36 <Xezlec> lispy: I guess I don't know what you want me to say.
21:17:42 <Tekmo> Xezlec: Think of it this way.  Haskell forces you to solve all your mistakes up front.  When you do it, your code just works flawlessly
21:17:51 <rwbarton> the name HList has these connotations of TypeCast'' magic to me
21:17:57 <Tekmo> Xezlec: You're ust encountering the pain of solving everything up front instead of deferring the problem to later
21:18:01 <cmccann> haha TypeCast'' :D
21:18:03 <latermuse> cale: do you feel like having a strong knowledge in category theory has helped a lot? Im asking because Im not sure if I want to dedicate the time to fully understand such an abstract theory
21:18:03 <lispy> Xezlec: no response needed :) Just trying to phrase it in a new way, hoping that will help it sink in.
21:18:13 <elliott> rwbarton: I actually think HList is generally not very useful in practice
21:18:23 <elliott> but it sure is useful for writing abstract type hackery
21:18:23 <Cale> latermuse: If your goal is to write programs and get things done, don't worry about it.
21:18:35 <Xezlec> Tekmo: the problem is that so far the people here haven't been able to help me with the fundamental static types issue
21:18:41 <Cale> latermuse: If your goal is to understand for the sake of understanding, then it's an excellent way forward :)
21:18:48 <cmccann> elliott, so in other words it's useful for writing the kind of libraries that would use HList stuff
21:18:51 <elliott> rwbarton: not sure making the library GHC-specific would be a good idea though -- could just be on hackage somewhere
21:18:55 <Xezlec> Tekmo: and so I consider that an unresolved liability of using Haskell
21:19:08 <rwbarton> it doesn't really have to be part of GHC, but it is such an obvious thing to include
21:19:11 <rwbarton> similarly, Sum
21:19:17 <elliott> yeah
21:19:17 <rwbarton> it would be like if Haskell didn't include tuple type constructors
21:19:24 <Tekmo> Xezlec: There is no type issue.  You can clearly solve it using generators
21:19:26 <elliott> well
21:19:32 <elliott> you need extensions to do HList properly
21:19:36 <Xezlec> Tekmo: you haven't even heard it
21:19:37 <jcp> Oh, now I just discovered that if I do ghci TestThing, it imports it fine, but if I do ghci -i.\nimport TestThing, it doesn't work.
21:19:39 <latermuse> cale: Thanks cale! I understand what I need to do now.
21:19:43 <elliott> and for instance my expression is really really GHC-specific
21:19:44 <Cale> latermuse: Category theory is full of really nice abstract designs for things. Sometimes when you're stuck on how to design a library, it can provide nice answers for a "right way" to do things.
21:19:46 <Tekmo> Xezlec: Alright, shoot :)
21:19:50 <elliott> in terms of requiring a bunch of extensions nobody else is even close to implementing
21:19:51 <Xezlec> Tekmo: oh I get it, you weren't here any of the other times I came in here
21:19:53 <lispy> Xezlec: if you mean #haskell specifically, then I will say, some issues are not solved well over IRC and you may have better luck asking on the mailing lists or stackoverflow
21:19:56 <elliott> except probably edwardk's super secret compiler
21:20:10 <elliott> actually I have been trying to express Ur's record system in Haskell with all this fancy stuff
21:20:12 <elliott> but it's tough going
21:20:18 <Cale> (This is true of mathematics in general, but especially true of category theory)
21:20:21 <elliott> it is basically HMap
21:20:41 <Tekmo> Xezlec: Oh :(
21:20:51 <elliott> it is a good use for TypeNEq though
21:21:13 <elliott> which is, I think, the first time anyone has found a use for a type inequality class, ever
21:21:27 <cmccann> hahaha
21:21:58 <Cale> latermuse: If it turns out that you find yourself interested in it, a really good starting point is Awodey's book.
21:22:07 <elliott> (http://hpaste.org/76555)
21:22:12 <Xezlec> Tekmo: So I'm writing a file format library.  This file format can contain data of many different types.  I was having all sorts of issues getting Complex integers and everything to work, and being able to easily write a piece of code to use the library to process the data regardless of what type it is.
21:22:13 <elliott> (but you don't actually want to use this representation, it's not very good)
21:22:30 <rwbarton> I don't really believe in TypeNEq
21:22:38 <latermuse> Cale: I will look for that. In fact, I am super interested in category theory, but I dont have a lot of time these days. So I was just trying to figure out if its worth allocating time to each day to study.
21:22:39 <lispy> Xezlec: well, you've piqued my curiosity. What things are you stuck on?
21:22:44 <elliott> rwbarton: well here I use it to avoid duplicate record keys
21:22:54 <Cale> (check pm)
21:22:59 <Xezlec> lispy: I'm not stuck, really.  I solved it, it just requires a lot of ugliness and difficulty.
21:23:08 <nifr> elliott: familiar with Richard Eisenberg's branch with overlapping type family instances?
21:23:13 <lispy> Xezlec: what are you working on?
21:23:18 <elliott> nifr: nope. that sounds terrifying
21:23:31 <nifr> elliott: sound, I should say
21:23:34 <Xezlec> lispy: dependent typing just doesn't seem to be something Haskell does well ;)
21:23:44 <nifr> more restricted than OverlappingInstances
21:23:52 <lispy> Xezlec: That's a true. I've run into that before.
21:24:01 <rwbarton> elliott, your record keys could be type-level strings though and then you could have a better-founded NEq class
21:24:03 <nifr> makes TypeEQ and TypeNEQ straight forward
21:24:09 <jcp> :quit
21:24:11 <jcp> er
21:24:11 <Tekmo> Xezlec: Why do you need dependent types?
21:24:11 <jcp> ignore
21:24:20 <rwbarton> on the other hand that has a gross non-nominal-typing feel to it
21:24:25 <rwbarton> if that is the word I am looking for
21:24:36 <copumpkin> EVERYONE needs dependent types!!
21:24:39 * copumpkin runs
21:24:43 <copumpkin> (I don't actually think that)
21:24:45 <Cale> latermuse: One thing in particular which I hope to see someone do sooner or later is a database whose interface is more category-theoretic in nature. There are a lot of nice things which would be natural to want from a categorical perspective (and which, to be honest, are not that unnatural from a relational perspective), but which it seems that most databases have missed.
21:25:05 <Xezlec> Tekmo: well, I'm playing a little fast and loose with terminology there.  I just mean that I'm having trouble working with the data in the file without knowing at compile time what it is.  It's not impossible, but it takes a LOT of work.
21:25:14 <nifr> Cale: I saw some slides along those lines. Have you seen those?
21:25:17 <rwbarton> Cale, you've seen/read Spivak's talk/paper on databases as categories (really functors) I presume?
21:25:20 <cmccann> copumpkin, but the real question is what would codependent types be
21:25:24 <Cale> nifr: The talks by David Spivak?
21:25:28 <Cale> yeah
21:25:30 <nifr> probs
21:25:38 <copumpkin> cmccann: beats me :)
21:25:47 <Tekmo> Xezlec: A parser doesn't work?
21:25:57 <lispy> Xezlec: in what sense do you not know what it is? You don't have the schema? You don't know the syntax? or ?
21:26:02 <Cale> cmccann: Overly Attached Type?
21:26:21 <Xezlec> lispy: I don't know the type at compile time because the file can contain many types of data.
21:26:34 <elliott> <rwbarton> elliott, your record keys could be type-level strings though and then you could have a better-founded NEq class
21:26:40 <Xezlec> Tekmo, lispy: it's a complex problem that isn't easy to summarize.
21:26:40 <Tekmo> Xezlec: Are you familiar with monadic parsing?
21:26:43 <elliott> rwbarton: uh? isn't that exactly what my paste does
21:26:46 <cmccann> Cale, or something like that
21:26:52 <rwbarton> oh is it
21:26:53 <carter_> hello everyone! :)
21:26:56 <Tekmo> Hi!
21:26:57 <Xezlec> Tekmo: extremely familiar.  I'm not writing a parser of any kind.
21:27:05 <rwbarton> i saw scary overlap fundep cheating and tuned out
21:27:09 <Tekmo> Xezlec: I mean, can't you just write a parser for each file format
21:27:14 <elliott> rwbarton: well it's actually Symbol, I think you can't inspect them
21:27:19 <rwbarton> oh i see
21:27:21 <rwbarton> hrm
21:27:21 <Tekmo> Xezlec: You try each parser, and then unify the potential results with a sum type
21:27:26 <elliott> rwbarton: which is good since you want blah blah parametricity can't distinguish "x" and "y" except by them being not the same sort of thing
21:27:30 <elliott> since they're just labels
21:27:37 <elliott> but that means you need a fancier thing to ensure they're distinct
21:27:40 <rwbarton> well like I can distinguish Nats
21:27:44 <rwbarton> by recursion
21:27:45 <nifr> Tekmo, Xezlec: that "sum type" could be a bounded existential, too
21:27:51 <elliott> Ur just has an inequality context for labels as a primitive
21:27:58 <rwbarton> that seems like it might be the way to go
21:28:03 <elliott> and right but you want symbols to be opaque
21:28:10 <rwbarton> because you want two things
21:28:19 <rwbarton> a type inequality constraint
21:28:19 <carter_> copumpkin yo!
21:28:22 <elliott> yes this stuff should just be built into the language... I was curious if it could be implemented with all the junk GHC has lying around by now though
21:28:30 <elliott> seems like the answer is basically "yes but it's really ugly and unusable"
21:28:37 <rwbarton> and also a guarantee that if two modules don't import any common module then they cannot be using the same symbols
21:28:48 <Xezlec> Tekmo: It doesn't need any parsing, but yes, I am representing the data using a huge algebraic type with zillions of different constructors representing all possible types, and then an incredibly elaborate system to help the application developer be somewhat agnostic as to the type of the data and yet still process it.
21:28:51 <cmccann> elliott, that's the answer to a lot of things
21:28:55 <rwbarton> so that the system is properly nominal
21:28:55 <latermuse> cale: coincidentally I am working on a big database project at the moment, but am not versed enough in category theory to start the project from scratch to utilize category theory from the begining
21:29:01 <elliott> anyway I sort of think (/~) :: a -> a -> Constraint should be built-in to Haskell.
21:29:12 <elliott> sure it's not useful all that option but it's symmetrical with (/~) and it's sometimes useful
21:29:21 <elliott> s/option/often/
21:29:22 <lispy> Xezlec: someone was trying to get data out of AWS recently, was that you?
21:29:37 <Tekmo> Xezlec: The way you solve that is that you define the operations the user wants to perform on the result
21:29:48 <copumpkin> carter_: hey
21:29:59 <Xezlec> lispy: no
21:30:04 <Cale> latermuse: I'll give you an example of the sort of thing I mean. There are many many cases where you have a relationship like "Every X has either a Y or a Z" (but not both, and not neither)
21:30:06 <carter_> elliott yes, a types not equal  op would be great
21:30:10 <Tekmo> Xezlec: Then you can take each resulting type (all zillion of them) and convert each one into a common dictionary representing the operations you want to give the user
21:30:11 <nifr> elliott: if (False ~ Equal a b) suffices, then you'd like Richard's GHC branch
21:30:15 <Xezlec> Tekmo:L I don't understand you.
21:30:23 <Tekmo> Xezlec: Ok, let's use a simple example
21:30:29 <elliott> nifr: yes, that would work
21:30:36 <Tekmo> Xezlec: Let's say that all the downstream user wants to do is "Show" the value
21:30:44 <elliott> still needs more infrastructure for the full records though
21:30:47 <Cale> latermuse: Categorically, this corresponds to a coproduct, or "sum" type. It is infuriatingly hard to represent it accurately in most databases though. :)
21:30:50 <Tekmo> Xezlec: But he doesn't know ahead of time what kind of value it will be
21:31:09 <Tekmo> Xezlec: Rather than giving him the raw value and having him work through the huge zillion-case statements
21:31:21 <Tekmo> Xezlec: You just give him something he can invoke to show the value
21:31:33 <Tekmo> Xezlec: Or you can even "pre-show" it for him and just give him the resulting string
21:31:40 <Xezlec> Tekmo: so then I have to implement all of Haskell inside this dictionary?
21:31:56 <Cale> latermuse: What most people end up doing is having two nullable columns: one with a foreign key into Y and one with a foreign key into Z, and then they go through hoops to try to prevent the "neither" and "both" cases from happening.
21:31:58 <Tekmo> Xezlec: No
21:32:06 <Xezlec> Tekmo: remembver this is just supposed to be a file format library for use by application dveelopers
21:32:12 <Tekmo> Xezlec: I understand
21:32:21 <carter> nifr whats this branch?
21:32:33 <Tekmo> Xezlec: I mean, if you have a zillion possible formats, then you either have two choices
21:32:36 <deech> What would be involved in getting GHC to support an FFI to a language other than C?
21:32:44 <latermuse> cale: At this point, those types of relationships would need to be managed by some external software, no?
21:32:51 <Tekmo> Xezlec: You give them a zillion possible values, or you provide a smaller common interface to those values
21:32:57 <Cale> latermuse: well, that's frequently the case
21:33:00 <deech> Just trying to figure out if it's something I am able to do.
21:33:00 <Xezlec> Tekmo: Here's what I did:
21:33:05 <nifr> https://github.com/ghc/ghc/tree/overlapping-tyfams
21:33:06 <copumpkin> deech: what kind of language would you want? more than a language, it's an FFI to a calling convention
21:33:13 <Cale> latermuse: but it sucks -- my database ought to be able to express constraints like this
21:33:32 <carter> nifr theres an overlapping type fams branch!
21:33:33 <carter> woah
21:33:36 <rwbarton> deech: if you are just trying to FFI to some particular code in a non-C language, the usual thing to do is get that language to talk to C
21:33:36 <carter> i'm out of date
21:33:40 <deech> copumpkin: I was thinking about Ocaml or Javascript.
21:33:44 <Cale> latermuse: (You can also use triggers, but those tend to be quite expensive too)
21:33:47 <nifr> works well, I hear
21:34:10 <copumpkin> deech: the question is how would it talk to javascript in the first place? and ocaml can do C bindings so it should already work
21:34:10 <nifr> Eisenberg is proving some safety properties in an FC extension, currently, IIUC
21:34:11 <Xezlec> Tekmo: I wrote a typeclass with a whole tree of calls in the defaults, so that the user can instantiate that typeclass to do their processing, and override whichever functions correspond to the data at the level of abstraction they need for their particular application.  It's big.
21:34:49 <Tekmo> So who actually calls the type class functions: your library or the user?
21:34:55 <latermuse> cale: Do any databases currently implement these types of arrows?
21:35:43 <Xezlec> The user, optionally through one of a growing collection of helper functions provided in the library
21:35:56 <deech> copumpkin: I would like it to talk to Javascript (or Ocaml) at the language level "foreign import "javascript" ... ".
21:36:01 <Cale> Not so far as I know. I think that a lot of the NoSQL movement is happening because people can't express the constraints that they want in terms of traditional SQL stuff, so they end up throwing out the baby with the bathwater and just storing pretty much unstructured data.
21:36:24 <copumpkin> deech: yeah, but how would the javascript thing work, in practice?
21:36:25 <Cale> But I want something which goes in the other direction. I want a database with fancier types, basically.
21:36:38 <Tekmo> Xezlec: I don't get why the user is "overriding" functions.  That doesn't sound correct
21:36:39 <Cale> and where the results of any query can themselves be used as a datatype for a column
21:36:52 <Cale> (or as a primary key!)
21:37:15 <Xezlec> Tekmo: so that the other functions will pass the value up through the tree, all the way from the most specific function.  For example:
21:37:22 <Tekmo> Xezlec: Type classes are not like abstract classes
21:37:31 <deech> copumpkin: It would take a javascript library and generate C stubs for it and call those.
21:37:45 <copumpkin> hmm
21:37:55 <lispy> I suspect type classes and scala traits are very similar, but I don't understand traits very well.
21:38:18 <deech> copumpkin: bad idea?
21:38:44 <copumpkin> deech: I'm just not sure how the mechanics of it would work, since a machine can't run js code directly. Would you integrate a particular js interpreter or something?
21:38:50 <Xezlec> Tekmo: let's say one piece of data in the file is of type Float16.  Now, I don't know what level of abstraction the user wants to see it at.  so we keep passing it up the tree, through Fractional, Real, Num, "single element", etc. until we hit a function that is not just the default.
21:38:50 <copumpkin> or VM
21:38:58 <carter> Cale : i've thought a bit about that
21:39:30 <deech> copumpkin: Yeah, like V8.
21:39:36 <copumpkin> ah
21:39:39 <Xezlec> Tekmo: That way, if all I want is a Num, so I can add it, my application will work on any value that is eventually just a Num.
21:39:56 <copumpkin> deech: I'm not sure people would want that directly integrated with GHC. I think there's already a GHCjs branch though
21:40:25 <Tekmo> Xezlec: If all you want is a Num, you just put a "(Num a) =>" constraint on your function.
21:40:27 <carter> its something i'd want myself
21:40:35 <Tekmo> Xezlec: You shouldn't have to do any type-class "plumbing" to make that work
21:40:47 <copumpkin> deech: I think the general attitude with the FFI is that it just needs to speak the lowest-level language of the machine it's running on, which tends to be C. For a while people were working on a .NET compiler backend for GHC, with a corresponding FFI to .NET, but that fell through
21:40:47 <Tekmo> Xezlec: Haskell is not like Java
21:40:48 <Xezlec> Tekmo: that constraint is present on the num-level function in the tree
21:41:03 <Tekmo> Xezlec: Why not just place the constraint directly on the user's function?
21:41:07 <lispy> copumpkin: I'm certainly like the integration the other way around. For Chrome to add a ffi for Haskell and to bundle GHC.
21:41:14 <copumpkin> :)
21:41:18 <Tekmo> Xezlec: Why do you have this hierarchy of type-class constraints/
21:41:30 <Xezlec> Tekmo: I'm not sure how you're thinking you would use that constraint to magically see whatever type happens to be in the file the right way and error out at runtime if it isn't.
21:41:46 <Tekmo> Xezlec: Ok, that last comment was more helpful
21:41:58 <Tekmo> Xezlec: So the user calls some function, which needs some sort of number
21:42:04 <deech> copumpkin: I feel as though being able to nice to talk to more codebases without having to manually write the C-interface for each library. Might make it easier to sell Haskell.
21:42:09 <Xezlec> Tekmo: No
21:42:15 <Tekmo> Xezlec: And based on that constraint, you want to parse the file and expect a number?
21:42:35 <Xezlec> Tekmo: The user passes a file to the file format library function along with an instance of the processing class to process its contents.
21:42:53 <deech> copumpkin: It's certainly the big reason that people take Scala seriously.
21:43:01 <lispy> deech: Maybe? I think having Haskell work well with more VMs would do it to. (Haskell on .NET/CLR, Haskell on JVM, Haskell in the browser)
21:43:09 <copumpkin> deech: well, scala only has an "FFI" to java :)
21:43:21 <copumpkin> or rather, to the jvm calling convention
21:43:35 <a215> a type can have more than one typeclass right?
21:43:41 <copumpkin> that's the kind of thing I mean, though. It runs on the jvm, so it needs to "speak jvm"
21:43:50 <copumpkin> most haskell runs on your CPU, so it speaks native calling conventions
21:44:14 <Tekmo> So you have some function, let's call it "process"
21:44:17 <deech> copumpkin: The interop is seamless enough and the Java library is nice enough that you can do most of what you need. Of course the language compromises a great deal for this interop.
21:44:18 <Xezlec> Tekmo: I might be able to do it exactly the same way it's done in C.  I guess I haven't tried that.
21:44:23 <copumpkin> haskell on the JVM would have issues
21:44:24 <Tekmo> You want it to accept two arguments
21:44:29 <copumpkin> deech: oh, I know too well :(
21:44:31 <Tekmo> Xezlec: The file, and how to process it
21:44:44 <Tekmo> Xezlec: Except, you can't pass a type-class instance as an argument, correct?
21:44:46 <lpvb> frege?
21:45:14 <deech> copumpkin: Shame though, there's some great ideas in there.
21:45:29 <Xezlec> Tekmo: It's way more comlicated than that.  I'm glossing over a lot of details.  But ultimately, it's done by explicitly typing the return value of something.
21:45:55 <deech> lispy: Do you envision it playing nice with other languages on those respective VM's?
21:45:55 <lispy> Xezlec: similar to how read works?
21:45:55 <copumpkin> deech: I wish scala had tried a bit harder to avoid exposing the jvm structure
21:45:59 <Xezlec> Tekmo: You have to understand, this file format is actually very complex.
21:46:09 <Tekmo> Xezlec: I've worked with complex file formats, too :)
21:46:17 <Xezlec> lispy: Yes, but with more crazy stuff happening all around it ;)
21:46:42 <ryanos> copumpkin/dech: what do you think about scala? how much scala has to offer from fp perspective ? is it gonna get there sometimes ?
21:46:44 <Tekmo> Xezlec: But I'm trying to reduce the problem to its essence so I can better answer you
21:46:46 <lispy> deech: Yes, and I'll name my pony Piponi!
21:46:49 <deech> copumpkin: If you were Odersky would you sacrifice adoption for it?
21:46:59 <Xezlec> Tekmo: that's not an easy thing to do.
21:47:00 <copumpkin> ryanos: I don't have huge faith in the "inspiration" of the people designing it :)
21:47:04 <copumpkin> deech: yes
21:47:13 <copumpkin> deech: but I'm an ivory-tower academic
21:47:27 <copumpkin> deech: I don't think it has to be a sacrifice though
21:47:27 <ryanos> what do you mean (on the inspiration side :) )
21:47:49 <Xezlec> Tekmo: Actually, you've half-convinced me to try doing it the exact way I've done it in C and see if that's doable.
21:47:52 <lispy> deech: Haskell trys to avoid (success at all costs). It sounds like scala did not.
21:47:53 <deech> copumpkin: So would I and I'm not an ivory tower academic, just someone who's dealing with a codebase where side-effects run rampant.
21:47:55 <copumpkin> ryanos: I think odersky just threw the kitchen sink into it, without too much thought about how different things would interact with each other cleanly
21:48:06 <Tekmo> Xezlec: Try to distill the nature of the problem
21:48:20 <ryanos> copumpkin: agreed, that's why i'm asking
21:48:34 <copumpkin> deech: aren't you with m******o?
21:48:37 <Tekmo> Xezlec: One of the points of Haskell is that once you define something that works, it scales limitlessly
21:48:47 <ryanos> there is no comparison betw hask and scala
21:48:50 <deech> copumpkin: maybe :)
21:48:53 <Tekmo> Xezlec: So when you tell me "This file format is really big and complex", that doesn't mean a lot to me
21:49:05 <Tekmo> Xezlec: It just means you haven't yet founded that limitlessly scaling abstraction yet
21:49:05 <copumpkin> deech: you asshole! you just pinched one of my colleagues! :P
21:49:18 <deech> copumpkin: hah!
21:49:23 <ryanos> on the other side, odersky has to offer a lot of stuff to make scala "appealing"..
21:49:35 <Xezlec> Tekmo: I really don't agree with you there.  I mean then you could say "why not just find the generally scaling abstraction for all problems, and then do that"
21:50:12 <Tekmo> Xezlec: I mean that a complex file format should use the same solution as a simple file format
21:50:13 <ryanos> in the java world ppl don't get fp.. scala is their way of at least getting closer
21:50:20 <Tekmo> Xezlec: The abstraction shouldn't really change when the format gets more complex
21:50:26 <ryanos> would have loved to see haskell instead of scala doing the same thing
21:50:28 <nifr> Xezlec: I missed your intro, sorry; are you familiar with singleton types?
21:50:34 <ryanos> but it doesn't seem to happen...
21:50:40 <copumpkin> ryanos: I certainly appreciate it taking the java community in the right direction
21:50:44 <copumpkin> ryanos: and the broader community
21:50:48 <ryanos> right
21:50:58 <Xezlec> Tekmo: then you don't need to know my format.  Start with the solution for the empty file and scale.
21:50:58 <copumpkin> but overall, if you're into FP, the language is a bit of a pain to work with
21:50:59 <ryanos> but not sure what is that direction :)
21:51:09 <Xezlec> nifr: I'm not sure.
21:51:17 <ryanos> i guess *some* direction is better than none (?)
21:51:21 <deech> copumpkin: Now we have to incorporate Scalaz and there's someone with more credibility than myself advocating for a pure monadic approach.
21:51:35 <copumpkin> yay
21:51:38 <copumpkin> moar moanadz
21:51:56 <deech> copumpkin: Honestly I feel really lucky ...
21:52:13 <cmccann> every time I hear stuff about scala it sounds like it collects all the tricky complex bits of haskell and java and then takes the cartesian product
21:52:17 <Xezlec> Tekmo: my point is that of course complexity matters, and of course a complicated situation will require a complicated solution.
21:52:18 <mikeplus64> > let pi n = 4 * (sum [ (-1)^x / (2*x+1) | x <- [1..n] ] in pi 100
21:52:19 <lambdabot>   <no location info>: parse error on input `in'
21:52:25 <lispy> deech: what is Scalaz?
21:52:26 <cmccann> like every possible combination of weird obtuse stuff is in there somewhere
21:52:29 <mikeplus64> > let pi n = 4 * (sum [ (-1)^x / (2*x+1) | x <- [1..n] ] in pi 100
21:52:30 <lambdabot>   <no location info>: parse error on input `in'
21:52:37 <mikeplus64> oops
21:52:49 <lispy> cmccann: and adds in some of its own stuff just to be safe
21:52:53 <deech> lispy: A library that lets you do Haskelly things in Scala.
21:52:54 <mikeplus64> i was scrolled up by centuries
21:53:07 <mikeplus64> > let pi n = 4 * sum [ (-1)^x / (2*x+1) | x <- [1..n] ] in pi 100
21:53:08 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:53:08 <lambdabot>    `GHC.Real.Integral a'
21:53:08 <lambdabot>   ...
21:53:22 <Tekmo> Xezlec: There's a difference between format complexity and abstraction complexity
21:53:31 <deech> cmccann: It's amazing what the Scala type system can do in a dancing bear sort of way.
21:53:44 <mikeplus64> > let pi n = 4 * sum [ (-1)**x / (2*x+1) | x <- [1..n] ] in pi 100
21:53:45 <lambdabot>   -0.8485065989290095
21:53:46 <Tekmo> Xezlec: For example, consider monadic parsing
21:53:51 <mikeplus64> close enough
21:54:02 <Tekmo> Xezlec: The parser definitions certainly will get larger the more complex your file format is
21:54:03 <lispy> mikeplus64: haha
21:54:04 <cmccann> deech, yeah that's the impression I keep getting
21:54:06 <Xezlec> Tekmo: Let me just give you the whole thing: it's a file format that can contain structures and arrays of structures, both time dependent and not, where each field in each of those structures can be any data type including another structure, and this data can represent literally anything and be processed in any way.  So.  Complex.
21:54:08 <Tekmo> Xezlec: But in the end, you're still using monadic parsing
21:54:27 <Xezlec> Tekmo: It's similar to HDF5.
21:54:36 <ryanos> cmccann: true but running on top of java gives them a large captive audience..
21:55:04 <deech> cmccann: Implicits are just crazy to reason about but really powerful. But I will say that traits and how they solve multiple inheritance is just plain cool.
21:55:11 <Tekmo> Xezlec: So, from reading that I can give you, in broad strokes, the parts that I think sound hard and the ones that don't
21:55:15 <copumpkin> johntromp: did you make that binary lambda calculus IOCCC submission?
21:55:28 <Cale> a215: I'm not sure whether or not anyone answered your question, but yes
21:55:33 * cmccann should actually learn a bit of scala one of these days
21:55:42 <cmccann> if only to properly appreciate what people complain about
21:55:46 <Tekmo> Xezlec: Recursive and mutually recursive data structures are easy in Haskell
21:55:57 <Xezlec> Tekmo: and all other languages.
21:56:05 <Cale> a215: types and type classes are in a many to many relationship
21:56:28 <Tekmo> Xezlec: Time-varying values just means you wrap them in the IO monad to reflect that they are not referentially transparent.  Tedious, but it works.
21:56:33 <deech> cmccann: I think there was a recent comment by doliorules on the Haskell reddit that outlined some of the criticisms.
21:56:58 <cmccann> yeah
21:56:59 <Tekmo> Xezlec: If the user can process it any way, you pass the way it can be processed as a function, not as a type class
21:57:05 <Cale> a215: You can think of each type class as being like something which may or may not be true of any given type, and when it is true, says that some functionality related to that type is available.
21:57:16 <Xezlec> Tekmo:  I think you just lost me
21:57:32 <Tekmo> Xezlec: Right now you use type classes to let the user specify how to process the data structure
21:57:35 <Tekmo> Xezlec: But that's wrong
21:57:36 <mikeplus64> Xezlec: i think so long as you can represent it in an ADT (which i would be very surprised if you can't) you ought to be looking at attoparsec or binary or cereal docs -- depending on your need
21:57:47 <Xezlec> Tekmo: How do I pass a function that operates on any type within some constraint and get the library to know how to apply that within a static type system.
21:58:21 <Tekmo> Xezlec: First off, you've already told me that the user knows how to operate on the type, correct?
21:58:33 <Tekmo> Xezlec: You said the user defines these type class instances
21:58:39 <Tekmo> Xezlec: So presumably they have this code
21:59:00 <Xezlec> Tekmo: But that code has some constraints which differ from application to application.  Num.  Integral.  Complex.
21:59:06 <Tekmo> Xezlec: Right, and that's okay
21:59:10 <Xezlec> And from field to field.
21:59:13 <Tekmo> Xezlec: That's okay
21:59:34 <Xezlec> So I can't just have a function in the library that takes ONE function as an argument.
21:59:38 <Xezlec> It has to be a....
21:59:41 <Tekmo> Dictionary
21:59:43 <Xezlec> *CLASS*
21:59:45 <Xezlec> ... of them
21:59:49 <Tekmo> The term you are looking for is dictionary
21:59:58 <Tekmo> Type classes evolved from dictionaries
22:00:08 <Tekmo> A dictionary is just a record of functions
22:00:10 <Xezlec> You want me to pass a dictionary to the library?
22:00:12 <Tekmo> Yes
22:00:30 <Tekmo> Here
22:00:42 <Xezlec> A dictionary containing one function.
22:00:44 <Tekmo> Let me link you my controvesial type class vs. dictionary post
22:00:49 <Tekmo> Hold on a second
22:00:55 <rwbarton> it's called "functional programming" for a reason!
22:01:05 <Tekmo> http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
22:01:07 <lispy> rwbarton: amen brother!
22:01:08 <nifr> Xezlec: are the types that can be stored in the file built from some fixed set of type constructors? eg int, char, array, etc?
22:01:14 <Tekmo> That will show you how to translate any type class into a dictionary
22:01:33 <lispy> Tekmo: I was hoping you'd bring up that article
22:01:35 <Tekmo> :)
22:01:39 <Tekmo> I wanted to motivate it first
22:01:58 <Xezlec> nifr: In a sense.
22:02:25 <Xezlec> Tekmo: I've seen this.
22:02:45 <Tekmo> Xezlec: Then you should understand that any type class can be converted into a dictionary
22:02:56 <Tekmo> Xezlec: The user passes that dictionary of functions to your processor
22:03:30 <Cale> Tekmo: of course, that's how type classes *are* implemented
22:03:40 <Xezlec> Tekmo: You mean a dictionary of one function.
22:03:40 <mikeplus64> Xezlec: so i don't have to scroll up lightyears, the problem is parsing a complex format with lots of different types, possibly recursive?
22:03:54 <Tekmo> Xezlec: One function per type class method you had
22:03:57 <Xezlec> mikeplus64: very recursive.
22:04:04 <Tekmo> Xezlec: So if your original type class had 10 methods the user was defining
22:04:09 <Tekmo> Xezlec: You have 10 entries in the dictionary
22:04:15 <Cale> The whole point of type classes is to provide a default implementation of some functionality at various types where it's present.
22:04:16 <Tekmo> Xezlec: And you don't even have to define them all
22:04:19 <Xezlec> Tekmo: The user was defining one member of that class and the rest would default.
22:04:24 <Tekmo> Xezlec: You can provide a helper function that defaults
22:04:28 <Tekmo> Xezlec: Example
22:04:29 <Cale> So that you don't have to pass those parameters around explicitly
22:04:39 <Tekmo> Xezlec: defaultDict :: MyDict
22:04:48 <Tekmo> Xezlec: The user uses that and then overrides one value in that record
22:04:51 <Tekmo> Xezlec: Like so:
22:05:01 <Tekmo> Xezlec: defaultDict { showImplementation = ... }
22:05:18 <deech> Tekmo: Your post is awesome and I finally see an honest-to-goodness use for ImplicitParams.
22:05:49 <Tekmo> Thanks! :)
22:05:51 <nifr> deech: ha, which brings the convo back to Scala
22:05:56 <Xezlec> Tekmo: and why is this better than classes?
22:06:18 <Xezlec> Tekmo: there seemed to be a lot of dissent in the comments.
22:06:27 <copumpkin> Tekmo: how do you deal with Ord-like things with Map?
22:06:34 <Tekmo> copumpkin: You can't
22:06:39 <copumpkin> okay :)
22:06:39 <deech> nifr: I think ImplicitParams are much more frowned upon in the Haskell code.
22:06:40 <Tekmo> copumpkin: This is the big weakness of dictionaries
22:06:53 <copumpkin> that's why I'm annoyed that scala took that approach :P
22:06:57 <Tekmo> copumpkin: People tell me you need dependent types to do that
22:07:02 <copumpkin> yeah
22:07:07 <copumpkin> in Agda I can be safe about that again
22:07:15 <copumpkin> but scala doesn't have the power to be safe with it
22:07:18 <Tekmo> Xezlec: The main dissent is what copumpkin mentioned
22:07:23 <copumpkin> so it actually loses some computational efficiency because of it
22:07:29 <Tekmo> Xezlec: Without dependent types there are some things type classes can do that dictionaries can't
22:07:41 <Tekmo> Xezlec: However, there are some things dictionaries can do that type classes cannot
22:07:42 <Cale> No there aren't.
22:07:52 <Cale> The compiler compiles typeclasses into dictionaries
22:07:59 <dolio> Not all compilers do.
22:08:01 <Tekmo> Xezlec: Such as defining dictionaries at runtime
22:08:06 <copumpkin> Cale: the point is the canonical aspect
22:08:11 <Cale> Well, when I say "the compiler", I mean GHC
22:08:11 <mikeplus64> Xezlec: that seems like a good candidate for a parser combinator lib e.g. attoparsec, i'd define the structure of the format in an ADT, and it's fields could be ADTs representing the data, e.g. data Value = Array [Value] | Integer Integer | Floating Double or something
22:08:14 <copumpkin> Cale: which is implemented in the type system and is what we're talking about
22:08:16 <Cale> copumpkin: right :)
22:08:32 <latermuse> Can someone get by without using traditional monads by mastering arrows? Are arrows a viable substitution for monads, or are they supplemental to each other?
22:08:44 <Cale> I guess if you mean "ensure that only one instance exists in scope per type", then yeah :)
22:08:50 <copumpkin> yeah
22:09:01 <dolio> It doesn't do that, either.
22:09:12 <dolio> Unless you use such an instance.
22:09:17 <Xezlec> Tekmo: now, I have multiple input/output streams and so I can't just pass a function anymore, because I need something that can be reading and writing to multiple streams.
22:09:19 <applicative> latermuse: this sounds like a bad idea
22:09:36 <mikeplus64> Xezlec: (although perhaps a better name for Value would be Literal considering the fields i've given it)
22:09:38 <Tekmo> Xezlec: You can do that, too
22:09:54 <Tekmo> Xezlec: Let's just say for simplicity that you are reading from multiple streams
22:09:55 <Xezlec> Tekmo: or I might want to do something else like print values to the screen.
22:10:02 <latermuse> applicative: using arrows as a substitute for monads, you mean?
22:10:10 <applicative> ah Tekmo is here. I have found a difficulty with the proxy type...
22:10:12 <Tekmo> Xezlec: Then just pass a list of IO actions that read from these streams, one for each stream
22:10:16 <applicative> latermuse: yes
22:10:17 <Xezlec> mikeplus64: I don't think I need to parse anything.
22:10:18 <Tekmo> applicative: Tell me!
22:10:36 <Cale> latermuse: They're not, really, and arrows as formulated have some subtle issues which might (in part) be solved by making an assumption which would cause the Kleisli arrow instance to be invalid for most monads.
22:10:52 <Tekmo> Xezlec: Just have the user supply the IO action to feed the value to
22:10:54 <deech> Learning Haskell was like climbing a mountain and now you see Agda's like that taller mountain that was hidden behind it and you're like "fuck".
22:10:55 <applicative> well, you must know it since you wrote the signatures, but filter and drop and dropwhile seem not at all what one hoped
22:11:00 <mikeplus64> Xezlec: then the same thing, but with binary or cereal
22:11:21 <copumpkin> deech: in some ways, it's more straightforward :) it's just that the things you can build with types in it are ridiculous
22:11:22 <Tekmo> applicative: You mean the upstream direction?
22:11:35 <Cale> latermuse: Arrows as formulated are in some sense a "generalisation of monads", but in order to say that, you have to throw away a law without which things can behave in rather unfortunate ways which make it hard to reason about your arrow programs.
22:11:50 <copumpkin> deech: it has fewer, more regular building blocks
22:11:54 <Xezlec> Tekmo: I can't picture it at all, and also how do I combine information from multiple fields of different types?
22:12:02 <applicative> Tekmo well in either direction; the direction that receives filtered material must be a pipe or co-pipe so to say
22:12:08 <beekor>  hiya guys.  I'm getting my module path in my type error like this:  Couldn't match expected type `FilePath' with actual type `system-filepath-0.4.6:Filesystem.Path.Internal.FilePath' .  I'm not seeming able to find how to connect those two.
22:12:16 <Cale> latermuse: and meanwhile, most of the "real" arrow instances used for FRP and such will satisfy this additional law which the arrows which come from monads don't.
22:12:17 <deech> copumpkin: So I was looking at some Agda tutorial and it seem like you write your program twice, once for the compiler and once for your user.
22:12:22 <applicative> so you cant maintain the two way proxy business.
22:12:28 <copumpkin> deech: hmm, I don't think so!
22:12:30 <Tekmo> applicative: Why must it be a pipe?
22:12:37 <rwbarton> what's a "user"?
22:12:37 <copumpkin> deech: you only write it once, because you have no users :)
22:12:44 <deech> copumpkin: nice.
22:12:46 <Tekmo> applicative: Only the filter/dropWhile stage is a pipe
22:12:46 <Xezlec> Tekmo: I mean since we're talking about separate functions in a dictionary that don't talk to each other
22:12:49 <latermuse> Cale: So arrows should be used as a supplement to monads?
22:12:53 <Tekmo> applicative: but they can be connected to stages that are not pipes
22:12:57 <copumpkin> deech: but I don't feel like I ever need to duplicate work, actually, in agda
22:13:03 <copumpkin> well, in some ways I do
22:13:23 <dolio> Real dependent types help you not write things twice.
22:13:30 <Tekmo> Xezlec: What do you mean by combining information from multiple fields?
22:13:33 <Cale> latermuse: Yeah, Arrow is just another (somewhat less) common "shape" which appears in some libraries, and which we've chosen to abstract over.
22:13:42 <dolio> In Haskell, you have to write everything at both the term and type level, assuming you want it at both.
22:13:45 <applicative> Tekmo: yes, it may be i'm not understanding, it was a couple daysago. i'm looking at the source for filter etc
22:13:58 <Xezlec> Tekmo: remember that each data stream can have many structures and substructures full of different data fields
22:14:01 <copumpkin> dolio: I'm thinking about ornaments, though, which would save us from writing a lot of the same things more than once
22:14:03 <Cale> latermuse: Which is something that you can also say about Applicative, Monad, and well, pretty much any abstraction really :)
22:14:16 <dolio> Well, there is that.
22:14:20 <Tekmo> Xezlec: Is your code publicly available?
22:14:25 <Xezlec> Tekmo: no.
22:14:29 <nifr> latermuse: just to be clear, some relationships hold between arrows and monads, but neither subsumes the other
22:14:39 <applicative> filterD :: (Monad m) => (a -> Bool) -> () -> Proxy () a () a m r     filterU :: (Monad m) => (a' -> Bool) -> a' -> Proxy a' () a' () m r
22:14:54 <dolio> copumpkin: That doesn't invalidate the point, though. In Agda you write things n times. In Haskell you write it 2*n times.
22:14:56 <Tekmo> Xezlec: I suppose the best answer I can give is that these functions can be defined to operate on recursive types
22:14:57 <dolio> Or more.
22:15:00 <copumpkin> deech: anyway, I really recommend learning it, as it'll make a lot of things a lot clearer :) you'll also find an army of enthusiastic people who want to teach it in #agda
22:15:01 <deech> copumpkin: I was referring to an example I saw where the invariants were expressed at the type level and on the function level.
22:15:03 <applicative> the one I had difficulty with wasjust drop, which I was implementing on the spot
22:15:05 <Xezlec> Tekmo: I could still just do it the same way I do it in C, but it would be slow because of the small granularity of the operations I'm doing...
22:15:10 <latermuse> Thanks guys. Im understand better now.
22:15:13 <deech> copumpkin: Will do :).
22:15:14 <Cale> I don't think that Arrow should generalise Monad, and should instead adopt the law that (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
22:15:21 <Xezlec> Tekmo: well that's the way I currently do it.
22:15:31 <copumpkin> deech: hmm, what example? we don't really distinguish much between "type level" and "value level" because types are just values
22:15:45 <copumpkin> I can write a recursive function that produces types
22:15:51 <deech> copumpkin: I can't seem to dig it up quick enough.
22:16:05 <Cale> latermuse: If you look at stuff surrounding Arrow, you'll see there are these "wiring diagrams" which people draw.
22:16:07 <copumpkin> moo : Int -> Set
22:16:33 <applicative> Tekmo, I can't  just interpolate this filter into the middle of a sequence of proxies, as I can a list filter, that  much is clear
22:16:50 <Cale> latermuse: Without the law that I just stated, the behaviour of an Arrow given by one of those diagrams can be affected by how you split the diagram up vertically or horizontally at each stage.
22:17:38 <Cale> latermuse: Which is rather like the behaviour of a circuit depending on your printed circuit board layout, which sucks.
22:17:47 <Tekmo> applicative: Oh, I understand
22:17:54 <Tekmo> applicative: I think :)
22:17:55 <Xezlec> Tekmo: I'm not at all clear on why dictionaries are any better... seems like they're identical to what I'm doing now, but I could give it a try.
22:17:59 <Tekmo> applicative: You mean because of the return type?
22:18:03 <applicative> yes
22:18:13 <Tekmo> applicative: Yeah, I can fix that
22:18:17 <Cale> latermuse: and almost all monads give arrows which break that law
22:18:42 <Tekmo> applicative: But before I do
22:18:43 <latermuse> Cale: Breaking the law isnt inherently bad though, no?
22:18:53 <Tekmo> applicative: I assume your original pipe returns a non-() value, correct?
22:18:58 <applicative> I was wondering if you had thought of it and it involved e.g. proxy transformers or something.  I was trying a state monad and suchlike
22:19:01 <Cale> Well, it depends on your definition of "bad"
22:19:15 <Cale> It means that you can't think about arrows just in terms of their wiring diagrams
22:19:16 <Tekmo> applicative: So, a couple of things I can explain
22:19:28 <Tekmo> applicative: Whenever you have a pipe that you KNOW you want to provide the return value for the pipeline
22:19:28 <Cale> you actually have to pay attention to how they're cut up into smaller parts
22:19:32 <applicative> Tekmo: yes, suppose I want your malicious to drop some of the results, not just increment
22:19:47 <Xezlec> Well I have to go to bed.  See you later, all.
22:19:51 <deech> copumpkin: Got it. o
22:19:53 <Cale> But yeah, you can still write programs which work
22:20:07 <applicative> i mean 'malicious' from the tutorial
22:20:08 <deech> copumpkin: https://github.com/bitonic/agdastuff/blob/master/Quicksort.agda
22:20:27 <Tekmo> applicative: Right.  You want malicious to behave like a filter
22:20:36 <deech> copumpkin: Check out the length-filter and qsort function.
22:20:58 <Tekmo> applicative: Oh okay.  If you want i can just generalize the types of the filters
22:21:08 <Tekmo> applicative: Oh, now I remember
22:21:12 <copumpkin> deech: oh, that does a lot of work to prove the sort actually sorts though
22:21:24 <Tekmo> applicative: There is a reason that I set the type of the opposite direction to ()
22:21:29 <Tekmo> applicative: It's coming back to me now
22:21:31 <copumpkin> deech: it'd be a lot shorter if you didn't need to do that
22:21:35 <applicative> I dont think you can, you wrote the types because you had to
22:21:39 <Cale> latermuse: the thing which makes (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k) fail in the case of, say, Kleisli IO, is that g and h "happen" in the opposite order, and they can "crosstalk" because the IO monad has lots of external means of communication.
22:21:44 <applicative> or so I was wondering, Tekmo
22:21:45 <Tekmo> applicative: No, you can technically use a polymorphic type
22:21:52 <copumpkin> deech: proofs will often mirror the structure of the code they're proving something about, so that might explain some duplication
22:21:54 <deech> copumpkin: But is that a style that's encouraged in Agda programming?
22:21:54 <applicative> ah
22:21:59 <Tekmo> applicative: I know because I originally wrote them that way
22:22:06 <Nereid> Cale: so that law holds for Kleisli m precisely when m is a commutative monad, right
22:22:11 <Cale> Nereid: right
22:22:14 <Tekmo> applicative: The reason I switched is because there is a slightly poorly defined behavior when you drop a value
22:22:29 <copumpkin> deech: I probably wouldn't write it that way, but proving things about your programs is certainly encouraged, because we can do it and it's fun :)
22:22:32 <neworder> Hi guys
22:22:33 <Tekmo> applicative: Let's imagine that instead of '()' the value is something of type "x"
22:22:39 <copumpkin> deech: you could easily write a program with no proofs and it would look mostly like haskell
22:22:45 <neworder> I have problems understanding how the type is inferred for the following function
22:22:46 <Tekmo> applicative: And let's discuss "filterD" just for concreteness
22:22:56 <deech> copumpkin: Cool. It's nice that you can do it though.
22:22:59 <copumpkin> yeah
22:23:01 <Tekmo> applicative: So when you make a request from upstream, you have to supply a value of type "x"
22:23:01 <neworder> \ f g -> g (f g) :: ((a -> b) -> a) -> (a -> b) -> b
22:23:12 <Cale> latermuse: So my proposal is that Arrow be restricted to cases where the arrows can only communicate along the lines where you explicitly plug them into one another.
22:23:23 <copumpkin> deech: I'm not sure Agda really has an accepted "coding style" or approach yet, since only a handful of people write it
22:23:26 <Tekmo> applicative: When you filter a value, you don't get a new value of type "x" from downstream
22:23:29 <deech> copumpkin: And I take it the Unicode stuff isn't necessary?
22:23:41 <dolio> deech: length-filter is proving that filter doesn't return a longer list.
22:23:43 <Tekmo> applicative: So if you want to get a new value from upstream, you have to reuse the old value of type "x"
22:23:45 <copumpkin> deech: yeah, the emacs mode for it just makes it really easy to type unicode so we all use it
22:23:49 <Cale> latermuse: there are still lots of useful Arrow instances of that sort, and almost all the useful Arrows I've seen in the wild really do have that property.
22:23:50 <dolio> So that's also proving that the quicksort terminates.
22:23:52 <Tekmo> applicative: However, it's not always clear the user wants values to be reused
22:23:58 <applicative> yes
22:24:00 <Tekmo> applicative: So I played it safe and restricted the type to "()"
22:24:05 <applicative> I see what you mean.
22:24:07 <dolio> Which doesn't happen in Haskell.
22:24:13 <Tekmo> applicative: However, I can always offer the more polymorphic version
22:24:15 <Nereid> neworder: well, both f and g are applied to something, so say g :: a -> b and f :: c -> d
22:24:19 <Tekmo> applicative: with a cautionary note
22:24:34 <Nereid> neworder: but f is applied to g, so we must have f :: (a -> b) -> d
22:24:34 <Cale> latermuse: In addition to this, Arrow is a bit of a restrictive interface for monads, because the future of an arrow computation can't depend on its intermediate results (without the addition of a primitive which effectively says you really have a monad)
22:24:45 <deech> dolio: I see that now. Thanks!
22:24:50 <Nereid> neworder: meanwhile, g is applied to f g :: d, so a = d
22:25:02 <latermuse> cale: So your proposal is to make arrows stricter? Can this be done in the current system?
22:25:25 <Cale> latermuse: yeah, well, nothing has to be done just for that, except that we stop writing certain bad Arrow instances
22:25:29 <Nereid> so you get f :: (a -> b) -> a, g :: a -> b.
22:25:31 <neworder> Nereid: Getting clearer! Thanks
22:25:51 <Cale> latermuse: but there are a whole bunch of other things which I'd like to do to Arrow to adjust it a bit and make it more practical for a wider range of applications
22:25:54 <neworder> lemme understand that
22:26:04 <Cale> latermuse: and those actually start to rely on this law
22:26:28 <applicative> Tekmo: I tried to write a pipe like type that just had one constructor, of your new kind which writes on one side and reads on the other so to say
22:27:02 <applicative> Tekmo: and the difficulty of writing drop and filter seemed insuperable. It works with Proxy Pipes, because they end up with two separate constructors.
22:27:10 <latermuse> Cale: Have you considered making a module with these adjustments?
22:27:13 <Cale> Basically, I'd like to widen the gap between Monad and Arrow a bit, and in the process, make Arrow more relevant.
22:28:06 <Tekmo> applicative: Right.  You can define a type that has synchronized awaits and yields
22:28:23 <applicative> Tekmo, anyway, I wont complain aimlessly more.  I was just puzzled really how e.g. malicious could drop prime numbers or , how I could drop the first five messages from downstream since they're nonsense usully...
22:28:29 <Tekmo> applicative: The main reason I never defined such a type is that usually you can accomplish something similar using just Kleisli composition
22:28:31 <applicative> Tekmo: yes
22:28:44 <Cale> latermuse: I have one in-progress -- it's part of the functional reactive programming system which we wrote at iPwn while implementing our game in Haskell. (This project is on hiatus right now, but we actually have an interesting amount of the game finished, so I hope we can return to it)  We plan to write a few papers and release some part of it to the Haskell community at some point too.
22:28:58 <Tekmo> applicative: Don't worry about complaining!  I always value feedback of any kind
22:29:18 <Nereid> neworder: or we can do this kind of algorithmically
22:29:32 <applicative> Tekmo: a simple pipe type with this hopeless constructor and the kleisli framework, is actually very beautiful, then my heart was broken...
22:29:53 <Nereid> say h = \f g -> g (f g). then h is applied to two things so h :: a -> b -> c, where f :: a and g :: b.
22:29:55 <Tekmo> applicative: Yeah, I went through the same thing
22:30:00 <Tekmo> applicative: Back before I even made the pipes library
22:30:05 <Tekmo> applicative: I was trying out similar abstractions
22:30:18 <Nereid> now we see f g, so f :: d -> e, where d ~ b because it's applied to g :: b.
22:30:23 <latermuse> cale: Do you have a website with information about said game?
22:30:28 <Cale> latermuse: The gist of it is that various operations should be added to the interface to make Arrow more like the categorical definition of a symmetric monoidal category. One of the main practical problems with Arrow as it stands, is that if you use the proc/do notation at all, it defeats much of the point of using the Arrow interface in the first place.
22:30:54 <Nereid> and then we have f g :: e, and we see g applied to it, so g :: i -> j, where i ~ e
22:31:12 <Cale> Because the translation of the arrow syntax essentially sticks uses of 'arr' in between all of your arrows in order to wire the results around to where they need to go
22:31:16 <Tekmo> applicative: Basically, I picked the most powerful but most difficult to work with type out of all the available abstractions and tried to find elegant abstractions around it anywa
22:31:26 <Nereid> but then the return type of h matches the type of g (f g), which is j, so c ~ j
22:31:32 <Cale> but each use of 'arr' is a black box
22:31:40 <latermuse> cale: It wouldnt be this would it? intoverflow.wordpress.com
22:31:44 <applicative> Tekmo: it's very elegant, but all those type parameters !!
22:31:52 <Tekmo> applicative: I consider those necessary
22:31:54 <Nereid> so we just have a bunch of equations
22:32:02 <Cale> latermuse: I'm unfamiliar with that blog
22:32:08 <Tekmo> applicative: When you study the proxy type in depth, you see that there is a lot of theoretical structure that takes advantage of those
22:32:09 <applicative> Tekmo: no it makes sense, yes
22:32:16 <Nereid> h :: a -> b -> c, a ~ d -> e, d ~ b, b ~ i -> j, i ~ e, c ~ j
22:32:21 <Tekmo> applicative: Especially if you study the other two categories
22:32:28 <Tekmo> applicative: They show how those extra type parameters shine
22:32:46 <applicative> which do you mean? which categories
22:32:54 <Cale> latermuse: So, one of the main reasons you'd want an Arrow rather than a Monad in the first place is because any computation in a monad is going to involve >>=
22:32:56 <rwbarton> is there any pipes-like library that allows for more complicated protocols between stages of a pipeline? in the style of session types
22:33:02 <Tekmo> applicative: Oh, check out Control.Proxy.Class's Interact class
22:33:03 <Cale> latermuse: and >>= takes a function as its second parameter
22:33:21 <rwbarton> I was half-tempted to try to write one
22:33:26 <Cale> latermuse: functions are black boxes, and so there's essentially nothing you can do to optimise things dynamically
22:33:27 <applicative> oh yes, ok
22:33:28 <rwbarton> if only so that I could name it "session-pipes"
22:33:40 <applicative> i was thinking you must mean something different
22:33:57 <Tekmo> applicative: Those categories take advantage of the extra type variables
22:34:06 <Cale> latermuse: You can't say: Well, you plugged this thing into this other thing I know about, so I can choose to do something clever to implement it better than just running one and then the other.
22:34:10 <Tekmo> applicative: showing that those type variables are essential
22:34:24 <applicative> ah, I will look at it with this in mind
22:34:29 <Cale> latermuse: With an arrow, both of the parameters to (>>>) are values of a datatype which you have significant control over
22:34:45 <Cale> latermuse: so there's a tantalising amount of opportunity for optimisation
22:34:52 <Tekmo> applicative: In fact, even when I write unidirectional pipe code, I actually still use the Proxy type
22:35:02 <Tekmo> applicative: Because it has so many elegant properties that Pipes don't have
22:35:42 <elliott> rwbarton: I think cmccann's WIP stuff would allow something like that
22:35:47 <applicative> I see, that I don't see yet, but you think the Interact class shows it
22:35:51 <elliott> and maybe Oleg's regions-with-pipes stuff is relevant too
22:36:08 <applicative> Tekmo by the way, I thought of the most hideous imaginable way of uniting the monad transformer and proxy transformers
22:36:15 <rwbarton> it also seems like a natural generalization of the slightly nontrivial "produce a bunch of output and then declare yourself done"
22:36:18 <Tekmo> applicative: What's the idea?
22:36:54 <rwbarton> my main contribution to this area is the name though
22:37:25 <applicative> fancy kinds of course,   ([*] -> *) -> ([*] -> *)
22:37:27 <applicative> or the like
22:38:04 <Tekmo> How does that work?
22:38:22 <Tekmo> Because I've been looking for a solution to a more general problem
22:39:37 <applicative> Tekmo: the natural thought was that one wants to generalize (*->*)  -> (*->*) , so maybe (k -> *) -> (k -> *) but that has nothing to do with the number of parameters
22:40:01 <copumpkin> if you instantiate k to tuples, it does
22:40:06 <applicative> I will try to work it out. The list kind encodes the arity
22:40:25 <applicative> copumpkin: yes, that's what i'm doing, at first I didn't see it.
22:40:48 <nifr> elliott: you can avoid unsafeCoerce in your hpaste 76553 -- interested?
22:41:00 <applicative> but i want 'foo transformers' for monads and for proxies
22:41:25 <applicative> thus something other than a tuple is needed.
22:42:04 <Tekmo> applicative: I will give that a try
22:42:11 <elliott> nifr: definitely
22:42:26 <applicative> copumkin but I misstated my difficulty above, it's that I was impeded by reading k -> * as allowing , e.g. Nat -> *
22:42:56 <applicative> Tekmo: I think it will be impractical, on the hand, I seems like you wouldn't mind blowing the existing transformer mess up.
22:43:04 <applicative> on the other hand, rather
22:44:13 <dibblego> does anyone know of a (!!) function for a list zipper?
22:44:24 <dibblego> (curious about implementation more than anything)
22:44:51 <ion> iterateN n right?
22:44:52 <applicative> dibblego: wouldn't you need !!- for left and -!! for right...
22:45:03 <dibblego> yeah those are easy functions
22:45:17 <dibblego> I am thinking more, "move to this absolute index"
22:45:24 <applicative> Tekmo: in any case it is very beautiful, I will continue to study it.
22:45:37 <Tekmo> Thanks!
22:45:47 <hpaste> nifr annotated “augh” with “augh (annotation)” at http://hpaste.org/76553#a76556
22:45:57 <nifr> huh
22:46:16 <dibblego> I am thinking "move left, with a trailing focus and if that trailing focus reaches n, then move to far-left and return trailing focus, otherwise, keep length of left, then move right the required amount"
22:46:30 <dibblego> I was wondering how smart/silly that might be
22:46:56 <nifr> the proxy argument specifies us, which was previously undetermined by context since it only occurred as the index of a type family (which are non-injective)
22:48:20 <neworder> Nereid: what does this symbol mean ~ in d ~ b
22:48:27 <Nereid> type equality
22:48:31 <nifr> unless the proxy argument is unacceptable for your intended interface?
22:48:37 <elliott> nifr: oh, nice
22:48:54 <elliott> nifr: it seems like you could avoid the Proxy by defining a casting function
22:48:59 <elliott> like asTypeOf
22:49:06 <elliott> since it is just there to set "us" correctly, right?
22:49:37 <nifr> it seems that way, but in my experience it won't work; you'll just be delaying the essential problem
22:49:51 <elliott> hrm
22:49:54 <nifr> which is, that us only occurs within the index of a type family
22:49:54 <elliott> I'll play around with it
22:49:59 <elliott> thanks, anyway
22:50:08 <elliott> certainly better than unsafeCoerce in practice
22:50:09 <nifr> gl -- let me know if you get anywhere with that cast
22:50:42 <elliott> :)
22:51:45 <dibblego> alrighty, I'll take a crack myself
22:53:32 <koala_man> dibblego!
22:54:37 <neworder> Nereid: For the algorithmic explanation you were giving,  h = \f g -> g (f g). then h is applied to two things so h :: a -> b -> c, where f :: a and g :: b
22:54:40 <neworder> I understand the above
22:54:45 <dibblego> omg it's koala_man!!
22:55:15 <neworder> but a is the type returned by function a right?
22:55:19 <koala_man> omg
22:55:25 <Nereid> what function a?
22:55:59 <neworder> oh sorry, by function f I mean
22:56:06 <Nereid> a is the type of f
22:56:31 <neworder> ok, then later you bring in d->e, why is that so
22:56:41 <Nereid> because we see "f g", so f is a function.
22:56:54 <Nereid> so it's type is some function type d -> e
22:56:56 <neworder> Ah I see
22:57:31 <Nereid> so then you can write down the equation a ~ d -> e
22:59:06 <neworder> If we say that a is the type of f, does it mean that the function f returns the type a?
22:59:10 <Nereid> no.
22:59:31 <Nereid> @type chr
22:59:33 <lambdabot> Int -> Char
22:59:40 <neworder> ohh!
22:59:52 <mm_freak> neworder: in C when you say "int x;", then x /is of type/ int, not /x returns an int/
22:59:55 <Nereid> Int -> Char is the type of chr. but the function chr returns a value of type Char.
23:00:36 <mm_freak> and much less does x return the type int
23:00:54 <Nereid> a function returning a type doesn't make sense
23:01:07 <mm_freak> it does, but not in haskell
23:01:13 <neworder> Hmm I see!
23:01:29 <mm_freak> at least not in standard haskell =)
23:01:33 <Nereid> (unless we're talking about type functions...)
23:01:37 <neworder> Looks like I'm confusing functions
23:01:39 <neworder> haha
23:02:15 <mm_freak> Nereid: "Int -> exists b. b" is a basically a function that returns a type and a value of that type
23:02:16 <neworder> *confused with functions in Haskell
23:02:23 <mm_freak> neworder: think simple
23:02:50 <neworder> hmm ok
23:03:00 <mm_freak> neworder: in haskell everything has a type, not just the arguments and result of a function, but the function itself, too
23:03:16 <mm_freak> Int -> Char is the type of a function that takes an Int as argument and produces a Char
23:03:44 <neworder> I see
23:03:46 <mm_freak> a -> a is the type of a function that takes an 'a' and produces an 'a'…  the type is variable, but argument and result have the same type
23:04:58 <neworder> the type as in a right?
23:05:13 <neworder> you said the type is variable
23:05:18 <mm_freak> 'a' /is/ the type (or argument and result)
23:05:38 <mm_freak> and 'a' is a variable in the mathematical sense
23:05:42 <Nereid> a is a "type variable"
23:05:52 <mm_freak> see this function:  id x = x
23:05:59 <Nereid> a can stand for any type
23:06:07 <neworder> Hmm I see
23:06:11 <mm_freak> it takes an argument, calls it 'x' and gives it right back as its result
23:06:18 <Nereid> @type id
23:06:19 <lambdabot> forall a. a -> a
23:06:30 <mm_freak> you can use it as an Int -> Int, a String -> String or a Double -> Double
23:06:38 <mm_freak> or even as a (Int -> Int) -> (Int -> Int)
23:06:49 <shachaf> (exists a. a -> a), on the other hand, is a pretty useless function.
23:06:52 <mm_freak> as long as it matches the pattern a -> a
23:07:03 <neworder> I see!
23:07:23 <mm_freak> neworder: just like 4, 9 and 16 all match the pattern x²
23:07:36 <mm_freak> think of variables in the mathematical sense in haskell
23:07:45 <mm_freak> both for values and types
23:08:50 <neworder> hmm alright
23:08:52 <Nereid> I don't like your x^2 example.
23:09:10 <mm_freak> yeah, because it's lacking a type =P
23:09:32 <neworder> haha, yeah, this was clearer (Int -> Int) -> (Int -> Int)
23:10:05 <mm_freak> neworder: just to blow your mind:  (a -> b) -> (a -> b) is also an instance of a -> a
23:10:16 <shachaf> mm_freak: That's just unhelpful.
23:10:24 <shachaf> (a -> b) -> (a -> b) is an instance of (c -> c)
23:10:42 <mm_freak> ok, that could be better
23:10:51 <mm_freak> (b -> c) -> (b -> c) is also an instance of a -> a
23:11:03 <shachaf> For any types b and c.
23:11:06 <neworder> yup got that, thanks guys
23:12:00 <neworder> I can read the -> as mapped to right?
23:12:07 <mm_freak> yeah
23:12:39 <mm_freak> read "id :: a -> a" as: for all types 'a', 'id' is a mapping from 'a' to 'a'
23:12:40 * shachaf thinks putting foralls everywhere makes this much clearer.
23:13:33 <neworder> yup!
23:14:01 <shachaf> "forall" can be thought of as another type of "->", by the way. But maybe that's just confusing right now. :-)
23:15:23 <neworder> For this function, h = \f g -> g (f g).  h :: a -> b -> c,  c is the type of the function gfg right?
23:15:38 <mm_freak> shachaf: actually thinking of 'forall' that way made me understand RankNTypes =)
23:15:47 <shachaf> mm_freak: Right, it's a very helpful way of thinking about it.
23:16:09 <mm_freak> but yeah, i was cheating…  i've learned agda already =)
23:18:16 <mm_freak> neworder: h f g = g (f g), so g :: a -> b, so f :: (a -> b) -> a, so h :: ((a -> b) -> a) -> (a -> b) -> b
23:19:43 <mm_freak> 'g' must be a function, so its most general type is a -> b…  f takes g as an argument and its result is passed to g, so its argument is of type a -> b and its result is of type a
23:20:12 <mm_freak> because h's result is g's result, h's result is of type b
23:20:14 <mm_freak> hence the type
23:20:16 <neworder> why is its result of type a
23:20:18 <neworder> oh
23:20:46 <mm_freak> type inference done manually =)
23:21:16 * shachaf gets the urge to mess up mm_freak's computations with wrong data just to be able to call it "type interference".
23:21:27 <mm_freak> hehe
23:21:35 <mm_freak> neworder: note that 'f' can't return anything
23:22:05 <mm_freak> neworder: to understand why, try to write a function with the type (a -> b) -> a
23:22:18 <mm_freak> myFunc f = …
23:22:22 <neworder> oh!
23:22:50 <neworder> so f is a function which takes in a function which maps a to b and then maps it to a?
23:23:00 <mm_freak> exactly
23:23:06 <lanqing> hi all
23:23:12 <mm_freak> hi there lanqing
23:23:50 <neworder> when it finally maps to a, isn't it equivalent of saying that it returns a?
23:23:52 <neworder> haha
23:24:02 <mm_freak> yeah, but how does it do that?
23:24:38 <neworder> oh I see, so there's no return in Haskell
23:24:43 <neworder> right?
23:24:44 <mm_freak> that's not the point
23:24:56 <lanqing> I come to haskell today, how to learn it?
23:25:04 <mm_freak> neworder: write a small test function
23:25:07 <mm_freak> myFunc :: a -> b
23:25:13 <mm_freak> try to write a function with that type
23:25:18 <mm_freak> myFunc x = …?
23:25:26 <neworder> y
23:25:33 <mm_freak> lanqing: did you try LYAH?
23:25:37 <mm_freak> @where lyah
23:25:37 <lambdabot> http://www.learnyouahaskell.com/
23:25:44 <mm_freak> neworder: y is not in scope
23:25:53 <Nereid> "what's y?"
23:26:07 <lanqing> thanks
23:26:42 <neworder> oh!
23:26:54 <neworder> yah, get that
23:26:56 <lanqing> It's there any video lecture about Haskell?
23:27:06 <mm_freak> neworder: no, really, try to write that function
23:27:13 <Nereid> unsafeCoerce
23:27:15 <Nereid> ;)
23:27:20 <mm_freak> it's possible to write a well-typed function of the type a -> b in haskell
23:27:21 <neworder> Yup, thinking about it
23:27:31 <Nereid> oh I see where you're going.
23:27:59 <elliott> lanqing: you should probably read lyah
23:28:00 <elliott> @where lyah
23:28:00 <lambdabot> http://www.learnyouahaskell.com/
23:28:01 <neworder> If it takes only on argument, then..
23:28:07 <neworder> I'm a bit confused, haha
23:28:11 <neworder> what's the answer?
23:28:19 <neworder> one argument*
23:28:30 <mm_freak> neworder: myFunc :: a -> b…  its argument is of type 'a', so myFunc x = x is a type error
23:28:37 <mm_freak> because its result is of type 'b'
23:28:49 <mm_freak> but one thing is always possible:  myFunc x = myFunc x
23:28:59 <Nereid> myFunc x = let y = y in y
23:29:00 <mm_freak> certainly, because obviously the equation holds =)
23:29:14 <Nereid> myFunc x = undefined
23:29:14 <Nereid> etc.
23:29:33 <mm_freak> Nereid: please wait before revealing bottom =)
23:29:50 <Nereid> ok, go on.
23:29:50 <neworder> hmm, myFunc is on both sides, doesn't that mean they must be of the same type?
23:29:53 <Nereid> :p
23:29:58 <mm_freak> neworder: they are
23:30:04 <mm_freak> myFunc x :: b
23:30:07 <lanqing> @while lyah
23:30:08 <lambdabot> http://www.learnyouahaskell.com/
23:30:17 <lanqing> instersting
23:30:17 <neworder> or so in other words a=b
23:30:22 <neworder> ?
23:30:26 <Nereid> no
23:30:29 <Nereid> x has type a
23:30:29 <mm_freak> neworder: no, that would change the story entirely 0)
23:30:30 <mm_freak> =)
23:30:32 <Nereid> but myfunc x has type b
23:30:38 <Nereid> because myfunc :: a -> b
23:30:48 <lanqing> @where lyah
23:30:49 <lambdabot> http://www.learnyouahaskell.com/
23:30:57 <mm_freak> neworder: let's make it simpler
23:31:00 <neworder> oh!
23:31:03 <mm_freak> write a value x of type a
23:31:03 <neworder> I get it
23:31:04 <lanqing> @where haskell
23:31:04 <mm_freak> x :: a
23:31:04 <lambdabot> http://haskell.org
23:31:05 <mm_freak> x = ?
23:31:17 <mm_freak> the only possibility is x = x
23:31:29 <neworder> Hmm I see
23:31:36 <lanqing> @where erlang
23:31:37 <lambdabot> I know nothing about erlang.
23:31:44 <mm_freak> but then what's x?
23:31:49 <mm_freak> ah, x is x
23:31:51 <mm_freak> so what's x?
23:31:53 <mm_freak> it's x
23:31:56 <mm_freak> and what's x?
23:31:57 <mm_freak> it's x
23:31:59 <neworder> haha
23:32:00 <mm_freak> infinite loop =)
23:32:01 <neworder> it's x
23:32:04 <neworder> I see
23:32:17 <Nereid> > let x = x in x
23:32:20 <lambdabot>   mueval-core: Time limit exceeded
23:32:23 <lanqing> @help
23:32:23 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:32:30 <lanqing> @list
23:32:30 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:32:52 <Nereid> lanqing: you are encouraged to try lambdabot out in private. :p
23:33:15 <lanqing> sorry
23:34:06 <neworder> Just to confirm that I got it
23:34:10 <neworder> myfunc :: a -> b
23:34:25 <neworder> myfunc takes in elements of type a and maps them to elements of type b
23:34:32 <Nereid> sure
23:34:37 <Nereid> (we call elements "values")
23:34:39 <mm_freak> neworder: the "for all" is important
23:34:45 <Nereid> ah, right.
23:34:54 <mm_freak> for all types a and b, myFunc maps values of type a to values of type b
23:35:02 <Nereid> quantifiers are often hidden, so it's really myfunc :: forall a b. a -> b
23:35:20 <neworder> ok
23:35:54 <neworder> eh wait
23:35:54 <Nereid> but any function of that type is either useless or unsafeCoerce.
23:36:09 <mm_freak> any function of that type is useless, period
23:36:12 <mm_freak> there is no unsafeCoerce
23:36:15 <Nereid> :P
23:36:25 <ion> unsafeCoerce ALL THE THINGS
23:36:42 <Jafet> @quote unsafeCoerce
23:36:42 <lambdabot> roconnor says: unsafeCoerce isn't even safe
23:36:57 <mm_freak> @quote Jafet
23:36:57 <lambdabot> Jafet says: [on ##c++] They're not nasty; their niceness is just distributed over more people.
23:37:09 <Nereid> lol
23:37:11 <mm_freak> lol
23:37:52 <mm_freak> neworder: the "for all" means that the caller chooses the types a and b
23:38:00 <ion> hah
23:38:13 <mm_freak> if i'm the caller of 'id' and id :: a -> a, then i can choose a = Int and say "id 3"
23:38:22 <mm_freak> and i'm expecting an Int as result
23:38:41 <Nereid> @type (id :: Int -> Int) 3
23:38:42 <lambdabot> Int
23:38:58 <mm_freak> as the caller of myFunc i could choose a = Int and b = String
23:39:08 * hackagebot iptadmin 1.3.0 - web-interface for iptables  http://hackage.haskell.org/package/iptadmin-1.3.0 (EvgenyTarasov)
23:39:10 * hackagebot pandoc 1.9.4.4 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.4.4 (JohnMacFarlane)
23:39:14 <mm_freak> because myFunc promises to work "for all" a and b
23:39:31 <Nereid> "work"
23:39:32 <neworder> Hmm I see!
23:39:47 <neworder> There's no restriction on the types then, right
23:40:03 <mm_freak> less restrictions on types means more restrictions on values
23:40:10 <neworder> a is a set of all types an db is a set of all types right?
23:40:18 <Nereid> no, they are variables.
23:40:24 <neworder> I mean for this case
23:40:33 <neworder> where the restrictions are not defined
23:40:34 <Nereid> they may stand for any type.
23:40:40 <neworder> Hmm
23:40:40 <mm_freak> a is a type and b is a type
23:40:42 <Nereid> but variables are not sets.
23:40:54 <neworder> Hmm ok
23:41:08 <neworder> when I say something like  (\ x = x +1 ) 3
23:41:15 <Nereid> > (\x -> x+1) 3
23:41:16 <lambdabot>   4
23:41:38 <mm_freak> neworder: complicated example, but go on
23:41:52 <Nereid> it's complicated because of + and 1.
23:41:57 <Nereid> and 3.
23:42:03 <neworder> 3 is mapped to x right
23:42:06 <neworder> I mean
23:42:09 <mm_freak> yeah
23:42:14 <neworder> 3 is pattern matched with x
23:42:20 <neworder> and then x is mapped to x + 1
23:42:22 <mm_freak> in that function application 'x' becomes 3
23:42:32 <neworder> hmm, yeah
23:42:35 <mm_freak> so (\x -> x + 1) 3 = 3 + 1
23:42:40 <Nereid> so (\x -> x+1) 3 reduces to 3+1.
23:42:45 <Nereid> yeah.
23:42:45 <neworder> similarly
23:43:27 <neworder> if we compare the above function to myfunc x
23:43:47 <neworder> myfunc is undefined unlike  (\ x = x +1 ) right?
23:43:55 <neworder> Sorry if my questions seem weird
23:43:56 <mm_freak> myFunc is defined
23:43:58 <Nereid> myfunc is defined, it's just useless.
23:43:59 <mm_freak> we just defined it =)
23:44:04 <neworder> don't know why I'm confusing about this!! =(
23:44:11 <mm_freak> no worries
23:44:24 <neworder> what's its definition
23:44:30 <mm_freak> myFunc x = myFunc x
23:44:45 <Nereid> it's a recursive definition
23:44:56 <neworder> hmm
23:45:00 <neworder> so in this case
23:45:03 <neworder> a=b right?
23:45:09 <neworder> myfunc:: a->b
23:45:12 <Nereid> no
23:45:17 <Nereid> both sides of the equation have type b
23:45:34 <mm_freak> neworder: if myFunc :: a -> b and x :: a, then myFunc x :: b
23:45:46 <mm_freak> if you apply a function of type a -> b to a value of type a, you get a value of type b
23:46:05 <neworder> ohhh
23:46:07 <neworder> hahaha
23:46:10 <neworder> Alright
23:46:36 <mm_freak> just like sin 3 :: Double
23:46:37 <mm_freak> =)
23:46:47 <neworder> in the above case, we didn't define the type of x
23:46:52 <neworder> so what does Haskell do
23:46:53 <mm_freak> we did
23:46:58 <Nereid> we did, when we said myfunc :: a -> b
23:47:00 <mm_freak> myFunc :: a -> b
23:47:04 <mm_freak> so x :: a
23:47:11 <neworder> Ah I see!!
23:47:57 <mm_freak> but the type of x doesn't really matter, because our myFunc can't possibly do anything with its argument =)
23:48:07 <neworder> Imperative programming is so much more straight forward.. haha
23:48:07 <mm_freak> and also can't return it, precisely because we can't assume a = b
23:48:13 <shachaf> type family Hi a; data Foo = Foo (forall a. Hi a); conv (Foo x) = Foo x
23:48:34 <mm_freak> haskell is logic…  once you get it, it's much more straightforward than imperative programming =)
23:48:44 <Nereid> I don't think it's a matter of imperative vs functional programming though
23:48:51 <mm_freak> in particular, knowing all this you learn to read what a function does from its type signature =)
23:48:53 <Nereid> I could imagine an imperative language with type inference.
23:49:02 <mm_freak> i know that a function of type a -> b -> a must be the constant function
23:49:04 <Nereid> although I guess we still have to talk about types of functions.
23:49:12 <Nereid> mm_freak: or something less defined than that.
23:49:37 <mm_freak> either that or it's an infinite loop for the reasons you just learned =)
23:49:45 <Nereid> @djinn f :: a -> b -> a
23:49:45 <lambdabot> Cannot parse command
23:49:50 <Nereid> eh
23:49:53 <Nereid> @djinn a -> b -> a
23:49:53 <lambdabot> f a _ = a
23:50:22 <mm_freak> Nereid: functional programming plays an important role, because that's where types not only capture valid arguments/results, but actually the structure of the algorithm
23:50:38 <Nereid> sure.
23:50:58 <mm_freak> imperative programs don't have that property, so you still can't reason about what they are /doing/
23:51:01 <mm_freak> in haskell you can
23:51:29 <mm_freak> that's the difference between lists of actions and monadic I/O =)
23:54:58 <neworder> For this function, to infer the types which you explained just now, \f g -> g (f g)
23:55:10 <neworder> which side to we look at first
23:55:27 <neworder> right or left
23:55:33 <shachaf> type family Hi a; foo :: (forall a. Hi a) -> (forall b. Hi b)
23:55:36 <shachaf> Can you write foo?
23:56:06 <mm_freak> shachaf: unless bottoms are allowed, no
23:56:18 <shachaf> Why not?
23:56:39 <mm_freak> or are polymorphic instances allowed?
23:56:46 <mm_freak> type instance Hi a = a
23:57:16 <mm_freak> neworder: i looked on the right side first
23:57:17 <shachaf> Yes, that instance makes it type-check. But I mean in general.
23:57:27 <shachaf> You might *think* that "foo x = x" would work...
23:57:43 <neworder> Alright, I will try inferring the types
23:57:50 <mm_freak> ah, i confused type with data
23:58:24 <mm_freak> the question is:  foo :: (forall a. Hi a) -> Hi b
23:58:31 <shachaf> Right.
23:58:50 <mm_freak> doesn't seem possible to me
23:59:13 <neworder> g is a function, so let's give it a type a->b   ,  since f takes g as an argument and it's result is the argument of g, f:: (a->b) -> a
23:59:15 <Nereid> why can one not write foo = id?
23:59:21 <mm_freak> foo x = x obviously doesn't work
23:59:30 <mm_freak> because possibly Hi a = Int
23:59:43 <shachaf> But my argument has to be polymorphic.
