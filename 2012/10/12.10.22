00:00:23 <sheriff_> The big problem with LYAH is that the big images make it hard to subtly pretend you're reading something else at work
00:00:58 <johnw> haha
00:01:52 <dmwit> "A programmer puts two glasses on his bedside table before going to sleep. A full one, in case he gets thirsty, and an empty one, in case he doesn't."
00:02:29 <shachaf> Sounds like a joke intuitionists would make about classicalists, and vice versa.
00:02:43 <sheriff_> I have a boat load of really boring questions about Haskell terminology, so apologies in advance
00:03:07 <dmwit> Bring it. 90% chance you'll watch a really boring and long argument about Haskell terminology in response to any give such question.
00:03:35 <sheriff_> If we define a new type class with a method `foo`, and define other types as being instances of it, that's ad-hoc polymorphism
00:03:52 <sheriff_> Because the compiler/whatever is dispatching the same named function for different types
00:03:55 <sheriff_> amirite?
00:04:03 <shachaf> That sounds like an argument about words.
00:04:10 <dmwit> urite
00:05:13 <sheriff_> Given a type class called "Foo", if I go and say "instance Foo String where" ... would I be right to say "String is an instance of Foo"
00:06:13 <dmwit> yes
00:06:34 <sheriff_> quadruple :: (Doubleable a) => a -> a -- this is a parametrically polymorphic function, right?
00:06:46 <dmwit> tricky question
00:06:50 <sheriff_> k, why?
00:06:51 <dmwit> Some people say yes, some no.
00:06:59 <shachaf> Hence <shachaf> That sounds like an argument about words.
00:07:11 <sheriff_> Can you briefly outline the argument that it's not?
00:07:17 <shachaf> "foo" :: YourClass a => a -> a
00:07:21 <dmwit> On the one hand, one valid way to compile it is to make a parametrically-polymorphic function which takes a dictionary of Doubleable methods as its first argument.
00:07:24 <shachaf> From the foo before.
00:07:41 <shachaf> You called that one ad-hoc.
00:07:53 <dmwit> On the other hand, that makes the term "parametrically polymorphic" kind of stupidly unuseful in a Haskell context, so others use the term "ad-hoc polymorphic" to distinguish between class-polymorphic and other functions.
00:08:17 <shachaf> I say this terminology is mostly useless.
00:08:18 <sheriff_> shachaf: hrm
00:08:28 <sheriff_> Yeah, sadly I have to write a paper about it, so :-)
00:08:58 <sheriff_> More accurately, I have written a paper about it, and I am just double-checking I haven't completely missed the point
00:09:14 <shachaf> You have to write a paper about what words mean?
00:09:58 <sheriff_> shachaf: OK, I have a comeback
00:10:11 <sheriff_> foo is ad-hoc polymorphic, because I have defined different implementations for different types
00:10:36 <sheriff_> Where quadruple (ahd I appreciate I haven't shown the function body) is parametrically polymorphic
00:10:44 <sheriff_> because it uses the same implementation for each type
00:10:50 <dmwit> But that's not true.
00:10:50 <sheriff_> > quadruple :: (Doubleable a) => a -> a
00:10:50 <sheriff_> > quadruple = double . double
00:10:51 <lambdabot>   Not in scope: type constructor or class `Doubleable'Not in scope: `quadruple'
00:10:51 <lambdabot>   can't find file: L.hs
00:10:51 <shachaf> That seems like a silly distinction.
00:11:09 <rwbarton> what if it was just blah :: Doubleable a => a -> a; blah = double
00:11:17 <dmwit> It uses a different implementation for each type for exactly the same reason double does. It calls double; it has no choice but to use a different implementation for each type if double does.
00:11:24 <rwbarton> are you going to say double is ad-hoc polymorphic and blah is parametrically polymorphic?
00:11:34 <sheriff_> rwbarton: Yes
00:11:40 <rwbarton> but they are the same
00:11:58 <shachaf> They're the same except you can't say "instance Doubleable Blah where blah = ..."
00:11:59 <rwbarton> the only difference is that I have to use the name "double" when I define an instance
00:12:19 <shachaf> But that's not worth calling one "ad-hoc" and the other "parametric".
00:12:20 <sheriff_> ad-hoc polymorphism is about over-loading of function names, so the compiler/interpretor chooses the correct one for you
00:13:00 <shachaf> I wouldn't say that type classes are really for "ad-hoc polymorphism" in the usual sense.
00:13:06 <shachaf> But then again, I'm a h8r.
00:13:54 <sheriff_> rwbarton: Regardless of the actual underlying implementation, blah is the definition of parametrically polymorphic because it's defined the same way for every type, which is, in terms of 'double'
00:14:34 * dmwit squints at sheriff_
00:14:35 * shachaf notes that this argument is only "interesting" because it's about words.
00:14:49 <sheriff_> I dunno, this is the argument I'm making in my essay
00:15:05 <dmwit> You have a funny definition of ad-hoc polymorphism, and I think you will find it doesn't match any of the most popular camps of current definitions.
00:15:14 <sheriff_> I note no-one has actively called my views stupid yet, which I'm taking as a positive sign
00:15:23 <sheriff_> Or maybe a sign of politeness unusual for IRC
00:15:29 <dmwit> Your argument is stupid, and you should feel stupid.
00:15:39 <sheriff_> gah.
00:16:34 <sheriff_> "Ad-hoc polymorphism occurs when a function is defined over several different types, acting in a different way for each type"
00:16:47 <sheriff_> Am I saying something significantly different from that?
00:16:56 <dmwit> "acting in the same way" means "does not inspect the bits"
00:17:05 <dmwit> You can copy bits, but not manipulate them.
00:17:20 <dmwit> quadruple inspects bits (because double inspects bits)
00:20:11 <sheriff_> dmwit: Isn't that necessarily just a detail on how ghci works?
00:20:40 <shachaf> I think dmwit is using the word "bits" to mean something more "denotational" than that.
00:20:46 <sheriff_> k
00:46:02 <shachaf> rwbarton: By the way, you should read the STG paper!
00:46:04 <shachaf> @where stg
00:46:04 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
00:47:17 <rwbarton> yes I should
01:00:22 <iskren> I have some code that uses Foreign.C.Types.CUInt, but the newest GHC doesn't have that. What should I use instead? Data.Word.Word32?
01:00:37 <shachaf> I have CUInt
01:01:03 <shachaf> (Which is defined as a wrapper around Word32, but that's architecture-specific, of course.)
01:02:21 <iskren> http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/ << this doesn't have Foreign.C.Types
01:03:12 <shachaf> Yes it does?
01:04:56 <iskren> hmmmm, 4.6.0.0 also has it, shachaf you're right
01:05:43 <gienah> iskren: sometimes you need to import the constructor as well: import Foreign.C.Types    (CULong(..), CUInt(..))
01:06:30 <shachaf> There should be no need to import the constructor.
01:08:50 <iskren> gienah, I'll try that
01:10:03 <iskren> gienah, aah, that worked. It didn'
01:10:17 <shachaf> iskren: You shouldn't need to match on the constructor, usually.
01:10:25 <iskren> it worked before ghc 7.6.1, but now it failed :)
01:10:27 <shachaf> Well, it depends.
01:10:34 <shachaf> fromIntegral can always do the conversion for you.
01:10:47 <shachaf> But maybe that's too polyorphic.
01:10:49 <iskren> here is the file: https://github.com/ichernev/dotfiles/blob/master/.xmonad/lib/XMonad/Hooks/PerWindowKbdLayout.hsc
01:12:14 <iskren> I found this file in some mail list and I started using it, for 1-2 years now
01:12:20 <gienah> yeah its with ghc 7.6.1 that it wants the constructor, like I had to patch out the conditional compilation in gtk2hs-buildtools: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/gtk2hs-buildtools/files/gtk2hs-buildtools-0.12.3.1-remove-conditional-compilation-as-it-is-ignored-ghc-7.6.patch
01:12:44 <gienah> because c2hs ignore the conditional compilation, and ghc 7.6.1 really wants the constructor
01:13:12 <iskren> gienah, so adding '(..)', i.e importing constructors is the right solution of the problem, right?
01:13:46 <gienah> iskren: yes I think so, in that it makes it compile
01:14:23 <shachaf> iskren: Well, fromIntegral :: CUInt -> Word32
01:19:46 * hackagebot Stream 0.4.6.1 - A library for manipulating infinite lists.  http://hackage.haskell.org/package/Stream-0.4.6.1 (WouterSwierstra)
01:37:53 <t7> @hoogle (^)
01:37:53 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
01:37:53 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
01:37:53 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
01:38:10 <t7> > 2 ^ 28
01:38:11 <lambdabot>   268435456
01:38:13 <t7> > 2 ^ 48
01:38:14 <lambdabot>   281474976710656
01:39:13 <t7> only 281 terabytes are addressable on amd64?
01:39:47 * hackagebot async 2.0.1.4 - Run IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/async-2.0.1.4 (SimonMarlow)
01:39:49 <shachaf> Haswell will probably has 56 address bits.
01:40:33 <shachaf> @google 281474976710656 bytes in terabytes
01:40:34 <lambdabot> 256 terabytes
01:40:35 <lambdabot> http://supportline.microfocus.com/documentation/books/sx20books/fhlimi.htm
01:40:35 <lambdabot> Title: File Handling Limits
01:44:56 <bGoku> hello. I was wondering how could one efficiently manipulate images in haskell (modifying them at a pixel level) when haskell is immutable?
01:46:25 <shachaf> If you want to write an imperative program full of state mutation, you can certainly do that in Haskell.
01:46:51 <beaky> hello
01:46:54 <beaky> helo
01:46:55 <shachaf> On the other hand, depending on the type of manipulation, often there are less-mutating ways of doing things.
01:46:59 <beaky> hello*
01:47:09 <bGoku> shachaf really? I thought you can't mutate things in haskell?
01:47:15 <byorgey> hi beaky
01:47:49 <shachaf> bGoku: Sure you can. There are arrays and mutable variables and everything.
01:47:54 <shachaf> People just prefer not to use them.
01:47:57 <beaky> http://ideone.com/uCWbAV any ideas on getting the turing machine to print only the parts of the tape it touched?
01:48:03 <beaky> rather than the entire infinitely-long tape ^^
01:48:36 <shachaf> Keep track of how much tape you've actually used, and print only that much.
01:48:52 <bGoku> shachaf ok interesting. so what makes haskell purely functional then?
01:49:14 <beaky> purely functional => referential transparency I think
01:49:25 <MostAwesomeDude> bGoku: Define "purely functional" first. :3
01:49:38 <shachaf> Please don't define "purely functional". :-(
01:49:41 <byorgey> bGoku: you can have arrays and mutable variables and so on... but their use is tightly restricted by the type system.
01:49:54 <beaky> in a true functional language, evaluation is simply substituting symbols
01:49:56 <shachaf> byorgey: It's not really accurate to say "by the type system", I think.
01:50:16 <shachaf> byorgey: You could have an untyped language with all the same properties.
01:51:06 <byorgey> well, that's true, but my point is that if you have a function of type, say,   Int -> Int,  you know it cannot do any manipulation of mutable variables, mutable arrays, etc.
01:51:09 <shachaf> It might be more accurate to say that it's restricted by the primitives you have (i.e. IO + (>>=) + return + putStrLn + the RTS running main, - unsafePerformIO - anything that does IO on its own).
01:51:43 <shachaf> That's only true because there's no primitive of type Int -> Int that does that. :-) But if you took Scheme and took all those primitives out, you'd end up with the same properties.
01:52:08 <byorgey> OK, agreed.
01:52:24 <beaky> In a language like Haskell, all the IO is segregated from all the logic bits
01:52:52 <beaky> whereas in a language like Java, a function int foo(int) can read and write stuff
01:53:24 <beaky> Haskell has achieved IO encapsulation with monads.
01:54:33 <beaky> also, imperative languages have this notion of sequence, where you find yourself in the middle of computations.
02:00:00 <doomlord> image manipulatiion - interesting question.
02:00:43 <doomlord> i think functional langauges are good at expressing undo systems, eg a seemingly mutable datastructure which is a record of changes..
02:29:38 <sordina> So, is there a nice way to combine lenses with mutable arrays?
02:54:48 * hackagebot aws-sdk 0.4.2.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.4.2.0 (YusukeNomura)
02:59:42 <doomlord> do lonses solve the pronlem of name clashes in records
03:02:43 <Nereid> no?
03:03:51 <doomlord> lenses not lonses yikes, typo
03:04:27 <Nereid> I assumed that. and also problem.
03:04:45 <zhulikas> and a missing question mark in the end
03:05:54 <doomlord> is there any workaround for that with template haskell
03:06:05 <Nereid> workaround for what
03:06:17 <Nereid> I don't know if I'd call it a problem, anyway.
03:06:36 <Nereid> if you want a common interface to multiple data types, consider a type class.
03:07:04 <doomlord> ah, perhaps template haskel could streamline making the typeclass..
03:07:16 <Nereid> maybe
03:07:32 <doomlord> i like most of the ideas in haskell - its just the name clashes in records feels un-natural
03:07:53 <doomlord> (after taking structs for granted in C for so long)
03:08:22 <doomlord> even ASM could do some sharing of names between structs :) by placing the same named slots at the same offset (like single-inheritance of structs)
03:08:29 <Nereid> get used to it :v
03:08:51 <doomlord> i'm oscilating between different potential languages
03:09:25 <zomg> It seems people either prefix the record functions or just use qualified imports
03:10:12 <doomlord> how would the typeclass solution look... you'd make a typeclass for each common name ?
03:10:31 <Nereid> or set of common names
03:10:47 <doomlord> ones that always occur together, ok
03:11:15 <merijn> doomlord: You can use qualified imports to deal with nameclashes in records
03:11:34 <Nereid> if they come from different modules, yes
03:11:44 <merijn> (obviously this requires that clashing records come from different modules)
03:12:27 <mm_freak> doomlord: the more experience you gain, the less you will use struct-like ADTs anyway
03:12:51 <merijn> mm_freak: Well, they're nice in combination with State(T), but I guess nameclashes aren't really an issue then
03:13:08 <mm_freak> record puns have about the same status as OO here…  if enough people would really care, there would be a solution
03:13:09 <doomlord> its most natural for me to think in data first then in transformations of that data second
03:13:21 <mm_freak> it's just that nobody really considers this a real problem
03:13:45 <Nereid> doomlord: haskell requires you to think differently from most languages ;)
03:13:55 <shachaf> Haskell records are somewhat annoying but not a fundamental problem, at least.
03:14:06 <doomlord> data and functions should work in the functional world :)
03:14:23 <doomlord> i get the point that haskell is proving more ideas such that this individual issue doesn't kill it
03:14:34 <doomlord> but it *does* repel me :(
03:14:52 <doomlord> which is a shame because i like a lot of what it does
03:15:06 <mm_freak> that's sad to hear…  as said, the more experience you have, the less you will even notice the lack
03:15:16 <shachaf> "the more brainwashed you get"
03:15:20 <Nereid> lol
03:15:23 <mm_freak> lol
03:15:30 <zhulikas> I bet php programmers doesn't compain about php either
03:15:31 <zhulikas> :P
03:15:42 <zhulikas> with all the experience they have
03:15:55 <zhulikas> s/doesn't/don't
03:16:21 <mm_freak> true…  you guys have successfully brainwashed me to think that OOP is the most stupid idea that has ever inspired a language
03:16:35 <Nereid> I bet there are a lot of php programmers who are php programmers only because they're trapped
03:16:40 <doomlord> i dont like OOP. i much prefer *seperating* functions and data
03:18:11 <zhulikas> I am just not entirely sure that argument 'problem fades away when you realise other ways to achieve it' isn't a good argument for something being not intuitive enough
03:19:00 <doomlord> so with a typeclass - you could give many types the same acessor i guess.
03:19:27 <doomlord> maybe someone should make some 'template haskell' helper code for setting that up :)
03:19:47 <Nereid> I guess no one has felt the need to.
03:20:25 <zhulikas> there is also a possibility that doomlord is too biased as a C veteran :P
03:20:30 <Nereid> :p
03:20:39 <Nereid> how many other languages have sum types, anyway?
03:21:03 <doomlord> haskell is the first language other than ASM i've encountered where you have to think about this issue
03:21:17 <Nereid> (implying it's an issue)
03:21:18 <doomlord> <and ASM has a simple workaround for single-inheritance>
03:23:07 <zomg> I'm a php dev but I'd rather do something else :P
03:23:20 <zomg> It's just kinda hard to find anything else here...
03:23:25 <Nereid> hooray, evidence to support my claim.
03:23:55 <zhulikas> :D
03:24:04 <zomg> At least I'm the guy who's in charge of all the app coding here so I get to make the rules so I don't go crazy with shitty PHP
03:24:07 <zomg> :P
03:24:10 <zhulikas> zomg, I actually recently looked into php
03:24:16 <zhulikas> and will probably do some development with it
03:24:20 <zhulikas> crazy, isn't it :D
03:24:22 <Jafet> @protontorpedo
03:24:23 <lambdabot> where was haskell during th internet boom?
03:24:33 <merijn> mm_freak: Naah, I still like python/smalltalk style OOP
03:24:39 <zomg> It's not *bad* per-se, it just has a lot of gotchas and a lot of bad code has been written using it :P
03:24:45 <merijn> mm_freak: It's just Java/C++ OOP that is completely braindead
03:25:31 <zhulikas> zomg, any thoughts on Yii? that's what I'm using
03:26:12 <Jafet> PHP is bad per se.
03:26:14 <zomg> zhulikas: seems the creators of Yii enjoy making false claims about it
03:26:20 <zomg> This is all I know. Never used it
03:26:21 <zomg> :D
03:26:27 <zhulikas> huh
03:26:33 <zomg> Things like performance and such
03:26:37 <zhulikas> oh, ok
03:27:35 <zomg> I've been using Zend Framework with Doctrine 2 myself mostly
03:27:42 <zomg> some Symfony 2 stuff
03:27:54 <zomg> (ZF1)
03:44:49 * hackagebot rdf4h 1.0.2 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.0.2 (RobStewart)
04:07:43 <solirc> I'm looking for something that allows me to watch/wait for file changes.  Is there anything on Hackage?
04:08:55 <fmap> hinotify?
04:10:45 <solirc> fmap: I was wondering if there is something more high level, but if not, I'll probably role my own on top of hinotify.
04:13:14 <bitonic> is there a nice package with a string quasiquoter?  not necessarily with interpolation, just something to include multiline strings easily
04:15:48 <solirc> bitonic: Don't know if there is something on Hackage, just looked in some code that I wrote for that, but it does more than just quasiquoting: https://github.com/sol/vimus/blob/master/src/Command/Help.hs
04:16:24 <bitonic> solirc: yeah, I can define it myself, but I was wondering if there was a package floating around
04:17:51 <fmap> @hackage string-quote
04:17:51 <lambdabot> http://hackage.haskell.org/package/string-quote
04:17:56 <merijn> Anyone remember the correct incantation to generate lenses for multiple types using Control.Lens' makeLenses?
04:18:14 <merijn> I thought it was just "mapM makeLenses <list of types here>", but that gives an error...
04:24:45 <Kyraimion> merijn:  Just looking at the types I would assume something like concatMapM (if it existed), so maybe fmap concat . mapM makeLenses $ [type, names, here]
04:25:41 <merijn> :t mapM
04:25:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:25:48 <merijn> hmmm
04:29:52 <Nereid> :t sequence .: map
04:29:54 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
04:30:04 <Nereid> :t sequenceA .: map
04:30:05 <lambdabot> Not in scope: `sequenceA'
04:30:07 <Nereid> aw.
04:30:43 <Kyraimion> :i (.:)
04:30:47 <Kyraimion> :t (.:)
04:30:48 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
04:31:07 <merijn> I think (.:) is just fmap.fmap
04:31:09 <merijn> :t fmap.fmap
04:31:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:31:12 <ski> @type Data.Traversable.sequenceA .: map
04:31:13 <lambdabot> forall (f :: * -> *) a a1. (Applicative f) => (a1 -> f a) -> [a1] -> f [a]
04:31:17 <ciaranm> :t ((.).(.))
04:31:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
04:31:37 <Nereid> @type Data.Traversable.sequenceA .: fmap
04:31:38 <lambdabot> forall (t :: * -> *) (f :: * -> *) a a1. (Data.Traversable.Traversable t, Applicative f) => (a1 -> f a) -> t a1 -> f (t a)
04:31:47 <merijn> ciaranm: That's just because (.) == fmap in lambdabot
04:31:55 <ski> @type @let (.) = (Prelude..) in (.) . (.)
04:31:56 <lambdabot> parse error on input `@'
04:31:59 <ski> @type let (.) = (Prelude..) in (.) . (.)
04:32:01 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
04:32:01 <Nereid> @type Data.Traversable.traverse
04:32:02 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
04:32:03 <ciaranm> merijn: i know. i just like the boobies operator.
04:32:16 <merijn> This should be easy though, I remember it took just one function to generate lenses for multiple types, I just can't remember which...
04:32:26 <merijn> And of course edwardk is missing right now >.
04:32:40 <Nereid> :t Data.Traversable.traverse id
04:32:42 <lambdabot> forall (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => t (f b) -> f (t b)
04:32:45 <Nereid> :t sequence id
04:32:46 <lambdabot>     Couldn't match expected type `[m a]'
04:32:47 <lambdabot>            against inferred type `a1 -> a1'
04:32:47 <lambdabot>     In the first argument of `sequence', namely `id'
04:32:49 <Nereid> ergh
04:32:51 <Nereid> :t mapM id
04:32:52 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
04:33:04 <ciaranm> edwardk accidentally stabbed himself with a pointed functor that he thought was copointed
04:33:54 <Kyraimion> ciaranm:  Well, still better than being costabbed
04:34:44 <Nereid> I'd hate to costab edwardk
04:35:08 <Nereid> or myself for that matter
04:35:48 <Kyraimion> Maybe he is just refunctoring his bifactor
04:38:28 <Nereid> hey
04:38:38 <Nereid> I found a bool :: a -> a -> Bool -> a http://hackage.haskell.org/packages/archive/custom-prelude/0.2.2.0/doc/html/CustomPrelude.html
04:38:41 <Nereid> :D
04:39:03 <Nereid> wait
04:39:05 <Nereid> noooooooooooooo
04:39:10 <Nereid> the first argument is the True value.
04:39:11 <Nereid> noooooooo
04:39:24 <Nereid> terrible.
04:44:27 <bitonic> @type if'
04:44:28 <lambdabot> Not in scope: `if''
04:44:31 <bitonic> @type ite
04:44:32 <lambdabot> Not in scope: `ite'
04:44:39 <bitonic> I'd expect caleskell to have that :P
04:44:51 * hackagebot sundown 0.5.0.1 - Bindings to the sundown markdown library  http://hackage.haskell.org/package/sundown-0.5.0.1 (FrancescoMazzoli)
04:44:54 <Nereid> @let bool f t b = if b then t else f
04:44:56 <lambdabot>  Defined.
04:45:23 <Nereid> @type flip (bool (return ()))
04:45:25 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:46:19 <akosch> anyone compiled ghc-core with 7.6.*?
04:46:33 <Nereid> @type flip (maybe (return ()))
04:46:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> (a -> m ()) -> m ()
04:46:43 <Nereid> @type flip (either return)
04:46:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => Either a b -> (b -> m a) -> m a
04:46:51 <Nereid> hmm
04:47:02 <Nereid> @type bool id
04:47:03 <lambdabot> forall a. (a -> a) -> Bool -> a -> a
04:48:45 <Nereid> @type bool (const Nothing) Just
04:48:46 <lambdabot> forall b. Bool -> b -> Maybe b
04:49:03 <Nereid> bool is fantastic.
04:49:19 <Nereid> @type bool Left Right
04:49:20 <lambdabot> forall a. Bool -> a -> Either a a
04:49:23 <Nereid> heh.
04:49:59 <Nereid> @type (,) :: Bool -> (Bool,a) -- equivalent to above under (Bool,a) ~= Either a a
04:50:00 <lambdabot>     Couldn't match expected type `(Bool, a)'
04:50:00 <lambdabot>            against inferred type `b -> (Bool, b)'
04:50:01 <lambdabot>     In the expression: (,) :: Bool -> (Bool, a)
04:50:05 <Nereid> er
04:50:12 <Nereid> Bool -> a -> (Bool,a) duh.
04:51:36 <schlicht> Is there a parser libary that can handle ambiguity well?
04:51:47 <Nereid> @type either f g
04:51:48 <lambdabot> forall a c b. (Show a, SimpleReflect.FromExpr c, Show b) => Either a b -> c
04:52:02 <Nereid> > either f g x
04:52:03 <lambdabot>   Couldn't match expected type `Data.Either.Either a b'
04:52:03 <lambdabot>         against infer...
04:52:05 <Nereid> > either f g (Left x)
04:52:06 <lambdabot>   Ambiguous type variable `c' in the constraints:
04:52:06 <lambdabot>    `GHC.Show.Show c'
04:52:07 <lambdabot>      a...
04:52:11 <Nereid> oh come on.
04:52:24 <Nereid> > Left x
04:52:25 <lambdabot>   Left x
04:52:32 <Nereid> > f x
04:52:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:52:33 <lambdabot>    `GHC.Show.Show a'
04:52:33 <lambdabot>      a...
04:52:39 <Nereid> > f a
04:52:40 <lambdabot>   Ambiguous type variable `a' in the constraints:
04:52:40 <lambdabot>    `GHC.Show.Show a'
04:52:40 <lambdabot>      a...
04:52:44 <Nereid> I thought this worked.
04:52:49 <Nereid> > iterate f x
04:52:51 <lambdabot>   [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (...
04:52:55 <Nereid> what gives.
04:52:58 <Nereid> > [f x]
04:52:59 <lambdabot>   Ambiguous type variable `t' in the constraints:
04:52:59 <lambdabot>    `GHC.Show.Show t'
04:52:59 <lambdabot>      a...
04:55:26 <fmap> > f a :: Expr
04:55:28 <lambdabot>   f a
04:57:25 <Nereid> oh ok.
04:57:30 <Nereid> > either f g (Left x) :: Expr
04:57:31 <lambdabot>   f x
04:57:55 <Nereid> > repeat f :: Expr
04:57:57 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
04:57:57 <lambdabot>         against inferred ...
04:58:01 <Nereid> er no.
04:58:03 <Nereid> > fix f :: Expr
04:58:04 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
04:58:08 <Nereid> hehehe.
05:00:12 <merijn> Nereid: Wouldn't it be
05:00:17 <merijn> > repeat f :: [Expr]
05:00:18 <lambdabot>   [f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,f,...
05:00:29 <Nereid> merijn: I meant fix, not repeat.
05:00:30 <Nereid> :p
05:00:43 <Nereid> it's late.
05:10:02 <ski> @pl \condition consequent alternate -> if condition then consequent else alternate
05:10:02 <lambdabot> if'
05:10:24 <Nereid> @pl \f t b -> if b then t else f
05:10:24 <lambdabot> flip (flip . flip if')
05:10:29 <Nereid> @type if'
05:10:31 <lambdabot> Not in scope: `if''
05:10:34 <Nereid> dumb
05:11:01 <Nereid> @type Control.Conditional.if'
05:11:03 <lambdabot> Couldn't find qualified module.
05:11:11 <Nereid> hmm
05:11:16 <b__> it's a lambdabot-specific function I think
05:11:30 <Nereid> moreover it's pl-specific, it seems.
05:11:35 <ski> yes
05:11:38 <Jafet> @pl \b t f -> [t, f] !! fromEnum b
05:11:39 <lambdabot> flip (flip . ((!!) .) . (. return) . (:)) . fromEnum
05:11:44 <Nereid> disgusting.
05:11:53 <Nereid> Jafet: besides, that's wrong.
05:11:59 <Nereid> > fromEnum False
05:12:00 <lambdabot>   0
05:12:24 <b__> wouldn't a "complete" FP language _always_ generate concise PF code? (random question)
05:12:36 <b__> or well not generate
05:12:37 <Jafet> @let if' = flip (flip . ((!!) .) . flip (:) . return) . fromEnum
05:12:39 <lambdabot>  Defined.
05:12:39 <b__> but facilitate
05:12:45 <Nereid> noo
05:12:50 <Nereid> > if' True True False
05:12:51 <lambdabot>  Terminated
05:12:55 <Nereid> what.
05:12:56 <Nereid> > if' True True False
05:12:57 <lambdabot>   True
05:13:00 <Nereid> oh ok
05:13:06 <Nereid> oh you changed it
05:13:37 <Nereid> it would be nice if we could @src things which were @let
05:13:53 <Nereid> @type if'
05:13:54 <lambdabot> forall a1 a. (Enum a1) => a1 -> a -> a -> a
05:13:59 <Nereid> oh boy.
05:14:04 <Nereid> > if' 2 True False
05:14:06 <lambdabot>   *Exception: Prelude.(!!): index too large
05:14:53 <Nereid> hmm, I guess fromEnum is why we can't have derived Enum instances.
05:15:01 <Nereid> shame
05:15:44 <quicksilver> Nereid: what do you mean "we can't have derived Enum instances" ?
05:16:12 <Nereid> I can't write data Foo = L | R Bool deriving (Enum), say.
05:16:23 <Nereid> although it has a perfectly reasonable Enum instance.
05:16:45 <Nereid> in which map toEnum [0,1,2] = [L, R False, R True]
05:16:52 * quicksilver nods
05:16:58 <quicksilver> I think they just couldn't be bothered to write it.
05:17:10 <quicksilver> I think other people have written that derivation.
05:17:11 <Nereid> no, I think there's an actual problem.
05:17:28 <Nereid> fromEnum ought to be injective, right? how should we give an Enum instance to Either Int Int?
05:17:40 <quicksilver> you can't
05:17:46 <Nereid> indeed
05:17:48 <quicksilver> you would deriving the instance for only finite types.
05:17:59 <Nereid> fine
05:18:13 <quicksilver> but you can do better than the current situation which is only simple finite types
05:18:27 <quicksilver> this is disjoin from the problem than Enum is a stupid class
05:18:27 <Nereid> but succ, pred, enumFrom* work just fine for Either Int Int.
05:18:34 <Nereid> it's only to/fromEnum that are problematic.
05:18:40 <quicksilver> or a couple of sensible ideas mashed together into a stupid class
05:18:46 <Nereid> heh
05:19:21 <quicksilver> there is no 'natural' succ for Either Int Int which lets you traverse the whole type
05:19:30 <Nereid> who said it had to?
05:19:36 <quicksilver> you have to choose between a natural one which doesn't give you traversal
05:19:47 <quicksilver> Nereid: the word "enumerable" presumably.
05:19:53 <Nereid> heh.
05:20:05 <quicksilver> ...and an an-natural one which does traverse it
05:20:10 <quicksilver> at least, if you are allowed to use 'pred' as well
05:20:12 <Nereid> well succ doesn't let you traverse all of Int either.
05:20:13 <Nereid> or enumerate.
05:20:20 <quicksilver> indeed
05:20:23 <Nereid> yeah fine, if you allow pred.
05:20:25 <quicksilver> it's all a can of pants.
05:20:30 <Nereid> what's a can of pants :v
05:20:48 <quicksilver> something unsatisfactory and also daft.
05:20:54 <quicksilver> and a bit british.
05:21:18 <Nereid> I'm not british.
05:21:58 <merijn> Nereid: No one blames you for that :)
05:22:07 <merijn> Well, maybe a little :>
05:22:59 <Nereid> speaking of not being british, I've stayed up far too late, bye
05:23:02 <jip_> quick question: i have a function primes and primePairs, they both work and generate infinite lists, now i want to edit the function primePairs to only generate only pairs that contain primes smaller than argument n, like so: http://pastebin.com/cxL3kpxY, this gives me correct results but somehow also an exception about Non-exhaustive patterns in function pairs
05:23:08 <maukd> The paste cxL3kpxY has been copied to http://hpaste.org/76603
05:23:32 <jip_> i really don't understand what's going on, and i've been at it for a while.. probably a super obvious problem for a veteran haskell coder :) any help much appreciated
05:23:44 <quicksilver> jip_: the error is at the end of the list.
05:23:55 <quicksilver> x:y:xys will only match on a list with at least 2 elements
05:24:01 <merijn> jip_: Duh, pairs crashes when the list has less than 2 elements :p
05:24:10 <quicksilver> once you get to the last element, that function will crash
05:24:28 <jip_> yes, i figured it would be something like that, how do i avoid this problem? (i am about a week fresh into haskell ;p)
05:24:46 <mcstar> i wouldnt call it a crash, does what it was supposed to do
05:24:56 <merijn> jip_: The "Non-exhaustive pattern" warning means "there is a pattern that could occur that you are not dealing with"
05:25:04 <jip_> ah
05:25:10 <merijn> jip_: You need to add a case to pairs that deals with lists of less than 2 elements
05:25:47 <merijn> jip_: Presumably something like "pairs _ = []" which returns the empty list for all inputs with 1 or 0 elements
05:27:42 <jip_> awesome, that did the trick, thanks for the quick help guys :) haskell can be daunting for an imperative newbie like me
05:30:56 <merijn> jip_: Unless you're 110% sure what you're doing "non-exhaustive pattern" is always a very big red flag saying "you forgot something!"
05:31:55 <jip_> merijn: good to know :)
05:32:03 <mcstar> if a pattern cannot appear, i still write it, and put an error at rhs with some witty message
05:32:55 <yaxu> I don't suppose anyone has any thoughts about my post to haskell-cafe "testing if values can be applied to polymorphic functions"? http://www.haskell.org/pipermail/haskell-cafe/2012-October/104055.html
05:34:36 <merijn> mcstar: Same here, that way I at least know where the error is caused :)
05:35:42 <mcstar> i think you could do that with the preprocessor
05:36:03 <int-e> yaxu: Typeable only works for concrete types. AFAIK there is no encoding of polymorphic types at runtime.
05:36:04 <mcstar> with the C preprocessor, there is a token that stands for the line number i think
05:36:19 <mcstar> merijn: do you know if the same holds for haskell?
05:36:40 <merijn> mcstar: Well, you could always enable the CPP extension and use the CPP token :p
05:36:50 <mcstar> ah
05:38:13 <aleator> Has anyone here used hlint for teaching?
05:38:36 <mcstar> yaxu: after a minute i realized i need to put on my earplugs
05:39:41 <mcstar> or earbud..., where the sound comes frome
05:43:13 <mcstar> haskell's new motto: if it typechecks, it sounds good
05:44:00 <yaxu> int-e: OK, thanks
06:12:32 <mm_freak> merijn: python-style OO is even worse, because it's basically the most non-static form of programming you can get
06:12:46 <mm_freak> smalltalk-style OO may be fine, since we're using it anyway through Control.Concurrent
06:12:46 <CzokNorris> hi, can anybody tell me, why my compiler doesnt accept this: sum_max_sq :: Integer -> Integer -> Integer -> Integer
06:12:47 <CzokNorris> sum_max_sq x y z = if x <= y || x <= z then y*y+z*z
06:13:07 <mm_freak> but smalltalk-style OO is a concept for concurrency, not for generic problem solving or application design
06:13:35 <mm_freak> CzokNorris: what if it's false?
06:13:50 <CzokNorris> mm_freak:  good questin
06:13:55 <mm_freak> ;)
06:14:01 <CzokNorris> ok, thx mm_freak
06:14:06 <mm_freak> that's why the compiler doesn't accept it
06:15:00 <mroman> Haskell needs else.
06:15:02 <mroman> or else.
06:15:20 <mm_freak> CzokNorris: as a syntactical note, you may want to use guards there
06:15:35 <mcstar> he didnt say it was haskell, btw
06:15:40 <mcstar> he said it was his compiler
06:15:49 <mm_freak> sumMaxSq x y z | x <= y || x <= z = y^2 + z^2
06:15:57 <mm_freak> | otherwise = whateverElse
06:16:35 <CzokNorris> hmm… I am going to figure out how this guards work, now
06:17:11 <clahey> The guard function is totally different than the concept of guards, right?
06:17:29 <mcstar> @hoogle guard
06:17:29 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
06:17:29 <lambdabot> Language.Haskell.TH.Syntax data Guard
06:17:29 <lambdabot> Language.Haskell.TH data Guard
06:17:36 <mm_freak> clahey: yes
06:17:47 <mm_freak> clahey: the 'guard' function is about monadic guards
06:18:01 <merijn> clahey: Depending on your definition of "totally different", yes :)
06:18:01 <mcstar> why would it be totally different?
06:18:12 <clahey> Not directly related.
06:18:14 <mm_freak> > do x <- [1..10]; guard (even x); [x, x+1]
06:18:16 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
06:18:17 <clahey> They are both parts of haskell.
06:19:01 <mcstar> @src guard
06:19:02 <lambdabot> guard True  =  return ()
06:19:02 <lambdabot> guard False =  mzero
06:19:06 <mm_freak> the guard function generalizes the idea of guards in a list comprehension
06:19:12 <merijn> clahey: There's a conceptual similarity in that both are used to precondition something on a boolean condition being true
06:19:21 <mm_freak> > [ x^2 | x <- [1..10], even x ]
06:19:23 <lambdabot>   [4,16,36,64,100]
06:19:37 <mm_freak> > do x <- [1..10]; guard (even x); return (x^2)
06:19:38 <lambdabot>   [4,16,36,64,100]
06:19:48 <mm_freak> just that 'guard' works for other monads as well =)
06:19:50 <clahey> Got it.
06:19:59 <clahey> Oh.
06:20:05 <clahey> I could use it for a parser.
06:20:10 <mm_freak> yes
06:20:16 <clahey> To check that variable names match.  Interesting.
06:20:40 <mm_freak> although it's often easier to use if/empty explicitly
06:20:44 <clahey> To check that a variable is in scope, for example.
06:20:49 <clahey> mm_freak: Why easier?
06:21:23 <mm_freak> because 'guard' doesn't compose very well
06:21:54 <mm_freak> empty and (<|>) compose much better
06:22:05 <mm_freak> also it's often syntactically more pleasing
06:22:08 <mm_freak> | otherwise = empty
06:22:09 <mcstar> theres also ifM
06:22:10 <Kyraimion> :t empty
06:22:11 <lambdabot>     Ambiguous occurrence `empty'
06:22:11 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
06:22:11 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
06:22:42 <clahey> One advantage I see to being explicit is that I can specify the error message.
06:22:50 <clahey> fail "whatever" instead of mzero.
06:23:14 <Kyraimion> clahey:  fail is an ugly hack, I'd avoid it
06:23:48 <Kyraimion> > fail "bla" :: Maybe Int
06:23:49 <lambdabot>   Nothing
06:24:06 <Kyraimion> And depending on the monad it ignores it's argument anyway
06:24:20 <clahey> Kyraimion: I'm aware of the things it lacks, but in the parser monads, it's quite useful.
06:24:27 <clahey> If there's something better, please let me know.
06:25:34 <clahey> Another lack is that in many cases it just calls error.
06:26:43 <clahey> Kyraimion: Is there something better for that usage?
06:26:54 <Kyraimion> clahey:  Parsec has parserFail
06:27:08 <clahey> if (whatever) return otherwhatever else fail "Whatever error message"
06:27:27 <maukd> when whatever $ fail "err"
06:27:29 <Kyraimion> clahey:  Parsec's fail is just parserFail, so I would use that directly
06:27:29 <maukd> return x
06:27:37 <maukd> Kyraimion: I wouldn't
06:28:45 <clahey> Kyraimion: But if I use parserFail, then when I switch to another parser monad, I'll have to change that code.
06:29:09 <clahey> Also, I'm not currently using parsec, but trifecta probably has something similar.
06:31:20 <clahey> Actually, it doesn't appear to.
06:33:06 <clahey> maukd: Hmm.  I sorta wish I could do it without do notation or lambdas, but I don't think it's possible using when in the way you've described.
06:33:35 <mm_freak> clahey: don't use 'fail', just never use it
06:33:35 <Kyraimion> clahey:  The trifecta parser is an instance of MonadError, so you could use throwError
06:33:40 <mm_freak> for a parser use (<?>) instead
06:33:44 <clahey> maukd: But apparently, I'm already in do notation, so I'll use your way as I like it better than my if statement.
06:33:49 <mm_freak> myParser <?> "my error message if it fails"
06:34:23 <mm_freak> or rather "what was expected and the input string failed to provide"
06:34:25 <Kyraimion> clahey:  Or just mzero and annotate the parser
06:35:13 <mm_freak> also, i'd avoid the arbitrary MonadPlus class and go for Alternative instead
06:35:29 <mm_freak> i.e. use 'empty' instead of 'mzero' and (<|>) instead of 'mplus'
06:36:09 <clahey> throwError is closer to what I want, though I have to look into it a bit more.
06:36:31 <clahey> <?> "a name other than xmlns" isn't a very good error message.
06:36:38 <clahey> expected: a name other than xmlns.
06:36:40 <clahey> I don't think so.
06:39:31 <notdan> http://hackage.haskell.org/package/obdd does anyone have any experience with this package?
06:41:13 <Polarina> mm_freak, any news? :)
06:42:17 <clahey> I'll try throwerror next time I'm not at work to see if it works as well as fail, and if so, perhaps I'll switch.
06:44:16 <monad_magician> hello
06:45:05 <monad_magician> is there a function that recursively applies itself, stopping when it reaches a fixed point?
06:45:51 <maukd> first off, the "itself" part makes no sense
06:46:23 <maukd> :t \f -> iterate f
06:46:25 <lambdabot> forall a. (a -> a) -> a -> [a]
06:46:25 <monad_magician> let f x = (f . f) x
06:46:33 <maukd> no, that still makes no sense
06:46:35 <monad_magician> let f x = (f . f) x in (+1)
06:46:44 <monad_magician> let f x = (f . f) x in f (+1)
06:46:51 <maukd> :t \f -> ap zip tail . iterate f
06:46:52 <lambdabot> forall b. (b -> b) -> b -> [(b, b)]
06:46:52 <monad_magician> > let f x = (f . f) x in f (+1)
06:46:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
06:46:54 <lambdabot>    arising from a use of `...
06:47:11 <monad_magician> ah right
06:47:25 <maukd> :t \f -> dropWhile (uncurry (/=)) . ap zip tail . iterate f
06:47:26 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> [(a, a)]
06:47:27 <troydm> monad_magician: well if there is no such func why don't you write yourself
06:47:37 <maukd> :t \f -> fst . head . dropWhile (uncurry (/=)) . ap zip tail . iterate f
06:47:38 <lambdabot> forall a. (Eq a) => (a -> a) -> a -> a
06:48:29 <maukd> > (\f -> fst . head . dropWhile (uncurry (/=)) . ap zip tail . iterate f) (/ 4) 1
06:50:43 <lambdabot>   0.0
06:50:43 <mcstar>    o.O
06:53:56 <clahey> > (\f -> fst . head . dropWhile (uncurry (/=)) . ap zip tail . iterate f) (const 5) 7
06:53:58 <lambdabot>   5
06:54:22 <clahey> maukd: Any reason that isn't in the libraries somewhere?  That's a fantastically useful function.
06:55:19 <maukd> clahey: I've never needed it
06:55:52 <clahey> maukd: I was reading about sudoku solvers yesterday, and it seems like that would be a super useful function.
06:55:58 <Nereid> can we have such a thing like a constrained monad?
06:55:59 <Nereid> like say
06:56:22 <Nereid> class ConstrainedMonad (c :: * -> Constraint) (m :: * -> *)
06:56:53 <Nereid> uh
06:56:56 <Nereid> idk what I'm doing.
06:57:13 <Nereid> ok just Constraint, not * -> Constraint
06:57:24 <Nereid> so we can have stuff like instance ConstrainedMonad (Monoid a) ((,) a)
06:58:03 <GnomeStoleMyBike> hi All
06:58:05 <GnomeStoleMyBike> @nixon
06:58:05 <lambdabot> A public man must never forget that he loses his usefulness when he as an individual, rather than his policy, becomes the issue.
06:58:09 <Nereid> class ConstrainedMonad (c :: Constraint) (m :: * -> *) where
06:58:17 <Nereid> return :: c => a -> m a
06:58:23 <GnomeStoleMyBike> you guys used Network.AMQP ?
06:58:25 <Nereid> join :: c => m (m a) -> m a
06:58:27 <GnomeStoleMyBike> is it good and solid ?
06:58:52 <Nereid> instance ConstrainedMonad (Monoid a) ((,) a) where
06:59:02 <Nereid> return = (mempty,)
06:59:08 <Nereid> join (a,(b,c)) = (a <> b,c)
06:59:09 <Nereid> etc.
06:59:30 <Nereid> could be cool
07:01:26 <Nereid> ugh I need to get 7.6.1 on here
07:02:23 <fmap> Nereid: wouldn't that be annoying since you need to specify types all the time?
07:02:36 <Nereid> types?
07:03:01 <fmap> yeah, for ghc to select right instance
07:04:22 <Nereid> how so
07:04:26 <Nereid> oops someone already did this.
07:09:07 <t7> > 0x1000
07:09:08 <lambdabot>   4096
07:10:24 <saml> let's talk about stuff cause i'm bored
07:10:36 <saml> i mean haskell stuff
07:10:49 <t7> > 0x100
07:10:50 <lambdabot>   256
07:10:55 <t7> i can math
07:15:19 <saml> t7, 0xXXX is hex
07:16:35 <t7> i think you'll find hex is 0-F
07:17:38 <ski> Nereid : why not just `instance Monoid m => Monad ((,) m)' ?
07:17:55 <Nereid> because uh that's not the example I had in mind.
07:18:22 <ski> what is the example you had in mind ?
07:18:45 <Nereid> except your question probably applies to that example to.
07:18:45 <Nereid> o
07:20:18 <Nereid> haha, yeah I had it all wrong.
07:20:36 <Nereid> class CMonad (c :: * -> Constraint) (m :: * -> *) where creturn :: c a => a -> m a; ...
07:24:20 <Nereid> but this has already been done.
07:24:58 <Sculptor> o/
07:25:05 <Nereid> in like http://blog.omega-prime.co.uk/?p=127
07:27:55 <klr> what's "Ord"?
07:28:11 <ski> a type class
07:28:11 <saml> it's a typeclass
07:28:16 <saml> @info Ord
07:28:17 <lambdabot> Ord
07:28:18 <klr> what's a typeclass?
07:28:25 <saml> it's a class of types
07:28:37 <startling> klr, it's a way to have functions that do different things depending on the types involved
07:28:41 <klr> hmm, class as in , mage, warrios etc.?
07:28:54 <ski> `Ord' contains the types which have the operations `(<=)',`(<)',`(>)',&c. defined
07:29:00 <startling> klr, Ord lets you write (>) and (<) for any ordered type
07:29:18 <klr> i have to read the chapter again, now my mom is forcing me to do homework, ill be back layer
07:29:20 <mux> :i Ord
07:29:24 <mux> in ghci
07:29:27 <klr> s/layer/later
07:32:24 <monad_magician> http://ideone.com/xeQqkj anyone want to criticize my code? ^^
07:32:37 <monad_magician> I have a C implementation of the same thing for comparison (it's about 1k lines ^^)
07:32:47 <monad_magician> the C version is quite faster though :(
07:34:24 <mcstar> it is simply bad code, id hide it
07:34:30 <monad_magician> :(
07:34:35 <monad_magician> I'm still learning haskell
07:34:55 <mcstar> gave a free pass at criticising it! i havent look at it
07:34:58 <mcstar> you*
07:35:03 <monad_magician> ah
07:35:20 <monad_magician> I'll paste the C version
07:36:15 <monad_magician> http://ideone.com/eMTbBQ C version
07:36:32 <monad_magician> the C version does a little bit more/less
07:36:44 <monad_magician> How do I parse an Int from the command line args?
07:36:51 <Cale> monad_magician: one thing which I would suggest is to try to avoid head and tail in general. You'd much prefer to pattern match on structures.
07:37:17 <monad_magician> so I use the x:xs pattern over (head foo)
07:37:31 <Cale> yeah
07:38:03 <monad_magician> pattern matching ftw
07:39:30 <Cale> windLeft (Tape (l:ls) x rs b) = Tape ls l (x:rs) b
07:39:57 <Cale> (or you can write that using record syntax if you prefer, the pattern matching is what helps it most)
07:40:16 <Cale> You can also immediately tell from this that it's the case of the left list being empty which is not handled
07:41:03 <monad_magician> :( right
07:41:24 <Cale> I'm not sure whether the blank symbol should really be part of this structure or not
07:41:27 <rwbarton> you can also immediately tell what the function does :P
07:42:12 <monad_magician> I put the blanksymbol as a hack, to eventually be able to show the touched parts of the infinite tape
07:43:28 <Cale> You could also take the blank symbol as a parameter to windLeft, for instance, and use it to handle the empty case
07:43:54 <Cale> windLeft :: a -> Tape a -> Tape a
07:44:11 <mcstar> what are those primed top level definitions? they seem weird
07:44:25 <Cale> windLeft b (Tape [] x rs) = Tape [] b (x:rs)
07:44:25 <startling> does it sound like a good idea to use a phantom type to mark which types of things need 256-color terminal support for my curses thing?
07:46:35 <Cale> startling: It could be a reasonable option...
07:46:58 <mcstar> ((A, ZERO), (ONE, LEFT, B)) also, id change this to constructors taking parameters, like a A takes Zero, and Left takes a B One
07:47:16 <Cale> startling: Though if you carry that to its logical completion, you end up with all the termcaps in the type system and it starts to look a bit weird :)
07:47:58 <startling> Cale: heh. I was thinking of just doing mono/8-color/256-color
07:48:35 <clahey> and windLeft b (Tape (l:ls) x rs) = Table ls l (x:rs)
07:48:39 <clahey> So prett
07:48:41 <clahey> pretty.
07:48:52 <clahey> You could also do this:
07:48:56 <monad_magician> right
07:49:25 <startling> clahey, what's 'b' for?
07:49:39 <clahey> startling: The blank value as Cale described.
07:49:52 <clahey> startling: But you don't need it if there's something there on the tape.
07:50:15 <clahey> You could also do:
07:50:22 <startling> oh, I see what you mean
07:50:41 <clahey> class HasBlank a where blank :: a
07:51:04 <clahey> data HasBlank a => Tape a = Tape ...
07:51:15 <startling> clahey, you could use Monoid / mempty
07:51:35 <clahey> Then windLeft (Tape [] x rs) = Tape [] blank (x:rs)
07:52:00 <clahey> startling: True, but I don't see why you would.
07:52:05 <clahey> Oh, you could use Maybe a.
07:52:14 * killy9999 is learning FFI
07:52:21 <startling> clahey, lots of reasonable instances already made
07:52:38 <clahey> startling: Since you aren't gonna use mappend anywhere, it's a waste to define mappend on the class that you're going to define.
07:52:38 <killy9999> If a C function returns Ptr Double, how do I convert it to [Double] ?
07:52:51 <startling> clahey: sure
07:52:55 <rwbarton> peekArray
07:52:55 <startling> killy9999: peekArray
07:53:01 <clahey> Sorry, on the type that you're going to define.
07:53:02 <t7> is there anything like enum i can use on ADT? i just wanna tag each constructor for writing to binary
07:53:11 <clahey> killy9999: Do you know the length too?
07:53:24 <killy9999> clahey: yes
07:53:39 <startling> killy9999: yep, peek array
07:53:50 <clahey> startling: And in particular, in this case, TuringSymbol is an Enum with 3 values, so you would need to define mappend in that case.
07:53:50 <startling> er, peekarray
07:53:59 <killy9999> OK
07:53:59 <startling> clahey: fair enough
07:54:20 <startling> clahey: usually when you have an empty, though, you have a function that it's empty for.
07:54:56 <killy9999> continuing: the reason I'm doing C bindings is for performance, so it doesn't seem smart to convert a result to a lazy list
07:55:06 <killy9999> is there a better solution?
07:55:11 <rwbarton> personally I would prefer the original Tape to all these suggestions
07:55:16 <killy9999> perhaps convertion to ByteString or sth like that?
07:55:22 <clahey> monad_magician: Why do you have a blank symbol at all?
07:55:26 <startling> killy9999, you can do a data FiveDouble = { a, b, c, d, e :: Double } I guess
07:55:27 <rwbarton> killy9999: vector?
07:55:34 <clahey> rwbarton: The one that's there currently?
07:55:38 <rwbarton> yes
07:55:40 <startling> or yeah, a vector
07:55:47 <monad_magician> http://ideone.com/w5kRAD updated; turnss out I don't need record syntax ^^
07:55:52 <killy9999> rwbarton: vector is fine, providing its unboxed
07:56:07 <rwbarton> vector has pretty much everything imaginable
07:56:13 <monad_magician> clahey: I need a way to find out when to stop taking symbols from the infinite list in order to show the touched parts ^^
07:57:22 <rwbarton> killy9999: it sort of depends on what you want to do with the doubles
07:57:50 <clahey> monad_magician: Does it count as touched when the object becomes head or only when you do a write?
07:57:59 <rwbarton> obviously the cheapest/most universal thing is to just return the Ptr Double for the client to do with as they see fit
07:58:23 <monad_magician> clahey: when the object becomes head ^^
07:58:39 <clahey> monad_magician: In that case, just print the whole list.
07:58:55 <clahey> Something is blank if it has never been head, right?
07:59:18 <monad_magician> ah right
07:59:26 <killy9999> rwbarton: let's say I want to convert them to some native Haskell container
07:59:27 <clahey> So it never gets added to the list.
07:59:34 <monad_magician> how do I break a long string literal into multiple lines?
07:59:37 <clahey> You can toss out a ton of code.
07:59:40 <killy9999> so fro example pack them into unboxed vector for later processing
08:00:06 <clahey> monad_magician: You still need a bs, but it can just be ZERO.
08:00:09 <clahey> monad_magician: What is ds?
08:00:09 <rwbarton> sure
08:00:16 <killy9999> I'm looking at the docs, but I must admit that all this different pointer types like Ptr and ForeignPtr confuse me :/
08:00:17 <ski> > "like\n\    \this"  -- monad_magician
08:00:18 <lambdabot>   "like\nthis"
08:00:26 <monad_magician> clahey: the default symbol to overwrite the blank symbol ^^
08:00:54 <killy9999> is there a O(1) function that just packs Ptr Double into a vector?
08:00:57 <jake532> any one know c++ here?
08:01:05 <monad_magician> jake532: I know a little ^^
08:01:23 <clahey> monad_magician: Ah, so you don't need bs, just ds.
08:01:40 <ski> jake532 : perhaps you want to `/join ##c++' ?
08:01:51 <rwbarton> killy9999: well you should think a bit about ownership of the memory that is being returned
08:02:15 <rwbarton> did the C function allocate it? if so how are you supposed to free it? how are you going to make sure that it gets freed at an appropriate time?
08:02:26 <killy9999> hm...
08:02:30 <clahey> ski: It's overflow limited.
08:02:30 <rwbarton> that is the problem that ForeignPtr solves
08:02:36 <killy9999> I have two design choices in my C function
08:03:05 <killy9999> 1) operate in situ on an array that was passed to a function, but I guess that this is not a good idea since it breaks referential transparency
08:03:09 <ski> clahey ?
08:03:11 <killy9999> so I'm left with
08:03:21 <killy9999> 2) allocate the memory in C using malloc
08:03:43 <clahey> ski: ##c++
08:03:58 <rwbarton> well C functions are not expected to be referentially transparent
08:04:02 <clahey> ski: Not that that makes this an appropriate place to ask such questions.  :)
08:04:03 <ski> clahey : i fail to see the relevance
08:04:27 <killy9999> rwbarton: not expected == don't have too ?
08:05:01 <killy9999> I mean if I overwrite the array passed to C function won't this cause problems during the runtime in my original code?
08:05:02 <clahey> monad_magician: Actually, I think your current code never uses bs.
08:05:22 <ski> killy9999 : depends on where the array comes from, and who else knows about it
08:05:45 <clahey> monad_magician: Cool thing to write, btw.
08:05:46 <killy9999> hm... a different question would be how to retrieve a result from such an array
08:05:47 <rwbarton> well if you choose to wrap up some chunk of memory in a vector and hand it off to people, then yes it is your responsibility to make sure you don't pass the same chunk of memory to a C function that mutates it
08:05:50 <killy9999> ST monad?
08:06:18 <startling> is there a way I can make ghci re-compile hsc2hs things?
08:06:34 <startling> ooh, I could make C-c C-l in haskell-mode recompile and load the compiled one
08:06:47 <killy9999> no, I guess I'll stick with allocating new array in my C function
08:06:56 <killy9999> this seems easier
08:07:07 <Cale> killy9999: Perhaps 3) Do what you'd do in Haskell and use a tree structure, so that you only have to allocate a new version of the path from the root to the modified element, and share subtrees otherwise.
08:07:07 * ski wonders whether the FFI supports importing with result in `ST'
08:07:09 <rwbarton> you can also allocate an "output" array in haskell and pass it to C
08:07:53 <Cale> (though C makes manipulating data structures generally a chore)
08:07:59 <monad_magician> http://ideone.com/uSCwld I eliminated the blank symbol, but why doesn't this compile? :(
08:08:23 <rwbarton> using mallocForeignPtrArray, then the memory lifetime issues will be taken care of automatically
08:08:29 <killy9999> Cale: my function modifies every element in the array, so I';m not sure if that would be a good idea
08:08:45 <Cale> killy9999: ah, in that case, not much you can do
08:09:08 <Cale> monad_magician: you want error ("..." ++ show n)
08:09:30 <Cale> monad_magician: the way you have it, it's like  (error "...") ++ (show n)
08:09:42 <rwbarton> ski: I guess you would just use unsafeIOToST
08:09:45 <monad_magician> right
08:09:52 <monad_magician> Ill just throw a $ in there
08:10:04 <Cale> that'll work
08:10:14 * killy9999 sighs
08:10:22 <killy9999> guess I should begin with RWH
08:10:45 <killy9999> I thought I could figure all of this with apidoc but I guess not
08:10:54 <killy9999> one more stupid question
08:11:01 <Cale> killy9999: Are you reading the Haddock, or the FFI spec?
08:11:06 <killy9999> haddock
08:11:10 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
08:11:13 <Cale> you might try this
08:11:19 <killy9999> yeah, I know about it
08:11:31 <killy9999> though I only looked at TOC
08:12:04 <clahey> monad_magician: In the second match for cycle, you never use m without one of the accessors.  What about:
08:12:04 <Cale> It's a bit more readable as a tutorial than the rest of the Report
08:12:05 <saml> i have a binary tree, how can I fold tail recursively?  is it possible?
08:12:27 <Cale> saml: What does that mean?
08:12:29 <clahey> cycle state tape ttable = ...
08:12:39 <killy9999> Cale: OK, I'll give it a try
08:12:49 <killy9999> one more question
08:13:04 <saml> f (Node left right value) acc = f left acc; f right acc;  acc + value
08:13:11 <clahey> monad_magician: And then you can get rid of the record syntax there as well.
08:13:21 <killy9999> where should I place my c file containing the function? In the same directory as the hs file calling it?
08:13:42 <mm_freak> Polarina: not so far, i will notify you
08:14:01 <monad_magician> right
08:14:30 <startling> oops, killed the type-checker
08:15:12 <Cale> saml: what do you mean by ';' there? Just discard the result of f left acc?
08:15:44 <saml> Cale, i meant  to execute  f left acc first.  then f right acc secondly.   then finally  add value to updated acc
08:16:06 <saml> let x = f left acc;  y = f right acc in   x + y + value
08:16:15 <saml> is that tail recursive?
08:16:20 <ski> no
08:16:22 <Cale> well, no
08:16:34 <saml> so.. that's the question. is it possible to write it tail recursively?
08:16:39 <clahey> saml: No.
08:16:50 <clahey> saml: Well, you can write it half tail recursively.
08:16:54 <saml> so tree iteration can blow up memory
08:17:05 <saml> but tree depth is log n. so i don't have to worry  about it?
08:17:17 <Cale> Well, because addition is associative, you can flatten the tree.
08:17:18 <ski> saml : i'm not sure why you pass `acc' to both recursive calls
08:17:22 <clahey> saml: There's no way to avoid a stack when you're working with a tree.
08:17:30 <Cale> yeah, what's acc doing here?
08:17:35 <Eduard_Munteanu> Or a queue, if you're doing it breadth-first.
08:17:45 <Cale> Is it the value you're summing for each node of the tree?
08:17:51 <saml> yah
08:17:52 <clahey> Cale, ski, saml: Were you expecting that acc would be updated inside of f left acc?
08:18:15 <Cale> so f t 1 would give the size of t, and f t 2 would give twice that size?
08:18:19 <ski> clahey : maybe -- mostly just trying to find out *which* function saml want to write
08:18:25 <clahey> ski: Right.
08:18:42 <Cale> clahey: I'm going to say no :)
08:18:45 <saml> given a tree, t,  I want to get sum of values of each node.
08:18:46 <Polarina> mm_freak, all right. Let me know how I can help. :)
08:18:56 <ski> saml : perhaps you have some specific task which you'd like to write using this `f' function ?
08:18:57 <clahey> Cale: I'm not asking if you thought it would update.  I was curious if that's what saml thought.
08:19:00 <Cale> saml: See, this is a clearer problem description :)
08:19:06 <saml> data Tree = Node Node Node Int | Leaf Int
08:19:07 <clahey> :)
08:19:26 <ski> s/Node Node Node/Node Tree Tree/, itym
08:19:35 <saml> yup
08:20:02 <clahey> saml: And you're worried about having that stack.
08:20:16 <maukd> fold :: (a -> a -> Int -> a) -> (Int -> a) -> Tree -> a
08:20:23 <saml> sum (Leaf x) = x;     sum (Node l r x) = sum l + sum r + x
08:20:38 <saml> I want tail recursive version of it.. or do I have to write tail recursive version?
08:20:49 <clahey> saml: Why do you want a tail recursive version?
08:20:49 <Eduard_Munteanu> You can't :)
08:20:56 <maukd> saml: you can't write a tail recursive version
08:21:21 <saml> i don't know. i learned that tail recursive is efficient
08:21:21 <clahey> You could write it tail recursive to the right or tail recursive to the left.
08:21:32 <saml> i thought i could write all functions tail recursively
08:21:41 <Eduard_Munteanu> Uh, no.
08:21:42 <clahey> But as far as I can tell, tail recursive is actually worse in haskell than non tail recursive.
08:21:43 <notdan> You can use continuations + tail recursion
08:21:45 <saml> so that was the question.. if i can fold tree tail recursively
08:21:52 <monad_magician> how do I stop ghc from leaving .o and .hi files ?
08:21:59 <Cale> Here's what I'd do to be efficient: first write a traversal which will flatten the tree into a list
08:22:13 <Eduard_Munteanu> You may pretend you did it tail-recursively if you simulated a stack for instance.
08:22:14 <Cale> postorder (Leaf x) = [x]
08:22:32 <Cale> postorder (Node l r x) = postorder l ++ postorder r ++ [x]
08:22:41 <Cale> now, this is inefficient, but we can make it better
08:22:50 * ski . o O ( `sum t = fold (\l r n -> (+ acc) . r . l) (+) t 0' )
08:23:22 <Cale> The reason it's inefficient is that xs ++ ys takes O(length xs) steps to reduce
08:23:41 <notdan> Idk, I'd use continuations on the right branch + tail recursion on the left
08:23:45 <Cale> The trick to making it better is to replace lists [a] with functions [a] -> [a] that add elements to the beginning of a list. Then concatenation becomes composition
08:23:54 <Cale> So the replacement key is:
08:23:55 <notdan> It'll use memory for storing the functions, but not the stack
08:23:57 <Cale> [] becomes id
08:24:01 <Cale> [x] becomes (x:)
08:24:06 <saml> so can i say not all recursive functions can be written trail recursively?
08:24:09 <Cale> (++) becomes (.)
08:24:25 <Cale> postorder' (Leaf x) = (x:)
08:24:35 <maukd> saml: can you write all algorithms with a single loop?
08:24:43 <Cale> postorder' (Node l r x) = postorder' l . postorder' r . (x:)
08:24:52 <saml> can't I?  isn't that how assembly works?
08:24:54 <Cale> and now:
08:25:02 <Cale> postorder t = postorder' t []
08:25:08 <Cale> saml: make sense so far?
08:25:11 <notdan> saml: you can always simulate a recursion with a programmed stack
08:25:28 <saml> Cale, yes. but still not tail recursive..
08:25:30 <Cale> This is efficient because (.) always reduces in O(1) time
08:25:40 <Cale> Don't worry about whether it's tail recursive
08:25:44 <clahey> saml: It's impossible to make it tail recursive because you have to explore both branches.
08:25:47 <Eduard_Munteanu> Though the only reason to do that is trading stack for heap, or stuff like that.
08:25:50 <Cale> composition is constant time!
08:26:20 <ski> clahey : what notdan said
08:26:28 <clahey> But Cale is right, tail recursion doesn't seem to matter so much in haskell land.
08:26:35 <saml> okay. enough of my obsession with tail recursion
08:26:46 <Cale> Tail recursion is actually usually bad, if you put it in the wrong place
08:26:54 <notdan> clahey, Cale: why is that?
08:27:00 <Eduard_Munteanu> Cale: arguably there's a way to associate that (++) like Writer does, and the traversal should be productive so...
08:27:07 <notdan> I mean, if you have to proceed a lot of data and you don't have a big stack
08:27:10 <Cale> But once we flatten the tree, we'll make use of foldl' which has the right blend of strictness and tail recursion to be efficient
08:27:13 <notdan> you can't do without TCO?
08:27:17 <notdan> can you?
08:27:20 <Cale> notdan: There's no call stack
08:27:22 <clahey> notdan: Because of lazy evaluation.
08:27:29 <maukd> notdan: calls don't use a stack
08:27:30 <Cale> notdan: So all your assumptions about how evaluation works are broken.
08:27:36 <notdan> D8
08:27:43 <notdan> Damn you, Scheme
08:27:55 <startling> heh
08:28:21 <notdan> Ok, it looks like I have to read up a little bit on the basics of Haskell's evaluation model
08:29:29 <clahey> Cale: So, I'm not sure quite why this is faster.
08:30:18 <clahey> Cale: postorder Node ls rs x = ls ++ rs ++ [x] just becomes a thunk, right?
08:30:36 <clahey> Oh, I forgot the postorders.
08:30:46 <clahey> The first reduction  would then be:
08:31:22 <Cale> clahey: xs ++ ys takes O(length xs) steps
08:31:23 <clahey> Well, whatever, it would just expand the ls over and over until it found a Leaf, right?
08:31:35 <Cale> total, over its lifetime
08:31:41 <Cale> assuming you evaluate the whole list
08:31:47 <Cale> right?
08:32:02 <Eduard_Munteanu> Cale: well, sum also takes O(length xs), so if you're consuming the list...
08:32:08 <Cale> So if you have a left leaning tree
08:32:17 <Cale> then you're going to get quadratic complexity
08:32:17 <clahey> Cale: I think I see.
08:32:34 <Cale> because you'll do (++) about n times
08:32:59 <Cale> on successively shorter left lists, but the overall complexity will be like sum over i = 1 to n of i
08:33:06 <clahey> n^2/2.
08:33:13 <Cale> yeah, roughly
08:33:31 <Cale> So replacing (++) with an operation which is constant time improves things drastically
08:33:57 <ski> > sum [i | i <- [1 .. n]]
08:33:57 <Eduard_Munteanu> I thought a ++ (b ++ c) was fine.
08:33:58 <lambdabot>   *Exception: not a number
08:34:08 <ski> it is
08:34:16 <ziman> > sum [n]
08:34:17 <lambdabot>   0 + n
08:34:25 <Cale> Eduard_Munteanu: if a and b are fixed-length
08:34:27 <ziman> > [1 .. n]
08:34:28 <lambdabot>   *Exception: not a number
08:34:47 <Cale> @src (++)
08:34:48 <lambdabot> []     ++ ys = ys
08:34:48 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
08:34:48 <lambdabot> -- OR
08:34:48 <lambdabot> xs ++ ys = foldr (:) ys xs
08:34:57 <monad_magician> how do I parse the first element of getArgs into an Int?
08:35:02 <clahey> read?
08:35:58 <startling> read . head <$> getArgs
08:37:09 <clahey> Cale: So, if the tree is infinite, will your method allow you to usefully create an infinite list?
08:38:17 <Eduard_Munteanu> I suspect that can only work for an inorder traversal.
08:38:59 <Cale> clahey: yeah, sure, though you will likely lose infinitely many of the elements
08:39:17 <clahey> Cale: Which is true for any use of an infinite list.
08:39:35 <hpaste> efie pasted “Can this function be used regarding laziness?” at http://hpaste.org/76614
08:39:57 <tromp> > 0.480 * 75 / 72
08:39:58 <lambdabot>   0.5
08:40:00 <Cale> clahey: No, well, I mean there will be infinitely many elements in the infinite tree which don't end up in the infinite list
08:40:15 <efie> ups, I mixed the type signatur up, I'm searching how to annotate it ...
08:40:27 <Cale> clahey: In order to ensure they're all there, you'd want to do something like a breadth-first traversal
08:40:29 <notdan> Hm, OK, I don't think I fully understand guarded recursion, but what I want to know is how it helps Haskell being productive?
08:41:00 <clahey> But yeah, an inorder or preorder traversal with a right infinite tree will get you all the elements.
08:41:05 <clahey> Cale: Yeah, I know.
08:41:13 <clahey> I understood.
08:41:40 <ski> efie : "can the first element of \"f X\" be used before the whole \"f X\" is done?" -- no
08:41:41 <Eduard_Munteanu> That might also fail with an infinitely "wide" n-ary tree.
08:42:19 <ski> efie : what would happen if you could somehow access the first element, but when you look at later elements, they don't exists because `exitFailure' ?
08:42:25 <notdan> Cale: can you help me to understand how can the guarded recursion make Haskell programs more productive?
08:42:39 <Cale> clahey: no it won't, not in general...
08:42:56 <ski> efie : iow, to check for sure whether there were any `Left ...' things in the list, you have to traverse the whole list
08:43:12 <clahey> Cale: Why not?
08:43:19 <Cale> notdan: are you talking about in terms of total functional programming languages which are not Haskell?
08:43:39 <Cale> clahey: because if the left subtree is infinite, in an inorder traversal, you will never enumerate the root
08:43:50 <Cale> (nor any elements of the right subtree)
08:43:50 <clahey> Cale: That's what I meant by Right Infinite.
08:44:01 <Cale> oh, okay
08:44:08 <notdan> Cale: hm, well I read on the wiki the following : In Haskell, the function call model is a little different, function calls might not use a new stack frame, so making a function tail-recursive typically isn't as big a deal—being productive, via guarded recursion, is more usually a concern.
08:44:28 <clahey> RightInfiniteTree a = Node FiniteTree RightInfiniteTree a | Tail a
08:45:08 <efie> ski: if the later elements don't exist and the program stops with "existFailure" it would be fine for me
08:45:25 <Saizan> notdan: productive is kind of a technical term there, meaning the result can be inspected lazily
08:45:25 <Cale> notdan: Oh, okay, well, the idea is that the recursion is "guarded" by an occurrence of a data constructor
08:45:30 <clahey> efie: The problem is in the <$> function.
08:45:43 <ski> efie : but what if the program had already started doing some I/O (e.g. writing to a file), based on the first element ?
08:46:13 <clahey> @source IO <$>
08:46:14 <lambdabot> IO <$> not available
08:46:20 <Cale> notdan: Remember, evaluation is outermost-first, but we generally stop evaluating as soon as we reach a data constructor applied to some arguments.
08:46:25 <ski> @src (<$>)
08:46:25 <lambdabot> f <$> a = fmap f a
08:46:38 <clahey> @src IO fmap
08:46:39 <lambdabot> fmap f x = x >>= (return . f)
08:47:04 <Cale> notdan: because the only reason we evaluate things is to pattern match, and once we have an expression in the form of a data constructor applied to some arguments, we can (hopefully) match a pattern, and then proceed
08:47:16 <clahey> @src Maybe fmap
08:47:17 <lambdabot> fmap _ Nothing       = Nothing
08:47:17 <lambdabot> fmap f (Just a)      = Just (f a)
08:47:19 <monad_magician> the C version of my turing machine is 10 times longer in code size, but is 100 times faster :( how do I optimize my haskell turing machine?
08:47:35 <notdan> Cale: ah
08:47:38 <clahey> monad_magician: Are you running it compiled with -O2?
08:47:53 <efie> ski: I think I have to accept this, because but I can't check the whole list, because if I try to compute it I get "Killed" because it takes to much space / RAM. therefore I'd like to do go on proceeding with the first elements and therefore to save space
08:48:08 <Cale> notdan: and so if our recursive function only recurses inside one of the arguments to that data constructor, it essentially lets the caller of the function decide how far the recursion proceeds
08:48:28 <monad_magician> clahey: yes, compiled with ghc -O2 -Wall -Werror
08:48:49 <ski> efie : perhaps you could skip the rest of the elements of the list in case there's any `Left's ?
08:48:59 <rwbarton> efie: can you just use error instead of exitFailure? and get rid of the IO
08:49:09 <monad_magician> :t error
08:49:10 <lambdabot> forall a. [Char] -> a
08:49:16 <efie> rwbarton: ok
08:49:32 <monad_magician> what does error return?
08:49:56 * hackagebot HStringTemplate 0.6.11 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.11 (SterlingClover)
08:49:58 <rwbarton> it doesn't
08:50:08 <efie> ski: I need them all and if there is one of them corrupt the whole program should be stopped
08:50:15 <ski> efie : in case it's a program error (or "internal" data error) for there to be any `Left's, you could use `error', yes
08:50:32 <ski> (by "program error" i mean that your program has a bug)
08:50:44 <Cale> monad_magician: It doesn't.
08:51:00 <Cale> ah, haha, rwbarton got there first :)
08:51:10 <monad_magician> so it just halts the Haskell runtime?
08:51:13 <ski> efie : yes, but what does "stopped" mean ? -- i think if this is a realistic scenario, then you want control over what happens in this case
08:51:22 <Cale> monad_magician: yes, you can treat it similarly to going into an infinite loop
08:51:29 <clahey> efie: What you're asking for is basically impossible.  If you want the program to do nothing if there's any errors, then you can't do something until you've checked if there's any errors.
08:51:30 <Eduard_Munteanu> > error "ohai"
08:51:31 <Cale> monad_magician: except that your program actually stops
08:51:31 <lambdabot>   *Exception: ohai
08:51:39 <ski> monad_magician : what does `case False of True -> ()' evaluate to ?
08:51:43 <monad_magician> @source error
08:51:44 <lambdabot> error not available
08:51:58 <clahey> > case False of True -> ()
08:51:58 <monad_magician> ski: it evaluates to error?
08:52:00 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
08:52:26 <Cale> monad_magician: Now, technically, it actually throws an exception, but since it throws it during evaluation (rather than execution of an IO action), it's quite hard to ever catch that exception, and you can only really do so from IO anyway
08:52:35 <ski> monad_magician : it's a pattern-match failure which aborts computation. `error' also aborts computation
08:52:42 <Cale> It's not recommended to try to catch exceptions thrown by error
08:52:57 <monad_magician> so how should I handle logic errors
08:53:01 <clahey> Cale: Because you don't know the state of the evaluation at that point>
08:53:02 <clahey> ?
08:53:06 <Cale> monad_magician: Maybe/Either
08:53:09 <monad_magician> ah
08:53:13 <startling> monad_magician: what kinds of logic errors?
08:53:26 <monad_magician> like passing a negative number to factorial
08:53:36 <ski> `error' is fine for that
08:53:39 <efie> ski: shutting the program down and printing a message on the screen "corrupt data" is fine for me in this case
08:53:41 <clahey> Well, it depends.
08:53:49 <startling> monad_magician: yeah, Maybe is probably best
08:53:54 <clahey> efie: And it's okay to have processed data to this point?
08:54:04 <efie> clahey: yes
08:54:07 <clahey> monad_magician: It depends on what you want the program to do if you pass it a negative number.
08:54:10 <ski> monad_magician : when the caller has failed to satisfy any preconditions of use of an operation, `error' is fine
08:54:18 <startling> can I use a MultiParamTypeClass with FunctionalDependencies as a superclass?
08:54:47 <Saizan> sure
08:54:57 <clahey> efie: Sounds like error to me, but I'm fairly new.
08:55:04 <startling> I'm trying to do class (Something a b) => Else b where, but I get "not in scope: type variable a" and "b"
08:55:37 <Cale> startling: For both?
08:55:50 <monad_magician> How do I profile my haskell program to find out why it's so much slower than my C program?
08:55:52 <Cale> startling: Which functional dependencies are present?
08:56:02 <startling> a -> b
08:56:06 <ski> efie : then one could write `f :: [(Either Text String,Either ParseError Text)] -> [(Text,Text)]; f = map (fromRight *** fromRight) where fromRight (Left _) = error "corrupt data"; fromRight (Right a) = a'
08:56:15 <startling> Cale: yeah, I get that error for a and b.
08:56:15 <Cale> startling: oh, well, that won't do
08:56:31 <startling> oh, right
08:56:35 <Cale> startling: you'll need b -> a for this to even make sense
08:56:45 <startling> yeah, hadn't thought of that
08:57:29 <startling> oh, i can do class (Something a b) => Else a b where whatever :: b
08:57:48 <rwbarton> should probably repeat the fundep on Else
08:57:59 <Cale> and if you don't have b -> a
08:58:05 <Cale> then whatever is going to be hard to use
08:58:05 <startling> should I? good to know
08:58:21 <rwbarton> hmm, maybe it is automatic?
08:58:21 <Cale> because you'll only have type b at the usage site
08:58:34 <Cale> and won't be able to decide which a it goes with
08:58:40 <startling> yeah.
08:58:45 <gwern> @quote
08:58:46 <lambdabot> danharaj: says: unsafePerformIO : The gateway function
08:59:24 <efie> ski: uh oh, arrows? :) I did "(Right correct1, Right correct2) -> [(correct1,correct2)] ++ f xs"
09:01:56 * ski . o O ( "Yog-Sothoth is the gate." )
09:02:34 <ski> efie : will probably work just as fine
09:03:05 * ski wonders where efie got this list of pairs of `Either'-stuff from
09:03:32 <efie> well ... :) *types*
09:04:52 <Trayon> Anyone here?
09:05:06 <ski> at least you are in here
09:05:22 <Trayon> besides me of course
09:05:29 <Trayon> just had a quick question
09:05:58 <singpolyma> `reader` lets me turn (a -> b) into (ReaderT a m b)    how would I do  (a -> b -> c) -> (ReaderT a (ReaderT b m) c)
09:06:14 <monad_magician> I found out why the turing machine is slow: my haskell program is overflowing the stack. How do I find out why?
09:06:18 <monad_magician> what's the usual suspect?
09:06:49 <monad_magician> laziness?
09:07:06 <monad_magician> or maybe tail recursion
09:07:06 <brobles> hi
09:07:09 <monad_magician> brobles: hello
09:07:15 <brobles> Im new on haskell
09:07:24 <brobles> have a little language crisis lol
09:07:32 <brobles> can't decide between haskell or go
09:07:50 <brobles> w one have best performance and job options ?
09:08:21 <Trayon> anyone know how haskell might manipulate the end of the list without having to traverse it? I don't like the idea that I cant have a pointer to the end of the list.
09:08:47 <monad_magician> how do I make my functions more strict so I don't overflow the stakc?
09:08:56 <ski> @type ReaderT . (((ReaderT) . (return .)) .)
09:08:58 <lambdabot> forall r a r1 (m :: * -> *). (Monad m) => (r -> r1 -> a) -> ReaderT r (ReaderT r1 m) a
09:09:23 <efie> ski: http://hpaste.org/76616
09:09:35 <ski> Trayon : "lists" are (single-)linked lists in Haskell -- if you want something else, use a different data structure
09:10:00 <monad_magician> try Data.Sequence
09:10:04 <Trayon> okay, I'll take a look at that
09:10:15 <Trayon> thanks ski
09:10:20 <ski> Trayon : .. btw, what are you trying to do ?
09:10:32 <Trayon> Lol, learnin
09:10:38 <Trayon> I just started to pick it up
09:10:43 <singpolyma> ski: that looks like what I want.  I guess the best way is to make `reader2` be that?
09:11:24 <ski> @type reader
09:11:26 <lambdabot> forall r a. (r -> a) -> Reader r a
09:11:31 <Trayon> I didn't really think my question through, I feel kind of dumb now not thinking that there are other data structures
09:11:55 <ski> @type ReaderT . (ReaderT .)
09:11:55 <ski> @type ReaderT . (reader .)
09:11:56 <lambdabot> forall r a r1 (m :: * -> *). (r -> r1 -> m a) -> ReaderT r (ReaderT r1 m) a
09:11:57 <lambdabot> forall r a r1. (r -> r1 -> a) -> ReaderT r (ReaderT r1 Identity) a
09:12:41 <Trayon> btw, is there an equivalent to slime for haskell in emacs?
09:12:48 <ski> singpolyma : hm, did `reader' change from `(r -> a) -> ReaderT r Identity a' to `Monad m => (r -> a) -> ReaderT r m a' ?
09:13:00 <clahey> :t reader
09:13:02 <lambdabot> forall r a. (r -> a) -> Reader r a
09:13:06 <Cale> Trayon: btw, you do have a pointer to the end of every list, it's just []
09:13:10 <singpolyma> ski: I think so
09:13:15 <ski>   type Reader r a = ReaderT r Identity a
09:13:27 <singpolyma> ooh, looks like      ReaderT (reader . f)      might be ok instead of an explicit reader2
09:13:31 <brobles> o deploy yesod app ? easy
09:13:41 <Cale> (well, every finite list, anyway)
09:14:30 <Trayon> I read that haskell mode in emacs doesn't have the "instant feedback" feature of slime for lisp
09:14:30 <Cale> Trayon: It's just, knowing that isn't so useful when lists are immutable :)
09:15:07 <troydm> Trayon: no, but you can easily reload modules in haskell mode iirc
09:15:27 <Trayon> that's too bad
09:15:33 <Trayon> heat does the trick
09:15:40 <Trayon> but I wanted something for linux
09:15:45 <Trayon> and I like emcas
09:16:32 <Trayon> oh well, I'm just starting to learn, I suppose heat will just have to do until I start tacking harder problems
09:16:34 <singpolyma> that pattern doesn't seem to generalize directly to, say, reader3, though
09:16:36 <singpolyma> hmm...
09:17:11 <singpolyma> oh, no, it does
09:17:20 <singpolyma> ReaderT . ((ReaderT . (reader .)) .)
09:17:21 <singpolyma> cool
09:20:13 <Trayon> oh, hey professor Gomez
09:22:50 <Trayon> @fgomez: you wouldn't happen to teach at UCF would you?
09:22:50 <lambdabot> Unknown command, try @list
09:23:16 <monad_magician> http://ideone.com/LLtaOS any ideas for optimizing this program? It runs orders of magnitute slower than the equivalent C version
09:28:44 <mcstar> at least it is shorter
09:29:35 <mcstar> did you use -O2? probably you did, just asking to make sure
09:31:49 <clahey> monad_magician: What about making run !m !n ?
09:31:51 <monad_magician> I did ^^
09:32:41 <monad_magician> clahey: the bang in front of m makes it slowerr :(
09:33:04 <mcstar> monad_magician: you can import Prelude hiding (cycle) so you dont have to write that ugly Main.cycle
09:33:19 <monad_magician> right
09:35:26 <monad_magician> optimizing haskell is challenging ^^
09:35:59 <mcstar> everything is challenging when you do it the first time
09:37:10 <mcstar> i dont get why 'run' is -> IO ()
09:37:32 <lispy> monad_magician: I highly recommend profiling to take the magic out of optimizing
09:37:42 <monad_magician> how do i profile it?
09:37:45 <mcstar> the computation you do with that tape machine is pure, so i wouldnt drive it from io
09:38:00 <lispy> monad_magician: http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
09:38:12 <lispy> monad_magician: chapter 5 covers most of what you need to know
09:38:14 <monad_magician> its IO () cause I print the tape out on every ste ^^
09:38:18 <monad_magician> step*
09:38:30 <mcstar> i get it
09:38:30 <monad_magician> ah xlent
09:38:31 <lispy> monad_magician: and this covers the rest: http://book.realworldhaskell.org/read/profiling-and-optimization.html
09:38:35 <mcstar> but i dont understand why
09:39:12 <mcstar> monad_magician: try to compile with -rtsopts, and run with +RTS -s to get a GC profile
09:39:20 <mcstar> maybe you somehow copy too much, idk
09:39:26 <monad_magician> right
09:39:40 <lispy> monad_magician: profiling consists of recompiling your program with certain flags, doing your test run again, and then interpreting the data, so that you know what to change. Rinse. Repeat.
09:40:02 <mcstar> hehe, thats when the programmer dies while washing his head
09:40:22 <mcstar> so, eventually pls stop
09:40:29 <lispy> mcstar: and lice can't be killed with regular shampoo :)
09:40:55 <monad_magician> MUT takes 5.2 seconds
09:40:59 <monad_magician> what is that?
09:41:07 <mcstar> monad_magician: whats the productivity?
09:41:11 <mcstar> percentage
09:41:21 <monad_magician> productivity = 88.0%
09:41:30 <mcstar> thats not too horrible
09:41:43 <mcstar> not ideal, but not the main problem
09:41:54 <monad_magician> what would be ideal?
09:42:01 <mcstar> 100%
09:42:04 <rwbarton> 110%
09:42:08 <mcstar> :)
09:42:18 <mcstar> rwbarton: parallel gc?
09:42:33 <rwbarton> you gotta motivate your program to do its best
09:42:36 <monad_magician> why is my productivity so low?
09:42:44 <mcstar> it is not low imo
09:42:54 <mcstar> 10% is low
09:43:15 <monad_magician> what does productivity meaasure?
09:43:25 <lispy> monad_magician: If I had to take a wild guess as to where the slowness is, I would guess that cycle is the problem
09:43:30 <mcstar> non gc time over time
09:43:33 <monad_magician> right
09:43:34 <mcstar> or something close
09:44:22 <clahey> run seems to spend a lot of time allocating things.
09:44:27 <clahey>   run                    Main                                                 347         108   0.0   78.5     0.0   85.3
09:44:33 <monad_magician> :(
09:44:48 <clahey> Not that I know what that means.
09:45:14 <mcstar> id write a case on windDirection
09:45:26 <mcstar> instead of those windLeft/windRight stuff
09:45:43 <lispy> monad_magician: what is your high water mark for memory usage?
09:45:57 <startling> yeah, I had a zipper-like thing and wrote a data Direction = N | E | W | S
09:46:06 <monad_magician> I have a C version of te program ^^
09:46:08 <startling> much cleaner code, imo
09:48:03 <clahey>         total alloc = 7,955,864,244 bytes  (excludes profiling overheads)
09:48:24 <clahey> monad_magician: I hope you don't mind that I downloaded it to try?  I'm interested in learning to optimize haskell code as well.
09:48:50 <monad_magician> sure
09:49:21 <mcstar> monad_magician: i see, you dont store the visited states of the machine, that why you print each step
09:49:32 <mcstar> monad_magician: how many prints per second are we talking about?
09:50:12 <mcstar> what happens when you just collect the result, and take the length of the result instead of printing it directly?
09:50:24 <monad_magician> lets see
09:50:36 <mcstar> monad_magician: first tell me many prints per sec
09:50:44 <mcstar> just approximately
09:51:05 <mcstar> how many*
09:51:08 <monad_magician> > 11000000/4.5
09:51:09 <lambdabot>   2444444.4444444445
09:51:14 <monad_magician> prints per second ^^
09:51:25 <mcstar> jesus holy christ
09:51:45 <mcstar> ok, c wins here, no wonder
09:51:57 <mcstar> your whole runtime must be dominated by printing the result
09:52:27 <monad_magician> right
09:53:33 <monad_magician> maybe I should print it all at the end
09:54:58 <mcstar> 3.4 sec for input 5
09:55:10 <mcstar> 11798826
09:55:28 <mcstar> monad_magician: dont print it when you are benchmarking
09:55:37 <mcstar> monad_magician: wheres the C version?
09:55:42 <mcstar> i think you pasted that too
09:55:51 <monad_magician> http://ideone.com/eMTbBQ
09:56:08 <monad_magician> the Haskell version makes the C version look bad
09:57:11 <mcstar> 0.25s
09:57:30 <mcstar> > 3.4/0.25
09:57:31 <lambdabot>   13.6
09:57:42 <mcstar> thats still not honkey dorky
09:58:05 <monad_magician> on my machine the C version takes 100 milliseconds to complete ^_^
09:58:29 <monad_magician> haskell version seems to take twice as long
09:58:46 <monad_magician> I still think the Haskell version can go faster
09:58:51 <mcstar> i know i have a slow pc
09:58:56 <mcstar> ofc it can
09:59:40 <monad_magician> at least the Haskell version is in the 'fast enough' now
09:59:49 <monad_magician> 'fast enough' zone*
10:00:25 <monad_magician> lets see how the python version fares :D
10:00:29 <hiptobecubic> what are we looking at?
10:00:36 <hiptobecubic> turing machine?
10:00:46 <hiptobecubic> christ
10:00:48 <monad_magician> yes
10:01:18 <monad_magician> the python version takes 15 times longer to complete
10:01:21 <mcstar> monad_magician: i dont really understand how did you measure 2x slower haskell performance vs. my 13x
10:01:23 <monad_magician> than the C version*
10:01:43 <monad_magician> I used the time command :D
10:01:43 <lispy> monad_magician: I tried to run it, but I got an exception Prelude.head
10:01:48 <hiptobecubic> I missed the haskell version, can someone repaste :) ?
10:01:51 <lispy> monad_magician: what should I change to make it run?
10:02:20 <mcstar> lispy: his paste worked for me for the first try
10:02:21 <monad_magician> http://ideone.com/r2a9a5
10:02:39 <monad_magician> you need to run it with some number argument :D
10:02:41 <mcstar> lispy: ah, you need to suply a number on the comand line
10:02:47 <lispy> ah
10:03:46 <u_quark> so, what's the solution for this http://hpaste.org/76599 ?
10:04:15 <clahey> So, I tried to make a version that was completely pure in the computation of the number of cycles.
10:04:33 <clahey> But it runs out of stack space now.
10:04:36 <monad_magician> http://ideone.com/mVN1GR here's the python version :D
10:04:50 <mcstar> clahey: how so, i rewrote it too :D
10:04:57 * hackagebot lio 0.9.1.2 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.9.1.2 (DeianStefan)
10:05:18 <clahey> mcstar: run :: TuringMachine -> Int
10:05:18 <clahey> run (TM HALT _ _) = 0
10:05:19 <clahey> run m = run (Main.cycle m) + 1
10:05:32 <clahey> mcstar: I also tried a tail optimized version.
10:05:50 <mcstar> well, im doing m : run...
10:05:54 <clahey> And I tried making it strict in the parameter m.
10:06:09 <mcstar> probably i should discard the list, and just return the number at the end
10:06:14 <mcstar> but it doesnt SO for me
10:07:50 <rwbarton> clahey: you should convert that to tail recursive style and then make it strict in the accumulator (though ghc ought to be able to figure out to do that automatically)
10:08:04 <mcstar> 2.9 sec if i dont collect the list, not a big difference, since i was just taking the length of it
10:08:05 <rwbarton> strict in m is useless, you already pattern match on m in the first case
10:10:31 <clahey> rwbarton: I tried exactly that and it didn't seem to help.
10:10:46 <hiptobecubic> throw strictify at it :D
10:11:36 <rwbarton> well maybe there is another stack overflow then
10:12:12 <clahey> rwbarton: If I change it to:  length . unfoldr (\m -> safeCycle m >>= return . (,m))
10:12:22 <clahey> Then it doesn't stack overflow, but it does just sit there.
10:12:48 <clahey> Oh, I have an appointment.  Talk to y'all later.
10:18:22 <mcstar> why is Tape polymorphic?
10:18:39 <monad_magician> no reason :D
10:19:06 <ski> (nitpick, it's parametric, not polymorphic)
10:19:15 <monad_magician> I originally had no idea to implement the infinite tape until Cale suggested I use that :D
10:19:23 <monad_magician> no idea how* to implement it
10:20:33 <Cale> You could of course pick a specific type of value for the elements
10:20:47 <monad_magician> right
10:20:48 <Cale> But many operations on tapes won't care about that
10:21:02 <monad_magician> I like the generic definition
10:21:04 <Cale> and the parametricity makes sure that they don't
10:21:20 <monad_magician> makes me focus on the tape operations rather than what they actually hold ^^
10:21:22 <klr> im trying to do an exercise in Real World Haskell, and i made this code: https://gist.github.com/3932740 it doesnt want to compile/load in ghci, can someone explain whats wrong please?
10:21:31 <drewr> is there a way with hsenv to set a different default ghc?
10:21:42 <mcstar> ski: isnt it called parametric polymorphism, that haskell has?
10:21:52 <johnw> elem xs is missing an argument
10:21:57 <drewr> --ghc seems to only take a bz2 and then extract the entire thing into each project (which is fine for some cases)
10:22:06 <klr> johnw: what you mean?
10:22:10 <johnw> i think you meant "length xs"?
10:22:23 <klr> oh, ill try that one thanks!
10:22:37 <u_quark> so, what's the solution for this http://hpaste.org/76599 ?
10:22:43 <klr> hmm it still wont load :(
10:22:58 <johnw> u_quark: you are using 7.6.1 to build a package that hasn't been ported to it
10:23:20 <johnw> you'll need to download the project, add an "import Control.Exception" in the modules that need it, and build locally
10:23:39 <ski> mcstar : yes. `depth :: Tree a -> Int' is polymorphic. `Tree' is parametric
10:23:43 <u_quark> johnw: tnx
10:23:47 <johnw> u_quark: i've had to do this now more times than I can count
10:24:01 <johnw> submit the changes back to the author, if you have time
10:24:15 <johnw> there are still lots of incompatible packages on Hackage
10:24:16 <lispy> monad_magician: by removing all your tuples, it goes from 2.7 s to 1.7s
10:24:17 <klr> this function https://gist.github.com/3932740 doesnt seem to work, it's supposed to show the item of the list next to the last one
10:24:24 <Cale> klr: you might want to use more pattern match
10:24:25 <Cale> ing*
10:24:43 <klr> Cale: okey, what do you mean with "pattern matching"?
10:24:49 <mcstar> ski: but the Tape value constructor can take arguments of any type, so it is like a polymorphic function, the type of it can still be parametric, right?
10:24:53 <johnw> klr: your function only returns the penultimate member
10:24:56 <Cale> klr: specifically, make it look like this:
10:25:01 <Cale> lastButOne [] = ...
10:25:03 <Cale> lastButOne [x] = ...
10:25:04 <johnw> klr: so it can't show the original list "next to" that member
10:25:09 <ski> mcstar : no, it's kind is `* -> *', so it's like a *monomorphic* function
10:25:19 <klr> hmm, i dont really understand but ill try
10:25:19 <Cale> lastButOne xs = ...
10:25:35 <klr> i want to use gaurds
10:25:44 <ski> mcstar : `Tape' can take ant *concrete* type as argument (i.e. any type of kind `*')
10:25:46 <johnw> klr: you are programming with "guards" right now; there is another way to solve the same problem which is more idiomatic in this case, called "pattern matching"
10:25:48 <rwbarton> but ski you're talking about the type constructor
10:26:04 <rwbarton> mcstar said "the Tape value constructor"
10:26:08 <ski> mcstar : compare this with how `not' can take any *boolean* value as argument (i.e. any value of type `Bool')
10:26:10 <Cale> klr: using xs == [] to check if a list is empty won't work in general, because == on lists requires an Eq instance for the elements of the lists
10:26:12 <klr> johnw: i know, ive solved the problem already, but i want to do it with gaurds :P
10:26:22 <Cale> klr: So you'll have an extra Eq constraint then
10:26:23 <klr> Cale: ok
10:26:25 <johnw> use "null xs" instead of "xs == []"
10:26:31 <Cale> You could use null xs, yes
10:26:31 <klr> hmm ok
10:26:39 <Cale> But it's better to just pattern match
10:26:58 <ski> rwbarton : yes, however at <http://ideone.com/LLtaOS>, we have `data Tape a = T [a] a [a] a'
10:27:06 <rwbarton> oh
10:27:11 <Cale> If you don't like writing the name lastButOne multiple times, you can use case
10:27:14 <Cale> case xs of
10:27:17 <Cale>   [] -> ...
10:27:20 <Cale>   [x] -> ...
10:27:25 <rwbarton> anyways yes I agree that the type constructor is parametric rather than polymorphic
10:27:31 <klr> hmm
10:27:32 <ski> mcstar : iow, `Type' is not a value/data constructor here, it's a type consrtuctor
10:27:33 <rwbarton> whatever its name is :)
10:27:47 <klr> this seemed harder than i tought, i have to re-read the gaurds thingy
10:28:02 <mcstar> ski: oh, that was my mistake, i meant to write T then
10:28:20 <ski> `T' is polymorphic, yes
10:28:27 <Cale> klr: Guards are good for lots of conditions, but when you're taking apart list structure, testing to see how many elements are in a list with length and such is bad style
10:28:37 <klr> ok
10:28:38 <ski>   T :: [a] -> a -> [a] -> a -> Tape a
10:28:38 <klr> thanks
10:28:46 <Cale> klr: (even if just because length is O(n), and hangs on an infinite list)
10:28:46 <gatlin> has anyone here successfully set up the LLVM backend on OS X Lion?
10:29:40 <ski> mcstar : and that is short for `T :: forall a. [a] -> a -> [a] -> a -> Tape a' -- it's the `forall' in the type here which indicates that `T' is polymorphic
10:29:55 <mcstar> k
10:29:57 * hackagebot chuchu 0.1.3 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.1.3 (FelipeLessa)
10:30:07 <nicoo> klr: It's guards, not gaurds ;)
10:30:22 <klr> nicoo: oh, sorry for my english!
10:30:23 <mcstar> anyway, removing this only helped a couple percents
10:30:24 <rwbarton> {-# LANGUAGE PatternGourds #-}
10:30:25 <hpaste> lispy pasted “BusyBeaver” at http://hpaste.org/76618
10:30:38 <lispy> monad_magician: How does that version compare?
10:30:56 <mcstar> lispy: did it help to make the fields strict?
10:31:21 <mcstar> no...
10:31:29 <lispy> mcstar: Removing the lazy tuples for strict ones made a big difference here.
10:31:34 <mcstar> actually, it made slower
10:31:39 <lispy> mcstar: i'm not sure about the strict fields otherwise
10:31:44 <mcstar> i just tried
10:31:48 <lispy> mcstar: what ghc do you use?
10:31:54 <mcstar> 7.6.something
10:32:01 <lispy> $ ghc --version                                                                                                                                                        10:29
10:32:04 <lispy> The Glorious Glasgow Haskell Compilation System, version 7.4.1
10:32:06 <klr> i rewrote the functions using if and else, https://gist.github.com/3932806 , but it still wont loud :(
10:32:25 <lispy> mcstar: for me the time went from 2.7s to 1.7s for an input of 5
10:32:43 <lispy> mcstar: so about a 30+% increase
10:32:52 <ski> klr : perhaps you meant to write `error' in front of those two string literals ?
10:33:07 <rwbarton> klr: also you're missing an "else"
10:33:12 <klr> ski: what you mean?
10:33:17 <klr> rwbarton: no i have an else
10:33:28 <rwbarton> nevertheless you are still missing an else
10:33:46 <klr> rwbarton: how do you mean, i have an else at the end, or do i need one more?
10:33:49 <mcstar> lispy: oh, great, i mentioned before, it would be better to replace those tuples, but i didnt consider performance at that time :)
10:34:10 <monad_magician> lispy: it speeds up quite a bit: 0.7 milliseconds vs the original's 0.83 milliseconds
10:34:14 <rwbarton> klr: you have "if ... then ... if ... then ... else ..."
10:34:26 <klr> rwbarton: is that wrong?
10:34:29 <ski>   lastButOne xs = if xs == [] then error "Empty list :P"
10:34:32 <mcstar> monad_magician: lets stick to input 5
10:34:34 <ski>              else if length xs == 1 then error "You need more items in your list :P"
10:34:37 <ski>              else last (init xs)
10:34:39 <klr> ski: thanks
10:34:57 <mcstar> for 5, it is long enough to get stable numbers out of it
10:35:21 <rwbarton> klr, yes, every if needs a corresponding then and else
10:35:40 <klr> ok
10:35:41 <drewr> aha, https://github.com/Paczesiowa/hsenv/issues/12
10:36:32 <ski> klr : using guards
10:36:35 <ski>  lastButOne xs
10:36:39 <ski>     | xs == []       = error "Empty list :P"
10:36:46 <ski>     | length xs == 1 = error "You need more items in your list :P"
10:36:48 <ski>     | otherwise      = last (init xs)
10:36:58 <klr> length doesnt work
10:37:04 <klr> complains about Eq sth
10:37:16 <ski>   lastButOne :: Eq a => [a] -> a
10:37:18 <rwbarton> xs == [] would be the one that complais about Eq
10:37:20 <klr> can i try getting length another way?
10:37:22 <ski> but that is because of `xs == []'
10:37:28 <ski> not because of `length'
10:37:34 <klr> oh okey
10:37:53 <klr> what should i use instead of == to compare the list with the empty one?
10:37:59 <ski> `null xs'
10:38:04 <rwbarton> null (didn't we just go over this?)
10:38:14 <klr> okey thanks, sry for not listening to carefully
10:38:19 <ski> > null ("didn't we just go over this?")
10:38:20 <lambdabot>   False
10:38:30 <mcstar> cheating
10:38:37 <mcstar> artificial quotes
10:38:39 <klr> IT WORKS ! :D thanks everyone!
10:38:43 <tromp> > 1200/241
10:38:45 <lambdabot>   4.979253112033195
10:38:56 <rwbarton> < Cale> klr: using xs == [] to check if a list is empty won't work in general, because == on lists requires an Eq instance for the elements of the lists < Cale> klr: So you'll have an extra Eq constraint then < klr> Cale: ok < johnw> use "null xs" instead of "xs == []"
10:39:01 <johnw> is it true to say that Haskell evaluation of recursive lazy functions is essentially hylomorphic?  in that it builds a series of thunks from an initial expression (anamorphism), and then reduces them down to a result value as needed (catamorphism)?
10:39:11 <ski> > null (didn't we just go over this)
10:39:12 <lambdabot>   Not in scope: `we'Not in scope: `just'Not in scope: `go'Not in scope: `over...
10:39:48 <ski> > null (didn't we just go over this)
10:39:50 <Cale> johnw: uhhhh...
10:39:50 <lambdabot>   False
10:40:01 <rwbarton> ski: needs the ? for a section
10:40:01 <Cale> :t didn't
10:40:02 <lambdabot> forall t t1 t2 t3 t4. t -> t1 -> t2 -> t3 -> t4 -> [Char]
10:40:04 <klr> null (im cool)
10:40:14 <monad_magician> ghc: panic! (the 'impossible' happened)
10:40:17 <johnw> Cale: is what I said too simple, or was something wrong?
10:40:19 <monad_magician> what happened?
10:40:23 <mcstar> ski: did those labels got interned, so to speak?
10:40:27 <rwbarton> monad_magician: the 'impossible'
10:40:37 <rwbarton> you tell us!
10:40:49 <ski> > null (didn't we just go over this?)
10:40:50 <mcstar> > nosuchlabel
10:40:51 <lambdabot>   Not in scope: `nosuchlabel'
10:40:51 <lambdabot>   False
10:40:54 <mcstar> > nosuchlabel
10:40:55 <Cale> johnw: I think you'd have to flesh this idea out with actual datatypes before it would really start to be right or wrong.
10:40:55 <lambdabot>   Not in scope: `nosuchlabel'
10:41:05 <Cale> johnw: I don't immediately see it.
10:41:05 <ski> rwbarton : satisfied ?
10:41:06 <monad_magician> I just tried compiling my turing machine and ghc spat that error :D
10:41:08 <mcstar> > first nosuchlabel
10:41:09 <lambdabot>   Not in scope: `nosuchlabel'
10:41:11 <mcstar> > first nosuchlabel
10:41:12 <lambdabot>   Not in scope: `nosuchlabel'
10:41:13 <rwbarton> ski: yes :)
10:41:31 <rwbarton> monad_magician: paste code and full error message
10:41:45 <rwbarton> monad_magician: also congrats, getting that error message is something of a rite of passage ;)
10:41:49 <johnw> i'm trying to make sense of this statement on Wikipedia: "In the previous example (written in Haskell, a purely functional programming language) it can be seen that this function (factorial), applied to any given valid input, will generate a linear call tree isomorphic to a list... the anamorphic part of the process is the generation of the call tree which is isomorphic to the list [1, 1, 2, 3, 4, 5]. The catamorphism, then, is the
10:41:49 <johnw> calculation of the product of the elements of this list."
10:41:53 <ski> mcstar : interned ?
10:42:01 <mcstar> ski: i dont understand why you didnt get not in scope errors on your second try
10:42:10 <mcstar> ski: a cl term
10:42:25 <hpaste> beaky pasted “GHCError” at http://hpaste.org/76620
10:42:31 <ski> i convinced lambdabot my code was fine as it was
10:42:36 <mcstar> lol
10:42:52 <rwbarton> -fdefer-not-in-scope-errors
10:43:02 <ski> (and no, there's no symbols in there, so no interning)
10:43:33 <Cale> johnw: Well, you can *express* factorial as a hylomorphism, but not everything is necessarily a hylomorphism, I think.
10:43:40 <rwbarton> monad_magician: interesting
10:44:03 <rwbarton> monad_magician: i would guess maybe the issue is on line 55, try removing various numbers of !s there?
10:44:06 <klr> thanks for all help everyone, i hope ill learn one new haskell thing each day so i one day may be able to become a programmer :D
10:44:16 <johnw> yes, that's why I restricted to "lazy recursive"
10:44:21 <Cale> johnw: But maybe there is something to that idea, I don't know
10:44:41 <rwbarton> monad_magician: oh
10:44:43 <johnw> "build up thunks, reduce them down" == hylomorphic
10:44:46 <Cale> johnw: I haven't thought much about what the recursion schemes mean in the context of general expression graphs
10:44:55 <rwbarton> monad_magician: lines 38-39 are bogus
10:45:02 <rwbarton> monad_magician: ghc 7.4 gives a proper error about them
10:45:05 <Cale> I don't like that use of the word thunks here though
10:45:08 <rwbarton> looks like a regression
10:45:19 <johnw> Cale: what is the better terminology?
10:45:38 <Cale> Well, data structures
10:45:43 <monad_magician> rwbarton: right that fixed it :D
10:45:55 <monad_magician> why doesn't my newer ghc give a proper error?
10:46:01 <johnw> but most implementations of factorial don't actually build data structures
10:46:01 <monad_magician> ah
10:46:04 <rwbarton> a bug i guess
10:46:08 <rwbarton> report it :)
10:46:19 <rwbarton> preferably after reducing to a minimal test case
10:46:22 <Cale> If you want to talk about the thunks which are built during the evaluation of some definition of factorial, those are almost certainly going to involve both multiplication and the elements of the list used in the hylomorphism
10:46:27 <johnw> the only reason the intermediate values are isomorphic to a list is that Haskell creates thunks to builds them in sequence upon demand...
10:46:31 <rwbarton> which should just be a line or two
10:46:49 <johnw> ok
10:46:51 <Cale> johnw: Well, I don't think that's the case
10:46:59 <Cale> thunks are an implementation detail
10:47:10 <johnw> oh...
10:47:13 <Cale> which is just the representation of expressions at runtime
10:47:33 <johnw> is this description on wikipedia just about the conceptual evaluation of factorial?
10:47:43 <Cale> yes, I think so
10:47:46 <johnw> that is, it would still be true if fully strict
10:47:47 <johnw> ok, cool
10:47:54 <johnw> i'm starting to like that about category theory :)
10:48:11 <Cale> hylomorphisms aren't really a category theory thing
10:48:25 <Cale> though, you can build this stuff in a category theoretical way
10:48:28 <johnw> i _was_ able to explain category theory to my wife enough that she saw the usefulness of it, before our soup was finished :)
10:48:54 <Cale> this is recursion theory stuff which the category theorists don't really touch
10:49:54 <Eduard_Munteanu> johnw: does your wife have a math background?
10:49:55 <Cale> (but catamorphisms do have a nice interpretation in terms of initial algebras of a functor, or terminal coalgebras)
10:50:02 <johnw> Eduard_Munteanu: she used to tutor it in college
10:50:47 <lispy> monad_magician: I'm going to stop looking at it, but what i've learned from profiling is that Data.Map.(!) and compare are your two biggest slow downs.
10:51:01 <Eduard_Munteanu> I guess that explains it. Without some background on abstract algebra or other branches of math, I'm not really sure how you'd motivate a layman about CT.
10:51:05 <lispy> monad_magician: I'm not sure if it's worth writing your own Ord instance, but it might be.
10:51:08 <Eduard_Munteanu> At least, not in a few words.
10:51:43 <lispy> monad_magician: if you could write them and get them to inline you might get a speed up
10:51:46 <akosch> I'm having trouble finding a suitable alias for the monster-type (monad transformer) I just created. I've seen people name such things "App", but I would rather refrain from calling it that (it feels a bit like naming variables "data").
10:52:31 <akosch> It's hard to come up with a name that describes what it's for.
10:53:05 <johnw> I told her to imagine the functions for "identity+associative binary operator" for a given domain as if they were different types of screwdrivers -- phillips, flathead, etc. -- and how wouldn't it be cool if your toolbox just had a single instrument for "insetting metal", no matter what the metal was or how you set it (kind of like a sonic screwdriver).  That's essentially what programming in terms of Moniods is, rather than having to
10:53:05 <johnw> always think about the different ways to "append" or "concatenate" various types of structures
10:53:05 <akosch> anyone with a similar problem?
10:53:24 <johnw> that's why I always use <> now, instead of ++, but it makes my code inherently more transportable to other problems I haven't thought about yet
10:53:26 <monad_magician> lispy: right; maybe there's something faster than Data.Map I can use. Thanks for all the optimization :D
10:53:42 <johnw> akosch: I usually name it after the app that I'm making
10:53:53 <rwbarton> oh that kind of App
10:54:22 <johnw> s/but/because
10:54:29 <akosch> johnw: and if it's used only inside a single module?
10:54:42 <Cale> akosch: Well, what are computations in this monad capable of generally?
10:54:58 <johnw> akosch: i rarely, rarely program by creating a new module from scratch.  I very often copy & paste, if not abstract into a new library module and then just import that
10:55:05 <startling> akosch: then why not the name of the module?
10:55:06 <Cale> akosch: Think about your new monad as a special purpose programming language: what is its purpose?
10:55:32 <johnw> so much of expertise seems to be having an ever deeper collection of boilerplate to draw from :)
10:55:44 <Cale> akosch: What monad transformers did you apply to which starting monad?
10:55:49 <startling> johnw: heh
10:56:00 <lispy> monad_magician: Data.Map.Strict may work better, but I can't test that
10:56:18 <mcstar> lispy: you mean Data.HashMap.Strict?
10:56:36 <akosch> I'm writing a little module on top of SDL and use ReaderT and StateT on IO
10:56:37 <johnw> akosch: I still do it, just so I'm clear that it's not a transformer for a general purpose
10:56:46 <mcstar> maybe there really is a Map.Strict that i dont know about
10:57:20 <Cale> mcstar: There is.
10:57:45 <Cale> mcstar: Starting in containers-0.5.0.0
10:57:49 <akosch> johnw: it's not for general purpose :)
10:57:57 <Cale> http://hackage.haskell.org/package/containers-0.5.1.0
10:58:07 <mcstar> thanks Cale
10:59:12 <Cale> akosch: What are the types of things that the ReaderT and StateT are giving you?
11:00:05 <Cale> Would it make sense to call the monad SDL?
11:00:37 <Cale> (is it supposed to wrap up all of SDL, or maybe some part of it?)
11:00:57 <akosch> Cale: it's hard to define the purpose succinctly enough for a type name: it provides a read-only context and some state for sequentially applying drawing actions
11:01:02 <hpaste> lispy annotated “BusyBeaver” with “custom compare saves off a bit more” at http://hpaste.org/76618#a76623
11:01:14 <Cale> akosch: How about Drawing?
11:01:17 <lispy> monad_magician: That should help even more
11:01:33 <lispy> monad_magician: Notice that I tried to reduce the number of constructors to test at each value
11:01:46 <akosch> Cale: I guess I will go with that, that's my module name after all ;)
11:01:53 <lispy> monad_magician: It's down to almost 1s here (from the original 2.7s)
11:14:36 <tromp> > map (*5) [174,238]
11:14:38 <lambdabot>   [870,1190]
11:15:12 <monad_magician> ls
11:16:46 <mcstar> hm, i tried HashMap, didnt help, much, but helped some
11:16:59 <mcstar> 2.2 vs. 2.8
11:17:22 <mcstar> it would do better with lispy's modifications
11:17:52 <monad_magician> right
11:18:08 <monad_magician> why would the origanl tupley version be much slower?
11:18:11 <monad_magician> original*
11:20:22 <mcstar> you could take a look at the core they generate, and look for unboxing
11:20:25 <mcstar> and strictness
11:27:06 <startling> so I've got a class Curses s a | s -> a where attrs :: [a] -> c () . I want a class Colored s c where fg :: c -> s; cyan :: c
11:27:17 <mcstar> 1.44s
11:27:35 <startling> such that the s in Colored is the same as the s in Curses, so I could do attrs [fg cyan] without ambiguity
11:27:38 <startling> any advice?
11:33:51 <colah> Anyone know how to get Snap to cache? I have a fully referentially transparent REST API, but requests are quite computationaly expensive. It would be nice if I could remember the results of old requests instead of recomputing them.
11:33:53 <squidz> i'm having problems implemlenting this line in haskell. http://en.wikipedia.org/wiki/K-means_clustering#Standard_algorithm specifically the line where points for a set Si are being calculated, can somebody guide me a little please
11:34:38 <c_wraith> colah: Snap has nothing for that.  You could write it yourself, easily enough.
11:35:15 <c_wraith> colah: with a fair bit more work, you could probably define an app-independent caching layer.
11:35:41 <c_wraith> colah: and as a third option, you could just use an independent proxy layer like varnish
11:35:45 <squidz> I only see that I have to iterate through 'mi' as well as iterate through 'mj'. I can't figure out how to do it functionally though with haskell. I only see iteration
11:36:22 <atriq> I actually had a nightmare about programming in Haskell last night
11:36:36 <c_wraith> squidz: that line looks like it should translate to a list comprehension almost trivially
11:36:53 <hpaste> jeff_s pasted “unbound type variable compiles” at http://hpaste.org/76624
11:36:59 <atriq> Someone had put a nasty virus on Hackage that had a similar name to another package (I think it was "vualt" or something like that)
11:37:01 <nand`> I have recurring dreams about Haskell. Fortunately, none of them have been nightmares as of y et
11:37:09 <c_wraith> > [ (x, y) | x <- [1..5], y <- [10..13] ]
11:37:10 <lambdabot>   [(1,10),(1,11),(1,12),(1,13),(2,10),(2,11),(2,12),(2,13),(3,10),(3,11),(3,1...
11:37:11 <jeff_s1> Why does the code in my hpaste compile?
11:37:16 <atriq> And it killed people?
11:37:24 <atriq> edwardk was trying to fix it
11:37:51 <maukd> > undefined :: a b
11:37:52 <lambdabot>   No instance for (GHC.Show.Show (a b))
11:37:53 <lambdabot>    arising from a use of `M5717279774...
11:38:02 <maukd> jeff_s1: why not?
11:38:05 <c_wraith> jeff_s1: all type variables in haskell implicitly are universally quantified at the top level
11:38:08 <atriq> Then it got all Psychonauts and Homestuck
11:38:10 <atriq> :(
11:38:22 <startling> nand`: thankfully I have yet to run into an ambiguity error in my sleep
11:38:29 <mcstar> ive been killing those flying saws from HL2, esterday night, though i havent played it in years
11:38:37 <jeff_s1> I've been making a modified version of aeson, and the same function does not compile, saying the type variable 't' is unbound in the context.
11:39:26 <squidz> c_wraith: hm I'm not really seeing it. I know list comprehension would be probably the best way to translate that line, but I tried and got stuck because I ended up having to use list comprehensions within list comprehensions
11:40:00 <atriq> It was a weird nightmare
11:40:09 <colah> c_wraith: Thanks. Latency is potentially a big issue for me as well, so I'm not sure if varnish would work, but I'll look into it. Otherwise I'll write my own, I guess....
11:40:13 <sclv_> dcoutts: ping
11:40:23 <atriq> Got me thinking about actually writing a virus in Haskell and distributing it through Hackage
11:40:42 <sclv_> anyone familiar with cloud haskell hanging about?
11:40:52 <startling> squidz, you can do that
11:40:57 <rwbarton> > ord ('A' :: a)
11:40:58 <lambdabot>   Couldn't match expected type `a'
11:40:58 <lambdabot>         against inferred type `GHC.Types.C...
11:41:06 <startling> atriq, replace ghc with an executable that just spits out a huge type error
11:41:34 <c_wraith> colah: well, if you decide to do it in-process, I wrote a handy lru cache package, and put on hackage.  It's pretty much designed for doing things like that.
11:41:47 <squidz> startling: c_wraith ill give it another shot with list comprehensions and if i get stuck ill come back
11:42:13 <mcstar> atriq: imagine all the helpless billions of haskell users throughout the galaxy!
11:42:33 <mcstar> infecting hackage would be soo devastating
11:42:49 <startling> I imagine haskell would be the language of choice for interstellar navigation
11:42:56 <mcstar> you would turn back the economical clock to 1930!
11:43:01 <Hochmeister> hello. can someone help me errors when trying to install pandoc? I'm getting "Unacceptable result type in foreign declaration: CInt".
11:43:10 <c_wraith> squidz: if you do need help, put all the code you've got so far on hpaste, and post the link in here when you ask for it.  It'll help people figure out what you need to know.
11:43:52 <c_wraith> Hochmeister: that implies a version mismatch between a library pandoc's using and the version of ghc you're using. I don't know what the fix is, though.
11:44:15 <c_wraith> Hochmeister: unless you can go to an older version of ghc
11:44:54 <startling> Hochmeister, what does ghc --version say?
11:44:57 <Guest34658> byorgey: re. promoting type variables: this is my use-case: https://code.google.com/p/omega/source/browse/mosaic/Singletons.lhs
11:47:40 <gabor> byorgey: do you think it would make sense to categorize (e.g. by a Constraint) whether a type can be promoted?
11:47:41 <Hochmeister> startling, version 7.6.1
11:48:28 <rwbarton> pandoc hasn't been updated to work with 7.6
11:48:44 <rwbarton> it is presumably possible to do so but would involve some unknown amount of work
11:49:06 <startling> Hochmeister: yeah, sounds like pandoc's out of date.
11:49:35 <c_wraith> I think you could compile pandoc with ghc 7.0
11:49:42 <c_wraith> but probably not anything newer
11:50:01 <c_wraith> (well, 7.0.*)
11:50:03 <startling> works on 7.4.2 for me
11:50:07 <rwbarton> nah, it works fine on 7.4
11:50:11 <c_wraith> really? was the FFI change that recent?
11:50:13 <startling> with a slightly old blaze-html
11:50:24 <c_wraith> I thought it was in 7.2.  silly me
11:50:27 <rwbarton> what was the ffi change anyways?
11:50:49 <c_wraith> It needs constructors to be in scope for its types.
11:50:54 <c_wraith> It didn't need that before
11:50:58 <rwbarton> oh
11:51:02 <c_wraith> So the fix is probably just some imports somewhere
11:51:13 <rwbarton> yeah
11:51:16 <rwbarton> http://stackoverflow.com/questions/11112287/warning-newtype-cint-is-used-in-an-ffi-declaration
11:52:39 <burbul> What's the right equivalent of this line (in a .cabal file)?
11:52:40 <burbul> ghc-options: -fwarn-unused-matches,warn-dodgy-exports,warn-dodgy-imports
11:52:54 <burbul> I've tried ghc-options: -fwarn-unused-matches -fwarn-dodgy-exports -fwarn-dodgy-imports
11:53:01 <burbul> ghc-options: -fwarn-unused-matches, -fwarn-dodgy-exports, -fwarn-dodgy-imports
11:53:26 <burbul> I must be missing something obvious here...
11:54:51 <Cale> it's apparently just a token list of the options, you shouldn't need the commad
11:54:54 <Cale> commas*
11:54:59 <geekosaur> looks like the first should work.  might need to cabal configure again?
11:55:22 <jfischoff> how do make newlines with haddock?
11:55:34 <burbul> Cale: so -fwarn-unused-matches warn-dodgy-exports warn-dodgy-imports
11:55:35 <burbul> ?
11:55:43 <burbul> no, that doesn't work
11:55:45 <Cale> no, you'll need the -f's
11:56:19 <Hochmeister> ok I read about that issue. so I'm going to attemp to use and older version.
11:56:21 <burbul> [geekosaur: I cleaned before each try]
11:56:42 <burbul> keep getting "ghc.exe: unrecognised flags: -fwarn-unused-matches, -fwarn-dodgy-exports"
11:56:50 <xplat> fwarns don't sound quite as pleasant as funboxes
11:56:56 <burbul> (even without commas)
11:57:11 <Cale> burbul: then maybe those aren't options to whatever version of GHC you have installed?
11:57:17 <burbul>  version 7.4.1 ?
11:57:19 <Cale> It's GHC complaining about the options it's being passed
11:57:36 <burbul> yes, sorry --- the error message changed halfway through and I didn't spot it until just now
11:58:29 <rwbarton> ghc doesn't print a comma between unrecognized flags here
11:58:36 <Sami235>  I have a few question regardsing DSL
11:58:49 <Sami235> can anyone help?
11:59:03 <startling> Sami235, what's your question?
11:59:05 <rwbarton> so i guess "-fwarn-unused-matches, -fwarn-dodgy-exports" must be getting sent as a single flag?
11:59:06 <Cale> There was probably a comma after -fwarn-unused-matches because that was a valid flag in 7.4.1
11:59:17 <rwbarton> yeah
11:59:33 <Cale> -fwarn-dodgy-exports doesn't appear to be in the documentation?
11:59:36 <rwbarton> -fwarn-dodgy-exports is a thing too though
11:59:39 <burbul> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/options-sanity.html
11:59:41 <rwbarton> at least my ghc didn't complain about it
11:59:41 <Cale> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/flag-reference.html
11:59:52 <Cale> oh, hmm
12:00:00 * hackagebot ty 0.1.0 - Typed type representations and equality proofs  http://hackage.haskell.org/package/ty-0.1.0 (ConalElliott)
12:00:12 <Cale> okay then :)
12:00:42 <Sami235> I need to design a datatype for representing structured data
12:01:03 <monad_magician> I got my turing machine down to 0.4 seconds by using pattern matching instead of looking up a Data.Map
12:01:11 <Sami235> It should allow useres to represent inetger, string, pairs and lists
12:01:13 <burbul> Oh, wait -- I think it was the latest version of Leksah being stupid
12:02:03 <burbul> (It wasn't saving the changes to the .cabal file automatically, which I think the previous version did. . Sorry about that, and thanks for the help.)
12:04:27 <startling> Sami235, what's wrong with haskell strings numbers pairs lists etc?
12:05:37 <nand`> Sami235: what; like (,), Either and () ?
12:06:24 <Tobius> Hi all - I have a fairly simple problem, but in spite of searching I can't seem to find a simple solution...  I want to join two showable things together, probably they are both Strings, but I don't want to limit it to work with only Strings.  As such, I'm using "show" to ensure I get a String to work with.  The problem is that...   bob ++ show bob  yields:  "bob\"bob\""  .
12:06:41 <Tobius> My question is:  how do I show without having escape characters in the output?
12:07:07 <Sami235> Ok for example, ["hello",1234,"Good",[2,3,4]]
12:07:21 <nand`> data Cat a b = Cat a b; instance (Show a, Show b) => Show (Cat a b) where show (Cat a b) = show a ++ show b
12:07:23 <nand`> ?
12:07:27 <maukd> Tobius: I don't understand your question
12:07:42 <Sami235> then I need to define a function called valide::Constraint->Data->Bool
12:07:43 * ski thinks that list is unstructured
12:08:44 <Sami235> that should return True if the given data satisfies the given constraint
12:08:48 <Tobius> nand`: thanks, I'll give that a try!
12:09:00 <rwbarton> that is not going to solve your problem
12:09:57 <Sami235> one example could be: valid ineteger ["hello",1234,"Good",[2,3,4]]
12:10:22 <Sami235> if the datum is an integer
12:10:38 <Tobius> That gives me...  "bob""bob"...  ideally, I'd like to get "bobbob"
12:10:49 <rwbarton> you should not attempt this
12:10:54 <rwbarton> just insert show calls where you need to
12:14:00 <minimalis> would this work?
12:14:04 <minimalis> newtype TobiusString =  TobiusString { innerString :: String }
12:14:14 <minimalis> instance Show TobiusString where show (TobiusString s) = s
12:14:30 <rwbarton> yes, in a sense
12:14:40 <rwbarton> then you have to insert TobiusString anywhere that you do have a string, though
12:14:43 <minimalis> true
12:14:45 <rwbarton> and if you forget, you get the wrong behavior
12:15:02 <nand`> proper behavior is to not use ‘show’
12:16:58 <rwbarton> i see a lot of this "false generalization"
12:17:00 <minimalis> agree, not using show is a better idea
12:17:18 <rwbarton> "my function works with type T but I want to use it with anything that can be converted to T so I precomposed by function with toT"
12:17:26 <rwbarton> that adds nothing, the user can just call toT themselves
12:18:07 <sami683> I need to design a datatype Data, for representing a structured data. it should allow users to represent integer, string, pairs and list.
12:18:17 <monad_magician> http://ideone.com/7PjXgJ I've optimized my haskell turing machine by turning the Data.Maps into functions. Is that a good idea?
12:18:20 <rwbarton> sami683: you should talk to this guy Sami235
12:19:04 <gwern> @quote
12:19:04 <lambdabot> wli says: Monads are like constipation. Comonads are like Ex-Lax.
12:19:40 <monad_magician> data Data a = a
12:19:45 <sami683> I need to design a DSL for expresing constraint which can validate data
12:20:10 <sami683> Like: validate::Constraint->Data->Bool
12:20:11 <mcstar> monad_magician: depends how many states you want, it can be more flexible to just fill the map
12:20:16 <sami683> can anyone help?
12:20:34 <mcstar> monad_magician: how did it work out performance wise?
12:20:38 <johnw> Cale: is the "identity + binary associative operator" thing what is meant by "unital associative algebra"?
12:20:58 <ski> johnw : yes
12:21:28 <johnw> cool
12:21:31 <monad_magician> mcstar: it's now 0.4 seconds, down from 0.7 (Lispy's optimizations)
12:21:36 <lawoju> lmlkml
12:21:51 <monad_magician> I don't get it; my C version is actually less memory efficient than the Haskell version, yet the Haskell version is 4.4 times slower
12:23:42 <mcstar> i'd follow Bruce Lee's advice
12:23:46 <clahey> monad_magician: What data structure did you use in C?
12:24:11 <monad_magician> clahey: I used an array for the transition table, and a doubly-linked list for the tape
12:24:17 <johnw> and when it is said that monads are monoids in the category of endofunctors, are the endomorphisms of that monoid category what we sometimes call "monadic values"?
12:24:22 <janiczek> hi guys, what do exclamation marks mean in datatype definitions? (I've seen them in arrays, but not like this): `data Zipper a = Zip ![a] ![a] deriving (Eq,Show)` - from Data.List.Zipper module source...
12:24:32 <mcstar> strict fields
12:24:45 <mcstar> those dont require lenguage extension
12:24:50 <clahey> monad_magician: Wow.  I would have expected that to be slower.
12:25:21 <clahey> monad_magician: I bet if you were willing to use C++ you could get a bunch of speed improvements from std::map and std::deque.
12:25:32 <clahey> monad_magician: What's the latest version?
12:25:34 <janiczek> mcstar: and what does that mean (strict) ? I only know it has something to do with strict vs lazy, but ... not much more
12:25:51 <monad_magician> I'm using gcc 4.7.2
12:26:04 <clahey> monad_magician: Does that mean you can't use C++?
12:26:12 <monad_magician> means I can use C++11 :D
12:26:15 <clahey> :)
12:26:37 <clahey> I'm not entirely sure if deque would be faster.
12:26:54 <mcstar> janiczek: i think it is similar to an application of seq
12:27:06 <monad_magician> I think I'll go ahead and implement this silly turing machine in C++; that's 4 different languages I've done this now :D
12:27:11 <mcstar> i.e. it takes the expression and evaluates to whnf
12:28:08 <janiczek> mcstar: mhm ... does it have advantages? I thought lazy was the way to go for haskell ... :)
12:28:09 <mcstar> let x = <expr> in x `seq` Data x
12:28:19 <atriq> I've got some not very interesting lens questions which have not very interesting answeres
12:28:54 <mcstar> janiczek: you dont always want a build up of thunks
12:29:03 <mcstar> it can space leak, and slow down execution
12:29:11 <mcstar> for some purposes, it is necessary though
12:29:34 <clahey> In other cases, it can speed things up quite a bit.
12:29:53 <acowley> johnw: I interpret that description to be referring to monadic values as the objects of this category as the "m" type constructors are endofunctors over whatever category the types it is applied to come from. A monad "m" is an endofunctor on, say, Hask, so morphisms between such endofunctors would be a function between monadic values.
12:29:58 <mcstar> well, not in itself, but with sharing it can
12:31:20 <johnw> acowley: the composition in that monoid category is between m a and m b, or is it between m a -> m b and m b -> m c?
12:31:22 <janiczek> I guess I get why the strict approach was used in the list zipper ... probably because if you went left and right and left and right then with lazy evaluation you would have mess inside the structures, right? functions that are inverses of each other ...
12:31:56 <acowley> johnw: The latter, I believe.
12:32:05 <johnw> that makes sense
12:32:29 <johnw> since it's in the category of endofunctors, not endomorphisms
12:32:58 <rwbarton> are you just asking about "monads are monoids in the category of endofunctors"?
12:33:01 <hpaste> beaky pasted “foo” at http://hpaste.org/76626
12:33:03 <johnw> yes
12:33:14 <rwbarton> the endofunctors are on Hask
12:33:20 <monad_magician> http://hpaste.org/76626 any way I can make this function not blow the stack
12:33:23 <johnw> i'm trying to understand exactly the unital associative algebra of that monoid category
12:33:31 <rwbarton> it's a monoidal category
12:33:49 <rwbarton> the operation is composition of functors (from Hask to Hask)
12:34:01 <johnw> yes, and in the Monoid category for integer sums, the endomorphisms are integer values
12:34:01 <brunonery> hi guys, I'm confused about conduits. where's $$+- defined, and what's the difference to $$?
12:34:03 <acowley> Yes, the monoidal operation is join
12:34:04 <rwbarton> so like "f * g = \a -> f (g a)"
12:34:10 <johnw> oh, composition of functors
12:34:29 <startling> can I break a Text into a bunch of little Texts cheaply?
12:34:36 <rwbarton> a monoidal category is not a monoid
12:34:40 <rwbarton> well
12:34:42 <rwbarton> it sort of is
12:35:02 <rwbarton> but not in the same way that you are thinking of a correspondence between monoids and categories, that's something else
12:35:09 <johnw> so in the Monoid category for endofunctors, the endomorphisms are each particular functors for some m a -> m b?
12:35:14 <rwbarton> no
12:35:19 <rwbarton> first: "monoidal category" :P
12:35:52 <mcstar> janiczek: it is an optimization, there is nothing 'mess'ed up inside
12:35:59 <rwbarton> the category of endofunctors is not what you are calling a "Monoid category"
12:36:08 <rwbarton> it has many objects, all the different endofunctors of Hask!
12:36:29 <johnw> the definition said it was a "monoid _in_ the category of endofunctors"
12:36:33 <rwbarton> quite right
12:36:33 <johnw> so what exactly does that mean?
12:36:37 <rwbarton> exactly?
12:36:38 <johnw> a monoidal category?
12:36:46 <rwbarton> http://en.wikipedia.org/wiki/Monoid_object
12:36:50 <mcstar> it shouldnt change the semantics, and i *think* you cant make something strict to change the result, but i need confirmation on this one
12:36:59 <johnw> ok, I'll read that, thanks!
12:37:10 <rwbarton> in this case
12:37:22 <startling> well, better question: can I iterate through a Text and piece out certain parts efficiently?
12:37:27 <janiczek> mcstar: thanks for info ... :) I guess it would work with laziness too, it just makes sense to me (if I understand the difference correctly) that they want to get to the "unreducable" definition of the element asap...
12:37:30 <mcstar> for example, recursive bang pattern bindings are disallowed
12:37:32 <rwbarton> C = End(Hask) (objects are functors Hask -> Hask which you can think of as instances of Functor; morphisms are natural transformations)
12:37:40 <rwbarton> (x) = composition of endomorphisms of Hask
12:37:47 <rwbarton> I = the identity functor (Id a = a)
12:38:02 <mcstar> janiczek: whnf is not unreduceable
12:38:31 <rwbarton> M is going to be an object of C and it is the underlying functor of the monad
12:38:40 <rwbarton> mu and eta are join resp. return
12:38:49 <johnw> rwbarton: I'll have to stop you there, rwbarton
12:38:52 <rwbarton> and the diagrams are the monad laws
12:38:56 <johnw> rwbarton: and come back when I've grokked a bit more
12:39:06 <rwbarton> yep, okay :)
12:39:11 <acowley> johnw: I don't think you're that far off.
12:39:18 <johnw> rwbarton: but I'm very glad you've shown me that I'm close, but not quite there yet
12:39:28 <janiczek> mcstar: i don't really know the jargon :) just wanted to say that they don't want to have something like (head ((head (x : ys)) : zs)) lying there
12:40:00 * hackagebot gdiff-th 0.1.0.0 - Generate gdiff GADTs and Instances.  http://hackage.haskell.org/package/gdiff-th-0.1.0.0 (JonathanFischoff)
12:41:13 <rwbarton> johnw: probably the most important step will be to forget what you know about "Monoid categories" :)
12:41:20 <acowley> Also, I don't think the distinction between monoidal categories and monoids is as stark as rwbarton made out
12:41:41 <mcstar> i think ![a] is equivalent on matching the list's constructors, (:) and []
12:41:47 <johnw> yes, my understanding of Monoid is so far only based on intuitions developed from practical use of Monoid; I need to go back to the drawing board for that part
12:42:19 <rwbarton> there are two ways you can relate monoids and categories
12:42:28 <rwbarton> the one that is popular among haskellers is not the relevant one here
12:42:41 <Eduard_Munteanu> Categories are monoidoids :)
12:42:45 <johnw> haha
12:42:56 <Eduard_Munteanu> (no really, that's a real name)
12:43:03 <rwbarton> also irrelevant :)
12:43:15 <acowley> Not entirely!
12:43:21 <johnw> id and . seem sooo similar to mempty and mappend, and the fact that there is a function instance for Monoid confuses the distinction even more for me
12:43:47 <rwbarton> it is relevant if you want to start talking about monoidal categories as a certain kind of 2-category
12:43:53 <rwbarton> however, I'm fairly sure that johnw does not want to do that
12:44:00 <Eduard_Munteanu> Categories have a monoidal structure, if you're looking at that.
12:44:05 <acowley> No, it's relevant in that CT is sometimes described as a generalization of monoids
12:44:19 <acowley> due precisely to the connection johns has made
12:44:26 <rwbarton> but that is exactly the *irrelevant* connection here
12:44:26 <acowley> johnw, too
12:44:30 <Eduard_Munteanu> Yeah, he's right there.
12:44:57 <clahey> mcstar: From what I read about denotational semantics, I think ! can change the meaning of a piece of code, but only in a way that makes it less defined.
12:44:57 <rwbarton> nothing wrong about it but it will not help you understand what a monoidal category is (unless you already somehow understand what a 2-category is instead)
12:45:06 <Eduard_Munteanu> Mm, right, probably irrelevant if he's looking at monads.
12:45:16 <acowley> Well, it's not the right operation for the monads as monoids in, but I don't think we need to add so much ceremony to what it means to be a monoid
12:45:36 <sm0ke> hi, what is a functor i just dont understand!
12:45:48 <mcstar> clahey: do you have an example?
12:46:07 <johnw> sm0ke: well, you've come to the right place, but whether you will walk away satisfied from a single definition is entirely another matter
12:46:33 <bgamari> sm0ke, It's something that has a map operation
12:46:40 <Eduard_Munteanu> sm0ke: functors generalize mapping operations
12:46:46 <Eduard_Munteanu> :t fmap
12:46:47 <clahey> mcstar: take 5 [1..] where take 0 _ = []; take n (x:xs) = x:take (n-1) xs
12:46:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:46:48 <clahey> mcstar: Vs.
12:46:57 <clahey> mcstar: take' 5 [1..] where take' 0 _ = []; take' n !(x:xs) = x:take' (n-1) xs
12:47:09 <johnw> sm0ke: in a very simple, non-rigorous form: if a function is a mapping between types in Haskell (say, Int -> String), a functor is a mapping between data structures (say, [Int] -> [String]) which does not change the type or size of the data structure being mapped
12:47:23 <bgamari> sm0ke, e.g., in the case of a list, you can apply a function to each element to get a new list
12:47:53 <monochrom> LYAH has a good explanation of Functor. people say.
12:48:14 <mcstar> clahey: i dont see the problem
12:48:16 <johnw> Functors generalize mapping, but it's possible to write map-like operations which are not functors
12:48:17 <clahey> mcstar: Actually, that didn't make it break, because ! only forces a single layer.
12:48:18 <sm0ke> but why do we need a fancy name for mapping? cant we just write function which just return list for a list?
12:48:20 <clahey> mcstar: My mistake.
12:48:52 <johnw> sm0ke: the fancy name allows us to talk about mapping free from the particular language imposed by any specific data structure
12:48:53 <bgamari> sm0ke, Yes, but then you couldn't also use that function on say, a Set
12:48:58 <acowley> sm0ke: yes, but perhaps you want to write a function that works with anything that "supports the functor interface" as it were
12:49:06 <bgamari> although for unrelated reasons, that was a bad example
12:49:12 <acowley> hah
12:49:13 <bgamari> (Set)
12:49:15 <monochrom> Maybe and IO
12:49:16 <acowley> good, old Set
12:49:24 <clahey> mcstar: I'm just getting to know !
12:49:24 <acowley> always mucking things up for us
12:49:35 <monochrom> I disagree that "Functor" is a fancy name
12:49:36 <mcstar> clahey: you are alrady pattern matching on the list constructor, so the ! is totally useless there
12:50:01 * hackagebot classify 2012.10.22 - Library for classification of media files.  http://hackage.haskell.org/package/classify-2012.10.22 (DavidHimmelstrup)
12:50:19 <Eduard_Munteanu> monochrom: yeah, after all other PLs misuse it for other unrelated stuff. :)
12:50:35 <clahey> mcstar: Yeah, I figured that out.
12:51:00 <monochrom> you must at least give credit for being a short name. it's shorter than "Mappable"
12:51:02 <sm0ke> i dont know if i see the significance of a functor as of now...i have very limited haskell knowledge, but i am sure its there for a reason
12:51:17 <acowley> monochrom: fancy in the same way that people who speak another language than I do have fancy words for things I already know!
12:51:56 <monochrom> it is also not "just" "function which just return list for a list"
12:51:58 <Eduard_Munteanu> sm0ke: lists are functors, trees too, basically stuff which can take a function on its elements and apply it everywhere in that data structure.
12:52:16 * ski . o O ( uses of the word "functor" in C++,SML,Haskell,Prolog at <http://www.catonmat.net/blog/on-functors/> )
12:52:19 <monochrom> it is a type class that includes list, Maybe, IO, etc
12:52:31 <acowley> the page ski linked is very good
12:52:44 <sm0ke> makes sense
12:53:02 <monochrom> at the end, if you know what it does, you can go on to judge it as useful or useless, fancy name or not fancy name...
12:53:03 <ski> > fmap (fmap (^ 2)) (Just (Just 5))
12:53:04 <lambdabot>   Just (Just 25)
12:53:04 <acowley> Can anyone recommend a command line parsing library?
12:53:15 <Eduard_Munteanu> @hoogle getopt
12:53:16 <ski> > fmap (fmap (^ 2)) [Just 5,Nothing,Just 3]
12:53:16 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
12:53:16 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
12:53:16 <lambdabot> System.Console.GetOpt module System.Console.GetOpt
12:53:16 <monochrom> but if you don't know, you should withold your judgement
12:53:16 <lambdabot>   [Just 25,Nothing,Just 9]
12:53:26 <kirindave> :t fmap
12:53:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:53:32 <kirindave> :t fmap.fmap
12:53:33 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:53:42 <kirindave> Hello edwardk ;)
12:54:29 <sm0ke> on a completely different note, i have never seen an irc channel more helpful then this one :) ...thanks guys
12:54:29 <clahey> monad_magician: Do you have the latest version of your haskell version?
12:55:15 <monad_magician> I'm using ghc 7.6.1
12:55:23 <monad_magician> probably not the latest
12:55:28 <copumpkin> \o/ sm0ke
12:55:32 <clahey> monad_magician: I meant the latest version of your code.
12:55:35 <monochrom> 7.6.1 is new enough
12:55:48 <clahey> I'm on 6.12.1
12:56:16 <monad_magician> http://ideone.com/DKrDOW this is the latest
12:57:48 <gfredericks> are there any other well-known languages that have haskell's functional purity?
12:58:01 <acowley> Eduard_Munteanu: getOpt doesn't hold my hand as much as I'd like
12:58:18 <acowley> "well-known"
12:58:22 <MostAwesomeDude> gfredericks: You might have to define "well-known languages" first. Also apparently we aren't allowed to define "functional purity" as of last night. :3
12:58:59 <gfredericks> MostAwesomeDude: are there any other languages with more than two users that have haskell's that which we do not speak of?
12:59:17 <clahey> Okay.
12:59:18 <MostAwesomeDude> gfredericks: Joy.
12:59:29 <clahey> So when I change monad_magician's code to return an int instead of an IO ().
12:59:36 <MostAwesomeDude> I'm sure there are others.
12:59:41 <monad_magician> http://ideone.com/H5z7cc C version :D
12:59:45 <startling> I've got a data T = A | B [T]. is it alright to make it a Monoid instance with B [] as mempty etc?
12:59:46 <clahey> It runs out of stack space instead of working.
12:59:51 <clahey> I don't understand the difference.
13:00:01 * hackagebot Semantique 0.1.0 - Command-line tool for maintaining the Semantique database.  http://hackage.haskell.org/package/Semantique-0.1.0 (DavidHimmelstrup)
13:00:12 <clahey> I changed the base case to just return n, and it makes it kill the stack space.
13:00:22 <gfredericks> MostAwesomeDude: thanks!
13:00:32 <clahey> Can anyone help me understand why this is different?
13:01:05 <monochrom> is the code short?
13:01:10 <rwbarton> startling: depends on the "etc"
13:01:14 <ski> startling : as long as `mempty' and `mappend' are total and satisfies the laws, it should be fine
13:01:15 <mcstar> it was a bug of GHC 6.12.1, they didnt want to get rid of it, they called it a feature
13:01:56 <startling> ski: even if e.g. I do B [] `mappend` x = x ?
13:01:56 <clahey> monochrom: Was that question for me?
13:02:10 <mcstar> they argued: "who in their right minds wants to return an int?? lets make a SO out of this, to discourage others"
13:02:11 <monochrom> yes
13:02:33 <startling> I understand that the monoid laws are what matter, but I feel like there might be a reason this doesn't follow the monoid laws that I don't see. :)
13:02:34 <ski> startling : if `B []' is `mempty', then that would satisfy one of the identity laws
13:03:27 <startling> ski: fair enough
13:03:46 <ski> startling : you'd need to check the other laws as well, though
13:03:52 <startling> ski: sure
13:04:02 <clahey> monochrom: It's pretty short, yeah.
13:04:16 <rwbarton> and finish writing mappend :)
13:04:32 <startling> rwbarton: of course
13:04:39 <mcstar> clahey: do you have that function composition in run?
13:05:01 <mcstar> it is not needed, you could try without, just a hunch though
13:05:10 <u_quark> I get some `Unacceptable argument type in foreign declaration: CInt' with ghc 7.6.1 ... is that due to the new CAPI calling convention ?
13:05:42 <rwbarton> u_quark: http://stackoverflow.com/questions/11112287/warning-newtype-cint-is-used-in-an-ffi-declaration
13:06:00 <monochrom> it's due to following Haskell 2010 rules for real
13:06:06 <u_quark> tnx
13:07:04 <clahey> mcstar: I figured out that I was compiling wrong and that was part of it.
13:07:08 <monad_magician> what does seq do?
13:07:10 <monad_magician> :t seq
13:07:11 <lambdabot> forall a t. a -> t -> t
13:07:43 <startling> monad_magician: magic
13:07:44 <acowley> That type is the zombo of Haskell
13:07:53 <monochrom> seq makes things more strict. this may lead to more eagerness. in practice, it does lead to more eagerness
13:08:36 <monochrom> eagerness skips the bookkeeping overhead of laziness
13:08:46 <clahey> mcstar: Okay.  It turns out that it works on ideone and not on my local box.
13:09:01 <clahey> mcstar: I'm guessing there's a missing optimization because I have an old version of haskell?
13:09:12 <mcstar> ghc
13:09:15 <yiannis_t> u_quark: Did you manage to build your lambdabot? : )
13:09:15 <mcstar> maybe
13:09:29 <mcstar> clahey: so you compile with -O1/2 ?
13:09:31 <clahey> mcstar: An old version of ghc.
13:09:35 <u_quark> yiannis_t: still working on it
13:09:35 <clahey> -O2
13:09:44 <yiannis_t> u_quark: ghc?
13:10:02 <u_quark> yiannis_t: latest
13:10:04 <mcstar> clahey: can you paste the line? or annotate one of the pastes?
13:10:47 <clahey> mcstar: http://ideone.com/ffooJr is my version.
13:10:57 <clahey> Changes near line 49.
13:11:27 <mcstar> clahey: can you remove that function compositin as i suggested?
13:11:49 <mcstar> + is supposed to be strict btw
13:11:54 <kirindave> clahey: Begs for free monad.
13:12:15 <clahey> mcstar: So, the problem was profiling.
13:12:31 <clahey> kirindave: free monad?
13:12:43 <atriq> @hackage free
13:12:43 <lambdabot> http://hackage.haskell.org/package/free
13:15:00 <augustss> howdy
13:15:08 <atriq> Hey
13:15:19 <bgamari> Does cabal strip executables by default?
13:15:35 <kirindave> clahey: Yeah
13:15:49 <kirindave> clahey: Would let you build and interpret those programs much more easily.
13:15:53 <monochrom> yes
13:15:55 <kirindave> clahey: Even compose them.
13:16:21 <clahey> kirindave: Is there a tutorial or some such instead of just a hackage file?
13:16:37 <kirindave> Yes
13:16:38 <kirindave> one moment
13:16:39 <clahey> Oh, found something more like a tutorial.  No worries.
13:17:35 <kirindave> clahey: http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
13:17:54 <kirindave> clahey: And http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html is doing exactly what you want to do with a simpler language
13:18:05 <kirindave> clahey: See also FreeT, which lets you make programs that use IO.
13:19:23 <lispy> who maintains the gentle intro? I found a bug in it: http://www.haskell.org/tutorial/moretypes.html
13:19:49 <lispy> It should really mention BangPatterns instead of saying that ! can't be used in function signatures
13:20:37 <augustss> BangPatterns isn't in the standard yet, AFAIK.
13:21:02 <monochrom> I trust that you know that there was no BangPattern when the Gentle Introduction was written
13:21:08 <kirindave> It should be.
13:21:10 <kirindave> Who doesn't use it?
13:21:24 <kirindave> Like one of the two extensions everyone knows about
13:21:29 <lispy> monochrom: yes
13:21:37 <kirindave> The other being -XOhGodMakeTheMonomorphismWarningGoAwayIHope
13:21:54 <lispy> augustss: You're right, but I think it's disingenious to say that we can't do it. We can, but it requires a non-standard extension.
13:22:17 <augustss> Yeah
13:22:22 <clahey> Oh, I thought the other was to make string literals be polymorphic.
13:22:34 <colah> c_wraith: Thanks!
13:23:09 <aknagi> OMG! It's busier in here that #ruby
13:23:21 <startling> aknagi, but of course
13:24:34 <aknagi> Are you guys hipsters too? :)
13:24:57 <lispy> aknagi: Nah, I liked being ironic before it was cool
13:25:04 <aknagi> lol
13:25:12 <atriq> aknagi, I've been reading Homestuck since Act 2, and I watched the subs of Hetalia before the dubs came out
13:25:43 <shachaf> hi augustss
13:25:54 <shachaf> It's been a while!
13:25:56 <monad_magician> Haskell: http://ideone.com/DBEHHb vs. C: http://ideone.com/H5z7cc
13:26:01 <augustss> Hi shachaf
13:26:03 <aknagi> atriq: Very cool man:)
13:26:20 <MostAwesomeDude> atriq: I read Problem Sleuth when it was being written and stopped reading Homestuck halfway through the first act because I felt that he sold out. >:3
13:26:33 <atriq> MostAwesomeDude, oh, damn.
13:26:45 <MostAwesomeDude> atriq: But I've never seen Hetalia!
13:26:57 <MostAwesomeDude> Also I don't drink PBR, which I'm told is *the* tenet of hipsters.
13:27:01 <startling> is mappend for Text O(n) or what?
13:27:18 <atriq> MostAwesomeDude, Hetalia's became more mainstream since
13:27:53 <clahey> :k Free
13:27:54 <lambdabot> Not in scope: type constructor or class `Free'
13:28:16 <MostAwesomeDude> clahey: data Free f a = Free f (Free f a) | Pure a
13:28:25 <MostAwesomeDude> ...Also it's kinda sad that I know that one by heart.
13:28:42 <divyanshu> why is it not possible http://ideone.com/u9Abxq where as this runs http://ideone.com/EM8yrH
13:28:43 <clahey> MostAwesomeDude: Right.  I've got that in front of me, but what's its kind?
13:28:46 <startling> MostAwesomeDude, when lambdabot was down I /nick startlebot 'd.
13:28:46 <shachaf> MostAwesomeDude: That's the wrong kind.
13:28:54 <startling> MostAwesomeDude: I learned a lot about myself that day.
13:28:55 <rwbarton> it's "Free (f (Free f a))"
13:28:56 <MostAwesomeDude> shachaf: D'oh, you're right.
13:29:34 <MostAwesomeDude> Clearly I need to just stop saying things.
13:30:01 * hackagebot gdiff-th 0.1.0.1 - Generate gdiff GADTs and Instances.  http://hackage.haskell.org/package/gdiff-th-0.1.0.1 (JonathanFischoff)
13:30:15 <shachaf> clahey: Well, you can figure out the kind by typing it into ghci, or by looking at it. :-)
13:30:37 <divyanshu> rwbarton : Hi
13:30:51 <shachaf> It has kind x -> y -> *, where x is the kind of f and y is the kind of a.
13:31:08 <monochrom> perhaps you misunderstood the type of <*>? and so you wrote a wrong implementation?
13:31:15 <monochrom> @type (<*>)
13:31:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:31:58 <ezyang> So, how do I get cabal to generate Foo_stub.h files before attempting to compile C files?
13:32:32 <clahey> So, is Free [] an arbitrary width tree?
13:32:50 <shachaf> clahey: Cofree [] is Data.Tree.Tree
13:33:02 <hpc> @src Free
13:33:02 <lambdabot> Source not found. I am sorry.
13:33:40 <shachaf> > let free f a = pure a <|> fmap f (free f a) in free (+1) 0 -- iterate!
13:33:41 <lambdabot>   No instance for (GHC.Show.Show (f a))
13:33:41 <lambdabot>    arising from a use of `M9169143479...
13:33:47 <rwbarton> but Free [] is also a kind of tree
13:33:52 <shachaf> > let free f a = pure a <|> fmap f (free f a) in free (+1) 0 :: [Int]
13:33:53 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:34:03 <mcstar> hey, im back from my old lappy, in a real terminal, from emacs
13:34:47 <monochrom> tomorrow, you'll be in a real teletype
13:35:09 <byorgey> Free [] is the type of "parenthesizations" where parentheses can contain an arbitrary number of elements
13:35:14 <monochrom> P.S. teletype is why terminals are called tty
13:35:28 <byorgey> e.g.  (2 (3 4 5) 8 (9 0 (1) 6))
13:35:34 <clahey> shachaf: So Free [] would be a tree with no values at branches.
13:35:35 <mcstar> kind of obvious isn it?
13:35:47 <byorgey> clahey: right
13:36:05 <clahey> Or equivalently the set of parenthesizations.
13:36:09 <shachaf> byorgey: Makes sense.
13:36:27 <shachaf> data Tree a = One a | Lots [Tree a]
13:36:45 <shachaf> Just like lisp!
13:37:12 <byorgey> you get lisp by Freely nesting parentheses
13:37:13 <byorgey> hehe
13:39:03 <divyanshu> why is it not possible http://ideone.com/u9Abxq where as this runs http://ideone.com/EM8yrH
13:39:25 <monochrom> I just said, perhaps you misunderstood the type of <*>? and so you wrote a wrong implementation?
13:39:31 <lispy> yay, just like me!
13:39:47 <luksow> would you say that Haskell has 'built-in' concurrency? I'm preparing seminar about concurrency where I'm considering various programming languages and this group is particularly important
13:40:23 <MostAwesomeDude> luksow: Sure!
13:40:31 <monochrom> is 'built-in' really important?
13:40:42 <divyanshu> I think types are right
13:40:49 <merijn> luksow: Define built-in?
13:40:54 <lispy> Does the HP include any lens libraries?
13:41:01 <merijn> lispy: Don't think so?
13:41:02 <augustss> luksow: Define Haskell
13:41:04 <acowley> lispy: No
13:41:07 <johnw> One of the beauties of Haskell is that very little is "built-in", in the sense of other languages with special syntactic structures as builtins
13:41:22 <shachaf> Define "define" before you ask someone to define something, people!
13:41:28 <johnw> lol
13:41:28 <monochrom> "Node (fmap f tree) ..." clearly has type "f (f b)" as opposed to "f b"
13:41:41 <acowley> let define = define in define
13:41:50 <lispy> Someday I'd like to get the HP to update OpenGL/GLUT but they won't accept the StateVar dependencies and there doesn't seem to be anything in the platform to replace it. Seems like a stalemate.
13:41:52 <johnw> so define is _|_?
13:41:53 <luksow> well, it's not easy to define, I know :) for ex. Go is built with concurrency in mind and concurrent execution is part of its grammar so I consider it as a builtin concurrency language
13:41:58 <lispy> johnw: correct
13:42:13 <shachaf> ezyang: As far as I can tell it's supposed to just work. Does it not?
13:42:17 <johnw> so the least-defined meaning for Haskell is the best definition we can give
13:42:28 <MostAwesomeDude> luksow: By "concurrency" you're accepting cooperative solutions, right?
13:42:29 <lispy> the report!
13:42:48 <clahey> So, now I see the definition of a Comonad, but I don't yet understand what it would be useful for.
13:42:53 <luksow> MostAwesomeDude, sure :)
13:43:01 <johnw> clahey: see the Store comonad, for a useful example
13:43:06 <lispy> luksow: Many of us who use Haskell for real stick to GHC. In that context, we have good solutions for concurrency and parallelism and any overlap that those two should have.
13:43:12 <ezyang> shachaf: No, it seems to build the C sources too early
13:43:19 <acowley> lispy: Why won't they accept StateVar?
13:43:51 <startling> Is there some formalization for a MonadState that checks for duplicates?
13:43:58 <lispy> acowley: It introduces Data.StateVar, which is considered bad for the newbies.
13:43:59 <startling> err, I mean MonadWriter
13:44:07 <johnw> clahey: a somewhat common example of using a comonad is applying a "blurring" filter to an image bitmap; algorithmically comonads solve that particular problem very elegantly
13:44:17 <lispy> acowley: at least, that is my primitive understanding
13:44:18 <acowley> lispy: that's… annoying :/
13:45:02 * hackagebot gdiff-th 0.1.0.2 - Generate gdiff GADTs and Instances.  http://hackage.haskell.org/package/gdiff-th-0.1.0.2 (JonathanFischoff)
13:45:03 <clahey> johnw: Couldn't find the Store comonad.
13:45:03 <lispy> acowley: I was told to basically remove the package and put the things it creates under Graphics.Rendering.OpenGL.*, but since StateVar is used by OpenAL it seems like a bad idea.
13:45:04 * hackagebot confsolve 0.3.3 - A command line tool for resolving conflicts of file synchronizers.  http://hackage.haskell.org/package/confsolve-0.3.3 (DanielTrstenjak)
13:45:07 <monochrom> base introduces unsafeCoerce, which is clearly bad for the newbies. so, don't ship base in HP? :)
13:45:21 <startling> I guess I could just write tell to possibly fail.
13:45:22 <lispy> acowley: I was asking about lenses, because possibly I could drop StateVar and use a lens library instead
13:45:36 <lispy> acowley: that could be a nice win for everyone
13:45:41 <ezyang> Ah, here it is: https://github.com/haskell/cabal/issues/842
13:45:45 <acowley> The lens API is still too much in flux to go in the HP
13:46:21 <clahey> johnw: But blurring might help me understand quite a bit.
13:46:34 <acowley> lispy: Do OpenAL and OpenGL need to share values of the same StateVar type?
13:46:39 <startling> clahey, cellular automata can be modelled with comonads too
13:46:41 <lispy> maybe the HP should only be GHC, gcc, make, and cabal? (possibly some other tools like happy/alex/hsc2hs/c2hs) Specifally, maybe we shouldn't be trying to bundle specific libraries.
13:46:54 <clahey> startling: I'm reading such a blog post right this second.
13:46:57 <lispy> acowley: Not that I'm aware.
13:47:05 <startling> clahey: was just going to point you there. :)
13:47:12 <lispy> acowley: It's more than Khronos made both APIs and both use opaque reference types.
13:47:24 <acowley> lispy: Then, if it were me, I'd just copy the relevant modules into OpenGL, and leave StateVar on hackage.
13:47:26 <startling> I guess bluring is a rule for cellular automata
13:47:34 <lispy> acowley: StateVar turns those references into something that can be used like an IORef
13:47:43 <acowley> lispy: Yeah, I'm familiar with it
13:47:48 <johnw> clahey: http://stackoverflow.com/questions/8766246/what-is-the-store-comonad
13:47:53 <shachaf> ezyang: Yep, looks like you're right. For some reason I thought it worked.
13:48:16 <johnw> one way to solve the blurring problem is to represent your bitmap as a Store :)
13:48:17 <lispy> Hackage is a better way to get your libraries than the HP is.
13:48:18 <lispy> IMO
13:48:26 <acowley> lispy+1
13:49:27 <johnw> i've noticed that cabal-install 1.16's dependency resolver is *much* better than 0.14
13:49:43 <johnw> i haven't stumbled into cabal hell even once lately
13:50:01 <shachaf> I don't think that has to do with cabal-install's dependency resolver.
13:50:02 * hackagebot gdiff-th 0.1.0.3 - Generate gdiff GADTs and Instances.  http://hackage.haskell.org/package/gdiff-th-0.1.0.3 (JonathanFischoff)
13:50:13 <johnw> shachaf: no?
13:50:22 <startling> johnw: obviously you haven't tried interfacing with pandoc
13:50:30 <johnw> pandoc doesn't build with 7.6.1] yet
13:50:33 <rwbarton> hehe
13:50:35 <rwbarton> problem solved!
13:50:35 <johnw> so maybe I just haven't endured it yet
13:50:38 <johnw> :)
13:50:41 <acowley> johnw: the version on github does
13:50:48 <johnw> also, I use cabal-dev for any project with huge dependencies as a matter of course now
13:50:50 <acowley> johnw: but you need to pull in other deps from github
13:51:01 <johnw> acowley: cabal-meta actually makes that sort of thing quite easy to do
13:51:38 <acowley> I've not tried cabal-meta. I just clone from github and install in my local repo because I'm a cowboy.
13:51:41 <acowley> :P
13:51:48 <leod_> is there something like takeWhile except it also includes the first element that does not satisfy the condition?
13:52:03 <shachaf> leod_: No. :-(
13:52:07 <leod_> :(
13:52:57 <johnw> acowley: cabal-meta lets you have a sources.txt file full of GitHub URLs, and then it does dependency resolution across all of them at once
13:53:08 <johnw> https://github.com/yesodweb/cabal-meta
13:53:11 <johnw> it's in Hackage too
13:53:55 <johnw> I use it locally for building packages that use like 5 other local packages, all of which I'm hacking on at the same time, rather than figuring out which order to rebuild everything in
14:00:17 <shachaf> rwbarton: By the way, as far as I can tell GHC doesn't have a special case for strict packed fields.
14:00:26 <shachaf> Though I think it could?
14:00:43 <rwbarton> packed?
14:00:46 <rwbarton> as in the opposite of unpacked?
14:00:57 <johnw> counpacked
14:01:06 <shachaf> Right.
14:01:27 <shachaf> I guess "packed" means sort of the same thing as "unpacked", actually...
14:01:41 <shachaf> Boxed?
14:02:16 <rwbarton> that was my confusion, yes
14:03:12 <shachaf> I think it could apply an optimization there but it would probably only be relevant in some special cases.
14:03:46 <shachaf> (Though Data.Map would be one of them.)
14:14:34 <startling> so I've got something like data A a = A a | B | C
14:14:54 <ciaranm> sounds like a monad
14:14:59 <startling> I thought I'd be able to do fmap fn (A a) = A . fn $ a; fmap fn x = x, but I guess I can't.
14:15:02 * hackagebot xmonad-extras 0.10.1.2 - Third party extensions for xmonad with wacky dependencies  http://hackage.haskell.org/package/xmonad-extras-0.10.1.2 (DanielWagner)
14:15:11 <startling> ciaranm: sure
14:15:16 <startling> is there a trick to doing that?
14:15:52 <S11001001> startling: do you have "instance" in your code above it?
14:16:06 <startling> S11001001: yes
14:16:15 <maukd> startling: why do you guess you can;t?
14:16:41 <startling> maukd: because B is of one type when it needs to be of another type
14:16:50 <maukd> right
14:17:03 <startling> so, is there a trick? or do I have to write it for each constructor?
14:17:26 <maukd> unsafeCoerce
14:17:33 <Peaker> don't do that..
14:17:48 <Peaker> startling, just enumerate all the constructors -- or use the "DerivingFunctor" GHC extension
14:18:20 <Peaker> startling, or possibly group all of these constructors under a different type:
14:18:24 <Peaker> data BC = B | C
14:18:39 <Peaker> data A a = A a | BC BC
14:18:40 <startling> Peaker: huh, for some reason I thought DeriveFunctor wouldn't do trickier instances
14:18:47 <startling> that does the trick nicely. thanks
14:18:54 <johnw> so cabal-dev install BlogLiterately worked fine with HTTP and pandoc, it was regex-pcre-builtin that died...
14:19:00 <rwbarton> this isn't a very tricky instance
14:19:14 <startling> rwbarton, I was lying
14:19:21 <johnw> (on 7.6.1)
14:19:29 <shachaf> DerivingFunctor can do some pretty tricky instances.
14:19:43 <startling> yeah. very cool
14:19:49 <shachaf> (Are there valid Functor instances that it can't do?)
14:19:53 <Peaker> With the derive package, you can derive Foldable, Traversable too which is cool
14:20:00 <Peaker> shachaf, maybe with GADTs?
14:20:00 <startling> glad computers are finally doing work for me!
14:38:57 <johnw> @hoogle (~>)
14:38:57 <lambdabot> No results found
14:39:37 <johnw> BlogLiterately is using ~> without importing anything
14:39:47 <johnw> is this a GHC language extension that got moved to another name in 7.6.1?
14:40:05 <merijn> johnw: I think 7.6 changed the way type level operators and variables worked
14:40:11 <ciaranm> last time i saw ~> it was for "reduces to"
14:40:15 <merijn> johnw: Breaking lots of stuff. Maybe it's related?
14:40:33 <merijn> (I know ~> was a common variable name for arrows)
14:41:00 <merijn> i.e. "Arrow (~>) => b ~> c" instead of "Arrow a => a b c"
14:41:06 <johnw> it's using it to define whenA, but bool-extras has a function with almost the same type signature, so maybe I don't need this special version
14:41:54 <johnw> yes, that fixed it
14:42:24 <johnw> yay, pandoc and BlogLiterately are built with 7.6.1!
14:42:42 <monad_magician> data Tape a = T [a] a [a] a -- Is there a way to 'annotate' this so that people know what [a] and a are supposed to be?
14:42:52 <hpc> monad_magician: a record
14:43:10 <notdan_> monad_magician: I recommend using zippers for (infinite) tape
14:43:14 <hpc> data Tape a = T {before :: [a], cursor :: a, after :: [a], dunnoWhatThatIs :: a}
14:47:36 <johnw> ok, https://github.com/jwiegley/BlogLiterately/tree/ghc-7.6-compat does the trick
14:48:12 <johnw> that and https://github.com/bgamari/regex-pcre-builtin
14:48:26 <johnw> everything else is just from current hackage
15:04:29 <monad_magician> vim tm.hs
15:10:16 <lightquake> monad_magician: this isn't a terminal :P
15:11:28 <hpc> [sudo] password for monad_magician:
15:12:02 <monad_magician> > System.Cmd.system "vim"
15:12:03 <lambdabot>   Not in scope: `System.Cmd.system'
15:12:31 <merijn> monad_magician: lambdabot can't do IO, for obvious security reasons
15:12:45 <monad_magician> ^^
15:13:25 <derrida> Could someone help me understand why this is happening: http://sprunge.us/MDcX - I've run into this a few times but still not sure what I'm doing wrong to cause it or how to remedy it.
15:13:39 <squidz> if I have a list [(1,10), (1,11), (2,20)] how could I extract the unique  values like so [(1,[10,11]), (2,20)]?
15:13:59 <ciaranm> your types don't make sense
15:14:07 <shachaf> > groupBy ((==) `on` fst) [(1,10), (1,11), (2,20)]
15:14:08 <lambdabot>   [[(1,10),(1,11)],[(2,20)]]
15:14:24 <squidz> thanks shachaf
15:14:25 <shachaf> Oh, not quite, I guess.
15:14:31 <squidz> oh right
15:14:36 <squidz> thats not what i meant
15:15:00 <int80_h> hello everyone
15:15:02 <squidz> i meant this [(1,[10,11]), (2,[20])]?
15:15:15 <shachaf> > map (fst . head &&& map snd) $ groupBy ((==) `on` fst) [(1,10), (1,11), (2,20)]
15:15:17 <lambdabot>   [(1,[10,11]),(2,[20])]
15:15:57 <squidz> wow there's no simpler way?
15:16:19 <monad_magician> :t &&&
15:16:20 <lambdabot> parse error on input `&&&'
15:16:23 <geekosaur> derrida, you have a package that is out of date for modern ghc, it tries to depend on both base and haskell98 at the same time and this has not worked for a while.
15:16:26 <merijn> squidz: Sure there are, just not on one line :p
15:16:30 <monad_magician> :t (&&&)
15:16:31 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:16:38 <monad_magician> :O
15:16:41 <merijn> squidz: Some helper functions and names will make that a lot simpler
15:16:54 <geekosaur> porting the package probably involves removing the haskell98 package from the list of dependencies, then finding and replacing uses of obsolete package names with their modern replacements
15:17:05 <merijn> monad_magician: It's using the Arrow instance of (->), mentally you can just replace a with (->) there
15:17:17 <squidz> merijn: i think in my case it will be better to leave it as a one liner, but out of curiousity how would I do it otherwise
15:18:17 <merijn> monad_magician: i.e. "Arrow a => a b c -> a b c' -> a b (c, c')" becomes "(->) b c -> (->) b c' -> (->) b (c, c')" simplifies to "(b -> c) -> (b -> c') -> b -> (c, c')"
15:18:39 * monad_magician : ParseError
15:18:42 <merijn> squidz: Why would it be better as a one liner?
15:18:49 <monad_magician> what's an Arrow?
15:19:03 <merijn> monad_magician: Even the last type signature is ununderstandable?
15:19:07 <derrida> geekosaur: I see, thank you, I wanted to be sure it wasn't something I was doing. I'll take a closer look and see if it's something I can fix.
15:19:35 <squidz> merijn: because I have this so far http://hpaste.org/76633
15:19:51 <merijn> monad_magician: Just an abstract typeclass like Monad, Functor, etc. an arrow is just an interface for things that map an input to an output
15:19:51 <kulakowski> I'm having a bit of trouble with cabal-install. It's claiming that my symlink-bindir does not exist, and it most certainly does. It's obviously not that huge of a deal to manually link things over, but I'm curious what I might be overlooking.
15:20:25 <monad_magician> aren't those functions?
15:20:28 <merijn> monad_magician: Functions happen to be a very convenient trivial case of "things that map an input to an output"
15:20:31 <monad_magician> ah
15:20:43 <merijn> monad_magician: No, think of for example stream transformers
15:21:24 <merijn> Which can turn a stream of type b into a stream of type c (and using the arrow class, combine streams, etc)
15:22:17 <merijn> monad_magician: There's a (reasonably readable) nice paper discussing arrows and non-function things you can use them for
15:22:48 <merijn> monad_magician: Although, if my type signature simplification didn't make sense to you it might be a bit to complicated
15:22:56 <monad_magician> :D
15:23:09 <startling> merijn, care to point me to that paper?
15:24:19 <merijn> monad_magician, startling: The papers to look at are "Generalising Monads to Arrows" and "Programming With Arrows", both by John Hughes
15:24:30 <startling> merijn: thanks!
15:24:43 <merijn> monad_magician, startling: They get a tad complicated by the end, but the beginning should be relatively simple and still teach you quite a bit
15:25:06 <monad_magician> functional programming has all these new stuff I've never even imagined/heard about in imperative programming. No java/c# developer has "Monad" or "Arrow" in his vocabulary ^^
15:25:29 <merijn> monad_magician: C# has monad(s) (well, at least one)
15:25:29 <johnw> monad_magician: it's more than he's unaware of the abstractions at that level
15:25:31 <johnw> s/than/that
15:25:33 <merijn> LINQ is a monad :p
15:25:49 <startling> monad_magician, and we don't use Singletons and AbstractBeanFactories
15:25:56 <maukd> merijn: [] is a monad
15:26:05 <merijn> maukd: True
15:26:27 <merijn> maukd: But I don't think C# has bind for lists by default?
15:27:11 <monad_magician> Why do haskell folks never speak about Singletons, AbstractFactories, and Strategy/Visitor, while C# developers never factor in closures or monads?
15:27:46 <startling> monad_magician, because our languages have different kinds of abstractions
15:28:06 <startling> monads are kind of annoying in languages without haskell's type system, for example
15:28:30 <hiptobecubic> there was that example of monadic python that looked pretty decent i thought
15:29:09 <merijn> monad_magician: Visitor is just fmap and/or traverse, I think
15:29:49 <merijn> Singletons only really make sense for mutable data I think?
15:29:56 <startling> yeah
15:30:31 <merijn> AbstractFactories only exist because Java is freaking braindamaged
15:30:36 <monad_magician> lol
15:30:38 <merijn> Anyhoo, bed time
15:30:44 <monad_magician> what are AbstractFactories
15:30:50 <u_quark> anyone know what `__hscore_hs_fileno' could be ?
15:31:08 <ciaranm> monad_magician: http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html
15:31:09 <johnw> it's one of the FFI utility functions in the GHC libraries
15:31:23 <johnw> as in "hs core"
15:31:32 <johnw> it likely calls fileno()
15:32:22 <u_quark> did 7.6.1 change that too ?
15:32:30 <johnw> change it in what sense?
15:33:39 <u_quark> in the sense that it isn't there anymore
15:34:03 <johnw> the typical reason I've seen for all these __hscore functions is to abstract operating system variant function calls
15:34:08 <johnw> yeah, maybe it's gone, dunno
15:34:16 <johnw> i'd check the VCS history for GHC
15:34:30 <u_quark> ok
15:35:04 * hackagebot iptadmin 1.3.1 - web-interface for iptables  http://hackage.haskell.org/package/iptadmin-1.3.1 (EvgenyTarasov)
15:37:44 <squidz> merijn: sorry but what package does the function `on` belong to?
15:38:01 <johnw> Data.Function
15:38:39 <squidz> thanks johnw
15:39:09 <johnw> for my friendly cephalopod, anytime
15:46:15 <Nereid> squidz:
15:46:16 <Nereid> @hoogle on
15:46:17 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
15:46:17 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
15:46:17 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
15:46:36 <Nereid> @where hoogle
15:46:37 <lambdabot> http://haskell.org/hoogle
15:46:38 <Nereid> @where hayoo
15:46:38 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
15:47:00 <John370> Hi everyone
15:47:18 <typoclass> John370: hello
15:47:28 <John370> I have a question regarding DSL
15:48:05 <John370> I need to design a datatype, called Data, for representing structured data
15:48:18 <maukd> data Data deriving Data
15:48:31 <rwbarton> better fully qualify that class name
15:48:39 <maukd> Data.Data.Data
15:48:45 <John370> the datatype should allow the user to represent string, integer, list and pairs
15:49:08 <John370> can anyone help?
15:49:09 <maukd> data Data = S String | I Integer | L [Data] | P Data Data
15:49:24 <John370> I created something very similar
15:49:27 <maukd>   deriving (Eq, Ord, Read, Show)
15:49:33 <John370> thank you maukd
15:49:45 <John370> but the problem is after this
15:50:17 <John370> now I have to design a DSL for expressing constraint, with which on can validate data
15:51:00 <John370> validator function is of type  validate::Constraint->Data->Bool
15:52:07 <John370> A list of possible Constraint combinator is also given
15:52:28 <squidz> Nereid: thanks
15:53:04 <John370> false::constrain --this constraint always fails
15:53:24 <John370> true::constraint--this Constraint always succeeds
15:53:34 <Nereid> type Constraint = Data -> Bool
15:53:44 <John370> integer::Constraint --the datum is an integer
15:54:14 <Nereid> (or a newtype)
15:54:33 <John370> above::Integer ->Constraint--the datum is an integer greater than given argument
15:55:45 <John370> some validation example: validate false ["hello", 2756, "primes",[2,3,5,7]]
15:56:26 <maukd> John370: where are you stuck?
15:56:31 <John370> output: error:expected the impossible, but found ["hello",2765,"primes",[2,3,5,7]]
15:57:28 <maukd> John370: wait, what output?
15:57:32 <maukd> it's supposed to return a Bool
15:58:34 <John370> output for: validate false ["hello",2765,"primes",[2,3,5,7]]
15:58:47 <maukd> yes, this makes no sense
15:59:08 <John370> I have a few more if you want I can show you
15:59:41 <maukd> that won't make this make sense
16:00:33 <John370> I really need help
16:00:40 <John370> sorry
16:13:50 <John370> this is my datatype: data Data: I Integer|S String|List [Data]|Pair (Data,Data)
16:14:07 <John370> I need to design a DSL for expressing constraint
16:14:35 <John370> with which one can validate data. in its simplest form a validator is a function of type
16:14:54 <John370> validate::Constraint->Data->Bool
16:15:43 <John370> Can anyone help me to design Constraint
16:15:59 <John370> some possible Constraint combinators:
16:16:24 <John370> false::Constraint--This constraint always fails.
16:16:37 <John370> true::Constraint--This constraint always succeeds.
16:16:55 <John370> integer::Constraint--The datum is an integer.
16:17:37 <John370> some example validations:
16:17:38 <John370> Main> ex
16:19:07 <maukd> John370: it seems like you're looking for someone to do your homework for you
16:19:33 <John370> I have done many parts of it
16:19:41 <John370> but I am stuck here
16:19:53 <John370> some help would be great
16:20:01 <maukd> define "help"
16:20:16 <Nereid> ok, hi
16:20:27 <Nereid> John370: are there any restrictions on what a Constraint could possibly be?
16:20:53 <Nereid> i.e. is there any reason why you can't do: type Constraint = Data -> Bool, validate = id?
16:21:01 <John370> help me to define function false
16:21:15 <Nereid> you need to figure out what the Constraint type is first.
16:21:35 <maukd> John370: are you just going to ignore any inconvenient questions?
16:21:42 <John370> I think it is of type Constraint ::Data->Bool
16:21:49 <John370> I think it is of type Constraint :: Data->Bool
16:21:54 <John370> not
16:22:08 <John370> there is not restriction on Constraint
16:22:21 <Nereid> by restriction I mean
16:22:28 <Nereid> could any function Data -> Bool be represented by a constraint?
16:22:38 <John370> as an example:
16:22:48 <John370> Main> ex
16:23:15 <Nereid> (fwiw "type Constraint :: Data->Bool" doesn't make sense*)
16:23:30 <Nereid> (* unless you have DataKinds which you should probably ignore)
16:24:14 <John370> I think when Constraint datatype is defined
16:24:32 <Nereid> John370: I'm trying to ask questions that would be helpful to think about.
16:24:50 <Nereid> I don't know what "Main> ex" is supposed to mean.
16:24:53 <John370> it will be used by function validate to basically validates the data
16:25:08 <Nereid> yes, that is understood.
16:25:08 <typoclass> John370: if you say a Constraint is a "Data -> Bool", that would mean a Constraint is a function which takes a Data and gives a Bool, right? i think for your "false" constraint, the next step would be that you try to write a function which takes one argument and gives back False
16:25:49 <John370> for false function this example is given
16:26:08 <janiczek> guys, is "do x1 <- return $ (...) \n x2 <- return $ (...) \n more of the same" an antipattern? :D is it necessary to raise every value through the return?
16:26:11 <John370> validate false ["hello", 2765, "Good", [1,2,3,4]]
16:26:53 <Nereid> (I hope not, as that last thing isn't a Data, nor even well-typed)
16:26:55 <John370> output: error: expected the impossible, but found ["hello", 2765, "Good", [1,2,3,4]]
16:27:36 <Nereid> John370: ["hello", 2765, "Good", [1,2,3,4]] doesn't make sense.
16:27:36 <Cale> janiczek: Use let
16:27:57 <hpc> janiczek: let x1 = ...; x2 = ... in more of the same
16:28:01 <Cale> janiczek: do ... ; let { x1 = ...; x2 = ... }; ...
16:28:03 <John370> ["hello", 2765, "Good", [1,2,3,4]] is just an example of type Data
16:28:06 <typoclass> janiczek: you're right, the "<-" cancels out the "return"
16:28:12 <Nereid> John370: it isn't
16:28:29 <Cale> (and you can leave out the braces and semicolons if you're not squishing it all onto one line
16:28:30 <Cale> )
16:28:46 <hpc> janiczek: after you desugar the do-notation, {x <- return expr; f x} is equal to f x
16:28:46 <typoclass> Nereid: he's means to represent his Data type, he doesn't mean a haskell list when he uses [ ]
16:29:02 <Nereid> well I hope he isn't typing it in verbatim then!
16:29:02 <hpc> by the monad laws
16:29:14 <janiczek> yeah I do it multiline, just thought maybe IRC wouldnt handle it well
16:29:31 <Cale> Well, that *is* one of the monad laws, exactly :)
16:29:41 <maukd> f expr
16:29:46 <typoclass> John370: i think for your "false" constraint, you should write a function which takes some Data and gives back False
16:29:51 <Cale> yes
16:29:53 <hpc> er, yeah that
16:30:54 <janiczek> but what if I want to rewrite one of the vars? like ... before I wrote x1 <- return "A" ... and then again x1 <- return "B" ... it should probably be encapsulated in State monad, but how to handle this? the let will throw an error, I think?
16:31:10 <Cale> janiczek: That's not rewriting anything
16:31:17 <John370> something like this: false _ =  False
16:31:18 <Cale> It's just shadowing the previous definition.
16:31:32 <hpc> you probably don't want to be doing that, in any event
16:31:52 <Cale> Yeah, that'll mostly just result in confusing code
16:32:04 <typoclass> John370: yes, that's a good start
16:32:07 <Cale> without doing anything different from the case where you name the variables differently
16:32:14 <maukd> let {x1 = "A"}; let {x1 = "B"}; ... should work just fine
16:32:25 <hpc> if you don't mind some harsh-sounding advice, stop writing haskell like it's C or java or some such
16:32:28 <Cale> The second x1 is in an inner nested scope
16:32:39 <hpc> you'll have a much better time working through equational reasoning
16:32:43 <Cale> Well, this is a subtle point
16:32:46 <hpc> than by doing "this, then this, then that"
16:33:03 <Cale> x <- foo really looks like "assign the result of foo to x" but that's not what it means
16:33:15 <Cale> it means "let x be a *name* for the result of foo"
16:33:21 <janiczek> hpc: I do write haskell functionally and enjoy it very much, but now I'm neck-deep inside monads and wrapping my head around the concept :)
16:33:27 <Cale> i.e. x is not a mutable cell in memory
16:33:30 <janiczek> it'll probably crystalize
16:33:30 <hpc> ah
16:33:33 <John370> but false function should output this: expected the impossible, but found....
16:33:40 <Cale> it just becomes a name for the result of that action
16:33:43 <hpc> janiczek: pick a specific monad, like Maybe
16:33:49 <johnw> or more, "let x be a name for the result found in the contextualized value returned by foo"
16:34:07 <Nereid> John370: well how is a function Constraint -> Data -> Bool going to return anything like that, instead of a Bool?
16:34:08 <hpc> and get really comfortable with the definition of (>>=) and return
16:34:10 <Cale> janiczek: When you desugar the do block, you'll end up with:
16:34:15 <Cale> foo >>= \x -> ...
16:34:40 <Cale> and if you use the same variable more than once, you end up with nested lambdas binding the same variable
16:34:41 <John370> Yes, not possible. I am so confused :(
16:34:53 <Cale> Like  foo >>= \x -> bar >>= \x -> ...
16:34:54 <typoclass> John370: right, but you said a Constraint is a Data -> Bool. so false only can give True or False, it can't give a message or something. that's why the "validate" function will have to print the message
16:34:59 <Nereid> John370: or maybe you have to rethink the type of validate?
16:35:10 <Nereid> janiczek: you're not alone in your confusion of monads; we all went through this at some point ;)
16:35:18 <pauser> hi, why is hugs showing me this problem  ? http://pastebin.com/aXY4UvvK . can someone help me ?
16:35:24 <maukd> The paste aXY4UvvK has been copied to http://hpaste.org/76635
16:35:39 <maukd> pauser: why are you using hugs?
16:35:43 <maukd> it's been dead since like 2006
16:35:53 <John370> It does day that Bool can be replaced by a richer type
16:35:55 <pauser> maukd: why ?
16:36:06 <Nereid> pauser: the type declaration of sumPowers is the issue, it seems.
16:36:06 <Cale> pauser: You have sumPowers :: Integer -> Integer which suggests that sumPowers takes one parameter
16:36:15 <ski> pauser : `sumPowers :: Integer -> Integer' should probably be `sumPowers :: Integer -> Integer -> Integer'
16:36:23 <maukd> pauser: what?
16:36:36 <Cale> also, be careful, because  sumPowers n k+1  means  (sumPowers n k) + 1
16:36:37 <ski> pauser : also, `( sumPowers n k+1 )' should probably be `sumPowers n (k + 1)'
16:36:39 <hpc> you also want to put parens around (k+1), judging from the spacing
16:36:47 <Nereid> heh
16:36:51 <typoclass> pauser: he means that ghci (which comes with ghc) is more modern and works better than hugs
16:37:09 <maukd> yeah, you should tell your teacher that everyone uses ghc now
16:37:29 <hpc> ghc has cooler features, anyway :P
16:37:35 <Nereid> :p
16:37:35 * ski thought pauser didn't use ghc ..
16:38:10 <pauser> can i call the function like this sumPowers(n,(k+1))
16:38:14 <maukd> no
16:38:23 <ski> pauser : no, it should be `sumPowers n (k + 1)'
16:39:04 <pauser> thank you so much, your very helpful :D
16:39:06 <hpc> the difference will probably be covered in class
16:39:18 <ski> pauser : well, .. you *can* make it `sumPowers(n,(k+1))', but then you must also change `sumPowers n k' to `sumPowers(n,k)' and `sumPowers :: Integer -> Integer -> Integer' to `sumPowers :: (Integer,Integer) -> Integer'
16:39:34 <typoclass> John370: i think you should try to start on the "validate" function. it would have to use the Bool that it got from a Constraint (e.g. the False that it got from function "false"). if the Bool is True, it could print "yippie it worked". if the Bool is False, it could print "expected ____, but got ___"
16:39:40 <hpc> basically, the type (Integer - Integer -> Integer) is actually
16:39:44 <johnw> :t curry
16:39:45 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
16:39:47 <hpc> Integer -> (Integer -> Integer)
16:39:48 <johnw> :t uncurry
16:39:49 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
16:39:58 <ski> pauser : however, the tradition in Haskell is to prefer the `sumPowers n (k + 1)' version, if no compelling reason suggests otherwise
16:40:08 <johnw> uncurry sumPowers (n, k+1) == sumPowers n (k+1)
16:40:24 <maukd> hmm. timing suggests university
16:40:46 <pauser> ski: why do you use ` and ' . does haskell need it ?
16:40:47 <johnw> ooh, i think I meant curry there
16:40:56 <johnw> curry sumPowers (n, k+1) == sumPowers n (k+1)
16:41:06 <ski> pauser : no, i just use it to quote Haskell code inside english text
16:41:08 <hpc> pauser: it's fancy quotes
16:41:13 <maukd> s/fancy/ugly/
16:41:18 <hpc> haha
16:41:24 <Nereid> looks fine in TeX!
16:41:30 <johnw> `' is a convention used by Emacs and TeX people
16:41:30 * ski fancies ugly quotes :)
16:41:34 <maukd> and m4
16:41:42 <johnw> ooh, m4
16:41:42 <pauser> nice
16:41:54 <maukd> johnw: it only works on ancient systems
16:42:02 <johnw> and by ancient people
16:42:13 <hpc> \if{we}{were using text\,} you would \not{be able to read anything in this channel}
16:42:18 <maukd> on anything modern, ` is not the mirror version of '
16:42:31 <hpc> *tex
16:42:37 <johnw> they figured out that 'foo' can be determined from usage
16:42:48 <Nereid> \TeX*
16:42:51 <maukd> ‘this’ is what it's supposed to look like
16:43:05 <hpc> people who use m4 are bad people and should feel bad :P
16:43:11 <johnw> which doesn't look anything like what it should look like in my IRC reader :)
16:43:19 <Nereid> isn't all of autotools built on m4
16:43:26 <johnw> dnl(hush, hpc)
16:43:30 <hpc> Nereid: exactly
16:43:40 <johnw> Nereid: sadly, that only proves his point
16:43:44 <Nereid> :V
16:44:05 <Nereid> I never figured out autotools.
16:44:15 <maukd> ｢let x = 1｣ test
16:44:17 <johnw> now with CMake, you don't have to
16:44:26 <Nereid> yeah, that's what I've been using
16:44:41 <johnw> i know autotools quite well, and I'm rapidly striving to forget it all
16:44:45 <Nereid> haha
16:44:50 <johnw> worst use of neurons ever
16:45:49 <johnw> i may return to TeX though
16:45:54 <johnw> nothing makes typesetting math quite as easy
16:46:20 <johnw> and XeTeX handles Unicode and PDF output and OpenType fonts quite well these days
16:47:02 <maukd> “asdf”  „fdsa“  «qwert»  ‹trewq›  『bonus』
16:47:43 <Nereid> 【blah】
16:48:21 <johnw> rwbarton: ping
16:48:36 <maukd> ⟦o rly?⟧
16:49:05 <Nereid> 《ya rly》
16:49:24 <johnw> how do I msg people with lambdabot again?
16:49:26 <johnw> is it @tell?
16:49:32 <monochrom> ⟦f x⟧ = ⟦f⟧ ⟦x⟧
16:49:41 <byorgey> @help tell
16:49:41 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
16:49:47 <johnw> @tell rwbarton at the end of http://en.wikipedia.org/wiki/Anamorphism it says: "A notation for ana f found in the literature is [(f)]. The brackets used are known as lens brackets, after which anamorphisms are sometimes referred to as lenses."  Is this in any way related to work like Control.Lens?
16:49:47 <lambdabot> Consider it noted.
16:49:59 <byorgey> johnw: no, it isn't
16:50:14 <byorgey> that's a completely different use of the word lens.
16:50:20 <Nereid> the brackets just look like concave lenses. :v
16:50:31 <Nereid> (optical lenses)
16:50:51 <byorgey> also, I have never heard anamorphisms referred to as lenses.
16:51:03 <byorgey> except facetiously.
16:51:08 <johnw> i kind of thought it wasn't
16:51:08 <johnw> it didn't feel similar at all, but who was I to know
16:51:08 <johnw> ah terminology, just when you think you know something, they redefined "know"...
16:51:14 <Nereid> lol
16:51:28 <johnw> Nereid: seriously, is that where the name comes from?
16:51:35 <Nereid> I don't know. just my idea.
16:51:39 <byorgey> yes, it is
16:51:39 <typoclass> is the "barbed wire lens bananas" paper referring to Control.Lensish things or anamorphismish things?
16:51:46 <byorgey> typoclass: the latter.
16:51:46 <monochrom> don't be surprised. "functor" means 3 unrelated things
16:51:55 <Nereid> @remember johnw ah terminology, just when you think you know something, they redefined "know"...
16:51:55 <lambdabot> It is forever etched in my memory.
16:52:20 <byorgey> johnw: catamorphisms are notated with (| |), known as "banana brackets"
16:52:25 <byorgey> because... they look like bananas.
16:52:25 <johnw> aha
16:52:33 <byorgey> but no one calls catamorphisms bananas.
16:52:42 <jmcarthur> i'm guessing there is no point in a SPECIALIZE pragma for a function that already has an INLINE pragma. does anybody know if i am wrong?
16:52:44 <johnw> is that related to why the FRP package is called Bananas or something?
16:52:58 <byorgey> johnw: possibly, you'd have to ask apfelmus.
16:53:03 <byorgey> reactive-banana.
16:53:41 <pauser> if i have a funcion fu :: Integer -> Integer ... . How do i call it from the same file so it will show my function tests when i lode the file . Is it possible ?
16:54:42 <jmcarthur> pauser: what do you mean call it? you mean use it within another definition?
16:54:56 <jmcarthur> pauser: and by lode do you mean load into ghci?
16:54:58 <johnw> i think he means "run my tests every time I load the file in ghci"
16:55:02 <jmcarthur> ah
16:55:17 <jmcarthur> i do not know of a way to do that
16:55:19 <johnw> like a top-level function call you see in other dynamic languages
16:55:36 <monochrom> too bad haskell is not a dynamic language
16:55:50 <johnw> but we've got Data.Dynamic!
16:55:57 <jmcarthur> what makes a language "dynamic"?
16:56:02 <monochrom> none of those onload hook, onclick hook, and onclose hook
16:56:18 <geekosaur> lemme guess, TH would cause ghci to explode with some recursive invocation of the bytecode backend?
16:56:26 <pauser> i have a function sum :: Int -> Int. now i have to check after i load it if it work sum 1 2 ect. but can i do it in the file ?
16:56:32 <typoclass> jmcarthur: customer is livid because it crashed? programmer runs around in panic? sounds very dynamic to me
16:56:50 <geekosaur> pauser: since the discussion is apparently goingover your head, the answer is no
16:56:53 <Nereid> pauser: you could write another function that runs the tests
16:57:29 <pauser> a function without argument ?
16:57:33 <Nereid> yeah
16:59:03 <Nereid> anyone seen this on cabal-install 1.16.0?
16:59:05 <Nereid> cabal: Command.optionToFieldDescr: feature not implemented
16:59:07 <pauser> ist it something like test :: void ?
16:59:11 <johnw> yes
16:59:17 <Nereid> pauser: perhaps test :: IO ()
16:59:22 <johnw> you have something in ~/.cabal/config that it doesn't recognize
16:59:24 <johnw> like, jobs: 8
16:59:29 <johnw> or jobs: true
16:59:52 <monochrom> why is it not test :: Bool?
17:00:04 <maukd> main :: IO ()
17:00:24 <johnw> pauser: I usually have a test function like that in every module I'm working on
17:00:26 <Nereid> johnw: well it worked before?
17:00:38 <johnw> Nereid: well, guess what, it doesn't now :)
17:00:39 <Nereid> until I reinstalled cabal-install with 7.6.1
17:00:39 <typoclass> Nereid: not sure, but i *think* people were talking about cabal 1.16 wonkiness in here recently. check the logs, somebody might have had an answer
17:00:53 <johnw> yeah, that's when it started happening for me too, fwiw
17:00:57 <Nereid> weird.
17:01:06 <Nereid> well, taking out jobs works for now
17:01:06 <johnw> i just removed the offending config setting and carried on with my life
17:01:07 <frio> pauser: look up hspec. I've been using that for testing my last few projects and its proven quite nice
17:02:03 <pauser> frio: oh well, its my first day in haskell so i dont know how to use frameworks here
17:02:29 <Nereid> I guess I could just keep using the previous cabal binray
17:02:31 <Nereid> binary.
17:03:52 <frio> pauser: ah, fair enough. hspec is quite straightforward (take a look at the examples, and the tutorial is quite simple to follow), but if you've not used haskell before installing gobs of stuff might be quite intimidating
17:04:33 <pauser> frio:  i will do it in next 2-3 weeks
17:12:17 <ezyang> Anyone know, when running 'cabal test' with a 'test-framework' runner, how to execute a specific test?
17:18:33 <sinelaw> Peaker, good morning!
17:21:21 <thoughtpolice> ezyang: i think something like, 'cabal test --test-option="--select-tests <foo>"'
17:21:35 <thoughtpolice> ezyang: you can get the test names by running the exe with '--list-tests'
17:21:36 <thoughtpolice> IIRC
17:22:21 <sinelaw> I'm disappointed. The pure-haskell XML parsers all went bust on memory, and only the expat one is actually useful
17:23:03 <sinelaw> what am I missing?
17:23:22 <typoclass> sinelaw: i haven't used the xml-conduit stuff, but conduits are supposed to have better memory behavior
17:23:23 <ezyang> fancy!
17:23:49 <typoclass> @hackage xml-conduit
17:23:49 <lambdabot> http://hackage.haskell.org/package/xml-conduit
17:25:02 <ezyang> A bit clunky though. I bet if we added -- support that would be nice.
17:27:05 <sinelaw> typoclass, thanks! Maybe I'll try that too
18:02:04 <byorgey> q
18:02:32 <ski>     p
18:02:51 <byorgey> I'll just pretend I meant to do that
18:03:25 <shachaf> U+0070   LATIN SMALL ROTATED LETTER Q   [p]
18:03:55 <byorgey> wat
18:04:45 <ski> (rotated ?)
18:04:59 <shachaf> Wait, it's flipped. :-(
18:05:12 <typoclass> shachaf: i can't wait for your alternative list of unicode descriptions
18:05:14 * shachaf sighs.
18:05:19 <sipa> shachaf: haha!
18:05:40 <shachaf> typoclass: I can't even rotate a letter properly -- you think I can give a full description for all of Unicode?
18:05:48 <sipa> shachaf: don't you mean U+0080   LATIN SMALL ROTATED LETTER B ?
18:05:52 <sipa> eh, 0070
18:05:58 <hpaste> clahey pasted “MicroXML parser” at http://hpaste.org/76637
18:06:09 <shachaf> LATIN SMALL REVERSED LETTER Q
18:06:12 <shachaf> I don't know.
18:06:24 <shachaf> @quote LATIN.SMALL
18:06:25 <lambdabot> shachaf says: U+006D   LATIN SMALL LIGATURE RN   [m]
18:07:44 <clahey_> I would love any style comments on my microxml parser.
18:07:52 <typoclass> LATIN SMALL LETTER B THAT HAS FALLEN OVER [q]
18:08:04 <clahey_> Ways to do it more efficiently or more haskelly?
18:08:32 <typoclass> BELLY-UP LATIN SMALL LETTER D [p]
18:09:38 <shachaf> clahey_: Well, hlint has a few suggestions for you.
18:09:47 <clahey_> shachaf, I did the first one and the two errors.
18:10:03 <clahey_> Are using functions as infix operators really that much more haskelly?
18:10:26 <shachaf> I think it has a specific list of functions it prefers infix.
18:10:44 <clahey_> Hence unions wanting to be infix.
18:11:04 * shachaf cabal -j install trifecta
18:11:10 <shachaf> cabal-install++
18:11:23 <clahey_> I think the other thing is that I should go through and define the module and specify all the types.
18:11:26 <shachaf> (Not that I'm going to do anything with it...)
18:11:34 <clahey_> shachaf, Huh?
18:11:42 <shachaf> ?
18:11:55 <clahey_> I thought that was a suggestion for me.
18:12:08 <clahey_> Only problem with specifying the types is that I'll have to change them all if I switch parsing frameworks.
18:13:10 <clahey_> Oh, I can add a type at the top.
18:13:26 <shachaf> You can probably use CS.range instead of CS.fromList of ranges.
18:18:35 <Nereid> ah, so that's what cabal-dev is.
18:18:36 <Nereid> cool
18:18:42 <brunonery> I'm trying to create a conduit but ghc doesn't like it: conduit :: Monad m => C.Conduit ByteString m ByteString
18:18:42 <brunonery> conduit = CL.map $ map W.toUpper
18:19:04 <brunonery> :(
18:19:06 <brunonery> why?
18:19:18 <Nereid> paste the code with the error message?
18:20:15 <brunonery>     Couldn't match expected type `ByteString'
18:20:15 <brunonery>                 with actual type `[W.Word8]'
18:20:28 <Nereid> so your problem is with the usage of map
18:20:42 <Nereid> ByteString is not a list of Word8s.
18:20:48 <brunonery> ah bon?
18:21:00 <brunonery> I thought I used it like that before?
18:21:02 <brunonery> :P
18:21:07 <Nereid> you have to use map from ByteString
18:21:19 <Nereid> looks like you're using Prelude's map.
18:21:26 <brunonery> ah - good  catch, Nereid!
18:21:59 <brunonery> perfect! now it works! :)
18:25:34 <Nereid> hmm, darcs doesn't build with ghc-7.6
18:25:35 <Nereid> oh well
18:35:06 <wkh> in http://www.haskell.org/haskellwiki/Typeclassopedia#Instances it says: "Implement Functor instances for Either e and ((->) e)." how do you define an instance for (->)? isn't that a language keyword? can you do that like that?
18:35:07 <johnw> yeah, I'm still using my 7.4.2 build
18:35:12 <johnw> another benefit of cabal-dev
18:35:28 <johnw> wkh: instance Functor ((->) e) where ...
18:35:45 <johnw> ((->) e) is a type constructor
18:36:07 <typoclass> wkh: yes it's language syntax :-) it's a little special, but you can use it like that ((->) e)
18:36:32 <byorgey> wkh: note that  (->) a b == a -> b,  just like  (+) 3 4 == 3 + 4
18:36:40 <typoclass> wkh: don't get confused however. ((->) e) means basically "e ->". it's the same that ...
18:36:45 <typoclass> er yeah what byorgey says
18:36:48 <wkh> is it possible to see a type for that, or something? any kind of definition? or is it just its own thing?
18:36:57 <johnw> it *is* a type
18:37:00 <johnw> it's kind is * -> *
18:37:28 <byorgey> wkh: there's no definition, it's just built in. but you can ask for its kind, just like for any type or type constructor
18:37:31 <monochrom> fmap :: (a->b) -> (e->a) -> (e->b)
18:37:37 <byorgey> at the ghci prompt type   :kind (->)
18:37:56 <monochrom> also, it's ((->) e), not (->)
18:37:59 <byorgey> or try  :kind ((->) Int)
18:38:37 <liyang> > :kind (->)
18:38:37 <liyang> (->) :: * -> * -> *
18:38:39 <lambdabot>   <no location info>: parse error on input `:'
18:38:41 <Nereid> ((->) e) is just another type constructor, with ((->) e) a = e -> a
18:39:14 <donri> is there a motivation for (e ->) not being a valid syntax?
18:39:25 <monochrom> it does not matter than (->) is built-in. afterall, IO is built-in, too
18:39:35 * ivanm currently hates the FFI
18:39:41 <johnw> (e ->) isn't an operator section?  I actually thought it was
18:39:58 <ivanm> everything was working perfectly; now it suddenly seems that peek wants to change the meaning of numbers :@
18:40:02 <donri> FSVO builtin. IO is still just a name, that you can import, or hide and give some other meaning ...
18:40:13 <gwern> @quote
18:40:13 <lambdabot> Botje says: playing with self is for when i have a bit more time :)
18:40:19 <monochrom> oh heh, I forgot that
18:40:46 <liyang> donri: none that I can see.
18:40:52 <ivanm> does anyone know of any reasons why FFI in ghci can do this?  I haven't had it cause any problems when compiling
18:41:01 <ivanm> (and this makes it difficult to debug my C :s)
18:41:10 <johnw> ivanm: we're kind of completely lacking context
18:41:47 <typoclass> ivanm: how do you mean, peek wants to change the meaning of numbers?
18:42:04 <ivanm> https://plus.google.com/u/0/101302416956767249890/posts/BdL8WE7RkMd
18:42:12 <ivanm> ^^ an explanation I wrote yesterday
18:42:13 <monochrom> yeah, I only know two kinds of people who change the meaning of numbers. mathematicians. crackpot mathematicians
18:42:24 <ivanm> except now the value that _was_ working is also getting errors :s
18:42:41 <johnw> i know of 3 kind of people who change the meaning of numbers.  me
18:43:21 <monochrom> hahaha you win!
18:43:35 <ivanm> typoclass: for some reason when peeking a CInt inside a struct, it comes up with a completely different number
18:44:19 <monochrom> perhaps alignment problems
18:44:29 <monochrom> perhaps even 32-bit vs 64-bit problems
18:45:58 <typoclass> or even endianness, if that's still a thing these days
18:47:00 <typoclass> could you be accessing uninitialized memory for some reason? some off-by-one thing, everything of the array being zeroed except the last element, etc.?
18:47:03 <johnw> can you put a breakpoint on that C function in gdb, run your Haskell program, and then dump the memory to see where that value is coming from?
18:47:04 <ivanm> 64bit GHC
18:47:09 <ivanm> AFAIK 64bit gcc
18:47:12 <ivanm> it _usually_ works
18:47:14 <geekosaur> some of us still use (and have customers who use) sparc and ppc
18:47:21 <ivanm> on x86_64
18:47:31 <ivanm> johnw: nfi how to do that :)
18:47:41 <johnw> build your haskell program foo
18:47:44 <johnw> gdb foo
18:47:51 <johnw> gdb> b <name of C function>
18:47:54 <johnw> gdb> run <ARGS>
18:48:04 <ivanm> johnw: that's the thing: I've never managed to get it to do anything weird when compiled
18:48:09 <typoclass> geekosaur: right :) i just can't think of any laptop or other consumer thing that's big-endian (except if it's like 7 years old)
18:48:09 <ivanm> only in ghci
18:48:13 <johnw> ohhh
18:48:21 <johnw> well, now you've given us a good datapoint!
18:48:27 <ivanm> johnw: I did say that earlier :)
18:48:32 <johnw> sorry, didn't see it
18:48:44 <ivanm> it's a PITA to change main just to test a different definition :s
18:48:50 <johnw> you can run ghci under gdb too
18:49:02 <johnw> addresses are addresses, and you can set breakpoints on them
18:49:09 <JoeyA> The doc for GHC.Event.closeFd says "Close a file descriptor in a race-safe way."  What is the "race" being prevented here?
18:49:47 <johnw> JoeyA: so that the close happens after any pending writes?
18:50:18 <ivanm> johnw: I also get dodgy values sometimes when doing "with foo peek" :s
18:50:32 <typoclass> ivanm: compiled or interpreted?
18:50:35 <johnw> ivanm: i don't really test my FFI code in ghci, so I can't say
18:50:36 <JoeyA> You mean, so the IO manager won't wake threads waiting to write when closing?
18:50:44 <ivanm> typoclass: interpreted
18:51:11 <ivanm> I'm trying to find why my C code isn't working, so using ghci is easier than ghc :s
18:51:14 <johnw> JoeyA: i meant, so that if you have lazy write actions that haven't been evaluated yet, the close doesn't suddenly cause an invalid file descriptor to be seen by those actions
18:51:17 <typoclass> JoeyA: they probably are talking about race conditions, but i'm not sure exactly how those relate to closing an fd
18:51:44 <johnw> that would be a write/close race
18:52:18 <JoeyA> My understanding of how GHC does IO on *nix with -threaded: it waits for the thread to be ready for read/write by using select/epoll/etc., then does the IO (with a non-blocking socket)
19:03:39 <ivanm> johnw: do you know if it's possible tehre might be laziness issues going on with the peeking and poking?
19:03:57 <johnw> ivanm: peek is in IO, so I would highly doubt that
19:04:34 <ivanm> I'm also using peekArray
19:04:36 <ivanm> and pokeArray
19:04:48 <ivanm> just had a case where after poke, the C value didn't seem to be right :s
19:04:57 <johnw> i'd stop using ghci :)
19:05:14 <ivanm> yeah, mebbe
19:05:32 <ivanm> which makes working out wtf is wrong with my code a hell of a lot harder :(
19:08:45 <johnw> then put aside your day and debug ghci instead of your problem :)
19:09:06 <johnw> i have no good answer for you
19:09:44 <ivanm> thanks anyway
19:09:45 <geekosaur> typoclass, I can think of severl, just not sure whether haskell will be seen on any of them.  (LOTS of game consoles are based on the Cell processor which is PPC and IIRC runs it big-endian)
19:09:57 <ivanm> I couldn't even find a good answer on "does ghci not like FFI" :s
19:10:26 <typoclass> geekosaur: right, but i find it unlikely that ivanm is talking to us from a game console ...
19:10:29 <typoclass> ;)
19:10:35 <johnw> and the thing is that when you compile, I believe you're linking against the FFI library, but when you use ghci is it using dlopen()?
19:10:47 <johnw> that could lead to different semantics; not sure how, just saying maybe
19:10:51 <geekosaur> maybe.  I'd not be surprised if there's something for xbox....
19:13:01 <Nereid> dmwit: how's getting gtk2hs to work on 7.6.1 coming along? :v
19:13:13 <johnw> dmwit: yeah, i'd like to know too
19:13:33 <johnw> dmwit: I'm building threadscope in a VM using 7.4.2 just so I can use the tool...
19:15:54 <hamishmack> https://patch-tag.com/r/hamish/gtk2hs/home contains patches for GHC 7.6.1 and Gtk 3 (-fgtk3)
19:19:31 <Nereid> cool
19:19:56 <hamishmack> Try it out and let dmwit know how you get on and perhaps he will be able to merge them in to the main repo
19:20:58 <hamishmack> I have gtksourceview patches for gtk3 too, but now where to put them right now as the repo is still darcs1
19:22:13 <gienah> hamishmack: those gtksourceview patches would be useful for the gentoo haskell overlay
19:22:57 <Nereid> hmm.
19:23:08 <gienah> hamishmack: although maybe I should just wait for them to be merged in the main repo
19:23:43 <Nereid> building gio still failed, looks like the #if __GLASGOW_HASKELL__>=704 check isn't working right?
19:23:46 <Nereid> I don't know anything.
19:24:02 <gienah> Nereid: you need to build gtk2hs-buildtools first
19:24:13 <Nereid> I have that.
19:24:43 <gienah> Nereid: did you build gtk2hs-buildtools from the repo that hamishmack pointed to with ghc 7.6.1 first
19:25:10 <Nereid> I built the regular gtk2hs-buildtools with 7.6.1 after messing with it to make it build.
19:25:23 <Nereid> while having no clue what I was doing.
19:25:27 <gienah> as you need to, as hamishmack has removed the conditional compilation from: https://patch-tag.com/r/hamish/gtk2hs/snapshot/current/content/pretty/tools/hierarchyGen/Hierarchy.chs.template
19:25:38 <Nereid> I see.
19:26:41 <gienah> Nereid: like here: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/gtk2hs-buildtools/files/gtk2hs-buildtools-0.12.3.1-remove-conditional-compilation-as-it-is-ignored-ghc-7.6.patch
19:27:45 <Nereid> sure, it works now.
19:29:59 <hamishmack> gienah: I have emailed my latest gtksourceview patches to the gtk2hs-devel list
19:30:09 <gienah> Nereid: great (and you don't need the gentoo-haskell overlay patches, as somethine similar/better is already in https://patch-tag.com/r/hamish/gtk2hs/home)
19:30:15 <gienah> hamishmack: great, thanks :-)
19:30:30 <Nereid> that's what I'm using.
19:31:11 <Nereid> the only thing I installed with portage was ghc, anyway.
19:33:05 <hamishmack> gienah: The GHC 7.6 patches in that repo are the the ones jwlato emailed to the list
19:33:14 <gienah> hamishmack: exactly
19:34:57 * gienah notes that gtk2hs and threadscope build with ghc 7.6.1 in the gentoo haskell overlay, but not currently leksahh or gtksourceview
19:39:28 <lispy> hello
19:40:00 <Nereid> gtksourceview2 from hackage built fine?
19:40:13 <Nereid> gtk2 though
19:40:40 <Nereid> oh I guess that was all it was about.
19:40:49 <Nereid> just gtk3 patches.
19:42:26 <lispy> ivanm: does the C code using any thread local storage?
19:42:38 <lispy> ivanm: that's one way that GHCi will give different behavior than GHC
19:42:42 <ivanm> lispy: nope
19:42:51 <ivanm> lemme shove the code up somewhere
19:42:54 <lispy> ivanm: you could try using -fno-ghci-sandbox
19:43:30 <Nereid> would be nice to have an updated hoogle package too, I had to do some fiddling with that for 7.6.1 too
19:43:34 <lispy> ivanm: and GHCi uses a custom linker
19:44:30 <ivanm> lispy: oh? didn't know that
19:45:24 <lispy> ivanm: In experience, if the ghci linker works then you're good to go. So I doubt that's a factor here
19:45:30 <ivanm> the .hsc, .c and .h files I'm using are here: http://hub.darcs.net/ivanm/dangd/browse/utils
19:45:41 <ivanm> if anyone can see anything drastically wrong I'm doing :)
19:46:12 <johnw> where is the peek that has the problem?
19:47:53 <Nereid> well, seems like I've got everything moved over to 7.6 now yay
19:50:59 <lispy> ivanm: I looked over your .hsc file, but nothing stands out other than having some very non-trivial instances.
19:51:04 <ivanm> johnw: peeking on SGraph
19:51:12 <johnw> line#?
19:51:13 <lispy> ivanm: I guess I would start by making sure those instances work as expected
19:51:32 <ivanm> johnw: ` with (sgraph ddr) peek '
19:51:33 <lispy> ivanm: maybe you can throw QC at this?
19:51:35 <ivanm> (for example)
19:51:48 <ivanm> lispy: it seems to work... except for when suddenly random numbers change in ghci :s
19:52:12 <ivanm> so I can't tell whether it's a memory allocation problem with ghci or somethign else :s
19:52:19 <johnw> ivanm: i don't find that text in any of the .hs file
19:52:23 <johnw> please give me file & line
19:52:34 <ivanm> johnw: it's not, that's what I run in ghci :)
19:52:47 <johnw> :t with
19:52:48 <lambdabot> Not in scope: `with'
19:52:54 <ivanm> @hoogle with
19:52:55 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
19:52:55 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
19:52:55 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
19:52:55 <lispy> ivanm: you could try setting your pointers to 0 after freeing them. That makes errors where you use them or free them again immediately obvious at run-time
19:53:14 <ivanm> lispy: well, I don't use free explicitly, just with and alloca :s
19:53:23 <lispy> ivanm: in the .c file, I meant
19:53:31 <lispy> bench_match_bud.c
19:53:44 <typoclass> ivanm: stupid question, but what is GRAPH? some global variable coming from the c side? (i'm looking at the Storable SGraph instance)
19:53:53 <johnw> so, the memory from sgraph ddr isn't cleaned up after the with?
19:53:57 <lispy> typoclass: it's a struct
19:53:57 <ivanm> lispy: oh, right; that bit doesn't seem to be a problem
19:54:01 <johnw> what about peek =<< sgraph ddr?
19:54:20 <ivanm> johnw: not sure if it's that, but sometimes the numbers that come from the peek are all wrong
19:54:27 <typoclass> lispy: er right, sorry, got it
19:54:37 <rwbarton> johnw, not as far as I know
19:54:37 <lambdabot> rwbarton: You have 1 new message. '/msg lambdabot @messages' to read it.
19:55:03 <ivanm> johnw: does that even type-check? :s
19:55:10 <johnw> err, guess not
19:55:19 <ivanm> oh, good, you were confusing me for a bit there :)
19:55:28 <johnw> sorry
19:55:59 <ivanm> when I just try and use ` with <foo> peek ' on the "arrays", they're fine; it's only as part of the struct that sometimes errors occur
19:56:00 <johnw> so yeah, since with returns an action, nothing should be wrong there as far as laziness goes
19:56:09 <ivanm> so I don't know if I'm not meant to use alloca for Storable instances or something else
19:56:15 <lispy> :t with
19:56:16 <lambdabot> Not in scope: `with'
19:56:21 <ivanm> @hoogle with
19:56:21 <lambdabot> Foreign.Marshal.Utils with :: Storable a => a -> (Ptr a -> IO b) -> IO b
19:56:21 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
19:56:21 <lambdabot> Foreign.Marshal.Array withArray :: Storable a => [a] -> (Ptr a -> IO b) -> IO b
19:57:23 <lispy> ivanm: and you don't violate this? "The memory is freed when f terminates (either normally or via an exception), so the pointer passed to f must not be used after this."
19:57:51 <ivanm> lispy: yeah, I can't tell what that means exactly
19:57:58 <ivanm> does that mean I shouldn't use the Ptr a value?
19:58:04 <ivanm> or not the memory that it points to?
19:58:51 <lispy> ivanm: You must return something that is independent of Ptr a sticking around
19:59:12 <ivanm> so, does that mean my Storable instances are wrong because they use alloca?
19:59:24 <ivanm> should I be using ForeignPtr's with finalizers instead?
19:59:25 <typoclass> ivanm: another stupid question, what is the logic behind fromCI/fromIntegral? sometimes it's "fromCI <$> #{peek ...", sometimes it's just "#{peek ..."
19:59:40 <ivanm> typoclass: just to force types
20:00:07 <ivanm> if I don't use the value, it complains it doesn't know the type
20:00:21 <ivanm> and with {max,num}{N,E} I was switching around which ones I was using later on
20:00:35 <typoclass> hmm
20:00:44 <ivanm> so I shoved the fromCI stuff there to make sure it knew how to read it
20:00:45 <lispy> ivanm: normally you'd use `with` if you want to pass a pointer to Haskell value to a C function
20:00:57 <ivanm> I had a bug earlier where I forgot to use it and all these values were read as Ints rather than CInts :s
20:01:28 <ivanm> lispy: right, which is what I _want_ to do, but kept finding these errors when trying to use ghci to debug my C code
20:02:00 <lispy> ivanm: I'm slow and not good at reading the scroll back. WHat is the example in ghci that causes a problem?
20:02:57 <lispy> ivanm: this line:  #{poke DANGD, graph} ptr grP
20:02:58 <ivanm> lispy: every now and then, doing something like "with ddr peek" would have weird numbers in the edge values
20:03:19 <lispy> ivanm: In C, that's like ptr->graph = grP
20:03:34 <lispy> ivanm: followed by free(grP);
20:03:39 <ivanm> oh...
20:04:29 <ivanm> so, how am I meant to allocate memory for stuff that the C representation is just a pointer?
20:04:45 <lispy> I guess that depends
20:04:54 <lispy> malloc is one way
20:05:06 <lispy> But I'm not sure that will do what you want
20:05:18 <ivanm> yeah, since I then need to free those values somehow
20:05:38 <ivanm> I couldn't find any examples of how to deal with complex structures in FFI :s
20:05:40 <lispy> You could look into stableptr
20:05:42 <sinelaw> @hoogle Bool -> IO () -> IO ()
20:05:42 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
20:05:42 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
20:05:42 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
20:06:16 <lispy> ivanm: I'm guessing the C side uses a ptr there because it wants a reference that may be used in multiple places?
20:06:31 <lispy> ivanm: kind of like, this node points at the following nodes?
20:06:44 <copumpkin> not StablePtr
20:06:58 <lispy> copumpkin: no?
20:07:09 <ivanm> well, I'm using pointers in C because I was under the impression that was how you pass values to C methods that you want changed
20:07:10 <rwbarton> simplest way is if your C struct contains a pointer then the corresponding Haskell type with a Storable instance should contain a Ptr
20:07:14 <ivanm> and without copying the entire value
20:07:16 <copumpkin> that's for passing a reference to a haskell structure that may move to the outside
20:07:26 <rwbarton> then worry about what to put in that Ptr separately
20:07:41 <copumpkin> you just use malloc with your Storable instance
20:07:42 <lispy> rwbarton: that sounds like what I've done in the past
20:07:43 <copumpkin> if that's what you have
20:07:51 <ivanm> rwbarton: so I need another layer of conversion from Haskell -> intermediary Haskell -> C via Storable ?
20:08:09 <copumpkin> newtype MyOpaqueWrapper = Opaque (Ptr MyOpaqueRapper)
20:08:15 <rwbarton> yeah it's pretty common to have two layers like that in FFI bindings
20:08:19 <copumpkin> or possible ForeignPtr
20:08:25 <ivanm> oh hooray *sighs*
20:08:28 <rwbarton> you can generate the second -> with bindings-dsl
20:08:37 <ivanm> rwbarton: had nfi how to use that
20:08:43 <ivanm> looked at the docs and got confused
20:08:57 <lispy> ivanm: on the bright side, you know why the code you have crashes
20:09:07 <lispy> and you have a fix
20:09:08 <ivanm> so now I have to work out how to convert my Haskell representation of a graph into a Ptr-based Haskell representation of a graph :s
20:09:17 <ivanm> lispy: because it's crap and something I don't really want to do? :p
20:09:32 <copumpkin> if you want to deal wtih C, you need to know how the C side of things works :P
20:09:42 <ivanm> maybe I should scrap Storable and work out how to just define these values within C after all
20:09:53 <ivanm> since I figured using Storable would be easier than manual explicit definitions :s
20:09:55 <lispy> ivanm: aren't you glad you took my recommendation to use criterion ;)
20:09:58 <copumpkin> ivanm: it is
20:10:04 <ivanm> lispy: heh
20:10:23 <ivanm> copumpkin: sure, but now you're all telling me that my Storable instances are all wrong! :s
20:10:30 <mapreduce> :t sequence
20:10:31 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:10:47 <copumpkin> ivanm: I am?
20:10:57 <copumpkin> I thought you were just using a temporary allocation function and holding onto its memory?
20:10:59 <ivanm> copumpkin: oh, wait, what was your "it is" in response to?
20:11:00 <lispy> ivanm: if you want some example code, I went though a similar exercise last year making a freetype2 binding: https://github.com/dagit/freetype2/tree/cabalization/Graphics/Rendering/FreeType/Internal
20:11:08 <copumpkin> "it is easier to use Storable"
20:11:48 <ivanm> copumpkin: OK, well, I already wrote all these wrappers around my data types just because I need a max array size for C, etc. ...
20:12:05 <ivanm> now you're telling me that I need more indirection/conversions
20:12:30 <ivanm> lispy: what should i be looking at in there?
20:12:33 <lispy> ivanm: you want the type with the Storable instance to be a 1-1 of the C type
20:13:03 <ivanm> and then use malloc, etc. explicitly in my conversions to that type?
20:13:52 <rwbarton> the simplest thing is call malloc explicitly when you want to actually call a C function
20:14:11 <copumpkin> or actually use alloca and marshall/unmarshall on the fly
20:14:23 <rwbarton> or some other allocation yes
20:14:27 <copumpkin> probably not ideal to do that though
20:14:32 <rwbarton> yeah I should have said alloca
20:14:33 <copumpkin> unelss it's a simple/flat structure
20:14:46 <rwbarton> or unless it is a one-shot kind of thing
20:14:46 <copumpkin> that's basically what integer-gmp is doing though
20:15:02 <lispy> ivanm: THat could work: https://github.com/dagit/freetype2/blob/cabalization/Main.hs
20:15:07 <ivanm> well, I was using alloca; apparently wrongly :s
20:15:22 <rwbarton> take a haskell structure, marshall it to C, call the C function, get the result back and then throw the whole mess away
20:15:30 <copumpkin> ivanm: the docs say what it does right there :P
20:15:47 <ivanm> copumpkin: yes, but I just thought I shouldn't use that _variable_ any more :s
20:16:04 <lispy> okay, but hang on. ivanm isn't the most experienced C programmer. He's struggling in some places, but that's fine.
20:16:34 <lispy> ivanm: you have the basic idea right, but storing the ptr was your mistake.
20:16:38 <ivanm> OK, so the correct approach to FFI is: 1) I have C data structures; 2) I write Haskell data structures that are direct translations of the C ones, and write Storable instances for them; 3) I write IO-based functions to convert my real data structures into the bridging ones ?
20:16:41 <lispy> We just have to fix that
20:16:44 <ivanm> thanks lispy
20:17:00 <lispy> ivanm: that should work
20:17:16 <lispy> ivanm: that Main.hs does that with the types I defined in the .hsc files I linked to you
20:17:17 <rwbarton> i don't know if that is the only correct approach but it is a simple and effective one
20:17:47 <lispy> ivanm: you seen lines like this in Main.hs
20:17:48 <lispy> forM_ text $ \c -> do
20:17:48 <lispy>     withForeignPtr matrix $ \mp ->
20:17:48 <lispy>       withForeignPtr pen $ \pp -> do
20:17:49 <ivanm> IIRC, I took the Assembler option rather than C in the only subject I did that had C in it (for microcontrollers) just so I wouldn't have to deal with malloc; and avoided upgrading my degree to the new one because of a new required course that was about C :s
20:18:07 <ivanm> so, how does ForeignPtr differ from Ptr?
20:18:19 <lispy> the GC will clean up ForeignPtrs
20:18:25 <sinelaw> how do I abort an IO () in a do?
20:18:26 <lispy> With Ptr it's up to you
20:18:57 <ivanm> sinelaw: is this in main ?
20:19:14 <ivanm> otherwise, use an if-statement or something with a return () statement
20:19:20 <sinelaw> ivanm, yes :)
20:19:34 <sinelaw> I want to print a string an exit
20:19:35 <ivanm> sinelaw: I wrote a "die" function to exit the app when I wanted that :p
20:19:51 <ivanm> I've got it in Main.hs of SourceGraph if you want to have a look
20:20:10 <ivanm> I think it's also in haskell-updater that's on github (under gentoo-haskell) if that's easier for you
20:20:10 <lispy> sinelaw: You could use exceptions, depending on what you mean by abort
20:20:27 <ivanm> @hoogle Ptr a -> ForeignPtr a
20:20:29 <lambdabot> Foreign.ForeignPtr newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
20:20:29 <lambdabot> Foreign.Concurrent newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
20:20:29 <lambdabot> Foreign.ForeignPtr newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
20:21:04 <ivanm> lispy: oh, Storable can convert the ForeignPtr into a Ptr for me or something?
20:21:06 <sinelaw> thanks, got it
20:21:52 <lispy> :t withForeignPTr
20:21:53 <lambdabot> Not in scope: `withForeignPTr'
20:21:55 <ivanm> @hoogle withForeignPtr
20:21:55 <lambdabot> Foreign.ForeignPtr withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
20:21:58 <ivanm> ahhh
20:22:02 <ivanm> just saw your line using that :p
20:22:27 <lispy> ivanm: look at: https://github.com/dagit/freetype2/blob/cabalization/Main.hs#L30
20:22:33 <ivanm> yeah, just saw that :)
20:22:38 <ivanm> lispy: so use mallocForeignPtr instead of alloca?
20:22:38 <lispy> ivanm: I have to do that poke because I never wrote the other layer
20:22:58 <rwbarton> argh why are half the sources for Foreign.* modules missing on hackage
20:22:59 <lispy> It really depends. ForeignPtrs live till you're done with them, alloca is more efficient.
20:23:10 <ivanm> *nod*
20:23:20 <rwbarton> actually  the whole haddock page is missing
20:23:56 <cornihilio> what would "data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)" be in record syntax?
20:24:14 <lispy> ivanm: have you read this before? http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
20:24:38 <ivanm> yes
20:24:58 <ivanm> but since it only dealt with CInts, I tried working all this stuff out on my lonesome, with disastrous results :p
20:25:36 <lispy> cornihilio: record syntax is usually discouraged when you have more than one constructor, but let' me show you anayway: data Shape = Circle { first :: Float, second :: Float, third :: Float} | Rectangle { x :: Float, y :: Float, w :: Float, h :: Float } deriving (Show)
20:25:47 <lispy> cornihilio: that should work unless I typod in there
20:26:00 <lispy> ivanm: even the PCRE example?
20:26:09 <ivanm> that's the only example there, isn't it?
20:26:33 <ivanm> but I was reading that and wishing they explained wtf the ccall and unsafe bits meant ;)
20:26:42 <lispy> ivanm: sory, I was confused by the CInt comment
20:27:20 <cornihilio> lispy: why is record syntax discouraged when you are definining a data type that uses "|"?
20:27:37 <ivanm> cornihilio: because you create prtial functions
20:30:21 <monochrom> ccall means you are not calling Windows API
20:31:07 <hpaste> lispy pasted “records with more than one constructor” at http://hpaste.org/76640
20:31:21 <lispy> cornihilio: check that hpaste ^^
20:31:32 <monochrom> unsafe means several things. one thing is less overhead but reduces parallelism
20:31:33 <ivanm> monochrom: oh, I thought it just meant "I'm using C" rather than Java or something
20:32:40 <ivanm> lispy: I'll try out using ForeignPtrs later on; I've got marking to do as well so that might even help me clear my head :s
20:33:11 <lispy> ivanm: cheers. I think  you have this thing whipped once you add a layer or marshalling.
20:33:20 <ivanm> yeah, hooray :s
20:33:55 <ivanm> lispy: especially since IIUC, it means I need to create a pointer, use storable, and then pass those pointers around through two layers of wrapping :s
20:34:05 <monochrom> unsafe also means "may screw up if Haskell calls C calls Haskell"
20:34:14 <ivanm> monochrom: yeah, that's not going to happen here
20:34:26 <rwbarton> if you are creating a pointer then you are already in the middle layer of wrapping
20:34:49 <lispy> ivanm: yeah, I think this means you'll end up with a copy of the data (and it's interconnections) on both sides (Haskell and C)
20:35:33 <lispy> ivanm: so you'll have a nice data structure in Haskell land and from that you'll create some pointers, hookup the Ptr fields of your low level Haskell type, and then marshal that to C
20:35:52 <ivanm> *nod*
20:36:09 <lispy> If C changes it, you copy things back out following ptrs, create a new Haskell value, and throw away the poiters.
20:36:11 <lispy> pointers*
20:36:16 <ivanm> and then after all that get all morose when the quick`n`dirty`n`unsafe C implementation is way faster than my Haskell one :(
20:36:43 <lispy> that's when you post on Haskell Cafe saying that even dons can't optimize the Haskell code any better ;)
20:36:56 <lispy> Wait 24 hours, and check your inbox :)
20:36:57 <ivanm> heh
20:37:17 <ivanm> yeah, I have big suspiciouns that my planar-graph library is nowhere near as efficient as it could be
20:37:23 <monochrom> but dons is now chartered by a bank. (pun!)
20:37:32 <ivanm> but without somehow switching to using vector under the hood instead of Maps, I have nfi how to improve it
20:37:40 <ivanm> monochrom: <obligatory groan>
20:40:17 <lispy> ivanm: well, the good news is that you can use GHC's profiler to show you where it's spending time.
20:40:33 <lispy> ivanm: since this is research, I bet the asymptotics are more improtant anyway
20:41:30 <lispy> make sure you're not timing the marshalling code :)
20:42:15 <lispy> Anyone here know good introductory material about unification used in H-M type inference?
20:42:38 * lispy is looking at the typing haskell in haskell paper at the moment, it may be sufficent but just in case.
20:43:54 <shachaf> lispy: You should read _The Reasoned Schemer_!
20:43:57 <shachaf> Not that it's really relevant.
20:44:56 <monochrom> I learned unification from "term rewriting and all that"
20:45:44 <monochrom> I think Lawrence Paulson's "ML for the working programmer" has unification too, since it tells you how to write an automatic theorem prover
20:45:59 <lispy> monochrom: I have a copy of "term rewriting and all that" maybe I should look in there :)
20:46:15 <monochrom> yeah, it is pretty short and plain
20:46:44 <monochrom> also, any book that teaches resolution proofs has to cover unification, too
20:50:08 <shachaf> @quote
20:50:08 <lambdabot> <companion_cube> says: edwardk, you mean it's 2 phD/nick in average ? :) <edwardk> clearly this is why SPJ stays away, he doesn't want to dilute that metric.
20:50:18 <shachaf> @quote unification
20:50:19 <lambdabot> ghc says: Unexpected kind unification failure
20:50:32 <aravart> @pl \f g x y z -> f x y (g z)
20:50:33 <lambdabot> flip . ((flip . ((.) .)) .)
20:50:45 <aravart> @pl \f x y z -> x + y + z
20:50:46 <lambdabot> const (((+) .) . (+))
20:51:32 <aravart> @pl \x y z -> x + y + z
20:51:33 <lambdabot> ((+) .) . (+)
20:57:06 <Nereid> @pl \f x y z -> x + (y + z)
20:57:07 <lambdabot> const ((. (+)) . (.) . (+))
20:57:25 <Nereid> @pl \x y z -> x + (y + z)
20:57:25 <lambdabot> (. (+)) . (.) . (+)
20:57:26 <Nereid> heh.
20:59:44 <pordan30> @pl \f g h x -> f (g x) (h x)
20:59:44 <lambdabot> liftM2
20:59:50 <pordan30> @pl \f g h x y -> f (g x) (h y)
20:59:51 <lambdabot> ((flip . ((.) .)) .) . (.)
21:01:28 <ski> @ghc
21:01:28 <lambdabot> ghc says: WARNING: SE CAFs unsupported, forcing UPD instead
21:28:51 <lispy> okay. unification is not so bad
21:29:15 <shachaf> Unification is the future.
21:29:22 <shachaf> It's like pattern matching, except both ways. :-)
21:33:44 <mikeplus64> shachaf: lispy: unification?>
21:34:59 <lispy> mikeplus64: type unification
21:35:46 <shachaf> unicornification
21:36:19 <lispy> https://en.wikipedia.org/wiki/Unification_(computer_science)#Syntactic_unification_problem_on_first-order_terms
21:37:07 <ivanm> lispy: the way I was doing it with just one basic function was to marshall the value outside of criterion; criterion then benchmarked cloning the value (which is required anyway) and then running the operation
21:37:25 <ivanm> there was a 40x speed difference (20x if I used whnf rather than nf)
21:38:07 <lispy> ivanm: is there a way to find out the cost of cloning the value?
21:38:13 <lispy> 40x is pretty big
21:38:23 <shachaf> lispy: Depends on what x is.
21:38:50 <lispy> ivanm: do you know how the relative speed scales?
21:39:21 <ivanm> shachaf: time(Haskell version) ~= 40 * time(C version)
21:39:35 <ivanm> lispy: what do you mean by "relative speed scales"? size of inputs?
21:39:45 <ivanm> I think that was rather constant
21:40:01 <lispy> ivanm: yeah, size of inputs
21:42:07 * ski . o O ( "Polymorphic Type Inference" by Michael I. Schwartzbach in 1995 at <http:/cs.au.dk/~mis/typeinf.pdf/> mentions unification shortly )
21:42:45 <ivanm> I only tried it with two different inputs, and the timing difference was about the same
21:43:13 <ivanm> which was why I figured I should do a more involved test (rather than just adding one edge and deleting two nodes, each with only one edge attached)
21:43:39 <lispy> ski: Nice. "For very pure type systems, this connection is known as the
21:43:40 <lispy> Curry-Howard isomorphism. It is so famous that we shall frame it."
21:44:13 <ski> (:
21:52:11 <hpaste> lispy pasted “x has a huge type” at http://hpaste.org/76641
21:52:29 <lispy> ski: ^^ I got that from the paper you linked
21:53:13 <monochrom> heh
21:53:51 <shachaf> lispy: Pft, that's not even that huge.
21:54:11 <shachaf> @src asTypeIn
21:54:12 <lambdabot> a `asTypeIn` f = a where _ = f a
21:54:12 <lambdabot> infixl 0 `asTypeIn`
21:54:26 <shachaf> @ty id `asTypeIn` \i -> i id id id id id id id id id id id "hi"
21:54:29 <lambdabot> ((((((((((([Char] -> [Char]) -> [Char] -> [Char]) -> ([Char] -> [Char]) -> [Char] -> [Char]) -> (([Char] -> [Char]) -> [Char] -> [Char]) -> ([Char] -> [Char]) -> [Char] -> [Char]) -> ((([Char] -> [
21:54:29 <lambdabot> Char]) -> [Char] -> [Char]) -> ([Char] -> [Char]) -> [Char] -> [Char]) -> (([Char] -> [Char]) -> [Char] -> [Char]) -> ([Char] -> [Char]) -> [Char] -> [Char]) -> (((([Char] -> [Char]) -> [Char] -> [
21:54:29 <lambdabot> Char]) -> ([Char] -> [Char]) -> [Char] -> [Char]) -> (([Char] -> [Char]) -> [Char] -> [Char]) -> ([Char] -> [Char]) -> [Char] -> [Char]) -> ((([Char] -> [Char]) -> [Char] -> [Char]) -> ([Char] -> [
21:54:29 <lambdabot> Char]) -> [Char] -> [Char]) -> (([Char] -> [Char]) -> [Char] -> [Char]) -> ([Char] -> [Char]) -> [Char] -> [Char]) -> ((((([Char] -> [Char]) -> [Char] -> [Char]) -> ([Char] -> [Char]) -> [Char] -> [
21:54:29 <lambdabot> Char]) -> (([Char] -> [Char]) -> [Char] -> [Char]) -> ([Char] -> [Char]) -> [Char] -> [Char]) -> ((([Char] -> [Char]) -> [Char] -> [Char]) -> ([Char] -> [Char]) -> [Char] -> [Char]) -> (([Char] -> [
21:54:31 <lambdabot> [223 @more lines]
21:55:04 <shachaf> Hmm, you can probably make something that grows more quickly than exponentially.
21:55:26 <shachaf> @@ @run length @show @type id `asTypeIn` \i -> i id id id id id id id id id id id id id id id id id id "hi"
21:55:38 <lispy> well, there goes lambdabot
21:55:46 <lambdabot>   mueval-core: Time limit exceeded
21:55:51 <shachaf> @@ @run length @show @type id `asTypeIn` \i -> i id id id id id id id id id id id id "hi"
21:55:57 <lambdabot>   90106
21:56:11 <ivanm> lispy: oh, btw, with the C data structure I'm using, I based mine off of one that uses pointers everywhere rather than ints; but my algorithm depends on being able to generate a list of graphs, permute them, then merge them into one big graph, for which I don't think pointers would work (specifically the merging part)
21:56:20 <shachaf> @@ @run length @show @type let pair x y z = z x y; x = let x1 y = pair y y in let x2 y = x1(x1(y)) in let x3 y = x2(x2(y)) in let x4 y = x3(x3(y)) in x4(\z -> z) in x
21:56:24 <lambdabot>   7180
21:56:46 <shachaf> @@ @run length @show @type let pair x y z = z x y; x = let x1 y = pair y y in let x2 y = x1(x1(y)) in let x3 y = x2(x2(y)) in let x4 y = x3(x3(y)) in x4(x4(x4(x4(\z -> z)))) in x
21:56:58 <ivanm> shachaf: why do you hate lambdabot? :(
21:57:08 <shachaf> This should be a competition!
21:57:22 <lambdabot>   mueval: ExitFailure 1
21:57:22 <lambdabot>  mueval: Prelude.undefined
21:57:25 <shachaf> Get the largest type for some piece of code under n characters.
21:58:03 <lispy> shachaf: we should probably outlaw TH then :)
21:58:06 <shachaf> Unfortunately it would be hard to judge exactly beyond very few characters.
21:58:26 <shachaf> lispy: Sure, we want it to be nice and simple, not TC.
21:58:37 <monochrom> twitter #hugetype?
21:58:47 <lispy> #typewang
21:58:56 <shachaf> lispy: Much trickier if you want a Haskell *program* that prints the largest string, say.
21:59:09 <lispy> based on this: http://encyclopedia.thefreedictionary.com/NumberWang
21:59:09 <shachaf> (Or evaluates to the largest Integer. There was a contest for that once!)
21:59:15 <pordan30> for small n, you could just run every legal haskell program of size <= n through a type inference algorithm, no?
21:59:22 <shachaf> http://djm.cc/bignum-results.txt
21:59:28 <shachaf> pordan30: Right.
21:59:59 <shachaf> loader.c is pretty great.
22:00:24 <shachaf> «The final and winning entry, {loader.c}, diagonalizes over the Huet-Coquand `calculus of constructions'.  This is a highly polymorphic lambda calculus such that every well-formed term in the calculus is strongly normalizing; or, to put it another way, a relatively powerful programming language which has the property that every well-formed program in the language terminates.»
22:00:30 <lispy> Does type checking scale asymptotically differently than type inference?
22:01:02 <lispy> Eg., could you use this for encryption? If someone knows the type they give it to you and you check it quickly. If they don't know the type they try to infer it and end up with with an expential amount of time?
22:01:11 <monochrom> I think so. because unification is the blow up part
22:01:55 <monochrom> but I haven't thought of it cryptographically
22:02:26 <monochrom> ah, here is the problem. the type itself is too big
22:02:30 <lispy> I've heard crypto described as problems that are computationally very expensive unless you know the short-cut.
22:03:19 <lispy> Hmm...yes.
22:08:58 <pordan30> one of the common arguments against using strongly normalizing calculi as the foundation for a programming language is turing completeness, but it appears that in the majority of common applications, programmers either want termination or productivity. given that techniques such as well-founded recursion for non-structurally recursive programs and corecursion to model nonterminating processes are old-hat to dependently typed progr
22:08:58 <pordan30> ammers, what are the actual implications of lacking the turing-completeness property?
22:09:36 <pordan30> (actual = practical*)
22:10:01 <copumpkin> pordan30: more pain for writing things that terminate less obviously
22:10:11 <copumpkin> you can generally still write them, but it might not be obvious how to
22:10:19 <copumpkin> and it's probably less efficient if you ever plan on actually running them
22:12:39 <lispy> pordan30: I like this perspective: https://www.youtube.com/watch?v=7zXhP--9axQ
22:12:52 <lispy> pordan30: it's not about depnedent types, but it does discuss a case where losing TC is a good thing
22:13:25 <pordan30> copumpkin: isn't the former a cultural or environmental problem -  in the sense that programmers lack familiar design patterns and tools, rather than a structural problem - of the languages? for instance, most programmers ensure those properties informally already. the latter point is well-taken, however.
22:14:12 <shachaf> pordan30: Informal proofs are much easier than formal proofs.
22:14:14 <pordan30> lispy: galois talks are always interesting. thanks for the link.
22:14:15 <copumpkin> pordan30: reasoning informally about it and being able to construct a proof are kind of different
22:14:25 <shachaf> Especially when they're not really proofs, just "hunches".
22:14:26 <copumpkin> but yeah, ideally there'd be nice combinators for making it less annoying
22:14:37 <copumpkin> the agda std lib already has "termination combinators"
22:14:41 <copumpkin> but they're obscure as hell
22:14:56 <copumpkin> I have to figure them out each time I need them
22:16:43 <b__> what sites do all of you use for looking up/learning about math?
22:17:35 <lispy> b__: google
22:17:38 <lispy> b__: sad as that is
22:17:40 <monochrom> planetmath, wikipedia, sometimes wolfram alpha too. those are for look up
22:17:44 <Cale> b__: Mostly the obvious ones which turn up in any google search, plus a bunch of books, on a topic-specific basis.
22:17:59 <pordan30> copumpkin: assuming termination combinators from agda can be made accessible, they sound useful. the program and measure features of coq are helpful, but don't always scale well to larger programs.
22:18:00 <Cale> ncatlab
22:18:00 <b__> I should get me some books probably
22:18:02 <lispy> mathexchange is getting better
22:18:17 <b__> for alga's I have TAOCS
22:18:19 <Cale> b__: What do you want to study?
22:18:28 <monochrom> for learning, I actually get some kind of book or tutorial. by luck.
22:18:30 <copumpkin> pordan30: there's also the fact that we haven't quite figured out how to do the coinductive counterpart to that nicely
22:18:32 <b__> but for math I need something less heavy
22:18:39 <copumpkin> pordan30: which makes it kind of asymmetrical
22:18:45 <b__> Cale, Number Theory and Category Theory
22:18:51 <lispy> b__: I don't know how well khan academy, coursera or other new fangled sites work.
22:18:58 <copumpkin> pordan30: it's hard to even figure out what you'd need to track to deal with productive corecursion in a composable way
22:19:02 <b__> two very different fields, but for different reasons
22:19:12 <Cale> Okay, for category theory, I would highly recommend Awodey's book as a good starting point.
22:19:15 <b__> b__ yeah I should probably check those out too
22:19:22 <b__> okay
22:19:37 <lispy> b__: Implementing the topic in a programming language can help in the learning process
22:19:44 <Cale> b__: sent you a pm :)
22:19:48 <lispy> b__: I've been doing this with ray tracing to great advantage
22:20:04 <b__> thanks Cale :}
22:20:07 <pordan30> copumpkin: not only that, but there isn't really an accepted standard for corecursive definitions in different (relevant) languages, if i recall correctly. it's asymmetrical, but understandable at this point.
22:20:25 <ski> @where awodey
22:20:25 <lambdabot> http://www.math.uchicago.edu/~may/VIGRE/VIGRE2009/Awodey.pdf
22:20:28 <b__> lisp yeah, that's usually my approach
22:20:30 * lispy really needs to downgrade to 7.4.
22:20:32 <lispy> I can't build anything
22:20:34 <b__> lispy*
22:20:39 <shachaf> lispy: You don't need to downgrade.
22:20:48 <shachaf> They can perfectly well coëxist on the same system.
22:20:49 <Cale> Number theory, I'm less sure about. I haven't met a number theory book I've really loved (but maybe that's why I don't really love number theory)
22:21:08 <lispy> shachaf: I'm lazy and use the installers
22:21:14 <shachaf> lispy: Installers?
22:21:19 <shachaf> Is this a Windows thing?
22:21:21 <Cale> I could recommend some notes if you were studying algebraic number theory, but that has some heavy prerequisites.
22:21:34 <lispy> shachaf: OSX and Windows ghcs come with installers
22:21:38 <shachaf> lispy: I've used "make install" in GHC with multiple versions and it worked fine.
22:21:54 <lispy> yeah, the tarballs allow for that
22:22:01 <b__> Cale, my knowledge is wide, and at some points deep, but there are huge gaps
22:22:13 <b__> so I probably need more basic works at this point
22:22:18 <lispy> I should just port this code to use haskeline instead of readline
22:22:27 <pordan30> this isn't that helpful because i can't remember the names, but there are some pretty good books that go over category theory and abstract algebra introducing the latter with number theory.
22:23:13 <b__> well it's good to know what's out there
22:49:06 <shachaf> Cale: Aren't you in Toronto?
22:51:28 <unlink> Why is there an Enum instance for ()?
22:51:33 <Cale> shachaf: I'm in Brantford
22:51:48 <Cale> unlink: because there can be :)
22:51:59 <shachaf> Cale: Have you been to the monthly Haskell meeting in Toronto?
22:52:51 <unlink> Cale: So why are succ and pred undefined?
22:52:54 <monochrom> please come! it's just once a month. we need more victims. err people!
22:53:02 <ski> > [() .. ()]
22:53:05 <lambdabot>   [()]
22:53:17 <unlink> > succ ()
22:53:18 <lambdabot>   *Exception: Prelude.Enum.().succ: bad argument
22:53:22 <ski> > succ True
22:53:23 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
22:53:45 <unlink> Ah.
22:54:01 <monochrom> although, we end at 10pm or something, it may very late for you if you live far away
22:54:15 <unlink> It's a trivial enumerable.
22:54:20 <ski> yes
22:54:34 <akamaus> monochrom, victims in the name of whom? ;)
22:54:36 <unlink> > minBound :: ()
22:54:37 <lambdabot>   ()
22:54:43 <unlink> Cute.
22:55:29 <Cale> shachaf: no
22:56:01 <Cale> shachaf: I wasn't really even aware of them
22:56:14 <shachaf> Cale: See <monochrom> above.
22:56:27 <Cale> oh I see
22:56:31 <shachaf> Cale: Someone was just mentioning them at the bahaskell meeting.
22:57:09 <monochrom> we are so desperate, we send a representative to Bay Area for recruitment...
22:57:12 <Cale> I live about an hour away, but I don't have a car or the ability to drive
22:57:18 <Cale> haha
22:57:35 <Cale> So it would be a greyhound bus thing for me
22:57:47 <pordan30> unlink: i suppose you could define succ () = () and similarly for pred, but in general succ should not be surjective
22:58:15 <shachaf> colah: Was that you at bahaskell?
22:58:18 <Cale> which might work out, or else maybe they'd want to take me to Woodstock for a 4 hour stopover and then back
22:58:23 <ski> pordan30 : .. though it wouldn't fit the pattern with `Bool' e.g.
22:58:24 <shachaf> preflex: seen colah
22:58:24 <preflex>  colah was last seen on #haskell 9 hours, 35 minutes and 47 seconds ago, saying: c_wraith: Thanks!
22:59:09 <pordan30> ski: i agree; it was more: "if you really want it defined, then..."
22:59:26 <monochrom> Haskell 98 and 2010 disallow succ and pred to be cyclic
23:00:06 <pordan30> monochrom: how?
23:00:17 <pordan30> oh, in the specification
23:00:17 <Cale> monochrom: succ is surjective on Integer! :)
23:00:26 <Cale> er, I mean pordan30
23:00:41 * ski . o O ( torson-free ? )
23:01:21 <monochrom> "The calls succ maxBound and pred minBound should result in a runtime error."  2010 section 6.3.4
23:01:40 <Cale> I don't really see why succ and pred need to be in Enum at all
23:02:11 <Cale> Enum should just define the [a..], [a..b], [a,b..] and [a,b..c] notations.
23:02:18 <Cale> and that's all
23:02:37 <pordan30> cale: hah, yeah - i guess not being cyclic is a better restriction. although a more intuitive notion of enumerability for integers would have a least element, i guess
23:04:02 * ski thinks the report has no business adding extra common laws for `Enum' and `Bounded' without making a common subclass
23:07:59 <lispy> It would be great if we could agree on a way to address the Enum, Bounded, and numeric type class issues in the prelude.
23:08:07 <lispy> and actually get the changes ratified
23:08:19 <lispy> But so much language breakage would ensue
23:08:48 * lispy goes to bed
23:08:50 <lispy> night all
23:11:19 <unlink> How can I write this non-recursively? go n xs = take n xs : go n (drop n xs)
23:14:37 <ski> > unfoldr (Just . splitAt 3) [0 .. 9]
23:14:39 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
23:14:49 <P1RATEZ> is haskell used out in the wild, are there programs written with this?
23:14:57 <MostAwesomeDude> P1RATEZ: Sure.
23:15:31 <P1RATEZ> was reading the tutorial on the web site up in topic, i think its got cocaine embedded in the text, i can't stop reading it
23:15:33 <ski> unlink : ok ?
23:15:54 <Cale> map (take n) . iterate (drop n)
23:16:17 <Cale> P1RATEZ: :)
23:16:53 <Cale> P1RATEZ: Which tutorial exactly?
23:16:56 <unlink> Cale: Thanks.
23:17:12 <P1RATEZ> one of those links too me to learnmesomesomething..
23:17:37 <Cale> Ah, LYAH
23:18:02 <P1RATEZ> http://learnyouahaskell.com/starting-out
23:18:09 <P1RATEZ> oh
23:18:15 <monochrom> yes
23:18:22 <Cale> I love the drawings
23:18:27 <P1RATEZ> i know eh
23:18:36 <P1RATEZ> edible colours
23:18:37 <P1RATEZ> ;]
23:18:39 <P1RATEZ> XD
23:18:58 <Cale> I wonder why BONUS never seems to show up on IRC any more
23:19:17 <monochrom> the book ate him
23:20:46 <ski> > dualize "cocaine"
23:20:48 <lambdabot>   "caine"
23:22:01 <Cale> I wonder if BONUS/Miran Lipovača was actually a reboot of _why and now he has yet another pseudonym.
23:22:41 <donri> _because
23:23:03 <shachaf> Cale: I doubt it.
23:23:21 <monochrom> I suddenly have an idea. most new nicks coming here to say they like LYAH, that's him promoting the book :)
23:23:40 <shachaf> Cale is going to write a competitor book to LYAH.
23:23:45 <MostAwesomeDude> Cale: Y'know, I would not be surprised.
23:23:52 * ski grins
23:23:56 <MostAwesomeDude> Cale: Except wasn't BONUS around at the same time as _why?
23:24:54 <Ralith> planning!
23:24:59 <Cale> MostAwesomeDude: I don't know for certain.
23:31:37 <unlink> Cale: Hah. Googling for this problem brings up logs from 2007 where you discussed the same thing.
23:32:10 <Cale> unlink: heh, which problem?
23:32:33 <Cale> unlink: breaking a string into equal-length parts?
23:33:04 <unlink> <Cale> The variant of unfoldr I wish we had is unfoldr p f g = map f . takeWhile p . iterate g
23:33:40 <shachaf> That's not really unfoldr...
23:34:12 <shachaf> Well, I guess it is in one sense. But it's even more different from foldr than the current unfoldr.
23:35:15 <monochrom> @type (\p f g -> map f . takeWhile p . iterate g)
23:35:17 <lambdabot> forall a b. (a -> Bool) -> (a -> b) -> (a -> a) -> a -> [b]
23:35:21 <Cale> shachaf: yes, but it's a good bit more usable in a lot of cases
23:35:33 <shachaf> You know what would be convenient? If we had a function like your unfoldr, except it had keyword arguments so you could remember which was the map, which was the takeWhile, and which was the iterate.
23:36:06 <shachaf> So you could write something like "foo (map f. takeWhile p. iterate g)"
23:36:12 <Cale> lol
23:36:15 <shachaf> (As it happens, foo = id)
23:36:55 <ski> why `map f' there at all ?
23:37:39 <shachaf> ski: Because the result type of unfoldr isn't the same as the "input type".
23:38:07 <monochrom> because "a" is internal state, "b" is projection of that state
23:38:17 <ski> if we're already changing it willy-nilly, why not change that as well ?
23:38:47 <monochrom> change to what?
23:39:08 <ski> `(a -> Bool) -> (a -> a) -> (a -> [a])', e.g.
23:39:25 <ski> or possibly `(a -> Maybe a) -> (a -> [a])'
23:41:13 <unlink> how the hell do I indent list comprehensions?
23:41:27 <shachaf> The same way you indent everything else.
23:41:35 <monochrom> there is no restriction
23:41:49 <unlink> haskell-mode wants to do something really strange.
23:41:53 <ski> i typically indent the `,'s under the `|' -- optionally with `|' under the `['
23:42:05 <Digit> are the errors presented in hpaste always accurate/correct/valid?  it's telling me i have a redundant bracket which doesnt seem redunant...
23:42:19 <monochrom> you may safely override what it does
23:42:28 <shachaf> Digit: In my experience hlint tends to be correct about that.
23:42:45 <unlink> I'm aware, but I'd rather use tab to indent rather than space.
23:43:03 <shachaf> (However, "redundant bracket" means that the code would work without it, not necessarily that it would be more readable without it.)
23:43:24 <ski> Digit : looks correct in this case
23:44:40 <ski> unlink : then, in case you have a layout-block spanning more than one line, you should make sure to always break line after the layout-introducing keyword heading the block
23:45:13 <ski> (.. and i think you should also make sure to indent solely by tabs then, not mixed with spaces)
23:45:33 * ski finds it simpler to just always indent with spaces, though
23:46:10 <ski> (unlink : possibly you can configure your $EDITOR to insert spaces when you press the `TAB' key)
23:46:14 <unlink> I mean with the tab key (indent-for-tab-command) rather than manually with the space key
23:46:53 <ski>   (setq-default indent-tabs-mode nil)  ; in `.emacs' does the trick
23:47:04 * Digit LOVES hlint
23:47:25 <Digit> thanks shachaf
23:47:48 <shachaf> Digit: hlint = hpaste errors
23:47:58 <unlink> ski: What I'm saying is that I'd like to rely on the indent cycle 100% rather than overriding it with manual adjustments with spacebar
23:48:11 <Digit> hlint's much more clear about what it is, and provides many many more suggestions.
23:48:39 <statusfailed> Is there a "Default" typeclass? I seems to remember there is but can't find it
23:48:41 <shachaf> Digit: I'm pretty sure all hpaste does is run your code through hlint.
23:48:41 * Digit realises you can click on the hpaste errors to expand them
23:48:45 <shachaf> Digit: Have you clicked the -- yes.
23:48:49 <Digit> yeah.  ^_^
23:49:07 <monochrom> unlink: do you have (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation) or is it 'turn-on-haskell-indent?
23:49:13 <ski> unlink : .. oh. that's different from what i thought you were talking about
23:49:14 <Digit> lovely.  learning the ways.  :)
23:55:40 <Digit> hrmm.  pity there doesnt seem to be a way to automatically produce a version of the code using the suggestions
23:56:07 <Digit> probably for the best.  better the code is lazy, and not me.  ^_^
23:56:33 <shachaf> Digit: By fixing the code by hand, you learn hlint style, so it doesn't need to tell you next time!
23:56:39 <Digit> indeed.
23:56:53 <ivanm> I thought you could have it automatically fix it for you
23:57:13 <Digit> ivanm, dont tell me that now.  ^_^  i'm learning!  XD
23:57:31 <ivanm> I actually find it annoying
23:57:47 <ivanm> in emacs it keeps asking me if I want to apply the suggestions, but usually I don't want it to!
