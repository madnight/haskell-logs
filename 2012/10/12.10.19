00:01:40 <hirsch_> morning #haskell, I'm writing a ByteString to a file with fdWrite like that:  sz <- fdWrite fd (unpack buf) But sz /= length It's binary data and I assume the string conversion is my problem
00:02:12 <hirsch_> sz /= length buf
00:05:05 <ion> You should write the ByteString directly. See e.g. Data.ByteString.writeFile
00:05:20 <ion> or Data.ByteString.hPut
00:05:52 <Cale> hirsch_: It is weird that System.Posix.IO.ByteString.fdWrite takes a String parameter
00:06:11 <hirsch_> ion: The problem is, I only habe a Fd, no Handle
00:06:18 <hirsch_> Cale: yes, indeed
00:06:34 <ion> @hoogle Fd -> Handle
00:06:35 <lambdabot> System.Posix.IO fdToHandle :: Fd -> IO Handle
00:06:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
00:06:35 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
00:07:23 <m3ga> hirsch_: if you are on windows make sure you set the fd to binary mode to prevent windows line ending mangling.
00:07:33 <hirsch_> ion: Ok, is it safe? I read the Fd will be converted to nonblocking mode
00:07:47 <hirsch_> m3ga: windows? never
00:07:52 <ion> Where did the Fd come from?
00:08:09 <hirsch_> ion: HFuse
00:09:22 <Cale> hirsch_: All the usual operations on Handles are implemented using nonblocking I/O, and the illusion of blocking is provided, so that things work properly in programs with multiple threads.
00:09:47 <zergut> mornin
00:09:54 <hirsch_> I try to convert the handle, the Handle based IO is more convenient IMHO
00:10:17 <ion> hirsch: I suppose there won’t be a problem if you convert it to a Handle and then keep using Handle operations only.
00:10:26 <Cale> hirsch_: That does seem like it should be considered a bug with that posix ByteString library though.
00:10:59 <hirsch_> Cale: You mean the Interface?
00:11:03 <Cale> yeah
00:11:15 <Cale> fdWrite from that module ought to take a ByteString directly
00:11:16 <hirsch_> Cale: Yes
00:12:04 <hirsch_> Cale: I realized that the purpose of that module is not writing ByteString stuff, the filename parameters are ByteStrings
00:12:35 <Cale> hirsch_: That's really weird though
00:13:13 <Cale> It's usually not the filenames that you're worried about the distinction between String and ByteString for.
00:16:26 <hirsch_> There's fdWriteBuf thich takes a Ptr Word8, can I get the Ptr from a ByteString?
00:17:06 <shachaf> hirsch_: Probably by importing Data.ByteString.Internal.
00:18:02 <shachaf> That'll let you pattern-match directly on the constructor, or it exports toForeignPtr.
00:18:11 <shachaf> But you'll need to know how ByteStrings work in order to use it. :-)
00:18:17 <Cale> unsafeUseAsCStringLen :: ByteString -> (CStringLen -> IO a) -> IO a
00:18:23 <Cale> type CStringLen = (Ptr CChar, Int)
00:18:28 <shachaf> Oh, that works.
00:19:02 <hirsch_> shachaf: It's undocumented in hackage
00:19:15 <shachaf> hirsch_: The thing Cale mentioned is probably better.
00:19:31 <shachaf> hirsch_: The reason it's undocumented is that it's internal. :-)
00:20:01 <hirsch_> shachaf: But probably required
00:20:19 <shachaf> ?
00:20:29 <shachaf> The thing Cale mentioned isn't (as) internal, I think.
00:20:46 <hirsch_> I'll try it, thanks for the moment
00:21:34 <ion> It’s in .Unsafe, not .Internal
00:21:55 <shachaf> ion: Right.
00:34:25 <startling> how could I write an extensible parser in haskell? I want to be able to just plug in a list of little parsers and get a structure
00:34:49 <startling> I'm a little fuzzy with how I'd turn this into an AST, though
00:34:58 <startling> since haskell-style ASTs are pretty fixed.
00:36:35 <Ralith> startling: um, parsec?
00:37:19 <startling> Ralith: sure, but parsers written with parsec aren't typically configurable
00:37:37 <startling> except with data Configuration = Configuration { a :: Bool, ... }
00:38:05 <Ralith> what does "configurable" mean to you?
00:38:52 <Ralith> and haskell makes ASTs easier than in any other language I know...
00:38:57 <Ralith> even lisp doesn't have it this good
00:39:05 <Ralith> (well, short of dependently typed languages I suppose)
00:39:28 <startling> Ralith: sure, but you can't really add anything to the ast without changing the source code
00:39:38 <startling> the ast's type I mean.
00:39:55 <startling> however, I think I see how this could work. give me a minute to see if I can't come up with a more concrete question
00:41:24 * Ralith can only guess at your meaning
00:41:35 <startling> heh, sorry!
00:56:58 <killy9999> can I pass ghc flags to "cabal build" in any other way than using .cabal file?
00:58:13 <merijn> There's no way to convince the type checker to consider "IO ()" as having type "IO a", right?
00:58:22 <ClaudiusMaximus> killy9999: i think "cabal configure" is the one you want to pass options too with     --PROG-options=OPTS             give extra options to PROG
00:58:45 <killy9999> OK
00:58:51 <ClaudiusMaximus> killy9999: "cabal install" does configure and build and install, or something like it
00:59:30 <Ralith> merijn: what do you want that for?
01:00:06 <killy9999> ClaudiusMaximus: I am trying to figure out how to use ghc-core with cabal
01:00:21 <merijn> Ralith: I have a forever with a "IO ()" inside, but wrapped with an exception handler of type "IO a"
01:00:33 <ClaudiusMaximus> killy9999: g'luck - i have to go out now..
01:00:40 <killy9999> OK
01:00:44 <merijn> Ralith: Unfortunately "handle :: Exception e => (e -> IO a) -> IO a -> IO a"
01:01:00 <merijn> Ralith: So the "forever :: IO ()" forces the handler to unify with "IO a"
01:01:07 <merijn> eh, IO ()
01:01:14 <ClaudiusMaximus> :t forever
01:01:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
01:01:21 <merijn> whereas the handler really can pick to return anything it wants
01:01:34 <Ralith> merijn: isn't this one of the few cases where unsafeCoerce might be applicable?
01:01:44 <Ralith> or perhaps
01:01:45 <merijn> ClaudiusMaximus: hmmm, so maybe it's not forever that's causing it then...
01:01:52 <Ralith> forever >> return (undefined :: a)
01:02:00 <JuanDaugherty> am I the only one put off by being wished "good luck" for something that is simply the work one claims to be a professional in?
01:02:05 <Ralith> ooor moot point.
01:03:49 <JuanDaugherty> but only a teensy bit, one adjusts
01:24:11 <sheriff_> Is it correct to say "type x is an instance of type class y"?
01:24:26 <quicksilver> yes
01:24:35 <sheriff_> thanks :-)
01:24:35 <quicksilver> "Int is an instance of Num"
01:25:40 <sheriff_> How about the sentence: "`quadruple` is a parametrically polymorphic function - while it can be called on different types, its definition is the same for those types"
01:26:11 <JuanDaugherty> O_o
01:26:12 <Cale> sheriff_: yes
01:26:34 <sheriff_> Thanks
01:26:36 <shachaf> Parametric polymorphism applies to more than functions, though.
01:26:41 <Cale> There's a bit of weirdness in saying that it's just plain parametrically polymorphic
01:26:50 <sheriff_> Cale: How so?
01:26:54 <Cale> usually you'd want to say that it's type class polymorphic
01:27:08 <shachaf> I thought sheriff_ meant quadruple f x = f (f (f (f x)))
01:27:22 <shachaf> ...Mostly because of the discussion earlier today, but that was someone else.
01:27:34 <Cale> oh, given your question about Num just before that, I would have thought  quadruple x = 4*x
01:27:58 <sheriff_> In this case, `quadruple` is (double . double)
01:27:59 <shachaf> quadruple x = x*4, if anything.
01:28:21 <shachaf> Or x+x+x+x!
01:28:25 <evincar> quadruple :: (a -> b /\ b -> c /\ c -> d /\ d -> e) -> a -> e
01:28:31 <evincar> If only.
01:28:39 <shachaf> Anyway, type class polymorphism isn't really parametric.
01:28:56 <Cale> I would say it is
01:29:07 <sheriff_> Really? I'm arguing it is... :-P
01:29:09 <Cale> It's not unrestricted parametric polymorphism
01:29:23 <sheriff_> That it allows both parametric and ad-hoc polymorphism
01:29:35 <Cale> It's not really ad-hoc
01:29:41 <sheriff_> This essay either makes some sense or I am disappearing up my behind
01:30:01 <sheriff_> Cale: It allows you to define different functions that share the same name, that the compiler dispatches based on the type you pass in
01:30:32 <Cale> sheriff_: But which type that is doesn't have to be fixed at the place where the term is used.
01:30:43 <Cale> (like with ad-hoc polymorphism)
01:30:55 <sheriff_> Cale: That's why it enables parametric polymorphism too
01:31:06 <sheriff_> Because you can compose the ad-hoc polymprophic functions
01:31:10 <Cale> There's a comparison to be made in that typeclass polymorphism and ad-hoc polymorphism solve some of the same problems
01:31:16 <Cale> But they're not really the same thing
01:31:17 <sheriff_> in to paramtric polymorphic functions
01:31:58 <Cale> and I think it's unhelpful to try to say that typeclasses are some form of ad-hoc polymorphism, it's better to say that they're a restricted or guarded sort of parametric polymorphism
01:32:09 <startling> what not-cabal markdown libraries are any good?
01:32:15 <startling> err, not-pandoc
01:32:32 <sheriff_> startling: What are you doing?
01:32:33 <Cale> Typeclass polymorphism also isn't quite the same as unrestricted parametric polymorphism
01:32:42 <Cale> the latter gives you free theorems which the former doesn't
01:33:00 <sheriff_> I think I have lost interest in trying to improve this essay
01:33:30 <sheriff_> It's probably wrong, but it's probably also at this point an accurate reflection of my understanding
01:33:34 <sheriff_> So let the markers have at it!
01:33:50 <quicksilver> sheriff_: I think a problem is that mathemeticians aren't really perfectly consistent in how they use words
01:34:09 <startling> sheriff_: rendering static pages, but I want to work with a recent blaze-html
01:34:21 <quicksilver> One author might take a very extreme view on what parametric requires, to make a point about free theorems
01:34:38 <quicksilver> and another author who is more interested in how to write compilers might take amore pragmatic one.
01:38:07 <Cale> > let f :: (Show a) => Integer -> a -> String; f x 0 = show x; f x n = show [x] in map (f ()) [0..]
01:38:08 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
01:38:09 <lambdabot>         against inf...
01:38:18 <Cale> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = show [x] in map (f ()) [0..]
01:38:19 <lambdabot>   ["()","[()]","[()]","[()]","[()]","[()]","[()]","[()]","[()]","[()]","[()]"...
01:38:46 <Cale> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = f [x] (n-1) in map (f ()) [0..]
01:38:48 <lambdabot>   ["()","[()]","[[()]]","[[[()]]]","[[[[()]]]]","[[[[[()]]]]]","[[[[[[()]]]]]...
01:38:54 <Cale> that's the one :)
01:39:01 <Cale> sheriff_: ^^
01:39:19 <Cale> That is a little bit hard to explain via ad-hoc polymorphism
01:39:38 * sheriff_ reads
01:39:54 <Cale> There are infinitely many 'show' functions we're using
01:40:20 <Cale> at different types :)
01:41:48 <evincar> Anyone know of a way to reify a module?
01:42:15 <evincar> I need names, type signatures, and data declarations.
01:43:02 <Cale> > let f :: (Show a) => a -> Integer -> String; f x 0 = show x; f x n = f (x,x) (n-1) in map (f ()) [0..]
01:43:04 <lambdabot>   ["()","((),())","(((),()),((),()))","((((),()),((),())),(((),()),((),())))"...
01:43:12 <dmwit> evincar: The GHC API, I guess.
01:43:30 <Cale> It's unclear what is meant by "reify" I think.
01:43:51 <Cale> There's no straightforward way to turn modules into values.
01:44:14 <Cale> But if you have the source code, you could run a Haskell parser over it, and that would be something...
01:45:10 <evincar> Cale: The API seems...unhelpful.
01:45:58 <evincar> By "reify" I mean I want the GHC API to give me a Big Damn Haskell alue with the names and types of all the toplevels in a module.
01:46:47 <evincar> Whether they're declared explicitly or not.
01:47:05 <Cale> So that implies running the typechecker at least
01:47:10 <evincar> Yes.
01:47:43 <Zariel> If i have a function to just return a String, but i need to use the IO monad how can I mix it in ?
01:48:16 <Cale> evincar: you could use hint, which has some module querying stuff
01:48:19 <dmwit> :t return
01:48:21 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
01:48:58 <Cale> Zariel: perhaps a 'let' statement inside the do-expression?
01:49:00 <Zariel> i guess Im giong to have to do an intermediary function in the io monad to return it
01:49:37 <Cale> do x <- getLine; let { y = reverse x }; putStrLn y
01:49:40 <dmwit> Your question isn't really specific enough to answer, Zariel.
01:49:42 <ski> Zariel : the intermediary doesn't need to be in `IO', unless it needs to call any `IO'-operation
01:49:42 <quicksilver> evincar: you can't get the names of non-exported toplevels from a compiled module.
01:49:49 <XexonixXexillion> Does anyone know how I can build a graph from a list of contexts in fgl, having it ignore edges linking to nodes not in the list of contexts?
01:49:54 <quicksilver> evincar: (they're not there)
01:49:59 <Cale> (you can leave out the braces and semicolons if you're using layout)
01:50:00 <Zariel> this is what im doing, https://gist.github.com/bd78416eb2068141d698
01:50:09 <quicksilver> so you will need to use the interpreter / type checker on the actual source code
01:50:32 <Cale> Zariel: Well, that has type  Maybe (IO Handle)
01:51:03 <ski> Zariel : since `getHandle' calls `openFile', it needs to contain `IO' somewhere in it's result type
01:51:06 <Cale> Zariel: Which might be just fine
01:51:53 <Zariel> Yeah thats what I figured
01:51:56 <Zariel> the other case is this
01:51:58 <Zariel> getHandle ("--stdin" : xs) = Just stdin
01:52:03 * hackagebot morfeusz 0.4.1 - Bindings to the morphological analyser Morfeusz  http://hackage.haskell.org/package/morfeusz-0.4.1 (JakubWaszczuk)
01:52:06 <Zariel> which is why its not in the IO monad already
01:52:11 <evincar> quicksilver: Source code is fine. Looking at hint now.
01:52:30 <startling> bah. is there a way I can specify the <title> for pandoc's standalone html?
01:52:30 <Cale> Zariel: Yeah, you'd want that to be  Just (return stdin)  if you want the types to match
01:52:48 <Cale> Zariel: You might also prefer  IO (Maybe Handle)  to  Maybe (IO Handle)
01:53:38 <Cale> Zariel: A value of the first type is an IO action you can execute to give you a Maybe Handle, the latter is Maybe (an action you can execute to give you a Handle)
01:53:59 <Zariel> which is why its not in the IO monad already
01:54:02 <Zariel> woops
01:55:04 <Cale> But Maybe (IO Handle) is somewhat more precise, given that you can tell from that without actually opening the file whether you have a way to get a handle from your command line options
01:55:38 <Zariel> Cale: thanks very much :)
01:58:03 <ski> @type Data.Traversable.sequence `asAppliedTo` Just (System.IO.openFile ?path System.IO.ReadMode)
01:58:04 <lambdabot> (?path::FilePath) => Maybe (IO GHC.IO.Handle.Types.Handle) -> IO (Maybe GHC.IO.Handle.Types.Handle)
02:03:57 <imperative_coder> hello
02:04:51 <imperative_coder> > let p n = (/ fromIntegral n) . (* 100) in p 50 30
02:04:54 <lambdabot>   60.0
02:04:58 <imperative_coder> how does the dot work in there?
02:05:21 <ski>   p n = (/ fromIntegral n) . (* 100)
02:05:24 <ski> is the same as
02:05:30 <ski>   p n x = ((/ fromIntegral n) . (* 100)) x
02:05:35 <ski> which is the same as
02:05:45 <ski>   p n x = (/ fromIntegral n) ((* 100) x)
02:05:47 <ski> which is the same as
02:05:52 <ski>   p n x = (/ fromIntegral n) (x * 100)
02:05:54 <ski> which is the same as
02:06:00 <imperative_coder> ah
02:06:03 <ski>   p n x = x * 100 / fromIntegral n
02:06:18 <imperative_coder> so it's essentially computing the percentage out of n?
02:06:28 <srhb> _NO_
02:06:32 <imperative_coder> no?
02:06:36 <imperative_coder> :t (.)
02:06:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:06:41 <ski> `(/ fromIntegral n) . (* 100)' means the function that first multiplies its input with `100', then divides the result of that with `fromIntegral n'
02:06:41 <shachaf> You asked how the dot works, not what it's doing.
02:06:41 <imperative_coder> O.o
02:06:46 <ski> @src (.)
02:06:46 <lambdabot> (f . g) x = f (g x)
02:06:47 <lambdabot> NB: In lambdabot,  (.) = fmap
02:07:03 * hackagebot Configurable 0.1.0.0 - Declare types as Configurable then specialize them all in one place  http://hackage.haskell.org/package/Configurable-0.1.0.0 (JosephAbrahamson)
02:08:13 <qasi> [11:06:25] <lambdabot> NB: In lambdabot,  (.) = fmap
02:08:14 <qasi> ooooh
02:08:37 <srhb> imperative_coder: 42/100 = 42 percent. 42 * 100/100 = fourty two hundred percent. Pet peeve from teaching grade schoolers. ._.
02:08:46 <qasi> i love the ((->) r) functor
02:08:56 <imperative_coder> right
02:08:56 <ski> > negate . [-3,2,-1,1,0,1,1,2,3]
02:08:58 <lambdabot>   [3,-2,1,-1,0,-1,-1,-2,-3]
02:09:13 <imperative_coder> map negate [1..10]
02:09:23 <imperative_coder> > map negate [1..10]
02:09:24 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
02:09:31 <imperative_coder> > fmap negate [1..10]
02:09:33 <lambdabot>   [-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]
02:09:41 <imperative_coder> ah
02:09:41 <ski> ("percent" essentially means "/ 100")
02:09:50 <imperative_coder> true
02:10:15 <ski> > ((`execStateT` 1) . forever $ do n <- get; if n >= 100 then throwError ("I'm trapped in a string : " ++ show n) else put (2 * n)) :: Either String Integer  -- a short `forever'
02:10:17 <lambdabot>   Left "I'm trapped in a string : 128"
02:10:32 <srhb> ski: s/essentially/literally
02:10:34 <srhb> :P
02:11:00 <Zariel> Why cant I do this? https://gist.github.com/5eff44103584cdd10fe8
02:11:43 <hpaste> Janthinidae pasted “Parser” at http://hpaste.org/76479
02:12:32 <shachaf> ski: In particular, "per" means "/" and "cent" means "100".
02:12:50 <Eduard_Munteanu> Zariel: you probably want IO (Maybe Handle)
02:13:19 <tumdum> > :t (>>=)
02:13:20 <lambdabot>   <no location info>: parse error on input `:'
02:13:24 <Janthinidae> Yesterday I was asking about writing a parser. Anyone willing to look at my script (http://hpaste.org/76479) and mention what could be improved?
02:13:31 <ion> I don’t understand why many languages call it “procent” or some variant of that. Including Finnish.
02:14:02 <srhb> ion: Latin.
02:14:08 <Eduard_Munteanu> ion: hrm, same here
02:14:19 <ion> srhb: “pro” is Latin for “per”?
02:14:23 <srhb> ion: Right.
02:14:29 <ion> ok
02:14:36 <tumdum> @type (>>=)
02:14:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:14:39 <Eduard_Munteanu> And what's the origin of "per" then?
02:14:45 <Eduard_Munteanu> Greek?
02:15:10 <srhb> Actually, I may have it backwards.
02:15:13 <ski> Zariel : perhaps you meant `run (getHandle args)' ?
02:15:38 <ion> dictionary.com says both come from Latin.
02:15:47 <ion> into English, that is
02:15:52 <imperative_coder> how do i produce tiny haskell executables?
02:15:54 <Zariel> ski: ah, doh :)
02:16:16 <Eduard_Munteanu> imperative_coder: dynamic linking and stripping
02:16:19 <ion> imperative_coder: By dynamic linking (but then the binary depends on a dynamically linked GHC runtime).
02:16:28 <startling> imperative_coder, use a tiny compiler
02:16:47 <imperative_coder> so ghc -dynamic ?
02:17:03 * hackagebot aws-sdk 0.4.1.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.4.1.0 (YusukeNomura)
02:17:24 <ion> yeah
02:18:53 <imperative_coder> hmm the executable is still larger compared to the C++ executble :(
02:19:12 <ski>   lexer s0 = Text txt : lexer s1
02:19:15 <ski>     where
02:19:15 <ski>     (txt,s1) = break (`elem` "@{}") s0
02:19:20 <imperative_coder> 5864 vs 36736
02:19:21 <ski> Janthinidae ^
02:20:21 <Janthinidae> Ski: Thanks I'll look at it
02:20:36 <Zariel> Can you add class constraints to type definitions?
02:20:48 <Zariel> ie, type Fish = (Num => a) [ a ] ?
02:21:10 <mm_freak> Polarina: i can think of many scenarios where a manager wire would be useful, but i'm having difficulty unifying the interfaces…  in particular so far i think that monadic updates are most useful coupled with an IxSet
02:21:10 <ion> imperative_coder: Is your floppy disk getting full?
02:21:24 <imperative_coder> ion: no ^^
02:21:41 <mm_freak> Polarina: in other words updates wouldn't happen through input, but the individual subwires would perform the update themselves
02:22:02 <mm_freak> Polarina: either through their output or through monadic binding
02:22:55 <ski> Janthinidae : also see the hint suggestions below the paste
02:23:14 <Janthinidae> sk: yeah I already incorporated them, but break was a better idea
02:23:26 <dada-cetacean> I tried defining fromJust (Just x) = x; but for some reason trying to evaluate fromJust (Just 1) gives an error; what went wrong?
02:23:45 <Botje> dada-cetacean: is the error about ambiguous values?
02:23:56 <Botje> @hoogle fromJust
02:23:56 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
02:24:25 <Botje> dada-cetacean: what type did haskell infer for fromJust?
02:24:28 <Botje> try :t fromJust
02:24:36 <sopvop> > fromJust Nothing
02:24:37 <lambdabot>   *Exception: Maybe.fromJust: Nothing
02:24:41 <dada-cetacean> oh. Maybe [a] -> [a]
02:24:45 <dada-cetacean> that would explain why it works for lists only
02:24:57 <Botje> dada-cetacean: you probably want to widen the type then
02:25:11 <Botje> put "fromJust :: Maybe a -> a" above the definition
02:25:45 <ion> fromJust is evil.
02:25:45 <mm_freak> dada-cetacean: if that's what GHC inferred, then your fromJust is probably not a top level definition, but inside a let/where of another one
02:25:49 <dada-cetacean> whoo, it works! thanks
02:26:04 <mm_freak> dada-cetacean: in any case, fromJust is something you wouldn't want to use
02:26:16 <mm_freak> it's 'head' for Maybe
02:26:27 <mm_freak> and you know why 'head' is a bad idea
02:27:45 <Janthinidae> ski: btw. what runs in the background of hpaste? I'm quite impressed that it 'rewrites' my code and not just gives some generic hints
02:28:28 <quicksilver> hlint, Janthinidae
02:28:46 <ehamberg> see for yourself: https://github.com/chrisdone/hpaste :-)
02:29:06 <imperative_coder> hlint ftw
02:30:50 <ski> Janthinidae : is `parser (lexer "@a{A")' meant to succeed parsing as `[Tag "a" [Value "s"]]' ?
02:32:58 * sheriff_ {heart} hlint
02:33:43 <Janthinidae> ski: In fact not, I think I've to write another function where I explicitly catch such a thing
02:37:04 * hackagebot network-transport-tests 0.1.0.1 - Unit tests for Network.Transport implementations  http://hackage.haskell.org/package/network-transport-tests-0.1.0.1 (EdskoDeVries)
02:37:06 * hackagebot network-transport-tcp 0.3.1 - TCP instantiation of Network.Transport  http://hackage.haskell.org/package/network-transport-tcp-0.3.1 (EdskoDeVries)
02:39:15 <john__> hi. what does this mean?
02:39:15 <john__> Thread raised exception: Ratio.%: zero denominator
02:39:41 <ion> > 5 / 0 :: Rational
02:39:42 <lambdabot>   *Exception: Ratio.%: zero denominator
02:39:51 <srhb> john__: Division by zero is bad. :-)
02:40:21 <ivanm> srhb: unless you _like_ destroying the universe! :p
02:41:07 <john__> Hehe, yes, but does that have anything to do with my program? It worked a few hours ago and I did not make any changes. Now it stopped working and I get strange exception, when I try. And there is no exceptions on other computers - only when I try on my laptop.
02:41:28 <srhb> john__: Your program is dividing by zero somewhere.
02:41:40 <srhb> john__: Which causes it to crash.
02:41:59 <john__> Hm... strange. I'm wondering why I do not get that message on the other computer, then.
02:42:18 <srhb> john__: If it only happens in some environments then it would seem that specific environments affect your program in a way that causes it to divide by zero.
02:42:38 <john__> Hm... I also get this one:
02:42:38 <john__> Thread raised exception: arithmetic overflow
02:42:57 <srhb> maxBound + 1 :: Int
02:43:00 <cornihilio> hey, can someone help explain what this code says?: data Action = Move (Int, Int) | Tag I am trying to say an Action is either a Move, with an (Int, Int), or Tag. Is that right?
02:43:01 <srhb> > maxBound + 1 :: Int
02:43:03 <lambdabot>   -9223372036854775808
02:43:06 <srhb> Aw, that doesn't work
02:43:09 <typoclass> john__: it might be an issue like your laptop is 32 bit, while your other computers are 64
02:43:39 <john__> It could be, but is that a problem?
02:44:06 <ski> > (recip . fromIntegral) (maxBound + 1 :: Word) :: Rational
02:44:08 <lambdabot>   *Exception: Ratio.%: zero denominator
02:44:28 <typoclass> john__: well something has to be different about the two machines. you pointed that out correctly
02:44:38 <typoclass> john__: is the program short enough to put on hpaste?
02:44:49 <john__> Yes, it is - I'll paste it :)
02:44:55 <john__> It's about 125 lines.
02:45:11 <ski> Janthinidae : one way would be to keep track of the nesting depth, and only allow the empty token list to successfully end the parsing in case the level is `0'
02:46:39 <john__> Right here: http://pastebin.com/M43ZX4aJ
02:47:53 <john__> http://pastebin.com/pYpw4jeE
02:48:10 <bxc> in a profile, i'm seeing a lot of time taken by sat_sNb:
02:48:10 <bxc> CAF:sat_sNb             Main                              89.6  100.0  47452 22104856224
02:48:16 <bxc> any pointers to figure out what that is?
02:48:22 <john__> I'm using WinHugs on both machines to run the programs.
02:49:13 <john__> The program is supposed to draw fractals.
02:50:33 <john__> But while drawing, it crashes on this laptop (it didn't just a few hours ago) ;)
02:51:01 <ion> Is Hugs still maintained?
02:51:27 <Eduard_Munteanu> Hugs is long dead AFAIK.
02:51:37 <ion> That’s what i thought.
02:52:01 <Eduard_Munteanu> john__: you might want to try the Haskell Platform.
02:52:05 <Eduard_Munteanu> @where platform
02:52:05 <lambdabot> http://hackage.haskell.org/platform/
02:52:19 <john__> Is it? Well, the teacher suggested that we used Hugs. But could the Haskell platform run my program as well?
02:52:48 <john__> I will try :)
02:54:07 <john__> I don't need to make any changes in the code to make it work outside Hugs?
02:54:34 <merijn> john__: As long as your code is valid haskell it should
02:54:46 <Eduard_Munteanu> I think the main reason some people stuck with Hugs is its IDE and the sometimes more helpful error messages.
02:54:48 <bxc> doh forgot -auto-all - now i get muhc better cost centres
02:54:50 <Eduard_Munteanu> But it's really old.
02:55:07 <typoclass> it's all a bit interesting. john's program doesn't use % or Rational, and neither does the HGL package (his only import)
02:55:34 <john__> Oh, I wasn't aware of that - but I'm currently installing the Haskell platform :)
02:56:04 <hpaste> typoclass pasted “related to the overflow? related to div by 0?” at http://hpaste.org/76480
02:56:34 <typoclass> what do you guys think of this? ^^ it's from SOE.hs in the HGL package
02:57:02 <atriq> Hehe I'm actually using lenses
02:57:15 <typoclass> john__: do you use hugs on both computers, or ghc here and hugs there?
02:57:38 <john__> Yes, I use Hugs on both computers :)
02:57:53 <john__> But I'm currently installing the Haskell platform here.
03:00:32 <john__> Hm, there is just one problem: Could not find module `Graphics.HGL'
03:00:38 <john__> Do I need to download that separately?
03:01:44 <john__> I guess it was part of Hugs, since I didn't have to do anything to make it work.
03:02:03 <typoclass> john__: normally you just do "cabal install HGL". cabal is a part of the platform. not sure how hugs did it
03:02:04 * hackagebot aeson-lens 0.1.0.2 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.1.0.2 (HideyukiTanaka)
03:02:53 <Kyraimion> HGL doesn't build on ghc >= 7.0
03:02:59 <typoclass> ... urgh, HGL hasn't been updated since 2009
03:03:06 <typoclass> Kyraimion: right :(
03:03:13 <john__> <interactive>:10:1: Not in scope: `cabal'
03:03:13 <john__> <interactive>:10:7: Not in scope: `install'
03:03:19 <john__> <interactive>:10:15: Not in scope: data constructor `HGL'
03:03:23 <john__> Hm...
03:03:44 <Kyraimion> john__:  No, you need to enter it in the terminal, not ghci
03:03:49 <quicksilver> I have some vague memory of more modern compatible rewrites of HGL
03:03:52 <Kyraimion> john__:  cabal is a program
03:04:02 <john__> Oh...
03:04:13 <typoclass> john__: no, cabal is meant for the command line :) not in ghci (or hugs). but it is true that HGL can't help you anyway
03:05:20 <quicksilver> hmm. I think HGL *was* the new one (newer than the original SOE) but still now sadly out of date
03:05:24 <quicksilver> :(
03:05:29 <john__> Hm, any alternatives without a major rewrite of the program, if I just want to "make it work"?
03:06:16 <john__> Hugs is obviously not the best choice?
03:06:16 <quicksilver> install older GHC/older platform?
03:06:19 <typoclass> john__: you're new to haskell, right?
03:06:26 <john__> Yes, I am
03:06:36 <typoclass> john__: ok welcome :)
03:06:37 <john__> I am not very experienced with Haskell.
03:06:40 <john__> Thanks ;)
03:07:17 <typoclass> (if you were intermediate, or very adventurous, i'd have suggested you change the HGL.cabal file, loosen the version on 'base' and on 'X11', and see what happens ...)
03:07:49 <john__> Well, it sounds very interesting, but I have to say, I have no idea how to do that ;)
03:08:02 <john__> But I will try to find an older Haskell platform and install it, if you think that would be the best way?
03:08:35 <Jafet> Just remove the number after base, see what happens
03:08:58 <john__> Where is the file located? Can I just open it with a normal text editor?
03:09:13 <typoclass> Jafet: hang on, i'm on it
03:09:20 <Jafet> Well, it's best to use a good text editor.
03:09:20 <john__> :)
03:09:44 <john__> Sometimes I use Eclipse, sometimes I simply use Notepad++
03:11:11 <Kyraimion> Does cabal-dev ghci work for somebody with cabal-dev 0.9.1 and cabal-install 1.16.0 ?
03:12:49 <typoclass> Kyraimion: not what you asked, but fwiw, 0.9.1 works with Cabal 1.10.1.0
03:15:12 <Kyraimion> typoclass:  Yes that worked for me as well, but I fixed what wasn't broken and now I have cabal-install 1.16.0 and cabal-dev ghci doesn't work. So I'm wondering if that's a problem with my system or if cabal-dev doesn't play nicely with cabal-install 1.16 in general
03:16:01 <killy9999> is there a way to add something to ghc's eventlog?
03:16:26 <killy9999> I would like to mark some point in my program to deduce what is going on during runtime
03:17:29 <imperative_coder> http://www.youtube.com/watch?v=ScS8Q32lMxA
03:18:41 * killy9999 learned about tmux from that video
03:19:02 <typoclass> how do i compile a file (ghc) using the packages cabal-dev installed?
03:19:12 * ski hugs screen
03:19:35 <john__> :D
03:19:55 <imperative_coder> why should or shouldn't I annotate the type of main?
03:20:08 <dada-cetacean> is there a "null" value such that [] = [null]?
03:20:24 <ski> imperative_coder : taste ?
03:20:28 <ski> dada-cetacean : no
03:21:06 <ski> regardless of what `null' was, `[null]' would be a list with a single element, namely `null' -- not an empty list
03:21:10 <ski> > length [null]
03:21:11 <lambdabot>   1
03:21:16 <ski> > length []
03:21:17 <lambdabot>   0
03:21:35 <imperative_coder> where can I read some good Haskell style guides?
03:21:37 <ski> dada-cetacean : perhaps you want to use `++' or `concat' somewhere ?
03:21:57 <Tester> servus
03:21:57 <troydm> imperative_coder: on RLW and LYH
03:22:22 <john__> Hehe, I cannot even download a Haskell platform from 2009 - I simply get a 404:
03:22:23 <john__> http://www.haskell.org/platform/2009.2.0/HaskellPlatform-2009.2.0-setup.exe
03:22:28 <dada-cetacean> ski: nope, was just reading and got curious
03:22:32 <troydm> imperative_coder: http://is.gd/49mcxr
03:22:33 <ski> @where style
03:22:33 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide
03:22:50 <ski> imperative_coder : ^ might perhaps be useful (i've only looked very superficially at it)
03:23:23 <jix> dada-cetacean: Maybe with catMaybes can get you something similar... catMaybes [Just 1, Nothing, Just 2] == [1, 2]
03:23:43 <troydm> imperative_coder: ohh you mean style guide
03:23:52 <Zariel> Is this correct way to use forall in a type definition? type Stack = forall a. Num a => [ a ]
03:23:59 <troydm> well style no matter how you'll write your code
03:24:09 <troydm> reading it later will be pain in da ass anyway
03:24:10 <ski> Zariel : what are you trying to achieve by that ?
03:24:53 <Zariel> i want a list of Numbers
03:25:03 <Zariel> ski: so [1, 1.1, 1] for instance, is that posible?
03:25:19 <ski> yes, but it's probably not what you want
03:25:37 <jix> Zariel: you won't be able to add two different list items with that type though
03:25:45 <jix> oh wait I misread what you wrote
03:26:23 <Zariel> First I thought i would just use, :: (Num a) => [a]
03:26:31 <Zariel> but I cant define a type that way
03:26:39 <Kyraimion> imperative_coder:  It's considered good form to annotate all top level definitions, including main
03:26:48 <ski> with `data AnyNum = forall a. Num a => WrapNum a', you could have `[WrapNum (1 :: Int),WrapNum (1.1 :: Double),WrapNum (1 :: Rational)]', of type `[AnyNum]'
03:26:54 <Kyraimion> imperative_coder:  It's a form of compiler-checked documentation
03:27:01 <ski> but you can't do much with an `AnyNum'
03:27:27 <ski> e.g. you can't add two of them together as jix said, since you don't know that they have the same type inside
03:27:44 <Eduard_Munteanu> Zariel: you can't use a type synonym there
03:28:27 <jix> Eduard_Munteanu: with RankNTypes it's fine
03:28:33 <jix> or Rank2Types
03:28:39 <Eduard_Munteanu> Yeah, but not what he really wants.
03:28:41 <nand`> but probably not what he meant
03:28:48 <typoclass> john__: if you're interested i did get your program to run on a modern ghc, but it requires a few steps
03:29:19 <john__> typoclass: I'm very interested :)
03:29:25 <Eduard_Munteanu> You can't really hide the Num constraint that way.
03:29:35 <ski> Zariel : additionally, you don't know a common third type the two types inside two `AnyNum's could be converted to, so you can't add that way either
03:29:35 <john__> Especially if you're willing to explain the steps to a beginner ;)
03:29:45 <jix> Zariel: most likely you just want to use [a] with a (Num a) constraint on the function that takes or returns that list
03:30:02 <Zariel> yeah thats what I was thinking I would end up having to do
03:30:15 <Zariel> i was trying to just use custom types to add clarity to the functions
03:30:42 <atriq> How evil an extension is TupleSections?
03:30:55 <ski> Zariel : what you *can* do is `data MyNum = AnInt Int | ADouble Double | ARational Rational', then you *can* actually use `[AnInt 1,ADouble 1.1,ARational 1]'
03:31:15 <Zariel> hm that may be an option
03:31:39 <ski> this requires you to know all the possible number types you want to be able to handle in advance
03:31:51 <Zariel> if i define a list of (Num a) => [a], all the a's have to be 1 concrete type ?
03:32:01 <ski> yes
03:32:17 <ski> in fact they have to be polymorphic, i.e. have to be of *every* number type
03:32:21 <Zariel> i only need to handle fractional numbers and whole numbers
03:32:31 <Zariel> so (Fractional a) => [a] should be ok
03:32:42 <nand`> atriq: I don't think it's that evil, eg. compare (,,x) <$> foo <*> bar with (\z y -> (z,y,x) <$> ... or whatever
03:32:55 <nand`> latter is arguably much uglier in this case
03:33:16 <ski> Zariel : `Fractional a => [a]' by itself will probably not do what you want
03:33:20 <atriq> nand`, I remember some people complaining that something like ((,x,),,(,,y)) was misleading?
03:33:26 <atriq> Or something like that?
03:33:41 <ski> Zariel : `myFun :: Fractional a => [a] -> ..a..' could perhaps work
03:33:46 <EarlGray> Hello, I have some problems with cabal dependencies, could someone help me?
03:33:54 <ski> (depending on what you want)
03:34:07 <nand`> I don't think it is? \z -> (\a b -> (a,x,b), z, \a b -> (a,b,y))
03:34:35 <Kyraimion> EarlGray:  Don't ask to ask, just ask
03:34:55 <EarlGray> <command line>: cannot satisfy -package-id Cabal-1.14.0-4c06a562607ba36eb8da720380ff1c54:
03:34:57 <EarlGray>     Cabal-1.14.0-4c06a562607ba36eb8da720380ff1c54 is shadowed by package Cabal-1.14.0-bcd4d2f3c47a192df4df0c51ed21bbbf
03:35:09 <EarlGray> installing `plugins`
03:35:14 <ski> @type (>>= (return .))
03:35:15 <ski> @type \ma f -> ma >>= return . f
03:35:15 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m1, Functor m, Monad m) => m (m a) -> m (m1 a)
03:35:16 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m a -> (a -> a1) -> m a1
03:35:41 <ski> is `(>>= (return .))' misleading ?
03:36:38 <EarlGray> also a lot of packages requires unix-2.5.1.0, whereas another lot of packages unix-2.5.1.1
03:37:17 * ski thinks `TupleSections' is slightly evil -- about as much as ordinary operator sections are evil
03:37:18 <Kyraimion> EarlGray:  Minor version numbers shouldn't break anything, so you can just relax the upper bound on those that require 2.5.1.0
03:37:23 <Zariel> ski: thanks ill look into it and have a play with types
03:37:57 <ski> (however, some other suggestions for "expressions with holes in them" definitely are more evil)
03:38:21 <EarlGray> but Cabal-0.14.0 is shadowed by Cabal-0.14.0 with other checksum, and `plugins` can't be installed
03:38:22 <sopvop> Upper bounding on minor version should be considered a violent crime.
03:41:36 <ski> (thinking specifically about "Free Sections" by rasfar at <http://fremissant.net/freesect/> here)
03:42:01 <EarlGray> I meant Cabal-1.14.0
03:44:32 <ski> Zariel : note that if you define `myList :: Fractional a => [a]', then this means that the *user* of `myList', not you (the definer), gets to decide what type `a' should be (also every element in the list gets the same type `a'
03:45:23 <ski> Zariel : so `myList = [1 :: Int,1.1 :: Double]' would be incorrect then, since here you're trying to say what the types of the specific elements should be -- this doesn't work if e.g. the user wants all the elements to have type `Rational'
03:46:20 <cornihilio> could someone perhaps point out a really cool library using Haskell, or something that really points out Haskell's strong features? I've been learning it for a while, but I'm just looking for some motivation/something cool I can look forward to learning more about.
03:47:04 <AfC> cornihilio: some people might suggest "parsing" at this point; Haskell seems to do well there.
03:47:18 <cornihilio> AfC: as in parsec?
03:47:26 <AfC> cornihilio: of course, that's only interesting if you have some file data that you need to ingest
03:47:38 <ski> Zariel : also, since the user can select any type in the `Fractional' class, this means that the *only* information about the type `a' that you can use to construct this list is the fact that whatever type `a' will be used in the end will be an instance of `Fractional' (meaning : you know that the methods of `Fractional' and the suberclasses of that will work on them)
03:47:43 <AfC> cornihilio: as in Parsec, yes, and Trifecta, Attoparsec, and at least one other.
03:48:15 <hpaste> typoclass pasted “How to get HGL to compile” at http://hpaste.org/76481
03:48:25 <cornihilio> what about other than parsing?
03:48:29 <typoclass> john__: ^^ here's the instructions that worked for me
03:51:45 <cornihilio> for me, I think the strongest part of Haskell is the libraries. Not any library in specific, or even the community that's writing libraries; pure functional programming forces libraries to be strictly functional, so leveraging them is easy in a fundamental way that other languages can't compete with. At least that's my take on it, I have no clue if that's actually all that true, but that is my gut feeling about it.
03:52:43 <AfC> cornihilio: the other area that Haskell shines is domain specific languages. Have a look at the 2000 paper by Peyton Jones et al about Financial Contracts
03:52:48 <AfC> cornihilio: http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.htm
03:53:56 <nand`> what I like about Haskell, in no particular order: 1. the friendly and helpful community, 2. the availability of awesome libraries, 3. purity, static type system, nonstrictness, 4. the reasonably expressive type system (allowing for a greater number of abstractions)
03:54:27 <nand`> and last but not lead, 5. the minimalism with which things can be expressed; I observe a code shrink to 20% or so compared to C# on average
03:54:41 <typoclass> 0. the damn helpful compiler. it tells you everything that's wrong with your code, or might be wrong. if you can get something to compile, there's not many bugs left
03:54:42 <nand`> but not least*
03:55:13 * ski was figuring "last but not lead" was some interesting figure of speech ..
03:55:45 <quicksilver> I'm surprised code shrink as low as 20%
03:56:00 <cornihilio> yes, the community is amazing: irc, stackoverflow, blogs, reddit, it's everywhere really. Not sure I know of any other language community like it.
03:56:06 <EarlGray> plugins-1.5.2.3/1.5.2.2/1.5.2.1/1.5.1.4 - all failed to install
03:56:07 <quicksilver> although I'm not very familiar with C#, generally haskell is much better at factoring out repeating code patterns
03:56:23 <typoclass> ski: first is obviously gold, then silver and so on, until you get last = lead
03:56:32 <nand`> I write fairly compact C#, and I'm comparing on a ‘single file/module’ basis
03:56:43 <nand`> if you account for inter-module code re-use, the figure may drop
03:57:14 <nand`> why not start with Hydrogen, then Helium, then Lithium, etc.?
03:57:26 <nand`> Gold, Silver, Bronze ... seems a bit arbitrary
03:57:55 <typoclass> short guide on how to get an old package to compile: http://hpaste.org/76481 any additions or comments? i plan to put it on the wiki
03:59:39 <ski> well, iron is the end product of fusion (after decay)
04:00:51 <typoclass> ski: i think you can fuse to heavier elements, it's just that it costs energy instead of producing it
04:01:55 <ski> yes, so it doesn't occur naturally
04:02:34 <srhb> Oh it definitely does.
04:02:47 <srhb> There's an abundance of energy, after all. It's just that it's negligible amounts outside of supernovae.
04:04:30 <typoclass> ski: well, right at the start of the universe, nothing 'occurred naturally' that would be familiar to us :)
04:05:22 <fmap> typoclass: funny thing there is no Control.OldException in modern ghc
04:05:47 <fmap> (FSVO modern)
04:05:55 <typoclass> fmap: did they remove it in ghc 7.6? it's present on my 7.4
04:06:03 <fmap> typoclass: seems so
04:06:14 <typoclass> oh great ... :-/
04:06:52 <dada-cetacean> is there a function that gives the index of a specified element of a list?
04:07:32 <fmap> @ty elemIndices
04:07:34 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
04:08:39 <fmap> @ty elemIndex
04:08:40 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
04:08:58 <fmap> dada-cetacean: ^
04:09:09 <dada-cetacean> thanks!
04:11:20 <atriq> Do Word16 and Int16 have the same internal representation?
04:11:34 <atriq> As in, can I unsafeCoerce :: Word16 -> Int16 and vice versa?
04:13:33 <Nereid> atriq: looks like some strange things happen there
04:13:59 <Nereid> atriq: if I do (unsafeCoerce :: Word16 -> Int16) 65535, it writes 65535
04:14:03 <Nereid> whereas 65535 :: Int16 is -1
04:14:11 <Nereid> in ghci
04:14:29 <atriq> Ah, okay
04:14:29 <atriq> That's not what I want then
04:14:41 <Nereid> and they even test as unequal
04:14:46 <Nereid> fromIntegral will do it.
04:19:53 <ski> srhb : yes, i suppose "naturally" wasn't a good choice of words
04:20:58 <quicksilver> Nereid's test is not surprising to me.
04:21:27 <quicksilver> Word16 and Int16 do indeed have the same representation - as 32 (or 64) bit values
04:21:40 <quicksilver> however, they live in overlapping but different parts of that.
04:21:42 <Nereid> I figured it was probably something like that.
04:22:02 <quicksilver> it would be much more expensive to implement "16 bit 2s complement"
04:22:09 <quicksilver> (which is what you'd need to have done to get the -1 answer)
04:23:34 <Nereid> adding 0 to it gets it in the right range though
04:25:26 <Jafet> data Word16 = W16# Word#
04:26:26 <od--> is it possible to auto derive instances for Show for type families
04:27:06 * hackagebot ghc-mod 1.11.1 - Happy Haskell programming on Emacs/Vim  http://hackage.haskell.org/package/ghc-mod-1.11.1 (KazuYamamoto)
04:28:49 <Jafet> I believe standalone deriving works
04:31:16 <efie> when I do "ghc -O2 --make main.hs -prof -auto-all -caf-all -fforce-recomp" it fails after the "linking main ..." step with "/usr/bin/ld: cannot find -lHSdeepseq-1.3.0.0_p / collect2: ld returned 1 exit status". I reinstalled deepseq, but it did not help
04:31:25 <od--> jafet: thanks
04:32:38 <Jafet> "Did you install the profiling libraries for HSdeepseq?"
04:34:09 <fmap> is there any semantic difference between `type family F; type instance String' and `type F = String'?
04:34:26 <fmap> `type instance F = String' rather
04:34:53 <efie> Jafet: I did "cabal install deepseq --reinstall --enable-library-profiling" - is HSdeepseq something different?
04:35:17 <rfw> @pl \xs -> case filter (\x -> x `mod` 2 == 0) xs of [] -> Nothing; (x:xs) -> Just x
04:35:17 <lambdabot> (line 1, column 52):
04:35:17 <lambdabot> unexpected ">" or "-"
04:35:18 <lambdabot> expecting variable, "(", operator or end of input
04:35:31 <rfw> @pl \xs -> case filter (\x -> x `mod` 2 == 0) xs of { [] -> Nothing; (x:xs) -> Just x }
04:35:32 <lambdabot> (line 1, column 49):
04:35:32 <lambdabot> unexpected "{"
04:35:32 <lambdabot> expecting variable, "(", operator or end of input
04:36:21 <Jafet> @hackage HSdeepseq
04:36:21 <lambdabot> http://hackage.haskell.org/package/HSdeepseq
04:37:27 <typoclass> so they removed Control.OldException in ghc 7.6. is there a package that it was moved to?
04:38:13 <Alice> what's on?
04:39:20 <ski> discussion about and related to the programming language Haskell
04:39:55 <Alice> need to look up what Haskell is
04:40:08 <ski> @where haskell
04:40:08 <lambdabot> http://haskell.org
04:40:17 <typoclass> Alice: it's an odd, but very very good function programming language :)
04:40:25 <Alice> thanks
04:40:36 <typoclass> s/function/functional/
04:40:42 <ski> @pl \xs -> listToMaybe (filter (\x -> x `mod` 2 == 0) xs)
04:40:42 <lambdabot> listToMaybe . filter ((0 ==) . (`mod` 2))
04:40:48 <efie> Jafet: the link does not work ... I couldn't find it via google too
04:41:05 <efie> but it helped to reintalled containers
04:41:22 <efie> (why wasn't this displayed?)
04:41:23 <Jafet> ghc will have told you which library is missing.
04:41:41 <Jafet> Isn't containers part of the default distribution?
04:41:52 <efie> I reinstalled it with profiling libraries
04:42:24 <Jafet> That's strange, it should have already been.
05:05:04 <hpaste> efie pasted “how to make this function faster” at http://hpaste.org/76485
05:07:31 <sopvop> efie: Try to specialize it for certain type of 'a'.
05:08:21 <sopvop> And Data.Text comparision will be faster.
05:09:09 <efie> thanks
05:09:15 <ClaudiusMaximus> efie: define   sum' :: Num a => [a] -> a ; sum' = foldl' (+) 0    and use that instead of   sum = foldl (+) 0
05:10:11 <ClaudiusMaximus> efie: assuming that is the issue, rather than the comparisons
05:10:31 <sopvop> @source sum
05:10:32 <lambdabot> sum not available
05:10:41 <ClaudiusMaximus> @src sum
05:10:41 <lambdabot> sum = foldl (+) 0
05:11:01 <ClaudiusMaximus> but it's on Int so GHC should be clever enough
05:11:31 <ClaudiusMaximus> at least with -O or -O2
05:11:54 <sopvop> why not foldr?
05:12:22 <atriq> foldr makes a huge stack of functions but foldl reduces as it goes
05:12:34 <Saizan> foldl doesn't actually
05:12:37 <Saizan> foldl' would
05:12:43 <atriq> > foldr (+) 0 (replicate 10000 0)
05:12:43 <efie> isn't this then rather a space than time issue?
05:12:44 <lambdabot>   0
05:12:48 <atriq> > foldr (+) 0 (replicate 10000000000 0)
05:12:49 <lambdabot>   *Exception: stack overflow
05:12:58 <atriq> > foldl (+) 0 (replicate 100000000000 0)
05:13:02 <lambdabot>   mueval-core: Time limit exceeded
05:13:08 <atriq> > foldl (+) 0 (replicate 10000000000 0)
05:13:13 <lambdabot>   mueval-core: Time limit exceeded
05:13:26 <atriq> So foldl just takes ages, but foldr actually crashes
05:13:28 <Saizan> > foldl' (+) 0 (replicate 1000000000 0)
05:13:31 <lambdabot>   mueval-core: Time limit exceeded
05:13:40 <Saizan> atriq: foldl also takes a lot of heap
05:13:48 <typoclass> is this an equivalent of Control.OldException? http://hackage.haskell.org/package/extensible-exceptions-0.1.1.4
05:14:37 <Saizan> because you build a big thunk of additions in memory that need to be reduced later, probably causing a stack overflow at that point
05:14:51 <Saizan> foldl' instead keeps the accumulator in WHNF
05:14:59 <sopvop> It seems I've got foldr and foldl' mixed in my head :(
05:15:30 <Saizan> foldr is good when you have a complex result type and your result can be computed lazily
05:16:10 <quicksilver> which mostly means your result is a list, or ismorphic to one
05:16:26 <mikeplus64> are discriminated/tagged unions the same as adts?
05:16:42 <quicksilver> it kind of has to have at least a distinguished linear spine containing parts which can be evaluated on-demand
05:16:45 <Saizan> foldl' is good when you have a simple result type or your step function is strict in the accumulator, foldl is almost never good
05:16:46 <sopvop> mikeplus64: wikipedia says so
05:18:03 <sopvop> so, sum in prelude is bad?
05:19:16 <nand`> mikeplus64: you need tuples as well
05:19:34 <nand`> I guess
05:19:36 <merijn> Is there no way to enable tests when running cabal build?
05:19:37 <atriq> sopvop, sum in the Haskell Report is bad
05:20:00 <atriq> GHC by default uses a different implementation to the ones we've been discussing
05:20:08 <dcoutts_> merijn: sure, cabal configure --enable-tests; cabal build; cabal test
05:20:12 <nand`> ‘sum’ in GHC Prelude uses an explicit tail-recursive version
05:20:13 <merijn> "cabal build --enable-tests" says "unrecognised option" so that means I have to run "cabal configure --enable-tests && cabal build && cabal test"
05:20:32 <nand`> that accumulates the sum in an extra parameter, though not strictly
05:20:33 <sopvop> now I see it #ifdef USE_REPORT_PRELUDE
05:20:37 <nand`> I guess the GHC optimizer can pick that up
05:20:57 <dcoutts_> merijn: in general it needs to be done at configure time because your tests usually have extra dependencies, like QC etc
05:21:24 <Jafet> > sum [0 .. 10^7]
05:21:29 <lambdabot>   mueval-core: Time limit exceeded
05:21:33 <Jafet> > foldl1' (+) [0 .. 10^7]
05:21:35 <lambdabot>   50000005000000
05:21:45 <sopvop> Also - {-# SPECIALISE sum     :: [Int] -> Int #-}
05:22:31 <ClaudiusMaximus> efie: maybe add additional cost centres to your subexpressions with scc pragmas
05:22:31 <merijn> dcoutts_: Yeah, but if I configure with "--enable-tests" and cabal build will reconfigure without it if the cabal file has changed since the last build
05:22:39 <zhulikas> @src sum
05:22:39 <lambdabot> sum = foldl (+) 0
05:22:47 <ClaudiusMaximus> efie: and then re-profile
05:22:54 <dcoutts_> merijn: yes we could do more automatic dep stuff
05:23:35 <merijn> And clearly if I run "cabal build" after having configured with --enable-tests it's a bit annoying that it sometimes resets that flag
05:23:55 <dcoutts_> aye, I'm not sure why it's resetting it
05:24:14 <dcoutts_> but that bit of system is rather flaky and in the process of being rewritten
05:41:58 <akamaus> what's the modern library for web scraping with Haskell?
05:43:16 <nand`> what exactly does specializing do? generate extra code that calls those particular functions directly instead of going via the typeclass?
05:45:22 <sopvop> looks like you are right http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/pragmas.html#specialize-pragma
05:46:09 <sopvop> Moreover, given a SPECIALIZE pragma for a       function f, GHC will automatically create       specialisations for any type-class-overloaded functions called       by f, if they are in the same module as       the SPECIALIZE pragma, or if they are       INLINABLE; and so on, transitively.
05:49:00 <ClaudiusMaximus> hm, could that be used with NoMonomorphismRestriction to not recompute a polymorphic value at a finite set of specialized types?
05:49:48 <ClaudiusMaximus> or is it orthogonal, maybe i should test some time when i get sufficiently bored
05:59:28 <sopvop> Why Fridays are always that boring on internets?
06:01:58 <Lemmih> sopvop: Hacking anything fun?
06:02:41 <sopvop> cleaning up code, adding type annotations to top levels. Removing unused imports. dealing with shadowing names. (making GHC shut up -Wall)
06:03:39 <sopvop> Gods hate me now {-# OPTIONS -fno-warn-orphans #-}
06:04:47 <atriq> Don't warn the orphans
06:05:07 <atriq> We don't want them to see it coming
06:14:32 <john__> I get two warnings. I will copy/paste them in a minute.
06:14:34 <john__> My program: http://pastebin.com/MBAKwwRN
06:14:40 <maukd> The paste MBAKwwRN has been copied to http://hpaste.org/76488
06:14:49 <john__> Warning: Pattern match(es) are overlapped
06:15:05 <john__> In an equation for 'expand': expand _ _ _ = ...
06:15:12 <john__> Warning: Pattern match(es) are overlapped
06:15:19 <john__> In an equation for 'process': process _ = ...
06:15:27 <john__> Is that because something is "bad practice"?
06:15:38 <john__> Or should they simply be ignored?
06:15:58 <maukd> it's because you wrote nonsensical code that could never possibly be reached
06:16:00 <benmachine> john__: it's because when that happens it's usually because you've made a mistake
06:16:02 <maukd> you should remove the dead code
06:16:13 <benmachine> or misunderstood something
06:16:17 <john__> The dead code are these two lines, I guess?
06:16:21 <maukd> (and then look at what hlint has to say)
06:16:28 <maukd> john__: don't guess. understand first
06:17:15 <john__> Yes, I understand what you said that it is never reached. But what I do not know is whether they could simply be deleted, these two lines?
06:17:31 <maukd> no, you should understand the code
06:17:44 <benmachine> john__: ...what are you afraid of? :P
06:17:56 <maukd> john__: for example, what is line 39 supposed to do?
06:18:11 <john__> It was supposed to be a "base case"
06:18:31 <john__> Afraid of? Nothing really - I just don't understand the warnings :)
06:18:41 <maukd> under which circumstances would line 39 be executed (and not line 38)?
06:18:48 <benmachine> why do you need a base case?
06:19:03 <benmachine> what *is* a base case?
06:19:20 <ski> `... else state' is a base case
06:19:25 <benmachine> john__: what I meant by "afraid of" is, what do you expect might go wrong if you delete the lines
06:19:58 <maukd> benmachine: unpredictable runtime errors
06:19:58 <john__> I am not sure it would be reached. But I thought I had to cover "that case" as well.
06:20:08 <maukd> john__: but what exactly is "that case"?
06:20:26 <john__> That is what should happen if line 38 will not match.
06:20:28 <john__> For some reason.
06:20:38 <maukd> john__: but what if line 39 doesn't match either?
06:20:41 <maukd> for some reason
06:20:51 <john__> Wouldn't it always do that?
06:21:05 <maukd> wouldn't line 38 always match too?
06:21:15 <ski> the equation `expand state rules depth = ...' will be used if the three arguments match that patterns `state',`rules',`depth'
06:21:19 <ski> otherwise the equation `expand _ _ _ = []' will be used
06:21:19 <john__> Maybe? I don't know, that's why I asked.
06:21:34 <maukd> john__: you didn't ask about that
06:21:40 <ski> (now, under which conditions does "otherwise" happen ?)
06:22:12 <sopvop> @src otherwise
06:22:12 <lambdabot> otherwise = True
06:22:27 * sopvop is giving the hint
06:22:30 <maukd> sopvop: ?
06:23:22 <sopvop> oh, ski didn't mean THAT otherwise
06:23:46 <maukd> and even if he did, otherwise = True wouldn't help
06:23:46 * sopvop needs  more coffee
06:23:48 <john__> Hm... I wanted to know whether I should be worried about the warnings or they should be ignored. Basically I did not understand why they occurred, which is why I asked whether I should care about them.
06:23:52 <Nereid> john__: line 38 always matches
06:24:07 <john__> OK. So that's why it could just be skipped?
06:24:09 <Nereid> what warnings?
06:24:18 <maukd> Nereid: patterns are overlapped
06:24:19 <maukd> etc
06:24:23 <john__> Yep
06:24:26 <Nereid> ah
06:24:48 <Nereid> because lines 38 and 39 match exactly the same things
06:24:48 <maukd> john__: do you know how patterns work?
06:24:50 <Nereid> namely, everything
06:25:19 <maukd> a pattern is either a variable, or a constructor followed by 0 or more patterns
06:25:38 <john__> Yes, very basically, but I am not a Haskell guru, just a beginner.
06:25:39 <maukd> if it's a variable, it will match anything (and bind it to the variable)
06:26:03 <Saizan> john__: once one pattern matches that's the one picked and later ones don't get considered
06:26:10 <john__> :)
06:26:11 <maukd> if it's a constructor, it will match only that constructor, then recursively match the constructor's arguments against the subpatterns
06:26:25 <john__> So the right thing is to drop these lines? At least it fixed the problem.
06:26:34 <maukd> the special variable _ also matches anything but doesn't bind it
06:27:07 <maukd> so the patterns 'foo' and '_' match exactly the same values
06:27:40 <john__> Oh :)
06:27:50 <john__> Thank you for the explanation.
06:27:53 <ski> john__ : arguments will be matched with corresponding patterns, in turn. each of these matchings might fail -- in that case the next definition equation (if any) will be tried (if no next one, then a run-time pattern-match failure will be generated, aborting the computation) -- in case all the matchings succeed, the equation in question will be used, i.e. the definiens (i.e. the right-hand side of the `=') will be computed as the result of the
06:28:25 <ski> john__ : in this case, the respective patterns are `state',`rules',`depth', and since they're variables, they will *always* match
06:28:46 <ski> john__ : therefore, the next clause will *never* be reached, not under *any* circumstances
06:28:56 <john__> Great - and that is why it will never be reached, I see :)
06:29:12 <john__> I think that made it a lot more clear :)
06:29:18 <maukd> john__: scroll down to the end of the hpaste link if you want to see more warnings :-)
06:29:46 <john__> Oh, there are more warnings? I'll check
06:29:57 <ski> john__ : so, you need to ask yourself whether : (a) maybe you meant for the latter equation to be reached -- then you need to make sure it can be reached; or (b) maybe it was no mistake that it couldn't be reached -- and in that case it can just be removed
06:30:07 <john__> Some Redundant brackets, I see
06:30:16 <Nereid> john__: click them for more detail :v
06:30:29 <john__> ski: b is definitely the case.
06:30:38 <ski> john__ : btw, note that if there's any "guards" attached to the definition equation, then the matching process is slightly more complicated
06:30:45 <john__> Oh, I see :)
06:32:24 <ski> john__ : namely, in case all the arguments successfully match with the patterns, then the first boolean guard expression is evaluated -- if it yields `True', we select the corresponding definiens to compute as result of the call; if it yields `False' then we try the next guard similarly; if there's no more guard on this definition equation, *then* we go to the next one (starting over again with matching with its patterns)
06:32:48 <ski> @src filter
06:32:48 <lambdabot> filter _ []     = []
06:32:48 <lambdabot> filter p (x:xs)
06:32:48 <lambdabot>     | p x       = x : filter p xs
06:32:48 <lambdabot>     | otherwise = filter p xs
06:32:51 <john__> Thanks :)
06:33:02 <ski> is one example where the second equation has two guards
06:33:35 <ski> `otherwise' is just a different spelling of `True' here, so in case `p x' is `False', then surely the next guard will always succeed
06:33:41 <ski> @src take
06:33:41 <lambdabot> take n _      | n <= 0 =  []
06:33:41 <lambdabot> take _ []              =  []
06:33:41 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
06:34:20 <ski> is an example where if the guard expression `n <= 0' evaluates to false, it will discard the first equation, and move on to the next one
06:35:09 <ski> > take 3 [6,28,496,8128]
06:35:10 <lambdabot>   [6,28,496]
06:35:12 <ski> > take 4 [6,28,496,8128]
06:35:13 <lambdabot>   [6,28,496,8128]
06:35:14 <ski> > take 6 [6,28,496,8128]
06:35:15 <lambdabot>   [6,28,496,8128]
06:35:54 <ski> > take 1 [6,28,496,8128]
06:35:55 <lambdabot>   [6]
06:35:57 <ski> > take 0 [6,28,496,8128]
06:35:58 <lambdabot>   []
06:36:01 <ski> > take (-1) [6,28,496,8128]
06:36:02 <lambdabot>   []
06:36:17 <ski> in the last case here, `n <= 0' was `True'
06:37:09 * hackagebot gt-tools 0.1.4.4 - Console and GUI interface for Google Translate service  http://hackage.haskell.org/package/gt-tools-0.1.4.4 (SergeiTrofimovich)
06:37:11 * hackagebot sbv 2.5 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-2.5 (LeventErkok)
06:37:12 <ski> > filter odd [0,1,1,2,3,5,8,13,21,34,55,89,144]
06:37:13 <lambdabot>   [1,1,3,5,13,21,55,89]
06:37:48 <atriq> Implementing a lightweight queue. Is Data.Sequence thing to use?
06:39:54 <Cale> Data.Sequence is the easiest way to get a simple queue which works well, I think
06:40:15 <Cale> (ignoring how it works itself)
06:48:00 <scooty-puff> i may have gone overboard on a permutation monad (https://github.com/sonyandy/perm/blob/master/Control/Monad/Perm/Internal.hs#L56); how important is it that delegation to any underlying monad preserve any distinction between Alternative and MonadPlus of the underlying monad in a monad transformer?
06:51:02 <Cale> scooty-puff: There are no clearly-stated laws for those classes, so it's hard to say what would be good to preserve.
06:52:02 <scooty-puff> k
06:53:40 <Cale> scooty-puff: It would be good to check that (empty,<|>) and (mzero,mplus) make each instance a monoid.
06:53:52 <Cale> scooty-puff: as for interaction with everything else, I don't know.
06:57:47 <Haskellbaby> what
06:58:03 <raynulds> i'm trying to build the haskell platform (2012.2.0.0) from source and I'm getting an error that "happy is required but could not be found" when building alex. I'm bootstrapping from a binary installation of GHC 7.4.1, which means I don't have cabal to install happy. is my best bet to install that package manually? And surely this is a dependency bug in the platform installer, seeing as it includes happy (but presumably tries to build it *after* 
06:58:33 <jix> raynulds: AFAIK cabal does not track dependencies on executables
06:59:04 <Cale> raynulds: usually what I do is to just grab the cabal-install package's tarball from Hackage...
06:59:29 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.14.0/cabal-install-0.14.0.tar.gz -- should be appropriate for 7.4.1
06:59:46 <Cale> Inside that, there's a bootstrap.sh script which you can run
07:00:04 <Cale> and then you can cabal-install things as you need them
07:00:24 <raynulds> Cale: okay, that looks good, thanks. I swear this should be in the documentation for the platform though, i mean all it says you need is GHC...
07:00:55 <Cale> You probably should only need GHC. I don't know why it's giving you problems, but I don't use Platform.
07:01:58 <jix> raynulds: happy is part of the haskell platform, so you should be able to install it from the platform sources without installing cabal-install before
07:02:20 <matthiasgorgens> Does anybody else have problems with the wxc packages (a dependcy of wx)?
07:02:31 <matthiasgorgens> I run ghc 7.6.1.
07:03:17 <quicksilver> the main problem with wxc is having the right version of wx correctly installed first.
07:03:22 <raynulds> jix: i guess, but I figured doing my own builds of stuff inside the HP tree could be a bit dicey. Anyway, bootstrap script is running now and it looks promising
07:03:27 <raynulds> thanks for your help guys...
07:03:34 <quicksilver> I mean, the right version of the non-haskell wx library
07:03:56 <quicksilver> each version of wxc only works with the corresponding version of wxWidgets
07:04:11 <matthiasgorgens> quicksilver: ok, will try that.
07:08:36 <matthiasgorgens> hmm, the haskell package says it wants wxWidgets 2.9.
07:08:54 <matthiasgorgens> There's wxgtk 2.9 in archlinux claiming to be "GTK+ implementation of wxWidgets API for GUI".
07:09:30 <Nereid> that's what you want I think
07:09:36 <matthiasgorgens> ok, I have that installed.
07:09:41 <quicksilver> you need to make sure you get the 'devel' stuff
07:09:45 <quicksilver> not sure how arch handles that
07:09:48 <quicksilver> headers and things.
07:10:19 <matthiasgorgens> yeah, debian (and ubuntu etc) have devel stuff.
07:11:54 <matthiasgorgens> there's even a haskell-wx package in the AUR (inofficial additional repositories).  but that doesn't install.  probably out of date.
07:18:41 <qasi> okay, this is probably a very faqy FAQ, but what would *you* use for making GUIs with Haskell? specifically, Mac OS X, though I'm certainly not against platform-agnostic approaches (as long as they translate well to OS X, which Qt seems to rather not do, due to DETAILS.)
07:18:59 <matthiasgorgens> qasi: I asked the same question yesterday.
07:19:03 <matthiasgorgens> wx seems to be a good choice.
07:19:18 <qasi> nice. so there are good wx bindings for Haskell?
07:19:27 <matthiasgorgens> I am just trying to install some. :o)
07:19:28 <srhb> wxhaskell
07:19:34 <matthiasgorgens> on archlinux.
07:19:41 <srhb> Installing them is somewhat nontrivial, usually.
07:19:42 <matthiasgorgens> (but arch is too bleeding edge.)
07:20:03 <matthiasgorgens> I've got gtk to run just fine really easily.
07:20:06 <qasi> will I be able to compile it into something that works? 8)
07:20:13 <srhb> Sure.
07:20:36 <srhb> The GTK bindings for OS X are not really mature in any way, at least the cocoa ones.
07:20:39 <matthiasgorgens> gtk-toy might be worth a look.
07:20:53 <matthiasgorgens> (at least form the haskell point of view.)
07:21:08 <srhb> Doesn't help much since you can't generate a proper Cocoa interface.
07:21:18 <matthiasgorgens> yeah.
07:21:20 <srhb> Well, you can (allegedly) but it requires you to install the gtk cocoa stuff.
07:21:38 <qasi> I don't really want to go the X11 route.
07:21:44 <srhb> Then GTK is out
07:22:03 <qasi> without proper Cocoa... seems like :(
07:22:40 <srhb> Let me sum it up: GUI bindings for Haskell / OS X don't work with the exception of wx, which is (usually) nontrivial to install. But it depends on the phases of the moon.
07:24:51 <qasi> sigh. would something built with wx at least be somehow redistributable without major headaches (like manually installing libraries... nontrivially)?
07:24:56 <srhb> Yes.
07:25:07 <srhb> If by that you mean distributing the binary
07:25:28 <qasi> that's good at least. I think I can handle nontrivial installation if I only have to do it in order to develop.
07:25:33 <qasi> srhb, I do
07:25:53 <srhb> Right. Then it should definitely be doable. Fsvo doable, which involves versions, bitness etc. :P
07:26:00 * srhb wonders if bitness has been coined.
07:26:14 <akamaus> does anyone have an experience of using conduits for html parsing?
07:26:15 <Sculptor> hi!
07:26:19 <srhb> Sculptor: Hi
07:28:38 <nimor> why is toUpper '\181' == '\924' and toLower '\924' == '\956' ?
07:29:35 <jerojasro> unicode is not a function? :P
07:29:42 <srhb> Right. :P
07:29:54 <maukd> nimor: what else would it be?
07:30:19 <srhb> Well, it's certainly not a bijection.
07:30:23 <nimor> well. it says Convert a letter to the corresponding lower-case letter, if any. Any other character is returned unchanged.
07:30:33 <nimor> on the function. so thought it would return unchanged :-P
07:30:53 <sopvop> By the spec: http://www.fileformat.info/info/unicode/char/b5/index.htm http://www.fileformat.info/info/unicode/char/039c/index.htm
07:31:27 <jerojasro> sorry, what I meant is: unicode lowercase has no inverse function
07:32:36 <sopvop> is this right sentences: "toUpper and toLower do not form an isomorphism"? :) want to sound smarty
07:32:43 <ski> @check liftM2 (==) id (toLower . toUpper)
07:32:45 <lambdabot>   "Falsifiable, after 129 tests:\n'\\1332'\n"
07:32:48 <ski> @check liftM2 (==) id (toUpper . toLower)
07:32:50 <lambdabot>   "OK, passed 500 tests."
07:33:22 <ski> sopvop : more or less. yes. or you could say they're not inverses
07:33:38 <maukd> > filter (\x -> x /= toLower (toUpper x)) [minBound ..]
07:33:39 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ\181\192\193\194\195\196\197\198\199\200\201\202...
07:33:42 <ski> `f' and `g' forming an isomorphism situation means `f . g = id' and `g . f = id'
07:33:52 <Nereid> but do we at least have toLower . toUpper . toLower = toLower and the other similar thing?
07:33:59 <maukd> > filter (\x -> isLower x && x /= toLower (toUpper x)) [minBound ..]
07:34:00 <lambdabot>   "\181\305\383\962\976\977\981\982\1008\1009\1013\7835\8126"
07:34:29 <srhb> Nope!
07:35:12 <Nereid> yeah, we don't
07:39:03 <nand`> @hoogle (a -> Maybe a) -> a -> a
07:39:05 <lambdabot> Data.IntMap update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
07:39:05 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
07:39:05 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
07:39:45 <nand`> is there an elegant way to write this function? the semantics being ‘apply the function as often as it returns Just; stopping when it returns Nothing)
07:39:55 <ski> @type ap fromMaybe
07:39:56 <lambdabot> forall b. (b -> Maybe b) -> b -> b
07:40:08 <ski> oh, iteration
07:40:23 <nand`> right now I'm at ‘reduce f a = maybe a (reduce f) (f a)’
07:40:51 <jerojasro> nand`: takeWhile ?
07:41:22 <Nereid> well, at least we have the next best thing: toLower . toUpper and toUpper . toLower are idempotent
07:41:47 <nand`> jerojasro: you mean something like  last . takeWhile isJust . iterate (>>= f) ?
07:41:55 <nand`> . Just
07:42:35 <ski> @type last .: unfoldr . (fmap (join (&&&) id) .)
07:42:36 <lambdabot> forall a. (a -> Maybe a) -> a -> a
07:42:42 <nand`> if so, that's probably not an improvement, plus it adds ugly functions like isJust, last and fromJust
07:42:49 * ski nods
07:42:56 <nand`> I'll go with what I have
07:43:27 <ski> @djinn (a -> Maybe a) -> a -> a
07:43:27 <lambdabot> f a b =
07:43:27 <lambdabot>     case a b of
07:43:27 <lambdabot>     Nothing -> b
07:43:27 <lambdabot>     Just c -> c
07:43:36 <sopvop> does not forever do that?
07:44:23 <Cale> Trust djinn to find the non-recursive solution ;)
07:44:37 <Nereid> @pl reduce f a = maybe a (reduce f) (f a)
07:44:37 <lambdabot> reduce = fix (ap . flip maybe =<<)
07:46:33 <Nereid> @type (>>= ap . flip maybe)
07:46:34 <lambdabot> forall b a. ((b -> Maybe a) -> a -> b) -> (b -> Maybe a) -> b -> b
07:46:45 <b__> is there any use in specialising Integral functions for Int and Integer?
07:46:56 <Nereid> @type ap . flip maybe
07:46:57 <lambdabot> forall b a. (a -> b) -> (b -> Maybe a) -> b -> b
07:48:26 <ski> @type either id (error "fromLeft : can't happen") .: fix . (>=>) . liftM2 (`maybe` Right) Left
07:48:27 <lambdabot> forall a. (a -> Maybe a) -> a -> a
07:48:45 <ski> `fix . (>=>)' isn't quite `forever'
07:51:37 <ski> @type ap (`maybe` id)
07:51:38 <lambdabot> forall a. (a -> Maybe a) -> a -> a
07:54:27 <haskellnoob> hello?
07:54:34 <arcatan> hello!
07:54:54 <maukd> is this the krusty krab?
07:55:21 <haskellnoob> what do i have to type if i want to compare 3 numbers?
07:55:33 <ski> compare how ?
07:55:34 <maukd> code that compares 3 numbers
07:55:50 <haskellnoob> they must be the same
07:55:53 <srhb> > 1 == 1 == 1
07:55:54 <lambdabot>   Precedence parsing error
07:55:54 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
07:56:05 <srhb> > (1==1)==1
07:56:06 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
07:56:06 <lambdabot>    arising from the literal `1'...
07:56:12 * srhb is drunk
07:56:29 <srhb> Consider this the example of what you did wrong while I go wash my brain in bleach.
07:57:20 <arcatan> > let a = 1; b = 1; c = 1 in a == b && b == c
07:57:22 <lambdabot>   True
07:57:31 <sclv_> @remember spj "You do the category theory, and you talk to Gordon. And he talks to Phil. And Phil talks to me."
07:57:31 <lambdabot> Done.
07:57:32 <srhb> > let compare a b c = all (==a) [b,c] in compare 1 1 1
07:57:34 <lambdabot>   True
07:57:47 <arcatan> sclv_: who does the category theory?
07:57:49 <ski> > (and . (zipWith (==) `ap` tail)) [0,0,0]
07:57:50 <lambdabot>   True
07:58:05 <Cale> @quote zip`ap`tail
07:58:06 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
07:58:08 <haskellnoob> ok thanks :)
07:58:41 <haskellnoob> this chat is gonna help me in my studies i think
07:58:53 <Cale> haskellnoob: Here's the more noob-friendly version of ski's code:
07:58:55 <srhb> arcatan: spj does not know, therefore we do not know.
07:59:00 <srhb> :P
07:59:14 <Cale> > let allEqual xs = and (zipWith (==) xs (tail xs)) in allEqual [0,0,0,0]
07:59:15 <lambdabot>   True
07:59:18 <sclv_> arcatan: lawvere :-P
07:59:19 <Cale> > let allEqual xs = and (zipWith (==) xs (tail xs)) in allEqual [0,0,1,0]
07:59:21 <lambdabot>   False
07:59:59 <srhb> > let allEq (x:xs) = all (==x) xs in allEq [1,1,1]
08:00:00 <lambdabot>   True
08:00:03 <srhb> Seems more noob friendly
08:00:06 <srhb> With appropriate corner cases.
08:00:12 <Nereid> how lucky are we that zip `ap` tail doesn't error on []?
08:00:19 <Cale> > let allEqual xs = and (zipWith (==) xs (tail xs)) in allEqual []
08:00:20 <lambdabot>   True
08:03:46 <clahey> > let allEqual xs = and (zipWith (==) (tail xs) xs) in allEqual []
08:03:48 <lambdabot>   *Exception: Prelude.tail: empty list
08:04:12 <clahey> Is that ordering constraint part of the definition of the language?
08:04:17 <maukd> :t null . drop 1 . nub
08:04:18 <lambdabot> forall a. (Eq a) => [a] -> Bool
08:04:32 <haskellnoob> what does fst do?
08:04:37 <Nereid> :t fst
08:04:38 <srhb> > fst (1,2)
08:04:38 <lambdabot> forall a b. (a, b) -> a
08:04:39 <lambdabot>   1
08:04:40 <maukd> @src fst
08:04:40 <lambdabot> fst (x,_) =  x
08:04:51 <srhb> @src snd
08:04:51 <lambdabot> snd (_,y) =  y
08:04:54 <srhb> whee!
08:05:05 <maukd> > null . drop 1 . nub $ [1, 1, 1, 1]
08:05:05 <Nereid> :t fst (&&&) snd
08:05:06 <lambdabot>     Couldn't match expected type `(a, b)'
08:05:07 <lambdabot>            against inferred type `a1 b1 c -> a1 b1 c' -> a1 b1 (c, c')'
08:05:07 <lambdabot>     In the first argument of `fst', namely `(&&&)'
08:05:07 <lambdabot>   True
08:05:08 <fmap> sclv_: are you the right person to ask about hstringtemplate?
08:05:12 <Nereid> :t fst (*) snd
08:05:13 <lambdabot>     Couldn't match expected type `(a, b)'
08:05:13 <lambdabot>            against inferred type `a1 -> a1 -> a1'
08:05:14 <lambdabot>     In the first argument of `fst', namely `(*)'
08:05:14 <Nereid> :t fst (***) snd
08:05:15 <lambdabot>     Couldn't match expected type `(a, b)'
08:05:15 <lambdabot>            against inferred type `a1 b1 c -> a1 b' c' -> a1 (b1, b') (c, c')'
08:05:16 <Nereid> oh I'm dumb.
08:05:16 <lambdabot>     In the first argument of `fst', namely `(***)'
08:05:18 <Nereid> :t fst &&& snd
08:05:19 <lambdabot> forall c b. (c, b) -> (c, b)
08:05:34 <ski>   -| reify fn a => fn b => fn c => allEqual [a,b,c];
08:05:40 <ski>   val it = <(fn a => (fn b => (fn c => if a %= b then if b %= c then true else false else false)))> : <'1  -> '1  -> '1  -> bool>
08:05:53 <int-e> :t fst * snd
08:05:55 <lambdabot> forall b. (Num b) => (b, b) -> b
08:06:03 <Nereid> lol
08:06:11 <Nereid> :t uncurry (*)
08:06:11 <int-e> Nereid: Cale strikes again
08:06:12 <lambdabot> forall a. (Num a) => (a, a) -> a
08:06:38 <ski> > (sum / genericLength) [1,2,3,4,5,6]
08:06:39 <lambdabot>   3.5
08:06:41 <clahey> What's &&&, something to do with arrows?
08:06:46 <clahey> :t (&&&)
08:06:47 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
08:06:51 <clahey> Duh, I can ask the bot.  :)
08:06:59 <Nereid> :t fst &&& snd
08:07:00 <lambdabot> forall c b. (c, b) -> (c, b)
08:07:10 <Nereid> uh I just did that.
08:07:18 <Nereid> :t fst *** snd
08:07:19 <lambdabot> forall c b a b1. ((c, b), (a, b1)) -> (c, b1)
08:07:26 <Nereid> silly.
08:07:27 <srhb> How useful.
08:07:36 <ski>   (f *** g) x = (f x,g x)  -- in the function case
08:07:47 <clahey> @quickcheck (fst &&& snd) x == x
08:07:47 <lambdabot> Unknown command, try @list
08:07:50 <Nereid> that's &&&
08:07:51 <Nereid> ski
08:07:57 <ski> er, yes
08:08:00 <Nereid> (f *** g) (x,y) =(f x, g y)
08:08:06 <ski> @src (->) (***)
08:08:06 <lambdabot> (f *** g) ~(x,y) = (f x, g y)
08:08:09 <Nereid> :t id &&& id
08:08:10 <lambdabot> forall b. b -> (b, b)
08:08:21 <ski> @type snd &&& fst
08:08:22 <lambdabot> forall a c. (a, c) -> (c, a)
08:08:32 <ski> @type Right ||| Left
08:08:33 <lambdabot> forall b a. Either b a -> Either a b
08:08:38 <Nereid> :t (|||)
08:08:40 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
08:09:02 <Nereid> ah, generalizing either
08:09:14 <clahey> I suppose, other than undefineds, there's only one function of type forall c b. (c, b) -> (c, b)
08:09:17 <ski> @type (fst . fst) &&& ((snd . fst) &&& snd)
08:09:18 <Nereid> :t id ||| id
08:09:18 <lambdabot> forall a b b1. ((a, b), b1) -> (a, (b, b1))
08:09:19 <lambdabot> forall c. Either c c -> c
08:10:01 <ski> @type (fst *** fst) &&& (snd *** snd)
08:10:02 <lambdabot> forall c b a b1. ((c, b), (a, b1)) -> ((c, a), (b, b1))
08:10:20 <clahey> ski: transpose.
08:10:43 <clahey> What's the standard way to represent matricies in haskell?
08:11:28 <Nereid> I don't know if there is a "the" standard.
08:12:38 <clahey> Is there a library with processor level optimizations?
08:14:11 <matthiasgorgens> !type swap
08:14:16 <matthiasgorgens> :t swap
08:14:16 <ClaudiusMaximus> clahey: hmatrix uses foreign libraries that are processor-specific, afaik
08:14:18 <lambdabot> Not in scope: `swap'
08:14:24 <matthiasgorgens> :t Data.Tuple.swap
08:14:25 <lambdabot> Not in scope: `Data.Tuple.swap'
08:14:38 <Nereid> @hoogle (a,b) -> (b,a)
08:14:38 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
08:14:39 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
08:14:39 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
08:19:59 <spaceships> Dear Haskell Committee, Thank you for making Haskell! I like to use it! everyday! Sincerely, Spaceships
08:24:31 <ski> @type (Left *** Left) ||| (Right *** Right)
08:24:32 <ski> @type (fst +++ fst) &&& (snd +++ snd)
08:24:32 <lambdabot> forall b b1 b' b2. Either (b, b') (b1, b2) -> (Either b b1, Either b' b2)
08:24:33 <lambdabot> forall c b a b1. Either (c, b) (a, b1) -> (Either c a, Either b b1)
08:25:50 <haskellnoob> :t ==
08:25:52 <lambdabot> parse error on input `=='
08:26:02 <ski> @type (==)
08:26:03 <lambdabot> forall a. (Eq a) => a -> a -> Bool
08:26:22 <haskellnoob> :t (==)
08:26:24 <lambdabot> forall a. (Eq a) => a -> a -> Bool
08:26:40 <haskellnoob> :t (Bool)
08:26:42 <lambdabot> Not in scope: data constructor `Bool'
08:26:57 <haskellnoob> :t bool
08:26:59 <lambdabot> Not in scope: `bool'
08:27:03 <haskellnoob> :t Bool
08:27:04 <lambdabot> Not in scope: data constructor `Bool'
08:27:06 <qasi> :t True
08:27:07 <lambdabot> Bool
08:27:09 <Polarina> mm_freak, I see. As far as I can see *my* uses for a manager wire, it would be only for pure wires (I'm not using monads. Well, I am, but mostly only for easy debugging/sight-seeing), as I want some variable amount of wires to evolve individually, What possible use cases do you have in mind?
08:27:31 <ski> @kind Bool
08:27:32 <lambdabot> *
08:27:35 <ski> @src Bool
08:27:36 <lambdabot> data Bool = False | True deriving (Eq, Ord)
08:27:45 <haskellnoob> whats a bool?
08:27:52 <ski> a truth-value
08:27:57 <haskellnoob> ok
08:28:08 <ski> @type isDigit
08:28:09 <lambdabot> Char -> Bool
08:28:14 <ski> > isDigit '7'
08:28:15 <lambdabot>   True
08:28:17 <ski> > isDigit 'A'
08:28:17 <lambdabot>   False
08:28:56 <mm_freak> Polarina: i'm thinking not only of user interfaces and such, but also about network services, where the manager wire could manage a set of clients or objects within a client
08:29:02 <ski> > map isDigit "TI-99a"
08:29:03 <lambdabot>   [False,False,False,True,True,False]
08:29:57 <Polarina> mm_freak, that's the idea I had as well.
08:30:05 <haskellnoob> reverse map isDigit "TI-99a"
08:30:11 <mroman> How can I persuade ghc/haskell to print numbers without e Notation?
08:30:18 <Polarina> mm_freak, e.g. client connects, new wire to manage.
08:30:34 <tac> mroman: use a different data type
08:30:47 <ski> > reverse (map isDigit "TI-99a")
08:30:48 <lambdabot>   [False,True,True,False,False,False]
08:31:04 <haskellnoob> ahh
08:31:04 <ski> > map (graph isDigit) "TI-99a"
08:31:06 <mroman> tac: Like?
08:31:06 <lambdabot>   [('T',False),('I',False),('-',False),('9',True),('9',True),('a',False)]
08:31:17 <haskellnoob> the brackets ;)
08:31:27 <ski> > filter isDigit "TI-99a"
08:31:28 <lambdabot>   "99"
08:31:36 <tac> mroman: Int, Integer
08:31:44 <Polarina> mm_freak, actually, that's pretty much what I wolud use it for..
08:31:53 <tac> If you need floating points, I don't believe there's a way
08:31:58 <n-dolio> > showFFixed Nothing 10000000000000000 ""
08:31:59 <lambdabot>   Not in scope: `showFFixed'
08:32:03 <mroman> I need floating point
08:32:05 <n-dolio> > showFFloat Nothing 10000000000000000 ""
08:32:06 <tac> there's already a show instance for Float
08:32:06 <lambdabot>   "10000000000000000.0"
08:32:26 <mroman> @type showFFloat
08:32:27 <parcs`> > showFFloat Nothing 123123.3453475923 ""
08:32:30 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
08:32:34 <lambdabot>   "123123.3453475923"
08:32:38 <b__> is there any use in specialising Integral functions for Int and Integer?
08:32:44 <tac> hmm
08:32:55 <ski>   showFFloat :: RealFloat a => Maybe Int -> a -> ShowS  -- iow
08:33:01 <mroman> > showFFloat Nothing (0.00008 :: Double)
08:33:02 <lambdabot>   Overlapping instances for GHC.Show.Show
08:33:02 <lambdabot>                              (GHC.B...
08:33:16 <ski> > showFFloat Nothing (0.00008 :: Double) ""
08:33:17 <lambdabot>   "0.00008"
08:33:17 <mroman> @hoogle showFFLoat
08:33:18 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
08:33:44 <haskellnoob> if i type "filter isDigit "TI-99a"" in winHugs it doesnt work. anyone know why?
08:33:46 <ski> > 10000000000000000 :: Double
08:33:47 <lambdabot>   1.0e16
08:33:53 <mroman> in which package is that?
08:34:08 <ski> haskellnoob : maybe try `:also Data.Char' first ?
08:34:20 <n-dolio> showFFloat is in the Numeric module, I think.
08:34:26 <n-dolio> @hoogle showFFloat
08:34:26 <lambdabot> Numeric showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
08:34:34 <mroman> ah
08:34:38 <mroman> I tried Data.Numeric :)
08:34:55 <ski> @index lex
08:34:55 <lambdabot> Text.Read, Prelude, Text.Read.Lex
08:35:23 <Polarina> mm_freak, so, the idea was: manager :: (Monoid e', Monad m, Monoid b) => Wire e m ([Wire e' m a b], a) (e', b)  --  Don't misunderstand that I want you to use that signature or anything, just an idea to work on. :)  So, I'm trying to understand what needs or uses for a manager wire, that signature cannot satisfy.
08:35:35 <ski> haskellnoob : any luck ?
08:35:41 <Polarina> mm_freak, maybe this is not what you had in mind for a manager wire... :/
08:37:09 * Polarina hopes that this makes sense...
08:38:02 <mroman> Ok. Thx.
08:38:05 <mroman> That works.
08:38:44 <b__> is it considered good style to always put spaces around operators?
08:39:10 <ski> haskellnoob : `isDigit' is defined in the module `Data.Char', which isn't imported per default in the interactor (WinHugs) -- using `:also Data.Char' will cause it to also load that module (and bring the things exported by it in scope in the interactor, so that you can refer to it)
08:39:34 <ski> b__ : i usually do that
08:39:57 <b__> I see a lot of people making exceptions for n-1 etc
08:40:12 <ski> in patterns, i usually don't put spaces around the `:' operator, and sometimes not in expressions as well
08:40:37 <ski> if there's lots of arithmetic operations, i often don't put spaces around the "innermost" ones
08:40:46 <b__> yeah to group them?
08:40:52 <b__> visually
08:41:03 <ski> yes, to visually make the grouping stand out more
08:41:19 <haskellnoob> ok thanks :) do i have to load it when im using hugs in linux?
08:41:32 <ski> haskellnoob : yes
08:41:39 <b__> I do that too but I find the typographical possibilities very limited
08:42:11 <ski> i often align things over multiple lines, which sometimes causes more space around operators
08:43:42 <PcManiac92> hay
08:43:45 <haskellnoob> hay
08:44:33 <ski> b__ : and for `n-1' and `n+1' things which are just used to count down up some counter (and thus isn't so algorithmically interesting) i suppose i more often don't places spaces around the operator
08:44:43 <ski> hello PcManiac92
08:45:28 <b__> yeah but there are edge-cases where x > 1 in n+x
08:46:22 <PcManiac92> :)
08:46:58 <clahey> :t 2><3
08:47:00 <lambdabot> forall a. (Num (Gen a)) => Gen a -> Gen a
08:47:26 <ski> @type (><)
08:47:27 <lambdabot> forall a. (Gen a -> Gen a) -> (Gen a -> Gen a) -> Gen a -> Gen a
08:48:11 <PcManiac92> began my computer science studies last week
08:48:17 <PcManiac92> very interesting
08:48:46 <ziman> sometimes I have a pure program (with no reason to taint it with IO) that does quite a lot of computation, which takes time. I'd like to periodically print progress information about the computation; what's the standard approach? Break the algorithm into pure steps and perform the outermost loop in IO?
08:48:54 <ski> PcManiac92 : are you (going to) study Haskell ? :)
08:49:27 <PcManiac92> i have a haskell course
08:49:35 <scp> I too am interested in the answer to ziman's question
08:49:42 <scp> PcManiac92: awesome.. we got C++ x_X
08:49:45 <tac> ziman: You use a writer monad
08:50:21 <mroman> @hoogle fromBase
08:50:21 <lambdabot> No results found
08:50:22 <PcManiac92> c++ is in our third semester
08:50:25 <mroman> @hoogle toBase
08:50:26 <lambdabot> No results found
08:50:28 <tac> The writer monad allows you to do "log" statements. The resulting computation gives you the actual return value and a list of log messages.
08:50:32 <mroman> @hayoo fromBase
08:50:32 <lambdabot> Unknown command, try @list
08:50:42 <tac> You can consume the log messages even before the final result is finished.
08:50:46 <tac> and print them to the screen
08:50:58 <Cale> Or just, you know, use a list :)
08:51:12 <scp> tac, is that sort of thing hard to add on "after the fact"?
08:51:39 <ski> @type showIntAtBase
08:51:39 <Cale> scp: It implies putting an ordering on computation of subexpressions which wasn't in your original code
08:51:40 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
08:51:41 <ski> @type readInt
08:51:43 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
08:51:51 <ClaudiusMaximus> i basically did something like a -> b  becoming a -> [Progress b]  data Progress b = StillNotDone String | Done b  and it was still awkward with threads/gtk/forcing
08:52:00 <brunonery> hello! I'm a complete haskell noob but I thought I'd start using it to replace Python on my small throw away programs. question is: how do I process stdin line by line in haskell until EOF?
08:52:06 <Cale> scp: So you have to add information to the algorithm when you do it, making it "nontrivial", but it's usually easy enough.
08:52:06 <tac> scp: You have to re-implement parts of your algorithm, but it's still pure
08:52:18 <ski> mroman : maybe you were looking for something different ?
08:52:25 <ziman> tac, Cale, thanks
08:53:13 <scp> Basically I'd like to use this sort of thing for debugging. Is there another approach which will let me print out progress and then remove it later to get my pretty pure code back?
08:53:23 <mroman> I'm looking for converting numbers between common bases
08:53:24 <ClaudiusMaximus> Debug.Trace
08:53:25 <ziman> scp, there's Debug.Trace
08:53:35 <mroman> which is 2-26
08:53:35 <scp> ok, will look into that. Thanks folks
08:53:39 <mroman> In that range.
08:53:45 <Cale> brunonery: main = do xs <- getContents; let {ys = lines xs}; ... do stuff with ys ...
08:53:51 <ski> brunonery : `main = interact (unlines . foo . lines)' is one simple way
08:53:54 <ClaudiusMaximus> which apparently also has ghc event log support, not just stderr logging
08:53:54 <clahey> In order to build a complex Storable, I just implement sizeof, alignment, peek, and poke, and to implement them, I use castPtr to access the underlying types?
08:54:17 <brunonery> that's nice, Cale and ski! Thanks!
08:54:37 <ski> (itym s/26/36/)
08:54:50 <scp> nice! Debug.Trace is fancy
08:54:59 <scp> so, now for a tougher (I think) question
08:55:25 <ClaudiusMaximus> clahey: there's hsc2hs that helps you be more portable if you have C header with structs, and bindings-DSL helps for larger library bindings
08:55:46 <scp> I'm using the maybe monad to short-circuit a simple parser. Is there a convenient way to use trace or traceShow in a do block?
08:56:13 <ClaudiusMaximus> @hoogle traceShow
08:56:13 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
08:56:25 <ClaudiusMaximus> just let your b be :: m y
08:56:34 <scp> hmm, I think I sort of answered my own question
08:56:38 <scp> ClaudiusMaximus: ya, thanks
08:57:02 <ziman> this is one of the problems where I have to impose an arbitrary "order" on my code; another one is generating unique identifiers: all I need is the uniqueness but it seems that the only way I can achieve it is through an arbitrary "order" in which they are generated (i.e. newtype Ident = Ident Int), which requires ordering of code (a monad) of some sort
08:57:04 <scp> sweeeet, figuring out what's going on in my monads just got way easier
08:57:20 <ClaudiusMaximus> i saw some define debug = flip traceShow  and then use it infix after the actions for less noise
08:57:24 <killy9999> I need advice
08:57:48 <killy9999> I am benchmarking different implementations of one algorithm
08:58:00 <killy9999> one is based on lists, another on Vector and so on
08:58:03 <killy9999> the question is
08:58:12 <killy9999> does it make sense to define a typeclass for that?
08:58:20 * Gx4 Have a nice weekend all! :)
08:59:36 <hpaste> fmap pasted “Any nasty hack to compile c or d?” at http://hpaste.org/76490
09:00:22 <clahey> ClaudiusMaximus: I was more thinking of making a Storable for use in libraries that require one.
09:00:30 <ClaudiusMaximus> killy9999: at the end you'll still need  to write   bench foo (input :: [Int]), bench foo (input :: Vector Int) ...  etc
09:00:37 <clahey> ClaudiusMaximus: sizeof has to be independent of the passed in value, right?
09:00:41 <ClaudiusMaximus> yes
09:00:41 <clahey> If so, why does it take a value?
09:00:48 <Cale> fmap: What are the types of c and d?
09:00:58 <clahey> Why not just have sizeOf be a polymorphic value?
09:01:02 <fmap> Cale: T ()
09:01:04 <ClaudiusMaximus> because it needs to know the type, you can have   sizeOf :: Int
09:01:08 <ClaudiusMaximus> *can't
09:01:09 <ClaudiusMaximus> oops
09:01:16 <Cale> fmap: How do I tell that from this code?
09:01:20 <Cale> oh _f
09:01:29 <killy9999> CaludiusMaximus: I was thinking that final version will be used as qualified import
09:01:44 <killy9999> A.foo, B.foo and so on
09:01:59 <Cale> fmap: Oh, right, no, I can't tell the type of the original def
09:02:13 <b_jonas> fmap: what the heck do those percent signs do?
09:02:21 <clahey> ClaudiusMaximus: So, you write sizeOf (undefined :: TypeName)
09:02:23 <clahey> ?
09:02:36 <ski> @type \a ts t -> t {rootLabel = a,subForest = ts}
09:02:37 <lambdabot> forall a t. a -> Forest a -> Tree t -> Tree a
09:02:38 <b_jonas> they're not the (%) function that makes rationals, right?
09:02:38 <Cale> fmap: and I need to know that type in order to know which instance of Default to use
09:02:51 <scp> :t %
09:02:53 <lambdabot> parse error on input `%'
09:02:59 <scp> :t (%)
09:03:01 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
09:03:05 <ski> fmap : i think it's ambiguity
09:03:13 <b_jonas> yep, but that thing in fmap's paste doesn't look like that
09:03:14 <ClaudiusMaximus> clahey: yep, it would have been better with sizeOf :: Proxy a -> Int  instead of :: a -> Int  and   data Proxy a = Proxy  so you could use Proxy instead of undefined
09:03:29 <LordBrain> is the Default class part of the standard libs? I have re-invented that
09:03:44 <fmap> Cale: yeah, and the fact I'm not actually using Default instance for `a' doesn't help me i guess? :(
09:03:53 <scp> :t (%)
09:03:54 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
09:04:05 <ski> fmap : the syntax in `c' and `d' transforms from `T a' to `T ()', for some `a' -- but by the use of `def', `a' must be in `Default'
09:04:07 <ClaudiusMaximus> scp: looks like it's a lens thing
09:04:17 <ski> fmap : but it doesn't know which instance to use
09:04:24 <scp> ya, sorry, I didn't mean to do it twice =P
09:04:56 <b_jonas> ski: wait what? the brace syntax can tranform between different types
09:05:15 <ski> yes
09:05:33 <b_jonas> I see
09:06:31 <ClaudiusMaximus> > (\s -> s{ getSum = (fromIntegral :: Int -> Double) (getSum s) }) (Sum 1)
09:06:32 <Cale> fmap: Well, it might help to think of it like this, the  instance Default a => Default (T a)  is internally represented as a function  DefaultInst a -> DefaultInst (T a)
09:06:33 <lambdabot>   Sum {getSum = 1.0}
09:06:33 <ski> i assume it desugars to something like `\a ts t -> case t of Node old_a old_ts -> Node a ts'
09:06:44 <b_jonas> makes sense
09:06:47 <b_jonas> ok
09:06:57 <Cale> fmap: In order to obtain a value of type DefaultInst (T a), the compiler needs to apply that function to a value of type DefaultInst a
09:07:13 <Cale> fmap: and it doesn't know which to choose
09:07:21 <ski> > undefined {rootLabel = (),subForest = []} `seq` ()
09:07:22 <lambdabot>   *Exception: Prelude.undefined
09:07:29 <ski> ok, so `case' and not `let'
09:07:36 <Cale> (and isn't smart enough to prove that it doesn't matter, because that relies on the details of the implementation)
09:08:05 <Cale> fmap: You can get around this by adding an explicit type annotation to your use of def
09:08:12 <Cale> as you noticed
09:09:00 <b_jonas> so would using def' worked even if you wanted a type different from T () ?
09:09:20 <b_jonas> like, c = def' { _f = 15 };
09:09:29 <Cale> yeah, it would
09:09:41 <b_jonas> then you could just use that for no matter what type
09:10:35 <Cale> b_jonas: However, if his goal is to be able to use some other piece of machinery that uses this Default class, that might not be an option.
09:11:44 <fmap> Cale: yeah, I see what's the problem. What's unfortunate is that typechecker isn't smart enough :[
09:12:16 <fmap> anyway, thanks
09:12:34 <Cale> fmap: Well, it's actually really subtle here
09:14:01 <Cale> It would have to be able to see that no matter which type a it chose, that the only difference would occur in a field which was not used by the remainder of the program.
09:14:46 <Cale> In this specific case, it's not hard for us to see that the field is immediately ignored and replaced with something else.
09:14:57 <Cale> But in general, this is arbitrarily hard.
09:21:41 <atriq> If I wanted to make a 128x96 pixel display, how would I do it?
09:24:59 <Cale> atriq: What graphics library are you using?
09:25:08 <atriq> Haven't decided yet
09:25:12 <atriq> Whichever, basically
09:25:24 <Cale> What kind of graphics are you drawing in that display?
09:27:07 <atriq> I'm making an emulator for the DCPU from 0x10^c, so... 32x12 16 bit cells with a 16-colour palette, each cell is monochrome
09:27:58 <Cale> In that case, you'll want something which can push an array of pixels to the screen nicely...
09:29:27 <atriq> Any suggestions?
09:30:07 <b__> how doI remove a package with cabal?
09:31:03 <Swampert> is "if - then - else" actually a kind of Monad?
09:31:21 <atriq> I'd say no
09:31:26 <int-e> b__: it's not supported - use ghc-pkg unregister (and optionally remove the files manually)
09:31:32 <atriq> It's a bit like Reader Bool, though, Swampert
09:31:39 <b__> alright int-e, thanks
09:31:49 <Cale> atriq: I wonder if gloss-raster would be good for you
09:32:07 <atriq> Cale: I'll give it a look, thanks
09:32:10 <Swampert> thanks
09:32:28 <fmap> Swampert: no, kind of Monad is (* -> *) -> Constraint
09:33:16 <int-e> b__: (I suppose the deeper reason for this is that cabal-install does not track installed files at all, so 'unregister' is all it would do anyway. But then people would complain that the files are not deleted.)
09:33:36 <b__> right
09:33:39 <b__> I don't mind :}
09:39:53 <atriq> Doesn't have an equivalent to Gloss's impure versions
09:40:55 <Swampert> ok, I don't know what that means yet, only reason I said "kind" is because "type" already means something... of course this is the CT language so every abstract term is well defined already
09:41:35 <MostAwesomeDude> Swampert: Kinds are to types as types are to values, roughly.
09:46:00 <scp> Swampert: I believe that fmap was being obtuse. Your sentence made it clear that you were talking about a variety of monad, not the haskell "kind" of Monad
09:46:22 <haskellnoob> is there anyone who speaks german? :)
09:46:40 <PcManiac92> ja hier
09:46:45 <atriq> haskellnoob, no. Literally no-one in the entire world speaks German.
09:47:06 <scp> that is a funny little sequence of comments :)
09:47:08 <PcManiac92> :D
09:47:08 <haskellnoob> is there anyone "here" who speaks german? :)
09:47:39 <maukd> NEIN
09:51:13 <parcs`> que?
09:54:31 <wereHamster> let's suppose I want to download a file from a HTTP server and save it on the local disk. Is there an easy to use library which can do that with minimal setup?
09:55:02 <atriq> Cale, I'm afraid gloss-raster isn't quite what I want
09:55:54 <atriq> Ideally, there'd be makeABox :: (Int, Int) -> IO Window and fillBox :: Window -> SomeImage -> IO ()
09:56:05 <atriq> And maybe killBox :: Window -> IO ()
09:58:12 <parcs`> wereHamster: conduit and http-conduit
09:59:34 <ski> haskellnoob : you could try #haskell.de
10:00:45 <k00mi> haskellnoob: i do
10:01:31 <wereHamster> parcs`: thanks. Seems ok. although, it appears to try to win the 'longest function with only symbols' contest (Data.Conduit.$$+-)
10:02:38 <Cale> wereHamster: I'd just like to say that I would never use conduit just for that
10:03:02 <wereHamster> Cale: hm. do you have any suggestions for a http client library?
10:03:22 <Cale> If all you want to do is download something, see download or download-curl
10:03:53 <Cale> If you want fancier HTTP requests, there's a library called HTTP.
10:04:24 <Cale> download provides:
10:04:32 <Cale> openURI :: String -> IO (Either String ByteString)
10:04:32 <Cale> Download content specified by url (in RFC1738 form), using either FTP, HTTP or file protocols, returning the content as a strict ByteString.
10:04:59 <Cale> There's also openURIString, if you're more inclined to want a simple String
10:05:10 <Cale> http://hackage.haskell.org/packages/archive/download/0.3.2/doc/html/Network-Download.html
10:06:43 <wereHamster> yeah, openURI is just what I need. Maybe I steal >>= sinkFile from conduit and that's it.
10:07:04 <Cale> Just use Data.ByteString.writeFile
10:07:11 <wereHamster> ah, splendid
10:08:19 <dzhus> that feel when you can't ping darcs.haskell.org.
10:09:30 <Cale> I'm somewhat opposed to using conduit for simple tasks, because it's a mass of fancy machinery which isn't perfectly abstracted away, meaning that you might actually have to understand something about how it works at some point, and then you're going to have a really fun time.
10:10:51 <Cale> It's a very effective piece of machinery in general though, for producing things that run fast and do complex stream processing.
10:12:36 <Cale> (I'm not sure it's the *right* one though. There are a bunch of competing libraries on this front, and they all involve some things with somewhat crazy types which are exposed to their users.
10:15:23 <Cale> There's another one called 'pipes' which might be the best we can do for now, but I think there perhaps is something better still.)
10:15:32 <b__> is there any use in specialising Integral functions for Int and Integer?
10:15:47 <Cale> b__: Performance wise, sometimes
10:15:50 <ocharles> edwardk: thanks for the talk yesterday! I meant to ask one question though - do you see lenses to replace general record access?
10:16:07 <b__> Cale, is it possible to SPECIALIZE for both?
10:16:15 <Cale> b__: yeah
10:16:16 <edwardk> they replace 99% of the uses. with mgsloan's lenq dsl they kill the last couple ;)
10:16:27 <Cale> b__: Though SPECIALIZE isn't recursive
10:16:32 <Cale> (as far as I recall)
10:16:53 <edwardk> (we're working on integrating a variant on that into the library still)
10:16:54 <ocharles> edwardk: so if i was a library author, it might be a good idea for me to export lenses, rather than normal record accessor functions?
10:16:55 <Cale> b__: so you often have to track down all the dependencies and use SPECIALISE on those as well.
10:17:02 <ocharles> edwardk: can i see that dsl anywhere?
10:17:04 <b__> ah okay
10:17:10 <edwardk> ocharles: either instead of or in addition to
10:17:17 * ocharles nods
10:17:20 <edwardk> ocharles: github, he has a fork of lens that has it
10:17:26 <ocharles> ok, will check that out
10:17:51 <edwardk> but basially you can do things like $(compound [e| \(a,b,c) -> (b,c) ])    and it builds the lens from your pattern matching, etc.
10:18:13 <edwardk> basically you provide the match and construction and it turns everything around to put it back together
10:19:00 <ocharles> yea, having a look at the example atm, it looks interesting
10:19:06 <edwardk> the issue i didn't get a chance to address is that lenses do type-editing field access like records, but you need to use a compount lens, if you have something like data Foo a = Foo { x,y :: a, z :: Int }
10:19:23 <atriq> edwardk, I'm actually using lenses now
10:19:35 <edwardk> it needs some polish, and i want to change the design a bit to fit the rest of the library and have a more principled way to generate traversals before we integrate it
10:19:45 <edwardk> atriq: =)
10:19:47 <atriq> I was quite surprised
10:19:52 <edwardk> oh?
10:19:56 * ocharles was refactoring some of his lens using code during the talk itself
10:19:57 <ocharles> :)
10:20:03 <edwardk> heh
10:20:11 <atriq> Mainly that I've managed to understand lenses enough to use them
10:20:13 <ocharles> "ohhhh, so that's what 'to' is for!"
10:20:40 <atriq> Which talk?
10:20:44 <edwardk> atriq: my goal with the library was that if you looked and found a combinator that remotely looked like what you wanted that you should be able to use it with pretty much anything that remotely looked like it would fit ;)
10:24:54 <atriq> edwardk, you did well!
10:25:11 <ocharles> atriq: the talk was about the derivation of the lens library, and how to use it
10:25:14 <ocharles> (at bay area haskell)
10:25:24 <atriq> Is there a video online anywhere?
10:25:34 <ocharles> sadly no, google said no recording/pictures
10:25:51 <ocharles> (it was hosted at google's office)
10:25:56 <edwardk> i'm just hoping next time i won't be talking to a large crowd without a microphone right after recovering my voice. ;)
10:26:12 <ocharles> :)
10:26:14 <edwardk> the sheer number of monitors sprinkled across the room helped quite a bit though
10:26:21 <ocharles> glad to hear your back to health!
10:26:28 <ocharles> now you can get right back to work on indexed ;)
10:26:52 <shachaf> We all had to go through a memory wipe after the talk, just in case we saw something Googly we weren't supposed to.
10:27:07 <edwardk> hah
10:27:27 <edwardk> indexed is mostly on hold until simon fixes product kinds
10:27:39 <mm_freak> Polarina: i think we have the same purpose in mind, but with different interfaces
10:27:59 <edwardk> as they are i can't fix up and ship a polykinded version of categories or do indexed transformers, etc.
10:28:03 <Polarina> mm_freak, did you have any particular interface "style" in mind?
10:28:07 <mm_freak> Polarina: a manager wire might be something as simple as Wire e m a b and as complicated as a large Manager type
10:28:10 <ocharles> i see
10:28:13 <edwardk> even my 'herp & derp' witness hack break down there =(
10:28:20 <edwardk> er breaks
10:28:24 <ocharles> i'll hopefully have a chance to grab you at gsoc to talk about what i plan to do with indexed
10:28:30 <ocharles> if indexed is even the right thing, anyway
10:28:31 <edwardk> sure
10:28:39 <ocharles> (but i think it is, after briefly skimming mcbride's paper)
10:28:42 <mm_freak> Polarina: the interface style i have in mind is one where you can choose to update the current set of wires from input, a monadic action and even another thread, including memory transactions
10:28:44 <edwardk> i'm down in mountain view at the wild palms today even
10:29:11 <edwardk> not sure where you are staying or if you are a local
10:29:32 <mm_freak> Polarina: and where the type of database is selected by the user, not netwire, so i might use something like IxSet (that's basically what i'm currently examining)
10:29:40 <Polarina> mm_freak, well, hmm... wire inputs can be result of monadic computations (with perform or execute*).
10:29:47 <Polarina> mm_freak, ah.
10:30:17 <ocharles> edwardk: ah ok, i'm staying at the domain
10:30:19 <mm_freak> Polarina: the point is:  you have a wire, let it be constructed by mkGen, and at some point in the underlying computation you choose to add another wire to the set, then that's just a monadic action
10:30:45 <Guest1447> Hi, some people here understanding Haskell? ^^
10:30:50 <mm_freak> Polarina: the other option would be through output of the subwires, but then the response time is much longer (i.e. you have to wait until the next instant to observe the change)
10:30:54 <Polarina> mm_freak, so, you want the user to be able to manage the whole set easily, without netwire having neccesarily manage addition/removals, etc.?
10:31:08 <mm_freak> Polarina: exactly
10:31:19 <mm_freak> netwire should do a lightweight job there
10:32:16 <mm_freak> Guest1447: haskell is like quantum mechanics; if you claim to understand it, you don't
10:32:37 <mm_freak> anyone who has ever tried to implement comonad transformers knows how little he understands haskell =)
10:32:58 <edwardk> i implemented them twice. the first time i screwed them all up
10:33:04 <n-dolio> Is it also like quantum mechanics in that people cite BS quotes about how no one understands it?
10:33:15 <Polarina> mm_freak, just to clarify, where do you want the set of wires to come from? Wire input, or from the monad, like { :: (m ListOfWiresType) -> Wire e m a b }?
10:33:18 <mm_freak> ;)
10:33:49 <brunonery> hi guys! I'm trying to extract a number from a string -- "this is task #123". what's wrong with: read . tail . ((=~ "#[0-9]+") :: String) ?
10:33:51 <Guest1447> I want to program as short as possible that a function func a b c, finds out the two biggest numbers and gives back a^2 + b^2, assumed a and b are the biggest numbers here. :)
10:33:58 <mm_freak> Polarina: an IxSet managed by the manager wire
10:34:15 <Guest1447> I already have some code, but its too long
10:34:23 <mm_freak> Polarina: the schema of the IxSet is selected by you, i.e. it's polymorphic in the element type
10:34:30 <Polarina> Ah.
10:34:45 <Polarina> Let me look up IxSet for a second here. :)
10:34:55 <mm_freak> @hackage ixset
10:34:55 <lambdabot> http://hackage.haskell.org/package/ixset
10:35:00 <mm_freak> there
10:35:20 <Polarina> Thanks.
10:36:27 <Guest1447> atm i have: sum_max_sq a b c | a <= b && a <= c = b * b + c * c  | otherwise = sum_max_sq b c a
10:37:09 <Guest1447> any idea how to get this shorter. i don't want more performance. i just want to use less tokens
10:37:51 <Kyraimion> > let [_,a,b] = sort [5,3,7] in a^2 + b^2
10:37:52 <lambdabot>   74
10:38:18 <Cale> brunonery: "nothing"
10:38:29 <Cale> brunonery: Apart from the fact that you're using the most confusing library in the world, and regexes.
10:38:33 <Guest1447> thx Kyraimion i'll try it
10:38:46 <Cale> brunonery: that ought to work, so long as it knows what type it's meant to read
10:39:20 <Cale> oh, your type signature
10:39:22 <brunonery> hmmm ok, Cale -- it must be something else bugging ghc then. what do you mean by "the most confusing library in the world"?
10:39:26 <Cale> ((=~ "#[0-9]+") :: String)
10:39:30 <Cale> this is clearly false :)
10:39:39 <brunonery> oh String -> String?
10:39:42 <Cale> yeah
10:39:45 <Cale> or remove it
10:39:54 <Cale> because you're passing the result to read anyway
10:40:01 <Cale> so it'll know it needs to produce a String
10:40:12 <Cale> the type which is ambiguous is what type is the result of read
10:40:37 <brunonery> but I'm using it to fill a record field that is Int :P
10:40:47 <Cale> ah, in that case, all should be well
10:40:53 <Cale> if you just remove the explicit signature
10:41:16 <Cale> brunonery: Text.Regex.Base does a ton of fancy context-sensitive type stuff, which is far more complicated even than what perl does in that regard
10:41:49 <brunonery> hehe ok Cale! remove the explicit signature, and it worked -- it was the way I was calling it on the let in clause that was wrong
10:42:24 <Cale> For my own parsing, I essentially never use regular expressions anymore
10:42:47 <Cale> I would only use a regex library if it was part of the spec of the thing I was implementing that I had to provide regular expression support to my users.
10:43:49 <Cale> Parser combinator libraries pretty much dominate regex libraries as far as readability and maintainability of code in all cases, and they're much easier to write as well, for any case more complicated than the one you have there :)
10:44:17 <Cale> (I mean, the parsers are easier to write)
10:44:30 <ocharles> <3 parser combinators
10:47:08 <brunonery> Parser combinator? any nice tutorial on the subject? I'm a C++/Python guy, and I'm planning on starting to write my throw away programs with Haskell now
10:47:34 <jamiltron> Is there an easy way using randomIO to generate a list of random integers?
10:47:46 <brunonery> by the way,  is there a beautiful pointwise way of saying this    "extractStatus l = if (l =~ "Starting") then Started else Stopped"?
10:47:55 <brunonery> extractStatus returns Status, which is data Status = Started | Stopped deriving (Enum, Show)
10:48:16 <srhb> jamiltron: Why not use randomRIO?
10:48:32 <srhb> jamiltron: Er, sorry, not what I meant
10:48:45 <Kyraimion> @type replicateM -- jamiltron
10:48:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:49:02 <srhb> jamiltron: randoms :-)
10:50:07 <jamiltron> Thank you!
10:50:14 <hpaste> Polarina pasted “manager wire” at http://hpaste.org/76493
10:50:29 <Polarina> mm_freak, so, if I understand IxSet correctly, how's that?
10:52:43 <mm_freak> Polarina: that's not how you would use IxSet here…  you provide query/subset operations
10:52:55 * Polarina is clueless.
10:53:11 <mm_freak> so the signature would look something like this:  manager :: Manager w e m a b -> Wire e m a b
10:53:34 <mm_freak> one member of Manager would be:  IxSet w -> IxSet w
10:53:42 <mm_freak> that one selects the wires to run
10:57:19 <Polarina> mm_freak, hmm... to be honest, if I'm not missing anything, I think using IxSet here might be an overcomplication.
10:57:46 <wereHamster> how do I generate documentation?
10:58:30 <Polarina> wereHamster, if you're using cabal, try cabal haddock.
10:58:56 <wereHamster> and if not?
10:59:36 <maukd> if not, why not? :-)
11:00:06 <wereHamster> it's a single file so far.
11:00:15 <Polarina> wereHamster, try looking into haddock's own documentation: http://www.haskell.org/haddock/doc/html/index.html
11:04:10 <mm_freak> Polarina: i don't see any other way to do it…  you have to consider that i have to find a solution that is sufficiently generic
11:12:58 <atriq> Has anyone got any suggestions for a graphics thingy like I described earlier?
11:13:16 <atriq> I'm looking for one that lets me create windows and paste images in them
11:13:30 <atriq> Preferably simple
11:26:20 <strebe> atriq: the gimp?
11:26:34 <atriq> strebe, I mean a Haskell library
11:27:14 <strebe> makes more sense, but just in case it wasn't what you meant, I had to make sure it wasn't getting missed :)
11:27:36 <strebe> I would expect the gtk bindings to allow for that?
11:28:40 <atriq> Apparently, the 'G' in GTK stands for GIMP
11:28:48 <atriq> So, I'm using GIMP anyway, hehe
11:29:58 <strebe> kinda :-)
11:32:28 <strebe> otherwise, I'd also be amazed if it didn't work in wxhaskell, which I hear is more portable
11:32:41 <strebe> but I generally avoid gui programming like the plague
11:33:42 <atriq> Right, I'm install gtk
11:33:48 <atriq> (the haskell library)
11:33:57 <atriq> (I think I already had GTK itself installed)
11:34:19 <atriq> (in fact, I almost certainly did, since I'm on Ubuntu and use GIMP)
11:34:56 <kirindave> I am still reeling from edwardk's talk last night.
11:35:09 <kirindave> Gotta find an excuse to do a blog post about lens now.
11:40:41 <strebe> kirindave: please do
11:40:53 <strebe> atriq: then it's certain you did, yes
11:42:16 <kirindave> I should resolve Project Euler 58 using lens to clean up the code then do another post on that.
11:42:28 <kirindave> As an approach towards true real-world problems in haskell.
11:42:39 <kirindave> "Here is a bs problem. Here is a math problem. Here is an operational problem."
11:42:57 <strebe> meh, I'll need to get around to looking at 58 and solve it so that's not a spoiler :-)
11:43:01 <kirindave> Maybe that's a nice didactic progression.
11:43:16 <kirindave> strebe: The natural haskell solutions are fast.
11:43:28 <kirindave> strebe: Or as a friend said, "Stream fusion like woah."
11:43:36 <strebe> kirindave: nice :-)
11:43:53 <kirindave> Like amortized check a prime factor ever 3 microseconds kind of fast.
11:44:12 <kirindave> As fast as an assinine unreadable C implementation fast.
11:50:49 * strebe takes a look
11:56:06 <Cale> kirindave: What algorithm are you using?
11:59:13 <kirindave> Cale: Oh it's what arithmoi offered.
11:59:30 <kirindave> Cale: Let me look it up..
11:59:50 <kirindave> Cale: "isPrime n tests whether n is a prime (negative or positive). First, trial division by the primes less than 1200 is performed. If that hasn't determined primality or compositeness, a Baillie PSW test is performed." from http://hackage.haskell.org/packages/archive/arithmoi/0.4.0.1/doc/html/Math-NumberTheory-Primes-Testing.html
12:00:26 <kirindave> Cale: Since PE58 terminates before numbers even exceed signed 32bit integer range, it's an exceptionally fast approach.
12:00:48 <Cale> Right, that's a serious primality test :)
12:00:51 <kirindave> My tests suggest if you write it right for one CPU, haskell produces code that pretty much functions entirely in cache.
12:01:21 <kirindave> And thus with -O2 even my naive solution completes in 200ms.
12:02:10 <kirindave> Of course a lot of solutions I've seen for P58 generate the entire goddamn matrix. And my first implementation suffered from my misunderstanding and was O(n^2). :P
12:03:16 <strebe> kirindave: yep, that's exactly the class of solutions i'm currently busy rejecting...
12:03:55 <Cale> kirindave: In fact, it sounds pretty much identical to what Mathematica's PrimeQ does
12:04:43 <Cale> "PrimeQ first tests for divisibility using small primes, then uses the Miller-Rabin strong pseudoprime test base 2 and base 3, and then uses a Lucas test."
12:04:53 <Cale> bailliePSW n = isStrongFermatPP n 2 && lucasTest n
12:05:27 <Cale> So Mathematica would be doing  isStrongFermatPP n 2 && isStrongFermatPP n 3 && lucasTest n
12:08:16 <kirindave> Cale: No coincidence, I bet.
12:08:42 <kirindave> strebe: Project Euler is almost always, "Notice this mathematical relationship BEFORE you code."
12:09:21 <kirindave> strebe: So just find a function from Winding -> Corners.
12:09:43 <maukd> oh, I wasn't supposed to brute force everything?
12:09:47 <strebe> kirindave: that's what I'm currently coding, as I'd noticed it, but hey, no spoilers :-)
12:10:14 <rwbarton> run all your project euler solutions on ec2 with cloud haskell
12:15:03 <kirindave> maukd: My first impl was N^2 by accident because I forgot pure functions don't behave like IO actions. :(
12:15:19 <kirindave> maukd: Livin' life in IO. What of it? :)
12:15:55 <tac-tics> Is there an easy rule of thumb for approximating complexity in a lazy language?
12:16:44 <tac-tics> In an imperative language, you can watch out for loop nesting, for instance.
12:17:05 <kirindave> tac-tics: is there an easy rule of thumb for approximating complexity in a strict language?
12:17:32 <kirindave> tac-tics: Loop nesting can be pretty misleading.
12:17:57 <shachaf> tac-tics: "loop nestings" are just as bad, FSVO "loop"s, if they're actually evaluated.
12:18:47 <strebe> kirindave: how were you expecting them to behave like IO actions?
12:19:29 <jix> tac-tics: you can still use loop nesting... just look out for (higher order) functions that recursively deconstruct lists or similar
12:19:44 <jix> tac-tics: but it still can be as misleading
12:19:48 <kirindave> strebe: I cannot remember why I just assumed they'd auto-memoize.
12:19:52 <kirindave> strebe: Dumb me, I know.
12:20:34 <tac-tics> shachaf: FSVO?
12:20:52 <strebe> kirindave: ahh, yeah; that's bit me on project Euler problems too, easy mistake
12:21:08 <shachaf> tac-tics: For Some Values Of.
12:21:15 <tac-tics> ah
12:21:16 <tac-tics> of course
12:21:22 <shachaf> Nested loops are like a cartesian product.
12:21:32 <tac-tics> yeah
12:21:53 <tac-tics> and a cartesian product is like structural recursion on a pair of objects.
12:23:05 <tac-tics> How true is the proposition that normal order evaluation optimizes for time while applicative order evaluation optimizes for space?
12:25:25 <n-dolio> tac-tics: It's not hard to write things that will run in constant space in Haskell but O(big) space in, say, ML.
12:25:43 <tac-tics> hmm
12:26:24 <tac-tics> I guess I'm not even sure what it means for a function in haskell to have a certain complexity
12:26:47 <tac-tics> If the result is never used, the cost is constant.
12:27:00 <scp> tac-tics: sometimes =P
12:27:02 <tac-tics> (I think)
12:27:04 <tac-tics> yeah
12:28:01 <scp> haskell does lack predictability in theory, but I haven't implemented a function where I couldn't adequately guess its cost
12:28:43 <scp> by "in theory" I mean, there are theoretical cases where _I_ don't know what will happen =P. I'm sure it's all well defined
12:28:55 <kirindave> tac-tics: What is the time complexity of an imperative language's function that is never called? Similarly constant. :)
12:29:38 <scp> Ya, the weirdness comes from partial evaluation of results
12:29:59 <scp> then its hard to be sure whether it will be expensive or not
12:30:03 <tac-tics> kirindave: indeed :)
12:31:01 <copumpkin> indeedles
12:31:24 <kirindave> tac-tics: I think what I hear most people complain about in haskell is not time complexity issues but space complexity issues.
12:31:41 <kirindave> tac-tics: Usually what I hear from people regarding haskell wall clock performance is "How the ____ did it do it that quickly?"
12:32:10 <kirindave> tac-tics: Then a ghostly head resembling Simon Marlow appears through the wall and whispers something about optimizations to stream fusion and everyone laughs.
12:32:12 <tac-tics> hehe
12:32:30 <tac-tics> well, I'm curious for theoretical reasons
12:32:33 <tac-tics> Not practical reasons
12:32:44 <tac-tics> I'm curious about total functional programming languages
12:32:54 <tac-tics> which allows you to "choose your own adventure" with the reduction strategy
12:33:32 <tac-tics> I'd like to know what kind of considerations an optimized runtime would look like for such a language.
12:34:18 <incompetentcoder> hello
12:38:16 <minimalis> Hello, I have a quick STM question. Does anyone know how to dispose of channels created with dupTChan?
12:38:33 <maukd> "dispose"?
12:39:32 <minimalis> Or maybe it happens automatically? The issue is I'm creating a lot a duplicate channels, and don't want the messages taking up space when the duplicates are no longer being used.
12:40:27 <minimalis> Do you think they would get GC'd automatically when the duplicate channels go out of scope?
12:40:51 <jix> minimalis: it should be
12:42:49 <minimalis> Thanks, that was my guess
12:43:09 <jix> minimalis: as far as I understand the implementation the values will be in TVars that will not be referenced from anywhere when the duplicate channel got collected
12:46:04 <minimalis> That makes sense. I wasn't feeling quite brave enough to go and read the source.
12:46:24 <jix> minimalis: it's implementation is surprisingly simple
12:46:45 <jix> it's just a list with TVars in the spine
12:46:52 <shachaf> minimalis: Read the source! You'll have a much better intuition for how it works. http://hackage.haskell.org/packages/archive/stm/2.2.0.1/doc/html/src/Control-Concurrent-STM-TChan.html
12:47:14 <ciaranm> is there a standard way of dealing with parsec and applicative having different <|>s?
12:47:24 <kirindave> strebe: Solve it?
12:47:39 <kirindave> The STM package is quite readable, I think.
12:48:25 <minimalis> I'll have a look. I am finding STM very pleasant in general.
12:48:32 <shachaf> These slides might also help: http://community.haskell.org/~simonmar/slides/cadarache2012/3%20-%20concurrent%20haskell.pdf http://community.haskell.org/~simonmar/slides/cadarache2012/4%20-%20software%20transactional%20memory.pdf
12:48:52 <strebe> kirindave: got caught up in trying to write the function to generate the list of diagonals too prettily. I'm now writing it using a bit of an ugly hack
12:50:34 <Guest1447> i have been told that "let [_, a, b] = sort [x, y, z] in a^2 + b^2" has 24 Tokens, whereas "let" is a token, "[" is counted as a token, "x" is a token "," is a token, and so on. That's too much. I came to a function with 19 Tokens "if min b c >= a then b^2 + c^2 else sum_max_sq2 b c a". But there has to be a shorter code with 18 or less. Someone an idea?
12:51:08 <MostAwesomeDude> Guest1447: What is this for?
12:51:30 <strebe> MostAwesomeDude: clearly an intrinsic love of golf.. :/
12:51:32 <Guest1447> oh, i forgot to say, that on the left side of the phrase there is sum_max_sq2 a b c
12:51:56 <Guest1447> it is for us students who try to get the shortest code
12:52:12 <Guest1447> we don't want to have a performant solution, but a short one
12:53:59 <Guest1447> We count every identifier, operator, bracket, number etc. as a token.
12:55:23 <MostAwesomeDude> Guest1447: This is homework then?
12:55:43 <srhb> Golfing? :D
12:55:58 <Guest1447> No we don't have to do it. Its just for competition.
12:56:03 <srhb> Actually, I remember having a homework about writing the shortest quine in SML..
12:56:08 <srhb> homework challenge*
12:56:22 <sclv_> sum . map (^2) . take 2 $ sort [x,y,z] ?
12:56:32 <MostAwesomeDude> sclv_: I was gonna go along those lines as well.
12:56:41 <sclv_> i think the token count is still around 20 for that
12:56:47 <sclv_> but its the 'right' answer
12:57:04 <sclv_> you can replace take 2 by init
12:57:11 <MostAwesomeDude> sum . map (^@) . tail $ sort [x, y, z] -- You want the two *biggest* ones, right?
12:57:18 <srhb> Yes.
12:57:26 <Guest1447> right
12:57:27 <FireFly> sections are expensive due to the parens being separate tokens :\
12:57:28 <sclv_> oh, good point
12:57:30 <srhb> combine to a fold?
12:58:05 <sclv_> the lambda expression will have lotsa tokens tho
12:58:10 <srhb> True.
12:58:49 <osfameron> Guest1447: what have you tried?
12:59:04 <Guest1447> At the beginning i started with 30 tokens, then i found a solution with 25, then 19. then i thought i had 18, but forgot otherwise = xd
12:59:51 <Guest1447> the old with 30 is long gone and i can't remember
13:01:10 <Guest1447> let [_,a,b] = sort [x, y, z] in a^2 + b^2 looked good but the brackets alone have 7 tokens. 2 * 7 = 14 plus the rest
13:01:35 <srhb> Definitely like the other way better.
13:01:45 <Guest1447> now sum_max_sq2 a b c = if min b c >= a then b^2 + c^2 else sum_max_sq2 b c a is the shortest i have now ^^
13:02:03 <osfameron> does it have to be called as sum_max_sq2 a b c ?
13:02:03 <srhb> Ew :P
13:02:08 <shachaf> @pl sum_max_sq2 a b c = if min b c >= a then b^2 + c^2 else sum_max_sq2 b c a
13:02:09 <lambdabot> sum_max_sq2 = fix (ap (ap . (ap .) . (`ap` ((. (^ 2)) . (+) . (^ 2))) . (liftM2 if' .) . flip (flip . ((>=) .) . min)) . flip . (flip .))
13:02:09 <srhb> Names count as one token
13:02:10 <srhb> I believe
13:02:11 <shachaf> There you go.
13:02:25 <FireFly> I think that one has more than 18 tokens
13:02:49 <Guest1447> sum_max_sq2 = , is always there
13:02:59 <Guest1447> so we always count right after the "="
13:03:12 <Guest1447> and a function like sum_max_sq2 is 1 token
13:03:28 <srhb> Guest1447: Function calls too?
13:05:03 <Guest1447> its like every char is one token e.g. "(", ",", "a", ")" and so on
13:05:09 <srhb> Ah well.
13:05:18 <Guest1447> but a function name like "sum_max_sq" counts as 1 token
13:05:28 <srhb> Golf it in Perl :P
13:05:31 <srhb> Much better for it.
13:06:18 <Guest1447> and thats why "sum_max_sq2 a b c = if min b c >= a then b^2 + c^2 else sum_max_sq2 b c a" has 19 tokens
13:07:00 <Guest1447> count right after the = "if" "min" "b" "c" ">=" "a" "then" "b" "^" "2" ....
13:08:31 <hpaste> scp pasted “Why isn't this running faster w/ +RTS -N4?” at http://hpaste.org/76498
13:09:01 <scp> anyone? =]
13:12:42 <n-dolio> scp: Is it using 2 cpus?
13:12:58 <scp> 4
13:13:02 <n-dolio> No.
13:13:05 <n-dolio> I mean actual usage.
13:13:21 <scp> Oh, that's a good point, I'm ensuring only 2 run at once.
13:13:26 <n-dolio> And you're not parallelizing more than 2 at at ime.
13:13:41 <scp> Hmm, let me try running w/ N2 and see if it gives improvements
13:13:52 <n-dolio> But what I meant was, is it pegging 2 cpus?
13:13:56 <n-dolio> Or just 1?
13:14:16 <scp> It uses all 4, but goes way slower
13:14:18 <n-dolio> Or something else.
13:14:21 <scp> they are all at 30-40%
13:14:30 <scp> if I run it on 2, it goes only slightly slower than it does on 1
13:15:02 <scp> oh nevermind... Ok
13:15:08 <scp> +RTS -N2 was my answer =], thanks n-dolio
13:15:18 <scp> I need to parallelize more if I want more to run x_X
13:17:31 <Guest1447> @MostAwesomeDude your solution with "sum . map (^2) . tail $ sort [x,y,z]" has only 18 tokens thank you
13:17:31 <lambdabot> Unknown command, try @list
13:19:48 <dzhus> scp: note that parallel naiveFib is quite an unbalanced load and I believe parallel package has no tricky scheduling to deal with that, you may try to use Repa's interspersed scheduling to deal with this
13:20:17 <dzhus> oh, I'm still writing in Ingrish
13:24:31 <MostAwesomeDude> Guest1447: Wait, *I* got it? That's remarkably unlikely.
13:25:25 <typoclass> srhb: hiya :) have you seen my message in haskell-blah?
13:26:15 <solirc> I'm trying to use different unlit options for different files.  Anyone succeeded in doing that?
13:26:29 <solirc> If I do something like: ghci -pgmL custom-unlit -optL optionA ModuleA.lhs -pgmL custom-unlit -optL optionB ModuleB.lhs
13:26:53 <solirc> then optionA and optionB are used for MudeleB
13:27:23 <solirc> they are dynamic, so I think in theory GHC can support it
13:27:36 <solirc> but I'm not sure if there is a UI for it
13:27:45 <Guest1447> MostAwesomeDude: ok you wrote "sum . map (^@) . tail $ sort [x, y, z] -- " but i changed it a bit xd
13:28:41 <Kyraimion> :t (^@)
13:28:42 <lambdabot> Not in scope: `^@'
13:29:11 <Kyraimion> Oh, obviously (^2) is meant
13:29:28 <Guest1447> yes ^^
13:29:38 <Guest1447> but he wrote ^@ and i changed it to 2
13:29:43 <Guest1447> so its his solution ^^
13:30:11 <Guest1447> it has 18 tokens and is the shortest i have seen so far. i think 17 or less is impossible
13:31:59 <Polarina> Does anyone know of a pure version of this library that can parse BMP files directly from a ByteString, rather than a Handle? http://hackage.haskell.org/package/bmp-1.2.2.1
13:32:42 <shachaf> I wonder if there's a reasonable way to make a pseudo-Handle from a ByteString?
13:32:50 <shachaf> It looks like the structure of Handle is kind of hard-wired. :-(
13:32:55 <copumpkin> why is that in IO and Handle in the first place?
13:34:05 <solirc> shachaf, Polarina: http://hackage.haskell.org/package/knob
13:34:15 <solirc> but does not support all operations
13:34:41 <Polarina> solirc, oh, noes...
13:34:46 <Polarina> That's a silly workaround.
13:34:56 * solirc nods
13:35:05 <Polarina> And I'm deep inside some pure code doing BMP things.
13:35:28 <copumpkin> bug benl23 to make BMP pure
13:36:25 <solirc> Polarina: just said it because shachaf asked for that ;)
13:36:31 <Polarina> Hehe.
13:36:36 <solirc> but yes
13:36:37 <Polarina> copumpkin, I'll email him then.
13:36:38 <solirc> it won't help
13:37:02 <copumpkin> Polarina: you basically want that hGetBMP2 function inside his code that isn't exported
13:37:11 <copumpkin> a simple wrapper around that would do it
13:37:40 <rwbarton> is there a Data.Map.Strict for ghc 7.4? if I install containers-0.5.1.0 that will break everything right?
13:37:58 * Polarina wonders if TH can magically access it somehow.
13:38:13 <clahey> @hoogle [a] -> [[a]]
13:38:14 <lambdabot> Data.List inits :: [a] -> [[a]]
13:38:14 <lambdabot> Data.List permutations :: [a] -> [[a]]
13:38:14 <lambdabot> Data.List subsequences :: [a] -> [[a]]
13:39:19 <shachaf> rwbarton: It'll break lots of things if you try to use it
13:40:01 <shachaf> I didn't realize .Strict wasn't in 0.4.
13:40:15 <rwbarton> it is not :(
13:40:32 <rwbarton> will just write this silly foldl' / insertWith' thing yet again
13:40:49 <shachaf> Just upgrade, man!
13:41:01 <shachaf> GHC 7.6 has been out for, like, *years*.
13:41:02 <rwbarton> i bet that would break repa more than it would unbreak Data.Map.Strict
13:41:46 * shachaf tries to install repa.
13:41:54 <shachaf> It compiles...
13:42:05 <clahey> Guest1447: You want the sum of the squares of the highest two values, not the sum of the highest two squares of the values?
13:42:22 * hackagebot perm 0.3.0.1 - permutation Applicative and Monad with many mtl instances  http://hackage.haskell.org/package/perm-0.3.0.1 (AndySonnenburg)
13:44:24 * Polarina just sent the mantainer a mail.
13:46:28 <Polarina> solirc, copumpkin, shachaf, JuicyPixels seems like a good alternative: http://hackage.haskell.org/packages/archive/JuicyPixels/2.0.1/doc/html/Codec-Picture-Bitmap.html
13:49:50 <typoclass> Polarina: yes i've used juicypixels casually the other day, and it worked well
13:51:42 <Polarina> typoclass, :)
13:52:08 <Shapeshifter> Hi. I would like to try happstack but I have ghc 7.6 and happstack seems to require sendfile, which depends on an older bytestring than the one I have. Other than downgrading ghc, what can I do to solve this?
13:52:36 <stepcut> Shapeshifter: I could bump the upper bounds on sendfile and upload a new version
13:52:55 <stepcut> Shapeshifter: but.. it would be nice if you could check if that actually works first..
13:53:25 <stepcut> Shapeshifter: just do, cabal unpack sendfile, edit the sendfile.cabal and raise the limit, and then run 'cabal install' in the directory to install it
13:53:34 <stepcut> if that works I will patch sendfile and upload a new version to hackage
13:54:15 <hiptobecubic> Has anyone tried comonadically solving a PDE via ex. finite differencing?
13:54:44 <alpounet> hiptobecubic, i think i've seen a blog post or two about that
13:55:00 <hiptobecubic> damn
13:55:01 <alpounet> http://idontgetoutmuch.wordpress.com/2012/04/01/solving-a-partial-differential-equation-comonadically/
13:55:07 <typoclass> Shapeshifter: you could also use cabal-dev or virthualenv for what stepcut said, if you're concerned about your ~/.cabal getting borked
13:55:17 <hiptobecubic> i thought i had something novel to work on :)
13:55:29 <Shapeshifter> stepcut: It compiled and installed. Is there something I could test? Although now happstack-server fails to build.
13:55:53 <stepcut> Shapeshifter: if it compiles, it should be fine. What error does happstack-server get ?
13:56:23 <Shapeshifter> stepcut: see http://pastie.org/5085972
13:56:45 <Shapeshifter> stepcut: a problem with System.Time.CLockTime vs. actual type time-1.4.0.1:Data.Time.Clock.UTC.UTCTime
13:57:16 <stepcut> ah, there is a patch for that. directory switched from old-time to time I think. I will apply that patch and upload a new happstack-server as well.
13:57:18 <stepcut> give me 10 mins.
13:57:43 <Shapeshifter> stepcut: oh thanks, that's great.
13:58:06 <clahey> Any idea why I can't click on any links in http://hackage.haskell.org/package/algebra
13:59:17 <typoclass> clahey: probably because of the build failure. to generate documentation, haddock needs source code that is at least somewhat working
13:59:43 <typoclass> clahey: you could do "cabal unpack algebra" and view the files directly
14:00:11 <clahey> typoclass: Gotcha.
14:00:12 <typoclass> (unpack does not install things or mess with your ~/.cabal)
14:00:23 <dhorn> @quote cheezey
14:00:24 <lambdabot> cheezey says: oh man i wish i had some cheese
14:00:58 <typoclass> clahey: oh also, the older version did work http://hackage.haskell.org/package/algebra-2.1.1.2 if you don't anticipate much change between 2.1 and 3.0
14:03:36 <sclv_> i'm getting  "undefined reference to `ntohl'" linker errors playing with distributed-process on windows. -lws2_32 doesn't seem to help. any other suggestions?
14:05:16 <typoclass> sclv_: ntohl is a function relating to networking, so you need to link against whatever library does networkish things on windows. which i have no clue about :)
14:05:28 <sclv_> yes, that's supposed to be ws2_32
14:06:49 <Sculptor> tuta1234321
14:07:16 <Eduard_Munteanu> Someone needs to change his password now? :P
14:07:25 * hackagebot sendfile 0.7.7 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.7.7 (JeremyShaw)
14:08:18 <Sculptor> Eduard_Munteanu, hah, good one
14:08:49 <Sculptor> now someone will ghost me
14:09:01 * nand` was tempted
14:09:19 <nand`> but I decided I shouldn't enforce a society in which mistakes are punished, because mistakes are how you learn
14:09:25 <Sculptor> but, no, wait. that's not my password
14:09:41 * adnauseam walks in
14:09:56 <adnauseam> what is this.. i don't even...
14:10:02 <Eduard_Munteanu> I tried it :).
14:10:13 <typoclass> sclv_: http://msdn.microsoft.com/en-us/library/windows/desktop/ms740069(v=vs.85).aspx seems to suggest ntohl is indeed provided by ws2_32, so i'm gonna guess that ghc somehow doesn't find the library even though you said -lws2_32
14:10:17 * Eduard_Munteanu feels bad about himself
14:10:25 <typoclass> sclv_: also, could it be some sort of 32 vs 64 bit issue?
14:27:00 <Student148> hello
14:27:37 <typoclass> Student148: hi
14:27:39 <Student148> Hello guys, i need your help
14:28:44 <Student148> i want create a module for Haskell. This module take the minimum of 3.
14:28:51 <stepcut> Shapeshifter: fixed the UTCTime requires tweaks to a bunch of .cabal files that depend on happstack-server, so its going to take a little longer than I first predicted
14:29:05 <Student148> >min3:: Int -> Int -> Int -> Int
14:29:06 <Student148> >min3 a b c = (if a<b && a<c then a else ) (if b<c && b<a then b else c)
14:29:10 <Student148> where is my error ?
14:30:58 <joehillen> Student148: check after the 'else'
14:31:10 <joehillen> Student148: both of them
14:32:36 <mcstar> hai
14:34:56 <manone> ?wiki Monad
14:34:57 <lambdabot> http://www.haskell.org/haskellwiki/Monad
14:34:58 <Shapeshifter> stepcut: no hurry, I'm reading the happstack philosophy in the meantime ^^
14:35:06 <stepcut> sweet
14:39:59 <nand`> class Dyad d where return :: a -> b -> d a b; ... -- ?
14:43:21 <nand`> my C# implementation of monads could be added to that wiki page: http://hub.darcs.net/nand/csharp/browse/MonadDict/MonadDict.cs
14:43:22 <manone> what's the best/fastest way to learn haskell? have a lot of experience with imperative languages (c/c++/java/etc) but not much fp. i want some books/sites/materials to get the main ideas and move along fast with haskell… any suggestions ? tx
14:43:24 <nand`> perhaps somewhat condensed
14:43:41 <nand`> manone: I cannot answer what the fastest way is, but the best imo starts with LYAH
14:43:43 <nand`> @where lyah
14:43:44 <lambdabot> http://www.learnyouahaskell.com/
14:44:03 <manone> tx - read lyah already :)
14:44:04 <Kyraimion> Why does "#if MIN_VERSION_base(3,0,3)" compile but ghci complains about 'missing binary operator before token \"" ' (or, presumably, the proprocessor does)
14:44:16 <manone> went well for the first few chapters
14:44:33 <typoclass> manone: hi :) you might try real world haskell, which is available free of charge
14:44:33 <typoclass> @where rwh
14:44:33 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
14:44:36 <manone> and i loved his sense of humor
14:44:42 <manone> then it went into some stuff that got me lost
14:45:03 <nand`> this would be the right place to ask questions about the things that had you confused
14:45:13 <manone> got it, thanks
14:45:44 <typoclass> Kyraimion: i'm pretty sure that .hsc kind of stuff is not possible for ghc and ghci. you need to preprocess the file with hsc2hs, or whatever. cabal does this automatically for you (the intermediate .hs file is somewhere in dist/build/ i think)
14:45:46 <manone> i started with realworld also but again - after a few chapters i'm sinking in without anything sinking in anymore :)
14:46:13 <Kyraimion> typoclass:  It's not hsc, just -XCPP
14:46:28 <typoclass> Kyraimion: hm i see. dunno about -XCPP :-/ sorry
14:46:38 <manone> i would need something clear/well done that describes well the concepts (both fp and especially haskell)
14:46:46 <rwbarton> Kyraimion: i think maybe cabal defines that MIN_VERSION_base macro
14:46:47 <Kyraimion> Ah, it's probably because cabal sets extra flags
14:47:11 <manone> have strong math bkground also, just need The Way :)
14:47:17 * nand` .oO( A fast way to learn Haskell would probably be aboard the Helios 2 solar probe )
14:47:26 <manone> :))
14:47:28 <mcstar> nand`: are there persistent data structures in c#? like set/map for haskell?
14:47:48 <Kyraimion> rwbarton:  Thanks, I just realized that muself
14:47:49 <nand`> mcstar: you can have a class with immutable fields
14:47:51 <sipa> nand`: http://abstrusegoose.com/249
14:47:53 <nand`> ‘readonly’ attribute
14:48:00 <nand`> so values of this class are effectively persistent
14:48:02 <janiczek> guys, Im having a problem ... Im trying to install gtk2hs-buildtools, and it doesnt see program "alex" ... but I installed it. Im on osx 10.8, port-installed ghc and cabal
14:48:45 <Kyraimion> janiczek:  Is you cabal/bin folder in $PATH?
14:49:29 <nand`> (C# also has laziness annotations, with manual forcing)_
14:51:20 <janiczek> Kyraimion: no I dont - so that will be it. but where can I find it?
14:51:57 <typoclass> manone: i'd actually advise that you don't worry about the concepts too much. a lot of stuff has been written ('writing a new monad tutorial' has even become a running joke around here), but as far as i'm concerned, all that stuff didn't really help me much. nothing beats writing haskell code and muddling through. the conceptual understanding will come by itself
14:52:26 * hackagebot happstack-server 7.1.0 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.1.0 (JeremyShaw)
14:52:30 <Polarina> manone, http://learnyouahaskell.com/ is also very good.
14:52:38 <Kyraimion> janiczek:  Under unix it's in $HOME/.cabal/bin but I have no idea about OSX
14:52:39 <typoclass> manone: that said, what concepts are giving you trouble at the moment? :)
14:52:56 <typoclass> Polarina: yup :) he says he's in the middle of it
14:53:03 <Polarina> typoclass, ah. :)
14:53:05 <imeredith> say you have a web service - and you want to store a list of ips in memory of every client that has accessed the web service - how to you do that without mutation?
14:53:06 <nand`> I'm not sure I agree with that typoclass, ‘just poking around’ can, while enlightening, be incredibly misleading
14:53:08 <manone> typoclass: i'm trying to build a parsing system for xml
14:53:26 <manone> nand': that's my approach too - top down
14:53:41 <janiczek> Kyraimion: maybe ~/Library/Haskell/bin, the alex is there
14:53:45 <manone> problem is i don't see the top from here :)
14:53:48 <janiczek> ill try to add it to $PATH
14:53:51 <nand`> I like top down; start by defining what it is you want, then break it up into smaller sub-problems
14:54:15 <manone> by top down i mean "understand the main concepts first"
14:54:38 <janiczek> Kyraimion: yes that did it :) thanks!
14:55:24 <nand`> the same wording applies - what you want is (understanding of) a programming language; so you break it up into smaller domains/concepts
14:55:33 <manone> @Typoclass: @nand: so i guess the questions would be : what's the best subset of all the theory around fp/haskell that i should read before starting to get me going through the first few (simple/test) apps
14:55:33 <lambdabot> Unknown command, try @list
14:55:36 <typoclass> imeredith: the default answer is, you add the new ip to a list. adding is immutable because it gives you a new list that is the same as the previous list plus the new element. then you pass this new list as an argument into a function, often recursively
14:56:15 <nand`> manone: I don't know; I went through and understood all of LYAH before throwing myself headfirst into practice apps
14:56:19 <imeredith> typoclass: well, but then how does that list get passed to the next request so that the next ip can be appended?
14:56:28 <imeredith> typoclass: oh..
14:56:37 <nand`> but you can probably satisfy yourself with a lot less; especially if you choose to ignore IO and focus on pure programming, eg. in GHCi
14:57:00 <manone> i need to use IO
14:57:14 <manone> IO is not optional for what i want to do
14:57:18 <nand`> for an XML parser, for example, you don't
14:57:28 * hackagebot happstack-server-tls 7.0.1 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.0.1 (JeremyShaw)
14:57:31 * hackagebot happstack-lite 7.3.0 - Happstack minus the useless stuff  http://hackage.haskell.org/package/happstack-lite-7.3.0 (JeremyShaw)
14:57:32 * hackagebot happstack-hamlet 7.0.2 - Support for Hamlet HTML templates in Happstack  http://hackage.haskell.org/package/happstack-hamlet-7.0.2 (JeremyShaw)
14:57:34 * hackagebot happstack-heist 7.0.1 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-7.0.1 (JeremyShaw)
14:57:43 <stepcut> \o/
14:57:58 <manone> really? how do i get the xml in then?
14:58:21 <rwbarton> that is not the xml parser's problem :)
14:58:28 <nand`> your ‘parsing function’ would fundamentally look something like parse :: String -> XML  (or perhaps Maybe XML or Either Error XML, whatever)
14:58:53 <nand`> whether you get the String from a file or a user input or a network socket or whatever is of no concern to the parsing function
14:58:54 <Kyraimion> And probably ByteString or Text rather than String
14:59:15 <typoclass> nand`: there's of course nothing wrong with setting a task and breaking it up into subtasks. but i've found that in haskell, if you try to "understand the theory first", you'll end up reading all night about abstract algebra, category theory, and whatever other math jargon. the problem in my opinion is that outside of some niches, that stuff is neither necessary to be a haskell programmer, nor is it even very helpful
14:59:40 <manone> typoclass: brilliant comment !
14:59:43 <Cale> Oh, it can be very helpful, but necessary? Not really.
15:00:00 <manone> but i need to know how to acquire that besides hacking away for years...
15:00:18 <incompetentcoder> what does eta reduce mean?
15:00:37 <rwbarton> turning \x -> {- something -} x to {- something -}
15:00:38 <nand`> typoclass: oh, I see what you mean; yeah I believe the ‘theory of Haskell’ is actually very, very condensed - you should learn about how the type system works, how nonstrictness works, how pattern matching works, that kind of stuff
15:01:04 <Cale> manone: How to acquire what exactly?
15:01:17 <Cale> manone: What is your goal? To understand the IO library?
15:01:20 <ion> @check \x -> {- something -} x == {- something -}
15:01:20 <lambdabot>   Parse error at end of input
15:01:35 <Cale> You certainly do not need to understand monads (even in Haskell!) to understand IO
15:01:36 <manone> 1 - i want to understand what is teh minimum amount of theory to learn/understand fp well
15:01:37 <typoclass> nand`: oh absolutely no disagreement there. i'd count that as programming topics, not mathy at all
15:01:52 <rwbarton> ion: you need a special compiler that understands the {- something -} syntax
15:01:57 <Kyraimion> manone:  Have a look at http://www.cis.upenn.edu/~bcpierce/sf/index.html
15:01:58 <manone> 2 - want to understand the min amount of theory/libs to be able to use haskell
15:02:19 <manone> Kyraimion: tx
15:02:59 <manone> 3 - want to write some apps in haskell to use some IO (using xml as an example, but not really the case) - just need to do some parsing of heavy structured data
15:03:13 <nand`> as for 2, a large amount of library intuition can be gained from hackage (via tools such as hoogle or hayoo)
15:03:30 <nand`> which is imo quite vital for becoming a successful Haskell programmer
15:03:43 <incompetentcoder> if camelCase is the style for function names, what's the style for 'variables'?
15:03:48 <nand`> for parsing, Parsec is popular
15:03:50 <incompetentcoder> like a number or a data instance
15:04:01 <nand`> incompetentcoder: ‘a’, ‘b’, ‘c’, ...
15:04:07 <nand`> ‘x’, ‘y’ and ‘z’ are also fairly popular
15:04:22 <hpc> if you're feeling rebellious, you can use 'f' or 'g'
15:04:25 <incompetentcoder> but what if I want to define a constant like 'the set of all natural numbers'?
15:04:28 <typoclass> incompetentcoder: the same really. there's not much difference in haskell between values and functions. for example, both can be passed as a parameter equally well
15:04:34 <nand`> that would be a function
15:04:34 <incompetentcoder> right
15:04:36 <nand`> well,
15:04:38 <nand`> name-wise
15:04:42 <nand`> top-level definition
15:04:44 <Kyraimion> Don't forget the most helpfully named named "foo", "bar", "quux"
15:05:15 <nand`> the distinction is entirely between top-level (optionally exported) definition and local bindings
15:05:18 <Kyraimion> incompetentcoder:  As a matter of fact, functions are values.
15:05:45 <nand`> let ℕ = S.fromList [0..]
15:05:46 <incompetentcoder> and data are functions?
15:05:49 <incompetentcoder> in Haskell*
15:05:58 <nand`> ‘data’?
15:06:03 <nand`> Are you talking about the ‘data’ keyword?
15:06:20 <Kyraimion> incompetentcoder: Constructors are special, but they can act as functions
15:06:35 <hpc> more accurately, constructors can act as VALUES
15:06:42 <incompetentcoder> http://ideone.com/0Dzo7
15:06:43 <hpc> functions are a special case of values
15:06:54 <nand`> constructors can act as functions too
15:06:56 <rwbarton> some of them are also values that are functions
15:06:57 <Kyraimion> Not all constructors are functions, so yes.
15:07:05 <incompetentcoder> so constructors acting as values are like symbols?
15:07:09 * nand` reread what hpc said
15:07:27 * hackagebot happstack-hsp 7.1.1 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.1.1 (JeremyShaw)
15:07:33 <nand`> incompetentcoder: functions are values too
15:07:39 <nand`> so, not necessarily
15:08:06 <nand`> ‘symbol’ is reserved terminology for type-level strings now isn't it?
15:08:30 <hpc> i just don't use the word "symbol"
15:08:40 <nand`> well, the kind's Symbol
15:08:54 <hpc> :k "huh?"
15:08:56 <lambdabot> parse error on input `"'
15:08:58 <hpc> :(
15:09:19 <incompetentcoder> for example, data Foo = Foo; is Foo a symbol?
15:09:21 <sipa> some values are functions, some values are constructors; these two sets overlap only partially
15:09:22 <nand`> λ :k "huh?"
15:09:24 <nand`> "huh?" :: GHC.TypeLits.Symbol
15:09:31 <incompetentcoder> ah
15:09:36 <nand`> incompetentcoder: for some value of ‘symbol’; sure -- it's ultimately just a value, a value of type Foo
15:09:39 <Kyraimion> incompetentcoder:  In that case Foo is both a type and a constructor
15:09:53 <Cale> incompetentcoder: Foo will be defined at the type level as a type (constructor), as well as at the value level as a data constructor
15:10:02 <typoclass> manone: at the most practical level, you might want to start your xml parser work by roughly deciding what should come out of it. i bet it's going to be some sort of tree structure that you define using the 'data' keyword. this is described in chapter 8: http://learnyouahaskell.com/making-our-own-types-and-typeclasses
15:10:12 <sipa> incompetentcoder: and neither of both will be a function
15:10:12 <Cale> incompetentcoder: because you named both the type and data constructor the same thing
15:10:16 <mcstar> nand`: i was afk, so, there are no standard-ish maps for C# like in haskell/clojure/scala?
15:10:36 <nand`> there's Dictionary if you promise not to mutate it
15:10:38 <nand`> but that's about it
15:10:40 <nand`> afaik
15:11:39 <manone> typoclass: tx. i looked at that in the learn yours haskell
15:11:54 <manone> but by the chapter 8 i was  already lost in details..
15:11:56 <mcstar> 'persistent' has the connotation of being able to retain the original version while having a new updated one relatively fast
15:12:22 <typoclass> manone: well, feel free to ask in here about those details :)
15:12:25 <manone> but i absolotely loved the book, the guy has an uncanny sense of humor - would love to meet him sometimes
15:12:43 <nand`> I see. Well, I have no idea; if there is a type like that, I've never been exposed to it
15:12:51 <nand`> maybe SO or DDG know more
15:12:58 <nand`> or ##csharp :)
15:13:03 <mcstar> nvm, i just was curious..
15:13:03 <Cale> manone: Are you thinking of *writing* an XML parser, or just using one?
15:13:11 <manone> typoclass: you all seem like a brilliant / v nice group but don't want to abuse your kindness :)
15:13:15 <Cale> manone: Writing an XML parser is no small task.
15:13:43 <Cale> manone: But there are lots of fairly easy to use libraries, as well as some less easy to use ones.
15:13:45 <manone> cale: using one to parse stuff
15:13:48 <Kyraimion> Cale:  That's true indepedently of haskell
15:13:56 <Cale> Kyraimion: absolutely :)
15:14:02 <hpc> @quote xml
15:14:02 <lambdabot> kmc says: SSE9. Where the registers are 1 megabyte long and there's an instruction for PACKED SATURATED DOUBLE-PRECISION PARSE XML AND CONSTRUCT FACEBOOK API QUERY. I believe the mnemonic is
15:14:02 <lambdabot> PSDPPXACFAQ
15:14:04 <manone> but also being able to parse various things
15:14:15 <typoclass> manone: don't worry :) if someone doesn't feel like answering questions, he'll simply not be in here
15:14:23 <Cale> It's probably easier to write an XML parser in Haskell than most languages, just because we have such good general parser combinator libraries.
15:14:40 <hpc> it's also harder, because you are encouraged to stick to the spec :P
15:15:00 <nand`> the hardest language to write an XML parser in is English
15:15:03 <incompetentcoder> :t id
15:15:04 <lambdabot> forall a. a -> a
15:15:09 <incompetentcoder> is there a pointfree way to define id
15:15:25 <manone> nand' : interesting - why ?
15:15:26 <Kyraimion> It's actually a shame that haskell is capable of such a heinous task.
15:15:32 <Cale> incompetentcoder: well...
15:15:34 <typoclass> manone: you've seen the rwh chapter on making a simple but pretty complete csv parser, right? it explains how you can approach parsing stuff in haskell
15:15:37 <hpc> > let id = join const in id 5
15:15:38 <lambdabot>   5
15:15:45 <incompetentcoder> :t join
15:15:46 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
15:15:47 <nand`> manone: it was a joke based on how complex and hard for humans to process XML is
15:15:48 <incompetentcoder> :t const
15:15:49 <lambdabot> forall a b. a -> b -> a
15:15:55 <incompetentcoder> O.o
15:15:55 <cmccann> :t fmap fix return
15:15:57 <lambdabot> forall a. a -> a
15:15:57 <hpc> > const 1 2
15:15:58 <lambdabot>   1
15:16:03 <cmccann> > (fmap fix return) 5
15:16:04 <lambdabot>   5
15:16:06 <hpc> > join (+) 2
15:16:07 <lambdabot>   4
15:16:09 <nand`> of course, ‘const’ and ‘join’ can't be written in a point-free way without id
15:16:17 <manone> nand': :)
15:16:20 <incompetentcoder> lol
15:16:34 <nand`> though if you add primitives like S or K to the language, it would be
15:16:36 <manone> forget about xml - i am looking at parsing random forms of text
15:16:44 <manone> that can be xml or not
15:16:45 <typoclass> nand`: i bet he isn't going for a full xml parser, he'll just start with some simple subset
15:17:05 <incompetentcoder> is there a program that can show me how to point-free-ify a function?
15:17:21 <Cale> > (const <*> const) 5
15:17:21 <Kyraimion> @type ap const const -- incompetentcoder
15:17:22 <nand`> typoclass: I assumed as much; eg. a reasonably simpler “XML-ish” <foo> <bar> </bar> </foo>
15:17:22 <lambdabot> forall b. b -> b
15:17:22 <lambdabot>   5
15:17:26 <hpc> @pl \a b c d -> d c c b a (b a)
15:17:27 * hackagebot happstack-jmacro 7.0.3 - Support for using JMacro with Happstack  http://hackage.haskell.org/package/happstack-jmacro-7.0.3 (JeremyShaw)
15:17:27 <lambdabot> ap (ap . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . (flip =<< flip id)))) (flip id)
15:17:39 <hpc> incompetentcoder: it can generate some horrid output sometimes
15:17:40 <Cale> :t const <*> const
15:17:41 <lambdabot> forall b. b -> b
15:17:59 <incompetentcoder> @pl \n -> (== n)
15:17:59 <lambdabot> (==)
15:18:04 <Cale> dat skk
15:18:06 <hpc> heh, was waiting for someone to suggest SKK
15:18:23 <incompetentcoder> what's SKK?
15:18:33 <ion> Now define const and (<*>) pointlessly.
15:18:38 <nand`> ap const const
15:18:49 <hpc> incompetentcoder: it's a term in the SKI calculus; it's not important
15:18:52 <nand`> (= S K K)
15:18:52 <Cale> incompetentcoder: S and K are combinators in something called the SK (or SKI) calculus
15:19:02 <mcstar> Cale: do you have an idea, how fast the sudoku solvers are from the haskell wiki? which might be the fastest to test against?
15:19:05 <typoclass> manone: have a look at this chapter http://book.realworldhaskell.org/read/using-parsec.html , particularly the part "Extended Example: Full CSV Parser"
15:19:05 <Cale> incompetentcoder: S f g x = f x (g x), and K x y = x
15:19:10 <hpc> K = const, I = id, S = (<*>)
15:19:13 <incompetentcoder> :t liftM2
15:19:14 <nand`> K = const; and S corresponds to the Haskell ‘ap’ (for the function monad)
15:19:15 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:19:26 <incompetentcoder> what does liftM2 do?
15:19:31 <sipa> > :t ap (ap const)
15:19:32 <lambdabot>   <no location info>: parse error on input `:'
15:19:37 <cmccann> I wonder if talking about the SKI basis pings ski's IRC client
15:19:50 <sipa> incompetentcoder: lift an operator on pure values to one one monadic ones
15:19:55 <Cale> incompetentcoder: liftM2 f x y = do u <- x; v <- y; return (f u v)
15:19:55 <hpc> incompetentcoder: the source is perhaps the best answer to that one
15:19:58 <hpc> @src liftM2
15:19:58 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
15:20:11 <hpc> you'll have to mentally format that to be readable
15:20:26 <Cale> > liftM2 (+) [1,2,3] [40,50]
15:20:28 <lambdabot>   [41,51,42,52,43,53]
15:20:29 <incompetentcoder> so sometimes I have to resort to monads to point-free-ify a function?
15:20:43 <nand`> incompetentcoder: not necessarily
15:20:45 <hpc> i wouldn't say you HAVE to
15:20:47 <sipa> so if (+) is Ine -> Int -> Int, then (liftM2 (+)) is m Int -> n Int -> m Int
15:20:47 <hpc> but it can help
15:20:50 <nand`> incompetentcoder: @pl uses some monad functions from time to time
15:20:55 <Cale> incompetentcoder: @pl uses the monad instance for functions
15:20:59 <incompetentcoder> @pl \a b n -> a n || b n
15:20:59 <hpc> :t (+) <=< ?f
15:21:00 <lambdabot> liftM2 (||)
15:21:01 <lambdabot> forall b a. (Num b, ?f::a -> b -> b) => a -> b -> b
15:21:06 <nand`> but you can just as well define the non-monad versions of the same functions yourself, specialized to the function type
15:21:09 <MostAwesomeDude> incompetentcoder: You really shouldn't think about "resorting" for point-free stuff. If something's hard to make point-free, then I wouldn't bother.
15:21:11 <Cale> incompetentcoder: Because it provides a way to duplicate an argument
15:21:13 <hpc> huh
15:21:23 <incompetentcoder> ah
15:21:28 <manone> gentlemen, thanks much for your great input - will follow-up. one last question: if you would pick ONE book for fp and ONE book for haskell to provide a good overview/intro - what would that be ?
15:21:32 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
15:21:34 <lambdabot>   ("hello","olleh","HELLO")
15:21:37 <Cale> ^^ function monad
15:21:41 <Kyraimion> cmccann:  That's like calling yourself SIGSEGV in #C and wondering why you are getting pinged
15:21:48 <hpc> manone: for the latter, definitely LYAH
15:21:54 <hpc> for FP, no idea
15:21:54 <sipa> @where LYAH
15:21:54 <lambdabot> http://www.learnyouahaskell.com/
15:21:58 <hpc> i just kinda picked it up on my own
15:22:12 <Cale> incompetentcoder: "running" a function in a do-block means to apply it to the value to which the whole do-block has been applied
15:22:27 * hackagebot happstack-hstringtemplate 7.0.2 - Support for using HStringTemplate in Happstack  http://hackage.haskell.org/package/happstack-hstringtemplate-7.0.2 (JeremyShaw)
15:22:28 <typoclass> incompetentcoder: i think the ground rule is, a little bit of point-free-ifying is helpful, but often you pretty quickly hit the limit and further point-free-ifying will help you in no way while making the code unreadable
15:22:29 * hackagebot happstack 7.0.1 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-7.0.1 (JeremyShaw)
15:22:34 <manone> hpc: i guess FP as it relates to haskell..
15:22:59 <hpc> for that, LYAH will cover you fairly well
15:23:01 <ion> @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
15:23:02 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
15:23:05 <ion> @type (=<<) `asAppliedTo` (undefined :: a -> b -> c)
15:23:06 <lambdabot> forall a b b1. (a -> b1 -> b) -> (b1 -> a) -> b1 -> b
15:23:15 <nand`>  @pl is not very good at pointfree-ifying
15:23:29 <nand`> a human can come up with much more concise solutions in the most cases
15:23:35 <hpc> you can also loop @pl by passing a poorly-typed term
15:23:37 <typoclass> manone: if you ask me, if it involves closures, it's functional programming *shrug* :-) ...
15:23:39 <ion> @@ @djinn @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
15:23:40 <lambdabot>  f a b c = a c (b c)
15:23:44 <ion> @@ @djinn @type (=<<) `asAppliedTo` (undefined :: a -> b -> c)
15:23:46 <lambdabot>  f a b c = a (b c) c
15:24:42 <incompetentcoder> so I should prefer `\a b n -> a n && (not . b) n` over \
15:24:53 <hpc> incompetentcoder: probably
15:24:53 <manone> tx all: so if i understand well what you recommend here is to read lyah again (:-) and not bother much with fp?
15:24:54 <incompetentcoder> over \_ -> (. (not .)) . liftM2 (&&)
15:25:03 <nand`> surely, I would write that as \a b n -> a n && not (b n)
15:25:04 <ion> incompetentcoder: Certainly.
15:25:12 <ion> incompetentcoder: The latter is almost unreadable.
15:25:12 <nand`> the latter is just line noise
15:25:30 <incompetentcoder> obfuscated Haskell ftw ^^
15:25:44 <nand`> @unpl \_ -> (. (not .)) . liftM2 (&&)
15:25:45 <lambdabot> \ _ j m -> j >>= \ d -> (\ p -> not (m p)) >>= \ c -> return (d && c)
15:25:46 <typoclass> manone: yeah i think once you've started writing haskell, you've started being a functional programmer
15:25:49 <nand`> there you go
15:25:51 <ion> Only use pointless code when if actually makes it *better* for humans.
15:26:21 <hpc> don't obsess over when to pointfree something
15:26:29 <hpc> it's only really worth it in the "obvious" cases
15:26:35 * nand` wants generalized boolean algebras and a function instance for them :(
15:26:47 <Kyraimion> hpc:  Where you want to impress #haskell
15:26:58 <rwbarton> something like the little mler would be a good read
15:26:59 <nand`> foo && bar => liftM2 (&&) foo bar
15:27:07 <hpc> and making it pointfree is really a side-benefit to having a nicer formulation of the function in general
15:27:13 <hpc> like
15:27:27 * hackagebot web-routes-happstack 0.23.4 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.23.4 (JeremyShaw)
15:27:29 * hackagebot web-routes 0.27.2 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.27.2 (JeremyShaw)
15:27:33 <hpc> foo x = f (g (h x)) -- i would refactor this
15:27:42 <hpc> foo x = f . g . h $ x -- this is fine
15:28:07 <ion> or (f . g . h) x
15:28:09 <Kyraimion> Why not f . g $ h x ? One operator less
15:28:11 <hpc> foo = f . g . h -- not overwhelmingly better than #2, but nice to do because it's already almost there
15:28:13 <nand`> I try to eta reduce wherever possible
15:28:29 <nand`> because it makes definitions read more like statements about the functions themselves
15:28:31 <Cale> Kyraimion: more composition is in some ways better :)
15:28:41 <incompetentcoder> http://ideone.com/kIzuu why won't this compile? :(
15:28:45 <Cale> Kyraimion: g . h is meaningful, g $ h is not
15:28:49 <hpc> Kyraimion: counting operators doesn't matter so much as "telling a story", so to speak
15:29:02 <hpc> "compose these three functions, apply to x"
15:29:13 <hpc> vs "compose these two functions, apply to (h x)"
15:29:24 <Cale> When you present things as a composition of functions, there are more ways to visually break it down into smaller parts
15:29:31 <osfameron> why is g $ h not meaningful?
15:29:34 <Cale> (or textually, if you're editing the code)
15:29:40 <MostAwesomeDude> incompetentcoder: You'll need to grab that instance from e.g. Control.Monad.Instances.
15:29:40 <incompetentcoder> $ is ugly
15:29:44 <Cale> osfameron: Well, in that case, it will probably not typecheck
15:29:51 <ion> incompetentcoder: Import Control.Monad.Instances, but you’ll also get it by importing Control.Applicative.
15:29:52 * cmccann sometimes writes stuff like (f . g $ h x) if h is conceptually more relevant to x than (f . g)
15:29:54 <Cale> unless g is very polymorphic
15:30:13 <osfameron> oh, in context.
15:30:45 * nand` tends to avoid the . . . . . $ style
15:30:49 <nand`> I just don't like it
15:31:03 <Cale> nand`: just use parens?
15:31:14 <nand`> that'd be even worse
15:31:30 <shachaf> cmccann: Isn't it great when you write a long composition and then end it with something like ()?
15:31:49 <nand`> if a function contains more than one set of parens, or begins nesting them whatsoever, it hovers dangerously close to refactoring for me
15:31:53 <Cale> nand`: Or you mean you extract that function into a new definition and apply it all at once?
15:31:57 <typoclass> shachaf: quite a few beethoven symphonies end with ()
15:32:02 <osfameron> the a . b . c . d . e . f . g . h $ i  thing is ok
15:32:12 <osfameron> e.g. a single $
15:32:24 <hpc> shachaf: i use (ContT ()) quite often
15:32:30 <osfameron> otherwise I'd really rather use parens
15:32:42 <nand`> Cale: Well, it depends from case to case - but I just noticed that I generally don't run into that pattern
15:32:43 <shachaf> hpc: I prefer ContT Void
15:32:44 <cmccann> () is the best value
15:32:49 <hpc> which tends to result in calling lots of (k ())
15:32:49 <nand`> I probably don't write enough Haskell
15:32:52 <ion> I only tend to use $ if the “i” is on another line, e.g.
15:32:56 <ion> foo = a . b . c …
15:33:02 <lispy> > pred ()
15:33:03 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
15:33:03 <ion>     $ bar
15:33:24 <ion> On any single line expression (a . b . c …) x seems more clear when skimming the code to me.
15:33:27 <cmccann> lispy, that has to be one of the stupidest instances in the standard libraries
15:33:35 <lispy> cmccann: yup
15:33:42 <lispy> cmccann: but I think Enum is broken in general too
15:33:47 <cmccann> yes, it is
15:33:48 <lispy> cmccann: too much Int
15:33:49 <osfameron> what is pred () ?
15:33:55 <lispy> > pred 1
15:33:56 <lambdabot>   0
15:34:07 <nand`> Enum is fairly arbitrary, especially in combination with Bounded
15:34:11 <Kyraimion> > [minBound .. maxBound] :: [()]
15:34:12 <lambdabot>   [()]
15:34:22 <osfameron> > pred ()
15:34:23 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
15:34:24 <rwbarton> and then there's also Ix which duplicates some of Enum
15:34:28 <nand`> osfameron: the predecessor of () in the enumeration of units
15:34:29 <lispy> > pred minBound
15:34:30 <lambdabot>   *Exception: Prelude.Enum.().pred: bad argument
15:34:38 <lispy> > pred (minBound :: Int)
15:34:38 <osfameron> I get that exception too
15:34:39 <lambdabot>   *Exception: Prelude.Enum.pred{Int}: tried to take `pred' of minBound
15:35:09 <lispy> cmccann: I dislike having partial functions in the Prelude
15:35:12 <shachaf> > (subtract 1) (minBound :: Int)
15:35:14 <lambdabot>   9223372036854775807
15:35:16 <shachaf> :-(
15:35:20 <rwbarton> pred () should definitely be _|_
15:35:21 <lispy> cmccann: head :: [a] -> Maybe a, would have been nice
15:35:32 <hpc> > floor (0/0) :: Integer
15:35:33 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
15:35:47 <shachaf> At least we can all be glad that pred 0 isn't 1.
15:35:49 <shachaf> That would succ.
15:35:54 <osfameron> hahaha
15:36:09 <osfameron> lispy: that'd be inconvenient for many simple things though
15:36:17 <manone> tx gentlemen, typoclass, nand', cale, hpc, kraimion.. you are great, will ping you again next week once i'm done re-reading lyah.. have a great weekend - and let me know if/when any of you are in n-california/bay area - i won't be lazy to deliver a couple of beers :)
15:36:19 <cmccann> lispy, well, the prelude replacement I use defines head that way...
15:36:33 <nand`> pred 0 :: Word1
15:36:36 <lispy> osfameron: debugging head [] in a large program is far more inconvient :)
15:36:53 <rwbarton> ugh
15:36:57 <typoclass> manone: appreciated :) you're welcome
15:37:03 <cmccann> some partial functions are a hassle to avoid
15:37:12 <osfameron> fair enough... I've not really debugged large production codebases in haskell ;-)
15:37:23 <cmccann> from personal experience, making cycle total is a terrible idea
15:37:27 * hackagebot web-routes-wai 0.22.2 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.22.2 (JeremyShaw)
15:37:29 <manone> ps. rwbarton : apologies - miss u on that list -please b my guest too
15:37:29 <nand`> ‘error’ makes debugging a pain in general, imo
15:37:36 <typoclass> the whole thing would be much better if ghc could output the filename and line number where and exception occurred
15:37:39 <lispy> ?src cycle
15:37:40 <lambdabot> cycle [] = undefined
15:37:40 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
15:37:48 <typoclass> s/and/an
15:38:04 <osfameron> given I mostly write live code in dynamic languages, it seems a bit "the lady doth protest too much" though ;-)
15:38:11 <lispy> cmccann: because you'd want to define it for a NonEmptyList type?
15:38:36 <cmccann> lispy, you kinda want cycle applied to a list literal to work, is the thing
15:38:38 <Kyraimion> typoclass:  So what would it give you to know that head resides in Data.List, since that's where the error occurred?
15:38:39 <nand`> I think it would be better for functions that call ‘error’ (directly or by proxy) to be marked as ‘errors’ by the compiler, which can then insert some sort of compile-time meta-information about each use of such a function, so you can trace back where and when the usage was
15:38:49 <nand`> eg. in which line of code
15:39:03 <hpc> nand`: that'd be an awesome bit of compiler magic
15:39:36 <mhr> I'm trying to grok this code, and >> wasn't in the readme, so I have no idea if this is Sirea code or Haskell code.  https://github.com/dmbarbour/Sirea, https://github.com/dmbarbour/Sirea/blob/master/tst/Hello.hs.  Any help?  I tried googling "haskell >>", but google doesn't recognize >>
15:39:37 <typoclass> Kyraimion: right, but i meant the call site obviously :) but in general you're right, a javaish full stack trace is what you'd really need
15:39:38 <cmccann> nand`, http://hackage.haskell.org/package/placeholders ?
15:39:39 <rwbarton> yeah, for example you could even replace 'cycle' with some TH thing that expanded to "\xs -> let Just y = safeCycle xs in y"
15:39:46 <rwbarton> then get a better error message
15:39:54 <lispy> :t (>>)
15:39:55 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
15:39:57 <lispy> mhr: ^^
15:40:04 <rwbarton> actually doing this seems sort of dumb, there must be a better way to get the same effect
15:40:06 <Kyraimion> typoclass:  I think ghc actually has call backtraces now
15:40:15 <hpc> mhr: use hoogle
15:40:17 <hpc> @where hoogle
15:40:17 <lambdabot> http://haskell.org/hoogle
15:40:34 <hpc> it's the single greatest language tool i have ever used :P
15:40:35 <ion> Wasn’t GHC going to get holes at some point?
15:40:43 <shachaf> ion: It has "holes" of some form in HEAD.
15:40:44 <typoclass> Kyraimion: right. i think it was new in 7.4. but afaik it requires the program and all dependencies to be rebuilt with profiling enabled
15:40:46 <hpc> ion: it got deferred type errors
15:40:48 <hpc> iirc
15:40:48 <cmccann> anyway, having replaced "cycle" with a version that returns maybe in my prelude replacement has made it nearly useless in practice
15:40:58 <rwbarton> yes
15:41:02 <rwbarton> partial functions are good
15:41:04 <rwbarton> using them wrong is bad
15:41:11 <rwbarton> not being able to find where you are using them wrong is unfortunate
15:41:11 <merijn> hpc: Holes and deferred type errors are rather different...
15:41:12 <typoclass> hpc: which is the greatest tool? hoogle?
15:41:23 <hpc> hoogle
15:41:24 <rwbarton> the last one is the real problem
15:41:41 <nand`> cmccann: well, I meant for “production errors”, the sort you have on eg. cycle []; things that are not worth the hassle wrapping around in Maybe or similar or which are provided for convenience only
15:41:51 <nand`> not sure if holes were meant for that purpose
15:41:55 <nand`> or whether they fill it well
15:42:27 * hackagebot reform-happstack 0.1.2 - Happstack support for reform.  http://hackage.haskell.org/package/reform-happstack-0.1.2 (JeremyShaw)
15:42:29 <cmccann> nand`, the package I linked to is something different from holes
15:42:29 * hackagebot happstack-foundation 0.2.3 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.2.3 (JeremyShaw)
15:43:02 <cmccann> but it obviously doesn't help with code that doesn't use it
15:43:05 <nand`> cmccann: I see now, it's just a pretty wrapper for ‘error’?
15:43:17 <cmccann> it's TH splices that are "error with more info"
15:43:35 <cmccann> and optional compiler warnings
15:43:45 <merijn> If I want to selectively broadcast to multiple channels based on a sort of "notification subscription" the only way to really do it is to have one channel per thread per relevant notification, I guess?
15:43:56 <typoclass> cmccann: i think the compiler warnings are really the goal of the thing
15:44:11 <nand`> it still doesn't carry any usage information though, does it? eg. if I have ‘someFunctionThatFails a’ and ‘someOtherFunctionThatFails b’ and I don't know which one is forced first; and both of them call the same ‘failingFunction c’; I can only know that failingFunction is the source of the error; not which of those two calls led to it
15:44:24 <cmccann> yeah, it's pretty limited
15:44:30 <mhr> (I'm new to haskell) (Monad m) => m a -> m b -> m b - what does that mean?  I know what a monad is, but I don't know what it's saying with the ->
15:44:40 <cmccann> strictly superior to just using undefined or (error "oh noes!")
15:44:59 <cmccann> but otherwise not doing much
15:45:02 <merijn> mhr: "For ever possible monad m, this is a function taking an "m a" and an "m b" and returning an "m b"
15:45:08 <nand`> which sort of defeats the purpose of what I proposed; to go from ‘Prelude.head: empty list’ to ‘Prelude.head: empty list <: Foo.hs:20: ‘head xs’’
15:45:12 <ion> mhr: It’s a function of type e.g. IO a -> IO b -> IO b, [a] -> [b] -> [b] or Maybe a -> Maybe b -> Maybe b.
15:45:32 <lispy> mroman: well, the identity function has type a -> a, meaning it takes something and returns it
15:45:41 <nand`> fundamentally, every failing function could accept an extra String for the ‘location information’
15:45:55 <mhr> merijn: so print "1" >> print "2" returns print "2"?
15:46:02 <cmccann> nand`, yeah, just thought it was worth mentioning
15:46:05 <nand`> indeed
15:46:08 * nand` will sleep now
15:46:12 <typoclass> nand`: no, i think the "Foo.hs:20" information is a step in the right direction. there might be more steps needed in practice (= stacktraces), but still
15:46:20 <lispy> > Just 1 >> Just 2
15:46:21 <lambdabot>   Just 2
15:46:22 <shachaf> mhr: No, it returns neither.
15:46:33 <hpc> mhr: it returns "print 1, then print 2"
15:46:46 <shachaf> hpc: I'd rather say it *is* that. :-)
15:46:56 <hpc> er, "then return the result of print 2, which is ()"
15:47:08 <hpc> just for thoroughness
15:47:19 <typoclass> merijn: so you have one sender thread that knows what receivers are subscribed to what notifications, and knows all the channels?
15:47:22 <nand`> typoclass: that's what I'm saying; usage information is needed if you call ‘head’ a thousand times in your code
15:47:23 <shachaf> "yield" the result of «print "2"», maybe.
15:47:26 * cmccann ponders whether an Enum instance for Void would be more or less sensible than the one for ()
15:47:33 <hpc> yield might be better, yeah
15:47:39 <rwbarton> equally sensible I think
15:47:41 <cmccann> because in a sense it would have fewer ways to produce new errors
15:47:41 <shachaf> cmccann: Seems sensible to me.
15:47:41 <dada-cetacean> I'm getting an error with cabal where the command prompt just opens and closes, am I missing some sort of file from my installation?
15:47:54 <cmccann> toEnum would be bad of course
15:47:54 <lispy> cmccann: given my grumpiness I don't know if any Enum instance can be sensible :)
15:48:03 <ion> mhr: print "1" >> print "2" combines them into an action that upon execution prints both. Generally, (a >> b) has the side effects (what that is depends on the monad) of both but throws away the result value of a.
15:48:05 <rwbarton> well there is that
15:48:09 <lispy> dada-cetacean: on windows?
15:48:21 <dada-cetacean> yeah, windows 7 :x
15:48:21 <cmccann> but unlike (succ ()), you'd only get an error from succ/pred for Void if you already have a bottom value
15:48:24 <nand`> fromEnum = const error; toEnum = void; succ = pred = id -- what could possibly go wrong?
15:48:38 <lispy> dada-cetacean: You need to use a command shell like cmd.exe
15:48:57 <shachaf> Man, remember when command shells in Windows were called COMMAND.COM?
15:48:57 <nand`> flip fromEnum/toEnum
15:48:59 <shachaf> Those were the ays.
15:49:01 <cmccann> nand`, well, fewer things than can go wrong with the instance for (), is my point
15:49:08 <lispy> dada-cetacean: I use the shell provided by my git install, FWIW
15:50:05 <lispy> dada-cetacean: I have pagent installed and hooked up to it as well so that I can use github from the command line. Configuring all that was a pain though.
15:50:40 <cmccann> command shell on windows? that's part of cygwin or something, isn't it?
15:50:51 <cmccann> because I'm pretty sure windows doesn't come with anything I would call a command shell built in
15:51:09 <mhr> So it returns the second statement but also does both statement's side effects. On the hello world link I pasted, print "before hw app (ctrl+c to halt)" >>     runSireaApp bHelloWorld  >>     print "after hw app".  With three params (or is that haskell works?), what does this statement mean if >> takes in two?
15:51:10 <hpc> cmd.exe is a fairly crap shell
15:51:17 <hpc> and i think some versions come with powershell
15:51:31 <cmccann> powershell is really not that much better
15:51:33 <lispy> but powershell costs like $30
15:51:39 <cmccann> well, maybe it is
15:51:46 <lispy> I tried some Console2 or something but I couldn't stand it.
15:51:47 <cmccann> but that's still not more better-er enough
15:52:01 <cmccann> Console2 is one of the best options
15:52:02 <cmccann> sadly
15:52:04 <lispy> The Bash that came with my git install is really the best I've found and it's dreadful
15:52:15 <rwbarton> mhr: x >> y >> z is (x >> y) >> z
15:52:21 <rwbarton> or possibly the reverse, but I'm pretty sure it's that one
15:52:25 <lispy> It's at least bash, but the terminal emulation part is gross
15:52:28 <hpc> rwbarton: it's neither
15:52:29 <cmccann> I think mintty is the one I found most tolerable
15:52:37 <rwbarton> wat
15:52:37 <hpc> or both
15:52:39 <mhr> rwbarton: ah, it all makes sense :)
15:52:53 <hpc> the monad laws say both are equal
15:53:04 <rwbarton> well sure but haskell doesn't know anything about the monad laws
15:53:30 <mhr> what?
15:53:33 <lispy> rwbarton: it does when desugaring
15:53:38 <rwbarton> ...
15:53:38 <lispy> rwbarton: they are assumed
15:53:41 <cmccann> yes, but we generally expect monad instances to behave according to those laws
15:53:41 * rwbarton stops answering questions
15:53:55 <cmccann> unlike certain other type classes
15:54:06 <lispy> rwbarton: Welll, I get your point. There is no proof given for the instances and it doesn't explicitly use it.
15:54:08 <cmccann> or instances for certain allegedly numeric types
15:54:14 <hpc> as far as the programmer should be concerned, the associativity of (>>) can change at any time, whenever it wants
15:54:21 <shachaf> rwbarton: http://www.haskell.org/onlinereport/haskell2010/haskellch13.html#dx21-194004
15:54:31 <shachaf> "Haskell" certainly "knows" about the monad laws!
15:54:40 <lispy> rwbarton: But, as I understand it, translating from do-notation to (>>=) assumes a monad that plays by the laws
15:54:53 <rwbarton> what did I do to deserve this
15:55:03 <shachaf> Sorry. :-(
15:55:08 <hpc> rwbarton: you were wrong at a time when a lot of people are active ;)
15:55:13 <rwbarton> lol
15:55:14 <hpc> happens all the time
15:55:26 * shachaf didn't see rwbarton being wrong.
15:55:35 <cmccann> a lot of pedantic people who enjoy arguing on IRC, specifically
15:55:53 <lispy> rwbarton: :)
15:55:59 <cmccann> (but that's the norm around here)
15:56:08 <mhr> hpc: then a >> b >> c means...what?  if the associativity of >> is arbitrary...?  I'm so confused
15:56:15 <lispy> rwbarton: Stop saying you that we're correcting you, because we're not ;)
15:56:21 <Kyraimion> lispy:  How can windows users live without a (proper) shell?
15:56:26 <shachaf> mhr: The Haskell report specifies that a >> b >> c means (a >> b) >> c
15:56:42 <shachaf> mhr: It *also* specifies that that *should* be equivalent to a >> (b >> c), but that's not how it evaluates.
15:56:44 <hpc> mhr: it's the same as (5 + 2 + 1)
15:56:45 <ion> mhr: “(print foo, then print bar), then print baz” is the same thing as “print foo, then (print bar, then print baz)”.
15:56:58 <hpc> mhr: you don't know if it's ((5 + 2) + 1) or the other way around
15:57:10 <shachaf> I,I {-# RULES "fix >>" (>>) ((>>) b c) = (>>) a ((>>) b c) #-}
15:57:12 <lispy> Kyraimion: I'm not sure but I think it had to do with the rise of the IDE. Without an encompassing environment to compose commands you kind of need a specialized editing environment.
15:57:16 <hpc> but you still know it's going to be 7 -- your compiler is bad at math
15:57:26 <ion> shachaf: ಠ_ಠ
15:57:39 <mhr> I'll assume it means (a >> b) >> c then
15:57:44 <shachaf> ion: °͜°
15:58:00 <S11001001> @info (>>)
15:58:00 <lambdabot> (>>)
15:58:07 <cmccann> is it unicode o' clock again?
15:58:07 <S11001001> thanks lambdabot
15:58:12 <lispy> Kyraimion: On windows I just use the git bash shell to do really basic stuff like changing to a directory and running make/cabal
15:58:17 <typoclass> mhr: a >> b >> c means all three actions are run, the first two results are ignored, and the third action's result is yielded
15:58:33 <lispy> Kyraimion: on OSX/Linux I'm all about the shell though.
15:58:54 <Kyraimion> lispy:  Yeah, with enough colourful buttons you can kind of paper over the lack of a command line in special cases (like an IDE), but I mean in general, day-to-day computer use?
15:58:56 <mhr> okay, so if I had a >> b >> c >> d, then the first three results are ignored, all four actions are run, and the third action's result is yielded, and so on?
15:58:59 <shachaf> cmccann: Every o'clock is Unicode o'clock in #haskell-blah!
15:59:05 <incompetentcoder> http://ideone.com/c4XLT3 any style comments on my code?
15:59:11 <mhr> *fourth's
15:59:16 <lispy> Kyraimion: But, I mostly just do the windows Haskell stuff to make sure packages build there. The actual development happens on osx.
15:59:21 <cmccann> don't make me start talking in fraktur again
15:59:38 <typoclass> mhr: yup :) that's right
15:59:50 <typoclass> mhr: it's always the rightmost result
16:00:12 <ion> 𝕻𝖗𝖔𝖇𝖑𝖊𝖒?
16:00:17 <ion> https://gist.github.com/3909452#file_styles.hs
16:00:37 <john_r_watson> @pl (\(x,y) -> ((a:x),(a:y)))
16:00:37 <lambdabot> (a :) *** (a :)
16:00:50 <john_r_watson> Isn't there a way to do better than that?
16:01:04 <mhr> In the link I posted, why did he use >>, anyway?  why not just execute all three, why does he want to return print "after hw app"?
16:01:07 <john_r_watson> (a:) {some fancy operator}
16:01:08 <cmccann> ion, that's much fancier than mine
16:01:27 <lispy> Kyraimion: I've even thought of installing a VM on windows and sharing the filesystem with a linux VM instance so I can just do the cabal command on windows and the editing on linux.
16:01:30 <john_r_watson> :t (&&&)
16:01:31 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:01:31 <shachaf> john_r_watson_: over both (a:)
16:01:33 <lispy> Kyraimion: I haven't gotten that desparate yet
16:01:39 <shachaf> john_r_watson: (After importing Control.Lens.)
16:01:44 <cmccann> ion, are you using the bold fraktur there?
16:01:48 <ion> yeah
16:02:04 <incompetentcoder> @pl \n g -> M.map ((/ fromIntegral n) . (* 100)) (M.fromListWith (+) [(h, 1) | h <- g])
16:02:04 <lambdabot> (. (M.fromListWith (+) . return . (((h, 1) | h) <-))) . M.map . (. (100 *)) . flip (/) . fromIntegral
16:02:05 <typoclass> john_r_watson: i have a function "both f (a,b) = (f a, f b)" defined, so you can do "both (a:) (x,y)"
16:02:09 <john_r_watson> shachaf: I was just reading about Control.Lens - I started picking my brain off the ceiling shortly thereafter
16:02:21 <shachaf> typoclass: edwardk's both is much more general!
16:02:31 <ion> λ> :t over both
16:02:33 <ion> over both :: (c -> d) -> (c, c) -> (d, d)
16:02:35 <S11001001> john_r_watson: if a is polymorphic, then you can't throw out either (a:)
16:02:55 <Kyraimion> lispy:  I wonder how well eshell works on windows. I guess you could survive by just never leaving emacs.
16:03:05 <shachaf> I wonder whether "over both" is how you're actually supposed to do it?
16:03:21 <incompetentcoder> @pl \a -> putStr a >> hFlush stdout >> readLn
16:03:21 <lambdabot> (>> readLn) . (>> hFlush stdout) . putStr
16:03:24 <S11001001> > (1:) *** (1:) $ ([1],[3.5])
16:03:25 <typoclass> shachaf: my 'both' has an implementation like 8 bytes long, and doesn't need 168 dependencies ;)
16:03:26 <lambdabot>   ([1,1],[1.0,3.5])
16:03:50 <shachaf> typoclass: His "both" is only slightly longer than yours, and more composable!
16:04:14 <typoclass> shachaf: seriously, if you're using the lens stuff anyway, sure, go for it. but just for this single thing it seems a bit overblown to pull in the lens library
16:04:33 <shachaf> typoclass: Well, you have to start somewhere. :-)
16:04:35 <typoclass> shachaf: oh yeah, "slightly longer" in the sense that it needs 6000 lines of imports :)
16:04:42 <shachaf> typoclass: No imports needed!
16:05:07 <typoclass> shachaf: what, he put all of his library in one file?
16:05:24 <mhr> if haskell is inferred, why is :: all over the place?
16:05:27 <shachaf> typoclass: both f (x,y) = (,) <$> f x <*> f y
16:05:42 <hpc> mhr: GHC cannot yet beam the types directly to your brain
16:05:45 <hpc> it's a known issue
16:05:51 <mhr> haha
16:06:08 <mhr> so it's for the programmer?
16:06:14 <hpc> essentially, yes
16:06:14 <ion> mhr: For humans as useful documentation, and for verification that what you think the type should be is what it actually is.
16:06:19 <shachaf> @quote rwbarton infer
16:06:19 <lambdabot> rwbarton says: type inference is supposed to be the compiler's job, not the reader's job
16:06:29 <mhr> ah
16:06:29 <hpc> it's roughly on the level of "the code's right there, what's with all these comments?"
16:06:30 <Kyraimion> mhr:  Some of the fancier types can't be inferred
16:06:42 <typoclass> mhr: the loose convention is that for top-level things you write down the function type. it's orientation for the programmers, it's documentation, it's a double-check that ghc verifies
16:07:10 <cmccann> also, they improve error messages
16:07:28 <cmccann> since you get "this isn't what you said" instead of "hey these two silly types I inferred don't match"
16:09:21 <typoclass> yeah, it narrows down where the ultimate cause of the error is
16:11:21 <incompetentcoder> how do I put a do block in one line?
16:11:32 <incompetentcoder> without layout?
16:11:58 <typoclass> incompetentcoder: "do { a ; b ; c }", or less directly "a >> b >> c"
16:12:23 <incompetentcoder> right
16:12:50 <shachaf> Note that do { a; b; c } is a >> (b >> c)
16:13:42 <Jetbeard> shachaf, presumably (>>) is associative and thus parens don't matter?
16:13:53 <ciaranm> if >> isn't associative then someone should be testicle-punched
16:14:00 <shachaf> Jetbeard: We were just over this.
16:14:29 <shachaf> Jetbeard: (++) is also associative, but you still prefer "a ++ (b ++ c)" to "(a ++ b) ++ c"
16:14:47 <Jetbeard> ah yes, I understand
16:15:38 <shachaf> It's nice how you can take any argument about monoids and turn it into an argument about monads by using Writer. :-)
16:15:46 <Jetbeard> though when I say "parens don't matter", I loosely mean "the compiler will do what I mean when I leave out the parens", and in both of those cases I mean for the compiler to infer the preferable associativity
16:15:55 <shachaf> Writer w's three monad laws correspond directly to w's three monoid laws.
16:16:15 <shachaf> (>>)'s associativity is not the preferable one.
16:16:40 <Jetbeard> Oh, it's not? Is there any reason why that is?
16:17:13 <shachaf> I'm not sure.
16:17:20 <shachaf> I guess some people's preferences aren't the same as mine.
16:17:28 * hackagebot morfeusz 0.4.2 - Bindings to the morphological analyser Morfeusz  http://hackage.haskell.org/package/morfeusz-0.4.2 (JakubWaszczuk)
16:19:18 <S11001001> I vote for binary associativity: a >> b >> c >> d >> e >> f = ((a >> b) >> (c >> d)) >> (e >> f)
16:19:19 <mhr> y'all confuse me
16:20:13 <ciaranm> a confusion is just the categorical dual of a fusion, which is just a fusoid in the category of brainofunctors
16:20:51 <Jetbeard> ciaranm i'm sewing as well as irc'ing and you just caused me to stab myself due to laughter :(
16:21:21 <typoclass> ciaranm: i hear edwardk is working on it and will upload all that to hackage over the weekend
16:21:23 <typoclass> @remember ciaranm a confusion is just the categorical dual of a fusion, which is just a fusoid in the category of brainofunctors
16:21:24 <lambdabot> It is stored.
16:24:49 <incompetentcoder> @thx
16:24:49 <lambdabot> you are welcome
16:42:28 * hackagebot type-unary 0.2.2 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.2 (ConalElliott)
16:46:48 <typoclass> ^^ anyone have experience with that? i do wish there was a casual way of saying "list that can't be empty"
16:47:30 * hackagebot happstack-yui 7373.5.2 - Utilities for using YUI3 with Happstack.  http://hackage.haskell.org/package/happstack-yui-7373.5.2 (DagOdenhall)
16:52:16 <sshack> Hi, is there a PDF report generating package for Haskell? I'm thinking of something comparable to reportlab in python
16:52:29 * hackagebot type-unary 0.2.3 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.3 (ConalElliott)
16:53:47 <alpounet> sshack, you have this to generate PDF files: http://www.haskell.org/haskellwiki/Cookbook/PDF_files but then you're on your own
16:54:36 <sshack> alpounet: Okay thanks. Very low level.
16:54:55 <alpounet> sshack, i've never heard of any higher-level wrapper around it
16:55:19 <sshack> Well at least I know what the state of the art is, and where it's at.
16:55:27 <typoclass> sshack: might be a wild idea, but you could generate html (there's several libraries for that) and convert it
16:56:02 <sshack> typoclass: It's possible yes. In this case, layout has a major effect on the impact though.
16:56:13 <sshack> I'll certainly have a look though.
17:02:24 <lpvb> Do my haskell programs automatically run on multiple cores without runtime settings if I use parallel functions?
17:03:08 <lpvb> & are there supposed to be special compiler options to specify the program is multi-threaded?
17:07:54 <magicman> @djinn (a -> b) -> Not b -> Not a
17:07:55 <lambdabot> f a b c = b (a c)
17:08:04 <magicman> @djinn (Not a -> Not b) -> b -> a
17:08:04 <lambdabot> -- f cannot be realized.
17:08:08 <Cale> lpvb: Compile with -threaded and run with +RTS -n
17:08:15 <magicman> @djinn (Not a -> Not b) -> b -> Not (Not a)
17:08:16 <lambdabot> f a b c = void (a c b)
17:08:18 <shachaf> -N
17:08:28 <Cale> lpvb: er, yes, -N
17:08:40 <shachaf> -ℕ
17:08:42 <Cale> -N<n> where <n> is the number of cores
17:08:54 <magicman> @type void
17:08:55 <lambdabot> Not in scope: `void'
17:09:19 <Cale> magicman: void :: a -> Void
17:09:24 <Cale> errr
17:09:28 <Cale> Void -> a
17:09:45 <Cale> (yes, that way :)
17:09:46 <magicman> Ahh, I see.
17:10:28 <shachaf> void :: exists a. a -> Void
17:10:47 <Cale> hmm
17:12:34 <ion> > void [0..]
17:12:35 <lambdabot>   Not in scope: `void'
17:12:39 <ion> aww
17:15:32 <parcs`> > (() <$) [0..]
17:15:34 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
17:15:53 <shachaf> > 0<$>[0..]
17:15:55 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
17:16:00 <glguy> > [(),()..]
17:16:01 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
17:16:08 <parcs`> > 0.[0..]
17:16:11 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
17:16:22 <MostAwesomeDude> ['a'..]
17:16:26 <MostAwesomeDude> > ['a'..]
17:16:27 <monochrom> w00t, new haskell platform version soon
17:16:27 <lambdabot>   "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
17:16:34 <shachaf> monochrom: With 7.6?
17:16:47 <monochrom> I don't know yet
17:16:59 <shachaf> monochrom: 2014 is not "soon". :-)
17:17:04 <monochrom> haha
17:17:20 * nejucomo fails to mentally parse 0.[0..]
17:17:21 <ousado> depends on the project.
17:17:26 <nejucomo> :t 0.[0..]
17:17:28 <lambdabot> forall b. (Num b) => [b]
17:17:43 <nejucomo> @type 0.[0..]
17:17:45 <lambdabot> forall b. (Num b) => [b]
17:17:45 <typoclass> > 0 . "abc"
17:17:47 <lambdabot>   [0,0,0]
17:17:56 <nejucomo> @type 0
17:17:58 <lambdabot> forall t. (Num t) => t
17:18:08 <typoclass> nejucomo: it's lambdabot's funky Num instances
17:18:09 <nejucomo> @type (0 .)
17:18:11 <lambdabot> forall a b (f :: * -> *). (Num b, Functor f) => f a -> f b
17:18:22 <parcs`> nejucomo: 0.[0..] = fmap (const 0) [0..] = map (const 0) [0..]
17:18:40 <nejucomo> Ah.  Great way to confuse newcomers about the base language.  :-/
17:18:54 <parcs`> s/confuse/intrigue
17:18:55 <shachaf> nejucomo: Yep. :-(
17:19:00 <nejucomo> Can channel members define types and instances in lambdabot?
17:19:01 <shachaf> Cale: Get rid of it!
17:19:01 <magicman> Ooh, combined with lambdabot's funky (.). Awesome >_<
17:19:04 <shachaf> nejucomo: No.
17:19:33 <nejucomo> Or just rename it to "nonstd_haskell_bot" or something.
17:20:07 <nejucomo> I like the idea of having experimental code to publicly play with, the only thing I dislike is the potential confusion.
17:20:24 <shachaf> lambdabot should let people define types.
17:20:32 <nejucomo> That would be fun.
17:20:33 <shachaf> And newtypes! With GeneralizedNewtypeDeriving!
17:20:52 <nejucomo> I was just imagining a bot that gives each username a separate namespace.
17:21:07 <shachaf> (GeneralizedNewtypeDeriving breaks the type system.)
17:21:34 <nejucomo> shachaf: Really?  That surprises me.  How?
17:21:51 <nejucomo> Maybe I should rtf-wiki instead of assuming I understand what it is by name.
17:22:01 <shachaf> @google generalizednewtypederiving unsafeCoerce
17:22:02 <lambdabot> http://joyoftypes.blogspot.com/2012/08/generalizednewtypederiving-is.html
17:22:11 <Cale> If you write a bot which gives everyone their own namespace, I will run it :)
17:22:22 <sclv> breaks the type system *in combination* with equality constraints
17:22:49 <sclv> or more precisely allows the abuse of equality constraints to break the type system.
17:23:33 <sclv> i'm nitpicky on this because i think it is ridiculous to avoid this useful extension because you can deliberately break it (until the next compiler release or so)
17:23:48 <nejucomo> shachaf: I haven't read that blog yet, but I'd put my money on this alternate assertion: unsafeCoerce breaks the type system.
17:24:15 <shachaf> nejucomo: That post is *implementing* unsafeCoerce using GeneralizedNewtypeDeriving and type families or GADTs.
17:24:29 <nejucomo> oh, hehe... awesome.
17:24:59 <shachaf> sclv: Well, if lambdabot allowed people to define arbitrary types and had GeneralizedNewtypeDeriving, it would be unsafe.
17:25:11 <shachaf> Arbitrary GADTs, at least. :-)
17:25:31 <shachaf> I agree that it's a useful extension, and I'll be happy to see it made useful and safe. :-)
17:26:02 <Cale> This code is super-cute
17:26:04 <Cale> crash :: segfault
17:26:19 <Cale> unsafeCoerce = coerce . IS_NO_LONGER . SAFE
17:26:36 <sclv> shachaf: that's why generalized newtype deriving is banned from safe-haskell :-)
17:26:37 <magicman> The :: segfault does it.
17:26:45 <shachaf> Cale: Given unsafeCoerce you can probably execute arbitrary IO.
17:26:51 <nejucomo> Ooh... safe-haskell?
17:26:58 <shachaf> sclv: I suppose.
17:26:59 * nejucomo queries-the-fscking-web.
17:27:01 <Cale> shachaf: you can
17:27:08 <nejucomo> s/web/exocortex/
17:27:11 <Cale> shachaf: At least, importing ST makes it easy
17:27:22 <lpvb> Cale that's quite lame, why isn't threading automatic? Can I compile it so that it runs multi-core automatically?
17:27:34 <shachaf> Cale: lambdabot isn't running in any sandbox or anything, right?
17:27:37 <Cale> shachaf: and even without, I recall that you can mess around
17:27:58 <Cale> shachaf: right, well, it's running on a VM
17:28:10 <shachaf> Oh, a VM on top of lispy's server?
17:28:21 <Cale> yeah, or his VM anyway
17:28:26 <Cale> I don't know if he's renting it or what
17:28:47 <nejucomo> Hm.  I already don't understand newtypes deriving from this blog post.  Time for haskellwiki.
17:28:48 <Cale> I just ssh in and run it
17:28:53 <fizzbang> it seems Numeric.Units.Dimensional isn't made for use with Data.Ratio
17:29:04 <fizzbang> somebody willing to set me straight here?
17:29:39 <Cale> lpvb: There's a way to bake in RTS options by linking against a small .c file which defines them
17:30:20 <Cale> I also seem to recall in the latest GHC, there's IO actions for setting the number of capabilities
17:30:23 <shachaf> Cale: Or just -with-rtsopts=opts?
17:30:25 <Cale> but I don't recall what those are
17:30:30 <lispy> Cale: what are you doing now? :)
17:30:32 <Cale> oh, can you do that too?
17:30:40 <shachaf> The man page confirms it.
17:30:44 * nejucomo wants a web site renderer for literate haskell.
17:30:53 <Cale> lispy: I don't know, the server lambdabot is running on is a VM instance, right?
17:31:04 <Cale> lispy: (Or is that bare metal somewhere?)
17:31:14 <shachaf> Oh, sure, his linode VM.
17:31:18 <lispy> Cale: it's a VM, linode specifically
17:31:20 <shachaf> But presumably there are other things running on that?
17:31:29 <Cale> shachaf: screen, lambdabot
17:31:29 <typoclass> shachaf: good catch
17:31:32 <lispy> shachaf: yeah, other hosts
17:31:39 <typoclass> lpvb: what shachaf said ^^
17:31:48 <shachaf> The point is that lispy might be unhappy if arbitrary #haskell people were to run arbitrary code on lambdabot.
17:31:53 <lispy> I think I might have an apache instance too
17:32:37 <lispy> The most unhappy thing that I've seen with lambdabot so far is when split-objs is enabled
17:32:59 <lispy> That can cause gnu ld to take gigs of swap to link haskell stuff. Which translates into hours sof waiting.
17:33:51 <lispy> shachaf: but yeah, arbitrary IO would be bad
17:34:16 <shachaf> "Therefore if F' is right-Lobachevsky then |Σ| ≅ ℵ₀. By Newton's theorem, if Darboux's criterion applies then I < Γ'. So ζ is conditionally Erdős."
17:35:25 <nejucomo> On "GeneralizedNewtypeDeriving is Profoundly Unsage", I don't understand how this compiles: "newtype IS_NO_LONGER a = IS_NO_LONGER a deriving Convert"
17:35:32 <typoclass> shachaf: just the other day i saw a lolcat on exactly that
17:35:46 <nejucomo> Oh, hold up.
17:36:53 <nejucomo> So that line means "if the a type variable is 'bound' to any type for which there is a Convert instance, then IS_NO_LONGER a has a Convert instance" ?
17:38:20 <shachaf> nejucomo: Try it out. :-)
17:39:12 <nejucomo> I don't know...  it looks pretty scary.  ;-)
17:39:31 <Cale> nejucomo: The only bad thing that could happen is anything at all.
17:40:34 <monochrom> if you run it with normal user privilege, the worst thing that can happen is losing that user's data
17:41:13 <monochrom> well, I guess that is not worse. it can send out a lot of spams, too :)
17:41:19 <nejucomo> hehe...
17:41:30 <shachaf> If there's a bug in lambdabot, why not a bug in the kernel?
17:41:32 <shachaf> Or the VM.
17:41:32 <nejucomo> monochrom: You have a lot of faith in user privilege enforcement.
17:41:49 <shachaf> Also, spam is good.
17:42:13 <shachaf> Spam has taught me how to enlarge my mortgage and get rich quick.
17:42:52 <monochrom> spam teaches me foreign languages
17:43:11 <nejucomo> This post has gotten me much more interested in the two type equality proving mechanisms, rather than GeneralizedNewtypeDeriving...
17:43:50 <nejucomo> I don't grok SameType (Refl) yet.
17:45:54 <nejucomo> Is there a search term where I can learn about: data SameType a b where Refl :: SameType a a
17:46:37 <sclv> type equality constraints
17:46:44 <fizzbang> when using Numeric.Units.Dimensional, it seems I have to have declared a function in a context where Dimensional.Prelude was imported, otherwise it doesn't like me using things like /
17:46:47 * nejucomo discovers Data.Type.Equality
17:47:06 <sclv> SameType is the essence of a GADT
17:47:14 <shachaf> sclv: That and existential types.
17:47:16 <fizzbang> so does this mean I can't use Dimensional with other modules?
17:47:23 <Cale> http://cale.yi.org/share/Screenshot%20-%20FP%20Complete%20Before.png  -->  http://cale.yi.org/share/Screenshot%20-%20FP%20Complete%20After.png
17:47:40 <Cale> Why do people like grey on grey text so damn much?
17:48:05 <monochrom> because they like monochrom!
17:48:05 <cmccann> white on white text is much classier.
17:48:41 <ion> Yeah, it’s annoying when web pages lack contrast. Browsers should have some kind of an autocontrast thing for that. :-P
17:48:59 <shachaf> Cale: Wow, that second version is so unstylish I can barely stand to read it.
17:49:17 <Cale> I have a link (that Z link in my bookmark bar), which zaps the CSS and sets a lot of things to default colours
17:49:31 <typoclass> ion: uh, shift-G in opera :)
17:50:29 <ion> I said “auto-”. :-P
17:50:53 <Cale> It's like they don't really want you to read the text
17:51:26 <Cale> they just want you to sit back and blur your eyes and bask in the glory of their page layout without all the black ants ruining the picnic
17:51:28 <ion> Yeah. “These are unimportant details, feel free to skip over this part.” Except that the whole page is that part.
17:52:30 * hackagebot netstring-enumerator 0.1.1 - Enumerator-based netstring parsing  http://hackage.haskell.org/package/netstring-enumerator-0.1.1 (JohnMillikin)
17:55:22 <lispy> Hmm...I think I may officially stop using bash for scripting.
17:55:56 <Clint> it's not a very good shell
17:55:59 <lispy> I just maintained a lot of haskell that did the job I would normally use bash for and then switched back to bash for a different thing and was immediately bitten by for i in {1..$UPPERBOUND}
17:56:01 <conal> how can i get a .ghci file to be included in a package distribution, i.e., picked up by 'cabal sdist'? there used to be an extra-source-files cabal field, but it appears to have gone away. i want other people to be able to play with my library (type-unary) in ghci as i do, and the library now needs ":set -package applicative-numbers" in a .ghci.
17:56:29 <lispy> Clint: but specifically, I think I'm going to start using Haskell for all my scripting. It's not as onerous as I thought to launch processes.
17:56:47 <conal> possibly related: what is the extra-ghci-libraries cabal field about?
17:56:54 <roconnor> hello haskell
17:56:54 <typoclass> lispy: in my experience as a shell script gets longer than 5 lines, it very quickly gets unmanageable
17:57:07 <Clint> in my experience, nothing is better for shell scripting than shell scripts
17:57:20 <typoclass> lispy: and yes, haskell does a much better job if you have a few helper functions for running commands and such
17:57:54 <lispy> I'm not rewriting this bashscript right now, using `seq 1 $UPPERBOUND`; instead, but going forward. Less bash more Haskell.
17:58:12 <lispy> even if I have to build up my own haskell shell utilities
17:59:10 <lispy> conal: did cabal say that field has gone away? (I'm quite skeptical about that)
17:59:50 <lispy> conal: it's still documented here, for instance: http://www.haskell.org/cabal/users-guide/developing-packages.html#package-descriptions
18:00:08 <lispy> conal: I bet data-files is more appropriate though
18:00:30 <conal> lispy: i still see the field, but i get an error from cabal, and i can't find the field in the cabal source code.
18:00:40 <conal> lispy: yeah -- it's not 'source'.
18:01:03 <conal> i might be looking in the wrong place in the source code
18:01:18 <typoclass> Clint: i think the syntax is terribly complicated and ill-thought out (lone parens? double semicolons?), it's has way too many features that nobody can remember (6000 ways of expanding a variable ...), it's not even a real programming language (stuff like 'return' in a function may work, or may silently do nothing)
18:01:28 <gienah> conal: I was wondering: is this your pkg: http://hackage.haskell.org/packages/archive/TypeCompose/0.9.6/logs/failure/ghc-7.6
18:01:58 <conal> oh, i see. "extra-src-files", not "extra-source-files"
18:02:18 <conal> i guess the online doc is wrong/old
18:02:37 <conal> gienah: looking ...
18:02:58 <conal> gienah: yeah. ghc 7.6 broke a *lot* of my code.
18:03:20 <gienah> conal: ok, thanks, hoping you might know how to fix it some time :-)
18:03:58 <typoclass> ... honestly, how are you supposed to take a language seriously if it thinks it's a great idea to just continue running the rest of the script when an error occurred. "cp x y ; rm x", "oh cp wasn't found? well let's do the rm anyway. it's half of what the user wanted, so he'll be half-happy"
18:04:15 <conal> gienah: i know some possible alternatives that might not be too ugly to bear. haven't tried them yet.
18:04:49 <Clint> typoclass: well, posix fixed lone parens
18:04:50 <gienah> conal: neat, I was wanting to bump TypeCompose in the gentoo overlay, but I don't know how to build it wiht ghc 7.6.1
18:04:59 <lispy> conal: <sigh> That's a bummer, re: out of date docs.
18:04:59 <dolio> cp x y && rm x
18:05:07 <lispy> conal: thanks for figuring that out
18:05:12 <conal> lispy: yeah. :)
18:05:51 <lispy> new ghc == broken hackage
18:05:53 <typoclass> dolio: you're advocating to put && between all commands in a shell script?
18:06:09 <dolio> Not really. But that would have avoided your problem.
18:06:54 <gienah> yeah haskell-platform 2012.4.0 seems like it wants to be boring and use ghc 7.4.2, network 2.3, ancient glut
18:07:04 <conal> lispy: data-files it is. works great. thanks!
18:07:14 <Clint> if you want to do proper error checking in a shell script, you can
18:07:17 <typoclass> dolio: i feel like i complained "this car is missing a wheel" and you said "well you could put a ski there"
18:07:25 <Clint> most people are too lazy and use set -e instead
18:07:34 <dolio> typoclass: I think it is recommended in some situations.
18:07:45 <dolio> Like './configure && make && make install'
18:08:09 <dolio> It's not going to scale to more than one liners, though.
18:08:20 <typoclass> (hm cars on skis ... there's *got* to be a top gear episode on that ...)
18:08:24 <Clint> no, that's what you have if/then for
18:08:51 <typoclass> dolio: yeah that's what i mean. it's not going to scale. you're better off just turning on that switch that stops execution on errors
18:09:15 <watermind> slightly off topic... but what is the usual (denotational) interpretation of a case construct and its injections?
18:09:16 <dolio> if then isn't going to scale any better.
18:09:58 * Clint sighs.
18:10:03 <watermind> interpreting tuples and projections is straightforward
18:10:32 <watermind> but deconstructing a case seems more involved
18:10:59 * typoclass uses an abe simpson voice to yell in the general direction of shell scripts
18:12:31 * hackagebot type-unary 0.2.4 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.4 (ConalElliott)
18:12:46 <conal> now type-unary has numeric instances for (length-typed) vectors, via applicative-numbers
18:13:08 <watermind> D |-  f :A=>C    D|- g : B=>C      ---->   Gamma |- f + g : A+B=>C
18:13:09 <parcs`> typoclass: the command 'set -e' makes it so that the script exits when a command returns a non-zero status
18:13:13 <conal> @hackage applicative-numbers
18:13:14 <lambdabot> http://hackage.haskell.org/package/applicative-numbers
18:13:31 <typoclass> parcs`: right
18:13:34 <parcs`> ah Clint already mentioned that
18:13:58 <watermind> this requires taking two morphisms D->A=>C and D->B=>C  and constructing D->A+B=>C
18:15:51 <watermind> it's easy to get D->(A=>C x B=>C)
18:16:56 <lpvb> when I make a map from a list of constant pairs, does it have to convert the list every time at runtime, or does it compile it to a map?
18:17:31 * hackagebot silently 1.2.4 - Prevent or capture writing to stdout and other handles.  http://hackage.haskell.org/package/silently-1.2.4 (TrystanSpangler)
18:21:40 <parcs`> find out with Debug.Trace
18:22:53 <parcs`> lpvb: if the pairs are really constant and the map is bound to a name then it will be evaluated once at runtime
18:28:12 <sclv> but once for every run.
18:32:31 * hackagebot haskell-bcrypt 0.3 - A bcrypt implementation for haskell  http://hackage.haskell.org/package/haskell-bcrypt-0.3 (BrettCarter)
18:32:33 <Saizan> wereHamster: look at coproducts?
18:35:08 <Saizan> that was for watermind
18:48:20 <dada-cetacean> I'm trying to install yi but cabal keeps giving me a "need unix combatibility toolchain" error; what do I do after downloading cygwin?
18:52:10 <gienah> dada-cetacean: I'm not sure, maybe this might help: http://blog.johantibell.com/2011/01/setting-up-haskell-development.html
18:52:54 <dada-cetacean> gienah: thanks!
19:17:32 * hackagebot sbv 2.6 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-2.6 (LeventErkok)
19:22:23 <zzo38> An idea is programming using the linear logic, with additive conjunction, multiplicative conjunction, additive dusjunction, multiplicative dusjunction, and other stuff like "!" and so on, you can encode intuitionistic logic in linear logic using "!" so perhaps if you have a category, you can make "!" like a comonad for using ordinary functions? (Like you use "Cont" monad in Haskell to make continuations)
19:22:32 * hackagebot yesod-comments 0.7.1 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.7.1 (PatrickBrisbin)
19:23:00 <zzo38> cmccann: Do you know?
19:23:49 <lpvb> parcs`: but it won't be evaluated at compile time?
19:23:54 <cmccann> zzo38, I don't think the encoding is quite that straightforward
19:25:06 <zzo38> cmccann: Well, I don't really know much about it; I read the Wikipedia article for linear logic.
19:25:37 <fizzbang> anybody have experience with Dimensional? [promise i won't lose connectivity again]
19:25:39 <cmccann> the comonadic nature of ! doesn't really tell you very much
19:26:42 <cmccann> especially if you expect it give you the sort of arbitrary non-linear behavior you have in intuitionistic logic
19:27:46 <zzo38> I don't know much about it, perhaps you would know exactly what would it tell you?
19:29:33 <fizzbang> if i define a function in one module which uses (/), and i import that function to another module in which I use Dimensional values, is it the case that I cannot use my function from the first module?
19:29:38 <cmccann> as far as I can tell, the comonadic behavior of ! results mostly from lifting the usual trivial comonoid from & to *
19:30:16 <cmccann> which means it's about as interesting as \x -> (x, x) in Haskell
19:31:37 <cmccann> so slapping ! on all your terms does what you expect but not in any interesting way
19:32:21 <zzo38> Well OK I can see what you mean I think, but they say how to encode it with ! on the left (I suppose like in Haskell you have (Cont r) on the right to make continuations, i.e. classical logic category being that Kleisli category), so I thought it would make a coKleisli category for intuitionistic logic
19:32:49 <zzo38> Is that how it works or not quite?
19:33:25 <cmccann> I'm pretty sure you need the ! on each type, not just the entire left side of the lollipop-arrow-thing
19:33:39 <cmccann> though maybe that ends up being equivalent, I'd have to think about it
19:34:28 <cmccann> but really, it's like swatting flies with a sledgehammer
19:34:35 <cmccann> no subtlety
19:35:01 <cmccann> if you really want to get benefit from a linear logic setting, you probably want more fine-grained control
19:35:32 <cmccann> otherwise it'd be like the IO sin bin in Haskell, but worse
19:36:03 <zzo38> Well, I know that at least classical logic can have implication only, and so you can use (Kleisli (Cont r)) as its implication type, but linear logic seem more complicated
19:36:08 <zzo38> What is a IO sin bin?
19:36:51 <cmccann> refers to the way almost everything that's not a simple pure function in Haskell ends up tossed into IO
19:38:55 <zzo38> Still, many things can be made from other things without needing the IO, we have the various monads, comonads, categories, etc
19:39:11 <cmccann> yes
19:39:19 <zzo38> And data types
19:39:30 <cmccann> and in a linear logic-based setting you'd want to make things without needing the exponentials
19:40:00 <zzo38> Yes, you would want to make such things, but you could use them for some things you want to make
19:40:19 <zzo38> As in, even in Haskell many things make without the IO but for some things you can use the IO
19:41:13 <cmccann> also, the requirements on how the exponentials behave (assuming implicit equivalences and commutativity and whatnot) forces them to do nothing interesting
19:42:01 <fizzbang> this is all super interesting, but is there a haskell channel for people who'd like to learn the language, and not just people who like to talk about how much they know about what's going on in the academic world surrounding the launguage?
19:42:39 <cmccann> you end up with, give or take, either a lazy tree of identical values, or a fixed number of probably identical values you have to process independently
19:42:42 <zzo38> fizzbang: We have to use this channel
19:43:06 <dolio> !A -o B is intuitionistic A -> B.
19:43:16 <dolio> !A -o ?B is classical A -> B.
19:43:42 <zzo38> dolio: Yes I read that on the Wikipedia.
19:43:46 <dolio> Oh, okay.
19:44:17 <dolio> That means Kleisli ! is intuitionistic.
19:44:30 <cmccann> dolio, but is !(A⊗B)⊸C the same as intuitionistic A∧B→C?
19:44:37 <dolio> Or, CoKleisli if you prefer.
19:45:00 <zzo38> dolio: At least, yes it is what I thought, it is a comonad.
19:45:03 <dolio> No, you'd use !(A&B), I think.
19:46:48 <zzo38> You could possibly represent these things by implication only too, like you would use (forall z. (x -> z) -> (y -> z) -> z) like (Either x y), I think
19:47:25 <cmccann> dolio, which I assume means you'd need to use the additive disjunction as well
19:47:37 <dolio> Yeah.
19:47:43 <dolio> Multiplicative is weird anyway.
19:47:46 <cmccann> which means no straightforward lifting of linear functions into the intuitionistic encoding
19:48:09 <fizzbang> does anybody have experience using Numeric.Units.Dimensional ?
19:48:14 <cmccann> nah, negative polarity is weird
19:49:27 <strebe> fizzbang: I've found newbie questions are quite welcome here; it's a wide-ranging channel
19:49:36 <cmccann> ⊗ behaves in the obvious way given the linearity constraint, but & is weird
19:50:05 <strebe> fizzbang: I don't, but what motivates you to ask? :-)
19:50:17 <dolio> I meant multiplicative disjunction, really.
19:50:26 <dolio> ⊗ and & are both fairly sensible.
19:50:46 <fizzbang> strebe: i'm trying to define functions that work with numbers, but it seems that then they won't work with dimensional
19:50:54 <cmccann> eh, ⅋ really isn't that strange once you get used to it
19:51:25 <fizzbang> strebe: it seems that dimensional defines its own types, and rather than making them instances of standard numeric typeclasses, it just redefines the prelude
19:51:39 <dolio> I think Wadler has a paper on a fragment of linear logic with !, ⊗, &, +, ⊸ and... I forget which nullary things.
19:51:50 <fizzbang> strebe: so i can't seem to make it play well with anything that wasn't defined in a context which imports dimensional
19:52:04 <cmccann> I don't really get the interest in fragments of linear logic
19:52:15 <zzo38> Something I found on something linked from Wikipedia, says that the ! and ? are possible to introduce multiple copies of them which are not the same as the originals even though they follow the same rules. Is that like how in Haskell you have (Cont r) and (Cont r') which are both classical logic?
19:52:18 <cmccann> seems like it loses all the tidy symmetry that makes things nice
19:52:40 <dolio> It's a fragment that doesn't require thinking about things as something more like a process calculus.
19:53:21 <strebe> fizzbang: put your code on hpaste.org
19:53:36 <dolio> So I guess it's probably 0.
19:53:37 <cmccann> why would full linear logic require that?
19:54:04 <dolio> And I can't remember whether he uses 1 or top.
19:54:47 <dolio> Because that's the kind of thing that ⅋ and negative polarity do.
19:54:54 <ryant5000> is it possible to catch exceptions in the Q monad?
19:55:35 <zzo38> ryant5000: Do you mean the Template Haskell Q monad?
19:55:39 <ryant5000> zzo38: yeah
19:55:39 <shachaf> What sorts of exceptions?
19:55:40 <cmccann> they don't require any sort of actual concurrency.
19:55:45 <shachaf> There's runIO :: IO a -> Q a.
19:55:58 <cmccann> possibly weird evaluation order.
19:56:28 <cmccann> doesn't wadler have a paper that uses lazy evaluation in Haskell to build a simple model of full linear logic?
19:56:31 <ryant5000> shachaf: well, the exception would be coming out of a Q function i don't control
19:56:41 <fizzbang> strebe: my code's a little messy at the moment; let me make a paired-down version to paste
19:57:03 <ryant5000> i'm basically trying to smuggle some data out of a function passed into someone else's Q action
19:57:12 <cmccann> in fact, I'd be surprised if you can do anything with the negative polarity connectives that DOES look like concurrency
19:57:19 <shachaf> ryant5000: Sounds kind of evil.
19:57:25 <ryant5000> shachaf: yeah
19:57:29 <ryant5000> i realized that as i typed it :P
19:57:32 <cmccann> because of how ⅋ forces things to be independent
19:57:40 <ryant5000> but what i want really *is* a non-local exit
19:57:47 <dolio> The end of proofs and types has a process calculus based on linear logic.
19:57:52 <ryant5000> well, whatever; i'll just avoid it
19:58:12 <dolio> Or, one of the appendices not written by Girard.
19:58:38 <ParahSailin> > let 倒 = flip
19:58:39 <lambdabot>   not an expression: `let
20:01:02 <ParahSailin> @let 倒 = flip
20:01:02 <lambdabot>   Illegal character ''\20498''
20:01:11 <Cale> ryant5000: There's recover
20:01:29 <ParahSailin> @let (倒) = flip
20:01:29 <lambdabot>   Illegal character ''\20498''
20:02:18 <ParahSailin> what, you get to use upside down ampersand, but not do
20:02:24 <Cale> ah, but that doesn't exactly catch meaningful exceptions...
20:02:25 <cmccann> dolio, I can't seem to find that, do you recall any other details?
20:02:39 <mikeplus64> > 倒
20:02:40 <lambdabot>   Not in scope: `
20:02:42 <dolio> I don't think I studied it in depth.
20:02:49 <mikeplus64> ParahSailin: i think it's lambdabot
20:02:53 <dolio> I seem to recall it was completely devoid of deadlocks.
20:02:57 <ion> > let 倒 = 42 in 倒
20:02:57 <dolio> Due to the linearity.
20:02:58 <lambdabot>   42
20:03:01 <ryant5000> Cale: yeah, i just decided to do it a different way
20:03:04 <mikeplus64> or not
20:04:20 <mikeplus64> > let 倒 = flip in 倒 map [0..10] succ
20:04:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
20:04:23 <cmccann> dolio, which sounds to me like there's no interesting concurrency going on...
20:05:17 <cmccann> I seem to recall that you end up with something that can be trivially sequentialized
20:05:54 <cmccann> maybe with chunks of stuff that have interleaved evaluation but no actual concurrent interaction
20:06:27 <dolio> Is that like how System F has no interesting computation because all its terms normalize in finite time?
20:07:39 <hpaste> fizzbang pasted “dimensional doesn't play well with modules” at http://hpaste.org/76521
20:08:27 <cmccann> dolio, I don't know. I can't seem to find the paper I'm sort of recalling here, sorry.
20:08:48 <cmccann> but I remain skeptical that there's an interesting model for concurrency here
20:09:02 <fizzbang> in that paste, if i uncomment the commented line, i'll get an error that the dimensional type isn't an instance of Num (and so cannot be used with the function defined in the module)
20:09:15 <fizzbang> anybody know how to use dimensional with modules that don't use dimensional?
20:09:25 <fizzbang> or is it simply a hassle..
20:10:45 <fizzbang> oops! .. ignore the last line of the paste
20:10:46 <Nereid> > generalCategory '倒'
20:10:47 <lambdabot>   OtherLetter
20:11:04 <Cale> fizzbang: Well, the point of importing the Prelude qualified is to hide the definitions of standard operations so that you can use Dimensional's, I'd bet.
20:11:52 <Cale> fizzbang: Load up Dimensional in GHCi and ask for the type of (Numeric.Units.Dimensional.Prelude.*)
20:12:04 <fizzbang> Cale: yes, i know that.. but the implication is that i cannot use anything with Dimensional which i haven't built specifically for it
20:12:17 <fizzbang> i can't write a generic data clustering module and then use it with dimensional data
20:12:22 <Cale> fizzbang: Well, not without putting units on things.
20:12:36 <Cale> The types are all completely different...
20:12:42 <fizzbang> right
20:13:08 <Cale> (*) :: (Num a, Mul d d' d'') => Dimensional v d a -> Dimensional v d' a -> Dimensional v d'' a
20:13:12 <fizzbang> so i'm curious how people who do use dimensional deal with being unable to write code that doesn't import it
20:13:26 <Cale> There are people who use dimensional? ;)
20:13:35 <fizzbang> Cale: i don't know .. are there?
20:13:40 <Cale> I don't know either
20:13:54 <Cale> It does seem like it would be a very nontrivial amount of work
20:13:55 <fizzbang> seemed like a good idea when i was getting started, but now it seems like it just complicates things
20:14:11 <fizzbang> why isn't it written to instantiate typeclasses? gah!
20:14:19 <Cale> look at the type!
20:14:26 <Cale> (*) :: (Num a, Mul d d' d'') => Dimensional v d a -> Dimensional v d' a -> Dimensional v d'' a
20:14:39 <fizzbang> i can see it
20:14:41 <Cale> there's no way to get that to unify with  (*) :: (Num a) => a -> a -> a
20:14:42 <cmccann> dolio, ah, here it is: http://citeseer.uark.edu:8080/citeseerx/viewdoc/summary?doi=10.1.1.55.1710
20:15:03 <Cale> because the unit marker types are different in each of the parameters and the result
20:15:23 <Cale> So they basically can't use the standard interfaces for anything, because those aren't general enough.
20:15:38 <dolio> cmccann: The proof nets stuff is what I was talking about.
20:15:43 <fizzbang> so the conclusion is that i have to rewrite all of the mathematics libs i want to use to be compatible with dimensional ... or i just don't use dimensional
20:15:46 <dolio> But it doesn't look like they really go into much programming.
20:15:52 <dolio> Mostly a footnote.
20:16:25 <fizzbang> Cale: thanks for confirming; i'm new enough that i wasn't sure if i was just missing something
20:17:05 <Cale> fizzbang: Well, there is probably a way to add units to things which are initially not tagged
20:17:10 <Cale> (and remove them again)
20:17:16 <fizzbang> yes, there is a way
20:17:25 <Cale> But yeah, it defeats a lot of the point of using the library to do that
20:17:39 <dada-cetacean> how do I add a location to my PATH?
20:17:42 <cmccann> dolio, right, and part of the conclusion of the paper I linked to is that it's not really concurrent in any way that intuitionistic logic isn't as well
20:18:09 <fizzbang> i'd have to write a wrapper interface around all of the libraries i want to use in which i strip units from arguments, call the library function, and then apply units correctly to the result
20:18:18 <Cale> yes
20:18:23 <fizzbang> cool
20:18:29 <fizzbang> my conclusion is to ditch dimensional
20:18:33 <rwbarton> fizzbang: well it makes sense
20:18:38 <fizzbang> sadly :(
20:18:42 <fizzbang> rwbarton: which part?
20:18:48 <rwbarton> what if the function f in the library is implemented as f x = x + x*x
20:19:04 <rwbarton> if you have a number x you can form x + x*x
20:19:18 <rwbarton> but if you have a dimensioned quantity x you can't form x + x*x unless x is actually unitless
20:19:48 <rwbarton> so of course you cannot take some arbitrary library with math functions and pass dimensioned quantities to it, because dimensioned quantities are not numbers
20:20:20 <rwbarton> this is a concrete example of the issue that Cale was referring to with the types
20:20:44 <dolio> cmccann: Are all (one of) the links there broken?
20:21:00 <fizzbang> rwbarton: okay, that makes sense
20:21:03 <Cale> Another thing you might be able to do is to take the library you want to use, obliterate all the type signatures in it, and try importing the dimensional Prelude
20:21:06 <rwbarton> yes
20:21:21 <fizzbang> because x*x squares the units, and then i'm adding meters to meters-squared
20:21:24 <Cale> and see if it can prove that your library is actually dimension-safe
20:21:38 <cmccann> dolio, oh, I didn't check... I have a copy on my hard drive, just googled for the title after I remembered which paper it was
20:22:02 <fizzbang> Cale: i don't really want to do that.. i want to write a program, and maybe build some libraries i can reuse in the future
20:22:08 <dolio> Well, it's fine. I can easily believe there's no, say, nondeterminism, unless maybe you add in the modalities.
20:22:10 <Cale> yeah
20:22:37 <cmccann> pretty sure the exponentials don't change anything either
20:22:42 <Cale> In that case, dimensional is a bit of a baroque curiosity rather than something terribly useful for exposing to your users.
20:22:58 <cmccann> though there's some tricky bits with how much you expect certain equivalences to be equivalent up to which isomorphism
20:23:03 <cmccann> if memory serves me
20:23:49 <dolio> If you have ! and ?, then you can encode anything in classical logic.
20:23:58 <dolio> Is there also a well defined sequential semantics for that?
20:24:23 <fizzbang> heh..
20:24:36 <fizzbang> Cale: rwbarton: thank you both.
20:25:45 <cmccann> dolio, I'm not sure what non-sequential semantics it would have?
20:26:10 <cmccann> it amounts to the same thing as the double-negation translation to encode into intuitionistic logic
20:27:10 <cmccann> from a programming perspective I'm pretty sure the exponentials have a straightforward interpretation in terms of lazy data structures
20:27:17 <cmccann> but I don't have that pinned down well enough to elaborate
20:27:30 <dolio> Well, I don't really know anything about ! and ? from a programming perspective.
20:27:45 <dolio> But I do know that with call/cc, for instance, you can detect evaluation order.
20:27:59 <Cale> fizzbang: You can enforce pretty much anything in the type system with all the extensions turned on, if you're willing to go to the trouble, but types are only as useful as long as people are willing to bear any inconvenience of actually using them, and there's a practical limit to what you can reasonably do at any point.
20:28:03 <dolio> So I'd be hard pressed to say it has a well defined sequential evaluation order.
20:28:14 <dolio> Since your results depend on what you pick.
20:28:59 <cmccann> I'm not sure how that would translate into the logic
20:29:00 <tac> I always felt in Haskell, the dozens and dozens of type extensions felt really self-defeating.
20:29:10 <fizzbang> Cale: as somebody just learning the type system, i don't think i'm ready for that ;)
20:29:46 <tac> fizzbang: how long have you been doing haskell?
20:31:19 <cmccann> but my intuition is that encoding it in something based on linear logic would end up preventing that sort of observation
20:31:44 <dolio> I guess that makes sense. That's what the intuitionistic encoding does.
20:32:02 <cmccann> because even with the ability to duplicate or discard information, the connectives partition dependencies between terms
20:33:47 <cmccann> the paper I mentioned earlier demonstrates that very persuasively, using lazy evaluation to encode linear logic rather directly in Haskell
20:33:59 <cmccann> rather than the CPS-style encoding I used
20:35:30 <cmccann> the "no deadlocks" property of the quasi-concurrent interpretation is probably similar
20:38:33 <cmccann> dolio, anyway, thanks for putting up with my rambling, heh
20:38:44 <dolio> No problem.
20:42:39 <gwern> sure, you can prove no deadlocks, but can you prove no dreadlocks?
20:42:57 <gwern> (ja ja mon, I and I think you can't)
20:43:12 <cmccann> >:I
20:43:29 <gwern> well, prove me wrong white boy
20:44:33 <ion> “Ouch! My eye-and-eye!” – Hermes Conrad
20:46:59 <gwern> ion: a typical Babylon slur on a rastaman
20:58:17 <fizzbang> tac: i haven't really written anything; just read about it in my free time for a couple months
20:58:23 <sm> good new bob marley documentary on netflix btw
20:58:45 <tac> fizzbang: awesome
20:59:21 <fizzbang> tac: it's not feeling awesome, man... i feel so stupid all the time
21:00:11 <tac-tics> fizzbang: Yeah. Haskell makes you take a step backwards before you start flying.
21:00:25 <fizzbang> tac-tics: like today i realized i don't really understand the hierarchy of numeric types, and consequently can't do anything :P
21:00:43 <maukd> there's a hierarchy?
21:01:02 <fizzbang> tac-tics: i get the feeling that it'll be more of a slow climb :)
21:01:43 <fizzbang> maukd: http://www.haskell.org/onlinereport/classes.gif
21:02:00 <fizzbang> maukd: kind of?
21:02:07 <maukd> fizzbang: sure, but those aren't types
21:02:09 <maukd> they're classes
21:02:24 <fizzbang> but the non-bold text in the bubbles are types
21:02:38 <tac-tics> fizzbang: A lot of Haskellers in this channel will make you feel like you don't know enough. Not on purpose -- Haskell is just a really active research language.
21:02:41 <maukd> yes, but the types don't form a hierarchy
21:02:46 <fizzbang> each fitting into one or more places in a hierarchy
21:02:53 <tac-tics> So just take everything people say here, and ask yourself "is this really useful? Or is it just neat?" :)
21:02:58 <maukd> fizzbang: you can ignore most of that
21:03:13 <maukd> the types you'll probably need in practice are Int, Integer, and Double
21:03:18 <maukd> maybe Rational
21:03:32 <fizzbang> maukd: well i have to know some of it to understand what i can and can't give as an argument to a function that, say, accepts "fractionals" or "integrals"
21:04:04 <maukd> for "integrals" you can pass Int and Integer; for "fractionals" you can pass Double :-)
21:04:12 <tac-tics> fizzbang: The number types in Haskell are fubar, anyway
21:04:18 <tac-tics> Focus on using the basic types
21:04:24 <tac-tics> and you can learn the ugly numeric tower later
21:04:37 <tac-tics> (I don't even know the number tower properly, and I've been learning Haskell for 5 years)
21:04:38 <fizzbang> tac-tics: okay, sounds good
21:04:49 <fizzbang> heh..
21:05:03 <maukd> I mean, there's no point in remembering that (/), (**), and fromRational are in different classes
21:05:05 <tac-tics> Most of the time, the operations "just work"
21:05:11 <tac-tics> @type (/)
21:05:13 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:05:14 <tac-tics> > 1 / 2
21:05:16 <lambdabot>   0.5
21:06:16 <maukd> hmm
21:06:22 <maukd> I may actually have a very good point here
21:06:36 <tac-tics> @type (/) :: Float -> Float -> Float
21:06:38 <lambdabot> Float -> Float -> Float
21:06:47 <maukd> there are 7 numeric classes but only like 3 basic types
21:07:20 <fizzbang> the way you talk-- i almost feel bad for poor ole' floaty
21:07:23 <maukd> so it makes perfect sense to not try to understand the classes and their relationships but to focus on the types instead
21:07:34 <tac-tics> Types are king in Haskell
21:07:41 <maukd> Float is like Double, only worse
21:07:43 <rwbarton> i certainly could not list the classes
21:07:54 <tac-tics> classes are trickery. Useful, useful trickery
21:07:55 <maukd> I don't think I've used Float, ever
21:08:06 <tac-tics> maukd: what do you use?
21:08:09 <tac-tics> Double?
21:08:10 <maukd> Double
21:08:12 <tac-tics> @kind Double
21:08:13 <lambdabot> *
21:08:39 <maukd> and I mean, once you understand Double, Float is just more of the same
21:08:46 <maukd> just with less precision
21:08:48 <fizzbang> or less of the same..
21:09:18 <maukd> > replicate 10 0.1
21:09:19 <lambdabot>   [0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1,0.1]
21:09:25 <maukd> > sum (replicate 10 0.1) :: Rational
21:09:26 <lambdabot>   1 % 1
21:09:36 <maukd> eat that, lisp
21:10:22 <lpvb> does the arch haskell group have its own channel?
21:11:16 <fizzbang> lpvb: arch linux haskell?
21:11:22 <fizzbang> don't you people have jobs?
21:11:56 <tac-tics> Yes. We use Haskell as an escape.
21:11:59 <tac-tics> (at least, I do)
21:12:00 <lpvb> umm..
21:12:26 <lpvb> fizzbang: what do you mean?
21:12:32 <fizzbang> i used archlinux for about five years and then stopped when a series of changes around last may borked everything when i updated :/
21:12:48 <ryanos> fizzbang: do you think haskell is ready to be used at work ?
21:13:00 <fizzbang> lpvb: i mean, now that i'm not a grad student and work all day, i don't have energy and time to deal with as much of the computer stuff i used to think was "fun"
21:13:11 <fizzbang> (in my free time)
21:13:19 <fizzbang> ryanos: sure. i can't though.
21:13:54 <ryanos> fizzbang: if you had the power to choose whatever u want tor a lang to develop stuff @work would u pick haskell ?
21:13:57 <lpvb> My install has never been borked before, and I've used arch for 4 years now
21:14:09 <lpvb> I always ready breaking changes on the homepage before I update
21:14:13 <lpvb> read*
21:14:50 <gwern> ah yes, there's nothing quite like relaxing with a cold brew to read release notes
21:15:06 <dmwit> There's nothing like it. But there's something better.
21:15:09 <lpvb> I update about once a month
21:15:25 <fizzbang> lpvb: yeah, read those, but there were a couple of big changes that had happened since my last update... when i followed the instructions as i had done in the past, it broke and i haven't had time to fix it
21:15:44 <fizzbang> i update about once every time i have to to install something i don't currently have installed
21:16:08 <fizzbang> (that is to say, not often enough to keep current)
21:16:19 <lpvb> you have strong opinions
21:16:50 <fizzbang> lpvb: no, i just have little patient
21:16:55 <fizzbang> patience
21:17:41 <gwern> reinstalling an entire system can be a waste of a day or two; it only takes one or two such incidents to take the gild off the lily
21:17:57 <fizzbang> gwern: thank you
21:18:44 <lpvb> arch never forces you to break your system if you don't have time for it, but since you updated every time you installed an application you forced yourself into it
21:19:07 <ryanos> so with all these being given - is it realistic to assume somebody can use haskell at work and do stuff other than individual programs and utilitities?
21:19:19 <ryanos> utilities
21:19:24 <Robdgreat> hmmm
21:19:27 <gienah> an arch update made a little notebook of mine unbootable back in about may
21:19:29 <gwern> (after all, whatever the benefits of arch... say it saves you 70 minutes a week somehow compared to debian - well, 2 wasted days is 2 * 24 * 60 minutes or 41 weeks which is almost a year. so a single upgrade failure or drive corruption can blow your claimed arch benefits)
21:19:45 <fizzbang> lpvb: no, i updated because i got 404 errors when i wanted to install an application -- in that circumstance you must -Syu to install anything at all
21:20:05 <lpvb> 404 errors?
21:20:23 <fizzbang> lpvb: go 3 months without updating, and you'll get them too
21:20:58 <lpvb> that's just pacman's mirrors being out of date
21:21:06 <fizzbang> lpvb: it just means the packages your system knows about aren't on the mirror anymore because you're outdated
21:21:13 <fizzbang> lpvb: right
21:21:16 <lpvb> arch is not responsible for its mirrors decisions
21:21:20 * gienah was unlucky with that destruction of the little arch notebook though, as it only had 384MB of memory so could not network boot it with arch, and its cdrom drive was broken, so recovery was impossible with arch linux
21:21:26 <lpvb> and you only have to update pacman
21:21:31 <lpvb> or choose another mirror
21:21:54 <lpvb> gienah: usb install?
21:22:35 <gienah> lpvb: maybe, if it had a usb slot that might of worked (ancient notebook)
21:22:44 <fizzbang> lpvb: no, it's not the mirror being out of date, it's your local references against the mirror
21:23:27 * gienah likes arch linux anyway, its usually fine
21:23:59 * fizzbang feels the same way, just doesn't have the energy to reinstall it 
21:24:47 <lpvb> fizzbang: what do you use then?
21:25:27 <fizzbang> lpvb: bought my gf's macbook so she could get an air ... and i hate it
21:26:36 <fizzbang> anyway, back to haskell
21:26:49 <fizzbang> it's great, but it's taking me forever to learn
21:26:54 <fizzbang> sorry to go off topic
21:27:07 * gienah put sabayon linux on the little notebook after arch, but its power supply broke immediately after I installed it
21:27:35 <lpvb> I've been contemplating installing a *BSD
21:28:07 <dada-cetacean> I'm trying to manually install yi via cabal but it keeps telling me that it's missing dependencies which I've already installed via cabal
21:29:35 <gienah> dada-cetacean: yi uses old deps, there are some patches here: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/app-editors/yi/files
21:33:08 <ryanos> ladies(?) and gentlemen : anybody knows of some large haskell systems out there in the wild - and where i can read some details on how they leverage haskell ?
21:34:51 <dmwit> "leverage" is a noun.
21:35:12 <ryanos> dmwit: how they use what haskell has to offer
21:35:18 <Jafet> He leveraged it as a verb.
21:35:23 <ryanos> :)
21:35:48 <shachaf> As long as we're picking on what ryanos said, I suspect that question mark wasn't *really* necessary.
21:35:51 <ryanos> how they take advantage of haskell features
21:36:37 <ryanos> shachaf: let's not get strong typed now
21:36:43 <johnw> leverage is also a verb, says the dictionary
21:36:45 <Jafet> @faq are there wild haskell systems?
21:36:46 <lambdabot> The answer is: Yes! Haskell can do that.
21:36:46 <ryanos> just interested on some examples
21:37:16 <ryanos> @faq large haskel systems
21:37:16 <lambdabot> The answer is: Yes! Haskell can do that.
21:37:27 <ryanos> @faq land on the sun
21:37:28 <lambdabot> The answer is: Yes! Haskell can do that.
21:38:04 <johnw> the most common opinion I'm hearing from non-Haskellers is, "Haskell is a good thing to know, but not very useful for solving real problems."  I wonder what has given so many of that that impression
21:38:50 <dmwit> Have you looked at the wiki?
21:38:53 <johnw> i'm using it now for everything I would have used Python/Ruby for, and it is not one whit less useful or practical
21:38:59 <Jafet> They haven't used it to solve real problems
21:39:00 <johnw> lol
21:39:10 <johnw> Jafet: I think that's it
21:39:20 <ryanos> i love haskell
21:39:32 <ryanos> and want to use it for some projs i want to build in the near future
21:39:48 <ryanos> but want to manage/control potential technology risks
21:39:51 <fizzbang> johnw: i want to do what you just said, because recently i've become fed-up with the state-dependent nature of many aspects of python...
21:40:16 <MostAwesomeDude> fizzbang: Refactor. You can write really clean Python, it's just that very few people bother to do it.
21:40:28 <fizzbang> johnw: but so far i'm just spinning my wheels, reading about haskell but not moving forward ... it's truly a difficult language
21:40:37 <johnw> well, I can tell you from my experience that Haskell programs become asymptotic to "correct" much faster than do Python programs, and they are far easier to make concurrent
21:40:42 <ryanos> so trying to learn from u/other that did large projs with haskell
21:40:58 <fizzbang> MostAwesomeDude: I write very clean python, but i'd rather write functional (as in functionl-language) code
21:41:07 <shachaf> ryanos: You should answer dmwit's question.
21:41:10 <MostAwesomeDude> fizzbang: Okay.
21:41:25 <ryanos> i browsed through wiki, yes
21:41:29 <ryanos> but not specifics
21:41:39 <ryanos> was trying to see how is behind the courtains
21:41:46 <ryanos> (for large systems)
21:42:18 <gienah> it seems it used to be a similar situation with python as it is now with haskell: http://www.paulgraham.com/pypar.html
21:42:23 <fizzbang> MostAwesomeDude: python's arbitrary restriction on the depth of recursion makes it less-than-convenient for writing my own recursive data structures.. that and state, i guess ...
21:43:12 <johnw> does the GHC optimizer take binary associativity into account for categories and monoids?
21:43:35 <dmwit> no
21:44:03 <fizzbang> anyhow, it's been nice talking with y'all
21:44:06 <fizzbang> night
21:44:32 <shachaf> johnw: It probably could if there was a RULES for it...
21:45:00 <johnw> shachaf: nice, reading now...
21:45:08 <Jafet> How to make the optimizer loop, part 1
21:45:32 <shachaf> I found out that the inliner still crashes on Curry's paradox. :-(
21:46:01 <ryanos> gienah: the paulgraham article is right on: "Real ugliness is not harsh-looking syntax, but having to build programs out of the wrong concepts."
21:47:13 <tac-tics> Graham used Lisp. He probably never saw a syntax in his life.
21:47:24 * adu <3 lisp
21:47:46 <lpvb> good morning, fizzbang
21:48:12 <ryanos> he was talking about perl in that context "At the mention of ugly source code, people will of course think of Perl. But the superficial ugliness of Perl is not the sort I mean. Real ugliness is not harsh-looking syntax, but having to build programs out of the wrong concepts."
21:48:15 <dolio> Lisp has syntax.
21:48:40 <rwbarton> and different "lisps" have different syntax
21:48:50 <shachaf> Oh boy. Is it Lisp-syntax-o'clock?
21:49:13 <Jafet> shachaf: '()
21:49:24 <shachaf> :'()
21:49:35 <dolio> That's why Scheme macros are called "define-syntax" and stuff.
21:49:58 <shachaf> dolio: If they're syntax, why do you call them macros?
21:50:03 <shachaf> Checkmate.
21:50:21 <dolio> define-syntax isn't the only piece.
21:50:31 <shachaf> There's syntax-rules.
21:50:35 <dolio> There's also syntax-case.
21:50:38 <dolio> syntax-parse
21:50:38 <shachaf> Which is the Scheme designers saying that syntax rules.
21:50:43 <lpvb> is it possible to make a lisp with a strong type system rivaling haskell?
21:50:50 <MostAwesomeDude> lpvb: Anything's possible!
21:51:17 <lpvb> MostAwesomeDude: Is it possible for something to be impossible?
21:51:36 <johnw> Checkmate.
21:52:01 <ryanos> lpvb: it is possible for something to be impossible..
21:52:01 <strebe> lpvb: yes. ;-)
21:52:20 <lpvb> while holding the axiom "anything's possible"
21:52:21 <johnw> he said anything's possible, not that everything is possible :)
21:52:31 <lpvb> hmm
21:52:37 <shachaf> @google trebla all any
21:52:38 <lambdabot> http://www.vex.net/~trebla/weblog/any-all-some.html
21:52:38 <lambdabot> Title: Any, For All, Exists
21:52:50 <shachaf> Why is #haskell so terrible?
21:52:54 <Jafet> Clearly MostAwesomeDude is using a strong type system
21:52:55 <strebe> lpvb: there's a strongly typed smalltalk
21:53:10 <strebe> shachaf: how's it terrible?
21:54:08 <Jafet> Because we keep misspelling "terrible".
21:55:01 <MostAwesomeDude> lpvb: Oh, right, I forgot which channel we're in.
21:55:17 <strebe> lpvb: have you heard of Qi? http://en.wikipedia.org/wiki/Qi_%28programming_language%29
21:55:36 <johnw> Qi is now called Shen
21:56:16 <johnw> i wonder if Haskell can be a host language for Shen...
22:01:00 <lpvb> strebe: interesting
22:05:34 <lispy> hello
22:05:40 <lispy> how is channel?
22:06:20 <tertl4> its here
22:06:21 <Jafet> Channel is.
22:07:42 <lispy> how is code?
22:08:45 <MostAwesomeDude> Code is.
22:09:29 <tertl4> wtfrack
22:10:05 <lispy> MostAwesomeDude: it's declarative?
22:10:41 <MostAwesomeDude> lispy: Sure!
22:11:53 <Jafet> tertl4: http://www.nullis.net/stuff/images/new-server-rack-filled.jpg
22:13:17 <tertl4> wtfrack Jafet ?
22:13:32 <Sculptor> high tech
22:13:39 <tertl4> that looks like bill gates closet in 1990
22:13:59 <tertl4> is that a good estimation?
22:14:17 <Sculptor> is that stefan didak's first setup?
22:17:15 <tertl4> i wasnt into computers at that stage
22:17:33 <tertl4> i was still on the nintendo
22:17:37 <tertl4> it was way cooler
22:23:09 <johnw> joeyh: ping
22:45:42 <mikeplus64> so on http://www.haskell.org/haskellwiki/GHC/Using_the_FFI it says "Caution! If you are not responsible for the source of the foreign function you should not mark the import as unsafe unless you are absolutely certain it doesn't (and won't ever) call back into Haskell...", what counts as calling back into haskell?
22:45:49 <mikeplus64> creating threads?
22:46:15 <shachaf> mikeplus64: Calling Haskell code, I assume.
22:46:17 <mikeplus64> obviously actually interacting with the haskell runtime directly, but it seems to imply there are different subtle ways it can
22:46:27 <shachaf> mikeplus64: Note that that's not the only time that you want to avoid unsafe.
22:46:33 <ezyang> It's pretty clear, IMO...
22:46:37 <shachaf> For example if your "unsafe" call blocks, it'll also block the GHC capability.
22:53:18 <eyebloom> Has anyone encountered the "Conflicting family instance declarations:" error. I think I don't fully understand but I thought the scope of a type synonym inside a typeclass was limited to the class or instance? Please see this code:
22:53:23 <hpaste> eyebloom pasted “Conflicting family instance” at http://hpaste.org/76522
22:53:52 <shachaf> eyebloom: You should include the actual error when you paste something like that.
22:54:38 <eyebloom> One moment
22:55:03 <shachaf> eyebloom: Try "type Neep Who = ..." and "type Neep Foo = ..."
22:55:20 <shachaf> Er, assuming that's what you mean.
22:55:28 <shachaf> If it's not, then I'm not sure what you *do* mean.
22:57:35 <eyebloom> Well it's an example. So I don't mean much
22:58:13 <eyebloom> But thanks, I think that helps, I'm trying to get it to compile now.
22:58:42 <eyebloom> I think you showed me basically a type family is a partial function.
22:58:52 <eyebloom> Whether it is in a typeclass or not.
