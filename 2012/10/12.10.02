00:00:31 <chumma> and cabal install inside binary directory throws the same old error
00:02:01 <fmap> interesting
00:03:19 <fmap> @hpaste
00:03:20 <lambdabot> Haskell pastebin: http://hpaste.org/
00:03:26 <fmap> chumma: paste full error please
00:03:46 <chumma> will do it, but i could install warp
00:06:28 <dropster> morning
00:07:07 <hpaste> Chumma pasted “Binary installation ubuntu11.10” at http://hpaste.org/75651
00:07:46 <chumma> fmap:i pasted it please check
00:09:06 <chumma> fmap: i think i have to remove line 46 right?
00:10:10 <dimka> What version of cabal it is?
00:10:17 <fmap> chumma: you need to remove the whole test-suite section
00:10:34 <fmap> from "test-suite qc" to "build-depends: binary"
00:20:47 <chumma> thanks guys fmap,rohit_ i got it working, sorry for that much trouble i am just getting started with haskell
00:21:59 <rohit_> thanks fmap
00:24:56 <lightquake> is there a way to specify arbitrary data in a cabal file?
00:25:13 <lightquake> ... on the other hand, maybe that's not really a good idea for what i want. hm.
00:25:31 <Cale> Hokay. It's 3:24am, I just woke up, and I feel like examining what lenses really amount to in the traditional category of homotopy types of topological spaces...
00:25:53 <Cale> lightquake: What kind of arbitrary data?
00:26:04 <Cale> (I don't think any part of the file is arbitrary Haskell code)
00:26:09 <lightquake> just a string.
00:26:29 <lightquake> i'm trying to think about how i want to manage cabal-dev sandboxes. i realized that putting the path to the sandbox, which would be user-dependent, in the cabal file is a bad idea
00:31:10 <lightquake> i guess making a symlink named 'cabal-dev' in the project root to the actual cabal-dev works
00:32:00 <lightquake> it's somewhat ugly but i don't think there's really any good solution
00:32:03 <mrkotfw> Hello everyone!
00:32:13 <lightquake> unless cabal-dev or something similar becomes actually a part of cabal
00:32:31 <fmap> lightquake: solution to what problem?
00:33:05 <lightquake> fmap: suppose i store my cabal-dev sandboxes in ~/.sandboxes, so that i can share them between projects
00:33:17 <lightquake> i'm in ~/code/myproj. what sandbox do i use?
00:35:35 <lightquake> one solution is 'make ~/code/myproj/cabal-dev a symlink to ~/.sandboxes/box1/'
00:40:45 <fmap> lightquake: did you try hsenv? i guess concept of virtual environment is more similar to what you want than cabal-dev sandboxes.
00:41:38 <lightquake> fmap: hsenv has the same problem; if i want to share hsenvs between projects, i have to put them somewhere (say in ~/.envs)
01:09:31 <paolino> I have a GADT constructor Pattern :: forall c . Render c => c -> a -> R Relative a, for type data R b a, compilers says 'a' is not in scope
01:09:39 <Rc43> Hi, guys.
01:10:06 <Rc43> Anybody uses UUAG (attribute grammars)?
01:10:18 <Rc43> I can't install it (`cabal install uuagc`).
01:10:30 <Rc43> Compilation fails.
01:10:39 <fmap> @hpaste
01:10:39 <lambdabot> Haskell pastebin: http://hpaste.org/
01:10:42 <fmap> Rc43: ^
01:12:07 <hpaste> Rc43 pasted “uuagc build failed” at http://hpaste.org/75653
01:13:24 <maukd> whoa. Cabal version mismatch?
01:14:10 <paolino> ok, I must leave the forall c out
01:16:52 <fmap> Rc43: ghc version?
01:22:15 * hackagebot gloss 1.7.6.4 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.6.4 (BenLippmeier)
01:24:01 <drdo> A fold where the iteratee can choose between different paths, possibly with different input types. Is there a name for this?
01:26:23 <VCommeLeVent> drdo, different paths=
01:26:34 <VCommeLeVent> You mean the difference between a right and left fold?
01:26:39 <drdo> No, i don't
01:28:41 <drdo> Think of traversing some graph
01:29:13 <drdo> Web links for example
01:29:33 <VCommeLeVent> drdo, you mean in what order the expressions are evaluated?
01:29:54 <drdo> No
01:30:03 <VCommeLeVent> Then I am left confused..
01:30:47 <drdo> VCommeLeVent: Think of traversing the streets in your town
01:31:09 <drdo> You usually like to be able to choose which street to take at intersections
01:31:20 <VCommeLeVent> Yeees, what does that have to with fold?
01:32:11 <drdo> Usually with folds you don't choose, the enumerator fully decides what you get
01:32:50 <VCommeLeVent> Choose what?
01:32:55 <VCommeLeVent> drdo, can you give me an example?
01:33:00 <drdo> More examples?
01:33:06 <VCommeLeVent> A code example
01:33:08 <VCommeLeVent> you haven't given me any.
01:33:45 <drdo> I'm asking for information about this
01:33:58 <drdo> What do you mean code example?
01:35:08 <VCommeLeVent> drdo, you realize that essentially no one understands what exactly you mean right?
01:35:14 * ClaudiusMaximus -> http://rybn.org/dev/art/ Paris tonight!
01:37:18 <drdo> VCommeLeVent: If you don't understand what i mean by traversing a graph, i don't know what more to tell you
01:37:41 <VCommeLeVent> I don't know how it relats to fold/
01:38:06 <drdo> Ok, let's get more specific
01:39:20 <drdo> An iteratee, as in Oleg's iteratee, that can guide the enumerator
01:39:39 <Iceland_jack> VCommeLeVent: I understand what drdo means
01:39:52 <VCommeLeVent> Iceland_jack, really?
01:39:57 <VCommeLeVent> Well, I suppose answer it then
01:42:04 <Iceland_jack> I don't know if there anything like it, drdo if I understand correctly you want to have some choice mechanism when you fold
01:42:19 <sopvop> is that a zipper?
01:42:22 <Iceland_jack> so if you were folding a tree it could choose whether to fold left, right, both or neither
01:42:38 <Iceland_jack> A zipper is a data structure?
01:42:42 <drdo> Iceland_jack: Sure, that's an example
01:43:01 <sopvop> sort of. zipper is a "place in structure" data structure.
01:43:06 <drdo> But the real use is when traversing live shit
01:43:24 <drdo> As opposed to static data structures
01:43:31 <sopvop> drdo: Just write a traversal function, there can be no generic solution
01:43:33 <merijn> Iceland_jack: Yes, if you don't know the term zipper I can recommend spending some time reading up on them in the near future, they're very neat functional data structures :)
01:43:45 <Iceland_jack> I do know zippers merijn
01:44:11 <Iceland_jack> but zippers don't "decide" which branch you take
01:44:17 <drdo> sopvop: The problem isn't writing, i'm not even looking an a specific thing i need to get done right now, i'm asking about information on the topic
01:45:30 <sopvop> drdo: I'm not a mathemagician of any sorts, but I don't think such thing can exist and has a name.
01:45:44 <Iceland_jack> Why couldn't it exist sopvop?
01:46:02 <drdo> Writing one is easy, just write it in CPS and choose from a bunch of continuations in a list
01:46:17 <sopvop> Because every structure is different.
01:46:42 <drdo> sopvop: That remark right there
01:46:42 <Iceland_jack> It could take a predicate for the actual elements of the data structure
01:46:48 <drdo> Think about how dumb that actually is
01:47:49 <sopvop> ok, call it "unfold"
01:47:53 <Enigmagic> drdo: take a look here http://hackage.haskell.org/packages/archive/machines/0.2.1/doc/html/Data-Machine-Wye.html
01:48:03 <drdo> I'm just calling it traverse now
01:48:13 <drdo> Because apparently people were thinking Prelude.foldr
01:48:13 <sopvop> @type unfold
01:48:15 <lambdabot> Not in scope: `unfold'
01:48:22 <sopvop> @type unfoldr
01:48:24 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:48:28 <dimka> There is annoying message appearing during `cabal install`: on the commandline: Warning: -package-conf is deprecated: Use -package-db instead
01:48:39 <dimka> What am I doing wrong and where it comes from?
01:48:56 <sopvop> dimka: using virthualenv or hsenv?
01:49:18 <dimka> No, I don't use them
01:49:28 <quicksilver> drdo: zippers generally give rise to a notion of 'direction' at a point which can lead to a notion of a path to follow
01:49:39 <sopvop> dimka: Strange, I have the same message. Though it comes from them.
01:50:38 <ivanm> nah, Cabal
01:50:51 <ivanm> ghc 6.7 changed the flags needed
01:50:55 <ivanm> * 7.6
01:51:02 <sopvop> I thought it writes wrong cabal.
01:51:14 <ivanm> so if you're still using cabal-install 0.14, it probably still uses the old command
01:51:33 <ivanm> sopvop: Cabal uses ghc-pkg (and the equivalent for other compilers)
01:51:37 <dimka> ivanm: there is newer cabal-install?
01:51:39 <ivanm> rather than trying to do it all itself
01:51:40 <sopvop> I know
01:51:41 <ivanm> dimka: on github
01:51:51 <dimka> Oh, okay
01:51:54 <dimka> Thanks
01:51:55 <drdo> quicksilver: I didn't really mean direction, i never meant to assume much structure at all, i was just being pushed into specific examples
01:51:57 <sopvop> I thought that environment things write wrong cabal config.
01:53:26 <quicksilver> drdo: well an abstract notion of "direction" is just one way to choose which path to take at choice points
01:55:20 <drdo> quicksilver: Sure, but you usually talk about direction when there's some relation between the choices at different points
01:56:45 <sopvop> drdo: in my opinion it is hylomorphism. or  fold . unfold
01:57:21 <dimka> `do { p ← getProcessID; f ← pidPath; writeFile f $ show p }` how can it be rewritten?
01:57:28 * sopvop is now smart from wikipedia.
01:58:10 <ion> writeFile f (show p)
01:58:14 <drdo> sopvop: Are you just looking up random words? :P
01:58:46 <maukd> @undo do { p <- getProcessID; f <- pidPath; writeFile f $ show p }
01:58:47 <lambdabot> getProcessID >>= \ p -> pidPath >>= \ f -> writeFile f $ show p
01:58:54 <maukd> @. pl undo do { p <- getProcessID; f <- pidPath; writeFile f $ show p }
01:58:54 <lambdabot> (pidPath >>=) . flip writeFile . show =<< getProcessID
01:58:57 <sopvop> drdo: almost. sort of  *morphism, then try prefixes like co, pro...
01:59:06 <drdo> What i'm talking about has nothing to do with unfolding
01:59:16 <dimka> maukd: ok
01:59:31 <sopvop> drdo: Ok, you mean you have different kinds of folding then.
02:00:40 <ion> let bind2 f a b = join (liftM2 f a b) in bind2 writeFile pidPath (show <$> getProcessID)
02:00:48 <fmap> liftA2 writeFile pidPath (show <$> getProcessID) ?
02:00:59 <fmap> oh right
02:03:15 <fmap> `\f -> join .: liftA2 f' should be in Control.Monad :[
02:03:23 <drdo> sopvop: I just mean traversing some arbitrary heterogenous graph, and you don't and can't know the graph, if nothing else because it depends on time
02:07:44 <kallisti> > (replicate 3 ) (replicate 2 [2, 2])
02:07:45 <lambdabot>   [[[2,2],[2,2]],[[2,2],[2,2]],[[2,2],[2,2]]]
02:08:26 <dimka> @pl \f a b -> join $ liftM2 f a b
02:08:26 <lambdabot> ((join .) .) . liftM2
02:08:48 <kallisti> > (`replicateM` "abc") =<< [0..]
02:08:50 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
02:09:24 <kallisti> > replicateM 4 "abc"
02:09:25 <lambdabot>   ["aaaa","aaab","aaac","aaba","aabb","aabc","aaca","aacb","aacc","abaa","aba...
02:09:38 <kallisti> > replicateM 8 "abc"
02:09:40 <lambdabot>   ["aaaaaaaa","aaaaaaab","aaaaaaac","aaaaaaba","aaaaaabb","aaaaaabc","aaaaaac...
02:12:38 <sopvop> drdo: you want to name a traversal of graph, in which you decide which route to take, right?
02:13:28 * sopvop will chat about anything, doesn't want to start coding new thing in last 20 minutes till lunch .
02:13:38 <drdo> sopvop: Just think of an Iteratee
02:18:15 <VCommeLeVent> I must admit to be stil as confused as I always was.
02:19:08 <VCommeLeVent> Ohhh, with fold you don't mean the foldr or foldl functions?
02:19:13 <sopvop> drdo: traversal is either a fold or a map, right? (iteratee or not). So you can call it... traversal or map, or fold. Add 'path deciding' for scientificity.
02:19:57 <VCommeLeVent> sopvop, share with me what you got, I am intrigued
02:20:06 <VCommeLeVent> It itches my very soul, I have to know what it means.
02:21:28 <kallisti> VCommeLeVent: yes
02:21:51 <VCommeLeVent> kallisti, what?
02:21:55 <VCommeLeVent> What do you mean, it intrigues me
02:22:02 <VCommeLeVent> I have to know, it itches inside my very soul.
02:22:14 <drdo> sopvop: If you want to go down that road, i'll need formal definitions of fold and map
02:22:16 * hackagebot safecopy 0.7.0 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.7.0 (DavidHimmelstrup)
02:23:05 <VCommeLeVent> drdo, of map or fmap?
02:24:26 <drdo> I don't know, you are the one using the words
02:25:02 <bartavelle> is that ghc-vis thing supposed to work with something more complicated than lists of ints ?
02:25:08 <sopvop> drdo: Formal is hard. You should wait for someone like edwardk :)
02:25:09 <VCommeLeVent> Well, you originally used the word fold which left me confused, because I assumed you talked about the prelude functions foldr and foldl, but you don't seem to, right?
02:25:20 <VCommeLeVent> sopvop, formal is just Haskell code?
02:28:00 <sopvop> drdo: informally i understand what fold -> reduce object to something else (like fold on lists does). map -> change object keeping structure (fmap of Functor).
02:28:21 <sopvop> and both of them are folds :)
02:28:58 <drdo> That's not really what i mean
02:29:12 * sopvop maybe wrong
02:29:18 * VCommeLeVent is still very confused as to what drdo means.
02:30:22 <sopvop> drdo: I may have missed your original question, so there comes confusion.
02:31:20 * sopvop away
02:35:09 <merijn> VCommeLeVent: fold can be much more general than Prelude.foldr and Prelude.foldl
02:35:15 <merijn> VCommeLeVent: Take a look at Data.Foldable
02:36:08 <VCommeLeVent> Yeah, I know, I'm still a bit confused by what exacrly drdo is talking about and I want to knowww. ><
02:46:28 <Rc43> Hmm, I had problems with irc =/
02:46:36 <Rc43> So, what about this error: http://hpaste.org/75653 ?
02:47:03 <Rc43> I don't know if there were answers.
02:47:23 <fmap> Rc43: I've asked about ghc version
02:47:35 <ivanm> yeah
02:47:40 <Rc43> fmap, 7.4.1
02:47:47 <ivanm> looks like a clash between versions of Cabal
02:47:53 <ivanm> which is weird, I've never seen that before
02:48:00 <ivanm> Rc43: try ghc-pkg hide Cabal-1.16.0
02:48:02 <ivanm> then do that again
02:48:22 <ivanm> or, even easier: edit the .cabal file and make sure it only uses Cabal-1.14.*
02:48:46 <Rc43> Aaargh
02:48:47 <Cale> Here I'm using 7.4.1 and the only Cabal I have installed is 1.14.0
02:49:14 <Rc43> My cabal is 1.14.0, too.
02:49:59 <Rc43> Hackage talks that uuagc is ok with ghc-7.4.1.
02:50:17 <ivanm> yes
02:50:23 <ivanm> but you also have Cabal-1.16.0 installed
02:50:25 <ivanm> ghc-pkg list Cabal
02:50:30 <ivanm> _that_ seems to be the problem
02:51:22 <Rc43> ivanm, really, I have two versions =/
02:51:45 <Rc43> can't remember where can I have second from
02:52:37 <clsmith> hey all. i don't suppose there's an introductory guide to writing proofs of things like lambda calculus semantics? :D
02:53:05 <clsmith> being interested in programming language theory but being in no way a mathematician is harrrd.
02:53:16 <Rc43> ivanm, must I have this folder with ghc in my home?
02:53:33 <Rc43> ifanm, by "home" I mean /c/Users/UserName now.
02:53:42 <ivanm> do you mean ~/.ghc ?
02:53:59 <ivanm> if so, yes, if you're installing and building stuff locally with cabal-install
02:54:11 <Rc43> ivanm, (I am from windows now); I have folder C:\Users\UserName\AppData\Roaming\ghc
02:54:23 <Cale> clsmith: Sent you a link to a book in PM :)
02:54:27 <ivanm> I don't know how it works on windows
02:54:31 <Rc43> ivanm, but `type -a ghc` gives me other path
02:54:33 <clsmith> Cale: thanks! :)
02:54:43 <ivanm> Rc43: what's the contents of the folder?
02:55:29 <ivanm> Rc43: what's the contents of the folder?
02:57:39 <Rc43> ivanm, ghci configs (.conf and _history) and ghc-<version> folders with package.d folders in them; I tried to remove theml ghci continues to write into it
02:57:56 <ivanm> ghci won't be writing there
02:57:58 <ivanm> cabal-install does
02:58:00 <ivanm> you want them
02:58:15 <ivanm> well, not the ghc-<version> folders
02:58:25 <ivanm> why do you want to delete it?
02:58:45 <Rc43> ivanm, just test; recoverd back
03:01:23 <krey_> o/, i'm trying to enumerate natural transformations from (A+A)x(B+B) -> (AxB)+(AxB)+1. what's the best way of doing this? is it even tractable?
03:02:44 <Rc43> Why `cabal --version` gives me 1.14.0 and <home-folder>/ghc/ghc-<version> contains 1.16.0 ?
03:03:11 <Rc43> Ooh, there is <home-folder>/cabal too
03:08:00 <Rc43> Why uuagc installs cabal-1.16 even if I unregistered it?
03:09:56 <fmap> try to install with --constraint='Cabal-1.14.0'
03:11:53 <Rc43> fmap, is it correct syntax? cabal tells "expected package name followed by a constraint..."
03:12:56 <fmap> Rc43: sorry, --constraint='Cabal == 1.14.0'
03:14:52 <kc8qvp> Morning, gents.  And ladies, presumably.
03:16:57 <kc8qvp> I want to learn Haskell.  I usually use linux exclusively, and vim as an editor.  Which haskell compiler/package would be best for me for 1) use on windows and 2) learning?  GHC?  HUGS?  Also, would taking up Emacs at the same time be worthwhile, or does it not really matter?
03:17:26 <kc8qvp> I want to pick up LISP too at some point but probably not elisp.
03:17:37 <sopvop> kc8qvp: http://hackage.haskell.org/platform/
03:18:19 <kc8qvp> thanks.
03:18:56 <ousado> drdo: using these informal descriptions at the top: http://www.haskell.org/haskellwiki/Enumerator_and_iteratee, are you looking for the name of a thing that is both enumerator and iteratee where the enumerator part decides, (partially) based on some kind of feedback from the iteratee part, which item to produce next?
03:19:57 <drdo> ousado: Something like
03:20:22 <drdo> Mostly seeing if someone came up with a nice general way to do the "feedback" part
03:20:54 <drdo> Haskell's type system doesn't help
03:21:31 <drdo> *Something like that
03:21:36 <merijn> kc8qvp: Haskell Platform + GHC is the only serious way to start with haskell, regardless of OS
03:22:03 <merijn> kc8qvp: As for learning emacs, it depends on what editor you are used to and comfortable with
03:22:03 <drdo> I've been awake far too long, i need to sleep
03:22:47 <merijn> kc8qvp: If you don't know a good editor yet it will be worthwhile in the long run. If you're already intimately familiar with a proper editor other than emacs (vim!) then I wouldn't bother
03:23:29 <kc8qvp> ok.  I didn't know if emacs would have lots of features and capabilities that would make it particularly suited to writing haskell and/or lisp.
03:25:59 <sopvop> kc8qvp: https://github.com/haskell/haskell-mode for emacs. check here for vim - http://www.haskell.org/haskellwiki/Vim
03:26:02 <MasseR> If I'm not mistaken, arrows could provide something like this: (a -> b) -> (c -> d) -> (a, c) -> (b, d), as in do something for both of the 2-tuple values. I can't wrap my head around arrow types and can't hoogle a suitable function
03:26:17 <GnomeStoleMyBike> Hi All!
03:26:24 <merijn> kc8qvp: For Lisp the answer is likely yes. For Haskell, not so much (there's haskell mode, but vim has some stuff too and it probably doesn't matter all that much)
03:26:37 <fmap> @type (***)
03:26:38 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:26:48 <kc8qvp> thanks again guys.
03:26:52 <Rc43> fmap, constraint helped; thanks
03:27:21 <merijn> MasseR: Correct, the translation key for Arrows + functions is to realise that the function instance uses (->) as arrow
03:27:36 <fmap> > succ *** pred $ (2,2)
03:27:37 <lambdabot>   (3,1)
03:27:51 <merijn> MasseR: So "Arrow a => a b c" translates to "(->) b c" = "b -> c"
03:28:43 <fmap> MasseR: also note there is bifunctors package with such a function
03:28:53 <MasseR> merijn: The word is 'key'. I tried replacing the type of *** with (->) b c and now it makes sense
03:28:54 <fmap> (bimap)
03:29:23 <t7> is there an easy way to combine ranges?
03:29:50 <t7> like [(0,5), (6,10)] + (4,7) = [(0,10)]
03:32:17 * hackagebot tar 0.4.0.1 - Reading, writing and manipulating ".tar" archive files.  http://hackage.haskell.org/package/tar-0.4.0.1 (DuncanCoutts)
03:33:48 <fmap> dcoutts: ghc-7.6.1 compatibility release?
03:34:30 <dcoutts> aye
03:35:37 <astry> hello
03:35:39 <astry> i have a question
03:35:43 * sopvop wants patched directory-1.2 for < ghc-7.6.1 compatibility...
03:36:03 <dcoutts> sopvop: should be doable, just needs someone to do the work
03:36:10 <astry> what does this mean? type A = B -> C -> D
03:36:16 <dcoutts> t7: not that easy, but there's some code in cabal that does that, but specialised for Version numbers
03:36:26 <astry> does this mean that foo :: A is a synonym for foo :: B -> C -> D ?
03:36:40 <sopvop> dcoutts: just apply the patch. it's not breaking anything on 7.0.3 -> 7.6.1 :)
03:36:41 <ivanm> astry: yes
03:36:46 <astry> thanks guys
03:36:49 <ivanm> well, that "A" is a synonym for "B -> C -> D"
03:36:49 <astry> helpful as always :)
03:36:52 * sopvop is a  buildbot
03:36:55 <dcoutts> sopvop: what patch?
03:36:57 <astry> ivanm: gotcha
03:37:12 <sopvop> dcoutts: this one. http://hackage.haskell.org/trac/ghc/attachment/ticket/7262/fix_build.2.patch
03:37:18 * fmap wants patched bzlib and zip-archieve
03:37:36 <fmap> or rather zip-archive
03:37:45 <sopvop> guess no-one reads mail from trac :)
03:38:09 <astry> what is a good way to execute a binary as a subprocess, and run specific functions every time it writes something to stdout or stderr?
03:38:32 <astry> i looked at this but the docs make it seem a bit underdeveloped (the docs kinda suck): http://hackage.haskell.org/packages/archive/ports/0.4.3.1/doc/html/Control-Concurrent-Processes.html
03:39:59 <sopvop> astry: you cant construct it with System.Process http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html
03:41:34 <sopvop> astry: you can construct it.
03:42:13 <int-e> dcoutts: Ok, the latest cabal-install 1.16 from git also works :)
03:42:33 <dcoutts> int-e: ta
03:42:36 <Cale> astry: Once you have the Handles from createProcess (or one of the other related convenience functions), you can fork a thread or two in which you read from those.
03:42:55 <int-e> (oops, channel mismatch)
03:45:23 <t7> can i make this more pleasant?   (if s1 < s2 then s1 else s2, if e1 > e2 then e1 else e2)
03:45:35 <t7> oh min and max!
03:45:41 <t7> ignore me
03:47:06 <sopvop> t7: also - use guard expressions.
03:47:24 <Ferdirand> @type liftA2 (,) min max
03:47:25 <lambdabot> forall a. (Ord a) => a -> (a -> a, a -> a)
03:47:36 <t7> > 1 < 3 |  4
03:47:38 <lambdabot>   <no location info>: parse error on input `|'
03:48:03 <sopvop> > case () of () 1 < 3 | 4
03:48:04 <lambdabot>   <no location info>: Parse error in pattern
03:48:20 <astry> Cale: i'm not sure how to fork. but, i thought it would work like this: i define my callbacks for stdout and stderr, and create the process telling it what callbacks to use.
03:49:23 <astry> oh, i get the handles directly
03:49:27 <sopvop> > case () of _ | 1 < 3 | 4
03:49:29 <lambdabot>   <no location info>: parse error on input `|'
03:49:31 <sopvop> damn
03:49:44 <sopvop> > case () of _ | 1 < 3 -> 4
03:49:45 <lambdabot>   4
03:49:47 <astry> what about simply looping some code which looks into each handle?
03:50:14 <Cale> astry: Right, well, you presumably want to wait on both handles, and the easiest way to do that is just to forkIO a couple threads
03:51:58 <t7> > abs (9 - 10) :: Word8
03:52:00 <lambdabot>   255
03:52:02 <user3458734985> goodday, can I ask a small favour. What is the best way to represet a data set of stock data? At the moment i have been useing lists of individual stocks, with elements of the lists starting with the date element. Is there a better way to set up the program? I can see it getting very hard to mannage.
03:52:02 <astry> Cale: hmm
03:52:03 <t7> :|
03:52:21 <sopvop> astry: forever $ do isThereErrorWaiting <- hReady (stderrHandle)
03:52:25 <astry> Cale: btw, i'm looking at this api, and there doesn't seem to be a way to get the PID of the subprocess. do you know of such a way?
03:52:45 <astry> sopvop: right, that's a useful snippet of code, thanks a lot
03:52:53 <astry> it'll save me a lot of browsing :)
03:53:44 <sopvop> asty: you can exit from forever if you run MaybeT IO (or EitherT IO) with it, and exit with Nothing or Left
03:53:55 <Cale> astry: All this stuff is cross-platform, so you don't get a pid, but you get a ProcessHandle which you can use for much the same things.
03:53:57 <sopvop> Either can return you a value.
03:54:43 <astry> Cale: i need a PID so that a linux process can eventually kill the subprocess if it hangs and my haskell program doesn't kill it
03:54:51 <astry> i store this pid in a file
03:56:07 <t7> @hoogle Map k v -> k -> (v -> v) -> Map k v
03:56:07 <lambdabot> Data.Map adjust :: Ord k => (a -> a) -> k -> Map k a -> Map k a
03:56:54 <sopvop> astry: I'm not sure, but maybe if you create process with create_group = False. The process will be killed with your haskell process.
03:57:04 <astry> that's not good enough
03:57:08 <astry> processes can become disowned
03:57:27 <astry> my haskell process might not get killed, it might just hang up
03:57:32 <astry> etc etc
03:57:49 <sopvop> astry: maybe this will help. http://www.haskell.org/ghc/docs/latest/html/libraries/unix-2.6.0.0/System-Posix-Process.html
03:57:51 <astry> i really need to check if the specific subprocess is running otherwise i can't ensure atomicity
03:59:56 <cods> I'm puzzled by this short program: http://hpaste.org/75657  What is the value of `nm' when calling walk in repmin? That's probably obvious, but I'm staring at it for 10 minutes without being able to figure it out.
04:00:40 <astry> sopvop: hmm... i don't exactly see how that helps..
04:01:07 <maukd> cods: just change repmin to make it return mn as well
04:01:10 <astry> sopvop: there's executeFile but it is missing both stdout/stderr feedback, and reporting the pid
04:01:11 <maukd> then you can see what it is
04:01:37 <sopvop> astry: I'm searching through 'unix' package right now :)
04:01:52 <Cale> cods: why, it's the same mn that walk produces as its result of course :)
04:02:07 <astry> yeah i'm looking through hackage as well
04:02:08 <astry> :)
04:02:12 <Cale> (as the first part of its result)
04:02:14 <astry> maybe we'll converge at some point :)
04:02:43 <Cale> astry: I think it may be easier to get the child process to record its own pid somewhere?
04:03:38 <cods> maukd: sure, ok it returns 1 (as I expected). I just don't understand how we can pass mn to walk.. while it is defined nowhere, except as the name of the result to the call to the function itself!
04:04:09 <astry> Cale: that is not possible
04:04:20 <astry> Cale: plus, it's error-prone because it's not atomic
04:04:29 <Cale> cods: That's a perfectly good definition though :)
04:04:47 <cods> Cale: I can't figure how it can work
04:04:51 <maukd> cods: time travel
04:05:11 <Cale> cods: How does fac 0 = 1; fac n = n * fac (n-1) work?
04:05:20 <Ferdirand> @type (liftA2.liftA2) (,) min max
04:05:21 <lambdabot> forall a. (Ord a) => a -> a -> (a, a)
04:05:22 <maukd> we're sending (some part of) the return value back into the function as an argument
04:05:41 <astry> this looks interesting...
04:05:42 <astry> http://www.haskell.org/pipermail/haskell-cafe/2011-November/096797.html
04:05:57 <cods> Cale: that I can understand. No problem with this one.
04:06:01 <Cale> cods: After all, if fac isn't defined yet, how can we use it inside the definition of fac?
04:06:01 <astry> but, you still only get the pid of the haskell wrapper
04:06:05 <astry> not the pid of the program itself
04:06:23 <astry> so, this doesn't really help that much......
04:06:31 <cods> Cale: hmm, I need to think more about that.
04:06:45 <Cale> Or, let's take another example, if that one is too easy to understand :)
04:07:54 <maukd> preferably a non-function value
04:08:02 <Cale> facs = 1 : zipWith (*) facs [1..]
04:08:16 <maukd> I'd prefer an intermediate step first
04:08:22 <maukd> > let ones = 1 : ones in ones
04:08:23 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:08:28 <cods> Cale: actually I can understand this one too :) (thinking in term of thunk)
04:08:55 <Cale> Yeah, you don't even need to think at the level of thunks, just think in terms of expressions.
04:08:57 <cods> I'm trying to relate that to my question, but I've some difficulties :/
04:09:18 <Cale> cods: So, let's apply walk to some specific tree
04:09:27 <Cale> or, rather repmin
04:09:31 <cods> sorry, I need to go for 30 minutes.
04:09:35 <astry_> sorry i got disconnected
04:09:45 <cods> but I will read whatever you will say :)
04:09:46 <maukd> > let walk xs = 1 : zipWith (*) xs [1 ..]; repmin = mn where mn = walk mn; in repmin
04:09:48 <lambdabot>   [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800...
04:10:00 <Cale> cods: Well, let me know when you're back
04:10:00 <maukd> cods: ^ now with a structure more similar to your code
04:11:58 <bls> astry: forgive me, shouldn't forkProcess just work? (I'm on win right now, can't test from home)
04:13:57 <sopvop> bis: It does not give you process id
04:14:13 <bls> forkProcess :: IO () -> IO ProcessID
04:14:18 <sopvop> Oh
04:14:21 <astry_> hmm
04:14:30 <astry_> yes bls
04:14:36 <bls> your child can do whatever it wants to record pid and then exec
04:14:36 <astry_> but that's a haskell process..
04:14:45 <bls> right, but haskell gets replaced when u exec
04:14:50 <maukd> what's a "haskell process"?
04:14:52 <bls> that's what exec does normally
04:15:00 <astry_> bls: really?
04:15:00 <astry_> hmm
04:15:02 <bls> yeap
04:15:13 <bls> man 2 exec (think it's section 2, on win)
04:15:13 <astry_> let me try a quick mockup
04:15:29 <sopvop> So thats why exec type ends with (IO a) and function ends with 'undefined'!
04:15:59 <t7> @pl bounds rs = (fst $ head rs, snd $ last rs)
04:16:00 <lambdabot> bounds = ap ((,) . fst . head) (snd . last)
04:16:13 <bls> astry_: you will get screwed if your subprocess is badly behaved though; if IT spawns subprocesses things can get difficult
04:16:30 <zomg> ap . ap (gangnam style)
04:18:47 <fmap> @type \rs -> (fst $ head rs, snd $ last rs)
04:18:48 <lambdabot> forall a b. [(a, b)] -> (a, b)
04:19:02 <fmap> @type fst . head &&& snd . last
04:19:03 <lambdabot> forall a b. [(a, b)] -> (a, b)
04:23:13 <astry_> it works really well
04:23:22 <astry_> thanks for the tip bls
04:23:35 <astry_> btw, if the subprocess spawns things, it's out of my hands already
04:23:44 <astry_> so i'm not going to worry too much
04:23:49 <bls> no worries, I could use the karma coz I havea lot of dumb Haskell questions ;)
04:24:01 <astry_> i expect people to do things which are stupid, but not things which are too stupid :)
04:24:09 <astry_> bls: cool, what questions? :)
04:24:14 * sopvop unloads truck of karma on bls
04:24:23 <astry_> haha
04:24:31 <astry_> like in that back to the future scene..
04:24:37 <astry_> except it was a truck of something else!
04:24:46 <bls> lol, ok, so silly question #1
04:24:48 <sopvop> It was bad karma
04:24:52 <astry_> haha
04:26:06 <bls> I'm using fclabels and it's telling me to hide the (.) operator and id from the Prelude
04:26:28 <sopvop> import Prelude hiding ((.), id); import Control.Category
04:26:38 <bls> but I'm copying and pasting a fairly trivial function from StackOverflow, and obvs it wants .
04:26:52 <bls> ummm so stylistically, what do people do about things like that?
04:27:01 <merijn> bls: The . in Prelude is very restricted (it only works on functions)
04:27:21 * sopvop also notes what fclabels is not the FOTM now. lens are trending.
04:27:27 <merijn> bls: There are definitions of (.) (for example in Control.Category) which are more general (i.e. they work on functions and *many* other things)
04:27:30 <astry_> import qualified FCLabels; <.> = FCLabels..
04:27:33 <astry_> or something like that
04:28:01 <bls> ohno this is going to turn into recursive questions
04:28:02 <astry_> there's probably a syntax error in that line
04:28:11 <astry_> the mandelquestion
04:28:28 <fmap> bls: fairly trivial function from StackOverflow should be happy with Control.Category..
04:28:30 <ozgura> is there a simple way to make cabal use -fllvm only if llvm is available on the machine?
04:28:41 <bls> fmap and all: thanks, that makes sense
04:29:09 <astry_> merijn: i could never figure out why people use . and not $?
04:29:20 <astry_> like, i've never ran into a line of code where i had to use (.)
04:29:21 <dcoutts> ozgura: I don't think there is. But perhaps cabal isn't the place to do that, perhaps ghc.
04:29:28 <merijn> astry_: Really? I do all the time
04:29:30 <astry_> why do people use (.) ?
04:29:47 <astry_> :t (.)
04:29:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:29:51 <ozgura> dcoutts: hmm. my program runs faster with -fllvm but not all machine have it.
04:29:53 <mroman> astry_: To combine functions.
04:30:17 <mroman> > filter (>11) . map (join(*)) $ [1..10]
04:30:19 <lambdabot>   [16,25,36,49,64,81,100]
04:30:47 <dcoutts> ozgura: sure, I understand the problem.
04:30:55 <ozgura> dcoutts: thanks anyway. gotta go now.
04:31:03 <astry_> what does the * do?
04:31:12 <mroman> It multiplies two numbers ;)
04:31:16 <ozgura> dcoutts: I will resort to more mechanical solutions for now :)
04:31:17 <astry_> oh
04:31:18 <astry_> right
04:31:18 <mroman> > 3 * 5
04:31:19 <lambdabot>   15
04:31:27 <dcoutts> ozgura: e.g. I think ghc ignores the -fasm flag on platforms where it's not supported
04:31:28 <astry_> @hoogle join
04:31:28 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
04:31:29 <lambdabot> package join
04:31:29 <lambdabot> System.FilePath.Windows joinDrive :: FilePath -> FilePath -> FilePath
04:31:38 <mroman> > filter (>11) . map (\c -> c * c) $ [1..10]
04:31:40 <lambdabot>   [16,25,36,49,64,81,100]
04:31:41 <mroman> if you don't know join
04:31:50 <mroman> join(*) == \c -> c * c
04:32:15 <mroman> > let squ x = x * x in filter (>11) . map squ $ [1..10]
04:32:17 <lambdabot>   [16,25,36,49,64,81,100]
04:32:34 <astry_> mroman: right, but i can write that with $ in place of the .
04:32:43 <astry_> and it does the same thing
04:32:55 <fmap> mroman: what funny with this example is that `filter (>11) $ map (\c -> c * c) [1..10]' is simpler
04:33:04 <astry_> btw, what can the Control.Monad (.) do that the Prelude one can't?
04:33:21 <merijn> astry_: I frequently write functions that are structuraly similar to things like
04:33:24 <merijn> :t map (chr . sum . map ord)
04:33:26 <lambdabot> [[Char]] -> [Char]
04:33:42 <mroman> > map (chr $ sum $ map ord)
04:33:43 <lambdabot>   Couldn't match expected type `[a]'
04:33:43 <merijn> astry_: rewriting that with $ is very cumbersome
04:33:43 <lambdabot>         against inferred type `[GHC.Type...
04:33:51 <mroman> > (map (chr $ sum $ map ord)) [1..10]
04:33:52 <lambdabot>   Couldn't match expected type `[a]'
04:33:52 <lambdabot>         against inferred type `[GHC.Type...
04:33:57 <mroman> hm.
04:33:58 <merijn> mroman: That's a type error
04:34:01 <mroman> Yeah.
04:34:02 <mroman> I noticed.
04:34:04 <astry_> map (chr . sum . map ord) ["abc", "def", "ghi"]
04:34:07 <astry_> > map (chr . sum . map ord) ["abc", "def", "ghi"]
04:34:08 <mroman> > (map (chr $ sum $ map ord)) [äbc"]
04:34:09 <merijn> You need an extra ($) and sectioning syntax
04:34:09 <lambdabot>   <no location info>:
04:34:10 <lambdabot>      lexical error in string/character literal at end o...
04:34:10 <lambdabot>   "\294\303\312"
04:34:14 <mroman> damn deadkeys
04:34:26 <mroman> > (map (chr $ sum $ map ord)) ["abc"]
04:34:27 <lambdabot>   Couldn't match expected type `[a]'
04:34:27 <lambdabot>         against inferred type `[GHC.Type...
04:34:32 <maukd> :t interact (unlines . map (show . length) . lines)
04:34:34 <lambdabot> IO ()
04:34:37 <merijn> mroman: No, you nee an extra $
04:34:41 <astry_> > map (chr . sum . map ord) ["abc", "def", "ghi"]
04:34:43 <lambdabot>   "\294\303\312"
04:34:49 <astry_> heh.
04:34:50 <mroman> > (map (chr $ sum $ map ord)) $ ["abc"]
04:34:51 <lambdabot>   Couldn't match expected type `[a]'
04:34:51 <lambdabot>         against inferred type `[GHC.Type...
04:34:56 <maukd> > (unlines . map (show . length) . lines) "a\nbc\ndef\n"
04:34:57 <mroman> I don't like spamming $ anyway
04:34:59 <lambdabot>   "1\n2\n3\n"
04:35:05 <merijn> mroman: If it is at all possible, possible you need a lambda too
04:35:15 <mroman> >  (+3) . (+5) $ 5
04:35:17 <lambdabot>   13
04:35:20 <mroman> >  (+3) $ (+5) $ 5
04:35:21 <lambdabot>   13
04:35:24 <merijn> astry_: It computes the "average" character in a string, which is a completely stupid idea :p
04:35:29 <mroman> Too many $ just look weird.
04:35:34 <astry_> merijn: :P
04:35:38 <maukd> > (+3) $ (+5) 5
04:35:40 <lambdabot>   13
04:35:50 <astry_> mroman: ok i can see where . is useful sometimes..
04:35:56 <astry_> maybe i should start forcing myself to use it
04:36:01 <maukd> > (+) (+) 3 5 5
04:36:03 <lambdabot>   13
04:36:05 <astry_> so that i can see where it is applicable more easily
04:36:25 <mroman> > (*3) $ (+5).(*3) $ 7
04:36:27 <lambdabot>   78
04:36:31 <mroman> > (*3) $ (+5) $ (*3) $ 7
04:36:32 <merijn> Chaining functions without giving a name to the results is the usual approach
04:36:32 <lambdabot>   78
04:36:37 <maukd> (*) (+) (*) 3 5 3 7
04:36:41 <maukd> > (*) (+) (*) 3 5 3 7
04:36:42 <astry_> merijn: so what is that "more general" . about?
04:36:43 <lambdabot>   120
04:36:53 <merijn> :t Control.Category..
04:36:54 <lambdabot> parse error on input `Control.Category..'
04:37:00 <merijn> :t (Control.Category..)
04:37:01 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
04:37:08 <merijn> :t (Prelude..)
04:37:09 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
04:37:19 <merijn> astry_: More general than what?
04:37:23 <astry_> what can the C.C one be used for?
04:37:32 <merijn> Any category
04:37:38 <merijn> Which is just a typeclass
04:37:39 <astry_> what is a category in haskell
04:37:40 <bls> merijn: is that like, a morphism?
04:38:04 <merijn> bls: I think it is functor composition? but my category theory-fu is weak
04:38:06 <astry_> can you give me an example of code which uses categories?
04:38:28 <bls> merijn: yeah woops, def not
04:38:30 <merijn> astry_: (->) (i.e. functions) are just a instance of Category
04:38:37 <astry_> i realize
04:38:42 <astry_> but can you give me other instances?
04:39:07 <merijn> astry_: You'd have to ask someone like edwardk :)
04:39:17 <astry_> who is edwardk
04:39:27 <astry_> i think he's not here
04:39:28 <mroman> :i Category
04:39:49 <astry_> huh what does :i do :)
04:39:51 * astry_ googles
04:39:55 <merijn> astry_: He's in here frequently and writes ridiculously general code using stuff like Control.Category
04:40:08 <astry_> nice
04:40:09 <merijn> astry_: ":i" = :info in ghci and prints out loaded instances for a typeclass
04:40:17 <mroman> In ghci it shows you infos about instances and stuff.
04:40:18 <astry_> yeah merijn
04:41:16 <astry_> hoogle doesn't have a way to search for all instances of a class does it?
04:41:20 <cods> Cale: I'm back. So, I think that the purpose is to pass as argument to the function the value it *will* return later, right?
04:41:25 <astry_> also all values of a type, or all functions that consume a type
04:41:30 <Cale> cods: yes
04:42:10 <Cale> cods: of course, time is kind of a funny thing to talk about, but operationally, you're not going to know that result straight away
04:42:57 <cods> that's a curiously interesting construct of the language :)
04:43:11 <mroman> astry_: Maybe hayoo does?
04:43:14 <mroman> But I doubt it.
04:43:24 <maukd> time travel is ok as long as you don't create any paradoxa
04:43:48 <mroman> :i at leasts shows you all instances of a class in all currently "imported" modules
04:44:32 <sopvop> cods: I believe this is relevant http://www.haskell.org/haskellwiki/Tying_the_Knot
04:45:07 <Cale> cods: In an imperative language with pointers, you might do the equivalent of this by defining a new pointer at the beginning, and traversing the tree, constructing a new tree with the same shape as the old one, but with that pointer in its leaves, and once you'd calculated the minimum, you'd set the value of the pointer to that, yeah?
04:45:30 <Cale> (I mean, the value that the pointer points to)
04:45:42 <cods> Cale: I see your point.
04:45:48 <sopvop> cods: this explanation looks simpler http://en.wikibooks.org/wiki/Haskell/Laziness#Tying_the_knot
04:46:15 <cods> sopvop: thanks. Indeed "tying the knot" appears (IIRC) in the paper http://www.cs.indiana.edu/~sabry/papers/yield-pp.pdf that leads me to this question.
04:46:53 <merijn> The function definition still makes me go "my mind is full of fuck"
04:46:59 <Cale> cods: So this is not so very different -- we're sticking the variable mn, which we get as a parameter into the leaves of the tree
04:47:03 <merijn> And I thought I was kinda getting the hang of this haskell thing :p
04:47:21 <sopvop> I avoid such circular things by emulating pointers with Map :)
04:47:37 <Cale> cods: and we're identifying the first part of the pair which is the result of this function with that variable
04:49:39 <hpaste> cduez pasted “Wtf” at http://hpaste.org/75659
04:49:42 <Cale> When we apply  walk mn (Leaf 1), we don't need to know anything about what mn is in order to produce our result
04:49:51 <Cale> we know the result is (1, Leaf mn)
04:50:04 <cduez> Why ghci keep saying Couldn't match expected type `IO t0' with actual type `Integer' ?
04:50:23 <merijn> cduez: Because you're trying to pass an IO value to something that expects an Integer :)
04:50:24 <Cale> cduez: because add 1 2 is an Integer
04:50:24 <Ferdirand> missing return ?
04:50:38 <Cale> cduez: and main is always supposed to be an IO action
04:50:38 <merijn> Eh, reverse what I just said
04:50:44 <sopvop> cduez: val <- thatIOvalue
04:50:50 <Cale> cduez: You maybe want something like   main = print (add 1 2)
04:51:05 <cods> Cale: thanks for the explanations. Really helpful.
04:51:10 <cduez> omg
04:51:17 <cduez> thx everybody
04:51:22 <Cale> No problem
04:51:30 <Cale> Feel free to ask any questions :)
04:53:38 <sopvop> Cale: Any questions? So, what happens when unstoppable force meets unmovable object?
04:53:50 <Jafet> Type error
04:54:15 <trotro> sopvop, it's creation :)
04:54:37 <sopvop> trotro: Only in PHP
04:54:52 <trotro> i was thinking about Elder Scroll mythology :)
04:55:02 <Cale> sopvop: What does unstoppable mean?
04:55:40 <Cale> If it means "constant", then the force is applied but does no work.
04:56:13 <trotro> it's a contradiction, nothing logical is possible
04:56:44 <sopvop> So, that really is a Type error.
04:57:17 <merijn> The existence of an unstoppable force precludes the existence of an unmovable object
04:57:21 <sopvop> 'You will find all the answers in this book. Bible of typed lambda calculus'
04:57:29 <trotro> :D
04:57:32 <merijn> Philosophy majors really suck at proper definitions...
04:57:39 <trotro> merijn, I don't agree
04:57:56 <Cale> Nobody defined either one of these things yet.
04:58:56 <kc8qvp> I like cale's answer best.
04:59:17 <Cale> I've never moved in my life. No matter where I've gone, I've always been right here.
04:59:21 <maukd> what is a motion
04:59:31 <kc8qvp> also, I was a philosophy major :/
04:59:39 <trotro> #philosophy
04:59:52 <kc8qvp> can't stand that channel.
05:00:03 <kc8qvp> maybe #misanthropes
05:00:31 <Cale> Does the Earth go around the Sun, or does the Sun go around the Earth?
05:00:38 <Philippa> merijn: you should see the graduates I've met IRL :-(
05:00:41 <Philippa> Cale: "yes"
05:00:46 <sopvop> Cale: Both.
05:00:49 <bls> Cale: one answer does make the calculations a lot simpler
05:00:53 <Cale> good answers :)
05:01:18 <trotro> nothing move
05:01:26 <trotro> it's the referential which deforms
05:01:34 <Cale> Maybe the Sun and Earth are both held on a fixed line.
05:01:46 <trotro> s/deforms/distorts/
05:02:24 <parcs`> > 2.032^2
05:02:25 <lambdabot>   4.129024
05:02:57 <Cale> heh, I'm reminded of page 15 of http://cheng.staff.shef.ac.uk/morality/morality.pdf
05:03:26 <Cale> Oh no, I'm sitting opposite a philosopher: A play in one act by Eugenia Cheng
05:04:16 <Cale> "This is utterly non-fictional and any resemblance to living characters is entirely deliberate"
05:05:09 <bls> heh, yep. duct tape and hammers not only solve all physical problems -- they can also be applied directly to the philosopher where neccesary
05:05:38 <otters> what version of GHC does base-4.6.0.0 correspond to?
05:05:46 <Saizan> tsk, they are both still and the earth is spinning
05:05:48 <sopvop> 7.6.1
05:06:11 <otters> so that's not something I should be using yet
05:07:03 * sopvop sits in a room with ~70 artists.
05:07:23 <kc8qvp> Cale: you baited me into a philosophical discussion and now I have no where on-topic to have it :/  I may explode.
05:07:35 <bls> sopvop: is there a group noun for that situation?
05:07:59 <merijn> kc8qvp: Pretty sure that's on topic in -blah
05:08:00 <sopvop> Half of them think they are good at psychology, the other half think they are philosophers. Most are photographers, some are directors.
05:08:23 <sopvop> No one to talk to about programming :(
05:08:32 <sopvop> bls: I can't make one up. help?
05:08:43 <kc8qvp> A pallette of artists?  A collaboration of artists?
05:08:54 <sopvop> CG studio with artist-monkeys
05:08:59 <trotro> sopvop, wanna talk about programming ? What do you think about singleton pattern ?
05:09:13 <bls> ;)  and to keep it on topic, a disagreement of lisp programmers, and a ? of haskell programmers?
05:09:15 <sopvop> trotro: I think it should not exist.
05:09:21 <otters> does ghc-pkg have an easy way to unregister old versions of packages when I have multiple versions
05:09:25 <trotro> sopvop, thx
05:09:45 <Saizan> ghc-pkg unregister pkg-ver
05:09:54 <otters> huh
05:10:27 <otters> oh wait, I'm totally in the cabal-dev sandbox right now so it doesn't matter
05:12:06 <Cale> I have this feeling that philosophy would get a whole lot more done if philosophers would just agree on definitions, and try harder not to conflate them, perhaps through the consistent use of subscripts. :D
05:12:50 <bls> ok so there is Data.Lenses, Data.Label, Data.Accessors, and I should be using Data.Lenses?
05:12:59 <Cale> bls: Control.Lens
05:13:14 <Cale> http://hackage.haskell.org/package/lens-3.0.1
05:13:16 <otters> dibs on the next Lens prefix
05:13:36 <otters> bls: yeah, just check out that diagram, that's the library you want
05:13:49 <bls> lol
05:13:57 <mcstar> i think only retired scientists should be allowed to have philosophical thoughts
05:13:58 <sopvop> lens are awesome.
05:14:03 <mcstar> by law
05:14:04 <kc8qvp> Cale: you mean equivocate less?
05:14:09 <Cale> kc8qvp: yes
05:14:30 <trotro> What is lens ?
05:14:40 <mcstar> plural of len
05:14:40 <sopvop> that is http://hackage.haskell.org/package/lens-3.0.1
05:14:41 <hvr> sopvop: like bow ties?
05:14:44 <Cale> kc8qvp: All such identifications should be more explicit, and the analogies between them ought to be named.
05:15:17 <sopvop> are you mocking my limited English?
05:15:28 <merijn> trotro: They're a neat abstraction for composable getter+setter combinations in functional programming
05:15:36 <trotro> ok
05:15:47 <trotro> it's something I can install with cabal from haskell platform ?
05:15:55 <hvr> mcstar: how is the plural of a plural called btw?
05:15:55 <zomg> public Lens getFoo() { ... }
05:15:58 <zomg> erm
05:15:58 <kc8qvp> Cale: well, a lot of philosophy is just attempting to create a strict/accurate definition of an intuitive concept, like 'knowledge'.  a lot of other times terms of art are introduced by giving definitions for words that don't match their dictionary definition.  but equivocation is simply an error.
05:16:09 <merijn> trotro: Yes, Control.Lens (lens) and Data.Lens (data-lens) are the best place to start
05:16:17 <trotro> cool
05:16:21 <trotro> i'll have a look
05:16:21 <Cale> We should make T-shirts with: What part of "type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b" don't you understand?
05:16:23 <trotro> thx
05:16:37 <merijn> trotro: The first one is more theoretically sounds and has more built in stuff. The latter is probably significantly easier to start with and understand
05:16:42 <mcstar> 'you no follow?'
05:16:44 <zomg> Cale: do it :D
05:17:04 <merijn> Cale: I swear, I understood 90% of data-lens in two days. I still don't understand lens xD
05:17:05 <bls> oooookay, before I so just to clarify; I'm just trying to struct up a binary file format header.... should I be worried that I will not initially understand how that machinery works?
05:17:13 <mcstar> hvr: collection of .., bunch of... ?
05:17:21 <trotro> merijn, ok
05:17:21 * sopvop uses lens without understanding.
05:17:27 <sopvop> Guess it's amoral
05:17:41 <hvr> mcstar: so 'lenses' bunch-of 'len'?
05:17:43 <merijn> sopvop: Me too, but it makes it hard to search for operators :p
05:18:03 <mcstar> argh, no
05:18:09 <merijn> sopvop: Other than directly querying edwardk ;)
05:18:09 <mcstar> anyway, this is moot
05:18:26 <merijn> Holy crap!
05:18:34 <merijn> I just understood the Lens signature!
05:18:44 <mcstar> if you have 2 apples, and then you have 2 apples again, you wont have appleses
05:18:47 <mcstar> only 4 apples
05:19:15 <mcstar> but you can say, that you have 2 bunches of apples
05:19:16 <sopvop> you will have two times two apples.
05:19:29 <merijn> My mind is blown
05:20:27 <Cale> kc8qvp: A lot of the philosophy of mathematics that I've read ends up seeming horribly unrealistic by equivocating different notions of truth. Specifically it's often formal truth and empirical truth, or even stranger more ill-defined notions.
05:21:11 <mcstar> teaching philosophy is an industry
05:21:18 <mcstar> but noone needs that kind of industry
05:21:21 <trotro> There three truth : the relative truth, the absolute truth and the true truth
05:21:37 <mcstar> and my truth
05:21:42 <mcstar> so thats 4
05:21:46 <kc8qvp> it kills me that so many people are anti-philosophy, when at it's core philosophy is just the advocacy and practice of clear thinking.
05:21:47 <merijn> Cale: If only they had a type system to keep different truths separated...
05:22:04 <merijn> I'm pro-philosophy but anti-philosopher :>
05:22:08 <mcstar> hehe
05:22:12 <mcstar> i like that merijn
05:22:13 <Cale> merijn: HOMOTOPY TYPE THEORY TO THE RESCUE!
05:22:32 <merijn> I prefer talking philosophy with theoretical computer scientists, mathematicians and phycisists
05:22:43 <mcstar> yeah
05:22:48 <sopvop> I'm philosophy Chaotic-neutral.
05:23:02 <merijn> sopvop: I'm chaotic-neutral everything :)
05:23:04 <trotro> chaotic-neutral...
05:23:16 <mcstar> whats that?
05:23:17 <Cale> kc8qvp: But isn't that what mathematics is?
05:23:36 <kc8qvp> Cale: Mathematics is a subset of philosophy, isn't it?
05:23:39 <sopvop> mcstar: Nerd joke, philosophers don't undrestand.
05:24:17 <trotro> kc8qvp, no it's the opposite
05:24:28 <trotro> philsophy is a subset of mathematics
05:24:50 <trotro> everything which belongs to logical world belongs to mathematics
05:24:50 <kc8qvp> I don't really see how that could be true.
05:25:09 <trotro> if you got axiom and rules it's mathematics
05:25:13 <trotro> otherwise it's art
05:25:13 <sopvop> At first, there was only philosophy. So math is child of philosophy, but it's no a subset of it.
05:25:24 <trotro> at first it was the same thing
05:25:31 <mcstar> at first, there was darkness..
05:25:51 <mcstar> no, at first there was the beginning
05:26:08 <mcstar> but if everything begins with a beginning, how can anything begin at all?
05:26:13 <trotro> there was no beginning
05:26:23 <Cale> Philosophy and mathematics are both trying to use logical systems of reasoning to accomplish certain goals.
05:26:33 <mcstar> but, everything that has a beginning has an end
05:26:37 <mcstar> i see the end coming
05:26:41 * sopvop random joke: Using gentoo - I'm like god. Building the world takes 7 days.
05:26:42 <kc8qvp> logic is a subset of philosophy, math is a subset of logic.
05:26:43 <mcstar> the darkness spreading
05:26:51 <mcstar> and you are theonly one who stands in his way
05:26:54 <mcstar> Smith
05:27:03 <trotro> mcstar, and semidroite how do you call that
05:27:04 <trotro> ?
05:27:11 <trotro> [0, infinity[ ?
05:27:26 <trotro> yes [0, 1[ got a beginning but no end
05:27:47 <Philippa> Philosophy is a subset of talking out of your arse, and talking about sets is a subset of philosophy
05:27:47 <mcstar> trotro: ofc it has an end
05:27:55 <mcstar> its called infinity
05:27:56 <merijn> kc8qvp: Math a subset of logic? I know many mathematicians and logicians that would take offense to your statement
05:28:14 <mcstar> trotro: anyway, what KIND of infinity? countably many? uncontably?
05:28:16 <mcstar> more?
05:28:29 <trotro> mcstar, it's not the end
05:28:32 <merijn> Cale: Math seems to be the more productive of the two, though xD
05:28:41 <trotro> if you're inside there is no end
05:28:54 <Philippa> (Philosophy: the study of how to camoflage your bullshit)
05:29:00 <byorgey> what on earth are we discussing here?  Can we get back to Haskell please?
05:29:07 <trotro> Philippa, today it's that, sic....
05:29:09 <kc8qvp> byorgey: you have a haskell question?
05:29:33 <byorgey> kc8qvp: no, but someone might
05:29:33 <Cale> merijn: yes, and the reason is that in mathematics, we stick to things which we can formalise, so arguments about all but the most primitive things *tend* to be resolved by the formalism
05:30:22 <Cale> Mathematicians I think are a bit more willing to bend their idea of something to what the formalism says it ought to be, rather than starting over with a new formalism.
05:30:32 <Cale> This isn't always true
05:30:53 <Philippa> mmm, and sometimes the question is "how can I transform old formalism into appropriate new one?"
05:31:10 <mcstar> mathematics is more than formalism
05:31:12 <mcstar> at least today
05:31:15 <Philippa> (what do you mean, we have a tendency to want to build CCCs out of everything?)
05:31:19 <mcstar> you have to have a bunch of intuition
05:31:24 <Cale> mcstar: yes, but it has a formal skeleton
05:31:33 <mcstar> yes, but thats for checking something
05:31:37 <mcstar> not deriving a result
05:31:49 <alpounet> it helps deriving results though
05:32:03 <Philippa> well, at least we're heading to a more interesting holy war :p
05:32:03 <Cale> I totally agree that you need more than just a formalism to get work done.
05:32:24 <Cale> But I think it's a key ingredient to not ending up in a morass of disagreement.
05:32:25 <Philippa> Intuition: that which bails you out when nobody's formalised what you're handwaving about yet
05:33:04 <mcstar> Cale: ofc, thats what hilbert dreamt about
05:33:31 <mcstar> so now back to the limitations of formalism
05:33:45 <Cale> mcstar: Hilbert had grander ideas than I'm talking about
05:34:00 <trotro> Cale, which was ? (the idea)
05:34:11 <mcstar> afaik he had great dreams of formalizing everything
05:34:22 <trotro> like mao :)
05:34:23 <Philippa> formalisms have a way of guiding proofs
05:34:27 <mcstar> little did he know about he limitations of formal systems
05:34:34 <mcstar> the*
05:34:38 <Philippa> well, he led to us discovering some of them
05:34:49 <Philippa> the Hilbert Program is an important landmark
05:34:50 <Cale> trotro: The idea that there should be a complete and consistent formalism in which universal statements about the natural numbers can be discussed.
05:35:24 <bls> where "complete" has a somewhat specialised meaning, I think
05:35:53 <bls>  like, you should be able to prove all the things in the system which are true
05:36:07 <trotro> it's atheorem (of hilbert) that true = provable
05:36:17 <trotro> if we stick to first order logic
05:36:22 <trotro> which is sufficent :)
05:37:03 <Cale> But an example of the kind of problem I'm talking about is how people treated the notion of complex numbers with suspicion and doubt, and very little work was done on them for about a century after people started using them a little shamefully, because it wasn't so clear at the time how to know whether they "really existed" as mathematical things.
05:37:46 <mcstar> didnt know that
05:37:51 <Philippa> Cale: "what are these algorithm things and is the notion relevant in all programming languages?"
05:37:54 <merijn> Philippa, Cale: I usually laugh at people who try to avoid formalisation. I just spent the past week formalising an algorithm I used to handwave I did find several interesting optimisations and a better feeling of correctness :)
05:38:10 <lcfrs> Is it correct to say that one can reify continuations as a function/callback?
05:38:21 * jesyspa doesn't get people who question whether mathematical entities exist.
05:38:23 <Philippa> merijn: heh. So I try to avoid it until I'm /ready/, but hacking up an informal-as-in-I'm-not-committing version is often useful
05:38:58 <lcfrs> Also, hi everyone!
05:39:06 <merijn> Philippa: To be fair I had already implemented significant portions at this point and my initial design was completely operationally oriented :p
05:39:08 <trotro> jesyspa, it's to know if you do useless things or not
05:39:19 <Philippa> lcfrs: that's a religious question :p Close enough, though
05:40:18 <jesyspa> trotro: Isn't that a question of whether you can do useful calculations/proofs with them, though?
05:40:26 <Philippa> jesyspa: it's a lot easier to say that now though, there's been a lot more thinking done about maths and modelling
05:41:06 <alpounet> jesyspa, well, defining 'useful' here is the trick heh
05:41:13 <kc8qvp> jesyspa: that's a question; what's wrong with asking a different question.
05:41:48 <trotro> jesyspa, mathematics must serve human kind
05:41:58 <jesyspa> kc8qvp: The concept of "existence" just doesn't make sense to me when applied to mathematical entities.
05:42:03 <trotro> so it's a way to ask themselves if there are usefull or not
05:42:05 <merijn> And people wonder why haskell has a math reputation ;)
05:42:20 <kc8qvp> jesyspa: the concept of 'existence' is far from simple/clear/settled.
05:42:24 <bls> jeyspa: pretty sure there are no square triangles
05:42:43 <Cale> There is of course a notion of existence which is internal to the (usually first order) logic that we use in mathematics, but it has nothing to do with any other kind of existence.
05:42:45 <alpounet> merijn, yeah i guess this doesn't happen on ##php
05:43:02 <Cale> But that notion of existence *is* clearly defined.
05:43:05 <bls> jesyspa: or even prime numbers > 2
05:43:08 <trotro> alpounet, they don't have the time, they have to handle null ref exception
05:43:28 <jesyspa> bls: If we're going to be talking about it that way: the set of square triangles is empty, when the set of imaginary numbers quite clearly isn't; thus, I don't see how that can be an open question using that definition.
05:43:39 <Cale> and it's the only notion of existence which we tend to really care about as mathematicians :)
05:43:56 <Cale> Of course, there's this whole point about morality to be made, but that's another thing :)
05:44:05 <user3458734985> how do you address the elements of a mulitpart tuple?
05:44:08 <mcstar> mathematicians are immoral?
05:44:09 <trotro> what is a square triangle ?
05:44:11 <kc8qvp> it seems like we're touching on the question of whether mathematics is invented or discovered.  I lean toward both... the concept of integers I think would 'exist' even w/o humanity, but maybe a lot of more complex mathematical things would not.
05:44:14 <jesyspa> Hang on, what's the point of morality?
05:44:28 <mcstar> lets ask ted kachinzky
05:44:30 <Cale> mcstar: See: http://cheng.staff.shef.ac.uk/morality/morality.pdf
05:44:48 <bls> jesyspa: sorry, I don't understand what  you mean by open question, is that a technical term how u used it?
05:45:25 <bls> i guess i am just thinking of existence proofs, and that's what immediately springs to mind when someone talks about something "mathematically existing"
05:45:54 <bls> that is "given some set of rules we both agree on, does there exist a thing which satisfies these conditions?"
05:45:56 <mcstar> Cale: haha, im sure i can benefit from reading it, but only later, when i wont have more important stuff
05:46:10 <Cale> mcstar: http://faculty.valpo.edu/lpudwell/papers/mm005281.pdf -- see footnote 1
05:46:16 <merijn> kc8qvp: I think both notions are equally incoherent
05:46:25 <jesyspa> bls: I don't see how anyone could really ask themselves "do imaginary numbers exist?" when they just defined them.  Or was it that they were expected to lead to a contradiction?
05:46:56 <kc8qvp> jesyspa: probably the question was 'do these correspond to anything useful in the real world'
05:47:10 <bls> i guess we're using different definitions of existence. i am using the one described above, you're kind of expressing that you can define anything you like, which I agree with
05:47:13 <kc8qvp> which we now know they obviously do.
05:47:43 <Cale> kc8qvp: No, it's obviously something worse than just that.
05:48:02 <bls> kc8qvp: if you invent something crazy enough, it always seems to get used in physics somewhere ;)
05:48:10 <kc8qvp> bls: I know, it's awesome.
05:48:23 <alpounet> jesyspa, they were probably looking for "real world" manifestations of imaginary numbers, which puzzled them
05:48:25 <Cale> kc8qvp: Because they didn't study them for a long time, until someone finally put some thought into it and managed to formalise the complex numbers as pairs of real ones.
05:48:41 <jesyspa> Hm, okay.
05:48:43 <Cale> and then you saw complex analysis spring up very quickly
05:48:58 <mcstar> and conformal field theory
05:49:11 <Cale> and it's not like this is something which ought to have taken 100 years to come up with a formalism for
05:50:15 <mcstar> Cale: what was the purpose of bringing that footnote to my attention?
05:50:19 <Philippa> it's amazing how that works sometimes, though
05:50:29 <Cale> mcstar: <mcstar> lets ask ted kachinzky
05:50:47 <mcstar> yeah, but whats the significan of that particular paper?
05:50:54 <lcfrs> Philippa: oh, I wasn't aware. Thanks for being clear.
05:50:57 <Cale> mcstar: Oh, I just found it funny
05:51:01 <mcstar> ah ok
05:51:03 <Philippa> Cale: why the fuck are we not routinely talking about type inference in terms of constraint logic programming? For decades? :-)
05:51:07 <Cale> mcstar: that he's "better known for other work"
05:51:21 <mcstar> yeah, thats a funny phrasing
05:51:21 <lcfrs> Philippa: Any good discussion about it I can skim?
05:51:36 <bls> Philippa: is that how people are doing it now?
05:52:01 <Cale> Philippa: Well, there is that... and the fact that we just didn't have really great formal objects to build other things from at the time.
05:52:05 <Philippa> lcfrs: er. So the "religious" part is really: are we going to be hacky or are we going to be type-theoretically rigorous? If the latter, continuations and functions are distinct things that stay distinct
05:52:24 <Philippa> bls: mostly not, even when constraints are a major part of the type system. Which is kinda disgusting really. It's how I'm doing it though
05:52:37 <Philippa> lcfrs: if you're being hacky in a "traditional" functional language, go for it :-)
05:52:40 <bls> Philippa: cool, how are you applying it?
05:52:56 <lcfrs> K, I can see the argument. Thanks :)
05:53:20 <Philippa> bls: "slowly", as I'm pretty awful at getting stuff done. But I'm kinda using it as a factoring: push interesting metatheoretical questions into the constraint system and get away from the surface syntax, that kind of thing
05:53:42 <bls> Philippa: is this like, "type sherlock".... owait, doesn't that mean you could compute with it?
05:53:51 <Cale> Philippa: but also, there was a difference in mathematical philosophy -- Today, if we can write down a clear description of whatever it is that we want to talk about, which is good enough to apply logic to and prove things about, it basically will pass as mathematics.
05:54:06 <bls> Philippa: do you have a trivial example?
05:54:24 <Philippa> lcfrs: It's worth reading up on call-by-push-value and polarity if you want to see the type-theoretical side, but it's an ongoing research area
05:54:45 <Cale> Philippa: At the time, it seems there was much more Platonism about, and worry about whether the things being discussed really existed in some Platonic parallel reality
05:54:53 <Philippa> bls: yep :-) https://flippac.wordpress.com/2012/02/23/the-simply-typed-lambda-calculus-with-constraints/#more-109
05:55:05 <Philippa> Cale: yep. A definite difference in attitude there
05:55:16 <Philippa> (also: Anathem is a fun piece of "hard" SF!)
05:55:49 <Philippa> bls: I've been "nearly done" with the second part of that for a few months. I managed to walk my dad through the presentation in both parts and get him to the point of "...oh, that's actually a program, isn't it?"
05:56:18 <Philippa> (dad's done mostly-imperative programming, knows a little haskell but hasn't done any logic programming)
05:56:48 <mcstar> heh, must be great to be able to talk to your dad about those things
05:57:16 <mcstar> my mom cant stand if i correct her sentences
05:57:27 <mcstar> which drives me crazy..
05:58:23 <Philippa> well, it's a bit odd at times? Dad's comparatively used to thinking in terms of the machine first, so it's a little easy to blow his mind /and then turn it fractal before he's admitted it/
05:59:35 <Philippa> there's... a certain feeling you get when you've internalised some of the lessons of basic category theory that tells you a whole bunch of stuff is basically OK to do? He's not got that yet, so he tries to build the whole CCC or whatever without knowing what a CCC is or that they're actually pretty tame things
06:02:37 <Philippa> (we had a conversation about replacements for SQL where I mentioned that there's no good reason not to have nth-order relations - watching him work out how it doesn't break things was interesting)
06:02:51 <lcfrs> Philippa: Thanks for the recommendation. I'll keep that in mind.
06:03:18 <mcstar> Philippa: whats your father's occupation?
06:03:38 <Philippa> manufacturing management consultant
06:03:45 <Philippa> he did his degree in engineering though
06:03:57 <Philippa> wrote worrying amounts of assembler and cobol in the 70s
06:04:14 <mcstar> when it was still fun?
06:04:16 <mcstar> XD
06:04:25 <Saizan> https://github.com/Saizan/PP/blob/master/interprete.pl <- a Hindley-Milner with constraints, kinda :)
06:04:46 <Philippa> he's coded to some fun instruction sets, yeah :-)
06:04:51 <alpounet> Philippa, hey, cool posts on your blog!
06:05:07 <alpounet> haven't seen them before, don't you put them on /r/haskell or smth?
06:05:11 <Philippa> alpounet: thanks! Am trying to get a whole bunch more up, my life is kinda determined to distract the hell out of them lately though
06:05:29 <Philippa> I leave the redditing to others, though I know at least some of them got linked pretty soon after they went up
06:06:50 <alpounet> Philippa, i mean, it would be nice not to have to go to your blog to see if there's something new, but to be reminded by just following /r/haskell or planet haskell or smth alike
06:06:58 <Saizan> they were on planet haskell, i think
06:07:19 <alpounet> oh alright, i must have missed them then
06:07:26 <Philippa> right. Someone's posting my stuff on /r/haskell, I just can't remember who :-)
06:08:21 <alpounet> hah
06:09:26 <Philippa> want me to check my referrer logs for reddit links?
06:09:37 <alpounet> nah
06:09:38 <Philippa> not that upvoting's going to get me anywhere people pay attention on posts that old now :-)
06:09:43 <alpounet> just make sure we hear about new posts
06:09:59 <Philippa> *nod* Should do one way or another, yeah
06:11:23 <astry_> hi
06:11:41 <alpounet> Philippa, cool, thank you
06:18:12 <user3458734985> quit
06:32:21 * hackagebot gluturtle 0.0.10 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.10 (YoshikuniJujo)
06:46:35 <carpi> can someoneplease tell me what do i get if i install the haskell standard platform?
06:47:34 <sopvop> carpi: http://lambda.haskell.org/platform/doc/current/frames.html
06:47:44 <sopvop> my god, frames!
06:48:05 <aranea> sopvop: http://www.haskell.org/platform/contents.html
06:49:29 <carpi> sweet. thanks much : )
06:55:10 <edwardk> @tell ski http://www2.tcs.ifi.lmu.de/~abel/popl13.pdf
06:55:11 <lambdabot> Consider it noted.
06:55:52 <adnauseam> is there a nth root function ?
06:56:08 <adnauseam> google's being a tad vague
06:56:37 <adnauseam> in prelude that is
06:56:52 <Iceland_jack> Try raising it to the power of the reciprocal?
06:56:53 <Cale> adnauseam: There's **
06:57:05 <nand`> doesn't look like it, judging by :i Floating
06:57:09 <Cale> > 2 ** (1/12)
06:57:10 <lambdabot>   1.0594630943592953
06:57:24 <MostAwesomeDude> > 81 ** (1/4)
06:57:25 <lambdabot>   3.0
06:57:49 <adnauseam> oo
06:57:53 <adnauseam> ** will do!
06:59:11 <mcstar> > sqrt (0 :+ 1)
06:59:11 <lambdabot>   0.7071067811865476 :+ 0.7071067811865475
06:59:11 <Cale> > (0 :+ 1) ** (1/2)
06:59:12 <lambdabot>   0.7071067811865476 :+ 0.7071067811865475
07:00:14 <Ferdirand> @type (:+)
07:00:14 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
07:00:14 <Ferdirand> oh
07:00:14 <Cale> > exp (1/2 * log (0 :+ 1))
07:00:14 <lambdabot>   0.7071067811865476 :+ 0.7071067811865475
07:00:14 <mcstar> Cale: going for the most efficient one?
07:00:14 <int-e> > exp 1 ** (0 :+ pi)
07:00:14 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
07:00:28 <ion> > exp 1 ** (0 :+ pi) :: Complex CReal
07:00:30 <adnauseam> o_0
07:00:31 <lambdabot>   mueval-core: Time limit exceeded
07:00:32 <Cale> mcstar: no, just expanding things randomly
07:00:34 <trotro> @src pi
07:00:34 <lambdabot> Source not found. Take a stress pill and think things over.
07:00:36 <ion> > exp 1 ** (0 :+ pi) :: Complex CReal
07:00:40 <trotro> >acos -1
07:00:40 <lambdabot>   mueval-core: Time limit exceeded
07:00:45 <trotro> >acos -1.0
07:01:00 <mcstar> > pi
07:01:02 <lambdabot>   can't find file: L.hs
07:01:06 <mcstar> @undef
07:01:07 <kaol> > acos (-1)
07:01:08 <lambdabot>   3.141592653589793
07:01:09 <mcstar> > pi
07:01:10 <lambdabot>   3.141592653589793
07:01:12 <int-e> trotro: you need a space after >
07:01:14 <Cale> trotro: the space after > is not optional, and you don't want to subtract 1.0 from a function :)
07:01:26 <int-e> > acos - 1 $ 6
07:01:27 <lambdabot>   NaN
07:01:31 <ion> > exp (0 :+ pi) :: Complex CReal
07:01:33 <lambdabot>   (-1.0) :+ 0.0
07:01:33 <int-e> > acos - 1 $ 0.5
07:01:34 <lambdabot>   4.719755119659785e-2
07:01:43 <int-e> Cale: I blame you ;-)
07:01:45 <trotro> there is no priority ?
07:01:49 <maukd> trotro: ?
07:02:05 <trotro> acos -1 means acos (-1) because there is no space between 1 and -
07:02:13 <Cale> trotro: that's not true
07:02:17 <trotro> i don't interpret -1 as - (1) but as the integer -1
07:02:30 <int-e> trotro: you may see it that way, but Haskell doesn't
07:02:33 <mcstar> haha
07:02:33 <Cale> Yeah, that's not how the Haskell compiler sees it :)
07:02:36 <trotro> yes, i see
07:02:51 <mcstar> would be wonderful to use _ for minus
07:02:53 <mcstar> _1
07:02:59 <Cale> "wonderful"
07:03:05 <mcstar> any J programmer would tell you that
07:03:15 <int-e> no, _ has a more useful purpose in Haskell already :)
07:03:18 <mcstar> j/k
07:03:20 <nand`> I think mathematics made a mistake in using - for prefix inversion
07:03:25 <trotro> no
07:03:27 <byorgey> it would be wonderful to use different symbols for subtraction and negation.  I don't really care what symbols they are.
07:03:37 <trotro> negation and substration is the same concept
07:03:40 <kc8qvp> this is one of those times I'm sorely missing my compose key
07:03:44 <trotro> that's why there is the same symbol
07:03:52 <byorgey> trotro: they are related, but not the same.
07:03:56 <nand`> subtraction is addition with right negation
07:04:02 <maukd> trotro: yes, that's why 'recip' and '/' are the same symbols
07:04:03 <trotro> byorgey, ok
07:04:04 <Philippa> they're /related/ concepts, but it's a PITMFA for programming languages that have to deal with more generality
07:04:04 <maukd> except not
07:04:07 <kc8qvp> - is clearly two operators, one unary and one binary
07:04:18 <companion_cube> mathematics are designed for human, that can deal with easy ambiguities like this
07:04:19 <nand`> I think choosing something like ~ for negation would have been better
07:04:28 <int-e> this has been discussed to no end ... including the option of making whitespace significant (so that indeed, acos -1 would be different from acos - 1). no good has ever come out of these discussions that I know of.
07:04:29 <Philippa> mathematical notation is less rigorous than might be expected because it's for people and not computers
07:04:37 <Philippa> int-e: quite
07:04:43 <trotro> nand`, no it's the approximate "operator" :)
07:04:51 <nand`> I know that as ≈
07:04:52 <mcstar> what i dont like in hasekell are && and ||
07:04:57 <nand`> ‘approximately equal’
07:05:04 <trotro> Philippa, there are rigourous, but there is many "language abuses")
07:05:09 <mcstar> but it makes sense from the point of view it handles infix
07:05:10 <nand`> ∨ and ∧ are so much better, right? :)
07:05:37 * nand` .oO( ¬5 )
07:05:45 <kc8qvp> nand`: that's what I wanted to type :)
07:05:54 * mcstar only sees ?s
07:05:56 <trotro> characters must come from ASCII charset (127 chararcters only)
07:05:57 <Philippa> nand`: you'd have to rewrite the Prelude so we could use ¬ for logic as well!
07:06:15 <kc8qvp> mcstar: need a better font, terminal, or encoding.
07:06:18 <kc8qvp> or irc client.
07:06:19 <Iceland_jack> Is this #agda now?
07:06:30 <Luke2> is there a haskell datetime type where the timezone is included (unlike local time)?
07:06:35 <mcstar> kc8qvp: everything worked couple of weeks ago
07:06:36 <trotro> otherwise lambda will have been used for lambda and not \
07:06:47 * Philippa figures this is one of those things where either you've written a parser for such things or you think it's worth arguing about
07:07:00 <mcstar> until*
07:07:14 <Philippa> Iceland_jack: looks like we're talking Haskell (syntax) to me
07:07:20 <kc8qvp> mcstar: you may be missing the symbols used here today but had the symbols used a couple of weeks ago.
07:07:23 <kc8qvp> s/symbols/glyphs/
07:07:25 <nand`> λ for abstractions was never intentional either way, iirc
07:07:49 <Philippa> nand`: it's moderately cute in that the matching elimination form does 'branch' syntactically? But yes
07:07:51 <Iceland_jack> Philippa: ;) it was a joke
07:08:11 <mcstar> kc8qvp: font is ok, terminal is ok, weechat worked in the past, i think some inputrc setting or somesuch interferes with weechat
07:09:02 <nand`> locale settings maybe
07:09:08 <kc8qvp> can't be inputrc I don't think
07:09:11 <mcstar> thats good too
07:09:21 <mcstar> one thing i did, is swtiched to zsh
07:09:32 <kc8qvp> also irrelevant I would think
07:09:58 <nand`> terminals have greatly varying support for special characters
07:10:00 <Luke> oh I found it: ZonedTime
07:10:01 <nand`> oh
07:10:10 <nand`> whoops, zsh is a shell
07:10:10 <kc8qvp> although the switch to zsh might mean your locale setup was in a file that only bash interprets
07:10:39 <nand`> maybe if he switched the login shell as well :)
07:11:43 <kc8qvp> mcstar: how about this, do you see one or two ?'s for, example, λ
07:12:42 <mcstar> one
07:13:12 <trotro> Do you see that 'œ' ?
07:13:16 <mcstar> ?
07:13:27 <mcstar> '?' to be precise
07:13:36 <kc8qvp> I'm still going with font, then.
07:13:54 <mcstar> but the same font works ok, i have unicode in my prompt
07:14:02 <kc8qvp> if your term wasn't interpreting utf8, you'd get two characters for that.
07:14:05 <kc8qvp> and probably not ?'s
07:14:07 <mcstar> i only see this problem in weechat
07:14:23 <kc8qvp> ahh, maybe it has re-encode features you need to turn off.
07:14:32 <Cale> on subtraction vs. negation, we could always just opt to remove subtraction, lol.
07:14:39 <kc8qvp> maybe it's trying to latin-1-ize the utf8 from the server, instead of just displaying it.
07:14:46 <trotro> mcstar, so you don't see it
07:15:09 <trotro> it's a latin-15 char :)
07:15:20 <Cale> just always write a - b as a + -b
07:15:45 <nand`> Cale: I'd like separate symbols for ‘addition with right inversion’ and ‘addition with left inversion’
07:15:54 <Cale> hah
07:15:56 <nand`> for all groups, preferably
07:16:49 <Cale> nand`: Well, you'd have it: -b + a and a + -b
07:17:20 <Cale> (In a sense :)
07:17:44 <nand`> maybe inversion could be switched from a prefix notation to something like a combinator
07:17:58 <nand`> yknow how in stochastics you have a bar over something to represent its inversion
07:17:59 <kc8qvp> if you really want operators for exactly what you said, -+ and +- seem like decent choices :)
07:18:16 <trotro> +' isn't - ?
07:18:20 <trotro> +- isn't - ?
07:18:27 <nand`> to make it a bit less verbose
07:18:36 <trotro> ha...
07:19:50 <Cale> trotro: The discussion was about how - is currently used for two things
07:20:05 <Cale> trotro: Which personally, I think Haskell made the best possible compromise on.
07:20:24 <trotro> Cale, I know
07:21:09 <trotro> we must nevere redefine maths symbols
07:21:13 <trotro> never
07:22:26 <nand`> you can redefine them as much as you want, as long as they're interchangeable :)
07:23:17 <trotro> nand`, each time maths are not respected silly things are done
07:23:33 <kc8qvp> nand`: your nick would be awesomer for here if it was `nand` :)
07:24:15 <nand`> kc8qvp: yeah but that would change tab completion
07:24:59 <kc8qvp> nand`: I think irssi would still work right, I think it tries dropping leading non-alphas
07:32:22 * hackagebot gluturtle 0.0.11 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.11 (YoshikuniJujo)
07:40:06 <rking> dmenu isn't so great. =\
07:40:42 <rking> Just finally found out how to paste, which is Ctrl+y, a keybinding I've never once seen.
07:41:09 <Clint> not even in emacs?
07:41:15 <rking> It doesn't recognize $PATH
07:41:18 <byorgey> rking: you're not an emacs user, I take it =)
07:41:25 <rking> Clint: That's to paste the emacs buffer thing
07:41:30 <rking> Not the X11 selection
07:41:40 <Iceland_jack> lol
07:41:49 <byorgey> can you change dmenu's keybindings?
07:42:23 * hackagebot cakyrespa 0.0.7 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.7 (YoshikuniJujo)
07:42:36 <rking> I don't know, it's just all around a waste of time of a thing compared to plain zsh
07:42:46 <rking> I really don't see one thing it does right except be a narrow bar
07:43:07 <byorgey> 'run turtle like LOGO with lojban'  o.O
07:43:31 <Clint> that guy has at least 3 lojban libraries
07:46:02 <maukd> rking: what do you mean, recognize $PATH?
07:46:06 <maukd> it's just a string selector
07:48:12 <rking> When I mod-p, it only does system paths, not $PATH
07:48:29 <rking> On the completion list — but I can still type the whole thing in and it'll actually run from ~/bin
07:48:30 <maukd> what does "system paths" even mean?
07:48:32 <trotro> xmonad ?
07:48:38 <rking> Default paths
07:48:46 <maukd> what does "Default paths" even mean?
07:48:51 <rking> I'm 100% sure there's a way to fix it, it's just I don't get the point of making it work
07:49:05 <rking> maukd: /bin /usr/bin /usr/local/bin
07:49:18 <maukd> dmenu doesn't just make up paths
07:49:22 <maukd> that's your $PATH then
07:49:31 <maukd> also, mod-p doesn't (just) run dmenu
07:50:42 <Clint> XMonad.Prompt.Shell is far less annoying than dmenu
07:51:06 <rking> Clint: Thanks, that's what I'm looking for, an alternative like that.
07:53:56 <rking> Clint: Yep, that's better.
07:54:22 * Clint nods.
07:55:01 <rking> Though still doesn't know about ~/bin, not sure at what point it's determining $PATH
07:55:18 <maukd> when you start it
07:55:35 <maukd> but "when" is less important than "where"
07:55:41 <rking> Heh, it also does the C-y thing
07:55:54 <maukd> because once a process is running, you can't modify its environment from the outside
07:56:07 <rking> maukd: I start it from mod-p after binding it in xmonad.xs, I'm not sure what you mean.
07:56:18 <Clint> he means it's using xmonad's $PATH
07:56:20 <maukd> irrelevant
07:56:20 <rking> "it" == xmonad itself in this case?
07:56:24 <maukd> what processes are involved?
07:56:37 <maukd> with dmenu you've got dmenu_run being started from xmonad
07:57:01 <maukd> with XMonad.Prompt.Shell presumably there's only xmonad
07:57:05 * nand` uses yeganesh, which is a Haskell-written wrapper on top of dmenu that does sorting by use frequency
07:57:32 <maukd> in any case, I suspect you're modifying $PATH after starting xmonad, so xmonad doesn't know about the new value
07:58:32 <rking> Yep, sure.
07:58:41 <rking> I picked Xmonad as my X session manager
07:59:28 <shmoo_> is there a way to pattern match that does something like: foo (con x y z) = con x y z where foo :: T -> T? The idea is to capture the constructor in con, without specifying which constructor it is
08:00:19 <maukd> rking: and where do you set your $PATH?
08:00:29 <rking> gdm —— xmonad
08:00:38 <rking> maukd: ~/.zshenv
08:00:48 <Clint> is zsh invoked in the session chain?
08:00:53 <maukd> ಠ_ಠ
08:01:21 <rwbarton> shmoo_: no. perhaps you can rearrange your data type if you want something like that
08:01:27 <rking> If it spawned dmenu via system(), wouldn't that use the user's preferred shell?
08:01:40 <trotro> can't you launch the WM with the command env ?
08:01:55 <Clint> no, system() uses /bin/sh
08:02:09 <shmoo_> rwbarton: yeah thats easy enough, just thought i would check
08:03:46 <rking> Then how come the actual command works?  When I tell dmesg to run myfoothingfromtildebin, it works?
08:05:31 <Clint> ~/bin is in dmenu's path then?
08:06:24 <rking> Clint: That's the weird thing. It doesn't complete that as part of the list, but then it runs it.
08:06:40 <ceii> I'd suppose dmenu uses your user shell to run commands
08:07:11 <ceii> so it passes the string to zsh which reads your .zshenv on startup
08:07:46 <Clint> that seems like kind of a poor design
08:07:48 <ceii> at any rate, try setting your PATH in ~/.profile or ~/.xrprofile
08:07:59 <ceii> I think gdm reads one of those
08:08:21 <ceii> not sure though, I haven't used it in a while
08:09:47 <Lutin`> I'm not sure how but I just got a 107/100 on a C++ exam
08:09:58 <ceii> yay for bonus points
08:10:11 <Lutin`> Why won't they just let me test out of this class...
08:10:18 <Lutin`> Oh well, easy 4.0
08:10:22 <rwbarton> dmenu doesn't even run the command itself does it
08:10:40 <rwbarton> there's a separate script dmenu_run
08:11:23 <rwbarton> it looks like the stock dmenu_run uses $PATH to build the file list and then passes the selected command to $SHELL
08:11:41 <rwbarton> which is more or less what ceii said
08:12:04 <rking> dmenu_test pipes to $SHELL or /bin/sh
08:12:09 <rking> That's why it works when I run it.
08:12:16 <rking> Hehe, I was late on that one.
08:15:47 <rwbarton> it sounds like you are setting your path in the equivalent of .bashrc then
08:15:51 <ceii> if I remember right what I used to do when I used gdm, I had a custom X session file that simply ran something like ~/.xmonad/autostart
08:16:10 <tibbe> anyone have a sec to help me define a Traversable instance?
08:16:10 <ceii> from where I'd start stuff up and exec xmonad
08:17:18 <rking> rwbarton: Right, of course. Where else would someone reasonably set a $PATH but in their shell startup scripts?
08:17:19 <hpaste> tibbe pasted “Traversable instance for Records” at http://hpaste.org/75661
08:17:20 <rwbarton> it should probably go in the equivalent of .profile instead
08:17:31 <tibbe> Can anyone see what's wrong with http://hpaste.org/75661 ?
08:17:58 <rking> dmesg could run ${SHELL:-/bin/sh} -c 'echo $PATH' and it'd be good enough.
08:18:44 <rwbarton> sounds simpler to just have your whole login session use the right path
08:18:58 <maukd> rking: .profile
08:19:09 <maukd> or your session script
08:21:21 <rking> OK, I suppose that is a more correct place for it.
08:28:07 <akamaus> hi! I'm trying to kill a gkt2hs thread with killThread. The call blocks indefinitely for some reason. Why?
08:29:06 <hpaste> nevrenato pasted “Problem in the type sig” at http://hpaste.org/75663
08:29:07 <t7> can you prove something _doesnt_ terminate ?
08:29:22 <mcstar> im worse off then i was before
08:29:25 <t7> beyond x = x
08:29:33 <quicksilver> of course, t7
08:29:41 <quicksilver> you can prove it in many specific cases
08:29:46 <Iceland_jack> t7: some languages employ a termination checker, like agda
08:29:46 <quicksilver> you just can't prove in general
08:29:50 <nevrenato> can anyone help me about the error posted, just now pls ?
08:30:12 <rwbarton> tibbe: don't you need a Right on line 18
08:30:15 <byorgey> Iceland_jack: those don't prove non-termination, though.
08:30:21 <t7> Iceland_jack: agda will only tell you if it does absolutely terminate
08:30:23 <byorgey> they only fail to prove termination.
08:30:25 <rwbarton> (also isn't Either String already an instance of Traversable?)
08:30:25 <tibbe> rwbarton: figured it out
08:30:41 <rwbarton> also, can't you derive Traversable?
08:31:02 <Iceland_jack> I didn't say it proved non-termination, I said it had termination checking
08:31:03 <tibbe> rwbarton: traverse _ n@Nil = n is not the same as traverse _ Nil = Nil
08:31:07 <rwbarton> ugh
08:31:16 <tibbe> rwbarton: Either String isn't an instance
08:31:40 <tibbe> rwbarton: so we have to allocate a new Nil (which is free fortunately)
08:32:19 <rwbarton> ghc doesn't handle that for you?
08:32:29 <byorgey> nevrenato: can you please paste the actual code and the actual error?  Constructors cannot start with a lowercase letter so that code cannot possibly have produced that error.
08:32:41 <rwbarton> oh I forgot there were arguments to Nil
08:32:48 <rwbarton> still seems like CSE might pick it up
08:33:38 <nevrenato> byorgey:  Hi thx for the answer :) I could post but it's like a bazillion lines of code. I restricted the problem to this
08:33:55 <zhulikas> @type Nil
08:33:57 <lambdabot> Not in scope: data constructor `Nil'
08:34:04 <zhulikas> traverse _ n@Nil = n is not the same as traverse _ Nil = Nil
08:34:07 <zhulikas> how is this different
08:34:31 <byorgey> nevrenato: restricting the problem to something shorter is fine.  But you should make sure that your restricted version actually produces the given error message.  Otherwise it is impossible for anyone to help you.
08:34:42 <Saizan> zhulikas: types
08:35:14 <maukd> zhulikas: try writing a Functor instance for Maybe
08:35:24 <maukd> chances are you'll run into this problem
08:35:31 <nevrenato> byorgey: You're right ! I'm going to try to test this short version
08:36:07 <rwbarton> no tibbe has the opposite problem I think, he just doesn't want to reallocate the Nil constructor
08:36:46 <rwbarton> oh wait
08:36:57 <quicksilver> this is an advantage of the derived instances
08:37:06 <quicksilver> they cheat and use the zero-copy implementations
08:37:19 <quicksilver> IIRC
08:37:25 <Saizan> n :: Records a /= Records b
08:37:52 <quicksilver> (even though the types don't match)
08:38:09 <quicksilver> fmap f n@Nothing = unsafeCoerce n
08:38:22 <mcstar> kc8qvp: if i copy some unicode text into gvim, that doesnt show up right either
08:38:50 <Saizan> quicksilver: do they? i thought only GeneralizedNewtypeDeriving pulled tricks like that
08:39:09 <kc8qvp> mcstar: copy from your irc client you mean?
08:39:13 <kc8qvp> or just in general?
08:39:21 <mcstar> kc8qvp: from chromium
08:39:28 <hpaste> nevrenato pasted “Error in the contexts” at http://hpaste.org/75664
08:39:38 <quicksilver> Saizan: I'm talking about -XDeriveFunctor and -XDeriveFoldable etc
08:39:43 <ceii> does fmap f Nothing = Nothing really "allocate a Nothing"? I thought zero-argument contructors just lived at a known address
08:39:53 <nevrenato> byorgey: Done :)
08:40:01 <mcstar> kc8qvp: http://www.humancomp.org/unichtm/huseyin8.htm that turkish text for example
08:40:27 <quicksilver> Saizan: (I could still be wrong ;)
08:40:35 <kc8qvp> huh.
08:41:22 <rwbarton> so there were actually three errors in the original paste
08:41:33 <byorgey> nevrenato: right, notice it says can't deduce (Syntax l1 b)
08:41:43 <mcstar> kc8qvp: also, it works fine with emacs
08:41:49 <kc8qvp> mcstar: what does it do?  in gvim I mean
08:42:17 <byorgey> nevrenato: the reason is that the AnyLogic wrapper contains something of some type we don't know
08:42:29 <rwbarton> ceii: no but the original example had a two-argument constructor Nil
08:42:33 <byorgey> nevrenato: so there's no guarantee it has anything to do with the type l in the type of x
08:42:43 <ceii> rwbarton, oh, okay.
08:43:21 <nevrenato> byorgey:  But AnyLogic has the Logic context which has the Syntax…so it should deduce Syntax right ?
08:43:36 <mcstar> kc8qvp: http://i.imgur.com/Dnhlo.png
08:43:46 <byorgey> nevrenato: for that to work you need an  instance (Syntax l b) => Logic l b
08:43:51 <byorgey> nevrenato: not just the class
08:44:33 <byorgey> nevrenato: I assume in your real thing the Logic class actually has more methods?
08:44:41 <mcstar> kc8qvp: i also saw, that awesome complains that some iso2utf utility cant convert multi byte characters
08:44:43 <nevrenato> byorgey: Yeah
08:44:50 <byorgey> nevrenato: and probably some instances for specific types?
08:44:55 <mcstar> kc8qvp: recently im on kde, thats why i didnt notice that
08:44:56 <kc8qvp> mcstar: for gvim, gotta be the font, right?? some of it works, and what doesn't doesn't show up as multiple chars...
08:45:01 <byorgey> nevrenato: in which case you don't actually want to/can't add the instance I said
08:45:23 <mcstar> kc8qvp: its dejavu sans, the font must be ok, the same i use for emacs
08:45:23 <kc8qvp> mcstar: when you said emacs, you mean emacs in a terminal?
08:45:27 <byorgey> nevrenato: what I would do is just define   data AnyLogic = forall l b. (Syntax l b, Logic l b) => ...
08:45:32 <mcstar> no, gui
08:46:27 <nevrenato> byorgey : But why…if Logic already has Syntax in the context ? If it's of the Logic type shouldn't also be automatically of the Syntax type ?
08:46:38 <maukd> mcstar: :set enc? fenc?
08:46:52 <byorgey> nevrenato: yeah, let me think for a minute, I thought I understood but now I am confused
08:47:06 <nevrenato> byorgey:  ok :)
08:47:21 <mcstar> maukd: with ? in it?
08:47:24 <maukd> yes
08:47:24 <kc8qvp> mcstar: it makes sense that an iso2utf couldn't convert multi-byte characters because there are no multi-byte characters in iso-8859-1
08:47:48 <byorgey> nevrenato: oh! Now I get it
08:47:56 <nevrenato> byorgey: Shoot it
08:48:05 <byorgey> nevrenato: the problem is that we also don't know anything about the type b wrapped up in MkLogic
08:48:40 <nevrenato> byorgey:  We only know that has to belong to a Syntax instance
08:48:57 <byorgey> nevrenato: the x function insists on returning some particular type b (chosen by the caller of x) but parse_basic_spec may return some other type.
08:49:26 <Cale> Yeah, I just had a look too
08:49:27 <mcstar> maukd: that didnt help
08:49:35 <Cale> l determines b, but b does not determine l
08:49:38 <maukd> mcstar: ... what did you expect it to do?
08:49:47 <byorgey> nevrenato: x's type promises to be able to return *any* type b that a caller of x wishes, as long as there is a Syntax l b instance
08:50:06 <mcstar> maukd: lol, why did you tell me to use it?
08:50:09 <nevrenato> byorgey: that's it !
08:50:10 <byorgey> nevrenato: but x in fact can only return the particular type which is wrapped inside the AnyLogic argument
08:50:24 <Cale> So when you write x :: (Syntax l b) => AnyLogic -> Maybe (IO b), it doesn't know which instance to use. It knows which b, but not that the l has to be the l you provided in the constraint.
08:50:27 <maukd> mcstar: so I would know what encoding vim is configured to use
08:51:19 <mcstar> maukd: fileencoding none, encoding latin1
08:51:32 <maukd> that's a likely source of problems
08:51:49 <maukd> put 'set encoding=utf-8' in your ~/.vimrc and try again
08:52:28 <nevrenato> Cale, byorgey : Sorry i couldn't understand what was the problem =S
08:52:41 <byorgey> nevrenato: why be sorry?
08:53:11 <Cale> Is it still not clear?
08:53:12 <mcstar> maukd: yeah, it works, now ill test it in the console
08:53:29 <nevrenato> byorgey: Because i still couldn't understand what Cale said
08:53:49 <byorgey> nevrenato: oh! hehe, I misunderstood what you meant
08:54:04 <byorgey> maybe Cale can continue explaining, I have to go to lunch
08:54:08 <nevrenato> byorgey: np :)
08:54:20 <nevrenato> Cale: Can you explain in a noober way
08:54:56 <Cale> nevrenato: Okay, so let's start by looking at  MkLogic :: (Logic l b) => l -> AnyLogic
08:55:03 <kc8qvp> mcstar: I wonder, if your X session locale is wrong but when you open a terminal and it runs a shell your shell startup is setting it correctly so that you don't see the problem when you run 'locale'.
08:55:15 <mcstar> maukd kc8qvp ok, i can see that text correctly from the console in vim/emacs, or cat it to the console
08:55:16 <nevrenato> Cale : yep
08:55:40 <maukd> mcstar: I don't even know what your problem is, I just saw that gvim screenshot :-)
08:55:47 <Cale> What MkLogic does is to discard the type information about l, and only remember that there is an instance (Logic l b), for some types l and b
08:56:04 <mcstar> maukd: the problem is, that in the same console, in weechat i cant see ut8 characters
08:56:48 <maukd> I dislike weechat so I can't help you there
08:57:21 <Cale> When we pattern match in the definition of x against the MkLogic constructor, the only thing we know about the value l that we get is that l is of some unknown type l (thanks for naming these the same btw ;) such that there is an instance Logic l b
08:58:10 <Cale> We do not know which type l this is, or which type b
08:58:12 <kc8qvp> mcstar: a lot of irc clients can translate charset encodings.  weechat may be trying to convert utf8 from the server to latin-1 before sending it to your terminal (as I mentioned earlier)
08:58:18 <nevrenato> Cale : oh Ok
08:58:27 <kc8qvp> mcstar: google tells me there is a 'charset' plugin for doing this
08:58:33 <kc8qvp> mcstar: see if it's enabled/misconfigured
08:58:48 <nevrenato> Cale : So the problem is that AnyLogic doesn't has the context
08:58:50 <mcstar> k
08:58:55 <Cale> Well...
08:59:08 <nevrenato> Cale:  The constructor has…
08:59:13 <Cale> The problem is that x :: forall b. AnyLogic -> Maybe (IO b)
08:59:20 <Cale> but that b isn't necessarily the same b
08:59:25 <kc8qvp> mcstar: looks like if you unload the charset plugin, "WeeChat can only read/write UTF-8 data.", which is pretty much what you want
09:00:20 <nevrenato> Cale : that b isn't necessarily on the Logic class
09:00:50 <rwbarton> nevrenato: "x :: (Syntax l b) => AnyLogic -> Maybe (IO b)" mean that I, the caller of x, get to pick the types l and b as long as there is a Syntax l b instance, and pass x a value of type AnyLogic, and x is supposed to give me a value of type Maybe (IO b)
09:00:55 <Cale> you'll notice that I removed the (Syntax l b) constraint. Why? Well, because it doesn't help us in any way.
09:01:24 <Cale> That l doesn't have to match the type of the l that we pattern match
09:01:43 <Cale> (this discussion is being made hard because too many things are called l)
09:01:51 <Cale> (and none of them are equal)
09:01:55 <rwbarton> nevrenato: that's pretty clearly impossible, since AnyLogic contains a value of some other type l' that I don't know has any relation to b at all.
09:02:51 <Cale> nevrenato: Did you define this datatype in the first place? Do you have control over this API?
09:03:32 <nevrenato> Cale : I have but  i would prefer not change it, as it's not mine
09:04:50 <nevrenato> Cale : Do you have a quick fix for this ?
09:05:04 <Cale> Well, I'd need to know more about what you're trying to do.
09:05:05 <rwbarton> delete the function x
09:05:26 <monochrom> heh
09:05:34 <Cale> x does seem pretty clearly pointless, because you already have a name for it, parse_basic_spec
09:06:39 <rwbarton> seriously, the type of x ought to be something like AnyLogic -> exists b. Maybe (IO b)
09:06:44 <Cale> nevrenato: Okay, well, I was going to suggest that you get rid of the existential, and possibly the typeclasses, and just turn values of type AnyLogic into records consisting of what used to be the typeclass methods. This would make it clearer perhaps what you were allowed to do with them.
09:07:00 <rwbarton> but since that type doesn't exist, and since x is trivial anyways, x is useless
09:07:05 <nevrenato> Cale, rwbarton : yes, i know that x is pretty useless…I just wanted to see if i could make this function x
09:07:23 <rwbarton> if you throw away the result of the IO action you can do it
09:07:24 <nevrenato> rwbarton, Cale : to learn more about type in haskell
09:07:31 <rwbarton> x :: AnyLogic -> Maybe (IO ())
09:08:49 <car> squadra antimafia
09:09:03 <rwbarton> you can't do anything with that value of type "b" anyways
09:10:08 <nevrenato> rwbarton, Cale : yes i see know, i was being dumber than a door with this function 'x' :D
09:10:29 <Cale> In fact, with the interface as described in this paste, there's quite literally nothing which can be done with the b once you get something out of that existential, in general.
09:10:36 <lispy> any reactive-banana/frp experts want to help me understand using a fixed time step? http://stackoverflow.com/questions/12685430/how-to-implement-a-game-loop-in-reactive-banana/12686447
09:10:47 <Cale> You'll need some more methods of Syntax and Logic to do anything -- hopefully they mention the b type more.
09:11:41 <nevrenato> Cale : yes they do ! I just sliced the code to the minimum. It may not make sense in utility…but the problem is the same (i think)
09:12:40 <nevrenato> Cale, rwbarton : Anyway i understood now the problem thx for your help really :)
09:12:56 <thoughtpolice> GHC has holes now!
09:13:00 * thoughtpolice does a cheer
09:13:07 <thoughtpolice> hopefully someone will whip up emacs integration
09:14:10 <lispy> thoughtpolice: vim too! ;)
09:14:40 <lispy> thoughtpolice: Seems like improving the cabal/ghci intergration is a prerequisite to doing it well.
09:14:45 <thoughtpolice> i tried out vim with spf-13 and a bunch of other stuff because it was easy to install and, why the hell not
09:15:01 <jfischoff> I really hope TH integration is possible with holes
09:15:05 <lispy> For a while I could do 'cabal-dev ghci' and it worked just like I would want but then the cabal devs broke that feature.
09:15:11 <thoughtpolice> the past month has gone pretty good, although a lot of the haskell addons seem to noticeably affect vim's performance
09:15:26 <lispy> what is spf-13?
09:15:27 <mcstar> kc8qvp: now it works, the problem was, that i didnt have a locale.conf with LANG set, which weechat/charset needed to pick the correct encoding
09:15:38 <dcoutts> lispy: we didn't break it on purpose, cabal-dev ghci is taking a hacky approach
09:15:54 <thoughtpolice> lispy: sure, it's a lot easier for agda, especially because everyone everywhere uses emacs and doesn't have as complex a package ecosystem. :)
09:15:55 <mcstar> kc8qvp: apparently, even my /etc/profile.d/locale.sh was missing too which would be responsible to read locale.conf
09:16:17 <lispy> thoughtpolice: I used emacs for a long time, but lately (last 18 months or so) I'm taking a break from regular emacs use to master vim. Vim is a nice editor, but I wish it was easier to script like emacs.
09:16:26 <thoughtpolice> lispy: it's basically a nice shell script that sets up vim with a lot of good stuff by default
09:16:42 <thoughtpolice> yeah, same here, i'm only a month in like i said
09:16:52 <thoughtpolice> lispy: https://github.com/spf13/spf13-vim
09:16:59 <lispy> dcoutts: Sorry. I don't mean to imply that it was intentional or there is any malice or anything. It was meant more "matter of a fact".
09:17:36 <dcoutts> lispy: np
09:17:58 <thoughtpolice> lispy: here's a little bit of stuff that does spf-13 + a bunch of haskell stuff in one go https://github.com/jejansse/Haskim
09:18:03 <lispy> thoughtpolice: cool. I'm using vim + vundle. Here is my setup: https://github.com/dagit/dotfiles
09:18:20 <thoughtpolice> lispy: that's why i started using vim, because i could immediately set it up for a haskell environment + no manual tweaks by default
09:18:30 <thoughtpolice> lispy: yeah, spf-13 uses vundle by default and stuff. it's really nice
09:18:30 <kc8qvp> mcstar: that's weird, why don't they just get it from the environment.
09:18:57 <Cale> lispy: I guess I could have a look at reactive-banana, but I would guess that if you wanted to fix your timestep, you'd be better off with a simpler FRP system
09:19:05 <thoughtpolice> it's pretty slick, but like I said the on the fly recompile seems to hurt vim more than emacs right now
09:19:10 <lispy> thoughtpolice: hmm..I'll have to check that out in more detail...Looks compelling :)
09:19:34 <jfischoff> lispy, thought police: do you have any stability with your setups (i.e. random crashes)?
09:19:45 <thoughtpolice> i do like how those addons unify hlint/ghc errors. i dislike having to switch between hlint/ghc mode when using ghc-mod
09:19:50 <lispy> jfischoff: my setup is stable.
09:20:04 <jfischoff> thoughtpolice: is yours?
09:20:11 <lispy> Cale: hmm...Such as?
09:20:18 <roconnor> is there a "take :: Int -> Simple Travesal a b -> Simple Traversal a b" function for traversals?
09:20:21 <thoughtpolice> jfischoff: ? what do you mean, vim?
09:20:26 <roconnor> in lens
09:20:28 <thoughtpolice> if so, no
09:20:59 <lispy> Cale: What draws me to reactive-banana: the author cares about predictable performance and other practical considerations, he seems to be activily improving the library (does anyone work on Yampa anymore?)
09:21:06 <Cale> lispy: There's a super-simple Circuit arrow type which is floating around, which is pretty much a continuation-based Mealy machine. It's what Yampa reduces to when you remove the timestep parameters.
09:21:06 <jfischoff> so I added haskellmode to Haskim and got plus some other stuff, and vim started crashing all the time
09:21:26 <malorie> hi. I'm trying to read up on arrows and came across code like `head &&& (head . tail) $ "bla"' for which I don't know why it works. shouldn't it be `arr head &&& arr (head . tail) $ "bla"'?
09:21:42 <lispy> jfischoff: I'm not using Haskim yet. My vim + haskell setup really just has syntax highlighting.
09:21:48 <thoughtpolice> Cale: are you referring to edwardk's machines library? (i may totally be off base)
09:21:57 <jfischoff> I'm haven't had time to figure out what component or interaction between components is causing the instablility
09:22:01 <Cale> thoughtpolice: It's quite likely that has it...
09:22:26 <Cale> http://hackage.haskell.org/packages/archive/machines/0.2.1/doc/html/Data-Machine-Mealy.html -- yes, this is isomorphic to what I was thinking
09:22:46 <thoughtpolice> Cale: right, that's why i mentioned it, because you referred to Mealy
09:22:51 <thoughtpolice> what Circuit type are you talking about?
09:23:02 <thoughtpolice> jfischoff: ah, no, no segfaults with haskim
09:23:11 <lispy> Cale: To be fair, I haven't spent any time using FRP, so my misunderstanding about how to do this fixed time step thing might be a superficial misunderstanding and not actually relevant.
09:23:11 <jfischoff> good to hear
09:23:48 <Cale> thoughtpolice: well, there's an example here: http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
09:24:02 <lispy> But, I always have this problem with FRP where I have a hard time figuring out what the drawbacks are and how to properly use it. Why? Because I've only read the papers and not applied the material to examples.
09:25:16 <krey_> hello,  i'm trying to enumerate all polymorphic functions that obey certain commutative diagrams. the polymorphic function is between two 'polynomial' functors. my question is if there's some theory that can be used to treat these as finite things that can be enumerated & computed? possibly related to C-H correspondence
09:25:26 <Cale> lispy: Well, I suppose I might also be a little off-base because reactive-banana looks like an applicative-style FRP system, so that suggestion might be a larger change in API than you want.
09:26:08 <Cale> malorie: (->) is an Arrow instance
09:26:34 <Cale> > head &&& (head . tail) $ "abcd"
09:26:36 <lambdabot>   ('a','b')
09:27:07 <malorie> yeah. but `head' in there is of type `[a] -> a' and not `Arrow a => a [b] b', no?
09:27:10 <lispy> Cale: hmm...I think it is applicative style, it's originally based on Conal's reactive semantics
09:27:45 <malorie> (same for `head . tail' of course)
09:27:47 <Cale> malorie: one is the generalisation of the other
09:28:01 <Cale> malorie: set a = (->)
09:28:09 <Cale> then a [b] b = [b] -> b
09:28:55 <Cale> :t head :: (->) [b] b
09:28:57 <lambdabot> forall b. [b] -> b
09:29:50 <Cale> lispy: If it held true to that semantics, then it's probably sufficiently deterministic that you can just set all the timesteps to a constant.
09:32:42 <Cale> lispy: I haven't read the entire article, but I think this guy has kind of too strong a notion of repeatability (well, it could make sense sometimes)
09:32:48 <roconnor> @ask edwardk is there a "take :: Int -> Simple Travesal a b -> Simple Traversal a b" function for traversals?
09:32:49 <lambdabot> Consider it noted.
09:33:49 <edwardk> roconnor: 'sorta'
09:33:49 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
09:33:59 <roconnor> :?
09:34:11 <edwardk> elementsOf l (<n)  will get you that
09:35:24 <astry_> hi
09:35:25 <roconnor> edwardk: no such function is in the index
09:35:36 <edwardk> i could be talked into adding an explicit taking, dropping
09:35:42 <roconnor> er maybe I'm out of date
09:35:50 <edwardk> er renamed it
09:35:51 <edwardk> iwhereOf
09:35:59 <edwardk> iwhereOf l (<n)
09:36:33 <astry_> hi
09:36:36 <edwardk> 'elements' was too common of a name to take, so i moved it to one side
09:36:49 <roconnor> ok
09:36:50 <astry_> what is the best way to do command line options and possibly subcommands?
09:37:26 <edwardk> i could definitely add a taking and dropping though. that way even if you have other indices it would work
09:37:35 <astry_> i'm looking for something like python's argparse
09:37:48 <astry_> which is very well suited for what i'm doing, but i want to do it in haskell.
09:38:05 <roconnor> edwardk: I'll leave it to you to decide what you want to do
09:38:07 <otters> getopt?
09:38:11 <edwardk> astry_ there are several options, there is cmdargs, cmdtheline, optparse-applicative, getopt, etc
09:38:17 <roconnor> edwardk: as long as I have some way to do it now I'm happy
09:38:22 <edwardk> each has relative strengths and weaknesses
09:38:30 <otters> @hoogle GetOpt
09:38:30 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
09:38:31 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
09:38:31 <lambdabot> System.Console.GetOpt module System.Console.GetOpt
09:38:38 <edwardk> roconnor: =)
09:38:42 <Cale> astry_: that thing ^^
09:38:49 <krey_> ok, maybe I phrased the question badly, but I'm still hoping that someone's interested in helping me. basically I would like a cheaper version of curry-howard that only applies to polynomials. the reason is, I don't want to implement beta reduction. or is there a lib that does this for me? I put in a type, finds all instances, and then does beta reduction?
09:38:53 <lispy> Cale: I'm no expert of physics engines, but my understanding of them is that they really struggle to approximate physics in a numerically sound way. I think the article reflects some of that.
09:39:24 <Cale> astry_: see the example here: http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/System-Console-GetOpt.html
09:39:31 <lispy> Cale: When I read a book about them it seemed like small changes in inputs can lead to big differences in accumulated errors.
09:40:14 * lispy used GetOpt yesterday. It's nicer than you might think.
09:41:21 <Cale> lispy: well, of course, you spend a lot of time dealing with that and balancing it against the amount of time you have available to compute things. If it's a game, though, the important thing isn't to have really sound physics, but to have physics which behaves in a way which seems predictable to the player.
09:42:36 <astry_> i couldn't make sense out of cmdtheline
09:42:42 <astry_> cmdargs is fairly simplistic
09:42:49 <lispy> Cale: Right. So then it's good if computers with big differences in CPU power get the same results. So the author says to always use the same dt.
09:43:09 <astry_> getopt looks cool, i haven't seen that yet
09:43:29 <lispy> astry_: it requires more boilerplate, so some people don't like it.
09:43:39 <lispy> astry_: but I've never regretted using it.
09:43:56 <jfischoff> So I have been using Aeson for JSON serialization, which works great. However, I would like to be able to accumulate missing key warnings during deserialization. Out of the box that is not something Aeson supports. Is there a JSON package that does?
09:44:11 <astry_> lispy: using getopt?
09:44:20 <astry_> one thing i'm missing from getopt is subcommands
09:45:37 <astry_> thanks cale/ lispy / edwardk , i think i'll try getopt first
09:45:55 <edwardk> getopt is simple, and understandable
09:46:00 <edwardk> but it doesn't do much
09:47:11 <astry_> edwardk: does any of them have support for subcommands?
09:47:29 <edwardk> astry_: cmdargs
09:47:45 <jfischoff> optparse too
09:48:07 <lispy> astry_: yeah, I've never regretted using getopt despite it requiring a bit more boilerplate
09:48:13 <edwardk> i've been meaning to package up my own stab at solving this space
09:48:57 <lispy> jfischoff: Have you looked at the galois json library? I've never needed it, but maybe it does what you want?
09:49:00 <edwardk> using lenses to update the configuration, monoidally concatenable configurations that can be merged from a .cabal -like file or command line, etc.
09:49:11 <lispy> jfischoff: IIRC, it's just called 'json'
09:49:31 <copumpkin> edwardk: sounds relevant to snoyberg's latest blog post
09:49:49 <edwardk> but every time i start it its fairly daunting ;)
09:50:04 <jfischoff> lispy: thanks that is worth a look. I basically want Aeson + parsec parsing
09:50:06 <edwardk> link?
09:51:00 <Cale> lispy: As a player, I'm not going to notice if there are small variations in the way that the physics looks on different machines, so long as events occur at essentially the same times.
09:51:19 <copumpkin> Cale's a playa
09:51:43 <Cale> because I don't have two computers with the same controller hooked up to both of them generally
09:51:44 <jfischoff> hehe
09:51:50 <copumpkin> edwardk: http://www.yesodweb.com/blog/2012/10/generic-monoid
09:52:32 <lispy> Cale: You want to rule out the case where on one system a physics puzzle is solvable and on a different CPU it's not due to accumalting error differently.
09:52:43 <Philippa> Cale: that may be true, but games tend to feel 'off' if you've got that kind of thing happening. You need at least some kind of stability
09:52:47 <Philippa> (what lispy's saying)
09:52:53 <Philippa> hi Noldorin
09:53:02 <lispy> Cale: imagine something like a mess of springs feeding back into each other
09:53:12 <Noldorin> heh, hi Philippa
09:53:21 <Noldorin> didn't know you were in here... should have guessed!
09:53:25 <Philippa> lispy: you mean like all but the most basic models that Chris Hecker had us playing with a decade back?
09:54:05 <lispy> Philippa: Unfortunately, I'm unfamiliar with Chris Hecker so I'm not sure what you're refering to.
09:54:27 <Philippa> he was one of the main people to drag physics simulation into the game industry
09:54:40 <Philippa> wrote a lot of good stuff
09:54:45 <lispy> cool
09:55:24 <jfischoff> lispy: json not close enough ;(
09:55:29 <Philippa> so basically I'm being snarky about what's a simple or complex problem - though not really in your direction
09:55:42 <lispy> jfischoff: bummer! Time to hack your feature into aeson or json?
09:56:00 <jfischoff> lispy: I would love to add it to Aeson…if possible
09:56:21 <Cale> Well, I would tend to say that the solvability and rough equivalence of whatever physics puzzle on the two machines is what's important, rather than the particular chaotic oscillations that I get.
09:56:23 <lispy> jfischoff: if you could show that it doesn't slow down aeson I bet bos would consider it?
09:56:34 <Philippa> Noldorin: talking of which, I forgot to reconnect and rejoin the other place. They still getting into stupid PL arguments more often than anything else?
09:56:59 <Noldorin> Philippa: yeah, and worse alas.
09:57:03 <Philippa> Cale: so describing the rough equivalence matters, and things get a lot hairier if you're actually running a multiplayer game
09:57:14 <Noldorin> even religion debates... then you know things have gone to pot
09:57:22 <jfischoff> lispy: Yeah, but I bet it will. It is hard to write code as fast as bos.
09:57:37 <Philippa> Noldorin: ouch. Pastafarians vs emacs users?
09:57:47 <lispy> Philippa: Yeah, I'm no expert here. I read one book about implementing physics engines for games over vacation about two months back. If I can find the time/energy I'll try writing a physics engine as a learning project.
09:57:47 <Noldorin> don't like the place much; seem to be too many overgrown children, i'm afraid. decided not to stay!
09:58:09 <Noldorin> Philippa: hah. something like that. more theist/atheist though ;)
09:58:24 <Philippa> Noldorin: fair enough. I suspect some of them have, if anything, regressed slightly in the last decade
09:58:48 <Noldorin> heh yeah. i just didn't much fancy the ethos and culture in there.
09:58:49 <Noldorin> *shrug*
09:58:51 <lispy> Right now I should focus work
09:58:53 <lispy> ttyl
09:58:54 <hpaste> carpi pasted “unusual ” at http://hpaste.org/75665
09:58:58 <Cale> In a case like that, I'd say do some basic things to conserve energy, and you're probably fine.
09:59:16 <carpi> can someone please take a look at that and tell me whats wrong? its  a very simple snippet
09:59:16 <Noldorin> Philippa: plus, i need to be focusing on university now :) will still hang out on Freenoe a bit though
09:59:45 <Cale> carpi: This is why we don't like tabs
09:59:53 <Blkt> good evening everyone
10:00:15 <carpi> ill change the tabs to space. one moment
10:03:40 <carpi> Cale: thanks : ) this iworks.
10:05:52 <Cale> carpi: any decent text editor will be able to replace them automatically with spaces for you
10:06:11 <Cale> carpi: e.g. if you're using vim,  set expandtab
10:06:23 <carpi> Cale: sublime text editor
10:07:02 <Philippa> Noldorin: fair enough. Did any of that pile of tutorial I gave you stick long enough to try it out, btw?
10:07:14 <Noldorin> remind me which ones they were again?
10:07:31 <Philippa> oh, I typed way too much about monads and applicatives at you
10:09:19 <Cale> http://www.sublimetext.com/docs/2/indentation.html
10:13:08 <clahey> I think I figured out the expression I was trying to figure out yesterday.
10:13:18 <clahey> It's not point free though.
10:13:51 <clahey> a <= b = foldr1 (||) ([(<), (==)] <*> [a] <*> [b])
10:13:58 <clahey> :t foldr1 (||) ([(<), (==)] <*> [a] <*> [b])
10:13:59 <lambdabot> Bool
10:14:05 <clahey> :t a->b->foldr1 (||) ([(<), (==)] <*> [a] <*> [b])
10:14:06 <lambdabot> parse error on input `->'
10:14:13 <clahey> :t a -> b -> foldr1 (||) ([(<), (==)] <*> [a] <*> [b])
10:14:14 <lambdabot> parse error on input `->'
10:14:19 <clahey> :t A -> B -> foldr1 (||) ([(<), (==)] <*> [a] <*> [b])
10:14:20 <lambdabot> parse error on input `->'
10:14:25 <clahey> Oh, right.
10:14:33 <clahey> :t \a b -> foldr1 (||) ([(<), (==)] <*> [a] <*> [b])
10:14:35 <lambdabot> forall a. (Ord a) => a -> a -> Bool
10:16:56 <Nimatek> Leave it to Haskellers to express the lequal through applicative functors.
10:17:03 <Nimatek> operator*
10:19:27 <clahey> @hoogle f (a -> b) -> a -> f b
10:19:28 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
10:19:28 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
10:19:28 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
10:19:42 <clahey> None of those actually match what I asked for.
10:20:03 <clahey> Obviously:
10:20:09 <clahey> :t <*> . return
10:20:10 <lambdabot> parse error on input `<*>'
10:20:16 <clahey> :t (<*>) . pure
10:20:17 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (a -> b) -> f a -> f b
10:20:28 <clahey> Hmm, not quite.
10:20:40 <clahey> :t ((<*>) .) . pure
10:20:41 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Applicative f1) => f (a -> b) -> f1 (f a -> f b)
10:20:54 <clahey> :t flip (flip <*> . pure)
10:20:55 <lambdabot> parse error on input `.'
10:21:01 <clahey> :t flip (flip (<*>) . pure)
10:21:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
10:21:44 <clahey> @pl f (a -> b) -> a -> f b
10:21:44 <lambdabot> (line 1, column 6):
10:21:44 <lambdabot> unexpected ">"
10:21:45 <lambdabot> expecting variable, "(", operator or ")"
10:22:09 <clahey> @pl flip (flip (<*>) . pure)
10:22:09 <lambdabot> (. pure) . (<*>)
10:22:24 <Nimatek> :t \f x -> f <*> (pure x)
10:22:25 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
10:23:08 <clahey> :t (. pure) . (<*>)
10:23:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
10:23:24 <clahey> Huh, that's not what my ghci says.
10:24:44 <clahey> Oh, I know what I did wrong.
10:26:23 <clahey> There's what I was trying for yesterday:
10:26:25 <clahey> ((foldr1 (||) .) . ((. pure) . (<*>)) . ((. pure) . (<*>)) [(<), (==)])
10:26:28 <clahey> Lord that's ugly.
10:26:47 <jeebee> can anybody explain to me what the dollar means in: putStrLn $ "solution: " ++ show solution
10:27:07 <byorgey> jeebee: it is function application.
10:27:07 <clahey> jeebee: So, a $ b is equivalent to a b
10:27:21 <byorgey> jeebee: and it has a very low precedence
10:27:40 <Clint> @pl putStrLn $ "solution: " ++ show solution
10:27:40 <lambdabot> putStrLn ("solution: " ++ show solution)
10:27:46 <byorgey> jeebee: it is defined as:    infixr 0 $;  f $ x = f x
10:27:52 <jeebee> aha, ok thanks, i'll try to read some more about that
10:28:16 <byorgey> jeebee: people often use it to avoid writing parentheses.
10:28:36 <byorgey> jeebee: in your example, without the $ you would have to write putStrLn ("solution: " ++ show solution)
10:29:08 <jeebee> thanks all :)
10:29:14 <byorgey> jeebee: however, don't let anyone tell you that it is somehow magically related to parentheses.  it is just a normal operator.
10:29:34 <clahey> Oh yeah, that's the other thing it's useful for is that the order of operations is opposite that of standard function application.
10:30:37 <byorgey> it's not all that useful for that though.  Writing    f . g . h $ x   is much better style than    f $ g $ h $ x
10:31:28 <clahey> Oh yeah, I see what you mean.  Good point.
10:33:25 <monochrom> I prefer (...) to $
10:33:35 <mizu_no_oto> why?
10:34:10 <monochrom> also, for beginners, (...) shows the real thing, $ is syntax sugar that may promote "it's magic" rather than "it has rules"
10:34:21 <mizu_no_oto> Do you prefer (f . g . h) x?
10:34:25 <monochrom> yes
10:35:00 <monochrom> I also prefer the unambiguity of explicit parenthesizing for myself. I don't want to remember more precedence
10:35:26 <monochrom> in the long run I prefer to see the parse tree
10:35:36 <edwardk> byorgey: cale always pushed that point of view too, but i've kind of recanted in my old age. ;) i prefer writing with chained $'s to chained .'s in part for pragmatic concerns. if the inliner stops short, the latter optimizes better
10:35:49 <mizu_no_oto> monochrome: So, I heard there's this language called lisp that's supposed to be pretty nice...
10:35:53 <byorgey> pragmatic concerns, ugh
10:36:13 <edwardk> that and our type checker here sometimes explodes when you use a lot of row types and . but it works dandy with $ ;)
10:36:27 * byorgey cares not a whit for pragmatic concerns, except when necessary
10:36:39 <monochrom> lisp lacks pattern matching
10:36:45 <byorgey> edwardk: hehe
10:37:06 <monochrom> but if you say "I heard s-expression is nice", then yes
10:37:31 <edwardk> well the other consideration is that $ is a smaller reasoning step. and that its precedence is more useful than the one for .  Mixing . and ending with $ is using the two ends of the precedence spectrum
10:38:18 <mizu_no_oto> http://common-lisp.net/project/cl-match/
10:38:24 <edwardk> that means you can't use any operators with that chain, which kinda sucks =P
10:38:46 <monochrom> lisp has many other problems
10:39:26 <Shou> Please help. I'm getting an error "hGetLine: invalid argument (invalid byte sequence)", is there a way to catch this and continue reading from the handle?
10:40:14 <dcoutts> Shou: yes, it's just an ordinary exception
10:40:25 <dcoutts> you can also change the expected encoding of the handle
10:41:01 <Shou> dcoutts ★ → When I try to read from the handle again I get the same error. How would I stop that?
10:41:06 <dcoutts> Shou: the main thing is you need to decide what it is you're reading
10:41:19 <dcoutts> are you reading binary data, or text, if text, what encoding
10:41:36 <dcoutts> saying "how do I make the exception go away" is the wrong question
10:41:37 <Shou> I'm reading from an IRC server, so text and UTF-8.
10:41:42 <carter> edwardk it won't optimize as well in your version or in ghc too with $ rather than .
10:41:43 <carter> ?
10:42:08 <dcoutts> Shou: so what do you want to do when you encounter invalid utf8?
10:42:24 <monochrom> you are better off reading IRC as binary, then micro-decode each small chunk and do your fine-grain error handling
10:42:31 <edwardk> carter: $ is easy for ghc to inline, working with (.) requires the compiler to notice and inline both args to (.) into (.) and then inline that
10:43:18 <edwardk> and it may have to do all 3 of those inlinings to _start_ optimizing the two functions, because the functions are probably not fully saturated with arguments until the (.) gets inlined
10:43:39 <carter> eeeeeeeek
10:43:42 <carter> ok
10:43:49 <edwardk> and so the inliner leaves them along until the expansion of f . g = \x -> f (g x)  kicks in and gives you an 'x' argument
10:43:59 <edwardk> er leaves them alone
10:44:20 <Shou> dcoutts ★ → I'm not really sure what I could do. Skip the line and ignore it? That probably is bad.
10:45:14 <carter> edwardk: so (.) inline to the point where nice optimization happens is more "expensive"
10:45:19 <carter> in the fuel / cost model
10:45:22 <carter> that ghc uses
10:45:24 <carter> ?
10:45:41 <edwardk> in general code written with $ can call code written with $ or code written point free efficiently with good inlining code written to inline heavily that uses . had better be calling code written point free
10:45:48 <edwardk> yep
10:46:39 <dcoutts> Shou: so the default is that it decodes from utf8 bytes into a String at the point you read from the handle. Or you can change the handle to use binary mode and do the utf8 conversion yourself.
10:47:16 <dcoutts> e.g. the iconv package gives quite a bit of control over how to handle invalid encodings
10:47:34 <carter> ... so unless you're living in pointfree land in terms of code base,  $ is better
10:47:42 <carter> not obvious at all :)
10:47:46 <carter> perf wise
10:48:00 <Puffton> If I make a file with something like: a = "hello"
10:48:07 <edwardk> yeah
10:48:09 <Puffton> then in the terminal I do: a
10:48:10 <Puffton> I get "hello"
10:48:28 <Puffton> is "a" in this case a function with no args returning a string, or a string
10:48:40 <rwbarton> there is no difference
10:48:41 <monochrom> not function. just string.
10:48:43 <edwardk> Puffton: 'both'
10:48:48 <Shou> dcoutts, monochrom: Alright thanks. I'll try to look into reading it as binary and decoding myself.
10:49:11 <edwardk> Puffton: in haskell an 'Int' is a computation that will yield a machine integer when forced
10:49:35 <edwardk> > let as = 'a':as in as
10:49:36 <lambdabot>   "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
10:49:55 <monochrom> that may be unnecessarily complicated
10:49:58 <edwardk> is that a string or a procedure for generating an infinite string of 'a's?
10:50:27 <Puffton> edwardk, well, it involves logic, you are processing something
10:50:35 <Puffton> as opposed to just returning a string as-is
10:50:58 <edwardk> > let x = 1 + 2 in x    -- x starts out as a calculation, which when you look at it, demands the value of 1 and the value of 2, and then adds them, replacing itself with the value 3.
10:50:59 <lambdabot>   3
10:51:20 <rwbarton> other language draw a distinction between "function with no args returning a string" and "a string" because in those languages a function can have effects while a string cannot have effects
10:51:28 <edwardk> after that it becomes the 'trivial' calculation that just hands you back 3 each time
10:51:39 <byorgey> Puffton: if you want to understand what Haskell code *means* there is no difference.  If you want to learn about performance, how it is actually evaluated, etc., then it makes a difference.
10:51:45 <byorgey> I would suggest not worrying about it for now.
10:51:56 <monochrom> well haskell draws a distinction too because the type "[Char]" does not have an "->"
10:52:01 <edwardk> we have no side-effects here so the difference between a 0-ary function that returns a string and a string is pretty much non-existent
10:52:27 * hackagebot histogram-fill 0.7.3.0 - Library for histograms creation.  http://hackage.haskell.org/package/histogram-fill-0.7.3.0 (AlexeyKhudyakov)
10:52:39 <edwardk> if you want something tat interacts with the user and generates a string the 'do something that gets me a string' nature is usually handled by a monad of some sort. an IO String is a calculation that you can run that when finished will give you a string.
11:17:27 * hackagebot snaplet-acid-state 0.2.2 - acid-state snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-acid-state-0.2.2 (DougBeardsley)
11:18:39 <evancz> Hello! Is it possible to access the data-files of one package from another indepentdent package?
11:19:08 <evancz> i.e. use "import Paths_pkg1" from pkg2
11:20:00 <Saizan> only if pkg1 exposes that module
11:21:01 <evancz> Ok, that makes sense!
11:23:56 <Puffton> If I make a function "k a = 5" and call it: k (5+2)
11:24:07 <Puffton> since 5 does not depend on a, will (5+2) ever be evaluated?
11:24:16 <Botje> no.
11:25:45 <byorgey> theoretically, it is allowed for an implementation of Haskell to evaluate it and then throw it away, since it doesn't change anything.  In practice, no implementation does that.
11:25:58 <byorgey> a better example would be   k (error "help!")
11:26:12 <byorgey> here the call to error *must not* be evaluated.
11:30:49 <Puffton> ah yes, seems to be working fine
11:35:32 <Jeanne-Kamikaze> I'm not sure if I understand newForeignPtr; is it saying that I am not guaranteed that the object is freed as soon as the last reference is dropped ?
11:35:50 <thoughtpolice> edwardk: so, simon merged holes into GHC HEAD. i'm playing around with them on codensity right now. i don't think it's full blown agda-quality, but it does make it easy to say, write the instance for Monad (Free f). maybe i'll try yoneda later since i already did this :P
11:36:03 <edwardk> good =)
11:36:06 <djahandarie> Holes?!
11:36:26 <djahandarie> GHC is getting more and more exciting these days
11:36:56 <thoughtpolice> edwardk: djahandarie http://hpaste.org/75668
11:37:06 <thoughtpolice> (the hole is on line 29, for the Monad (Free f) instance)
11:37:19 <thoughtpolice> from the 'relevant bindings' section it's pretty easy to see the solution
11:38:12 <djahandarie> So how long before we can make it automatically fill in the holes?
11:38:24 <thoughtpolice> good question :)
11:38:41 <tam1138> hi!  i'm looking for a function takes an `a' and a [ (a -> b) ] and returns the result of passing the single `a' to each function in turn.  hoogle didn't turn anything up.  suggestions?
11:38:57 <tam1138> so the result is [b]
11:39:05 <evancz> Does anyone know about serving files with HAppStack?
11:39:32 <Cale> Jeanne-Kamikaze: It's saying that the finaliser will run at some point between the ForeignPtr being GCed, and when the program exits.
11:39:48 <Cale> tam1138: sequence will do that
11:40:05 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
11:40:06 <lambdabot>   [5,7,10,25,32]
11:40:15 <Cale> tam1138: (in the function monad)
11:40:23 <Cale> Or, you can write
11:40:24 <evancz> specifically serving files with their absolute path
11:40:33 <Cale> > map ($ 5) [id, (+2), (*2), (^2), (2^)]
11:40:35 <lambdabot>   [5,7,10,25,32]
11:40:53 * djahandarie usually uses map ($ x) FWIW
11:41:13 <djahandarie> I'm not a terribly huge fan of the function monad
11:41:27 <Eduard_Munteanu> It's just Reader :)
11:42:22 <Jeanne-Kamikaze> Cale, so if you're interfacing some C code that does not expose the definition of some structure and instead exposes constructors/destructors to create new instances, would you just make bindings for those constructors/destructors and let the user manage their resources or would you wrap it in a newForeignPtr (in which case the user has no control when the resource is free, but at least they don't have to manage it manually)?
11:42:38 <Jeanne-Kamikaze> *freed
11:43:16 <Cale> I guess it depends on how critical it tends to be that the resource is freed promptly
11:43:59 <djahandarie> Eduard_Munteanu, yes, but I just don't like it without the newtype.
11:44:36 <edwardk> thoughtpolice: thats pretty spiffy
11:47:24 <thoughtpolice> edwardk: yeah! it's making it real easy to write some of this stuff
11:47:47 <thoughtpolice> edwardk: you can't fill it in like agda, but like in that example, you can quickly see how to piece stuff together
11:48:08 <thoughtpolice> oh, i should fmap f. but now i need Free f a -> Free f b, given 'g' and (>>=), it gets pretty easy to piece it together
11:48:11 <Puffton> When do you ever use the empty tuple? Is there a scenario for it?
11:49:14 <hiptobecubic> Puffton, () ?
11:49:19 <Puffton> yes
11:49:38 <hiptobecubic> Puffton, it's just unit. It signifies lack of information i think.
11:49:53 <hiptobecubic> Kind of like void i guess
11:50:16 <edwardk> thoughtpolice: next step write an emacs plugin that calls out to djinn
11:50:17 <Puffton> oh ok
11:50:19 <hiptobecubic> you can use it to signify "something" but without giving any information about what 'it' is
11:50:20 <Cale> Puffton: One really common case is as the argument to IO
11:50:38 <hiptobecubic> IO ()
11:50:51 <Cale> the type IO () being the type of IO actions which have no useful information to return
11:50:53 <hiptobecubic> Meaning "this action does not give you anything useful back."
11:51:10 <thoughtpolice> edwardk: yea, the emacs support is when it will really get killer. :) doing all this stuff is actually maybe wanting to make me legitimately learn agda
11:51:21 <hiptobecubic> you can use them to count if you really like unary numbers
11:51:25 <Puffton> ah ok, thanks!
11:51:29 <thoughtpolice> in the past i would just try to write actual programs and run them, making me the worst agda programmer ever, obviously :)
11:51:46 <hiptobecubic> > length $ replicate 5 () ++ replicate 7 ()
11:51:48 <lambdabot>   12
11:52:11 <clahey> hiptobecubic: You said it "signif[ies] "something" but without giving information about what 'it' is"
11:52:22 <hiptobecubic> clahey, it's not "nothing"
11:52:28 <hiptobecubic> it just has no information
11:52:45 <hiptobecubic> but clearly [()] is not the same as []
11:52:45 <clahey> hiptobecubic: I mean, yeah, it's different than Nothing.
11:52:54 <hiptobecubic> Nothing is totally different
11:53:06 <hiptobecubic> Nothing says "this could have been something.. but it isn't"
11:53:14 <ion> > ([()] >> "hello", [] >> "world")
11:53:15 <lambdabot>   ("hello","")
11:53:17 <hiptobecubic> it even says the type of the thing it could have been
11:55:01 <hiptobecubic> @src [] (>>)
11:55:01 <lambdabot> xs >> ys      = concatMap (const ys) xs
11:55:21 <hiptobecubic> interesting
11:56:20 <hiptobecubic> @check xs >> ys == (concat . replicate (length xs) $ ys)
11:56:21 <ion> Incidentally, guard does exactly that.
11:56:21 <lambdabot>   Not in scope: `xs'Not in scope: `ys'Not in scope: `xs'Not in scope: `ys'
11:56:33 <hiptobecubic> @check \xs ys -> xs >> ys == (concat . replicate (length xs) $ ys)
11:56:34 <lambdabot>   Couldn't match expected type `[b]'
11:56:38 <ion> > (guard True "hello", guard False "world")
11:56:39 <lambdabot>   No instance for (Control.Monad.MonadPlus ((->) [GHC.Types.Char]))
11:56:39 <lambdabot>    arisin...
11:56:52 <ion> > (guard True >> "hello", guard False >> "world")
11:56:54 <lambdabot>   ("hello","")
11:56:56 <hiptobecubic> @check \xs ys -> (xs :: [()]) >> ys == (concat . replicate (length xs) $ ys)
11:56:57 <lambdabot>   Couldn't match expected type `[b]'
11:56:57 <nejucomo> Another example where () pops up is when using a general type where some of the generality is not needed in a particular case.
11:56:57 <nejucomo> For example, Parsec parsers in general have a parser state type parameter, but many parsers don't need parser state.
11:56:57 <nejucomo> -so their state type is ().
11:56:57 <nejucomo> I guess IO () is the same situation: IO is general to any result type, but sometimes you don't need/produce a result.
11:58:10 <clahey> @check (<=) == ((foldr1 (||) .) . ((. pure) . (<*>)) . ((. pure) . (<*>)) [(<), (==)])
11:58:12 <lambdabot>   "*Exception: (==): No overloading for function
11:58:26 <clahey> @check (<=) a b == ((foldr1 (||) .) . ((. pure) . (<*>)) . ((. pure) . (<*>)) [(<), (==)]) a b
11:58:28 <lambdabot>   "OK, passed 500 tests."
11:58:38 <hpaste> jeebee pasted “p25” at http://hpaste.org/75670
11:58:38 <clahey> God, I love this language and this channel.
11:58:44 <Puffton> Is it possible to call the operator "+" for instance, without it being infix?
11:58:57 <clahey> > (+) 5 7
11:58:58 <lambdabot>   12
11:58:59 <clahey> Like that?
11:59:05 <Puffton> ah in parenthesis
11:59:16 <Puffton> parentheses*
11:59:20 <Puffton> I just tried + 5 7
11:59:24 <clahey> Ah.
11:59:35 <clahey> Puffton: And the opposite is ``.
11:59:55 <clahey> So: sqrt `map` [4, 9]
11:59:58 <Puffton> yeah that is for non-infix operators to be used as infix
11:59:59 <Puffton> right
12:00:00 <clahey> > sqrt `map` [4, 9]
12:00:01 <lambdabot>   [2.0,3.0]
12:00:07 <clahey> I'm curious.
12:00:13 <clahey> > 5 `(+)` 7
12:00:14 <lambdabot>   <no location info>: parse error on input `('
12:00:20 <clahey> :)
12:00:20 <Puffton> > 1 `+`2
12:00:23 <lambdabot>   <no location info>: parse error on input `+'
12:00:25 <Puffton> :P
12:00:48 <bgamari> Is there a good reason why Data.Set, Data.Map, et al should not have Traversable-esque functions on them?
12:01:34 <bgamari> Given they all require Ord, it seems that it would be perfectly reasonable to write a monadic map over these structures
12:02:18 <Cale> bgamari: Do you mean a specialised Monad class for Ord-requiring structures?
12:02:44 <jeebee> In this paste (http://hpaste.org/75670), you can see I get an error on using my len function (which should give the number of digits in a number). But I do not understand why it does not work, while at the same time something like this does seem to work: [len n | n <- [1..10]]
12:02:49 <osfameron> hah.  #haskell.log is my biggest by far (and just crashed irssi)
12:03:10 <Cale> bgamari: or you just mean the one function, separately?
12:03:13 <copumpkin> I want a class Ord1 f where compare1 :: f a -> f b -> Ordering
12:03:49 <bgamari> Cale, e.g why does Data.Set.mapM exist
12:04:15 <bgamari> I understand why an actual Traversable instance can't exist
12:04:19 <bgamari> sadly
12:05:15 <bgamari> on that note, has there been any discussion concerning incorporating constraints into the standard type classes?
12:05:30 <Cale> bgamari: Good question, I guess it's because you can't really do any better of a job than using toList/fromList, but that's not much of an excuse
12:05:52 <bgamari> alright, maybe I'll put together a patch in that case
12:07:37 <Cale> jeebee: You're using !!
12:07:59 <nand`> osfameron: how large? 121 MB here
12:07:59 <Cale> jeebee: Since you do fibs !! n in the definition of fib, n must be an Int
12:08:29 <Cale> jeebee: and so anywhere that you apply fib to some parameter, that parameter must be an Int
12:08:32 <osfameron> nand`: 98MB.  my VM must have a largest filesize limit set somewhere
12:08:43 <jeebee> ok, and my len function cannot work on an int then?
12:08:45 <Cale> jeebee: and you can't take the log of an Int directly
12:09:00 <Cale> right, you need a floating point type for that
12:09:08 <jeebee> I see, I just did a :t log
12:09:12 <jeebee> thanks Cale !
12:09:36 <Cale> jeebee: But also, I believe you meant to check whether fib n had length larger than 1000
12:09:38 <Cale> by the comment
12:10:02 <jeebee> indeed. and I missed a head at the beginning ;)
12:20:03 <Puffton> read :: (Read a) => String -> a
12:20:33 <Puffton> means that "a" that is returned, is inheriting from Read?
12:21:01 <alech> hi, is there an easy way to have regular expressions which support unicode? I have strings along the lines of "titeld=S\252V 2010", but they don't match =~ "^titeld=(.+)$" :(
12:21:03 <Puffton> as opposed to "read :: String -> a" where there is no such constraint(?) on a
12:21:37 <alech> (I'm using Text.Regex.Posix for now)
12:22:52 <hc> Puffton: it means that a is an instance of the typeclass Read
12:23:32 <shachaf> Puffton: Didn't we have a conversation about the word "inheriting"?
12:23:42 <Puffton> oh yeah shachaf, I keep mixing them up :p
12:23:52 <shachaf> There's absolutely no "inheritance" involved in type classes. You'd be best off not using that word, and forgetting about OO completely.
12:24:13 <Puffton> no inheritance in haskell at all?
12:24:39 <shachaf> Pretty much.
12:25:50 <Puffton> read :: (Read a) => String -> a
12:25:54 <Puffton> is there any other way of writing this?
12:26:01 <Puffton> like read :: String -> (Read a)
12:26:02 <Puffton> or alike
12:26:07 <Cale> not really
12:26:11 <hiptobecubic> Puffton, don't think so
12:26:14 <Cale> you can choose a different variable for a
12:26:17 <shachaf> You can write read :: String -> ((Read a) => a)
12:26:17 <hiptobecubic> :D
12:26:28 <shachaf> But that'll probably just confuse you.
12:26:33 <shachaf> (Then again, maybe not.)
12:26:46 <Cale> heh, indeed you can
12:29:33 <nand`> you can spice things up with equality constraints as well, but that's completely pointless
12:30:04 <mapreduce> @src Fractional
12:30:04 <lambdabot> class  (Num a) => Fractional a  where
12:30:04 <lambdabot>     (/)             :: a -> a -> a
12:30:04 <lambdabot>     recip           :: a -> a
12:30:04 <lambdabot>     fromRational    :: Rational -> a
12:30:33 <shachaf> That constr ain't right.
12:30:58 <mapreduce> shachaf: What's the relationship between fractional and num?  That seems like the closest thing to inheritance in Haskell.
12:31:12 <nand`> mapreduce: that's called a superclass
12:31:27 <mapreduce> because if you have an instance of Fractional you know you have an instance of Num
12:31:32 <nand`> it just means ‘if a is Fractional, it must also be Num’; no more, no less
12:35:28 <Cale> nand`: It's like inheritance, except without the inheritance part, lol.
12:35:43 <Cale> Er, I mean, mapreduce:
12:36:19 <Cale> You still have to write the instances
12:38:54 <Cale> There's no ordering on when the code becomes available though, so you can implement the methods of the child and parent class in terms of each other if you want.
12:40:21 <mapreduce> Cale: That's quite interesting regarding the ordering part.
12:40:32 <shachaf> mapreduce: Why are you looking for things that are close to inheritance?
12:41:26 <Cale> mapreduce: Yeah, it really is, as nand` said, just a constraint than whenever one instance is available, so must be the other.
12:41:46 <mapreduce> I'm not, I just wondered about your statement "There's absolutely no "inheritance" involved in type classes."
12:42:21 <monochrom> it doesn't provide implementation inheritance
12:42:52 <monochrom> it also doesn't allow you to write "instance Ord Mine where x==y = ..."
12:43:24 <Cale> It's a little interesting that you can't make two classes subclasses of each other actually. I think that's mostly an artificial restriction.
12:44:14 <Cale> (it's obviously a silly thing to do)
12:46:14 <mjrosenb> shachaf: where did you say the check on the ghc version was in vector?
12:47:18 <nand`> monochrom: what do you mean, I can't write “instance Ord Mine where x==y = ...” ?
12:47:20 <nand`> oh
12:47:29 <nand`> that's from Eq, not Ord, yeah
12:48:04 <shachaf> mjrosenb: Right before the line it named in the error message, I think.
12:49:37 <Cale> but what if I wanted  class (Odd [a]) => Even a  and class Even [a] => Odd a ?
12:49:40 <Cale> :D
12:50:15 <nand`> instance Even (Mu []) -- where's the problem? :)
12:51:13 <Cale> nand`: You could even get instances going for ordinary lists, you just need a couple which are parametric.
12:51:41 <Cale> But GHC doesn't allow these classes
12:56:09 <mjrosenb> anyone know what the preprocessor happens to define when the arch is PPC or PPC64?
12:58:40 <nomeata> Are ther parsec combinators that allow me to say: use parser p, but only on input that also matches q? My usecase is to use "digit" but only when it parses exactly 4 digits.
12:59:42 <nand`> why not something like ‘replicateM 4 digit’ ?
13:00:39 <nomeata> nand`: because that returns [Char], while the digit, eh, I did say natural,  natural takes care of the conversation.
13:00:51 <nomeata> in general, imagine more complex things for p.
13:04:50 <hiptobecubic> I have a function on relations, which I just represent as (Integer, Integer). I can generate the transitive closure pretty easily, but I'm trying to think of a way to test that it's correct without just writing the same function again :/
13:05:13 <hiptobecubic> @define r @@ s = nub [(x,z) | (x,y) <- r, (w,z) <- s, y == w]
13:06:08 <hiptobecubic> @let r @@ s = nub [(x,z) | (x,y) <- r, (w,z) <- s, y == w]
13:06:09 <lambdabot>  Defined.
13:06:25 <rwbarton> what is @define I wonder?
13:06:42 <astry_> hiptobecubic: a relation is a set of pairs.
13:07:02 <hiptobecubic> astry_, yes.
13:07:13 <astry_> a pair in that relation is called a tautology.
13:07:33 <astry_> so do you have a function which works on relations, or on tautologies?
13:07:52 <mcstar> http://t-a-w.blogspot.co.uk/2012/08/7-languages-in-7-weeks.html -- look for paragraph #7
13:08:17 <hiptobecubic> astry_, relations i think
13:08:20 <mcstar> that couple of lines sum up haskell pretty good
13:08:28 <astry_> hiptobecubic: what does your function do?
13:08:45 <hiptobecubic> let relSucc = [(1,2),(2,3),(3,4)] in relSucc @@ relSucc
13:08:47 <hiptobecubic> > let relSucc = [(1,2),(2,3),(3,4)] in relSucc @@ relSucc
13:08:48 <lambdabot>   Not in scope: `@@'
13:08:53 <hiptobecubic> damnit
13:08:55 <hiptobecubic> @let r @@ s = nub [(x,z) | (x,y) <- r, (w,z) <- s, y == w]
13:08:57 <lambdabot>  Defined.
13:08:59 <hiptobecubic> > let relSucc = [(1,2),(2,3),(3,4)] in relSucc @@ relSucc
13:09:01 <lambdabot>   [(1,3),(2,4)]
13:09:26 <astry_> so your @@ is just composition
13:09:28 <hiptobecubic> > let relSucc = [(1,2),(2,3),(3,4)] in nub $ relSucc ++ relSucc @@ relSucc ++ relSucc @@ relSucc @@ relSucc
13:09:30 <hiptobecubic> astry_, yes
13:09:30 <lambdabot>   [(1,2),(2,3),(3,4),(1,3),(2,4),(1,4)]
13:09:41 <astry_> and you're trying to prove what?
13:09:43 <mcstar> Cale: can you comment on the link i pasted?
13:09:45 <astry_> correctness?
13:09:57 <hiptobecubic> astry_, yes. beyond saying "look it at. obviously."
13:10:23 <hiptobecubic> not that @@ is correct, but that a function using it is correct
13:10:29 <astry_> you need to prove that, given a relation on A x B, and a relation on B x C, you will get a relation on A x C
13:10:31 <hiptobecubic> specifically a function that generates the transitive closure
13:10:55 <astry_> so what you want to prove is that your function is of type (a, b) -> (b, c) -> (a, c)
13:11:13 <astry_> you do this by declaring your function as of this type, and compiling with ghc
13:11:16 <hiptobecubic> So essentially, given a relation, i want to prove that it is a transitive closure
13:11:17 <astry_> if it compiles then it is correct
13:11:37 <Phil___> Total beginner issue: trying to update my version of cabal and get the message "Could not find module `System.Directory' " and then am told that cabal-install-0.14.0 depends on Cabal-1.14.0 which failed to install. Any ideas how I resolve this?
13:13:36 <astry_> hiptobecubic: what function using @@ do you want to prove is correct?
13:13:42 <hiptobecubic> that proves composition, not transitive closure of a given relation
13:15:13 <hpaste> hiptobecubic pasted “Transitive closure testing” at http://hpaste.org/75675
13:15:49 <sp3ctum> when pattern matching, I can use record syntax to directly access some fields of a type. but can I refer to the whole type like with lists: @all(x:xs) ?
13:17:26 <mcstar> > data Rec = Rec { f1 :: Int, f2 :: Int }; let Rec a b = Rec 1 2 in (a,b)
13:17:27 <lambdabot>   <no location info>: parse error on input `data'
13:18:12 <mcstar> and yeah, you can do all@(Rec a b)
13:18:52 <astry_> what does "compose" do in mathematical terms, hiptobecubic?
13:18:52 <sp3ctum> i'm thinking something like function Rec {f1=nameForF1} = (do stuff with nameForFI)
13:19:08 <sp3ctum> ah, I'll try that
13:19:32 <sp3ctum> mcstar, yes. that seems to compile. thanks!
13:19:33 <hiptobecubic> astry_, i was thinking maybe some recursive function that follows the chain and checks that each is an element of the original list
13:19:45 <hiptobecubic> astry_, what do you mean?
13:20:25 <astry_> i am trying to understand your code
13:20:46 <hiptobecubic> astry_, it makes a new relation consisting of pairs which separated by one step
13:21:06 <astry_> "compose" takes two relations, c and r, but why does it also access "rel" if "rel" is passed as c?
13:21:23 <hiptobecubic> astry_, oh the actual thing i wrote. not the word in general
13:21:25 <astry_> shouldn't that bit read: nub $ r ++ ( r @@ c ) ?
13:21:34 <hiptobecubic> astry_, i wanted to play with "fix". It's uglier than it needs to be
13:21:43 <astry_> that's ok
13:21:54 <hiptobecubic> astry_, c is not a relation
13:22:01 <hiptobecubic> astry_, c is the function itself
13:22:08 <hiptobecubic> `fix` is a strange thing
13:22:16 <astry_> c is which function
13:22:20 <hiptobecubic> astry_, compose
13:22:27 <astry_> right
13:22:37 <astry_> i forgot
13:22:53 <hiptobecubic> > (fix $ \self n -> if n > 3 then n else self (n+1)) 0
13:22:54 <lambdabot>   4
13:23:50 <astry_> ok so why doesn't it read: nub $ r ++ ( r @@ r ) ?
13:23:51 <hiptobecubic> I'm sure there are more clever ways to use it. I'm basically treating it like a "iterateWhile"
13:24:13 <hiptobecubic> astry_, because that will always produce  R u R²
13:24:45 <hiptobecubic> astry_, we want R u R² u R³....
13:24:50 <astry_> i thought you wanted to start with "rel" and add pairs that are in rel @@ rel
13:24:59 <astry_> and then add more pairs
13:25:00 <astry_> and so on
13:25:01 <astry_> right?
13:25:19 <hiptobecubic> yes that is what happens
13:25:31 <hiptobecubic> first r == rel
13:25:43 <astry_> right
13:25:52 <astry_> but further r's will be supersets of rel
13:25:52 <hiptobecubic> next time compose is called, r = rel@@rel
13:26:20 <astry_> i thought the next time compose is colled it would be nub $ rel ++ rel @@ rel
13:26:27 <astry_> called
13:26:43 <hiptobecubic> no, r is already (rel @@ rel) by then
13:27:02 <astry_> you're talking about the condition "else c r'" right?
13:27:03 <hiptobecubic> so it because   (rel@@rel) ++ (rel @@ rel) @@ rel
13:27:18 <hiptobecubic> yes
13:27:25 <hiptobecubic> so r' is R u R²
13:27:48 <hiptobecubic> then the next time around, that's r
13:28:38 <hiptobecubic> so then r' is (R u R²) u R³
13:28:38 <astry_> let's say compose is in the first iterative level, and the condition is met to go to else, in that case r' is equal to nub $ rel ++ (rel @@ rel)
13:28:41 <astry_> do you see that?
13:28:47 <hiptobecubic> i do
13:28:49 <astry_> so r' will then contain r as a subset
13:28:54 <hiptobecubic> yes
13:28:56 <hiptobecubic> as it must
13:29:02 <astry_> every time you perform a recursive step you still contain rel
13:29:12 <hiptobecubic> no
13:29:23 <hiptobecubic> well, it's part 'r'
13:29:29 <astry_> sure you do. look, the first time you recurse you contain r as a subset
13:29:31 <astry_> but r is rel
13:29:42 <astry_> the next time you also contain your next r as a subset
13:29:44 <astry_> which is your r'
13:29:58 <astry_> from the previous iterative step
13:30:01 <hiptobecubic> r' is  R u R², not just R or R²
13:30:08 <astry_> which is in turn a superset of r which is rel
13:30:14 <astry_> yes
13:30:28 <astry_> R u R^2 contains R
13:30:34 <astry_> it's a superset of R
13:30:41 <hiptobecubic> So with each recursive step, we take the union of our current r and r composed with the original relation again
13:30:45 <hiptobecubic> astry_, yes
13:30:52 <hiptobecubic> in that sense, yes, rel is carried on
13:30:59 <astry_> yes
13:31:12 <astry_> therefore, you could write: nub $ r ++ (r @@ r)
13:31:18 <nicoo> hiptobecubic: Transitive closure ?
13:31:38 * nicoo is too lazy to read the backlog
13:31:48 <astry_> which could make the analysis easier
13:33:15 <hiptobecubic> astry_, that would expand to rel ++ (rel @@ rel) in the first round, then in the second round it would be   (rel ++ (rel @@ rel)) ++ (rel ++ (rel @@ rel)) @@ (rel ++ (rel @@ rel))
13:33:49 <hiptobecubic> which is R u R² u (R u R² @@ R u R²)
13:33:54 <astry_> yeah
13:33:59 <hiptobecubic> which i suppose will have R³ in it
13:34:00 <astry_> which doesn't matter
13:34:01 <astry_> :)
13:34:10 <astry_> because you still get your closure
13:34:13 <hiptobecubic> yes
13:34:24 <astry_> so what you are now trying to do is to prove that if there is a left element a, and right element b, in the range and domain of r, and if there exists a pair (a, b) in r^n for some n, then (a, b) exists in your trClos r
13:34:26 <madhadron> And today in #haskell, linear subspaces...
13:34:28 <hiptobecubic> astry_, just with a lot of repeated terms i guess
13:34:42 <astry_> they won't be repeated because you use nub
13:35:32 <hiptobecubic> astry_, yes that's what it's there. I just mean that use r @@ r instead of r @@ rel does some extra work
13:35:36 <hiptobecubic> using*
13:35:59 <astry_> you're right, it kinda is. i was just trying to understand what's going on there.
13:36:11 <astry_> ok, so do you agree with what i just said about your proof
13:36:18 <hiptobecubic> astry_, i am trying to understand it
13:36:41 <hiptobecubic> astry_, yes
13:36:48 <astry_> ok
13:37:12 <astry_> so in other words, you want to show that trClos r is a superset of r^n for any n
13:37:34 <hiptobecubic> astry_, hmmmm. Yes I suppose i do.
13:38:15 <astry_> ok, so for a given n = k, how do you show that r^k is in your trClos r?
13:38:33 <astry_> you could do this via induction
13:39:10 <hiptobecubic> hmm
13:39:14 <hiptobecubic> well
13:39:16 <astry_> given that r^(k-1) is in trClos r, show that r^k is in trClos r,
13:39:25 <trotro> trClos ?
13:39:26 <astry_> and then show that r is in trClos r.
13:41:14 <hiptobecubic> if r^k is in, then r^k+1 is in because it's either = r^k or r^k u r @@ r^k is in
13:41:38 <astry_> right
13:42:00 <Lou__> hello world?
13:42:03 <astry_> why is r in trClos r?
13:42:09 <astry_> Lou__: hello
13:42:33 <hiptobecubic> astry_, because is how trClos was called?
13:42:42 <hiptobecubic> astry_, because that is*
13:43:08 <Lou__> I'm entirely new to Haskell and only have basic knowlege of VB and Pascal, I'm studying Haskell at my university and feel a little out of my depth, any starting pointers?
13:43:12 <astry_> you need to display the actual logic flow which ends up in r being included
13:43:27 <astry_> Lou__: learnyouahaskell.com
13:43:42 <Lou__> tyvm
13:44:05 <astry_> hiptobecubic: you also need to display the actual logic flow which ends up in r^k being included, what you said is correct, but it should be in terms of code
13:44:19 <hiptobecubic> astry_, the first call to compose is with r, and every subsequent call takes a union with it or returns it?
13:44:21 <astry_> that's only a technicality
13:44:31 <astry_> hiptobecubic: that is correct
13:45:06 <astry_> now if you want to be technical, as i said, you could take your colloquial explanation and use terms from your code to explain it
13:45:13 <astry_> but that's not really necessary
13:45:36 <hiptobecubic> astry_, I am very convinced that the function works now, so that's good. But my original goal was to literally write a methodical test
13:45:57 <astry_> there is no methodical test for this
13:46:22 <astry_> you can use quicktest to do fuzztesting, but that's not an exhaustive test, it's just a fuzz test
13:46:34 <hiptobecubic> astry_, my plan was to chase along the each 'path' and confirm that the elements are all in the trClos
13:46:48 <astry_> that only shows you that trClos works for one value
13:47:22 <hiptobecubic> astry_, that is true. But i think the point of the exercise is practice fuzz testing
13:47:24 <astry_> out of a 2^\Aleph_0 possible values
13:47:26 <hiptobecubic> is to*
13:47:35 <hiptobecubic> I cannot type these days. I don't know what's happening.
13:47:35 <clahey> mcstar: Hey there.
13:47:43 <mcstar> hey
13:47:43 <madhadron> hiptobecubic, Can you algebraically transform it and arrive at an equality?
13:47:44 <clahey> mcstar: I have feedback as a player and not as a coder.
13:47:44 <astry_> well in that case you can do some fuzz testing
13:47:58 <mcstar> clahey: you can have it eithr way :)
13:48:10 <madhadron> Lou_, Out of your depth how? There are many ways to go astray.
13:49:14 <madhadron> hiptobecubic, Proving programs has a long and illustrious history at the scale of one or two functions at a time.
13:49:22 <astry_> you can start at a pair in r, and build a tree in such a way: start with (a, b), then build leafs from (b, ?) for every "?" and recurse until you either find no more or you go back to one of your earlier levels
13:49:23 <clahey> mcstar: When an object is near the edge of the screen, you have to draw it twice.
13:49:29 <clahey> mcstar: That's my biggest complaint.
13:49:39 <clahey> The flicker when objects are overlapping is a little annoying, but not life threatening.
13:49:44 <astry_> for example if you find (a, b) (b, c) (c, d) (d, b) then that's a leaf and you don't recurse
13:49:50 <mcstar> clahey: thats solved
13:49:58 <mcstar> clahey: thats why i sorted the asteroids
13:49:58 <clahey> The fact that when you finish a layer, an asteroid can appear right on top of you is life threatening.
13:50:11 <hiptobecubic> astry_, that was  my plan yes. Just working out how to do it "functionally"
13:50:17 <astry_> once the tree is built, check that all the pairs are inside trClos r.
13:50:22 <clahey> I love that when you die, the steering controls affect where your explosion goes.
13:50:29 <mcstar> clahey: absolutely, i have to exclude the vicinity of the ship from asteroids spawning
13:50:35 <astry_> well, you write a recursive function.
13:50:45 <clahey> mcstar: It needs multiple lives and storing the high score (and perhaps names)
13:50:53 <astry_> you pass it the relation r, and your tree t. and then it recurses over and over again.
13:51:13 <clahey> mcstar: The biggest issue is definitely the fact that when you're half off screen, you don't show up on the other end of the screen.
13:51:17 <astry_> you select the initial tree (i.e. the initial pair) at random from r.
13:51:18 <clahey> And you don't run into things and so forth.
13:51:58 <astry_> but i see no reason to do it because induction is a real proof and quicktest is just a convenience for coders who are too lame to do it right :^)
13:52:01 <mcstar> clahey: the original maelstrom just hides you behind a thick black frame, as well as all objects that are about to pass the border :(
13:52:29 <clahey> mcstar: Yeah, not acceptable.
13:52:51 <clahey> mcstar: IMO
13:53:11 <mcstar> those are good points, and im aware of them
13:53:11 <lispy> if I set a signal handler and then forkIO, should I expect the new thread to inherit the signal handler?
13:53:15 <clahey> Although obviously it was a popular game, so who knows.
13:53:22 * lispy isn't sure where to find this in the docs
13:53:30 <mcstar> but what im going to do next time, is tidy up the control structure
13:53:38 <mcstar> clahey: have you looked at the latest version?
13:54:09 <mcstar> i split the source into 3 files, made it a bit more readable, added top level type sigs..
13:54:21 <clahey> mcstar: I just did a pull but haven't looked at the code.
13:54:23 <astry_> um
13:54:27 <mcstar> clahey: if  you have comment on the code, you can tell me
13:54:32 <astry_> the thick black frame was a fun part of the original game guys
13:54:33 <clahey> mcstar: I think it's totally reasonable to clean up the code before working on bugs.
13:54:35 <astry_> plz don't break that
13:54:46 <mcstar> clahey: the flicker should be solved by now, that why im asking if you have the latest
13:54:53 <astry_> it was like this moment of uncertainty
13:55:02 <astry_> not knowing where your ship will show up exactly
13:55:09 <astry_> added to the thrill
13:55:20 <mcstar> astry_: hehe, youre mind works in counterintuitive ways
13:55:31 <mcstar> -e
13:55:34 <astry_> my mind?
13:55:38 <mcstar> yeah
13:55:45 <astry_> i'm glad it works at all
13:55:46 <mcstar> i dont mind
13:56:39 <astry_> it would be fun to have a maelstrom with gravitating asteroids..
13:56:54 <astry_> and real black holes and stuff..
13:57:21 <astry_> and a finite amount of fuel and asteroids propeling gas out and stuff
13:57:30 <mcstar> 'real'?
13:57:44 <astry_> yeah as in attractors
13:57:55 <clahey> mcstar: Ah, I haven't played since I updated.
13:58:00 <astry_> as opposed to something that just moves you n pixels in its direction
13:58:09 <mcstar> a black hole is not different from any other gravitational source as long as you dont go very close
13:58:40 <astry_> yeah, just that the force us strong enough that you can have things start orbiting i
13:58:43 <astry_> it
13:59:13 <mcstar> it all depends on your velocity coming from infinity
13:59:23 <mcstar> i.e. the energy you bring into the system
13:59:48 <astry_> maybe you should make a fusion of maelstrom and osmos
14:00:01 <clahey> I was about to mention osmos.
14:00:02 <astry_> i.e. you shoot asteroids, but instead of splitting, they join up
14:00:02 <clahey> So good.
14:00:03 <mcstar> idk osmos
14:00:03 <astry_> :D
14:00:13 <astry_> how can you not know osmos
14:00:18 <astry_> you are a bad person
14:00:19 <mcstar> why would i?
14:00:28 <mcstar> its not like im looking for games all day long
14:00:31 <astry_> because it's unsavoury not to know osmos
14:00:37 <clahey> mcstar: It's a little similar to asteroids.
14:00:40 <clahey> And it's so so very good.
14:00:45 <mcstar> asteroids came up as a possible next challenge for Aichallenge
14:00:51 <astry_> it's quite similar to maelstrom actually
14:00:55 <astry_> you have stuff flying around
14:01:04 <astry_> except you're this bubble
14:01:15 <astry_> if you encounter smaller bubbles you suck them out and grow
14:01:25 <astry_> if you touch bigger bubbles than you then they suck matter out of you
14:01:51 <astry_> it's fun because it does a lot with rigid body physics as well as strange attractors
14:01:57 <mcstar> astry_: i think i have to see it in action to appraciate the awesomeness
14:02:23 <astry_> seeing it in action isn't enough, you have to play it
14:02:27 <astry_> otherwise it looks stupid
14:02:50 <clahey> The other thing that's great is that to accelerate, you have to eject small bits of your protoplasm to go in the opposite direction.
14:02:56 <clahey> So in order to accelerate you have to become smaller.
14:03:02 <astry_> yeah you eject bits of yourself
14:03:13 <clahey> And if your ejected bits hit other objects, it accelerates them a little bit.
14:03:21 <clahey> And they get bigger.
14:03:27 <Ralith> am I the only one who found osmos kind of boring
14:03:37 <astry_> which has bit me a few times already, when a bubble i could eat was a bit far away, so i accelerated to get it, and by the time i got there i was smaller than the bubble and it ate me
14:03:41 <astry_> lol
14:03:43 <Ralith> nicely arted but one level's really the same as the next
14:04:15 <astry_> Ralith it got a bit tedious at some points but i thought the challenges were fun
14:04:23 <astry_> some of the levels were really tough
14:04:28 <clahey> Ralith: There are some similarities, but there were a few different variations that are very different.
14:04:31 <astry_> i wish they did more with environment
14:04:36 <astry_> not only cells and cells
14:04:41 <mcstar> that vide on its site doesnt have any effect on me at all?
14:04:41 <Ralith> yes, there were a few identifiably distinct gimmicks
14:04:42 <mcstar> .
14:04:47 <Ralith> that isn't really enough to keep the variety up
14:04:48 <clahey> My favorite are the ones where the board is just entirely covered with cells of varying sizes that don't move.
14:04:53 <mcstar> is this really good, or you are making fun of me?
14:04:59 <clahey> mcstar: Really good.
14:05:03 <astry_> it's good
14:05:06 <astry_> play it
14:05:12 <mcstar> then the video is quite shitty
14:05:12 <Ralith> it's good for an iphone game or something
14:05:18 <Ralith> I wouldn't spend money on it
14:05:22 <astry_> clahey: with the negative cells?
14:05:31 <astry_> Ralith: lies, it's good.
14:05:43 <nand`> what are examples of some Floating number types out there other than the built-in floating point types and CReal?
14:06:07 <maukd> @src Floating
14:06:07 <lambdabot> class  (Fractional a) => Floating a  where
14:06:08 <lambdabot>     pi                                                      :: a
14:06:08 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
14:06:08 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
14:06:08 <lambdabot>     (**), logBase                                           :: a -> a -> a
14:06:19 <maukd> > pi :: Complex Double
14:06:21 <lambdabot>   3.141592653589793 :+ 0.0
14:06:31 <maukd> > pi :: Char -> Double
14:06:33 <lambdabot>   *Exception: show: No overloading for function
14:06:37 <nand`> those don't help much
14:07:33 <mcstar> might be interesting to write an AI for osmos though
14:07:43 <mcstar> i will keep it on my list of suggestions
14:08:27 <maukd> > pi :: Complex (Complex Double)
14:08:28 <lambdabot>   No instance for (GHC.Float.RealFloat
14:08:29 <lambdabot>                     (Data.Complex.Comp...
14:08:53 <nand`> I just find it a bit hard to fathom that there's no compromise between the two extremes (arbitrarily defined IEEE floats with Infinity, -0, NaN and whatnot) and the super-slow, super-precise CReal
14:09:02 <nand`> something like Fixed but for floating point calculations
14:09:10 <ion> > pi :: Quaternion Double
14:09:11 <lambdabot>   Not in scope: type constructor or class `Quaternion'
14:09:52 <maukd> nand`: isn't the entire point of Fixed that it's not floating point numbers?
14:10:21 <mcstar> he meant fixed point real numbers
14:10:51 <nand`> sure, but I can meaningfully define stuff like ‘pi’ or ‘sqrt’ on fixed-precision numbers
14:11:06 <nand`> pi :: Fixed E2 would be 3.14
14:11:31 <mcstar> i would rather have the range fixed
14:11:49 <jfischoff> I want to combine configuration options using something like <|> but I have a monomorphic type. Is there an analogous typeclass I should use?
14:12:10 <jfischoff> Monoid?
14:12:13 <maukd> yes
14:12:19 <jfischoff> alright
14:13:00 <fmap> or Semigroup if you don't have an id
14:13:49 <jfischoff> got def so monoid is a go
14:13:54 <shachaf> Or Magma if it's not associative!
14:14:22 <nand`> Unital, in this case
14:14:44 <clahey> I wouldn't spend $20 on osmos definitely.
14:14:46 <jfischoff> oh what have I started
14:14:47 <clahey> Probably not $10.
14:14:51 <clahey> $1, Hell Yes.
14:15:22 <shachaf> nand`: IEEE floats aren't *that* arbitrary.
14:15:24 <ion> ~/grep osmos
14:15:27 <ion> whoops
14:16:18 <clahey> @pl \f (x:xs) -> foldM f x xs
14:16:18 <lambdabot> (`ap` tail) . (. head) . foldM
14:16:33 <clahey> Is there a function for this?
14:17:31 <monochrom> I think not
14:18:09 <clahey> @hoogle (a -> b -> a) -> a -> [m b] -> m a
14:18:10 <lambdabot> Data.Sequence scanl :: (a -> b -> a) -> a -> Seq b -> Seq a
14:18:10 <lambdabot> Prelude scanl :: (a -> b -> a) -> a -> [b] -> [a]
14:18:10 <lambdabot> Data.List scanl :: (a -> b -> a) -> a -> [b] -> [a]
14:18:30 <nand`> so would that be foldM1 or fold1M
14:19:00 <monochrom> sounds like it
14:19:12 <clahey> @hoogle [m a] -> m [a]
14:19:12 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
14:19:12 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
14:19:12 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
14:19:13 <nand`> but I mean, which of those names
14:19:42 <monochrom> ah, I think neither name has been chosen
14:20:24 <nand`> but I mean if I were to define it, which name would fall in line with the proper ‘conventions’ best?
14:20:38 <maukd> :t foldl1'
14:20:40 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:20:42 <maukd> :t foldl'1
14:20:42 <monochrom> I perfer foldM1
14:20:43 <nand`> I guess fold1M
14:20:44 <lambdabot> Not in scope: `foldl'1'
14:20:55 <nand`> with fold1M_ being the ‘void’ alternative
14:21:13 <clahey> So, it turns out foldM isn't what I'm looking for.
14:21:23 <clahey> I don't think.
14:21:29 <clahey> :t foldM
14:21:30 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
14:21:33 <clahey> Yeah, it's not.
14:21:37 <clahey> Cause I have a [m b]
14:21:51 <clahey> And I want an m a
14:22:03 <clahey> (Where a and b are both Bool)
14:22:12 <clahey> @hoogle [m Bool] -> m Bool
14:22:13 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
14:22:13 <lambdabot> Test.QuickCheck.Gen oneof :: [Gen a] -> Gen a
14:22:13 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
14:22:14 <hiptobecubic> ssequence?
14:22:24 * hiptobecubic wasn't paying attention
14:22:31 <clahey> @hoogle [IO Bool] -> IO Bool
14:22:31 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
14:22:31 <lambdabot> Control.Exception.Base block :: IO a -> IO a
14:22:31 <lambdabot> Control.Exception block :: IO a -> IO a
14:22:41 <maukd> :t fmap and . sequence
14:22:43 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
14:23:05 <clahey> I want or, actually, but yeah.
14:23:16 <clahey> So, here's what I'm curious about.
14:23:21 <clahey> In IO, if you do that...
14:23:38 <clahey> Will it still execute the IOs once it finds one that is true?
14:23:42 <clahey> Or will it short circuit?
14:23:49 <maukd> no, it will execute all actions first
14:23:55 <maukd> then it will combine the results using 'or'
14:24:27 <trotro> @src msum
14:24:27 <lambdabot> msum =  foldr mplus mzero
14:24:39 <trotro> @src mplus
14:24:40 <lambdabot> Source not found. :(
14:24:45 <nand`> it's a class method
14:24:49 <nand`> or function
14:24:57 <trotro> ha yes
14:25:06 <nand`> (sorry, been writing C# and the terms get mixed up late at night)
14:25:13 <trotro> it's (++) on list ?
14:25:27 <maukd> :t let orM [] = return False; orM (m : ms) = do x <- m; if x then return True else orM xs in orM
14:25:29 <lambdabot> Not in scope: `xs'
14:25:31 <trotro> no forget
14:25:34 <maukd> :t let orM [] = return False; orM (m : ms) = do x <- m; if x then return True else orM xs in orM
14:25:36 <lambdabot> Not in scope: `xs'
14:25:36 <trotro> saying stupid thngs
14:25:42 <maukd> :t let orM [] = return False; orM (m : ms) = do x <- m; if x then return True else orM ms in orM
14:25:44 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
14:26:01 <nand`> it is indeed (++) on list
14:26:04 <trotro> :t guard
14:26:05 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:27:22 <clahey> maukd: Cool, but nothing built in that I can construct it from.
14:27:29 <clahey> maukd: Very useful function though.
14:27:56 <nand`> well, you can define it as a foldr
14:28:16 <clahey> :t foldr
14:28:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:29:06 <maukd> :t foldr (\x z -> do b <- x; if b then return True else z) (return False)
14:29:07 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
14:29:28 <clahey> :t foldr (\m1 m2 -> m1 >>= \x -> if x then return True else m2)
14:29:29 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> [m Bool] -> m Bool
14:29:36 <clahey> :t foldr (\m1 m2 -> m1 >>= \x -> if x then return True else m2) return False
14:29:37 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m a'
14:29:37 <lambdabot>       Expected type: a -> Bool
14:29:37 <lambdabot>       Inferred type: a -> m a
14:29:40 <clahey> :t foldr (\m1 m2 -> m1 >>= \x -> if x then return True else m2) (return False)
14:29:41 <lambdabot> forall (m :: * -> *). (Monad m) => [m Bool] -> m Bool
14:34:58 <Puffton> Using list comprehensions, say I have a variable x and a list p, [(s,x) | s <- p]
14:35:31 <Puffton> Without writing another list comprehension, is it possible to also create (x,s) and add it to the list?
14:35:50 <Puffton> within the same list comprehension I mean
14:35:53 <maukd> yes
14:35:54 <nand`> [a | s <- p, a <- [(s,x), (x,s)]]
14:36:31 <nand`> or simply:  concat [[(s,x), (x,s)] | s <- p]
14:36:50 <Puffton> oh
14:36:57 <Puffton> that is neat, didn't think of that
14:37:04 <clahey> I love both of those.
14:37:35 <nand`> I would go with the latter in practice, the former was just meeting the conditions in the question as closely as possible (all within the same list comprehension)
14:37:57 <Puffton> nand` what if x was a function that was was pretty heavy to run?
14:38:12 <nand`> irrelevant
14:38:20 <nand`> oh, you mean a function; as in ‘x s’ ?
14:38:26 <Puffton> exactly
14:38:32 <maukd> [a | let x = f y z, s <- p, a <- [(s,x), (x,s)]]
14:38:37 <Puffton> yeah ok
14:38:41 <absence> is there a way to modify the data pointed to by a StablePtr, or is the normal use case to deref it, free it, and make a new one with the modified data?
14:38:41 <Puffton> you eval x inside
14:38:48 <Puffton> cool
14:39:07 <nand`> in general if you need work sharing you use ‘let .. in’
14:43:46 <clahey> mcstar: I just watched the video.  It's an awful video.
14:44:00 <clahey> mcstar: I got it as part of one of the indie bundles and started playing it and was absolutely engrossed.
14:44:17 <mcstar> theres a little known fact about me
14:44:33 <mcstar> i only understood the meaning of 'indie game' yesterday
14:44:38 <Puffton> nand`, but if the function x depends on the values in p then? i.e. on s
14:44:41 <mcstar> independent
14:45:04 <clahey> mcstar: Yeah, so you're an indie game developer.  Good work!
14:45:05 <clahey> So am I.
14:45:09 <clahey> (Not sarcastic)
14:45:12 <mcstar> XD
14:45:32 <clahey> Has anyone played with fay or any of the other haskell/js crossovers?
14:47:19 <nand`> Puffton: still works; [a | s <- p, let z = x s, a <- [(s,z), (s,z)]]
14:47:34 <Puffton> oh ok just running it after
14:47:34 <nand`> or a <- let z = x s in [(s,z), (s,z)]
14:47:38 <Puffton> I did it in the wrong order
14:49:53 <clahey> Has anyone does ICFP before?
14:56:40 <hpaste> Jeanne-Kamikaze pasted “Help: This IO thing is killing me” at http://hpaste.org/75677
14:57:10 <Jeanne-Kamikaze> guess I should've made that text format
14:57:55 <Jeanne-Kamikaze> ok the looks don't really change
14:58:02 <Jeanne-Kamikaze> ^ can someone take a look at that please ?
14:58:43 <monochrom> IO is killing you softly!
14:59:17 <monochrom> but it is a really long question
14:59:34 <tac> IO is the Choose Your Own Adventure of types.
14:59:40 <tac> Sometimes, everything works out fine
14:59:51 <tac> Sometimes, you die in a flood.
15:00:29 <monochrom> may I ignore "CSFML_GRAPHICS_API" ?
15:01:03 <Jeanne-Kamikaze> yes
15:01:13 <clahey> Jeanne-Kamikaze: How about make them thunks of some sort and then force them when needed?
15:01:23 <clahey> Let me think about what I mean...
15:02:29 <clahey> It looks like every function is a set or a get.
15:02:32 <monochrom> so the essence seems to be: a C-side pointer that Haskell side just takes and gives back uninterpreted
15:02:43 <Jeanne-Kamikaze> to summarise it up, the whole point is that I want to interface a C type that is really a C++ object, so I cannot write make a Storable version of that type in Haskell
15:02:50 <clahey> So what if you created two types?
15:03:00 <Jeanne-Kamikaze> two types ?
15:03:23 <Jeanne-Kamikaze> monochrom, yeah, but if I do that it all must happen inside IO
15:03:37 <clahey> Circle and Circle'
15:04:30 <clahey> data Circle' = Base Circle | Modification CircleOperation Circle'
15:05:08 <Jeanne-Kamikaze> so you're accumulating a bunch of operations on a Circle ?
15:05:09 <clahey> Then have a function circle'ToCircle which takes the base Circle, extracts the C pointer, makes a copy, does all the transformations, then returns the new Circle.
15:05:12 <clahey> Yep.
15:05:27 <Jeanne-Kamikaze> isn't that gonna chain up ?
15:05:34 <clahey> Jeanne-Kamikaze: How do you mean?
15:05:38 <Jeanne-Kamikaze> in memory
15:06:04 <Jeanne-Kamikaze> (Op 1 (Op2 (Op3 .... (OpN ( Base circle))).....)
15:06:04 <clahey> How many modifications are you expecting to make?
15:06:12 <clahey> Yeah.
15:06:13 <Jeanne-Kamikaze> many per second
15:06:19 <Jeanne-Kamikaze> it's a game
15:06:22 <Jeanne-Kamikaze> 60 fps
15:06:26 <Jeanne-Kamikaze> many circles
15:06:30 <clahey> How many modifications to a particular circle before you do something with it?
15:06:53 <Jeanne-Kamikaze> I don't know, 3 ?
15:07:03 <Jeanne-Kamikaze> how is the "doing something with it" gonna help ?
15:07:07 <Jeanne-Kamikaze> ah
15:07:18 <clahey> Well, you switch it back to being a Circle and then create a new Circle' for your new changes.
15:07:20 <Jeanne-Kamikaze> I see what you mean now, but I don't want to do that
15:07:28 <Jeanne-Kamikaze> create a new Circle = malloc, and malloc is slow
15:07:43 <clahey> Right.  It cuts down your mallocs by a factor of 3, but not to none.
15:07:45 <Jeanne-Kamikaze> immutable C is not an option either
15:08:10 <clahey> Jeanne-Kamikaze: Oh, I have an idea.
15:08:34 <clahey> Do what I described, but write a little bit of C code to keep a set of available circles.
15:08:42 <clahey> Then instead of a malloc, you get a copy.
15:09:02 <clahey> When you free a circle, just put it in the queue of available circles.
15:09:22 <Jeanne-Kamikaze> so you're telling me to write my own memory allocator ?
15:09:29 <clahey> Well, instead of malloc you get a copy and a pop from a queue.
15:09:31 <clahey> Yep!
15:09:34 <clahey> :)
15:09:38 <Jeanne-Kamikaze> for every type I want to interface :D ?
15:09:40 <clahey> There are other options.  I know glib has one built in.
15:09:51 <Jeanne-Kamikaze> or maybe some void* magic
15:09:54 <clahey> Naw, just create a templated type in C++.
15:09:58 <clahey> Or void* magic.
15:10:01 <Jeanne-Kamikaze> that too
15:10:11 <clahey> A templated type would be more type safe.
15:10:45 <Jeanne-Kamikaze> meh, who in their right mind writes C bindings to C++ code
15:10:55 <ion> ODE developers
15:11:06 <armlesshobo|work> sadists
15:11:20 <clahey> Jeanne-Kamikaze: People that want their code to be bindable to tons of different languages?
15:11:36 <Jeanne-Kamikaze> but then you write it in C and make a C++ interface to it
15:11:47 <Jeanne-Kamikaze> not the other freaking way around
15:11:51 <clahey> Jeanne-Kamikaze: I completely agree.
15:12:29 <clahey> Or, write it in glib objects and you get object oriented ness and a built in system for language bindings.
15:12:37 <clahey> And a culture of people that write bindings to tons of libraries.
15:13:13 <Jeanne-Kamikaze> or mail this conversation to SFML devs and make them realise that their code sucks
15:14:33 <clahey> Jeanne-Kamikaze: Well, it's certainly not functional.
15:14:39 <clahey> But neither is most code.
15:14:55 <Jeanne-Kamikaze> if it were C it would be just fine
15:15:10 <nand`> who in their right mind writes C++ code?
15:15:13 <Jeanne-Kamikaze> but it's C with vtables
15:15:27 <clahey> nand`: People who are paid to?
15:15:40 <Jeanne-Kamikaze> Feature request: can you rewrite the entire library please ? This is gonna be fun.
15:15:55 <Jeanne-Kamikaze> can you _properly_ rewrite the entire library
15:16:04 <nand`> clahey: oh, that makes sense. So, like, programmer prostitutes?
15:16:15 <clahey> nand`: Oh god, now I feel all dirty.
15:16:26 <clahey> nand`: But I mean, the same could be said of any job, couldn't it?
15:16:42 <clahey> Someone working at McDonalds isn't a chef prostitute.
15:16:49 <nand`> there are some jobs I would gladly be paid to do without having to sacrifice my dignity or my sanity :P
15:17:12 <clahey> C++ isn't bad, it's just different.
15:17:21 <clahey> And with sigc++, it's not all that far from functional.
15:17:37 <clahey> I have to go build things for free.
15:17:40 <clahey> See y'all tomorrow.
15:17:42 <mapreduce> I have 3 years experience as head prostitute at McDonalds, then I went on to be the area prostitute for Waitrose..
15:22:04 <nicoo> mapreduce: And now you (re)lie on Big Tables ?
15:22:08 <nicoo> (Good night_
15:22:11 <Polarina> Just a random question; if I have a function that evaluates a thunk of type { :: Either a b } to WHNF (`seq`), will it force it to evaluate the value enough to determine if it's definitely a Right, a Left, or something else (error, undefined, etc.)?
15:23:50 <pr>  
15:24:15 <tromp> yes, it will determine if it's Left or Right
15:24:19 <hiptobecubic> Polarina, yes
15:24:30 <Polarina> hiptobecubic, thanks. :)
15:25:12 <ion> > (Left undefined `seq` 42, undefined `seq` 42)
15:25:13 <lambdabot>   (42,*Exception: Prelude.undefined
15:27:34 <rhg135> Hello, I have a question about the correct way to solve a problem in haskell.
15:27:49 <Eduard_Munteanu> Polarina: that's what WHNF is, it gets you the first, outermost constructor.
15:27:55 <Eduard_Munteanu> rhg135: hi
15:28:00 <rhg135> hello
15:28:18 <Polarina> Eduard_Munteanu, I never really understood what that meant exactly. :/
15:29:20 <mcstar> > let e = Left undefined in e `seq` const 3 e
15:29:21 <lambdabot>   3
15:29:30 <Cale> Polarina: A term is in head normal form if: 1) It is a constructor applied to some expressions, or 2) It is a lambda applied to an expression in head normal form.
15:29:37 <rhg135> I know monads can represent failure-possible computations but how would you represent both failure-possible and failure-optional computations
15:29:57 <Cale> Polarina: A term is in weak head normal form if: 1) It is a constructor applied to some expressions, or 2) It is a lambda.
15:30:02 <kirindave> rhg135: There is a difference?
15:30:08 <Eduard_Munteanu> rhg135: what do you mean by failure-optional?
15:30:48 <rhg135> yes, failure-optional should ignore failures and backtrack and just continue
15:30:49 <Cale> rhg135: not all monads can do this, but there are data types with a valid Monad instance which can
15:31:06 <ion> @type (<|>)
15:31:07 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
15:31:39 <rhg135> I'm currently using MaybeT and WriterT and IO in a stack
15:32:07 <Eduard_Munteanu> Are you asking for something like exceptions?
15:32:14 <Cale> rhg135: It's possible you're looking for LogicT
15:32:16 <Eduard_Munteanu> That is, stuff that's either handled or not.
15:32:41 <rhg135> oh logict would work, I hadn't thought of that
15:37:34 * hackagebot gluturtle 0.0.12 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.12 (YoshikuniJujo)
16:21:37 <Polarina> mm_freak, what is "depends" in the documentation for most wires?
16:36:22 * monochrom is very dumb!
16:36:59 <madhadron> Don't feel bad. They pay me quite well and I'm a blithering idiot.
16:37:54 <monochrom> dumb mistake: (C code) typedef struct T { blahblah }; T* ctor() { T *p = malloc(sizeof(T)); initialize p->fields; /* and I forgot to return p!*/ }
16:38:17 <pnielsen> monochrom: wow, that's dumb
16:38:22 <pnielsen> dummie!
16:38:25 <monochrom> then the Haskell side, which calls the above C side code, behaves strangely!
16:38:39 <madhadron> Shouldn't -Wall on the C side catch that?
16:38:42 <madhadron> Or have I not written C in too long?
16:38:48 <monochrom> I never use -Wall
16:39:01 <pnielsen> -Wall is for sissies
16:39:15 <monochrom> well, maybe I should for C. for GHC Haskell -Wall is obnoxious
16:39:34 <hiptobecubic> monochrom, just leave -fdefer-type-errors on all the time
16:40:04 <pnielsen> monochrom: jk, btw. Sorry, I'm bored.
16:40:07 <hiptobecubic> anyway bed
16:40:41 <monochrom> anyway, the strange part is that if I "gcc -c that.c" and then "ghc haskell.hs that.o", the program does what I want. misbehaviour only when "ghc haskell.hs that.c"
16:41:14 <shachaf> monochrom: Fortunately the compiler can remind you of that.
16:41:18 <shachaf> You should use -Wall
16:41:23 <Eduard_Munteanu> monochrom: maybe ghc invokes gcc with different CFLAGS?
16:41:26 <Jafet> Wall, n. a supportive obstacle
16:41:29 <monochrom> yeah I agree with -Wall for gcc
16:41:29 <shachaf> You should use ghc -Wall too, but turn off the obnoxious errors.
16:41:48 <shachaf> gcc -Larry -Wall
16:41:55 <monochrom> yes, ghc is known to call gcc with different flags
16:42:37 * hackagebot levmar 1.2.1.3 - An implementation of the Levenberg-Marquardt algorithm  http://hackage.haskell.org/package/levmar-1.2.1.3 (BasVanDijk)
16:42:53 <monochrom> it's just strange that, without those flags, the generated code happens to have the equivalent of "return p" that I forgot :)
16:43:42 <Eduard_Munteanu> I don't know what gcc does when it notices a missing return. :/
16:44:10 <shachaf> Eduard_Munteanu: Well, it's undefined behavior, presumably.
16:44:24 <Eduard_Munteanu> Maybe it disregards it completely, and the generated code happens to work with p in %eax/%rax.
16:45:36 <Eduard_Munteanu> AFAIR, rax is the first register, the malloc call takes %rdi in and GCC might pick up rax for p.
16:46:07 <monochrom> I'm on 32-bit. it's eax :)
16:46:20 <Eduard_Munteanu> Ah. Try looking at the generated code anyway.
16:46:25 <Eduard_Munteanu> (asm level I mean)
16:47:00 <Eduard_Munteanu> (might also pick up eax because that's the return from malloc)
16:47:02 <laurent_> Hello there
16:47:11 <Eduard_Munteanu> laurent_: hi there
16:47:42 * bgamari passionately despises stack overflows
16:50:14 <laurent_> I hate to be the guy to ask a support kind of question, but… it looks like OpenGL 2.4.*.* doesn't install (via cabal) on the latest haskell platform (this exact problem: http://hydra.nixos.org/build/3010353), I couldn't find anything about it via Google so before creating a ticket I wanted to make sure no one knows a quick fix.
16:50:37 <parcs`> i wish ghci could handle hsc files
16:51:14 <parcs`> or ghc for that matter
16:51:35 <shachaf> laurent_: Yes, GHC broke compatibility by removing a Num superclass.
16:51:45 <laurent_> ah, so this is a known problem
16:51:53 <shachaf> laurent_: Any reason you're using 2.4 instead of 2.5?
16:52:29 <laurent_> GLFW-b-demo wants 2.4, I guess I'll have to hack the cabal data files to test using 2.5.
16:52:47 <laurent_> Thanks a lot for the info!
16:52:50 <Polarina> laurent_, the current haskell platform provides ghc 7.4, not ghc 7.6.
16:53:19 <laurent_> ok, I guess you mean OGL 2.5 is 7.6 only.
16:53:26 <shachaf> Oh, it is?
16:53:35 <Polarina> laurent_, OGL 2.5 works fine on 7.4.
16:53:44 <laurent_> ah, then I'm inferring all wrong.
16:54:11 <Polarina> laurent_, it's just that the errors you are seeing indicate that you have ghc 7.6.
16:54:19 <Polarina> Which is not in the haskell platform.
16:54:40 <laurent_> oki, so back to trying to have glfw-b-demo to work with ogl 2.5, I hope it just works as is 'cause I'm too much of a noob to do any deeper changes ;)
16:57:34 <Jeanne-Kamikaze> is there any particular reason why you use GLFW-b as opposed to GLFW ?
17:03:20 <bgamari> Cale: How would you write Data.Map.mapM?
17:03:59 <hpaste> “Ben Gamari” pasted “Stack overflow in mapM implementation” at http://hpaste.org/75683
17:04:09 <bgamari> My attempt (above) stack overflows
17:04:51 <laurent_> jeanne: from https://github.com/bsl/GLFW-b/blob/master/README.md it seemed that the -b version was a better choice. and that it was more haskell-ish than the other one.
17:05:04 <laurent_> I'm totally not qualified to verify it though.
17:05:26 <Polarina> Why not just use GLUT?
17:05:34 <laurent_> I hate it with a passion
17:05:45 <Polarina> I haven't had any problems with it.
17:06:00 <MostAwesomeDude> GLUT does have some pretty serious issues, but nothing that can't be fixed with a healthy heap of SDL.
17:06:17 <hpaste> monochrom pasted “FFI with C-side secret” at http://hpaste.org/75684
17:06:38 <monochrom> Jeanne-Kamikaze: I hope the above paste is useful
17:07:15 <Jeanne-Kamikaze> monochrom, which ?
17:07:27 <monochrom> 75684
17:07:27 <Jeanne-Kamikaze> ah
17:07:29 <laurent_> I just need an easy way to output some graphics for my small attempts at learning Haskell and googling led me to think that glfw is the best choice.
17:08:15 <alpounet> laurent_, depending on the kind of graphics you want, gloss can be cool too
17:08:30 <Jeanne-Kamikaze> I don't see how it's useful ?
17:08:31 <laurent_> I just wants some lines, vectors and text
17:08:45 <bgamari> laurent_, diagrams is also nice although if you just want to get something working quickly, I'd recommend gloss
17:08:52 <monochrom> it has a create and a destroy.
17:09:02 <Jeanne-Kamikaze> but I wanted the interface to be pure
17:09:08 * laurent_ googles gloss
17:09:10 <bgamari> Anyone have any suggestions about my mapM implementation above?
17:09:14 <bgamari> I'm really out of ideas
17:09:58 <monochrom> you want "use" to be pure, too?
17:10:08 * bgamari doesn't understand why laziness and him disagree so violently
17:10:24 <monochrom> because the nature of use is impure
17:10:27 <Jeanne-Kamikaze> yes
17:10:30 <Jeanne-Kamikaze> exactly
17:10:52 <Jeanne-Kamikaze> so the next solution was making a data Object in haskell and making it storable
17:11:12 <laurent_> gloss looks nice but it doesn't seem to handle input though (not that I'll need it right now).
17:11:23 <Jeanne-Kamikaze> but I can't do that because the C struct contains a C++ object which has a pointer to a vtable
17:12:19 <Jeanne-Kamikaze> at least not elegantly
17:12:38 * hackagebot x11-xim 0.0.7 - A binding to the xim of X11 graphics library  http://hackage.haskell.org/package/x11-xim-0.0.7 (YoshikuniJujo)
17:12:48 <alpounet> laurent_, there's "Game" module in there, that handles key/mouse input
17:12:57 <tibbe> do we have an up-to-date list of Hackage reverse dependencies?
17:14:05 <laurent_> alpounet: thing is I know IO isn't the easiest thing to figure out for a beginner so I'm a bit afraid to have to handle several different libs for gfx and input at the same time.
17:14:35 <laurent_> having everything handle by one seems like it'd be easier to figure out
17:14:41 <laurent_> *handled*
17:14:51 <shachaf> bgamari: I think the problem is with mapM, and has nothing to do with (Data.)Map.
17:14:59 <alpounet> laurent_, you don't, it's all in gloss. it's just in a different "module" (namespace, if you prefer)
17:15:03 <cmccann> for simple interactive graphics using SDL and graphics-drawingcombinators has always worked for me
17:15:22 <cmccann> but then again I'm used to SDL from using it in other languages
17:15:40 <laurent_> alpounet: ah, got you. I will dig in further then. Thanks!
17:16:10 <shachaf> bgamari: E.g. "mapM return [(i,i+2) | i <- [1..1000000]] >>= print" will overflow too.
17:16:17 <laurent_> cmccann: I love the term combinator, however I'm fairly certain I won't be able to use one for a bit :D.
17:16:31 <cmccann> graphics-drawingcombinators is very very easy to use
17:16:43 <cmccann> it's pretty limited but very pleasant for what it does
17:16:43 <laurent_> for a beginnerÉ
17:16:48 <Jeanne-Kamikaze> anyways monochrom I'm have to hop to bed but if you come up with another solution I'll be glad to know; I'm still giving it some more thought
17:16:49 <alpounet> tibbe, http://packdeps.haskellers.com/reverse/unordered-containers
17:16:52 <laurent_> ?
17:17:30 <tibbe> alpounet: either no one is using cassava or the list if out of date :)
17:17:39 <alpounet> tibbe, oh right
17:17:46 <alpounet> some of my packages aren't there either
17:18:01 <cmccann> laurent_, here's a (somewhat terrible) bit of code I long time ago: https://github.com/isomorphism/lazy-tetrominoes/blob/master/Main.hs
17:18:22 <alpounet> tibbe, well, the two hackage2 test instances that had reverse deps enabled that i know of are down :/
17:18:32 <alpounet> (factis research's and cmccann's)
17:19:25 <tibbe> alpounet: :/, I will just download the package index and use grep
17:19:35 <shachaf> tibbe: Are you going to edwardk's talk this month, by the way?
17:19:49 <cmccann> my hackage2 instance never actually had packages in it anyway
17:19:54 <tibbe> shachaf: I don't know when it is
17:20:01 <shachaf> If it makes you feel better, you probably already have the index in ~/.cabal :-)
17:20:03 <tibbe> shachaf: just got back from europe
17:20:10 <tibbe> shachaf: is it in mountain view or in SF?
17:20:14 <cmccann> I had real life stuff come up and had no time to tinker with hackage unfortunately
17:20:14 <shachaf> tibbe: The 18th
17:20:35 <shachaf> tibbe: I don't think the venue is decided yet.
17:20:44 <Cale> bgamari: Replace the import of Data.Map.Strict with Data.Map and there's no overflow
17:20:57 <laurent_> cmccann: too …. many … new … things … overflowing.
17:21:00 <laurent_> :)
17:21:02 <alpounet> shachaf, what is his talk going to be about? lenses i guess
17:21:04 <Cale> I'm not sure what's going wrong with the strict one...
17:21:11 <tibbe> shachaf: I will try to make it
17:21:17 <Cale> I don't have a new enough containers locally to try it
17:21:34 <cmccann> laurent_, I can explain any of that code if you want. most of it is pretty simple in concept.
17:21:36 <tibbe> Cale: if there's a containers bug, let me know
17:21:44 <shachaf> Cale: Hmm, I still get an overflow.
17:21:51 <cmccann> laurent_, but a lot is written in an ugly way...
17:21:52 <shachaf> alpounet: Naturally.
17:21:57 <bgamari> tibbe, Could you add mapM to Data.Map?
17:22:11 <tibbe> bgamari: yes, please file a bug on github so I remember
17:22:20 <tibbe> bgamari: I'm working on too many things at the same time
17:22:49 <tibbe> bgamari: there's a Traversable instance, if you don't need to go over the keys
17:22:53 <bgamari> Cale, I'm not exactly sure what was wrong with my approach (fromList/toList) but it works when I use traverseWithKey instead
17:22:56 <tibbe> bgamari: otherwise toList in the meantime
17:23:25 <bgamari> tibbe, oh man, you are right
17:23:38 <bgamari> I somehow missed the traversable instance
17:24:02 <shachaf> Huh, why doesn't :i in ghci show the Map instance?
17:24:04 <tibbe> bgamari: but is only for values, as Traversable only has a single type variable
17:24:19 <shachaf> Oh, it's because of the qualified import?
17:24:22 <shachaf> That seems like a ghci bug.
17:24:35 <tibbe> getting off the shuttle, brb
17:24:44 <bgamari> tibbe, sure, it should do fine though
17:24:55 * cmccann wishes it was possible to use TH's instance-lookup functions in GHCi...
17:25:11 <bgamari> tibbe, in that case a specialized mapM isn't necessary I guess
17:25:47 <laurent_> cmccann: I'd need two whole weeks to get it though ;)
17:26:53 <alpounet> bgamari, still working on optimizing your code / not making it overflow?
17:27:27 <bgamari> alpounet, Different piece of the code
17:27:39 <bgamari> although this last issue was just stupidity
17:27:50 <Cale> bgamari: btw, are you compiling with -O2?
17:28:05 <bgamari> Cale, Just -O
17:28:08 <bgamari> Cale, Why?
17:28:19 <Cale> I dunno
17:28:24 <Cale> I compiled with -O2
17:28:44 <Cale> I'll try with -O
17:29:12 <Cale> Okay, it's still fine
17:29:24 <Cale> I'm using GHC 7.4.1
17:29:40 <Cale> containers-0.4.2.1
17:29:58 <bgamari> hmm, I'm on ghc 7.7
17:30:12 <bgamari> with containers 0.5.0.0
17:30:22 <bgamari> this might just be the price I pay
17:30:22 <shachaf> Didn't work for me with 7.6
17:31:49 * laurent_ resists the urge to kill a baby seal and will attempt to run the glfw-b demo manually instead of trying to install the package manually (which didn't work and I don't want to know why).
17:33:25 <bgamari> shachaf, good to know
17:45:16 <hpaste> monochrom annotated “FFI with C-side secret” with “FFI with C-side secret (annotation)” at http://hpaste.org/75684#a75685
17:48:45 <monochrom> @tell Jeanne-Kamikaze http://hpaste.org/75685 is a purified version. you have a C-side sfCircleShape_copy too
17:48:46 <lambdabot> Consider it noted.
17:57:28 <alpounet> monochrom, i think he wanted to avoid malloc as much as possible
17:58:00 <alpounet> but there doesn't seem to be an actual solution that avoids all the issues he raised with the solutions he listed
17:58:51 <monochrom> well, getter operations won't need create. I don't have a getter operation. my operation (underlying operation is "use") is a mixture of getter and setter. setter must malloc
17:59:20 <monochrom> well, s/malloc/create
18:00:02 <monochrom> err, create or copy. but of course, sfCircleShape_create and sfCircleShape_copy are going to malloc
18:01:13 <Cale> seaside secret
18:04:06 <laurent_> Has anyone ever managed to get OpenGL output in Haskell under OS X and not have the window freeze ? It's the second time I'm running an OGL sample program (initial one was using GLUT) and they all freeze when run.
18:05:22 <laurent_> Mostly a rhetoric question though. Venting my frustration. Sorry for the noise.
18:07:04 <vwvwvwv> does anyone know what happened to the epigram website?
18:07:21 <vwvwvwv> I've tried a couple of times the past couple of months
18:07:41 * hackagebot gluturtle 0.0.13 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.13 (YoshikuniJujo)
18:07:55 <vwvwvwv> but it just has a blank page with "Redirecting..." plastered over it.
18:09:55 <cmccann> looks like it's the darcs thingie it redirects to that's not responding
18:10:39 <cmccann> the old blog entries and such are fine
18:11:12 <vwvwvwv> Where are the old blog entries?
18:11:21 <geisthaus> laurent_: try updating your osx gl implementation off the opengl reference site, also try updating all your drivers etc and your OS, then update haskell and glut as well
18:11:37 <cmccann> vwvwvwv, http://www.e-pig.org/epilogue/
18:11:51 <vwvwvwv> ahh, thank you :)
18:12:03 <cmccann> http://www.e-pig.org/darcsweb also seems to work
18:12:42 <alpounet> monochrom, i think it's unavoidable. it's either the way you suggest or by having any operation being of type   CircleShape -> Foo -> IO ()
18:13:01 <alpounet> (if he wants to avoid malloc-heavy code)
18:18:23 <laurent___> hum, turns out the freezing of OpenGL stuff on OS X in Haskell is a common occurrence: http://www.haskell.org/pipermail/haskell-cafe/2007-August/029932.html
18:22:05 <laurent___> Work around: http://www.haskell.org/haskellwiki/WxHaskell/Mac#Using_wxHaskell_on_MacOS_X_platforms
18:22:41 <laurent___> I hereby would like to sing my high praise for the courageous existing haskell OpenGL developers on os x'
18:23:04 <laurent___> (not that anyone needs to care) ;)
18:25:11 <carter> laurent___ I'm actually planning to circumvent that pain by writing my gui code in macruby and having the logic layer in hskell :)
18:25:24 <ivanm> carter: cheater!
18:25:25 <carter> also lets me decouple gui logic from app logic
18:25:25 <ivanm> ;)
18:26:23 <laurent___> carter: I want to do everything in haskell :(
18:27:08 <carter> laurent___ admirable dream, either a) write better libs for mac so we can love you, or b) if you want it to work nicely and be sane to do in the mean time, check ou macruby for easy use of os x gui and apis
18:28:11 <laurent___> carter: I wish I were at the stage I could do that. I will be starting with Real World Haskell to seriously learn Haskell.
18:28:17 <carter> ok
18:28:28 <carter> for mac gui work though... play with macruby
18:28:32 <carter> its not ruby
18:28:33 <lightquake> whoa, holes look neat
18:28:55 <laurent___> I think I'll try to see if I can live with the current work around.
18:28:58 <carter> its more like objective c with a dynamic type system and ruby short hand
18:29:39 <laurent___> but then I need to learn how to have the mcruby and haskell profs to communicate and that's way out of my league.
18:29:41 <shachaf> lightquake: GHC has holes?
18:29:49 <laurent___> profs=progs
18:30:23 <ivanm> carter: are you using hubris to do the communication?
18:30:44 <dolio> shachaf: Don't get too excited yet.
18:30:53 <laurent___> carter: this being said from what I understand the restriction is an os x one. And a pretty ridiculous one at that. Apple is so retarded technically that it hurts.
18:31:51 <shachaf> dolio: Too late!
18:31:52 <dolio> shachaf: It seems to be limited to letting you put _ in an expression and get a warning with type info and some extra stuff.
18:32:06 <dolio> Like, some stuff in scope.
18:32:22 <shachaf> And it turns into _|_?
18:32:30 <dolio> Something like that.
18:32:34 <cmccann> it's a start, at least.
18:32:35 <shachaf> Sounds like a localized -fdefer-type-errors
18:32:53 <cmccann> if nothing else it obsoletes the stupid ImplicitParams hack.
18:32:59 <dolio> Yeah.
18:33:27 <carter> ivanm: no, for my own pending mac dev, i'm using macruby for the gui layer
18:33:49 <carter> laurent___ which thing is an apple restriction?
18:33:51 <cmccann> cf. http://www.reddit.com/r/haskell/comments/10u7xr/ghc_head_now_features_agdalike_holes/ for anyone wondering about this holes business
18:33:54 <byorgey> dolio: what else would you want from it?
18:34:07 <lightquake> 21:31:32              <dolio> shachaf: It seems to be limited to letting you put _ in an expression and get a warning with type info and some extra stuff.
18:34:14 <lightquake> i mean, this is what i really wanted
18:34:19 <laurent___> carter: the not being able to run graphics stuff from ghci (i.e. console apps).
18:34:35 <carter> laurent___ : oh, thats not an OS X thing
18:34:53 <laurent___> It looks like the work around is essentially something that runs the haskell code as a carbon app.
18:34:54 <carter> thats how some of the libs ffi bindings are written interacting with the ghci linker in some way i've nver been able to pin down
18:34:54 <laurent___> Ah
18:35:07 <carter> i've definitely done grapphics from ghci on mac :)
18:35:18 <dolio> Editor interaction that lets me write candidate expressions to fill the hole with, query their types, fill in when type correct only....
18:35:33 <carter> its because of ffi binding + ghci having its own special linker interactions
18:35:33 <laurent___> carter: without it freezing?
18:35:49 <carter> laurent___ i need nouns not pronouns :)
18:35:55 <carter> it =?
18:36:01 <cmccann> is there anything preventing interesting editor support for GHC's holes?
18:36:02 <dolio> All the stuff I've had for a couple years with Agda.
18:36:20 <dolio> I doubt it supports all that yet, unless it's going to parse error messages.
18:36:23 <laurent___> without the ghci ran program freezing ?
18:36:37 <cmccann> obviously types in haskell don't tell you as much as they can in agda
18:36:46 <carter> laurent___ : its waiting to return
18:36:49 <carter> do control c
18:37:01 <carter> and then try your next plot
18:37:06 <laurent___> carter: oh I did, my keyboard still screams.
18:37:13 <carter> screams?
18:37:15 <cmccann> and editor support depends on someone hacking something together
18:37:22 <laurent___> carter: from the pain.
18:37:27 <laurent___> (of the ctrl-c)
18:37:45 <rwbarton> what is this, #haskell-surrealism
18:37:50 <carter> solution: use the timeout lib! :)
18:37:56 <carter> wrap the io action in a timeout
18:37:57 <carter> done
18:38:17 <carter> 30 seconds of gui is enough for plotting right?
18:38:19 <laurent___> carter: thing is I took the glfw-b demo and modified it so that it doesn't loop and just does one render and exits. That's enough to freeze it.
18:38:24 <dolio> Maybe you can hook the editor up using the GHC api directly or something. I don't know.
18:39:22 <carter> well, either fix the api, report a bug
18:39:24 <carter> or...
18:39:31 <dolio> Anyhow, the types being fancier in Agda doesn't really enter into it.
18:39:32 <carter> write a better lib?
18:39:47 <carter> i've yet to see a haskell gui lib that people liked :)
18:39:59 <carter> and browser / website side stuff dosn't quite count :)
18:40:00 <byorgey> dolio: yeah, makes sense, having a more programmatic way to get at the holes information would be a great start
18:40:17 <cmccann> I figure that hey, it exists, that's a start
18:40:24 <byorgey> yep
18:40:31 <dolio> In the mean time, I'll still write my code in Agda and then port to Haskell. :)
18:40:41 <dolio> Sometimes.
18:40:51 <cmccann> hacking better ways to use that information seems more approachable than implementing it in the first place
18:40:54 <bgamari> Does anyone know which GHC version the next Platform will ship with?
18:41:08 <laurent___> carter: I have no clue what the problem is exactly, I thought I did but now I'm more confused than when I started ;).
18:41:22 <byorgey> bgamari: word on the street is 7.4.2
18:41:29 <bgamari> damn
18:41:39 <cmccann> the prospect of trying to get type information out of GHC using the API sorta scared me last time I looked into it :[
18:42:18 <byorgey> cmccann: it can be done.  but it is indeed scary.
18:42:38 <dolio> I'm a little curious how they did this at all, really.
18:42:43 * hackagebot cakyrespa 0.0.8 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.8 (YoshikuniJujo)
18:42:45 <cmccann> (unfortunately holes are almost exactly the opposite of what I was trying to do that time)
18:42:57 <dolio> Agda has a type checking algorithm that's kind of specifically designed to facilitate this.
18:43:19 <dolio> And the algorithms I've seen for System F like stuff usually doesn't.
18:43:46 <dolio> Maybe GHC is more long the Agda lines with all the equality constraints flying around now, though.
18:44:39 * cmccann is still happy about the prospect of not abusing implicit params though
18:44:43 <dolio> We actually have this language at work, and we've been trying to do something similar. Our algorithm is basically HMF, and it's not very good for it.
18:47:21 <carter> cmccann wheres a good exposition of the agda type checking algorithm?
18:47:29 <cmccann> heh, don't ask me
18:47:36 <carter> oops, i mean dolio
18:47:46 <cmccann> yes, you did
18:47:54 <carter> darn eyeball parser mixed up the irc feed :0
18:47:58 <carter> :)
18:48:02 <dolio> Type Checking in the Presence of Meta-variables is a simplified version, I think.
18:48:17 <carter> dolio thanks!
18:48:26 <dolio> I'm sure Ulf Norell's thesis has a more detailed story.
18:48:26 <carter> i'm still needing to hop into the whole agda coding thing
18:48:40 <carter> cool
18:51:04 <dolio> I don't mean to oversell. It's good for playing around, and stuff that you wouldn't use any libraries for in Haskell.
18:51:56 <dolio> If you'd want to use a library, you'd probably have to port/wrap it into Agda.
18:52:28 * cmccann recalls an agda compiler generating some amusing Haskell code as output
18:52:32 <carter> dolio i'm not planning to *run* the code
18:52:39 <carter> :)
18:52:41 <dolio> carter: That's also good.
18:52:44 <carter> idris is for that :P
18:52:53 <dolio> Yeah, idris is neat, too.
18:53:05 <carter> i need to play with both
18:53:06 <bgamari> Why does template-haskell depend upon containers?
18:53:12 <carter> and time permitting write my own :)
18:53:15 <dolio> That's actually a slimmed-down model of how GHC could go, I guess.
18:53:23 <bgamari> Is there no way to use containers-0.5.0.0 on ghc 7.4?
18:53:32 <carter> bgamari you can do it
18:53:37 <carter> but lots of things complain
18:53:41 <dolio> Idris lets you start up a repl, and then break out into an editor, and interact with holes that way.
18:53:43 <carter> so 7.6 it :)
18:53:51 <carter> dolio yeah, i like that pice :)
18:53:53 <dolio> And it will edit your file for you.
18:54:16 <dolio> You just have to beware of something like the old GHC bug, where if you had a type error, it'd delete your file from disk.
18:54:27 <bgamari> carter, Yeah, unfortunately I'm afraid my audience will be wanting to use HP
18:54:53 <dolio> Really encourages getting the types right.
18:54:58 <carter> hehe
18:55:03 <dolio> Or version control, I guess.
18:55:19 <carter> or jsut have a nother file
18:55:21 <carter> for the proofs
18:55:34 <carter> prog.idr  prog.idrproof
18:56:04 <YayMe> darcs is distributed version control, no?
18:56:15 <alpounet> yes
18:56:20 <byorgey> yes
18:56:21 <YayMe> what sets it apart from git?
18:56:46 <byorgey> it has a simpler conceptual model and a much better UI
18:57:06 <dolio> Also darcs was doing distributed version control before it was cool.
18:57:09 <cmccann> git has a UI?
18:57:15 <cmccann> ;]
18:57:33 <byorgey> cmccann: exactly.
18:57:56 <dolio> Git is kind of like the C++ of distributed version control.
18:57:57 <YayMe> byorgey: "it" - which one?
18:58:10 <byorgey> when you need to make aliases to remember the magic incantations to do things you want to do often, you know something is wrong.
18:58:11 <YayMe> dolio: like an octopus made by nailing legs to a dog?
18:58:15 <byorgey> YayMe: darcs.
18:58:15 <cmccann> git is nicer than using non-distributed source control, and is the price one pays for using github
18:58:31 <YayMe> cmccann: Is there a darcshub?
18:58:31 <cmccann> otherwise eh
18:58:48 <YayMe> is hackage basically darcshub?
18:58:51 <cmccann> not to the same level of polish as github, I don't think
18:58:56 <Ghoul> I dont understand everything about haskell.
18:58:58 <byorgey> YayMe: yes, hub.darcs.net, but it's nowhere near as nice as github
18:59:10 <dolio> Hackage is not like github.
18:59:12 <byorgey> YayMe: no, Hackage is completely different. it does not host repositories at all.
18:59:13 <YayMe> Ghoul: I don't think even simon peyton jones could understand *everything* about haskell
18:59:21 <dolio> Patchtag is more like it.
18:59:24 <dolio> Or... darcsden?
18:59:38 <byorgey> hub.darcs.net, which is a fork of darcsden
18:59:40 <Ghoul> I don't understand why there cannot be void types
18:59:47 <byorgey> is the one with momentum these days
18:59:56 <Ghoul> and why the IO () hack is considered proper
18:59:59 <YayMe> but maybe I'm undercutting the man, I grant his intelligence is of a form I couldn't even conceptualize
19:00:24 <YayMe> Ghoul: () isn't a hack, it's just a tuple with no elements
19:00:41 <Ghoul> There we go.
19:00:44 <Ghoul> That makes sense.
19:00:55 <Ghoul> Curse he who try to Haskell from a background of C.
19:01:03 <Polarina> hub.darcs.net seems nice. :)
19:01:14 <Ghoul> It would be easier to learn if someone brainwashed me
19:01:29 <cmccann> also, () is just a regular type with one value, also written ()
19:01:47 <cmccann> it's used as the equivalent of a "void" return type because it's the standard "no information" type
19:01:49 * YayMe hands Ghoul a 2 litre of vodka
19:01:58 <Ghoul> YayMe: oh, you
19:02:23 <Ghoul> Okay what about
19:02:31 <Ghoul> Stuff like this
19:02:32 <Ghoul> Num t => ([t],[t]) -> [t]
19:02:42 <Ghoul> ** addTogether :: Num t => ([t],[t]) -> [t]
19:02:44 * hackagebot gluturtle 0.0.14 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.14 (YoshikuniJujo)
19:02:48 <cmccann> what about it?
19:02:59 <Ghoul> whatdo Num t
19:03:07 <Ghoul> and what's the significance of t after that
19:03:08 <YayMe> have you read lyah Ghoul?
19:03:15 <Ralith> "whatdo"?
19:03:15 <Ghoul> Yeah, I don't get it.
19:03:43 <Ghoul> Infact, I've probably read the part about types 5 times.
19:03:51 <cmccann> "t" is a type variable that can be any type, which is an instance of the type class "Num". which basically means you can use +, *, and such
19:03:58 <YayMe> it constrains the types to T, go read C# generic constraints as a primer maybe coming from C that will make more sense
19:04:27 <cmccann> it's what Haskell uses as a more explicit version of what you'd do with overloaded functions in C
19:04:42 <Ghoul> Gotcha.
19:04:47 <Ghoul> How do I do multiple.
19:05:02 <Ghoul> like Num a => Num b => a -> b
19:05:08 <Ghoul> or something like that, how does that work.
19:05:27 <cmccann> you can't do anything useful with that type, because Num doesn't give you conversions except from Integer
19:05:37 <cmccann> there's no implicit type conversion in Haskell, note
19:05:39 <cmccann> unlike many languages
19:05:54 <cmccann> but there are other type classes that define conversions you can use
19:05:57 <cmccann> :t realToFrac
19:05:58 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
19:06:01 <cmccann> :t fromIntegral
19:06:02 <lambdabot> forall a b. (Integral a, Num b) => a -> b
19:06:33 <cmccann> (have I mentioned lately that Real is a terrible name for that class, btw?)
19:06:45 <Ghoul> Er
19:06:50 <Ghoul> Idirectly the answer I was looking for
19:07:03 <Jafet> class Unreal
19:07:04 <Ghoul> was (Type a, Type b, Type c) => a -> b -> c
19:07:07 <Ghoul> But thanks.
19:07:30 <cmccann> note that there are separate type classes for conversions to and from basic numeric types, i.e. Integer and Rational
19:07:59 <cmccann> which is why those two functions have different constraints for the types "a" and "b"
19:08:13 <laurent___> oki, the wxhaskell work around for gui freezing doesn't work on os 10.8 so I just can't do what I want.
19:08:43 <laurent___> Ie, I now need to install bootcamp on my mac to run OpenGL in Haskell.
19:09:08 <Ghoul> So what can x be.
19:09:13 <Ghoul> if I have
19:09:17 <Ghoul> myFunction x = ...
19:09:28 <Ghoul> can x be a ([x],[y]) or something
19:09:45 <cmccann> it can be whatever you need it to be depending on how you use it
19:10:06 <cmccann> > let myFunction x = length (fst x) + length (snd x)
19:10:07 <lambdabot>   not an expression: `let myFunction x = length (fst x) + length (snd x)'
19:10:11 <cmccann> > let myFunction x = length (fst x) + length (snd x) in myFunction
19:10:12 <lambdabot>   Overlapping instances for GHC.Show.Show
19:10:13 <lambdabot>                              (([a],...
19:10:17 <cmccann> :t let myFunction x = length (fst x) + length (snd x) in myFunction
19:10:19 <lambdabot> forall a a1. ([a], [a1]) -> Int
19:10:22 <cmccann> ok I really need to get to bed
19:10:25 * cmccann sighs
19:10:44 <Ghoul> I see
19:10:51 <Ghoul> What constrains [x]
19:10:57 <Ghoul> is it a single list element
19:11:15 <cmccann> as a type, [a] means "a list of things of type 'a'"
19:11:21 <cmccann> as a value, it means a single-element list
19:11:25 <YayMe> Ghoul: it can be anything, so long as the functions that apply to it in myFunction support the type use consistently
19:11:28 <cmccann> yes, it's a bit confusing
19:11:46 <cmccann> :t [1,2,3]
19:11:47 <Ghoul> yeah I just got a headache
19:11:48 <lambdabot> forall t. (Num t) => [t]
19:12:45 * hackagebot gluturtle 0.0.15 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.15 (YoshikuniJujo)
19:13:24 <Ghoul> Mhm
19:13:30 <cmccann> anyway, the use of [] brackets is a special syntax for lists
19:13:45 <cmccann> I wouldn't worry about it, that's just a "by definition" thing
19:14:56 <YayMe> :type ++
19:14:58 <laurent___> Anyway, there's not much I can do to solve it at this stage so I'll let you in peace for now ;). This problem hasn't been solved since 2007 so I guess the motivation is a bit lacking :D.
19:15:03 <YayMe> :t (++)
19:15:04 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:15:06 <YayMe> Ghoul: f x = x ++ x; g y = f y
19:15:09 <laurent___> Thanks to everyone for their help.
19:15:14 <cmccann> Caleskell strikes again
19:15:19 <cmccann> :t (Prelude.++)
19:15:21 <lambdabot> forall a. [a] -> [a] -> [a]
19:15:22 <YayMe> Ghoul: Now look at that and tell me what type y is
19:15:46 <Ghoul> I can't even tell you what f and g are
19:16:00 <YayMe> Ghoul: functions
19:16:17 <YayMe> Ghoul f and g are both functions which take a single parameter (named x and y respectively)
19:16:39 <Ghoul> makes sense
19:16:46 <Ghoul> didnt think haskell had semicolons
19:17:07 <YayMe> Ghoul: I didn't use the semicolon correctly, ignore it, I was just trying to delineate that it's 2 functions
19:17:27 <cmccann> Haskell does use semicolons to separate things, though
19:17:31 <YayMe> yeah
19:17:33 <pqmodn> :t mconcat
19:17:34 <lambdabot> forall a. (Monoid a) => [a] -> a
19:18:14 <Ghoul> uh
19:18:37 <cmccann> the whitespace-sensitive syntax is defined by translation to explicit blocks and delimiters using {} and ;
19:18:37 <Ghoul> y = [..]
19:19:07 <YayMe> Ghoul: there's only one function in my whole definition which has a type constraint, did you spot it?
19:19:19 <YayMe> f x = x ++ x
19:19:23 <YayMe> g y = f y
19:19:32 <Ghoul> Yeah i saw that
19:19:41 <YayMe> :t (++)
19:19:42 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:19:46 <Ghoul> so I assume y is an array
19:19:49 <Ghoul> er
19:19:49 <Ghoul> list
19:19:56 <YayMe> right
19:20:28 <Ghoul> :t (++) means nothing to me.
19:20:30 <lambdabot> parse error (possibly incorrect indentation)
19:20:35 <YayMe> Ghoul: and that's the trick of haskell's type inference, it assumes things in the same way you managed to assume
19:20:47 <YayMe> Ghoul: that's fine, ignore it
19:21:05 <cmccann> if you're wondering what :t means it means "what's the type of this thing"
19:21:07 <monochrom> consider (++) :: [a] -> [a] -> [a]
19:21:09 <Jafet> :t Prelude.++
19:21:11 <lambdabot> parse error on input `Prelude.++'
19:21:13 <Jafet> :t (Prelude.++)
19:21:14 <lambdabot> forall a. [a] -> [a] -> [a]
19:21:23 <cmccann> it's used in GHCi, but lambdabot responds to it as well
19:21:48 <YayMe> as soon as I make it: f x = x + x
19:21:52 <YayMe> :t (+)
19:21:52 <lambdabot> forall a. (Num a) => a -> a -> a
19:22:03 <YayMe> see the type signature, what does x have to be now?
19:22:20 <Ghoul> A number.
19:22:29 <shachaf> x's type is a
19:22:36 <Guest955> @type map
19:22:37 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:22:46 * hackagebot cakyrespa 0.0.9 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.9 (YoshikuniJujo)
19:22:48 <YayMe> Ghoul: Correct, specifically "Num" as it said in the signature
19:23:07 <YayMe> Ghoul: There's other types of numbers than just Num
19:23:09 <YayMe> :t (/)
19:23:10 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:23:40 <cmccann> "Num" means "things you can convert integers to"
19:23:44 <YayMe> Fractional is a type of number too, like 1/2
19:24:00 <Ghoul> So uh
19:24:08 <Ghoul> Is this valid
19:24:09 <cmccann> with some operations that make sense for that, like addition and multiplication
19:24:14 <Ghoul> myFunc :: [Num] -> Num
19:24:17 <Ghoul> or do I have to do this
19:24:18 <Mortchek> Fractional and Num aren't types, they typeclasses
19:24:23 <Mortchek> they're*
19:24:24 <YayMe> Ghoul that's a valid type signature yep
19:24:27 <Ghoul> myFunc :: (Num a) => [a] -> a
19:24:29 <Mortchek> No it isn't
19:24:38 <YayMe> No? N/m
19:24:40 <cmccann> it's a valid type signature but it doesn't mean what Ghoul wants
19:25:00 <cmccann> Ghoul, the latter is what you want, yes
19:25:22 <Mortchek> A typeclass describes an interface common to many types
19:26:02 <cmccann> a structured way to specify groups of overloaded functions was roughly the original motivation, I think
19:26:05 <Mortchek> (Num a) => a basically means "any type that is of the typeclass Num"
19:26:34 <Ghoul> I see
19:26:43 <Ghoul> so if I say that (Num a) =>
19:26:49 <Ghoul> like this
19:26:54 <Ghoul> (Num a) => [a] -> a
19:27:01 <Ghoul> Then it has to be the same type the whole way through>
19:27:03 <Ghoul> *?
19:27:04 <cmccann> yes
19:27:06 <cmccann> :t sum
19:27:08 <lambdabot> forall a. (Num a) => [a] -> a
19:27:28 <Ghoul> So I cannot imput an Integer
19:27:32 <Ghoul> and output a Float
19:27:34 <Ghoul> in that example
19:27:36 <Mortchek> Right
19:27:40 <cmccann> correct
19:27:43 <Ghoul> Makes sense.
19:27:46 * hackagebot gluturtle 0.0.16 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.16 (YoshikuniJujo)
19:27:52 <Ghoul> The correct syntax for that then would be
19:28:10 <Ghoul> (Integer a, RealFloat b) => a -> b
19:28:18 <cmccann> no, Integer is a type
19:28:30 <Mortchek> Perhaps you mean Integral
19:28:30 * Ghoul is lost again
19:28:36 <pqmodn> :t fromIntegral
19:28:37 <lambdabot> forall a b. (Integral a, Num b) => a -> b
19:28:44 <Ghoul> I cannot use a type?
19:28:44 <Cale> Ghoul: Types and type classes are two separate things
19:28:49 <Ghoul> Oh good lord.
19:28:51 <Mortchek> Int and Integer are types of the Integral typeclass
19:29:02 <YayMe> Ghoul: You had it right except Integer is just the wrong term, you wanted the term Integral
19:29:05 <Cale> Ghoul: Type classes constrain the set of types which type variables range over
19:29:07 <cmccann> type variables are written in lowercase, and you can constrain them to have certain type classes
19:29:12 <Ghoul> So then I'd have to do
19:29:19 <Ghoul> (RealFloat a) => Integer -> a
19:29:30 <Cale> That's a valid type
19:29:45 <Cale> (I haven't followed the rest of the conversation though)
19:30:02 <Mortchek> If you wanted to be even more general, you could say (Integral a, RealFloat b) => a -> b
19:30:02 <cmccann> but if you want to output a Float specifically you don't need type classes at all, just Integer -> Float
19:30:20 <Ghoul> Hmm
19:30:26 <cmccann> :t round
19:30:27 <Mortchek> In which case it will accept an Int or an Integer or anything else of the typeclass Integral
19:30:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:31:22 <cmccann> but again, it's reasonable to just write functions that use concrete types
19:31:28 <cmccann> especially when first learning the language
19:32:02 <cmccann> if you want to do something with an Integer and produce a Float, you can just make the type Integer -> Float and call it a day
19:32:24 <forgreatgood> Hi - Is there a way for me to interact with the lambdabot without spamming out the chat?
19:32:25 <cmccann> (though I'd use Rational or Double instead)
19:32:33 <cmccann> forgreatgood, use /msg
19:32:42 <cmccann> lambdabot will talk to you privately all you want
19:32:48 <forgreatgood> Thanks
19:33:03 <cmccann> you can also install your own lambdabot locally but that's not simple if memory serves me
19:33:21 <Ghoul> couldnt you just use ghci
19:33:23 <lpvb> type classes are like interfaces that types have to obey, and monads are like burritos
19:33:30 <cmccann> lambdabot does more stuff than GHCi does
19:33:31 <alpounet> forgreatgood, to get the type of an expression, you have to write '@type your_expr' though, :t doesn't work
19:33:53 <cmccann> @djinn (a -> b -> c) -> (a -> b) -> a -> c
19:33:54 <lambdabot> f a b c = a c (b c)
19:33:57 <Ghoul> Monads just
19:33:59 <Ghoul> I don't even.
19:34:07 <Mortchek> Monad is also a typeclass
19:34:08 <cmccann> see, lambdabot will even write code for you based on the type :]
19:34:10 <Ghoul> What's the point.
19:34:10 <forgreatgood> Ok, thanks. And yeah - I'm on Windows, and lambdabot (and all it's extra features) are only available on Linux
19:34:19 <Ghoul> ** of monads.
19:34:19 <forgreatgood> I tried to install it in a VM but I had issues building it
19:34:31 <cmccann> yeah, just /msg lambdabot instead, it's simpler
19:34:33 <Mortchek> The point is whatever the particular Monad was written for
19:35:22 <cmccann> the point of Monad is that it describes a common pattern of using various types. people get hung up on understanding the type class instead of using the types that are why it exists
19:35:49 <Ghoul> A monad is a ... macro?
19:36:02 <lpvb> type class
19:36:03 <cmccann> no, it's just a type class, like Num.
19:36:06 <cmccann> :t mapM
19:36:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
19:36:44 <Ghoul> Then what's the point of >>==
19:36:57 <Ghoul> clearly I read the wrong thing on Monads x__x
19:37:07 <cmccann> well, what's the point of + or *?
19:37:17 <cmccann> it's just an operation defined for the Monad type class
19:37:51 <cmccann> what it means depends on the specific type, just like + works differently depending on what type you're using it on
19:37:52 <YayMe> :t (>>==)
19:37:53 <lambdabot> Not in scope: `>>=='
19:37:57 <cmccann> :t (>>=)
19:37:58 <YayMe> :t (>>=)
19:37:58 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:37:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:38:19 <Ghoul> Okay
19:38:36 <cmccann> note that Monad is a type class defined on data structures, instead of single types, hence stuff like "m a"
19:38:55 <pqmodn> :t flip ($)
19:38:56 <lambdabot> forall a b. a -> (a -> b) -> b
19:39:01 <cmccann> which is why it's a little trickier to make sense of out of context
19:39:06 <Cale> Ghoul: http://www.haskell.org/haskellwiki/Monads_as_computation is an attempt to explain why we care about monad as an abstraction, but cmccann is correct: understanding the examples of monads is more important than understanding monads generally, and the latter will come with experience anyway.
19:39:20 <cmccann> consider this instead:
19:39:22 <cmccann> :t fmap
19:39:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:39:44 <cmccann> Functor is a type class that roughly describes data structures where you can map a function over the contents
19:40:00 <Ghoul> Cale: ty
19:40:06 <cmccann> mapping over the elements in a list being the obvious example
19:40:19 <Ghoul> cmccann: Im not sure of the link
19:40:30 <Ghoul> So lemme go un-headache and read that thing Cale sent me
19:40:31 <lpvb> Monads are like burritos, they take a type t and puts it in a new type M t, a burrito takes a type like beans, chicken, or beef and puts it into a new type Burrito beans or Burrito chicken
19:40:43 <cmccann> eh, just trying to illustrate type classes applied to data structures instead of specific types
19:40:47 <cmccann> with something simpler than Monad
19:41:07 <shachaf> lpvb: Come on.
19:41:07 <cmccann> man, I could go for a burrito right now. sounds tasty.
19:41:22 <shachaf> cmccann: Just another reason to move to CA!
19:41:27 <Mortchek> > fmap (\n -> 2*n + 1) [1..]
19:41:29 <lambdabot>   [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,...
19:41:29 <cmccann> @quote endospacesuit
19:41:30 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
19:41:55 <YayMe> haha
19:41:57 <Ghoul> > map (\ (x) -> n + 1) [1..10]
19:41:59 <lambdabot>   [n + 1,n + 1,n + 1,n + 1,n + 1,n + 1,n + 1,n + 1,n + 1,n + 1]
19:42:17 <cmccann> Ghoul, making fun of "explanations" of monads that just confuse people further is a popular passtime in #haskell
19:42:19 <Ghoul> Oh
19:42:22 <Mortchek> You accidentally used a free variable it looks like
19:42:24 <Ghoul> > map (\ (x) -> x + 1) [1..10]
19:42:26 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
19:42:44 <Ghoul> How do I do recursiveness
19:42:45 <dmwit> A burrito is just a "sparingly" in the category of food pyramids, what's the problem?
19:42:46 <Ghoul> in a lambda function
19:42:50 <dmwit> Ghoul: fix
19:42:51 <dmwit> :t fix
19:42:52 <lambdabot> forall a. (a -> a) -> a
19:42:53 <Ghoul> if I  want the lambda to call itself
19:43:05 <dmwit> (or just use let)
19:43:13 <Ghoul> What's fix do.
19:43:17 <Ghoul> Can you give an example
19:43:19 <dmwit> recursion
19:43:23 <Mortchek> Giving it a name is the easiest way, I think
19:43:26 <cmccann> > fix error
19:43:27 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
19:43:28 <dmwit> > fix (1:)
19:43:29 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
19:43:43 <jfischoff> @src fix
19:43:44 <lambdabot> fix f = let x = f x in x
19:43:55 <dmwit> > fix (\factorial n -> if n == 0 then 1 else n * factorial (n-1)) 5
19:43:57 <alpounet> there you go, another headache
19:43:57 <lambdabot>   120
19:43:57 <Mortchek> > let f 0 = 1; f x = 2 + f (x - 1) in f 10
19:43:59 <lambdabot>   21
19:44:11 <dmwit> Ghoul: There's a less unhelpful answer, perhaps.
19:44:28 <cmccann> Ghoul, the straightforward version is that "fix f" is "f (fix f)"
19:45:03 <Ghoul> > map (\ (x) -> case x of 0 -> 0; 1-> 1; _ -> x + fix (x - 1)) [1..10]
19:45:05 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
19:45:16 <cmccann> but nobody really uses fix because it's awkward and confusing
19:45:30 <cmccann> using "let" to give something a name is more sensible
19:45:55 <dmwit> > map (\f x -> case x of 0 -> 0; 1 -> 1; _ -> x + f (x - 1)) [1..10]
19:45:56 <lambdabot>   No instance for (GHC.Enum.Enum (t -> t))
19:45:56 <Ghoul> What if I want to fix that error while keeping it nameless to confuse myself
19:45:56 <lambdabot>    arising from a use of `e_100111...
19:45:57 <dmwit> uh
19:46:05 <dmwit> > map (fix (\f x -> case x of 0 -> 0; 1 -> 1; _ -> x + f (x - 1))) [1..10]
19:46:06 <lambdabot>   [1,3,6,10,15,21,28,36,45,55]
19:46:07 <Mortchek> >> let a = 0:b; b = 1:a in a
19:46:10 <Mortchek> > let a = 0:b; b = 1:a in a
19:46:11 <lambdabot>   [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,...
19:46:22 <Ghoul> Oh hey you can give lambda's names?
19:46:43 <pqmodn> > let f = \x -> x + 10 in f 5
19:46:44 <lambdabot>   15
19:46:47 <shachaf> You can give anything a name.
19:46:56 <Ghoul> (\f x
19:46:59 <Ghoul> what's that mean.
19:47:07 <dmwit> Ghoul: It means \f -> \x ->
19:47:16 <shachaf> Ghoul: You should probably find an introduction to Haskell and read it.
19:47:21 <dmwit> So the answer to your question is "yes, you can give lambdas names, but that's not what I did".
19:47:34 <Ghoul> Ah, okay.
19:47:39 <shachaf> People here can answer these questions, but reading an introduction is probably much nicer and less ad-hoc.
19:48:34 <cmccann> eh, sometimes a conversation helps people learn more than reading
19:50:05 <shachaf> cmccann: Sure. At a certain point there's a trade-off.
19:50:44 <cmccann> anyway, Ghoul mentioned earlier trying to read LYAH and not making progress understanding it
19:51:07 * Ghoul is gonna just disappear now
19:51:33 <cmccann> people are almost always happy to answer questions in here anyway
19:52:27 * cmccann should probably get to bed. :T
19:52:30 <YayMe> Ghoul: Feel free to ask questions when you don't understand things in here, I wouldn't understand any haskell if it weren't for this place, granted I'm not particularly good at it yet either :)
19:53:02 <forgreatgood> In the theme of asking questions, I'm working through LYAH to supplement lecure material on programming langs, and I'm not sure about pointfree functions
19:53:08 <Ghoul> I guess I'll attempt to learn me a haskell again then.
19:53:09 <forgreatgood> lecture*
19:53:16 <dmwit> Pointfree is sort of...
19:53:18 <dmwit> meh
19:53:34 <forgreatgood> I have this function that I need to rewrite as pointfree. I'm not sure if I removed enough points
19:53:39 <dmwit> I can sort of see the point of it, but really it's a pretty minimal win compared to the other wins you can get by learning other things.
19:53:52 * lispy agrees with dmwit 
19:54:12 <dmwit> Anyway, of course feel free to ask any question.
19:54:21 <YayMe> dmwit: You mean just learning to do things point free?
19:54:46 <dmwit> Since that isn't a complete sentence, I have a hard time telling whether that's what I mean or not.
19:54:50 <lpvb> @pl f g (x,y,z) = (x,y,g z)
19:54:50 <lambdabot> (line 1, column 13):
19:54:50 <lambdabot> unexpected "="
19:54:50 <lambdabot> expecting variable, "(", operator or end of input
19:54:50 <Mortchek> Not all functions can be intuitively expressed point-free
19:54:52 <YayMe> dmwit: I feel like I see point free style pretty often no?
19:54:52 * cmccann prefers the term "pointless"
19:54:54 <Mortchek> Some get quite ugly
19:55:03 <forgreatgood> my_function xs = map (\x -> x^2) xs is a simple function that I wrote to square the numbers in a list,
19:55:06 <forgreatgood> using map and a lambda
19:55:11 <dmwit> YayMe: Yep, it's pretty common.
19:55:11 <YayMe> dmwit: Sorry I meant, you said point free is meh in regards to learning or usage?
19:55:16 <Mortchek> forgreatgood, do you know about sections?
19:55:32 <mapreduce> > map (^2) [1..10]
19:55:33 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
19:55:33 <forgreatgood> My first attempt to make it pointfree: pointfree_squares = map (\x -> x^2)
19:56:01 <dmwit> YayMe: Both, I think?
19:56:13 <forgreatgood> Mortchek: Not by that name? Unless I missed something
19:56:28 <Ghoul> holy
19:56:30 <Ghoul> flying
19:56:31 <Ghoul> what
19:56:32 <copumpkin> > scanl1 (+) [1,3..]
19:56:33 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
19:56:43 <dmwit> forgreatgood: Yep, that's a good start. Typically in the pointfree style you'd write (^2) instead of (\x -> x^2), but otherwise looks good to me.
19:56:46 <Ghoul> map (^6+2-9) [5..8]
19:56:47 <ivanm> copumpkin: :o
19:56:54 <copumpkin> moo
19:56:54 <mapreduce> > let pointfree_squares = map (^2) in pointfree_squares [1..10]
19:56:56 <lambdabot>   [1,4,9,16,25,36,49,64,81,100]
19:57:03 <Ghoul> > map (^6+2-9) [5..8]
19:57:04 <lambdabot>   The operator `GHC.Real.^' [infixr 8] of a section
19:57:05 <lambdabot>      must have lower prec...
19:57:12 <Ghoul> Forget it, too hard.
19:57:16 <dmwit> > map (^(6+2-9)) [5..8]
19:57:17 <lambdabot>   [*Exception: Negative exponent
19:57:20 <Mortchek> forgreatgood, (^2) is one such example. It's like writing (\n -> n ^ 2)
19:57:33 <YayMe> dmwit: So you don't think it's usage is a particular win over not using it? I'm still trying to understand what the common opinion is of a lot of things in haskell, not trying to argue a point
19:57:48 <dmwit> > map ((^6).(+2).subtract 9) [5..8]
19:57:50 <lambdabot>   [64,1,0,1]
19:57:51 <lpvb> @pl \x -> x^6+2-9
19:57:52 <lambdabot> subtract 9 . (2 +) . (^ 6)
19:57:57 <Mortchek> Likewise, (2^) is like writing (\n -> 2 ^ n)
19:58:00 <cmccann> pointless style is good when it makes things more readable, and bad when it makes them less readable
19:58:06 <cmccann> and that's really all there is to say on the matter
19:58:08 <shachaf> ==cmccann
19:58:09 <dmwit> YayMe: There are a few times where point-free style is a big win on readability and reusability.
19:58:26 <jfischoff> > map (**(6+2-9)) [5..8]
19:58:27 <lambdabot>   [0.2,0.16666666666666666,0.14285714285714285,0.125]
19:58:32 <dmwit> However, it's much, much more common than this argument is true.
19:58:40 <mapreduce> @pl \x y -> x * y + y *2 + x
19:58:40 <lambdabot> flip =<< ((+) .) . (`ap` (2 *)) . ((+) .) . (*)
19:59:21 <ParahSailin_> :t ap
19:59:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:59:23 <forgreatgood> So in this case it seems to improve readability
19:59:23 <Mortchek> @pl \x -> x ^ x * x + x
19:59:23 <lambdabot> (+) =<< (*) =<< join (^)
19:59:30 <shachaf> If you really like point-free style, go use a concatenative language.
19:59:31 <lpvb> does lambdabot always give the most concise pointless version or is it approximate?
19:59:31 <forgreatgood> Is this a case of function composition then?
19:59:48 <shachaf> lpvb: It's impossible to give the most concise point-free version.
19:59:56 <mapreduce> lpvb: It does not.
19:59:57 <lpvb> that's what I thought
19:59:57 <cmccann> lambdabot gives a very simple translation
20:00:09 <cmccann> by which I mean the translation process is simple, not the expression
20:00:10 <shachaf>  @pl is an optimizing compiler.
20:00:12 <mapreduce> @pl \x y -> x * x + y * y
20:00:13 <lambdabot> (. join (*)) . (+) . join (*)
20:00:52 <YayMe> What's a good concatenative language?
20:00:53 <cmccann> @pl \x -> x > 5 && x < 11
20:00:54 <lambdabot> liftM2 (&&) (> 5) (< 11)
20:00:55 <YayMe> out of curiosity
20:00:57 <rwbarton> if @pl is an optimizing compiler I don't want to know what it is optimizing for
20:01:07 <mapreduce> that one has a much simpler pointless representation but I can't get it to come out of my head.
20:01:12 <Mortchek> rwbarton, lack of points :P
20:01:13 <cmccann> rwbarton, for hilarity?
20:01:50 <cmccann> mapreduce, any expression with multiple arguments that are used multiple times each is probably not going to have a nice pointless form
20:02:21 <mapreduce> I think join helps with that particular case.
20:02:34 <shachaf> Mortchek: "lack of points" is the "compiler" part.
20:02:35 <forgreatgood> So for the educational takeaway of that pointfree function (map (^2)) - It's an example of a partially applied function because I only give one input function to map?
20:03:07 <shachaf> forgreatgood: "partially applied" is kind of a meaningless term.
20:03:17 <shachaf> Don't worry about whether things are partially applied or not.
20:03:45 <cmccann> mapreduce, that said...
20:03:53 <Mortchek> (^2) is a function accepting an argument and returning its square
20:03:59 <cmccann> > ((+) `on` (^2)) 3 4
20:04:00 <lambdabot>   25
20:04:26 <mapreduce> That was what I was looking for, on.
20:04:34 <cmccann> but that doesn't really generalize
20:04:36 <lpvb> Haskell makes a great alternative to brainfuck if you make everything pointless
20:04:52 <jfischoff> shachaf: I wouldn't say it is a meaningless
20:05:10 <ParahSailin_> :t on
20:05:11 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
20:05:22 <shachaf> jfischoff: Well, ddarius gave a proposed meaning for it in here recently.
20:05:26 <cmccann> @src on
20:05:26 <lambdabot> (*) `on` f = \x y -> f x * f y
20:05:38 <shachaf> But it's subtle enough that I wouldn't worry about it.
20:05:42 <jfischoff> it has an informal meaning if nothing else
20:06:45 <cmccann> a function is partially applied if it's applied to fewer arguments than it expects, and every function in Haskell has arity 1, so there :P
20:07:41 <shachaf> cmccann: A strict function is one that expects no arguments.
20:08:11 <cmccann> no, it just wins the argument every time :P
20:08:26 <shachaf> @quote wins.*argument
20:08:26 <lambdabot> Jafet says: unsafeCoerce takes any argument. AND IT WINS THAT ARGUMENT.
20:08:27 <cmccann> and sends you to bed without dinner
20:09:07 <Mortchek> shachaf, what does that mean? Don't all functions "expect" at least one argument?
20:09:18 <shachaf> Mortchek: It doesn't "mean" anything.
20:09:37 <shachaf> It's just a pun. :-(
20:09:41 <shachaf> > rot13 "shachaf"
20:09:42 <lambdabot>   Not in scope: `rot13'
20:09:46 <Mortchek> Oh. Okay. :P
20:09:49 <shachaf> @@ @let rot13 = @where rot13
20:09:50 <lambdabot>  Defined.
20:09:51 <shachaf> > rot13 "shachaf"
20:09:53 <lambdabot>   "funpuns"
20:09:58 <Mortchek> :0
20:10:02 <shachaf> @where rot13
20:10:02 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
20:10:45 <shachaf> Is it Golf o'clock?
20:12:00 <shachaf> @@ @run (@where rot13) "abc"
20:12:02 <lambdabot>   "nop"
20:14:41 <lpvb> is there a pointless command line tool so I can stop spamming lambdabot with pointless requests?
20:15:03 <cmccann> yes
20:15:22 <lpvb> may I get a link?
20:15:23 <cmccann> see http://hackage.haskell.org/package/pointfree
20:15:28 <cmccann> sorry, took me a moment to find it :P
20:15:35 <pqmodn> though people seem to complain it's broken and doesn't work as well as lambdabot's
20:15:37 <lpvb> thanks
20:15:45 <dubambaRumba> can anyone help me with acid-state.... im confused outa my mind... First of all, what should the type of the function be that does queries on acid-state??? Can I have it be something like: "IO ByteString"?
20:15:53 <cmccann> though I think http://hackage.haskell.org/package/djinn is more fun
20:16:24 <lpvb> what does djinn do?
20:16:55 <lpvb> converts a type into an expression, don't really understand what that means
20:17:08 <shachaf> @google what does djinn do haskell
20:17:09 <lambdabot> http://lambda-the-ultimate.org/node/1178
20:17:09 <lambdabot> Title: Djinn, a theorem prover in Haskell, for Haskell. | Lambda the Ultimate
20:17:11 <cmccann> @djinn a -> b -> a
20:17:12 <lambdabot> f a _ = a
20:17:20 <cmccann> @djinn (a -> b -> c) -> (a -> b) -> a -> c
20:17:21 <lambdabot> f a b c = a c (b c)
20:17:48 <cmccann> you give it a type, it gives you an expression with that type (if one exists, and it's a type djinn understands)
20:18:04 <cmccann> @djinn a -> b
20:18:05 <lambdabot> -- f cannot be realized.
20:18:11 <SLi> As far as I understand correctly, takes a type and generates a terminating (=non-bottom) program that is an inhabitant of that type, or tells you that one does not exist.
20:18:40 <cmccann> @djinn (a -> r -> r) -> r -> [a] -> r
20:18:41 <lambdabot> Error: Undefined type []
20:18:53 <cmccann> it's a bit limited though :P
20:18:57 <SLi> As for why that is an interesting thing to do, there is an interesting correspondence between types and proofs.
20:19:21 <shachaf> That's not the only reason.
20:20:25 <Mortchek> @djinn m a -> n -> n a
20:20:25 <lambdabot> Error: kind error: (KArrow (KVar 1) (KVar 4),KVar 2)
20:20:28 <Mortchek> Heh
20:20:48 <Mortchek> Oh, I know why that doesn't work >_>
20:21:01 <Jafet> > @djinn ((p -> q) -> p) -> p
20:21:03 <lambdabot>   <no location info>: parse error on input `@'
20:21:06 <Jafet> @djinn ((p -> q) -> p) -> p
20:21:07 <lambdabot> -- f cannot be realized.
20:21:33 <pqmodn> is that the type of a continuation?
20:21:51 <cmccann> @djinn ((p -> (q -> r) -> r) -> (p -> r) -> r) -> (p -> r) -> r
20:21:53 <lambdabot> f a b = a (\ c _ -> b c) b
20:22:02 <shachaf> @djinn (((Either (Not p) p -> Void) -> Either (Not p) p) -> Either (Not p) p) -> Either (Not p) p
20:22:02 <lambdabot> f a =
20:22:02 <lambdabot>     case a (\ b -> Left (\ c -> b (Right c))) of
20:22:03 <lambdabot>     Left d -> Left d
20:22:07 <lambdabot>     Right e -> Right e
20:22:30 <pqmodn> what is "Not"?
20:22:41 <pqmodn> p -> _|_?
20:22:45 <shachaf> p -> Void
20:22:52 <shachaf> Where Void is uninhabited.
20:22:55 <SLi> Or actually, types do not correspond to proofs; types correspond to propositions, and their inhabitants (= non-bottom values) correspond to proofs.
20:23:01 <pqmodn> ok, got it
20:23:13 <shachaf> SLi: I would say that all values correspond to proofs.
20:23:22 <shachaf> But if your language allows _|_ values, it's not a very good proof system.
20:23:51 <Jafet> let n = n + 1
20:23:52 <cmccann> @quote prove.exist.bottom
20:23:53 <lambdabot> No quotes match. I feel much better now.
20:23:56 <cmccann> @quote prove.exist
20:23:57 <lambdabot> No quotes match. That's something I cannot allow to happen.
20:23:59 <cmccann> argh
20:24:08 <shachaf> @quote prove.*exist
20:24:09 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
20:24:26 <cmccann> :D
20:24:27 <cmccann> thanks.
20:24:40 <shachaf> Remember the good ol' days when kmc was here?
20:24:40 * cmccann wishes kmc was still around :[
20:24:52 <shachaf> He's around, just not in #haskell
20:25:00 <shachaf> Because #haskell is terrible. :-(
20:25:06 <cmccann> :[
20:25:10 <Jafet> I'm terrible
20:25:23 <isomorphic> Hrm.  I have a package that insists on v 1.5.* of another package in cabal, but I think it will build with v 1.6 -  --constraint won't force an override in cabal - can anything?
20:25:48 <Clint> edit the .cabal file
20:26:18 <SLi> isomorphic, in such a case I'll generally just cabal unpack it, edit the .cabal and then build and install it. Hackage is a mess IMO :p
20:26:20 <isomorphic> Clint:  That's one approach.  Since I depend on this package, I'd ideally like the maintainer to do so
20:26:44 <monochrom> command line does not override *.cabal file
20:27:16 <SLi> The current way of versioning is Clearly Broken, though I'm not sure if there's a consensus on that (= if people agree with the obviously correct statement that it's broken) :)
20:27:19 <isomorphic> SLi:   It'd be great if hackage included an intersection matrix showing pairs of packages that had been successfully built together
20:28:25 <SLi> I don't think the rather strict version dependencies created by cabal init help very much.
20:28:29 <isomorphic> .. rather than trying to use version numbers
20:28:51 <isomorphic> yesod-platform always causes me problems - it insists on specific versions of everything
20:29:20 <SLi> Of course there can be incompatibility that does not show on the type level (i.e. packages build correctly but work wrong).
20:29:27 * Clint doesn't bother with yesod-platform
20:29:36 <YayMe> anyone here know parsec real well who could look at some small snips of code and give me suggestions? It was too hard to come up with these techniques so I presume they're wrong
20:29:39 <monochrom> we need version transfinite ordinals
20:30:52 <lpvb> I'm getting one of these errors on a pointless conversion
20:30:54 <lpvb>     No instance for (Monad ((->) a0))
20:30:56 <lpvb>       arising from a use of `ap
20:30:57 <isomorphic> SLi:  True, but computationally cheaper than running all the tests.  Once you figure out the path through the dependencies, I guess you just enable the unit tests in all your packages
20:30:58 <lpvb> what does that mean?
20:31:22 <YayMe> does emacs haskell-mode have an hpaste feature?
20:31:46 <zuserm> I found a GHC 7.6.1 bug. http://hpaste.org/75686
20:32:04 <SLi> I don't know of others, but it strikes me as a bit funny that we have a language with very strict and good type system to ensure correctness, but then cabal&hackage are fairly full of corner cases of "this doesn't work", "this may work if you edit this" and "reinstalls are dangerous, but in practice you may want to try anyway" etc. Of course I realize that automagical goodness for everything doesn't just follow from the language ...
20:32:05 <cmccann> monochrom, I still want version complex numbers, where the imaginary component indicates incomplete or buggy features.
20:32:10 <SLi> ... being magnificent, but anyway... :)
20:32:51 <Clint> lpvb: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Control-Monad-Instances.html
20:32:57 <cmccann> to be fair, cabal and hackage are really no worse than most things of comparable purpose
20:33:18 <lpvb> Clint: thanks
20:33:22 <SLi> And, really, dependency versioning is hard in general. I don't know of any good solution save for the soname style of doing things used in unix-land.
20:33:22 <Clint> differently worse
20:33:34 <hpaste> YayMe pasted “C# oneline comment parse” at http://hpaste.org/75687
20:33:43 <mapreduce> Why do we have to install stuff instead of just specifying dependencies and running away?
20:33:43 <zuserm> Oh god, I can't make out the capcha on the GHC trac at all. Maybe I've been secretly replaced with a robot.
20:33:57 <mm_freak> Polarina: "Depends: current instant" means:  the output of this instant depends on this instant
20:34:12 <mm_freak> Polarina: the implication is that you can't use feedback without a delay
20:34:43 <mm_freak> Polarina: in other words using 'loop' will cause bottom
20:34:52 <isomorphic> SLi:  I believe people settled on virtualization as a solution for that one.
20:35:21 <YayMe> I feel like my anyChar thingy there where I have to define the end of parsing in both my between and manyTill I must be doing something stupid and wrong'
20:35:49 <mm_freak> Polarina: for example for 'integral_' the output of this instant depends on the previous instant, so you can feed back its output as input:  rec x <- integral_ 0.01 -< x
20:36:03 <Ghoul> appending : to the dependency
20:36:10 <Ghoul> followed by a version would work fine
20:36:42 <Ghoul> But I know nothing, so don't worry.
20:36:42 <mm_freak> Polarina: because feedback is something that comes up a lot in FRP and because i was always annoyed by yampa not documenting its data dependencies i decided to document it in netwire
20:37:04 <isomorphic> Kind of funny when you look back, eg: Let's make shared libraries so that we don't have redundancy between applications -> Oh wait, I didn't want *that* dependency upgraded, my application is broken now -> Now I have eight copies of my whole operating system, and no problems with shared libraries!
20:37:37 <Ghoul> /s/OS/Arch Linux
20:37:50 * cmccann just fires up a separate VM for each application he uses, doesn't everyone?
20:37:51 <Ghoul> /lib is hell.
20:37:51 <dmwit> Ah, yes, but you only have eight copies, whereas you have significantly more than eight applications.
20:38:18 <geekosaur> then there's java...
20:38:27 <SLi> isomorphic, well, it needs a lot of coordination, but e.g. Debian does it quite well. Still ABI-breaking core library transitions are a PITA.
20:38:40 <SLi> Java, and Windows DLL hell.
20:39:06 <SLi> The Java way seems to be just shipping with jars of everything, and nobody even knows where the jars came from.
20:40:06 <geekosaur> I was thinking that too often each Java app comes with its own specific JRE version
20:40:11 <geekosaur> and config
20:40:19 <isomorphic> dmwit:  I guess my point is that shared libraries don't seem to save much.  Particularly now everybody seems to virtualize on a dedup layer anyway :/
20:40:48 <mm_freak> Polarina: more precisely:  "Depends: current instant" means:  the WHNF of this instant's output depends on the WHNF of this instant's input
20:41:06 <Ghoul> Well.
20:41:28 <Ghoul> I actually don't mind the python method
20:41:32 <Ghoul> Of never deprecating.
20:42:08 <isomorphic> cmccann:  The imaginary numbers thing - is there a package operation that goes with multiplication?
20:42:10 <SLi> isomorphic, I don't think very many people actually dedup (except backups). It's really very overhyped. In a typical use case, it won't save you much, and it will consume a huge amount of resources (ZFS) and just make your disk accesses a lot slower, because the next block in that file is not in the sequentially next place on the disk but you need to seek to find it.
20:42:43 <SLi> With virtualization it's used too, if you don't need good disk performance.
20:42:47 <ivanm> bos suggested the other day _not_ to use -auto-all and -caf-all when profiling because optimisations can be ignored
20:43:06 <SLi> And Linux has kernel samepage merging (= memory dedup for virtualization), which is good.
20:43:09 <isomorphic> SLi:  Have you seen the feature in the VMWare hypervisor?
20:43:15 <ivanm> so I removed all those options from the packages that I depended on, rebuilt them, and added an SCC pragma to the function I wanted profiled
20:43:28 <isomorphic> SLi:  Yup, similar.
20:43:28 <ivanm> the end result is that now it takes 0% of the runtime as opposed to 1.5% :s
20:43:35 <ivanm> which is _so_ useful to me
20:43:36 <ivanm> :/
20:54:58 <zuserm> Is there anyway to edit my bug ticket?
20:55:17 <zuserm> on the GHC trac
20:56:07 <zuserm> figured it out
20:57:04 <ivanm> hmmmm, profiling tells me where ~80% of my runtime and memory usage is from
20:57:08 <ivanm> but not the other 20%...
21:47:54 * hackagebot cakyrespa 0.0.10 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.10 (YoshikuniJujo)
21:55:04 <lispy> ivanm: needs more SCCs?
21:55:46 <ivanm> lispy: yeah, figured it out; having "foo <- {-# SCC "label" #-} bar . baz $ x" doesn't seem to work
21:55:51 <ivanm> had to define an extra function
21:57:25 <lispy> ivanm: hmm, interesting
21:58:11 <lispy> ivanm: You expected to see the cost of bar . baz?
21:58:22 <ivanm> of bar . baz $ x
21:58:26 <ivanm> I was hoping to compare timings between my program and one in C for the serialisation components to show that it wouldn't be that much faster in C (or at least provide bounds)
21:58:47 <ivanm> but it seems that in practice there's not enough info (as the serialisation is too small for a meaningful comparison)
21:59:08 <lispy> criterion is good at figuring out how much cheap things cost
21:59:13 <ivanm> and trying to use FFI to write one of my functions in C - as suggested by my supervisor - doesn't exactly fill me with delight :s
21:59:46 <ivanm> lispy: hmmmm, interesting way of doing it
22:02:54 * hackagebot gluturtle 0.0.18 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.18 (YoshikuniJujo)
22:09:21 <ivanm> if I re-write one of my functions in C and use FFI to access it, I need to somehow convert my graph data type into C
22:09:23 <ivanm> hooray :s
22:17:06 <lpvb> I can't import Prelude hiding ((:))
22:17:22 <lpvb> ?
22:17:27 <shachaf> You can't?
22:17:31 <lpvb> I tried
22:17:36 <lpvb> <interactive>:1:25: parse error on input `:'
22:17:38 <shachaf> I don't know whether you can or not, but at any rate (:) is special.
22:17:48 <shachaf> lpvb: Did you (( ))?
22:18:01 <lpvb> double parens? yea
22:18:12 <lpvb> import Prelude hiding ((:))
22:18:51 <rwbarton> can you hide constructors generally?
22:19:04 <rwbarton> they have that special import syntax
22:19:09 <shachaf> Works for me in ghci.
22:19:13 <shachaf> That's also true.
22:19:47 <rwbarton> I don't know how you name the list type in that syntax
22:19:51 <lpvb> strange, didn't work for ghci for me on 7.4.2
22:20:16 <shachaf> The whole list syntax is magic anyway.
22:20:17 <rwbarton> shachaf, what works for you exactly?
22:20:23 <shachaf> Why would you hide it? You won't be able to override it.
22:20:29 <shachaf> rwbarton: import Prelude hiding ((:))
22:20:45 <shachaf> Ah, but not in 7.4.
22:21:38 <rwbarton> import Prelude hiding (Just) does work correctly so I guess it's not related to the fact that (:) is a data constructor
22:21:53 <shachaf> That also doesn't fail in 7.6.
22:21:57 <dolio> It wouldn't be a parse error, certainly.
22:21:59 <shachaf> I suspect it's a bug.
22:22:07 <rwbarton> true
22:22:26 <shachaf> Er, never mind.
22:22:55 * hackagebot cakyrespa 0.0.11 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.11 (YoshikuniJujo)
22:27:54 <ivanm> is there a Storable instance for Map anywhere?
22:29:09 <lispy> ivanm: as a list?
22:29:26 <ivanm> as whatever :)
22:29:28 <lispy> ivanm: if you use asc list it should be fast, right?
22:29:58 <ivanm> my C-fu is minimal, but it looks like I'm having to resort to trying to convert one of my functions in C after all :s
22:30:37 <lispy> doesn't SBV have a code generator? maybe you could use that ;)
22:30:56 <lispy> ivanm: http://hackage.haskell.org/package/sbv
22:31:06 <lispy> " Automatically generate C programs from Haskell functions."
22:31:43 <lispy> -fvia-C also comes to mind
22:31:49 <ivanm> never heard of sbv before
22:32:08 <lispy> Levent's best kept secret
22:32:43 <ivanm> -fvia-C doesn't disprove that "ZOMG, using C would make this _sooooooo_ much faster!"
22:34:46 <lispy> it was a joke :)
22:35:07 <ivanm> heh
22:35:15 <ivanm> oh, I don't think sbv is applicable here
22:35:23 <ivanm> I'm not using an SMT solver
22:35:39 <lispy> You can use sbv as a code generator too
22:36:14 <lispy> at least that's what I was told. I haven't used it myself.
22:36:18 * lispy is off to bed
22:36:25 <ivanm> g'night then
22:46:37 <augur> ski!
22:50:17 <sayuke> Im working with a library with lots of type Nice = Ugly blah blah blah definitions, so that in ghci :t shows the type as Nice. Is there a way to see the underlying ugly type in ghci?
22:51:12 <shachaf> type family Id a; type instance Id a = a; :t undefined :: Id Nice
22:51:36 <shachaf> (There's probably a much nicer way. :-) )
22:51:48 <shachaf> Oh, wait, that doesn't do what you want at all.
22:52:23 <sayuke> no
22:52:47 <shachaf> I don't think ghci has a nice way of expanding all type synonyms
22:52:49 <sayuke> ive got a Nice expression id like to know the underlying type of
22:52:53 <sayuke> :(
22:52:56 * hackagebot cakyrespa 0.0.12 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.12 (YoshikuniJujo)
23:03:32 <ivanm> if I want to use -fllvm, does it need to be for the libraries as well or only for the final executable?
23:07:57 * hackagebot cakyrespa 0.0.13 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.13 (YoshikuniJujo)
23:09:35 <shachaf> ivanm: I would think that -fllvm affects how the .o files are generated, and .o files exist for libraries, so you'd need it for libraries.
23:09:46 <ivanm> *nod*
23:09:56 <shachaf> But it should be binary-compatible to use -fllvm for some code and not for other code?
23:10:03 <ivanm> I'd heard some people say that you don't need more recompilations, so I wasn't sure
23:10:16 <ivanm> it would help if my ghc actually had llvm support; I thought I had enabled that :s
23:11:56 <shachaf> ivanm: Also, there's a lot of cross-module inlining. :-)
23:12:46 <shachaf> (So "what the library was compiled with" might not be that simple.)
23:12:55 <ivanm> *nod*
23:20:18 <ivanm> if I built ghc with llvm support, it should mention that in ghc --info, right?
23:21:32 <shachaf> Mine has ,("LLVM llc command","llc"),("LLVM opt command","opt")
23:21:48 <ivanm> mine doesn't :s
23:22:07 <ivanm> I have "GhcWithLlvmCodeGen=YES" in mk/build.mk
23:22:12 <ivanm> so AFAIK it should be built
23:30:52 <ivanm> shachaf: which version of ghc are you using?
23:31:40 <lpvb> If I made instance Monad Burrito
23:31:46 <lpvb> what would be >>= ?
23:32:29 <Ralith> guacamole.
23:32:49 <lpvb> seriously, what would I model >>=?
23:33:03 <lpvb> model >>= as* ?
23:33:27 <shachaf> ivanm: 7.6.1
23:33:39 <ivanm> hmmm, I have 7.4.2
23:33:52 <shachaf> From where?
23:34:29 <ivanm> compiled and installed via package manager
23:34:48 <ivanm> (source-based distro)
23:35:38 <ivanm> lpvb: wouldn't that depend on how you defined Burrito?
23:36:48 <lpvb> ivanm: I'm thinking the burrito would contain various fillings like Beef, Chicken, Salsa, etc.
23:36:55 <lpvb> and the burrito would be a list of fillings
23:37:00 <lpvb> so Burrito is a list
23:37:11 <ivanm> well, remember you need kind * -> *
23:37:13 <lpvb> but non-deterministic burritos aren't cool
23:37:37 <lpvb> yea, Burrito a = Tortilla | Cons a (Burrito a)
23:37:54 <Ferdirand> it would be pestering the burrito man to put the contents of a burrito in another burrito, but without nesting the wraps
23:38:17 <Ferdirand> whatever that means
23:40:35 <ivanm> shachaf: when you compile something with -fllvm, should ldd report it linking to any LLVM libraries or something?
23:40:44 <ivanm> I'm trying to work out how to tell if LLVM was actually used...
23:41:51 <lpvb> Maybe Burrito should be a Set Monad?
23:42:59 * hackagebot gluturtle 0.0.19 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.19 (YoshikuniJujo)
23:43:08 * ivanm thinks the joke is getting a tad old...
23:45:07 <shachaf> ivanm: I doubt it.
23:45:15 <shachaf> ivanm: You can look at the generated assembly, if nothing else.
23:45:17 <shachaf> ghc -S
23:45:46 <ivanm> well, it generates a .ll file
23:45:51 <ivanm> so I presume it _is_ using llvm
23:52:59 * hackagebot Elm 0.4.0.3 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.4.0.3 (EvanCzaplicki)
23:53:01 * hackagebot elm-server 0.4.0.3 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.4.0.3 (EvanCzaplicki)
23:59:44 <simon> lpvb, if you're looking for inspiration on how to make instance Monad Burrito, just consider instance Monad Monad. :-P
