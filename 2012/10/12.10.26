00:01:18 <jfischoff> why would one want to set the INLINE phase number?
00:01:45 <shachaf> Because one wants inlining to happen in a certain order, presumably.
00:01:52 <shachaf> (Or in a certain order in relation to RULES.)
00:02:11 <jfischoff> can you think of a concrete example?
00:02:33 <mroman> Is ByteString's pack locale dependent?
00:02:46 <shachaf> mroman: ByteString's pack is :: [Word8] -> ByteString.
00:02:51 <mroman> I need to output raw bytes to stdout.
00:02:56 <shachaf> You might be thinking of ByteString.Char8.pack, which is the devil.
00:03:13 <mroman> which is not possible with regular Strings.
00:03:22 <shachaf> Ah, ByteStrings should be fine for that.
00:03:24 <mroman> (Because Haskell will crash with invalid character errors)
00:03:38 <shachaf> (If you use something like hPut.)
00:03:57 <rwbarton> you can possibly also do it with regular Strings if you use appropriate hSetEncoding etc. but you shouldn't
00:06:34 <mroman> hPut assumes ISO-8859-1
00:06:42 <shachaf> Huh?
00:06:53 <shachaf> Why would hPut do any encoding?
00:07:00 <shachaf> It should just put bytes.
00:07:09 <mroman> "As with hGet, the string representation in the file is assumed to be ISO-8859-1."
00:07:12 <mroman> says hackage.
00:07:26 <mroman> But I think ISO-8859-1 covers all 255 values.
00:07:44 <shachaf> mroman: Hmm, that looks like faulty documentation.
00:07:50 <rwbarton> link?
00:07:50 <shachaf> Maybe it belongs in .Char8.
00:07:57 <shachaf> http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/Data-ByteString.html#v:hPut
00:08:18 <shachaf> Oh, that's hGetContents.
00:08:29 <rwbarton> oh ok
00:08:36 <shachaf> Not that that really matters...
00:08:38 <rwbarton> no
00:08:44 <pordan30> where does emacs store the haskell syntax highlighting files? i'm seeing hits for haskell-mode all over my system, in standard emacs directories
00:09:01 <shachaf> pordan30: Sounds like a question for #emacs.
00:09:46 <mroman> I actually have to deal with utf8 strings and strings containing raw bytes.
00:10:12 <rwbarton> in the same file?
00:10:37 <shachaf> edwardk: Oh, this "zipper" thing is more clever than I thought.
00:10:48 <edwardk> =)
00:11:07 <mroman> rwbarton: In my program.
00:11:08 <edwardk> "thanks" i think ;)
00:12:44 <mroman> "All Chars will be truncated to 8 bits." <- that does not sound very good @Data.ByteString.Char8
00:13:07 <rwbarton> don't use .Char8 unless you Know What You Are Doing
00:13:27 <shachaf> mroman: As I said, "the devil".
00:13:28 <rwbarton> it doesn't sound like you need it
00:13:37 <shachaf> mroman: Data.ByteString.Char8 pretends that bytes = characters.
00:13:50 <shachaf> Since you seem to want to be dealing with bytes, just forget .Char8.
00:14:23 <mroman> I have something like data MyString = Regular String | Raw String
00:14:39 <mroman> and yes, Raw must contain a String :)
00:14:49 <shachaf> What's Raw?
00:14:55 <rwbarton> what is that supposed to mean
00:15:27 <mroman> It means that it contains a string with "has no encoding" in the sense that it's a string of bytes
00:15:29 <rwbarton> "either a unicode string, or a _______"
00:15:32 <mroman> * which
00:15:42 <rwbarton> that is what a ByteString is (who would have guessed!)
00:15:50 <mroman> Yes.
00:15:59 <rwbarton> so why not Regular String | Raw ByteString ?
00:16:42 <shachaf> That sum type is a bit suspect.
00:16:49 <ivanm> rwbarton: why not Regular Text | Raw ByteString ?
00:16:52 <shachaf> (But it's much better than conflating the two, at least.)
00:16:56 <mroman> Because internally everything runs on Strings
00:16:56 <rwbarton> even better! but first things first
00:17:06 <mroman> but I like to output some strings as raw bytes.
00:17:08 <shachaf> ivanm: Text can't represent certain things that String can represent!
00:17:22 <mroman> like
00:17:37 <rwbarton> like unicode characters that don't exist?
00:17:44 <mikeplus64> mroman: huh, "internally everything runs on Strings", i'm not sure what subset of everything you're talking about ...
00:17:46 <rwbarton> > '\1114112'
00:17:48 <lambdabot>   <no location info>:
00:17:48 <mroman> an array of strings, and just because I'm funny I want to print every second string as raw bytes ;)
00:17:48 <lambdabot>      lexical error in string/character literal at chara...
00:17:48 <ivanm> shachaf: oh? such as?
00:17:55 <mroman> rwbarton: yes, they contain invalid characters
00:17:59 <mroman> which is why it's such a problem.
00:18:07 <rwbarton> you are making no sense
00:18:19 <shachaf> rwbarton: No, like "\55296"
00:18:31 <shachaf> Well, I guess that's a "Yes".
00:18:32 <rwbarton> that's the d8xx range or whatever it is?
00:18:36 <shachaf> Right.
00:18:39 <shachaf> Since Text is UTF-16
00:18:43 <shachaf> rwbarton: Also, infinite strings. :-)
00:18:44 <rwbarton> > 0xd800
00:18:45 <lambdabot>   55296
00:18:49 <shachaf> I guess lazy text can hold those, though.
00:18:56 <mroman> rwbarton: I have a 'black box' which works on strings
00:19:10 <mroman> and it sometimes generates invalid characters in that string
00:19:16 <rwbarton> ok
00:19:18 <mroman> and when I print those bogus strings, my program crashes.
00:19:20 <rwbarton> this is the worst program ever
00:19:49 <mikeplus64> lol
00:20:23 <mroman> But I can predict when it creates those strings.
00:20:52 <mroman> But now I need to find a way to print those strings without crashing my program.
00:21:03 <rwbarton> sigh
00:21:12 <mroman> It's an ugly hack. Yes.
00:21:33 <mikeplus64> mroman: why does it crash at "bogus" characters?
00:22:10 <mroman> mikeplus64: I don't know.
00:22:19 <mroman> It just crashes when strings contain invalid characters.
00:22:21 <rwbarton> because they ARE NOT characters
00:22:40 <mroman> and instead of creating bogus data out of invalid characters it rather crashes ;)
00:24:53 <mroman> ok
00:25:08 <cadabra> I run `cabal install parsec` and get: "cannot satisfy -package-id mtl-2.1.1-..." When I run `cabal install mtl`, I get the same error for `transformers`. When I run `cabal install transformers`, I'm told it's already installed. What does this mean? :|
00:25:21 <mroman> These strings contain only Char8.
00:25:27 <shachaf> rwbarton: Welcome to the "gets seriously heated up about character sets" club!
00:25:31 <mroman> so using pack from ByteString.Char8 is actually safe.
00:25:33 <shachaf> (Not that you weren't in it already.)
00:25:51 <rwbarton> quite
00:26:27 <mroman> @type pack
00:26:28 <lambdabot> forall o n. (Newtype n o) => o -> n
00:27:22 <mroman> But still...
00:27:25 <rwbarton> why would you produce a String having character values 0-255 only to pack it into a ByteString with .Char8 and output it as raw bytes
00:27:29 <rwbarton> that's what makes no sennsssse
00:27:46 <mroman> rwbarton: I'm not the one producing the string
00:27:55 <mroman> I'm just the guy wanting to print it :)
00:28:03 <rwbarton> who is producing the string
00:28:14 <shachaf> rwbarton: Another use case for NMUckage!
00:28:37 <rwbarton> i was going to call it patchage, what do you think
00:28:54 <shachaf> Sounds good.
00:29:57 <mikeplus64> cadabra: no idea, but maybe ghc-pkg check might know
00:31:26 <mroman> rwbarton: It's a simple interpreter. And programs can do string manipulations so they are able to produce strings with invalid characters in them.
00:31:40 <mroman> so I don't have control about the contents of the string
00:31:54 <shachaf> edwardk: Is there some nice way to make zippers Showable?
00:31:59 <rwbarton> are they supposedly manipulating unicode strings?
00:32:07 <mroman> rwbarton: Yes.
00:32:09 <edwardk> shachaf: sadly no
00:32:10 <rwbarton> "These strings contain only Char8."
00:32:13 <rwbarton> sounds like a no
00:32:24 <mroman> They are supposed to work on unicode strings.
00:32:34 <mroman> but they can generate invalid unicode strings of course.
00:32:44 <mroman> which my frontend then can't print.
00:32:49 <rwbarton> are you talking about
00:32:49 <mroman> because they are invalid.
00:32:50 <rwbarton> oh i give up
00:33:19 <mroman> :(
00:34:45 <mroman> What would you do?
00:35:07 <mroman> You are given a string (which is supposed to contain valid utf-8 characters) but you can not guarantee that.
00:35:17 <rwbarton> stop right there
00:35:25 <rwbarton> a String does not contain utf-8 anything
00:35:27 <cadabra> mikeplus64: it shows three warnings about haddock-interfaces and haddock-html.
00:35:48 <rwbarton> it contains unicode characters
00:35:52 <ivanm> mroman: as in you have a series of raw bytes that are meant to be utf-8 encoded textual data?
00:36:13 <mroman> Actually they contain whatever your local locale is?
00:36:18 <rwbarton> no!
00:36:21 <mroman> or not?
00:36:29 <rwbarton> a String is a list of unicode characters by definition
00:36:37 <rwbarton> it makes no reference to encoding
00:36:40 <rwbarton> nor locale etc.
00:37:18 <mroman> But they are converted to my locale when I try to print them?
00:37:20 <shachaf> I,I globale
00:37:22 <ivanm> mroman: yes
00:37:25 <rwbarton> yes
00:37:36 <mroman> And if it can't convert them it crashes.
00:37:39 <rwbarton> so that your terminal knows how to display them
00:38:41 <ivanm> if you have raw bytes, use bytestring
00:39:04 <shachaf> Or [Word8]
00:39:09 <mroman> I don't have raw bytes. I have strings. But some of them may contain characters I can't print.
00:39:15 <shachaf> mroman: What does that mean?
00:39:28 <ivanm> that makes no sense
00:39:39 <mroman> How does that not make sense?
00:39:40 <ivanm> what locale are you using that it can't print some characters, even as empty boxes?
00:39:40 <rwbarton> perhaps he has a locale like C or some iso-8859-1 thing
00:39:52 <rwbarton> those can't represent most unicode characters at all
00:39:54 <ivanm> rwbarton: he said utf-8 earlier...
00:40:31 <shachaf> UTF-8 can represent every Unicode codepoint and many things that aren't Unicode codepoints!
00:40:56 <ivanm> the only other thing I can think of is that some characters are control characters
00:41:01 <ivanm> even then _something_ would be printed
00:41:08 <ivanm> even if it looks like a weird symbol
00:41:28 <rwbarton> well you can't putStrLn "\xd800"
00:41:50 <rwbarton> is that the issue?
00:42:05 <ivanm> what's \xd800 ?
00:42:25 <mroman> rwbarton: Yes.
00:43:33 <rwbarton> then either (1) fail hard because your "Unicode string" is garbage/cannot be printed (2) check for invalid characters before printing and fail more nicely (3) replace invalid characters with something else
00:44:05 <mroman> And if I want to print it no matter what?
00:44:17 <rwbarton> what is that supposed to mean
00:44:21 <mroman> I don't actually care if the terminal can't display it.
00:44:22 <rwbarton> you need to encode it
00:44:26 <rwbarton> there is no utf-8 encoding
00:44:29 <rwbarton> so, you have a problem
00:44:34 <shachaf> ?
00:44:37 <shachaf> UTF-8 can encode \xd800
00:44:47 <shachaf> UTF-16 can't.
00:44:48 <rwbarton> well, maybe
00:44:49 <rwbarton> "According to the UTF-8 definition (RFC 3629) the high and low surrogate halves used by UTF-16 (U+D800 through U+DFFF) are not legal Unicode values, and the UTF-8 encoding of them is an invalid byte sequence and thus should be treated as described above."
00:44:58 <mroman> I don't have control over the locale anyway.
00:44:58 <shachaf> Ah, well, OK.
00:45:04 <mroman> I could set it with hSetEncoding
00:45:12 <shachaf> mroman: Sounds to me like you're in trouble.
00:45:40 <shachaf> If you have some library you can't control generating "String"s that aren't really Strings, the first step would be to turn them into the correct type.
00:45:46 <mroman> Can't I convert String to raw bytes and then print raw bytes to stdout?
00:46:07 <rwbarton> huh
00:46:15 <rwbarton> Data.Text.IO.putStrLn $ pack "\xd800" worked
00:46:17 <ivanm> @hoogle Char -> Int
00:46:17 <lambdabot> Data.Char digitToInt :: Char -> Int
00:46:17 <lambdabot> Data.Char ord :: Char -> Int
00:46:18 <lambdabot> Graphics.UI.GLUT.Callbacks.Window Char :: Char -> Key
00:46:29 <rwbarton> mroman: do you mean "can't I write my own UTF-8 encoder"
00:46:33 <ivanm> ord; can never remember which is which between ord and chr
00:46:53 <shachaf> rwbarton: No it didn't.
00:46:57 <rwbarton> well
00:46:59 <shachaf> rwbarton: Well, depends on what you mean by "worked".
00:47:01 <rwbarton> it didn't raise an exception
00:47:06 <rwbarton> like ordinary putStrLn did
00:47:09 <shachaf> Data.Text will turn \xd800 into a replacement character.
00:47:28 <rwbarton> that may meet mroman's needs (if indeed such exist)
00:47:56 <shachaf> Hah.
00:47:58 <rwbarton> oh, because it is utf-8
00:48:01 <rwbarton> *16
00:48:05 <shachaf> Right.
00:48:07 <rwbarton> can't even type utf-16 :P
00:48:12 <rwbarton> who thought this was a good idea
00:48:20 * shachaf once ported Text to using UTF-21.333...
00:48:40 <shachaf> What was a good idea?
00:48:48 <rwbarton> using utf-16 for Text
00:48:52 <shachaf> jaspervdj once ported Text to UTF-8, and it turned out to be slower.
00:49:00 <ivanm> shachaf: here I was thinking that it was data UTF = UTF Int :p
00:49:02 <shachaf> Also a lot of external libraries like ICU prefer UTF-16
00:49:29 <Jafet> UTF-2i
00:49:37 <shachaf> rwbarton: UTF-16 means you can't even get constant-time indexing. :-(
00:49:58 <mroman> rwbarton: I guess so.
00:50:55 <mroman> One that produces bytes from unicode characters and if it contains an invalid character it puts the invalid character also into the bytes.
00:50:55 <rwbarton> you could also make it an error in your language to produce the character '\xd800' (and whatever the others in that range are)
00:51:03 <rwbarton> adsjfakjg
00:51:09 <rwbarton> what does "puts the invalid character also into the bytes" mean
00:51:59 <rwbarton> why isn't it an error to have the character '\xd800' in haskell anyways?
00:52:13 <rwbarton> succ '\1114111' is an error so why not succ '\xd7ff'
00:52:20 <mroman> rwbarton: Well, it would just append [d8,00] then
00:52:29 <rwbarton> ...
00:52:41 <shachaf> rwbarton: Arguably it is an error, I think.
00:52:53 <rwbarton> shachaf: I guess it would be pretty awkward for Enum
00:53:02 <rwbarton> though it could just skip over the whole range?
00:53:07 <shachaf> Probably.
00:53:18 <rwbarton> then fromEnum/toEnum would be weird
00:53:34 <mroman> hm yeah.
00:53:38 <mroman> That does not work that way :)
00:54:31 <mroman> So... I'm screwed :(
00:55:40 <mroman> Well. I guess then I'll choose (1): fail hard.
00:56:14 <rwbarton> there is still a question of why anyone would write a program to produce the "characters" U+D800 in the first place
00:56:24 <rwbarton> er, *"character"
00:56:51 <shachaf> rwbarton: Did you know the way to escape codepoints greated than U+FFFF in JSON is to use surrogate pairs? :-(
00:56:52 <mroman> well
00:57:10 <rwbarton> shachaf, ugh
00:57:20 <shachaf> This is inherited from JavaScript, of course.
00:57:30 <rwbarton> let's make our own unicode! surely that will solve all problems
00:58:07 <rwbarton> mroman: I mean if you are running into this issue in practice, then even if your interpreter is behaving correctly, there is still a question about the program you are interpreting
00:58:17 <circle> Which is better, Haskell or Lisp?
00:58:27 <circle> Or, alternatively, which applications are each better for?
00:58:37 <shachaf> Ask #lisp
00:58:39 <shachaf> Or see the FAQ
00:58:41 <shachaf> @where faq
00:58:41 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
00:58:46 <ivanm> we're not biased _at all_ ;)
00:58:59 <circle> shachaf: I should ask #lisp this question?
00:59:02 <arcatan> @faq Can Haskell beat lisp?
00:59:03 <lambdabot> The answer is: Yes! Haskell can do that.
00:59:05 <int-e> no, completely unbiased. Lisp has applications? *ducks*
00:59:06 <circle> shachaf: Why would I do that?
00:59:14 <shachaf> circle: Because I'm not in #lisp
01:00:00 <circle> shachaf: What?
01:01:23 <mroman> > map (chr) [81,22,100,201,227,0,87,159,74,100,64,32]
01:01:24 <lambdabot>   "Q\SYNd\201\227\NULW\159Jd@ "
01:01:42 <mroman> ^- I can't print that for example.
01:02:25 <rwbarton> I can
01:02:39 <rwbarton> *Test> putStrLn $ map Data.Char.chr [81,22,100,201,227,0,87,159,74,100,64,32]
01:02:39 <rwbarton> Qd√â√£WJd@
01:03:03 <rwbarton> though I imagine some of the characters output did not survive the copy/paste process
01:03:12 <ivanm> mroman: what's your $LANG ?
01:03:35 <mroman> I'm on a windows machine.
01:03:36 <rwbarton> or run 'locale'
01:03:37 <shurikas> > map chr [100,111,117,99,104,101,98,97,103]
01:03:38 <lambdabot>   "douchebag"
01:03:47 <shachaf> edwardk: If goto x is a Just, should goto1 x be the same as its fromJust?
01:03:51 <ivanm> shurikas: are you going to take that from lambdabot? :p
01:04:11 * shurikas thinking of a smart response to what just lambdabot called him
01:04:12 <int-e> @botsnack
01:04:13 <lambdabot> :)
01:04:36 <edwardk> iirc the 1 combinators were all total functions
01:04:42 <shurikas> I'll take it to private with him
01:04:51 <ivanm> _her_
01:04:54 <ivanm> @vixen a/s/l
01:04:55 <lambdabot> The presidency has many problems, but boredom is the least of them.
01:04:56 <shurikas> why her?
01:04:58 <ivanm> @vixen asl
01:04:58 <lambdabot> Government enterprise is the most inefficient and costly way of producing jobs.
01:05:00 <ivanm> bah
01:05:04 <shachaf> edwardk: Er, right. But in the case that it's a Just.
01:05:04 <ivanm> @where lambdabot
01:05:04 <int-e> lambdabot, be gentle :-)
01:05:05 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
01:05:09 <ivanm> shurikas: ^^
01:05:17 <ivanm> oh, that's right, @vixen is no more
01:05:20 <edwardk> goto n = rights n . leftmost
01:05:21 <shurikas> ohhh
01:05:22 <shurikas> :DD
01:05:26 <shurikas> hehe, didn't know that
01:05:27 <edwardk> goto1 = rights1 n . leftmost
01:05:39 <shurikas> she looks ill though :/
01:05:49 <hpaste> tShamanoid pasted ‚ÄúWhy Non-exhaustive?‚Äù at http://hpaste.org/76807
01:06:04 <edwardk> the former only succeeds if there are at least n elements the latter succeeds always and just stops at the last one
01:06:17 <shachaf> I'm getting a lot of ‚ä•s with goto1. Maybe I don't understand how it works.
01:06:20 <circle> What sort of problems is Haskell good for working with on?
01:06:26 <shurikas> no case of a single element
01:06:28 <shachaf> E.g. ("hello","there") % zipper % down _1 % fromWithin traverse % goto1 0 % view focus
01:06:34 <edwardk> if you can get a _|_ out of goto1 then i screwed it up
01:06:37 <shurikas> oh, wait.
01:06:38 <ivanm> tShamanoid: check the spelling in line 3
01:06:40 <shurikas> sorry, m ybad
01:06:44 <ivanm> capitalisation, rather
01:06:44 <mroman> I can print it with hSetEncoding stdout utf8
01:07:22 <rwbarton> mroman: what does it look like printed out?
01:07:58 <mroman> Q‚ñ¨d‚îú√´‚îú√∫ W‚î¨∆íJd@
01:08:07 <edwardk> shachaf: interesting. that looks like a bug to me ;)
01:08:14 <rwbarton> W‚î¨∆í, indeed
01:08:23 <ivanm> rwbarton: *groan*
01:09:00 <shachaf> edwardk: Looks like rights1 and related functions are crashing.
01:09:04 <edwardk> ok, so goto works, but goto1 fails. guessing rights1 is busted
01:09:22 <circle> What sort of problems is Haskell good for working with on?
01:09:23 <shachaf> edwardk: Oh, it's the 0
01:09:32 <shachaf> edwardk: rights1 n z | n <= 0 = lefts1 (-n) z
01:09:37 <edwardk> hahaha
01:09:41 <edwardk> woops
01:09:54 <edwardk> same with lefts1
01:10:12 <DrSyzygy> edwardk: ooops. :-)
01:10:37 <ivanm> circle: ones that have a computational solution ;)
01:10:51 <circle> ivanm: What about, for instance, AI?
01:10:53 <edwardk> one sec. patching and uploading
01:10:57 <circle> ivanm: Would it be better than Lisp or Python for that?
01:11:00 <ivanm> there's some work being done on that
01:11:25 <mroman> I'd have to check what happens when one does putStr $ map (chr) [0..255] with encoding utf8
01:11:25 <ivanm> but I have no idea how it compares to lisp or python, since I don't do any AI :)
01:11:28 <rwbarton> mroman: so it looks like your windows locale-equivalent is in fact not utf-8 but some mystery encoding
01:11:37 <edwardk> fixed
01:11:43 <arcatan> for writing metacircular evaluators, i recommend lisp
01:11:55 <shachaf> edwardk: Thanks!
01:12:04 <edwardk> 3.0.5 will be on hackage in a sec
01:13:34 <shachaf> edwardk: By the way, "rights" conflicts with Data.Either.
01:13:59 <edwardk> i can't win em all ;)
01:14:10 <mroman> rwbarton: Indeed.
01:14:12 <edwardk> there is also a left and a right in Control.Monad.Either iirc
01:14:18 <edwardk> or one of those
01:14:24 <mroman> map (chr) [0..255] uses replacement characters.
01:14:43 <rwbarton> one that cannot even represent the latin1 range of unicode
01:15:05 <mroman> and the output is more than 255 bytes
01:15:30 <rwbarton> those aren't "replacement characters" you pasted before, those are utf-8 sequences being decoded as something else
01:15:39 <rwbarton> i guess that awful old dos code page
01:15:46 <shachaf> CP437?
01:15:48 <mroman> rwbarton: Ah, right.
01:15:50 <rwbarton> based on the line drawing characters
01:15:52 <shachaf> I think you mean s/awful/wonderful/
01:16:24 <rwbarton> maybe you can tell your terminal to use utf-8
01:17:05 * hackagebot lens 3.0.5 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.0.5 (EdwardKmett)
01:17:51 <shachaf> ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
01:17:51 <shachaf> ‚îÇI ‚ô• CP437‚îÇ
01:17:51 <shachaf> ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
01:18:19 <rwbarton> ‚ò∫
01:18:27 <mm_freak> edwardk: is there any inherent difficulty in writing a MonadFix instance for Free/FreeT?  i noticed you haven't written either of them
01:18:46 <edwardk> i honestly don't recall if there was or wasn't ;)
01:18:56 <edwardk> try to write it and let me know if it works
01:19:09 <edwardk> if it doesn't make sense it typically goes wrong pretty fast
01:19:13 <ion> :‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê        ‚îå‚îÄ‚îÄ(
01:19:16 <ion>                   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ(
01:19:21 <ion> whoops, i borked it.
01:19:26 <edwardk> if it works, put in an issue on github.com/ekmett/free/issues to add it
01:20:29 <mroman> If someone abuses strings as bytes I *could* switch to latin1 when printing those.
01:20:42 <mroman> but that would be awful.
01:20:47 <int-e> ion: looked fine here
01:20:59 <rwbarton> "*** Exception: <stdout>: hPutChar: invalid argument (invalid character)" should really tell you what the invalid character was
01:21:16 <ion> int-e: My paste contained extraneous spaces. If your IRC client is wide enough it‚Äôll look as originally intended.
01:21:20 <lightquake> general design question: is the state of a game's RNG part of the state of its world?
01:21:41 <shachaf> rwbarton: It should just embed the codepoint directly into the string!
01:21:55 <lightquake> i want to say 'no' because it's useful to separate the ability to mutate the RNG (by pulling numbers from it) from the ability to mutate the world
01:21:55 <tShamanoid> ivanm: sorry for the late reply, fixed it. Thank you for your help.
01:22:01 <ivanm> np
01:26:44 <lightquake> also, earlier i was asking about whether monad transformers commute, and the answer was 'some do, some don't.' is there a way to 'determine' whether two transformers commute?
01:26:52 <lightquake> i'm phrasing this badly because it's 4:30 am
01:27:44 <ivanm> I would hazard a guess that you would have to check the actual transformers
01:28:42 <ivanm> but those without similar functions like ReaderT and StateT would commute, but two different State-like transformers wouldn't
01:29:23 <lightquake> makes sense
01:31:24 <lightquake> @unmtl StateT world (Writer log) a
01:31:24 <lambdabot> world -> (a, world, log)
01:31:44 <lightquake> @unmtl WriterT log (State rng)
01:31:44 <lambdabot> Plugin `unmtl' failed with: `WriterT log (State rng)' is not applied to enough arguments, giving `/\A. rng -> (A, log, rng)'
01:31:46 <lightquake> @unmtl WriterT log (State rng) a
01:31:46 <lambdabot> rng -> (a, log, rng)
01:31:58 <lightquake> so those are obviously equivalent
01:34:32 <ivanm> edwardk: you still around?
01:34:39 <edwardk> just passing out now
01:34:43 <edwardk> whats up?
01:34:52 <ivanm> does trifecta actually do pretty-printing?
01:35:05 <ivanm> you have it listed under pretty-printer on hackage, but I thought it was just a parser library :s
01:35:20 <edwardk> it generates syntax highlighting
01:35:31 <ivanm> right
01:35:32 <edwardk> probably doesn't belong under pretty printing though
01:35:35 <ivanm> so not what I want ;)
01:35:39 <edwardk> i'll fix it if i remember =)
01:35:45 <ivanm> heh
01:36:02 <edwardk> feel free to post an issue to github
01:36:34 <BenjiArts> Hi guys, shocking cool vid! http://www.youtube.com/watch?v=TPuJat9jMqY
01:36:55 <ivanm> that doesn't look suspicious _at all_
01:37:00 <ivanm> edwardk: if I can remember :p
01:37:09 <lightquake> @hoogle World -> [World -> m World] -> World
01:37:09 <lambdabot> Warning: Unknown type World
01:37:09 <lambdabot> Control.Parallel.Strategies using :: a -> Strategy a -> a
01:37:10 <lambdabot> Control.Seq using :: a -> Strategy a -> a
01:37:20 <lightquake> @hoogle a -> [a -> m a] -> a
01:37:21 <lambdabot> Control.Parallel.Strategies using :: a -> Strategy a -> a
01:37:21 <lambdabot> Control.Seq using :: a -> Strategy a -> a
01:37:21 <lambdabot> Control.Seq withStrategy :: Strategy a -> a -> a
01:37:26 <lightquake> er
01:37:29 <shachaf> Why is there no mapA in Control.Applicative?
01:37:30 <lightquake> @hoogle a -> [a -> m a] -> m a
01:37:30 <lambdabot> Control.Parallel.Strategies using :: a -> Strategy a -> a
01:37:31 <lambdabot> Control.Seq using :: a -> Strategy a -> a
01:37:31 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
01:37:33 <Jafet> @hoogle foldM
01:37:33 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
01:37:33 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
01:37:34 <lambdabot> Data.Foldable foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
01:38:26 <lightquake> what i want to do is fold the list up using (>=>)
01:39:34 <lightquake> @type foldr (>=>) return
01:39:36 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
01:40:00 <merijn> :t foldr1 (>=>)
01:40:01 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> b -> m b
01:40:17 <lightquake> i don't know for certain that my list is going to be nonempty though
01:40:40 <lightquake> > foldr (>=>) return [x, y] z
01:40:42 <lambdabot>   Couldn't match expected type `c -> m c'
01:40:42 <lambdabot>         against inferred type `Simp...
01:40:46 <lightquake> bah
01:41:01 <lightquake> i think foldr actually goes in the wrong direction
01:41:16 <ivanm> @hoogle a -> [a] -> [a]
01:41:17 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
01:41:17 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
01:41:17 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
01:41:32 <lightquake> in that i want func [m, n] z to be return z >>= m >>= n
01:41:35 <ski> > foldr (>=>) return (map (Just .) [f,g]) a
01:41:38 <lambdabot>   Just (g (f a))
01:42:03 <lightquake> ‚Ä¶ really?
01:42:11 <ivanm> > intersperse 3 []
01:42:12 <lambdabot>   []
01:42:45 <lightquake> shouldn't it go backwards? like, if you have [f,g] then that turns into f >=> g >=> return
01:43:20 <rwbarton> which is f >=> g
01:43:23 <lightquake> oh right
01:43:36 <rwbarton> then when you apply to something the input appears "on the left of f"
01:43:40 <lightquake> so i want foldr (>=>) return
01:43:53 <rwbarton> if you write it as return z >>= f >=> g
01:44:02 <rwbarton> (maybe needs more parens)
01:44:09 <ski> yes, and `(f >=> g >=> return) a  =  (g >=> return) =<< f a  =  return =<< g =<< f a  =  g =<< f a'
01:44:28 <ski> @type foldr (>=>) return
01:44:29 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
01:45:49 <ski> @type \fs a -> foldl (>>=) (return a)
01:45:50 <lambdabot> forall t (m :: * -> *) b. (Monad m) => t -> b -> [b -> m b] -> m b
01:45:57 <ski> er
01:46:05 <ski> @type \fs a -> foldl (>>=) (return a) fs
01:46:06 <lambdabot> forall (m :: * -> *) b. (Monad m) => [b -> m b] -> b -> m b
01:46:11 <ski> > foldl (>>=) (return a) (map (Just .) [f,g])
01:46:13 <lambdabot>   Just (g (f a))
01:46:27 <ski> so `foldl' could also be used, i think
01:47:11 <rwbarton> yep, since (>=>) is associative and return its unit
01:49:21 <ski> > foldr (>=>) return (replicate (10^6) (Just . succ)) 0
01:49:24 <lambdabot>   Just *Exception: stack overflow
01:49:25 <ski> > foldl (>>=) (return 0) (replicate (10^6) (Just . succ))
01:49:27 <lambdabot>   *Exception: stack overflow
01:49:32 <ski> interesting
01:52:54 <lightquake> > foldr' (>=>) return (replicate (10^6) (Just . succ)) 0
01:52:56 <lambdabot>   Not in scope: `foldr''
01:58:47 <ski> > foldr (>=>) return (replicate (10^6) (ContT . flip ($) . succ)) 0 `runContT` Just
01:58:51 <lambdabot>   Just *Exception: stack overflow
01:58:52 <ski> > foldl (>>=) (return 0) (replicate (10^6) (ContT . flip ($) . succ)) `runContT` Just
01:58:55 <lambdabot>   Just *Exception: stack overflow
02:01:29 <shachaf> I guess traverse = mapA
02:06:20 <ski> yes
02:13:31 <ivanm> I wanted to draw trees "nicely", and I thought it would be relatively quick to whip something together
02:13:57 <ivanm> now I'm getting bogged down in details: what about if one branch is much wider than the other? odd vs even number of sub-trees? etc.
02:14:18 * ivanm hopes byorgey's boxes library works as advertised
02:15:50 <ivanm> even when the AUD was worth more than the USD, we were paying about $50 extra for a Nexus 7 tablet
02:16:01 <ivanm> whoops, wrong channel for the last line
02:18:10 <yitz> ivanm: you were using diagrams?
02:18:20 <ivanm> nope
02:18:30 <ivanm> I wanted textual pretty-printing
02:18:34 <ivanm> didn't think of diagrams actually
02:18:34 <yitz> ah
02:18:43 <ivanm> might be feasible to output to both...
02:18:52 <yitz> sounds nice
02:19:22 <yitz> ivanm: also, let us know if you find a nice tree drawing app for the nexus 7
02:19:41 <ivanm> heh
02:19:49 <ivanm> don't have a tablet, let alone a nexus 7
02:20:04 <yitz> ivanm: just got one. pretty cheap, does the job.
02:20:16 <yitz> ivanm: (in usd, of course)
02:20:22 <ivanm> I realised I had no need for one
02:20:37 <ivanm> between ebook reader, android phone, two laptops (neither of which I use much) and a desktop
02:21:11 <yitz> ivanm: everyone used to think they had no need for one. until steve jobs held up an ipad, and everyone's pupils started twirling.
02:21:36 <yitz> oh you have an ebook reader. well...
02:21:36 <ivanm> mine didn't
02:21:56 <ivanm> and the battery life of my ebook reader trumps that of a tablets :)
02:22:40 <yitz> which one do you have?
02:22:46 <shachaf> Has GHC's "possible fix" message ever helped anyone ever?
02:22:51 <shachaf>     No instance for (Gettable Mutator) arising from a use of `repeated'
02:22:52 <shachaf>     Possible fix: add an instance declaration for (Gettable Mutator)
02:22:56 <ivanm> BeBook Neo
02:23:06 <shachaf> Presumably if you know what a type class is, you know that you can add an instance.
02:23:10 <ivanm> has a wacom tablet, wifi that I've only tried to use once or twice
02:23:15 <shachaf> But the message just confuses people who aren't sure what it means.
02:23:17 <yitz> shachaf: that message has never helped me.
02:23:28 <shachaf> As far as I can tell it's redundant.
02:23:32 <ivanm> shachaf: yeah, it usually means "you've used the wrong type!" ;-)
02:23:36 <MostAwesomeDude> shachaf: Usually I want to import an already-existing instance, not make a new one.
02:23:42 <ivanm> I think there might have been _once_ I forgot to write a type instance
02:23:52 <yitz> MostAwesomeDude: sometimes, but more often what ivanm said
02:24:04 <ivanm> oh, wait, it does when I want to use rnf in criterion, and I haven't written an NFData instance yet
02:24:37 <shachaf> Right.
02:26:08 <shachaf> Is haskeline supposed not to build under 7.6?
02:26:16 <shachaf> Doesn't ghci use it?
02:26:27 <shachaf> Oh, wait.
02:26:31 <shachaf> This thing depended on an old version.
02:33:36 <merijn> shachaf: It helps sometimes (the possible fix message)
02:34:26 <merijn> shachaf: For instance I frequently forget stuff MultiParamTypeClasses, FlexibleInstances, DataKinds and the reminder helps then
02:34:42 <merijn> (oh, and FlexibleContexts)
02:57:41 <t7> is their an X86 assembler DSL thing on hackage?
02:57:49 <t7> or even assembly printer
03:01:09 <t7> harpy looks good
03:08:09 <mm_freak> lightquake: depends on your abstraction (the RNG thing)
03:08:29 <mm_freak> the RNG is always part of the state of your world, but it may be implicit enough to become invisible
03:08:39 <mm_freak> for example FRP hides the RNG from you
03:10:08 <shachaf> merijn: Is there a way to phrase it such that it would help you but not confuse beginners with messages like "add instance Num (a -> b)"?
03:12:07 <shachaf> Hmm, "lens"-style lenses are pretty elegant.
03:12:24 <shachaf> I wonder whether there's a nicer way to explain them.
03:12:58 <ion> t7: llvm, too, kind of.
03:19:17 <nyc> mm_freak: A monadic Fisher-Yates shuffle tends to trip over mutable array monad issues beyond just RNG state.
03:19:42 * nyc ponders monadic Fisher-Yates shuffles.
03:19:50 <shachaf> So if Functor->Lens and Applicative->Traversal, what sort of thing would Monad be?
03:20:39 <nyc> Back up about 300 steps. How do these associations work, and what is Lens?
03:21:36 <shachaf> nyc: A lens is sort of like a "functional lvalue".
03:21:37 <mm_freak> nyc: you can do this inside of an FRP framework easily
03:22:06 <shachaf> nyc: You have read-only "getters", i.e. functions, everywhere. But if you want to set a deeply-nested value, it gets really awkward.
03:22:33 <shachaf> Something like "x.foo.bar.y += 5" is really annoying, in normal Haskell.
03:23:09 <shachaf> So a lens is behaves like a (getter,setter) pair, such that you can compose them.
03:23:31 <nyc> This being an abbreviation for record update syntax?
03:23:40 <shachaf> Well, it's a first-class data structure.
03:23:47 * ski . o O ( `whole -> (part,part -> whole)' )
03:24:04 <shachaf> Yes, that.
03:24:08 <shachaf> (Except polymorphic etc.)
03:24:18 <nyc> Not the lens, just the update pseudocode fragment.
03:24:35 <shachaf> Well, in Haskell that pseudocode fragment would look way uglier than, say, C.
03:24:55 <Saizan> "x.foo.bar.y += 5" was meant to be from an OOP-ish imperative language
03:25:05 <merijn> nyc: You'd have to do nested record syntax updates (ick...)
03:25:10 <Saizan> (or is it even valid C?)
03:25:12 <shachaf> x { foo = (foo x) { bar = (bar (foo x)) { y = y (bar (foo x)) + 5 }} }
03:25:14 <shachaf> Or something like that.
03:25:19 <shachaf> Disgusting.
03:25:24 <shachaf> Saizan: Looks like valid C to me.
03:25:36 <srhb> Are nested records really used that often?
03:25:41 <shachaf> Saizan: (It's also valid Haskell. :-) )
03:25:50 <shachaf> srhb: Well, lenses are useful for more than just records.
03:25:51 <merijn> srhb: I use them quite a bit with StateT/ReaderT
03:26:06 <srhb> shachaf: Yes, lenses are nice.
03:26:25 <shachaf> srhb: Oh, do you have an answer to my question? :-)
03:26:37 <shachaf> The answer is probably "some weird thing".
03:26:41 <shachaf> Because monads are weird.
03:27:12 <srhb> What question was that? Whether there was a better way to describe them?
03:27:25 <shachaf> srhb: The Monad thing.
03:27:40 <srhb> Ah.
03:27:45 <shachaf> nyc: For example, _1 :: SimpleLens (a,b) a, so you can use it like so: view _1 ("hello","there") = "hello"; set _1 "hi" ("hello","there") = ("hi","there")
03:27:50 <Eduard_Munteanu> Comonad -> Zipper?
03:27:54 <ski> (shachaf : by "polymorphic" i suppose you mean polymorphic in a functor ?)
03:28:09 <srhb> Hm, I have no idea.
03:28:27 <shachaf> But you can also compose it, so set (_1._1._1) ((("hello","there"),"to"),"you") "hi" = ((("hi","there"),"to"),"you")
03:28:45 <shachaf> srhb: I mean that set _1 :: (a -> b) -> (a,c) -> (b,c)
03:28:49 <shachaf> Er, ski:
03:29:02 <ski> nyc : the lens sortof represents the `.foo.bar.y' part of `x.foo.bar.y += 5', not the whole lvalue `x.foo.bar.y'
03:29:05 <shachaf> ski: Rather than set _a :: (a -> a) -> (a,c) -> (a,c)
03:29:08 <Eduard_Munteanu> By duality, I guess you get something like State for monads.
03:29:16 <ski> shachaf : oh right
03:29:35 <shachaf> ski: With the whole -> (part, part -> whole) representation, you can't do that.
03:29:50 <nyc> Sounds reasonable with respect to lenses.
03:29:59 <ski> nyc : iow, the lens haven't decided yet in *which* value it will access a sub-structure
03:30:02 <shachaf> ski: (But also there are a bunch of other nice properties of "lens"-style lenses.)
03:30:03 <srhb> shachaf: But you could say that functor -> traversal too, could you not
03:30:09 <nyc> Not that I really have the algebra down from the discussion.
03:30:10 <shachaf> srhb: ?
03:30:18 <shachaf> srhb: -> doesn't mean "superclass"
03:30:38 <shachaf> srhb: type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
03:30:46 <shachaf> srhb: type Traversal a b c d = forall f. Applicative f => (c -> f d) -> a -> f b
03:30:47 <srhb> Right.
03:30:55 <shachaf> Oh, I see what you mean.
03:31:08 <shachaf> Yes, it would unify, since an Applicative is a Functor.
03:31:11 <srhb> Indeed.
03:31:26 <srhb> Pretty sure ekmett commented on that as well
03:31:41 <ski> shachaf : i presume by "lens"-style you mean something different, but i've always thought of "lens"-style as `type Lens whole part = whole -> (part,part,whole)' as opposed to e.g. `type FRef whole part = (whole -> part,part -> whole -> whole)'
03:31:43 <Eduard_Munteanu> Ah, now I get it.
03:31:55 <shachaf> ski: Are you thinking of data-lens?
03:32:02 <ski> possibly
03:32:12 <shachaf> edwardk wrote a package called data-lens that had that sort of representation.
03:32:29 <shachaf> He's since replaced it with a much bigger package, "lens", that uses the type Lens a b c d I gave above.
03:33:31 <srhb> The lens package is pretty fantastic. Even though I struggle a bit with the "backwards application" - which is of course not what is happening. :P
03:33:37 <srhb> The types just look weird to me.
03:33:51 <shachaf> srhb: They make some more sense after a while. :-)
03:33:57 <srhb> I usually end up mashing operators in until ghci does not complain.
03:34:24 <shachaf> I like how Traversal is such a natural extension of Lens.
03:36:48 <ski> shachaf : yes, i've understood he's been able to do type-updates as well, though i haven't looked into how it works, yet
03:37:20 <ski> shachaf : are there any good relevant links you'd suggest ?
03:37:31 <ski> .. so that we could perhaps add then to
03:37:35 <ski> @where lenses
03:37:35 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/
03:37:35 <lambdabot> lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation>
03:37:37 <ski> e.g.
03:37:41 <shachaf> ski: Hmm. His talk in San Francisco last week was good. :-)
03:37:50 <shachaf> You should've come!
03:37:57 <fryguybob> I dove in and used `lens` and after a short bit found it very intuitive.
03:38:39 <srhb> shachaf: Is it online somewhere?
03:38:52 <shachaf> srhb: The slides are online but they won't do you too much good on their own.
03:38:57 <srhb> Ah well.
03:39:01 <shachaf> srhb: https://groups.google.com/d/msg/bahaskell/YifnIpEu2OY/kddoyuvdCOMJ
03:39:07 <srhb> Thanks.
03:40:10 * ski just sees some text complaining about Javascript
03:40:57 <shachaf> ski: https://docs.google.com/open?id=0ByK3AAy5ubqady1YczU2UEYzODQ ?
03:41:13 <shachaf> I'm not sure if that's any better...
03:41:46 <shachaf> I can put a copy of the PDF elsewhere if you can't get to it.
03:42:18 <ski> hm, i can see the name of it, but apparently no link :/
03:42:21 <shachaf> ski: Anyway, the polymorphic-update thing works in a similar way to the way (fmap.fmap.fmap) is polymorphic.
03:42:26 <shachaf> @ty fmap.fmap.fmap
03:42:28 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
03:42:58 <shachaf> Except with arbitrary lenses, instead of Functors.
03:43:05 <ion> @type (=<<).(=<<).(=<<)
03:43:07 <lambdabot> forall (m :: * -> *) b a. (Monad m) => (a -> m b) -> m (m (m a)) -> m b
03:43:18 <ski> @let swap :: Arrow ar => ar (a,b) (b,a); swap = arr snd &&& arr fst
03:43:19 <ion> boring
03:43:20 <lambdabot>  Defined.
03:43:31 <shachaf> @arr
03:43:32 <lambdabot> Yeh scurvy dog...
03:43:34 <shachaf> @ty swap
03:43:36 <lambdabot> forall (ar :: * -> * -> *) a b. (Arrow ar) => ar (a, b) (b, a)
03:43:45 <ski> @type \(f,g) -> [fmap f,swap . fmap g . swap]
03:43:47 <lambdabot> forall a b. (a -> a, b -> b) -> [(b, a) -> (b, a)]
03:44:30 <ski> @type \(f,g) -> fmap f . swap . fmap g . swap
03:44:31 <lambdabot> forall a b b1 a1 (ar :: * -> * -> *). (Arrow ar, Functor (ar (a1, a))) => (a -> b, a1 -> b1) -> ar (a1, a) (b1, b)
03:44:49 <ski> the functor `f' is polymorphic, but above it got instantiated to `(,) a'
03:45:12 <shachaf> Right.
03:45:23 * shachaf isn't sure of the relation here, though, if there is one.
03:45:31 <ski> in the first case the "before" and "after" type for each case was forced to be the same, since the other component didn't change it, but composing, we get type-changing
03:46:35 <ski> the relation was just that in your `fmap . fmap . fmap', it was polymorphic in `f',`f1',`f2'
03:47:13 <ski> (while allowing the type `a' to be changed to a type `b')
03:47:18 <shachaf> ski: The part I meant was that it was polymorphic in the "a"/"b", though.
03:47:25 <ski> and then, if we compose this "focusing" with one which focuses on another part, we can change the type of that component
03:49:18 <ski> shachaf : yes, but you need the "rest", i.e. `f' to also be polymorphic enough, so that we can compose with another update
03:49:34 <ski> and such that the two updates commute, if they're changing disjoint parts
03:50:45 <ski> .. i wonder whether there's any nice way of making updates on disjoint parts independent -- ideally this should automagically work, regardless of which way we compose
03:51:03 <shachaf> ski: In the case of lens you specify the types explicitly, e.g. Lens (a,c) (b,c) a b
03:51:59 <ski> by "independent" i mean that if we compose an update on the A part with an update on the B part, then the update on the A part shouldn't have to wait for the B part to return the spine down to where A and B part ways -- and vice versa
03:52:24 <shachaf> Oh.
03:55:26 <ski> hm, the abstractness of the locations could make this harder
03:58:02 <ski> shachaf : if you could put the slides up somewhere, it would be handy
03:58:07 <shachaf> Is there a library on Hackage that provides an evil monoid instance that disobeys all the laws?
03:58:30 <shachaf> Such that you can get a nice binary tree that shows how the compositions went.
03:59:30 <Rc43> HI, guys.
03:59:41 <shachaf> ski: OK, uploading.
03:59:42 <ski> you want basically `data NonFreeMonoid = MEmpty | Mappend NonFreeMonoid NonFreeMonoid | MConcat [NonFreeMonoid]' ?
03:59:47 <ski> hello Rc43
04:00:06 <shachaf> ski: Something like that, yes.
04:00:09 <ski> (s/app/App/)
04:00:23 <shachaf> I guess MConcat is part of it.
04:00:39 <ski> well, you might as well throw it in, since it's in the class
04:00:46 <shachaf> Right.
04:01:20 <Rc43> Anybody can say what more convinient way to install haskell packages on ubuntu? Should I use cabal only or it is normal to install ubuntu packages, too. And do ubuntu's apt-get know about cabal (I mean unregistering packages with ghc-pkg when they are deinstalled etc.).
04:02:22 <shachaf> I just use cabal.
04:03:32 <Rc43> shachaf, I now have some problems with ncurses; terminfo from hackage requires ncurses.h, but I think that I can get it only with ubuntu's ghc-ncurses-dev.
04:03:48 <shachaf> Why would ghc-ncurses-dev have ncurses.h?
04:03:59 <shachaf> .h is for C libraries.
04:04:02 <fmap> Rc43: I use cabal, do *not* install anything as --global and use cabal-dev for my projects
04:04:11 <fmap> seems to work well
04:04:29 <Rc43> shachaf, I don't know; just assume
04:04:32 <shachaf> Presumably you'd want something like libncurses-dev
04:04:36 <Rc43> fnap, hmm, I forgot about cabal-dev
04:04:44 <Rc43> fmap,
04:04:48 <shachaf> I don't know, man. This isn't #ubuntu.
04:04:57 * shachaf has never used cabal-dev.
04:05:02 <Rc43> shachaf, and #ubuntu isn't #haskell :)
04:05:50 <shachaf> Rc43: You should acquire the useful skill of "find out what package contains a particular file".
04:06:03 <shachaf> apt-file will do it, for example.
04:06:07 <shachaf> Google will often do it.
04:06:52 <Rc43> shachaf, never hear about apt-file, thanks; I used `apt-cache search | less` and then search for "ncurses.*dev" now
04:07:26 <quicksilver> shachaf: http://www.debian.org/distrib/packages#search_contents
04:07:32 <quicksilver> is how we used to do it before apt-file ;)
04:08:02 <quicksilver> well that page used to look a little different but anyhow : packaged.debian.org and click "search package contents" or similar
04:08:14 <shachaf> quicksilver: That goes under "Google". :-)
04:08:19 <Jafet> Just install everything
04:08:29 <Rc43> btw libncurses5-dev
04:09:07 <Rc43> explicit versions in package little alert me
04:09:50 <shachaf> ski: Maybe (traverse.traverse.traverse) would've been a better example. :-)
04:12:07 <b__> is it possible to write an instance Num for type Foo where I implement (*) to work on Foo and (for example) Integer? (as opposed to implementing it to work on two Foo's)
04:12:36 <shachaf> b__: Nope, not with Num's (*)
04:12:43 <ion> foo * fromInteger bar
04:13:14 <ski> @type let traverse = Data.Traversable.traverse in traverse . traverse . traverse
04:13:15 <lambdabot> forall (f :: * -> *) (t :: * -> *) (t1 :: * -> *) a b (t2 :: * -> *). (Data.Traversable.Traversable t, Applicative f, Data.Traversable.Traversable t1, Data.Traversable.Traversable t2) => (a -> f b) -
04:13:15 <lambdabot> > t (t1 (t2 a)) -> f (t (t1 (t2 b)))
04:13:35 <b__> shachaf, ok thanks =]
04:14:10 <ski> b__ : the type of `(*)' is `Num a => a -> a -> a' -- the two arguments must be of the *same* type `a' (and the result will also be of this type)
04:14:23 <b__> alright
04:14:53 <merijn> b__: Of course if you make a Num instance for Foo you will have a fromIntegral anyway, so you could coerce any Integral type to yours for use with (*)
04:15:05 <merijn> :t fromIntegral
04:15:06 <lambdabot> forall a b. (Integral a, Num b) => a -> b
04:15:13 <b__> yeah
04:15:30 <merijn> :t (fromIntegral 1 *)
04:15:32 <lambdabot> forall b. (Num b) => b -> b
04:15:34 <shachaf> ski: Note that "traverse" is an actual Traversal as in the package.
04:16:07 <merijn> b__: Actually, that's redundant because numeric literals already use "fromIntegral"
04:16:21 <ion> They use fromInteger
04:16:25 <b__> yes
04:16:28 <merijn> oh, my bad
04:16:28 <ion> (or fromRational)
04:16:31 <merijn> Anyway
04:16:45 <merijn> This would be valid: "let a = Foo in 1 * a"
04:16:53 <merijn> But this wouldn't be
04:17:14 <b__> I have no sensible way to implement (*) though (for a money type), whilst (+) is very useful
04:17:20 <merijn> "f :: Int -> Foo; f i = Foo * i"
04:17:40 <ion> I want (*) for my money.
04:17:41 <merijn> b__: Maybe that's a sign that money shouldn't be an instance of Num :)
04:17:44 <b__> so now I have $* for multiplication of the type
04:17:48 <b__> merijn yeah
04:18:12 <ion> $*? I see what you did there.
04:18:17 <b__> hehehe
04:18:20 <b__> accidental
04:18:39 <b__> but yeah it fits nicely with the subject
04:18:56 <b__> similarly I have $% etc
04:19:41 <merijn> b__: You could redefine the operators in your money module, and make people use them qualified
04:19:54 <merijn> Money.+, etc.
04:20:01 <merijn> Might not be very nice, though
04:20:12 <b__> yeah, it would be ugly, but it would make sense
04:20:35 <merijn> Wasn't there a package that let you specify units for numeric values and then typecheck those
04:20:35 <b__> $* $% is probably going to conflict with some existing libraries
04:21:11 <merijn> If not, I should write one ;)
04:21:21 <b__> I don't know, but I'd be interested if there was
04:21:35 <b__> main issue with money is precision
04:21:41 <b__> I use Rational now for representing it
04:21:46 <b__> Integer for constructing it
04:21:53 <b__> and a rounded Double for showing it
04:22:00 <b__> sort of convoluted
04:22:10 <merijn> b__: I'm pretty sure there should be a fixed precision type
04:22:18 <b__> merijn yes Data.Fixed
04:22:49 <b__> but "show $ 12.8544 :: Centi == 12.84"
04:22:53 <b__> or something like that
04:23:10 * ski . o O ( `geometricMean :: Money -> Money -> Money; geometricMean m0 m1 = sqrt (m0 * m1)' )
04:23:15 <bxc>   
04:23:26 <merijn> b__: newtype it and provide your own show instance?
04:23:30 <Jafet> Is that how accountants print numbers
04:23:45 <b__> merijn I kinda did  something like that
04:23:46 <shachaf> sqrt :: forall a. (Evil a) => a -> Money
04:24:00 <b__> *Finance.General> eur 12000
04:24:01 <b__> Ä 120,00
04:24:01 <b__> *Finance.General> 20 $% eur 12000
04:24:01 <b__> Ä 24,00
04:24:15 <b__> etc
04:24:31 <b__> I newtyped Rational
04:24:43 <merijn> Rational is not right for money, I think
04:24:50 <ion> instance Evil Shachaf
04:25:05 <merijn> Because money is rounded, just with a fixed precision, rather than the usual float approach
04:25:08 <nyc> Exact arithmetic perhaps.
04:25:19 <shachaf> ski: So NonFreeMonoid (without MConcat) is the type of Haskell 98 kinds.
04:25:36 <b__> merijn, if I take a percentage of it like 5 times, I don't want to lose any precision before I show it again as actual money
04:25:58 <b__> I want to retain all precision until I round it again
04:26:15 <ski> shachaf : the intent was that given a physical quantity described by `q * q', `sqrt' would given a physical quantity described by `q'
04:26:22 <b__> but tell me if I'm off here
04:26:49 <ski> shachaf : hm, how did you define `Ord NonFreeMonoid' ?
04:27:26 * ski supposes a partial order would be needed anyway
04:27:27 <shachaf> ski: I didn't.
04:27:43 <hpaste> ivanm pasted ‚ÄúSample tree pretty-printing‚Äù at http://hpaste.org/76810
04:27:44 <merijn> b__: You might not want a fixed precision of Centi (I agree), but you want fixed or arbitrary precision
04:27:54 <ivanm> ^^ what do people think of that tree drawing?
04:28:04 <merijn> b__: You could just Fixed with a nano resolution and round to cents at the final operation
04:28:05 <ivanm> any way it could be improved?
04:28:06 <ski> i think `MAppend' should be bimonotone, while `(->)' is not
04:29:33 <Rc43> Anybody knows where to look what does ExitFailure 9 mean?
04:29:55 <merijn> Rc43: Basically that the program exited with an exit code of 9
04:30:13 <merijn> What specifically 9 indicates is not well-defined
04:30:19 <b__> merijn, why would I want fixed precision over a rational representation?
04:30:35 <b__> I mean, until I "show" it
04:30:48 <merijn> b__: I guess it depends, I'm not well versed on common practice in the banking world
04:31:15 <b__> I think it's a matter of convention, and like you, I have no idea what the convention is
04:31:25 <merijn> Unrelated question, given a fraction x/y what's the names for the x and y parts of the fraction?
04:31:29 <Rc43> merijn, I mean encoding of return value 0
04:31:31 <Jafet> If you are writing financial software, you usually have no choice in the matter. Arithmetic and rounding are standardized.
04:31:35 <Rc43> merijn, *9
04:31:50 <ivanm> merijn: numerator and divisor ?
04:32:08 <osfameron> and denominator ?
04:32:12 <Jafet> (And different sectors undoubtedly use different standards.)
04:32:13 <merijn> ivanm: That sounds like what I wanted
04:32:15 <Rc43> Somehow `cabal install agda` fails with this ExitFailure 9.
04:32:20 <Jafet> :t (numerator, denominator)
04:32:21 <lambdabot> forall a a1. (Integral a, Integral a1) => (Ratio a -> a, Ratio a1 -> a1)
04:32:31 <fmap> Rc43: you should paste whole log
04:32:51 <merijn> ivanm, osfameron, Jafet: Thanks
04:33:04 <Rc43> fmap, will write it now
04:33:22 <Rc43> fmap, but I don'w see any errors on the screen
04:33:23 <fmap> Rc43: probably with -v 3
04:33:35 <Rc43> fmap, it is cabal's flag?
04:33:41 <fmap> Rc43: yep
04:34:09 <b__> Jafet, do you know where I could find information on such standards? (other than Google which I am about to use)
04:34:56 <fmap> Rc43: actually 3 might be too much, i'd say you should add verbosity until some meaningfull error is displayed
04:35:21 <fmap> (or you think it could be meaningful)
04:35:27 <Rc43> fmap, ok; am I right, that there is no space? (-v3)
04:35:31 <Jafet> I'm guessing you could find someone who writes this stuff, ask them, and hope the answer doesn't contain "NDA".
04:35:51 <ski> merijn : "dividend","divisor" is the alternate name pair
04:36:04 <fmap> Rc43: yeah, no space
04:36:35 <Jafet> And there is hledger, I don't know what kind of arithmetic it uses.
04:37:14 <b__> Jafet, the few financial packages out there for Haskell use Double and other dodgy types
04:37:20 <merijn> ski: I think numerator/denominator are more common, I just couldn't remember the numerator part :p
04:37:31 <merijn> b__: Really? Ick!
04:38:10 <Jafet> Floating-point isn't bad, it's just wrong in any officious capacity
04:38:39 <hpaste> ivanm annotated ‚ÄúSample tree pretty-printing‚Äù with ‚ÄúSample tree pretty-printing (annotation)‚Äù at http://hpaste.org/76810#a76811
04:38:47 <ivanm> ^^ is this better?
04:42:52 <shachaf> Cale: When are we getting lens in lambdabot?!
04:43:21 <ivanm> shachaf: I believe the answer was that lambdabot needed to build with 7.6 first
04:43:35 <shachaf> ivanm: No, lens will run on 7.4
04:43:46 <ivanm> well, then when lambdabot builds on 7.4 :p
04:44:02 <shachaf> lambdabot already does.
04:44:06 <ivanm> oh
04:44:08 <ivanm> *shrug*
04:44:23 <ivanm> yitz: were you actually interested in my tree-pretty-printing code?
04:47:45 <cyberoptiq> morning...new to Haskell and wondering is this language used primarily in a particular industry more than others?? I've never heard of it till now...
04:47:59 <ivanm> cyberoptiq: it tends to be used a lot in finance
04:48:12 <ivanm> but that's more because finance found it useful rather than being targetted
04:48:19 <merijn> cyberoptiq: Well, compiler people and finance tend to make use it
04:48:30 <ivanm> @google haskell in industry
04:48:32 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
04:48:32 <lambdabot> Title: Haskell in industry - HaskellWiki
04:48:37 <ivanm> not sure how up-to-date that is
04:48:51 <merijn> cyberoptiq: But we're slowly conquering the rest of the world too now that we have some nice web frameworks and a growing library ecosystem ;)
04:49:06 <cyberoptiq> thanks Merijn...what is Haskell's strength??
04:49:28 <ivanm> cyberoptiq: pure functional programming language with strong static typing
04:50:02 <cyberoptiq> what other language is it similar to?
04:50:26 <shachaf> Welsh.
04:50:28 <merijn> cyberoptiq: Writing correct code (i.e. easy to test and low bug-to-lines of code ratio) and writing complex programs
04:50:30 <ivanm> other functional languages with similar typing systems include OCaml, Scala, F#
04:50:37 <merijn> cyberoptiq: Also, simple concurrency
04:50:43 <ivanm> Erlang is also FP, but its typing isn't as strong
04:50:47 <ivanm> shachaf: heh
04:50:50 <cyberoptiq> I see...
04:50:58 <ivanm> shachaf: we don't use terms _that_ long, do we?
04:51:29 <merijn> cyberoptiq: It's also well known for rewiring your brain to give you √ºber programming powers
04:51:41 <Petit_Dejeuner_> Hi, I've been trying to make a small example function to practice some concepts, but there have been some type issues and I can't figure out what's going on.  Why does this http://hpaste.org/76820 give this http://hpaste.org/76821 ?
04:51:55 <merijn> cyberoptiq: It's one of the few languages I would recommend learning even if you never end up writing code in it
04:51:55 <cyberoptiq> in other words you learn to code correctly...as opposed to sloppy programming...
04:52:19 <merijn> cyberoptiq: Well, it tends to have that effect once you get past the learning curve, yes
04:52:21 <shachaf> Petit_Dejeuner_: To the first one, because Floating isn't a type.
04:52:37 <Petit_Dejeuner_> It's a typeclass, got it
04:52:40 <shachaf> Petit_Dejeuner_: To the second one, because x1 etc. are Ints.
04:52:48 <shachaf> You can't implicitly turn Ints to Floats like that.
04:53:02 <Petit_Dejeuner_> I have a cast.
04:53:03 <merijn> Petit_Dejeuner_: Sounds like you're looking for fromIntegral
04:53:09 <merijn> Petit_Dejeuner_: :: is not a cast
04:53:11 <shachaf> Petit_Dejeuner_: Haskell doesn't have casts.
04:53:14 <merijn> Petit_Dejeuner_: It is a type annotation
04:53:40 <cyberoptiq> thanks for the quick update on Haskell merijn...
04:53:41 <merijn> Petit_Dejeuner_: "x :: Y" tells the compiler "x should have type Y" if it doesn't, that's a compile error
04:53:52 <merijn> :t fromIntegral
04:53:53 <lambdabot> forall a b. (Integral a, Num b) => a -> b
04:53:58 <Petit_Dejeuner_> merijn, alright, that makes sense
04:54:05 <merijn> > fromIntegral 1 :: Double
04:54:06 <lambdabot>   1.0
04:54:42 <merijn> Petit_Dejeuner_: fromIntegral takes an Integral and returns any Numeric (including taking an Integral and returning Double, which is presumably what you want)
04:55:01 <shachaf> merijn: That sounds like terminology that'll just confuse someone who's already confuse.d
04:55:32 <Petit_Dejeuner_> So if I return a Num and say "is a" (::) Double it'll "cast" down to a double?
04:55:38 <shachaf> merijn: Confusing types with type classes is a sin.
04:55:46 <shachaf> And we can see the results already.
04:55:49 <merijn> shachaf: yeah, typo
04:55:54 <shachaf> Petit_Dejeuner_: There's no such thing as a "cast".
04:55:58 <shachaf> There's also no subtyping.
04:56:11 <merijn> Petit_Dejeuner_: No, but returning a Num is ambigous, i.e. returning "Num a" could return *any* Num
04:56:36 <Petit_Dejeuner_> With a :: I insure that the Num is a certain type?
04:57:05 <merijn> Petit_Dejeuner_: "x :: Y" tells the compiler "x should be type Y", if x has multiple valid types and Y is one of those types then "x :: Y" tells the compiler "I know you could pick many types, but you *should* pick Y"
04:57:31 <merijn> An example would be "minBound" which works for any bounded type
04:57:34 <merijn> > minBound
04:57:35 <lambdabot>   ()
04:57:35 <ivanm> @hoogle fix
04:57:36 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
04:57:36 <lambdabot> Data.Fixed module Data.Fixed
04:57:36 <lambdabot> Data.Function fix :: (a -> a) -> a
04:57:38 <merijn> oh, bah
04:57:41 <merijn> stupid defaulting
04:58:39 <Petit_Dejeuner_> Like the example in LYAH where they (read 3) ?
04:58:50 <shachaf> Petit_Dejeuner_: Yes.
04:59:03 <Petit_Dejeuner_> Okay, that makes sense, thanks
04:59:03 <shachaf> Er, assuming you mean (read "3")
04:59:09 <Petit_Dejeuner_> yes
04:59:16 <shachaf> Please be precise. :-)
04:59:17 <merijn> Petit_Dejeuner_: When you just write "minBound" then ghc doesn't know which minBound you meant. If you'd write "minBound : "c"" then GHC can infer that minBound has to return a Char (because of the type of "c")
05:00:09 <merijn> > minBound :: Char
05:00:11 <lambdabot>   '\NUL'
05:00:13 <merijn> > minBound :: Int
05:00:14 <lambdabot>   -9223372036854775808
05:00:48 <b__> how can I show a Float/Double in FFFixed format?
05:00:56 <merijn> But!
05:01:01 <merijn> > minBound :: Integer
05:01:02 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
05:01:02 <lambdabot>    arising from...
05:01:10 * shachaf suspects merijn is only confusing the poor newcomer.
05:01:33 <merijn> Petit_Dejeuner_: Integer is not a possible type for minBound, so annotating it results in an error
05:01:47 <merijn> shachaf: Maybe, hopefully not. Or at least not completely :p
05:02:21 <mcstar> :t minBound
05:02:23 <lambdabot> forall a. (Bounded a) => a
05:02:48 <mcstar> it is an error, since Integer is not Bounded
05:03:35 <merijn> mcstar: Yes, that is what I mean by Integer not being a valid type for minBound
05:06:17 <mcstar> "c" is not a Char also
05:06:27 <merijn> mcstar: That's not what I said
05:06:28 <mcstar> sorry for the nitpicking
05:06:48 <merijn> mcstar: If you're gonna nitpick you're gonna have to read more carefully
05:06:55 <merijn> > minBound : "c"
05:06:56 <lambdabot>   "\NULc"
05:07:09 <shachaf> merijn: Let's nitpick: minBound doesn't *return* a Char, it *is* a Char.
05:07:26 <merijn> I said minBound has to be a Char because of the type of "c", not because "c" is a Char
05:07:34 <merijn> shachaf: Yeah, I just noticed that :\
05:09:10 <mcstar> merijn: sry, you didnt say that
05:09:29 <shachaf> Don't nitpick *and* be wrong.
05:09:30 <merijn> I quote: "GHC can infer that minBound  has to return a Char (because of the type of "c""
05:09:32 <shachaf> Nobody likes a wrong nitpicker.
05:09:55 <mcstar> merijn: i mean, sry, you didnt say what i thought you said
05:10:03 <merijn> mcstar: :P
05:10:37 <mcstar> shachaf: every nitpicker has to start somewhere, dont they?
05:10:42 <shachaf> No.
05:13:11 <cyberoptiq> merijn one more question...are there places where Haskell training is provided?? or is this something learned but trial & error??
05:13:33 <cyberoptiq> *by trial & error I meant...
05:14:04 <merijn> cyberoptiq: Some universities have classes and there are books, but I'm not sure whether there is any "official" training...
05:14:06 <ivanm> cyberoptiq: there are various books available
05:14:07 <mcstar> universities, paid courses, books
05:14:24 <ivanm> isn't there also a video series on some MSDN site or something?
05:14:33 <ivanm> Can anyone think of anything I should change here? http://hub.darcs.net/ivanm/pretty-tree/browse/Data/Tree/PrettyPrint.hs
05:14:38 <cyberoptiq> gotcha...thx guys...
05:14:45 <merijn> @where lyah
05:14:45 <lambdabot> http://www.learnyouahaskell.com/
05:14:48 <merijn> @where rwh
05:14:48 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
05:20:35 <beaky> hello
05:20:37 <beaky> hello
05:21:35 <moops> hi
05:22:32 <beaky> http://ideone.com/alHIRN I've optimized that turing machine even further. Now even the original (1000-liner) C version  is twice as slow :D
05:22:36 <teneen> Is it possible to have a sum existential type?
05:23:31 <teneen> An existential type with several constructors?
05:23:39 <merijn> teneen: Sounds like you want GADTs
05:23:57 <shachaf> teneen: I think quantification and sum/product/etc. aren't really related.
05:25:03 <teneen> shachaf: I get a syntax error when I add one more constructor
05:25:15 <merijn> teneen: I might be wrong, as I have no idea what you're trying to accomplish. But if you've reached the point of using existentials you probably want to know about GADTs anyway, even if you end up not needing them right now for this problem
05:25:26 <Saizan> teneen: can you show the code?
05:25:33 <shachaf> You probalby shouldn't be using existentials. :-)
05:26:41 <merijn> shachaf: But all the cool people use existentials!
05:27:05 <Saizan> {-# LANGUAGE ExistentialQuantification #-}
05:27:06 <Saizan> data Foo = forall a. C1 a | forall a. C2 a
05:27:14 <Saizan> teneen: that loads fine ^^^
05:27:23 <teneen> Ok, I'm sorry guys it was a silly error :)
05:27:29 <Jafet> I use existentialist types
05:27:31 <teneen> silly mistake
05:27:49 <teneen> Saizan: Yes, Thanks!
05:28:13 <teneen> Saizan: I figured that I had a problem somewhere else in the code
05:28:23 <merijn> "data Foo where C1 :: a -> Foo; C2 :: a -> Foo"
05:28:31 <moops> are there any simple games written in haskell i could look at?
05:28:38 * merijn GADTs are like hammers
05:28:54 <merijn> moops: edwardk's lens library has an example implementing Pong, I think
05:29:02 <Jafet> There's cabal-install. I'm sorry.
05:29:19 <merijn> moops: https://github.com/ekmett/lens/tree/master/examples
05:29:30 <moops> perfect, thanks!
05:30:46 <merijn> moops: Also, this blog walks through a game example (using FRP): https://github.com/leonidas/codeblog/blob/master/2012/2012-01-17-declarative-game-logic-afrp.md
05:31:11 <merijn> moops: Although you probably want to read the previous article it links to first
05:37:10 * hackagebot tpdb 0.6.0 - Data Type for Rewriting Systems  http://hackage.haskell.org/package/tpdb-0.6.0 (JohannesWaldmann)
05:46:25 <ivanm> where's preflex?
05:46:31 <ivanm> @time byorgey
05:46:32 <lambdabot> Local time for byorgey is Fri Oct 26 08:46:11 2012
05:57:11 * hackagebot pretty-tree 0.1.0.0 - Pretty-print trees  http://hackage.haskell.org/package/pretty-tree-0.1.0.0 (IvanMiljenovic)
06:00:03 <beaky> http://ideone.com/7fk5DV I've implemented the turing machine in Java, and it's faster than the Haskell version we wrote :(
06:00:44 <mcstar> its the same as your other one
06:00:45 <ivanm> beaky: are you using the same data structures and algorithms?
06:00:45 <Jafet> @quote einstein
06:00:45 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
06:00:51 <mcstar> how does it compare to C?
06:01:21 <beaky> about as fast as the C one
06:01:26 <Darkcloud> can any tell me how to XOR a list of Bool's
06:01:38 <mcstar> then whats the problem? they say java can be pretty fast
06:01:41 <beaky> I think I will do it again in haskell, but using the same unboxed array type
06:01:46 <Jafet> @hoogle xor
06:01:46 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
06:01:46 <lambdabot> Graphics.Rendering.OpenGL.GL.PerFragment Xor :: LogicOp
06:01:46 <lambdabot> package xorshift
06:02:02 <shachaf> even . length . filter id
06:02:07 <ivanm> xor for bools is /=
06:02:17 <ivanm> not sure how you'd apply that to a list of them though
06:02:19 <shachaf> Hmm, maybe odd
06:02:19 <Jafet> beaky: then you're just writing it in C
06:02:22 <shachaf> odd . length . filter id
06:02:24 <int-e> ivanm: foldl'
06:02:28 <ivanm> int-e: sure
06:02:36 <int-e> @type foldl' (/=) False
06:02:37 <ivanm> I meant more I wasn't sure how Darkcloud wanted it applied to a list
06:02:38 <lambdabot> [Bool] -> Bool
06:02:43 <shachaf> @type odd . length . filter id
06:02:44 <lambdabot> [Bool] -> Bool
06:02:45 <ivanm> does he want a fold? or something more complex
06:02:54 <shachaf> @check \xs -> (odd . length . filter id) xs == foldl' (/=) False xs
06:02:56 <lambdabot>   "OK, passed 500 tests."
06:03:04 <Darkcloud> fold would be fine
06:03:30 <ivanm> now we just need lambdabot to have a @bench plugin tno compare the two... :p
06:03:41 <shachaf> odd . length . filter (\x -> if id x == True then True else False)
06:04:19 <shachaf> ivanm: The advantage of mine is that it suggests that maybe you shouldn't be having a list of Bools in the first place.
06:04:33 <ivanm> shachaf: yeah
06:05:34 <Darkcloud> lol
06:05:44 <Jafet> @check \x -> (odd . sum . map fromEnum) xs == foldl' (/=) False xs
06:05:46 <lambdabot>   Not in scope: `xs'Not in scope: `xs'
06:05:51 <Jafet> @check \xs -> (odd . sum . map fromEnum) xs == foldl' (/=) False xs
06:05:53 <lambdabot>   "OK, passed 500 tests."
06:06:08 <Darkcloud> Well, I'm not used to Haskell, and trying to wrap my head around its nuances is a bit difficult at times..lol
06:08:54 <Darkcloud> so Jafet would you mind explaining that line of code please?
06:10:12 <parcs`> lol, 'filter id'
06:10:23 <jrm2k6> Hi guys, I have a problem
06:11:09 <jrm2k6> I want to do a writeFile fileResult text, but i need to transform the right part of an Either object into a string
06:11:10 <strebe> jrm2k6: what is the problem?
06:11:10 <shachaf> "Some people, when they have a problem, announce the fact to an IRC channel without providing any more details. Now they have two problems."
06:11:13 <jrm2k6> how can i do that?
06:11:21 <jrm2k6> (soz i was typing)
06:11:39 <shachaf> jrm2k6: Sounds completely orthogonal to the writeFile thing.
06:12:05 <jrm2k6> ok so, lets try to reformulate
06:12:16 <mcstar> 3rd problem
06:12:43 <jrm2k6> what i have to achieve to get the left part of an Either type?
06:13:14 <parcs`> pattern match
06:13:15 <mcstar> > case Left 1 of Left x -> x
06:13:17 <lambdabot>   1
06:13:57 <mcstar> also, be aware, that it is slow
06:14:06 <mcstar> it took lambdabot 2 seconds to do that
06:14:13 <jrm2k6> hm
06:14:38 <mcstar> i can hear shachaf say to himself 'what an ass!'
06:15:04 <strebe> jrm2k6: another option, either (\x -> "") id yourvariable (see http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html ) - use 'show' instead of 'either' if the right part isn't a string
06:15:14 <shachaf> mcstar: ?
06:15:38 <jrm2k6> i will check your link thx
06:15:40 <mcstar> shachaf: i guess, you dont like my stupid jokes, thats what i meant
06:16:48 <strebe> sorry, 'show' instead of 'id'!
06:18:09 <strebe> >  either (\x -> "") show (Right 3.14)
06:18:10 <lambdabot>   "3.14"
06:18:38 <strebe> > either (\x -> "") show (Left "oops")
06:18:39 <lambdabot>   ""
06:19:23 <strebe> though stylistically, (\_ -> "") is better than (\x -> "") because the variable isn't actually used
06:19:49 <jrm2k6> hm
06:20:01 <mcstar> const ""
06:20:05 <jrm2k6> what i did was calling show (elem) which is a Right
06:20:22 <mcstar> :t const
06:20:25 <lambdabot> forall a b. a -> b -> a
06:20:25 <beaky> on a second benchmark, seems the C version is actually twice as fast as the Java version
06:20:27 <jrm2k6> but the thing is it shows (logically) Right [content right]
06:20:49 <nicoo> strebe: For such a simple lambda, it doesn't truly matter.
06:20:52 <jrm2k6> i should just overried the show of either to print only its content?
06:21:21 <strebe> jrm2k6: you could, but I wouldn't recommend it
06:22:21 <jrm2k6> so, what do you think is the best?
06:22:27 <strebe> jrm2k6: what you probably want to do is extract the value on the right, which as people have been saying, you can do by pattern matching (you can use guards or a case statement), or you can simply directly use either - see my lambdabot examples above
06:22:31 <quicksilver> well he couldn't, actually. The 'show' of Eitehr is defined in the same place as Either and can't be overridden.
06:22:46 <jrm2k6> oh ok
06:23:19 <strebe> quicksilver: presumably he could recompile ghc or something, though it would be a case of applying an icbm to swat a fly
06:24:10 <jrm2k6> oh btw i want to extract this content in a do block
06:24:41 <strebe> let content =  either (\x -> "") show whateeryourvariscalled
06:27:06 <jrm2k6> ok
06:27:26 <Darkcloud> Thanks for your help. what are some good resources for student trying to do more complicated haskell functions?
06:27:51 <Darkcloud> Not homework answers, but good references.
06:28:06 <moops> pick a project then try to do it ?
06:28:23 <t7> i think haskell has made me lazy (no pun intended)
06:28:37 <t7> when im wiriting JS i have so many type error and misspellings
06:28:49 <strebe> Darkcloud: http://www.haskell.org/haskellwiki/Learning_Haskell . I'm partial to http://book.realworldhaskell.org/ , and http://nostarch.com/lyah.htm seems quite popular
06:31:27 <Darkcloud> Thanks again guys.
06:31:32 <merijn> Darkcloud: Depends, how comfortable are you in haskell? Are you only just getting started?
06:31:59 <merijn> LYAH is a very good book, but start out very basic, by the end it covers a bunch of more complicated stuff, though
06:32:26 <Darkcloud> Its part of my programming languages class and i'm truly struggling
06:32:33 <merijn> (i.e. the monad and zipper chapters)
06:32:42 <merijn> Darkcloud: If you're struggling, maybe start with LYAH
06:32:50 <merijn> It's very comprehensive and starts very simple
06:32:53 <merijn> @where lyah
06:32:53 <lambdabot> http://www.learnyouahaskell.com/
06:33:03 <merijn> (And available for free)
06:33:42 <Cale> Darkcloud: also, feel free to ask lots of questions here
06:33:50 <merijn> That too, of course
06:34:10 <Darkcloud> @Cale I appreciate that
06:34:10 <lambdabot> Unknown command, try @list
06:34:20 <mcstar> the probability of receiving misinformation is pretty low
06:35:21 <quicksilver> well, at least the probability of misinformation being swiftly corrected by snarky regulars is high.
06:35:30 <quicksilver> values of snark may vary.
06:37:12 * hackagebot gluturtle 0.0.35 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.35 (YoshikuniJujo)
06:38:20 <merijn> Darkcloud: On IRC it's common to use : after the name instead of @, especially here as the @ will confuse lambdabot
06:42:12 * hackagebot cakyrespa 0.0.26 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.26 (YoshikuniJujo)
06:42:17 <Darkcloud> Oh ok, thanks. Well, I gotta get back to work. Take it easy
06:49:02 <ski> merijn : .. i wonder whether "dividend","divisor" are more associated with "partitioning division", while "numerator","denominator" are more associated with "quotative division"
06:49:24 <Jafet> Them's fighting words, there
06:52:32 <ski> at least i'm pretty sure that "quotient" and "quota" goes with quotative division (i.e. asking how many times a part fits in a whole : e.g. asking what the corresponding factor group is to a normal subgroup of some group -- we can think of the factor group as in some sense measuring "how many times" cosets shaped like the normal subgroup fits in the whole group)
06:54:23 <ski> (and therefore, it seems unfortunate that the factor group is often called a "quotient group" -- the quotient here really is the normal subgroup, according to this line of thought)
06:55:09 <mrg> hi
06:55:28 <Jafet> I have in fact never heard of them being called factor groups
06:56:18 <ski> i've seen it used, but "quotient group" seems the more commonly used phrase
06:59:16 <ski> hello mrg
07:01:39 <mrg> while working with monad transformers (like MaybeT) i wonder why you cannot use deriving show for a transformer. is it because you dont know if there is a Show instance for the variable moand?
07:02:12 * hackagebot lojbanParser 0.1.6 - lojban parser  http://hackage.haskell.org/package/lojbanParser-0.1.6 (YoshikuniJujo)
07:07:20 <ski> mrg : we'd probably like to say `instance (Show a,Show m) => Show (FooT m a)' -- but `Show m' is nonsense, `Show' wants a concrete type (a type of kind `*') as argument, but `m :: * -> *'
07:08:18 <ski> the ideal solution might be if we could say `instance (Show a,forall b. Show b => Show (m b)) => Show (FooT m a)'
07:08:40 <ski> i.e. we assume that for any `b' in `Show', `m b' will also be in `Show'
07:09:14 <ski> however, in current Haskell, this is not a well-formed constraint : we can't have higher-rank constraints
07:09:32 <mrg> ive never seen "forall" before, does it require some kind of ghc-extension?
07:09:40 <ski> yes
07:10:09 <typoclass> it's ExistentialQuantification, isn't it
07:10:41 <ski> it is used in some other situations. polymorphic components/fields of data constructors. "existential" data constructors, higher-rank types (being able to take a polymorphic operation as *argument*)
07:11:06 <parcs`> can cabal dynamically build executables that use template haskell?
07:11:13 <ion> Hmm. I take it instance (Show (m a)) => Show (FooT m a) won‚Äôt work?
07:11:26 <ski> `ExplicitForAll' enables the `forall' syntax
07:11:46 <typoclass> parcs`: i think it does handle TH ... how do you mean 'dynamically'?
07:12:10 <ski> for the specific extensions there, `PolymorphicComponents',`ExistentialQuantification',`Rank2Types',`RankNTypes'
07:13:13 <ski> ion : it will work for those `m's where `m a' is in `Show', regardless of whether `a' is or not -- so `m' being `Const k' with `k' in `Show', with `data Const k a = MkConst k' would work
07:13:35 <parcs`> typoclass: er, i meant "build dynamic executables" as in instructing ghc to dynamically link them
07:14:33 <merijn> ski: So do Rank2 and RankNTypes, no?
07:14:39 <merijn> oh, bah
07:14:40 <merijn> Too late
07:14:52 <ski> in the specific case of `MaybeT' we have `newtype MaybeT m a = MaybeT (m (Maybe a))', so in this case `b' in `m b' only needs to be able to be `Maybe a', so `instance (Show a,Show a => Show (m (Maybe a))) => Show (MaybeT m a)' would suffice in this case
07:15:01 <ion> ski: Ah
07:15:12 <ski> and we can simplify that to `instance (Show a,Show (m (Maybe a))) => Show (MaybeT m a)'
07:15:27 <typoclass> parcs`: i think you can always do "with-ghc-option=-dynamic" or whatever the exact syntax is
07:16:16 <ski> ion : and in several cases, you can do this (getting different constraints in each case, depending on the *innards* of the transformer) -- but i don't think it can work in general
07:17:09 <ski> still, it would be nice if GHC managed to derive (useful) instances in the case it is possible (and currently expressible)
07:18:32 <mrg> ok... if just tried "instance (Show a,Show (m (Maybe a))) => Show (MaybeT m a)" and ghc says i need -XFlexibleContexts
07:18:46 <ski> yes, but that's a very benign extension
07:18:48 <ski> add
07:19:04 <mrg> so no drawback of this solution
07:19:04 <ski>   {-# LANGUAGE FlexibleContexts #-}
07:19:11 <ski> to the start of your file
07:19:17 <parcs`> typoclass: well cabal already has support for building dynamic executables it's just that there's an edge case when the executable uses TH: you have to build the executable twice, first statically and then dynamically
07:19:37 <parcs`> it doesn't seem that cabal understands this however
07:19:52 <typoclass> parcs`: ooh, now i see what you mean. sorry, i don't have a clue about that
07:19:54 <ski> `FlexibleContexts' and `FlexibleInstances' are probably the two least "controversial/advanced" extensions
07:20:46 <ski> mrg : of course (unless you use `StandaloneDeriving') you'd also need to *implement* `showsPrec' in this instance
07:21:21 <dmwit> naively, that looks like it might ask for UndecidableInstances next
07:21:36 <mrg> if i dont need a specific representation i could just unwrap the transformer like runMaybeT $ MaybeT $ Left $ Just "Hello", am i right?
07:21:36 <ski> mrg : see <http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving> for how to use `StandaloneDeriving'
07:22:11 <ski> mrg : are you talking about implementing `showsPrec' here, or something else ?
07:23:15 <mrg> i was just looking for some representation in ghci
07:23:29 <ski> @type (Control.Monad.Trans.Maybe.MaybeT . Left . Just) "Hello"
07:23:31 <lambdabot> forall a. Control.Monad.Trans.Maybe.MaybeT (Either (Maybe [Char])) a
07:23:52 <merijn> mrg: The Haskell standard is *very* conservative in the type of constraints and instances it allows
07:24:23 <merijn> mrg: FlexibleContexts/FlexibleInstances basically tell GHC to be less uptight and accept many sensible constraints and instances that are not allowed by the standard
07:26:07 <ski> iiuc, they just took the safe for the unsafe and erred on the conservative side, to not mandate any specific extension of those until implementation had been given more time to experiment with extensions, so one could see what worked
07:26:33 <ski> s/ had been/s had been/
07:27:13 * hackagebot Checked 0.0.0.1 - Inbuilt checking for ultra reliable computing  http://hackage.haskell.org/package/Checked-0.0.0.1 (RobertOnslow)
07:28:25 <merijn> ski: Sure,I didn't say they didn't have a reason :p
07:28:51 <merijn> I was just clarifying that there's no practical reason to avoid those extensions
07:29:34 <mrg> thank you... if i'll need the instance i will use flexible contexts... for now i think unwraping with runMaybeT will lead to a sufficient representation of the contained value
07:30:02 <drbean> When you run out of variables, x,y,z what do people generally choose next for the 4th, w?
07:31:05 <typoclass> drbean: depends on what you're doing, but you might want to start with some more descriptive names
07:31:11 <merijn> drbean: Depends, people often grab primes, so x', y', z', x'', etc.
07:31:33 <merijn> drbean: You shouldn't need that many abstract names very often, though
07:31:52 <parcs`> > succ 'z'
07:31:53 <lambdabot>   '{'
07:32:49 <beaky> how does the Maybe type work?
07:32:58 <dmwit> ?src Maybe
07:32:58 <lambdabot> data Maybe a = Nothing | Just a
07:33:07 <ski> mrg : fwiw, i think a correct implementation would be `showsPrec p (MaybeT mMa) = showParen (p > 10) $ showString "MaybeT " . showsPrec 11 mMa'
07:33:13 <typoclass> drbean: i mean, if a function only works with 2 variables in total, it's easy for the reader anyway, and you don't need longer names. if you have 20 variables and they all have 1-letter names, i bet the reader will get confused
07:33:15 <Cale> Every value of type Maybe t is either the value Nothing or it is of the form Just x where x has type t
07:33:56 <nooodl> i think lookup is a good introduction to Maybe
07:34:15 <beaky> so Maybe is the null object patern?
07:34:19 <nooodl> yes
07:34:31 <typoclass> beaky: i think of Maybe as a list that can contain 0 elements or 1 element. it's used in haskell where you'd use a null pointer in other languages, to indicate "doesn't exist" and such
07:34:41 <osoleve> i'm looking to create bindings for a python library, because my searches for it haved turned up no results but enough desire for it that i'd feel guilty not giving back. i have no idea how to go about this, though; could someone point me in the direction of a good resource on the subject? :]
07:34:45 <ski> > lookup "hi" [("hello",5),("hi",2)]
07:34:46 <lambdabot>   Just 2
07:34:49 <ski> > lookup "lo" [("hello",5),("hi",2)]
07:34:50 <lambdabot>   Nothing
07:35:10 <astor> how do I export MyClass(.., hiding bar) - i.e. everything inn MyClass except bar?
07:35:24 <beaky> http://james-iry.blogspot.com.br/2009/05/brief-incomplete-and-mostly-wrong.html
07:35:55 <dmwit> osoleve: Go via C; look for documentation on exporting the Python library as a C API, then read about the Haskell FFI for accessing C libraries.
07:35:58 <dmwit> ?where ffi
07:35:58 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
07:36:19 <dmwit> astor: List the other methods explicitly.
07:36:41 <ski> beaky : yes .. except that `Maybe' is better, since it avoid domain contagion -- you can have `Maybe (Maybe String)', with values being either `Nothing' or `Just Nothing' or `Just (Just s)' where `s' is a string -- this isn't poeeible in e.g. Java with `null' and a value of type `String'
07:36:52 <beaky> ah
07:36:56 <osoleve> dmwit: great, thanks!
07:37:00 <beaky> so it's more recursive
07:37:04 <astor> dmwit: thanks, but so sad.
07:37:13 * hackagebot CarneadesDSL 0.9 - An implementation and DSL for the Carneades argumentation model.  http://hackage.haskell.org/package/CarneadesDSL-0.9 (BasVanGijzel)
07:37:27 <ski> beaky : note that `lookup' distinguishes the case when there was no matching association from the case where the matching association contained `Nothing'
07:37:43 <hirsch_> I get a 'Bad value on output port 'tcp_inet'' when sending an image reply with cowboy like that cowboy_req:reply(200, [{'Content-Type', <<"image/png">>}], Image, Req)
07:37:53 <ski> > lookup "hi" [("hello",Nothing),("hi",Just "lo")]
07:37:54 <lambdabot>   Just (Just "lo")
07:37:57 <beaky> right
07:37:59 <ski> > lookup "hello" [("hello",Nothing),("hi",Just "lo")]
07:38:00 <lambdabot>   Just Nothing
07:38:02 <ski> > lookup "lo" [("hello",Nothing),("hi",Just "lo")]
07:38:03 <lambdabot>   Nothing
07:38:21 <nooodl> ski: that's a wonderful example
07:38:36 <ski> beaky : and it can be important to be able to distinguish "user `null'" from "operation failure `null's"
07:39:17 * dmwit notes that class MaybeString { public String just; } (or whatever the Java syntax is) has two distinguishable nulls.
07:39:21 <typoclass> i think java sidesteps this by disallowing most data structures to contain a null
07:39:38 <dmwit> typoclass: ...what?
07:39:45 <merijn> typoclass: Only by programmer consensus
07:40:03 <ski> for the term "domain contagion", see the 2006-02-03 entry "Option types, optional parameters" at Riastradh's blag <http://mumble.net/~campbell/blag.txt> (RSS <http://www.ccil.org/~cowan/blag.xml>)
07:40:23 <dmwit> Only primitive types can't be null in Java, and there's only like... three of those.
07:40:26 <typoclass> dmwit: it's been years since i last touched java, but i *think* it's not possible to store the value 'null' in a regular Map ...
07:40:37 <dmwit> typoclass: No, that's not true.
07:40:58 <dmwit> There's a separate method "hasKey" specifically so you can tell whether the null you got back was because the key was missing or because the key was there and the value was null.
07:41:09 <quicksilver> also java programmers don't use the container libraries because they don't understand them
07:41:15 <osfameron> really?
07:41:17 <beaky> > (+1) <$> Just 3
07:41:18 <lambdabot>   Just 4
07:41:22 <quicksilver> so java programmers are always based around adhoc hand-rolled data types
07:41:23 <beaky> > (+1) <$> Nothing
07:41:24 <lambdabot>   Nothing
07:41:27 <beaky> aha
07:41:28 <quicksilver> programs, that is.
07:41:39 <ski> (`void',`boolean',`char',`short',`int',`long',`float',`double' -- any more ?)
07:42:01 * osfameron glowers at ski's mismatched quotes
07:42:11 * ski can't recall if there's any unsigned variants
07:42:20 <merijn> osfameron: That's LaTeX quoting
07:42:23 * ski beams with pride
07:42:50 <nooodl> latex quoting hurts my eyes
07:43:03 <beaky> ``foo''
07:43:12 <quicksilver> that's why you should always read ski's utterances through xdvi
07:43:13 <beaky> TeX output is beautiful though
07:43:14 <quicksilver> not directly
07:43:30 * ski nods gravely
07:43:56 <hpaste> astor pasted ‚ÄúSyntax error‚Äù at http://hpaste.org/76826
07:43:59 <dmwit> Good mathematicians have a LaTeX filter between their eyes and their brain anyway.
07:44:01 <astor> can someone help me with the syntax for type families + constraints + constraintkinds?
07:44:35 <osfameron> xdvi usually gives me horrible error messages and a confusing debugger
07:44:57 <typoclass> dmwit: right, i looked it up, i misremembered it. the Map interface says implementations may choose to disallow null keys or even null values, but e.g. HashMap allows both
07:45:27 <Eduard_Munteanu> Hrm, new look for hpaste.
07:45:58 <ski> astor : .. interesting observation
07:46:26 <hpaste> foo pasted ‚Äúfoo‚Äù at http://hpaste.org/76827
07:46:27 <laurynne> hello everyone, I'm having trouble getting wxHaskell installed and need a little help
07:46:57 <nooodl> "import GHC.Prim"?
07:47:13 * hackagebot buildwrapper 0.6.2 - A library and an executable that provide an easy API for a Haskell IDE  http://hackage.haskell.org/package/buildwrapper-0.6.2 (JeanPhilippeMoresmau)
07:47:15 * hackagebot scion-browser 0.2.11 - Command-line interface for browsing and searching packages documentation  http://hackage.haskell.org/package/scion-browser-0.2.11 (JeanPhilippeMoresmau)
07:47:38 <astor> nooodl: There's this weirdo where 'Constraints' is not visible unless imported from GHC.Prim.
07:47:40 <ski> nooodl : i suppose for `Constraint'
07:47:52 <nooodl> huh
07:47:53 <astor> Constraint, I mean
07:48:26 <laurynne> First I tried to install wxHaskell via the package manager (Linux Mint Debian) and then tried to compile a sample wxHelloWorld file with ghc -package wx
07:48:49 <laurynne> Which results in the error: <command line>: cannot satisfy -package wx
07:48:57 <beaky> is Scala lazy?
07:49:02 <beaky> oops wrong channel
07:49:55 <laurynne> I then uninstalled everything again and tried to install all the packages via cabal
07:50:01 <nooodl> beaky: that sounds googlable
07:51:50 <dmwit> astor: The former definition does not have a MonadIO constraint on Deps.
07:51:56 <laurynne> but if I try to install wxcore, reactive-banana-wx etc., cabal gives me an error like  "wxcore-0.90.0.3 depends on wxc-0.90.0.4 which failed to install"
07:52:06 <dmwit> Try it: ask :k! Deps ZipList in ghci and see what happens.
07:52:18 <beaky> I like how working on data structures in Haskell is just pattern matching on constructors
07:52:22 <laurynne> Trying to install wxc, then, simply results in "ExitFailure 1"
07:53:38 <laurynne> I found this question on StackOverflow that is similar to my problem: http://stackoverflow.com/questions/12367480/
07:53:43 <ski> .. i suppose you could try asking dcoutts
07:54:01 <dmwit> "ExitFailure 1" means you have to scroll up (sometimes WAY up) to find the real error message.
07:54:33 <typoclass> laurynne: hello, try the failing cabal command again, but with "-v3" to make it verbose. if you can't figure out the output, feel free to put it on hpaste so folks in here can look at it
07:54:35 <typoclass> @where hpaste
07:54:35 <lambdabot> http://hpaste.org/
07:55:00 <dmwit> -v3 isn't likely to help in the case of ExitFailure 1.
07:55:21 <dmwit> Typically that means a call to configure failed, and configure isn't being passed on the "really, really, really verbose" request.
07:55:22 <laurynne> dmwit, there's a warning about a missing config file, I'll paste it
07:55:48 <Philonous> I find that just restarting the compilation will usually bring the error message to the end of the output
07:56:26 <dmwit> astor: (Does that answer your question?)
07:57:52 <laurynne> http://hpaste.org/76828
07:57:58 <dmwit> laurynne: Do you have the wx C libraries (including -dev version, if your distribution makes that distinction) installed?
08:00:06 <laurynne> dmwit, do you mean libwxbase2.8?
08:00:10 <typoclass> laurynne: have you tried that wx-config --list command? and what dmwit says, i bet you have no wx versions installed that match the version that the wxc package needs
08:00:47 <dmwit> laurynne: Oh, if you have wx-2.8, it seems wxc-0.90 isn't for you.
08:01:10 <dmwit> You need wx-2.9 or later, according to the Hackage page for wx.
08:01:41 <dmwit> You could try installing wx-0.13.2.3 instead.
08:02:01 <hpaste> laurynne pasted ‚Äúoutput of wx-config --list‚Äù at http://hpaste.org/76829
08:02:23 <dmwit> uh, and the latter there is meant to be the Haskell package version number, while the former is the C package version number
08:03:12 <laurynne> I read on the HaskellWiki that there seems to be a difference in how wx 2.8 and 2.9 have to be treated, but I didn't really understand it
08:03:14 * dmwit notes that this information is also in the first section of the wxHaskell home page
08:03:52 <dmwit> "didn't understand, therefore ignore"? =/
08:04:13 <laurynne> I did not ignore it
08:04:22 <typoclass> laurynne: which part didn't you understand? do you mean on this page? http://www.haskell.org/haskellwiki/WxHaskell
08:05:04 <dmwit> Try: cabal install wx --constraint "wx >= 0.13 && < 0.90"
08:05:32 <laurynne> I don't understand if I need the packages from my package manager at all or if I could/should/must install everything via cabal
08:06:08 <parcs`> > pi :: Rounded TowardZero 100
08:06:09 <lambdabot>   Not in scope: type constructor or class `Rounded'Not in scope: type constru...
08:06:11 <parcs`> 0.000000000931322574615587496216
08:06:12 <laurynne> There are so many different pages, one says "do it this way", another says "do it that way"
08:06:15 <parcs`> zsh: segmentation fault  ghci :(
08:06:25 <dmwit> There's lots of choices.
08:06:27 <laurynne> I just got really confused
08:07:01 <dmwit> In short: the C bits must come from outside of cabal; the Haskell bits may equally well come from your package manager (if they're there) or cabal.
08:08:18 <laurynne> I did install g++, libglu-dev (which is libglu1-mesa on Mint), and libwxgtk2.8-dev and its dependences, like it said on http://www.haskell.org/haskellwiki/WxHaskell/Linux
08:08:31 <typoclass> laurynne: oh right :) with these sorts of libraries, you generally have a haskell side and a c side. cabal can get the haskell side for you, but the c side must be installed through your distro's package manager. the versions need to match, as described on that wiki page in the first section
08:08:31 <laurynne> *dependencies
08:09:32 <typoclass> laurynne: yeah, that's pretty much the right stuff. only you need the 0.13 version of wxc. if you just say "cabal install wxc", it'll select the newest, which is 0.90, which is not compatible with wx 2.8 (see wiki page)
08:09:58 <laurynne> typoclass, ah, okay, I didn't understand that. I thought I had to choose between package manager and cabal, either one or the other
08:10:16 <typoclass> laurynne: don't worry :)
08:10:32 <typoclass> laurynne: so yes, refer to the cabal command dmwit mentioned above. that should install the compatible version of wxc
08:10:46 <laurynne> okay
08:11:54 <laurynne> I'm not really on friendly terms with cabal, it always goes KABOOM on me :/
08:13:44 <typoclass> laurynne: right, it can be a bit brittle :-) but there's some tricks to get it to run better. if you have cabal trouble, feel free to put the -v3 output on hpaste and ask in here. usually folks can figure it out pretty quickly
08:14:24 <laurynne> okay. -v3 really spammed my terminal when I tried it :D
08:14:50 <laurynne> ahh, I'm finally having an error that's mentioned on the Wiki. Hooray!
08:15:01 <dmwit> -v3 is great when cabal is at fault. Not so much when it's shipping out to something else that's at fault.
08:15:41 <dmwit> e.g. if dependency resolution fails
08:16:23 <laurynne> I'm having that libwx_gtk2u_media problem that http://www.haskell.org/haskellwiki/WxHaskell/Linux mentions
08:17:07 <astor> dmwit: Thanks for the pointer.  I'll have to push it on my stack - I've misunderstood what instances with context really mean, so I need to redo my approach.
08:17:07 <laurynne> so, how do I find out which gstreamer and gconf packages I have to install?
08:17:48 <laurynne> there's an awful lot of gstreamer packages in the PM, some of which are already installed
08:19:28 <dmwit> There's always the "cut the Gordian knot" approach.
08:19:31 <dmwit> Install them all. =D
08:19:46 <laurynne> Ö I feared that answer might come xD
08:20:28 <dmwit> I guess this means you're not on Ubuntu or Debian, huh?
08:20:29 <identity> I would be wary of following dmwit's advice. He's only a single vowel away from an idiot.
08:21:06 <laurynne> dmwit, I'm on Linux Mint Debian Edition
08:21:18 <typoclass> laurynne: does your distro have a search thingy that can tell you which package offers anything named "libwx_gtk2u_media"?
08:22:40 <identity> really? I'm not getting any credit for that witty joke?
08:22:50 <identity> Tough crowd.
08:23:17 <dmwit> As far as "dimwit jokes" go, it was pretty good. =)
08:23:20 <Eduard_Munteanu> FWIW, it might've been offensive, but rather amusing.
08:23:28 * dmwit is not offended
08:23:37 <dmwit> Hell, it's why I chose the nick in the first place. =D
08:23:38 <identity> thank you guys. I knew I could count on you.
08:23:42 <Eduard_Munteanu> Heh.
08:23:49 <typoclass> identity: i think many people secretly pronounce dmwit as "dimwit"
08:24:12 <identity> and I allowed myself to presume that I wasn't the first person to come up with such a joke and thus judged the probability of dmwit being offended as close to 0.
08:24:20 <identity> typoclass: I know I do.
08:24:20 <identity> heh.
08:24:46 * dmwit pronounces it that way too
08:25:17 <dmwit> It doesn't come up much in IRC, but I've had a few amusing times in multiplayer games.
08:25:30 <dmwit> "Hey, uh... dee em wit or whatever, there's a guy behind you!"
08:25:53 <laurynne> typoclass, I'm using Synaptic, but no luck there
08:27:33 <laurynne> I'm searching the Internet for hints on this
08:27:53 <typoclass> laurynne: try http://packages.debian.org/search?searchon=contents&keywords=libwx_gtk2u_media&mode=filename&suite=stable&arch=any you might need to adjust your debian version
08:28:10 <typoclass> i think there's a similar thing for ubuntu
08:29:40 <beaky> why do I keep on having problems building Haskell packages/modules/libraries/applications with cabal?
08:31:01 <laurynne> Linux Mint Debian is rolling-release, its repos are based on Debian testing, so I'll look whether I can find it in testing
08:31:23 <laurynne> although Synaptic already says that there's no libwxgtk2.6, onli 2.8
08:31:29 <laurynne> *only
08:33:03 <laurynne> "You have searched for filenames that contain libwx_gtk2u_media in suite wheezy, all sections, and all architectures. Sorry, your search gave no results." :(
08:34:09 <laurynne> noob question: isn't there some complete wxHaskell binary that I could install and just bypass all of this fiddling around with single packages?
08:35:45 <laurynne> Strange enough, sid does have those libwxgtk2.6 that squeeze has, but wheezy doesn't
08:37:04 <beaky> what is bad about the Haskell record system
08:37:31 <Clint> namespace pollution
08:38:15 <quicksilver> beaky: it doesn't have one.
08:38:32 <quicksilver> All it has is a (rather minor) syntactic convenience for field accessor and field update.
08:38:36 <quicksilver> Which really *isn't* a record system.
08:38:47 <quicksilver> and it's more annoying than useful because it's not composable.
08:39:08 <beaky> ah
08:39:16 <quicksilver> On the other hand, you can write some quite interesting record systems in plain old haskell maybe using a little TH for boilerplate.
08:39:30 <quicksilver> which are composable and polymorphic and various things.
08:39:58 <laurynne> so, should I just take those libwxgtk2.6-0 and libwxgtk2.6-dev from sid, then?
08:41:10 <laurynne> or probably squeeze might be a better choice, I'm having enough breakages as it is
08:44:12 <beaky> is Data.Vector standard?
08:48:18 <drrckln> edwardk: btw, you presented some solution you made to traversing trees faster or something, at hac-phi this year. what was that again?
08:48:30 <Cale> beaky: What do you mean by standard?
08:48:41 <mroman> @pl \c -> [c]
08:48:42 <lambdabot> return
08:48:53 <edwardk> drrckln: probably the trick i came up with for fast lowest common ancestor search?
08:48:54 <Cale> beaky: It is a quality library
08:48:58 <beaky> like how all standard C++ implementations must have a std::vector
08:49:10 <drrckln> edwardk: yup yup
08:49:40 <Cale> Then no
08:49:49 <edwardk> drrckln: http://www.slideshare.net/ekmett/skewbinary-online-lowest-common-ancestor-search
08:49:57 <drrckln> edwardk: what were those numbers you used?
08:50:06 <drrckln> and.. that will work nicely haha
08:50:27 <edwardk> drrckln: skew binary: http://en.wikipedia.org/wiki/Skew_binary_number_system
08:50:46 <Eduard_Munteanu> beaky: the "standard" thing is Array
08:50:52 <Eduard_Munteanu> (and friends)
08:51:03 <edwardk> drrckln: http://hackage.haskell.org/package/lca implements the algorithm i presented
08:51:25 <edwardk> http://hackage.haskell.org/packages/archive/lca/0.2.2/doc/html/Data-LCA-Online.html should give you all the relevant details
08:52:12 <beaky> ahright
08:52:33 <laurynne> dependency hell D:
08:54:24 <laurynne> I tried to install libwxgtk2.6-0 from squeeze which obviously contains the wanted  libwx_gtk2u_media, but it wants libwxbase2.6-0 and I fear I might never get out of this alive :(
08:55:00 <drrckln> edwardk: sweet. there gonna be a boston haskell meetup anytime soon?
08:55:30 <edwardk> drrckln: i need to get the space, but in theory it should be on the 7th. dan doel is going to present something as will some folks from fp complete
08:56:01 <edwardk> dan doel is going to over normalization by evaluation. fp complete has an announcement of some sort
08:56:42 <drrckln> hmm.. interesting
09:02:26 <hiptobecubic> edwardk, I hadn't considered that the partial derivatives of a function form a comonad (apparently)
09:02:48 <koala_man> let's say I have a parsec parser that reads a simple AST. how can I annotate that AST with SourcePos information as I parse? starting each function with getPosition can't be optimal
09:03:47 <koala_man> I assume I can stack some monads somehow, but I'm a noob
09:04:28 <hiptobecubic> chocolate trains and outer space
09:06:10 <Cale> koala_man: Well, start out by writing some of it like that, and then try to factor out the repetition.
09:07:40 <koala_man> Cale: I can make a toAnnotated p = do { pos <- getPosition; foo <- p; return $ Annotated pos foo; }, but that doesn't help when p is composite
09:08:15 <Cale> What do you mean by p is composite?
09:08:45 <koala_man> in the sense that it parses a section of AST. I only get the outermost SourcePos, while I would like it for every element in the tree
09:09:24 <Cale> Right, so you need a use of toAnnotated for each element where you want an annotation
09:09:41 <edwardk> hiptobecubic: i'd have to work through the partial derivative thing to make sure its rigorous
09:09:47 <edwardk> gotta run though
09:10:01 <hiptobecubic> edwardk, Cofree?  ok toodleoo
09:10:25 <edwardk> well, i use the cofree comonad to hold the derivatives, its not really comonadic though
09:10:40 <hiptobecubic> Oh
09:10:46 <edwardk> basically just has the right shape, a * f (a * f (a * ‚Ä¶
09:10:50 <hiptobecubic> Well i'll ask again later. :)
09:10:56 <koala_man> Cale: is there any practical way around that?
09:11:04 <edwardk> its the answer and the first derivatives zipped with the second, etc.
09:11:10 <edwardk> and you an extract it from that into a Jet
09:11:18 <hiptobecubic> edwardk, i figured out to make it work
09:11:21 <koala_man> just turn an AST into a position annotated AST by magic?
09:11:21 <edwardk> using jet, headJet and tailJet to get access to each level
09:11:23 <edwardk> k
09:11:30 <edwardk> i'l be back on tonight
09:11:34 <hiptobecubic> after some time :).  but i didn't see why it wasn't just a jet to begin with
09:11:35 <edwardk> probably in 12 hours
09:11:36 <hiptobecubic> ok
09:11:46 <hiptobecubic> edwardk, yikes. I will hopefully be asleep :) maybe next time
09:11:51 <edwardk> the issue is that the cofree comonad is stronger than the jet
09:11:58 <edwardk> it kept the 'f's zipped
09:12:03 <edwardk> you can't zip arbitrary traversables
09:12:06 <edwardk> but here it can
09:12:13 <Cale> koala_man: Well, there's no such thing as magic. You need to say what you mean in one way or another.
09:12:15 <clahey> mcstar: I've been thinking a lot about how to structure my sudoku solver.
09:12:29 <clahey> mcstar: So far I've mostly done work on making some of the low level stuff fast.
09:12:44 <edwardk> a * f (a * f (a * ‚Ä¶ is more information than a * f a * f (f a) * f (f (f a)) .. the former lets you know more about the shared shape of the 'f's
09:13:03 <hiptobecubic> it was more useful to use the cofree directly in my case
09:13:29 <hiptobecubic> or at least, more intuitive
09:13:45 <edwardk> yeah
09:13:50 <hiptobecubic> https://gist.github.com/3956381
09:14:00 <edwardk> the cofree comonad is the 'right' version, the jet is convenient when you want to peel off the hessian, etc.
09:14:12 <hiptobecubic> sure
09:14:20 <clahey> I've got data NineBits and countEqualsOne [NineBits] -> NineBits which, for each bit, returns whether that bit shows up as on exactly once in the list, without a single branch.
09:14:24 <edwardk> hiptobecubic: nice
09:14:58 <hiptobecubic> edwardk, also ... lenses. Also nice.
09:15:24 <laurynne> Could somebody help me, please?
09:15:42 <edwardk> with linear, i've been working with acowley on lens-based linear algebra
09:15:48 <hiptobecubic> laurynne, be more specific please
09:15:59 <hiptobecubic> edwardk, sounds interesting
09:16:42 <Cale> I find it funny that they felt the need to invent a Greek letter.
09:16:48 <edwardk> using lenses as the representation of corepresentable functors,and the fact that every vector space is free to get a nice abtract encoding of linear algebra that i can 'see through' for AD and GPU work, etc.
09:16:49 <hiptobecubic> Yes
09:16:56 <hiptobecubic> Cale, as if there weren't plenty lying around already
09:17:27 <edwardk> heading out
09:17:37 <hpaste> laurynne pasted ‚Äúinstalling wx fails because wx_gtk2u_media-2.8 is missing‚Äù at http://hpaste.org/76831
09:18:05 <hiptobecubic> laurynne, did you install that library?
09:18:32 <laurynne> I don't know where it is
09:18:34 <hiptobecubic> via your package manager, for example?
09:18:57 <hiptobecubic> laurynne, which distribution of ... is this linux or osx?
09:19:00 <rwbarton> laurynne, what OS (linux?)/distro?
09:20:09 <laurynne> typoclass searched for it on packages.debian.org and found wx_gtk2u_media in for Debian Squeeze, in a package called libwxgtk2.6-0, but there is no 2.6 version in my repos, only 2.8
09:20:21 <laurynne> my OS is Linux Mint Debian Edition
09:20:41 <laurynne> it's based on the testing branch of Debian, which is wheezy atm
09:21:16 <laurynne> but wheezy does not seem to have a package that satisfies wx_gtk2u_media
09:21:19 <laurynne> http://packages.debian.org/search?suite=wheezy&arch=any&mode=filename&searchon=contents&keywords=libwx_gtk2u_media
09:21:52 <laurynne> so I'm at a loss now
09:21:59 <hiptobecubic> hmm
09:23:01 <hiptobecubic> laurynne, https://bugs.launchpad.net/debian/+source/wxwidgets2.8/+bug/632984
09:23:02 <rwbarton> laurynne: it doesn't seem quite right but i don't suppose this is your problem? http://stackoverflow.com/questions/9756088/cabal-install-wx-missing-c-library
09:23:24 <rwbarton> ok hiptobecubic's looks much more promising
09:23:28 <koala_man> Cale: fair enough. what if I want nice warnings on the current element, like do { s <- parser; when (s == "foo") (warn "unsupported"); return s; }, but I don't want these warnings to appear on any subelements or parent elements
09:24:31 <koala_man> so like stacking a Writer monad but limiting it to a scope of my choosing
09:25:04 <laurynne> rwbarton, I found this question on SO, too, but g++ is already installed here
09:25:17 <laurynne> hiptobecubic, ummm, what does that bug report tell me?
09:26:17 <rwbarton> see the last message in the thread
09:26:29 <Cale> koala_man: Parsec has some provision for user state which you could use to keep track of a log of warnings.
09:26:30 <rwbarton> then if applicable, see message #12
09:26:53 <Mortchek> To fold a set the same way no matter in what order it's traversed, would the folding function need to be a commutative binary operation (i.e., S√óS‚ÜíS for some S)?
09:26:58 <Cale> koala_man: I suppose you could also use ParsecT or WriterT if you really wanted to.
09:27:17 <koala_man> I guess I could maintain my own stack of messages on the user state. thanks!
09:27:34 <Cale> Mortchek: also associative probably
09:27:42 <Mortchek> Cale, why?
09:27:53 <laurynne> rwbarton, you mean I should use the Ubuntu PPA mentioned there?
09:28:08 <Mortchek> Oh, I think I see
09:28:20 <hiptobecubic> laurynne, in debian apparently, the file was removed because it pulled in gconf which no one wanted
09:28:23 <rwbarton> laurynne, I guess so
09:28:39 <rwbarton> hmm
09:28:44 <Mortchek> Cale, are my other restrictions reasonable? Can they be relaxed?
09:28:48 <hiptobecubic> laurynne, then some people complain about it and someone from ubuntu posts a patch which people also complain about. tldr you have to build it yourself probably.
09:28:59 <hiptobecubic> or find an ubuntu package that 'works'
09:29:15 <Cale> No, that's reasonable. You want a commutative monoid.
09:29:15 <laurynne> but I don't know if I can, since linuxmint.com explicitly states that Linux Mint Debian Edition is compatible with Debian, but not with Ubuntu
09:29:20 <hiptobecubic> in quotes because that's totally unsupported and will be a coincidence i think.
09:29:28 <Cale> (it also has to be a monoid because of the empty set)
09:29:44 <Cale> (and not just a commutative semigroup)
09:29:58 <hiptobecubic> laurynne, it *often* works but it depends on a lot of things being coincidentally lined up
09:30:02 <clahey> Is there a function with type something like ((element, State) -> (element, State)) -> (Array, State) -> (Array, State) ?
09:30:08 <hiptobecubic> laurynne, so if it doesn't work, it's no surprise.
09:30:28 <hiptobecubic> most recent complaint here was 4 days ago
09:30:30 <laurynne> I'm really starting to hate all this :((
09:30:30 <hiptobecubic> http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=588104
09:30:49 <rwbarton> clahey, you can build it with mapM from Traverable in the State monad
09:31:00 <clahey> Traverable?
09:31:04 <laurynne> I'm pulling the sources via darcs now (in case that's the right thing to do to get the sources)
09:31:08 <rwbarton> Data.Traversable
09:31:17 <johnw> Traversable's mapM == traverse, btw
09:31:51 <hiptobecubic> laurynne, try the PPA if you found one. it could work
09:32:13 <Mortchek> Cale, what is something that is a commutative monoid but not much stronger? I have relatively little intuition about what is a monoid or a commutative monoid or whatnot.
09:32:38 <typoclass> (i thought wx is a fairly popular package. it seems very weird that installing it on a major distro like debian is difficult to impossible)
09:32:49 <bitonic> is there a way to print the trees in `containers' in a nice way, without building with -Ddebug or whatever that was?
09:32:58 <johnw> Mortchek: Product and Sum are commutative monoids
09:33:25 <clahey> johnw: Just one is for Applicatives and one is for Monads for some reason.
09:33:38 <johnw> clahey: interesting!  good to know
09:33:51 <johnw> i still haven't run into a Monad that wasn't also Applicative yet...
09:34:01 <clahey> johnw: That's because mathematically, they all are.
09:34:09 <johnw> i mean, in Hask :)
09:34:11 <clahey> johnw: I was about to ask...
09:34:20 <Mortchek> Cale, johnw, thanks.
09:34:25 <laurynne> typoclass, you're reading my mind there :/
09:34:33 <clahey> johnw: How much would it break existing code to change Monad to include Applicative in its definition?
09:34:45 <clahey> johnw: Not to just ask you, but to ask people in general.
09:35:00 <rwbarton> this is actually being proposed on haskell-prime presently
09:35:02 <laurynne> I dunno, maybe I'm just too dumb to do it correctly, but I don't really think I am
09:35:04 <b__> is it possible to use unicode chars like Ä in ghci somehow? if I try to input it in ghci I get "???"
09:35:28 <c_wraith> clahey: it'd make any type that declares a monad instance but not an applicative instance fail to compile.
09:35:28 <johnw> clahey: probably for the same reason that Monad isn't constrained by Functor
09:35:33 <rwbarton> b__, sure
09:35:37 <rwbarton> Prelude> '‚Ç¨'
09:35:38 <rwbarton> '\8364'
09:35:42 <johnw> because once you have the Applicative constraint, you will have the Functor constraint
09:35:54 <b__> hm it is probably an iterm2 issue then =]
09:35:55 <rwbarton> I just copied-and-pasted your euro symbol here to a terminal
09:36:04 <b__> or mac
09:36:30 <johnw> clahey: there was a big discussion thread on this topic on gmane, looking fro it now
09:36:38 <rwbarton> might be an inputrc thing as well?
09:36:47 <rwbarton> does ghci use that?
09:36:56 <johnw> clahey: anyway, see http://stackoverflow.com/questions/8658384/relationship-between-functor-applicative-functor-and-monad
09:37:02 <typoclass> laurynne: it now seems to be not so much a haskell problem, but a debian packaging problem. have you tried asking debian people about it? e.g. bugtracker, irc channel, forum
09:37:05 <rwbarton> anyways you should start by trying to paste one into 'cat' and see how that goes
09:37:18 <laurynne> typoclass, no, not yet
09:37:30 <b__> ± % echo Ä                                                                                                                                                                  !6674
09:37:30 <b__> Ä
09:37:34 <clahey> rwbarton: I don't have to build it.
09:37:37 <johnw> c_wraith: but isn't that a really small set of types these days?
09:37:42 <laurynne> I could try asking on the Linux Mint forums, they have a subforum for the Debian Edition there
09:37:45 <b__> in other words, it works, sorry for spampaste
09:37:49 <clahey> rwbarton: It's called mapAccumR (or L)
09:38:09 <johnw> i mean, GHC 7.6.1 already made a bunch of packages that didn't include Control.Exception fail to compile
09:38:24 <b__> rwbarton, pasting it into terminal is fine, but pasting it into ghci gives ???
09:38:27 <rwbarton> for an Array? that is from Data.Traversable also?
09:38:36 <johnw> so forcing an Applicative instance -- and I bet LANGUAGE DeriveApplicative would be trivial -- doesn't seem like a big stretch
09:38:44 <rwbarton> b__: hmm, maybe a haskeline peculiarity then?
09:40:31 <b__> rwbarton, I cannot input any chars via the usual alt-shift-x
09:40:43 <b__> (only in ghci)
09:40:52 <b__> in terminal and iterm2 it works fine
09:41:04 <b__> and macvim, etc, etc
09:41:34 <b__> The Glorious Glasgow Haskell Compilation System, version 7.4.1
09:43:05 <ski> @quote
09:43:06 <lambdabot> UmbertoEco says: I don't even have an e-mail address. I have reached an age where my main purpose is not to receive messages.
09:43:36 <tac> @quote
09:43:36 <lambdabot> michael| says: That made me rather angry with them [Adobe]. I should have uninstalled Flash to display my anger!
09:45:32 <b__> any char I try to input with the alt key fails in ghci
09:47:28 <b__> it would be so pretty to be able to write "Ä 3.00" etc
09:47:43 <b__> are there other input modes I could consider?
09:48:02 <Cale> b__: works for me
09:48:04 <clahey> rwbarton: Yeah, from Data.Traversable
09:48:16 <Cale> b__: Perhaps get a different terminal emulator?
09:48:26 <Cale> I'm using gnome-terminal
09:48:30 <b__> Cale, I tried it in both iterm2 and terminal
09:48:37 <b__> okay
09:48:48 <laurynne> okay, so I tried to follow the instructions on how to build wxHaskell on Unix systems: http://www.haskell.org/haskellwiki/WxHaskell/Building#On_Unix_systems
09:48:54 <Eduard_Munteanu> Maybe your encoding/locale aren't set properly?
09:49:16 <johnw> for example, export LANG=en_US.UTF-8
09:49:44 <Cale> b__: note that the euro sign is going to be printed as \8364 in the output, because the String value has show applied to it, which quotes all the non-ascii characters.
09:49:45 <laurynne> I pulled the sources with darcs get http://code.haskell.org/wxhaskell
09:49:46 <b__> johns, that works
09:50:03 <b__> thanks Cale, Eduard_Munteanu, johnw
09:50:21 <rwbarton> wow really? huh
09:50:23 <laurynne> I changed into the newly created wxhaskell directory and made a folder "mybuild"
09:50:23 <rwbarton> what was it before?
09:50:29 <sm> morning all
09:50:32 <johnw> the default is LANG=C
09:50:34 <johnw> hi sm!
09:50:46 <sm> b__: out of interest, what version of ghci is that ?
09:50:50 <b__> 7.4.1
09:50:52 <laurynne> I chmod +x the configure file and run it from within the "mybuild" directory
09:50:56 <sm> thx, good to know
09:50:56 <rwbarton> really? on a mac? wow
09:51:13 * sm thought the LANG var was obsoleted by GHC 7.x
09:51:51 <Eduard_Munteanu> How so? LANG isn't a GHC thing.
09:51:52 <hpaste> laurynne pasted ‚Äúbuilding wxHaskell from source: output of configure‚Äù at http://hpaste.org/76832
09:52:03 <johnw> LANG is a libc thing
09:52:04 <b__> rwbarton, yes, 10.8.2
09:53:00 <sm> Eduard_Munteanu: at least before GHC 7.0, GHC-built executables would crash if they encountered non-ascii data without LANG set correctly for that data
09:53:02 <laurynne> so, like configure says, I typed "make", but make complains that it could not find the make file (or sth. like that, system language is German atm)
09:53:31 <johnw> Ich kann nicht das Make finden!
09:54:05 <laurynne> however, there is a makefile in "wxhaskell/bugs", but I'm not sure whether I should use this oneÖ
09:54:40 <johnw> i would not
09:54:44 <johnw> have you run ./configure?
09:55:04 <laurynne> yes, I have, see ./configure's output in the hpaste
09:55:04 <geekosaur> GHC 7x (actually starting a little) *knows about* LANG, instead of ignoring it as in earlier versions...
09:55:14 <laurynne> http://hpaste.org/76832
09:55:21 <rwbarton> that output is rather weird
09:55:25 <geekosaur> 7.0 did tweak the behavior in the case of misencodes, yes
09:55:31 <johnw> it looks like it is not using autoconf
09:55:33 <laurynne> it created a folder "config" in my "mybuild" directory
09:55:36 <geekosaur> but I think 6.12 was the first version that knew about it at all
09:55:36 <johnw> but some custom script it has called "configure"
09:55:46 <rwbarton> what kind of system has /usr/doc/libraries
09:55:49 * sm meant "without locale set appropriately, which was most easily corrected via the LANG var"
09:55:52 <rwbarton> or even /usr/doc
09:56:44 <laurynne> do I have the correct sources?
09:57:10 <rwbarton> i'm also confused, are you building wxWidgets or wxhaskell?
09:57:33 <mcstar> clahey: im here
09:57:56 <rwbarton> because you pasted a link to instructions for building wxWidgets but your hpaste talks about ghc and wxhaskell
09:58:39 <laurynne> I guess it should be wxHaskell, since I got the sources from http://code.haskell.org/wxhaskell
09:59:01 <laurynne> Ö oh, now I see
09:59:04 <typoclass> rwbarton: afaik he's currently trying to get the c side to install. the larger goal is to get wxhaskell to run
09:59:07 <laurynne> you're right, rwbarton
09:59:23 <rwbarton> right
09:59:48 <laurynne> it even says "Building wxWidgets (usually optional)" in the headline
10:00:09 <laurynne> but it's on the wxHaskell page, so I got it all messed up
10:01:27 <laurynne> ok, so I need to build wxWidgets and then build wxHaskell, is that correct?
10:02:22 <rwbarton> build wxWidgets from source and then cabal install wx
10:02:36 <laurynne> I guess after some time one just gets so tired of all this that one starts skipping important detailsÖ
10:03:49 <laurynne> maybe I'll just try again tomorrow with a fresh brain
10:04:04 <laurynne> thank you, everyone who tried to help me
10:04:57 <typoclass> laurynne: you're welcome, and good luck for tomorrow's attempt
10:05:04 <johnw> zombies like fresh brains
10:05:10 <johnw> so watch out
10:07:19 <laurynne> so I guess wxWidgets is a zombie?
10:07:46 <laurynne> turned my precious little brainy into complete mush ;_;
10:08:25 <johnw> if it were the zombie, you'd have a hollow head by now
10:08:29 <laurynne> maybe I should just stick to Java, Swing and other idiot-proof stuff xD
10:08:33 <johnw> I just don't want you attracting nearby zombies
10:08:55 <johnw> is that idiot-proof in the same sense that high alcohol proof means more alcohol?
10:10:33 <typoclass> laurynne: right, it is a weakness of haskell that installing the gui parts can get so complicated
10:10:46 <b__> is there a symbol for addition other than the usual (+)?
10:11:04 <johnw> and, on behalf of Haskell, we do apologize for any inconvenience
10:11:16 <johnw> b__: what is it you're wanting?
10:12:17 * hackagebot citeproc-hs 0.3.6 - A Citation Style Language implementation in Haskell  http://hackage.haskell.org/package/citeproc-hs-0.3.6 (AndreaRossato)
10:12:24 <clahey> mcstar: Did you read what I said earlier?
10:12:27 <mourad> Unlimited International calls. is 100% free!
10:12:27 <mourad> http://free-unlimited-international-calls.tk/
10:12:27 <mourad> that you must download and install
10:12:31 <ion> b__: curry (negate . uncurry ((-) . negate))
10:12:54 <johnw> even better: add = (+)
10:15:30 <laurynne> thanks, guys
10:15:46 <laurynne> I guess I'm not feeling like a total idiot after all
10:15:53 <mcstar> clahey: something about a list of bits?
10:16:58 <clahey> mcstar: Yeah.
10:17:26 <clahey> So I have a data type to represent whether each value is possible in a particular cell.
10:17:55 <clahey> And an algorithm that just does a bunch of arithmetic and lets you combine multiple such values in an interesting way.
10:18:12 <clahey> For example, it can test for the case where only one cell has a particular value available.
10:18:21 <clahey> Without any branches.
10:18:31 <clahey> Well, a branch at the end where you test if it's zero or not.
10:19:00 <clahey> And it does it for all the possible values at the same time.
10:19:15 <mcstar> aha
10:19:27 <rwbarton> now process every row at once with simd operations :)
10:19:59 <mcstar> how can i un-seamless-ify a virtualbox window? :(
10:20:45 <mcstar> clahey: i have a set for each cell, that keeps the available choices
10:20:46 <clahey> rwbarton: I think I can do two rows at once.
10:21:18 <clahey> mcstar: Yeah, instead of a Set, I have an Int64.
10:21:31 <clahey> mcstar: 9 of the bits represent the possible values.
10:21:36 <mcstar> well, 8 bits would be enough
10:21:50 <clahey> rwbarton: Oh, of course I can't.  If I could do two rows at once, I could have done one row in 32 bits.
10:21:56 <clahey> mcstar: How so?
10:22:34 <rwbarton> you are spacing out the bits so that you can add and then test for "exactly one occurrence"?
10:22:34 <mcstar> yeah, weird
10:22:39 <clahey> rwbarton: Yep.
10:22:51 <rwbarton> so inconvenient how 9 is slightly more than 8
10:23:03 <clahey> rwbarton: And since there's up to 9 elements, I need 4 bits per element.
10:23:08 <rwbarton> I guess you would need 7 anyways
10:23:10 <rwbarton> right
10:23:13 <rwbarton> hm
10:23:20 <clahey> So 36 bits.
10:23:46 <rwbarton> seems like there is potential for more trickery
10:24:02 <clahey> rwbarton: Oh, yeah, I'm just getting started.
10:24:07 <rwbarton> since it's so close to 32
10:24:38 <clahey> rwbarton: Oh, to get it down to 32 bits?
10:25:04 <clahey> Well, all modern hardware is 64 bits anyway.  I'll just upgrade my machine to have a 64 bit OS.
10:25:19 <rwbarton> well, for example, if you use "base 10" instead of "base 16", it would fit in 32 bits, trouble is then you wouldn't have a good way to extract anything
10:25:31 <mcstar> clahey: i checked, i use a power of 2 representation once, but ofc not in 8 bits, i used a whole Int
10:25:39 <mcstar> used*
10:25:47 <clahey> Right.
10:26:08 <clahey> The low level stuff is all I've really coded so far.
10:26:17 <clahey> I'm pretty concerned about slicing the array quickly.
10:26:25 <clahey> I know how to do it in C, but not in haskell yet.
10:26:42 <mcstar> i would be really surprised if you approach would make the solver comparable in speed to the fastest ones
10:26:44 <mcstar> but lets see
10:26:51 <mcstar> is it working now, btw?
10:26:59 <clahey> I also haven't decided how I'm going to mark dirty rows/cols/boxes.
10:27:18 <clahey> mcstar: No, I've implemented data NineBits and countEqualsOne :: NineBits.
10:27:19 <clahey> Nothing else.
10:27:39 <mcstar> are you planning to explicitely backtrack?
10:28:11 <clahey> How would I implicitly backtrack?
10:28:55 <mcstar> if your algorithm does not mutate things, you can forget about backtracking
10:29:33 <clahey> In the past what I've done is made the solve function return whether it found a conflict and then just have it be recursive with a depth argument.
10:29:43 <byorgey> ivanm: looking for me?
10:30:51 <clahey> Once it's followed all the rules I code it with, it takes the first undecided cell and creates a copy with it set to each possible value checking for values that give a conflict.
10:32:04 <clahey> I think it'd probably be faster to find the cell with the fewest possibilities > 1 and recurse there.
10:32:54 <mcstar> yes, it is
10:33:03 <beaky> anyone know of a turotirla for Data.Array.Unboxed?
10:33:12 <mcstar> i dont eat turotirla
10:33:17 <mcstar> hate maxican food
10:33:19 <beaky> tutorial* ^^
10:33:32 <johnw> maybe there's one among all the unboxing videos on youtube :)
10:33:38 <mcstar> beaky: it is just an array
10:33:49 <clahey> But yeah, I usually have to write a clone method once I decide to recurse, but of course, in Haskell I'm gonna be constantly making "copies"
10:33:54 <hiptobecubic> beaky, tutorial in what sense?
10:33:57 <mcstar> what kind of tutorial would you need, for using an array?
10:34:10 <clahey> mcstar: It's just an Array that can't store undefined, right?
10:34:10 <mcstar> my code has type annotations and read/write operations
10:34:20 <beaky> How do i create my own arrays, and what can I store in an unboxed array?
10:34:21 <typoclass> johnw: please refer to http://www.youtube.com/watch?v=2XID_W4neJo
10:34:27 <hiptobecubic> clahey, it's an array that can store things which have an instance of Unboxed defined, or something
10:34:38 <mcstar> yeah, look at the docs
10:35:12 <hiptobecubic> also why Array and not Vector?
10:35:16 <beaky> so Data.Array.Unboxed is just like a plain C array, where you must specify the size at compile time?
10:35:21 <hiptobecubic> (honest question)
10:35:39 <beaky> Data.Array.Unboxed comes standard :D
10:35:48 <mcstar> newArray_ :: Ix i => (i, i) -> m (a i e)
10:35:49 <hiptobecubic> it's C-like in the sense that it's not the usual collection of pointers
10:35:53 <clahey> "Primitive types are always unlifted; that is, a value of a primitive type cannot be bottom."
10:35:57 <clahey> That's what I was trying to say.
10:36:14 <rwbarton> you use UArray exactly like Array
10:36:39 <mcstar> with newArray_ the elements are not initialized
10:36:50 <mcstar> also, i dont understand why you would want that
10:36:57 <beaky> I want one initialized all zeroes
10:37:08 <rwbarton> beaky: you don't have to specify the size at compile time. just like you do not have to with Array
10:37:10 <mcstar> newArray :: Ix i => (i, i) -> e -> m (a i e)
10:37:14 <mcstar> e
10:37:18 <hiptobecubic> beaky, it's worth the ten second cabal install apparently. I don't actually know, I haven't used Arrays, only Vectors, but every time I see a blog or something using Arrays, there's always some comment about Vectors and then the post is modified to use Vectors for whatever reason
10:37:27 <mcstar> ofc you dont have to
10:37:35 <beaky> right
10:37:51 <rwbarton> > listArray (0,4) [] :: UArray Int Int
10:37:52 <lambdabot>   Not in scope: type constructor or class `UArray'
10:37:58 <mcstar> hiptobecubic: for me, arras was a bit faster than vector
10:38:09 <mcstar> hiptobecubic: also, they are multi dimensional, vectors arent
10:38:10 <hiptobecubic> mcstar, using the 'unsafe' fections?
10:38:12 <clahey> mcstar: So, you used Arrays of cells?
10:38:14 <hiptobecubic> functions*
10:38:27 <clahey> mcstar: With newArray ((0, 8), (0, 8)) ?
10:38:28 <mcstar> i think, yeah
10:38:43 <mcstar> clahey: i wouldnt use a 2d array for sudoku
10:38:47 <mcstar> a map is perfect
10:39:08 <mcstar> which you can change in an immutable way, so you dont have to explicitely backtrack
10:39:52 <clahey> mcstar: Hmm.
10:39:58 <mcstar> clahey: the turing machine code used arrays, so i think, you havent look at it?
10:40:02 <rwbarton> beaky: listArray will hand you one initialized with all zeros
10:40:08 <mcstar> you know, i wrote that code, for y ou to actually read
10:40:16 <beaky> I think of arrays as functions mapping an Index type to an object of another type
10:40:41 <clahey> mcstar: I must have missed the Arrays version somehow.  Do you have the link?
10:40:53 <clahey> mcstar: So, my plan was to update every cell at once from the old array.
10:41:03 <clahey> To create a new array.
10:41:10 <mcstar> clahey: are you talking about beaky 's turing machine?
10:41:25 <clahey> mcstar: You said the turing machine code used arrays.  What were you talking about?
10:41:25 <mcstar> thats where i used an array
10:41:35 <mcstar> yeah
10:41:46 <clahey> I thought beaky's machine used data Tape [a] a [a]
10:41:58 <clahey> But I'd be happy to look at whatever you've got.
10:42:00 <mcstar> but then i changed a to IOUArray
10:42:12 <mcstar> a chunked array representation
10:42:14 <clahey> And did it all impure.  Got it.
10:42:20 <beaky> data Tape [a] a [a] turned out to be too slow :(
10:42:32 <mcstar> why?
10:42:43 <mcstar> if the arrays are long enough, you dont swap them much
10:42:55 <mcstar> if they are ~100000 elements, busy beaver 5 doesnt swap them
10:43:00 <Dodek> hey, have you heard about fast inverse square root hack? how would one implement it in haskell?
10:43:01 <clahey> mcstar: Do you have a link to that version?
10:43:01 <beaky> with an Array, windL and windR should be as fast as ++pointer or --poiner
10:43:14 <mcstar> clahey: it is hpaste-rotten
10:43:15 <clahey> beaky: As they were with my version.
10:43:25 <clahey> mcstar: Ah, I'm sorry I missed it.
10:44:08 <hpaste> beaky pasted ‚Äúturingmachine with arrays‚Äù at http://hpaste.org/76834
10:44:27 <mcstar> clahey: http://hpaste.org/76691
10:44:45 <beaky> http://ideone.com/ZJchYL this is the one we need to beat :D
10:44:53 <mcstar> hpaste should be filterable by author and or subject
10:45:12 <mcstar> i definitely dont need to beat that one
10:45:18 <mcstar> this is totally misguided
10:45:22 <beaky> why?
10:45:39 <clahey> I agree about not needing to beat that one.
10:45:42 <clahey> It's not safe.
10:45:43 <mcstar> beaky: go ahead, and write the exact same code in haskell
10:45:52 <beaky> right I'll try to
10:45:56 <mcstar> you CAN do that, but why the heck would you want to...
10:46:08 <beaky> I have a safer java version
10:46:17 <beaky> runs just as fast too
10:46:52 <mcstar> ah, beaky, you repasted my code?
10:46:53 <beaky> http://ideone.com/KrdtUF
10:46:55 <clahey> It also has the machine hard coded.  I should try changing my C++ version to do that and see if it's as fast.
10:46:57 <beaky> yes
10:48:22 <clahey> mcstar: Anyway, I was hoping to make a pure sudoku solver.  One that avoids IO.
10:48:32 <clahey> mcstar: And see how fast I can make it.
10:48:42 <clahey> mcstar: So my plan was to write something like:
10:51:41 <mcstar> that could work
10:51:56 <clahey> newGrid = array   ((0, 8), (0, 8))   [(i, newVal) | i \‚Üê [(0, 0), (8, 8)], let newVal = updateFunc oldGrid i]
10:52:34 <clahey> I know that syntax isn't quite right.
10:52:45 <mcstar> not just the syntax
10:53:01 <mcstar> i would take on (0,0) and (8,8)
10:53:12 <clahey> Oh, I mean .., not ,
10:53:19 <byorgey> clahey: ((0,8), (0,8)) means your array has only one element
10:53:24 <byorgey> namely, (0,8)
10:53:25 <mcstar> thaty too
10:53:32 <clahey> Right, ((0, 0), (8, 8))
10:53:34 <mcstar> ((0,0),(8,8)
10:53:38 <mcstar> )
10:53:45 <clahey> Can I write [(0, 0) .. (8, 8)]
10:53:47 <byorgey> [(0,0) .. (8,8)]  -- does this work?
10:53:50 <mcstar> i dont think so
10:53:51 <byorgey> > [(0,0) .. (8,8)]  -- does this work?
10:53:52 <lambdabot>   No instance for (GHC.Enum.Enum (t, t1))
10:53:52 <lambdabot>    arising from a use of `e_10088' ...
10:53:53 <byorgey> no
10:54:08 <byorgey> @hoogle range
10:54:08 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
10:54:08 <lambdabot> Data.Ix rangeSize :: Ix a => (a, a) -> Int
10:54:09 <lambdabot> Language.Haskell.TH.Syntax data Range
10:54:16 <byorgey> you have to use that function
10:54:26 <byorgey> > range ((0,0),(8,8))
10:54:28 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(1,0),(1,1),(1,2),(1...
10:54:28 <mcstar> have to?
10:54:39 <byorgey> ok, not *have* to
10:54:43 <byorgey> you could reimplement it yourself
10:54:46 <byorgey> =P
10:54:48 <clahey> Is \<- right?
10:54:54 <mcstar> no
10:54:59 <byorgey> drop the \
10:55:12 <clahey> I saw it here: http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-IArray.html#v:array
10:55:21 <clahey> I didn't think it was supposed to be there.
10:55:33 <byorgey> hah, that looks like a typo
10:55:41 <byorgey> like they were trying to escape the <
10:55:50 <byorgey> but I guess it doesn't need to be escaped.
10:55:52 <clahey> Ha.
10:56:13 <clahey> So, the other issue is that there's shared computations among the different cells.
10:56:23 <clahey> Look at a row, calculate some stuff about it.
10:56:39 <mcstar> you want to change state after each updateFunc i
10:56:48 <clahey> So I figure it can be updateFunc oldGrid i sharedData.
10:56:49 <mcstar> i.e. work on a new array
10:56:59 <mcstar> so this approch would be really bad
10:57:22 <mcstar> but its your code
10:57:32 <rogerthealien> hi, i'm a newbie trying to write a compiler in haskell, is anyone available for some brain poking in private (so I don't spam the list with my noob questions) ?
10:57:33 <mcstar> make one that solves the problem first
10:57:43 <clahey> I haven't decided how much I think it's gonna slow things down.
10:58:01 <mcstar> clahey: fortunately, algorithms tend to decide this for themselves
10:58:07 <Polarina> rogerthealien, just ask ahead in this channel. If you got lots of code, put it on hpaste. :)
10:58:09 <clahey> mcstar: :)
10:58:26 <clahey> mcstar: I haven't decided what my prediction is.  :)
10:58:48 <byorgey> rogerthealien: noob questions are welcome, either here or on beginners@haskell.org
10:58:56 <acowley> This happens to me all the time: I pick a bunch of pairs of numbers to sum or what have you, and end up subconsciously picking pairs that result in the same value
10:59:13 <acowley> I need the cranial quickcheck plugin
10:59:24 <typoclass> rogerthealien: welcome. to learn haskell, a good book is lyah
10:59:26 <typoclass> @where lyah
10:59:26 <lambdabot> http://www.learnyouahaskell.com/
10:59:53 <efie> In myfunction arg1 arg2 I can force arg2 to be evaluated strictly by saying: myfunction arg1 $! arg2. How do you evaluate arg1 strictly? I don't want to reorder the arguments
11:00:27 <typoclass> rogerthealien: to learn about constructing compilers, i'm not really sure, but i think "sicp" is a popular book
11:00:28 <Polarina> efie, use BangBatterns. { myfunction arg1 !arg2 = ... }
11:00:33 <mauke> arg1 `seq` myfunction arg1 arg2
11:00:51 <mcstar> or use strictness annotation on the arguments when you define it?
11:00:57 <mcstar> them*
11:01:02 <rwbarton> what mauke said or (myfunction $! arg1) arg2
11:01:15 <mcstar> it, since you define the function, not the arguments
11:01:26 <Philippa> rogerthealien: there's #haskell-overflow if you want to leave the main chan free?
11:01:30 <k00mi> typoclass: no, it's not about compilers
11:01:42 <rogerthealien> ok, here goes nothing, i've got this algerbraic data type define: data IntExp = IVar String | ICon Integer | Neg IntExp --- and I have an expression of the form exp :: IntExp -> a where i take an IntExp and just want to do something with it depending on which constructor it was created with. My questions is, how can I test which constructor was used, if at all possible?
11:01:47 <Philippa> it tends to help if there's more than one person you can work with, not least so we don't get worn out :-)
11:02:07 <Polarina> rogerthealien, it's called pattern matching
11:02:12 <beaky> theres a haskell book that gets you to write a scheme compiler
11:02:25 <Polarina> rogerthealien, exp (IVar str) = ...; exp (ICon int) = ...; etc.
11:02:38 <efie> thanks
11:02:39 <clahey> acowley: I was doing that last night.
11:03:00 <fmap> beaky: you probably meant interpreter, not compiler?
11:03:01 <typoclass> in Polarina's example, "exp" is the name of the function that is being defined here. "..." would be the code of the function
11:03:20 <acowley> clahey: It's funny because it means my hand-rolled tests always set off my "That doesn't look random!" warning alarms
11:04:12 <beaky> yes
11:04:22 <clahey> acowley: Even the value I was trying it with wouldn't have worked, I just forgot how the function I was calling worked and since I was doing the math in my head, it didn't work.
11:04:59 <acowley> Stupid head math getting the way
11:05:34 <Philippa> acowley: you mean you don't hand-roll random = 4 -- generated by d6 ?
11:05:38 <clahey> acowley: Well, specifically, I was just learning about shift and forgot that to shift right you needed negative numbers.
11:06:02 <clahey> acowley: So I wrote the algorithm using shift twice and expecting it to shift left the first time and shift right the second time.
11:06:09 <acowley> Yeah, I only use an IEEE certified random number for formal things.
11:06:15 <rogerthealien> Polarina, thank you
11:06:27 <clahey> acowley: Does that come with a certificate of approved randomness?
11:06:34 <acowley> Everyone's IEEE membership card has their own random number printed on the back
11:06:38 <acowley> it's great
11:06:45 <acowley> Can mine be 4? Sure!
11:07:07 <acowley> well, at least that's how I think it should work
11:07:16 <acowley> I guess the member ID is random enough for government work
11:08:41 <acowley> @seen edwardk
11:08:41 <lambdabot> Unknown command, try @list
11:09:59 <hiptobecubic> acowley, two hours ago. said he'd be back 10 hours from now.
11:10:14 <acowley> From now, or from then?
11:10:19 <hiptobecubic> from now
11:10:40 <hiptobecubic> 13 from then, for large enough values of 2
11:11:03 <acowley> when will then be now?
11:11:12 <hiptobecubic> how large is 2?
11:11:43 <hiptobecubic> acowley, really though. 10 hours from now.
11:11:48 <c_wraith> hiptobecubic: how soon is now?
11:12:02 <hiptobecubic> c_wraith, you just missed it
11:12:05 <acowley> hiptobecubic: thanks
11:12:49 <c_wraith> hiptobecubic: darn it
11:13:09 <hiptobecubic> c_wraith, the next one is soon though. keep your eyes open
11:13:55 <hiptobecubic> Ok, time to cycle home 10 km in the dark at 5¬∞C in a t-shirt and mittens
11:14:17 <clahey> hiptobecubic: You might want to get a coat.
11:14:25 <acowley> why does something like data family Foo (a::*) give a parse error on the right paren?
11:14:45 <rwbarton> do you have KindSignatures on?
11:14:47 <acowley> hiptobecubic: You might want to get pants.
11:14:52 <hiptobecubic> clahey, it's at home :)
11:14:55 <acowley> rwbarton: yes
11:15:01 <hiptobecubic> acowley, i might not :D
11:15:06 <clahey> hiptobecubic: Sleep in the office and wait until it's warm tomorrow afternoon and go get your coat?
11:15:11 <clahey> hiptobecubic: Or get a ride from someone?
11:15:28 <hiptobecubic> clahey, HAH. warm tomorrow afternoon.
11:15:32 <rwbarton> oh it's because ::* is a single token
11:15:42 <acowley> rwbarton: But it's annoying
11:15:48 <rwbarton> well waaah
11:16:01 <mcstar> run instead of cycle
11:16:05 <hiptobecubic> honestly it's not so bad. The mittens are essential, but if you cycle hard, it's nice. I never seem to have a problem with chest/legs being cold
11:16:08 <rwbarton> what if i need it for my spider kiss infix type constructor
11:16:08 * callen steels himself for trying to install haskell again
11:16:08 <mcstar> you will feel warmer
11:16:39 <acowley> haha
11:16:40 <hiptobecubic> i'm off!
11:16:44 <acowley> I like that a lot
11:16:44 <mcstar> bb
11:17:18 <acowley> I'd like to see an expansion of the Haskell syntactic bestiary.
11:17:21 <rwbarton> ::)
11:17:36 <hpaste> callen pasted ‚Äúcabal failing at life‚Äù at http://hpaste.org/76835
11:17:49 <callen> yep, still breaking the cabal install.
11:17:57 <callen> so what gives? how do I fix this?
11:19:41 <acowley> See what ghc-pkg list transformers says, then mentally regroup while preparing yourself for nuclear annihilation of ~/.cabal.
11:20:59 <hpaste> callen annotated ‚Äúcabal failing at life‚Äù with ‚Äúcabal failing at life (annotation)‚Äù at http://hpaste.org/76835#a76836
11:21:03 <acowley> Oh come on, writing "{-# UNPACK #-} Int" is also a parse error due to the missing !
11:21:07 <callen> acowley: annotated.
11:21:37 <gentleben> anyone using the new distributed-process stuff?
11:22:22 <acowley> callen: I'm not sure what the problem is. One approach is to track down which of comonad's dependencies that you'd previously installed also depends on transformers, then reinstall it
11:22:29 <callen> ...
11:23:51 <b_notsober__> "Ö" : known for it's usefulness in fixing technical problems
11:24:04 <acowley> another approach is to wait for dcoutts to offer guidance
11:24:11 <shapr> b_notsober__: what?
11:24:12 <b_notsober__> I just got that from Merriam Webster
11:24:26 <shapr> b_notsober__: Can you help me fix my cabal dependencies?
11:24:40 <beaky> I have this great idea to solve the expression problem: let's invent a dialect of Haskell, Objective-Haskell, and introduce class-based OO to Haskell! :D
11:24:45 <b_notsober__> I'd love to try shape =]
11:24:55 <b_notsober__> shapr*
11:25:13 <shapr> Are you sober?
11:25:16 <beaky> then we have the best of all worlds: ADTs and objects
11:25:30 <shapr> beaky: What's good about objects?
11:25:43 <shapr> beaky: Should we call it something like OOHaskell?
11:25:52 <beaky> or just OHaskell
11:25:53 <acowley> shapr: Btw, my current policy for bounds is that lower is what I test with, and no upper unless it's really needed
11:25:56 <shapr> beaky: http://homepages.cwi.nl/~ralf/OOHaskell/ ?
11:26:10 <tibbe> O'Haskell, where art thou?
11:26:22 <beaky> objects are great because if objects aren't great, then why would the most popular language have them?
11:26:23 <b_kindasober__> shape, what problems are you having? just tuned in
11:26:45 <b_kindasober__> shapr*
11:27:17 <shapr> Well, I wrote a Haskell program, and it has lots of dependencies, and it often doesn't build when people try to install it from hackage.
11:27:21 <callen> b_kindasober__: tab-completion. learn it, love it, use it.
11:27:24 <Silox|> Hello, I'm trying to read some input (strings) with the following function: reverseInput = do input <- readLn. It works, but only if I surround the input with quotes. Is it possible to make it work without the quotes around the input?
11:27:35 <beaky> on the serious side, a blend of OOP and FP seems interesting though like how scala does it
11:27:38 <b_kindasober__> callen, tab-completion in XChat is exactly the problem
11:27:49 <callen> b_kindasober__: I'm sorry you live in a computational ghetto.
11:27:56 <callen> b_kindasober__: I would however, be willing to trade you my cabal problems.
11:28:09 <b_kindasober__> a computational ghetto hm?
11:28:35 <b_kindasober__> sounds true given that I work as a front-ender in a PHP shop
11:28:39 <shapr> ha
11:29:06 <shapr> beaky: Have you tried Oleg and Ralf's OOHaskell code?
11:29:48 <beaky> shapr: they implement an object system on top of haskell? :D
11:30:36 <shapr> Try it!
11:33:56 <callen> now cabal itself is failing
11:34:09 <hpaste> callen pasted ‚Äúcabal fails to install itself again‚Äù at http://hpaste.org/76838
11:34:17 <callen> guys, I'm not going to lie.
11:34:18 <callen>  this is fucking dumb.
11:34:20 <mcstar> -rwsr-xr-x
11:34:23 <mcstar> whats 's'?
11:34:30 <geekosaur> setuid
11:34:30 <mauke> man ls
11:34:30 <callen> mcstar: stickybit
11:34:41 <geekosaur> callen: stickybit is t
11:34:42 <mcstar> thanks
11:34:46 <callen> geekosaur: my mistake
11:34:54 <callen> I have never seen a package manager be as unreliable as cabal.
11:35:27 <geekosaur> it's not a package manager, it's a wrapper for ghc-pkg which is also not a package manager (and most of the problems come ultimately from that)
11:36:14 <Silox|> I'm trying to read some input (strings) with the following function: reverseInput = do input <- readLn. It works, but only if I surround the input with quotes. Is it possible to make it work without the quotes around the input?
11:36:27 <rwbarton> sounds like you want getLine not readLn
11:36:40 <shapr> geekosaur: So, what's the fix?
11:36:54 <Silox|> Aha, it seems like I do, thanks rwbarton!
11:36:56 <callen> well, does anybody know why cabal is failing to install itself?
11:37:06 <typoclass> mauke: i don't think that the manpage explains it. you'd have to go to the info page
11:38:02 <shapr> callen: Actually cabal installed fine, cabal-install is failing to install because you don't have HTTP, see line 18?
11:38:15 <callen> shapr: why didn't it install HTTP?
11:38:22 <shapr> callen: if you see any "cannot satisfy" lines, that means you need to install that first.
11:38:33 <typoclass> callen: i think there's something wrong with your http package. either it's not installed, or it's installed and broken. try "ghc-pkg check"
11:38:33 <rwbarton> did you try "use -v for more information"?
11:38:34 * callen frowns
11:38:37 <geekosaur> shapr: if I only knew... the point is more that it's trying to make ghc-pkg more palatable and that's kinda lost cause from the outset.  I'm not sure it *is* fixable...
11:38:43 <shapr> callen: Because cabal-install is the "install from network" widget, and without HTTP it can't get to the network.
11:39:01 <typoclass> callen: also, are you sure you need to install cabal through cabal? mostly it's fine to just use the cabal that came with your ghc
11:39:09 <callen> ghc-pkg check HTTP or HTTP-4000 didn't work
11:39:18 <callen> typoclass: I was upgrading cabal to try to fix cabal
11:39:27 <callen> typoclass: because it was fucking failing at life on a different app earlier.
11:39:38 <shapr> callen: no swearing please
11:39:42 <callen> sorry.
11:39:48 <shapr> I know this is frustrating, I have similar problems.
11:39:51 <callen> It's just that after using leiningen, I'm finding this intensely bewildering.
11:40:02 <callen> leiningen works *fine* and it has to bridge two ecosystems (java and clojure)
11:40:11 <shapr> So, port it to Haskell?
11:40:12 <callen> I don't even remember the last time leiningen broke for me.
11:40:23 <callen> shapr: thankless work. I'd end up replacing ghc-pkg.
11:40:31 <shapr> I'd send you $5 :-)
11:40:47 <shapr> Which is a significant chunk of my student loans budget for this term.
11:41:04 <callen> anyway, ghc-pkg check didn't work for me, it complains about a syntax error.
11:41:09 <shapr> callen: So, did you try "cabal install cabal" ?
11:41:13 <callen> ghc-pkg check HTTP
11:41:19 <mauke> callen: ghc-pkg check
11:41:31 <callen> shapr: "already installed"
11:41:33 <typoclass> callen: cabal can be brittle, but with some tricks it runs fairly well. i recommend asking in here at the first sign of cabal trouble
11:41:51 <hpaste> callen pasted ‚Äúghc-pkg check‚Äù at http://hpaste.org/76839
11:41:51 <shapr> callen: did you do "cabal update" first?
11:42:09 <callen> I'd done one recently to begin with, but I'll do it again.
11:42:11 <shapr> callen: Well, the ghc-pkg check says you need to do "ghc-pkg recache"
11:42:30 <shapr> I don't see a syntax error mentioned.
11:42:52 <callen> shapr: we're moving faster than that.
11:43:04 <shapr> er, faster than what?
11:43:04 <callen> recache seems to have gotten the cabal-install going again, we'll see if it works.
11:43:12 <callen> that fixed it.
11:43:20 <callen> shapr: we moved past what you noted.
11:43:37 <callen> re-attempting original install now that cabal is cabal-install'd
11:44:25 <callen> well, that fixed everything.
11:44:29 <callen> a single ghc-pkg recache
11:44:31 <callen> absurd.
11:44:37 <callen> why didn't it just do the recache for me?
11:44:44 <shapr> callen: fix it?
11:44:52 <callen> fix what?
11:44:52 <typoclass> callen: i realize it doesn't help you much with the current mess, but for next time -- don't randomly update or reinstall things, i recommend to ask in here first
11:45:08 <shapr> callen: If you think it should do a recache for you, fix it?
11:45:08 <callen> typoclass: yeah, I figured that out by the time I started squawking in here.
11:45:22 <callen> shapr: I don't know enough Haskell to feel comfortable fiddling with cabal.
11:45:23 <typoclass> callen: ok :) i was just making sure
11:45:26 <callen> or ghc-pkg.
11:45:39 <shapr> callen: On the good side, that's only GHC, you should be fine!
11:45:44 <callen> typoclass: I reinstalled haskell like 3 times to get where we are now.
11:45:53 <callen> shapr: only what?
11:46:10 <shapr> I mean, adding an automatic recache call would only require adding some code to GHC.
11:46:27 <rwbarton> "Regenerate the package database cache.  This command should only be necessary if you added a package to the database by dropping a file into the database directory manually."
11:46:42 <rwbarton> who knows what you did to break it
11:46:43 <rwbarton> we certainly don't
11:47:06 <callen> I'll beg forgiveness for trying to get a compile to work later.
11:47:21 <shapr> callen: I think that was tactful for "you are leaking frustration everywhere, and it's no fun."
11:47:23 <callen> thanks for your help, typoclass, shapr, mauke.
11:48:51 <shapr> callen: Your life may be easier if you have your own Linux install and you use the packages from your distro to install the latest GHC. That should include everything you need.
11:49:00 <callen> shapr: OS X
11:49:07 <callen> shapr: I generally dev on Mac, deploy to Linux.
11:49:47 <shapr> I've not used OS X since 1999 or so, so I know nothing about it.
11:50:02 <callen> who does? *shrug*
11:50:35 <Clint> i know more than i want to know
11:50:45 <shapr> Oh right, it was Halloween of 1999 when I last used OS X.
11:51:25 <shapr> I wish I could get a copy of that, it was the Finder running as an app on top of NeXTStep.
11:51:57 <typoclass> shapr: not sure ... i wasn't very happy with the haskell packages that arch linux offers. each one needs multiple steps to install, and they don't even come with haddocks. i ended up just doing everything through cabal
11:52:09 <shapr> Debian is pretty good about Haskell packages.
11:52:32 <callen> it's their ruby packages you want to keep far afield of.
11:53:41 <Clint> i certainly want to keep far afield of any ruby packages
11:54:06 <Nickeeh> Total newb here, busy with tryhaskell.org :). Why can I do 1 : [2,3] but not [2,3] : 4 ?
11:54:27 <CmrPantoufle> : is not commutative
11:54:33 <CmrPantoufle> :t (:)
11:54:35 <lambdabot> forall a. a -> [a] -> [a]
11:54:39 <typoclass> Nickeeh: welcome. the : operator expects a single element on its left side, but a list on its right side
11:54:53 <rwbarton> x : xs is the list whose first element is x and where the rest of the list is xs
11:55:46 <Nickeeh> Okay. How would I append a value to a list?
11:56:00 <rwbarton> [2,3] ++ [4]
11:56:14 <rwbarton> ++ is for concatenating lists
11:56:22 <Nickeeh> Okay :)
11:56:24 <typoclass> Nickeeh: you might stick it at the beginning of the list, and at the end just reverse the whole list. or do what rwbarton said :)
11:57:02 <Nickeeh> Thanks both.
11:57:05 <Philonous> reverse (x : reverse xs) -- avoid the inefficient list concatenation ;)
11:58:42 <Nickeeh> > toUpper 'a'
11:58:42 <Nickeeh> Terminated!
11:58:43 <lambdabot>   'A'
11:58:47 <Nickeeh> oh nice.
11:58:50 <Nickeeh> Hello bot.
11:59:23 <Nickeeh> Does anybody happen to know how I acn skip a lesson? :X
11:59:28 <Nickeeh> it terminates. Not sure why.
11:59:42 <Nickeeh> Everything terminates.
11:59:43 <Nickeeh> Derp.
11:59:51 <Nickeeh> oh hey, the url.. that's easy
12:04:44 <mcstar> heh
12:04:55 <mcstar> that would be interesting
12:05:33 <mcstar> well, maybe not that much, it would be a double ended queue
12:10:17 <Nickeeh> hah, the tutorial is really fun :)
12:14:41 <Nickeeh> aww I'm done. :(
12:14:55 <Nickeeh> Well, a nice introduction.
12:16:03 <typoclass> Nickeeh: do you know lyah? it's a good book available free of charge
12:16:06 <typoclass> @where lyah
12:16:06 <lambdabot> http://www.learnyouahaskell.com/
12:18:12 * nejucomo always recommends book.realworldhaskell.org, but has not read lyah.
12:18:36 <nejucomo> Also, I worked with one of the rwh authors, so I'm probably biased.
12:19:31 <beaky> http://ideone.com/rmFKi3 how do I write a program like this in Haskell?
12:19:33 <strebe> nejucomo: they seem to have somewhat different target audiences
12:19:46 <typoclass> nejucomo: sure, rwh is also an excellent book :) i think it's a little more for intermediate haskellers, not really beginners
12:20:31 <nejucomo> I see.  Good to know the comparison.
12:20:38 <Rotaerk__> I'm not a fan of RWH
12:21:42 <Rotaerk__> it takes too long to teach things, because it's too dilluted with large, involved examples
12:22:11 <Rotaerk__> and you can't just skip them, because they sometimes nest new haskell ideas into them
12:22:28 <mcstar> there is speedreading
12:22:59 <Rotaerk__> speed reading is not useful for learning
12:23:19 <rwbarton> so slow down when you get to something you don't know :)
12:23:19 <Rotaerk__> because the bottleneck is not in your reading speed but in your learning speed
12:23:48 <Rotaerk__> it's not that I know it, for instance the examples aren't all about things I know
12:24:00 <Rotaerk__> it's just that they sometimes require me to learn things I don't *care* to know
12:24:11 <rwbarton> I see
12:24:16 <Rotaerk__> i.e. not haskell related
12:25:14 <mcstar> like what?
12:25:20 <Rotaerk__> not to mention i can't really speed read very well at all
12:25:26 <Rotaerk__> only in short spurts
12:26:05 <strebe> Rotaerk__: it's pretty bad as a reference manual, but I've found it extremely useful to learn from
12:26:05 <mcstar> i think if something is not haskell related in that book, then either you know it, or it is useful to know
12:26:23 <typoclass> Rotaerk__: i learn much better from examples than from abstract discussion, so that didn't bug me. the only thing that i would criticize is that rwh says things like "here's the code, but that has some disadvantages, so here's some fixes, etc." to get the end result you sometimes need to carefully read and combine several things, instead of just having one code block
12:26:42 <strebe> mcstar: I can't say my life's been deeply enriched by knowing details of a particular image format :-)
12:27:34 <strebe> typoclass: yeah, the code in chapter 14 is annoyingly scattered, and there are a few places where there are errors instead of the intended output throughout the book, usually due to multiple declarations of things in prelude
12:27:41 <Rotaerk__> yea, image format, barcodes, bloom filters
12:27:54 <Rotaerk__> JSON
12:28:04 <nooodl> aaaaah what the hell; my cygwin installation somehow let 20-something ghc threads run even after closing the terminal
12:29:35 <Rotaerk__> typoclass, I don't mind examples; I just don't like unnecessarily involved examples
12:29:36 <strebe> Rotaerk__: personally, that's something I like about the book
12:30:06 <strebe> I think they made a fairly decent tradeoff, and they make Haskell come alive in a way that "and this is three ways to reverse a list" references don't
12:30:35 <Rotaerk__> well, it also makes sense to show how it can be applied
12:30:44 <Rotaerk__> but imo that should be separated from the teaching of concepts
12:30:50 <strebe> but what you point out is definitely a disadvantage when looking for specific details
12:30:52 <Rotaerk__> so that you can easily skip it if desired
12:31:17 <Rotaerk__> (but it can't be skipped completely because they embed new concepts in the examples)
12:31:31 <strebe> Rotaerk__: short of making the book an entirely unreadable reference manual, I'm not quite sure how you'd do that
12:31:32 <beaky> should I feel bad if I use unsafePerformIO when writing system utilities?
12:31:52 <strebe> Rotaerk__: sure, the chapters build on each other; it's not a substitute for the module by module documentation, etc
12:33:47 <strebe> in general, when I want to find something via the index, I often can; it's not always entirely understandable without having read other chapters, but you'll find that in any tutorial
12:34:35 <rwbarton> Rotaerk__: have you read LYAH?
12:34:52 <Rotaerk__> yea, I like its style better, though it's not as complete
12:35:23 <Rotaerk__> well, didn't read all of it, but enough to get an idea of what it's like, and then saw the topics of coverage from the table of contents
12:36:33 <rwbarton> ok, just making sure. sounds like it would be more in your style
12:44:42 <nand`> I'm not a fan of RWH, because I don't like the code samples
12:44:53 <nand`> they're all ugly or feel overengineered, like ‚Äúsurely there's a simpler solution‚Äù
12:46:32 <strebe> nand`: I'd agree about some of them, but it's also made me realize just how incredibly clumsy some of the Haskell I've previously written is, and shown me more concise and simple ways to do things
12:47:06 <strebe> if you have examples of codebases to read for clean, dense Haskell that doesn't strike you as overengineered, I'm all ears :-)
12:47:12 <Philonous> beaky:  No, you should just not use unsafePerformIO
12:47:41 <Saizan> it's a bit unfair to blame them for overengineering, they are trying to show with a simple example some level of engineering which would work for more complex situations
12:48:25 <Saizan> though it somehow overlook the importance of keeping things as simple as possible
12:49:09 <beaky> do I have a disadvantage at learning Haskell as a beginner vs. someone who has years of experience developing in a language like C# or Java?
12:49:27 <MostAwesomeDude> beaky: Not particularly.
12:49:38 <strebe> beaky: I'd say slightly, but not as much as you might think
12:49:47 <nand`> strebe: the best way to find an elegant minimal solution to something is to post it on IRC and hold a contest to see how can come up with the prettiest solution
12:50:08 <Eduard_Munteanu> beaky: an advantage would be you don't have much to unlearn
12:50:18 <nand`> on a more serious note, I don't know of any such ‚Äòbeautiful code databases‚Äô, in particular because beauty is in the eye of the beholder - I would have to start one myself if my goal is to only include code I find pretty
12:50:33 <Eduard_Munteanu> But yeah, there are disadvantages too, not particularly tied to Haskell though.
12:50:45 <beaky> what does one unlearn if one is a Java monkey learning Haskell?
12:50:52 <nand`> Java
12:51:04 <hiptobecubic> I still argue it's an advantage not to know C/Java when you're starting out in haskell
12:51:07 <strebe> nand`: I did a small version of that yesterday, and am now using scanl and replicate and generally not abusing list comprehensions over several zipped lists quite so badly ;-)
12:51:49 <strebe> nand`: understandable. I'm slowly working my way through the xmonad source, but it's a bit above my level in places
12:52:12 <nand`> strebe: for that matter, the most recent library that I perceived as beautiful was byorgey's ‚Äòdiagrams‚Äô; simply because it makes working with diagrams compositionally so natural while remaining general and abstract enough to have a ton of useful backends
12:52:13 <hiptobecubic> working your way through meaning?
12:52:20 <strebe> beaky: a lot of algorithms and basic idioms that become as second nature as breathing, like for loops
12:52:32 <nand`> my favorite part is how it works for 3D diagrams and backends like OpenGL too
12:52:50 <byorgey> =D
12:53:00 <strebe> hiptobecubic: looking at it, and going "hm" a lot, and "oh, that's how that works!" on occasion
12:53:09 <hiptobecubic> strebe, beaky you can still for loops perfectly fine in haskell, you just don't use them to mutate
12:53:12 <strebe> nand`: awesome, I'll check it out
12:53:14 <hiptobecubic> strebe, ah
12:53:24 <nand`> ah; I haven't looked at xmonad's source but I liked how small it was, compared to some other popular tiling window managers of similar scope
12:53:43 <nand`> strebe: one warning though is that the type signatures and core design are probably not very newcomer friendly
12:54:04 <nand`> but if you just omit types, the examples are fairly understandable (hooray type inferencing)
12:55:30 <strebe> hiptobecubic: sure... but as someone with a background in imperative programming, and impure functional programming, a lot of algorithms I take for granted require mutation, and functional equivalents often require rethinking and a different set of data structures
12:55:43 <enkomax> Would i be correct to structure my datatypes like Point and Line inside a module? Is this correct?
12:56:00 <enkomax> Something like Primitives.Point
12:56:12 <nand`> trivially so, all data type definitions are inside modules :P
12:56:21 <hiptobecubic> strebe, yes, that is true. But many require very little modification as well
12:56:45 <hiptobecubic> strebe, loops which are actually just a reduction, for example. Or just mapping over an array
12:57:51 <strebe> hiptobecubic: have you ever seen the book "Purely functional data structures"? Plenty of things are trivial in both styles, but both the trivial and more complex are often _different_ between them, and some things simply can't be done with the same complexity functionally, and more are open research problems
12:58:16 <strebe> s/functionally/purely/, oops
12:58:30 <nand`> for me it seems to be the other way round; when I code in an imperative language I start designing algorithms functionally, then wonder when it stack overflows due to lack of tail call optimization
12:58:43 <twopoint718> Are there any BDD libraries/tools for Haskell? I found this but the link is broken: http://www.haskell.org/pipermail/haskell-cafe/2004-March/005883.html
12:58:48 <johnw> hspec
12:59:00 <johnw> @google hspec
12:59:05 <lambdabot> https://github.com/trystan/hspec
12:59:37 <strebe> nand`: sure, I tend to prefer doing algorithms functionally, but _sometimes_ not using mutable state comes at a cost, and it can be a slow process to rethink what a suitable replacement for, say, a mutable hashtable is for a particular purpose
12:59:46 <jfischoff> I want to test some code that loads a bunch of files. Is there a way to mock IO to test the functions in a pure setting?
12:59:51 <mkaito> howdy folks o/
13:00:08 <Eduard_Munteanu> mkaito: hi
13:00:11 <beaky> hello m8
13:00:49 <jfischoff> or should I make a BL.readFile and something that is passed in to my function?
13:00:49 <nand`> strebe: sure; I'm not that big on algorithms either way, I'll tend to use some existing library if at all possible. On that note, when mutability is the best solution there are tools like ‚ÄòST‚Äô
13:00:59 <nand`> which has mutable references, arrays, etc.
13:01:02 <acowley> So I'm trying to benchmark this silly linear algebra code. I try to boil down a really simple test, and start the process of Core diving‚Ä¶ only to discover that GHC had statically computed the dot product I was testing :/
13:01:30 <mkaito> let's see if I can learn some haskell gems by simply hanging out here and reading other people's question. has worked in the past :)
13:01:39 <strebe> nand`: I'm aware of that, but I'm trying to remap my brain into doing things purely functionally when it _is_ a reasonable option, rather than relying on the crutch of mutable state just because it's familiar, and that -is- a slow process :-)
13:01:55 <nand`> acowley: read its input at runtime? :P
13:02:06 <acowley> nand`: That's what I'm doing now
13:02:16 <acowley> hand`: I was just surprised it had done so much work
13:02:21 <nand`> strebe: fair enough, the more Haskell you read and write, the more you think in terms of Haskell
13:02:38 <nand`> there's no short cut to nirvana, unfortunately :(
13:03:09 <strebe> nand'`: agreed :-)
13:03:42 <strebe> acowley: http://ics.p.lodz.pl/~stolarek/blog/2012/10/code-benchmarking-in-haskell/ looked interesting when I stumbled across it the other day; I don't know if it would help
13:04:42 <acowley> that link is just giving me a .rss file
13:05:11 <acowley> I found the article
13:05:51 <strebe> ah, sorry about the link
13:06:45 <acowley> Well, I'm glad that article exists. It's a good resource.
13:07:01 <acowley> The variance in multiple benchmarking runs is frustrating.
13:07:28 <enkomax> what am i doing wrong here: http://pastebin.com/EDk86p3Z getting Not in scope: data constructor 'Point'
13:07:33 <mauke> The paste EDk86p3Z has been copied to http://hpaste.org/76840
13:07:45 <acowley> In any case, my core diving has been successful. The dot product is fully unpacked and unboxed. My problem is that the "slower" implementation actually runs just as quickly.
13:10:07 <liffon> What is a good way to make something (e.g. a game tick) happen at regular intervals?
13:10:15 <acowley> Hah, yeah. Sometimes GHC is wicked smart.
13:10:31 <byorgey> enkomax: Primitives only exports the type Point, and not its constructor
13:10:50 <byorgey> enkomax: change it to  module Primitives ( Point(..) ) where ...
13:10:58 <enkomax> got it
13:11:01 <enkomax> thank you
13:11:36 <enkomax> (..) exposes all constructors of the type?
13:11:54 <rwbarton> yes
13:12:15 <enkomax> Point(Point3) would only export Point3 ctor?
13:12:22 <rwbarton> yep
13:12:25 <enkomax> nice
13:12:51 <acowley> liffon: There are many ways to skin this cat. If your processing time is constant, you can just use threadDelay after you do your work. If the processing time is significant, you can have one thread that sets a semaphore at the desired frequency, and another that blocks on it. However, there are few if any guarantees that your thread will wake up exactly when you want it to. So‚Ä¶. horses for courses. What's your application?
13:14:30 <liffon> acowley: I'm trying to write a Tetris clone for learning. So no heavy processing in this case.
13:14:40 <typoclass> acowley: cats are adorabubble! none of them will be skinned on my watch
13:15:16 <beaky> So a monad is like a cartridge of a pure computation that you can inject into another cartridge?
13:15:34 <parcs`> > (1 + sqrt 5)/2
13:15:36 <lambdabot>   1.618033988749895
13:15:41 <acowley> typoclass: Sorry, I should update that idiom to the Internet age, "There are many ways to dress a cat."
13:15:50 <beaky> someday I will stumble upon the right analogy and finally grok monads
13:16:00 <acowley> a monad is a like a cat in a suit
13:16:01 <typoclass> s/dress/caption
13:16:05 <johnw> and then you'll only grok that monad, I'm afraid
13:16:20 <acowley> Caption: "I should get a bind."
13:16:34 <beaky> lol
13:16:54 <signalsea> @type [(*), (+), (-)]
13:16:56 <lambdabot> forall a. (Num a) => [a -> a -> a]
13:17:01 <beaky> what are monads in general?
13:17:05 <signalsea> ^ can someone explain that?
13:17:19 <johnw> beaky: it would require specific language to answer that question :)
13:17:35 <typoclass> @type (+)
13:17:36 <lambdabot> forall a. (Num a) => a -> a -> a
13:17:40 <signalsea> Oh
13:17:41 <signalsea> right
13:17:44 <strebe> beaky: http://www.haskell.org/haskellwiki/Monads_as_computation and http://www.haskell.org/haskellwiki/Monads_as_containers
13:17:45 <signalsea> dur
13:17:50 <signalsea> thanks typoclass
13:17:52 <typoclass> signalsea: the list becomes the same type as the elements
13:17:54 <beaky> so that 'a monad is a monoid in the category of endocuntors" is true?
13:18:01 <preyalone> What's your favorite Haskell regex library?
13:18:05 <strebe> endofunctors, yes
13:18:18 <johnw> yes, that is a general definition
13:18:19 <ion> preyalone: Parsec ;-)
13:18:26 <Eduard_Munteanu> Heh, that's some typo.
13:18:32 <strebe> that's a rather nice description, as long as you know enough category theory; otherwise it's a bit of a word salad
13:18:43 <johnw> you're probably more interested in what you can use Monads *for*
13:18:44 <beaky> yes
13:18:46 <johnw> which is a different question
13:19:04 <beaky> I have no idea what a monad is and what an endofunctor is :( But I kinda understand what a plain functor is
13:19:04 <johnw> you can use monads to sequence effectful computations
13:19:12 <preyalone> I just want to extract the programming language name from a resource URL string: http://dbpedia.org/resource/D_(programming_language).
13:19:18 <preyalone> I'm afraid of using overkill libs.
13:19:18 <johnw> all Haskell functors are endofunctors
13:19:29 <johnw> so you don't yet understand a plain functor :)
13:19:35 <beaky> :(
13:19:37 <rwbarton> johnw: For now!
13:19:44 <rwbarton> But, yes.
13:19:44 <johnw> rwbarton: oh, is that changing?
13:19:44 <beaky> I thought functors are stuff you can fmap into
13:19:51 <preyalone> I considered using pattern matching, but "http://debpedia.org/resource/" : name ++ "_(programming language)" doesnt work.
13:19:58 <Eduard_Munteanu> johnw: you can define general functors in Haskell.
13:19:58 <strebe> beaky: endofunctors are just functors that map a category to itself rather than another category
13:19:59 <johnw> beaky: endofunctors map m a -> m b
13:20:00 <rwbarton> well, probably not actually
13:20:07 <preyalone> Err,  "http://debpedia.org/resource/" : name : "_(programming language)" doesnt work.
13:20:07 <beaky> ah
13:20:09 <johnw> functors can map m a -> n b
13:20:12 <typoclass> > stripPrefix "lol" "locat" -- preyalone
13:20:13 <lambdabot>   Nothing
13:20:14 <rwbarton> no no
13:20:17 <typoclass> > stripPrefix "lol" "lolcat" -- preyalone
13:20:18 <lambdabot>   Just "cat"
13:20:18 <rwbarton> functors map Hask to Hask
13:20:26 <Eduard_Munteanu> Functors, even.
13:20:27 <preyalone> typoclass: and stripSuffix?
13:20:27 <rwbarton> er
13:20:29 <johnw> oh, that's right
13:20:37 <johnw> endofunctors map Hask to Hask
13:20:40 <rwbarton> endofunctors of Hask, aka Functors, map Hask to Hask
13:20:50 <johnw> functors can map any category to or from Hask
13:20:51 <typoclass> preyalone: yeah that's also available, though you don't need it for your url
13:20:56 <rwbarton> functors in general can map things to other things
13:21:17 <Ralith> :t (:)
13:21:19 <lambdabot> forall a. a -> [a] -> [a]
13:21:20 <Ralith> preyalone: ^
13:21:30 <johnw> rwbarton: so, functors in haskell are even more constrained than categorical endofunctors
13:21:33 <beaky> so all monads are endofunctors
13:21:40 <strebe> beaky: in _practice_, I find Cale's descriptions (the things I linked to) useful, while the category theory tends to take a while to sink in (but I like Awodey's book on it, if you do want to learn more)
13:21:41 <Eduard_Munteanu> I guess the only restriction is they have to be Hask-enriched.
13:21:52 <beaky> right
13:21:53 <johnw> Functor only goes from m a -> m b, not from Hask -> Hask
13:22:24 <johnw> all Haskell monads are endofunctors
13:22:53 <Eduard_Munteanu> johnw: fmap deals with the arrows, the type constructor deals with the objects.
13:22:57 <osfameron> enriched with vitamins and monads?
13:23:07 <strebe> beaky: read Cale's two articles, then play around with simple monads, starting with [], and it'll hopefully start making snse
13:23:09 <johnw> Eduard_Munteanu: I thought Haskell's Functor didn't map morphisms at all
13:23:21 <rwbarton> what is m??
13:23:22 <Eduard_Munteanu> Sure it does, that's fmap.
13:23:28 <johnw> fmap maps objects
13:23:33 <typoclass> beaky: i recommend that you just practice using monads and learn what you can do with them. you can study what they "really are" in some mathematical sense, but i feel that's like studying what an object in java "really is" in some philosophical sense. it may be a way to spend a rainy sunday, but i doubt it'll make you a better programmer
13:23:42 <johnw> doesn't it?
13:23:47 <johnw> m a -> m b
13:23:49 <rwbarton> your terminology is still a bit screwy
13:23:59 <johnw> ok, please set me straight
13:24:04 <rwbarton> a functor maps an object of Hask to another object of Hask
13:24:08 <plhk> hi, can someone help me with attoparsec? how do i match "abbb.." which is "some a" followed by "many b"?
13:24:18 <rwbarton> it also maps a morphism of Hask to another morphism of Hask
13:24:21 <Eduard_Munteanu> johnw: no, the type constructor maps objects
13:24:36 <strebe> beaky: basically, monads are as scary (or not) as you make them. On one end, you can get into some really heavy category theory, on the other hand you're dealing with a couple of functions as simple as map and id
13:24:56 <rwbarton> in Haskell the first part is just called "applying the type constructor" and the second part is called fmap
13:24:57 <typoclass> strebe++
13:25:01 <johnw> beaky: yes, Monads are not nearly as magical as they seem
13:25:21 <johnw> Eduard_Munteanu: oh yeah, because objects ar etypes
13:25:22 <iago> hi all, I would appreciate some help. I wrote a parser using parsec3 with Char as token type and taking advantage of the 'makeTokenParser' facility... I found that for large files (>5MB) the memory blows up even if I feed the parser with Text/ByteString. Profiling seems to point the use of the 'identifier' parser-combinator as the main cause, since everytime it's called it creates a new String... I'm thinking that the best way to proceed may be
13:25:22 <iago> write my lexer in Alex but I would like to know if someone has experienced the same problem and came out with a simple & clean solution within parsec
13:25:35 <rwbarton> (in math usually the same notation is used for both mappings. if f : X -> Y then Ff : FX -> FY)
13:25:41 <plat0> Is UArray a Functor?
13:25:56 <rwbarton> (but in Haskell you write if f :: X -> Y then fmap f :: f X -> f Y)
13:26:21 <n-dolio> Probably a bad choice of one of the names there.
13:26:28 <rwbarton> oh yeah
13:26:37 <rwbarton> fmap f :: F X -> F Y
13:28:22 <johnw> so, the [] functor maps a -> [a] by its type constructor, and a -> b to m a -> m b by fmap
13:28:41 <johnw> and it's an endofunctor because both a and [a] are in Hask
13:28:55 <johnw> s/m a -> m b/[a] -> [b]
13:28:59 <typoclass> plat0: UArray is a data structure defined in module Data.Array.Unboxed, which is offered by the "array" package. i have no idea if it can also be called a functor :-/ http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-Unboxed.html#t:UArray
13:29:00 <rwbarton> yes
13:29:09 <johnw> got, that is very clarifying, thank you
13:29:14 <johnw> my Awodey book is still in the mail
13:29:19 <beaky> right
13:30:36 <johnw> the [] monad is a monoid in the category of endofunctors (Hask -> Hask) because it...?
13:31:00 <johnw> knows how to compose a -> m b and b -> m c?
13:31:33 <johnw> (Hask -> Hask in this case, I meant to say)
13:31:59 <acowley> It's because there is ([].[]) a -> [] a
13:31:59 <beaky> why is [Char] the default string type rather than something like ByteString or Text? Aren't singly-linked lists of characters impractical?
13:32:01 <johnw> or because it can compose a -> [a] and [[a]] -> [a]?
13:32:22 <johnw> beaky: history
13:32:56 <byorgey> johnw: because there is a composition operation  join :: [[a]] -> [a]  and an identity for that operation,  return :: a -> [a]
13:33:02 <parcs`> is there a haskell library that supplies the gamma function?
13:33:17 <byorgey> johnw: to understand the precise sense in which that is a "monoid" takes some unpacking
13:33:18 <Eduard_Munteanu> You can define functors external to Hask, btw.
13:33:24 <johnw> also, while practicality for efficient programs was a goal for Haskell, i don't think it was such a driving goal that chosing Text made more sense.  String happens to fit very well in a List-oriented world
13:33:27 <byorgey> it's a generalized notion of monoid
13:33:41 <johnw> byorgey: ah, cool!  thank you
13:33:58 <typoclass> beaky: Text could be a possibility, but ByteString is a bunch of bytes. you need to decode it (with e.g. utf8) to turn it into Chars
13:33:59 <johnw> i'll keep that in the back of my head as I keep reading
13:34:29 <parcs`> oh, 'gamma' :)
13:35:03 <Eduard_Munteanu> For instance class (Category c1, Category c2) => Functor f c1 c2 | f -> c1 c2 where fmap :: c1 a b -> c2 (f a) (f b)
13:35:07 <Eduard_Munteanu> Or something like that.
13:35:42 <Eduard_Munteanu> (I guess you could take it even further, and enrich it and get rid of the -> in there)
13:36:53 <lispy> hello
13:37:14 <Eduard_Munteanu> Then that coincides with the normal functor for c1 = c2 = (->).
13:37:22 <Eduard_Munteanu> lispy: hi there
13:38:05 <lispy> how are things?
13:38:10 <Eduard_Munteanu> But for most purposes I guess treating Hask as Set does fine.
13:38:43 <preyalone> How do I convert Data.Text.Internal.Text to [Char]?
13:38:57 <johnw> beaky: part of the usefulness of monads is that you can sequence a series of monadic function calls (a >> b >> c) and there will be a "context" that is common throughout the chain of calls -- plus the calls occur in that same sequence; this allows you to model all kinds of useful behavior without bending over backwards with CPS notation or some such (as IO did before Monad)
13:39:19 <Eduard_Munteanu> Things are looking great, I'm just spewing random CT stuff. :D
13:39:32 <johnw> beaky: what the context *means*, though, is dependent on each Monad instance
13:39:32 <shachaf> preyalone: Data.Text.unpack
13:39:33 <Eduard_Munteanu> Typical #haskell day.
13:39:41 <shachaf> @hoogle Text -> [Char]
13:39:42 <lambdabot> Data.Text.Lazy.Internal showStructure :: Text -> String
13:39:42 <lambdabot> Data.Text.Internal showText :: Text -> String
13:39:42 <lambdabot> Data.Text.Lazy unpack :: Text -> String
13:39:50 <Ralith> johnw: whether there even *is* a context depends on the Monad instance :P
13:40:01 <beaky> right
13:40:13 <Ralith> but it permits one.
13:40:18 <johnw>  the simplest context is simply the presence of a Monad at all, such as with the Identity Monad
13:40:30 <Ralith> that's not a very useful definition of 'context'
13:40:32 <Eduard_Munteanu> Probably a better take on that is monads are computations with structured output.
13:40:35 <hiptobecubic> johnw, CPS notation?
13:40:49 <lispy> hiptobecubic: continuation passing style
13:40:52 <johnw> it is if you are using the Identity Monad to indicate that the value was in the Identity Monad
13:40:57 <hiptobecubic> lispy, ah
13:41:03 <Eduard_Munteanu> Now sure, you can implement state by making your output structured as a bunch of state modifiers.
13:41:05 <johnw> you can use that kind of context to model Perl's "taintedness" behavior
13:41:38 <Eduard_Munteanu> And (>>=) / join happen to combine things appropriately.
13:42:24 <Eduard_Munteanu> Anyways, if you're looking to understand monads, start with a few simple ones. E.g. look at Maybe.
13:42:29 <Eduard_Munteanu> @src Monad Maybe
13:42:29 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:42:37 <Eduard_Munteanu> @src Maybe Monad
13:42:37 <lambdabot> Source not found. Wrong!  You cheating scum!
13:42:39 <Eduard_Munteanu> Bah.
13:42:42 <johnw> what I mean by "context" in this case is that an Int isn't just an Int anymore, it's an M Int, where M can have any meaning you want -- and the presence of that M is the "context"
13:44:06 <johnw> sometimes, when two M Int's are combined, this has additive meaning, sometimes is has selective meaning, sometimes it has abortive meaning.  This is why you have to understand the behavior of each monad, rather than trying to understand every monad "in general"
13:45:34 <rwbarton> Data.ByteString.Lazy.Builder is new in ghc 7.6? is there somewhere I can get a ghc 7.4 version?
13:45:56 <johnw> the value of understanding monads in general is that you can write generic code using the monad combinators, and it will work out "right" for every specific monad that your code gets applied to
13:46:04 <hpaste> tac-tics pasted ‚ÄúThe same?‚Äù at http://hpaste.org/76841
13:46:58 <hpaste> tac-tics pasted ‚ÄúAre these the same?‚Äù at http://hpaste.org/76842
13:47:07 <tac> oo, it autoposts
13:47:17 <tac> Are the two definitions here the same thing?
13:47:42 <tac> the (so-called) existential quantification confuses me in the first definition
13:47:42 <rwbarton> no
13:47:43 <mcstar> not auto, you selected the channel
13:48:00 <rwbarton> because you forgot the argument to Answer in the second definition
13:48:02 <tac> (mcstar: it doesn't work in other channels. I thought the functionality was broken)
13:48:19 <tac> rwbarton: oops.
13:48:32 <rwbarton> other than that they are the same thing written in two different syntaxes, yes
13:48:35 <tac> That aside. The two are the same. Mostly, I'm concerned about translating that forall there
13:48:40 <tac> thank you
13:49:03 <beaky> what parts of APL has Haskell bin eenspired by?
13:49:10 <mcstar> tac: hpaste needs to be present on the channel ofc
13:49:25 <mcstar> hpaste: hi
13:49:33 <mcstar> bit dumber than lambdabot
13:49:46 <mcstar> or just bad mannered
13:50:19 <rwbarton> just shy
13:50:44 <Eduard_Munteanu> The pastebin.com -> hpaste.org copy bot is a bit more talkative :P
13:50:50 <tac> I have been using it most often in Agda, which, of course, Hpaste does not sit
13:51:06 <beaky> what is agda?
13:51:07 <tac> and you might consider it a bug that it lists channels it cannot paste to and has no qualms about that fact
13:51:26 <tac> beaky: Agda is a depedently-typed functional programming language / proof assistant
13:51:34 <Eduard_Munteanu> beaky: something... beyond Haskell :)
13:51:47 <beaky> so it's like Haskell++
13:52:14 <strebe> beaky: it's very academically cool, but doesn't have much software in it
13:52:38 <beaky> ah :(
13:52:56 <rwbarton> and more importantly it will not make your turing machine go faster
13:53:07 <strebe> I get the impression it's mainly a proof assistant still, but it's nifty
13:53:31 <mcstar> rwbarton: XD
13:53:32 <beaky> lol
13:53:33 <Eduard_Munteanu> Good thing this ain't Agda, otherwise we'd have universe-polymorphic indexed monad analogies and questions. :P
13:53:58 <strebe> * Topic for #agda is: Agda: is it a dependently-typed programming language? Is it a proof-assistant based on intuitionistic type theory? Ø\(∞_0)/Ø Dunno, lol.
13:54:08 <Shapeshifter> I'm reading the happstack crash course chapter on templates. This all seems very PHPish. Which of the many template languages has the least haskell code in it? I.e. I want the template to cover only the view and as little control as necessary.
13:54:31 <stepcut> heist
13:54:42 <tac> beaky: It's very Haskell-like in the syntax, but it feels very different. It's harder, but really fun too
13:54:44 <johnw> at least if we were programming in Agda, we could prove that we're programming in Agda
13:54:49 <stepcut> but, HSP is only superficially like PHP, in practice it is very unPHPish
13:55:36 * Eduard_Munteanu wishes there was a Haskell library you could use to build web apps without dealing with HTML at *all*
13:56:09 <Shapeshifter> Eduard_Munteanu: I'm not sure why that would make sense.
13:56:17 <c_wraith> Eduard_Munteanu: sure, just use JSON for all communications
13:56:19 <stepcut> Heist uses external .xml files and there is no control structures at all in them
13:56:21 <Shapeshifter> stepcut: thanks, I'll check out heist as well.
13:56:46 <Eduard_Munteanu> Shapeshifter: well, I kinda felt like building a web app, but dealing with HTML templating and what not makes me feel dirty :P
13:57:21 <Eduard_Munteanu> I just wish there was some functional toolkit-like (in the GTK sense) thingy for web stuff.
13:57:35 <stepcut> Shapeshifter: but, you could also just use self control and not stick control stuctures in your HSP templates :)
13:58:04 <plat0> Eduard_Munteanu: do you mean you don't want to touch Blaze either?
13:58:25 <stepcut> Shapeshifter: in any case, this is the section on heist, http://www.happstack.com/docs/crashcourse/Templates.html#helloheist
13:59:02 <Eduard_Munteanu> plat0: yeah, I don't care about looks at all.
13:59:19 <Eduard_Munteanu> (hence the GTK example)
13:59:52 <tac> I really ought to really learn Agda
13:59:55 <tac> or really learn Haskell
14:00:05 <tac> Instead of being mediocre at both :)
14:00:17 <acowley> Learn Haskell
14:00:24 <Ralith> compromise with idris!
14:00:30 <tac> Ralith: :)
14:00:38 <acowley> and as you bump into its limits, you'll be naturally motivated to check out what Agda can offer
14:00:55 <tac> acowley: I'm pretty familiar with the general idea of what Haskell sucks at
14:01:06 <tac> @faq Can Haskell prove its own consistency?
14:01:07 <lambdabot> The answer is: Yes! Haskell can do that.
14:01:09 <johnw> what does Haskell offer that Agda does not?
14:01:10 <tac> ^ that
14:01:13 <rwbarton> Eduard_Munteanu: I think Facebook (as in the company, not the site) provides some styling/CSS libraries that can make your web site not look like it is from 1995
14:01:16 <mcstar> idris elba?
14:01:39 <acowley> The limitations of Haskell are not at all obvious. Evidence: http://okmij.org/ftp/Haskell
14:01:40 <rwbarton> oh I guess that is not quite what you are looking for
14:01:55 <Eduard_Munteanu> rwbarton: I'm ok with 1995 looks, anything goes :)
14:02:17 <johnw> i want a library that makes my website look like it's from 1859
14:02:39 <Eduard_Munteanu> I just feel like building forms and tables and so on without touching HTML. :)
14:02:52 <rwbarton> can't you do that? assuming you mean "without touching the literal string representation of HTML"
14:03:08 <shachaf> rwbarton: Wasn't that Twitter?
14:03:15 <rwbarton> maybe
14:03:22 <rwbarton> that sounds equally plausible to me
14:03:29 <shachaf> Anyway, 1995 was the year!
14:03:31 <tac> acowley: They are obvious if you know about dependent types
14:03:45 <rwbarton> shachaf: do you remember what it is called?
14:03:50 <shachaf> rwbarton: Bootstrap?
14:03:53 <rwbarton> ah yeah
14:04:04 * shachaf is always pleased to find a completely unstyled HTML page.
14:04:07 <acowley> ‚Ä¶ I do not believe that Oleg's contributions can realistically be described as "obvious" to anybody on this planet
14:04:13 <Eduard_Munteanu> rwbarton: Haskell HTML combinators is still pretty much HTML. Something that comes close is GTK3's HTML backend, but I guess gtk2hs doesn't support it.
14:04:36 <shachaf> acowley: Everything is either impossible or trivial. It's a theorem.
14:04:40 <shachaf> (A trivial one, in fact.)
14:04:55 <strebe> acowley: they're certainly non-obvious to me
14:06:03 <rwbarton> I feel like a gtk html backend would not be a lot better than just dealing with html
14:06:10 <rwbarton> maybe that's just me though
14:06:43 <beaky> use SOAP
14:06:52 <n-dolio> shachaf: Doesn't sound constructive.
14:07:09 <Eduard_Munteanu> Well, manipulating GTK controls seems a bit more high-level to me.
14:07:28 <Eduard_Munteanu> rwbarton: actually, that's HTML5, and your app pretty much looks like a GTK app.
14:10:13 <Eduard_Munteanu> I'd poke an analogy to make my point... if GUI app developers were like their web counterparts, they'd all mess with X11 calls.
14:10:36 * Ralith shudders at the thought
14:11:10 <shachaf> Cale: When were we getting GHC 7.4 again?
14:11:11 <acowley> We need Win32 and MFC in the browser!
14:11:30 <tac> What I need is an actual reason to program real software in Haskell
14:11:43 <strebe> Eduard_Munteanu: yes, because they'd have no alternative horribly often
14:11:45 <johnw> tac: what do you use for your utility scripting?
14:11:48 <tac> Instead of consuming type theory like a fat man consumes potato chips.
14:11:52 <tac> johnw: python
14:11:55 <Eduard_Munteanu> Oh well, I guess it's .com's fault partly.
14:11:57 <johnw> tac: so, use Haskell instead
14:12:05 <kirindave> How do I convert between a bytestring and a Text and back again?
14:12:06 <johnw> that's how I started
14:12:17 <johnw> kirindave: Data.Text.Encoding
14:12:20 <shachaf> kirindave: By encoding and decoding.
14:12:23 <strebe> johnw, tac: that's the path I'm currently walking too
14:12:27 <tac> yeah
14:12:29 <johnw> @hoogle ByteString -> Text
14:12:29 <lambdabot> Data.Text.Encoding decodeASCII :: ByteString -> Text
14:12:29 <lambdabot> Data.Text.Lazy.Encoding decodeASCII :: ByteString -> Text
14:12:29 <lambdabot> Data.Text.Encoding decodeUtf16BE :: ByteString -> Text
14:12:35 <tac> That's basically how I learned Python, I think
14:12:38 <shachaf> kirindave: decodeASCII doesn't exist.
14:12:40 <kirindave> Ahh there it is.
14:12:42 <shachaf> Please don't use it.
14:12:57 <shachaf> If you use decodeASCII, you're a bad person.
14:13:00 <parcs`>  > print (pi :: Rounded TowardsZero 20) ==> 0.000000000931322574615587496216
14:13:02 <tac> The problem I find in haskell is the libraries are not as clearly organized as Python
14:13:05 <shachaf> Just use decodeUTF8 if you have UTF8
14:13:09 <johnw> shachaf: give 'em the frowny face, shachaf!
14:13:14 <tac> Python ships with more or less "good to use" standard libs
14:13:17 <johnw> it's decodeUtf8
14:13:30 <tac> In Haskell, you have to figure out what's good, production quality stuff versus experimental and research-grade stuff
14:13:30 <johnw> tac: so does cabal :)
14:13:34 <Ralith> isn't that what the haskell platform is for
14:13:47 <johnw> tac: it's not that hard, just ask here
14:13:50 <shachaf> johnw: Been using any lenses recently?
14:13:58 <tac> yeah
14:13:58 <johnw>  yes
14:14:06 <tac> The main issue is I just don't use it that much :)
14:14:09 <Eduard_Munteanu> Which package?
14:14:24 <rwbarton> I like that "decode ASCII"
14:14:27 <strebe> tac: hmm, I find hoogle goes a long way, and both platforms ship with a fair amount of batteries included and have large third-party collections that your quality point applies to
14:14:41 <shachaf> The frowny face is reserved for you personally, johnw. Surely you've noticed.
14:14:46 <johnw> haha
14:15:05 <MostAwesomeDude> tac: Let's be honest, most of Python's stdlib is crap.
14:15:12 <johnw> i had to apply my frowny lens to Haskell, to find the subset that shachaf approves of
14:15:30 <shachaf> Was it ‚àÖ?
14:15:40 <johnw> the operator is (}:()
14:15:43 <shachaf> (That would surely require a frowny traversal.)
14:16:32 <johnw> I'm reading Halmos' book on "Naive Set Theory" now, and I must say it's rather enjoyable
14:16:43 <shachaf> johnw: Oh, I remember that one.
14:16:46 <typoclass> i thought { } was reserved and couldn't be used in operators ... ?
14:16:59 <johnw> >:(
14:17:01 <strebe> One thing I'm really missing in haskell is an easy way to see how far along a computation is; debug.trace breaks referential transparency and makes code messy, and building anything like a ui that reports progress on a keypress also would as far a I can see
14:17:03 <johnw> :t (>:()
14:17:05 <lambdabot> parse error (possibly incorrect indentation)
14:17:08 <johnw> :t (>:|)
14:17:10 <lambdabot> Not in scope: `>:|'
14:17:21 <shachaf> @ty (‚òπ)
14:17:22 <typoclass> johnw: yeah, same for () and []
14:17:23 <lambdabot> parse error (possibly incorrect indentation)
14:17:25 <johnw> haha
14:17:30 <johnw> perfect!
14:17:43 <johnw> of course, I just define shachaf = (‚òπ)
14:17:54 <shachaf> shachaf = const (‚òπ)
14:17:59 <johnw> there you go
14:18:01 <johnw> lol
14:18:16 <johnw> @remember shachaf shachaf = const (‚òπ)
14:18:16 <lambdabot> It is forever etched in my memory.
14:18:35 <Eduard_Munteanu> @quote shachaf
14:18:35 <lambdabot> shachaf says: <Tekmo> Then you just compose them <shachaf> Uh-oh, Tekmo is going to >=> <Tekmo> using Kleisli composition
14:18:50 <shachaf> @quote Eduard_Munteanu
14:18:51 <lambdabot> Eduard_Munteanu says: [In response to "GHC can go jump out a window" and "GHC has already jumped out a window and flied and left you behind"] Yes, GHC even implements optimizations such as defenestrat
14:18:51 <lambdabot> ion.
14:18:58 <shachaf> ion: hi
14:19:07 <Eduard_Munteanu> Now that wasn't quite a frowny quote.
14:19:15 <shachaf> @quote johnw
14:19:16 <lambdabot> johnw says: but probably the other package is more "idiomatic". if by that you mean "uses mathematics to such a degree that most people walk away in consternation"
14:19:40 <ion> hachaf
14:19:47 <typoclass> ion: gesundheit
14:19:49 <ion> hambdabot
14:19:53 <ion> hypoclass
14:19:58 <johnw> shachaf: edwardk pronounces your name as if it were shakaf
14:20:17 <johnw> i've been saying shachaf with a "ch" as in "chin" sound
14:20:17 <shachaf> johnw: It's more like a voiceless uvular fricative than a 'k'.
14:20:24 * Eduard_Munteanu still isn't sure how to pronounce shachaf 
14:20:28 <johnw> you mean like german "ch"?
14:20:37 <shachaf> As in "Bach", more or less.
14:20:37 <Clint> there are two german ch's
14:20:40 <typoclass> johnw: yup
14:20:45 <johnw> uvular fricative, is that like Arabic "gh"?
14:20:45 <ion> bachaf
14:20:47 <Shapeshifter> There sure are a lot of web frameworks for haskell...
14:20:49 <shachaf> Why were you talking about me to edwardk?
14:20:54 <Eduard_Munteanu> Like in "half"?
14:21:02 <johnw> Client: oh yeah, ich and Bach
14:21:16 <Clint> like arabic "kh"
14:21:21 <johnw> shachaf: because you come up in all conversations
14:21:26 <shachaf> Eduard_Munteanu: As in https://en.wikipedia.org/wiki/Voiceless_uvular_fricative
14:21:28 <typoclass> johnw: ich is more to the front of the mouth
14:21:49 <johnw> ah, arabic "kh", ok
14:22:01 <shachaf> Arabic has two "kh"s, I think.
14:22:04 <Clint> haha
14:22:06 <johnw> does it?
14:22:11 <johnw> it has two "q"s
14:23:04 <shachaf> I don't know much about transliterating Arabic to English.
14:23:17 <johnw> q is qaf, gh is ghayn, kh is kheh
14:23:39 <johnw> q/gh are both gutteral, but gh is more akin to french "r"
14:23:57 <johnw> ŸÇ ÿ∫ ÿÆ
14:24:00 <typoclass> shachaf: fortunately, i'm an expert on this. let me transliterate an arabic text for you. "sausage sausage sausage, small sausage, sausage with dots on it, sausage sausage sausage wurst"
14:24:18 <geekosaur> *eyeroll*
14:24:36 <Eduard_Munteanu> typoclass: I thought you were the expert on kittyspeak :P
14:24:54 <lispy> I think we need a good lenses library in the platform (assuming the platform continues to operate the way it always has)
14:24:55 <shachaf> When all you have is an image caption tool, every language is kittyspeak.
14:24:56 <typoclass> Eduard_Munteanu: i am an expert on many things, largely the ones i make up
14:24:56 * mauke CAT FACE WITH WRY SMILE
14:25:10 <johnw> lispy: that's not "lens"?
14:25:23 <lispy> (an alternative idea I support, is to reduce the platform to just ghc/cabal/make, eg., the essentials for building most of hackage)
14:25:39 <shachaf> lispy: "lens" is good when you get used to it.
14:25:50 <lispy> I'm sure it is
14:26:08 <johnw> "lens" is rather awesome, actually
14:26:08 <lispy> I lack the experience/context to pick a lenses library for the HP
14:26:13 <lispy> Just noting that it should have one
14:26:16 <jeff_s1> Is there a simple way to format a large record printed by a Show instance?
14:26:23 <johnw> I've begun writing a "working man's" introduction
14:26:25 <lispy> jeff_s1: groom?
14:26:27 <Eduard_Munteanu> I'm not sure either, but I suppose edwardk's does.
14:26:34 <shachaf> lispy: Did you see edwardk's (unbiased, naturally) comparison of lens libraries?
14:26:34 <lispy> @hackage groom
14:26:34 <lambdabot> http://hackage.haskell.org/package/groom
14:26:35 <jeff_s1> lispy - thanks, I'll look at groom.
14:26:42 <typoclass> tangentially, karl pilkington on the chinese writing system: "it looks like somebody is trying out a ballpoint pen"
14:26:45 <lispy> shachaf: link please
14:26:58 <shachaf> @where lenses
14:26:58 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/
14:26:58 <lambdabot> lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation>
14:27:00 <shachaf> That last one.
14:27:22 * hackagebot factual-api 0.6.0 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.6.0 (RudigerLippert)
14:27:31 <Eduard_Munteanu> I wonder if you could abstract all those implementations somehow.
14:27:41 <lispy> shachaf: thanks
14:27:49 <johnw> shachaf: um, nothing on that last link refers to edwardk's *current* lens library
14:27:57 <shachaf> johnw: Incorrect.
14:28:04 <johnw> oh, you are right
14:28:18 <parcs`> @tell ekmett the 'rounded' library in its current state seems to be broken, ie it claims pi :: Rounded TowardsZero Double is equal to 0.0000000153376547 and so on
14:28:19 <lambdabot> Consider it noted.
14:28:27 <shachaf> parcs`: Try @tell edwardk
14:28:29 <__name__> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
14:28:29 <__name__> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
14:28:30 <__name__> .........................................................................................................................................................................................................................................................................................................................................................................................................................................................................
14:28:31 <johnw> i see the link now, buried at the bottom of the update
14:28:35 <__name__> ....................................................................................................................................................................................................................................................................................................................................
14:28:39 <__name__> i am terribly sorry
14:28:39 <shachaf> @where ops
14:28:39 --- mode: ChanServ set +o Saizan
14:28:40 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
14:28:41 <__name__> that was my cat
14:28:42 <shachaf> Oh.
14:28:48 <typoclass> awwww :-D
14:28:56 <johnw> your cat types just one letter?
14:28:58 <shachaf> Your cat?
14:28:59 <parcs`> blame the cat why don't ya
14:29:03 <shachaf> I guess __name__ means "cat /dev/dots"
14:29:04 <acowley> tiny feet
14:29:04 <typoclass> __name__: tell her MEOW from us! :-)
14:29:10 <parcs`> shachaf: oh right..
14:29:11 <lispy> __name__: if this channel was a roguelike your cat would have just gotten you killed :)
14:29:17 <parcs`> @tell edwardk the 'rounded' library in its current state seems to be broken, ie it claims pi :: Rounded TowardsZero Double is equal to 0.0000000153376547 and so on
14:29:17 <lambdabot> Consider it noted.
14:29:19 <ion> What a great way to flood and not get kicked.
14:29:30 <__name__> he stepped on my dot key
14:29:35 <johnw> "It was my cat"
14:29:42 --- mode: Saizan set -o Saizan
14:30:02 <__name__> and apparently x-chat break long lines into separate messages
14:30:08 <rogerthealien> i'm trying to write an interpreter for a small imperative language, and I'm having some troubles understanding how IO works. I get that once you taint something with IO, it stays like that, but then, do I have to make all my 'functions' work on IO types to accommodate this?
14:30:11 <__name__> *breaks, even
14:30:22 <parcs`> __name__: that's because irc imposes a limit on message length
14:30:23 <shachaf> rogerthealien: Nope, you don't "taint" anything.
14:30:25 <Eduard_Munteanu> You'd think he has a leopard kitty given all those dots :P
14:30:28 <Dodek> hey, how can i obtain bits from Float? i mean, something like C's float x = 3.2; int i = *(int*)&x;
14:30:43 <shachaf> rogerthealien: It's a common misconception that "IO String" is a "tainted" String, but it's not.
14:30:56 <jakubmal> (Monad mA, Monad mB) -> mA a -> mB a     possible or I'm doing something wrong?
14:31:14 <typoclass> __name__: please refer to this topical lambdacat http://spl.smugmug.com/Humor/Lambdacats/i-2zgRG5v/0/O/1c199077-f3db-47e7-9bc4.jpg
14:31:17 <shachaf> jakubmal: The latter.
14:31:29 <shachaf> jakubmal: (How would you write IO a -> Identity a?)
14:31:30 <Saizan> jakubmal: it can be done for specific monads but not in general
14:31:51 <jakubmal> ok, I have snap as web framework and mongo driver
14:32:01 <jakubmal> snap has its own monad, and mongo driver uses IO
14:32:13 <Cale> rogerthealien: The idea is this: values of type IO t describe actions which could be carried out in order to produce a value of type t
14:32:19 <shachaf> Maybe #snapframework would know. :-)
14:32:48 <__name__> typoclass, :)
14:32:48 <stepcut> jakubmal: liftIO
14:32:49 <typoclass> rogerthealien: the usual approach is to have a small number of functions in IO that do the actual reading from the outside world, and which then use pure functions to process things (lines from stdin, messages from the network, etc.)
14:32:50 <jakubmal> so when I query the db I get IO () and to return Text as http response I have to make Snap () where Snap is monad
14:32:53 <shachaf> rogerthealien: getLine :: IO String contains a String in the same way that The Goose That Laid The Golden Eggs contained golden eggs
14:33:01 <stepcut> jakubmal: from Control.Monad.Trans
14:33:14 <Eduard_Munteanu> @quote shachaf.*bin/ls
14:33:14 <lambdabot> No quotes match. :(
14:33:19 <Eduard_Munteanu> @quote shachaf.*contains
14:33:19 <lambdabot> No quotes match. I've seen penguins that can type better than that.
14:33:26 <shachaf> Eduard_Munteanu: Just a ' ', not .*
14:33:32 <Eduard_Munteanu> @quote shachaf contains
14:33:33 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
14:33:41 <Cale> rogerthealien: Here's my little intro: http://www.haskell.org/haskellwiki/Introduction_to_IO
14:33:48 <typoclass> rogerthealien: so the standard advice is to keep the number of functions in IO low
14:33:50 <Saizan> shachaf: doesn't a goose contain eggs before laying them?
14:34:11 <jakubmal> oh, that liftIO looks ok
14:34:12 <shachaf> Saizan: I don't think classical geese do.
14:34:20 <shachaf> Maybe constructive geese.
14:34:36 <jakubmal> stepcut: I'll try that in a second
14:34:57 <rwbarton> DNA Goose -> Goose
14:35:24 <Eduard_Munteanu> unsafeLayEgg?
14:35:29 <parcs`> Dodek: you would have to use the Foreign module, i think
14:35:48 <parcs`> Dodek: something like 'new >=> peek . castPtr :: (Storable a, Storable b) => a -> IO b'
14:35:49 <sykora> I'm having a prettyprint issue, does anyone know how I can tell `fsep` to successively indent all overflow lines?
14:35:56 <Dodek> parcs`: thanks
14:36:13 <Dodek> parcs`: can't you do it with GHC.Prim, or something like this?
14:36:19 <rogerthealien> shachaf, but then if getLine :: IO String contains a String, can i pass an IO String to something of type: String -> a?
14:36:27 <rogerthealien> thanks, btw
14:36:41 <Saizan> shachaf: it's not like it materalizes itself while it gets out
14:36:49 <mcstar> typoclass: hilarious site
14:36:56 <shachaf> rogerthealien: If you have something of the type String -> IO a, you can combine it with the IO String.
14:37:14 <shachaf> rogerthealien: By the way, my point was that getLine :: IO String *doesn't* contain a String.
14:37:23 <Saizan> rogerthealien: the idea is that rather than taking values out of IO you push functions in
14:37:27 <shachaf> rogerthealien: It's a program that contains instructions on how to get a String, if you run it.
14:38:07 <shachaf> You can turn that program into a "bigger program" that takes the String and does something with it.
14:38:12 <Saizan> rogerthealien: e.g. if you have (f :: String -> a) you can build a "liftM f getLine :: IO a"
14:38:37 <shachaf> Hmm, GHC has a function called "unsafeSingSymbol"
14:39:29 <ion> unsafeFormAcappellaBand
14:39:36 <beaky> I like Text
14:39:59 <jakubmal> stepcut: Superb! That worked ;)
14:41:31 <parcs`> Dodek: i'm not sure
14:41:33 <rogerthealien> Saizan: do you know of any examples that turn the program into a bigger program? I can't seem to find anything
14:42:01 <shachaf> rogerthealien: You should really read an introduction to IO.
14:42:05 <shachaf> Did you see the FAQ?
14:42:07 <shachaf> @where faq
14:42:08 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
14:43:31 <jakubmal> in general the problem was, what if you had to deal with different monads
14:43:49 <jakubmal> if you only deal with IO/Maybe/Either it's easy to combine them
14:43:59 <jakubmal> adn even nest
14:44:23 <jakubmal> what startled me was that there were 2 totally different monads monads
14:48:51 <beaky> so in Haskell, a monad is simply a type that implements an API that specifies (>>=) and return?
14:48:57 <beaky> ]=
14:49:02 <hpc> yep
14:49:16 <hpc> and that implementation follows a few laws
14:50:17 <c_wraith> Which makes it a very broadly-applicable abstraction
14:50:19 <beaky> like De Morgan's laws?
14:50:35 <hiptobecubic> from logic?
14:50:47 <c_wraith> So the many useful things you can write using just the Monad abstraction work with all types that implement it.
14:50:57 <beaky> so far I've only used monads in conjunction with do for things like printing "Hello, World!" or getting user input
14:51:10 <hiptobecubic> beaky, you've used lists and maybe, probably
14:51:19 <beaky> I used lists a lot
14:51:26 * Shapeshifter just learned about literate programming in haskell O_O
14:51:35 <beaky> I believe every problem in CS can be solved with a list
14:52:00 <Shapeshifter> this is brilliant. I can read the tutorial and modify the code at the very same time. How clever.
14:52:03 <mcstar> not a surprise after you wrote a turing tape machine
14:52:13 * PureSkillPureMic proceeds to ennumerate all solutions to every problem ever and encode that with lists containing only zeroes of that length.
14:52:16 <Iceland_jack> Doesn't mean it should...
14:53:06 <beaky> I should generalize my turing machine to take any type of turing machine as input so that it can generate all possible outputs. A "universal" turing machine
14:53:43 <lispy> beaky: and further modify it so it can tell when an input turing machine would halt?
14:54:07 <beaky> ah that's harder to do
14:54:12 <lispy> A little bit yeah
14:54:40 <aninhumer> It is the hardest hardness
14:54:47 <Zfolfr> Nahh, it' easy, my C++ parser does that all the time.
14:54:52 <d-snp> can't be much harder than running a salesroute..
14:56:43 <Tekmo> I have a question about garbage collection
14:56:51 <tromp> a universal lambda calculus machine is easier to implement
14:57:22 <beaky> tromp: that gives me an idea: I will implement the lambda calculus in haskell!
14:57:28 <Tekmo> So I have a generator of a bunch of values that I'm storing in a vector
14:57:43 <Tekmo> I'm resizing the vector by doubling since I don't know the number of values ahead of time
14:58:04 <tromp> in fact one recen tly won the ioccc :-)
14:58:18 <Tekmo> This is a large vector that takes about 4 GB when it is finally complete
14:58:23 <beaky> what is the lambda calculus?
14:58:30 <d-snp> hey beaky if you make some pretty code, could you put it on github or something similar so we can admire it?
14:58:48 <d-snp> I like looking at pretty code, and I've not been introduced to lambda calculus properly yet :)
14:58:50 <beaky> I don't have a github :(
14:58:54 <Tekmo> So I notice that as the program goes on, the garbage collection takes an increasingly long amount of time
14:58:57 <tromp> lambda calculus is haskell without the types and the sugar
14:59:01 <d-snp> nonsense, every programmer has a github :P
14:59:02 <hiptobecubic> beaky, it's free.
14:59:06 <hiptobecubic> get one
14:59:07 <Tekmo> At the beginning of the program run it's less than 10% of execution time
14:59:09 <hiptobecubic> it's fun
14:59:19 <Tekmo> But if I let it go all the way then it rises to over 90% of execution time
14:59:27 <beaky> alright
14:59:40 <Tekmo> So my question is what is the source of this gradual increase of the proportion of garbage collection?
14:59:42 <d-snp> I sincerely recommend having a github :)
14:59:55 <beaky> i'll go make a free github account and put all my projects in it
14:59:56 <d-snp> Tekmo: perhaps you're accumulating thunks?
15:00:00 <hiptobecubic> beaky, yes.
15:00:08 <d-snp> beaky: that's the spirit :) I did too
15:00:09 <hiptobecubic> beaky, it also gives you a lot of code to play with
15:00:13 <Tekmo> d-snp: That's what I thought, but I am certain that the elements going into the vector are fully evaluated
15:00:31 <jix> Tekmo: unless the vector is unboxed I can imagine that just the size of the vector can slow down garbage collection a lot
15:00:48 <Tekmo> The vector is boxed
15:01:08 <Tekmo> and I cannot unbox it
15:01:22 <Tekmo> One of the fields of the element going inside is another vector
15:01:28 <d-snp> why is the vector not just a list?
15:01:36 <thoughtpolice> Tekmo: have you tried compiling with profiling and running on a smaller data set? that should at least tell you which data constructors are using up memory
15:01:45 <Tekmo> Yeah, I have
15:01:55 <Tekmo> All the memory is associated with the vector
15:02:13 <acowley> Perhaps the GC treats large arrays differently than small objects
15:02:27 <thoughtpolice> i know that vector at least uses pinned byte arrays, which are handled differently
15:02:33 <acowley> yeah
15:03:00 <jix> thoughtpolice: even the boxed vector?
15:03:07 <Tekmo> Here, let me quickly redo the profiling so I can get the exact contributor
15:03:08 <acowley> But you may need to ask on cafe in the hopes that someone who's really looked at the GC can offer guidance
15:03:14 <Tekmo> It's been over a week since I last did it
15:05:32 <acowley> You should write a custom Vector that uses a ByteArray# backing and unsafeCoerce the pointers out of it
15:05:52 <Tekmo> Also, the reason I don't use lists is that I need O(1) indexing into this vector
15:05:52 <acowley> by "should" I probably meant to say, "should not"
15:06:11 <jix> Tekmo: you could use unboxed vectors if you don't store subvectors but concatenate all subvectors into a second unboxed vector and store indices into that vector instead... but that is not very elegant so I'd identify the exact cause before going down that route
15:06:31 <acowley> Boxed arrays aren't pinned
15:07:14 <acowley> I'm back to my unsafeCoerced ByteArray# of pointers plan
15:07:28 <Tekmo> So how does pinned vs. unpinned change things?
15:08:03 <acowley> There's two parts: The GC doesn't scan ByteArray#s for pointers, and if the array is pinned, the GC won't move it
15:08:17 <Tekmo> So ~100% of the space belongs to ARR_WORDS
15:08:46 <tac> Is there any particular reason why you have to specify the number of cores in haskell when you start a program?
15:08:48 <ezyang> What is the "alternative layout rule"?
15:08:50 <jix> Tekmo: so if you use unboxed vectors the GC should 1) never copy that data around and 2) never scan it for pointers to follow
15:09:03 <tac> Is dynamic processor usage hard to implement?
15:09:05 <acowley> Tekmo: how ugly would following jix's advice be?
15:09:20 <Tekmo> So do you think this slow quadratic buildup is because of scanning a successively larger vector for pointers?
15:09:30 <acowley> tac: you can give it the -N option at compile time so it always uses all available cores
15:10:01 <Tekmo> For example, when I don't write to the vector at all, then the performance goes back to beign linear
15:10:08 <acowley> Tekmo: Whether it's scanning or moving, you'd probably rather the whole thing be more opaque to the GC
15:10:18 <acowley> Well, that's actually not a sure thing at all
15:10:31 <Tekmo> If I just allocate the vector and double it without writing values, then the garbage collector performance goes away
15:11:00 <acowley> You're using Data.Vector.Mutable, right?
15:11:01 <Tekmo> *garbage collector overhead
15:11:02 <Tekmo> Yes
15:11:15 <tac> acowley: What does the -N flag actually do? At the "C" level of things?
15:11:18 <Tekmo> I use grow in powers of 2
15:11:22 <Tekmo> and write to add elements
15:11:31 <jix> Tekmo: I'm just guessing now but: if you don't write values you aren't allocating many values so it might be just the GC not running that often?
15:11:53 <absence> i see there's a 110 mb ghc 7.6.1 installer for win64. how does that work compared to haskell platform? does it have cabal and stuff so i can run "cabal install package" like in hp, or is there a lot of things that has to be set up manually first?
15:12:01 <Tekmo> jix: But what I'm wondering is why it gets progressively worse.
15:12:21 <merijn> Best way to represent a fixed size grid is an array indexed by (Int, Int), I guess?
15:12:22 <jix> Tekmo: it doesn't do that at all without writing values?
15:12:32 <Tekmo> jix: Correct
15:12:53 <acowley> tac: I imagine it's system dependent. See http://stackoverflow.com/questions/150355/programmatically-find-the-number-of-cores-on-a-machine
15:12:58 <Tekmo> jix: If I just evaluate the values going in, but don't write them, then the garbage collector overhead disappears
15:13:06 <jix> and it can't be that without writing values the constant factor before the quadratic term is just a lot smaller so it gets swallowed by some other constant overhead?
15:13:12 <tac> acowley: that makes sense
15:13:53 <Tekmo> jix: I don't see how writing the values changes the constant factor
15:14:12 <jix> Tekmo: yeah it shouldn't when you force evaluation even without writing
15:14:23 <jix> I was assuming that you don't evaluate when you don't write them
15:15:05 <jix> I'm not sure whether ghc performs those optimizations but many GCed langauges avoid allocation from the heap if they can detect the scope of an object statically... if you don't write it to an array this could be the case
15:15:35 <Tekmo> Also, unboxing the internal vector will be difficult, because it's actually 3 nested vectors
15:15:39 <Tekmo> not including this one
15:15:58 <merijn> Is there a way to use Data.Array.array but set all elements not specified in the association list to a default value?
15:16:20 <acowley> I can't find where writing into the array would inherently affect GC
15:16:21 <Tekmo> Although, I could just write an index translation function
15:16:37 <acowley> I would guess the optimizer is just more successful when you don't write
15:16:46 <Tekmo> Here, let me try something
15:16:53 <Tekmo> I will try writing undefineds in and see what happens
15:17:55 <jix> Tekmo: hmm I think if you don't write the values to the array they will just be collected by a minor GC... causing less pressure to do a major GC
15:18:02 <acowley> The problem with investigating this is that you get down to writeArray# which is a built-in and so undebuggable from the outside
15:18:21 <jix> Tekmo: maybe threadscope could also help in analyzing this
15:18:43 <Tekmo> What events do I look for in threadscope?
15:19:03 <acowley> One other note is that there is often something to be gained by changing runtime GC parameters in these cases
15:19:15 <Tekmo> Also, writing undefineds also gives no garbage collection overhead
15:19:15 <jix> Tekmo: I haven't used it myself but you should be able to see when minor and major collections are triggered
15:19:28 <Tekmo> acowley: Yeah, I tried that
15:19:37 <Tekmo> acowley: I get a constant factor speed up, but still the progressive slowdown
15:20:03 <Tekmo> acowley: This is a computer with 10 MB of cache and 96 GB of RAM
15:20:05 <acowley> How big are the vectors you're nesting?
15:20:11 <Tekmo> Not very big
15:20:14 <jix> Tekmo: but when you write undefineds your heap doesn't grow as fast does it?
15:20:28 <Tekmo> jix: Let me check
15:20:39 <Tekmo> Well, it shouldn't grow at all
15:20:48 <Tekmo> Because the values in that vector are what contribute to the heap
15:20:58 <Tekmo> If I don't write them, I expect them to be garbage collected immediately
15:21:13 <jix> exactly, and I'd say it's just that major GC time is linear in heap size
15:21:26 <Tekmo> So you think that's what contributes to the progressive slowdown?
15:21:35 <Tekmo> Except, there's one issue
15:21:44 <Tekmo> Even in long running versions
15:21:51 <Tekmo> there are only 10s of major garbage collections
15:22:06 <Tekmo> And I have it outputting numeric progress
15:22:12 <Tekmo> so I can see garbage collection stutters if any
15:22:23 <Tekmo> and there are no huge garbage collection stutters
15:22:34 <Tekmo> also -sstderr only reports maximum stutter of like 100 ms
15:22:42 <Tekmo> in a run of over 30 minutes
15:23:10 <Tekmo> Also, -sstderr reports that the youngest generation collection is what accounts for all the overhead
15:24:30 <jix> Tekmo: when you write undefines to the arrays... you also copy them on resizing, right?
15:24:36 <Tekmo> jix: yes
15:24:46 <Tekmo> I mean
15:24:49 <Tekmo> I use "grow"
15:24:57 <Tekmo> which I believe does the copying for you
15:25:36 <jix> I'm out of ideas then
15:25:41 <merijn> :t union
15:25:43 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
15:25:47 <Tekmo> Alright.  Thanks for the help.  I appreciate it
15:26:25 * copumpkin moos
15:26:32 <beaky> > range (0, 10)
15:26:33 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10]
15:26:47 <merijn> Bah, am I seriously the first person to want array initialisation with a default element? :<
15:26:47 <beaky> it's almost like python's range :D
15:26:58 <hiptobecubic> beaky, inclusive though
15:27:02 <beaky> right
15:27:05 <copumpkin> merijn: Vector.replicate ?
15:27:29 <rwbarton> or listArray bds $ repeat x
15:27:41 <c_wraith> merijn: can't you just initialize it to the default element, then do a multiple update?
15:28:18 <merijn> :t listArray
15:28:20 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
15:28:20 <acowley> I guess the answer to the question is, "No."
15:28:37 <merijn> c_wraith: Yeah, I didn't know about listArray, though
15:29:04 <merijn> :t array
15:29:06 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
15:29:16 <copumpkin> :t listArray
15:29:18 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
15:29:34 <merijn> Still, I would've preferred "array :: (Ix i) => (i, i) -> e -> [(i, e)] -> Array i e"
15:29:37 <copumpkin> :t (. replicate) . listArray
15:29:39 <lambdabot>     Couldn't match expected type `a -> [a]' against inferred type `[e]'
15:29:39 <lambdabot>       Expected type: (i, i) -> (a -> [a]) -> b
15:29:39 <lambdabot>       Inferred type: (i, i) -> [e] -> Array i e
15:29:41 <copumpkin> gah
15:30:20 <copumpkin> merijn: why are you using arrays anyway? use Vector :P
15:30:25 <copumpkin> arrays have basically no API
15:30:29 <Tekmo> Yes, use vector
15:30:35 <merijn> copumpkin: Vector seems unsuitable for matrices
15:30:38 <copumpkin> they give you the primitives and no convenience functions
15:30:40 <copumpkin> how so?
15:30:46 <Tekmo> Use hmatrix for matrices
15:30:50 <hiptobecubic> beaky, this is what i was talking about earlier
15:30:51 <merijn> I want (i, i) as index
15:30:54 <copumpkin> or REPA if you want to write your stuff yourself
15:30:59 <lispy> hmatrix has nice matrix operations (but it's hard to build on windows and it's GPL)
15:31:05 <copumpkin> REPA will let you get multidimensional indices
15:31:10 <copumpkin> and will represent them efficiently
15:31:14 <copumpkin> just ignore the parallel stuff
15:31:31 <merijn> lispy: I don't want matrix operations, though
15:31:47 <merijn> I want an X by Y grid to represent a game board
15:31:48 <beaky> ah
15:31:57 <nyc> copumpkin: Tell me more about repa vs. hmatrix
15:31:57 <hiptobecubic> I compared some simple unboxed vector stuff against hmatrix and hmatrix *smoked* it
15:32:11 <copumpkin> nyc: hmatrix is just a binding to BLAS/LAPACK/GSL
15:32:12 <beaky> so Vector is all the goodness of Array, with the convenience of List?
15:32:14 <Tekmo> Well, hmatrix is basically a thin layer over LAPACK
15:32:19 <merijn> hiptobecubic: For numerics operations, presumably
15:32:19 <hiptobecubic> hmatrix is basically just some library calls
15:32:19 <linduxed> if i've got a list of strings, what would the best way be to find the longest string?
15:32:22 <Tekmo> I'd expect it to always win for numerical computations
15:32:23 <rwbarton> vector is black magic through and through
15:32:28 <copumpkin> nyc: REPA is built on top of vector and is all pure haskell, and uses pure haskell parallel annotations
15:32:41 <rwbarton> i could never wrap my head around it and always found myself digging through the source of internal modules to figure out wtf it was doing
15:32:48 <lispy> hmatrix isn't _just_ a thin wrapper. It's a wrapper but it's thicker than you might guess.
15:32:50 <Tekmo> Yeah, vector is very opaque
15:32:52 <linduxed> my thought was to maybe have foldr go through it and put the longest word into the accumulator
15:32:52 <merijn> But all the numeric matrix/vector stuff is completely useless to my usecase >.>
15:32:52 <nyc> copumpkin: I'm probably more concerned with API's vs. performance.
15:33:00 <Tekmo> And vector's source code is very hard to navigate
15:33:04 <linduxed> but i'm thinking that there must be an easier way
15:33:09 <copumpkin> nyc: hmatrix will be as fast as any native LAPACK code
15:33:13 <copumpkin> since it is that
15:33:25 <copumpkin> REPA is more flexible, since it's polymorphic, and has a lot of higher-order combinators
15:33:33 <merijn> All I want is efficient indexing (like O(1), preferably) and efficient update
15:33:36 <copumpkin> you can't do that very well with a C binding
15:33:40 <merijn> Everything else is useless to me
15:33:41 <enkomax> so if I have deriving (Eq) on my custom data type, how is comparison logic derived?
15:33:43 <hiptobecubic> repa is nice to use, yes
15:33:43 <lispy> hiptobecubic: I was able to write some fixed dimensional code that was faster than hmatrix.
15:33:49 <nyc> copumpkin: For me more of the pain is building the matrices and vague asymptotics.
15:33:51 <Tekmo> Vector is basically arrays with length annotations, stream fusion, and a large standard library
15:33:51 <rwbarton> merijn: sounds like you just want Array
15:33:52 <rwbarton> imo
15:33:53 <lispy> hiptobecubic: At least for 3x3 and 4x4 inverses
15:33:56 <merijn> enkomax: Constructors are compared and any arguments are compared
15:34:03 <copumpkin> nyc: neither of them do sparse matrices at all, if you want that
15:34:04 <merijn> rwbarton: Isn't that where I started ;)
15:34:06 <rwbarton> yes
15:34:17 <nyc> copumpkin: That would be where the asymptotics matter, yes.
15:34:17 <rwbarton> i recommend you stay there :)
15:34:18 <enkomax> merijn: and values too?
15:34:45 <merijn> enkomax: Basically, deriving Eq requires all parametric types to be Eq to and it will then recursively compare those. For example:
15:34:52 <copumpkin> nyc: I don't think there's anything doing sparse matrices, although there were some noises made about using DPH to do them, since it doesn't require regular shapes
15:34:54 <enkomax> ok got it
15:35:00 <enkomax> recursive comparison makes sense
15:35:21 <merijn> enkomax: "data Foo a b = Foo a | Bar b" is Eq if a and b are Eq and it will just pattern match your constructors and compare the arguments
15:35:36 <enkomax> makes sense
15:35:53 <lispy> structural equality
15:35:59 <nyc> copumpkin: The construction pains are centered very much around sparse matrices, e.g. tridiagonal with border sorts of commands, and then efficiency is more about exploiting that than LAPACK/etc. (wasn't there a SPARSEPACK?).
15:36:11 <copumpkin> ah
15:36:17 <copumpkin> then you'd probably need a dedicated library
15:36:21 <copumpkin> which doesn't exist yet :)
15:36:30 <copumpkin> (to the best of my knowledge)
15:36:36 <enkomax> thanks merijn
15:36:37 <merijn> enkomax: Same for Read, Show, Ord and Enum derivations
15:36:49 <enkomax> yep, figured
15:37:25 <acowley> I spent a couple months trying to beat ARPACK for sparse matrices once. It was not a good use of my time.
15:37:34 <Tekmo> lol
15:37:36 <hiptobecubic> indeed nont
15:37:46 <hiptobecubic> not*.   Should have been contributing to instead :)
15:38:02 <rwbarton> if you can't beat 'em, write a Haskell binding to 'em
15:38:39 <copumpkin> I should finish that MPFR crap :P
15:38:43 <copumpkin> work on it goes in bursts
15:38:53 <acowley> Bindings are actually really hard
15:39:06 <acowley> Matlab's ARPACK bindings are thousands of lines of nonsense
15:39:22 <acowley> so many heuristics as it tries to guess how to set various parameters
15:39:38 <Tekmo> acowley: You can always do a completely raw binding
15:39:44 <acowley> The kicker is that, after all the ugliness, it has *awesome* performance
15:39:52 <acowley> I did that
15:39:55 <acowley> but it was pointless
15:39:57 <copumpkin> the MPFR bindings are doubly ugly
15:40:00 <acowley> well not to Haskell
15:42:06 <acowley> You can never win with these things. I just wrote a nonlinear optimizer in Haskell for use in a project, and was really proud of the simplicity of the API. Then, as I tried to eke out better performance for specific problems, the interface sprouted a multitude of knobs.
15:42:40 <beaky> are case-of lists optimized to jump-tables?
15:43:02 <acowley> depends on the size
15:43:11 <shachaf> "it's not that simple"
15:43:29 <shachaf> But you can definitely expect jumps. :-)
15:45:50 <beaky> Should I prefer passing data over passing functions?
15:46:06 <shachaf> Functions are data.
15:46:18 <seydar> is anyone here finnish? i need help translating something
15:46:30 <shachaf> Everyone on IRC is Finnish.
15:46:50 <seydar> what does tl mean as in "1/4 tl hiivaa". this is in a recipe
15:46:56 <Tekmo> beaky: Pass data when you need it to be serializable
15:46:56 <hiptobecubic> seydar, i have access to one
15:47:04 <typoclass> seydar: teespoon?
15:47:05 <Tekmo> beaky: Pass functions if it's easier for the user to use
15:47:08 <typoclass> *tea
15:47:16 <typoclass> beaky: either one is fine. whatever is more convenient in your situation
15:47:17 <seydar> typoclass: right, it's on that level, but what is it exactly
15:47:32 <shachaf> teralitre?
15:47:33 <typoclass> seydar: Teel√∂ffel :-)
15:47:37 <hiptobecubic> 1/4 teaspoons yeast he says
15:47:41 <beaky> what does serializabe mean
15:47:50 <beaky> serealizable*
15:47:53 <seydar> hiptobecubic: can you ask him what the full finnish word is?
15:48:00 <Tekmo> beaky: You can write it to disk, for example
15:48:17 <Tekmo> beaky: Specifically, it means you can translate it into binary (or, less efficiently, text)
15:48:26 <hiptobecubic> Teelusikallinen
15:48:37 <seydar> huh. interesting. thank him for me, hiptobecubic
15:48:55 <beaky> ah
15:49:24 <typoclass> beaky: a data structure that can be turned into a string (for writing to disk or whatever). famously, functions in haskell are not serializable, while all the stuff that has a Show instance is
15:50:15 <beaky> ah
15:50:22 <beaky> wish I can show my functions :(
15:50:47 <shachaf> You can probably show your functions in other languages.
15:51:01 <shachaf> Try another language, report back to us later.
15:51:07 <beaky> in Python, yeah
15:51:22 <Cale> Well, what do you want to see?
15:51:31 <Cale> You can write Show instances
15:51:39 <beaky> ah I'll try that
15:52:50 <kirindave> Common Lisp had serializable functions in many impls
15:52:52 <typoclass> beaky: i think showable functions would be slightly convenient for debugging and learning, but not really for programming
15:53:00 <kirindave> I think sbcl has multiple showables.
15:53:21 <kirindave> Cloud Haskell has these interesting Closure things which give you the actual benefit of serializable functions.
15:54:12 <strebe> beaky: python's not particularly useful in that regard: >>> def a(): 1      >>> a      gives ... <function a at 0x28650c8>
15:54:17 <Polarina> Read instances for functions would be cool.
15:55:19 <Ghoul> Holy shit
15:55:22 <Ghoul> shut down
15:55:23 <Ghoul> http://stackoverflow.com/questions/6964392/speed-comparison-with-project-euler-c-vs-python-vs-erlang-vs-haskell
15:55:31 <Ghoul> Look at the suggested answer
15:56:57 <merijn> Hmm, what'd be the simplest way to instantiate a grid if its horizontally and vertically mirrored? i.e. I should be able to get away with specifying one quadrant and fixing the rest from there?
15:58:27 <Tekmo> I wish Haskell had some feature to enable a generalized "UNPACK"
15:58:38 <Tekmo> that accepted any field that was fully unpacked
15:58:54 <Tekmo> What I mean by this is that I have a Point data type
15:59:00 <Tekmo> Let's say it has three coordinates, all unpacked
15:59:08 <Tekmo> So far so god
15:59:10 <Tekmo> *good
15:59:21 <Tekmo> Then I have some other data type
15:59:34 <Tekmo> with a field I'd like to make polymorphic over UNPACK-able things
15:59:37 <Tekmo> So I would just say
15:59:53 <Tekmo> data Foo a = Foo { field :: {-# UNPACK #-} !a }
16:00:03 <Tekmo> and that would be legal if and only if a was fully unpacked
16:00:16 <typoclass> Ghoul: very nice link, thank you
16:00:25 <Tekmo> Then you could define a strict list, like:
16:00:49 <Tekmo> data List a = Nil | Cons {-# UNPACK #-} !a {-# UNPACK #-} !(List a)
16:01:10 <jix> Tekmo: I think this would cause quite some implementation problems
16:01:42 <rwbarton> I was with you up until {-# UNPACK #-} !(List a)
16:02:11 <Tekmo> What I mean is that
16:02:15 <Tekmo> these are sort of like inductive data types
16:02:24 <Tekmo> Their fields may only be other inductive data types
16:02:36 <rwbarton> currently you cannot unpack a field which is a data type with multiple constructors
16:02:38 <Tekmo> Guaranteeing finite-ness
16:02:50 <Tekmo> Ok, well, forget unpacking then
16:02:54 <Tekmo> replace it with STRICT
16:02:55 <Tekmo> or FINITE
16:03:00 <Tekmo> or whatever semantics make sense to you
16:03:09 <Tekmo> So, list would not work
16:03:21 <Tekmo> At least, not without a type-level length
16:03:29 <acowley> Tekmo: I have often wanted that. The best you can is data families :/
16:03:45 <typoclass> Tekmo: friendly suggestion, could you maybe use longer lines? it's a bit hard to read
16:03:54 <Tekmo> Alright, I'll chop up my sentences less
16:04:02 <typoclass> Tekmo: thanks :)
16:04:04 <Tekmo> :)
16:04:09 <acowley> Tekmo is Shatnering #haskell
16:04:40 <Iceland_jack> heh
16:04:40 <Tekmo> It's a habit I developed from back in my computer gaming days
16:04:49 <Tekmo> I didn't have a microphone, so I just learned to type really quickly in spurts
16:05:26 <acowley> are you saying we should expect you to drop into some Xbox Live style trash talk at some point?
16:06:04 <kirindave> Could someone explain to me why this code is both very slow and also seems to leak memory on large inputs? https://gist.github.com/e922a21d1d481706fc12
16:06:15 <Tekmo> Haha :)
16:06:26 <kirindave> It is nearly exactly a copy of my bytestring-based version, but is 2x slower and leaks memory.
16:06:42 <acowley> edwardk: I fleshed out Dim some, but initial tests show it to be no faster than the existing V3
16:06:53 <kirindave> Tekmo: Are you the author of Pipes?
16:06:54 <edwardk> i didn't expect it to be honestly
16:06:55 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
16:07:03 <edwardk> just a few combinators for building them from triples, etc.
16:07:06 <Tekmo> kirindave: Yes
16:07:15 <kirindave> Tekmo: Can I ask you something about frames?
16:07:21 <acowley> the zipWith is hideous, ridiculous, and offensive, but no matter the representation, GHC optimizes everything away
16:07:23 <Tekmo> kirindave: I'm deprecating the, just so you know
16:07:36 <acowley> edwardk: Well, I paired it with a data family so I could unpack the elements
16:07:55 <kirindave> Tekmo: Oh? In favor of?
16:08:02 <Tekmo> kirindave: A two-pronged solution
16:08:06 <Tekmo> kirindave: using proxies
16:08:13 <kirindave> Cuz like, the indexed monad solution is pretty brutal to integrate with
16:08:14 <kirindave> I tried
16:08:18 <edwardk> yeah that i actually was deliberately avoiding. the problem with that approach is that there isn't a good canonical place to put all those instances.
16:08:20 <kirindave> becuase I _really_ like the resource management behavior.
16:08:22 <Tekmo> kirindave: I completely understand
16:08:23 <acowley> The only problem is that classes like R2 don't work out so well there as I'd need a class constraint, e.g. Vector V3 a => R2 V3 where
16:08:23 <Polarina> kirindave, a guess, but it seems to me that loopChunks isn't tail-recursive when it's calling loopByets.
16:08:32 <Tekmo> kirindave: I hate the indexed monad conflicting with the normal monad
16:08:37 <edwardk> so from a haskell engineering perspective the resulting api winds up fairly brittle
16:08:38 <kirindave> Polarina: Except that if I use my older bytestring version it is. I can't figure out why.
16:08:40 <Tekmo> kirindave: The new solution uses ordinary monads
16:08:51 <kirindave> Tekmo: Do you think that'll be the version you stick with?
16:08:55 <Tekmo> kirindave: Yes
16:09:08 <Tekmo> kirindave: It's actually superior to frames
16:09:09 <kirindave> Tekmo: In general, I really like your library over some of its competitors. It does most of what they do in a cleaner way.
16:09:17 <edwardk> and there is that
16:09:18 <acowley> but that instance makes no sense with the "a" type
16:09:20 <Tekmo> kirindave: If you want, I can breifly explain what I have in mind
16:09:23 <beaky> how do I do a while loop in Haskell i.e. `while readIORef foo /= False $ do`
16:09:29 <kirindave> Tekmo: I would really enjoy hearing it.
16:09:38 <edwardk> the unpacked API is more in the spirit of hmatrix than linear, honestly
16:09:42 <Polarina> beaky, haskell doesn't have while loops. Try recursion. :)
16:09:43 <kirindave> Tekmo: And also Haskell-the-community really needs to like, pick a goddamn iteratee-like solution soon. >:(
16:09:57 <Tekmo> kirindave: There are two halves to do it.  The first is guaranteeing determinism and the second is guaranteeing promptness
16:10:00 <rwbarton> i'm sort of glad it hasn't yet
16:10:04 <kirindave> Because we're starting to have people notice how awkward non-iteratee IO is.
16:10:06 <rwbarton> consider the situation a year ago
16:10:08 <edwardk> the more i think about it the more i think it'd belong in a separate package
16:10:17 <Tekmo> kirindave: I completely understand the urgency.  I spend ALL my free time working on pipes
16:10:21 <kirindave> rwbarton: I agree it needs time to bake. I just want the cake to come out soon.
16:10:37 <Tekmo> kirindave: The only reason I haven't released anything yet is I'm seeing if I can type-class proxy operations or not
16:10:38 <kirindave> Tekmo: 2 halves. I am with you.
16:10:53 <acowley> edwardk: Yeah, as it stands it's not worth the headache. I'd like to see if it ever shows a performance advantage, but I was really disappointed with the absurdity of zipWithF :/
16:10:56 <Tekmo> kirindave: There is a brutal type-class problem I can't work around.  If I can't solve it soon I am just going to standardize on the Proxy type
16:11:11 <Tekmo> kirindave: Anyway, back to finalization
16:11:15 <edwardk> did you commit the zipWithF code?
16:11:31 <Tekmo> kirindave: The first half of the solution is determinism.  This will be very similar to Michael's ResourceT solution
16:11:45 <Tekmo> kirindave: You have some base monad that catches all unused finalizers and makes finalization idempotent
16:12:01 <Tekmo> kirindave: In fact, I may even endorse Michael's solution for this half if I can't find a more elegant alternative
16:12:01 <kirindave> Okay.
16:12:09 <Tekmo> kirindave: That handles determinism, but not promptness
16:12:14 <acowley> edwardk: not yet
16:12:20 <edwardk> k
16:12:24 <acowley> edwardk: Shall I put these things on a new branch?
16:12:33 <rwbarton> http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Lazy-Builder.html
16:12:34 <kirindave> So it seems to me like the one really nice part of your Frames solution was when resource generators were chained it was better than resourceT in most cases.
16:12:38 <acowley> edwardk: It's very partial and we'll probably dump it or spin it off eventually
16:12:48 <Tekmo> kirindave: Yes, and the new one will have this property, too
16:12:53 <kirindave> Okay.
16:12:53 <rwbarton> does anyone know what they are renaming the Builder modules from/to
16:12:55 <kirindave> Promptness.
16:12:58 <Tekmo> kirindave: In afct, Michael's implementation still has late finalization bugs in it
16:13:06 <rwbarton> because that page isn't terribly illuminating
16:13:12 <kirindave> And aristid-ic_ was complaining about how things leak.
16:13:18 <Tekmo> kirindave: Yes, they do
16:13:19 <edwardk> i'm totally in favor of adding the zipwith code to master i'm pretty negative on adding the partially implemented data family mess though
16:13:31 <Tekmo> kirindave: That's actually a different issue
16:13:38 <Tekmo> kirindave: It's because of the way I wrote the recursion
16:13:44 <kirindave> Ah
16:13:48 <edwardk> if you want to throw the zipwith code for linear.dim in master and shove the rest out in a branch to bitrot that'd probably be ideal.
16:13:49 <Tekmo> kirindave: If you use "let" to do the recursion it disappears
16:13:58 <acowley> edwardk: Okay, I'll do that
16:14:03 <Tekmo> kirindave: I just never updated the frame code because I was planning on deprecating it
16:14:08 <kirindave> Interesting.
16:14:28 <Tekmo> kirindave: And even now it only happens if you use NOINLINE on the code in some weird cases
16:14:34 <Tekmo> kirindave: But anyway, all new code has that bug fixed
16:15:02 <Tekmo> kirindave: So the second half of the solution is promptness, which is orthogonal to determinism
16:15:16 <Tekmo> kirindave: I'll explain why it's orthogonal in a second
16:15:20 <kirindave> Okay.
16:15:40 <Tekmo> kirindave: Basically, it uses a proxy transformer that extends proxies with the ability to register monoids over sections of code
16:15:48 <Tekmo> This monoid could be anything, but in this specific case it's a finalizer
16:15:59 <Tekmo> Where the monoid is: Monad m => m ()
16:16:07 <kirindave> Okay.
16:16:14 <kirindave> You seemed unsure that was a monoid at some point?
16:16:22 <Tekmo> Well, there is the issue of bottom
16:16:26 <Tekmo> and if it's REALLY an issue
16:16:28 <Tekmo> you can always use
16:16:29 <kirindave> Ha.
16:16:32 <Tekmo> forall r . r -> m r
16:16:41 <Tekmo> that monoid works just fine, I believe
16:17:08 <Tekmo> So anyway, it lets you register monoids, just the way you would register finalizers using frames
16:17:24 <Tekmo> This lets you write something like: register someMonoid $ do wrappedAction
16:17:35 <Tekmo> Everything within that do block is wrapped with that monoid
16:17:56 <Tekmo> Then, the proxy transformer lets you fold the currently active monoids in either the upstream or downstream direction
16:18:09 <Cale> ... entire monoids?
16:18:24 <Tekmo> It's like mconcat
16:18:29 <Tekmo> over upstream or downstream
16:18:31 <Cale> Or monoid elements?
16:18:35 <Tekmo> monoid elements
16:18:36 <Tekmo> :)
16:18:46 <kirindave> Dat whole monoid.
16:18:50 <kirindave> Okay.
16:19:07 <Tekmo> So, for example, if you mconcat upstream, that returns every currently active finalizer that was registered
16:19:21 <Tekmo> You canthen run that to finalize them
16:19:26 <Tekmo> Except, these are not finalizers
16:19:37 <Tekmo> They are actually optional suspension routines
16:19:58 <linduxed> i don't get it... when i run "maximumBy (compare `on` length) . concatMap (tail . words) . lines $ list" in ghci, it works fine, but when i try to load the same line through some code i get IO.hs:8:20:Couldn't match type `String -> [Char]' with `[Char]'
16:20:18 <Tekmo> So the idea is that you say "I'm not going to await from upstream any time soon, so you can optionally give me a suspension routine if you want to deallocate yourself in the meantime"
16:20:32 <Tekmo> This suspension routine is orthogonal from a finalization routine
16:20:51 <kirindave> I could see that also being used to say things like, "Now is the time to commit a series of transactions?"
16:21:02 <rwbarton> :t \list -> maximumBy (compare `on` length) . concatMap (tail . words) . lines $ list
16:21:03 <lambdabot> String -> [Char]
16:21:26 <kirindave> Interesting
16:21:31 <clahey> So, if I have a 2D Array, is there a quick way to get a vector of a subset?
16:21:34 <rwbarton> linduxed: well it sounds like the surrounding code is wrong then
16:21:39 <Tekmo> To see why, consider the following pipeline: p1 >-> (p2 >=> p3)
16:22:04 <Tekmo> Actually, let me change that: p1 >-> ((p2 >-> p3) >=> p4)
16:22:07 <Tekmo> That's a better example
16:22:10 <rwbarton> linduxed: what does "load the same line through some code" mean
16:22:20 <Tekmo> So (p2 >-> p3) reads from p1
16:22:26 <Tekmo> Similarly, p4 reads from p1
16:22:28 <kirindave> Right
16:22:42 <Tekmo> However, if p2 >-> p3 is done with p1, it doesn't mean that p4 is
16:23:02 <Tekmo> So that's why the semantics are to simply "suspend" and not finalize
16:23:23 <Tekmo> If there is no meaningfully suspension routine, you just don't register one at all and fall back on the deterministic finalization at the very end
16:23:25 <kirindave> What is a suspend for, say,  a file handle?
16:23:26 <kirindave> fflush?
16:23:33 <Tekmo> That's up to the file handle to decide
16:23:39 <kirindave> I see
16:23:47 <linduxed> rwbarton: https://gist.github.com/3962134
16:23:51 <Tekmo> You could choose not to suspend at all and fallback on the final cleanup (assuming that you terminate early)
16:23:56 <kirindave> I would have to think on that.
16:23:59 <Tekmo> Alternatively, you could close the file and save its position
16:24:09 <kirindave> I am not sure it is useful in an operational context or not...
16:24:11 <Tekmo> Then, when you reawaken it, it seeks back to where it ws
16:24:12 <kirindave> Sounds good
16:24:27 <kirindave> Yeah a good example is chunked URL reading.
16:24:32 <kirindave> It could work really well there
16:24:35 <rwbarton> linduxed: why is there a 'file' on the left hand side of line 8 but not on the right hand side
16:24:40 <Tekmo> Yeah.  The point is that it's completely optional to opt into
16:24:42 <rwbarton> that's probably not what you mean
16:24:46 <kirindave> I see.
16:24:48 <Tekmo> If there is no meaningful suspension routine, you just don't register one
16:24:50 <linduxed> rwbarton: gaaaaah
16:24:54 <kirindave> It'd be nice if you could define them all in one go though
16:25:01 <linduxed> rwbarton: these tiny errors :-/
16:25:05 <linduxed> thx
16:25:13 <Tekmo> So in the case of a file, what you would probably do is register a suspension routine where you deallocate the file and reopen and seek back when you reawaken
16:25:19 <kirindave> Like somehow not create finalization and suspension diaspora for each IO-related resource.
16:25:39 <Tekmo> Well, the suspension is what makes the prompt finalization possible
16:25:43 <kirindave> Tekmo: That strikes me as really interesting.
16:25:48 <Tekmo> So, a resource can choose to register a finalizer as a suspension routine
16:25:52 <kirindave> Tekmo: Because that implies you somehow serialize the state.
16:25:55 <Tekmo> and then throw an error if it's reawakened
16:26:01 <aristid-ic_> kirindave: did you highlight me here?
16:26:08 <kirindave> aristid-ic_: In passing
16:26:10 <Tekmo> As far as reawakening resources goes, it's simple
16:26:15 <kirindave> If your pipeline is cleanly serializable and the state is not excessive
16:26:26 <kirindave> Then it's possibly another model cloud haskell can support.
16:26:33 <kirindave> Where instead of serialization representing that jump
16:26:38 <Tekmo> kirindave: Yeah, it's a nice way to serialize resources
16:26:41 <kirindave> Err, representing a sleep, it represents that jump.
16:26:44 <clahey> Actually, maybe what I want is Ix i, Ix i' => (i, i) -> (i -> i') -> Array i' -> Array i
16:26:49 <kirindave> But that implies
16:26:50 <kirindave> Um
16:26:51 <kirindave> What' sthe word?
16:26:54 <rwbarton> @type ixmap
16:26:55 <lambdabot> forall i j e. (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
16:26:59 <tac> What's the difference between Control.Monad.Free and Control.Monad.Prompt? I was under the (mistaken) idea that Prompt allowed you to build free monads
16:26:59 <kirindave> A copointed structure for your monoid, right?
16:27:08 <Tekmo> kirindave: I'm not sure what copointed is
16:27:09 <rwbarton> or for that matter
16:27:18 <kirindave> Tekmo: Maybe I used the wrong word
16:27:19 <rwbarton> @hoogle (Ix i, Ix i') => (i, i) -> (i -> i') -> Array i' -> Array i
16:27:20 <lambdabot> Did you mean: (Ix i, Ix i') => (i, i) -> (i -> i') -> Array i' i -> Array i i
16:27:20 <lambdabot> No results found
16:27:28 <Tekmo> kirindave: Well, there are other benefits of this monoid formulation
16:27:28 <kirindave> Like You have to be able for your monoid to go a -> ma -> a
16:27:30 <rwbarton> oh huh
16:27:34 <rwbarton> @hoogle (Ix i, Ix i') => (i, i) -> (i -> i') -> Array i' e -> Array i e
16:27:35 <lambdabot> Data.Array ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
16:27:35 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
16:27:35 <lambdabot> Data.Array.MArray mapIndices :: (MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)
16:27:51 <rwbarton> @hoogle (Ix i, Ix i') => (i, i) -> (i -> i') -> Array i' i -> Array i i
16:27:51 <lambdabot> Data.Array ixmap :: (Ix i, Ix j) => (i, i) -> (i -> j) -> Array j e -> Array i e
16:27:51 <lambdabot> Data.Array.IArray ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
16:27:51 <lambdabot> Data.Array.MArray mapIndices :: (MArray a e m, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> m (a i e)
16:27:57 <rwbarton> what a weird suggestion
16:27:59 <Tekmo> kirindave: For example, let's say that instead of suspension routines, your monoid element is a trace
16:28:10 <kirindave> Ah yeah
16:28:11 <Tekmo> kirindave: Then when you mconcat upstream or downstream, you have a stack trace of what is currently going on
16:29:08 <aristid-ic_> Tekmo: i read a bit of backlog and you said there is a plan for something similar to ResourceT... my question is: with or without ST-like phantom type?
16:29:30 <Tekmo> aristid-ic_: I'm not familiar with the ST approach.  How does it work?
16:29:37 <lkinthwasyx> damn.. wanted to ask a question, but just noticed that I forgot the "let" in interactive mode :)
16:29:38 <aristid-ic_> :t runST
16:29:40 <lambdabot> forall a. (forall s. ST s a) -> a
16:29:44 <Tekmo> I know that
16:29:45 <aristid-ic_> Tekmo: ^
16:29:50 <lkinthwasyx> bb
16:29:56 <kirindave> Tekmo: The only problem with such flexible semantics is that people will misuse it. But I suppose that can't be helped. :)
16:30:03 <aristid-ic_> Tekmo: i don't understand your question then?
16:30:04 <Tekmo> aristid-ic_: Oh, I understand
16:30:27 <Tekmo> aristid-ic_: You mean give the option to make it run pure using the ST monad to take care of registration and finalization
16:30:50 <aristid-ic_> Tekmo: no i mean using a phantom type to make sure there is no leaking of resources outside the region:)
16:31:01 <Tekmo> aristid-ic_: You mean like Oleg's regions paper?
16:31:05 <kirindave> Yeah that's the leak I was describing.
16:31:08 <kirindave> Although
16:31:23 <clahey> rwbarton, Yeah, I wasn't sure the order of the arguments to search for on hoogle.
16:31:35 <aristid-ic_> Tekmo: i think so, although i didn't read oleg's regions paper:)
16:31:41 <Tekmo> aristid-ic_: Basically, I'd use any base monad that supports this features
16:31:47 <Tekmo> aristid-ic_: This requires no integration with proxies at all
16:31:51 <rwbarton> hoogle can rearrange multiple arguments
16:31:54 <kirindave> I should get back to work
16:31:58 <Tekmo> aristid-ic_: You just set the base monad to the one that handles resource finalization
16:32:00 <kirindave> Tekmo: But thank you very much for walking me through that.
16:32:05 <rwbarton> @hoogle [a] -> (a -> b) -> [b]
16:32:06 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
16:32:06 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
16:32:06 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
16:32:07 <Tekmo> kirindave: You're welcome
16:32:09 <kirindave> I'm excited to see what you come up with.
16:32:19 <Tekmo> kirindave: There will also be parsing soon
16:32:19 <aristid-ic_> Tekmo: so you could even use ResourceT?
16:32:23 <Tekmo> aristid-ic_: Correct
16:32:35 <Tekmo> aristid-ic_: That was my plan if I don't find a better alternative
16:32:46 <Tekmo> aristid-ic_: I don't know if there are any competitors to ResourceT
16:32:51 <kirindave> Tekmo: My big concern is not parsing. I'm trying to write production software for managing thousands of budgets. :)
16:32:55 <aristid-ic_> Tekmo: http://hackage.haskell.org/packages/archive/regions/0.11/doc/html/Control-Monad-Trans-Region.html
16:33:04 <Tekmo> aristid-ic_: Thanks.  I will try that one out, too
16:33:20 <Tekmo> aristid-ic_: Although I remember each time I check it, I think "Where is the part that I USE?"
16:33:22 <kirindave> Tekmo: And writing the stages of that algorithm as proxies is attractive to me.
16:33:33 <Tekmo> kirindave: Yeah, it makes it a lot easier to reason about my own code
16:33:54 <aristid-ic_> Tekmo: haha i think it must be similar to ResourceT, just way more oleg ;)
16:33:59 <Tekmo> aristid-ic_: Yeah
16:34:03 <kirindave> Haha
16:34:04 <Tekmo> aristid-ic_: I just want something exception safe
16:34:11 <kirindave> the Oleg is strong in that one.
16:34:13 <enkomax> how would this be described in english: where (f:_) = firstname ?
16:34:19 <Tekmo> aristid-ic_: Whatever I pick for the base monad has to have exception safety, which is a big request I get
16:34:38 <kirindave> aristid-ic_: By the way look at me. Holding a non-retarded discussion in #haskell.
16:34:47 <kirindave> aristid-ic_: HOW FAR I HAVE COME.
16:34:50 <Tekmo> lol
16:34:53 <kirindave> Oop, regressed.
16:34:54 <aristid-ic_> kirindave: a-ma-zing
16:35:12 <kirindave> aristid-ic_: Haha. I consider myself shot down. But give me just a moment.
16:35:47 <Tekmo> kirindave: Also, if you have any requests for the standard library, just let me know
16:35:58 <typoclass> enkomax: firstname would have to be a list (e.g. a String), and (f:_) cuts off the first element of that list and names it "f"
16:36:03 <kirindave> Tekmo: aristid-ic_ and I were just talking about how there need to be I/O batteries included.
16:36:06 <kirindave> Tekmo: But.
16:36:14 <kirindave> Tekmo: Obviously Frames are being deprecated. So.
16:36:20 <Tekmo> kirindave: Yeah, I will release bytestring and text utilities soon
16:36:21 <enkomax> ok gotcha, thanks
16:36:35 <Tekmo> kirindave: Once I sort out the base monad I will also release file-level sources
16:36:42 <kirindave> Tekmo: ST stuff too.
16:36:44 <Tekmo> kirindave: Instead of just handle-level stuff
16:36:44 <enkomax> in other words where f is the first element of firstname
16:36:56 <clahey> rwbarton, I'll remember that next time.  Thanks.
16:37:06 <Tekmo> kirindave: What specifically about ST?
16:37:12 <kirindave> Pardon me
16:37:15 <kirindave> I really need to finish this.
16:37:17 <kirindave> Sorry!
16:37:20 <Tekmo> Alright, good luck
16:37:21 <linduxed> i've noticed that when i pipe in really large files into https://gist.github.com/3962207 i get stack space overflow. is there a way to counteract this?
16:38:19 <enkomax> run shells with larger stack :P
16:38:29 <shachaf> linduxed: Files with long lines or with many lines?
16:38:36 <linduxed> shachaf: many
16:38:58 <linduxed> shachaf: like 3291830 many
16:39:02 <Tekmo> linduxed: I'm guessing the leak is from maximumBy
16:39:19 <Tekmo> linduxed: It has to keep track of the most current match
16:39:20 <Cale> Yeah
16:39:28 <Tekmo> linduxed: But it's probably not strict in that accumulator
16:39:32 <acowley> edwardk: both pushes are now on github
16:39:33 <Tekmo> linduxed: At least, not completely strict
16:39:34 <shachaf> @src maximumBy
16:39:34 <lambdabot> Source not found. Maybe you made a typo?
16:39:38 <Cale> Are you compiling with -O2?
16:39:43 <Tekmo> linduxed: So the String it stores accumulates space leaks
16:39:56 <Cale> also, you can probably speed this up by computing the lengths only once
16:40:02 <linduxed> Cale: i'm just doing "ghc thefile.hs"
16:40:02 <shachaf> edwardk: Do you get any Lens/Traversal-like thing with Monad?
16:40:08 <Cale> linduxed: add -O2
16:40:12 <edwardk> acowley: thanks
16:40:15 <Cale> and see if the situation improves
16:40:20 <edwardk> shachaf: nope
16:40:36 <Tekmo> Who was it that said: "Every time you don't use -O2, the GHC developers shed a single tear"
16:40:38 <edwardk> you mean if you upgrade it to Monad m => (c -> m d) -> a -> m b ?
16:40:43 <shachaf> edwardk: Right.
16:40:44 <linduxed> Cale: still overflow
16:40:52 <edwardk> yeah the extra context sensitivity isn't helpful
16:40:59 <shachaf> Monad seems like a pretty weird thing to use there.
16:41:28 <edwardk> its like how there isn't a FunctorM class. there used to be in places, but Traversable is pretty compelling
16:41:48 <shachaf> What's FunctorM?
16:41:59 <shachaf> Ah, fmapM :: Monad m => (a -> m b) -> f a -> m (f b)
16:42:00 <Cale> okay, in that case, try using  map snd . foldl1' max . (\x -> (length x, x))
16:42:01 <edwardk> if you can mapM you should be able to traverse, otherwise you can't fit into the laws
16:42:04 <edwardk> shachaf: yeah
16:42:27 <shachaf> traverse pretty much is generic mapM.
16:42:32 <shachaf> (Well, generic mapA)
16:42:42 <Cale> The foldl1' being the important change -- to strictify the maximum
16:42:59 <aristid-ic_> Tekmo: looking a bit closer at the types and the code, regions (the package) seems quite cool. maybe a little bit over-desgined, but should still be usable.
16:43:27 <acowley> That word capitalization brouhaha on /r/haskell has been pretty interesting
16:43:47 <rwbarton> yes
16:43:55 <Cale> linduxed: any better?
16:43:59 <Tekmo> aristid-ic_: The argument for ResourceT is that it allows users to more easily transition from conduit
16:44:01 <rwbarton> in several ways
16:44:13 <linduxed> Cale: longestWord = map snd . foldl1' max . (\x -> (length x, x)) . concatMap (init . words) . lines
16:44:41 <linduxed> Cale: couldn't match expeccted type `[[(a0, Char)]]'
16:44:42 <aristid-ic_> Tekmo: fair enough, i just dislike that you can easily leak resources from resourcet
16:45:05 <aristid-ic_> Tekmo: just return your Pipe and there it is outside
16:45:05 <Cale> linduxed: oh, silly me, just snd, not map snd
16:45:20 <Tekmo> aristid-ic_: Oh, I see what you mean
16:45:25 <Tekmo> aristid-ic_: You want extra type safety
16:45:37 <Tekmo> aristid-ic_: I will experiment with Oleg's then
16:45:42 <linduxed> Cale: couldn't match expeccted type `[(a0, String)]'
16:45:54 <rwbarton> map (\x -> (length x, x))
16:45:57 <Cale> > snd . foldl1' max . (\x -> (length x, x)) . words $ "here are some words"
16:45:59 <lambdabot>   Couldn't match expected type `[(a, b)]'
16:45:59 <lambdabot>         against inferred type `(GHC...
16:46:08 <Cale> > snd . foldl1' max . map (\x -> (length x, x)) . words $ "here are some words"
16:46:11 <lambdabot>   "words"
16:46:12 <Cale> yes
16:46:24 <Cale> I'm obviously not thinking clearly
16:46:24 <aristid-ic_> Tekmo: in the end, you need to weigh these things :P it's not my library after all
16:46:37 <Tekmo> aristid-ic_: I always appreciate the advice.  Don't worry
16:46:55 <Tekmo> aristid-ic_: Also, I've been interacting with Bas van Dijk a bit recently so I can ask him more about it
16:47:28 <linduxed> Cale: yes, now it worked :-D
16:47:29 <Cale> linduxed: any better?
16:47:32 <Cale> okay, great
16:47:43 <linduxed> Cale: tricky, that strict vs. non-strict stuff
16:47:52 <Cale> Takes a little getting used to, yeah
16:47:53 <johnw> indeed, it is
16:47:58 <beaky> http://ideone.com/91jTl4 I'm reimplementing my optimized C turing machine in Haskell. How do I get this code to compile?
16:48:13 <linduxed> i feel like i loose a lot of nice things that happen to be lazy
16:48:30 <linduxed> like that maximumBy function (and most likely all the others from the same aread)
16:48:40 <Cale> linduxed: Generally you want strictness where you're taking a large amount of data and summarising it into a small result
16:48:51 <Cale> and you want things to be lazy everywhere else
16:48:57 <linduxed> ok
16:49:29 <chare> With Haskell what is the intended way to do things when you don't have the standard dynamic dispatch of inheritance like in Java
16:49:39 <beaky> :t (- 1)
16:49:40 <lambdabot> forall a. (Num a) => a
16:49:41 <beaky> :t (+1)
16:49:43 <lambdabot> forall a. (Num a) => a -> a
16:49:50 <beaky> how come the first is -1, and the second is Succ?
16:50:11 <rwbarton> because there is no unary + operator
16:50:21 <shachaf> chare: Usually you, uh, do them.
16:50:38 <gwern> @quote unary
16:50:39 <lambdabot> No quotes match. My brain just exploded
16:50:42 <chare> so how does haskell do that
16:50:51 <shachaf> I think people managed to do things long before "the standard dynamic dispatch of inheritance like in Java" existed.
16:51:02 <shachaf> Here's an example of doing a thing:
16:51:03 <shachaf> > 1 + 1
16:51:04 <lambdabot>   2
16:51:11 <Cale> chare: What would you be using the inheritance for?
16:51:12 <shachaf> If you have a more complicated thing you'd like to do, feel free to specify it. :-)
16:51:26 <Dashkal> Instead of asking how to re-implement a specific mechanic of another programming style, focus on how to solve the problem at hand.
16:51:30 <Cale> chare: also, are you sure that you mean inheritance and not just subtyping?
16:51:33 <chare> Cale: for the same reason that inheritance is used in nonfunctional llanguages right?
16:52:01 <shachaf> rwbarton: You know, if lambdabot was "fixed", we could be using Control.Lens in it right now!
16:52:16 <Cale> chare: You mean, creating bugs when people are lazy about implementing interfaces completely and the superclass methods do the wrong thing?
16:52:21 <rwbarton> what about it needs fixing anyways
16:52:24 <rwbarton> just building on 7.4?
16:52:35 <rwbarton> (or 7.6?)
16:52:37 <typoclass> chare: not sure what you're asking for :) but haskell has powerful parametric polymorphism
16:52:57 <shachaf> rwbarton: Oh, I meant making it good.
16:53:06 <rwbarton> oh...
16:53:12 <shachaf> I think it already builds on 7.4, which is enough for lens.
16:53:25 <rwbarton> so why isn't it running on 7.4
16:53:26 <shachaf> Cale: Can you get lambdabot running on 7.4?
16:53:30 <beaky> http://ideone.com/A4kl2y Why is my code blowing the stack?
16:53:38 <shachaf> "thx Cale"
16:53:43 <Cale> I have gotten it running on 7.4 before
16:53:49 <shachaf> Cale: I mean the actual lambdabot.
16:53:49 <Cale> I suspect I could do it again
16:53:52 <Cale> oh, no
16:54:02 <shachaf> Cale: I suspect it's pretty trivial, because I did it just the other day.
16:54:05 <Cale> 7.4 isn't installed on the machine I'm running it on
16:54:19 <shachaf> lispy: ‚òù
16:54:23 <Cale> I guess I could try to install it in my user account
16:54:27 <Cale> but I don't know
16:54:31 <shachaf> Cale: It's quite easy to do that.
16:54:47 <shachaf> Just download the GHC binary and install it in some directory.
16:55:13 <Cale> Yeah, I might do that at some point
16:55:15 <rwbarton> then cabal-install various things for a day
16:55:19 <Cale> I don't really see much point in it
16:55:26 <Cale> since lambdabot is working okay as it is
16:55:34 <shachaf> (Also, can you get rid of the flip thing?)
16:55:52 <shachaf> Cale: I want Control.Lens!
16:56:00 <beaky> is modifyIORef lazy?
16:56:06 <rwbarton> yes
16:56:18 <beaky> I primed all the modifyIORef and got it to work :D
16:56:23 <rwbarton> in the sense that it puts an unevaluated expression in the IORef
16:56:48 <beaky> http://ideone.com/nau08a doesn't compile in the ideone though, why is that?
16:56:50 <aristid-ic_> shachaf: just use id and supply the type yourself!
16:56:52 <rwbarton> yes, a loop with "modifyIORef foo (+1)" is a common source of stack overflow
16:57:01 <beaky> is modifyIORef' a recent addition
16:57:02 <shachaf> aristid-ic_: ?
16:57:12 <rwbarton> i've never heard of modifyIORef'
16:57:16 <aristid-ic_> shachaf: to use lens...
16:57:21 <shachaf> rwbarton: I have one.
16:57:23 <rwbarton> though it is obvious what it should do
16:57:32 <aristid-ic_> shachaf: sorry, jokes that need explanation are always bad:(
16:57:43 <beaky> funny that this version of the turing machine is twice as slower as the purely functional one :(
16:57:56 <beaky> I thought this would be as fast as the java version at least
16:58:05 <shachaf> aristid-ic_: I must still be still missing it.
16:58:42 <merijn> There's no "Array i v -> (v -> v) -> i -> Array i v" type of function?
16:58:49 <aristid-ic_> shachaf: well at least a while ago, a substantial fraction of lens' functions were apparently id with a type class
16:58:58 <aristid-ic_> -class+restriction
16:59:09 <merijn> Oh, Control.Lens to the rescue :>
16:59:14 <shachaf> aristid-ic_: Oh.
16:59:21 <edwardk> merijn: hah
16:59:45 <edwardk> merijn: figured out "over traverseArray"?
16:59:47 <shachaf> @let both f (x,y) = (,) <$> f x <*> f y
16:59:49 <lambdabot>  Defined.
16:59:58 <Cale> beaky: The index and state don't need to be IORefs, you could just make them function parameters.
17:00:01 <merijn> edwardk: I was just thinking of "ix"
17:00:10 <edwardk> you can also implement amapped = sets amap; and then use amapped %~ ...
17:00:12 <rwbarton> can you @@ @let @where multiple definitions?
17:00:13 <aristid-ic_> shachaf: like (%%~) = id
17:00:19 <edwardk> ah
17:00:27 <rwbarton> how long can a @where entry be? can we put whole modules in there? :)
17:00:48 <shachaf> Sadly we can't put types in there. :-(
17:01:02 <shachaf> rwbarton: I bet rwbarbot would allow you to define types in @let
17:01:05 <merijn> shachaf: I proposed "both f = join (***)" on libraries@, support my quest!
17:01:12 <merijn> eh
17:01:14 <rwbarton> doesn't @let just append to a file anyways
17:01:16 <shachaf> merijn: Control.Lens's both is way better!
17:01:19 <merijn> "both = join (***)" I mean
17:01:23 <shachaf> rwbarton: Yep, after verification.
17:01:31 <rwbarton> as in, parsing
17:01:40 <shachaf> Well, yes.
17:01:48 <shachaf> Making sure there's no import or anything like that.
17:01:48 <merijn> Anyhoo
17:01:51 <merijn> Way past bedtime
17:01:52 <rwbarton> ah sure
17:01:55 <edwardk> i call that join operator 'diag' i think in categories
17:01:57 <shachaf> (Because you could import unsafePerformIO and so on.)
17:01:58 <key> quick, i need the minds of other smart ppl
17:02:09 <rwbarton> technically you could ensure that without parsing! since all imports go at the top
17:02:16 <key> what are the possible basic operational states of a server?
17:02:21 <shachaf> rwbarton: It also makes sure that you don't define data types.
17:02:24 <rwbarton> just start the file with a dummy definition
17:02:26 <shachaf> rwbarton: I'm not sure whether that's justified.
17:02:56 <shachaf> Current L.hs looks something like https://github.com/zeekay/lambdabot/blob/master/State/L.hs
17:03:40 <key> server states: 1. offline. 2. online and ready for queries. 3. online but busy. 4. failure?
17:03:50 <rwbarton> :t foo
17:03:51 <lambdabot> Not in scope: `foo'
17:03:56 <shachaf> key: Does this have anything to do with Haskell?
17:04:06 <key> not at all
17:04:41 <shachaf> rwbarton: OK, it's more like https://github.com/zeekay/lambdabot/blob/master/State/Pristine.hs
17:05:25 <rwbarton> @let foo x = x x
17:05:26 <lambdabot>  <local>:4:8:
17:05:26 <lambdabot>      Occurs check: cannot construct the infinite type: t = t ->...
17:05:29 <rwbarton> i see
17:05:30 <rwbarton> clever
17:07:25 * hackagebot chan-split 0.5.0 - Concurrent Chans as read/write pairs. Also provides generic  Chan pair class.  http://hackage.haskell.org/package/chan-split-0.5.0 (BrandonSimmons)
17:09:56 <acowley> sbv is really neat, but boy do I type "forall" instead of "forAll" a lot
17:10:15 <shachaf> I sometimes accidentally type ‚àÄ
17:10:59 <typoclass> shachaf: you accidentally typed ¬µ when the cat walked over your keyboard
17:11:00 <acowley> I kind of like using unicode characters
17:11:15 <acowley> except my monospaced font in emacs doesn't always cope so well
17:11:36 <shachaf> typoclass: Well, cats do tend to mew.
17:11:48 <acowley> I hope the Haskell community develops an acceptance of unicode names over time.
17:11:57 <shachaf> I like using Unicode characters because my computer doesn't support anything else.
17:12:01 <rwbarton> sounds like you should get a ŒΩ cat
17:12:47 <shachaf> rwbarton: Why is Œµ afraid of Œ∂?
17:13:55 <johnw> what kind of keyboard do you have that you can accidentally type ‚àÄ?
17:14:02 <strebe> acowley: they're somewhat annoying to type, and sometimes to recognize which particular one is being used when several look alike
17:14:10 <acowley> strebe: I know
17:14:12 <merijn> johnw: An APL one
17:14:27 <acowley> strebe: I sometimes hate reading other people's Agda for that reason, but love reading my own :)
17:14:34 <johnw> in my Emacs buffers, all Haskell code is displayed using as many math symbols as possible
17:14:46 <johnw> that way I don't have to wait for Unicode names to catch on
17:14:57 <acowley> I actually spend more time in Coq, and there I make somewhat more frugal use of unicode than is popular in Agda.
17:15:10 <acowley> johnw: do you have any issues with character alignment?
17:15:18 <johnw> acowley: I do
17:15:36 <johnw> acowley: mostly due to -> getting converted into ‚Üí
17:15:53 <shachaf> My ‚àÉs always end up being chaotic evil. :-(
17:16:22 <acowley> Yeah, that kind of thing is very irksome. Pretty annoying that it's an issue we have to contend with.
17:16:24 <johnw> hey, I thought the frowny face was reserved for me!
17:17:46 <acowley> He was looking right at you when he typed it.
17:17:54 <johnw> must have been
17:18:09 <shachaf> ¬∞Õú¬∞
17:19:18 <cmccann> I always assumed the purpose of weird unicode stuff in agda was to ensure that typing the syntax is harder than typing the program
17:20:07 <aristid-ic_> agda has an input mode that makes typing those weird unicode things easy
17:20:08 <hpc> nah, it's so when you go to read agda source, it's as impenetrable as the math it represents
17:20:30 <acowley> Actually I think it's more that each line is so painstakingly drawn from the darkest depths, kicking and screaming, that you want to inject a bit of ceremony into things.
17:20:51 <cmccann> sounds like good reason to write all your identifiers in fraktur
17:20:57 <cmccann> it looks so dramatic
17:21:27 <aristid-ic_> then my grandma can write agda, that's cool
17:21:29 <johnw> just be happy you don't have to prove the existence of each character before you can use it
17:21:56 <c_wraith> meh, someone would just release them in library
17:22:04 <c_wraith> compile times for that library might be painful, though
17:22:07 <aristid-ic_> johnw: usage constitutes constructive proof
17:22:27 <johnw> aristid-ic_: take that to a philosophy class
17:23:20 <aristid-ic_> johnw: i should do it when i have a few weeks of free time
17:23:31 <cmccann> honestly I wouldn't be surprised if somewhere in unicode there are symbols whose visual representation is uncomputable
17:23:52 <aristid-ic_> well there are some without visual representation if that counts?
17:23:59 <johnw> there should be a Unicode symbol which represents the set of all Unicode characters
17:24:14 <johnw> by extension, no less
17:24:18 <cmccann> I like how there are various kinds of semantic whitespace characters
17:24:25 <cmccann> like "juxtaposition meaning multiplication"
17:24:38 <cmccann> (which is, sadly, not a valid operator symbol in haskell)
17:24:42 <cmccann> (in case anyone was wondering)
17:24:45 <shachaf> cmccann: That's in Unicode?
17:24:56 <lispy> edwardk: ping
17:25:03 <lispy> edwardk: I have a question about lens
17:25:06 <edwardk> pongish
17:25:10 <edwardk> shoot
17:25:13 <c_wraith> edwardk is busy inflicting a hurricane upon boston
17:25:23 <Eduard_Munteanu> I kinda wish whitespace was overloadable in a sane manner.
17:25:24 <johnw> edwardk!
17:25:26 <shachaf> Next time, shoot first, ask to ask questions later.
17:25:28 <acowley> I like to use "juxtaposition indicating nothing of significance" for non sequiturs banana
17:25:43 <lispy> edwardk: Are you familiar with Data.StateVar? It generalizes readIORef/writeIORef to types other than just IORef
17:25:45 <aristid-ic_> Eduard_Munteanu: first, we have to redefine sanity.
17:25:58 <Eduard_Munteanu> Heh, I guess I was asking for it.
17:26:04 <typoclass> acowley: wha?
17:26:04 <edwardk> sorry. my hurricane protection shield only extends a small radius around my person. Right now it is covering most of Florida, so Boston gets shafted.
17:26:13 <lispy> edwardk: Is it possible to export something from the OpenGL libraries that makes it so that we can use lens instead of Data.StateVar?
17:26:20 <herpladee> hey how do i tell ghc to look after modules in a specific .hs file?
17:27:02 <edwardk> lispy: sadly it doesn't work well to try to make monadi getters/setters with lens. We have actions that you can run with (^!) but they don't feel like setters in that you can't assign back to them
17:27:04 <lispy> edwardk: I found the Action type in the lens library, but I'm not understanding what types I should index Action at or how to write the getter/setter stuff for it
17:27:11 <typoclass> herpladee: i think there's no way around it, you have to name the file the same as the module
17:27:33 <acowley> except for Main
17:27:38 <acowley> which can be NotMain
17:27:45 <lispy> edwardk: hmm
17:27:49 <edwardk> An Action is like a Kleisli action for some monad, that an be freely composed with other actions, or with getters, folds, traversals and lenses -- but only for reading
17:27:53 <cmccann> shachaf, http://www.unicode.org/reports/tr25/tr25-8.html#_Toc214
17:28:04 <edwardk> it isn't a getter/setter pair
17:28:30 <edwardk> when i tried to elaborate actions into MonadicTraversals or MonadicFolds it actually fell apart.
17:28:37 <shachaf> cmccann: Aha, 2061   FUNCTION APPLICATION     [<U+2061>] 2062   INVISIBLE TIMES     [<U+2062>] 2063   INVISIBLE SEPARATOR     [<U+2063>] 2064   INVISIBLE PLUS     [<U+2064>]
17:28:42 <typoclass> cmccann: invisibul bike
17:28:55 <edwardk> eg. it'd be REALLY nice to have a notion of a monadic lens that can read or write the target of an IORef
17:29:17 <lispy> edwardk: yeah
17:29:21 <hpc> i have a remarkable proof, but this margin is invisible!
17:29:31 <lispy> edwardk: That's pretty much exactly what I want :)
17:29:34 <cmccann> typoclass, not sure if that one's in unicode (yet)
17:29:40 <edwardk> i haven't come up with a decent enough trick to make that possible
17:30:18 <edwardk> it might be possible to do something like I did with Isomorphic, Indexed and the class behind Projection, but I haven't figured out the right incantation
17:30:20 <lispy> edwardk: well, now you have your homework ;)
17:30:33 <johnw> make it so, edwardk
17:30:37 <lispy> edwardk: would that require indexed monads?
17:30:40 <edwardk> lispy: well, i already tried for a week and gave up, so i wouldn't hold my breath ;)
17:30:43 <edwardk> no
17:30:55 <edwardk> the indexed in question isn't indexedmonads, its the traversablewithindex stuff i use
17:31:12 <lispy> ah
17:31:13 <edwardk> see IndexedLens, IndexedTraversal, et.
17:31:20 <lispy> I'm not familiar with those tyes
17:31:25 <edwardk> i should have picked a better name to minimize confusion
17:31:33 <lispy> I've used your lens library for all of about 5 minutes :(
17:31:47 <cmccann> huh. that's not something I ever expected to hear edwardk say
17:32:01 <cmccann> ;]
17:32:02 <edwardk> cmccann: =P
17:32:02 <acowley> hahaha
17:32:17 <shachaf> cmccann: edwardk thinks long names are confusing.
17:32:23 <shachaf> Which is why he prefers names like "a"
17:32:42 <lispy> a name like, "a" is very iconic and recognizable.
17:32:46 <edwardk> shachaf: lens is such a good library because it lets you reuse such classic names as '.' and 'id'
17:32:51 <lispy> Pretty much anyone who reads english will know "a"
17:33:06 <shachaf> edwardk: I still think you could do that with any lens library.
17:33:07 <typoclass> @remember cmccann <edwardk> i should have picked a better name to minimize confusion <cmccann> huh. that's not something I ever expected to hear edwardk say
17:33:08 <lambdabot> It is stored.
17:33:08 <edwardk> and offers incredibly verbose combinators like 'ix' and 'at'
17:33:38 <edwardk> i actually did consider adding an 'an' combinator to lens
17:33:40 <lispy> edwardk: when do we get lens into the platform?
17:33:45 <shachaf> traverseOf is a pretty great combinator.
17:34:03 <edwardk> e.g. an takes a traversal and yields a monadic action that picks a random target of the traversal and returns it
17:34:41 <edwardk> lispy: tricky it depends on stuff like unordered-containers. tibbe has stated he has no intention of pushing for that to go into the platform
17:34:53 <edwardk> it also would drag with it a bunch of comonad and comonad-transformer code
17:35:43 <lispy> edwardk: This is what ends up making me say that the platform should just be the tools you need to get going with hackage (ghc, gcc, make, autoconf, and a shell, most of this is already present except on windows)
17:36:11 <lispy> oh and cabal
17:36:16 <hpc> autoconf?
17:36:32 <edwardk> lispy: i'm rather strongly in the other camp. having a large platform is a HUGE aid to library writers like me. i can know that a large part of hackage will work together
17:36:33 <lispy> hpc: Some of the FFI bindings use make and/or autoconf
17:36:41 <hpc> i would let the OS deal with FFI stuff
17:37:25 <lispy> hpc: windows doesn't really have a way to deal with it. People have to install other things like mingw or cygwin
17:37:28 <cmccann> hpc, in other words "who cares if anything works on windows", right? :P
17:37:49 <cmccann> not that it's a walk in the park getting anything FFI-related working on windows right now, or at least last time I tried
17:37:59 <acowley> edwardk: I want to write some comonadic type stuff on a data type with a class constraint that prevents me from even writing a Functor instance. Where in lens should I be looking?
17:38:01 <lispy> edwardk: So maybe the bar to get things into the platform too high in the wrong areas?
17:38:34 * shachaf thinks lens doesn't belong in the platform (yet).
17:38:53 <acowley> I think a big platform only makes sense if there is centralized control. I much prefer getting GHC, then cabal installing my dev. environment.
17:39:00 <edwardk> lispy: well. i'm not worried about getting lens into the platform. i'd rather just say that it is compatible with the last n platforms and go from there
17:39:06 <lispy> edwardk: I've almost given up on getting the latest opengl stuff into the platform. This look at rewriting Data.StateVar into lens code was an attempt at removing Data.StateVar from the list of deps.
17:40:01 <herpladee> is there any way to make ghc output all the .o and the .hi files somewhere else so they don't mess up my directory?
17:40:06 <lispy> edwardk: the cool thing about lens, is that I can support it whether it's in the platform or not. People can get it from Hackage if they want the nice combinators.
17:40:07 <edwardk> acowley: well, there isn't centralized control, but mark lenctzner pretty much kills himself getting everyone together to get out a compatible platform
17:40:15 <edwardk> lispy: yep
17:40:23 <lispy> herpladee: cabal does this automatically
17:40:46 <acowley> Right, so what I'm saying is that any effort to push a lot of packages into the HP would not be the action of any particular authority.
17:40:54 <acowley> So I think much of the community wouldn't care for it
17:41:12 <herpladee> thanks i'll just live with it for now then :)
17:41:42 <acowley> I think that flushing the integration bugs out of things on all 3 platforms is a great service the HP (and Mark Lenctzner in particular) provides.
17:41:56 <lispy> herpladee: ghc works much like gcc for many compilation flags. So if you know how to do it with gcc, you can kind of port the same build script
17:42:02 <shachaf> herpladee: -hidir and -odir
17:42:05 <herpladee> alright i'll try that
17:42:12 <herpladee> thanks again
17:42:45 <acowley> But I think the Republic of Haskell is more dynamic than the a dictatorship.
17:43:23 <edwardk> afk for a couple of hours
17:43:27 <typoclass> acowley: what are you arguing for? more things in the platform?
17:43:31 <hpc> acowley: more of an enlightened despotism
17:43:41 <acowley> typoclass: The opposite!
17:45:17 <typoclass> i think the platform is a valuable effort because cabal is brittle
17:45:31 <beaky> is main the only function in Haskell that doesn't have any parameters?
17:45:41 <beaky> is main a function?
17:45:45 <hpc> main is an action
17:45:48 <shachaf> No, and no.
17:45:49 <beaky> ah
17:46:00 <acowley> typoclass: That's a valid point, but I'm more interested in cabal improvements (e.g. sandboxing) than doing without it.
17:48:08 <johnw> acowley: cabal-dev doesn't cut it?
17:48:43 <gwern> @quote cabal-dev
17:48:43 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
17:48:52 <acowley> johnw: Maybe it does. It's not as convenient as a package db in ~/.cabal
17:49:12 <johnw> biggest flaw I've seen so far is that it scatters Haddock docs all over the place
17:50:07 <hpc> hmm, question:
17:50:24 <acowley> Well, my issue with it is that it generally just requires more work to use. This is absolutely solvable, but it's just more convenient for me to install various private packages locally so I can use them in all my projects.
17:50:29 <hpc> why doesn't cabal do something like encode the dependencies it compiles with, and put that in the binary name?
17:50:49 <johnw> yes, I tend to install "libraries" with cabal, and "applications" with cabal-dev
17:50:57 <hpc> so instead of compiling the same version of foo with different verisons of bar and putting them in the same place
17:51:14 <hpc> you get foo-46fbc and foo-fff59
17:51:16 <hpc> or something
17:51:18 <typoclass> acowley: i think everyone agrees with improving cabal. what i'm not buying is the stuff about "dictatorship" and so on. i don't believe that abolishing standards as much as possible will in mysterious way lead to everything being great
17:51:35 <typoclass> *ways
17:52:06 <acowley> Sorry, I wasn't trying to say anything negative about dictatorships or any form of government. My point is that what works for the Python community won't necessarily serve the Haskell community as well.
17:52:35 <hpc> python is arguably even more of a dictatorship
17:52:50 <johnw> and a strong reason why it has stagnated
17:53:01 <acowley> Yes, that's why I referred to the Republic of Haskell as being a better model than a dictatorship
17:53:34 <acowley> It adds tremendous vibrancy at the cost of Mark Lenctzner's suffering :/
17:59:49 <lispy> oh cool, idris has codata now
18:00:05 <lispy> codata Stream a = Nil | (::) a (Stream a)
18:00:27 <lispy> Sure, it looks just like [a] in Haskell
18:00:37 <lispy> But that's because we can't tell codata from data.
18:01:44 <typoclass> acowley: you keep bringing up this dictatorship stuff. you're making it sound as if haskell is being strangled if there's even some small effort towards compatibility, reliability, being considerate, or really just thoughtful solid engineering
18:02:18 <typoclass> the way things are, code from this time last year is probably not compiling anymore, unless you archived all the packages and the ghc you used. that's not too hot either
18:02:20 <shachaf> lispy: Does it have copatterns?
18:02:31 <jmcarthur> ha, that was my first thought too
18:02:51 * ivanm just ignores the platform
18:03:04 <Hsk> Why "data T a = T a deriving Show" works but not "data T a = T (a Int) deriving Show"
18:03:21 <ivanm> Hsk: "(a Int)" implies that a is of kind * -> *
18:03:38 <copumpkin> shachaf: no
18:03:41 <lispy> why are google groups so terrible?
18:03:42 <Hsk> ok and?
18:03:43 <rwbarton> the instance the latter would need to write would need some extension
18:03:47 <lispy> shachaf: I have no idea if this will work: https://groups.google.com/forum/#!topic/idris-lang/bZmQpOVbHpY
18:04:01 <Saizan> Show (a Int) => Show (T a) would be easy
18:04:03 <rwbarton> maybe even UndecidableInstances? not sure
18:04:11 <jmcarthur> you need UndecidableInstances
18:04:14 <ivanm> Saizan: yeah, my guess is that the instance generator can't figure that out
18:04:18 <rwbarton> anyways you can have it produce the instance Saizan mentioned with StandaloneDeriving
18:04:19 <Saizan> i think you can StandaloneDeriving that
18:04:20 <jmcarthur> and then you can at least deriving it was StandaloneDeriving
18:05:34 <Eduard_Munteanu> Gee, now a dependently-typed language has to have copatterns since Agda has them. :P
18:05:49 <Eduard_Munteanu> At least any decent such language. :P
18:06:05 <Saizan> i wonder if you can really make something non-terminating with instances like C1 (a X) => C2 (T a)
18:06:19 * Eduard_Munteanu still isn't sure if idris concerns itself with termination/totality
18:06:25 <copumpkin> Saizan: I'd guess not
18:06:29 <Saizan> Eduard_Munteanu: it does
18:06:32 <copumpkin> Eduard_Munteanu: they don't work though
18:06:48 <Eduard_Munteanu> copumpkin: in Agda?
18:06:59 <copumpkin> Eduard_Munteanu: you can write them but there's no productivity
18:07:01 <copumpkin> at least in my version
18:07:07 <RebelBunny1> what do you guys think of Ada?
18:07:24 <hiptobecubic> I don't
18:07:27 <Eduard_Munteanu> Ah so you can only use it for normal data / non-corecursive definitions?
18:07:29 <ivanm> RebelBunny1: I've heard good things about it
18:07:43 <ivanm> admittedly, from someone who for some reason wants to do Haskell <-> Ada FFI
18:07:44 <RebelBunny1> RebelBunny1: What sort of good things?
18:07:47 <copumpkin> Eduard_Munteanu: not sure if you can write anything that doesn't turn orange with it, unless it's non recursive
18:07:54 <ivanm> RebelBunny1: that it's a good language :p
18:07:59 <ivanm> and better than C
18:08:02 <ivanm> not really any specifics
18:08:06 <ivanm> (that I can recall)
18:08:12 <RebelBunny1> ivanm: "Better than C" in what respect?
18:08:19 <ivanm> I don't recall :)
18:08:26 <ivanm> there was a thread on Ada on HN recently though
18:08:27 <Eduard_Munteanu> copumpkin: I guess http://code.haskell.org/Agda/test/features/Copatterns.agda works because they don't do codata at all?
18:08:33 <Eduard_Munteanu> Or maybe it doesn't work.
18:08:58 <copumpkin> Eduard_Munteanu: it loads, but is full of orange, as far as I know
18:09:02 <Eduard_Munteanu> Honestly I never tried them yet.
18:09:04 <Eduard_Munteanu> Ah.
18:09:48 <elliott> that definition of alternate is funky
18:10:25 <copumpkin> Eduard_Munteanu: http://snapplr.com/k2ht
18:10:45 <copumpkin> elliott: all of those definitions are funky if you haven't seen copatterns before
18:10:50 <Eduard_Munteanu> Hm, I see. I also find that Stream definition strange.
18:11:09 <copumpkin> why?
18:11:16 <Eduard_Munteanu> copumpkin: it isn't coinductive
18:11:17 <elliott> copumpkin: this is true
18:11:19 <elliott> copumpkin: i'm all funked out!!!
18:11:23 <copumpkin> Eduard_Munteanu: it is though
18:11:33 <copumpkin> it just doesn't use the sharp or a codata definition
18:11:35 <elliott> copumpkin: can't tell whether i hate this or love it
18:11:46 <copumpkin> elliott: I hope it works out, cause I don't like the sharp
18:11:55 <copumpkin> and this has the potential to make awkward definitions less awkward
18:12:01 <elliott> copumpkin: all i know about the sharp is that coq doesn't have it
18:12:04 <elliott> therefore it must be agda silliness
18:12:09 <Eduard_Munteanu> Ok, I clearly don't know something about copatterns.
18:12:18 <copumpkin> coq does some weird shit about coinduction in the first place
18:12:21 <copumpkin> or so I hear
18:12:30 <elliott> copumpkin: coq does all the weird shit
18:12:43 <copumpkin> Eduard_Munteanu: how come?
18:12:48 <rwbarton> I always thought this was the more sensible way to write definitions of codata
18:13:03 <copumpkin> yeah, I like it. But things like Colist become more awkward
18:13:07 <copumpkin> than with the other thing
18:13:10 <dolio> Coq does the same thing Agda originally did.
18:13:11 <shachaf> Colist is the coolest.
18:13:12 <copumpkin> so it might be nice to have both
18:13:37 <dolio> They just haven't changed anything since finding out that it breaks subject reduction and such.
18:14:02 <Saizan> i wonder where Idris stands there
18:14:19 <Eduard_Munteanu> copumpkin: I just find it odd you can declare a non-co datatype and copatterns magically make it coinductive.
18:14:23 <copumpkin> edwinb said he was replicating coq behavior
18:14:35 <rwbarton> is the unicode arrow the same as the -> arrow?
18:14:38 <dolio> rwbarton: Same here. But somehow that seems to be the minority opinion.
18:14:38 <copumpkin> Eduard_Munteanu: but a record like that is sort of coinductive in the first place
18:14:54 <rwbarton> dolio, not sure whether I would want to use it in practice
18:14:55 <copumpkin> Eduard_Munteanu: even if it doesn't say so with any keywords
18:14:59 <Saizan> Eduard_Munteanu: i think it's just assuming that recursive records are coinductive
18:15:00 <rwbarton> having never really tried
18:15:21 <copumpkin> Eduard_Munteanu: if you've read that paper on general coinduction, it talks about codata as being observable
18:15:31 <copumpkin> with observation functions and no structure
18:15:40 * Eduard_Munteanu is missing a lot of background, actually :(
18:17:15 <dolio> rwbarton: I strongly suspect it's nicer if you're committed to syntactically 'obvious', structural (co)recursion.
18:17:22 <dolio> Which is the case in Agda right now.
18:17:38 <dolio> Although, it gets rid of some of the nice stuff you can do with the delays version.
18:17:54 <dolio> Like having certain constructors of your data type be corecursive and others not.
18:18:05 <acowley> That copattern observation syntax is awesome
18:18:44 <Entroacceptor> e
18:18:50 <beaky> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
18:18:59 <beaky> when would I need that construct :D
18:19:18 <shachaf> Never.
18:19:21 <rwbarton> beaky: when you want to scare off Java programmers
18:19:27 <Eduard_Munteanu> Anyway, say I have a weird theorem for which I can provide an infinite coinductive proof. Would that mean I magically get a finite proof? Or does Agda somehow prevent me from doing that with copatterns?
18:19:48 <dolio> But for instance, I suspect that 'head fibs = 0 ; head (tail fibs) = 1 ; tail (tail fibs) = zipWith (+) fibs (tail fibs)' is 'obviously' correct in the same way that 'fib zero = zero ; fib (suc zero) = suc zeor ; fib (suc (suc n)) = fib n + fib (suc n)' is 'obviously' correct.
18:20:11 <Eduard_Munteanu> I guess I'm asking how it tracks coinductiveness in absence of musical notation.
18:21:06 <dolio> But the delay version doesn't work for that, because you have arbitrary functions messing up your guarded corecursive references.
18:21:33 <elliott> beaky: when you really need both semi-mutual recursion and history and to repeatedly apply a natural transformation as you get deeper into the functor
18:22:55 <__name__> Whgat does that even mean?
18:23:03 <__name__> *What
18:26:01 <beaky> so it's like a protected abstract virtual base pure virtual private destructor
18:26:52 <typoclass> beaky: __name__: afaik it was made up as a joke, to show that you can go overboard and end up with something very complicated that gives very little gain
18:27:21 <beaky> right
18:29:05 <elliott> i am pretty sure it was actually rather a parody of how others view the useful abstract concepts in haskell (and simultaneously self-parody by those who work with them)
18:29:06 <Eduard_Munteanu> beaky: http://comonad.com/reader/ for your daily scary stuff :P
18:29:11 <elliott> rather than a criticism of those abstract concepts
18:30:27 <shachaf> Cale: You fixed flip?
18:37:00 <byorgey> @type flip
18:37:01 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:37:12 <shachaf> Cale++
18:37:40 <Eduard_Munteanu> :t (.)
18:37:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:38:34 <Ralith> :t (id .)
18:38:36 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
18:38:42 <geekosaur> beware of lambdabot
18:38:51 <Ralith> rather
18:38:52 <geekosaur> :t (Prelude..)
18:38:53 <Ralith> :t (. id)
18:38:53 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:38:55 <lambdabot> forall a b. (a -> b) -> a -> b
18:40:15 <beaky> :t (***)
18:40:16 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:40:38 <Eduard_Munteanu> > {-# LANGUAGE NoImplicitCaleskell #-}
18:40:39 <lambdabot>   not an expression: `{-# LANGUAGE NoImplicitCaleskell #-}'
18:51:14 <herpladee> hey when i run my haskell applicataion i just get "Killed"
18:51:18 <herpladee> is there any way to figure out what happened?
18:51:35 <shachaf> strace!
18:51:52 <copumpkin> herpladee: what OS?
18:52:02 <herpladee> ubuntu
18:52:13 <copumpkin> hmm
18:52:28 * hackagebot gluturtle 0.0.36 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.36 (YoshikuniJujo)
18:56:16 <herpladee> how do i learn to interpret all that strace output
18:56:24 <herpladee> i mean i'm assuming that it's out of memory
18:56:30 <herpladee> but i have no idea how to confirm it
18:56:48 <shachaf> Look at the end.
18:56:51 <rwbarton> if it was killed by the oom killer then dmesg should say something about that
18:57:09 <herpladee> it does!
18:57:09 <herpladee> thanks
18:57:28 * hackagebot gluturtle 0.0.37 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.37 (YoshikuniJujo)
19:02:28 * hackagebot gluturtle 0.0.38 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.38 (YoshikuniJujo)
19:07:28 * hackagebot gluturtle 0.0.39 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.39 (YoshikuniJujo)
19:07:33 <MostAwesomeDude> Heh.
19:12:30 * hackagebot gnutls 0.1.4 - Bindings for GNU libgnutls  http://hackage.haskell.org/package/gnutls-0.1.4 (JohnMillikin)
19:17:34 <beaky> is foldl a catamorphism?
19:20:39 <byorgey> beaky: no
19:20:46 <byorgey> beaky: foldr is the catamorphism for lists
19:22:05 <byorgey> though you can implement foldl in terms of foldr (but it's tricky)
19:23:38 <beaky> why foldr but not foldl? aren't they the same?
19:24:24 <byorgey> beaky: no, they aren't the same
19:24:27 <jmcarthur> beaky: foldr is what you get if you simply replace the constructors
19:24:35 <byorgey> > foldr f z [a,b,c,d]
19:24:36 <edwardk> foldl f z xs = foldr (\a g r -> g (f r a)) id xs z
19:24:36 <lambdabot>   f a (f b (f c (f d z)))
19:24:45 <jmcarthur> beaky: that is, foldr f z replaces (:) with f and [] with z
19:24:46 <byorgey> > foldl f z [a,b,c,d]
19:24:48 <lambdabot>   f (f (f (f z a) b) c) d
19:25:00 <enkomax> in higher order functions section, how does sum' xs = foldl (\acc x -> acc + x) 0 xs  add 0 and xs on first iteration? I assume acc + x is 0 + list, or am i wrong?
19:25:07 <edwardk> foldr f z replaces each : with 'f' and [] with z
19:25:26 <edwardk> foldl requires 'as many parens' as there are functions to start working basically
19:25:34 <edwardk> er as may parens as there are :'s
19:25:36 <jmcarthur> > foldr (:) [] [a,b,c,d]
19:25:37 <lambdabot>   [a,b,c,d]
19:25:51 <shachaf> > foldr (+) 0 [a,b,c,d,e]
19:25:53 <lambdabot>   a + (b + (c + (d + (e + 0))))
19:25:56 <beaky> :t foldr
19:25:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:25:57 <jmcarthur> > foldl (:) [] [a,b,c,d] -- fail
19:25:58 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
19:26:13 <edwardk> > foldl (flip (:)) [] [a,b,c,d]
19:26:14 <lambdabot>   [d,c,b,a]
19:26:15 <beaky> :t foldl
19:26:16 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:26:43 <shachaf> foldl (flip jmcarthur)
19:26:45 <shachaf> (‚ïØ¬∞‚ñ°¬∞Ôºâ‚ïØÔ∏µ …πn…• á…π…ê…î…Øÿ∏
19:26:55 <edwardk> shachaf++
19:27:28 * hackagebot cakyrespa 0.0.27 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.27 (YoshikuniJujo)
19:27:47 <Nereid> > foldl (const 1) 0 [1..]
19:27:54 <lambdabot>   mueval: ExitFailure 1
19:27:54 <lambdabot>  mueval: Prelude.undefined
19:28:01 <Nereid> > foldl (const) 0 [1..]
19:28:04 <Nereid> heh.
19:28:05 <lambdabot>   mueval-core: Time limit exceeded
19:28:19 <Nereid> > foldl (const id) 0 [1..]
19:28:20 <jmcarthur> shachaf: if only i could make my nick unicode
19:28:24 <lambdabot>   mueval-core: Time limit exceeded
19:28:45 <typoclass> enkomax: what foldl does is, it pulls out each list element one by one. so the first calculation will be "0 + the_first_element_of_xs"
19:28:46 <unicode> works for me
19:28:51 <Nereid> oh yeah, duh.
19:29:00 <jmcarthur> scorcery!
19:29:14 <shachaf> How do you catch a unicode nick?
19:29:28 <shachaf> unic up on it
19:29:53 <enkomax> typoclass: oh so it feeds each element to lambda... ok makes sense, thank you, for some reason i was mapping xs directly to x
19:30:21 <typoclass> enkomax: don't worry :-)
19:32:07 <enkomax> see now that whole section makes sense
19:32:12 <enkomax> :P
19:39:47 <beaky> can you have unicode identifiers in haskell?
19:39:52 <Nereid> yes
19:39:59 <shachaf> Why don't you try it, beaky?
19:40:14 <beaky> how do I even enter unicode characters?
19:40:23 <Nereid> > let Œ± = 5 in Œ±^2
19:40:25 <lambdabot>   25
19:40:36 <shachaf> If you can't enter them, why do you care?
19:41:25 <typoclass> beaky: yes you can have them. if you need them only very occasionally, it's probably easiest to google for them and copy-paste from the symbol's wikipedia page or some such
19:42:20 <Nereid> > let {Áôæ = 100; ÂÖ´ = 8} in Áôæ + ÂÖ´
19:42:22 <lambdabot>   108
19:42:24 <Nereid> etc
19:43:23 <byorgey> beaky: you are entering unicode characters right now!
19:43:28 <Nereid> :-)
19:44:50 <typoclass> byorgey: yeah ... i bet when he says unicode characters, he means non-ascii unicode characters :-)
19:44:57 <byorgey> I know =)
19:46:25 <Eduard_Munteanu> Customers who bought unicode characters also bought: {-# LANGUAGE UnicodeSyntax #-}
19:47:15 <beaky> ah
19:47:25 <byorgey> Customers who bought unicode characters also bought: Agda
19:47:26 <Eduard_Munteanu> Or you can graduate to Agda. :P
19:47:29 <Eduard_Munteanu> Heh.
19:47:32 <byorgey> =)
19:47:52 <Nereid> I kind of like the appearance of everything in ascii.
19:48:27 <shachaf> edwardk: %s/ arent / aren't /g in the lens code, if you're into fixing that kind of thing.
19:48:38 <Nereid> I once briefly had a vim plugin that made -> display as ‚Üí and so on, but I got rid of it because I liked -> better.
19:48:52 <edwardk> shachaf: feel free to throw a patch at it
19:49:07 <edwardk> i'm definitely happy to have it fixed
19:49:25 <Eduard_Munteanu> Nereid: plugin? I just used a bunch of map commands in my vimrc to replace -> automatically when typed.
19:49:37 <Eduard_Munteanu> Oh, just display?
19:49:40 <Nereid> yes display
19:50:36 <shachaf> edwardk: http://slbkbs.org/lens-apostrophes.patch
19:50:40 <Eduard_Munteanu> I kinda feel like trying proportional fonts for programming sometime.
19:50:57 <Eduard_Munteanu> (might go well with unicode stuff)
19:51:01 <Fuuzetsu> -> looks superior
19:51:04 <edwardk> shachaf: bah now i have to remember how to apply an old school patch ;)
19:51:13 <Nereid> Eduard_Munteanu: I'd be worried about layout.
19:51:13 <Eduard_Munteanu> -> power!
19:51:24 <shachaf> edwardk: git apply?
19:51:47 <edwardk> shachaf: fair nuff =)
19:51:52 <Eduard_Munteanu> Nereid: yes, you kinda have to change your coding style, not sure how nice it'd be.
19:52:12 <shachaf> Man, the days of patch -i -p1 foo.patch were great.
19:52:56 <Eduard_Munteanu> shachaf: git format-patch FTW
19:53:13 <byorgey> ugh, and having patch barf because of different line endings, and getting the number after -p wrong, and ... no thanks =P
19:54:28 <edwardk> shachaf: patched
19:54:51 <shachaf> Hooray!
19:55:03 <shachaf> Wait, why am I the author?
19:55:07 <shachaf> :-(
19:55:11 <Nereid> lol
19:55:32 <byorgey> shachaf: why would you not be the author?
19:55:47 <shachaf> byorgey: Well, I wasn't the author for yesterday's patch...
19:56:08 <byorgey> oh.  I guess edwardk forgot the --author flag yesterday.
19:56:38 <shachaf> Now I'll look like a nitpicker in the git history!
19:56:56 <edwardk> i try to remember --author. i apologize if i forgot it on a more interesting patch )
19:56:59 <edwardk> ;)
19:57:47 <Eduard_Munteanu> shachaf: git format-patch FTW
19:57:50 <Eduard_Munteanu> :P
19:58:15 * shachaf prefers to "contribute" anonymously
19:58:29 <edwardk> fair nuff.
19:59:01 <shachaf> At any rate, most of lens makes sense to me now.
19:59:24 <edwardk> good =)
19:59:55 <edwardk> its really not that complicated of a library, i just kept riffing on the same pattern over and over
20:00:09 <shachaf> Yep.
20:00:45 <shachaf> Hmm, what's the point of May?
20:00:52 <shachaf> Isn't that Monoid instance the same as Maybe's?
20:06:42 <shachaf> edwardk: Travis-CI is telling me that my commit broke the build. :-(
20:06:59 <edwardk> heh, then fix the bug you didn't add ;)
20:07:14 <edwardk> i think there is a failing test case marking droppingWhile at the moment
20:07:16 <shachaf> edwardk: Oh, I have no idea what's going on.
20:07:32 <shachaf> Did you force-push?
20:07:46 <edwardk> you can view fixing droppingWhile as a test that you understand the library ;)
20:07:48 <edwardk> yeah
20:07:56 <edwardk> i was trying to remove the author flag and failed
20:08:04 <edwardk> then shrugged and moved on
20:08:17 <shachaf> "Fixed apostrophies" :-(
20:08:21 * shachaf sighs.
20:08:45 <shachaf> That's what I get for trying to help!
20:09:38 <edwardk> sorry. do you know how to --amend a patch and get it to change authors? i tried using --author with --amend to no success
20:10:06 <shachaf> You could just go back to the previous revision and apply the patch again.
20:10:23 <rwbarton> --reset-author or something
20:10:36 <typoclass> shachaf: i think the Maybe monoid has mempty = Nothing, while the May monoid has mempty = May (Just mempty)
20:10:47 <rwbarton> oh that doesn't do what you want
20:11:00 <shachaf> typoclass: Oh.
20:11:01 <typoclass> (let me just butt in on the off chance that i understand some miniscule part of lens)
20:11:09 <shachaf> thypoclass
20:11:13 <edwardk> shachaf: fixed
20:11:20 <edwardk> fixed fixed apostrophes
20:11:34 <shachaf> Hooray!
20:12:19 <enkomax> does foldr(*) allocate partial functions for entire list before folding it?
20:12:30 <enkomax> *foldr1 rather
20:12:39 <shachaf> enkomax: No.
20:12:51 <shachaf> enkomax: This is easy to figure out by foldr1ing an infinite list. :-)
20:12:58 <typoclass> shachaf: but you're right about the larger point :) a comment wouldn't hurt ... "Except for our mempty, this is the same as the Maybe instance from Data.Monoid"
20:13:16 <shachaf> typoclass: Send edwardk a patch!
20:13:24 <rwbarton> how can two Monoid instances differ only in mempty
20:13:25 <enkomax> shachaf: not seeing the connection
20:13:29 <shachaf> typoclass: Except that's not true.
20:13:33 <shachaf> typoclass: mappend is also different.
20:13:37 <rwbarton> good
20:13:49 <edwardk> is May my type?
20:13:59 <shachaf> Yes.
20:14:03 <edwardk> from where?
20:14:09 <shachaf> Lens.Internal
20:14:10 <typoclass> why are you people asking me things, i have no idea about either instance
20:14:22 <shachaf> I thought it was the same as Maybe's Monoid instance but typoclass pointed out that I'm silly.
20:14:23 <typoclass> it's here http://hackage.haskell.org/packages/archive/lens/3.0.5/doc/html/src/Control-Lens-Internal.html
20:14:37 <shachaf> edwardk: What was wrong with droppingWhile?
20:15:08 <edwardk> shachaf: it was just implemented wrong. doesn't work as designed. someone sent me a failing test case
20:15:17 <edwardk> i added the test case but haven't taken the time to fix it
20:15:23 <shachaf> Oh, it's a test.
20:15:41 <edwardk> yeah, TDD and all that
20:16:43 <beaky> @pl \x -> if x `rem` 15 == 0 then "FizzBuzz" else if x `rem` 3 == 0 then "Fizz" else if x `rem` 5 == 0 then "Buzz" else show n
20:16:43 <lambdabot> ap (flip if' "FizzBuzz" . (0 ==) . (`rem` 15)) (ap (flip if' "Fizz" . (0 ==) . (`rem` 3)) (flip (flip if' "Buzz" . (0 ==) . (`rem` 5)) (show n)))
20:16:50 <beaky> :t ap
20:16:51 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
20:17:39 <shachaf> Oh, droppingWhile is acting like filter.
20:25:47 <edwardk> shachaf: exactly
20:25:56 <edwardk> my test case sucked before so i didn't spot i'd done it wrong
20:26:12 <edwardk> its easy enough to fix i suppose
20:26:12 <shachaf> edwardk: Defining dropWhile as a foldr is tricky.
20:26:17 <edwardk> yeah
20:26:50 <edwardk> two tips: there is an email out there showing it as a paramorphism, and a monad reader article that covers the derivation in terms of foldr using foldr as a wimpy 'fix'
20:26:55 <rwbarton> @src dropWhile
20:26:56 <lambdabot> Source not found. Where did you learn to type?
20:27:24 <roconnor> I need a Streicher_K
20:27:31 <shachaf> edwardk: I found the email already. :-)
20:27:38 <shachaf> I also found a wrong definition equivalent to yours.
20:27:43 <edwardk> yep
20:27:58 <shachaf> Traversals are more awkward than lists.
20:28:04 <edwardk> its the one you get when you take a quick gander at takeWhile and try to flip it
20:28:11 <edwardk> you can foldrOf
20:28:13 <edwardk> instead of foldr
20:28:21 <shachaf> I guess this is a fold, not a traversal.
20:28:28 <edwardk> yep
20:29:01 <edwardk> can't be a traversal -- the user could change the number of targets by changing the answer to now match or fail the predicate
20:29:05 <shachaf> Right.
20:29:18 <edwardk> so you'd violate the traversal fusion law
20:31:06 <shachaf> Should probably have spanningOf, too.
20:33:24 <shachaf> edwardk: Is there ever a significant advantage to using folded instead of traverse, where either works?
20:33:56 <edwardk> shachaf: folds can sometimes be implemented more efficiently
20:34:59 <edwardk> i get a noticeable difference defining isClosed = all (const False) compared to say, isJust . traverse (const Nothing)
20:35:21 <edwardk> so i'd suspect yes
20:35:26 <shachaf> Ah, makes sense.
20:35:27 <edwardk> its all constant factor stuff though
20:38:10 <shachaf> edwardk: let dW p l f = fst . foldrOf l (\a r -> let s = f a *> snd r in (if p a then (fst r) else s, s)) (noEffect, noEffect)
20:38:23 <edwardk> that works?
20:38:27 <shachaf> Seems to.
20:38:40 <edwardk> looks like my quick attempt here, but fixed. i buy it
20:38:48 <lispy> hello
20:38:54 <shachaf> edwardk: That was modeled on your attempt. :-)
20:39:11 <shachaf> Actually I changed it more than I needed to.
20:39:26 <shachaf> -- droppingWhile p l f = fst . foldrOf l (\a r -> let s = f a *> snd r in if p a then (snd r, s) else (s, s)) (noEffect, noEffect)
20:39:26 <edwardk> oh i guess i did push that one didn't i?
20:39:38 <shachaf> -- droppingWhile p l f = fst . foldrOf l (\a r -> let s = f a *> snd r in if p a then (fst r, s) else (s, s)) (noEffect, noEffect)
20:39:47 <shachaf> It's just using fst in one place.
20:40:40 <edwardk> running test suite
20:40:52 <edwardk> ah
20:41:08 <edwardk> i just banged out the one that was there real quick before i had to head out the door, and didn't get back to it
20:41:09 <shachaf> Wait, that doesn't build?
20:41:32 <edwardk> doesn't build
20:41:57 <edwardk> Endo (f a, f a)
20:42:01 <shachaf> Oh, it needs a different cosntraint.
20:42:02 <edwardk> you need to change the signature
20:42:05 <shachaf> Right.
20:42:35 <edwardk> should i shachaf this one? it was less pedantic. =)
20:43:02 <shachaf> Hah, if you want.
20:43:14 <edwardk> toListOf (droppingWhile (<=3) folded) [1..6]'   expected: [4,5,6] but got: [2,3,4,5,6]
20:43:17 <edwardk> failed
20:43:31 <shachaf> Blah.
20:43:37 <shachaf> Wait, are you sure you made the change?
20:43:42 <shachaf> That looks like the old behavior of the function.
20:43:46 <roconnor> w00t, avoided needing Streicher_K by rephrasing my theorem.
20:44:13 <edwardk> paste the correct one
20:44:34 <shachaf> OK, let me just run the tests myself. :-)
20:45:18 <edwardk> =)
20:46:23 <shachaf> "toListOf (droppingWhile (<=3) folded) [1,6,1]" is supposed to be [], right?
20:46:48 <edwardk> droppingWhile (<=3) should drop the 1, then fail the predicate so [6,1] should be the answer
20:47:05 <shachaf> Oh, I read that as a 6 instead of a 3.
20:47:24 * shachaf sighs.
20:47:39 <shachaf> OK, tests pass.
20:47:46 <shachaf> droppingWhile p l f = fst . foldrOf l (\a r -> let s = f a *> snd r in if p a then (fst r, s) else (s, s)) (noEffect, noEffect)
20:52:51 <lispy> what are people up to?
20:53:03 <edwardk> shachaf: derp
20:53:47 <shachaf> lispy: Lenses, what else?
20:53:52 <lispy> heh
20:54:21 <lispy> I'm torn between reading, coding, and trying out bastion (the game)
20:54:38 <lispy> Whatever I do I want it to be low intensity
20:54:39 <shachaf> lispy: You should read lens code!
20:54:55 <shachaf> lispy: I've already found/fixed multiple bugs by doing it.
20:55:13 <lispy> I really should learn lens. I want to use lenses in my 6502 cpu simulator where I use a lot of record types
20:55:23 <typoclass> lispy: (most of which he introduced himself, but yeah)
20:55:25 <typoclass> ;-)
20:55:49 <edwardk> shachaf: perfect. it even handles the infinite case correctly
20:55:59 <lispy> says someone who's nick contains "typo" :)
20:56:21 <shachaf> "typo" is my new word for "type error", by the way.
20:56:42 <edwardk> shachaf: ready for the expert level puzzle?
20:56:57 <shachaf> Uh oh.
20:56:59 <edwardk> shachaf: extend holesOf so it works on infinite structures
20:57:03 <typoclass> lispy: i was just kidding :) he earlier sent a patch, there was a failing build, he thought it was his fault, then it turned out it wasn't
20:57:15 <edwardk> holesOf  :: LensLike (Control.Lens.Internal.Bazaar c c) a b c c     -> a -> [Control.Lens.Internal.Context c c b]
20:57:17 <lispy> typoclass: ah
20:57:22 <edwardk> you can replace Bazaar with a different type
20:57:30 <shachaf> edwardk: Plated is still on my plate. :-)
20:57:37 <lispy> I think I'll work on my lambda calculs
20:57:45 <lispy> I need to refactor a bunch of stuff in there
20:57:45 <shachaf> Oh, this isn't directly related to Plated.
20:57:59 <edwardk> shachaf: yeah its in there, but you don't need to understand the surrounding stuff in that module
20:58:05 <edwardk> in fact most of Plated is pretty self-contained
20:58:59 <koala_man> when parsec fails, can I get the user state at the point it failed?
20:59:29 <shachaf> edwardk: OK, well, I *will* need to understand Bazaar.
20:59:41 <shachaf> But it's probably not that complicated.
21:08:35 * lispy tries to downgrade his windows ghc to 32bit
21:08:44 <lispy> Anyone know if I need to uninstall my current GHC first?
21:09:09 <lispy> The path it's installed at doesn't mention 64bit, so I'm guessing yes
21:09:17 <shachaf> I'm pretty sure for Linuxghc you don't have to.
21:10:24 <lispy> trying to just install over it
21:10:40 <lispy> I find the 64bit version too buggy :(
21:10:45 <isturdy> On W7, I thought it was 32-bit installations that normally had a specific path (Program Files (x86)) or thereabouts--but I have no idea whether GHC complies with that.
21:10:50 <lispy> I hope they fix that in 7.6.2
21:11:09 <lispy> isturdy: it doesn't seem to comply with that
21:11:24 <lispy> C:\ghc\ghc-7.6.1 was the default install location
21:11:35 <lispy> I bet the mingw stuff it uses doesn't deal well with spaces in pathes?
21:12:05 <isturdy> Ah. The glories of the Windows Filesystem Hierarchy nonstandard.
21:12:27 <lispy> windows is like the wild west of OSes
21:12:38 <lispy> the file system is under marshal law
21:14:45 <shachaf> edwardk: What does it mean for holesOf to work on infinite structures?
21:15:07 <edwardk> shachaf: if you have an infinite list and ask for holesOf it spins forever
21:15:08 <shachaf> I haven't figured this code out yet, but e.g. map pos $ holesOf traverse (cycle "hello") seems to work.
21:15:32 <edwardk> at least that was what roconnor complained about
21:15:43 <shachaf> What's some code that fails with it?
21:16:07 <edwardk> hrmm
21:16:28 <shachaf> Ah, extract . head $ holesOf traverse (cycle "hello") just prints ["
21:16:30 <edwardk> i think you may have to ask roconnor =/ i'd expect what you just gave me to fail based on what he said before
21:16:33 <roconnor> shachaf: http://www.reddit.com/r/haskell/comments/11mnw5/wiggling_sums_a_somewhat_interesting_traversable/c6o0u5q
21:16:42 <edwardk> aha
21:16:45 <roconnor> shachaf: with  wiggleSum (Sum [10,20,...])
21:17:00 <edwardk> thats what it was
21:27:32 * hackagebot yesod-comments 0.8.0 - A generic comments interface for a Yesod application  http://hackage.haskell.org/package/yesod-comments-0.8.0 (PatrickBrisbin)
21:31:16 <lispy> my package db was really confused
21:31:22 <lispy> I had 2 of everything and nothing would install correctly
21:31:29 <meiji11> anyone know how to generate random undirected weighted graphs at a rate that will not make me want to tear my hair out?
21:31:37 <lispy> So, I think I have to delete my 64bit install to install the 32bit version
21:31:46 <Ralith> define 'random'
21:32:02 <meiji11> well, you have n vertices, labelled 1 through n
21:32:17 <lispy> uniform distribution?
21:32:27 <meiji11> it's the generation of weights/edges that's randomized
21:32:39 <Ralith> randomized how?
21:32:42 <meiji11> lispy, yes, I'm using uniformR from the MWC library
21:32:46 <meiji11> and a very naive algorithm
21:33:01 <meiji11> I thought its performance might be reasonable on graphs with fewer than 200,000 edges
21:33:03 <lispy> meiji11: have you profiled or do you otherwise know what is slow?
21:33:05 <meiji11> I was wrong.
21:33:21 <meiji11> lispy, well, I've tried. I can't seem to find the profiling package for mwc-random on cabal
21:33:23 <Ralith> there's a fixed probability of an edge existing between any two vertices?
21:33:27 <meiji11> and my cabal chops are not good, not sure how to find it..
21:33:35 <meiji11> there's a deb package for it, so it definitely exists
21:34:05 <meiji11> Ralith, I'm not sure. All I'm doing is pulling random vertices from a list, and splitting the list into thirds.
21:34:34 <Ralith> perhaps you should more precisely define the behavior you want?
21:34:35 <meiji11> the third list is the list of the weights, the heads of the first and second lists form an edge.
21:34:47 <lispy> meiji11: cabal install --reinstall --enable-library-profiling mwc-random
21:34:48 <meiji11> I can process the three lists with zipWith3, in that way, filtering out duplicates with nub.
21:34:54 <meiji11> it's all very naive and basic.
21:35:01 <meiji11> lispy, ah, ok, thanks..
21:35:10 <lispy> meiji11: repeat that for any libraries that cabal complains about.
21:35:27 <lispy> meiji11: I recommend just telling your cabal config to always enable library profiling
21:35:50 <Saizan> meiji11: nub has quadratic performance btw
21:36:13 <meiji11> Saizan, yeah, I should've considered that.. :P
21:36:48 <Ralith> selecting c*n random elements from a list of length n isn't very good either, if that list is large.
21:37:11 <Ralith> depending on how you do it--you could actually do it in one traversal.
21:38:06 <lispy> > fix show
21:38:07 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:39:43 <lispy> meiji11: fixing the algorithmic stuff is more important, but once you get that taken care of ghc has a nice profiler you can use
21:40:07 <meiji11> lispy, yes, I've used it.. it is indeed nice.
21:40:20 <lispy> ah, cool
21:40:54 <meiji11> oh boy, i haven't installed the profiling libraries for the vector library mwc-random uses.
21:41:27 <meiji11> how do I switch on --enable-library-profiling by default, as you mentioned?
21:42:08 <lispy> meiji11: vim ~/.cabal/config
21:42:31 <lispy> meiji11: it should be obvious once you get in there
21:42:32 * hackagebot yesod-links 0.2 - A typeclass which simplifies creating link widgets throughout your site  http://hackage.haskell.org/package/yesod-links-0.2 (PatrickBrisbin)
21:42:49 <lispy> meiji11: the default config has all the options with commented out defaults
21:42:58 <meiji11> lispy, that it is, my thanks..
21:43:42 <lispy> meiji11: you can go a step further and use cabal-dev. Then reinstalling these is as simple as blowing away the sandbox and and reinstalling the deps with --enable-library-profiling
21:44:07 <lispy> meiji11: http://www.reddit.com/r/haskell/comments/f3ykj/psa_use_cabaldev_to_solve_dependency_problems/
21:44:33 <meiji11> sorry for the zeal, by the way, i've taken neo citran for a cough and am loopy on the medicine right now.
21:45:11 <lispy> heh. I can't tell, FWIW
21:45:48 <lispy> cabal-dev ghci is not working anymore and it's making me crazy
21:59:03 * lispy puts the ghci back in cabal-dev
22:06:41 <dmj> Hi, maybe someone could help me
22:06:43 <dmj> I have show_table :: IO String
22:07:05 <Ralith> why is it in IO?
22:07:18 <shachaf> Ralith: Wow, a little aggressive, aren't you?
22:07:38 <Ralith> more curious; did it come across as aggressive?
22:07:39 <dmj> No, he's right, it looks ugly
22:07:43 <Ralith> if so, my apologies
22:08:02 <Ralith> how should I phrase it in the future?
22:08:02 <shachaf> Maybe it's just me. :-)
22:08:05 <dmj> I'm using import Database.MySQL.Simple
22:08:20 <Ralith> oh, that kind of table.
22:08:24 <rwbarton> wait for the actual question
22:08:27 <shachaf> Ralith: You might wait until you know what it actually is before phrasing anything. :-)
22:08:29 <typoclass> Ralith: adding a "hello" softens things :)
22:08:37 <Ralith> all good ideas!
22:08:58 <dmj> I'm able to read data out of the MySQL db, now I want to display it over Http via the Scotty web framework
22:09:02 <dmj> main = scotty 3000 $ do
22:09:07 <typoclass> @where hpaste
22:09:08 <lambdabot> http://hpaste.org/
22:09:18 <typoclass> dmj: if you have longer code, try hpaste ^^
22:09:36 <typoclass> (erm, "longer" in the sense of "more than 1 line" :-) )
22:10:22 <hpaste> dmj pasted ‚Äúscotty + mysql‚Äù at http://hpaste.org/76843
22:10:36 <dmj> viola
22:10:43 <dmj> voila?
22:11:04 <dmj> the problem is line 17
22:11:05 <shachaf> I don't know what the type of get is, but maybe you want "fmap text" instead of "text"?
22:11:05 <dmj> get "/" $ text $ show_table
22:11:24 <shachaf> However, even if that's the right answer, you should really understand *why* you want that. :-)
22:12:34 <dmj> you're right, I just need an intermediate function that will convert string to text
22:12:43 <Ralith> the type of 'scotty' would be informative as well
22:13:01 <dmj> can I hoogle a String -> Text on irc?
22:13:16 <dmj> IO String -> Text
22:13:23 <shachaf> @hoogle String -> Text
22:13:24 <Nereid> you don't want IO String -> Text.
22:13:24 <lambdabot> Data.Text.Lazy pack :: String -> Text
22:13:24 <lambdabot> Data.Text pack :: String -> Text
22:13:24 <lambdabot> Prelude read :: Read a => String -> a
22:13:33 <shachaf> You can also do it not-on-IRC. :-)
22:13:35 <typoclass> dmj: regarding your other remark, with all probability, show_table has to be in IO. "connect" and "query_" are in IO, and there's really no more pure stuff that you could pull out of that function
22:13:43 <shachaf> dmj: You should really understand how IO works before doing this, though.
22:13:44 <Ralith> you cannot safely convert an IO String -> Text because that would remove it from IO.
22:13:44 <typoclass> @where hayoo
22:13:44 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
22:13:50 <typoclass> dmj: ^^
22:13:58 <shachaf> dmj: Have you read an introduction to IO?
22:14:02 <shachaf> @google introduction to io in haskell
22:14:02 <Nereid> @where IO
22:14:04 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
22:14:04 <lambdabot> Title: Introduction to IO - HaskellWiki
22:14:04 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
22:14:49 <lispy> for other cabal-dev users: https://github.com/creswick/cabal-dev/pull/73
22:15:49 <typoclass> lispy: ooh, brilliant, thanks
22:15:55 <dmj> since mysql uses IO and Scotty uses IO are they two different IO contexts? or should I go read for 30 mins and then come back?
22:16:11 <Ralith> dmj: indeed you should.
22:16:36 <dmj> also, cabal-dev, is that the same as virthualenv?
22:16:46 <typoclass> dmj: no, there's only one IO :) and don't worry, it's really not hard to understand or use
22:17:02 <dmj> k
22:17:32 <typoclass> dmj: i think pretty much. virthualenv says it attempts to be easier to use
22:18:10 <dmj> i like it a lot. Works better with vim than sublime though
22:19:25 <dmj> thanks for the article, night
22:32:16 <hpaste> pshr pasted ‚Äúcompilation error‚Äù at http://hpaste.org/76844
22:32:37 <pshr> can any one please help me with this
22:32:38 <pshr> http://hpaste.org/76844
22:33:00 <pshr> I am a beginner in haskell trying to implement a simple power algorithm in haskell
22:35:04 <ion> ‚Äúpower x floor y/2‚Äù parses as ((((power) x) floor) y)/2
22:35:59 <spaceships> pshr: need an "in" somewhere after "let"
22:38:27 <ion> power _ 0 = 1; power x y | m == 0 = t^2 | otherwise = x * t^2 where { (d,m) = y `divMod` 2; t = power x d }
22:46:22 <hpaste> ion annotated ‚Äúcompilation error‚Äù with ‚Äúcompilation error (annotation)‚Äù at http://hpaste.org/76844#a76845
22:46:29 <Nereid> pshr:  also, you can't divide Integers with /
22:46:43 <Nereid> but instead of floor(y/2), use y `div` 2
22:49:23 <pshr> Thanks ion spaceships Nereid
23:43:41 * mgsloan thinks this is actually pretty neat http://www.reddit.com/r/programming/comments/122iby/another_nonargument_in_type_systems/c6sfg5n?context=3
23:53:22 <Ralith> Is there a MonadST?
