00:00:08 <Jupiter123> If I spend more time learning it
00:00:15 <Jupiter123> may be whole day as such
00:00:20 <Jupiter123> each day I mean
00:01:05 <Jupiter123> LIke you can call an expert to be on haskell
00:01:09 <Cale> Well, feel free to ask lots of questions here. Check out the tutorials, like http://learnyouahaskell.com/ and http://book.realworldhaskell.org/
00:01:45 <Jupiter123> I am going through books for learning as of now
00:02:05 <Jupiter123> And parallel with Philip Wadler book as well
00:02:28 <Jupiter123> His book I liked it much than the other two
00:03:14 <Saizan> i think there's some amount of time needed to abosrb new concepts and change the way you think about programs that can't be shrunken much by intensive work
00:03:56 <Jupiter123> ok. yes you are right
00:04:01 <lightquake> maybe i should associate each Entity with an id number and have entities refer to each other as their ID numbers
00:04:01 <Jupiter123> Yes, i wanted to ask few of the website in haskell.org or I think whole haskell website is built on Python isn't? Why don't the community used HAskell instaed
00:04:19 <Jupiter123> I mean the backend
00:04:30 <Cale> Jupiter123: Which Haskell website do you mean?
00:04:55 <Jupiter123> check its mailing list
00:04:57 <Cale> There's a MediaWiki which is running the main haskell.org page
00:05:01 <Jupiter123> its powered by python it says
00:05:03 <shachaf> Can you believe that the OS that runs the website is written in C?
00:05:13 <Cale> which of course is php
00:05:20 <Jupiter123> yup
00:05:26 <lightquake> Jupiter123: the mailing list program is written in python
00:05:35 <Jupiter123> yup
00:05:40 <lightquake> no point in writing a haskell one when we've got a perfectly serviceable one already
00:06:15 <Cale> Jupiter123: All the Hackage stuff is generated by a Haskell server, as is all the library documentation.
00:06:22 <Jupiter123> hmm may be but still
00:06:40 <Jupiter123> I meant with lightquake answer
00:07:04 <Cale> The main webserver itself is an Apache server
00:07:04 <Jupiter123> I wish I could see haskell everywhere :D
00:07:26 <shachaf> Feel free to write a Haskell mailing list program. Maybe they'll use it.
00:07:35 <Jupiter123> But getting fond of haskell, even when I know python
00:07:36 <Jupiter123> :D
00:07:57 <Jupiter123> YEs I would love to use haskell and do that for the community
00:07:59 <Jupiter123> it will be fun
00:08:22 <Cale> There's no really good reason that it has to be Apache/MediaWiki, and in the old days it used to be a MoinMoin wiki written in Python.
00:08:26 <shachaf> I think what language the mailing list software is written in is a very low priority for anyone in the Haskell community.
00:09:08 <Cale> I actually preferred the MoinMoin wiki because people actually used that more how a wiki was meant to be used
00:09:18 <lightquake> at least it's not emacswiki
00:09:23 <Jupiter123> hmm
00:09:34 <Cale> As soon as people see MediaWiki, they automatically start obeying Wikipedia's guidelines.
00:09:40 <Cale> Or some approximation of them
00:09:56 <rwbarton> should use gitit!
00:10:04 <Jupiter123> guys kindly let me know, how long lightquake , Cale, shachaf all you guys working on haskell
00:10:25 <Jupiter123> how many months or time you took to learn it
00:10:48 <Cale> Jupiter123: Well, you already know in my case.
00:11:02 <Jupiter123> Yes , pardon me, Cale (boy or girl)
00:11:07 <cmccann> Cale, [citation needed]
00:11:17 <Cale> I'm male
00:11:21 <Jupiter123> thank god
00:11:27 <Cale> lol, why?
00:11:29 * cmccann doesn't need a citation on that part
00:11:39 <Jupiter123> Yesterday I mention guys to someone on chat, and it turned a lady
00:11:45 <Jupiter123> :)
00:12:06 <Cale> Nobody really needs to have a gender online.
00:12:12 <shachaf> cmccann: I think he would be the one to get a citation.
00:12:26 <shachaf> Cale: I have several!
00:12:26 <Jupiter123> yes I believe too, but she was bit annoyed initially :)
00:12:48 <cmccann> you're all just words on my screen
00:12:53 <cmccann> words don't have gender (in English at least)
00:13:28 <shachaf> cmccann: Not yeltzooo
00:13:31 <Jupiter123> yup
00:13:34 <shachaf> yeltzooo isn't even words on your screen.
00:14:37 <Cale> shachaf: HEY, yeltzooo is *a* word, supposing you have a sufficiently flexible definition of word.
00:15:14 <rwbarton> not a word accepted by shachaf
00:15:17 <shachaf> Cale: Sorry, my words stop at 8 bytes (\0 terminated).
00:16:16 <Cale> Everywhere else, you'll see discussions like this dismissed with "ugh, semantics", while here, everyone's like "YAY, SEMANTICS!"
00:16:27 <Jupiter123> Semantics :)
00:16:35 <dada_cetacean> yes, why aren't we all philosophy majors
00:16:39 <Jupiter123> :D
00:16:49 <rwbarton> what is the denotation of life
00:17:04 <Cale> dada_cetacean: Because we're too busy being mathematics majors
00:17:26 <dada_cetacean> haha, too true
00:17:50 <Jupiter123> in Haskell.org to register it says send email nominolo at the email service from google
00:18:06 <Jupiter123> why is that happened
00:18:26 <Jupiter123> Should I send a word "nominolo" :D
00:18:43 <Cale> Jupiter123: It's assumed that you know about gmail
00:18:49 <Jupiter123> yes
00:19:01 <Cale> Jupiter123: and can figure out what his email address is from the given information :)
00:19:43 <Cale> Jupiter123: Spammers like to harvest email addresses which look like email addresses automatically by scraping them from websites, so it's written that way to cut down a bit on spam.
00:19:52 <cmccann> pf, why not just double-major in mathematics and philosophy
00:20:23 <Cale> cmccann: Because then that "Oh no, I'm sitting across from a philosophy major" feeling would never leave you.
00:20:47 <shachaf> Cale: Have you noticed how philosophy majors are never seen around mirrors?
00:21:41 <cmccann> though I suppose the intersection of philosophers and mathematicians would be mostly logicians
00:22:12 <cmccann> which both church and curry were, so I guess that fits well enough
00:22:22 <Cale> I had a particularly good philosophy of mathematics professor, who was formerly an algebraic topologist.
00:22:56 <shachaf> What a coïncidence -- my mathematics of philosophy professor used to be a topological algebraist.
00:23:16 <cmccann> must be the dual of Cale's professor
00:24:48 <shachaf> Duel? I don't think he was really into Galois theory.
00:25:01 <Cale> I'm slowly coming to the realisation that shachaf is actually one of the characters from a Douglas Hofstadter book.
00:26:56 <cmccann> Cale, hahahahaha
00:27:17 * cmccann finds that surprisingly plausible
00:28:10 <shachaf> It is a sobering thought that by the time Galois was my age, he had been dead for seven months.
00:29:13 <McJan_Flanders> VieiraN, sup!
00:29:46 <VieiraN> Excuse me?
00:30:00 <Cale> VieiraN: McJan_Flanders = Lajla
00:30:08 <Cale> If it helps
00:30:19 <McJan_Flanders> VieiraN, I heard you feel not that intelligent in the company of jokes regarding galouis theory
00:30:21 <McJan_Flanders> We're here to help.
00:30:35 <McJan_Flanders> Cale, you keep track of everything don't you?
00:31:04 <VieiraN> Well, I'll be dammed
00:31:38 <McJan_Flanders> What, you thougt the biggest ranter about C++ on #teamliquid is not in #haskell?
00:31:43 <McJan_Flanders> I'm everywhere dude.
00:32:16 <VieiraN> I wasn't quite expecting that
00:32:49 <McJan_Flanders> Why?
00:33:02 <VieiraN> Nevermind
00:41:54 <dada_cetacean> how do I write a type declaration for an if-then-else function? where f x = type A if True, type B if False
00:43:07 <shachaf> You don't.
00:45:25 <fmap> > let f :: Eq a => Eq b => a -> b -> Bool; f = undefined in 5
00:45:28 <lambdabot>   5
00:45:51 <fmap> Do type signatures written that way violate report? It seems only single optional context is  possible: http://www.haskell.org/onlinereport/haskell2010/haskellch4.html#x10-620004
00:45:53 <Saizan> you can do Bool -> a -> b -> Either a b
00:46:19 <shachaf> fmap: Violate?
00:46:23 <shachaf> Oh, I see.
00:46:27 <shachaf> No, it should be fine.
00:46:37 <shachaf> fmap: Think of it as Eq a => (Eq b => a -> b -> Bool)
00:46:55 <shachaf> You can even write Eq a => a -> Eq b => b -> Bool
00:47:55 <Saizan> depends on what type is in that grammar
00:49:02 <Saizan> and reading section 4.1.2 it doesn't include contexts
00:49:10 <shachaf> Oh, hmm.
00:49:57 <Cale> dada_cetacean: Perhaps you want  f :: Bool -> Either A B ?
00:50:14 <shachaf> You're quite right.
00:50:27 * shachaf bad #haskeller
00:52:03 <shachaf> I thought that was H98 for some reason.
00:52:06 <dada_cetacean> ghci keeps saying it "couldn't match expected type Either A B with actual type A"
00:52:43 <fmap> apparently I can even write f :: a -> Eq a => Bool
00:53:08 <fmap> Saizan: context is defined in 4.1.3
00:53:09 <shachaf> dada_cetacean: You should probably figure out what you're doing (and how Either works) before using it.
00:53:17 <Saizan> dada_cetacean: you've to wrap it in a Left or Right constructor
00:53:41 <shachaf> It's possible that you want Either but it's likely you don't.
00:54:34 <dada_cetacean> I'll just keep googling through the haskell wiki
00:55:01 <shachaf> dada_cetacean: You could also say what you're actually trying to do. :-)
00:57:11 <dada_cetacean> I'm trying to do the fizzbuzz exercise in haskell by defining a data type "Fizz" that includes integers and Fizz, Buzz, and FizzBuzz
00:57:36 <dada_cetacean> and then just taking a function that turns numbers that fit the criteria into fizz or buzz, and then mapping it over [1..100]
00:57:38 <shachaf> OK.
00:57:53 <shachaf> (That's probably way overkill for this problem, but anyway.)
00:58:02 <shachaf> What's your data type?
00:58:15 <dada_cetacean> Int | Fizz | Buzz | FizzBuzz
00:58:17 <dada_cetacean> is that bad?
00:58:37 <shachaf> You might want some more information for "Int".
00:58:42 <shachaf> Like which Int it is.
00:58:59 <Saizan> Int there is not interpreted as the type Int
00:59:17 <Saizan> but as a new data-constructor of name Int, unrelated to the type
00:59:29 <shachaf> Oh, yes.
00:59:58 <dada_cetacean> isn't the name Int restricted, though?
01:00:14 <Saizan> you've to use e.g. "I Int" there; so that you have a constructor I with a field of type Int
01:00:45 <donri> someone should do a Evolution of a Haskell Programmer with fizzbuzz
01:01:05 <Saizan> dada_cetacean: data-constructors and types live in different namespaces, if that's what you are asking
01:01:08 <shachaf> donri: No. Someone should delete fizzbuzz from the history of the Internet.
01:01:14 <donri> :)
01:03:42 <donri> also you should zomg optimize that and use Word8 instead of Int!
01:04:07 <Jafet> Word8 uses the same representation as Int.
01:04:22 <shachaf> But different operators.
01:04:43 <Cale> dada_cetacean: You can have a data constructor named Int, because that isn't taken -- there's no *value* with the name Int, only a *type*
01:04:57 <Cale> dada_cetacean: and types and values live in separate namespaces, so it's no problem
01:05:08 <Cale> (though it might be mildly confusing)
01:06:13 <Cale> ah, Saizan already said this :)
01:11:18 <donri> does a Word8 always have the same performance characteristics as an Int, then?
01:11:55 <donri> or maybe worse, even, because it has to do the modulo?
01:12:31 <Jupiter123> Quick question guys, is it mandatory to say that we must be know emacs or vim to be programmer
01:12:38 <atriq> No
01:12:52 <Jupiter123> or any simple editor works isn't
01:13:37 <atriq> It helps to have something more than Notepad
01:13:47 <rhubarb> Notepad works fine for me.
01:13:49 <Saizan> donri: maybe not if it gets unboxed
01:14:11 <donri> Saizan: yea that's what i'm thinking, but really i have no idea how these things work
01:14:16 <Saizan> donri: i think they are most interesting in arrays though, since they are packed
01:14:20 <Jupiter123> In here I have a discussion with some programmers regarding which editor they use
01:14:34 <shachaf> It doesn't actually "do the modulo" as a separate step, does it?
01:14:41 <shachaf> Exercise: Figure it out.
01:14:46 <atriq> I generally use Eclipse for bigger things
01:14:49 <Jupiter123> so some says _ - If you don't use Emacs, its worse.
01:14:52 <shachaf> Jupiter123: That's among the most useless discussions.
01:14:59 <rhubarb> I generally use emacs for bigger things.
01:15:00 <shachaf> You should stop caring and keep using whatever you're using.
01:15:03 <Jupiter123> haha you are right
01:15:18 <shachaf> Eventually you can learn another editor, but not while you're learning Haskell.
01:15:29 <Jupiter123> correc
01:15:31 <Jupiter123> correct
01:15:53 <donri> best learn vim, haskell and convert to dvorak all at once. trust me!
01:16:36 <Jupiter123> I am ok with any till I am doing something out of haskell
01:16:37 <Jupiter123> :D
01:17:03 <bartavelle> Hello, due to a bad design decision I have a pair of library that define the same type names, but some of them are actually distinct between the libraries
01:17:13 <atriq> Is it a rule that fmap _ _|_ = _|_?
01:17:24 <bartavelle> I would like to "read" from a file made with library A (with show) from library B
01:17:33 <bartavelle> to do this I did import qualified both
01:17:41 <bartavelle> and did something like
01:17:44 <Cale> Jupiter123: You can get by in Haskell with anything that'll convert tabs to spaces automatically. Apart from that, syntax colouring would probably be nice.
01:17:56 <bartavelle> a <- fmap read (readFile file) :: (A.type1, B.type2, B.type3)
01:18:00 <atriq> Ah, yes it is
01:18:09 <Jupiter123> yes
01:18:16 * bartavelle thinks about it
01:18:24 <bartavelle> this is not the problem actually, sorry for the noise
01:18:26 <Nereid> bartavelle: the :: should be the type of the thing to the right of the <-
01:18:32 <shachaf> > fmap id (undefined::a->a) `seq` ()
01:18:33 <lambdabot>   ()
01:18:41 <bartavelle> Nereid, yes I forgot IO
01:18:51 <shachaf> atriq: Laws and _|_ tend to be kind of iffy.
01:18:54 <Jupiter123> Can't we access files from the compiler
01:18:54 <bartavelle> the problem is that it's made from HashMap, and I defined read for this on both libraries
01:18:59 <atriq> shachaf, hmm
01:19:17 <Cale> atriq: certainly fmap id _|_ = _|_
01:19:40 <Cale> heh, "certainly"
01:19:43 <shachaf> Cale: Not for a lot of Functor instances in Haskell!
01:20:13 <shachaf> > fmap id (undefined::State Int Int) `seq` ()
01:20:14 <lambdabot>   ()
01:20:20 <shachaf> > fmap id (undefined::Cont r Int) `seq` ()
01:20:21 <lambdabot>   ()
01:20:34 <shachaf> And so on.
01:21:02 <Cale> Right
01:21:02 <atriq> Data.Proxy.Proxy from the tagged package, for instance
01:21:04 <Cale> functions :)
01:21:13 <atriq> fmap id undefined = Proxy
01:21:25 <atriq> That may be an incorrect instance, though
01:21:32 <donri> Jupiter123: there's EclipseFP btw if you want IDE features and an editor that doesn't have to be "learnt"
01:21:44 <shachaf> Curse you for having lifted functions, H98!
01:21:52 <Jupiter123> ok donri  thanks
01:21:52 <donri> IME it's been a bit difficult to set up, but might've improved since
01:21:53 <Cale> atriq: actually shachaf is right to begin with. We tend to just ignore laws when it comes to _|_
01:21:58 <atriq> Okay
01:22:27 <Cale> atriq: From a compiler author's perspective, it would be unreasonable
01:22:42 <donri> bottom line is, the laws become undefined
01:23:36 <atriq> :)
01:23:46 <shachaf> I think I came across a paper vaguely on the topic recently.
01:24:35 <donri> you could say that bottom is inherently unreasonable
01:24:37 <Cale> Was it titled "Fast and loose reasoning is morally correct"?
01:24:46 <shachaf> Cale: That's the one.
01:24:46 <Cale> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.59.8232
01:24:53 <shachaf> I like the title but I haven't read the paper yet. :-)
01:27:18 <Jupiter123> all of you are working on Haskell projectS? I am concerned about the funding of your projects, or just like open source projects
01:27:30 <atriq> I'm a hobbyist
01:27:42 <Jupiter123> :) thats nice, what about Cale
01:27:51 <Jupiter123> and shachaf
01:28:06 <Jupiter123> and donri
01:28:13 <atriq> I'm pretty sure Cale is magical
01:28:23 <Jupiter123> :) Cale is Guru Geek
01:28:25 <Jupiter123> :D
01:28:42 <Jupiter123> Zen may be
01:29:05 <Cale> Jupiter123: I did paid work on an iOS game in Haskell for a couple years, and at my new company, we're shortly going to be rewriting the backend of our webservice in Haskell (because it is a Grails clusterfuck at present), and are hiring some people to help with that.
01:29:49 <Jupiter123> Grails
01:29:57 <Jupiter123> webframework isn't?
01:30:21 <Jupiter123> or something else
01:30:28 <Cale> Yeah, it's this web framework in this poorly thought out and implemented programming language called Groovy
01:30:46 <Jupiter123> was it groovy or Ruby based
01:30:51 <Jupiter123> correct me if I am wrong
01:30:52 <shachaf> Cale: What's your new company?
01:31:55 <Cale> which is like, a bunch of guys who didn't know much about implementing programming languages decided they liked Ruby but wanted to run on the JVM, and designed a programming language that was kinda ruby-ish in some small ways, and kinda like Java without all that typesafety, and much slower
01:32:15 <Jupiter123> hmm
01:32:17 <Cale> (in terms of their terrible implementation which will hopefully be the only implementation ever of this language)
01:32:32 <atriq> Is it possible to compile Haskell to the JVM?
01:32:37 <Cale> shachaf: skedge.me
01:32:46 <atriq> Asks I, who knows very little about the JVM
01:33:04 <Cale> atriq: possible in principle, but nobody does it
01:33:07 <shachaf> atriq: Possible but not very well, they say.
01:33:12 <atriq> Okay
01:33:15 <shachaf> @google haskell jvm
01:33:16 <lambdabot> http://stackoverflow.com/questions/7261039/haskell-on-jvm
01:33:16 <lambdabot> Title: Haskell on JVM? - Stack Overflow
01:34:01 <Cale> It'd basically be a huge time sink for people that we'd really want to be working on other, more useful things.
01:34:09 <Jupiter123> I won't prefer Haskell on JVM
01:34:25 <Cale> Not to say that JVM support wouldn't be useful
01:35:57 <Cale> shachaf: As it happens, my boss is the same person.
01:36:13 <Cale> (Ryan Trinkle)
01:42:09 <Springwight> Is there a good source about implementing laziness on a software level?
01:43:03 <shachaf> @google spineless tagless g machine
01:43:04 <lambdabot> http://research.microsoft.com/pubs/67083/spineless-tagless-gmachine.ps.gz
01:43:25 <shachaf> Springwight: ☝
01:45:20 <Springwight> shachaf what was that letter?
01:45:36 <shachaf> 261D   WHITE UP POINTING INDEX     [☝]
01:45:45 <Springwight> ah
01:45:59 <Springwight> myis this just one implementation?
01:46:12 <Cale> yes
01:46:24 <Springwight> I've wanted more like, a general overview and different implementations
01:46:39 <Cale> It also (more briefly) discusses some other options
01:47:27 <atriq> Hmm
01:47:57 <shachaf> Springwight: It's not exactly the way GHC works, but it's good background.
01:47:58 <atriq> With Const, (), (->), Free, Cofree, Compose, Product and Coproduct, can you make any pure monad-y thing?
01:48:28 <shachaf> Unless you're looking for a higher-level idea of laziness, in terms of graph reduction or something.
01:51:05 <Springwight> I'm looking for a general overview on the subject of laziness. The core principles of implementing any sort of laziness, something like that.
01:51:10 <Springwight> And different ways to achieve this
01:51:14 <Cale> Hooray for that paper using the word "closure" correctly.
01:51:32 <Cale> (of course, it would, being written by actual language implementors)
01:53:36 <shachaf> Springwight: SPJ also wrote a book on the general topic that might be interesting.
01:53:47 <shachaf> That's earlier, though, from before Haskell.
01:54:02 <Jupiter123> when we run the ghci in the terminal, is it not possible to access the files created
01:54:31 <Jupiter123> I created a .hs file inside a folder(I use linux)
01:54:38 <Cale> Springwight: See page 11 of that paper for a good initial overview at least
01:54:41 <Jupiter123> and when I type ghci it leads me to prelude
01:54:50 <Springwight> ah nice
01:55:03 <shachaf> Jupiter123: I think most introductions to Haskell mention how to use ghci for this.
01:55:06 <Jupiter123> will it not possible to access the file created in prelude
01:55:18 <shachaf> Wait, "the file created"?
01:55:31 <Jupiter123> yes
01:55:50 <Jupiter123> what does this do than "ghc --make Test.hs -o test"
01:55:59 <Jupiter123> and :l ggg.hs does
01:56:05 <shachaf> ?
01:57:09 <Jupiter123> I Created a file consider hello.hs
01:57:22 <Jupiter123> inside it I gave main = putStrLn "Hello World"
01:57:33 <Jupiter123> and ghc --make Test.hs -o test
01:57:47 <Jupiter123> in the terminal
01:57:52 <Jupiter123> it creates a test file
01:58:02 <Jupiter123> which i can run it
01:58:08 <Jupiter123> saying ./test
01:58:19 <Jupiter123> which gets Hello World
01:58:25 <Cale> right
01:58:41 <Cale> and if you do  ghci Test.hs
01:58:44 <Cale> and then type main
01:58:48 <Cale> what do you get?
01:59:33 <Jupiter123> I get main>
01:59:45 <Cale> type main at the prompt
02:00:18 <Jupiter123> didn't get you
02:00:35 <Jupiter123> ok
02:00:37 <Jupiter123> got it
02:00:42 <Cale> okay :)
02:00:44 <Jupiter123> it says Hello World right
02:01:07 <Cale> now, you might have noticed when ghci loaded the file, it probably said that it loaded it in compiled mode
02:01:21 <Cale> which means that it loaded the compiled .o/.hi instead of the .hs file
02:01:31 <Jupiter123> yes
02:01:43 <Cale> This will mean that things run faster in general, but also means that you can only access things which were exported by the module
02:02:34 <Jupiter123> so if we write a new file having square x = x + x
02:02:44 <Jupiter123> should we say square or x
02:02:45 <Jupiter123> ?
02:02:59 <Jupiter123> let me check
02:03:11 <Cale> square will be defined
02:03:15 <maukd> > let square square = square * square in 4
02:03:16 <lambdabot>   4
02:03:19 <maukd> either works
02:03:23 <Cale> but you'll want to apply it to some value
02:03:36 <Jupiter123> got it
02:03:47 <Jupiter123> yes you are right
02:04:04 <Jupiter123> i did mention square 3  as such
02:04:30 <Cale> maukd: that is somewhat perverse :)
02:05:17 <maukd> :t let f f f = f in f
02:05:18 <lambdabot>     Conflicting definitions for `f'
02:05:18 <lambdabot>     Bound at: <interactive>:1:6
02:05:18 <lambdabot>               <interactive>:1:8
02:05:37 <shachaf> typedef int x; x x(x x) { return x; }
02:05:39 <maukd> :t let f = \f f -> f in f
02:05:41 <lambdabot>     Conflicting definitions for `f'
02:05:41 <lambdabot>     Bound at: <interactive>:1:9
02:05:41 <lambdabot>               <interactive>:1:11
02:05:46 <maukd> :t let f = \f -> \f -> f in f
02:05:47 <lambdabot> forall t t1. t -> t1 -> t1
02:06:27 <Feuerbach> maukd: you can't bind the same variable multiple times in the same pattern
02:06:44 <Cale> I think nonlinear patterns were actually implemented at one point. I think not for Haskell proper, but perhaps Miranda.
02:07:08 <Cale> i.e. you write f x x = 0, and this applies only when the parameters are equal
02:07:16 <maukd> Feuerbach: but it's not the same pattern
02:07:32 <shachaf> Feuerbach: Just another hole in the «\x y -> ...» -> «\x -> \y -> ...» myth!
02:07:49 <maukd> currying is a scam
02:07:52 <jaj> Cale: so you can abuse the language to solve equations
02:07:52 <Jupiter123> I got an error "<interactive>:1:1:    Ambiguous occurrence `signum'   It could refer to either `Main.signum', defined at test2.hs:1:1 or `Prelude.signum', imported from Prelude"
02:07:53 <Feuerbach> maukd: right, that wasn't very precise
02:07:56 <shachaf> Cale: There is trickiness involved in that.
02:08:21 <Cale> i.e. you desugar that to  f x y | x == y = 0
02:09:01 <maukd> Cale: but do you use x or y in the body?
02:09:39 <Cale> maukd: Use one or the other randomly and punish people who write bad Eq instances.
02:09:56 <shachaf> Cale: E.g. http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/PAGES/065.HTM
02:10:27 <maukd> Cale: it's not necessarily bad
02:10:58 <Cale> shachaf: right
02:11:04 <maukd> all you need for making the difference matter is non-strictness
02:12:23 <Cale> shachaf: Yeah, that was actually where I first read about this
02:14:31 <Jupiter123> Guys what you think of having an irc which starts with tutor on xchat who discusses about a specific book for a week, and that be mentioned on haskell.org
02:14:50 <Jupiter123> and who teaches online about haskell with a book
02:15:26 <Cale> Are you volunteering?
02:15:34 <Jupiter123> I am ready
02:15:35 <Jupiter123> :D
02:15:51 <Jupiter123> would you teach
02:15:53 <Jupiter123> :)
02:16:06 <Jupiter123> a simple basics of haskell as such
02:16:17 <Cale> Oh, I meant you teach :)
02:16:28 <Jupiter123> yes sure If I knew haskell :D
02:16:53 <Cale> I teach things to people here all the time
02:17:00 <Cale> but I don't structure it so much
02:17:10 <Jupiter123> I can do it for you
02:17:11 <Jupiter123> :D
02:17:17 <Jupiter123> I mean as basics
02:17:28 <Feuerbach> maukd: "The set of patterns corresponding to each match must be linear—no variable is allowed to appear more than once in the entire set." (Haskell 2010 report, p.52)
02:17:30 <Jupiter123> a lists of things cover on a day on a specific book which you choose
02:17:34 <Feuerbach> that's the precise statement
02:17:43 <Jupiter123> and group who would learn from you
02:18:07 <Jupiter123> through xchat and programming the codes parallel
02:18:11 <Cale> Jupiter123: I'd prefer not to use a book
02:18:29 <Jupiter123> its tutor way how he wishes to :-)
02:18:38 <Jupiter123> not mandatory as book
02:19:25 <Jupiter123> Since that how I have come across in Python
02:19:30 <Jupiter123> learning
02:19:46 <Jupiter123> I wish we had similar or more nice in Haskell
02:20:12 <Cale> This channel is full of people who answer beginner questions
02:20:26 <Jupiter123> a separate IRC each week which teaches haskell for an hour or so giving the examples and people work over it interacting and clearing doubts
02:20:32 <Jupiter123> yes i know
02:20:49 <Jupiter123> but I feel, sometimes the questions come repeated I guess
02:20:57 <maukd> a separate IRC each week, and every month a new HTTP!
02:20:59 <path[l]> is there an online courselike coursera or something yet that does haskell
02:21:00 <Cale> I actually like this :)
02:21:13 <Cale> I answer the same questions over and over, and I get better at answering them
02:21:13 <Jupiter123> or we can have this irc itself
02:21:16 <hiptobecubic> Jupiter123, you don't really need that here because there isn't the same "fuck you go learn it yourself" kind of attitude that a lot of channels seem to have
02:21:17 <Jupiter123> which does that
02:21:23 <shachaf> This in general or this right now?
02:21:29 * shachaf can't take this any more. :-(
02:21:42 <maukd> and a new TCP every christmas
02:21:50 <hiptobecubic> with packets
02:21:50 <Jupiter123> :D
02:22:23 <Jupiter123> yes you are right Cale  in someway
02:22:27 <shachaf> hiptobecubic: I think this channel could use a little more of that attitude, except maybe more polite.
02:22:49 <shachaf> Learning to figure things out for yourself is way more valuable than most things people in #haskell can teach you.
02:22:53 <Cale> Eventually I will probably write a book
02:23:00 <Jupiter123> :D
02:23:29 <hiptobecubic> shachaf, true. But I can't say the questions people ask in here are anywhere near as bad as, for example, C++ or Python
02:23:37 <Jupiter123> I would buy that book
02:23:40 <Jupiter123> :)
02:23:57 <shachaf> It's pretty bad some of the time.
02:24:14 <Jupiter123> haha shachaf is right
02:24:24 <Jupiter123> since I faced it in python
02:24:24 <hiptobecubic> there are always people who spoil it, yes :)
02:24:49 <hiptobecubic> but for them @lyah is usually all anyone says i think
02:26:29 <Jupiter123> my words was just an opinion Cale , not as such that it should
02:26:43 <Cale> Jupiter123: yeah, I know :)
02:27:50 <Jupiter123> since, recently I added Pycon in India, I found few guys who find it difficult to understand C, so I was discussing with them to have a forum as such which does based on the idea I shared with you all right now
02:28:24 <Cale> Jupiter123: If there were a bunch of people at the same point in learning, a study group would make sense, and I'm sure you could get people here to teach the group.
02:28:31 <Jupiter123> I used to do it on basecamp as well such event
02:28:56 <Cale> But generally we don't mind explaining things one-on-one. In fact, questions are often answered by multiple people at the same time :)
02:28:58 <Jupiter123> yes, I will try to interact on mail with the haskell team regarding this
02:29:40 <Jupiter123> yes, this is nice, but when the people who wants to learn increase, i have see similar questions and delay in reply in basecamp
02:30:03 <Jupiter123> like probably after 2-3 years, there may be millions who wants to learn haskell
02:30:04 <Jupiter123> :D
02:30:09 <Jupiter123> in that perspective :)
02:30:13 <shachaf> I hope not.
02:30:22 <Jupiter123> :D I hope it happens :D
02:30:28 <shachaf> Jupiter123: Why do you want to learn Haskell?
02:31:02 <Jupiter123> I don't know, I like it the way it is generic
02:31:42 <Jupiter123> more like equations
02:32:05 <shachaf> Where did you come across it?
02:32:27 <Jupiter123> lamba programming in python
02:33:06 <Jupiter123> it seams shachaf didn't like the idea :)
02:33:35 <atriq> Messing with Lambda Calculus is easier in Python than Haskell due to type-checky things
02:33:50 <atriq> However, Haskell's lambda calculus is indisputably better
02:34:02 <Ralith> plenty of people manage to dispute it anyway
02:34:08 <Jupiter123> May be till I come across that chapter
02:34:23 <Jupiter123> I am going slow right now
02:35:26 <imeredith> Its slow learning - at least it was (is) for me - but i dont think there is really any silver bullet apart from doing, failing, and doing again
02:35:29 <atriq> Haskell's is lighter weight (lambda var: exp vs \var -> exp) and allows pattern and multi-line expressions (like do notation)
02:36:00 <imeredith> ie in general how learning is done
02:36:18 <Jupiter123> I don't know what you guys are going through  , but I am loving it till now :D
02:37:39 <atriq> At the moment, I'm trying to encode GEDCOM in Haskell
02:37:54 <atriq> At the same time as trying to learn what all this GEDCOM means
02:38:30 <atriq> This is especially bad because I'm awful at naming things, especially things I don't know much about
02:38:54 <shachaf> atriq: Try "george".
02:39:12 <atriq> There are two constructors for the GedcomFamilyEventStructure type called "GedcomIDontEven" and "GedcomApparentlyIDoEven"
02:40:24 <imeredith> atriq: oh yeah im awful at naming things too - i end up after a few others with "a" "b" "aaa" "asdf" etc - and then have to go back over it
02:40:52 <atriq> I try to put as much info as possible into names
02:41:26 <imeredith> well, i would apart from that i dont have a good idea of how to compose the program so i end up changing things a lot
03:01:07 <hvr> rotfl...
03:01:14 <hvr> (sorry, wrong #)
03:07:08 <Jupiter123> why is import IO
03:07:11 <Jupiter123> used
03:07:23 <Jupiter123> and "main = do "
03:07:38 <Jupiter123> and "  hSetBuffering stdin LineBuffering
03:07:40 <Jupiter123> "
03:08:15 <Jupiter123> and is name <- getline are keywords?
03:08:53 <Jupiter123> module Main
03:08:53 <Jupiter123>         where
03:08:53 <Jupiter123> import IO
03:08:53 <Jupiter123> main = do
03:08:54 <Jupiter123>         hSetBuffering stdin LineBuffering
03:08:54 <Jupiter123>         putStrLn "Please Enter your Name:"
03:08:55 <Jupiter123>         name <- getLine
03:08:58 <Jupiter123>         putStrLn ("Hello, "++name++", how are you")
03:09:02 <Jupiter123> "Above progrm"
03:09:28 <maukd> don't paste code into the channel
03:09:35 <Jupiter123> ok. I am sorry for that
03:09:46 <maukd> 'import IO' is generally not used anymore
03:09:52 <Jupiter123> oh
03:09:55 <wto> Jupiter123: use this service for pasting code: http://hpaste.org/new/haskell
03:09:55 <maukd> 'import System.IO' is preferred
03:10:05 <Jupiter123> ok thanks a lot
03:10:18 <maukd> getLine isn't a keyword, it's defined in a library
03:10:27 <maukd> "<-" is built into the language, though
03:10:32 <Jupiter123> What both does import IO and why now it is import System.IO
03:10:57 <maukd> someone thought it would be cool to allow '.' in module names
03:11:20 <Jupiter123> so IO is module name
03:11:27 <maukd> and now we have pseudo-hierarchical modules like Data.List, System.IO, System.Environment, etc
03:11:52 <Jupiter123> why is that pseudo hierarchical modules
03:11:54 <Jupiter123> what that means
03:12:08 <maukd> (the old names are just List and IO)
03:12:19 <maukd> ((there was no Environment module back then))
03:12:27 <Jupiter123> oh import List, import Environment as such you mean
03:12:58 <Jupiter123> now it is import Data.List and import System.Environment?
03:13:01 <Jupiter123> is it correct
03:13:06 <maukd> yes
03:13:26 <Jupiter123> how do we know it is system.environment not Data... ?
03:13:29 <maukd> it looks like a hierarchy because you have names such as Control.Concurrent.STM.TVar
03:13:52 <maukd> which belongs in Control.Concurrent.STM, which belongs in Control.Concurrent
03:14:00 <Jupiter123> oh ok ok
03:14:04 <maukd> but that's really not true because the '.' is just another character in the name
03:14:36 <Jupiter123> so what does System.IO do in that simple program
03:14:51 <Jupiter123> gets putStrLn and getLine to work?
03:14:55 <maukd> provides hSetBuffering, stdin, LineBuffering
03:14:58 <Jupiter123> is it correct?
03:15:00 <maukd> @index getLine
03:15:00 <lambdabot> System.IO, Prelude
03:15:15 <atriq> Hmm
03:15:26 <maukd> getLine and putStrLn are also in System.IO, but they're re-exported by the Prelude so they're already there
03:15:30 <atriq> A Control Lens setter seems more powerful than a Data Lens setter
03:15:46 <Jupiter123> ok
03:15:51 <atriq> (b -> b) -> a -> a vs. a -> b -> a
03:16:04 <Jupiter123> why is that module Main
03:16:11 <Jupiter123> and again we get main = do
03:16:18 <Jupiter123> both Main and main
03:16:38 <maukd> because what's bound to Main.main is executed automatically when the program starts
03:16:48 <atriq> When an application is compiled, GHC finds the Main module and the main function within it, and that's what execution starts with
03:16:53 <hpaste> Jupiter pasted “program” at http://hpaste.org/75899
03:16:55 <maukd> you don't even have to write 'module Main where'
03:17:12 <maukd> if there is no module declaration, haskell assumes you mean 'Main'
03:17:14 <Jupiter123> oh
03:17:54 <Jupiter123> do is keyword is it
03:18:03 <maukd> yes
03:18:14 <maukd> line 6 looks useless, btw
03:18:43 <Jupiter123> can we just write like import System.IO and than main = do
03:18:56 <Jupiter123> than declaring module Main where
03:19:10 <maukd> yes
03:19:17 <maukd> no
03:19:18 <Jupiter123> Brilliant :)
03:19:22 <Jupiter123> oh NO
03:19:25 <Jupiter123> oh
03:19:26 <Jupiter123> o
03:19:27 <Jupiter123> ok
03:19:28 <maukd> by "than", do you mean "then"?
03:19:44 <Jupiter123> only import IO
03:19:46 <Jupiter123> main = do
03:19:49 <Jupiter123> like that
03:19:53 <maukd> that works
03:19:58 <Jupiter123> without declaring module Main where
03:20:16 <Jupiter123> what is this hSetBuffering does
03:20:19 <maukd> basically, the first thing in a file has to be a module declaration. if it doesn't start with 'module', the compiler assumes 'module Main where'
03:20:24 <Jupiter123> and stdin LineBuffering
03:20:45 <maukd> it's a call to the hSetBuffering function, passing it stdin and LineBuffering as the arguments
03:21:23 <maukd> stdin is an IO handle representing "standard input"
03:21:30 <Jupiter123> ok
03:21:36 <Jupiter123> why hSet?
03:21:37 <maukd> there are three predefined IO handles: stdin, stdout, and stderr
03:22:06 <maukd> stdin is usually your keyboard, while stdout and stderr are the screen (in your terminal)
03:22:15 <maukd> but this can be changed
03:22:23 <Jupiter123> hmm
03:22:26 <absence> is there a more concise way to write "r { something = (+1) . something $ r }"?
03:22:41 <maukd> absence: lenses :-)
03:23:04 <nand`> something +~ 1 -- lenses :)
03:23:15 <Jupiter123> so what hSetBuffering does
03:23:18 <absence> maukd: ah. i was wondering when they'd come in handy ;) thanks
03:23:27 <Jupiter123> pulls getLine keyword request
03:23:32 <maukd> Jupiter123: every IO handle has a "buffering mode": unbuffered, line buffered, or block buffered
03:23:43 <Jupiter123> ok
03:23:50 <maukd> hSetBuffering changes the buffering mode of an IO handle
03:23:59 <maukd> but I can't explain why it's in this program because it has no effect
03:24:08 <maukd> stdin is already line buffered by default
03:24:15 <absence> nand`: is that for a particular lens package? (if there are more than one)
03:24:28 <nand`> it's for ‘lens’, yes
03:24:30 <Jupiter123> so what can we write instead
03:24:45 <maukd> you can simply remove that line
03:25:02 <Jupiter123> let me comment it and check
03:25:03 <absence> nand`: great, i'll check it out!
03:25:29 <donri> absence: (that's the 'lens' package, btw)
03:25:36 <donri> oh, nand` already said
03:25:37 <Jupiter123> yes it works
03:27:09 <Jupiter123> so putStrLn is like Printf and getLine is like Scanf as in C , is it right?
03:27:19 <maukd> no
03:27:25 <Jupiter123> oops
03:27:29 <Jupiter123> gone wrong again may be
03:27:30 <maukd> putStrLn is like puts and getLine is like gets
03:27:30 <atriq> ...Ish
03:27:42 <Jupiter123> hmm
03:27:46 <atriq> If you've underestimated the power of printf and scanf
03:27:48 <maukd> except gets is horribly unsafe, and getLine isn't
03:28:02 <Jupiter123> yup
03:28:06 <maukd> atriq: reading a line with scanf is highly non-trivial
03:28:11 <donri> why aren't they called putLine or getStrLn?
03:28:11 <klr> hi, is it dangerous to learn haskell as first language?
03:28:12 <Jupiter123> :D
03:28:23 <atriq> maukd, oh yeah.
03:28:23 <maukd> klr: no
03:28:35 <atriq> My entire knowledge of the C programming language is very small
03:29:20 <klr> maukd: so, is there none disadvantages/advantages with learning haskell first?
03:29:41 <Jupiter123> so define a name which takes the putStrLn and same PutStrLn with ++name++ gets us the output
03:29:43 <maukd> char buf[100]; if (scanf("%99[^\n]", buf) == 1) { /* consume \n, use buf */ } else { /* handle errors */ }
03:30:06 <maukd> klr: learning Haskell first is probably easier (for understanding Haskell, that is)
03:30:08 <Jupiter123> I am wrong somewhere to catch this
03:30:09 <atriq> klr, it makes you realise how horrendously inadequate every other programming langyage is
03:30:25 <atriq> Just like a lot of other programming languages do
03:30:35 <maukd> Jupiter123: do you know any other programming languages?
03:31:01 <Jupiter123> why is that question
03:31:01 <klr> armlesshobo and maukd thanks for the information
03:31:24 <hpaste> jjauhien pasted “Test” at http://hpaste.org/75902
03:32:20 <Jupiter123> yes i do know
03:32:27 <atriq> Yeah, I don't know any other programming languages because Haskell's so unconventional being a good Haskell programmer is a bad Almost Everything Else programmer
03:32:42 <osfameron> hehe
03:32:45 <atriq> So, I'm just like "aaargh! Mutable variables! Are you insane!?"
03:32:46 <Jupiter123> :)
03:32:53 <maukd> Jupiter123: which ones?
03:33:08 <Jupiter123> C, Python, Ruby
03:33:12 <atriq> "Why is this IO here? That's a ridiculous place to have IO!"
03:33:15 <Jupiter123> as you said puts and gets
03:34:01 <maukd> print "Please Enter your Name:"; name = raw_input(); print "Hello, "+name+", how are you"
03:34:13 <maukd> (that should be python)
03:34:18 <Jupiter123> yrd
03:34:20 <Jupiter123> yes
03:34:38 <Jupiter123> now raw_input we don't use it in new version
03:34:53 <Jupiter123> whatever I got what you are giving the relation
03:35:08 <maukd> oh yeah, I think it's just input() in python3
03:35:13 <Jupiter123> :)
03:39:12 <Jupiter123> its seams python now
03:39:13 <cornihilio> I'm trying to use the trace command and print out the type of a variable that I do not know. What is the best way of doing that?
03:39:13 <Jupiter123> :D
03:39:25 <Jupiter123> hehe
03:39:37 <jjauhien> @index zip
03:39:37 <lambdabot> Data.List, Prelude
03:40:25 <Athas> cornihilio: The trace command?  In GHCi?
03:40:37 <maukd> cornihilio: put a type annotation in, look at the error message the compiler spits out
03:41:41 <Athas> cornihilio: alternatively, if you set a breakpoint (using :break), it will print the type of bindings in scope.
03:42:05 <Jupiter123> oops yes maukd , thanks for now . will trouble you when the next program i'm working won't execute hehee :D
03:42:19 <donri> compile ghc from git and use type holes ;)
03:42:35 <Athas> That said, if your code compiles, but malfunctions for a reason you suspect is due to complex type inference... then your program is probably too complicated.
03:42:59 <JoshuaA_> Hey guys, syntastic in vim is telling me 'Use ***', but I have no idea what this means and it seems impossible to google this (what I presume to be) function. Any ideas?
03:43:21 <wto> @type (***)
03:43:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:43:33 <maukd> JoshuaA_: hoogle it
03:43:35 <donri> JoshuaA_: those are from hlint
03:43:56 <donri> JoshuaA_: they're suggestions for how to potentially make the code simpler or more idiomatic
03:44:05 <donri> JoshuaA_: they can be safely ignored, though
03:44:07 <shachaf> (***) :: (a -> b) -> (c -> d) -> (a,b) -> (c,d)
03:44:09 <wto> ...or less readable...
03:44:22 <donri> wto: thus 'potentially' :)
03:44:58 <JoshuaA_> donri: yeah, I understood that :) I was just unsure about *** and couldn't google it. maukd: thanks for suggesting hoogle!
03:45:41 <wto> I think first and second is the arrow functions that I've used the most.
03:45:47 <wto> s/is/are
03:46:15 <donri> i find myself using &&& from time to time
03:48:28 <fmap> wto: there is lens for that
03:50:24 <wto> fmap: instead of first and second you mean?
03:50:50 <shachaf> (_1 %~), I guess
03:51:03 <fmap> wto: yep
03:52:07 <donri> assuming the function arrow ;)
03:52:12 <donri> also fmap for second
03:52:36 <fmap> who uses other arrows anyway
03:53:11 <hpaste> Jupiter pasted “I got a parse error ” at http://hpaste.org/75904
03:53:14 <Jupiter123> test5.hs:14:19: parse error on input `doGuessing'
03:53:15 <Jupiter123> Failed, modules loaded: none.
03:53:18 <Jupiter123> I got this error
03:53:27 <Jupiter123> Could anyone let me know where I am wrong
03:55:11 <maukd> Jupiter123: your indentation is wrong
03:55:18 <Jupiter123> oh
03:55:22 <donri> Jupiter123: i think if you have "do bla" on one line, the next line must line up with "bla" if it's part of that do
03:55:32 <maukd> doGuessing should be aligned with putStrLn in the line above
03:55:42 <maukd> donri: not just if it's on one line
03:55:59 <maukd> the next token after 'do' determines the base indentation of the following block
03:56:14 <donri> maukd: well if you have a line break directly after 'do', you don't have to line up with 'do', i meant
03:56:26 <maukd> you never have to line up with 'do'
03:56:40 <maukd> it's always the thing after 'do'
03:57:35 <donri> Jupiter123: also, `do putStrLn "You Win"` is the same as simply `putStrLn "You Win"`
03:57:49 <donri> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
03:58:54 <absence> what's the main difference between Control.Lens and Data.Lens?
04:00:22 <donri> absence: a lens can change the type in Control.Lens
04:00:49 * hackagebot haskell-ftp 0.1.0.0 - A Haskell ftp server with configurable backend.  http://hackage.haskell.org/package/haskell-ftp-0.1.0.0 (YiHuang)
04:00:52 <cornihilio> sorry, I disconnected accidentally earlier. Is there a proper way for printing the type of a variable when I'm trying to trace something?
04:01:30 <donri> _1 %~ show $ (1,2)  -- > ("1",2)
04:01:58 <donri> fstL ^%= show $ (1,2) -- type error
04:02:29 <absence> donri: ah, i see
04:04:22 <Athas> cornihilio: The trace command?  In GHCi?
04:04:45 <Athas> cornihilio: If you set a breakpoint (using :break), it will print the type of bindings in scope when the breakpoint is reached.
04:05:51 * hackagebot haskell-aliyun 0.1.0.0 - haskell client of aliyun service.  http://hackage.haskell.org/package/haskell-aliyun-0.1.0.0 (YiHuang)
04:05:53 * hackagebot haskell-ftp 0.1.0.1 - A Haskell ftp server with configurable backend.  http://hackage.haskell.org/package/haskell-ftp-0.1.0.1 (YiHuang)
04:06:46 <cornihilio> Athas: sorry, I mean the Debug.Trace module to be used with the source
04:07:35 <Athas> cornihilio: oh.  That's a rather strange request.
04:07:41 <Athas> Why are you unsure about the type of something?
04:08:32 <Athas> (There's probably a solution using Data.Typeable to reify the type, but I think there may be a simpler way to do what you're trying to accomplish.)
04:08:41 <donri> cornihilio: one hack is to put an undefined there and give it a known-wrong type
04:09:13 <donri> > length (undefined::Int)
04:09:14 <lambdabot>   Couldn't match expected type `[a]'
04:09:15 <lambdabot>         against inferred type `GHC.Types...
04:09:31 <donri> this tells you it's expecting a [a] in place of that undefined
04:26:32 <absence> why does ghc complain about naked expressions at top level when i try to use makeLenses from Control.Lens?
04:27:04 <sipa> can you paste your code somewhere?
04:28:08 <absence> sipa: http://hpaste.org/75905
04:28:19 <alextrusk> hitler gangnam http://www.youtube.com/watch?v=JCfuZ9YmqiI
04:29:08 <sipa> absence: ok, what do you want to do with the result of that makeLenses ?
04:30:34 <absence> sipa: no idea, i'm just following the example on the wiki in order to try to make sense of lenses. i found this very similar paste when googling: http://hpaste.org/74503
04:31:15 <sipa> well that has the same problem
04:31:23 <sipa> you can't just write an expressions
04:31:49 <absence> sipa: what's different from the usage in this example? https://github.com/ekmett/lens/blob/master/examples/Pong.hs
04:32:32 <sipa> ooh, i suppose it's some templatehaskell thing that expands to more source code
04:32:40 <sipa> disregard what i said before
04:33:25 <absence> i just noticed the {-# LANGUAGE TemplateHaskell :)
04:33:44 <absence> suddenly it works better
04:39:46 <Bluelz> Hi, is this the channel where its okay to ask questions for people getting started with Haskell?
04:40:47 <sipa> yes
04:41:52 <sipa> Bluelz: just ask your question, but be patient; people may not immediately see it (especially at this time of day)
04:44:02 <Bluelz> I've bought a book (Programming in Haskell, by Graham Hutton). I'm eager to get started with this interesting language, and my background is mainly Java and c++. I have met a small wall however. I have downloaded Hugs for windows (version Sep 2006). Im trying to run a simple test.hs file i created, with one single line. The line was an example from the book. "doubleME x = x + x". From what I can make it, I should be able to write "doubleMe 4" into
04:44:02 <Bluelz>  WinHugs, and expect 8 to be printed. However, im faced with syntax error, unexpected symbol x. My googling thus far has yielded no result as to why it doesnt work.
04:44:48 <Bluelz> All other interaction into WinHugs works, but when im trying to load the file i get the syntax error :s
04:45:16 --- mode: hubbard.freenode.net set +o ChanServ
04:45:25 <sipa> first of all, hugs is seriously outdated; i'd advise you to install the haskell platform
04:45:53 <atriq> Is Hugs still being actively developed
04:46:08 <Bluelz> Does seem like it, the latest version is Sep 2006 from what I can make out
04:48:19 <maukd> Bluelz: first off, it should be doubleMe, not doubleME
04:48:33 <maukd> what is the exact error message?
04:48:48 <Bluelz> Syntax error in declaration (unexpected symbol "x")
04:49:01 <maukd> I bet that's not the exact error message
04:49:27 <Bluelz> ERROR file:.\test.hs:1 - Syntax error in declaration (unexpected symbol "x")
04:49:43 <sipa> and what is the exact line in that file?
04:50:22 <Bluelz> doubleMe x = x + x
04:51:22 <maukd> I'm installing hugs
04:51:34 <sipa> same :)
04:52:06 <Bluelz> I just installed the Haskell platform from Haskell.com, il try to run it there.
04:52:15 <maukd> there's a haskell.com?
04:52:19 <sipa> Bluelz: anyway, if you have a test.hs file with just that line, and load it into a haskell interpreter (hugs or ghci), "doubleMe 4" should give you 4
04:52:22 <sipa> eh, 8
04:52:43 <maukd> ... there is, but it has nothing to do with haskell
04:52:58 <maukd> therefore I seriously doubt what Bluelz is telling us
04:53:01 <Bluelz> I started up the ghci, loaded the file, and here it works without problem
04:53:15 <Bluelz> haskell.org*
04:53:17 <Bluelz> sorry!
04:53:43 <Bluelz> Allright, so the Haskell Platform is the way to go, not Hugs, in other words?
04:53:49 <sipa> it works perfectly in hugs here as well
04:53:54 <maukd> works here as well
04:54:03 <sipa> $ hugs Test.hs
04:54:07 <sipa> Main> doubleMe 4
04:54:09 <sipa> 8
04:54:28 <Bluelz> Can there be some wierd configuration I have fucked up in Hugs?
04:54:39 <sipa> then again; ghci is the better choice nowadays, so don't pay too much attention to it
04:54:45 <sipa> perhaps
04:55:30 <drostie> I like how I decided to start learning Haskell today and the first thing I see in this room is some error with "doubleMe x = x + x", which comes from the same tutorial that I'm following. ^_^
04:55:48 <atriq> drostie, don't use Hugs.
04:55:54 <maukd> ERROR "test.hs":1 - Syntax error in input (unexpected symbol "x")
04:56:06 <maukd> I get quotes around the filename and no 'file:' in front
04:56:40 <maukd> (and I triggered the error with 'doubleMe (f x)')
04:57:15 <Bluelz> What triggered it for me was simply loading test.hs into hugs
04:57:34 <sipa> weird
04:57:35 <sipa> :)
04:58:01 <Bluelz> Well, luckily im now able to run my examples after getting ghci, so that'll help me a  lot :)
04:58:24 <sipa> which OS are you on?
04:58:31 <Bluelz> Windows 7 x64
04:59:08 <maukd> ah, I can get the "... in declaration" error with '[doubleMe] x'
04:59:25 <sipa> when my test.hs has windows/dos-style line terminators, i get an error: Undefined variable "x"
04:59:32 <maukd> > let [doubleMe] x = ()
04:59:33 <lambdabot>   <no location info>: Parse error in pattern
04:59:55 <absence> does anyone know how to defined a Control.Lens manually without TH?
05:00:12 <maukd> sipa: works fine here
05:00:25 <Bluelz> @Sipa this is happening in Hugs only, or should I be worried about this happening in ghci as well, and install a virtual linux box?
05:00:25 <lambdabot> Unknown command, try @list
05:01:00 <sipa> in ghci it always works
05:01:12 <sipa> Bluelz: ghc should work fine in windows (and hugs too, but ...)
05:01:53 <maukd> Bluelz: what happens if you change the file to 'foo = ()'?
05:03:05 <Bluelz> maukd: No error at all
05:03:29 <maukd> Bluelz: doubleMe = \x -> x + x
05:05:02 <Bluelz> It gives me no error, but then again, when I try to enter doubleMe 4,  ERROR - Undefined variable "doubleMe" appears.
05:06:44 <drostie> yay, I just rewrote a 13-line PHP function that I wrote yesterday (for someone in ##math) to be two lines long. ^_^
05:06:47 <maukd> how are you loading the file?
05:07:00 <drostie> Haskell is pretty spiffy.
05:07:39 <Bluelz> Main> :load "F:\programmering\haskell\vartest.hs"
05:09:09 <Bluelz> The file vartest.hs contains the one line doubleMe = \x -> x + x
05:09:23 <maukd> mysterious
05:10:51 * hackagebot jack-bindings 0.1.1 - DEPRECATED Bindings to the JACK Audio Connection Kit  http://hackage.haskell.org/package/jack-bindings-0.1.1 (PhilippBalzarek)
05:10:54 * hackagebot fay 0.9.2.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.9.2.0 (ChrisDone)
05:11:38 <Bluelz> Indeed. Well, with the addition of ghci to my arsenal, i am now able to run the simple "dobuleMe x = x + x" file with the result I was hoping for, and that will simplify the learning process, as I am now able to run the examples from the book, + play around with my own ideas. Thanks for the help guys!:D
05:13:40 <sipa> Bluelz: good luck
05:27:36 <absence> why doesn't this work? test f d v = d { ff = v }
05:27:57 <absence> err
05:28:03 <absence> test f d v = d { f = v }
05:28:10 <maukd> define "work"
05:28:33 <sipa> the 'f' inside the brackets must be the name of a field in the data type of d
05:28:34 <absence> maukd: compile :)
05:28:46 <sipa> you can't pass field names as first-class variables
05:28:48 <maukd> absence: what's the error message?
05:30:12 <absence> sipa: oh. is there a different syntax that will let me change a field like that?
05:30:37 <sipa> you want something like lenses for that
05:30:44 <maukd> <mauke> absence: lenses :-)
05:30:45 <absence> maukd: it was "f is not a visible constructor field"
05:30:56 <maukd> absence: well, then that was the reason why it didn't work
05:31:31 <absence> maukd: if i understood that it meant "you can't pass field names as first-class variables" i wouldn't have asked, obviously :)
05:31:55 <maukd> you should have asked "what does this error message mean?"
05:32:38 <absence> sipa: actually this code was to be a makeLens ;) i guess the lense definitions have to be a bit more verbose then (i know it's common to use TH for this, but i can't due to bug in my version of ghc)
05:35:59 <absence> maukd: yeah probably. luckily sipa was able to deduce :)
05:37:48 <sipa> absence: i assume maukd would have guessed the same thing, but he prefers having you do some work to find out yourself :p
05:45:01 <absence> sipa: oh i did google and all that, i just happened to paste the code instead of the error message because i assumed there was something blindingly obvious wrong with my code :)
05:45:53 <merijn> absence: How to define Control.Lens lenses without TH, first three functions in: https://github.com/merijn/SNet2.0/blob/master/SNet/Record.hs
05:46:20 <atriq> I'm trying to think what a Comonad-y lens would grant
05:46:21 <merijn> (Man, having some haskell code public is really simplifying my "tell people how to do something"-workflow xD)
05:46:39 <atriq> Something similar to Setter, I think
05:48:41 <drostie> out of curiosity, how would I extend a typeclass like Prelude.Num to include a custom type, like (Num a) => (a, a) ?
05:49:44 <absence> merijn: thanks!
05:49:47 <merijn> drostie: "instance Num (a, a) where {- functions here -}"
05:50:06 <merijn> Although I suspect (a, a) is already in Num
05:50:11 <merijn> > (2,1) + (3,4)
05:50:13 <lambdabot>   (5,5)
05:50:54 <merijn> drostie: You're example wouldn't make sense, btw. I suspect what you had in mind was something like "instance Num a => Num (a, a) where"
05:52:02 <drostie> (2,1) + (3,4) yells at me in GHCi 7.4.1.
05:52:20 <merijn> drostie: Also, the phrasing "extend the typeclass" is a bit OO. You can't actually "extend" anything about a typeclass. You *can* instantiate them for other types
05:52:37 <merijn> drostie: hmm, maybe it's defined in other module or specific in lambdabot
05:52:39 <drostie> merijn: the idea is to tell Haskell that (Num a) => (a, a) is a number.
05:52:40 <merijn> @info Num
05:52:40 <lambdabot> Num
05:53:37 <merijn> drostie: Yeah, then you want the rephrasing I just used "instance Num a => Num (a, a) where" (i.e. "a being a Num instance implies that (a, a) is a Num instance")
05:53:44 <drostie> ok.
05:53:57 <byorgey> drostie, merijn: lambdabot has such an instance, but it is not in the standard libraries
05:54:08 <int-e> @type \a(_,_) b -> a+b
05:54:08 <byorgey> hence why it works here but not in drostie's ghci
05:54:10 <lambdabot> forall t t1 a. (Num a) => a -> (t, t1) -> a -> a
05:54:42 <int-e> @type \a@(_,_) b -> a+b
05:54:44 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1) -> (t, t1) -> (t, t1)
06:02:16 <klr> when im in ghci i can't type + or -, do i have to set a variable for that or somthing?
06:03:07 <drostie> merijn: ghci tells me that `Num (a, a)' is an "Illegal instance declaration" :(
06:03:13 <twanvl> klr: do you mean that the + and - keys of your keyboard suddenly stop working?
06:03:25 <klr> twanvl: only in ghci
06:03:26 <twanvl> drostie: instance (Num a, Num b) => Num (a,b)
06:03:45 <klr> twanvl: the numpad part of my keyboard doesnt seem to work in ghci
06:03:54 <Earnestly> A very basic question, how do I 'read' the type of map? `(a -> b) -> [a] -> [b]', conceptually? I'm a little unsure how to interpret `(a -> b)'. Sorry if it's a silly question
06:04:04 <drostie> twanvl: I want to phrase the constraint that both a and b are the same type of number though. :x
06:04:08 <klr> do i have to specify some setting in compile time to get it working with my keyboard?
06:04:25 <twanvl> drostie: why would you need that for the instance?
06:04:39 <klr> nvm, ive had pressed numlock by mistake, sry for disturbing :)
06:04:45 <drostie> twanvl: because a * b is sometimes a sensible thing to do if (a, b) is a number.
06:05:14 <twanvl> drostie: you can have functions that take (a,a), but the instance should be for the general case (a,b)
06:06:30 <drostie> twanvl: and if I ever do a * b the wrong way, just let the compiler explode downstream?
06:07:20 <twanvl> drostie: having a more general instance is not going to make anything explode
06:10:05 <klr> what does "/=" means?
06:10:12 <atriq> Not Equal To
06:10:16 <atriq> > 3 /= 3
06:10:17 <lambdabot>   False
06:10:21 <atriq> > 3 /= 4
06:10:22 <lambdabot>   True
06:10:26 <klr> aa like != in C?
06:10:32 <atriq> Precisely
06:10:36 <klr> okey, thanks :)
06:10:54 * hackagebot select 0.4 - Wrap the select(2) POSIX function  http://hackage.haskell.org/package/select-0.4 (GardSpreemann)
06:11:08 <nand`> drostie: the error message should mention a language extension you can enable to do this
06:11:37 <atriq> I think they made it /= in Haskell because it's slightly closer to the mathematical symbol ≠
06:11:39 <klr> is it possible to get colored output in ghci? it didnt got a man page...
06:11:44 <drostie> twanvl: 'explode' is maybe the wrong word, I'm thinking of an error message of the form "Could not deduce (a ~ b) from the context (Num a, Num b)" when I go to define multiplication.
06:11:45 <nand`> but note that what twanvl is valid
06:11:56 <atriq> klr, yes but you need a library
06:12:05 <klr> atriq: okey, which one?
06:12:05 <drostie> twanvl: please keep in mind that I've only been programming Haskell for two hours or so. ^_^
06:12:29 <twanvl> drostie: if you get that error, then the compiler is telling you that your definition of multiplication is wrong
06:12:33 <nand`> drostie: how are you defining multiplication?
06:12:53 <klr> i found the wiki page nvm :)
06:12:57 <drostie> (*) (w, x) (y, z) = (w * y - x * z, w * z + x * y).
06:13:01 <drostie> The obvious way.
06:13:15 <nand`> the obvious was is (w*z, x*z)
06:13:18 <nand`> err
06:13:20 <nand`> w*y
06:13:22 <nand`> way*
06:13:30 <drostie> if you hate geometry then yes. :P
06:13:56 <drostie> I happen to like geometry and complex numbers are awesome, therefore, I am using complex multiplication.
06:14:10 <drostie> Which is why I want (Num a) => Num (a, a).
06:14:13 <atriq> drostie, or you could just use Data.Complex
06:14:23 <atriq> @info Complex
06:14:23 <lambdabot> Complex
06:14:30 <Axman6> @src Complex
06:14:30 <SwashBuckla> ;D
06:14:30 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
06:14:46 <atriq> > (1 :+ 2) * (3 :+ 4)
06:14:47 <lambdabot>   (-5.0) :+ 10.0
06:14:49 <SwashBuckla> !a is dereference a?
06:14:54 <SwashBuckla> @info !
06:14:55 <lambdabot> (!)
06:14:55 <drostie> Look, I'm trying to _learn a language_ here guys. --_--;;
06:14:56 <atriq> a is strict a
06:14:59 <nand`> drostie: if that's the function you want, then yeah; you need Num a => Num (a, a) -- and to that effect, see the suggestion provided by the ‘illegal instance declaration’ error message
06:15:03 <SwashBuckla> @source!
06:15:03 <lambdabot>  not available
06:15:09 <SwashBuckla> @source !a
06:15:09 <nand`> drostie: but yeah, if you want complex numbers, it's been done for you as mentioned
06:15:09 <lambdabot> !a not available
06:15:57 <drostie> nand`: what suggestion?
06:15:59 <twanvl> drostie: instead of using tuples, it is better to use your own datatype, because that lets you enforce that the real and complex parts have the same type
06:16:40 <nand`> drostie: paste the whole error message you see when you try to define instance Num a => Num (a, a)
06:17:43 <drostie> nand`: Illegal instance declaration for `Num (a, a)' (All instance types must be of the form (T a1 ... an) where a1 ... an are *distinct type variables*, and each type variable appears at most once in the instance head. Use -XFlexibleInstances if you want to disable this.) In the instance declaration for `Num (a, a)'
06:17:56 <nand`> ‘Use -FlexibleInstances if you want to disable this.’ <- that's the suggestion I meant :)
06:18:02 <drostie> ok. ^_^
06:18:30 <nand`> (if you're in ghci, :set -XFlexibleInstances; if you're in a file, {-# LANGUAGE FlexibleInstances #-} )
06:18:55 <drostie> twanvl: and you're saying that what I'm trying to do is more complicated than just trying to tell Haskell that "tuples are numbers too" and I should instead look into the ways of making structured data types?
06:19:11 <trotro> hi, why the switch -fglasgow-exts was declared as obsolete ?
06:19:52 <nand`> drostie: telling Haskell that “tuples are numbers too” isn't much more complicated, it's just bad design in this case
06:20:02 <nand`> drostie: but yes, you should look into ways of making data types; if you haven't already
06:20:14 <nand`> since that's one of the most fundamental things in haskell
06:20:23 <drostie> Like I said, I've only been programming in this language for two hours.
06:20:52 <nand`> http://learnyouahaskell.com/making-our-own-types-and-typeclasses
06:21:30 <drostie> nand`: ok, I'll get there in 5 chapters. ^_^ :D
06:21:44 <plat0> drostie: if it's only been two hours I suggest not trying to write your own Num instances yet, especially not for (a,a)!
06:22:16 <drostie> psh. I came here to be thrown in the deep end.
06:22:44 <drostie> more precisely, I came here to learn how to read the source code of darcs. ^_^
06:22:59 <nand`> ouch, darcs has some ugly source code :(
06:23:36 <nand`> well; ‘reading’ implies understanding (as opposed to just ‘looking’ at the source code); and to understand Haskell code you have to understand the semantics of it all :)
06:23:42 <nand`> so it's good to start at the beginning
06:24:36 <drostie> nand`: hence the tutorials etc. I'm not crazy. :D
06:32:54 <eyebloom> Has anyone read "Giving Haskell a Promotion"?
06:34:40 <hpc> is that the polykinds paper?
06:34:58 <eyebloom> yes
06:36:32 <eyebloom> I get parse errors trying to compile some of the code snips from the paper and I was wondering if there is a source link for the paper.
06:37:41 <hpc> eyebloom: probably whitespace?
06:38:05 <eyebloom> I typed them in.
06:39:11 <eyebloom> for example this is taken from the paper: type family Shape (a :: X ) :: *
06:39:24 <eyebloom> it gives a parse error on input "X"
06:39:30 <hpc> ah
06:39:45 <hpc> {-# LANGUAGE DataKinds, PolyKinds #-}
06:40:14 <hpc> (probably not polykinds for that specific example)
06:41:07 <eyebloom> I see, it looks like I need to upgrade my compiler too as I get Unsupported extension:Datakinds
06:41:16 <hpc> ghc --version?
06:41:25 <nand`> capital K?
06:41:46 <eyebloom> nand: yes
06:42:15 <eyebloom> 7.0.4
06:42:20 <nand`> get 7.4.2
06:43:04 <hpc> 7.0.4 is mostly just 6.12.1 with a few bad habits broken :P
06:43:31 <hpc> (at least at the level a user sees)
06:44:21 <eyebloom> If I reinstall the platform 2012.2.0.0 do I get 7.4.2 in there?
06:44:59 <nand`> 2012.2.0.0 has 7.4.1
06:45:02 <nand`> close enough
06:45:05 <nand`> I forgot what changed to .2
06:45:46 <hpc> nand`: a failure to handle parse errors in class declarations was fixed, iirc
06:46:00 <hpc> was the largest change
06:46:28 <nand`> what about the deriving (show) thing?
06:48:07 <hpc> yeah, that's the change
06:48:30 <hpc> i don't see it in the release notes, but i see a lot of other unrelated IO-y stuff like STM segfaults
06:48:39 <hpc> so it shouldn't matter
06:53:33 <eyebloom> Ok updated GHC this line type family Shape (a :: X ) :: * gives a parse error on the second ::
06:54:09 <eyebloom> Sorry the line is:    type family Shape (a :: X ) :: *
06:54:31 <eyebloom> I'm assuming that's because I'm misunderstanding the example somehow.
07:25:58 * hackagebot idris 0.9.4 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.4 (EdwinBrady)
07:27:59 <hpaste> eyebloom pasted “Experimenting with Type families” at http://hpaste.org/75911
07:28:39 <eyebloom> I've gotten closer but haven't been able to get this to compile on 7.4.2
07:28:51 <hiptobecubic> How do dependent types actually work? How does the compiler know that my Int is > 2 at compile time?
07:30:14 <eyebloom> I get "Not in scope: type constructor of class 'X'." Which is confusing because I though X would read as a polymorphic kind.
07:35:30 <nand`> try a lowercase ‘x’?
07:36:37 <hpc> hiptobecubic: it does a lot less thinking than you would expect
07:37:03 <hpc> ie, it rejects a program if it can't "obviously" tell that x > 2
07:37:20 <hpc> or more accurately, it rejects a program where it can't unify x with (S (S n))
07:37:37 <hpc> (for nats)
07:38:31 <merijn> eyebloom: 7.4 has unsupported DataKinds support, 7.6 is the first one that properly supports them
07:38:58 <eyebloom> I see, I'll upgrade thank you.
07:39:11 <sipa> unsupported support sounds fun
07:39:12 <merijn> (i.e. it's mostly in there, but not officially supported so at least my DataKinds didn't really work properly)
07:48:05 <porn> ~/ this means home directory
07:48:38 <Guest2830> ~/ this means home directory
07:49:15 <Guest2830> ??
07:50:01 <geekosaur> on unix yes
07:50:06 <geekosaur> bah
07:50:07 <typoclass> Guest2830: yes it does, if you use "~" in a shell. however, this channel is about the programming language haskell. you might want to direct your questions to another channel
07:50:24 <typoclass> yes, bah indeed
07:56:21 <eyebloom> how would one make ghc 7.6.1 the default version of the compiler?
07:57:40 <merijn> eyebloom: I basically installed GHC 7.6 to ~/ghc and then set my path to PATH=~/ghc/bin:$PATH
07:57:49 <merijn> eyebloom: It just pics the first ghc encountered on your path
07:58:17 <digital_monster> hello
08:02:51 <digital_monster> how do I update a Map (a0, Int), incrementing Int, according to input from stdin?
08:03:36 <fakas> any advice installing wxhaskell in lion?
08:03:52 <klr> why are there no "uninstall"/"remove" in cabal?
08:03:53 <srhb> fakas: Sacrificing kittens I believe is the latest step.
08:04:03 <srhb> klr: cabal-install is not a package manager.
08:04:21 <srhb> digital_monster: First consider how to do it with a static number instead of one from stdin
08:04:35 <klr> srhb: hmm, it isn't? what is then?
08:04:37 <digital_monster> srhb: Data.Map.map (+1) or something
08:04:47 <fakas> ihave dogs
08:04:56 <srhb> fakas: Well, you're out of luck then. :P
08:04:57 <digital_monster> or is it Data.Map.update (Just (+1)) m?
08:04:58 <klr> gtg, have nice day everyone
08:05:35 <srhb> digital_monster: mapKeys
08:05:49 <srhb> :t mapKeys
08:05:50 <lambdabot> Not in scope: `mapKeys'
08:05:57 <srhb> @hoogle mapKeys
08:05:58 <lambdabot> Data.Map mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
08:05:58 <lambdabot> Data.Map mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
08:05:58 <lambdabot> Data.Map mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
08:06:27 <fakas> (=^Y^=)
08:06:42 <digital_monster> ah
08:07:24 <digital_monster> > Data.Map.mapKeys (+1) (Data.Map.fromList [("A", 0)])
08:07:25 <lambdabot>   Not in scope: `Data.Map.mapKeys'Not in scope: `Data.Map.fromList'
08:07:29 <digital_monster> :(
08:07:38 <digital_monster> > import qualified Data.Map as M
08:07:39 <lambdabot>   <no location info>: parse error on input `import'
08:07:50 <srhb> digital_monster: Looks right. Then consider how to get an integer from stdin and pass it on
08:08:33 <digital_monster> how do I update individual values other than all of them? Will Data.Map.update work?
08:10:08 <srhb> digital_monster: update, yeah
08:10:34 <srhb> digital_monster: Or you might be able to use adjust
08:11:00 * hackagebot hoauth2 0.2.4 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.2.4 (HaishengWu)
08:11:58 <digital_monster> getting haskell code to compile is a pain ^_^ I'm doing it wrong :(
08:12:17 <hpaste> otters pasted “flexible instance nonsense” at http://hpaste.org/75913
08:12:19 <srhb> digital_monster: :) Once you catch it, it'll be awesome.
08:12:30 <otters> I don't understand why I'm getting the error ^
08:12:40 <typoclass1> digital_monster: often it's pretty hard to get anything to compile, but once it does, there's not much debugging work left. so there's an upshot :)
08:12:45 <digital_monster> "maybe a $ here, a pair of parentheses there... dang! 'Inferred Int, actual type IO a0'" :(
08:12:47 <otters> there's an IsString Text instance, but no IsString [Text]
08:12:58 <otters> so I would think (IsString a, Foo a) would narrow it down to Text
08:13:15 <srhb> digital_monster: Have you played around with IO before?
08:14:17 <typoclass1> otters: have you tried turning off the DMR?
08:14:37 <mroman> pas = [1]:[1:(p y)|y<-pas]
08:14:43 <otters> typoclass1: the what?
08:14:54 <mroman> ^- How does that not recalculate everything again?
08:15:05 <mroman> (I'm assuming it does not because it wouldn't make sense)
08:15:14 <typoclass1> otters: sorry for the jargon :) i mean, try adding {-# LANGUAGE NoMonomorphismRestriction #-}
08:15:16 <digital_monster> srhb: yes, with simple stuff like regurgitating input i.e. "putStrLn "What's your name?" >> getLine >>= putStrLn"
08:15:36 <digital_monster> but nothing like updating a map according to user input
08:15:37 <mroman> At its first pass, pas 'contains' only a single list with [1]
08:16:00 * hackagebot ginsu 0.8.1 - Ginsu Gale Client  http://hackage.haskell.org/package/ginsu-0.8.1 (DylanSimon)
08:16:06 <digital_monster> http://ideone.com/850vi yay I figured out how to do it statically ^_^ thanks guys
08:16:13 <otters> typoclass1: yes. same problem
08:17:04 <mroman> http://codepad.org/E9AJoLtH <- actualy code
08:17:22 <mroman> so the first pass kinda yields [[1],[1,1]... obviously
08:17:59 <mroman> but for it to work, p must always receive the latest result (the last element in the lest)
08:18:06 <mroman> or else it would start recalculating everything from begin
08:18:31 <srhb> digital_monster: Now you need to figure out how to "translate" what you read from a stdin into a number, probably easiest in a do-block if you've understood the basics of that notation :)
08:18:41 <mroman> but y<-pas does not assign the last element to y
08:18:42 <digital_monster> right
08:18:49 <mroman> it goes through the whole list.
08:20:09 <merijn> digital_monster: how about just "updateMapEntry :: (Int -> Int) -> Map Char Int -> IO (Map Char Int); updateMapEntry f m = do { line <- getLine; return $ Data.Map.update (Just . f) (head line) m }"
08:20:10 <typoclass1> otters: hm, good question. could you do :t "x" in ghci, with all the instances imported that your program has imported? also, verify that :i IsString gives the expected
08:20:19 <otters> okay
08:20:33 <merijn> digital_monster: As example way to read a key from stdin and update a map based on that key
08:20:56 <mroman> If I inline the first two passes I get [1]:[1:(p y|y<-[1]:[1:(p y)|y<-[1]:[1:(p y)|y<-pas]]
08:21:15 <merijn> digital_monster: All sorts of ways to clean that code up, it's just a rough sketch to give you an idea where to start
08:21:17 <mroman> which looks like it recalculates every case again?
08:22:09 <otters> typoclass1: "x" :: Data.String.IsString a => a
08:22:25 <otters> IsString has instances for Text and [Char]
08:23:42 <digital_monster> http://ideone.com/HiH8I I'm doing something wrong here :(
08:23:44 <merijn> Oh, I guess that code would've been simpler using Data.Map.adjust
08:23:46 <mroman> and a function like f=[1:y|y<-f] never terminates
08:23:51 <digital_monster> I think it's because tabulateGrade is pure
08:23:54 <mroman> as well as is not lazy
08:24:12 <mroman> (f!!0 does not return a result in finite time)
08:24:41 <otters> typoclass1: although "x" ++ "y" gives me an error that there's no instance for IsString [a0]
08:24:47 <otters> but ("x" :: [Char]) ++ "y" works fine
08:24:50 <otters> this is very suspicious
08:24:52 <merijn> digital_monster: THe update of the map is not in place
08:24:59 <otters> there's definitely an instance for IsString [Char]
08:25:03 <merijn> digital_monster: tabulateGrade returns a new map
08:25:19 <digital_monster> http://ideone.com/F039i this works! ^_^
08:25:24 <merijn> digital_monster: But since you run tabulateGrade within do notation it expect an IO value (which tabulateGrade does not provide)
08:25:28 <digital_monster> so every line in a do block must be an IO action?
08:25:34 <merijn> digital_monster: Yes
08:25:46 <otters> or a let statement
08:26:00 <merijn> digital_monster: If you need to do temporary "assignment" you could do something like "let newMap = tabulateGrade ...; print newMap"
08:26:21 <digital_monster> http://ideone.com/QSAdb ah
08:26:23 <merijn> or just "print $ tabulateGrade .."
08:27:08 <McJan_Flanders> merijn, does it really?
08:27:28 <merijn> digital_monster: If you intend to frequently update said map (i.e. because you want to do stateful computation) you might want to look at the State monad, which makes this much nicer
08:27:49 <merijn> McJan_Flanders: Yes, but since everything is immutable the new map will share the majority of all values with the old one
08:28:21 <merijn> McJan_Flanders: Since only the nodes between the newly inserted value and the root of the map's tree need to be updated. All other branches can be reused directly
08:29:14 <digital_monster> right
08:33:41 <b__> is there a way to bind Just a value with guards like is possible with case?
08:33:58 <eyebloom> Hmmm... I get the same "Not in scope: type constructor or class `X'" when I try to compile this code http://hpaste.org/75914 using ghc 7.6.1 as well.
08:34:54 <typoclass1> b__: you might be interested in "pattern guards" http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/syntax-extns.html#pattern-guards and the following section ("view patterns")
08:36:08 <mroman> I don't even understand how q=[1]:[1:y|y<-q] can possibly work
08:37:56 <b__> thanks typoclass1
08:38:04 <merijn> :t reads
08:38:05 <lambdabot> forall a. (Read a) => String -> [(a, String)]
08:38:09 <copumpkin> mroman: it prepends 1 onto every list in q, and throws a [1] onto the beginning of the whole thing
08:38:20 <mroman> copumpkin: I know what it does
08:38:26 <mroman> that's the trivial part.
08:38:29 <copumpkin> what's wrong with it?
08:38:35 <copumpkin> oh, it's recursive
08:38:39 <mroman> I don't know how it does it.
08:38:47 <copumpkin> that's more interesting, but not too surprising
08:39:08 <copumpkin> have you come across the recursive definitions of powers of 2 or fibonacci?
08:39:23 <mroman> Yes.
08:39:29 <mroman> Recursion is not a problem.
08:39:40 <copumpkin> > let x = 1 : map (2*) x in x
08:39:41 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
08:39:44 <copumpkin> that kind of recursion?
08:39:55 <copumpkin> because it's the same thing
08:39:58 <merijn> > read "1" :: [(Int, String)]
08:39:59 <lambdabot>   *Exception: Prelude.read: no parse
08:40:05 <merijn> > reads "1" :: [(Int, String)]
08:40:06 <otters> @pl let x = 1 : map (2*) x in x
08:40:06 <lambdabot>   [(1,"")]
08:40:06 <lambdabot> fix ((1 :) . map (2 *))
08:40:14 <otters> oh
08:40:17 <mroman> copumpkin: That's the one that bugs me, yes.
08:40:29 <alephomega> Lazy evaluation.
08:40:50 <copumpkin> mroman: what you need is Cale's mental evaluation mechanism to run through a few steps of it for you
08:40:56 <merijn> digital_monster: Wanted to show you an example of implemtning something like you had using the State monad, but unfortunately ideone doesn't let me import that one, so the example doesn't actually run: http://ideone.com/HhbrN
08:40:56 * copumpkin performs the Cale-summoning dance
08:41:02 * hackagebot snaplet-oauth 0.0.5 - snaplet-oauth  http://hackage.haskell.org/package/snaplet-oauth-0.0.5 (HaishengWu)
08:41:40 <copumpkin> mroman: the basic trick though is that (1:) at the beginning, which lets it actually produce useful output
08:42:03 <copumpkin> > let x = 1 : 3 : map (2*) x in x
08:42:04 <lambdabot>   can't find file: L.hs
08:42:05 <mroman> 1 : map (2*) x, but hence x is 1 : map (2* x), I can replace the x with it
08:42:08 <copumpkin> lol
08:42:16 <copumpkin> keep replacing forever
08:42:17 <mroman> thus leading to 1 : map (2*) (1 : map (2* x))
08:42:18 <copumpkin> so basically
08:42:21 <copumpkin> yeah
08:42:29 <mroman> and so on.
08:42:33 <copumpkin> yep
08:42:53 <copumpkin> > let x = 1 : 3 : map (2*) x in x
08:42:54 <lambdabot>   [1,3,2,6,4,12,8,24,16,48,32,96,64,192,128,384,256,768,512,1536,1024,3072,20...
08:43:17 <alephomega> ... how has that never occured to me?
08:43:46 <mroman> I call that the freaky kind of recursion :)
08:44:00 <copumpkin> fundamentally, it's no different from "function call recursion" that you're used to
08:44:15 <mroman> the second map produces [2,4,8,...]
08:44:16 <mroman> so
08:44:34 <mroman> 1 : map (2*) [1:[2,4,8,...]]
08:45:29 <eyebloom> I'm seeking an example of arity-generic code that compiles in ghc.
08:45:32 <mroman> which leads to 1 : [2,4,8,16,...]
08:46:11 <copumpkin> > let q = [1] : map (1:) q in q
08:46:12 <lambdabot>   [[1],[1,1],[1,1,1],[1,1,1,1],[1,1,1,1,1],[1,1,1,1,1,1],[1,1,1,1,1,1,1],[1,1...
08:46:12 <mroman> the tricky part is how it's evaluated in haskell
08:46:23 <mroman> because you never know the result of the last thingy
08:46:27 <mroman> because there is no last thingy
08:46:33 <mroman> so recursion usually works bottom up
08:46:38 <copumpkin> well, keep in mind that the list doesn't contain values
08:46:40 <mroman> which it can't here because there is no bottom
08:46:44 <copumpkin> it contains references to ways to compute the values
08:46:48 <copumpkin> so you never need all of them at once
08:47:08 <copumpkin> it produces a list, and then when you ask for the first one, it runs through enough computation to give you the 1
08:47:11 <copumpkin> which is trivial
08:47:30 <copumpkin> when you ask for the second one, it runs through enough to give you the second one, which runs through one level of map
08:47:31 <typoclass1> eyebloom: you mean variadic functions? it's funky in haskell, but possible http://www.haskell.org/haskellwiki/Varargs but if you instead can just pass a list, i recommend you try that
08:47:53 <mroman> hm
08:47:56 <mroman> that makes sense.
08:48:00 <nand`> I think he means kind polymorphism like Typeable (t :: a)
08:48:08 <copumpkin> mroman: so at no point does it need more than it already has
08:48:09 <eyebloom> nand
08:48:19 <eyebloom> nand: yes
08:48:21 <copumpkin> mroman: however, you can construct ones that do need more than they have, and those will hang
08:48:32 <mroman> I noticed :)
08:48:34 <nand`> eyebloom: you can find a bunch of code in the GHC test suite
08:49:02 <nand`> eyebloom: but those aren't all very practical or useful
08:49:27 <mroman> so
08:49:44 <mroman> pas = [1]:[1:(p y)|y<-pas]
08:50:21 <hpaste> eyebloom pasted “Global Extension Lambda” at http://hpaste.org/75915
08:50:33 <mroman> obviously the second passis [1]:[1:(p y)|y<-[[1],...]
08:50:43 <eyebloom> nadThis is the reason I need it basically
08:51:10 <eyebloom> nand': Sorry this is the reason: http://hpaste.org/75915
08:51:13 <mroman> but it seems to me as if every pass would calculate the case [1:(p y)|y<-[[1],...]
08:51:25 <nand`> eyebloom: looks to be a bit above my head, at least at a first glance
08:51:39 <nand`> I haven't done much with type families or polykinds/datakinds yet
08:52:54 <eyebloom> I see, basically if you look at the definition of Lg about midway down you can kind of get an idea of where polykinds would be needed.
08:53:06 <mroman> which is actually pas = [1] : map (\y -> 1:(p y)) pas
08:54:08 <mroman> aha
08:54:12 <mroman> Now I get it.
08:56:11 <merijn> digital_monster: Ok, fixed my example so it actually runs. You can just paste into a .hs file and execute it using runhaskell. It's probably a bit complex for what you're used to, but I think that using hoogle to find the type signatures you should be able to follow what happens. It'll give you something nice to study ;) http://hpaste.org/75916
08:58:11 <merijn> digital_monster: StateT allows you to add some state to an existing monad (it adds state containg "Map Grade Int" to the IO monad here), the liftIO stuff you can (mostly) ignore, it just changes the IO functions into functions that work with any monad that supports IO (such as the StateT wrapped around IO)
09:00:14 <digital_monster> right
09:15:31 <gargawel> Does someone know why auto-deriving a MonadTrans instance for this newtype won't work:
09:15:34 <gargawel> newtype GBotMonad m a = BotMonad { unBotMonad :: ReaderT BotInfo (StateT BotState m) a } ?
09:15:50 <gargawel> I get an horrible "cannot eta-reduce enough" error
09:16:34 <twanvl> gargawel: that type is not a monad transformer
09:16:41 <twanvl> oh wait, it is
09:16:41 <twanvl> sorry
09:16:53 <jmcarthur> gargawel: there are multiple choices for that instance. which one do you want?
09:17:05 <jmcarthur> oh wait
09:17:09 <jmcarthur> no, only one, nevermind
09:17:28 <jmcarthur> but the one given by ReaderT isn't the right one
09:17:56 <gargawel> Humm
09:18:01 <voidf> how to return the type in a function?
09:18:03 <elliott> gargawel: because it tries to use the ReaderT instance modulo newtype wrapping
09:18:13 <elliott> and that tries to lift things down one level, but there's a StateT BotState m you have to lift down past again
09:18:25 <elliott> basically you have to write that instance yourself
09:18:25 <gargawel> So what can I do to be able to lift things down ?
09:18:42 <gargawel> write the MonadTrans instance myself ? 'k
09:18:44 <elliott> presumably lift = BotMonad . lift . lift
09:18:57 <gargawel> Yup
09:19:02 <elliott> whereas it is being derived as lift m = BotMonad (lift m) or something, which is clearly wrong
09:19:05 <jmcarthur> voidf: what do you mean?
09:19:12 <twanvl> voidf: what do you mean? what type?
09:19:16 <elliott> (because all newtype deriving does is use the underlying type's instance with wrapping and unwrapping the newtype added in)
09:19:51 <gargawel> Thanks ; I guess I should study the generalized newtype deriving mechanism a bit more
09:21:18 <voidf> iam tryng to take 3 strings and return their type by infering function ("1" + 4) ("lkll" ++"sdf") ("True" || False)
09:21:51 <jmcarthur> using OverloadedStrings or something?
09:21:54 <digital_monster> http://dave.fayr.am/posts/2012-10-4-finding-fizzbuzz.html
09:22:00 <voidf>  Int [Char] Bool
09:22:21 <jmcarthur> voidf: what is the type of the function you want?
09:22:51 * BMeph is desperately trying NOT to say "Step away from the crack pipe..." oops, too late!
09:22:56 <voidf> i have being trying with read but nope
09:23:11 <nand`> :t ?something || False
09:23:13 <lambdabot> (?something::Bool) => Bool
09:23:17 <jmcarthur> > read "1" + 4
09:23:19 <lambdabot>   5
09:23:24 <nand`> :t ?something ++ "sdf"
09:23:26 <lambdabot> (?something::[Char]) => [Char]
09:23:30 <jmcarthur> > read "\"lkll\"" ++ "sdf"
09:23:33 <lambdabot>   "lkllsdf"
09:23:39 <jmcarthur> > read "True" || False
09:23:40 <lambdabot>   True
09:24:29 <voidf> how would be the type declaration ?
09:24:37 <jmcarthur> the type declaration for what? read?
09:24:39 <jmcarthur> :t read
09:24:40 <lambdabot> forall a. (Read a) => String -> a
09:25:14 <Eduard_Munteanu> Types are types, you don't get to return them like values.
09:25:35 <Eduard_Munteanu> Besides, you already know the type, e.g. a || b is a Bool
09:27:44 <voidf> so how could it be a function that takes 3 strings adds a Bool a String etc and show the result like read but with 3 strings
09:28:37 <c_wraith> what type should the function have?
09:29:42 <jmcarthur> > let f str1 str2 str3 = (read str1 + 4, read str2 ++ "sdf", read str3 || False) in f "1" "\"lkll\"" "True"
09:29:45 <lambdabot>   (5,"lkllsdf",True)
09:29:48 <typoclass1> > let f x y = show (read x || False) ++ show (read y + 5) in f "True" "7" -- voidf, not sure what you're looking for
09:29:51 <lambdabot>   "True12"
09:30:39 <typoclass1> voidf: the 'show' function converts from any showable value into a String. the 'read' function does the reverse, taking a String and giving a value
09:30:41 <jmcarthur> voidf: what is an example use of the function, complete with inputs and outputs?
09:31:48 <voidf> func ("1" + 3 ) ("FGGS"++ "DSD") ("True" || False)
09:32:17 <voidf> 4 FGGSDSD True
09:32:40 <c_wraith> that's not a value that a function can return
09:32:56 <voidf> but it could be any func ("False" && False) etc
09:33:07 <aristid-ipad> invalid
09:33:20 <typoclass1> voidf: sorry that's not going to work in haskell (unless you want major trickery). i think you should restructure your program a little. if you want advice on that, put it on hpaste
09:33:23 <typoclass1> @where hpaste
09:33:23 <lambdabot> http://hpaste.org/
09:34:19 <typoclass1> > let parse x f = f (read x) in parse "True" (&& False) -- voidf: this is the closest thing that i can think of
09:34:21 <lambdabot>   False
09:34:27 <voidf> ok something like read "1" + 4 but with 3 inputs 3 outputs
09:35:01 <jmcarthur> voidf: does my function above not do what you want?
09:35:05 <jmcarthur> > let f str1 str2 str3 = (read str1 + 4, read str2 ++ "sdf", read str3 || False) in f "1" "\"lkll\"" "True"
09:35:07 <lambdabot>   (5,"lkllsdf",True)
09:35:39 <jmcarthur> oh, you want to pass things in slightly differently
09:35:45 <jmcarthur> here's something that can work:
09:36:14 <nand`> ‘func’ could be realized with -XOverlappingInstances and -XOverloadedStrings; but I wouldn't recommend it
09:36:21 <voidf> nope because it can be any not necessarily  read str2 ++ "sdf", read str3 || False)
09:36:35 <nand`> (let func x y z = unwords $ map show [x,y,z])
09:36:49 <jmcarthur> > let f str1 f1 str2 f2 str3 f3 = (f1 (read str1), f2 (read str2), f3 (read str3)) in f "1" (+ 4) "\"lkll\"" (++ "sdf") "True" (|| False)
09:36:51 <lambdabot>   (5,"lkllsdf",True)
09:37:16 <jmcarthur> :t let f str1 f1 str2 f2 str3 f3 = (f1 (read str1), f2 (read str2), f3 (read str3)) in f
09:37:17 <lambdabot> forall a t a1 t1 a2 t2. (Read a2, Read a1, Read a) => String -> (a -> t) -> String -> (a1 -> t1) -> String -> (a2 -> t2) -> (t, t1, t2)
09:37:25 <nand`> oh, not even that; it would be a bit more complicated to make "FGGSDSD" show as "FGGSDSD", but nothing OverlappingInstances can't handle
09:37:45 <jmcarthur> voidf: how's that? ^^
09:37:58 <jmcarthur> voidf: you have to pass in three strings and three functions
09:37:59 <voidf> lol
09:38:16 <jmcarthur> yeah it's funny looking. i think you are asking for something funny
09:39:13 <jmcarthur> you could even do this:
09:40:09 <jmcarthur> > let f g str1 str2 str3 = g (read str1) (read str2) (read str3) in f (\a b c -> (a + 4, b ++ "sdf", c || False)) "1" "\"lkll\'" "True"
09:40:11 <lambdabot>   (5,"*Exception: Prelude.read: no parse
09:40:17 <jmcarthur> fail
09:40:19 <jmcarthur> > let f g str1 str2 str3 = g (read str1) (read str2) (read str3) in f (\a b c -> (a + 4, b ++ "sdf", c || False)) "1" "\"lkll\"" "True"
09:40:22 <lambdabot>   (5,"lkllsdf",True)
09:41:05 <voidf> its hurting my eyes ;D but does the work
09:41:18 <jmcarthur> yay!
09:42:22 <nand`> http://bpaste.net/show/49795/
09:42:23 * nand` hides
09:42:36 <jmcarthur> @slap nand`
09:42:37 <lambdabot> I'd rather not; nand` looks rather dangerous.
09:43:48 <Psycho_pr> Is there a way to write a Cocoa Haskell app without writing one line of Objective-C?
09:43:55 <nand`> the :: String could be dropped but I had ++ as mappend so it defaulted to ()
09:44:18 <nand`> it might still default to [()] though
09:44:42 <jmcarthur> silly defaulting
09:44:45 <voidf> wxHaskell but is a pain in the ass
09:44:54 <nand`> IsString should clearly default to String :)
09:45:09 <jmcarthur> there should just not be defaulting, IMO
09:45:54 <nand`> there should definitely be defaulting in GHCi, eg. lack of Integer defaulting would throw ambiguous type errors on every other line
09:45:56 <nand`> for me
09:46:03 <cmccann> no defaulting at all is a pain in the ass
09:46:26 <cmccann> at least for Num-like types
09:46:27 <kosmikus> it should be less of a hack though :)
09:46:47 <jmcarthur> well, lack of defaulting and lack of polymorphic literals would be bearable
09:47:06 <jmcarthur> then numeric literals would just be Integers anyway
09:47:21 <cmccann> but I like polymorphic literals :[
09:47:22 <jmcarthur> not sure i would want to give up the latter just to do away with the former, though
09:47:24 <jmcarthur> i do too
09:48:07 <cmccann> also, the literals should be Natural instead of Integer, with negate handled separately.
09:48:11 <cmccann> also, Natural should exist.
09:48:16 <jmcarthur> i think no defaulting by default but retaining the ability to add it to your .ghci file would be fine
09:48:33 <jmcarthur> yes, Natural should definitely exist
09:49:02 <cmccann> but I've complained about that before
09:49:04 <cmccann> at tedious length
09:49:08 <spaceships> potentially dumb question: best place to read the prelude? haskell report? hackage?
09:49:27 <jmcarthur> not sure about negate being handled separately. seems to me that non-negative literals could use fromNatural and negative ones could use fromInteger
09:49:33 <cmccann> if you want to see very clean, pretty code I think the report has those definitions
09:49:48 <cmccann> jmcarthur, mostly I don't see any reason to change the current behavior
09:50:04 <cmccann> note that toInteger is only applied to positive numbers when converting literals
09:50:28 <jmcarthur> huh?
09:50:37 <cmccann> so it's already defined as syntactic negation + a natural number literal
09:50:41 <jmcarthur> you mean fromInteger?
09:50:45 <cmccann> er
09:50:46 <cmccann> yes.
09:50:48 <jmcarthur> i see
09:50:49 <cmccann> sorry.
09:50:51 <jmcarthur> i didn't realize that
09:50:57 <cmccann> I am trying to eat and type at the same time :P
09:51:03 <jmcarthur> i thought it was applied to both positive and negative literals
09:51:08 <cmccann> nope!
09:51:19 <jmcarthur> okay, then i agree there is no point in changing it
09:52:25 <cmccann> jmcarthur, here's a snippet from one of my various futile escapades raging against Num: http://hpaste.org/63381
09:52:55 <elliott> the clear solution is to remove integers from the language
09:53:16 <cmccann> god gave us the coinductive natural numbers, all else is the work of man
09:53:43 <cmccann> (with apologies to whoever it was that I'm misquoting there)
09:53:55 * jmcarthur facepalms at the joke in the comments
09:54:22 <cmccann> *sunglasses* B]
09:54:37 <elliott> remove numbers from the language
09:54:40 * typoclass1 loves it :) first thing i noticed
09:54:41 <elliott> also strings
09:54:43 <elliott> all disputes solved
09:54:52 <cmccann> numbers are text are too hard anyway
09:56:09 <elliott> remove dates also
09:56:14 <cmccann> yep
09:56:31 <typoclass1> remove ALL the things
09:57:38 <cmccann> but no reaction to the module being named "Numbest", huh?
09:58:12 <jmcarthur> didn't even notice
09:58:29 <cmccann> this is why I probably shouldn't be allowed to name things
10:03:35 <typoclass1> cmccann: i for one like your style. i think that way better than "IsString" or "HasString" would be Stringly, Stringy, Stringish or any number of playful things
10:04:36 <cmccann> I tend to use a mixture of bad puns and unspeakably boring exactly-what-it-sounds-like names
10:04:47 <jmcarthur> nothing quite like stringly typed programming
10:05:06 <McJan_Flanders> So what is the particular reason length and (!!) work with Int and not Num a anyway?
10:05:18 <jmcarthur> probably just to avoid confusing newbies'
10:05:27 <cmccann> because the standard libraries are inexplicably monomorphic all over the place
10:05:27 <mroman> StringThingy .
10:05:44 <jmcarthur> and monomorphic in the wrong ways, too!
10:06:05 <jmcarthur> Int instead of Word for list stuff :(
10:07:01 <McJan_Flanders> jmcarthur, doesn't it serve only to confuse them when they get a crpytic error from it?
10:07:08 <cmccann> typoclass1, also, clearly the class should be "Str", because str-ing is what it lets you do
10:07:21 * typoclass1 giggles
10:07:28 <McJan_Flanders> hughfdjackson, sup dawg.
10:07:37 <jmcarthur> McJan_Flanders: some consider Num a => a to be more cryptic for newbies than Int
10:08:07 <jmcarthur> cmccann: i have facepalmed several times by now
10:08:12 <cmccann> personally I've seen more questions along the lines of "what's the difference between map and fmap" than I have people avoiding confusion because of seeing fewer type classes
10:08:21 <cmccann> it's not like you can avoid type classes entirely
10:08:39 <cmccann> it's kind of a half-assed notion right now
10:08:51 <jmcarthur> i like polymorphism in all the things
10:09:04 <cmccann> either full-ass it and make the whole Prelude monomorphic (including arithmetic!) or give up and stop making it all stupid
10:09:26 <jmcarthur> no-ass, please
10:09:37 <jmcarthur> empty-ass?
10:10:03 <cmccann> initial object in the category of asses? :P
10:10:12 <jmcarthur> bottom
10:10:17 <cmccann> heh
10:10:34 <cmccann> anyway, the monomorphic approach does have some merits for beginners
10:10:57 <rwbarton> it has merits for everyone
10:10:57 <cmccann> I'd strongly consider that for a learning environment with an alternate stripped down Prelude or such
10:11:07 <jmcarthur> import BeginnerPrelude
10:11:15 <typoclass1> Preprelude
10:11:43 <cmccann> I seem to recall mention of... I think Gloss making everything monomorphic? and having a simpler API because of it.
10:12:11 <typoclass1> cmccann: what is gloss again, the opengl thing?
10:12:36 <jmcarthur> cmccann: i will take this opportunity to ask you for help naming a library for 2.5d graphics
10:13:08 <cmccann> jmcarthur, hahaha. what's the specific purpose, anything beyond that?
10:13:17 <jmcarthur> intended for games
10:13:31 <cmccann> yeah, that's what I figured
10:13:48 <merijn> While we're at it, can't we change all IO a stuff into "MonadIO m => m a"? >.>
10:13:55 <jmcarthur> merijn: not all of it
10:14:07 <jmcarthur> merijn: try bracket, for example
10:14:12 <jmcarthur> :t bracket
10:14:12 <cmccann> IO stuff in covariant position perhaps
10:14:13 <lambdabot> Not in scope: `bracket'
10:14:21 <jmcarthur> :t Control.Exception.bracket
10:14:23 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
10:14:32 <merijn> jmcarthur: I know about bracket, I don't see a conceptual reason why you can monadio it
10:14:39 <jmcarthur> merijn: try it :)
10:14:46 <merijn> It'd require changing the build in in GHC, though
10:15:05 <typoclass1> jmcarthur: well, what does the library do? what's the main feature?
10:15:07 <cmccann> yeah, not to be negative (ha, ha), but IO types in contravariant position really don't work the same way.
10:15:08 <jmcarthur> merijn: you could definitely MonadIO the result, but the inputs would be tougher since they are in contravariant position, as cmccann brought up
10:15:30 <merijn> jmcarthur: I did, I have some stuff running in bracket and due to this stupid IO thing I can't run my monadstack in bracket (or more importantly in this case) any wrappers using bracket
10:15:34 <typoclass1> (or is it just "some" 2.5d graphics library)
10:16:00 <rwbarton> it's not a "stupid IO thing", what you want doesn't actually make sense
10:16:02 <cmccann> wanting to use MonadIO in contravariant position is like asking why we need Integral when Num already has a perfectly servicable fromInteger
10:16:07 <jmcarthur> typoclass1: it's a library for rendering sprites with extra information for 3d effects like depth
10:16:38 <merijn> rwbarton: It's stopping me from being able to do what I want, from this it automatically follows that it is stupid :p
10:16:59 <elliott> there is the monad-control thing
10:17:06 <elliott> but it doesn't really work generally
10:17:27 <cmccann> where by "doesn't really work" elliott means "can't possibly work"
10:17:42 <elliott> yes
10:17:42 <jmcarthur> can't in general but can for specific cases, no?
10:18:06 <merijn> The Haskell ZeroMQ bindings provide "withContext" and "withSocket" functions to run something using a specific monad, but the internal use of bracket there means I can't run any arbitrary monadstack inside there or even provide state/reader wrappers :\
10:18:14 <hpaste> zalzice pasted “eval” at http://hpaste.org/75918
10:18:45 <cmccann> sure, it'd work for some monad transformers
10:18:59 <cmccann> after all, IdentityT would be no problem
10:19:03 <zalzice> Hi, I wondering if its possible to put "convertVar" and (convertVar e) in one line?
10:19:06 <cmccann> the question is which others would work :P
10:19:33 <merijn> cmccann: Is there a reason why bracket couldn't work for ReaderT for example?
10:19:42 <cmccann> I think ReaderT would also work, yes
10:20:04 <rwbarton> ReaderT is certainly fine yeah
10:20:05 <cmccann> in fact I think I've written a bracket lifted to ReaderT before
10:20:12 <merijn> I tried writing my own bracket that'd work with Reader, but even that was a ridiculous amount of work
10:20:24 <jmcarthur> really?
10:20:31 <cmccann> but Reader is second only to Identity in terms of playing nice where nothing else does
10:20:33 <rwbarton> (r -> IO a) -> (a -> r -> IO b) -> (a -> r -> IO c) -> (r -> IO c)
10:20:34 <merijn> Because I'd have to reimplemnt all the underlying built ins
10:20:42 <rwbarton> pass the last r to all the other guys
10:20:49 <rwbarton> and call bracket
10:21:34 <jmcarthur> :t \create destroy use r -> Control.Exception.bracket (create r) (`destroy` r) (`use` r)
10:21:36 <lambdabot> forall t a b c. (t -> IO a) -> (a -> t -> IO b) -> (a -> t -> IO c) -> t -> IO c
10:21:45 <merijn> hmm, yeah, that'd work
10:22:49 <rwbarton> State poses more serious issues
10:23:07 <cmccann> and Writer, I'd assume
10:25:27 <rwbarton> zalzice: you can do this: head [s | (Var x,s) <- tmp, x == c ]
10:26:08 <rwbarton> though that might actually mean something different
10:26:32 <rwbarton> alternatively: head [s | (e,s) <- tmp, e == Var c]
10:28:30 <zalzice> rwbarton: Thanks, I will try:-)
10:29:12 <rwbarton> your code will crash if there is a non-Var element in tmp before the matching Var element, whereas my alternatives will just ignore those
10:29:40 <ben_m> Is there a nicer way of saying (c . a &&& c . b), ie. not having to say c . on both sides of &&&
10:30:07 <ben_m> Trying to input the type it'd have to be into Hoogle, but no result yet.
10:30:23 <maukd> @pl \c -> c . a &&& c . b
10:30:24 <lambdabot> liftM2 (&&&) (. a) (. b)
10:30:40 <hiptobecubic> yuck
10:30:43 <ben_m> yuck indeed
10:30:49 <ben_m> I think I'll stick to what I have, that is too clever :D
10:30:52 <jmcarthur> :t let both = join (***) in \a b c -> both c <<< a &&& b
10:30:53 <lambdabot> forall (cat :: * -> * -> *) b c a. (Arrow cat) => cat a b -> cat a b -> cat b c -> cat a (c, c)
10:31:08 <Adeon> meow
10:31:26 <zalzice> rwbarton: Thank you! Work like charm:-)
10:31:29 <jmcarthur> with some higher rank types that could be more polymorphic
10:31:35 <zalzice> a charm*
10:32:01 <hiptobecubic> > sequence . words $ "me ow"
10:32:02 <lambdabot>   ["mo","mw","eo","ew"]
10:32:06 <jmcarthur> you couldn't use join for the more polymorphic version though
10:32:17 <hiptobecubic> > concat. sequence . words $ "me ow"
10:32:19 <lambdabot>   "momweoew"
10:32:30 <typoclass1> ben_m: i use "both f (x,y) = (f x, f y)". it's not the cleverest, but i like to think it's the clearest
10:32:48 <hiptobecubic> @define scream = concat . sequence . words
10:32:49 <ben_m> typoclass1, I agree, thanks
10:32:54 <hiptobecubic> > define scream = concat . sequence . words
10:32:55 <lambdabot>   <no location info>: parse error on input `='
10:33:00 <hiptobecubic> euhhhhh
10:35:18 <monochrom> it's called @let
10:37:56 <germnboy8> http://posatori.com/videos/spanish-hardcore-anal-in-Madrid-Amateur
10:58:45 <digital_monster> learning haskell has made me a better programmer
10:59:13 <atriq> digital_monster, elaborate
10:59:33 <hpaste> betamine pasted “Beginners Error: Could not deduce (t ~ t1)” at http://hpaste.org/75919
10:59:45 <digital_monster> Haskell has taught me to perceive programming differently
10:59:51 <integral> learning haskell has made me frustrated by facilities provided elsewhere :-)
11:00:17 <digital_monster> its great that languages like C++ steal great features from Haskell
11:00:26 <betamine> Can't figure out why it won't work.
11:00:35 <maukd> betamine: because f and g are monomorphic
11:00:50 <atriq> betamine, add type signatures to f and g, or run with NoMonomorphismRestriction
11:00:54 <typoclass1> digital_monster: glad to hear it :) keep it up
11:00:58 <maukd> atriq: wat
11:01:03 <integral> digital_monster: no, it's really awful:  C++ is gigantic, very complicated, and has very little syntax
11:01:14 <atriq> betamine, I'm probably wrong
11:01:22 <atriq> Judging by maukd's reaction
11:01:22 <rwbarton> this won't work with nomonomorphismrestriction
11:01:44 <maukd> atriq: there is no code of the form 'identifier = expression', so the MR won't trigger
11:02:11 <rwbarton> @type (>>=)
11:02:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:02:12 <atriq> Ah, okay
11:02:29 <atriq> I assumed it would also kick in with <-'s
11:02:41 <rwbarton> ^ the argument 'a' to the second argument is not a polymorphic type there
11:02:41 <maukd> <- is syntactic sugar for function parameters
11:02:43 <typoclass1> betamine: i see the very first line is commented; what was the problem it caused?
11:02:53 <maukd> parameters are always monomorphic
11:03:28 <betamine> typoclass1: For example, want to be able to call `steps' (4,'a')`
11:03:54 <typoclass1> betamine: ah
11:06:40 <rwbarton> it works in ghc with sufficient type system extensions and type annotations
11:07:14 <rwbarton> but probably better to just do something like
11:07:53 <rwbarton> fi <- [0, 1]; let f = case fi of 0 -> pred ; 1 -> succ
11:08:52 <rwbarton> or will that not work in modern ghc any more
11:08:58 <typoclass1> rwbarton: what are thos extensions? (other than NoMono)
11:09:08 <typoclass1> s/thos/those
11:09:16 <hpaste> rwbarton annotated “Beginners Error: Could not deduce (t ~ t1)” with “Beginners Error: Could not deduce (t ~ t1) (annotation)” at http://hpaste.org/75919#a75920
11:09:25 <rwbarton> not beginner-recommended
11:09:47 <typoclass1> ugh, whoa
11:10:08 <maukd> NoMonomorphismRestriction only helps against the MR
11:12:46 <rwbarton> or you can use a newtype wrapper and avoid those extensions
11:14:17 <rwbarton> that would just require Rank2Types
11:14:38 <betamine> rwbarton: thanks, I thought is was going to be a simple fix :) I'll just go back to doing something less clever.
11:15:19 <betamine> So the problem is that the type of "f" and "g" is fixed from within steps'?
11:15:31 <rwbarton> here is a much simpler example
11:15:38 <hpaste> betamine annotated “Beginners Error: Could not deduce (t ~ t1)” with “Beginners Error: Could not deduce (t ~ t1) (annotation) (annotation)” at http://hpaste.org/75919#a75921
11:15:46 <rwbarton> > (\f -> (f (5 :: Int), f 'x')) $ succ
11:15:47 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
11:15:47 <lambdabot>         against inferred type...
11:16:10 <rwbarton> you cannot freely pass a polymorphic value through a lambda and use it at multiple types inside
11:18:24 <maukd> > (\f -> (f False, f 'a')) succ
11:18:25 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
11:18:25 <lambdabot>         against inferred type...
11:18:40 <maukd> > (\f g -> (f False, g 'a')) succ succ
11:18:41 <lambdabot>   (True,'b')
11:18:59 <maukd> > join (\f g -> (f False, g 'a')) succ
11:19:00 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
11:19:00 <lambdabot>         against inferred type...
11:21:21 <ben_m> What would one use the ((->) r) Monad instance for?
11:21:42 <ben_m> What I mean is, is there a general purpose for function monads
11:22:09 <hiptobecubic> ben_m, it's good for doing tricks on irc
11:22:09 <shachaf> The (r ->) monad was discovered, not invented. It has no purpose.
11:22:16 <ben_m> hiptobecubic, heh, that's what I expected
11:22:35 <ben_m> shachaf, I see
11:23:05 <Eduard_Munteanu> ben_m: it's just an unwrapped Reader monad
11:23:20 <hiptobecubic> > filterM (const [True, False]) [1,2,3]
11:23:20 <maukd> ben_m: yes, implicitly passing an argument
11:23:21 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
11:23:22 <hiptobecubic> there's always that one
11:23:33 <maukd> hiptobecubic: ?
11:23:42 <hiptobecubic> well
11:23:45 <hiptobecubic> return instead of const
11:23:52 <hiptobecubic> > filterM (return [True, False]) [1,2,3]
11:23:53 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
11:23:56 <maukd> > return 1 2
11:23:57 <lambdabot>   1
11:24:10 <rwbarton> that is not really a thing it is "good" for
11:24:12 <hiptobecubic> > 1 2
11:24:13 <lambdabot>   1
11:24:57 <ben_m> maukd, that's essentially what Eduard_Munteanu said, right?
11:25:05 <maukd> yes
11:25:10 <maukd> (->) r is Reader
11:25:13 <ben_m> Great, thanks!
11:31:37 <ixmatus> I'm reading Learn you as haskell and I'm working on the  functors-applicative-functors-and-monoids chapter
11:31:54 <ixmatus> I'm working on this part of it where they use newtype
11:32:00 <ixmatus> and there's this example: newtype Pair b a = Pair { getPair :: (a,b) }
11:32:21 <ixmatus> but it is never explained as to why Pair b a's order is significant
11:32:35 <voidf> can a function take a type?
11:32:50 <maukd> voidf: no
11:32:52 <shachaf> ixmatus: The argument order matters for instance Functor
11:32:54 <voidf> Int Char
11:32:57 <alephomega> voidf: types are not valies
11:33:01 <alephomega> values*
11:33:10 <voidf> then minBound :: Char
11:33:11 <shachaf> ixmatus: Try writing a Functor instance and you'll see!
11:33:17 <byorgey> voidf: in a sense, the answer is yes: polymorphic functions take types as arguments.
11:33:18 <ixmatus> shachaf I gathered that as I did the instance Functor (Pair c) where example
11:33:27 <voidf> minBound :: Char
11:33:28 <byorgey> voidf: but the type arguments are implicit, and it's impossible to pattern-match on them
11:33:41 <ixmatus> and switched the args to get a fmap instance that worked on the last value
11:33:59 <ixmatus> but I'm somewhat confused as to *why* it's working that way?
11:33:59 <shachaf> Type functions can take types.
11:34:24 <voidf> this is funny func61 x = (minBound x,maxBound x)
11:34:41 <maukd> voidf: minBound isn't a function
11:34:57 <jmcarthur> it is in a hidden way
11:34:58 <voidf> then
11:35:22 <shachaf> ixmatus: I'm not sure what you're asking.
11:35:25 <merijn> > (minBound, maxBound) :: (Char, Int)
11:35:26 <lambdabot>   ('\NUL',9223372036854775807)
11:35:42 <monochrom> "minBound x" is likely a type error, unless you have a wacky instance of Bounded
11:35:43 <jmcarthur> minBound could be a function, in fact, depending on what instances are in scope
11:35:56 <shachaf> I suspect Pair isn't the best example because there's nothing really interesting about the order.
11:36:04 <jmcarthur> > minBound 5 :: Int -- just checking
11:36:05 <lambdabot>   No instance for (GHC.Enum.Bounded (t -> GHC.Types.Int))
11:36:05 <lambdabot>    arising from a u...
11:36:10 <ixmatus> shachaf well, I'm asking about why newtype Pair b a vs newtype Pair a b produce widely different results when creating an instance of it for functor
11:36:19 <rwbarton> voidf seems already really confused without adding possibilities like Bounded (a -> b) ...
11:36:30 <maukd> ixmatus: because f x y is different from f y x
11:36:38 <ixmatus> I assumed the a and the b were just type variables
11:36:41 <ixmatus> mmkay
11:36:42 <byorgey> instance Bounded a => Bounded (e -> a) where  minBound = const minBound   -- this really isn't so wacky, is it?
11:36:48 <rwbarton> no but
11:36:54 <maukd> byorgey: yes, it is
11:36:55 <jmcarthur> ixmatus: a functor must be a type constructor that accepts only one argument, so the last argument is the one that matters
11:36:55 <rwbarton> can anyone figure out what on earth voidf is asking
11:37:25 <voidf> func x = (minBound x,maxBound x) i know is wrong but somethin like this
11:37:27 <byorgey> OK, sorry, you're right, just confusing voidf
11:37:35 <ixmatus> jmcarthur okay that make sense based on what I did with the functor instance for fmap with it - but how is the type variable 'b' being "hidden" so-to-speak?
11:37:40 <voidf> func ::  Char
11:37:55 <jmcarthur> voidf: are you wanting the min and max bounds of the type of an argument?
11:38:06 <hpc> byorgey: fairly straightforward to me
11:38:22 <cmccann> byorgey, just defined minBound = undefined for all types. it's correct in some sense, right? :P
11:38:43 <hpc> does Bounded imply Ord?
11:38:45 <jmcarthur> :t let f x = (minBound `asTypeOf` x, maxBound `asTypeOf` x) in f 'a'
11:38:47 <lambdabot> (Char, Char)
11:38:50 <jmcarthur> > let f x = (minBound `asTypeOf` x, maxBound `asTypeOf` x) in f 'a'
11:38:52 <lambdabot>   ('\NUL','\1114111')
11:38:57 <voidf> i want to get at the same time Char min and max bound
11:38:59 <voidf> in a func
11:39:09 <rwbarton> > (minBound, maxBound) :: (Char, Char)
11:39:09 <lambdabot>   ('\NUL','\1114111')
11:39:10 <voidf> Char Int etc
11:39:11 <jmcarthur> you don't need a function for that
11:39:14 <shachaf> cmccann: You should make a Spoon-like Ord instance for any type based on definedness!
11:39:16 <jmcarthur> it's just a value
11:39:16 <monochrom> ixmatus: for a smaller example, "newtype X a b = Ctor a; Functor (X a) ..." and "newtype Y b a = Ctor a; Functor (Y b) ..." are pretty different
11:39:21 <rwbarton> > (minBound, maxBound) :: (Int, Int)
11:39:22 <lambdabot>   (-9223372036854775808,9223372036854775807)
11:39:23 <jmcarthur> which happens to be polymorphic
11:39:25 <shachaf> Hmm, I guess Ord is total ordering.
11:39:30 <cmccann> shachaf, that sounds like a delightfully bad idea
11:39:37 <jmcarthur> voidf: just use (minBound, maxBound)
11:39:49 <ixmatus> monochrom yeah I did that with pair and the reverse order of the original one too
11:39:57 <t7> @hoogle bounds
11:39:57 <lambdabot> Data.Graph type Bounds = (Vertex, Vertex)
11:39:57 <lambdabot> Data.Array.IArray bounds :: (IArray a e, Ix i) => a i e -> (i, i)
11:39:57 <lambdabot> Data.Array bounds :: Ix i => Array i e -> (i, i)
11:39:58 <maukd> ixmatus: currying. f x y means (f x) y
11:40:01 <voidf> why minBound can take ::Char ?
11:40:10 <maukd> voidf: it doesn't take :: Char
11:40:11 <jmcarthur> voidf: it doesn't *take* anything. Char is just the type
11:40:17 <maukd> :: Char is an annotation of the result type
11:40:22 <digital_monster> > sum $ map (1/) [2..10]
11:40:24 <lambdabot>   1.928968253968254
11:40:30 <voidf> how can i get the type in a func
11:40:31 <jmcarthur> > 'f' :: Char -- voidf
11:40:33 <lambdabot>   'f'
11:40:36 <ixmatus> maukd ahh! ok
11:40:42 <shachaf> voidf: Do you know how (5 :: Int) works?
11:40:48 <voidf> yes
11:40:57 <shachaf> It's the same thing.
11:40:58 <jmcarthur> voidf: the :: Char just tells the compiler what type you're expecting. it is not an argument
11:41:33 <shachaf> > ord maxBound
11:41:34 <lambdabot>   1114111
11:41:40 <shachaf> @ty ord
11:41:45 <lambdabot> Char -> Int
11:41:48 <shachaf> See, no (:: Char) necessary.
11:42:09 <voidf> so i cant make a function like minBound that returns both max and min and the same time of a given type
11:42:15 <rwbarton> what
11:42:19 <rwbarton> (minBound, maxBound)
11:42:21 <jmcarthur> voidf: it is not a function
11:42:29 <jmcarthur> voidf: it's just (minBound, maxBound). that's the whole thing
11:42:40 <rwbarton> minBound is not a function either
11:42:58 <jmcarthur> voidf: you just use that and the correct type will be chosen based on how you use it
11:43:06 <rwbarton> it is a value of type Char, and also a value of type Int, and ...
11:43:25 <rwbarton> just like 5 is a value of type Int, and also a value of type Double, and ...
11:43:27 <voidf> :(
11:43:30 <rwbarton> no
11:43:30 <rwbarton> :)
11:43:32 <maukd> voidf: what
11:43:37 <elliott> need to systematically purge all those tutorials that call random values functions
11:43:37 <jmcarthur> voidf: why is this undesirable?
11:43:59 <voidf> cant make my own minBound
11:44:04 <jmcarthur> why not?
11:44:08 <ixmatus> so "instance Functor (Pair c)" the (Pair c) part is actually expecting a curried type constructor there?
11:44:14 <monochrom> @let monof :: (Int, Int); monof = (minBound, maxBound)
11:44:15 <lambdabot>  Defined.
11:44:19 <monochrom> > monof
11:44:20 <jmcarthur> voidf: it's nothing built in
11:44:21 <lambdabot>   (-9223372036854775808,9223372036854775807)
11:44:24 <monochrom> works
11:44:25 <shachaf> :⎠
11:44:35 <jmcarthur> voidf: do you know what type classes are?
11:44:40 <monochrom> works for me, I don't see a problem
11:44:42 <voidf> yis
11:44:54 <jmcarthur> voidf: that is the mechanism for defining your own minBound for new types
11:44:55 <shachaf> ixmatus: It's not "curried", but yes, it takes another argument.
11:44:57 <byorgey> ixmatus: the argument to Functor must be something of kind  * -> *
11:45:00 <shachaf> ixmatus: Pair :: * -> * -> *
11:45:05 <shachaf> (Pair c) :: * -> *
11:45:05 <jmcarthur> voidf: or for creating a brand new minBound for all possible types
11:45:11 <byorgey> ixmatus: since  Pair :: * -> * -> *, which is curried... what shachaf said.
11:45:18 <rwbarton> ixmatus: just do the substitution; "class Functor f where fmap :: (a -> b) -> f a -> f b"; "instance Functor (Pair c) where ..." so f = Pair c; "... fmap :: (a -> b) -> f a -> f b" becomes fmap :: (a -> b) -> Pair c a -> Pair c b
11:45:19 <voidf> ok
11:45:20 <monochrom> @undefine
11:45:31 <ixmatus> shachaf ahh! that clicks for me now
11:45:53 <shachaf> Yay, unification.
11:46:06 <ixmatus> (I meant to say "partial function" not curried function, is that the more correct way to say what I said?)
11:46:09 <shachaf> Haskell 101 books should probably talk about unification when they bring up types.
11:46:13 <ixmatus> errr
11:46:15 <shachaf> For some reason I don't think they do.
11:46:25 <shachaf> ixmatus: No, "partial function" means something completely different.
11:46:26 <ixmatus> s/function/type constructor
11:46:26 <jmcarthur> they like to pretend type inference is magical for some reason
11:46:27 <nand`> is '(*, *) a valid type?
11:46:28 <nand`> err
11:46:30 <nand`> valid kind
11:46:31 <byorgey> ixmatus: it is a partially applied type constructor
11:46:32 <rwbarton> this isn't even really unification
11:46:43 <ixmatus> I meant to say type constructor
11:46:44 <rwbarton> just substitution
11:47:03 <monochrom> in fact, high school math is already all about unification
11:47:15 <maukd> nand`: no
11:47:32 <ixmatus> so why is Monad not part of Functor?
11:47:36 <monochrom> "x+y = y+x", unify x with a*b, unify y with c, get: a*b + c = c + a*b
11:47:39 <shachaf> maukd: It's not?
11:47:49 <rwbarton> again substitution not unification
11:47:52 <jmcarthur> yeah i don't see why not
11:47:56 <rwbarton> but yes, this is basic algebraic manipulation
11:47:58 <byorgey> nand`: yes, with -XDataKinds, though note you don't need the quote
11:48:04 <byorgey> nand`: actually the quote is not allowed
11:48:14 <byorgey> nand`: '(Int,Bool) :: (*,*)
11:48:16 <maukd> oh, DataKinds
11:48:26 <shachaf> byorgey: No, (Int,Bool) :: *
11:48:43 <byorgey> shachaf: (Int,Bool) :: *, and  '(Int,Bool) :: (*,*)
11:48:45 <shachaf> Er, wait.
11:48:48 * shachaf sighs.
11:48:54 <shachaf> Yes, what byorgey said.
11:49:08 <nand`> byorgey: I see, thanks
11:50:05 <nand`> I forget the ' is only for types
11:50:19 <monochrom> oh, it's unification when you have a bigger problem. "x+y = y+x, so a*b+c = ?" now you use unification to find a good substitution
11:50:24 <dolio> How about -XNoPuns.
11:50:28 <byorgey> right, and it's also confusing with (,) because the data and type constructor have the same name
11:51:05 <shachaf> dolio: I quit!
11:51:15 <cmccann> byorgey, even more fun is explaining to beginners what [] means
11:51:28 <shachaf> > rot13 "shachaf"
11:51:30 <lambdabot>   "funpuns"
11:51:37 <cmccann> because that's not at all the same thing for types vs. terms, unlike (,) which roughly is
11:52:00 <dolio> Wow, really?
11:52:33 <byorgey> cmccann: heh, indeed
11:52:34 <typoclass1> it looks plausible, but i really can't believe it
11:52:54 <monochrom> unification is a skill everyone learns and then intentionally loses because "the exam is over, I want to forget everything". subsequently, when programming tasks call for unification, people fail
11:53:15 <nand`> [A] :: BOX; '[A] :: [*]; [A] :: *; [A] :: [A]
11:53:22 <danharaj> > rot13 "danharaj"
11:53:23 <shachaf> I've never had an exam that mentioned unification.
11:53:25 <lambdabot>   "qnaunenw"
11:53:28 <danharaj> aw
11:53:49 <monochrom> the name is never mentioned, yes.
11:53:52 <nand`> naturally, data A = A
11:53:59 <nand`> confusing enough yet?
11:54:53 <cmccann> shachaf, see, that rot13 thing and stuff like that is why I'm starting to think Cale is right that you're actually a character from a Douglas Hofstadter book
11:54:57 <cmccann> it explains so much
11:55:24 <shachaf> cmccann: What does that make you?
11:55:55 <cmccann> I'm kind of afraid to ask really
11:55:59 <voidf> :t in sourcode
11:56:00 <lambdabot> parse error on input `in'
11:58:19 <jmcarthur> > rot13 "cmccann"
11:58:21 <lambdabot>   "pzppnaa"
11:58:26 <cmccann> :[
11:58:31 <merijn> Speaking of DataKinds, someone should fix github's syntax highlighter for Haskell, DataKinds quotes break it :p
11:58:51 <nand`> I saw that :)
11:59:04 <cmccann> it breaks the syntax highlighting in SciTE too :[
11:59:19 <cmccann> also quoting names for TH
11:59:34 <nand`> it works in vim iirc
11:59:35 <cmccann> (as you'd expect)
12:11:13 * hackagebot cabal-meta 0.3 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.3 (GregWeber)
12:12:44 <jackfdhughes> hughfdjackson, Fenner David, right?
12:15:34 * Mortchek looks at jackfdhughes, then looks at hughfdja1kson, then back.
12:16:16 <Mortchek> I was unaware he had an evil twin.
12:16:22 <Mortchek> s/evil/good/
12:16:33 <hpc> they're both evil, one just has a moustache
12:16:33 <jackfdhughes> Twins tend to share last names though.
12:16:42 <jackfdhughes> I beg to differ
12:16:43 <jackfdhughes> a goatee
12:16:47 <Mortchek> hpc, so, jackfdhughes has no mustache?
12:17:12 <jackfdhughes> http://media.photobucket.com/image/recent/JML9999/MirrorSpock.jpg self evident
12:23:15 <Wordskilove> Hey, I got a question about something I've been wrestling a little with, It seems I cannot make an infix function using words (test) :: a ->a but only using operators like (+++) :: a -> a is my observation correct and is there anyway to circumvent this other than using `test` ?
12:23:55 <Eduard_Munteanu> Wordskilove: yeah, you can't use 'test' infix like that.
12:24:06 <nand`> and yes, the only way to make a word infix is via ``
12:24:25 <Wordskilove> ok, thanks. always quick and nice help here! :D
12:24:38 <nand`> haskell has separate naming rules for ‘operators’ and ‘names’; the former of which consist of certain symbols and are infix by default; the latter of which are not infix by default and consist of mainly letters
12:27:02 <cmccann> note that you can still give fixity declarations for alphanumeric identifiers
12:27:19 <cmccann> as well as write them infix when defining a function
12:28:03 <Mortchek> > let a `f` b = a * b + a in 10 `f` 20
12:28:04 <lambdabot>   210
12:36:04 <jackfdhughes> CAn you actually just store a number in an operator?
12:36:23 <hpc> jackfdhughes: "store"?
12:36:35 <jackfdhughes> > let (++) = 3 in 3 ++ 4
12:36:36 <lambdabot>   3
12:36:42 <jackfdhughes> Oh yeah, wait
12:36:45 <identity> how does one create a quickcheck test where you manually specify the domain for the input?
12:36:46 <jackfdhughes> > let (++) = 3 in (3 ++ 4)
12:36:47 <lambdabot>   3
12:36:56 <jackfdhughes> Huuuh
12:37:01 <jackfdhughes> > let (++) = 5 in (3 ++ 4)
12:37:02 <lambdabot>   5
12:37:08 <merijn> jackfdhughes: Caleskell is messing with you :p
12:37:12 <copumpkin> jackfdhughes: that's lambdabot's idiosyncrasies
12:37:12 <rwbarton> > 5 3 4
12:37:13 <lambdabot>   5
12:37:23 <jackfdhughes> Yeah, I know, that's why I did the brackets
12:37:26 <jackfdhughes> But especially the last case
12:37:41 <identity> jackfdhughes: an operator is just a function.
12:37:45 <jackfdhughes> I know
12:37:47 <merijn> jackfdhughes: Look at rwbarton's example, that's what your code ends up being
12:38:03 <digital_monster> `No instance for (Num (a0 -> a1 -> t0)) arising form the literal `5'`
12:38:05 <jackfdhughes> I know, that doesn't sense
12:38:13 <jackfdhughes> It should surely complain about trying to apply a number?
12:38:17 <copumpkin> :t 5
12:38:19 <lambdabot> forall t. (Num t) => t
12:38:23 <copumpkin> all it wants is a Num instance
12:38:28 <copumpkin> if you have one for functions, then it'll work
12:38:36 <merijn> jackfdhughes: No, lambdabot has a Num instance for functions
12:38:43 <Mortchek> jackfdhughes, number literals have no type unless constrained; they can represent anything of the Num typeclass
12:38:46 <merijn> jackfdhughes: Which confuses lots of people in scenarios like this :)
12:38:49 <hpc> :t let f = 5 in (f, f 22)
12:38:50 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
12:38:59 <hpc> huh
12:39:00 <jackfdhughes> Yeah, I know, but surely (5 3 1) can't ever typecheck
12:39:01 <Mortchek> so if you have an instance of Num for functions, you can use them where you'd need a function
12:39:13 <jackfdhughes> It's trying to apply a number to another number.
12:39:15 <Mortchek> which is presumably what lambdabot was doing above
12:39:18 <merijn> jackfdhughes: SUre it can
12:39:20 <copumpkin> jackfdhughes: Haskell doesn't know about "number"
12:39:24 <merijn> jackfdhughes: 5 :: Num a => a
12:39:24 <digital_monster> why do we say that Haskell is a non-strict language as opposed to a lazy language?
12:39:26 <copumpkin> jackfdhughes: it knows about the Num typeclass
12:39:30 <hpc> jackfdhughes: there's a num instance for functions
12:39:35 <hpc> it's used for stuff like this
12:39:44 <copumpkin> > (sin^2 + cos^2) 5
12:39:45 <lambdabot>   0.9999999999999999
12:39:47 <hpc> that
12:39:48 <merijn> digital_monster: Laziness means that everything is *guaranteed* to be only computed once
12:39:52 <cmccann> non-strict is about meaning, laziness is about implementation
12:39:53 <merijn> digital_monster: Which is not true in haskell
12:39:55 <ion> > (sin^2 + cos^2) 5 :: CReal
12:39:56 <lambdabot>   1.0
12:40:07 <cmccann> I don't think Haskell is required to be lazy
12:40:24 <hpc> the haskell report takes great pains to avoid such things as specificity
12:40:25 <digital_monster> so laziness is a synonym for applicative evaluation?
12:40:28 <jackfdhughes> Yes, I know that's the type of 5. But it's not Num a => x -> y -> a or anything.
12:40:39 <hpc> jackfdhughes: but it CAN be
12:40:48 <hpc> 5 is polymorphic
12:40:48 <Mortchek> jackfdhughes, the type of 5 is (Num a) => a
12:40:55 <Trudko> whats wrong with this cartProd xs ys = [(x,y) | x <- xs, y <- ys] ?
12:40:58 <Mortchek> jackfdhughes, in other words, it can be of *any* type which is an instance of Num
12:41:00 <jackfdhughes> > 5.0 1 2
12:41:01 <lambdabot>   5.0
12:41:02 <Trudko> >> cartProd xs ys = [(x,y) | x <- xs, y <- ys]
12:41:09 <jackfdhughes> Yeah, I know that.
12:41:09 <ion> trudko: Nothing.
12:41:10 <c_wraith> :t 5 :: Num a => x -> y -> a
12:41:11 <lambdabot> forall x y a. (Num a) => x -> y -> a
12:41:14 <merijn> jackfdhughes: Lambdabot has a "Num (a -> a)" (or something like that) instance
12:41:14 * hackagebot idris 0.9.4.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.4.1 (EdwinBrady)
12:41:17 <hpc> > (5 :: Int -> IO String -> Double) 22 getLine
12:41:19 <lambdabot>   5.0
12:41:22 <jackfdhughes> :t (5.0 1 2)
12:41:22 <cmccann> > liftA2 (,) [1..3] [11..13]
12:41:23 <lambdabot> forall t t1. (Fractional (t1 -> t), Num t1) => t
12:41:23 <lambdabot>   [(1,11),(1,12),(1,13),(2,11),(2,12),(2,13),(3,11),(3,12),(3,13)]
12:41:24 <merijn> Oh, even more general
12:41:50 <jackfdhughes> merijn, for 5?
12:41:50 <hpc> jackfdhughes: instance Num a => Num (anything -> a) where ...
12:41:55 <hiptobecubic> Does anyone know why 0-based indexing became standard? Fortran doesn't use it and most math texts don't seem to either
12:42:00 <hpc> Double is a Num, so (IO String -> Double) is a Num
12:42:08 <hpc> and Int -> (IO String -> Double) is a Num
12:42:10 <jackfdhughes> So basically, there is an instance in it where 5 _ _ = 5
12:42:11 <copumpkin> hiptobecubic: because it's nice to have an additive identity when doing index manipulation
12:42:19 <jackfdhughes> What's the purpose of that?
12:42:19 <hpc> the implementation is fromIntegral x = const x
12:42:20 <digital_monster> anyone here use Haskell as a scripting language? i.e. having lots of .hs files with #!/usr/bin/env runhaskell at the top?
12:42:23 <dolio> 0-based is better.
12:42:25 <hpc> plus other stuff
12:42:31 <cmccann> yes, 0-based indexing is hella convenient for actually computing offsets
12:42:35 <dolio> I think monochrom has a Dijkstra paper showing why.
12:42:43 <hpc> jackfdhughes: (sin^2 + cos^2) 5
12:42:44 <copumpkin> jackfdhughes: you saw what I wrote before, where I wrote sin^2 + cos^2?
12:42:47 <hiptobecubic> digital_monster, some people use shelly i think.
12:42:56 <hpc> sin and cos are being treated like numbers when you exponentiate them
12:43:10 <jackfdhughes> copumpkin, yeah, what's with it?
12:43:20 <copumpkin> jackfdhughes: it lets me add functions like I add numbers
12:43:22 <hpc> and the result is fairly apparent
12:43:23 <monochrom> yes, http://www.cs.utexas.edu/users/EWD/transcriptions/EWD08xx/EWD831.html
12:43:24 <copumpkin> and square them
12:43:33 <copumpkin> jackfdhughes: in fact, many mathematicians use that kind of shorthand
12:43:44 <copumpkin> when they talk about the equation sin^2 + cos^2 = 1
12:44:00 <Mortchek> If you didn't have a Num instance for those, you'd have to write something like (\n -> (sin n)^2 + (cos n)^2) 5, which is way less convenient
12:44:03 <hiptobecubic> I prefer 0-based as well, but I was reading http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2034.htm ('') and the guy begging for a linear algebra library cites 1-based indexing as 'necessary' and 'more natural' for stats and math people.
12:44:26 <cmccann> "necessary"?
12:44:40 <monochrom> I don't use the word "natural" easily. only the nipple is natural.
12:45:05 <monochrom> but, "0-based is convenient" and "1-based is convenient" are fair statements
12:45:19 <c_wraith> monochrom: mothers might argue with that. (many babies need to be taught)
12:45:24 <cmccann> monochrom, you would think so but babies have a hard time figuring even that out
12:45:36 <monochrom> cool, then nothing is natural
12:46:28 <monochrom> I really like that because people speak like "mutable variable is natural" or "object is natural" or "function is natural". wrong, all of them are learned
12:46:29 <cmccann> the suckling reflex is innate. getting them to stop flailing and latch on is another matter.
12:47:06 <c_wraith> there are natural extensions to existing things you already know.
12:47:13 <Eduard_Munteanu> What about "is natural in X"? :P
12:47:22 <shapr> byorgey: Hey, your Friday blog post using diagrams is the coolest Haskell I've seen this week!
12:47:23 <cmccann> monochrom, I think it's safe to say that any way of thinking about programming that you can communicate to a computer is inherently unnatural for people
12:48:00 <Eduard_Munteanu> shapr: linky?
12:48:04 <shapr> In case you haven't seen byorgey's blog post, look at: http://mathlesstraveled.com/2012/10/05/factorization-diagrams/
12:48:07 <cods> whoah. What I need to do to have (sin^2 + cos^2) 5 working in ghci? (that's really valid?)
12:48:15 <cmccann> (also, anyone who says that OOP is a natural fit for the real world doesn't understand OOP and/or reality)
12:48:15 <shapr> Eduard_Munteanu: It's really nifty.
12:48:34 <shapr> cmccann: I strongly agree, programming is unnatural :-)
12:48:55 <identity> okay.. so, sources on how to actually use quickcheck beyond simple boolean functions(such as specifying the domain of the input to functions), anyone? I obviously can't redefine the Arbitrary instance for Int or Char
12:49:11 <jackfdhughes> copumpkin, yeah, I know, that's the stuff I'm trying to avoid honestly.
12:49:11 <shapr> identity: I think you can actually.
12:49:16 <identity> shapr: I tried
12:49:22 <identity> it just gives me duplicate instance declarations
12:49:27 <cmccann> rudimentary imperative programming is arguably the least unfamiliar to most people, since "follow these instructions" is a well-established concept
12:49:29 <copumpkin> jackfdhughes: well, we're just saying why it works that way :P
12:49:34 <copumpkin> haskell makes it possible
12:49:37 <copumpkin> even though most people don't use it
12:49:41 <jackfdhughes> It gets messy and ambiguous pretty quickly if you use things like cos^2 to mean \x -> (cos x)^ 2 instead of cos . cos
12:49:41 <shapr> identity: I would have expected QuickCheck to have the instances in a separate module so you can import only the ones you want.
12:49:42 <cmccann> but it's still not in any way "natural"
12:49:50 <jackfdhughes> copumpkin, I had no idea.
12:50:08 <identity> shapr: Not quickcheck 2.* as I understand. 1.* let you define them manually so you could control the domain
12:50:13 <jackfdhughes> So there is an instance of Num which contains cos/
12:50:15 <jackfdhughes> Basically
12:50:24 <shapr> cmccann: Yes, arguing by 'naturalness' precludes any interface or API past the nipple.
12:50:26 <jackfdhughes> I don't know, I'd rather 5.0 1 2 just flagged you at compile time.
12:50:36 <copumpkin> it normally does
12:50:41 <copumpkin> unless you go out of your way to get instances
12:50:42 <cmccann> shapr, we just went over that, it precludes that as well :P
12:50:45 <identity> it provides primitives to generate bounded integers and such, but I have no idea what type a function that uses those primitives would even have and so on.
12:50:49 <copumpkin> lambdabot happens to contain them
12:50:49 <shapr> cmccann: Oh, I missed that part.
12:50:57 <shapr> bah, now I see it.
12:51:00 <jmcarthur> jackfdhughes: (cos x)^2 is not the same as (cos . cos) x
12:51:04 * shapr goes back to writing SNOBOL code
12:51:14 <jmcarthur> > (cos x)^2
12:51:15 <lambdabot>   cos x * cos x
12:51:18 <jmcarthur> > (cos . cos) x
12:51:21 <lambdabot>   cos (cos x)
12:51:23 <Mortchek> (^) is power over multiplication
12:51:29 <jackfdhughes> jmcarthur, that's what I said 'instead of'
12:51:42 <shapr> Eduard_Munteanu: If you've already read byorgey's awesome blog post, look at sjoerd visser's svg : https://dl.dropbox.com/u/205768/factorDiagram.svg
12:51:46 <jmcarthur> jackfdhughes: oh i misinterpreted
12:52:01 <monochrom> only the nipple and the natural transformation are natural
12:52:18 <osfameron> natural transformation?
12:52:31 <monochrom> yes, the one in category theory
12:52:32 <osfameron> also, trackpads are much better than nipples
12:52:33 <Mortchek> The non-negative integers are naturals
12:52:35 <Mortchek> :P
12:52:36 <jackfdhughes> jmcarthur, well, I basically mean the akwkward story where in analysis you can encounter sin^2(x) to mean both (sin(x))^2 and sin(sin(x)) basically
12:52:44 <monochrom> hehe
12:52:58 <lightquake> i've never seen sin^2(x) to mean sin(sin(x))
12:53:04 <jmcarthur> nor have i, to be honest
12:53:10 <jmcarthur> but i can see where that might come from
12:53:21 <lightquake> yeah, but nobody would use that because it'd be confusing
12:53:28 <jmcarthur> in many texts, "fg" means "f . g" or "g . f"
12:53:31 <Mortchek> I've seen it in a few textbooks. Normally when the power is applied to the function itself, it means a power of that function rather than exponentiation
12:53:31 <osfameron> but if it means sin(x)^2 why not just say that?
12:53:41 <osfameron> sin^2 in itself is odd
12:53:55 <Mortchek> So sin^2(x) would be distinct from sin(x)^2
12:53:59 <rwbarton> for the particular case of trig functions "sin^2 x" is traditional for "(sin x)^2" because that one is actually useful
12:54:08 <lightquake> what rwbarton said
12:54:21 <lightquake> sin(sin(x)) is used a lot less than sin(x)^2
12:54:28 <elliott> still yucky
12:54:36 <hpc> sin^2 lets you write those formulas pointfree in x
12:54:43 <jackfdhughes> osfameron, that is what I wonder indeed.
12:54:44 <hiptobecubic> @src sequence
12:54:44 <lambdabot> sequence []     = return []
12:54:44 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:54:44 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
12:54:48 <identity> So, no one here actually has any sources on how to use quickcheck? Am I just doomed to attempt to grok this colossal library until I  can piece something together?
12:54:51 <jackfdhughes> But I've seen it a lot to mean that.
12:54:52 <osfameron> ah, points
12:54:59 <rwbarton> no one really writes the trig equalities points-free
12:55:06 <hpc> :t (^2) + (^2)
12:55:07 <lambdabot> forall a. (Num a) => a -> a
12:55:27 <rwbarton> but sin^2 x + cos^2 x = 1 looks better than (sin x)^2 + (cos x)^2 = 1
12:55:35 <rwbarton> fewer parentheses, haskellers should be able to relate to that :P
12:55:39 <cods> what do you need to import to have sin^2 to be valid?
12:55:41 <jackfdhughes> I have seen f^2 to mean f . f more than I have seen f^2 to mean \x -> (f x)^2 anyway.
12:55:52 <hiptobecubic> > sequence [even, odd] 5
12:55:53 <lambdabot>   [False,True]
12:56:11 <merijn> cods: It's an instance in lambdabot, don't think it's any default library
12:56:20 <cods> oh ok
12:56:25 <monochrom> why are we arguing over this, when the most basic question "is 0 a natural number?" is still in dispute? :)
12:56:31 <merijn> cods: You can check out lambdabot's source for the implementation of course?
12:56:35 <Trudko> How would i change this  cartProd xs ys = [(x,y) | x <- xs, y <- ys] ?  so each element multiply. For example for cartProdu [2] [2] i would get  [(4)]
12:56:39 <danharaj> obviously zero is a natural number
12:56:42 * danharaj :P
12:56:48 <merijn> danharaj++
12:56:57 <dolio> monochrom: Only those wacky number theorists dispute 0 as a natural number.
12:57:02 <Mortchek> I'm in the camp that says 1 isn't a natural number either, so there
12:57:04 <hpc> the naturals start at 2
12:57:08 <jmcarthur> @let magnitude = sqrt ((+) `on` (^2))
12:57:09 <lambdabot>  Defined.
12:57:10 <hpc> the primes start at 2, so it's only natural
12:57:10 <monochrom> no, also real analysis people
12:57:12 * Iceland_jack puts head in sand
12:57:16 <jackfdhughes> rwbarton, wouldn  that go awry due to the operator praecidences anyway? as in, would it not first try to apply 2 to x and then take that result and apply (^) to sin and that?
12:57:18 <Mortchek> If we can't have an additive identity, we don't get a mulitplicative identity either :P
12:57:22 <jmcarthur> :t magnitude
12:57:23 <lambdabot>     Ambiguous occurrence `magnitude'
12:57:23 <lambdabot>     It could refer to either `L.magnitude', defined at <local>:2:0
12:57:23 <lambdabot>                           or `Data.Complex.magnitude', imported from Data.Complex
12:57:30 <jmcarthur> oh...
12:57:32 <dolio> monochrom: Clearly they start at -2, though.
12:57:34 <cmccann> the natural numbers start at infinity and count backwards from there, obviously
12:57:40 <hpc> :t L.mangitude
12:57:42 <lambdabot> Not in scope: `L.mangitude'
12:57:43 <jmcarthur> @undef
12:57:48 <hpc> :(
12:57:48 <Mortchek> cmccann, infinity's not a number! Heretic!
12:58:13 <dolio> Infinity isn't a natural number, at least.
12:58:15 <dolio> So they can't do that.
12:58:17 <rwbarton> jackfdhughes: I'm not talking about haskell
12:58:30 <rwbarton> talking about normal mathematical notation
12:58:47 <jmcarthur> they start at *almost* infinity
12:59:04 <hiptobecubic> infinity - eps
12:59:05 * cmccann defines infinity as "one larger than the largest natural number I care about".
12:59:36 <darkf> Why can't I do this? http://ideone.com/hpP2X shouldn't the type be IO () from `print`?
12:59:42 <hiptobecubic> some cultures don't really count past 5 or so anyway
12:59:44 <dolio> cmccann: Then that isn't the natural numbers, either.
13:00:02 <danharaj> :t (>>=)
13:00:04 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:00:20 <cmccann> dolio, I didn't realize people were providing accurate definitions of the natural numbers here :P
13:00:22 <jmcarthur> darkf: the only thing using IO there is print. you don't need all those (>>=)s
13:00:32 <hiptobecubic> darkf, the type is determined by the Just 10 in that case i think
13:00:35 <jackfdhughes> rwbarton, ohh, you'd be good freinds with Cale.
13:00:43 <hiptobecubic> the Nothing will be of type Maybe Integer
13:00:58 <jmcarthur> oh, are you *trying* to use the Maybe monad?
13:01:27 <darkf> jmcarthur: I'm trying to learn it, actually. I believe (>>= Nothing) will result in Nothing no matter the RHS, so I was trying to see that in action. :P
13:01:51 <jmcarthur> darkf: i think you mean   main = print (Just 10 >>= \_ -> Nothing)
13:01:53 <danharaj> darkf: The problem is that you are using >>= with two different monads.
13:02:04 <lightquake> so i have a bunch of Entities in my game, and i might want an entity to reference other entities (for example, a healer might want to focus on one specific enemy or something)
13:02:05 <jmcarthur> danharaj: the problem is just the extra >>=
13:02:12 <jmcarthur> oops
13:02:14 <jmcarthur> darkf: ^^
13:02:26 <lightquake> what'd be a good approach for this?
13:02:36 <darkf> jmcarthur: That could be it, but wouldn't do { a <- Just 10; b <- Nothing; print b } compile to rougly mine?
13:02:52 <jmcarthur> darkf: yes, which is to say, that won't compile
13:02:54 <danharaj> lightquake: store your Entities in a data structure and refer to them by their indices. (e.g. use an Array or a Map)
13:03:15 <dolio> monochrom: Why don't real analysis people like 0 in the naturals, by the way?
13:03:26 <lightquake> sounds right, just wanted to make sure there wasn't some obvious approach i was missing
13:03:29 <darkf> jmcarthur: Ah, then what's the way to do things like that? Surely you're able to do { a <- someMaybeComputation; print a } ?
13:03:54 <danharaj> lightquake: if you think about it the approach in other languages where you keep a pointer to the object is the same thing except the entire world is the data structure and the index is the pointer.
13:04:05 <Mon_Ouie> You just use print someMaybeComputation
13:04:05 <jmcarthur> darkf: you can do that if someMaybeComputation :: IO (Maybe a)
13:04:20 <jmcarthur> darkf: if it's just Maybe something, you don't use bind for that
13:04:24 <darkf> I see.
13:04:32 <lightquake> danharaj: ah, yeah
13:04:41 <jmcarthur> darkf: this is because bind wants both sides to be the same monad
13:05:19 <darkf> jmcarthur: Ah.
13:05:22 <digital_monster> http://ideone.com/4gwyT I just stuck a virtual in there; is it fine now?
13:05:26 <digital_monster> ah sorry wrong channel
13:07:45 <lightquake> boo, hiss, C++
13:09:23 <rwbarton> :t virtual
13:09:25 <lambdabot> Not in scope: `virtual'
13:21:17 * hackagebot ghc-heap-view 0.3.0.3 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.3.0.3 (JoachimBreitner)
13:25:29 <tswett> Yes, I like how Idris looks.
13:30:14 <crdueck> how do i repeat a monadic action a given amount of times? I'm trying to model a coin toss, i have this function: http://sprunge.us/HKgB which produces all the possible outcomes for 3 coin tosses, but i want to generalize it for n many tosses. Theres probably a very elegant monadic solution.
13:32:36 <lightquake> > replicateM 3 ["heads", "tails"]
13:32:37 <lambdabot>   [["heads","heads","heads"],["heads","heads","tails"],["heads","tails","head...
13:32:59 <lightquake> crdueck: ^
13:33:45 <crdueck> lightquake: thats it, thanks :) if i've seen replicateM before i sure didnt remember it
13:37:19 <crdueck> @hoogle Monad m => Int -> m a -> m [a]
13:37:20 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
13:37:20 <lambdabot> Test.QuickCheck.Gen vectorOf :: Int -> Gen a -> Gen [a]
13:37:20 <lambdabot> Test.QuickCheck vectorOf :: Int -> Gen a -> Gen [a]
13:37:32 <crdueck> @hoogle Monad m => Int -> m a -> [m a]
13:37:32 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
13:37:33 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
13:37:33 <lambdabot> Control.Monad (>>) :: Monad m => m a -> m b -> m b
13:40:17 <GnomeStoleMyBike> did anyone ever hacked lambdabot ?
13:40:47 <sipa> > putStrLn "I'm a stupid bot"
13:40:48 <lambdabot>   <IO ()>
13:40:58 <GnomeStoleMyBike> > print "lol"
13:40:59 <lambdabot>   <IO ()>
13:41:17 <lightquake> i think people have done denial of services by asking it for very large types
13:41:19 <GnomeStoleMyBike> > show "me"
13:41:20 <lambdabot>   "\"me\""
13:41:34 <sipa> > "me"
13:41:36 <lambdabot>   "me"
13:41:37 <tdammers> > "lol"
13:41:38 <lambdabot>   "lol"
13:41:43 <tdammers> not so hard
13:42:10 <GnomeStoleMyBike> lambdabot is cool
13:43:07 <monochrom> if you mean compromising, I think lambdabot is very conservative, and no one has compromised it
13:43:50 <GnomeStoleMyBike> he is sandboxing like a pro
13:45:02 <GnomeStoleMyBike> what if i try ? > map \x -> x, [1..]
13:45:08 <GnomeStoleMyBike> he will timeout
13:45:10 <GnomeStoleMyBike> ?
13:45:37 <Eduard_Munteanu> GnomeStoleMyBike: yes
13:45:40 <Eduard_Munteanu> > [1..]
13:45:41 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:45:57 <GnomeStoleMyBike> i don't want to break it ;p i like it
13:46:09 <Eduard_Munteanu> GnomeStoleMyBike: actually in this case it prints part of the output, but otherwise it will timeout
13:46:16 <Eduard_Munteanu> > fix id
13:46:19 <lambdabot>   mueval-core: Time limit exceeded
13:46:31 <GnomeStoleMyBike> cool
13:46:50 <GnomeStoleMyBike> so he runs stuff in thread and timeout or co-thread
13:47:23 <Eduard_Munteanu> She :)
13:47:29 <GnomeStoleMyBike> it
13:47:30 <GnomeStoleMyBike> sorry
13:47:33 <Eduard_Munteanu> (that's how #haskell people like to address lambdabot)
13:47:34 <GnomeStoleMyBike> my english is very bad
13:47:48 <maukd> Eduard_Munteanu: I think of it as "it"
13:47:52 <GnomeStoleMyBike> so it should be lambdabotiet
13:47:57 <maukd> @nixon
13:47:58 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
13:48:05 <kartoffelbrei> > fix error
13:48:06 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
13:48:13 <Eduard_Munteanu> Reminds us of the late vixen :(
13:48:29 <maukd> kartoffelbrei: are you a broom?
13:48:59 <GnomeStoleMyBike> @Eduard_Munteanu
13:49:00 <lambdabot> Unknown command, try @list
13:49:12 <GnomeStoleMyBike> @kennedy
13:49:12 <lambdabot> Unknown command, try @list
13:49:18 <GnomeStoleMyBike> @bush
13:49:19 <lambdabot> Maybe you meant: bug flush
13:49:23 <GnomeStoleMyBike> @list
13:49:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:49:26 <kartoffelbrei> maukd: yes i am
13:49:33 <kartoffelbrei> atalking one
13:50:04 <GnomeStoleMyBike> @slap Eduard_Munteanu
13:50:05 <lambdabot> go slap Eduard_Munteanu yourself
13:50:10 <GnomeStoleMyBike> :D
13:50:11 <Eduard_Munteanu> Heh.
13:50:24 <Eduard_Munteanu> @botsnack
13:50:24 <lambdabot> :)
13:50:32 <maukd> kartoffelbrei: nice
13:50:34 <Eduard_Munteanu> Good girl.
13:50:46 <GnomeStoleMyBike> @vixen
13:50:47 <lambdabot> The second point is that coming out--coming back and saying that black Americans aren't as good as black Africans--most of them , basically, are just out of the trees.  Now, let's face it, they are.
13:51:10 <GnomeStoleMyBike> hahah ^^ imba
13:51:12 <GnomeStoleMyBike> i love it
13:51:17 <GnomeStoleMyBike> good night guys
13:51:19 <Eduard_Munteanu> vixen just autocorrects to nixon nowadays. :(
13:51:29 <Eduard_Munteanu> GnomeStoleMyBike: g'night
13:56:03 <identity> What can I do to fix the fact that I did not get profiling libraries for base when I installed the haskell platform?
13:56:07 <Puffton> What's the point in only allowing functions with a single argument, and the whole currying thing?
13:56:42 <Tekmo> Puffton: Example: map (+1) [1, 2, 3, 4, 5]
13:56:48 <Tekmo> > map (+1) [1, 2, 3, 4, 5]
13:56:49 <lambdabot>   [2,3,4,5,6]
13:56:57 <maukd> Puffton: makes the language simpler
13:57:04 <maukd> you don't need a special "argument list" construct
13:57:08 <Tekmo> If (+) were not curried, I couldn't write it that cleanly
13:57:12 <luite> but the implementation more difficult :)
13:57:27 <hpc> Puffton: instead of making function calls like foo(x, y, z), we call them somewhat like foo(x)(y)(z)
13:57:37 <Tekmo> I'd have to write: map (\x -> 1 + x) ...
13:57:42 <hpc> which makes it a lot easier to do things with foo(x)
13:57:51 <hpc> and apply y, z later
13:58:19 <merijn> Puffton: Partial application becomes a lot cleaner using 1 argument functions and currying
13:58:20 <Tekmo> Also, you can already do "multi-argument" functions using tuples
13:58:26 <hpaste> Luke pasted “Static Linking Problem” at http://hpaste.org/75925
13:58:28 <Tekmo> f (x, y) = ...
13:58:32 <maukd> Tekmo: no, \ys -> map(\x -> 1 + x, ys) :-)
13:58:37 <merijn> And a significant number of the code I write ends up being partially applied :p
13:58:54 <kartoffelbrei> or/and point-free
13:59:04 <Tekmo> maukd: The "..." was supposed to be the list
13:59:11 <Tekmo> maukd: But still appreciated :)
13:59:58 <rwbarton> "only allowing functions with a single argument" -- makes the language simpler. "the whole currying thing" -- (usually) more convenient
14:00:38 <Tekmo> Puffton: The important point is that currying everything recapitulates what you already had with multi-argument functions, but using a much simpler approach
14:00:57 <Luke1> can someone help me with this static linking problem?: http://hpaste.org/75925
14:02:38 <kartoffelbrei> Tekmo: but functions like "f x y z = x + y + z" are not compiled as "((f x)y)z ", at least not in ghc
14:03:04 <Tekmo> Tekmo: Can you elaborate?
14:03:11 <Tekmo> Oops
14:03:15 <Tekmo> Why am I typing my own name?
14:03:18 <danharaj> Tekmo: <<loop>>
14:03:20 <Tekmo> lol
14:03:25 <maukd> imitation, flattery, etc
14:05:14 <Puffton> So "multiply a b = a*b", since this multiply has two arguments, it is indirectly a higher order function?
14:05:28 <maukd> yes
14:05:32 <danharaj> not indirectly, directly.
14:05:34 <maukd> also, multiply = (*)
14:05:42 <maukd> magic :-)
14:05:55 <hpc> haskellers don't generally consider it higher order because that kind of function is everywhere :P
14:05:58 <hpc> but yes
14:06:38 <Tekmo> Usually we reserve the term higher order for ones that do non-trivial things
14:07:01 <Tekmo> like iterate
14:07:03 <Tekmo> :t iterate
14:07:05 <lambdabot> forall a. (a -> a) -> a -> [a]
14:07:18 <Eduard_Munteanu> Or function types occurring in arguments, rather than the return type.
14:07:27 <Luke1> can someone help me with this static linking problem?: http://hpaste.org/75925 <-- I'm trying to use the haskell curl wrapper and it doesn't seem to want to static link
14:07:45 <Tekmo> Yeah, I've been studying that
14:07:54 <Tekmo> I just used curl recently and never had that problem
14:07:59 <Tekmo> What exactly does the -static flag do?
14:08:06 <Tekmo> I thought ghc compiled things statically by default
14:08:29 <kartoffelbrei> maybe to override the -dynamic flag?
14:08:47 <Luke1> not sure what it does
14:08:48 <rwbarton> -static is for statically linking C libraries
14:08:50 <Luke1> just found it online to use
14:08:59 <rwbarton> ghc statically links Haskell libraries by default
14:09:00 <rwbarton> not C libraries
14:09:05 <Luke1> oh hey rwbarton - you were helping me with this before =)
14:09:09 <Luke1> still broken
14:09:15 <kartoffelbrei> rwbarton: ah i see, thanks
14:09:15 <rwbarton> yes, I see you've made... well progress, maybe?
14:09:25 <Luke1> honestly I can't tell
14:09:28 <Luke1> I've added all that crap to my .cabal
14:09:29 <rwbarton> sometimes the order of libraries is important
14:09:32 <Luke1> nothing seems to work
14:09:37 <Tekmo> Does it compile without the -static flag?
14:09:39 <Luke1> the commented stuff isn't found
14:10:02 <Luke1> without the  -static -optl-static -optl-pthread it compiled
14:10:10 <rwbarton> do you get the same errors as before?
14:10:28 <Luke1> can't tell there are so many
14:10:30 <rwbarton> how about doing one thing at a time
14:10:32 <Luke1> i think it's the same though
14:10:45 <rwbarton> you could use diff or wc -l or something
14:11:13 <Luke1> http://hpaste.org/75845 is the old one
14:11:27 <Luke1> doing diff now btw
14:11:43 <Tekmo> Does GHC require you to provide the *.o files on the command line when you statically link C libraries?
14:11:59 <rwbarton> well obviously it is a lot shorter, that's good
14:12:16 <Luke1> oh its way shorter
14:12:19 <Luke1> nice
14:12:28 <Luke1> 1083 to 438
14:12:32 <Luke1> lc
14:12:43 <rwbarton> do you have the old cabal file?
14:12:56 <Luke1> yeah - same thing without the extra-libraries section
14:13:05 <rwbarton> not even curl?
14:13:10 <Luke1> nope
14:13:28 <rwbarton> i guess maybe the curl Haskell package directory gives you that for free?
14:13:48 <Luke1> not sure
14:13:56 <Luke1> not sure what you mean that is
14:14:21 <jackfdhughes> Puffton, major downside though is that variadic functions are a bit difficult and cumbersome to aemulate meaning that you can't really have a nice formastring like function
14:14:59 <maukd> > ""++ printf "the %s is %d." "moon" 3
14:15:01 <lambdabot>   "the moon is 3."
14:15:05 <Puffton> formastring?
14:15:54 <Tekmo> Well, it's not like they are trivial in other languages either
14:16:09 <maukd> in javascript, all functions are variadic
14:16:10 <Puffton> I also take it that the concept of currying for instance is entirely depending on Haskell being a lazily evaluating language?
14:16:16 <maukd> Puffton: not at all
14:16:26 <osfameron> why the ""++  ?
14:16:34 <maukd> osfameron: polymorphic return type
14:16:40 <Puffton> How else would you pass only one argument at a time to a function requiring several arguments, maukd?
14:16:49 <maukd> Puffton: f x y
14:16:56 <osfameron> maukd: to *printf*?  what else could it be?
14:17:03 <Tekmo> an IO action
14:17:07 <maukd> :t printf
14:17:08 <lambdabot> forall r. (PrintfType r) => String -> r
14:17:10 <maukd> osfameron: r
14:17:17 <Tekmo> It works as both a String and an IO action
14:17:31 <maukd> Tekmo: forget the IO action; it works as both a String and a function
14:17:34 <Puffton> maukd, yes but that calls f first with x, no? that means that initially we don't have enough information since we depend on y too. y is called in the next step unless I misunderstood currying?
14:17:35 <maukd> which is the varargs bit
14:17:37 <osfameron> wouldn't it be more convenient to split printf and sprintf like most oehter languages?
14:17:42 <maukd> Puffton: what?
14:17:55 <maukd> osfameron: wouldn't change much, honestly
14:17:59 <Tekmo> > printf "Test" >> putStrLn ("Test" ++ printf "Test")
14:18:00 <Puffton> A function can only have one argument right? Any function that has more is curried
14:18:02 <lambdabot>   <IO ()>
14:18:28 <otters> GHC isn't very bright
14:18:46 <Tekmo> All functions have exactly one argument
14:18:52 <Tekmo> in Haskell
14:19:01 <Puffton> Yes, so f x y… First f is called with x, right?
14:19:01 <maukd> and OCaml
14:19:07 <maukd> Puffton: yes
14:19:16 <Tekmo> Right
14:19:20 <Puffton> If Haskell wasn't a lazy language, would this still work?
14:19:21 <Tekmo> f x y = (f x) y
14:19:25 <maukd> I'm going to assume OCaml for the rest of this conversation
14:19:28 <maukd> Puffton: yes
14:19:28 <Tekmo> Puffton: yes
14:19:30 <nand`> even in strict languages, ‘f x’ can strictly compute a function to compute the rest
14:19:43 <nand`> by first computing ‘x’, then passing that result into ‘f’
14:19:44 <Tekmo> Puffton: You could implement this exact same trick in C or Java
14:19:51 <Tekmo> Puffton: It would be ugly, but it would work
14:19:56 <maukd> not in C
14:20:08 <nand`> it can be done in any higher-order language
14:20:10 <Tekmo> You can return function pointers
14:20:12 <maukd> in Java ... maybe?
14:20:14 <Tekmo> That's what I mean
14:20:18 <nand`> Java isn't a higher order language I thought
14:20:18 <maukd> Tekmo: but you can't create functions
14:20:24 <nand`> you can in C#, though
14:20:33 <maukd> Tekmo: you can only point to existing global functions
14:20:58 <nand`> maukd: but surely you can lift lambdas to the top level and give them names
14:21:00 <Tekmo> maukd: At the very extreme end, you could implement your own Haskell compiler in C and achieve it
14:21:06 <Puffton> Then if f x y = x*y what would f x evaluate to?
14:21:10 <maukd> nand`: no, you can't
14:21:17 <maukd> Tekmo: doesn't count
14:21:20 <Tekmo> maukd: :)
14:21:25 <danharaj> Puffton: \y -> x*y
14:21:26 <maukd> Puffton: \y -> x*y
14:21:32 <Puffton> You mean f 3 2 is 3*y in the first step?
14:21:33 <danharaj> function application is substitution.
14:21:45 <maukd> Puffton: oh, are you not familiar with closures?
14:22:06 <Puffton> I'm horribly bad with terminology
14:22:19 <Tekmo> Puffton: It's ok
14:22:28 <maukd> a closure is a function that refers to local variables outside of its own scope
14:22:29 <rwbarton> Luke1: well it looks like most of the remaining errors come from krb5 and gss and ldap, so you better track those down
14:22:32 <Tekmo> Puffton: "f x" evaluates to a function of a single argument
14:22:48 <dolio> Lifting lambdas to the top level isn't good enough. You have to pack them into closures manually in C.
14:22:55 <Luke1> rwbarton: what's weird is when I include them in the extra-libraries, it complains they're not found
14:23:02 <danharaj> maukd: I don't see why that terminology is necessary.
14:23:09 <dolio> And probably implement garbage collection somehow.
14:23:14 <rwbarton> well you better find them then!
14:23:19 <equities> is there any problem with fromIntegral
14:23:19 <Puffton> So basically we are just scoping in y into (f x) ?
14:23:23 <BMeph> maukd: If they're outside of its scope, then in what sense are they "local"? Seriously, I ask. :)
14:23:25 <maukd> danharaj: because some languages don't have them
14:23:28 <rwbarton> Luke1: why are you doing this anyways?
14:23:44 <danharaj> maukd: those languages suck
14:23:58 <Luke1> rwbarton: to move the binary to a remote server where I can't install libraries
14:24:03 <danharaj> BMeph: clearly module boundaries :P
14:24:07 <maukd> danharaj: blame john mccarthy
14:24:18 <maukd> BMeph: I don't understand that question
14:24:20 <Tekmo> Luke1: Have you tried it without -static on the other server?
14:24:34 <Luke1> Tekmo: yeah it complains it can't find the .so files
14:24:35 <gfredericks> is there an integer-sqrt function somewhere?
14:24:47 <danharaj> what do you want the integer-sqrt function to do?
14:24:57 <maukd> compute the integer square root of an integer
14:24:58 <rwbarton> not saying this is necessarily easier, but you can install .so files wherever you want and use LD_LIBRARY_PATH to help the linker find them
14:25:07 <gfredericks> but the result is integers too
14:25:17 <rwbarton> unsafeIntegerSquareRoot
14:25:19 <BMeph> maukd: "[--:22] <maukd> a closure is a function that refers to local variables outside of its own scope" - what makes "variables outside of its scope" to be "local"?
14:25:21 <danharaj> maukd: what is integer-sqrt of 2?
14:25:23 <gfredericks> integerSqrt n = (a,b) such that a * a + b == n
14:25:24 <Luke1> rwbarton:  with extra-libraries: krb5  ->  /usr/bin/ld: cannot find -lkrb5
14:25:28 <maukd> danharaj: 1
14:25:31 <gfredericks> and b < a
14:25:41 <rwbarton> Luke1: in that case it must be in a package you don't have installed
14:25:49 <Tekmo> You mean
14:25:51 <maukd> BMeph: uh, 'let' usually
14:25:58 <Luke1> rwbarton: how could I run it dynamically if I didn't have the package installed?
14:26:00 <maukd> or however your language creates local variables
14:26:11 <rwbarton> ... you have the dynamic library
14:26:14 <danharaj> gfredericks: you can cast to a floating value, do the sqrt, then cast back.
14:26:14 <rwbarton> just not the static library
14:26:16 <dolio> Also you probably need arbitrarily many types.
14:26:21 <Luke1> rwbarton: you mean the headers?
14:26:24 <danharaj> (Probably the fastest way to implement the function anyway?)
14:26:30 <rwbarton> the static library is only needed when you are linking something statically, which no one ever does, which is why you don't have it
14:26:32 <danharaj> (Actually no, probably not.)
14:26:33 <rwbarton> no, I mean the static library
14:26:36 <gfredericks> danharaj: I'm not sure that's obvious
14:26:47 <BMeph> maukd: What I mean is, is it not still a closure if the variable "outside of its scope" is NOT local?
14:26:47 <rwbarton> it is likely to be in the same distro package as the header files though
14:26:59 <gfredericks> especially because integerSqrt could conceivable work for arbitrary Integers
14:27:09 <maukd> BMeph: no, because then it's global
14:27:10 <Tekmo> gfredericks: Did you mean something like: integerSqrt n = let a = truncate (sqrt n) in (a, n - a)
14:27:12 <Luke1> rwbarton: oh i'm not familiar with this concept. i thought that was just the -dev packages on ubuntu
14:27:12 <dolio> Closure for (int, int) -> int with the first int bound, Closure for (int, int, int) -> int with the first and second int bound, closure for (int, int) -> float with the first int bound, ...
14:27:30 <gfredericks> Tekmo: that could work for small numbers, if you meant n - a * a
14:27:42 <Luke1> rwbarton: yeah that's what the -dev packages are on ubuntu. meaning if I had the headers I probably have the static libraries as well?
14:27:44 <rwbarton> Luke1: can you just not use curl? it would save a lot of effort
14:27:45 <gfredericks> but problematic when out of floating point rage
14:27:59 <rwbarton> Luke1: well normally but apparently libkrb5-dev does not include a static library
14:28:05 <Luke1> rwbarton: unfortunately it's in a library i didn't write that would take a lot of time to rewrite
14:28:22 <Tekmo> gfredericks: Is this for some prime-based algorithm?
14:28:34 <gfredericks> Tekmo: eh just messing with project euler
14:28:37 <rwbarton> does the server actually not have libcurl.so?
14:28:50 <gfredericks> and prefer staying in the realm of exact math than dipping into the floats
14:28:54 <Luke1> rwbarton: well it's not found
14:29:12 <danharaj> http://www.haskell.org/haskellwiki/Generic_number_type#squareRoot
14:29:15 <danharaj> you can use that, it should be fast enough
14:29:20 <danharaj> for project euler, at least.
14:29:34 <rwbarton> Luke1: maybe you should just use a tool like this: http://stackoverflow.com/questions/271089/how-to-statically-link-an-existing-linux-executable
14:29:38 <Tekmo> gfredericks: Why not use the inexact floating point to get a close guess, then brute force the vicinity for the exact answer?
14:30:10 <Luke1> rwbarton: taking a look - thanks
14:30:20 * BMeph is never " out of floating point rage"... ;)
14:30:25 <gfredericks> Tekmo: just checking if there was a non-messy thing already existing
14:30:28 <rwbarton> also the LD_LIBRARY_PATH suggestion remains
14:30:46 <Tekmo> gfredericks: There are libraries that implement a lot of these prime algorithms already, I think
14:30:57 <gfredericks> okay, thanks
14:31:04 <nooodl_> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 104
14:31:06 <lambdabot>   10
14:31:41 <Luke1> rwbarton: i think installing the static c dependencies locally will be more effort than it's worth. It doesn't scale
14:31:44 <rwbarton> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 110
14:31:45 <lambdabot>   10
14:31:49 <rwbarton> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 120
14:31:50 <lambdabot>   10
14:31:52 <rwbarton> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 121
14:31:53 <lambdabot>   11
14:31:54 <danharaj> gfredericks: if you want to be srs bsns with your performance and you are using GHC, you can use the FFI to import the function from GMP and then have it operate on the representation of an Integer.
14:32:03 <danharaj> But that is probably overkill
14:32:17 <Tekmo> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 999999999
14:32:18 <rwbarton> @check let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in \n -> n < 0 || let s = isqrt n in s * s <= n && n < (s+1) * (s+1)
14:32:18 <lambdabot>   31622
14:32:19 <lambdabot>   "Falsifiable, after 28 tests:\n1\n"
14:32:23 <Tekmo> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 999999999999
14:32:25 <lambdabot>   999999
14:32:29 <Tekmo> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 999999999999999999
14:32:31 <lambdabot>   999999999
14:32:32 <rwbarton> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 1
14:32:33 <lambdabot>   0
14:32:35 <rwbarton> haha
14:32:37 <Tekmo> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 9999999999999999999999999999
14:32:39 <lambdabot>   99999999999999
14:32:40 <nooodl_> yeah, it doesn't work for 1 and 0
14:32:41 <Tekmo> Damn you, lambdabot
14:32:43 <rwbarton> @check let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in \n -> n < 2 || let s = isqrt n in s * s <= n && n < (s+1) * (s+1)
14:32:44 <lambdabot>   "OK, passed 500 tests."
14:32:48 <gfredericks> this is exciting :)
14:32:50 <Tekmo> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 999999999999999999999999999999999999999999999999999999999999999999
14:32:52 <lambdabot>   999999999999999999999999999999999
14:33:03 <rwbarton> @check let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) ((n+1) `div` 2) in \n -> n < 0 || let s = isqrt n in s * s <= n && n < (s+1) * (s+1)
14:33:04 <lambdabot>   "OK, passed 500 tests."
14:33:04 <Tekmo> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 99999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
14:33:06 <lambdabot>   9999999999999999999999999999999999999999999999999999999999999
14:33:07 <Tekmo> I'll break you yet!
14:33:10 <nooodl_> at some point during this whole thing we should've just defined isqrt *once*
14:33:23 <Tekmo> > let isqrt n = head $ dropWhile (\x -> x*x > n) $ iterate (\x -> (x + n `div` x) `div` 2) (n `div` 2) in isqrt 9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999
14:33:25 <lambdabot>   999999999999999999999999999999999999999999999999999999999999999999999999999...
14:33:25 <hpaste> otters pasted “flexible instances” at http://hpaste.org/75926
14:33:26 <rwbarton> I wasn't sure whether @check could see @let stuff
14:33:27 <Tekmo> I give up
14:33:31 <otters> gusy help :D
14:33:44 <otters> *guys
14:33:46 <gfredericks> well thanks everyfolk
14:34:04 <nooodl_> gfredericks: so, remember to define isqrt 0 = 0 and isqrt 1 = 1
14:34:16 <nooodl_> otherwise, that definition works well enough
14:34:24 <rwbarton> Luke1: basically people don't use static libraries nowadays, so yeah, anything involving them is liable to be a pain
14:34:38 <rwbarton> my (n+1) `div` 2 change seemed to fix it
14:34:40 <rwbarton> for 0 and 1
14:34:42 <merijn> rwbarton: wat
14:34:45 <Tekmo> Luke1: Don't give up!
14:34:46 <otters> the only intersection of instances for those two classes is Text
14:34:53 <Tekmo> Luke1: This is how things get fixed
14:35:05 <rwbarton> you don't want to fix this thing
14:35:06 <merijn> Speak for yourself, I use static libraries quite frequently
14:35:16 <merijn> Dynamic libraries are retarded
14:35:27 <rwbarton> well maybe you want to solve Luke1's problem then :P
14:35:28 <rwbarton> have fun
14:35:41 <Luke1> rwbarton: you did have a good point though: the list of errors is more than half shorter
14:35:45 <Luke1> so it's working
14:35:49 <rwbarton> yeah
14:36:01 <rwbarton> though I am puzzled why idn_free is still undefined
14:36:25 <Luke1> rwbarton: also I've confirmed I have all the libkrb5 etc files it's complaining I don't have
14:36:28 <Luke1> so something else is wrong
14:36:38 <rwbarton> libkrb5.a?
14:36:42 <nanobeard_> Tekmo: in your blogpost you talk about an unimplementable proxy transformer, how was that supposed to work?
14:36:57 <Tekmo> Tekmo: It was the codensity proxy transformer
14:36:59 <Tekmo> Gah
14:37:03 <Tekmo> Why do I name myself?
14:37:12 <Luke1> rwbarton: it actually said "/usr/bin/ld: cannot find -lkrb5"
14:37:20 <Tekmo> nanobeard_: So the basic problem is that I needed a constraint of the form:
14:37:29 <rwbarton> right, and? what is the file you confirmed that you have
14:37:32 <Luke1> rwbarton:  when I try to compile with "extra-libraries: krb5"
14:37:39 <Tekmo> nanobeard_: (forall a' a b' b. Monad (p a' a b' b m)
14:37:39 <Luke1> oh - the .so
14:37:42 <Luke1> perhaps that's wrong
14:37:44 <rwbarton> .so is a dynamic library
14:37:46 <Luke1> i get what your'e saying now
14:37:48 <rwbarton> .a is a static library
14:37:49 <Tekmo> nanobeard_: But I can't really write that
14:37:50 <Luke1> gotcha
14:37:52 <Luke1> let me check the .a
14:37:55 <nooodl_> > let isqrt = (concatMap (\x -> replicate (2*x+1) x) [0..] !!) in isqrt 123
14:37:56 <lambdabot>   11
14:38:03 <nooodl_> this is awfully inefficient, but cool
14:38:24 <Tekmo> nanobeard_: It's also the same reason I can't auto-lift request and respond
14:38:31 <Luke1> rwbarton: you're right! I have, for example, libcurl.a but not krb5.a
14:38:35 <Luke1> that's the problem
14:38:38 <gfredericks> nooodl_: haaa
14:38:41 <Tekmo> nanobeard_: I need a way to say that "p a' a b' b m" is a monad for all a' a b' b
14:38:43 <nanobeard_> Tekmo: ah ok
14:38:53 <rwbarton> Monad4 p
14:39:18 <d-snp> hey, anyone know an article/blog on implicit type classes in Haskell? has it been tried, is it feasible? (aka method overloading?)
14:39:25 <rwbarton> I wonder how hard it would be to add constraints like that to GHC
14:39:27 <cmccann> Tekmo, btw I did a quick hackish example of building up a stream with my stuff
14:39:36 <cmccann> so you can see how ugly it ends up being right now
14:39:41 <Tekmo> cmccann: Yeah, show me!
14:39:42 <nanobeard_> I was toying around with your code for a bit and I saw the post on stackoverflow about using the constraints
14:39:53 <Tekmo> nanobeard_: Yeah, that question was related to that issue
14:39:55 <nanobeard_> but I couldn't get it to work using the example posted either :P
14:40:20 <hpaste> “C. McCann” annotated “half-baked stream processing stuff” with “half-baked stream processing stuff (annotation)” at http://hpaste.org/75855#a75927
14:40:21 <nanobeard_> but that's probably because I don't really know what I'm doing
14:40:37 <nanobeard_> but you do seem to have an idea on how to fix it?
14:40:46 <Tekmo> nanobeard_: Well, I think I can probably solve it using the "constraints" solution that the one answerer gave
14:40:52 <BMeph> d-snp: I'm not sure how "implicit type classes" equals "method overloading" - I guess I've been out of the C++ & Java loop for too long (yay! ;)).
14:40:53 <Tekmo> nanobeard_: I just need some time to try it out
14:41:26 <cmccann> Tekmo, testStep builds everything, test runs the stream using IO to either prompt for an Int or produce output
14:41:33 <cmccann> it doesn't do anything useful
14:41:52 <cmccann> but compare how clumsy it is compared to doing the equivalent with pipes
14:42:11 <nanobeard_> Tekmo: ok.. and the codensity transformer was purely for optimization purposes?
14:42:18 <d-snp> BMeph: well in C# you could have a function ToString(String value) overloaded with a ToString(int value) and ToString(bool value)
14:42:24 <Tekmo> cmccann: Don't worry.  I'm sure with time it will improve.  Let me try it out
14:42:41 <d-snp> so you'd have multiple functions with the same name, but different parameter types
14:42:41 <cmccann> Tekmo, lots of boilerplate and bookkeeping and running the stream requires some weird gymnastics and it's hard to see how to have a generic "runStream"
14:42:43 <Tekmo> nanobeard_: Purely for curiosity.  I just wanted to add it for coolness
14:43:24 <merijn> d-snp: Heh, isn't that exactly what you can accomplish using typeclasses?
14:43:42 <d-snp> yes, exactly, but not implicitly
14:43:42 <rwbarton> cf. < d-snp> hey, anyone know an article/blog on implicit type classes in Haskell? has it been tried, is it feasible? (aka method overloading?)
14:43:59 <merijn> d-snp: What do you mean by implicit in this context?
14:44:08 <d-snp> you would have to define a typeclass ToStringable, and put the ToString in there
14:44:17 <Tekmo> cmccann: Where do I get the Overture module?
14:44:24 <elliott> cmccann: ooh ooh something about stream processing??
14:44:28 <Tekmo> Yeah
14:44:29 <cmccann> oh crap, sorry, I forgot to remove that
14:44:30 <elliott> cmccann: my museum beckons
14:44:36 <cmccann> that's my silly prelude replacement
14:44:45 <elliott> infixr 6 ⅋
14:44:46 <elliott> good start
14:44:46 <Tekmo> That's fine, I can install  it
14:44:53 <d-snp> well it could be two things, one would be that the compiler simply assumes a type class instance when you define the function
14:44:58 <nanobeard_> Tekmo: ok, but then I don't see what the use of that coolness would be, what features would it add?
14:45:13 <cmccann> Tekmo, nah, just remove that
14:45:17 <d-snp> the other is that even if a typeclass does not exist, the existance of two functions having the same name implies one
14:45:21 <cmccann> you'll need to import a bunch of modules that it re-exports
14:45:38 <Tekmo> nanobeard_: It was just to exercise the proxy transformer system.  I'm sure I could come up with a use for it if I tried, but it was more to test how powerful it was
14:46:14 <BMeph> nooodl_: How's about this?
14:46:16 <BMeph> > let isqrt n = fst . head . dropWhile ((n>).snd) . zip [0..] . map (^2) $ [1..] in isqrt 123
14:46:18 <lambdabot>   11
14:46:19 <cmccann> elliott, this is a snippet of a recent incarnation of my stream processing stuff, using what's probably the internal representation I'll keep
14:46:55 <elliott> cmccann: this looks great
14:47:00 <Tekmo> cmccann: My GHC is choking on the type operator symbols
14:47:09 <elliott> you need 7.6 I think
14:47:09 <cmccann> but I'm currently distracted by some other stuff and haven't gotten back to it recently
14:47:11 <cmccann> yeah
14:47:13 <Tekmo> Oh yeah
14:47:16 <Tekmo> I have 7.4
14:47:17 <elliott> cmccann: clearly the solution to all the plumbing is to make more typeclasseses!
14:47:19 <elliott> that solves every problem
14:47:35 <Tekmo> Well, let me just continue to study it
14:47:38 <Tekmo> I've almost fully grokked it
14:48:46 <elliott> cmccann: is the LEM definition actually useful for anything?
14:48:57 <cmccann> well, it's the identity function
14:48:59 <cmccann> is that useful?
14:49:04 <elliott> well, yes :)
14:49:12 <Cale> which LEM definition?
14:49:13 <elliott> also, does this have the resource management guarantees you said you could achieve? ISTR that was tied in with the ? ! stuff
14:49:21 <elliott> Cale: lem :: Linear (Var x ⊸ Var x) r ()
14:49:26 <cmccann> elliott, did you see my linear logic stuff I've mentioned a few times?
14:49:29 <cmccann> because that's what this is based on
14:49:47 <jfischoff> I would like to recursively generate ctags for vim, what is the easiest way to do that? GHCi + a script, Hashtags, something else?
14:50:01 <cmccann> elliott, the exponentials are the one thing I still don't have sorted out :[
14:50:08 <elliott> cmccann: I think so -- depends on whether we're referring to the sam ething or not
14:50:22 <d-snp> hey ReinH, when's episode 3 coming? :)
14:50:23 <elliott> cmccann: all I remember is you said it resulted in a nice way of doing resource finalisation
14:50:34 <cmccann> elliott, hpaste.org/75222 is the non-stream version
14:50:49 <nanobeard_> Tekmo: stacking n proxy transforms requires n nestings of liftP to get a function to the right level.. is there anything I can do to ease this pain?
14:51:14 <cmccann> elliott, it's more that it gives a good way of expressing ideas about resource use
14:51:15 <elliott> cmccann: re that Category problem -- if you redefine the Category class locally with PolyKinds on, I think you will be able to give it an instance.
14:51:22 <elliott> without even using a single different byte to the normal category definition
14:51:27 <Tekmo> nanobeard_: The same thing you do with monad transformers
14:51:33 <cmccann> my implementation has been too up in the air trying to make it work right for me to really dig into the practical results :[
14:51:40 <Cale> So that's  lem :: Linear (Not (Var x) ⅋ (Var x)) r ()
14:51:48 <Cale> okay :)
14:51:54 <Luke1> rwbarton: looks like i have libkrb5.a though it's just not finding it...
14:51:56 <cmccann> elliott, yeah, that was mentioned in here earlier
14:52:12 <Tekmo> nanobeard_: There are three solutions I will list
14:52:21 <Luke1> $ dpkg -S libkrb5.a
14:52:23 <Luke1> heimdal-multidev: /usr/lib/x86_64-linux-gnu/heimdal/libkrb5.a
14:52:29 <merijn> mm_freak: I think I mostly get the wire idea enough to follow the API documentation, but I'm not really sure yet how to write a bigger or non-trivial program. Are you aware of any example code using Netwire?
14:52:32 <cmccann> Cale, if you unpack the layers of indirection the linear logic LEM ends up equivalent to the usual \k -> k . Left $ \x -> k . Right $ x
14:52:48 <elliott> Cale: which is lem :: Linear (\r -> (Not (Var x) r -> r, Var x r -> r) -> r) r () :p
14:52:49 <Tekmo> nanobeard_: a) whenever you are writing a proxy with multiple levels, begin by defining the functinos that lift to each level.  i.e. "liftEither = liftP . liftP, liftState = liftP, etc"
14:52:55 <elliott> which is (etc.)
14:53:19 <Tekmo> nanobeard_: b) Combine the proxy transformer stack you want into a single proxy transformer and define special functions that auto lift to the internal proxy transformers
14:53:28 <Tekmo> nanobeard_: c) Define the proxy transformer equivalent of the mtl
14:53:34 <rwbarton> Luke1: I don't think that is the "right" libkrb5.a, though I don't know what will happen if you try to use it
14:53:36 <Tekmo> I personally use (a) in my own code
14:53:42 <Tekmo> same as I do with monad transformers
14:53:44 <Cale> elliott: I just wanted to unpack it enough to see that it's properly an lem :)
14:53:50 <Luke1> rwbarton: ah? is there some other?
14:53:58 <rwbarton> that's from Heimdal kerberos, not the MIT kerberos implementation
14:54:08 <rwbarton> the other one doesn't exist :P
14:54:11 <cmccann> Cale, it's a linear  logic LEM using multiplicative disjunction, yeah
14:54:14 <nanobeard_> Tekmo: ok, I guess I also used a)
14:54:19 <nanobeard_> never used the mtl though
14:54:25 <nanobeard_> but will try to find out
14:54:26 <rwbarton> you could get the libkrb5-dev source package and try to figure out how to build a static library
14:54:27 <Tekmo> nanobeard_: Then don't start!
14:54:39 <nanobeard_> =D
14:54:42 <cmccann> additive disjunction doesn't allow LEM, for the same reason you can't make (Either a (a -> Void)) work for all a
14:54:52 <Tekmo> nanobeard_: For example, using the mtl there is no way to write a more powerful catch function that chnanges the error type
14:55:33 <Tekmo> nanobeard_: The other reason is that it's difficult to reason about mtl code
14:55:46 <cmccann> basically linear negation and ⅋ capture exactly the stuff you can do by cheating via CPS transform (but without using callCC).
14:55:47 <Tekmo> nanobeard_: The semantics of the code change depending on which order you run the monad transformers
14:55:54 <elliott> I don't buy that it's difficult to reason about mtl code
14:56:16 <Tekmo> Simple example, MaybeT and StateT
14:56:19 <rwbarton> this is a common nonsense
14:56:23 <Tekmo> You can write the exact same do block
14:56:33 <Tekmo> but you get a different result depending on which order you apply runMaybeT and runStateT
14:56:37 <rwbarton> "it is difficult to reason about functions because the semantics of the composition of f and g depends on the order in which you compose f and g"
14:56:44 <cmccann> it's difficult to reason about code that has a bunch of "MonadFoo m, MonadBar m" constraints
14:56:52 <cmccann> because that doesn't specify the order of composition
14:57:00 <elliott> cmccann: right, which is why explicitly specifying the types locally is better
14:57:02 <cmccann> an explicit transformer stack is no problem
14:57:05 <elliott> there's nothing wrong with *locally* using the implicit lifting
14:57:06 <Tekmo> rwbarton: I don't see how that relates
14:57:08 <elliott> that is just notational convenience
14:57:15 <elliott> and it is easier to reason about because you do not have lift lift lift lift
14:57:22 <Tekmo> I just define
14:57:29 <Tekmo> liftState = lift . lift ...
14:57:35 <rwbarton> Luke1, http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=439039
14:57:36 <Tekmo> so I always know which level I'm lifting to
14:57:39 <cmccann> also, it's mostly an issue when you mix failure monads with stateful ones
14:57:49 <cmccann> you can toss in MonadReader all you want, I expect
14:58:02 <Tekmo> No, also pipes/proxies
14:58:08 <Tekmo> If you were to "mtl-ify" pipes
14:58:14 <cmccann> and I don't think anyone actually uses ContT :P
14:58:17 <elliott> Tekmo: and if you have two StateTs in a monad stack, and mix up the number of lifts for each one?
14:58:17 <Luke1> rwbarton: 2007 :-/
14:58:20 <Tekmo> the semantics completely change whether the pipe/proxy monad is inside or outside another monad transformer
14:58:29 <rwbarton> it's not going to change tomorrow, yeah
14:58:33 <Tekmo> Tekmo: I label them
14:58:36 <Tekmo> gah!
14:58:39 <Tekmo> elliott: I label them
14:58:40 <cmccann> yeah, pipes are definitely in the "order of composition is critical" group
14:58:49 <Tekmo> elliott: liftStateOuter
14:58:56 <Tekmo> elliott: liftStateInner
14:59:09 <cmccann> cmccann, Tekmo is talking to himself now D:
14:59:59 <Tekmo> There is another reason I don't like the mtl which has nothing to do with reasoning about code
15:00:03 <elliott> anyway you can write a thousand lifts if you want but it seems dubious to tell people not to use mtl because of a reasoning benefit that doesn't really apply if you are using the mtl reasonably
15:00:05 <cmccann> elliott, at any rate the linear logic stuff + the snippet of stream processing stuff is the core of where I'm at with it
15:00:24 <Tekmo> With the mtl, you can't express a lot of interesting operations
15:00:33 <Tekmo> For example, how would you apply the mtl to pipes?
15:01:00 <cmccann> elliott, feel free to tinker with it if you want, and maybe help me figure out how to make the exponentials work cleanly with the linear logic stuff
15:01:15 <elliott> that seems a very vague question
15:01:18 <absence> http://hpaste.org/75928 <- it complains about lack of Num instance, what is the right syntax for that?
15:01:29 <elliott> cmccann: the chances I will be able to help with that are very marginal
15:01:35 <cmccann> elliott, heh
15:01:37 <elliott> cmccann: you must be desperate :p
15:01:38 <Tekmo> elliott: Define a "MonadPipe" type class that turns the Pipe into an mtl-style monad
15:02:04 <elliott> for which of the thousand definitions of Pipe :p
15:02:07 <rwbarton> absence, huh? what are you trying to do?
15:02:11 <elliott> anyway it's not like you want a typeclass for every single monad
15:02:21 <cmccann> elliott, the really annoying thing is that the Stream type works a great deal like the ? modality
15:02:24 <elliott> but there is undeniably a bunch of standard transformers that can be composed usefully like the mtl does
15:02:33 <elliott> and for what it works on it works well
15:02:43 <rwbarton> absence: why are you writing a MonadPlus instance for (Reader SynthState)? that seems very unlikely whatever SynthState is
15:02:48 <cmccann> so if I could get the exponentials working I think I could usefully express stuff of running sub-streams inside a larger stream
15:02:53 <elliott> (though the typeclasses are not perfect, of course -- mostly they need more members, state got one it needed recently)
15:02:57 <rwbarton> absence: do you want a Num instance?
15:03:06 <cmccann> which is where a lot of my expectations for resource tracking comes from
15:03:17 <absence> rwbarton: i want to be able to msum a list of actions in that monad
15:03:17 <Tekmo> elliott: I think that's a reasonable think to say.  I suppose my main issue is that it leaves casual users unequipped to deal with more sophisticated monad transformer stacks
15:03:21 <Tekmo> *thing to say
15:03:24 <rwbarton> ...
15:03:37 <rwbarton> that doesn't make any sense
15:03:42 <rwbarton> @type mzero
15:03:43 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
15:03:43 <cmccann> elliott, helping me figure out a way to make a sane API for stream building would also be nice
15:03:45 <elliott> well (m ()) forms a monoid
15:03:47 <elliott> for a monad m
15:03:58 <rwbarton> absence: figure out what you want to do
15:04:03 <rwbarton> without using the word "msum"
15:04:06 <Tekmo> absence: Do you want "sequence"?
15:04:06 <rwbarton> or "MonadPlus"
15:04:09 <Tekmo> :t sequence
15:04:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:04:19 <Tekmo> or "sequence_"?
15:04:21 <Tekmo> :t sequence_
15:04:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
15:04:28 <rwbarton> like can you give an example of using this supposed "msum"?
15:04:31 <elliott> cmccann: do you not have an equivalent of "(∘) :: (y ⊢ z) -> (x ⊢ y) -> (x ⊢ z)" for these streams?
15:04:43 <elliott> cmccann: you don't seem to have a first-class expression of composition in that paste
15:05:02 <cmccann> elliott, it's not baked in
15:05:14 <cmccann> but the lolipop is still equivalent
15:05:16 <absence> rwbarton: okay... i want to pass a list of actions in that monad to a lib that does mzero and mplus. but that's much the same as msum :/
15:05:49 <rwbarton> still makes no sense
15:05:50 <elliott> cmccann: right, I just mean that you don't seem to have any composition operators defined at all
15:05:51 <absence> Tekmo: well i want the sum of the values the actions return
15:05:51 <cmccann> so you'd need to compose streams like (x ⊸ y) and (y ⊸ z)
15:06:06 <cmccann> elliott, I don't have a lot of things defined there
15:06:06 <absence> rwbarton: hang on i'll find the function
15:06:19 <cmccann> any of that should work fine though
15:06:30 <elliott> probably I should figure out what testStep actually does anyway
15:06:33 <Tekmo> cmccann: Is there any reason you prefer to use Fix than Free?
15:06:46 <elliott> and runTest for that matter
15:07:01 <absence> rwbarton: http://hackage.haskell.org/packages/archive/netwire/3.1.0/doc/html/src/Control-Wire-Prefab-Split.html#branch
15:07:09 <cmccann> Tekmo, because I'm not sure that everything makes sense on finite streams
15:07:16 <absence> rwbarton: i want to use the branch function, and m is Reader SynthState
15:07:24 <cmccann> "zipping" two streams with ⊗, for instance
15:08:03 <rwbarton> @type mplus
15:08:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
15:08:10 <Tekmo> I'm just curious.  I've considered some similar idea myself on a number of occasions
15:09:04 <jfischoff> haskdogs appeared to work well
15:09:05 <absence> rwbarton: i guess what i want is for msum to give me the same result as sum . sequence ... i think :P
15:09:07 <elliott> cmccann: anyway let me see if I can actually get this running first
15:09:11 <rwbarton> absence: okay
15:09:15 <elliott> last time I tried to do Haskell I remembered my Emacs ghci was useless
15:09:19 <rwbarton> that makes sense, but it is wrong. progress :)
15:09:28 <rwbarton> that isn't what msum does
15:09:36 <rwbarton> look at the type for example
15:09:38 <rwbarton> @type msum
15:09:39 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
15:09:45 <rwbarton> nothing possible about adding
15:09:56 <rwbarton> it is supposed to represent a choice among alternatives
15:10:22 <Nereid> > [1,2,3] `mplus` [4,5]
15:10:24 <lambdabot>   [1,2,3,4,5]
15:10:26 <elliott> cmccann: which Control.Monad.Free does it use?
15:10:42 <elliott> Nereid: that's combining a choice among 1, 2, and 3 and a choice among 4 and 5
15:10:49 <Nereid> indeed it is.
15:10:52 <elliott> list ~ (ordered) nondeterministic choice
15:10:55 <absence> rwbarton: it looks very much like mconcat, and still Monoids can sum
15:10:56 <Tekmo> elliott: Probably the "free" package
15:11:04 <rwbarton> I don't know what to say
15:11:22 <rwbarton> -- * Nondeterministic wires
15:11:28 <rwbarton> how can Reader SynthState be nondeterministic
15:11:31 <BMeph> absence: "These aren't the droids you're looking for." ;)
15:11:37 <rwbarton> all you can do is read the SynthState
15:11:54 <rwbarton> Perhaps you want something like ReaderT SynthState []
15:12:06 <rwbarton> I have no idea about this netwire stuff
15:12:26 <absence> rwbarton: hmm, that's possible
15:12:26 <rwbarton> I would guess you don't want branch at all.
15:12:46 <rwbarton> do you just want a wire that sums a bunch of things?
15:13:18 <absence> rwbarton: a wire that sums the result of a bunch of wires
15:13:37 <rwbarton> like a Wire e (>~) [n] n where n is an instance of Num?
15:13:40 <elliott> having cabal-install not spam a billion lines is weird
15:13:44 <elliott> the future ruins everything
15:13:52 <JoshTriplett> dcoutts_: Around?
15:14:01 <absence> rwbarton: not quite
15:14:03 <rwbarton> wouldn't that just be arr sum?
15:14:07 <rwbarton> okay
15:14:33 <absence> rwbarton: a list of wires, and then the sum of the results
15:14:48 <rwbarton> a list of Wire e (Kleisli (Reader SynthState)) blah Int ?
15:15:11 <elliott> cmccann: is first as from Control.Arrow?
15:16:13 <absence> rwbarton: but i'm really just looking for a hole to match my peg here, it may be the wrong one
15:16:46 <rwbarton> you have a list of ____ and you want a ____
15:16:50 <rwbarton> what are the types in the ____s
15:17:38 <mkscrg> QuickCheck question: i'd like to use the Arbitrary instance of my data type to produce a large number of "random" values for a benchmark. is there a way to use the Gen MyType as such?
15:18:00 <Tekmo> absence: So if I understand correctly, you have [m Int], where "m" is the "Wire e ...", and you want to collapse that to "m Int"?
15:18:03 <mkscrg> so far all I've found is sample', which always gives back a list of length 10
15:18:16 <absence> rwbarton: hmmmm.. different (wire and Double), which sort of goes against the type signature of branch, doesn't it
15:18:29 <rwbarton> "wire" is not a type
15:18:50 <absence> rwbarton: true, i'll dig out the actual wire type
15:18:56 <mikeplus64> @check (True == False) == False
15:18:57 <lambdabot>   "OK, passed 500 tests."
15:19:13 <Luke1> rwbarton: I'm just asking the hosting company to install all the dynamic libraries =)
15:19:19 <Luke1> rwbarton: thanks for all your help
15:19:22 <absence> rwbarton: WireM () (Reader SynthState) Double Double
15:19:22 <elliott> I like how it uses 500 tests to check a boolean
15:19:27 <rwbarton> okay
15:19:31 <elliott> cmccann: runTest seems fairly general -- is it specialised to testStream in some way?
15:19:37 <mikeplus64> @check \x -> x == x
15:19:38 <lambdabot>   "OK, passed 500 tests."
15:20:00 <mikeplus64> @check ()
15:20:01 <lambdabot>   "Arguments exhausted after 0 tests."
15:20:05 <elliott> cmccann: also does test ever return True?
15:20:06 <rwbarton> so [WireM () (Reader SynthState) Double Double] -> WireM () (Reader SynthState) Double Double
15:20:12 <mikeplus64> @check False
15:20:13 <lambdabot>   "Falsifiable, after 0 tests:\n"
15:20:18 <rwbarton> or?
15:20:20 <hpaste> orzo pasted “Quickcheck Conditioned List” at http://hpaste.org/75929
15:20:24 <absence> rwbarton: so i guess i want WireM () (Reader SynthState) [WireM () (Reader SynthState) Double Double] Double
15:20:28 <orzo> hi
15:20:39 <rwbarton> or maybe WireM () (Reader SynthState) [Double] Double
15:20:51 <orzo> i'm trying to do something with quick check and its not working.  In the code i pasted, the "arbitrary" call is always generating 0.0
15:21:02 <absence> rwbarton: not [Double], it's a list of wires
15:21:08 <rwbarton> okay right
15:21:18 <rwbarton> I doubt you want a wire with wires as input though...?
15:21:24 <danharaj> absence: how would you combine two wires to get their sum?
15:21:29 <rwbarton> you want to somehow connect a list of wires
15:21:31 <danharaj> (if you can solve that then just use foldr)
15:22:32 <Nereid> @type liftM sum . sequence
15:22:33 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => [m a] -> m a
15:22:36 <orzo> it's 7 lines of code including a type signature... anybody willing to look at it for me?
15:22:48 <elliott> rwbarton: i think wires take wires as input in netwire sometimes??
15:22:59 <elliott> netwire is weird
15:23:00 <absence> rwbarton: i was thinking that in a synthesizer where you have multiple simultaneous voices, each voice is a wire, and they have to be mixed together for the audio output, which is why i'm thinking list of wires
15:23:22 <absence> danharaj: that's what i'm trying to figure out :)
15:23:38 <rwbarton> surely this is easy but I don't know anything about arrows or netwire
15:23:40 <Nereid> absence: does the thing I wrote do it for you?
15:23:47 <Nereid> I don't know anything either.
15:23:50 <rwbarton> is WireM () (Reader SynthState) Double a monad?
15:24:03 <rwbarton> I thought that was the point of arrows, that it's not a monad?
15:24:35 <absence> rwbarton: right, it's an arrow, not a monad. but it wraps a monad
15:24:43 <latro`a> some arrows are monads
15:24:48 <rwbarton> okay
15:24:49 <Nereid> all monads are arrows
15:24:50 <rwbarton> focus people :P
15:24:53 <latro`a> all monads are arrows, indeed
15:25:03 <absence> latro`a: i don't think these are
15:25:16 <rwbarton> if they were then surely netwire wouldn't bother with arrows, right
15:25:17 <elliott> rwbarton: wires are monads
15:25:20 <elliott> since they're ArrowWhatever
15:25:24 <Tekmo> cmccann: Ok, I think I sort of get it now
15:25:27 <elliott> that happens to be equivalent to a monad
15:25:32 <rwbarton> hmm okay
15:25:34 <orzo> hi
15:25:35 <latro`a> ArrowApply?
15:25:38 <elliott> yes
15:25:40 <elliott> rwbarton: but if you use the less powerful arrow interfaces it can optimise more, or whatever
15:25:44 <elliott> since the control flow is more explicit
15:25:47 <Tekmo> cmccann: It's like a free monad over a given functor, but you structure it so that the output result can be of any type, like Cont
15:25:47 <rwbarton> I see
15:25:57 <Tekmo> cmccann: Technically, Fix over a given functor
15:25:59 <rwbarton> well I am pretty sure you can do this particular task without monads
15:26:02 <rwbarton> @type (&&&)
15:26:03 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:26:16 <rwbarton> @type arr (uncurry (+)) .: (&&&)
15:26:17 <lambdabot>     No instance for (Arrow (,))
15:26:18 <lambdabot>       arising from a use of `&&&' at <interactive>:1:21-25
15:26:18 <lambdabot>     Possible fix: add an instance declaration for (Arrow (,))
15:26:22 <danharaj> you probably want something like \a1 a2 -> a1 &&& a2 >>> (fmap (uncurry (+)))
15:26:24 <orzo> :/
15:26:27 <Tekmo> cmccann: This lets you decide on the effects at the very last minute
15:26:32 <Nereid> @type fmap (uncurry (+)) .: (&&&)
15:26:34 <lambdabot> forall a (a1 :: * -> * -> *) b. (Num a, Functor (a1 b), Arrow a1) => a1 b a -> a1 b a -> a1 b a
15:26:37 <Nereid> eh.
15:26:40 <rwbarton> yeah
15:26:45 <rwbarton> oh right
15:26:52 <rwbarton> @type (arr (uncurry (+)) .) .: (&&&)
15:26:53 <lambdabot> forall a (a1 :: * -> * -> *) b. (Num a, Functor (a1 b), Arrow a1) => a1 b a -> a1 b a -> a1 b a
15:26:56 <Nereid> heh
15:27:00 <danharaj> ugh what is this caleskell heresy
15:27:01 <rwbarton> how awful
15:27:02 <danharaj> :t (.:)
15:27:04 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
15:27:12 <rwbarton> I actually wanted Control.Category.. but I guess it worked anyways?
15:27:15 <monochrom> hereskell
15:27:35 <Nereid> @type (&&&) >>^ uncurry (+)
15:27:36 <lambdabot>     Couldn't match expected type `a b c' -> a b (c, c')'
15:27:36 <lambdabot>            against inferred type `(a1, a1)'
15:27:36 <lambdabot>     In the second argument of `(>>^)', namely `uncurry (+)'
15:27:38 <Nereid> oops.
15:28:00 <rwbarton> anyways there must be a function [a b c] -> a b [c] you can build out of (&&&)
15:28:00 <absence> Nereid: i don't think it will... at least i have no idea how to mix that with the arrow syntax :)
15:28:07 <Nereid> @type \x y -> (x &&& y) >>^ uncurry (+)
15:28:08 <lambdabot> forall (a :: * -> * -> *) b c'. (Arrow a, Num c') => a b c' -> a b c' -> a b c'
15:28:14 <Nereid> now fold that shit
15:28:16 <elliott> problem with caleskell (.) is that it's the wrong generalisation
15:28:18 <orzo> Why does this never terminate? (trace output is a=0.0 repeated) http://hpaste.org/75929
15:28:28 <Tekmo> cmccann: I'm also reasonably certain you don't need to delay the universal quantification until the last minute when you wrap it with Stream
15:28:51 <danharaj> :t foldl (\f g -> (f &&& g) >>^ uncurry (+)) (const 0)
15:28:53 <Tekmo> cmccann: I think you could probably accomplish the same thing by replacing Linear with FreeF
15:28:53 <lambdabot> forall b c'. (Num c') => [b -> c'] -> b -> c'
15:29:06 <danharaj> close enough.
15:29:20 <Nereid> :t foldl (\f g -> (f &&& g) >>^ uncurry (+)) (arr (const 0))
15:29:21 <lambdabot> forall (a :: * -> * -> *) c' b. (Arrow a, Num c') => [a b c'] -> a b c'
15:29:22 <rwbarton> orzo: well that's a function. what did you pass it
15:29:38 <orzo> rwbarton: gernate 10 (/=0)
15:29:53 <orzo> spelled correctly
15:30:09 <orzo> n=10, pred=(/=0)
15:30:13 <Nereid> hey uh
15:30:29 <rwbarton> what happens with generate 10 (/= 1)
15:30:39 <Nereid> shouldn't we have an instance Arrow a => Applicative a b?
15:31:00 <rwbarton> yeah there is. http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Applicative.html#t:WrappedArrow
15:31:00 <Tekmo> cmccann: It also explains why you end up needing Fix
15:31:08 <Nereid> aha.
15:31:15 <Tekmo> cmccann: You've been essentially trying to write Fix (FreeF f r)
15:31:16 <orzo> rwbarton: it succedes, but i assume i'm always getting 10 zeros
15:31:23 * hackagebot csv-conduit 0.3.0.2 - A flexible, fast, conduit-based CSV parser library for Haskell.  http://hackage.haskell.org/package/csv-conduit-0.3.0.2 (OzgunAtaman)
15:31:35 <Tekmo> cmccann: But you would get the monad instance back with an equivalent representation by just using Free f r directly
15:31:52 <orzo> rwbarton: i think arbitrary is -always- giving 0.0, and i don't understand why
15:31:57 <cmccann> Tekmo, elliott: sorry, I had to run AFK suddenly
15:32:14 <Tekmo> cmccann: I can sort of summarize what I just said
15:32:20 <kartoffelbrei_> @pl \x y -> f x (f y)
15:32:20 <lambdabot> (. f) . f
15:32:27 <Tekmo> cmccann: I think you can recapitulate most of what you wrote using a free monad
15:32:33 <elliott> cmccann is being chased by oleg for his crimes against iteratees
15:32:33 <cmccann> Tekmo, do note that (Fix f) is pretty much equivalent to (Free f Void)
15:32:33 <lambdabot> elliott: You have 1 new message. '/msg lambdabot @messages' to read it.
15:32:41 <elliott> not this again
15:32:47 <Tekmo> cmccann: I mean something different
15:32:52 <cmccann> I convert it to Fix mostly so that I can feel more comfortable ignoring the Pure case
15:33:02 <Tekmo> cmccann: I'm saying that you have Fix (FreeF f r), which is isomorphic to Free f r
15:33:11 <Nereid> @pl \f x y -> f x (f y)
15:33:11 <lambdabot> flip =<< ((.) .)
15:33:16 <Tekmo> cmccann: Your "Linear" is behaving like FreeF f r
15:33:22 <Tekmo> Sorry, technically
15:33:28 <Tekmo> FreeF f r a
15:33:36 <Tekmo> Or maybe I have a and r backwards
15:33:49 <Tekmo> And your Stream is basically Fix (FreeF f r)
15:34:04 <Tekmo> So you could condense both of them into just Free f r and regain the monad instance for the final resulting type
15:34:14 <Tekmo> with no loss in power
15:34:48 <Tekmo> You keep all your other functors the same
15:34:53 <Tekmo> i.e. Join, In, Out, etc.
15:34:54 <cmccann> oh, I see what you're saying
15:34:55 <cmccann> hm
15:35:01 <Tekmo> But now it is
15:35:08 <cmccann> er, but keep in mind that not all of those are functors
15:35:21 <cmccann> Join certainly isn't
15:35:24 <Tekmo> Stream f = Free f Void
15:35:41 <Tekmo> Well, they can be made functors
15:35:48 <Tekmo> The only reason they aren't is because you are using CPS style
15:35:52 <Tekmo> So you delay the functor instance to the interpreter
15:35:53 <cmccann> the final parameter of the logical connectives is the CPS result type
15:35:55 <Tekmo> your testStep function
15:36:00 <elliott> the CPS style is the whole linear logic thing, isn't it
15:36:16 <cmccann> elliott, the CPS-ish business is how it works, yes
15:36:26 <Tekmo> It's the same reason Codensity doesn't require the base monad is a monad
15:36:27 <cmccann> linear implication is basically Kleisli Cont here
15:36:31 <Tekmo> It delays the bind to the interpreter
15:36:47 <Tekmo> But if you did it in non-CPS style using just the Free monad, you need to make them functors
15:36:54 <Tekmo> and they can be
15:37:01 <Tekmo> All of them are perfectly acceptable functors
15:37:18 <elliott> I'm not sure how you'd do it in non-cps style... maybe an hpaste of the basic definitions would help?
15:37:20 <cmccann> I'm really not seeing how you're going to make With and Join into functors
15:37:28 <cmccann> elliott, which definitions?
15:37:44 <elliott> well, Tekmo's revised Stream/Join/In/Out
15:37:47 <elliott> /etc.
15:37:49 <cmccann> oh
15:37:56 <cmccann> yeah, I'm not sure exactly what he has in mind either
15:38:18 <cmccann> Tekmo, think you could do a rough example in code?
15:38:31 <Tekmo> Yeah, let me try
15:38:33 <orzo> rwbarton: you see what I'm trying to do right?  What if i want 10 non-zero values, is there a quickcheck idiom for this?
15:38:42 <Tekmo> I don't think I can do With, though
15:38:51 <Tekmo> Let me think about thatone
15:38:57 <cmccann> Tekmo, because I think I have the rough idea of what you're after and I tried (and failed) to make something like that work earlier
15:39:22 <cmccann> With and Join are dual to Or and And in the same way
15:39:55 <cmccann> the negative polarity stuff has been no end of headaches the whole time though
15:40:38 <absence> mm_freak: i'm trying to make a simple synthesizer using netwire, and thinking a wire defines each voice, but which parts of netwire should i look at for adding/removing voices on note on/off and mixing (adding) the resulting audio together into one output? WSplit / branch with ListT, or is that for something entirely different?
15:41:07 <Tekmo> cmccann: By negative polarity, do you mean "r" in the negative position?
15:41:37 <cmccann> no, that's polarity in the linear logic sense
15:42:06 <cmccann> which here means With and Join and their identities
15:43:05 <elliott> as much as this type operator change makes cmccann's stuff prettier I hate the inconsistency
15:43:11 <cmccann> heh
15:43:16 <rwbarton> orzo: how are you running this code in more detail?
15:43:21 <rwbarton> maybe it is defaulting to a stupid type somehow
15:43:26 <cmccann> it is so much prettier though.
15:43:29 <rwbarton> or maybe you hit an rng bug
15:43:37 <rwbarton> it wouldn't be the first time that has happened with quickcheck
15:43:43 <Cale> lol, this node.js script problem:    for d in bin lib share include; do rm -rf $N_PREFIX/$d
15:43:51 <Cale> "What could possibly go wrong?"
15:44:06 <elliott> cmccann: if only you could give constructors such nice names too
15:44:16 <elliott> it's almost as if the uppercase/lowercase distinction kind of sucks!
15:44:17 <cmccann> elliott, also to answer a question from backscroll, runTest is specialized to the step shape that testStream uses
15:44:38 <elliott> cmccann: about making constructing these easier
15:44:44 <cmccann> generalizing anything away from specific steps is a pain
15:45:01 <elliott> cmccann: I think you could write a typeclass that lets you write blah x for (rstep . lstep . etc . build $ x)
15:45:03 <cmccann> previous incarnations had towering edifices of baroque type classes just to make things kinda tolerable
15:45:03 <elliott> but it'd be fairly ugly
15:45:07 <cmccann> yes
15:45:08 <cmccann> it is
15:45:15 <elliott> and then maybe you can make yield/await use that typeclass
15:45:19 <elliott> so you don't need any of the wrapping at all
15:45:28 <cmccann> especially when you account for mixing additive and multiplicative operators
15:45:28 <orzo> rwbarton: I have code "ds <- generate 0 10 (/=0)" which is invoked from a function that is invoked from a prop_ function which is invoked from runTests
15:45:31 <elliott> it might end up too overloaded to actually resolve properly but maybe it would work
15:45:48 <elliott> and that would then make testStep not kind of horrible
15:46:32 <cmccann> elliott, not everything is as simple as additive disjunction though
15:47:06 <elliott> yeah
15:47:20 <cmccann> for example, two inputs combined with And feed to two separate stream "futures", with the zipping happening independently
15:47:38 <cmccann> whereas an input and output combined with Join obviously gives you a linear function
15:48:08 <elliott> yeah
15:48:24 <elliott> still, that kind of plumbing obviously has to be made implicit somehow for this to work nicely
15:48:26 <elliott> at least for the most part
15:48:34 <cmccann> and combining streams using With advances their "futures" separately depending on which side is used
15:48:38 <cmccann> yeah
15:48:51 <cmccann> it's just a gigantic headache
15:49:13 <cmccann> it was terrible in a previous version before I made everything way more awkward in order to get the logic working correctly
15:49:23 <rwbarton> orzo, did generate grow an extra argument?
15:49:53 <rwbarton> can you pin down the type somehow
15:50:04 <elliott> cmccann: maybe you need a stream-building abstraction that isn't a monad or something
15:50:22 <rwbarton> I guess if it's really printing "a=0.0" the type must be Double?
15:50:40 <cmccann> elliott, well, once the streams are sealed I'm pretty sure combining them can be made nicer
15:50:45 <orzo> rwbarton: yes, i added a tries counter, sorry
15:51:14 <cmccann> lifting all the operations in the linear logic stuff to streams, with a bit of hackery to tidy that up it'd be fine
15:51:40 <cmccann> and building simple streams Free-style is fine
15:51:54 <elliott> cmccann: right, it is just the definition of Step values that seems not ideal
15:52:24 <cmccann> but stitching together compound steps to stack onto the free monad is... ugh.
15:52:27 <elliott> cmccann: maybe (forall r. Linear f r a) and Step f a could be unified so you don't need the build?
15:52:32 <elliott> not that the build is nearly the worst part of it
15:53:08 <cmccann> well, Step is the free monad part
15:53:15 <cmccann> so that's not the same thing
15:53:27 <cmccann> (it's also badly named right now)
15:53:59 <hpaste> orzo pasted “ConditionedList, full code” at http://hpaste.org/75931
15:54:13 <elliott> cmccann: right, I guess redefining Linear as a free monad would be sort of bad
15:54:18 <cmccann> basically Linear is a single linear step, Step is a sequence of steps being built, and Stream is an infinite series of linear steps
15:54:25 <orzo> I've extracted the bits of my code that are relevent and made a complete program that exhibits the behavior, http://hpaste.org/75931
15:54:59 <orzo> I complie using, "ghc simple.hs"
15:55:44 <orzo> my conditionedList function is getting a little weird... just trying random stuff
15:56:03 <elliott> cmccann: right
15:56:14 <elliott> cmccann: I was thinking you could merge the first two
15:56:25 <elliott> cmccann: and just represent values that are currently Linears as singleton Steps, so to speak
15:56:38 <Tekmo> cmccann: Here's a weird question.  What are Out and In the identities of?
15:57:20 <elliott> cmccann: btw is there a reason that newtype definition of Not doesn't work out and you use a type family instead?
15:57:24 <orzo> rwbarton: the type was Float, and you see the complete code paste, right?  That's two files.
15:58:28 <cmccann> elliott: I need to work with single steps in order to define the logical operations independently, so that I can lift them to work on streams
15:58:58 <cmccann> Tekmo, nothing, they represent logical atoms
15:59:09 <elliott> cmccann: right
15:59:13 <Tekmo> cmccann: Are you sure?
15:59:31 <Nereid> hmm, this is a nice article. http://okmij.org/ftp/tagless-final/course/Boehm-Berarducci.html
15:59:36 <elliott> cmccann: is the problem with the newtype Not that Not (In x) isn't the same as Out x because the r isn't quantified?
15:59:39 <Tekmo> cmccann: It seems like they are each missing a respective composition operator of their own
15:59:59 <cmccann> elliott: also I used a type family because otherwise it's easy to end up with a huge stack of negations that I then have to manually eliminate
16:00:34 <cmccann> elliott, if you look at the non-stream linear logic stuff I do it the other way
16:00:38 <cmccann> there's really no difference in the end
16:01:16 <cmccann> Tekmo, like what? Out is just there to lift a regular type, and In is its negation
16:01:23 <elliott> cmccann: seems like if you come up with something to eliminate the other structural cruft you could use the newtype definition too
16:01:25 * hackagebot xbattbar 0.2 - Simple battery indicator  http://hackage.haskell.org/package/xbattbar-0.2 (AlexanderPolakov)
16:01:50 <cmccann> elliott, possibly, there's multiple ways I could shift cruft around
16:01:55 <Tekmo> cmccann: Before I explain, did you read my pipes-2.4 write up?
16:02:04 <cmccann> not yet, been really busy
16:02:13 <Tekmo> cmccann: Then let me summarize the relevant point
16:02:21 <Tekmo> cmccann: I found two extra categories for the Proxy type
16:02:35 <Tekmo> It turned out that request and respond where the identies of these two categories
16:02:44 <cmccann> in an ideal world I wouldn't need Out at all, and In would be the same thing as Not
16:02:50 <Tekmo> cmccann: The way I found them was when I noticed my functor was lifting their identities
16:03:01 <cmccann> they're pure cruft to make the types work
16:03:02 <Tekmo> cmccann: So I assumed there must have been an associated composition operator that it also lifted
16:03:51 <Tekmo> cmccann: The fact that Not is converting them back and forth suggests to me that each of them is the identity in some category and you would have a useful composition operator on your hands for each one
16:04:52 <cmccann> Tekmo, like I said, if you strip out the cruft Out really should be superfluous
16:05:17 <cmccann> (Out x) would be an object in the category linear logic corresponds to
16:05:23 <cmccann> because I can't just use "x" directly
16:06:18 <cmccann> and (In x) stands for the dual of (Out x)
16:07:10 <cmccann> where Not is the dualize operation
16:08:46 <cmccann> Tekmo, actually, did I ever point you to anything describing what the category structure for linear logic is?
16:08:56 <Tekmo> No
16:09:06 <hpaste> orzo annotated “ConditionedList, full code” with “ConditionedList, full code (annotation)” at http://hpaste.org/75931#a75932
16:09:16 <cmccann> can you deal with reading nLab articles? :P
16:10:08 <cmccann> because http://ncatlab.org/nlab/show/linear+logic is a decent overview of linear logic, and http://ncatlab.org/nlab/show/star-autonomous+category captures most of the essential structure
16:10:12 <orzo> rwbarton: It seems like on the first go, testing a prop_ function, arbitrary is not arbitray until that at least one run of the prop_ has completed...
16:10:43 <cmccann> Tekmo, but http://ncatlab.org/nlab/show/polycategory has a more direct relation to my encoding
16:12:40 <Tekmo> cmccann: Is Linear in the non-stream encoding just (f r -> r) -> r?
16:13:26 <gwern> hm. how to generate all 25 combinations of 1-5... as in, [(1,1), (1,2)..(5,5)]
16:14:05 <gwern> zip [1..5] [1..5] is close but not enough. maybe map zip?
16:14:23 <rwbarton> > (,) <$> [1..5] <*> [1..5]
16:14:24 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
16:14:29 <cmccann> Tekmo, if you strip out the cruft and flip the order around (Linear f g) = (f r -> (g r -> r) -> r)
16:14:30 <rwbarton> > range ((1,1),(5,5))
16:14:31 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
16:14:39 <Cale> > liftM2 (,) [1..5] [1..5]
16:14:40 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
16:14:45 <dagle> Does there exist a version of !! that have the type: Enum b => [a] -> b -> a ? I get this feeling that I shouldn't need to define it. :P
16:14:48 <gwern> map (\x -> zip [1..5] (repeat x)) [1..5]
16:14:54 <Cale> > [(x,y) | x <- [1..5], y <- [1..5]]
16:14:55 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
16:14:58 <cmccann> Tekmo, like I said, linear implication is basically Kleisli Cont with some restrictions on use
16:15:10 <Cale> > replicateM 2 [1..5]
16:15:12 <lambdabot>   [[1,1],[1,2],[1,3],[1,4],[1,5],[2,1],[2,2],[2,3],[2,4],[2,5],[3,1],[3,2],[3...
16:15:23 <gwern> replicateM? of course! :)
16:15:29 <gwern> how stupid of me not to see it
16:21:05 <RobMacKenzie> Hi, I was looking at various haskell functions, and was confused a bit by repeat.
16:21:08 <RobMacKenzie> @src repeat
16:21:08 <lambdabot> repeat x = xs where xs = x : xs
16:21:26 <RobMacKenzie> why not just repeat x = x:(repeat x)
16:22:19 <cmccann> because that would keep creating new (:) constructors.
16:22:41 <cmccann> the definition that's used creates a single value and then uses it as its own tail (thanks to laziness)
16:22:46 <cmccann> so you have a circular list
16:23:58 <dagle> I like that some functions in the std lib have comments like -- we like to write the function this easy: [code], but that would be bad because of space.
16:24:01 <RobMacKenzie> Cool, gonna think about that for a bit
16:24:32 <RobMacKenzie> thanks
16:24:34 <Cale> RobMacKenzie: Yeah, it's a pretty subtle point about how things are actually implemented
16:25:01 <cmccann> yes, it's an excellent question to ask, and ponder over
16:25:26 <Cale> RobMacKenzie: The value of a variable is evaluated at most once. But the values of function applications are not memoised
16:25:41 <RobMacKenzie> Ohhhhhh, that got it for me
16:25:43 <Cale> (if they were, you'd never be able to garbage collect anything)
16:26:11 <RobMacKenzie> just had an aha moment
16:27:05 <Nereid> Cale: so in repeat x = x : repeat x, repeat would have to get called every time we deconstruct the list, right
16:27:18 <Nereid> er
16:27:25 <Cale> Nereid: yeah, each time we evaluate another tail
16:27:28 <Nereid> yeah.
16:27:35 <Cale> and a new distinct cons cell is constructed in memory
16:27:43 <Cale> So you potentially end up using O(n) space
16:27:53 <Nereid> time to see if I can actually observe this.
16:28:01 <Cale> while the other version uses O(1) space (a single cons cell which points at itself)
16:28:38 <Cale> You can observe it with Debug.Trace
16:28:48 <Nereid> heh.
16:28:49 <Cale> (at least, the time behaviour)
16:28:57 <Nereid> yeah.
16:28:57 <Nereid> but the memory behaviour.
16:29:26 <Cale> Vacuum should be able to pick that up
16:29:40 <Cale> http://hackage.haskell.org/package/vacuum
16:29:42 <YayMe> Would y'all avoid mentioning Haskell in an enterprisey .NET interview?
16:30:33 <elliott> RobMacKenzie: Nereid: (Note that this is an implementation detail and not specified by the standard or anything)
16:30:40 <Nereid> sure.
16:30:48 <Cale> YayMe: I wouldn't. If they minded, they'd be doing me a favour not to hire me.
16:31:20 <YayMe> Cale: Yeah.. one part of me thinks that, the other part of me wants another job heh
16:31:57 <RobMacKenzie> YayMe: heh
16:31:59 <YayMe> I just wonder what experiences people have had with other peoples reactions to mentioning Haskell
16:32:01 <Cale> YayMe: Not to mention that anyone who really cares about .net should know who Erik Meijer is, and his name is on the Haskell Report.
16:32:29 <jfischoff> YayMe: most engineers have not heard of it
16:32:35 <Cale> Knowing Haskell means you automatically understand LINQ
16:32:49 <YayMe> Cale: I know that, but many people don't care as you put it about .net even though they get to make hiring decisions
16:32:53 <cmccann> Cale, heh, mentioning vacuum reminds me of writing http://www.reddit.com/r/haskell/comments/c4hnr/zhuangzi_butterfly_and_referential_transparency/c0q2wfw
16:32:59 <dagle> Cale: Until you have to debug it.
16:33:10 <YayMe> dagle: Why do you say that?
16:34:42 <Cale> cmccann: cute!
16:35:00 <cmccann> that was the idea :]
16:39:26 <mm_freak> @tell merijn regarding netwire example code, right now there isn't any…  be brave, there will be examples soon =)
16:39:26 <lambdabot> Consider it noted.
16:40:11 <YayMe> my experience with other .NET developers has been that they've no interest in the idea of functional programming or even the development of .NET, the best .NET developers I've met were only interested in programming to the extent that they thought frameworks that do cool stuff were neat i.e. "oo ninject is cool! I use it with NHibernate, MVC and WCF, and of course I use the Telerik MVC controls! They're cool!" I'm hoping folks here
16:40:11 <YayMe> could say that's not.. over 80% of .NET devs in their experience?
16:40:27 <mm_freak> absence: first of all i recommend going for netwire 4 now…  even though it's not released its API is stable and can be used in new projects:  darcs get http://darcs.ertes.de/netwire/
16:41:15 <Nereid> Cale: heh, vacuum blows up on the non-shared version of repeat ()
16:41:17 <YayMe> cmccann: heh that is cool. I have no idea what it's referencing but even I understand it so that's saying something
16:42:16 <cmccann> YayMe, the wikipedia link should explain the reference
16:43:04 <lightquake> cmccann: i wish i could upvote that :(
16:44:07 <cmccann> but yeah, it's a cute illustration of the "why is repeat defined that way" question, using vacuum to show the difference
16:44:35 <mm_freak> absence: to write signal generators and transformers for audio processing you would sample at a constant rate (either call stepWire directly or use counterSession)…  then you can use prefab wires and inhibition to produce noise…  to synthesize you could either write your own wire or do something with 'repeatedly' or 'periodically'
16:46:04 <mm_freak> a simple sine wave could look like this:  3 * (sin . time)
16:46:19 <mm_freak> or rather:  3 * pi * (sin . time)
16:47:02 <ben_m> > randomIO :: IO Int
16:47:03 <lambdabot>   <IO Int>
16:47:09 <ben_m> How do I 'fix' that? :D
16:47:21 <ben_m> lambdabot specific
16:47:41 <danharaj> > unsafePerformIO (randomIO :: IO Int)
16:47:42 <lambdabot>   Not in scope: `unsafePerformIO'
16:47:46 <BMeph> cmccann: Reminds me of a lot of the Boundary Institute stuff. ;)
16:48:03 <cmccann> no idea what that is
16:48:05 <mm_freak> ben_m: you can't
16:48:09 <danharaj> > totallySafeTrustMeOnThisPerformIO (randomIO :: IO Int)
16:48:11 <lambdabot>   Not in scope: `totallySafeTrustMeOnThisPerformIO'
16:48:15 <mm_freak> > random (mkStdGen 0) :: Integer
16:48:16 <lambdabot>   Couldn't match expected type `GHC.Integer.Type.Integer'
16:48:16 <lambdabot>         against inf...
16:48:29 <mm_freak> > random (mkStdGen 0) :: (Integer, StdGen)
16:48:30 <lambdabot>   (-117157315039303149,1346387765 2103410263)
16:48:49 <ben_m> ah :)
16:48:55 <ben_m> Thanks
16:49:09 <mm_freak> > randoms (mkStdGen 0) :: [Integer]
16:49:10 <lambdabot>   [-117157315039303149,-8854136653200549331,-2598893763451025729,-21049421333...
16:51:09 <Nereid> @src iterate
16:51:09 <lambdabot> iterate f x =  x : iterate f (f x)
16:52:43 <Nereid> I guess there's not much we can do about this one.
16:53:53 <BMeph> cmcann: Have you heard of the "Laws of Form"?
16:54:11 <hpaste> orzo pasted “Quickcheck Conditioned List, solution” at http://hpaste.org/75933
16:54:57 <BMeph> "iterate f x = xs where xs = x : map f xs"? ;)
16:55:24 <BMeph> Never mind, it still has application. :/
16:55:32 <cmccann> BMeph, don't think so
16:55:32 <Nereid> oops.
16:55:40 <Nereid> BMeph: that's the first thing I tried
16:56:29 * hackagebot fountain 0.0.6 - A fountain codec.  http://hackage.haskell.org/package/fountain-0.0.6 (RubenAstudillo)
16:58:04 <Nereid> I've mostly convinced myself that we can't rewrite iterate to be any better
16:58:21 <Nereid> or even special cases of iterate
17:01:02 <monochrom> iterate f x = g x where g y = y : g (f y)
17:01:13 <monochrom> this may be better or worse
17:01:19 <BMeph> cmccann: It (LoF) is...intersting. If you're into such things, feel free to look it up.
17:01:56 <Nereid> monochrom: not better
17:01:59 <Nereid> at least not asymptotically
17:02:17 <cmccann> BMeph, oh, I think I've seen this before
17:02:23 <cmccann> but don't really have time to look at it right now
17:02:56 * BMeph nods
17:03:01 <monochrom> yeah, I am not sure that it is better either, just submitting it for consideration :)
17:03:18 <elliott> BMeph: i hear it doesn't make any sense or something
17:05:34 <zzing> I need some advise, a practical problem I cannot see my way out of… details are at the end of this paste: http://hpaste.org/75934   Essentially, I want to parse a file but the file starts off with headings and then once they are done, content beings. This is all pure code, which is likely why my imperative brain is having trouble.
17:07:50 <Nereid> wow, learn something new every day just by looking at what goes on hackage.
17:07:53 <Nereid> I'd never heard of fountain codes before.
17:08:51 <wavewave> hi
17:09:09 <niteria> Nereid: there was a nice blog post about them here http://blog.notdot.net/2012/01/Damn-Cool-Algorithms-Fountain-Codes
17:09:10 * BMeph wave-waves. ;)
17:09:21 * wavewave waves BMeph
17:09:50 <wavewave> anyone knows how to handle C99 bool type with c2hs?
17:13:34 <Nereid> niteria: neat
17:16:30 <Cale> zzing: what trouble are you having?
17:16:33 <Nereid> niteria: gonna read the other posts on there later  O:
17:18:37 <cmccann> wavewave, oh hey
17:18:44 <danharaj> edwardk: I've been playing with machines today. Here's a very simple example that illustrates the usefulness of indexing input by k :: * -> *. I was going to implement the actor model next for fun. Do you have examples that use more than Plans?
17:18:54 <danharaj> http://hpaste.org/75935
17:18:55 <Cale> zzing: Probably a good way to begin is to cleanly separate the file into a portion before and after a pair of blank lines.
17:19:13 <cmccann> wavewave, I decided to start hacking on an implementation of geometric algebra for doing basic graphics stuff
17:19:15 <wavewave> cmccann: hi!
17:19:22 <cmccann> weren't you interested in something like that?
17:19:36 <edwardk> danharaj: yeah you just spotted the fact that the main machines type is a version of monad prompt ;)
17:19:51 <wavewave> cmccann: great. yeah, that's interesting.
17:19:55 <danharaj> A superior version in my opinion :P
17:20:02 <edwardk> danharaj: most of the interesting examples we have are all over in scala sadly
17:20:12 <danharaj> I can read scala! Almost.
17:20:28 <danharaj> Also I was wondering about the Appliance class because I'm not sure how to interpret the description.
17:20:29 <edwardk> https://github.com/runarorama/scala-machines has a few examples in it
17:20:48 <edwardk> danharaj: its partially a joke, and partially a placeholder for missing functionality
17:21:14 <wavewave> cmccann: on my side, I am about to release a new version of hoodle
17:21:22 <danharaj> There is a precedent for serious concepts being given pun names in your libraries ;)
17:21:30 <zzing> Cale, the trouble I am having is coming up with a pure way of doing it. I suppose I can take advantage of lazy evaluation for something like this. I was just thinking it would be easier to do it progressively.
17:21:34 <cmccann> wavewave, I'm not really aiming for extreme performance (that invites a lot of headaches figuring out when multivectors will be empty without losing speed to laziness you don't need) but something fast enough to use for simple stuff
17:21:39 <edwardk> the goal is that you use it to make an Applicative for a machine
17:21:46 <edwardk> hence Appliance ;)
17:21:49 <zzing> I should be able to do a break on "\n\n" before using lines
17:22:02 <cmccann> yeah, I've still not had the time to actually experiment with hoodle at all. :[ I'm glad you went with that name, though, it was my favorite
17:22:09 <zzing> > length "\n"
17:22:10 <lambdabot>   1
17:22:11 <edwardk> so when your input is such that you can merge multiple 'request' streams together in a sensible way you can make an applicative instance for machine
17:22:39 <danharaj> what do you mean by 'request' stream? These are undefined terms that are not intuitive to me. :P
17:22:41 <Cale> zzing: Well, what I/O really has to be performed after you read the file?
17:22:59 <zzing> Cale, it is all read in :-)
17:23:04 <edwardk> e.g. if you have a single input you could just block and make sure to feed the same inputs to both machines, and then take their outputs and feed the nth function returned by one the nth output returned by the other
17:23:08 <zzing> Although one thing - how should I handle errors?
17:23:09 <wavewave> cmccann: good abstraction will pay back soon hopefully ;-)
17:23:24 <edwardk> danharaj: consider a Process. ideally it should be applicative
17:23:31 <zzing> I have importDocument returning a Maybe so far, so i supose that will do
17:23:40 <Cale> zzing: Well, to be fair, if you really want to do this right, you might want to use something like Parsec
17:23:52 <edwardk> by feeding the same inputs to two machines, running them in parallel and then merging their outputs
17:24:00 <Cale> zzing: which will provide you with nicer errors than "something was wrong"
17:24:18 <danharaj> ah yes, I see, that makes sense.
17:24:21 <cmccann> wavewave, I've now gotten sidetracked playing with some UI stuff, but even with a grossly inefficient unoptimized conformal 3D I seem to get tolerable speed
17:24:35 <zzing> Cale, it would take me a while to figure out how to do that, when I am really dealing with stuff that can be parsed with breakOn
17:24:51 <wavewave> cmccann: cool~
17:25:20 <cmccann> wavewave, anyway, once I have a slightly more usable version I'm going to toss it on github, dunno if you'd actually have any use for it or not but it'd be nice to get someone else trying it out
17:25:27 <edwardk> danharaj: but this doesn't work for all input 'profiles', what do you do when you have two machines that each take a pair of inputs, and one reads from the left a lot and the other from the right? how do you interleave?
17:26:30 <danharaj> I see. Speaking of which, what is a "Wye"?
17:26:32 <wavewave> cmccann: I was checking your github now. I look forward to seeing that library there!
17:26:35 <cmccann> I've basically only been testing with stuff from 2 to 5 dimensions, either euclidean or the conformal style (which has one "timelike" direction)
17:26:48 <zzing> > Data.Text.breakOn "\n" "test\ndata"
17:26:49 <lambdabot>   Not in scope: `Data.Text.breakOn'
17:27:01 <startling> Text.Blaze.Html.Render.String.renderHtml makes this: https://gist.github.com/57f7f171bedf19154484
17:27:10 <cmccann> not that time has anything to do with it in this case, but might as well borrow the term
17:27:18 <startling> that's not right, "hello." renders as "hello ." because of the newline
17:27:35 <zzing> How do I tell ghci which extensions I want it to support?
17:27:40 <startling> err, T.B.H.R.Pretty.renderHtml, I mean
17:27:50 <startling> zzing, :set -XSomeExtension
17:28:08 <startling> it renders fine with T.B.H.R.String, though, but it's pretty ugly
17:28:12 <startling> (no newlines)
17:28:16 <startling> is there no middle ground?
17:28:24 <cmccann> wavewave, any thoughts on what a good API should look like for such a library would be nice, though
17:28:40 <zzing> merci
17:28:46 <cmccann> especially since I suspect you're more familiar with the concepts than I am
17:28:56 <wavewave> cmccann: it'll be my great pleasure to make some comment on your work! ;-)
17:29:15 <wavewave> cmccann: just post it on github. I will be watching you.
17:29:29 <cmccann> wavewave, I will, though probably not until next weekend
17:29:50 <wavewave> these days, I am exploring ghcjs.
17:29:51 <cmccann> right now it's just a bunch of product definitions and some utility functions for creating rotations
17:30:44 <cmccann> though it's kind of nice to have a type that represents geometric objects with an actual, legit, sensible Num instance as well
17:30:50 <cmccann> even abs and signum make sense!
17:31:51 * cmccann hasn't looked at ghcjs at all, compiling to javascript always sounds too scary D:
17:32:13 <pharaun> possible to update an IxSet using two keys or am i going to have to remove then re-insert into the IxSet ?
17:32:31 <pharaun> the api seems to imply that it needs to be a single key?
17:32:44 <wavewave> cmccann: eventually I would like to make a tiny javascript version of hoodle using ghcjs
17:33:07 <cmccann> that would be really neat!
17:33:34 <wavewave> ghcjs has a nice cabal integration, that's an advance compared with other haskell->javascript tools.
17:33:48 <wavewave> but it doesn't have FFI yet.
17:33:56 <wavewave> that's minus point.
17:35:09 <cmccann> what would you be using to show output? SVG and/or a canvas element, or something else?
17:35:20 <wavewave> canvas element.
17:35:48 <wavewave> hoodle uses cairo library extensively.
17:35:55 <wavewave> and cairo is very similar to canvas
17:36:47 <pharaun> how would you even use FFI with ghcjs, unless you mean a FFI to javascript libraries?
17:36:49 <wavewave> so I hope that I can make a common abstraction of canvas and cairo so that as large code as possible can be reused.
17:37:24 <cmccann> wavewave, that makes sense, though I also suspect SVG might be more efficient for some of what you'd be doing...
17:37:48 <wavewave> pharaun: currently, you cannot use any external function for ghcjs yet.
17:38:08 <pharaun> wavewave: as in jQuery?
17:38:25 <wavewave> pharaun: yes, you cannot use it yet.
17:38:33 <zzing> What was the syntax that I am using here called?     where match (h, e) | h == "Title     :" = (True , PDoc (Just e) Nothing  Nothing  Nothing  Nothing)     ( | h == … )     I am having some trouble with it compiling (doesn't know about ==), so I think i am using it wrong.
17:38:39 <wavewave> pharaun : in a sense, only 'pure' hasekll function can be used in ghcjs.
17:38:58 <bytbox> I'm probably just missing the obvious, but I can't seem to find any boolean xor (outside of Data.Bits). That can't be right, can it?
17:39:17 <pharaun> wavewave: oh ok gotcha :) i'm just used to thinking of FFI as in external compiled/other code and was like buh
17:39:19 <wavewave> pharaun: but of course ghcjs soon has it. that seems a top priority.
17:39:27 <pharaun> makes sense
17:39:36 <pharaun> silly to throw away lots of hard work with other js libraries
17:39:40 <cmccann> bytbox, (/=)?
17:39:41 <applicative> bytbox: isn't it /=
17:40:16 <bytbox> cmccann: applicative: yeah, thanks
17:40:28 <bytbox> not sure how I missed that
17:40:47 <wavewave> cmccann: that's right, but in fact, because gtk abandons gnomecanvas2 (which is similar to SVG), and moved towards cairo, so I had to choose cairo.. following 'immediate mode rendering path'
17:41:05 <cmccann> wavewave, yeah, makes sense
17:42:02 <wavewave> pharaun: among haskell->javascript tool, ghcjs has the largest goal in a sense : embrace whole haskell and whole javascript in one tool.
17:42:49 <wavewave> cabal integration in ghcjs is quite impressive.
17:43:28 <luite> it doesn't really work right though, i'll look into it again when i get the new code generator pushed
17:43:58 <wavewave> anyway, today, I just experimented to build FFI to webkit javascript library and found that c2hs is not working for that because of C99 bool type.
17:44:33 <zzing> Is "otherwise" not a keyword?     Not in scope: `otherwise'   (used in a pattern guard)
17:44:50 <luite> it's a Bool value
17:45:11 <zzing> learn something new every day
17:45:26 <cornihilio> how do I tell if an attoparsec Result r is of type Done or Fail? http://hackage.haskell.org/packages/archive/attoparsec/0.8.3.0/doc/html/Data-Attoparsec-Lazy.html
17:45:40 <zzing> I should see if I really need NoImplicitPrelude when using some yesod related stuff… import Prelude (undefined, error, ($), (.), IO, unlines, show, putStrLn, fmap, Show, Eq, id, null, String, (++), Maybe(Just, Nothing), Bool(..), (==), otherwise)
17:45:41 <startling> luite: ha, clever
17:46:13 <wavewave> luite: I got an error message : The type specifiers of this declaration do not form a legal ANSI C(89) type.
17:46:58 <luite> what's hoodle?
17:47:02 <wavewave> luite: when I tried to convert a C function with bool return type by {#fun #}
17:47:19 <wavewave> luite : pen notetaking program entirely written in haskell.
17:47:21 <zzing> luite, it is a small animal that clings to people hearing hoodies
17:47:31 <luite> wavewave: ah cool
17:47:33 <wavewave> zzing : kkk
17:47:43 <wavewave> luite: formerly 'hxournal'
17:47:49 <wavewave> luite : now changed to hoodle
17:48:16 <wavewave> luite: http://ianwookim.org/hxournal
17:48:19 <zzing> and "A water pipe or bong." (from ud)
17:48:22 <luite> i'm still writing a new code generator for ghcjs, which is a lot of work, but should hopefully pay off in a few months, 20x faster than the old one
17:48:35 <wavewave> this is a web site for that.
17:48:48 <wavewave> luite: that's really cool!!!
17:49:03 <luite> but when i get enough basic features up and running, i'll try to help you with canvas ffi :)
17:49:15 <zzing> Has anyone attempted to write a nice Qt binding?
17:49:25 <cornihilio> how do I tell if an attoparsec Result r is of type Done or Fail? http://hackage.haskell.org/packages/archive/attoparsec/0.8.3.0/doc/html/Data-Attoparsec-Lazy.html
17:49:34 <ousado> luite: is that on github somewhere?
17:49:42 <wavewave> luite : I hope ghcjs will work quite well with a good performance in the case of my program since it's mainly using native rendering library.
17:50:05 <luite> ousado: not yet, i'm pushing the new generator in a new branch today or tomorrow
17:50:16 <rwbarton> cornihilio: you can use a case expression
17:50:19 <startling> is there a css dsl somewhere?
17:50:19 <luite> wavewave: haskell runs about 10x slower than ghc
17:50:22 <rwbarton> (and they aren't "types")
17:50:23 <luite> native, with -O2
17:50:40 <luite> that's in chrome and firefox 18
17:51:00 <cornihilio> rwbarton: thank you! but, what are they then?
17:51:10 <zzing> Cale, if I wanted to write a parser is there a quick way of me doing it while learning about it? I can see myself relying on perfection that doesn't exist.
17:51:22 <luite> hopefully i can sqeeze some more speed out of this with pointer tagging, dataflow analysis and (hopefulyl next year) proper tail calls in js
17:51:34 <rwbarton> cornihilio, you should read some introductory haskell text
17:51:35 <ousado> luite: or do you blog or something? I'd be interested in how you go about lazy evaluation
17:51:44 <luite> ousado: the same as the native ghc
17:51:48 <wavewave> luite: yeah, I understand it. In my case, haskell is mainly for program logic, not for any fast-processing.
17:52:17 <wavewave> luite: your plan sounds very exciting to me!!!
17:52:41 <luite> wavewave: yeah even for that, the upgrade might be worthwhile, the old version (and also haste) has some memory leaking issues that are difficult to resolve
17:53:29 <Cale> zzing: There's this old tutorial about Parsec which is stilly pretty good, even though the modules have moved around a bit. http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
17:53:43 <Cale> (Someone should really go through this and update it to the current version at some point)
17:54:00 <luite> ousado: read the "making a fast curry" paper by simon marlow, that's more or less the strategy
17:54:05 <zzing> I really do want to do this properly, but don't want to get bogged down in learning to parse :P
17:54:33 <Cale> http://hackage.haskell.org/package/parsec-3.1.3 -- here is the modern Parsec, you're mainly meant to import Text.Parsec
17:54:44 <luite> ousado: difference between the old one is that the odl one uses javascript closures to capture free variables, the new one copies them explicitly to an array
17:55:00 <zzing> Cale, would it make sense to design the parser around the idea of making the monoid and then have another function that converts that to the proper full type?
17:55:36 <Cale> zzing: It's reasonably simple to get started with -- the main idea is just that you have some primitive parsers which match simple things, like single strings or characters and such, and then you have ways to glue those together into larger parsers -- notably do-notation, as parsers form a monad
17:55:51 <Cale> but yeah, you want to produce values in your monoid
17:56:04 <Cale> and then combine the results of subparsers
17:56:07 <zzing> I can also throw away unknown headers without errors
17:56:16 <Cale> Or maybe even more precisely type the results of the subparsers
17:56:44 <Cale> Well, at the very least, you may be able to separate the type of a header from the type of the content.
17:56:59 <miyako> I'm using FFI to create a wrapper for a C library.  Is there a way to access enums provided by the library so that I can create a corresponding Haskell type.
17:57:00 <Cale> Or something -- perhaps what you have is fine.
17:57:15 <ousado> luite: thanks, I'll take a look
17:57:20 <stepkut> is there a quasiquoter like 'verbatim' or 'here' on hackage already ?
17:57:23 <zzing> I know I could make a nice regex for a regular header
17:57:33 <Cale> zzing: This is like that, but better :)
17:57:45 <Cale> zzing: (more readable and even more writeable)
17:57:54 * BMeph has trouble making sense out of the phrase, "a nice regex"... ;)
17:57:56 <sclv> stepkut: yep, don't remember the name tho. one sec
17:58:17 <stepkut> i keep reimplementing it.. which is silly ;)
17:58:18 <wavewave> miyako: have you looked at c2hs?
17:58:19 <zzing> I suppose I can make a parser for a header, then one that reads anything for the body, and then the whole thing is  manyOne header newline newline body
17:58:24 <luite> ousado: the javascript implementation doesn't use the system (javascript) stack, but a dynamically allocated growable stack for each thread (a javascript array)
17:58:53 <zzing> Cale, now I notice there is a Text.Parsec.Text, I am dealing with Text types here. Should I have any trouble with that?
17:59:04 <Cale> zzing: nope, it should work fine :)
17:59:33 <zzing> Cale, I think I should learn how to make my own parser combinators too. I think the real world haskell book and/or the hutton book have something on it
17:59:34 <miyako> wavewave: yeah, I was hoping to avoid using c2hs because I had some issues with it in the past, but most of the information I've found via google is talking about using c2hs to do it.  I was hoping there was some other way.
17:59:38 <Cale> zzing: If you import that module, it'll define Parser and GenParser type synonyms to make it easy to use Parsec with Text
17:59:59 <Cale> zzing: If you want, I can take you through the construction of a super-simple Parser implementation
18:00:00 <sclv> stepkut: just ctrl-f on the page gives me http://hackage.haskell.org/package/string-quote
18:00:05 <Cale> Let me get a cup of tea :)
18:00:14 <sclv> and this which i guess is newer http://hackage.haskell.org/package/string-qq
18:00:29 <zzing> Cale, I should be able to start with that :P. I do have a friend coming over shortly though.
18:00:31 <wavewave> miyako: in fact, I am struggling with c2hs right now. ;-(
18:00:48 <sclv> & this for interpolation: http://hackage.haskell.org/package/interpolatedstring-perl6
18:01:28 <stepkut> spiffy
18:01:30 <sclv> i think applicative-quoters used to have one, but it seems gone now
18:01:33 <hamishmack> wavewave: Hi, are you using the stand alone or integrated ghcjs?
18:01:46 <zzing> hmm, he might be here now :P
18:02:15 <zzing> Cale, could I take a raincheque?
18:02:21 <orzo> is there a way to make your own classes derivable with the deriving keyword ?
18:02:27 <Cale> zzing: Sure
18:02:48 <sclv> orzo: not exactly. but you can use the new generics and default instances to come very very close.
18:02:53 <liyang_> orzo: yes, send a patch to GHC-HQ.
18:03:17 <sclv> orzo: or you can use the derive package to build th derivers which aren't shabby either.
18:03:53 <liyang> There's also Template Haskell for writing derivers.
18:04:21 <wavewave> hamishmack: hi, i installed integrated ghcjs last week. :-)
18:04:22 <Cale> There was, at one point, a system which I think allowed the extension of 'deriving' via product/sum generics, but from what I understand, nobody maintained it.
18:06:15 <liyang> Cale: you don't mean http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-programming.html ? That's recent…
18:06:21 <luite> wavewave: oh in that case i've said nothing about cabal not working properly, the integrated build works much better :)
18:06:35 <Cale> liyang: I mean the thing that that replaces
18:06:50 <luite> wavewave: difference is that hamishmack made the integrated build, i did the standalone one, you do the math ;p
18:07:01 <Cale> liyang: and possibly an old version of it... it looks like the one in 6.12.x didn't have special syntax for deriving
18:07:07 <Cale> You just wrote empty instance declarations
18:07:09 <wavewave> luite: ahh, I see.
18:07:10 <liyang> Cale: I guess the replacement will have to suffice. :)
18:07:15 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/generic-classes.html
18:07:16 <orzo> liyang: is this template haskel method separate than the derive package that sclv mentioned?
18:07:41 <wavewave> luite: I installed the standalone version first and had some problem at that time, too.
18:07:44 <liyang> orzo: yeah, best not to look at it unless you feel masochistic.
18:08:16 <Cale> liyang: The new one is probably better, though it has less cute syntax.
18:08:19 <ihm> anyone have any experience using CmdArgs? I can't seem to get the "args" annotation to work
18:08:37 <Clint> what's the error?
18:08:43 <luite> wavewave: yeah i'm not surprised, i haven't spent much time testing and using that build
18:08:59 <ihm> i'm writing a little todo-list app
18:09:01 <ihm> System.Console.CmdArgs.Implicit, unexpected flag (Arg_): Help "A to-do list item you wish to add"
18:09:27 <ihm> that's what happens if i run it without any arguments or with bare (that is, non-flag) arguments
18:10:11 <sclv> orzo: here's derive: http://community.haskell.org/~ndm/derive/
18:10:25 <hamishmack> It will take a while to gather meta data
18:10:30 <sclv> its a tool that helps with template haskell, but you can of course do the th without it
18:11:06 <orzo> I'd like something like Show, but the output always works as code you can paste into a .hs source file
18:11:37 <orzo> i'm finding i'm wasting lots of time reformating generated data to make static tests
18:13:57 <wavewave> hamishmack: today, I tried to make webkit-javascriptcore ffi library using c2hs, but i got stuck with C99 bool type. Do you have any experience about that?
18:14:26 <liyang> orzo: The (unwritten?) convention with Show is that it should output something that's parsable as a Haskell expression…
18:14:54 <liyang> orzo: in any case, why have static tests when you can QuickCheck?
18:15:14 <hamishmack> I have not.  Is there a package that uses it I could try in ghcjs?
18:15:29 <orzo> liyang: well, i find that quickcheck finds problems, and then i take the data it generates and make a static test program to debug it
18:16:09 <liyang> O I C.
18:16:36 <liyang> In that case why bother formatting it nicely? You're going to throw it away once you've fixed the bugs.
18:17:00 <latro`a> f[]
18:17:28 <jfischoff> orzo: I have the same problem
18:17:31 <latro`a> do
18:17:32 <latro`a> er
18:17:34 <latro`a> sorry
18:17:37 <latro`a> disregard
18:17:37 <orzo> two reasons, one, sometimes formatting helps me understand the data i'm looking at, and more importantly, it just DOESNT WORK, to paste show output, it messes up all kinds of things, and i need ot do all kinds of cosmetic work to make stuff parse
18:17:55 <orzo> i'm constnatly wasting time fixing up show output
18:17:59 <orzo> to get it ot parase
18:18:02 <liyang> :-/
18:18:11 <latro`a> [;l;;;;;;'''
18:18:20 <wavewave> hamishmack: no binding to webkit JavaScriptCore library yet as far as I know. I am just trying to make it for dual purpose. one is to make useful thing and the other is to learn how to use c2hs
18:18:25 <liyang> orzo: Can you give us a brief example? hpaste.org maybe?
18:18:50 <liyang> latro`a: give your cat a scratch on the chin for me. :3
18:18:51 <ihm> Going to just use getOpt unless anyone knows of anything better?
18:18:57 <jfischoff> There are a few options. There is groom and there is pretty show I think it is called. However neither create compact enough code in my opinion.
18:19:04 <latro`a> sorry liyang
18:19:25 <latro`a> this is actually trying to get all the keys to work again
18:19:30 <jfischoff> orzo: also you can write the output to a file and read it in for the test.
18:19:42 <latro`a> but it appears that that is not going to happen
18:20:07 <latro`a> oh well, this keyboard lasted 8 years
18:20:15 <orzo> well, suppose you have a constructor with two arguments, the second argument is an hlist.  So something like From (-32) (HCons 5 (HCons 3 HNil)) ---> depending on type, that -32 is not always parenthesized in show output, and the parenthesis around the HList are always absent
18:20:40 <orzo> there is jus tlots and lots of this crap
18:21:06 <hamishmack> wavewave and I are moving our discussion to #ghcjs if anyone else is interested in GHCJS
18:21:17 <liyang> orzo: Oh. Seems like the show instance for the type that the From constructor belongs to is broken.
18:21:58 <orzo> not really
18:22:03 <lightquake> ooh
18:22:10 <lightquake> parallel builds in cabal 0.16 are nice
18:22:15 <orzo> i could change it to From (blah) (blah) no matter what, but of course im adding clutter
18:23:04 <liyang> orzo: if you implement the showsPrec method instead of show, you have an extra parameter to let you decide if you need to parenthesise things or not.
18:23:30 <orzo> and i used "deriving" to define show there and the issue would apply to all derived-show instances for data instances
18:24:10 <falbani> Hi
18:25:15 <Luke1> rwbarton: you mentioned a while ago an env var I could set to specify more libraries?
18:25:50 <orzo> liyang: okay, well i wasnt familiar with showsPrec, thanks.  Still I wish the whole task smoother
18:26:24 <JoeyA> In GHC.Event.Manager, why does unregisterTimeout call wakeManager?
18:27:46 <falbani> If one tends to name classes (interfaces) appending the "-able" suffix, i.e., pointing out the fact that some types are ABLE to be manipulated in some way, which would be the "-able" adjective for the Monad class. What means for a type of the form "M a" to be "monadable"?
18:28:08 <JoeyA> Bindable?
18:28:11 <JoeyA> Actionable? :-)
18:29:08 <JoeyA> My mental model of the GHC event manager: wait until the soonest timeout expires, or activity happens on an FD we're watching.
18:29:40 <JoeyA> But if a new timeout or FD is inserted while waiting, we may have to reduce our wait time, so that's why we need to wake the manager.
18:29:43 <falbani> I'm no Haskell expert; I know how to handle the common monads but I feel that after reading many of monad tutorials I still cannot "see" when something is monadable...
18:30:19 <falbani> for example, can a "M a" monad instantiation depend on the nature of type "a"?
18:30:21 <fujisan> @tell falbani how much i love lambdabot
18:30:21 <lambdabot> Consider it noted.
18:30:37 <shachaf> falbani: It can't.
18:30:38 <napping> well, see if you can define return and bind
18:31:00 <latro`a> you never instantiate an m a anyways
18:31:02 <shachaf> falbani: The "-able" suffix is usually silly.
18:31:12 <shachaf> And "Monad" isn't a verb, so "Monadable" doesn't mean anything.
18:31:27 <Nereid> monadifiable.
18:31:31 <fujisan> First we thought the PC was a calculator. Then we found out how to turn numbers into letters with ASCII — and we thought it was a typewriter. Then we discovered graphics, and we thought it was a television. With the World Wide Web, we've realized it's a brochure.
18:31:37 <orzo> hm, i dont understand showsPrec
18:31:48 <falbani> shachaf: "-able" makes sense many times and I know it's not a verb... i'm playing with the language
18:31:48 <lambdabot> falbani: You have 1 new message. '/msg lambdabot @messages' to read it.
18:32:01 <fujisan> @messages
18:32:02 <lambdabot> You don't have any new messages.
18:32:10 <fujisan> try that in the channel please falbani
18:32:25 <orzo> also, i run into issues with infinites in my data, so show gives Infinity rather than (1/0)
18:32:49 <falbani> fujisan: I don't understand the joke, sorry.
18:32:51 <shachaf> falbani: Most standard classes don't have the "-able" suffix.
18:32:57 <orzo> is the Show instance for Float/Double broken?
18:33:07 <shachaf> You shouldn't try to add it just because.
18:33:10 <fujisan> it's not a joke falbani
18:33:11 <orzo> or is the idea that show makes pastable data just wrong
18:33:22 <shachaf> orzo: Why would it show "(1/0)"?
18:33:23 <fujisan> can you just do @messages in the channel please falbani?
18:33:33 <fujisan> testing a feature
18:33:36 <shachaf> fujisan: What?
18:33:39 <shapr> fujisan: This conversation may be better done in #haskell-blah
18:33:42 <fujisan> @messages
18:33:42 <lambdabot> You don't have any new messages.
18:33:53 <orzo> shachaf: because that is a Float or Double value that represents infinity, and i don't know how else to make that value in haskel syntax.
18:34:02 <falbani> shachaf: I know they don't have it, but for example the Show class is meant for types "able to be shown"
18:34:08 <shachaf> Show and Read aren't supposed to be Haskell syntax.
18:34:09 <falbani> fujisan: I tried. It worked
18:34:10 <fujisan> ok ty shapr i didn't know about that channel sorry if i was disruptive
18:34:21 <fujisan> ok ty falbani
18:34:53 <shachaf> falbani: OK, and?
18:35:11 <orzo> shachaf: the output it makes "Infinity" will not work
18:35:18 <shachaf> > read "Infinity" :: Double
18:35:19 <lambdabot>   Infinity
18:35:22 <shachaf> Works for me.
18:35:30 <falbani> shachaf: so I wondered if finding a "able" adjective for this may help me understand monads better
18:35:55 <orzo> oh i see, well i guess the read function takes it, but you can't paste write a=Infinity in your haskell source file
18:35:56 <shachaf> falbani: Num instances can be (+)ed and (-)ed and all sorts of things.
18:35:57 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
18:36:35 <shachaf> falbani: The adjective approach won't help you understand Monad.
18:36:39 <falbani> it's like the monad class is meant for "container" types able to be the result of some computation... I don't know
18:36:43 <BMeph> orzo: Why not?
18:36:47 <falbani> (english is not my natural language)
18:36:50 <shachaf> falbani: No, monads have nothing to do with containers.
18:37:00 <rwbarton> actionable
18:37:08 <orzo> > Infinity :: Float
18:37:09 <lambdabot>   Not in scope: data constructor `Infinity'
18:37:09 <falbani> shachaf: some tutorials offer that point of view
18:37:17 <shachaf> falbani: They're wrong. :-)
18:37:21 <falbani> shachaf: but I know is not 100% appropiate
18:37:26 <napping> > read "[Infinity]" :: [Double]
18:37:27 <lambdabot>   [Infinity]
18:37:38 <falbani> rwbarton: can you expand on that?
18:37:39 <shachaf> @quote monad.*container
18:37:39 <lambdabot> dons says: Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
18:37:40 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
18:37:41 <shachaf> @quote monad.*container
18:37:42 <lambdabot> dons says: Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
18:37:42 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
18:37:48 <shachaf> @quote kmc: monad.*container
18:37:48 <lambdabot> kmc: says: "monads are like containers, as long as you forget everything you know about containers, and treat it as a synonym for 'monad'"
18:37:57 <napping> orzo: maybe the test program should read a string
18:38:49 <zebr> shachaf: well, 'container' is a nice visualisation for a subset of monads :p
18:38:55 <orzo> napping: then i need to make Read instances for everything
18:39:01 <shachaf> zebr: No it's not. It's unhelpful.
18:39:15 <zebr> shachaf: not for that subset, it aint.
18:39:39 <falbani> shachaf: which would you say are the properties that made a type "m a" candidate for a meaningful instance of monad?
18:39:50 <shachaf> I'm not sure what you're getting at.
18:39:55 <shachaf> falbani: Yes, the monad laws.
18:40:36 <zebr> shachaf: basically the idea of a 'container' is a useful way of introducing oneself to the monad laws when one isn't a mathematician :p
18:40:49 <zebr> shachaf: it isn't entirely accurate, but it works for a useful subset of cases.
18:41:09 <falbani> shachaf: but the monad laws tell me nothing
18:41:42 <shachaf> falbani: They tell you everything. The thing is that Monad is such a generic API that knowing about it doesn't tell you a whole lot about concrete instances.
18:41:54 <zebr> falbani: the monad laws are extremely abstract. that's kind of the point. it's somewhat unhelpful when trying to grasp the concept, though.
18:41:54 <shachaf> zebr: No, it'll just confuse you and give you wrong intuition.
18:42:12 <shachaf> Almost all monads break the "container" analogy terribly, and the few that don't aren't that interesting.
18:42:13 <lightquake> the only way to learn monads is to write a lot of haskell
18:42:23 <megajosh2> I only really understood monads after using them
18:42:31 <lightquake> and eventually you'll notice 'huh, there's a pattern here'
18:43:06 <orzo> quickcheck ought to be able to autogenerate a throw-away test program stub using the failed data
18:43:16 <lightquake> that'd be pretty neat
18:43:21 <shachaf> @forget kmc: "monads are like containers, as long as you forget everything you know about containers, and treat it as a synonym for 'monad'"
18:43:22 <lambdabot> Done.
18:43:30 <shachaf> @remember kmc monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
18:43:30 <lambdabot> Done.
18:44:51 <zebr> shachaf: will you hurt me if i say monads are more like one of those extendable ladders?
18:45:43 <shachaf> You can say unhelpful things and make inside jokes, and the channel won't be much worse for it.
18:45:47 <shachaf> But it certainly won't be better for it.
18:46:27 <cmccann> ah, but inside jokes form a monad
18:46:27 <zebr> it is actually closer to an extendable ladder than a container, though. :)
18:49:18 <JoeyA> tibbe: Quick question about the GHC event manager:  why does unregisterTimeout call wakeManager?  If I understand correctly, unregisterTimeout never shortens the length of time the manager needs to wait.
18:49:22 <zebr> also i'd say that the lambda calculus nested data type monad is both a container and interesting :p
18:49:27 <latro`a> I think functors actually are a lot like containers
18:49:36 <latro`a> as are pointed functors
18:50:05 <latro`a> but that monads are less like containers in general
18:50:18 <zebr> latro`a: well, if a functor is like a container a monad must be too :p
18:50:20 <JoeyA> Is this to keep TimeoutQueue edits from stacking up?
18:50:25 <latro`a> not really
18:50:26 <nexx> latro`a but every monad is a functor
18:50:44 <latro`a> no I mean that join can be non-container-y
18:50:46 <latro`a> basicay
18:50:53 <latro`a> *basically
18:50:53 <liyang> monads are *beyond* containers.
18:51:01 <latro`a> right
18:51:02 <liyang> join is perfectly containery.
18:51:11 <latro`a> not necessarily
18:51:12 <latro`a> often yes
18:51:14 <shachaf> Functors are even less like containers than monads.
18:51:25 <latro`a> I disagree
18:51:39 <Gracenotes> (a -> a -> b) to (a -> b). I can see the containers already.
18:51:59 <latro`a> to fmap nontrivially you need the value to be there
18:52:03 <liyang> You have a burrito inside a spacesuit and you join them to make a space-burrito.
18:52:15 <nexx> latro`a you mean actually functors, which are not monads, are like containers?
18:52:16 <zebr> again, it's a useful metaphor for a subset of functors.
18:52:18 <frio> thanks liyang, i finally get monads!
18:52:36 <shachaf> What value is "in" (String -> Int) or (IO Int) or (State Char Int)?
18:52:44 <zebr> i mean if i had to understand category theory before using fmap, well, no.
18:52:46 * shachaf gets a feeling of déjà vu.
18:52:48 <latro`a> rather that the functor interface is containery, nexx
18:53:12 <latro`a> if functions are accepted as being containery
18:53:25 <latro`a> which is not that easy to swallow
18:53:54 <shachaf> What about (Void -> Int)?
18:53:59 <latro`a> shachaf: function types are essentially dictionaries
18:54:28 <latro`a> and I said "to fmap nontrivially" for a reason
18:54:41 <hpaste> orzo pasted “Type alias causes instance overlap?” at http://hpaste.org/75936
18:54:43 <shachaf> Hmm, this is an argument about words.
18:54:51 <shachaf> Therefore it's useless. :-)
18:54:52 <latro`a> yes
18:54:54 <latro`a> indeed
18:55:05 <cmccann> @quote endospacesuit
18:55:05 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
18:55:34 <orzo> see my paste.  All i did was use the type keyword to make a short-hand, and it causes Read to stop working
18:55:40 <shachaf> syntaxgrinch
18:55:49 <shachaf> orzo: Maybe it's a weird ghci behavior.
18:55:59 * shachaf will guess that it doesn't reproduce in a file.
18:56:16 <fujisan> Did you guys hear about that new programming languages that is closer to a natural language?
18:56:35 <danharaj> Is this the set up to a joke?
18:56:54 <cmccann> natural language programming is generally a joke, yes
18:57:26 <orzo> shachaf: i guess so, putting the Cell alias into my source file caused ghci to accept it
18:57:35 <ParahSailin> but i can program anything in lojban!
18:57:46 <shachaf> orzo: If you can narrow it down to a little test case, that'll be great.
18:58:13 <cmccann> pf, lojban does not count as a natural language
18:59:04 <fujisan> ieje mencre do tol mencre mi xagji
18:59:21 <Gracenotes> lojban is off-topic.
18:59:25 <fujisan> oh sorry
18:59:36 <Gracenotes> orzo: I think this can only be an issue with ghci.
18:59:59 <Gracenotes> i.e. it traces two paths to an instance declaration which it thinks are distinct.
19:00:21 <Gracenotes> but reproducibility would help.
19:02:46 <fujisan> :crying3:
19:03:03 <zebr> it's true: a natural language is defined as one that is not defined, but instead /evolves/. that's why common lisp is a natural language.
19:03:55 <fujisan> but isn't nature superior to anything we can come up with
19:04:00 <danharaj> hahaha
19:04:02 <fujisan> the way DNA stores memory etc
19:04:07 <danharaj> what
19:04:14 <latro`a> zebr: conlangs evolve
19:04:15 <fujisan> so why the hate on natural language?
19:04:17 <orzo> it is a ghci issue, and im working around it.  Are you saying you want me to file a bug report with instructoins on reproducing?
19:04:21 <latro`a> if they are actually used
19:04:25 <latro`a> which is not unusual
19:04:34 <shachaf> orzo: If you can narrow it down to something simple and it's definitely a bug, then you probably should.
19:04:54 <zebr> fujisan: natural languages are beautiful, but not conducive to the logic needed for programming :p
19:05:02 <orzo> sorry, are you saying its definately a bug, or are you saying that -if- its definately a bug, i should do that?
19:05:06 <fujisan> but they probably use a higher logic
19:05:22 <orzo> i don't want to make the call that its a bug
19:05:22 <zebr> fujisan: right, the problem is that our computers are stupid.
19:05:43 <orzo> maybe its just a ghci interactive limitation
19:05:47 <danharaj> orzo: it doesn't hurt to report it
19:05:49 <fujisan> i know i tried Siri
19:05:56 <fujisan> it's horrible
19:06:49 <Gracenotes> orzo: a limitation is a bug
19:07:22 <Gracenotes> remove stuff until what you propose starts working
19:07:52 <rwbarton> if it's a behavior the ghc developers don't expect then they will be glad to learn about it whether it is a bug or not
19:08:45 <fujisan> Cedric Lynch uses his own logic and no professor can follow him he invented his own math for it
19:09:43 <fujisan> i think that will happen with artificial intelligence as well eventually
19:10:05 <fujisan> at some point we will just be unable to comprehend
19:12:08 <fujisan> but i like the concept here to learn something and then chat about it in here
19:15:09 <tigger__> Hi all, I'm working on the port audio bindings which build on my machine (os x 10.8 with ghc 7.4) with "cabal install portaudio" but they seem to fail on hackage http://hackage.haskell.org/packages/archive/portaudio/0.2.0/logs/failure/ghc-7.4 with error messages stating that various items in the hsc file are undeclared. Does anyone have any tips on what the issue might be?
19:16:37 <tigger__> maybe it's complaining because portaudio is not installed on the hackage server?
19:16:38 <applicative> orzo: awesome error
19:17:11 <shachaf> tigger__: Quite possibly.
19:17:17 <shachaf> tigger__: Try it on your own machine.
19:19:49 <orzo> it wants me to register to report the bug
19:20:03 <rwbarton> that sort of looks like the wrong version of portaudio headers possibly
19:20:24 <cornihilio> okay, I think I'm finally getting somewhere. Right now I have this https://gist.github.com/3850389 with this output https://gist.github.com/3850391 which seems to indicate that for some reason the bytestring it is returning is the complete one, not the partially parsed one, as indicated on the API page: "The parse succeeded. The ByteString is the input that had not yet been consumed (if any) when the parse succeeded."
19:20:32 <tigger__> shachaf: hmm, ok
19:20:37 <hpaste> orzo pasted “Bug: Interactive type alias breaks class instance.” at http://hpaste.org/75938
19:20:52 <orzo> there's a paste, if anybody wants to forward that on to the bug tracker, they can
19:23:06 <applicative> tigger__: portaudio seems to build fine
19:23:58 <cornihilio> also, here is all my code atm: https://gist.github.com/3850405
19:24:19 <tigger__> applicative: yeah its strange, im not sure where those errors are from. I actually don't even recall installing portaudio on my mac.
19:24:34 <tigger__> applicative: let me see if the examples work
19:25:38 <tigger__> does anyone know what the hackage build environment is?
19:26:48 <fryguybob> orzo: Perhaps it is related to http://hackage.haskell.org/trac/ghc/ticket/5820
19:26:53 <JoshTriplett> dcoutts_: Around?
19:27:09 <fryguybob> orzo: I can't reproduce it on 7.6.
19:27:11 * hackagebot libxml-sax 0.7.3 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.7.3 (JohnMillikin)
19:28:39 <tibbe> JoeyA: don't remember off hand
19:28:41 <tibbe> JoeyA: bbl
19:33:55 <tigger__> ok I guess if I remove portaudio.h from my path it fails, so that must have been the issue. thanks all!
19:33:58 <orzo> fryguybob, hmm, guess its fixed then
19:35:05 <tigger__> on another note, I don't seem to ever see any of the docs here: http://hackage.haskell.org/package/portaudio-0.2.3, even though I can locally build and view them. This is probably because the portaudio header isn't on hackage, is there another way to upload docs.
19:35:37 <tigger__> I've noticed that hsndfile also has docs, even though I'd guess the libsndfile header is not included on the build server?
19:37:05 <randomclown> If I have data A = One | Two, then data X = X A
19:37:21 <randomclown> is there a way to make sure the type constructor X A only accepts One?
19:37:49 <Eduard_Munteanu> randomclown: no
19:37:52 <JoshTriplett> randomclown: Short answer: no.  That's called "dependent typing".
19:38:27 <JoshTriplett> randomclown: Some languages have that, and it offers some fun features (like a "head" function that requires a non-empty list), but it adds more complexity and more proof requirements, and Haskell doesn't do it.
19:38:55 <randomclown> ok
19:39:12 <JoshTriplett> randomclown: You might look at Omega if you're interested in dependent typing.
19:39:35 <Eduard_Munteanu> Or the friendly neighbor, Agda. ;)
19:39:52 <JoeyA> You can do it using GADTs: data One; data Two; data A t where One :: A One; Two :: A Two; data X = X (A One)
19:40:12 <cornihilio> okay, I think I'm finally getting somewhere. Right now I have
19:40:13 <cornihilio>              this https://gist.github.com/3850389 with this output
19:40:13 <cornihilio>              https://gist.github.com/3850391 which seems to indicate that for
19:40:13 <cornihilio>              some reason the bytestring it is returning is the complete one,
19:40:16 <cornihilio>              not the partially parsed one, as indicated on the API page: "The
19:40:19 <cornihilio>              parse succeeded. The ByteString is the input that had not yet
19:40:22 <cornihilio>              been consumed (if any) when the parse succeeded."
19:40:26 <cornihilio> sorry, didn't know it would format like that
19:40:32 <applicative> tigger__:  with the last line "withPortAudio withBlockingIO" Example1.hs ended in 'Segmentation Fault' but the other option 'withPortAudio (withDefaults >> withCustomSettings)' makes a pleasant noise...
19:40:38 <cornihilio> okay, I think I'm finally getting somewhere. Right now I have this https://gist.github.com/3850389 with this output https://gist.github.com/3850391 which seems to indicate that for some reason the bytestring it is returning is the complete one, not the partially parsed one, as indicated on the API page: "The parse succeeded. The ByteString is the input that had not yet been consumed (if any) when the parse succeeded."
19:41:27 <fujisan> http://learnyouahaskell.com/introduction#so-whats-haskell OS X is reading it to me now
19:41:46 <latermuse> When do you guys chose to use trees instead of lists when working with data?
19:41:53 <tigger__> applicative: are you running with runghc
19:42:01 <tigger__> applicative: or compiling then running
19:42:28 <applicative> I compiled.
19:42:55 <tigger__> applicative: oh yeah, I still need to fix that https://github.com/sw17ch/portaudio/issues/3#issuecomment-8226988
19:42:56 <Eduard_Munteanu> latermuse: depends a lot on "data". And mind Data.Map is a tree-like structure so that counts too.
19:43:14 <tigger__> applicative: it works with runghc but not when compiled for some reason...
19:43:42 <applicative> ah I see, it's the same issue indeed
19:43:53 <tigger__> applicative: btw, do you know any way to get the docs to show up on hackage? they build locally but not on hacakge, prolly due to the header
19:44:06 <fujisan> Haskell was made by some really smart guys (with PhDs). so do i need to be a PhD to understand Haskell?
19:44:30 <lispy> fujisan: nope
19:44:43 <luite> depends on how much of it you want to understand, but you can get pretty far without one
19:45:00 <fujisan> do you need to be good at math?
19:45:05 <applicative> tigger__: i m not sure; does the build have to succeed before haddock is put to work?
19:45:08 <lispy> fujisan: but don't be discouraged if you find yourself needing to learn a lot of new things. That's normal.
19:45:09 <luite> fujisan: not at all
19:45:18 <fujisan> ok ty
19:45:40 <tigger__> applicative: no probs. yeah I have no clue, im a noob at this hackage stuff.
19:45:47 <cornihilio> why is my attoparsec lazy Done result returning the entire unparsed bytestream?
19:45:59 <tigger__> applicative: id assume so though.
19:47:12 * hackagebot dbus 0.10.1 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.1 (JohnMillikin)
19:49:23 <latermuse> fujisan: I find myself reading higher level math books recreationally so that I can better understand haskell. But I wasnt good at math when I began.
19:49:39 <arthurmaciel> hello
19:49:52 <applicative> hello arthurmaciel
19:52:17 <arthurmaciel> I'm interested in learning a functional programming language and I have found some difficulty understanding Haskell (I suppose I don't a so mathematician mind). In contrast, Scheme has an easy syntax and I'm trying to understand some concepts of functional programming with it. This can be read as a too broad question, but what are the main differences between Haskell and Scheme, despite of their complete different syntax?
19:52:40 <cmccann> arthurmaciel, Haskell's type system
19:52:44 <cornihilio> is my issue simply a misunderstanding of basic concepts in haskell, or is my issue attoparsec specific?
19:53:43 <cornihilio> I think that because the bytestream that's getting returned is total, that there is something fundamentally wrong. The returned length should not equal the length of the unparsed bytestring.
19:54:03 <arthurmaciel> cmccann: I have read about it on A Gentle Introduction to Haskell. Indeed Scheme does not have a type system like that. Is there any advantage of this type system other than compile time errors detection?
19:54:10 <arthurmaciel> (and thanks for answering!)
19:55:02 <cmccann> arthurmaciel, well it's really a very impressive amount of compile-time error detection
19:55:52 <rwbarton> types also serve as documentation, you can do type-directed searches
19:56:05 <cmccann> and type inference sometimes lets you avoid some boilerplate code
19:56:11 <arthurmaciel> cmccann: I see. I'm not an experienced programmer, so I don't have much idea of what is the cost of this error detection. But I believe you :)
19:56:18 <cmccann> and hoogle is a thing, that's pretty nice
19:57:00 <cmccann> but really scheme isn't a bad place to start, I learned scheme before learning haskell and it helped a bit
19:57:45 <arthurmaciel> cmccann: hey, hoogle is quite interesting!
19:57:49 <tac> arthurmaciel: I think Haskell tends to be focused on fancy things you can do with types
19:58:08 <tac> If you want to break into typed functional programming languages, Ocaml is a better starting point.
19:58:08 <arthurmaciel> tac: what do you mean by that? Could you give an example, please?
19:58:09 <cmccann> a lot of the very fancy stuff is just abstraction golfing
19:58:38 <cmccann> any ML-style language would be a fine starting point
19:58:42 <frio> arthurmaciel: advanced typing allows you a lot of power to ensure your program is correct.
19:58:46 <tac> arthurmaciel: Haskell is very powerful. It has lots of features you don't need to know to get started
19:58:54 <arthurmaciel> cmccann and tac: could you point out examples of 'fancy things'
19:58:59 <tac> And it can be hard to decide what is "basic" and what can be saved for later (if ever)
19:59:00 <arthurmaciel> please?
19:59:11 <frio> arthurmaciel: scheme has nil/null, right?
19:59:15 <cmccann> arthurmaciel, eh, most of it's hard to even explain to someone who doesn't know the language
19:59:19 <frio> and you occasionally need to check things are nil or null?
19:59:43 <arthurmaciel> frio: yes
19:59:51 <frio> in haskell, your type system can ensure you never need to do that, or can encode it sensibly so the programmer is forced to check null (rather than the program crashing when it hits that)
20:00:14 <frio> in haskell it's called the Maybe type, but C# (for instance) has lifted it as the Option type :)
20:00:19 <tac> arthurmaciel: things like multiparameter type classes, GADTs (I guess Ocaml has those now too), functional dependencies --- none of these are super useful to learn Functional Programming
20:00:27 <cmccann> C# has Nullable<>
20:00:33 <cmccann> Option is F#
20:00:37 <frio> ah, right :)
20:00:44 <cmccann> actually, every other ML-type language uses option I think
20:00:50 <cmccann> Maybe is a Haskell-ism
20:00:59 <jmcarthur> agda inherited it, now
20:01:00 <tac> arthurmaciel: Haskell is also very pure. You can't do IO without having to learn a little about Monads, and you can't "fall back" on imperative programming
20:01:29 <cmccann> well yeah, every ML-style language not descended from Haskell
20:01:37 <applicative> cornihilio: try CA.many1 packetValue instead of   CA.many packetValue
20:01:41 <frio> arthurmaciel: have you just used scheme? or have you learnt other languages as well?
20:01:44 <cmccann> or perhaps closely related to it, dunno about Clean or such
20:02:24 <arthurmaciel> guys, I quite understand that, but while studying Scheme (that is really susceptible to those kind of errors) and talking to the Scheme community, I have been thinking about how much the programmer should or should not know where those flaws can occur. To delegate to the compiler something you should prevent seems to be positive and negative at the same time, don't you think?
20:02:56 <frio> arthurmaciel: surely it's entirely positive? what negatives do you see?
20:03:05 <tac> frio: not really
20:03:14 <frio> if the compiler can prevent me from doing Dumb Stuff (and I do a lot of Dumb Stuff), then that's absolutely something i want to take advantage of
20:03:18 <cmccann> well, the negative is that compilers are stupid and explaining things to them can be tedious
20:03:24 <stew> arthurmaciel: accept some invalid programs to teach the programmer a lesson?
20:03:28 <tac> cmccann: <- exact that
20:03:31 <cmccann> which is where type inference and whatnot comes in
20:03:34 <arthurmaciel> frio: if you develop your program step by step, and check it works at every step, you won't be trapped in those errors, for example.
20:03:42 <frio> tac/cmccann: yeah fair enough in that case
20:03:50 <tac> In Haskell, you end up having to baby-sit the type system
20:03:59 <tac> it helps for sure in most cases
20:04:04 <tac> which is why we're here in this channel :)
20:04:07 <jmcarthur> just wanted to share this little nugget that stole a lot of my time this evening that i already shared with #haskell-game... (fromIntegral . (truncate :: Float -> Int) :: Float -> Word8)  is waaaay faster than  (truncate :: Float -> Word8)  because there is a rewrite rule for (truncate :: Float -> Int) but not for (truncate :: Float -> Word8)
20:04:15 <tac> But it's not *always* a benefit.
20:04:18 <jmcarthur> the latter uses properFraction :(
20:04:19 <frio> tac: I absolutely agree with that, and that's why i prototype a lot of stuff in dynamic languages (clojure's my current plaything :))
20:04:29 <cmccann> a lot of the fancy type trickery people do is to 1) explain more detailed constraints to the compiler 2) teach the compiler how to figure stuff out on its own
20:04:33 <BMeph> In Haskell, the type system baby-sits YOU! ;)
20:04:39 <cornihilio> applicative: thank you so much! that really helped me get back on the right track
20:05:00 <cmccann> personally, I think lisp-family languages are worth trying even for Haskell programmers
20:05:10 <cmccann> though I'd probably go with clojure these days instead of scheme
20:05:15 <tac> In Haskell, especially, even though it has a "more powerful" type system than, say, Java or C.... trying to understand unification errors is a big ol' PITA
20:05:25 <frio> arthurmaciel: i agree with you whole-heartedly, but having a safety net that can catch you when you do fuck up is very valuable
20:05:40 <BMeph> jmcarthur: That's...obscene! :/
20:06:00 <cmccann> rewrite rules always seemed like a huge hack to me :T
20:06:27 <frio> arthurmaciel: basically, as someone who develops in both clojure and haskell (and python and java during the day), scheme/a lisp is a great place to start
20:06:36 <arthurmaciel> frio: answering back there: I have studied C, C++, PHP and little bit of Python.
20:07:06 <tac> IMO, it's good to know *just enough* Scheme to be able to write the eval function in Scheme
20:07:11 <arthurmaciel> stew: is that an invitation?
20:07:13 * hackagebot http-conduit-browser 1.6.1 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.6.1 (MylesMaxfield)
20:07:22 <frio> arthurmaciel: in that case, id start on scheme to get a handle on things
20:07:50 <arthurmaciel> if I understand correctly clojure is a Lisp dialect as Scheme is, right?
20:07:55 <cmccann> yes
20:07:57 <frio> yes; it runs on the JVM
20:08:06 <cornihilio> applicative: seriously, thank you, now it's actually finding packets! I've been tearing my hair out over that; I never though of using attoparsecs own combinators.
20:08:06 <arthurmaciel> isn't it dlow?
20:08:09 <arthurmaciel> slow*
20:08:13 <tac> Once you know how this code works, you know enough Lisp: http://lib.store.yahoo.net/lib/paulgraham/onlisp.lisp
20:08:14 <frio> no
20:08:16 <cmccann> I think clojure is also the only language besides Haskell with a decent STM implementation
20:08:23 <cmccann> which is pretty cool but not relevant to a beginner I suppose
20:08:31 <frio> i really really like how modern clojure feels
20:08:39 <frio> because everything in it, and its libraries, is so new
20:08:41 <arthurmaciel> cmccann: what is a STM implementation?
20:08:48 <frio> there's very little in the way of ancient cruft, which is nice
20:08:54 <tac> State Transactional Memory = STM arthurmaciel
20:09:14 <arthurmaciel> uh... any hint on what it means, please?
20:09:25 <ion> Software transactional memory
20:09:35 <tac> arthurmaciel: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/index.htm <- this is a very easy to read paper on the subject
20:09:42 <frio> arthurmaciel: it really depends what you want out, in terms of what you learn, btw :). if all you're after is an orientation to the functional mindset, scheme or clojure will be great. haskell is a neverending spiral of billions of new things to learn, which can be very frustrating.
20:09:50 <tac> but basically, STM = modular concurrency where you run all read/writes in a transaction
20:10:15 <tac> Either the whole transaction runs in one go, or it aborts and tries again later.
20:10:16 <frio> but haskell has taught me a lot more than clojure or scheme would...
20:11:06 <arthurmaciel> tac: understand the code until which line?
20:11:40 <tac> usually you have to understand *all* the code :P
20:11:47 <cmccann> frio, incidentally, any suggestions on the best place to start learning clojure? I really want to try it out one of these days.
20:12:05 <cmccann> even after a few years of haskell I still miss scheme sometimes :T
20:12:30 <arthurmaciel> cmccann: what do you miss about it?
20:12:42 <frio> cmccann: the API's pretty much all you'll need. coming from haskell, i found everything very familiar (and rich hickey is obviously quite interested in haskell himself)
20:12:49 <arthurmaciel> tac: STM ~ database transactions? (an quite imperfect analogy)
20:12:53 <cmccann> dunno, lisps are just sorta fun to tinker with
20:13:11 <tac> arthurmaciel: actually, it's almost exactly the same thing. STM is "software" Transactions
20:13:31 <frio> cmccann: I haven't read any books... but I'd recommend picking something you want to make, getting leiningen (2.0preview-whatever), and blatting out something new (lein new whatever)
20:13:36 <arthurmaciel> tac: oh, so I get the idea.
20:13:41 <cmccann> frio, reading some of the stuff about his philosophy for clojure is a large part of why I'm wanting to try it
20:14:05 <frio> yeah, it's really nice cmccann. the only fault i have with it (other than the lack of static types) is the java interop
20:14:14 <frio> it's... fine, but warty
20:14:18 <cmccann> well
20:14:20 <arthurmaciel> is clojure a lisp dialect that do ffi with Java standard libs?
20:14:21 <cmccann> it's java, so
20:14:22 <cmccann> yeah
20:14:29 <rwbarton> transactional memory, meaning I can say "if variable x is positive then add variable y to variable z" and that whole operation will occur atomically
20:14:34 <ion> arthurmaciel: Re: STM: http://youtu.be/hlyQjK1qjw8?t=12m39s
20:14:40 <tac> the thing Haskell does really well, arthurmaciel, is that the transaction is trapped inside an STM monad. And inside an STM monad, you can *only* do reads and writes. Not arbitrary IO.
20:14:42 <frio> it's a lisp dialect that runs on the JVM arthurmaciel -- in the same way that scala does etc.
20:14:51 <tac> Arbitrary IO is what makes transactions unsafe in other languages.
20:15:16 <frio> cmccann: yeah. it can be a bit frustrating... for instance, a type (almost) is a record. so you can (defrecord AThing name picture), for instance
20:15:26 <frio> and that'll go away and generate a java class
20:15:47 <arthurmaciel> tac: so concurrency is safe by default in Haskell, right?
20:16:01 <frio> in elder clojure, that meant you had to both (:use [somemodule :only (Thing)]) *and* do a java-import to get at the type constructor
20:16:02 <tac> well, kinda
20:16:13 <frio> luckily in 1.4 they've cleaned that up quite a bit, so the import isn't necessary anymore
20:16:15 <tac> There's both safe and unsafe concurrency in Haskell
20:16:30 <tac> but you can easily identify which one a programming is using by the types involved.
20:16:58 <tac> as long as you're using *just* STM, you can be sure you don't have the most dangerous kinds of concurrency bugs.
20:17:03 <arthurmaciel> tac: I have read about monads and even tried to watch some youtube records about it, but I confess I understood almost nothing
20:17:25 <cmccann> frio, last time I used Java was even longer ago than last time I used scheme, heh
20:17:33 <tac> Monads are easy, but if you try to think about what they are, they become hard.
20:17:44 <arthurmaciel> tac: any example?
20:17:48 <cmccann> how much does clojure have in the way of libraries that don't involve ugly java interop?
20:18:22 <tac> at the "survival" level of understanding, you can just pretend that monads are a way to control which side effects a function can have.
20:18:52 <arthurmaciel> tac: well, so I survived ;)
20:19:05 <arthurmaciel> (if my life depended on that definition)
20:19:19 <ion> arthurmaciel: You won’t need to learn monads beforehand. You’ll end up using a bunch of libraries who just happen to offer the same kind of interface for certain operations and the understanding will come almost automatically.
20:19:31 <tac> but more accurately, monads are just a data type where you have two functions: return and bind. Return "puts a thing inside the monad", bind "executes a function on a monad"
20:19:56 <tac> and they obey some algebraic laws which you don't really have to think about usually and seem obvious
20:20:08 * ion cringes at the explanation. :-P
20:20:20 <tac> ssh ion
20:20:33 <tac> that's why I gave the survival level first.
20:21:07 <monochrom> "ssh ion" should lead to ion's prompt "Password:"
20:21:50 <arthurmaciel> lol
20:21:56 <arthurmaciel> that's what I read first!
20:21:57 <ion> I don’t think i’m personally listening on port 22, and i’d use key auth anyway.
20:22:19 <tac> but yeah. Monads are just algebraic thingies. That's why they are so hard. It's like explaining what a mathematical field is to someone.
20:22:25 <tac> "It's something that works like the real numbers"
20:22:44 <tac> Monads are things that work like continuations >____>
20:23:16 <monochrom> @quote array.*monad
20:23:17 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
20:23:22 <monochrom> is my explanation
20:23:47 <tac> yeah
20:23:49 <monochrom> do not ask "what is". ask for examples and use cases
20:23:58 <tac> one you get the hang of "do" notation, you just forget about monads
20:24:38 <monochrom> programmers do not ask "what is number, what is 1, really". just use numbers.
20:25:09 <tac> The important thing to remember in do-notation is
20:25:19 <tac> if x has type IO Int
20:25:29 <frio> cmccann: "enough" :p
20:25:36 <tac> then in "do i <- x; ...", i has type Int
20:25:43 <cmccann> frio, ok :P
20:25:44 <tac> and the whole thing has to end in IO *something*
20:25:45 <frio> to be fair, the interop isnt so bad, it's just a bit warty
20:25:51 <frio> you dont have to do it very often
20:26:38 <frio> a constructor, for instance --  new MyThing("a", 2) would translate to (MyThing "a" 2), which isn't so bad
20:27:01 <frio> and accessing something -- myThing.doSomething() (. myThing doSomething)
20:27:25 <frio> it's pretty clean in all fairness, and now that the (import) and (use) thing isn't necessary anymore it's a little cleaner
20:27:44 <tac> Q. How can you tell a program is written in Lisp? A. You search for the string ")))))))))" in the source code
20:27:45 <tac> xD
20:27:55 <frio> painfully true tac :p
20:28:06 <arthurmaciel> monochrom: could you please give me an example or use case of monads, please?
20:28:13 <ion> It seems to be popular in Russia to add this kind of a… “smiley” in the end of sentences))))))))))))
20:28:18 <arthurmaciel> tac, really thanks for the explanation.
20:28:22 <shachaf> arthurmaciel: Don't worry about monads.
20:28:33 <frio> sharpening my emacs has been a big part of the clojure experience tac :p
20:28:36 <ion> They can also be sad(((((((((
20:28:36 <tac> arthurmaciel: no problem. (but what shachaf said. Don't worry about them).
20:28:52 <Eduard_Munteanu> arthurmaciel: an easy one to consider is Maybe: computations which may fail
20:28:57 <Eduard_Munteanu> @src Monad Maybe
20:28:57 <lambdabot> Source not found. Wrong!  You cheating scum!
20:29:48 <arthurmaciel> geez, this bot is aggressive!
20:29:54 <Eduard_Munteanu> return = Just; Nothing >>= _ = Nothing; Just x >>= f = f x
20:29:58 <monochrom> the list comprehension [ x+y | x<-[1,2], y<-[3,4] ] can be written as the monadic [1,2] >>= \x -> [3,4] >>= \y -> return (x+y)
20:30:32 <latermuse> monochrom: why would you chose the monadic version over the list comprehension version? The former is much easier to read
20:31:01 <Eduard_Munteanu> arthurmaciel: in that case, failure is indicated by Nothing, which short-circuits the whole thing.
20:31:27 <frio> arthurmaciel: i spent a long, long time trying to understand monads
20:31:49 <frio> they're actually _very_ simple, but because they've got a new word and a stack of unfamiliar syntax, they seem more confusing than they are
20:32:01 <monochrom> my first answer is that I'm showing an example of monad, and I want to bootstrap it from something you already know, e.g., list comprehension
20:32:14 <frio> like the others said, dont worry about them/ignore them for now
20:32:42 <ion> latermuse: List comprehensions can be implemented in terms of the list monad. Also, here’s the same monadic code using the “do” notation. do x <- [1, 2]; y <- [3, 4]; return (x+y)
20:32:44 <frio> and when it comes time to learn them, dont make them complex than they are, if that makes sense :)
20:33:20 <monochrom> my second answer is that GHC now generalizes list comprehension to monad comprehension as prophesized by Phil Wadler. now you can write [ length xs | xs <- getLine, _ <- putStrLn xs ], too
20:33:23 <latermuse> ion: do notation is easier to read than the notation using the >>= operands
20:33:23 <shachaf> If you use the word "them" when talking about "monads", you've already lost. There is no "them".
20:33:42 <Eduard_Munteanu> Them monads. :P
20:34:02 <shachaf> Or if you say "learn monads".
20:34:38 <ion> I need to get from place A to B. How do i learn vehicles?
20:34:39 <arthurmaciel> monochrom: thanks for the example, but indeed I need more. I don't understand a bit. Thanks anyway!
20:34:55 <monochrom> yes, you need 10 to 100 examples
20:35:10 <monochrom> I cannot give 10 to 100 examples for free
20:35:46 <arthurmaciel> monochrom: anyway, all of your examples would be of the same color to me ;)
20:35:59 <arthurmaciel> http://learnyouahaskell.com/ <--- is it worthy?
20:36:01 <Eduard_Munteanu> You just need to try to work out the definitions for a few simple monads to "get it".
20:36:14 <Eduard_Munteanu> Either by staring at them, or trying to reimplement them yourself.
20:36:29 <monochrom> but Phil Wadler gives 3 for free. look for his "monad for functional programming" article. it's how I learned.
20:36:30 <Eduard_Munteanu> arthurmaciel: yeah, that's what's usually recommended in here
20:37:09 <monochrom> of course, it should be "monads for functional programming"
20:37:10 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
20:39:29 <arthurmaciel> geez, university of glasgow: that reminds me glasgow's trauma scale!
20:42:08 <latermuse> my girlfriend hates that I spend so much time studying haskell. her eyes glaze over when I talk to her about monads and arrows. how can I save our relationship?
20:42:37 <tac> latermuse: Teach her Agda instead
20:42:47 <spaceships> use a girlfriend monad
20:43:12 <Cale> Pass yourself as a failure continuation to the relationship
20:43:16 <tac> spaceships: once you put it in the girlfriend monad, you can't take it out.
20:43:42 <monochrom> why do you talk about monads and arrows to her. sounds like some kind of brainwashing or forcing her to listen.
20:43:43 <Eduard_Munteanu> Then you can both enjoy type-theoretic euphemisms for stuff.
20:44:27 <Eduard_Munteanu> "I can't take you out tonight, I can only bind you around."
20:44:28 <frio> latermuse: http://www.exocomics.com/245
20:44:31 <latermuse> monochrom: I guess I have nothing else to talk about these days. I am spending hours every day reading about monads and arrows
20:44:52 <monochrom> unless the two of you have a symmetric, bilateral agreement that you may tell her things that bore her, and she may tell you things that bore you
20:44:55 <latermuse> frio: haha Ill show her that
20:44:56 <arthurmaciel> http://wiki.call-cc.org/eggref/4/monad <-- they have done it in Scheme!
20:45:24 <frio> latermuse: mine sent me that after a week or so of me ranting about SICP :E
20:45:54 <shachaf> arthurmaciel: That doesn't look like a good article.
20:47:35 <Eduard_Munteanu> arthurmaciel: you should probably try to understand monads in the context; "ports" to other languages often make less sense.
20:48:00 <arthurmaciel> schlumpi: that's not an article. It just says there is port to Scheme.
20:48:07 <arthurmaciel> schlumpi: sorry
20:48:23 <arthurmaciel> shachaf: that's not an article. It just says there is port to Scheme.
20:48:24 <shachaf> It's OK. You don't need to say my name.
20:48:35 <latermuse> monochrom: if you have a symetric, bilateral agreement with each other to talk about things that bore each other, then why would you still be with that person in a relationship?
20:48:52 <monochrom> it is more relational to play strip monopoly
20:49:11 <arthurmaciel> shachaf: it makes me think that monads are good! if people want to port a feature, it may be quite worthy to learn!
20:50:05 <Eduard_Munteanu> Well, I kinda wished for monads in Erlang for instance.
20:50:16 <Eduard_Munteanu> (and there is a monad library for it)
20:51:39 <Eduard_Munteanu> But that being said, they're less useful or even usable in other languages, say C.
20:52:54 <Cale> arthurmaciel: Yeah, but the sad fact is that most languages don't have the features required to make the monad abstraction worthwhile to use.
20:54:51 <Cale> arthurmaciel: If you look at the type of return :: (Monad m) => a -> m a
20:55:23 <arthurmaciel> Cale: what do you mean by this second sentence?
20:55:24 <Cale> It is polymorphic in its result type in a way that can't be decided from its parameter
20:55:48 <Cale> i.e. you can't determine m given the input to the function, you have to determine it from the context in which return is used
20:55:49 <arthurmaciel> Cale: so?
20:55:59 <Cale> and moreover, m is a type constructor
20:56:01 <orzo> i have a Show instance that outputs a constructor function for a Data.Vec object, reason being that all the ():.() is ugly to look at and grok.  How difficult would it be to make a corresponding Read instance that intereprets the constructor?  Is there any quick easy example of this sort of thing?
20:56:30 <mm_freak> i think Cale's point is that you need polymorphism of type constructors for monads to be worthwhile, which is true
20:56:40 <arthurmaciel> oh, ok, now I see.
20:56:51 <Cale> Very few programming languages really support polymorphism over type constructors, and all the polymorphism that OO languages tend to give you is directed by the types of the arguments to operations, not the types of their results
20:57:12 <Cale> and without those things, the monad abstraction is pretty much unusable
20:57:15 <arthurmaciel> hm.. That's make sense.
20:57:29 <orzo> is there a Read/Show tutorial?
20:57:30 <arthurmaciel> That makes sense*
20:57:33 <mm_freak> also most other languages have too much syntax noise for monads to be useful
20:57:57 <arthurmaciel> mm_freak: indeed that's one thing I'm learning about Haskell: a lean syntax
20:58:18 <arthurmaciel> Well, guys, thank you so much for the explanations! I'll study more! Have a good night!
20:58:20 <Saizan> orzo: i think one often writes a ReadP parser and uses the conversion to ReadS
20:58:46 <mm_freak> bind(Action(…), function (x) { return Action(…) })
21:00:16 <arthurmaciel> good night to all!
21:00:19 * shapr waves
21:00:24 <Eduard_Munteanu> arthurmaciel: g'night
21:00:43 <mm_freak> good morning
21:06:00 <twmb> I'm reading Learn You a Haskell, and I don't understand typeclasses that much, are there any more sources I could read a different perspective from?
21:07:45 <Quimet> http://book.realworldhaskell.org/read/using-typeclasses.html
21:07:45 <spaceships> twmb: i found the gentle introduction's type sections lucid --- http://www.haskell.org/tutorial/index.html
21:08:45 <frio> twmb: what other languages have you used?
21:09:00 <twmb> Java, C, Tcl, C++, Perl, uh
21:09:28 <twmb> maybe others that I can't think of readily, maybe not
21:09:31 <frio> twmb: the correlation that worked for me is that typeclasses are like interfaces in java, kind of :)
21:09:38 <frio> except you can declare them after-the-fact
21:09:45 <frio> so you can confirm a type X
21:10:04 <frio> and then later say X is an instance of (implements) typeclass Y, meaning it has a series of functions that can be performed on it
21:10:18 <twmb> ok.. that makes sense, but I don't understand how the Read typeclass works, nor the read function
21:10:26 <frio> s/confirm/define/ (im too tired :<)
21:10:50 <Cale> twmb: Okay, so the read typeclass looks like this:
21:10:59 <Cale> class Read a where
21:11:04 <Cale>   read :: String -> a
21:11:09 <Cale>   ... some other stuff...
21:11:37 <Cale> twmb: This means that an instance of the Read typeclass will provide a parser for turning a String into a value of the given type
21:11:39 <twmb> LYAH says that it takes a string and returns a type of member Read... but - what is member Read?
21:11:44 <Cale> > read "56" :: Integer
21:11:45 <lambdabot>   56
21:12:02 <frio> a type that implements/is an instance of the Read typeclass
21:12:22 <rwbarton> I'm sure it doesn't say "type of member Read"
21:12:23 <twmb> does Haskell have it's own little table that it compares the string against, then?
21:12:25 <Cale> So, you can think of type classes as being like predicates on types (things which might be true or false of any given type)
21:12:44 <frio> which just means that it returns a type, for which the "read" method is defined
21:12:49 <rwbarton> maybe "type that is a member of [the type class] Read"
21:13:04 <Cale> and when they are true, it means that there is some bunch of implemented functionality for that type
21:13:09 <frio> twmb: what Cale said above is indicative -- you generally need to specify the type you want back, so haskell can find the correct Read function
21:13:16 <twmb> k
21:13:27 <twmb> I'm just looking at the examples in LYAH and doing some of them
21:13:33 <twmb> specifying the return type would make sense
21:13:38 <frio> read "/my/link" :: URL says "convert this into a URL", but it'll only work if URL is an instance of Read, and therefore defined a read function
21:13:41 <twmb>  read "True" || False
21:13:49 <Cale> twmb: If it can be inferred from context what the type is, say, because you applied some operation which determines it, then you won't need to say which type
21:14:10 <twmb> ok that actually makes a lot of sense, now
21:14:17 <Cale> twmb: The typechecker sees that you're taking the result of read "True" and using the logical OR operation to combine it with False
21:14:24 <Cale> and so it must need to read a Bool
21:14:33 <twmb> I didn't think that it'd be using inference on the other stuff in the line, I thought it was just sheer magic converting it to the right type
21:14:42 <Cale> and that determines which instance of Read is selected (which parser parses the string)
21:14:55 <twmb> k
21:14:59 <twmb> thanks that makes much more sense
21:16:01 <twmb> wow
21:16:30 <twmb> If I read the paragraph further, I would have read what you just explained... I just sat and thought about the read function for so long I didn't think to read further.
21:17:12 <frio> haha :)
21:17:42 <frio> i do that (that said, talking about it helps heaps too)
21:18:14 <BMeph> "The true magic of the mind is technology."
21:21:49 <twmb> Is programming dynamic webpages in Haskell difficult?
21:22:28 <adnauseam> you can try doing in in java server pages if you'd like
21:23:09 <alpounet> that's mean.
21:23:21 <adnauseam> sorry =p
21:24:13 <twmb> not that I care, I'm asking for... is Haskell that great of a web language at all?  I want to experiment writing a web page in haskell, but if it's terrible to do, I might not
21:25:25 <adnauseam> yes it is great
21:25:41 <adnauseam> especially if you plan on scaling
21:25:54 <twmb>  good
21:26:27 <alpounet> twmb, there are 3 good web frameworks: happstack, yesod and snap
21:26:45 <alpounet> for happstack, see http://www.happstack.com/c/view-page-slug/3/documentation
21:26:57 <alpounet> for yesod, well, there's a book, which is also readable online
21:27:24 <alpounet> and for snap, see http://snapframework.com/docs/quickstart to get a taste of how it looks like to use it
21:27:52 <alpounet> well, http://snapframework.com/docs/tutorials/snap-api rather
21:29:05 <orzo> anyone know a quicky for consuming all the elements of a list as arguments to a function?
21:29:53 <Cale> orzo: What type is the operation that you want?
21:29:55 <orzo> doit func [a1,a2,a3,...] = func a1 a2 a3 ...
21:30:10 <Cale> What's the type of doit?
21:31:21 <frio> doit's the function he doesn't know the name of...
21:31:28 <Jafet> doit :: Not Damn -> Give
21:31:55 <Cale> frio: I'm asking what type of function he *wants*
21:32:00 <orzo> in one case, it's  (Int->Int->Vec2 Int) -> [Int] -> Vec2 Int
21:32:19 <adnauseam> map ?
21:32:23 <Cale> doit f [x,y] = f x y
21:32:26 <frio> is there a generic "apply" function in haskell?
21:32:29 <Cale> doit f _ = ...?
21:32:38 <frio> (i doubt it?)
21:32:43 <adnauseam> map?
21:32:44 <Jafet> :t ($)
21:32:46 <lambdabot> forall a b. (a -> b) -> a -> b
21:32:57 <frio> no adnauseam -- that'd be func a, func b, func c etc.
21:32:58 <Cale> Yeah, ($) is function application
21:33:05 <frio> this is func [a, b, c] = func a b c
21:33:09 <Cale> Every function takes exactly one parameter
21:33:27 <orzo> could i do a fold with ($) ?
21:33:29 <orzo> heh
21:33:49 <Cale> orzo: pretty much no.
21:34:02 <geekosaur> you should think about what the type would be of a function thta could take an arbitrary number of parameters
21:34:04 <Cale> orzo: Think about what type the resulting operation will have
21:34:07 <twmb> alpounet: Which do you think is best?
21:34:08 <Jafet> orzo: you can't write something if it doesn't have a valid type.
21:34:28 <frio> ah Cale, right (the one parameter bit especially :D)
21:34:34 <alpounet> twmb, they use different approaches, see the comparison there: http://softwaresimply.blogspot.fr/2012/04/hopefully-fair-and-useful-comparison-of.html
21:34:36 <Cale> It is actually possible to do some sneaky things with type classes to make this kind of thing happen.
21:34:40 <Cale> But you don't want it.
21:34:42 <alpounet> there isn't really a "best"
21:35:17 <frio> twmb: if you're looking at making something small, i've really enjoyed using scotty
21:35:33 <frio> which is a sort of sinatra-esque microframework
21:36:05 <frio> for larger stuff, it's a tossup between snap and yesod depending on the style you prefer (yesod uses a _lot_ of template haskell)
21:36:38 <orzo> i looked at the error for: let doit f xs = foldl ($) f xs
21:37:02 <orzo> it infers the result is the same type as f
21:37:10 <Cale> yes, it has to be
21:37:12 <orzo> due to the foldl signature
21:37:27 <Jafet> :t foldl1 ?f ?xs
21:37:28 <lambdabot> forall a. (?xs::[a], ?f::a -> a -> a) => a
21:37:41 <Cale> orzo: after all, xs might just be an infinite list, and things have to work out
21:38:06 <Cale> orzo: So the only way for this to work is if f can always take another parameter and produce a function which can do the same again
21:38:37 <Cale> But we don't allow infinite types like that
21:38:49 <Cale> At least, not without a newtype constructor in between
21:38:56 <Cale> :t inR
21:38:58 <lambdabot> Not in scope: `inR'
21:39:02 <Cale> oh, hmm
21:39:03 <Jafet> :t In
21:39:04 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
21:39:06 <Cale> right
21:39:10 <Cale> :t InR
21:39:11 <lambdabot> forall a. (Rec a -> a) -> Rec a
21:39:15 <Cale> :t OutR
21:39:16 <lambdabot> Not in scope: data constructor `OutR'
21:39:18 <Cale> :t outR
21:39:19 <lambdabot> forall a. Rec a -> Rec a -> a
21:39:20 <Cale> ugh
21:40:02 <Cale> I guess that's the other way
21:40:05 <orzo> pretty much i'm writing the same funciton repeatedly for different values of f and different numbers of arguments.
21:40:11 <latro`a> :k Rec
21:40:12 <lambdabot> * -> *
21:40:18 <latro`a> @source Rec
21:40:18 <lambdabot> Rec not available
21:40:24 <latro`a> eh
21:40:34 <orzo> the recurring pattern suggested i might be able to do it more concisely
21:40:37 <Cale> orzo: But you have to handle all the cases where the number of parameters to f isn't correct
21:40:49 <latro`a> figured that would happen
21:40:50 <Cale> You might indeed be able to do it more concisely
21:41:07 <Cale> latro`a: yeah, it's just stuck into L.hs
21:41:25 <Jafet> newtype Rec a = InR { outR :: a }
21:41:29 <Cale> latro`a: I never bothered to copy-paste the code into the file that @src reads from
21:41:35 <Cale> also @source is different from @src
21:41:51 <latro`a> that is a bit confusing then
21:41:59 <Jafet> Err
21:42:08 <Cale> newtype Rec a = InR { outR :: Rec a -> a }
21:42:28 <Cale> This is actually the opposite of what we want for orzo's fold I think
21:42:34 <Cale> hmm...
21:42:50 <Cale> Mu ((->) e) ?
21:43:00 <Cale> yeah, that looks right :)
21:43:01 <randomclown> If there any point in having a custom monad for code generation? or should I just stick for the state monad
21:43:11 <BMeph> :t outR . Rec
21:43:12 <lambdabot> Not in scope: data constructor `Rec'
21:43:23 <Jafet> randomclown: use a newtype
21:43:31 <Cale> randomclown: there can be, it depends on what operations you need.
21:44:02 <Cale> But yeah, use a newtype to hide the fact that you're using a State monad, and later if you need to change the implementation, you'll be able to do it without affecting the client code.
21:44:04 <Jafet> And implement the newtype monad with a state monad.
21:44:40 <Cale> :t out
21:44:41 <lambdabot> forall (t :: * -> *). Mu t -> t (Mu t)
21:45:00 <Cale> :t foldl (\f x -> out f x)
21:45:02 <lambdabot> forall b. Mu ((->) b) -> [b] -> Mu ((->) b)
21:45:23 <Cale> orzo: there you go, lol ;)
21:45:36 <hpaste> orzo pasted “repeated pattern” at http://hpaste.org/75954
21:45:51 <Cale> (I am somewhat joking there)
21:46:15 <Cale> orzo: y u no pattern match?
21:46:37 <orzo> you mean on the if part?
21:46:46 <Jafet> case (gs, ws) of ([g1,g2,g3], ("lin3":_)) ->
21:46:49 <orzo> shrug
21:47:00 <Cale> case gs of [x,y] -> [(lin2 x y, unwords (drop 3 ws))]; _ -> []
21:47:09 <Cale> no computing lengths or !!
21:47:19 <orzo> oh ya that would be better
21:47:25 <Cale> also, you can push that back a bit...
21:47:33 <Cale> fs itself could be pattern matched against
21:47:46 <Cale> case fs of (x:y:es) -> ...
21:47:52 <orzo> by the way, this is for instances of Read
21:48:06 <Cale> Usually you want to implement Read using deriving
21:48:12 <orzo> i think its a little silly/inefficient to use unwords
21:48:28 <Cale> oh?
21:48:42 <Cale> ah, well, perhaps a bit, yes
21:49:00 <Cale> Especially if you're chaining lots of these, yeah
21:49:13 <Cale> Let's use ReadP
21:49:29 <Cale> and readP_to_S to make the ReadS for this
21:49:41 <orzo> you're going to walk me through it?
21:49:55 <Cale> yes
21:49:59 <orzo> awsome
21:55:18 <Cale> okay, so this is the library we'll use: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/Text-ParserCombinators-ReadP.html
21:57:19 <Cale> okay
21:57:42 <Cale> orzo: still here? I've written and tested something
21:58:28 <Cale> So, you'll note there are a few components of this library which may be useful:  string :: String -> ReadP String  will try to match a specific string.
21:59:28 <Cale> There's skipSpaces to eat whitespace, but I think it's better to strictly enforce that whitespace occurs with many1 (satisfy isSpace)
21:59:48 <Cale> and there's readS_to_P which you can apply to a reads parser to turn it into a ReadP parser
22:00:02 <Cale> orzo: okay?
22:00:54 <orzo> okay, i managed to make one that parses "lin2" as a string using that string function you mentioned
22:01:11 <Cale> Right, so one other thing you need to know is that ReadP is a monad
22:01:23 <Cale> and you can use do-notation to parse one thing after another
22:01:31 <orzo> okay
22:01:33 <Cale> So if we define
22:01:37 <Cale> space = many1 (satisfy isSpace)
22:01:48 <Cale> parseLin2 =
22:01:48 <Cale>   do string "lin2"
22:01:48 <Cale>      space
22:02:00 <Cale> and here we want to parse some value of an appropriate type
22:02:15 <orzo> do i need to create that space function or is it supplied already?
22:02:20 <Cale> using the reads for that type
22:02:47 <Cale> you could get away with using skipSpaces
22:02:57 <Cale> but that doesn't strictly enforce that at least one space exists
22:03:11 <Cale> (but space itself isn't defined)
22:03:35 <Cale> So next we'll use  x <- readS_to_P reads
22:03:44 <Cale> to read some value of an appropriate type to pass to lin2
22:03:45 <orzo>     Not in scope: `isSpace'
22:03:52 <Cale> ah, import Data.Char
22:03:56 <Cale> forgot to mention that
22:04:26 <orzo> okay
22:04:28 <Cale> and then another space
22:04:37 <Cale> and then  return (lin2 x y)
22:04:40 <Cale> oh, derp
22:04:51 <Cale> heh, before that y <- readS_to_P reads
22:05:11 <hpaste> Cale pasted “ReadP” at http://hpaste.org/75956
22:05:31 <Cale> ghci> readP_to_S parseLin2 "lin2 5 7"
22:05:32 <Cale> [(Lin2 5.0 7.0,"")]
22:05:41 <Cale> much nicer, eh?
22:06:15 <orzo> yes
22:06:26 <Cale> now, we could actually do even better, if you really want to factor out the difference between lin2 and lin3...
22:07:09 <orzo> hm
22:07:52 <orzo> acheiving that isn't obvoius to me either
22:08:03 <orzo> but i don't really need it i guess
22:08:22 <Cale> oh, annoying... ReadP only became an instance of Applicative in the lastest release :P
22:10:58 <Cale> but, if we import Control.Applicative and Control.Monad (or if you're on GHC 7.6.1)
22:11:01 <Cale> we can write
22:11:05 <Cale> instance Applicative ReadP where
22:11:05 <Cale>   pure = return
22:11:05 <Cale>   (<*>) = ap
22:11:11 <Cale> and than
22:11:14 <Cale> and then*
22:11:19 <Cale> parseLin2 =
22:11:19 <Cale>      string "lin2" *> (Lin2 <$> (space *> readS_to_P reads)
22:11:20 <Cale>                             <*> (space *> readS_to_P reads))
22:11:35 <Cale> using the fancy applicative combinators
22:11:47 <orzo> i'm not using 7.6.1
22:11:48 <orzo> heh
22:11:59 <Cale> Yeah, that's fine
22:12:17 <Cale> You'll have to put the Applicative instance for ReadP in to use that then
22:12:30 <Cale> (which is a bit annoying if this is for a library)
22:13:07 <randomclown> Cale: how does one newtype the State monad? I'm a bit confused it
22:13:13 <Cale> randomclown:
22:13:29 <Cale> newtype MyMonad a = MM (State MyState a)
22:13:47 <Jafet> deriving (Monad)
22:13:50 <Cale>   deriving (Functor, Applicative, Monad)
22:14:09 <Cale> and possibly  MonadState MyState,  if you want to provide get and put
22:14:09 <randomclown> ah right the deriving
22:14:26 <Cale> That's with generalised newtype deriving
22:14:27 <Ralith> deriving arbitrary stuff Just Works on newtypes? handy!
22:14:52 <Cale> yeah, it's an extension
22:14:53 <randomclown> probably easier to just use type instead of newtype
22:15:08 <Cale> randomclown: That would defeat the purpose of doing this :)
22:15:19 <Cale> randomclown: The point is that you're not going to expose the MM data constructor
22:15:35 <Cale> randomclown: which means that nobody can actually *tell* that you're using State
22:16:05 <Cale> randomclown: that lets you change the implementation later without having to track down all the usages of this monad, if you want to add features
22:17:22 <randomclown> Cale: can you give an example of adding a feature
22:18:05 <cryptopsy> entire haskell doc available for offline user somewhere?
22:18:24 <Cale> randomclown: Okay, well, I don't know what you're presently using the state for, but suppose later on you decide that you'd like to keep track of local environments using a ReaderT (or just an extra internal function parameter)
22:19:12 <Cale> (You're writing a language implementation right?)
22:19:26 <randomclown> yesh
22:20:27 <Cale> cryptopsy: If you set  documentation: True  in your ~/.cabal/config  then cabal will generate local documentation for every package you install.
22:21:37 <Guest29009> Need help. Trying to "cabal install zip-archive". Getting message: "Codec/Archive/Zip.hs:486:10: Not in scope: `lookAhead'"
22:22:11 <Guest29009> And "Not in scope" in other three lines.
22:23:10 <Cale> Guest29009: hmmm
22:24:11 <Cale> Guest29009: ah, those have been removed from Data.Binary.Get for some reason...
22:24:22 <Cale> I wonder what to replace it with
22:24:31 <Guest29009> Maybe someone forget to make an "import" somewhere in the module? Or it's just me, making something wrong...
22:25:11 <Cale> Guest29009: no, it's that the function no longer exists in newer versions of the binary package
22:26:48 <cmccann> stepcut, man you're quick on the draw there
22:27:07 <Cale> cmccann: Do you know what happened to lookAhead in Data.Binary.Get?
22:27:16 <cmccann> I was totally gonna post something when it broke 10k :P
22:27:37 <cmccann> Cale, I have no idea, why are you asking me D:
22:27:49 <cmccann> I didn't break it I swear, it wasn't me
22:28:00 <Cale> I'm just asking you randomly because you're here :)
22:28:08 <cmccann> heh
22:28:23 <Cale> (and most Haskellers will probably come across Data.Binary from time to time)
22:28:37 <Guest29009> Sorry. I'm a newbie. How do I report this problem to the package maintainer?
22:28:40 <cmccann> I've been too distracted by other stuff lately
22:29:07 <Guest29009> The archive-zip package maintainer?
22:29:43 <Cale> the maintainer is listed as jgm@berkeley.edu
22:29:53 <Guest29009> Thanks.
22:30:02 <Cale> (on the main package page)
22:30:18 <cryptopsy> Cale: where's the documentation get placde?
22:30:59 <Cale> cryptopsy: ~/.cabal/share/doc/index.html
22:31:23 <Guest29009> RTF hackage page, right?  : )    Thanks. My mistake!
23:33:58 <Puffton> Using foldl, is there no way to stop the iterating once a certain condition is met?
23:34:30 <liyang> Puffton: perhaps you're looking for unfoldr.
23:35:28 <mparkes> I have a list of indexes which correspond to a list of values, what would be the best function to use to pull out the values with the given indexes?  filter?
23:37:22 <shachaf> Puffton: fold*l*?
23:37:27 <shachaf> What are you trying to do?
23:37:38 <mparkes> Map might work...
23:37:41 <shachaf> mparkes: You should provide an example with a question like that.
23:37:42 <RobMacKenzie> mparkes: map
23:37:51 <shachaf> Usually indexing and lists don't mix.
23:38:14 <RobMacKenzie> map (!! xs) [list of indexes]
23:38:28 <mparkes> values = [a,b,c,d,e,v,x,g,h]
23:38:29 <mparkes> Indexes = [0,5,2]
23:38:29 <shachaf> RobMacKenzie: (xs !!)
23:38:46 <RobMacKenzie> right you are
23:39:09 <shachaf> mparkes: You could do what RobMacKenzie said, but keep in mind that list indexing is inefficient and sometimes ugly.
23:39:11 <liyang> mparkes: map (flip $ IntMap.findWithDefault (error "oh noes!")) indices where m = IntMap.fromList (zip [0..] values)
23:39:11 <Puffton> shachaf, reading "Learn you a haskell for great good"
23:39:25 <Puffton> and came across foldl, figured it would be cool if the folding could be stopped at some point
23:39:42 <Puffton> For instance the implementation of elem using foldl uses a boolean accumulator
23:39:51 <Puffton> if it ever is True, it seems pointless to keep folding
23:39:55 <shachaf> Puffton: You should give an example and specify what the behavior you want is.
23:40:03 <shachaf> I think what you want is foldr, though.
23:40:07 <liyang> mparkes: I meant, map (IntMap.findWithDefault (error "oh noes!") `flip` m) indices where m = IntMap.fromList (zip [0..] values)
23:40:12 <shachaf> foldr is way more important than foldl.
23:40:12 <rwbarton> you wouldn't implement elem using foldl
23:40:13 <startling> yeah, sounds like foldr would do it
23:40:25 <shachaf> s/important/fundamental/
23:40:45 <RobMacKenzie> liyang: whoa
23:41:29 <Puffton> So what will foldr do if the last element in the list is the element we are looking for?
23:41:31 <liyang> Actually, Data.Vector would be even better.
23:41:50 <Puffton> Won't it just keep on folding until the first element?
23:41:50 <shachaf> Or Array.
23:42:07 <shachaf> liyang: Though none of these will work for an infinite list.
23:42:43 <liyang> shachaf: I rarely use Arrays, and that's an academic point.
23:43:37 <rwbarton> Puffton: lazy evaluation means that if the *first* element in the list is the element you're looking for then the rest of the fold will never be evaluated
23:43:53 <shachaf> liyang: What, the infinite list thing? I don't think that's academic.
23:44:03 <shachaf> Indexing into an infinite list is very common.
23:44:19 <liyang> shachaf: sure, in academia.
23:44:35 <Puffton> elem' y ys = (\x acc -> if x == y then True else acc) False ys
23:44:42 <Puffton> In this case, will it really stop, rwbarton?
23:44:46 <merijn> liyang: heh, why wouldn't people outside academia use that?
23:44:46 <lambdabot> merijn: You have 1 new message. '/msg lambdabot @messages' to read it.
23:44:48 <rwbarton> you accidentally the foldr?
23:45:18 <Puffton> I meant foldr :p
23:45:31 <Puffton> sorry
23:45:37 <rwbarton> then yes, naturally. if x == y then it will return True, no need to evaluate acc
23:45:39 <shachaf> Puffton: Why don't you try it?
23:46:04 <Puffton> shachaf, how will I know if it continues? should I put a print in there too?
23:46:18 <merijn> liyang: I use it quite frequently. Granted I'm in academia, but the code I'm writing is not particularly academic...
23:46:19 <shachaf> Puffton: Just run it on an infinite list.
23:46:27 * cmccann has no idea what academia has to do with anything here
23:47:27 * hackagebot binary 0.6.2.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.6.2.0 (LennartKolmodin)
23:47:39 <Puffton> Oh
23:47:42 <shachaf> > 'm' : "academia"
23:47:43 <Puffton> I didn't know it was that smart
23:47:44 <lambdabot>   "macademia"
23:47:47 <shachaf> Coïncidence?
23:47:59 <shachaf> Puffton: Smart?
23:48:04 <liyang> No, delicious.
23:48:21 <cmccann> shachaf, nah, you're nuts.
23:48:30 <shachaf> Haskell evaluation isn't particularly smart.
23:48:40 <rwbarton> nothing smart, just normal lazy evaluation
23:48:54 <Puffton> "If it was True, it stays that way as the rest of the list is folded up"
23:48:57 <Puffton> it said in the book
23:49:05 <Puffton> which I thought implied it would keep folding
23:49:06 <shachaf> By the way, if x then True else y === x || y
23:49:24 <shachaf> Puffton: You should learn to do reductions by hand.
23:49:34 <shachaf> It's the best way to figure out how something evaluates.
23:49:50 <shachaf> (And to understand laziness.)
23:49:58 <shachaf> cmccann: If I'm nuts, what does that make you?
23:50:23 <Puffton> shachaf, yeah it's pretty smart.. I mean what if I had written something that could potentially change the boolean value for coming elements
23:50:26 <cmccann> now that's an excellent question
23:51:19 <shachaf> Puffton: I think you're ascribing something to Haskell evaluation that it doesn't have.
23:51:38 <rwbarton> the description in the book is a little confusing
23:51:51 <shachaf> People tend to do that when they're learning about laziness. But there's no "magic" or special heuristics -- it's just a very simple rule.
23:52:22 <rwbarton> it describes the order of evaluation in a strict language, which is (mostly) fine for understanding what is being computed but not for understanding how
23:52:40 <rwbarton> the thing in foldr shouldn't really be called an "accumulator" at all
23:52:55 <rwbarton> from an operational point of view anyways
23:53:12 <shachaf> What *should* it be called?
23:53:19 <rwbarton> I don't know
23:53:26 <shachaf> Often I say foldr (\x xs -> ...), but "xs" is obviously wrong.
23:53:52 <Puffton> shachaf, yeah ok, it just seems to stop at the first True either way
23:54:24 <shachaf> What seems to stop?
23:54:25 <Puffton> I tried
23:54:26 <Puffton> let test ys = foldr (\x acc -> if odd x then True else acc) False ys
23:55:45 <Puffton> I figured for [2,3,4] it would go False, True, False… returning False :p
23:55:56 <Puffton> and for [2,3,5] it would go False, True, True… returning True
23:56:21 <Puffton> So ok, I overestimated it a bit
23:56:49 <rwbarton> I second shachaf's hand-reduction suggestion
23:56:55 <rwbarton> it looks like you are just looking at expressions and guessing
23:57:01 * shachaf can't figure out what Puffton's mental model of lazy evaluation is.
23:57:28 * cmccann decides that in (foldr (\x r -> ...)) the argument "r" is an accumulator traveling backwards in time, because it represents the accumulated result of the part you haven't done yet.
23:57:36 <liyang> expression — (magic black box) — output?
23:57:42 <shachaf> cmccann: Needs more continuations.
23:57:48 <rwbarton> so "r" for last letter of accumulator? :)
23:58:13 <Puffton> shachaf, my approach normally is to but my head on things 500 times
23:58:14 <shachaf> Accumulator, alligator!
23:58:17 <liyang> rwbarton: lator!
23:58:17 <Puffton> a brute force attempt
23:58:26 <Puffton> to attain knowledge
23:58:43 <shachaf> Puffton: I suspect there are better uses for your head.
23:58:45 <Puffton> butt*
23:59:30 <cmccann> shachaf, write the type as ([a] -> (Maybe (a, r) -> r) -> r) instead, now it looks all CPS-y
