00:15:38 <hpaste> “Lauri Lehmijoki” pasted “Simulating with Gloss – a simple example” at http://hpaste.org/76846
00:16:37 <hpaste> “Lauri Lehmijoki” annotated “Simulating with Gloss – a simple example” with “Simulating with Gloss – a simple example (annotation)” at http://hpaste.org/76846#a76847
00:18:17 <Ralith> ah, edwardk wrote one
00:18:18 <Ralith> of course
00:53:24 <cornihilio> why is haskell so good for writing parsers?
00:55:50 <Rogach> Hello! I'm new to haskell (wrote my first util today), so can somebody tell me if my code can be written in some better way? I pasted it here - http://pastie.org/5122533
00:59:03 <shachaf> Rogach: If you paste it on hpaste.org it'll give you some nice style suggestions. :-)
00:59:36 <jakubmal> hi guys
00:59:44 <jakubmal> any good reading on monad transformers?
01:01:46 <elliott> Rogach: You should probably use Data.Text, not ByteString, for representing Unicode text.
01:01:51 <elliott> Data.ByteString.UTF8 is a bit of a hack.
01:02:18 <elliott> Also, you should generally give all top-level declarations a type signature, and I suspect you can avoid that isPrefixOf duplication in sortImports, though I'm not sure how.
01:02:30 <elliott> Other than that it looks pretty good.
01:02:56 <elliott> Rogach: Though you shouldn't read the file in as ByteString (or Text) just to convert it to a String.
01:03:06 <elliott> You might as well just read it in as a String if you do that.
01:03:29 <Cale> elliott: He's reading and writing the same file
01:03:42 <Cale> elliott: So he's just using Data.ByteString for the strict I/O
01:03:48 <ion> Write to a temporary file and rename it over the old one?
01:03:58 <elliott> Cale: Right, but might as well use one of the actual strict IO packages if you want to do that :P
01:04:08 <Cale> ion: Yeah, that's typically a better option.
01:04:18 <elliott> Or just write the program with Text to start with if that's viable (possibly converting to String to use this System.FilePath.Find module.)
01:04:22 <shachaf> Data.Text has strict I/O too.
01:04:44 <Cale> Right, I agree about using Text
01:05:27 <shachaf> ((intercalate "\n" x) ++ "\n") is pretty similar to unlines x.
01:07:37 <Cale> (\a -> isPrefixOf "import" a) can be eta contracted to (isPrefixOf "import"), and similarly (\a -> not $ isPrefixOf "import" a) becomes (not . isPrefixOf "import")
01:08:08 <shachaf> Better infixify it too.
01:08:20 <shachaf> @let isn'tPrefixOf = not .: isPrefixOf
01:08:22 <lambdabot>  Defined.
01:08:24 <Cale> heh
01:08:43 <Cale> I disagree on that. Infixifying is kinda awkward here.
01:08:57 <shachaf> What, ("import" `isPrefixOf`)?
01:09:06 <shachaf> `isPrefixOf` is *meant* to be used infix.
01:09:22 <Cale> Well, you'd need an isn'tPrefixOf as you've already pointed out
01:09:24 <shachaf> If you read it non-infixly, it looks backwards: (is prefix of "import")
01:09:32 <shachaf> Right.
01:09:42 <shachaf> Thought you can say not . ("import" `isPrefixOf`)
01:09:44 <elliott> should rename isPrefixOf to hasPrefix
01:09:46 <elliott> hasPrefix "import"
01:09:47 <shachaf> s/t//
01:10:01 <elliott> it even works infix
01:10:05 * shachaf is a fan of infixing that comes out natural.
01:10:06 <elliott> sort of
01:10:10 <shachaf> elliott: No it doesn't. :-(
01:10:11 <elliott> oh it actually the opposite of works
01:10:11 <Rogach> elliott: I already asked about that on SO, and they settled on using ByteString and then converting. Or using Data.Text to get the same strict IO and get better efficiency.
01:10:35 <elliott> Rogach: Well, unless I'm seriously missing something, I don't agree with whoever answered your question on SO and would have answered it differently :P
01:11:45 <Rogach> shachaf: Does unlines add "\n" at the end?
01:12:00 <Rogach> shachaf: Ah, I see, it does.
01:12:01 <elliott> > unlines ["a","b"]
01:12:02 <lambdabot>   "a\nb\n"
01:12:05 <shachaf> Rogach: Yes, unless the list is empty.
01:15:40 <Rogach> Is it better to write "unlines $ sortImports $ lines input" or "(unlines . sortImports . lines) input"?
01:16:12 <shachaf> Rogach: The latter is nicer.
01:16:31 <shachaf> You can also say "unlines . sortImports . lines $ input" if you don't like the parentheses.
01:16:47 <elliott> Rogach: The latter has an advantage: you can make a function that abstracts the operation just by copying the a . b . c bit.
01:16:49 <Rogach> shachaf: Wow, great!
01:16:52 <elliott> (and sticking "foo =" in front of it)
01:17:38 <Rogach> Well, it's completely great - now my code is two times shorter.
01:17:58 <Rogach> Also, I was interested - is there some way to write the "main" method better in this case?
01:18:32 <Rogach> All those sequences and fmaps look horrible.
01:18:45 <shachaf> Rogach: If you pasted your code into hpaste, it would give you some suggestions. :-)
01:18:45 <elliott> Well, "fmap foo $ bar" is "foo <$> bar".
01:18:54 <elliott> And "sequence (map f xs)" is "mapM f xs".
01:18:57 <shachaf> For example, it would tell you that sequence (map f x) = mapM f x
01:18:59 <elliott> But yes, hpaste gives these recommendations.
01:19:12 <elliott> @hoogle concatMapM
01:19:12 <shachaf> (You can also get it standalone by installing hlint.)
01:19:13 <lambdabot> No results found
01:19:26 <elliott> Right, so you have to do concat <$> mapM ... or fmap concat $ mapM ..., no concatMapM.
01:19:28 <elliott> (That's a shame.)
01:19:33 <elliott> (or rather concatMap is a shame I guess)
01:19:38 <shachaf> (concat -> dirs) <- mapM ...
01:19:43 <shachaf> (Don't do that.)
01:19:52 <elliott> Rogach: (Similarly sequence_ (map f xs) is mapM_ f xs.)
01:20:14 <shachaf> hpaste would've told you that too. :-)
01:20:58 <Rogach> hpaste is awesome :)
01:21:22 <Rogach> Don't like the colors, though, but that doesn't matter a lot.
01:21:55 <shachaf> cabal install hlint to get it standalone.
01:22:35 <Rogach> shachaf: Is there some way to wire it up with runghc? So it would tell me those things when compiling.
01:22:58 <shachaf> Rogach: Not really. If you have a cabal project you can probably add it as a hook?
01:23:19 <Rogach> shachaf: As I said, it's my first Haskell day, so no cabal project :)
01:23:21 <shachaf> (But do compile with ghc -Wall to get some useful warnings.)
01:23:55 <Rogach> shachaf: Thanks, -Wall catched 5 errors :)
01:24:26 <Rogach> shachaf: But it warns about absent type signatures, which is annoying.
01:25:01 <Rogach> elliott: Where can I look up that "<$>"?
01:25:03 <shachaf> Rogach: You can disable that. But giving top-level things type signatures is a good habit. :-)
01:25:07 <shachaf> Rogach: Hoogle.
01:25:08 <shachaf> @where hoogle
01:25:09 <lambdabot> http://haskell.org/hoogle
01:25:46 <elliott> Rogach: It's annoyingly correct :P
01:30:21 <Rogach> hpaste also hinted on using break instead of span
01:36:34 <ion> @hoogle (<$>)
01:36:34 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
01:36:34 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
01:36:50 <ion> I always import it from Control.Applicative.
02:42:44 <Rogach> Would be "main = do getArgs >>= mapM_ putStrLn" the best way to print arguments to output?
02:43:25 <Rogach> Oh, "main = getArgs >>= mapM_ putStrLn" - 'do' is redundant.
02:49:14 <ion> or print =<< getArgs
03:17:54 <Rogach> ion: Well, "print =<< getArgs" looks unpretty and prints everything on one line.
03:26:30 <watermind> is there some shorter synonym for fromIntegral?
03:27:34 <watermind> could be worst, like  immersionOfValuesFromIntegralToNum
03:27:44 <watermind> but still :S
03:28:04 <watermind> makes simple formulas rather long
03:28:15 <Rogach> watermind: You can make your own shorter alias?
03:28:32 <watermind> Rogach: yes but then my code will be readable by me
03:28:53 <watermind> Rogach: was wondering if there was some standardish approach
03:30:00 <watermind> for instance I also thought of something like  (>*) n y = fromIntegral n * y    for binary operators
03:30:36 <Rogach> watermind: Well, hoogle doesn't seem to find anything better than fromIntegral :(
03:30:47 <watermind> requires a bunch of definitions, not a very general solution, and would live out plenty of unary functions
03:30:58 <watermind> but it would make some code look nicer
03:31:59 <watermind> (m >* y ) +< z  as opposed to  (fromIntegral m * y) + fromIntegral z
03:32:13 <watermind> but wouldn't help you with cos and sqrt and what not
03:32:40 * hackagebot aivika 0.4 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.4 (DavidSorokin)
04:13:20 <merijn> @hoogle (a -> b, c -> d) -> (a,c) -> (b,d)
04:13:20 <lambdabot> No results found
04:14:53 <merijn> bah, I have "a -> a -> a" and want to turn it into "(a,a) -> (a,a) -> (a,a)" (i.e. apply the function to both sides of the tuple)
04:16:18 <Rogach> merijn: a -> b -> c?
04:17:58 <fmap> merijn: `bilift2' from bifunctors might be relevant
04:18:32 <Rogach> @hoogle bilift2
04:18:32 <lambdabot> No results found
04:18:51 <Rogach> fmap: Where's that bilift2?
04:19:13 <fmap> @hoogle bilift2 +bifunctors
04:19:13 <lambdabot> Could not find some databases: bifunctors
04:19:13 <lambdabot> Searching in:
04:19:14 <lambdabot>   .
04:19:19 <fmap> i see
04:19:42 <fmap> Rogach: http://hackage.haskell.org/packages/archive/bifunctors/latest/doc/html/Data-Bifunctor-Apply.html#v:bilift2
04:23:15 <merijn> Rogach: Well, the alternative type signatures would be "a -> b -> c" and "(a,a) -> (b,b) -> (c,c)"
04:30:44 <merijn> Actually, I think the more practical (concrete) solution what I want is:
04:30:58 <merijn> :t join (***) concat . unzip
04:30:59 <lambdabot> forall a. [([a], [a])] -> ([a], [a])
04:33:51 <Rogach> merijn: Well, maybe I'm missing something, but maybe "\(a1,a2) -> \(b1,b2) -> (abc a1 b1, abc a2 b2)" will work?
04:34:37 <fmap> that's too readable
04:34:43 <Rogach> :)
04:35:03 <Rogach> I'm new to haskell, so I'm not skilled on producing unreadable code yet :)
04:35:29 <Rogach> fmap: What would be better way to write that?
04:36:13 <fmap> Rogach: honestly I think there isn't
04:46:11 <merijn> Rogach: Well, my version in the channel is a bit unreadable
04:46:36 <merijn> But I usually define "both = join (***)" (and am campaiging to get that in the standard libraries)
04:46:42 <merijn> And then it makes  a  bit more sense
04:46:48 <shachaf> @ty both
04:46:50 <lambdabot> forall t (f :: * -> *) a. (Applicative f) => (t -> f a) -> (t, t) -> f (a, a)
04:46:52 <shachaf> "the one true both"
04:47:01 <merijn> :t let both = join (***) in both concat . unzip
04:47:03 <lambdabot> forall a. [([a], [a])] -> ([a], [a])
04:47:12 <fmap> > [1,2,3] ^. _head
04:47:13 <lambdabot>   Not in scope: `_head'Not in scope: `^.'
04:47:17 <fmap> =(
04:47:21 <merijn> shachaf: Lies!
04:47:31 <shachaf> @let over l f = runIdentity . l (Identity . f)
04:47:33 <lambdabot>  Defined.
04:47:38 <shachaf> > over both (+1) (1,2)
04:47:40 <lambdabot>   (2,3)
04:47:47 <merijn> That's ugly :(
04:47:57 <shachaf> @ty runConst
04:47:59 <lambdabot> Not in scope: `runConst'
04:48:04 <shachaf> @ty Const
04:48:05 <lambdabot> forall a b. a -> Const a b
04:48:32 <shachaf> Hmm.
04:48:41 <shachaf> Oh, it's getConst.
04:49:30 <shachaf> @let toListOf l = getConst . l (Const . (:[]))
04:49:32 <lambdabot>  Defined.
04:49:34 <shachaf> > toListOf both (1,2)
04:49:36 <lambdabot>   [1,2]
04:49:40 <shachaf> > toListOf (both.both) ((1,2),(3,4))
04:49:42 <lambdabot>   [1,2,3,4]
04:50:02 <shachaf> > over (both.both) (+1) ((1,2),(3,4))
04:50:04 <lambdabot>   ((2,3),(4,5))
04:50:14 <shachaf> merijn: Let's see your both do that!
04:50:24 <merijn> It doesn't have to...
04:50:38 <shachaf> ...That's a pretty good argument.
04:50:49 <shachaf> This namespace ain't big enough for the two of us.
04:51:00 <merijn> Also, I'd like to see you use that both to combine netwire arrows :p
04:51:08 <shachaf> Arrows are the devil anyway.
04:51:44 <merijn> Somehow some of my "first draft" haskell code ends up very ugly...
04:51:49 <shachaf> > over (traverse.both) toUpper [('a','b'),('c','d'),('e','f')]
04:51:50 <lambdabot>   Not in scope: `traverse'
04:52:01 <shachaf> > over (Data.Traversable.traverse.both) toUpper [('a','b'),('c','d'),('e','f')]
04:52:03 <hpaste> merijn pasted “pretty show code :p” at http://hpaste.org/76851
04:52:03 <lambdabot>   [('A','B'),('C','D'),('E','F')]
04:52:26 <merijn> Look at that beautiful code >.>
04:53:15 <ion> You could use ShowS
04:53:34 <shachaf> > over (Data.Traversable.traverse . _2) toUpper [('a','b'),('c','d'),('e','f')]
04:53:37 <lambdabot>   [('a','B'),('c','D'),('e','F')]
04:53:47 <merijn> ion: I need to drastically simplify it anyway
04:53:47 <shachaf> merijn: Who writes Show code by hand these days?
04:54:02 <shachaf> It's the devil.
04:54:19 <shachaf> Are you going to make a matching Read instance?
04:56:32 <merijn> shachaf: Of course :p
05:15:50 <Jafet> Has Reflection actually been used to do the stuff in the reflections paper?
05:17:52 <hpaste> Jafet pasted “ZZZ” at http://hpaste.org/76852
05:19:59 <elliott> Jafet: which stuff was that again?
05:20:26 <elliott> I don't think reflection gets that much use in practice, though I think that floating-point thingy binding copumpkin and edwardk (I think?) were working on used it
05:20:31 <elliott> (no reason it shouldn't, though)
05:20:59 <elliott> Jafet: you do not need the ZZModulus type there, by the way
05:21:06 <elliott> can just say s `Reifies` a
05:21:17 <Jafet> You're right
05:21:26 <Jafet> But but, type safety dude
05:22:04 <elliott> Jafet: well, you can think of it as ZZ :: (Integral a) => (a :: *) -> a -> *, or such
05:22:10 <Jafet> You're asking what was in the paper? Mod arithmetic, program configuration and some other thing
05:22:28 <elliott> (I suggest (ZZ s a) so you can have a Functor instance... there is a code example of this in the reflection distribution iirc... or was that another one)
05:22:46 <elliott> Jafet: here is an example I wrote that uses reflection for program configuration, if you are interested http://hpaste.org/66715
05:23:05 <Jafet> Yay
05:24:27 <Jafet> I wonder why it doesn't get that much use in practice
05:25:44 <elliott> Jafet: probably because ReaderT is much more commonly-used and handles most of the same situations... or just because it can be somewhat tricky to understand at first (like, it can seem like you need to pass around the proxy argument you get everywhere, because it's not intuitively obvious that all the information gets transferred to the type, so it's not clear what you gain)
05:25:56 <elliott> (and nobody's bothered to write an accessible explanation of it)
05:26:18 <elliott> and possibly some people are put off by the fact that a standard Haskell implementation if it involves using the FFI/unsafePerformIO (though only in safe ways)
05:26:20 <Rogach> Q: How does one compile .hs file? I tried "ghc sort-imports.hs", but got two pages of "undefined reference ..." and exit status 1.
05:26:29 <Jafet> Well, you do have to carry the phantom type around
05:26:35 <Rogach> It runs with runghc without any problem.
05:26:37 <elliott> Rogach: try ghc --make sort-imports.hs (if that works it's a sign that your GHC is old though)
05:26:37 <Jafet> That could be inconvenient
05:26:59 <Rogach> elliott: It is - 6.12.
05:27:01 <elliott> (actually I am partially to blame for the fact that reflection's default implementation is even scarier -- unsafeCoerce-based)
05:27:05 <Rogach> elliott: Thanks, that worked!
05:27:05 <elliott> Rogach: yow
05:27:08 <elliott> Rogach: you should really fix that :)
05:27:39 <elliott> Jafet: right, though you do in a sense with Reader as well
05:28:00 <Rogach> elliott: Only when I would be fully reinstalling my machine, and that would happen right after new year. I use Ubuntu 10.10, so updates are not coming to me :)
05:28:02 <elliott> (compare "Reader Foo a" to "(Reifies s Foo) => ... MyType s a", where MyType could even just be Tagged or whatever)
05:28:23 <elliott> Rogach: well, I would generally recommend against using most distro packages of GHC unfortunately :/
05:28:30 <Rogach> elliott: Why?
05:28:35 <Jafet> Could you explain this Tagged thing
05:28:44 <elliott> Jafet: data Tagged s a = Tagged a
05:28:49 <elliott> it's just there to carry the type
05:28:51 <Jafet> Funky
05:29:00 <elliott> though it's a pain to use in practice i suggest "Proxy s -> a" instead... like reflection actually gives you
05:29:38 <elliott> Rogach: their tendency to be fairly out of date (and GHC advances quickly) combined with the ease in which you can get into bad Cabal situations like http://www.vex.net/~trebla/haskell/sicp.xhtml describes
05:29:45 <elliott> (the unsafeInterleaveInstall part, in particular)
05:29:52 <Jafet> I guess I still have to write data EllipticCurve s = EC (ZZ s Integer) (ZZ s Integer)
05:30:00 <Jafet> Because there's no type safety otherwise
05:31:02 <Rogach> elliott: Well, I'll think about that, but I probably won't be using very new features anyway - and if I would build ghc from sources every time, I would get into much trouble trying to sync that across all my machines.
05:31:12 <elliott> Jafet: right. but that is actually a good thing, IMO: it means that you can't mix up two EllipticCurves with different moduluses!
05:31:16 <Jafet> Hm, or data EC a = EC a a
05:31:24 <Jafet> Looks a bit neater
05:32:38 <elliott> Rogach: fair enough... still, there have been some quite major changes to type-checking and so on since 6.12, and there is of course the matter of bugfixes... if you are just writing strictly haskell-standard-compliant code then it shouldn't affect you, but that's quite an unlikely thing to be doing, since basically all the common libraries depend on a few common, widely-accepted extensions
05:32:49 <elliott> (and it sure would be nice if those extensions were properly standardised...)
05:34:06 <Rogach> elliott: Reading that link - am I right that if I would be using only cabal-install for all the haskell stuff, I would be on the safe side?
05:34:32 <Jafet> If you use only cabal-install --user, and follow some other rules
05:34:47 <Jafet> Hm, should ZZ be Integral (being integers), or Fractional (being a field (or similar to one)), or both?
05:35:28 <elliott> Rogach: right. if the only thing you get from your distribution is GHC and you install all your libraries through cabal-install then you should be fine
05:36:12 <elliott> I don't know what kind of package versions you'll even get if you try to install stuff with 6.12, though I think some people still support it
05:36:21 <elliott> if it works for you then it works for you and no need to worry, of course
05:37:00 <elliott> Jafet: probably both... not like the classes have laws to speak of
05:37:47 <Jafet> It's funny that more than half of my Integral instance is undefined.
05:38:46 <elliott> that sounds like a bad sign then :)
05:39:09 <Jafet> I can't think of any sensible way to div in Z/nZ
05:39:46 <Jafet> And it prevents you eg. somehow defaulting to ZZ for (^) (which is mathematically wrong)
05:39:58 <Jafet> For the exponent to (^)
05:40:02 <elliott> right. perhaps you shouldn't make it Integral, then :)
05:41:27 <Jafet> I should totally use dependent typing to provide a Fractional instance only if the modulus has a field
05:54:35 <fmap> Does second functor law have a name?
05:55:51 <Polarina> fmap, composition, I believe.
06:09:19 <fmap> Polarina: thanks
06:42:44 * hackagebot dates 0.2.1.1 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.2.1.1 (IlyaPortnov)
06:47:44 * hackagebot dates 0.2.1.2 - Small library for parsing different dates formats.  http://hackage.haskell.org/package/dates-0.2.1.2 (IlyaPortnov)
06:47:46 * hackagebot crf-chain1-constrained 0.1.0 - First-order, constrained, linear-chain conditional random fields  http://hackage.haskell.org/package/crf-chain1-constrained-0.1.0 (JakubWaszczuk)
06:52:44 * hackagebot stylish-haskell 0.5.3.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.3.0 (JasperVanDerJeugt)
06:57:30 <Rc43> Hi, guys.
06:58:34 <Spooner> Hi, I'm new to Haskell (but experienced coder). I'm trying to work through some problems with Haskell, but I want to do it with TDD. Simple problem I'm having is that I can't see how to put a series of tests into my scripts with my functions. Don't need a full test suite; something like "frogTree 5 == 9 || raise" type assertions would be fine. Any suggestions?
07:00:24 * nand` forgets what the haskell libraries for unit testing were called
07:00:27 <nand`> one of them was hUnit, I think
07:01:01 <Iceland_jack> Is it possible to do without a library?
07:01:13 <mauke> yes, write the library yourself
07:01:19 <nand`> well, yes
07:01:33 <nand`> write a function test :: Eq a => [(a, a)] -> IO ()
07:01:42 <nand`> or perhaps add a String to name them
07:02:20 * nand` wonders, can TH be leveraged to ‘show’ the Haskell source of the test into a String at compile time?
07:02:29 <nand`> in addition to including it
07:03:03 <Ghoul> # let fn (x,y) = x == y in fn 3 4
07:03:21 <Ghoul> !
07:03:27 <Ghoul> lambdabot:
07:03:37 <Ghoul> What's the deal with lamda today
07:03:50 <nand`> none of those are recognized by lambdabot
07:03:59 <Ghoul> What's the prefix
07:04:01 <Ghoul> I forgot :C
07:04:01 <nand`> > let fn (x,y) = x == y in fn 3 4
07:04:03 <lambdabot>   Couldn't match expected type `t1 -> t'
07:04:03 <lambdabot>         against inferred type `GHC.B...
07:04:10 <nand`> uh
07:04:13 <nand`> > let fn (x,y) = x == y in fn (3,4)
07:04:14 <lambdabot>   False
07:04:24 <Ghoul> > let fn (x,y) = x == y in fn (3,3)
07:04:25 <lambdabot>   True
07:04:28 <Ghoul> aww yeah.
07:04:36 <Ghoul> I'm slightly above supernewb :o
07:04:38 <nand`> let fn = uncurry (==)
07:04:51 <Ghoul> Whaat
07:04:57 <Ghoul> No, head, explosion
07:04:59 <Ghoul> Urgh
07:05:06 <Iceland_jack> WHy would you want to use that instead of just (==)
07:05:08 <nand`> :t uncurry
07:05:09 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:05:20 <nand`> Iceland_jack: presumably to map it over a list [(a,a)]
07:05:34 <Iceland_jack> then uncurry away
07:06:11 <Ghoul> join " " ("Iceland_jack","because","I","can")
07:06:16 <Ghoul> > join " " ("Iceland_jack","because","I","can")
07:06:17 <lambdabot>   Couldn't match expected type `[a]'
07:06:17 <lambdabot>         against inferred type `GHC.Types...
07:06:21 <Iceland_jack> ...
07:06:27 <Ghoul> > join " " ["Iceland_jack","because","I","can"]
07:06:28 <lambdabot>   Couldn't match expected type `[a]'
07:06:29 <lambdabot>         against inferred type `GHC.Types...
07:06:34 <Ghoul> > join ["Iceland_jack","because","I","can"]
07:06:35 <lambdabot>   "Iceland_jackbecauseIcan"
07:06:41 <Ghoul> what the hell
07:06:44 <nand`> join = concat for lists
07:07:04 <arcatan> @type intercalate
07:07:05 <lambdabot> forall a. [a] -> [[a]] -> [a]
07:07:08 <Iceland_jack> > intercalate " " ["Iceland_jack","because","I","can't"]
07:07:09 <lambdabot>   "Iceland_jack because I can't"
07:07:31 <Ghoul> > foldl1 $ map (\x->x++" ") ["Iceland_jack","because","I","can"]
07:07:33 <lambdabot>   Couldn't match expected type `a -> a -> a'
07:07:33 <lambdabot>         against inferred type `[...
07:07:39 <Ghoul> > foldl1 (++) $ map (\x->x++" ") ["Iceland_jack","because","I","can"]
07:07:42 <lambdabot>   "Iceland_jack because I can "
07:07:57 <Iceland_jack> ;) trailing whitespace?
07:08:04 <Ghoul> er hm
07:08:12 <Ghoul> > trim $ foldl1 (++) $ map (\x->x++" ") ["Iceland_jack","because","I","can"]
07:08:13 <lambdabot>   Not in scope: `trim'
07:08:15 <nand`> you could use foldr (++) [] instead of foldl1 (++); which incidentally enough is equal to ‘concat’
07:08:22 <nand`> (the former is more efficient and safer)
07:08:58 <Ghoul> is foldr faster than foldl
07:09:10 <nand`> depends
07:09:15 <Ghoul> I thought anything that started from the left was faster because haskell lists are linked
07:09:24 <Iceland_jack> But it's lazy
07:09:44 <nand`> foldr is lazy, foldl isn't
07:09:56 <Iceland_jack> ah
07:10:09 <Ghoul> anyhow
07:10:14 <nand`> (foldl immediately recurses into itself with the tail of the list and then pattern matches on its argument)
07:10:15 <Ghoul> 1:09am sleepy
07:10:17 <Ghoul> night
07:12:49 <mauke> everything starts from the left
07:27:20 <Zariel> Is there a way i can one line the hClose with the above line? https://gist.github.com/40bbae8d965bc17b6725
07:28:41 <byorgey> Zariel: I mean, you could always  ((execute .  ...   >>= printStack) >> (x >>= hClose)
07:28:45 <byorgey> but why would you want to do that?
07:29:02 <Zariel> yeah i figured that but it doesnt really make it any better
07:29:04 <Zariel> i guess ill leave it
07:29:32 <nand`> that being said, your line 3 is fairly unreadable; are you sure it isn't better to write it out?
07:30:16 <nand`> (and is it correct to re-run the IO Handle?)
07:31:55 <Zariel> what do you mean re-run ?
07:32:15 <nand`> you're binding ‘x’ twice; once to hGetContents and once to hClose
07:32:38 <nand`> so if ‘x’ has side-effects; they'd appear twice
07:34:11 <Zariel> it can be written like this, https://gist.github.com/40bbae8d965bc17b6725
07:34:18 <Zariel> but having that bind at the top looked, ugly?
07:35:13 <byorgey> it's not a quiestion of how it the meaning is actually different
07:35:33 <byorgey> in the first one, x will be run twice; in the second that you just posted, x will only be run once
07:35:46 <mauke> Spooner: I just hacked up a minimal TAP module. wanna test it? :-D
07:36:04 <byorgey> if x can return a different handle every time it is run then running it twice is almost certainly wrong.
07:36:22 <byorgey> *"It's not a question of how it looks, the meaning..."
07:36:51 <hpaste> nand` pasted “run (annotation)” at http://hpaste.org/76855
07:37:08 <Spooner> mauke : Well, I looked at HUnit, but cabal isn't wanting to install it. QuickCheck seems to be included as Standard, so I'm trying to get my head around that. What do you mean by a TAP module?
07:37:19 <byorgey> Zariel: also, what you just posted looks the nicest to me.  Perhaps your perception of "ugly" needs to be adjusted ;-)
07:38:02 <Zariel> hm i guess I do :)
07:38:09 <nand`> surely the hGetContents and hClose should be factored out into some of the ‘bracket’-like constructs
07:38:13 <Zariel> where is that tool which un-sugars do blocks to the >>= notation?
07:38:17 <nand`> in no small part due to recovering in case of errors
07:38:27 <nand`> @undo do { a <- b; c <- d; e a c }
07:38:28 <lambdabot> b >>= \ a -> d >>= \ c -> e a c
07:39:03 <Zariel> id forgotten about bracket, ill add that
07:41:25 <mauke> Spooner: TAP is a simple protocol for writing tests
07:42:07 <Spooner> mauke : I can give it a go.
07:42:39 <Spooner> mauke : Seems I misunderstood what QuickCheck did and cabal is taking forever to update so I can install HUnit :/
07:42:55 <hpaste> nand` annotated “run (annotation)” with “run (annotation) (annotation)” at http://hpaste.org/76855#a76858
07:42:57 <nand`> here's a one-liner
07:43:25 <hpaste> mauke annotated “tapper.hs” with “TAP.hs” at http://hpaste.org/76857#a76859
07:43:40 <mauke> Spooner: ^ that's my code
07:43:53 <mauke> it's super primitive
07:44:08 <nand`> it just occured to me that ‘isn't’ is a valid function name
07:44:13 <mauke> oh, and I tested it with 'prove -e runghc tapper.hs'
07:46:20 <mauke> oops, I should fix the test names
07:46:33 <mauke> the interface is inspired by https://metacpan.org/module/Test%3A%3AMore#DESCRIPTION
07:46:43 <Spooner> mauke : OK, thanks, I'll take a look at it.
07:46:52 <mauke> https://metacpan.org/module/prove#NAME is a tool for running TAP tests
07:48:36 <hpaste> mauke annotated “tapper.hs” with “TAP.hs (annotation)” at http://hpaste.org/76857#a76860
07:49:53 <Zariel> nand`: thanks, >=> is a new one
07:50:09 <nand`> oh no, I just helped you golf things into oblivion, didn't I?
07:50:53 <Zariel> :)
07:50:59 <Spooner> If I have to install external tools to use TAP, I'm not convinced it is simpler to use than HUnit installed via cabal (which has finally finished fiddling with itself) ;)
07:51:06 <Zariel> ill leave as is, maybe introduce bracket somewhere :)
07:52:12 <mauke> Spooner: well, you can just run it
07:52:19 <mauke> you won't get pretty output, though
07:52:25 <mauke> Spooner: what OS are you on?
07:53:06 <Spooner> mauke : The "wrong one" (I have a Lubuntu VM, but easier to stick native if I can).
07:53:30 <Jafet> @hoogle acme-dont
07:53:31 <lambdabot> package acme-dont
07:53:37 <Jafet> @hackage acme-dont
07:53:37 <lambdabot> http://hackage.haskell.org/package/acme-dont
07:53:52 <mauke> Spooner: VMS?
07:54:04 <Jafet> Hey, the module isn't named Don't.
07:54:23 <Spooner> mauke : Virtual Machine. Windows is my native OS at the mo.
07:55:00 <Jaxan> can someone help me with this: http://ideone.com/PIVHvm#view_edit_box ?
07:55:30 <Rc43> Anybody used "vty"?
07:55:38 <Rc43> I can't run test example from its source.
07:55:58 <mauke> Spooner: http://en.wikipedia.org/wiki/OpenVMS
07:56:07 <Rc43> I get error "Terminal does not define required capability "cnorm"".
07:56:16 <mauke> (that would be the "wrong one")
07:56:28 <Rc43> Even if I use `tput cnorm` before launch.
07:56:33 <Spooner> mauke More wrong than Windows? Surely not :D
07:58:31 <Jaxan> Oh I actually have: http://ideone.com/o5eAiS , why doesn't the compiler just pick the instance Foo a a ?
07:58:47 <byorgey> Jaxan: because there might be other instances defined in other modules
07:58:56 <geekosaur> Rc43: that could happen if it linked against a curses that uses terminfo but your 'tput' uses termcap, or vice versa (or is using a different terminfo, which can happen confusingly in some cases)
07:59:05 <Jaxan> byorgey: How can I tell him to pick that one?
07:59:09 <byorgey> it only picks an instance if it *must* be the right instance, not if it *can* be the right one
07:59:16 <geekosaur> in short, it usually means something complicated has gone wrong
07:59:17 <Jaxan> ok, that explains
07:59:18 <byorgey> Jaxan: you could add a functional dependency
07:59:26 <byorgey> though that may or may not be what you intend
07:59:34 <byorgey> class Foo a b | a -> b where ...
07:59:48 <byorgey> that means a will always determine b, i.e. for any given type a there can be only one instance
07:59:58 <Jaxan> I also have the case "where (_,y) = ...", so that won't work right?
08:00:26 <byorgey> I'm not sure.  sorry, I actually have to run
08:00:33 <Rc43> geekosaur, reinstalling somthing can help?
08:00:39 <Jaxan> byorgey: thanks anyways :)
08:01:13 <geekosaur> Rc43, not clear.  cabal has probably done the best it can but is being confused by something at the level of C libraries, is what it comes down to
08:01:42 <geekosaur> I could porbably diagnose it if the system were in front of me, but I'm less certaon about coaching someone else through it remotely
08:02:21 <Rc43> geekosaur, I mean reinstalling somthing from system; btw, it is fresh ubuntu server
08:02:47 <geekosaur> hrm.  that makes it odder, you should not have conflictling libraries in that case
08:02:51 <rwbarton> Jaxan, what do you mean 'the case "where (_,y) = ..."'
08:03:25 <Rc43> geekosaur, may be I have installed bad curses packages; I installed several of them, could cabal use one, which is not appropriate?
08:03:28 <Jaxan> rwbarton: let me first see if the thing byorgey suggests works
08:03:41 <rwbarton> it ought to work for your program as pasted, I believe
08:04:02 <Jaxan> yes, but my real problem is a bit more subtle (maybe)
08:04:07 <Jaxan> it turns out it already works :)
08:04:10 <geekosaur> Rc43, yes, that's conceivable, but I would expect them to be marked as incompatible with each other usually.  what version of ubuntu is this?
08:05:14 <Rc43> geekosaur, 12.10
08:05:30 <nand`> it works if you add ScopedTypeVariables and define test = (fst :: (a, a) -> a) . bar
08:05:39 <beaky> hello
08:05:55 <beaky> what is the difference between currying and partial function application?
08:06:33 <monochrom> currying describes the function. partial function application describes the application
08:06:34 <nand`> currying is a method of turning a function accepting tuples into a function that returns another function
08:06:51 <nand`> there's really no such thing as ‘partial function application’; every function is applied
08:06:58 <nand`> (when you apply it, I mean)
08:07:13 <beaky> right
08:07:23 <rwbarton> partial application means applying a "function of multiple arguments" (whatever that means to you) to only some of its arguments leaving a function that expects the remaining arguments
08:07:35 <Rc43> geekosaur, does terminfo provide any executables?
08:08:34 <Spooner> mauke : The normal output of TAP.hs looks fine actually. 'prove' presumably just adds colours and a summary?
08:08:35 <geekosaur> Rc43, I don't know offhand for ubuntu but typically the executables are tic, infocmp, and tput
08:09:26 <beaky> how do you uncurry a function?
08:09:38 <ion> @type uncurry
08:09:40 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
08:09:46 <Rc43> geekosaur, yea, there are such exes
08:09:50 <ion> @src uncurry
08:09:50 <lambdabot> uncurry f p = f (fst p) (snd p)
08:09:52 <monochrom> "f o" is a partial application because I haven't finished writing it, and finished it will be "f ô". :)
08:09:56 <beaky> uncurry (\x -> \y -> x * y)
08:10:02 <beaky> > uncurry (\x -> \y -> x * y)
08:10:02 <ion> lambdabot: Eh, that’s a stupid definition.
08:10:03 <lambdabot>   Overlapping instances for GHC.Show.Show ((b, b) -> b)
08:10:03 <lambdabot>    arising from a use...
08:10:03 <monochrom> s/and/when/
08:10:23 <Rc43> geekosaur, does it affect if I am working through SSH?
08:10:25 <geekosaur> also I'm not seeing mu;ltiple versions of curses in the package  list for quantal... admittedly that doesn't show any external repos ("universe")
08:10:32 <Rc43> geekosaur, I mean real terminal
08:11:07 <geekosaur> only to the extent that $TERM is more likely to be set to something that isn't the system default, which would make divergent curses packages more obvious
08:11:21 <nand`> > let uncurry f (x,y) = f x y in uncurry (+) (3,4)
08:11:23 <lambdabot>   7
08:11:47 <nand`> ion: agreed
08:11:59 <Rc43> geekosaur, eeeeeem; yeah `echo $TERM` gives "cygwin"; it seems it is the problem
08:12:07 <geekosaur> ...yeek.
08:12:12 <mauke> Spooner: two sample runs: http://i.imgur.com/uII86.png
08:12:25 <dolio> How do you know which definition is the stupid one?
08:12:42 <monochrom> wait, what? cygwin on ubuntu? :)
08:12:51 <Rc43> geekosaur, ok, so I try to adjust my real terminal somehow
08:12:54 <geekosaur> monochrom, Rc43 is ssh-ed into an ubuntu
08:13:04 <monochrom> I see
08:13:14 <geekosaur> you might try running the example with 'env TERM=vt100 ' in front of the command
08:13:38 <nand`> mauke: what does the example you're running look like?
08:13:39 <geekosaur> I don';t know if cygwin's terminal is vt100 compatible offhand but it's the typical lowest common demnominator these days
08:13:51 <mauke> nand`: see the hpaste link
08:13:57 <geekosaur> and I find it difficult to believe they emulated a vt52 or wyse50 or something...
08:14:00 <beaky> :t uncurry (\x -> \y -> x * y)
08:14:02 <lambdabot> forall b. (Num b) => (b, b) -> b
08:14:08 <beaky> :t (\x -> \y -> x * y)
08:14:10 <lambdabot> forall a. (Num a) => a -> a -> a
08:14:14 <nand`> oh, at the top; missed it, thanks
08:14:15 <beaky> ah
08:14:27 <monochrom> there is no stupid definition :)
08:14:30 <Rc43> geekosaur, don't work
08:14:38 <Rc43> *doesn't
08:15:26 <Spooner> mauke : Found someone else's tap with a slightly different API for comparison: http://testanything.org/wiki/index.php/HaskellTapModule
08:15:29 <geekosaur> Rc43, a recommendation I'm seeing is to install cygwin's rxvt which gives you a terminal that linux usually knows what to do with
08:15:36 <Rc43> geekosaur, ha; env TYPE=wyse50 gives another error (capability "setaf")
08:16:04 <nand`> beaky: \x -> \y -> x * y  =  \x -> (*) x  = (*)
08:16:05 <Rc43> geekosaur, can't I install terminfo on cygwin and tput required capabilities?
08:16:36 <Rc43> geekosaur, hm, terminfo is installed ...
08:16:39 <geekosaur> ... that's somewhere between brave and foolhardy, you know?  (using the wrong $TERM can do very ugly things; one of the reasons everyone uses vt100 as a base is it's slightly les slikely to do that)
08:16:53 <geekosaur> Rc43, nothing you do on your end will help
08:17:13 <geekosaur> theprogram is querying the terminfo database on the linux machine to see how to talk to your terminal
08:17:44 <geekosaur> if it doesn't know anyting about cygwin's terminal, how much *cygwin* knows about the terminal is not relevant; you need to teach *linux* about it
08:18:04 <Rc43> geekosaur, ok, understood
08:18:31 <rwbarton> i missed the start of this conversation but can you try using putty?
08:18:40 <beaky> so currying is very handy
08:18:51 <beaky> why isn't it the default in other programming languages?
08:19:01 <geekosaur> because it can be confusing
08:19:19 <shurikas> and because other languages suck
08:19:22 <beaky> ah
08:19:23 <rwbarton> it puts more demands on the implementation too for efficiency
08:19:24 <gripau> hi guys
08:19:24 <monochrom> because once upon a time mathematicians did not think of higher-order functions
08:19:51 <monochrom> when some of them finally did (Landin), they wrote like "f(x)(y)(z)"
08:19:53 <rwbarton> i seriously doubt that there were programming languages with currying before mathematicians thought about higher-order functions
08:20:45 <monochrom> sure, but most language authors look only at 200-year old mathematics
08:21:44 <monochrom> for example BASIC did not let you have boolean variables
08:21:54 <dolio> So we've got 100 years to go for currying?
08:22:04 <beaky> wish I could make all my functions curried in other languages, but then my code will look like do_foo(x)(y)(z)
08:22:17 <beaky> not clean like haskell's doFoo x y z
08:22:35 <shurikas> I bet it would be clean if it supported currying
08:22:45 <shurikas> well, scala isn't clean though
08:22:55 <Spooner> beaky : For example, in Ruby, you can now manually curry a method, but they couldn't make currying standard, since it would break old code that assumed methods worked in a different way.
08:23:05 <beaky> ah
08:23:11 <Minoru> mandatory parentheses would still prevent it from being clean enough, IMO
08:23:36 <Rc43> geekosaur, rxvt works
08:23:48 <dolio> Also it'd probably be significantly slower in most languages, unless they did a lot of work on the compiler.
08:23:53 <dolio> Assuming they even have one.
08:24:01 <beaky> why is currying efficient in Haskell though?
08:24:08 <beaky> or other functional languages with autoatic currying*
08:24:14 <beaky> automatic*
08:24:21 <dolio> Because people did work on the compiler to make it so.
08:24:26 <beaky> ah
08:25:13 <Spooner> I assume because it was designed from the start to work that way. You can hack other languages to do it, but that would be from inefficient to impossible to do ;)
08:26:10 <beaky> let f(x) = x*x in f(3)
08:26:13 <beaky> > let f(x) = x*x in f(3)
08:26:15 <lambdabot>   9
08:26:45 <beaky> @pl \x -> x*x
08:26:46 <lambdabot> join (*)
08:26:52 <beaky> :t join
08:26:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:26:57 <monochrom> if you have f :: Int -> Int -> Int, and I use it as "f x y", that's just like "f(x,y)" in other languages, and the compiler can just do the simple thing
08:27:33 <monochrom> only when I use "f x" does the compiler have to really consider higher-order functions
08:28:04 <Rc43> geekosaur, just env TERM=xterm works, too (guys from #cygwin said me that)
08:28:05 <nand`> every higher order language ‘supports currying’
08:28:12 <nand`> it just looks ugly or is inefficient in many
08:28:31 <geekosaur> interesting, I wonder if ubuntu no longer installs the vt100 entry or somehting
08:28:40 <nand`> is inefficient in many implementations, I mean; though sometimes the language semantics themselves permit corner cases that break certain optimizations
08:28:49 <geekosaur> since it should have worked to some extent (although, hm ,youmentioned setaf and that won't be supported)
08:28:50 <beaky> it looks extremely ugly in C++ :D
08:29:08 <nand`> C++ is a higher order language?
08:29:09 <typoclass> beaky: what doesn't :)
08:29:44 <beaky> C++ has first-class objects; objects may overload operator() (function call) :D
08:29:48 <nand`> ah
08:30:07 <nand`> well, even C is trivially higher order due to presence of a top type
08:30:10 <nand`> void*
08:30:21 <beaky> so even C is higher order? :D
08:30:23 <mauke> void * is not top
08:30:34 <nand`> it isn't?
08:30:50 <nand`> maybe I have misconceptions of what a ‘top type is’; a type that permits every possible value?
08:31:01 <mauke> have you ever tried to store a string in a void *?
08:31:03 <mauke> or a double?
08:31:08 <mauke> or a FILE?
08:31:14 <mauke> or a char?
08:31:34 <nand`> I thought you could do that. Maybe I should stop pretending I know a thing about C
08:31:45 <mauke> you can't do any of the above
08:31:48 <Rc43> geekosaur, but under rxvt and Console2 (windows term emulator) behaviour is different
08:32:00 <Rc43> geekosaur, it seems Console2 works incorrectly with it
08:32:38 <geekosaur> what $TERM is Console2 using?  (and does linux know about it and how buggy is its emulation?)
08:33:11 <beaky> you can implement a haskell interpreter in C. Haskell is higher-order. therefore, C is higher-order ^^
08:33:27 <beaky> </flawedlogic>
08:33:37 <Rc43> jon_y, or rxvt
08:33:50 <Rc43> geekosaur, or rxvt
08:40:26 <bartavelle> I am writing some game, and would like to write functions that take two entities as argument, compute stuff, and alter their state. The problem is that there can be tons of entities in my state and I do not want to look them up all the time. Are lenses what I am looking for ?
08:43:21 <jmcarthur> bartavelle: i would like to call your attention to the existence of #haskell-game :)
08:43:33 <jmcarthur> bartavelle: but i can still answer your question here
08:44:03 <plat0> http://web.jaguarpaw.co.uk/~tom/blog/2012/10/27/why-are-these-simple-text-processing-programs-so-much-faster-than-in-c.html
08:44:14 <jmcarthur> bartavelle: what is it you are wanting to save? programmer time or computation time?
08:44:14 <bartavelle> oh i didn't knew this existed
08:44:22 <bartavelle> readability
08:44:38 <plat0> ^^ anyone who wants to give me feedback on my response to the reddit "Haskell can't capitalize words quickly" farce is welcome :)
08:44:47 <bartavelle> it is not game specific, I suppose it happens every time you have a state made of multiple things
08:45:00 <jmcarthur> bartavelle: lenses isn't crazy for this
08:45:48 <bartavelle> a specific example is having to compute the results of a creature trying to attack another, whereas in my state i have several creatures, and possible other stuff
08:45:48 <jmcarthur> bartavelle: but i'm not sure exactly what boilerplate you're wanting to get rid of, so i'm not certain. i'm guessing you have some sort of nested record for your state? if so, yes, lenses make sense
08:46:01 <bartavelle> i'd like to write functions like
08:46:02 <beaky> how efficient are iorefs?
08:46:22 <Jafet> IORefs are pointers.
08:46:30 <jmcarthur> beaky: they allow real mutation. pretty efficient
08:46:31 <bartavelle> attack :: Creature -> Creature -> (Creature, Creature)   <- this is easy to do, but what i would like is
08:46:41 <bartavelle> attack :: Creature -> Creature -> State ()
08:46:52 <bartavelle> where the state of both creatures is automatically put back into the state
08:47:05 <beaky> http://ideone.com/XcFwYZ (Haskell) vs http://ideone.com/ScPkzL (C), why is the Haskell version far more inefficient?
08:47:10 <jmcarthur> bartavelle: so it looks up the two creatues in the state and then replaces them with new creatures?
08:47:14 <jmcarthur> *creatures
08:47:38 <bartavelle> yes, except I'd like to look them up out of this function, if this is possible
08:47:46 <Jafet> Perhaps you want to use unboxed arrays.
08:48:05 <bartavelle> actually, I am not sure why I would like this more
08:48:07 <jmcarthur> bartavelle: in order to replace them in the state you would still have to look them up again
08:48:18 <beaky> are IOUArrays unboxed?
08:48:30 <jmcarthur> beaky: that is what the U is for, yes
08:48:42 <beaky> ah
08:49:03 <beaky> but my haskell translation of C is slow for some reason :(
08:49:09 <jmcarthur> bartavelle: i would consider making it    attack :: CreatureID -> CreatureID -> State GameState ()
08:49:10 <bartavelle> actually I suppose I could just assign them an identifier, store them in a map, and write helpers to get them and set them back from/to the state
08:49:24 <bartavelle> heh :)
08:49:30 <Jafet> Oh, it uses unboxed arrays.
08:50:00 <bartavelle> jmcarthur, thanks, will try this
08:50:05 <Jafet> Instead of using IORefs, pass the state as a tuple.
08:50:24 <beaky> so state, i, and steps are an IOREF tuple>
08:52:03 <Jafet> To follow that suggestion to not use IORefs, you should not use IORefs
08:52:18 <beaky> right
08:52:43 <Jafet> let run s = if halt then return () else ... run s'
08:53:44 <beaky> ah then I don't need the silly while loop :D
08:53:49 <beaky> right I'll try it out
08:54:23 <Jafet> This is because ghc will almost always unbox the tuple, and deal with the state directly, like in the C program.
08:54:38 <beaky> so IORefs are still boxed?
08:54:46 <Jafet> Of course.
08:54:59 <beaky> ah :(
08:55:25 <Jafet> And hiding it behind an IORef is a great way to ensure that ghc does not unbox it.
08:55:32 <beaky> right
08:55:52 <Jafet> (I think I saw it used in this way once)
08:55:54 <beaky> was hoping that I could have both mutable and efficient variables by using IORef
08:57:37 <Jafet> Why can't ld build shared libraries for packages.
08:58:29 <Jafet> "relocation R_X86_64_PC32 against undefined symbol x3i49gdx3p9ig3poic3qpuf3cabalfnord can not be used when making a shared object; recompile with -fPIC"
08:58:59 <Jafet> Why isn't cabal using -fPIC
09:01:02 <monochrom> did you use "--enable-shared"?
09:03:11 <Jafet> That causes the problem, yes
09:13:13 <beaky> http://ideone.com/fa9lPo I followed the tuple-passing suggestion, but now it's blowing the stack :(
09:13:31 <beaky> looks clearner that way though :D no more readIORef writeIORef everwhere
09:16:09 <beaky> http://ideone.com/v99H1X solved the stackoverflow prolem with bangpatterns, but the code still is nowhere near as efficient as the C version :(
09:16:48 <nicoo> beaky: Do you have a link to the StackOverflow thread ?
09:17:11 <Jafet> Well, you're trying to solve a problem that is easily solved in C in Haskell.
09:17:22 <beaky> nicoo: ah I meant actual stackoverflow issue due to thunking rather than a problem on stackoverflow.com ^^
09:17:40 <Jafet> Maybe you can try to solve a more interesting problem.
09:18:09 <Jafet> Also, the bang-pattern is only required for steps.
09:18:40 <beaky> it made the code faster when I banged the tape though
09:19:02 <Jafet> It's actually pointless to pass the tape to run, because tape never changes.
09:19:09 <beaky> ah
09:19:31 <Jafet> As a last resort, you could use unsafe array operations.
09:21:00 <beaky> eliminating the IORefs definitely improved the code :D
09:21:52 <beaky> funny that this C-like solution is slower than the purely-functional elegant solution :(
09:23:23 <Jafet> Paradigms are mostly irrelevant to operational semantics
09:27:47 * hackagebot bayes-stack 0.2.0.1 - Framework for inferring generative probabilistic models  with Gibbs sampling  http://hackage.haskell.org/package/bayes-stack-0.2.0.1 (BenGamari)
09:28:14 <nicoo> beaky: Ah, ok
09:28:15 <nicoo> xD
09:32:59 <monochrom> IORef has indirection overhead
09:33:48 <beaky> right
09:33:58 <monochrom> "f x = ... f (x-1) ...", in contrast, enjoys optimizations such as keeping x and x-1 in registers directly
09:34:36 <zebr> hey all. slightly off topic, but does anyone know the best way to represent the 'oplus' summation of elements in a set in mathematical notation?
09:34:58 <Jafet> \oplus?
09:35:02 <zebr> yeah
09:35:11 <zebr> but i mean, summation, as in big sigma.
09:35:25 <byorgey> zebr: just use \bigoplus.
09:35:27 <rwbarton> \bigoplus
09:35:51 <byorgey> \bigFOO is to \FOO as  \sum is to +
09:35:52 <zebr> hmm, i thought that might be it but was unsure... and it looks kind of weird. ok, thanks :]
09:36:16 <zebr> there ought to be like a circled sigma :p
09:37:47 * hackagebot network-topic-models 0.2.0.1 - A few network topic model implementations for bayes-stack  http://hackage.haskell.org/package/network-topic-models-0.2.0.1 (BenGamari)
09:37:49 * hackagebot dyre 0.8.11 - Dynamic reconfiguration in Haskell  http://hackage.haskell.org/package/dyre-0.8.11 (WillDonnelly)
09:39:06 <bartavelle> which priority queue should I use ? (I just want to insert arbitrary stuff, and retrieve the item with the highest priority, nothing else)
09:39:41 <parcs`> > (x + 4)*(x + 3)
09:39:43 <lambdabot>   (x + 4) * (x + 3)
09:39:43 <Jafet> Map, as a first approximation
09:41:05 <bartavelle> let's go for map then
09:42:41 <rwbarton> watch out for duplicate priorities
09:42:52 <rwbarton> or duplicate items
09:43:23 <beaky> what is the difference between . and liftM?
09:43:29 <beaky> :t .
09:43:30 <lambdabot> parse error on input `.'
09:43:35 <beaky> :y liftM
09:43:39 <beaky> :t liftM
09:43:41 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:43:48 <beaky> :t (.)
09:43:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:44:06 <rwbarton> :t (Prelude..)
09:44:07 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
09:44:19 <rwbarton> liftM is more general
09:44:34 <rwbarton> liftM is just fmap for a monad
09:44:42 <Jafet> (.) is fmap, which is a generalised liftM, which is a generalised (.)
09:45:53 <merijn> beaky: In fact fmap and (.) are so much the same lambdabot has "(.) = fmap"
09:46:00 <merijn> @src (.)
09:46:01 <lambdabot> (f . g) x = f (g x)
09:46:01 <lambdabot> NB: In lambdabot,  (.) = fmap
09:46:42 <rwbarton> thinking of (.) and fmap as the same is harmful to your health though
09:48:21 <Rc43> Now I have strange cabal issue.
09:48:45 <Rc43> I trying to install vty-ui and it talks that I will broke regex-* packages.
09:48:47 <hpaste> Rc43 pasted “Attempt to install vty-ui” at http://hpaste.org/76861
09:49:22 <Rc43> Don't know how to resolve it. Should I install dependencies and then reinstall rgex-* packages?
09:49:59 <Jafet> > (.) (.) (.) (.) (.) succ pred [1,2,3]
09:50:01 <lambdabot>   [1,2,3]
09:50:26 <beaky> > fmap (+1) (*1)
09:50:28 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
09:50:28 <lambdabot>    arising from a use of `...
09:50:33 <beaky> > fmap (+1) (*1) 3
09:50:35 <lambdabot>   4
09:50:52 <beaky> so . ad fmap are the same thing?
09:51:03 <geekosaur> in lambdabot they are
09:51:09 <rwbarton> Rc43: in a sense the "correct" fix is probably to loosen the mtl constraint in vty-ui to allow mtl 2.1.*
09:51:17 <geekosaur> lambdabot is not running normal haskell, sadly
09:51:23 <geekosaur> @src (.)
09:51:23 <lambdabot> (f . g) x = f (g x)
09:51:23 <lambdabot> NB: In lambdabot,  (.) = fmap
09:51:32 <rwbarton> however you can also just try "cabal install vty-ui regex-posix-0.95.1 regex-compat-0.95.1"
09:52:19 <geekosaur> you might want to do this stuff in a locally running ghci to avoid the Caleskell hackery in lambdabot
09:52:22 <monochrom> fresh from haskell-cafe: http://www.ozonehouse.com/mark/enemy/ by Mark Lentczner
09:52:23 <Rc43> rwbarton, you mean install vty-ui and then rollback regex-* packages, won't it break vty-ui?
09:52:30 <rwbarton> i mean what i said
09:52:50 <Rc43> rwbarton, ok, I can try it :) won't it break vty-ui?
09:53:07 <rwbarton> it will rebuild vty-4.7.0.18 and regex-base-0.93.2 and regex-posix-0.95.1 and regex-compat-0.95.1 all against mtl-2.0
09:53:13 <rwbarton> no, it will specifically not break things
09:53:22 <rwbarton> if you cabal install x then x should work afterwards!
09:53:39 <rwbarton> "cabal install x y z" does not mean "cabal install x and then cabal install y and z breaking x"
09:53:44 <beaky> lol
09:53:54 <rwbarton> it means "find consistent versions of x, y and z and install them all simultaneously"
09:54:20 <Jafet> I wouldn't be surprised if cabal could break packages that aren't installed
09:54:27 <Rc43> rwbarton, but it can fails when installing z with same error what is now
09:54:36 <Rc43> rwbarton, but ok, I will try it now; thanks
09:54:45 <rwbarton> if you have yet other packages that use regex-posix-0.95.1 or regex-compat-0.95.1 then you might need to rebuild them as well, etc.
09:56:30 <rwbarton> Rc43, if it "fails when installing z" then you will get an error message immediately that is similar to the one you have pasted
09:56:40 <beaky> http://ideone.com/awGnY4 any ideas for furhter optimizing this simple progam?
09:57:16 <rwbarton> beaky, how does the runtime compare to the similar C program now?
09:57:24 <Jafet> Use unsafeRead and unsafeWrite
09:58:11 <Rc43> rwbarton, I read your message inattentive; thought you suggest "cabal isntall x; cabal install y-<version_number>".
09:58:21 <rwbarton> ah
09:58:21 <Rc43> rwbarton, it works, thanks
09:58:39 <rwbarton> in fact, then I did not mean what you read :)
09:59:50 <beaky> rwbarton: the C version runs in 0.020 seconds on my machine, while the Haskell version runs in 0.360s :(
10:00:13 <rwbarton> really, odd
10:00:19 <beaky> where can I get unsaferead and unsafewrite?
10:00:20 <nicoo> beaky: Try much larger inputs
10:00:41 <nicoo> To see if you aren't just getting a bigger startup time
10:00:42 <Jafet> @hoogle unsafeRead
10:00:43 <lambdabot> No results found
10:00:57 <Jafet> Executable loading time should be insignificant.
10:01:21 <rwbarton> beaky: are you building with -fllvm? wonder whether it would do better on this kind of code
10:01:21 <beaky> right
10:01:35 <Jafet> beaky: Data.Array.Base
10:01:47 <monochrom> fortunately, for turing machine emulators, you don't need a larger input, you just need a small input that takes a long time to run :)
10:01:52 <beaky> I'm using ghc -O2 -fforce-recomp -fllvm
10:01:53 <rwbarton> unsafeRead/Write is definitely a good suggestion but it won't buy you a factor of 18
10:01:57 <rwbarton> i see
10:02:00 <Jafet> monochrom: his TM is hardcoded
10:02:02 <rwbarton> have you tried not using -fllvm? :)
10:02:11 <beaky> yes and it runs the same :(
10:02:24 <monochrom> ah, but then hardcode a turing machine that takes a long time to run
10:02:33 <Jafet> I thought llvm does better on numerical programs
10:02:37 <beaky> busybeaver5 takes a pretty long time
10:02:44 <rwbarton> that's essentially what he's done, it takes 0.360 seconds
10:02:47 <beaky> busybeaver6 takes an eternity though even in C :D
10:02:50 <rwbarton> which is quite long enough
10:03:00 <monochrom> 0.36s is not a long time
10:03:16 <beaky> I'll do replicateM_ busybeaver5 100 then
10:03:23 <rwbarton> long enough that you can tell the difference between 0.36 seconds and 0.02 seconds
10:03:51 <monochrom> well, I want one of them to be at least 1 second to be sure
10:03:53 <beaky> even the Java version runs in 0.100 seconds :(
10:04:24 <Xorlev> I bet the Java one can get down further with some careful optimization.
10:05:04 <beaky> http://ideone.com/1m48hj java version
10:05:11 <monochrom> wait, cartesian closed comics has a new one?!
10:05:12 <beaky> yes the JIT makes it a bit faster after a while
10:05:31 <nicoo> monochrom: Srsly ?
10:05:45 <rwbarton> beaky: wait, is your state an Integer?
10:05:47 <monochrom> http://ro-che.info/ccc/15.html
10:05:49 <Jafet> Yes, it updates annually now.
10:06:02 <beaky> what are iteratees?
10:06:12 <monochrom> hahaha "Haskell 6000BC Language Report"
10:06:17 <nicoo> xD
10:06:20 <nicoo> Niiiice one
10:06:34 <rwbarton> beaky: try changing e.g. "curstate == 0" -> "curstate == (0 :: Int)"
10:06:59 <Jafet> rwbarton: subtle
10:07:35 <parcs`> the state and the steps are both defaulting to integers
10:07:47 <parcs`> why aren't you compiling with -Wall !
10:08:10 <beaky> rwbarton: yay!
10:08:11 <Jafet> Because then the defaulting warnings scroll by underneath all the other warnings
10:08:19 <beaky> now the haskell versio runs faster than the java version
10:08:29 <rwbarton> did you fix steps too?
10:08:35 <beaky> yes
10:08:55 <parcs`> just add 'run :: Int -> Int -> Int -> IO Int' in the let binding
10:08:58 <rwbarton> and are you using unsafeRead/Write?
10:09:02 <rwbarton> yeah, that is a better fix
10:09:10 <beaky> http://ideone.com/hk8OtG
10:09:38 <Xorlev> With the java version you'd have to run a warmup phase before measuring its performance.
10:09:55 <beaky> right I'll try looping the java one and replicateM_ing the haskell one
10:10:14 <JoeyA> When using throwErrnoIf, what keeps the RTS from scheduling the code to another OS thread between the action and the errno lookup?
10:11:39 <parcs`> wow unsafeRead halves the runtime for me
10:11:46 <monochrom> probably nothing. but is errno really thread-local? I thought it was such a ridiculously global variables
10:11:51 <parcs`> unsafeWrite doesn't change the runtime at all though
10:12:09 <JoeyA> In Linux, (I think) errno is thread-local storage.
10:12:22 <Jafet> @hoogle throwErrnoIf
10:12:22 <lambdabot> Foreign.C.Error throwErrnoIf :: (a -> Bool) -> String -> IO a -> IO a
10:12:22 <lambdabot> Foreign.C.Error throwErrnoIf_ :: (a -> Bool) -> String -> IO a -> IO ()
10:12:22 <lambdabot> Foreign.C.Error throwErrnoIfMinus1 :: Num a => String -> IO a -> IO a
10:12:30 <parcs`> 0.4s with Integer state and steps, 0.12s with Int, 0.6s with unsafeRead/Write
10:12:39 <JoeyA> Granted, this should not be a problem if calling throwErrnoIf from a bound thread.
10:12:44 <parcs`> 0.06*-
10:13:10 <beaky> how do I add a type signature ina  let binding?
10:13:27 <parcs`> http://paste.debian.net/204125/
10:13:47 <Jafet> This is probably a good reason to use forkOS then
10:14:02 <rwbarton> maybe the RTS is errno-aware?
10:14:23 <JoeyA> rwbarton: Now that I think of it, I think you're right.
10:15:23 <JoeyA> In includes/rts/storage/TSO.h: StgWord32               saved_errno;
10:16:23 <Jafet> But when is it saved?
10:17:04 <JoeyA> I'm guessing before it reschedules the Haskell thread or such
10:18:11 <JoeyA> So when it jumps to a different green thread, I suspect it saves errno, then restores it when it comes back.
10:18:12 <beaky> why is it slower with unsafeRead?
10:18:58 <Jafet> beaky: it is?
10:19:01 <beaky> yes
10:19:25 <Jafet> Don't use unsafeRead then
10:20:00 <parcs`> it's not
10:20:03 <parcs`> not for me
10:21:23 <Jafet> "Somehow, my car goes slower when I take the airbags out"
10:21:29 <Jafet> "Uh okay, put them back in"
10:21:37 <Eduard_Munteanu> Anybody wondered about (=>>) :: (Comonad w) => a -> (w a -> b) -> b? Seems like that's a more appropriate dualisation of (>>=) to me.
10:23:07 <Eduard_Munteanu> But I'm unsure you can implement it in terms of extract and duplicate.
10:23:22 <Eduard_Munteanu> Am I missing something?
10:23:32 <beaky> ah right
10:23:50 <beaky> what else can I make unsafe to make things faster?
10:23:59 <Eduard_Munteanu> (for reference, the normal (=>>) :: (Comonad w) => w a -> (w a -> b) -> w b)
10:24:45 <beaky> it may be faster than the java version, but the C version is an F1 machine compared to the haskell version ^_^
10:24:49 <monochrom> I have a cunning plan
10:25:28 <monochrom> why compare C and Haskell by Turing machines? you should compare by lambda calculus evaluators
10:25:47 <beaky> I don't understand the lambda calculus though; I only know how to implement turing machines atm :(
10:26:31 <plat0> Eduard_Munteanu: um, can't you just compose with w b -> b?
10:27:19 <Eduard_Munteanu> plat0: how do you mean?
10:27:32 <Jafet> > let e s@(_:'\\':v:'.':l)=let(x,')':t)=e$d l in(take 4 s++x++")",t);e('(':s)=let(x,t)=e s;(y,')':u)=e$d t in(a x y,u);e s=splitAt 1$d s;d=snd.span(==' ');a(_:'\\':v:_:l)s=let f x|x==v=s|1>0=[x]in fst.e$init l>>=f;a f x='(':f++" "++x++")" in e "((\\x. x) (((\\x. (\\y. (x y))) x) y))"
10:27:34 <lambdabot>   ("(x y)","")
10:27:48 <parcs`> beaky: your c version runs in 50 ms and this haskell version http://paste.debian.net/204125/ runs in 60ms
10:27:54 <Jafet> Do that in one line of C
10:28:08 <beaky> ah
10:28:32 <beaky> but with clang -O3 my C one goes over twice as fast as the haskell version :(
10:28:58 <beaky> half as fast as C is pretty good though
10:29:18 <beaky> maybe we can use GHC primitives to get it even faster ^^
10:29:22 <plat0> Eduard_Munteanu: you have extend :: (w a -> b) -> w a -> w b, and extract :: w a -> a, thus you can implement the function with the signature you want
10:29:27 <Spooner> beaky And that is bad because? There is a see-saw - development time vs run-time. You can't have both tending towards  0 ;)
10:29:35 <plat0> Eduard_Munteanu: oh
10:29:46 <plat0> I misread.  Ignore me!
10:30:04 <zerowaitstate> Spooner: no, but you CAN get them to both tend toward infinity.  Just look at Java
10:30:22 <Spooner> zerowaitstate : :D
10:30:27 <monochrom> hahaha
10:30:35 <beaky> lol
10:30:37 <Jafet> There is a joke about L'Hopital's rule to be made here
10:30:42 <nicoo> zerowaitstate: Ahah xD
10:31:13 <beaky> :t replicateM_
10:31:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
10:31:34 <nicoo> Spooner: No, but each language gives you a Pareto curve for development time vs run-time, and we might be able to get increasingly better compromises
10:32:24 <nicoo> However, I believe you loose some in learning time (than again, I think teaching how to write proper Haskell is easier than how to write proper C)
10:33:26 <Jafet> It's quite probable than more hours of work have gone into the optimization passes of gcc than in the entire base library
10:34:04 <Jafet> (If you include all its dependencies, like gmp, graphite, dwarf2)
10:35:12 <warpy_> i have an issue with haddoc, when i generate docs for my projects, it generates local links to the types in base package
10:35:18 <nicoo> Jafet: graphite isn't a dep., it's a branch of GCC, IIRC
10:35:26 <warpy_> how do i make it generate links to the hackage docs
10:35:45 <warpy_> i couldnt find an option to do that
10:36:03 <nicoo> But IMHO, the big problems of GCC are the IR and the fact it isn't designed to be play nice as a {front,back}-end for other tools
10:36:30 <Jafet> You want your local haddock to link to the hackage website haddocks?
10:36:50 <warpy> yes
10:37:06 <warpy> because i want to put the generated docs on internet
10:37:16 <warpy> and then the local links wont work
10:38:22 <warpy> any ideas?
10:41:49 <Jafet> Does -i accept a URL?
10:43:08 <beaky> can only top-level function-definitions use pattern matching, or can those bound by let also use pattern-matchin?
10:43:34 <byorgey> beaky: any function definitions can use pattern matching
10:43:43 <byorgey> ones bound by 'let' included
10:43:55 <byorgey> > let f 0 = 1; f n = n * f (n-1) in f 5
10:43:56 <lambdabot>   120
10:44:07 <beaky> ah
10:44:27 <byorgey> beaky: were you just curious or are you running into problems?
10:44:36 <beaky> just curious :)
10:45:01 <beaky> trying to eliminate if-then-else
10:45:44 <Eduard_Munteanu> There are other places where you can use patterns, like case-of, the lhs of <- in do notation, lambdas...
10:46:00 <beaky> case-of seems to be like Scala's pattern-matching syntax
10:46:17 <warpy> it is
10:46:25 <Eduard_Munteanu> > (\(Just x) -> x + 1) $ Just 5
10:46:26 <lambdabot>   6
10:46:34 <beaky> are there any languages with more advanced pattern matching than Haskell/Scala?
10:46:41 <warpy> Jafet: i am wondering, has no one run into this issue ever?
10:47:17 <warpy> f# also does it, dunno if it is more advanced
10:47:47 <rwbarton> prolog, in some sense
10:47:57 <Jafet> warpy: I have not run into this issue, ever
10:48:04 <Eduard_Munteanu> beaky: pattern matching follows the structure of the data by design, mind.
10:48:22 <Eduard_Munteanu> Though with some extensions you can do fancier stuff, say ViewPatterns.
10:48:23 <warpy> Jafet: you've never put your haddoc docs online?
10:48:27 <rwbarton> warpy, it's pretty common to see links to people's own built haddocks on hackage
10:49:23 <warpy> i dont want to publish my package on hackage
10:49:29 <rwbarton> though many of those are to http://www.galois.com/~dons/ which no longer exist
10:49:30 <rwbarton> s
10:49:33 <rwbarton> that is not relevant
10:49:39 <rwbarton> my point is, people have done this
10:49:55 <rwbarton> so it is possible, or used to be possible at least
10:49:55 <warpy> how? i could not find a solution
10:50:00 <Jafet> I've never written haddocks
10:50:05 <rwbarton> well i don't know since i have never done it
10:50:15 <warpy> i see, an elusive art then
10:50:20 <Saizan> warpy: there's a flag for haddock
10:50:55 <beaky> pattern matching is one of the coolest feature I've seen in a programming language :D
10:51:10 <warpy> i played with the flags, i can set only one url, it does not work if i have links to both base and mtl
10:51:34 <warpy> which is pretty usual i think
10:53:27 <Saizan> warpy: --read-interface=$base_url_for_a_package,$.haddock_interface_for_such_package
10:53:49 <monochrom> yes beaky, scheme would be a pleasant functional language too if not for lack of pattern matching. "if mylist is empty then xxx else ... head mylist ... tail mylist ..." is really tiresome. and does not scale for richer data types
10:54:10 <warpy> Saizan: what is haddock interface?
10:54:15 <Saizan> --read-interface=/home/saizan/ghc-7.4/share/doc/ghc/html/libraries/deepseq-1.3.0.0,/home/saizan/ghc-7.4/share/doc/ghc/html/libraries/deepseq-1.3.0.0/deepseq.haddock
10:54:49 <warpy> this will point the docs to hackage URL?
10:54:54 <Saizan> no
10:54:55 <warpy> i'll try it out
10:54:58 <warpy> eh?
10:55:08 <Saizan> that's what my cabal passes to haddock, pointing to local docs
10:55:14 <warpy> my docs already point to local docs
10:55:24 <Saizan> yeah, but i had that example ready
10:55:24 <warpy> i want to point to hackage docs
10:55:31 <monochrom> but now you know what to change
10:55:36 <Saizan> if you want to point to hackage docs you have to change the first url
10:55:49 <warpy> i see
10:55:53 <Saizan> and you need a --read-interface for each package you use
10:55:59 <warpy> lot of work
10:56:12 <Saizan> also, you want to change the second path to the .haddock file you have locally installed
10:56:16 <warpy> you'd imagine there'd be an easy option for this
10:56:27 <Saizan> yeah, it is, i wrote a script once but never packaged it
10:56:37 <warpy> because hackage is a standard location of docs
10:56:53 <warpy> like how javadoc does it
10:56:54 <rwbarton> easy option is to publish on hackage
10:57:09 <rwbarton> or just publish docs for everything
10:57:19 <rwbarton> beyond those two options i don't think there is a lot of demand
10:57:24 <Jafet> Or write a sed script
10:57:25 <warpy> rwbarton: how do i do that?
10:57:41 <monochrom> I have a cunning plan, but it requires you to have some control over the web server. in short, tell your web server to redirect
10:57:52 <rwbarton> doesn't ghc come with haddocks for base and mtl and so on?
10:58:01 <Eduard_Munteanu> Hm, I wonder if my new (=>>) could provide a more sensible codo notation.
10:58:04 <warpy> it does
10:58:33 <Eduard_Munteanu> Specifically fixing the unsafe "packing" issue.
10:58:39 <warpy> you mean, copy the standard docs in my docs folder?
10:59:22 <Eduard_Munteanu> (just how 'm a -> a' is "unsafe" for monads, 'a -> w a' should be unnatural for comonads, or at least handled internally)
10:59:39 <beaky> why did they settle on bitshiftrightassign (>>=) for monadic bind?
10:59:59 <rwbarton> I guess if you move those docs then you still need to tell haddock what new URL they are at
11:00:35 <warpy> hmm, i'll just use the interface way
11:01:23 * Eduard_Munteanu waits for edwardk to appear :)
11:01:26 <beaky> :t printf
11:01:27 <lambdabot> forall r. (PrintfType r) => String -> r
11:01:40 <warpy> i have another unrelated question, is using Data.Conduit for IO faster than the usual IO?
11:01:40 <beaky> how does printf work/
11:01:54 <Eduard_Munteanu> beaky: some typeclass trickery
11:01:58 <Jafet> @remember beaky why did they settle on bitshiftrightassign (>>=) for monadic bind?
11:01:58 <lambdabot> Nice!
11:02:32 <Eduard_Munteanu> > printf "%s%d" "A string" 5
11:02:33 <rwbarton> Eduard_Munteanu: forall a b. a -> (w a -> b) -> b is just a -> w a
11:02:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:02:33 <lambdabot>    `Text.Printf.PrintfType ...
11:02:49 <typoclass> beaky: not sure, but i guess they wanted ">>" for "first this then that", and it's not very far off to add an equals sign for "first this, then pass its result into the other thing"
11:02:53 <rwbarton> (forall a. a -> w a rather)
11:02:56 <monochrom> printf is a long story. learn types first
11:02:56 <beaky> ah
11:03:12 <beaky> I don't understand types :(
11:03:19 <typoclass> beaky: yeah, printf is kind of cute, but it's witchcraft :-)
11:03:50 <Eduard_Munteanu> rwbarton: hm, I had a feeling it amounts to that.
11:04:07 <warpy> rwbarton: is using Data.Conduit for IO faster than the usual IO?
11:04:41 <rwbarton> I haven't used Data.Conduit myself but my understanding is that improved performace is not one of its selling points
11:05:01 <typoclass> warpy: i dunno about faster, but the conduit people had the goal to use less memory
11:05:05 <rwbarton> aside from improved performance over reading entire files into memory strictly due to less memory usage
11:05:19 <jmcarthur> it can be faster than lazy IO if you're lucky, but there's nothing fundamental about it that makes it faster
11:05:26 <rwbarton> it is basically supposed to give you the performance of lazy IO without the sketchiness
11:05:29 <Eduard_Munteanu> rwbarton: but what does it amount to categorically? I'm kinda thinking of coalgebras for comonads.
11:05:30 <warpy> i see, but i am concerned with write here
11:05:39 <warpy> fast write
11:05:58 <rwbarton> what kind of thing are you writing? how do you produce it
11:06:19 <warpy> it is result of some in memory calculations
11:06:34 <warpy> and is becoming the bottleneck of the program
11:06:50 <warpy> just writing to stdout
11:07:10 <Eduard_Munteanu> Anyway, the original (=>>) looks like an unnatural dualisation to me, perhaps there's some insight as to why.
11:07:17 <rwbarton> are you currently using lazy bytestring? strict bytestring? text? lots of small chunks? large chunks? etc.
11:07:19 <typoclass> warpy: afaik stdout is going to be slower than writing into a file
11:07:32 <rwbarton> (String??)
11:07:37 <warpy> String
11:07:46 <rwbarton> though actually String write performance tends to be less terrible than one might expect IME
11:07:54 <Jafet> What's wrong with String
11:08:00 <Jafet> I mean, apart from the everything
11:08:05 <warpy> typoclass: is it so? any idea why?
11:08:06 <Eduard_Munteanu> Like other assymmetries in monads / comonads, say the fact you can get a monad from a comonad, but not the other way around.
11:08:26 <typoclass> warpy: well, your terminal has to draw it all on screen
11:08:32 <Eduard_Munteanu> I remember edwardk blogged about this.
11:08:44 <warpy> typoclass: i see
11:09:03 <typoclass> even if it scrolls away after a second. that's a lot of wasted effort
11:09:24 <Jafet> I wonder how fast screen is.
11:09:27 <rwbarton> stdout might be a file of course
11:09:28 <typoclass> warpy: try running "yourprogram > somefile", or even just "yourprogram > /dev/null" for comparison
11:09:29 <Eduard_Munteanu> Also, look at (=>=) :: Comonad w => (w a -> b) -> (w b -> c) -> w a -> c
11:09:35 <Jafet> stdout is a file of course
11:09:38 <rwbarton> okay
11:09:40 <rwbarton> it might be a file on disk
11:09:43 <warpy> typoclass: /dev/null is faster
11:09:48 <warpy> i checked it
11:09:57 <Eduard_Munteanu> That seems more natural.
11:10:01 <warpy> but that is missing the whole point
11:10:03 <plat0> Eduard_Munteanu: also known as compose in the coKleisli category :)
11:10:07 <Jafet> Disks? But those are slow!
11:10:20 <Eduard_Munteanu> Yeah.
11:10:20 <plat0> in fact, it's flipped compose
11:10:34 <plat0> But that's the way I like to think of such things
11:10:35 <rwbarton> warpy: what about with redirection to a file
11:10:42 <Jafet> warpy: so, which part of your program is using too much time?
11:10:46 <rwbarton> on a tmpfs filesystem if you are Jafet
11:10:47 <Eduard_Munteanu> And I expect =>> to be application for coKleisli arrows.
11:11:04 <warpy> Jafet: the writing takes more than half time
11:11:14 <rwbarton> how are you building up this String
11:11:15 <Jafet> Which part of the writing is using too much time?
11:11:25 <rwbarton> I guess however you are doing it cannot be too good
11:11:25 <Eduard_Munteanu> If you scratch the 'w a' in there.
11:11:27 <warpy> what part of wruting?
11:11:45 <warpy> what do you mean by that
11:11:53 <Jafet> There you go, a failure to even find what the problem is
11:11:58 <rwbarton> lol
11:12:03 <rwbarton> warpy: I suggest you look at http://hackage.haskell.org/packages/archive/text/0.11.1.5/doc/html/Data-Text-Lazy-Builder.html
11:12:16 <warpy> ok
11:12:35 <warpy> well, i just call a putStrLn
11:12:46 <warpy> i dont know what are the part of "writing"
11:13:03 <rwbarton> where does this huge String come from
11:13:24 <Jafet> It could be that your terminal is too slow, or whichever buffering mode or line conversion than stdout happens to be using by default is too slow, or converting Strings to write() calls is too slow, or trawling memory to pick up the String is too slow
11:13:27 <rwbarton> is it unlines of something? show? defined by explicit recursion? etc.
11:13:46 <warpy> i see, it is a show
11:13:55 <rwbarton> hmm
11:14:06 <beaky> does haskell have a stdlib function that generates all permutations of a list?
11:14:09 <Jafet> Or the derived Show is crap for some reason, like some derived Reads are
11:14:15 <beaky> like python's itertools.permutations?
11:14:16 <warpy> but the show is fast, because i separated string generation from printing
11:14:16 <Eduard_Munteanu> beaky: Data.List.permutations
11:14:20 <beaky> ah
11:14:21 <rwbarton> > permutations "abc"
11:14:22 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
11:14:27 <Eduard_Munteanu> @hoogle permutations
11:14:27 <lambdabot> Data.List permutations :: [a] -> [[a]]
11:14:27 <lambdabot> package action-permutations
11:14:42 <rwbarton> warpy: separated how?
11:14:52 <rwbarton> did you force evaluation of the entire String to be printed?
11:14:56 <warpy> i generate the all the string in memory at once, then write them to stdout
11:14:56 <typoclass> warpy: (rule of thumb: performance is tricky and often not intuitive. as you've seen, you need to actually test, not guess. think of everything that could be a bottleneck, and test each to find out what really is the issue. this conversation could easily have ended with you changing all your program to use conduits, only to discover it didn't help at all :-)  )
11:14:56 <beaky> > permutations ['a'..'z']
11:14:58 <lambdabot>   ["abcdefghijklmnopqrstuvwxyz","bacdefghijklmnopqrstuvwxyz","cbadefghijklmno...
11:15:23 <warpy> hmm
11:15:44 <rwbarton> "let str = show x" is fast because it does nothing
11:16:04 <rwbarton> "evaluate str" is also fast because it just evaluates a tiny amount of the string
11:16:11 <typoclass> warpy: so have you tried running with "> somefile" yet?
11:16:50 <Jafet> > permutations [0..]
11:16:52 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
11:17:04 <warpy> rwbarton: that makes sense, i'll try forcing it to be strict
11:17:09 <rwbarton> > permutations [0..] !! 17
11:17:10 <lambdabot>   [1,0,3,2,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:17:13 <rwbarton> neat
11:17:20 <warpy> typoclass: trying
11:17:46 <Jafet> Of course, this does not generate all permutations, strictly speaking.
11:18:27 <beaky> is it possible to turn off the GC?
11:19:08 <Jafet> That doesn't make any sense. But you can adjust rtsopts to make it infrequent.
11:19:39 <Jafet> +RTS -A4G or something along those lines
11:19:51 <rwbarton> beaky: have you run with +RTS -sstderr?
11:20:05 <rwbarton> my guess is your program does approximately no garbage collection
11:20:35 <beaky> yes everything is on the stack
11:21:03 <beaky> '%GC time 0.0%'
11:21:07 <Jafet> There is no stack
11:21:11 <beaky> 100% productivity
11:21:17 <Jafet> Everything is in the heap
11:21:21 <beaky> ah :(
11:21:38 <warpy> typoclass: it is about 30% faster when i pipe to a file
11:22:45 <rwbarton> for benchmarking you may as well use >/dev/null... it's not like your program knows its output is being thrown away, and that way you aren't waiting on a disk or anything
11:22:56 <oal> Is there an equivalent of Django / Ruby on rails written in Haskell? I know it wouldn't map directly as Python/Ruby is very different for Haskell, but I'm looking for a web framework that does more than just routing and sessions.
11:22:59 <warpy> yes i tried
11:23:12 <warpy> rwbarton: same result, 30% faster
11:23:20 <tac> oal: There is Yesod.
11:23:26 <rwbarton> all right, good
11:23:35 <typoclass> warpy: ok so that's a good start. 30% improvement that you got practically for free :)
11:23:48 <rwbarton> more like your measurement is now 30% more accurate :)
11:23:54 <oal> tac: checking it out. Thanks
11:24:53 <michael_>  /nick mschober
11:24:54 <warpy> so stdout is very slow
11:24:56 <rwbarton> anyways if the issue really turns out to be that Show is slow then I don't know of a great alternative off-hand
11:25:00 <rwbarton> warpy: not stdout
11:25:01 <Jesin> hi
11:25:02 <rwbarton> your terminal
11:25:19 <beaky> when would lazy evaluation be more efficient than strict?
11:25:24 <warpy> can i make it faster?
11:25:27 <rwbarton> > head [1..]
11:25:28 <lambdabot>   1
11:25:32 <typoclass> warpy: you could easily do "yourprogram | tail -99" or similar
11:25:33 <rwbarton> beaky: ^
11:25:33 <beaky> ah
11:26:11 <Jesin> if I want to make an "instance Foldable" in my own .hs file, can I import qualified Foldable and then refer to the methods as, for example, Foldable.foldr, when defining them?
11:26:12 <beaky> so a lazy program terminates, while an eager one doesn't?
11:26:18 <rwbarton> in this case yes
11:26:32 <rwbarton> > head [1..1000000]
11:26:33 <lambdabot>   1
11:26:41 <Jesin> Or do I need to import Prelude hiding (foldr, [etc]) and them import Foldable unqualified?
11:27:20 <warpy> beaky: selecting smallest element from a list
11:27:23 <rwbarton> Jesin: have you tried just importing Data.Foldable and writing instance Foldable F where foldr = ...
11:27:29 <warpy> head (sort list))
11:27:47 <warpy> it does not sort the whole list
11:27:55 <rwbarton> seems like it ought to know that you mean the foldr that is part of Foldable because it is a definition in a Foldable instance
11:27:58 <warpy> just enough to get the first element
11:27:58 <Jafet> Non-strict evaluation works for strictly more programs than strict evaluation (strictly speaking, this only refers to termination)
11:28:07 <Jesin> rwbarton: that's... messy, I don't want to have two different definitions of foldr in one scope.
11:28:11 <beaky> ah
11:28:15 <rwbarton> ok
11:28:18 <rwbarton> well
11:28:22 <Jesin> rwbarton: or did you mean import qualified?
11:28:27 <rwbarton> what i really mean is, have you tried anything :P
11:28:32 <rwbarton> that should work too
11:28:45 <tac> beaky: lazy evaluation is much more efficient if strict evaluation would get stuck in an infinite loop :)
11:28:57 <rwbarton> instance Data.Foldable.Foldable where foldr = ... -- seems to me like it ought to work
11:29:11 <tac> beaky: lazy evaluation is guaranteed to always terminate if the program has a chance in hell of terminated
11:29:14 <tac> terminating*
11:30:19 <Jafet> Clearly skynet should have used laziness
11:30:23 <beaky> so lazy evaluation is more efficient in infinite-loopy situations, and strict evaluation is more efficient everywhere else?
11:30:37 <nicoo> beaky: It's more complicated
11:30:40 <beaky> ah
11:30:45 <rwbarton> beaky, no, I gave you a second example "head [1..1000000]"
11:31:08 <beaky> ah there lazy evaluation is still more efficient
11:31:20 <tac> beaky: I'm not 100% sure on this, but I think from a practical standpoint, strict usually favors space usage whereas lazy usually favors time usage
11:31:23 <mauke> head (sort xs)
11:31:57 <beaky> let x = (big long computation) in x * x * x * x * x seems to favor strictness
11:32:01 <nicoo> tac: In rwbarton's exemple, lazy is way more space-efficient
11:32:08 <tac> yes
11:32:17 <mauke> beaky: how so?
11:32:37 <tac> beaky: Do you know the nonstrict vs lazy thing?
11:32:58 <beaky> in a strict program the biglongcomputation is done first before the xs, but in a lazy one the bglongcomputation is done 5 times, or am I mistaken?
11:33:03 <tac> Lazy will use "sharing" to make that example equally efficient to strict
11:33:09 <beaky> ah
11:33:13 <tac> Yeah
11:33:23 <tac> It's done 5 times the "naive" way
11:33:35 <tac> GHC (and any sane haskell impl) uses sharing
11:33:47 <tac> which computes x only once
11:34:53 <Jafet> mauke: but not last (sort xs)
11:35:21 <mauke> head (sortBy (flip compare) xs)
11:35:36 <beaky> how come enforcing strictness in places like data members or accumulating parameters made the program go faster?
11:35:39 <Jafet> sort xs !! (length xs `div` 2)
11:35:45 <beaky> or not overflow the stack*
11:36:46 <warpy> i think strictness makes things faster by causing less GC
11:37:00 <beaky> ah
11:37:12 <warpy> and less allocation
11:38:44 <ezyang> A value which is used strictly doesn't need a closure to be allocated for it.
11:38:59 <ezyang> But the biggest thing people see when things are non-strict is a large accumulation of unevaluated data
11:39:19 <beaky> in those cases I need to use strict parameters/seq?
11:39:58 <warpy> or the !
11:40:19 <ezyang> yeah, I've written about it here: http://blog.ezyang.com/2011/05/anatomy-of-a-thunk-leak/
11:40:52 <beaky> why aren't bangpatterns standard?
11:41:55 <warpy> ezyang: nice cartoons
11:42:50 * hackagebot stable-memo 0.1.1 - Memoization based on argument identity  http://hackage.haskell.org/package/stable-memo-0.1.1 (JakeMcArthur)
11:43:46 <warpy> is there a lazy variant of forM or mapM
11:46:07 <Eduard_Munteanu> warpy: they are lazy if the underlying monad is.
11:46:24 <Eduard_Munteanu> @src mapM
11:46:24 <lambdabot> mapM f as = sequence (map f as)
11:47:15 <Eduard_Munteanu> @src sequence
11:47:15 <lambdabot> sequence []     = return []
11:47:15 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
11:47:15 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
11:47:34 <beaky> what does seq stand for
11:47:36 <beaky> :t seq
11:47:36 <warpy> i see, thanks Eduard_Munteanu
11:47:37 <Silox|> @src replicateM
11:47:37 <lambdabot> replicateM n x = sequence (replicate n x)
11:47:37 <lambdabot> forall a t. a -> t -> t
11:47:46 <lispy> beaky: sequence
11:47:49 <mauke> string equality
11:48:16 <Eduard_Munteanu> beaky: a `seq` b means "reduce a to WHNF when evaluating b"
11:48:20 <beaky> ah
11:48:21 <warpy> sequential evaluation
11:48:25 <Eduard_Munteanu> (and return 'b')
11:48:37 <warpy> a then b
11:48:55 <lispy> the "whet evaluating b" is important
11:48:58 <lispy> when*
11:49:15 <mauke> warpy: b can be evaluated first
11:50:06 <warpy> it can be?
11:50:24 <warpy> then what is the point
11:50:25 <Eduard_Munteanu> Shouldn't matter.
11:50:39 <lispy> warpy: the point is that a gets evaluated to WHNF when b is needed
11:51:04 <warpy> lispy: so a is evaluated first (to whnf)
11:51:11 <warpy> is that i said
11:51:24 <rwbarton> foldl' is a lie
11:51:47 <lispy> warpy: well, maybe b is evaluated and then a. It would still be the case that a was evaluated when b was
11:51:55 <jmcarthur> Eduard_Munteanu: it can matter
11:52:22 <jmcarthur> pseq is widely regarded to be a bit nicer than seq when you're trying to control evaluation order very tightly
11:53:07 <monochrom> the point of seq is to suggest to the compiler (not mandate) to evaluate something first
11:53:18 <beaky> right
11:53:23 <monochrom> or at least not too late
11:53:59 <jmcarthur> the semantics don't look like a suggestion to me...  seq _|_ x = _|_
11:54:03 <jmcarthur> *doesn'
11:54:24 <jmcarthur> yet again i need to slow down my typing
11:54:38 <monochrom> however, looking at the name "seq", you can almost guess that the original intention is to get at the order
11:55:51 <Silox|> :t zipWithM
11:55:53 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
11:56:04 <monochrom> jmcarthur, you're mixing up "what goes on the table" and "what does under the table"
11:56:11 <jmcarthur> i wish it could be thought of as "use pseq to control evaluation order. use seq to merely inform the compiler to treat a an expression as though it is definitely going to be evaluated"
11:56:31 <jmcarthur> monochrom: i am?
11:56:54 <monochrom> yes, I think so
11:57:11 <jmcarthur> oh, because i'm saying the semantics require a certain operational behavior?
11:57:50 <rwbarton> which they certainly do not
11:58:00 <jmcarthur> oh i agree
11:58:28 <Eduard_Munteanu> seq _|_ x = _|_ should be preserved regardless of the evaluation order, as long as that bottom gets evaluated eventually.
11:58:28 <jmcarthur> i'm implicitly pairing the semantics with how i happen to know ghc works
11:58:38 <jmcarthur> right
11:58:42 <monochrom> no, because the committee cannot officially talk about operational semantics on the table, but under the table, what's the point of adding this strictness if it did not change order to save memory, that's an open secret
11:59:22 <jmcarthur> it can safely evaluate x first as long as it doesn't give x as the result until it has made sure the first argument is not _|_
11:59:51 <monochrom> go to John Hughes's home page, somewhere he says his contribution to Haskell: sometimes laziness consumes too much memory, he has an adopted idea to solve that
12:00:44 <jmcarthur> i don't think i'm mixing them up. i'm not on the committee and am free to be as frank about it as i want! ;)
12:01:04 <Eduard_Munteanu> jmcarthur: although I guess _|_ `seq` fix id yields different "results".
12:01:06 <monochrom> he doesn't say what idea it is (probably because that description is meant to be for laypeople). but I would guess it is seq. and if seq doesn't nudge the compiler to change order, no memory is saved
12:01:25 <Eduard_Munteanu> But semantically they should be the same.
12:01:40 <jmcarthur> Eduard_Munteanu: what do you mean?
12:02:22 <Eduard_Munteanu> jmcarthur: the order of evaluation gives different results, a crash vs infinite looping.
12:02:37 <monochrom> I am not on the committee either, but I can read what John Hughes wrote and put 2 and 2 together
12:02:40 <Eduard_Munteanu> > undefined `seq` fix id
12:02:41 <lambdabot>   *Exception: Prelude.undefined
12:03:02 <Eduard_Munteanu> Well, I kinda misused _|_ there.
12:03:09 <jmcarthur> Eduard_Munteanu: those are the same result :P
12:03:22 <Eduard_Munteanu> Yeah, I guess so.
12:03:23 <jmcarthur> g2g
12:04:49 <monochrom> I also have the benefit of reading what Simon Marlow wrote, too
12:04:54 <BMeph_> Has anyone done a mock-up of Ted Nelson's ZigZag(TM) stuff in Haskell?
12:06:55 <monochrom> sometime did ask about seq vs pseq for GHC, and Marlow answered: seq is a strong suggestion, but he wants to reserve some right to disobey for GHC, in case the compiler finds an even better thing to do
12:08:10 <ezyang> In particular, seq's contract is the denotational equations which it obeys (bottom `seq` a = bottom); but GHC still is allowed to evaluate a; no ordering is implied.
12:08:11 <Nereid> undefined `seq` unsafePerformIO launchMissiles
12:08:17 <Nereid> what should it do?
12:10:35 <monochrom> overall, I feel the whole business is like a country's president telling the public "we don't negotiate with terrorists". but secretly, he/she does send out representatives to negotiate.
12:11:25 <monochrom> the party line is "seq is no more than denotational semantics, strictness". ok, but it doesn't explain two things: why the name seq, and what John Hughes says about his contribution to haskell
12:11:33 <Nereid> hmm, reading the doc for pseq.
12:11:37 <parcs`> error "a" `seq` error "b" could print one of "a" or "b"; error "a" `pseq` error "b" prints "a"
12:11:39 <fruitFly> in creating a factorial function  in ghci with: fact 0 = 1, fact n = n * fact(n-1) I get an infinite loop
12:12:10 <Nereid> fruitFly: you probably accidentally defined two different facts
12:12:18 <Nereid> with two lets
12:12:22 <monochrom> whereas my conspiracy theory "those people did have evaluation order in mind, just can't say it out loud" is an effective and unifying explanation
12:12:48 <fruitFly> nereid so 2 different functions can be stored with the same name?
12:13:00 <fruitFly> well duh, right?
12:13:06 <Nereid> fruitFly: the second overwrites the first
12:13:10 <jix> is there something generic for this: replacing every element in a data structure with a zipper of the structure focused to that element?
12:13:25 <fruitFly> I'm going to try again
12:13:26 <ezyang> parcs`: I'm pretty sure that's not true
12:13:36 <monochrom> to make the connection, you must first realize that strictness alone doesn't save memory, contrary to popular myth
12:13:38 <Nereid> try: let fact 0 = 1; fact n = n * fact(n-1)
12:13:42 <Nereid> on one line
12:13:57 <Nereid> or enable multi-line input and write that on two lines
12:14:08 <monochrom> hell, denotational semantics doesn't even talk about memory
12:14:25 <fruitFly> NEREIS IT WORKS!!!!!!!!!!!!
12:14:27 <fruitFly> ThaNKS!!
12:14:33 <fruitFly> NEREID
12:14:35 <fruitFly> *
12:15:03 <fruitFly> #onMyWayToConqueringTheWorld
12:15:34 <Nereid> fruitFly: it's usually good to write large definitions into a file and :load that into ghci
12:15:54 <fruitFly> it worked when I did that, just not in interactive
12:15:58 <Nereid> yeah
12:16:46 <fruitFly> what's the point of saying defining, fact :: (Integral a) => a -> a
12:16:59 <fruitFly> is it just for clarity?
12:17:07 <Nereid> aside from clarity, in that case it also specializes the type
12:17:22 <parcs`> ezyang: oh?
12:17:31 <Nereid> else it would have type (Eq a,Num a) => a -> a
12:17:57 <fruitFly> eq a, num a is just a general number?
12:18:06 <Nereid> read about typeclasses if you want to understand it
12:18:22 <fruitFly> I will look it over again, THANKS!
12:21:28 <ezyang> parcs`: To give an analogy, if my compiler is speculatively evaluating thunks, if they error they should not affect my program
12:24:04 <noteventime> Is there an NFData instance for Vector somewhere?
12:32:31 <mysticc> I have a function f a b = dosomething .. call g a .. do something. This function is pure. If I now do map (f a) somelist, will g a be called again for each element of the list ?
12:35:24 <noteventime> mysticc: Compile with -prof and check :)
12:36:27 <beaky> i like haskell
12:36:29 <mysticc> noteventime: How will I know with profiling that a function is called once or more than once ?
12:37:20 <fruitFly> :t read yields read :: Read a => string -> a ... why not just Read => string -> a .....what significance does the a have beside Read?
12:37:21 <lambdabot> parse error on input `=>'
12:39:02 <byorgey> mysticc: technically the Haskell standard does not specify how many times g will be galled.  But no sensible Haskell implementation would call g more than once in your case.
12:39:09 <byorgey> beaky: =)
12:39:16 <byorgey> s/galled/called/
12:39:25 <mauke> fruitFly: er. what would "Read => String -> a" mean?
12:39:46 <byorgey> fruitFly: Read a =>   ...  means  a  is a type which is an instance of Read
12:40:13 <fruitFly> aaaaaaaah... thanks byorgey
12:40:24 <monochrom> "Read => String -> a" is like what I saw recently when grading proofs
12:40:31 <byorgey> fruitFly: so the type of read means  'read takes a String and can return a value of whatever type you want, as long as that type is an instance of the Read type class'
12:40:34 <noteventime> mysticc: I might be mistaken, but I think that's what the entires column is for
12:40:51 <Jesin> hmm
12:41:01 <fruitFly> byorgey ythanks sooo much!
12:41:02 <Jesin> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/src/GHC-List.html#foldl
12:41:08 <monochrom> "blah blah blah, therefore, holds". what holds?
12:41:29 <Jesin> I'm curious, why is that written as "foldl f z0 xs0 = lgo z0 xs0" instead of "foldl f = lgo"?
12:41:51 <monochrom> similarly, "Read => blah blah blah", which thing are you saying is a Read instance?
12:42:03 <Jesin> It seems like the latter would allow it to be inlined and thus strictness-analyzed in more cases.
12:42:16 <byorgey> Jesin: either (1) no good reason or (2) magical gnomes
12:42:35 <byorgey> but probably (2) .
12:43:16 <Jesin> Hm, can you point me to someone who knows these gnomes?
12:43:21 <Jesin> <_<
12:43:59 <monochrom> perhaps ask the ghc mailing list
12:44:07 <Jesin> k
12:44:31 <Jesin> ooh, #ghc is a channel
12:44:33 <Jesin> I'll ask there
12:46:51 <Jesin> oh, you're in that channel
12:46:57 <Jesin> eh, I'll ask on the mailing list.
12:47:11 <bootcode> hi
12:47:42 <bootcode> can you give me a pointer on specifying for ghc which packages to use?
12:48:23 <monochrom> it's automatic
12:48:45 <bootcode> I have a collision on import C.M.Identity
12:49:03 <bootcode> from mtl and monads-tf
12:49:17 <bootcode> so I though one can specify which to use
12:49:26 <monochrom> alright, then on the ghc command line, add "-hide-package monads-tf" or "-hide-package mtl"
12:49:36 <rwbarton> or you can use PackageImports, or cabal
12:49:48 <Jesin> byorgey: Do I have to subscribe to the mailing list in order to get notified of replies, or will replies to a thread I started get sent directly to me regardless?
12:50:06 <bootcode> rwbarton: cabal is pretty standard isn't it?
12:50:15 <rwbarton> I mean, write a .cabal file for your project
12:50:25 <rwbarton> then build it with cabal build etc.
12:50:33 <byorgey> Jesin: you have to subscribe
12:50:36 <bootcode> will try it, thank you
12:50:43 <Jesin> ok, thanks.
12:50:47 <rwbarton> "cabal init" will get you started
13:04:09 <bootcode> rwbarton: it works great
13:05:49 <beaky> let sieve (n:ns) = n:sieve ns' where ns' = filter ((/= 0) . flip rem n) (n:ns) in filter (<10000) (sieve [2..])
13:06:02 <beaky> > let sieve (n:ns) = n:sieve ns' where ns' = filter ((/= 0) . flip rem n) (n:ns) in filter (<10000) (sieve [2..])
13:06:05 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
13:06:09 <beaky> it works?
13:08:43 <beaky> http://ideone.com/43UxSf still thinking of ways to optimize this program, even though it now runs faster than the original C version
13:28:01 <Polarina> beaky, does that do anything practical?
13:29:19 <beaky> not really :( it's just a benchmark game
13:29:36 <beaky> implement it in different languages in different implementations and see how performance differs
13:29:40 <beaky> that's the game :D
13:31:19 <Polarina> beaky, you may want to increase the number of steps. It runs in 0.064 seconds for me.
13:31:40 <beaky> lright
13:32:22 <beaky> it used to be 0.200 seconds then some folks here suggested I use IOUArrays :D
13:33:11 <parcs`> beaky: you're checking whether curstate equals 0 twice
13:33:53 <beaky> ah right I translated over that redundancy :(
13:34:25 <shajen> could someone help me with STABLE merge sort?
13:36:33 <Polarina> parcs`, it seems, from looking at the core output, that ghc optimizes that away.
13:37:47 <aninhumer> Is there a standard implementation of sized Vector types?
13:38:30 <aninhumer> (Ideally one which can make use of promoted literals)
13:40:21 <parcs`> Polarina: oh, cool
13:57:42 <Polarina> What would be a suitable container/algorithm for an array of values where I need random removals but only insertions at the end? I don't need random lookups. The values cannot be ordered or checked for equality (fully polymorphic).
13:58:13 <Silox|> Is this relative xs = map (/sum xs) xs possible with only 1 list traversal instead of 2? :P
13:58:42 <Silox|> It looks impossible <_<
13:59:34 <Ralith> Polarina: I'm not aware of any data structure where random removals have different costs than random lookups.
14:00:04 <Polarina> Ralith, I want to do the removals for some values as I traverse the list.
14:00:18 <Polarina> So, not truly "random" removals, per say.
14:00:19 <Ralith> that doesn't sound random, then
14:00:19 <sipa> Polarina: doubly linked list, in that case
14:00:50 <sipa> Polarina: or if you only need to iterate forward, singly linked
14:01:16 <Polarina> Sounds a lot like lists.
14:01:28 <sipa> lists in haskell are singly linked
14:01:38 <sipa> so, yes
14:01:50 <jmcarthur> yeah it also sounds like a list to me
14:01:59 <jmcarthur> insert at the head, use filter for the removals
14:02:25 <jmcarthur> or fused into whatever traversal you are actually going to use
14:05:44 * Polarina crosses fingers and hopes this will be efficient enough.
14:09:42 <DottorBiondini> ciao
14:09:47 <DottorBiondini> :||list
14:11:30 <mauke> DottorBiondini: hi
14:23:04 <Silox|> Is this relative xs = map (/sum xs) xs possible with only 1 list traversal instead of 2? It looks quite impossible.
14:23:51 <nand`> I'm sure you could accumulate both the sum and the length in the same traversal and calculate lazily
14:24:16 <sipa> what does he need the length for?
14:24:33 <nand`> oh, whoops; I didn't look at the code properly
14:25:01 <nand`> uh; same concept, accumulate the sum while mapping and calculate lazily
14:25:17 <hpaste> troubld pasted “why does this hang?” at http://hpaste.org/76868
14:25:52 <Silox|> hm, k, thanks, I'll try to look at that approach :3
14:27:54 * hackagebot FixedPoint-simple 0.4 - Fixed point, large word, and large int numerical representations (types and common class instances)  http://hackage.haskell.org/package/FixedPoint-simple-0.4 (ThomasDuBuisson)
14:29:02 <troubld> how do i figure out why it's not working? i'm willing to read up on stuff but I don't know what I should be looking at
14:32:24 <u_> rel' s [] = (s,[]) ; rel' s (x:xs) = (sum,(x/sum):xs') where (sum,xs') = rel' (x+s) xs
14:32:31 <u_> that hurt my brain
14:33:06 <u_> and then of course relative l = snd (rel' 0 l)
14:38:22 <edwardk> Eduard_Munteanu: i've appeared. if you are still waiting for me, then i'm impressed by your fortitude
14:40:54 <fryguybob> edwardk: I used lens the other day and was very happy!
14:40:57 <nand`> u_: you forgot to actually accumulate the sum somewhere
14:40:59 <edwardk> fryguybob: =)
14:41:01 <Botje> use lens be happy!
14:41:14 <u_> nand`: eh? (x+s)
14:41:18 <nand`> oh
14:41:22 <u_> i just tried it, it works
14:41:24 <edwardk> botje: a reasonable sloganeering effort =)
14:48:20 <u_> however, the naive double-transversal version is faster and uses less memory
14:49:01 <u_> wait
14:50:07 <Eduard_Munteanu> edwardk: I'm still here, but I have to go afk shortly.
14:51:07 <nand`> what happens if you change ‘rel' s’ to ‘rel' !s’ ?
14:51:08 <u_> yup, already strict i guess
14:51:20 <u_> i just did, no change
14:51:50 <Eduard_Munteanu> edwardk: nvm, I'll be back later
14:54:52 <u_> naive version is still half the time and memory
14:57:04 <pertl> will it be the first or second map that first apples when this function is evaluated? -- map (map (^2)) [[1,2],[3,4,5,6],[7,8]]
14:57:28 <Ralith> > map (map (^2)) [[1,2],[3,4,5,6],[7,8]]
14:57:29 <lambdabot>   [[1,4],[9,16,25,36],[49,64]]
14:59:39 <ciaranm> > (^2) .: [[1,2],[3,4,5,6],[7,8]]
14:59:42 <lambdabot>   [[1,4],[9,16,25,36],[49,64]]
15:00:31 <pertl> I know the result, I just don't get the order of evaluation. what exactly happens with the partical function (map (^2)) ?
15:01:33 <nand`> the outer map will execute first as you force the outer list; the inner maps will execute second as you start observing their results
15:01:39 <nand`> at least that's what I would guess
15:06:51 <Cale> pertl, nand`: that's right, lazy evaluation is outermost-first
15:09:42 <Cale> Well... the outer map happens first, but once it has produced the first (:) in the result, the first element of the result can be evaluated, which carries out some evaluation of map (^2) [1,2]
15:10:01 <Cale> and then you could return to evaluating the overall list again
15:10:17 <Cale> the order in which things happen is partly up to the caller
15:10:26 <Cale> (how the result is pattern matched)
15:22:55 * hackagebot stable-memo 0.1.2 - Memoization based on argument identity  http://hackage.haskell.org/package/stable-memo-0.1.2 (JakeMcArthur)
15:24:54 <hpaste> Marzhall pasted “Inclusion Issues” at http://hpaste.org/76870
15:26:14 <marzhallo1> Hi #haskell, I'm getting an include error when trying to use a data constructor in a file I'm including the datatype in. I can use the dataconsrtuctor fine in the file it's declared in, but not when I include the module. Any idea what I'm doing wrong? Thanks.
15:26:27 <geekosaur> you need to include the data constructors in the export list
15:26:41 <geekosaur> usual way is to add (..) to the type to indicate all constructors
15:26:56 <geekosaur> but you can also list them explicitly in parentheses
15:27:10 <hpaste> geekosaur annotated “Inclusion Issues” with “Inclusion Issues (annotation)” at http://hpaste.org/76870#a76871
15:27:14 <marzhallo1> That I"ve tried, but I get "    Not in scope: type constructor or class `IncludeFile'"
15:27:53 <rwbarton> you need to include them in parentheses after the type name
15:28:02 <marzhallo1> oh, I see
15:28:08 <marzhallo1> thanks, rwbarton
15:28:13 <rwbarton> or use (..) like geekosaur said
15:28:17 <rwbarton> to export all of them
15:28:25 <marzhallo1> that makes sense
15:28:32 <marzhallo1> gracias, geekosaur
15:28:37 <geekosaur> look at my annotation (or the diff:  http://hpaste.org/diff/76870/76871)
15:28:54 <marzhallo1> gotcha
15:28:57 <bitonic`> has anybody ever seen one of these: `cabal: language-spelling.cabal:25: unexpected span: ")]"'?
15:32:21 <jmcarthur> bitonic: i got that exact error earlier today trying to haddock a project i'm working
15:32:40 <jmcarthur> bitonic: something either cabal or haddock didn't like in my description :\
15:33:01 <bitonic> jmcarthur: it's braces
15:33:11 <jmcarthur> ah!
15:33:17 <bitonic> a single brace `}' makes it go bad
15:33:22 <jmcarthur> i guess they need to be escaped then
15:33:28 <bitonic> jmcarthur: nope, doesn't work
15:33:39 <jmcarthur> ah darn
15:34:26 <bitonic> so... is this a bug or what?
15:34:56 <bitonic> braces are not even mentioned here <http://www.haskell.org/haddock/doc/html/ch03s08.html>
15:42:55 * hackagebot stable-memo 0.1.3 - Memoization based on argument identity  http://hackage.haskell.org/package/stable-memo-0.1.3 (JakeMcArthur)
15:44:43 * bitonic goes to take a look at the sources...
15:52:24 <bitonic> jmcarthur: an no, found the problem, I think
15:52:43 <bitonic> braces are used for blocks in .cabals
15:52:55 <jmcarthur> ah!
15:53:17 <beaky> hello
15:53:27 <jmcarthur> well, for now i just avoided anything needing curly braces
15:53:41 <jmcarthur> tired of spamming the channel with uploads to hackage, so i will just wait until some other time
15:53:50 <bitonic> jmcarthur: well... I kind of need braces.
15:54:13 <beaky> when are curly braces used in haskell?
15:54:25 <jmcarthur> maybe you could put that particular bit of documentation into your main module instead of your cabal file
15:54:53 <jmcarthur> beaky: records, also do-notation if you don't want to rely on indentation
15:57:13 <bitonic> beaky: pretty much everything actually
15:57:14 <bitonic> if you want
15:57:24 <geekosaur> more specifically, you can use braces and semicolons in place of layout; this is not generally recommended but can be useful with ghci
15:57:24 <bitonic> class Foo a where { ... } is valid
15:57:31 <geekosaur> (or lambdabot)
15:59:19 <jmcarthur> the braces are not required if it's all in one line
15:59:26 <jmcarthur> at least for the class definition
16:00:17 <parcs`> > "Hello, World!"
16:00:19 <lambdabot>   "Hello, World!"
16:02:46 <marzhallo1> > 4 +5
16:02:47 <lambdabot>   9
16:03:59 <Rotaerk> > 1 + 1
16:04:00 <lambdabot>   2
16:04:04 <Rotaerk> hmm... it's broken
16:05:19 <u_> > do do do do do do do do do do do 0
16:05:20 <lambdabot>   0
16:05:52 <beaky> http://ideone.com/9BxBPk are my semicolons wrong?
16:06:12 <Ralith> beaky: you should use ST instead of IO
16:06:31 <beaky> will it be more efficient?
16:06:38 <hpc> > do be do be do wop
16:06:39 <lambdabot>   <no location info>: parse error on input `do'
16:06:41 <hpc> :(
16:06:42 <Ralith> in theory, it will be precisely as efficient
16:06:47 <Ralith> but it will also be pure.
16:06:51 <hpc> > do be $ do be $do wop
16:06:53 <lambdabot>   Shoo be do be do
16:07:08 <rwbarton> doesn't the { have to be on the same line as the do
16:07:19 <Ralith> also it's a bit weird how you're using brackets *and* indentation
16:07:45 <beaky> in C brackets are mandatory, and indentation is just there for readibility :D
16:07:47 <rwbarton> not really an expert on braces style here
16:07:49 <rwbarton> hmm, i guess not
16:08:36 <jmcarthur> i suspect that it might have something to do with the fact that the let is still relying on indentation or something
16:08:48 <rwbarton> the let is using layout yeah
16:09:04 <rwbarton> oh hmm
16:09:13 <rwbarton> because of where that { is on line 17 probably
16:09:32 <rwbarton> would that end the let block?
16:10:40 <u_> all those (steps + 1)
16:10:44 <Ralith> beaky: and this isn't C.
16:11:02 <bitonic> mhm.  haddock seems to have problems accepting uploads
16:13:12 <lispy> bitonic: hackage?
16:13:22 <rwbarton> or maybe the ; on line 41 is somehow inside the let block rather than after it
16:13:22 <bitonic> lispy: yes sorry, hackage.
16:13:44 <bitonic> and when I terminated the first upload now it doesn't let me upload the same version again.  so I suspect a lack of atomicity :P
16:15:06 <jmcarthur> bitonic: it does that sometimes. i bet it actually uploaded just fine
16:15:10 <bitonic> yee, `Internal Server Error'
16:15:11 <jmcarthur> bitonic: check hackage
16:15:18 <jmcarthur> i've been having the same problem all day
16:15:40 <bitonic> jmcarthur: oh right, it's there.
16:17:56 * hackagebot language-spelling 0.1 - Various tools to detect/correct mistakes in words  http://hackage.haskell.org/package/language-spelling-0.1 (FrancescoMazzoli)
16:17:58 * hackagebot language-spelling 0.1.1 - Various tools to detect/correct mistakes in words  http://hackage.haskell.org/package/language-spelling-0.1.1 (FrancescoMazzoli)
16:18:57 <u_> beaky: sure you don't wanna factor out all those repeated unsafeWrites, go's, (steps + 1)'s?
16:18:58 <Eduard_Munteanu> edwardk: still around?
16:19:11 <edwardk> back. whats up?
16:19:26 <beaky> u_: I'm thinking of cleaning up the code and making it even more efficient :D
16:20:08 <Eduard_Munteanu> edwardk: I wanted to ask you about your comonadic bind... I feel like (=>>) :: a -> (w a -> b) -> b is a more suitable dualisation of (>>=)
16:20:19 <u_> beaky: i'd have the cases return a tuple, pattern match on it then have a single unsafeWrite blah blah blah >> go blah blah blah (steps + 1) at the end
16:20:25 <watermind> is there some standard way to derive a monad from a comonad and vice-versa?  For instance, there's Monad Maybe, and  Maybe a ~ 1+a  and there's  Comonad (,) ()  and (,) () a ~ 1xa
16:20:50 <Eduard_Munteanu> edwardk: have you ever considered it? Also, why can't I implement it from extract and duplicate?
16:20:50 <edwardk> Eduard_Munteanu: lets take a step back and i think you'll see why extend is what it is
16:21:09 <Eduard_Munteanu> Alright.
16:21:22 <edwardk> Eduard_Munteanu: (>>=) is a colossally messed up operator categorically
16:21:35 <watermind> edwardk: indeed :S
16:22:01 <edwardk> it conflates the exponentials in the target category with the mapping induced by the monad with arrows in it. it has 3 kinds of arrows all playing the same role
16:22:04 <Eduard_Munteanu> watermind: there's a way to get a monad from a comonad, but not the other way around, edwardk blogged about it.
16:22:28 <typoclass> edwardk: hence its comonadic equivalent is lossally messed up
16:22:32 <edwardk> if you look at (=<<) on the other hand it has a pretty clean separation
16:23:00 <edwardk> you go from (a -> m b)   to m a -> m b -- you take an arrow in the kleisli category of m, to an arrow in the base category your monad lives in
16:23:03 <watermind> Eduard_Munteanu: oh...
16:23:22 <edwardk> the arrow in between is the 'meta-language' one
16:23:44 <edwardk> (a ~> m b) -> (m a ~> m b)
16:23:46 <watermind> edwardk: Eduard_Munteanu: Ah I just realised who you are, I was just reading your presentation on comonads, good stuff
16:23:54 <Eduard_Munteanu> I see.
16:24:00 <edwardk> now when we dualize this we flip the two arrows that aren't meta
16:24:06 <watermind> Eduard_Munteanu: comonad reader right
16:24:23 <hpc> i thought the comonad reader was edwardk
16:24:26 <edwardk> (m b ~> a) -> (m b ~> m a)
16:24:28 <Eduard_Munteanu> watermind: yes
16:24:33 <edwardk> comonad.reader is me, yes
16:24:37 <watermind> hpc: yes that's what I meant
16:24:51 <hpc> ah
16:25:03 <edwardk> and that is the signature i use for extend in category-extras and in comonad
16:25:42 <edwardk> you get the same operator if you take it apart categorically as well. just working with duplicate, fmap, and extract
16:25:50 <Eduard_Munteanu> edwardk: the reason I looked into this was codo notation is a bit awkward to work with using extend. Specifically you need to come up with a 'w a' in the first place.
16:25:55 <beaky> http://ideone.com/nyRTGP what extra type argument is STUArray missing?
16:25:57 <watermind> Eduard_Munteanu: found it, thank you!
16:26:18 <edwardk> Eduard_Munteanu: that is the _point_ of a comonad. you can easily throw it away, but you have to fight to build it up in the first plae
16:26:29 <edwardk> whereas a monad you have to fight to take apart but is easy to build
16:26:43 <hpc> beaky: ST stuff takes an extra 's' type variable, which magically prevents mutable stuff from leaking into pure code
16:26:57 <hpc> type Tape s = STUArray s Int Int
16:27:18 <hpc> (it's not magic, but that's a whole other thing)
16:27:24 <edwardk> Consider the comonad ((,) e)  -- you need to have an (e,a) to get started
16:27:32 <edwardk> but you can extract the a with snd
16:27:38 <Eduard_Munteanu> Right.
16:27:46 <edwardk> and you can extend :: ((e,a) -> b) -> (e,a) -> (e,b)
16:27:51 <edwardk> @djinn ((e,a) -> b) -> (e,a) -> (e,b)
16:27:52 <lambdabot> f a (b, c) = (b, a (b, c))
16:27:57 <beaky> ah
16:28:53 <nand`> are you going to write a book ‘Wrestling with Comonads by Edward A. Kmett’?
16:29:04 <edwardk> What would you do with your a -> ((e,a) -> b) -> b  on the other hand?
16:29:27 <edwardk> nand`: not enough compelling examples honestly.
16:29:51 <nand`> (I was mainly making a bad joke in reference to the imo amusing usage of the word ‘fight’)
16:29:59 <Eduard_Munteanu> Hm, I'm trying to think what mine means too.
16:30:05 <edwardk> store is great, lenses are great, the zipper for traversables is nice, but they mostly exist to supplement code, rather than as an overarching control structure
16:30:08 <edwardk> nand`: =)
16:30:38 <edwardk> Eduard_Munteanu: honestly i think yours is just a consequence of naively trying to turn the arrows around in a way that just doesn't work
16:30:56 <watermind> edwardk: if e ~ ()  then we could have both duplicate and join as well as extract and return,  but it's rather trivial... are there any non trivial examples of monads + comonads?
16:31:13 <hpc> watermind: []
16:31:15 <edwardk> watermind: there are many things that act ike both monads and comonads
16:31:45 <nand`> hpc: how do you extract [] ?
16:31:51 <hpc> head
16:31:51 <watermind> hpc: I thought streams were comonads, not lists as we can't extracty from []
16:31:57 <Eduard_Munteanu> edwardk: well, I just looked at what bind did, it took the result of a monadic computation and fed it to a monadic function, returning its result.
16:31:57 <hpc> er yes, stream
16:31:58 <edwardk> watermind: in abstract algebra we have bialgebras, those point you at structures that have similar properties to what you want a mixed monad/comonad for
16:32:10 <edwardk> watermind: yes, but you can make a non-empty list type that is both
16:32:31 <watermind> edwardk: but how is the return in a non-empty list?
16:32:37 <watermind> nevermind
16:32:41 <edwardk> watermind: =)
16:32:59 <Eduard_Munteanu> edwardk: so I thought (=>>) should take the result of an 'w a -> b', hence 'b', and feed it to another comonadic function.
16:33:07 <Eduard_Munteanu> Like (=>=)
16:33:12 <nand`> hpc: perhaps NonEmpty?
16:33:13 <watermind> edwardk: should look into bi algebras, think I never came across them
16:33:22 <edwardk> yeah that is where your intuition is leading you astray
16:33:26 <Eduard_Munteanu> (=>=) :: (w a -> b) -> (w b -> c) -> w a -> c
16:33:47 <edwardk> watermind: bialgebras and hopf algebras are both rather useful refinements
16:34:07 <edwardk> watermind: i have a bunch in my algebra package you can compare against wikipedia
16:34:20 <edwardk> Eduard_Munteanu: that guy you can build ;)
16:35:09 <edwardk> compare (>>= return) with extend extract
16:35:21 <edwardk> and you'll see why the types work out the way they do
16:35:21 <Eduard_Munteanu> edwardk: yeah, you have it in your comonad package, the trouble was taking that coKleisli composition to coKleisli "application" (cobind)
16:35:25 <watermind> edwardk: that is a pretty big package
16:35:58 <edwardk> Eduard_Munteanu: in general expect the composition of everything with a comonad to run backwards from how it runs with a monad ;)
16:37:57 * hackagebot language-spelling 0.1.2 - Various tools to detect/correct mistakes in words  http://hackage.haskell.org/package/language-spelling-0.1.2 (FrancescoMazzoli)
16:39:03 <hpc> it'd be interesting to have some combinators for dealing with monad/comonad types
16:39:18 <hpc> like an "under" function
16:39:19 <edwardk> fwiw the 'every comonad gives you a monad' trick originally belonged to ddarius. he spotted you could sandwich in between the adjuntion that gives rise to Cont. i just quantified over it, and showed you can always get a monad transformer out of it
16:39:54 <edwardk> hpc: you might want to check out some of martin erwig's work on metamorphisms
16:41:17 <watermind> ops got to go
16:41:22 <watermind> thanks guys, see later
16:50:03 <beaky> What parts of APL have influenced Haskell?
16:53:02 <nand`> they both have monads
16:53:04 <nand`> clearly
16:54:21 <ryanos> help pls !! :)
16:54:21 <typoclass> nand`: *groooaaan* hehehe
16:55:02 <ryanos> hi.. i'm learning haskell and as per suggestions i got through a few books.. currently looking through "realworldhaskell"
16:55:08 <ryanos> and i find that frustrating
16:55:10 <geekosaur> I don't think there's a lot of direct influence; APL played around with some functional programming stuff but mostly the way Haskell gets that is from Lisp via ML, and Lisp and ML took rather different paths to get there.
16:55:31 <geekosaur> RWH is not really for beginners, it's more an intermedia text after something like LYAH
16:55:39 <strebe> ryanos: what about it is frustrating? (might you prefer 'learn you a haskell for great good'?)
16:55:39 <ryanos> it "realworldhaskell" there is a lot of material, but it is NOT in a form that is digestable  by me
16:55:57 <geekosaur> it's more about taking the Haskell you've already learned, and turning it into something practical
16:56:00 <Eduard_Munteanu> @where lyah
16:56:00 <lambdabot> http://www.learnyouahaskell.com/
16:56:05 <ryanos> got u..
16:56:15 <ryanos> thanks Eduard, strebe, geekosaur
16:56:52 <ryanos> i just had a down moment - thinking i'm an idiot looking at those things that make no sense
16:57:32 <ryanos> (again, your support still doesn't exclude that i may be an idiot - but at least makes me feel a bit better :) )
16:57:59 <strebe> ryanos: naw, that's a typical way to feel when you see something over your head, but in a case like this it's a matter of prerequisite knowledge/experience, not idiocy :-)
16:58:08 <typoclass> ryanos: don't worry, we've all been there :) haskell has a steep learning curve, but it's really rewarding as well. and yes, lyah is much better for beginners. you can move on to rwh afterwards
16:58:12 <beaky> right
16:58:35 <ryanos> agree strebe, typoclass: i love haskell
16:58:49 <beaky> steep learning curve means that you feel your grasp of Haskell is very slippery at the beginning, but then you very quickly do lots of interesting stuff with the language
16:58:50 <ryanos> just trying to find the best heuristic to get up the hill
16:58:54 <strebe> beaky: using too many terse symbols :D
16:59:52 <ryanos> i already started to do useful things with the lang like find prime numbers, common divisors, etc - enough to impress a 3rd grade kid :)
17:00:51 <ryanos> wanted to use haskell for some project i'm looking for but i believe i'll pass on it - imo it is not "production ready" but excellent for fast prototyping
17:01:16 <strebe> ryanos: in what way do you see it as not being "production ready"?
17:01:21 <ryanos> and the missing part is not in teh core, but in the supporting libraries
17:01:35 <ryanos> strebe: the supporting libs are not there
17:01:54 <strebe> ryanos: http://holumbus.fh-wedel.de/hayoo/hayoo.html
17:02:09 <strebe> supporting libs are quite domain-specific; some domains are better-represented than others
17:02:12 <ryanos> yeah, seen that - but i was looking through some of the libs i wanted to use and all are "experimental"
17:02:34 <strebe> and given that some companies have been using haskell commercially for a decade, it's clearly a bit of a mixed bag :-)
17:02:35 <ryanos> strebe: and many have missing various parts
17:02:55 <strebe> ryanos: can you give a concrete example of something you need that's missing?
17:03:09 <ryanos> strebe: xml for ex
17:03:20 <ryanos> i looked through the libs and there are 3 implementations
17:03:28 <ryanos> tried all of them
17:03:33 <ryanos> one of them is simply not there
17:03:37 <ryanos> another not working
17:03:37 <Polarina> ryanos, many of those are pretty good.
17:03:46 <ryanos> the thirt is working
17:04:00 <ryanos> Polarina: exactly, "pretty good" is a good term
17:04:10 <fmap> xml :(
17:04:21 <ryanos> but not supporting all xslt for ex
17:04:29 <ezyang> If I'm looking for a function which takes a bytestring of binary data (e.g. a SHA-1 digest) and converts it into a human readable form, where would I look?
17:04:30 <ryanos> fmap: agree :)
17:04:47 <strebe> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:xslt
17:05:02 <ryanos> strebe: tx, looked at it
17:05:09 <ryanos> the problem is not that i diddn't find some libs
17:05:11 <shachaf> ezyang: You want the standard hexadecimal representation of a hash?
17:05:14 <ryanos> the problem is the support they provide
17:05:19 <ezyang> shachaf: Yup
17:05:30 <ryanos> they seem to be missing various parts
17:05:46 <typoclass> > showHex 123 "" -- ?
17:05:48 <lambdabot>   "7b"
17:05:51 <lispy> what is the name of this symbol? ι
17:05:51 <ryanos> and i have to choose whether to add to the libs or work on my proj
17:06:00 <strebe> ryanos: I'm lucky enough not to have to work with xml, so I haven't run into that particular thorn; most libraries for it in every language seem horribly wrong in one way or another
17:06:13 <shachaf> ezyang: map (printf "%02x")?
17:06:14 <ezyang> typoclass: I'd have to convert the Bytestring to Integer first, and it wouldn't pad out values appropriately
17:06:16 <ryanos> strebe: partially agree
17:06:38 <ryanos> xml is not a fun thing but some langs have a more complete support for it
17:06:43 <typoclass> ezyang: er right, bytestring. sorry i missed that
17:06:53 <typoclass> lispy: iota?
17:07:10 <lispy> typoclass: oh, that could be /me double checks
17:07:10 <ezyang> More broadly, I'm using crypto-api and they only give me bytestrings and not human hashes
17:07:19 <ezyang> shachaf: Does that work?
17:07:25 <strebe> ryanos: yes, and the key phrase there is 'a more' :/
17:07:46 <shachaf> > concatMap (printf "%02x") [12,13,14,15] :: String
17:07:47 <lispy> typoclass: thanks!
17:07:47 <lambdabot>   "0c0d0e0f"
17:07:52 <parcs`> ezyang: the base64-bytestring package
17:08:04 <shachaf> ezyang: Looks working to me.
17:08:57 <lispy> I find elimination rules and motives confusins
17:09:02 <lispy> confusing*
17:09:44 <ezyang> shachaf: base64-bytestring looks reasonable, except that it's base 64
17:09:49 <ezyang> *parcs`, I mean
17:10:08 <ezyang> shachaf: OK, that does look like it would work
17:10:33 <ezyang> oh right, base16-bytestring
17:11:13 <shachaf> I,I base256-bytestring
17:11:37 * ezyang smirks 
17:11:43 <shachaf> ezyang: The API is :: ByteString -> ByteString? Shouldn't it be ByteString -> String?
17:12:06 <typoclass> shachaf: drop 4, *shrug*
17:12:38 <shachaf> typoclass: You think drop is easy?!
17:12:47 * shachaf refers typoclass to droppingWhile p l f = fst . foldrOf l (\a r -> let s = f a *> snd r in if p a then (fst r, s) else (s, s)) (noEffect, noEffect)
17:13:34 <Ralith> o.O
17:13:44 <ryanos> strebe: agreed abt xml..just *have* to do something with it here.. but haskell runs circle around all the base languages at beauty though
17:13:56 <typoclass> > unwords $ zipWith ($) [id, id, drop 4] (words "ByteString -> ByteString")
17:13:57 <lambdabot>   "ByteString -> String"
17:14:20 <shachaf> unacpk :: ByteString -> (Byte,String)
17:14:26 <ryanos> @Eduard_Munteanu - vorbesti si alte limbi straine? :)
17:14:26 <lambdabot> Unknown command, try @list
17:14:57 <ryanos> Eduard_Munteanu: vorbesti si alte limbi straine? :)
17:16:13 <strebe> ryanos: what is that?
17:16:27 <byorgey> shapr: is there a test instance of ghclive running anywhere?  I assume not
17:16:31 <strebe> romanian?
17:16:38 <typoclass> strebe: i bet romanian
17:16:38 <byorgey> I mean a publically accessible test instance
17:16:44 <shachaf> byorgey: ghclive does have the feature where you can run arbitrary code in IO.
17:17:10 <byorgey> I thought it was sandboxed.
17:19:26 <beaky> sh
17:19:48 <ryanos> strebe, typoclass: your typecasting system works well :)
17:20:38 <beaky> are there any jit interpreters for haskell?
17:21:21 <Ralith> what is a 'jit interpreter'?
17:21:24 <strebe> beaky: does ghci count?
17:21:26 <Ralith> you mean a JIT compiler?
17:21:29 <Ralith> or an interpreter?
17:21:53 <beaky> yes a JIT compiler
17:22:00 <nand`> ‘interpreter’ is a fairly broad term if you ask me, as is ‘compiler’
17:22:06 <beaky> something like pypy for python
17:22:06 <nand`> re: Ralith
17:22:09 <beaky> or hotspot for java
17:22:22 <typoclass> beaky: you could do "runhaskell somefile.hs", but that only interprets
17:22:47 <sipa> how about reusing some terminology, and call it a lazy compiler
17:22:47 <beaky> right
17:22:47 <Ralith> nand`: gotta start somewhere
17:22:54 <Ralith> sipa: hah, I like that
17:23:00 <beaky> lazy compiler is a nice term
17:24:12 <sipa> "no,no, that is not the source code, it's a lazy executable!"
17:25:33 <shachaf> nominolo is doing some work on a tracing JIT for Haskell.
17:28:38 <pnielsen> is there a "de facto" FRP lib? http://www.haskell.org/haskellwiki/Functional_Reactive_Programming#Libraries lists quite a lot. reactive-banana?
17:30:44 <pnielsen> and Elm for the browser?
17:35:41 <hiptobecubic> I only see people discussing reactive-banana
17:35:50 <hiptobecubic> but i'm not keeping track
17:36:07 <beaky> I think Qt is the one folks use
17:36:16 <nand`> I also know of sodium, of which I haven't heard too many great things, and netwire, which is lacking documentation
17:36:21 <byorgey> Qt isn't an FRP library
17:36:23 <nand`> but personally I don't like the reactive-banana examples
17:36:28 <nand`> I like what I've seen of netwire though
17:36:34 <typoclass> pnielsen: i thought there were several competing reactive approaches. not sure if a favorite has emerged yet. but i'm not following that :)
17:36:38 <pnielsen> hiptobecubic: yep, same
17:37:58 * hackagebot gluturtle 0.0.43 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.43 (YoshikuniJujo)
17:38:07 <pnielsen> I'll take a look at all of them. As far as I can tell, the serious contender on the HTML(5) side is Elm since Fay doesn't have arrows(?)
17:38:32 <pnielsen> (transcompiling to JS)
17:39:03 <shachaf> There are many projects to compile actual Haskell to JS.
17:39:45 <pnielsen> yes, but Elm seems to be the only one to provide a DOM/HTML5 FRP framework
17:39:50 <nand`> about half a dozen at least
17:40:00 <nand`> of the ones that are actually past the theoretical stage
17:40:07 <pnielsen> but my investigation has been far from thorough. I've just been googling around
17:40:52 <pnielsen> example: http://elm-lang.org/edit/examples/Intermediate/Form.elm
17:46:03 * lispy wants to deprecate GLUT, but notes some people still use it
17:46:54 <pnielsen> nand`: netwire does look nice
17:50:50 <doomlord> glut is more awkward for haskel because its apis are more imperative?
17:51:04 <doomlord> (setting callbacks..)
17:52:28 <otters> Haskell doesn't have a pack/unpack function, does it?
17:52:40 <nand`> pack/unpack?
17:52:45 <hpc> otters: what kind of pack/unpack?
17:52:46 <byorgey> lispy: that's not how it works.  You deprecate something to let current users know that they shouldn't use it.
17:52:47 <hpc> @hoogle pack
17:52:47 <lambdabot> Graphics.Rendering.OpenGL.GL.PixelRectangles.PixelStorage Pack :: PixelStoreDirection
17:52:47 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
17:52:47 <lambdabot> Data.Text.Lazy pack :: String -> Text
17:52:54 <otters> oh wait, no, it couldn't
17:53:04 <otters> unpack :: String -> [a]
17:53:07 <otters> pack :: [a] -> String
17:53:17 <otters> but it would have to be dependently typed
17:53:23 <otters> I think that's the term...
17:53:23 <nand`> toDyn :: String -> Dynamic
17:53:27 <nand`> fromDyn :: Dynamic -> String
17:53:31 <nand`> uh
17:53:33 <hpc> otters: there's Show/Read instances
17:53:34 <nand`> forget that last one
17:53:39 <nand`> fromDynamic :: Dynamic -> Maybe String
17:53:46 <nand`> unless I'm misunderstanding what you meant
17:53:49 <hpc> > read "[True, False, False, False]" :: [Bool]
17:53:50 <nand`> which I probably am
17:53:50 <lambdabot>   [True,False,False,False]
17:53:53 <otters> yeah, but I mean, what would convert "\x1d\x2e\x00\x00" into 11805
17:54:02 <hpc> oh, yeah
17:54:06 <beaky> > let f = \s -> case s of { [] -> []; (x:xs) -> f xs ++ [x] } in f [0..9]
17:54:08 <otters> for example
17:54:08 <lambdabot>   [9,8,7,6,5,4,3,2,1,0]
17:54:09 <nand`> hmm
17:54:15 <hpc> there's Storable
17:54:18 <otters> practical examples are always easier for me
17:54:18 <beaky> > let f = \s -> case s of { [] -> []; (x:xs) -> f xs ++ [x] } in f [0..9] -- is this a good implementation of reverse?
17:54:20 <lambdabot>   [9,8,7,6,5,4,3,2,1,0]
17:54:46 <fruitFly> cc
17:54:51 <nand`> > fromEnum (maxBound :: Char)
17:54:52 <lambdabot>   1114111
17:55:14 <nand`> treat the [Char] as a base-1114111 number :P
17:55:43 <fruitFly> can addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2) accept tuples with more than 2 elements?
17:55:58 <hpc> fruitFly: with that exact definition? no
17:56:22 <hpc> each different n-tuple is a totally different type
17:56:32 <hpc> they just totally coincidentally look similar
17:57:45 <Nereid> you can make a typeclass whose memebers are tuples of numbers, and define addVectors for each one
17:58:10 <hpc> oh yes, and there's actually already a package or two for that
17:58:11 <Nereid> it's also already done for you in, say, NumInstances
17:58:11 <madhadron> And if you're really on a role, you could try to do some Template Haskell to generate typeclass instances for tuples of arbitrary size
17:59:11 <Nereid> NumInstances does it up to 4-tuples, I guess.
17:59:29 <nand`> otters: do you mean something like runPut . putWord64le :: Word64 -> ByteString; runGet getWord64le :: ByteString -> Either String Word64 -- ?
17:59:40 <otters> nand`: yeah, kinda
18:00:11 <madhadron> fruitFly, This kind of thing is where dependent type systems shine.
18:00:20 <fruitFly> is == a member of typeclass Eq?
18:00:28 <fruitFly> I'm just trying tow rap my head around the concept
18:00:33 <madhadron> fruitFly, Yes
18:00:37 <Nereid> I wouldn't call it a member.
18:00:38 <nand`> or package binary; which has ‘put’ and ‘get’ in a typeclass
18:00:50 <Nereid> the members of typeclasses are types.
18:00:53 <Nereid> (==) is a method of Eq
18:01:11 <madhadron> Though actually, if you did something like Peano numbers, you could probably build a version of tuples which assert length in the type system but that you could still write functions independent of their length over
18:01:22 <fruitFly> so == is not a type.. then what is?
18:01:27 <Nereid> Int is a type
18:01:30 <nand`> I would call types ‘instances’, not ‘members’
18:01:35 <Nereid> fine.
18:01:43 <madhadron> fruitFly, It's a function.
18:01:55 <madhadron> It just happens to be defined over a type Eq a => a
18:02:09 <madhadron> (==) :: Eq a => a -> a -> Bool
18:02:18 <nand`> I'm not sure ‘members’ is appropriate either. I think it somewhat fits though, and I don't know what else to use - ‘function’ fails for stuff like mempty and ‘typeclass value’ sounds funny
18:02:31 <madhadron> How you manufacture something of type Eq a => a is your own business. The function's just there.
18:02:41 <Nereid> nand`: hence "method"
18:02:53 <Nereid> madhadron: there aren't many interesting values of type Eq a => a
18:02:54 <nand`> oh, method, yeah
18:02:58 <nand`> I was mixing up method and member in my head
18:03:01 * nand` is very tired
18:03:14 <madhadron> Nereid, Really? Integers? Strings? Most things we work with?
18:03:24 <Nereid> forall a. Eq a => a
18:03:40 <madhadron> Nereid, Okay, yes, I'm being imprecise.
18:03:41 <nand`> Nereid: ‘method’ still fails for ‘mempty’ though
18:03:53 <madhadron> nand`, Why? It's a function with no arguments.
18:04:02 <shachaf> exists a. Eq a *> a
18:04:03 <Nereid> nand`: who said methods had to be functions?
18:04:05 <fruitFly> so == is a function/instance of the typeclass Eq, and Int is an instance of the typeclass Num?
18:04:07 <rwbarton> method is the Official Name
18:04:08 <madhadron> In a lazy, pure language, a function of no arguments and an argument are the same.
18:04:13 <madhadron> sorry, a value, not an argument
18:04:19 <shachaf> rwbarton: And getChar is Officially a function!
18:04:32 <rwbarton> ah, probably true...
18:04:41 <shachaf> Can't trust those officials.
18:04:44 <madhadron> fruitFly, == is a function which takes elements of a type which is an instance of typeclass Eq as its two arguments. The other is right.
18:04:49 <rwbarton> well they can't get them all right
18:04:50 <shachaf> madhadron: There's no such thing as a function of no arguments.
18:05:05 <nand`> every function has one argument
18:05:10 <fenton> how do I launch my main method from within emacs' haskell ghci?
18:05:27 <Nereid> fruitFly: (==) is a method of Eq, and (+) is a method of Num. Int is an instance of both Eq and Num
18:05:35 <rwbarton> shachaf: hmm, where does it say that?
18:05:36 <nand`> shachaf: *> ?
18:05:38 <madhadron> shachaf, nand, In a non-pure language, there are functions with no arguments. In Haskell the distinction doesn't exist. That's what I'm trying to say.
18:06:03 <shachaf> rwbarton: http://www.haskell.org/onlinereport/haskell2010/haskellch7.html#x14-1420007
18:06:12 <fruitFly> thanks madhadron and nereid
18:06:18 <rwbarton> oh, ok
18:06:19 <shachaf> madhadron: I think those things are sort of orthogonal.
18:06:24 <rwbarton> but just below it says "The getChar operation"
18:06:24 <nand`> surely ‘function’ is a misnomer in those contexts though
18:06:31 <nand`> ‘procedure’ is much better for stuff with side-effects
18:06:36 <rwbarton> and some of them are actually functions
18:06:41 <nand`> and a procedure with no arguments makes sense
18:06:45 <shachaf> rwbarton: Yes, it's just carelessness.
18:07:07 <rwbarton> perhaps it is just the enlightened "function of 0 or more arguments" terminology!
18:07:14 <shachaf> @slap rwbarton
18:07:15 <lambdabot> I won't; I want to go get some cookies instead.
18:07:24 <rwbarton> cookies++
18:07:39 <madhadron> nand, Yes, but people have been fighting over the meaning of 'function' in programming for a while
18:08:17 <madhadron> The distinction was there in FORTRAN, ignored entirely in C...
18:08:43 <nand`> in an unrelated note, GHC has holes in the head right?
18:09:16 <Nereid> oh yeah, I have cookies
18:09:16 <Nereid> !
18:10:08 <beaky> what do we call things in haskell with no arguments, like main?
18:10:12 <nand`> values
18:10:14 <beaky> a void function?
18:10:26 <nand`> (note: functions are also values, it is the over-arching term)
18:11:02 <nand`> in the case of IO in particular, you could call it an ‘action’
18:11:34 <madhadron> I think we use whatever word feels most convenient for the nonmathematical context at hand, since in the math, who cares what it's called.
18:13:05 <madhadron> Just because we have words for distinctions that may not apply doesn't mean we have to take them seriously.
18:13:16 <nand`> the thing about math is that the terminology should be consistent
18:13:36 * madhadron guffaws.
18:13:43 <madhadron> Been in a math library recently?
18:14:09 <nand`> depends on your definition of the words ‘math’ and ‘library’
18:14:19 <beaky> sets and singletons mean very different things to both mathematicians and programmers ^^
18:14:28 <Nereid> I'm with nand` as long as he means consistent to mean noncontradictory
18:14:35 <beaky> although the programmer folks borrowed the terms from maths
18:14:47 <Nereid> and mathematicians give themselves a fair bit of slack
18:15:04 <madhadron> Nereid, Unfortunately, even noncontradictory doesn't hold up everywhere.
18:15:05 <nand`> for example; I could be perfectly fine with writing a book where I exchange the terms ‘addition’/‘multiplication’ and the symbols +/*; as long as I clearly re-define them at the start
18:15:17 <nand`> but who wouldn't get confused?
18:15:17 <Nereid> madhadron: that was my thought immediately after I wrote that.
18:15:35 <madhadron> nand, Yup. It's exactly where the boundaries are set that's hard.
18:15:45 <madhadron> Are finite dimensional inner product spaces Hilbert spaces? Are all lattices bounded?
18:15:57 <Nereid> yes and no
18:16:11 <Nereid> (as long as the inner product spaces are over C)
18:16:25 <nand`> yeah I'm aware some authors like to use slightly differing definitions of common concepts depending on whichever one fits more elegantly into their philosophy
18:16:28 <madhadron> Nereid, Depends who you ask. Some folks use a definition of the bounded lattice as a lattice. Not common, but it happens.
18:16:37 <madhadron> nand, Or whichever one they learned first.
18:16:50 <madhadron> A lot of high level algebraists use postfix functions. Why? They learned that way.
18:16:52 <nand`> or that; my point is that it's needlessly confusing
18:17:01 <madhadron> I still revert to physicist math when I'm doing integrals.
18:17:19 <madhadron> nand, Needlessly, implying there is no need for it to be that way, or that it doesn't have to be that way.
18:17:32 <madhadron> But if the social process generating it includes that as an effect, then isn't it inevitable?
18:18:01 <Nereid> it's too bad postfix functions aren't more common.
18:18:05 <madhadron> For an extreme case, why is a function on a probability space called a random variable?
18:18:13 <nand`> with the possibilities of present day communication you'd *think* central definitions could be maintained and relied upon
18:18:25 <madhadron> Nereid, Agreed. They do some nice things. Ah, Forth, how I miss thee...
18:18:26 <Nereid> madhadron: for the same reason a morphism in a category is called a point
18:18:36 <rwbarton> I tried reading a category theory paper using postfix function notation once and was completely unable to
18:18:44 <madhadron> Nereid, Actually, it's because English probabilists learned from the French and not the Germans.
18:18:57 <madhadron> nand, What possibilities? And whose definitions?
18:19:45 <madhadron> There are tells about people's lineage in their notation and choice of terms.
18:19:56 <madhadron> Anyone who watches me work in spherical coordinates knows I was trained by a Russian.
18:20:09 <madhadron> Well, anyone who's spent a lot of time in a culture of theoretical physicists
18:20:27 <Nereid> what do russians do?
18:20:59 <madhadron> Phi is the angle in the 2D plane, and theta is the angle from the pole.
18:20:59 <nand`> (then again, the world hasn't even adopted the SI units uniformly, for some odd reason)
18:21:06 <Nereid> yes, physicists here do that too.
18:21:09 <madhadron> It's the reverse of the west.
18:21:26 <Nereid> but mathematicians swap theta and phi
18:21:40 <Nereid> at least, the ones I've seen.
18:21:57 <madhadron> And mathematicians also swap which element in an inner product on a space over C is conjugated.
18:22:05 <Nereid> sure
18:22:05 <madhadron> Or is conjugate linear, or however you would say it
18:22:22 <Nereid> I know what you meant.
18:22:36 <Nereid> (and I'd say "which argument the inner product is conjugate-linear in"
18:22:37 * madhadron writes Python and Java these days.
18:23:03 <madhadron> It's like a mage taking a job as a plumber.
18:23:38 <madhadron> nand, Agreed on SI. If we can't even get SI everywhere, how do you expect to get anything less clear cut?
18:23:52 <madhadron> And even units aren't all clear cut. Which are the right electromagnetic units?
18:24:12 <madhadron> And is your instrument calibrated in Gaussian or SI or something else?
18:24:42 <Nereid> I'm all for units that minimize the number of appearance of 4pi in fundamental equations.
18:25:01 <madhadron> Nereid, Yeah, but there was a period when, in my working life, hbar = c = 1.
18:25:28 <rwbarton> interestingly the nlab uses the "physicist's convention" which is also the one that was obvious to me
18:25:29 <madhadron> If I don't get to do that, I also prefer Gaussian.
18:25:36 <rwbarton> for the inner product in a Hilber space
18:25:59 <Paprikachu> > let myLast (x:[]) = x
18:26:00 <lambdabot>   not an expression: `let myLast (x:[]) = x'
18:26:06 <Paprikachu> > let myLast (_:x:xs) = myLast (x:xs)
18:26:08 <lambdabot>   not an expression: `let myLast (_:x:xs) = myLast (x:xs)'
18:26:10 <Paprikachu> what's wrong here?
18:26:11 <madhadron> rwbarton, I don't think either is obvious. And I think the physicist convention actually may be an artifact of English vs French mathematicians, since physicists learned theirs from Dirac.
18:26:17 <Nereid> Paprikachu: indeed it's not an expression
18:26:23 <Nereid> let expressions look like "let ... = ... in ..."
18:26:27 <Paprikachu> ghci says
18:26:27 <madhadron> and I think the mathematicians are ostensibly taking theirs from the lineage that led to Bourbaki.
18:26:33 <Paprikachu> *** Exception: <interactive>:5:5-35: Non-exhaustive patterns in function myLast
18:26:49 <Nereid> yes, you're defining a function called myLast twice, with the second overwriting the first.
18:26:50 <rwbarton> well I was really startled when I saw which convention wikipedia uses
18:26:54 <shachaf> Paprikachu: Put it on one line with semicolons.
18:27:14 <rwbarton> (then again I don't work in an area related to Hilbert spaces)
18:27:30 <mmirman> Why must type functions in haskell be open?
18:27:37 <Nereid> type families?
18:27:44 <mmirman> yes
18:28:49 <Paprikachu> why do i have to put it on one line?
18:28:59 <madhadron> Ah, girlfriend's home. Ciao, all.
18:29:13 <Nereid> Paprikachu: well, you could put it on multiple lines if you enable multi-line input, but
18:29:17 <Nereid> you still have to use only one "let"
18:29:27 <Nereid> else you're defining myLast twice
18:29:35 <Nereid> and it's throwing out the first definition
18:33:08 <Ralith> hm
18:33:25 <Ralith> what extension(s) do I need for map show (x :: [forall a. Show a => a]) to work?
18:34:05 <Nereid> Rank2Types
18:34:40 <Paprikachu> > let myReverse xs = [reverse tail xs] ++ [head xs] in myReverse [1, 2, 3, 4, 5]
18:34:42 <lambdabot>   Couldn't match expected type `[a]'
18:34:42 <lambdabot>         against inferred type `[a1] -> [...
18:34:46 <rwbarton> maybe ImpredicativeTypes too?
18:34:55 <Nereid> Paprikachu: reverse tail xs is (reverse tail) xs
18:35:02 <Paprikachu> > let myReverse xs = [reverse $ tail xs] ++ [head xs] in myReverse [1, 2, 3, 4, 5]
18:35:03 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
18:35:23 <Nereid> and then [reverse $ tail xs] is a list of lists
18:35:36 <shachaf> Ralith: Note that "forall a. Show a => a" is uninhabited.
18:35:44 <Paprikachu> > let myReverse xs = (reverse $ tail xs)++ [head xs] in myReverse [1, 2, 3, 4, 5]
18:35:46 <lambdabot>   [5,4,3,2,1]
18:36:18 <Ralith> shachaf: hm?
18:36:22 <Paprikachu> > let myReverse xs = reverse . tail xs ++ [head xs] in myReverse [1, 2, 3, 4, 5]
18:36:24 <lambdabot>   No instance for (GHC.Num.Num [a])
18:36:24 <lambdabot>    arising from a use of `e_112345' at <i...
18:36:37 <Nereid> Paprikachu: reverse . tail xs
18:36:43 <shachaf> Ralith: There's no value of type "forall a. Show a => a"
18:36:46 <shachaf> Unless I'm being silly?
18:36:55 <Nereid> Paprikachu: also, you need to handle the case where xs = []
18:37:19 <Paprikachu> > let myReverse xs = (reverse . tail xs) ++ [head xs] in myReverse [1, 2, 3, 4, 5]
18:37:21 <lambdabot>   No instance for (GHC.Num.Num [a])
18:37:21 <lambdabot>    arising from a use of `e_112345' at <i...
18:37:22 <Ralith> shachaf: I'm not sure that's how it is actually interpreted.
18:37:28 <Ralith> shachaf: let me stop XYing, though.
18:37:33 <Paprikachu> > let myReverse xs = (reverse . tail) xs ++ [head xs] in myReverse [1, 2, 3, 4, 5]
18:37:35 <lambdabot>   [5,4,3,2,1]
18:37:55 <Nereid> oh, that works because reverse is not myReverse.
18:37:55 <rwbarton> oh i only read the "[forall a. Show a => a]" part
18:38:02 <rwbarton> surely you intended some existential type thing instead
18:38:20 <Paprikachu> > let myReverse [] = []; myReverse xs = (myReverse . tail) xs ++ [head xs] in myReverse [1, 2, 3, 4, 5]
18:38:22 <lambdabot>   [5,4,3,2,1]
18:38:52 <Ralith> shachaf: what I want to do is take a collection of values having different types that all implement the same typeclass, and collect them into a list so that I may call those typeclass functions on them at my leisure.
18:38:54 <Nereid> Paprikachu: cool, now write an O(n) version. (yours is O(n^2) -- can you see why?)
18:39:05 <shachaf> Ralith: The answer is "have a list of strings instead".
18:39:15 <shachaf> At least, if your class is Show.
18:39:19 <Paprikachu> can i write this function with curriying?
18:39:20 <Ralith> my class isn't actually Show.
18:39:28 <Paprikachu> since xs are always used at the end
18:39:35 <shachaf> Ralith: OK, the answer is "i dunno, man"
18:39:43 <Ralith> I could do that anyway, but it would be awkward, as there are several values in the typeclass.
18:39:53 <shachaf> Several values isn't awkward.
18:40:05 <shachaf> data Foo = Foo { blah :: String, hmm :: Int -> Foo }
18:40:08 <Ralith> it could be less awkward!
18:40:19 <Ralith> but yes, I can just make the typeclass record explicit
18:40:28 <shachaf> Ralith: People will tell you about existential types, but pretty often that ends up being more awkward than it's worth.
18:40:32 <Ralith> I was wondering if there was a prettier way.
18:40:34 <shachaf> Also they're not first-class in Haskell.
18:40:47 <Paprikachu> > let myReverse [] = []; myReverse x:xs = (myReverse xs) ++ [x] in myReverse [1, 2, 3, 4, 5]
18:40:48 <lambdabot>   <no location info>: Parse error in pattern
18:40:50 <Nereid> Ralith: you could write an existential type: data ShowT = forall a. Show a => ShowT a
18:40:54 <rwbarton> just use {-# LANGUAGE FirstClassExistentials #-}
18:40:55 <shachaf> The existential type way would be data SomeFoo = forall a. Foo a => SomeFoo a
18:40:59 <Nereid> so you get a constructor ShowT :: Show a => a -> ShowT
18:40:59 <Paprikachu> > let myReverse [] = []; myReverse (x:xs) = (myReverse xs) ++ [x] in myReverse [1, 2, 3, 4, 5]
18:41:01 <rwbarton> after writing a compiler that supports it
18:41:02 <lambdabot>   [5,4,3,2,1]
18:41:09 <shachaf> rwbarton: Doesn't UHC support it?
18:41:17 <shachaf> Oh, it supports first-class existentials, but not with class constraints.
18:41:18 <otters> wow, fundeps in Data.Binary
18:41:30 <rwbarton> apparently?
18:41:34 <otters> so you can't extract two different types in the same context
18:41:37 <Ralith> come to think of it, I'd settle for a way to explicitly refer to/obtain values of the record type of a typeclass.
18:41:42 <shachaf> Ralith: Just go back to #idris
18:41:44 <shachaf> I bet they support it.
18:41:48 <Ralith> :P
18:41:57 <Liskni_si> What does it mean for an existential to be first-class?
18:42:14 <shachaf> Liskni_si: A value of type (exists a. ...)
18:42:26 <shachaf> A dual to forall.
18:42:28 <Nereid> Ralith: this existential type is effectively the same thing
18:42:32 <Liskni_si> shachaf: I see, thanks.
18:42:45 <Nereid> Ralith: although with the Constraint kind you can do it uniformly for all typeclasses
18:42:51 <Ralith> Nereid: yes, I'm aware that they're isomorphic.
18:42:57 <Paprikachu> > let isPalindrome xs = xs == (reverse xs)
18:42:58 <lambdabot>   not an expression: `let isPalindrome xs = xs == (reverse xs)'
18:43:09 <Nereid> see the constraints package and related materials
18:43:14 <Paprikachu> > let isPalindrome xs = xs == (reverse xs) in isPalindrome [1, 2, 3]
18:43:14 <Ralith> I'm just looking for any option whereby I don't have to effectively write out the typeclass twice.
18:43:15 <lambdabot>   False
18:43:22 <Paprikachu> > let isPalindrome xs = xs == (reverse xs) in isPalindrome [1, 2, 3, 2, 1]
18:43:24 <lambdabot>   True
18:43:31 <Nereid> Ralith: you don't.
18:43:38 <Ralith> using what approach?
18:43:40 <Nereid> er
18:44:16 <Nereid> well what do you even mean.
18:44:19 <shachaf> Ralith: The answer people usually give to this problem is "carefully consider your whole approach and see whether a type class is really what you want".
18:44:24 <shachaf> Sometimes it is. Sometimes it isn't.
18:44:29 * Ralith nod
18:44:34 <shachaf> If you really want an existential, you can make one.
18:44:38 <shachaf> @where antipattern
18:44:39 <lambdabot> I know nothing about antipattern.
18:44:44 <shachaf> @google existential antipattern
18:44:46 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
18:44:46 <Ralith> it seems like just using an explicit record type instead of the typeclass would be less awkward.
18:44:46 <lambdabot> Title: Haskell Antipattern: Existential Typeclass « Luke Palmer
18:45:03 <rwbarton> right, so maybe you can get rid of the type class entirely
18:45:08 <rwbarton> maybe not
18:45:31 <rwbarton> (s/can/ought to/)
18:46:29 <shachaf> @where+ antipattern http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
18:46:30 <lambdabot> It is stored.
18:46:38 <shachaf> "I advocate a direct programming style in Haskell. Advanced type system features have their place, but plain old functions go a long, long way. Functions are the masters of reuse: when you use an advanced feature, you need a yet more advanced feature to abstract over it (think: classes < existential types < universally quantified constraints < unknown). But all you need to abstract over a function is another function."
18:46:51 <lispy> "...it is very difficult to imagine how unimaginably unimaginable something is." -- Dijkstra
18:47:13 <ezyang> i,i "Except when you need rank-n types"
18:47:31 <rwbarton> {-# LANGUAGE RankNPlusOneTypes #-}
18:47:50 <shachaf> RankNPlusKTypes
18:48:09 <typoclass> shachaf++ for awesome quote
18:48:28 <rwbarton> also we can insert ConstraintKinds into that quote now!
18:49:03 <shachaf> rwbarton: Are you using Control.Lens yet?
18:49:19 <rwbarton> haven't had much of a chance to yet but plan to
18:49:37 <Paprikachu> > let ache = [] in head ache
18:49:39 <lambdabot>   *Exception: Prelude.head: empty list
18:49:49 <simpson> So, IIUC it's now possible in GHC 7.6 to make things like type-safe vectors?
18:50:54 <typoclass> simpson: how do you mean type-safe vectors?
18:51:02 <shachaf> As in data Vec (n::Nat) a where { Nil :: Vec Z a; Cons :: a -> Vec n a -> Vec (S n) a }?
18:52:05 <simpson> Yeah.
18:52:11 <typoclass> shachaf: what's that, a vector where the type system knows the length? "this function needs a non-empty list" kind of thing?
18:52:14 <dolio> That was possible way before 7.6.
18:52:36 <shachaf> Yes.
18:53:01 <shachaf> 7.6 has type-level Nat literals, though. :-)
18:53:12 <shachaf> I haven't yet figured out how to do anything useful with them.
18:53:14 <typoclass> i mean, the cheapest thing would be to use an (a,[a]) as a poor-man's non-empty list
18:53:16 <simpson> Oh, so the types aren't dependent, just easier to enter?
18:53:42 <shachaf> GHC 7.6 doesn't have dependent types, no.
18:54:04 <shachaf> typoclass: This isn't just "empty/non-empty", this is "length known at compile time".
18:54:15 <typoclass> shachaf: right, sure
18:54:20 <Paprikachu> i want an infinite list that starts at a given value and whose next elements are the previous value + alternating 2 or 4 added to it, how can i do that?
18:54:52 <typoclass> shachaf: can those Nats do, for example, "function hour must give an Int > 0 and < 23 and the compiler enforces it"? they can't, right?
18:55:33 <shachaf> You can presumably express that type but I imagine it'll be awkward.
18:55:33 <Paprikachu> like [5, 2, 11, 13, 17, 19, 23, ....]
18:55:34 <rwbarton> welllll
18:55:41 <rwbarton> hour :: Time -> Fin 24
18:55:42 <Paprikachu> err
18:55:44 <rwbarton> but then what
18:55:53 <Paprikachu> [5, 7, 11, ...
18:57:18 <Mortchek> Paprikachu, pattern n = n:(n+2):pattern (n+6)
18:57:41 <lispy> RankNPlusKTypes would be awesome
18:58:30 <simpson> shachaf: So I noticed that there's a (+) on types? Can one express concat :: Vec n a -> Vec m a -> Vec (n + m) a -- now?
18:58:47 <shachaf> I haven't figured out how to use GHC's TypeLit Nat +
18:58:52 <shachaf> Does anyone in here know?
18:59:08 <Paprikachu> > let numbers x = x:(x+2):(x+4):pattern $ x + 6 in numbers 5
18:59:09 <lambdabot>   Not in scope: `pattern'
18:59:14 <byorgey> shachaf: define "use"
18:59:16 <Paprikachu> > let numbers x = x:(x+2):(x+4):numbers $ x + 6 in numbers 5
18:59:18 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a -> t'
18:59:19 <lispy> shachaf: Iavor put some documentation about using it on the ghc trac
18:59:42 <dmwit> Paprikachu: Your parenthesization is bad and you should feel bad.
18:59:54 <typoclass> Paprikachu: friendly reminder, lambdabot is also available in private chat :)
18:59:56 <dmwit> > let numbers x = x : x+2 : x+4 : numbers (x+6) in numbers 5
18:59:56 <lispy> dmwit: zoidberg!
18:59:57 <lambdabot>   [5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55...
19:00:04 * lispy leaves
19:00:18 <dmwit> ...but this is not the desired pattern anyway.
19:00:22 <Paprikachu> > let numbers x = x:x+2:x+4:numbers $ x + 6 in numbers 5
19:00:25 <lambdabot>   Couldn't match expected type `[a]' against inferred type `a -> t'
19:01:06 <shachaf> byorgey: I'd expect :k! 1 + 2 to reduce to 3, for example?
19:01:13 <shachaf> Or to be able to pattern-match on Nats somehow?
19:01:16 <shachaf> Or who knows.
19:01:24 <dmwit> > let numbers x = [x,x+6..]; funnyNumbers x = concat . transpose $ [numbers x, numbers (x+2)] in funnyNumbers 5
19:01:27 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
19:01:49 <Paprikachu> what.
19:02:12 <rwbarton> > scanl (+) 5 $ cycle [2,4]
19:02:13 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
19:02:21 <Paprikachu> > transpose [1,2,3]
19:02:23 <lambdabot>   No instance for (GHC.Num.Num [a])
19:02:23 <lambdabot>    arising from a use of `e_1123' at <int...
19:02:34 <Paprikachu> > transpose [[1,2,3]]
19:02:36 <lambdabot>   [[1],[2],[3]]
19:02:51 <Paprikachu> > transpose [[1,2,3], [4,5,6]]
19:02:52 <lambdabot>   [[1,4],[2,5],[3,6]]
19:03:11 <dmwit> transpose is zipN
19:03:21 <shachaf> zipNplusK
19:03:39 <Paprikachu> > takeUntil (> 10) [1..]
19:03:40 <lambdabot>   Not in scope: `takeUntil'
19:03:43 <aninhumer> Hmm "type family m (+) n" is that + in brakets normal syntax there? Seems kinda weird
19:03:52 <Paprikachu> > takeWhile (` 10) [1..]
19:03:54 <lambdabot>   <no location info>: parse error on input `10'
19:03:58 <Paprikachu> > takeWhile (< 10) [1..]
19:03:59 <lambdabot>   [1,2,3,4,5,6,7,8,9]
19:04:10 <typoclass> > let f x = x : x+2 : x+6 : f (x+2+6) in f 5 -- Paprikachu, this might be the beginner-friendly variant. rwbarton's scanl is probably how most experienced haskellers would write it
19:04:11 <lambdabot>   [5,7,11,13,15,19,21,23,27,29,31,35,37,39,43,45,47,51,53,55,59,61,63,67,69,7...
19:04:15 <marzhallo1> >print "how was your day?"
19:04:27 <typoclass> Paprikachu: also, try the command "/query lambdabot"
19:04:34 <dmwit> typoclass: eh, I think that's wrong
19:04:41 <marzhallo1> > print "how was your day?"
19:04:42 <dmwit> just x : x+2 : f (x+6)
19:04:42 <lambdabot>   <IO ()>
19:04:54 <dmwit> > text "how was your day?"
19:04:55 <Paprikachu> i'm rying to solve http://www.haskell.org/haskellwiki/99_questions/31_to_41
19:04:55 <lambdabot>   how was your day?
19:05:01 <typoclass> sorry, what was the thing again that he wanted ...?
19:05:05 <shachaf> dmwit: Being wrong is very beginner-friendly. :-)
19:05:08 <Paprikachu> trying
19:05:09 <byorgey> shachaf: there's no constraint solver for type nats included in GHC yet.
19:05:15 <typoclass> right, i'm an idiot
19:05:16 <byorgey> shachaf: so they are not all that useful yet.
19:05:21 <shachaf> byorgey: OK. Are they any use for anything?
19:05:23 <typoclass> shachaf: yeah thanks :-(
19:05:24 <rwbarton> does that include constraints like x == 1 + 2
19:05:46 <shachaf> constrain't solver
19:05:47 <byorgey> rwbarton: I don't know.
19:05:49 <rwbarton> or x ~ 1 + 2, I should say
19:06:07 <byorgey> shachaf: at this point they're really only useful as static type indices.
19:06:11 <shachaf> abs (x - (1 + 2)) < eps
19:06:21 <shachaf> When do we get type-level Doubles?
19:06:23 <byorgey> like instead of  Word8, Word16, ...  we could just have a type  Word :: Nat -> *
19:06:30 <typoclass> > let f x = x : x+2 : f (x+6) in f 5 -- Paprikachu, i think that's correct now
19:06:32 <lambdabot>   [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,7...
19:06:54 <byorgey> shachaf: you can reify and reflect between type Nats and value-level ones.
19:06:57 <simpson> byorgey: So it's kind of like that type-level configuration trick?
19:07:08 * simpson cannot remember the module name
19:07:09 <rwbarton> "1" and "2" are types lifted from an inductive data type Nat, right?
19:07:10 <byorgey> simpson: right
19:07:18 <rwbarton> so I can define my own Plus type family?
19:07:21 <rwbarton> is that not what + is?
19:07:29 <Paprikachu> is there a function that makes a single value out of a list providing a function?
19:07:39 <dmwit> + is exactly the type family you'd write by hand, yes.
19:07:46 <Paprikachu> like adding all its elements
19:07:53 <rwbarton> so presumably from x ~ 1 + 2 it ought to be able to infer x ~ 3
19:08:04 <byorgey> uh, I don't think so
19:08:05 <typoclass> Paprikachu: yup, foldr is what you could use for that
19:08:08 <Paprikachu> > foldl (+) [1..10]
19:08:09 <dmwit> Paprikachu: fold{r,l'}?
19:08:09 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
19:08:09 <lambdabot>    arising from a us...
19:08:17 <dmwit> > foldl (+) 0 [1..10]
19:08:18 <lambdabot>   55
19:08:21 <shachaf> dmwit: The type family I write by hand can do a lot more than +!
19:08:24 <byorgey> the type-level nats are not lifted from an inductive Nat.
19:08:25 <rwbarton> byorgey: which part
19:08:26 <rwbarton> oh
19:08:30 <byorgey> they are just primitive type constants
19:08:32 <shachaf> As far as I can tell the only thing + is good for is being +
19:08:34 <rwbarton> I see
19:08:39 <byorgey> and + is just some primitive type operator
19:08:47 <rwbarton> uninterpreted
19:08:48 <rwbarton> currently
19:08:49 <Paprikachu> > and True False
19:08:51 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
19:08:51 <lambdabot>         against inferred typ...
19:08:52 <rwbarton> like a constructor
19:08:53 <byorgey> right, I think so
19:08:56 <dmwit> Oh, I'm wrong. Again.
19:09:06 <dmwit> > (True && False, and [True, False])
19:09:07 <lambdabot>   (False,False)
19:09:14 <Paprikachu> ah
19:09:31 <Paprikachu> > and [True]
19:09:33 <lambdabot>   True
19:09:37 <Paprikachu> > and [False]
19:09:38 <lambdabot>   False
19:09:46 <Paprikachu> ok
19:10:01 <mauke> @src and
19:10:01 <lambdabot> and   =  foldr (&&) True
19:11:05 <ezyang> Hmm, does anyone know if Haskell heap profiles are always ASCII, or if they can contain UTf-8/
19:12:13 <shachaf> That's a worrying question.
19:12:25 <Paprikachu> > let f x y = x `mod` y == 0; isPrime x = and $ map (f x) scanl (+) 5 $ cycle [2,4] in filter isPrime [1..20]
19:12:26 <lambdabot>   Couldn't match expected type `[a]'
19:12:26 <lambdabot>         against inferred type `(a1 -> b ...
19:12:58 <mauke> map (f x) scanl <- no
19:13:14 <Paprikachu> > let f x y = x `mod` y == 0; isPrime x = and $ map (f x)  $ scanl (+) 5 $ cycle [2,4] in filter isPrime [1..20]
19:13:15 <lambdabot>   []
19:13:18 <byorgey> ezyang: surely if you have some non-ASCII identifiers in your program...
19:13:26 <dmwit> byorgey: but maybe zdec
19:13:31 * byorgey doesn't actually know
19:13:40 <ezyang> byorgey: Hm. I guess the names aren't munged in most profiles I look at, so that seems plausible
19:14:18 <Paprikachu> > let f x y = x `mod` y == 0; g x y = x * x <= y; isPrime x = and $ takeWhile (g x) $ map (f x)  $ scanl (+) 5 $ cycle [2,4] in filter isPrime [1..20]
19:14:19 <lambdabot>   No instance for (GHC.Real.Integral GHC.Bool.Bool)
19:14:19 <lambdabot>    arising from a use of ...
19:14:33 <shachaf> Paprikachu: You might try these things in /msg lambdabot. :-)
19:14:52 <Paprikachu> since i need you to help me
19:15:04 <dmwit> You don't need us.
19:15:08 <Paprikachu> i do
19:15:10 <dmwit> Put them in ghci and learn to read error messages.
19:15:13 <Paprikachu> i don't know what's wrong here
19:15:25 <dmwit> It will help you more than relying on us would.
19:15:37 <mauke> you're trying to 'and' a list of numbers
19:15:46 <Paprikachu> no
19:15:53 <rwbarton> which you could know if you could read the error message
19:15:56 <Paprikachu> i have a function that returns a condition, g
19:15:56 <mauke> then you're trying to '*' Bools
19:16:00 <dmwit> No, he's trying to multiply a bunch of Bools.
19:16:03 <dmwit> yeah
19:16:14 <mauke> depends on whether you work inside out or outside in :-)
19:16:34 <Paprikachu> and i want to take numbers from map ... as long as this condition holds
19:16:46 <mauke> what numbers?
19:16:50 <dmwit> Think harder.
19:16:54 <dmwit> Play with smaller compositions.
19:16:56 <rwbarton> read your code
19:16:57 <Paprikachu> map (f x) $ scanl (+) 5 $ cycle [2,4]
19:17:03 <Paprikachu> from this
19:17:03 <mauke> no numbers here
19:17:15 <dmwit> If, after, say, 15 minutes, you are still clueless, then come back here and tell us what you thought about.
19:17:23 <shachaf> Why read your code when #haskell can do it for you?
19:17:31 <mauke> I am a modem
19:18:25 <typoclass> Paprikachu: look closely what types your functions have (f and g)
19:18:50 <Paprikachu> > let f x y = x `mod` y == 0; g x y = x * x <= y; isPrime x = and $ map (f x) $ takeWhile (g x) $ scanl (+) 5 $ cycle [2,4] in filter isPrime [1..20]
19:18:52 <lambdabot>   [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
19:19:15 <Paprikachu> ._.
19:19:47 <Paprikachu> > let f x y = x `mod` y != 0; g x y = x * x <= y; isPrime x = and $ map (f x) $ takeWhile (g x) $ scanl (+) 5 $ cycle [2,4] in filter isPrime [1..20]
19:19:48 <lambdabot>   Not in scope: `!='
19:19:54 <Paprikachu> > let f x y = x `mod` y /= 0; g x y = x * x <= y; isPrime x = and $ map (f x) $ takeWhile (g x) $ scanl (+) 5 $ cycle [2,4] in filter isPrime [1..20]
19:19:58 <lambdabot>   mueval-core: Time limit exceeded
19:21:44 <typoclass> Paprikachu: this channel is read by about 900 people. try out your lambdabot code in another window before you bother everyone. i've told you twice and shachaf told you once. this is your last warning.
19:24:54 <otters> it kind of makes you wonder why lambdabot has mueval in the first place
19:25:07 <Cale> ?
19:25:14 <dmwit> It's a great tool for impressing other Haskellites.
19:25:16 <byorgey> ...to evaluate things?
19:26:12 <aninhumer> Oh hmm, type literals do seem kind of useless at the moment yeah...
19:26:34 <aninhumer> I was thinking I could use them with type-level-tf somehow
19:26:42 <aninhumer> But I don't think that's possible?
19:28:54 <shachaf> data N = Z | S Nat; type family ToNat (n::N) :: Nat; type family FromNat (n::Nat) :: N; type instance FromNat 0 = Z; type instance FromNat 1 = S Z; ...
19:28:57 <Paprikachu> @src foldl
19:28:57 <lambdabot> foldl f z []     = z
19:28:58 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
19:29:00 <shachaf> Sounds like a worthy library!
19:30:03 <aninhumer> I think I'll stick with D1..D9999 for now
19:30:11 <bss03> I am currently working in calal hell.
19:30:12 <lambdabot> bss03: You have 1 new message. '/msg lambdabot @messages' to read it.
19:30:20 <bss03> Do I ask questions here, or is there a better channel?
19:31:46 <rwbarton> here
19:32:04 <bss03> Can I make a package that depends on (conduit >=0.2.0 && <0.3) || (resourcet <0.5)?
19:32:39 <byorgey> bss03: yes, using flags and conditional sections
19:34:58 <bss03> Ah, hrm.  I think I see. Basicially how bytestring-in-base works in other packages?
19:37:06 <Paprikachu> is there a fold that returns a value of different type than the element type?
19:37:30 <Eduard_Munteanu> :t foldl
19:37:31 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:37:37 <Eduard_Munteanu> Paprikachu: how do you mean?
19:37:53 <Paprikachu> i give it a list of ints and it returns a bool
19:38:16 <Eduard_Munteanu> foldl/foldr can do that.
19:38:25 <Paprikachu> http://ideone.com/dFnjwS
19:38:25 <Eduard_Munteanu> Look at the type.
19:38:27 <rwbarton> sure, all the common folds are like that
19:39:13 <Eduard_Munteanu> Paprikachu: that conditional there is problematic
19:39:27 <Eduard_Munteanu> What type is that supposed to be?
19:39:34 <Paprikachu> ?
19:39:37 <rwbarton> in foldl the first parameter to the function is the "accumulator"
19:39:44 <Eduard_Munteanu> Is it Bool, is it some number?
19:40:11 <Paprikachu> damn folds
19:40:16 <Paprikachu> i'll just use foldr
19:40:19 <Eduard_Munteanu> Oh, and what rwbarton says.
19:40:36 <Paprikachu> still the result is wrong
19:40:52 <rwbarton> looks like you should be using foldr anyways
19:41:01 <Eduard_Munteanu> Stop poking at it for a second and think about the types.
19:41:28 <Paprikachu> the types are correct.
19:41:33 <mauke> heh
19:41:34 <typoclass> > foldr (\x acc -> acc && even x) True [2,4,7] -- Paprikachu, here is a possibility
19:41:36 <lambdabot>   False
19:41:38 <Paprikachu> otherwise it wouldn't compile
19:41:49 <Eduard_Munteanu> :t foldr
19:41:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:42:02 <shachaf> Sounds like all even
19:42:42 <shachaf> rwbarton: The second parameter to foldr is also an "accumulator". :-)
19:43:10 <rwbarton> that's why I used the scare quotes!
19:43:15 <rwbarton> in case it came up
19:43:28 <shachaf> Er.
19:43:32 <shachaf> In foldl.
19:43:36 <shachaf> *To* foldl.
19:43:39 <shachaf> OK, I messed that up.
19:43:56 <rwbarton> oh i see
19:44:03 <Paprikachu> http://ideone.com/EPRDew
19:44:04 <Paprikachu> :|
19:44:09 <rwbarton> that second parameter.
19:44:22 <shachaf> The return value of foldl is also the "accumulator".
19:44:27 <shachaf> @ty foldl
19:44:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:44:42 <shachaf> In fact every "a" there is the accumulator, at some point in time.
19:44:49 * shachaf isn't sure he had any point.
19:45:00 <tsou> If I have a ct1 = CalendarTime { ctYear = 1992 }, and a ct2 = CalendarTime { ctYear = 1992, ctMonth = June },
19:45:06 <tsou> is there a way to test if they are "compatible" or not?
19:45:30 <Ralith> if one subsumes the other, you mean?
19:45:34 <bss03> not . all . map ((== 0) . (mod n)) $ isPrimeDivisionsFor n ?
19:45:44 <tsou> yes
19:46:05 <rwbarton> ctMonth ct1 = undefined, yes? so that's not very promising the way you have set it up
19:46:21 <tsou> yes, ctMonth ct1 will throw an error
19:46:25 <tsou> that's why I ask :)
19:46:39 <Eduard_Munteanu> Then not really.
19:47:06 <bss03> It's awkward, but you can map valid values to Just value and bottoms to nothing by catching exceptions.
19:47:16 <tsou> I'm not really interested in CalendarTime, it's just an example.. the question is general for "incomplete" values created with record syntax..
19:47:18 <bss03> But, then everything needs to live in IO.
19:47:30 <Eduard_Munteanu> @hackage spoon   -- while we're at it
19:47:30 <lambdabot> http://hackage.haskell.org/package/spoon   -- while we're at it
19:47:55 <Eduard_Munteanu> (Don't do that.)
19:48:07 <tsou> hehehe
19:48:52 <Eduard_Munteanu> tsou: if you don't care, you create a default value record and modify that.
19:49:03 <bss03> REally, with a package name like spoon I expected a call to fork in the source code.
19:49:22 * bss03 am disapoint.
19:49:27 <tsou> Eduard_Munteanu: what do you mean?
19:49:46 <Eduard_Munteanu> defaultCt = CalendarTime { ctYear = 1990, ctMonth = June }; ct1 = defaultCt { ctYear = 1992 }
19:50:00 <tsou> oh no :P
19:50:39 <mikeplus64> @src build
19:50:39 <lambdabot> build g = g (:) []
19:50:44 <tsou> I would have no way to tell if something represents bottom or a value, in case of that coincidence
19:51:02 <tsou> (unless I misunderstood what you said)
19:51:03 <Eduard_Munteanu> tsou: then use a Maybe for that field.
19:51:21 <bss03> tsou, If you really want to be able to carry not-a-values, you should decorate the fields in Maybe.
19:51:30 <tsou> since record syntax allows missing fields, I was wondering if there was some built-in mechanism that avoids using Maybes
19:51:44 <Eduard_Munteanu> No.
19:51:50 <bss03> You can combine that with default values, too.  Just have the default value put Nothing in every field.
19:52:06 <tsou> yes, in that case it would work
19:52:47 <Eduard_Munteanu> (or perhaps you might be looking for a property list / map)
19:52:48 <tsou> is there a magic way to decorate all the fields with a Maybe?
19:52:51 <bss03> tsou: The built-in mechanism is that programs which access a field that is not set are semantically ill-defined and equivalent to _|_. :P
19:52:53 <Paprikachu> http://ideone.com/EyI6F0
19:53:09 <tsou> bss03: hehehe I see :)
19:53:49 <Eduard_Munteanu> tsou: use a Map or something like that
19:54:31 <Eduard_Munteanu> Though you'd have trouble enforcing properties are well-formed.
19:54:42 <bss03> paprikachu: This is just a learning exercise right, cause we already have a package or two for primality testing using trial division.
19:54:47 <typoclass> bss03: hmm ... i could have sworn that you get a runtime error when you access an uninitialized record field. i am sure, however, that you get a warning with -Wall
19:55:06 <Paprikachu> yes
19:55:18 <Eduard_Munteanu> typoclass: yes, you do get a runtime error
19:55:40 <tsou> you get a runtime error upon accessing such a field, and a warning upon creating such a value
19:55:40 <bss03> typoclass: runtime error == _|_.
19:55:58 <boris``> i have a question regarding lazy bytestrings. http://hpaste.org/76880 -- i'm expecting this program to stream samples, but it doesn't produce any output. what am i doing wrong?
19:56:05 <typoclass> bss03: er, ok :-)
19:56:42 <tsou> Eduard_Munteanu: can you point me to this Map as it'd be hard to google given its capital M?
19:57:27 <Eduard_Munteanu> tsou: ok, let's make it simpler...
19:57:30 <bss03> Paprikachu: Sorry, any/all are wrong, I think you want and/or.
19:57:34 <bss03> :t any
19:57:35 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:57:36 <bss03> :t and
19:57:38 <lambdabot> [Bool] -> Bool
19:57:41 <Eduard_Munteanu> type Calendar = [Properties]
19:58:10 <bss03> Paprikachu: Double Sorry, but I always mess that up myself. :(
19:58:12 <Paprikachu> > not $ any [True, False, False]
19:58:14 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
19:58:14 <lambdabot>         against inferred ...
19:58:14 <Eduard_Munteanu> data Properties = Month ... | Year Int | ...
19:58:26 <Paprikachu> wat
19:58:35 <bss03> > not $ and [True, False, False]
19:58:36 <lambdabot>   True
19:58:45 <bss03> > not $ or [True, False, False]
19:58:46 <lambdabot>   False
19:59:08 <Paprikachu> not or may work
19:59:14 <Paprikachu> but why doesnt not any work
19:59:20 <mauke> > any not [True, False, False]
19:59:22 <lambdabot>   True
19:59:37 <Paprikachu> and what does this do?
19:59:45 <Eduard_Munteanu> tsou: again, assuming the calendar thingy was just an example. But there are probably better ways to accomplish this.
19:59:49 <Paprikachu> i'm confused by priorities :|
19:59:57 <mauke> what priorities?
19:59:57 <typoclass> @type any
19:59:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:59:59 <bss03> Paprikachu: "any" applies a predicate to each value and or's the results.
20:00:04 <tsou> Eduard_Munteanu: oh, I was waiting for a "Map" to kick in
20:00:04 <Paprikachu> evaluation order
20:00:12 <bss03> Paprikachu: You aren't providing a predicate.
20:00:21 <Paprikachu> ah
20:00:22 <Eduard_Munteanu> tsou: I used a list instead of a map ("making things simpler")
20:00:54 <tsou> Eduard_Munteanu: I don't get your example.. I'd have [Year 1992, Year 2000] :: Calendar, would that somehow represent some kind of ambiguity?
20:00:57 <Paprikachu> and still the result is wrong: http://ideone.com/ddrER0
20:01:01 <Paprikachu> and i don't get why.
20:01:29 <tsou> Eduard_Munteanu: heh forget the simpler thing, where can I learn more about the Map thing that you mentioned?
20:01:38 <Eduard_Munteanu> tsou: yeah, look at Data.Map
20:02:03 <Paprikachu> given a number n, i want to check if it is dividable by 5, 7, 11, ..., and if it is, then it's not a prime
20:02:07 <Eduard_Munteanu> tsou: http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
20:02:37 <rwbarton> that is not actually the definition of "prime number"
20:02:40 <rwbarton> this is your problem
20:02:44 <tsou> ah, that's what you meant
20:02:45 <tsou> thanks
20:03:02 <Eduard_Munteanu> tsou: but it's probably bad advice, I don't know what you're doing.
20:03:34 <Paprikachu> that is the optimized version of it.
20:03:50 <bss03> boris``: I'm not an expert, but I also would expect it to stream.
20:04:05 <tsou> Eduard_Munteanu: I imagined something like map but working at the type level.. so that I could some how "MagicMap Maybe Calendar" and that would create a MagicCalendar...
20:04:15 <tsou> not that I can imagine any way that this could be implemented in haskell
20:04:16 <Paprikachu> http://ideone.com/6hsrd7
20:04:24 <Paprikachu> i just forgot the last condition...
20:04:33 <Paprikachu> it works, yay.
20:05:22 <tsou> Eduard_Munteanu: Not doing something in particular, I just realized that I am allowed to leave values unspecified when using record syntax.  And I was playing a bit with that..
20:05:24 <Paprikachu> http://ideone.com/D3ygsv
20:05:31 <typoclass> tsou: Data.Map is roughly an alternative to records, but it's "softer" and "more runtimey" if you will. for example, the compiler won't warn you if you forget initializing fields, and you can make typos in the key names
20:05:41 <bss03> boris``: That said, perhaps it would be better written using pipes or conduits or one of the iterator libraries.  Just to be more explicit in the streaming.
20:06:36 <tsou> typoclass: yes, I've used Data.Map, I thought Eduard_Munteanu meant something completely different..
20:07:00 <boris``> bss03: so i did have a non-exhaustive pattern in myFilter -- myFilter (_:[]) = []
20:07:18 <boris``> it still doesn't work when i try to stream an audio file, but it prints some console output if i just type into it
20:07:49 <Eduard_Munteanu> Though you probably want some heterogenous map to emulate records better.
20:08:03 <Eduard_Munteanu> (but that's another can of worms)
20:08:06 <Paprikachu> > scanl (+) 5 [1..10]
20:08:07 <lambdabot>   [5,6,8,11,15,20,26,33,41,50,60]
20:08:23 <Paprikachu> > map (+5) [1..10]
20:08:24 <lambdabot>   [6,7,8,9,10,11,12,13,14,15]
20:08:43 <dmwit> > 2 : 3 : scanl (+) 5 (cycle [2,4])
20:08:44 <lambdabot>   [2,3,5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,...
20:08:46 <Paprikachu> @src scanl
20:08:46 <lambdabot> scanl f q ls = q : case ls of
20:08:46 <lambdabot>     []   -> []
20:08:46 <lambdabot>     x:xs -> scanl f (f q x) xs
20:09:41 <boris``> it more or less works if i type characters into it and then hit ctrl+D, but it doesn't produce any output until EOF
20:09:50 <bss03> boris``: Maybe L.getContents is waiting for too much data before it delivers some to the rest of the program?
20:10:13 <boris``> bss03: yeah, i think that may be. i think i read the default chunk is 32KiB
20:10:14 <bss03> boris``: Like maybe it's lazy i/o, but just not jazy enough when it's not pulling from a terminal?
20:10:37 <tsou> I guess to asnwer questions of "compatibility" between such values, using Maybes in all the values is the simplest way..
20:11:18 <typoclass> tsou: you could do something like "data Day = { y, m, d ...} ; data Time = { day :: Day, h, m, s ...}". this would help if you always initialize a Day all at once, then at some later time want to add hour/min/sec all at once
20:11:19 <boris``> however, it doesn't seem to create any output when i cat an audio file and pipe it in
20:11:31 <bss03> tsou: Probably.
20:12:28 <Ralith> shachaf: so, here's what I'm trying to do
20:12:50 <Ralith> shachaf: I have a family of continuous statistical distributions like 'normal', 'log normal', 'beta', etc
20:12:58 <tsou> typoclass: is that somehow better than using the existing CalendarTime type and doing ct = CalendarTime { ..day fields.. }, and later ct' = ct { ..time fields.. } ?
20:13:10 <Ralith> shachaf: elements of each family are identified by a few parameters.
20:13:24 <Ralith> e.g. normal has mean and std dev, log normal has minimum and shape, etc.
20:14:07 <Ralith> each of these distributions has distinct mean, median, and mode functions on their parameters.
20:14:19 <Ralith> as well as sampling functions, pdf and cdf functions, and so on.
20:14:53 <typoclass> tsou: well, it would mean you don't have a a partially-initialized record floating around for a while (disadvantages: crashes if you accidentally access it, causes warnings, ...)
20:15:10 <tsou> hmm
20:15:14 <Ralith> I think it makes sense to use a typeclass for those common operations
20:15:44 <Ralith> however, there's one other kind of distribution I'm interested in, and that's the gibbs sampling of some combination of other distributions.
20:15:55 <tsou> typoclass: thanks, I see some point to it now :)
20:16:09 <Ralith> this, too, makes sense as an instance of the continuous distribution typeclass
20:16:33 <tsou> but still has the disadvantage that I have to create a different data type for every "subpart" of the original type that can exist by itself..
20:16:36 <Paprikachu> is there anything i could do better? http://ideone.com/w0YnTe
20:16:50 <tsou> adding Maybes everywhere it is :P
20:16:52 <Ralith> but it seems to require existential types to implement, although those existential types would not otherwise be useful in the interface described.
20:16:59 <Ralith> shachaf: any thoughts?
20:17:39 <typoclass> tsou: a record with a lot of Maybes in it would make sense if the fields really are all independent. to stick with the calendar example, it'd allow year and day, but not month being set. i can't imagine many programs that would need to allow that :-)
20:17:59 <typoclass> tsou: it depends on what you're doing. for the calendar thing, i don't think it'd make much sense
20:18:19 <tsou> typoclass: yes, the calendar thing it won't make sense to skip things, but doing in the way you suggested, it does make sense to have types:
20:18:19 <dmwit> Maybe (Year, Maybe (Month, Maybe Day))
20:18:23 <dmwit> -- lololol
20:18:29 <tsou> YearOnly, YearMonth, YearMonthDay, ..etc..
20:19:32 <Saizan> Ralith: i guess the main question is whether it's useful or not to have a type for each distribution
20:19:34 <bss03> Paprikachu: I would try and write it to avoid the special case for 2 and 3 in isPrime / isPrimeDivisorsFor
20:19:38 <tsou> dmwit: heh, exactly :)
20:20:01 <Paprikachu> that's not possible
20:20:14 <shachaf> dmwit: Sounds like a sort of HList where the types are known at compile-time but the length isn't.
20:20:14 <dmwit> Paprikachu: Yes it is, and not only that I showed how above. =)
20:20:34 <Paprikachu> where?
20:20:41 <Ralith> Saizan: hm, I suppose having a single data Distribution = Normal mean var | ... -- would moot the problem. I liked the idea of making the set of distributions open, but I don't actually need that.
20:20:47 <bss03> Paprikachu: Yes, it is.  I've done that kata several times in the past.
20:20:50 <Ralith> I think I'll do that; thanks.
20:21:25 <Paprikachu> it is impossible
20:21:26 <bss03> Ralith: Yay! Fewer typeclasses! ;)
20:21:49 <dmwit> Paprikachu: I like to think this channel is above that kind of baiting technique.
20:21:56 <dmwit> Think a bit first.
20:22:10 <Ralith> bss03: heh. Not a bad point either.
20:22:16 <Paprikachu> i already thought enough about it
20:22:19 <Paprikachu> it's not possible
20:22:29 <bss03> isPrimeDivisors = 2 : 3 : scanl (+) 5 $ cycle [2. 4] -- For a start.
20:22:41 <Paprikachu> that's the same
20:22:52 <Paprikachu> i just moved 2 : 3 : to the next function, since it's more efficient.
20:23:03 <bss03> Then, dropping the "2 : 3 :" for isPrimeDivisorsFor
20:23:28 <typoclass> tsou: yeah, dmwit's tuples will get awkward, but i think a [Maybe Int] would not be totally out of the question, if you order it biggest-to-smallest (year ... second). every additional element would make the value more precise, but "take 3" on the list would still make sense
20:23:29 <Paprikachu> moving it to isPrimeDivisorsFor does not require takeWhile to visit the elements.
20:23:32 <mmirman> Not that this is particularly usefull yet, but here is an efficient typed tagless concurrent interpreter for the linear lambda calculus based on HOAS rather than DeBruijn indexes https://github.com/mmirman/order/blob/master/Lam.hs
20:23:35 <mantovani> how can I change it "euclidean m n = if n <= 0 then m else euclidean n (rem m n)
20:23:38 <mantovani> "
20:23:40 <mantovani> to work in GHCI ?
20:23:42 <bss03> Then, removing the special case, should just work.
20:23:49 <typoclass> tsou: er, not [Maybe Int], just [Int] :-)
20:23:50 <Paprikachu> what special case?
20:24:04 <dmwit> mantovani: let euclidean m n = ...
20:24:16 <bss03> n `elem` [2,3]
20:24:23 <dmwit> mantovani: You can view ghci as one big IO-based do block. Sort of.
20:24:23 <Paprikachu> you can't remove that
20:24:27 <tsou> typoclass: heh indeed for such a thing it'd work
20:24:32 <bss03> Paprikachu: Yes, you can.
20:24:32 <Paprikachu> that's what the algorithm relies on
20:24:42 <Paprikachu> not without making it inefficient.
20:24:45 <bss03> Paprikachu: Done it before, will proabbly do it again in the future, but not tonight.
20:25:13 <bss03> Paprikachu: You might want to look at the source of one of the trial-division pacakges on hackage. :)
20:25:21 <tsou> typoclass: i'm not trying to do something in particular; I was just playing around with semi-defined values :P
20:25:28 <mantovani> dmwit: :(
20:25:29 <Paprikachu> i want to implement THIS algorithm.
20:25:45 <Paprikachu> and this algorithm requires this special case.
20:25:46 <bss03> Paprikachu: THAT algorithm is trial divison.
20:26:31 <bss03> Paprikachu: THAT algorithm has the same big-O (and Theta) times.
20:26:56 <bss03> Paprikachu: e.g. THAT algorithm isn't more or less efficient for large data.
20:27:12 * bss03 slaps himself.
20:27:22 <bss03> bss03: You mean "i.e." not "e.g.".
20:27:26 <bss03> bss03: Sorry.
20:27:45 <Paprikachu> the algorithm trades efficiency for extra constant work.
20:27:56 <Paprikachu> which is the special case.
20:28:22 <Paprikachu> dividing by 1..x where x*x <= n is the slow version of it
20:28:30 <bss03> A better use of constant work is to exapand you wheel.
20:28:32 <Paprikachu> 2..x
20:28:52 <bss03> You know, like the aforementioned trial division packages.
20:29:00 <Paprikachu> i am only diving through 2,3,5,7,11,13,17,....
20:29:08 <mantovani> http://nopaste.info/38f60721af.html
20:29:14 <mantovani> dmwit: ^
20:29:15 <Paprikachu> thus i need to check for 2 and 3
20:29:25 <dmwit> mantovani: euclidean 100 10
20:29:27 <Paprikachu> since this would return false.
20:29:44 * lispy kept wondering why no one was chatting in here, then realized his putty session was inactive
20:29:58 <shachaf> hi lispy
20:30:03 <bss03> Paprikachu: I know what you are doing, you still don't need the special case.
20:30:09 <lispy> shachaf: heya, did you find the stuff by iavor on the wiki?
20:30:09 <shachaf> lispy: How's them traversals?
20:30:18 <shachaf> lispy: On TypeLits?
20:30:20 <bss03> Paprikachu: AND it will still only divide by items on your wheel.
20:30:22 <shachaf> I found some text.
20:30:30 <lispy> shachaf: I found a typo in an edwardk post about lenses. That's about it for traversals.
20:30:44 <lispy> on SO
20:30:49 <lispy> looks like he has since fixed it
20:31:07 <shachaf> I've decided that figuring out Traversal is the key to figuring out lens.
20:31:16 <shachaf> Almost everything else is just a specialization of it.
20:31:22 <lispy> I figured out how to get idris to build with the latest haskeline, but ran into a lack of gmp
20:31:41 <bss03> Paprikachu: Hint: 2 * 2 > 2, 2* 2 > 3, 3 * 3 > 2, and 3 * 3 > 3.
20:31:52 <dmwit> mantovani: (By the way, in case this is not just an exercise, the Prelude comes with gcd and lcm.)
20:32:13 <lispy> have people here been looking at idris? It's actually quite interesting. edwinb's contribution to dependently type languages seems to be performance.
20:32:30 <lispy> dmwit: and sadly, no extended gcd
20:32:42 <shachaf> lispy: Well, I was at edwinb's talk on Idris in Jan. Does that count?
20:32:47 <Paprikachu> [06:30:02]	<bss03>	Paprikachu: AND it will still only divide by items on your wheel.
20:32:49 <Paprikachu> what
20:32:49 <lispy> shachaf: cool
20:32:50 <shachaf> Looked pretty neat.
20:32:53 <Paprikachu> this works for all numbers
20:32:56 <shachaf> I haven't used it, though. :-)
20:33:05 <bss03> I've avoiding dependently-typed lanaguages until I can get a job using a strongly, statically typed lanaguage. :(
20:33:36 <Paprikachu> i skip all multiples of 2 and 3.
20:33:42 <randomclown> bss03: java?
20:33:42 <bss03> Paprikachu: Your "wheel" is the [2,3,5,7,11,...]
20:34:06 <bss03> randomclown: That's dynamically typed.
20:34:08 <Paprikachu> then i don't understand that statement.
20:34:34 <randomclown> bss03: Java, dynamically typed, oh you.
20:34:57 <Paprikachu> java is crappy typed
20:35:12 <rwbarton> haskell is dynamicall typed
20:35:17 <rwbarton> type system changes every few months
20:35:23 <Paprikachu> :D:D
20:35:45 <Paprikachu> also, bss03, your hint does not help me at all...
20:35:56 <bss03> randomclown: Well, I guess it depends on the Java around you.  Sometimes it is dynamically typed, often it is weakly typed, but it CAN be used in a strong, statically typed manner.
20:37:02 <randomclown> bss03: staticlly typed = type checking is done by the compiler at compile time.
20:37:41 <ivanm> OK, I'm confused by hayoo: for some reason it doesn't let me search within a specific package for a function :/
20:38:01 <ivanm> oh, and letters used for variable names matter
20:39:32 <bss03> randomclown: Yeah, I know.  instanceof and ClassCastExceptions aren't checked by the compiler.
20:39:50 <bss03> randomclown: (of course, neither is unsafeCoerce)
20:40:24 <lispy> bss03: those jobs do exist
20:40:25 <Paprikachu> http://ideone.com/Yl8kfJ
20:40:27 <Paprikachu> yay.
20:41:12 <randomclown> bss03: just because ClassCastExceptions exist doesn't make it dynamically typed, the result of the cast still has to conform
20:41:25 <bss03> lispy: Oh, I know.  I just haven't gotten one, yet.
20:41:51 <randomclown> just because there is a function that tries to turn class A into class B doesn't make it dynamically typed.
20:42:26 <bss03> randomclown: If that function type-checks and fails at runtime due to type issues, it does.
20:42:34 <lispy> shachaf: traversals as in Data.Traversable?
20:42:39 <lispy> (or whatever it's called)
20:42:41 <shachaf> lispy: Yes.
20:42:46 <bss03> randomclown: Well-typed programs do not "go wrong" (in that way).
20:42:49 <shachaf> lispy: Well, as in the generalization of it in lens. :-)
20:42:58 <lispy> shachaf: I read the applicative paper. Should I be reading something eles?
20:43:04 <shachaf> lispy: type Traversal a b c d = forall f. Applicative f => (c -> f d) -> a -> f b
20:43:16 <shachaf> (Hint: A Traversal is just a mapM.)
20:43:33 <lispy> oh yeah, that pattern of (c -> f d) -> (a -> f b) is interesting
20:43:41 <lispy> I'm not sure what to make of that
20:43:45 <shachaf> lispy: Thinking of it in terms of mapM makes it make sense.
20:43:49 <randomclown> bss03: Violation of java's static typing results in "class confusion" and is a security vulnerability. The bottom line is that Java is not dynamically typed.
20:43:53 <lispy> :t mapM
20:43:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
20:44:01 <randomclown> even if it's not "well-typed"
20:44:19 <bss03> randomclown: Well, TAPL doesn't consider it statically-typed.
20:44:38 <shachaf> lispy: I can explain my perspective on it in more detail in a bit, if you like. :-)
20:44:41 * lispy 's copy of TAPL is at the office or he'd check
20:45:05 <lispy> shachaf: I'm going to take a break and do something mindless right now, but Imay take you up on that before the weekend is out :)
20:45:16 <Eduard_Munteanu> Mine's by the bed but I can't be bothered. :P
20:45:18 <shachaf> lispy: OK.
20:45:28 * shachaf resists the temptation to write a lens tutorial.
20:45:37 <edwardk> shachaf: stop resisting
20:45:40 <edwardk> write one!
20:45:51 <shachaf> edwardk: Hmm, maybe.
20:45:56 <Eduard_Munteanu> So you don't have to write documentation? :P
20:46:00 <edwardk> yes
20:46:13 <edwardk> i'm sick of writing documentation
20:46:20 <dmwit> shachaf: You'll probably be doing a better thing for the Haskell community by writing a lens tutorial than by hanging out in here. =P
20:46:29 <lispy> zing!
20:46:39 <shachaf> dmwit: Pft. Lenses are the new monads.
20:46:39 * lispy disappears again
20:46:57 <shachaf> "number of lens tutorials surpasses the numbers of lens users" could actually be a realistic headline.
20:47:08 <bss03> randomclown: Sorry, just looked it up.
20:47:22 <bss03> randomclown: They consider Java stically typed, just that the type system is unsound.
20:47:50 <bss03> randomclown: Which, is arguably pretty close to being untyped, just think a lot more typing (on the keyboard).
20:48:42 <randomclown> bss03: lol typing
20:48:52 <Eduard_Munteanu> Well yeah, Erlang is funny in that department too: it's strongly-typed but the type system is so basic it doesn't really prevent disasters.
20:49:58 <bss03> Still, doing Java would probably be better than what I am doing, which is taking C code and turning it in to a pre-standard dialect of C++.
20:49:59 <Paprikachu> > let isPrime n = if n < 2 then False else not $ or $ map (\x -> n `mod` x == 0) $ takeWhile (\x -> x * x <= n) $ 2 : 3 : (scanl (+) 5 $ cycle [2,4]) in filter isPrime [1..100]
20:50:01 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
20:50:10 <Paprikachu> yay
20:50:16 <bss03> Still, I get to fix type errors every day. :P
20:52:01 <randomclown> bss03: it was
20:52:11 <randomclown> "type confusion", not "class confusion"
20:56:00 <dmwit> > let isPrime n = n >= 2 && and . map (\x -> n `mod` x /= 0) . takeWhile (\x -> x * x <= n) $ 2 : 3 : scanl (+) 5 (cycle [2,4]) in filter isPrime [1..100]
20:56:02 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
20:56:02 <lambdabot>         against inferred type ...
20:56:15 <dmwit> rookie mistake
20:56:34 <dmwit> > let isPrime n = n >= 2 && (and . map (\x -> n `mod` x /= 0) . takeWhile (\x -> x * x <= n)) (2 : 3 : scanl (+) 5 (cycle [2,4])) in filter isPrime [1..100]
20:56:36 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
21:02:59 <Paprikachu> > let isPrime n = n >= 2 && (and $ map (\x -> n `mod` x /= 0) $ takeWhile (\x -> x * x <= n) $ 2 : 3 : scanl (+) 5 $ cycle [2,4] in filter isPrime [1..100]
21:03:01 <lambdabot>   <no location info>: parse error on input `in'
21:03:13 <Paprikachu> > let isPrime n = n >= 2 && (and $ map (\x -> n `mod` x /= 0) $ takeWhile (\x -> x * x <= n) $ 2 : 3 : scanl (+) 5 $ cycle [2,4]) in filter isPrime [1..100]
21:03:14 <lambdabot>   Couldn't match expected type `[t]'
21:03:14 <lambdabot>         against inferred type `[a] -> [a]'
21:03:21 <Paprikachu> well fu then
21:03:31 <Paprikachu> /surrender
21:04:13 <Paprikachu> > let isPrime n = n >= 2 && (and $ map (\x -> n `mod` x /= 0) $ takeWhile (\x -> x * x <= n) (2 : 3 : scanl (+) 5 $ cycle [2,4])) in filter isPrime [1..100]
21:04:14 <lambdabot>   Couldn't match expected type `[t]'
21:04:15 <lambdabot>         against inferred type `[a] -> [a]'
21:04:39 <Paprikachu> > let isPrime n = n >= 2 && (and $ map (\x -> n `mod` x /= 0) $ takeWhile (\x -> x * x <= n) (2 : 3 : (scanl (+) 5 $ cycle [2,4]))) in filter isPrime [1..100]
21:04:40 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
21:05:04 <Paprikachu> > let isPrime n = n >= 2 && (and $ map (\x -> n `mod` x /= 0) $ takeWhile (\x -> x * x <= n) $ 2 : 3 : (scanl (+) 5 $ cycle [2,4])) in filter isPrime [1..100]
21:05:05 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]
21:05:18 <dmwit> ($) is causing more heartache than it's solving there, in my opinion. =)
21:05:37 <Paprikachu> the evaluation order is indeed confusing
21:05:44 <dmwit> nothing to do with evaluation order
21:05:46 <Paprikachu> but i hate typing parenthesis
21:06:09 <dmwit> But there's just as many parentheses in "(scanl (+) 5 $ cycle [2,4])" as there are in "scanl (+) 5 (cycle [2,4])".
21:06:14 <dmwit> So why bother with the ($)?
21:06:41 <Paprikachu> i didn't know that i don't have to write parenthesis around the second...
21:07:57 <lispy> Paprikachu: do you know the precedence rules for Haskell?
21:08:44 <lispy> Paprikachu: the first thing to know is that function application almost always binds tightest (the exceptions are few)
21:09:20 <dmwit> (The only exception is record syntax.)
21:09:32 <Jafet> infixl 10
21:09:56 <scooty-puff> in the various definitions for MonadFix in Control.Monad.Fix, is it possible to have any of the error "mfix ..." be evaluated?
21:10:08 <dmwit> The second thing to know is that $ binds loosest (the exceptions are few).
21:10:12 <Paprikachu> > let !!! = even in !!! 42
21:10:12 <lispy> dmwit: the other one is that data constructors are functions, which means they bind the way they should, but it can be suprising to beginners
21:10:13 <lambdabot>   <no location info>: parse error on input `!!!'
21:10:32 <dmwit> > let (!!!) = even in (!!!) 42
21:10:33 <lambdabot>   True
21:10:38 <dmwit> > let (!!!) = even in (42!!!)
21:10:40 <lambdabot>   True
21:11:14 <Paprikachu> you can use unary operators prefix as well as postfix?
21:11:35 <dmwit> No. You can use them prefix and infix, only.
21:11:49 <Paprikachu> what.
21:11:55 <dmwit> (Surprise!)
21:12:02 <Paprikachu> i dunno what infix means
21:12:15 <dmwit> Take a guess, just going by what the other two words mean.
21:12:17 <Paprikachu> aren't binary operators infix?
21:12:21 <dmwit> Yes.
21:12:24 <typoclass> > let f = (+2) in f 7
21:12:26 <lambdabot>   9
21:12:27 <dmwit> Unless they're prefix. =)
21:12:51 <Paprikachu> so how can there be infix for unary operators
21:12:55 <Paprikachu> that doesn't make sense
21:13:01 <typoclass> Paprikachu: ^^ if you write it in parens and leave out one of the arguments, you get a function that expects the missing argument
21:13:04 <dmwit> Unary operators are binary operators with no second argument. =)
21:13:31 <Paprikachu> so it's postfix, not infix
21:13:32 <Jafet> Binary? In my haskell?
21:13:46 <Paprikachu> you are misusing the word infix :P
21:13:55 <bss03> Jafet: class Bits n where
21:14:01 <dmwit> No, you are misunderstanding how unary operators fit into Haskell's syntax.
21:14:15 <gwern> @quote darn.*constant.*factors
21:14:16 <lambdabot> No quotes match. Take a stress pill and think things over.
21:14:17 <dolio> They don't. It's an extension.
21:14:18 <Paprikachu> that doesn't have to do anything with syntax
21:14:25 <dmwit> (And, yes, I'm abusing "infix" a little bit. But not much.)
21:14:29 <dmwit> It has everything to do with syntax.
21:14:32 <dmwit> Fixity is syntax.
21:14:46 <Paprikachu> the words prefix, infix and postfix are clearly defined.
21:14:54 <Paprikachu> that has nothing to do with haskell
21:15:03 <ivanm> "Warning: Note that reinstalls are always dangerous. Continuing anyway..." <-- `always' ?  Even if nothing depends on it?
21:15:10 <Jafet> Saying unary operators are postfix is like saying 0 = 1 because, hey, it' true in the trivial group
21:15:11 <dmwit> The words prefix, infix, and postfix are clearly defined for mathematical expressions. Haskell expressions are not mathematical expressions.
21:15:14 <Saizan> Paprikachu: basically you can use (a *) with any operators, even binary infix, and it'll desugar to (*) a
21:15:32 <shachaf> Binary infix operators? Things like .&. and .|. ?
21:15:38 <Paprikachu> even if haskell treats them that way, infix still means infix.
21:15:38 <Jafet> ivanm: remove that plastic packaging from your head, you're clearly suffocating
21:15:49 <Paprikachu> and not postfix.
21:15:53 <Saizan> shachaf: right
21:16:12 <ivanm> Jafet: huh?
21:16:59 * typoclass tries to think of any unary operators other than "-". maybe "!" with BangPatterns enabled
21:17:09 <Saizan> Paprikachu: sure, i'm just explaining the fact that there's a bit of confusion because haskell per se only supports infix operators, and postfix ones are kind of abusing the sections desugaring
21:17:19 <dolio> typoclass: Not an operator, really.
21:17:37 <Jafet> ! isn't an operator any more than ( is an operator
21:17:37 <Saizan> Paprikachu: a section is stuff like (a *) or (* a) where you pass only one argument to an infix operator
21:17:40 <dolio> - is the only one.
21:18:05 <bss03> typoclass: You can think of <$> as a unary operator. >:)
21:18:07 <Paprikachu> > !True
21:18:08 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:18:13 <bss03> > not True
21:18:15 <lambdabot>   False
21:18:18 <Paprikachu> what is !?
21:18:20 <pikhq> You can view all operators as unary operators.
21:18:42 <pikhq> They just map from a value to an unary function. >:)
21:18:43 <Paprikachu> :t (!)
21:18:45 <typoclass> Paprikachu: it's about controlling laziness and requires a compiler extension (BangPatterns)
21:18:45 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
21:19:11 * dmwit just typod "tips" as "types"
21:19:12 <Paprikachu> what's Ix? :|
21:19:15 <dmwit> conversion: complete
21:19:30 <Paprikachu> :t Ix
21:19:32 <lambdabot> Not in scope: data constructor `Ix'
21:19:34 <typoclass> Paprikachu: yeah, as you discovered, (!) is also a function, but that has 2 arguments (not 1)
21:19:49 <bss03> I just think of <$> as "liftF" (a -> b) -> (f a -> f b) more than as fmap ((a-> b) -> f a) -> f b, but they are isomorphic.
21:19:54 <ivanm> Paprikachu: Ix is the index class used by Data.Array
21:19:58 <ivanm> @src Ix
21:19:58 <lambdabot> class (Ord a) => Ix a where
21:19:58 <lambdabot>     range           :: (a,a) -> [a]
21:19:58 <lambdabot>     index           :: (a,a) -> a -> Int
21:19:58 <lambdabot>     inRange         :: (a,a) -> a -> Bool
21:19:58 <lambdabot>     rangeSize       :: (a,a) -> Int
21:20:22 <Paprikachu> what's <$>?
21:20:26 <typoclass> bss03: yeah, well you still need to put it in parens if you apply it to only one argument ...
21:20:30 <bss03> @src Applicative
21:20:31 <lambdabot> class Functor f => Applicative f where
21:20:31 <lambdabot>     pure  :: a -> f a
21:20:31 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
21:20:40 <bss03> @src (<$>)
21:20:41 <lambdabot> f <$> a = fmap f a
21:20:42 <ivanm> Paprikachu: inline fmap
21:20:48 <ivanm> *infix
21:21:09 <Paprikachu> > (+2) <$> [1..10]
21:21:10 <lambdabot>   [3,4,5,6,7,8,9,10,11,12]
21:21:20 <Paprikachu> i see
21:21:51 <bss03> typoclass: That's true of all haskell unary operators, I think.  Unary (-) has special syntax baked in to the language.
21:22:13 <dmwit> s/inline/infix/
21:22:42 <Paprikachu> what's the difference between fmap and map?
21:22:53 <ivanm> fmap works on other data types as well
21:22:58 <ivanm> > fmap (+2) (Just 3)
21:23:00 <lambdabot>   Just 5
21:23:05 <ivanm> @type fmap
21:23:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:23:06 <ivanm> @type map
21:23:07 <Paprikachu> oO
21:23:08 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
21:23:15 <Paprikachu> why would i want to do that
21:23:23 <ivanm> because it's very useful
21:23:25 <dmwit> Why would you want to prevent that?
21:23:30 <Paprikachu> i can just do (+2) (Just 3)
21:23:35 <ivanm> rather than needing a separate maybeMap, etc. function for every single type
21:23:36 <typoclass> bss03: yes, that's what i originally meant. "-" is special. other than that, haskell doesn't really have unary operators. it does of course have sections with 2-arg operators
21:23:37 <dmwit> > (+2) (Just 3)
21:23:39 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
21:23:39 <lambdabot>    arising from a use of...
21:23:39 <ivanm> Paprikachu: no you can't :)
21:23:55 <Paprikachu> > Just 3 + 2
21:23:56 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
21:23:57 <lambdabot>    arising from a use of...
21:23:59 <Paprikachu> gay
21:24:07 <ivanm> why is that happy?
21:24:15 <bss03> > Just $ 3 + 2
21:24:16 <Paprikachu> you can still define the operators
21:24:17 <lambdabot>   Just 5
21:24:33 <ivanm> Paprikachu: yes, but if already have a "Just 3" from somewhere else, how do you add 2 to the value?
21:24:48 <ivanm> > map (fmap (+2)) [Nothing, Just 3, Nothing, Just (-5)]
21:24:49 <lambdabot>   [Nothing,Just 5,Nothing,Just (-3)]
21:24:51 <dmwit> Paprikachu: Watch your language.
21:25:09 <Paprikachu> > let myPlus2 x =
21:25:10 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:25:11 <Paprikachu> whoops
21:25:16 <ivanm> Paprikachu: yes, you can define a function for every single type
21:25:24 <ivanm> this way you have one function for heaps of types
21:25:51 <ivanm> Paprikachu: should we have separate addInts, addFloats, addDoubles, etc. functions rather than just using + ?
21:25:51 <Paprikachu> > let myPlus2 Nothing = Nothing; myPlus2 (Just x) = Just $ x + 2 in myPlus2 $ Just 42
21:25:52 <lambdabot>   Just 44
21:26:18 <dmwit> Paprikachu: You can define that, yep. And then when you want to add three you need a new function... and then when you want to multiply by 5... and then when you want to append a string...
21:26:35 <Paprikachu> can't you just overload it for ints
21:26:38 <Paprikachu> or specialize
21:26:40 <dmwit> So eventually you just end up abstracting that as myFun f Nothing = Nothing; myFun f (Just x) = Just (f x) and by golly you've written fmap.
21:26:41 <Paprikachu> or whatever it's called
21:26:48 <ivanm> Paprikachu: why specialise for one thing and not for others?
21:26:51 <ivanm> @src Maybe fmap
21:26:51 <lambdabot> fmap _ Nothing       = Nothing
21:26:51 <lambdabot> fmap f (Just a)      = Just (f a)
21:27:03 <ivanm> @src Map fmap
21:27:03 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:27:08 <ivanm> @src Data.Map.Map fmap
21:27:09 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:27:11 <ivanm> bah
21:27:19 <Paprikachu> @src Data.Map fmap
21:27:20 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:27:39 <ivanm> @src (Either a) fmap
21:27:39 <lambdabot> Source not found. My brain just exploded
21:27:57 <ivanm> fmap f (Left l) = Left l; fmap f (Right r) = Right $ f r
21:28:18 <Paprikachu> what
21:28:32 <ivanm> > fmap (+2) (Left "boo!")
21:28:33 <lambdabot>   Left "boo!"
21:28:33 <Paprikachu> why isn't f called with l
21:28:37 <ivanm> > fmap (+2) (Right 3)
21:28:38 <lambdabot>   Right 5
21:28:41 <ivanm> @src Either
21:28:41 <lambdabot> Source not found. Just try something else.
21:28:49 <ivanm> data Either a b = Left a | Right b
21:28:53 <dmwit> Paprikachu: Try writing that function. Then check its type.
21:28:54 <Paprikachu> > fmap (+2) $ Left 3
21:28:55 <lambdabot>   Left 3
21:28:58 <ivanm> ^^ fmap only applies to the last type argument
21:29:04 <ryanos> brother ivan, what r u trying to do ?
21:29:12 <Paprikachu> so why is this type called Either
21:29:12 <Jafet> @protontorpedo
21:29:12 <lambdabot> and haskell is not a lisp. correct? holy shit then m learning haskell
21:29:18 <dmwit> Paprikachu: ...and then check the type of fmap when specialized to Either.
21:29:24 <ivanm> ryanos: demonstrate the usefulness of fmap to Paprikachu
21:29:30 <ryanos> :)
21:29:33 <ryanos> k
21:29:35 <Paprikachu> it should rather be called DoStuffOnlyOnRight
21:29:39 <ivanm> Paprikachu: it's either a Left value or a Right value
21:29:52 <Paprikachu> or LeftIsUseless
21:29:58 <dmwit> Jafet: very reminiscent of protontorpedo
21:30:08 <dmwit> Paprikachu: More like LeftIsAnErrorCondition
21:30:08 <ivanm> Paprikachu: depends on what you're using it for; you might want to do different things based upon the classification
21:30:20 <ivanm> dmwit: I've used Either for other cases than that...
21:30:27 * dmwit nods supportively
21:30:34 <ivanm> but yes, usually you use Either with the Left values being error ones
21:30:45 <ivanm> quite often you have Either String a
21:31:03 <ivanm> so it's like Maybe, but you can actually have an error message to say _why_ something failed rather than just knowing something failed
21:31:16 <dmwit> Oh, I like that angle.
21:31:25 <dmwit> Paprikachu: How come f isn't used when the constructor is Nothing?
21:31:41 <ivanm> hmmm, fail /= Left any more for Either, is it....
21:32:01 <ivanm> dmwit: oh, didn't think of that approach myself; was just explaining the usage of Either :)
21:32:09 <Paprikachu> because Nothing really means nothing
21:32:30 <dmwit> Paprikachu: What if we defined a new kind of Maybe that was like
21:32:39 <dmwit> data MaybeWithInt a = Nothing Int | Just a
21:32:45 <dmwit> Would you be okay with
21:32:56 <dmwit> fmap f (Nothing n) = Nothing n; fmap f (Just x) = Just (f x) -- ?
21:33:08 <dmwit> (Since, after all, f may not apply to Int's at all.)
21:33:39 <Paprikachu> since f doesn't take a Maybe
21:34:02 <Paprikachu> waht would you do with Nothing?
21:34:16 <dmwit> I gave the code above. Just read it and you'll have your answer. =)
21:34:35 <Paprikachu> ... other than returning Nothing
21:34:47 <dmwit> Why would you restrict yourself to avoid returning Nothing?
21:35:46 <Paprikachu> i asked, what else you would return.
21:35:52 <Paprikachu> returning Nothing makes perfectly sense
21:35:59 <dmwit> okay, great
21:36:08 <dmwit> Now I'm going to massage the type declaration just a tad more.
21:36:20 <dmwit> data MaybeWithSomeArbitraryExtra b a = Nothing b | Just a
21:36:24 <dmwit> And copy fmap from before:
21:36:35 <dmwit> fmap f (Nothing n) = Nothing n; fmap f (Just x) = Just (f x)
21:36:38 <dmwit> Is this still okay?
21:37:03 <dmwit> (After all, f may not apply to b's at all!)
21:37:19 <Paprikachu> why wouldn't it be okay?
21:37:23 <Paprikachu> Nothing is nothing
21:37:47 <dmwit> Alright, so just change the name MaybeWithSomeArbitraryExtra to Either; Nothing to Left; and Just to Right. Congratulations, you've just invented Either (and its fmap implementation)!
21:38:17 <Paprikachu> Left does have a value though
21:38:24 <dmwit> So does Nothing.
21:38:29 <Paprikachu> no, it doesn't
21:38:34 <dmwit> Sure it does.
21:38:47 <dmwit> data MaybeWithSomeArbitraryExtra b a = Nothing b | Just a -- see, it has a b value. =)
21:38:59 <Paprikachu> it's a type, not a value
21:39:07 <dmwit> ?src Either
21:39:08 <lambdabot> Source not found. Just what do you think you're doing Dave?
21:39:13 <dmwit> uh
21:39:16 <Jafet> This guy is pretty good
21:39:23 <dmwit> data Either b a = Left b | Right a -- I hope you can see the parallel here?
21:39:43 <dmwit> Or, in what sense does "Left" have a value, if "Nothing" doesn't?
21:39:49 <donri> Nothing is a value, of type Maybe a
21:39:55 <shachaf> data Either b a = Left b ∥ Right a
21:39:59 <shachaf> That might help you see the paralle.
21:40:07 <ivanm> donri: using a custom Maybe type that dmwit defined above
21:40:12 <dmwit> donri: Please read the context.
21:40:30 <dmwit> Locally, the term "value" has a nontraditional meaning.
21:40:57 <dmwit> ...also, locally, "Nothing" has a nontraditional meaning, as ivanm pointed out. =)
21:42:49 <Paprikachu> i'm confused.
21:43:00 <dmwit> I apologize.
21:43:12 <dmwit> Tell me how far you've believed me without becoming confused, and we'll start from there.
21:43:37 <Paprikachu> how can i define types with lambdabot?
21:43:44 <dmwit> You can't, unfortunately.
21:43:55 <shachaf> Paprikachu: It's possible to evaluate Haskell outside of lambdabot.
21:44:08 <shachaf> (I know that might come as a bit of a surprise.)
21:44:12 <Paprikachu> guess what, that's what i'm doing right now
21:44:12 <ivanm> let's back up; we started this with Paprikachu not understanding the point of the Functor class, right?
21:44:37 <ivanm> hang on, wasn't shapr working on something that would make explaining this kind of stuff easier for GSoC?
21:44:53 <dmwit> yes, ghclive
21:44:58 <Paprikachu> data Foo x
21:45:12 <Paprikachu> that declares Foo as a type taking a type parameter, right?
21:45:23 <dmwit> So far, so good.
21:45:23 <ivanm> yes
21:45:28 <Paprikachu> so when i write
21:45:35 <Paprikachu> data Foo x = Nothing x
21:45:48 <Paprikachu> you can construct it from a Nothing of type x?
21:45:53 <dmwit> Ah, not quite.
21:46:03 <dmwit> What that really means is:
21:46:18 <ivanm> Paprikachu: Nothing <a value of type `x'> is a value of type `Foo x'
21:46:25 <dmwit> There's a new function (Nothing :: x -> Foo x), and a new pattern for using in case statements.
21:46:32 <ivanm> so Nothing 3 :: Foo Int
21:48:11 <Paprikachu> but any type could be x
21:48:24 <ivanm> x could be any type, yes
21:48:33 <dmwit> Yes, "x" is determined by what argument you pass to "Nothing".
21:48:46 <ivanm> ` Nothing (+) ' is of type (Num a) => Foo (a -> a -> a)
21:49:12 <Paprikachu> how do i create such a Foo object?
21:49:13 <dmwit> :t Left "here's an example of type Either String a"
21:49:15 <lambdabot> forall b. Either [Char] b
21:49:24 <ivanm> Paprikachu: as I just did: Nothing (+)
21:49:33 <dmwit> :t Left 3 -- an example of type Either Integer a
21:49:35 <lambdabot> forall t b. (Num t) => Either t b
21:49:43 <dmwit> well =)
21:49:52 <dmwit> :t Left True -- an example of type Either Bool a
21:49:53 <lambdabot> forall b. Either Bool b
21:49:54 <ivanm> modulo type variable names :)
21:50:06 <shachaf> WHAT ABOUT: Nothing (+) :: Foo (forall a. Num a => a -> a -> a)
21:50:13 <Paprikachu> i only get errors in ghci :|
21:50:33 <ivanm> shachaf: why are you shouting? :s
21:50:46 <shachaf> ivanm: CAPS LOCK DAY
21:50:48 <Paprikachu> is the 'x' before the '=' the same 'x' after it?
21:50:50 <ivanm> Paprikachu: probably because you can't just define your Foo type like that as it clashes with Maybe
21:50:57 <dmwit> Paprikachu: Yes, they're connected.
21:51:15 <ivanm> Paprikachu: try doing ` :type Left 3 ' in ghci
21:51:17 <dmwit> Paprikachu: And I recommend choosing a different name than "Nothing" in ghci; perhaps you'd like
21:51:22 <dmwit> data Foo x = Bar x
21:51:42 <Paprikachu> isn't the first x a type and the second a value?
21:52:09 <ivanm> Paprikachu: "a value of Foo with a type variable x is defined as Bar with a value of type x"
21:52:36 <Paprikachu> ah
21:53:01 <Paprikachu> with Bar it works now.
21:53:30 <Paprikachu> > let data Foo x = Bar x deriving Show in Bar 42
21:53:32 <lambdabot>   <no location info>: parse error on input `data'
21:53:39 <ivanm> you can't define data types in ghci
21:53:47 <Paprikachu> *lambdabot
21:53:49 <Paprikachu> :P
21:53:55 <ivanm> or in lambdabot :)
21:54:08 <ivanm> sorry, thought you were copy/pasting an error into lambdabot
21:54:09 <dmwit> You can do it in ghci.
21:54:14 <dmwit> With a sufficiently advanced ghci.
21:54:15 <ivanm> oh, right, as of 7.6.1
21:54:19 <Paprikachu> i know, i already did x)
21:54:33 <Paprikachu> Prelude> data Foo x = Bar x deriving Show
21:54:35 <Paprikachu> Prelude> Bar 42
21:54:35 <dmwit> Just drop the "let".
21:54:37 <Paprikachu> Bar 42
21:54:39 <dmwit> right
21:54:42 <rwbarton> 7.4! get with the times :)
21:54:58 <Paprikachu> GHCi, version 7.4.1
21:57:20 <Paprikachu> so when i define a type constructor with the same name as a type, i can't use that type anymore?
21:57:32 <ivanm> rwbarton: oh? I must have gotten my versions mixed up; never really needed to define a data type in ghci (I just wish that ghci could remember "sessions" so I didn't need to repeatedly go and re-do the last <n> things in history after editing and reloading a file :s)
21:57:33 <Paprikachu> such as with data Foo x = Nothing x
21:57:44 <ivanm> Paprikachu: you can't re-use constructors from other types
21:57:47 <rwbarton> if only ghci had ctrl-O
21:57:55 <rwbarton> or if only haskeline had it, I suppose
21:57:57 <ivanm> rwbarton: what would that do?
21:58:06 <shachaf> haskeline is a cheap plastic imitation of readline. :-(
21:58:20 <shachaf> It gets all my readline reflexes just slightly wrong.
21:58:22 <Paprikachu> but ghci accepts it
21:58:30 <ivanm> shachaf: as opposed to an expensive plastic imitation?
21:58:45 <rwbarton> in readline, if you go back in command history to a command and hit ctrl-O it is like hitting enter except it then automatically brings up the following command in the command history afterwards
21:59:03 <rwbarton> so you can ctrl-O ctrl-O ctrl-O your way through a series of commands in history
21:59:20 <shachaf> shachaf@carbon:~$ ls -l .ghc/ghci_history
21:59:20 <shachaf> lrwxrwxrwx 1 shachaf shachaf 9 Sep  6 15:26 .ghc/ghci_history -> /dev/null
21:59:25 <ivanm> rwbarton: oooohhhhh
21:59:29 <Paprikachu> Prelude> data Foo x = Nothing x deriving Show
21:59:30 * shachaf does not like history in ghci.
21:59:31 <Paprikachu> Prelude> Nothing 42
21:59:32 <Paprikachu> Nothing 42
21:59:37 <ivanm> shachaf: oh? how come?
21:59:38 <shachaf> rwbarton++ for telling me about ^O
21:59:49 <ivanm> Paprikachu: yeah, but ghci is a bit weird like that
21:59:54 <dmwit> Paprikachu: That is arguably a bug. It should give you an ambiguity error instead.
21:59:55 <Paprikachu> and Nothing alone gives me an error
21:59:56 <ivanm> as you can re-define stuff using let
22:00:26 <dmwit> Anyway, the "Nothing alone gives me an error" thing is because there's no (good) way to serialize functions as String.
22:00:28 <ivanm> dmwit: my guess it's intended to let you override other data types you defined in ghci, but it's not smart enough to tell "this is overriding a constructor from Prelude"
22:00:40 <Paprikachu> > Nothing
22:00:42 <lambdabot>   Nothing
22:01:00 <ivanm> Paprikachu: just like doing `show' alone will give you an error
22:01:35 <Paprikachu> show takes a parameter
22:01:44 <Paprikachu> Nothing doesn't
22:02:12 <ivanm> Paprikachu: except you've overriden Nothing in your ghci session
22:02:21 <ivanm> so as far as ghci knows, Nothing _does_ take a parameter!
22:02:30 <Paprikachu> but what about the old Nothing?
22:02:41 <dmwit> It's gone.
22:02:47 <donri> >>> show
22:02:47 <donri> <() -> [Char]>
22:02:49 <donri> hmmm! ;)
22:02:58 <Paprikachu> what's >>>
22:03:03 <donri> my ghci prompt
22:03:15 <Paprikachu> ah, lol.
22:03:49 <ivanm> donri: how did you get that?
22:03:51 <donri> that way you can copy-paste ghci sessions for haddock
22:04:05 <donri> ivanm: you mean the show instance?
22:04:12 <ivanm> yeah
22:04:16 <donri> @hackage show
22:04:16 <lambdabot> http://hackage.haskell.org/package/show
22:04:17 <ivanm> I know how to set the prompt :p
22:04:53 <Paprikachu> > (+)
22:04:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
22:04:54 <lambdabot>    arising from a use...
22:05:07 <Paprikachu> i thought you can print functions
22:05:15 <ivanm> nope
22:05:19 <donri> >>> (+)
22:05:19 <donri> <Integer -> Integer -> Integer>
22:05:33 <ivanm> Paprikachu: @src has some function definitions built-in, if that's what you're after
22:05:40 <Paprikachu> > show (+)
22:05:40 <donri> Paprikachu: i have ghci set up to import an instance for Show (a -> b)
22:05:41 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
22:05:41 <lambdabot>    arising from a use...
22:05:48 <donri> http://hackage.haskell.org/packages/archive/show/0.4.1.2/doc/html/src/ShowFun.html
22:06:11 <ivanm> donri: figured it was using Typeable
22:06:22 <ivanm> and then ghci defaulting has show have type () -> String
22:06:22 <donri> sneaky typeable
22:06:38 <ivanm> of course, that's wrong as Show is meant to generate a valid Haskell expression... ;)
22:06:50 <donri> duno if that's a rule
22:07:16 <donri> not true for Doc ;)
22:07:32 <ivanm> well, it's the _intent_ of Show/Read
22:07:49 <ivanm> and some people have expressed dissapointment about the Show instance for Doc, etc. :)
22:08:03 <donri> i like it
22:08:08 <ivanm> it also breaks down in cases like Data.Map where you don't export the constructors
22:08:25 <ivanm> in general though, it's meant to be an actual Haskell expression for debugging purposes
22:08:29 <donri> well the show instance for Map is a valid haskell expression ...
22:08:43 <ivanm> yeah, but you normally import it qualified
22:08:47 <rwbarton> "undefined :: Integer -> Integer -> Integer"
22:08:49 <donri> assuming the keys and values show instances are
22:08:59 <Paprikachu> > Data.Map.singleton 4 5
22:09:00 <lambdabot>   Not in scope: `Data.Map.singleton'
22:09:04 <ivanm> it's really fun when you have a Seq containing a Set of Maps or something
22:09:07 <ivanm> all those fromLists! :p
22:09:25 <ivanm> > M.singleton 4 5
22:09:26 <lambdabot>   fromList [(4,5)]
22:09:28 <donri> -XOverloadedLists
22:09:45 <ivanm> ^^ is that a Map, a Set of tuples, a Seq of tuples, etc.?
22:09:53 * ivanm glares at donri 
22:10:03 <donri> same is true for Text etc
22:10:13 <donri> actually same is true for numbers ... :p
22:10:16 <ivanm> if we get OverloadedLists, I don't think it should apply to things like Map, Set, etc. where ordering doesn't matter
22:10:18 <ivanm> donri: heh
22:10:20 <ivanm> true
22:10:27 <ivanm> but for numbers it's less of an issue
22:10:46 <ivanm> for Text it's annoying if you haven't set -XOverloadedStrings in ghci
22:10:55 <ivanm> (and then when you do you often need to add explicit type sigs)
22:11:07 <dmwit> ivanm: It's not really about Map's constructors being hidden. Importing any other type with its constructors qualified would have the same caveats.
22:11:11 <ivanm> I also often have code fail because it's designed for Ints, but ghci defautls to Integer
22:11:18 <ivanm> dmwit: sure, that's what I meant
22:11:20 <donri> also generated Show instances don't care about qualification either AFAIK
22:11:25 <ivanm> I said that earlier
22:11:30 <ivanm> donri: yeah
22:11:37 <dmwit> No, I mean...
22:11:41 <ivanm> it'd be nice if they automatically did add qualification
22:11:47 <ivanm> dmwit: oh, right
22:11:59 <dmwit> "Nothing" isn't a valid expression if you've only got "P.Nothing" in scope or something like that.
22:11:59 <Ralith> ivanm: but there's no way to specify a syntax which doesn't have ordering
22:12:03 <ivanm> import Prelude hiding (Maybe(..)); then show a Maybe value
22:12:08 <dmwit> Which has nothing to do with whether Maybe's constructors are hidden or not.
22:12:15 <dmwit> exactly
22:12:31 <ivanm> Ralith: I meant that I can understand [foo, bar] being overloaded for Seq or something, but not for Maps or Sets
22:13:05 * hackagebot montage 0.1 - Riak Resolution Proxy  http://hackage.haskell.org/package/montage-0.1 (ErinDahlgren)
22:13:29 <donri> i'm half considering writing a QQ that parses case arrows into a Map
22:14:05 <Ralith> ivanm: I get where you're coming from, but is the unavoidable ordering inherent in any syntax sufficient reason not to permit any syntax overload for unordered containers?
22:14:14 <Ralith> donri: cases alternatives are ordered too, though.
22:14:22 <Ralith> aren't they?
22:14:37 <donri> well so is fromList :P
22:14:44 <ivanm> dmwit: it's just more often a problem I think in those cases where the module is more likely to be imported qualified
22:14:46 <ivanm> I recently had a ~ 1 million character long output from show that I had to manually go through and add qualifications to to be able to debug a dodgy function :s
22:15:13 <donri> actually not sure case arrows would work, keys are not patterns
22:15:38 <donri> [map| _ -> "nonsense" |]
22:16:00 <donri> but the idea was to get to reuse haskell-src-exts
22:16:35 <dmwit> ivanm: ugh, I'm so sorry
22:17:19 <donri> ivanm: sexp-show might help if you're using emacs
22:17:33 <donri> doesn't qualify, but makes navigating large show output easier
22:18:22 <donri> i think perhaps better than qualification would be type-annotated showing?
22:18:37 <donri> "fromList [] :: Map k v"
22:19:20 <donri> i wonder if we could whip that up with generics
22:21:12 <donri> the point of course is to annotate it "deeply"; "fromList [(1 :: Int, "one" :: String) :: (Int, String)] :: Map Int String"
22:21:35 <donri> noisy, but then things like sexp-show could present it better
22:21:54 <fenton> when inside main, i call a function that returns an IO String, but I'd like to pass just a string to another function...possible?  I mean how do i get out of the 'tainted' world back into the pure world from inside main?
22:22:48 <donri> fenton: short answer is 'fmap'
22:24:00 <prophile> the shorter answer is <$>
22:24:09 <Cale> fenton: Think about:  do s <- getLine; print (reverse s)
22:24:10 <Cale> fenton: reverse :: String -> String
22:24:12 <fenton> donri: ok, hmmm...
22:24:13 <Cale> You don't necessarily need fmap
22:33:45 <fenton> huh
22:33:45 <fenton> interesting...
22:33:46 <fenton> really seems like reverse is taking an IO String...
22:33:48 <fenton> Cale: thx...
22:33:56 <rwbarton> @google haskell introduction to IO
22:33:56 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
22:33:56 <lambdabot> Title: Introduction to IO - HaskellWiki
22:34:03 <fenton> rwbarton: thanks, reading now...
22:34:32 <ivanm> donri: tried that, it didn't
22:34:53 <ivanm> it was too long for it IIRC :s
22:35:25 <Cale> fenton: When you run the action of type IO String, you'll get a String as the result.
22:35:25 <Cale> fenton: which you can then apply pure functions to in order to get additional stuff and potentially do some output based on that.
22:35:26 <Cale> fenton: Inside a do-block, the line  v <- x  means "run the action x and name its result v"
22:35:26 <Cale> If x :: IO t, then v :: t
22:35:26 <Cale> fenton: Make sense?
22:36:22 <chare> If you have an object oriented program what exactly is the way you would rewrite it in Haskell?
22:37:03 <dmwit> The question is too vague to be meaningful. Sorry.
22:37:49 <fenton> Cale: so the <- extracts the t from the IO monad...hmmm...almost like that naughty: unsafe :: IO a -> a
22:37:51 <chare> you saying that you basically have to rethink and rearchitect the program each case by itself
22:38:17 <dmwit> I believe that is true whether the original program is object-oriented or not, yes.
22:39:36 <dmwit> fenton: That's only an intuition.
22:39:53 <chare> Ok maybe i can rephrase the question, Java programs rely on dynamic dispatch, what does Haskell do instead?
22:39:54 <dmwit> fenton: What's really happening is that the rest of the block is being put even deeper into IO.
22:40:10 <Jafet> There aren't many truly object-oriented programs anyway.
22:40:35 <donri> fenton: well, the do-expression must still result in an IO action, so you can't escape the "taint". here, we do that by 'print'ing the string.
22:40:52 <dmwit> chare: Why don't you just start writing some Haskell programs?
22:41:04 <donri> fenton: we could also have 'return'ed the string, which would make the whole thing still an IO String (but reversed)
22:41:06 <dmwit> Ultimately that's going to align your neurons more helpfully than any amount of English in this channel can.
22:41:34 <Jafet> Obligatory link http://www.vex.net/~trebla/humour/Nightmare.java
22:43:28 <fenton> Cale, dmwit, donri: thank you all for your explanations...I'm still not there, but definitely closer, thanks for you patience with a Haskell newbie!!!
22:46:11 <dmwit> I can't tell whether that's one troll succesfully avoided or one potential newbie turned off of Haskell.
22:46:36 <dmwit> Maybe troll isn't the right term, since that sort of implies evil intent that I don't want to imply.
23:03:53 <Jafet> I thought we formally embraced trolls
23:03:55 <pdxleif> How do I get the "contained" value back out of a newtype?
23:03:55 <pdxleif> Just trying to get the "string" out of this: http://hackage.haskell.org/packages/archive/swish/0.8.0.3/doc/html/src/Swish-QName.html#LName
23:03:56 <pdxleif> I tried pattern matching, and it tells me "Data constructor 'LName' not in scope".
23:03:56 <pdxleif> I could just call "show" on it, I guess?
23:03:58 <Jafet> Try reading the documentation
23:04:38 <pdxleif> Oh, there's a getLName function. :/
23:04:47 <pdxleif> LName -> T.Text
23:06:21 <Jafet> The whole point of a newtype is to hide the definition.
23:12:41 <mysticc> If I update my ghc from 7.4 to 7.6 do I need to reinstall all my cabal packages ?
23:13:32 <donri> yes
23:13:57 <Jafet> You should in fact install them, not reinstall them
23:16:53 <mysticc> donri: Jafet: Yeah. Is there a way of installing the packages that were previously installed (not manually one by one)
23:16:55 <Jafet> Oh, .ghc already sorts by version.
23:17:00 <Jafet> ghc-pkg list | sed something something | xargs cabal install
23:17:00 <Jafet> Uh, well, you need to install the new ghc in between that
23:17:01 <mysticc> Jafet: I had lots of packages previously installed (around 100). I installed the ghc 7.6. Now I see none of the packages installed.
23:17:01 <rwbarton> correct
23:17:05 <rwbarton> I think "cabal install world" is supposed to do this
23:17:32 <rwbarton> though I don't know whether that will always pick reasonable versions
23:18:45 <jmcarthur> whenever i upgrade ghc i usually go ahead and install a few packages i know i will end up using off the top of my head and then just do the rest on demand
23:19:43 <rwbarton> ~/.cabal/world seems to be approximately a list of what packages I've manually installed
23:20:15 <Jafet> Where on earth is the documentation for cabal-install, anyway?
23:21:00 <dada-cetacean> does haskell have something analogous to mathematica's Table[] function?
23:21:59 <Jafet> What is the Table[] function?
23:21:59 <jmcarthur> what does that function do?
23:23:19 <dada-cetacean> oh, map
23:23:23 <dada-cetacean> haha
23:24:59 <Jafet> (Table is much more convoluted than map)
23:26:09 <rwbarton> looks like a list comprehension with ranges
23:47:36 <Ghoul> anyone know if GHC still cannot optimize enumerators properly
23:59:36 <fenton>  /filter add joinquit * irc_join,irc_part,irc_quit *
