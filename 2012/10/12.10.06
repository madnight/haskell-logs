00:00:02 <maukd> Ghoul: no
00:00:04 <dada_cetacean> so f[x_,y_,z_] @@ {1,2,3} = f[1,2,3]
00:00:08 <maukd> Ghoul: what is that supposed to do?
00:00:13 <Ghoul> Would it be correct if bUcs2 was a type
00:00:26 <maukd> Ghoul: it can't be a type; it starts with a lowercase letter
00:00:34 <Ghoul> I know, I have some work to do
00:00:37 <maukd> but even then: no
00:00:41 <Ghoul> Oh okay
00:00:52 <Ghoul> So I can't say typeclass = type \:
00:01:00 <maukd> of course not
00:01:09 <maukd> a typeclass is a class (set) of types
00:01:09 <rwbarton> you should probably forget about the word "type class" for a while
00:01:17 <rwbarton> until you understand types
00:01:20 <jfischoff> data_cetaesean: not really
00:01:34 <maukd> Ghoul: what other programming languages do you know?
00:01:47 <fenton> ivanm: thx, i'll check
00:01:48 <Ghoul> C
00:01:49 <Ghoul> C++
00:01:59 <Ghoul> python, php, perl
00:02:01 <Ghoul> java
00:02:30 <maukd> hmm
00:03:04 <jfischoff> data_cetacean: look at uncurry
00:03:39 <maukd> I could mention that typeclasses have some similarities to java interfaces, but it might be misleading :-)
00:04:26 <shachaf> Imagine what you would do if Haskell didn't have type classes at all.
00:04:28 <shachaf> Then do that.
00:04:38 <maukd> use ocaml?
00:04:57 <shachaf> OCaml doesn't have type classes either.
00:05:35 <maukd> but it has modules
00:05:49 <ivanm> shachaf: didn't Oleg do a post about how if you only had one type class you could simulate all other ones?
00:05:49 <maukd> and functors :-)
00:06:35 <maukd> Ghoul: in C terms, are you looking for a typedef?
00:07:38 <fenton> Ghoul: type class is a more generic classification.  example: generic: car, specific: toyota, honda, etc...
00:08:45 * shachaf wonders whether there's any context in which that analogy is helpful...
00:08:48 <fenton> Ghoul: floats (1.2) and ints 2 can each be respectively added (+) but they are different types, but belong to the same type class: number!
00:08:56 <dada_cetacean> jfischoff currying is where f x y = (f x) y, right?
00:09:08 <dada_cetacean> (i.e. (f x) is a function by itself)
00:09:26 <dada_cetacean> I should go read Gentle Introduction again
00:09:28 <maukd> dada_cetacean: yes
00:09:42 <maukd> heh, "gentle"
00:09:53 <shachaf> dada_cetacean: No, currying is converting the function f :: (A,B) -> C to the function g :: A -> (B -> C)
00:10:01 <shachaf> It's what the function "curry" does.
00:10:31 <ivanm> dada_cetacean: you're thinking of partial application I think
00:11:10 <fenton> shachaf: isn't partial application (if you only apply 1 param at the same time) effectively just like currying?
00:11:38 <dada_cetacean> I'm trying to define a function, "headOver": headOver f [] = f
00:11:39 <dada_cetacean>  ; headOver f (x:xs) = headOver (f x) xs ; but GHCi tells me I'm trying to construct an infinite type, what went wrong?
00:12:00 <shachaf> fenton: No.
00:12:13 <rwbarton> you're trying to construct an infinite type
00:12:14 <dada_cetacean> is there a way to designate my f as a partially applied function?
00:12:24 <shachaf> dada_cetacean: What's the type of headOver?
00:13:01 <shachaf> rwbarton: That's some impressive detective skills.
00:13:22 <rwbarton> hey, it is possibly the first time anyone has ever gotten that message and had it be what they were trying to do
00:13:35 <dada_cetacean> shachaf not sure, I should probably learn type declarations though
00:13:38 <rwbarton> or at least, it is pretty cloes
00:13:55 <maukd> headOver :: b@(a -> b) -> [a] -> b
00:14:22 <shachaf> Remember when sorear wrote that type checker that supported infinite types?
00:14:29 <lightquake> y
00:14:31 <maukd> ocaml -rectypes?
00:14:39 <Ghoul> fenton: thanks
00:14:48 <Ghoul> maukd: figured it out, dw :)
00:14:53 <shachaf> http://www.haskell.org/pipermail/haskell-cafe/2006-December/020072.html
00:14:56 <Ghoul> But I do have a question about enumerators
00:15:10 <Ghoul> let's say in one enumerator I have something called Crouch
00:15:18 <Ghoul> if I have the same thing in another enumerator will it conflict
00:15:27 <Ghoul> Like, if I call it the same name.
00:15:36 <rwbarton> there's no such thing as "enumerator"
00:15:37 <maukd> your use of "enumerator" is bizarre
00:15:42 <rwbarton> but, yes it will conflict
00:15:55 <shachaf> Enumerator, alligator!
00:16:03 <Ghoul> Aw
00:16:03 <maukd> interpretation: "if I have the same data constructor in multiple types, will they conflict?"
00:16:04 <Ghoul> reall?
00:16:06 <Ghoul> *really
00:16:11 <Ghoul> data EntityAction = Crouch | Uncrouch | LeaveBed | StartSprint | StopSprint
00:16:12 <rwbarton> you should just say "let's say in one data type I have something [a data constructor] called Crouch"
00:16:15 <Ghoul> data PlayerAnimation = None | SwingArm | Damaged | LeaveBed | Eating | Crouch | Uncrouch
00:16:26 <maukd> interpretation correct!
00:16:29 <rwbarton> yes really
00:16:38 <Ghoul> Aw
00:17:05 <shachaf> Ghoul: What behavior do you expect/hope for?
00:17:12 <rwbarton> otherwise when you saw Crouch, how would you know whether it was an EntityAction or a PlayerAnimation
00:17:24 <Ghoul> I thought it might just depend on the type
00:17:33 <Ghoul> like how it would if it were C
00:17:36 <rwbarton> that *is* the type
00:17:37 <maukd> enum foo { MEOW, MOO, BARK };  enum bar { LEAF, BRANCH, BARK };  // also conflicts
00:19:12 <pharaun> not always but sometime i do like EACrouch | EAUncrouch, etc... and then PACrouch | PAUncrouch
00:19:23 <pharaun> not beautiful but it does the trick for making it clear
00:19:32 <pharaun> but usually better to try to find a better name
00:20:26 <johnw> maukd: C++11 has scoped enums, btw
00:20:49 <shachaf> johnw: I thought we were talking about C.
00:21:03 <johnw> it was just an fyi
00:21:05 <maukd> oh, good. just what I've always wanted in C++: more features
00:21:17 <johnw> maukd: they're in the pipeline!
00:21:25 <johnw> C++14 is underway
00:21:30 <pharaun> c++ will eventually acquire *all* of the features
00:21:31 <johnw> err, no, c++17
00:21:45 <johnw> i'm waiting for us to accept Haskell as the new templating language
00:21:53 <shachaf> c++0xb
00:51:18 <theplanet> is it possible to compile and install AND UNINSTALL if you compile it yourself?
00:51:56 <theplanet> for some reason i want the latest binaries
00:58:53 <johnw> theplanet: to what exactly do you refer?
01:01:59 <theplanet> johnw, why ghc
01:02:07 <theplanet> what else would i be asking about in #haskell
01:02:23 <johnw> a cabal project you've cabal install'd
01:02:33 <johnw> which is how I read your question
01:02:50 <johnw> the easiest way to do what you want with ghc would be to use hsenv
01:02:59 <theplanet> hsenv?
01:03:00 <johnw> then you can setup a separate ghc/cabal for each binary version
01:03:05 <johnw> @google hsenv
01:03:06 <lambdabot> https://github.com/Paczesiowa/hsenv
01:03:15 <theplanet> damnit
01:03:28 <theplanet> what if I don't use hsenv
01:03:32 <johnw> example: hsenv --ghc=/path/to/ghc-7.3.20111105-i386-unknown-linux.tar.bz2
01:03:35 <theplanet> will i run into trouble?
01:03:37 <rwbarton> or "./configure --prefix=$HOME/tmp/ghc-7.6 ; make install ; rm -rf $HOME/tmp/ghc-7.6"
01:03:38 <johnw> you start using it :)
01:04:00 <theplanet> rwbarton, that does it ?
01:05:50 <theplanet> i dont know why ubuntu ships  with a ghc from 2009
01:06:59 <rwbarton> how old is your ubuntu
01:07:10 <rwbarton> mine has "Version: 7.4.1-1ubuntu2"
01:07:20 <theplanet> wait, that's my debian
01:07:26 <rwbarton> say no more
01:07:42 <rwbarton> I tend not to bother with the distro ghc on debian
01:08:28 <theplanet> The source distribution needs an installed GHC (version 6.12 at least). If your platform isn't currently supported with a binary distribution, then you'll need to consult the section on Porting GHC in the Building Guide
01:08:32 <theplanet> damn!
01:08:39 <rwbarton> oh yeah
01:08:59 <theplanet> source haskell needs binary haskell to compile source to binary
01:09:00 <rwbarton> well you can just use a binary download
01:09:12 <rwbarton> unless you want a HEAD version of ghc
01:09:19 <rwbarton> (and maybe even then?)
01:09:47 <theplanet> ubuntu server uses 7.4.1
01:10:00 <theplanet> HEAD?  no i don't think i want a head
01:10:05 <rwbarton> debian stable has ghc 6.12 so you can apt-get install that to build ghc HEAD from source hopefully
01:10:14 <theplanet> HEAD?
01:10:19 <theplanet> ís tht what i want?
01:10:21 <rwbarton> like the current development version
01:10:23 <rwbarton> how should i know
01:10:35 <rwbarton> but if you want a released version, the binary downloads are generally more convenient
01:10:51 <rwbarton> I assumed the only reason to install from source was that you wanted a development version
01:11:16 <rwbarton> if you don't know whether you want ghc HEAD, you probably don't
01:15:22 <theplanet> i want the latest
01:15:31 <theplanet> but i feel like compiling
01:15:36 <johnw> the latest *release*?
01:15:43 <johnw> as in, 7.6.1?
01:15:46 <theplanet> yes
01:15:48 <theplanet> the latest release
01:15:55 <johnw> i build releases from source too
01:15:59 <johnw> some of us are just bent like that
01:16:10 <theplanet> some ;)
01:16:52 <mparkes> so do I...  errr portage takes care of that :)  Recently switched over to gentoo.
01:17:12 <johnw> i just recently started asking homebrew to do my installs
01:17:17 <johnw> so I actually think it grabs the binary tarball
01:17:27 <theplanet> i'd go with freebsd over gentoo ;/
01:17:30 <johnw> yeah, it does
01:18:03 <johnw> ah, well, in gentoo you build everything
01:18:06 <mparkes> gentoo has old ghc version... I had to unmask 7.2+
01:18:23 <theplanet> whatever unmask entails
01:19:08 <mparkes> yeah, just tell portage (package manager) to download the latest src for compile instead of what is marked as stable...  Think it was 6.* something
01:20:30 <theplanet> why can't ubuntu have that feature
01:20:47 <theplanet> mparkes, you  *did* have to install 6.12 before though
01:20:50 <theplanet> i mean, compile it
01:20:53 <mparkes> yes
01:21:06 <theplanet> that's pretty damning
01:21:23 <mparkes> i'm on ubuntu on my laptop... i have 7.0.3
01:21:48 <Jafet> Wait, people actually use debian stable?
01:22:06 <theplanet> what, me?
01:22:10 <mparkes> on gentoo it was 6.12
01:31:17 <rhubarb> Jafet: People use Debian anything?
01:31:34 <theplanet> ubuntu people use debian
01:31:43 <rhubarb> They don't matter on the grand scale of things.
01:31:54 <theplanet> what's that mean
01:32:04 <rhubarb> It means that they do not matter on the grand scale of things.
01:32:12 <theplanet> what's it imply
01:32:33 <rhubarb> It implies that you're too clever to ascertain what the ramifications are.
01:33:09 <theplanet> what do you use?
01:33:23 <JoeyA> @hoogle [IO a] -> IO (Either SomeException a)
01:33:23 <lambdabot> Control.Exception.Base tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
01:33:23 <lambdabot> Control.Exception tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
01:33:23 <lambdabot> Control.OldException tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)
01:33:31 <Ghoul> Kay let's play a game
01:33:36 <Ghoul> golf code gogo :D https://gist.github.com/3844340
01:33:43 <rhubarb> Why?
01:33:54 <johnw> tl;dr
01:33:59 <Ghoul> i've made it as compact as possible.
01:34:12 <johnw> i prefer to golf <10 lines
01:34:16 <JoeyA> Is there a function in some library that spawns multiple threads, and when one of them finishes, kills the others and returns the result?
01:34:32 <Ghoul> lol dw :P
01:34:38 <johnw> JoeyA: like a tortoise race?
01:35:25 <Ghoul> can an enumerator be equal to "Nothing"
01:35:30 <JoeyA> Yes.  But I found a real-world use case that doesn't involve heating the CPU and throwing away one of the results.
01:35:40 <Ghoul> like data a = blah | blah
01:35:44 <johnw> Ghoul: a Maybe Enum can be :)
01:35:52 <Ghoul> a = Just asdf ... or Nothing
01:35:56 <Ghoul> Oh
01:36:11 <JoeyA> Namely, spawn a pair of worker threads, one for receiving, and one for sending.
01:36:23 <JoeyA> (over a network connection)
01:36:32 <JoeyA> If one of them fails, kill all the workers.
01:37:02 <johnw> JoeyA: you want bound lifetimes
01:37:14 <JoeyA> What do you mean?
01:37:25 <johnw> their lifespan is connected
01:37:29 <johnw> if one is ended, they all end
01:37:31 <JoeyA> Right
01:37:41 <JoeyA> Control.Concurrent.Async has race :: IO a -> IO b -> IO (Either a b), but that's only for two threads.
01:37:52 <JoeyA> I can implement it myself, I'm just wondering if someone else already has.
01:38:14 <theplanet> The Glorious Glasgow Haskell Compilation System, version 7.4.1
01:38:22 <theplanet> well.. i'm still compiling
01:39:00 <johnw> i'd make a tie :: ThreadId -> ThreadId -> IO () function, and then fold it over a list of ThreadIDs
01:40:04 <JoeyA> But there isn't a function for waiting for a thread to finish.
01:40:10 <johnw> tie would have to spawn a manager thread that wait on an MVar for the kill code
01:40:26 <johnw> once it gets it, it kills the thread it's managing
01:40:28 <JoeyA> What I'm planning to implement has this signature: [(w, IO a)] -> IO (w, Either SomeException a)
01:40:49 <johnw> ah, yes, maybe that would be better
01:41:02 <johnw> my solution would create a chain
01:41:08 <JoeyA> It spawns all these threads.  When one of them finishes, it forks a thread to kill the threads, and returns the winner.
01:41:38 <JoeyA> The reason we fork a thread to kill the threads is that 'throwTo' blocks until the exception is delivered.
01:41:57 <JoeyA> Sometimes, the exception is not delivered (in particular, when the action is making an FFI call).
01:42:22 <JoeyA> But we don't have to worry about that when doing network stuff, right?  Oh wait, Windows...
01:51:06 <vas> 0_o
02:04:04 <theplanet> hmm what is to be found inside the libghc* packages
02:04:09 <bam_> http://www.reddit.com/r/programming/comments/x2e3e/functional_programming_is_a_ghetto/c5j6yuu?context=3
02:04:17 <bam_> What does #haskell think of this crititism?
02:04:30 <bam_> "That's what doesn't make sense about Haskell. It is impossible to do something as simple as memoizing a recursive function without constructing a custom made immutable data structure for the function. In fact if you are clever enough you can publish a paper on what it takes to memoize functions in a language like Haskell. Trivial change in one language, publishable work in Haskell. Who in their right mind would consider that a langua
02:04:58 <bam_> Cale ^
02:05:32 <theplanet> what language does that commenter recommend then?
02:06:34 <JoeyA> Google "haskell memoize"
02:06:44 <JoeyA> The top two results suggest making your own data structures :(
02:07:13 <JoeyA> I wrote a simple memo utility in about 20 lines, but it's buried somewhere in reddit
02:07:23 <tdammers> JoeyA: but then, it's haskell. Making your own data structures is easy and cheap.
02:07:38 <quicksilver> is memoization somehow easier in other languages?
02:07:54 <quicksilver> isn't the point just that people somehow *expect* memoization to be automatic in haskell, and are disappointed?
02:07:54 <JoeyA> Here it is: http://www.reddit.com/r/programming/comments/crgxs/do_i_really_want_to_be_using_a_language_where/c0v8jvf
02:08:05 <quicksilver> it's not harder in haskell than in other languages as far as I can see
02:08:49 <startling> how would I find the first <h1> in an Html?
02:08:49 <theplanet> JoeyA, phd-level you are ;)
02:08:51 <sanjoyd> JoeyA: unsafePerformIO!!
02:09:19 <JoeyA> I wrote that two years ago, not long after I picked up the language :P
02:09:47 <fmap> "addition of a hash map and an if statement" shouldn't be harder in haskell than in "all the languages"
02:10:35 <tdammers> maybe I'm being naive here, but I'd just throw in a State monad over a Map to memoize that factorial function
02:10:44 <startling> fmap: I'm not sure that addition is defined for those types
02:10:55 <JoeyA> tdammers: Good solution.
02:11:02 <theplanet> JoeyA, you know haskell does fib the fastest of any language out there though
02:11:24 <tdammers> theplanet: blunt statement
02:12:05 <startling> in fact, how do I search an Html at all?
02:12:06 <theplanet> tdammers, well, it's really fast. and doing the 200th doesn't take a very long time at all
02:12:18 <tdammers> I believe that much
02:12:29 <tdammers> I just don't buy that it would be impossible to beat that using, say, C
02:12:38 <tdammers> just probably really really hard
02:13:20 <sanjoyd> How hard depends on whether you want unbounded integer.
02:13:24 <sanjoyd> *integers
02:13:29 <sanjoyd> If you'
02:13:47 <sanjoyd> re using an Int, the naive, non-recursive factorial in C should be at least as fast as one on Haskell.
02:13:48 <alpounet> startling, there are a few libraries for that
02:13:55 <alpounet> tagsoup for example
02:13:55 <sanjoyd> Yeah, Data.MemoTrie
02:13:55 <startling> > let fibs@(_:fs) = 0:1: zipWith (+) fibs fs in fibs !! 200
02:13:56 <lambdabot>   280571172992510140037611932413038677189525
02:14:04 <tdammers> you can do unbounded integers in C, too
02:14:08 <tdammers> it's just more work
02:14:26 <sanjoyd> tdammers: yeah, which is why it will be harder to match Haskell's perf.
02:14:36 <startling> alpounet, I've already got an Html from blaze-html, though
02:14:39 <tdammers> yes
02:14:44 <alpounet> ohhhh
02:14:53 <alpounet> i don't know then
02:15:08 <startling> I *could* render and parse it if that's really what it takes, though. ;)
02:15:56 <tdammers> well, what exactly do you want to search for? text content only, or html structure?
02:16:14 <Jafet> @quote undoubtedly
02:16:14 <lambdabot> _pizza_ says: i think Haskell is undoubtedly the world's best programming language for discovering the first few dozen numbers in the Fibonacci sequence over IRC
02:16:53 <JoeyA> Surely you can do better with APL
02:17:09 <startling> tdammers: html structure. I want to find what's in <h1>...</h1>
02:17:10 <theplanet> heh
02:17:32 <JoeyA> Or not... http://dfns.dyalog.com/n_fibonacci.htm
02:22:21 <tdammers> startling: and you already have a Html from blaze? Can't you just like recursively walk through that or something?
02:22:50 <startling> tdammers: I don't know, can I?
02:23:55 <tdammers> not really sure myself, but the data structure looks like it, superficially at least
02:24:07 <tdammers> http://hackage.haskell.org/packages/archive/blaze-markup/0.5.1.0/doc/html/Text-Blaze-Internal.html#t:MarkupM
02:26:15 <osa1> do we have a tool to generate FFI bindings automatically ?
02:26:58 <startling> seems like it might be difficult because of the foralls, though. hmm
02:27:04 <startling> maybe I should use something like xmlhtml
02:29:32 <theplanet> JoeyA, how easy would it be to implement that in haskell?
02:29:49 <JoeyA> Implement what?
02:30:13 <theplanet> the stuff from taht link
02:30:20 <JoeyA> Which link?
02:30:35 <theplanet> forget it
02:30:37 <JoeyA> The fibonacci one?
02:30:43 <theplanet> yeah
02:30:53 <AfC> startling: xmlhtml is pretty nice, if it fits your use case {shrug}
02:31:38 <JoeyA> I don't code APL, so I don't know.
02:31:54 <theplanet> what is apl?
02:32:12 <theplanet> i've never heard of it
02:32:27 <JoeyA> It's a programming language that looks like this: ↑1 ⍵∨.∧3 4=+/,¯1 0 1∘.⊖¯1 0 1∘.⌽⊂⍵
02:32:41 <theplanet> that sucks!
02:32:46 <JoeyA> http://en.wikipedia.org/wiki/APL_%28programming_language%29
02:32:46 <bitonic> ahhh, APL.
02:32:52 <JoeyA> Crazy-terse
02:32:55 <bitonic> dyalog APL is actually free for students
02:33:07 <JoeyA> theplanet: That implements Conway's Game of Life.
02:33:09 <theplanet> my keyboard doesnt know that
02:33:17 <JoeyA> (the example I pasted)
02:33:24 <bitonic> theplanet: they give you software to type that
02:34:18 <startling> JoeyA: I thought you were joking
02:34:48 <ivan> http://www.youtube.com/watch?v=a9xAKttWgP4 conway
02:37:38 <tdammers> wow
02:37:45 <tdammers> even brainfuck is more readable than that
02:38:55 <flux> tdammers, I suppose in a way you are correct, this brainfuck implementation of game of life looks like this: http://www.linusakesson.net/programming/brainfuck/index.php
02:39:34 <lpvb> Suitable solution to Ghoul's problem (above)?
02:39:37 <lpvb> http://hpaste.org/75860
02:40:28 <Ghoul> Flaggables are great
02:40:49 <Ghoul> because it means they can be reused for the flags in mobs and such
02:40:51 <Psycho_pr> Would Haskell be good for a CRM program (including backend and UI, let's say on Mac)?
02:40:52 <lpvb> I'm wondering if there's a better way to serialize enums + flags
02:48:49 <theplanet>  weird
02:48:54 <theplanet> i ran into greenspuns 10th
02:49:50 <GnomeStoleMyBike> > 64 * 0.2
02:49:51 <lambdabot>   12.8
02:50:06 <GnomeStoleMyBike> > 65 * 0.8
02:50:07 <lambdabot>   52.0
02:50:17 <GnomeStoleMyBike> > 26 * 0.8
02:50:18 <lambdabot>   20.8
02:53:43 <startling> I want to do something like "data Tree n = Tree [Tree (n - 1)]". what extensions can do this?
02:54:28 <startling> or "data List n a = Cons a (List (n - 1) a)"
02:55:48 <maukd> data S n; data Z; data List n a where Cons :: a -> List n a -> List (S n) a
02:56:51 <startling> is that just gadts? surely there's a library with type-encoded Nats?
02:58:57 <elemir> startling: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/promotion.html
02:59:10 <elemir> System FC pro is awesome
02:59:16 * hackagebot blaze-html-truncate 0.1.0.2 - A truncator for blaze-html  http://hackage.haskell.org/package/blaze-html-truncate-0.1.0.2 (MarcelRuegenberg)
03:00:05 <startling> interesting
03:01:07 <elemir> http://research.microsoft.com/en-us/um/people/simonpj/papers/ext-f/promotion.pdf <- full paper about current ghc type system
03:04:16 * hackagebot blaze-html-truncate 0.2.0.1 - A truncator for blaze-html  http://hackage.haskell.org/package/blaze-html-truncate-0.2.0.1 (MarcelRuegenberg)
03:12:12 <plantd> are these libghc the same stuff you download with cabal
03:15:19 <hollow_spine> hello
03:31:50 <cornihilio> I am still trying to get this to work, but it seems like I still really don't know what I'm doing. This is what I have so far: https://gist.github.com/3844565. So far I have yet to find out why it gives up after the first failed parse; I would think that my usge of my 'howMany' applicative function would have fixed that.
03:45:15 <absence> when building a project that has both .hs and .c files using cabal, how do i make it generate stub .h files from the FFI exports?
03:47:34 <plantd>  what is that supposed to do cornihilio
03:52:05 <cornihilio> plantd: it's supposed to parse a pcap file and print out the number of packets it's read.
03:56:23 <absence> oh, never mind. got it working :)
03:57:08 <cornihilio> my main problem is I don't understand how to do recursion with a stream. If parsing a packet fails half way through and returns nothing, how am I supposed to tell the difference between that nothing and the nothing I get at the end of the stream?
03:57:28 <cornihilio> I can't seem to find any general info on dealing with parsing a stream, even without attoparsec.
04:04:38 <hpaste> niklasb pasted “findM” at http://hpaste.org/75863
04:05:29 <niklasb> hi, I just wondered about the above code snippet. I expected the findM function based on filterM to behave exactly the same as findM', but it doesn't. Why is there no lazy evaluation here?
04:07:45 <hpaste> gsps pasted “install msgpack-rpc” at http://hpaste.org/75864
04:08:47 <gsps> hi everyone! I'm stumped by something that should appear to be quite simple: Installing the msgpack-rpc package via cabal install msgpack-rpc. Building fails and I have no idea where to start looking for a solution (except for the obvious google paste-search which didn't turn up anything useful). Could someone give me a hand?
04:09:19 * hackagebot geniplate 0.6.0.2 - Use template Haskell to generate Uniplate-like functions.  http://hackage.haskell.org/package/geniplate-0.6.0.2 (LennartAugustsson)
04:35:15 <cornihilio> with the trace command, how do I print out the type of something, if I don't know what it is?
04:37:10 <cornihilio> also, how am I supposed to be able to extract data from the result returned by a parser? http://hackage.haskell.org/packages/archive/attoparsec/0.8.3.0/doc/html/Data-Attoparsec.html#t:Parser
04:39:26 <fmap> cornihilio: what do you mean by not knowing what the type of thing is?
04:41:21 <fmap> cornihilio: you can use typeOf function from Data.Typeable, but there is probably another solution
04:52:07 <niklasb> cornihilio: as for your second question, Parser is a monad. You can use `parse` or `parseOnly` to apply a parser to a string and get the result
04:54:21 * hackagebot regex-tdfa-text 1.0.0.1 - Text interface for regex-tdfa  http://hackage.haskell.org/package/regex-tdfa-text-1.0.0.1 (KidoTakahiro)
04:59:19 <cornihilio> thank you!
05:06:03 <plantd> compiling the ghc is just not enough if you want cabal to tag along is it
05:06:19 <plantd> it has to be done in a specific way or something
05:06:26 <plantd> or are cabal and ghc versions compatible up to a point
05:36:04 <Skola> are there programs for visualizing Haskell program execution?
05:38:44 <gienah> Skola: there's threadscope
05:38:49 <Philonous> How can I deprecate a package on hackage?
05:40:25 <Skola> thanks, will check it out
05:47:20 <zzzzzbogus> I've just discovered that http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/win32-dlls.html has wrong command lines. ghc -shared -dynamic -o Adder.dll Adder.o StartEnd.o and ghc -no-hs-main -dynamic -o tester Tester.cpp Adder.dll.a should be used to call Haskell from C++ on Windows. Feel free to fill a documentation bug report :)
05:47:30 <merijn> Skola: Do you mean actual visualisation or just any sort of feedback on execution (i.e. for debugging)?
06:01:55 <yawnt> hellow .. best book to jump start into haskell?
06:02:11 <merijn> mm_freak: Is there a netwire introduction somewhere already?
06:02:16 <merijn> yawnt: Learn You a Haskell
06:02:31 <merijn> yawnt: Real World Haskell is also nice, but I tend to recommend as a follw up to LYAH
06:02:34 <merijn> @where lyah
06:02:35 <lambdabot> http://www.learnyouahaskell.com/
06:02:36 <merijn> @where rwh
06:02:37 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:03:23 <yawnt> thanks merijn
06:03:30 <yawnt> i'll go with learnyouahaskell
06:03:32 <merijn> yawnt: Although "jump starting" in Haskell can be hard without previous functional experience (SML/ocaml, or maybe some Lisp)
06:03:49 <merijn> LYAH is a nice comprehensive intro, though :)
06:04:50 <yawnt> merijn: i've done some clojure and erlang
06:05:33 <yawnt> it's just that i didn't fall in love with them like it happened with other languages :(
06:05:36 <yawnt> so i'm trying haskell
06:06:08 <merijn> yawnt: Oh, then you can try mixing RWH and LYAH. RWH focuses on more practical things, but glosses over some important details (IMO), LYAH is more comprehensive and introductory, but it can take a while before you can write anything useful
06:07:32 <yawnt> merijn: i don't have that much experience though.. i just wrote some code .. so i think i'll go with LYAH :)
06:07:51 <lambada_calculus> hello
06:08:37 <lambada_calculus> is there a mapM_ that works from right to left?
06:10:24 <Jeanne-Kamikaze> mapM_ foo . reverse ?
06:10:24 <lambdabot> Jeanne-Kamikaze: You have 1 new message. '/msg lambdabot @messages' to read it.
06:10:52 <Lajjla> LYAH sort of makes you feel like you're in kindergarten
06:10:58 <Lajjla> Which honestly feels very nice.
06:11:00 <simon> Lajjla, I'm not?!
06:11:02 <simon> Lajjla, yes.
06:11:22 <lambada_calculus> lyah is a great book
06:11:43 <yawnt> Lajjla: i just wish there was a .mobi
06:11:46 <Lajjla> I disagree, it is quite awful, like everything.
06:11:50 <yawnt> 34$ is damn expensive
06:11:50 <Lajjla> Everything is awful.
06:11:59 <Lajjla> yawnt, it's online too is it?
06:12:05 <yawnt> yeah
06:12:08 <shapr> SHAZAM!
06:12:09 <Lajjla> I never got people who like books over monitors
06:12:12 <yawnt> but i hate reading stuff on the computer
06:12:23 <yawnt> Lajjla: it tires my eyes
06:12:24 <lambada_calculus> why is it awful
06:12:26 <yawnt> and i get headache
06:12:27 <Lajjla> e-paper I could understand, but why would you give up the ability to change fonts, spacing, font size etc to your own praeferences?
06:12:40 <merijn> yawnt: LYAH is also sold on paper (and probably e-book)
06:12:41 <shapr> Lajjla: Have you tried Real World Haskell?
06:12:45 <Lajjla> lambada_calculus, because I would've done it slightly differently I guess.
06:13:11 <Lajjla> shapr, no I have not, I might read it, I probably also consider it awful, not that I cosnider Haskell an awful langauge, everything is awful, I am awful, so are you most likely, well met stranger.
06:13:25 <shapr> I'm not awful :-(
06:13:31 * shapr sniffles
06:13:57 <Lajjla> shapr, do you live in a first world country?
06:14:11 <Lajjla> And do you donate anything but the bare minum you need to survive to people less fortunate hmm?
06:14:13 <shapr> I write Haskell. I organize Haskell communities!
06:14:29 <Lajjla> Haskell is a luxury, some people don't have clean drinking water!
06:14:29 <lambada_calculus> after I learn enough Haskell from LYAH, I might read Real World Haskell
06:14:30 <lambada_calculus> is that one also good?
06:14:33 <shapr> I started the Boston Area Haskell User's Group.
06:14:52 <shapr> I organized EuroHaskell and the first AngloHaskell.
06:14:58 <shapr> I started The Monad.Reader
06:15:03 <Lajjla> Yes, but Haskell is awful.
06:15:13 <shapr> I disagree.
06:15:16 <Lajjla> Shouldn't awful like mean 'something you are in awe for' actually/
06:15:33 <shapr> English makes about as much sense as Dutch.
06:15:36 * shapr disappears
06:15:42 <merijn> shapr: I beg to differ
06:15:57 <yawnt> uh
06:15:59 <yawnt> i found a mobi
06:16:05 <merijn> shapr: Dutch makes more sense in its text-to-pronunciation mapping :p
06:16:06 <Lajjla> shapr, I don't, the problem with Haskell is its clumsy syntax, no proper type hierarchy, no dependent typing, unicode support is far to be found and encoding strings as lists of characters is a big mistake.
06:16:08 <byorgey> Lajjla: it used to.
06:16:22 <shapr> Lajjla: Actually, unicode support is pretty good.
06:16:25 <merijn> Lajjla: {-# LANGUAGE UnicodeSyntax #-}
06:16:30 <shapr> Lajjla: I think you're reading an older version of your script.
06:16:36 <Lajjla> merijn, having grown up speaking Dutch has left me with a sore throat honestly.
06:16:38 <lambada_calculus> I thought Haskell had unicode built in?
06:16:45 <Lajjla> merijn, I don't mean that
06:16:52 --- mode: ChanServ set +o merijn
06:16:52 <Skola> merijn, as regards your question earlier: it would be cool to be able to "step through" functions
06:16:53 <merijn> lambada_calculus: It does
06:16:54 <Lajjla> I mean in the String datatype.
06:17:03 <nicoo> lambada_calculus: IIRC, it does
06:17:14 <shapr> Lajjla: Yes, Unicode support is pretty good.
06:17:25 <merijn> Skola: There's Debug.Trace which lets you embed IO prints in pure expressions for debugging/stepping functionality
06:17:31 <Lajjla> No, it's simply not there. Haskell strings are not unicode aware in any way.
06:17:37 <Lajjla> They are a 'list of characters'.
06:17:39 <merijn> Skola: Not interactive, but still
06:17:45 <Skola> okay, still sounds nice
06:17:46 <Skola> thanks
06:17:50 <merijn> Lajjla: Haskell Char are defined as unicode characters
06:18:04 <Lajjla> merijn, yes, I know, and do you know what unicode aware means?
06:18:05 <merijn> Skola: This is obviously completely unsafe and unsuitable for production code :)
06:19:00 <ksf> Lajjla, Char is a unicode codepoint.
06:19:06 <Lajjla> > "jörgen" == "jörgen"
06:19:06 <ksf> encodings are a different matter.
06:19:07 <lambdabot>   False
06:19:16 <Lajjla> ksf, that is what I mean with unicode aware
06:19:29 <Lajjla> > length "jörgen
06:19:30 <lambdabot>   <no location info>:
06:19:30 <lambdabot>      lexical error in string/character literal at end o...
06:19:33 <ksf> well, normalise the buggers.
06:19:34 <Lajjla> > length "jörgen"
06:19:35 <lambdabot>   7
06:19:42 <Boreeas> eww
06:19:49 <Lajjla> ksf, there are more issues than combinging characters
06:20:28 <Lajjla> For instance, in the arabic script, each character has an initial, medial, final and isolate form, these are all at different unicode codepoints, a unicode aware string splitting function resolves this when you split a string.
06:20:52 <Lajjla> I have yet to find a string library for Haskell which is unicode aware, maybe it exists, but I couldn  find it.
06:20:56 <ksf> icu?
06:21:08 <nicoo> Lajjla: This isn't about Unicode, but about internationalization
06:21:21 <nicoo> Quite different
06:21:25 <hiptobecubic> merijn, Skola what about ghc's debugging? You can definitely step through functions
06:21:29 <Lajjla> That's what you call 'unicode aware', unicode specifies how this should be processed
06:21:39 <Lajjla> And string operations are said to be 'unicode aware' if they follow those rules.
06:21:50 <merijn> hiptobecubic: Sure, but I've never used it so I can't really tell people how to use it :p
06:22:00 <Lajjla> But I'm looking into icu right now.
06:22:22 <nicoo> Lajjla: I seriously doubt Unicode specifies behaviour of split and such
06:22:23 <ksf> might be that the bindings are incomplete
06:22:42 <Lajjla> nicoo, it defines how certain operations on string must behave to be called 'unicode aware'
06:22:45 <nicoo> But if you have a link towards the relevant part of the standard, why not
06:23:18 <Lajjla> Let me see if I can find it
06:24:31 <Lajjla> Doesn't seem like unicode actually offers their standard in free form.
06:24:45 <nicoo> Ouch
06:24:51 <Lajjla> Girls like diamonds eh.
06:25:12 <Lajjla> I alsow onder who would ever pay for this: http://en.wikipedia.org/wiki/ISO_2, it does cost money to view that standard
06:26:30 <merijn> It's not really possible to turn an IO action into an STM action, is it?
06:27:35 <ksf> merijn, trampoline it.
06:27:39 <ksf> that is, return IO.
06:28:02 <ksf> there's also a module that does exactly that with some additional guarantees.
06:28:11 <merijn> ksf: Oh? What's it called?
06:28:25 <ksf> http://hackage.haskell.org/package/stm-io-hooks
06:28:32 <ksf> at least I think that's it.
06:29:19 <ksf> usually join . atomically should suffice, though.
06:30:10 <buffer_overflow> hello
06:30:30 <merijn> :t join . atomically
06:30:32 <lambdabot> Not in scope: `atomically'
06:30:45 <merijn> :t join . Control.Concurrent.STM.atomically
06:30:46 <lambdabot> Couldn't find qualified module.
06:31:30 <fmap> @hoogle IO a -> STM a
06:31:31 <lambdabot> GHC.Conc.Sync unsafeIOToSTM :: IO a -> STM a
06:31:31 <lambdabot> GHC.Conc unsafeIOToSTM :: IO a -> STM a
06:31:31 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
06:31:35 <merijn> ksf: I don't that does what I need
06:31:46 <ksf> join . atomically :: STM (IO a) -> IO a
06:31:48 <merijn> don't know, even
06:32:14 <ksf> join . atomically $ return (putStrLn "hello")
06:32:41 <ksf> where "return" is STM
06:33:58 <merijn> Ok, so my problem is: To implement polling multiple Chan's I'm using TChan's so I can do "readTChan x `orElse` readTChan y", but now I also have a blocking read inside IO (i.e. socket) that I want to do. But I don't think there's a nice way to mix that with the STM and IO doesn't have a nice way to block on multiple sources, afaik (otherwise I might as well block in IO instead of STM and use Chan's)
06:34:29 <byorgey> @remember EvanLaforge Then we can tell them about how we had to walk in the snow both ways uphill fighting space leaks with bare hands while they just have to read about it.
06:34:29 <lambdabot> It is stored.
06:34:32 <ksf> make another thread
06:35:03 <ksf> and send what you read over a TChan
06:35:54 <ksf> the IO backend uses epoll under the hood, and will wake up the thread that can proceed effectively.
06:36:17 <merijn> ksf: Yeah, that's what I was thinking
06:36:30 <merijn> ksf: But at this rate I'll be spawning 10 threads per client >.>
06:36:35 <ksf> so what?
06:36:48 <merijn> Feels like there should be a more elegant way
06:36:52 <ksf> combinatorrent does similar, or worse.
06:48:31 <kartoffelbrei> haskell threads are really lightweight, though. I'm not talking about forkOS.
06:49:38 <mm_freak> merijn: for netwire 4 see the haddocks of the Control.Wire module
06:50:00 <mm_freak> you'll find a quickstart tutorial there
06:50:15 <merijn> mm_freak: Ah, that might be the issue
06:50:23 <merijn> hackage only lists 3.1 for me :p
06:50:32 <mm_freak> it's not on hackage yet
06:50:39 <mm_freak> darcs get http://darcs.ertes.de/netwire/
06:51:19 <merijn> Time to install darcs, I guess :p
06:51:27 <mm_freak> =)
06:52:02 <merijn> Or implement a Mercurial-to-darcs converter ;)
06:55:19 <hiptobecubic> What makes darcs nice compared to git?
06:56:55 <kartoffelbrei> i like the user interface better
06:57:15 <kartoffelbrei> also that patch set way of thinking about your commits is kinda nice
06:58:49 <merijn> Git's user interface is just horrible, though. So that's easy to beat :p
07:00:04 <osfameron> it has some niceties compared to mercurial -- automatically paging its output for example
07:03:34 <merijn> osfameron: Mercurial has a builtin extension for that
07:03:43 <merijn> It's just not enabled by default
07:04:23 <parcs`> kartoffelbrei: forkOS is not what you think it is
07:04:31 <osfameron> ah, that's handy to know.  Really struggling having to use Mercurial at the moment :-(
07:05:05 <merijn> osfameron: There's a bunch of desirable builtin extensions you might want to check out
07:05:33 <merijn> Such as paging, colorisation of diffs, etc
07:05:52 <merijn> osfameron: You can check out my .hgrc at https://github.com/merijn/dotfiles/blob/master/hgrc
07:06:03 <osfameron> really, I should read up on it.  It's for a short-term contract though, and I've not made the time to invest in doing much more than just checking in code.
07:06:06 <osfameron> ta
07:06:17 * osfameron bookmarks
07:06:25 <merijn> osfameron: The mq and record extension are probably also things to look at coming from git
07:06:45 <merijn> (the other worthwhile ones should have obvious descriptions in the config file)
07:07:13 <merijn> record lets you interactively select parts of files to add to commits (not at a line level like git, though)
07:07:27 <osfameron> ah, it gives you an index?
07:07:45 <merijn> And MQ gives you reorderable/updateable patch queues that are managed by the repo but not yet "committed"
07:08:08 <osfameron> I don't think the latter is a core git workflow is it?
07:08:09 <merijn> So they're used for the sort of history rewriting/rebasing kind of local work you'd do in git
07:08:25 <osfameron> ah
07:10:32 <merijn> You *can* edit/rebase hg history, but it's not as easy as git (mostly because it is frowned upon) MQ let you have local patches which you can revise/update etc. before committing, so doing that sort of exploratory committing is nicer using MQ
07:12:46 <merijn> osfameron: Or you can work locally using git and use hg + hg-git to convert and push to the hg repository if you have to collaborate with colleagues using hg ;)
07:13:19 <Expez> Is it considered poor style to use DoAndIfThenElse?
07:13:40 <merijn> It works rather well, all my github repo's are actually hg repos. Although your colleagues might be annoyed that git doesn't properly report file moves if you move files frequently
07:13:42 <osfameron> DoAndIfThenElse?
07:14:28 <Expez> osfameron: Allows you to keep the then and else clause on the same indentation level as the if clause
07:14:55 <merijn> Expez: Personally I prefer indenting the then/else, but no clue what the overall opinion is
07:15:33 <osfameron> Expez: is it a compiler flag then?
07:15:40 <Expez> Seems to be part of haskell 2010, but cabal just told me to 'use -XDoAndIfThenElse'. Pretty sure I've used it before without adding a flag.
07:16:04 <merijn> Expez: You can probably add a pragma at the top
07:16:07 <Expez> When just building with GHC it turns on the flag behind the scenes
07:16:13 <merijn> {-# LANGUAGE DoAndIfThenElse #-}
07:16:51 <Expez> Just wanted to know if I should stop it, even if it looks more natural to me
07:17:18 <merijn> Expez: I'd just use whatever you like for your own code and follow the existing style for other people
07:17:22 <merijn> 's code
07:17:45 <Expez> Aight, thanks
07:19:26 <niteria> is warp still the fastest haskell web server?
07:19:39 <niteria> a lot of benchmarks are from 2 years ago
07:22:19 <merijn> niteria: I suspect it is
07:26:02 <Abraxas> if i want to know the type signature of a helper function which uses a variable of the top level function (therefore cannot easily made a top-level function itself), how can i do it?
07:26:41 <sipa> Abraxas: add a type signature :: () to it
07:27:14 <sipa> the compiler will tell you the right type in the error message
07:28:39 <merijn> one of the right types :p
07:29:47 <Abraxas> nice
07:29:47 <buffer_overflow> is all data  in haskell an algebraic data type??
07:30:24 <merijn> buffer_overflow: Maybe, depending on how you define all and haskell
07:30:25 <pordan30> consider functions and primitive types
07:30:38 <merijn> oh, and data
07:30:38 <dolio> All data is data.
07:30:42 <buffer_overflow> ah right
07:30:43 <dolio> Functions are not data.
07:30:57 <mm_freak> (or wait for GHC to have holes…  yes, they are working on that)
07:30:58 <Abraxas> but why can't i explicitly write that same type signature?
07:31:01 <buffer_overflow> I thought functions in a functional programming language were data
07:31:11 <merijn> mm_freak: I thought it was already mostly finished
07:31:17 <merijn> buffer_overflow: They're *values*, but not data
07:31:21 <mm_freak> merijn: it is
07:31:30 <buffer_overflow> ah right
07:31:35 <merijn> mm_freak: I'm so sad holes aren't in 7.6 :(
07:31:35 <mm_freak> but it's not in any release yet…  it's in HEAD
07:31:39 <pordan30> i didn't realise that value and data aren't synonymous
07:32:06 <mm_freak> pordan30: data is something that lives in memory…  a value is more of a conceptual thing
07:32:12 <buffer_overflow> data are objects in memory, whereas values are something else
07:32:27 <Abraxas> "Couldn't match expected type `a0 -> [a] -> [a]' with actual type `()'"
07:32:39 <Abraxas> if i replace the signature, i get another error
07:32:43 <buffer_overflow> in haskell, everything ultimately boils  down to a value thanks to  referential transparency
07:32:48 <mm_freak> think of it this way:  data in memory can represent different values
07:32:58 <mm_freak> and a function may not live in memory at all
07:33:03 <dolio> That isn't how I was using "data" but whatever.
07:33:25 <pordan30> that makes sense
07:33:34 <mm_freak> i think that 'data' is just unfortunately named in haskell
07:33:35 <fmap> i guess there isn't a chance holes will be in 7.6.2?
07:33:45 <dolio> The way I was using it would pretty much trivially make it synonymous with algebraic data types.
07:33:48 <mm_freak> fmap: doubt it, more like 7.8
07:33:52 <fmap> =(
07:34:01 <EvanR2> data being called data is like the one place where a basic pedestrian name made it through
07:34:02 <mm_freak> but ask in #ghc
07:34:05 <Abraxas> "Couldn't match type `a0' with `a1'"
07:34:05 <EvanR2> one of
07:35:38 <Abraxas> is it not possible to write a type signature for a helper function?
07:35:56 <Abraxas> will the compiler always complain about an explicit one, i mean
07:36:23 <monochrom> 1. yes.  2. no
07:36:55 <buffer_overflow> its always  good style to  write out the signatures, except in the main function
07:37:19 <monochrom> eh? no exception.
07:38:09 * merijn often doesn't write signatures for helpers unless they're of significant complexity
07:38:45 <mroman> Hm.
07:39:55 <mroman> I think I just have to accept that Java is ~3-5 times faster than Haskell
07:39:55 <pordan30> what is the difference between "data" and a value of an inductively defined (family of) types, then? is it just coincidence that such values are data, because they /must/ be stored in memory on, e.g., actual computers?
07:41:06 <Abraxas> if i were able to link you to the code i am referring to...it's a comment on RWH
07:41:44 <merijn> Abraxas: Maybe paste the failing code to hpaste?
07:41:50 <Abraxas> btw...is that one of the worst books on haskell?
07:42:31 <Abraxas> there seem to be a ton of mistakes and half-truths in the online version
07:43:37 <merijn> Oh?
07:44:11 * merijn mostly got the idea that some of the covered libraries are by now a bit old/out-of-date considering the haskell communities aggressive deprecation strategy :p
07:44:22 <monochrom> I don't see tons. I only see a few, and only because every book is outdated the day it is printed
07:44:37 <hpaste> Abraxas pasted “helper type signature not working” at http://hpaste.org/75871
07:45:31 <Abraxas> every other line there is a comment more or less saying "this is completely wrong"
07:45:54 <monochrom> every type signature comes with an implicit "for all"
07:46:01 <Abraxas> at least in that chapter
07:46:26 <monochrom> you are looking at, firstly, myFilter :: for all a, (a->Bool) -> [a] -> [a]. so far so good
07:46:48 <merijn> oh, I think I see :)
07:47:04 * merijn suspects a solution involving ScopedTypeVariables :p
07:47:07 <monochrom> but next, you are looking at step :: for all a, a -> [a] -> [a]. which is another way to say, step :: for all t, t -> [t] -> [t]. this is clearly not what you want
07:47:55 <merijn> Abraxas: The problem is that the a in step is not the same as the a in the top level signature. As a result the type of "step" is wrong, because the initial a is decided by the top level function
07:48:00 <Abraxas> yeah, hold on...that's pasted from the comment, but that's clearly wrong, yeah
07:48:16 <Abraxas> i was one step further, but that's not working, either
07:48:18 <merijn> (because step uses the p from filter)
07:48:43 <Abraxas> i replaced it with "step :: ()" as sipa suggested
07:48:55 <merijn> Abraxas: Do you follow what's going wrong so far? (Be it my or monochrom's summary)
07:49:29 <Abraxas> then the compiler says "Couldn't match expected type `a0 -> [a] -> [a]' with actual type `()'"
07:49:34 <monochrom> no, the correct type sig for step is inexpressible in Haskell 2010. extensions allow you to express it.
07:49:58 <merijn> Abraxas: The problem is that the top level myFilter selects some a when you call it, yes?
07:49:59 <Abraxas> so i replaced that with a0 -> [a] -> [a]
07:50:00 <monochrom> and lastly, this example does not imply that all helper type sigs are inexpressible
07:50:02 <carpi> is there a function that allows me to map over a list of maybe's and only allow just values to be processed and ignore the nothing values ...?
07:50:09 <Abraxas> but you say it's not expressible, i see
07:50:39 <merijn> Abraxas: Your helper claims to work for all a (not the same a as in the top level function, the a in your helper function's type signature is separate from the top level myFIlter)
07:51:09 <fmap> @type map ?f . catMaybes
07:51:11 <lambdabot> forall a b. (?f::a -> b) => [Maybe a] -> [b]
07:51:17 <kartoffelbrei> why not just: 'myFilter p = foldr (\x acc -> if p x then x:acc else acc) []' ?
07:51:20 <Abraxas> yes, sorry, that was the commenter's mistake
07:51:35 <mcstar> @hoogle mapmaybe
07:51:36 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
07:51:36 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
07:51:36 <lambdabot> Data.Map mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
07:51:39 <Abraxas> that type signature is ofc wrong
07:51:54 <merijn> Abraxas: So it runs into problems because your helper uses p (whose a is chosen by myFilter, and so step is restricted by the type of myFilter). This means "step" *can't* work for all a like your type signature claims, it can only work for the a used by myFilter. Understand?
07:51:59 <monochrom> oh? there are tons of mistakes and 0.1-truths in user-provided comments? :)
07:52:05 <Abraxas> but the one the compiler tells me about cannot explicitly be writtent that way, either
07:52:16 <Abraxas> no, monochrom :D
07:52:32 <Abraxas> the explanations are incomplete, just look at all the fold-stuff
07:53:10 <carpi> thanks mate : )
07:53:12 <merijn> Abraxas: The correct solution to writing a type signature for a function like this is: "{-# LANGUAGE ScopedTypeVariables #-}", this is a GHC extension that basically says "if I use the type variable a in a helper function, the a should be the same as the a in the top level function"
07:53:51 <kartoffelbrei> there is no need for scoped type variables for the stuff he wants to do
07:54:07 <merijn> kartoffelbrei: Sure, just removing the type signature works too
07:54:26 <Abraxas> sorry about the paste, this is NOT the same problem i was running into after sipa's first suggestion
07:54:28 <merijn> kartoffelbrei: But ScopedTypeVariables is an imminently sensible extension and enabling doesn't hurt
07:55:03 <Abraxas> thanks, @merijn
07:55:45 <merijn> mm_freak: Ah, yes. Netwire 4's haddock looks a lot better than 3.1 :p
07:55:46 <Abraxas> maybe you are talking about the same thing as monochrom, though
07:56:00 <merijn> Abraxas: I am
07:56:01 <kartoffelbrei> merijin: oh sorry i kind of misinterpreted Abraxas problem here
07:56:29 <merijn> If your problem is different from what you pasted, I can't guess the solution :p
07:56:48 <Abraxas> it's not the same a, but it's also not b or whatever :D it's not expressible
07:57:00 <merijn> Why is it not expressible?
07:57:12 <Abraxas> without the extension, i mean
07:57:36 <merijn> Abraxas: The sample you pasted is not expressible without the extension, no. But leaving out the signature works
08:05:27 <hpaste> Abraxas annotated “helper type signature not working” with “helper type signature not working (annotation)” at http://hpaste.org/75871#a75872
08:05:50 <Abraxas> to give you the whole picture (hopefully), this time
08:07:45 <Abraxas> which led me to suspect it's not possible to write an explicit type signature in *this* case, at least...which monochrom confirmed =)
08:07:46 <monochrom> I am not sure what more I need to say, but thank you.
08:08:02 <Abraxas> that was for @merijn, mostly ;)
08:08:45 <shachaf> merijn is an op now?
08:09:06 <Abraxas> i have a history of causing hpaste confusion...or confusion, in general
08:09:28 <Abraxas> i literally have a history of that
08:10:54 <merijn> shachaf: Wait, what?
08:11:20 <merijn> Apparently I am? When'd that happen?
08:11:23 <Abraxas> i tried {-# LANGUAGE ScopedTypeVariables #-} and it doesn't work, might be my GHC version
08:11:39 <shachaf> Wait, merijn actually *is* an op.
08:11:39 <Abraxas> oh, i thought that was part of your name :D
08:12:40 <mm_freak> merijn: the haddocks of netwire 3 are good as well, but they are just API documentation…  for this version i decided to make it real documentation
08:12:48 <Abraxas> i use mirc sporadically, pretty much only when i need help on haskell or whatever...no clue about conventions, @ is prolly not allowed in nicks?
08:12:49 <mm_freak> too bad haddock does not allow external files
08:13:03 <Abraxas> *irc
08:13:04 <merijn> shachaf: Apparently shapr opped me 2 hours ago, but I have no clue why?
08:13:16 <mcstar> birthday?
08:13:42 * merijn goes crazy with power and kickbans everyone
08:14:50 <Botje> merijn: don't forget to elect yourself as Grand Poobah of Haskell, first.
08:15:48 <merijn> mm_freak: Yeah, they looked ok, but without an idea of the overall design the API docs don't help much :)
08:19:32 * hackagebot http-accept 0.1 - Functions for working with HTTP Accept headers  http://hackage.haskell.org/package/http-accept-0.1 (StephenWeber)
08:26:52 <buffer_overflow> > forever $ getLine >>= putStrLn -- How do I cleanly exit from this loop if getLine reads EOF?
08:26:53 <lambdabot>   Ambiguous type variable `b' in the constraint:
08:26:54 <lambdabot>    `Data.Typeable.Typeable b...
08:27:14 <merijn> buffer_overflow: Surround forever with a catch?
08:27:32 <buffer_overflow> ah didn't  learn about exceptions
08:27:47 <otters> cabal-dev is horribly confused
08:27:51 <buffer_overflow> I'll look it up ^_^
08:28:02 <merijn> buffer_overflow: Control.Exception is a good place to start
08:28:11 <buffer_overflow> thanks
08:28:12 <otters> I moved my project folder and cabal-dev is still making GHC look in the old place for a package database
08:28:16 <merijn> buffer_overflow: I also have exactly the code you want in this file: https://github.com/merijn/SNet2.0/blob/master/SNet.hs
08:28:18 <otters> I don't know where the configuration file is found
08:28:50 <buffer_overflow> merijn: wow
08:29:02 <merijn> buffer_overflow: globIn reads from stdin until it hits an exception. If the exception is EOF it runs the mvar action, else it reraises it
08:29:16 <otters> https://gist.github.com/418f90857878f1322434
08:29:22 <otters> this is my problem
08:30:05 <merijn> (Go read Control.Exception anyway, but this should help :p)
08:30:21 <Abraxas> @djinn a -> b -> a
08:30:22 <lambdabot> f a _ = a
08:30:49 <buffer_overflow> didn't know that you can achieve complicated control flow in a purely functional manner like that
08:31:03 <buffer_overflow> exceptions, for-loops, goto, etc.
08:31:28 <buffer_overflow> I must study Control.Monad  as well
08:31:37 <otters> @djinn (g,a,f) -> f -> (g,a) -> g -> a
08:31:38 <lambdabot> f _ _ (_, a) _ = a
08:31:56 <otters> any ideas, folks?
08:31:57 <merijn> buffer_overflow: Well, haskell has two types of exceptions, pure and impure
08:32:02 <otters> I have no idea where cabal-dev's configuration is stored
08:32:07 <monochrom> not only that, but in fact user-defined control flow
08:32:20 <hpc> buffer_overflow: you can do much stranger and complex things than those :D
08:32:22 <merijn> buffer_overflow: The pure ones use Either/Maybe, the impure ones can only but caught and handled in IO
08:33:14 <monochrom> and therefore "monad is just for adding I/O to haskell" is flawed
08:33:54 <Abraxas> @djinn ((a,b),(c,d)) -> (b,c)
08:33:55 <lambdabot> f ((_, a), (b, _)) = (a, b)
08:34:23 <mcstar> monochrom: still hung up on that article? :)
08:34:46 <merijn> monochrom: Pffft, it's not like monads can do anything else useful, like parsing ;)
08:34:57 <monochrom> perhaps not. a lot more people hold that belief than just that article
08:35:31 <buffer_overflow> maybe someday someone will implement goto in Haskell ^_^
08:36:21 <Abraxas> how do i define "type C a = (a -> r) -> r" for lambdabot?
08:36:44 <MagneticDuck> hiah, I'm having trouble finding a nice tutorial for grapefruit
08:36:46 <nand`> buffer_overflow: continuations? :P
08:37:04 <monochrom> http://www.vex.net/~trebla/haskell/cont-monad.xhtml  there is a setjmp somewhere
08:37:18 <simon> MagneticDuck, I hear grapefruits are kind of like monads. maybe if grapefruits are too hard to understand, read a monad tutorial?
08:37:26 <shachaf> Good ol' callCC (return . fix)
08:37:26 <MagneticDuck> um
08:37:27 <kartoffelbrei_> buffer_overflow: well you can actually do some goto-ish things with the Cont Monad and callCC
08:37:33 <MagneticDuck> I thought grapefruit used arrows
08:37:35 <MagneticDuck> oh
08:37:35 <buffer_overflow> right
08:37:36 <MagneticDuck> haha
08:37:39 <simon> MagneticDuck, it's a joke.
08:37:43 <MagneticDuck> x|
08:37:49 <simon> ^_^
08:37:49 <buffer_overflow> so things like Functors, Monads, and Arrows are concepts from Category Theory?
08:37:55 <MagneticDuck> yeah
08:37:57 <MagneticDuck> but sometimes
08:37:59 <MagneticDuck> twisted
08:38:00 <MagneticDuck> :/
08:38:10 <merijn> buffer_overflow: Well, names from Category Theory :p
08:38:21 <MagneticDuck> yeah
08:38:31 <MagneticDuck> functor /= endofunctor
08:38:35 <MagneticDuck> for instance
08:38:36 <merijn> buffer_overflow: Usually with some not *to* distant relation to the category theory things
08:38:39 <buffer_overflow> :(
08:38:48 <MagneticDuck> anyway, are there any good tutorials for grapefruit?
08:38:54 <MagneticDuck> I understand arrows and haskell and stuff
08:39:01 <adnauseam> one bends the tools to meet the task at hand - that's the purpose of mathematics
08:39:17 <MagneticDuck> that's the purpose of engineering, I thought
08:39:27 <monochrom> both
08:39:38 <MagneticDuck> programmers are kind of like engineers
08:39:43 <MagneticDuck> but more annoyed
08:39:49 <YayMe> I'm an engine!
08:39:54 <Abraxas> let type C a = (a -> r) -> r
08:39:55 <MagneticDuck> YayYou!
08:40:16 <MagneticDuck> so
08:40:18 <buffer_overflow> so the guys who invented stuff like Monads and Functors and Arrows for Haskell were just inspired by those concepts in category theory.
08:40:20 <Abraxas> damn, i wish there were a tutorial for lambdabot
08:40:22 <MagneticDuck> no good grapefruit tutorials?
08:40:32 <Abraxas> @let type C a = (a -> r) -> r
08:40:32 <MagneticDuck> I can just find a bunch of general things about FRPs
08:40:32 <lambdabot>  Invalid declaration
08:40:35 <MagneticDuck> garr
08:40:43 <shachaf> Abraxas: The answer is "you can't do that"
08:40:44 <MagneticDuck> <feels generous today>
08:40:49 <MagneticDuck> bot snack
08:40:51 <MagneticDuck> botsnack
08:40:54 <Abraxas> aw
08:41:03 <MagneticDuck> EAT YOUR FRICKING BOTSNACK YOU!
08:41:04 <shachaf> Also, you can /msg lambdabot
08:41:09 <MagneticDuck> yeah
08:41:13 <Abraxas> then i need the original djinn to try the examples
08:41:14 <yawnt`afk> i know this is a stupid question but
08:41:23 <yawnt`afk> how do you close ghci ?
08:41:29 <MagneticDuck> mainQuit
08:41:29 <yawnt`afk> :\
08:41:32 <MagneticDuck> or something like that
08:41:32 <yawnt`afk> thanks :)
08:41:32 <shachaf> Abraxas: lambdabot also has djinn but that's unrelated to @let
08:41:37 <MagneticDuck> m
08:41:38 <MagneticDuck> no
08:41:38 <aristid-ipad> shachaf: forall r. should be possible with the right extensions, no?
08:41:40 <MagneticDuck> exit
08:41:41 <MagneticDuck> sry
08:41:41 <shachaf> See @help, @list
08:41:41 <nand`> buffer_overflow: the haskell typeclasses Monad, Functor etc. do directly correspond to some monads, functors etc. from category theory, but not arbitrary ones
08:41:44 <MagneticDuck> I misread
08:41:46 <yawnt`afk> no
08:41:47 <yawnt`afk> i tried exit
08:41:48 <yawnt`afk> and quit
08:41:50 <shachaf> aristid-ipad: ?
08:41:50 <yawnt`afk> and didn't work
08:41:52 <MagneticDuck> um
08:41:54 <rwbarton> ctrl-D
08:41:55 <nand`> in particular, they're functors and monads on the category of haskell functions
08:41:56 <shachaf> aristid-ipad: I mean that you can't @let
08:42:00 <MagneticDuck> ctrl-
08:42:02 <yawnt`afk> ^D works
08:42:02 <MagneticDuck> C
08:42:05 <yawnt`afk> ^C doesn't
08:42:09 <MagneticDuck> weird
08:42:10 <siracusa> yawnt`afk: :q
08:42:20 <Abraxas> @djinn a -> (a -> r) -> r
08:42:20 <lambdabot> f a b = b a
08:42:20 <yawnt`afk> :q and ^D
08:42:22 <MagneticDuck> yeah
08:42:23 <MagneticDuck> :quit
08:42:24 <yawnt`afk> thanks :D
08:42:27 <MagneticDuck> I was all mixed up
08:42:28 <MagneticDuck> x|
08:42:30 <yawnt`afk> :P
08:42:37 <yawnt`afk> brb learning haskell \ò/
08:42:38 <MagneticDuck> gtk2hs? no, bash! no, something else
08:42:39 <aristid-ipad> shachaf: ther's always the local trusty ghci
08:42:53 <MagneticDuck> so
08:43:00 <MagneticDuck> are there any well documented FRPs?
08:43:04 <MagneticDuck> x|
08:43:06 <MagneticDuck> I like tutorials
08:43:08 <MagneticDuck> sorry
08:43:28 <Abraxas> shchaf: yeah, i was just trying to define a type for use, but i can simply write it out
08:43:35 <Abraxas> *for use with djinn
08:43:46 <shachaf> You can do it for @djinn. Exercise: You @help and @list in /msg to find out how.
08:43:49 <MagneticDuck> I just found the wiki page and a few little key-notes about why FRPs are good
08:43:51 <Abraxas> *shachaf
08:44:12 <monochrom> I haven't written a grapefruit tutorial. perhaps that's why.
08:44:17 <MagneticDuck> :O
08:44:23 <MagneticDuck> lol
08:44:27 <MagneticDuck> you maintain it?
08:44:53 <Abraxas> @help
08:44:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:45:10 <monochrom> no. I am a popular tutorial writer
08:45:14 <MagneticDuck> ah
08:45:39 <monochrom> so, for example, no one asks "where can I find a lazy evaluation tutorial?" because I already wrote one
08:45:44 <MagneticDuck> :D
08:45:46 <aristid-ipad> monochrom: have you written a monad tutorial, too?
08:45:50 <MagneticDuck> lol
08:45:52 <monochrom> no
08:45:54 <MagneticDuck> how many monad tutorials are there
08:46:01 <MagneticDuck> I don't think we need another
08:46:05 <MagneticDuck> besides, monads are easy!
08:46:06 <MagneticDuck> :D
08:46:14 <monochrom> yes, monad is too easy
08:46:27 <Abraxas> @list
08:46:27 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:46:28 <MagneticDuck> once I learned them, I find it boring to think about
08:46:33 <MagneticDuck> *them
08:46:39 <monochrom> Num doesn't need a tutorial, therefore Monad doesn't either
08:46:40 <MagneticDuck> so, reactive banana has documentation?
08:46:44 <MagneticDuck> it also has a good name
08:46:48 <MagneticDuck> haha
08:46:50 <MagneticDuck> they
08:46:56 <MagneticDuck> they're equally used
08:47:10 <aristid-ipad> people just confuse monads (easy) with the unconventional way haskell does i/o, i think
08:47:16 <MagneticDuck> yeah
08:47:26 <MagneticDuck> we should keep newbies from do-notation
08:47:33 <MagneticDuck> it breeds unholy thoughts
08:48:26 <MagneticDuck> I wonder if some day, somebody will write a functional operating system
08:48:26 <Abraxas> @help djinn-names
08:48:27 <lambdabot> djinn-names.
08:48:27 <lambdabot> Show the current djinn environment, compactly.
08:48:29 <MagneticDuck> without side effects
08:48:30 <MagneticDuck> hmm
08:48:38 <monochrom> @quote use.*array
08:48:39 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
08:48:56 <nand`> monochrom: did I correctly infer that you like grapefruit?
08:48:56 <MagneticDuck> hehe
08:49:01 <nand`> the library, that is
08:49:02 <MagneticDuck> so
08:49:04 <Abraxas> can the chat see my @help attempts?
08:49:09 <MagneticDuck> no
08:49:09 <MagneticDuck> xD
08:49:13 <MagneticDuck> it's private
08:49:19 <MagneticDuck> you can have your private time with lambdabot
08:49:22 <Abraxas> then why would i need \msg?
08:49:26 <shachaf> Abraxas: Yes.
08:49:30 <MagneticDuck> well
08:49:31 <monochrom> I don't know whether I like grapefruit or not. I haven't learned it
08:49:35 <MagneticDuck> it's the same thing as a private chat
08:49:39 <MagneticDuck> so
08:49:44 <Abraxas> uh, /msg
08:49:50 <hpaste> Skola pasted “Why does this not terminate?” at http://hpaste.org/75873
08:49:54 <MagneticDuck> are there any really stable FRPs with lots of documentation?
08:49:58 <nand`> oh, okay; I figured there was some reason you were mentioning grapefruit in particular out of all the FRP libraries out there
08:49:58 <MagneticDuck> there's a lot, that's for sure
08:49:59 <Skola> does it have to do with laziness?
08:50:07 <nand`> (but I missed the early half of the conversation)
08:50:08 <MagneticDuck> nand`: that was me
08:50:12 <MagneticDuck> I asked about it
08:50:13 <Abraxas> i will never get used to IRC...
08:50:17 <MagneticDuck> I liked the name
08:50:19 <nand`> I see, never mind then
08:50:44 <MagneticDuck> Abraxas: ..until one day, when it's a dark and stormy night,... you will understand it all
08:50:44 <Abraxas> i use it on and off and always forget everything
08:50:45 <buffer_overflow> what is the difference between error and fail?
08:50:51 <MagneticDuck> you will understand everything!
08:50:56 <MagneticDuck> IRC is beautiful
08:50:56 <nand`> error throws an exception
08:51:02 <monochrom> error is pervasive. fail is Monad-only
08:51:09 <nand`> fail can do different things depending on the monad
08:51:15 <MagneticDuck> buffer_overflow: fail is for monads
08:51:16 <monochrom> also, fail is user-defined
08:51:16 <MagneticDuck> yeah
08:51:18 <nand`> > fail "foo" :: [Int]
08:51:19 <lambdabot>   []
08:51:22 <MagneticDuck> and fail is weird
08:51:25 <nand`> > fail "bar" :: Maybe Char
08:51:26 <lambdabot>   Nothing
08:51:30 <MagneticDuck> they should take it out
08:51:37 <MagneticDuck> I can't think of a good reason to have fail
08:51:37 <Abraxas> it doesn't tell you anywhere what's private and what's not...i thought it was color-coded if it's private
08:51:40 <nand`> for most other monads, it's ‘error’
08:51:42 <buffer_overflow> so error is a pure exception
08:51:45 <buffer_overflow> while fail is impure
08:51:50 <MagneticDuck> Abraxas: what client are you using?
08:51:54 <MagneticDuck> yeah
08:51:56 <Abraxas> mirc
08:52:02 <MagneticDuck> error is built into ghc
08:52:04 <monochrom> no, not pure vs impure
08:52:07 <MagneticDuck> crashes everything
08:52:15 <MagneticDuck> um
08:52:19 <nand`> Abraxas: the target of the PRIVMSG tells you if it's private or not - if the target is a channel, it's being sent to everybody in that channel; if the target is a nick, it's only being sent to that person
08:52:19 <MagneticDuck> exceptions aren't pure
08:52:20 <MagneticDuck> x|
08:52:22 <Skola> does anybody know why this quickCheck test does not finish? http://hpaste.org/75873
08:52:41 <rwbarton> Skola, it has more to do with the existence of negative numbers I think
08:52:44 <nand`> buffer_overflow: exceptions aren't very ‘pure’ in Haskell, you can only catch them in IO
08:52:58 <monochrom> I doubt that Abraxas is seeing raw PRIVMSG
08:53:03 <shachaf> Depending on what you mean by "exception".
08:53:03 <MagneticDuck> yeah
08:53:05 <MagneticDuck> using mirc
08:53:10 <nand`> and they're not a good mechanism for handling expectable errors
08:53:11 <Abraxas> i was talking about @help, for example
08:53:22 <MagneticDuck> Abraxas: depending on how much of a geek you are, you might want to learn the irc protocol
08:53:23 <nand`> shachaf: in this context, ‘error’
08:53:25 <MagneticDuck> everything will be clear
08:53:31 <cwraith> rwbarton: it's not about negative numbers, it's about overflow
08:53:34 <MagneticDuck> making irc bots is fun
08:53:51 <Abraxas> no real desire for that ;)
08:53:51 <rwbarton>   C-c C-c*** Failed! Exception: 'user interrupt' (after 1 test):
08:53:52 <rwbarton> -1
08:54:03 <Skola> yes it never reaches 1
08:54:07 <Abraxas> i don't use it often enough
08:54:21 <Skola> thanks :}
08:54:28 <MagneticDuck> Abraxas: not yet
08:54:32 <MagneticDuck> >:D
08:54:37 <MagneticDuck> we will win over you
08:54:40 <MagneticDuck> it's just a matter of time
08:54:45 <Abraxas> don't assume i am new to using IRC
08:54:51 <buffer_overflow> what's a sum type?
08:54:51 <MagneticDuck> (I'm the freaky one on this channel)
08:55:01 <MagneticDuck> buffer_overflow: you're referring to the Sum newtype
08:55:03 <MagneticDuck> it's a monoid
08:55:07 <MagneticDuck> for nums
08:55:09 <MagneticDuck> Nums
08:55:13 <Abraxas> i used it for years, but i keep forgetting everything
08:55:16 <MagneticDuck> mconcat == (+)
08:55:23 <MagneticDuck> ar
08:55:26 <MagneticDuck> sum
08:55:27 <MagneticDuck> I mean
08:55:35 <hpaste> YayMe pasted “Graphwalker” at http://hpaste.org/75876
08:55:36 <MagneticDuck> >mconcat $ map Sum [1..5]
08:55:42 <MagneticDuck> > mconcat $ map Sum [1..5]
08:55:43 <lambdabot>   Sum {getSum = 15}
08:55:55 <MagneticDuck> buffer_overflow: do you know about monoids yet?
08:56:03 <YayMe> Any tips on better way to walk my graph and back?
08:56:09 <rwbarton> that is not what "a sum type" is
08:56:11 <MagneticDuck> zippers!
08:56:16 <MagneticDuck> rwbarton: yeah
08:56:21 <Abraxas> i have been to this channel many times
08:56:24 <MagneticDuck> I guessed he was referring to the Sum newtype
08:56:34 <Abraxas> but it never sticks :D
08:56:42 <MagneticDuck> YayMe: http://learnyouahaskell.com/zippers
08:57:02 <MagneticDuck> okay, real fast
08:57:08 <MagneticDuck> what's a good FRP library
08:57:10 <rwbarton> buffer_overflow, what is the context in which you see "a sum type"
08:57:11 <MagneticDuck> with lots of documentation
08:57:17 <buffer_overflow> rwbarton: tagged unions
08:57:22 <rwbarton> right
08:57:23 <MagneticDuck> oh..
08:57:26 <rwbarton> a sum type is a tagged union
08:57:28 <rwbarton> like Either
08:57:35 <aristid-ipad> MagneticDuck: maybe reactive-banana?
08:57:42 <MagneticDuck> okay, I'll check that out
08:57:48 <Abraxas> @help djinn-add
08:57:48 <lambdabot> djinn-add <expr>.
08:57:48 <lambdabot> Define a new function type or type synonym
08:57:49 <buffer_overflow> so in  `data Foo = Bar | Baz`, Foo is a sum type?
08:57:59 <monochrom> yes
08:57:59 <Abraxas> did you see that?
08:58:40 <MagneticDuck> their fake testimonials in the wiki page have already won over me
08:58:43 <YayMe> MagneticDuck: You would use zip to walk a graph?
08:58:49 <MagneticDuck> a zipper
08:58:51 <buffer_overflow> so sum types are  structs
08:58:54 <rwbarton> Abraxas: yes we saw it
08:59:04 <monochrom> eh? no, not structs
08:59:07 <MagneticDuck> it's a method to walk around a recursive data structure
08:59:09 <MagneticDuck> like a tree or a list
08:59:23 <MagneticDuck> without having to recalculate the position every time you move
08:59:38 <YayMe> MagneticDuck: Am I recalculating the position each time in my example?
08:59:42 <nand`> I recently heard bad things about reactive-banana in -blah
08:59:43 <monochrom> I'm sorry I say no to every flawed translation
08:59:49 <Abraxas> how do i make this private?
09:00:01 <nand`> Abraxas: /query lambdabot
09:00:04 <Abraxas> msg just sends the string to me
09:00:16 <MagneticDuck> YayMe: I don't see your example
09:00:19 <MagneticDuck> missed it
09:00:29 <YayMe> http://hpaste.org/75876
09:00:43 <mcstar> that doesnt 'walk' the graph, it makes a list out of it
09:00:52 <Abraxas> i can msg it to lambdabot, ofc...
09:00:57 <Abraxas> lol, thx
09:01:00 <YayMe> mcstar: Right, sorry, it visits every node though
09:01:34 <MagneticDuck> ah
09:01:37 <YayMe> mcstar: I had it visiting only once but figured it made more sense that it walk to and from each vertex
09:02:00 <Abraxas> i even knew that lambdabot is a "user"
09:02:12 <Abraxas> but didn't occur to me, anyway
09:02:27 <MagneticDuck> g2g
09:02:28 <MagneticDuck> bb
09:03:13 <rwbarton> YayMe: only problem I see with this code is that "Vertice" is not a word
09:03:25 <rwbarton> also I hope your graph is a tree
09:03:29 <YayMe> rwbarton: yeah I just fixed that (I remember you guys telling me that a while ago heh)
09:03:36 <YayMe> rwbarton: Yeah, cyclical would be bad here
09:03:40 <ixmatus> if the type of "return" is: return :: Monad m => a -> m a
09:03:43 <ixmatus> then
09:03:50 <ixmatus> why can I do "return 4"
09:04:12 <ixmatus> is Int part of the Monad typeclass?
09:04:16 <rwbarton> why not?
09:04:18 <rwbarton> no
09:04:21 <mcstar> a is a type variable
09:04:21 <maukd> ixmatus: ?
09:04:23 <rwbarton> the argument is a
09:04:28 <rwbarton> can be any type you like...
09:04:39 <mcstar> the monad is m
09:04:40 <monochrom> 4 has type a, not type m
09:04:40 <ixmatus> Monad m => is a constraint though, no?
09:04:54 <rwbarton> yes. a constraint on m
09:05:00 <YayMe> rwbarton: that was going to be my next question how would you handle cyclical? Should I make an accumulator of Vertexes and do an elem check to see if I've visited the node before?
09:05:04 <jmcarthur> minor complaint about cabal-install's new parallel builds feature... it's kind of hard to see what it's still working on
09:05:11 <ixmatus> okay, so what happens to "m"?
09:05:16 <mcstar> YayMe: vertices
09:05:27 <maukd> "happens?"
09:05:30 <ixmatus> yeah
09:05:33 <monochrom> undetermined. you have only written "return 4", m is still undetermined
09:05:34 <jmcarthur> other than that, i'm loving it
09:05:44 <elemir> @type return 4
09:05:45 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
09:05:50 <nand`> > return 4 :: Maybe Integer
09:05:52 <lambdabot>   Just 4
09:05:52 <elemir> Is it clear?
09:05:53 <nand`> > return 4 :: [Integer]
09:05:55 <lambdabot>   [4]
09:06:12 <jmcarthur> > return 4 :: ZipList Integer
09:06:13 <lambdabot>   No instance for (GHC.Base.Monad Control.Applicative.ZipList)
09:06:13 <lambdabot>    arising fro...
09:06:14 <rwbarton> > return 4 :: IO Integer
09:06:15 <lambdabot>   <IO Integer>
09:06:18 <jmcarthur> oh right no monad for that
09:06:28 <byorgey> hehe
09:07:01 <Abraxas> well...
09:07:04 <Abraxas> @djinn-add type C a = (a -> r) -> r
09:07:05 <lambdabot> Error: Undefined type variable r
09:07:32 <ixmatus> so "return (Just 3)" m is then determined?
09:07:39 <elemir> type C a = exist r. (a -> r) -> r, keke
09:07:39 <maukd> ixmatus: no
09:07:42 <rwbarton> YayMe`: well I would probably use a different data structure entirely for working with a graph with cycles, since cyclical data structures are usually a pain
09:07:53 <nand`> :t return (Just 3)
09:07:54 <monochrom> no, return (Just 3) gives you m (Maybe Integer)
09:07:55 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m (Maybe t)
09:07:55 <YayMe`> rwbarton: Ideas?
09:07:57 <mcstar> > return 3 == Just 3
09:07:58 <lambdabot>   True
09:08:02 <Abraxas> ah
09:08:05 <YayMe`> rwbarton: Would you treat it more like okasaki's queue?
09:08:20 <Abraxas> a and b already got an "exist" predefined?
09:08:28 <ixmatus> okay
09:08:30 <elemir> no
09:08:32 <Abraxas> i didn't think it would work that way
09:08:37 <monochrom> clearly, in "a -> m a", whatever you do to "a" cannot possibly affect "m"
09:08:48 <ixmatus> right
09:08:49 <rwbarton> personally I like to just use a -> [a] when possible
09:08:59 <ixmatus> because we're talking about functors
09:09:12 <Abraxas> @djinn-add type C a = exist r. (a -> r) -> r
09:09:12 <lambdabot> Error: Undefined type variable exist
09:09:21 <Abraxas> =/
09:09:22 <monochrom> you can write "return (Just (Just (Just [Just 4..." and all you're doing is making "a" bigger, and you still haven't touched "m"
09:09:51 <ixmatus> monochrom so what is "m" then? is it the Maybe monad?
09:10:02 <mcstar> whatever it is
09:10:03 <elemir> Abraxas: As I known, ghc doesn't support existentianal types in that form
09:10:04 <monochrom> no, it depends on the context
09:10:13 <ixmatus> well I mean in the context of your example
09:10:21 <elemir> Abraxas: http://www.haskell.org/haskellwiki/Existential_types
09:10:25 <monochrom> my example leaves it undertermined
09:10:36 <rwbarton> "exists r. (a -> r) -> r" is logically trivial anyways (pick r = ())
09:10:45 <hpaste> osa1 pasted “haddock error” at http://hpaste.org/75878
09:10:50 <Abraxas> all i want is this:
09:10:58 <osa1> I can't install haddock, can anyone help ? http://hpaste.org/75878
09:11:02 <ixmatus> monochrom could you give me an example where it is determined?
09:11:04 <Abraxas> @djinn-add type C a = (a -> r) -> r
09:11:05 <lambdabot> Error: Undefined type variable r
09:11:15 <typoclass> ixmatus: roughly, if you're in a function "foo :: IO Int" and do "return 4", m will refer to IO
09:11:16 <ixmatus> I feel like i'm missing something very obvious here
09:11:19 <Abraxas> why is the r special in this case?
09:11:24 <rwbarton> what?
09:11:32 <rwbarton> what are you really trying to do
09:11:35 <mcstar> > return 3 == Just 3 -- ixmatus whats the monad here?
09:11:36 <lambdabot>   True
09:11:37 <rwbarton> it cannot be "define a type synonym in djinn"
09:11:38 <monochrom> "[True] >> return 4" fixes m to []
09:11:53 <monochrom> "putChar 'x' >> return 4" fixes m to IO
09:11:57 <Abraxas> why not
09:12:00 <elemir> @djinn-add type C a r = (a -> r) -> r
09:12:13 <elemir> Abraxas: Because r is undefined
09:12:14 <rwbarton> ...
09:12:17 <ixmatus> monochrom interesting okay
09:12:24 <ixmatus> typoclass that helps, thank you
09:12:45 <monochrom> unsafePerformIO (return 4) also fixes m to IO
09:12:47 <Abraxas> well, i got it from here: http://lambda-the-ultimate.org/node/1178
09:12:49 <maukd> return is a virtual constructor
09:13:00 <ixmatus> mcstar I have no idea - as per monochrom it is undetermined?
09:13:07 <mcstar> no
09:13:12 <ixmatus> mcstar I guess that's why I was asking in the first place
09:13:15 <Abraxas> from the guy who has written djinn in the first place
09:13:23 <mcstar> what type is Just a contructor of?
09:13:26 <Abraxas> oh nice, "in the first place" double
09:13:50 <Mortchek> ixmatus, it might help to note that == takes two arguments of the same type
09:13:52 <elemir> @type Just
09:13:53 <lambdabot> forall a. a -> Maybe a
09:14:07 <mcstar> (well, Just is a value constructor, but it results a value of a type, dont confuse it with a real type constructor)
09:14:26 <Abraxas> that's what he used: Djinn> type C a = (a -> r) -> r
09:14:47 <ixmatus> mcstar do you mean the kind?
09:15:00 <ixmatus> oh I mis read what yo uwrote
09:15:05 <Abraxas> does that mean he programmed a type command that defines unknown type variables?
09:15:05 <mcstar> you dont need to worry about kinds now
09:15:19 <ixmatus> Just is a constructor of the Maybe type
09:15:34 <rwbarton> maybe an older version of djinn would just pretend that r is in scope there
09:15:55 <Mortchek> ixmatus, so if Maybe a is on one side of (==), what's must be on the other?
09:15:58 <Mortchek> s/what's/what/
09:16:02 <ixmatus> oh interesting
09:16:06 <ixmatus> :t Just
09:16:07 <lambdabot> forall a. a -> Maybe a
09:16:11 <ixmatus> Just :: a -> Maybe a
09:16:25 <ixmatus> on the return Maybe (which is a monad, right?)
09:16:25 <rwbarton> like elemir demonstrated you can use "type C a r = (a -> r) -> r" and then use C a r in place of C a
09:16:39 <ixmatus> oh oh, I'm starting to see now
09:16:56 <buffer_overflow> what does IORef mean?
09:17:02 <Mortchek> ixmatus, yep, both sides are of type Maybe a. One side constrains the other.
09:17:26 <rwbarton> buffer_overflow, it is a storage cell that you can mutate in the IO monad
09:17:26 <monochrom> IORef means mutable variable in IO
09:17:26 <mcstar> buffer_overflow: a mutable 'container' of a single value, in IO
09:17:29 <buffer_overflow> ah
09:17:41 <ixmatus> Just 4 is taking a value and returning a Maybe monad with that value (is that the right way to say that?)
09:17:44 <buffer_overflow> so things like Arrays and typical variables you see in C are IORef'd?
09:17:50 <Abraxas> yeah, but don't really get why that worked in the older version...but nm, just did :D thanks
09:18:35 <mcstar> ixmatus: Just 3 return Maybe Int, for example, it just happens so, that Maybe is also an instance of Monad, and return is defined fo rit
09:18:52 <mcstar> which doesnt do anything surprising, as you saw it
09:18:53 <rwbarton> for arrays there is IOArray (and others)
09:18:58 <Mortchek> ixmatus, Just is a data constructor for Maybe.
09:19:09 <Abraxas> @djinn-add type C a r = (a -> r) -> r
09:19:17 <ixmatus> Mortchek yes I know it's a value constructor
09:19:18 <kartoffelbrei_> buffer_overflow: yes, but there are all kinds of different arrays in Haskell.
09:19:23 <Abraxas> @djinn a -> C a
09:19:24 <lambdabot> Error: kind error: (KVar 1,KStar)
09:19:43 <rwbarton> an IOArray is sort of like a lot of IORefs though. or an IORef is like a one-element IOArray
09:19:44 <Abraxas> oops
09:19:44 <ixmatus> I guess I just got hung up on the abstraction - Just 4 returns the Maybe monad with the value 4
09:19:44 <jmcarthur> @djinn a -> C a r
09:19:45 <lambdabot> f a b = b a
09:19:52 <Abraxas> yeah, sorry
09:19:58 <buffer_overflow> interesting; how would an array or doubly-linked list be defined in a purely-functional manner?
09:20:13 <mcstar> easily
09:20:16 <Mortchek> ixmatus, if you're just talking about Just, it's not really relevant that Maybe is a Monad.
09:20:27 <jmcarthur> buffer_overflow: the former is just an array that can be indexed efficiently but "mutated" inefficiently
09:20:34 <Mortchek> That would be relevant if you were talking in terms of the monad operations, such as (>>=) and return.
09:20:36 <buffer_overflow> ah
09:20:48 <mcstar> jmcarthur: he didnt say he wanted mutable arrays and mutable doubly lnked lists
09:20:52 <rwbarton> or you could use a tree structure with O(log n) indexing and update
09:20:55 <ixmatus> Mortchek okay
09:21:02 <kartoffelbrei_> buffer_overflow: for doubly linked lists, there are hella tricky ways exploiting lazy evaluation. that "trick" is know as "tying the knot"
09:21:05 <Mortchek> ixmatus, it's kind of like saying 5 is a value in the Int Num type
09:21:05 <jmcarthur> buffer_overflow: the latter is just a normal doubly linked list, but again with inefficient mutation (unless you use a trick where you reify the "pointers" into something like an IntMap)
09:21:10 <ixmatus> Mortchek OH I see what you're saying
09:21:17 <ixmatus> hero deep I should have noted that
09:21:20 <ixmatus> derp*
09:21:39 <rwbarton> or some problems that you would use doubly linked lists for you can instead use zippers
09:21:42 <ixmatus> Just IS only value constructing - we aren't doing any binding
09:21:48 <jmcarthur> mcstar: no, he didn't, but i'm just explaining the bits that i imagine he was having the most trouble imagining
09:22:29 <mcstar> ixmatus: binding?
09:22:40 <mcstar> as in, variable binding? or >>=?
09:22:44 <ixmatus> >>=
09:23:05 <rwbarton> in general "how would I implement a pure function $DATA_STRUCTURE" is not as good a question as "how would I purely functionally solve the problems that $DATA_STRUCTURE is designed to solve"
09:23:52 <jmcarthur> buffer_overflow: we also have some really neat array libraries, though. some of them have optimizations that eliminate many intermediate arrays and some even semi-automatically parallelize array computations
09:24:26 <buffer_overflow> right
09:24:27 <jmcarthur> buffer_overflow: for the most part you don't use them the way you would in C, though. you tend to use things like folds, maps, etc.
09:25:24 <jmcarthur> :t uncurry $ flip replicate
09:25:26 <lambdabot> forall a. (a, Int) -> [a]
09:25:31 <mcstar> also, because of lazyness, haskell has funny ways of building an array
09:25:32 <absence> is there a library function that will take a tuple of two io actions and sequence them?
09:25:38 <mcstar> (a pure array)
09:25:54 <rwbarton> uncurry (>>) -- ?
09:25:56 <hpaste> bfig pasted “Ambiguous type variable (first argument of trace)” at http://hpaste.org/75879
09:25:58 <jmcarthur> ^^ was in http://mathlesstraveled.com/2012/10/05/factorization-diagrams/ . i had never seen that point-free idiom before
09:26:12 <jmcarthur> mcstar: funny ways?
09:26:19 <mcstar> yeah
09:26:23 <jmcarthur> i don't understand
09:26:31 <mcstar> like in 'gentle introduction to haskell'
09:26:33 <bfgun> what's the problem with my call to trace?
09:26:39 <absence> rwbarton: ahh of course! thanks :)
09:26:59 <mcstar> jmcarthur: before the array is actually initialized, you can access its elements that are initialized
09:27:15 <mcstar> and build the next elements using them
09:27:22 <jmcarthur> oh, you mean boxed arrays specifically
09:27:29 <byorgey> jmcarthur: it comes up when doing the inverse of run-length encoding
09:27:30 <ixmatus> Mortchek so, I just did "let r = return 4" and got back an error (I know what it means - it's actually what I expected to get when just typing "return 4" into the REPL) so why am I able to call "return 4" in GHCI but I can't bind it to a let variable?
09:27:35 <jmcarthur> yes, boxed arrays allow you to do odd things
09:27:51 <byorgey> jmcarthur: or turning factorizations into a list of primes =)
09:28:01 <jmcarthur> byorgey: i see
09:28:11 <Mortchek> ixmatus, was the error "ambiguous type variable"?
09:28:16 <ixmatus> yes
09:28:18 <ixmatus> m0
09:28:20 <Mortchek> ixmatus, if so, it's because it doesn't know *which* return you want.
09:28:24 <ixmatus> for the Monad type variable
09:28:32 <jmcarthur> byorgey: it was the (uncurry . flip) that seemed to most unusual to me, as a general pattern
09:28:36 <Mortchek> Do you want the one for []? For Maybe? For IO? etc.
09:28:39 <rwbarton> did you type "let r = return 4" into ghci?
09:28:45 <jmcarthur> byorgey: i tend not to use flip, so i guess that's why i haven't bumped into it before
09:28:53 <rwbarton> oh
09:28:58 <ixmatus> rwbarton yes
09:29:04 <byorgey> jmcarthur: sure
09:29:05 <Mortchek> ixmatus, try, e.g., let r = return 5 :: Maybe Int
09:29:37 <ixmatus> !
09:29:38 <rwbarton> the reason is because when you enter an expression, ghci first tries to typecheck it as IO something and if that succeeds, runs the action
09:29:40 <bfgun> http://hpaste.org/75879 <- what's the problem with my call to trace? (didn't post the link
09:30:14 <ixmatus> Mortchek okay so "return" has special sauce to return the Maybe monad if you pass an Int to it? (or a Char, etc..)?
09:30:22 <ixmatus> I think thats what mcstar tried to tell me earlier
09:30:35 <mcstar> nah
09:30:42 <mcstar> thats totally not it
09:30:54 <ixmatus> hey be nice - this is a lot for a noob to take in
09:30:56 <rwbarton> ixmatus, now try let r2 = return 5 :: [Int]
09:30:59 <Mortchek> ixmatus, return is a function defined on all Monads, but each one has its own version of that function.
09:31:09 <ixmatus> I'm doing my best to grok this stuff
09:31:24 <Mortchek> ixmatus, you have to tell Haskell which one you meant, either with an explicit type annotation, as above, or by using it in with a function that fixes its type.
09:31:25 <jmcarthur> ixmatus: return is polymorphic in both the m and the a, and the a doesn't help to determine the m in any way or vice versa
09:31:26 <ixmatus> Mortchek okay, that's good to know
09:31:33 <mcstar> ixmatus: it returned a Maybe Int, because, the type inference determined the monad should be Maybe, since the other side of the equality was of Maybe Int
09:31:34 <Mortchek> -in
09:31:43 <mcstar> ixmatus: otherwise, it wojldnt have typechecked
09:31:52 <ixmatus> okay understood
09:32:09 <rwbarton> bfig, are you using OverloadedStrings in this module?
09:32:27 <ixmatus> this helped a lot, thank you Mortchek and mcstar
09:33:02 <rwbarton> bfig: also pasting the entire error message (in an annotation on the hpaste) would be useful
09:33:02 <buffer_overflow> what is a functor? In C++ we call objects that overload operator() `functors`, but Functor means something different in haskell
09:33:23 <jmcarthur> buffer_overflow: anything you can define a map-like operation for
09:33:26 <Mortchek> buffer_overflow, a Functor is something that can be mapped over while preserving its structure
09:33:31 <cmccann> :t fmap
09:33:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:33:35 <rwbarton> @where typeclassopedia
09:33:35 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
09:33:41 <bfig> i just added a signature to printBoth ([Vector2]->[Vector2]->String) and it worked :)
09:33:43 <ixmatus> mcstar Mortchek NOW I see why return is an identity function!
09:33:44 <buffer_overflow> so a functor is a mathematical structure?
09:33:46 <rwbarton> http://www.haskell.org/haskellwiki/Typeclassopedia#Functor
09:33:48 <buffer_overflow> like an isomorphism?
09:33:52 <bfig> i don't think i have been using overloaded strings
09:33:54 <Mortchek> ixmatus, \o/
09:34:01 <merijn> buffer_overflow: The name comes from category theory (though it doesn't match exactly)
09:34:05 <buffer_overflow> ah
09:34:08 <mcstar> well, it lift the thing into the monad, sort of identity
09:34:09 <cmccann> buffer_overflow, that's roughly where haskell gets the term from, yes
09:34:12 <bfig> the error message is the title of the hpaste
09:34:17 <rwbarton> that's not the whole error message
09:34:27 <buffer_overflow> so  fmap is a lower-level map?
09:34:30 <jmcarthur> well, it's a specialized instance of the category theory notion of functor
09:34:31 <merijn> buffer_overflow: But the type shown by lambdabot should be relatively clear in explaining what it does
09:34:39 <cmccann> no, fmap is a generalized version
09:34:40 <merijn> buffer_overflow: map is a special case of fmap for [], yes
09:34:43 <b__> if anyone is very familiar with the collate problem/conjecture, could you comment on my code for calculating the first N sequences?
09:34:45 <hpaste> Skola pasted “Collatz” at http://hpaste.org/75880
09:34:45 <ixmatus> mcstar oh okay - that is good to know
09:34:50 <merijn> > fmap (+1) [1..10]
09:34:51 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
09:34:58 <b__> collatz*
09:35:01 <merijn> > fmap (+1) (Just 2)
09:35:02 <lambdabot>   Just 3
09:35:08 <jmcarthur> @instances Functor
09:35:09 <lambdabot> ((,) a), ((->) r), ContT r m, Either a, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, ST s, StateT s m, WriterT w m, []
09:35:11 <typoclass> buffer_overflow: however, i don't think that understanding category theory will help you a lot in using or understanding haskell. reading typeclassopedia is much more helpful
09:35:19 <buffer_overflow> right
09:35:23 <buffer_overflow> I don
09:35:31 <merijn> fmap (+1) ('c', 1)
09:35:34 <merijn> > fmap (+1) ('c', 1)
09:35:35 <lambdabot>   ('c',2)
09:35:55 <merijn> > fmap (+1) (Left 'c')
09:35:56 <lambdabot>   Left 'c'
09:35:59 <jmcarthur> i think learning some category theory *is* helpful in FP, but only when you are already very comfortable with an FP language
09:36:03 <merijn> > fmap (+1) (Right 1)
09:36:05 <lambdabot>   Right 2
09:36:10 <buffer_overflow> I'm still getting to grips with haskell
09:36:16 * byorgey agrees with jmcarthur 
09:36:38 <ixmatus> buffer_overflow I actually am reading the Haskell Category Theory wikibooks page and I found it very illuminating - it's a little think unless you've studied category theory, and it's causing me to ask a lot of questions; but it really drove home the mathematical underpinnings of Haskell for me
09:36:38 <rwbarton> you should be very familiar with at least one of category theory and an FP language :)
09:36:41 <jmcarthur> it helps you notice a lot of common patterns and, in your mind if not in your code, abstract over them in potentially useful ways
09:36:46 <buffer_overflow> that functional programming class I'm taking on coursera (it uses scala though) is also helping me learn FP ^_^
09:36:49 <ixmatus> buffer_overflow this is what I've been reading http://en.wikibooks.org/wiki/Haskell/Category_theory
09:36:50 <b__> or if someone is willing to comment on style that would be super-helpful too: http://hpaste.org/75880
09:36:56 <Mortchek> I doubt at this point in my Haskell education that most people need to know what a zygohistomorphic prepromorphism is :P
09:37:08 <buffer_overflow> ixmatus: I'll check that out :)
09:37:13 <cmccann> also, it's harder than you'd think to explain haskell to someone who knows category theory
09:37:21 <cmccann> just because of all the bullshit hand-wavy stuff we do :P
09:37:25 <buffer_overflow> lol
09:37:26 <jmcarthur> Mortchek: zygohistomorphic prepromorphisms are too special-case to be productive to learn anyway
09:37:48 <ixmatus> cmccann I don't have a category theory background - but I can understand the proofs
09:37:50 <Mortchek> I just use that term because it sounds funny
09:37:55 <jmcarthur> Mortchek: but catamorphisms, anamorphisms, etc... useful to understand!
09:38:00 <Mortchek> Indeed
09:38:18 <BlackShift> I was planning to learn haskell and category theory at the same time, hope I'm not making it too difficult for myself :)
09:38:25 <mcstar> does anyone here use Okular a lot, and a tiling wm, and wants to restore his/her open documents on next login?
09:38:26 <jmcarthur> BlackShift: i think that sounds difficult
09:38:28 * cmccann notes that it doesn't even make sense to define a Functor instance between Category instances in Haskell...
09:38:41 <buffer_overflow> what are (cata|ana|iso|homo)morphisms?
09:38:44 <jmcarthur> cmccann: Functor should be called Endofunctor, really
09:38:59 <cmccann> jmcarthur, even that's too broad
09:39:02 <jmcarthur> true
09:39:09 <rwbarton> a homomorphism is just a map that preserves whatever structure you care about
09:39:13 <cmccann> since "Either _ e" is a valid endofunctor
09:39:17 <buffer_overflow> so morphisms are basically functions
09:39:21 <cmccann> but not a Functor instance
09:39:39 <jmcarthur> buffer_overflow: catamorphisms are generalized folds. anamorphisms are generalized unfolds
09:39:48 <cmccann> also, there's no true identity functor, every Functor instance is a subcategory of Hask
09:39:50 <buffer_overflow> ah
09:40:13 <nand`> isomorphisms are pairs of morphisms that give the identity under composition
09:40:18 <buffer_overflow> so the factorial function can be defined as a catamorphism on the natural numbers?
09:40:36 <nand`> buffer_overflow: http://www.willamette.edu/~fruehr/haskell/evolution.html#cartesian
09:40:37 <nand`> :)
09:40:45 <jmcarthur> buffer_overflow: there are sometimes a few different ways to describe algorithms like that
09:40:47 <cmccann> so Functor is functors from Hask to a subcategory of itself, while Category is a category with the same objects as Hask but different morphisms, and Arrow implies a functor from Hask to the other category.
09:40:53 <cmccann> this is clearly a sensible use of terminology
09:40:57 <nand`> (or the one before that)
09:40:58 <jmcarthur> buffer_overflow: it could also be described as an anamorphism
09:41:14 <nand`> factorial is clearly a hylomorphism
09:41:16 <buffer_overflow> and an isomorphism?
09:41:37 <nand`> you unfold the number (eg. 5) to the list [5,4,3,2,1]; then refold that under (*)
09:41:37 <rwbarton> cmccann: right, it's sort of bad. even trying to say exactly what set the objects of Hask are is a quagmire
09:41:51 <nand`> buffer_overflow: I gave a description of isomorphisms a bit above
09:41:58 <Mortchek> The way I tend to think of isomorphisms is, e.g., you can define all the same operations on the sets {0, 1} and {True, False}
09:42:02 <cmccann> rwbarton, also there's inconsistent amounts of hand-wavy idealization involved when people talk about Hask
09:42:15 <rwbarton> my best attempt involved Hask being a varying category depending on what data/newtype declarations are in scope
09:42:16 <jmcarthur> nand`: and the (*) is an anamorphism *or* a catamorphism
09:42:27 <nand`> the way I think of isomorphisms is “two things are isomorphic; or there exists an isomorphism between two things, if you can losslessly convert between them”
09:42:49 <nand`> ‘lossless’ satisfying the property of identity
09:43:07 <b__> Haskell / FP seems to exist on the border of language
09:43:17 <b__> if that makes sense
09:43:26 <mcstar> no
09:43:36 <b__> haha thought so
09:43:38 <jmcarthur> i do not understand
09:43:50 <byorgey> buffer_overflow: actually, factorial isn't a catamorphism; a catamorphism over the naturals is something you can compute by iterating a function, i.e. by replacing every Succ with some function f
09:44:04 <byorgey> buffer_overflow: but there are no f and z such that   f (f (f (f ... z)))) computes factorials
09:44:08 <nand`> {True, False} and {1, 0} are isomorphic because you can convert True -> 1 -> True; or False -> 0 -> False without losing information in the roundtrip; (there are actually two isomorphisms here, consider also True -> 0 -> True and False -> 1 -> False)
09:44:13 * cmccann tends to think of the phrase "up to isomorphism" as a formalized way of saying "eh, close enough"
09:44:57 <jmcarthur> byorgey: it is a catamorphism over lists of naturals, though
09:44:58 <nand`> b__: the only borders of languages I know are the ones between expressivity classes
09:45:05 <nand`> or whatever the proper term for that is
09:45:08 <byorgey> jmcarthur: agreed
09:45:21 <mcstar> i think he meant 'english'
09:45:32 <typoclass> jmcarthur: i'm curious, if you have a programmer dude who understands folds, and a mathy programmer dude who understands folds and catamorphisms, what are the advantages that he has?
09:45:34 <byorgey> jmcarthur: as nand` said, you can see it as a hylomorphism, 5 -> [1,2,3,4,5] -> 120
09:45:44 <aristid-ipad> byorgey: so i started reading your article about factorial diagrams, it said "i used my own libray" and i thought "he shouldve used diagrams instead" until i noticed it was your blog and diagrams indeed :p
09:45:45 <Mortchek> nand`, in this way, can we also define an isomorphism between the naturals and the integers, since they have the same cardinality?
09:45:45 <cmccann> byorgey, are you sure about that? it's possible to write factorial with church numerals, isn't it?
09:45:48 <byorgey> it's also a paramorphism, but no need to get into all of that =)
09:46:01 <nand`> Mortchek: yes
09:46:17 <byorgey> cmccann: not directly, you would have to use some kind of pairing trick, just like for predecessor
09:46:19 <b__> I'm being too vague obviously, but some concepts in FP--like monads--seem to express concepts that are not easily expressible in natural language
09:46:23 <byorgey> cmccann: try it! =)
09:46:24 <nand`> Mortchek: isomorphisms on sets are just bijections; and sets have the same cardinality iff there exists a bijection between them
09:46:26 <b__> hence: no good Monad tut exists
09:46:33 <Mortchek> Oh, neat.
09:46:34 <cmccann> byorgey, well yeah, it'd involve at least one step of indirection
09:46:34 <byorgey> aristid-ipad: hehehe
09:46:44 <cmccann> but I think you'd still end up with some "f" that gives you factorial
09:47:12 <byorgey> cmccann: no, you'd end up with some f that gives you some data structure that you have to postprocess to give you factorial.  like a pair of the factorial and something else.
09:47:24 <jmcarthur> typoclass: folds *are* catamorphisms, so they understand the same thing. you need to refine what you mean by "understand" for me to answer than more meaningfully
09:47:24 <cmccann> hm
09:47:29 <jmcarthur> *that more
09:47:37 <cmccann> ah yeah, you may be right
09:47:51 <b__> anyone get what I'm trying to say?
09:47:57 <cmccann> unless there's some trickery you could do by choice of zero value
09:48:00 * cmccann considers
09:48:14 <jmcarthur> typoclass: do you mean that in the sense that a lot of programmers consider folds to be the specialization of catamorphisms to lists?
09:48:36 <mcstar> if z is a tuple...
09:48:37 <rwbarton> well fact 1 = fact 0 so that is going to be a problem
09:49:29 <cmccann> folds are clearly just the church encoding of lists, and church encoding is just a CPS-encoded pattern match with recursive calls baked in. pf, catamorphisms.
09:49:40 <nand`> usually when talking about ‘catamorphisms’ you're talking about generalizing folds, eg. stuff like (f a -> a) -> Mu f -> a; and I guess the ‘advantage’ in this case is code reuse - you only define folds, unfolds, refolds, etc. once; then use them for any foldable
09:49:49 <rwbarton> catamorphism is already not really a term *from* category theory
09:49:50 <nand`> of course, the advantage is dubious due to the overhead
09:49:55 <nand`> and typeclasses work well for this
09:50:25 <typoclass> jmcarthur: well, i'm not very mathy, and i'm trying to determine if it's worth learning things like catamorphisms. i mean, it seems like an awful lot of jargon that costs a lot of time to learn, and i'm wondering what value you really get out of it
09:50:49 <byorgey> > let f (n,fac) = (n+1, (n+1)*fac) in snd (iterate f (0,1) !! 5)
09:50:50 <lambdabot>   120
09:50:56 <cmccann> it's worth reading the... whatever the title was, bananas and barbed wire and all that paper.
09:51:19 <jmcarthur> typoclass: the biggest benefits i have reaped are that it reveals ways to decompose algorithms further and it reveals ways to optimize my code
09:51:49 <nand`> http://academic.research.microsoft.com/Paper/296068.aspx
09:51:54 <typoclass> jmcarthur: hmm, i see
09:53:04 <spaceships> typoclass: it seems like knowing a touch of category theory is part of being fluent in haskell... or at least that's whats motivating me to learn it
09:53:08 <nand`> generalizing folds also gives rise to zygohistomorphic prepromorphisms
09:53:15 <jmcarthur> typoclass: also, recognizing various recursion patterns allows you to write code more quickly, in the same sense that design patterns allow you to write out more boilerplate in OO languages more quickly...
09:53:40 <nand`> spaceships: disagree, you need to know no category theory to understand the use and laws of the CT-inspired classes in Haskell
09:54:01 <jmcarthur> typoclass: but of course it's nice to use more general code to avoid the boilerplate, too, but i wouldn't say that writing catamorphisms explicitly is very common unless you're edwardk or, sometimes, me
09:54:17 <spaceships> nand`: does it help?
09:54:19 <jmcarthur> (there are actually many who do it, but not a large percentage of haskellers do it)
09:54:26 <edwardk> i don't write catamorphisms for 99% of the recursion i do
09:54:29 <cmccann> haskell doesn't really use that much category theory, to be honest
09:54:43 <jmcarthur> edwardk: tongue in cheek
09:55:11 <cmccann> haskell more tends to jump category theorists in dark alleys and shake them down for loose terminology
09:55:14 <dolio> Well, that's because even foldr is too general to bother with most of the time.
09:55:18 <dcoutts> afterall, haskell is based on domain theory, not category theory
09:55:31 <typoclass> jmcarthur: do you have a link or googlable term on those recursion patterns? not an exhaustive list, just some examples
09:55:42 <edwardk> the biggest problem with the recursion scheme model is that once you hit hylo its already turing complete, so the process of decomposing and recomposing an answer is pretty hairy. Encoding _into_ a hylomorphism isn't obvious and the fusion laws kinda suck
09:55:45 <nand`> spaceships: it might as well confuse more than help; but some of the more abstracted-to-oblivion libraries tend to use names from CT heavily so being fluent in them may be handy
09:56:17 <monochrom> haskell is based on the dark domain of Mordor? :)
09:56:19 <edwardk> typoclass: http://comonad.com/reader/2009/recursion-schemes/
09:56:23 <yawnt`afk> LOVIN IT
09:56:29 <yawnt`afk> IT'S MATH
09:56:29 <edwardk> thats an exhaustive list ;)
09:56:31 <yawnt`afk> \ò/
09:56:36 <jmcarthur> typoclass: ah i was looking for the link edwardk gave (it's his)
09:56:45 <spaceships> nand`: but its tangential rather than central?
09:56:51 <b__> wow awesome
09:57:00 <nand`> spaceships: but eg. some concepts from CT I would get lost on trying to understand in abstract CT terms; meanwhile looking at a Hask-only example makes their function and use much more transparent
09:57:09 <nand`> spaceships: yeah, completely - it's in no way central
09:57:10 <edwardk> the old category-extras had them all implemented (though the Erwig metamorphism is implemented wrong as i recall)
09:57:19 <edwardk> and i have versions of them in the recursion-schemes package
09:57:20 <typoclass> hm thanks guys, will look at it
09:57:31 * spaceships puts down category theory textbook.
09:57:45 <edwardk> typoclass: http://comonad.com/haskell/catamorphisms.html goes through catamorphisms in detail
09:57:54 <nand`> that being said
09:57:57 <rwbarton> a category theorist is very unlikely to have heard of any of the terms in the leftmost column on that page (except *maybe* catamorphism)
09:58:10 <edwardk> i started writing others for para, etc. but around that time comonad.com got hacked and i lost 2-3 months of data
09:58:11 <nand`> the only reason I learned CT is so I could understand the ‘a monad is just a lax 2-functor from a terminal bicategory, what's the problem?’ jokes
09:58:14 <jmcarthur> i agree with the people who have advised *not* to try to learn too much of this stuff at first
09:58:15 <nand`> correction
09:58:18 <nand`> learned a tiny portion of CT
09:58:24 * cmccann still thinks that the recursion scheme nonsense has potential but that encoding and decoding to express them directly is probably not workable
09:59:07 <edwardk> yeah in the end recursion schemes _aren't_ something a category theorist will know anything about. The names sound all super technical but are mostly a result of a fetish Lambert Meertens had for greek and latin, which his students picked up on
09:59:10 <cmccann> rwbarton, also my impression is that mathematicians in general spend a lot less time thinking about corecursion and related concepts than we do
09:59:19 <aristid-ipad> nand`: is that version of the monad joke accurate?
09:59:23 <nominolo> what are people here using instead of cabal-dev?
09:59:29 <cmccann> where by "we" I mean "especially edwardk"
09:59:30 <nand`> aristid-ipad: yes, in fact
09:59:46 <nominolo> cabal-dev doesn't work with ghc 7.6
09:59:56 <rwbarton> well you must also realize that mathematicians in general spend a lot more time thinking about "additive" things than about sets
09:59:56 <jfischoff> is there something equivalent to rvm for Haskell? Basically a system for managing which ghc is active.
10:00:02 <aristid-ipad> nand`: omv
10:00:26 <aristid-ipad> hmm i can pretend the v was deliberate
10:00:46 <edwardk> the most damning things about the recursion scheme approach to me is that it really never caught on outside of Meertens students, the hylo fusion stuff never paid off in terms of performance gains or automatic algorithmic rewriting, and the deeper recursion schemes are all just the application of a (co)monad and a distributive law to the basic construction
10:00:50 <fmap> nominolo: I use cabal-dev compiled with 7.4.1
10:01:18 <nand`> aristid-ipad: source: http://ncatlab.org/nlab/show/monad <- “A third and somewhat less obvious definition says that a monad in K is a lax 2-functor from the terminal bicategory 1 to K”
10:01:20 <nominolo> fmap: my ghc 7.4.1 is apparently borked, so I was hoping to avoid that
10:01:20 <dolio> Most mathematicians spend less time thinking about most computer science topics than computer scientists.
10:01:21 <jmcarthur> aren't there many other kinds of fusion, though?
10:01:23 <nand`> ‘somewhat less obvious’
10:01:25 <edwardk> and when it comes down to it, beyond para, they aren't all that fundamental. Tarmo Uustalu once told me he regretted working on them, and he did as much work as _anyone_ to advance the theory
10:01:32 <jmcarthur> the banana split law comes to mind, for example
10:01:38 <edwardk> dolio: =)
10:01:52 <nominolo> fmap: maybe I should just go the old-fashioned route and delete it all
10:01:52 <aristid-ipad> dolio: said that way, it almost sounds obvious
10:02:07 <Jafet> @quote what's.the.problem
10:02:07 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
10:02:18 <rwbarton> most computer scientists spend less of their time thinking about objects that computers are bad at manipulating ;)
10:02:26 <cmccann> dolio, is this the point where pigworker would usually inject a comment along the lines of "there's a difference?" :P
10:02:52 <typoclass> hmm, when i read "foomorphism: tears down a structure with ____", it sounds a little how you can listify a tree in different ways by doing preorder traversal, inorder traversal, etc.
10:02:54 <nand`> incidentally, it takes a special kind of computer science to spend all day arguing over what a ‘computer scientist’ really is
10:02:57 <nand`> scientist*
10:03:04 <Eduard_Munteanu> preflex: seen pigworker
10:03:04 <preflex>  Sorry, I haven't seen pigworker
10:03:17 <spaceships> nand`: that's what philosophers do
10:04:05 <cmccann> "computer science" is not about computers and is not a science, so we're off to a good start already
10:04:09 <jmcarthur> typoclass: i wouldn't say that's quite the angle i would use to explain it. the algebra you use would pretty much determine the traversal, really
10:04:42 <nand`> every time I try arguing semantics, I come to the conclusion that every word is the exact same thing and refers to anything
10:04:44 <jmcarthur> typoclass: the recursion schemes are more about how information is propogated
10:04:50 <Skola> cmccann: why would it not be a science?
10:04:54 <rwbarton> it's true that "coalgebra", while it is studied, is much less prominent in math than "algebra"; but the normal settings for doing algebra/coalgebra are rather different anyways
10:04:58 <rwbarton> than in Haskell
10:05:00 <aristid-ipad> cmccann: we could call it Informatik
10:05:01 <cmccann> nand`, you mean that all words are identical up to some isomorphism? :P
10:05:10 <jmcarthur> @remember nand` every time I try arguing semantics, I come to the conclusion that every word is the exact same thing and refers to anything
10:05:10 <lambdabot> Done.
10:05:15 <Skola> cmccann: is it not merely a science whose boundaries are unknown?
10:05:27 <typoclass> jmcarthur: hmm okay
10:05:28 <cmccann> depends on how you define "science".
10:05:34 <mcstar> its trial and error, id hardly call that science
10:05:39 <nand`> this is readily moving into -blah territory
10:05:40 <Skola> really?
10:05:55 <rwbarton> I would say exactly the same as mcstar but with "not" inserted after the first word
10:05:56 <edwardk> A computer scientist just a mathematician who interpreted the maxim that if you can't say something constructive, don't say anything at all  rather literally.
10:06:10 <mcstar> j/k -- for clarification
10:06:19 <cmccann> but CS is more math and/or engineering depending on who you ask.
10:06:32 <cmccann> if you call math and engineering science, then so is CS. otherwise, no.
10:06:51 <jmcarthur> that's why the computer science and software engineering distinction exists, IMO
10:06:55 <nand`> I tend to avoid the term ‘computer science’ because of its negative connotations
10:07:00 <aristid-ipad> edwardk: that maxim is very intuitive to me
10:07:20 <edwardk> I find it highly intuitionistic ;)
10:07:25 <jmcarthur> lol
10:07:32 <cmccann> jmcarthur, yeah, if that distinction is made then CS is math and CE is engineering pretty much
10:08:04 <aristid-ipad> and neither is a science :p
10:08:04 <jmcarthur> cmccann: not sure where to fits things like AI in, though
10:08:04 <Skola> is there a place to put Haskell code up for review?
10:08:19 <aristid-ipad> Skola: hpaste.org
10:08:19 <edwardk> @hpaste
10:08:20 <nand`> hpaste.org
10:08:20 <lambdabot> Haskell pastebin: http://hpaste.org/
10:08:24 <edwardk> Skola: ^
10:08:27 <nand`> and, of course, pasting it here
10:08:28 <cmccann> AI goes in philosophy or theology I think :P
10:08:40 <nand`> (or selecting #haskell from the channel list on hpaste, thus making it auto-announce)
10:08:42 <Skola> my previous hpaste didn't gather a lot of interest, and understandable so
10:08:48 <edwardk> nand`: though that gets rather discouraged if it overflows the line ;)
10:09:17 <nand`> I don't think AI can be constrained to one domain (just like how every science has a huge amount of overlap)
10:09:37 <jmcarthur> AI is a bit of a science, now that you mention it
10:09:39 <Skola> but thanks for the suggestion :}
10:10:13 <mcstar> computer science and math are science, lets not argue on this one
10:10:15 <aristid-ipad> jmcarthur: how so?
10:10:15 <Jafet> AI is the set of things people haven't figured out how to make computers do yet
10:10:16 <jmcarthur> it tends to be based on the scientific method much more than the average cs research
10:10:26 <cmccann> yeah, if you take AI seriously (my flippant remark aside) it's at very least going to be overlapping cognitive science a great deal
10:10:27 <jmcarthur> experimental in nature
10:10:37 <nand`> Skola: it's best to state so if you want code critique, otherwise nobody is going to go around looking at random hpaste links and voice their opinions on it
10:10:45 <mcstar> and AI is multi-disciplinary
10:10:56 <cmccann> a lot of AI stuff involves neuroscience and linguistics and other whatnot
10:11:16 <k00mi_> cmccann: cogsci itself involves a lot of CS
10:11:23 <Skola> nand` I did, but there was an interesting discussion going on in this channel, so I think people weren't that interested
10:11:23 <nand`> ‘science’ is inherently fractal
10:11:33 <jmcarthur> i don't even know what multi-disciplinary means apart from "our ontology has failed yet again"
10:11:41 <nand`> each sub-domain resembles the whole
10:11:47 <nand`> and each sub-domain gives rise to an entire new science of sorts
10:11:50 <Skola> + my code isn't very special :}
10:11:59 <cmccann> yeah, a lot of sub-fields really overlap multiple fields, there aren't as many clear lines as university department structure suggests
10:12:01 <aristid-ipad> is machine learning considered part of ai?
10:12:10 <mcstar> jmcarthur: well, theres a point of catergorizing things, and who is to blame that they didnt get it right, right away?
10:12:17 <mcstar> things evolve
10:12:27 <mcstar> our understanding changes
10:12:34 <mcstar> we see new connections all the time
10:12:41 <mcstar> the world is dynamic
10:12:49 <jmcarthur> this is definitely -blah material
10:12:58 <jmcarthur> but instead of continuing the discussion there, i will leave now
10:14:16 <mcstar> well, Herr operator merijn ban anyone so far
10:14:18 <BlackShift> i'm here as an astronomer because someone told me that what we do with our data can actually best be described with category theory and that our methodology is very similar to Haskell
10:14:21 <mcstar> didnt ban*
10:14:52 <BlackShift> so it's all multi-disciplinary
10:15:57 <BlackShift> and, as a dutch guy I must be an intuitionist :)
10:15:58 <cmccann> heh, I saw thoat factorization diagrams post from reddit and thought "hey, I bet the diagrams package would work great for that" before I realized whose blog it was
10:16:19 <aristid-ipad> cmccann: !
10:16:44 <byorgey> =)
10:17:05 <dolio> They were definitely not what I was expecting.
10:17:34 <cmccann> I really like that 1-36 chart. it'd make a great poster or something
10:18:07 <BlackShift> I just spend the entire first hour of my hands-on Haskell experience getting Diagrams to work on Ubuntu 10.04..
10:18:12 <BlackShift> thanks for these nice examples
10:18:23 <Skola> I'll try once more, since more/new peeps might be online now: any general/style-related criticism (or specific to the problem this code tries to solve; calculating Collatz chains)? http://hpaste.org/75880
10:18:31 <nand`> cmccann: can you elaborate?
10:18:43 <cmccann> nand`, hm? on what?
10:18:47 <byorgey> BlackShift: excellent, so you got it to work?
10:19:14 <BlackShift> byorgey, yeah, by installing ghc and haskell-platform by hand
10:19:19 <nand`> cmccann: I don't understand your message about ‘diagrams’, somebody's blog and posts on factorization
10:19:27 <cmccann> Skola, posting it here might get a better response: http://codereview.stackexchange.com/
10:19:28 <aristid-ipad> byorgey: maybe your blog should say in the subtitle or so that it's yours. i know it's in the about page but that is a few clicks away
10:19:32 <BlackShift> I was naively assuming that I could use whatever is in this old distribution
10:19:35 <cmccann> rather than waiting for people on IRC to not be distracted
10:19:42 <cmccann> nand`, oh
10:19:46 <cmccann> ask byorgey about that :P
10:19:50 <byorgey> cmccann: yeah, I might look into getting posters printed on demand or something.  Once I make them prettier with color and everything.
10:19:52 * cmccann needs to leave anyhow
10:20:12 <byorgey> nand`: http://mathlesstraveled.com/2012/10/05/factorization-diagrams/
10:20:16 <Skola> cmccann: thanks for the suggestion :]
10:20:16 <byorgey> aristid-ipad: why?
10:20:41 <cmccann> byorgey, if you can try to make the color meaningful somehow. color for its own sake would be distracting.
10:20:44 <aristid-ipad> byorgey: so people aren't confused like me or cmccann were?
10:20:55 <nand`> byorgey: oh, I think I see the joke now
10:20:57 <byorgey> cmccann: yes, the idea would be to have a color for each prime
10:21:17 <cmccann> byorgey, that would probably work nicely
10:21:22 <typoclass> byorgey: oh nice :) thanks for the link
10:21:31 <byorgey> aristid-ipad: people only get confused when there's a post that crosses communities like this.  I write that blog mostly with math education people, high schoolers, etc. in mind
10:21:47 <byorgey> every now and then I use some Haskell and people here end up seeing it
10:21:51 <cmccann> Skola, haskell code seems to usually get one or two responses there, and if nothing else I'll give it a look myself later tonight
10:22:17 <cmccann> but right now I'm in the middle of unpacking after a move and should probably get back to work :T
10:22:25 <byorgey> BlackShift: cool, glad you got it to work.  Feel free to join #diagrams if you have questions
10:22:42 <aristid-ipad> byorgey: i dont see why you would want to obscure your name, but its your blog *shrug*
10:22:54 <BMeph> byorgey: Maybe (to appease aristid-ipad, wink-wink), you should make this part bold: " (yes, this is the library I wrote myself; I promise to write more about it soon!)"
10:23:14 <byorgey> aristid-ipad: I'm not trying to purposely obscure my name.  Maybe you're right, there's somewhere I could put my name on the front page
10:23:28 <mcstar> did someone mention collatz?
10:23:33 <nand`> byorgey is the only ‘Brent’ I know; no confusion for me
10:23:42 <BMeph> mcstar: Skola did.
10:23:46 <t7> @hoogle a -> (a -> Bool) -> Maybe a
10:23:47 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
10:23:47 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
10:23:47 <lambdabot> Test.QuickCheck.Gen suchThatMaybe :: Gen a -> (a -> Bool) -> Gen (Maybe a)
10:24:03 <mcstar> ive been working on it, without much success XD
10:24:25 <Skola> cmccann: I've always had a lot of nice and very educational response here when posting my code
10:24:56 <Skola> no response must mean it's either pretty idiomatic and boring, or completely hopeless : D
10:24:57 <BMeph> Skola: I remember reading a paper that accommodated the negatives into its tree (showing the connections between the numbers). I'll see if I can find it again.
10:25:07 <cmccann> Skola, or that people are distracted
10:25:12 <Skola> cmccann, sure
10:25:18 <cmccann> problem with IRC is that it's mostly now-or-never
10:25:28 <cmccann> anyway, I really do need to go
10:25:31 <mcstar> Skola: maybe you can use this http://sprunge.us/EKQB
10:25:35 <Skola> I <3 it if people help me, and don't mind at all if people don't :}
10:25:43 <Skola> BMeph that would be supercool
10:25:51 <t7> @hoogle Maybe a -> Either a ()
10:25:51 <lambdabot> Prelude Left :: a -> Either a b
10:25:51 <lambdabot> Data.Either Left :: a -> Either a b
10:25:51 <lambdabot> Prelude Right :: b -> Either a b
10:25:59 <Skola> mcsmash I will have a look :} thanks
10:26:00 <BMeph> Skola: There's also "I don't know if the little I know about the subject is worth making a response," and "hey, that's interesting; I need to spend some time really looking this over for a bit..." responses, too. ;)
10:26:37 <hpaste> clahey pasted “Dance.hs” at http://hpaste.org/75881
10:26:39 <Skola> BMeph yeah sure, though I appreciate every little comment :}
10:28:55 <mcstar> Skola: also, i have a mathematica notebook that has some stuff too
10:29:01 <t7> is this not a thing? maybe (return ()) Left c
10:29:29 <mcstar> i know how im going to prove the conjecture, so i can give these away
10:29:39 <t7> ignore the c
10:29:58 <typoclass> :t maybe
10:30:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
10:30:18 <Skola> anything you wanna share on the problem is welcome :D
10:30:32 <mcstar> Skola: i mean, can you work with it?
10:30:40 <typoclass> t7: so you want to produce an "Either a ()" ...?
10:30:45 <mcstar> theres no point in giving you the notebook if you cant open it
10:30:52 <Skola> mcstar yes I can
10:30:54 <t7> let test = maybe (return ()) Left in do { test Nothing; test (Just "error!") };
10:30:56 <t7> > let test = maybe (return ()) Left in do { test Nothing; test (Just "error!") };
10:30:57 <lambdabot>   <no location info>: parse error on input `;'
10:31:29 <t7> just use Either a () instead?
10:32:23 <mcstar> hoho, 1.4M, lets see if sprunge can deal with ti
10:32:59 <typoclass> t7: i think the Monad instance for Either is not in Prelude, or possibly not even in the base package. if you want to use "return ()" like that you're gonna need that
10:33:12 <t7> import Control.Monad.Instances
10:33:23 <t7> its in the platform somewhere
10:33:25 <typoclass> t7: ... no wait, erm, what are you trying to do again? :)
10:33:45 <t7> well i have some checks that can throw an error, but otherwise return nothing useful
10:33:57 <t7> so it made sense to return Maybe Error
10:34:52 <Eduard_Munteanu> That would be a bit odd.
10:35:11 <Eduard_Munteanu> e.g. if you later want to use it in a Maybe monad context
10:35:39 <Eduard_Munteanu> Why not use Either Error ()?
10:35:47 <t7> well i am at the moment
10:36:05 <mcstar> sprunge failed
10:36:14 <typoclass> > let test = maybe (Right ()) Left in do { test Nothing; test (Just "error!") }
10:36:15 <lambdabot>   Left "error!"
10:37:05 <typoclass> t7: ^^. i agree with eduard that it's a little unconventional (Maybe normally has Just for the "it worked" condition), but you could add a big fat comment what you're doing
10:37:54 <ornicar> @help
10:37:55 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:44:01 <ornicar> hello, newbie here :) I try to make an instance of Semigroup, and I don't understand the compiler error. For instance if I do:
10:44:04 <ornicar> instance Semigroup [a] where (<>) = (++)
10:44:10 <ornicar> then the compiler says:
10:44:33 <ornicar> '<>' is not a (visible) method of class 'Semigroup'
10:44:53 <ornicar> what is the right way to make an instance of Semigroup?
10:45:03 <Jafet> You did not import (<>).
10:45:04 <rwbarton> what package is providing Semigroup?
10:45:10 <ornicar> Data.Semigroup
10:45:13 <shachaf> ornicar: :i Semigroup
10:45:32 <rwbarton> I see packages Semigroup and semigroups which both have Data.Semigroup with a class Semigroup with different operation names
10:45:34 <johnw> it's from edwardk's package, I believe
10:45:49 <edwardk> semigroups is the one you want
10:45:52 <johnw> category-extras?
10:46:14 <johnw> ah, maybe not
10:46:15 <shachaf> category-extras is dead.
10:46:19 <ornicar> hmm cabal says I have semigroups installed
10:46:25 <aristid-ipad> johnw: thats outdated, now there are 3000 edwardk packages
10:46:27 <johnw> long live category-extras?
10:46:30 <johnw> haha
10:46:37 <edwardk> aristid-ipad: i blame roconnor ;)
10:46:42 <johnw> ok, looks like semigroups is very fresh
10:47:03 <aristid-ipad> edwardk: well i think it's an improvement to some degree
10:47:06 <ornicar> and when I do :i Semigroup I can see (<>) :: a -> a -> a
10:47:09 <shachaf> johnw: Huh? It's almost two years old.
10:47:14 <edwardk> aristid-ipad: i like most of it
10:47:25 <shachaf> ornicar: Is that exactly what :i says?
10:47:32 <shachaf> Not (Data.Semigroup.<>) :: a -> a -> a?
10:47:59 <aristid-ipad> edwardk: but dont let practicality prevent a bad joke
10:48:01 <johnw> shachaf: last update 9/6/12
10:48:07 <ornicar> https://gist.github.com/3845603 shachaf
10:48:22 <edwardk> Data.Semigroup chose (<>) as its operator because at the time it had been 6 months since we approved it for monoid but at the time it still had gone nowhere. ;)
10:48:26 <shachaf> ornicar: I don't see an error there. :-)
10:48:55 <ornicar> I do see one when I try to make an instance of Data.Semigroup in my code.
10:49:02 <edwardk> and it works out pretty well because you can import either Data.Monoid now and get (<>) tied to mappend, or import Data.Semigroup and get all the monoids and (<>) tied to the semigroup operation which should be compatible
10:49:34 <ornicar> oh my bad :( I messed up the Semigroup import
10:49:48 <ornicar> it's working now :) sorry for the noise and thanks for the help
10:50:11 <shachaf> lrwxrwxrwx 1 shachaf shachaf 9 Sep  6 15:26 /home/shachaf/.ghc/ghci_history -> /dev/null
10:50:40 <typoclass> shachaf: sounds unhelpful
10:51:12 <KirinDave> shachaf: does not concern himself with the past, only the <reverb>future</reverb>
10:51:32 <buffer_overflow> should  I prefer  fmap to map?
10:51:55 <johnw> i wouldn't
10:51:59 <BMeph> buffer_overflow: Yes. Next question? ;þ
10:52:08 <rwbarton> no
10:52:13 <rwbarton> use map when you can use map
10:52:16 <johnw> fmap instinctively makes me think something other than a List or Map is involved
10:52:22 <shachaf> I agree with BMeph and rwbarton.
10:52:36 <KirinDave> buffer_overflow: Use fmap when you're talking about a functor.
10:53:31 <shachaf> I think using the name "map" for "fmap" wouldn't have been a terrible decision.
10:53:38 <johnw> I agree
10:53:51 <johnw> someday I'd like to see the Prelude redone
10:54:18 <johnw> so that id and . come from Category, for example, and map is fmap, and a few other things
10:54:18 <monochrom> go with your heart
10:54:26 <KirinDave> haha, believe in yourself.
10:54:31 <shachaf> I'd like to see the Prelude redone, but not by the sort of person who likes the idea of redoing the Prelude.
10:54:47 <KirinDave> shachaf: Game of Haskell Thrones logic.
10:54:50 <johnw> I wouldn't mind you being in charge of it, shachaf
10:54:56 <shachaf> I would!
10:55:02 <johnw> it's like a presidency: the best candidate is the one who doesn't want the job
10:56:50 <rwbarton> of course how to redo Prelude depends on what degree of backwards compatibility is desired
10:56:52 <monochrom> I don't like to redo Prelude. so I am suitable for redoing Prelude.
10:57:11 <johnw> rwbarton: I'd be ok with {-# LANGUAGE NewPrelude #-}
10:57:16 <monochrom> some things I will redo in the Prelude: head :: [a] -> Maybe a
10:57:22 <monochrom> tail :: [a] -> Maybe [a]
10:57:31 <rwbarton> that function already exists doesn't it
10:57:33 <rwbarton> listToMaybe
10:57:36 <monochrom> and most importantly, fromJust :: Maybe a -> Maybe a
10:57:44 <rwbarton> ok, sarcasm detected :)
10:57:45 * BMeph thinks that "Haskell2" should rename "fmap" as "map", and "map" to "lMap". He also thinks that "mappend" should've been camel-cased to mAppend, so-as to break trying to read it as "map-pend"...
10:57:48 <johnw> rwbarton: and lenses have that behavior too
10:57:56 <shachaf> uncons :: [a] -> Maybe (a,[a])
10:58:20 <NadiaYvette> head and tail sound good, fromJust is just a bad idea.
10:58:32 <shachaf> safeHead :: [a] -> Maybe a; safeHead = unsafeCoerce
10:58:39 <johnw> monochrom: lol
10:59:09 <shachaf> unsafeCoerce totally works there!
10:59:12 <johnw> so, before we have Haskell Prime, we'll make Haskell Choice and Haskell Select
10:59:14 <hpc> BMeph: mappend should just be (++)
10:59:16 <NadiaYvette> Undoing the Haskell 98 polymorphic scare damage would be very nice.
10:59:20 * shachaf wonders just how many standard library functions can be replaced with unsafeCoerce.
10:59:25 <johnw> hpc: agreed
10:59:28 <johnw> or <>
10:59:30 <rwbarton> already I hear about six suggestions for redoing Prelude I disagree with
10:59:31 <typoclass> NadiaYvette: absolutely. i think it's actually worsened by the same module having fromMaybe right next to fromJust, where one is perfectly fine and the other is dangerous and would nearly warrant an 'unsafe' in the name
10:59:36 <hpc> (<>) is too wonky a symbol
10:59:48 <vividrain> unicorns :: [a] -> [Unicorn]
10:59:56 <shachaf> (<>) = (/=)
10:59:57 <johnw> rwbarton: which is likely why it's never happened
11:00:05 <rwbarton> well I am glad
11:00:08 <johnw> shachaf: are you a Pascal boy?
11:00:16 <NadiaYvette> :t fromMaybe
11:00:17 <lambdabot> forall a. a -> Maybe a -> a
11:00:24 <hpc> i still want (<=>) = compare
11:00:27 <rwbarton> since IMO most of the suggested changes are for the worse :)
11:00:32 <shachaf> johnw: Visual Basic 4 lyfe
11:00:46 <johnw> shachaf: haha
11:00:46 <typoclass> NadiaYvette: it's just "here's a default value and a Maybe"
11:01:00 <johnw> let's for a Prelude Committee
11:01:10 <johnw> we'll write all our suggestions on a wall, and everyone gets to strike one
11:01:41 <BMeph> hpc: "++"/"<>" is a symbolic form which doesn't preclude having a word form for the function. I'm just saying that if it has to be in a word form at all, then I highly prefer mAppend to mappend, even though I'm not fond of camel case in general. Nothing against it, just not fond of it.
11:01:53 <typoclass> shachaf: so are we agreed then? we all give our conflicting pie-in-the-sky suggestions to you, and you have to sort it out? :-D
11:02:13 <shachaf> typoclass: No, rwbarton has taken over.
11:02:22 <rwbarton> just you watch and see
11:02:27 <rwbarton> div will become unsafeDiv
11:02:31 <rwbarton> sqrt will become unsafeSqrt
11:02:34 <johnw> unsafeHead
11:02:37 <NadiaYvette> I liked it when Monoid had nice list names.
11:02:45 <rwbarton> asTypeOf will become const
11:02:47 <johnw> mAppend is so ugly
11:02:50 <rwbarton> it will be a Haskeller's dream
11:03:05 * BMeph comments: Icon fanboi over here!
11:03:11 <monochrom> I think you also want unsafeSubtract
11:03:20 <shachaf> div :: (a:Nat) -> (b:Nat) -> NonZeroProof b -> DividesProof a b -> Nat
11:03:22 <rwbarton> monochrom, very possibly, cannot be too safe!
11:03:23 <johnw> i think main should be called unsafeMain
11:03:28 <Clint> i want unsafeId
11:03:41 <shachaf> Clint: That already exists, with type a -> b
11:03:43 <johnw> and allow operator forms, like unsafe+
11:03:54 <johnw> :t unsafeId
11:03:55 <lambdabot> Not in scope: `unsafeId'
11:03:58 <NadiaYvette> I'll settle for sexier nomenclature vs. safety or most other considerations.
11:03:58 <typoclass> i want a split function in the new Prelude
11:04:06 * BMeph is now relentlessly trying to find a program in which to use "unsafeCoerce unsafeHead" in... >;)
11:04:06 <bitonic> :t unsafeCoerce
11:04:08 <lambdabot> Not in scope: `unsafeCoerce'
11:04:13 <bitonic> @hoogle a -> b
11:04:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:04:13 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
11:04:13 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
11:04:26 <rwbarton> is unsafeCoerce id = unsafeCoerce?
11:04:33 <shachaf> Yep.
11:04:44 <shachaf> Er, no.
11:04:51 <shachaf> Only if you restrict the type to be a function.
11:05:08 <rwbarton> So, yes.
11:05:19 <shachaf> unsafeCoerce is id in implementation.
11:05:39 <shachaf> Just with a more general type.
11:07:11 <NadiaYvette> What I'd like most out of a redone Prelude is natural number intrinsics.
11:07:40 <NadiaYvette> Monad comprehensions would also be nice to have back.
11:07:57 <buffer_overflow> http://ideone.com/2lqQN I keep hearing on discussions about Algebraic Data Types that a compiler will help you know if you've got all cases covered. What does that mean? In this case the code compiles  fine even though I don't specify a case to return a grade of F
11:08:15 <shachaf> buffer_overflow: That link is broken.
11:08:20 <shachaf> But try compiling with -Wall
11:08:33 <buffer_overflow> http://ideone.com/2IqQN
11:08:48 <shachaf> Are you typing the link by hand?
11:08:52 <buffer_overflow> yes
11:09:02 <Clint> what's the real url then?
11:09:03 <monochrom> haha, big mistake to trust humans
11:09:04 <NadiaYvette> Basically more compiler magic surrounding integer literals so natural number literals come out as-needed.
11:09:15 <typoclass> buffer_overflow: the compiler will help you with a warning, if you enable it (-Wall)
11:09:16 <shachaf> Anyway, the issue is different here.
11:09:20 <shachaf> typoclass: No it won't.
11:09:32 <shachaf> Nothing guarantees that a function is surjective.
11:09:44 <buffer_overflow> what does surjective mean
11:09:52 <rwbarton> you have "| otherwise" so your function cannot fail to cover all input cases
11:09:57 <buffer_overflow> oh
11:10:00 <shachaf> buffer_overflow: That it returns every possible value of its type.
11:10:17 <buffer_overflow> ah I remember, surjective means it maps to everything in its codomain
11:10:21 <shachaf> buffer_overflow: The thing you can get warnings about is when you don't handle every possible *input*.
11:10:30 <shachaf> (Though you wouldn't get that warning here either.)
11:10:49 <tdammers> it's like #haskell is this strange place where every noun has a conoun
11:10:50 <rwbarton> you also don't return a grade of E btw :)
11:10:55 <buffer_overflow> lol
11:11:12 <monochrom> very interesting interpretation of "all cases covered"
11:11:35 <buffer_overflow> so anyone have an example of where the compiler will automagically inform you that you havent got all cases covered?
11:12:03 <monochrom> fj (Just x) = x.  compile with -Wall
11:12:19 <rwbarton> don't you mean unsafeFj
11:12:43 <monochrom> no need for a broken toy function to have a meaningful name
11:12:54 <buffer_overflow> what does Fj mean?
11:13:04 <monochrom> it means a function name
11:13:32 <monochrom> it means this is the 10th function I write today. fa, fb, ..., fj, fk, ...
11:13:33 <latro`a> it was supposed to be an abbreviation of fromJust
11:13:37 <latro`a> >.>
11:13:47 <typoclass> monochrom: i have no idea what you're on about ...
11:13:48 <aristid-ipad> :t fromJust -- :P
11:13:49 <lambdabot> forall a. Maybe a -> a
11:14:35 <rwbarton> sorry, I just get annoyed by all the "head :: [a] -> Maybe a" hysteria
11:14:41 * hackagebot data-accessor-template 0.2.1.10 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-template-0.2.1.10 (HenningThielemann)
11:14:47 <buffer_overflow> ah
11:14:54 <aristid-ipad> so fj can stand for fromJust
11:15:05 <buffer_overflow> :t fromJust
11:15:06 <lambdabot> forall a. Maybe a -> a
11:15:13 <monochrom> do you follow the contextual discussion? it says, what is an example of the compiler telling you that you forgot one case of an algebraic data type
11:15:42 <buffer_overflow> I love magical compilers
11:15:54 <aristid-ipad> monochrom: still fj can be a backronym :P
11:16:11 <rwbarton> monochrom: me? yes, of course
11:16:37 <monochrom> well sure, but someone asked me what I am on about.
11:17:06 <rwbarton> oh, okay
11:17:36 <aristid-ipad> oh, that was typoclass
11:17:48 <typoclass> buffer_overflow: i think you have a point. ghc warns when you define a function and then use it nowhere, so it'd be plausible to have a warning about unused constructors. but i don't think it'd be terribly useful because one use would have to be enough to shut up the warning, so you'd still be free in your next function to again forget a constructor ...
11:19:28 <buffer_overflow> right
11:19:48 <tdammers> I think warning about unused constructors would be more irritating than helpful
11:20:17 <tdammers> after all, if any pattern match has a catch-all case, any "unused" constructor is also covered
11:20:32 <tdammers> I want to be warned about non-exhaustive patterns, not about unused constructors
11:22:19 <typoclass> tdammers: right, we all agree deconstructing is fine, buffer_overflow was asking about constructing ...
11:23:26 <tdammers> as in, you declare a constructor but never actually construct an instance through it?
11:23:49 <t7> (and its not exported_
11:23:55 <tdammers> warning about that would be really annoying
11:24:46 <rwbarton> it also doesn't seem very likely to catch any errors
11:24:49 <typoclass> tdammers: yeah, it wouldn't be very useful. this was his question, btw http://ideone.com/2IqQN
11:26:28 <tdammers> it would warn about dead code
11:26:36 <tdammers> but there's usually a reason for yet-unused constructors
11:26:44 <tdammers> such as you're going to use them later
11:48:00 <buffer_overflow> I love Haskell
11:48:09 <mcstar> you think you love it
11:48:27 <buffer_overflow> it's safer than C, more expressive than C,etc.
11:49:22 <buffer_overflow> and the glorious glasgow haskell compiler spits out code that's almost as fast as the code that my C compiler would have spat out have I written the program in C.
11:49:31 <buffer_overflow> had*
11:49:53 <donri> (sometimes faster, if you can benefit from parallelism)
11:49:54 <lambdabot> donri: You have 1 new message. '/msg lambdabot @messages' to read it.
11:50:42 <mcstar> sometimes your stack blows
11:50:59 <mcstar> sometimes you dont know how the hell make something strict, to actually make it fast
11:51:16 <mcstar> sometimes you are just not sure how to express the thing you want without mutation
11:51:18 <mcstar> sometimes....
11:51:41 <mcstar> its a journey, you are only seeing the lady, you havent talked to her
11:52:21 <buffer_overflow> :(
11:54:36 <buffer_overflow> I'm thinking of writing all the GNU coreutils in haskell
11:55:04 <mcstar> also, gcc is probably not the fastest c compiler
11:55:51 <buffer_overflow> maybe clang is faster
11:59:42 <mcstar> im not an expert or anything, but why would you rewrite coreutils?
11:59:51 <tdammers> I thought the general consensus was that gcc was a horribly mess but nobody cared enough to fix it?
11:59:56 <mcstar> why not spend your time improving haskell+shell interaction then?
12:00:45 <latro`a> or just improving shells
12:00:46 <latro`a> -_-
12:00:49 <mcstar> make haskell better suited for shell scripts
12:01:06 <typoclass> buffer_overflow: sure, go for it :) at minimum, it'll be enlightening to write things like cat, sort, seq in haskell
12:01:33 <typoclass> ... well maybe those 3 are not exactly the most enlightening :) but in principle
12:02:21 <geekosaur> depends.  use them to learn how to use conduits?
12:02:22 <mcstar> typoclass: i think the devil is in the details, does he really want to duplicate functionality exactly? with the same command line arguments? with documentation?
12:03:53 <mcstar> also, it would be interesting to offer those as part of haskell
12:03:57 <Clint> buffer_overflow: http://www.haskell.org/haskellwiki/Simple_unix_tools
12:04:10 <typoclass> mcstar: sure, you can spend infinite time on that project, but you can also just spend 1 hour and come up with just 2 tools that are minimal, but working
12:04:12 <mcstar> so, you wouldnt have to spawn a process and pipe text, but stay in haskell, mostly
12:05:00 <mcstar> hm, find is not even part of coreutils
12:05:31 <typoclass> Clint: right i was thinking of that page, but didn't link it i feel it has some problems ...
12:05:36 <Clint> certainly
12:05:46 <typoclass> *because
12:05:47 * Eduard_Munteanu wants a convenient Haskell shell
12:06:30 <typoclass> Eduard_Munteanu: me too! do you have any ideas for features so far?
12:07:06 <Eduard_Munteanu> I'm not really sure what it should look like. :/
12:07:10 <monochrom> what does "Haskell shell" mean here?
12:07:11 <Nafai> Haskell shell?  a better REPL or a command shell similiar to scsh?
12:07:18 <mcstar> make sure type inference will work with 'ls'
12:07:23 <mcstar> i dont want to anotate ls all the time
12:07:32 <Eduard_Munteanu> monochrom: a convenient Haskell library I can use in say ghci instead of bash
12:08:23 <typoclass> mcstar: interesting, how do you mean 'annotate ls'?
12:08:58 <mcstar> runLs "~" :: FileType Pdf
12:09:27 <typoclass> mcstar: that'd be the equivalent of "ls *pdf"?
12:09:49 <mcstar> or whatever, i just meant, it would need to be pretty flexible to be used as a shell
12:09:52 <Eduard_Munteanu> Or say, a special ghci-like thingy.
12:09:56 <Clint> shellRunThingy "ls" >>> shellRunThingy "more"
12:09:59 <mcstar> typoclass: sort of, yeah
12:10:14 <mcstar> typoclass: but you could have typed results, not just text
12:10:49 <typoclass> mcstar: ok i see. not just bytes in the pipes but haskell data structures
12:10:55 <mcstar> also, it could actually check to see if a file is a pdfs
12:10:57 <mcstar> -s
12:11:06 <mcstar> it can be, without a .pdf extension
12:11:08 <Eduard_Munteanu> Yeah, it would depart a bit from the string manipulation paradigm.
12:11:50 <Eduard_Munteanu> So   ls :: IO [Filename]  instead of   ls :: IO String
12:12:46 <Eduard_Munteanu> Or if you really want to manipulate strings, you could call a pretty printer of sorts.
12:12:49 <mcstar> Eduard_Munteanu: well, it would be just a list of filenames
12:12:51 <typoclass> Eduard_Munteanu: how could you further use a Filename or [Filename]?
12:12:57 <mcstar> but you want a type of files with filenames
12:13:17 <typoclass> Eduard_Munteanu: (because this is a direction i haven't been thinking about so far)
12:13:21 <mcstar> ocmal has open types
12:13:35 <mcstar> yeah, thats a new language
12:14:01 <mcstar> dont google it, im kidding
12:14:06 <Eduard_Munteanu> typoclass: well you could call readFile or an analogue of 'cat' on it for example
12:14:48 <mcstar> Eduard_Munteanu: also, it would be great if you wouldnt have to pipe text to and from a utility like find
12:14:52 <typoclass> Eduard_Munteanu: right, the regular cat takes only a plain string which may or may not be an existing file
12:15:15 <mcstar> cat doesnt take anything
12:15:33 <Eduard_Munteanu> cat :: [Filename] -> IO String
12:15:43 <mcstar> cat doesnt make sense here
12:16:03 <Eduard_Munteanu> Maybe, I was just thinking.
12:16:33 <typoclass> mcstar: why not? i use "cat somefile.txt" all the time
12:16:40 <tdammers> hmm.. I kinda remember seeing something like that some time
12:16:47 <tdammers> it was intended for scripting, but still
12:16:55 <tdammers> given the right functions, it could double as a shell
12:16:57 <mcstar> typoclass: cat is for concatenation
12:17:07 <mcstar> typoclass: other uses are side-effects
12:17:27 <mcstar> you would cal it readFile in haskell
12:17:41 <mcstar> or, fromFile, that starts a pipe
12:17:52 <mcstar> and there would be a fromFiles too
12:18:22 <mcstar> also, people use cat more than they need to
12:18:35 <mcstar> they use it cat file | command instead of commadn < file
12:18:40 <tdammers> mcstar: guilty as charged
12:18:45 <Ralith> or sometimes even 'command file'
12:18:46 <cmccann> cf. http://partmaps.org/era/unix/award.html
12:18:53 <mcstar> or that, yeah
12:19:13 <tdammers> there's a semantic difference between command <file and command file though
12:19:24 <tdammers> in the first case, command doesn't get to see the file name
12:19:34 <tdammers> (or that it's from a file at all, for that matter)
12:19:40 <rwbarton> cat file | command is often convenient
12:19:58 <mcstar> ok, but im saying, you wouldnt do it in a possible haskell shell
12:20:06 <rwbarton> though < file command also works, but it looks weird
12:20:07 <typoclass> mcstar: well typing "<" vs. "cat" seems to be a really small unnecessary issue
12:20:22 <rwbarton> anyways Eduard_Munteanu's "cat" took a list of files
12:20:47 <mcstar> thats true
12:20:57 <mcstar> but you dont want to concatenate arbitrary files
12:21:05 <mcstar> a Filename is not a good type for a file
12:22:17 <mcstar> it would be great, to make a small haskell interpreter, that wouldnt depend on the whole ghc
12:22:27 <mcstar> so that shell would be more easily distributable
12:23:03 <typoclass> cmccann: yeah i've seen the 'useless use of cat' award, but i find it very very pointless. those people must have way too much time on their hands
12:23:19 <Ralith> lol
12:23:39 <tdammers> if unnecessary use of 'cat' were the only problem in the IT sector, the world would be a wonderful place
12:23:42 <cmccann> typoclass, perhaps you should start handing out a "useless awarding of awards" award.
12:23:46 <tdammers> full of unicorns and rainbows and shit
12:24:07 <mcstar> i dont like that sentence ^^
12:24:11 <mcstar> visually disturbing
12:24:36 <mcstar> im still seeing those things...
12:24:36 <typoclass> typoclass: will do :) first award will go to myself, if i may be so bold
12:24:38 <tdammers> wait until your mental image forms
12:24:59 <mcstar> tdammers: thats what im talking about XD
12:25:07 <_Muffin_> '
12:25:13 <tdammers> mcstar: you're a quick thinker then
12:31:15 <Expez> When I use readFile with a relative path, what is it relative to?
12:31:52 <simon> CWD, presumably.
12:31:52 <c_wraith> Expez: the current working directory
12:32:08 <typoclass> Expez: the working directory (more or less the directory from where you started your program, or ghci)
12:32:54 <simon> in Windows, CWD can be a little random... sometimes it's the desktop, sometimes your documents directory, sometimes the equivalent to your home directory, and sometimes the directory where the executable is.
12:34:10 <Expez> So you have to use absolute paths when opening data files included with your program?
12:34:34 <cizra> Heya, I'm trying to read and right after that, write a file. Standard (lazy) IO doesn't allow this. I could use System.IO.Strict, but that'd require installing it. Do I have any convenient options (short of file handles) to do this with platform tools?
12:34:47 <rwbarton> you don't know where your program will be installed though
12:35:53 <rwbarton> cabal has some magic to help you out here
12:35:57 <mcstar> doesnt argv[0] give you the path to the executable that was called?
12:36:04 <yawnt> factorial n = product [1..n]
12:36:05 <yawnt> lol
12:36:07 <yawnt> awesome :D
12:36:14 <typoclass> cizra: not sure, but you could read from the file, write into a temporary file, then when finished rename the temporary (overwriting the input file)
12:36:24 <mcstar> yawnt: wals for factorial 0
12:36:27 <mcstar> fails*
12:36:36 <rwbarton> no it doesn't
12:36:47 <buffer_overflow> is there a Visual Haskell IDE for windows?
12:36:47 <typoclass> yawnt: yes, it's not bad, isn't it :)
12:36:53 <mcstar> oh, damn defaults
12:36:57 <callen> tibbe: you have saintly patience
12:37:05 <yawnt> typoclass: man, coming from javascript i'm like discovering a world of unicorns and rainbows
12:37:32 <kartoffelbrei> buffer_overflow: IIRC there is/was an Eclipse Plugin or something
12:37:32 <buffer_overflow> http://leksah.com
12:37:39 <cizra> typoclass: Even more hackish than hGetContents.
12:37:39 <Eduard_Munteanu> buffer_overflow: Visual Haskell? Are you trying to write GUI apps?
12:37:41 <buffer_overflow> http://leksah.org oops
12:37:52 <typoclass> yawnt: welcome to haskell :) i take it you're aware of lyah?
12:37:55 <typoclass> @where lyah
12:37:56 <lambdabot> http://www.learnyouahaskell.com/
12:37:59 <buffer_overflow> Eduard_Munteanu: nah was just looking for Haskell IDEs on Windows ^_^
12:38:04 <tdammers> > product [1..0]
12:38:05 <lambdabot>   1
12:38:09 <tdammers> hehe
12:38:14 <yawnt> typoclass: that's what i'm reading :D
12:38:21 <typoclass> cizra: i think it's a pretty standard approach. vim does that whenever saving a file, afaik
12:38:22 <buffer_overflow> btw, how are GUIs written in a language like hs?
12:38:35 <mcstar> hardly :)
12:38:57 <callen> mcstar: I was trying to think of an adverb that involved types but couldn't contrive anything.
12:38:59 <Eduard_Munteanu> buffer_overflow: you may reach for stuff like gtk2hs, which is a binding to GTK2
12:39:45 <Eduard_Munteanu> buffer_overflow: you can use glade to design your UI, just like you'd use GTK from C.
12:40:03 <kartoffelbrei> buffer_overflow: often with gtk or wx bindings that live in the IO Monad a lot. There are some experimental FRP GUI libs like reactive-bannana-wx to do that in a more declarative/functional way
12:40:19 <rwbarton> cizra: yeah, what typoclass suggested is standard because that way you don't lose your input file if the program crashes between opening the file for writing and actually writing, and also other processes on the system can never see a partially-written file
12:40:20 <cizra> typoclass: Yeah, you're probably right. But the use case is {in,de}crementing LCD brightness via /sys/class/backlight/acpi_video0/brightness in XMonad special keys.
12:40:33 <cizra> Which means no partially written files and no loss.
12:40:36 <rwbarton> oh
12:41:00 <typoclass> cizra: i see
12:41:36 <Eduard_Munteanu> cizra: hGetLine / hPutStrLn?
12:41:49 <typoclass> cizra: i'm not really clear on lazy i/o, but would it work to read, then do hClose, then open it again in write mode?
12:41:51 <rwbarton> well, there are many options but none is ideal
12:41:54 <rwbarton> how about Data.Text?
12:42:06 <rwbarton> that is in the HP right
12:42:15 <rwbarton> it includes strict IO functions
12:42:44 <rwbarton> you can also just insert seq carefully
12:42:46 <kartoffelbrei> cizra: what about hFlush?
12:42:55 <cizra> Yeah, I'm doing it with handles right now.
12:43:08 <tdammers> cizra: I actually cheated on that one
12:43:09 <cizra> They're just not that simple and elegant compared to readFile/writeFile.
12:43:20 <tdammers> I do it with a shell script and spawn that from xmonad
12:43:20 <typoclass> cizra: (btw, i'm an xmonad user also, and brightness keys are handled by acpid for me. didn't have to set up it up, it just worked, as long as acpid is running)
12:43:21 <monochrom> no, lazy I/O is unlikely to work with "read, then close, then re-open"
12:43:59 <typoclass> monochrom: i see, thanks. so it doesn't help to throw hFlush into that?
12:44:18 <monochrom> no, hFlush does not help
12:44:34 <mcstar> i was thinking about xmonad, but it doesnt support the mouse well
12:44:47 * hackagebot uploadcare 0.1 - Haskell client for Uploadcare.  http://hackage.haskell.org/package/uploadcare-0.1 (DimitrySolovyov)
12:45:12 <tdammers> mcstar: you mean that you can't have a click both select a window and act on it?
12:45:47 <mcstar> like selecting workspace with the mouse, or tiling mode
12:45:52 <mcstar> i use the scroll a lot for that
12:46:40 <mcstar> if you use gui apps, you are often working with the mouse, tiling wm notwithstanding
12:46:45 <fmap> what's mouse?
12:46:54 <mcstar> > fmap mouse
12:46:55 <lambdabot>   Not in scope: `mouse'
12:47:29 <mcstar> awesome allows me to use the mouse if and when i want
12:48:02 <mcstar> even if it is not written in haskell, i can put up with it :)
12:48:36 <typoclass> his question is interesting actually ... how do you safely read an Int from a file, increment it, and write it back into the file. maybe there should be a minimal example on the wiki
12:48:38 <kartoffelbrei> well XMonad + dzen + conky + trayer is all i need
12:49:18 <callen> kartoffelbrei: I'm most productive in Xmonad, but use a mac for convenience reasons.
12:49:25 * Eduard_Munteanu uses xmobar
12:51:00 * typoclass has a homegrown replacement for xmobar that is hacked directly into xmonad. i'd release it if it just was a little more done and a little less scary :)
12:51:56 <mcstar> does anyone use okular?
12:52:16 <callen> typoclass: why'd you make it?
12:52:21 <callen> typoclass: just wondering.
12:53:25 <mcstar> weird
12:53:41 <mcstar> i'd have guess many use it, since folks here read papers
12:53:45 <mcstar> guessed*
12:54:18 <Eduard_Munteanu> I use evince :/
12:54:37 * cizra  
12:54:51 <rwbarton> I use ... a custom recompiled evince that changes some default settings :/
12:54:55 <mcstar> i miss, that tiling wms dont have session restore features, that restore open applications/documents on new login
12:55:03 <typoclass> callen: i was unhappy with the idea of shoehorning xmonad state into a string (window title, names of workspaces, ...), and then in another program reading it back with some flaky parser
12:55:08 <tibbe> callen: :)
12:55:17 <typoclass> callen: if i remember correctly, there were ridiculous issues like "if the browser ever opens a page with {} in the title, the xmobar layout will go wahooni-shaped because that's a control sequence" ...
12:55:26 <mcstar> anyway, i wrote a script, that keeps track of okular's open documents, and restores them on new login
12:55:29 <mcstar> thats why im asking
12:56:25 <rwbarton> yeah, xmobar is pretty sketchy and I would like to replace it
12:56:26 <tibbe> callen: I'm not sure why cabal's dep solver doesn't find a build plan that works
12:56:27 <typoclass> mcstar: i think you can get gnome-session-manager (or whatever it's called) to work with a tiling wm, or any other session manager
12:56:40 <mcstar> nah, tried that, problematic
12:56:41 <mmcdermo> Why would a package from hackage sometimes install correctly, and sometimes give a compile error? http://hpaste.org/75886
12:56:59 <mcstar> does evince keep track of your position in a document?
12:57:00 <yawnt> what a mess
12:57:58 <cizra> hmmmmmm. Is there any reason why   old <- IO.withFile path IO.ReadMode IO.hGetContents
12:58:03 <cizra> ... should not work?
12:58:06 <Saizan> mmcdermo: probably different versions of some dep get picked
12:58:15 <geekosaur> cizra, yes, that will not work
12:58:19 <donri> mcstar: yep
12:58:23 <callen> tibbe: part of the problem is the globalness.
12:58:27 <cizra> geekosaur: Hm, why?
12:58:28 <geekosaur> hGetContents is lazy, withFile is not lazy
12:58:33 <callen> tibbe: leiningen never fails like this because the packages are per build/project.
12:58:40 <callen> tibbe: it just caches the stuff you've already gotten.
12:58:44 <tibbe> callen: we will do that in the next cabal release
12:58:48 <callen> tibbe: but it doesn't attempt reconcile a global interdependency.
12:58:58 <callen> tibbe: that's all well and good, but that should've been the priority from the start
12:59:01 <rwbarton> cizra, your file is just a single line though, right? you can use ... hReadLn I think
12:59:04 <rwbarton> @type hReadLn
12:59:04 <tibbe> callen: most of the sandbox patches have landed in master
12:59:05 <lambdabot> Not in scope: `hReadLn'
12:59:05 <callen> tibbe: making projects build, not the whole universe simultaneously.
12:59:06 <geekosaur> don;t use lazy I/O with withFile, because hGetCOntents won;t read anything until needed so withFile will see it "complete" without doing anything and close the file
12:59:08 <rwbarton> @type readLn
12:59:09 <lambdabot> forall a. (Read a) => IO a
12:59:14 <rwbarton> whatever the handle version of that is
12:59:15 <tibbe> callen: I agree, but it wasn't
12:59:18 <cizra> rwbarton: Yeah, but ...
12:59:22 <Eduard_Munteanu> @hoogle hGetLine
12:59:22 <lambdabot> System.IO hGetLine :: Handle -> IO String
12:59:22 <lambdabot> GHC.IO.Handle hGetLine :: Handle -> IO String
12:59:22 <lambdabot> Data.ByteString hGetLine :: Handle -> IO ByteString
12:59:27 <rwbarton> or hGetLine + read
12:59:32 <callen> tibbe: the simplicity and focus on the core use case, "get my project to build" is partly why leiningen has never broken for me except on alpha 2.0 builds.
12:59:33 <cizra> geekosaur: How do you know hGetContents is lazy? And why should the mix not work right?
12:59:43 <geekosaur> ...
12:59:46 <mmcdermo> Saizan: Ahh I see. Thanks! I'll look into updating all dependencies etc.
12:59:47 <tibbe> callen: in either case I don't understand why cabal cannot come up with a build plan in this case, I don't understand why it picks slightly different versions of network
12:59:56 <callen> tibbe: meanwhile, I can scarcely make a re-attempt at learning Haskell because cabal breaks everytime I come back to tinker.
13:00:08 <rwbarton> "How do you know hGetContents is lazy?" by reading the documentation
13:00:12 <callen> tibbe: it makes the situation look really bad.
13:00:12 <tibbe> callen: we're getting cabal there, I'm modelling it partly after Google's build system, which is great
13:00:26 <typoclass> geekosaur: thanks. is there some list which i/o functions are lazy? i thought all of them in base were
13:00:33 <Saizan> mmcdermo: the latest version might not be the best, you can check which ones get used by --dry-run -v2 i think
13:00:33 <donri> cizra: simple solution: use strict text/bytestring I/O. advanced solution: look at pipes/conduit
13:00:34 <callen> tibbe: I can't speak to Google's build system, all I know is that they seem to be using Haskell more and more in devops.
13:00:34 <cizra> " returns the list of characters" -- that's the only hint of laziness I can see.
13:00:45 <tibbe> callen: right
13:00:46 <geekosaur> I know it because I read documentation.  http://lambda.haskell.org/platform/doc/current/ghc-doc/libraries/haskell2010-1.1.0.1/System-IO.html#v:hGetContents
13:00:51 <callen> tibbe: you understand why as an outsider this looks bad though, right?
13:00:56 <tibbe> callen: sure
13:01:09 <rwbarton> IO.withFile path IO.ReadMode IO.hGetContents will not work because withFile will open the file, run the hGetContents action, and then close the file before any of the file is actually read, causing hGetContents to fail (silently by returning "")
13:01:09 <callen> tibbe: how can I invest in learning the language if I can't trust stuff to build on a stable version?
13:01:13 <tibbe> callen: I'm more focused on understanding and fixing this bug
13:01:13 <tibbe> callen: the rest is being worked on
13:01:25 <cizra> rwbarton: Interesting!
13:01:27 <mmcdermo> Saizan: Ahh perfect. I'll look at it on the ver. that works then.
13:01:28 <callen> tibbe: which is totally great, your responsiveness is awesome.
13:01:29 <tibbe> callen: I did get your point
13:01:37 <callen> tibbe: I'm just concerned at the larger level because I'm trying to get away from Python and learn something more enriching
13:01:52 <callen> tibbe: but I can't pick something that'll jettison my productivity into the outer reaches of the galaxy.
13:01:53 <tibbe> callen: we're well aware of the problems, we're working on it
13:01:57 <tibbe> now, time for a bike ride!
13:01:59 <cizra> Thanks, it works now!
13:02:01 <callen> tibbe: have fun!
13:02:07 <tibbe> callen: thanks
13:02:15 <rwbarton> callen: if you just want it to work you should just blow away your cabal/ghc directories every year or two and start afresh
13:02:24 <callen> rwbarton: it's not that old of an install
13:02:31 <rwbarton> you said it was two years old before
13:02:43 <callen> rwbarton: no, I'd been tinkering with Haskell off and on for two years
13:02:52 <callen> rwbarton: this particular install is on a fairly new macbook air I bought recently
13:02:53 <donri> cizra: or just use readFile and be done with it, if handles aren't scarce in your app
13:03:01 <callen> the haskell platform install is maybe 2-3 months old at the most.
13:03:08 <rwbarton> odd
13:03:10 <callen> I'm not blowing away my dev env every couple months, end of story.
13:03:17 <rwbarton> I never run into these sorts of problems
13:03:24 <monochrom> cizra: "items are read from hdl on demand" is a way to say lazy reading
13:03:26 <callen> rwbarton: I am a plague-carrier for bugs.
13:03:32 <callen> rwbarton: I'm the master of making them show their ugly faces.
13:03:39 <callen> rwbarton: I'm seriously cursed.
13:03:45 <rwbarton> it is not like these are unknown issues
13:03:50 <rwbarton> they just tend not to arise in practice
13:03:54 <typoclass> donri: will readFile have the same problem that rwbarton described for hGetContents? its docs say readFile is lazy and like getContents
13:04:15 <callen> rwbarton: well, practice, meet theory. Theory? Stop bludgeoning practice to death.
13:04:19 <latro`a> ...??? "genRange cannot examine its argument, and hence the value it returns can be determined only by the instance of RandomGen." then why does it take an argument at all, if the return value can be determined by type magic?
13:04:25 * callen wipes blood off paron
13:04:25 <rwbarton> it's difficult to maintain a consistent set of versions over a very large span of time
13:04:41 <callen> rwbarton: well, let me give you the "man on the ground"'s point of view.
13:04:43 <monochrom> I am the dual of callen. all software I use works 100% for me, I run into no problems. including both cabal-install and pulseaudio.
13:04:48 <rwbarton> I am a man on the ground too, lol
13:04:51 <donri> typoclass: the way I understand it is it's kept open until fully consumed and then closed for you
13:05:00 <donri> don't trust me on this though :)
13:05:02 <callen> rwbarton: leiningen doesn't break, sbt is kinda flaky if you don't change the heap size but otherwise works, and cabal breaks nearly every time I use it.
13:05:05 <kartoffelbrei> couldn't just add strictness with BangPatterns (or seq)? like '!content <- hGetContent'?
13:05:14 <geekosaur> no
13:05:17 <callen> rwbarton: and Makefiles are something I can at least grapple with and attempt to fix.
13:05:37 <callen> I can't fix an entire broken ecosystem that insists on spreading global state all over my computer like cabal.
13:05:41 <typoclass> donri: i see, so withFile "closes" the file, but that doesn't actually close it just yet; readFile is holding on to it
13:05:58 <rwbarton> cabal doesn't spread global state all over your computer
13:06:03 <geekosaur> you're getting a string, which is a linked list of Char.  seq, or !, will strictify the first character at most
13:06:06 <donri> typoclass: readFile is just open >>= hGetContents
13:06:06 <rwbarton> are you using cabal install --global?
13:06:16 <callen> rwbarton: nope.
13:06:37 <donri> typoclass: and hGetContents docs talk about some 'semi-closed state' the handle is put in
13:06:40 <callen> rwbarton: it seems as if there's a global/user/system-level state, though.
13:06:44 <callen> rwbarton: as opposed to per-project.
13:07:05 <rwbarton> yes
13:07:26 <rwbarton> there are projects in the works for per-project package states as well
13:07:29 <donri> typoclass: and it says that a semi-closed handle becomes closed "once the entire contents of the handle has been read. "
13:07:32 <callen> rwbarton: well that decision wrote a check your community clearly can't cash.
13:07:51 <typoclass> donri: right, i had heard about the semi-closed thing
13:07:55 <callen> rwbarton: so I'm left trying to learn Haskell so I can leave the infantile Python community, but can't, because cabal is shitting the bed and there's nothing I can do except hope somebody helps tibbe address the github issue.
13:08:05 <callen> rwbarton: how I do uninstall the bastard?
13:08:12 <donri> typoclass: so, it works fine for small and simple apps, and is quite lovely for that really. but unpredictable and leaks resources for larger, more complex apps.
13:08:29 <rwbarton> I don't know, I have never personally had to uninstall any cabal stuff because it never breaks for me
13:08:36 <tibbe> callen: worst case you can uninstall all your libs with rm -rf ~/.ghc and then try the install
13:08:57 <callen> lets test that theory.
13:09:05 <NadiaYvette> Leave a way to back out. mv -i ~/.ghc ~/.ghc.bak
13:09:16 <callen> NadiaYvette: nah, I'm in the mood to kill.
13:10:10 <typoclass> callen: fwiw, i have had good experiences with cabal-dev, which creates a new (hopefully clean and working) package repository, just for your project. it seems to work much better than the "all projects use the same packages in ~/.cabal"
13:10:19 <kartoffelbrei> geekosaur: how about mapping seq over the whole string?
13:10:41 <callen> typoclass: per project packages is the sensible way to do it and I'm really bothered Haskell didn't start from there.
13:10:56 <rwbarton> what "project" am I in if I just run ghci
13:11:01 <typoclass> donri: ok, thanks for the explanation :) i think i've got it. "withFile hGetContents" will call hClose, which is really the difference, because readFile will only semi-close (not close) the file
13:11:02 <callen> even the Rubyites know the pain of cross-project packaging, and they're about as hygienic as elephants.
13:11:17 <mcstar> you can unregister packages with ghc-pkg
13:11:25 <mcstar> or just delete them, and recache
13:11:32 <callen> mcstar: pfft, I nuked the .ghc
13:11:40 <mcstar> i think thats what i did when i removed cabal installed packages
13:11:59 <mcstar> callen: now ghc will have a lot of broken packages
13:12:30 <mcstar> see what 'ghc-pkg list' gives
13:12:33 <rwbarton> what, how? isn't its package database also in ~/.ghc ?
13:12:43 <callen> mcstar: I'm arraying the fucks I give before you in memory, there is 1 byte per array element, each bit is 0, the length of the array is 0.
13:12:46 <typoclass> rwbarton: the one in ~/.cabal. i think there's some way to get ghci to use the packages that cabal-dev created in this or that place. i've actually wondered about that
13:13:06 <napping> If I run cabal install gloss --flags="GLFW -GLUT", why does it try to build GLUT?
13:13:25 <cizra> monochrom: Ohh, right! I must have had a fit of blindness.
13:13:25 <callen> nuking ~/.ghc fixed it.
13:13:29 <mcstar> oh, you deleted .ghc, ok
13:13:30 <typoclass> rwbarton: afaik cabal-dev calls ghc-pkg with some options to direct it to another directory (not ~/.cabal)
13:13:34 <mcstar> not .cabal, my bad
13:13:50 <rwbarton> well I don't use cabal-dev, I am just saying that I like to be able to install a package and run ghci and use the package
13:13:54 <mcstar> anyway, if you delete system packages, whose need to be unregistered
13:14:02 <mcstar> those*
13:14:08 <callen> yep, don't care. Cf. array full of zeroes.
13:15:01 <callen> cabal now permamently believes it needs to update itself
13:15:07 <napping> seems like it makes a package that depends on GLUT and GLFW
13:15:15 <callen> despite my having done so perhaps 2 or 3 times.
13:15:18 <callen> this is ridiculous.
13:18:04 <mcstar> callen: i think it just tells you theres a new version, but you dont HAVE to install it
13:18:36 <byorgey> callen: where did it install the new version? are you sure it's somewhere on your $PATH?
13:19:01 <mcstar> i dont want to upgrade my cabal-install, since that is a system installed package for me
13:19:10 <mcstar> so that would be stupid to cabal install cabal-install
13:19:26 <mcstar> if you installed it, then probably you are not using it
13:19:34 <mcstar> is your .cabal/bin sourced?
13:19:43 <mcstar> i mean, added to PATH
13:19:47 <byorgey> callen: also, what does  cabal --version  say?
13:24:44 <JoshuaA_> Hey guys, I've just set up haskellmode.vim, but I can't seem to get the plugin working. Any suggestions or ideas as to what miht be causing this?
13:26:10 <donri> JoshuaA_: there are better, maintained vim addons
13:26:37 <JoshuaA_> Ah, could you point me to what you consider to be the best one? :)
13:26:53 <donri> https://github.com/dag/vim2hs#see-also
13:27:13 <donri> also https://github.com/bitc/vim-hdevtools (should add this to that list)
13:27:41 <typoclass> donri: oh wow thanks
13:28:36 <JoshuaA_> Whow, great list for a haskell newbie, thanks!
13:28:51 <mcstar> whats that color scheme? i like it
13:29:09 <donri> also https://github.com/jejansse/haskim is supposed to set a bunch of those up for you
13:29:43 <JoshuaA_> I thnk I'd rather set them up myself using pathogen, or would you advice against that?
13:30:54 <donri> JoshuaA_: i recommend vundle, but same difference
13:31:29 <simon> I'm not sure if this goes here or #emacs, but can anyone recommend an option that changes the color of ghc-mod/flymake output of hslint? currently it's a red background that goes really bad with the text, so I can hardly read it.
13:32:07 <JoshuaA_> Yeah, already using pathogen for my other plugins, so I'd rather stick with that (for now ;))
13:32:49 <donri> mcstar: i believe the first one is molokai with custom background to match the window manager, and the second one is vydark with same bg
13:33:20 <mcstar> emacs has molokai, i think i used it
13:33:37 <donri> confusingly, there's also monokai which is different
13:33:38 <mcstar> but it depends on haskell-mode to use all to colors and make it nice..
13:34:26 <mcstar> https://github.com/alloy-d/color-theme-molokai
13:35:22 <mcstar> im not sure how many ppl saw typerex, but it makes ocaml code look like rainbow
13:35:35 <mcstar> (and in not a bad way)
13:40:48 <mcstar> yeah, haskell-mode needs more imagination to match that vim coloring
13:43:29 <monochrom> so much misinformation and whining in #haskell. it seems people want circlejerks, not solutions
13:44:25 <mcstar> what exatly are you referring to?
13:44:46 <monochrom> the conversations half an hour ago
13:44:56 <donri> mcstar: vim2hs does a lot that the standard haskell.vim syntax doesn't, nor emacs
13:51:20 <hiptobecubic> I don't use the syntax from vim2hs because it's so damn slow
13:51:42 <hiptobecubic> I have a decent one that doesn't have any of the fancy tricks for template haskell etc (I don't think)
13:51:46 <hiptobecubic> But I like it.
13:52:28 <JoshuaA_> donri: I'm trying to install vim-hdevtools as you adviced but following the installation guide (https://github.com/bitc/vim-hdevtools#installation) I get a cabal error message that I as a newcomer to haskell can't quite decipher :p http://hpaste.org/75888 any idea what might be the cause?
13:52:48 <mcstar> let g:hpaste_author = 'donri'
13:52:56 <mcstar> is that your github?
13:53:08 <donri> mcstar: i'm the author of vim2hs yes
13:54:01 <donri> JoshuaA_: i can only guess that it might have to do with an unsupported ghc version?
13:54:52 <Tekmo> JoshuaA_: It looks like they don't put version bounds on the `ghc` packages they depend on
13:54:52 <donri> hiptobecubic: i'd love some feedback on that, because it's not slow for me so i can't really debug it. https://github.com/dag/vim2hs/issues/28
13:55:01 <Tekmo> JoshuaA_: So cabal might be bringing in the wrong version
13:55:15 <JoshuaA_> 7.0.4, the one that came with my system.  Think that might be it?
13:55:19 <hiptobecubic> donri, that's my issue actually. I just haven't had time to play with it anymore :(
13:55:27 <donri> ah :)
13:55:51 <hiptobecubic> It will come. If i'm the only one complaining about it then it's probably my fault some how :)
13:56:03 <JoshuaA_> Tekmo: hm, how would I fix that? :p
13:56:17 <donri> hiptobecubic: nah, i've had others complain about it in here
13:56:18 <Tekmo> JoshuaA_: I'm looking to find the module and package you need
13:56:21 <hiptobecubic> Maybe when I get to where I actually need some of those features I'll force myself to test it out
13:56:36 <JoshuaA_> Thanks for taking the time!
13:56:57 <hiptobecubic> donri, vim2hs by the way. Very great.
13:57:04 <donri> thanks :)
13:57:26 <donri> far from perfect though, which is why i've yet to announce it in any official fashion
13:58:00 <hiptobecubic> vim plugins are rarely perfect
13:58:12 <hiptobecubic> fugitive excepting
13:58:19 <donri> it's also a bit of a kitchen sink for my experimentation. should probably split it out in multiple addons. that way you could use the features you need, without the slow syntax for example.
13:58:24 <Tekmo> JoshuaA_: Ok, so here is the weird part.  It looks like they are doing everything correctly
13:58:36 <Tekmo> JoshuaA_: The latest version of the `ghc` package provides those functions in the `GHC` module
13:58:48 <Tekmo> JoshuaA_: And it's imported and invoked correctly within the Info.hs file
13:58:59 <hiptobecubic> is anyone an op in #math? we're getting raped in there
13:59:00 <Tekmo> JoshuaA_: Do you have the latest version of the Haskell platform?
13:59:06 <hiptobecubic> nevermind i think someone got it
14:00:13 <donri> Tekmo: JoshuaA_ is using ghc 7.0.4, so not latest platform or ghc package
14:00:19 <JoshuaA_> Tekmo: Don't think so, was using the bins that came pre-installed so far (ghc 7.0.4 and cabal 1.16.0). I'll get the latest now though!
14:00:33 <donri> JoshuaA_: what OS?
14:00:41 <Tekmo> JoshuaA_: It might work.  While you try that I will check if 7.0.4 exports those functions
14:00:46 <JoshuaA_> osx (.. unfortunally :p)
14:01:12 <donri> try upgrading haskell-platform. you probably want to do that anyway!
14:01:47 <Shapeshifter> Hi. How can I investigate the nature of a type? I'm trying some stuff with cairo and I want to set the colormap of my widget to RGBA, but the Types documentation is missing from the project. I can do h>:m Graphics.UI.Gtk.Gdk.Screen; h>:t Graphics.UI.Gtk.Types.Colormap and it tells me :: Screen -> IO (Maybe gtk-0.12.3.1:Graphics.UI.Gtk.Types.Colormap). So how can I look at what Colormap is. I assume it would be an integer or ...
14:01:53 <Shapeshifter> ... something, since it's not a [Char]
14:02:03 <Tekmo> JoshuaA_: Unfortunately, I can't find the location of previous GHC API's, so your best bet is upgrading to the latest Haskell platform
14:02:24 <JoshuaA_> Tekmo: No problem, downloading atm
14:02:31 <Tekmo> Shapeshifter: Type ":info Colormap"
14:02:36 <Tekmo> You'll have to qualify the name, though
14:02:43 <donri> JoshuaA_: if you got the time, could be a good idea to file a bug for this to hdevtools
14:03:06 <donri> https://github.com/bitc/hdevtools/issues/
14:03:10 <Tekmo> Shapeshifter: Just bring the type into scope, first, using: "import Graphics.UI.Gtk.Types"
14:03:13 <Shapeshifter> Tekmo: thanks
14:03:20 <JoshuaA_> donri: will do!
14:03:24 <rwbarton> how can :t Graphics.UI.Gtk.Types.Colormap output Screen -> IO (Maybe gtk-0.12.3.1:Graphics.UI.Gtk.Types.Colormap)
14:03:59 <Tekmo> Shapeshifter: You're welcome!
14:04:01 <rwbarton> that seems obviously impossible because Graphics.UI.Gtk.Types.Colormap would be a data constructor, and not of IO
14:04:18 <Shapeshifter> Tekmo: mhh, Could not find module `Graphics.UI.Gtk.Types' it is a hidden module in the package `gtk-0.12.3.1' but I can't import gtk-0.12.3.1 or gtk-0.12.3.1:Graphics.UI.Gtk.Types, that gives me parse errors.
14:04:45 <rwbarton> a hiddel module in the package or a module in the hidden package?
14:04:59 <Tekmo> Shapeshifter: What happens if you type ":m Graphics.UI.Gtk.Types"
14:05:05 <Shapeshifter> rwbarton: ghci says it's a hidden module in the package `gtk-0.12.3.1'
14:05:14 <startling> is a monad transformer for tagged monads possible? I have "data Named m a = Name (Maybe String) (m a)"; I'm having trouble writing (>>=) for instance Monad m => Monad (Named m)
14:05:30 <Shapeshifter> Tekmo: same error message as above
14:05:40 <Tekmo> Shapeshifter: Then bring up another command line and type: "ghc-pkg list | grep gtk"
14:05:55 <Tekmo> That will show you which versions of "gtk" you have installed and which ones are exposed or hidden
14:06:20 <Shapeshifter> Tekmo: gtk-0.12.3.1 is what I have
14:06:28 <rwbarton> it looks like it is really a hidden module
14:06:30 <Tekmo> Does it have parentheses around it?
14:06:34 <Shapeshifter> Tekmo: no
14:06:49 <Tekmo> Then rwbarton is right.  It's just a hidden module you can't import
14:06:55 <rwbarton> http://hackage.haskell.org/packages/archive/gtk/0.12.3.1/doc/html/doc-index-C.html doesn't list Colormap at all
14:07:34 <Tekmo> Shapeshifter: What that means is that when a package maintainer releases a package, they define which modules to expose the documentation of
14:07:39 <JoshuaA_> donri: Anything else that might be usefull to add? https://github.com/bitc/hdevtools/issues/2
14:08:06 <Tekmo> Shapeshifter: However, you can still see the source for it if you download the package tarball
14:08:20 <rwbarton> newtype Colormap = Colormap (ForeignPtr (Colormap)) deriving (Eq,Ord)
14:08:23 <Tekmo> Shapeshifter: But it seems odd that you would use a type that is not documented
14:08:26 <donri> Tekmo: i was looking at conduit, it has functions like splitting a text source on lines. will there be such helpers for pipes, or can we just do `await >>= mapM yield . lines`? the conduit function is much more complicated, so curious if it needs to be.
14:08:32 <rwbarton> how did you find out about this Colormap anyways
14:08:41 <Tekmo> donri: There will be a separate parser library released soon
14:08:49 <Tekmo> donri: I'm releasing pipes-2.4 today, which will support parsing
14:08:55 <donri> coolness!
14:08:57 <Tekmo> donri: But I don't want to make the main library depend on bytestring or text
14:09:03 <Shapeshifter> rwbarton: http://hackage.haskell.org/packages/archive/gtk/0.12.3/doc/html/Graphics-UI-Gtk-Abstract-Widget.html , there is a widgetSetColormap function which takes a Colormap, which is not linked anywhere in the docs.
14:09:06 <donri> makes sense
14:09:23 <rwbarton> I see
14:09:38 <Shapeshifter> I'm still not sure how to procure such a Colormap now...
14:09:54 <monochrom> hrm, newtype X = X (ForeignPtr X) is a cute trick! I have only thought of newtype X = X (ForeignPtr ())
14:10:14 <donri> Tekmo: mainly though i'm curious on a more general level why the complexity is needed in conduit and if it's also needed in pipes. conduit people tell me it would leak memory or something to use Text.lines directly on the stream...
14:10:25 <Tekmo> donri: The complexity is not needed
14:10:30 <Tekmo> donri: They are just drinking their own cool-aid
14:10:41 <donri> Tekmo: https://github.com/snoyberg/conduit/blob/master/conduit/Data/Conduit/Text.hs#L70
14:10:45 <donri> ok :D
14:11:03 <Tekmo> donri: I can give you an old hpaste
14:11:07 <Tekmo> which demonstrates the basic idea
14:11:11 <Tekmo> although the names and such have changed
14:11:34 <pcapriotti> donri: if the input is chunked, you need to be careful to rejoin lines that were split in the middle
14:11:46 <donri> is it needed in conduit because of design differences? or isn't it needed in conduit *either*
14:12:15 <Tekmo> donri: Well, the conduit design is actually an awkward attempt to inline state
14:12:30 <Tekmo> donri: pipes-2.4 includes a state proxy transformer
14:12:30 <rwbarton> Shapeshifter: do you know how to do what you are trying to do with the gtk C API?
14:12:44 <Tekmo> donri: That you can use to transparently layer local state on a pipe
14:12:52 <Tekmo> donri: Which you can use to keep track of unhandled input
14:13:14 <Tekmo> donri: Here's the hpaste I was talking about
14:13:15 <Tekmo> http://hpaste.org/73647
14:13:22 <Tekmo> A lot has changed since that paste
14:13:26 <Tekmo> But it's the same basic idea
14:13:51 <Shapeshifter> rwbarton: I found it, I get one by calling screenGetRGBAColormap on the screen object.
14:14:19 <Shapeshifter> "returns a colormap to use for windows with an alpha channel or Nothing if the capability is not available" which is good.
14:14:20 <rwbarton> yes I just found that also
14:14:54 <rwbarton> though I'm still confused what you actually did originally to see ":: Screen -> IO (Maybe gtk-0.12.3.1:Graphics.UI.Gtk.Types.Colormap)"
14:15:22 <rwbarton> since that is actually the type of the thing you wanted, in the end
14:17:07 <Shapeshifter> rwbarton: I was being absent minded. I did :t screenGetRGBAColormap which gave that output. At that moment, I thought I didn't want any "screen colormap" but specifically RGBA... which is exactly what this does ...
14:19:34 <theplanet> when installing ghc do you get all the libraries that are required?
14:20:09 <monochrom> I don't know what "required" means to you, but GHC comes with some libraries.
14:22:40 <geekosaur> theplanet, ghc itself comes with enough libraries to rebuild itself but not a full ecosystem.  the haskell platform is a full ecosystem including the compiler
14:23:36 <liyang> I thought Hackage was the full ecosystem.
14:23:45 <theplanet> can the libghc* be installed with cabal?
14:24:05 <monochrom> what is libghc*?
14:24:09 <donri> if you mean the debian packages, yes
14:24:23 <donri> those that can't generally come with ghc anyway
14:24:33 <liyang> theplanet: I'd recommend using cabal instead of installing libghc*.
14:24:41 <theplanet> excellent!
14:25:06 <donri> unsure about some special ones like gtk, happy/alex, though
14:25:06 <liyang> They're often rather out of date.
14:25:16 <donri> the latter two does come with the platform, otoh
14:25:37 <liyang> Even happy or alex.
14:36:44 <Gracenotes> hm. I find I'm transferring over some of my habits using C in the last few weeks into Haskell.
14:38:02 <hpc> Gracenotes: which habits?
14:38:58 <Gracenotes> it's not exclusive to C, but for example, paranoia about argument types in top-level definitions to make it less possible to have bad preconditions
14:39:28 <Gracenotes> in C, that manifests as not allowing the caller to make assumptions about the way memory is managed in the function by forcing conventions with the argument/return types
14:40:37 <hpc> i suppose that's better than bad haskell habits in C
14:40:47 <ski> (example ?)
14:40:47 <hpc> you'd probably end up defining malloc in CPS'd form
14:41:08 <Gracenotes> i.e. no highly coupled cooperation between functions regarding memory management
14:41:55 <Gracenotes> memory allocated outside of a set of functions is never deallocated in any of those functions
14:42:56 <hpc> C++ has an interesting (but hacky) solution to those kind of questions
14:43:11 <hpc> with different kinds of pointers
14:43:47 <hpc> like one that's deallocated when it leaves scope (meant to be used as arguments to functions that deallocate their parameters)
14:44:19 <hpc> the wrapping at the call site makes it more obvious what's going on in memory
14:44:23 <Gracenotes> in Haskell, I have a some ADTs with complicated invariants, so I avoid having top-level functions which process only parts of that ADT.
14:45:06 <Cowbar> I never understood how CPS in Haskell works if all functiosn technically are single argument?
14:45:15 <Cowbar> Surely you need at least double argument functions for CPS?
14:45:35 <Cowbar> Well, I guess cpsFact (n, k) works
14:46:04 <Gracenotes> much like in C, where unless I know where memory came from, I can't assume it's mine. A bit of a tenuous comparison maybe, but I get the same program-organization sense tingling.
14:46:13 <typoclass> Cowbar: yeah well, haskell does have support for multi-argument functions, it's just that *if you want* you can look at them as being a series of single-argument functions
14:46:37 <typoclass> :t map
14:46:38 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:46:45 <typoclass> uh, bad example ... :)
14:46:54 <typoclass> :t (++)
14:46:56 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:47:59 <infrage> how long ? wxmac make 2.4 core duo
14:48:12 <Cowbar> typoclass, well, it's more that you can theoretically partially apply and therefore make a function return, while the whole idea of CPs is that no function returns.
14:49:25 <Cowbar> But obviously just using pairs solves that issue, carry on, I'm stupid, like that one vice praesident of the US who believed you could breathe on mars.
14:49:47 <Gracenotes> I suppose another way to say it is: in C, a lack of encapsulation can be deadly. In Haskell, it's just poor program design. But it's overriding many other factors, I'm finding.
14:49:51 <Gracenotes> in any case
14:50:41 <typoclass> Cowbar: right. however, in haskell, stuff isn't actually applied (isn't actually running, isn't actually returning) at the time you might expect because of laziness
14:51:14 <Cowbar> typoclass, that is true, which makes continuations a bit fuzzy for me to understand honestly.
14:51:35 <Cowbar> Specifically escape continuations, isn't that idea pretty much unsafe in haskell?
14:52:42 <Cowbar> Like ehhh, (let/cc escape ((always-0 (lambda xs 0))) (always-0 (escape 1))))
14:53:40 <Cowbar> In scheme that is well defined, that should be 1, but in Haskell, something identical, the program may never execute (escape 1) because it can prove that (always-0 x) will just be 0 for any x and replace it with that at compile time, so what goes?
14:54:42 <hpc> Cowbar: the trick is how scheme doesn't do types
14:55:00 <monochrom> it is why haskell doesn't give you continuations
14:55:15 <Cowbar> hpc, I'm not sure how that solves the fuzziness, I'll be frank if I say I don't understand how continuations can make a lot of sense in Haskell.
14:55:41 <hpc> if we imagine scheme had types, (escape 1) would have some kind of continuationy type, which we will just call "ContVal"
14:56:02 <hpc> the way we are using always-0 suggests it has a type of ContVal -> ContVal
14:56:08 <Cowbar> Ohhh, so like the values continuations return are wrapped inside somrthing?
14:56:15 <hpc> in haskell, it would probably look something like
14:56:20 <hpc> always0 k = do
14:56:21 <hpc>   k
14:56:23 <hpc>   return 0
14:56:37 <hpc> that's clearly not equal to return 0
14:57:09 <hpc> and yeah, haskell doesn't give you the kind of magic continuations scheme does for basically that reason
14:57:10 <Cowbar> hpc, ah yes, so the type system basically enforces that my example is not well typed in Haskell? You have to wrap it inside something?
14:57:32 <Cowbar> Well, that suddenlye xplains why I didn't understand any literature about continuations with respect to Haskell
14:57:40 <hpc> yep
14:58:02 <hpc> the type you wrap with is Cont, which is a bit bendy to even intermediate haskellers
14:58:05 <hpc> @src Cont
14:58:06 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
14:58:27 <Cowbar> It's a record?
14:58:28 <hpc> it happens to have a monadic interface that looks a lot like scheme
14:58:43 <hpc> the record is just sugar for the run function
14:58:44 <c_wraith> being a record just give it a handy accessor
14:58:47 <hpc> it could easily be something like
14:58:57 <hpc> newtype Cont r a = Cont ((a -> r) -> r)
14:59:01 <monochrom> it is not just types, and it has little to do with types. SML has similar types as Haskell, but can be made to support call/cc.
14:59:03 <hpc> runCont (Cont k) = k
14:59:34 <Cowbar> monochrom, yes, but SML is strict
14:59:46 <Cowbar> The major issue is that with non strict semantics it becomes extremely vague.
15:00:04 <monochrom> evaluation order is the key point. SML has a nailed evaluation order, so "the rest of the computation" means something, and you can store that in a continuation, and you know what you'll get
15:00:22 <monochrom> and so, it is not so much strictness either
15:00:33 <monochrom> Haskell does not have a nailed evaluation order
15:00:52 <Cowbar> That's what non strict in practice means right?
15:01:59 <kosmikus> Cowbar: the semantics is specified, the evaluation order isn't
15:02:36 <hpc> Cowbar: a casual definition of non-strict semantics might be, "if there's an evaluation order that would make this expression have a defined value, pick one of those"
15:02:53 <monochrom> screw "in practice". what does non-strict mean to you? pick one:  A. "don't know the evaluation order, although there are some constraints like const True undefined = True"  B. "I know the evaluation order, and it is the lazy order"  C. other: ________
15:02:55 <hpc> if that helps visualize the problem
15:03:03 <monochrom> to me it is A
15:03:11 <Cowbar> hpc, yeah I know.
15:03:34 <Cowbar> Like ehh, in scheme if you do (always-0 (escape 1) (escape 2)) it could be either.
15:03:44 <Cowbar> Or ((esacpe 1) (escape 2) (escape 3))
15:03:57 <monochrom> the thing is, if you nail the evaluation order, even if it's lazy, suddenly "the rest of the computation" is known again, and you can have continuations.
15:04:01 <Cowbar> So it's not a problem per se.
15:04:19 <Cowbar> monochrom, that is true.
15:04:41 <monochrom> on the flip side, if you only know "strict", there are still multiple evaluation orders
15:04:58 <Cowbar> But like, as I illustrated above, that it may be a lot of different things is not necessarily a problem.
15:05:01 <monochrom> this is the whole reason why I am against "strict vs lazy"
15:05:18 <Cowbar> I concur, it's shallow and paedantic.
15:10:53 <gwern> @quote
15:10:54 <lambdabot> cwillu_at_work says: the novice has a data corruption problem, and says "I know, I'll use error correcting codes!".  He then has either no or two problems
15:11:09 <monochrom> haha
15:13:45 <luite> I have a few large ADTs, call them Expr and Stat, and a function pretty :: Stat -> Doc, prettyExpr :: Expr -> Doc. Now i want to write another function pretty' :: Stat -> Doc, that does almost the same as pretty, but handles one type of statement differently.
15:13:51 <luite> how do i do that, in a way that it also works for nested block statements (for WhileStat ..., pretty :: Stat -> Doc calls itself to print the nested block)
15:15:05 <hpc> luite: you could probably expand pretty to "pretty :: (Stat -> Doc) -> Stat -> Doc""
15:15:14 <hpc> ordinaryPretty = fix pretty
15:15:21 <hpc> fancyPretty = ???
15:15:34 <luite> hpc: the existing pretty is in an existing package, i'd rather not touch that
15:15:35 <ion> 3. PROFIT
15:15:39 <hpc> ah
15:15:53 <hpc> hmm
15:16:07 <monochrom> you need some design patterns. XD
15:16:25 <hpc> haha
15:17:37 <monochrom> but what hpc says. you need open recursion, so as to be able to override things and have recursive calls honour your overriding. which is provided by OOP and some design patterns.
15:20:00 <luite> hm ok i'll just rewrit this in java then
15:21:49 <monochrom> onoes, what have I done :)
15:22:04 <hpc> depending on the structure, you could write it as a fold?
15:22:11 <hpc> like, if your structure was
15:22:47 <hpc> data Tree a = Leaf a | Tree a (Tree a) (Tree a), a fold would be fold :: a -> (a -> b -> b -> b) -> Tree a -> b
15:22:57 <hpc> er, b ->
15:23:19 <JoshuaA_> donri: I'm having trouble getting the unicode working in vim2hs, any ideas what might be causing it? I'm using vim powerline, which also uses unicode characters, so they're definitely supported ;)
15:23:24 <hpc> er, not that either; you get the point
15:23:51 <JoshuaA_> Other than that everything seems to work. Kudos for the nice setup!
15:23:52 <hpc> then you just substitute in different behavior for the specific "constructor" in the fold
15:28:53 <niteria> can I use haddock to pretty print the source and have hyperlinks?
15:33:38 <monochrom> yes. you need "hscolour". and then it is tedious to call haddock directly for this. but "cabal haddock --hyperlink-source" does the hard stuff for you
15:34:06 <bfig> can i stack multiple levels of where?
15:34:17 <bfig> (or lets)
15:34:25 <monochrom> yes
15:34:48 <monochrom> > let x = (let y = 4 in y) in x
15:34:50 <lambdabot>   4
15:34:50 <rwbarton> as long as you have a binding (or expression) to attach another where (or let) to
15:35:01 <monochrom> hmm...
15:35:05 <monochrom> > let {} in 4
15:35:07 <lambdabot>   4
15:35:29 <bfig> cool :)
15:35:47 <monochrom> > 4 where {}
15:35:49 <lambdabot>   <no location info>: parse error on input `where'
15:35:52 <bfig> > let {} in let {} in let {} in 4
15:35:54 <lambdabot>   4
15:36:19 <bfig> > 4 where { where { where { where { where {}}}}}
15:36:20 <lambdabot>   <no location info>: parse error on input `where'
15:36:37 <typoclass> bfig: yes, you just need to wrangle the indentation a bit, as usual :-) but you might sometime want to get at something inside the where or let, because of testing (quickcheck, unit tests) or because you want to try something in ghci real quick. so don't build any habits that will be in the way later :-)
15:36:43 <bfig> > 4 where { x = 3 where { x = 3 where { x = 3 where { x = 3 where {}}}}}
15:36:44 <lambdabot>   <no location info>: parse error on input `where'
15:36:49 <monochrom> > let {f x = x where {}} in 4
15:36:50 <lambdabot>   4
15:37:27 <bfig> typoclass, good to take into account :)
15:37:38 <bfig> i have been reborn as a haskell programer after finding Debug.Trace
15:37:57 <monochrom> yeah, need a binding so "where" can cling on to it
15:37:59 <typoclass> bfig: fine :-) welcome to the club
15:38:11 <bfig> :)
15:38:17 <int-e> > let x = x where x = 4 in x
15:38:19 <lambdabot>   4
15:38:31 <bfig> are there any good telecommuting jobs for haskellers?
15:38:53 <monochrom> @remember bfig i have been reborn as a haskell programer after finding Debug.Trace
15:38:53 <lambdabot> I will never forget.
15:39:03 * monochrom snickers evilly
15:39:08 <bfig> lol
15:40:10 <monochrom> I saw a job posting like that in haskell-cafe. let me find a link...
15:41:06 <bfig> cool :)
15:42:04 <monochrom> as usual, gmane is malfunctioning
15:42:44 <hpc> https://groups.google.com/forum/?fromgroups=#!searchin/haskell-cafe/job/haskell-cafe/dpqzt3Z1m1o/PHn0I_d4gCUJ
15:42:47 <monochrom> http://www.mail-archive.com/haskell-cafe@haskell.org/msg101435.html
15:43:53 <monochrom> "will work in a modern virtual environment in their homes. some travel may be required"
15:45:03 <augur> ski!
15:45:09 <monochrom> hrm, haskell-cafe is on google groups? that's bad...
15:45:10 <donri> JoshuaA_: could you elaborate?
15:47:27 <bfig> hpc, that sounds *way* out of my league
15:47:53 <bfig> monochrom, that sounds like a very daunting job but i'd gladly approach it. what do you think are the minimum requirements to be considered?
15:48:02 <bfig> (and for how long that position will be open)
15:48:16 <monochrom> I don't know. the posting certainly sounds like "we'll teach you everything"
15:48:35 <JoshuaA_> donri: donri your example screenshot shows unicode arrows instead of ->. I can't seem to get this to work when setting g:haskell_conceal_wide=1
15:50:22 <donri> JoshuaA_: have you added that to your vimrc and restarted vim?
15:51:49 <JoshuaA_> Ugh, I was testing it in a current vim buffer, sorry.
15:52:59 <donri> vim2hs uses autoloading to cache code which sadly means you have to restart if the code is already loaded, if you change settings
15:59:14 <niteria> Warning: Couldn't find .haddock for export Data.Typeable.Internal.Typeable
16:02:58 <GnomeStoleMyBike> Hi All
16:03:39 <Cale> hello
16:12:23 <sayuke> what does the "f | DataConstructor <- foo =" syntax mean in "zero | IntegralDict <- integralDict ty = codegenIntegralScalar ty 0"?
16:14:20 <typoclass> sayuke: it's not a view pattern, it's the other thing, what was it called ...
16:14:25 <hpc> pattern guard
16:15:28 <sayuke> hpc: so im used to f a | a == 1 = "one" type thing
16:15:32 <sayuke> what is the <-
16:15:38 <typoclass> right, it's not a simple guard, it's a pattern guard
16:15:53 <typoclass> sayuke: check this out file://localhost/usr/share/doc/ghc/html/users_guide/syntax-extns.html#pattern-guards
16:16:11 <sayuke> googling pattern guard helped
16:16:12 <sayuke> thanks :)
16:17:47 <typoclass> sayuke: customers who bought a pattern guard also bought a view pattern :-) it's the chapter right below pattern guards
16:18:29 * typoclass , in other news, is an idiot for linking to localhost. sorry. but you said you found it anyway.
16:18:30 <byorgey> customers who viewed pattern guards also had a pattern of viewing view patterns
16:20:33 <cmccann> byorgey, can you do animations in diagrams?
16:20:39 <byorgey> cmccann: yes
16:20:59 <cmccann> animating those factorization diagrams might be neat
16:21:10 <byorgey> yes, I thought of that, I'm going to try =)
16:21:24 <cmccann> as in, show it splitting for factorization
16:21:34 <cmccann> hm
16:21:45 <byorgey> show the diagram for n, then have another dot appear in the middle, then have all the dots zoom to their locations for the factorization of n+1
16:22:21 <byorgey> right, or just show a single dot and have it recursively split
16:22:22 <donri> typoclass: ah, but that link works for me! :)
16:22:47 <donri> is there any situation where pattern guards are preferable over view patterns?
16:23:04 <cmccann> yeah, I was thinking starting with a dot representing the product, then moving/shrinking dots from that point to show the factoring one number at a time
16:23:30 <byorgey> cmccann: yeah, that sounds nice
16:23:41 <cmccann> for large composite numbers it might be interesting
16:24:03 <byorgey> donri: well, they aren't exactly interchangeable
16:24:07 <cmccann> since for primes you'd just have one dot --> a big circle
16:24:15 <byorgey> donri: with a pattern guard you can pattern match on a function of several parameters
16:24:19 <bfig> monochrom, sent an email :)
16:24:20 <byorgey> cmccann: right
16:24:24 <donri> byorgey: no, but view patterns are strictly more powerful afaik?
16:24:36 <bfig> if i get this job, that'd be **awesome**
16:24:37 <byorgey> donri: but with view patterns you can only match on a function of a single argument
16:24:46 <donri> byorgey: well view patterns take an arbitrary expression, so you can do flip or lambdas etc?
16:25:12 <byorgey> donri: yes, but if your function is   f x y z = ...   you can't have a view pattern that takes x AND y into account
16:25:28 <byorgey> i.e. you have to do   f (foo -> Blah) y z = ...
16:25:31 <donri> or you mean guarding multiple variables in a pattern
16:25:45 <byorgey> but with a pattern you can do   f x y z | Blah <- foo x y = ...
16:25:58 <donri> yea i feel y a :) thanks
16:26:14 <byorgey> bfig: what job?
16:27:23 <cmccann> byorgey, btw, did anyone ever manage to sell you on geometric algebra? :]
16:27:44 <byorgey> cmccann: oh, it's clearly really cool
16:27:52 <byorgey> I just haven't yet put in the time to learn it properly
16:28:36 <cmccann> it's not very difficult, the main issue is lack of implementations and too much material that spends more time evangelizing the idea than explaining it :[
16:28:43 <byorgey> I'm also afraid that if I do learn it properly, I'll end up rewriting diagrams from scratch =P
16:29:03 <byorgey> heh
16:29:10 <Tekmo> Geometric algebra rules!
16:29:11 <cmccann> I doubt that, but I haven't looked at how diagrams is implemented
16:29:21 <byorgey> hehe, ok
16:29:32 <byorgey> well, it's lots of traditional vector space stuff
16:29:41 <byorgey> vector spaces and affine spaces
16:29:49 <copumpkin> Algebraic geometry rules!
16:29:51 <cmccann> it's a generalization of complex numbers at heart
16:30:10 <byorgey> right
16:30:39 <cmccann> anyway, waiting for someone else to make a full haskell implementation of GA seemed to not be working so I'm attempting to put together something that's at least usable enough for doing graphics
16:30:42 <byorgey> heh, I like how Geometric Algebra and Algebraic Geometry are both Things, and they are completely different
16:30:44 <Tekmo> Well
16:30:51 <Tekmo> What I do is special case it to three dimensions
16:30:51 <cmccann> yeah, that amuses me
16:30:58 <Tekmo> when writing my own geometry libraries
16:30:59 <byorgey> cmccann: oh, very cool
16:31:14 <byorgey> cmccann: wasn't edwardk working on an implementation of GA, once upon a time?
16:31:25 <Tekmo> If you just wrote a highly performant 3-D version of GA, I think a lot of people would use it
16:31:25 <cmccann> he has a geometric coalgebra
16:31:27 <cmccann> because he's edwardk
16:31:33 <byorgey> haha
16:31:51 <byorgey> Tekmo: probably, though diagrams is explicitly polymorphic in the vector space
16:32:05 <byorgey> though there's nothing yet that takes advantage of it.
16:32:08 <Tekmo> byorgey: Yes, but can I divide by a diagram?  No.  Case closed!
16:32:08 <cmccann> Tekmo, I'm after a tolerably fast version that can do conformal 3D
16:32:19 <byorgey> hehe
16:33:08 <Tekmo> cmccann: You can always do the matrix approach
16:33:25 <cmccann> anyway, edwardk's implementation is neat but I found it counterintuitive to reason about performance
16:33:46 <cmccann> and I have a lot of cases where I'm happy to force things to very limited portions of a full multivector and be explicit about it
16:34:12 <cmccann> whereas the coalgebra works best if you want an arbitrarily large basis that you filter after the fact by inspecting only certain elements
16:34:13 <bfig> byorgey, http://www.mail-archive.com/haskell-cafe@haskell.org/msg101435.html
16:34:35 <cmccann> Tekmo, hm?
16:34:43 <cmccann> right now I'm just shoving everything into an unpacked vector
16:34:53 <Tekmo> cmccann: You represent all terms as matrices
16:35:08 <cmccann> and using TH to hardcode the various products
16:35:14 <Tekmo> cmccann: Then the matrix operations correspond to the GA operations
16:35:18 <byorgey> bfig: ah, looks cool
16:35:22 <bfig> :)
16:35:27 <byorgey> I hear good things about Boulder
16:35:35 <byorgey> (and the job sounds neat too =)
16:35:54 <Tekmo> cmccann: The disadvantage is that all 3-D values require an 8x8 matrix to represent
16:35:58 <Cale> Yeah, the preachiness about distinguishing between vectors and points can be a little annoying. There are obviously settings in which it's all right to identify vectors and points, and settings in which it's not okay.
16:35:59 <Tekmo> cmccann: So it's very wasteful of space
16:36:02 <bfig> doubt they will be interested though :(
16:36:25 <cmccann> Cale, distinguishing vectors from bivectors is what I found most persuasive
16:36:40 <Tekmo> cmccann: Yeah, it's really elegant
16:36:50 <cmccann> Tekmo, yeah I'm already wasting enough space doing conformal 3D
16:36:51 <bfig> their profile seems to be a phd related to distributed computing with ample experience... i'm an almost-engineer :p
16:37:08 <Tekmo> cmccann: Here, let me find my half-assed GA package I use
16:37:12 <Tekmo> cmccann: So you can see the matrices
16:37:14 <cmccann> as is to make this really usable I'll need to do some special-case handling for values of limited grade
16:37:21 <Tekmo> cmccann: It will be pretty obvious when you see the matrices
16:37:53 <Eduard_Munteanu> dontcare: IRC-ing as root? ;)
16:37:59 <cmccann> Tekmo, note that "conformal 3D" means "non-euclidean 5D space projected down twice to get 3D"
16:38:06 <Tekmo> Oh
16:38:08 <dontcare> Eduard_Munteanu: Ident root nc
16:38:10 <dontcare> znc*
16:38:13 <Tekmo> Then you will have huge-ass matrices
16:38:16 <cmccann> my multivectors are already 2^5 elements
16:38:19 <cmccann> I don't need them any bigger
16:38:24 <Tekmo> yeah
16:38:28 <Tekmo> It would be that, squared
16:38:35 <Tekmo> 32x32 matrices
16:38:53 <Tekmo> There was some guy
16:38:59 <dontcare> Eduard_Munteanu: if i could only figure out ssl with znc then it would look even sillier :P
16:38:59 <cmccann> the full geometric product takes 32^2 multiplications and that's already painful enough
16:39:00 <Tekmo> who did his thesis on a space-efficient performant version
16:39:07 <Tekmo> Let me see if I can google it
16:39:19 <cmccann> was it based on C++ template hackery?
16:39:26 <cmccann> because there are a couple versions along those lines
16:39:29 <Tekmo> http://staff.science.uva.nl/~fontijne/phd.html
16:39:31 <Tekmo> That's it
16:39:46 <cmccann> yeah pretty sure that's the one I'm thinking of
16:40:32 <cmccann> I'd rather just have a haskell implementation
16:40:46 <Tekmo> Me, too
16:40:57 <cmccann> but I'm using TH for mostly the same reasons he did stuff with C++ templates if I'm remembering correctly
16:41:15 <Tekmo> Right now I'm not doing as much geometric stuff as I was before
16:41:16 <cmccann> pretty sure I read his large chunks of his thesis a while back
16:41:26 <cmccann> so I'm familiar with the basic idea
16:41:36 <Tekmo> But when I was, my crude GA implementation as like lightning shoot out of my fingertips
16:41:45 <cmccann> but ugh. TH is such a pain
16:42:02 <Tekmo> Are they ever going to come up with a more elegant alternative to TH
16:42:10 <cmccann> there was talk of it a while back
16:42:27 <Tekmo> I remember Oleg saying something about it
16:42:33 <Tekmo> with respect to his finally-tagless paper
16:42:36 <cmccann> actually, I thought there was talk of splitting it into two different versions
16:43:20 <cmccann> one for powerful AST building with no correctness checks, and one for something more like staged programming where type checking the template code would guarantee well-typed output
16:43:55 <cmccann> instead of the current situation of splices/quotation/AST mishmash that does both poorly
16:44:26 <Tekmo> That's just one of the problems with Haskell in general
16:44:44 <Tekmo> There is just too big of a divide between writing the programming and running it
16:45:20 <cmccann> I think Jacques Carette was involved on the "well-typed metaprogramming" side of things
16:45:23 <Tekmo> I wish some legendary hero would come along and make it possible to seamlessly mix compiling with running with hot code loading
16:47:04 <Cale> This reminds me that at some point I should write down somewhere my little bit of algebra that takes the polarity which exchanges points and lines via a conic section and generalises that to a higher degree variety.
16:47:14 <cmccann> anyway, this GA stuff is what's currently distracting me from the stream processing and linear logic stuff from the other night :P
16:47:18 <Tekmo> lol
16:47:21 <Tekmo> Give me a second
16:47:25 <Tekmo> I'm polishing up pipes-2.4
16:47:33 <Tekmo> I'm about to upload it to Hackage
16:48:37 <cmccann> I've also been thinking about implementing a toy language with a linear type system
16:49:24 <cmccann> I have a few ideas for how it might work, after spending all this time tinkering with encoding linear logic in Haskell...
16:52:10 <Tekmo> Actually, I'll have to discuss it later.  My daughter wants to play with me
16:52:20 <Tekmo> I'll be on more tonight
16:52:52 <cmccann> heh, no rush
16:53:03 <cmccann> I'm working on the GA stuff right now anyway
16:53:54 <wto> I'm trying to compile GHC on a raspberry pi of mine, but it keeps insisting that I need a working ghc already. Following these instructions: http://hackage.haskell.org/trac/ghc/wiki/Building/Porting
16:54:35 <wto> at the configure stage, it tries to compile a version of ghc-pwd, which is of course not possible.
16:59:02 <rwbarton> hmm, really? don't those instructions tell you to copy ghc-pwd from /bin/pwd?
16:59:53 <wto> exactly, which I did. But then it tries to compile its own version of it anyway
16:59:55 <publican> how to uninstall a bre package
17:00:18 <rwbarton> odd
17:00:21 <rwbarton> well I don't know, sorry
17:00:25 <publican> *brew
17:01:29 <publican> how to uninstall  wxmac --devel in brew?
17:02:07 <geekosaur> maybe you should ask in a channel about brew instead of one about haskell?
17:02:29 <publican> ok
17:03:31 <alephomega> publican: it should be documented... maybe homebrew -h or man homebrew?
17:05:07 * hackagebot pipes 2.4.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-2.4.0 (GabrielGonzalez)
17:08:50 <jfischoff> it appears that cabal stores packages in a folder associated with the version of ghc, but not the architecture. So if you have both a 32 and 64 bit version of ghc, is there something special that must be done to keep the installed packages separate?
17:17:05 <Guest51026> hi, can anyone help me out? i'm learning the haskell, i've written a Server.hs file, but when i run ghc Server.hs, it doesn't create a binary file, only object file. any ideas why its not creating ./Server?
17:18:03 <Saizan> jfischoff: add $arch to the paths in ~/.cabal/config
17:18:17 <jfischoff> cool
17:18:50 <rwbarton> Guest51026, try ghc Server.hs -main-is Server.main
17:19:04 <rwbarton> assuming you defined a "main" in Server
17:19:07 <cmccann> or just rename it to Main.hs, I'm lazy that way
17:19:48 * rwbarton just doesn't write "module Foo where"
17:20:00 <Guest51026> rwbarton: thanks that works great
17:20:13 <cmccann> rwbarton, also a fine approach
17:23:49 <Lutin`> So how are you Windows users setup for Haskell dev?
17:23:54 <Lutin`> Esp the ones that use vim
17:24:50 <cmccann> my usual setup for Haskell on windows involved swearing, crying into my beer, then going back to linux
17:25:10 <cmccann> at least where anything using the FFI was involved
17:25:11 <Lutin`> Yeah that's my current one ;[
17:25:20 <cornihilio> I keep trying to understand attoparsec, but it's still a bit too weird for me to grok. In my mind, the result type contains some data, primarily the values that the parser instantiated as it ws parsing a bytestring. How do I get that list of values out of the result type? relevant: http://hackage.haskell.org/packages/archive/attoparsec/0.8.3.0/doc/html/Data-Attoparsec-Lazy.html#t:Result
17:25:45 <Lutin`> reboot time it is
17:26:00 <rwbarton> cornihilio, you return whatever data you want from your parser
17:26:41 <cornihilio> rwbarton: I do not understand
17:27:01 <rwbarton> I suggest you look at a Parsec tutorial
17:27:09 <cornihilio> here is a gist of my code if you want to see the half-assed parser I'm using: https://gist.github.com/3846605
17:27:13 <monochrom> perhaps I should write a parsec tutorial
17:27:32 <cornihilio> rwbarton: how different are attoparsec and parsec?
17:27:50 <cmccann> are there any parsec tutorials that aren't slightly broken due to being based on older versions?
17:27:52 <rwbarton> I haven't used attoparsec but AFAIK not very
17:27:54 <monochrom> if you understand parsec basics, attoparsec is easy to pick up
17:28:01 <cmccann> if memory serves me that was an issue last time I looked around
17:28:13 <cornihilio> haha, I guess I don't understand parsec basics :P
17:28:37 <cornihilio> is the rwh chapter on it pretty much the definitive tutorial?
17:28:44 <rwbarton> cornihilio: well in howMany you throw the packets away
17:28:46 <rwbarton> only keeping the length
17:28:50 <cmccann> cornihilio, pretty sure you're asking about one of the places where attoparsec is rather different
17:29:24 <cornihilio> cmccann: dang it!
17:29:33 <rwbarton> but if you wanted to access the packets, you could do it inside howMany
17:30:15 <cornihilio> I keep trying ot read articles about atto/parsec and they are from ~2007 and seem to mix and match.
17:30:21 <rwbarton> your parser is "howMany packetValue", that is a AL.Parser Int, its return value is the number of packets and you got it out with AL.maybeResult
17:30:27 <cornihilio> rwbarton: thank you for that pointer!
17:32:04 <cornihilio> rwbarton: if you don't mind me troubling you a bit more, could you perhaps explain what howMany does? my simple understanding is that it is using an applicative to find the length of the list containing the packets, going by what you said earlier.
17:32:25 <rwbarton> p is a parser that returns a Packet
17:32:35 <rwbarton> many p is a parser that returns a list of Packets ([Packet])
17:32:47 <rwbarton> fmap length (many p) is a parser that returns the length of that list (as an Int)
17:33:08 <rwbarton> I don't know what you mean by "an applicative". the applicative functor here is just AL.Parser
17:34:31 <cornihilio> rwbarton: than I'm just misusing the term, I thought that's what it was called
17:34:50 <rwbarton> well I just can't tell how you think you are using the term :)
17:35:13 <rwbarton> there is no reason for howMany not to just be specialized to AL.Parser
17:35:23 <rwbarton> howMany :: AL.Parser a -> AL.Parser Int
17:35:56 <cornihilio> well I just rewrote it removing howMany and this is what I have: https://gist.github.com/3846649
17:36:00 <cornihilio> thank you very much!
17:36:17 <rwbarton> right
17:36:52 <cornihilio> I'm still stuck on the issue of the parser giving up after the first failed parse; I'm not sure how to do recursion with something that returns Nothing if it fails at parsing a packet or reaches the end of the stream.
17:37:41 <rwbarton> this is a trickier subject and I don't know whether attoparsec can do it
17:38:11 <rwbarton> "resumable parsing"
17:41:04 <cornihilio> oh no... what do you mean?
17:43:16 <cornihilio> is this something I would understand better if I reread the parsec chapter? or this specific to attoparsec?
17:44:14 <jfischoff> Saizan: there is /usr/local/lib/ghc-7.6.1 library is fixed to one arch. Is there a setting to get around that?
17:45:53 <publican> why cabal-macosx command not found
17:46:22 <jfischoff> publican: it's not an executable
17:46:42 <publican> i am trying to bundle a .hs
17:46:57 <publican> cabal-macosx wxtest
17:49:15 <jfischoff> are you saying you want to create an application bundle i.e. an .app folder?
17:55:24 <publican> yes so it can execute
17:57:43 <sayuke> what can I google to learn about the ~ in "Could not deduce (e ~ sh)"
17:58:21 <sipa> sayuke: "type equality constraint"
17:58:21 <cornihilio> okay... here is what I have so far, but I'm getting stuck with a weird error (it's at the top of the gist): https://gist.github.com/3846702
17:58:39 <jfischoff> publican: in your cabal file make -> Build-type: Custom
17:59:15 <jfischoff> publican: use this for your Setup.hs http://hpaste.org/75892
17:59:35 <jfischoff> and change the name of the app to match the name of executable in your cabal file
17:59:36 <Cale> sayuke: Basically, it says that those two types, whatever they are, need to be equal to each other in order for things to work.
18:00:11 <Cale> sayuke: and the error is that it can't prove that they are equal given the actual code.
18:01:29 <publican> ok iwill
18:05:49 <publican> Setup: At least the following dependencies are missing: cabal-macosx -any, wx -any
18:08:20 <jfischoff> publican: `cabal install cabal-macosx wx`
18:09:06 <publican> i tink is a problem with my platform hot can i completely delete it a install it again
18:13:20 <jfischoff> what happens when  you try to install cabal-macosx?
18:18:22 <deech> Hi all, is it possible to call Agda functions from Haskell?
18:23:12 <alephomega> http://www.haskell.org/haskellwiki/Foreign_Function_Interface this may help?
18:29:24 <cullin> how to completely remove haskell platform to install properly
18:29:42 <cullin> ??
18:34:18 <amindfv> cullin: http://stackoverflow.com/questions/6884478/everywhere-that-ghc-haskell-platform-installs
18:45:12 <cullin> ghc: no input files
18:45:12 * hackagebot xbattbar 0.1 - Simple battery indicator  http://hackage.haskell.org/package/xbattbar-0.1 (AlexanderPolakov)
18:45:20 <cullin> when in terminal ghc
18:45:27 <cullin> oh wait thats right
18:45:31 <cullin> lol ;F
19:00:11 <DalZap> alguien que hable español
19:01:09 <MostAwesomeDude> Yes, but I can't help you with Haskell en espanol. :c
19:01:18 <DalZap> how do this: x^(1/3)
19:02:06 <DalZap> root cubic. raiz cúbica, root 3
19:02:13 <rwbarton> x**(1/3)
19:03:15 <DalZap> easy. gracias. thanks.
19:03:21 <MostAwesomeDude> > 27 ** (1/3)
19:03:22 <lambdabot>   3.0
19:03:56 <DalZap> problema resuelto. Gracias a todos
19:04:09 <MostAwesomeDude> De nada. :3
19:11:10 <sipa> > (-64) ** (1/30
19:11:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
19:11:13 <sipa> > (-64) ** (1/3)
19:11:14 <lambdabot>   NaN
19:11:25 <sipa> > (-64) ** (1)
19:11:26 <lambdabot>   -64.0
19:19:53 <Jafet> > (-64) ** (1/3) :: Complex Double
19:19:54 <lambdabot>   2.0 :+ (-3.4641016151377535)
19:20:42 <sipa> heh
19:20:44 <Jafet> > (-1) ** (1/(0:+pi)) :: Complex Double
19:20:45 <lambdabot>   0.36787944117144233 :+ (-0.0)
19:20:49 <sipa> > (-4) ** 3
19:20:50 <lambdabot>   -64.0
19:21:23 <sipa> > (2.0 :+ (-3.464101615)) ** 3
19:21:24 <lambdabot>   (-63.999999994273686) :+ (-3.3060779218071626e-9)
19:21:51 <Jafet> > (2.0 :+ 3.4641016151377535)^3
19:21:52 <lambdabot>   (-63.99999999999996) :+ 2.4868995751603507e-14
19:28:22 <shachaf> Is there a reason that "a newtype constructor cannot have an existential context" in GHC?
19:30:45 <JoeyA> I think it's because an existential context requires a dictionary.
19:30:47 <byorgey> shachaf: because newtype constructors have no runtime representation
19:31:00 <byorgey> and what JoeyA said.  You have to pair a dictionary with the value.
19:31:08 <shachaf> What dictionary?
19:31:16 <shachaf> newtype Foo = forall a. Foo a
19:31:19 <shachaf> That's pretty useless.
19:31:22 <shachaf> newtype Foo = forall a. Foo (a,a -> Int)
19:31:38 <byorgey> oh.  good point.
19:31:44 <cornihilio> what does $ mean?
19:31:50 <byorgey> shachaf: dunno then.
19:32:01 <mm_freak> cornihilio: f $ x = f x
19:32:21 <JoeyA> cornihilio: Infix function application, mainly for convenience
19:32:23 <cornihilio> it only affects operator precedence, right?
19:32:34 <cornihilio> err I guess not
19:32:38 <byorgey> it does not affect operator precedence.
19:32:39 <JoeyA> so instead of saying f (a b (c d e (f g)))
19:32:41 <Nereid> $ has a very low precedence
19:32:46 <JoeyA> you can say f $ a b $ c d e $ f g
19:32:47 <Nereid> function application has the highest precedence
19:32:48 <byorgey> it is simply an operator, with a low precedence.
19:32:57 <Nereid> yeah $ is just an ordinary binary operator.
19:33:00 <shachaf> f . ab . c d e $ f g
19:33:09 <mm_freak> JoeyA: very bad example
19:33:14 <mm_freak> don't give such examples…
19:33:17 <JoeyA> mm_freak: Why?
19:33:23 <Nereid> because it's atypical
19:33:27 <byorgey> infixr 0 $; f $ x = f x  -- everything you need to know about $
19:33:34 <mm_freak> JoeyA: f $ g $ h $ x = f . g . h $ x
19:33:41 <Nereid> and that
19:33:55 <JoeyA> I for one find f . g . h $ x harder to read.
19:34:09 <JoeyA> I'd rather see "f applied to the following: g applied to the following: ..."
19:34:11 <Nereid> JoeyA: I find it easier.
19:34:16 <JoeyA> Though I'm fine with (f . g . h) x
19:34:19 <Nereid> because then I don't have to think about which way $ associates
19:34:20 <mm_freak> JoeyA: i'd argue that most haskellers find that one easier, and it is much more composable
19:34:28 <Nereid> and . is associative
19:34:32 <mm_freak> JoeyA: i agree about your last point, though
19:34:40 <mm_freak> i prefer (f . g . h) x, too
19:34:56 <Nereid> but $ exists precisely to get rid of parentheses in such a situation.
19:35:11 <shachaf> ((.h) . (.g) . (.h)) x
19:35:16 <mm_freak> i propose that you should have to import Data.Function to get ($)
19:35:17 <cornihilio> but isn't . only exist to make a function curried, as in it won't be executed immediately?
19:35:23 <cornihilio> doesnt*
19:35:26 <Nereid> huh?
19:35:30 <Nereid> . is function composition
19:35:33 <Nereid> it exists to compose functions
19:35:37 <shachaf> Er
19:35:42 <mm_freak> cornihilio: it has nothing to do with currying…  "f . g" is the function that applies g, then f
19:35:45 <JoeyA> Going by character count: (f . g . h) x and f . g . h $ x are the same length.  f $ g $ h x is shorter.
19:35:49 <Nereid> (f . g) x = f (g x)
19:36:07 <Nereid> JoeyA: yeah, but it's easier to insert a $ and an adjacent space than to insert a pair of parentheses
19:36:11 <JoeyA> Well, with that spacing
19:36:14 <shachaf> ((.h) . (.g) . (.f)) x
19:36:15 <applicative> cornihilio: the things on either side of . are so far 'partially applied' I guess
19:36:17 <JoeyA> f.g.h$x is shorter than (f.g.h)x
19:36:32 <cornihilio> why don't you want to include x in the composition? f . g . x
19:36:36 * shachaf sighs.
19:36:38 <mm_freak> JoeyA: breaks down once you have a constructor
19:36:45 <Nereid> cornihilio: because you think about it.
19:36:50 <mm_freak> F.G.H$x is most likely a "not in scope" error
19:36:51 <applicative> cornihilio: they aren't composed with x
19:36:53 <Nereid> @type (.)
19:36:54 <JoeyA> cornihilio: Each item in the composition chain is a function.
19:36:55 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:36:58 <Nereid> erdthfgh
19:36:58 <JoeyA> x is the value.
19:36:59 <Nereid> @type (Prelude..)
19:37:01 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
19:37:02 <applicative> cornihilio: they (together) are applied to it
19:37:28 <applicative> > ord . chr . ord . chr $ 100
19:37:30 <lambdabot>   100
19:37:32 <mm_freak> cornihilio: your misconception might be that the dot operator is builtin syntax…  it's a regular function that you can define
19:37:46 <applicative> > chr . ord . chr . ord . chr $ 100
19:37:46 <mm_freak> now try to define a version that allows to compose with the x
19:37:49 <lambdabot>   'd'
19:38:08 <mm_freak> you couldn't even write the type for that one
19:38:15 <cornihilio> > chr . ord. chr . ord . chr (100)
19:38:17 <lambdabot>   Couldn't match expected type `f GHC.Types.Char'
19:38:17 <lambdabot>         against inferred ty...
19:38:18 <JoeyA> Fun way to think about (f . g . h) x: f . g . h is a train of functions.  You use . to stick the cars together.  This train is bearing down on x.  h will run over it first.
19:38:33 <Nereid> > chr . ord. chr . ord . chr $ 100
19:38:35 <lambdabot>   'd'
19:38:44 <Nereid> JoeyA: haha.
19:39:02 <cornihilio> I still don't get why $ is used in your example
19:39:15 <Nereid> it doesn't have to be
19:39:16 <mm_freak> cornihilio: f . g $ x = (f . g) x
19:39:19 <Nereid> > (chr . ord. chr . ord . chr) 100
19:39:21 <lambdabot>   'd'
19:39:22 <mm_freak> cornihilio: because f $ x = f x
19:39:39 <mm_freak> the '$' just saves you the parentheses at the expense of flatter code
19:39:40 <Nereid> by definition, chr . ord. chr . ord . chr $ 100 = (chr . ord. chr . ord . chr) 100
19:39:49 <Nereid> (definition of ($))
19:40:16 <cornihilio> so $ works on the items to it's left?
19:40:31 <mm_freak> cornihilio: what languages are you familiar with?
19:40:32 <Nereid> huh
19:40:47 <mm_freak> name your favorite
19:40:47 <Nereid> $ is just a binary operator, like + or *
19:40:49 <Nereid> or :
19:41:20 <mm_freak> then i will explain ($) in terms of your favorite language =)
19:41:23 <cornihilio> python
19:41:38 <mm_freak> ok, imagine in python you have a function "func" and a value "x" you want to apply it to
19:41:38 <cornihilio> I know python, java, and a little bit of cl
19:41:45 <mm_freak> normally you would write func(x)
19:41:49 <Nereid> def apply(f,x): return f(x)
19:41:58 <mm_freak> but you can also define a function:  def apply(f, x): return f(x)
19:42:08 <mm_freak> that's the '$' function
19:42:12 <mm_freak> difference:  '$' is infix
19:42:23 <mm_freak> so you write func $ x instead of apply(func, x)
19:42:25 <Nereid> in haskell, you could write ($) f x
19:42:32 <Nereid> where ($) is apply
19:42:45 <Nereid> and it's just defined as ($) f x = f x
19:43:00 <mm_freak> (.) is something similar:  def compose(f, g): return lambda x: f(g(x))
19:43:34 <cornihilio> mm_freak: I guess what I don't get is that if I wanted f(x), why wouldn't I just call f(x) there?
19:43:42 <Nereid> yu can
19:43:44 <Nereid> you*
19:43:51 <mm_freak> cornihilio: operator precedence
19:44:07 <Nereid> it just saves you some parentheses sometimes
19:44:09 <Nereid> like
19:44:11 <cornihilio> okay, I think I'm getting it now
19:44:12 <mm_freak> > const (sin 3)
19:44:13 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
19:44:14 <lambdabot>    arising from a use of `...
19:44:19 <Nereid> instead of writing (return . sin) (5 + 6)
19:44:19 <mm_freak> bad…
19:44:22 <Nereid> you can just write
19:44:24 <Nereid> return . sin $ 5 + 6
19:44:49 <Nereid> because
19:44:59 <Nereid> that parses as (return . sin) $ (5 + 6), because $ has lowest precedence
19:45:01 <mm_freak> cornihilio: background:  function application is a hidden operator that has the highest precedence
19:45:05 <cornihilio> and $ simply wraps everything between it and the beginning of the declaration in parens?
19:45:22 <Nereid> cornihilio: it's not $ that does that
19:45:25 <mm_freak> so if you write sin x + 3, it's parsed as (sin x) + 3
19:45:29 <Nereid> but it's parsed that way because of $'s low precedence
19:45:37 <mm_freak> you could write sin (x + 3)
19:45:44 <mm_freak> but you could also write sin $ x + 3
19:45:49 <mm_freak> because ($) has lowest priority
19:46:13 <cornihilio> sin (x + 3) == sin $ x + 3?
19:46:18 <mm_freak> yes
19:46:26 <mm_freak> you could even say "=" instead of "=="
19:46:38 <cornihilio> cos . sin (x + 3) == cos. sin $ x + 3?
19:46:43 <Nereid> no
19:46:47 <otters> what's the recommended lens library
19:46:54 <Nereid> cos . sin (x + 3) parses as cos . (sin (x + 3))
19:46:56 <edwardk> lens
19:47:12 <otters> none of them are called that
19:47:13 <otters> do you mean lenses
19:47:17 <cornihilio> okay, I really don't get that, if that's true
19:47:21 <edwardk> no, i mean lens
19:47:22 <mm_freak> otters: check out hackage
19:47:25 <edwardk> trust me its there ;)
19:47:28 <mm_freak> there is a library called "lens" =)
19:47:32 <Nereid> cornihilio: because function application binds more tightly than everything else
19:47:32 <otters> ok
19:47:35 <edwardk> @hackage lens
19:47:35 <lambdabot> http://hackage.haskell.org/package/lens
19:47:49 <otters> oh, it's the one with the gigantic diagram
19:47:56 <Nereid> haha
19:48:00 <mm_freak> cornihilio: imagine you would have to write function application as an operator called '##'
19:48:02 <edwardk> =)
19:48:08 <mm_freak> f ## x + 3
19:48:16 <cornihilio> cos sin (x + 3) = cos . sin $ x + 3?
19:48:23 <mm_freak> ## has the highest priority, higher than +, so it's parsed as (f ## x) + 3
19:48:23 <Nereid> cornihilio: no
19:48:32 <Nereid> cos sin (x + 3) = (cos sin) (x + 3)
19:48:33 <Nereid> (currying)
19:48:39 <edwardk> https://github.com/ekmett/lens#examples shows more examples
19:48:41 <mm_freak> $ has the lowest priority, lower than +, so f $ x + 3 = f (x + 3)
19:48:49 <mm_freak> or f ## (x + 3), if you will
19:48:51 <Nereid> (and function application associates to the left)
19:49:13 <mm_freak> i'll leave explaining the rest to Nereid =)
19:49:15 <Nereid> so in mm_freak's notation, a ## b ## c = (a ## b) ## c
19:49:34 <mm_freak> just one hint:  you should probably explain currying later =)
19:49:43 <Nereid> yeah but he was asking about cos sin (x + 3)
19:49:58 <otters> why does lens have this many dependencies
19:50:08 <Nereid> which parses as (cos sin) (x + 3)
19:50:14 <Nereid> to write what you mean, you could:
19:50:17 <Nereid> cos (sin (x + 3))
19:50:20 <Nereid> or cos $ sin (x + 3)
19:50:22 <edwardk> lens comes 'batteries included' with a lot of lenses for stuff that is in the haskell platform
19:50:30 <Nereid> or cos $ sin $ x + 3, or cos . sin $ x + 3, or ...
19:50:49 <otters> I see
19:50:57 <Nereid> edwardk: what if you separate it out into two packages, lens and lens-batteries?
19:50:58 <cornihilio> but cos (sin (x + 3)) isn't equal to cos . sin $ (x + 3)
19:51:03 <Nereid> cornihilio: sure it is
19:51:10 <Nereid> > cos (sin (x + 3))
19:51:11 <lambdabot>   cos (sin (x + 3))
19:51:13 <Nereid> > cos . sin $ (x + 3)
19:51:15 <edwardk> Nereid: not going to happen. i need most of the dependencies just to provide the basic functionality
19:51:15 <lambdabot>   cos (sin (x + 3))
19:51:20 <Nereid> edwardk: heh.
19:51:44 <edwardk> and it complicates life for all of the end users to make the vanishingly small set of users who don't like the extra dependencies happier
19:51:47 <cornihilio> so cos sin (x + 3) = cos . sin $ (x + 3)
19:51:52 <Nereid> no
19:52:20 <cornihilio> what?!?! cos (sin (x + 3)) != cos sin (x + 3)?
19:52:24 <Nereid> indeed
19:52:30 <Nereid> as I said, function application associates to the left
19:52:33 <Nereid> so a b c means (a b) c
19:52:48 <Nereid> not a (b c)
19:53:01 <cornihilio> oh, okay
19:53:02 <geekosaur> cos sin (x + 3) tries to invoke what in som other language mught be described as cos(sin, x + 3)
19:53:11 <Nereid> indeed
19:53:23 <edwardk> Nereid: i actually seriously considered splitting lens up like i used to split all my packages initially
19:53:29 <cornihilio> is that sort of associativity normal in programming languages, or unique to haskell? for some reason I'm having trouble wrapping my head around it I guess
19:53:37 <geekosaur> it takes some getting used to
19:53:38 <edwardk> then dolio made a pretty compelling case to me for not doing so
19:53:48 <sayuke> how do i reference type variables in a function definition from inside a "where"
19:53:57 <Nereid> cornihilio: it's this way in haskell because of the way haskell handles functions with multiple arguments
19:53:59 <Nereid> namely, currying
19:54:30 <edwardk> the fact is it is compatible with lens-family, which takes that approach. you can make a lens with either, and use it with the other, but i really don't like the resulting api that you get when you split it up
19:54:55 <Nereid> sayuke: ScopedTypeVariables
19:56:15 <edwardk> importing Control.Lens gets you a large base of lenses to work with and combinators to use with them, that are all designed to be mutually compatible. The split version means that the pace of development slows to a crawl, that the end user has to now import at least 3 modules to do anything, and incur ~3 dependencies, the cognitive load is high enough without adding that
19:56:38 <Nereid> edwardk: right
19:56:52 <edwardk> i realize i am beating a dead horse ;)
19:57:18 <Nereid> I was sure you had a good reason to have it the way it is ;)
19:57:23 <jmcarthur> > (cos.sin)(+3)x
19:57:26 <lambdabot>   cos (sin (x + 3))
19:57:40 <Nereid> jmcarthur: saved by caleskell
19:57:45 <edwardk> jmcarthur: =P
19:57:58 <Nereid> or rather
19:57:59 <rwbarton> I was so proud of everyone for not doing that
19:57:59 <jmcarthur> Nereid: i actually like NumInstances
19:58:00 <Nereid> damn you caaaaaaale!
19:58:12 <edwardk> > cos sin x
19:58:13 <lambdabot>   cos (sin x)
19:58:16 <edwardk> =)
19:58:41 <jmcarthur> > cos sin (+3) x
19:58:42 <cornihilio> Nereid, mm_freak: thank you so much for helping me understand those concepts!
19:58:43 <lambdabot>   cos (sin (x + 3))
19:58:54 <Nereid> cornihilio: no problem. just ignore what jmcarthur is doing here :O
19:59:01 <jmcarthur> yes, ignore me
19:59:11 <sayuke> Nereid: thats nice, i know what that extension actually does now, lol
19:59:17 <edwardk> cornihilio: the code that jmcarthur and i just wrote isn't generally legal, so ignore it ;)
19:59:17 <Nereid> sayuke: :)
19:59:36 <jmcarthur> it's perfectly legal... just requires instances not in the standard library
20:01:02 <Nereid> the point being there is some magic involved that you need to turn on for it to wkr.
20:01:08 <Nereid> work.
20:01:56 <jmcarthur> it's no more magical than any other Num instance
20:02:17 <Nereid> I'd guess that it looks like magic to him.
20:02:23 <jmcarthur> it might
20:02:28 <cornihilio> is there an easy way to 'delist' something? I have a [[]] that I want to concat into a []
20:02:31 <jmcarthur> i don't mean to push it as something for beginners
20:02:38 <Nereid> cornihilio: you said it
20:02:38 <Nereid> concat
20:02:39 <jmcarthur> cornihilio: concat?
20:02:48 <jmcarthur> :t concat
20:02:49 <Nereid> > concat [[1,2,3],[4,5]]
20:02:49 <lambdabot> forall a. [[a]] -> [a]
20:02:50 <lambdabot>   [1,2,3,4,5]
20:02:54 * applicative is having a little trouble following this instance. Or are there more than one involved in " cos sin x " -- x is an expression, sin :: Expr -> Expr, but by a function num instance cos is ( Expr -> Expr) -> ( Expr -> Expr)?
20:03:07 <jmcarthur> applicative: it's more than one
20:03:45 <Nereid> applicative: say sin :: Num a => a -> a. then we use the Num a => Num (a -> a) instance to get cos :: Num a => (a -> a) -> (a -> a)
20:03:48 <Nereid> except it's not Num.
20:03:51 <Nereid> it's whatever it is.
20:04:17 <Nereid> applicative: so, with these instances, cos sin = cos . sin
20:04:23 <jmcarthur> yeah i should say, it's one instance being used multiple ways
20:04:42 <Nereid> applicative: so, basically what you said is correct
20:04:43 <applicative> yeah I think I've sort of put it together
20:04:51 <jmcarthur> that last bit, cos . sin, is exactly because the instance lifts those functions using fmap
20:04:59 <jmcarthur> and fmap for functions is (.)
20:05:19 <Nereid> does NumInstances do it for any Functor, or just (->) t?
20:05:24 <jmcarthur> the latter
20:05:28 <Nereid> right
20:05:31 <jmcarthur> the pattern works for any Applicative
20:05:43 <Nereid> oh right, for binary functions.
20:06:00 <jmcarthur> and you need pure for fromIntegral
20:06:03 <jmcarthur> *fromInteger
20:06:26 <jmcarthur> and i suppose also things like pi
20:06:27 <Nereid> and integers are 0-ary functions right.
20:06:28 <Nereid> :P
20:06:31 <Nereid> or constants
20:06:34 <jmcarthur> > pi x
20:06:36 <lambdabot>   3.141592653589793
20:06:40 <jmcarthur> bah...
20:06:49 <Nereid> so it's what I meant to say.
20:06:53 <Nereid> Functor is enough to do it for unary functions
20:06:57 <jmcarthur> right
20:07:07 <Nereid> yeah.
20:07:16 <jmcarthur> it's a lovely instance
20:07:28 <jmcarthur> sin^2 + cos^2   just lovely
20:09:11 <jmcarthur> > map (sin^2 + cos^2) [0..10]
20:09:14 <lambdabot>   [1.0,1.0,1.0,0.9999999999999999,1.0,0.9999999999999999,0.9999999999999999,0...
20:09:29 <Nereid> @check (==) <$> sin^2 + cos^2 <*> 1
20:09:30 <lambdabot>   "Falsifiable, after 6 tests:\n1.3333333333333333\n"
20:09:35 <Nereid> augh.
20:09:39 <jmcarthur> float fail
20:09:42 <Nereid> yeah.
20:09:44 <jmcarthur> > map (sin^2 + cos^2) [0..10] :: [CReal]
20:09:46 <lambdabot>   [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0]
20:09:53 <Nereid> @check ((< 0.0001) . abs) <$> sin^2 + cos^2 <*> 1
20:09:54 <lambdabot>   Couldn't match expected type `a -> b'
20:10:02 <Nereid> eh
20:10:25 <jmcarthur> i wish it was as easy to lift (==) and (<) as it is the Num stuff
20:10:40 <jmcarthur> sin^2 + cos^2 == 1    would be nice
20:12:27 <Nereid> oh duh.
20:12:50 <Nereid> @check (< 0.0001) . abs $ sin^2 + cos^2 - 1
20:12:52 <lambdabot>   "*Exception: (==): No overloading for function
20:12:56 <Nereid> uh.
20:13:06 <Nereid> @check fmap ((< 0.0001) . abs) $ sin^2 + cos^2 - 1
20:13:08 <lambdabot>   "OK, passed 500 tests."
20:13:44 <Nereid> @check fmap ((< 0.000000001) . abs) $ sin^2 + cos^2 - 1
20:13:45 <lambdabot>  Terminated
20:13:51 <Nereid> !
20:13:54 <Nereid> @check fmap ((< 0.000000001) . abs) $ sin^2 + cos^2 - 1
20:13:56 <lambdabot>   "OK, passed 500 tests."
20:14:06 <Nereid> proof by quickcheck.
20:15:07 <byorgey> > (sin^2 + cos^2) 1.3333333333333333
20:15:08 <lambdabot>   0.9999999999999999
20:15:37 <Nereid> @let x =~= y = abs (x - y) < 0.00000001
20:15:39 <lambdabot>  Defined.
20:15:43 <Nereid> @check (=~=) <$> sin^2 + cos^2 - 1
20:15:44 <lambdabot>   can't find file: L.hs
20:15:45 <Nereid> @check (=~=) <$> sin^2 + cos^2 <*> 1
20:15:48 <lambdabot>   "OK, passed 500 tests."
20:17:28 <ParahSailin_> > cos 355
20:17:29 <lambdabot>   -0.999999999545659
20:18:35 <Nereid> > sin 355
20:18:36 <lambdabot>   -3.014435335948845e-5
20:18:52 <JoeyA> :t sin^2
20:18:54 <lambdabot> forall a. (Floating a) => a -> a
20:18:56 <Nereid> > sin 312689
20:18:57 <lambdabot>   2.900699389332111e-6
20:18:59 <JoeyA> :t (^)
20:19:00 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
20:19:07 <JoeyA> :t sin
20:19:09 <lambdabot> forall a. (Floating a) => a -> a
20:19:26 <JoeyA> Is sin^2 lambdabot syntactic sugar?
20:19:27 <Nereid> JoeyA: lambdabot has an instance Num a => Num (t -> a)
20:19:34 <JoeyA> oh
20:19:36 <Nereid> from NumInstances
20:20:00 <JoeyA> > 0 :: (a -> Int)
20:20:01 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Types.Int)
20:20:01 <lambdabot>    arising fro...
20:20:10 <Nereid> > 0 5
20:20:11 <lambdabot>   0
20:20:18 <Nereid> > 0 "bacon"
20:20:20 <lambdabot>   0
20:20:25 * hackagebot gitlib 0.4.0 - Higher-level types for working with hlibgit2  http://hackage.haskell.org/package/gitlib-0.4.0 (JohnWiegley)
20:20:27 * hackagebot general-prelude 0.1 - Prelude replacement using generalized type classes where possible  http://hackage.haskell.org/package/general-prelude-0.1 (JohnWiegley)
20:20:29 * hackagebot hsubconvert 0.0.1 - One-time, faithful conversion of Subversion repositories to Git  http://hackage.haskell.org/package/hsubconvert-0.0.1 (JohnWiegley)
20:20:29 <applicative> @check let (===) = liftA2 (=~=) in sin^2 + cos^2  ~=~ 1
20:20:31 <lambdabot>   Not in scope: `~=~'
20:20:40 <applicative> @check let (===) = liftA2 (=~=) in sin^2 + cos^2  === 1
20:20:41 <lambdabot>   No instance for (GHC.Num.Num (f a))
20:20:41 <lambdabot>    arising from the literal `2' at <int...
20:20:45 <applicative> grr
20:20:56 <Nereid> > 1 "pie" + 2 "bacon"
20:20:57 <lambdabot>   3
20:21:21 <Nereid> @let (===) = liftA2 (=~=)
20:21:22 <lambdabot>  Defined.
20:21:25 <Nereid> @check sin^2 + cos^2 === 1
20:21:26 <lambdabot>   No instance for (GHC.Num.Num (f a))
20:21:26 <lambdabot>    arising from the literal `2' at <int...
20:21:27 <Nereid> aw.
20:21:32 <Nereid> I wonder why.
20:21:48 <Nereid> wel.
20:21:49 <Nereid> l
20:21:55 <applicative> @check let  (===) = liftA2 (\x y -> abs (x - y) < 0.0001)  ; infixl 1 === ; in  (sin^2 + cos^2  === 1)
20:21:56 <lambdabot>   "OK, passed 500 tests."
20:22:24 <Nereid> @let (===) = liftA2 (\x y -> x =~= y)
20:22:25 <lambdabot>  <local>:6:0:
20:22:25 <lambdabot>      Multiple declarations of `L.==='
20:22:25 <lambdabot>      Declared at: <local>...
20:22:29 <Nereid> oh arh.
20:22:31 <Nereid> hhjjykj
20:22:53 <Nereid> @check let (===) = liftA2 (\x y -> x =~= y) in sin^2 + cos^2 === 1
20:22:53 <lambdabot>   No instance for (GHC.Num.Num (f b))
20:22:54 <lambdabot>    arising from the literal `2' at <int...
20:23:06 <Nereid> forget it.
20:23:07 <Nereid> :P
20:25:42 <cornihilio> hcan somebody help me figure this out? it's driving me nuts! I have a normal type declaration at the top, but for some reason it's expecting a [[a0]]?!?! https://gist.github.com/3846950
20:27:04 <Nereid> cornihilio: why do you have return there
20:28:04 <Nereid> cornihilio: also why are you concat'ing it in the first place
20:40:18 <tswett> You know, it seems like there aren't any dependently typed programming languages that are *just* programming languages.  All of them attempt to be theorem provers as well.
20:40:28 <tswett> Why is this?
20:40:42 <applicative> cornihilio: It does seem like just this is enough:  fromMaybe [] $ AL.maybeResult $ AL.parse (CA.many packetValue) p
20:40:53 <cornihilio> Nereid: two good points, I'll have to look into that
20:41:15 <applicative> tswett: I'm not sure there are enough implementations to gather statistics
20:42:15 <applicative> tswett: even if you're not interested in theorem proving in general, as I'm not, you might need a bit of it to do whatever you mean to do
20:42:24 <applicative> but I don't know
20:42:30 <cornihilio> applicative: thanks!
20:42:44 <Sculptor> so can i run a haskell interpreter on android
20:44:44 <donri> tswett: idris?
20:46:04 <Nereid> sometimes I wish $ associated to the left.
20:46:13 <Nereid> so I could write stuff like filter $ not . null $ some list
20:46:14 <Nereid> or whatever
20:46:14 <cornihilio> okay, I managed to get that fixed. however, I'm tryin to figure out what's going on by creating a value that holds the result, but for some reason that is causing an issue: https://gist.github.com/3847025. I don't get it, why would a <- statement cause a type error? shouldn't only returning statements do that?
20:46:32 <applicative> donri I was goinng to ask if tswett had tried idris
20:46:33 <tswett> donri: never heard of it.  Thanks.
20:46:48 <donri> although website says one of its features is "Tactic based theorem proving"
20:47:02 <donri> but it is specifically designed as a "systems PL"
20:47:13 <donri> OSLT
20:47:29 <tswett> So far, the syntax looks exactly like Haskell's except with : and :: swapped.
20:47:30 <Nereid> cornihilio: do you even understand what the do notation is doing there?
20:47:42 <rwbarton> why are you using do notation
20:47:48 <Nereid> ^
20:47:52 <applicative> in fact it does have fancy theorem proving ideas, but its supposed to be practical.  I wrote hello world in it!!
20:48:03 <applicative> never got that far in agda
20:48:48 <Nereid> cornihilio: removing line 3 would make it work, but you shouldn't do that unless you understand what's going on with the do notation
20:48:54 <Nereid> (in this case, it would be in the list monad)
20:48:59 <applicative> cornihilio: yes, LA.parse myparser myline returns a Result a , theres no need to think of a monad
20:49:06 <Nereid> yes
20:49:24 <rwbarton> cornihilio probably just wants "let { v = ...; r = ... } in r"
20:49:31 <Nereid> probably, yes.
20:49:41 <applicative> yes
20:49:47 <rwbarton> (and yes I see that v is unused so far)
20:52:15 <applicative> cornihilio: https://gist.github.com/3847032 maybe?
20:52:55 <cornihilio> I guess I do not understand how this ( fromMaybe [] $ AL.maybeResult ) does not require do notation but ( fromMaybe [] $ AL.maybeResult $ AL.parse (CA.many packetValue) p ) does
20:53:12 <applicative> as rwbarton says, the v isn't used; maybe this https://gist.github.com/3847032
20:53:15 <rwbarton> what do you mean "( fromMaybe [] $ AL.maybeResult $ AL.parse (CA.many packetValue) p ) requires do notation"
20:53:25 <cornihilio> sorry I meant AL.parse (CA.many packetValue) p for the first part
20:53:57 <cornihilio> well this works but I don't understand why: https://gist.github.com/3847035
20:54:09 <rwbarton> it works by coincidence
20:54:12 <rwbarton> just write:
20:54:23 <rwbarton> countPackets p = fromMaybe [] $ AL.maybeResult $ AL.parse (CA.many packetValue) p
20:54:28 <rwbarton>   where v = AL.parse (CA.many packetValue) p
20:54:41 <rwbarton> and don't worry about why the other thing also works
20:55:05 <cornihilio> but I'm using the do notation because I want to play around with the return value a bit; I don't understand attoparsec fully, so that's my main goal atm
20:55:11 <rwbarton> don't use do notation
20:55:12 <rwbarton> for this
20:55:15 <rwbarton> trust me :)
20:55:32 <cornihilio> but then how am I supposed to play around with the Result value?
20:55:44 <rwbarton> if you want to do stuff with the return value you can give it name in a where block or a let expression, like normal...
20:56:15 <cornihilio> https://gist.github.com/3847035 <- like that?
20:56:26 <rwbarton> no!
20:56:34 <cornihilio> so, no do at all?
20:56:38 <rwbarton> right1
20:56:38 <rwbarton> !
20:57:08 <tswett> I'm just curious: what is the type of fromMaybe [] $ AL.maybeResult $ AL.parse (CA.many packetValue) p?
20:57:20 <rwbarton> [Packet]
20:57:45 <rwbarton> cornihilio, you can use something like this that applicative pasted: https://gist.github.com/3847032
20:58:47 <applicative> cornihilio: I think I see the problem.  Parser is itself a monad, so you can use do notation with it  of course, but
20:59:30 <applicative> the role of 'parse' is to take you out of the monad, you just have a 'Result a' now, which is either Success [Packet] or some kind of failure
21:00:03 <applicative> but you are trying to put 'parse myparser mybytestring' inside the do block
21:01:21 <cornihilio> applicative: well I'm focusing on the failing case, since that's the one I'm the most interested in, and I thought that if I wanted to play around with partially parsed streams that would be done in a monad. Right now I'm kind of just operating under the assumption that state = needs to be in a do block.
21:01:28 <applicative> you can use 'myparser' inside the do notation -- to define a more complex parser.  but then you use parse outside the do notation to turn the parser into a function on ByteStrings
21:03:01 <cornihilio> applicative, rwbarton: thank you! you have made things much clearer for me
21:10:18 <p1key> hey im new to haskell and heard its really maths orientated, is that true?
21:12:43 <Jafet> Yes. Isn't that great?
21:12:49 <tswett> Eh... depends on what you mean by "maths-oriented", I guess?
21:13:21 <Tekmo> Haskell does general-purpose programming very well
21:23:45 * liyang isn't new to Haskell and thinks it's really computer-science-orientated, is that true?
21:25:22 * applicative thinks haskell is more lucidity oriented
21:35:50 * cmccann thinks Haskell is non-orientable in R^3, is that true?
21:36:14 <latro`a> bah, haskell's not embeddable in R^3 at all
21:36:25 <latro`a> it's only embeddable in the analysis superstructure, nothing smaller is sufficient
21:36:26 <latro`a> :p
21:36:34 <latro`a> (superstructures are freaking terrifying btw)
21:37:58 * cmccann doesn't know enough about topology or whatever to continue the joke, sorry :[
21:38:16 <latro`a> I pretty much escalated the joke as far as it goes
21:38:28 <latro`a> basically the superstructure in question contains every object that might ever come up in analysis ever
21:38:37 <latro`a> along with a vast infinity of other objects
21:38:39 <cmccann> ok, thanks
21:38:53 <latro`a> it's sometimes used to build up nonstandard analysis
21:39:02 <cmccann> that sounds moderately unpleasant
21:39:41 * VieiraN feels bad for not getting the joke
21:39:46 <latro`a> http://en.wikipedia.org/wiki/Non-standard_analysis#Approaches_to_non-standard_analysis
21:39:48 <cmccann> then again I never really enjoyed analysis or that entire branch of mathematics so eh
21:40:03 <latro`a> nonstandard analysis is much more fun than standard analysis imo
21:40:13 <latro`a> fewer quantifiers to keep track of, for one thing
21:42:37 <applicative> ah cmccann did you notice your (⊢) or Lin type is a category with the alleged forthcoming version of Control.Category?
21:43:15 <applicative> not sure how that would help exactly
21:43:22 <cmccann> well, of course it's a category
21:43:37 <cmccann> but I didn't know Control.Category was going to be changed?
21:43:43 <cmccann> making the kind polymorphic or something?
21:43:46 <applicative> of course, I was just noticing a remark that you cant declare it in Haskell
21:43:58 <applicative> right, edwardk claims so.
21:44:10 <cmccann> neat
21:44:22 <cmccann> and yeah, obviously the kind mismatch is the only problem
21:44:26 <edwardk> cmccann: i asked for it to be changed, and the response was positive, but i haven't seen the change go in
21:44:35 <applicative> i imported his "Cat k" which has the same definition, but kind polymorphism on.
21:44:58 <applicative> ah, maybe edwardk was more optimistic while writing indexed whatever ....
21:45:00 <edwardk> applicative: from indexed?
21:45:41 <applicative> yeah, since it was to hand I imported it to get a category instance, or Cat instance, to compile
21:46:10 <hpaste> applicative annotated “linear logic” with “linear logic (annotation)” at http://hpaste.org/75222#a75894
21:46:11 <byorgey> check it, sneak preview for #haskell: http://www.cis.upenn.edu/~byorgey/hosted/Factorization100.pdf
21:46:16 <byorgey> comments welcome =)
21:46:17 <edwardk> cmccann: where is your Lin type defined? is there a paste or hackage package?
21:46:30 <cmccann> edwardk, just http://hpaste.org/75222
21:46:34 <applicative> edwardk: I just repasted it
21:46:41 <edwardk> thx
21:46:44 <cmccann> oh, missed the repaste, heh
21:47:04 <cmccann> byorgey, oh man, that is lovely
21:48:14 <byorgey> cmccann: thanks =)
21:48:20 <edwardk> cmccann: hrmm. i suppose one could use the same trick i use in lens to just use a type alias and piggyback on the existing (.) and id for your linear stuff
21:48:33 * cmccann shrugs
21:48:33 <edwardk> though (.) composes backwards then like it does in lens
21:48:43 <cmccann> I'm not actually using that for anything
21:49:02 <cmccann> it was mostly an intuition-building exercise for linear logic
21:49:07 <edwardk> *nods*
21:49:25 <cmccann> the stuff I actually want to use linear logic for is more complicated and even less amenable to a Category instance, heh
21:49:38 <edwardk> sure =)
21:50:08 <cmccann> though I still wish I could figure out a clearly sensible way to add the exponentials to that encoding of linear logic
21:50:35 <edwardk> ah just noticed they were missing
21:51:08 <edwardk>  type x ⊸ y = Not x ⅋ y -- is a funny looking lollipop
21:51:33 <cmccann> everything else pretty much falls directly out from the types and making sure I use all variables linearly inside the definitions
21:51:44 <edwardk> its pretty clean
21:52:07 <edwardk> i may port a version of it into indexed as an example
21:52:27 <cmccann> and yeah, I had a "Loli" type at first then decided I was tired of writing out explicit definitions
21:53:06 <cmccann> anyway, if you can think of any similarly clean way to do exponentials I'd love to hear it
21:54:17 <cmccann> the fact that they're not uniquely determined by their behavior is probably not helping here
21:54:28 <cmccann> since that suggests there's no canonical way of doing it
21:55:02 <donri> what does Tekmo Mr. Category guy say about the proposed update to Category?
21:55:13 <Tekmo> Is this with kind polymorphism?
21:55:31 <edwardk> i would hope it should be entirely non-controversial
21:55:49 <donri> got a paste for the proposed version?
21:56:20 <edwardk> yeah
21:56:27 <edwardk> {-# LANGUAGE PolyKinds #-}
21:56:31 <edwardk> now paste the existing definition
21:56:34 <cmccann> heh
21:56:47 <edwardk> nothing changes
21:56:54 <donri> o_O
21:57:12 <edwardk> we're just asking the type system to infer a more general type than it would otherwise
21:57:33 <edwardk> if you import it in code without PolyKinds turned on, you get the old behavior, so nothing changes
21:57:42 <edwardk> it only helps folks who turn on polykinds themselves
21:57:44 <donri> ah
21:58:02 <donri> and presumably there'd be some CPP for portability?
21:58:04 <edwardk> but if that line _isn't_ present, then the Category class remains useless to polykinded code
21:58:07 <edwardk> yes
21:58:08 <edwardk> well
21:58:15 <edwardk> base is tied to a particular version
21:58:19 <edwardk> so no real need
21:58:40 <edwardk> other than for other compilers that might piggyback on base
21:59:08 <edwardk> so there was a #if defined(__GLASGOW_HASKELL__) && __GLASGOW_HASKELL__ > 706    around it in my proposal
21:59:14 <edwardk> er >=
22:04:10 <cmccann> edwardk, as an aside, the type I use for linear implication is essentially identical to that linear map type in your algebra package with twenty pages of instances
22:04:31 <edwardk> *nods*
22:04:40 <cmccann> since the quantifier over the result type is mostly cosmetic in my code
22:05:18 <edwardk> so now you need to sell the connection between the two forms of linearity ;)
22:05:40 <cmccann> well, I have no idea if there is any connection
22:05:58 <cmccann> but it did seem an amusing coincidence at least
22:07:03 <cmccann> it's pretty much "Kleisli Cont" which is pretty flexible by nature, heh
22:07:11 <Tekmo> cmccann: I have a question
22:07:17 <cmccann> 'sup?
22:07:21 <Tekmo> cmccann: So how did you envision building the Streams
22:07:29 <Tekmo> Using the Free monad converted to a Fix or using Step?
22:07:32 <cmccann> awkwardly
22:07:35 <Tekmo> lol
22:07:42 <cmccann> well
22:07:42 <lightquake> so here's a problem that i'm running into
22:08:02 <cmccann> problem is some things aren't very well-defined, or at least aren't very useful, on a half-built stream
22:08:08 <lightquake> in my game, the state of the entire world is captured in a World datatype, which has an [Entity] to represent all the monsters
22:08:51 <Lutin`> @hoogle [IO a] -> IO a
22:08:52 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
22:08:52 <lambdabot> Control.Exception.Base block :: IO a -> IO a
22:08:52 <lambdabot> Control.Exception block :: IO a -> IO a
22:08:53 <lightquake> i want monsters to be able to effect arbitrary change (by, say, creating more monsters or whatever), so each Entity has an aiUpdate :: World -> World
22:09:02 <Lutin`> Is IO a MonadPlus
22:09:25 <cmccann> but the basic intent is to build streams that have some sort of internal logic using the same stacking-up-layers Free-style approach pipes uses
22:09:26 <lightquake> the problem is, sometimes an aiUpdate will just update the characteristics of that particular monster, by moving its position or whatever, but that's not easy to express
22:09:52 <cmccann> then finalize them to get sealed streams (i.e. Free -> Fix)
22:09:54 <lightquake> i think this is a flaw in my 'aiUpdate' type, but I'm not sure what a good one would be
22:10:11 <Lutin`> lightquake: Have you tried the state monad?
22:10:32 <cmccann> and then combine those finalized streams to "wire things up"
22:10:35 <Lutin`> :i State
22:10:40 <lightquake> that doesn't really get me what i want
22:10:42 <Lutin`> @i State
22:10:42 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
22:10:47 <Lutin`> what am i doing
22:11:10 <Lutin`> So you have Entity
22:12:00 <Tekmo> cmccann: I understand.  So I basically just need to "liftF" your yield and await stuff to create the free monad syntax
22:12:08 <lightquake> right
22:12:43 <donri> Tekmo: hm given that proxies are parametrized by the initial argument, would perhaps Kleisli Proxy be any useful? *random newbie thought*
22:13:00 <cmccann> Tekmo, I kept tweaking the details of that which is why I don't have anything built that way in the snippet
22:14:26 <Lutin`> Wait so each entity has an aiUpdate?
22:14:31 <Lutin`> World -> World
22:14:34 <lightquake> yeah
22:14:46 <lightquake> because you might have one enemy that spawns zombies, one enemy that eats other enemies for health, etc
22:14:49 <Lutin`> can I just see the code?
22:14:50 <applicative> Lutin instance MonadPlus IO -- Defined in `Control.Monad.Trans.Error'
22:14:52 <lightquake> i guess what i could do is have aiUpdate :: (World -> Entity -> Entity, World -> World) that means 'the first element of the tuple specifies what to replace this entity with, the second element is a transformation on the world to be done afterwards'
22:15:00 <Lutin`> applicative: Thanks
22:15:12 <Tekmo> donri: The kleisli arrow is the central abstraction, sort of
22:15:17 <Tekmo> donri: The proxy type is just a bridge to that
22:15:19 <hpaste> Veinor pasted “entity” at http://hpaste.org/75895
22:15:24 <Lutin`> applicative: Or is there a better way to go from [IO a] to IO a
22:15:30 <lightquake> @hoogle sequence
22:15:31 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
22:15:31 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
22:15:31 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
22:15:32 <Lutin`> Maybe map >>
22:15:40 <Lutin`> Oh yeah that works I guess
22:15:42 <Lutin`> Cause
22:15:46 <Lutin`> m ()
22:15:51 <Lutin`> That's what I was looking for
22:16:02 <Lutin`> @hoogle [IO a] -> IO ()
22:16:03 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
22:16:03 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
22:16:03 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
22:16:06 <Lutin`> k
22:18:11 <lightquake> alternately, i might have aiUpdate :: Entity -> [Action] where data Action = ReplaceWith Entity | AttackPlayer AttackData | Spawn [Entity] | ...
22:18:20 <donri> Tekmo: i'm... not sure what you're saying there :)
22:18:27 <lightquake> and then performAction :: World -> Action -> World
22:18:45 <Tekmo> donri: So there are actually four categories that proxies align upon
22:18:52 <Tekmo> donri: All four categories share the same morphism shape
22:18:57 <Tekmo> donri: The same as the Kleisli category
22:19:07 <Tekmo> Something of the shape: a -> Proxy b c d e m r
22:20:46 <applicative> byorgey: your pictures put me in mind of a sentence from Frege's Grundlagen:  http://i.imgur.com/z7KvH.png
22:25:15 <hmmmm> hi, can anyone teach me how to dougie?  thanx in advance
22:26:15 <byorgey> applicative: nice
23:21:53 <Springwight> Can I ask a question about functional programming that's not about haskell?
23:22:00 * Springwight doesn't know where to ask these questions :(
23:22:09 <Springwight> it's a conceptual one and is also pretty easy.
23:22:55 <Cale> okay
23:23:31 <Springwight> oh
23:23:34 <Springwight> you're here again :P
23:23:38 <Springwight> lol sorry
23:23:46 <Springwight> didn't mean it like that
23:23:59 <Springwight> "Hello, how are you, our previous chat was very informative"
23:24:25 <Cale> :D
23:24:45 <Cale> Well, me and 890 other people who are apparently all bots or sleeping
23:25:06 <Springwight> Okay, this problem is pretty simple. You have a Stream that goes {{1, 2, 3}, {1, 2, 3}, {1, 2, 3}}
23:25:19 * BMeph quickly closes his eyes and practices: Zzzzzz
23:25:20 <Springwight> I want to pivot it so I have {{1, 1, 1}, {2, 2, 2}, ...}
23:25:30 <Robdgreat> Cale: or don't have anything meaningful to contribute ;)
23:25:38 <Springwight> In a totally lazy fashion
23:25:45 <Springwight> Without storing stuff
23:26:27 <Cale> The Haskell list library's transpose is probably about as lazy as you'll get.
23:26:40 <Springwight> Yeah, but I want an implementation since I'm not using haskell :P
23:26:46 <Springwight> is there one?
23:26:50 <Cale> transpose                :: [[a]] -> [[a]]
23:26:50 <Cale> transpose []             = []
23:26:50 <Cale> transpose ([]     : xss) = transpose xss
23:26:50 <Cale> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) :
23:26:50 <Cale>                            transpose (xs : [t | (h:t) <- xss])
23:26:57 <BMeph> There are at least two! ;)
23:27:12 <Cale> Actually, now that I think of it
23:27:31 <Cale> Wasn't there some chatter about something even lazier than this or something?
23:27:52 <Ralith> what's #const?
23:27:53 <Cale> transpose               :: [[a]] -> [[a]]
23:27:53 <Cale> transpose []             = []
23:27:53 <Cale> transpose ([]   : xss)   = transpose xss
23:27:53 <Cale> transpose ((x:xs) : xss) = (x : [h | (h:_) <- xss]) : transpose (xs : [ t | (_:t) <- xss])
23:27:54 <Springwight> okay can you explain it in words :(
23:28:07 <Cale> okay
23:28:20 <Cale> So the transpose of an empty list is the empty list
23:28:41 <Cale> The transpose of a list of lists whose first element is empty is the transpose of the tail of that list.
23:29:34 <Springwight> oh
23:29:45 <Springwight> I need to execute tail on the inner sequence
23:29:57 <Cale> yeah, but there's a subtlety here
23:30:14 <Cale> (h:_) <- xss in the list comprehension will only match nonempty lists in xss
23:30:29 <Cale> so it's also implicitly filtering out the empty lists in xss
23:30:35 <Springwight> nice
23:30:50 <Cale> and same goes with the tails
23:31:24 <Springwight> I guess it's not possible without a Tail operation
23:32:10 <Cale> But you can do that list comprehension lazily
23:32:29 <BMeph> Cale: splitAt 1 and a lot of concats could work, too, right? :)
23:32:36 <Springwight> Yeah but I forgot I don't have a tail operation
23:32:40 <Springwight> ahhhh
23:33:03 <Cale> BMeph: hmm...
23:33:15 <Cale> BMeph: like a map (splitAt 1) ?
23:33:21 <Cale> errrr...
23:33:41 <Springwight> I can do something like that but it would be terrible.
23:33:44 <Cale> and an unzip, perhaps
23:34:02 <Springwight> I'll have to use mutable state because my sequence type sucks and doesn't have Tail.
23:34:03 <BMeph> Cale: Right. then unzip, and concat the first part, and recurse on the second.
23:34:10 <Cale> yes :)
23:34:29 <Springwight> And any take 1/split 1 operation takes ages
23:34:59 <BMeph> Heh-heh, "I'll have to use mutable state because my sequence type sucks and doesn't have Tail." - now you have two problems... ;)
23:35:25 <Cale> > let tr [] = []; tr ([] : xss) = tr xss; tr ((x:xs):xss) = (x : ys) : tr yss where (ys,yss) = unzip (map (splitAt 1) xss) in tr [[1,2,3],[],[4,5],[6,7,8,9],[10]]
23:35:26 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
23:35:31 <Cale> oops
23:36:06 <BMeph> Cale: concat ys? ;)
23:36:17 <Cale> > let tr [] = []; tr ([] : xss) = tr xss; tr ((x:xs):xss) = (x : concat ys) : tr yss where (ys,yss) = unzip (map (splitAt 1) xss) in tr [[1,2,3],[],[4,5],[6,7,8,9],[10]]
23:36:18 <lambdabot>   [[1,4,6,10],[5,7],[8]]
23:36:20 <Cale> yes
23:36:35 <Cale> > transpose [[1,2,3],[],[4,5],[6,7,8,9],[10]]
23:36:36 <lambdabot>   [[1,4,6,10],[2,5,7],[3,8],[9]]
23:36:38 <rwbarton> poor 9 :(
23:37:16 <Cale> lol
23:37:29 <BMeph> tr (xs:yss)?
23:37:45 <Cale> > let tr [] = []; tr ([] : xss) = tr xss; tr ((x:xs):xss) = (x : concat ys) : tr (xs:yss) where (ys,yss) = unzip (map (splitAt 1) xss) in tr [[1,2,3],[],[4,5],[6,7,8,9],[10]]
23:37:47 <lambdabot>   [[1,4,6,10],[2,5,7],[3,8],[9]]
23:37:58 <Cale> derp derp hooray
23:38:05 <Cale> lol
23:38:07 * BMeph does the Kirby dance...
23:38:52 <VieiraN> Looks like wizardry
23:39:00 <Cale> @check let tr [] = []; tr ([] : xss) = tr xss; tr ((x:xs):xss) = (x : concat ys) : tr (xs:yss) where (ys,yss) = unzip (map (splitAt 1) xss) in \xss -> tr (xss :: [[Int]]) == transpose xss
23:39:04 <lambdabot>   mueval-core: Time limit exceeded
23:39:07 <Cale> :(
23:39:36 <cmccann> pf, so much for "100% loyal"
23:39:48 <Cale> okay, did it locally and it passed a few hundred tests
23:40:03 <Cale> Maybe I should try again
23:40:05 <Cale> @check let tr [] = []; tr ([] : xss) = tr xss; tr ((x:xs):xss) = (x : concat ys) : tr (xs:yss) where (ys,yss) = unzip (map (splitAt 1) xss) in \xss -> tr (xss :: [[Int]]) == transpose xss
23:40:09 <lambdabot>   "OK, passed 500 tests."
23:40:21 <Cale> Okay, just a random blip
23:40:26 <Cale> (hopefully!)
23:42:22 <Cale> > take 10 . map (take 10) . transpose $ [[n + m | m <- [0..]] | n <- [0..]]
23:42:24 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,...
23:42:43 <Cale> > let tr [] = []; tr ([] : xss) = tr xss; tr ((x:xs):xss) = (x : concat ys) : tr (xs:yss) where (ys,yss) = unzip (map (splitAt 1) xss) in take 10 . map (take 10) . tr $ [[n + m | m <- [0..]] | n <- [0..]]
23:42:45 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,9,10],[2,3,4,5,6,7,8,9,10,11],[3,4,...
23:44:22 <lightquake> so i'm working on a roguelike, and right now i have a datatype World that holds all the Entities, and each Entity has an aiUpdate :: Entity -> Entity function that produces a list of Actions; each Action is something like SelfUpdate (Entity -> Entity) | Spawn [Entity] | Die | DoAttack AttackData
23:45:29 <Cale> lightquake: do you mean aiUpdate :: Entity -> [Action] ?
23:45:37 <lightquake> er, yes
23:46:07 <lightquake> the problem is, i'm not sure how to make sure that the SelfUpdate actions get 'applied' to the right Entity
23:46:27 <Cale> What if you did away with it?
23:46:31 <Cale> :)
23:46:43 <lightquake> well, sure :) but i'm not sure what to replace it with
23:46:43 <Cale> and also Die
23:46:59 <Cale> and made entities spawn their future selves
23:47:18 <lightquake> ... that's an interesting idea
23:47:42 <Cale> Then the world update, at least as far as entities go, is a concatMap
23:47:47 <lightquake> so the 'do-nothing' aiUpdate is just aiUpdate ent = Spawn [ent]?
23:47:56 <Cale> yes
23:47:59 <lightquake> well, [Spawn [ent]]
23:48:03 <Cale> right
23:48:31 <lightquake> nice
23:49:34 <lightquake> and then somewhere i have a processAction :: Action -> World -> World and then updateWorld = foldr processAction
23:50:09 <lightquake> (one thing i omitted is that aiUpdate has to get the World so it can know where the player is, but that doesn't really change things)
23:50:48 <Jupiter123> Hi guys
23:50:54 <Cale> hello
23:50:56 <Jupiter123> How long will it take to learn Haskell
23:51:21 <rwbarton> roughly 7.23 seconds
23:51:45 <Cale> Jupiter123: depends on how well you want to know it -- it took me about 2 months before I felt like I could be productive with it and about a year to be comfortable
23:52:01 <lightquake> i had about cale's experience
23:52:01 <Cale> But some people will go faster or slower of course
23:52:21 <Jupiter123> Sure 2 months? buddy
23:52:37 <Jupiter123> Since, my question is bit ironical I know
23:52:39 <lightquake> also, i assume for logging i'd do all that in the updateWorld loop (since that'd be running in IO)
23:52:53 <Jupiter123> Since my company projects deals mostly with python
23:53:18 <Jupiter123> and I if I start learning Haskell my Director will kill me :) But yet I want to learn Haskell
23:53:22 <Jupiter123> so is the question
23:54:08 <Cale> Jupiter123: It's not something you can just pick up in a weekend if you've never done any pure functional programming before. Maybe if you already know OCaml or something, it might be a somewhat easier transition...
23:54:35 <Cale> But you're talking about relearning how to write programs, to a fair extent.
23:54:39 <Jupiter123> No I haven't been through OCaml indeed, I know bit of Python and RUby
23:54:55 <Cale> Haskell makes Python and Ruby seem almost identical
23:55:17 <lightquake> actually, i just realized that i wanted to use this as an excuse to learn FRP. maybe i should actually look into that sometime
23:55:30 <Jupiter123> I am going through HAskell right now, But seams quite I don't know how to describe, bit worried should I go for it and make my self productive soon
23:56:15 <Jupiter123> so that I don't have to make my Director uncomfortable shifting the backend of his project
23:56:32 <Cale> Jupiter123: My advice would be to learn Haskell in your spare time, and as far as work goes, perhaps you'll see ways to apply the ideas from Haskell to how you think about the programs in your day job.
23:56:34 <Jupiter123> I want to show him that Haskell works
23:57:21 <lightquake> hm. one thing i realized is that this design makes it impossible for an entity to have a persistent reference to 'that other entity'
23:57:28 <Cale> But if you don't know Haskell, it's like learning to program for the first time (in some cases worse than that because you have unlearning of old habits to do :)
23:57:30 <Jupiter123> How long will it take even If I work in spare time to be productive
23:57:56 <Jupiter123> "Empty the cup" isn't? :D
23:57:59 <Cale> Jupiter123: At the time I learned Haskell, I had a full course load of mathematics courses, so it's not like I was spending all my time on it
23:58:20 <Jupiter123> How often you worked than to learn it'
23:58:42 <Cale> I don't recall exactly... this was about 10 years ago
23:58:45 <Jupiter123> Because, I need to keep this motivation to learn
23:58:55 <Cale> actually pretty much 11 now
23:58:56 <Jupiter123> 10 years wow
23:58:57 <Jupiter123> :D
23:59:43 <Jupiter123> I was thinking to dedicate whole my time to haskell and be serious on to become productive as early as possible
23:59:57 <Jupiter123> what's your suggestion
