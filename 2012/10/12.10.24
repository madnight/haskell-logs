00:00:09 <Cale> or give a name to the value that you're going to print
00:00:20 <neworder> Ah I see
00:00:38 <neworder> module Main where
00:00:40 <neworder> f=f in if 1>0 then 1 else f 0
00:00:44 <neworder> Why doesn't this parse
00:01:00 <Cale> because you left in the 'in' which belonged to the 'let' which you removed
00:01:11 <Cale> module Main where
00:01:13 <Cale> f = f
00:01:21 <Cale> x = if 1 > 0 then 1 else f 0
00:01:25 <Cale> main = print x
00:02:19 <Cale> You can also leave out the module declaration
00:02:29 <Cale> modules without a module declaration are named Main by default
00:03:09 <Cale> (and giving your main module another name will only make life hard)
00:03:39 <Cale> (i.e. you'll need an extra compiler flag to say what the main is)
00:03:57 <Cale> shachaf: Which sum type?
00:04:08 <neworder> Hmm I see, thanks
00:04:17 <Ghoul> Is there a lazy list that automatically unloads elements when they aren't used for a while?
00:04:31 <Cale> Ghoul: no
00:04:35 <Ghoul> used for ie: game region storage in a chunk-based game :|
00:04:36 <Ghoul> ah.
00:04:48 <Cale> Ghoul: I've actually thought that such a structure would be interesting to have before
00:05:16 <Ghoul> One where you could set a time limit before unload or something
00:05:17 <Cale> More likely for a single value as a primitive
00:05:20 <shachaf> Cale: They had something like data Foo = NormalException Exception | OurThing Signal
00:05:24 <Ghoul> and then its members would be available to the GC for unloading
00:05:28 <Ghoul> when the GC gets around to it
00:05:53 <shachaf> Presumably the point of the new mechanism is that this sort of sum type is not needed.
00:06:01 <shachaf> This isn't especially complicated, it just annoys me. :-)
00:06:12 <Cale> shachaf: Well, if you really want to get rid of it, you probably can.
00:06:18 <Jafet> Ghoul: you can implement this with weak pointers.
00:06:26 <shachaf> Cale: I think it's more complicated not to get rid of it.
00:06:29 <Cale> shachaf: Make Signal an instance of Exception directly
00:06:38 <shachaf> Right, I did that anyway.
00:07:05 <shachaf> Cale: Anyway, you have the lambdabot code. Comment out every line that imports "OldException" and you'll have the same errors. :-)
00:07:19 <Ghoul> Jafet: ?
00:07:32 <Cale> The only tricky thing will be splitting up the catches. You might want to keep Foo around, and make it an instance of Exception in a more interesting way.
00:08:11 <Cale> So that when you catch a value of type Foo, it separates the Signal case for you :)
00:08:29 <Jafet> Ghoul: ¿
00:08:39 <dmwit> Jafet: Cool. I knew the term, but had never bothered to read about them before.
00:08:52 <Ghoul> I guess I could use weak pointers
00:09:05 <Ghoul> But I would have to write the automatic unloading detection in haskell
00:09:50 <Cale> To do that, you'd write...
00:10:34 <dmwit> Ghoul: That's what the finalizers are for, I guess.
00:11:30 <Ghoul> dmwit: I think the problem would be that
00:11:47 <Ghoul> I still have to unload them manually
00:11:52 <Ghoul> for the finaliser to get called
00:11:55 <Ghoul> unless I'm missing something
00:12:48 <hpaste> Cale pasted “Sum instance” at http://hpaste.org/76687
00:12:53 <Cale> shachaf: ^^
00:14:23 <Cale> shachaf: That'll let values of type Foo be thrown and caught, but when thrown, they'll be thrown as the basic types involved, and catching a Foo will catch any exception, but will tag it in the case that it's a Signal.
00:15:44 <shachaf> Cale: You should rather give this advice to gienah. :-)
00:16:19 <Cale> oh
00:16:25 <Cale> gienah: are you here?
00:16:50 <gienah> Cale: yeah
00:17:16 <Cale> shachaf: Anyway, this is something I like about the new exception system -- it's easy to come along and add your own new types of exceptions and provide all the semantics for what throwing and catching them means.
00:17:42 <Cale> gienah: Okay, so shachaf and I were talking about the exception stuff in lambdabot
00:18:01 * gienah just came back from a run covered in sweat
00:18:19 <Cale> gienah: If you want I can perhaps help you get un-stuck with whatever problems you're having.
00:19:11 <gienah> Cale: thanks thats a really neat offer, but I'm too busy now, I could try again in mid nov
00:19:50 <Cale> ah, okay
00:20:02 <shachaf> Cale: You could also `cabal unpack lambdabot; vim $(rgrep OldException *)`
00:21:42 * gienah needs a shower, back in a little while
00:21:52 <Cale> shachaf: and this would tell me where lambdabot uses OldException, but then someone needs to go and fix it up and work through the compiler messages :)
00:22:07 <shachaf> Cale: Right. That's the part I don't want to do.
00:22:19 <Cale> I'm happy to help with that, but I don't have any immediate need for building lambdabot on 7.6
00:22:32 <shachaf> I don't either, given that I don't run lambdabot.
00:22:33 <Ghoul> Cale: what about mmap
00:22:33 <Cale> (and I don't even have 7.6 installed)
00:22:43 <Ghoul> Someone once said memory mapping would work but i never understood
00:22:47 <shachaf> Cale: It would be nice if you upgraded to 7.4 so we could use lens.
00:23:12 <Cale> shachaf: Yeah, I actually had forgotten that I have a local copy of lambdabot on my machine which is on 7.4
00:25:59 * hackagebot Semantique 0.2.2 - Command-line tool for maintaining the Semantique database.  http://hackage.haskell.org/package/Semantique-0.2.2 (DavidHimmelstrup)
01:16:40 <newOne31> Hello! There someone whom can i ask about haskell? (couple of questions)
01:18:52 <ehamberg> you don't have to ask to ask. just ask! :-)
01:20:01 <newOne31> I have program that provides for user information. For example there are func1 and func2. I need to implement access rights(for example user1 can not use func1, but can use func2), with minimal changes in code and clear logic.
01:21:14 <newOne31> how i can do that? where i can read about typical solutions?
01:24:48 <merijn> newOne31: How do you authenticate users? i.e. how do you know which user is running the code?
01:31:08 <newOne31> It is for example. At this moment i use php, but i really want to understand how i can (or  not) do the same with haskell.  So i get over http sid, then check if it is in sessionCache on the server.
01:32:39 <newOne31> * i had think like this: in haskell this will be nice, this perfect... acess rights - hm how?
01:33:06 <dmwit> Are you asking for the type system to statically guarantee access rights?
01:33:28 <dmwit> If so, that's very hard; if not, you do it the same way in Haskell that you did it in PHP (that is, by checking whether the user is allowed to run a function before you run it).
01:34:10 <newOne31> and especially - if i will change logic, how much code i will need to change?
01:34:26 <zomg> dmwit: so that would actually be doable but very hard? Interesting =)
01:35:17 <newOne31> it is not about "statically guarantee access rights", can you write example?
01:36:11 <dmwit> An example? Sure.
01:36:34 <dmwit> data Action = Action { permissions :: User -> Bool; action :: IO () }
01:36:57 <dmwit> checkAndRun act user = when (permissions act user) (action act)
01:37:35 <dmwit> (in case it's not immediately clear, perhaps because you are new to Haskell... ;-) checkAndRun :: Action -> User -> IO ()
01:37:39 <osfameron> so each action has its own permissions hash?
01:37:47 <dmwit> Sure, why not.
01:37:52 <shachaf> "hash"
01:38:19 <dmwit> zomg: I don't know whether it's possible. I just know that if it is possible, it's very hard.
01:38:33 <osfameron> map/dict, I'm still using Perl terminology...
01:40:05 <zomg> dmwit: ok :D
01:40:51 <zomg> I could sort of see it done using some sort of trickery with types yeah but not entirely sure how to implement it in practice
01:41:22 <newOne31> is it right - all code that runs func1 will now run check And Run with func 1 as parameter?
01:42:20 <osfameron> presumably the backend could still run func1 without checking the user
01:42:54 <dmwit> You can easily write a don'tCheckAndRun as well, of course.
01:42:58 <dmwit> don'tCheckAndRun = action
01:43:27 <dmwit> or perhaps don'tCheckAndRun act user = action act -- if you want to have the same type as checkAndRun
01:44:16 <newOne31> i mean something else. I think that it is bad idea, there are no way to check it "inside" func1? or it is OK?
01:45:10 <newOne31> this solution mean that i need to check whole code, whole modules and etc.
01:45:42 <dmwit> You can certainly embed the check inside the action if you prefer that.
01:45:51 <osfameron> that would couple it really tightly though
01:46:00 <dmwit> But really, these questions are so vague as to be meaningless.
01:46:03 <osfameron> if you then want your backend to call that code, you'll have to *fake* a user
01:46:28 <osfameron> newOne31: you might want to look at a haskell web framework like Snap, and see how they recommend structuring an application?
01:48:04 <newOne31> 2osfameron okay
01:51:01 * hackagebot syntactic 1.5.1 - Generic abstract syntax, and utilities for embedded languages  http://hackage.haskell.org/package/syntactic-1.5.1 (EmilAxelsson)
01:51:33 <newOne31> can you advise some books not about coding haskell, but about understanding how it works? because for me it is something like thinking in the opposite way.
01:52:25 <dmwit> ?where stg
01:52:25 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
01:53:20 <dmwit> http://blog.ezyang.com/2011/04/the-haskell-heap/ maybe
01:53:45 <dmwit> ?google tackling the awkward squad
01:53:46 <lambdabot> http://research.microsoft.com/~simonpj/papers/marktoberdorf/mark.pdf.gz
01:54:03 <shachaf> Oops.
01:54:12 <shachaf> I did cabal install --force-reinstalls despite repeated warnings not to.
01:54:17 <shachaf> Now my cabal is broken.
01:54:24 <shachaf> I blame you, #haskell.
01:54:31 <osfameron> newOne31: have you already looked at LYAH?
01:54:37 <dmwit> I'm mildly amused that Tackling the Awkward Squad's filename is mark.pdf
01:54:43 <osfameron> that is about coding haskell, but it does kinda explain how it works
01:55:21 <dcoutts_> shachaf: it's not really a problem, you can still tell cabal what you want to be installed and it'll install things as appropriate. Having broken packages around isn't in itself a big problem.
01:55:39 <dmwit> If you're into that kind of thing, we can point you at more "how does type inference stuff work" kind of papers, though I'm pretty sure that's not what you're asking about. (?)
01:55:50 <shachaf> dcoutts_: Right, I just unregistered it and it seems to be working.
01:57:02 <dmwit> dcoutts_ is so nice. He writes little messages to you saying "if you do this, you get to keep both pieces", and then when you do that anyway he even tells you how to put the pieces back together.
01:57:50 <dcoutts_> :-)
01:58:35 <shachaf> The thing I force-reinstalled was process-1.1.0.2
01:58:56 <newOne31> LYAH - it is this http://learnyouahaskell.com/ ?
01:59:11 <Nereid> yes
01:59:36 <dmwit> The standard tutorials are:
01:59:37 <dmwit> ?where lyah
01:59:37 <lambdabot> http://www.learnyouahaskell.com/
01:59:39 <dmwit> ?where rwh
01:59:39 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
01:59:41 <dmwit> ?where gentle
01:59:41 <lambdabot> http://www.haskell.org/tutorial/
02:00:42 <newOne31> thank you
02:01:01 * hackagebot aeson-lens 0.2.0.0 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.2.0.0 (HideyukiTanaka)
02:02:45 <shachaf> Hmm, that's the first standalone lens package I've seen.
02:02:52 <shachaf> -fno-warn-orphan-lens
02:11:09 <dncr> a good read: http://stackoverflow.com/questions/9952602/does-haskell-require-a-garbage-collector
02:21:00 <Lemmih> dncr: I'm not sure why someone would believe that purity means that you don't need a GC.
02:22:11 <dncr> Lemmih: mm.  I'm more interested in why GC is better in haskell than other kinds of automatic memory management.
02:22:52 <merijn> No language requires a GC provided you have sufficient memory ;)
02:23:56 <dncr> I'm sure it's a naive question, but why not just deallocate things the moment they are no longer needed?
02:24:07 <Lemmih> dncr: What other kinds of automatic memory management is there?
02:24:38 <merijn> dncr: Isn't that what "garbage collection" means?
02:24:40 <dncr> Lemmih: I've read briefly about region inference, and https://en.wikipedia.org/wiki/RAII
02:24:43 <Lemmih> dncr: That is also a form of garbage collection.
02:25:28 <dncr> Lemmih: Maybe my term is off.  By "GC" I mean a system where you periodically look for memory you can free.
02:25:30 <merijn> dncr: That's just one specific form of garbage collection
02:25:46 <merijn> dncr: Region inference still has to do that
02:25:54 <dncr> The garbage collector, or just collector, attempts to reclaim garbage, or memory occupied by objects that are no longer in use by the program.
02:26:07 <dncr> Maybe there are multiple meanings of GC.
02:26:13 <Lemmih> dncr: Ah, so you're asking why reference counting isn't used?
02:26:23 <merijn> dncr: Take a look at the second example of region inference in the first answer
02:26:38 <Lemmih> dncr: Some languages keep a counter of references and delete objects once nothing points to them any more.
02:26:53 <Lemmih> dncr: But that approach is fairly slow and has other drawbacks.
02:27:09 <quicksilver> counter-intuitively, referencing counting is actually slower than a periodic "sweep" kind of GC
02:27:09 <dncr> Lemmih: mm, so it mostly ends up being slow?
02:27:13 <merijn> dncr: Region inference says it's safe to deallocate x2 when g returns, but then the question is how do you check whether g has finished? Insert an explicit check in g? If so then you have to do the same for every other function that keeps f
02:27:21 <dncr> quicksilver: right.  that seems crazy to me
02:27:30 <quicksilver> dncr: you need to store all those reference counts
02:27:30 <merijn> quicksilver: "Given some set of constraints"
02:27:34 <shachaf> One reference! Ah-ah-ah-ah-ah!
02:27:37 <dncr> quicksilver: true
02:27:39 <quicksilver> and update them.
02:27:40 <shachaf> Two references! Ah-ah-ah-ah-ah!
02:27:55 <quicksilver> languages like LISP and haskell and ML allocate a lot of tiny bits of memory
02:28:04 <quicksilver> managing refcounts for all of them is a massive overhead.
02:28:21 <guest11122223> @let obfuscate = (pl . unpl . pl . unpl . pl . unpl)
02:28:23 <lambdabot>  <local>:1:13: Not in scope: `pl'
02:28:23 <lambdabot>  
02:28:23 <lambdabot>  <local>:1:18: Not in scope: `unpl'
02:28:23 <lambdabot>  
02:28:23 <lambdabot>  <l...
02:28:38 <quicksilver> "static reference counting" approaches are very promising but require hard compiler work
02:28:44 <guest11122223> @pl f x y = map x (f y)
02:28:45 <lambdabot> f = fix (flip ((.) . map))
02:28:48 <MostAwesomeDude> quicksilver: It *really* depends on the refcounting style and GC style. Python's a fun example.
02:28:50 <quicksilver> becausey ou don't actually need to store the refcounts, you infer them at compile time.
02:28:56 <guest11122223> @pl f x y = map x (f y)
02:28:57 <lambdabot> f = fix (flip ((.) . map))
02:29:08 <quicksilver> like region analysis.
02:29:23 <quicksilver> but it can never work for all cases and mkaing it work for enough interesting cases turns out to be a hard problem.
02:29:29 <merijn> dncr: Another thing is (as the SO answer covers) is that region analysis is apparently tricky in a lazy setting
02:29:50 <quicksilver> MostAwesomeDude: fun in what way?
02:29:52 <dncr> merijn: right
02:29:57 <merijn> MostAwesomeDude: Python allocations are very different from haskell, though
02:30:12 <quicksilver> MostAwesomeDude: you mean python is so slow than the difference between a fast GC and a slow GC is irrelevant, the bottleneck is the badly written runtime?
02:30:15 <MostAwesomeDude> quicksilver: Well, "fun".
02:30:15 <quicksilver> *duck*
02:30:17 <merijn> Python can get away with allocating lots of stuff on the stack and using that for GC
02:30:30 <MostAwesomeDude> quicksilver: Someday, look at PyPy. Just for "fun."
02:30:34 <MostAwesomeDude> merijn: Right.
02:31:22 <nikita-0> Are cyclic structures (in the sense of reference counting) possible in Haskell?
02:31:29 <merijn> nikita-0: Sure
02:31:46 <quicksilver> MostAwesomeDude: interesting.
02:31:46 <merijn> > let ones = 1 : ones in ones
02:31:48 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:32:00 <shachaf> merijn: That probably never gets GCed. :-)
02:32:07 <merijn> shachaf: Sure it does
02:32:16 <shachaf> Well, not if it's top-level.
02:32:29 <merijn> shachaf: You can't GC top level definitions anyway...
02:32:50 <shachaf> Yes, I'm not sure what my point was, actually.
02:32:58 <nikita-0> merijn: I see thanks, and probably a compiler creates a bunch of them internally behind the scene.
02:32:58 <merijn> Determining whether you will ever need a top level definition in the future is equivalent to the Halting problem...
02:33:09 <dncr> Is the "long pause problem" of GC Haskell's bane the way that the global interpreter lock is for python?
02:33:15 <shachaf> merijn: That's true for more than top-level definitions...
02:33:26 <shachaf> merijn: Lots of things GHC does are equivalent to the halting problem in the general case.
02:33:36 <merijn> shachaf: Sure, being top-level is sufficient, but not necessary :)
02:33:43 <dncr> Sorry, the "pause time problem" at http://www.haskell.org/pipermail/glasgow-haskell-users/2012-March/022142.html
02:33:51 <randomclown> what's the best way to delete a list of keys from a Data.Map
02:34:13 <merijn> nikita-0: Actually that just allocates one integer and one list constructor (plus some boxing)
02:34:33 <merijn> randomclown: Fold over the list with the map as accumulator and delete as folding function?
02:34:44 <shachaf> @ty (M.\\)
02:34:46 <lambdabot> forall k a b. (Ord k) => M.Map k a -> M.Map k b -> M.Map k a
02:34:47 <shachaf> Hmm, not quite.
02:35:09 <merijn> Actually, map difference might be better, yeah
02:35:41 <merijn> Something like "map \\ fromList (zip keyList (repeat ()))"?
02:35:43 <nikita-0> merijn: yes, I understand. I meant that compiler can generally create cyclic structures internally even when language level construct is not cyclic.
02:36:46 <dncr> I guess using Haskell for hard real-time programming is hard.
02:36:59 <randomclown> ah well close enough, somehow I skimmed over the \\ operator
02:37:05 <shachaf> On the other hand, using Haskell for hard-time programming is real.
02:37:26 <merijn> :t foldr Data.Map.delete undefined
02:37:27 <lambdabot> forall a a1. (Ord a) => [a] -> M.Map a a1
02:37:29 <ivanm> shachaf: "hard time programming" == "programming whilst in jail"?
02:37:35 <Eduard_Munteanu> @hackage atom
02:37:35 <lambdabot> http://hackage.haskell.org/package/atom
02:37:59 <quicksilver> merijn, shachaf : determining whether you need a top-level definition again is not equivalent to the halting problem, and top-level definitions do indeed get GCed as far as I know
02:38:03 <merijn> dncr: I think using any language with dynamic memory management is hard for hard real-time
02:38:07 <quicksilver> although, not in ghci I think
02:38:18 <merijn> quicksilver: It's impossible in the general case
02:38:29 <dncr> Mm.  Another problem I've run into is wanting to load something huge into memory.  Like wanting to make a big tree and just freeze it to disk and get it back later.
02:38:34 <merijn> quicksilver: Detecting simple cases is trivial, obviously
02:38:50 <quicksilver> merijn: what you're saying applies to all GC, top-level or not
02:38:58 <quicksilver> top-level definitions aren't special in any way.
02:39:00 <killy9999> I have a question about conventions used when creating Haskell libraries
02:39:06 <dncr> I guess your typical Haskell data structure is all over the place in memory.
02:39:24 <killy9999> if I have some C sources included in my lib is it more common to create a separate source dir for them
02:39:32 <dncr> So if you want something quick-freezable you have to stick to specific data structures.
02:39:44 <killy9999> or are they just placed in the same drectories as .hs files?
02:39:47 <merijn> dncr: Have you looked at Habit? That might be more amenable to hard realtime, if it's not vaporware
02:40:04 <killy9999> I know that both apporaches work
02:40:21 <killy9999> I just don't know which one is more often used or regarded as better
02:40:33 <merijn> dncr: It's a strict Haskell dialect with first class memory areas (so you can do statically checked manual memory management)
02:40:36 <dncr> merijn: I'll check it out
02:40:42 <dncr> oooh
02:40:56 <merijn> dncr: http://hasp.cs.pdx.edu/
02:46:07 <quicksilver> merijn: basically, reachability is tracked for code as well as data; so top-level definitions can be GCed when all the functions which use them are no longer reachable.
02:46:17 <dncr> does GHC have a stack and heap?  or is everything heap?
02:46:21 <quicksilver> merijn: (but, this is the same for non-top-level things too....)
02:46:34 <shachaf> dncr: Those words mean other things than what you think they mean.
02:47:00 <quicksilver> the answer you hope for might be "everything is heap" although as shachaf says, the analogy with a C memory model is not really clear
02:48:06 <shachaf> For example, heap allocation is really cheap, more or less incrementing a pointer. This is another one of those things you can get with some types of GC.
02:48:34 <shachaf> GHC has a "stack" but it's used for a different thing from what most languages use "the stack" for.
02:48:52 <dncr> shachaf: what is GHC's stack used for?
02:49:39 <dncr> i know there's the -K argument to the run time system
02:49:44 <shachaf> dncr: Thunks that are being evaluated.
02:49:54 <dncr> ok
02:50:29 <dncr> the stack is for function calls in C and for thunk evaluations in GHC.
02:50:56 <shachaf> I'm not sure how much benefit you'll really get fro trying to draw directly analogies like that.
02:52:01 <dncr> I'm like to think I'm discovering etymologies more than drawing analogies.
02:52:18 <quicksilver> perhaps you should read SPJ's "book" then
02:52:37 <quicksilver> http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
02:52:59 <quicksilver> it dicusses quite a few of the different runtime approachs you can choose to use in a haskell-like language
02:53:24 <dncr> interesting
02:53:26 <shachaf> Or this:
02:53:27 <shachaf> @where stg
02:53:27 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
02:53:42 <Trudko> Guys I am learning learn your haskell but what I would like to do is also practice, so is there some source online where is thery but also some excercises?
02:53:56 <quicksilver> shachaf: isn't that the same thing?
02:54:00 <quicksilver> or a shorter version
02:54:11 <shachaf> quicksilver: No, it's neither.
02:54:25 <shachaf> Well, it *is* shorter, but it's somewhat different.
02:54:38 <shachaf> Wait, maybe not.
02:54:55 <shachaf> OK, it turns out SPJ has two books?
02:55:10 <shachaf> I thought you'd linked to http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/index.htm
02:55:18 <quicksilver> still, I think my link only goes as far as G-machine
02:55:27 <quicksilver> and your link is the 'S,T' part of "STG'
02:55:33 <quicksilver> they were published the same year
02:55:35 <shachaf> But the STG paper is neither of those.
02:55:37 <quicksilver> but books take longer
02:55:52 <quicksilver> so presumably the book was earlier and the STG paper builds on it
02:56:01 <shachaf> The STG paper is ~80 pages. :-)
02:56:16 <shachaf> Not a book, but still.
02:56:30 <shachaf> Anyway I didn't even know about that book, so I can't comment on the difference between them.
02:58:12 <shachaf> Why would you publish a book called "The Implementation of Functional Programming Languages" followed by one called "Implementing Functional Programming Languages"?
02:58:41 <osfameron> at least it shows you're consistent
02:59:57 <dncr> a book, a tutorial, an article
02:59:59 <dncr> oh my
03:00:44 <quicksilver> shachaf: the main purpose of the second publication was to show his increasing distaste of prepositions?
03:01:02 <dncr> it is pithier
03:01:04 <shachaf> quicksilver: And the paper is called "Implementing Lazy Functional Languages"
03:01:16 * quicksilver nods
03:01:29 <quicksilver> also no prepositions.
03:01:57 <quicksilver> but it predates his later interests in the sartorial arts.
03:02:04 <shachaf> Actually it's called "Implementing Lazy Functional Languages on Stock Hardware"
03:06:22 <ion> Implementing Stock Languages on Lazy Functional Hardware
03:08:18 <dncr> ion: That sounds like OpenCL or something.
03:19:01 <Nereid> I wonder if there will ever be a high-level language for quantum computers.
03:24:27 <Nereid> implicit in that question is whether there will ever be a need for one.
03:30:22 <dmwit> One of my colleagues is working on high-level languages for quantum computing, and he is not alone.
03:31:21 <quicksilver> dmwit: presumably he enjoys the company of an uncountable number of quantum superpositions of himself, at least
03:31:36 <osfameron> hehe
03:32:23 <shachaf> The nice thing about high-level quantum computing languages is that you don't need to make any design decisions, you can just make all of them.
03:33:45 <ion> main = allPrograms
03:34:16 <Nereid> oh you guys. :V
03:35:14 <merijn> Nereid: Eh, that question supposes that quantum computers are Turing complete, which afaik is an open question
03:36:32 <statusfailed> Can I get GHCi to automatically recompile when the source file changes?
03:36:47 <Nereid> merijn: what? you can embed classical computers in them
03:37:03 <dmwit> Can you?
03:37:14 <Nereid> can't you?
03:37:23 <dmwit> Classical computers can do lots of "weird" stuff, like duplicating information for free.
03:37:55 <Nereid> you can duplicate a qubit for free if it's in one of two known basis states too
03:39:10 <Nereid> there's a perfectly good unitary operator that maps |0> to |0> (x) |0> and |1> to |1> (x) |1>
03:42:14 <HugoDaniel> :)
03:42:23 <HugoDaniel> i love the name "Nereid" :D
03:42:35 <Nereid> ok
03:48:21 <Nereid> I admit I haven't been following quantum information stuff recently, since I'm not actually working in it or a related area
03:59:40 <dncr> I guess "garbage collection" sometimes means "automatic memory management" and sometimes means "AMM done when you want more memory (pull-based) and with some analysis going on."
04:02:11 <shachaf> Argument about words alert.
04:28:41 <mm_freak> Polarina: i'm sorry, but i decided to release without the manager wire for now, so i suggest doing your own solution using mkGen
04:30:01 <akamaus> hi all. Is there a way to reexport qualified modules in the module export list? So that after importing my module Foo Data.Map.lookup would be acceptable as M.lookup, for example.
04:30:24 <Nereid> I don't think so.
04:31:04 * hackagebot chuchu 0.1.4 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.1.4 (FelipeLessa)
04:31:15 <merijn> akamaus: What's wrong with exporting unqualified? Then the users just have to do "import qualified Foo" and use either Foo.lookup or import Data.Map themselves
04:32:25 <mcstar> wtf is behavior driven development
04:33:17 <mcstar> i dont like when people cant come up with a good description
04:33:26 <arcatan> it's like TDD 2.0
04:33:35 <spacepluk> mcstar: if you're a good boy you get paid
04:33:36 <akamaus> merijn, some modules, like Map and Set a designed to be imported qualified. I have a module with all sort of auxiliary stuff I use all over the program, I wanted to move frequent imports of libraries there too.
04:34:56 <Nereid> you'll just have to import them in each module you use them in.
04:36:05 * hackagebot netwire 4.0.0 - Flexible wire arrows for FRP  http://hackage.haskell.org/package/netwire-4.0.0 (ErtugrulSoeylemez)
04:37:21 <fmap> mcstar: you can safely read "behaviour driven development" as "blah blah blah"
04:37:35 <Nereid> what about profit driven development
04:37:46 <mm_freak> that's $blah $blah $blah
04:38:08 <mcstar> fmap: thanks, the good explanation i was looking for
04:38:54 <mcstar> development needs to be bug driver, first of all
04:38:59 <mcstar> driven*
04:39:14 <mcstar> you go where the bugs take you
04:39:41 <osfameron> that sounds bokononist
04:40:37 <Nereid> why am I reading the STG paper when I should be in bed or doing homework :s
04:40:59 <mm_freak> because the STG paper is mind-bending
04:41:05 * hackagebot chuchu 0.2 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.2 (FelipeLessa)
04:41:05 <akamaus> Nereid, I understand, I just wanted to shorten the import list a bit :)
04:41:33 <mcstar> whoa, that was fast
04:41:55 <mcstar> behavior driven development develops in front of us
04:43:25 <mcstar> this paper? http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/
04:43:33 <Nereid> no
04:43:35 <Nereid> @where stg
04:43:35 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
04:43:47 <mm_freak> behavior driven development looks like TDD/Cobol
04:46:21 <mcstar> Nereid: does that paper describe basically the early ghc?
04:46:22 <merijn> akamaus: Do you use both Map and Set within your program or just one of the two?
04:46:32 <Nereid> mcstar: no idea
04:47:12 <Nereid> Set k = Map k ()
04:47:34 <mm_freak> mcstar: yeah, it does
04:47:38 <akamaus> merijn, I use Maps almost everywhere and occasionally sets too.
04:48:33 <merijn> akamaus: You could just export Map unqualified and import Set qualified where necessary
04:48:55 <bitonic> just use them always as qualified.  that's a much better choice
04:49:15 <akamaus> merijn, yeah, but that way there would be many clashes with Prelude too.
04:49:38 <bitonic> unqualified modules are a mistake :P
04:49:58 <Nereid> you know you can re-export only parts of modules.
04:50:10 <mm_freak> i think that's the only shortcoming of haskell's type inference
04:50:10 <merijn> "import Prelude hiding (lookup,insert)" etc :p
04:50:23 <merijn> {-# LANGUAGE NoImplicitPrelude #-} :>
04:50:33 <mm_freak> type inference could be used to resolve names
04:50:43 <Eduard_Munteanu> There was that TDNR proposal.
04:50:54 <mm_freak> that would give us shorter code + the record puns that many people want
04:51:02 <Eduard_Munteanu> Type-directed name resolution, but dunno what became of it.
04:51:12 <mm_freak> Eduard_Munteanu: seems like it went nowhere
04:52:53 <bitonic> this is really a non-problem.  just use qualified modules.  Erlang has only qualified modules and I've never heard anybody complain about that
04:54:05 <Eduard_Munteanu> Agda has something like that for constructors.
04:54:27 <bitonic> well with agda you can also import and rename...
04:58:30 <mm_freak> bitonic: that's because nobody in the erlang world thinks: "that could be done better"…  they just live with ugly code =)
05:00:20 <bitonic> mm_freak: it's not ugly, and it's much simpler
05:00:31 <bitonic> I'm saying this after working on a large Erlang codebase
05:00:59 <mm_freak> simpler than haskell?  i doubt that
05:01:14 <mm_freak> (syntax)
05:01:37 <bitonic> mm_freak: I'm talking about the module system.  and in terms of syntax, it's `:' instead of `.'...
05:01:41 <bitonic> module:fun
05:02:12 <mm_freak> i see
05:02:28 <mm_freak> dunno, i don't like qualified names, much less qualified operator names
05:02:41 <mm_freak> i just use them, because they are the best you get right now
05:03:29 <bitonic> I think spending time to devise a system to avoid having to type the module name is wasted effort.
05:03:50 <mm_freak> i like the TDNR approach
05:04:19 * quicksilver thinks TDNR is a disaster
05:04:27 * bitonic is with quicksilver 
05:04:38 <quicksilver> hmm, one of our rivers is poisoned, how shall we fix it?
05:04:48 <mm_freak> dunno if it's good, but the idea to have name resolution based on types doesn't sound too bad
05:04:48 <bitonic> maybe not "disaster", but still a mess, imo
05:04:50 <quicksilver> I know, let's poison every single body of water in the world, that''s how.
05:05:24 <osfameron> TDNR?
05:05:52 <osfameron> ah, "TypeDirectedNameResolution"
05:06:28 <mm_freak> osfameron: type-directed name resolution, as in you write "insert", and the compiler figures out which one must be the correct one based on types
05:06:54 <bitonic> except when it doesn't
05:07:40 <mm_freak> do you fear that you would have to write more type signatures?
05:08:02 <osfameron> it looks like quicksilver fears mass poisoning
05:08:23 <ivanm> quicksilver: what's this about rivers?
05:08:24 <bitonic> mm_freak: I fear it'll make things much more confusing
05:08:57 <quicksilver> ivanm: it was an analogy for TDNR
05:09:07 <quicksilver> it was a clumsy and verbose way of saying "cure worse than the disease"
05:09:16 <mm_freak> remember i don't know what exactly the TDNR proposal looks like
05:09:40 <osfameron> I thought it was rather beautiful, though I didn't follow the precise details of the satirical critique
05:09:54 <mm_freak> my proposal is just:  if there is name ambiguity, instead of just listing the possibilities, figure out if there is exactly one type-correct resolution, and if yes, use it
05:10:19 <quicksilver> the reason I don't like it, basically, mm_freak is that I find the idea that subexpressions stand on their own
05:10:26 <quicksilver> and have a well-defined principal type
05:10:42 <quicksilver> to be a valuable one for understanding, reasoning about, and refactoring haskell programs.
05:10:45 <bitonic> mm_freak: if not, the user is forced to specify the type.  and if the type too polymorphic... mhm.  and if the expression is copy-pasted somewhere else...
05:11:25 <mm_freak> quicksilver: not if there are free variables, because then the type and semantics of the subexpression does depend on your imports anyway
05:11:46 <quicksilver> mm_freak: Yes, that is true.
05:11:48 <bitonic> mm_freak: we write a lot of point-free code
05:12:04 <quicksilver> mm_freak: principle type is already "within a context"
05:12:13 <quicksilver> (the context of your imports)
05:12:23 <drostie> there is still something about the JS idea of associating functions to prototypes which appeals to me, I confess. :<
05:12:24 <quicksilver> but this proposal makes it even weaker (or makes the context stronger, i fyou like)
05:12:46 <mm_freak> i understand your concern
05:13:09 <mm_freak> it's just that basically even if enabled by default type-based resolution would still be just an option
05:13:21 <mm_freak> you could still use your qualified imports, if you want
05:13:41 <mm_freak> most people would only use it for stuff like ByteString, Map, etc.
05:14:48 <quicksilver> we already have a notion of type-directed resolution which works well - typeclasses
05:14:56 <mm_freak> to get some of the well-definedness back you could require that this type of name resolution only works for monomorphic values, or values where every type variable is fully polymorphic
05:14:59 <quicksilver> it works well because the principal type then explains the context.
05:15:08 <quicksilver> that is precisely what typeclass contexts are
05:15:10 <mm_freak> hmm, yeah
05:15:27 <quicksilver> a second "second-class" type-directed mechanism
05:15:33 <quicksilver> to solve a problem which is really about naming
05:15:37 <quicksilver> just doesn't feel right :)
05:15:49 <quicksilver> I'd much rather people worked harder to turn the import/export/qualified system into something useful.
05:16:04 <quicksilver> allow you to re-export whilst qualifying and renaming
05:16:15 <quicksilver> so that you have a composable notion of module renaming
05:18:48 <Nereid> or first-class modules
05:19:09 <t7> anyone know of some system that requires >1 programmer to sign off on a commit before it gets merged into some secure branch?
05:19:28 <Botje> burocracy?
05:19:32 <Nereid> I know of an abstract one.
05:19:32 <srhb> t7: Pull requests EVERYWHERE!
05:19:35 <ivanm> t7: as in a tool-based approach to enforce it?
05:19:35 <t7> automagical*
05:19:45 <t7> ivanm yeah
05:19:46 <Botje> t7: google's gerrit has something like it.
05:19:55 <srhb> For extra fun, make your boss be the one handling the secure branches.
05:19:58 <srhb> :-)
05:20:05 <Nereid> aw, I was hoping a cryptographic approach.
05:20:05 <t7> liek it will be merged automatically once these conditions are met
05:20:10 <ivanm> I seem to recall reading about git having some sign-off functionality; maybe some way to enforce using that or something?
05:20:12 <Nereid> like secret sharing.
05:22:55 <randomclown> there desparately needs a modifystarray function
05:23:22 <t7> ivanm oooh i didnt know about this sign off stuff, maybe one could set up a prehook or something
05:23:25 <randomclown> monad.state has modify, stref has one, st needs on.
05:23:28 <randomclown> one*
05:28:50 <fmap> randomclown: mapArray?
05:32:00 <t7> i thought bitbucket was opensource ?
05:33:10 <t7> nope :'(
05:33:55 <randomclown> fmap: that's all indices though
05:34:35 <Nereid> randomclown: write your own
05:34:45 <randomclown> pfff of course it's trivial
05:34:45 <Nereid> u:
05:34:54 <randomclown> But for consistancy
05:35:34 <randomclown> Nereid: do you now see the merit of a modifySTArray function?
05:36:08 <Nereid> or one that works on arbitrary MArrays
05:44:45 <hpaste> neworder pasted “h2” at http://hpaste.org/76689
05:45:08 <neworder> My teacher was able to compile the code but I can't
05:45:31 <neworder> Am I missing something in the code?
05:46:04 <ivanm> @tell lispy I managed to get ghci to crash with a glibc double free or corruption error! :p
05:46:05 <lambdabot> Consider it noted.
05:46:34 <fmap> neworder: yeah, don't use tabs
05:46:48 <neworder> oh
05:47:03 <neworder> So for indentation, I use spaces right
05:47:16 <fmap> yes
05:47:18 <Nereid> @where style
05:47:18 <lambdabot> http://urchin.earth.li/~ian/style/haskell.html http://snapframework.com/docs/style-guide
05:47:28 <Nereid> ^
05:47:55 <neworder> Thanks
05:51:23 <ivanm> @tell lispy (I think from my rather dubious attempt at turning Ptr into ForeignPtr in peek; looks like I _do_ have to clone the value somehow)
05:51:23 <lambdabot> Consider it noted.
05:57:50 <asante> (floor $ a/b) should be the same as (a `div` b) ?
05:58:30 <Nereid> yes
05:58:44 <asante> thx
05:58:49 <Nereid> div rounds down.
05:58:52 <Nereid> quot rounds toward zero.
05:59:40 <Nereid> quot and rem for Int behave like / and % in C.
06:02:15 <Nereid> heh, liftA2 . liftA2
06:03:21 <Nereid> you know what would be cool?
06:03:38 <Nereid> if we could specify minimal complete definitions for instances without having mutually recursive default methods.
06:04:40 <Nereid> e.g. right now we can write instance Eq T and it won't warn us because (==) and (/=) are defined in terms of each other by default.
06:05:59 <mcstar> i think it could be useful to shadow instance declarations too
06:06:08 <mcstar> since haskell doesnt have module functors like ocaml
06:06:10 <Nereid> what do you mean?
06:06:25 <Nereid> (I've never touched a *ml so I don't know how those work.)
06:06:42 <mcstar> like, Int is in Eq, so when you put in a map, it works
06:06:48 <mcstar> but what if, you want a different ordering?
06:06:54 <Nereid> I see.
06:06:57 <mcstar> you have to wrap that Int into your own type
06:07:02 <mcstar> and provide an instance declaration
06:07:19 <mcstar> and this can be cumbersome, if the thing is not an Int, but a Set for example
06:07:34 <mcstar> since you still want to use all the Set related functions on your wrapped type
06:07:39 <Nereid> I'm not 100% sure that's a good idea but I can imagine why someone would want it.
06:07:40 <mcstar> but now you cant
06:08:35 <mcstar> if there would be a clever and consistent way to scope instance declarations...
06:08:47 <beaky> hello
06:08:47 <lambdabot> beaky: You have 1 new message. '/msg lambdabot @messages' to read it.
06:08:53 <mcstar> heh
06:09:05 <mcstar> at the right time, beaky i left you the message
06:09:19 <beaky> :D
06:09:24 <quicksilver> mcstar: it's not a simple idea; there are good reasons why instances are global
06:09:29 <quicksilver> they're used to provide invariants
06:09:41 <quicksilver> two different instance of Ord in different places can break your Maps
06:09:50 <quicksilver> two different instances of Binary can break your serialisation
06:09:50 <quicksilver> etc.
06:09:54 <mcstar> quicksilver: im aware of, that there are good resons behind that(im just not clearn on them)
06:10:04 <mcstar> but, i think you can see the logic in my argument
06:10:05 <Nereid> first issue I think of is, say you shadow some instance for Int, and then you call some function which uses the same class's methods on Int.
06:10:09 <Nereid> which instance should it use?
06:10:54 <quicksilver> mcstar: I can see why you would want it, but I think you're wrong.
06:11:01 <mcstar> heh
06:11:01 <Nereid> anyway, I wonder if you can do something along those lines with the Constraint kind somehow.
06:11:02 <quicksilver> if you think you want a local instance, just use a data type
06:11:04 <mcstar> i can be...
06:11:05 <quicksilver> which contains the methods
06:11:12 <quicksilver> a.k.a. a dictionary.
06:11:18 <Nereid> or some of those things.
06:11:20 <quicksilver> "if you didn't want it to be global, it wasn't really a typeclass you wanted"
06:12:02 <beaky> How do I translate what getArgs returns into parameters to a function?
06:12:35 <mcstar> quicksilver: lets imagine, i have a data MySet = MySet (Set Int), how would i 'inherit' all the functions, to work on my new type, that come with Set?
06:12:59 <mcstar> @hoogle getArgs
06:13:00 <lambdabot> System.Environment getArgs :: IO [String]
06:13:00 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
06:13:11 <mcstar> you can match on the returned list of strings
06:13:21 <beaky> how do I do that?
06:13:29 <mcstar> par1:_ <- getArgs
06:13:39 <Nereid> args <- getArgs
06:13:40 <quicksilver> mcstar: well the correct question is "why did you decide to newtype Set; what instance did you want to do differently" ?
06:13:51 <mcstar> and then do womething with par1, because it is just a string
06:14:30 <Nereid> make sure to handle the case when the argument list isn't the right size.
06:14:54 <mcstar> quicksilver: the problem i run into, is that i wanted to have sets, that were placed into a map-like proiority queue, PSQueue, but i wanted a different ordering, i wanted to prioritize them on their number of elements, the set cardinality
06:15:07 <asante_> my connection was broken. so sry if asking twice: Nereid: what's the difference between `rem` and `mod` then?
06:15:23 <Nereid> asante_: read the docs :)
06:16:15 <quicksilver> mcstar: but surely PSQueue is designed precisely so you can put whatever you like in the 'priority' field
06:16:24 <ghorn> anybody know the status on gtk being broken for 7.6.1? at least, gtk's dependencies pango and glib are broken...
06:16:25 <mcstar> beaky: you could try to compile the new code, and see how close it gets to C, i had an almost 2x speedup, by changing mod
06:16:32 <quicksilver> mcstar: it explicitly *doesn't* use the the Ord instances of the key itself
06:16:53 <mcstar> quicksilver: no, it uses the Ord of the 'priority'
06:16:59 <mcstar> which is my set
06:17:02 <Nereid> mcstar: use a newtype wrapper
06:17:13 <quicksilver> mcstar: then you're using it wrong?
06:17:20 <mcstar> quicksilver: no, im not
06:17:20 <quicksilver> mcstar: the 'priority' is supposed to be the priority.
06:17:24 <beaky> where's the code?
06:17:26 <mcstar> yes
06:17:26 <quicksilver> it's not supposed to be some arbitrary date.
06:17:28 <quicksilver> data.
06:17:39 <mcstar> quicksilver: then it is not flexible enough
06:17:41 <quicksilver> put the cardinality of the set in the 'priority' not the set itself
06:17:53 <quicksilver> why would you want to put an entire set there?
06:18:06 <quicksilver> the purpose of that field is to store the priority, that's all
06:18:12 <mcstar> quicksilver: that psqueue is a map like mapping from keys to priorities, i can have fast lookup, and fast lookup of the min element at the same time
06:18:12 <Nereid> mcstar: there's a reason PSQueue has separate keys and values.
06:18:30 <quicksilver> your requirements make no sense to me, I'm afraid.
06:18:36 <Nereid> wait.
06:18:36 <quicksilver> but I'm sure they're not a flaw in the typeclass system
06:18:43 <quicksilver> they are, at most, a flaw in the API of PSQueue
06:18:46 <mcstar> i didnt say it was a flaw
06:18:53 <Nereid> yes
06:18:56 <quicksilver> although it seems to me you're just fighting against the way PSQueue is intended to be used needlessly
06:19:03 <Nereid> mcstar: put the set as the key, and its cardinality as the priority
06:19:10 <mcstar> lol
06:19:16 <mcstar> and now i lost lookup
06:19:27 <mcstar> so, lets have a different map from my real keys to the sets
06:19:27 <beaky> http://ideone.com/ydhyMf what pattern am I missing? :(
06:20:03 <mcstar> []
06:20:06 <mcstar> for example
06:20:14 <Nereid> then put those keys in the PSQueue.
06:21:07 * hackagebot http-conduit 1.8.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.1 (MichaelSnoyman)
06:21:09 * hackagebot tuple-hlist 0.1.0.6 - Functions to convert between tuples and HLists.  http://hackage.haskell.org/package/tuple-hlist-0.1.0.6 (NicolasDudebout)
06:21:31 <mcstar> all im saying, is that this mechanism lack a bit of felxibility
06:22:30 <drostie> beaky: are you sure that the lambda { \(s:t:u:_) -> print $ f t u s } gets applied to a list with at least three elements?
06:22:42 <quicksilver> if anything lacks flexibility, mcstar, it's PSQueue for forcing you to use the Ord instance of hte 'p'
06:22:49 <quicksilver> but you really are using it in a way it isn't designed
06:23:01 <Nereid> I think it's mcstar that lacks flexibility.
06:23:03 <beaky> drostie: no somethimes one (or all) of s, t, and u are empty
06:23:03 <quicksilver> it's not *supposed* to store arbitrary data in the 'p' field - just the priority.
06:23:13 <Nereid> beaky: not just empty, nonexistent.
06:23:16 <quicksilver> you're supposed to store keys, and priorities
06:23:17 <Iceland_jack> beaky: that's not how it works
06:23:34 <Nereid> that lambda will only match on a list with at least 3 elements.
06:23:34 <quicksilver> if you have auxiliary data against the key the natural thing would be another Map
06:23:39 <quicksilver> for the aux stuff.
06:23:40 <drostie> beaky:  \(s:t:u:_) will not match a list with fewer than 3 elements.
06:23:41 <Nereid> so if you have fewer than 3 arguments, oops.
06:23:44 <fmap> ghorn: there are patches to make it work for 7.6.1 but patched version is not yet on hackage
06:23:48 <hpaste> mcstar pasted “beaky” at http://hpaste.org/76691
06:23:50 <Iceland_jack> case [] of (s:t:u:_) -> s
06:23:58 <Iceland_jack> > case [] of (s:t:u:_) -> s
06:23:59 <lambdabot>   *Exception: <interactive>:(3,0)-(4,21): Non-exhaustive patterns in case
06:24:02 <quicksilver> *having said all that* you could make a wrapper MySet with a different Ord instance and wrap only your PSQueue code to use it
06:24:08 <quicksilver> so the rest of your code used plain Sets
06:24:12 <quicksilver> and that would be less of a change.
06:24:12 <drostie> beaky: the list [1, 2, 3] is actually 1:2:3:[] if it helps.
06:24:32 <Nereid> you can also match on [s,t,u]
06:24:43 <Nereid> (as a synonym for s:t:u:[])
06:25:20 <Nereid> args <- getArgs; case args of { [s,t,u] -> do stuff; _ -> report wrong number of arguments }
06:25:51 <mcstar> Nereid: i lack flexibility? how did you arrive at that conclusion?
06:26:04 <beaky> I love pattern matching
06:26:05 <Nereid> by insisting on not making a wrapper or something?
06:26:11 * hackagebot authenticate 1.3.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.2 (MichaelSnoyman)
06:26:13 * hackagebot keter 0.3.2 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.2 (MichaelSnoyman)
06:26:15 <mcstar> i wrote a wrapper
06:26:15 * hackagebot http-conduit-browser 1.6.3 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.6.3 (MikhailKuddah)
06:26:18 <Nereid> okay
06:26:22 <beaky> if-else blocks are so 60s
06:26:39 <Nereid> I'm not sure why you don't just take the keys of your Set-valued Map as the keys in the PSQueue.
06:27:02 <Nereid> but I have no clue what you're actually doing, so.
06:27:17 <mcstar> because i need to have the keys too, otherwise the set is meaningless
06:27:26 <hpaste> neworder pasted “h3” at http://hpaste.org/76692
06:27:33 <Nereid> mcstar: what? you have the keys.
06:27:40 <Nereid> you put the keys in the PSQueue.
06:27:42 <neworder> I removed all the tabs and still can't compile =(
06:27:49 <neworder> Used only spaces
06:28:02 <Nereid> neworder: I see tabs
06:28:18 <neworder> Oh
06:28:22 <neworder> Lemme try again
06:28:24 <mcstar> Nereid: i got it backwards what you said, but now, i have 2 lookups instead of one
06:28:39 <mcstar> anyway, it is not worth arguing about
06:28:54 <hamid> @src (:)
06:28:54 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
06:28:57 <beaky> how do I get argv[0]?
06:29:02 <beaky> getArgs doesn't contain it :(
06:29:13 <mcstar> what quicksilver proposed, wrapping Set only for the psqueue, and not for the rest of the code is the easiest
06:29:13 <hamid> @src (++)
06:29:13 <lambdabot> []     ++ ys = ys
06:29:13 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
06:29:13 <lambdabot> -- OR
06:29:13 <lambdabot> xs ++ ys = foldr (:) ys xs
06:29:23 <Nereid> mcstar: popping from the PSQueue is cheap.
06:29:42 <mcstar> yeah, but i need to delete arbitrary elements from it too
06:29:44 <Nereid> mcstar: if you wrap Set, then every time the PSQueue has to comare stuff, it has to dig into the Set and compute its cardinality.
06:29:50 <Nereid> compare*.
06:29:58 <Nereid> sounds a lot slower.
06:30:02 <mcstar> i dont think it has to do that
06:30:04 <mauke> beaky: depends on what you need it for
06:30:05 <Iceland_jack> beaky: getProgName?
06:30:09 <mcstar> size is O(1)
06:30:33 <Nereid> mcstar: finally, it smells.
06:30:34 <Nereid> :v
06:30:51 <quicksilver> mcstar: well the point worth arguing is, that this *isn't* a good example of why local instaces would be nice :)
06:30:55 <hamid> hmm so ++ joins 2 lists but, : joins one element to a list. that's why it's faster
06:31:07 * hackagebot yesod-auth 1.1.1.4 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.1.4 (MichaelSnoyman)
06:31:08 <neworder> Nereid: They are spaces really
06:31:09 <quicksilver> although it *might* be a good example of why reusable containers like PSQueue shouldn't use Ord instances
06:31:18 <neworder> The compiler gives this error
06:31:20 <quicksilver> (they should ask you to pass a comparison function for the priority)
06:31:27 <neworder> The function `putStrLn' is applied to two arguments
06:31:34 <Nereid> hamid: [x] ++ list is just as fast as x : list, with optimizations and such
06:31:39 <Nereid> hamid: but : is clearer
06:31:40 <mcstar> quicksilver: yeah, that could be handy
06:31:48 <Iceland_jack> neworder: I'd say that's a pretty clear error message :)
06:31:58 <mcstar> also, i lost Nereid on what 'smells'
06:32:09 <mcstar> dont smell it if it smells...
06:32:10 <Nereid> neworder: probably because your getLine ... is indented more than ptuStrLn
06:32:15 <mcstar> flush your toilet
06:33:04 <Nereid> mcstar: it just feels morally wrong to put sets as priorities.
06:33:23 <mcstar> heh, what a BS talk
06:33:27 <mcstar> afk
06:33:33 <beaky> 13:33 < mcstar> afk
06:33:33 <hamid> Nereid, hmm... while people keep saying that :/ thanks
06:33:38 <beaky> http://ideone.com/m606Xd
06:33:56 <Nereid> beaky: you can omit the first 3 cases there
06:34:05 <Nereid> and write [s,t,u] instead of s:t:u:[]
06:34:48 <Iceland_jack> beaky: [] falls through [s,t,u] to the catch-all case _
06:34:58 <Iceland_jack> so does [s] and [s,t]
06:35:47 <beaky> what does >>= do?
06:36:07 <Nereid> x >>= \y -> z is the same as do { y <- x; z }
06:36:35 <Nereid> @undo do { y <- x; z }
06:36:36 <lambdabot> x >>= \ y -> z
06:36:57 <Nereid> @do x >>= \y -> z
06:36:57 <lambdabot> do { y <- x; z}
06:36:57 <Nereid> heh
06:37:24 <beaky> so >>= does a monadic action and purify the result?
06:37:38 <rwbarton> nononono
06:37:38 <beaky> :t (>>=)
06:37:39 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:37:54 <Nereid> >>= does a monadic action and feeds its result to a function which returns another monadic action.
06:38:00 <beaky> ah
06:38:11 <mauke> >>= does nothing
06:38:22 <Nereid> it does what whoever wrote the Monad instance told it to do.
06:38:24 <mauke> >>= takes an action and a function, and returns a new action
06:38:37 <Nereid> ok,
06:38:56 <mauke> when that new action is executed, it executes the first action, passes the result to the function, then executes the return value of the function
06:39:11 <Nereid> *running* m >>= k runs m and then feeds its result to the function k, which returns another monadic action that then gets run.
06:39:22 <Nereid> run = executed
06:39:47 <beaky> so it is like passing continuations?
06:40:20 <ghorn> fmap: thanks, working now - i'd tried that patch before but i hadn't re-installed the executables like c2hs
06:40:39 <rwbarton> is (.) "like passing continuations"?
06:40:58 <mauke> beaky: in a way, yes
06:41:41 <Nereid> beaky: the purpose of >>= in IO is to thread IO actions together so they get executed in order.
06:42:18 <beaky> ah
06:42:27 <neworder> Sorry guys, I seriously don't know where I'm going wrong
06:42:46 <Nereid> the reason it's a monad is just to take advantage of the type system to ensure you can't break the sequencing.
06:42:47 <Nereid> I think.
06:42:50 <neworder> I indented the putstrln with the getLine
06:42:58 <Nereid> neworder: show the code please.
06:43:00 <neworder> Didn't use tabs
06:43:05 <neworder> Sure
06:43:16 <Nereid> also
06:43:20 <Nereid> paste the error message together with the code
06:43:53 <hpaste> neworder pasted “h4” at http://hpaste.org/76693
06:44:05 <Nereid> you still have tabs in the last line.
06:44:25 <rwbarton> isn't line 2 already a problem?
06:44:31 <Nereid> please configure your text editor properly, or use a better text editor
06:44:33 <rwbarton> but yeah
06:44:34 <Nereid> ah yes, line 2 is already a problem.
06:45:20 <Nereid> neworder: another note, functions that take multiple arguments are usually written curried, like convert a b i
06:45:23 <Nereid> instead of taking a tuple
06:45:58 <neworder> Ah I see
06:46:05 <neworder> Alright
06:46:16 <Nereid> but yeah, line 2 has to be indented at least as far as the let in line 1.
06:47:46 <hpaste> rwbarton annotated “h4” with “fix whitespace” at http://hpaste.org/76693#a76694
06:48:01 <rwbarton> here is how i would lay it out if i were constrained to put line breaks in the same places you did
06:48:48 <rwbarton> (where "i" = my editor, really)
06:49:20 <beaky> http://ideone.com/eo1t2U how do I make the case of expression pointfree?
06:49:40 <hpaste> Nereid annotated “h4” with “I'd rewrite it like so (annotation)” at http://hpaste.org/76693#a76695
06:49:46 <Nereid> (I was liberal with making changes)
06:49:55 <Nereid> hmm, I'd probably align the = signs in convert.
06:50:15 <quicksilver> beaky: you can't.
06:50:45 <quicksilver> you can stop naming the parameter 'xs' and instead name a function f :: [String] -> IO ()
06:50:48 <quicksilver> but that's not really a win
06:51:03 <Nereid> as long as it's not named f
06:51:04 <quicksilver> it's the same number of 'entities named once and used only once'
06:51:16 <quicksilver> good point Nereid ;)
06:51:20 <beaky> also what's a better name for those functions f and f'?
06:51:22 <rwbarton> yeah, Nereid's is a lot more like how I'd actually write it. or you could move convert to a where block
06:51:25 <beaky> and can I merge f' with f?
06:51:53 <Nereid> beaky: a good name for it will tell me roughly what it does.
06:52:19 <hpaste> rwbarton annotated “h4” with “another possible style” at http://hpaste.org/76693#a76696
06:52:54 <fmap> beaky: with -XLambdaCase it would be `getArgs >>= \case [s, t, u] -> …'
06:52:59 <beaky> it's a functon that converts "a" "b" "aa" into ["aa", "ba", "ab", "bb"]
06:53:10 <Nereid> that's a bit long for a name
06:53:11 <Nereid> :p
06:53:31 <Nereid> beaky: it doesn't have to describe it completely
06:53:36 <t7> how do i get all the enums in a data type?
06:53:36 <rwbarton> beaky's code looks like something produced by a disassembler
06:53:39 <Nereid> that's what function definitions are for
06:53:42 <t7> as a list
06:53:45 <Nereid> just make it memorable
06:53:59 <Nereid> t7: derive Enum and Bounded, and then [minBound .. maxBound]
06:54:24 <t7> ah thanks
06:54:25 <rwbarton> f' = allReplacements?
06:54:33 <Nereid> t7: or just [minBound..]
06:54:37 <beaky> right
06:54:53 <rwbarton> or wait
06:55:02 <rwbarton> ah i get it
06:55:18 <Nereid> beaky: I had a go at writing that function the other day, do you want to see what I got
06:55:23 <beaky> yes :D
06:55:27 <Nereid> if I can remember where I put it
06:56:16 <Nereid> I remember you were calling it combReplace before.
06:56:22 <Nereid> anyway.
06:56:26 <hpaste> Nereid pasted “combReplace2” at http://hpaste.org/76697
06:56:30 <beaky> I didn't like the name combReplace :(
06:56:33 <Nereid> me either.
06:56:41 <Nereid> but I'm not very creative with names.
06:56:45 <rwbarton> it looks like maybe you can just fix the base case on line 8 (f' _ _ [] = [[]]) and then remove "sr:" on line 9
06:56:51 <rwbarton> then get rid of f
06:57:22 <Nereid> yeah, the base case should be a thing.
06:57:25 <t7> > randomIOR (1, 10)
06:57:26 <lambdabot>   Not in scope: `randomIOR'
06:58:59 <Nereid> haha oops.
06:59:04 <Nereid> that isInfixOf is supposed to be isPrefixOf.
06:59:42 <Nereid> it must have been late when I was writing that.
06:59:44 <Nereid> just like it is now.
06:59:55 <t7> @hoogle [a] -> Int -> (a, [a])
06:59:55 <lambdabot> Data.Generics.Twins gmapAccumQ :: Data d => (forall e. Data e => a -> e -> (a, q)) -> a -> d -> (a, [q])
06:59:55 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
06:59:55 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:00:07 <Nereid> t7: what are you looking for?
07:00:22 <t7> take and remove
07:00:35 <Nereid> take? so ... -> ([a],[a])?
07:00:41 <Nereid> @type splitAt
07:00:42 <lambdabot> forall a. Int -> [a] -> ([a], [a])
07:00:58 <t7> no like deleteAtButGiveMeAlso
07:01:02 <Nereid> oh.
07:01:08 * hackagebot antigate 0.0.1 - Interface for antigate.com captcha recognition service.  http://hackage.haskell.org/package/antigate-0.0.1 (MikhailKuddah)
07:02:01 <Nereid> > let delete n xs = take n xs ++ drop (n+1) xs in delete 1 [a,b,c,d]
07:02:04 <lambdabot>   [a,c,d]
07:02:22 <Nereid> @let delete n xs = take n xs ++ drop (n+1) xs
07:02:23 <lambdabot>  Defined.
07:02:46 <Nereid> @type (liftA2 . liftA2) (,) (!!) (flip delete)
07:02:47 <lambdabot>     Ambiguous occurrence `delete'
07:02:47 <lambdabot>     It could refer to either `L.delete', defined at <local>:1:0
07:02:47 <lambdabot>                           or `Data.List.delete', imported from Data.List at State/L.hs:35:0-33
07:02:51 <Nereid> oh damn.
07:03:12 <beaky> how do I make y program return 1 on failure?
07:03:17 <Nereid> @type (liftA2 . liftA2) (,) (!!) (flip L.delete)
07:03:18 <lambdabot> forall a. [a] -> Int -> (a, [a])
07:03:26 <Nereid> beaky:
07:03:29 <Nereid> @hoogle exitFailure
07:03:29 <lambdabot> System.Exit ExitFailure :: Int -> ExitCode
07:03:29 <lambdabot> System.Exit exitFailure :: IO a
07:03:36 <t7> i need to delete by index
07:03:39 <Nereid> yeah
07:03:45 <Nereid> that is what this delete does.
07:03:58 <Nereid> @undefine
07:04:12 <Nereid> @let deleteAt xs n = take n xs ++ drop (n+1) xs
07:04:13 <lambdabot>  Defined.
07:04:18 <Nereid> @type (liftA2 . liftA2) (,) (!!) deleteAt
07:04:19 <lambdabot> forall a. [a] -> Int -> (a, [a])
07:04:24 <t7> is this not standard?
07:04:28 <Nereid> doesn't look like it.
07:04:44 <Nereid> > (liftA2 . liftA2) (,) (!!) deleteAt 1 [a,b,c,d]
07:04:44 <t7> writing a random shuffler is really ugly
07:04:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:04:45 <lambdabot>         against inferred type ...
07:04:49 <Nereid> > (liftA2 . liftA2) (,) (!!) deleteAt [a,b,c,d] 1
07:04:51 <lambdabot>   (b,[a,c,d])
07:04:59 <t7> i need Data.List.Mutable
07:05:02 <Nereid> haha.
07:05:42 <Nereid> there ought to be a lens for that.
07:05:52 <Polarina> mm_freak, no hard feelings. Better get it right later than get it wrong and release. :)
07:06:26 <neworder> Nereid: I just managed to compile it!! I forgot to put module Main where :P
07:06:33 <Nereid> you shouldn't need that
07:06:54 <neworder> oh, so it compiled due to something else
07:06:59 <neworder> ?
07:07:05 <Nereid> I guess
07:07:10 <beaky> @hoogle String -> Int
07:07:10 <lambdabot> Test.HUnit.Base Label :: String -> Node
07:07:10 <lambdabot> Prelude error :: [Char] -> a
07:07:10 <lambdabot> Prelude length :: [a] -> Int
07:08:22 <Nereid> @tell edwardk how about a lens for accessing the n'th element of a list?
07:08:22 <lambdabot> Consider it noted.
07:09:23 <merijn> Nereid: I think he doesn't support those because they violate his lens laws
07:09:33 <Nereid> how so?
07:09:38 <merijn> Nereid: I've made similar suggestions in the past
07:09:48 <Nereid> there's one for head and last...
07:09:48 <rwbarton> there might not be an nth element of the list i guess
07:09:51 <merijn> I forget, I don't actually remember them
07:09:56 <Nereid> which error if the list is empty
07:10:03 <rwbarton> yeah, you could do that
07:10:07 <rwbarton> I would think...
07:11:31 <t7> haskell can do sized vectors now right? with type families or something?
07:11:46 <Nereid> type-level naturals
07:16:54 <Nereid> I couldn't get type-level natural literals to work well last time I tried, though
07:16:55 <beaky> when should I use let over where?
07:17:25 <Nereid> http://www.haskell.org/haskellwiki/Let_vs._Where
07:17:33 <beaky> :D
07:17:45 <beaky> I like where better
07:17:49 <beaky> never had to used let
07:18:18 <beaky> I like how where captures the function's parameters
07:20:56 <Nereid> I tend to use let most of the time.
07:22:49 <Nereid> oh, here's that lens for accessing the n'th element of a list.
07:22:51 <Nereid> _at 0 = _head; _at n = _tail . _at (n-1)
07:22:55 <Nereid> :)
07:23:26 <Nereid> lenses are great.
07:23:30 <beaky> why use f = \x -> x * x over f x = x * x ?
07:23:44 <Nereid> I don't know.
07:24:05 <rwbarton> normally you wouldn't
07:24:31 <Nereid> yep, that works as expected.
07:24:42 <mauke> because you like the MR
07:24:48 <Nereid> lol
07:25:53 <Nereid> t7: this lens is for you
07:26:20 <fmap> Nereid: making At Int [] instance would be more interesting :[
07:26:31 <Nereid> sure.
07:27:54 <Nereid> ghci> [0..6] ^. _at 3
07:27:54 <Nereid> 3
07:27:54 <Nereid> ghci> _at 3 .~ 5 $ [0..6]
07:27:54 <Nereid> [0,1,2,5,4,5,6]
07:27:55 <Nereid> :D
07:28:38 <t7> Nereid is that by index or equality of item?
07:28:41 <Nereid> index
07:28:53 <t7> lens syntax looks nasty
07:29:14 <Nereid> you can use view and set if you don't like those operators.
07:30:17 <Nereid> ghci> :t view . _at
07:30:17 <Nereid> view . _at :: Int -> [d] -> d
07:30:18 <Nereid> ghci> :t set . _at
07:30:18 <Nereid> set . _at :: Int -> d -> [d] -> [d]
07:31:08 * hackagebot not-gloss 0.5.0.1 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.5.0.1 (GregHorn)
07:31:10 * hackagebot not-gloss 0.5.0.2 - Painless 3D graphics, no affiliation with gloss  http://hackage.haskell.org/package/not-gloss-0.5.0.2 (GregHorn)
07:34:58 <Nereid> t7: I think the syntax is as good as it can get.
07:35:33 <t7> ^. .~  :|
07:36:04 <fmap> my favourite is <%@~
07:36:10 <t7> i dont mind operators as long as they have some kinda meaning in math or whatever
07:37:21 <Nereid> t7: the operators for MonadState are pretty cool.
07:38:07 <Nereid> id .= blah sets the state to blah. id %= f modifies the state by f.
07:38:18 <Nereid> and you can replace id with any lens of the state
07:39:37 <Nereid> er, lens into the state type. or whatever. what do you call this?
07:40:28 <FireFly> fmap: what does it do? :P
07:40:55 <Nereid> FireFly: http://hackage.haskell.org/packages/archive/lens/3.0.4/doc/html/Control-Lens-IndexedLens.html#v:-60--37--64--126-
07:41:03 <Nereid> I don't know what it means, though.
07:41:16 <Nereid> wait, actually it's pretty clear from the type.
07:41:21 <Nereid> or it would be, if I was comfortable with indexed lenses.
07:44:09 <beaky> what makes functional programming more powerful than whatever C# offers?
07:45:40 <Philippa> 1) it's possible for us to know something doesn't have side-effects 2) our type systems don't have to deal with added complexity for OO support, which makes it possible and even easy (from a 2012 perspective, if not the 1992 perspective of some of our researchers) to make them substantially more powerful
07:45:51 <fryguybob> beaky: Haskell offers purity which, for me at least, gives a way of thinking about programming that you cannot do with C#.
07:46:29 <Philippa> 3) we get a lighter syntax that's much better for algebraic manipulation etc. When you're seeing horribly dense code, it's because it /can be/ that dense while expressing everything it does
07:46:46 <jeff_s1> Aren't you guys conflating pure and functional?
07:47:00 <Philippa> jeff_s1: there be holy wars
07:47:11 <fryguybob> jeff_s1: I mentioned Haskell specifically.
07:47:47 <Philippa> and it's enough for C# /not/ to support purity: it's clear that pure FP can exist :p
07:47:57 <Philippa> (hi: people mistake me for a lawyer sometimes)
07:48:43 <Polarina> beaky, in haskell, and most other functional languages, functions are first-class objects. They can be toyed around and manuiplated just as easily like that Int over there. Functional programming tends to deal with the application and evaluation of functions, rather than sequential computations.
07:49:10 <Philippa> Polarina: C# has first class functions these days too, of course
07:49:18 <Philippa> what it doesn't have is thorough support for a functional style
07:49:22 <Polarina> Philippa, so it would seem.
07:49:24 <jeff_s1> Currying is nice.
07:49:40 <jeff_s1> What I mean is partial application, dunno if I used the word Currying correctly.
07:49:41 <Philippa> the ease of embedding languages is much nicer!
07:49:53 <Nereid> non-strict semantics is pretty cool.
07:50:10 <Philippa> especially, the interplay between embedded languages that you get when you have a type system making sure their interactions make sense
07:50:21 <Nereid> a cool t ype system is pretty cool.
07:50:43 <jeff_s1> I want a cooler type system!
07:50:49 <Philippa> jeff_s1: currying allows partial application (in fact, we only have n-ary functions insofar as currying is a thing)
07:50:54 <Philippa> jeff_s1: so fair enough
07:51:10 <Nereid> partial application isn't all that special imo.
07:51:16 <Nereid> you can do that even in C++.
07:51:34 <jeff_s1> I love it when a language has syntactic support for partial application.
07:51:37 <Nereid> sure.
07:51:38 <jeff_s1> C++ has it?
07:51:44 <Philippa> Nereid: last time I used C++ seriously, you really didn't /want/ to fake it
07:51:47 <Nereid> I wouldn't call it a killer feature though.
07:51:54 <Nereid> Philippa: I never said you'd want to :v
07:52:12 <Philippa> beaky: any of this making sense? Any of it you'd like to hear more detail about?
07:52:33 <jeff_s1> It seems like there would be a wiki page for beaky...
07:53:10 <Nereid> but haskell supports some pretty cool abstractions for, say, concurrency
07:53:58 <Philippa> Nereid: 'sfunny how knowing nothing dirty is going on can enable you to do really dirty things, isn't it?
07:54:26 <Nereid> no, what's funny is the sun's coming up here and I'm still awake.
07:54:36 <jeff_s1> Anyone know if Intel's software transaction extensions are going to help Haskell's STM library?
07:54:43 <Nereid> I should do something about that.
07:55:02 <Nereid> and since I can't stop the sun...
07:55:07 <tromp> > map (2.5*) [346,432]
07:55:08 <lambdabot>   [865.0,1080.0]
07:55:10 <rwbarton> why does lens use (<//=) rather than (</=)?
07:55:15 <Philippa> ...you should run for cover from it?
07:55:24 <Nereid> nah, I'll just stop being awake.
07:55:29 <Nereid> bye.
07:55:50 <rwbarton> why that name with the doubled /, that is
07:56:29 <rwbarton> @hoogle (//)
07:56:29 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
07:56:29 <lambdabot> Data.Array (//) :: Ix i => Array i e -> [(i, e)] -> Array i e
07:56:53 <neworder> let f=f in (\ x y -> case x of _ -> case y of _ -> (x,y)) (f 0) (f 1)
07:57:06 <neworder> how do I put in another function definition inside
07:57:21 <neworder> I want to put in k=k inside too
07:57:33 <neworder> let f=f,k=k in (\ x y -> case x of _ -> case y of _ -> (x,y)) (k 0) (f 1)
07:57:35 <rwbarton> let {f=f; k=k} in ...
07:57:43 <rwbarton> but normally you would use layout
07:57:45 <rwbarton> let f = f
07:57:47 <rwbarton>     k = k
07:57:48 <rwbarton> in ...
07:57:55 <neworder> Ah I see, Thanks
07:58:48 <rwbarton> this is also how you would define the same f by several cases
08:04:33 <parcs`> rwbarton: what does <//= do?
08:04:58 <rwbarton> it's part of a series <+=, <-=, <*=, <//=
08:05:30 <rwbarton> for manipulating the state of your MonadState via a lens
08:05:44 <rwbarton> a lens that selects a Num/Fractional type
08:06:36 <fryguybob> jeff_s1: There is potential for TSX to be useful, but not directly in the sense that Haskell STM transactions would become TSX transactions.
08:06:40 <rwbarton> oh i get it
08:06:45 <rwbarton> there is also a version //=
08:06:53 <rwbarton> which can't use the name /=
08:07:26 <byorgey> <//=  fish with gills?
08:13:17 <neworder> I made this function which takes in two arguments and returns a tuple of the 2 arguments (\ w x -> (w,x))
08:13:31 <neworder> I want another function which takes in 4 arguments and returns 2 tuples
08:13:48 <sipa> > ((,) `fmap` (,))
08:13:50 <lambdabot>   Overlapping instances for GHC.Show.Show
08:13:50 <lambdabot>                              (a -> ...
08:13:56 <neworder> (\ w x y z -> (w,x),(y,z))
08:14:10 <mauke> @pl (\ w x y z -> (w,x),(y,z))
08:14:10 <lambdabot> (((const . const) .) . (,), (y, z))
08:14:12 <neworder> I know the above is wrong
08:14:18 <rwbarton> you're missing some parens
08:14:22 <int-e> neworder: you can only return a pair of pairs
08:14:35 <mauke> @pl \ w x y z -> ((w,x),(y,z))
08:14:35 <lambdabot> flip flip (,) . (((.) . (.) . (,)) .) . (,)
08:14:36 <rwbarton> oh
08:14:39 <mauke> ah, much better
08:14:48 <int-e> mauke: better?!
08:14:54 <mauke> well, it's correct now
08:15:10 <neworder> a pair of pairs as in
08:15:14 <neworder> one tuple right
08:15:21 <mauke> a tuple of a tuple and a tuple
08:15:55 <int-e> neworder: ((w,x),(y,z)) <- you're missing the outer pair of parentheses here.
08:15:56 <neworder> Meaning this ((a,b),(c,d)) ?
08:16:11 <neworder> Oh!
08:16:36 <parcs`> @type (fmap fmap fmap curry . curry) (,)
08:16:37 <lambdabot> forall a b a1 b1. a1 -> b1 -> a -> b -> ((a1, b1), (a, b))
08:16:56 <neworder> got it, thanks! =)
08:21:20 <beaky> foo
08:25:03 <beaky> so unlike Scala/OCaml, Haskell doesn't need OOP constructs?
08:25:14 <merijn> beaky: Define "need"
08:25:26 <int-e> @t (.) (.) (.:) curry curry (,)
08:25:26 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
08:25:27 <merijn> I'm pretty sure Scala/OCaml don't "need" OOP either
08:25:33 <int-e> @type (.) (.) (.:) curry curry (,)
08:25:34 <lambdabot> forall a b a1 b1. a1 -> b1 -> a -> b -> ((a1, b1), (a, b))
08:25:57 <pettter> merijn: correct, at least for Scala
08:26:03 <byorgey> *like* Scala/OCaml, Haskell doesn't need OOP constructs.  Unlike Scala/OCaml, it actually doesn't have them either.
08:26:13 <merijn> byorgey++
08:26:16 <pettter> quite
08:26:41 <merijn> The more I understand programming, the less sense I think OOP makes
08:26:43 <byorgey> despite the "O" in OCaml, I'm told most OCaml programmers do not actually use the OOP features
08:26:59 <rwbarton> the reasons for choosing OCaml over other MLs have little to do with the 'O', yes
08:27:16 <beaky> ah
08:27:17 <merijn> Or rather, the typical java style OOP with inheritance
08:27:38 <beaky> right
08:27:50 <beaky> I never understood OOP as well
08:27:54 * companion_cube uses objects in OCaml
08:28:04 <beaky> but then again I'm still a beginner ^_^
08:28:12 <merijn> beaky: Most explanations of OOP are terrible, so that's not your fault :>
08:28:29 * merijn will stab the next person explaining OOP using examples like vehicles, cars and fords >.>
08:28:36 <beaky> and animals
08:28:42 <merijn> beaky: Word.
08:28:43 <parcs`> and people
08:28:46 <rwbarton> circles and ellipses
08:28:48 <beaky> and banks ^_^
08:28:51 <bartavelle> there is something I have no clue how to do in the list monad. I want to support JtR mangling rules preprocessor macros with a parser. Right now I support stuff like this "[ab]x[cd]" which turns into ["axc","bxc","axd","bxd"], using "sequence"
08:29:11 <bartavelle> but I don't know how to support "parallel-like comprehensions", such as
08:29:39 <FireFly> Have any suggestions for better things to use as examples to explain OOP?
08:29:49 <Philippa> merijn: explaining OO in terms of 'business objects' like (filled) forms/applications/etc, letters, decision making processes and so forth makes a lot more sense than the 'fun' 'real world' objects
08:29:50 <bartavelle> "[ab]x\p1[cd] [ef]" which turns into ["axc e", "bxd e", "axc f", "bxd f"]
08:30:11 <companion_cube> more abstractly, I find objects useful to provide different implementations for an interface at runtime
08:30:12 <Philippa> though it tends to make inheritance an obviously dodgy thing at that point
08:30:19 <merijn> Philippa: Although even there I feel OOP is mostly not that useful
08:30:20 <companion_cube> but that's exactly like typeclasses
08:30:23 <companion_cube> but for values
08:30:31 <merijn> Philippa: Isn't inheritance inherently dodgy?
08:30:34 <bartavelle> anyone has a clue on how I could do that in an elegant way ?
08:30:37 <Philippa> merijn: yeah. OOM, sure, but why bother with the P?
08:31:01 <Philippa> merijn: when separated from subtyping? Not /always/, just usually
08:31:22 <merijn> Structural subtyping and interfaces are sensible, inheritance is dumb
08:31:33 <companion_cube> I mostly agree with merijn
08:31:48 <companion_cube> that's why OCaml objects are quite nice (although a bit complicated)
08:32:17 <b__> should I stay away from floats when dealing with currencies? (I know that the question alone probably implies complete ignorance and incompetence on the matter, but I'm not planning to write anything very serious)
08:32:55 <parcs`> b__: you should probably use the Data.Fixed module
08:32:57 <beaky> yeah I think you ought to use arbitrary precision decimals for that thing ^^
08:33:43 <b__> beaky, yes I was planning on managing my entire family's capital that way, no problem
08:33:51 <b__> parcs`, will look into it, thanks
08:34:33 <merijn> b__: YES!!!!!1!!11!1!one!1one1!eleven (in answer to staying away from floats when doing currency)
08:34:49 <b__> ^^
08:35:02 <parcs`> unless you want to replicate the plot of superman 3
08:35:04 <merijn> @quote mantissa
08:35:04 <lambdabot> quicksilver says: <jatqceer> i love them.  Double is my friend <quicksilver> You think he is, sure <quicksilver> he says nice things about you <quicksilver> but one day, when your back is turned, he
08:35:04 <lambdabot> will stab you in the back with a mantissa
08:45:57 <b__> Straight integral numbers don't seem too great either
08:46:06 <b__> would data.ratio be an option?
08:46:10 * hackagebot keter 0.3.3 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.3 (MichaelSnoyman)
08:48:35 <Philonous> Is there something like recvFrom with timeouts / access to epoll?
09:01:10 * hackagebot tls-extra 0.4.7.1 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.4.7.1 (MikhailKuddah)
09:08:20 <rosie> I've forgotten -- why does x in the following get bound to String and not IO String? getLine >>= \x -> putStrLn $ "You typed: " ++ x.   The return type of (>>=) is of course m b where m is a Monad, and the return type of putStrLn is this m b, but how does the x get passed a value that's not in a monad?
09:09:38 <Lemmih> rosie: The second argument to >>= has the type 'a -> m b'
09:09:38 <mm_freak> rosie: (>>=) :: IO a -> (a -> IO b) -> IO b
09:09:40 <mm_freak> your 'x' is of type 'a'
09:09:41 <DexterLB> if I have a function f :: Int -> Int, how do I make an infinite list "l" where each element "l !! n" is equal to "f $ l !! (n - 1)"? aka each element is a function f from the previous one
09:09:54 <mm_freak> DexterLB: iterate
09:10:03 <DexterLB> mm_freak: thanks
09:10:15 <mm_freak> > iterate (\x -> mod (x^2 + 1) 12827) 1
09:10:16 <lambdabot>   [1,2,5,26,677,9385,8044,6549,8741,7470,3451,5946,3705,2136,8912,11788,2054,...
09:10:40 <rosie> ah right thanks!
09:10:44 <saml> hey i have a question
09:10:52 <DexterLB> also, is there a way to ask the same question in a simpler way? I tend to be unable to ask properly
09:10:56 <DexterLB> :D
09:11:40 <saml> DexterLB, what do you want to ask?
09:11:44 <fmap> @hoogle (Int -> Int) -> Int -> [Int]
09:11:45 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
09:11:45 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
09:11:45 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
09:12:06 <DexterLB> saml: I already asked, and got an answer, about iterate
09:12:07 <quicksilver> DexterLB: your way worked fine ;)
09:12:23 <parcs`> DexterLB: "how do i get an infinite list of repeated applications of f to x"
09:12:24 <quicksilver> DexterLB: I'd have said "is there a way to get the lis [x,f x, f(f x), ....]
09:12:39 <quicksilver> DexterLB: but I don't see anything wrong with your approach.
09:12:50 <DexterLB> thanks, both of you :)
09:13:09 <MostAwesomeDude> Hey, out of curiosity (mostly), is it possible to coerce GHC to emit extern C symbols which call Haskell code? I kind of want to build a standard SO/DLL out of Haskell.
09:13:11 <fmap> I'd think about desired type signature and ask if there is such function already
09:13:57 <quicksilver> MostAwesomeDude: yes.
09:14:00 <quicksilver> MostAwesomeDude: "foreign export"
09:15:31 <MostAwesomeDude> quicksilver: And then there's some flag similar to -shared which I can pass?
09:16:11 <saml> i doubt
09:17:01 <quicksilver> MostAwesomeDude: haskell produces .o files. you can link those directly.
09:17:06 <quicksilver> or you can bundle them into a library if you want
09:17:10 <quicksilver> you do need the RTS though
09:17:18 <quicksilver> s/haskell/GHC/;
09:17:36 <MostAwesomeDude> quicksilver: Okay. Is there any tutorial or writeup on doing this sort of thing, or am I off on my own?
09:17:48 <quicksilver> http://www.haskell.org/haskellwiki/Calling_Haskell_from_C
09:17:51 <quicksilver> covers the basics.
09:17:57 <quicksilver> the GHC manual has some stuff too
09:18:08 <quicksilver> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ffi-ghc.html
09:18:10 <MostAwesomeDude> Sweet, thanks.
09:18:22 <quicksilver> "8.2.1.2. Making a Haskell library that can be called from foreign code"
09:18:53 <quicksilver> I'm not sure what the incantation is to get the actual shared lib built though
09:27:45 <DexterLB> how do I print a list in a human-readable way? for example [[1, 2, 3], [3, 4, 5], [5, 6, 7]] to be printed as "[\n  [1, 2, 3]\n  [3, 4, 5]\n  [5, 6, 7]\n]" or similar
09:28:34 <DexterLB> there was some function that did that iirc, but I can't find it now
09:28:49 <nand`> does GHC treat \t as 8 spaces verbatim, or an indentation to the next multiple of 8?
09:28:55 <quicksilver> 8 verbatim
09:28:56 <donri> DexterLB: groom
09:28:57 <tibbe> dcoutts: hey, how are things?
09:29:23 <rwbarton> nand`: the latter (i think/hope)
09:29:31 <quicksilver> there is also Language.Haskell.Pretty
09:29:34 <quicksilver> I've never used it though
09:30:17 <donri> data-pprint
09:30:47 <DexterLB> yes! that was the one I remember
09:30:50 <quicksilver> nand`: I was wrong.
09:30:50 <DexterLB> thanks :)
09:30:57 <quicksilver> nand`: "Tab stops are 8 characters apart.; A tab character causes the insertion of enough spaces to align the current position with the next tab stop."
09:31:04 <quicksilver> nand`: ( http://www.haskell.org/onlinereport/syntax-iso.html )
09:31:19 <beaky> how do I catch EOFerrors?
09:34:25 <quicksilver> donri: hmm. Cute.
09:34:33 <quicksilver> possibly overengineered? but cute.
09:34:49 <nand`> beaky: seems to be part of IOException
09:35:02 <beaky> right
09:36:12 <rwbarton> quicksilver: well the whole package only contains 4 lines of actual code :)
09:38:24 <quicksilver> rwbarton: ?
09:38:40 <rwbarton> oh
09:38:48 <rwbarton> i thought you were replying to < donri> DexterLB: groom
09:38:54 <quicksilver> :) no
09:39:00 <quicksilver> 17:29 < donri> data-pprint
09:40:29 <donri> sexp-show, integrated with emacs
09:41:02 <donri> with collapsible nodes
09:41:11 * hackagebot Cabal 1.16.0.2 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.16.0.2 (JohanTibell)
09:46:13 * hackagebot cabal-install 1.16.0.1 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.16.0.1 (JohanTibell)
09:59:06 <sm> hurrah!
09:59:55 <Nisstyre> Do people think it would be feasible to teach a subset of Haskell to high school kids? Like, in an afternoon or something...
10:00:04 <simon> Nisstyre, yes.
10:00:24 <Nisstyre> simon: cool, do you have any ideas for things they could do?
10:00:27 <djahandarie> A useless subset.
10:00:28 <simon> Nisstyre, since the empty subset is a trivial subset of all sets, I would say always. ;-)
10:00:31 <Nisstyre> :P
10:00:38 <djahandarie> You can teach them how to write factorial or something like that.
10:00:39 <Nisstyre> I meant more like a subset you can use to write small programs
10:00:40 <simon> Nisstyre, recursive functions.
10:00:48 <Nisstyre> simon: perhaps if they already know some other language
10:01:01 <Iceland_jack> Kind of depends on their background and what you intend for them to learn
10:01:08 <Nisstyre> true enough
10:01:48 <Iceland_jack> You can probably cover some basics like what lists are and what map does which they'll probably grasp, but it doesn't mean that they'll be able to use it afterwards
10:01:54 <simon> Nisstyre, factorial, fibonacci numbers, stirling numbers, binomial coefficients.
10:01:55 <Iceland_jack> Just depends on the crowd I guess
10:02:20 <Nisstyre> Iceland_jack: do you think Haskell would be more understandable than say, Scheme?
10:02:24 <Nisstyre> simon: nice suggestions
10:02:28 <Iceland_jack> Hm.. it's hard to say
10:02:32 <monochrom> for highschool students, mind the notation "f(x)" vs "f x"
10:02:39 <Nisstyre> yup
10:02:40 <Iceland_jack> Probably yes
10:02:49 <monochrom> but yes do tell them how wrong "f(x)" is!
10:03:13 <klr> are there any book or tutorial which teaches how to make programs with haskell aimed at beginners, it's boring to just learn without having some real program, it feels like no progress is being made ...........
10:03:18 <Iceland_jack> even though I like Lisps they look very foreign and probably not something they can familiarize themselves with in a week
10:03:23 <Nisstyre> klr: Learn You A Haskell
10:03:33 <nand`> ironically, both parse to the same thing in Haskell
10:03:43 <simon> Nisstyre, currying and partially evaluated functions
10:03:46 <Nisstyre> Iceland_jack: yeah, I figured that much
10:03:50 <nand`> so you can use f(x) if you really want to. not that I condone the needless expense of parentheses
10:03:53 <simon> Nisstyre, the first part of LYAH :)
10:03:55 <Nisstyre> simon: that would be an awesome thing to explain
10:03:57 <klr> Nisstyre: i read that, it's boring, ofc i learn haskell, but not how to program real software
10:04:00 <Nisstyre> I'd have to explain anonymous functions firstr
10:04:02 <Nisstyre> *first
10:04:12 <klr> yes do that :D
10:04:12 <Nisstyre> klr: okay then try "Real World Haskell"
10:04:23 <klr> Nisstyre: i have, too difficult
10:04:35 <Nisstyre> klr: well there's not really anything in between
10:04:42 <Iceland_jack> I do not agree with simon's suggestions, currying and math heavy stuff is probably not a good starting point if they don't know any programing to begin with
10:04:46 <klr> crap, suicide then good bye
10:05:02 <simon> Iceland_jack, I assume they're interested in math.
10:05:15 <Iceland_jack> If that's the case
10:05:15 <Nisstyre> these would be kids interested in either CS or SE
10:05:22 <Nisstyre> this is for an outreach program my university does
10:05:24 <monochrom> there is the Gentle Introduction between LYAH and RWH
10:05:46 <Iceland_jack> Nisstyre: What ever you do, at least have them compile at least one program
10:05:51 <monochrom> however, "RWH is too hard and I want to write a real [sic] program now" is a contradiction
10:05:51 <Nisstyre> Iceland_jack: indeed
10:06:13 <monochrom> if RWH is too hard, you are not ready to write a substantial program
10:06:33 <monochrom> even the programs in RWH are toys compared to "real" programs
10:06:43 <Iceland_jack> Instead of 5 different ways of defining factorials, ...
10:06:45 <beaky> lyah is a gentler introduction to haskell
10:08:08 <Nisstyre> Iceland_jack: the problem is how to introduce a minimal amount of ideas that let you do something interesting
10:08:09 <monochrom> and to compare with other communities: the python tutorial doesn't have "real" programs either. be surprised or not surprised that it shows fibonacci, too
10:08:55 <Iceland_jack> Introduce do notation/getLine/putStrLn, don't mention monads, show some basic pattern matching...
10:09:22 <beaky> have a goal in mind when learning a new programming language, something like "I wanna use haskell to implement a FORTRAN compiler!"
10:09:31 <Nisstyre> Iceland_jack: If they've seen piecewise functions in math before then I could introduce guards pretty easily
10:09:40 <Iceland_jack> yeah, exactly
10:09:47 <Iceland_jack> I'd mention laziness which might seem impressive
10:09:59 <Iceland_jack> [1..] or shouting = 'a' : shouting
10:10:10 <Nisstyre> heh
10:10:14 <Nisstyre> yeah, that would blow their minds
10:10:28 <Nisstyre> especially if they've used a strict language before
10:10:29 <Philippa> not shouting = "lager"++shouting? :p
10:10:29 <Iceland_jack> And let them think on how it's “stored” in memory
10:10:31 <Iceland_jack> yes exactly
10:10:37 <beaky> the good thing about languages like Haskell is that 'assignment' is final, unlike in other languages where "x = x + 5;" trips folks up ^^
10:10:40 <monochrom> if they haven't seen piecewise functions, you should still introduce guards and if-then-else. most programs are piecewise functions. cannot be avoided
10:10:59 <Philippa> Iceland_jack: so storage is a more complex one, you have to talk about the difference between laziness and non-strictness
10:11:04 <Nisstyre> monochrom: I think the curriculum for grade 12 math has piecewise functions somewhere
10:11:08 <Nisstyre> this is Ontario Canada
10:11:18 <Iceland_jack> Hm that's true, but he wouldn't have to go into it in detail Philippa
10:11:25 <Iceland_jack> Just give them some food for thought
10:11:40 <Iceland_jack> Nisstyre: But this is a pretty subjective question so don't be surprised if you get different answers ;)
10:11:57 <Nisstyre> Iceland_jack: I'm just looking for ideas really
10:12:04 <mcstar> we were integrating in grade 12
10:12:04 <monochrom> in fact it's highschool math classes that are so irrationally refraining from piecewise functions like we're in the 16th century and we barely understand numbers let alone booleans
10:12:12 <nand`> http://hackage.haskell.org/packages/archive/data-pprint/0.2.1.4/logs/failure/ghc-7.6 an odd log
10:12:24 <nand`> (works fine for me, GHC 7.6.1, incidentally)
10:12:28 <Nisstyre> mcstar: sadly I don't think the grade 12 curriculum covers integral calculus, however that might be a good thing since it's not butchered
10:12:29 <Philippa> Iceland_jack: you'd be surprised. But then, something very closely related led to me explaining how to reliably GC cyclic data using refcounting to my gf over dinner
10:12:45 <Iceland_jack> heh, well Philippa
10:12:55 <Philippa> (the trick? Keep explicit fixpoints, count references /through/ the fixpoint separately to those 'within' it)
10:13:05 <mcstar> Nisstyre: the OKTV, physics section basically required you to use integral calculus
10:13:10 <Iceland_jack> Nisstyre could always give them references to read up on if they really want to know ;Þ
10:13:16 <mcstar> thats high school student competition
10:13:43 <Nisstyre> Iceland_jack: I'm looking at getting a copy of Spivak's "Calculus", so maybe I could recommend that if I enjoy it :P
10:13:45 <mcstar> (hungary)
10:14:08 <Iceland_jack> Hm yes
10:14:59 <Nisstyre> What about creating a simple vector data type then explaining an algorithm to add vectors?
10:15:05 <Nisstyre> that's something they would be doing from physics
10:15:21 <Iceland_jack> That sounds like a good idea
10:15:45 <mcstar> Nisstyre: jon harrop's site has some example programs that are short and interesting, trolling aside, id recommend those
10:16:00 <mcstar> (his trolling aside, not mine)
10:16:15 <Iceland_jack> If you intend on having them work in groups you could ask them to define some operations on vectors
10:16:34 <Philippa> mcsmash: nothin' wrong with a little metatrolling so long as everyone else is having fun
10:16:37 <Nisstyre> mcstar: can you give me the url?
10:16:56 <mcstar> Nisstyre: http://www.ffconsultancy.com/ocaml/index.html
10:17:05 <monochrom> Nisstyre: https://groups.google.com/d/msg/alt.algebra.help/HHV33maShQg/EkBbGcS8jBwJ
10:17:22 <Nisstyre> mcstar: awesome, nice
10:17:29 <Nisstyre> I could benefit from that ray tracer program
10:17:58 <klr> what's the typeclass Ord?
10:18:16 <sipa> @src Ord
10:18:16 <lambdabot> class  (Eq a) => Ord a  where
10:18:16 <lambdabot>     compare      :: a -> a -> Ordering
10:18:16 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
10:18:16 <lambdabot>     max, min         :: a -> a -> a
10:18:17 <monochrom> it is for >=, <=, etc
10:19:08 <beaky> @src flip
10:19:08 <lambdabot> flip f x y = f y x
10:19:21 <Nisstyre> klr: for things that can be ordered
10:19:22 <beaky> is it possible to define flip in a point-free manner? ^^
10:19:38 <monochrom> but aren't you giving up haskell? :)
10:19:38 <mauke> of course
10:19:51 <rwbarton> well flip is one of the things you usually use to write things points-free
10:19:54 <monochrom> @pl \f x y -> f y x
10:19:55 <lambdabot> flip
10:20:00 <monochrom> err, nevermind :)
10:20:08 <Iceland_jack> haha
10:20:11 <klr> Nisstyre: like?
10:20:19 <Iceland_jack> klr: numbers
10:20:20 <Nisstyre> klr: like integers
10:20:27 <Nisstyre> or strings
10:20:29 <klr> how can they be sorted?
10:20:31 <monochrom> Int and Char are examples of Ord instances
10:20:43 <monochrom> woah, you're too fast
10:20:45 <klr> eh, lol, im an idiot, i dont understand
10:20:55 <beaky> what are the typeclasses that can be put in a deriving clause?
10:21:20 <monochrom> if you have "<", you can write a sorting routine yourself. or use "sort" from Data.List
10:21:24 <mauke> flip = \f -> \x -> \y -> f y x
10:22:01 <Iceland_jack> > sort [2,5,3,4,1]
10:22:02 <lambdabot>   [1,2,3,4,5]
10:22:03 <mauke> flip = \f -> \x -> \y -> S f (K x) y
10:22:10 <mauke> flip = \f -> \x -> S f (K x)
10:22:25 <mcstar> beaky: how did the latest version compare?
10:22:42 <mauke> flip = \f -> \x -> (S (K (S f)) K) x
10:22:49 <mauke> flip = \f -> (S (K (S f)) K)
10:24:21 <kirindave_> :\
10:24:30 <kirindave_> http://channel9.msdn.com/posts/Erik-Meijer-and-Gilad-Bracha-Dart-Monads-Continuations-and-More at 35:00
10:24:36 <beaky> mcstar: still twice as slow as the C version :(
10:24:39 <mauke> S (S (K S) (S (K K) S)) (K K)?
10:24:40 <beaky> on my machine at least
10:24:43 <kirindave_> Talking about how monad manipulation is rare.
10:24:53 <kirindave_> Bummer to hear that from such a prominent dude.
10:24:55 <mauke> :t ap (ap (const ap) (ap (const const) ap)) (const const)
10:24:56 <lambdabot> forall b a b1. (b1 -> a -> b) -> a -> b1 -> b
10:25:02 <mcstar> beaky: are you sure? with the new lookup and mod?
10:25:04 <rwbarton> huzzah
10:25:17 <mcstar> i have 0.22 vs. 0.35
10:25:21 <kirindave_> So I asked this the other day, and last week at BAHaskell Coffee hour.
10:25:40 <mcstar> no, 0.3s, averaging over 10 iterations
10:25:50 <mauke> :t ap (ap (return ap) (ap (return return) ap)) (return return)
10:25:50 <mcstar> > 0.22/0.3
10:25:51 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m (a -> b) -> a -> m b
10:25:51 <lambdabot>   0.7333333333333334
10:26:00 <kirindave_> Monatron seems fallow and unmaintained. How _do_ people develop more specific monad transformer components that can be reused?
10:26:32 <beaky> :O so on your machine it's faster than the C version? :D
10:26:36 <mcstar> no
10:26:46 <mauke> :t (<*>) ((<*>) (pure (<*>)) (pure pure <*> (<*>))) (pure pure)
10:26:48 <lambdabot> forall (f :: * -> *) b a. (Applicative f) => f (a -> b) -> a -> f b
10:27:01 <scooty-puff> is it possible to define a pair GADT that has only a single data constructor, while enforcing that either one or both of the contained data is Just (i.e. at most one Nothing) - a GADT Maybe would be fine
10:27:24 <kirindave_> He also mentions the "Future" monad.
10:27:27 <mauke> :t pure (<*>) <*> (pure pure <*> (<*>)) <*> pure pure
10:27:28 <lambdabot> forall (f :: * -> *) b a. (Applicative f) => f (a -> b) -> a -> f b
10:27:28 <kirindave_> I wonder what that is.
10:27:32 <kirindave_> Like Cont?
10:27:36 <mauke> perfect
10:27:37 <scooty-puff> the closest i can get is (:*:) :: Maybe empty a -> Maybe empty' b -> Pair (And empty empty') a b
10:27:44 <mcstar> beaky: the reason im suspicious, is that it was 2x slower before i made the modifications, at least, that was what you told me, and i could confirm it
10:27:52 <mcstar> and the changes definitely made it faster
10:28:04 <yiannis_t> mauke: please don't use that anywhere :-]
10:28:06 <mcstar> so....i expect it to run faster on your side too
10:28:17 <scooty-puff> but that does not eliminate the need to match Pair Nothing Nothing
10:28:31 <beaky> right
10:28:42 <scooty-puff> (data Maybe empty a where Nothing :: Maybe True a; Just :: a -> Maybe False a)
10:29:15 <mauke> yiannis_t: but beaky was asking for it
10:29:38 <yiannis_t> ... shocked
10:30:14 <beaky> point-free flip :D
10:31:12 * hackagebot certificate 1.3.1 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.3.1 (VincentHanquez)
10:35:07 <beaky> :t unsafePerformIO
10:35:08 <lambdabot> Not in scope: `unsafePerformIO'
10:35:12 <beaky> :(
10:35:51 <alpounet> unsafePerformIO :: IO a -> a
10:38:23 <scooty-puff> with functional dependencies and data kinds, is it possible to make a type class Or a b c that, given a ~ True, will infer c (without b being available), and same with b?
10:39:12 <beaky> when should I use unsafeOerform IO?
10:39:22 <Philonous> beaky:  You shouldn't
10:39:23 <byorgey> beaky: never
10:41:36 <yiannis_t> : )
10:43:04 <ion> beaky: For instance, when you’re interfacing with a C function you *know* to be pure. It’s never okay to use it to inject side effects to a function. (Debug.Trace.trace is the exception to the rule, but that should never be left to the code after the debugging either.)
10:43:21 <beaky> why is it called unsafe?
10:43:42 <yiannis_t> http://www.cafepress.com/+haskell-hackers-hacker-unsafeperformio+t-shirts
10:43:42 <ion> Because it can inject side effects to a pure function, which is a great way to shoot yourself in the foot.
10:43:46 <Philonous> ion:  No need to use unsafePerformIO there either. The FFI takes care of it
10:43:58 <Polarina> beaky, because it is unsafe. It breaks referential transparency when used incorrectly.
10:43:59 <beaky> right
10:44:25 <Polarina> beaky, unsafe functions, when used incorrectly, can also crash your programs in unimaginable ways.
10:44:26 <rwbarton> it can even break type safety when used incorrectly
10:44:51 <lightquake> you can write unsafeCoerce :: a -> b with unsafePerformIO
10:45:23 <beaky> so things like unsafePerformIO and unsafeCoerce are for the C programmers who want to prove they can write C in any language ^^
10:45:40 <Philonous> beaky:  You don't need unsafePerformIO to write C in haskell
10:46:09 <beaky> how do I write C in Haskell?
10:46:26 <Polarina> beaky, a rule of thumb is to use them if, and only if, you know you need them. Not when you think you need them.
10:46:37 <ion> philonous: I was thinking of things like withCString.
10:46:41 <beaky> right
10:46:45 <scooty-puff> if you mean ffi, see: http://www.haskell.org/haskellwiki/FFI_Introduction
10:47:34 <Philonous> ion:  Fair enough
10:47:54 <mcstar> why is this backwards approach so popular among newcomers to haskell?
10:48:01 <Philonous> beaky:  IO ist for "C in Haskell"
10:48:27 <lightquake> beaky: what do you mean "write C in haskell"?
10:48:33 <parcs`> you can almost write unsafeCoerce with -fdefer-type-errors and Template Haskell
10:48:35 <Clint> putStr "C"
10:48:35 <lightquake> if you mean "use C libraries from haskell" the answer is the FFI
10:48:50 <beaky> I meant imperative style code ^^
10:48:58 <lightquake> if you mean "write C-style code in haskell" the answer is "you are asking the wrong question"
10:49:10 <beaky> ah
10:49:21 <lightquake> or 無 if you prefer
10:49:40 <parcs`> let unsafeCoerce :: Lift a => a -> b; unsafeCoerce x = [| x |]
10:50:00 <Clint> http://kormacode.blogspot.com/2011/11/c-style-haskell_10.html
10:50:41 <lightquake> parcs`: so what does that actually wind up doing?
10:50:58 <mcstar> 'if and only if'
10:51:01 <lightquake> Clint: wow, that's scary
10:51:43 <lightquake> beaky: the way you write haskell code is fundamentally different from the way you write C code
10:51:55 <beaky> right
10:52:05 <lightquake> it's more oriented around… manipulating data, I guess, than on 'do this, then do that, then do this other thing'
10:52:46 <parcs`> lightquake: the TH bracket supposed to be a type error but because of -fdefer-type-errors the TH bracket is instead supposed to be replaced with a call to 'error <type-error-string>' but this step is (erroneously) not done for TH brackets
10:52:57 <beaky> the way I used to design C programs is think of different data structures, separating them by interface & implementation, then implement operations on them one-by-one, then integrate the separate modules.
10:53:28 <parcs`> lightquake: so an error won't get thrown at runtime and the function will act like unsafeCoerce
10:53:42 <lightquake> parcs`: oh, so it's a bug
10:53:49 <nand`> I tend to think of my design methodology as ‘type-directed programming’; I think up what data I want to represent and model a type for it; then I think about the types of functions I want
10:53:53 <parcs`> lightquake: ye.
10:53:55 <parcs`> p
10:55:00 <beaky> I guess the only thing common between C and Haskell software design is modularization ^^
10:55:40 <mcstar> the FFI is common between them
10:55:53 <clahey> beaky: C++ version?
10:55:57 <clahey> beaky: Or do I have to write it?  :)
10:56:10 <beaky> clahey: my C++ version is almost done, but I've got some very strange bugs :(
10:56:41 <mcstar> i didnt have bugs, except that SO because of the unevaluted counter variable increment
10:56:46 <beaky> the good thing about haskell is that if it compiles, it tends not to have such strange bugs
10:58:41 <clahey> I wonder how C++ with inferred types would be.
10:58:55 <mcstar> auto, decltype
10:59:35 <clahey> I don't know why I would want such a thing.
10:59:55 <mcstar> that type of object orientation is supposed to be too complex to provide meaningful type inference, thats what i heard
11:00:00 <clahey> My biggest fear about switching to haskell is that I want other people to be able to maintain my code.
11:00:11 <clahey> mcstar: That does make sense.
11:00:33 <monochrom> everyone here is able to maintain your code
11:01:11 <chrisbuchholz> monochrom: im not, yet anyways
11:01:47 <clahey> monochrom: Yeah, but that's not a huge portion of the population.
11:01:50 <mcstar> you wouldnt ask a python or C programmer to maintain your c++ code
11:01:53 <nand`> there is lots of code I'm unable to maintain
11:01:58 <nand`> simply due to not wanting to deal with it
11:02:09 <clahey> mcstar: Right, but there's a lot more python programmers than haskell programmers.
11:02:10 <nand`> so there's a refutation of the ‘everyone’ property
11:02:11 <tac> clahey: "I wonder what C++ would be like if it had _____" is why C++ is so terrible now.
11:02:40 <mcstar> nand`: theres a difference between being able to or being willing to
11:02:51 * nand` wonders what C++ would be like if it had a halting oracle
11:02:59 <monochrom> no no, don't count "how many programmers". count "how many programmers want to do this"
11:03:13 <mcstar> i wonder what the world would look like, if c++ didnt exist
11:03:14 <nand`> mcstar: to me, willingness factors into ability
11:03:28 <mcstar> or bjarne
11:03:30 <clahey> And of course, if early people considering python had said "Eh, there's more perl programmers than python programmers"...
11:03:46 <monochrom> there are a lot more python programmers, but a lot fewer python programmers who want to maintain your code. they already have the jobs they want, not going to switch
11:04:11 <monochrom> there are a lot fewer haskell programmers, but a lot more haskell programmers who want this job
11:04:19 <clahey> monochrom: Well, I'm thinking more in terms of unpaid open source stuff, not jobs.
11:04:22 <mcstar> c++ cannot be more terrible than it was before
11:04:34 <clahey> monochrom: I'm not considering starting a company, I'm considering moving my open source project from python.
11:04:40 <nand`> mcstar: for example of the extreme, if I had some mental disorder that gives me traumatizing panic attacks whenever confronted with such code; I would clearly not be able to maintain it, even though I have the technical knowledge of the concepts
11:04:52 <clahey> monochrom: And it's a fairly small group of people that would be interested in the program in the first place.
11:04:59 <nand`> despite it only being a purely emotional restriction
11:05:04 <mcstar> wtf
11:05:12 <mcstar> masturbate elsewhere nand`
11:06:01 <klr> haskell is for smart people, fuck this
11:06:10 <Iceland_jack> What is up with klr?
11:06:22 <mcstar> did he hit a wall with something?
11:06:35 <monochrom> does anyone want to bet: 10 minutes later, klr will be back asking another haskell question? :)
11:07:32 <clahey> I've been considering whether it would make sense to make a set of code design decisions that limited what parts of the language you could use.
11:07:38 <clahey> In a particular project that is.
11:07:46 <clahey> For instance, no pointless pointless syntax.
11:08:00 <clahey> I enjoy it right now, but it does make things harder to read.
11:08:04 <nand`> design guidelines exist for pretty much this purpose, I guess
11:08:12 <Iceland_jack> What nand` said
11:08:15 <nand`> eg. ‘readability and clarity of intent over size’
11:08:17 <clahey> guidelines, that's the word I was looking for.
11:08:48 <Iceland_jack> Personally I think point-free syntax be avoided in most cases, but I think it's not the prevailing opinion at #haskell
11:08:51 <mcstar> clahey: you sound like as if you wanted to base a business on haskell
11:09:13 <Iceland_jack> Except for something like: numberValue = id
11:09:25 <nand`> there are certain kinds of point reductions I perform without question
11:09:28 <akosch> I'm a confused bit with arrows in HXT: how can I filter elements based on their childrens attributes, but extract information of the parents?
11:09:29 <nand`> for example, eta reduction
11:09:51 <clahey> mcstar: Not a business, but an open source project has a lot of the same requirements.
11:10:09 <mcstar> clahey: but you seem to be serious about this
11:10:32 <mcstar> i wish i had something productive to do with it, too
11:11:08 <nand`> next gen design guidelines: base a library on some mathematical ‘theme’, make all design decisions adhere to this theme
11:11:13 <nand`> eg. monoids (package diagrams)
11:11:15 <clahey> mcstar: I have some particular things in mind, yeah.
11:12:08 <mysticc> I have, data A = forall a . A a .. Is it possible to write say Show instance for A without adding Show a constraint in the datatype but in the instance only ?
11:12:38 <rwbarton> no
11:12:43 <rwbarton> that would be a different type entirely
11:12:48 <parcs`> no, but you can if you have 'data A c = forall a. c a => A a'
11:12:50 <clahey> mysticc: I.e., you want A a to be of Show if a is?
11:13:19 <monochrom> you can write an informationless Show instance...
11:13:23 <parcs`> i.e you can if you parameterize the existential type by a constraint-kinded variable
11:13:29 <ocharles> how can I do a heterogeneous list fold? I have an operator (:.) :: a -> b -> a :. b, and I want to fold [a] into a :. a :. :. a ...
11:13:29 <mysticc> clahey: yeah .. but I don't want to add the constaint in data type
11:13:40 <ocharles> foldl' is no good, because that expects the result type to remain the same
11:13:45 <ocharles> but the type changes after each fold
11:13:56 <mysticc> monochrom: Whats informationless show class?
11:14:07 <monochrom> like this:
11:14:08 <scooty-puff> instance Show a => Show (A a)
11:14:11 <monochrom> > getLine
11:14:13 <lambdabot>   <IO [Char]>
11:14:17 <scooty-puff> o, ignore me
11:14:23 <mysticc> parcs`: Whats constraint kinded variable?
11:14:52 <parcs`> ignore me
11:15:03 <clahey> ocharles: How does the type change?
11:15:17 <clahey> ocharles: Adds an extra layer of [] or something like that?
11:15:31 <ocharles> well if I have [a, a] then the final output is a :. a
11:15:31 <rwbarton> parcs`: the ol' hit-and-run, eh :)
11:15:34 <mysticc> parcs`: Is that possible what you gave ?
11:15:41 <ocharles> but if I have [a, a, a], then the type is a :. a :. a
11:15:49 <clahey> ocharles: Then what's the type of your function?
11:15:56 <ocharles> so each fold adds a ":. a" to the equation
11:16:05 <ocharles> clahey: that I want to fold with? (:.) :: a -> b -> a :. b
11:16:08 <mcstar> substitute (:.) for (:) ?
11:16:16 <ocharles> then it would be homogeneous
11:16:18 <monochrom> but really, what do you want the Show instance do? specifically?
11:16:18 <clahey> ocharles: No, what's the final type of the fold?
11:16:23 <clahey> ocharles: It can't be done.
11:16:25 <ocharles> clahey: that depends on whatever is in [a]
11:16:32 <ocharles> urgh
11:16:35 <ocharles> oh!
11:16:39 <clahey> ocharles: You can't have the type of a function be dependent on the value passed in.
11:16:44 <ocharles> [a] is actually fine
11:16:45 <scooty-puff> a perhaps more general version of a question i asked earlier: using DataKinds, can && and || be implemented in the type system that allows for bidirectional inference - a || b, you know not both a and b are False, etc.
11:16:50 * ocharles picard face palms
11:16:51 <ocharles> :)
11:17:01 <mcstar> ocharles: yeah, what you want is isomorph with a list
11:17:08 <ocharles> indeed
11:17:20 <ocharles> i thought I actually had a :. b :. c ... ,but b ~ a and c~a
11:17:25 <ocharles> so it's isomorphic to [a], indeed
11:17:31 <scooty-puff> i guess, not ||, more of \/
11:17:34 <scooty-puff> bah
11:19:08 <mysticc> what is meant by (?x :: Int)
11:19:29 <Peetookh> Hey
11:19:39 <Peetookh> Where the haskell are used?
11:19:49 <mcstar> where is haskell used?
11:19:54 <beaky> Peetookh: Web development
11:19:54 <mcstar> where is haskell used in the real world?
11:19:54 <Peetookh> Yeap
11:19:59 <Peetookh> yes
11:20:21 <Peetookh> Like Obj–C in for iOs development or Java for Enterprise
11:20:28 <dmwit> ?wiki haskell in industry
11:20:28 <lambdabot> http://www.haskell.org/haskellwiki/haskell_in_industry
11:20:31 <monochrom> mysticc: that's implicit parameters. I know not further
11:20:39 <Philippa> Haskell is used in spaces where you're allowed to run native binary apps
11:20:40 <Peetookh> Or C for system and lowlevel coding
11:20:44 <mcstar> sticking with stereotypes, haskell is for programming laguage research
11:20:58 <beaky> haskell is also for writing theorem provers and compilers ^^
11:20:59 <Philippa> so Haskell gets used for not-quite-so-lowlevel system coding sometimes
11:21:35 <Philippa> we know it's seen some use in finance - one company was using it as glue in-between a C library and Excel, for example
11:21:47 <Philippa> well, not /just/ glue, there was algorithmic stuff happening on top of the C
11:21:53 <hpaste> rwbarton pasted “either or both” at http://hpaste.org/76701
11:22:05 <rwbarton> scooty-puff: does ^ look like what you want?
11:22:07 <nand`> there are operating systems and kernels written in Haskell
11:22:12 <nand`> and they're fairly cool, conceptually
11:22:18 <nand`> because they're based on static, type-directed safety
11:22:24 <nand`> and compile time proofs
11:22:29 <monochrom> I want to know what Peetookh thinks what python "is for"
11:22:48 <nand`> like “how do I ensure no piece of malware will even theoretically be able to access kernel code?”
11:22:59 <Peetookh> Python?
11:23:07 <monochrom> yes python
11:23:13 <mcstar> yeah, the brainchild of guido
11:23:21 <callen> I'm loathe to pick the 32-bit version of haskell platform. Is it really that big a deal?
11:23:26 <monochrom> I mean must you limit each language to one domain?
11:23:28 <callen> if I use the 64-bit edition?
11:23:30 <Clint> only if you're on a mac
11:23:31 <rwbarton> scooty-puff: when i tried to define a "first (Pair MNothing MNothing)" case I got a type error, so that is promising
11:23:31 <Peetookh> For peoples that cannot into Java or ASP.NET for Web Development
11:23:38 <callen> Clint: I am, what's the story on that?
11:23:50 <callen> Clint: am I setting myself up for unexpected-hurt if I use the 64-bit edition?
11:23:58 <Clint> i dunno, ask luite
11:24:01 <Peetookh> Oh, and i prefer Per
11:24:03 <Peetookh> Perl
11:24:06 <nand`> Peetookh: what's C++ used for, then?
11:24:15 <pckt> What's clojure for then?
11:24:19 <hiptobecubic> go hask
11:24:23 <hiptobecubic> oops :)
11:24:24 <nand`> I'm interested in prolog too
11:24:24 <callen> pckt: prolog interpreters
11:24:30 <hpaste> scooty-puff annotated “either or both” with “either or both (annotation)” at http://hpaste.org/76701#a76702
11:24:40 <callen> luite: 64-bit Mac Haskell platform, why shouldn't I use it? is it that big of a deal?
11:24:48 <scooty-puff> rwbarton: o - let me try playing with it
11:24:50 <Peetookh> Gamedev, Forms App, maybe drivers
11:24:52 <scooty-puff> i think i annotated too soon
11:25:03 <mcstar> what is a forms app?
11:25:13 <Peetookh> Like QT
11:25:17 <beaky> what's Scala for?
11:25:21 <mcstar> gui development then
11:25:25 <nand`> ‘forms app’ makes me think .NET's ‘Forms’ library
11:25:30 <pckt> People who like the idea of java but hate java
11:25:38 <nand`> which is the language-specific wrapper of the Win32 GUI stuff
11:25:49 <beaky> what's brain*** for
11:25:53 <beaky> brain****
11:25:58 <callen> beaky: writing a brainfuck interpreter.
11:26:02 <rwbarton> ****ing your brain, obviously
11:26:07 <Peetookh> Scala? I dont know, cuz i didnt meet itw
11:26:11 <beaky> :D yeah it's great for proving some esoteric languages turing complete
11:26:18 <nand`> SK is better :)
11:26:22 <scooty-puff> rwbarton: that looks like it could work - do you know if theres any difference in how the type family is defined - if the first argument is used as the type variable?
11:26:27 <callen> turing-completeness is overrated.
11:26:39 <rwbarton> scooty-puff: yeah, the exhaustive pattern checker tends to lag behind fancy language features unfortunately...
11:26:44 <Peetookh> Bump, anowns
11:26:54 <Peetookh> Oh srry that wasnt to you
11:26:55 <rwbarton> scooty-puff, do you mean if I "pattern match" on b instead of a?
11:27:00 <rwbarton> or what
11:27:06 <scooty-puff> yes
11:27:11 <nand`> Peetookh: what's Agda used for?
11:27:11 <scooty-puff> that
11:27:25 <rwbarton> it still compiled
11:27:28 <Peetookh> >Functional
11:27:32 <Peetookh> I didnt use it
11:27:41 <Peetookh> And i want to learn haskell
11:27:43 <rwbarton> and it still doesn't compile with the extra MNothing MNothing case
11:27:57 <mcstar> Peetookh: make sure you really want to learn haskell, and then go ahead
11:28:08 <nand`> Peetookh: if you do, I can recommend LYAH
11:28:12 <mysticc> parcs`: If I use constraint kind what is the identity for constraint or what type I will use when I want no constraint? I am using something like data A cxt = forall a . cxt a => A a
11:28:16 <scooty-puff> rwbarton: i guess i'm trying to think of an example of using too many type variables somewhere - but see as the Pair's k will always be True where i use it, i wouldn't think so
11:28:24 <scooty-puff> rwbarton: thanks for the example!
11:28:36 <clahey> Peetookh: I used haskell to do my Crypto homework.
11:28:39 <beaky> have a goal in mind when learning a new language
11:28:39 <clahey> That's how I got into it.
11:28:47 <rwbarton> i am not really sure how well this will work in practice, yeah
11:28:55 <beaky> like: "I want to write a purely-functional roguelike!"
11:29:00 <nand`> I use Haskell to generate slides for my presentation; at least, I will be shortly
11:29:04 <rwbarton> scooty-puff: oh let me try another thing
11:29:09 <scooty-puff> k
11:29:29 <mcstar> i use haskell to procrastinate
11:29:37 <monochrom> the goal will demoralize you, if you later find that you cannot reach it in 2 weeks
11:29:38 <clahey> mcstar: Oh god, I'm so good at that.
11:29:39 <joeyh> I'm trying to load both Control.Monad.State.Strict and Network.Protocol.XMPP, and this seems to fail, due to the former being in both mtl and monads-tf. Help?
11:29:59 <scooty-puff> rwbarton: i would guess, but am not at all certain, that if various instances on MMaybe used a type var for k, you might get issues
11:30:05 <clahey> monochrom: That would be one reason why one week's homework is a good goal.
11:30:18 <hpaste> rwbarton annotated “either or both” with “either or both (annotation)” at http://hpaste.org/76701#a76703
11:30:24 <clahey> I'm pretty happy with my microxml parser.  I went though and annotated it with types.
11:30:25 <rwbarton> scooty-puff: you might like that one better?
11:30:27 <mysticc> Is there a Identity for constraint. I have data A cxt = forall a . cxt a => A a .. What should be the type when I want no constraint ?
11:30:27 <nand`> I use Haskell + package lens as a drop-in replacement for shattered corrective eyewear
11:30:41 <monochrom> haha nand`
11:31:05 <mcstar> i prisms in my glasses, i guess haskell isnt good at them
11:31:05 <nand`> I've been meaning to switch to zippers, though
11:31:09 <mcstar> i have*
11:31:50 <joeyh> if I -ignore-package monads-tf , it hides Network.Protocol.XMPP
11:32:24 <monochrom> mysticc: I think you have to make one
11:32:48 <nand`> I use Haskell+zippers to read each word on each line on each page in a book on the leftmost hand on my arm on my appendages
11:32:52 <mysticc> monochrom: Something like empty class ?
11:33:00 <monochrom> yeah
11:33:11 <joeyh> if I -ignore-package mtl, I can't use things like Data.Bits.Utils
11:34:06 <monochrom> which package has Network.Protocol.XMPP?
11:34:46 <joeyh> network-protocol-xmpp
11:34:54 <scooty-puff> rwbarton: got worried for a second - tried doing some redundant instances (which succeeded), but thankfully, Or False False = True always failed
11:35:12 <parcs`> mysticc: good point, there wouldn't be any
11:37:36 <parcs`> mysticc: you would have to create a type family that takes a Maybe (* -> Constraint) and returns a Constraint
11:37:38 <parcs`> mysticc:
11:38:26 <rwbarton> or a list
11:38:43 <hpaste> parcs` pasted “for mysticc” at http://hpaste.org/76704
11:38:45 <rwbarton> data A cxts = forall a. All cxts a => A a ...
11:38:48 <monochrom> then I guess you need {-# LANGUAGE PackageImports #-} and  import "mtl" Control.Monad.State.Strict
11:38:57 <rwbarton> type family All '[] a = ()
11:38:58 <joeyh> network-protocol-xmpp seems to legitimately depend on monads-tf; it uses ErrorType which is not in mtl
11:39:09 <rwbarton> type family All '(c:cs) a = (c a, All cs a) -- note untested
11:39:11 <joeyh> monochrom: aha
11:39:23 <parcs`> rwbarton: nice
11:39:25 <joeyh> my remaining hair thanks you
11:39:34 <parcs`> i wonder whether that works
11:40:54 <signalsea> Hi. question: what's the constructor AppT for, w/regard to the data type called "Type", in Template Haskell? Looks to me like maybe "apply type function" but not sure
11:41:05 <hpaste> scooty-puff pasted “:||” at http://hpaste.org/76705
11:41:13 * hackagebot digestive-functors 0.5.0.4 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.5.0.4 (JasperVanDerJeugt)
11:41:21 <scooty-puff> rwbarton: i wonder if the redundant instances add anything
11:41:47 <rwbarton> why is that even allowed
11:42:08 <rwbarton> type family instances can overlap?
11:42:12 <SamTheProgrammer> hello everyone
11:42:23 <Eduard_Munteanu> SamTheProgrammer: hi
11:42:39 <rwbarton> aha!
11:42:44 <rwbarton> it is checking that the instances are coherent
11:42:46 <joeyh> so what's the story here, it seems very unusual and problimatic for two packages to have overlapping modules
11:42:47 <dmwit> rwbarton: Yeah, *if* the overlapping instances all agree.
11:42:55 <dmwit> rwbarton: Oh, I see you discovered that restriction already. =)
11:43:01 <rwbarton> you were about 2s too late
11:43:16 <rwbarton> that is pretty clever
11:43:22 <hpaste> parcs` annotated “for mysticc” with “for mysticc (annotation)” at http://hpaste.org/76704#a76706
11:43:30 <parcs`> it works!
11:44:13 <monochrom> mtl and monads-tf certainly have a competition relation. they fight for functional dependency vs type family
11:44:50 <rwbarton> scooty-puff: so they might help, I suppose
11:45:14 <scooty-puff> hmm
11:45:16 <scooty-puff> k
11:45:21 <scooty-puff> well, i'll try both ways
11:45:53 <scooty-puff> does seem weird - especially since you can't really do that with type classes, but i guess it'd be a fundep to a third type var c, so kind of makes sense
11:45:55 <joeyh> There's also monads-fd, although at least that one is deprecated
11:45:56 <callen> I'm getting "installation failed" for Haskell Platform 32-bit on Mac OS X
11:46:07 <callen> has anyone else had this? it's just totally broken for me.
11:46:10 <monochrom> yeah, monads-fd has become today's mtl
11:46:59 <parcs`> is there a way to have a partially applied type equality constraint?
11:47:31 <rwbarton> yeah, having both instances lets it simplify the types of both \x -> EPair x MNothing and \x -> EPair MNothing x
11:47:33 <rwbarton> that is cool
11:47:40 <rwbarton> I can't even do that kind of at the value level :P
11:47:43 <rwbarton> *kind of thing
11:49:02 <Philonous> Is there a non-blocking socket interface?
11:52:19 <dmwit> Philonous: threads
11:52:54 <Philonous> dmwit:  Threads and asynchronous exceptions?
11:52:56 <dmwit> rwbarton: Yes you can.
11:53:26 <rwbarton> but I can't have ghc check that my amb program is correct
11:53:35 <dmwit> unamb, but that's true
11:53:50 <rwbarton> right
11:53:58 <dmwit> Philonous: I would avoid exceptions if at all possible.
11:54:48 <solrize> @pl (
11:54:49 <lambdabot> (line 1, column 2):
11:54:49 <lambdabot> unexpected end of input
11:54:49 <lambdabot> expecting lambda abstraction, expression or ")"
11:55:01 <solrize> @pl (\x y -> f (g x y))
11:55:01 <lambdabot> (f .) . g
11:55:11 <saml> hey, how do you represent many fields?
11:55:14 <Philonous> dmwit:  In general or just used asynchronously? And how do I nudge the Socket out of it's blocking state without exceptions?
11:55:38 <Philonous> saml:  Could you please elaborate?
11:55:40 <dmwit> "nudge the socket out of its blocking state"?
11:55:47 <saml> data Options = EmptyOption | Crop Int Int Int Int | Resize Int Int | Quality Int | More Options Options  ?
11:55:51 <dmwit> and in general
11:56:09 <saml> basically, I need 7 Int fields  where some of them are optional
11:56:31 <Eduard_Munteanu> saml: you probably want to use records
11:56:42 <dmwit> data Foo = Foo { a, b, c, d, e, f, g :: Maybe Int }
11:56:43 <Eduard_Munteanu> For optional stuff, you can use Maybe.
11:56:55 <saml> yah thanks
11:57:23 <solrize> or if the optionals have defaults you could have
11:57:32 <solrize> data Foo = Foo { a, b, c, d, e, f, g :: Int }
11:57:48 <solrize> defaultFoo = Foo {a=1, b=3, c=0, ... }
11:57:57 <solrize> myFoo = defaultFoo {b = 7 }
11:58:29 <dmwit> This is an abomination.
11:58:41 <solrize> eh?  Atom does it that way
11:58:45 <dmwit> The obviously correct way to spell defaultFoo is instance Default Foo where def = Foo { a=1, ... }
11:58:47 <solrize> what's better ?
11:58:55 <solrize> hmm
11:59:14 <solrize> is Default a standard class ?
11:59:17 <Eduard_Munteanu> Philonous: if you're using threads, you just work with blocking I/O
11:59:19 <solrize> brb
11:59:19 <dmwit> ?hackage data-default is the finest three-line package I've ever had the pleasure of installing on every machine I've ever owned
11:59:20 <lambdabot> http://hackage.haskell.org/package/data-default is the finest three-line package I've ever had the pleasure of installing on every machine I've ever owned
11:59:23 <solrize> hmm
12:02:22 <osfameron> three-line?
12:03:25 <c_wraith> instance declarations don't count as lines
12:03:30 <c_wraith> (for some reason)
12:03:33 <osfameron> https://github.com/mauke/data-default/blob/master/Data/Default.hs has many more than 3 lines
12:03:39 <dmwit> Okay, so it's more than three lines.
12:03:50 <Philonous> Eduard_Munteanu:  Well, the thread is blocking on recvFrom and I have no idea if the package will ever arrive. So I want a timeout. How do I get rid of the socket and the thread once the timeout has expired without using exceptions?
12:03:52 <osfameron>  are imports lazy?
12:03:59 <dmwit> Anyway, it's definitely one of the most content-less packages available, yet I depend on it everywhere.
12:04:04 <beaky> imports happen at compile time, don't they?
12:04:21 <beaky> or just-in-time?
12:04:24 <c_wraith> imports are only for compile-time name resolution.
12:04:25 <osfameron> so in order to declare the instances it sucks in a whole load of packages you might not be using?
12:04:31 <mcstar> the more important question is, why does teller never talk?
12:04:32 <Philonous> s/package/packet
12:04:54 <dmwit> Philonous: killThread, I guess.
12:04:55 <rwbarton> @hoogle timeout
12:04:56 <lambdabot> System.Timeout module System.Timeout
12:04:56 <lambdabot> System.Timeout timeout :: Int -> IO a -> IO (Maybe a)
12:04:56 <lambdabot> System.Event type TimeoutCallback = IO ()
12:05:05 <Philonous> dmwit:  So, exceptions.
12:05:14 <dmwit> Or what rwbarton said.
12:05:26 <rwbarton> it uses exceptions internally
12:05:55 <dmwit> ?hackage unbounded-delays may also be relevant, I think it has a timeout :: Integer -> IO a -> IO (Maybe a)
12:05:55 <lambdabot> http://hackage.haskell.org/package/unbounded-delays may also be relevant, I think it has a timeout :: Integer -> IO a -> IO (Maybe a)
12:06:14 <rwbarton> oh yeah
12:06:24 <rwbarton> the whole Int number of microseconds thing is such a dumb API
12:06:36 <rwbarton> why not just use a Rational
12:07:23 <solrize> use a double
12:07:49 <rwbarton> that would also be fine
12:08:26 <dmwit> threadDelay (-1e8)
12:08:44 <rwbarton> of course some weirdo might try to threadDelay for 1/0 or 0/0 seconds then :)
12:08:59 <dmwit> If you're going to fix it, use Ratio Nat
12:09:20 <dmwit> and correct fromInteger to fromNat while you're at it
12:09:23 <saml> f x (f y acc)       how do I make it tail recursive?
12:09:47 <saml> f :: a -> [b]     and acc :: [b]
12:09:48 <dmwit> Don't bother. Tail recursion is usually orthogonal to goodness in Haskell.
12:09:58 <tac> dmwit: why is that?
12:10:00 <saml> i see. damn it scala
12:10:03 <dmwit> Fix your mental model of how calls happen.
12:10:10 <tac> what is the relationship between tail recursion and lazy/non-strict eval?
12:10:12 <dmwit> tac: Because there's no call stack anyway.
12:10:48 <dmwit> The relationship isn't between tail recursion and lazy evaluation, it's between tail recursion and GHC's implementation of non-strict evaluation.
12:10:52 <dmwit> ?where stg
12:10:52 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
12:12:33 <dmwit> Yes, for precision I should have s/goodness in Haskell/goodness in GHC/
12:20:35 <Eduard_Munteanu> I think most of the confusion comes from languages such as C, where it's pretty easy to blow the stack up.
12:22:17 <rwbarton> okay, dumb question... how do I get ghci to import a module from a .hs file in its working directory
12:22:46 <Eduard_Munteanu> But I think tail-recursion is still desirable in the sense such algorithms don't need additional memory.
12:23:52 <till_t> rwbarton: :l filename.hs
12:24:17 <rwbarton> I don't want to load it
12:24:36 <rwbarton> I want it to be like I loaded a file that imports it
12:24:51 <rwbarton> since I think loading it will bring all its contents into scope
12:25:13 <rwbarton> seems like loading a file that imports it is the only way
12:25:38 <till_t> rwbarton: you could try :m +modulename
12:25:47 <beaky> does ghc have architecture-specific optimizations like -march=i686?
12:25:52 <beaky> or -fomit-frame-pointer?
12:26:35 <Eduard_Munteanu> beaky: indirectly, it goes through LLVM/GCC
12:27:41 <Eduard_Munteanu> beaky: see -optc
12:27:51 <mcstar> ghc still uses gcc? really?
12:28:22 <mcstar> i thought it generated asm directly
12:28:25 <mcstar> s
12:29:47 <clahey> mcstar The docs make it sound like it can do either.
12:29:52 <clahey> Or maybe not the docs.
12:30:01 <clahey> Maybe I'm thinking of RWH.
12:30:40 <snickerz777> is there a haskell beginner channel? i have some problems with cabal... :(
12:31:00 <k00mi> i remember reading generating c is deprecated, llvm and direct asm are used now
12:31:02 <fengshaun_> hi all, when using <*>, should the Applicatives of the two operands be the same?
12:31:24 <fengshaun_> I mean, can I only use <*> when both args are Maybe a, or [a], etc.
12:31:29 <mcstar> -fasm   -fllvm   -fno-code  -fbyte-code  -fobject-code
12:31:39 <mcstar> no via-c
12:32:11 <mcstar> :t (<*>)
12:32:12 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:32:24 <mcstar> f is a type variable
12:32:27 <fengshaun_> I guess that's a yes
12:32:30 <Eduard_Munteanu> snickerz777: #haskell *is* the beginner channel :)
12:32:31 <fengshaun_> thanks
12:32:31 <mcstar> you can substitute a Functor in
12:32:47 <mcstar> sry, Applicative
12:33:12 <mcstar> :t id
12:33:13 <lambdabot> forall a. a -> a
12:33:19 <mcstar> same as here
12:33:39 <mcstar> you can substitute a type in place of 'a'
12:34:05 <Philippa> snickerz777: ask away!
12:34:21 <snickerz777> oh, good! i have problems by installing of some libs with cabal, e.g lens, gloss , gtk2hs
12:35:14 <snickerz777> whenever i try to install something, i get an error
12:35:44 <rwbarton> show us the errors! http://hpaste.org
12:35:51 <rwbarton> preferably with the command you ran and the full output
12:36:57 <deech> I'm trying to wrap my head around bottom. The Wikipedia page says that it's used to represent the type of a function that doesn't return a value. So why is main :: IO ()?
12:37:55 <snickerz777> http://hpaste.org/76707
12:38:19 <rwbarton> well
12:38:21 <rwbarton> that's a new one to me!
12:38:23 <rwbarton> what os?
12:38:31 <snickerz777> linux mint
12:38:40 <snickerz777> maya
12:39:03 <crdueck_> i'm trying to understand/use the State monad, what is the best way to map a stateful function f :: a -> myState -> State myState () over a list of a's [a1, a2..] so that the result of (f a1 initialState) is used as the next state for (f a2)?
12:39:17 <rwbarton> snickerz777: http://www.haskell.org/pipermail/haskell-cafe/2011-December/097962.html
12:39:31 <rwbarton> can you install/temporarily select gnu ld rather than gold
12:40:22 <rwbarton> or I guess you will need to use gnu ld whenever linking haskell packages
12:40:55 <rwbarton> hmm
12:41:13 <snickerz777> isn#t haskel linking automatically?
12:41:15 * hackagebot type-unary 0.2.5 - Type-level and typed unary natural numbers, inequality proofs, vectors  http://hackage.haskell.org/package/type-unary-0.2.5 (ConalElliott)
12:41:35 <rwbarton> cabal uses your system linker
12:41:46 <conal> (type-unary now fixed for ghc 7.4.1.)
12:41:47 <rwbarton> it is passing a command-line argument that your peculiar linker doesn't understand
12:42:14 <rwbarton> my guess is because you have binutils-gold installed
12:43:45 <hpaste> fengshaun pasted “applicatives/functors” at http://hpaste.org/76709
12:44:03 <fengshaun_> I'm trying the code above
12:44:18 <fengshaun_> and I have no idea what is wrong
12:44:30 <snickerz777> so i'll  remove the binutils-gold package and try again.
12:44:53 <fengshaun_> I'm trying to transform an Applicative (IO, in this case) without using <-
12:45:11 <fengshaun_> can someone point me in the right direction?
12:46:28 <kirindave_> It is incredibly frustrating when people do things in GHCI that don't work as compiled code. In canonical tutorials.
12:46:37 <kirindave_> Prime example: http://hackage.haskell.org/packages/archive/conduit/0.5.2.7/doc/html/Data-Conduit.html
12:46:43 <nand`> if you don't want to use <-; there's always >>=
12:46:46 <ion> fengshaun: func3 returns an IO action. func3 . func2 . func1 <$> getLine :: IO (IO Something). You could do ‘join (func3 … getLine)’ (join :: IO (IO a) -> IO a), or its equal ‘func3 =<< (func2 . func1 <$> getLine)’
12:46:50 <nand`> but for Applicative you want <$> and <*> most likely
12:47:38 <fengshaun_> ion: Ahhh, the the code actually works, I just don't know what the hell I'm doing!  Thanks a lot!
12:48:00 <kirindave_> Does anyone know how you actually use Conduits? :\
12:48:03 <fengshaun_> nand`: I haven't yet read about >>=, I'm just reading through lyah and just got to applicatives
12:48:08 <Iceland_jack> kirindave_: no
12:48:22 <kirindave_> Cuh-razy.
12:48:37 <nand`> <- and ‘do’ notation basically desugars to >>=
12:49:12 <kirindave_> Seriously though. How on earth can something typecheck in GHCI but not typecheck in a program where you say main = <ghci line here>
12:49:18 <snickerz777> rwbarton: thank you! that helped me ;)
12:49:25 <kirindave_> Assuming it's an IO action.
12:49:39 <rwbarton> snickerz777: this is ghc 7.4 btw?
12:49:44 <nand`> kirindave_: language extensions?
12:49:49 <kirindave_> nand`: None
12:50:06 <ion> kirindave: Show the code and the error message.
12:50:06 <nand`> what's the example and the error you get?
12:50:33 <rwbarton> it looks like that example was doing overly clever things with ghci module imports
12:51:31 <kirindave_> https://gist.github.com/6cfc741ad08cbc7391fb
12:51:46 <kirindave_> Which is lifted directly from the Conduit's tutorial.
12:51:56 <snickerz777> rwbarton:ghc 7.4.1
12:52:28 <luite> kirindave_: add a type sig main :: IO ()
12:53:01 <kirindave_> luite_: I thought main had to have a type of IO ()?
12:53:25 <rwbarton> it doesn't even know your 'main' is really THE main
12:53:26 <nand`> kirindave_: not necessarily, actually; in particular the () can be replaced for any type
12:53:35 <rwbarton> since you are in a module
12:54:02 <nand`> ooh
12:54:05 <kirindave_> Fun stuff
12:54:08 <nand`> would removing line 1 fix it?
12:54:10 <nand`> without further changes
12:54:16 <rwbarton> I am curious about that too
12:54:23 <rwbarton> or with -main-is Cap.main
12:54:30 <rwbarton> my guess is no...
12:54:32 <nand`> probably the fact that main must be IO _ could be enough to fix the instance
12:54:49 <nand`> still odd that it would work in GHCi, if you ask me
12:54:52 <nand`> without type signatures, taht is
12:54:59 <rwbarton> yes but i'm not sure the type checker knows that at the point where it is typechecking main
12:55:26 <hpaste> snickerz777 pasted “cabal bmp error” at http://hpaste.org/76710
12:56:19 <nand`> snickerz777: maybe that version isn't properly backwards compatible with 7.4?
12:56:22 <mjrosenb> hey, can anyone think of a good pair of mutually recursive functions foo,bar :: Int -> Int that end up with exponential runtime?
12:56:29 <beaky> what are monads?
12:56:41 <mjrosenb> iirc, there was a neat exampl in godel, esche, bach
12:56:43 <yiannis_t> Where monads
12:56:51 <yiannis_t> @where monad
12:56:51 <lambdabot> I know nothing about monad.
12:56:53 <MostAwesomeDude> mjrosenb: What about two halves of the Ackermann function?
12:56:55 <rwbarton> yes, BSL.fromStrict is new
12:56:56 <yiannis_t> dammit :(
12:57:13 <nand`> beaky: mathematical objects
12:57:30 <rwbarton> version constraint in bmp-1.2.3.1 is too lax
12:57:38 <mjrosenb> MostAwesomeDude: how do you split it into two?
12:57:49 <nand`> snickerz777: try 1.2.1.1
12:57:56 <rwbarton> or 1.2.2.1
12:57:57 <MostAwesomeDude> mjrosenb: Hm. Good point. Ignore me!
12:58:01 <rwbarton> appears to have no fromStrict
12:58:16 <nand`> yeah worth a try; I just went on what hackage confirmed builds on 7.4
12:58:24 <rwbarton> oh yeah good idea
13:04:49 <beaky> what is wrapper transformation
13:06:16 <beaky> http://www.workerwrapper.com/
13:06:35 <adnauseam> sounds socialist
13:08:34 <kirindave_> I was going to try writing that capitalize program that has everyone's feathers ruffled
13:08:38 <kirindave_> In conduits.
13:08:49 <kirindave_> But I think this is a waste of my time. It's actually really hard to do with Conduits.
13:08:51 <nand`> that capitalize program?
13:08:54 <kirindave_> Yes
13:09:01 <nand`> I was hoping for an elaboration
13:09:13 <kirindave_> http://honza.ca/2012/10/haskell-strings
13:09:26 <kirindave_> It just turns out that there is all sorts of awkwardness
13:09:30 <kirindave_> e.g., Word8 vs. Char.
13:09:37 <kirindave_> The general lack of documentation for Conduits
13:09:46 <nand`> oh god, the ‘fi’ ligatures on that page look strange
13:09:51 <nand`> is anybody else seeing that?
13:09:54 <Cale> beaky: The heart of it is something kind of obvious. If you can do a computation more efficiently on one type than another, and you have an efficient way to convert back and forth between your two types, then a good way to get things done is just to convert to the other type, do your computation there, and convert back.
13:10:24 <Ralith> kirindave_: seems like it should be pretty easy
13:10:36 <kirindave_> Ralith: It might be
13:10:40 <kirindave_> But Conduit's is not well documented.
13:10:44 <Ralith> source from file, decode as utf8, split into words, capitalize, merge, encode, write out.
13:10:46 <rwbarton> nand`, yes
13:10:53 <beaky> ah
13:10:58 <kirindave_> Ralith: Also, you probably don't want to do it that way
13:11:03 <beaky> maybe I can use that to optimze the turing machine further
13:11:03 <kirindave_> Ralith: As it will be obscenely slow.
13:11:07 <Ralith> why do you say that?
13:11:09 <kirindave_> As it _is_ obscenely slow.
13:11:18 <kirindave_> Ralith: Oh I dunno the entire premise of the article is that it is sow.
13:11:22 <kirindave_> Err, slow.
13:11:28 <Ralith> um, you realize that we're talking about conduits, right?
13:11:42 <kirindave_> I think part of the problem is "words"
13:11:48 <kirindave_> But yes, conduits is in this equation.
13:11:51 <Cale> beaky: One particularly useful example is in cases where you're doing a lot of concatenation of lists
13:11:57 <Ralith> yes, you do that piecewise
13:11:58 <Cale> beaky: For example, consider this program:
13:11:58 <kirindave_> I figured it'd be an nice easy thing to do with conduits.
13:11:58 <Ralith> it's not slow at all
13:12:18 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
13:12:20 <kirindave_> Ralith: Well I am not sure how to do it. Conduits doesn't, for example, talk about how to write new conduits.
13:12:23 <Cale> inorder Tip = []
13:12:27 <kirindave_> Ralith: In its documentation
13:12:31 <Ralith> it would; I've written comparable trivialties based on all of one example and fifteen minutes with the docs.
13:12:34 <Cale> inorder (Branch x l r) = inorder l ++ [x] ++ inorder r
13:12:38 <kirindave_> So you look at the source and it's, somewhat awkward.
13:12:47 <Ralith> that's not been my experience.
13:12:56 <kirindave_> Ralith: http://hackage.haskell.org/packages/archive/conduit/0.5.2.7/doc/html/Data-Conduit.html
13:13:05 <mcstar> Not sure if I want to continue learning Haskell after this.
13:13:13 <Ralith> yes, I'm familiar with the docs, as I said a minute ago.
13:13:16 <kirindave_> Ralith: The actual documentation on how to write conduits? Very vague.
13:13:21 <Cale> beaky: This program suffers from slowness on leftward leaning trees, because xs ++ ys takes O(length xs) steps to compute, which leads to a quadratic worst case for inorder.
13:13:31 <Clint> it was less vague several versions ago
13:13:42 <beaky> right
13:13:43 <mcstar> i like how that guy forgot profiling anything at all!
13:13:48 <zeiris> Has anyone gotten gitit plugins to work without Haskell installed on the system?
13:13:50 <kirindave_> Clint: Documentation regression, I guess.
13:13:58 <kirindave_> But the net result is that I certainly am having trouble.
13:13:59 <mcstar> i think douchebag fits
13:14:17 <kirindave_> mcstar: The author is upset. And so they misdirect that frustration into their attitude.
13:14:19 <nand`> edwardk: Is it possible to mix Zippers with Effective yet?
13:14:22 <kirindave_> mcstar: But it's a legitimate complaint.
13:14:24 <Cale> beaky: So what we can do is to replace lists by a type which supports faster concatenation. Specifically, a great choice here is to replace lists of type [a] with functions [a] -> [a] which add elements to the beginning of other lists.
13:14:37 <Cale> [] becomes id
13:14:41 <Cale> [x] becomes (x:)
13:14:45 <Cale> and (++) becomes (.)
13:14:47 <kirindave_> Ralith: If you have resources on using conduits that are more concrete and helpful than that documentation, I humbly request you give me the link.
13:14:59 <kirindave_> Ralith: Becuase as it stands it's quite difficult for me.
13:15:12 <Cale> Since f . g evaluates in constant time while xs ++ ys is linear, this improves the performance:
13:15:15 <Cale> inorder' Tip = id
13:15:28 <Cale> inorder' (Branch x l r) = inorder' l . (x:) . inorder' r
13:15:50 <kirindave_> For example, why in all the code does it use the maybe function?
13:15:54 <Ralith> kirindave_: as I said a few minutes ago, I found the above adequate.
13:16:00 <Cale> and then we can turn the resulting function [a] -> [a] back into a list
13:16:06 <Cale> by applying it to an empty list:
13:16:12 <Cale> inorder t = inorder' t []
13:16:24 <kirindave_> Ralith: If you do feel inspired to write a program to quickly capitalize words, please consider msg'ing me. I'd love to see it.
13:16:33 <Cale> and we've converted a quadratic time program into a linear time one
13:16:37 <mcstar> 'utf-8' is basically ascii if you only have 'lorem ipsum' in that file
13:16:37 <kirindave_> Ralith: I must just not be as capable of parsing these docs as you.
13:16:44 <mcstar> i thin Char is much bigger
13:16:47 <Ralith> or you lacked the examples
13:16:54 <Ralith> or you just haven't spent the time experimenting :P
13:16:55 <mcstar> > minBound :: Char
13:16:56 <Cale> The whole thing about the worker/wrapper transformation is just formalising and generalising what we did to this program to make it more efficient.
13:16:57 <lambdabot>   '\NUL'
13:17:01 <mcstar> > maxBound :: Char
13:17:02 <lambdabot>   '\1114111'
13:17:09 <kirindave_> Ralith: I cannot even get a custom conduit to compile. :\
13:17:27 <kirindave_> Ralith: I know how to do it in Enumerator. :\
13:17:40 <mcstar> > length [minBound :: Char .. maxBound]
13:17:42 <lambdabot>   1114112
13:17:45 <Cale> Well, it also generalises a lot of other strategies for improving performance
13:17:57 <hpaste> snickerz777 pasted “wxc build error” at http://hpaste.org/76712
13:17:58 * Ralith tries to remember where the github repository for the project he played with conduits on is
13:18:36 <mcstar> also, why would you break the file by lines?
13:19:20 <beaky> so worker/wrapper transformation is about exploiting efficient conversion between types in order to take advantage of more efficient operations in one type?
13:20:00 <Philippa> beaky: pretty much. That, and making sure the 'user' never has to know
13:20:16 <Philippa> it also means that the more you can do 'inside the wrapper' at once the better
13:20:28 <Philippa> which can have interesting consequences if you're working with EDSLs
13:20:34 <hpaste> Ralith pasted “Custom conduit example” at http://hpaste.org/76714
13:20:47 <Ralith> kirindave_: ^
13:21:04 <Cale> beaky: yeah
13:21:12 <slack1256> how do I install a package with the second set of dependencies instead of the first in cabal?
13:21:27 <kirindave_> Ralith: The use of maybe is helpful here. I was very confused.
13:21:34 <Cale> beaky: and even fairly inefficient conversions between types can work out reasonably well, if you have a lot of operations to do.
13:22:00 <slack1256> the highlighting-kate package is broken in 7.6.1 with regex-pcre-builtin but no with pcre-light, how do i specify it?
13:22:11 <Cale> beaky: For an example of that, you could read about stream fusion
13:22:26 <Ralith> kirindave_: I used that conduit to provide interactive keyboard control for testing my ICFP contest submission.
13:22:49 <mcstar> C.cons (toUpper (C.head s)) (C.tail s)
13:22:56 <kirindave_> Ralith: Ty
13:23:14 <mcstar> vs.
13:23:16 <mcstar> w.capitalize()
13:23:25 <mcstar> and  words[i] = capitalize(words[i])
13:23:32 <mcstar> and he wonders why 10s
13:23:45 <Philippa> Cale: DSLs also make an excellent site for worker/wrapper, though we often don't view it that way
13:23:58 <Clint> wow, that's pretty different from 0.4
13:24:00 <Ralith> kirindave_: it should be fairly clear to see how to convert that into something that converts a stream of text into a stream of words, and then you can use Conduit.List.map for the actual capitalization.
13:24:14 <Philippa> (which is to say: stream fusion isn't the only way to make the chunk behind the wrapper 'big')
13:24:44 <Ralith> kirindave_: also refer to http://hackage.haskell.org/packages/archive/conduit/0.5.2.7/doc/html/Data-Conduit-Text.html for encoding/decoding.
13:24:57 <kirindave_> Ralith: I don't even really want to encode or decode the thing
13:25:06 <kirindave_> Ralith: I don't even want to make words.
13:25:15 <kirindave_> Ralith: That's outside the scope of the requirement.
13:25:20 * Ralith shrug
13:25:25 <Ralith> they're cheap enough as streaming operations.
13:25:34 <kirindave_> What's required is that alpha characters after space characters should be capitalized.
13:25:46 <Ralith> to get characters, you must perform decoding.
13:25:53 <kirindave_> Yeah, unfortunately. :\
13:25:57 <Ralith> this is definitional.
13:26:27 <Ralith> you could instead write a program that did a bytewise operation that under some circumstances had comparable effect, but that'd be more effort.
13:26:29 <kirindave_> Ralith: Data.ByteString.Char8 is my friend here.
13:26:40 <Ralith> -_-
13:26:50 <Ralith> do it right first, then worry about hacking it up :P
13:27:16 <Ralith> kirindave_: why do you want to avoid decoding?
13:27:28 <Ralith> or any of the rest for that matter
13:27:40 <kirindave_> Ralith: Wording would require also preserving whitespace.
13:27:50 <kirindave_> Ralith: I dislike that consideration.
13:28:13 <Ralith> okay, so inline the capitalization into the custom conduit and don't split it up into words first.
13:28:27 <kirindave_> Yep.
13:29:12 <hpaste> Okasu pasted “Haskell CV” at http://hpaste.org/76715
13:29:37 <Okasu> guys, can you explain why this stuff eats all of my memory?
13:30:49 <Ralith> you should still perform proper encoding and decoding.
13:32:31 <kirindave_> Ralith: So that I can use Text.
13:32:33 <mmirman> concurrent tagless linear lambda calculus interpreter: https://github.com/mmirman/order/blob/master/Pi.hs  enjoy.
13:32:39 <kirindave_> Ralith: Which has been notoriously finnicky.
13:32:47 <kirindave_> Ralith: One thing I don't get about your code.
13:33:08 <kirindave_> Ralith: If you have no new input, but still have stuff in accum, how does that drain?
13:33:26 <kirindave_> Ralith: Does it not?
13:33:41 <Ralith> kirindave_: I'm not sure I follow
13:34:08 <kirindave_> Ralith: At each run of helper, it awaits, and appends that to accum.
13:34:28 <Ralith> no
13:34:29 <kirindave_> Helper then takes the first item out of the bytestring
13:34:50 <Ralith> er, rather
13:34:59 <Ralith> what do you mean by drain?
13:35:00 <kirindave_> So if you enter accum but Await returns Nothing
13:35:09 <kirindave_> Then accum may not be empty.
13:35:42 <Ralith> ah
13:35:46 <Ralith> probably a legitimate bug
13:36:00 * kirindave_ does the jackie chan meme at Conduits. :\
13:36:33 <Ralith> as I mentioned, this was used for interactive input, so I doubt accum being non-empty ever got tested
13:37:05 <kirindave_> Yeha
13:37:42 <hpaste> nand` pasted “Capitalize” at http://hpaste.org/76717
13:37:46 <Ralith> the correct thing to do there would probably be to yield Actions until the input is entirely consumed, and only then await again
13:37:51 <nand`> kirindave_: ^ my attempt
13:37:55 <Ralith> thereby obviating the need for an accumulator at all
13:38:03 <nand`> I didn't test for performance :)
13:38:03 <kirindave_> nand`: ?
13:38:08 <nand`> at the ‘capitalize’ program
13:38:32 <kirindave_> nand`: I am quite sure it will be slow.
13:38:39 <nand`> probably
13:38:42 <kirindave_> nand`: The problem is all the consing.
13:38:58 <kirindave_> The only way Haskell can do that quickly is to do it in a streaming fashion.
13:38:58 <nand`> I'd be interested in how much slower than the naive string version from that blog post, actually
13:39:01 <Lutin`> Is it possible for Haskell to ensure totality of functions?
13:39:15 <kirindave_> AFACIT, this is sort of the secondary point Oleg was on about.
13:39:19 <Ralith> the only way *anything* can do this quickly is in a streaming fashion; some environments just have smaller constant factors.
13:39:39 <kirindave_> Ralith: Or their semantics are so weak that they can just mutate the hell out of things e.g., python
13:39:40 <nand`> Lutin`: not really
13:39:55 <kirindave_> It's also one of those insights from using Codensity
13:40:03 <Ralith> kirindave_: you are welcome to use ST!
13:40:19 <kirindave_> Ralith: Hah yeah well you are right that streaming is the correct approach.
13:40:31 <Lutin`> nand`: Alright, this problem is probably more suited to Agda anyways
13:40:35 <nand`> Lutin`: it can't be done via the type system, since every Haskell type has ⊥ as member; thus you can match any type with ‘undefined’; and there aren't any language extensions I know of to add termination/exception checking
13:40:37 <nand`> yeah
13:40:57 <mcstar> read the file into a mutable vector, go over it, and capitalize, and write out
13:41:02 <Lutin`> Also I want a space-cadet keyboard :[
13:41:21 <mcstar> do this as many times as needed for the given file
13:41:26 <nand`> I like my approach for its style, not its performance
13:41:35 <nand`> ‘byWords._head %~ toUpper’
13:42:03 <hiptobecubic> i think i borked it
13:42:42 <Lutin`> I would kill for this keyboard: http://upload.wikimedia.org/wikipedia/commons/4/47/Space-cadet.jpg
13:42:49 <clahey> nand`: How do you type _|_?
13:42:52 <hiptobecubic> why? it's terrible.
13:42:59 <hiptobecubic> clahey, _|_
13:43:06 <mcstar> lol
13:43:22 <shachaf> I press the ⊥ key on my keyboard.
13:43:25 <mcstar> ⊥
13:43:28 <mcstar> yeah, easy
13:43:30 <shachaf> (It's next to the ⊤ key.)
13:43:37 <hiptobecubic> :þ
13:43:55 <mcstar> i bound it to the print scren button
13:44:02 <mcstar> ⊥
13:44:03 <hiptobecubic> I need to fix my bindings
13:44:09 <mcstar> ⊥⊥⊥⊥⊥⊥⊥⊥
13:44:11 <nand`> @ask edwardk Do you think you could provide lenses like ‘_words’, ‘_lines’? Since the existing words/unwords and lines/unlines probably violate some lens laws; a more rigorous Iso could be made which simply splits on literal ' ' or '\n' characters; thus preserving eg. "a  b" ⇔ ["a","","b"]; "a \n b" ⇔ ["a","\n","b"]; furthermore (byLines, byWords) = (_lines.traverse, _words.traverse)
13:44:12 <lambdabot> Consider it noted.
13:44:14 <hiptobecubic> I have all of these charactersI don't care about and will never use
13:44:15 <mcstar> i can do as many as ai want
13:44:44 <nand`> clahey: it's Alt Gr + Shift + b for me
13:44:58 <clahey> I was hoping there would be a compose sequence for it.
13:45:02 <clahey> Like →
13:45:06 <clahey> And ←
13:45:11 <Lutin`> Make one?
13:45:11 <mcstar> heh, i was copying nand's first bottom symbol
13:45:11 <nand`> that's Alt Gr + h for me
13:45:13 <hiptobecubic> a compose sequence?
13:45:18 <mcstar> so they are just replicas of it
13:45:37 <clahey> Lutin`: I didn't know I could add compose sequences.  I'll look into that.
13:45:49 <Lutin`> clahey: Yep look at your keymaps
13:46:28 <Ralith> clahey: ~/.XCompose
13:46:35 * Ralith has a sizable one
13:46:43 <Bigcheese> Haskel platform is supposed to include the network package, right?
13:47:19 <Bigcheese> Right now when I try to cabal install a package that needs it, it tries to compile network 2.4.0.0 and fails :(
13:47:54 <clahey> hiptobecubic: On linux at least, there's a compose key, so you just type reasonable sequences instead of having to memorize stuff.
13:47:56 <Bigcheese> I have ghc 7.4.1 and haskell platform 2012.2
13:47:57 <Lutin`> Bigcheese: http://www.haskell.org/platform/changelog.html
13:48:09 <hiptobecubic> clahey, "a compose key" ?
13:48:12 <nand`> clahey: like ‘compose b o t t o m’ ?
13:48:15 <clahey> compose + - → ±
13:48:17 <Bigcheese> Lutin`: yeah, I saw that.
13:48:21 <Lutin`> Bigcheese: It includes 2.3.0.13 not 2.4.0.0
13:48:26 <clahey> nand`: I was going to go with compose _|_
13:48:35 <nand`> fair enough :)
13:48:40 <clahey> hiptobecubic: I have it bound to my windows key.
13:48:53 <nand`> I use B for ‘bottom’; ‘b’ is already taken for ‘bijection’; and ‘h’ is for ‘hom’
13:48:58 <clahey> hiptobecubic: I type <compose> - > to get →
13:48:59 <Lutin`> clahey: What os?
13:49:04 <Bigcheese> Lutin`: the cabal file just requires network, not any specific version. So I have no idea why cabal is deciding it needs to go build 2.4.0.0
13:49:05 <clahey> Lutin`: 10.04.
13:49:12 <Lutin`> So Ubuntu
13:49:18 <clahey> I'm looking up instructions to update it now.
13:49:19 <clahey> Yes.
13:51:33 <Bigcheese> cabal info even shows that it already has network installed.
13:52:40 <mcstar> why not script your irc client to unicodify latex sequences?
13:53:09 <clahey> mcstar: That's actually a pretty cool idea.
13:53:17 <sclv_> reference request -- hewitt claims that scheme/the lambda calc + state don't give you actors
13:53:18 <clahey> mcstar: But then I couldn't type them into my haskell programs.
13:53:26 <mcstar> weechat supports at least python, perl, lua
13:53:34 <sclv_> the original scheme papers claimed they did, at least semantically
13:53:36 <mcstar> clahey: i hope you dont want to
13:53:40 <clahey> mcstar: Just a joke.
13:53:54 <sclv_> does anyone know if there are serious ppl seriously disagreeing w/ hewitt
13:54:02 <sclv_> or if he changed his def of actor over time?
13:54:14 <Eduard_Munteanu> clahey: you can use SCIM, that should work with most X apps.
13:54:22 <sclv_> or if there's anything resolved in this debate in terms of scholarship
13:54:29 <clahey> SCIM?
13:54:56 <Eduard_Munteanu> clahey: yeah, it's got a Latex table
13:55:10 <Eduard_Munteanu> E.g. I type \mu for µ
13:55:44 <beaky> when should I use typeclasses over algebraic dat atypes
13:56:01 <clahey> Eduard_Munteanu: Cool.
13:56:04 <beaky> \left(\right)
13:56:09 <clahey> I type compose m u
13:56:29 <clahey> What symbol is used for =>?
13:56:53 <beaky> if I add/remove/change a value ctor in an ADT, I have to touch every single bloody pattern in my code ^_^ what should I do instead?
13:56:55 <Eduard_Munteanu> With UnicodeSyntax? Not sure.
13:57:05 <mauke> ⇒
13:57:11 <rwbarton> I guess the closest latex equivalent is \Rightarrow ?
13:58:03 <Eduard_Munteanu> beaky: well, yes, ADTs are closed things in that sense. Typeclasses are open.
13:58:15 <mcstar> beaky: you can try records, and not pattern matching on it, but using the accessor functions
13:58:41 <rwbarton> welcome to the expression problem
13:58:51 <mcstar> 'you know'....
13:59:04 <Eduard_Munteanu> So ADTs are suitable when you know all the possible cases beforehand.
13:59:17 <mcstar> who was that guy? ralf rommel?
13:59:30 <beaky> expression problem :(
14:00:06 <Lutin`> Eduard_Munteanu: I love you. SCIM sounds perfect
14:00:14 <beaky> in C I just code against headers, so I never have this problem for my data types
14:00:24 <clahey> I wonder if there's an appropriate symbol for >>=.
14:00:34 * Eduard_Munteanu blushes :P
14:00:45 <beaky> \mathrm{>>=}
14:01:18 <mcstar> >>= is written as >>=
14:01:21 <Lutin`> Too bad I have to be on windows right now :[
14:01:37 <mcstar> ah, yeah, the incessant update notifications
14:01:41 <mcstar> id rather die
14:01:49 <Eduard_Munteanu> beaky: I'm not sure what you mean.
14:02:06 <Lutin`> I'd rather be on my linux install but I have to use Visual Studio for this stupid C++ class
14:02:24 <rwbarton> if you never define your own types then you never encounter this problem yes. same in haskell
14:02:30 <Hsk291> how I can I have abstractions on types, e.g.,    type  T =  \ r ::* -> (Int, r)       T :: * -> * ?
14:03:41 <clahey> Lutin`: You should buy a copy of VMware Workstation.
14:03:46 <Eduard_Munteanu> Hsk291: you can't do that literally, but you can say  type T = forall r. (Int, r)
14:03:54 <Lutin`> I have workstation 9
14:03:55 <clahey> Lutin`: <standard employment disclosure/>
14:04:02 <clahey> Lutin`: Oh, what do you think?
14:04:32 <Eduard_Munteanu> Hsk291: or perhaps you want   type T r = (Int, r)   rather
14:04:38 <Lutin`> I haven't used vmware since workstation 5 or 6 so it's a big change for me lol
14:04:48 <Eduard_Munteanu> (the former isn't really useful)
14:04:58 <clahey> Lutin`: Ah.  Workstation is actually the product I work on.
14:05:08 <Lutin`> orly
14:05:22 <clahey> rly
14:05:36 <clahey> Lutin`: Have you used the remote virtual machine stuff at all?
14:05:46 <Eduard_Munteanu> Hsk291: though if you're looking to make e.g. Monad instances you need a newtype since type synonyms have to be fully applied
14:05:48 <Lutin`> I've used VMWare view client
14:05:57 <Lutin`> But I haven't done that inside workstation
14:06:22 <nand`> is there some word to describe the relationship between ‘f’ and ‘g’ if f.g = g
14:06:23 <clahey> Lutin`: I don't think we support using it as a view client, but I could be wrong.
14:06:35 <nand`> (but f is not necessarily identity)
14:06:39 <Hsk291> Eduard_Munteanu: no GHC extension can simulate that?
14:06:40 <clahey> f is a left identity for g?
14:07:08 <clahey> Lutin`: But you can connect to ESX and vCloud and other WSs.
14:07:17 <Eduard_Munteanu> Hsk291: simulate what exactly? Or why isn't the above what you want?
14:07:28 <Lutin`> clahey: Yeah I think I tried before and it didn't work. At my uni all the computers in the comp engi building are thin clients and use view client
14:08:05 <clahey> Makes sense.
14:08:27 <ragno76> ciao
14:08:42 <ragno76> !list
14:08:43 <monochrom> ragno76: http://hackage.haskell.org/packages/archive/pkg-list.html
14:09:22 <Eduard_Munteanu> Huh... I didn't know monochrom ran a bot.
14:09:57 <clahey> nand`: Wikipedia doesn't mention anything about specifying left identity for a particular object.
14:09:57 <Eduard_Munteanu> ragno76: also, hi
14:10:23 <nand`> I swear; that's like the fifth time I've seen that particular combination of lines: “ciao”, “!list” followed by a /quit in here, and only in here
14:10:47 <Eduard_Munteanu> !list
14:10:47 <monochrom> Eduard_Munteanu: http://okmij.org/ftp
14:10:56 <Eduard_Munteanu> Hrm.
14:11:02 <Eduard_Munteanu> I think monochrom is trying something.
14:12:04 <mcstar> g^-1 . f . g = e looks like a kind of group conjugate
14:12:09 <mcstar> i forgot the terminology
14:12:40 <beaky> why is mod slower than rem
14:12:55 <nand`> probably something to do with signs
14:13:05 <nand`> and checking for them
14:13:25 <tac> Monad question: Can any monad be rewritten as an instance of Prompt?
14:14:09 <Eduard_Munteanu> tac: what's Prompt?
14:14:38 <tac> http://hackage.haskell.org/packages/archive/MonadPrompt/1.0.0.1/doc/html/Control-Monad-Prompt.html
14:15:34 <tac> If I understand correctly, it allows you to build "free monads" over some base set. it gets the monad laws automatically, regardless of the underlying set.
14:15:41 <clahey> mcstar: http://en.wikipedia.org/wiki/Conjugacy_class
14:16:05 <mcstar> ah yeah
14:16:24 <mcstar> kind of homomorphism on the group
14:16:25 <mcstar> or something
14:16:53 <mcstar> anyway, looks similar if the group product is function composition
14:19:22 <Hsk291> Eduard_Munteanu: data T1 (a :: *) = T1 ; data T2 (f :: * -> *) = T2; type T3 = T2 (\ r :: * ->  T1 ((,) Int r))
14:19:29 <clahey> mcstar: Except that's not a group, but such is life.
14:20:09 <mcstar> i think it depends on what functions are we talking about
14:20:14 <mcstar> in general, it might not be
14:21:28 <mcstar> also, f.g=g , provided f /= id, g must be bottom on every argument, musnt it?
14:23:00 <clahey> I don't think so.
14:23:18 <clahey> f (a, _) = (a, a)
14:23:22 <clahey> g a = (a, a)
14:24:05 <mcstar> f and g are curried
14:24:33 <Eduard_Munteanu> Hsk291: mm, no, I'm not sure if there's an extension for that. But if you're into that sort of stuff, might as well try Agda ;)
14:25:19 <clahey> mcstar: Huh?
14:25:39 <mcstar> i dont think we allow tuples
14:25:47 <clahey> mcstar: Okay.
14:25:56 <clahey> f a:xs = [a, a]
14:26:00 <clahey> g a = [a, a]
14:26:24 <clahey> Lots of possible algebraic data types could be subbed in.
14:27:09 <clahey> mcstar: Actually, on Int.
14:27:21 <clahey> f a = (a `mod` 2) * 2
14:27:24 <clahey> g a = a * 2
14:27:58 <mcstar> f is id here
14:28:12 <clahey> No, f 3 = 4.
14:28:13 <mcstar> no
14:28:25 <clahey> Or, rather f 3 = 2.
14:28:27 <clahey> Whichever.
14:30:04 <mcstar> 0 /= a
14:30:12 <mcstar> i dont get equality
14:30:25 <mcstar> f . g /= g in your case
14:30:33 <clahey> mcstar: Why?
14:30:49 <clahey> What input value gives a different result?
14:31:22 <Lutin`> Uh
14:31:33 <mcstar> 2*((2*a)`mod`2) ==? 2*a
14:31:37 <mcstar> ((2*a)`mod`2) ==? a
14:31:42 <mcstar> (0) ==? a
14:31:48 <mcstar> 0 /= a
14:32:02 <Lutin`> Yeah
14:32:24 <clahey> Oh.
14:32:26 <clahey> Not mod.
14:32:29 <Lutin`> div
14:32:33 <clahey> `div.
14:32:34 <clahey> Thank you.
14:32:36 <dino-> Any gitit users here, is it tricky to change an existing page name and/or path? I don't mean the page title like in metadata, but the thing identifying string when creating a new page.
14:33:09 <clahey> I knew it wasn't `rem`, but my brain gave me `mod` instead of `div`.
14:33:15 <dino-> I tried some darcs mv hackery and broke my repo with a naive test
14:36:18 * hackagebot pretty-class 0.1 - Extremely simple Pretty class  http://hackage.haskell.org/package/pretty-class-0.1 (DavidFox)
14:36:32 <clahey> @check let f a= (a `div` 2) * 2; g a = a * 2 in ((\a -> (f . g) a == g a) :: Int -> Bool)
14:36:35 <lambdabot>   "OK, passed 500 tests."
14:36:43 <clahey> @check let f a= (a `div` 2) * 2; g a = a * 2 in ((\a -> f a == a) :: Int -> Bool)
14:36:45 <lambdabot>   "Falsifiable, after 2 tests:\n-1\n"
14:37:09 <clahey> Quickcheck is so cool.
14:37:16 <clahey> mcstar: Anyway, sorry I got the wrong operator there.
14:37:59 <mcstar> aha
14:39:25 <mcstar> well, yeah
14:39:33 <mcstar> a/2*2 is not invertible
14:39:42 <mcstar> that is what fooled me
14:40:40 <mcstar> i could have said this when you showed your tuple examples
14:40:59 <mcstar> but i wasnt sure what was that bad feeling called that i felt
14:41:20 * hackagebot debian 3.65 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.65 (DavidFox)
14:42:07 <ctfirc> hello
14:42:14 <ctfirc> is it possible to print an empty list in haskell?
14:42:16 <jfischoff> anyone following the string processing performance thread on reddit?
14:42:21 <ion> ctfirc: print []
14:42:57 <nicoo> > print []
14:42:58 <lambdabot>   <IO ()>
14:43:00 <ctfirc> reversex [] = []   reversex (x:xs) = reversex xs ++ [x]
14:43:04 <nicoo> > show []
14:43:05 <lambdabot>   "[]"
14:43:06 <monochrom> Eduard_Munteanu: my program has a timeout of 1 minute before it responds again :)
14:43:21 <ctfirc> then in main = do i have
14:43:22 <ctfirc> print (reversex [])         print (reversex [1,2])
14:43:42 <ctfirc> throws error when compiling though
14:43:57 <ion> What error?
14:44:00 <Cale> ctfirc: The problem is that it doesn't know which type of elements your empty list has :)
14:44:09 <Cale> So it doesn't know which instance of Show to use.
14:44:19 <ctfirc> Ambiguous type variable `a0' in the constraint:   (Show a0) arising from a use of `print' Probable fix: add a type signature that fixes these type variable(s) In a stmt of a 'do' block: print (reversex [])
14:44:38 <Cale> (It'll work in GHCi because GHCi has more aggressive defaulting which will default the type of the list to [()]
14:44:40 <Cale> )
14:44:59 <Cale> If you give it a type signature like   print (reversex [] :: [Integer])
14:45:01 <Cale> then it'll work
14:45:24 <ctfirc> hmm i'll give it a shot
14:46:04 <jfischoff> Is possible to have something like repa but for jagged arrays? That might be an approach to achieves fusion for words/lines etc (from my naive vantage point)
14:46:09 <mcstar> no, give it a type!
14:46:21 <mcstar> dont shoot that poor empty list
14:46:22 <crdueck_> i'm using these compile options "ghc -O2 --make -threaded foo.hs", but "./foo +RTS -N1" complains that foo needs to be compiled with -threaded
14:47:08 <clahey> mcstar: Yeah, if f is invertible, then f = f', which I think means that it equals id.
14:47:51 <clahey> f . g = g ⇒  f' . f . g = f' . g ⇒ g = f' . g ⇒ f = f'
14:48:03 <mcstar> clahey: showing off your unicode, eh?
14:48:12 <clahey> mcstar: compose key, but yeah.
14:48:35 <mcstar> ' means derivative
14:48:39 <mcstar> :)
14:49:14 <Lutin`> derivative or inverse
14:49:28 <mcstar> ive never seen it denote an inverse of anything
14:50:16 <Lutin`> I see it mostly in boolean logic
14:50:18 <clahey> Right.
14:50:23 <Lutin`> like a'b'c + ab'c'
14:51:19 <Lutin`> huh
14:51:22 <dino-> Oh hey it does work to hack the darcs repo directly, assuming you fix up any links in pages to what you've changed.
14:51:25 <dino-> (gitit ^)
14:51:40 <clahey> Regardless, you get my point.  :)
14:53:15 <Lutin`> Does first-order logic form a ring?
14:53:17 <ezyang> Hmm, I wonder if I can tell Cabal to only build profiling on 'cabal install'
14:53:21 <Lutin`> It's looking to me like it does
14:53:30 <dcoutts_> ezyang: sure
14:53:42 <ezyang> Oh, how do I do it?!
14:53:51 <dcoutts_> see cabal install --help
14:54:04 <ezyang> Oh, but that's me having to specify it manually ^_^
14:54:14 <dcoutts_> not very manual
14:54:20 <Lutin`> ezyang: I think there's a stackoverflow topic on it
14:54:34 <Lutin`> I remember someone in here solved that problem before
14:54:50 <clahey> Lutin`: Multiplication is disjunction or conjunction?
14:55:08 <dcoutts_> ezyang: as you can see from the --help, you can turn on and off building of vanilla and of profiling libs.
14:55:11 <Lutin`> conjunction
14:55:27 <Lutin`> Wel
14:55:31 <clahey> But a' v b' != a v b
14:55:35 <Lutin`> disjunction
14:55:46 <clahey> Same argument for disjunction.
14:55:55 <Lutin`> true..
14:55:58 <ezyang> The situation I'm describing is this one: http://code.google.com/p/leksah/issues/detail?id=216
14:56:05 <Rc43> Hi, guys.
14:56:09 <clahey> Although maybe that's not always true for rings.
14:56:23 <clahey> Oh yeah, it is.
14:56:28 <Rc43> I am trying to install `unix` package with cabal on windows under cygwin.
14:56:32 <ezyang> So if I type 'cabal install', I want it to build profiling for the current package and all its deps automatically, without needing to say --enable-library-profiling
14:56:36 <Lutin`> clahey: There's no way it's a ring or even a group :P
14:56:49 <ezyang> And if I type 'cabal build', I don't want it to build profiling without needing to say --disable-library-profiling
14:56:50 <Lutin`> id' ~= id for either
14:56:53 <Rc43> And I can't because I need `rt` and `dl` C libs; but I don't know what they are.
14:56:57 <Lutin`> I mean !=
14:57:17 <Rc43> And cabal talks that there is no HsUnix.h, too.
14:57:25 <Rc43> How can I fix it?
14:58:05 <Lutin`> ezyang: I'm sure there's a way to set that in the cabal file
14:58:06 <clahey> Lutin`: Right.
14:58:18 <dcoutts_> ezyang: doing the deps would be nice but it requires that we track profiling versions separately, which is quite a bit of work
14:58:54 <ezyang> dcoutts_: Well, I can always set Enable-Library-Profiling in my .cabal/config, which is basically what I want
14:59:00 <dcoutts_> ezyang: not sure what you mean about the cabal build one, too many double negatives
14:59:31 <ezyang> Sorry. Basically, I'm too lazy to type 'cabal build --no-library-profiling'
15:00:00 <Lutin`> So you want cabal build to not have profiling but cabal install to have profiling
15:00:11 <ezyang> Yup
15:00:21 <Lutin`> That seems backwards to me but okay
15:00:49 <ezyang> Lutin`: It makes more sense when you realize in order to build profiling all your deps need to have profiling versions installed
15:02:53 <Lutin`> Yeah that makes sense
15:03:39 <Lutin`> But there should be a way to have the profiling versions separate
15:03:53 <Lutin`> Maybe through cabal-dev? I'm not sure
15:09:50 <beaky> my C++ turing machine is slower than the haskell one :D
15:09:57 <beaky> I wonder why is that
15:10:59 <mcstar> i heard teller talk!
15:11:09 <beaky> he does talk
15:11:20 <mcstar> i havent heard him before
15:12:22 <mcstar> beaky: which haskell version?
15:12:48 <beaky> yours
15:13:18 <beaky> the one with Data.Array
15:14:11 <clahey> beaky: URL me?
15:15:06 <beaky> http://ideone.com/Xf4Iun
15:17:17 <Lutin`> beaky: How are you doing the turing machine in haskell?
15:18:00 <clahey> beaky: Why not use std::deque?
15:18:25 <Lutin`> `data Tape a = Tape [a] a [a]` is what I would have in mind
15:19:29 <clahey> Lutin`: That's basically what it was.
15:20:01 <Lutin`> dat comonad
15:20:24 <clahey> beaky: You would make windLeft and windRight O(1)
15:20:33 <clahey> Well, a much faster O(1).  :)
15:20:52 <beaky> I thought push and pop were O(1)
15:21:23 <mcstar> list has push_back, push_front too
15:21:25 <beaky> http://ideone.com/KCU4o2 my old haskell version using lists
15:21:35 <clahey> beaky: They are.
15:21:44 <clahey> beaky: But a somewhat faster.
15:21:53 <clahey> beaky: But why are you returning a std::string?
15:22:30 <Lutin`> using c strings might make it faster
15:22:39 <beaky> right
15:22:44 <clahey> Not using strings for a data structure would definitely make it faster.
15:23:02 <beaky> but C++ doesn't have anything like haskells 'symbols'
15:23:12 <mcstar> struct
15:23:17 <Lutin`> What do you mean 'symbols'
15:23:27 <clahey> beaky: Make lookup_ttable return a const & Transition where struct Transition { char nextState; char writeValue; Direction direction; }
15:23:27 <mcstar> also, enums
15:23:29 <beaky> data Symbol = A | B | C
15:23:31 <mcstar> also, numbers
15:23:44 <Lutin`> Yeah what mcstar said
15:23:46 <clahey> data Symbol = A | B | C ⇒ enum { A, B, C; }
15:23:54 <clahey> No semi colon there.
15:23:58 <clahey> data Symbol = A | B | C ⇒ enum { A, B, C } Symbol
15:24:53 <clahey> And instead of passing in a string to the map, pass in a struct { char currentState; char currentValue; }
15:24:55 <clahey> Or whatever.
15:25:04 <Lutin`> Is there a way to get a compose key on windows?
15:25:18 <clahey> No clue.
15:25:28 <beaky> I think I can pass in a std::pair<State,Symbol>
15:25:52 <mcstar> you can write the transition as a switch
15:25:53 <clahey> That would work just fine too.
15:26:01 <mcstar> no need for a map
15:26:06 <clahey> mcstar: Not if you want to be able to load the machine from a file.
15:26:19 <mcstar> why?
15:26:45 <clahey> mcstar: What do you mean then?
15:26:58 <mcstar> you can parameterize a swtich
15:27:09 <mcstar> the values you match against neednt be static
15:27:43 <mcstar> anyway, he didnt want to load it from a file
15:27:49 <clahey> That must be a very new concept to C++.
15:28:06 <beaky> the haskell version looks more readable
15:28:23 <mcstar> that is not a least bit surprising
15:28:25 <Lutin`> ^
15:28:41 <Lutin`> I've yet to see C++ be more readable than Haskell
15:28:48 <clahey> But more readable than C.
15:29:09 <clahey> Lutin`: Depends on how point-free crazy people go and on how good you are at reading C++ vs. reading Haskell.
15:29:15 <beaky> lol
15:29:18 <Lutin`> clahey: Of course
15:29:37 <Lutin`> But there's just so much clutter in C++ files..
15:30:21 <Lutin`> </opinion>
15:31:19 * hackagebot debian 3.65.1 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.65.1 (DavidFox)
15:31:24 <clahey> mcstar: Actually, now that I look at the haskell version, it used a case statement too (hidden as a function declaration)
15:31:31 <mcstar> clahey: yeah, you can only match against constant simple values, but you can change the mapping
15:31:33 <beaky> java's also an offender: BigInteger n = new BigInteger(3); n.add(BigInteger.value(3));
15:31:49 <mcstar> clahey: yeah, and i made that more explicit
15:32:21 <mcstar> case v * 5 + s of 6 -> ; 7 ->; ....
15:33:23 <mcstar> 6 and 7 is the 2 states that the 5th busy beaver spends most of its time
15:33:43 <mcstar> so it speeds things up to match on them first
15:34:07 <mcstar> ive got to go to sleep
15:34:22 <mcstar> i have to put together a little presentation early in the morninig
15:43:46 <Lutin`> :[ I'm trying to code in C++ but I keep thinking of functional design patterns
15:44:34 <popl> Lutin`: C++11?
15:44:41 <Lutin`> Just C++
15:44:48 <kirindave_> Man.
15:45:48 <kirindave_> That's not awesome
15:45:57 <kirindave_> So I got a conduit version of captialize working.
15:46:03 <kirindave_> And it's actually very slow.
15:46:19 <nand`> what does the code look like?
15:46:26 <kirindave_> Not pretty, but it works.
15:46:49 <popl> Lutin`: Can you use Boost?
15:46:53 <kirindave_> https://gist.github.com/4c7c93798a626eb9dab9
15:47:03 <Lutin`> popl: Nope
15:47:25 <Lutin`> The assignment is -very- specific
15:48:00 <popl> Well that's cool. You get to think in a different paradigm. That will be fun.
15:48:32 <Lutin`> http://dl.dropbox.com/u/99608/hw4.htm
15:48:59 <Lutin`> Warning: Your retinas may be damaged from the colors of that page.
15:49:18 <kirindave_> nand`: ^
15:49:22 <kirindave_> nand`: What do you think?
15:49:36 <nand`> implement your own type system in C++ templates
15:49:40 <nand`> interpret all to void* at the low level
15:50:06 <popl> Lutin`: Thanks for the warning. :P
15:50:30 <kirindave_> nand`: It's just depressingly slow.
15:50:31 <nand`> kirindave_: I've never worked with conduit before but it looks very verbose and complex
15:50:35 <nand`> far more than it should be
15:50:43 <Lutin`> lol i should do that for the last one
15:50:51 <kirindave_> nand`: Well I wrote it in a hurry.
15:51:01 <Lutin`> implement hindley milner
15:51:02 <nand`> I'm not necessarily blaming you
15:51:35 <kirindave_> nand`: I mean it's basically the minimal stream implementation that can go bytewise.
15:51:35 <popl> Lutin`: I have to use Blackboard for school, too. :(
15:51:40 <kirindave_> nand`: So it very much resembles C.
15:51:56 * nand` wonders if you could use FRP for this
15:52:05 <Lutin`> popl: What school?
15:52:07 <kirindave_> nand`: Please don't say it. :(
15:52:13 <kirindave_> nand`: It is just sad that it is slow in haskell.
15:52:29 <popl> Lutin`: Two separate schools, Cal Poly Pomona and MSJC.
15:52:49 <popl> Cal Poly's implementation is slightly less painful.
15:53:01 <Lutin`> Different versions?
15:54:55 <kirindave_> Like, the conduit version is the _slowest_ version.
15:54:58 <kirindave_> Wow
15:55:12 <nand`> bench my lens ver :)
15:55:19 <kirindave_> Link again plz?
15:55:25 <edwardk> ?
15:55:25 <nand`> http://hpaste.org/76717
15:55:25 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:55:29 <edwardk> @messages
15:55:30 <lambdabot> Nereid said 8h 47m 8s ago: how about a lens for accessing the n'th element of a list?
15:55:30 <lambdabot> nand` asked 2h 11m 18s ago: Do you think you could provide lenses like ‘_words’, ‘_lines’? Since the existing words/unwords and lines/unlines probably violate some lens laws; a more rigorous
15:55:30 <lambdabot> Iso could be made which simply splits on literal ' ' or '\n' characters; thus preserving eg. "a b" ⇔ ["a","","b"]; "a \n b" ⇔ ["a","\n","b"]; furthermore (byLines, byWords) = (_lines.traverse, _
15:55:30 <lambdabot> words.traverse)
15:55:49 <nand`> Nereid: isn't there already a lens for that?
15:55:53 <nand`> ‘ix‘ or ‘at’ or something like that
15:56:06 <fmap> [] isn't an instance of At
15:56:09 <edwardk> nand`: i'm not terribly averse to adding _words and _lines with the caveat that they are only traversals if your strong doesn't contain other space like characters
15:56:34 <Ralith> kirindave_: that seems very strange, given the exceptionally good performance of yesod, the webserver conduits were built for.
15:56:36 <edwardk> @tell Nereid try element
15:56:36 <lambdabot> Consider it noted.
15:56:37 <kirindave_> nand`: My versin, 52.
15:56:48 <kirindave_> Ralith: My code is available for you to consider if you wish.
15:56:59 <kirindave_> nand`: Your version: 12.
15:57:04 <kirindave_> Python: 2.8s
15:57:11 <kirindave_> But mine writes to a file, not to dev null
15:57:12 <kirindave_> I wonder.
15:57:22 <edwardk> [] can't be an instance of 'At' but it is traversable, and 'element' can traverse the nth element of a traversable, while elementOf can give you the nth element of a traversal as a lens
15:57:23 <nand`> the python version looks so ugly though
15:57:31 <Ralith> kirindave_: that can produce a dramatic difference under the right circumstances
15:57:33 <kirindave_> nand`: No one cares.
15:57:34 <nand`> oh; ‘element’ is generalized?
15:57:40 <kirindave_> nand`: Engineering is an ugly art.
15:57:45 <Ralith> kirindave_: try /dev/nulling it!
15:58:01 <kirindave_> nand's thing makes no diff
15:58:05 <kirindave_> null or not, 12.8s
15:58:25 <kirindave_> Well, beyond my ken and limited time.
15:58:26 <Ralith> yours, I mean
15:58:29 <nand`> I was mainly interested in how it compares to the naive String version on that blog
15:58:33 <Ralith> the conduit version
15:58:54 <popl> Lutin`: Yes, and the IT people at MSJC customized their installation very much.
15:58:57 <kirindave_> Oh, it's worse.
15:59:07 <Ralith> writing to /dev/null is worse than writing to a file?
15:59:08 * nand` .oO( goto i )
15:59:10 <kirindave_> No
15:59:11 <edwardk> element :: Traversable t => Int -> Simple Lens (t a) a
15:59:13 <kirindave_> It doesn't matter.
15:59:14 <kirindave_> At all.
15:59:19 <kirindave_> I have an SSD.
15:59:22 <Ralith> ah.
15:59:25 <fmap> edwardk: At Int [] isn't possible?
15:59:26 <popl> Lutin`: They use the marquee HTML tag for scrolling notifications. :/
15:59:39 <kirindave_> So I think the reason the conduit version is so broken is because it makes so many bytestrings.
15:59:44 <Ralith> kirindave_: I'd suspect the way you allocate a new byt--yeah
15:59:45 <kirindave_> I'll profile later.
15:59:50 <edwardk> fmap: what do you do when you write Just a value back way past the end of the list?
15:59:52 <kirindave_> Ralith: I am not sure how to do it otherwise.
15:59:59 <kirindave_> Ralith: Without ST, that is.
16:00:23 <kirindave_> It would only make the code uglier.
16:00:36 <kirindave_> I got a meeting.
16:00:38 <Ralith> kirindave_: the fact that ST should be used whenever appropriate aside, you only need a new bytestring for the parts you change, not every single character you process.
16:00:44 <kirindave_> Thansk for the help earlier, Ralith.
16:00:47 <edwardk> fmap: at 200 ?~  'y' $ "woops"
16:00:48 <Ralith> np
16:00:52 <fmap> edwardk: oh, yeah, that's bad
16:00:54 <kirindave_> Ralith: I'd have to crack the existing bytestring
16:01:02 <kirindave_> Ralith: Like find a window of unchangability.
16:01:10 <kirindave_> Ralith: And I am not sure bytestrings are efficient for that.
16:01:19 <nand`> there's one thing I'd like to try as far as performance is concerned
16:01:28 <Ralith> kirindave_: at the very least you can have one bytestring per contiguous unchanged region.
16:01:33 <Ralith> instead of n
16:02:08 <kirindave_> Right.
16:02:20 <kirindave_> Before I go
16:02:37 <kirindave_> This really does suggest Conduit should have a nice friendly constructor for ST-based things.
16:02:53 <kirindave_> Because that's not unreasonable to ask for.
16:03:03 <Ralith> it would certainly be useful
16:03:23 <kirindave_> The nice part about unidirectional pipelines is that mutation is actually fair game.
16:03:44 <Ralith> given that state in conduits can persist across multiple steps, it might require some clever tricks
16:04:18 <kirindave_> Ralith: Once you yield, you lose it.
16:04:35 <kirindave_> That should be part of the semantics even if the type system cannot enforce it.
16:04:47 <kirindave_> For reals investor meeting now. :)
16:05:33 <Ralith> haffun!
16:06:51 <hpaste> nand` pasted “Capitalize” at http://hpaste.org/76720
16:06:57 <nand`> kirindave_: ^
16:07:00 <nand`> how slow is this?
16:07:10 <Lutin`> popl: Ah, they upgrade ours every year
16:08:01 <shapr> @quote
16:08:02 <lambdabot> Ralith says: I'm sure we'll have fusion within 40 years.
16:08:07 <shapr> @quote edwardk
16:08:08 <lambdabot> edwardk says: i want to be able to know if the compiler is being stupid or if its just me, and without any sort of model to reason about it with, i always have to assume it could be the compiler; i
16:08:08 <lambdabot> already have to deal with that problem, its called 'scala'
16:08:09 <nand`> ah, seems I was too slow
16:08:15 <shachaf> @quote shapr
16:08:16 <lambdabot> shapr says: <shapr> Oleg will do something terrifying like implementing type checking in tcp/ip checksums on the router level through someemergent property of BGP and he'll do it all with HSP!
16:08:22 <shapr> Personally, I wonder if Niklas Broberg is related to edwardk
16:08:31 <shachaf> @quote oleg
16:08:31 <lambdabot> oleg says: Unfortunately, once it became clear that the ideas are working out, the motivation fizzled.
16:08:35 <shapr> ha
16:08:43 <Ralith> I have a lambdabot quote? o.O
16:08:45 <shachaf> @quote Oleg
16:08:46 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
16:10:58 <shapr> dmwit: Do you mind if I quote you in my ghclive talk?
16:12:19 <shapr> @tell dmwit May I have your permission to quote you in my ghclive talk? : http://hpaste.org/76721
16:12:19 <lambdabot> Consider it noted.
16:15:54 <shapr> OH hey! You guys should comment on the abstract for my talk! http://hpaste.org/76723
16:16:59 <cmccann> mentioning the relative size of #haskell vs. other channels on freenode might be good
16:17:05 <cmccann> if memory serves me it's one of the bigger ones
16:17:46 <shapr> cmccann: That's a good point, any idea if there's a monthly average posted somewhere?
16:17:55 <c_wraith> cmccann: Why do you hate types with semantics that require destroying the universe?
16:18:03 * shapr blinks
16:18:05 <cmccann> hahahaha
16:18:10 <typoclass> shapr: 800-900 afaik
16:18:15 <shapr> typoclass: Thanks
16:18:40 <cmccann> c_wraith, I suppose it would be nice to mix in nondeterminism and implement something like quantum suicide bogosort
16:19:05 <c_wraith> ...  only universes in which the data is more-sorted by the swap survive?
16:19:06 <c_wraith> Hmm.
16:19:21 <cmccann> yes, generate all permutations in separate universes
16:19:22 <djahandarie> Wasn't #haskell only like 200-300 people like a year ago?
16:19:32 <cmccann> in each one, check if the result is sorted, if it is end the universe
16:19:34 <c_wraith> djahandarie: no, much longer.
16:19:37 <shapr> djahandarie: Longer than that
16:19:37 <cmccann> er
16:19:38 <cmccann> isn't, rather
16:19:48 <djahandarie> Hmm. My memory clearly is shot then.
16:19:56 <c_wraith> djahandarie: I've been here like 4 years now, and it was like 600ish when I first showed up
16:20:19 <djahandarie> That's around when I showed up.
16:20:29 <djahandarie> So I've clearly just gone insane.
16:21:04 <Lutin`> Alright guys, it's time to try and reach the Ballmer Peak
16:22:54 <c_wraith> hmm.  a quantum suicide sort would be both linear-time, *and* comparison-based.
16:23:09 <c_wraith> I think this violates some assumptions that theorem makes.
16:23:45 <c_wraith> I guess the issue is that the sort isn't comparison-based, just the destruction of the universe.
16:24:01 <nand`> yeah the sort is randomized
16:24:07 <nand`> strictly speaking
16:24:28 <nand`> then again, strictly speaking, it's comparison based too
16:24:49 <Lutin`> I love quantum computing
16:25:07 <nand`> it's not unlike generating a domain of possible sorted lists using a RNG then filtering through these using the suicide algorithm
16:25:17 <cmccann> quantum suicide algorithms amount to having a non-deterministic turing machine that looks (to the only remaining observer) like a deterministic turing machine
16:25:29 <nand`> which can be seen as one ‘sorting’ operation
16:25:35 <c_wraith> it just always gets the correct result on the first try
16:26:35 <cmccann> having quantum suicide algorithms would also make the question of P vs. NP trivial, so that's nice too
16:26:44 <cmccann> really, it's a win all around
16:26:54 <Lutin`> quantum computing itself would turn everything on it's head
16:27:08 <Tekmo> Assuming quantum computing lives up to its promise
16:27:16 <cmccann> actual quantum computers would work slightly differently :P
16:27:28 <nand`> physical sorting algorithms are the coolest either way
16:27:43 <nand`> O(√n) thanks to the power of gravitation
16:27:47 <cmccann> sleepsort is pretty cool too
16:28:04 <cmccann> also hilarious
16:28:31 <c_wraith> sleepsort is pretty much the same as a bucket sort, when considered from that angle
16:28:43 <cmccann> yeah
16:28:44 <nand`> best and worst case of O(largest integer in list)
16:29:23 <nand`> ah; plus the time it takes to print them all
16:29:51 <Tekmo> I have a polymorphic constraints question
16:30:29 <Tekmo> So I want to devise a polymorphic constraint for use within my pipes library, but the Foralls that Edward provides in his constraints package don't fit my purpose
16:30:56 <cmccann> my guess is that if edwardk hasn't solved your constraints problem you're in uncharted territory
16:30:56 <Lutin`> cmccann: The way I've understood how quantum computing is going to work is essentially filtering the wave function
16:30:58 <Tekmo> The particular constraint I'm interested in is: (Monad m) :=> (Monad (Proxy a' a b' b m))
16:31:23 <Tekmo> where that constraint is true for all a' a b' b
16:31:43 <cmccann> Lutin`, I don't recall the details but actually getting answers out of quantum computation is more complicated than it sounds
16:31:55 <Lutin`> Well yes
16:32:06 <Tekmo> So I have two questions, really
16:32:10 <cmccann> and that a naive idea of what "quantum algorithms" would allow doesn't actually work
16:32:34 <Tekmo> The first one is if I will have to resort to unsafeCoerceConstraint and use the Skolem trick for soundness
16:32:48 <Tekmo> The second is if I can adapt his trick at all to my need
16:32:59 <edwardk> Tekmo: i've been working with nicholas frisby on a new way to do forall, but its not quite fully baked yet
16:33:27 <Tekmo> edwardk: Yeah, I read that post
16:33:28 <shapr> edwardk: Is this the FORTRAN forall for NDP purposes?
16:33:33 <Tekmo> That's why I worded it as "Skolem" trick
16:33:56 <edwardk> shapr: its the Forall from Data.Constraints.Forall in 'constraints'
16:34:04 <shapr> oh
16:34:05 <Tekmo> edwardk: But I guess i just wanted to know if that's the only way to get polymorphic constraints to work
16:34:22 <Tekmo> edwardk: i.e. using some form of soundness proof along with unsafeCoerceConstraint
16:34:32 <Lutin`> cmccann: Yes even a simple 'filtering distributions' approach has a problem with the end of "How do observe the output distribution"
16:34:53 <edwardk> you can do something manual. class MyForall p where dict :: Dict (p a) -- and then build a safe MyForall p :- p a  using that dict and \\
16:35:06 <cmccann> Lutin`, yeah, but the details are well beyond my knowledge :T
16:35:13 <edwardk> but then you have to instantiate it for each constraint you want
16:35:32 <Tekmo> edwardk: My understanding is that if I do that, then I have to constrain the function with a type class that provides the dictionary, right?
16:35:50 <edwardk> Tekmo: yep
16:36:09 <Lutin`> cmccann: I understand Heisenberg and 3D Schrodinger but I'm not sure how that carries to qubits
16:36:31 <Lutin`> Well I know how heisenberg carries
16:36:43 <cmccann> you're probably ahead of me, then
16:38:08 <Tekmo> edwardk: Maybe I can get away with that, then
16:38:08 <Tekmo> edwardk: Thanks for the help
16:38:42 <Lutin`> Actually I know how schrodinger carries too now that I think about it
16:39:01 <Lutin`> vaguely
16:43:33 <hiptobecubic> edwardk, is it possible to use your AD package on functions which explicitly demand Double as input?
16:44:39 <edwardk> hiptobecubic: no
16:44:46 <edwardk> hiptobecubic: what do i have to latch onto?
16:45:38 <edwardk> hiptobecubic: i may wind up writing a compile-time automatic differentiator soon. (I've had someone inquire about paying me for it), but that won't work if they are external, etc.
16:46:15 <hiptobecubic> I was just playing with some option pricing formulas, which typically require the PDF of some distribution
16:46:44 <edwardk> sure, just calculate the pdf in a way that gives you AD variables. remember you can always lift doubles
16:46:46 <hiptobecubic> normal can be approximated of course
16:46:59 <hiptobecubic> edwardk, ok that's more of my question then
16:47:25 <hiptobecubic> edwardk, some kind of   lift (cumulative (normal 0 1)) ?
16:48:07 <Sgeo> Was there some sort of talk about Lenses?
16:48:11 <Sgeo> Is there a link to such a talk?
16:48:28 <edwardk> sgeo: i gave a talk out at google in san francisco last week, but sadly we weren't allowed to record it
16:48:40 <Sgeo> edwardk, aww, ok
16:48:45 <c_wraith> might have accidentally given away google secrets.
16:48:46 <c_wraith> somehow
16:48:55 <edwardk> Sgeo: i'll probably do another version of it somewhere else and record it soon
16:49:01 <Sgeo> edwardk, cool
16:49:09 <MostAwesomeDude> c_wraith: They told me that I can't talk about anything that they asked me on my interview, 'cause it might ruin it for other people.
16:49:18 <Sgeo> Although I guess I shouldn't necessarily wait for that in order to implement lenses in another language?
16:49:19 <MostAwesomeDude> I gotta be honest, I don't think anything's getting ruined.
16:49:24 <c_wraith> MostAwesomeDude: that's.. a bit different
16:49:25 <edwardk> its a shame too, because the one in san francisco went over amazingly well
16:49:32 <edwardk> Sgeo: what language?
16:49:35 <Sgeo> Clojure
16:49:36 <MostAwesomeDude> c_wraith: IYSS.
16:49:59 <edwardk> Sgeo: you can grab the slides from the talk, but you'll miss most of the punchlines -- they kind of need me talking over them
16:51:22 <edwardk> Sgeo: https://groups.google.com/d/msg/bahaskell/YifnIpEu2OY/kddoyuvdCOMJ
16:51:33 <edwardk> sgeo: you're welcome to skim through those for inspiration
16:51:41 <Sgeo> edwardk, cool, thanks
16:51:46 <edwardk> i need to run
17:08:05 <shachaf> Oh, so lens has an exciting new way to say (either id id): view chosen
17:08:15 <shachaf> "how exciting"
17:08:44 <typoclass> shachaf: i've long hoped for new ways to say either id id
17:09:21 <shachaf> typoclass: Hey, man, pay either id id some respect!
17:09:35 <Gracenotes> it's like you don't know your left from your right
17:09:59 <otters> :t either id id
17:10:00 <lambdabot> forall b. Either b b -> b
17:10:30 <shachaf> It's the "early return" function!
17:10:54 <shachaf> > either id id $ do { x <- Right 1; y <- Right 2; return (x + y)
17:10:55 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:10:56 <shachaf> > either id id $ do { x <- Right 1; y <- Right 2; return (x + y) }
17:10:58 <lambdabot>   3
17:11:04 <shachaf> > either id id $ do { x <- Right 1; y <- Left 14; return (x + y) }
17:11:05 <lambdabot>   14
17:11:39 <Gracenotes> I thought "evaluating the value of the monadic expression"  was the "early return" function
17:12:15 <shachaf> Gracenotes: But either id id loses the information about whether it returned early or not!
17:12:28 <shachaf> When you want a C-style "return" this can be useful.
17:12:50 <Gracenotes> if you're into information-losing, might I suggest const ()
17:12:52 <shachaf> @let early = Left
17:12:54 <lambdabot>  Defined.
17:13:45 <shachaf> > let foo x = either id id $ do { when (odd x) (early 0); return (x * foo (x-1)) } in foo 5
17:13:48 <lambdabot>   0
17:13:50 <shachaf> OK, not a veyr interesting function.
17:14:58 <hpc> to get more interesting than that you basically need delimited continuations
17:15:10 <shachaf> hpc: The whole point of this is *not* to use continuations.
17:15:12 <Gracenotes> there is at least some connection early returns == error conditions, as far as use of Either
17:15:16 <hpc> ::P
17:15:31 <shachaf> Continuations = the devil.
17:15:40 <Gracenotes> and the thing about early returns, even in imperative languages, is that they make it much more difficult to see the flow of data
17:16:05 <shachaf> Gracenotes: Alternatively, they make it much easier to see the flow of data.
17:16:38 <shachaf> foo(x, y) { if (soandso(x)) { return blah; } if (suchandsuch(y)) { return blah; } ... }
17:16:52 <shachaf> Compare to the silly nesting you need in Haskell for the same thing.
17:17:21 <Gracenotes> you mean guards?
17:17:25 <hpc> lol
17:18:03 <shachaf> Gracenotes: OK, now what if soandso and suchandsuch are monadic?
17:18:50 <typoclass> Gracenotes: i dunno what people have against early returns. and the remedy of setting some bool and littering the rest of the function with "if (go_on) ..." doesn't fix anything much as far as i can tell
17:19:44 <Gracenotes> early returns aren't necessarily to be considered harmful, but pattern matching is overall a much better abstraction if you can swing it
17:19:54 <Eduard_Munteanu> Dunno, early returns are useful for the same reason goto is useful.
17:20:12 <beaky> haskell has early returns?
17:20:21 <beaky> thought haskell didn't need that
17:20:53 <Eduard_Munteanu> And established codebases usually enforce common-sense coding styles.
17:21:04 <typoclass> beaky: yeah, we're talking about imperative languages
17:21:09 <beaky> ah
17:21:16 <Eduard_Munteanu> beaky: yes, they can be implemented in certain monads.
17:21:30 <Gracenotes> if soandso/suchandsuch are monadic, then to be honest maybe you should see if Alternative can help you
17:21:32 <beaky> in that case then yeah, I'm a fan of early-returns, especially in the case of duffing
17:21:52 <beaky> I like code that reads vertically
17:33:53 <beaky> how does the list pattern matching work?
17:34:06 <kfish> beaky: for example?
17:34:33 <beaky> [x,y,z] -> x + y + z
17:35:25 <kfish> it's a structural match: [x,y,z] is syntactic sugar for Cons x (Cons y (Cons z Nil))
17:35:49 <kfish> so if the input matches the same structure, then the substitution of x,y,z can be done
17:36:15 <typoclass> beaky: that'll match a list with exactly 3 elements
17:36:36 <beaky> http://codepad.org/dGklITgN will Haskell 'memoize' the result or will it parse the string multiple times?
17:37:01 <ezyang> beaky: Probably only if full laziness is turned on.
17:37:15 <ezyang> Or maybe just common subexpression elimination
17:37:21 <beaky> laziness ftw
17:37:39 <Jafet> Haskell does not memoize
17:37:40 <ezyang> Yeah, this is CSE, not full laziness
17:37:53 <ezyang> Jafet, well, it does, in a sense
17:38:19 <typoclass> when people say 'sharing', do they refer to cse?
17:38:22 <shachaf> I wouldn't normally call laziness memoization.
17:38:28 <beaky> so if I want to avoid parsing something unnecessarily I should use a lambda?
17:38:31 <shachaf> typoclass: Not usually.
17:38:32 <Jafet> I say memoization is when a function is evaluated exactly once for every input
17:38:40 <ezyang> beaky: let binding is good enough
17:38:44 <beaky> ah
17:38:46 <typoclass> shachaf: thanks, where is sharing described then?
17:38:58 <beaky> so `let states = read n` should be good enough?
17:39:03 <Jafet> Sharing is an implementation detail of GHC
17:39:12 <shachaf> @where lazy
17:39:12 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
17:39:36 <shachaf> Jafet: ow many times a function is evaluated is also an implementation detail. :-)
17:39:49 <Jafet> Box-and-pointer diagrams? In mah Haskel?
17:39:55 <beaky> so lazy means applicative evaluation order?
17:39:59 <shachaf> No.
17:40:36 <shachaf> typoclass: let x = 2+3 in x*x -- x is "shared" there.
17:40:46 <typoclass> Jafet: i hear the new version will rely on lambdacats more
17:41:03 <shachaf> With laziness you don't evaluate that the same way as (2+3)*(2+3)
17:41:10 <typoclass> shachaf: thanks. i was always unclear on the sharing thing
17:41:27 <beaky> so if i use let, haskell will eagerly evaluate x , resulting in (5)*(5) instead of (2+3)*(2+3)?
17:41:32 <shachaf> No.
17:41:41 <shachaf> beaky: Did you read the article above?
17:41:53 <beaky> I'll take a look
17:42:02 <shachaf> Read that article before making random guesses about what things mean. :-)
17:42:06 <Jafet> I'm not going to read the article above.
17:42:33 <shachaf> Jafet: What's wrong with box-and-pointer diagrams?
17:42:42 <shachaf> That's an article on graph reduction.
17:42:45 <beaky> ah
17:42:56 <beaky> so haskell is non-strict like that
17:43:45 <Jafet> Well, I prefer the metaphor of rewrite systems
17:44:17 <beaky> yes
17:44:25 <beaky> it's like re-writing strings
17:45:00 <beaky> but isn't that really inefficient? why is laziness a good feature?
17:45:49 <shachaf> beaky: You couldn't have read and understood the article above in 4 minutes.
17:45:58 <Jafet> It's a metaphor.
17:48:56 <Polarina> beaky, ghc has a strictness analyzer. It can figure out when it can make things strict (not lazy) where it won't affect your program's semantics or hurt performance.
17:49:17 <Polarina> beaky, so, behind the scenes, things aren't necessarily "that" lazy.
17:51:08 <Jafet> It can figure out when to make things strict, according to rules that the ghc authors stridently believe won't affect your program's semantics or hurt performance
17:52:10 <shachaf> Or sometimes it figures out when to make things non-strict.
17:52:12 <beaky> > let pow = \x -> \y -> if y = 0 then 1 else x * pow x (y - 1) in pow 2 2
17:52:13 <lambdabot>   <no location info>: parse error on input `='
17:52:17 <beaky> :(
17:52:17 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/7364
17:52:33 <Polarina> beaky, (=) is not the equals to operator.
17:52:42 <Polarina> beaky, did you mean (==)?
17:52:47 <beaky> > let pow = \x -> \y -> if y == 0 then 1 else x * pow x (y - 1) in pow 2 2
17:52:48 <lambdabot>   4
17:52:50 <beaky> yes
17:53:15 <beaky> in programming, = always means something totally different from equality :(
17:53:29 <deech> Hi all, I'm trying to understand bottom in Haskell. Wikipedia says it's used for functions that don't return a value. If so why is main typed "IO ()"?
17:53:40 <Polarina> beaky, lambdas can take on more than one arguments at a time, like this: let pow = \x y -> if y == 0 then 1 else x * pow x (y - 1) in pow 2 2
17:54:13 <Polarina> deech, bottom is different from an empty tuple.
17:54:54 <Polarina> deech, bottom is a non-terminating function (infinite loop), or a call to "error".
17:54:55 <sipa> deech: because main does return a value: it returns the "program" you want to execute
17:55:16 <deech> Polarina: I think the empty tuple is the unit type if I'm not mistaken, but I'm wondering why it isn't "IO Bottom" (or something like that)
17:55:29 <deech> sipa: Ah I didn't know that.
17:55:52 <deech> So is error the only way to produce a bottom type?
17:56:22 * hackagebot bmp 1.2.3.2 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.3.2 (BenLippmeier)
17:56:27 <typoclass> deech: e.g. fetching the last element of an empty list never gives a value, it just takes forever
17:56:40 <Jafet> deech: because () is shorter to type than undefined.
17:56:47 <sipa> typoclass: of an infinite list, you mean
17:56:55 <shachaf> @let ⊥ = error "⊥"
17:56:56 <lambdabot> Plugin `eval' failed with: Enum.toEnum{Word8}: tag (8869) is outside of bounds (0,255)
17:56:58 <Jafet> Otherwise, () is used in the same way as Void.
17:57:21 <typoclass> sipa: ah, yes sure
17:57:41 <Jafet> last [] = last []
17:57:42 <deech> Jafet: But () is the unit type,right? The type with only one value, itself.
17:57:55 <sipa> deech: correct
17:58:01 <sipa> deech: and Void is the type with no value
17:58:04 <beaky> @pl let pow = \x -> \y -> if y == 0 then 1 else x * pow x (y - 1) in pow 2 2
17:58:04 <lambdabot> fix ((ap (flip if' 1 . (0 ==)) .) . liftM2 (.) (*) . flip flip (subtract 1) . ((.) .)) 2 2
17:58:11 <deech> And that's differnt from bottom which has no values.
17:58:30 <Jafet> Yes. And so in a total program, it has the same behaviour as Void, because you can't do anything with the bottom value.
17:59:18 <sipa> well any value of type Void is necesarily a bottom
17:59:26 <Jafet> So there is no problem with using (), because no value is the same thing as one value.
17:59:57 <shachaf> spoon
18:00:15 <Jafet> Shut up, Neo.
18:00:25 <shachaf> teaspoon
18:01:29 <deech> I'm confused now are you saying the () and bottom are used the same way?
18:03:02 <sipa> hell no
18:03:07 <sipa> () even has a value
18:03:51 * typoclass thought he could perfectly well return a () from a function. that's different from not returning
18:04:31 <shachaf> typoclass: You can perfectly well return ⊥ from a function.
18:05:06 <Jafet> They are used in the same way with the IO type constructor.
18:05:21 <Jafet> Or, could be used in the same way.
18:06:01 <typoclass> shachaf: right, i didn't say that clearly. i meant i can return () and use it, as in case-of or whatever
18:06:08 <Jafet> You could replace every IO () with IO Void, because no one looks at the () anyway.
18:06:49 <shapr> I still wish Cale's logo had been chosen as the official Haskell logo!
18:06:49 <deech> Is "undefined" the bottom type?
18:07:08 <Jafet> undefined is the bottom value of every type.
18:07:11 <Jafet> > undefined :: Int
18:07:12 <lambdabot>   *Exception: Prelude.undefined
18:07:16 <Jafet> @type undefined :: Int
18:07:17 <lambdabot> Int
18:07:45 <typoclass> shapr: linky link?
18:07:46 <Jafet> There is no bottom type in Haskell, because it does not have subtyping
18:08:49 <shapr>    typoclass: http://www.haskell.org/haskellwiki/Image:Haskell-logo-6up.png
18:08:51 <beaky> :t ()
18:08:52 <lambdabot> ()
18:09:02 <shapr> typoclass: Still looks more professional to me.
18:09:39 <typoclass> shapr: hm yeah, not bad
18:09:46 <shapr> whoa
18:09:53 <beaky> lol
18:10:06 <jmcarthur> looks like they were all web clients
18:10:23 <shapr> yup, all irccloud.com
18:10:56 <beaky> besides a turing machine, what other projects are great for a beginner?
18:11:19 <Clint> something practical that hasn't been written yet
18:11:39 <beaky> something that hasn't been written yet... hmm...
18:11:43 <doomlord> learn by reinventing the wheel
18:12:04 <Jafet> Once you've made a turing machine, you can waste all your time on the turing machine.
18:12:08 <beaky> lol
18:12:24 <beaky> the turing machine is kind of a turing tarpit
18:13:37 <typoclass> beaky: take some module, work out what it is for, then write that down, possibly even as haddock documentation that you could send to the author
18:14:08 <beaky> I still have no idea what any of the standard modules are for :(
18:14:28 <beaky> besides Prelude
18:15:01 <Nereid> beaky: look at their contents
18:15:01 <lambdabot> Nereid: You have 1 new message. '/msg lambdabot @messages' to read it.
18:15:24 <Nereid> "try element"
18:15:25 <Nereid> doh.
18:15:25 <Nereid> :v
18:15:27 <typoclass> beaky: that's what i mean :) same for me
18:15:46 <Nereid> figures there'd be something for general traversables.
18:15:54 <beaky> right
18:16:13 <beaky> I'll start with what Control.Monad is all about
18:16:17 <Nereid> well I mean
18:16:35 <Nereid> stuff like Data.List, Data.Function, Data.Char, should contain some obviously potentially useful things
18:16:47 <Nereid> Data.Map and Data.Set are useful...
18:17:11 <Nereid> but as for all those typeclasses...
18:17:14 <Jafet> You could try to document Control.Arrow
18:17:14 <Nereid> @where typeclassopedia
18:17:14 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
18:17:25 <typoclass> beaky: i think Control.Monad is best understood not from the haddock or implementation, but from typeclassopedia
18:17:40 <beaky> right
18:18:22 <Nereid> or at least it's a good starting point
18:18:31 <beaky> :t (***)
18:18:32 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:18:52 <typoclass> > (pred *** succ) (2,9)
18:18:53 <lambdabot>   (1,10)
18:19:07 <beaky> :t pred
18:19:08 <typoclass> > (pred &&& succ) 7
18:19:08 <lambdabot> forall a. (Enum a) => a -> a
18:19:09 <lambdabot>   (6,8)
18:19:16 <beaky> pred [1..]
18:19:23 <beaky> pred 1
18:19:25 <typoclass> beaky: pred and succ are just +1 and -1
18:19:27 <beaky> ah
18:19:31 * beaky facepalm
18:19:38 <typoclass> ... erm, other way round :)
18:19:46 <Nereid> > succ 'A'
18:19:47 <lambdabot>   'B'
18:20:14 <abedra> I've got a rather dumb IO monad question
18:20:15 <Nereid> beaky: you can kind of think of [a..] as [a, succ a, succ (succ a), ...]
18:20:15 <abedra> time = round (realToFrac $ utctDayTime t) where t = getCurrentTime
18:20:18 <typoclass> Nereid: right, but in the examples i lambdabotted above
18:20:23 <Nereid> (except it stops when it runs out of succs)
18:20:25 <beaky> what are the typeclasses that can be placed in a deriving clause?
18:20:32 <abedra> fails because of IO UTCTime instead of UTCTime
18:20:37 <Nereid> typoclass: mhm
18:20:51 <abedra> what I really want to do is just return an int
18:20:55 <Nereid> abedra: yes, you've got to do things in the IO monad.
18:21:13 <typoclass> abedra: i bet you're looking for "<-". inside your "main = do" block, try "t <- getCurrentTime"
18:21:13 <Nereid> so your "time" would have type IO Int or so
18:21:19 <abedra> Nereid: all I really want to do is get the current time and use it as the seed for a random generator
18:21:34 <abedra> typoclass: this isn't in my main
18:21:46 <abedra> typoclass: I just want to have a function that returns an int
18:21:51 <Nereid> time = do { t <- getCurrentTime; return $ round (...) }
18:21:53 <Nereid> time :: IO Int
18:22:49 <Nereid> (or... time = fmap (round . realToFrac . utctDayTime) getCurrentTime
18:23:15 <typoclass> abedra: one possibility is to create the random number generator in your main function (using current time or whatever), then pass it around to wherever it's needed
18:24:48 <Jafet> ALL I REALLY WANT
18:25:34 <EvanR> typoclass: the previous state of the generator when the program quit ;)
18:27:13 <Cale> shapr: Why thank you! :)
18:36:44 <lispy> hello my fellow humans
18:36:44 <lambdabot> lispy: You have 3 new messages. '/msg lambdabot @messages' to read them.
18:36:57 <lispy> (I swear I'm human, back away with that Turing test...)
18:37:56 <ivanm> _sure_ you are lispy...
18:38:18 <ivanm> methinks you doth protest too much
18:39:31 <lispy> ivanm: so many messages. C sucks at polymorphism. I think you're right that you need copyFoo and copyBar
18:39:50 <ivanm> heh, sorry about that
18:39:54 <lispy> ivanm: np
18:40:19 <lispy> to "clone the value" re: Ptr vs. ForeignPtr, that should amount to allocating space on the Haskell side
18:40:36 <ivanm> yeah, allocate space in Haskell, then do the copying in C
18:40:45 <lispy> when doing a deep copy, you allocate new resources (eg. memory) and for values you just copy them
18:41:15 <beaky> haskell has pointers?
18:41:21 <ivanm> beaky: using FFI
18:42:04 <lispy> beaky: we have Ptr a and ForeignPtr a
18:42:13 <lispy> beaky: we have malloc too
18:42:22 <lispy> beaky: but you usually only use them when you interface with C
18:42:54 <ivanm> lispy: so if I want a ForeignPtr to something that contains ForeignPtrs, do I end up cloning the second-level pointers twice? :/
18:43:14 <shachaf> How does it contain ForeignPtrs?
18:43:52 <ivanm> shachaf: the Haskell representation has ForeignPtrs
18:44:13 <crdueck_> :t foldl1' mplus
18:44:14 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
18:44:33 <crdueck_> foldl1' mplus [Nothing, Nothing, Just 4, Nothing, Just 5]
18:44:43 <shachaf> ivanm: How does that work?
18:44:44 <crdueck_>  > foldl1' mplus [Nothing, Nothing, Just 4, Nothing, Just 5]
18:44:49 <crdueck_> > foldl1' mplus [Nothing, Nothing, Just 4, Nothing, Just 5]
18:44:50 <lambdabot>   Just 4
18:45:22 <ivanm> shachaf: well, poke seems to work: http://hub.darcs.net/ivanm/dangd/browse/utils/bench_match_bud.hsc
18:45:40 <beaky> liftM (>>=)
18:45:40 <lispy> ivanm: the cloning process is recursive
18:45:45 <typoclass> > msum [Nothing, Nothing, Just 4, Nothing, Just 5] -- crdueck_ ...?
18:45:46 <lambdabot>   Just 4
18:45:47 <lispy> ivanm: in your case, you may have to worry about cycles
18:45:59 <ivanm> lispy: nah, the data structure isn't cyclic
18:46:07 <crdueck_> typoclass: ah thanks, thats better
18:46:14 <ivanm> just can't tell whether I can use the peek method for CGraph in the peek method for CDangD
18:46:20 <typoclass> crdueck_: ;-) you're welcome
18:46:23 <shachaf> ivanm: Every time you peek you make a new ForeignPtr with a free finalizer?
18:46:54 <ivanm> shachaf: I tried just converting the Ptr to a ForeignPTr; I crashed ghci with a glibc exception :p
18:47:35 <shachaf> Sounds like a double-free?
18:47:45 <beaky> does a ghc cross-compiler exist
18:47:56 <ivanm> shachaf: *shrug* mebbe
18:47:59 <ivanm> beaky: not really
18:48:11 <shachaf> ivanm: I suspect whatever approach you're taking here isn't going to work.
18:48:40 <ivanm> care to suggest a better approach?
18:48:59 <lispy> beaky: some of the pieces are there, and IIRC it's been getting some attention lately. But it's not ready for use.
18:52:09 <shachaf> ivanm: You shouldn't newForeignPtr finalizerFree any particular Ptr value more than once.
18:52:18 <shachaf> And usually not even once, I'd guess.
18:52:34 <ivanm> so how do I turn a Ptr into a ForeignPtr for a peek?
18:52:50 <shachaf> Maybe you shouldn't.
18:52:58 <shachaf> In general a ForeignPtr is a Haskell value.
18:53:07 <shachaf> It shouldn't be "contained" in a Ptr.
18:54:38 <ivanm> oooohhh, just using newForeignPtr_ works! :o
18:54:41 <ivanm> (without a finalizer)
18:55:01 <lispy> ivanm: You shouldn't be passing addresses across the Haskell/C boundary. You might get an address, but you shouldn't hold on to it. Likewise, if C wants an address, don't give it one that Haskell's GC knows about.
18:55:09 <shachaf> ivanm: That sounds wrong.
18:55:25 <shachaf> ivanm: I have the feeling you should think more about what you're doing.
18:55:38 <ivanm> shachaf: I've been trying to do this for a couple of weeks now
18:55:46 <ivanm> and I don't really know what I'm doing or what the best approach is
18:55:57 <ivanm> atm, something that works is good enough :/
18:56:30 <lispy> ivanm: does it work for arbitrary runs of your program, or just 2 out of 3?
18:57:03 <lispy> ivanm: When making a deep copy, you should see any Ptr as a place where you recursively clone whatever is stored at that address
18:57:08 <ivanm> so this is what I'm trying that seems to work:
18:57:13 <lispy> ivanm: if you're taking any shorcuts there, you will pay for it later
18:57:18 <ivanm> do { cddr <- toCDangD ddr; with cddr $ \ pdr -> do { pg <- peekByteOff pdr 8; c_printGraph pg; cg <- peek pg; fromCGraph cg } }
18:58:01 <lispy> ivanm: and what is the life span of cg?
18:58:13 <ivanm> just printing it to screen there
18:58:28 <ivanm> lispy: I only want the peek definition to work for debugging
18:58:47 <ivanm> so that I can compare the values to my Haskell ones
18:59:09 <ivanm> also, ` do { cddr <- toCDangD ddr; cddr' <- with cddr peek; fromCDangD cddr' } ' also seems to work fine over repeated runs
18:59:28 <ivanm> whereas I used to get occasional errors with `with ddr peek' using my old formulation
18:59:39 <lispy> if `fromCGraph cg` returns something that depends on cg, then you need to be sure that cg won't get clean up till after you're done with `fromCGraph cg`
18:59:57 <ivanm> *nod*
19:00:16 <ivanm> I think it's assuming the memory locations are still being kept from the mallocForeignPtr
19:00:34 <lispy> I haven't looked at your code in a while
19:01:38 <ivanm> but as that de-sugars down to  toCDangD ddr >>=  \ cddr -> ... then the foreign pointers should still be floating around as the cddr value is in scope throughout the rest of the do-block, right?
19:04:12 <gatlin> has anyone installed hmatrix on mac os x lion?
19:08:14 <Nereid> hmm
19:08:16 <Nereid> reading about the FFI
19:08:29 <Nereid> the report is surprisingly readable
19:10:40 <lispy> gatlin: yes
19:10:52 <lispy> gatlin: I installed the foreign deps using port
19:11:33 <lispy> gatlin: and so in my cabal file I had to arrange for them to be available. I think I used the extra-libs field. But you need to make sure to have the osx stuff first. I don't have my .cabal file handy. You'll know you have it wrong if you get iconv linker errors
19:19:11 <ivanm> lispy: heh, maybe you were right; got a segmentation fault :s
19:22:28 <ivanm> lispy: interestingly, it seems to occur in the middle of the C side of things :s
19:22:38 <ivanm> (but if I don't peek, it works fine...)
19:22:45 <guidj0s> What C side of things?
19:24:02 <ivanm> guidj0s: the FFI stuff I'm trying to write
19:24:44 <lispy> ivanm: I think shachaf is right. You need to spend more time thinking through the pointer life-spans. Draw some pictures on paper and stuff.
19:24:48 <shachaf> ivanm: A ForeignPtr that you make with newForeignPtr_ is pretty much the same as a Ptr.
19:24:58 <lispy> ivanm: I kind of feel like it's hard to help you because we're not at the same terminal.
19:25:04 <ivanm> :(
19:25:11 <guidj0s> Well, UB is fun. :-)
19:25:19 <ivanm> guidj0s: UB?
19:25:23 <shachaf> ivanm: Sorry, man, that's C.
19:26:10 <lispy> ivanm: can you arrange for C and Haskell to print their values to disk and then diff those?
19:26:14 <guidj0s> ivanm: Undefined Behavior -- the thing making C victims insane.
19:26:25 <ivanm> lispy: yeah, that's what I'm trying to do now
19:26:35 <ivanm> just trying to work out how to print the C stuff nicely :/
19:26:46 <lispy> ivanm: I mean, what if you only bind enough of the api to start the same computation on both sides, bench that with criterion and forget about marshalling?
19:27:08 <ivanm> sure
19:27:14 <ivanm> once I get the bugs ironed out
19:27:19 <ivanm> which is what I want the peek for
19:27:29 <ivanm> otherwise, I was using poke just so I could have the same data for both
19:27:33 <lispy> ivanm: have you ever used valgrind?
19:27:38 <ivanm> nope
19:27:47 <ivanm> oh, and I was doing the mallocing on the Haskell side as well
19:28:03 <lispy> It won't work so well on Haskell, but if you have pure C code, it tells you a lot of things about your allocations and deallocations.
19:28:34 <soiamso> ivanm: use ForeignPtr ?
19:28:35 <lispy> It's very effective for debugging memory problems in C
19:28:38 <ivanm> yeah, one reason I want to to use poke is to avoid trying to work out how to define these values in C :p
19:28:42 <guidj0s> ivanm: Is there some minimal amount of C code I could look at?
19:28:43 <ivanm> soiamso: trying to do that
19:29:10 <shachaf> ivanm: If you're allocating memory for a ForeignPtr on the Haskell side, you should probably allocate it with foreignMalloc or whatever it's called.
19:29:27 <lispy> ivanm: oh, you mean you allocate the memory on the Haskell side and want to give it to C? That's not going to work with Ptr/ForeignPtr if the C side needs to hold on to it.
19:29:33 <ivanm> guidj0s: the C isn't quite up-to-date, (mainly because of printf statements) but here's what I've got: http://hub.darcs.net/ivanm/dangd/browse/utils/
19:29:45 <ivanm> lispy: I'm not storing anything globally if that's what you mean
19:29:46 <shachaf> If you're making a ForeignPtr out of memory that was allocated in C, that means you're "taking ownership" of freeing that pointer, which means that C code that allocated it needs to coöperate with that somehow.
19:30:05 <ivanm> shachaf: I'm using mallocForeignPtr, etc.
19:30:40 <shachaf> ivanm: OK, so you shouldn't use newForeignPtr.
19:30:45 <shachaf> (On the same pointer.)
19:30:58 <ivanm> I was just trying to use that for peek
19:31:09 <ivanm> as I couldn't get my head around how doing cloning would work recursively
19:31:27 <guidj0s> Way more C than I'm willing to digest at this time.
19:31:45 <shachaf> ivanm: peek probably shouldn't return a thing containing ForeignPtrs.
19:31:52 <shachaf> As rwbarton mentioned yesterday (?).
19:31:56 <guidj0s> But I suggest checking that foo != NULL after every allocation, and perror'ing otherwise.
19:32:12 <shachaf> guidj0s: that's definitely not the issue here.
19:32:16 <ivanm> shachaf: yeah, so does that mean my data structures should contain Ptrs rather than ForeignPtrs? :/
19:32:54 <shachaf> ivanm: If they're data structures that correspond to C structs, then presumably.
19:33:02 <shachaf> Given that C structs contain Ptrs, after all.
19:33:10 <guidj0s> shachaf: If there's UB, everything is the issue.
19:33:33 <shachaf> guidj0s: I think we're talking about two different things here.
19:33:39 <ivanm> guidj0s: the UB is in the marshalling
19:33:53 <ivanm> shachaf: OK, I got the impression from lispy that I should be using ForeignPtrs there
19:33:58 <lispy> ivanm: It's hard for us to understand exactly what you're dealing with here.
19:34:07 <ivanm> *nod*
19:34:07 <shachaf> ivanm: You probably should be using them *somewhere*.
19:34:13 <ivanm> hard for me to understand as well :p
19:34:23 <guidj0s> shachaf: Probably -- but that's no excuse not to test the value of malloc(...);.
19:34:55 <lispy> ivanm: in manually memory managed languages like C it's crucial to understand resource ownership for memory. I feel like we don't have a good understanding here.
19:35:03 <ivanm> *nod*
19:35:07 <lispy> ivanm: do you want to allocate nothing in C and everything in Haskell?
19:35:14 <ivanm> so should I only be allocating ForeignPtrs in main or something?
19:35:19 <ivanm> lispy: yeah, ideally
19:35:27 * lispy was under the impression that C would allocate some stuff and try to share a *copy* with Haskell
19:35:38 <ivanm> well, I need to create two structures, and then have a third blank one that I can copy one value into
19:35:54 <ivanm> anyway, I've got to go tutor soon
19:36:14 <ivanm> this has been _soooo_ much fun :s
19:36:17 <lispy> ivanm: It sounds like you'll end up with blocks like alloca $ \p -> ...
19:36:20 <ivanm> thanks anyway lispy and shachaf
19:36:42 <ivanm> lispy: yes, maybe my mistake was that I was trying to do those blocks in smaller functions rather than at the top level in main
19:36:48 <lispy> ivanm: You could try this with a simpler example instead of your thesis
19:37:07 <lispy> Work up to your thesis
19:37:43 <ivanm> *sigh* hooray
19:39:43 <Cale> arithmoi is such a good library :)
19:40:09 <lispy> Cale: what is it?
19:40:24 <Cale> lispy: Number theoretical stuff
19:40:55 * byorgey <3 arithmoi
19:40:57 <Cale> Really good implementations of factorisation-related stuff in particular http://hackage.haskell.org/package/arithmoi-0.4.0.1
19:41:20 <byorgey> does Daniel Fischer hang out in here?
19:41:21 <lispy> neat
19:41:55 <Cale> ghci> factorise 1111111112222222233333334444445555566667778891
19:41:55 <Cale> [(5159699135488321,1),(215344166984469949015217356171,1)]
19:41:55 <Cale> (3.36 secs, 1103768540 bytes)
19:42:28 <lispy> the pairs are rationals?
19:42:30 <Cale> Not quite as fast as Mathematica (which does that in about 1 second on my machine), but quite respectable.
19:42:39 <Cale> The pairs are (prime, exponent)
19:42:45 <lispy> ah
19:43:10 <lispy> I see that they have a miller-rabin implementation. There goes my contribution to their lib.
19:43:25 * lispy wonders if he still has his pollard-rho
19:48:04 <Cale> I wonder what Mathematica is doing differently to be able to factor 107337724458389630425434058294578767 in 0.11s or so, when arithmoi takes about 13 seconds on that one.
19:48:17 <ivanm> Cale: really big lookup tables? :p
19:48:44 <Jafet> I wouldn't be surprised
19:48:47 <ivanm> no, wait, I know: it's doing it in the Cloud!
19:48:48 <ivanm> ;)
19:48:50 <byorgey> maybe Mathematica speculatively runs several algorithms in parallel?
19:48:54 <YayMe```> anybody here know how to hlint my buffer in emacs?
19:49:10 <YayMe> off hand
19:49:46 <YayMe> ivanm: You mean 6 raspbery pis running cloud haskell?
19:49:56 <ivanm> YayMe: set the variable "hs-checkers-replace-with-suggestions" to true
19:50:09 <saml> is there opposite of Maybe monad? computation continues until it fines the first non-Nothing
19:50:17 <ivanm> and (define-key haskell-mode-map (kbd "C-c l") 'hs-lint)
19:50:18 <Cale> aha
19:50:26 <ivanm> (if you're using the new stuff by chrisdone)
19:50:30 * ivanm runs off
19:50:30 <Cale> stepFactorisation factors it quickly
19:50:34 <Cale> in 0.21 seconds
19:50:41 <YayMe> I setup my emacs pretty recently so should be ok.. thanks ivanm
19:50:47 <napping> saml: that's what the monoid does
19:51:13 <saml> Nothing `f` Nothing `f` Just 1 `f` Just 2     ==>  Just 1
19:51:20 <saml> what's that f ?
19:51:21 <typoclass> saml: Either a () ?
19:51:23 <napping> wait, mplus
19:51:53 <napping> > let f = mplus in Nothing `f` Nothing `f` Just 1 `f` Just 2
19:51:55 <lambdabot>   Just 1
19:52:20 <Jafet> @let gecm n a=id`either`const 0$foldM(flip(^))(1,1)[1..a]where m=pure;k^p|k==0=m(0,0)|odd k=(k-1)^p>>=(p/)|1>0=div k 2^p >>=join(/);(0,0)/x=m x;x/(0,0)=m x;(p,q)/(r,s)=let z l=let t=mod(l*l-p-r)n in m(t,mod(-q+l*(p-t))n)in case(p-r)&n of{(l,_,1)->z$l*(q-s);(_,_,f)|f/=n->Left f|1>0->case(2*q)&n of{(l,_,1)->z$l*(3*p*p+a);(_,_,f)|f/=n->Left f|1>0->m(0,0)}};a&0=(signum a,0,abs a);a&b=let(q,r)=divMod a b;(s,t,d)=b&r in(t,s-q*t,d)
19:52:22 <lambdabot>  Defined.
19:52:35 <Jafet> > gecm 1111111112222222233333334444445555566667778891 10000
19:52:38 <lispy> Cale: I would have guessed that they attempt to pull out a factor right away witha trick like gcd (product (first 100 primes) yournumber)
19:52:39 <lambdabot>   mueval-core: Time limit exceeded
19:52:43 <Jafet> Boo
19:53:23 <lispy> Cale: my parens, were off. I mean a gcd with your number and a fixed product of primes
19:53:40 <saml> napping, thanks
20:03:32 <mm_freak> Cale: ECM can be anything from very slow to very fast, depending on implementation
20:05:48 <Jafet> I believe the fastest is inria's gmp-ecm.
20:05:54 <roconnor> @free (F a) -> (a, b -> F b)
20:05:54 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
20:06:01 <roconnor> @free trav :: (F a) -> (a, b -> F b)
20:06:01 <lambdabot> (forall k p. $map_F g . k = p . g             =>              h k = p) => $map_Pair f h (trav x) = trav ($map_F f x)
20:08:37 <alete> JOIN e-sim, a browser game, wich have strategy, politics, and more. JOIN with this link and you will get extra gold at lvl 7. PM for more info. http://secura.e-sim.org/lan.22620/
20:08:58 <Jafet> Sounds like bitcoin
20:09:04 <roconnor> @free trav :: (F a) -> (a, B -> F B)
20:09:04 <lambdabot> $map_Pair f ((.) ($map_F $id)) . trav = trav . $map_F f
20:09:43 <mm_freak> how come that hackage failed to generate documentation?
20:09:55 <mm_freak> or does it do documentation in another step?
20:11:45 <mm_freak> http://hackage.haskell.org/package/netwire ⇐ built successfully, but no docs
20:14:04 <byorgey> mm_freak: oh, congrats on the 4.0 release =)
20:14:35 <mm_freak> thanks =)
20:16:51 <byorgey> mm_freak: you can still get the build logs even though it's not linked from the Hackage page, under http://hackage.haskell.org/packages/archive/netwire/4.0.0/logs/
20:17:11 <mm_freak> thanks
20:17:47 <byorgey> haddock: internal error: synifyKind
20:18:32 <byorgey> guess it's a Haddock bug
20:18:43 <byorgey> I wonder what version of Haddock is actually being run
20:18:50 <mm_freak> haddock: internal error: synifyKind
20:18:56 <mm_freak> yeah
20:19:08 <mm_freak> although the documentation seems to have been built anyway
20:19:53 <mm_freak> built, but not installed
20:20:35 <byorgey> hmm, strange
20:25:09 <marzhallo> Hello all. I've run into what seems to be a basic IO monad problem, and I've been reading up on monads all night, but it's just not clicking. I'm trying to ask a user for a file name if it's not passed as an argument, but I'm running into the filename being an IO string instead of a standard string when trying to call readfile. Here's the code: http://pastebin.com/fUmW1uUQ What would be the correct way to go 
20:25:12 <mauke> The paste fUmW1uUQ has been copied to http://hpaste.org/76731
20:30:07 <byorgey> marzhallo: I think you want  filename <- if askUser ...   instead of   let filename = ...
20:30:50 <byorgey> with  let filename = ...,  filename is literally a block of imperative code (an IO String), not a filename.
20:31:02 <byorgey> with  filename <- ...  , filename will be bound to the result of running that code.
20:31:15 <byorgey> which is what you want.
20:31:42 <Nereid> cool, I made a little ffi program together with a silly C library.
20:32:31 <Nereid> which uses dynamic and wrapper imports, and some struct marshalling, etc
20:32:49 <Nereid> was pretty easy. :o
20:34:08 <marzhallo> byorgey: Thank you, and thanks for the explanation. I actually tried that twice before, but both times I forgot to remove the "let" bit. >_<
20:34:14 <rwbarton> shachaf: so unsafeCoercing between different strictnesses seems to work fine as far as I can tell, without any noticeable segfaults
20:34:26 <byorgey> marzhallo: ah, that would do it.
20:34:46 <rwbarton> shachaf: as long as I build my code with -O or -O2
20:35:20 <shachaf> rwbarton: I looked into it a bit more later and my conclusion was that GHC probably *could* generate slightly different code that would break it, but it doesn't.
20:35:30 <lispy> rwbarton: in your test, is it a data type with strict fields that you unsafeCoerce between?
20:35:35 <rwbarton> any idea why the optimization level would matter?
20:36:02 <rwbarton> lispy: I am unsafeCoercing from a data type with fields marked strict to another version with the same fields but not marked strict
20:36:12 <shachaf> rwbarton: Oh, wait, I didn't see that part.
20:36:15 <rwbarton> so in particular from Data.Map.Map to data Map k a = Tip | Bin {-# UNPACK #-} !Size k a (Map k a) (Map k a)
20:36:17 <shachaf> rwbarton: It doesn't work without -O?
20:36:19 <rwbarton> no
20:36:26 <rwbarton> it produces a variety of unexpected behaviors
20:36:48 <rwbarton> including but not limited to segfaults
20:37:48 <rwbarton> shachaf: I can post a demo program if you want to investigate
20:38:03 <lispy> rwbarton: I'd have to look at the core to figure out why the optimization level matters
20:38:13 <lispy> (well, the core or lower)
20:38:16 <rwbarton> oh
20:38:18 <mm_freak> rwbarton: i'm pretty sure that will fail as soon as type class dictionaries enter the game
20:38:26 <mm_freak> try Typeable
20:38:27 <rwbarton> could it be that -O0 doesn't actually unpack the field?
20:38:37 <lispy> rwbarton: that's my guess
20:38:47 <rwbarton> that would certainly explain it
20:38:53 <rwbarton> where would I find that in the core anyways?
20:38:54 <shachaf> rwbarton: Sure, though I probably can't look at it right now.
20:39:18 <lispy> rwbarton: Well, I don't think core has boxing info
20:39:18 <shachaf> rwbarton: I admit that I only tested my tests under -O2
20:39:32 <lispy> so maybe at the cmm or asm?
20:39:39 <hpaste> rwbarton pasted “works with -O or -O2 but not -O0” at http://hpaste.org/76732
20:39:52 <rwbarton> there it is, in case you want to take a look at some point
20:40:16 <shachaf> rwbarton: Data.Map.Map has Tip as the second constructor according to :i in my ghci
20:40:19 <shachaf> Maybe that has to do with it?
20:40:28 <rwbarton> that is new in 7.6 i believe
20:40:35 <rwbarton> i actually generated this from TH
20:40:44 <rwbarton> then removed the TH for the self-contained example
20:40:57 <rwbarton> putting Bin first is an optimization somehow
20:41:13 <rwbarton> forget where i read that
20:42:28 <lightquake> what's the difference between mtl and transformers?
20:42:29 <shachaf> Makes sense, if it checks the constructors in order for a tagged pointer. Or something like that. I don't know.
20:42:52 <lispy> > "mtl" \\ "transformers"
20:42:54 <lambdabot>   "l"
20:42:59 <lispy> lightquake: l
20:43:07 <lightquake> :|
20:43:22 <lightquake> ..
20:43:30 <lispy> lightquake: silliness a side, I'm afraid I don't know as I haven't kept up with those libraries
20:44:34 <lispy> > [1,1,2,2,3,3] \\ [1,2,3]
20:44:36 <lambdabot>   [1,2,3]
20:45:40 <lispy> I guess that behavior is nice, but using lists as sets is kind of bad.
20:46:16 <mm_freak> lightquake: mtl is a high level non-h98 interface to transformers
20:46:46 <lispy> mm_freak: at work we tend to prefer monadLib
20:47:03 <lispy> er, meant that for lightquake too
20:47:11 <lightquake> monadLib?
20:47:24 <lightquake> never heard of it
20:47:28 <mm_freak> a better mtl
20:47:28 <lispy> http://hackage.haskell.org/package/monadLib
20:47:58 <mm_freak> unfortunately most libraries on hackage are based on mtl, so with monadLib you're at risk of having incompatibilities
20:48:11 <lightquake> why are there so many transformer libraries anyway
20:48:14 <lightquake> what's the difference
20:48:29 <lispy> lift/inBase work better in monadLib than in the other libs
20:48:51 <mm_freak> lispy: that's not a valid reason anymore
20:49:32 <lispy> mm_freak: oh?
20:49:54 <Nereid> yeah, hsc makes writing code for marshalling things tolerable.
20:49:56 <Nereid> if not pleasant.
20:50:02 <mm_freak> lispy: http://hackage.haskell.org/package/transformers-base
20:50:33 <lightquake> i have no clue what the hell to use
20:50:34 <lightquake> :(
20:50:43 <rwbarton> then use mtl like everyone else
20:50:55 <rwbarton> at least other people will be able to help you then
20:51:21 <lightquake> but i heard transformers is better
20:51:30 <lispy> mm_freak: interesting.
20:51:42 <mm_freak> lightquake: mtl is based on transformers
20:51:45 <rwbarton> transformers is part of mtl anyways
20:51:48 <rwbarton> yeah
20:51:49 <lispy> It's true what they say, so many hackage libraries that you can't stay on top of it :)
20:51:50 <mm_freak> i.e. if you use mtl, you use transformers
20:52:29 <mm_freak> lispy: i mostly liked monadLib for its Choice monad, but then i found LogicT =)
20:52:44 <mm_freak> so i really don't see a reason anymore to use monadLib
20:52:49 <randomclown> Map.find: element not in the map
20:53:01 <randomclown> how do I get it to print something actually useful when it crashes?
20:53:48 <mm_freak> what's more useful than "element not in the map"?
20:53:53 <randomclown> line of error?
20:54:03 <lispy> @hoogle Map.find
20:54:04 <lambdabot> package FindBin
20:54:04 <lambdabot> Data.Map findIndex :: Ord k => k -> Map k a -> Int
20:54:04 <lambdabot> Data.Map findMax :: Map k a -> (k, a)
20:54:13 <rwbarton> "Map.find" means !
20:54:31 <rwbarton> having just gotten that error message with the -O0 version of my sketchy program :)
20:54:53 <randomclown> can't even get a backtrace from ghci
20:55:08 <mm_freak> randomclown: with lazy evalution the lines between lines are very blurry…  there isn't even a call stack you could print
20:55:31 <mm_freak> randomclown: you don't get a backtrace, because there is no backtrace
20:55:50 <randomclown> does it know which line that called?
20:55:56 <mm_freak> randomclown: http://www.youtube.com/watch?v=J0c4L-AURDQ&feature=plcp
20:56:03 <lispy> randomclown: use lookup instead of (!)
20:56:22 <randomclown> lispy: I'm not unboxing maybes every time
20:56:57 <mm_freak> randomclown: why would you?
20:56:59 <lispy> randomclown: any particular reason why not?
20:57:12 <rwbarton> good
20:57:18 <rwbarton> we have both "why" and "why not" covered
20:57:28 <lispy> heh
20:57:37 <randomclown> perhaps you two should ask each other :)
20:57:41 <rwbarton> hehe
20:57:42 <mm_freak> randomclown: Maybe is a monad and you can fold it ;)
20:57:52 <randomclown> nah that's not the point
20:57:56 <randomclown> It's never supposed to crash
20:57:58 <randomclown> i'm debugging
20:58:28 <rwbarton> I hear if you enable profiling there is some way to get a stack-tracy thing
20:58:32 <rwbarton> if you have a new enough ghc
20:58:36 <mm_freak> but it does, so you should probably do something like:  maybe (error "crashed, even though it shouldn't") id . M.lookup k
20:58:37 <lispy> randomclown: you could use an exception handler around all the uses of (!).
20:58:38 <rwbarton> never tried it myself though
20:59:13 <mm_freak> the video i linked explains why you can't get a stack trace and what your alternatives are (and will be)
20:59:33 <randomclown> the :trace in ghci doesn't work
21:00:28 <rwbarton> randomclown: try building with -prof -auto-all -rtsopts and running with +RTS -xc
21:00:59 <lispy> The crappy thing about using partial fun*** Exception: Pattern match failure
21:01:18 <rwbarton> so you are saying there is no crappy thing, right :)
21:01:35 <mm_freak> @remember lispy The crappy thing about using partial fun*** Exception: Pattern match failure
21:01:35 <lambdabot> Good to know.
21:01:41 <lightquake> mm_freak: is there a tl;dw of that talk?
21:01:57 <mm_freak> what's that?
21:02:06 <lightquake> too long; didn't watch
21:02:08 <popl> "too long didn't watch" presumably
21:02:09 <randomclown> rwbarton: gives the general area, no line numbers, just function names
21:02:22 <hpaste> Marzhall pasted “parsing a tree of files” at http://hpaste.org/76735
21:02:40 <randomclown> he want's a summary mm_freak:
21:02:44 <randomclown> wants*
21:03:12 <lispy> randomclown: make a CPP macro that replaces ! with a call to lookup that prints __FILE__ and __LINE__ in the Nothing case
21:03:34 <lispy> randomclown: that will at least tell you which use of ! causes the crash
21:03:35 <mm_freak> don't know a summary
21:03:51 <mm_freak> anyway, there is Debug.Trace, if all else fails
21:04:01 <rwbarton> doing that is sort of tricky because ! is infix
21:04:07 <lightquake> the fact that error doesn't give you a line number is pretty gross
21:04:25 <lispy> rwbarton: oh yeah, I didn't think about that. I'm used to this trick with fromJust
21:04:26 <lightquake> like i know assert does
21:04:34 <Gracenotes> all errors essentially give you line numbers (unless they're undefined)
21:04:45 <Gracenotes> it might not be in the file you're interested in, though
21:05:14 <rwbarton> lispy: I think it is still possible with extra cleverness
21:05:31 <mm_freak> you want to bind error line numbers to the point of /application/, not /occurence/
21:05:32 <lispy> rwbarton: call it find instead of (!), there problem solved
21:05:33 <rwbarton> but then ! probably isn't something you can #define anyways
21:05:40 <applicative> marzhallo: [(current, [err])] ++ (parseIncludeTree rest) is mixing up pure lists of pairs and an IO action?
21:06:05 <hpaste> Marzhall pasted “parsing a tree of files With fixes from hpaste” at http://hpaste.org/76736
21:06:09 <mm_freak> that's easy in most languages, but difficult in haskell
21:07:02 <lispy> Really this is a security feature of the language. In say, Java, the stack trace teaches your users a lot about what is in your source code (you know, revealing corporate IP). Good thing Haskell hides this from users.
21:07:19 <mm_freak> lol
21:07:22 <randomclown> rofl
21:07:25 <lightquake> lispy: haha
21:07:45 <cmears> More evidence that Haskell is enterprise-grade
21:08:42 <randomclown> no but seriously how do I find the line with the the ! that's messing up. Wrap exception handlers around every block>?
21:08:58 <lispy> cmears: Still no Haskell Enterprise Service Bus on hackage though. Odd, really.
21:08:58 <mm_freak> you can't wrap exception handlers, because they are IO
21:09:15 <mm_freak> randomclown: i think your best bet is Debug.Trace
21:09:16 <lispy> randomclown: Debug.trace
21:09:24 <lightquake> yeah, Debug.Trace
21:09:32 <lispy> D.T, yo
21:09:33 <marzhallo> applicative: changed things around a bit. Now, the second definition for parseINcludeTree is giving me an unexpected type, "Couldn't match expected type `String -> Either ParseError [String]'  with actual type `Either t0 t1' In the pattern: Left err In a case alternative: Left err -> [(current, [err])]." I'm not sure why the first definition meets the type correctly, but the second doesn't.  Also, hpaste is n
21:09:43 <marzhallo> http://hpaste.org/76736
21:10:06 <Lutin`> I think ideone is down :X
21:10:18 <randomclown> unamiously debug.trace
21:10:53 <mm_freak> or use the type system to enforce program behavior
21:11:20 <mm_freak> encode your invariants in types, so that runtime errors become compile time errors…  then you get your line number
21:11:33 <marzhallo> If context is needed, I'm parsing a file and seeing what files it includes (in the syntax of an include in a langauge I use at work called Progress); I need to take that list of includes and then parse them. This way, I'm hoping to get the tree of includes a file uses.
21:14:05 <rwbarton> hm
21:14:14 <rwbarton> can TH insert SCC pragmas?
21:14:17 <applicative> marzhallo: if it is the parsec 'parse' you are using  then it needs three arguments, no? the parser, the sourcename and the string or whatever
21:14:54 <marzhallo> ah, you're right. Let me fix that.
21:15:18 <applicative> marzhallo: so 'parse includes contents' has the type String -> Either ParseError result  for your result type
21:16:42 <marzhallo> ah, I gotcha. Sorry for the dunce errors, I'm pretty exhausted at the moment. I'm also rushing a bit because this tool could help me big time tommorow. :/
21:17:52 <applicative> marzhallo: the only trouble i see coming is the mixup in the final things returned [(current, [err])] : (parseIncludeTree rest)
21:18:21 <applicative> this should be, e.g. liftM ([(current, [err])] :) (parseIncludeTree rest)
21:19:01 <applicative> or (parseIncludeTree rest >>= \result -> return [(current, [err])] : result
21:19:12 <applicative> or (parseIncludeTree rest >>= \result -> return $ [(current, [err])] : result
21:19:31 <lispy> rwbarton: I'm not really sure. I would assume it depends on if you are working directly on the AST that ghc uses for parsing haskell.
21:19:38 <lispy> rwbarton: So, probably?
21:19:44 <applicative> marzhallo:  something like that, anyway, to keep the levels straight
21:20:09 <lispy> rwbarton: if you have the GHC source handy you could look in the parser, but it's probably better to find the TH docs
21:20:12 <rwbarton> I couldn't find anything promising
21:20:18 <rwbarton> but did not read the docs exhaustively
21:20:30 <rwbarton> but... maybe I can turn every expression into a function call
21:20:32 <rwbarton> then use -auto-all!
21:20:50 <rwbarton> I guess I would still be unable to recover the line numbers, lool
21:21:19 <marzhallo> applicative: thanks, I'm trying that out now. I'm not sure what it's doing, but I'm figuring it out.
21:21:29 <rwbarton> or hm
21:21:48 <rwbarton> could replace every occurrence of 'head' or other known offenders with a uniquified name
21:26:34 <rwbarton> @type mapException
21:26:35 <lambdabot> Not in scope: `mapException'
21:26:39 <rwbarton> @hoogle mapException
21:26:39 <lambdabot> Control.OldException mapException :: (Exception -> Exception) -> a -> a
21:26:39 <lambdabot> Control.Exception.Base mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
21:26:39 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
21:27:16 <statusfailed> Is there a TemplateHaskell library for automatically marshalling haskell datatypes to MongoDB ?
21:27:23 <statusfailed> (or any other database...)
21:27:59 <statusfailed> I'm trying to find a key/value store which I can use just to store haskell types without having to worry too much about marshalling
21:28:12 <marzhallo> So, I"m not really understanding that, applicative. What is liftM supposed to be doing?
21:28:55 <randomclown> @pl \x -> [x]
21:28:56 <lambdabot> return
21:29:12 <randomclown> hohoho
21:29:53 <statusfailed> @pl \f m -> do { x <- m; return (f x) }
21:29:53 <lambdabot> (line 1, column 12):
21:29:53 <lambdabot> unexpected "{"
21:29:53 <lambdabot> expecting variable, "(", operator or end of input
21:29:59 <statusfailed> @pl \f m -> do { x <- m; return (f x); }
21:29:59 <lambdabot> (line 1, column 12):
21:29:59 <lambdabot> unexpected "{"
21:29:59 <lambdabot> expecting variable, "(", operator or end of input
21:30:03 <statusfailed> aw
21:30:33 <randomclown> m >>= (return . f)
21:30:47 <statusfailed> liftM
21:31:16 <statusfailed> nowait
21:31:30 <statusfailed> yeah.
21:31:40 <randomclown> @pl \f m -> m >>= (return . f)
21:31:40 <lambdabot> fmap
21:31:46 <randomclown> yep it's liftm
21:32:02 <statusfailed> how do you write do notation inline here?
21:32:19 <rwbarton> you wrote it right the first time
21:32:25 <rwbarton> however @pl doesn't understand it
21:32:28 <rwbarton> but @undo does
21:32:34 <marzhallo> @pl (x:xs) -> x
21:32:34 <lambdabot> (line 1, column 8):
21:32:34 <lambdabot> unexpected ">" or "-"
21:32:35 <lambdabot> expecting variable, "(", operator or end of input
21:32:39 <rwbarton> @@ @pl @undo \f m -> do { x <- m; return (f x) }
21:32:39 <lambdabot>  fmap
21:33:10 <statusfailed> rwbarton: oh right, thanks
21:33:16 <marzhallo> @pl \(x:xs) -> x
21:33:16 <lambdabot> head
21:33:21 <marzhallo> coool
21:33:24 <statusfailed> marzhallo: anyway, that's what liftM is doing :P
21:33:42 <statusfailed> but that probably didn't answer your question
21:33:42 <marzhallo> oh god
21:33:45 <marzhallo> help computer
21:34:03 <marzhallo> to be honest, I need to bed
21:34:04 <Lutin`> What
21:34:17 <marzhallo> so it may be best for another day - but thanks for your help, guys
21:34:18 <statusfailed> what?
21:34:24 <statusfailed> haha
21:34:31 <Lutin`> marzhallo: I think you need to bed too
21:34:49 <Lutin`> lol
21:34:54 <statusfailed> yeup :P
21:34:58 <Lutin`> \o/
21:35:02 <marzhallo> well, I'm gonna be up another half hour until this darn thing compiles >_<
21:35:15 <statusfailed> it's 11:34 am!
21:35:30 <Lutin`> It's 12:35 AM!
21:35:31 <marzhallo> 12:34 on the East Coast, work tommorow at 9
21:35:39 <statusfailed> bangkok :D
21:35:49 <Lutin`> Almost 12 hour difference
21:36:05 <statusfailed> Yeaup :D
21:36:06 <statusfailed> LUNCHTIME
21:37:09 <hpaste> applicative annotated “parsing a tree of files With fixes from hpaste” with “parsing a tree of files With fixes from hpaste (annotation)” at http://hpaste.org/76736#a76737
21:37:33 <marzhallo> ...
21:37:35 <marzhallo> it looks fancy
21:47:08 <hpaste> Marzhall annotated “parsing a tree of files With fixes from hpaste” with “parsing a tree of files With fixes from hpaste (annotation) (annotation)” at http://hpaste.org/76736#a76738
21:48:15 <marzhallo> O.k., so it looks like it's getting confused with the types  - it seems to be expecting to always be a tree with one level, and never go further. I've stuck the error and the parsing module code in there, in case it helps. I'm trying to figure out how to get it to be o.k. with the types given. Thank you so much, again, for your help.
21:49:41 <byorgey> marzhallo: what is the type of parseIncludeTree ?
21:50:08 <byorgey> (I mean what do you think the type should be?)
21:50:39 <marzhallo> There's none declared. I'm trying to get the compiler to figure it out, and then narrow it down later. I think it should be [String] -> [(String, [String])]
21:50:53 <byorgey> marzhallo: ok, that's what I thought.
21:51:06 <byorgey> marzhallo: do you understand why this is an error:   [3] : [4,5,6]
21:51:28 <marzhallo> yes. You're concatenating a list to a list, instead of an element to a list
21:51:34 <byorgey> right.
21:51:34 <marzhallo> 3:[4,5,6]
21:51:39 <marzhallo> is what you want, right?
21:51:42 <byorgey> indeed.
21:51:49 <marzhallo> ohhhhh
21:51:52 <marzhallo> wait.
21:51:53 <byorgey> =D
21:56:28 * hackagebot HaTeX 3.4 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.4 (DanielDiaz)
21:56:30 * hackagebot dph-base 0.7.0.1 - Data Parallel Haskell common config and debugging functions.  http://hackage.haskell.org/package/dph-base-0.7.0.1 (BenLippmeier)
22:01:03 <marzhallo> So I need to model this function so that it can handle [String, a], then?
22:01:32 <byorgey> marzhallo: what is [String, a]?
22:01:32 * hackagebot dph-prim-interface 0.7.0.1 - Data Parallel Haskell segmented arrays. (abstract interface)  http://hackage.haskell.org/package/dph-prim-interface-0.7.0.1 (BenLippmeier)
22:01:34 * hackagebot dph-prim-seq 0.7.0.1 - Data Parallel Haskell segmented arrays. (sequential implementation)  http://hackage.haskell.org/package/dph-prim-seq-0.7.0.1 (BenLippmeier)
22:01:36 * hackagebot dph-prim-par 0.7.0.1 - Data Parallel Haskell segmented arrays. (production version)  http://hackage.haskell.org/package/dph-prim-par-0.7.0.1 (BenLippmeier)
22:01:38 * hackagebot dph-lifted-base 0.7.0.1 - Data Parallel Haskell common definitions used by other dph-lifted packages.  http://hackage.haskell.org/package/dph-lifted-base-0.7.0.1 (BenLippmeier)
22:01:38 <byorgey> do you mean  [(String,a)] ?
22:01:40 * hackagebot dph-lifted-vseg 0.7.0.1 - Data Parallel Haskell lifted array combinators.  http://hackage.haskell.org/package/dph-lifted-vseg-0.7.0.1 (BenLippmeier)
22:01:46 <marzhallo> yes, thanks.
22:01:50 <byorgey> eek I'm beoing dphed
22:02:40 <byorgey> marzhallo: I don't know, it depends on what parseIncludeTree is supposed to do.
22:03:22 <byorgey> marzhallo: so did you figure out why you were getting that error?
22:05:50 <marzhallo> when it recurses, and it tries to concatonate the previous value to the new one, the new value is of a different type, correct? It's not [(a, a)], it's [(a,[(a,a)])], and haskell doesn't know how to combine the values into a list
22:06:30 <marzhallo> it comes down to trying to do [a, b] and failing, I think
22:06:42 <marzhallo> erm, a:[b]
22:06:42 * hackagebot dph-lifted-copy 0.7.0.1 - Data Parallel Haskell lifted array combinators. (deprecated version)  http://hackage.haskell.org/package/dph-lifted-copy-0.7.0.1 (BenLippmeier)
22:06:44 * hackagebot dph-examples 0.7.0.1 - Data Parallel Haskell example programs.  http://hackage.haskell.org/package/dph-examples-0.7.0.1 (BenLippmeier)
22:09:57 <byorgey> marzhallo: well, you had  [(current,more)] : stillmore,  but it should be   (current,more) : stillmore
22:10:21 <marzhallo> That I did fix, but it just seemed to kcik the can down the road
22:10:37 <byorgey> oh, I see.  Can you paste the new code and new error message?
22:11:29 <byorgey> oh, wait, yes, I see
22:11:40 <marzhallo> ?
22:12:14 <byorgey> in   (current,more) : stillmore,  both  more  and  stillmore  are results of calling parseIncludeTree
22:12:30 <byorgey> that is not going to work.  You can't have a list type whose elements also contain the same list type inside them.
22:13:01 <byorgey> marzhallo: so is the result you want to get out at the end really a tree?
22:13:18 <byorgey> if so, you will have to use a tree data type.  lists can't be used as trees (unlike in lisp).
22:13:40 <marzhallo> oh
22:13:47 <marzhallo> hmm
22:14:34 <byorgey> marzhallo: it would probably help to come up with a small concrete example input, and spell out exactly what output you hope to get
22:14:42 <marzhallo> hmm
22:16:28 * hackagebot dph-par 0.5.1.99 - (deprecated)  http://hackage.haskell.org/package/dph-par-0.5.1.99 (BenLippmeier)
22:19:18 <marzhallo> file1: "{file2.i} {file3.i}"
22:19:18 <marzhallo> file2: ""
22:19:19 <marzhallo> file3: "{file2.i}
22:19:19 <marzhallo> [("file1", [("file2", []), ("file3", ["file2"])])]
22:19:19 <marzhallo> ^ thank god for rainbow parenthesis in vim
22:19:51 <adnauseam> ;
22:19:57 <marzhallo> Then I was thinking I could maybe do a Data.Map.fromList on it, and treat it like a map even
22:21:29 * hackagebot dph-seq 0.5.1.99 - (deprecated)  http://hackage.haskell.org/package/dph-seq-0.5.1.99 (BenLippmeier)
22:22:12 <marzhallo> I had such high hopes...
22:22:23 <byorgey> marzhallo: ok.  and what is the type of that example output you wrote there?
22:24:28 <marzhallo> [(string,[(string, [string]), (string [string])])]
22:24:38 <Nereid> no
22:24:43 <byorgey> not quite
22:25:03 <byorgey> hint: [Int, Int] is not a valid type
22:25:17 <shachaf> byorgey: Is it just me or is there an echo in here?
22:25:35 <byorgey> shachaf: eh?
22:25:42 <shachaf> 22:24 <byorgey> hint: [Int, Int]
22:26:02 * byorgey groans
22:26:37 <marzhallo> oh, uh
22:27:20 <marzhallo>                         [(String, [(String, [String])])]
22:27:26 <otters> more spaces
22:27:33 <marzhallo>                                                        [(String, [(String, [String])])]
22:27:38 <byorgey> hehe
22:27:40 <byorgey> right
22:27:57 <otters> good, now I can read it
22:28:05 <byorgey> marzhallo: and what would be the type if we added   file4: "{file1.i}" ?
22:28:29 <marzhallo> dat recursion
22:28:41 <marzhallo> wait, no
22:28:51 <marzhallo> does file1 end up including file4?
22:29:24 <byorgey> no, I didn't mean a loop
22:29:40 <byorgey> I just meant a situation where you have to follow includes three levels deep instead of only two
22:29:43 <marzhallo> I'm starting at only onw file, so unless files 1, 2, or 3 include 4, it shouldn't hurt
22:29:50 <marzhallo> ah, I see
22:29:53 <Lutin`> type Marz = [(String,Marz)]
22:31:23 <byorgey> marzhallo: the point is that we get a different type for every amount of nesting (with the same amount of nesting in the type)
22:31:29 * hackagebot dph-examples 0.7.0.2 - Data Parallel Haskell example programs.  http://hackage.haskell.org/package/dph-examples-0.7.0.2 (BenLippmeier)
22:31:41 <byorgey> but all these types have to be the same if they are all being produced by the same function
22:31:47 <marzhallo> Yeah, I see. That's why I was trying to see if I could make it type [String, a].
22:31:51 <marzhallo> Ohh, I see
22:32:18 <marzhallo> I was thinking type [String, a] would let it change depending on arguments, which is stupid now that I think about it
22:32:18 <byorgey> making it [(String, a)] doesn't help.  that means it has to be able to produce *any* type a.
22:32:31 <byorgey> i.e. the *caller* of the function gets to choose the type a.
22:33:03 <byorgey> marzhallo: the solution is to make a custom tree type that reflects this recursive structure.
22:33:14 <marzhallo> O.k., I understand now.
22:33:25 <marzhallo> Thank you for being patient.
22:33:36 <byorgey> something like   data Tree = Tree [(String, Tree)]
22:33:38 <byorgey> sure
22:41:29 * hackagebot dph-examples 0.7.0.3 - Data Parallel Haskell example programs.  http://hackage.haskell.org/package/dph-examples-0.7.0.3 (BenLippmeier)
22:41:31 * hackagebot dph-examples 0.7.0.4 - Data Parallel Haskell example programs.  http://hackage.haskell.org/package/dph-examples-0.7.0.4 (BenLippmeier)
22:46:41 <hpaste> rwbarton pasted “horrible exception/TH hack” at http://hpaste.org/76740
22:50:11 <Cale> rwbarton: cute, sticking mapException everywhere?
22:50:15 <rwbarton> yes
22:50:42 <rwbarton> not sure whether useful
22:51:30 * hackagebot dph-examples 0.7.0.5 - Data Parallel Haskell example programs.  http://hackage.haskell.org/package/dph-examples-0.7.0.5 (BenLippmeier)
22:51:33 <Cale> I can imagine that being useful.
22:52:05 <rwbarton> the most annoying thing i've found so far is having to indent all your declarations if you use layout in the module :/
22:52:15 <rwbarton> all the declarations being passed to labelAll that is
22:58:17 <rwbarton> maybe when the expression is the right-hand side of a binding it should say something like "In the definition of: y"
23:00:30 <b__> Haskell is used quite a bit in financial applications/analysis right?
23:03:53 <Cale> b__: apparently yes
23:04:10 <b__> but all behind very closed doors probably
23:04:56 <b__> I can't for the life of me find modules or articles that describe a Haskell-friendly way of representing money and currencies
23:05:30 <b__> btw I got started with the Awodey book, it's great =]
23:05:35 <Cale> ah, cool
23:05:35 <mm_freak> is there a CleanupT?  like ResourceT, but simpler and with MonadFix
23:06:20 <mm_freak> something like WriterT [IO ()] m would suffice
23:07:34 <AfC> b__: there's a 2000 paper about describing contracts in Haskell, and a 2008 paper by Barclays Capital about their use of Haskell
23:07:56 <b__> oh thanks, I will go look them up!
23:08:21 <Cale> I was going to recommend the financial contracts paper as well, but it doesn't do all that much explicit legwork with respect to the representation of currency
23:09:21 <b__> the representations found on hackage are either Double, or a half-implemented fixed-precision type
23:09:48 <Cale> It basically supposes some type Currency whose values represent types of currency
23:09:50 <b__> but the problem of currency representation can't be an uncommon one
23:10:21 <centrinia> Is there an IEEE-754 type where you can specify the number of bits in the mantissa and exponent?
23:10:26 <Cale> and then has a primitive contract  one :: Currency -> Contract  representing the contract which immediately pays one unit of a given currency
23:10:35 <Cale> (and a way to scale contracts)
23:10:58 <luft> Hi, can I reduce this function more? http://pastebin.com/HYnMa78F
23:11:00 <mauke> The paste HYnMa78F has been copied to http://hpaste.org/76741
23:11:23 <Cale> (lineHelp) doesn't need the parens
23:11:24 <AfC> b__: http://research.microsoft.com/en-us/um/people/simonpj/papers/financial-contracts/contracts-icfp.ps.gz and er, well search on "FPF"
23:11:56 <b__> thanks AfC
23:12:17 <luft> thanks
23:12:54 <b__> I have to run to work, thanks for the suggestions
23:13:00 <b__> and Cale the books are great fun
23:13:13 <Cale> b__: great!
23:13:19 <centrinia> So basically? lineHelp '\n' = return ""; lineHelp = getChar >>= lineHelp >>= return . (c:)
23:13:56 <Cale> centrinia: c is unbound there
23:14:13 <centrinia> Sorry, that is a typo. lineHelp c = getChar ...
23:15:48 <luft> centrinia: Why would I give linehelp ourline's body?
23:16:15 <luft> er myline's
23:16:29 <centrinia> Why not? It consolidates stuff.
23:16:56 <luft> centrinia: but then instead of a function that I call to get input, I have a function that needs input to get input
23:17:55 <hpaste> Cale annotated “pastebin.com/HYnMa78F” with “pastebin.com/HYnMa78F (annotation)” at http://hpaste.org/76741#a76742
23:18:12 <Cale> That's not any shorter, but maybe it's easier to understand?
23:19:14 <luft> Cale: Yeah, that works fine but I was specifically avoiding do notation.
23:19:46 <hpaste> Cale annotated “pastebin.com/HYnMa78F” with “pastebin.com/HYnMa78F (annotation) (annotation)” at http://hpaste.org/76741#a76743
23:19:54 <Cale> There it is without do notation
23:20:07 <centrinia> myLine = getChar >>= \c -> if c == '\n' then return "" else myLine >>= return . (c:)
23:20:27 <centrinia> Yeah, what Cale said.
23:21:03 <luft> well and also if. I wanted to see if I could write it with just monads and functions
23:21:12 <centrinia> @let ifthenelse b a b = if b then a else b
23:21:13 <lambdabot>  <local>:5:11:
23:21:13 <lambdabot>      Conflicting definitions for `b'
23:21:13 <lambdabot>      Bound at: <local>:5:...
23:21:19 <centrinia> @let ifthenelse b a c = if b then a else c
23:21:21 <lambdabot>  Defined.
23:21:24 <Cale> :D
23:21:50 <centrinia> myLine = getChar >>= \c -> ifthenelse (c == '\n') (return "") (myLine >>= return . (c:))
23:22:21 <centrinia> :t \myLine -> getChar >>= \c -> ifthenelse (c == '\n') (return "") (myLine >>= return . (c:))
23:22:23 <lambdabot> IO [Char] -> IO [Char]
23:22:35 <centrinia> Makes sense.
23:23:37 <luft> Does haskell always require "return" to wrap a value in a monad? I'm used to monads in haskell
23:24:00 <Nereid> huh?
23:24:17 <luft> er scala
23:24:19 <luft> sorry
23:24:40 <shachaf> luft: "wrap a value in a monad" isn't a phrase that makes sense.
23:24:52 <shachaf> But I assume that it's required as often in Haskell as in Scala.
23:24:59 <Cale> A monad is a type constructor, it doesn't live in the world of values
23:25:12 <shachaf> When you do foo.flatMap(...), doesn't "..." have to do the same thing?
23:25:36 <Cale> For example, IO is a monad, Maybe is a monad, List is a monad. getLine is not a monad, Just 5 is not a monad.
23:25:46 <Nereid> nor is Just
23:25:51 <Cale> right
23:25:53 <shachaf> Nothing is not a monad.
23:25:58 <Nereid> lol
23:25:58 <luft> foo.flatMap sort of
23:25:58 <Cale> :D
23:26:05 <luft> foo.map never
23:26:14 <shachaf> luft: "map" is like "fmap" in Haskell.
23:26:19 <shachaf> > fmap (+1) [1,2,3]
23:26:21 <lambdabot>   [2,3,4]
23:26:22 <shachaf> No return needed!
23:26:33 <luft> ok nice
23:27:17 <hpaste> rwbarton annotated “horrible exception/TH hack” with “fancier version/example” at http://hpaste.org/76740#a76744
23:27:21 <Cale> luft: What return does for IO is take a value and give the IO action which when run does nothing except to produce that value as its result. That is, it does nothing except return the value, hence the name. :)
23:27:37 <rwbarton> i think that is enough atrocities for one night
23:27:59 <Cale> The same is essentially true of all other monads, except that what "run" means can be quite different.
23:28:07 <solrize> has anyone looked at www.spoj.pl lately?  it's been down all day and i wonder if it's been that way for a long time or it's just recent
23:29:46 <solrize> zzz
23:30:57 <Cale> I haven't looked at it in years
23:30:59 <statusfailed> How do I get lambdabot to handle type classes?
23:31:11 <Cale> statusfailed: what do you mean by "handle"
23:31:34 <statusfailed> I was doing this:
23:31:46 <statusfailed> @djinn (a, m b) -> m (a, b)
23:31:47 <lambdabot> -- f cannot be realized.
23:31:59 <shachaf> statusfailed: It pretty much doesn't.
23:32:23 <statusfailed> I swear I saw it recently :D
23:32:24 <shachaf> I think there's some limited support for type classes, maybe, but you shouldn't rely on it working.
23:32:33 <statusfailed> I actually know the definition anyway, I was just messing around
23:32:34 <statusfailed> hehe
23:32:35 <shachaf> @djinn Monad m => (a, m b) -> m (a, b)
23:32:35 <lambdabot> -- f cannot be realized.
23:32:41 <statusfailed> @djinn Monad m => (a, m b) -> m (a, b)
23:32:42 <lambdabot> -- f cannot be realized.
23:32:42 <statusfailed> doh
23:32:46 <statusfailed> too slow :D
23:32:52 <shachaf> @djinn Functor m => (a, m b) -> m (a, b)
23:32:53 <lambdabot> Error: Class not found: Functor
23:33:17 <Cale> The djinn program is capable of handling typeclasses, but I'm not sure if the plugin does.
23:33:21 <shachaf> Whatever. Type classes are almost like rank-2 types.
23:33:30 <rwbarton> it doesn't handle them particularly well iirc
23:33:49 <Cale> Well, it handles them as extra function parameters when possible
23:33:51 <rwbarton> I don't know whether the algorithm it uses can handle axiom schemas like you get from type classes
23:34:09 <rwbarton> right, so it can handle type classes like Eq but not like Functor
23:34:09 <shachaf> Cale: Right, but they need to be rank-2.
23:34:27 <rwbarton> @djinn Eq a => a -> a -> a
23:34:28 <shachaf> @djinn Eq a => a -> a -> (Bool,Bool)
23:34:28 <lambdabot> f a b =
23:34:28 <lambdabot>     case a == a of
23:34:28 <lambdabot>     False -> b
23:34:28 <lambdabot>     True -> a
23:34:29 <lambdabot> f a _ =
23:34:30 <Cale> Maybe even rank 1
23:34:30 <lambdabot>     case a == a of
23:34:32 <lambdabot>     False -> (False, False)
23:34:34 <lambdabot>     True -> (False, True)
23:35:26 <rwbarton> those are some pretty silly functions
23:35:32 <statusfailed> I was just thinking that :D
23:35:40 <shachaf> rwbarton: To be fair, Eq isn't a very interesting class for Djinn.
23:35:44 <rwbarton> indeed
23:36:13 <rwbarton> @djinn-env
23:36:13 <lambdabot> data () = ()
23:36:13 <lambdabot> data Either a b = Left a | Right b
23:36:13 <lambdabot> data Maybe a = Nothing | Just a
23:36:13 <lambdabot> data Bool = False | True
23:36:13 <lambdabot> data Void
23:36:15 <lambdabot> type Not x = x -> Void
23:36:17 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
23:36:19 <lambdabot> class Eq a where (==) :: a -> a -> Bool
23:36:21 <lambdabot> either :: (a -> c) -> (b -> c) -> Either a b -> c
23:36:59 <rwbarton> as I recall it basically can only apply those methods return and (>>=) to the literal types 'a' and 'b'
23:37:19 <shachaf> @djinn Monad m => a -> m a
23:37:19 <lambdabot> f = return
23:37:23 <shachaf> @djinn Monad m => b -> m b
23:37:24 <lambdabot> -- f cannot be realized.
23:37:26 <rwbarton> yeah
23:37:47 <shachaf> That's not very rank-2 at all!
23:44:21 <rwbarton> i think this is my favorite line of code from my little exception project
23:44:29 <rwbarton> deepMapException f = everywhere (mapException f `ext2T` (deepMapException f .))
23:48:42 <mm_freak> there should be a shorter syntax for: import qualified A.B.C as C
23:52:54 <lispy> import dwim A.B.C
23:53:02 <lispy> dwim = do want I mean
23:53:09 <shachaf> dwmit
23:53:18 <shachaf> dwimt
23:53:42 <lispy> good night, folks
23:53:47 <lispy> END SESSION
23:57:44 <mm_freak> i mean the common case where you import "Some.Very.Long.Chain.Of.Module.Directories.For.MyStuff" as "MyStuff"
23:58:33 <sp3ctum> like in python?
23:58:50 <mm_freak> no idea
23:58:52 <sp3ctum> import A.B.C.D.E.F.G as pizzaModule
23:59:13 <mm_freak> it's just that the "as MyStuff" is often redundant
23:59:28 <sp3ctum> ah I see
23:59:49 <mm_freak> but the import syntax of haskell is weird anyway
