00:00:12 <cmccann> also, I do often use "r" as a "final result" parameter, for both types and terms
00:00:25 <shachaf> Are you on the foldr :: (Maybe (a,b) -> b) -> [a] -> b side?
00:00:30 <cmccann> and a "k" prefix for continuation arguments
00:01:08 <cmccann> nah, using foldr that way would be hella awkward in comparison
00:01:30 <cmccann> but it's equivalent, and enlightening about some underlying structure
00:01:39 <cmccann> duality with unfoldr and all that
00:01:56 <shachaf> Similarly, cons :: Maybe (a,[a]) -> [a]
00:02:12 <cmccann> no, cons is the wrong name there
00:02:25 <shachaf> unlist?
00:02:31 <rwbarton> In :)
00:02:46 <shachaf> cmccann: uncons :: [a] -> Maybe (a,[a])
00:02:51 <shachaf> Surely you don't dispute that.
00:02:57 <rwbarton> though i guess it can't really be In
00:03:19 <rwbarton> In2
00:03:22 <cmccann> shachaf, that's a partial function that works on one constructor, and returns Nothing otherwise
00:03:28 <cmccann> completely different!
00:03:48 <shachaf> Maybe uncons :: [a] -> b -> (a -> [a] -> b) -> b
00:04:54 <orzo> Cale: you wouldn't happen to be eager to walk me through another Show/Read example, this time to correct bad Show instances that are not showing neccesary parenthesis?
00:07:01 <kulin> I am new to dealing with shared libraries but my goal is to write a program that has a single executable with a number of shared libraries that can be replaced at run time assuming their interface does not change. I have been trying to research this for over a week but have been coming up empty. Is this just not a concern for current haskell programs?
00:08:02 <shachaf> kulin: Shared (Haskell) libraries aren't very popular with GHC for various reasons, though I think there's some sort of support for them.
00:08:40 <m3ga> kulin: the project that used to do this was hsplugins. not sure how well that is maintained.
00:10:53 <kulin> What if I reduce the need for run time loading, and just loading shared libraries at a given path at program initialization?
00:11:04 <kulin> or is that in the same technical group?
00:15:48 <startling> is there an extension I can use to say "this function takes one of these three strings"?
00:15:57 <startling> on the type level, I mean
00:16:17 <darkf> I imagine that is in the realm of dependant typing
00:16:32 <antalsz> startling: Why not `data Arg = Str1 | Str2 | Str3`, `f :: Arg -> a`, and if you want, `mkArg :: String -> Maybe Arg`?
00:16:44 <startling> antalsz: because I have a million of these
00:16:58 <startling> I'm writing a thing for css fields and values
00:17:10 <startling> so far that means defining a data for each function
00:17:24 <startling> darkf: so are lots of extensions
00:17:55 <donri> startling: i've been working on that
00:18:09 <donri> i have lots of stuff like data Color = Black | White ...
00:18:55 <startling> also doesn't help that most (but not all!) fields can take "auto" and "inherit"
00:19:05 <kmbt> hi
00:19:15 <donri> startling: yea that's been annoying
00:19:28 <donri> startling: http://hub.darcs.net/dag/web-styles
00:19:33 <startling> so I've got class Inherit i where inherit :: i and then FontWeightInherit, FontStyleInherit...
00:19:51 <donri> you're replicating all the work i've already done dude :)
00:21:19 <startling> looks like your selectors are way off?
00:21:19 <rwbarton> probably if you are willing to work with your own "string" type using GADTs and 7.6 type-level string literals you could do it somehow
00:21:26 <donri> startling: selectors are unfinished yes
00:21:40 <donri> startling: how far along is your thing?
00:22:10 <startling> donri: I've got selectors and all the font fields
00:22:22 <donri> startling: i have all the properties and values done
00:22:34 <donri> http://hub.darcs.net/dag/web-styles/browse/src/Web/Styles/Stock.hs here is a working example stylesheet
00:22:57 <kulin> is ffi code statically linked into the executable?
00:23:40 <donri> http://hub.darcs.net/dag/web-styles/browse/test/data and here's how that renders with different functions
00:23:41 <startling> donri: lemme browse your code for a bit
00:24:01 <orzo> is there a way to use logical negation in a constraint?  Such as t is all types that are not instances of a given class... ?
00:24:09 <startling> donri: here's my selectors: https://gist.github.com/d2205738dd13104231ac
00:25:42 <startling> (no pseudoclasses yet)
00:25:47 <donri> orzo: not sure such a type could be inhabited by much more than bottom?
00:28:18 <donri> startling: do you have any rendering code?
00:28:41 <startling> donri: not at the moment
00:29:35 <startling> donri: for the selectors, do you mean? I could write that in a minute or two
00:30:06 <rwbarton> orzo: there is no way to ever know that a type is not an instance of a class
00:30:49 <donri> startling: what did you mean my selectors are way off btw? just that they're incomplete, or something else?
00:31:07 <startling> donri: the "combinators" in the w3c spec are really weird
00:31:18 <startling> and I don't think you can make a valid Monoid out of selectors
00:31:37 <rwbarton> except by successfully defining your own instance I suppose
00:31:55 <donri> don't see why not
00:32:03 <donri> i use monoid for what in css is a comma
00:32:09 <startling> oh, I see
00:32:29 <startling> my "Selector" type is just one thing and my Rule has [Selector]
00:34:19 <donri> i've been trying to figure out if things like q:before:before is nonsensical or not
00:34:34 <donri> spec seems unclear and #css users just look at me strange when i ask
00:34:39 <startling> haha
00:34:49 <orzo> does the default Show instance for numbers parenthsize negatives?
00:34:53 <donri> i'm gonna disallow it methinks
00:34:53 <startling> yeah, the spec doesn't say anything really about pseudo-elements. >:(
00:34:54 <orzo> its not working for me
00:35:17 <rwbarton> > showsPrec 0 (-3) ""
00:35:18 <lambdabot>   "-3"
00:35:22 <rwbarton> > showsPrec 10 (-3) ""
00:35:25 <lambdabot>   "(-3)"
00:37:41 <lpvb> Can anyone who uses Yi tell me the pros/cons vs. vim?
00:38:25 <orzo> when I am making a custom showsPrec for an algebraic type that has number arguments, how much should i add to the precedence number when i chain to the showsPrec for those numbers?  Adding 1 is apprently not sufficient
00:40:04 <rwbarton> "adding 1" is never the right thing
00:40:18 <rwbarton> what kind of syntax are youtrying to produce, ordinary prefix syntax?
00:40:49 <rwbarton> like Foo 'a' (-1)?
00:41:41 <rwbarton> or infix syntax?
00:43:09 <orzo> rwbarton, yes, ordinary prefix
00:43:27 <rwbarton> then you should use 10 i think
00:43:40 <orzo> + 10 ?
00:43:47 <rwbarton> no, just 10
00:43:47 <orzo> or just 10
00:44:02 <rwbarton> take a look at the haskell report, i think there is a section "specification of derived instances"
00:45:25 <rwbarton> if you are ever adding precedence values you are doing something wrong
00:47:21 <lightquake> rwbarton: haha
00:51:39 <orzo> hmm, The Read instance i made with Cale's help apparently cannot and needs to handle when an object is parenthesized
00:56:13 <mikeplus64> @pl \f x y -> f x y
00:56:13 <lambdabot> id
01:00:41 <startling> donri: yeah, I'm gonna say pseudo-elements can only be used once, too
01:01:02 <startling> (at the end of a Selector)
01:01:18 <donri> startling: yea i just changed it to enforce that. if it turns out to be valid and someone actually wants to use it they can report it
01:16:00 <shachaf> Is there some place (other than GHC source) that explains how RecursiveDo desugars?
01:19:06 <sipa> shachaf: i'm sure #haskell can explain it as wel (not me, though)
01:19:34 <shachaf> Maybe the best resource is Erkok's thesis.
01:25:28 <jfischoff> how does one sort rows of a two dimensional repa array?
01:26:07 <jfischoff> you take an slice and use the vector sort algos some how?
01:32:25 <shachaf> OK, this thesis answers most of my questions.
01:33:05 <merijn> Why aren't conduits arrows (letting people reuse the arrow operators)?
01:33:27 <t7> how do i factor a prime number in polynomial time without a quantum computer?
01:33:33 <lightquake> 04:32:03            <shachaf> OK, this thesis answers most of my questions.
01:33:42 <lightquake> haskell in a nutshell
01:33:52 <startling> t7, factor a prime number?
01:33:59 <startling> lightquake: heh
01:34:12 <lightquake> factors x = (1, x) --only works with primes
01:34:17 <t7> i prime that is prime * prime?
01:34:22 <t7> wait thats not a prime
01:34:29 <startling> haha
01:34:31 <shachaf> lightquake: I sort of feel like I should write a short explanation of this that doesn't require people to skim someone's thesis to figure out.
01:34:37 <lightquake> you should!
01:34:40 <shachaf> But on the other hand that would be annoying.
01:35:01 <shachaf> And I'd feel bad about doing it without reading the rest of the thesis, since I only understand it "enough to get my questions answered", not properly.
01:35:11 <merijn> shachaf: I know, right? If only I could write up things without actually writing ;)
01:35:13 * shachaf wonders why TH doesn't support it.
01:36:16 <t7> http://wiki.answers.com/Q/Why_is_2048_not_a_prime_number wut
01:36:24 <shachaf> merijn: You're all arrowy, aren't you?
01:37:37 <merijn> shachaf: Reading up on Netwire and Hughes' Programming with Arrows
01:37:47 <sipa> t7: http://en.wikipedia.org/wiki/Primality_test#Fast_deterministic_tests
01:37:49 <merijn> So I'm just trying to see if I understand things yet :p
01:38:08 <merijn> Also worried I need to rewrite all my monadic code using arrows soon ;)
01:38:15 <shachaf> I wonder whether I confuse merijn with mm_freak.
01:38:31 <t7> i think mm_freak is cleverer
01:38:47 <t7> and one is a dirty mac user
01:38:51 <merijn> I'd be offended if I wasn't afraid that was true :<
01:39:06 <startling> uh, if I think I killed the type-checker
01:39:13 <startling> s/if /
01:39:16 <merijn> startling: *high five*
01:39:19 <t7> merijn: i saw him answer questions on #crypto :O
01:39:41 * merijn is always really proud when he can manage to segfault GHC or kill the type checker
01:40:23 <lightquake> i feel like netwire/reactive-banana/something would be a good fit for making a turn-based game, but i'm not sure what
01:40:40 <merijn> btw, since it's quiet anyway. Any MacPorts users around that are well versed in linking? :p
01:41:08 <merijn> Or I guess anyone with experience in linking on unix would work...
01:41:45 <shachaf> merijn: You probably should just ask your question.
01:41:53 <merijn> Why would appending a path to my LIBRARY_PATH breaks GHC's ability to link? It seems to get confused if I append a path that has a wrong libiconv version in it
01:42:09 <merijn> Even if that path is *after* the path with the right libiconv in LIBRARY_PATH
01:42:25 <shachaf> What order does it search the paths in?
01:42:46 <shachaf> Or does it look for a more specific version through all the paths first, and then for a less specific version?
01:42:49 <shachaf> Who knows.
01:42:51 <merijn> Presumably front to back? That's the normal convention for paths in environment variables
01:42:56 <shachaf> strace will tell you.
01:43:03 <shachaf> This is OS X, so I guess dtruss will tell you.
01:46:03 <mapf> in profiling reports besidies ordinary functions there are functions with dots and backshashes at the end (e.g. allocNamedColor.\.\.\). does anyone know what it is mean?
01:46:51 <mapf> at first i thought it is foreign call, but it's not
01:47:17 <merijn> shachaf: dtruss can probably tell me, but mostly it just dumps a bunch of syscalls that tell me very little :p
01:47:58 <shachaf> merijn: It has open()/stat() syscalls.
01:48:04 <shachaf> You can see what files it looks for and in what order.
01:48:36 <merijn> Yeah, but it doesn't appear to look at files in the path I added at all
01:48:37 <startling> ghc is inferring the following type signature: (Monad m, Field (m b), Field (m a)) => m b
01:48:38 <int-e> mapf: A guess would be partial applications - the \ is probably a lambda.
01:48:43 <int-e> mapf: but I don't know
01:48:53 <shachaf> merijn: Do dtruss with/without, compare.
01:48:55 <startling> what am I supposed to make of tht?
01:49:49 <mapf> int-e: yep, seems like so. how i didn't guess...
01:49:50 <startling> if I don't give a type signature, I get lots of "could not deduce"s
01:51:25 <startling> ugh what. whenever I add a new line to this do expression, I get a junk Field instance
01:51:30 <startling> (Monad m, Field (m b), Field (m a1), Field (m a)) => m b
01:51:36 <startling> what in the world
01:54:22 <t7> startling: :S
01:54:26 <int-e> startling: So there is a Field typeclass. Great. Where does it come from, what does your code look like, what are you trying to accomplish?
01:54:28 <merijn> shachaf: GHC doesn't actually seem to do anything when I run it under dtruss >.>
01:54:51 <startling> int-e: sec
01:55:27 <mapf> or maybe not. for exsample peek have only one arg but in report we have (peek.\)
01:55:34 <shachaf> merijn: Sounds like dtruss isn't working.
01:55:43 <shachaf> I think you need to be root or something under OS X. I don't really know how it works.
01:57:25 <mapf> it's strange that ghc user guide says nothing about damn dotbackslash
01:57:39 <merijn> shachaf: I already sudo for dtruss, otherwise it complains about insufficient privileges to begin with
01:58:49 <merijn> Passing "-L/usr/lib" to ghc makes it work again, what the heck?
02:01:50 <startling> https://gist.github.com/cc7fcf785c4ae9721f03 <- there's my specific error, other relevant code is in https://github.com/startling/lass L.Css.Fields and L.Css2.Fields
02:02:06 <shachaf> Hmm, "assert" is a magic function.
02:02:40 <startling> I'm getting weird errors with this Writer; I *think* it may have to do with my using ExistentialQuantification
02:03:34 <shachaf> startling: Can you make a self-contained test case?
02:04:00 <startling> shachaf: I can try. there's quite a bit going on
02:04:21 <shachaf> startling: You probably shouldn't be using ExistentialQuantification
02:04:29 <shachaf> class Value v where value :: v -> String
02:04:46 <shachaf> data QValue = forall v. Value v => Q v
02:05:02 <shachaf> That's the classic example of when what you want is probably *not* ExistentialQuantification.
02:05:19 <shachaf> QValue ~= String
02:06:02 <startling> shachaf, hmm, I could manage that
02:06:19 <startling> shachaf, is that likely to have caused these errors? I'm not getting it
02:06:32 <shachaf> Getting what?
02:06:43 <shachaf> I don't know what caused the errors and I don't want to read all these files.
02:06:49 <startling> haha, alright
02:07:01 <shachaf> In the process of making a self-contained test case you'll probably figure out the problem yourself.
02:07:07 <startling> shachaf: so using existential quantification to make a heterogenous list is a no-no?
02:07:12 <shachaf> (That's how it works.)
02:07:21 <shachaf> startling: That depends.
02:07:33 <shachaf> Think about what you can actually do with a QValue.
02:07:47 <shachaf> (That's a question.)
02:08:02 <startling> shachaf, turn it into a string, at the moment
02:08:10 <shachaf> Right. So you might as well use a String instead.
02:08:51 <shachaf> You have quite a lot of type classes here. Does it really make sense to use type classes rather than, say, values?
02:10:02 <startling> shachaf: well, I need Value at least to have any sanity
02:10:38 <startling> I've got a thousand types to enforce type-safety for css-generating functions like fontFamily
02:11:07 <startling> I thought it'd be neat to have Field so that I can have the same functions run in a Writer or also produce (field, value) pairs
02:11:09 <craigInnes> Hi, does anyone know of any good resources for learning how to use GHC's API from the ground up? I am trying to do some things for a university project involving dynamic compilation and parsing. So far from googling I have only come across the GHC API docs (which are rather impenetrable to a beginner) And a couple of small blog posts explaining how to do one specific thing.
02:15:36 <shachaf> startling: The issue in your case is just ambiguity.
02:15:49 <GnomeStoleMyBike> @slap me
02:15:50 <lambdabot> I'd rather not; GnomeStoleMyBike looks rather dangerous.
02:15:57 <GnomeStoleMyBike> :D
02:15:59 <GnomeStoleMyBike> <3
02:16:02 <zomg> craigInnes: I don't think there's that much info on those sadly.. One of those blogposts you've found might be mine (regarding dynamic loading and compilation)
02:17:58 <craigInnes> zomg: I think it might be yours yea. What would you suggest is the best way to get into this kind of thing for a beginner then if resources are sparse?
02:19:06 <zomg> Well what I did was trial and error, and looking at some other libs (like mueval) which do similar things
02:19:14 <Cale> Or hint
02:19:35 <zomg> You can always ask here too if you have specific questions
02:19:45 <Cale> hint is often enough to get by on as a little facade over the GHC API
02:19:56 <bartavelle> the packaged ghc (7.4.1) with ubuntu 12.04 gives me all kind of "strange closure" or "strange lambda", and the one at work (installed "by hand", 7.4.2) doesn't
02:20:12 <bartavelle> is it known to be buggy or should I suspect hardware problems ?
02:20:15 <Cale> But looking at the source code for it will probably also reveal a good bit about where to look in ghc's source if you want to understand things
02:20:25 <startling> shachaf: oh? a type signature doesn't help
02:20:32 <startling> shachaf: https://gist.github.com/1ce7dd1af58302f24f61
02:20:36 <startling> as small as I can get it
02:21:01 <Cale> bartavelle: I stopped trusting the Debian/Ubuntu packages for GHC a long time ago :/
02:21:14 <bartavelle> that is what I wanted to hear
02:21:25 <zomg> bartavelle: I had obscure issues with ghc 7.4.x on ubuntu 12.04 as well
02:21:37 * shachaf wonders what sort of polymorphism startling is after.
02:21:42 <zomg> Issues persisted even if I compiled it from source, but maybe slightly less than with the package
02:21:52 <bartavelle> ah :(
02:22:00 <zomg> Some dependencies for ghc on 12.04 seem to be a bit b0rky on it for some reason I think..
02:23:28 <shachaf> startling: Anyway, like I said, it's ambiguity.
02:23:53 <shachaf> It'll work fine if you add :: Writer [(String,Values)] () to one of the lines.
02:24:06 <bartavelle> ok then I will develop my programs on my nice workstation (12.04) and run them at work (10.04) then :(
02:24:30 <startling> shachaf: which lines? in the do expression?
02:24:30 <shachaf> Broken type inference is the price you pay for having too many type classes. :-)
02:24:34 <shachaf> Yep.
02:24:51 <startling> oh, I see
02:24:54 <shachaf> startling: Do you see what I mean about QValue being pointless?
02:24:59 <startling> shachaf: yeah.
02:25:09 <shachaf> And?
02:25:21 <startling> shachaf: so for all ghc knows, someField A could be Writer [(String, Values)] Anything
02:25:26 <startling> and there's no Field instance for that
02:26:01 <shachaf> Yep.
02:26:18 <startling> shachaf: I think I understand now. thanks for all your help.
02:26:44 <startling> and the reason this doesn't happen with MonadWriter et al is that their methods are well-typed
02:27:12 <startling> err, well, the result type of the monad isn't specified
02:32:30 <absence> mm_freak: thanks! i'll be sure to upgrade to 4 and check out what's new and different. as for synthesis, i already have working code for a single sine wave with netwire 3.1 (using stepWireM and arr sin as you suggest), the problem is multiple notes at the same time, i.e. dynamically "(de)allocating" wires, process them in parallel and merge/fold the result, ao that i can play chords of e.g. sine waves
02:36:53 <startling> shachaf: your name is forever memorialized in my commit messages
02:36:57 <cetium> are there any large scale projects has used haskell as the main dev language
02:37:13 <startling> cetium, xmonad
02:38:35 <fmap> xmonad itself isn't very large actually
02:38:43 <startling> cetium: Agda, Darcs
02:38:53 <startling> fmap: that's true. it's pretty well-known, though
02:39:19 <merijn> Why isn't base statically linked with its dependencies :(
02:39:38 <randomclown> what's the best way to make a function f :: A -> A -> A commutative?
02:39:39 <merijn> cetium: xmonad? GHC?
02:39:59 <randomclown> "data A" has a couple of members
02:40:01 <startling> randomclown, f _ _ = whatever
02:40:29 <donri> cetium: there's web startups like silk
02:40:29 <randomclown> I meant f a b = f b a
02:40:49 <startling> randomclown, that's not commutative?
02:40:54 <startling> also it never halts
02:41:09 <randomclown> startling: that's commutative
02:41:16 <startling> ohhh, you mean ==
02:41:29 <startling> randomclown, the example I gave you is commutative
02:42:03 <startling> let f _ _ = 12 in f 1 2 == f 2 1
02:42:06 <ClaudiusMaximus> f x y | x <= y = f' x y | otherwise = f' y x  -- assuming Ord, and then f' can assume certain ordering properties, and you can also then add   f' _ _ = error "precondition violated, internal error"  at the bottom to remove the annoying warnings
02:42:11 <startling> > let f _ _ = 12 in f 1 2 == f 2 1
02:42:12 <lambdabot>   True
02:43:42 <ClaudiusMaximus> but it's probably better to exhaustively list patterns and recurse like  f x@A2 y@A1 = f y x
02:44:09 <ClaudiusMaximus> but it's probably better to exhaustively list patterns and recurse like  f x@A2{} y@A1{} = f y x -- for more fields
02:44:11 <eilyx> how do i get Control.Monad.State
02:44:18 <startling> eilyx: it's in mtl
02:44:22 <ClaudiusMaximus> @hoogle Control.Monad.State
02:44:22 <lambdabot> Control.Monad.State module Control.Monad.State
02:44:23 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
02:44:23 <lambdabot> Control.Monad.Trans.State.Lazy type State s = StateT s Identity
02:44:43 <eilyx> startling, and mtl is what?
02:44:49 <ClaudiusMaximus> @hackage mtl
02:44:49 <lambdabot> http://hackage.haskell.org/package/mtl
02:44:55 <eilyx> yay thanks
02:45:27 <ClaudiusMaximus> .oO( @hoogle could also list packages that provide the module )
02:45:52 <startling> eilyx, cabal install mtl
02:46:20 <eilyx> excellent
02:46:59 <eilyx> i assume cabal works a lot like apt-get
02:47:28 <fmap> not really
02:47:33 <startling> sort of, but it only installs
02:47:48 <startling> and it gets crotchety when you ask it to update
02:48:13 <startling> "reinstalling is always a bad idea!"
02:48:15 <fmap> @google cabal is not a package manager
02:48:17 <lambdabot> http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
02:48:17 <lambdabot> Title: Repeat after me: “Cabal is not a Package Manager” « «Insert Name Here»
02:48:17 <startling> shhh, calm down cabal
02:48:51 <randomclown> it should be a package manager
02:52:23 <t7> that article is silly
03:02:45 <t7> i wish my source code looked like a beautiful latex document in real time
03:04:18 <donri> the irony is that currently cabal is a better package manager than it is a developer build tool
03:05:10 <fmap> time for "repeat-after-me-cabal-is-not-a-developer-build-tool"?
03:05:28 <t7> haha
03:06:07 <glah> www.goo.gl/6JzgL MOther in the dream welcome!
03:21:36 <ozgura> I just realised building on mountain lion means the executable cannot be run on snow leopard
03:21:44 <ozgura> it gives: dyld: unknown required load command 0x80000028
03:22:28 <ozgura> somebody says passing -mmacosx-version-min=10.4 as a linker option would solve the problem
03:22:39 <ozgura> how do I pass linker options via cabal?
03:23:14 <merijn> ozgura: I suspect you can just set "LDFLAGS" and ld (called by cabal/ghc) will do the right thing
03:23:32 <ozgura> hmm, I'll try --ld-options
03:24:00 <ozgura> merijn: let's first see if this command line argument works.
03:25:01 <ozgura> damn. ld: unknown option: -mmacosx-version-min=10.4
03:25:12 <ozgura> if passes the option to ld though, at least.
03:25:18 <merijn> What's the difference between ~/.cabal/config and ~/.cabal/config.platform?
03:39:39 <fmap> @ask edwardk could you please upload lens 3.0.2 on hackage?
03:39:40 <lambdabot> Consider it noted.
03:39:49 <edwardk> yes
03:40:11 <fmap> oh
03:40:11 <edwardk> done
03:40:16 <fmap> nice, thanks
03:40:41 <merijn> Thus he (edwardk) continues to prove that he will soon answer lens questions before they've even been asked ;)
03:40:56 <edwardk> =)
03:41:15 <edwardk> hey, i don't like doing product support, but i figure if I can do it quickly i can at least get it out of the way ;)
03:42:12 <int-e> yeah, one can also avoid tedious bug fixes by getting the code correct the first time ...
03:42:33 <edwardk> int-e: thats one of the reasons why i moved to haskell =P
03:42:39 * hackagebot lens 3.0.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.0.2 (EdwardKmett)
03:45:58 <merijn> Also, once your core users understand the library they can do your support for you ;)
03:46:15 <donri> is "import safe" useful for anything with -XSafe? seems it adds nothing in that situation
03:46:54 <merijn> On that note, I had an epiphany and finally understood the Lens signature
03:47:03 <edwardk> yay!
03:49:32 <merijn> The reason for the vague "(a -> f b) -> c -> f d" is because Control.Lens lenses allow polymorphic updates and otherwise you couldn't use operations that change the type of data structure (i.e. (Char, Int) to (Bool, Int)), right?
03:49:43 <edwardk> yep
03:49:47 <merijn> \o/
03:58:51 <merijn> loop (from ArrowLoop) is freaking black magic...
04:00:06 <absence> ghci has the best error messages ever :D "My brain just exploded"
04:01:26 <Ippo> absence: how did you get that error? it never happened to me
04:01:31 <nicoo> absence: On which input ?
04:02:55 <absence> don't worry, it also said "I can't handle pattern bindings for existential or GADT data constructors." so i know what i did wrong, but i like the spice :)
04:04:08 <maukd> Ippo: trying to unwrap existentials
04:04:19 <absence> input was "let (Session s upd) = clockSession" for reference, but i'm just poking around and don't have a problem to solve yet
04:04:58 <Cale> absence: That is actually referring to Simon Peyton Jones' brain
04:05:13 <nicoo> @hoogle clockSession
04:05:13 <lambdabot> No results found
04:05:19 <nicoo> @hoogle Session
04:05:19 <lambdabot> package SessionLogger
04:05:19 <lambdabot> package sessions
04:05:19 <lambdabot> package clientsession
04:05:56 <Nereid> @type uncurry id
04:05:57 <lambdabot> forall b c. (b -> c, b) -> c
04:05:57 <absence> nicoo: netwire 4.0 from darcs, not released yet
04:06:14 <Nereid> @type curry id
04:06:15 <lambdabot> forall a b. a -> b -> (a, b)
04:06:20 <Nereid> haha.
04:06:22 <Nereid> right.
04:06:26 <maukd> :t curry ($)
04:06:27 <lambdabot>     Couldn't match expected type `(a, b)'
04:06:27 <lambdabot>            against inferred type `a1 -> b1'
04:06:28 <lambdabot>     In the first argument of `curry', namely `($)'
04:07:15 <Nereid> @type first id
04:07:16 <lambdabot> forall b d. (b, d) -> (b, d)
04:07:27 <Cale> absence: btw, if you're breaking open a lot of existentials/GADTs in order to get at the juicy constraints inside, and getting annoyed with the nesting of case expressions, try pattern bindings :)
04:07:39 <nicoo> absence: Ok, thanks
04:07:40 <Cale> er, pattern *guards*
04:07:45 <maukd> or just don't indent
04:07:57 <Ippo> every time I log on this channel, I discover something new about haskell
04:08:02 <Ippo> it's nice
04:08:10 <Ippo> never heard about existential types
04:08:17 <Nereid> @type (***) id
04:08:18 <lambdabot> forall b b' c'. (b' -> c') -> (b, b') -> (b, c')
04:08:34 <Nereid> hey, that's second.
04:08:49 <liyang> Pro-tip: when using lhs2TeX with Template Haskell code, the former doesn't understand the latter, so can't distinguish between splices and ($). If you %format $ to display correctly for splices, you can then do %format `id` = ... to typeset ($), and replace $ with `id` throughout.
04:08:53 <Nereid> @type (***) (arr id)
04:08:54 <lambdabot> forall b (a :: * -> * -> *) b' c'. (Arrow a) => a b' c' -> a (b, b') (b, c')
04:08:57 <Nereid> @type (&&&) (arr id)
04:08:58 <lambdabot> forall b (a :: * -> * -> *) c'. (Arrow a) => a b c' -> a b (b, c')
04:09:03 <absence> Cale: ah, thanks :)
04:09:10 <Nereid> @type arr id &&& arr id.
04:09:11 <lambdabot> parse error (possibly incorrect indentation)
04:09:14 <Nereid> @type arr id &&& arr id
04:09:15 <lambdabot> forall b (a :: * -> * -> *). (Arrow a) => a b (b, b)
04:09:18 <Nereid> well duh.
04:09:51 <Cale> maukd: the case syntax kind of forces you to indent
04:10:05 <Cale> (and it's ugly not to indent things properly)
04:31:49 <TacticalGrace> If anybody missed my survey on which advanced Haskell topics people are interested to see teaching material on, you can still complete it: https://docs.google.com/spreadsheet/viewform?formkey=dE1QZFNRLTFMdkllYWIyR2FkYnRzZHc6MQ
04:31:54 <cornihilio> sorry, but what is the best way of printing the type of a variable in a trace statement?
04:32:11 <maukd> cornihilio: no
04:32:13 <cb_> does anyone know if it's possible to "ghci :import" some things that I didn't cabal install?
04:33:41 <HugoDaniel> cb_: if you have the modules in a folder then it should be ok
04:33:45 <HugoDaniel> <- captain obvious
04:34:08 <fmap> cb_: you don't need cabal install to install packages
04:34:35 <cornihilio> maukd: what?
04:34:37 <cb_> HugoDaniel: They aren't compiled though, they're just something.hs files but yes they are in a whole bunch of folders - how do i go about loading them into ghci? do I point :import at a particular file? or just the folder
04:35:27 <maukd> cornihilio: the answer is "no"
04:40:48 <HugoDaniel> cb_: use :l Module.hs
04:42:45 <Axman6> maukd: can't you use typeable to do it? :\
04:44:43 <cornihilio> maukd: I don't know what the type is; how am I supposed to find out?
04:45:14 <Axman6> :t typeOf
04:45:15 <lambdabot> forall a. (Typeable a) => a -> TypeRep
04:45:34 <Axman6> > show (undefined :: TypeRep)
04:45:36 <lambdabot>   "*Exception: Prelude.undefined
04:45:44 <Axman6> seems TypeRep has a Show instance
04:47:07 <Axman6> so you could use: showType :: (Typeable a, Show a) => a -> b -> b; showType a b = trace (show . typeOf $ a) b
04:47:20 <TacticalGrace> Axman6: won't work if the type isn't monomorphic (unless you thread Typeable constraints through)
04:47:30 <cb_> HugoDaniel: hmm... is there meant to be a file called Module.hs specifically? The thing I'm trying to load has lots and lots of .hs files (http://hackage.haskell.org/package/accelerate)
04:47:32 <maukd> cornihilio: didn't we already go over this?
04:47:45 <TacticalGrace> Axman6: isn't it embarrasing that this isn't easy?
04:47:52 <Axman6> yeah :\
04:48:02 <Axman6> also, it's good to be back talking Haskell again!
04:48:15 <TacticalGrace> ;)
04:48:28 <hiptobecubic> Axman6, instead of?
04:48:48 <Axman6> moving into our new place and many other things. haven't done anything even close to programming in a while
04:49:38 <Axman6> and getting ready for my new job
04:51:16 <hiptobecubic> nice, congratulations
04:51:30 <Axman6> :)
04:51:58 <nicoo> Axman6: Is your new job Haskell-related ?
04:52:34 <Axman6> no, not even programming related really. patent examiner at IP Australia
04:53:08 <Axman6> it will be computer related patents though. I'm kinda glad it's not programming, so i can do that in my own time
04:53:30 <pingu> let us know about the nice patents
04:53:44 <pingu> so i can patent them in some other countri
04:54:07 <Axman6> yeah... i'd prefer to keep my job =)
04:56:54 <hiptobecubic> Are you allowed to patent things yourself if you work at the patent office?
04:57:01 <hiptobecubic> obviously not approve your own
04:58:43 <cb_> i'm having trouble with conflicting versions of packages, the older I cabal installed - what's the best way to use the newer package?
04:59:05 <hiptobecubic> I usually just buy a new computer
04:59:09 <hiptobecubic> It's hopeless
04:59:21 * hiptobecubic wanders off
05:00:04 <ski> @ghc
05:00:04 <lambdabot> ghc says: In a case expression, type of scrutinee does not match patterns
05:00:59 <ski> merijn : .. why ?
05:02:25 <Bluelz> Hi ! Im working my way through some exercises in Haskell, and I've created a tree datastructure, with data MyTree = Leaf String | Branch (String, Mytree, Mytree). So far so good. Now however, I am trying to create a recursive function that visits all the nodes of my tree. How do I identify what my function has hit? Obviously it has either just hit a Leaf, or a Branch, but im not quite sure how I tell the two apart :S The Leaf is a simple String, w
05:02:25 <Bluelz> hile the Branch is a Tuple.
05:02:53 <hiptobecubic> Bluelz, you pattern match on the constructors
05:03:02 <frerich> Bluelz: You can use pattern matching for this; the (data) constructor used tells you what kind of node you're looking at.
05:03:15 <Bluelz> thanks a lot guys
05:03:18 <hiptobecubic> myFun (Leaf s) = doSomethingWith s
05:04:51 <ski> Bluelz : you have used pattern-matching before, yes ?
05:05:03 <notdan> What should I use if I want to port flex code to haskell? Alex?
05:05:50 <Bluelz> Well, I have some background in Java, knowing the concepts im looing for was all i needed, I was sort of stuck, but im sure i'll find out the syntax etc from google now that I know what I am looking for
05:06:19 <merijn> ski: The whole lazy use the returned value as input voodoo
05:07:05 <ski> `fix' is the same
05:07:27 <merijn> And you'd say that fix *isn't* black magic? xD
05:07:43 <hiptobecubic> Bluelz, have you done any tutorials or anything? Learn You A Haskell, for example?
05:08:29 <Bluelz> Im frequently hitting up Learn You a Haskell when im working my way through Google, yes, but I am primarily learning this from a book with some examples I bought a few days ago
05:08:33 <Cale> Oh, cool, Nikki and the Robots was released!
05:08:34 <ski>   myFunction :: Mytree -> ...
05:08:40 <hiptobecubic> Bluelz, ok sure.
05:08:42 <ski>   myFunction (Leaf aString)                        = ..aString..
05:08:44 <ski>   myFunction (Branch (aString,leftTree,rightTree)) = ..aString..leftTree..rightTree..
05:08:53 <ski> Bluelz : you want to write something like that ^
05:09:08 <pingu> whats haskel usually used for?
05:09:13 <ski> programming
05:09:15 <pingu> financial stuff?
05:09:32 <pingu> fast trading?
05:09:36 <merijn> pingu: The same thing other languages are used for?
05:09:40 <merijn> *things
05:09:43 <ski> merijn : well, but it's understandable
05:09:59 <ski> merijn : `mfix' and possibly `loop' are sometimes harder to understand
05:10:05 <nicoo> pingu: I mostly hear about people using OCaml for financial apps
05:10:22 <nicoo> But Haskell is a general-purpoose FP language
05:10:38 <pingu> FP?
05:10:48 <nicoo> Functionnal Programming
05:10:54 <pingu> oh
05:11:02 <merijn> ski: True, fix makes sense in my mind (if it returns something like ("abc"++) then I can figure out the thing laziness is doing), loop is far less intuitive
05:11:31 <ski> merijn : .. so i suppose i was wondering if you had any particularly inscrutable example :)
05:11:59 <merijn> ski: Naah, I was reading a blog post on AFRP game programming that was using loop to implement the game logic loop
05:12:12 <merijn> I know how the example works. It just still blows my mind
05:13:14 <ski> ok
05:17:16 <ski> augur : SYN ACK
05:17:28 <augur> ski!
05:17:29 <augur> :D
05:17:47 <ski> you're supposed to answer with `ACK'
05:18:45 <dreugeworst> Hi, I have a statement in a do-block, of the form: fmap (writeFile name . f) (readFile oldname) -- not sure of a nicer way to do this
05:19:11 <dreugeworst> however, ghc 7.4.1 comes back to me with the warning: A do-notation statement discarded a result of typ IO ()
05:19:24 <dreugeworst> why does it do this? shouldn't it just ignore those?
05:19:36 <augur> ski: wellnowwhat.net/linguistics/PregroupGrammarTutorial.pdf
05:20:22 <fmap> dreugeworst: probably you return IO (IO ())
05:20:48 <ski> dreugeworst : `writeFile name . f =<< readFile oldName'
05:21:37 <fmap> @type fmap (writeFile ?name . ?f) (readFile ?oldname)
05:21:38 <lambdabot> (?oldname::FilePath, ?f::String -> String, ?name::FilePath) => IO (IO ())
05:22:37 <maukd> dreugeworst: if you write code that's ignored, it's generally by mistake
05:22:41 <int-e> fmap: you're not powerful enough to use monads to full effect :)
05:22:47 <maukd> because why write code that doesn't do anything?
05:22:47 <fmap> :[
05:23:22 <augur> ski: we should write up something on that whole syntax-from-the-sequent-calculus stuff we were talking about
05:23:24 <zomg> IO (IO ()).. nice.
05:23:25 <zomg> :D
05:23:31 <chra> :t join
05:23:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:23:33 <int-e> @type join
05:23:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:23:46 <chra> ^_^
05:25:11 <dreugeworst> ohh never mind, I see
05:25:12 <int-e> The 'join' operator got its name because it's used to join the dark side.
05:25:21 <dreugeworst> I want >>=, not fmap
05:25:57 <ChousukeTheFinn> So why can't you do (identity :: a -> a) x = x or even (identity) x = x, someone tell me tht.
05:27:02 <hvr> int-e: the dark side of what? ;)
05:27:24 <nand`> the first one because type signatures aren't valid in patterns
05:27:26 <nand`> the second works fine
05:28:54 <int-e> > let (id x) = x in id 1 -- hmm. need to check the report :/
05:28:56 <lambdabot>   <no location info>: Parse error in pattern
05:29:52 <int-e> (this is irritating because  let (const x) y = x in const 1 2  is accepted by ghc.)
05:30:55 <int-e> hvr: the impure side of functional programming. (I'm talking about IO, the other monads are fine. But IO is enough to taint 'join'. ;) )
05:31:32 <Botje> int-e: that would make the definition of `on` so much nicer .. let ((+) `on` f) x y = f x + f y in ...
05:31:36 <hvr> int-e: but the dark side you need, otherwise no visible effect you have
05:32:38 <hiptobecubic> @src on
05:32:39 <lambdabot> (*) `on` f = \x y -> f x * f y
05:33:05 <hiptobecubic> Botje, what's wrong with that definition?
05:33:49 <int-e> hvr: I know :)
05:35:50 <GnomeStoleMyBike> @vixen
05:35:51 <lambdabot> Government enterprise is the most inefficient and costly way of producing jobs.
05:36:16 <merijn> GnomeStoleMyBike: @vixen doesn't exist anymore, it just autocorrects to @nixon
05:36:25 <GnomeStoleMyBike> @nixon
05:36:26 <lambdabot> Any lady who is first lady likes being first lady. I don't care what they say, they like it.
05:38:17 <augur> f is a homomorphism if f . * = * on f! and also other things
05:38:22 <Botje> hiptobecubic: I'm not a fan of the 'x y thing, nothing wrong per se
05:38:31 <int-e> Botje: Ok, this is indeed allowed, and infix operators seem to be the modivation. There's even an example in the report: (x `plus` y) z = x+y+z. (And the grammar is such that (foo bar) is disallowed - there must be at least one pattern after the closing parenthesis.)
05:38:43 <augur> i wonder if there's some interesting connection between . and on there
05:38:54 <int-e> that said I prefer the current definition of `on`.
05:39:00 <ski> int-e : i've been irritated by that as well
05:39:14 <augur> ski!
05:39:16 <ski> > let (id -> x) = x in x
05:39:20 <lambdabot>   mueval-core: Time limit exceeded
05:39:24 <ski> augur?
05:39:33 <augur> ski: just saying hi again :)
05:40:44 <hiptobecubic> Botje, you mean using lambda instead of pattern matching on the args?
05:41:25 <Botje> yes
05:42:19 <hiptobecubic> > let ((*) `myOn` f) x y = f x * f y in ((+) `on` negate) 3 4
05:42:20 <lambdabot>   -7
05:42:40 <hiptobecubic> Botje, like that?
05:42:46 <hiptobecubic> oops
05:42:50 <hiptobecubic> > let ((*) `myOn` f) x y = f x * f y in ((+) `myOn` negate) 3 4
05:42:51 <lambdabot>   -7
05:42:55 <hiptobecubic> still works
05:46:05 <Botje> hiptobecubic: yep
05:46:27 <hiptobecubic> Botje, I'm confused then
05:49:22 <Botje> about what?
06:00:11 <vss> hi
06:00:31 <sinisa> Does there already exist defined something akin to (s -> (a, s)) -> State s a? It would modify the current state and set the new return value.
06:00:50 <merijn> sinisa: modify?
06:00:52 <merijn> :t modify
06:00:53 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
06:01:08 <vss> af[gfdsgjmg]gsfgjsdkd
06:01:10 <fmap> @ty state
06:01:12 <lambdabot> forall s a. (s -> (a, s)) -> State s a
06:01:25 <vss> [fj*f]fgfd-gfdgh^hg2
06:01:47 <vss> india
06:03:59 <sinisa> merijn: modify seems to only update the state, not the return value. fmap: I'm not sure what this means. It looks like what I need, but how do I use it? What does @ty state mean? Thanks.
06:04:16 <maukd> sinisa: it tells you the type of 'state'
06:05:43 <deech> Hi all, is anyone aware of any proposed alternatives to do-notation?
06:06:00 <maukd> >>=
06:06:10 <maukd> monad comprehensions
06:06:19 <sinisa> maukd: Thanks, I see now. Only, I'm not sure how to find where the function state is defined. It seems to be lacking in Control.Monad.State.Strict|Lazy|Class.
06:06:34 <deech> maukd: I'd forgotten about monad comprehensions, that's pretty new right?
06:07:29 <ibid> monad comprehensions are old
06:07:38 <nand`> Control.Monad.State.Class.state
06:07:58 <fmap> sinisa: `state' is from `MonadState' typeclass
06:08:07 <maukd> @hoogle state
06:08:07 <lambdabot> Control.Monad.State module Control.Monad.State
06:08:08 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
06:08:08 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
06:08:42 <sinisa> nand`, fmap, maukd: Apologies, I understand now. Thank you very much.
06:09:05 <fmap> and lambdabot is actually quite wrong about its type :[
06:09:20 <nand`> which ‘state’ is lambdabot pulling in?
06:09:37 <nand`> :t Control.Monad.State.Class.state
06:09:38 <lambdabot> Not in scope: `Control.Monad.State.Class.state'
06:10:09 <int-e> deech: it's very old, it's something that was dropped in Haskell 98.
06:10:54 <fmap> @type Control.Monad.State.Lazy.state
06:10:55 <lambdabot> forall s a. (s -> (a, s)) -> State s a
06:11:06 <fmap> I guess it's from mtl-2.0.1.0
06:11:20 <k00mi> int-e: well, it's back as an extension
06:12:15 <fmap> because 2.0.0.0 doesn't have `state' at all, and in 2.1 it's typeclass method
06:36:08 <t7> @check f a = 2 * (2 * a) == (2 * a) ** 2
06:36:09 <lambdabot>   Parse error at "=" (column 5)
06:36:15 <t7> @check \f a -> 2 * (2 * a) == (2 * a) ** 2
06:36:17 <lambdabot>   "Falsifiable, after 1 tests:\n()\n2.0\n"
06:49:43 <otters> is there any facility for hotloading code in Haskell
06:50:22 <donri> what exactly do you mean
06:50:41 <otters> like if I was making a bot and wanted to load plugins at runtime
06:50:51 <donri> @hackage plugins
06:50:52 <lambdabot> http://hackage.haskell.org/package/plugins
06:51:02 <int-e> also hint
06:51:05 <otters> oh, awesome
06:51:27 <bartavelle> quick question about that plugin thingie
06:51:38 <bartavelle> would that work without a full ghc installation ?
06:51:44 <donri> hint is interpreted though so plugins run slow
06:51:48 <bartavelle> ie. can I distribute binaries that can hot load ?
06:52:05 <hirsch_> How can I use "read" in a mapped lambda in pointfree style without an external "read' :: String -> Int" function: map (\n -> read n:: Int) (words l)
06:52:35 <ski> hirsch_ : `read :: String -> Int' ?
06:52:39 <donri> bartavelle: that should work if you only use load and not make methinks
06:52:48 * hackagebot language-puppet 0.2.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.2.0 (SimonMarechal)
06:52:50 * hackagebot puppetresources 0.3.5 - A program that displays the puppet resources associated to a node given .pp files.  http://hackage.haskell.org/package/puppetresources-0.3.5 (SimonMarechal)
06:53:00 <ski> > map (read :: String -> Int) ["0","12","345"]
06:53:01 <lambdabot>   [0,12,345]
06:53:04 <otters> oh, load takes an object file?
06:53:08 <int-e> or map (...) (...) :: [Int]
06:53:09 <bartavelle> donri: then I have wasted my time including lua in my library !
06:53:17 <hirsch_> ski: Ups
06:53:21 <merijn> :t sum . map read
06:53:21 <hirsch_> damn
06:53:22 <lambdabot> forall a. (Num a, Read a) => [String] -> a
06:53:31 <donri> > map read ["0"] :: [Int]
06:53:32 <lambdabot>   [0]
06:53:41 <merijn> > sum $ map read ["1", "2", "4", "5"]
06:53:42 <lambdabot>   12
06:53:43 <ski> hirsch_ : but if you might get parse errors, it's better to not use `read'
06:53:54 <merijn> Gogo type inference ;p
06:54:06 <otters> is it possible to load a .hs file? :P
06:54:07 <hirsch_> ski: it's project euler, numbers are always valid
06:54:43 <donri> otters: that requires interpreting it (e.g. with hint) or compiling it (with plugins, requires ghc)
06:54:44 <otters> I guess that's what hint can do
06:54:48 <merijn> otters: Take a look at ghci (and I think mueval)?
06:55:15 <otters> oh, System.Plugins.Make provides a facility for compiling
06:55:35 <otters> so anyone who wants to make plugins has to have GHC handy, so I might as well use make
06:56:01 <quicksilver> you just compile your app so that it contains GHC-as-a-library
06:56:11 <hiptobecubic> won't that be huge?
06:56:12 <quicksilver> so you effectively are distributing GHC, but bundled
06:56:17 <int-e> hiptobecubic: yes
06:56:18 * quicksilver shrugs
06:56:42 <otters> this may be a stupid question but are .o files cross-platform?
06:56:45 <int-e> hiptobecubic: it's just what it says - the ghc compiler (or 95% of it anyway) as a library.
06:56:57 <donri> or just depend on ghc. it's what xmonad does for configuration
06:57:05 <int-e> otters: no.
06:57:12 <otters> that's what I thought
06:57:18 <quicksilver> otters: no, they're normal binary files for your platform (ELF, XCOFF, etc)
06:57:21 <donri> also: it's what every interpreted/vm ever does
06:57:38 <otters> so if I just want people to be able to *use* plugins
06:57:42 <otters> they still probably have to have GHC
06:58:02 <donri> otters: same is true for your app itself, no?
06:58:17 <otters> is it?
06:58:20 <donri> they either must compile it (requires ghc) or there's precompiled binaries for their platform
06:58:30 <otters> yeah I was thinking I would provide binaries
06:58:31 <donri> in the latter case, the same could be done for the plugins
06:58:39 <otters> oh yeah, that works too
06:59:43 <augur> byorgey: the factorization diagrams look like periodic tables
06:59:53 <augur> which makes me wonder if there's any deep and interesting patterns to discover in them
07:00:05 <Sculptor> hi!
07:00:26 <augur> i suppose there's as many such patterns as theorems in number theory!
07:03:52 <sclv_> i'm sort of surprised that there's no cute patterns outside of circles once we move to primes >= 7
07:04:09 <merijn> @tell edwardk btw, have you considered writing up the naming patterns you use in lens? I can tell it's there, but I don't always see what it is.
07:04:09 <lambdabot> Consider it noted.
07:05:57 <nand`> byorgey: what's the status of diagrams on 7.6.1?
07:06:14 <ski> augur : factorization diagrams ?
07:06:24 <copumpkin> translation: "byorgey: FIX THE FUCKING PACKAGE"
07:06:24 <augur> ski: http://www.reddit.com/r/haskell/comments/1117h2/factorization_diagrams/
07:06:29 <copumpkin> nand`: right?
07:06:29 <augur> ski: comments on my previous link?
07:06:39 <alpounet> sclv_, that's pretty logical actually
07:06:45 <nand`> copumpkin: well, I'm curious if it's “I haven't tried” or “I tried but it's complicated”
07:06:49 <nand`> because in the former case I could give it a try
07:06:53 <copumpkin> :)
07:10:14 <sclv_> alpounet: why so?
07:10:24 <sclv_> i assume there's some classic geometric theorem or something?
07:11:32 <sclv_> for seven i'd think you could use the points of a hexagon + one in the middle?
07:12:37 <sclv_> 11 = six around the outside, five on the inside? or vice versa?
07:12:49 <alpounet> well, sclv_, a prime number p is pictured as the p vertices of a polygon with p vertices
07:12:59 <alpounet> that's the way brent does for them i think
07:13:30 <sclv_> right -- so for one to five things look clear and after that they just approach circles i guess.
07:13:38 <alpounet> so there really is no cool patterns for them :/
07:14:04 <alpounet> sclv_, yeah, and with primes around 1000, it's basically a circle
07:15:45 <sclv_> yeah, so a nice idea i'm not going to implement (:-P) would certainly be to do nested polygons once primes go above a certain size, but i dunno if there's an elegant formula for "nice" looking choices
07:16:11 <alpounet> feel free to send me the code
07:16:21 <alpounet> for the online app
07:16:22 <sclv_> haha yes "patches welcome"
07:16:24 <sclv_> :-P
07:16:37 <alpounet> actually brent has made some changes to his code
07:16:54 <alpounet> i'll update the app accordingly soon
07:17:33 <byorgey> sclv_: yeah, one thing I want to play with is special-casing more small primes with nice patterns
07:17:56 <byorgey> or even special-casing infinite families of primes, e.g. prime hexagonal numbers, etc.
07:18:01 <alpounet> byorgey, some kind of spiral for primes would be fun
07:18:03 <alpounet> maybe?
07:18:08 <byorgey> alpounet: what do you mean?
07:18:16 <byorgey> oh, do a spiral instead of a circle?
07:18:29 <alpounet> less annoying than a circle, yeah :P
07:18:33 <alpounet> still not great
07:18:35 <byorgey> yeah, that would be nice
07:18:41 <byorgey> better information density
07:18:51 <alpounet> but i don't see something very cool that wouldn't make us confuse primes with the other numbers
07:18:56 <sclv_> oh cute, just googled hexagonal numbers
07:19:47 <byorgey> I guess I didn't actually mean hexagonal numbers but rather hexagonal packing numbers, or something, dunno if they have an official name
07:19:59 <byorgey> @oeis 1 7 19 37
07:20:00 <lambdabot>  Hex (or centered hexagonal) numbers: 3*n*(n+1)+1 (crystal ball sequence for ...
07:20:01 <lambdabot>  [1,7,19,37,61,91,127,169,217,271,331,397,469,547,631,721,817,919,1027,1141,1...
07:20:15 <byorgey> hex numbers, apparently =)
07:20:19 <sclv_> https://en.wikipedia.org/wiki/Centered_hexagonal_number ?
07:20:23 <byorgey> yes, those
07:21:49 <byorgey> anyway, I'm going to make all this into a diagrams-contrib module with interchangeable pieces so it's easy to assemble different sorts of visualizations
07:22:29 <byorgey> maybe this afternoon, if I can get done all the other stuff I need to do
07:23:05 <nand`> byorgey: diagrams-core seems to build on 7.6.1 after just increasing the upper limit on base/containers by one
07:23:11 <nand`> one subversion*
07:23:38 <byorgey> nand`: yes, the git versions of diagrams-core, -lib, -svg, and -contrib all build under 7.6.1
07:23:48 <byorgey> nand`: I'm going to make new releases soon
07:23:56 <nand`> git? I thought it was on darcs
07:23:59 <nand`> I see
07:24:02 <byorgey> nand`: however, gtk2hs doesn't build under 7.6.1 and hence neither does diagrams-cairo
07:24:16 <byorgey> nand`: I moved them all to github
07:24:21 <byorgey> http://github.com/diagrams
07:24:31 <nand`> ah, the hackage link points to patch-tag.com
07:24:42 <byorgey> yeah, I need to make new releases =P
07:34:12 <otters> :t \a b c d -> d a c b
07:34:13 <lambdabot> forall t t1 t2 t3. t -> t1 -> t2 -> (t -> t2 -> t1 -> t3) -> t3
07:41:08 <Jello_Raptor> hmm, where would I start if i wanted to write an epub parsing library (not just one for metadata like in hackage) from a structure standpoint? I'm new enough to haskell that I don't have that intuition for how to design a good framework.
07:42:29 <byorgey> Jello_Raptor: write down some types to represent an epub.
07:42:47 <hpc> types and operations; think about what you want the end user to see when they look at your docs
07:42:54 <hpc> or rather, what the end user wants to see
07:43:19 <Jello_Raptor> the end user in this case being the person using the library?
07:43:26 <merijn> Jello_Raptor: Yeah
07:44:11 <merijn> Jello_Raptor: Just start doing stuff like "data EBook" without defining what's in there, and then defining types on that data like "author :: EBook -> Author", etc.
07:44:28 <merijn> You can use "author = undefined" to let your file type check
07:44:50 <merijn> Jello_Raptor: Then keep adding new data declarations (and elaborating existing ones) as you need them while specifying functionality
07:45:23 <merijn> Jello_Raptor: Once you have a skeleton of functions/types you want, then you start worrying about implementing them
07:45:29 <hpc> while you are at it, run "cabal init" in your working dir
07:45:48 <merijn> Word.
07:45:59 <hpc> thinking about how to package things will help you reason about the code
07:46:04 <merijn> Once I finally bothered to setup cabal for my project I was annoyed I didn't do it sooner...
07:46:06 <hpc> at that high level
08:00:25 <Jello_Raptor> okay, so i want a generic ebook typeclass that allows people to get useful information, and then epub to be a specific implementation of it
08:03:10 <gdoteof> http://hpaste.org/75976 --- i am getting: :(31,9)-(32,116): Non-exhaustive patterns in function compare
08:03:16 <gdoteof> as a runtime error
08:03:47 <hpc> gdoteof: are empty slots greater than, less than?
08:03:54 <hpc> your code doesn't specify
08:04:21 <merijn> Jello_Raptor: I wouldn't specify the typeclass unless you actually implement it, tbh
08:04:24 <hpc> you probably also don't want to be using fromJust
08:04:32 <hpc> but that's unrelated to your current issue
08:04:54 <Jello_Raptor> merijn: i intend to, and I want to be able to extend to other file formats eventually (it's just for now epub is the best)
08:04:59 <gdoteof> hpc: ok.. hrm.
08:05:27 <Jello_Raptor> merijn: for the most part the EPUB class would be defined by the EBOOK typeclass
08:05:44 <merijn> Jello_Raptor: In what sense are EPUB ebooks different from other ebook's?
08:05:57 <monochrom> concrete before abstract. get epub to work first
08:06:13 <merijn> Jello_Raptor: i.e. other than needing to parse different formats, why not have a single datatype for all ebooks and parse all formats into that?
08:06:24 <merijn> Then you don't need a typeclass at all
08:06:26 <ski> gdoteof : ooi, what's `Empty' for ?
08:07:10 <merijn> Jello_Raptor: Using a typeclass "because they're there" is rarely a good plan :)
08:07:28 <Jello_Raptor> merijn: hmm, i'm not sure if "handling the lazy parsing of epubs requires a different backend than lazy parsing of simple html files / other formats" is a good response
08:07:37 <gdoteof> ski: to represent a seat that is empty.  seats are either occupied (and have meta information) or they are empthy
08:07:57 <merijn> Jello_Raptor: Sure, but that difference has no relevance to your datatype, right?
08:08:11 <ski> gdoteof : maybe use `Maybe' ?
08:08:22 <merijn> Jello_Raptor: Just define "parseEpub :: File -> IO Ebook" and "parseWhatever :: File -> IO Ebook"
08:08:56 <merijn> Jello_Raptor: Supposedly most (if not all) ebooks support the same types of metadata, and the missing ones you can just define as Maybe's
08:09:07 <ski> gdoteof : btw, you don't need the brackets around the `PlayerSlot ...' patterns in there
08:09:11 <merijn> i.e. EBook has a field "Maybe Keywords" or whatever
08:09:18 <Jello_Raptor> merijn: point
08:09:31 <merijn> Jello_Raptor: That'd be simpler to implement, nicer to work with, etc ;)
08:09:59 <gdoteof> ski: yeah that would make sense
08:10:02 <Jello_Raptor> merijn: mhmm, (note: this is why i'm asking the question :P i don't know this stuff)
08:10:12 <gdoteof> its been a while since i wrote this and it has been running smoothly for ~6 months
08:10:20 * ski doesn't like partial field selectors
08:10:31 <gdoteof> suddenly it is breaking on a basic feature right in that function
08:10:42 <monochrom> that just says you haven't run into Empty for 6 months
08:10:56 <augur> hey ski
08:12:15 <gdoteof> but that isn't possible?  there are empty seats 99% of the time
08:13:01 <ski> perhaps you haven't `compare'd them before, somehow ?
08:13:15 <ski> yeh augur
08:14:16 * ski . o O ( <http://en.wikipedia.org/wiki/Loop_(mathematics)> )
08:14:17 <hpc> @unmtl StateT state (ContT r IO) a
08:14:18 <lambdabot> state -> (a -> state -> IO r) -> IO r
08:14:46 <ski> @unmtl ContT r (ReaderT state IO) a
08:14:46 <lambdabot> (a -> state -> IO r) -> state -> IO r
08:14:54 <hpc> :P
08:15:23 <augur> ski: wat
08:15:43 <ski> @wn wat
08:15:44 <lambdabot> No match for "wat".
08:16:04 <hpc> augur: (a -> m r) -> m r
08:16:22 <augur> ski: whats this about loops
08:16:36 <ski> augur : your pregroups reminded me of it
08:17:34 <augur> ski: oh. they're probably related
08:19:18 <ski> augur : hm, is your `=<' supposed to be a congruence relation wrt `e' and `*' ?
08:19:51 <augur> ski: \leq is a preorder. i dont know if thats mentioned in the version i linked you to
08:19:56 <augur> sorry, a partial order
08:20:14 <augur> so (A,e,*) is a monoid partially ordered by <=
08:20:32 <augur> and more order the partial order has to satisfy the inequalities there
08:20:33 <gdoteof> i am trying this to fix it:  but it is wrong
08:20:38 <gdoteof> http://hpaste.org/75977
08:21:06 <hpc> :t local
08:21:07 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
08:22:24 <ski> augur : yes, but is `forall a0 a1 b0 b1. (a0 \leq a1) /\ (b0 \leq b1) => (a0 * b0 \leq a1 * b1)' supposed to hold ?
08:22:49 <augur> can you translate that into normal symbols? :p
08:23:25 <augur> forall x, x', y, y'.   x <= x' & y <= y'  --->  x*y <= x'*y'
08:23:25 <augur> yes
08:23:35 <augur> thats what it means to be a partially ordered monoid!
08:23:47 <augur> or part of it any way
08:24:07 <augur> more generally,   x <= x'   --->   xy <= x'y
08:24:14 <augur> and   yx <= yx'
08:24:21 <augur> from which yours follows
08:24:52 <monochrom> gdoteof: that is not the right syntax
08:25:07 <MagneticDuck> greetings
08:25:21 <MagneticDuck> I'm unsuccessfully trying to install wx on ubuntu
08:25:52 <MagneticDuck> no useful error messages
08:26:00 <MagneticDuck> wxc is having the problem
08:26:07 <trotro> i have the same
08:26:11 <trotro> there is a version problem
08:26:19 <trotro> ubuntu has an old sdl version
08:26:22 <gdoteof> monochrom: can you be more specific :)
08:26:25 <trotro> but wxc need a recent
08:26:36 <MagneticDuck> hm
08:26:38 <MagneticDuck> what do I do?
08:26:46 <trotro> (it's a shame when we think at what SDL is)
08:27:12 <MagneticDuck> what do I do?
08:27:14 <MagneticDuck> can I?
08:27:26 <MagneticDuck> and if so, how do I get reactive-banana to work with gtk2hs
08:27:29 <MagneticDuck> which I have installed already
08:27:41 <trotro> you do like me, you're waiting the correct versiuon s:)
08:28:05 <MagneticDuck> x|
08:28:31 <monochrom> "Empty `compare` Empty = ..." on one line. "(PlayerSlot _ s1 _) `compare` (PlayerSlot _ s2 _) = ..." on another line. etc.
08:28:32 <gdoteof> oh i see
08:28:35 <gdoteof> thanks
08:28:40 <bigfg> what would be the best equivalent to a doubly linked list in functional programming_
08:29:15 <Jafet> A doubly-linked list would be the best equivalent, except in the cases where there's a better one
08:29:39 <monochrom> depends on the use case
08:30:39 <hpc> the nearest pure data structure is the list zipper
08:30:45 <MagneticDuck> bigfg: if you're looking for the ease to walk up and down the list, I'd recommend zippers
08:31:01 <hpaste> ski annotated “Handler/Meta.hs” with “like this” at http://hpaste.org/75977#a75978
08:31:02 <MagneticDuck> they're just as powerful as doubly linked lists for that problem
08:31:05 <hpc> there are likely going to be other structures you can use
08:31:05 <ski> gdoteof ^
08:31:37 <MagneticDuck> anyway, does reactive-banana work with gtk2hs?
08:31:54 <bigfg> i am not really sure that is what i need, i feel that using lists is going to become a pain
08:32:03 <ski> augur : "thats what it means to be a partially ordered monoid" -- that's precisely what i wanted to check
08:32:08 <augur> :P
08:32:12 <augur> ski: well now you know! :)
08:32:17 <augur> ill put that in a margin
08:32:30 <ski> augur : now i know that you meant that in this case
08:32:41 <MagneticDuck> bigfg: lists in haskell are awesome! Just slow sometimes if you want to walk up and down. In that case, zippers solve the problem.
08:32:58 <MagneticDuck> http://learnyouahaskell.com/zippers
08:33:09 <n-dolio> The thing is, "doubly linked list" isn't typically something wanted as an end.
08:33:16 <MagneticDuck> yeah
08:33:28 <n-dolio> What people want is a queue, or a deque, or ....
08:33:44 <n-dolio> And in C or something, "doubly linked list" is the implementation.
08:33:58 <MagneticDuck> C is horrible
08:34:10 <bigfg> well i need a traversable vertex list
08:34:11 <MagneticDuck> but anyway
08:34:11 <MagneticDuck> x|
08:34:18 <MagneticDuck> ah
08:34:20 <MagneticDuck> zippers all the way
08:34:27 <bigfg> sounds like the appropriate structure
08:34:36 <tac> C is great for what it was meant to do.
08:34:40 <MagneticDuck> yeah
08:34:46 <trotro> tac, +1
08:34:56 <augur> ski: is the semantics part clear?
08:35:00 <MagneticDuck> and glass on the beach is great for what it was meant to do too
08:35:01 <MagneticDuck> :D
08:35:06 <MagneticDuck> depends what you want it to do
08:35:09 <MagneticDuck> most people don't like it
08:35:13 * ski points trotro in the direction of `@karma+'
08:35:19 <monochrom> do you really traverse in both directions? and one item at a time?
08:35:24 <nand`> edwardk: do you have an article on those zippers you demonstrated a while back?
08:35:35 <edwardk> not yet
08:35:35 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:35:36 <nand`> I'm looking for some kind of theoretical foundation they adhere to
08:35:38 <nand`> k
08:35:46 <MagneticDuck> okey, anyway..
08:35:53 <MagneticDuck> who here knows their reactive bananas?
08:36:15 <edwardk> the theory is they are abunch of nested traversals rather than a bunch of nested lenses like a few other variants use ;)
08:36:26 <MagneticDuck> anyone?
08:36:34 <nand`> edwardk: ‘nested’?
08:36:36 <MagneticDuck> I duck is in need of support
08:36:39 <MagneticDuck> *A
08:36:57 <edwardk> Top :> (String, String) :> String :> Char
08:37:21 <edwardk> each layer can be a traversal that i can move left or right within
08:37:24 <MagneticDuck> reactive-banana isn't popular??!?!?!
08:38:03 <nand`> mm_freak: what's the status of netwire on 7.6.1?
08:38:23 <nand`> lots of changes due to the operators I guess?
08:38:28 <edwardk> ultimately its the same reasoning as the traditional non-empty list zipper, its just that i get the list from a traversal instead
08:38:34 <hpc> hmm, if ContT r (ReaderT s m) is analogous to StateT s (ContT r m)
08:38:46 <hpc> what's get/set going to be?
08:38:52 <nand`> edwardk: sounds logical enough
08:39:27 <t7> are zippers just (a -> a) where container is (c a) ?
08:40:15 <MagneticDuck> no
08:40:35 * MagneticDuck tries to remember what zippers are
08:40:42 <hpc> @unmtl ContT r (Reader s) a
08:40:42 <lambdabot> (a -> s -> r) -> s -> r
08:40:43 <t7> data ZLeft Zipper | ZRight Zipper | ZThis  ?
08:40:57 <hpc> oh, well get is obvious
08:41:12 <MagneticDuck> so anyway
08:41:25 <MagneticDuck> who here knows their reactive bananas?
08:41:31 <MagneticDuck> (from their grapefruit)
08:41:55 <MagneticDuck> because I'm trying to figure out how to get it working with gtk2hs
08:42:05 <ski> @type ContT (\k -> ReaderT (\s -> k s `runReaderT` s))
08:42:05 <MagneticDuck> it says on the wiki page that it's possibl
08:42:07 <lambdabot> forall r r1 (m :: * -> *). ContT r (ReaderT r1 m) r1
08:42:07 <ski> @type \s -> ContT (\k -> ReaderT (\_ -> k () `runReaderT` s))
08:42:09 <lambdabot> forall r r1 (m :: * -> *). r1 -> ContT r (ReaderT r1 m) ()
08:42:11 <MagneticDuck> but maybe they haven't made a port..?
08:42:31 <edwardk> t7: the traditional list zipper looks something like data ListZipper a = ListZipper [a] a [a]  -- where the middle 'a' is the current focus and the list to the left is the stuff you've moved past, and the stuff on the right is the rest of the list
08:42:43 <edwardk> and the left hand list is assumed to be finite
08:42:46 <nand`> edwardk: (%) = flip id ?
08:42:50 <edwardk> nand`: yes
08:43:13 <edwardk> convenient for naming the target first
08:43:18 <nand`> that's useful for lenses in general
08:43:24 <edwardk> yep
08:43:35 <edwardk> and when you work it out %~ is the application of that operator to a lens target
08:43:36 <nand`> foo % bar .~ one % bat .~ two
08:43:45 <edwardk> hence the name
08:43:56 <tac> Is there a tl;dr explanation of what a lens is?
08:44:02 <nand`> foo { bar = one, bat = two }
08:44:08 <nand`> I can hardly tell the difference
08:44:36 <edwardk> tac: tl;dr: a getter and a setter pair
08:44:37 <maukd> tac: a pointer
08:44:54 <edwardk> tac: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285
08:45:06 <edwardk> the intro to that gives you a useful understanding of the notion of a lens
08:45:24 <ski> tac : a place in a data structure, where we've abstracted away from which data structure we're considering the place
08:45:38 <ski> @where lenses
08:45:38 <lambdabot> <http://twanvl.nl/blog/haskell/overloading-functional-references>,<http://cdsmith.wordpress.com/2011/04/26/composing-state-with-functions-and-lenses/>,<http://patternsinfp.wordpress.com/2011/01/31/
08:45:39 <lambdabot> lenses-are-the-coalgebras-for-the-costate-comonad/>,<http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutation>
08:47:29 <tac> hm
08:48:47 <MagneticDuck> well
08:48:59 <MagneticDuck> anyone here know their reactive bananas?
08:49:04 <MagneticDuck> (a third try)
08:49:10 <MagneticDuck> =|
08:49:15 <merijn> MagneticDuck: Apparently not? Maybe try a bit later?
08:49:35 <MagneticDuck> I waited for 7 minutes!
08:49:36 <MagneticDuck> :D
08:49:41 <MagneticDuck> yeah sure
08:49:54 <niteria> qpfiffer:
08:49:59 <niteria> oops
08:51:50 <mm_freak> nand`: i'd be happy to hear your feedback on that =)
08:51:55 <mm_freak> i have 7.4.2
08:52:06 <nand`> mm_freak: you mean re: operators?
08:52:16 <mm_freak> nand`: netwire on 7.6.1
08:52:36 <nand`> well, I can send you a failure log
08:53:03 <nand`> http://bpaste.net/show/49990/
09:07:56 * hackagebot hat 2.7.0.0 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.0 (OlafChitil)
09:09:57 <hpc> man, i can tell already that this code is going to make more sense in haskell than perl
09:11:52 <Luke> I've got some code that's running out of memory. What's a good way to evaluate what's causing all the mem?
09:12:07 <Luke> is there like a mem byte count by data type?
09:12:36 <ClaudiusMaximus> heap profiling
09:12:44 <bfgun> monochrom, i have no idea if i traverse in both or what. i think what i need is a sort of random access... this algorithms are all explained in terms of pointers
09:13:01 <bfgun> i think i will have to improvise some pointerish structure with random access
09:13:15 <ClaudiusMaximus> Luke: http://www.haskell.org/haskellwiki/Performance/Space
09:13:29 <Luke> thanks
09:13:30 <ClaudiusMaximus> bfgun: Map Integer foo
09:13:40 <ClaudiusMaximus> with MonadState perhaps
09:14:04 <hpaste> macrover pasted “type signatures” at http://hpaste.org/75979
09:14:34 <bfgun> ClaudiusMaximus, i'm afraid it is a bit more complicated than that. i need to query for neighbors, traverse using a priority list which doesn't depend very strongly on the order of the polygon vertexes
09:15:00 <macrover> need type signature clarification: http://hpaste.org/75979
09:15:24 <bfgun> i will need a map of ints yes, but i'll need something to simplify their access too
09:15:50 <Eduard_Munteanu> macrover: monomorphism restriction plus defaulting rules for Integer
09:16:15 <mysticc> @hoogle nub
09:16:15 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
09:16:15 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
09:16:41 <macrover> are those restrictions and rules just for ghci?
09:17:07 <Eduard_Munteanu> macrover: no
09:18:33 <ClaudiusMaximus> bfgun: got a reference to the imperative/pointer algorithm?
09:18:33 <Eduard_Munteanu> macrover: http://www.haskell.org/haskellwiki/Monomorphism_restriction
09:18:57 <bfgun> ClaudiusMaximus, in a book
09:19:16 <ClaudiusMaximus> oh
09:19:31 <bfgun> Polygon => [MonotonePolygon]
09:19:38 <bfgun> (for triangulation)
09:20:20 <ClaudiusMaximus> well, you could try ST and use newSTRef for mutable cells, to hide all the nasty stuff, then incrementally transform it to a more functional style
09:20:21 <bfgun> book is Computational geometry - algorithms and applications
09:21:05 <ClaudiusMaximus> i think Cale (?) had some nice example somewhere going step by step from loops and pointers to a functional style thing
09:21:23 <eyebloom> Would anyone happen to have a link to the source code for the Simon PJ paper "Fun with Type Functions". The link in the paper appears to be broken.
09:25:15 <ClaudiusMaximus> bfgun: http://book.realworldhaskell.org/read/functional-programming.html#fp.loop might be relevant, but i haven't finished reading it yet
09:25:25 <bfgun> checking it
09:25:59 <hpc> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.153.2211
09:26:05 <hpc> eyebloom: ^ is v2
09:26:14 <hpc> could be relevant
09:26:56 <int-e> eyebloom: https://research.microsoft.com/en-us/um/people/simonpj/papers/assoc-types/ has a working link
09:27:18 <eyebloom> hpc, int-e : many thanks.
09:27:31 <MagneticDuck> anyone here know their reactive bananas?
09:27:34 <int-e> (with one /fun-with-type-funs less)
09:28:44 <hpc> MagneticDuck: ♪♪ bananas have to ripen in a certain way / when they're flecked with brown and have a golden hue, bananas taste the best and are the best for you ♪♪
09:28:52 <MagneticDuck> xD
09:28:57 <eyebloom> int-e: not as much fun with type funs. Doesn't seem possible.
09:29:20 <hpc> https://www.youtube.com/watch?v=RFDOI24RRAE
09:29:31 <MagneticDuck> yes I know
09:29:34 <MagneticDuck> ~_~
09:29:36 <MagneticDuck> x|
09:29:36 <hpc> :P
09:31:23 <MagneticDuck> ...but really
09:32:12 <hpc> ask your question; someone who knows the answer will speak up
09:32:24 <hpc> or will help you muddle through the problem
09:32:55 <MagneticDuck> okay, is there a port of reactive banana to gtk2hs?
09:33:03 <MagneticDuck> pretty dam simple dat
09:33:09 <MagneticDuck> (the quesiton)
09:33:25 <hpc> https://duckduckgo.com/?q=reactive+banana+gtk
09:33:33 <danharaj> quack
09:33:37 <hpc> reactive-banana-gtk on github :P
09:34:01 <MagneticDuck> kool
09:35:06 <MagneticDuck> wait just a gosh darn second..
09:35:07 <MagneticDuck> um..
09:35:08 <MagneticDuck> lol
09:35:11 <MagneticDuck> that's a pretty small port
09:35:13 <MagneticDuck> 1 file?
09:35:24 <MagneticDuck> 62 lines??
09:35:29 <MagneticDuck> hm
09:35:33 <MagneticDuck> not what I thought
09:35:36 <MagneticDuck> I have a bit to learn
09:36:10 <hpc> oh, hmm
09:36:21 <hpc> it could either be really easy to port, or that is horribly incomplete
09:37:57 * hackagebot GLUtil 0.2.1 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.2.1 (AnthonyCowley)
09:38:48 <MagneticDuck> another one has 48 lines
09:38:51 <MagneticDuck> bwahahahaha
09:38:58 <MagneticDuck> I'll check on hackage
09:39:32 <MagneticDuck> nuthin' on hackage
09:45:04 <Springwight> http://www.westpoint.edu/eecs/SiteAssets/SitePages/Faculty%20Publication%20Documents/Okasaki/jfp95queue.pdf
09:45:16 <Springwight> Is it my imagination or is the finally proposed queue (not deque) uses O(n) additional space
09:45:56 <Springwight> Since it basically contains references to a list and all of its sublists
09:46:24 <Springwight> I guess that's not bad
09:46:36 <Springwight> I mean the same happens if you have a count for each sublist
09:46:43 <Springwight> meh
09:46:51 <jfischoff> is there a Data.Vector equivalent of group?
09:47:52 <Luke> ClaudiusMaximus: Warning: 'ghc-options: -prof' is not necessary and will lead to problems when
09:47:58 * hackagebot GLUtil 0.2.2 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.2.2 (AnthonyCowley)
09:48:02 <Luke> ClaudiusMaximus: the recommendations of the webpage you sent me don't seem to work
09:50:42 <efie> Is there a website where people can express their happiness that they (think they) got to understand monads? :)
09:51:08 <danharaj> write a monad tutorial and post it to reddit
09:51:31 <tac_> danharaj is spot on. That's the usual ritual.
09:51:47 <jfischoff> oh man
09:52:05 <bfgun> ClaudiusMaximus, i'm going to implement the program in c, then use what i learned to slowly work it into haskell
09:52:15 <hpc> when i start writing a monad tutorial, i stop writing it and be awesome instead
09:52:35 <hpc> true story
09:52:42 <jfischoff> @remember hpc when i start writing a monad tutorial, i stop writing it and be awesome instead
09:52:42 <lambdabot> Okay.
09:54:58 <bfgun> @bfig
09:54:58 <lambdabot> Maybe you meant: bf bid bug
10:00:10 <tac_> Does anyone know of any software or library for pretty printing derivation trees?
10:00:30 <callen> still no response on my github issue for my broken cabal.
10:00:38 <callen> carthago delenda est
10:01:38 <edwardk> callen: Isn't that somewhat of a severe response? I mean I don't think dcoutts is even in Carthage.
10:03:15 <ClaudiusMaximus> Luke: cabal install --enable-executable-profiling --enable-library-profiling
10:03:19 <callen> edwardk: the reason for the reference is that i've been beating the drum of cabal's brokenness for awhile now.
10:03:34 <Luke> ClaudiusMaximus: ah yeah I saw it output that. Can I put that in my cabal file?
10:03:40 <johnw> your name must be Cato Allen then
10:03:49 <ClaudiusMaximus> bfgun: fair enough
10:03:57 <ClaudiusMaximus> Luke: ghc-prof-options
10:04:05 <Luke> nice - thanks
10:04:10 <callen> johnw: close enough.
10:04:30 <ClaudiusMaximus> but you'll probably find that you didn't put library-profiling: True in your cabal config, and have to reinstall everything :(
10:05:18 <ClaudiusMaximus> causing epic breakage unless you're very careful (my strategy is "make a copy of cabal world, nuke the ghc directory from orbit, cabal install world"
10:05:47 <ClaudiusMaximus> ~/.cabal/world contains a list of packages you've installed
10:05:54 <Cale> tac_: maybe http://www.math.ucsd.edu/~sbuss/ResearchWeb/bussproofs/index.html
10:05:58 <monochrom> be aware that "world" make be too large. it is not world, it is history. it contains junk that you forgot about
10:06:08 <ClaudiusMaximus> true
10:06:10 <monochrom> s/make/may/
10:06:19 <Cale> tac_: See the "Peter Smith's documentation" link
10:06:30 <ClaudiusMaximus> but at least it'll make sure that you don't get weird version conflicts
10:06:33 <edwardk> Sure, but there are 20,000 people living in Carthage today that have probably never heard of Cabal. Seems somewhat cruel to attack them instead. It reminds me of http://images.lolstream.com/assets/media_show/244__0723eb0704c0eaf27f49e838855cdb6d.gif
10:06:37 <edwardk> =)
10:06:44 <ClaudiusMaximus> ie, it'll install everything in a compatible way, if it can
10:07:23 <Cale> http://www.logicmatters.net/latex-for-logicians/nd/
10:08:07 <monochrom> oh w00t, natural deduction latex code :)
10:08:19 <danharaj> What's the difference between stdcall and ccall and should I be afraid that every ffi binding in this package I'm building is emitting a warning on Windows x86-64?
10:08:45 <monochrom> gcc is ccall, windows API is usually stdcall
10:08:57 <johnw> stdcall and ccall, I believe, is the difference between the caller and callee unpacking arguments
10:08:59 <tac_> Cale: thanks
10:09:03 <johnw> i.e., they are mutually incompatible
10:09:45 <johnw> ccall is what the world uses, and stdcall is what Windows chose for their DLL architecture
10:09:52 <monochrom> and what johnw says. it affects whether "return address, then arguments" or "arguments, then return address"
10:10:16 <danharaj> hm, wikipedia says that there's only one calling convention on windows x86-64 anyway.
10:10:34 <monochrom> ah, but which one? :)
10:10:39 <johnw> the AMD64 ABI
10:10:44 <johnw> i believe
10:10:48 <shachaf> johnw: Windows x64 doesn't use the AMD64 ABI.
10:10:52 <johnw> ah, ok
10:11:00 <shachaf> That would be way too easy.
10:11:02 <johnw> yeah, it's a private Windows ABI then
10:11:08 <Luke> ClaudiusMaximus: when I compile with those flags it's complaining it cant find Prelude and 'base' package. Does that mean I'll have to reinstall everything with some profiling flags? is there an easy way to do that?
10:11:24 <johnw> as someone whose company is currently being contracted to make a 64-bit compiler for Windows x86_64, let me tell you the answers aren't simple to these questions
10:11:36 <shachaf> #define ccall stdcall // problem solved
10:12:06 <ClaudiusMaximus> Luke: which distro?  perhaps it split out separate profiling versions
10:12:11 <shachaf> I'd like to imagine that johnw works for Microsoft or something.
10:12:13 <ClaudiusMaximus> into separate packages
10:12:29 <Luke> ClaudiusMaximus: ubuntu but I use platform and cabal to install everything, not apt
10:12:30 <luite> johnw: for what kind of language?
10:12:35 <johnw> shachaf: actually I'm working on a competitor's compiler.  It's for C++
10:12:46 <johnw> I cannot say more :)
10:12:54 <hpc> so intel, then :P
10:12:56 <johnw> only that I've spent days debating these exact issues
10:13:04 <ClaudiusMaximus> Luke: platform with apt?  or platform from tarball?
10:13:13 <shachaf> johnw: All sufficiently advanced compilers end up being for C++.
10:13:16 <danharaj> The issue really is if I should be afraid that GHC is going to accidentally the call convention on my platform :P
10:13:19 <shachaf> It'll happen to GHC too, just you wait.
10:13:23 <johnw> lol
10:13:29 <Luke> ClaudiusMaximus: checking....
10:13:38 <johnw> pretty soon C++ will just adopt GHC as its own preprocessor
10:13:42 <ClaudiusMaximus> Luke: http://packages.ubuntu.com/precise/haskell-platform-prof
10:13:43 <johnw> s/own/new
10:13:54 <Luke> ClaudiusMaximus: thanks
10:13:55 <armlesshobo> 예
10:13:56 <luite> all sufficiently advanced compilers will eventually output javascript
10:14:03 <armlesshobo> oops, sry
10:14:21 <hpc> luite: i have devised a sufficiently advanced javascript compiler!
10:14:23 <hpc> @let compile = id
10:14:25 <lambdabot>  Defined.
10:14:29 * ski thought this was the new style smiley ..
10:14:56 <johnw> .. is like an early chinese smiley, where the space surrounding the essential element is meant to suggest the whole
10:14:59 <Luke> ClaudiusMaximus: looks like I used the tarball
10:15:25 <armlesshobo> johnw: that was deep.
10:15:32 <armlesshobo> :D
10:15:59 <soapyillusions> Quick Question: If I have a bunch of (Either String a) is there an idiomatic way of saying: "If any of these have a 'Left' print that error string otherwise execute f" I cannot map a function over them because all their Right a's are of different types and therefore cannot bundle them into a list.
10:16:16 <johnw> soapyillusions: use the Applicative instance for Either
10:16:25 <johnw> soapyillusions: f <$> myEitherValue
10:16:45 <armlesshobo> johnw: would using maybe work?
10:16:52 <ClaudiusMaximus> > sequence [ Right "yo!", Left "dawg", Right "o rly" ]
10:16:53 <lambdabot>   Left "dawg"
10:17:13 <armlesshobo> ahhh, this is over a list
10:17:19 <ClaudiusMaximus> oh ignore me, i misread
10:17:22 <johnw> > [ Right "yo!", Right "dawg", Right "o rly" ]
10:17:23 <monochrom> <$> is now in Data.Functor, too
10:17:23 <lambdabot>   [Right "yo!",Right "dawg",Right "o rly"]
10:17:44 <johnw> > map (id <$>) [ Right "yo!", Right "dawg", Right "o rly" ]
10:17:45 <lambdabot>   [Right "yo!",Right "dawg",Right "o rly"]
10:17:54 <johnw> > map (id <$>) $ sequence [ Right "yo!", Right "dawg", Right "o rly" ]
10:17:55 <lambdabot>   Couldn't match expected type `[a]'
10:17:55 <lambdabot>         against inferred type `Data.Eith...
10:18:06 <ClaudiusMaximus> johnw: mapM
10:18:06 <shachaf> (id <$>)?
10:18:10 <johnw> ahh
10:18:13 <soapyillusions> yesp but I cannot make a list of elems which are (Either String Config) and (Either String Post)
10:18:16 <johnw> > mapM (id <$>) [ Right "yo!", Right "dawg", Right "o rly" ]
10:18:17 <lambdabot>   Right ["yo!","dawg","o rly"]
10:18:23 <johnw> id <$> is just my f <$>
10:18:26 <ski> > liftA2 replicate (Right 3) (Right ' ')
10:18:27 <johnw> > mapM (id <$>) [ Right "yo!", Left "dawg", Right "o rly" ]
10:18:27 <lambdabot>   Right "   "
10:18:28 <lambdabot>   Left "dawg"
10:18:32 <shachaf> (id <$>) = id
10:18:33 <ski> > liftA2 replicate (Left "oops") (Right ' ')
10:18:34 <lambdabot>   Left "oops"
10:18:36 <shachaf> It's The Law.
10:18:37 <monochrom> you need Either String (Either Config Post), maybe
10:18:45 <ClaudiusMaximus> ski++
10:18:47 <armlesshobo> why couldn't he use maybe?
10:19:02 <johnw> yesterday I learned the hard way how foldl' differs from foldM
10:19:09 <ski> ClaudiusMaximus ?
10:19:14 <monochrom> because "maybe" works for Just/Nothing, not Left/RIght
10:19:16 <johnw> I just couldn't get my actions to execute during the fold with foldl'...
10:19:20 <soapyillusions> here I will post a gist with a little code snippet to clear up my situation
10:19:26 <armlesshobo> monochrom: crap...wow...you're right.
10:19:31 <ClaudiusMaximus> getting the correct answer when we were all missing the point
10:19:39 <armlesshobo> monochrom: i'll see myself out. it's too damn early for me.
10:19:40 <monochrom> but! you can suggest "either" :)
10:19:48 <armlesshobo> monochrom: hahaha right
10:19:58 <shachaf> either id id
10:20:04 <johnw> and you are armless, we'll give you a break fro that
10:20:09 <soapyillusions> here is what I currently have https://gist.github.com/3853706
10:20:09 <ClaudiusMaximus> johnw++ # for suggesting it before ski
10:20:12 <armlesshobo> much appreciated
10:20:15 <johnw> either (id <$>) (id <$>)
10:20:35 <ClaudiusMaximus> SoupE: liftAx is what you want i think
10:20:36 <armlesshobo> soapyillusions: you can map 'either' over the list
10:20:48 <ClaudiusMaximus> armlesshobo: it's not a list, that was my misreading
10:20:57 <nand`> mapM (id <$>) = sequence
10:21:02 <armlesshobo> soapyillusions: or, you could not do that as it wouldn't solve your issue...
10:21:08 <armlesshobo> ClaudiusMaximus: lol gotcha
10:21:09 <int-e> fmap id = id
10:21:17 <ski> ClaudiusMaximus : johnw already suggested `<$>'
10:21:19 <johnw> nand`: well, the idea was to use some f instead of id, but I thought > would complain
10:21:20 <int-e> and (id <$>) = fmap id
10:21:35 <ski> (and i bet johnw also was thinking about `<*>')
10:21:44 <armlesshobo> ClaudiusMaximus: well the very least would be to use either and then do pattern matching with the two supplied functions lol
10:21:47 <johnw> (I always think about <*> when I think about <$>) :)
10:22:19 <ski> (:
10:22:26 <soapyillusions> <$> looks like it might be helpful, anywhere I can read up on that
10:22:41 <monochrom> <$> is infix notation for fmap
10:22:41 <ski> `(<$>)' is just `fmap'
10:22:55 <johnw> <$> is extremely useful
10:23:08 <ClaudiusMaximus> soapyillusions: 18:18 < ski> > liftA2 replicate (Right 3) (Right ' ')
10:23:15 <johnw> whenever you have a value-in-context, and you want to apply a function to it and have the answer also-in-context, you can use <$>
10:23:20 <johnw> (+1) <$> [2]
10:23:20 <Clint> it's prettier than `fmap`
10:23:22 <johnw> > (+1) <$> [2]
10:23:23 <lambdabot>   [3]
10:23:23 <ski> > ((2 *) <$>) <$> [Just 2,Nothing,Just 3]
10:23:24 <lambdabot>   [Just 4,Nothing,Just 6]
10:23:37 <shachaf> > (2*).:[Just 2,Nothing,Just 3]
10:23:39 <armlesshobo> johnw: none of that voodoo please
10:23:39 <lambdabot>   [Just 4,Nothing,Just 6]
10:23:42 <monochrom> LYAH discusses fmap
10:23:43 <soapyillusions> ohhh wow, that would solve a lot of stuff
10:24:03 <soapyillusions> sry I'm a day and half into my Haskell experimentation
10:24:09 <armlesshobo> .: unwraps values?
10:24:10 <ski> > replicate <$> Left "oops" <*> Right ' '  -- fwiw
10:24:12 <lambdabot>   Left "oops"
10:24:12 <johnw> soapyillusions: you can then use <*> to pass additional arguments
10:24:19 <johnw> > (+) <$> [2] <*> [3]
10:24:20 <lambdabot>   [5]
10:24:33 <Cale> armlesshobo: .: is fmap . fmap
10:24:39 <johnw> (That's not really what <*> _means_, but functionally it serves that purpose here)
10:24:42 <nand`> > (+1) . [2]
10:24:44 <lambdabot>   [3]
10:24:48 <armlesshobo> oooh. okay
10:24:51 <armlesshobo> Cale: ty
10:24:57 <soapyillusions> (+) <$> [2] is curried and then applied with [3] ?
10:25:02 <monochrom> yes
10:25:08 <soapyillusions> cool cool
10:25:14 <johnw> nand`: what instance are you using to do that?
10:25:17 <nand`> ‘curried’?
10:25:25 <nand`> johnw: Functor []
10:25:32 <johnw> ah, very col
10:25:35 <Cale> soapyillusions: Well, (+) is curried (as functions usually are) to begin with
10:25:37 <johnw> hadn't seen that trick before
10:25:44 <nand`> in lambdabot, (.) = fmap
10:25:45 <monochrom> it means you parse (f <$> x) <*> y
10:25:50 <johnw> by 'curried' is usually meant 'partially applied'
10:26:03 <johnw> which will bite you once you come to the functions curry and uncurry
10:26:04 <nand`> since fmap on Functor ((->) r) is just (.)
10:26:05 <shachaf> Usually neither of those things is meant and both are misused.
10:26:06 <armlesshobo> (((+) 1) 2)
10:26:10 <soapyillusions> johnw that's what I meant to say
10:26:24 <Cale> Currying is the process of turning functions of multiple parameters into functions of a single parameter which produce other functions.
10:26:31 <johnw> nand`: clever!
10:26:45 <shachaf> Cale: (+) isn't curried because there was no multi-parameter function to begin with. :-)
10:26:45 <armlesshobo> soapyillusions: in this case it's just a function being called. you're not left with a partially applied function.
10:26:51 <Cale> Partial application is the process of applying a function to some of its parameters in order to produce another function.
10:26:53 <nand`> johnw: it's one of those things that's cool for one-liners but incredibly annoying once you start getting type errors
10:26:55 <armlesshobo> soapyillusions: think of it as another way of expressing the same thing.
10:27:10 <armlesshobo> > 1 + 2
10:27:11 <lambdabot>   3
10:27:18 <armlesshobo> > (+) 1 2
10:27:18 <shachaf> Cale: Also known as "application".
10:27:19 <lambdabot>   3
10:27:20 <ski> > [f <$> [2],f <$> [2] <*> [3]] :: [[Expr]]
10:27:22 <lambdabot>   [[f 2],[f 2 3]]
10:27:23 <johnw> Cale: so that fact that partial application in Haskell _looks_ like currying is what confuses people?
10:27:40 <int-e> Haskell is a language of good taste - everything is curried by default.
10:27:50 <Cale> johnw: The functions are already curried in Haskell.
10:28:01 <ski> `f <$> [2]' is `[f 2]', and `f <$> [2] <*> [3]' is `[f 2] <*> [3]' is `[f 2 3]'
10:28:01 <soapyillusions> ok that's why there is no destinction between param and return val
10:28:06 <shachaf> johnw: Currying is what the function "curry" does.
10:28:10 <shachaf> That's all.
10:28:11 <Cale> johnw: You don't curry them, you just write them in an already-curried form usually.
10:28:18 <shachaf> It has nothing to do with application.
10:28:35 <Cale> soapyillusions: There is a distinction!
10:28:39 <armlesshobo> soapyillusions: not true
10:28:45 <Cale> soapyillusions: but I think I know what you're talking about :)
10:28:50 <johnw> Cale: by your definition, (a -> b -> c) -> (a, b) -> c is proper currying, as it takes a function of multiple arguments and yields a function that takes fewer arguments, which is just what curry says, as shachaf mentioned
10:28:51 <Cale> soapyillusions: when you see A -> B -> C
10:28:57 <Cale> soapyillusions: it means A -> (B -> C)
10:29:00 <shachaf> johnw: That's uncurry
10:29:03 <johnw> oh
10:29:03 <ski> johnw : "currying" means "the process of turning a non-curried function into a curried function"
10:29:08 <shachaf> curry :: ((a,b) -> c) -> a -> b -> c
10:29:17 <Cale> soapyillusions: and when you write f x y, it means (f x) y
10:29:17 <johnw> let me read what Cale wrote again
10:29:18 <armlesshobo> johnw: what ski said
10:29:40 <shachaf> ski: $VERBing means "the process of turning a non-$VERBed thing into a $VERBed thing"
10:29:46 <soapyillusions> Cale ok that's making sense
10:29:46 <johnw> and a curried function is?
10:29:49 <soapyillusions> Cale hanks
10:29:59 <ski> johnw : given `f :: A -> B -> C' (a curried function), and `a :: A', then `f a' (of type `B -> C') is known as "partially applying" `f' to `a'
10:30:09 <johnw> yes
10:30:17 <armlesshobo> johnw: a function that has been transformed to allow you to make partially applied functions
10:30:35 <Cale> soapyillusions: Every function in Haskell really has exactly one parameter. We provide the illusion of multiple parameters by this choice of notation :)
10:30:36 <johnw> armlesshobo: oh, that's a good definition
10:30:39 <monochrom> "curry (\(x,y) -> y)" is an example curried function
10:31:07 <soapyillusions> Cale that line just sums it up very well!
10:31:08 <shachaf> Is the first "id" in "id id 5" partially applied?
10:31:08 <mizu_no_oto> Speaking of curry, why isn't there curry3, curry4, curry5...?
10:31:10 <armlesshobo> johnw: how ever, Haskell does it for you.
10:31:32 <Mertesacker> what's an ulcer?
10:31:37 <ski> johnw : given `f :: (A,B) -> C' (a "tupled" function), and `b :: B', then `\a -> f (a,b)' (of type `A -> C') is also sometimes known as "partially applying" `f' *in the second "argument" (the second part of the pair)* to `b'
10:31:41 <Cale> mizu_no_oto: Because nobody really cares about larger tuples
10:31:42 <armlesshobo> > :t (\x y -> x + y ) 4
10:31:43 <lambdabot>   <no location info>: parse error on input `:'
10:31:50 <ski> shachaf :)
10:32:17 <Luke> ClaudiusMaximus: I installed platform and platform-perf for Ubuntu but it's still unable to install with those flags because it' can't find "base" ackage
10:32:19 <Luke> package
10:32:43 <shachaf> I like ddarius's definition of partial application.
10:32:47 <ski> shachaf : yes, it is :)
10:32:52 <nand`> :t curry . curry
10:32:54 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
10:32:55 <monochrom> oh, what is his definition?
10:33:01 * hackagebot snap-core 0.9.2.2 - Snap: A Haskell Web Framework (core interfaces and types)  http://hackage.haskell.org/package/snap-core-0.9.2.2 (GregoryCollins)
10:33:03 * hackagebot snap-server 0.9.2.4 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.9.2.4 (GregoryCollins)
10:33:05 * hackagebot snap 0.9.2.2 - Top-level package for the Snap Web Framework  http://hackage.haskell.org/package/snap-0.9.2.2 (GregoryCollins)
10:33:08 <nand`> :t uncurry . uncurry
10:33:09 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
10:33:10 <nand`> that's why
10:33:42 <ClaudiusMaximus> Luke: check the output of "which ghc" - maybe it's using some unexpected one
10:33:57 <ClaudiusMaximus> Luke: then adjust your $PATH environment variable?
10:34:06 <armlesshobo> :t (\x y -> x + y ) 4
10:34:07 <lambdabot> forall a. (Num a) => a -> a
10:34:29 <monochrom> or the special case Integer -> Integer
10:34:39 <monochrom> it will map y to 4+y
10:34:43 <Luke> ClaudiusMaximus: path has my ~/.cabal/bin taking precidence over the ubuntu path which should be ok. i started with a fresh .cabal and GHC dir
10:34:43 <ClaudiusMaximus> Luke: or cabal install -w/usr/bin/ghc or something like that, check cabal install --help for the flag to tell it which compiler to use
10:34:47 <shachaf> monochrom: "(f x) is a partial application iff f x == (curry (uncurry f) x)"
10:36:01 <monochrom> that is an evil way to hide the real condition (the type of f) behind an equation
10:36:15 <Cale> Mertesacker: Why do you ask?
10:36:24 <shachaf> monochrom: The main purpose of this definition isn't the types but other behavior.
10:36:25 * Polarina wonders why tuples, whose attributes are instance of Foldable, aren't an instance of Foldable.
10:36:30 <nand`> might as well say iff f x = g f x where g = id :: (a -> b -> c) -> (a -> b -> c)
10:36:54 <ski> shachaf : `remember' ?
10:36:55 <shachaf> monochrom: In a language with side effects you might have arbitrary behavior. In Haskell you might have _|_. In a total language every application is partial.
10:37:10 <Mertesacker> Cale: someone said they were making one and then disappeared, sounded like an interesting project
10:37:11 <shachaf> ski: ?
10:37:11 <nand`> shachaf: oh, fair enough
10:37:32 <ski> shachaf : whether to tell lambdabot to remember that definition
10:38:13 <Cale> Mertesacker: It's a medical condition. Usually when ordinary people say that word, they mean a gastrointestinal ulcer, which is a break in the intestinal tract or stomach, usually caused by a bacterial infection.
10:38:30 <shachaf> ski: Oh, sure.
10:38:35 <monochrom> "uncurry not" does not type-check. in a total language, a partial language, or a side-effecting language
10:38:57 <Mertesacker> Cale: lol so he perhaps he was stressed?
10:39:04 <Cale> I guess :)
10:39:14 <nand`> Polarina: what do you need Foldable ((,) x) for?
10:39:32 <dimka> win 20
10:39:46 <Polarina> nand`, not that I need it, just found it interesting.
10:40:09 <johnw> wouldn't Foldable let you apply f x to a tuple's right element without having to return a new tuple?
10:40:24 <Cale> Mertesacker: It used to be thought that ulcers were primarily caused by stress.
10:40:26 <nand`> well, there are a lot of potential Foldable instances that are missing, it seems; note that if you want Foldable instances you may be interested in lenses; in particular ‘lens’ which generalizes lenses to, among others, folds
10:40:39 <nand`> which essentially replace Foldable
10:40:40 <johnw> and the lens "folded" :)
10:40:53 <monochrom> @src curry
10:40:53 <lambdabot> curry f x y = f (x, y)
10:41:47 <monochrom> @src uncurry
10:41:48 <lambdabot> uncurry f p = f (fst p) (snd p)
10:42:47 <monochrom> those are also Haskell 2010's reference implementation. so let's calculate. with awareness of bottoms
10:43:47 <monochrom> curry (uncurry f) x = \y -> uncurry f (x, y)
10:44:27 <monochrom> so far no bottom. if we provide one more parameter to attempt extensional equality:
10:44:45 <monochrom> curry (uncurry f) x y = uncurry f (x, y)
10:45:06 <monochrom> = f (fst (x,y)) (snd (x,y))
10:45:32 <monochrom> this introduces no more bottoms than f introduces
10:45:52 <nand`> in a category with exponentiation, (-^X) gives rise to a functor, right?
10:46:27 <Eduard_Munteanu> nand`: yes
10:46:34 <monochrom> or rather, no more bottoms than f x y introduces
10:46:36 <nand`> is there a name for this type of functor?
10:46:43 <nand`> eg. “reader” in Haskell
10:46:50 <armlesshobo> super duper functor
10:47:08 <Eduard_Munteanu> nand`: exponential functor is ok I guess
10:48:43 <copumpkin> nand`: the other way around should give you a functor too
10:48:46 <Luke> ClaudiusMaximus: definitely using the right GHC
10:48:52 <nand`> copumpkin: but a contravariant one?
10:48:56 <copumpkin> ye
10:48:59 <monochrom> I see. I forgot: f x = ⊥, (\y -> f x) ≠ ⊥
10:49:18 <ski> nand` : maybe "partially applied exponential"
10:49:19 <shachaf> monochrom: Yes, that's the purpose of the definition.
10:49:34 <shachaf> monochrom: If f x had side effects, then it would be even more relevant.
10:49:36 <nand`> I guess it wouldn't be a functor if it were fully applied
10:49:51 <ski> a difunctor
10:50:01 <danharaj> shouldn't that just be called an internal hom functor?
10:51:04 <Eduard_Munteanu> Hom(-,-) isn't quite -^-, I think.
10:51:25 <Eduard_Munteanu> ski: I guess bifunctor is more common?
10:51:40 <danharaj> It's not the same thing, ^ is internal.
10:51:57 <ski> (i suppose <http://hackage.haskell.org/packages/archive/compdata/0.5.2/doc/html/Data-Comp-Param-Difunctor.html>)
10:51:58 <Eduard_Munteanu> (though there's di in dinatural)
10:52:50 <monochrom> following the request for curry3, curry4... we also need natural3, natural4 :)
10:52:54 <Eduard_Munteanu> ski: I've seen bimap
10:53:00 <Eduard_Munteanu> @hoogle bimap
10:53:01 <lambdabot> package bimap
10:53:05 <Eduard_Munteanu> Hrm.
10:53:38 <ski>   bimap :: BiFunctor f => (a0 -> a1) -> (b0 -> b1) -> (f a0 b0 -> f a1 b1)
10:53:46 <ski>   dimap :: DiFunctor f => (a1 -> a0) -> (b0 -> b1) -> (f a0 b0 -> f a1 b1)
10:54:02 <Eduard_Munteanu> Oh.
10:54:14 <monochrom> yikes
10:54:31 <ski> monochrom : curried natural transformations ??
10:55:10 <soapyillusions> I modified my app based on your recommendations (thanks Cale , johnw , nand`  and others) but I am left with this error: https://gist.github.com/3853706
10:56:20 <Cale> soapyillusions: aha, the problem is that generate' isn't prepared to handle the possible errors
10:56:28 <monochrom> why is generate' :: ... -> iO ()?
10:56:29 <johnw> Cale saved me the typing
10:56:30 <nand`> line 15 doesn't look right; you want to traverse generate', not fmap it
10:56:41 <ClaudiusMaximus> Luke: maybe https://bugs.launchpad.net/ubuntu/+source/ghc6/+bug/240563 - but i have to cook and eat now..
10:56:47 <nand`> if it's -> IO ()
10:56:59 <Cale> soapyillusions: also, that config/posts/templates are not IO actions anymore, they're results of IO actions
10:57:00 <ClaudiusMaximus> Luke: possibly not, actually, that's old..
10:57:08 <monochrom> then "result" is (), there is no Left or Right
10:57:17 <Luke> ClaudiusMaximus: ok thanks a lot - you have me off to a solid start. I should be able to muscle through it here
10:57:18 <Cale> soapyillusions: If generate' were prepared to deal with all the Either String values, then you could write:
10:57:35 <Cale> generate' <$> readConfig <*> readPosts <*> readTemplates
10:58:08 <nand`> monochrom: I think the intention is to traverse, since readConfig etc. all live in Either String ...
10:58:09 <soapyillusions> ok I thought using the fmap I would be able to make a function which works if all the values are correct if not the fmap would return the first Left err
10:58:16 <nand`> if he traverses, the result would be IO (Either String ())
10:58:20 <nand`> which seems plausible to me
10:58:35 <Cale> soapyillusions: ah, okay, right, so you want to use the Either String monad?
10:58:38 <monochrom> at the end, I think it needs no IO to begin with
10:58:52 <ski> Cale : i think the idea was to not have  generate'  deal with the errors
10:58:53 <soapyillusions> monochrom the generate' function you mean?
10:58:58 <monochrom> yes
10:59:02 <Cale> ski: right
10:59:16 <soapyillusions> monochrom well that function does a little IO of it's own (i.e. write files)
10:59:39 <Cale> soapyillusions: So you want something like...
11:00:12 <Cale> case generate' <$> config <*> posts <*> templates of Left e -> ... ; Right x -> x
11:00:40 <soapyillusions> Cale that's exactly what I want, but the fact that generate' does some IO I can't do that
11:00:44 <monochrom> I think it is better to see generate' in concrete
11:00:47 <Cale> soapyillusions: no, you can
11:01:09 <soapyillusions> ohh ok, and I can add the implementation of generate' if that helps monochrom
11:01:25 <monochrom> I don't trust human type inference
11:01:27 <Cale> soapyillusions: because the scrutinee of that case expression is going to have type Either String (IO ()), right?
11:02:14 <Cale> soapyillusions: So it's either Left s where s is a String, or it's Right x, where x is an IO action (that hasn't been run yet)
11:02:53 <soapyillusions> that's it
11:03:13 <soapyillusions> the correct solution was what you said Cale with case generate' <$> config <*> posts <*> templates of Left e -> ... ; Right x -> x
11:03:48 * ski would want to use a monad transformer
11:04:15 <soapyillusions> ski do you have a link to docs to read up on what a monad transformer is (haven't heard of that yet)
11:05:50 <tac_> soapyillusions: Monad transformers allow you to combine monads into a stack. For example, StateT + Maybe threads a state along, but might also end in failure (Nothing)
11:06:09 <tac_> ^ tl;dr Monad transformers
11:06:15 <tgeeky> Autobots: Left Monadic Action, Assemble!
11:06:50 <ski> @unmtl ErrorT String IO MyResult
11:06:50 <lambdabot> IO (Either String MyResult)
11:07:03 <monochrom> is that some kind of robotic communist manifesto? :)
11:07:29 <Mertesacker> where to ask about fft and applications?
11:08:23 <ski> <http://www.haskell.org/haskellwiki/Monad_Transformers_Explained> and <http://www.haskell.org/haskellwiki/All_About_Monads#Monad_transformers> might help
11:08:55 <soapyillusions> Cale quick question, everything compiles properly now (thanks) but the IO of generate' doesn't run, I think it has to do with the fact that I am ignoring the IO() which is returned: https://gist.github.com/3853706
11:09:07 <soapyillusions> ski thanks!
11:09:09 <mroman> @hoogle (<<=)
11:09:09 <lambdabot> No results found
11:09:20 <mroman> hm.
11:09:25 <mroman> >>= and?
11:09:30 <mroman> =<<?
11:09:31 <ski>   (<<=) :: Comonad w => (w a -> b) -> (w a -> w b)  -- ?
11:09:38 <Cale> soapyillusions: right.
11:09:45 <mroman> @hoogle (=<<)
11:09:46 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
11:09:46 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
11:09:50 <Cale> soapyillusions: If you don't run the action, it won't run :)
11:09:52 <ski> > show =<< [False,True]
11:09:53 <lambdabot>   "FalseTrue"
11:10:04 <soapyillusions> Cale haha I figured, is there a way to catch it and tell it to run?
11:10:24 <monochrom> Right action -> putStrLn "generated!" >> x
11:10:27 <monochrom> or the other order
11:10:29 <Cale> soapyillusions: There is a distinction in Haskell between evaluation (turning expressions into values) and execution (carrying out the effects described by IO actions)
11:10:39 <monochrom> err typo
11:10:40 <Cale> soapyillusions: So you get this IO action in the Right x case
11:10:47 <monochrom> Right action -> action >> putStrLn "generated!"
11:11:00 <soapyillusions> Cale then simply " Right x -> do { _ <- x }"
11:11:04 <Cale> and yes, combine that with the IO action which prints "Generated!"
11:11:15 <Cale> Right x -> x  would work
11:11:15 <ski> soapyillusions : or just `Right act -> act'
11:11:31 <zzing> Good afternoon
11:11:35 <monochrom> if you want to use do-notation: Right action -> do { action; putStrLn "generated!" }
11:11:46 <Cale> do { _ <- x } is syntactically invalid, because the last line of a do-block must be a plain action, and not a <-
11:12:05 <soapyillusions> awesome, it's all working now, thanks a lot for the really amazing help
11:12:09 <Cale> But  do { x } would work, it'd just be silly :)
11:12:19 <Cale> do x; putStrLn "Generated!"
11:12:24 <Cale> would be less silly :)
11:12:36 * ski sometimes writes `foo ... = do return x' (e.g.)
11:12:47 <monochrom> > do True
11:12:49 <lambdabot>   True
11:12:51 <Cale> (i.e. glue the two actions x and putStrLn "Generated!" together)
11:12:52 <monochrom> just to tease you
11:12:57 <mroman> > do Nothing
11:12:58 <lambdabot>   Nothing
11:13:15 <soapyillusions> Cale haha thanks that's what I did
11:14:05 <ski> @type ShowQ.done
11:14:07 <lambdabot> String -> Int -> [[String]] -> IO String
11:14:19 <mroman> Isn't therey some try monad?
11:14:29 <mroman> which takes a list of function
11:14:32 <Cale> soapyillusions: That's actually how you ought to think about do-expressions, by the way -- they're a way to glue a bunch of actions (in some monad) together
11:14:38 <mroman> and tries them in order until one succeeds
11:14:44 <mroman> maybe I could even use arrows for that?
11:14:56 <ski> mroman : maybe you want `mplus' or `msum' ?
11:15:06 <mroman> @hoogle mplus
11:15:07 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
11:15:26 <ski> > Nothing `mplus` Nothing `mplus` Just "fail !" `mplus` Nothing
11:15:28 <soapyillusions> Cale and all the actions are wrapped into a monad which can be executed later?
11:15:28 <lambdabot>   Just "fail !"
11:15:29 <Cale> mroman: or possibly you want some appropriate monoid on the results of the functions?
11:15:55 <tgeeky> does anyone know if there is already a library to source csv-style data from Google Docs?
11:16:02 <monochrom> I am not convinced that "function" really means function. the whole question needs a lot of concretization
11:16:21 <Cale> soapyillusions: The monad is a type-level thing -- IO and Maybe and Either String are monads, but getLine and Just x and Left e aren't.
11:16:49 <Cale> soapyillusions: But yes, the actions are joined together into a single action which can be executed later.
11:17:04 <ski> > msum [Nothing,Nothing,Just "fail !",Nothing,Just "success !"]
11:17:05 <lambdabot>   Just "fail !"
11:17:18 <soapyillusions> Cale thanks a lot, these explications really help
11:17:21 <ski> mroman : perhaps you can be more concrete ?
11:19:19 <mroman> MonadPlus sounds ok.
11:19:29 <mroman> And is Monoidic :)
11:19:58 <mroman> ski: For parsing stuff
11:20:07 <mroman> In times I don't like to use parsec :)
11:20:15 <mroman> and just to gain new insights.
11:20:31 <mroman> Actually every Haskellthing I do is just to gain new insights.
11:20:48 <zzing> Cale, would you happen to have time to go over that parser combinator thing we talked about last night?
11:21:00 <Cale> zzing: Sure, in a few minutes
11:21:29 <mroman> So guard uses MonadPlus behind the scenes.
11:21:30 <mroman> Neat.
11:21:49 <ski> nicer would be if it used `MonadZero'
11:22:13 <kmbt> Does anyone know if there is an easy way to convert Text to Maybe Int without first converting it to ByteString? I've tried to look it up on Hoogle but with no success.
11:22:14 <zzing> Cale, awesome. I am just getting myself some wonderful food. I will be along shortly too.
11:22:55 <mroman> MonadZero just contains mzero
11:23:04 * hackagebot heist 0.8.2 - An (x)html templating system  http://hackage.haskell.org/package/heist-0.8.2 (DougBeardsley)
11:23:09 <ski> @type mzero
11:23:10 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
11:23:25 <mroman> well
11:23:30 <mroman> it's a reform proposal
11:23:39 <rwbarton> kmbt: well you could convert it to String first instead, that seems more sensible but also probably not quite what you are looking for
11:23:44 <mroman> The idea is to split MonadPlus to MonadZero m => MonadPlus m
11:24:05 <ski> yes
11:24:06 <jfischoff> has anyone used the histogram-fill package? I would love to see a simple example.
11:25:12 <kmbt> rwbarton: That might work for me
11:25:49 <kmbt> rwbarton: thanks :)
11:35:33 <mcstar> hai
11:35:37 <mcstar> i have a grave problem
11:35:57 <mroman> Don't dig too deep.
11:36:03 <mcstar> wait
11:36:07 <mcstar> i think i know whats the problm
11:36:16 <mroman> The tombstone is missing?
11:37:39 <zzing> mroman, and the body is missing
11:37:41 <mcstar> ok, now i did something, and i need help
11:37:53 <mcstar> thing is, i use 'type' to type alias something
11:38:00 <mcstar> and i want to add it to Show
11:38:18 <mcstar> i didnt use type sigs at all, and thats why it didnt work before
11:38:20 <mcstar> my bad
11:38:29 <mcstar> but now it complains about overlapping instances
11:38:34 <statusfailed> Is there a tutorial anywhere on using Yesod/Snap/Somethingelse just to make a REST API? I don't really want any HTML templating or anything else
11:38:34 <mcstar> which is understandable
11:38:45 <statusfailed> and i'm rubbish at picking libraries
11:38:50 <mcstar> since my type is just a Data.Map.Map that i want to display in a custom way
11:39:24 <nurpax> statusfailed: re REST and Snap - I've seen some on github - and have done some of my own (which unfortunately haven't been released publicly)
11:39:30 <mcstar> is there some easy workaround, or should i just use data?
11:39:33 <zzing> statusfailed, I was doing something with yesod to make a javascript accessible api
11:40:17 <statusfailed> nurpax, zzing: Know of any pros/cons to picking one over the other?
11:40:27 <zzing> statusfailed, I might also suggest you check out #happs and see if stepcut or something like that is there. mightybyte in #snapframework or Michael Snoyman on google groups (look for the yesod).
11:40:49 <zzing> statusfailed, snap suffers from a documentation problem. Yesod has a book, and Happstack has an equally long tutorial.
11:40:59 <zzing> Although snap is rather nice from a design point of view
11:41:18 <statusfailed> I always felt snaplets were a bit too big to fit together well to be honest
11:41:20 <zzing> I rather like some aspects of the Persistent that yesod tends to use
11:41:28 <statusfailed> but I didn't use it
11:41:28 <statusfailed> uch
11:42:24 <nurpax> statusfailed: I've only worked with snap - been quite happy with it.  there are a few resources: http://stackoverflow.com/questions/10803171/how-to-use-haskell-snap-with-backbone-js, https://github.com/raimohanska/snap-mongo-rest.  I also like to think my example project for snap + auth (logins) + sqlite is pretty easy to get started: https://github.com/nurpax/snaplet-sqlite-simple/tree/master/example
11:43:05 <statusfailed> nurpax: oh, nice, I will have a read
11:43:06 <statusfailed> cheers!
11:43:46 <nurpax> statusfailed: it's easy to extend my example project for REST.  I have a private project that extends the example project with a REST interface + templating in javascript
11:44:12 <zzing> Make sure if you use sqlite that you don't assume anything if you go live with it - I would look at postgres for that.
11:44:57 <statusfailed> I'm actually not using any persistence at the mo
11:45:11 <nurpax> zzing: sure, there's a snaplet for postgres too here https://github.com/mightybyte/snaplet-postgresql-simple - that's almost 100% the same as the sqlite version
11:45:23 <Cale> zzing: Okay, so come to #haskell-overflow (and anyone else who is interested in watching this) and I'll go over the implementation of a very simple monadic parsing library.
11:46:12 <twmb> I have a question:  if :: is read as "has type of", does that mean in something like "(*) :: (Num a) => a -> a -> a  ", that the * has type of Num a?  - I read it as "a has type of Num", actually, I don't fully know how to read it
11:47:00 <johnw> (*) has type a -> a -> a
11:47:05 <johnw> where a must be an instance of type class Num
11:47:08 <statusfailed> twmb: the bit before => is a predicate, so it's saying "the a must be a Num"
11:47:18 <rwbarton> everything after :: there is the type
11:47:27 <tac_> twmb: read it as "For any type a, if there is an instance of Num a, then (*) has the type a -> a -> a"
11:47:42 <tac_> There is an instance, Num Int, for example
11:48:02 <twmb> I like asking questions here because I get 5 different perspectives of thinking about it
11:48:05 <tac_> So you can specialize the type as Num Int => Int -> Int -> Int, or just Int -> Int -> Int
11:48:22 <twmb> does it matter in which order it comes in? At the bottom of "Types and Typeclasses" in LYAH, the guy wrote a function like "(Num b) => length :: [a] -> b"
11:48:31 <statusfailed> haha, I was gonna say- new record for number of responses in a given time? :D
11:48:32 <twmb> but I haven't had the chance to test that
11:48:47 <tac_> twmb: I always think of type classes as implicit parameters
11:48:52 <statusfailed> twmb: the order of what? the predicates?
11:48:57 <twmb> yes
11:49:00 <statusfailed> nope
11:49:06 <statusfailed> I think!?
11:49:09 <tac_> Num a => a means  "Pass evidence that type a is a numeric type, then the result has type a"
11:49:19 <twmb> so anything to the left of EITHER :: or => is just defining types/function names?
11:49:33 <tac_> :: means "has type"
11:49:54 <tac_> => is "supposing that foo has the type class bar"
11:50:24 <ski> twmb : `Num b => length :: [a] -> b' is informal notation ("for every type `a' and `b', such that `b' is in class `Num', `length' is a function taking an argument of type `[a]' and returning a result of type `b'")
11:50:46 <ski> twmb : actual notation is `length :: Num b => [a] -> b'
11:51:19 <tac_> I've never even seen "Num b => length :: [a] -> b" before...
11:51:35 <ski> tac_ : it's not actual Haskell notation
11:51:35 <twmb> tac_: bottom of http://learnyouahaskell.com/types-and-typeclasses
11:52:08 <ski> twmb : to the left of `::' is the thing which is being claimed to have the type, which is the thing to the right of `::'
11:52:08 <tac_> ski: I know. But I've never even seen it used casually.
11:52:12 <tac_> weird.
11:52:15 <twmb> so if we want to specify more than one type definition, we put it in ( )?
11:52:15 <rwbarton> you should just pretend that says "length :: Num b => [a] -> b
11:52:16 <rwbarton> "
11:52:16 <ski> the thing to the left is usually just a single name, yes
11:52:28 <tac_> I'd go as far to say it's a typo in LYAH :/
11:52:39 <ski> twmb : i've sometimes used `forall a. length :: [a] -> Int' in here, when explaining
11:53:00 <twmb> k
11:53:03 <twmb> thanks for the help
11:53:05 <johnw> also a typo :)
11:53:07 <twmb> I'll probably be back later
11:53:10 <twmb> gotta go to class now
11:53:14 <ski> tac_ : er, that was meant for you, actually
11:53:19 <johnw> go to type class instead
11:53:20 <Springwight> So it too me a while to really, really, get it, but I understood that laziness is basically cheating.
11:53:29 <johnw> how is it cheating?
11:53:39 <Springwight> You're saying "Oh this data structure, it can't ever be changed, nope sirry" and changes occur all the time
11:53:43 <Springwight> *Sirree
11:53:56 <Springwight> But it's like, behind the scenes, and there are special effects
11:53:58 <tac_> ski: I have a pretty good handle on how type classes work ;)
11:54:00 <johnw> um, how are you changing data structures in Haskell?
11:54:05 <tac_> (except for the weird uses)
11:54:19 <Springwight> I mean, laziness involves memoization. That's a mutation.
11:54:22 <mroman> Springwight: I can't follow you.
11:54:32 <johnw> huh?
11:54:33 <ski> it's cheating and changing in the same sense as going from `(3 * 4) ^ 2' to `12 ^ 2' in math is cheating and changing
11:54:36 <nicoo> Springwight: Nope
11:54:38 <mroman> Are you referring to the way laziness is implemented?
11:54:49 <nicoo> Laziness and memoization are two different beasts
11:55:07 <Springwight> Okay, that's a good point.
11:55:07 <tac_> Springwight: the effect of memoization is not observable within the language.
11:55:51 <ski> (really, `3 * 4' *is* the same integer as `12')
11:55:58 <Springwight> I mean, laziness with memoization. I'm not saying it's bad, don't use it. I'm saying the trick is using it is basically a highly controlled use of mutation.
11:55:58 <nicoo> Springwight: If the term (f x y) is built twice, and the result used, it *will* be evaluated twice
11:56:08 <nicoo> It isn't memoization
11:56:17 <rwbarton> it is "memoization" for a single value
11:56:18 <dustingetz> sin(pi) is always 0, you don't have to calculate the expanded infinite series every time you want to know sin(pi)
11:56:21 <dustingetz> that's memoization
11:56:35 <hpaste> Bluelz pasted “string parse” at http://hpaste.org/75985
11:56:50 <rwbarton> if I write let z = f x y in {- ... use z twice ... -} then z = f x y will not be evaluated twice
11:57:14 <nicoo> rwbarton: Yes, but it isn't the same as constructing f x y twice
11:57:29 <nicoo> (if the compiler cannot optimize it away)
11:57:36 <rwbarton> I think you just have a very narrow definition of memoization
11:58:43 <rwbarton> z is an expression that gets evaluated the first time it is used and returned immediately when it is used subsequently, that is the pattern of memoization
11:58:46 <nicoo> rwbarton: Well, IMHO, memoization is the « caching » of the result associated to some input
11:58:54 <rwbarton> right, here there is a result but no input
11:58:54 <nicoo> Euh, nope
11:58:58 <rwbarton> and it is cached
11:59:16 <Bluelz> Hi guys, im working on a problem here where I am trying to parse what seems to be a postfix notation mathematical explression. However, my logic is flawed. Would anyone mind giving me some pointers as to how to "repair"? My code can be found here: http://hpaste.org/75985 and the issue is primarly in the function createTree, I understand why It doesnt work, but I cant come up with a way to get it it work :S It works on "+ 5 5", however a more inter
11:59:17 <Bluelz> esting "+ * 5 5 - + 2 1" fails
11:59:19 <rwbarton> like in memoization, it is also not computed up front
11:59:27 <rwbarton> only when it is needed for the first time
11:59:46 * nicoo doesn't have the energy required to battle windmills
12:00:04 <mroman> + *  5 5 is postfix?
12:00:09 <Springwight> Sorry. :( This is from the perspective of someone who's done imperative and switched to functional. From how I see it, (some types of) memoization are controlled uses of mutation that occur somewhere you can't see. So I made the jocular observation that it's kind of cheating.
12:00:25 <nand`> I just caught the tail end but what rwbarton is saying is basically correct
12:01:01 <mroman> Springwight: Then Haskell having I/O is the biggest sceam in the history of information technology? ;)
12:01:02 <rwbarton> if you imagine memoizing a function with 0 arguments, that is basically lazy evaluation
12:01:12 <Bluelz> @mroman prefix* !:D
12:01:12 <lambdabot> Unknown command, try @list
12:01:22 <Springwight> :P
12:01:25 <mroman> hm
12:01:26 <nand`> Springwight: technically, there's nothing forcing the compiler to memoize - it's simply an implementation strategy, the “updating” of values isn't in the specification afaik
12:01:27 <mroman> *scheme actually
12:02:16 <johnw> yeah, and when the code executes and CPU registers get updated, that's mutation too
12:02:21 <Springwight> Yeah, but it can lower the complexity class in otherwise purely functional algorithms. So it's a powerful strategy.
12:02:33 <nand`> lazy values :: a could be seen as memoized functions () -> a
12:02:56 <rwbarton> the garbage collector needs to mutate memory as well
12:03:16 <rwbarton> or you could not write many programs that run in constant space
12:03:42 <dustingetz> memory is an implementation detail
12:03:43 <Bluelz> Mroman Everything in that code apperas to work, apart from the createTree function, and I realize that is because im calling a recursive function twice with pretty much identical input :|
12:03:46 <dustingetz> pure functional code is math
12:03:49 <dustingetz> math has no memory
12:03:51 <dustingetz> math has no gc
12:03:55 <rwbarton> Springwight: so yes, what you are saying is correct but the way you said initially was very confusing :)
12:03:55 <nand`> the implementation strategy GHC uses to compile Haskell programs to x86 makes heavy use of mutation
12:04:21 <rwbarton> lazy evaluation is also an implementation detail
12:04:28 <nand`> math needs a garbage collector :)
12:04:38 <johnw> rwbarton: true, there are strict Haskell variants
12:05:26 <dustingetz> hand`: please explain
12:05:30 <dustingetz> nand`
12:05:42 <shachaf> johnw: That's not Haskell, though.
12:05:51 <shachaf> johnw: You could implement Haskell without laziness if you wanted to.
12:05:52 <johnw> I do believe I said Haskell variant...
12:06:01 <johnw> oh really?
12:06:04 <nand`> dustingetz: to collect all of the boring or erroneous work
12:06:09 <shachaf> johnw: Right, but that's not "an implementation detail", it's a different language. :-)
12:06:14 <rwbarton> sure, you can just not memoize :)
12:06:32 <luite> nand`: actually there is relatively little mutation, most heap objects are never updated, thunks only once
12:06:34 <nand`> changing strictness changes semantics because programs may diverge or error
12:06:38 <Springwight> rwbarton, yes, I'm sorry. I guess I should have realized that it wasn't a common way of phrasing things and that it would stir things up.
12:07:03 <dustingetz> lambda calculus needs no gc when we evaluate it with pencil and paper
12:07:04 <nand`> luite: I was thinking of the registers
12:07:13 <dustingetz> lambda calculus needs gc when we evaluate it on a register machine
12:09:53 <amiller> is it possible to use an IOref or something to create a top level state
12:09:57 <amiller> i'm not sure how to explain this
12:10:01 <tac_> nand`: since paper is so cheap compared to memory, most mathematicians just leaves garbage lying around in old notebooks
12:10:14 <maukd> needs unsafePerformIO + NOINLINE
12:10:21 <hpaste> ski annotated “string parse” with “blah” at http://hpaste.org/75985#a75986
12:10:27 <amiller> i have a simple routine
12:10:28 <amiller> double :: State Int ()
12:10:28 <amiller> double = get >>= put . (* 2)
12:10:29 <ski> Bluelz ^
12:10:50 <amiller> and i know how to use it with runState double 2 for example (it returns ((),4))
12:10:50 <maukd> modify (* 2)
12:11:24 <amiller> but what i want is to call double from the repl
12:11:41 <maukd> @unmtl State Int ()
12:11:41 <lambdabot> Int -> ((), Int)
12:11:46 <Bluelz> Ski; Woaw, you simplified a ton of that.. I'll have to have a closer look to identify what has happened
12:12:35 <amiller> maukd, i don't follow
12:13:01 <maukd> amiller: where?
12:14:10 <ski> amiller : it's the same in the interactor : `runState double 2'
12:14:32 <ski> Bluelz : note that i didn't actually fix any problem in the code, i just simplified it a bit
12:16:02 <Bluelz> Yea i noticed the addition of guards and such, + a ton of shorter lines. Im still pretty fresh to the syntax and quirks of haskell, so getting to know these shortcuts helps :=)
12:17:05 <amiller> ski, what i want to do is call double multiple times interactively
12:17:07 <ski> Bluelz : i think in `createTree' you want to get the *rest* of the input after the first recursive call, so you can continue by feeding that into the second recursive call
12:17:36 <amiller> i can call runState interactively, but that just runs a single instruction (or a batch of instructions)
12:17:37 <ski> amiller : `runState (do double; double) 2' ?
12:18:25 <Bluelz> Thanks for the tips, ski++
12:18:29 <ski> amiller : the interactor either just evaluates an expression (your case), or (evaluates and) executes an `IO'-action
12:18:50 <ski> amiller : there is no connection between your `Int' state in `State Int Blah' and the interactor
12:19:22 <rwbarton> you could rig up some way to do it with an IORef in the interpreter
12:19:42 <byorgey> ugh
12:20:06 <ski> Bluelz : also, you probably want to avoid using tabs in Haskell source (you can get hard-to-find errors due to layout being wrong)
12:20:45 <ski> perhaps one could register a way to run other monads as well ..
12:20:51 <Bluelz> So you only use whitespaces, no \t ?
12:21:07 <amiller> rwbarton, could you elaborate a bit, that sounds like what i want to do (i wish i had a better way to phrase it though!)
12:21:09 <ski> i've set my $EDITOR to expand tabs to spaces, in Haskell source
12:21:13 <maukd> "whitespace" is a set of characters that includes ' ', '\t', '\r', and '\n'
12:21:22 <rwbarton> well
12:21:41 <Bluelz> *by witespace i ment single space :)
12:21:47 <ski> > filter isSpace ['\NUL' ..]
12:21:48 <lambdabot>   "\t\n\v\f\r \160\5760\6158\8192\8193\8194\8195\8196\8197\8198\8199\8200\820...
12:21:51 <rwbarton> @hoogle atomicModifyIORef
12:21:51 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
12:21:56 <rwbarton> @hoogle runState
12:21:56 <lambdabot> Control.Monad.Trans.State.Lazy runState :: State s a -> s -> (a, s)
12:21:56 <lambdabot> Control.Monad.Trans.State.Strict runState :: State s a -> s -> (a, s)
12:21:57 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
12:22:06 <rwbarton> typical
12:22:13 <byorgey> amiller: what rwbarton is proposing is a hack, and would require completely rewriting your program anyway.
12:22:33 <byorgey> amiller: I understand what you are asking for, but it is not possible.
12:22:48 <amiller> oh no
12:22:53 <rwbarton> runStateOn ref st = atomicModifyIORef $ \s -> let (s', x) = runState st s in (x, s')
12:23:10 <rwbarton> then do myRef <- newIORef 0 {- or whatever initial state you like -}
12:23:19 <byorgey> heh, well, maybe it's not too bad after all =)
12:23:26 <rwbarton> this is all in ghci
12:23:35 <rwbarton> then you can runStateOn myRef double however many times you like
12:24:06 <ski> @type let runStateOn ref st = Data.IORef.atomicModifyIORef ref $ \s -> let (s', x) = runState st s in (x, s') in runStateOn
12:24:07 <lambdabot> forall a b. GHC.IORef.IORef a -> State a b -> IO b
12:25:56 <rwbarton> and you can read/write the state with readIORef/writeIORef
12:27:19 <amiller> rwbarton, fantastic, that _is_ exactly what i wanted!
12:31:10 <gabor> :src any
12:31:18 <amiller> what do i call this, rwbarton? i don't find anything searching for runStateOn, nor have i found anything similar using ioref and runstate, etc.
12:31:43 <ski> @src any
12:31:43 <lambdabot> any p =  or . map p
12:31:59 <amiller> it seems like it would work just as well with mvar or ST, also i wonder if it's applicable to other monad types
12:32:03 <ski> amiller : rwbarton just invented it, calling it `runStateOn'
12:32:30 <ski> (though i'm sure people have made similar things before ..)
12:33:50 <tac_> @type runState
12:33:51 <lambdabot> forall s a. State s a -> s -> (a, s)
12:34:19 <tac_> @type evalState, evecState
12:34:20 <lambdabot> parse error on input `,'
12:34:25 <tac_> @type (evalState, evecState)
12:34:26 <lambdabot> Not in scope: `evecState'
12:34:31 <tac_> doops
12:34:32 <amiller> execState?
12:34:38 <tac_> @type (evalState, execState)
12:34:40 <lambdabot> forall s a s1 a1. (State s a -> s -> a, State s1 a1 -> s1 -> s1)
12:35:15 <ski> @type evalCont
12:35:16 <lambdabot> forall o. Cont o o -> o
12:35:48 <ski> @type evalState &&& execState
12:35:49 <lambdabot> forall s a. State s a -> (s -> a, s -> s)
12:36:19 <shachaf> ski: evalCont?!
12:36:24 <ski> why not ?
12:36:26 <shachaf> Where does that come from?
12:36:34 <tac_> @type runCont
12:36:36 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
12:36:39 <ski> i just defined it
12:36:41 <shachaf> Oh.
12:36:44 <tac_> $type flip runCont id
12:36:49 <ski> @type evalContT
12:36:50 <tac_> @type flip runCont id
12:36:50 <lambdabot> forall o (m :: * -> *). (Monad m) => ContT o m o -> m o
12:36:51 <lambdabot> forall a. Cont a a -> a
12:36:53 <shachaf> I guess I'll keep (`runCont`id)ing.
12:39:34 <Soft> This is really elementary but why can't I write something like fmap (+1) (Right 41)
12:39:52 <rwbarton> > fmap (+1) (Right 41)
12:39:53 <lambdabot>   Right 42
12:40:02 <rwbarton> I don't know, why can't you?
12:40:09 <Soft> oh
12:40:09 <tac_> > fmap (+1) (Left 0)
12:40:10 <lambdabot>   Left 0
12:40:12 <Soft> weird
12:40:28 <Soft> ghci gives me No instance for (Functor (Either a0))
12:40:33 <rwbarton> aha
12:40:43 <rwbarton> you need to import... something that probably depends on your version of ghc
12:40:43 <maukd> missing import
12:41:00 <Soft> oh
12:41:11 <maukd> Data.Either?
12:41:26 <rwbarton> the ever popular Control.Monad.Instances worked for me
12:41:31 <monochrom> try importing everything in sight. then use ghci :info Either to find out which module gives the instance
12:41:46 <Soft> I just somehow assumed that instance was imported because Right and Left are
12:42:20 <rwbarton> doesn't have to be. instances can be declared separately from the type (and often are)
12:43:00 <rwbarton> hmm
12:43:09 <rwbarton> Haskell 98 says ... oh that's Maybe not Either
12:43:18 <monochrom> not in Haskell 98
12:46:46 <amiller> lol i did forever $ do runStateOn myRef double
12:46:52 <amiller> now i have 450 megabytes of an integer in memory
12:47:04 <amiller> that is exactly the foot-shooting power i wanted today :p
12:47:14 <merijn> Soft: Prelude imports and reexports a lot of datatypes, but not always all instances that'd you'd want :p
12:47:15 <nand`> mm_freak: is there a publicly available VCS repository for netwire?
12:47:33 <merijn> nand`: There's a darcs repo, somewhere I forgot
12:49:26 <ozgura> amiller: what is this runStateOn?
12:49:41 <ion> > let p=do{(x:xs)<-get;put xs;Node x<$>if all isDigit x then pure[]else replicateM 2p}in(drawTree.evalState p.words)"+ * 5 5 - + 2 1 42"
12:49:43 <lambdabot>   "+\n|\n+- *\n|  |\n|  +- 5\n|  |\n|  `- 5\n|\n`- -\n   |\n   +- +\n   |  |\...
12:49:54 <amiller> @type let runStateOn ref st = Data.IORef.atomicModifyIORef ref $ \s -> let (s', x) = runState st s in (x, s') in runStateOn
12:49:55 <lambdabot> forall a b. GHC.IORef.IORef a -> State a b -> IO b
12:50:11 <amiller> ozgura, ^^ rwbarton made it and ski clarified it and i'm trying to play with it
12:50:39 <merijn> nand`: My local clone says: http://darcs.ertes.de/netwire
12:50:52 <ClaudiusMaximus> probably needs more runStateOn' with added strictness
12:50:53 <nand`> with the change to TypeOperator in 7.6.1, is the only way to make something a variable now giving it an alphanumeric name?
12:51:16 <nand`> merijn: thanks
12:52:38 <nand`> oh nice; netwire 4.0 from that repository builds out of the box in 7.6.1 cc mm_freak
12:52:50 * nand` makes a package for it
12:52:52 <ozgura> amiller: thanks. doesn't look terribly useful to me :)
12:53:02 <merijn> nand`: It also works out of the box on 7.4 for me
12:55:04 <amiller> ozgura, it's useful because i can use ghci to simulate an interpreter without having to write one
12:55:51 <sleepster> I am new to haskell, can someone suggest an intermediate level project I can work on so that I can become a better haskell programmer? I come from a strong C++/Java background so when I learned those languages, I just implemented an IRC client, games, emulators, etc.  Can the same be done with haskell?
12:55:55 <ozgura> an interpreter for what?
12:56:21 <nand`> sure, but I wouldn't necessarily start right away with an IRC client, games, emulators, etc.
12:56:30 <nand`> but those are all reasonably doable
12:57:05 <sleepster> nand`: hmm. so what are some generally good projects to start with?  Maybe just solve some programming problems?
12:57:13 <merijn> sleepster: An IRC clients seems very easy, IRC server too. games/emulators I'd say depends on how complex you want to make them
12:57:35 <merijn> sleepster: Developing functional games can be tricky (at least as far as I've attempted :p)
12:57:57 <merijn> sleepster: There's 99 Haskell problems, but those are very basic, not "real" programming projects
12:58:12 <sleepster> that's a good start I think :)
12:58:14 <nand`> I don't know what concrete, good projects could look like; but I would go for something that's more at home to pure functional programming
12:58:16 <sleepster> I'll google that
12:58:32 <nand`> functional game development is very interesting
12:58:35 <nand`> FRP is a common approach
12:58:37 <merijn> sleepster: For people with experience in other languages I think anything network server/concurrent would be a good start, because Haskell is just very nice for those
12:58:45 <nand`> another is one like gloss takes
12:58:47 <sleepster> is haskell a general purpose language? or does it fall in the realm of DSL?
12:58:51 <merijn> nand`: I know, I finally started seriously reading up on AFRP and netwire
12:58:56 <nand`> it's a very general purpose language
12:58:57 <ion> > let p=do{(x:xs)<-get;put xs;Node x<$>if all isDigit x then pure[] else replicateM 2p};r(Node x[])=[x];r(Node x ys)=["(",x]++(r=<<ys)++[")"]in(unwords.r.evalState p.words)"+ * 5 5 - + 2 1 42"
12:58:58 <merijn> sleepster: Definitely general purpose :)
12:58:59 <lambdabot>   "( + ( * 5 5 ) ( - ( + 2 1 ) 42 ) )"
12:59:25 <amiller> sleepster, it is so general purpose that it will require you to broaden your understanding of the word 'general'
12:59:30 <sleepster> hah
12:59:49 <nand`> you can write, and generally everything has been written, from operating systems to games to compilers to embedded scripts to algorithms processing lots of data
12:59:56 <sleepster> I'd like to expand my understanding of programming in general.. so I am hoping FP can help with that
13:00:12 <amiller> ozgura, (i'm probably mincing this) but it's an interpreter for a language of simple stateful operations
13:00:12 <sleepster> c++ and java has kind of narrowed my understanding
13:00:14 <merijn> sleepster: The main reason I recommend network/concurrent style programs is that most (all?) programmers know how that stuff can be painful, whereas haskell makes the experience rather pleasant, with things like STM and lightweight threads :)
13:00:35 <nand`> Haskell lives in a fairly abstract computation model; so you can implement it in a large variety of environments
13:00:45 <amiller> i'm writing the operations using a state monad which is simplest, but then when i want to interact with it i just want to abuse an ioref
13:00:52 <nand`> be it a hardware based functional graph reducer or an x86 processor or even JavaScript
13:01:10 <merijn> ghcjs looks very promising :)
13:01:22 <merijn> Can't wait until I can write my front-end code in haskell :p
13:01:34 <ozgura> amiller: oh well, I see what you mean. I'll just buy that argument and stop :)
13:01:56 <amiller> ozgura, :]
13:02:27 <nand`> I've always been interested in using something like netwire for network programming one of these days
13:02:34 <nand`> but I've never known where to start, or how to approach problems
13:02:45 <merijn> nand`: Do you know ZeroMQ?
13:02:53 <nand`> merijn: from reading through its docs, yeah
13:03:24 <merijn> nand`: Good, I feel all my work writing socket code has been wasted time >.>
13:03:55 <nand`> I took a brief glance at the haskell ZeroMQ bindings also
13:04:05 <nand`> but I don't remember what my impressions were
13:04:43 <merijn> nand`: I've started working with them, they're ok. Two functions are missing and it needs a nice monad transformer interface (something reader based), but I'll probably implement those as I need them :p
13:04:48 <nand`> but Haskell can probably do better by working on a pure-Haskell implementation of the ZeroMQ protocols rather than a ‘simple’ binding
13:05:50 <merijn> Why?
13:06:33 <merijn> The bindings already block using the GHC runtime, they don't allow blocking on multiple sockets (yet), but after looking at the code that'd be trivial to add
13:06:53 <nand`> well, I always get the impression that bindings to existing libraries end you up with code that feels very imperative or sequential; rather than the declarative, static style I enjoy using most
13:07:14 <nand`> of course a reasonably high level layer on top of the existing bindings could provide that
13:07:40 <nand`> (I'm going to sleep now)
13:08:21 <merijn> nand`: I though the bindings looked fairly sensible
13:10:57 <merijn> Is there a way to search hackage for libraries depending on a certain package
13:14:57 <sm> sleepster: often the best thing to work on is something you'll enjoy using yourself
13:16:34 <sm> merijn: http://packdeps.haskellers.com/
13:17:14 <mcstar> so, is there a way to resolve overlapping instances?
13:17:53 <ion> > let p=do{(x:xs)<-get;put xs;Node x<$>if all isDigit x then pure[]else replicateM 2p};r(Node x[])=x;r(Node x ys)="("++x++((' ':).r=<<ys)++")"in(r.evalState p.words)"+ * 5 5 - + 2 1 42"
13:17:55 <lambdabot>   "(+ (* 5 5) (- (+ 2 1) 42))"
13:19:24 <Bluelz> wow, ion
13:19:45 <ion> bluelz: That’s just some stupid golfing, not a serious suggestion to you.
13:20:34 <Bluelz> Il have a look at it. All code is interesting at this point, im looking to learn haskell
13:21:17 <merijn> sm: That just lists the dependencies of a given package, right? Not "packages depending on X"
13:21:32 <sm> oh, perhaps so
13:21:58 <rwbarton> it has both
13:22:17 <rwbarton> http://packdeps.haskellers.com/reverse
13:23:18 <sleepster> thanks sm.. yeah I agree.. definitely makes the project much easier
13:23:30 <hiptobecubic> :t Node
13:23:31 <lambdabot> forall a. a -> Forest a -> Tree a
13:23:41 <Bluelz> ion/ski: I  have a pretty good idea of how my implementation should work, but im trying to figure out a smart way of dropping off elements from the list as they are "visited" in the parsing. In Java I'd just have the string im parsing sit on the outside of the recursive method, simplifying the fact that I have multiple recursioin inside my function, but I'm not quite sure how to pull that off here :)
13:24:08 <sm> sleepster: also do you want to work on something with a community, or your own thing
13:24:09 <merijn> sm, rwbarton: Thanks, but apparently not what I needed. I was just looking for a way to find packages using Netwire so I could use them as example code :)
13:24:23 <sleepster> sm: probably my own idea at first
13:24:43 <rwbarton> merijn: well, apparently there is just one
13:25:11 <merijn> Yeah, which is not really suitable as example from what I can tell, unfortunately
13:25:20 <hiptobecubic> ion, would you explain your snippet there? Particularly the pure[]else replicateM 2p}
13:26:17 <rwbarton> I got google to cough up https://github.com/navaati/gloss-netwire
13:26:37 <ion> replicateM 2 p = do a <- p; b <- p; return [a,b]
13:27:22 <ion> If “x” doesn’t consist of digits only, it will run “p” twice and the resulting list will end up as the node’s children. If it’s a digit, the list of children will be [].
13:27:22 <hiptobecubic> :r replicateM
13:27:24 <rwbarton> via search for filetype:cabal netwire
13:27:29 <hiptobecubic> :t replicateM
13:27:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
13:29:19 <hiptobecubic> ion, What is the purpose of using Node there? I saw it was for building trees from the type...
13:29:29 <hiptobecubic> and i can see that the result is a tree
13:29:43 <hiptobecubic> but i don't see the tree being built
13:29:46 <hiptobecubic> :t Node
13:29:47 <lambdabot> forall a. a -> Forest a -> Tree a
13:29:52 <hiptobecubic> :info Forest
13:29:58 <hiptobecubic> :i Forest
13:30:03 <hiptobecubic> @info Forest
13:30:03 <lambdabot> Forest
13:30:06 <hiptobecubic> damnit :D
13:30:18 <hiptobecubic> what module is that in?
13:30:21 <ion> hiptobecubic: (evalState p . words) "+ * 5 6 42" = Node + [Node "*" [Node "5" [], Node 6 []], Node "42" []]
13:30:23 <ion> Data.Tree
13:30:43 <hiptobecubic> Ah so it's an n-ary tree
13:30:43 <yawnt> hellow
13:30:52 <yawnt> is there a fairly working haskell vm except halvm?
13:30:52 <bgamari> Will the RTS kill any threads still running after main completes?
13:30:52 <hiptobecubic> with a list of branches
13:30:54 <yawnt> maybe parrot?
13:31:12 <ion> It’s not the right data type for this syntax tree, but it was convenient for the golfing.
13:31:31 <hiptobecubic> this tree should ideally just be binary no?
13:31:59 <hiptobecubic> aha... forest is just list of tree
13:32:56 <ion> Something like this would be a much better representation. data FooTree = Number Integer | BinOp Op FooTree FooTree
13:33:21 <hiptobecubic> yeah
13:33:23 <ion> data Op = Add | Sub | Mul | Div
13:33:40 <hiptobecubic> but now you're lexing
13:34:20 <hiptobecubic> your golf will take any non int as a binop
13:35:32 <ion> Ok, no lexing. :-P data FooTree = Leaf String | Bin String FooTree FooTree
13:35:41 <applicative> rwbarton, I see you solved this difficulty about (MonadTrans f, MonadTrans g) => MonadTrans (Compose f g)
13:35:59 <ion> data FooTree a = Leaf a | Bin (FooTree a) (FooTree a) a deriving (Functor)
13:36:35 <merijn> bgamari: Yes, unfortunately :p
13:36:41 <hiptobecubic> ion, but your nodes are now ints?
13:36:53 <bgamari> merijn, Ahh, that explains it. Thanks!
13:36:55 <ion> hiptobecubic: Not if a ~ String
13:37:04 <merijn> bgamari: My usual approach is to have an MVar and have main block on it until the last thread completes
13:37:07 <hiptobecubic> ion, ah ok
13:37:07 <ion> Leaf "foo" :: FooTree String
13:37:14 <hiptobecubic> yeah
13:37:48 <merijn> bgamari: Depending on if you know when the last thing exits. Otherwise, use a chan + a counter, increment everytime you forkIO, decrement anytime a thread sends a message on the chan, exit when 0.
13:38:43 * hackagebot simple-log 0.1.3 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.1.3 (AlexandrRuchkin)
13:39:39 <ion> Logarithm? Log files? Timber physics simulator?
13:42:03 <EvanR> its log its log, its big its heavy its wood
13:42:15 <EvanR> its log its log, its better than bad, its good!
13:42:34 <EvanR> log, from blamo
13:44:45 * ski . o O ( s/deriving (Functor)/deriving Functor/ )
13:45:17 <ion> deriving Functor, Show
13:48:43 * hackagebot hails 0.9.0.1 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.9.0.1 (AmitLevy)
13:51:48 <ion> What next? “fails – functional web framework”
13:52:15 <tac_> ion: come now. It would at least be called "frail"
13:52:16 <tac_> :)
13:52:17 <applicative> snails
13:53:25 <ozgura> I thought it always needed to start with an h? :)
13:54:53 <hpaste> Aluink pasted “Monoid Monad” at http://hpaste.org/75995
13:55:15 <aluink> i'm curious why that paste isn't defined already?
13:56:19 <aluink> does it break one of the monadic laws somehow?
13:57:12 <slack1256> I don't have any background on CS which book should I read on Data-structures before learning of only persistent data structures on okasaki?
13:57:19 <maukd> it breaks most Monoid instances
13:57:23 <maukd> does it even compile?
13:57:28 <aluink> yes
13:57:32 <slack1256> is there something as intro to (normal/imperative) data-structures.
13:57:34 <fmap> the same problem as with `instance C1 a => C2 a where …', i guess?
13:57:53 <aluink> ah snap, i had FlexibleInstances defined from something earlier
13:57:55 <rwbarton> it's a fine instance but it would overlap with a lot of other useful instances
13:57:56 <aluink> ...no it doesn't
13:58:15 <hiptobecubic> slack1256, there are lots of books on data structures
13:58:53 <slack1256> but there isn't a recommended one as with functional data-structures right?
13:59:03 <rwbarton> there are usually a lot of ways to make a monoid instance for a type
13:59:38 <Sharyari> Hi. I have installed the random package through cabal, but it is still not found. Any reason for this? Or should I link it manually somehow?
13:59:42 <aluink> yeah, this gives an Illegal instance declaration...then telling me to consider FlexibleInstances
14:01:06 <hiptobecubic> slack1256, there might be. go look on stanfords course description pags
14:01:07 <hiptobecubic> they usually make good choices
14:01:08 <aluink> yeah, and now I don't even know what the error means :(
14:01:55 <merijn> aluink: It means that the haskell standard is very prissy about what is defined as a "proper" instance declaration :p
14:02:11 <merijn> aluink: My usual solution is: just enable FlexibleInstances and don't worry
14:02:11 <aluink> i'm reading about it now, but is there any common perception/knowledge on FlexibleInstances?
14:02:11 <hpaste> applicative annotated “Monoid Monad” with “Monoid Monad (annotation)” at http://hpaste.org/75995#a75997
14:02:21 <aluink> ok
14:02:32 <applicative> aluink: this is harmless ^^ .
14:02:37 <slack1256> hiptobecubic: good idea.
14:02:47 <merijn> aluink: FlexibleInstances is perfectly ok as extension, the only downside is maybe slightly reduced portability of your code
14:03:02 <merijn> aluink: But unless you were planning to support anything other than GHC, who cares?
14:03:48 <merijn> aluink: The extensions to watch out for/avoid/be careful with (depending who you ask) are OverlappingInstances/UndecidableInstances/IncoherentInstances
14:03:51 <aluink> ok, i'll read more, but that's good to know...so now on to how this breaks Monoid laws
14:04:03 <applicative> I think it's a sign that things are going to get complicated and horrible later....
14:05:11 <merijn> aluink: It doesn't, I think people were saying that there are other possible monoid instances for "m a" and this one stops you from defining them
14:05:28 <rwbarton> for example [a] if a is a Monoid
14:05:35 <rwbarton> [a] already has mappend = (++)
14:05:36 <fmap> merijn -UndecidableInstances +GeneralizedNewtypeDeriving
14:06:03 <merijn> fmap: Dons says GeneralizedNewtypeDeriving is fine
14:06:09 <merijn> Here: http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
14:07:40 <c_wraith> GND is fine, except when it lets you break the type system
14:08:00 <aluink> oh, ok. so what you're saying is taht by defining this instance at such a high level, more specific instances such as Monoid [a] become ambiguous
14:08:12 <applicative> aluink: I think you should demand that the WrapMonad exported by Control.Applicative should have this monoid instance
14:08:26 <aluink> should i use mappend = (++) or mappend = lifM2 mconcat . sequence
14:08:58 <fmap> merijn: that's strange, afair with GND you can write unsafeCoerce
14:09:16 <aluink> applicative: i'm not familiar with WrapMonad...but will go read up
14:09:25 * aluink is pretty green
14:09:28 <rwbarton> there's also mzero = return (), mappend = (>>)
14:09:39 <fmap> @google generalized newtype deriving undefinable functions
14:09:40 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2010-March/074310.html
14:09:40 <lambdabot> Title: [Haskell-cafe] generalized newtype deriving allows the definition of otherwise u ...
14:10:44 <applicative> aluink: the trouble is with the Monoid class, it's really a place where the class + type system looks a little shabby. It works for things like Num on the one hand, and for things like Functor, Monad .on the otehr
14:12:01 <dylukes> slack1256: there are a few 'well known' books, but generally speaking the contents are similar.
14:12:01 <dylukes> I learned mostly from the internet, Introduction to Algorithms, bits of Programming Pearls, ...
14:12:06 <aluink> applicative: their differences being their kind?
14:12:47 <applicative> aluink: Yeah, I guess I think it's awesome for things of kind * -> *
14:12:52 <nicoo> dylukes: Frankly, Papadimitriou's "Algorithms" is much better than Cormen, Lieserston, Stein and Rivest's
14:12:59 <rwbarton> it's really just that Monoid is so simple
14:13:08 <applicative> aluink: and then for chicken feed things that are going to be horrible anyway like + - it's tolerable
14:13:23 <rwbarton> whereas you're pretty unlikely to have two different ways to add, subtract and multiple things
14:13:45 <rwbarton> you're very likely to have several ways to just have a monoid operation
14:14:21 <danharaj> Why did GHC opt to add datatype promotion instead of a `kind` declaration?
14:14:36 <aluink> applicative: well, in this case i'm not defining Monoid on the type, but more on the * -> *
14:14:48 <aluink> as long as the end * is a Monoid itself
14:15:26 <merijn> mm_freak: Bah, you should put netwire 4 on hackage so I can hoogle the documentation >.>
14:15:37 <aluink> gah, i g2g...wife + morning sickness = unpredictable life :(
14:15:44 <aluink> i'll chew on this, thx
14:15:46 <merijn> danharaj: Now you can just use Maybe rather than having to define your own kind for it
14:15:53 <merijn> (for example)
14:16:08 <danharaj> I don't see why the namespaces should be muddled so.
14:16:18 <dylukes> nicoo: I haven't read it, I'll take a look.
14:16:28 <dylukes> I'm taking an algorithms/data structures course next term and I'd love a companion book
14:16:46 <Luke> I have a problem with HDBC-ODBC where it works unless I compile with profiling included. any idea how to fix this?
14:17:17 <dylukes> it is a little muddly.
14:17:23 <dylukes> I'm not sure how I feel about datatype promotion atm.
14:17:32 <sleepster> why would one want to use F# over haskell?  It seems to me that there would be no reason to.. but I am just curious if anyone has used both F# and Haskell
14:17:39 <dylukes> I guess it kind of ties the upper level of the value/type/kind stratification into itself.
14:17:41 <danharaj> because you want to leverage .NET
14:17:46 <dylukes> ^
14:17:52 <slack1256> sleepster: .Net bro
14:17:56 <dylukes> Because you hate yourself.
14:18:06 <dylukes> (I jest, it's just a somewhat weaker OCaml variant)
14:18:08 <reprapb> hi, how can I convert an integer to a character?
14:18:13 <sleepster> I see.. that's what I thought
14:18:14 <applicative> danharaj: I had a similar idea, there should be promoted types, but they should be of a new unlifted variety.
14:18:19 <dylukes> reprapb: Look at the Ord instance for Char.
14:18:24 <sleepster> thanks
14:18:27 <dcoutts> @hoogle Int -> Char
14:18:28 <lambdabot> Data.Char chr :: Int -> Char
14:18:28 <lambdabot> Data.Char intToDigit :: Int -> Char
14:18:28 <lambdabot> Data.Text index :: Text -> Int -> Char
14:18:30 <merijn> Can I hide Prelude in ghci?
14:18:33 <dylukes> er, not Ord
14:18:33 <rwbarton> not Ord surely
14:18:40 <applicative> > chr 33
14:18:40 <rwbarton> ord perhaps :)
14:18:41 <lambdabot>   '!'
14:18:45 <nooodl_> @src intToDigit
14:18:45 <lambdabot> Source not found. Just try something else.
14:18:47 <dylukes> Enum, sorry.
14:18:47 <applicative> > ord 'm'
14:18:49 <lambdabot>   109
14:18:52 <rwbarton> ah, integer to character, not character to integer
14:18:52 <nooodl_> @src Data.Char.intToDigit
14:18:53 <lambdabot> Source not found. Sorry.
14:18:54 <reprapb> dylukes, thanks
14:18:59 <nooodl_> huh.
14:19:01 <dylukes> > fromEnum 'c'
14:19:02 <lambdabot>   99
14:19:08 <dylukes> > toEnum 95 :: Int
14:19:10 <lambdabot>   95
14:19:15 <dylukes> > toEnum 95 :: Char
14:19:16 <lambdabot>   '_'
14:19:23 <dylukes> etc
14:20:25 <applicative> danharaj: then we could sneak in 'unlifted' types into haskell...
14:20:36 <nooodl_> > map intToDigit [0..15]
14:20:36 <danharaj> applicative: I don't see why that's a problem.
14:20:37 <lambdabot>   "0123456789abcdef"
14:20:54 <nooodl_> reprapb: ^ Data.Char.intToDigit does just that
14:21:00 <applicative> danharaj: I was thinking it was a good idea...
14:21:08 <danharaj> yes I noticed that just now
14:21:10 <danharaj> :3
14:21:12 <reprapb> I couldn't find this on google, nor in my haskell book, when Haskell expects an "actual type `Maybe t0'", what does that mean?
14:21:29 <maukd> reprapb: where did you get "expects" from?
14:21:43 <danharaj> reprapb: You have an expression that has type `Maybe t0` (for some t0), but the type it wants is something else.
14:21:45 <reprapb> maukd: "Couldn't match expected type `[Char]' with actual type `Maybe t0'"
14:21:53 <applicative> actual type :: Foo  means, thats the type you gave it
14:21:56 <maukd> reprapb: so it expects "[Char]"
14:21:59 <maukd> reprapb: not Maybe t0
14:22:13 <reprapb> maukd, but what is this "t0"?
14:22:18 <danharaj> it's probably Char
14:22:18 <maukd> reprapb: a type variable
14:22:18 <applicative> but expected type Bar means:: you were supposed to put a Bar there
14:22:38 <reprapb> alright, thanks
14:22:40 <danharaj> I think GHC stops caring when it infers the type has the wrong shape so it doesn't unify the type variable.
14:22:43 <nooodl_> t0 is a name haskell invents for "some type varialbe"
14:22:55 <applicative> reprapb: all it knows is that it was giving you some kind of Maybe, when it wanted a Char
14:23:08 <applicative> you were giving it a Maybe, rather
14:23:17 <maukd> and it wanted a list, not a Char
14:23:26 <applicative> string indeed
14:23:52 <maukd> > "a" ++ Nothing
14:23:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:23:53 <lambdabot>         against inferred ty...
14:24:33 <applicative> To put it correctly, reprapb "Couldn't match expected type `[Char]' with actual type `Maybe t0'" means: I wanted a String there, but you gave me some funny kind of Maybe
14:27:14 <reprapb> applicative, thanks
14:32:30 <merijn> @localtime mm_freak
14:33:26 <Soft> I don't understand what ghci does when I run something like "pure 5" (from Applicative). If pures type definition is a -> f a and it can't infer what f I mean from anything what does it do then.
14:33:46 * hackagebot bytestring-progress 1.0.3 - A library for tracking the consumption of a lazy ByteString  http://hackage.haskell.org/package/bytestring-progress-1.0.3 (AdamWick)
14:33:54 <maukd> complain
14:34:14 <Soft> it doesn't seem to
14:34:15 <rwbarton> actually it won't complain because first it tries to typecheck your expression as IO something
14:34:16 <merijn> maukd: It doesn't
14:34:16 <danharaj> It doesn't complain.
14:34:23 <danharaj> Because it defaults f to IO
14:34:26 <rwbarton> and that succeeds and forces f = IO
14:34:31 <danharaj> and 5 to Int
14:34:38 <maukd> Soft: then it can infer what f to use
14:34:46 <rwbarton> 5 is defaulted but f is forced
14:35:01 <jfischoff> In TH if I want to make a guard with "otherwise" as the expression, would I make a varE 'otherwise?
14:35:02 <c_wraith> danharaj: should be Integer, not Int
14:35:12 <tgeeky> ha! I didn't say "defaulting" because I didn't what to say other than the single word :o
14:35:37 <danharaj> c_wraith: Close enough.
14:35:38 <c_wraith> Soft: ghci uses special rules for defaulting types that ghc doesn't, unless you enabled the ExtendedDefaultingRules extension
14:36:19 <maukd> jfischoff: I'd use True but I don't know TH
14:36:34 <jfischoff> cool
14:37:16 <Soft> oh okey
14:38:34 <rwbarton> > pure 5
14:38:35 <lambdabot>   No instance for (GHC.Show.Show (f t))
14:38:35 <lambdabot>    arising from a use of `M6706680421...
14:38:42 <rwbarton> @hoogle typeOf
14:38:43 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
14:38:43 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
14:38:43 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
14:38:47 <applicative> Soft in some respects, typing in ghci is like writing lines in an IO do block.  For pure things, it take hitting return to mean 'print' or for things of type Doc it has another rule...
14:39:50 <rwbarton> I thought it just tries to execute your expression as an IO action and if that fails it wraps print around the thing and tries again
14:40:24 <rwbarton> which is roughly what you said
14:40:26 <applicative> rwbarton: right, I think I was trying to say more or less that
14:41:17 <applicative> but that wont work for Text.PrettyPrint.Doc exactly
14:41:34 <rwbarton> isn't that just the Show instance for Doc?
14:41:51 <rwbarton> I haven't really used that
14:42:01 <merijn> @tell mm_freak What happened to the testWire/testWireM functions from Netwire 3? I've been playing around with Netwire 4, but I don't understand the new testWire/testWireM functions?
14:42:01 <lambdabot> Consider it noted.
14:42:53 <applicative> rwbarton: I think it applies print . render rather than print
14:43:16 <applicative> > text "hi" $$ text "bye"
14:43:18 <lambdabot>   hi
14:43:18 <lambdabot>  bye
14:43:58 <applicative> > show (text "hi" $$ text "bye")
14:43:59 <lambdabot>   "hi\nbye"
14:44:24 <applicative> so maybe it is the same?
14:44:36 <rwbarton> those appear to be the same, yes
14:45:03 <applicative> yes, it is.
14:48:02 <applicative> the show instance uses a default style
14:49:04 <applicative> not the one it would have derived :)
14:50:53 <danharaj> How would I make a kind of type-level lists where the elements range over a kind other than *?
14:51:15 <tgeeky> :: [* -> *] -- ?
14:52:42 <danharaj> :k doesn't work on that :[
14:52:44 <lambdabot> parse error on input `:'
14:52:48 <danharaj> :k [*->*]
14:52:50 <lambdabot> parse error on input `*->*'
14:52:57 <rwbarton> it is already a kind
14:53:07 <danharaj> ... yes. yes it is.
14:53:17 <danharaj> I am a 2-sort programmer, it seems.
14:53:23 <danharaj> I need to acquire that third sort.
14:53:48 <tac_> danharaj: Life is so much easier when * :: *
14:54:10 <danharaj> But is Life consistent when * :: *?
14:55:24 <tac_> Well, life was never consistent to begin with, but now, "Code's compiling" is potentially a very good excuse to slack off all day.
14:58:14 <Sharyari> How do I generate a list of random numbers?
14:58:25 <danharaj> > repeat 4
14:58:27 <lambdabot>   [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,...
14:58:30 <mcstar> coin flip
14:58:34 <shachaf> You mean a random list of numbers?
14:58:41 <shachaf> Well -- randomly generate a list of numbers.
15:01:21 <maukd> :t randoms
15:01:22 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
15:01:26 <shachaf> @remember ddarius (f x) is a partial application iff f x == (curry (uncurry f) x)
15:01:26 <lambdabot> Good to know.
15:02:10 <nooodl_> > do { gen <- newStdGen; randoms gen :: [Integer] }
15:02:12 <lambdabot>   Couldn't match expected type `GHC.Types.IO b'
15:02:12 <lambdabot>         against inferred type...
15:02:28 <maukd> :t randomsIO
15:02:29 <lambdabot> Not in scope: `randomsIO'
15:02:46 <nooodl_> what'd i do wrong
15:02:59 <mcstar> Int
15:03:01 <mcstar> not Integer
15:03:44 <nooodl_> lambdabot gives me the same error for everything; the type's not the issue
15:03:45 <nooodl_> > do { gen <- newStdGen; randoms gen :: [Bool] }
15:03:46 <lambdabot>   Couldn't match expected type `GHC.Types.IO b'
15:03:47 <lambdabot>         against inferred type...
15:05:50 <merijn> nooodl_: lambdabot doesn't do IO
15:05:50 <mcstar> nooodl_: anyway, dont tell me you can generate an Integer with uniform probability density
15:06:07 <merijn> (for obvious reasons)
15:06:13 <shachaf> nooodl_: The type is certainly the issue.
15:06:23 <shachaf> That's why you're getting a type error.
15:07:43 <nooodl_> > randoms (mkStdGen 42) :: [Int]
15:07:45 <lambdabot>   [-3907187990116499535,-2519438828217931933,-8264534369199619667,86887135830...
15:07:53 <ski> @help run
15:07:54 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
15:08:10 <shachaf> FSVO "Haskell"
15:08:21 <tac_> > map (\x -> x `mod` 100) randoms (mkStdGen 42) :: [Int]
15:08:23 <lambdabot>   Couldn't match expected type `[a]'
15:08:23 <lambdabot>         against inferred type `g -> [a1]'
15:08:27 <tac_> damnit lambdabot
15:08:40 <tac_> > map (\x -> x `mod` 100) $ randoms (mkStdGen 42) :: [Int]
15:08:41 <lambdabot>   [65,67,33,69,80,17,25,72,58,13,15,79,94,47,80,45,79,58,34,37,74,25,71,47,48...
15:09:02 <ski> > randomRs (0,99) (mkStdGen 42) :: [Int]
15:09:03 <lambdabot>   [71,71,17,14,16,91,18,71,58,75,65,79,76,18,4,45,87,51,93,36,66,4,32,94,36,1...
15:09:23 <shachaf> randomArr
15:09:25 <shachaf> @yarr
15:09:25 <lambdabot> Smartly me lass
15:09:34 <tac_> @vixen
15:09:35 <lambdabot> Solutions are not the answer.
15:10:04 <ski> @keal
15:10:05 <lambdabot> Cale etc already pointed out Haskell is puny to nothing to emulate using my barrage of mathematic theories
15:10:14 <Cale> lol
15:10:22 <Cale> dat keal
15:10:50 <Eduard_Munteanu> @protontorpedo
15:10:50 <lambdabot> does haskel work one windows?
15:11:28 <Eduard_Munteanu> @@ @google @protontorpedo
15:11:30 <lambdabot>  http://hackage.haskell.org/packages/archive/atto-lisp/latest/doc/html/atto-lisp.txt
15:12:08 <shachaf> @brain
15:12:09 <lambdabot> I think so, Brain, but, the Rockettes? I mean, it's mostly girls, isn't it?
15:13:17 <clahey> @brain
15:13:17 <lambdabot> Uh... yeah, Brain, but where are we going to find rubber pants our size?
15:22:55 <Bluelz> Ski: I think I have found a viable solution to my recursive problem. My recursive function went from beeing a [String] -> [String] to a [String] -> (MyTree,[String]). I think this change just made it a lot easier to only catch the "rest" of the input after someof it has been parsed already
15:23:26 <ski> Bluelz : yes ;)
15:28:48 * hackagebot ghc-mtl 1.0.1.2 - An mtl compatible version of the Ghc-Api monads  and monad-transformers.  http://hackage.haskell.org/package/ghc-mtl-1.0.1.2 (DanielGorin)
15:28:50 * hackagebot hint 0.3.3.5 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.3.3.5 (DanielGorin)
15:30:05 * ski waits for Bluelz to invent full-blown parser combinators, from scratch
15:30:49 <Polarina> Why doesn't transformers have MonadState and such like mtl does?
15:34:23 <c_wraith> transformers only has the single-parameter typeclasses
15:36:49 <canta> let x0 = [] .. let x1 = x0:x0 .. let x2 = x1:x1 .. works if done manually in ghci, why does a function which does the same ( f xs = xs:xs ) not compile? (cannot create infinite type)
15:37:43 <Polarina> c_wraith, out of curiosity, is there any particular reason as to why that is?
15:38:20 <danharaj> canta: because x0::[a], x1 :: [[a]], x2::[[[a]]], etc.
15:39:04 <c_wraith> Polarina: I believe it was so that it could stay haskell98
15:39:06 <maukd> canta: that's not the same thing
15:39:12 <maukd> canta: your function doesn't use 'let'
15:39:15 <Polarina> Oh. I see.
15:47:38 <ski> canta : because arguments are monomorphic (if you don't specify otherwise with a type signature)
15:48:31 <canta> The problem is that the function I try to create would need to be [a] -> [[a]] the first time, then [[a]] -> [[[a]]] .. and so on, because it does try to put an other value in front of the list?
15:49:37 <ski> > let f xs = xs:xs in f []
15:49:38 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:49:49 <ski> > let f :: forall a. [a] -> [[a]]; f xs = xs:xs in f []
15:49:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:49:52 <ski> > let f :: (forall a. [a]) -> (forall a. [[a]]); f xs = xs:xs in f []
15:49:53 <lambdabot>   [[]]
15:52:28 <ski> canta : .. perhaps you'd like to show your code ?
15:59:16 <hpaste> cnt pasted “setNum” at http://hpaste.org/76004
16:00:10 <ski> canta : you need dependent types to express the type of `toSetNum'
16:00:35 <ski> or you can make a datatype
16:01:00 <ski>   newtype HereditarilyFiniteSet = HFS [HereditarilyFiniteSet]
16:03:00 <ski> instead of `[]', you'd use `HFS []', and instead of `x_pred:x_pred', you'd use `HFS (x_pred : unHFS x_pred)' (with `unHFS (HFS elements) = elements')
16:05:53 <ski> you might enjoy looking at "A Functional Hitchhiker's Guide to Hereditarily Finite Sets, Ackermann Encodings and Pairing Functions" by Paul Tarau in 2008-08-06 at <http://arxiv.org/abs/0808.0754>
16:05:58 <ski> canta ^
16:10:19 <canta> ski: thanks, that works, will read that article
16:18:15 <cornihilio> hey, I want to create a file from an existing one that just wraps the contents again and again until it has written a file of at least a specific size
16:18:25 <cornihilio> what's the best way to do that in haskell?
16:20:03 <ski> an alternate approach might be to use type-level naturals `toSetNum :: IsNat n -> Pow [] n a' with `data IsNat :: * -> * where IsZero :: IsNat Zero; IsSucc :: IsNat n -> IsNat (Succ n)' and `data Pow (f :: * -> *) :: * -> * -> * where PowZero :: a -> Pow f Zero a; PowSucc :: Pow f n (f a) -> Pow f (Succ n) a'
16:21:47 <ski>   writeFile newFileName . take size . cycle =<< readFile oldFileName  -- cornihilio, maybe this ?
16:22:05 <ski> (note that that will not handle the case of a zero-length file gracefully)
16:22:49 <ski> (other than that, that will always output a file of size `size' -- maybe you didn't want that)
16:27:21 <jmcarthur> cornihilio: read in the file, cycle its contents, take the amount you need, write that out?
16:33:29 <hallettj> I'm working with a binary format that includes references to values at previous byte offsets in a message.  The bytesRead function in Data.Binary.Get is really helpful for parsing this format.  For serialization a complementary bytesWritten function would be really helpful - but that function does not seem to exist in Data.Binary or in Data.Serialize.  Does anyone know how to reference the number of bytes written using some binary serialization library?
16:39:19 <startling> if I make an instance for Text.Blaze.Internal.Markup, why would I get No instance for (SomeClass Html)?
16:39:58 <c_wraith> because Markup isn't Html
16:40:25 <startling> :info Html says type Html = H.Markup.
16:40:49 <c_wraith> oh.  Then probably a scope issue
16:41:00 <startling> how do you mean?
16:41:11 <c_wraith> is that instance in scope where you're trying to use it?
16:41:13 <Cale> hallettj: That does seem like a good idea. I don't know of a library which does that though.
16:41:25 <startling> c_wraith: yes
16:41:48 <c_wraith> well, then, you either declared the instance for the wrong class, or the wrong type.  (or maybe both)
16:42:00 <startling> oh, could it be a versioning thing?
16:42:14 <hallettj> Cale: Thanks for checking anyway :)
16:42:25 <rwbarton> possibly but not very likely
16:42:30 <c_wraith> potentially.  Having multiple versions of the same package in scope is...  um...  terrifying.
16:42:40 <rwbarton> what does :i SomeClass say after you define the instance
16:43:17 <startling> instance SomeClass Text.Blaze.Internal.Markup
16:43:25 <startling> looks like a versioning thing, yeah
16:43:27 <startling> thanks!
16:43:27 * ski was suspecting perhaps `SomeClass' being a superclass of `Markup'
16:43:49 <rwbarton> did you fix it?
16:43:51 * hackagebot containers 0.5.1.0 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.5.1.0 (JohanTibell)
16:43:58 <rwbarton> there was also some weird ghci bug with instances and type synonyms
16:44:53 <startling> yep, I had blaze-markup-0.5.1.1, blaze-markup-0.5.1.0, and blaze-html-0.5.1.0.
16:45:13 <rwbarton> good times
16:45:15 <startling> looks like blaze-html-0.5.1.0 pulled in blaze-markup-0.5.1.0, but my instance was using blaze-markup-0.5.1.1
16:45:27 <startling> >.>
16:51:24 <startling> "Continuing even though the plan contains dangerous reinstalls."
16:51:33 <startling> cabal is such a drama queen
16:54:05 <startling> does FlexibleInstances turn on TypeSynonymInstances?
16:54:34 <dmwit> not any more
16:56:43 <startling> what's "any more"?
16:57:14 <dmwit> I'm pretty sure there are a few versions of GHC for which FI implies TSI.
16:57:41 <startling> got it. seems like it's doing so right now
17:23:05 <cornihilio> ski: sorry for not getting back to you earlier, but would that process work lazily? I want to write a file that is ~2 times the size of ram.
17:27:51 <gwern> @quote
17:27:52 <lambdabot> ym says: sigh. i could have just become another ruby snob in the time it's taking me to figure out Scala's type system
17:28:20 <shachaf> @quote strict
17:28:21 <lambdabot> quicksilver says: partially applied type synonym = type lambdas = unrestricted type functions = can of pants
17:28:27 <shachaf> @quote strictness
17:28:28 <lambdabot> ghc says: Unexpected strictness annotation
17:30:17 <ski> cornihilio : yes, but the input file would be fully slurped into memory
17:30:58 <Lutin`> bytestrings?
17:31:13 <ski> @quote bytestrings
17:31:13 <lambdabot> No quotes match. Where did you learn to type?
17:31:21 <ski> @quote bytestring
17:31:21 <lambdabot> pozic says: I think if you want to contact dons, you have to say that you found a bug in ByteString.
17:31:38 <Lutin`> lol
17:31:49 <Jafet> A performance bug.
17:33:10 <cornihilio> and size, is that in bits?
17:34:44 <ski> characters
17:37:04 <shachaf> class Tiresome a where sighsOf :: a -> Int
17:37:47 <troydm> guys i'm installing haskell from source so i've downloaded haskell platform
17:38:21 <shachaf> troydm: Why would you do it from source?
17:38:37 <troydm> shachaf: i'm on openindiana
17:38:44 <troydm> so i don't have much choice
17:38:49 <shachaf> Ah.
17:38:57 <troydm> so i've downloaded sources to haskell platform
17:39:04 <troydm> and when i go to website of ghc
17:39:16 <troydm> it says that ghc is already in haskell platform
17:39:20 <Lutin`> instance Tresome Lutin` where sighsOf Lutin` = 9001
17:39:27 <troydm> but i don't see any ghc in haskell platform sources
17:39:28 <Lutin`> blah
17:39:35 <geekosaur> not in the sources, no
17:39:52 <troydm> so what's the right sequence of installing ghc && haskell platform when building from sources?
17:39:56 <geekosaur> for source build, you need to bootstrap cabal-install using your ghc, then use that to install the cabal packages
17:40:01 <geekosaur> comprising the platform
17:40:07 <shachaf> troydm: Haskell Platform is just a bunch of libraries.
17:40:14 <shachaf> You can install them yourself and get the same effect.
17:40:35 <troydm> geekosaur: wait
17:40:42 <troydm> i need to install cabal
17:40:47 <troydm> before i'm installing ghc?
17:40:54 <Jafet> I wonder if troydm even has a ghc binary.
17:41:08 <geekosaur> there should be, along with the sources, a cabal file which specifies the components making up the platform.  in the simplest case, you don;t neven need to download naything but the cabal-install bootstrap and then that cabal file, and run cabal update, and then cabal install the cabal fule to have it doewnload and install the package compoents from hackage
17:41:13 <troydm> Jafet: i've managed to get one
17:41:16 <geekosaur> you install ghc first
17:41:21 <troydm> also it's weird version ghc 7.2.2
17:41:38 <troydm> geekosaur: so now i'm building ghc 7.6.1 from sources
17:41:40 <geekosaur> youa re being confused byt he fact that for MOST people, you should not start with a ghc binary, you should get a binary platform installer
17:41:57 <Lutin`> Could you use a non-ghc compiler?
17:41:58 <troydm> geekosaur: i see
17:42:05 <geekosaur> right, so now you need either an older ghc binary to bootstrap from or you need to follow the bootstrap compiler instructions
17:42:16 <geekosaur> I thought there was a 7.x series ghc package for OI
17:42:18 <Lutin`> Oh yeah
17:42:26 <geekosaur> you'll want ot use that to bootstrao
17:42:28 <geekosaur> er
17:42:34 <geekosaur> to bootstrap the new ghc
17:42:45 <geekosaur> then use that ghc to install the cabal-install boostrap package
17:43:14 <geekosaur> if you can't use an older ghc binary package then things get kinda uglt
17:43:23 <troydm> geekosaur: isn't cabal-install included in haskell platform?
17:43:29 <troydm> or it's part of ghc ?
17:43:47 <troydm> ghc sources i mean
17:43:49 <geekosaur> sigh
17:44:09 <geekosaur> cabal-install is included in the platform, it is not part of ghc, it is available as a separate bootstrap package
17:44:19 <troydm> coz now i did ./configure && make on ghc sources
17:44:23 <troydm> and it's still running
17:44:31 <troydm> i think it's compiling cabal now
17:44:38 <geekosaur> that's the library component
17:44:55 <troydm> hmm
17:45:09 <Jafet> > "Cabal" == "cabal-install"
17:45:10 <lambdabot>   False
17:45:12 <geekosaur> cabal-install bootstrap is http://www.haskell.org/cabal/release/cabal-install-0.14.0/cabal-install-0.14.0.tar.gz
17:45:27 <geekosaur> this does not require the platform, only a working ghc
17:45:28 <troydm> ic
17:45:35 <acowley> Has anyone here used the levmar package?
17:45:56 <troydm> geekosaur: so first i need to install/compile latest ghc 7.6.1
17:46:07 <troydm> and only after that get cabal-install
17:46:11 <troydm> yes?
17:47:13 <cornihilio> why am I getting this complaint about the the file handle I am passing?: test.hs: ./sample.pcap: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
17:47:21 <geekosaur> hrm
17:47:38 <troydm> i do want to install the latest ghc
17:47:40 <geekosaur> released platform does not support 7.6.1 specifically, I do not know how much of a problem this will cause for you
17:47:43 <troydm> and get rid of this old one
17:48:09 <geekosaur> ghc is not the linux kernel, followingt he bleeding edge is NOT generally recommended unless you like experimenting with esoteric type machinery
17:48:17 <cornihilio> what sort of readFile/writeFile am I supposed to be using? data.bytestring.char8?
17:48:22 <troydm> geekosaur: so which one should i get?
17:48:46 <geekosaur> cornihilio, that error usually means you have the wrong locale set
17:48:52 <Jafet> cornihilio: what is the encoding of the file?
17:49:01 <cornihilio> it's a binary file
17:49:18 <Jafet> Which hGetContents are you using?
17:49:39 <cornihilio> ... the one that readFile uses? I'm not calling it directly.
17:49:46 <geekosaur> troydm, http://www.vex.net/~trebla/haskell/haskell-platform.xhtml says the current platform wants 7.4.1
17:49:48 <Jafet> Which readFile, then?
17:49:53 <cornihilio> createLargeFile oldFileName newFileName size = writeFile newFileName . take size . cycle =<< readFile oldFileName
17:50:12 <cornihilio> Jafet: I'm not sure myself. Do you know how I might find out?
17:50:14 <geekosaur> the release cycle for the next one just started a few dats agi
17:50:14 <Jafet> Prelude.readFile reads text.
17:50:23 <Jafet> To read bytes, use ByteString.readFile.
17:50:29 <geekosaur> *sigh* sorry, I am rather tired right now and it's affectimg my typing
17:50:43 <Jafet> (The reason should be obvious from the return type.)
17:50:55 <cornihilio> Jafet: thank you!
17:51:07 <Jafet> To read text that is in a strange encoding, also read ByteString and use Text.Encoding.
17:51:07 <geekosaur> I do not know what ghc is supported by the new release off the top of my head
17:55:03 <geekosaur> troydm: http://projects.haskell.org/pipermail/haskell-platform/2012-October/002208.html is th emost recent information I have about the next platform release.  It doesn't seem to say which ghc will be included; maybe the repo will be more forthcoming
17:55:38 <cornihilio> hmm... but now I have this issue: https://gist.github.com/3855914
17:55:57 <cornihilio> I don't get that new type complaint of [a0] -> [a0]
17:56:02 <troydm> geekosaur: ic, well i think i'll try to compile 7.4.2 then
17:56:18 <troydm> i hope it's not too much different compared to 7.4.1
17:57:30 <mm_freak> nand`: that's nice to know, thanks =)
17:57:31 <lambdabot> mm_freak: You have 1 new message. '/msg lambdabot @messages' to read it.
18:00:14 <mm_freak> @tell merijn i want to explore a few things before releasing it…  the testWire* functions work the same way:  'testWire 1000 0 (return 15) myWire' runs myWire displaying every 1000th output with no threadDelay (0) inbetween…  the input is 15 at every instant…  perhaps i should add examples to the haddocks
18:00:15 <lambdabot> Consider it noted.
18:00:50 <doomlord> anyone here used the opengl/glut bindings
18:02:33 <doomlord> how does one implement a classic rendering loop .. state object being updated by controller info coming back from the mouse motion callback
18:02:54 <doomlord> & rendering of that in the glut display callback
18:16:54 <tswett> Ahoy.
18:17:00 <Sculptor> yarr
18:17:07 <tswett> Avast.
18:17:11 <tswett> I'm trying to install Idris using cabal.
18:17:29 <tswett> It says, "Could not find module `Control.Monad.State'.  Perhaps you haven't installed the profiling libraries for package `mtl-2.1.2'?"
18:17:36 <tswett> That's nice.  How do I do that?
18:18:40 <deech> Hi all, is there some way in Haskell of tracing the type checker? As in watching how it deduces the type of something.
18:19:28 <tswett> Do I... set library-profiling to True and then reinstall the relevant packages?
18:20:22 <tswett> Oh, library-profiling *is* True.  Let me try just reinstalling, then.
18:24:38 <tswett> Well, that's one error fixed.
18:25:11 <lispy> deech: Not that I know of.
18:25:14 <dmwit> deech: not really
18:25:17 <dmwit> dang
18:25:19 <dmwit> too slow
18:25:23 <lispy> deech: Have you read typing Haskell in Haskell?
18:25:51 <lispy> deech: that paper shows you how to make a type checker for Haskell. You could imagine making the visualization you want once you have your implementation.
18:25:54 <dmwit> deech: You can put undefined in for smaller and smaller subexpressions and watch the types evolve. =)
18:26:50 <lispy> deech: Link to PDF on this page: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.470
18:26:50 <deech> lispy: No I haven't completed it. I started and realized that it only targets Haskell98. It seems like there's a huge difference between that and the way Haskell is used in practice today (Multiparam type classes and so on)
18:27:17 <lispy> deech: Understanding Haskell98 will give you a really solid foundation for the other stuff :)
18:27:41 <deech> lispy: I think I somewhat get type inference for simple types. It's when the commonly used extensions start kicking in that I have trouble.
18:27:49 <doomlord> what is $=
18:27:52 <deech> lispy: I'll look at it again.
18:28:01 <lispy> ?hoogle ($=)
18:28:01 <lambdabot> No results found
18:28:12 <lispy> doomlord: it's probably a definition specific to the code you have
18:28:26 <doomlord> ok (its a glut example)
18:28:34 <lispy> ah, that's from StateVar then
18:28:53 <lispy> doomlord: http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html
18:29:07 <lispy> doomlord: it's essentially an infix operator for writeIORef
18:29:10 <lispy> :t writeIORef
18:29:12 <lambdabot> Not in scope: `writeIORef'
18:29:31 <doomlord> "references in the IO monad..."
18:29:39 <lispy> instance HasSetter IORef where ($=) = writeIORef
18:29:43 <gfredericks> I'm reading a paper on HList -- is this used often?
18:29:52 <doomlord> i'm trying to figure out how to implement a typical  update-render loop in haskell/glut bindings
18:30:08 <lispy> gfredericks: Not really. I've only seen it used outside of Oleg's work once or twice?
18:30:27 <gfredericks> lispy: kthx
18:30:47 <lispy> doomlord: may I recommend this? http://hackage.haskell.org/package/nehe-tuts
18:30:54 <doomlord> thanks
18:31:12 <lispy> doomlord: I prefer GLFW-b over GLUT, but opinions vary
18:31:16 <doomlord> <now i remember why i veered off from haskell to lisp variants a while back...>
18:31:39 <doomlord> i've used glut more... but i gather glfw is better.
18:32:13 <doomlord> gluts' very minimal to get working in C and does the job for just getting graphics onscreen quickly
18:32:44 <lispy> doomlord: if you really want to use glut, look through the versions of nehe-tuts for the ones that use OpenGL+GLUT instead of OpenGLRaw+GLFW-b
18:33:17 <lispy> I rewrote them to use OpenGLRaw and GLFW-b at some point because I like those APIs better
18:33:30 <doomlord> fair enough.
18:33:38 <lispy> OpenGLRaw is harder for beginners, but it matches OpenGL C's api better
18:34:05 <doomlord> (in my c++ codebase i've just got glut and iOS+openGL-ES at the minute)
18:34:07 <lispy> So if you know OpenGL programming already and you want to learn how to do it in Haskell the OpenGL bindings get in the way (they introduce a lot of new functions)
18:34:58 <doomlord> should i bottle out and look for a framework and just get on with enjoying haskell
18:35:27 <lispy> Do we have any frameworks?
18:35:31 <lispy> I mean for OpenGL
18:35:49 <lispy> There is a binding to OGRE3D
18:35:54 <lispy> But I don't know of much else
18:36:05 <doomlord> ah, now i see GLFW does actually have a loop instead of passing callbacks like glut
18:36:16 <doomlord> that may well make things clearer in haskell
18:36:36 <doomlord> (i mean the sample code you gave that uses glfw)
18:36:56 * lispy nods
18:37:19 <lispy> it uses both really
18:37:27 <lispy> It has certain events that it wants you to register
18:37:33 <lispy> But then you get full control of your game loop
18:37:40 <doomlord> with the GLUT stuff.. it uses $= to assign render & update callbacks.. and i'm looking at that thinking how the hell do you update and render some world object
18:37:55 <doomlord> control over game loop, *want*.
18:38:32 <lispy> doomlord: If you decide you want to use FRP you might find this SO question informative: http://stackoverflow.com/questions/12685430/how-to-implement-a-game-loop-in-reactive-banana/
18:38:57 * hackagebot enummapset-th 0.5.1.0 - TH-generated EnumSet/EnumMap wrappers around IntSet/IntMap.  http://hackage.haskell.org/package/enummapset-th-0.5.1.0 (LiyangHu)
18:39:22 <doomlord> i've dealt with all that sort of thing before
18:39:22 * lispy is trying to keep an open mind about FRP, but has yet to adopt it
18:40:48 <YayMe> what on earth is the sample in that SO page doing? I see haskell mixed with a while loop ??
18:41:13 <doomlord> GLFW: how does input work
18:41:50 <lispy> YayMe: The code in the linked article is all C/C++ and I copied the final version of their loop as "pseudocode".
18:42:07 <lispy> YayMe: Obviously Haskell's syntax/implementation would look different
18:42:08 <doomlord> ah got it
18:43:39 <doomlord> hmmm.back to having to think a little about something basic in C :)  GLFW.KeyCallback is some monadic thing..
18:44:25 <lispy> doomlord: right. Eventually maybe there will be a better API on top of GLFW-b that is more Haskell friendly (FRP based?)
18:44:38 <lispy> For the small things I've written I've just used IORefs
18:44:52 <lispy> That's not really scalable but it gets the job done so far
18:44:56 <doomlord> i figure i want some function  'update:: World -> ControllerState -> World   and "render::World -> IO ()"that i can plug into a loop
18:45:17 <doomlord> so it seems like the challange is writing that loop..
18:45:29 <doomlord> or rather challenge for my n00by haskelling
18:45:58 <lispy> doomlord: I guess that's why I was asking about reactive-banana on SO
18:46:07 <lispy> doomlord: have you looked at frag?
18:46:08 <BMeph> "...now you have two problems"? ;)
18:46:27 <lispy> doomlord: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/frag
18:46:55 <lispy> BMeph: heh, possibly
18:46:55 <startling> can I make a template haskell function that a) makes a class, and b) sticks the name of that class in some list?
18:47:18 <doomlord> oh frag the quakey thing
18:47:30 <lispy> startling: I believe so, you can make types and insert types into lists and I'm not sure why type classes wolud be different
18:47:59 <startling> lispy: even if the template haskell function "modifies" some list?
18:48:50 <startling> meh, I'll just do "myList = ["a", "b", "c"]" and then "map myTHThing myList"
18:49:43 <doomlord> although gl calls are going to be in ::IO .. i guess a lot of the surrounding detail of a renderer can still be pure. frustum cull logic etc
18:49:46 <Jafet> There's always Q
18:50:46 <tac-tics> doomlord: it's easy to throw your trash in IO
18:50:59 <tac-tics> even though openGL is "pure", it still calls the C FFI.
18:51:20 <doomlord> are all C FFI calls impure
18:51:32 <lispy> opengl isn't pure though. It modifies the state of the opengl machine
18:51:40 <doomlord> thats the thing
18:51:43 <tac-tics> no. They can be masked unsafely.
18:51:56 <tac-tics> (that's also an inconvenient reality with OpenGL in particular)
18:52:11 <lispy> maksed unsafely?
18:52:19 <tac-tics> they *could* have modeled it using an openGL context, trapped in a monad, but it's easier to throw your trash in IO
18:52:25 <doomlord> i wondered if one could have different "IO monads"eg disk, network, input-devices, graphics..
18:52:26 <tac-tics> lispy: masked at all
18:52:32 <dmwit> Not all FFI calls are impure, but the pure ones are very rare.
18:52:36 <rwbarton> what is that an answer to
18:53:12 <startling> doomlord: you could. we don't.
18:53:22 <rwbarton> you can designate a call to e.g. sin() as pure
18:53:36 <Tekmo> I think he's saying that most of the pure calls are usually purified
18:53:47 <Tekmo> and that it's rare to find a pure FFI call that is not purified
18:53:57 <lispy> tac-tics: I think of that as something to build on top of the OpenGL api
18:54:09 <lispy> tac-tics: OpenGLRaw in particular
18:54:40 <lispy> Scene graphs are a nice abstraction in other languages for managing opengl calls. We could do something like that for Haskell.
18:54:57 <tac-tics> in an ideal world, everything would be neatly abstracted properly. But in the working world, people abstract as much as is useful for their immediate needs :)
18:55:02 <doomlord> is seperate device monads something that is ever discussed .. i think of the way D3D in c++ at least tries to mark areas of code that produce graphics effects by passing a device object around
18:55:12 <tac-tics> which is why OpenGL is IO based
18:55:36 <lispy> something like, renderGraph :: SceneGraph -> IO ()
18:55:41 <dmwit> ST is a monad for the RAM devices.
18:55:54 <lispy> So then you have pure code or ST code that manipulates the scene and only the rendering is IO ()
18:55:58 <Tekmo> tac-tics: Well, working on any library is a positive reinforcement cycle.  The more you work on it, the more people in that field don't get immediately put off by the state of Haskell libraries and begin giving back in the form of library contributions
18:56:35 <tac-tics> My lack of understanding of how real OSS works is probably why I contribute so little to it :P
18:56:39 <Tekmo> :)
18:56:39 <doomlord> i've heard of "monadius", i'm a fan of the game its based on :)
18:56:45 <tac-tics> I'd rather spend my free time building neat toys
18:56:55 <tac-tics> then throwing them away or breaking them when I get bored of them
18:57:38 <mm_freak> @oeis 2 3 5 17 257
18:57:39 <lambdabot>  Prime numbers of the form 2^n + 1.
18:57:39 <lambdabot>  [2,3,5,17,257,65537]
18:58:01 <Tekmo> What did you just do there?
18:58:23 <lispy> IIRC, almost all of the OpenGL api modifies something even if it's just the OpenGL equivalent of errno
18:58:47 <Tekmo> @oeis 2 17 3
18:58:49 <lambdabot>  Gpf(n): greatest prime dividing n (with a(1)=1).
18:58:49 <lambdabot>  [1,2,3,2,5,3,7,2,3,5,11,3,13,7,5,2,17,3,19,5,7,11,23,3,5,13,3,7,29,5,31,2,11...
18:58:57 <lispy> Giving that a pure interface on the Haskell side would make debugging harder
18:59:08 <AntonFrancisIre> @oeis 1 2 3
18:59:23 <lambdabot> Plugin `oeis' failed with: thread killed
18:59:24 <doomlord> "IORef, a mutable variable in the IO monad.." .. i didn't know you could do that. Would it be correct to stick such a variable in for the "world" object, and have it updated by a pure "update::World->Controller->World"
18:59:26 <AntonFrancisIre> lambdabot, doesn't like me as much. =(
18:59:28 <AntonFrancisIre> Ohh
18:59:34 <Tekmo> lol
18:59:41 <Tekmo> Apparently that sequence was too difficult
18:59:44 <AntonFrancisIre> @oeis 2 5 2
18:59:49 <lispy> doomlord: update would be forced to do IO in that case
18:59:53 <AntonFrancisIre> What is it anyway?
18:59:55 <lambdabot>  Lpf(n): least prime dividing n (with a(1)=1).
18:59:55 <lambdabot>  [1,2,3,2,5,2,7,2,3,2,11,2,13,2,3,2,17,2,19,2,3,2,23,2,5,2,3,2,29,2,31,2,3,2,...
19:00:03 <Tekmo> Well, it doesn't have to be in IO to be sequenced
19:00:30 <Tekmo> Do I have to break out the free monad lecture?
19:00:32 <doomlord> ok my understanding of that is still hazy. i would have thought you could read and write a pure value
19:00:35 <mm_freak> isn't there a name for those primes?
19:00:48 <mm_freak> 2^x + 1
19:00:55 <Tekmo> I think so
19:01:01 <rwbarton> fermat primes
19:01:09 <lispy> doomlord: You can have something like World -> Controller -> World and have it be pure
19:01:23 <mm_freak> rwbarton: nope, fermat primes are of the form 2^(2^x) + 1
19:01:25 <doomlord> yes thats where the bulk of "update" would be done
19:01:25 <lispy> doomlord: But, if you want to readIORef or writeIORef it has to happen in IO
19:01:34 <mm_freak> so they are just a special case
19:01:40 <rwbarton> you'd think that but no
19:01:48 <Tekmo> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
19:01:55 <doomlord> but can that just be done once in the "IO update-render loop"
19:02:03 <doomlord> and passed the pure function
19:02:04 <rwbarton> if n is not a power of 2 then 2^n + 1 is never prime
19:02:05 <Tekmo> The extreme case is a free monad
19:02:19 <Tekmo> Where you define a functor that encompasses all interactions with the OpenGL API
19:02:32 <mm_freak> rwbarton: oh, ok
19:02:36 <Tekmo> This just generates a pure syntax tree the library then evaluates with the OpenGL backend
19:02:52 <lispy> doomlord: you need an "interpreter" for that. Which is how I think of the free-monad approach in this case
19:02:53 <rwbarton> any x^n + 1 factors as (x + 1) (x^(n-1) - x^(n-1) + ... - x + 1) when n is odd
19:03:13 <doomlord> forever ....      writeIORef (controllers,..... )  ...        writeIORef (updateWorld  readIORef (...????)   controllers  )      renderWorld   (readIORef .... )
19:04:21 <danharaj> :k (,)
19:04:23 <lambdabot> * -> * -> *
19:04:30 <danharaj> how do I get a kind polymorphic (,)?
19:04:35 <danharaj> is that possible?
19:04:37 <Tekmo> You type it out
19:04:37 <mm_freak> rwbarton: that alone wouldn't be sufficient as a proof, because it only proves that 2^(2x + 1) + 1 is never prime
19:05:02 <rwbarton> apply to x = 2^r where r is the even part of n
19:05:56 <doomlord> i give up :)  cut and paste what monadius does perhaps
19:06:04 <mm_freak> ok, i just read the proof
19:07:58 <lispy> doomlord: I think the logical leap for your use case is how to get the callbacks to feed into your update :: World -> Controller -> World model.
19:08:39 <lispy> doomlord: For that, I think you should look at FRP. If I were you, reactive-banana is the FRP implementation I would look at first.
19:08:54 <lispy> doomlord: But you could do something simpler than FRP
19:09:06 <dcb> anyone willing to critique a SQL parser I wrote (using Parsec)?  I'm new to haskell, I would appreciate design suggestions/validation
19:09:33 <doomlord> priority is just getting any old update: render going :) refinitement of frame-compensation later
19:09:39 <Tekmo> dcb: I'll critique it
19:09:43 <lispy> doomlord: Manage some state for the Controller, and then have some IO look that looks up that state and passes it to your update :: World -> Conroller -> World function (which can now be pure)
19:10:29 <doomlord> yeah controller just needs to be a controller abstraction, filled in by the 'update-render-loop'
19:10:32 <dcb> Tekmo:  Thanks, i'll put it on hpaste shortly
19:10:42 <lispy> doomlord: figure out what the minimal amount of IO is, write that as general case loop that takes its body as pure code parameterized over the stuff you fetch from IO
19:11:25 <doomlord> yes
19:11:29 <hpaste> dcb pasted “SQL Parser” at http://hpaste.org/76009
19:11:58 <doomlord> ok reading up on FRP it might be illuminating for me
19:12:00 <Tekmo> doomlord: I highly recommend learning about free monads and free monad transformers
19:12:15 <doomlord> 'monad transformers' eek, ok
19:12:20 <Tekmo> here
19:12:23 <Tekmo> http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
19:12:25 <Tekmo> Just read that
19:12:30 <Tekmo> It's about ordinary free monads
19:12:55 <doomlord> i would like to see how gui's etc are done in haskell-land..
19:14:06 <lispy> doomlord: I think FRP and free monads are more theory than you NEED to have a pure update function, but both of them have the potential to lead you to something nice
19:14:43 <doomlord> i think i'll understand it a lot better if i build a simple case myself then extend it..
19:14:57 <tac-tics> I haven't studied free monads too much, but they seem pretty amazing
19:15:08 <Lutin`> doomlord: I quite like wxhaskell
19:15:39 <Tekmo> dcb: I don't believe I'll be able to help you much.  I'm not familiar with Parsec's more advanced features.  However, it looks quite well done.
19:15:48 <doomlord> with IORef, IO ... is it essentially possible to just split code up into pure functoins and impure bits that just look like imperative code
19:16:07 <danharaj> :k "promoted"
19:16:09 <lambdabot> parse error on input `"'
19:16:17 <danharaj> come on lambdabot, get with the times :[
19:16:53 <Tekmo> doomlord: Yes.  That is what free monad transformers do
19:17:00 <Tekmo> doomlord: They mix pure bits with impure bits
19:17:18 <dmwit> You don't need free monads to separate your pure and impure code.
19:17:30 <dcb> Tekmo:  Thanks, I appreciate the effort
19:17:35 <dmwit> In fact, I'm a bit puzzled that you'd mention them at all, as the basics of purity separation are quite simple in comparison.
19:17:44 <lispy> doomlord: you can have a function like doGameLoop :: (World -> Controller -> World) -> IO (), where doGameLoop update = do keyboard <- readIORef keyref; world <- readIORef w; update world keyboard
19:17:55 <Tekmo> dmwit: Yes, but you end up writing out the free monad transformer by hand
19:18:03 <dmwit> [citation needed]
19:18:10 <Tekmo> dmwit: Every library that I've seen do this
19:18:19 <Tekmo> Example
19:18:28 <Tekmo> Every iteratee library
19:18:45 <doomlord> lispy: that last line looks more like what i had in my head, would render go in there too ?
19:18:55 <lispy> doomlord: Don't take that too literally. I should have been more like, let w' = update world controller; writeIORef w world
19:19:00 <dcb> Tekmo:  I do have one question you may be able to help with though- is the normal Haskell organization to have data types (such as the AST types) and functions in the same file (such as the parsing functions)? Or is it better to split them into namespaced modules?
19:19:22 <lispy> doomlord: Yes, it certainly could
19:19:23 <doomlord> doGameLoop :: (World->Ctrl->World)->(World->Viewport ->  IO () )   -> IO ()
19:19:32 <doomlord> doGameLoop updateFunc  renderFunc ...
19:19:46 <jmcarthur> more modularity is "better", but haskell doesn't always make that as convenient as it could be
19:19:48 <Springwight> Is anyone interested in reading my O(1) worst case Queue data structure? I think it's a novel take.
19:19:48 <lispy> doomlord: This is the typical, "functional code is inside-out imperative code". You'er passing in the loop body.
19:19:49 <doomlord> ok paraphrasing
19:19:50 <Springwight> http://goo.gl/XnysH
19:19:59 <dmwit> (Almost) every presentation I've seen about free monads seem to just be introducing one unnecessary layer of indirection.
19:20:10 <Springwight> You can skim it. It's a long article.
19:20:12 <doomlord> that side of thing , passing loop body etc, i'm sold on that concept
19:20:15 <Springwight> *reading about
19:20:22 <doomlord> map > for (..)
19:20:33 <Tekmo> dcb: There is only one practical consequence of file organization, which is that namespacing (using the module system) only has file-level granularity.  So if you have data types that share similar names that you want to namespace then you have to put them in separate files.  However, other than that it's perfectly fine to put common functions on a type alongside the type
19:21:06 <Tekmo> dcb: So when I define parsers, I too put the parsers in the same file as the types they parse
19:21:08 <Springwight> It has log*n levels!!
19:21:14 <Springwight> I've always wanted to write something involving log*n
19:21:24 <Springwight> In any way shape or form
19:21:24 <jmcarthur> dcb: my favorite is to put the type and its primitives in one file and then in another re-export all that along with extra stuff that can just be described in terms of the primitives
19:21:30 <doomlord> world <- readIORef w ; let w' = update world controller ; writeIORef w w'  .... that's making sense to me
19:21:52 <Lutin`> Springwight: log n or log n * n
19:21:57 <Tekmo> dmwit: He's already introducing a layer of indirection by defining his World -> Controller -> World representation
19:21:59 <jmcarthur> dcb: the former being called something like "Foo.Internal" and the latter being just "Foo"
19:22:03 <doomlord> can I skip FRP and just do that
19:22:04 <Springwight> log*n
19:22:09 <Springwight> the iterated logarithm
19:22:16 <lispy> doomlord: right, you're just using the state capability of IO to store the world between calls. You could even return it and pass it back in instead of using an IORef
19:22:21 <dcb> Tekmo: OK, thanks
19:22:26 <tac-tics> It always seemed like it would be inefficient to naively do that kind of thing in Haskell
19:22:28 <Springwight> Log-star n
19:22:28 <Tekmo> dcb: You're welcome
19:22:30 <tac-tics> With an IORef World
19:22:36 <Lutin`> Ohohoh
19:22:38 <Lutin`> Interesting
19:22:39 <lispy> doomlord: yes, yes you can skip FRP. Read it again when you're curious if it would simplify your design
19:22:40 <doomlord> right up until this conversation, i didn't know IORef existed
19:22:41 <dcb> jmcarthur: That sounds interesting, I may play around with that organization
19:23:03 <tac-tics> You have one mutable variable and a huge, immutable game state. In a C or Java application, it would be a lot of small mutable variables
19:23:23 <tac-tics> and primitive or near-primitive immutable values
19:23:28 <doomlord> i'm happy with the idea of a world object
19:23:32 <doomlord> world variable
19:23:38 <lispy> doGameLoop :: World -> WouldUpdateFunc -> RenderFunc -> IO World -- this would be a totally legit type
19:23:40 <Tekmo> dcb: I forgot to mention another consequence of file organization, which is cyclic dependencies
19:23:49 <jmcarthur> what's the point of using an IORef at all? couldn't you just pass the world around?
19:23:57 <Tekmo> dcb: THe compiler doesn't allow cyclic imports, so that can sometimes impact how you organize your file import hierarchy
19:24:19 <Tekmo> dcb: This tends to bite you if you tend to start splitting your project into a lot of small files
19:24:26 <Tekmo> dcb: So don't go overkill when organizing your code
19:24:40 <tac-tics> It would be nice if the file wasn't the unit of compilation.
19:24:44 <jmcarthur> Tekmo: this property of haskell/ghc kind of sucks :(
19:24:50 <Tekmo> jmcarthur: I agree
19:24:54 <danharaj> Can I have constraints inside a type family instance or do I need to use associated type families to put the constraints in the class instance?
19:25:01 <lispy> tac-tics: yeah, whenever I use records I wish I could have local modules within files
19:25:14 <dcb> Huh, ok definitely something to keep in mind
19:25:19 <doomlord> jmcarthur,  would forever doGameLoop with that signature acheive that?
19:25:23 <danharaj> You can have cyclic imports in GHC
19:25:39 <danharaj> You just need to write a few files to break cycles.
19:25:46 <lispy> doomlord: forever isn't the right thing, but you could use foldM
19:25:52 <jmcarthur> doomlord: forever doesn't pass the state back in. you would need something like Tekmo's foreverK
19:26:03 <lispy> :t foldM
19:26:04 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
19:26:15 <Tekmo> Wouldn't StateT WorldState IO be better?
19:26:22 <lispy> [b] could be an infinite stream of events
19:26:24 <doomlord> folding an infinite sequence?
19:26:29 <jmcarthur> foreverK :: (a -> m a) -> m b    -- iirc
19:26:57 <Tekmo> doomlord: "StateT WorldState IO r" is a newtype around: WorldState -> IO (WorldState, r)
19:27:02 <jmcarthur> i've seen very few uses of StateT that seem practical
19:27:12 <Tekmo> Really?
19:27:19 <Tekmo> Not even parsers?
19:27:29 <jmcarthur> yeah. everytime i've ever used it i regretted it.
19:27:31 <doomlord> ah do i need a "state monad", or can i do without it
19:27:36 <jmcarthur> well, parsers have a specific abstraction to expose
19:27:43 <Tekmo> I mean, I can understand that it makes code harder to reason about
19:27:46 <jmcarthur> i mean where you actually expose a stateful thing of some sort
19:28:01 <Tekmo> jmcarthur: Because there are fewer equations StateT permits
19:28:01 <jmcarthur> get this, put that, modify those
19:28:19 <jmcarthur> i think that is a contributor, but not the only factor
19:28:49 <Tekmo> jmcarthur: My rule of thumb is that if the code I'm writing is isomorphic to State or StateT, I use them
19:28:56 <jmcarthur> i find the idea of a "state" to be just a complication anyway, at least when applied to a big program like games and such
19:29:06 <lispy> > foldM (\a b -> return (a+b)) 0 [1..10] :: Maybe Int
19:29:08 <lambdabot>   Just 55
19:29:27 <jmcarthur> i use mapAccum* and such instead of mapM, most of the time, for example
19:29:46 <Tekmo> jmcarthur: So are you saying that you prefer explicit state passing?
19:29:48 <jmcarthur> because the "state" is normally just local to one function anyway
19:29:48 <lispy> > take 10 (foldM (\a b -> return (a+b)) 0 [1..10] ::  [Int])
19:29:49 <lambdabot>   [55]
19:29:50 <doomlord> "monadius" seems to use IORef
19:29:59 <jmcarthur> no, i wouldn't say that
19:30:07 <jmcarthur> i would say i prefer nicer abstractions
19:30:08 <Tekmo> jmcarthur: Or just factoring out the stateful parts?
19:30:18 <jmcarthur> state is just not nice to work with
19:30:36 <danharaj> state is kind of nice with the lens package
19:30:49 <jmcarthur> it's okay...
19:30:52 <Tekmo> I mean, it depends on the project
19:31:05 <Tekmo> Like, none of my projects use state because they are just data processing pipelines
19:31:11 <Tekmo> But I could see how a game might want state
19:31:17 <jmcarthur> i've done lots of projects that i formerly thought state would be a perfect fit for and then ended up changing my mind every time
19:31:25 <jmcarthur> even games
19:31:28 <Lutin`> Or just abstract your game enough to switch between these?
19:31:35 <rwbarton> I think I use StateT on a much smaller scale
19:31:36 <doomlord> i'm happy with the idea of world' = update world
19:31:38 <Tekmo> What do you think is the appropriate abstraction for games?
19:31:42 <rwbarton> and I use it frequently
19:31:50 <Tekmo> Something like FRP?
19:31:51 <hpaste> “Ertugrul Söylemez” pasted “Pollard p-1 in Haskell” at http://hpaste.org/76010
19:32:05 <rwbarton> StateT s [] is nice for some kinds of backtracking search
19:32:06 <doomlord> i like the doGameLoop suggestion by lispy above
19:32:08 <jmcarthur> "something like" FRP was a good qualification
19:32:31 <doomlord> a loop that takes updateWorld / renderWorld functions
19:32:36 <Tekmo> Do you feel that any of the FRP frameworks have found that right abstraction yet?
19:32:38 <jmcarthur> i don't feel like FRP is quite there yet, either. it still doesn't quite feel natural to use
19:32:44 <Tekmo> Ok, that answers my question
19:32:45 <Tekmo> :)
19:32:52 <Tekmo> Yeah, I got the same feeling, too
19:33:01 <Tekmo> I feel that they are missing something really elegant
19:33:19 <lispy> doomlord: that factorization is really common in lots of "real" haskell programs, FWIW
19:33:40 <jmcarthur> my suspicion is that there is simply some undiscovered area of mathematics that would just "solve" the frp problem
19:33:59 <Lutin`> And I guess if you did like
19:34:01 <Tekmo> Well, I think the big problem is that (most of them) are "applicative"
19:34:06 <startling> jmcarthur: heh
19:34:07 <Tekmo> rather than compositional
19:34:21 <Tekmo> and I don't buy that the arrow ones are comopsitional
19:34:24 <doomlord> anyone here familiar with the "monadius" code? it looks freaky
19:34:33 <rwbarton> has anyone played around with cloud haskell?
19:34:39 <lispy> doomlord: No, do you have a link?
19:34:40 <jmcarthur> i like the simplicity of the classical models of frp, myself
19:34:47 <Tekmo> Time based?
19:34:53 <jmcarthur> they are both time based
19:34:53 <rwbarton> I'm trying to figure out how to write a simple little program with distributed-process-simplelocalnet
19:34:57 <Tekmo> I always preferred event-based, but I'm biased because of pipes
19:35:03 <doomlord> http://hackage.haskell.org/package/Monadius
19:35:17 <doomlord> its a haskell game based on "gradius", side scrolling shooter
19:35:22 <Tekmo> I never got why they care so much about time
19:35:32 <jmcarthur> i don't think continuous frp is at odds with convenient handling of events
19:35:50 <Tekmo> Well, I'd prefer to see time as an event
19:35:55 <jmcarthur> continuity is a propery that makes it so much easier to reason about
19:35:57 <doomlord> tick events sure
19:36:05 <Lutin`> My issue is I like to be able to go backwards very easily
19:36:06 <doomlord> i prefer timesteps
19:36:19 <doomlord> rather than pretending discrete is continuous
19:36:30 <Lutin`> Start at one state and given inputs I can go backwards as well or something
19:36:31 <Tekmo> For example
19:36:44 <Tekmo> for a game I'd like to react to frame refreshes, mouse clicks, and unit actions
19:36:48 <Tekmo> not time, per se
19:36:50 <lispy> I think pretending that Double/Float is isomorphic to Real numbers is a problem waiting to happen.
19:37:10 <jmcarthur> Tekmo: i think "time" vs. "events" is a false dichotomy
19:37:17 <Tekmo> jmcarthur: Yeah, I suppose so
19:37:17 <doomlord> a classic game loop needs to be based primarily on rendering hence frame refreshes
19:37:18 <Lutin`> jmcarthur: I agree
19:37:19 <lispy> Specifically, numerical issues
19:37:23 <rwbarton> what is a frame refresh
19:37:26 <Lutin`> They really can go hand in hand
19:37:47 <doomlord> somewhere in the main loop there will be some blocking on a swapbuffers
19:37:52 <rwbarton> if you have a real-time game don't you want things to happen at the same speed whether you are doing the logic at 30 FPS or 60 FPS?
19:37:57 <jmcarthur> Tekmo: in the classical models of frp, actually, events typically get their own type
19:37:58 <doomlord> polling video frame
19:38:12 <doomlord> the constant logic speed is done by running N updates
19:38:16 <rwbarton> surely you are modeling a continuous, time-varying system
19:38:22 <doomlord> you time the rendering loop, then you run some number of updates
19:38:24 <Tekmo> jmcarthur: The reason I'm biased towards events is because I sometimes wonder if I could implement FRP using a pipe-like abstraction
19:38:26 <jmcarthur> Tekmo: with a precise model and a well-defined interaction with continuous behaviors
19:38:52 <doomlord> while (gameTime < actualTime)  { update(state); gameTime+= timestep; }
19:38:55 <jmcarthur> Tekmo: i don't find, for example, "the current position of the sun" to be a very sensible thing to say in terms of events alone
19:39:06 <Tekmo> jmcarthur: Yeah, that's true
19:39:14 <Tekmo> jmcarthur: But that raises an interesting point
19:39:20 <jmcarthur> Tekmo: with classical frp, "the position of the sun at the time that event A occurs" is perfectly natural to describe
19:39:22 <rwbarton> of course for some games there is no real-time aspect
19:39:27 <Tekmo> jmcarthur: Which is that maybe FRP should be more concerned with continuous variables of all sorts, not just time
19:39:32 <Tekmo> jmcarthur: i.e. time should not be central
19:39:36 <jmcarthur> Tekmo: right, this has been explored
19:39:36 <doomlord> while (1) {   render();   t1=getrealtime();   while (gameTime<t1) { update(); gameTime+=timestep; }
19:39:46 <Tekmo> jmcarthur: Which libraries try that approach?
19:39:48 <danharaj> rwbarton: a solution is to model things as state machines that take a time increment input dt. there are systems where the time step can cause a big difference in program meaning so it's good to make it explicit.
19:39:52 <doomlord> so i basically want to turn that into haskel
19:39:55 <lispy> rwbarton: yes, but if you have a physics simulation in there you need the dt of each physics tick to be the same. Because the error in the integral calculation depends on the time step.
19:40:13 <doomlord> you might render at fractional time
19:40:16 <jmcarthur> Tekmo: none that i know of specifically. i only know of some little research projects here and there
19:40:18 <rwbarton> I would prefer to try to push that logic into the implementation layer somehow
19:40:24 <doomlord> to get smooth movement at non-integer subidivisions
19:40:26 <lispy> rwbarton: so even if you can do more physics updates per frame on the faster computer you need to chunk the time up so that dt is the same as on the slow computer
19:40:26 <jmcarthur> lemme try to find a blog post
19:40:57 <Xezlec> Hey, how would I install a package from hackage on a computer without internet access?  Will cabal do that?
19:41:12 <Tekmo> You download the tarball
19:41:20 <rwbarton> yes, you can cabal install whatever.tar.gz
19:41:21 <Tekmo> use a flash drive to transfer it
19:41:32 <Tekmo> then cd into the unzipped directory and type "cabal install"
19:41:35 <lispy> rwbarton: Right, so as I understand it FRP is compatible with this custome chunking of time, but the implementation of FRP needs to support it
19:41:39 <danharaj> I've recently been playing with edwardk's machines package because it's a spiffy generalization in some ways of MonadPrompt and makes for fun ways of structuring demand-driven updates.
19:41:44 <rwbarton> download all the tarball's dependencies too :)
19:41:51 <rwbarton> have fun with that bit...
19:41:55 <jmcarthur> Tekmo: some thoughts from sinelaw:  http://noamlewis.wordpress.com/2010/06/10/axiomatic-basis-for-frp/ and http://noamlewis.wordpress.com/2010/06/13/axioms-for-frp-discussing-insensitivity/
19:42:03 <Tekmo> jmcarthur: Thanks
19:42:19 <Xezlec> Cool, thanks.
19:42:50 <jmcarthur> Tekmo: the second one, in particular, makes an attempt to generalize the time domain a bit such that it encapsulates both continuous time and events
19:42:58 <jmcarthur> via measure theory
19:43:12 <doomlord> while(1) { t0=getrealtime();   render(state,  t0-state.time/* sub frame interpolation factor*/);   while (state.time<t0) { update(state); state.time+=dt; } }
19:43:13 <lispy> rwbarton: I was posting this earlier that talks about the time chunking with reactive-banana as the implementation: http://stackoverflow.com/questions/12685430/how-to-implement-a-game-loop-in-reactive-banana/
19:44:37 <jmcarthur> doomlord: a big idea in continuous time frp is that you shouldn't have to care about "steps" or "frames" or any of that. an implementation could, for example, use binary search along the time line to approximate each frame without the loss of precision that would come about from choosing some arbitrary delta between frames
19:44:55 <doomlord> jmcarthur, i think frp tries to solve a different problem then
19:45:10 <jmcarthur> there are many problems that frp allegedly is supposed to solve
19:45:13 <doomlord> game simulation is definitely best handled with steps
19:45:25 <jmcarthur> have any justification for that?
19:45:26 <Tekmo> jmcarthur: But I could I do that same search along any variable other than time?
19:45:36 <jmcarthur> Tekmo: i see no fundamental reason you couldn't
19:46:18 <jmcarthur> time is, after all, just an abstraction that has certain properties. this time we call time surely isn't the only match for the model
19:46:19 <doomlord> consistency; the simulation depends on the steps - you want the same behaviour between machines that render at different speeds. Also, games are designed to be limited by rendering time, not update time, ideally.
19:46:29 <lispy> jmcarthur: For games that compute an integral the justification is that the error in the integral depends on the time delta.
19:46:47 <doomlord> gaming devices have the bulk of their power in rendering. the rendering should never be waiting for update. the graphics chips should be maxed out
19:46:55 <rwbarton> but maybe you can get much smaller errors by choosing variable steps intelligently (and deterministically), for example
19:47:02 <doomlord> exactly as lispy says
19:47:18 <startling> if I want a TH Type to refer to a type that already exists, do I use VarT?
19:47:22 <rwbarton> like solve for the time the ball is going to hit the wall and put your time step there
19:47:40 <doomlord> you woulnd't use OS threads for each object or anything like that :)
19:47:52 <rwbarton> ideally the FRP layer could do this for you
19:47:55 <lispy> rwbarton: you could do that using ray casting, and you'd end up with what engineering simulations do, but as I understand it, it's not suitable for real-time simulation
19:47:57 <startling> doomlord: each bullet gets its own thread!
19:48:07 <startling> every atom!
19:48:23 <doomlord> i think FRP sounds like its solving a more complex problem than is needed for games.
19:48:32 <Tekmo> doomlord: No, FRP sounds very appropriate for games
19:48:37 <Tekmo> If it were solved "right"
19:49:00 <cmccann> startling, I tried doing that once just to see what would happen
19:49:01 <doomlord> the signature presented by lispy doGameLoop ... above is the right way I think
19:49:07 <cmccann> things fell over when I added a particle engine
19:49:07 <cmccann> heh
19:49:14 <startling> cmccann: haha
19:49:40 <startling> we get people in #python trying to do these things every once in a while. :/
19:49:57 <cmccann> pf
19:50:17 <Tekmo> jmcarthur: This might sound strange to you, but have you every thought that the fact that FRP implementations complain about space leaks suggest that they got it "wrong"?
19:50:26 <doomlord> monadius code:-
19:50:27 <cmccann> in python I just invented baroque hacks to get fancy coroutines and fake cooperative multithreading using generators and whatnot
19:50:31 <doomlord> mainProc :: GlobalVariables -> IORef Recorder -> IORef [Key] -> IO Scene
19:50:44 <jmcarthur> Tekmo: they are solely the fault of the implementations
19:50:58 <jmcarthur> Tekmo: there are two common sources of these space leaks. one is easier to fix than the other
19:51:17 <doomlord> -- | Scene is something that does some IO,
19:51:18 <doomlord> -- then returns the Scene that are to be executed in next frame.
19:51:18 <doomlord> newtype Scene = Scene (IO Scene)
19:51:22 <jmcarthur> Tekmo: the easier one is what some call "time leaks" which is just some information being accumulated over time without forcing it appropriately
19:51:23 <Tekmo> jmcarthur: Is there a layman's explanation of how they arise?
19:51:25 <doomlord> this sounds quite far off what i wanted
19:51:54 <doomlord> not going to cut/paste monadius, rather i want to implemnt lispy's suggestion
19:52:03 <jmcarthur> trying to think of a good way to explain the harder one...
19:52:14 <lispy> newtype Scene = Scene { :-> :: IO Scene } -- now you (:->) :: Scene -> IO Scene
19:52:25 <lispy> (you may need some parens in there)
19:52:40 <jmcarthur> Tekmo: the harder one tends to manifest itself in the form of a function of time that you are modifying over time
19:52:42 <lispy> Or you can use a different operator name too
19:52:57 <jmcarthur> Tekmo: common evaluation models of functional languages makes the naive approach to this difficult
19:53:04 <jmcarthur> Tekmo: since they can't evaluate under lambdas
19:53:24 <danharaj> http://hpaste.org/76011
19:53:26 <Tekmo> jmcarthur: Well, wouldn't that be hard in any language?
19:53:28 <jmcarthur> Tekmo: so you end up having a function calling a function calling a function calling a function, etc....
19:53:38 <Tekmo> jmcarthur: You'd have to precompute all solutions given each potential argument?
19:53:52 <jmcarthur> Tekmo: there exist evaluation strategies that solve this problem, even when implemented naively
19:53:59 <Lutin`> ex: you have (1+2+3+4+...) building up
19:54:03 <danharaj> I want to create a kind Binding that is inhabited by terms of the form Bind (symbol) (type). Is this possible? GHC hates me.
19:54:08 <rwbarton> danharaj: what's Symbol?
19:54:09 <lispy> jmcarthur: does rewriting solve it?
19:54:16 <danharaj> rwbarton: the promotion of String
19:54:39 <jmcarthur> Tekmo: the existence of those evaluation strategies hints at the existence of an implementation that doesn't rely on them, since all you'd have to do in the dumbest possible implementation is implement an interpreter for another language
19:54:51 <rwbarton> well surely the type of a function argument has to have kind *
19:54:53 <jmcarthur> Tekmo: "rewriting" could be seen as part of the evaluation strategy
19:55:05 <Lutin`> Given a smart enough compiler...etc
19:55:09 <rwbarton> what sort of thing could you pass to Bind
19:55:21 <danharaj> rwbarton: yes, but I don't care about the data-level signature, I care about the type-level signature after promotion :P
19:55:38 <rwbarton> hmm
19:55:41 <jmcarthur> Tekmo: "completely lazy evaluation" and "optimal evaluation" are the two strategies known to solve the problem. the latter has enough bookkeeping overhead that there is no asymptotic improvement though, but the former "just works"
19:55:44 <rwbarton> it still looks ill-kinded
19:56:01 <danharaj> Does it?
19:56:01 <Tekmo> jmcarthur: Do you mean they are "simulating" another evaluation strategy?
19:56:09 <jmcarthur> nope
19:56:11 <rwbarton> also this is some sort of existential type?
19:56:19 <rwbarton> I didn't think you could promote those anyways
19:56:27 <rwbarton> "what are you really trying to do"
19:56:38 <jmcarthur> Tekmo: completely lazy evaluation basically gives you what some might call partial evaluation, except that it does so lazily, at runtime
19:56:54 <danharaj> Make a kind Binding whose inhabitants are constructed by Bind :: Symbol -> * -> Binding
19:57:35 <rwbarton> so basically '(Symbol,*)
19:57:51 <jmcarthur> Tekmo: so if you dynamically create a function (f . g), when you use it the composition will be evaluated only once rather than every time, and so will various other things in the representations of f and g
19:57:51 <cornihilio> haha I thought I was going crazy, I didn't realize that takeTill in attoparsec was spelled till
19:57:53 <danharaj> I can't get (Symbol, *) to kind check.
19:58:22 <lispy> jmcarthur: I'm having a hard time finding complete laziness on google. Any links?
19:58:27 <jmcarthur> Tekmo: this is even sufficient to pass the "tower of interpreters test"
19:58:41 <jmcarthur> lispy: there are two "best" papers on it...
19:58:52 * ski . o O ( `type family NatTransf k :: k -> k -> *; type instance NatTransf * a b = a -> b; type instance NatTransf (k0 -> k1) f g = forall a :: k0. NatTransf (f a) (g a)' )
19:59:15 <jmcarthur> lispy: Michael Thyer's thesis "Lazy Specialization" and Sinot's "A Natural Semantics for Completely Lazy Evaluation" (I may have gotten that title slightly wrong)
19:59:18 <ski> jmcarthur : what is that test ?
19:59:24 <lispy> jmcarthur: thanks
19:59:33 <rwbarton> ski: I don't think a type synonym can expand to a polytype, but if you use a newtype wrapper that will work
20:00:18 <lispy> jmcarthur: this is from 2003/4. Does anyone actually work on this or put it into a Haskell-like language?
20:00:18 <jmcarthur> ski: start with a base language with a completely lazy interpreter. now write an interpreter in the base language. now write an interpreter in that language. repeat as many times as you want. finally, run some program using the topmost interpreter you wrote
20:00:29 <ski> rwbarton : can i have a kind as an argument of a type ?
20:00:42 <rwbarton> oh
20:00:53 <jmcarthur> ski: to pass the test, each interpreter must only add a constant overhead to the entire runtime of the program
20:00:57 <rwbarton> delete k and the arguments that take the place of k
20:01:02 <rwbarton> if that makes sense
20:01:13 <rwbarton> that will just work, somehow
20:01:20 <jmcarthur> ski: most evaluation strategies would have each interpreter *multiply* the runtime by some factor
20:01:21 <rwbarton> without explicitly stating the kind
20:01:40 <jmcarthur> lispy: i think there was/as some work in UHC, but i haven't seen any results from it
20:01:43 <jmcarthur> *was/is
20:02:00 <danharaj> rwbarton: even when I set -XPolyKinds, :k (,) is * -> * -> *
20:02:02 <rwbarton> argh, how do I refer to the lifted version of (,)
20:02:05 <ski> rwbarton : how could `type instance NatTransf a b = ...; type instance NatTransf f g = ...' work ?
20:02:15 <lispy> jmcarthur: It seems like an interesting thing to try in GHC
20:02:16 <rwbarton> ski: I don't know but I seem to recall that it does
20:02:20 <rwbarton> let me test
20:02:29 <jmcarthur> lispy: it's tough because it requires evaluation under a lambda
20:02:33 <rwbarton> or at least, something quite like this worked
20:02:53 <ski> jmcarthur : interesting, ty
20:03:12 <jmcarthur> lispy: you would probably also want some runtime code generation, since otherwise the in-memory representation would mostly be syntax-tree-like
20:03:27 <jmcarthur> and therefore quite slow
20:03:44 <lispy> I see. So you're constantly compiling the program
20:03:52 <jmcarthur> specializing
20:04:06 <hpaste> rwbarton pasted “well it compiles” at http://hpaste.org/76012
20:04:07 <Tekmo> jmcarthur: WHen you say constant overhead, you mean not proportional to the duration of the program?
20:04:10 <rwbarton> ski: ^
20:04:13 <jmcarthur> Tekmo: right
20:04:15 <ski> rwbarton : ok, so you seem to be saying that it's possible to have `NatTransf :: forall k. k -> k -> *'
20:04:17 <Tekmo> That's crazy
20:04:23 <jmcarthur> i know! i love it
20:04:27 <rwbarton> well not necessarily *all* k
20:04:34 <rwbarton> but those k which can be built up from * and (->)
20:04:42 <jmcarthur> i've had an implementation as a hobby project off and on for a while
20:04:47 <jmcarthur> it still sucks though
20:04:53 <Tekmo> But how does that even work?
20:05:00 <Tekmo> It boggles my mind
20:05:04 <ski> rwbarton : yeah
20:05:05 <rwbarton> ski: it can at least live at several kinds simultaneously
20:05:18 <Tekmo> The implications are profound
20:05:28 <Tekmo> You could get machine-level performance with no abstraction penalty
20:05:33 <jmcarthur> yes. it's a shame it hasn't gotten more attention (even criticism!)
20:05:33 <ski> (for all `k' in a certain full subcategory)
20:05:55 <jmcarthur> *(it hasn't even received much attention in the form of criticism)
20:06:02 <lispy> From a security point of view, it sounds like it could be dangerous
20:06:07 <Tekmo> Whose thesis was it again?
20:06:20 <jmcarthur> Tekmo: machine-level performance would be a stretch, i think, unless you have a pretty awesome JIT as well
20:06:21 <archblob> hy there
20:06:25 <jmcarthur> Tekmo: Michael Thyer
20:06:30 <lispy> Tekmo: I found here, but the ftp server is not responding: http://www.cs.york.ac.uk/fp/past.php
20:06:37 <hpaste> “Ertugrul Söylemez” annotated “Pollard p-1 in Haskell” with “Improved version” at http://hpaste.org/76010#a76013
20:06:38 <ski> rwbarton> :k Transf
20:06:51 <Tekmo> jmcarthur: Well, I mean that once you reach the level of compelte laziness
20:06:51 <jmcarthur> Tekmo: see also Sinot's Natural Semantics for Completely Lazy Evaluation
20:06:59 <Tekmo> jmcarthur: You stop losing performance from abstraction
20:07:06 <jmcarthur> Tekmo: exactly. abstraction is essentially free
20:07:28 <archblob> does anyone know if haddock 2.10.0 builds on ghc 7.6.1 ? because 2.12.0 does not work
20:07:53 <jmcarthur> lispy, Tekmo: oh! also see http://thyer.name/lambda-animator/
20:08:17 <jmcarthur> it's a working implementation in an applet with visualizations
20:08:34 <jmcarthur> it also demonstrates some of the discovered difficulties using it
20:08:56 <jmcarthur> just like in haskell where laziness can bite you if you aren't always aware of it, this has even more opportunities to bite you :\
20:09:07 <rwbarton> ski, which version of ghc are you using?
20:09:27 <jmcarthur> Thyer's thesis is probably a prerequisite to really understanding that applet though
20:09:35 <Tekmo> So is the reason this isn't possible in Haskell is because you don't have access (at the language level) to reflection on the function implementation?
20:09:37 <ski> rwbarton : not one with `PolyKinds'
20:09:49 <Nereid> huh.
20:09:54 <Nereid> I just learned something.
20:10:05 <jmcarthur> Tekmo: i don't think true function reflection is necessary, but you end up needing something similar at least
20:10:06 <Nereid> apparently you can have multiple qualified imports with the same qualified name.
20:10:12 <Nereid> and it'll dump everything into that new namespace.
20:10:14 * ski . o O ( "Implementing Bit-addressing with Specialization" by Scott Draves in 1997 at <http://www.cs.cmu.edu/~spot/bit-addr/bit-addr.html> )
20:10:15 <lispy> jmcarthur: thanks
20:10:16 <jmcarthur> Nereid: yes, i use it all the time. it's awesome :)
20:10:16 <rwbarton> hmm
20:10:21 <Nereid> yeah.
20:10:29 <rwbarton> Transf :: (AnyK -> AnyK) -> (AnyK -> AnyK) -> *
20:10:38 <ski> hm, ok
20:10:45 <rwbarton> but it doesn't seem to quite work
20:10:50 <ski> sounds a bit dynamically typed
20:10:54 <Nereid> jmcarthur: my case, Data.Text and Data.Text.IO both into T
20:11:10 <Tekmo> jmcarthur: Actually, maybe you could simulate this in Haskell
20:11:16 <Tekmo> jmcarthur: By not using Haskell values directly
20:11:17 <rwbarton> oh, I just had to help it out a bit
20:11:18 <jmcarthur> Tekmo: it's possible in haskell, to be clear. it's just that ghc's runtime representation isn't in a great state to adapt for it
20:11:25 <Tekmo> jmcarthur: Instead, simulating a representation of something using a data structure
20:11:26 <ski> (or possibly those are in place of skolems)
20:11:42 <jmcarthur> Tekmo: yeah, the basis of my implementation is lazy substitution using unsafeInterleaveIO
20:11:54 <jmcarthur> well, that's one of my implementations
20:12:10 <Tekmo> jmcarthur: Why is unsafeInterleaveIO necessary?
20:12:13 <jmcarthur> normal pure lazy evaluation over an ast with memoization is another
20:12:25 <Tekmo> Yeah, I was thinking of the latter approach
20:12:37 <jmcarthur> Tekmo: part of the big idea is that substitutions don't immediately start copying the function body before it has been reduced at all
20:13:22 <Tekmo> jmcarthur: So the substitutions themselves are lazy?
20:13:29 <jmcarthur> yes
20:14:06 <Tekmo> jmcarthur: So I assume the tricky part is defining heuristics for when to prematurely evaluate function bodies
20:14:10 <jmcarthur> and lazier than can be expressed in pure haskell without at least some memo tables or mutation
20:14:31 <jmcarthur> well, that could get you some constant speedup i guess
20:14:45 <jmcarthur> but it's not necessary for the core properties of the interpreter
20:14:55 <hpaste> rwbarton annotated “well it compiles” with “well it compiles (annotation)” at http://hpaste.org/76012#a76014
20:15:13 <Tekmo> jmcarthur: Oh yeah, it's completely lazy
20:15:15 <rwbarton> ski: a demo, though I don't know why it needs so much help
20:15:49 <hpaste> rwbarton annotated “well it compiles” with “well it compiles (annotation) (annotation)” at http://hpaste.org/76012#a76015
20:16:06 <rwbarton> I can't even skip writerToStateTrans3
20:16:22 <YayMe> @src (.)
20:16:23 <lambdabot> (f . g) x = f (g x)
20:16:23 <lambdabot> NB: In lambdabot,  (.) = fmap
20:16:33 <rwbarton> the definition of writerToStateTrans3 does not type check on the RHS of the definition for writerToStateTrans4
20:17:05 <startling> can I turn some TH declaration into a string somehow? I'm not seeing where this error is coming from
20:17:09 * ski . o O ( "Type Specialisation for the Lambda-calculus; or, A New Paradigm for Partial Evaluation based on Type Inference" by John Hughes at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.30.4903> (".. This leads to optimal specialisation, that is, complete removal of a layer of interpretation --- the first time this has been achieved for a typed higher-order language. .." <http://www.cse.chalmers.se/~rjmh/pubs.htm>) )
20:17:14 <startling> a string of haskell code, I mean
20:17:50 <Tekmo> jmcarthur: So I couldn't download the thesis either, but my intuition from what you described is that the reason the overhead is constant is by virtue of memoization.  Every time you pass through an interpreter its behavior for any unique code path only gets traversed once
20:17:59 <BMeph> jmcarthur, Tekmo: I prefer the phrase, "It's lazy, all the way down..." ;)
20:18:51 <jmcarthur> Tekmo: memo tables are only required to avoid substituting into the same part of a graph multiple times. they aren't used to memoize the result of an expression
20:18:51 <Tekmo> jmcarthur: So the "constant" in the constant overhead is merely the size of all code paths that interpreter might traverse
20:19:07 <jmcarthur> nope, i would not say that sounds right
20:19:45 <jmcarthur> there is no automatic memoization, just like there is none in ghc
20:20:24 <Tekmo> jmcarthur: Then perhaps I'm using the wrong word, but my mental image is that
20:20:37 <jmcarthur> Tekmo: what you said could possibly be true if you are just describing thunks
20:20:38 <Tekmo> jmcarthur: An interpreter's function carries a pointer to some lower-level interpreter's function
20:20:41 <lispy> how is specialization different than memoization?
20:20:54 <Tekmo> jmcarthur: and when you access that function, it just redirects the original pointer to the lower-level one
20:21:06 <ski> rwbarton : interesting
20:21:11 <jmcarthur> lispy: consider specialization to be the same thing as evaluating a thunk. if you call that memoization, then so is specialization. i don't think of that as memoization, though
20:21:24 <rwbarton> pretty neat but also pretty broken at the moment :)
20:21:33 <rwbarton> probably the issue is with all the layers of "forall"
20:21:38 <rwbarton> making it difficult to infer
20:22:17 <cornihilio> hey, can someone please help me with this? I am absolutely dumbfounded: https://gist.github.com/3856385
20:22:21 <jmcarthur> Tekmo: more like the unspecialized function is simply replaced by the specialized function
20:22:32 <startling> ah, pprint <$> runQ x can be an IO String
20:22:41 <jmcarthur> Tekmo: ghc does have indirection nodes in the heap to be GCed away later, but abstractely they don't exist
20:22:45 <jmcarthur> *abstractly
20:23:03 <cornihilio> it's like it thinks that a normal statement somehow is the value to return, and not the return statement?
20:23:03 <jmcarthur> Tekmo: this could work basically the same way
20:23:17 <rwbarton> cornihilio, the type signature is wrong
20:23:23 <rwbarton> wait
20:23:27 <rwbarton> you're doing it again
20:23:27 <Eduard_Munteanu> cornihilio: PacketRaw isn't a monad
20:23:29 <startling> cornihilio: return isn't a statement
20:23:36 <rwbarton> you don't want do notation
20:23:50 <Eduard_Munteanu> Yeah, what rwbarton says.
20:24:13 <geekosaur> why do you think you need do notation there?
20:24:30 <ski> rwbarton : i also wanted to define `type family Outer k :: (* -> *) -> k -> k; type instance Outer * c a = c a; type instance Outer (k0 -> k1) c f a = Outer k1 c (f (Inner k0 c a))' and `type family Inner k :: (* -> *) -> k -> k; type instance Inner * c a = a; type instance Inner (k0 -> k1) c f a = Inner k1 c (f (Outer k0 c a))'
20:24:51 * rwbarton takes a deep breath
20:25:06 <cornihilio> Eduard_Munteanu: what do you mean?
20:25:12 <cornihilio> startling: what do you mean?
20:25:27 <otters> let o = "owl" in (o,o)
20:25:30 <ski> rwbarton : and finally `class Liftable (f :: * -> *) k (a :: k) where lift :: NatTransf k (Inner k f a) (Outer k f a)' ;)
20:25:31 <otters> ops
20:25:36 <Eduard_Munteanu> You probably want   createRawPacket contents = PacketRaw { issueCode = BL.take 12 contents }
20:25:46 <Eduard_Munteanu> Or something like that.
20:25:49 <geekosaur> cornihilio, why do you think you need return there?
20:25:59 <startling> cornihilio: return is just a function only defined for instances of Monad
20:26:07 <rwbarton> ski, I don't think "type instance Outer (k0 -> k1) c f a" <-- you can do this
20:26:13 <startling> cornihilio: but really, you don't want do notation
20:26:35 <ski> rwbarton : yeah, the different arity could be a problem
20:26:41 <lispy> jmcarthur: looking at the animator for complete laziness, I'm reminded that graphviz can be a really nice way to debug things that have a graph representation
20:27:01 <Tekmo> jmcarthur: So is the constant overhead proportional to the number of potential specializations?
20:27:29 <YayMe> @src log
20:27:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
20:27:38 <rwbarton> I better try an example
20:27:40 <jmcarthur> Tekmo: no
20:28:09 <rwbarton> Outer (* -> *) c [] = \a -> Outer * c [Inner * c a] = \a -> c [a]
20:28:19 <jmcarthur> Tekmo: ... potentially, if you aren't careful, i guess
20:28:34 <Tekmo> What I mean
20:28:40 <Tekmo> is the specializations specific to each interpreter
20:28:47 <jmcarthur> Tekmo: consider the power function that simply replicates multiplication n times
20:28:52 <Tekmo> not the combinatorial product of all paths through each level
20:29:06 <rwbarton> oh, I think I see
20:29:27 <rwbarton> Outer is somehow composing all the positive bits of my type constructor with c
20:29:29 <rwbarton> yes?
20:29:31 <startling> anyone got a TH instance example somewhere? I'm getting "instance X where ..." and I'm not sure where I'm supposed to use the name of the type
20:29:36 <jmcarthur> Tekmo: when you apply it to 10 (to mean raise its next argument to the 10th power), the representation of the power function itself could explode to 10 levels of multiplication
20:29:47 <startling> or is the name of the typeclass supposed to be a CtxQ?
20:29:49 <cornihilio> um... well I guess it'd be best if I tried to explain what I'm trying to do. I'm trying to break up a bytestring into various parts; the first few bits go into this var and the next into something else.
20:30:02 <jmcarthur> Tekmo: for loops that you don't want to be infinitely unrolled, you either have to be more clever with strictness or have an evaluator that won't unroll loops that much
20:30:48 <jmcarthur> Tekmo: the constant overhead is just the amount of time it takes to specialize the interpreter. this is roughly the same as the amount of time it takes to run each part of the interpreter
20:30:49 <Tekmo> But why would the loop be infinitely unrolled if the language is lazy?
20:30:59 <jmcarthur> Tekmo: to run each part only *once* though
20:31:05 <startling> cornihilio: PacketRaw { issueCode = BL.take 12 contents }
20:31:06 <cornihilio> I'm not really sure how to do that, since the bytestring.lazy.take function returns the taken bytestring, but the next time I run take it starts at the same place. Is there a version of take that returns the bytestring beginning at that point?
20:31:14 <jmcarthur> Tekmo: it would be *lazily* unrolled
20:31:29 <cornihilio> startling: but what if I had a second var from the next 8 bits?
20:31:29 <rwbarton> ski: /tmp/ski.hs:4:1: Number of parameters must match family declaration; expected 2 In the type synonym instance declaration for `Outer'
20:31:34 <rwbarton> as expected
20:31:48 <ski> rwbarton : `Inner (* -> * -> *) [] f = \a b -> f [a] [b]' and `Outer (* -> * -> *) [] f = \a b -> [f a b]'
20:31:48 <cornihilio> BL.take 8 contents returns the first 8 that make BL.take 12 contents
20:31:48 <startling> cornihilio: you should be using some binary parsing thing tbh
20:31:52 <jmcarthur> Tekmo: which is probably not what you want for a loop intended to run for many thousands of iterations each time it's entered
20:31:59 <startling> cornihilio: like Binary or Cereal
20:32:01 <Tekmo> jmcarthur: So the idea is that if an interpreter were a function that takes 4 arguments, then there are four specializations to be made, and once they are made the overhead from that interpreter is done?
20:32:02 <rwbarton> right
20:32:18 <Eduard_Munteanu> cornihilio: there's splitAt, or take + drop
20:32:18 <Tekmo> Sorry
20:32:21 <Tekmo> not 4 arguments
20:32:26 <Tekmo> A type with 4 possible values
20:32:34 <Eduard_Munteanu> splitAt :: Int -> ByteString -> (ByteString, ByteString)
20:32:36 <jmcarthur> it's not like that
20:33:11 <jmcarthur> only the case branches would be specialized. it's not like there are four versions of that function now
20:33:14 <ski> rwbarton : .. i suppose one could `newtype' -- but it's gonna be ugly
20:33:24 <jmcarthur> but here's the interesting part...
20:33:28 <Tekmo> Right, that's what I mean
20:33:33 <Tekmo> some type has 4 constructors
20:33:37 <Tekmo> there are four branches to that case
20:33:40 <jmcarthur> Tekmo: say you have an interpreter f, a program p, and an input for the program x
20:33:42 <rwbarton> I'm trying that now
20:33:44 <Tekmo> you only traverse each branch once
20:33:53 <jmcarthur> Tekmo: let g = f p
20:34:04 <jmcarthur> Tekmo: now i can use g as many times as i want, only paying for f p once
20:34:04 <rwbarton> hmm
20:34:09 <rwbarton> it's not going that well
20:34:54 <rwbarton> I actually have no idea how this works
20:35:02 <jmcarthur> Tekmo: g is lazily specialized as it is applied to x, and if it is later applied to y it might be specialized a bit further (over the branches it didn't take the first time)
20:35:14 <Tekmo> jmcarthur: Yeah, I think I get it
20:35:20 <Tekmo> jmcarthur: Using a concrete example:
20:35:23 <rwbarton> not sure how to tell it that the kind of the output of the type family depends on the kind of the input
20:35:30 <Tekmo> let's say that f :: Bool -> a
20:35:34 <Tekmo> two code paths
20:35:37 <Tekmo> once for eahc value of Bool
20:35:43 <Tekmo> Once you traverse each code path
20:35:50 <Tekmo> you basically replace each code path with the `a`
20:36:03 <jmcarthur> yes
20:36:12 <ski> jmcarthur : "g is lazily specialized as it is applied to x" -- lazily specialized wrt *`x'* ?
20:36:13 <jmcarthur> so i guess this is where you saw it as memoization
20:36:18 <Tekmo> Yes
20:36:53 <Tekmo> So I guess the issue is that there is also a constant memory overhead
20:36:58 <jmcarthur> ski: no, but it *is* lazily specialized wrt p
20:37:02 <Tekmo> equal to the number of stored code paths
20:37:08 <jmcarthur> where p was the program the interpreter was applied to
20:37:23 <ski> ok
20:37:33 <Tekmo> jmcarthur: Also, what about large types like integers?
20:37:44 <Tekmo> jmcarthur: Would you be storing every result of addition?
20:37:44 * ski tries to picture this in terms of MetaML/MetaOCaml
20:37:47 <jmcarthur> ski: if g is polymorphic and types are considered arguments then you could reasonably expect it to be able to create a version of it specialized to a particular type, though
20:38:03 <doomlord> do you need to call type coersion epxlicitely eg. char -> int
20:38:05 <jmcarthur> Tekmo: only if it's shared, of course
20:38:19 <Tekmo> jmcarthur: So you basically specify in advance which things to share and which to not?
20:38:24 <ski> jmcarthur : is this on-line specialization ?
20:38:31 <jmcarthur> what do you mean by "specify in advance"?
20:38:42 <Tekmo> jmcarthur: In the program
20:38:45 <jmcarthur> ski: heh, what do you mean by "on-line"?
20:38:46 <startling> so uh, whose decision was it not to put any comments in the template haskell haddocks?
20:38:47 <Eduard_Munteanu> doomlord: there's no type coercion, there are conversions, and yes, they are explicit.
20:39:04 <Eduard_Munteanu> (or there is, but you don't want to know about it)
20:39:11 <jmcarthur> Tekmo: well, you could certainly do that if the language allows it, but it's not fundamental to the execution mode
20:39:14 <jmcarthur> l
20:39:33 <jmcarthur> ski: it's on-line in the sense that it doesn't happen until it's executed at least once
20:39:40 <jmcarthur> if that's what you mean...
20:39:54 <Tekmo> jmcarthur: I think he means that the specialization is done at run time
20:40:01 <jmcarthur> then yes
20:40:48 <Tekmo> This gives me a lot of ideas
20:41:13 <jmcarthur> Tekmo: the constant memory overhead isn't really that. it's only constant in the number of syntactic branches, not semantic. for example, a function over integers won't store a specialized branch for every integer you pass to it
20:41:31 <ski> jmcarthur : an on-line specializer decides what things to reduce and what things to residualize, after looking both at the program and the *value* of its static input. an off-line specializer only decides what things to reduce resp. residualize after looking at the program and "which parts of the input are static" (but *not* the actual values of the static part of the input)
20:41:45 <jmcarthur> Tekmo: unless you, the programmer, had made a huge case/if expression
20:42:04 <Tekmo> jmcarthur: So it is only keyed to case statements and doesn't pretend that integer addition is a gigantic case statement
20:42:16 <jmcarthur> ski: that dichotomy doesn't make much sense here, i think
20:42:27 <jmcarthur> Tekmo: think of it as being keyed to the AST
20:42:37 <ski> jmcarthur : with an off-line specializer, you can get an intermediate stage, where you have specialized the program, and gotten a new program that when fed the static input, will output a program specialized to that static input
20:43:05 <ski> (such that you can reapply that program many times to different static inputs, as long as they have the same "shape")
20:43:09 <jmcarthur> ski: the specialization here is actually just an effect of more sharing
20:43:37 <jmcarthur> ski: evaluation is the only driver of specialization. there is no special thing trying to analyze the program
20:43:58 <ski> otoh with an on-line specializer, you can (sometimes) make more agressive partial evaluation, like converting `0 * blah' to `0' (where `blah' may contain dynamic part) and where the `0' was computed during the specialization process
20:44:24 <jmcarthur> this would not perform that specific optimization without special logic for it
20:44:46 <jmcarthur> well, i guess if the type is lazy naturals or something it would ;)
20:45:23 <ski> off-line specializers are typically staged into (a) a BTA (Binding-Time Analyzer) which decides which parts should be static and which should be dynamic; and (b) a staged programming evaluation model which reduces the static parts, and residualizes the dynamic parts
20:45:48 <jmcarthur> there is no such staging in this case
20:46:02 <rwbarton> ski: I realized I don't even know how to write the newtype version
20:46:15 <jmcarthur> Tekmo: what kind of ideas does it give you?
20:46:39 <rwbarton> @type ap ($)
20:46:41 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
20:46:45 <Tekmo> jmcarthur: So I was trying to imagine if there were some imaginary parallel universe where Haskell had this facility
20:46:54 <rwbarton> @type liftM2 ($)
20:46:55 <lambdabot> forall a2 b (m :: * -> *). (Monad m) => m (a2 -> b) -> m a2 -> m b
20:47:25 <Tekmo> jmcarthur: And you described the fact that a type had not yet been shared by nesting it within some functor
20:47:29 <rwbarton> I don't know how to write LiftApply :: (* -> (k -> l)) -> (* -> k) -> (* -> l)
20:47:35 <Tekmo> let's say "Share"
20:47:54 <jmcarthur> i don't think i understood that sentence
20:48:20 <hpaste> cardamon pasted “my xmonad.hs” at http://hpaste.org/76017
20:48:26 <ski> jmcarthur : i suspect that what you're talking about is maybe related to e.g. memoing a function `Natural -> a' via an intermediate (lazy) `[a]' -- yes/no ?
20:48:47 <jmcarthur> ski: yes! that would be automatic
20:49:00 <ski> "automatic" meaning ?
20:49:21 <jmcarthur> Natural -> a  has the same properties as  [a]
20:49:35 <ski> rwbarton : hm, the non-`*' result kind is problematic ..
20:49:39 <rwbarton> right
20:49:44 <Tekmo> jmcarthur: What I mean is that you might start with a type of the form: Share (Either a b), and if the type is demanded up to the Either constructor it proceeds to Either (Share a) (Share b)
20:49:50 <jmcarthur> as you apply it to different arguments, its representation becomes more and more like [a]
20:50:01 <Tekmo> jmcarthur: Types "outside "Share" type constructors have been shared
20:50:15 <rwbarton> maybe as a newtype family?
20:50:20 <rwbarton> actually
20:50:28 <jmcarthur> Tekmo: yeah that sounds like a kind of model for normal lazy evaluation of data structures
20:50:32 <ski> rwbarton : here `newtype c (LiftApply f g a) = LA (c ((f a) (g a)))' would be nice to have (an old wish of mine)
20:50:53 <jmcarthur> Tekmo: it looks a lot like Agda's coinduction stuff
20:51:51 <jmcarthur> Tekmo: i'm not sure what the gain is in making this a type, yet
20:52:03 <ski> jmcarthur : i was thinking about `memoize :: (Natural -> a) -> (Natural -> a); memoize f = (as !!) where as = map f [0 ..]'
20:53:07 <jmcarthur> ski: yeah. with this evaluation model, that memoization just happens already.
20:53:18 <ski> jmcarthur : i was just wondering if the specialization you were talking about did some kind of similar memoization ?
20:53:44 <ski> (where the input `Natural -> a' would in your case be replaced by the input program)
20:53:47 <jmcarthur> it's not explicitly memoization, but obviously has some of the same effects
20:55:33 <nn_step> hello
20:55:40 <Tekmo> Hi
20:55:44 <ski> rwbarton : anyway, i'm not quite sure about whether `Inner' and `Outer' for higher-order types are right
20:56:15 <nn_step> anyone able to answer a basic question about xmonad?
20:57:03 <Tekmo> Not me.  I don't use xmonad
20:57:15 <latro`a> depends how basic
20:57:16 <frio> nn_step: maybe
20:57:39 <latro`a> there is a #xmonad on freenode though iirc
20:57:48 <nn_step> oh
20:57:52 <ski> rwbarton : basic idea, assume we can define `instance Liftable a => Liftable (f a) where lift :: f a -> C (f a)' (using `lift :: a -> C a') -- the obvious way to define this is to already have `f (C a) -> C (f a)' (assuming `f' is a functor)
20:58:04 <nn_step> perhaps I should ask my question there instead
20:58:07 <nn_step> sorry
20:58:20 <ski> s/f/F/
20:59:00 <doomlord> managed to get an update-render loop going  .... i suspect my method sucks
20:59:06 <ski> rwbarton : so instead of `instance Liftable a => Liftable (F a)' i wanted to have instead `instance Liftable F where lift :: F (C a) -> C (F a)'
20:59:21 <rwbarton> how do I get ghci to expand type families?
20:59:30 <ski> (`C' is `[]' in the examples above)
21:00:29 <Tekmo> Tell them to breed more
21:00:55 <rwbarton> oh, maybe it is not expanding because there is no matching instance
21:01:03 <rwbarton> though an error that says that would be nice
21:01:58 <otters> I'm trying to write a function :: Ord a => (b -> b -> a) -> [b] -> [b] that removes the "smallest" item from a list
21:02:03 <otters> but I'm stuck
21:02:11 <otters> err, that should be b -> b -> Ordering
21:02:41 <Tekmo> Ok, so how do you remove elements from a list?
21:03:19 <otters> filter
21:03:22 <otters> or tear it down and rebuild it
21:03:27 <otters> without the offending element
21:03:33 <ski> however, given `T :: (* -> *) -> (* -> *)' (say), the same issue reappears with `instance (Liftable f,Liftable a) => Liftable (T f a) where lift :: T f a -> C (T f a)' in terms of `lift :: forall a. f (C a) -> C (f a)' and `lift :: a -> C a'
21:03:40 <Tekmo> The latter is probably more efficient
21:03:57 <Tekmo> Wait
21:04:00 <Tekmo> Actually it won't be
21:04:10 <Tekmo> Because you won't know which element to remove until you get to the end of the list anyway
21:04:19 <otters> yeah, that's what just occurred to me
21:04:22 <Tekmo> Also, there is a simpler function than remove for getting rid of a single element
21:04:28 <Tekmo> *filter
21:04:33 <otters> which is what
21:04:36 <Tekmo> delete
21:04:45 <otters> right
21:04:47 <Tekmo> :t delete
21:04:48 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
21:05:48 <ski> using the definition above, `instance Liftable T where lift :: NatTransf (Inner C T) (Outer C T)', i.e. `lift :: forall f a. T (\b -> C (f b)) (C a) -> C (T (\b -> f (C b)) a)' suggests itself -- but i'm not convinced this is right
21:06:22 <Tekmo> ski: What were you trying to do?
21:06:30 <jmcarthur> ski: one way in which is differs from your memoization is that if you compose it was a function that adds three Succs to the input before passing it to your function and if your original function is no longer referenced, the first three elements in the "list" will be dropped by the gc since they are no longer reachable
21:06:39 <jmcarthur> wow i can't type
21:06:45 <jmcarthur> *in which it differs
21:06:53 <jmcarthur> *compose it with a function
21:06:55 <ski> Tekmo : define a kind of general "distributivity"-like type class
21:07:08 <Tekmo> parametrized on both functors or just one?
21:07:25 <startling> let's try this again: in template haskell, which argument in instanceD is the class name and which argument is the type?
21:07:26 <ski> Tekmo : only one of them matters
21:07:41 <ski> Tekmo : but it should be polymorphic in the kind of the other one :)
21:07:48 <Tekmo> ooooh
21:07:55 <Tekmo> This is over my head, then :)
21:08:22 <startling> its type is CxtQ -> TypeW -> [DecQ] -> DecQ, btw
21:08:31 <startling> s/TypeW/TypeQ
21:09:48 <ski> jmcarthur : nice :) (reminds me of <http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/Storage/HeapObjects#Selectorthunks>)
21:09:50 <startling> seems like the CxtQ are any typeclasses that apply, TypeQ is the name of the type, and the [DecQ] are the definitions for the class methods. so where does the typeclass go?
21:12:24 <ski> Tekmo : basically, in my case, `(lift :: A -> C A) => (lift :: F A -> C (F A))' (the `instance ... => ... where' stuff) was useless, since `lift :: A -> C A' could never be for my `A' -- however `lift :: F (C A) -> C (F A)' could still be, and was what i wanted
21:12:51 <ski> Tekmo : the rest was just a happy generalization fest
21:15:23 <rwbarton> ski: I am still way behind trying to define my LiftApply
21:17:21 <startling> is there a template haskell channel?
21:19:29 <mightybyte_> Anyone know if pandoc can do literate haskell with slidy markdown?
21:21:00 <rwbarton> or a poly-kinded Compose, for that matter
21:21:01 <ski> rwbarton : hm, i thought it could be done by doing induction on `l' in `LiftApply :: (* -> k -> l) -> (* -> k) -> (* -> l)', but now i'm not so sure
21:21:07 <rwbarton> I thought so too...
21:21:14 <rwbarton> I think maybe I have to do Compose first
21:22:29 * ski . o O ( `newtype c (Compose f g a) = C (c (f (g a)))' :/ )
21:23:21 <ski> (that feels to me as if it'd work -- but there'd need to be some restrictions on the form of the definiens, for safety)
21:30:23 <rwbarton> or just being able to make a newtype of something not of kind *
21:30:26 <rwbarton> newtype M = M Maybe
21:33:50 <zzing> Can I comment out something in .ghci?
21:34:19 <rwbarton> I think this is impossible because for any type constructor C defined via newtype, I can only feed C a uniformly bounded number of arguments before getting *
21:35:08 <rwbarton> that's not really very convincing
21:36:57 <osfameron> mightybyte_: slidy?
21:39:14 <mightybyte_> osfameron: An html-based presentation format
21:39:44 <osfameron> ah, nice... literate code on slides is an interesting idea!
21:39:49 <mightybyte_> The answer that I discovered so far is that I can render code blocks with ```, but net with the literate Haskell > syntax.
21:40:01 <osfameron> probably quite a bad idea too... if the tech talks I've seen that
21:40:08 <osfameron> discuss code are anything to go by...
21:40:13 <mightybyte_> lol
21:40:36 <mightybyte_> Well, I like to think that it's a good idea in the hands of the right presenter.
21:41:17 <osfameron> I think you need to show much less code, and repeat, edit, format it in ways that would be hard to automate
21:41:48 <mightybyte_> True.  I wouldn't present real-world literate Haskell code.
21:42:02 <osfameron> that said... it might be a good idea for marking up a codebase for training a new employee
21:42:05 <mightybyte_> I would present a presentation that has literate Haskell that I want to be able to compile
21:42:24 <osfameron> ah
21:49:10 <zzing> mightybyte_, hello long time no see
21:51:26 <thetallguy> is it possible to mark a field of a record as strict?
21:53:15 <zzing> thetallguy, I believe so, look at the source for the Text data type
21:53:36 <thetallguy> zzing: good idea, thanks
21:53:50 <zzing> http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/src/Data-Text-Internal.html#Text
21:54:13 * hackagebot criterion 0.6.2.0 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.6.2.0 (BryanOSullivan)
21:54:16 <zzing> Lucky for you I looked this earlier today and remembered seeing the ! before the types :P
21:55:07 <prokii> I'm trying to create a Data.Array.Array(Int,Int) Square  where data Square = Picture | NoPic
21:55:45 <prokii> But I am getting "Exception: (Array. !): undefined array element
21:55:58 <mightybyte_> zzing: Hi
21:56:33 <rwbarton> prokii: I think that means you didn't provide a value for the entry when you constructed the array
21:56:43 <rwbarton> > array (0,2) [(0,'a'), (2,'b')] ! 1
21:56:44 <lambdabot>   *Exception: (Array.!): undefined array element
21:56:55 <thetallguy> nope, simple constructor.
21:57:27 <Polarina> Which should I be using, TQueue/TMVar or MQueue/MVar, when I don't need any of the transactional guarantees of STM?
21:57:42 <rwbarton> thetallguy: pretty sure you just write ... C { field1 :: !Int, ... } ...
21:58:00 <thetallguy> rwbarton: that's what I thought.
21:58:03 <Lutin`> prokii: Do you mean !!
21:58:52 <thetallguy> rwbarton: Okay, that worked with a simpler example... now I have a new puzzle
21:58:52 <Lutin`> actually I just don't know what I'm talking about
21:59:17 <zzing> mightybyte_, I remember talking with you a little over a month ago about the philosophy of webdesign. I think I found one area that I like - built in template library in haskell (hamlet) coupled with actual documents retrieved from a database in html. I want to thank you for at least mentioning some of this stuff, because otherwise I might not have seen the other webframework. I am almost finished a project using yesod, and might at some p
21:59:17 <zzing>  able to take a fresher look at snap with more experience under my belt.
21:59:21 <ski> @let tabulate ix f = array ix [(i,f i) | i <- range ix]
21:59:23 <lambdabot>  Defined.
21:59:32 <ski> > tabulate (0,9) $ \i -> i^2
21:59:34 <lambdabot>   array (0,9) [(0,0),(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,...
21:59:51 <ski> prokii : mayhaps `tabulate' would be useful for you ?
21:59:56 <thetallguy> rwbarton: Oh, hee hee, !  binds very tightly
22:00:18 <rwbarton> ski: giving up on defining Compose and LiftApply and Outer, by the way. I have the vague feeling it's impossible
22:00:30 <rwbarton> thetallguy: you mean, you have to write !(Maybe Int)?
22:00:33 <thetallguy> data C = C { m :: ! Map Int Int } fails,  data C = C { m :: ! (Map Int Int) }
22:00:57 <prokii> perhaps.. I just need to init the array to NoPic
22:01:08 <thetallguy> rwbarton: Yup
22:01:17 <rwbarton> prokii: listArray whateverbounds $ repeat NoPic
22:02:26 <prokii> perfect!
22:02:29 <prokii> thanks
22:02:40 <ski> rwbarton : "or just being able to make a newtype of something not of kind *","I think this is impossible because for any type constructor C defined via newtype, I can only feed C a uniformly bounded number of arguments before getting *" -- this i why i want to be able to say `newtype k (T a b ...) = MkT (k (..a..b..))' -- e.g. `newtype k M = MkK (k Maybe)' with `M :: * -> *' and `MkK :: k Maybe -> k M'
22:02:59 <prokii> So.. if I use Int in place of Square..  it defaults to 0
22:03:10 <prokii> is there a way to make my Square type have a default?
22:03:36 <rwbarton> you are using Data.Array.Array? it doesn't default
22:03:37 <ski> s/MkK/MkM/
22:03:57 <prokii> does UArray default?
22:04:08 <mightybyte_> zzing: Cool, glad I could help
22:04:13 <rwbarton> STUArray defaults to 0
22:04:14 * hackagebot enumfun 0.5.1.0 - Finitely represented /total/ EnumMaps  http://hackage.haskell.org/package/enumfun-0.5.1.0 (LiyangHu)
22:04:23 <rwbarton> but how do you have a UArray of your custom type...
22:05:05 <rwbarton> you can do that but it's sort of hard
22:05:36 <rwbarton> ski: yeah, I see
22:05:52 <rwbarton> not clear that even this is general enough
22:06:17 <rwbarton> for example, how do you construct a value of type M Int
22:06:23 <rwbarton> hmm
22:06:25 <rwbarton> I suppose you can
22:06:34 <rwbarton> in a round-about fashion
22:07:05 <ski>   newtype OfInt f = OI (f Int)
22:07:07 <rwbarton> off . MkK . On where newtype On a f = On { off :: f a }
22:07:18 <ski> *nod*
22:07:25 <rwbarton> oh
22:07:29 <rwbarton> it's like Leibniz equality
22:07:37 <ski> yeah :)
22:07:59 <doomlord> can you extract a value from a monad,    if i have a function returning "IO a" and i want the "a"
22:08:05 <ski> `newtype A = MkA B' says `A' and `B' are iso
22:08:06 <rwbarton> of course it breaks with GADTs
22:08:18 <ski> `newtype A a = MkA (B a)' says `A a' and `B a' are iso, for any `a'
22:08:20 <doomlord> without using a temporary variable  somethign<-whatever..
22:08:26 <rwbarton> right
22:08:31 <ski> `newtype k A = MkA (k B)' says `k A' and `k B' are iso, for any `k'
22:08:44 <mzero> doomlord: inside a monadic (IO) expression? or outside of it?
22:08:50 <doomlord> inside
22:09:10 <mzero> you can use the a of an IO a in three common ways:
22:09:12 <ski> doomlord : short answer : "no, you can't"
22:09:19 <mzero> v <- thingThatMakesAnIOa
22:09:22 <doomlord> oh because it MUST passs the monad along
22:09:40 <mzero> or thingThatMakseAnIOa >>= functionThatTakesaAndReturnsIOb
22:09:43 <startling> doomlord: not really. that's specific to IO
22:09:56 <rwbarton> basically the only way to consume an IO action is with (>>=), yeah
22:09:59 <mzero> or funcFromAToB `fmap` thingThatMakseAnIOa
22:10:02 <rwbarton> (^ false statement for many reasons)
22:10:03 <startling> doomlord: if you have a Maybe or Either, you can get it out pretty easily
22:10:13 <doomlord> is a 6 line paste ok?
22:10:14 <ski> `<-' inside `do' desugars to a call to `(>>=)'
22:10:19 <ski> @paste
22:10:19 <lambdabot> Haskell pastebin: http://hpaste.org/
22:10:28 <startling> doomlord: paste it into a pastebin
22:10:32 <mzero> but doomlord seems to want to do this within an IO monadic operation
22:10:41 * ski would be ok with 6 lines, but others may differ
22:11:08 <doomlord> ok i have what i want working, the question is elegance.. i've not done much of this...
22:11:14 <ski> startling : except when it's not there :)
22:12:15 <doomlord> http://pastebin.com/mKH27Hq4
22:12:21 <maukd> The paste mKH27Hq4 has been copied to http://hpaste.org/76019
22:12:52 <doomlord> there's a typo
22:13:39 <doomlord> http://pastebin.com/imCnfGLF
22:13:45 <maukd> The paste imCnfGLF has been copied to http://hpaste.org/76020
22:13:50 <mzero> :t modifyIORef
22:13:51 <lambdabot> Not in scope: `modifyIORef'
22:14:45 <doomlord> if i used modify i have to read it again i think
22:15:11 <doomlord> but i see modify can cleanup another part i have
22:16:15 <doomlord> so this is the basic update-render loop called for opengl/glut ... first time i've written something like this in haskell; i've got my 'update' and 'render' seperated out which is the important bit... i can get going on doing something interesting now- but i just wondered if this is possible to do more elegantly...
22:18:14 <Ralith> doomlord: that's a pretty gratuitous use of IO
22:18:59 <doomlord> yeah i just stuffed the world & controller as mutable variables. but the update & controller translation can be pure
22:19:19 <mzero> doomlord: consider making your main function take World and return IO World
22:19:37 <Ralith> doomlord: why did you do that?
22:19:46 <doomlord> i dont know any better yet
22:20:15 <mzero> then you never need a worldRef - your mainloop starts with an initialWorld, computes the next world, renders it, pauses, then calls it self tail-recursively with the nextWorld
22:21:22 <mzero> what is the difference between Ctrl and World, btw?
22:21:26 <doomlord> a bit of detail here:- the render loop will be of this form:   { t=time(),  while (state.time<time) { Update(state); time+=dt;}   Render(state);}
22:21:34 <Ralith> mzero: considering that his update function is already pure, he could just use World -> World
22:21:38 <doomlord> Ctrl is controller data; "World" is the 'game-state'
22:21:50 <doomlord> 'update' takes a world and controller data, returns updated world
22:21:55 <mzero> something else updates the controller date from "real world" inputs?
22:21:57 <doomlord> 'render' takes a world and draws it
22:22:02 <doomlord> yes
22:22:14 <mzero> k... give me a sec.... coding in hpaste.... :-)
22:22:36 <doomlord> as it stands - i have the hooks to fill in that i want - update, render,  refresh controllers
22:22:42 <zzing> If I have a parser:   parseHeading :: Stream s m Char => ParsecT s u m ([Char], [Char])    how do I test it? I have tried with parseTest parseHeading "header : text"     but I am not sure about an instance it wants (Stream s0 Data.Functor.Identity.Identity Char)
22:24:02 <doomlord> bit more detail: this is shoved into GLUT;   GLUT.idleCallback, and GLUT.displayCallback
22:24:45 <doomlord> perhaps a better method involves GLFW , i saw another example with a loop.
22:25:07 <hpaste> mzero pasted “game state loop” at http://hpaste.org/76021
22:25:11 <doomlord> i saw a GLFW example with an explicit render loop - wheras here its using the Glut render-looop
22:25:17 <mzero> that's how I'd structure this
22:25:41 <mzero> if you really needed to parametertize mainLoop with rendering and update functions, I'd add those as initial arguments to mainLoop
22:26:18 <mzero> note that there are no IORefs in that code
22:26:29 <b__> how would I declare a datatype for a tree where each node splits into either 1 or 2 branches?
22:26:36 <doomlord> ok
22:27:06 <doomlord> mzero, i think my use of IORef is imposed by my use of glut .. or can you wite an explicit rendering loop over glut?
22:27:18 <doomlord> polling the rest of glut's services in the middle.
22:27:44 <mzero> doomlord: there is no requirement that you need to use IORef for your world data at all
22:28:04 <mzero> note that renderWorld is in IO, and so can call glut's services
22:28:16 <mzero> and it has direct access to World's data
22:28:37 <hpaste> mzero annotated “game state loop” with “game state loop (annotation)” at http://hpaste.org/76021#a76022
22:29:07 <mzero> b__: how does a tree split into 1 branch? is there data at each node?
22:29:20 <b__> yes, there's data at each node
22:29:38 <doomlord> do you know if you can implement this pattern with Glut; it could be i'm just making hacky use of that.
22:29:44 <mzero> b__:  are you looking for a code fragment or a hint?
22:29:53 <b__> a hint
22:29:57 <mzero> doomlord: I don't see why not
22:29:58 <b__> either
22:30:08 <doomlord> ok thanks for the suggestion of tail-recursive updateloop
22:30:16 <b__> I am think data Tree a = Leaf a | Branch [Tree a]
22:30:20 <b__> thinking*
22:30:37 <mzero> b__: okay, a normal binary tree would be like this:        data MyTwoTree a = Leaf a | Node a (MyTwoTree a) (MyTwoTree a)
22:30:48 <b__> yeah
22:31:13 <doomlord> GLUT needs to service other window events too
22:31:17 <mzero> b__: your though is a Forest (which is fine), but your datatype allows arbitrary n-way split, and has no data at the branching notdes
22:31:34 <ski> b__ : what you asked for is `data Tree a = OneBranch a (Tree a) | TwoBranches a (Tree a) (Tree a)' ..
22:31:39 <mzero> remember - you can have more than two constructors for a given data type
22:31:56 <b__> ah yeahh
22:32:12 <mzero> doomlord: so? World still doesn't need to be inside an IORef
22:32:19 <b__> thanks both :}
22:32:19 <ski> (but i somehow suspect that that is not quite what you wanted)
22:32:31 <b__> ski I think it is
22:32:41 <Lutin`> like data Tree = Leaf a | Branch1 a (Leaf a) | Branch2 a (Leaf a) (Leaf a)
22:32:54 <Lutin`> Or
22:32:57 <ski> b__ : note that every value of my `Tree a' will contain an *infinite* number of `a's
22:33:40 <b__> well, this is indeed the case
22:33:52 <b__> but it might be problematic
22:33:58 <ski> presumably you wanted a base case, as well ?
22:33:59 <Lutin`> Such malformed on my part
22:33:59 <mzero> (assuming that b__ still wants help figuring out how to go about it) --- think about these questions: Is there data at every node or only at the leaves (non-split points)? Can I have arbitrary split points or just specific size splits?
22:34:13 <doomlord> oh ... is this what the "setableStateVar" is for,...
22:34:13 <doomlord> http://cvs.haskell.org/Hugs/pages/libraries/GLUT/Graphics-UI-GLUT-Callbacks-Window.html
22:34:18 <b__> I am generating collate chains in reverse, if that helps
22:34:22 <Lutin`> like data Tree a = Leaf a | Branch1 a (Tree a) | Branch2 a (Tree a) (Tree a)
22:34:28 <mzero> you can then think about encoding these choices in the design of the options for your data type - which will - in turn make your program more robust
22:34:29 <b__> collatz
22:34:35 <Lutin`> @b__
22:34:35 <lambdabot> Maybe you meant: bf bid bug
22:34:42 <doomlord> GLUT.displayCallback ::SettableStateVar IO ()
22:34:47 <ski> (Lutin` : i'd s/Leaf/Branch0/ there :)
22:35:01 <Lutin`> Yes that would follow patterns
22:35:02 <mzero> doomlord: are you using hugs?
22:35:35 <doomlord> hugs, haskel interpreter ? not that i know of ; compiling with ghc.
22:36:04 <mzero> why are you looking at the hugs docs? those are , well, old
22:36:10 <mzero> are you running off haskell platform?
22:36:28 <doomlord> i'm googling all over the place.
22:36:36 <mzero> try these on-line docs: http://lambda.haskell.org/platform/doc/current/frames.html
22:36:54 <mzero> in theory, if you installed haskell platform, you have the correct versions on your hard disk
22:37:13 <mzero> and if you're using a different version of GLUT, you should use the docs that match the version off Hackage
22:38:09 <mzero> bah - no glut docs int aht set, try here: http://hackage.haskell.org/package/GLUT-2.1.2.2
22:38:18 <b__> Lutin`, mzero, ski, thanks for your suggestions :]
22:38:27 <mzero> er, http://hackage.haskell.org/package/GLUT-2.1.2.1
22:38:28 <brutal_chaos> _
22:39:37 <mzero> doomlord: what do you intend to do in those callbacks? adjust the Ctrl?
22:40:26 <doomlord> Ctrl is only modified by "updateCtrl;" its read-only by "update", and not used by "render"  *
22:41:45 <doomlord> i'm happy with that seperatation ... update / controllerIO /  render;   its just how to implement that loop in the first place..
22:41:55 <doomlord> what i have does actually work at least
22:42:01 <mzero> so, do you have a mainloop, or are you hanging all drawing off the displayCallback?
22:42:02 <startling> oh hey, I found it!
22:42:16 <startling> the answer is that you appT the typeclass name with your type name
22:42:23 <startling> which seems wrong. but meh.
22:42:41 <doomlord> idleCallback : render one frame, updatem 1 frame (TODO: frame compensation..))
22:43:18 <doomlord> displayCallback is just for window-refresh; that shouldn't update.  I'm just plugging callbacks in as per the default way glut is used in C.
22:43:58 <doomlord> perhaps glut's loop in haskell is passing that "SettableStateVar" which i didn't know how to use...
22:44:43 <doomlord> "keyboardMouseCallback" is grabbing controller information and stuffing it into IORef CtrlRef
22:45:03 <doomlord> i'm paste my main:-
22:46:26 <doomlord> http://pastebin.com/ZvQsS853
22:46:38 <maukd> The paste ZvQsS853 has been copied to http://hpaste.org/76023
22:47:03 <doomlord> 'mainLoop' enters glut-land
22:47:51 <doomlord> (there's a window-resize event too which i haven't supplied yet)
22:48:44 <rwbarton> anyone know whether any haskell->js project supports Typeable/cast?
22:50:07 <doomlord> it might just be glut is an archaic methodology that doesn't suit haskel
22:50:53 <doomlord> someone elsees suggestion was GLFW... but i just wanted to get something onscreen ASAP, and i've not used that yet
22:52:03 <doomlord> ah, glutMainLoopEvent... supposedly one can just poll that..
22:52:20 <jfischoff> why not read the IORef before you pass it to doRenderUpdate?
22:53:48 <doomlord> at the minute doRenderUpdate isn't a *loop*  , its a callback called by glutMainLoop.  I think one might be able to do ones' own mainloop and call 'glutMainEvent' within that ,
22:53:53 <jfischoff> for the ctrl
22:54:23 <doomlord> 'ctrl' is updated by a different glut-callback (keyboardMouseCallback)
22:58:04 <jfischoff> yeah but doRenderUpdate doesn't need to update it right?
22:59:45 <doomlord> 'ctrl' has state: glut gives individual keyup/keeydown; i like to keep a buffer of realtime key states (eg 1 bit per key)
23:00:30 <jfischoff> 
23:01:12 <doomlord> ok, i've seen that i can infact use my own loop instead of gluts, so 'world' is out of IORef now
23:02:17 <doomlord> i've just got the IORef left to be updated by Glut's "keyboardMouseCallback"
23:04:52 <doomlord> http://pastebin.com/NCr4i4DV
23:04:58 <maukd> The paste NCr4i4DV has been copied to http://hpaste.org/76024
23:05:36 <doomlord> so thats using tail recursion as mzero  suggested; however, its still getting 'ctrl' via gluts' callback..
23:05:41 <doomlord> & IORef
23:06:40 <doomlord> Parameterization of update/render just seemed natural; i might want to fire up different modes based on commandline params
23:07:02 <doomlord> its not stricly needed yet
23:27:13 <Bluelz> Quick question, can I only have one guard "|" followed by a guard catching otherwise? My case is this: I'm recursing on a [String], and depending on the String I just read, I might want to jump 2 slots forward OR 3.
23:27:16 <hpaste> Bluelz pasted “recursive tree” at http://hpaste.org/76025
23:27:41 <Bluelz> Theres my current code, is this invalid syntax in Haskell?
23:27:46 <Bluelz> Compiler gives errors
23:28:42 <Bluelz> file:5:3: parse error on input :'
23:29:37 <startling> donri: https://gist.github.com/3a190cf306048cf47560
23:29:58 <Jafet> > let s = "(Branch (str, tail strs, tail (tail strs), strs)" in (filter (=='(') s, filter (==')') s)
23:29:59 <lambdabot>   ("(((","))")
23:31:27 <donri> startling: the way i did numeric font weights was simply W100 | W200 ...
23:31:43 <startling> donri: yeah, I was thinking about that.
23:31:54 <startling> donri: my template haskell thing needs some modifications though
23:32:10 <startling> because otherwise it'd output font-weight: W100
23:49:09 <Bluelz> Jafet: Shit I didnt realize I was one paranthesis off, thanks for the save mate
23:51:35 <prokii> How can I print the contents of an IOArray
23:52:41 <Jafet> @hoogle IOArray i e -> IO [e]
23:52:42 <lambdabot> Data.Graph.Inductive.Query.ArtPoint ap :: Graph gr => gr a b -> [Node]
23:52:42 <lambdabot> Data.Graph.Inductive.Query.DFS dfs' :: Graph gr => gr a b -> [Node]
23:52:42 <lambdabot> Data.Graph.Inductive.Graph nodes :: Graph gr => gr a b -> [Node]
23:52:58 <ClaudiusMaximus> getElems, but that has a tendency to explode for large arrays
23:52:58 <Jafet> @hoogle Data.Array.IO.IOArray i e -> IO [e]
23:52:59 <lambdabot> Parse error:
23:52:59 <lambdabot>   Data.Array.IO.IOArray i e -> IO [e]
23:53:00 <lambdabot>       ^
23:53:10 <ClaudiusMaximus> @hoogle getElems
23:53:10 <lambdabot> Data.Array.MArray getElems :: (MArray a e m, Ix i) => a i e -> m [e]
23:54:38 <prokii> do I have to unwrap the IO monad before I pass it to the getElems?
23:55:51 <ClaudiusMaximus> for small arrays,   print =<< getElems a   otherwise do some monadic loop over the array printing as you go, without converting the whole thing to an in-memory list snapshot first
23:56:02 <rwbarton> @hoogle freeze
23:56:03 <lambdabot> Data.Array.MArray freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
23:56:03 <lambdabot> package safe-freeze
23:56:03 <lambdabot> Data.Text.Array unsafeFreeze :: MArray s -> ST s Array
23:57:14 <zzo38> What is the function to do like ((x -> Bool) -> ([x] -> [x]) -> [x] -> [x]) where the subset of elements in the input list matching the predicate is send to function and then is result same length, each one is replaced by the corresponding index in output retaining their order?
23:57:18 <ClaudiusMaximus> rwbarton: aha, then just use the show instance for IArray ?
23:57:49 <rwbarton> yes although it might require some annoying type annotations
23:58:07 <ClaudiusMaximus> mm
