00:02:43 <Cale> Polarina: The main limitation with Vector is that it only supports indexing by Int (I'm not really sure exactly why). The other main difference is in Vector's favour, and that's that it does stream fusion to fuse together loop operations to be more efficient.
00:03:40 <Cale> Polarina: i.e. you can write a bunch of operations which seem like they ought to need to iterate over the vectors involved, and it will automatically fuse the operations together into a single loop as far as possible.
00:04:43 <Polarina> Cale, that sounds very nifty.
00:05:53 * hackagebot yesod 1.1.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.2 (MichaelSnoyman)
00:05:55 * hackagebot yesod-core 1.1.3.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.3.1 (MichaelSnoyman)
00:07:17 <Polarina> Cale, thanks. :)
00:07:24 <Cale> No problem :)
00:08:35 <Polarina> Cale, would you recommend that I use vectors when I have no other reasons to use arrays instead?
00:09:11 <Cale> Yeah, it's probably a good decision.
00:10:46 <ClaudiusMaximus> vector doesn't unpack Bool into bits, whereas UArray does - but that's a rare use case where that matters; also if you need multidimensional indexing, repa is built on top of vector iirc
00:11:42 <Polarina> ClaudiusMaximus, that's useful to know, thanks. :)
00:13:02 <ClaudiusMaximus> vector could theoreticall do bit packing, there was some old code for its predecessor that did, but it never got updated (unless it has by now, in which case ignore this)
00:13:14 <astropirate> haskell needs to be easier to learn :(
00:13:26 <astropirate> faster* to learn
00:13:34 <shachaf> Gotta keep out the riffraff somehow. Right, copumpkin?
00:13:38 <Ralith> people need to be better at learning. :D
00:13:51 <astropirate> i'm learning fine :)
00:13:55 <astropirate> its just taking FOREVERRRRR
00:14:01 <Cale> astropirate: It wouldn't be as worthwhile to learn if you could learn it more quickly.
00:14:38 <astropirate> or would it? o_O
00:14:41 <killy9999> how do I provide a type annotation for a function defined in ghci ?
00:14:46 <Polarina> :t forever
00:14:48 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
00:14:50 <startling> astropirate: learn reader, writer, and state
00:15:05 <startling> astropirate: and then jsut write some Real program
00:15:16 <astropirate> I'm just about to start with the modules chapter of Learn you a Haskell
00:15:17 <astropirate> its great
00:15:18 <astropirate> but slow going
00:15:22 <shachaf> killy9999: let a :: b; a = c
00:15:28 <Cale> astropirate: Well, the main thing which makes it "difficult to learn" is that it's genuinely different from the languages you likely already knew.
00:15:28 <killy9999> thanks
00:15:29 <astropirate> I wish there was a more interactive way to learn
00:15:35 <ion> astropirate: Is Haskell your first language?
00:15:39 <astropirate> no
00:15:47 <Cale> Well, it's true, there could be more resources
00:15:52 <ion> astropirate: Did you learn your first language considerably faster?
00:15:57 <Cale> e.g. I could have written a book already ;)
00:16:06 <shachaf> Cale: Do it!
00:16:07 <bartavelle> hehe
00:16:09 <astropirate> ion, no not really :) but then again i was 10
00:16:15 <ClaudiusMaximus> cat #haskell.log | grep ^Cale
00:16:30 <ClaudiusMaximus> :)
00:16:33 <astropirate> If anyone is down to design an interactive resource i'd help out
00:16:40 <astropirate> being a front end dev as well
00:16:42 <shachaf> astropirate: There's tryhaskell.org
00:16:49 <astropirate> yah...
00:16:52 <astropirate> its really dry
00:16:54 <astropirate> not to bash on it
00:16:55 <bartavelle> astropirate, write some real program, and ask for advice when you believe what you are writing in clunkier than it should be ? this is interactive
00:17:06 <astropirate> bartavelle, how dare you and your logic
00:17:12 <bartavelle> ;)
00:17:18 <bartavelle> that's not a perfect solution
00:17:34 <bartavelle> now I use daily this "real program" and some parts are just horrible from the learning ;)
00:17:52 <bartavelle> probably all of it is horrible, but I don't realize that yet
00:17:59 <astropirate> hahah
00:18:11 <Polarina> astropirate, I've been learning haskell for some time now, I still feel sometimes like I have no idea what I am doing.
00:18:35 <astropirate> yah i remember haven written things in c++ that i thought were master pieces then i go back to them a couple of montsh ago and i'mlike what is this crap
00:18:53 <astropirate> Polarina, have you written any "real" applications with it?
00:19:00 <Polarina> astropirate, everyone knows that feeling...
00:19:00 <bartavelle> so hint: before writing any real program, be sure you understand the point of the ErrorT and StateT transformers
00:19:09 <Ralith> rule of thumb:
00:19:14 <Ralith> if you think what you are writing is clever, it isn't.
00:19:22 <Polarina> astropirate, real? Well, not really. But some I use regularly.
00:19:37 <astropirate> ahh ok
00:19:57 <bartavelle> Ralith, also, as it is harder to debug than to write, if what you write is clever, you will not be able to debug it
00:19:57 <astropirate> #truth Ralith
00:20:34 * ion watched the video <http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm>. It was nice.
00:21:05 <astropirate> I was thinking of making a interactive haskell totorial based on learn you a haskell as a learning exercise for myself
00:21:45 <startling> astropirate, you realize you can have ghci open as you read lyah and try things out?
00:21:54 <shachaf> Most introductions to Haskell that people write as they're just learning themselves turn out pretty bad. :-(
00:21:56 <Polarina> astropirate, it'll just take time. When someone first pointed out to me that I should learn Haskell (that was some years ago), I almost immedately bashed it for being an esoteric language. Then some years after that, I tried it. :)
00:22:32 <liyang> astropirate: you can speed up your learning by writing a monad tutorial.
00:22:52 <Nereid> ghci is an interactive haskell tutorial
00:22:54 <astropirate> why its like a borrito
00:22:55 <astropirate> :p
00:22:57 <Cale> I was introduced to Haskell via Haskore, when I offhand mentioned to someone that I was interested in algebraic foundations of music theory.
00:22:58 <astropirate> :P :P :P
00:23:10 <Ralith> is there such a thing?
00:23:30 <ion> yes
00:23:40 <Ralith> neat
00:23:41 <startling> Cale: and then you bashed it for being an esoteric language?
00:23:45 <Cale> No!
00:23:47 * liyang was introduced to Haskell via comp.lang.functional, after the CompScis in his year complained of how rubbish ML is.
00:24:23 * startling was introduced to haskell because he wanted a parsing framework that didn't suck.
00:24:25 * shachaf was introduced to Haskell via Perl 6. It was a scarring experience.
00:24:29 <Cale> I realised that everyone should be programming in this language almost immediately, despite the fact that I had no idea what I was doing or how to accomplish anything with it :)
00:24:34 * startling is still looking.
00:24:36 * Ralith wishes his classmates were at the point of complaining about the deficiencies of ML
00:24:52 <Cale> startling: Unhappy with Parsec and friends?
00:25:15 <startling> Cale: with their error-handling, really
00:25:19 <liyang> Ralith: their complaints were mostly about how hard and counterintuitive it was, compared to what they already knew.
00:25:25 <Ralith> oh.
00:25:28 * Ralith less envious.
00:25:34 <Polarina> startling, random question, have you looked at happy?
00:25:34 <startling> Cale: parsec is very very close though
00:25:58 <startling> Polarina: i remember having some trouble with it
00:26:18 <startling> like, getting it to run, not writing parsers
00:26:19 <Polarina> startling, I haven't tried it myself, yet. I've heard it's decent.
00:26:27 <Polarina> Ah.
00:26:52 <startling> Polarina: I should try it again, then
00:29:45 <bartavelle> I was introduced to haskell through the "coders at work" book, and it seemed the best language ever to troll coworkers
00:30:03 <bartavelle> turned out to be true, but also the best language for almost anything
00:30:27 <Ralith> how do you troll someone with haskell?
00:30:35 <bartavelle> well actually it is fairly easy
00:30:53 <bartavelle> "WHAT ????? you don't have ____ in your language ?"   or "WHAT ????? you have to do this UGLY thing ?"
00:31:07 <bartavelle> works with any language combination
00:31:14 <ion> Also against Haskell
00:31:19 <Ralith> I'd choose lisp for that
00:31:32 <Ralith> "What do you mean there's no metaobject protocol?"
00:31:41 <liyang> Ralith: "It's just a zygohistomorphic prepromorphism. What's the problem?"
00:31:41 <bartavelle> the point is that others won't know yours well enough to be able to formulate a correct retort
00:31:44 <shachaf> I never metaobject protocol I didn't like.
00:31:58 <Ralith> liyang: that's trolling with math.
00:32:17 <ion> Metaobject protocol? I hardly know her.
00:36:44 <startling> bartavelle: fmap fmap fmap is a fun one
00:38:21 <bartavelle> yes it is
00:38:32 <Ralith> :t fmap fmap fmap
00:38:33 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
00:38:39 <pdxleif_> @pl fmap fmap fmap
00:38:39 <lambdabot> fmap fmap fmap
00:38:47 <pdxleif_> Oh, duh, I guess
00:38:51 <Ralith> @unpl fmap fmap fmap
00:38:52 <lambdabot> fmap fmap fmap
00:38:54 <Ralith> aw
00:39:05 <bartavelle> @google fmap fmap fmap
00:39:06 <bartavelle> ;)
00:39:06 <lambdabot> http://stackoverflow.com/questions/8736995/fun-with-repeated-fmap
00:39:07 <lambdabot> Title: haskell - Fun with repeated fmap - Stack Overflow
00:39:11 <startling> > (fmap fmap fmap) (+ 1) (Just (Just 12))
00:39:12 <lambdabot>   Just (Just 13)
00:40:15 <pdxleif_> That result looks like (fmap . fmap)
00:40:33 <startling> > (fmap fmap fmap) (+ 1) (const . Just 1) "hello"
00:40:35 <lambdabot>   Couldn't match expected type `t -> a'
00:40:35 <lambdabot>         against inferred type `Data.M...
00:40:39 <startling> bah
00:40:45 <pdxleif_> :t (fmap . fmap)
00:40:47 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
00:40:49 <startling> pdxleif_: same thing
00:40:54 <shachaf> > fmap fmap fmap fmap (fmap (fmap fmap fmap fmap) fmap fmap fmap) (+ 1) Just Just 12
00:40:55 <lambdabot>   Just (Just 13)
00:41:19 <pdxleif_> Oh, fmap on functions is (.), or something.
00:41:24 <startling> pdxleif_: yep
00:41:29 <startling> (.).(.) is fun too
00:41:51 <pdxleif_> And join is "duplicate the argument" or something.
00:42:03 <shachaf> > fmap fmap fmap fmap (fmap fmap fmap fmap (fmap fmap) fmap fmap fmap fmap fmap fmap fmap fmap fmap) (+ 1) Just Just 12
00:42:04 <lambdabot>   Just (Just 13)
00:42:07 <startling> > let (.:) = (.).(.) in ((+ 1) . (+)) 12 13
00:42:10 <lambdabot>   26
00:42:11 <shachaf> Hmm, that's not an improvement.
00:42:54 <startling> you know how some cultures have few words but lots of inflectional and tonal qualities?
00:42:59 <startling> we need to do that with fmap
00:43:03 <lpvb> what's with all the fmaps
00:43:19 <pdxleif_> fmap party!
00:43:36 <pdxleif_> Bring your favourite functors.
00:43:46 <shachaf> > fmap fmap fmap fmap (fmap (fmap fmap fmap fmap) fmap fmap) fmap fmap (fmap fmap fmap fmap (fmap fmap) fmap fmap fmap fmap fmap fmap fmap) fmap fmap (+ 1) Just Just 12
00:43:46 <startling> :t fmap forever
00:43:48 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Monad m, Functor f) => f (m a) -> f (m b)
00:43:48 <lambdabot>   Just (Just 13)
00:44:06 <startling> lpvb: talking about trolling coworkers
00:44:30 <lpvb> turn everything into pointless?
00:45:13 <shachaf> > fmap (fmap fmap fmap fmap) fmap fmap fmap fmap (fmap (fmap fmap fmap fmap) fmap) fmap fmap fmap (fmap fmap fmap fmap (fmap fmap) fmap fmap fmap fmap fmap fmap fmap) fmap fmap (+ 1) Just Just 12
00:45:14 <lambdabot>   Just (Just 13)
00:45:16 <ion> @pl \fmap -> fmap fmap fmap fmap (fmap (fmap fmap fmap fmap) fmap fmap) fmap fmap (fmap fmap fmap fmap (fmap fmap) fmap fmap fmap fmap fmap fmap fmap) fmap fmap
00:45:18 <lambdabot> join (join (join (join (join (join (join id)) `ap` join (join (ap id (join (join (join id))))))) `ap` join (join (join (join (join (join (join (join (join (join id)) `ap` join id)))))))))
00:45:27 <ion> Too bad it won’t work.
00:45:40 <shachaf> Too bad @pl is untyped.
00:45:46 <shachaf> @pl (\x -> x x) (\x -> x x)
00:45:50 <lambdabot> ap id id (ap id id)
00:45:50 <lambdabot> optimization suspended, use @pl-resume to continue.
00:46:08 <shachaf> @pl (\x -> outR x x) (InR (\x -> outR x x))
00:46:09 <lambdabot> join outR (InR (join outR))
00:46:52 <shachaf> @ty join outR (InR (join outR))
00:46:54 <lambdabot> forall a. a
00:49:49 <Nereid> "<lambdabot> optimization suspended, use @pl-resume to continue."
00:49:51 <Nereid> I like that.
00:49:58 <Nereid> @pl \x -> x x
00:49:59 <lambdabot> join id
00:50:01 <Nereid> aw.
00:50:16 <shachaf> @pl join id (join id)
00:50:17 <lambdabot> join id (join id)
00:50:26 <shachaf> @pl join id (ap id id)
00:50:27 <lambdabot> join id (join id)
00:50:30 <shachaf> @pl ap id id (join id)
00:50:31 <lambdabot> join id (join id)
00:50:32 <shachaf> @pl ap id id (ap id id)
00:50:35 <shachaf> Pft.
00:50:36 <lambdabot> ap id id (ap id id)
00:50:36 <lambdabot> optimization suspended, use @pl-resume to continue.
00:50:38 <Nereid> haha
00:50:40 <ion> @unpl join id (join id)
00:50:40 <lambdabot> ((\ a -> a) >>= \ c -> c) ((\ b -> b) >>= \ e -> e)
00:50:54 <shachaf> @ty outR
00:50:56 <lambdabot> forall a. Rec a -> Rec a -> a
00:51:10 <ion> @src REc
00:51:10 <lambdabot> Source not found.
00:51:12 <ion> @src Rec
00:51:12 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
00:51:29 <shachaf> Rec++
00:57:46 <jfischoff> edwardk: I was comparing your tyvar substitution in Language.Haskell.TH.Lens to the one in Template Your Boiler Plate (i.e. subst') and there is subtly difference. With subst' ForallT's TyVarBndrs "hide" the enclosed vars. Not sure what is "expected"
00:58:51 <edwardk> well, the one i have avoids traversing the variables that are bound
00:59:34 <edwardk> that is the behavior i expect for substitution =) it should ignore bound variables completely
01:00:54 <edwardk> and the ForalllT'd TyVarBndr's in lens also hide the named variables
01:00:56 * hackagebot yesod-platform 1.1.4 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.4 (MichaelSnoyman)
01:00:58 * hackagebot aws 0.7.3 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.3 (MichaelSnoyman)
01:01:01 <edwardk> so i'm not sure i see the difference
01:01:13 <jfischoff> well I guess I misread it then
01:01:15 <edwardk> typeVarsEx s f (ForallT bs ctx ty) = ForallT bs <$> typeVarsEx s' f ctx <*> typeVarsEx s' f ty       where s' = s `Set.union` setOf typeVars bs
01:01:21 <edwardk> see the construction of s'?
01:01:39 <jfischoff> wait I am looking at something else
01:01:52 <jfischoff> I'm looking at SubstType Type
01:02:07 <edwardk> ah
01:02:23 <edwardk> i suppose i could make that a little more pedantic, yes
01:02:32 <jfischoff> I don't know
01:02:56 <edwardk> the current behavior there would be to do the same thing
01:03:06 <edwardk> make a substTypeEx, extend it, etc.
01:03:46 <jfischoff> ah
01:03:59 <edwardk>  er s/current/correct/
01:04:08 <jfischoff> right
01:04:20 <jfischoff> like typeVarsEx I guess
01:05:03 <jfischoff> well anyway, looks like it going to be a big showing :)
01:05:10 <edwardk> apparently
01:05:25 <edwardk> trying to keep my voice ;)
01:05:34 <jfischoff> :)
01:05:56 * hackagebot aws-sdk 0.4.0.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.4.0.0 (YusukeNomura)
01:06:14 <edwardk> (it is actually a serious concern, i've had a running cough for the last 3 months that the doc just diagnosed as walking pneumonia and my wife lost her voice all weekend)
01:06:24 <jfischoff> fuck
01:06:31 <jfischoff> dude
01:07:12 <edwardk> i came home early on thursday, skipped work friday, and will probably skip out today and barring a sudden recovery, will likely miss tomorrow too
01:07:46 <jfischoff> I wish you the best. Been fighting a sore throat myself
01:07:51 <jfischoff> but not that bad
01:08:01 <edwardk> by wednesday the antibiotics should have run their couse at least
01:08:10 <edwardk> and i just realized we weren't in #haskell-blah ;)
01:08:20 <t7> im ill :(
01:08:26 <jfischoff> haha
01:08:32 <t7> slept all weekend, missed a dinner party
01:08:34 <jfischoff> its late whatever
01:08:44 <jfischoff> speaking of which goodnight!
01:08:58 <edwardk> if we're not allowed to record at google, i'll just have to do another version of the talk down in new york or something and record it there
01:08:59 <t7> its 9am....
01:09:31 <edwardk> i _want_ a version of this online somewhere ;)
01:12:05 <nyc> Unless things turn around, I probably won't be able to hear of it or make it there even though in New York.
01:14:04 <edwardk> doh, whats going on?
01:15:15 <nyc> Woops, #haskell-blah
01:15:27 <edwardk> k
01:16:44 <edwardk> @tell jfischoff   substType m (ForallT bs ctx ty) = ForallT bs (substType m' ctx) (substType m' ty) where m' = foldrOf typeVars Map.delete m bs
01:16:45 <lambdabot> Consider it noted.
01:23:40 <killy9999> I need help with QuickCheck
01:23:58 <killy9999> is there a way to control number of generated test sets for one particular test?
01:25:56 * hackagebot lens 3.0.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.0.3 (EdwardKmett)
01:25:58 <xnor> x
01:26:37 <shachaf> killy9999: quickCheckWith?
01:27:49 <astropirate> Do people use tabs or spaces with haskell code
01:28:04 <shachaf> Spaces.
01:28:56 <astropirate> cool
01:28:59 <Itkovian> Every time I have not used Haskell for a while, I am totally flabbergasted at the new concepts and ideas that have popped up. And my lag gets ever bigger. Which seems like a good thing :-p
01:29:03 <killy9999> astropirate: http://www.emacswiki.org/emacs/TabsSpacesBoth
01:29:36 <astropirate> hahah
01:29:50 * killy9999 has recently found code on Hackage that uses tabs and all layout is screwed up :<
01:30:00 <killy9999> ahachaf: thanks, I also found mapSize
01:30:08 <rking> Tabs are such a bad idea.
01:30:20 <killy9999> but using it with two nested forAll is very tricky
01:30:34 <killy9999> seems that I'm getting 100*100 tests instead of 100
01:30:48 <astropirate> I guess "the great debate" for using spaces vs tabs is over with spaces winning?
01:31:22 <killy9999> I guess so
01:31:42 <pettter> imo, you should use either, but not both, for indentation
01:31:47 <pettter> and only spaces for alignment
01:31:49 <killy9999> I have tabs = 2 spaces on my system, so practically all code using tabs is displayed incorrectly
01:32:09 <killy9999> petter: look at the link I posted above ;)
01:32:21 <astropirate> http://www.thehouseofwhy.com/wp-content/uploads/2012/04/TP-The-Great-Debate1.jpg
01:32:28 <pettter> killy9999: :)
01:32:52 <killy9999> astropirate: I'm definitely for A
01:32:53 <pettter> killy9999: well, the problem is that people tend to conflate indentation and alignment
01:33:04 <pettter> so using only spaces makes things "simple"
01:33:05 <astropirate> killy9999, grrr you are one of those <_<
01:33:45 <sp3ctum> imo using mixed tabs and spaces is not worth the effort
01:39:56 <hirsch_> Using spaces is like usung static typing, using tabs is like dynaic typeing, you may get faster results but is more unsafe
01:40:45 <osfameron> the whole problem is that editors are stupid
01:40:53 <osfameron> tabs are conceptually right
01:41:05 <osfameron> but practically a pain in the arse
01:41:24 <pettter> also, alignment
01:42:14 <Ralith> if we're going to rely on structure-aware editors, we might as well just store code as ASTs
01:42:23 <osfameron> that would be cool
01:43:35 <astropirate> owwww yah
01:44:16 <pettter> Ralith: make that work with Any Editor, and I'm all for it
01:44:28 <astropirate> so i just reached chapter 7 of learn you a haskell. went to look at the chapters to realise i was only half way through the book. I am depressed now :( :(
01:44:29 <pettter> start with vi, and work your way up from there :P
01:45:04 <osfameron> astropirate: surely you should be happy you've got so much more fun learning ahead of you!
01:45:17 <astropirate> yah......
01:45:18 <astropirate> but
01:45:22 <astropirate> I want to make stuff already
01:45:23 <astropirate> :D
01:45:30 <lpvb> you can already make stuff
01:45:32 <astropirate> I learn by making
01:45:34 <lpvb> you just don't realize it
01:45:35 <astropirate> really?
01:45:38 <astropirate> i dontk now monads
01:45:42 <astropirate> and IO
01:45:50 <lpvb> okay maybe not
01:45:53 <astropirate> lol
01:45:56 <lpvb> you need to at least know IO
01:46:06 <astropirate> yah, if i knew IO i wouldnt have already started
01:46:11 <astropirate> i'm trapped!
01:46:37 <osfameron> getting started with IO is easy
01:46:41 <Ralith> pettter: I'm savvy to your challenges.
01:46:44 <lpvb> what do you want to make?
01:46:51 <Ralith> you'll just write a trivial editor that doesn't support it the moment I finish!
01:46:54 <osfameron> and when you get stuck just nopaste code and ask here for help
01:47:03 <astropirate> I want to make a very simple web application for starters
01:47:16 <astropirate> not using any of the frameworks
01:47:17 <pettter> Ralith: ;)
01:51:05 * hackagebot msgpack-rpc 0.9.0 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.9.0 (HideyukiTanaka)
01:55:29 <Nereid> astropirate: you could skip straight to chapter 9. there's not much in 7 or 8 that you need in 9
01:56:00 <Nereid> or at least
01:56:16 <Nereid> you could see how far in chapter 9 you can get.
01:56:24 <Nereid> I dunno.
01:56:25 <astropirate> I found this  http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell
01:56:31 <astropirate> seems to go at a pace I like
01:56:39 <Nereid> or that
01:56:45 <astropirate> :) tnx
01:57:48 <cornihilio> hey, is there a way to turn a word32 into a number like .0023456 instead of 23456. What should I do? What should I be googling to do that?
01:58:57 <quicksilver> how would a Word32 represent a fractional number?
01:59:05 <quicksilver> There are lots of ways it might.
01:59:14 <quicksilver> decide which one you want and it's simple enough.
01:59:39 <ClaudiusMaximus> > (('.' :) . reverse . take 7 . (++ repeat '0') . reverse . show) 23456
01:59:42 <lambdabot>   ".0023456"
02:00:17 <ClaudiusMaximus> @instances-importing Num Data.Fixed
02:00:18 <lambdabot> Couldn't find class `Data.Fixed'. Try @instances-importing
02:00:23 <ClaudiusMaximus> @instances-importing  Data.Fixed Num
02:00:25 <lambdabot> Double, Fixed a, Float, Int, Integer
02:00:37 <atriq> > ((read :: String -> Double) . ('.' :) . reverse . take 7 . (++ repeat '0') . reverse . show) 23456
02:00:40 <lambdabot>   *Exception: Prelude.read: no parse
02:00:53 <atriq> > ((read :: String -> Double) . ("0." ++ ) . reverse . take 7 . (++ repeat '0') . reverse . show) 23456
02:00:56 <lambdabot>   2.3456e-3
02:01:06 <atriq> > ((read :: String -> CDouble) . ("0." ++ ) . reverse . take 7 . (++ repeat '0') . reverse . show) 23456
02:01:08 <lambdabot>   Not in scope: type constructor or class `CDouble'
02:01:14 <atriq> > ((read :: String -> CFloat) . ("0." ++ ) . reverse . take 7 . (++ repeat '0') . reverse . show) 23456
02:01:16 <lambdabot>   Not in scope: type constructor or class `CFloat'
02:01:20 <atriq> Oh no!
02:06:11 * hackagebot hxt 9.3.1.1 - A collection of tools for processing XML with Haskell.  http://hackage.haskell.org/package/hxt-9.3.1.1 (UweSchmidt)
02:10:25 <cornihilio> what do you get when you add an Int64 and a Double?
02:10:27 <cornihilio> a Double?
02:11:01 <startling> cornihilio: you can't add those
02:11:11 * hackagebot bcrypt 0.0.4 - Haskell bindings to the bcrypt password hash  http://hackage.haskell.org/package/bcrypt-0.0.4 (AndrewMiller)
02:11:16 <startling> .seen edwardk
02:11:21 <startling> preflex: seen edwardk
02:11:22 <preflex>  edwardk was last seen on #haskell-blah 54 minutes and 13 seconds ago, saying: =/
02:11:26 <startling> bah
02:12:02 <dibblego> Ed just said he is going to sleep 10 minutes ago
02:12:20 <atriq> So he should be awake by now!
02:12:20 <atriq> Yay!
02:13:29 <startling> dibblego: darn. thought I should let him know that the new lens is haddock-less
02:13:41 <startling> http://hackage.haskell.org/package/lens
02:14:02 <dibblego> startling: looks more like a hackage issue
02:14:11 <shachaf> startling: Patience.
02:14:12 <dibblego> startling: you can always generate your own right?
02:14:17 <startling> dibblego: oh, could be
02:14:26 <startling> does it take a while after uploading? didn't know that
02:15:11 <startling> anyway, does anyone remember where the Writer lens combinators were? were there any State combinators?
02:15:15 <dibblego> startling: usually not more than a day (Oct 15)
02:15:33 <dibblego> startling: I spend a lot of time grepping Ed's code to answer questions like that — I recommend the .tar.gz
02:15:38 <shachaf> startling: Just click on the 3.0.2 link at the top.
02:15:44 <shachaf> All the documentation is there.
02:15:46 <startling> shachaf: yes, I'm there
02:15:52 <startling> dibblego: good call
02:28:41 <cornihilio> how do I print a double value without scientific notation? as in, I don't want this: 1.5280074230265038e9
02:30:54 <fmap> > printf "%f" 1.5280074230265038e9 :: String
02:30:55 <lambdabot>   "1528007423.0265038"
02:32:02 <opqdonut> > printf "%f" 1.27e100 :: String
02:32:03 <lambdabot>   "12700000000000000000000000000000000000000000000000000000000000000000000000...
02:32:13 <opqdonut> oh, it does eliminate scientific notation
02:35:09 <startling> @hoogle Functor f => (a -> m b) -> f a -> m (f b)
02:35:10 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:35:10 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:35:10 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
02:35:29 <startling> oh, *that's* what traverse is for
02:35:42 <startling> knew I would get there eventually
02:35:52 * spacekitteh sighs
02:36:08 <spacekitteh> compiling ghc produces a segfault
02:36:40 <startling>  @hoogle Functor f => (a -> m b) -> f a -> m ()
02:36:54 <atriq> spacekitteh, do you know why?
02:36:57 <startling> @hoogle Functor f => (a -> m b) -> f a -> m ()
02:36:57 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
02:36:58 <lambdabot> Data.Foldable mapM_ :: (Foldable t, Monad m) => (a -> m b) -> t a -> m ()
02:36:58 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
02:37:04 <spacekitteh> atriq: nope.
02:37:19 <atriq> (why are you compiling GHC?)
02:37:21 <startling> oh, neat
02:37:31 <spacekitteh> astriq: gentoo, yo
02:37:37 <atriq> Aaaah
02:37:46 <atriq> You kind of need GHC to compile GHC
02:37:54 <spacekitteh> yeah
02:37:57 <spacekitteh> i have it installed
02:38:00 <spacekitteh> but am upgrading
02:38:01 <cornihilio> fmap: how would I do that so that I can store the result as a String?
02:38:30 <fmap> cornihilio: I showed you?
02:38:45 <GnomeStoleMyBike> @nixon
02:38:45 <lambdabot> It is necessary for me to establish a winner image. Therefore, I have to beat somebody.
02:39:11 <fmap> cornihilio: `:: String' part is important, printf is polymorphic in its return type.
02:39:36 <fmap> :t printf
02:39:37 <lambdabot> forall r. (PrintfType r) => String -> r
02:40:31 <cornihilio> oh, so printf doesn't actually print... I thought it was like print. My bad!
02:40:40 <atriq> It can do
02:40:45 <atriq> But it can just return a string
02:40:45 <fmap> cornihilio: it could print
02:40:53 <fmap> > printf "%f" 1.5280074230265038e9 :: IO ()
02:40:54 <lambdabot>   <IO ()>
02:45:54 <cornihilio> fmap: what does this mean?: No instance for (Data.String.IsString (Double -> String)) arising from the literal `"%f"'
02:46:12 <cornihilio> right now I have: print (TP.printf $ "%f" (packetTime p) :: String)
02:46:30 <shachaf> It means get rid of that $
02:46:48 <spacekitteh> atriq: gmp-wrappers__1.o: file not recognized: file truncated
02:46:51 <shachaf> And probably stop using $ -- it's a bad habit. :-)
02:46:53 <spacekitteh> :s
02:47:01 <atriq> Sounds like a dodgy download
02:47:42 <spacekitteh> indeed. gona retry it
02:51:47 <tdammers> shachaf: what's so bad about $ ?
02:52:45 <shachaf> Nothing, though people tend to overuse it when they start out.
02:53:05 <tdammers> mkay
02:53:38 <shachaf> But you should understand how Haskell syntax works before using it.
02:53:49 <tdammers> yeah, I get that
02:54:12 <tdammers> I used to do `foo . bar . baz $ quux` a lot
02:54:36 <tdammers> until it occurred to me that I could also do foo $ bar $ baz quux
02:54:51 <Psycho_pr> schachaf: hi
02:57:48 <Cale> tdammers: The composition has the advantage that for instance bar . baz is a meaningful thing, while bar $ baz wouldn't be
03:00:18 <startling> the _1 lens should apply to unary functions, too
03:00:42 <startling> same with _2 and binary functions.
03:02:03 <Cale> What would view cos be?
03:02:57 <Cale> er, view _1 cos
03:03:52 <Cale> (maybe I'm misinterpreting what you mean)
03:04:21 <tdammers> Cale: I guess what I mean is that there are several ways of expressing the same thing
03:04:38 <tdammers> which is good, because it means I can pick the syntax variant that most closely matches my intent
03:05:03 <Cale> yeah, though a number of us would really like to be able to flip the associativity of $
03:05:28 <Cale> (so that it's left associative like function application usually is)
03:05:28 <pejo> I'm trying to get ghci to take a local source directory in . for one of the modules. I type "ghci -ipackage/src myfile.hs" to start ghci and then :m + package and ghci gives the response that it can't find the module. What am I missing?
03:05:33 <tdammers> isn't flipping associativity the whole point of $ in the first place?
03:05:38 <Cale> No
03:05:40 <tdammers> hm
03:05:47 <Cale> The whole point of $ is low precedence
03:05:50 <tdammers> ah right
03:05:52 <tdammers> yeah
03:06:03 * tdammers was confused for a second there
03:06:34 <tdammers> you could just define your own operator for that though
03:06:44 <Cale> Well, that would be silly
03:06:51 <tdammers> maybe
03:07:04 <tdammers> it would certainly not help readabilityh
03:07:21 <dibblego> why does Data.Set define a non-exported function foldlStrict instead of use foldl' ?
03:08:02 <dibblego> er scratch that, was looking at 6.4.1
03:08:43 <Cale> dibblego: hmm, it's still there in the latest containers
03:08:57 <dibblego> oddballs, it's not in http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.5.0.0/src/Data-Set.html
03:09:28 <Cale> dibblego: http://hackage.haskell.org/packages/archive/containers/0.5.1.0/doc/html/src/Data-Set-Base.html#Set
03:09:45 <Cale> http://hackage.haskell.org/packages/archive/containers/0.5.1.0/doc/html/src/Data-Set-Base.html#foldlStrict  rather
03:09:52 <dibblego> oh wait a minute, I'm having a shocker, sorry
03:09:59 <dibblego> yeah
03:10:11 <Cale> (also 0.5.0.0 in the same location)
03:10:31 <Cale> Maybe historical reasons?
03:10:40 <dibblego> I was originally looking for the source to fromList which uses foldlStrict, but now it doesn't, with a strange comment above
03:10:49 <Cale> Perhaps trying harder to get it to inline?
03:10:54 <sordina> Hey. Is there a way to make 'when' operate on a monadic condition while still allowing you to pass it a do block nicely?
03:10:58 <dibblego> yeah that's the comment
03:11:19 <dibblego> sordina: do when p a -- will work fine
03:12:31 <sordina> Basically I'd like mwhen :: Monad m => m Bool -> m () -> m ()
03:13:27 <sordina> dibblego: I'm more after a combinator that can be used inline if it exists.
03:13:36 <dibblego> sordina: that's just composed with return innit?
03:13:53 <dibblego> @type when . return
03:13:55 <lambdabot>     Couldn't match expected type `Bool' against inferred type `m a'
03:13:55 <lambdabot>       Expected type: a -> Bool
03:13:55 <lambdabot>       Inferred type: a -> m a
03:14:04 <merijn> sordina: "p >>= flip when (do ...)"?
03:14:10 <alpounet> mwhen mb action = do { b <- mb ; when b action } -- sordina
03:14:10 <dibblego> oh yeah, you know what I mean
03:14:16 <Cale> other way around -- sordina wants to run the action to get a Bool first
03:14:25 <dibblego> oh I see
03:14:28 <sordina> merijn: Yes, I'd come across that, but then you need the parens.
03:14:29 <merijn> :t p >>= flip when
03:14:31 <lambdabot>     Couldn't match expected type `m a' against inferred type `Expr'
03:14:31 <lambdabot>     In the first argument of `(>>=)', namely `p'
03:14:31 <lambdabot>     In the expression: p >>= flip when
03:14:39 <merijn> :t undefined >>= flip when
03:14:40 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m ()
03:14:48 <sordina> and you can't leave the second arg off when.
03:15:11 <dibblego> second argument? blasphemy!
03:15:16 <Cale> yeah, it's the wrong way around to make that easy :)
03:15:22 <dibblego> all haskell functions take one argument :)
03:15:23 <merijn> sordina: I'd just define mwhen then :p
03:15:33 <Cale> whenM?
03:15:39 <sordina> dibblego: well yes, I understand that, but >>= doesn't :P
03:15:45 <dibblego> sordina: it does
03:15:53 <dibblego> but yeah I had it the other way around
03:16:18 <dibblego> sordina: as an aside, it's handy to remember that *all* haskell functions take one argument (including (>>=))
03:16:22 <sordina> dibblego: not in a way that solves this problem unless I've missed something.
03:16:49 <dibblego> sordina: I'm not sure what you've missed — perhaps you can explain? all functions, one argument
03:17:02 <Cale> \c x -> c >>= flip when x
03:17:04 <Cale> :t \c x -> c >>= flip when x
03:17:06 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
03:17:07 <sordina> dibblego: I'm well aware of the one argument philosophy :) Just trying to see if something convenient exists.
03:17:25 <Cale> (not terribly nice)
03:17:29 <dibblego> sordina: I don't mean it as a philosophy, but a critical piece of information
03:17:45 <Cale> @pl \c x -> c >>= flip when x
03:17:47 <lambdabot> (. flip when) . (>>=)
03:18:22 <Cale> @pl \x c -> c >>= flip when x
03:18:23 <lambdabot> (=<<) . flip when
03:18:29 <cornihilio> sorry, I asked this earlier but I must have deleted my example code. how do I convert bytestring to hex?
03:18:31 <sordina> What I'm saying is, if you're under the impression that I think there are functions with more than one argument, then you're mistaken. It's still convenient to speak of functions that way though.
03:18:51 <Cale> sordina: agreed
03:19:40 <dibblego> sordina: I'm only going off your original statement, "can't leave the second arg off when" where I am not sure what to make of that even in light of that convenience
03:19:51 <sordina> Cale: That looks great!
03:20:12 <dibblego> @type \p -> (>>=) p . flip when
03:20:13 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
03:20:56 <Cale> > foldr (\x f xs -> f (x:xs)) id [1,2,3] [] -- foldr is clearly a 4 parameter function
03:20:58 <lambdabot>   [3,2,1]
03:21:59 <merijn> dibblego: Because leaving the second argument of when in my definition results in a completely different type for the result, a type that won't work for the goal
03:22:20 <merijn> sordina, Cale: Doesn't monad-loops have something like this?
03:23:01 <sordina> dibblego: try currying mwhen (mwhen c a = c >>= flip when a) by removing 'a'. That's what I'm referring to.
03:23:18 <dibblego> sordina: ap will help you there
03:23:45 <dibblego> sorry I misread
03:24:16 <cornihilio> sorry, I asked this earlier but I must have deleted my example code. how do I convert bytestring to hex?
03:24:48 <sordina> Anyway, I'll just define mwhen for now. It's not too bad :)
03:25:16 <sordina> Thanks for your help as always!
03:26:04 <dibblego> @type @type \p -> (>>=) p . (\x -> (`when` x)) -- like this?
03:26:05 <lambdabot> parse error on input `@'
03:26:07 <dibblego> @type \p -> (>>=) p . (\x -> (`when` x)) -- like this?
03:26:09 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
03:26:32 <pejo> Alternatively, is there some way to print the include path from inside ghci?
03:26:40 <Shapeshifter> I want to try out Yesod but I run into trouble when I want to start the default project made by yasod init. First, there's a whole bunch of missing dependencies; bytestring, directory, hjsmin, persistent-sqlite. I have ghc 7.6.1 and cabal-install 1.16.0 from the archlinux repositories, everything else I installed through cabal. If I do 'cabal install bytestring directory hjsmin persistent-sqlite' it just completely craps out like ...
03:26:47 <Shapeshifter> ... this: http://pastie.org/5061281 . So I was able to install bytestring manually, but installing hjsmin failed, first because happy was missing, so I installed that, now alex is missing, so I installed that, and now it's failing because "The program alex version ==3.0.1 is required but the version found at /home/shapeshifter/.home/.cabal/bin/alex is version 3.0.2". This is aggravating.
03:27:06 <Shapeshifter> tbh, cabal is rather underwhelming in its dependency handling.
03:27:21 <Shapeshifter> How do I solve this? Do I really need to pull in an older version of alex?
03:27:31 <sordina> dibblego: yes, that will work, but at this point it's not a simple combinator anymore, so there's no gains to be made by using it :(
03:27:38 <dibblego> sordina: yeah agreed
03:28:18 <merijn> Shapeshifter: You probably want to downgrade to ghc-7.4
03:28:27 <dibblego> @type \c x -> c >>= (`when` x) -- there it this
03:28:29 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
03:28:31 <GnomeStoleMyBike> @nixon
03:28:31 <lambdabot> I played by the rules of politics as I found them.
03:28:36 <merijn> Shapeshifter: 7.6 is not ready and arch (as usuall) is throwing its users of a cliff by making it the default
03:28:46 <Shapeshifter> merijn: I see.
03:28:57 <Shapeshifter> merijn: yeah it happens.
03:29:18 <merijn> Shapeshifter: The usual recommendation is to install Haskell Platform, they make sure all the major haskell libraries work together and with the compiler they ship
03:29:23 <sordina> dibblego: That's just my original definition wrapped in a lambda (and with a section) :P
03:29:39 <merijn> Shapeshifter: (Right now they're still on GHC 7.4, they will move to 7.6 in one of the next two releaes)
03:29:44 <dibblego> yes, the "second argument" is left off in both cases
03:29:55 <Shapeshifter> merijn: the recommendation is bypassing the distro package manager?
03:30:00 <Shapeshifter> for all things haskell?
03:30:22 <merijn> Shapeshifter: I dunno, I'm not really doing the linux thing, so I'm unsure what other people do on linux
03:30:28 <Shapeshifter> Ah ok.
03:30:37 <merijn> Shapeshifter: On OSX I just install platform and use cabal for fetching any further haskell dependencies
03:30:44 <Shapeshifter> I see.
03:30:51 <tdammers> same on debian
03:31:14 <tdammers> although debian stable has ghc 6.something, wheezy works much better
03:31:54 <Shapeshifter> merijn: although http://www.haskell.org/ghc/download gives no indication that 7.6 is in any way 'not ready'.
03:32:15 <sordina> Not the second argument to 'flip'. What I was trying to achieve was the ability to place the 'do block' after the function without any parenthesis.
03:32:16 <merijn> Shapeshifter: oh, the compiler is production ready, but the ecosystem hasn't caught up yet
03:32:42 <sordina> Anyhow, much food for thought. Thanks :)
03:32:58 <merijn> Shapeshifter: For example, the exception handling function Prelude.catch (deprecated for over a year) has been removed and a lot of packages haven't been fixed yet to use Control.Exception.catch causing them to break when you try to compile using 7.6
03:34:01 <merijn> Shapeshifter: Getting every library caught up with all changes takes some time. Which is exactly the thing that Haskell Platform tries to achieve, they not only want to ship a working compiler, but also a working set of major libraries (yesod, parsec, whatever else)
03:34:17 <Shapeshifter> merijn: makes sense.
03:34:50 <merijn> So they test everything builds and installs correctly, etc.
03:35:25 <fmap> yesod is in platform?
03:35:43 <alpounet> no
03:35:55 <merijn> fmap: I dunno, I was trying to think of big libraries
03:36:19 <fmap> yesod feels like a half of hackage :)
03:36:30 <tdammers> yeah
03:36:37 <tdammers> one of the reasons why I prefer happstack
03:37:18 <tdammers> also how yesod includes everything and their dog, even things not everyone needs
03:37:27 <merijn> yesod is a nice way to build a whole bunch of basic libraries in one go ;)
03:39:26 <Shapeshifter> by the way, if I want to get rid of everything I did using cabal, can I just delete ~/.cabal or do I need to unregister all the packages as well?
03:41:02 <fmap> Shapeshifter: the latter, you can do it by removing ~/.ghc
03:41:38 <fmap> (assuming you didn't install anything with --global)
03:41:48 <pejo> Ok, worked around the issue by installing the package instead of trying to load it in ghci by passing -i and giving a :m-command.
03:42:19 <alpounet> Shapeshifter, to avoid having to do that often, you should take a look at cabal-dev and its alternatives
03:42:33 <alpounet> this allows to have per-project package databases
03:42:45 <alpounet> (and a bit more)
03:43:14 <OODavo> Trying to install Pandoc with "cabal install pandoc", I appear to be having dependency problems: http://sprunge.us/VOjW
03:43:17 <Shapeshifter> I see
03:43:17 <OODavo> I've got GHC 7.4.1 running on Mint.
03:45:17 <fmap> OODavo: does `ghc-pkg check' say anything?
03:45:51 <OODavo> fmap: Yes, but only Haddock warnings ( http://sprunge.us/YBFJ ).
03:51:15 <fmap> OODavo: that error suggests you've reinstalled some core library such as directory or process which comes with ghc
03:51:27 <fmap> (via cabal-install or something)
03:52:10 <OODavo> Quite possible. How would I go about fixing such a problem?
03:53:33 <fmap> no idea besides `rm ~/.cabal ~/.ghc' and reinstalling everything while being paranoid about reinstalls
03:53:41 <fmap> probably there is better way
03:54:31 <merijn> What library/typeclass/whatever do I want for serialising data structures?
03:54:38 <t7> Binary
03:54:41 <startling> merijn: cereal is nice
03:54:50 <atriq> Has anyone got GHC working on Haiku?
03:54:57 <startling> merijn: depends what you mean by "serialising", though
03:55:10 <t7> converting to bytestring?
03:55:30 <merijn> startling: Putting into some represenation suitable to sending over the wire
03:55:37 <Psycho_pr> Does anyone have a good book in Russian for learning Haskell?
03:55:39 <merijn> (i.e. ByteString or some such)
03:55:52 <OODavo> The Show and Read typeclasses are intended to allow for serialised data structures, if I recall correctly.
03:56:03 <t7> OODavo: erm... no
03:56:08 <startling> merijn: yeah, I'd use cereal
03:56:15 <t7> Data.Binary
03:56:17 <startling> I like it more than binary because it has Alternative
03:56:38 <startling> so you can do someParser <|> someOther <|> whatever
03:56:45 <OODavo> t7: Hmm? Why not? Granted, it's not the most efficient representation, but it works.
03:57:10 <startling> OODavo: show isn't intended to output code
03:57:18 <startling> if it does, that's just a nice side-effect
03:57:22 <t7> i thought it was for getting the sourcecode representation of something
03:57:26 <merijn> OODavo: They return String, which is unsuitable to sending over network
03:57:47 <merijn> t7, startling: show/read are supposed to be inverses and return valid haskell *where possible*
03:58:14 <OODavo> merijn: Ah, that reasoning makes sense. Cool.
03:58:42 <startling> merijn: fair enough
03:58:44 <t7> merijn: use cloud haskell
03:58:49 <merijn> Now I could just pack the string, but that doesn't seem very efficient
03:58:53 <t7> you can pass stuff automagically
03:58:53 <merijn> t7: Why?
03:59:38 <merijn> t7: Cloud Haskell is, afaict, nowhere near as flexible as "proper" networking yet
03:59:56 <t7> merijn: its message passing rather than sending bytes
04:00:37 <t7> merijn: whatcha working on anyway?
04:00:50 <fmap> Psycho_pr: there is LYAH translation to russian ("Изучай Haskell во имя добра!"), also https://github.com/anton-k/ru-haskell-book worth a look
04:01:33 <startling> merijn: was it you that I was talking about my css thing to? did you see my "mixin" thing?
04:02:04 <merijn> t7: A bunch of different things with ZeroMQ. One for work, which has to interact with non-haskell ZMQ code and some other for myself (like my umpteenth go at writing a game :p)
04:02:14 <merijn> startling: I think so and no?
04:02:35 <OODavo> fmap: It looks like I've built up a lot of cruft in my .ghc and .cabal directories anyway, so removing them is probably a generally good idea. (This /home partition's been used on several distro installs.) Thanks.
04:02:42 <startling> merijn: it's kind of evil but it simplifies things a lot: https://github.com/startling/mixin
04:03:13 <t7> i would have thought there were zmq binding allready
04:03:37 <merijn> t7: There are, I'm writing code using those
04:04:03 <XexonixXexillion> What are some good graph libraries for Haskell?
04:04:14 <startling> XexonixXexillion: what do you mean by "graph"?
04:04:36 <fmap> OODavo: rule of thumb to avoid removing ~/.cabal once a week is to not reinstall anything from here: http://www.haskell.org/ghc/docs/7.4.1/html/libraries/index.html
04:05:11 <XexonixXexillion> A directed graph with edges weighted by a real number between 0 and 1
04:05:33 <fmap> (by anything I mean package names on the right)
04:05:34 <startling> XexonixXexillion: ah, so graph theory graphs
04:05:38 <startling> not statistics graphs
04:05:50 <XexonixXexillion> yeah
04:07:37 <XexonixXexillion> The catch is that the length of a path is done by multiplication of the weights, not addition
04:07:43 <merijn> Is "unsafePerformIO (newTVarIO 0)" a terrible top level thing to do?
04:08:07 <luite> merijn: yesod should work with 7.6.1 now btw, although i've found some issues on OS X with yesod devel again
04:09:26 <OODavo> Is it safe to run multiple cabal installations at the same time, or will that lead to breaking my ~/.cabal again?
04:10:02 <luite> Shapeshifter: it's expected that there are some missing packages when you yesod init a proejct, yesod-platform only includes the basics, not the database dependencies. install them by using cabal install --only-dependencies
04:10:03 <int-e> merijn: should be fine; indeed the documentation of newTVarIO lists this as an intended use. (The usual caveats apply - NOINLINE etc)
04:10:33 <luite> Shapeshifter: (from the new project dir)
04:11:16 * hackagebot hsc3-process 0.7.0 - Create and control scsynth processes  http://hackage.haskell.org/package/hsc3-process-0.7.0 (StefanKersten)
04:11:18 <Shapeshifter> luite: yes. I have ghc 7.6 which is the reasons builds fail.
04:11:25 <int-e> merijn: which leaves the usual objections against global variables.
04:11:39 <Shapeshifter> luite: I'll need to think about what to do...
04:12:24 <luite> Shapeshifter: i have a full install of yesod with 7.6.1, stringsearch was the last package that failed to build, but was updated recently
04:12:39 <luite> Shapeshifter: if you cabal install yesod (not -platform which might not have caught up yet) it should work
04:12:56 <luite> Shapeshifter: then you can yesod init, and cabal install --only-dependencies from the newly generated project
04:13:05 <merijn> int-e: I want fork to keep track of the number of threads to block main, a global variable makes this TVar an implementation detail of my forkIO wrapper. Otherwise I need to spread this TVar all over my code to pass it to wherever I might spawn a thread
04:13:09 <Psycho_pr> fmap: Thanks.
04:13:10 <Shapeshifter> luite: ok thanks I'll try this.
04:13:17 <delamonpansie> hello. I have problem with gtk2hs. For some unknown reason signal onSelectionChanged of FileChooser is commented out. Which signal should I use ?
04:13:27 <luite> Shapeshifter: you might need to reset your packages before, you can do that by removing ~/.ghc
04:14:12 <delamonpansie> or how dow I know that FileChooserButton has changed? It has no signals attached to it...
04:14:24 <merijn> int-e: I'm open to better suggestions, but skeptical that any cleaner ones exist
04:14:28 <luite> Shapeshifter: (don't manually install extra packages by the way, there is no way to be sure that they'll be built correctly for the yesod project, always use cabal install --only-dependencies (or just cabal install if you also want to install the project) from your project dir)
04:15:28 <mm_freak> merijn: even though that might be an intended use that doesn't make it a good idea
04:15:38 <mm_freak> merijn: what's the purpose?
04:16:01 <merijn> mm_freak: I just mentioned the intended purpose to int-e :p
04:17:39 <mm_freak> merijn: i probably didn't really understand it…  so you have a forker that should wait for all threads to die?
04:18:02 <merijn> mm_freak: I need main to wait for all threads to exit, because when main exits it calls all running threads
04:18:36 <mm_freak> first of all you don't really need STM for that…  see QSem
04:19:02 <mm_freak> to answer your actual question you should probably have a Forker monad for main
04:19:08 <mm_freak> withForker $ do …
04:19:25 <mm_freak> (or runForker or whatever)
04:19:34 <mm_freak> that's how i would do it
04:19:50 <merijn> mm_freak: And then I need to plaster that all over my entire codebase
04:20:03 <merijn> If I want to have threads fork other threads, etc
04:20:26 <mm_freak> well, if you want to keep things IO, another approach is:  withForker $ \fork -> …
04:20:35 <merijn> Docs say QSem is deprecated
04:20:48 <mm_freak> oh
04:20:58 <mm_freak> too bad…  go with STM then =)
04:21:05 <mm_freak> but an MVar is sufficient actually
04:21:16 * hackagebot hsc3-server 0.4.0 - SuperCollider server resource management and synchronization.  http://hackage.haskell.org/package/hsc3-server-0.4.0 (StefanKersten)
04:21:17 <mm_freak> newMVar + modifyMVar
04:21:18 <luite> Shapeshifter: oh i did forget to mention that you need happy, for building language-javascript
04:21:20 <merijn> The replacement package is safesemaphore, which uses STM :p
04:21:35 <luite> Shapeshifter: but i guess you already have that (though cabal cannot handle this dependency automatically)
04:21:38 <merijn> mm_freak: How do you block until all threads are finished then?
04:21:52 <merijn> mm_freak: Or did you mean one MVar per thread?
04:22:10 <mm_freak> only one MVar (Set ThreadId)
04:22:16 <mm_freak> or well
04:22:31 <mm_freak> only one MVar (Map ThreadId (MVar ()))
04:22:47 <Shapeshifter> luite: I removed .cabal and .ghc and I'm now installing yesod which takes a moment. But iirc language-javascript couldn't be installed because it depends on an older version of alex which does not work with ghc 7.6, I think that was the problem, initially.
04:22:59 <mm_freak> then the 'fork' function takes care of signalling that MVar ()
04:23:30 <mm_freak> if you're unsure, i can code you an example
04:23:47 <hpaste> merijn pasted “global TVar” at http://hpaste.org/76312
04:24:05 <merijn> mm_freak: Seems overly complex compared to that global TVar solution...
04:24:05 <luite> Shapeshifter: hmm, i thought it only depended on the programs (programs are not managed by cabal, only libraries are)
04:24:41 <mm_freak> you can do the same without globals
04:24:51 <mm_freak> with your idea an MVar Int is sufficient
04:25:04 <luite> Shapeshifter: i don't have alex installed, only happy, by the way, so i guess you don't really need the former?
04:25:08 <merijn> mm_freak: No, because what would main block on? readMVar?
04:25:51 <merijn> mm_freak: Also, theoretically I could also do the same in brainfuck, but that doesn't make it a good idea. Neither does using global variables when they make sense...
04:26:00 <merijn> ehh
04:26:11 <merijn> neither does *not* using global variables
04:26:16 * hackagebot adict 0.3.0 - Approximate dictionary searching  http://hackage.haskell.org/package/adict-0.3.0 (JakubWaszczuk)
04:26:43 <mm_freak> you're right, STM is better
04:27:48 <merijn> mm_freak: I just don't particularly see the reason to rearchitect everything just for the sake of avoiding globals when you can conveniently limit there acces by a simple two function interface
04:27:57 <merijn> s/there/their
04:28:03 <merijn> I suck at teh english
04:31:37 <Shapeshifter> luite: I think alex was needed by yesod-platform, no problems now. yesod-1.1.2 installed fine through cabal, but if I now make a new project and run cabal install as suggested by yesod init, I get an error I don't understand: http://pastie.org/5061542 "rejecting: base-3.0.3.2, 3.0.3.1 (global constraint requires installed
04:31:42 <Shapeshifter> instance)"
04:33:07 <luite> Shapeshifter: aie, looks like the scaffold itself has not been updateted. open hachipaste.cabal and check if you have a constraint for directory < 1.2
04:33:15 <luite> change it to < 1.3
04:35:10 <Shapeshifter> luite: if I make that change and run cabal install, it fails big time: http://pastie.org/5061556
04:35:47 <Shapeshifter> luite: I assume I also need to up the needed version of bystestring?
04:35:53 <luite> Shapeshifter: oh check yesod --version
04:36:10 <luite> Shapeshifter: or have you generated this project some time ago already?
04:36:25 <Shapeshifter> luite: yesod-core version:1.1.3.1, yesod version:1.1.2. I generated it just now, a few minutes ago, fresh start.
04:36:55 <Shapeshifter> after having deleted .ghc, .cabal and after installing yesod.
04:37:50 <luite> Shapeshifter: but yeah, you need to allow bytestring 0.10 in the cabal file
04:37:54 <luite> so make the constraint < 0.11
04:38:56 <luite> Shapeshifter: ok looks like the scaffold generator is slightly out of date, i'll fix that on github
04:39:03 <Shapeshifter> luite: okay, now it's installing more dependencies... Let's see where this is going... thanks for the help.
04:39:15 <luite> Shapeshifter: but for now, just update the bytestring dependency and the rest it's complaining about in the cabal file
04:40:44 <hpaste> “Ertugrul Söylemez” pasted “Forker + waiter” at http://hpaste.org/76313
04:40:54 <mm_freak> merijn: see paste
04:41:23 <luite> Shapeshifter: did it work?
04:42:18 <Shapeshifter> luite: now I'm at the same point I was before I came here. language-javascript-0.5.5 can't be installed because it depends on alex ==3.0.1.
04:42:39 <Shapeshifter> luite: http://pastie.org/5061597
04:42:39 <anicake> hello gurus! i have only one question... is the Haskell Platform going to have its own PPA on ubuntu?
04:42:51 <hpc> PPA·
04:42:56 <hpc> ?
04:43:02 <mm_freak> merijn: globals have always stood in the way of maintainance…  i avoid them at all costs
04:43:10 <Shapeshifter> luite: and if I install alex through cabal it gets 3.0.2
04:43:27 <anicake> personal package archive?
04:44:11 <anicake> PPA = personal package archive... the new way to manage software on ubuntu...
04:44:18 <hpc> ah, dunno
04:44:22 <anicake> i am a novice
04:44:30 <anicake> ok anyway... thanks
04:44:55 <anicake> i have installed the platform just now, by the debian package...
04:45:11 <anicake> how do i upgrade when a new release of HP comes out?
04:45:47 <hpc> you would remove your old platform
04:45:51 <anicake> would running the deb installer auto replace the old?
04:45:52 <luite> Shapeshifter: ah, alex --version tells you that you have 3.0.2?
04:46:02 <Shapeshifter> luite: yes.
04:46:27 <anicake> ahan...
04:46:28 <hpc> generally you don't upgrade until you install other things that depend on newer platform stuff
04:46:38 <hpc> and then, cabal will do it automagically
04:46:53 <anicake> oh yes.. i forgot about that.... thanks very much
04:46:56 <DanMere34567> evening guys.
04:47:04 <anicake> bye
04:47:13 <luite> Shapeshifter: it's a program, so if you really want it, you can build just alex 3.0.1 with ghc 7.4 and use that
04:47:30 <anicake> #exit
04:47:50 <anicake> #quit
04:47:54 <Shapeshifter> luite: I... don't really want it. I'd just like to try yesod and I can't ^^
04:48:28 <DanMere34567> got a question, i am getting into a bit of a pickle with loading modules/files. could someone explain how to do it when you have all the files in the same directory. what do i need to do with the main file? and how should i set up the sub files?
04:48:49 <DanMere34567> im trying to make my own.
04:49:09 <hpc> you always set up your directory structure to match the module structure
04:49:16 <Shapeshifter> luite: language-javascript wants alex, apparently. It's odd that you don't have alex.
04:49:18 <luite> Shapeshifter: yeah i see the problem, the language-javascript author uploaded a new version that breaks yesterday
04:49:25 <hpc> so if your main module is at /foo/bar/Main.hs
04:49:27 <Shapeshifter> luite: ah.
04:49:44 <luite> Shapeshifter: you can install the whole thing by doing cabal install --only-dependencies --constraint=language-javascript==0.5.4
04:49:45 <hpc> submodules would be at /foo/bar/Submodule/SubmoduleTwo/Lib.hs
04:49:49 <hpc> or similar
04:49:53 <luite> to get the older version that does work
04:50:06 <merijn> mm_freak: They only stand in the way of maintenance if they can leak out of the module they're defined in. If they're not exported from there they don't pose any particular maintenance overhead (similar to static variables in C)
04:50:12 <DanMere34567> do i write moduel main where first
04:50:22 <DanMere34567> then the inports
04:50:25 <DanMere34567> imports
04:50:30 <DanMere34567> or the other way round
04:50:37 <mm_freak> merijn: they are leaked out implicitly through the side effects you need
04:51:07 <mm_freak> remember those ugly PHP web frameworks?  that's why you need weeks to learn them, because you can't memorize all the interactions
04:51:28 <Shapeshifter> luite: I see. Well that fails as well because language-javascript-0.5.4 depends on containers <0.5 but I have 0.5.0.0 ;) I fear this will just go on and on up the dependency tree
04:51:38 * merijn doesn't remember ugly PHP web frameworks, since he never used them
04:51:44 <hpc> DanMere34567: either way works
04:51:50 <hpc> pick however you are most comfortable
04:52:02 <DanMere34567> i have a bunch of lists like.. sp_pop_totl_AFG,sp_pop_totl_ALB,sp_pop_totl_ASM so on... would i need to change them when i put them in th seperate file?
04:52:37 <startling> @hoogle (a, a) -> (a -> b) -> (b, b)
04:52:38 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
04:52:38 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
04:52:38 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
04:52:55 <hpc> :t join (&&&)
04:52:56 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
04:53:02 <luite> Shapeshifter: yeah i see, looks like the language-javascript 0.5.5 was a bit careless
04:53:08 <hpc> :t join (***) -- this, rather
04:53:09 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
04:53:09 <DanMere34567> ok so i wont need to change the names of the lists.
04:53:22 <luite> Shapeshifter: want to fix it? will require some cabal file editing
04:53:22 <startling> hpc: neat
04:53:42 <luite> Shapeshifter: I've reported the bug to the language-javascript author, so it should be fixed soon anyway :)
04:53:45 <merijn> hpc: I submitted a proposal to introduce "both = join (***)" but unfortunately I didn't receive much support on libraries@ :(
04:54:37 <DanMere34567> its saying it cannot find the module but both files are in the same directory.
04:54:57 <Shapeshifter> luite: Thanks! Well, I guess I'll sleep on it.
04:54:58 <hpc> DanMere34567: what are the filenames and module names?
04:55:16 <luite> Shapeshifter: if you want to fix it yourself: cabal install cabal-src; cabal unpack language-javascript; cd language-javascript-0.5.5; edit language-javascript.cabal, change version to 0.5.5.1 (just increase it a bit), remove the alex == 3.0.1 line
04:55:24 <luite> Shapeshifter: then run: cabal-src-install --src-only
04:55:30 <Shapeshifter> luite: okay I'll try this.
04:55:49 <luite> Shapeshifter: now you'll have a language-javascript-0.5.5.1 in your package database, which will install without problems
04:56:14 <DanMere34567> hpc : i want to put all the lists togeather in one file that are related to each other. i called them .sp_dny_tfrt_in_AFG where the last 3 letters are country codes.
04:56:17 * hackagebot cake 0.4.0.0 - A build-system library and driver  http://hackage.haskell.org/package/cake-0.4.0.0 (JeanPhilippeBernardy)
04:57:07 <DanMere34567> hpc: the module name I tryed a bunch of names and i cant get it to work. at the moment i only just started to split the main file. I want to seperate each of the lists into there own files so that the files are not so big.
04:59:17 <DanMere34567> is there a template on how to set up a series of modules and files?
04:59:42 <hpc> you just have to set it up so the directory structure and module structure are exactly the same
04:59:57 <hpc> module Foo.Baz goes in Foo/Baz.hs
04:59:58 <hpc> etc
05:00:21 <Shapeshifter> luite: thanks, it worked.
05:00:31 <DanMere34567> ok. and i just say import Foo.Baz
05:00:34 <hpc> yes
05:00:56 <DanMere34567> ok in the main file how do i set that up?
05:00:59 <luite> Shapeshifter: great, i also fixed the bounds in the yesod repository, hopefully this will be all on hackage in a few days
05:01:30 <hpc> if you leave the "module Main where" off, it's implied
05:01:45 <DanMere34567> in the module file i have put this at the top.
05:01:48 <DanMere34567> module Test
05:01:49 <DanMere34567> ( sp_dyn_le00_fe_in_AFG
05:01:49 <DanMere34567> , sp_dyn_le00_fe_in_ALB
05:01:49 <DanMere34567> , sp_dyn_le00_fe_in_DZA
05:01:52 <DanMere34567> , sp_dyn_le00_fe_in_ASM
05:01:59 <DanMere34567> ...
05:02:35 <hpc> did you define a "main" in Test?
05:02:43 <DanMere34567> no
05:02:50 <hpc> that should be fine, then
05:03:14 <DanMere34567> im very confused on how to set up the file strucutre i lookied on the gentle haskell intro and learn you a haskell but i just got even more confused lol..
05:04:32 <DanMere34567> when i load it in winghci it does not work. it says it cannot find the module and has a error with the main file.
05:05:39 <hpc> hmm
05:05:46 <Shapeshifter> luite: nice. Is it normal that the started app is only properly accessible from localhost? http://login.icu.uzh.ch/~archer/yesod_localhost.png I'm running it on 192.168.1.3, if I access it locally, it looks fine, but accessing it from another machine in the network doesn't work. All GETs except the one for / itself fail. I.e. bootstrap.css etc. can't be retrieved.
05:06:21 <Shapeshifter> luite: (the chromium window is a process on .3 launched using x-forwarding)
05:07:23 <hpc> Shapeshifter: hmm, i get something like that with my website, from noscript
05:07:41 <hpc> it works locally, so i doubt it's a problem with the site itself
05:07:48 <luite> Shapeshifter: hmm, that could be the problem i saw earlier
05:07:49 <Shapeshifter> hpc: noscript's disabled.
05:07:52 <DanMere34567> the main file execitues but i cannot access the lists anymore.
05:07:55 <luite> Shapeshifter: you run it with yesod devel?
05:08:01 <Shapeshifter> luite: yes.
05:08:15 <luite> Shapeshifter: OS X with 64 bit GHC?
05:08:46 <Shapeshifter> luite: linux 64bit
05:09:00 <luite> ah
05:09:07 <luite> hmm, maybe that's not it then
05:09:08 <gcollins> Shapeshifter: check your iptables setup
05:09:26 <bartavelle> I would like to add a testing framework for my puppet library, is there something I could build upon ?
05:09:33 <luite> Shapeshifter: i had some problem that only happend with yesod devel for some reason
05:09:39 <bartavelle> (probably not quickcheck as those would be "static" tests)
05:09:39 <hpc> DanMere34567: i am pretty much at the end of my ability to diagnose, without actually being there
05:09:42 <luite> not when compiled to an executable
05:10:20 <DanMere34567> parse error on input `Test.sp_dyn_le00_fe_in_BWA
05:10:44 <dMazz> Shapeshifter, 192.168.1.3 is a private-IP, not routed in the WAN.. is the remote machine in the same LAN segment? Can the remote machine ping your IP?
05:12:20 <killy9999> does anyone know of a package that has extensive benchmarks using Criterion?
05:12:30 <killy9999> I need to learn by example
05:13:05 <killy9999> I'm trying to figure out how to create random numbers for my benchmark so that data generating function doesn't get benchmarked
05:13:43 <DanMere34567> hmmm file is still erroring..
05:13:50 <DanMere34567> import Text.Printf
05:13:51 <DanMere34567> import Data.List
05:13:51 <DanMere34567> import Data.Array
05:13:51 <DanMere34567> import Test
05:13:59 <DanMere34567> but it says it cannot find Test
05:14:40 <Shapeshifter> dMazz: yes, I'm on 192.168.1.2 and yesod devel is launched on 192.168.1.3.
05:14:41 <mysticc> what does this means {-# LINE 507 "Network/Socket.hsc" #-} in Network.Socket source ?
05:15:24 <Shapeshifter> Right now I'm trying to find out if it's my fault (iptables and whatever, although I never enabled anything like that consciously)
05:15:31 <byorgey> mysticc: it's a pragma telling the compiler that place was generated from line 507 in Network/Socket.hsc
05:15:44 <byorgey> mysticc: so that it can issue better error messages
05:17:33 <DanMere34567> ok thanks anyway :D
05:22:04 <mysticc> byorgey: Thanks..
05:24:02 <dibblego> @type @type Data.Set.unions . map Data.Set.fromList
05:24:03 <lambdabot> parse error on input `@'
05:24:08 <dibblego> @type Data.Set.unions . map Data.Set.fromList
05:24:09 <lambdabot> forall a. (Ord a) => [[a]] -> S.Set a
05:24:17 <dibblego> is there a faster way besides say foldl' ?
05:24:51 <Nereid> @type Data.Set.fromList . concat
05:24:51 <lambdabot> forall a. (Ord a) => [[a]] -> S.Set a
05:25:04 <dibblego> yeah I guess, ta
05:25:18 <dibblego> I think I should sleep. thanks :)
05:27:32 <mysticc> undefined can take any type, is it true for only kind * or any kind ?
05:29:41 <merijn> :t (undefined :: IO)
05:29:42 <lambdabot>     Expecting an ordinary type, but found a type of kind * -> *
05:29:42 <lambdabot>     In an expression type signature: IO
05:29:42 <lambdabot>     In the expression: (undefined :: IO)
05:29:57 <merijn> Apparently just *?
05:30:59 <trotro> :t undefined
05:31:01 <lambdabot> forall a. a
05:31:08 <mysticc> merijn: Thanks .. anyways I was talking about Lifted Kinds from Data Something = ..
05:31:10 <trotro> :t (undefined :: IO a)
05:31:11 <lambdabot> forall a. IO a
05:31:14 <trotro> :D
05:31:17 <trotro> IO is not a type
05:31:31 <merijn> trotro: Sure it is
05:31:36 <merijn> Just not one of kind *
05:32:03 <merijn> Which is what mysticc was asking
05:32:05 <trotro> pov
05:33:07 <Shapeshifter> luite: actually, the reason is now obvious to me. I access 192.168.1.3:3000 but the document I receive (Hello...) contains this in its source: <link rel="stylesheet" href="http://localhost:3000/static/css/bootstrap.css?etag=nyE417Xw"><link rel="stylesheet" href="http://localhost:3000/static/tmp/-mEJHNL_.css"> No wonder it doesn't work if it's shipping URLs with "localhost" in them.
05:33:28 <Shapeshifter> luite: so I need to change tha approot, I guess.
05:33:39 <merijn> Shapeshifter: Sounds like that should work, yeah
05:33:39 <luite> Shapeshifter: ah right
05:33:53 <Shapeshifter> it works.
05:39:00 <Entroacceptor> ugh, full urls for stylesheets are bad style anyway
05:39:49 <Shapeshifter> true
05:40:44 <tdammers> Entroacceptor: except when you host them on a CDN or something
05:41:17 <tdammers> (or a static.something subdomain, or whatever)
05:41:35 <Entroacceptor> maybe, but that's still bad, too ;)
05:41:45 <Entroacceptor> in my opinion at least
05:41:48 <nand`> Is there an efficient function somewhere for multiplication-with-modulo? eg. x^y `mod` z
05:44:46 <b_jonas> nand`: for how large numbers?
05:45:01 <nand`> unknown, but large numbers I guess
05:45:18 <b_jonas> nand`: gmp has such a function, only you can't get a gmp object form a haskell Integer easily
05:45:54 <tdammers> Entroacceptor: well, the obvious downside is security; but the upside is that you can have a static content server and an application server with radically different optimizations applied
05:47:14 <Entroacceptor> you can optimize without user visibility
05:49:09 <tdammers> some things you can, others you cannot
05:50:02 <tdammers> e.g., load balancing becomes a bit trickier if you have to filter on the path instead of the domain
05:50:30 <tdammers> avoiding the cookie overhead for static resources, similar dilemma
05:51:26 <tdammers> serving static content from a different (sub)domain is the easiest and most foolproof way of doing these things
05:52:28 <merijn> There's no easy way to mass lift a module, I guess?
05:52:45 <Ceasar> Can someone help me understand Monads a little better? I have a function of type a -> a -> Maybe, and I want to apply it to two Maybe a's. If it werent for the fact that my function takes 2 a's, I could just use >>=, but its not the case.
05:53:26 <tdammers> do { x <- xMay; y <- yMay; f x y }
05:53:36 <quicksilver> Ceasar: either (1) use 'liftM2' or (2) use do notation
05:53:46 <danharaj> liftM2
05:53:50 <danharaj> :t liftM2
05:53:51 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:54:02 <danharaj> which is equivalent to tdammers definition
05:54:13 <merijn> danharaj: No, liftM2 needs a join too
05:54:14 <quicksilver> not quite, danharaj
05:54:14 <Ceasar> I thought about liftM2 but I couldn't get it to work.
05:54:22 <danharaj> it's close enough ;\
05:54:24 <merijn> :t join . liftM2
05:54:25 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (a2 -> a2 -> r) -> m a2 -> m r
05:54:29 <quicksilver> you need a join to get the same thing as tdammers
05:54:39 <merijn> :t join
05:54:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:54:45 <danharaj> just stick joins and returns where they are needed :P
05:55:29 <Ceasar> Great! That helps a lot. Thanks!
05:55:30 <merijn> Alternatively you could use Applicative, but that might be even more confusing if the Monad thing is still confusing
05:55:56 <Ceasar> I thought about that too, but I couldn't reason it out.
05:56:00 <merijn> :t \f x y -> f <$> x <*> y
05:56:01 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
05:56:18 <Ceasar> Yeah that's what I tried.
05:56:18 <merijn> oh, no. that also add the extra one at the end, I guess
05:56:20 * hackagebot language-c-quote 0.4.3 - C/CUDA/OpenCL quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.4.3 (GeoffreyMainland)
05:59:19 <fmap> @let (.::) = fmap . fmap . fmap
05:59:20 <lambdabot>  <local>:2:0:
05:59:20 <lambdabot>      Multiple declarations of `L..::'
05:59:20 <lambdabot>      Declared at: <local>...
05:59:25 <fmap> @type join .:: liftM2
05:59:26 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
06:00:04 <nand`> in http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Real.html#%5E -- isn't ‘f x y’ just ‘g x y 1’? why bother reimplementing the algorithm twice?
06:01:09 <danharaj> nand`: random guess, would ghc simplify g x y 1 into f x y?
06:01:50 <nand`> I don't think that's the case, how would ghc know they're the same function?
06:02:02 <nand`> (in fact, for broken definitions of (*) that might not be the case)
06:02:23 <danharaj> well I mean looking at the definition of g and simplifying it in a way that reduces it to f when the last arg is 1.
06:02:40 <nand`> oh
06:03:14 <danharaj> I suppose there's no guarantee that 1 is multiplicative identity if the instances are messed up.
06:03:33 <nand`> it seems like the code is duplicated just to avoid multiplication with 1
06:06:52 <merijn> Is there a way in cabal to do something like "export/install this module only for some compilers"?
06:07:46 <mcstar> .::: hi
06:09:44 <dcoutts_> merijn: yes, but that is a bit evil
06:10:16 <quicksilver> dcoutts_: if we weren't supposed to use it for evil why would it be called "cabal"?
06:10:19 <merijn> dcoutts_: Why?
06:10:45 <dcoutts_> merijn: packages should export a single api really, not have it vary based on flags etc
06:10:57 <dcoutts_> flags is worst, varying on compiler is less bad
06:11:22 <merijn> dcoutts_: Suppose I have an optional type families based API, how would I go about only exposing it when they're actually supported>
06:11:56 <luite> does anyone know how to make an optional string option (Maybe String) with optparse-applicative ?
06:11:57 <dcoutts_> merijn: so you can do it with cabal conditionals and exposed-modules
06:12:14 <dcoutts_> quicksilver: shh, we don't talk about that
06:12:15 <merijn> dcoutts_: Well, that was my question, wasn't it?
06:12:23 <merijn> :p
06:12:47 <merijn> I'm not sure how to specify conditionals for the presence of compiler extensions (or whether that's even possible)
06:13:09 <dcoutts_> merijn: if (ghc >= blah)
06:13:31 <dcoutts_> merijn: ideally we'd be able to do it on extensions too, but the solver doesn't look at that yet
06:13:48 <merijn> dcoutts_: That's what I feared, so no convenient way to select whether a compiler supports extension X?
06:14:03 <dcoutts_> quicksilver: anyway, a conspiracy for world domination for a good technology isn't evil is it? ;-)
06:14:34 <dcoutts_> merijn: no, you can specify hard dependencies on extensions, but not optional ones (or rather you can express them but the solver will not look at them)
06:15:54 <merijn> Unrelatedly, is there a less ghetto way of running a unknown monad stuck with reader in it with a specific value or am I stuck doing "local (const v)"?
06:16:00 <dcoutts_> merijn: since you could make a flag, like use-tf, and when that's true export the extra module and other-extensions: TypeFamilies
06:16:22 <dcoutts_> merijn: but the solver will never flip the flag to false if the compiler doesn't support it
06:16:35 <merijn> dcoutts_: I'll worry about writing the code first for now and portability next ;)
06:16:38 <dcoutts_> because the solver only looks at lib dependencies, not at extensions, c libs, progs etc etc
06:17:25 <danharaj> dcoutts: sounds like the premise of a gsoc project ;)
06:18:12 <dcoutts_> yeah, maybe
06:18:27 <dcoutts_> if you're interested talk to kosmikus
06:21:21 * hackagebot language-javascript 0.5.6 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.6 (AlanZimmerman)
06:23:14 <cornihilio> right now I have: print (TP.printf $ "%f" (packetTime p) :: String)
06:23:21 <cornihilio> oops, ignore that. Sorry!
06:23:49 <merijn> hmm
06:25:26 <merijn> If I have to have two related by independent types in Reader? Nested ReaderT or ReaderT (a,b)?
06:26:13 <merijn> More specifically, I have a Reader environment that gets used to create another environment that I need to carry in a different Reader...
06:26:18 <mcstar> i thought intmaps would be great for representing persistent sparse matrices....but they are slow
06:26:44 <Saizan> merijn: i guess lenses would mix well with ReaderT (a,b) ?
06:27:08 <mcstar> im wondering, if there is a comparison between haskell's and clojure's maps/hashtables
06:27:11 <merijn> Saizan: I guess it'd be more along the lines of ReaderT (a, Maybe b)
06:31:40 <merijn> @pl
06:31:40 <merijn>  -> runReaderT r x
06:31:41 <lambdabot> (line 1, column 1):
06:31:41 <lambdabot> unexpected end of input
06:31:41 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
06:31:53 <merijn> hmm
06:31:59 <merijn> @pl \x -> runReaderT r x
06:32:00 <lambdabot> runReaderT r
06:32:08 <merijn> oh, gah
06:32:24 <merijn> @pl \x -> runReaderT x y
06:32:25 <lambdabot> flip runReaderT y
06:33:57 <augur> hm. there's a ncie lowest-common-ancestor algorithm that doesnt require trees at all
06:34:06 <augur> (and infact probably couldnt)
06:38:48 <mcstar> > \(r,c)->(r,f c)
06:38:49 <lambdabot>   Overlapping instances for GHC.Show.Show ((t, t1) -> (t, t2))
06:38:49 <lambdabot>    arising fro...
06:38:51 <mcstar> @pl \(r,c)->(r,f c)
06:38:51 <lambdabot> second f
06:39:42 <mcstar> @pl \(r,c)->(c,f r)
06:39:43 <lambdabot> uncurry (flip (,) . f)
06:41:57 <merijn> Anyone familiar with Control.Scope? I see some haskell code importing it, but I can't find any package with that module on hackage (well, one, but that doesn't appear to be the right package)
06:42:41 <merijn> Hmm, appears to come from the ioscope package, whatever that is...
06:53:56 <jpcooper> hello
06:54:29 <shapr> hi
06:54:43 <jpcooper> can anyone suggest a library which would give integer solutions to equations of the form xM(x^t) = y, where y is an integer, x is an integer vector and M is an integer matrix?
06:55:01 <shapr> I have no clue, but have you check hackage?
06:55:04 <jpcooper> I'm aware that Mathematica can do this, but I'd rather use something written in Haskell
06:55:10 <jpcooper> I really don't know what to search for
06:55:16 <jpcooper> this isn't simple integer linear equation stuff
06:56:42 <shapr> jpcooper: Ask on haskell-cafe?
06:56:54 <jpcooper> will do
07:01:42 <nand`> byorgey: is there any alternative to diagrams-cairo I can use to actually get some sort of output, for GHC 7.6.1?
07:03:38 <alpounet> nand`, you can use the svg backend
07:03:52 <alpounet> (it's what i've used for the factorization diagrams app)
07:03:57 <nand`> alpounet: where can I find it?
07:04:12 <alpounet> nand`, http://hackage.haskell.org/package/diagrams-svg
07:04:17 <nand`> ah, thanks
07:04:46 <cornihilio> where would I find an example of creating an ord function for a custom data type?
07:07:47 <paolino_> a compare function
07:07:53 <paolino_> :t compare
07:07:54 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
07:08:30 <paolino_> @src Ord
07:08:31 <lambdabot> class  (Eq a) => Ord a  where
07:08:31 <lambdabot>     compare      :: a -> a -> Ordering
07:08:31 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
07:08:31 <lambdabot>     max, min         :: a -> a -> a
07:08:39 <paolino_> @src Ordering
07:08:40 <lambdabot> data Ordering = LT | EQ | GT
07:10:26 <S11001001> are Ord laws written down somewhere?
07:10:58 <nand`> alpounet: ah, diagrams-svg doesn't build on 7.6.1 (cc byorgey)
07:11:12 <merijn> Why can't Control.Exception.block be of type "MonadIO m => m a -> m a"?
07:11:13 <S11001001> (I've seen transitivity violated too often)
07:11:53 <alpounet> nand`, i think they're preparing diagrams for 7.6.1, or are going to
07:13:00 <byorgey> alpounet, nand`: yes, the HEAD versions build on 7.6.1
07:13:12 <nand`> byorgey: I'm building from https://github.com/diagrams/diagrams-svg
07:13:14 <yitz> nand`: i have a feeling it's not too hard to get it build on 7.6.1. diagrams backends tend to be pretty simple.
07:13:14 <byorgey> working on a new release, unfortunately I don't have a ton of time
07:13:25 <byorgey> nand`: oh, and that doesn't build on 7.6 ?
07:13:35 <nand`> byorgey: unsatisfied dependency on unix < 2.6 and directory < 1.2, both of which fail to build on 7.6.1
07:14:04 <nand`> directory 1.2 does build on 7.6.1
07:14:12 <nand`> so it should be as simple as updating to that
07:14:26 <byorgey> ah, whoops
07:14:27 <alpounet> nand`, it's bundled with 7.6.1, and relaxing that bound a bit will solve the issue
07:14:28 <nand`> unix 2.6 builds on 7.6.1 as w ell
07:14:31 <danharaj> merijn: Why can't every IO action be generalized to take a MonadIO constraint?
07:14:32 <byorgey> I though I had updated that
07:14:41 <byorgey> just a second, I will push some version bumps
07:14:53 <paolino_> this version of ghc should be numbered 8.0 for the problems it creates :-/
07:15:14 <merijn> danharaj: Was that a rethorical question?
07:15:23 <merijn> eh
07:15:25 <nand`> byorgey: do you know any rough estimates on when GtkHs will be updated to 7.6.1 (and thus diagrams-cairo)?
07:15:26 <merijn> rhetorical, even
07:15:41 <byorgey> nand`: no, I don't
07:15:52 <byorgey> nand`: ask dmwit
07:16:00 <nand`> @get-dmwit
07:16:01 <lambdabot> Unknown command, try @list
07:16:03 <nand`> :(
07:17:16 <yitz> preflex: seen dmwit
07:17:16 <preflex>  dmwit was last seen on #haskell 9 hours, 1 minute and 5 seconds ago, saying: oooo, liftA2 (flip (+)) -- ;-)
07:17:37 <nand`> flip (+) seems a bit useless
07:17:57 <yitz> nand`: looks like that comment is way out of context
07:18:12 <nand`> probably
07:18:13 <jix> nand`: but together with the ;-) operator it makes sense
07:18:42 <paolino_> nand`, there is a gtk compilable on 7.6.1
07:18:56 <byorgey> nand`: pushed
07:19:04 <nand`> dmwit │ I can't imagine how else (+) would be implemented for (r ->) than as liftA2 (+)
07:19:09 <nand`> that explains it
07:21:23 <nand`> byorgey: http://bpaste.net/show/51360/
07:22:43 <byorgey> nand`: hrmph
07:22:51 <byorgey> nand`: ok, let me actually try building it myself =)
07:23:40 <nand`> now I'm conflicted, do I use (#) or (%) for reverse function application? :(
07:23:53 <nand`> ah, I'll use both, depending on whether I'm working with lenses or diagrams
07:23:55 <nand`> what could possibly go wrong
07:24:05 <byorgey> heh
07:24:08 <ben> Reverse funtion application? You mean as flip ($)?
07:24:12 <byorgey> yes
07:24:27 <ben> I've always hoped (€) would catch on :(
07:24:37 <byorgey> as in   circle 1 # fillColor blue # scale 5
07:24:43 <edwardk> nand`: the reason i went with % was because lens code tends to elide the spaes, and # changes meaning in that setting.
07:24:50 <merijn> nand`: % is already in Control.Lens
07:24:52 <edwardk> er spaces
07:25:01 <nand`> merijn: I know :)
07:25:09 <nand`> edwardk: that makes sense
07:25:15 <byorgey> haha, what, didn't realize that re: # and spaces
07:25:19 <edwardk> also, i find # to be butt-ugly
07:25:27 <nand`> well, in the absence of -XMagicHash does that still hold?
07:25:36 <nand`> # to me just screams ‘internal’ now
07:25:42 <edwardk> nand`: that too
07:25:54 <danharaj> feature request: ghc language pragma that reverses function application.
07:25:59 <edwardk> without magihash the meaning doesn't shift. but i have it on in a fairly random smattering of my code
07:26:11 <edwardk> danharaj: *shudder*
07:26:12 <byorgey> nand`: well, there's nothing magical about (#) in diagrams.  Just use (%).
07:26:27 <danharaj> edwardk: I knew a guy who would write all his arrows on the board like B <- A
07:26:32 <edwardk> what is the fixity of (#)?
07:26:39 <nand`> something very high
07:26:42 <nand`> % is very low
07:26:43 <byorgey> oh, good point.
07:26:56 <edwardk> (%) is very low, (^%) is very high
07:27:05 <nand`> I'll use both, based on what fixity I want :P
07:27:31 <nand`> a ||| b # c   vs a ||| b % c
07:27:53 <jix> a language pragama that will reverse function application whenever that is needed to make the typechecker happy ;)
07:28:00 <byorgey> (#) is infixl 8
07:29:23 <cornihilio> is there a haskell library for dealing with epochs?
07:29:26 <edwardk> infixl 1 %; infixl 8 ^%; while # is infixl 9.
07:29:32 <edwardk> oh 8?
07:29:45 <byorgey> yes, 8
07:29:50 <edwardk> found it
07:30:01 <edwardk> so # and ^% are equivalent
07:30:04 <byorgey> I don't remember why I picked 8 but I do recall thinking about it carefully at the time.
07:30:10 <byorgey> apparently so.
07:30:24 <nand`> of course ^% is uglier imo for diagrams
07:30:33 <pingu> indeed
07:30:33 <nand`> circle 1 ^% fc red
07:30:34 <edwardk> I use % so that it binds just a _little_ tighter than $.  this makes it so you can chain setters with it
07:30:36 <nand`> hmm
07:30:38 <pingu> # is better
07:30:47 <edwardk> ^% is only there because it can mix with ^.
07:31:00 <edwardk> foo^._1^%magnitude
07:31:36 <edwardk> but % is nicer than # or ^% for chaining setting operations
07:31:51 <edwardk> foo % bar .~ baz % quux .~ quaffle
07:32:02 <edwardk> the fixity on # and ^% is too high for that to work
07:32:30 <edwardk> and the fixity can't go any lower without colliding with $ which has the opposite fixity
07:32:34 <nand`> foo^._1.to magnitude
07:32:46 <edwardk> nand`: sure. i definitely prefer that style
07:32:47 <obiwahn> is there an emement like inf in haskell
07:33:00 <obiwahn> i wnat to do some math:)
07:33:15 <edwardk> obk was just omplaining about there not being an operator for it, and ^% was the only one that i could concoct that had the right fixity to do what he wanted
07:34:32 <edwardk> it just avoids the parens when the function passed to 'to' takes arguments
07:35:23 <nand`> I feel the need to comment on how confusing the type signatures of diagrams stuff seem
07:35:34 <nand`> other than that what I've seen of the library is pretty beautiful
07:35:44 <yitz> obiwahn: what do you want it to operate on?
07:35:46 <byorgey> nand`: yes, I'm aware of the type signature pain.
07:35:47 <nand`> exactly as declarational as I like it
07:35:53 <hpaste> Abraxas pasted “stepeval for parser combinators” at http://hpaste.org/76317
07:36:10 <byorgey> nand`: one idea I had was to create an auto-generated 'diagrams-simple' package which re-exports lots of stuff with more monomorphic type signatures
07:36:26 <byorgey> nand`: e.g. specialize everything to R2 etc.
07:36:35 <obiwahn> yitz: i want something like: limit(sum(...),x=0..n,n=inf)
07:36:36 <nand`> what's the R2 for? dimension?
07:36:49 <byorgey> nand`: yes
07:36:53 <yitz> obiwahn: for lists, there is minimum. the RangedSets package has something somewhat more general.
07:36:55 <Abraxas> can you have a look at the above paste and tell me if it's done correctly?
07:37:02 <nand`> with an appropriate backend, I could in theory draw 3d diagrams or what?
07:37:07 <byorgey> nand`: yes
07:37:10 <nand`> neat
07:37:16 <nand`> and yes that sounds useful
07:37:16 <yitz> obiwahn: ahhh infinity?
07:37:24 <nand`> 2D diagrams seems like the majority of use cases right now
07:37:25 <yitz> obiwahn: ok, then, yes, just leave it out
07:37:40 <yitz> > [1,3..]
07:37:41 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
07:37:43 <nand`> byorgey: yknow I'm just expecting simple stuff like hcat :: [Diagram] -> Diagram
07:38:10 <byorgey> nand`: right.  and at the moment you have something like   (Enveloped a, V a ~ R2) => [a] -> a
07:38:32 <byorgey> which is more general but I agree is confusing to read when you're just learning.
07:38:56 <nand`> byorgey: though I personally feel that I'd be comfortable with the more complicated signatures as long as there's a good set of articles explaining them in depth
07:39:07 <byorgey> nand`: yeah, that's the other thing I'm working on =)
07:39:10 <nand`> I mean, Control.Lens uses some pretty complicated type signatures of its own but they're all well-explained
07:39:19 <byorgey> yup
07:39:30 <yitz> obiwahn: you'll have to write some code for the "limit" part, of course, depending on what you are trying to do exactly.
07:39:33 <Abraxas> especially, on line 39...do i have to evaluate it lazy all the time or could i by-pass it sometimes
07:40:06 <edwardk> all i have to do now is figure out how to fit an overview of them into an hour and a half in san francisco on Thursday
07:40:07 <byorgey> I should also point out that if someone wanted to contribute to diagrams but didn't know what to do, documentation-writing would be a great way to contribute =)
07:40:07 <obiwahn> yitz: i want something like: limit(sum(10000/x,x=0..n),n=infinity)
07:40:07 <Abraxas> if there's several lambda expression, i get mixed up with what's the next input to one lambda
07:40:13 <byorgey> I only have so much time.
07:40:17 <obiwahn> that is the term i want to calculate
07:40:24 <nand`> (Juxtaposable a, HasOrigin a, Monoid' a, V a ~ R2) => [a] -> a -- heh
07:40:32 <edwardk> documentation on lens has been exhausting, but worth it
07:40:42 <byorgey> nand`: ah, right, see, it was even more general than what I said =)
07:41:00 <nand`> Monoid' is ugly
07:41:01 <edwardk> i need to get better documentation in there for the zippers, uniplate and for some things like representations of functors via lenses
07:41:05 <byorgey> nand`: I know =(
07:41:08 <nand`> (can't you use a type synonym with ConstraintKinds for that?)
07:41:33 <yitz> > [sum [1000/x | x <- [1..n]] | n <- [1..]]
07:41:34 <lambdabot>   [1000.0,1500.0,1833.3333333333333,2083.333333333333,2283.333333333333,2449....
07:41:35 <byorgey> nand`: yes, eventually, but I still want to support versions of GHC that don't have ConstraintKinds
07:41:45 <nand`> ah
07:42:00 <nand`> I thought diagrams was pretty unportable, doesn't it use associated data families and whatnot?
07:42:06 <yitz> obiwahn: that just listed them all. you have to decide what it means to take the "limit"
07:42:19 <byorgey> nand`: yes, but those work all the way back to GHC 6.12
07:42:19 <nand`> oh, wait, you said versions of GHC
07:42:21 <nand`> thought you meant other compilers
07:42:29 <byorgey> nand`: no, definitely not other compilers =)
07:42:43 <edwardk> nand`: its the difference between >= 7.0.x and >= 7.4.1
07:42:51 <nand`> I see
07:43:06 <edwardk> which is the difference between supporting the most recent platform and the most recent 2
07:43:17 <obiwahn> yitz: the limit is the greatest number in the sequence
07:43:37 <byorgey> right.  eventually I do hope to switch to using proper class synonyms with ConstraintKinds, among other things
07:43:41 <Saizan> 7.0.x feels like ages ago already
07:43:47 <nand`> well hopefully Monoid would pick up Semigroup
07:44:08 <atriq> Is there much point in it picking up Group?
07:44:13 <yitz> obiwahn: there are infinitely many numbers in the sequence though. so you have to decide how to pick out the greatest one. your algorithm will be somewhat more practical if you can think of how to do it in finite time.
07:44:19 <nand`> Group would have Monoid, not the other way round
07:44:26 <atriq> class Monoid m => Group m where inverse :: m -> m
07:44:27 <byorgey> nand`: yes, that too
07:44:27 <atriq> Yes
07:44:37 <atriq> I meant in the whole family thing
07:44:39 <byorgey> nand`: though there are other places I am also using class synonyms
07:44:41 <nand`> though you could have class (Monoid m, Semigroup m) => Group m
07:44:47 <obiwahn> yitz: i need to compare the numbers and see if it is still growing
07:44:51 <nand`> or something like that
07:44:57 <nand`> Quasigroup, not Semigroup
07:45:01 <atriq> instance Num a => Group (Sum a) where invert (Sum a) = Sum (negate a)
07:45:03 <yitz> obiwahn: ok that sounds like a good plan.
07:45:07 <obiwahn> but i am unsure how to do it in finite time
07:45:36 <obiwahn> and when it is not convergent ill never get an answer
07:46:21 <yitz> obiwahn: how modifying that and look for when it is growing less than a small amount?
07:46:26 * hackagebot TraceUtils 0.1.0.2 - Functions that should have been in Debug.Trace  http://hackage.haskell.org/package/TraceUtils-0.1.0.2 (EyalLotem)
07:46:49 <yitz> how about*
07:47:24 <atriq> instance Fractional a => Group (Product a) where invert (Product a) = Product (recip a)
07:47:29 <merijn> @pl \x y -> f $ g x y
07:47:29 <lambdabot> (f .) . g
07:47:57 <romildo> How can someone import Prelude hiding the instance of list from class Ord?
07:48:09 <yitz> @pl \f g x y -> f $ g x y
07:48:09 <lambdabot> (.) . (.)
07:48:50 <byorgey> nand`: hmm, ok, the problem with diagrams-svg is actually a real problem with an API change in the 'directory' package
07:48:51 <Abraxas> generally speaking, if i manually evaluate haskell code, can i feed each lambda expression the appropriate values even ahead of lazy evaluation?
07:49:12 <byorgey> nand`: I plan to fix it soon but I'll have to think a bit more about the proper fix, and don't have time today
07:49:17 <nand`> byorgey: fair enough
07:50:01 <atriq> romildo, you can't. Make newtype MyList a = MyList [a]; instance Ord (MyList a) where...
07:50:30 <MostAwesomeDude> romildo: Out of curiosity, what's wrong with the instance in the Prelude?
07:51:48 <romildo> MostAwesomeDude, nothing wrong. just want to try an exercise which asks to complete the definition instance (Ord a) => Ord [a] where ...
07:52:02 <Abraxas> http://hpaste.org/76317
07:52:07 <Abraxas> oops
07:52:30 <MostAwesomeDude> romildo: Aha.
07:52:39 <byorgey> nand`: https://github.com/diagrams/diagrams-svg/issues/20
07:52:44 <jix> heh you can define an application operator that can be used in both directions.
07:53:01 <jix> http://hpaste.org/76318 but you'll get overlapping instance errors easily when using it
07:53:09 <Abraxas> well, for that paste, on line 38...the lambda should take "rest" and replace the "y" in yield with it?
07:53:37 <Abraxas> for this, i would have to skip lazy evaluation, because next in line should be the expansion of ++>
07:53:51 <Abraxas> (i think)
07:54:38 <Abraxas> so i expanded ++> and ended up with a different result
07:56:57 <Abraxas> "x2" somehow got in there instead of "rest"
07:59:16 <Abraxas> i think the problem is that i made "rest" part of the function for the expansion of "q ++> f"?
08:10:19 <Abraxas> if you have a partial application which is "complete" by feeding it a value, how do you make sure you are not getting the wrong value in "its way" during manual evaluation...or can that even happen? damn, this stepeval (http://hpaste.org/76317) confuses me...
08:13:37 <Cale> Abraxas: which bit is confusing?
08:16:03 <Cale> Abraxas: it appears that you dropped some parens which are required?
08:16:12 <Cale> (\x -> q ++> \y -> yield (f x y)) x rest
08:16:14 <Abraxas> i think on line 38 i have dropped parens
08:16:18 <Cale> yes
08:16:30 <Abraxas> this is wrong: q ++> \y -> yield (f x y) rest
08:16:37 <Cale> --> (q ++> \y -> yield (f x y)) rest
08:16:39 <Abraxas> must be (q ++> \y -> yield (f x y)) rest
08:17:52 <Abraxas> how this happened, i think: if i feed a value to a lambda and the open paren in front of the "\x" disappears, i remove the corresponding closing paren
08:18:03 <Abraxas> i am not allowed to do that?
08:19:27 <Saizan> not really, (\x -> ...) is (\x -> (...)) with explicit parens
08:19:40 <Abraxas> right
08:19:48 <Saizan> so you can drop the outher ones when you apply the lambda
08:20:06 <Abraxas> i never write the inner ones, though
08:20:22 <Saizan> yeah, none does
08:20:41 <Saizan> but logically they are there, and it's importand when you beta-redyce
08:20:45 <Saizan> *beta-reduce
08:20:53 <applicative> byorgey: I was putting my patch for diagrams-svg + ghc-7.6 up, but now I see it needs cpp for earlier ghc's.
08:20:59 <ClaudiusMaximus> bit confusing have (\x -> ... x ...) x  imo
08:21:08 <Cale> http://tinyurl.com/96dbhys -- this stepeval doesn't want to beta reduce under the lambda though
08:21:08 <Abraxas> is it easier to keep the outside parens or better write the inner parens for manual evaluation?
08:21:36 <Abraxas> keeping outside parens cannot hurt the evaluation, i think
08:22:04 <Cale> http://tinyurl.com/8jtz58u -- but you can force it to proceed like this
08:22:05 <Saizan> i just do (\x -> ...x...) arg --> (...arg...)
08:23:56 <Abraxas> oh, i didn't try it in the actual stepeval
08:24:11 <Abraxas> forgot that everything is defined and there are no problems
08:24:44 <Abraxas> i mostly have trouble with stepeval, because it only knows the prelude?
08:24:49 <Cale> I kind of think that this is a terrible way to understand this function though. :)
08:26:04 <Cale> It's kind of similar to trying to understand recursion by plugging in the definition of the recursive thing, only not *quite* as bad :)
08:26:22 <Abraxas> heh, possible
08:26:37 <Abraxas> i was trying to both practice stepeval and understand the function ;)
08:27:31 <Abraxas> i think i understand the function and was trying to see how horrible it looks when expanded
08:27:45 <Cale> Okay, so p ++> f is the parser which runs the parser p on the initial portion of the input in order to obtain some result x, and the remainder of the input rest (assuming it doesn't fail), and then runs the parser f x on the remainder of the input.
08:28:58 <Cale> and along with this we have that  yield x  is the parser which doesn't consume any of the input, but succeeds with result x
08:29:45 <Cale> So liftP f p q = p ++> \x -> q ++> \y -> yield (f x y)  is the parser which runs p getting some result x, and then runs q getting some result y, and if those succeeded, it succeeds with result (f x y)
08:31:04 <Abraxas> sorry, i was trying your two stepevals
08:31:24 <Abraxas> you removed lift
08:31:28 <Abraxas> from the second one
08:31:46 <Abraxas> you don't really need the definition, then?
08:33:24 <Abraxas> yeah, lift applies the function to the results of two different parses
08:33:43 <Abraxas> i once knew how that is related to monads, but not sure, right now
08:34:56 <Cale> Yeah, ++> is >>=
08:35:04 <Cale> and yield is return
08:35:09 <ksf> it lifts a computation from one part of the monad stack into a higher one.
08:35:12 <Cale> liftP is liftM2
08:35:25 <efie> Could someone tell me why this http://stackoverflow.com/a/5589992 does not work / what I am doing wrong?: when I replace the "..." with <somecode> and start the program. I press "q" and the shell says "ExitSuccess" but <somecode> still continues and does so till its done. Why does the program not stop?
08:35:27 <Cale> ksf: he's talking about a lift from his code
08:35:31 <ksf> oh.
08:35:52 <linduxed> just a quick check
08:36:05 <linduxed> {- -} is still a comment right?
08:36:08 <Cale> right
08:36:11 <linduxed> hmmm
08:36:25 <linduxed> then for some reason my vim has decided that they're not
08:36:35 <linduxed> worked some weeks ago....
08:36:57 <Abraxas> right, the several liftM correspond to this self-made one
08:37:05 <Abraxas> and other "stuff"
08:37:38 <Cale> efie: The program only ends when the main thread ends.
08:38:04 <ksf> efie, that is, exchange ... and exitOnQ.
08:39:24 <Cale> Abraxas: by the way, I actually think the code for >>= reads better when you define Parser as a newtype and runParser as a way to unwrap it:
08:39:36 <Cale> newtype Parser a = P (String -> Maybe (a,String))
08:39:49 <Cale> runParser :: Parser a -> String -> Maybe (a, String)
08:39:56 <Cale> runParser (P f) s = f s
08:40:23 <b__> is it possible to write: "x <- readArray i a; when x $ f" in a more straightforward way?
08:41:04 <efie> cale: ah ok, thanks- ksf: hm, it still does not work
08:41:12 <Botje> readArray i a >>= \x -> when x f
08:41:24 <Cale> x >>= f = P (\s -> do (v,s') <- runParser x s; (w,s'') <- runParser (f v) s'; return (w,s'')) -- using the Maybe monad.
08:41:46 <Botje> so then readArray i a >>= flip when f
08:41:58 <Cale> Note that there's nothing in that code which actually requires it to be the Maybe monad though.
08:42:06 <Cale> It could just as well be the list monad :)
08:42:24 <b__> thanks Botje
08:42:33 <Cale> (and if you replace Maybe with list, you get another kind of parser capable of dealing with nondeterminism)
08:43:20 <xnor> > map (+1) [1..10]
08:43:21 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
08:43:26 <efie> ksf: compiling it made it work, thanks
08:43:30 <Cale> I would normally explain the writing of that code line by line, but it'd be a little noisy here :)
08:44:35 <Abraxas> if there were a value behind the lambda expression, would i be able to feed it to the lambda, if there were also a possible expansion in front of it?
08:44:49 <Abraxas> that would break lazy evaluation?
08:44:51 <Cale> Not sure what you mean by that
08:45:00 <ksf> > (\x -> x + 1) 1
08:45:01 <lambdabot>   2
08:45:14 <Cale> Already you're not doing straightforward lazy evaluation, because you're evaluating underneath unapplied lambdas
08:45:45 <Abraxas> p ++> (\x -> ...x...) y
08:46:02 <Abraxas> yeah, that
08:46:19 <Cale> Normally, lazy evaluation would start with ++> there
08:46:37 <Abraxas> which causes all the confusion, maybe i should always assume the application before i even start?
08:46:48 <Cale> But every evaluation order which terminates will produce the same result
08:46:55 <Cale> So you don't have to worry
08:47:11 <Abraxas> in that case, i could replace x with y?
08:47:17 <Cale> When you're doing things by hand it's often convenient to evaluate in a stricter order
08:47:23 <Abraxas> because nothing else can "get in the way"
08:47:37 <Cale> sure, that's a valid transformation to apply
08:48:26 <Abraxas> there is not some "magical" way that something gets between the lambda and the y?
08:48:35 <Cale> You can beta reduce any subexpression at any point in time, and so long as your evaluation eventually terminates, it will produce the same result as if it had been carried out by lazy evaluation.
08:49:09 <Cale> However, outermost-first evaluation order has the nice property that if any evaluation order terminates, then it does.
08:49:46 <Abraxas> "beta reduce any subexpression at any point in time"
08:49:54 <Abraxas> ah, that's what i was looking for =)
08:50:22 <Cale> GHC actually takes advantage of this
08:50:43 <Abraxas> so, if it doesn't terminate out-of-order, it could still terminate and i'd have to try the other way to make sure
08:50:50 <Cale> Your programs *aren't* evaluated under simple lazy evaluation, but some bits of them are evaluated more strictly whenever GHC can prove it's okay
08:51:00 <Cale> yeah
08:51:21 <Cale> If it looked like things were getting out of hand, you could try doing more outermost reductions
08:51:38 <quicksilver> you can never go badly wrong, Abraxas
08:51:49 <efie> http://hpaste.org/76319 : when I press "q" I would like this program not to only stop, but also to let "print $ calcFibs 33" print out the list calcFibs 35 already calculated. Is this possible?
08:51:54 <Cale> Yeah, you'd never really have to backtrack
08:51:55 <quicksilver> what I mean is, there is no state you can finitely reach from which you can't "get back" onto the terminating path
08:52:06 <Abraxas> don't be so sure about that, quicksilver :D
08:52:27 <Cale> heh, if you make mistakes, then of course, it's possible to go badly wrong :)
08:52:28 <quicksilver> there are infinite paths, but every *point* on each infinite path has finite reductions to the WHNF, if WHNF exists.
08:52:52 <quicksilver> (actually, finite reductions to some point "as defined or more so" than the WHNF)
08:53:59 <Cale> efie: Of course, you can't tell the difference between the already-evaluated and not-already-evaluated elements of a list
08:54:23 <Abraxas> nice, thanks!
08:54:37 <Cale> efie: So you'll need to do something to take apart the algorithm for calculating the fibs if you want to know how far along you are in evaluating them.
08:55:50 <Abraxas> Cale: even with your workaround, stepeval doesn't manage to work this out in a satisfying fashion?
08:56:00 <Cale> (actually, that's possibly a bit of a lie -- with low-level tools for inspecting the GHC heap, like vacuum, you could tell)
08:56:11 <Cale> Abraxas: oh?
08:56:33 <Cale> Abraxas: I just deleted the part of the expression which was blocking it from proceeding with that subexpression
08:56:52 <Cale> Abraxas: (but I left the outer 'let' which defined the ++> and yield)
08:57:04 <efie> Cale: I cannot really imagine how to take it apart
08:57:25 <scooty-puff> if, for some GADT M :: K -> *, you have instances of C for all M K (but not for M k), do you have an instance of M k of C?
08:58:27 <scooty-puff> *instace of C for (M k)
08:58:35 <scooty-puff> ... *instance
08:58:47 <Cale> efie: Okay, so maybe instead of constructing a list, write a loop like:   generateFibs c n = do v <- evaluate (fib n); writeChan c v; generateFibs c (n+1)
08:59:06 <Cale> efie: evaluate is from Control.Exception (oddly enough)
08:59:29 <Cale> and writeChan is from Control.Concurrent.Chan
08:59:52 <Abraxas> it doesn't simplify the yield once again
09:00:36 <Abraxas> -once again +ever
09:01:39 <Cale> efie: then in your main loop, you'll want something like   do c <- newChan; tid <- forkIO (generateFibs 0); exitOnQ; killThread tid; xs <- getChanContents c; print xs
09:01:52 <Cale> er, your main thread
09:01:58 <Cale> the loop bit is in exitOnQ :)
09:02:16 <Cale> oops, didn't pass c to generateFibs there
09:02:22 <Cale> you get the idea
09:02:31 <ksf> ...and don't exit in exitOnQ, that is, waitForQ
09:02:58 <Cale> right, I was looking at http://hpaste.org/76319 at the time
09:06:33 <Cale> oh, hmm, this didn't work for me
09:06:51 <Cale> Abraxas: It should simplify it once there is no lambda surrounding it
09:07:03 <n-dolio> scooty-puff: Depends on the GADT. It won't happen automatically in any case.
09:07:09 <Cale> Abraxas: you'll have to manually discard the lambdas for it to unfold the part underneath them
09:07:18 <Abraxas> it needs the argument for yield
09:07:41 <Cale> (it's fine coping with things that aren't in scope though)
09:08:33 <Abraxas> this is the only tool of that sort for haskell?
09:09:23 <Cale> Abraxas: Well, there are some other things kinda similar to it, but not really the same as far as I've seen.
09:09:39 <Abraxas> would be awesome of there were a stepeval tool that's powerful enough to do most stuff
09:09:46 <efie> Cale: thanks, I will look at it,  but maybe you could tell me if I am on the right track with this example? I have a function which "upates" a data structure and which each update the data is getting "better": update :: data -> data. Now I want to apply this update-function to the new data and then again to newer data (and so on) until you press the "q" key. Then the latest data should further be processed
09:12:49 <Cale> efie: yeah, that's going to require concurrency, because the result depends on the precise nature of I/O that's happening
09:14:13 <Cale> oh, of course
09:14:18 <Cale> getChanContents won't do
09:14:31 <Cale> because it produces an "infinite" list
09:14:59 <efie> ok
09:15:36 <efie> anyway, it is not so important to do especially this, I try to figure it out in generel for my case :)
09:16:37 <Cale> it might be simpler just to use an MVar with a list
09:16:42 <Cale> that gets extended
09:18:38 <efie> Cale: MVar contains the data structure?
09:19:26 <efie> you are talking about the fibnumbers, ups
09:20:07 <hpaste> Abraxas annotated “stepeval for parser combinators” with “stepeval for parser combinators (annotation)” at http://hpaste.org/76317#a76321
09:20:26 <hpaste> Cale pasted “Like this” at http://hpaste.org/76322
09:21:14 <Cale> efie: ^^
09:21:31 * ksf would spawn another thread, and change the Chan type to Maybe Integer. one thread waits for the q and sends a Nothing, one thread computes fibs and sends Just, the third listens and outputs/really quits.
09:22:13 <Cale> ksf: The goal is to compute as many fibs as possible before q is pressed
09:22:19 <Cale> and print them all after that
09:22:31 <ksf> why not print them while they're coming in?
09:22:49 <Cale> Oh, I suppose you could do that :)
09:23:10 <ksf> ...or, even better, use one chan and one TVar.
09:23:43 <ksf> sounds like a proper Hello, World! for concurrency.
09:24:29 <ksf> that would be a nice wiki section to have, btw.
09:25:09 <rpglover64> Anyone willing to help out a student trying to understand ideas beyond his ken and fuse them together?
09:25:42 <ksf> no. but we're willing to blow your mind.
09:25:44 <Cale> rpglover64: That's kind of what this channel is for, so long as your questions are about Haskell or functional programming or related mathematics.
09:26:03 <hpaste> Abraxas pasted “tic-tac-toe in progress” at http://hpaste.org/76323
09:26:33 * hackagebot disjoint-set 0.2 - Persistent disjoint-sets, a.k.a union-find.  http://hackage.haskell.org/package/disjoint-set-0.2 (MaxwellSayles)
09:27:10 <Abraxas> for the helper function "win" in "endPosition"...can i apply the argument of "win" to the list in some other way?
09:27:32 <rpglover64> I'm trying to combine ideas from Data Types a la Carte, Metatheory a la Carte and the compdata package to build a system that I understand for constructing extensible data types with extensible result types and fine-grained control of (potentially monadic) evaluation order (in Haskell, of course).
09:27:40 <Abraxas> i used (\g -> any (==True) $ map (\x -> x g) to apply it to the list
09:27:52 <rpglover64> Cale: I know, but sometimes people are busy. Thanks.
09:27:56 <efie> Cale: thanks, I will look at while looking up what MVar exactly is :)
09:28:18 <Cale> efie: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/Control-Concurrent-MVar.html
09:29:21 <Abraxas> oh lol, i used repeat instead of replicate
09:29:52 <Cale> I think the remark under "Gotchas" there is a little too strongly worded -- "Be sure to" might not apply.
09:30:18 <Cale> Sometimes it's okay to put unevaluted expressions into MVars to be evaluated later (maybe) by some other thread.
09:30:37 <Cale> rpglover64: okay
09:31:27 * ksf thinks there should be concurrency primitives that deepseq without the use of NFData
09:31:46 <Cale> I'm not sure what that would mean
09:32:01 <ksf> ...evaluate to NF.
09:32:10 <ksf> (at least if it's a value)
09:32:13 <Cale> Apart from the fact that there are, and they belong to Cloud Haskell in the form of the Serialise class.
09:32:36 <Cale> Serializable, rather :)
09:32:55 <ksf> well, I'm always sceptical of type classes that end up being implemented for all datatypes and are constraints of every bloody function.
09:33:20 <Cale> Once was a time that seq had a typeclass constraint
09:33:29 <quicksilver> a happier time!
09:33:30 <Cale> It's actually straightforwardly implementable for most types
09:34:38 <ksf> well, imagine we finally get a JIT/supercompiling implementation. I'd like a "deepseqsupercompile" primitive, there.
09:34:39 <Cale> The fact that we can apply seq to functions means that we can tell the difference between undefined and const undefined
09:34:49 <Cale> which kinda sucks
09:35:10 <ksf> for denotational fundamentalists, maybe.
09:35:26 <efie> is also something like this possible? http://hpaste.org/76325 (pseudocode) return a value from a thread to the main thread?
09:35:45 <quicksilver> ksf: you can have a "deepseqsupercompile" IO primitive, if you like
09:35:50 <ksf> efie, you need to use a concurrent variable for that.
09:35:52 <Cale> ksf: Even if you're not a fundamentalist, you have to be annoyed whenever your assumptions are broken by that :)
09:36:01 <quicksilver> I don't see why should get such a thing as a pure primitive
09:36:08 <quicksilver> it doesn't represent anything, denotationally.
09:36:18 <ksf> the only thing forkIO returns is a thread id, and you can throw exceptions at it.
09:36:37 <Cale> efie: It's possible to construct an abstraction like that, I'm sure
09:36:37 <efie> ksf: like MVar?
09:36:43 <ksf> like MVar, yes.
09:36:53 <ksf> I recommend using the STM, though.
09:36:54 <Abraxas> for the tic-tac-toe paste above (http://hpaste.org/76323), line 88, the one i asked about...hpaste tells me it's a redundant lambda, so i guess there is another way to write it
09:36:57 <Cale> efie: But the result of forkIO is actually the thread id of the new thread.
09:37:12 <ksf> http://hackage.haskell.org/package/stm
09:37:21 <luite> Cale: hm, i wonder how difficult it would be to change that, often the location applying the seq doesn't know whether the thing it's seqqing is a function
09:37:30 <Cale> efie: well... for some appropriate type of 'latestData'
09:37:34 <ksf> efie, that is, a TMVar.
09:38:21 <Abraxas> but it also tells me to use "elem", which i hardly will be able to when testing for any (==True)?
09:39:03 <Abraxas> oh, it works
09:39:20 <linduxed> could someone tell my why this doesn't work?
09:39:23 <linduxed> Prelude> maximum $ (map read ["1","23","3"])::[Int]
09:39:25 <Abraxas> i can just say "elem True [1==1]"
09:39:25 <linduxed> *** Exception: Prelude.read: no parse
09:39:25 <efie> thanks guys, much to look at the next days... weeks.. :)
09:39:27 <Cale> luite: Well...
09:40:01 <ksf> > maximum ((map read ["1","23","3"])::[Int])
09:40:02 <lambdabot>   23
09:40:15 <Cale> luite: I was actually just thinking that if we were allowed to do something a bit spoony, we could define a semantics for seq applied to a function which would be a bit more faithful, perhaps.
09:40:16 <ksf> the type annotation doesn't scope like you think it does.
09:40:16 <luite> Cale: you could force some dictionary to be supplied for every polymorphic value, that somehow indicates that it's a function or not
09:40:17 <jesyspa> Abraxas: any (==True) sounds a lot like or to me.
09:40:28 <Cale> luite: Oh, well, yeah
09:40:35 <Cale> class Eval a where
09:40:40 <linduxed> hmmm, so the $ didn't work there
09:40:41 <Cale>   seq :: a -> b -> b
09:40:43 <linduxed> weird
09:40:56 <Cale> luite: That's how it used to be
09:41:04 <ksf> $ is just a function, it doesn't influence how :: is parsed.
09:41:17 <Cale> luite: Oh, or you mean that instances of that exist automatically for most types?
09:41:25 <ksf> @src ($)
09:41:25 <Cale> (which aren't functions)
09:41:26 <lambdabot> f $ x = f x
09:41:32 <ClaudiusMaximus> @quote ::
09:41:33 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
09:41:33 <lambdabot> like learn $ zip math haskell.
09:42:03 <luite> Cale: yeah. I didn't know that btw, probably before I started using Haskell :)
09:43:19 <Cale> It does have a tendency to clutter type signatures in a funny way
09:43:38 <Cale> Maybe that clutter is actually good though.
09:44:04 <ClaudiusMaximus> @quote cmccann ::
09:44:04 <lambdabot> cmccann says: newtype Natural = N { denature :: Integer }
09:44:08 <Cale> You could tell whether a polymorphic function was going to force evaluation of things or not
09:45:07 <dmwit> lispy: Yes, but I observed (from ghci) that that wasn't the case.
09:45:11 <dmwit> nand`: pong
09:45:58 <Abraxas> jesyspa: indeed =)
09:46:16 <Cale> Even if fast and loose reasoning is morally correct, the free theorems really do somewhat fail in the presence of seq.
09:46:18 <Abraxas> i was sure it was something simple, but didn't recall
09:46:37 <Abraxas> this is probably something simple, too: (\g -> map (\x -> x g)) list
09:46:38 <quicksilver> Cale: and so do monad laws, etc etc
09:46:42 <Cale> and there's a way to sort of recover them, but it's awkward
09:46:48 <dmwit> "morally correct" means "not in the presence of seq"
09:46:56 <Cale> dmwit: pretty much, yeah :)
09:47:29 <quicksilver> well the '=' is laws is already taking into account non-termination
09:47:43 <Cale> dmwit: well, it's actually a bit more than that
09:47:54 <Abraxas> i want to apply the function after the list to each element of the list
09:48:02 <Abraxas> is this something with flip?
09:48:15 * Abraxas doesn't know much about flip
09:48:57 <dmwit> :t map . flip id
09:48:58 <lambdabot> forall b a. a -> [a -> b] -> [b]
09:49:29 <dmwit> :t map . id
09:49:30 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:49:54 <dmwit> :t flip map
09:49:55 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
09:51:26 <ghollisjr> does anyone know if there is work being done to make data parallel haskell compile against the latest LLVM?
09:51:34 <Overload> hey, does anyone have some good example of polymorphic recursion to test my new inferencer?
09:51:56 <Lemmih> Overload: genericLength?
09:51:59 <rpglover64> Does anyone have insight into the connections between monadic algebras and algebras with monadic carriers, and how they translate to Mendler style (monadic) algebras?
09:52:00 <Abraxas> ...it's just flip map? how did i not try that
09:52:29 <dmwit> Overload: The standard example is any recursive function over data BalancedTree a = Leaf a | Branch (BalancedTree (a, a))
09:52:49 <dmwit> for example,
09:53:10 <dmwit> parse ('b':rest) = Branch (parse rest); parse rest = read rest
09:53:12 <dmwit> uh
09:53:15 <dmwit> parse rest = Leaf (read rest)
09:53:54 <Abraxas> maybe it's not just that
09:54:08 <nominolo> edwardk: What is "functional support" (re LinkedIn)
09:54:16 <edwardk> functional programming
09:54:23 <Overload> yeah the tree one is classic, already done that with lists
09:54:25 <edwardk> for some reason they canonicalize it to that stupid name
09:54:42 <Cale> rpglover64: are you talking about http://hackage.haskell.org/packages/archive/compdata/0.6.1/doc/html/Data-Comp-Algebra.html#t:AlgM
09:55:01 <applicative> Abraxas: I can't follow, quite, does hlint want, e.g. win g =  any (==True) $ map (\x -> x g)  ... or maybe   win g =  any (==True) $ map ($ g)
09:55:21 <dmwit> Overload: or any of the type-annotated functions from http://stackoverflow.com/a/6298414/791604 =)
09:55:30 <rpglover64> Cale: That's what I'm using as a reference for monadic algebras in typical (functoral?) style, yes.
09:55:35 <Cale> rpglover64: By the way, this terminology is maximally confusing, given that a monadic algebra is not the same thing as an algebra for a monad.
09:55:47 <Cale> but okay
09:56:02 <b__> what is the fastest known prime generator in Haskell? http://www.haskell.org/haskellwiki/Prime_numbers#Using_ST_Array -> this looks good, and the one using template haskell doesn't compile beyond a certain number for nthPrimes
09:56:04 <Abraxas> hold on, i update
09:56:20 <rpglover64> Cale: Category theory hurts my brain; I've been trying to cram it in for a while now, and it keeps leaking out
09:56:26 <applicative> b__: I would look at the arithmoi package
09:56:40 <Cale> rpglover64: Have you seen Awodey's book?
09:57:04 <ksf> rpglover64, don't cram, slurp.
09:57:10 <hpaste> Abraxas annotated “tic-tac-toe in progress” with “tic-tac-toe in progress (annotation)” at http://hpaste.org/76323#a76327
09:57:34 <Abraxas> haha, now it says "use any"
09:58:00 <Abraxas> if i use "any" it wants "elem"...now i took the advice to replace it with "or" instead, it wants "any" :D
09:58:01 <jesyspa> Abraxas: Why win = \g -> instead of just win g = ?
09:58:37 <rpglover64> We used Awodey's lecture notes, Pierce's book, and "Joy of Cats"; none of it is really sticking.
09:58:38 <b__> applicative, it does look good, implementing the sieve of Erastosthenes using Data.Array.ST unboxed
09:58:39 <jesyspa> Also, I'm pretty sure you should be able to make lines 91-99 with a list comprehension...
09:58:43 <Abraxas> oh, yeah, that was to help me think about something
09:58:52 <b__> for some reason people are very keen to implement this sieve using lists in haskell
09:59:22 <b__> resulting in awful performance
09:59:36 <Cale> rpglover64: There's also a nice set of lectures on YouTube by "TheCatsters"
09:59:57 <rpglover64> Cale: Thanks. I'll look into it.
10:00:01 <Abraxas> but anyway, that map expression is probably possible with flip
10:00:07 <b__> I wonder if there's a reason why people in general choose to implement the sieve of Erastothenes instead of that of Atkin
10:00:08 <Cale> They don't cover everything, but what they do cover, they do in an interesting and helpful way
10:00:53 <Abraxas> but it's not just "flip map" unless i do something wrong
10:00:55 <Cale> rpglover64: anyway, if you have a specific question about this stuff, I might be able to help you find an answer to it, but I'm not terribly familiar with this library
10:01:24 <jesyspa> Abraxas: Isn't (\x -> x g) just ($g2?
10:01:30 <jesyspa> ($g)*
10:03:05 <Overload> is there already some GHC extension capable to infer types for polymorphic recursive functions?
10:03:22 <applicative> b__: http://hackage.haskell.org/packages/archive/factory/0.2.0.4/doc/html/Factory-Math-Implementations-Primes-SieveOfAtkin.html
10:03:44 <b__> applicative, thanks a bunch
10:04:17 <b__> that source code is a good reason to throw 80-char line limit over board
10:04:20 <Abraxas> jesyspa: yes, that works =)
10:04:29 <Abraxas> i knew it was simpler
10:05:02 <Abraxas> that's the function application operator?
10:05:19 <rpglover64> Cale: I tried reading through the papers on it last year and found them impenetrable; I'm trying to take ideas from this work (http://www.cs.utexas.edu/~bendy/MTC/index.php), and port them back to haskell.
10:05:35 <jesyspa> Abraxas: I think so, yes.
10:05:40 <Abraxas> so that's what you do whenever you want to apply the function in the back
10:06:16 <b__> applicative, do you know anything about the performance of this implementation?
10:07:18 <Abraxas> hoogle: "It is also useful in higher-order situations, such as map ($ 0) xs, or zipWith ($) fs xs."
10:07:27 <Abraxas> what is that map thing?
10:07:43 <Abraxas> applying a zero to elements in the list...?
10:07:54 <jesyspa> Abraxas: Apply every function in xs to 0
10:08:26 <Abraxas> i apparently forgot what i was just asking about
10:08:31 <ClaudiusMaximus> > map ($ x) [f, g, h]
10:08:33 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:08:33 <lambdabot>    `GHC.Show.Show b'
10:08:33 <lambdabot>      a...
10:08:35 <Abraxas> :D
10:08:45 <ClaudiusMaximus> > map ($ x) [f, g, h] :: [Expr]
10:08:47 <lambdabot>   [f x,g x,h x]
10:09:04 <Abraxas> yeah, sure
10:09:23 <Abraxas> i thought the other way around again, immediately
10:09:30 <Cale> rpglover64: Is the code in that paper not just sugary Haskell code?
10:09:33 <ClaudiusMaximus> > zipWith ($) [f, g, h] [x, y, z] :: [Expr]
10:09:35 <lambdabot>   [f x,g y,h z]
10:09:38 <Abraxas> although it's just been 3 seconds i "figured it out", lol
10:09:43 <kirindave> I can't believe how excited I am for edwardk's talk this thurs.
10:09:55 <kirindave> I didn't even know about it until sunday.
10:09:56 <ClaudiusMaximus> there's operator sections, if you don't know them yet
10:09:57 <edwardk> =)
10:10:09 <Cale> edwardk: What are you talking about?
10:10:10 <rpglover64> Cale: It has subtle differences (e.g. the typeclass code works in coq but not in haskell) and doesn't fully capture what I think I want.
10:10:12 <jesyspa> > foldr ($) 1 [f, g, h]
10:10:13 <lambdabot>   Ambiguous type variable `b' in the constraints:
10:10:13 <lambdabot>    `SimpleReflect.FromExpr ...
10:10:17 <jesyspa> > foldr ($) 1 [f, g, h] :: [Expr]
10:10:19 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
10:10:19 <lambdabot>    arising from the lite...
10:10:20 <jesyspa> :(
10:10:27 <edwardk> Cale: lenses, folds and traversals, and then a quick dive into the port of uniplate and zippers
10:10:36 <Cale> cool!
10:10:46 <Abraxas> i know sections, i also read about that operator, but forgot
10:11:01 <edwardk> shachaf seems somewhat amused by the turnout so far
10:11:08 <copumpkin> edwardk: I worked on simplifying skew binary naturals last night! got them slightly simpler, but still not simple enough to make me feel like it's worth slogging through the uniqueness proof. I feel like there is more simplicity that I must squeeze out
10:11:13 <kirindave> edwardk: The fact that your lens library showed up right as I need something to work through that issue of mapping arbitrary attribute key-values into arbitrary data objects is only partly to blame for my exuberence, though. I just want to see if I can understand how you implemented the lenses. Codata and Comonads have been on my grok list for awhile.
10:11:14 <Cale> edwardk: How so?
10:11:20 <edwardk> copumpkin: doh
10:12:14 <edwardk> cale: i think he said something about how he didn't know there were that many people enthusiastic about haskell in the bay area ;)
10:12:19 <Abraxas> let's give that hpaste the fold it's crying about and then i update the end result
10:12:31 <Cale> kirindave: I'm not sure it should be necessary to understand codata for this?
10:12:48 <luite> is it the biggest bahug yet?
10:12:53 <Cale> kirindave: At least, as distinct from 'data' in the sense of total functional programming languages
10:13:02 <edwardk> luite: from the sounds of it
10:14:08 <dmwit> In what package/module can I find a kind-polymorphic data Proxy t = Proxy?
10:14:17 <edwardk> And here i am doped up on hydrocodone cough syrup and trying not to lose my voice before the talk =P
10:14:38 <thoughtpolice> dmwit: tagged has it, but i don't think edwardk added a conditional PolyKinds pragma
10:14:48 <edwardk> i did
10:15:05 <thoughtpolice> well, nevermind then, disregard me :)
10:15:05 <kirindave> Cale: For lenses?
10:15:16 <edwardk> thoughtpolice: http://hackage.haskell.org/packages/archive/tagged/0.4.4/doc/html/src/Data-Proxy.html
10:15:16 <Cale> kirindave: Yeah
10:15:26 <Cale> kirindave: There's some stuff related to specific comonads in there though
10:15:30 <kirindave> Cale: I just sort of conflate learning them because basically every tutorial I found on the subject talks about both.
10:15:40 <dmwit> thanks
10:15:48 <Cale> oh, weird
10:15:53 <thoughtpolice> edwardk: ah yes, i can see all the new stuff in the regular docs as well (all the 'Proxy *' instances)
10:15:58 <edwardk> kirindave: i use two types that happen to be comonads in the lens library, but i don't actually use their comonadic structure at all
10:16:04 <Cale> Comonads and codata are pretty separate in my head
10:16:13 <edwardk> likewise
10:16:15 <kirindave> Cale: I have no such structure in my head.
10:16:27 <kirindave> If you guys know resources for building said structures, I'd be appreciative
10:16:59 <dmwit> How to build a structure about mathematical idea X in your head: play with X a lot.
10:16:59 <Cale> kirindave: So, I take it you've seen the definition of a comonad?
10:17:00 <kirindave> I got recommended to an old paper, Kieburtz's "Codata and Comonads in Haskell."
10:17:04 <kirindave> Cale: I have.
10:17:11 <edwardk> you can have comonads that are data, monads that are codata, etc.
10:17:12 <edwardk> kirindave: skip it. the OI comonad doesn't work =P
10:17:14 <kirindave> But it's really hazy to me how the chaining works in a meaningful way.
10:17:21 <Cale> okay, so the main example I recommend understanding is this one...
10:17:23 <joe9> can anyone help me with what I am missing here? http://codepad.org/QMH9UcEt
10:17:23 <kirindave> edwardk: Yeah I was gonna say.
10:17:28 <Abraxas> oh, but hpaste will still complain about the "any", i guess
10:17:31 <kirindave> edwardk: Not referentially transparent.
10:17:32 <Cale> Oh, you also know what a monoid is?
10:17:36 <kirindave> Yes.
10:17:38 <kirindave> In fact. :\
10:17:40 <joe9> the first line has this: {-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}
10:17:41 <edwardk> kirindave: have you worked through any comonads?
10:17:48 <Abraxas> that it wants any for or, although it wanted elem for any
10:17:53 <Cale> Okay, so take any monoid m and consider the functor (->) m
10:17:55 <kirindave> edwardk: The only one I have ever used to solve a real problem is a zipper
10:17:56 <joe9> but, I still get this error: Use -XFlexibleInstances if you want to disable this.)
10:18:00 <Cale> of functions whose domain is m
10:18:07 <kirindave> But then you do cojoin and I'm like, "Zipper of zipper whu-whuut?"
10:18:26 <kirindave> Like every possible zipper as a zipper or something.
10:18:27 <edwardk> kirindave: try writing extract :: (e, a) -> a; extend :: ((e, a) -> b) -> (e,a) -> (e,b)
10:18:37 <Cale> kirindave: We have a natural definition of  extract :: (m -> a) -> a
10:18:41 <kirindave> Yeah
10:18:43 <Cale> which just applies the function to mempty
10:18:48 <kirindave> And I sort of understand how that relates to, say, OO programming.
10:18:49 <edwardk> or pursue cale's trickier exponential comonad example =)
10:18:59 <hpaste> Abraxas annotated “tic-tac-toe in progress” with “tic-tac-toe in progress (annotation)” at http://hpaste.org/76323#a76329
10:19:01 <copumpkin> expocomonad
10:19:09 <copumpkin> expokemonad?
10:19:15 <Abraxas> lol, look at that
10:19:15 <thoughtpolice> pokemonad
10:19:18 <edwardk> The Comonad Expo sounds like a gun show
10:19:22 <Abraxas> it wants any TWICE, now
10:19:27 <kirindave> Comocha
10:19:31 <kirindave> *sip*
10:19:39 * copumpkin takes a sip of his Cofree
10:19:51 <edwardk> kirindave: no, cocoffee is just ffee.
10:19:53 <Cale> kirindave: Following? So what we need next is a  duplicate :: (m -> a) -> (m -> m -> a)
10:20:14 <kirindave> Cale: Give me a moment to recover from the levity.
10:20:20 <Saizan> no toffee?
10:20:23 * copumpkin levitates kirindave 
10:20:41 * Cale gravitates kirindave 
10:20:46 <edwardk> Saizan: too much (syntactic) sugar for my taste
10:21:12 <Cale> kirindave: and of course, there's a natural one of those too:  duplicate f x y = f (mappend x y)
10:21:17 <kirindave> Cale: Okay, I am with you, m -> *.
10:21:42 <Cale> right, this would be (m ->) if we could write it like that :)
10:21:45 <johnw> ooh, I want a comocha
10:21:46 <kirindave> Cale: Okay.
10:21:54 <johnw> that's when you put coffee in chocolate
10:21:54 <kirindave> johnw: It is just black coffee.
10:21:58 <Abraxas> i don't need map here? win player =  any ($player) [...
10:22:07 <Cale> kirindave: Okay, so now let's plug in m = Integer with mempty = 0 and mappend = (+)
10:22:14 <johnw> that's not a co-mocha!  that's just co-ffee
10:22:17 <Cale> (i.e. use the Sum instance)
10:22:23 <kirindave> Cale: I'll need a moment to consider that.
10:22:24 <Abraxas> as opposed to: win player =  or . map ($player) $ [...
10:22:40 <Saizan> ?src ant
10:22:40 <lambdabot> Source not found. I've seen penguins that can type better than that.
10:22:42 <Saizan> ?src any
10:22:43 <lambdabot> any p =  or . map p
10:23:01 <Cale> kirindave: Think of a function Integer -> a as a doubly-infinite sequence of a's
10:23:02 <Abraxas> yes, but the map was not because of any
10:23:11 <kirindave> Cale: I appreciate not using the =>> and whatnot stuff. I confess I am always 50% more confused when people use the infix operator notation.
10:23:20 <Abraxas> i thought i needed the map to apply the ($) to elements in the list
10:23:21 <kirindave> Doubly infinite?
10:23:45 <Abraxas> seems to work, though
10:23:54 <Saizan> but "or . map f" is the same as "any f" by definition, so if one works so will the other
10:23:55 <Cale> kirindave: Well, like you'd write down all the integers:  ..., -3, -2, -1, 0, 1, 2, 3, ...
10:24:09 <Cale> kirindave: and associate each one with a value of type a
10:24:57 <Abraxas> ah, sorry
10:25:21 <edwardk> kirindave: i wrote the comonad library, and all the comonad-transformers, and i still have trouble using =>>. This is one reason why I call the main operator extend ;)
10:25:42 <kirindave> Cale: I suppose it is no coincidence that Comonads are easier to grasp when they're referring to a function. I find very much the opposite to be true for monads, so...
10:25:44 <kirindave> SYMMETRY.
10:25:46 <Abraxas> haha, funny how we came back around to "any" when at first hpaste complained about it, because the rest was wrong
10:25:48 <kirindave> But yes, I think I follow.
10:25:52 <johnw> =>> looks too much like a typo
10:26:19 <Cale> kirindave: actually, the ironic thing is that the dual to this comonad is the writer monad, which is the one common one which isn't a sort of functions :)
10:26:51 <Cale> kirindave: but saying that isn't very helpful for understanding this
10:26:56 <hpaste> Abraxas annotated “tic-tac-toe in progress” with “tic-tac-toe in progress (annotation)” at http://hpaste.org/76323#a76330
10:27:05 <edwardk> kirindave: what you just worked through with cale was the 'Traced' comonad: http://hackage.haskell.org/packages/archive/comonad-transformers/3.0/doc/html/Control-Comonad-Trans-Traced.html sometimes abusively called cowriter
10:27:09 <Cale> So, anyway, think of such a function as a sort of container
10:27:29 <Cale> What extract is doing is pulling out the value of the container at index 0
10:27:50 <edwardk> kirindave: the environment comonad (sometimes mislabeled "coreader") uses  (,) e
10:28:05 <Cale> and what duplicate is doing is building a container where the value at index i is a copy of the original container, but where all the indices have been shifted by i
10:28:34 <edwardk> and has properties like reader, just like Monoid m => Comonad ((->) m)    gives you properties that vaguely resemble writer
10:28:39 <Cale> So with that mental image, you can see why  fmap extract . duplicate = id
10:28:48 <kirindave> Cale: I can _try_.
10:28:52 <Cale> and why  extract . duplicate = id
10:28:54 <kirindave> I can't imagine using this traced comonad.
10:29:02 <kirindave> But that's probably just a function of not having done so.
10:29:11 <Cale> I'm not sure why edwardk calls this the traced comonad, myself
10:29:22 <kirindave> I'm told by friends that increasingly people reach for comonads to help describe some things.
10:29:22 <Cale> I think of it as the comonad of generalised cellular automata :)
10:29:30 <Cale> :D
10:29:38 <kirindave> So I want to build an intuition.
10:29:59 <Cale> Okay, so the state of a 1-D cellular automaton is more or less a function Integer -> a
10:30:02 <edwardk> trace :: Comonad w => m -> TracedT m w a -> a   is kind of like tell, but you have sort of a log of what has been done to the comonadic value, a trace as it were, that you are free to discard
10:30:07 <Cale> where perhaps a = Bool, for concreteness
10:30:20 <edwardk> when you extend the trace you add more to it
10:30:36 <joe9> can anyone please help me with what I am missing here? http://codepad.org/QMH9UcEt I am clueless
10:30:46 <kirindave> edwardk: So each operation has to give a trace and optionally change the value?
10:30:52 <Cale> So if we have some function Integer -> Bool representing our cellular automaton state, we can write a function which evaluates the cellular automaton at 0
10:31:11 <Cale> Which has type (Integer -> Bool) -> Bool
10:31:29 <kirindave> Oh interesting
10:31:43 <Cale> and to produce a step of the cellular automaton means to carry this out on all translations of the original state
10:32:01 <Cale> So if  f :: (Integer -> Bool) -> Bool  is our evaluation-at-zero function
10:32:07 <Cale> then  fmap f . duplicate
10:32:17 <Cale> is a complete step of the cellular automaton
10:32:35 <edwardk> kirindave: yes, but of course you have an empty initial trace you can supply: mempty
10:32:46 <edwardk> and fmap f . duplicate is 'extend f' in the vocabulary of the comonad package
10:32:54 <kirindave> edwardk: I can see then why it's called cowriter. But I agree that's weird.
10:33:14 <kirindave> Cale: So you can keep providing steps.
10:33:16 <edwardk> kirindave: well, the reason i dislike the 'cowriter' vocabulary is that it leads to bad intuitions
10:33:22 <Cale> kirindave: sure
10:33:33 <Cale> kirindave: Or just run this step over and over :)
10:33:36 <kirindave> So this is a lot to chew on, mentally.
10:33:44 <edwardk> in particular cowriter isn't dual to writer. its a comonad built from the other side of the adjunction
10:33:51 <kirindave> Cale: But at each point you basically feed a step in and the history is there for the step to be executed on.
10:33:54 <Cale> kirindave: Of course, this is a terribly inefficient mechanism described like this, because functions aren't by default memoised
10:34:09 <Cale> But we could represent this in a slightly different way and do a lot better:
10:34:29 <Cale> data Cellular a = C [a] a [a]
10:34:36 <kirindave> Which is a zipper.
10:34:37 <b__> applicative, that sieve of Atkin has the same performance as a fairly straight implementation of the sieve of Erastosthenes
10:34:39 <Cale> yeah
10:34:39 <kirindave> Hello one hole context
10:34:42 <edwardk> kirindave: yep
10:34:44 <kirindave> I recognize you anywhere now.
10:34:57 <kirindave> But then the [a] on the right is the future?
10:35:06 <Cale> You can also see how one of those where the lists are infinite is just a function Integer -> a
10:35:07 <Cale> right?
10:35:07 <edwardk> even the crazy zippers i have in lens use that as a building block
10:35:31 <edwardk> Cale: to be pedantic its both the function and a seleted Integer ;)
10:35:35 <Cale> (perhaps I should have been explicit and used   data Cellular a = C (Stream a) a (Stream a)
10:35:37 <edwardk> its more like Store than Traced ;)
10:35:44 <kirindave> Cale: I sort of get that, yes.
10:35:55 <Cale> edwardk: The selected Integer is selected by the monoid instance to be 0
10:36:08 <applicative> b__: that doesn't surprise me, I dont think that Factory package is aiming for speed as arithmoi emphatically is, though it doesnt have atkins seive
10:36:10 <edwardk> fair nuff
10:36:11 <kirindave> So as I graduate from raw haskell newbie to mild haskell user
10:36:31 <kirindave> Probably the most surprisingly hard thing for me to do is explicitly represent computations like that with data.
10:36:50 <kirindave> I don't know why it's always so mind bending.
10:36:58 <Cale> kirindave: Well, the trick is to stop thinking of them as computations
10:37:02 <Cale> (for a moment)
10:37:17 <Cale> and just picture the function as a set of pairs of inputs and their corresponding outputs
10:37:18 <kirindave> Cale: It's like the state of the computation in an instant, at a specific point.
10:37:27 <joe9> edwardk, cale, ; I have seen you quite a bit here. Wondering if you can please help me? http://codepad.org/QMH9UcEt
10:37:43 <joe9> edwardk, cale: the file has FlexibleInstances defined there.
10:37:48 <joe9> I am not sure what I am missing
10:37:55 <applicative> joe9: is it that QuickCheck.Property is not what it seems
10:38:24 <Cale> kirindave: A function A -> B is a (perhaps infinite) indexed container, where there are cubbyholes labelled with all the values of type A, and where each cubbyhole has a value of type B in it.
10:38:36 <applicative> joe9: type Property = Gen Prop
10:39:00 <edwardk> i'd actually mention that in #ghc. they might consider it a compiler bug
10:39:15 <joe9> edwardk: ok, thanks.
10:39:30 <Cale> orly?
10:39:40 <Cale> I don't think it's a compiler bug to require FlexibleInstances there
10:39:43 <joe9> applicative: i do not understand what you mentioned. let me check the quickcheck. property file.
10:39:49 <applicative> joe9: add TypeSynonymnInstances
10:39:53 <edwardk> Cale: it has FlexibleInstances but the suggested fix is to turn it on
10:39:57 <joe9> Cale, there is a flexibleinstances there in that file.
10:39:59 <Cale> oh, right
10:40:00 <applicative> joe9: Property is a type synonym
10:40:01 <edwardk> applicative: its already there
10:40:08 <edwardk> see the top of his paste
10:40:15 <Cale> Yeah, it means to be asking you to turn on TypeSynonymInstances :)
10:40:22 <joe9> applicative: yes, it is there.
10:40:23 <applicative> ah indeed
10:40:27 <edwardk> find . -iname "QUnit.hs" -exec head -20 {} \;
10:40:27 <edwardk> {-# LANGUAGE TypeSynonymInstances, FlexibleInstances #-}
10:40:33 <applicative> I was focussed on the error
10:40:49 <Cale> er, weird
10:40:53 <edwardk> so that code has done everything it should do to address the error it received
10:40:57 <Cale> lol
10:41:03 <Cale> Okay, yeah, that's definitely a bug
10:41:07 <applicative> I does seem like a bug, on the other hand its kind of annoying to go about things that way
10:41:13 <Cale> What happens if you expand the synonym?
10:41:13 <edwardk> hence why i directed him to #ghc =)
10:41:32 <joe9> edwardk: cale, applicative: thanks a lot, guys.
10:41:33 <Cale> (by hand)
10:41:33 <applicative> Cale: thats what I was going to suggest
10:42:41 <joe9> cale, applicative: what does FlexibleInstances expand to?
10:42:58 <Cale> joe9: I mean replace  Property  in your instance head with  Gen Prop
10:43:16 <applicative> he means, write Gen Prop instead of Property.  with the qualification
10:43:25 <applicative> ha
10:43:30 <b__> applicative, Factory is better than arithmoi for > 10000000 or so
10:43:43 <b__> but still, a plain Erastosthenes is faster
10:44:40 <applicative> b__: is that right?  hah, wait till Daniel Fischer finds out
10:45:21 <b__> plain Erastosthenes with Data.Array.ST is faster yes, and far more simple
10:45:47 <joe9> cale, applicative: got it, thanks. will do.
10:46:03 <kirindave> Cale: Thanks for walking through that with me. The more I think about it the more I think I get it.
10:47:05 <kirindave> Cale: I should probably try implementing it to help solidify my intuition. I'm a bit confused what happens when you do "extend f" on one of these Zippers-as-instant-of-computation, does it change the left side as well as the right, and what the heck that means. :)
10:47:16 <Cale> kirindave: Most comonads have some of that feel to them. The extract pulls out the value at some specific point in the container, and the duplicate produces a container full of all the "shiftings" of the original.
10:47:52 <nus> joe9, http://hackage.haskell.org/packages/archive/Extra/1.42/doc/html/src/Test-QUnit.html -- differs from what you've pasted, perhaps cabal is picking up a pristine package?
10:48:11 <nus> s/a pristine/the unmodified version of/
10:48:26 <Cale> kirindave: it changes everything
10:48:38 <Cale> kirindave: (potentially)
10:48:57 <kirindave> Cale: The Corporate Release extend.
10:48:59 <joe9> nus, let me delete the extra folder in .cabal/packages/ and try.
10:49:05 <kirindave> Cale: The entire market, changed
10:49:12 <kirindave> Cale: So really what it does is recast the entire thing.
10:49:15 <Cale> kirindave: It produces the result of applying the 1-D cellular automaton rule everywhere
10:49:58 <joe9> nus: http://codepad.org/wuNT86LD
10:50:07 <joe9> nus, it says it downloaded the package.
10:50:15 <Cale> We can also get a 2-D cellular automaton in our original presentation by replacing the monoid Integer with (Integer,Integer) with the obvious operation
10:50:40 <Cale> and then implement the game of life rule as a function ((Integer, Integer) -> Bool) -> Bool
10:50:44 <klr> hmm, may i ask what "xs" means? it's used a lot in learnyouahaskell book, is it like "foo" and "bar" but haskell's own?
10:50:49 <joe9> nus, you are correct
10:50:55 <Cale> which evaluates using just the neighbourhood of (0,0)
10:50:58 <joe9> it was picking a modified package.
10:50:58 <nus> joe9, I'm not sure how do you think cabal works
10:51:08 <joe9> nus, thanks for picking that up.
10:51:08 <Overload> "xs" is the plural of "x"
10:51:12 <kirindave> Cale: That is a pretty big mental meal to pick over. Is that plan actually efficient?
10:51:14 <Cale> and then extend f will play the game of life on the whole plane
10:51:23 <klr> Overload: and what does "x" mean?
10:51:29 <ousado> klr: yes, for multiple things
10:51:44 <klr> okey
10:51:49 <Cale> kirindave: It's not efficient if you leave things in a functional form, because functions don't get memoised, so as you iterate this, it's going to get slower and slower
10:51:50 <klr> so it is like "foo"?
10:51:53 <kirindave> Cale: One thing I haven't heard in this is the traditional zipper forward-back rules. Are those domain specific or generic or did I just miss them?
10:51:57 <Cale> kirindave: for one step it's efficient
10:52:26 <Overload> klr: its the most usual argument, like in f x = x+2
10:52:26 <kirindave> Like extend changes the machine's rules.
10:52:32 <Cale> kirindave: duplicate is producing a structure with all the iterates of forward/back in it
10:52:35 <kirindave> extract gets the result at 0
10:52:47 <klr> Overload: so "x" is the input?
10:52:49 <kirindave> Right but let's say I want to see the result at 1
10:53:11 <Overload> klr: xs generally refer to  a list, like in f (x:xs) = x + f xs
10:53:28 <Cale> kirindave: then you look at the head of the list on the right
10:53:36 <Cale> kirindave: and then you extract :)
10:53:38 <kirindave> Okay so it requires insight into the structure of the zipper.
10:53:54 <kirindave> Or rather a sort of domain-specific operation to tug the one hole context over.
10:54:05 <kirindave> Which varies based on the type zipped over.
10:54:09 <klr> Overload: okey, but what does it in itself stand for, is it the input or output or sth else? (thx for the help btw :) )
10:54:46 <ousado> klr: it's just used as a name for a value
10:55:06 <FireFly> klr: 'x' is basically an arbitrary value
10:55:27 <klr> hmm, okey, why not use a more explaining variable for what the value is? =o
10:55:31 <Cale> kirindave: Of course, the movements available in any given zipper will vary as well
10:55:33 <FireFly> 'f' is sometimes used for functions, and the 's' prefix for lists
10:56:08 <FireFly> err, 's' suffix I mean. as in xs or fs
10:56:17 <kirindave> Cale: So the comonad defintion doesn't generally concern itself with that.
10:56:42 <Cale> right
10:56:56 <luite> anyone using optparse-applicative? what's the best way to collect all options after some --argument as a list of strings? for example ./myProgram --x 1 --y 2 --collect a -b c -d e  which would give me a list of ["a","-b","c","-d","e"] for the collect option?
10:57:30 <ousado> klr: often haskell code is quite abstract / generic, so it depends on the use
10:57:33 <Cale> and tbh it doesn't really concern itself with the fact that that case is a zipper either, but whenever you have a zipper which you can move around, you probably have some kind of comonad structure there
10:58:00 <klr> hmm, okey, i dont know what abstract mean but i know what generic means :)
10:59:19 <Abraxas> klr: (x:xs) is just the common way to write lists
10:59:42 <kirindave> Cale: This has been awesome. Thanks.
10:59:44 <Cale> (x:xs) means the non-empty list whose first element is x and where the rest of the list is xs
10:59:45 <klr> Abraxas: ok
10:59:49 <kirindave> Cale: I won't take anymore of your time.
10:59:59 <Abraxas> you could always write name@(x:xs) to give a name to the list
11:00:04 <Cale> kirindave: Cool, it's no problem really :)
11:00:45 <Abraxas> you will often use that (x:xs) pattern to write a function
11:01:51 <klr> im trying to write an function that reverses a list or string of three elements https://gist.github.com/3894010 but it wont load into ghci due to " Parse error: naked expression at top level
11:01:56 <klr> "
11:02:12 <Cale> klr: you're missing an = sign
11:02:16 <clahey> On the second line
11:02:19 <Cale> also
11:02:19 <klr> okey
11:02:20 <klr> thanks
11:02:22 <Cale> the type is wrong
11:02:24 <klr> ups xD sry
11:02:27 <Cale> [a,b,c] isn't a type
11:02:30 <clahey> [a] -> [a]
11:02:41 <klr> ok thanks
11:02:56 <rpglover64> Are any of the solutions to the expression problem in Haskell accepted as canonical?
11:03:00 <Cale> also, why wouldn't the reverse of [] be []?
11:03:13 <Cale> rpglover64: I dunno, typeclasses?
11:03:20 <clahey> Also, why would you write a reverse function that could only take 3 elements?
11:03:21 <rpglover64> Don't fully solve it
11:03:30 <klr> it worked, my first own function :)
11:03:36 <clahey> klr: Ah, fair enough.
11:04:02 <klr> hmm, now i have to figure out how to write it so it can be used for larger lists and strings... :)
11:04:13 <Cale> rpglover64: what are you missing? :)
11:04:26 <clahey> klr: Do you want help or do you want to do it on your own?
11:04:55 <klr> clahey: I'll try to do it myself, if it takes more than a few days i might consult help :)
11:05:25 <clahey> klr: The help would be Socratic, if that helps.
11:05:50 <rpglover64> Cale: Unless you go basically the whole finally-tagless nine yards, you can't extend your data representation without modifying or duplicating code.
11:05:55 <Cale> http://ecn.channel9.msdn.com/o9/ch9/7020/567020/C9LecturesRalfLaemmelAFPTypeClasses_ch9.mp4
11:05:56 <klr> clahey: sorry for my bad knowledge of english but what is "Socratic"?
11:06:04 <clahey> klr: It means I'll ask you questions to help you learn.
11:06:21 <klr> clahey: aa, cool , thank you :)
11:06:50 <Cale> rpglover64: Well, the extent to which you solve the problem is up to you, but you can essentially encode open functions on open datatypes with typeclasses.
11:06:54 <clahey> klr: Okay, I'm reading the definition of Socratic method and I apparently have a bit to learn.
11:07:30 <ACE1> Hi, can someone please help with basic C programming? Q: What are the values of b, c and d after this statement? b=c=d=5;
11:07:37 <klr> clahey: okey :)
11:07:50 <zomg> ACE1: 7
11:07:56 <Cale> ACE1: you realise you're asking in #haskell?
11:08:06 <clahey> ACE1: Error, wrong channel.
11:08:08 <pettter> ACE1: a) try it b) what Cale said
11:08:09 <clahey> Also, ignore zomg.
11:08:15 <zomg> clahey: what :(
11:08:37 <zomg> it's obviously 7 because he has 5, and two variables c and d, and the start variable b
11:08:49 <Cale> I would expect that to be undefined behaviour, but I don't really know
11:08:58 <maukd> Cale: why undefined?
11:09:07 <mcstar> i know, 5
11:09:12 <clahey> Cale: Nope, they're all equal to 5.
11:09:13 <tromp> no, zomg, that would give d=5,c=6,b=7
11:09:16 <mcstar> if the types are right..
11:09:27 <zomg> tromp: you obviously don't know C
11:09:28 <zomg> ;>
11:09:33 <Cale> maukd: I just expect everything in which multiple effects occur on the same expression to be undefined behaviour, pessimistically.
11:09:41 <tromp> enough to win the ioccc:)
11:09:54 <zomg> You guys are no fun
11:09:56 <zomg> lol
11:09:57 <rpglover64> +1 Cale
11:10:11 <clahey> Cale: = is right associative and returns the value assigned.  Multiple effects is only a problem when it's multiple effects on the same variable.
11:10:20 <mcstar> zomg: if nobody will tell you, ill do it, youre funny
11:10:21 <S11001001> zomg: however, if the type of c is int*, then it is set to point to d
11:10:39 <ACE1> Ok thanks, how about, a = 5 + b;   //What is the value of a?
11:10:52 <clahey> ACE1: Why are you asking here?  Is it a troll attempt?
11:10:53 <zomg> ACE1: compile it and find out
11:11:00 <klr> hmm, can't i do list with variables like this: [a..z] ?
11:11:02 <mcstar> 5 will be equal to 7 and b will be the sum of + and a
11:11:31 <clahey> klr: Only if their type is an instance of Ord.
11:11:49 <mcstar> > ['a'..'z']
11:11:50 <ACE1> @clahey No troll, I don't know where else to go...
11:11:50 <lambdabot> Unknown command, try @list
11:11:50 <lambdabot>   "abcdefghijklmnopqrstuvwxyz"
11:11:52 <Cale> clahey: This may be true, but I will continue to not assume it is :)
11:12:13 <clahey> klr: In which case you'll get the values in between.
11:12:15 <maukd> Cale: that would make c = getchar(); undefined
11:12:34 <maukd> ACE1: how about a channel or forum where C is on-topic?
11:12:35 <parcs`> clahey: Enum actually
11:12:38 <clahey> Cale: It's a pretty safe assumption.  If he had said C++, for instance, all bets would have been off.
11:12:40 <clahey> parcs`: Thank yoU!
11:12:43 <klr> clahey: okey, hmm, then this with allowing more elements of the reverse functions will be a bit harder
11:12:45 <parcs`> :t \a b -> [a..b]
11:12:47 <lambdabot> forall t. (Enum t) => t -> t -> [t]
11:12:48 <clahey> Ord is ordering... my bad.
11:13:03 <clahey> klr: And even if they were Enums it wouldn't do what you're imagining they would do.
11:13:13 <klr> ok
11:13:20 <clahey> Such as #c.
11:14:25 <clahey> Cale: For example, i = j++; is always valid in C, but if i and j are references to the same memory location, it's undefined in C++.
11:14:26 <Cale> maukd: good point, perhaps I should make an exception for an assignment of the result of an effectful procedure call.
11:15:03 <maukd> printf("%d", i++);
11:15:42 <Overload> did anyone ever needed to use a polymorphic recursive function whose type was not inferable by GHC?
11:16:27 <solirc> Combining a list of predicates with (||), is there a nicer way than: foldr (liftA2 (||)) (const False)
11:16:34 <parcs`> don't all polymorphic recursive functions require a type signature?
11:16:46 <maukd> :t any
11:16:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:17:06 <maukd> :t \fs x -> any ($ x) fs
11:17:07 <lambdabot> forall a. [a -> Bool] -> a -> Bool
11:17:13 <Overload> yeah, i mean that you actually needed to use it
11:17:43 <Overload> i just wrote an inferencer that suppot polymorphic recursion and i'm looking for non-useless tests :P
11:18:34 <Saizan> with non-regular types they are pretty common
11:18:36 <clahey> @pl
11:18:37 <lambdabot> (line 1, column 1):
11:18:37 <lambdabot> unexpected end of input
11:18:37 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
11:18:42 <clahey> @pl \fs x -> any ($ x) fs
11:18:43 <lambdabot> flip (any . flip id)
11:19:01 <clahey> :t flip id
11:19:02 <lambdabot> forall a b. a -> (a -> b) -> b
11:19:58 <clahey> That's very cute.
11:20:09 <clahey> Took me a second to work out what flip id would be.
11:21:30 <copumpkin> :t const id
11:21:31 <lambdabot> forall a b. b -> a -> a
11:21:31 <copumpkin> :t flip const
11:21:32 <lambdabot> forall b a. a -> b -> b
11:21:36 <Cale> maukd: printf("%d", i++); is an example of something I *wouldn't* write
11:22:22 <parcs`> are 'read' and 'show' considered polymorphic-recursive?
11:23:10 <Cale> If I have to write imperative code these days, I translate it from Haskell do-notation in my head, and separate effects onto different lines as much as possible.
11:23:44 <Overload> parcs`: yes, thx
11:23:45 <johnw> yay, a new lens!
11:23:53 <johnw> edwardk read my mind
11:23:59 <klr> time for bed, thanks for all help! :) bye!
11:24:03 <rpglover64> Cale: How would you use typeclasses to write a) a function from an AST whose nodes are additions and integers to integers, and b) a function from an AST whose nodes are as before but also booleans and conditional expressions to something equivalent to Maybe (Either Int Bool) without modifying or rewriting the code from (a)
11:24:27 <maukd> Cale: when you have something like printf("%d", ctx->slots[hash(&state, ctx->caller.name)]++), do you repeat the whole thing?
11:25:28 <Cale> rpglover64: Doesn't he more or less do that example in the video?
11:25:38 <rpglover64> video?
11:25:38 <Cale> rpglover64: Maybe I forgot what that video had in it
11:26:16 <rpglover64> and ambiguous occurrance: "he"
11:26:20 <Cale> http://channel9.msdn.com/Shows/Going+Deep/C9-Lectures-Dr-Ralf-Lmmel-Advanced-Functional-Programming-Type-Classes -- (see the links on the right, under "download")
11:26:36 <Cale> (I linked you this before, or at least I thought I did)
11:26:36 * hackagebot cabal2nix 1.40 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.40 (PeterSimons)
11:26:58 <rpglover64> Ah; you did. I missed it
11:27:02 <parsercombinator> hello
11:27:36 <Cale> hello
11:32:57 <Cale> rpglover64: In any case, we don't actually tend to do the whole shebang because it *is* slightly awkward, but it's possible to do it if you really wanted to.
11:34:01 <rpglover64> Cale: Right; I want the whole shebang and then some and for it to be pretty.
11:37:15 <parsercombinator> whoke shebang?
11:37:18 <parsercombinator> whole*
11:39:55 <parsercombinator> this isnt directly related to Haskell, but what is a combinator and why are they useful?
11:40:32 <rpglover64> parsercombinator: it's another name for a function, but one that serves a specific purpose
11:40:41 <parsercombinator> ah
11:41:11 <arbn> parsercombinator: It's a function with no free variables.
11:41:49 <parsercombinator> I thought it was a Higher-Order function that combines functions into a new one
11:42:41 <arbn> parsercombinator: http://www.haskell.org/haskellwiki/Combinator
11:42:50 <rpglover64> It doesn't need to combine _functions_
11:42:51 <arbn> There are two separate definitions.
11:42:59 <rpglover64> e.g. a parser combinator combinse parsers
11:44:09 <parsercombinator> arent parsers just glorified functions?
11:44:13 <rpglover64> yes
11:44:19 <arbn> But, the most technically meaning, and the one used in combinatory logic, is that a combinator is a pure lambda expression, i.e., with no free variables.
11:44:24 <parsercombinator> ah
11:44:25 <rpglover64> but most things are
11:44:34 <parsercombinator> so thats where the name comes from
11:44:45 <johnw> joeyh: ping
11:45:12 <edwardk> johnw: which one did i read your mind about?
11:45:20 <johnw> wanting a new version of lens :)
11:45:24 <edwardk> ah
11:45:29 <edwardk> the version bump is pretty minor
11:45:40 <edwardk> just a fix to a function that is used internally in the TH codegen
11:45:41 <johnw> and, but it means things are more better now!
11:45:48 <edwardk> true
11:46:11 <trotro> hi, I don't find the function to get the file length. is there one ? or must i used hFileSize ?
11:46:19 <rpglover64> edwardk: How do _you_ solve the expression problem?
11:46:32 <edwardk> lenses, obviously
11:46:44 <parsercombinator> lenses?
11:46:49 <arbn> In combinatory logic, you only have combinators, and function application. No variables at all. So, everything is higher-order or primitive.
11:47:08 <edwardk> @hackage lens
11:47:08 <lambdabot> http://hackage.haskell.org/package/lens
11:47:28 <parsercombinator> ah
11:47:42 <parsercombinator> so lenses are higher order functions
11:47:53 <rpglover64> edwardk: Do you have a blog post on the matter (I'm also not sure what the troll-to-truth ratio of your reply was)
11:48:11 <edwardk> rpglover64: the ratio was pretty high on the troll side ;)
11:48:25 <parsercombinator> troll, troll, troll your boat ^^
11:48:25 <Ralith> don't you know, edwardk solves everything with lenses!
11:48:39 <edwardk> the part that is true is that i tend to use lenses/traversals/makeClassy to deal with composite system state at least
11:48:45 <Cale> parsercombinator: That is true (about Edward's implementation of lenses), but it doesn't go very far in characterising what lenses are
11:48:46 <johnw> or at least, he produces a function pair that can solve everything
11:48:46 <rpglover64> But what happens when you have too many lenses?
11:48:50 <parsercombinator> ah
11:48:58 <Saizan> you get a telescope
11:48:59 <edwardk> rpglover64: you break them up into lens combinators
11:49:00 <johnw> you just have to apply it ;)
11:49:06 <rpglover64> :)
11:49:07 <edwardk> or you use telescopes, as saizan noted ;)
11:49:15 <edwardk> (telescope is an actual operator in the free library)
11:49:31 <Ralith> I thought telescopes were dependent heterogenuous lists?
11:49:47 <edwardk> Ralith: those are also called paths or thrists
11:50:08 <Saizan> paths are another thing
11:50:09 <edwardk> Ralith: er nevermind, yes, those are also called telescopes
11:50:14 <arbn> parsercombinator: Best to stick to one difficult Haskell-related concept at a time. If you chase two hares, you will catch neither. :P At least, that's my experience.
11:50:27 <rpglover64> I don't understand free monads, comonads, or cofree comonads :(
11:50:29 <edwardk> paths or thrists are a different thing
11:50:39 <edwardk> rpglover64: the troll to truth ratio on that statement was even higher
11:50:39 <Ralith> what are they?
11:50:50 <Ralith> (don't forget coffee monads)
11:50:56 <rpglover64> I figured
11:51:07 <edwardk> the coffee comonad only has one operation: wakeUp :: m ()
11:51:12 <edwardk> er monad
11:51:15 <rpglover64> One day, I'll learn to understand your libraries
11:52:36 <edwardk> rpglover64: now, the classic expression problem is that you want to be able to add both cases and handlers for those cases. have you seen the work by matthias blume on MLPolyR? i think he has the most compelling overall solution to it
11:52:46 <edwardk> or at least he has hints of the most compelling solution
11:54:03 <rpglover64> edwardk: But does the MLPolyR solution port cleanly to Haskell with GHC extensions, and is there a nice library implementing it?
11:54:06 <johnw> the coffee monad wraps me into a caffeinated version of me
11:55:08 <ciaranm> what does the ffee monad do then?
11:55:32 <edwardk> I suppose the comonad would have sip = extract flavor, dilute = duplicate; brew = extend percolator
11:55:49 <edwardk> rpglover64: no, it doesn't
11:56:29 <rpglover64> :(
11:56:34 <edwardk> a more honest solution is to use something like the "finally-tagless" encoding of shan, kiselyov and carette
11:56:49 <edwardk> then you can use subclasses for more refined 'symantics'
11:56:54 <rpglover64> right
11:56:58 <edwardk> that lets you add cases easily
11:57:36 <rpglover64> Does that run into issues with extensible codomains (like the ones tekmo ran into recently in ProxyT)?
11:58:23 <edwardk> i admit i haven't really been paying attention to what tekmo has been doing there
11:58:44 <rpglover64> I've been paying attention, but not understanding
11:59:31 <rpglover64> The issue is that upstream instances can't be used in resolution downstream; the hack/solution is to wrap the output in a GADT to capture the constraints you want to send down.
12:01:01 <Cale> Maybe I haven't implemented enough interpreters yet, but part of me always wants to shout "fuck that, just define either your cases or your operations clearly from the beginning and the forced organisation will make your code a whole lot nicer in the end"
12:01:29 <rpglover64> Cale: Two problems with that
12:01:54 <rpglover64> 1) Your spec can change out from under you, and you want minimum difficulty updating/extending
12:02:11 <rpglover64> 2) Sometimes, you have a series of related intermediate languages
12:02:30 <rpglover64> and you don't want to have to rewrite the common code.
12:02:57 <Cale> But if you, say, change a datatype, we already have the compiler to tell us where we need to make changes throughout the code.
12:03:34 <Cale> and in my experience, that works remarkably well
12:03:36 <rpglover64> Yes, but if you change the addition operation, you shouldn't need to touch the multiplication code
12:06:00 <rpglover64> edwardk: Is there a reason your packages use fundeps rather than type families?
12:11:20 <ornicar> hello, newbie here. How to implement that type? [(a -> b)] -> a -> [b]
12:11:29 <ornicar> hoogle does not help me with this one
12:11:56 <lightquake> ornicar: do you know about the ($) function?
12:12:08 <ornicar> I know how to use to avoid parenthesis
12:12:20 <ornicar> but thanks for the clue!
12:12:24 <ornicar> I will look into it
12:14:44 <SrPx> So, (a b c $ d e f) is the same as ((a b c) (d e f)) ? Also, (a b c * d e f) is the same as (a b (c * d) e f) ?
12:15:05 <edwardk> rpglover64: i mix and match where appropriate. a lot of my packages have bidirectional dependencies, which express poorly with type families. also, for things like comonad-transformers it is both a.) consistent with the mtl and b.) _always_ less verbose.
12:15:08 <shachaf> ((a b c) * (d e f))
12:15:18 <shachaf> It's the same as $ (and every other operator).
12:15:24 <rpglover64> Makes sense.
12:15:25 <edwardk> there is also the problem that type families don't show up properly in haddock yet
12:15:31 <SrPx> So every binary operator does this? Split the whole thing in 2?
12:15:36 <ornicar> lightquake: found it :) foo fs a = ($ a) <$> fs
12:15:37 <edwardk> so the few that i do have are a source of annoying warnings and confusing documentation
12:16:20 <lightquake> ornicar: i'd use map instead of <$>
12:16:37 <edwardk> SrPx: yes, each operator has a precedence that is looser than juxtaposition.
12:16:37 <ornicar> I always use <$> for consistency. How is map better?
12:16:43 <lightquake> it's more explicit
12:16:57 <ion> @type \fs a -> fs <*> pure a
12:16:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> a -> f b
12:16:58 <lightquake> you lose generality but you gain clarity
12:17:07 <edwardk> i tend to use fmap when i'd have to put ('s around the argument, and <$> otherwise
12:17:22 <SrPx> shachaf: wait so (a + b ^ c) -> ((a + b) ^ c)  ? this is wrong
12:17:25 <ornicar> many ways to do the same thing :)
12:17:32 <SrPx> * instead of ^
12:17:33 <edwardk> fmap (\x y -> x * y + z) blarg is clearer to me
12:17:46 <ornicar> I quite don't understand why lists have such a special treatment in haskell
12:17:54 <ornicar> it's just a * -> * like the others
12:18:04 <edwardk> SrPx: there is a fixity associated with each operator. that determines what 'gets split on first'
12:18:25 <edwardk> SrPx: in the case of ^, ^ has very high precedence, so it gets split very late.
12:18:25 <tac> ornicar: You mean syntactically? Because other than the syntax, Lists are no different from any other * -> * type.
12:18:41 <tac> (And I guess standard library support)
12:18:50 <ornicar> yes syntax. And also 'map' instead of <$> like other functors
12:18:57 <edwardk> ornicar: for a long time lists were far more prevalent in haskell code than they are today
12:19:03 <parcs`> > Data.Traversable.sequence [succ, pred, negate] 10
12:19:03 <lightquake> lists tend to have special syntax in most languages
12:19:04 <lambdabot>   [11,9,-10]
12:19:15 <edwardk> the use of map over fmap was part of the great monomorphization revolution of '98.
12:19:28 <tac> Lists are one of the more fundamental data types. Other kinds of containers tend to be much more complicated.
12:19:31 <n-dolio> map is specialized to lists because in 1998, people thought it'd be better for using Haskell in beginner courses.
12:19:33 <ornicar> where I come from (scala) lists are just a library thing, the language know nothing about lists
12:19:34 <edwardk> i view it as a historical accident brought about by the inadequacies of the compiler error messages of the day
12:19:35 <ornicar> I like it
12:19:51 <lightquake> edwardk: is there any truth to the idea that it was so people wouldn't have to teach newbies about what the f in fmap means?
12:20:02 <ciaranm> there's so much less to learn if you just remember <$>, join and pure.
12:20:09 <edwardk> lightquake: no. because it was map before that as i recall. ;)
12:20:15 <lightquake> :P
12:20:19 <n-dolio> lightquake: It's because errors with type classes are scary.
12:20:20 <lightquake> you know what i meant
12:20:23 <SrPx> edwardk: so this is what happens?  (a + b * c ^ e + f) -> split the first + -> ((a + (b * c ^ e)) + f) -> no need to split thesecond +, split the * -> ((a + (b * (c ^ e))) + f) -> no need to split the ^
12:20:29 <ornicar> haha I bet it is a very ancient argument, that map fmap <$> thing
12:20:32 <ciaranm> what's the function that takes a value and returns a function that always returns that value called again? oh yeah, pure.
12:20:40 <shachaf> @ty map fmap <$> ?thing
12:20:42 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, ?thing::f1 [a -> b], Functor f1) => f1 [f a -> f b]
12:20:43 <Cale> SrPx: Function application (which is indicated by juxtaposition/whitespace between identifiers) binds more tightly than any infix operator
12:21:09 <edwardk> SrPx: close enough. the actual way that gets implemented is a _little_ different, but what you described achieves the right result in a top down rather than the bottom up manner in which it is implemented
12:21:09 <SrPx> any tuto on that ?
12:21:33 <Cale> SrPx: Infix operators have various precedence levels set by their infix, infixl, or infixr declaration
12:21:57 <tac> ornicar: You might also ask yourself: "If you want to use fmap and Functor types instead of map and Lists, why stop there?"
12:22:00 <parsercombinator> http://ideone.com/fxMOh what do we call this construct in FP?
12:22:09 <tac> Don't you think POINTED functors are the more important data type to teach?
12:22:14 <ornicar> btw haskell is an awesome language to learn, I'm having a lot of fun, and this IRC chan is the best I've seen so far
12:22:21 <tac> Since most of the functors we really like are pointed.
12:22:29 <ciaranm> most of the functors we really like are monads
12:22:34 <shachaf> parsercombinator: f is called "const" in Haskell and "K" in some other places.
12:22:36 <ornicar> not pointed :)
12:22:37 <tac> ciaranm: indeed.
12:22:40 <lightquake> tac: [] isn't pointed
12:22:46 <ornicar> Maybe isn't
12:22:53 <Cale> lightquake: yes it is
12:23:01 <Cale> return :: a -> [a]
12:23:08 <lightquake> oh, i was thinking of copointed
12:23:18 <ciaranm> ornicar: yes it is
12:23:18 <edwardk> srpx: e.g. infixl 6 +, -  means that a chain of multiple +'s or -'s will associate as: a + b - c - d   ==> ((a + b) - c) - d
12:23:22 <ornicar> me too, me too!
12:23:27 <lightquake> yeah most functors are pointed, the only one that isn't that comes to mind is (t, )
12:23:34 <ornicar> I was thinking of [a] -> a which seems more tricky
12:23:48 <Cale> But I think that talking about pointedness is distracting when you're trying to explain functors.
12:23:49 <ciaranm> copointed is fairly special
12:23:50 <parsercombinator> so f x = \_ -> x is a combinator?
12:23:54 <parsercombinator> or is it a closure?
12:23:57 <shachaf> lightquake: What does "(co)pointed" mean other than "there's a total function :: a -> f a (or f a -> a)"?
12:23:59 <edwardk> srpx: but things with higher precedence like infixl 7 *    will be a further refinement
12:23:59 <ClaudiusMaximus> ooh, is the build system for ghc-7.6 new in that it shows what stage you're on and less verbosity when compiling the compiler?  i particularly like the stage info
12:24:02 <shachaf> parsercombinator: It's just a function.
12:24:07 <tac> Cale: The point was "why are functors the correct thing to be talking about to begin with?"
12:24:09 <shachaf> parsercombinator: Don't worry about the name. :-)
12:24:17 <parsercombinator> ah
12:24:19 <ornicar> ok back to my dirty code. Thanks guys!
12:24:21 <ciaranm> parsercombinator: it's a natural transformation!
12:24:24 <tac> Pointed functors are a generalization. We've already generalized lists to functors. How do we know we've "generalized enough"?
12:24:25 <edwardk> lightquake: Map Double a
12:24:31 <edwardk> lightquake: IntMap
12:24:35 <parsercombinator> so it's a homomorphism?
12:24:45 <edwardk> lightquake: there are _lots_ of functors that are not pointed
12:24:50 <Cale> tac: because functors preserve categorical structure
12:25:12 <Cale> (nothing more, nothing less)
12:25:13 <shachaf> Const b
12:25:15 <lightquake> shachaf: that's a good point
12:25:48 <SrPx> edwardk: hmm thanks, is there a tutorial on that? I'm searching
12:25:48 <Cale> Constant functors of course are a little bit of a trivial way to "preserve" the structure, but they do.
12:26:01 <n-dolio> tac: Pointed functors are less general than functors, so that speaks against your original concern.
12:26:21 <edwardk> SrPx: http://www.haskell.org/onlinereport/exps.html is the canonical reference on how it works, as it is the standard
12:26:27 <lightquake> edward why doesn't point x = fromList [(0, x)] count?
12:26:31 <edwardk> notice the example 'sample parses'
12:26:38 <tac> n-dolio: that may be true. I chose a poor example.
12:26:44 <Cale> n-dolio makes a good point, you have the generalisation the wrong way around :)
12:26:46 <edwardk> lightquake: and how does it know 0 is the right choice? what is canonical about that?
12:26:47 <shachaf> lightquake: Why 0?
12:26:47 <ciaranm> lightquake: that's decidedly unnatural
12:26:54 <dimka> Is there any neco-ghc users? Did you have any problems with pragma completion? It just don't work and it's hard to understand what actually broken
12:27:04 <lightquake> ah, so it's a question of 'naturality'
12:27:10 <lightquake> i'm not objecting i was just curious
12:27:16 <SrPx> edwardk: thanks
12:27:17 <edwardk> lightquake: i can construct an (<*>) for IntMap, but that is _definitely_ not the pure for that (<*>)!
12:27:39 <shachaf> lightquake: If you mentioned a law for "pointed", people would probably tell you it doesn't satisfy the law. :-)
12:27:39 <parsercombinator> > let f x = \_ -> x in f 3 ()
12:27:40 <lambdabot>   3
12:27:52 <ciaranm> > (pure 3) 4
12:27:53 <lambdabot>   3
12:27:53 <edwardk> lightquake: in the case of IntMap it is much more natural for me to talk about how i can use its (<*>) than it is for me to worry about some useless point that doesn't cooperate with any other operation
12:28:02 <parsercombinator> > const 3 ()
12:28:03 <lambdabot>   3
12:28:07 <parsercombinator> ah
12:28:11 <parsercombinator> :t const
12:28:11 <edwardk> shachaf: actually the only law for pointed is boring and is a free theorem
12:28:12 <Cale> lightquake: The term "pointed" comes from the notion of a pointed set (which is a set S equipped with a function 1 -> S, where 1 is a one-element set) or pointed topological space (where it's much the same)
12:28:13 <lambdabot> forall a b. a -> b -> a
12:28:28 <parsercombinator> :t \x -> \_ -> x
12:28:30 <lambdabot> forall t t1. t -> t1 -> t
12:28:31 <Cale> lightquake: But we've transplanted this idea into the category of endofunctors and natural transformations
12:28:37 <edwardk> shachaf: it satisfies the law, but the chosen definition is incompatible with more useful generalizations
12:28:37 <shachaf> edwardk: Yes, that's my point, I think.
12:28:44 <ciaranm> shachaf: so you are pointed?
12:28:51 <Cale> lightquake: So a pointed functor is a functor F which has a natural transformation 1 -> F
12:28:52 <ciaranm> shachaf: do you come with a join too?
12:29:06 <shachaf> edwardk: What about (\x -> IntMap.fromList (map (,x) [minBound..maxBound])) for IntMap? That's clearly natural!
12:29:07 <edwardk> ciaranm: you'll know if he pointedly ignores you
12:29:32 <edwardk> shachaf: that works. =) now you just need a machine to run it on
12:29:38 <Cale> and natural transformations we tend to encode by polymorphic functions, so we have a specified map: a -> F a
12:29:45 <shachaf> (Map Double) is the devil anyway, and obeys no laws.
12:29:50 <Cale> (and that's all there is to it)
12:30:04 <lightquake> Cale: makes sense
12:30:16 <Cale> A pointed functor on its own isn't very nice.
12:30:25 <ciaranm> i'm never entirely comfortable with the whole "and you can ignore naturality because it's probably natural anyway" thing, even though respectable category theorists claim it's fine
12:30:26 <edwardk> in general i view pointed functors as a bad point in the design space to hang your hat. almost every practical use of a pointed functor is an abuse.
12:30:43 <Cale> because you have no laws
12:30:48 <Cale> (and you really can't state any)
12:31:12 <Cale> You really want something like an applicative functor, where <*> lets you put laws on pure
12:31:31 <Cale> Or indeed a monad, where (>>=) or join lets you put laws on return
12:31:33 <ciaranm> how many interesting applicatives aren't monads?
12:31:43 <edwardk> e.g. hey i can make a pointed instance for 'Set'!, and I have a 'Monoid' for 'Set', so i an make a 'fromList', right? But there are no laws interrelating `point` and `mappend`, so _any_ such code that takes a Monoid and a Pointed instance has to be reasoned about case by case. The classes are just ad hoc overloading
12:31:47 <n-dolio> At least one.
12:31:52 <Cale> ciaranm: You get one from time to time.
12:31:55 <applicative> ziplist is interesting...
12:32:00 <ciaranm> zipList can be made a monad!
12:32:04 <n-dolio> No.
12:32:06 <applicative> oh?
12:32:12 <applicative> no
12:32:13 <edwardk> ciaranm: orly?
12:32:16 <Cale> I ran into one while making a combinator library for reactive GUIs
12:32:17 <edwardk> ciaranm: try checking the laws
12:32:21 <ornicar> I don't understand why `($) :: (a -> b) -> a -> b` but `($ a) :: (a -> b) -> b`
12:32:22 <ciaranm> not like that!
12:32:36 <Cale> (built on top of an Arrow)
12:32:38 <edwardk> ciaranm: the diagonalization monad doesn't work for ziplist
12:32:48 <ciaranm> not like that!
12:32:53 <shachaf> ornicar: Do you understand why (/) :: Double -> Double -> Double but (/ 5) :: Double -> Double?
12:33:01 <ornicar> yes
12:33:02 <ciaranm> can't you take the first n things where there are at least n things in each item?
12:33:08 <shachaf> ornicar: Now apply the same rule.
12:33:21 <ornicar> yes but the arguments order is reversed
12:33:33 <Cale> ciaranm: seems uncomputable?
12:33:37 <shachaf> ornicar: ?
12:33:38 <ornicar> ($) wants a `a -> b` and a `a`. But I give it a `a`.
12:33:42 <Cale> ciaranm: what do you do with an infinite list?
12:33:47 <ornicar> and now it wants a `a -> b`.
12:33:50 <ornicar> how is it possible?
12:33:55 <shachaf> ornicar: What's (/ 5) 15?
12:33:59 <tac> @type (id $)
12:34:01 <lambdabot> forall a. a -> a
12:34:02 <tac> @type ($ 5)
12:34:03 <lambdabot> forall a b. (Num a) => (a -> b) -> b
12:34:06 <ornicar> Int
12:34:08 <tac> $type id $ 5
12:34:11 <ornicar> 3
12:34:23 <shachaf> ornicar: But that means the 5 is the second argument!
12:34:33 <shachaf> How is it possible?
12:34:40 <ornicar> huhu I see. Need to play with it some more :)
12:34:42 <edwardk> ciaranm: this gets proposed about once a year, and then it gets poked apart
12:34:43 <sm0ke> hi is there something similar to a fold function which ends in middle of a list on some condition?
12:34:54 <n-dolio> We went through this not a month ago.
12:34:56 <n-dolio> It doesn't work.
12:34:56 <shachaf> sm0ke: foldr can "stop" whenever it likes.
12:35:08 <edwardk> ciaranm: there are lots of useful applicatives that are not monads
12:35:09 <tac> functions do not like things.
12:35:13 <tac> :P
12:35:19 <sipa> shachaf: but it cannot know (directly) its position in the list
12:35:23 <n-dolio> Associativity requires things to hold for an entire cube that cannot be locally known based on any square.
12:35:25 <edwardk> newtype Const r a = Const r
12:35:31 <sipa> though you can zip with [0..] beforehand of course
12:35:41 <shachaf> sipa: I didn't read it that way.
12:35:47 <sm0ke> shachaf: can you give an example?
12:35:48 <ciaranm> mmm. being computable is clearly overrated as a concept.
12:35:56 <sipa> shachaf: ah, i missed "on some condition"
12:36:11 <Mon_Ouie> sm0ke: You could use fold
12:36:17 <Mon_Ouie> sm0ke: You could use foldM with the Maybe monad*
12:36:18 <edwardk> sm0ke: just takeWhile and then foldr on that
12:36:20 <shachaf> > any (> 5) [1,2,4,28,error "never reached" -- sm0ke
12:36:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:36:27 <shachaf> > any (> 5) [1,2,4,28,error "never reached"] -- sm0ke
12:36:28 <lambdabot>   True
12:36:39 <sm0ke> eg. jow do you modify this to stop at first True condition....foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing
12:36:52 <shachaf> sm0ke: That already does.
12:36:52 <sm0ke> how*
12:37:17 <ornicar> it's the infix notation that got me
12:37:18 <edwardk> sm0ke: its lazy. so it doesn't demand anything of 'v' when key = k
12:37:40 <edwardk> i mean it doesn't demand anything of acc
12:37:49 <mcstar> i have a hunch, that persistent maps dont do quite well, when im starting out with a big map, and as the program evolves, it removes elements from it
12:37:53 <mcstar> instead of adding them
12:37:54 <edwardk> so even if acc is undefined when key = k, its done
12:37:57 <shachaf> > (\key -> foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing) "hello" [("hmm",5),("hi",3),("hello",14),error "oops"]
12:37:58 <lambdabot>   Just 14
12:38:02 <mcstar> does anyone have experience with this?
12:38:03 <sm0ke> it does?
12:38:18 <sipa> sm0ke: behold the magic of laziness
12:38:18 <edwardk> sm0ke: yep. you're done
12:38:31 <shachaf> sm0ke: Thinking of "acc" as an "accumulator" might just make things confusing.
12:38:45 <shachaf> It's "the rest of the list", the part that you haven't looked at yet.
12:38:48 <shachaf> @src foldr
12:38:48 <lambdabot> foldr f z []     = z
12:38:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:39:08 <parsercombinator> is >>= a combinator?
12:39:18 <parsercombinator> and what about return
12:39:22 <shachaf> In the recursive call, "acc" is the "foldr f z xs". If you don't use it, it's never evaluated.
12:39:35 <shachaf> parsercombinator: Why do you care about what's a combinator?
12:39:41 <sm0ke> but i dont understand isnt fold supopsed to working on the whole list...laziness is just that unless i ask it to "show" but still the accumulator consumes the whole list right?
12:39:45 <Kyraimion> parsercombinator:  They are functions
12:39:49 <parsercombinator> ah
12:40:06 <shachaf> sm0ke: No, that's not how laziness works.
12:40:17 <shachaf> And there's no "accumulator". :-)
12:40:18 <mcstar> i like the numeric combinators
12:40:24 <mcstar> +,-,*,/...
12:40:45 <edwardk> sm0ke: the 'accumulator' only gets built when forced. foldr doesn't force it. your function may depending on how the output of your function is used
12:41:02 <edwardk> > take 10 $ foldr (:) [] [1..]
12:41:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:41:18 <edwardk> even though the 'accumulator' there is an infinite list that works fine.
12:41:19 <applicative> > (\key -> foldr (\(k,v) acc -> if key == k then Just v else acc) Nothing) "hello" $ [("hmm",5),("hi",3),("hello",14),error "oops"] ++ repeat ("hello",3)
12:41:21 <lambdabot>   Just 14
12:41:42 <sm0ke> edwardk: exactly my point...becuase i do not know when the condition will be met so it has to consume the whole list !
12:41:44 <edwardk> the accumulator is kind of a buggy analogy here
12:42:04 <edwardk> > foldr f z [a,b,c,d]
12:42:05 <lambdabot>   f a (f b (f c (f d z)))
12:42:11 <edwardk> lets just expand foldr
12:42:14 <sipa> sm0ke: it works from left to right through your list, and only calculates what to feed to your function as 'acc', when acc is actually used
12:42:30 <edwardk> its just replacing :'s in the list with your f, and the [] if it finds it with your 'z'
12:43:23 <sipa> A combinator is a higher-order function that uses only function application and earlier defined combinators to define a result from its arguments.
12:43:26 <sipa> -- http://en.wikipedia.org/wiki/Combinatory_logic
12:43:39 <mcstar> maybe im wrong, and insert and delete does the same amount of copying
12:43:47 <edwardk> now, when you look at the answer, you demand some part of it, and that in turn demands the result of f applied to the first element of the list and to the fold of the rest. it doesn't cause those two things to happen though. it just makes a place holder, for where to store the answer if they are demanded by f in the process of yielding the answer
12:44:02 <edwardk> so the 'fold of the rest of the list' _hasn't happened yet_
12:44:03 <Adeon> @pl f x = g $ h x
12:44:03 <lambdabot> f = g . h
12:44:08 <edwardk> the accumulator is still a thunk
12:44:34 <edwardk> now when your key matches you don't demand the value of the accumulator, so the 'fold of the rest of the list' becomes irrelevant and is thrown away, _never having happened_
12:44:55 <edwardk> this is the magic of laziness
12:45:08 <SegFaultAX|work> Anyone going to the Bay Area Haskell meetup on Thursday?
12:45:14 <edwardk> SegFaultAX|work: i should be there ;)
12:45:15 <Tekmo> Oh snap
12:45:19 <Tekmo> Is it too late to join?
12:45:23 <Tekmo> I'd love to come
12:45:26 <edwardk> Tekmo: signup
12:45:32 <SegFaultAX|work> Tekmo: https://sites.google.com/site/bayareahaskell/
12:45:32 <Tekmo> Where is the website?
12:45:34 <Tekmo> Thanks
12:45:35 <SrPx> How do non-associative operators work? I understand what happens to right and left associatives, like, (a . b . c) could be ((a . b) . c) or (a . (b . c)) depending on the associability of ., but what if it is non associative ?
12:45:49 <edwardk> https://sites.google.com/site/bayareahaskell/
12:46:14 <SegFaultAX|work> edwardk: Are you speaking?
12:46:17 <shachaf> SrPx: Then it just doesn't work.
12:46:26 <edwardk> SrPx: non-assoc operators are defined 'infix' rather than 'infixl' or 'infixr' attemting to chain two of them of the same fixity is a syntax error
12:46:31 <edwardk> SegFaultAX|work: yep
12:46:46 <SegFaultAX|work> edwardk: Oh duh, you're hosting it. :D
12:46:52 <SrPx> edwardk: shachaf oh okay, thanks. But why would someone make his operator not work on purpose?
12:46:56 <trotro> -> is not associative but you can chain many of it :)
12:46:59 <edwardk> well, satnam is hosting it. i'm just going to ramble on about lenses =)
12:47:10 <maukd> > 1 == 2 == 3
12:47:12 <lambdabot>   Precedence parsing error
12:47:12 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
12:47:14 <edwardk> SrPx: some times there is no meaning that makes sense.
12:47:30 <mcstar> 'through the looking lens'
12:47:33 <Abraxas> can i derive foldl as foldr via the universality of fold?
12:47:35 <shachaf> trotro: Type-level -> is right-associative. Value-level -> isn't an operator.
12:47:48 <edwardk> SrPx: (!*@#) :: Int -> Double -> String   -- can't be associated either way
12:48:00 <Abraxas> i have seen the derivation via helper functions and partial application
12:48:03 <shachaf> Mind your language, edwardk.
12:48:06 <edwardk> mcstar: "Lenses, Folds and Traversals" is the actual title
12:48:09 <trotro> shachaf, I know
12:48:13 <Tekmo> Ok, I have a heap profiling question.  If I see "MUT_ARR_PTRS_FROZEN" and "ARR_WORDS", are those the overhead for just the array or does that include the array contents?
12:48:17 <mcstar> :)
12:48:18 <SrPx> Hmmm I see edwardk
12:48:25 <edwardk> trotro: -> is associated to the right
12:48:26 <Abraxas> in fact, someone did this for me in this very chat
12:48:34 <trotro> i know, i was joking
12:48:45 <trotro> :t (**)
12:48:47 <lambdabot> forall a. (Floating a) => a -> a -> a
12:48:53 <trotro> > 1 ** 2 ** 3
12:48:54 <lambdabot>   1.0
12:48:57 <trotro> oh yeah
12:49:12 <Cale> It's not associative, but it's right-associative :)
12:49:32 <edwardk> SrPx: i have a few non-associative operators lying around, but they are mostly for things that work like = or ==
12:49:34 <trotro> > 2 ** 3 ** 4
12:49:35 <lambdabot>   2.4178516392292584e24
12:49:44 <sipa> heh?
12:49:47 <Abraxas> it was this one: http://hpaste.org/53272
12:49:47 <trotro> > 2 ** (3 ** 4)
12:49:48 <lambdabot>   2.4178516392292584e24
12:49:51 <trotro> ok
12:49:57 <sipa> oh, missed the 'e' in there
12:50:03 <trotro> sipa, me too :)
12:50:15 <bgamari> Has anyone looked into adding a mutable interface to repa's Vector representations?
12:50:16 <SrPx> edwardk: = in haskell is assign ? a = b = c won't work?
12:50:18 <Cale> > 2 ** (3 ** 4) :: CReal
12:50:19 <lambdabot>   2417851639229258349412352.0
12:50:24 <SrPx> oh wiat
12:50:34 <sipa> > 4 ** 3 ** 2
12:50:36 <lambdabot>   262144.0
12:50:46 <Tekmo> Equals means they are equal
12:50:56 <Abraxas> it's quite obvious that it doesn't work with universality or else why use a more complicated proof
12:51:03 <Cale> SrPx: well, it's not exactly assignment, but declaration of equality
12:51:16 <Abraxas> but perhaps it's close to univ.
12:51:38 <edwardk> SrPx: correct
12:52:02 <edwardk> srpx: = is used in definitions, not expressions, and there isn't a 'chaining' form of it
12:52:42 <SrPx> just a sec, (f $ x $ y) = ((f x) y) ? is not this left-associative?
12:53:16 <sipa> > (:) $ 5 $ []
12:53:17 <lambdabot>   Overlapping instances for GHC.Show.Show ([b] -> [b])
12:53:17 <lambdabot>    arising from a use ...
12:53:28 <shachaf> Uh-oh. Cale incoming.
12:53:39 <lightquake> > succ $ succ $ 0
12:53:41 <lambdabot>   2
12:53:47 <lightquake> > (succ succ) 0
12:53:49 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
12:53:49 <lambdabot>    arising from a use of `e_10' at...
12:53:56 <lightquake> > succ (succ 0)
12:53:57 <lambdabot>   2
12:54:14 <trotro> $ is not really what wa can call an operator
12:54:20 <Cale> SrPx: It ought to be left associative, but $ ended up being defined as right associative
12:54:27 <lightquake> trotro: why not?
12:54:28 <Tekmo> f $ x $ y = f (x y)
12:54:37 <trotro> for me an operator is a -> a -> a
12:54:38 <Tekmo> No, it should be right-associative
12:54:48 <lightquake> i see people use 'operator' to mean 'anything infix'
12:54:48 <trotro> but if people has other definitions...
12:55:01 <sipa> trotro: how do you call it then?
12:55:07 <edwardk> srpx: infixr 0 $
12:55:14 <n-dolio> So you don't believe in many-sorted algebraic theories?
12:55:17 <SrPx> Tekmo: why?
12:55:26 <Tekmo> The typical usage of $ is:
12:55:33 <Tekmo> f1 $ f2 $ f3 $ f4 x
12:55:37 <trotro> it's an operator if I look it in the language : haskell expr -> haskell expr -> haskell expr
12:55:43 <Tekmo> For people too lazy to convert them to (.)
12:56:00 <trotro> but i rather like the term infix function
12:56:08 <shachaf> This is the time when Cale gives the *other* lecture about laziness.
12:56:16 <edwardk> Tekmo: yes, but that typical usecase is replaceable with f1 . f2 . f3 $ f4 x    while with the flipped associativity you can use foo $ bar baz $ quux quaffle $ … to delimit arguments and still use . for chaining
12:56:31 <edwardk> the argument in favor of the flipped associativity is that it grants more power
12:56:45 <shachaf> edwardk: But on the other hand it's nice to have an (almost) arbitrary expression and be able to stick "length $" in front of it.
12:56:53 <edwardk> since the other usecases for $ with its current fixity can always be replaced with (.)'s for every one except the last
12:57:00 <edwardk> shachaf: very true
12:57:13 <hpaste> Abraxas pasted “foldl as foldr via universality...and then some?” at http://hpaste.org/76334
12:57:19 <edwardk> i'm somewhat torn. in our toy language here we gave $ the 'correct' associativity ;)
12:57:22 <Tekmo> edwardk: Yes, but I cannot safely do: "forM_ xs $ \a -> ..." and forget about what goes on the right side
12:57:28 <shachaf> Another argument for infxl $ is that it would imply infixl $!
12:57:36 <SrPx> oh I see it. perfect, thanks
12:57:48 <lightquake> clearly we need $'s evil cousin, which is infixl
12:57:51 <edwardk> Tekmo: the $! example is what sold me
12:57:52 <shachaf> Er, that's ($!) there.
12:58:01 <trotro> :t ($!)
12:58:02 <lambdabot> forall a b. (a -> b) -> a -> b
12:58:06 <lightquake> and so we need to pick the only thing that makes sense
12:58:09 <lightquake> ¢
12:58:10 <edwardk> foo $! bar baz $! quux quaffle $ something i don't care about $! something i need strict
12:58:11 <shachaf> infixl ﹩
12:58:23 <trotro> what does $! do ?
12:58:23 <edwardk> that fixity kills more parens than the current one
12:58:32 <edwardk> trotro: it forces its argument
12:58:37 <trotro> ouch
12:58:40 <edwardk> @src ($!)
12:58:41 <lambdabot> f $! x = x `seq` f x
12:58:44 <shachaf> Don't fixity fit ain't broken.
12:58:52 <Abraxas> what i have in mind for the above hpaste is a way to use universality of fold with some hackage applied such that you arrive at the conventional proof for foldl as foldr
12:58:56 <Tekmo> edwardk: You still need something for the cases where you want to delimit a do block: "... $ do ..."
12:59:03 <copumpkin> make sure to only use $! in situations where it doesn't do anything useful
12:59:04 <edwardk> @remember shachaf Don't fixity fit ain't broken.
12:59:05 <lambdabot> I will never forget.
12:59:06 <copumpkin> id $! 5
12:59:07 <Abraxas> is that complete nonsense?
12:59:19 <ClaudiusMaximus> hmpf, i tried the hacks on cabal ticket 517 and got an error after an hour of compilation with ~/.cabal/hscolour.css does not exist (so i guess you must use absolute path instead of ~/)
13:00:55 <gwern> @quote monkey
13:00:56 <lambdabot> psykotic says:  (:[]) is the happy monkey operator
13:01:14 <c_wraith> @quote eat.a.comment
13:01:14 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
13:01:24 <edwardk> @tell tekmo it works fine for that do block either way =)
13:01:25 <lambdabot> Consider it noted.
13:01:39 * hackagebot hpyrg 0.1.0.0 - pyrg utility done right  http://hackage.haskell.org/package/hpyrg-0.1.0.0 (MatveyAksenov)
13:04:06 <efie> Cale: thanks again, your example with MVar seem to be exactly what I want
13:04:27 <edwardk> @tell tekmo not only that but you can do things like bracket $ do { … } $ do { … } $ do { .. }
13:04:27 <lambdabot> Consider it noted.
13:04:28 <Abraxas> i mean, it's almost the same as the conventional proof, just without flipping the zero value to the back
13:04:59 <Abraxas> so why even bother, i guess :D
13:08:12 <Abraxas> tbh, i don't understand the flip in this proof: http://hpaste.org/53272
13:08:56 <Abraxas> can we just do this? any rules for this?
13:09:20 <parsercombinator> what does ghc --make do
13:09:24 <parsercombinator> vs ordinary ghc
13:09:39 <ciaranm> Abraxas: you can turn (a -> b -> c) into (b -> a -> c)
13:11:21 <efie> is modifyMVar_ 'efficient'? I have to update MVar a lot of times - how efficient is STM in comparison?
13:11:26 <Abraxas> always?
13:12:10 <copumpkin> Abraxas: yes
13:12:11 <adnauseam> hpc: hey dude, any progress with lambdabot lately ?
13:13:30 <Abraxas> the flip in the second equation looks dangerous to me
13:15:19 <Abraxas> i am flipping on both sides
13:15:21 <fryguybob> efie: STM is less efficient but it really depends on what you are doing.
13:15:31 <Abraxas> only works because the type of the result is the same?
13:15:44 <ciaranm> :t flip
13:15:45 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:16:12 <ciaranm> uh, that looks like a Cale special
13:17:28 <Attic> Can anyone help me out installing cabal-dev? I can't seem to get it installed through cabal or pacman's AUR
13:17:47 <Attic> Whenever I try to install through cabal, unix 2.3.2.0 fails to install
13:18:01 <lightquake> what's the failure message?
13:18:07 <parsercombinator> is it good practice to omit the type signature of main
13:18:25 <lightquake> there's no point in doing it imo
13:19:12 <Attic> lightquake: when installing cabal-dev it says depenency unix-2.3.2.0 fails to install, and when i try to install unix-2.3.2.0 it says dist/build/System/Posix/Signals.hs:127:0: fatal error: Signals.h: No such file or directory
13:19:29 <lightquake> what OS are you using?
13:19:39 <Attic> Arch Linux
13:19:45 <lightquake> ... that's weird
13:19:48 <lightquake> i was expecting 'windows'
13:19:56 <parsercombinator> lol
13:20:00 <Attic> Or well Parabola Linux but pretty much the same thing
13:20:20 <efie> fryguybob: in thread A is a loop in which the value in Mvar us updated, the loop gets interrupted when a key is pressed in thread B. then thread A gets killed and the value in Mvar is used in Thread B. the loop should 'loop' as fast as possible
13:20:48 <mroman> How's the relation between Monoids and turing completeness?
13:22:09 <ion> and list comprehensions and flight simulators?
13:22:16 <mroman> No.
13:22:24 <Attic> I tried installing unix-2.3.2.0 by downloading the package, but I have no idea where to get that missing file from
13:22:40 <hpaste> Abraxas annotated “foldl as foldr via universality...and then some?” with “foldl as foldr via universality...and then some? (annotation)” at http://hpaste.org/76334#a76335
13:23:48 <Abraxas> another attempt with flipping, but...i guess this time i cannot flip, because it's not the same function on either side
13:24:08 <Abraxas> or rather, not the same type signature
13:26:44 <parsercombinator> does haskell have a preprocessor like C or C++?
13:27:00 <maukd> no
13:27:45 <lightquake> Attic: what version of cabal-dev are you trying to install?
13:27:51 <clahey> Would TH be considered a preprocessor?
13:28:21 <Attic> lightquake: tried 0.9 and 0.9.1
13:28:48 <SegFaultAX|work> So are Lenses a generalization of accessors and mutators over records?
13:28:58 <lightquake> Attic: hm. i dunno then :/ sorry
13:29:02 <edwardk> SegFaultAX|work : yep
13:29:17 <Attic> lightquake: Do you know how to install any other version?
13:29:19 <SegFaultAX|work> edwardk: Can they be extended to other datastructures?
13:29:30 <edwardk> SegFaultAX|work: but there are some serious generalizations available to them
13:29:38 <SegFaultAX|work> edwardk: Such as?
13:29:55 <clahey> edwardk: Is there a good paper about lenses that I should read?
13:30:03 <edwardk> SegFaultAX|work: sure. at :: Ord k => k -> Simple Lens (Map k a) (Maybe a)    is a lens that updates a single entry in a map for instance
13:30:39 <edwardk> or 'contains :: Ord k => k -> Simple Lens (Set a) Bool'
13:30:40 <edwardk> can be used to both add an element to a set or remove it
13:30:57 <edwardk> clahey: not yet. i'm working on one with twanvl and roconnor though
13:31:10 <edwardk> clahey: the examples on the lens wiki are pretty handy for getting your head around it
13:31:27 <clahey> edwardk: kk
13:31:39 <clahey> edwardk: I'm gonna read the TH paper then.
13:31:39 <edwardk> github.com/ekmett/lens and github.com/ekmett/lens/wiki
13:31:58 <SegFaultAX|work> edwardk: So what's the goal of Lenses exactly, then? From my super primitive understanding, it seems like it makes it easy to compose mutation of state, for example, among other things.
13:32:11 <SegFaultAX|work> But what is the real problem that they solve?
13:32:23 <danharaj> edwardk: can you give me a quick tutorial on why the second signature can't be subbed in for the first?
13:32:24 <edwardk> SegFaultAX|work: thats the simplest thing you an do with them.
13:32:25 <danharaj> http://hpaste.org/76336
13:32:32 <ciaranm> SegFaultAX|work: they make things look pretty
13:32:35 <danharaj> (not really relevant to the library, just came up in its use :P)
13:33:38 <edwardk> danharaj: i'd probably need the method body to do that
13:33:51 <edwardk> SegFaultAX|work: but the lens library doesn't stop with lenses
13:34:11 <edwardk> SegFaultAX|work: it includes generalizations of them, the first generalization is a getter that can just be used to read from
13:34:41 <edwardk> the second is a setter that can be used only for updating. the former is analogous to a function, the latter works like a functor, but they permit more restricted types.
13:35:12 <edwardk> one issue you run into with libraries in haskell is that there are a lot of libraries that have to duplicate huge swathes of the Prelude. e.g. if you look at Data.ByteString it is an enormous cut and paste hack job
13:35:35 <edwardk> its a wonderful library and its fast, but its decidedly non-haskelly in its API
13:35:46 <danharaj> edwardk: I'll bug you later then, if I get around to making a clean example. It looks like GHC can't unify the variables quantified in each SourceT. I guess it makes sense that it can't do that.
13:35:48 <edwardk> same with Data.Text, Data.Map, Data.Set
13:36:18 <edwardk> each of those are very useful libraries, with incredibly complicated and highly repetitive APIs
13:36:52 <edwardk> by using the generalizations of lenses provided by the lens library, I'm able to take a pretty useful API for 'text' down to two combinators and the use of the more general lens and traversal combinators
13:37:00 <edwardk> similarly for 'bytestring'
13:37:13 <edwardk> and you can insert, delete, etc into a Map using just 'at'
13:37:19 <edwardk> which composes with other lenses
13:37:33 <clahey> at returns a Lens for a key in a map, right?
13:37:43 <edwardk> foo^.at "bar"
13:37:52 <edwardk> yep
13:38:10 <byorgey> nand`: diagrams-svg should be fixed now, https://github.com/diagrams/diagrams-svg/pull/23
13:38:11 <clahey> The goal being that then you can redefine all these functions in terms of Lenses and just be able to call them straight from Prelude.
13:38:13 <edwardk> m % at "bar" .~ Just 24
13:38:53 <edwardk> the goal is that you can have one lens library with a lot of combinators and lenses/traversals/folds and a bunch of combinators that all work with lenses/traversals/folds in such a way that they always do the right thing
13:39:05 <clahey> !! :: a -> LensGenerator a b -> b
13:39:21 <edwardk> 'at' is a lens, but a lens can be used as a traversal, getter, setter, etc.
13:39:26 <edwardk> LensGenerator?
13:39:41 <clahey> I figured you'd have a classtype that can give you lenses.
13:39:51 <edwardk> you just have lenses
13:40:02 <danharaj> I think the biggest hint that lens is a good library is that it was extended multiple times and each extension felt natural. A good abstraction does that.
13:40:13 <clahey> edwardk: I think I see.
13:40:23 <edwardk> 'traverse' is a valid traversal, so Traversable is a class that gives you a default traversal you can use, and most combinators can take a traversal.
13:41:34 <edwardk> danharaj: i like the cut of your jib
13:42:43 <danharaj> edwardk: I am totally not biased by the fact that I asked for one or two of those extensions ;)
13:42:54 <edwardk> danharaj: =)
13:43:29 <fryguybob> efie: If there were multiple dependencies and you could save computation by only re-evaluating part of them you could potentially save with STM.  But this doesn't sound like it is the case with your problem.  STM might still be easier though.
13:43:33 <clahey> edwardk: Where is at defined?
13:43:34 <edwardk> i still think my favorite thing about the lens library is how nice the zippers it offers are
13:43:49 <nand`> dmwit: rough ETA on GtkHs 7.6.1?
13:44:00 <nand`> byorgey: builds fine :)
13:44:18 <edwardk> clahey: http://hackage.haskell.org/packages/archive/lens/3.0.2/doc/html/Control-Lens-IndexedLens.html#v:at
13:44:33 <edwardk> it gets re-exported by Control.Lens
13:44:36 <byorgey> nand`: excellent =)
13:45:21 <nand`> byorgey: there's ‘defaultMain’ which works for standalone programs, but is there an easy way to generate diagrams from within GHCi?
13:45:30 <nand`> since I don't have console parameters this way
13:45:53 <byorgey> nand`: you can call 'renderDia' directly
13:45:58 <Abraxas> if i want to flip on both sides of an equation, but on one side there is only one value, can i just pair it with id?
13:46:05 <nand`> the type signature on that is scary
13:46:22 <byorgey> just a second
13:46:40 <nand`> what does Options translate to for SVG?
13:46:44 <joe9> can anyone do "cabal install cmdargs" and let me know if it core dumps?
13:46:49 <joe9> please?.
13:46:52 <fryguybob> nand`: There is also withArgs :P
13:46:59 <lispy> danharaj: BTW, I tried installing ghc-7.6 64bit windows version. I don't think it's really ready for use. I don't think you can build anything that depends on network.
13:47:04 <lispy> danharaj: I filed a bug report
13:47:05 <joe9> http://codepad.org/p8QMGGUp is what happens with me.
13:47:06 <byorgey> nand`: SVGOptions { fileName :: String, size :: SizeSpec2D }
13:47:11 <edwardk> i might want to add ?= and ?~ to set the result to Just to match the ^? operator's use for working with traversals
13:47:20 <lispy> danharaj: And I think the issue you had with ghci finding libraries may be related
13:47:48 <edwardk> at 1 ?= "hello"       is nicer than at 1 .~ Just "hello" when "hello" is more complicated
13:47:51 <byorgey> nand`: so it would be something like   renderDia SVG (SVGOptions "filename" (Width 400)) dia
13:47:54 <nand`> yuck, ambiguous type errors
13:48:05 <lispy> danharaj: I would suggest you try again with 7.6 but using the 32bit compiler on windows
13:48:12 <byorgey> nand`: oh?  what error?
13:48:20 <joe9> lispy: yes, I tried the 7.6.1 and it broke with the URI stuff.
13:48:25 <nand`>     No instance for (PathLike (QDiagram SVG R2 m0))
13:48:27 <nand`>       arising from a use of `circle'
13:48:29 <danharaj> lispy: thanks a ton for the second data point. It'll probably work with 7.6 32-bit. I'll try that once I'm really hurting for ghci.
13:48:35 <byorgey> oh, yeah. ick.
13:48:55 <byorgey> should be m0 = Any
13:49:05 <nand`> I just added :: Diagram SVG R2
13:49:11 <byorgey> yes, that works
13:49:24 <lispy> danharaj: I think ghc-7.6.1 64bit is a ticking timebomb. You don't know until you try if you'll be able to link things. Unless you're hoping to submit bug reports, I might stay away from it.
13:49:25 <byorgey> Diagram b v ~ QDiagram b v Any
13:49:31 <nand`> heh, gives me a blaze-svg value; now I just need to figure out how to write it to a file
13:49:38 <nand`> okay
13:49:41 <byorgey> oh, hehehe
13:49:57 <nand`> (what on earth is the filename for then?)
13:50:16 <lispy> danharaj: The way I understand the bugs in trac that are linked together, they may have to rewrite their custom linker to handle the large code size model for 64bit or use the system linker. Both are non-trivial changes.
13:50:52 <danharaj> lispy: noted. wrt network, I think I built a few things with it already. let me check.
13:50:58 <nand`> how odd, it doesn't seem have have any IO () or Serializable instance or anything
13:51:01 <byorgey> nand`: I ... don't know
13:51:13 <byorgey> nand`: I didn't write the SVG backend
13:51:13 <hpc> adnauseam: no progress on lambdabot, sadly
13:51:16 <nand`> okay
13:51:19 <hpc> been doing other more interesting things
13:51:49 <danharaj> lispy: Indeed I have. I built cabal-install with 64-bit and it relies on network. Strangeness.
13:52:11 <nand`> oh
13:52:21 <nand`> it's in an extra module, Text.Blaze.Svg.Renderer.Utf8
13:52:32 <clahey> edwardk: You know what might help the readability of the Lens code is if you used names for the types instead of a b c d.
13:52:37 <nand`> this is the point where I decide writing an extra file and using defaultMain is less effort
13:52:42 <hpaste> Abraxas annotated “foldl as foldr via universality...and then some?” with “foldl as foldr via universality...and then some? (annotation)” at http://hpaste.org/76334#a76337
13:52:48 <clahey> You use k for keys which helps, but more names would be cool.
13:53:13 <Abraxas> third attempt, doesn't change much
13:53:20 <edwardk> clahey: its been proposed and shot down a few times. the problem is finding names that are universally better. the convention of a b c d is consistently used throughout hundreds of combinators in there now
13:53:29 <Abraxas> not sure if any of that makes sense :D
13:53:41 <edwardk> alpha renaming them isn't trivial and any other convention is almost necessarily going to be longer
13:53:58 <clahey> edwardk: I'm okay with having more than one character for the names.
13:53:59 <SegFaultAX|work> edwardk: So it sounds like a good portion of the standard library could be re-written using lenses, and doing so would also DRY up a lot of the duplication from Prelude?
13:54:01 <edwardk> e.g. even just using Lens a a' b b' everywhere
13:54:22 <clahey> edwardk: Or perhaps having more info in the comments about what the parameters are meant to represent?
13:54:22 <nand`> I.. great, now I just need a program capable of displaying SVG files
13:54:26 <edwardk> clahey: yeah, but i have to type them all, and I'm the one who has to juggle in his head the intuition for them, so i'm not ;)
13:54:31 <edwardk> clahey: that i'm all for
13:54:40 <edwardk> clahey: knock yourself our adding documentation about the meanings =)
13:54:50 <clahey> edwardk: Anyway, I think At is what I meant by LensGenerator.
13:54:59 <fryguybob> @hoogle withArgs
13:54:59 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
13:55:16 <edwardk> clahey: At only works for things like Map. consider trying to define an instance of At for [] with an Int key. -- it fails
13:55:29 <clahey> edwardk: I don't know why it fails.
13:55:44 <clahey> edwardk: Cause I don't really understand Lens and in particular Traversal yet.
13:55:45 <fryguybob> nand`: Shouldn't your browser work?
13:55:56 <clahey> edwardk: I think having the thing where composition is inverted is confusing as well.
13:55:59 <nand`> modulo background color
13:56:09 <clahey> edwardk: Is there a reason for that other than trying to make it more imperative looking?
13:56:18 <edwardk> clahey: it grows on you with practice and the opposite order isn't possible
13:56:44 <edwardk> plus it means that foo^.bar.baz.quux means what an imperative programmer expects, which is an awesome and unexpected side-effect
13:57:16 <clahey> edwardk: I think the usage is natural, but it's making it harder to understand since the functions all take a function that is going to be used on the output.
13:57:55 <edwardk> clahey: fmap.fmap.fmap   (.).(.).(.), traverse.traverse.traverse and foldMap.foldMap.foldMap have always worked and done something useful.  the way 'lens' abuses composition is the generalization of all of these
13:58:52 <clahey> edwardk: I understand fmap and (.) on a very low level, so I'm going to go learn traverse and foldMap as well.
13:58:53 <edwardk> i find that just working through the types in each of those scenarios is useful to understand _why_ the lens types work the way they do
13:59:29 <hpc> :t traverse.traverse.traverse
13:59:30 <lambdabot> Not in scope: `traverse'
13:59:30 <lambdabot> Not in scope: `traverse'
13:59:30 <lambdabot> Not in scope: `traverse'
13:59:32 <edwardk> clahey: once you do, the definition of foldMapDefault and fmapDefault in terms of traverse will justify the connection between Traversals, and Folds and Setters
13:59:34 <hpc> D:
14:00:03 <nand`> apparently, ‘text’ does nothing; I don't know if this is due to diagrams-svg or some other oversight of mine
14:00:09 <dysinger> I can't build ghc-7.4 branch of GHC from github.  It's broken.  ghc-7.6 works but ghc-7.4 branch wants to clone cabal-1.14 and errors out.  steps to reproduce: git clone -b ghc-7.4 --depth=1 git://github.com/ghc/ghc.git ; cd ghc ; ./sync-all get
14:00:20 <nand`> defaultMain (text "Hello, world!") -- produces an empty .svg
14:01:05 <byorgey> nand`: that's because text objects take up no space
14:01:12 <byorgey> nand`: so it doesn't know how big to make it
14:01:28 <danharaj> edwardk: I just realized something about the way I'm using machines. I'm pretty much defining a signature for the IO I want to support and then attaching handlers and a driver to service my requests. It feels like a trivial use of the library :P
14:01:54 <byorgey> nand`: try  defaultMain (text "Hello world!" <> rect 10 1 # lw 0)
14:02:01 <edwardk> danharaj: probably is =) you can do a lot with it just treating it as a fancy 'MonadPrompt'
14:02:19 <nand`> still seemingly empty
14:02:55 <edwardk> danharaj: another usecase is to define monadic sources that just do what they need to do when demanded, and use the existing Process, Wye and Tee plumbing
14:03:20 <edwardk> danharaj: its all about how much control you want over the effects. you can delegate it to the monad or the driver more or less
14:03:39 <edwardk> giving you an open or closed world of effects to reason about
14:04:21 <danharaj> edwardk: My asyncDriver is like a Wye except the sources don't block when they're waiting on input. I need to figure out the puzzle so writing it doesn't have an explosion of case statements as I add more inputs.
14:04:38 <edwardk> yeah. 'wye' is pretty hellish
14:06:05 <clahey> edwardk: I think I'm gonna drop back to MonadParsers and stick there for a while.
14:06:17 <edwardk> clahey: fair nuff
14:06:57 <clahey> It is tempting to try to make a lazy parser.
14:07:08 <clahey> But I'm gonna stick with fixing my microxml parser for a while.
14:07:44 <danharaj> fortunately I don't think I need more than two or three inputs to my wye-like. It's working nicely right now, input and frame ticks interleave seamlessly with input prioritized. I think I like this approach more than the pseudo-frp I was doing before.
14:08:25 <Cale> ahahaha, Minecraft IRL (very subtle) http://i.imgur.com/nLjwB.png
14:08:56 <Cale> (the water, that is -- the dirt pillars are a bit less so)
14:09:03 <hpc> my god, it looks exactly the same as minecraft
14:09:05 <hpc> :P
14:09:18 <hpc> i also love the glitchy mountain shadows, and the chunk error
14:09:28 <ion> heh
14:09:58 <Cale> and the flying squid
14:12:41 <Cale> oh, wow, one of the trees is also floating, it's a bit hard to tell
14:14:00 <ion> heh
14:15:32 <shachaf> Man, remember the days when Cale was in #-blah?
14:15:39 <shachaf> Those were the days.
14:16:17 <Cale> btw, did everyone notice that http://joyridelabs.de/game/ is out?
14:17:10 <copumpkin> Cale: there's a list of people who noticed on buy. :)
14:17:30 <Cale> :)
14:17:37 <edwardk> they need a clearer way to up your contribution to stay on top of the high score chart =P
14:17:52 <Csigusz> was that game written in Haskell?
14:17:54 <Cale> yes
14:18:02 <shachaf> Those are high scores?
14:18:08 <shachaf> Sounds like a fun game.
14:18:18 <edwardk> and sorting later contributors at the same price point on top is dirty pool
14:18:18 <edwardk> shachaf: in terms of willingness to pay, etc.
14:18:28 <trotro> super villain Dr. Lacroix => another french bad guy :D
14:19:02 <Csigusz> yes, the french are evil
14:19:05 <Cale> Collecting all the batteries in some levels is insane
14:19:12 <shachaf> edwardk: Have you actually played the game?
14:19:14 <danharaj> edwardk: the best way is to just to make your donor name an agreeable phrase, such as "Flutteryshy is best pony." Who would want to knock that off the top 10?
14:19:27 <Abraxas> similarly to my earlier confusion surrounding flipping the last two arguments of a function...i don't understand why this transformation into primitive recursive functions works: h (x : xs) = g x (h xs)  <=> h y (x : xs) = g y x (h y xs)
14:19:37 * copumpkin slaps danharaj 
14:19:37 <trotro> Csigusz, I know (Van Damme was wonderfull in expendables II (dunno if he played a belgian or a french vilain))
14:19:43 <edwardk> shachaf: yeah. i'm not a huge fan of the actual gameplay mechanics, but i like what they are doing
14:19:56 <XexonixXexillion> danharaj: Except Sweetie Belle is best pony
14:20:03 <shachaf> edwardk: I tried a beta a while ago and had vaguely the same impression.
14:20:19 <Abraxas> is it that cut-and-dry that y is processed by both h and g in similar fashion?
14:20:19 <shachaf> Then again, it was a while ago.
14:20:22 <edwardk> danharaj: clearly the person who wants to come along later and fix the spelling of Fluttershy will be powerfully motivated to do so.
14:20:29 <danharaj> yes :[
14:20:39 <Abraxas> not similar...equivalent
14:20:46 <danharaj> I have this keyboard tic where I add y's in inappropriate places.
14:21:08 <edwardk> danharay: happens to the best of us =P
14:21:27 <shachaf> Abraxas: It looks like g in your first case = g y in your second case.
14:21:37 <shachaf> But I'm not quite sure what you're asking.
14:23:26 <Abraxas> from hutton on primitive recursions: "First of all, we introduce an extra argument y to the function h, which in the base case is processed by a new function f, and in the recursive case is passed unchanged to the functions g and h."
14:23:58 <Abraxas> base case: h [ ] = v <=> h y [ ] = f y
14:24:17 <crdueck> @hoogle Monad m => [a] -> (b,b) -> m a
14:24:17 <lambdabot> Text.Regex.Base.RegexLike extract :: Extract source => (Int, Int) -> source -> source
14:24:17 <lambdabot> Data.Generics.Aliases ext2R :: (Monad m, Data d, Typeable2 t) => m d -> (forall d1 d2. (Data d1, Data d2) => m (t d1 d2)) -> m d
14:24:18 <lambdabot> Data.Generics.Aliases ext2B :: (Data a, Typeable2 t) => a -> (forall d1 d2. (Data d1, Data d2) => (t d1 d2)) -> a
14:24:31 <Abraxas> i get that, we can just take a function f for which f y = v
14:24:54 <crdueck> @hoogle Monad m => [a] -> (b1,b2) -> m a
14:24:54 <lambdabot> Data.Generics.Aliases ext2R :: (Monad m, Data d, Typeable2 t) => m d -> (forall d1 d2. (Data d1, Data d2) => m (t d1 d2)) -> m d
14:24:54 <lambdabot> Data.Generics.Aliases ext2B :: (Data a, Typeable2 t) => a -> (forall d1 d2. (Data d1, Data d2) => (t d1 d2)) -> a
14:24:55 <lambdabot> Data.Graph.Inductive.Query.BFS bfsn :: Graph gr => [Node] -> gr a b -> [Node]
14:25:13 <Abraxas> but the second case confuses me, because y is passed unchanged to g, although it's not trivial to me that this can always be done
14:25:55 <michael_> Hi - I do not really have much experience with Haskell, but I am trying to get started on a small Haskell project. Is there any chance any of you could spare a few minutes to help me understanding a few basic things?
14:25:57 <shachaf> Pass an extra argument recursively? Why not?
14:26:04 <shachaf> michael_: Not if you don't ask your question.
14:28:02 <nand`> byorgey: in which way may diagrams be hazardous to my health?
14:28:10 <michael_> My task is to write a function apply :: State -> [Rule] -> State that takes a state (i.e. a sequence of letters) and applies to each letter of this state the first applicable rule from a list of rules.
14:28:33 <michael_> Letters that have no applicable rules are copied to the new state.
14:28:38 <byorgey> nand`: you might, for example, stay up too late making diagrams and end up not getting enough sleep
14:28:43 <michael_> Or "should be copied to the new state"
14:28:44 <byorgey> this may be detrimental to your health.
14:28:57 <nand`> oh my god, it's 23:28 as you say this; I was planning on sleeping at 21:00 or so
14:28:57 <michael_> I have not yet figured out how.
14:28:58 <Abraxas> how do i know that y has to go right there and not any other place on the RHS
14:29:04 <byorgey> hahahaha
14:29:27 <byorgey> well, you can't say I didn't warn you.
14:29:45 <michael_> According to the description, I can test my function by calling it with the following command:
14:29:45 <michael_> apply "FXRYF" [Rule 'X' "XRYF", Rule 'Y' "FXLY"]
14:30:02 <michael_> That should produce the following result:
14:30:03 <michael_> "FXRYFRFXLYF"
14:30:32 <Abraxas> what if there are several functions on the RHS, do it has to be passed as first argument to all of them?
14:30:36 <michael_> But I do not really have any idea whatsoever how that could be implemented in Haskell.
14:30:57 <maukd> michael_: how would you implement it in non-haskell?
14:31:00 <byorgey> looks like a heighway dragon =)
14:31:06 <crdueck> is there anything like Data.Foldable for filter?
14:31:16 <byorgey> crdueck: no
14:31:26 <michael_> I have implemented it in Python, which I am more familiar with - I can show you, if you want? ;)
14:31:34 <crdueck> byorgey: any reason not? seems like it would be useful
14:31:39 <maukd> michael_: sure
14:31:40 <byorgey> crdueck: what would the type be?
14:31:58 <michael_> One moment, will need to paste it to pastebin
14:32:05 <byorgey> crdueck: well, maybe that's not the right question.  A better question is, what sorts of container types could you filter?
14:32:15 <hpc> michael_: here's something that might get you started
14:32:17 <byorgey> crdueck: e.g. can I filter a binary tree?  What would that mean?
14:32:46 <nand`> here's how I would implement ‘apply’: I would go through the state and check for matching rules. If I don't find any, I'd copy it over unchanged
14:32:50 <crdueck> byorgey: okay, i see your point with a binary tree. but anything containing lists or list-like recursive structures would work
14:32:55 <nand`> I'm not sure if that helps.
14:33:02 <hpc> > "FXRYF" >>= \c -> case c of 'X' -> "XRYF"; c -> c
14:33:03 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
14:33:04 <lambdabot>         against inferred ty...
14:33:07 <hpc> > "FXRYF" >>= \c -> case c of 'X' -> "XRYF"; c -> [c]
14:33:08 <lambdabot>   "FXRYFRYF"
14:33:10 <crdueck> byorgey: i'll just make my own, but i thought i'd see if there was anything standard first
14:33:22 <trotro> type tree a = list (tree a) :D
14:33:32 <hpc> michael_: or actually, a bit more clearly
14:33:58 <michael_> http://pastebin.com/2KGqGWQv
14:34:00 <byorgey> crdueck: my point is just that it is much less general than Foldable, though you're certainly right that you can imagine a class of situations where the concept applies
14:34:03 <maukd> The paste 2KGqGWQv has been copied to http://hpaste.org/76339
14:34:06 <hpc> > do {c <- "FXRYF"; case c of 'X' -> "XRYF"; c -> [c]}
14:34:07 <lambdabot>   "FXRYFRYF"
14:34:11 <michael_> My Python implementation
14:34:14 <byorgey> crdueck: sure, just make your own if you want it
14:34:29 <nand`> byorgey: does diagrams have facilities for doing something like in calligraphy where you'd trace a path with a slanted line
14:34:40 <byorgey> nand`: no, it doesn't
14:34:44 <maukd> michael_: where's the apply function?
14:35:02 <michael_> That's called "expand" in this example - sorry if that was unclear.
14:35:28 <byorgey> nand`: I suppose it would require implementing some general functions for manipulating paths
14:35:38 <maukd> michael_: ... why is it a method on Rule?
14:35:55 <michael_> But thank you :)
14:36:02 <michael_> Is that a bad idea?
14:36:03 <byorgey> nand`: there's no reason in principle it hasn't been done.  It's just not implemented.
14:36:16 <maukd> michael_: it makes no sense to me
14:36:17 <byorgey> no reason in principle it *couldn't be done
14:36:31 <nand`> I see; but I thought generalized paths were implemented?
14:36:41 * hackagebot gearbox 1.0.0.1 - zooming rotating fractal gears graphics demo  http://hackage.haskell.org/package/gearbox-1.0.0.1 (ClaudeHeilandAllen)
14:36:43 <nand`> the tutorial at least seems to mention ‘paths’
14:36:48 <byorgey> nand`: yes, we have general paths.
14:36:52 <Abraxas> shachaf: let's say i understand (or accept :p) that...then it gets really wild in the next step: h y (x : xs) = g y x (h y xs) <=> h y (x : xs) = g y x xs (h y xs)
14:36:57 <byorgey> nand`: but no functions on paths for doing what you said.
14:37:04 <nand`> I see
14:37:15 <michael_> Sorry, maybe the Python will just confuse - I should probably have left out that :)
14:37:22 <mcstar> > let apply [] _ = []; apply (x:xs) rs = (case lookup x rs of Nothing -> [x]; Just s -> s) ++ apply xs rs in apply "FXRYF" [('X',"XRYF"),('Y', "FXLY")]
14:37:25 <lambdabot>   "FXRYFRFXLYF"
14:37:32 <Abraxas> just put an entire list on one side and everything is still ok?
14:37:42 <byorgey> I mean, if you have a backend that can do that sort of generalized stroking, then you could very easily make some primitives to direct the backend to do it
14:38:15 <joe9> between unixutils 1.48.1 and 1.50, the lazyCommand seems to have been removed.
14:38:28 <michael_> Wauw, it works great actually :)
14:38:29 <joe9> is there a different package that has this function?
14:38:33 <byorgey> nand`: but I was thinking more along the lines of "given a path, output the outline of the region (as another path) which results from stroking the first path with a slanted line"
14:39:05 <JuanDaugherty> why don't haskell packages dynamically link each other?
14:39:21 <nand`> let apply rs = mapM (\x -> fromMaybe [x] (lookup x rs)) in apply "FXRYF" [('X', "XRYF"),('Y', "FXLY")]
14:39:28 <nand`> > let apply rs = mapM (\x -> fromMaybe [x] (lookup x rs)) in apply "FXRYF" [('X', "XRYF"),('Y', "FXLY")]
14:39:29 <lambdabot>   Couldn't match expected type `(a, [a])'
14:39:29 <lambdabot>         against inferred type `GHC....
14:40:01 <nand`> oh
14:40:08 <nand`> > let apply rs = mapM (\x -> fromMaybe [x] (lookup x rs)) in apply [('X', "XRYF"),('Y', "FXLY")] "FXRYF"
14:40:10 <lambdabot>   ["FXRFF","FXRXF","FXRLF","FXRYF","FRRFF","FRRXF","FRRLF","FRRYF","FYRFF","F...
14:40:11 <nand`> I flipped the arguments
14:40:21 <nand`> and that doesn't look right :(
14:40:21 <michael_> I have to implement it in this file, so I will just need to adjust the syntax, I guess :)
14:40:22 <michael_> http://pastebin.com/5xHWM4Ug
14:40:27 <maukd> The paste 5xHWM4Ug has been copied to http://hpaste.org/76340
14:40:34 <maukd> > let apply rs = concatMap (\x -> fromMaybe [x] (lookup x rs)) in apply [('X', "XRYF"),('Y', "FXLY")] "FXRYF"
14:40:35 <lambdabot>   "FXRYFRFXLYF"
14:40:50 <nand`> oh, I want (>>=) not mapM
14:41:10 <Saizan> JuanDaugherty: the support wasn't always there in GHC and i guess it's not the default yet, i've never looked into it though
14:41:11 <maukd> > let apply rs = concatMap (liftM2 fromMaybe return (flip lookup rs)) in apply [('X', "XRYF"),('Y', "FXLY")] "FXRYF"
14:41:13 <lambdabot>   "FXRYFRFXLYF"
14:41:31 <JuanDaugherty> Saizan, ah
14:41:41 <nand`> > let apply xs rs = do x <- xs; fromMaybe [x] (lookup x rs) in apply "FXRYF" [('X', "XRYF"),('Y', "FXLY")]
14:41:42 <lambdabot>   "FXRYFRFXLYF"
14:41:43 * hackagebot qd 1.0.2.1 - double-double and quad-double number type via libqd  http://hackage.haskell.org/package/qd-1.0.2.1 (ClaudeHeilandAllen)
14:41:45 * hackagebot qd-vec 1.1 - 'Vec' instances for 'qd' types  http://hackage.haskell.org/package/qd-vec-1.1 (ClaudeHeilandAllen)
14:41:47 <maukd> > let apply = concatMap . liftM2 fromMaybe return . flip lookup in apply [('X', "XRYF"),('Y', "FXLY")] "FXRYF"
14:41:49 <lambdabot>   "FXRYFRFXLYF"
14:42:08 <michael_> I guess only minor adjustments will be needed in order to make it work with that Haskell file? :)
14:42:38 <maukd> michael_: well, you'd have to write your own 'lookup'
14:42:46 <maukd> because the standard function works on pairs, not Rules
14:42:47 <dessos> > 2 + 2
14:42:48 <lambdabot>   4
14:43:10 <maukd> :t find
14:43:10 <michael_> Hm, what would such a function have to do?
14:43:11 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:43:32 <maukd> michael_: we can go down to the fundamental building blocks
14:43:54 <maukd> michael_: e.g. you could write a function: matches :: Char -> Rule -> Bool
14:44:03 <maukd> that tells you whether a given rule matches a char
14:44:18 <michael_> Oh... :)
14:44:22 <nand`> edwardk: wait, where did all of the lenses go?
14:44:31 <edwardk> which ones?
14:44:34 <michael_> I would need such a function to make it work?
14:44:40 <nand`> oh, never mind; I was looking at the wrong page
14:44:44 <edwardk> nand`: heh
14:44:45 <maukd> michael_: not necessarily, but it would be one way to proceed
14:44:53 <nand`> (yes, I'm really tired)
14:45:34 <michael_> Well, if that is one way, it is great - I do not really have any preferences, since I have just started learning Haskell.
14:46:03 <michael_> I was just a bit frustrated that I could not get it to work, so I thought I would ask here :)
14:46:54 <michael_> I'm currently trying to modify it a bit to get it working :)
14:49:29 <michael_> The first step would probably be to understand every little tiny bit of the code, I guess
14:51:35 <edwardk> Added the ?~ and ?= combinators to lens, so now you can do things like m % at 42 ?= "bar"  -- rather than .~ Just "bar"
14:51:41 <edwardk> that should clean up a fair bit of code
14:52:30 <D4GGe> hi someone know how to do if i want to test more than 100 cases with quickCheck?
14:53:12 <byorgey> D4GGe: yes, use quickCheckWith instead of quickCheck
14:53:43 <hiptobecubic> D4GGe, look at the hackage page for quickcheck, and at the default args.
14:54:17 <byorgey> quickCheckWith (stdArgs { maxSuccess = 500 })
14:54:41 <maukd> quickCheckWith stdArgs{ maxSuccess = 500 }
14:54:56 <hiptobecubic> that's the one
14:55:05 <ion> maxSuccess = avoidAtAllCosts
14:56:58 <fmap> edwardk: you meant ?= "bar" rather than .= Just "bar"?
14:57:07 <edwardk> yeah
14:57:09 <D4GGe> thanks
14:57:18 <fmap> nice, should be useful
14:57:33 <edwardk> it'l be on 3.0.4 in a few minutes once all the tests run
15:01:04 <brianm> I am a haskell newbie, apologies for probably basic questions, but what does
15:01:12 <brianm> <no location info>: module `System.Process' is a package module
15:01:22 <brianm> mean when I try to ":load System.Process" in ghci?
15:01:35 <Dashkal> There's some good news.  The new RPi model Bs will ship with 512 megs of ram.  On-board haskell development just got easier.
15:01:37 <Attic> brianm: You need to use :m System.Process
15:01:41 <Attic> not load
15:01:42 <brianm> Attic: thanks
15:01:49 <Dashkal> :load is for loading haskell source
15:01:53 <brianm> ah
15:06:41 * hackagebot lens 3.0.4 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.0.4 (EdwardKmett)
15:12:20 <mysticc> I have a function prop :: ByteString -> Property .. When I do test = testProperty "myfunction" prop .. I get some weird error No instances for (QuickCheck-2.4.2:Test.QuickCheck.Property.Testable (Gen Prop),QuickCheck-2.4.2:Test.QuickCheck.Arbitrary.Arbitrary ByteString) arising from a use of `testProperty'
15:13:13 <mysticc> what is that I am doing wrong .. I am using testProperty from Test.Framework.Providers.QuickCheck2
15:14:56 <dmwit> mysticc: At a guess, you've got two versions of QuickCheck installed, and they're interfering.
15:15:05 <dmwit> Gotta run, but maybe this is enough of a hint for you to make progress.
15:41:42 * hackagebot haskell-modbus 0.1 - A haskell implementation of the Modbus protocol  http://hackage.haskell.org/package/haskell-modbus-0.1 (JasonHickner)
15:51:42 * hackagebot route-generator 0.4 - Utility to generate routes for use with yesod-routes  http://hackage.haskell.org/package/route-generator-0.4 (StephenWeber)
16:02:52 <k00mi>  /quit
16:02:56 <k00mi> woops
16:03:34 <enolan> http://www.reddit.com/r/haskell/comments/11ixcl/absurd_ambition_towards_lifting/
16:04:56 <strager> How would I get the IEEE 754 representation of a Double in Haskell?  Some function :: Double -> Word64
16:05:36 <trotro> double is always on 64 bits ?
16:06:04 <strager> It's "at least" 64 bits, according to http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Double
16:06:17 <trotro> whaou
16:06:20 <trotro> what a choice
16:06:47 <trotro> is there a floating type but we don't really know the size ? like double or int C ?
16:06:51 <strager> I just need to serialize a 64-bit double over the network.
16:06:53 <trotro> (yes int is not floating)
16:07:13 <strager> You don't really know the size of Int in Haskell; it only has a minimum bound.
16:07:31 <edwardk> enolan: check twitter for a laundry list of issues
16:07:45 <trotro> strager, which is ? one byte like in C ?
16:08:00 <strager> no; at least 30 bits
16:08:50 <Cale> http://www.youtube.com/watch?v=AmN0YyaTD60 :D
16:09:10 <ousado> strager: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Data.html
16:09:32 <edwardk> enolan: the short version is that the two notions of a derivative involved aren't interchangeable, not even a little bit
16:10:20 <jmcarthur> strager: most people do this by writing to a pointer and then casting it to the other type
16:10:38 <jmcarthur> strager: you can also do it using STUArray, if i recall correctly, because it can also be cast
16:10:45 <jmcarthur> (unsafely, of course)
16:11:12 <jmcarthur> strager: the *wrong* thing to do is using unsafeCoerce
16:12:58 <strager> jmcarthur: Well I'm not guaranteed that the Haskell representation is what I want.
16:13:25 <strager> ousado: I am not sure how that will help me.
16:13:58 <ousado> doh I meant Data.Serialize, sorry
16:14:05 <strager> Oh good; here's what I want http://hackage.haskell.org/packages/archive/data-binary-ieee754/0.4.2.1/doc/html/Data-Binary-IEEE754.html
16:16:45 <copumpkin> EvanR: tanking
16:20:19 <Kanisterschleife> hi. Is it possible to have the definition of a type constructor depend on some value of a given type? for example, is it possible to do define for each natural number n a type constructor List n which takes a type to its type of n-tuples?
16:20:34 <trotro> dependent types
16:21:17 <copumpkin> you sort of can do it in haskell, but it's a bit more of a pain
16:21:43 * hackagebot mtlx 0.1.6 - Monad transformer library with type indexes,  providing 'free' copies.  http://hackage.haskell.org/package/mtlx-0.1.6 (MarkSnyder)
16:22:30 <Saizan> next version of ghc should have type natural literals
16:23:03 <c_wraith> doesn't 7.6 have that already?
16:23:13 <Saizan> ah, maybe so
16:23:17 <c_wraith> It's just missing the solver for doing things with them other than using them as labels
16:23:27 <parsercombinator> is it possible to have purely-functional IO without monads?
16:23:38 <Saizan> anyhow the problem is that you need as many instances as tuple types you want to cover
16:24:05 <c_wraith> parsercombinator: there's no reason IO has to be a monad.  See older versions of haskell.  the monad abstraction is just a convenient way to structure dealing with IO - and a lot of other things.
16:24:16 <Kanisterschleife> What I would like to do is to define a typeclass FinRng of data types which are provied addition, multiplication, 0 and 1, and then to provide a type a type constructor which takes a type R in FinRng as well as a monic polynomial f in R (i.e. a finite list) and provide a new data type whose values are the elements of the quotient ring R[x]/(f)
16:24:56 <Saizan> parsercombinator: there are versions of haskell where main :: [Response] -> [Request]
16:24:56 <Kanisterschleife> In this case the new type would depend on a given one as well as on a list with values in that type
16:25:03 <Saizan> parsercombinator: another options is CPS
16:25:09 <parsercombinator> so the other purely-functional languages use things like streams or continuation-passing?
16:25:49 <tac> parsercombinator: Monads are just a trick to do state-threading.
16:26:08 <tac> as long as you can model the world as a sequence of states, you can model IO
16:26:11 <trotro> monads is the solution to all the problems
16:26:17 <Kanisterschleife> Saizan: Could you provide an example of how it works, like the one with finite lists?
16:26:31 <parsercombinator> monads seem simple
16:27:00 <parsercombinator> if I understand what >>= and `return` mean, then I guess I can finally grok them ^_^
16:27:04 <Saizan> parsercombinator: Clean uses uniqueness types, other use effect types
16:27:35 <ion> foldl, length, sum, product, reverse are partial? http://www.haskell.org/haskellwiki/List_of_partial_functions
16:27:49 <Saizan> tac: argh, that's really bad
16:28:03 <tac> "bad" depending on what your needs are.
16:28:08 <fmap> > length [1..]
16:28:12 <lambdabot>   mueval-core: Time limit exceeded
16:28:20 <XMunkki> I really suck at these concept so feel free to correct me, but there are many way to express how a computations result flows through and when it starts/ends..
16:28:32 <ion> Ah, i forgot about infinite lists. :-)
16:28:52 <XMunkki> clean has the uniqueness types.. haskell uses monads..
16:29:25 <XMunkki> do I understand mondas wrong? basically a way of stringing together computations "in a specific state"?
16:29:36 <Saizan> Kanisterschleife: you can define e.g. type family List (n :: Nat) (a :: *) :: *, type instance List 0 a = (); type instance List 1 a = a; type instance 2 a = (a,a); .. this because tuples are flat
16:29:45 <c_wraith> XMunkki: that's something monads can do.  But they're much more abstract than that.
16:30:31 <Saizan> Kanisterschleife: you probably want to learn about type families and gadts
16:30:33 <XMunkki> c_wraith: indeed.. my understanding is that the actual monad is the "way" it strings those together..
16:30:35 <c_wraith> XMunkki: The only things monads "are" is an abstraction for combining "things" in such a way as to "seem natural".
16:30:38 <tac> If I'm not mistaken, Monads are more or less "the simplest data type that give rise to continuations"
16:30:44 <tac> and you can build IO with continuations.
16:30:49 <tac> or something along those lines.
16:30:57 <tac> In a very hand-wavy fashion.
16:31:14 <c_wraith> XMunkki: where "things" and "seem natural" are very dependent on context
16:31:41 <hpc> tac: other things give rise to continuations
16:31:52 <hpc> just look at Cont's instance list
16:31:53 <XMunkki> yeah the abstract notion doesn't help me much :) more like am I in the right or wrong road?
16:32:14 <tac> Everyone gets hung up on monads at first.
16:32:27 <tac> Learn do notation. The rest will come in time, IMO.
16:32:30 <Cale> XMunkki: "Stringing together computations" is right for most of the monads you'll run into in Haskell.
16:32:33 <c_wraith> XMunkki: the thing is, the abstraction notion is the only one that matters. monads are an exceptionally abstract creation. That's the whole point.
16:32:41 <Cale> XMunkki: But "state" is only true for some of them.
16:32:54 <parsercombinator> when is unsafePerformIO necessary?
16:33:18 <Kanisterschleife> Saizan: ah ok, I see. How could I instead make the first argument a value of type [a] instead of a natural number? i.e. what to do if the arguments are not independent? Can I do something like type family bla (a :: *) :: ([a] -> *)?
16:33:20 <hpc> parsercombinator: almost never
16:33:25 <tac> Whenever you feel like you need to get something done, and you're willing to put up with the shit #haskell gives you for using an unsafe construct :)
16:33:40 <hpc> the cases in which is is truly necessary are so few, i can't even think of any
16:33:40 <tac> It's considered bad form.
16:33:46 <Cale> parsercombinator: when you'd otherwise be forced to add new features to GHC's evaluation mechanism to implement your primitive low level data structure implementation.
16:33:55 <XMunkki> cale/c_wraight: thanks.. :) too much other discussion here to really dig down.. :) but it feels I'm at least on the path of understanding..
16:34:03 <tac> unsafePerformIO is a good way to create untraceable bugs.
16:34:07 <Cale> parsercombinator: Or when you're importing pure things via FFI.
16:34:17 <parsercombinator> right
16:34:26 <hpc> Cale: ooh, hadn't thought about that
16:34:34 <hpc> how often does that happen?
16:34:41 <Cale> parsercombinator: It's only okay to use if you don't care how often or how many times the IO action is run.
16:34:52 <parsercombinator> H
16:35:17 <Cale> parsercombinator: (or otherwise, if you understand GHC so well as to know that it will only run exactly when you want it to)
16:37:11 <Saizan> Kanisterschleife: you can with PolyKinds i think, but type families never get values as arguments, only types and kinds
16:38:39 <Kanisterschleife> Saizan: hm, but in your example above, one has a value of Nat as argument?
16:38:46 <Saizan> Kanisterschleife: though because of gadts you can have some of the structure of a value reflected in its type, so you can connect the two
16:39:06 <Saizan> Kanisterschleife: that Nat is a kind, and those 0, 1, 2,.. are types
16:39:51 <Saizan> Kanisterschleife: i guess the interesting part is that these Nat there are compilation-time, they are already gone when you program runs
16:43:52 <tromp> > 687232 / 832
16:43:53 <lambdabot>   826.0
16:44:10 <Kanisterschleife> Saizan: ok, thank you, I think I have to take some time and read about type families
16:44:15 <parsercombinator> :t \_ -> 1/0
16:44:16 <lambdabot> forall t t1. (Fractional t1) => t -> t1
16:44:44 <parsercombinator> > let f = \_ -> 1 / 0 in f ()
16:44:45 <lambdabot>   Infinity
16:45:16 <ion> xmunkki: Functors introduce a generic “map” operator: you get to apply a function to values contained/generated by something (such as a list, an IO action, a parser or Maybe). An example using Maybe and also using list:
16:45:38 <ion> > ((+42) <$> Just 5, (+42) <$> Nothing, (+42) <$> [0..4])
16:45:39 <lambdabot>   (Just 47,Nothing,[42,43,44,45,46])
16:45:47 <parsercombinator> so you get to map over structures like Trees
16:45:50 <parsercombinator> or Graphs
16:46:04 <ion> xmunkki: Applicative functors extend functors by making it possible for the function to be drawn out of the container/generator:
16:46:17 <XMunkki> ion: we need to talk about this out of the channel :) pref face to face :)
16:46:28 <ion> xmunkki: (Just (+42) <*> Just 5, Nothing <*> Just 5, Just (+42) <*> Nothing, [id, (+42)] <*> [0..4])
16:46:34 <ion> whoops
16:46:35 <ion> > (Just (+42) <*> Just 5, Nothing <*> Just 5, Just (+42) <*> Nothing, [id, (+42)] <*> [0..4])
16:46:37 <lambdabot>   (Just 47,Nothing,Nothing,[0,1,2,3,4,42,43,44,45,46])
16:46:39 <XMunkki> yeah I know the functor -> app func -> monad thing..
16:47:02 <XMunkki> to me it's all about upping the state of application and "who does it"
16:47:34 <ion> XMunkki: The function itself (for instance, (+42)) still doesn’t get to e.g. change a “Just” to “Nothing”. Monads extend applicative functors by giving the function that power:
16:48:06 <ion> > let f n | odd n = Just (n+42) | otherwise = Nothing in (Just . (+42) =<< Just 5, const Nothing =<< Just 5, f =<< Just 5, f =<< Just 6, (\n -> replicate n n) =<< [0..4])
16:48:07 <lambdabot>   (Just 47,Nothing,Just 47,Nothing,[1,2,2,3,3,3,4,4,4,4])
16:48:23 <XMunkki> ion: yeah I think of those like "lifting"...
16:48:32 <XMunkki> you get to raise that to a CONTEXT
16:49:11 <XMunkki> and in the CONTEXT of maybe, in nothing it's nothing, it just, it's the value of just applied to the function..
16:49:31 <XMunkki> and sorry if I'm mixing up terms with other languages :)
16:49:57 <gwern> @quote context
16:49:58 <lambdabot> ghc says: The signature contexts in a mutually recursive group should all be identical
16:50:57 <XMunkki> makes no sense, that
16:51:16 <hpc> http://hpaste.org/76344 -- this imagemagick project is coming along amazingly
16:52:31 <ion> In IO, “length <$> getLine” is an IO action that reads a line and results in its length. “(+) <$> readLn <*> readLn” is an IO action that reads two numbers and results in their sum. ((+) <$> readLn :: IO (Integer -> Integer), so it has the right type for <*>’s first parameter: a function in IO.) “readLn >>= \n -> if even n then putStrLn "even" else putStrLn "odd"”: with the monad, the function
16:52:32 <ion> gets to choose the next IO action based on the result of the previous one.
16:53:37 <XMunkki> for you old school haskellers.. how the hell do you read other peoples haskell code?
16:54:02 <XMunkki> as an old timer statically typed person, the typing is the thing that documents the code..
16:54:04 <hpc> XMunkki: i look at types first
16:54:05 * monochrom prefers: "(length <$> getLine) >>= callback" reads a line, then calls callback with the length
16:54:06 <XMunkki> to me
16:54:14 <hpc> and data definitions
16:54:14 <XMunkki> hpc: and how?
16:54:40 <hpc> it's easier to put together individual definitions when you know the big picture of a module
16:54:44 <XMunkki> like if you look at a function body with that strings the functions together...
16:54:52 <monochrom> this is because I don't want to say that "IO Int" is "returns _____"
16:54:52 <hpc> but if the function bodies are simple, i might not even bother
16:54:53 <XMunkki> there was a name for the style..
16:55:05 <XMunkki> a . b . c
16:55:07 <XMunkki> etc
16:55:08 <hpc> depends on what's most helpful to understanding the code
16:55:16 <ion> xmunkki: In good code, anything whose type is not obvious to the reader should have an explicit type signature IMO.
16:55:31 <shachaf> @quote rwbarton inference
16:55:32 <lambdabot> rwbarton says: type inference is supposed to be the compiler's job, not the reader's job
16:55:50 <XMunkki> ion: just so often I see code that strings, say, 3 functions together.. from all over the scope..
16:56:14 <XMunkki> now I need to somehow see from the word (IDE can help, yes) that where it comes from..
16:56:18 <XMunkki> then what it does..
16:56:27 <XMunkki> thenI need to go back..
16:56:38 <XMunkki> try to remember.. how many arguments it had..
16:56:51 <XMunkki> and see how it was applied in the case I was looking..
16:57:00 <XMunkki> and this was the first place..
16:57:06 <ion> xmunkki: Do you have an example of especially confusing code like that?
16:57:08 <XMunkki> "7 more to go"
16:57:49 <XMunkki> ion: well we 2 know each other.. so most of the functional code I see.. even the stuff I have written myself..
16:58:26 <XMunkki> hence me asking here how the hell do you people structure your code so you won't get lost in the "typing hell" years later..
16:59:08 <dmwit> Top level type signatures, and strong naming conventions.
16:59:20 <dmwit> The latter are necessarily strongly domain-specific.
16:59:23 <monochrom> I'm pretty sure you're just looking for an IDE, since OO people should have the same problem but I never heard them talk about it. Consider: code that calls 3 methods from 3 classes sequentially. (How is that better than stringing 3 functions?)
16:59:23 <edwardk> XMunkki: the way i avoid it is that haskell tends to be built out of small obviously correct parts
16:59:57 <edwardk> i write small combinators and build up smarter combinators using those, and in the end, my solution to my problem usually involves stringing together a few small, reusable widgets
17:00:11 <edwardk> that can each be understood in isolation
17:00:32 <XMunkki> OO people hide behind namespaces and such.. stuff that haskell could have.. but not sure it really should.. =) still trying to understand (again reason why I asked)
17:00:34 <hpc> edwardk: but then when someone reads your type definitions, O.O
17:00:36 <hpc> ;)
17:00:50 <XMunkki> really good answers btw, thanks..
17:00:53 <monochrom> no, namespace is not the issue. we have namespace too
17:01:04 <edwardk> hpc: heh, well, the type definitions tell a lot to a well trained eye. those parameters let you know a _lot_ about what _isn't_ being manipulated at any given point in time.
17:01:06 <XMunkki> I'm gathering more of a generic feeling here..
17:01:10 <edwardk> Free theorems are amazing like that
17:01:17 <hpc> agree
17:01:34 <hpc> oh, can you review a type i am considering a library for?
17:01:42 <edwardk> fst :: (a,b) -> a  -- completely characterizes the function assuming it doesn't do something stupid like force stuff it doesn't need to, and that it terminates
17:01:51 <hpc> edwardk: type CompileT s r c m a = StateT (s, r -> c r) m a
17:02:02 <edwardk> kinda messy
17:02:12 <edwardk> whats the s?
17:02:17 <edwardk> arbitrary user state?
17:02:21 <hpc> yeah
17:02:38 <edwardk> so first thing i'd do
17:02:46 <edwardk>  type CompileT s r c = StateT (s, r -> c r)
17:02:54 <edwardk> is stop talking about things you don't use directly =0
17:02:59 <hpc> heh
17:03:01 <edwardk> that lets the type alias be used in more contexts
17:03:11 <hpc> i was going to turn it into a newtype
17:03:20 <XMunkki> I have to say I've never gotten past the confusion of partial application in code that I read..
17:03:27 <XMunkki> really easy to use and grok..
17:03:30 <XMunkki> and I like it..
17:03:52 <edwardk> second i'd consider just doing it the state 's' and your r -> c r current compilation or whatever separately
17:03:53 <XMunkki> but if I read code, it's just impossible to know what I'm reading..
17:03:56 <edwardk> e.g. distill it down to
17:04:09 <XMunkki> are you guys basically just using a good editor to handle that?
17:04:43 <edwardk> newtype CompileT r c m a = CompileT { decompileT :: (r -> c r) -> (a, r -> c r) }
17:04:46 <monochrom> we learned reading and writing partial applications
17:05:12 <edwardk> XMunkki: in the code in question its just eta-reduction.      \x -> f x    can be reduced to f.
17:05:46 <edwardk> type Foo a b c = Bar Int c   can be reduced to type Foo a b = Bar Int    -- the extra parameters get passed to the body
17:05:49 <ion> xmunkki: After using Haskell for a while you’ll learn to understand it intuitively.
17:06:10 <XMunkki> well I never did in the other dynamically typed languages..
17:06:13 <hpc> edwardk: neat
17:06:13 <ion> xmunkki: And from that point on you’ll find the lack of it annoying in other languages. :-P
17:06:18 <XMunkki> well actually I did for my OWN code..
17:06:26 <XMunkki> but my question is for code you read
17:06:31 <XMunkki> other people
17:06:34 <monochrom> it is not like OO people do not have a few very advanced design patterns to learn. I bet a good portion of OO people haven't grokked visitor
17:06:35 <edwardk> hpc: if you have custom combinators for manipulating that continuation like structure, then the user can bolt state on there himself if he needs it
17:06:40 <edwardk> and you've split out that concern
17:06:51 <johnw> joeyh: ping
17:06:52 <hpc> sweet
17:07:04 <hpc> i won't be able to split it out for what i am doing, but in general that will be nice
17:07:10 <edwardk> XMunkki: part of it is that in strict language, eta-reduction isn't always sound
17:07:26 <ion> xmunkki: I don’t know what i can say other than that it just won’t be a problem after getting used to the language.
17:07:29 <XMunkki> yeah I'm not saying OO people are any better.. I'm just trying to grok how you guys read (and understand) each others code..
17:07:37 <edwardk> XMunkki: \x -> f x  = f doesn't necessarily hold if 'f' has side-effects and your language is evil
17:08:19 <hpc> edwardk: i am currently using that type as a short-circuiting (Image -> IO Image) pipeline, for imagemagick
17:08:21 <monochrom> at the end it's all the sunken cost fallacy. "because I sunk 4 years of college plus 4 year at work into learning this way, I get to call other ways counterintuitive"
17:08:42 <edwardk> ah
17:08:47 <hpc> it's been working remarkably well, and i am trying to think of other places where it would be nice to have
17:08:59 <hpc> in my head, it looks a lot like a "reverse continuation"
17:09:10 <hpc> where it reifies "before this point in the computation" instead of "after"
17:09:42 <edwardk> I figure i had 20+ years of writing code imperatively. Haskell was a wonderful change of pace.
17:11:33 <monochrom> the good news is that it probably doesn't take 8 years to learn intermediate or even advanced haskell ways. but it is still learning. learning is always hard
17:11:57 <Jello_Raptor> hmm, i'm confused http://hpaste.org/76345
17:12:40 <monochrom> some people envy my emacs know-how (and I don't know that much actually) and ask what I did. I shelled out $20 for an emacs book and set aside 2 weeks learning, that's what I did. is that not expected?
17:13:04 <ion> What’s a good emacs book, btw?
17:13:19 <troydm> main question of programming in haskell that i still have
17:13:27 <monochrom> I don't know. but I went to an O'Reilly one. (can't go too wrong, eh?)
17:13:31 <dolio> I certainly haven't bought an emacs book.
17:13:38 <troydm> is say you have a software that loads it's settings from a configuration
17:13:54 <dolio> Nor a vim book.
17:13:59 <troydm> how can you maintain it's global configuration accross whole program
17:14:34 <troydm> pass it like a state monad?
17:14:35 <hpc> you could use ReaderT
17:14:47 <hpc> (you would almost always want a read-only config)
17:14:53 <monochrom> xmonad has an example
17:15:25 <hpc> xmonad is a strange example
17:15:30 <edwardk> heh, dolio would tell you to steer clear of whatever vim reference i used. ;)
17:15:43 <dolio> Yes.
17:15:53 <dolio> Apparently it tells you to go to the end of file by going to line 1 billion.
17:15:56 <dmwit> ?hackage dyre
17:15:56 <lambdabot> http://hackage.haskell.org/package/dyre
17:16:16 <edwardk> re: learning emacs there is always http://www.gnu.org/software/emacs/manual/emacs.pdf
17:16:37 <edwardk> dolio: yeah but becareful not to go to 10 billion because that might wrap around or something
17:17:10 <edwardk> or iirc, fail to parse as a number
17:17:11 <dolio> And to cut code by eyeballing the number of lines, and doing a sort of search around your initial guess.
17:17:39 <monochrom> typing in "G" can be saved by typing in nine "0"s, apparently
17:17:53 <edwardk> monochrom: that shift is so inconvenient
17:18:24 <monochrom> then you need Knuth's dream keyboard
17:18:25 <edwardk> its one of those keys that i _know_ is bound, but my reflexes don't reach for
17:18:47 <dolio> I can't remember many other quirks off the top of my head.
17:19:04 <monochrom> Knuth's dream keyboard: there are foot pedals for that, just like an organ. (fortunately, he has only dreamed of and talked about it. there is still no implementation)
17:19:16 <hpc> edwardk: no, it totally works
17:19:21 <edwardk> oh yeah thats right he plays the organ
17:19:22 <jmcarthur> i don't have much faith in knuthian ergonomics
17:19:34 <edwardk> hpc: lost context
17:19:38 <dolio> I suppose there's also: just repeat things manually instead of using the 'repeat last command' key or block select or something similar.
17:19:38 <byorgey> there are people that hook up foot pedals to use as emacs modifier keys.
17:19:47 <hpc> er
17:19:53 <monochrom> Knuth says he uses fvwm and emacs. if it pleases you :)
17:20:00 <hpc> 20:16 < edwardk> or iirc, fail to parse as a number
17:20:10 <jmcarthur> emacs isn't very ergonomic
17:20:15 <jmcarthur> (and i like emacs)
17:20:17 <LordBrain> What would be the best library/framework to do a distributed database in haskell?
17:20:27 <monochrom> emacs with foot pedals is ergonomic, no? :)
17:20:28 <edwardk> hpc: ah. i've just had problems with too many 0's in various vi implementations over the years ;)
17:20:40 <hpc> ah
17:20:44 <jmcarthur> and i know little about fvwm
17:20:49 <edwardk> monochrom: the problem is you might need a third foot
17:20:51 <hpc> a nice workaround is to do 1111111^D
17:21:02 <hpc> (down a page, hundred million times)
17:21:41 <jmcarthur> i don't think foot pedals sound very ergonomic for a text editor
17:21:47 <edwardk> meh, i'm more likely to fix my muscle memory to remember G than i am to remember another abominable hack
17:21:48 <jmcarthur> but i'm not an organist
17:22:04 * byorgey wants ear pedals
17:22:20 <edwardk> byorgey: wiggle to unlock?
17:22:29 <dolio> edwardk: Just switch to one-handed dvorak like we were discussing a while back. You'll have to retrain everything anyway.
17:22:29 * luite wants back pedals
17:22:31 <dolio> So you can do it right.
17:22:34 <byorgey> edwardk: right
17:22:36 <LordBrain> no suggestions?
17:22:43 <monochrom> I learned the piano a bit. foot pedal is convenient for me as modifier
17:22:50 <jmcarthur> LordBrain: it was a vague question
17:22:50 <edwardk> LordBrain: its a big project.
17:22:58 <dmwit> monochrom: Are those two sentences connected at all?
17:23:00 <dmwit> oh
17:23:09 <jmcarthur> LordBrain: in what way would you hope for the library to help you?
17:23:12 <monochrom> yes!
17:23:14 <jmcarthur> what should it do?
17:23:15 <edwardk> LordBrain: cloudhaskell might be handy, something for local data storage, etc.
17:23:18 * dmwit feels ashamed of his piano training now
17:23:21 <byorgey> dmwit: come now, you play the piano too =)
17:23:23 <monochrom> hehehe!
17:23:30 <LordBrain> yeah i was thinking cloud haskell
17:23:40 <Nafai> I don't play the piano very well for having 9 years of lessons
17:23:42 <shachaf> The piano is so natural for dmwit that he doesn't notice the foot pedal.
17:23:57 <dmwit> pfft, those pedals are for the week
17:23:58 <monochrom> that explains it :)
17:24:01 <jmcarthur> i also play piano, or at least used to, but i still don't associate those pedals with text editing
17:24:08 <dmwit> master players just hold the keys down and hit them more softly when necessary
17:24:13 <dolio> dmwit: Which week?
17:24:26 <dmwit> THE week, obviously
17:24:26 <MostAwesomeDude> I don't even *play* the piano anymore. It plays itself, really.
17:24:31 <dolio> Oh.
17:24:35 <monochrom> hahaha
17:24:55 <monochrom> hey, "the week" means the standard week of the week!
17:24:55 <LordBrain> jmcarthur, it would be nice to have a client server architecture, but i want the server spread out in a peer to peer. It seems like something like this must have been done time and time again by now.
17:25:42 <alpounet> i think i've seen this around somewhere on github
17:25:51 <dmwit> There's a third pedal, but given that I forgot there were pedals at all I'm somewhat proud that I remembered the purpose of the first two. ;-)
17:25:52 <jmcarthur> LordBrain: it sounds too big to have been done time and time again
17:25:58 <alpounet> oh no, left out quite some parts of the problem
17:26:08 <LordBrain> jmcarthur, you know, having redundancy, so this server gets shut down, it finds another, and they are kept relatively in sync
17:26:22 <jmcarthur> LordBrain: you know existing databases already do this, right?
17:26:35 <jmcarthur> is there any particular reason for rolling your own?
17:26:54 <LordBrain> what kind of database? you mean like a sql thing?
17:26:57 <jmcarthur> yes
17:27:00 <jmcarthur> or others
17:27:56 * byorgey has legitimately used the third pedal precisely once
17:28:44 <jmcarthur> same here, if by "third" you mean "middle"
17:29:04 <byorgey> yes
17:29:09 <jmcarthur> i've used the first, but mostly when i couldn't seem to control my enthusiam on my own
17:29:15 <luite> have you use the left one?
17:29:19 <LordBrain> jmcarthur, you suggest using something like mysql? embedding it?
17:29:24 <jmcarthur> LordBrain: sure, why not?
17:29:28 <byorgey> luite: yes, many times
17:29:33 <dmwit> Yes, the left one comes up quite a bit in comparison to the middle one.
17:29:42 <jmcarthur> LordBrain: (although personal preference leans toward postgresql)
17:29:47 <dmwit> once every few pieces or so
17:30:02 <jmcarthur> i try not to use the left one if i can help it
17:30:07 <jmcarthur> *tried
17:30:19 <luite> hmm, apparently i haven't played much then... or my teachers never thought the left one was important :)
17:30:24 <jmcarthur> i no longer play and should not make it sound like i still have a clue what i'm doing these days, being so out of practice
17:31:20 <jmcarthur> luite: i imagine beginners might use it as a crutch a lot of the time
17:31:48 <jmcarthur> i sure did
17:31:49 <dmwit> oh snap!
17:31:55 <dmwit> byorgey: [ ] not told [x] told
17:32:12 <stepcut>   oh yesod!
17:32:16 <byorgey> hahaha
17:32:22 <LordBrain> is there a system like postgresql, except not necessarily using sql, and written in haskell?
17:32:25 <jmcarthur> that was an unintentional telling
17:32:39 <jmcarthur> LordBrain: define "like"?
17:32:44 <shachaf> Who's telling what?
17:33:05 <LordBrain> it doesnt have to be that similar at all really, only that it can hold a large amount of data, and be distributed
17:33:27 <jmcarthur> shachaf: i think the progression was this: "<luite> have you use the left one? <byorgey> luite: yes, many times <jmcarthur> luite: i imagine beginners might use it as a crutch a lot of the time"
17:33:27 <startling> @pl \a b -> a (.|.) toAttrT b
17:33:28 <lambdabot> flip ($ (.|.)) toAttrT
17:33:28 <dmwit> shachaf: tl;dr byorgey uses the una corda pedal, jmcarthur says that pedal is for noobs
17:33:37 <copumpkin> lol
17:34:03 <jmcarthur> but in reality i meant that in response to "<luite> hmm, apparently i haven't played much then... or my teachers never thought the left one was important :)"
17:34:13 <jmcarthur> specifically about the teachers not teaching it bit
17:35:11 <startling> err
17:35:26 <startling> @pl \a b -> a .|. toAttrT b
17:35:26 <lambdabot> (. toAttrT) . (.|.)
17:35:31 <startling> bah
17:35:43 <shachaf> Is that a foldr?
17:35:55 <shachaf> Er, foldl?
17:35:56 <startling> it's the first argument to a foldr, yeah
17:36:11 <luite> jmcarthur: yeah i remember being shown what it was for on a grand piano, but i can't remember using it regularly....
17:36:27 <jmcarthur> there's so intuition shachaf apparently has that i don't, to recognize that as a foldl
17:36:36 <jmcarthur> or perhaps knowledge of what that operator and function are?
17:36:38 <startling> oh right, arguments are backwards in foldr
17:36:44 <shachaf> jmcarthur: Well, I was wrong, apparently.
17:36:51 <shachaf> Anyway, I was going to say, use fold + map
17:36:56 <startling> shachaf: nope, you found a bug in my code
17:37:05 <startling> shachaf: fold uses mappend, right?
17:37:07 <shachaf> Which only makes sense if that's a foldl (or if startling's arguments are backwards).
17:37:14 <shachaf> mappend?
17:37:16 <jmcarthur> startling: yes, if you mean Data.Foldable.fold
17:37:22 <startling> oh
17:37:25 <shachaf> Oh, that fold.
17:37:59 <jmcarthur> startling: which for lists is the same as mconcat
17:38:21 <startling> jmcarthur: (.|.) is bitwise OR, though
17:38:29 <jmcarthur> startling: ah, indeed
17:38:41 <jmcarthur> so you would need an Or monoid type
17:38:51 <maukd> @hoogle Any
17:38:51 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
17:38:52 <lambdabot> Data.List any :: (a -> Bool) -> [a] -> Bool
17:38:52 <lambdabot> Data.Monoid Any :: Bool -> Any
17:39:06 <jmcarthur> Any is the logical or version
17:39:08 <shachaf> > foldr (\x y -> x + f y) z [a,b,c,d] -- jmcarthur: The reason I thought it might be a foldl is that this is an unusual thing to do.
17:39:10 <lambdabot>   a + f (b + f (c + f (d + f z)))
17:39:23 <shachaf> > foldl (\x y -> x + f y) z [a,b,c,d] -- jmcarthur: Compare.
17:39:25 <lambdabot>   z + f a + f b + f c + f d
17:39:27 <jmcarthur> i see
17:39:48 <shachaf> Expr++
17:39:53 <jmcarthur> i love expr
17:40:10 <shachaf> startling: Anyway, the nice @pling would probably be to use a map and a fold, and hope it fuses or something.
17:40:33 <jmcarthur> they should fuse, i'm pretty certain
17:40:40 * shachaf phews when he can get his code to fuse.
17:40:49 <dolio> > foldr ((+) . f) z [a,b,c,d]
17:40:51 <lambdabot>   f a + (f b + (f c + (f d + z)))
17:41:12 <shachaf> Right, with foldr's argument order it works out anyway.
17:41:21 <shachaf> I still say the fold + map is clearer.
17:41:40 <dolio> I was just curious if Expr knew about the associativity of +.
17:41:47 <jmcarthur> i think it depends on what (+) and f are
17:41:58 <jmcarthur> (in response to shachaf, not dolio)
17:42:25 <jmcarthur> > ((a + b) + c, a + (b + c))
17:42:26 <lambdabot>   (a + b + c,a + (b + c))
17:43:24 <shachaf> > compare a 0
17:43:25 <lambdabot>   GT
17:43:26 <shachaf> > compare a (-1)
17:43:27 <lambdabot>   LT
17:43:45 <ion> Someone should merge Expr and Debug.Traced. The latter can display sharing.
17:43:50 <jmcarthur> shachaf: ...
17:44:07 <shachaf> jmcarthur: It took some digging to figure out why it does it.
17:44:30 * jmcarthur is surprised Expr has an Ord instance at all
17:45:11 <jmcarthur> > join (liftA2 compare) [a,b,c]
17:45:12 <lambdabot>   [EQ,LT,LT,GT,EQ,LT,GT,GT,EQ]
17:45:30 <jmcarthur> alphabetic, it appears?
17:45:44 <shachaf> Yep.
17:45:52 <shachaf> Unless they're both integers or something like that.
17:45:54 <jmcarthur> and i guess fromInteger does something like ord
17:46:03 <jmcarthur> or perhaps toEnum
17:46:15 <jmcarthur> would have to be that, i guess
17:46:20 <jmcarthur> > toEnum 0 :: Expr
17:46:21 <lambdabot>   toEnum 0
17:46:30 <jmcarthur> > 0 :: Expr
17:46:32 <lambdabot>   0
17:46:36 <jmcarthur> oh
17:46:46 <jmcarthur> a string?
17:46:50 <jmcarthur> > 555 :: Expr
17:46:51 <lambdabot>   555
17:46:53 <shachaf> String?
17:46:54 <jmcarthur> aha
17:46:58 <shachaf> Integers are stored as special integers.
17:47:05 <jmcarthur> > compare "a" "0"
17:47:07 <lambdabot>   GT
17:47:08 <jmcarthur> > compare "a" "-1"
17:47:10 <lambdabot>   GT
17:47:13 <jmcarthur> bah
17:47:49 <jmcarthur> oh then i guess i haven't even gotten close to reverse engineering this
17:47:59 <shachaf> > (compare `on` show) a 0
17:48:01 <lambdabot>   GT
17:48:01 <shachaf> > (compare `on` show) a (-1)
17:48:03 <lambdabot>   LT
17:48:37 <shachaf> You just missed one thing. :-)
17:48:42 <jmcarthur> > show ((-1) :: Expr)
17:48:43 <lambdabot>   "negate 1"
17:48:46 <jmcarthur> lol
17:49:06 <shachaf> > compare x 0
17:49:07 <jmcarthur> > (-1) :: Expr
17:49:07 <lambdabot>   GT
17:49:08 <shachaf> > compare x (-1)
17:49:09 <lambdabot>   negate 1
17:49:09 <lambdabot>   can't find file: L.hs
17:50:45 <luite> hm, why does threadDelay not work in ghci 7.6?
17:51:21 <dmwit> works for me?
17:51:30 <luite> dmwit: does it actually sleep?
17:51:33 <dmwit> Did you forget to multiply by a million?
17:51:36 <luite> no
17:51:46 <luite> thread gets woken up here instantly
17:51:57 <shachaf> Oh, it only works for me the first time.
17:52:05 <shachaf> Hmm, no.
17:52:13 <shachaf> It works and later it stops working.
17:52:13 <luite> i suppose that is allowed, but it's not really useful if it never sleeps
17:52:22 <startling> shachaf: fair enough.
17:52:23 <dmwit> I dunno. If I just type "threadDelay 1000000" it pauses for what feels like about a second.
17:52:37 <shachaf> dmwit: It did for me at first and later it didn't.
17:52:44 <luite> i have something like let loop n = print n >> threadDelay 1000000 >> loop (n+1) in loop 1
17:52:45 <shachaf> Then I closed my ghci session so I don't know how to reproduce it.
17:52:47 <dmwit> I can't reproduce that problem.
17:52:51 <jmcarthur> works multiple times for me
17:53:02 <shachaf> Wait, no, I think I just dropped a 0.
17:53:08 <luite> and it prints one thing per second in ghci 7.4.2 (OS X), and prints without delays in 7.6.1
17:53:17 <startling> if I have a newtype over an Int16 and a C thing takes an Int16, is it safe to write the type in the binding as taking my newtype?
17:53:23 <dmwit> luite: That seems to behave the way I expect here.
17:53:28 <jmcarthur> luite: it's happily going along fine for me
17:53:37 <luite> OS X 64 bit?
17:53:39 <shachaf> Works for me too.
17:53:40 * shachaf isn't using OS X, admittedly
17:53:45 <hpc> startling: with GHC, yes
17:53:50 <hpc> but it's not specified that it will work
17:53:56 <startling> hpc: alright. thanks!
17:54:05 <jmcarthur> startling: yes, although your newtype would probably be more "correct" if it wrapped one of the CTypes
17:54:27 <Nereid> oh no, edwardk isn't here!
17:54:32 <luite> oh this is not allowd, it can resume later than after 1 second, but not earlier
17:54:40 <luite> so there's something wrong here
17:54:51 <jmcarthur> luite: bug report!
17:54:57 <startling> jmcarthur: I thought there was a specification that you can bind them with the haskell equivalents to the CWhatevers?
17:55:04 <jmcarthur> luite: i wasn't testing on os x either, btw
17:55:18 <startling> oh, it's in haskell 2010 I think
17:55:25 <luite> anyone else with OS X here? and 7.6.1?
17:55:30 <jmcarthur> startling: not as far as i'm aware, but i could be pleasantly wrong
17:55:43 * jmcarthur checks the spec
17:56:17 <jmcarthur> startling: you seem to be correct
17:56:19 <luite> oh edwardk has OS X, how many things does this print for you every second with ghci 7.6.1? loop n = print n >> threadDelay 1000000 >> loop (n+1) in loop 1
17:56:33 <startling> jmcarthur: yeah http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1540008.4 < 8.4.2
17:56:35 <jmcarthur> "Char, Int, Double, Float, and Bool as exported by the Haskell Prelude as well as Int8, Int16, Int32, Int64, Word8, Word16, Word32, Word64, Ptr a, FunPtr a, and StablePtr a, for any type a, as exported by Foreign"
17:56:37 <edwardk> one sec. on phone
17:57:31 <ion> You should have said “one sec. on IRC” to the person on phone.
17:57:58 <edwardk> i did
17:58:02 <edwardk> now i have peace and quiet
17:58:17 <Nereid> edwardk: oh, I was just wondering where you were. turns out I don't need you anymore though
17:58:19 <Nereid> :o
17:58:24 <edwardk> =P
17:59:32 <startling> edwardk: you must be proud
18:00:49 <edwardk> @hoogle threadDelay
18:00:50 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
18:00:50 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
18:00:50 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
18:02:50 <edwardk> > 49/8.0
18:02:52 <lambdabot>   6.125
18:02:56 <riverc4c> ?
18:02:56 <riverc4c> q
18:03:01 <edwardk> about 6125/second at ghci
18:03:17 <dmwit> That's too many!
18:03:21 <edwardk> ?
18:03:28 <edwardk> i may suck at counting
18:03:38 * dmwit rings the BUG REPORT bell
18:04:04 <dmwit> edwardk: It's supposed to be 1/second.
18:04:06 <edwardk> it seems comparable with -fobject-code and that in a file
18:04:09 <edwardk> interesting
18:04:14 <dmwit> So it doesn't matter much if you screwed up counting.
18:04:44 <edwardk> yeah
18:04:52 <edwardk> just looked at the def for threadDelay =)
18:05:04 <amindfv> unless you *really* suck at counting
18:05:07 <edwardk> thats a pretty grievous bug
18:05:48 <edwardk> well, i'm a bit out of it, but unless i took a 12 hour nap between seeing luite's request and offering my response, i think there is a bug ;)
18:06:09 <dmwit> haha
18:06:25 <dmwit> You didn't notice the PM switch to AM in between blinks? =P
18:06:41 <edwardk> i knew i should have included that in the log format string
18:07:02 <luite> oh it's already reported, #7299
18:08:23 <shachaf> 1-ah-ha-ha
18:08:26 <shachaf> 2-ah-ha-ha
18:08:30 <luite> bah timeout is also affected (not that i'm surprised)
18:08:39 <luite> what's another way to delay a trhead a bit?
18:09:02 <luite> blocking select call? something easier?
18:09:03 <shachaf> Busy-wait on getCurrentTime
18:09:13 <luite> no something that doesn't cook my laptop :p
18:09:20 <dmwit> system "sleep 1"
18:10:44 <dmwit> Depending on your system, that probably only has second-level precision, though.
18:11:05 <shachaf> dmwit: Depending on your "sleep", more than your "system". :-)
18:11:40 <luite> dmwit: not bad :)
18:14:39 <dmwit> shachaf: Your sleep depends on your system. =)
18:14:51 <dmwit> But yes, my wording was ambiguous.
18:15:14 <shachaf> dmwit: I'm pretty sure "system" comes from System.Process and won't affect how your "sleep" works.
18:15:31 <dmwit> I meant "system" as in "operating system".
18:22:19 <joeyh> johnw: hey, what's up?
18:23:41 <shachaf> <johnw> hi there joeyh <johnw> how stable is your git-annex master branch? <johnw> i.e., should I trust data to it? :)
18:25:24 <joeyh> hm, well I have for some years now..
18:26:08 <johnw> hello!
18:26:17 <johnw> joeyh: I just posted a bug
18:26:24 <johnw> was hoping to track it down with you
18:26:57 <johnw> I haven't used git-annex before, so running into a crash bug this early on was a bit frightening, but I'm not ready to give up yet
18:27:01 <joeyh> yugh, partial !!
18:27:20 <johnw> yeah :(
18:27:38 <johnw> sadly, I'm not able to build profiled binaries with 7.6.1 yet, so I can't get you a trace
18:27:49 <johnw> but I can try to build it with 7.4.2, that will just take a little bit of doing
18:28:20 <johnw> i've got a phone meeting now, but will you be around in the day tomorrow?
18:28:48 <joeyh> well, I try to avoid partial functions and have rather few !! and even fewer that are in ssh code and new enough to likely have a bug, so I have a pretty good idea
18:29:00 <johnw> ooh, sounds promising
18:29:03 <joeyh> namely, validateSshPubKey
18:29:15 <joeyh> hmm, maybe not
18:29:27 <johnw> oh btw, you probably don't have control over the hashing code, but this is one area that would seriously help performance
18:29:41 <johnw> it's taking many hours to git annex add one of my filesets, while 15 cores lay idle...
18:30:21 <joeyh> ah, actually, it must be the one !! in GitAnnexShell
18:30:26 <johnw> haha
18:30:28 <johnw> sounds likely
18:30:38 <joeyh> yeah, I want to parallelize add one day
18:32:13 <johnw> i'd be willing to help with that
18:32:51 <johnw> by far the fastest is to load the whole bytestring into memory, then do the algorithm in parallel over the chunks; but for truly large files, just dividing up the problem into N lazy chunks at a time still really helps
18:33:29 <johnw> or, we can just make add itself concurrent, so that you can be hashing N files at once
18:33:49 <johnw> but the hashing speed I'm seeing right now is _ridiculously_ slow
18:33:53 <joeyh> yes, that's rather what I'd prefer, although you tend to get disk bound anyway
18:33:56 <johnw> like, >1 hour for a file that's only a few gigabytes
18:34:14 <johnw> the "whole bytestring in memory" approach, with MD4, was able to achieve around 3.5 GB/s
18:34:20 <johnw> (for files on a RAM disk)
18:34:24 <joeyh> hmm, perhaps you built it on a system without sha256sum external program? It falls back to a really slow pure haskell library for portability
18:34:34 <johnw> yeah, I don't have such an external program
18:34:37 <johnw> (Mac)
18:34:43 <joeyh> well, some macs do
18:34:52 <johnw> really?
18:34:55 <joeyh> it'll be massively faster
18:35:00 <johnw> i'm on 10.8.2, with homebrew
18:35:01 <joeyh> brew or something
18:35:10 <johnw> you wouldn't know the package to install, would you?
18:35:23 <joeyh> it may be coreutils, if it's like linux
18:35:40 <johnw> ah, it's called gsha256sum
18:35:45 <joeyh> huh
18:35:59 <johnw> can I abort a git annex add in progress, and just start it again safely?
18:36:36 <joeyh> I should find a faster library than Data.Digest.Pure.SHA
18:36:37 <joeyh> yes
18:36:50 <joeyh> you'll need to recompile though, it checks at configure time
18:37:03 <johnw> ok
18:37:22 <johnw> yes, it foundi t!
18:37:42 <joeyh> the partial?
18:38:53 <johnw> no, it found sha256sum
18:39:57 <joeyh> I've only got 25 uses of !! in 30kloc, and only a couple seem likely, but I'm not seeing it
18:40:58 <byorgey> 25 uses of !! is 25 too many
18:41:00 <joeyh> what version is installed on the remote system? That's where git-annex-shell crashed
18:41:04 <joeyh> yeah
18:42:17 <dmwit> 25 uses of !! is 25 chances to prove something in Coq.
18:43:34 <joeyh> ah, I see it
18:43:35 <joeyh>         | length segments < 2 = (segments !! 0, [])
18:43:49 <augur> what are session types?
18:45:09 <byorgey> augur: a way of assigning types to *communication channels* between two parties so that they can only be used in accordance with some protocol
18:45:21 <augur> hm
18:45:38 <byorgey> it has lots of cool connections to linear logic
18:46:45 * hackagebot lenses 0.1.6 - Simple Functional Lenses  http://hackage.haskell.org/package/lenses-0.1.6 (JobVranish)
18:46:57 <shachaf> Uh-oh.
18:47:11 <edwardk> wow, i guess someone is still using that package
18:47:38 <joeyh> johnw: so, I can reproduce a crash, on the other hand I don't know how git-annex-shell is ending up being run with the mangled parameters that would lead to that
18:48:09 <joeyh> if you can reproduce it, try running with --debug and see what command it's running
18:48:26 <Nereid> ok, I'm probably just too tired to work this out now but,
18:49:33 <Nereid> I want a map indexed by some type I
18:50:09 <Nereid> I have a function I -> Int, and I want the map to be represented as an IntMap
18:50:32 <Nereid> uh let's call it IMap
18:50:39 <dmwit> Usually, IntMap a is used to represent a (sparse) function a -> Maybe Int.
18:50:45 <dmwit> Okay. =)
18:50:52 <Nereid> no no.
18:51:01 <Nereid> eh
18:51:02 <shachaf> dmwit: Int -> Maybe a?
18:51:08 <Nereid> ^
18:51:11 <dmwit> ...crap
18:51:15 <dmwit> I failed at correction.
18:51:18 <Nereid> yeah.
18:51:20 <Nereid> my point is that
18:51:34 <Nereid> I want something like that, except the index type should be I.
18:51:37 <Nereid> because I like I better than Int.
18:51:46 <shachaf> Map I Int?
18:51:46 <Nereid> so this is all fine.
18:51:54 <Nereid> no.
18:52:04 <Nereid> something that represents a sparse function I -> Maybe a.
18:52:10 <Nereid> anyway.
18:52:16 <Nereid> just doing that is easy enough.
18:53:06 <Nereid> but then I shold be able to write an instance Control.Lens.IndexedLens.At I IMap
18:53:09 <Nereid> should*
18:53:19 <Nereid> using the existing instance At Int IntMap
18:53:36 <Nereid> but I'm too tired to figure out.
18:54:36 <edwardk> Nereid: is I like an instance of Enum or something?
18:55:30 <Nereid> not really, but we may as well pretend I = Char, and use ord :: Char -> Int
18:55:50 <Nereid> so I guess it could be.
18:56:20 <edwardk> Nereid: ok, so newtype NereidMap a = NereidMap { runNereidMap :: IntMap a }; makeIso ''NereidMap to start.
18:56:35 <Nereid> I already have an iso.
18:56:43 <Nereid> oops.
18:56:47 <Nereid> not that kind of iso.
18:56:54 <Nereid> anyway, ok.
18:56:58 <edwardk> then we need to make an instance of At
18:57:15 <edwardk> the easiest way to do that is honestly to just bang it out the hard way
18:57:22 <Nereid> blah
18:57:39 <edwardk> the problem is the index type changes
18:57:46 <edwardk> so you'd need to use something to map it
18:58:23 <edwardk> hrmm
18:58:35 <edwardk> you can probably do it by hjacking the other at actually using reindex.
18:59:00 <Nereid> that's what I was hoping.
19:00:43 <edwardk> something like: at k = reindex toEnum $ from nereridMap .> at k
19:01:06 <edwardk> using the nereidMap Iso
19:01:24 <edwardk> er
19:01:33 <Nereid> what if I had an iso between I and Int?
19:01:39 <edwardk> at k = reindex toEnum $ from nereidMap .> at (fromEnum k)
19:01:43 <Nereid> instead of using toEnum and such.
19:01:59 <edwardk> then use the forward and backwards direction instead of the toEnum and fromEnum
19:02:03 <Nereid> yeah.
19:10:39 <cornihilio> hey, how do I extract the hours/minutes/seconds/milliseconds/... from a  Data.Time.Clock.DiffTime?
19:12:38 <dmwit> It's a Num, Real, RealFrac, etc.
19:12:48 <dmwit> Fractional
19:13:48 <shachaf> It would be nice if ghci printed a type when there was no Show instance.
19:14:09 <cornihilio> dmwit: what do you mean?
19:14:23 <dmwit> :t toRational
19:14:24 <lambdabot> forall a. (Real a) => a -> Rational
19:14:26 <dmwit> :t round
19:14:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
19:14:35 <dmwit> :t (*1000000)
19:14:36 <lambdabot> forall a. (Num a) => a -> a
19:14:42 <dmwit> mix well
19:15:38 <shachaf> @@ @hoogle @type fromRational . toRational
19:15:39 <lambdabot>  Unsafe.Coerce unsafeCoerce :: a -> b
19:15:40 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
19:15:40 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
19:15:55 <shachaf> unsafeCoerce is so useful.
19:16:09 <cornihilio> but... I mean I have a DiffTime... but I don't have any ints/floats/aynthing. I mean, how do I get that stuff out of it?
19:16:22 <dmwit> scroll up, read again
19:16:27 <dmwit> repeat until you have the answer =)
19:17:42 <byorgey> cornihilio: do you know about type classes?
19:19:22 <cornihilio> well I know that it is a way of classifying behavior for types
19:19:25 <strebe> byorgey: he didn't a couple days ago
19:19:32 <dmwit> byorgey++ for being less of an unhelpful jerk
19:20:02 <byorgey> cornihilio: right.  DiffTime is a type which is an instance of a lot of type classes
19:20:12 <shachaf> dmwit: Excuse me. You were a *helpful* jerk.
19:20:13 <joeyh> johnw: aha, I figured it out, a recent change introduced this bug. The real underlying bug was worse than a partial function. Fixed in git and I'll be cutting a release soon.
19:20:24 <byorgey> cornihilio: that gives you access to those behaviors/functions for DiffTime.
19:21:49 <byorgey> cornihilio: in particular it is an instance of the Real type class, which means you can use the toRational function to convert it to a Rational
19:22:02 <cornihilio> byorgey: okay, I think I get that. But when I look on hackage and I see "data DiffTime", to me that means that it's a datatype, and that I have to use something like getDays to get data out of it via recordSyntax.
19:22:32 <byorgey> cornihilio: yes, it's a data type.  but its implementation is not exported.
19:22:47 <byorgey> cornihilio: there can be other ways to get data out of something than just projection functions.
19:22:52 <byorgey> e.g. in this case toRational.
19:23:51 <YayMe> :t (liftA filter)
19:23:52 <lambdabot> forall a (f :: * -> *). (Applicative f) => f (a -> Bool) -> f ([a] -> [a])
19:27:10 <cornihilio> but if I put seconds into diffTime... how do I get out the time value? the stuff you are pointing out (like toRational) would extract the value entirely as seconds, correct? but I want to extract the hourse, minutes, seconds, etc. Do I have to do that conversion myself?
19:27:11 <YayMe> > filter (==2) [1,2,2,3]
19:27:12 <lambdabot>   [2,2]
19:27:37 <johnw> edwardk: ping
19:28:37 <cornihilio> right now I have a double representing the seconds since the epoch. I've already converted it into a diffTime because I thought that might be useful. I don't really know what to do, but I do know I want the hours/minutes/seconds out of it.
19:29:01 <johnw> joeyh: cool!  building now
19:36:31 <cornihilio> am I being stupid about this, or is this an actual problem I'm facing
19:38:00 <JuanDaugherty> you'd think somebody would make an abstraction that subsumes the competing haskell web pkgs
19:38:15 <JuanDaugherty> just because
19:42:00 <JuanDaugherty> if I were you cornihilio I'd just work with integer seconds
19:43:20 <byorgey> cornihilio: don't feel bad, the time package is notoriously difficult to navigate
19:47:38 <latro`a> > a
19:47:39 <lambdabot>   a
19:47:43 <latro`a> wat
19:47:45 <latro`a> > :t a
19:47:46 <lambdabot>   <no location info>: parse error on input `:'
19:47:47 <latro`a> er
19:47:48 <latro`a> :t a
19:47:49 <lambdabot> Expr
19:47:52 <latro`a> ....
19:47:59 <latro`a> I don't even
19:49:25 <ion> > foldr f z [a,b,c,d,e]
19:49:26 <lambdabot>   f a (f b (f c (f d (f e z))))
19:50:48 <Nereid> :t f
19:50:50 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
19:51:16 <YayMe> is there an attoparsec alternative to many1 that doesn't consume on failure?
19:52:12 <parcs`> many1 consumes on failure?
19:52:30 <YayMe> I think? or to rephrase, it appears in my usage? Though I may be using it wrnog
19:52:33 <YayMe> *wong
19:52:36 <YayMe> eff it
19:53:30 <hpaste> YayMe pasted “this consumes 2 extra characters” at http://hpaste.org/76348
19:54:02 <YayMe> I always get the first 2 characters of the string chopped off, I assume one from the many1's failure and 1 from the notchar's failure
19:54:05 <YayMe> in my hpaste
19:54:10 <YayMe> Anybody?
20:06:36 <byorgey> cornihilio: sorry, got disconnected.  I think you just have to convert seconds to hours, minutes, etc. yourself
20:06:56 <byorgey> partly because there is not really a canonical way to do it, given things like leap seconds, leap days, etc.
20:13:11 <lpvb> did the compiling change in 7.6.1? I don't get an executable anymore when I use --make
20:13:27 <geekosaur> afaik --make has no effect in 7.4 and later
20:13:44 <geekosaur> (it's the default, you have to use explicit -package arguments to get the old behavior)
20:14:02 <lpvb> so how do I make executables again?
20:14:06 <geekosaur> but 7.6.1 should give you an executable if you don;t use -c
20:14:17 <geekosaur> unless something is failing somewhere along the way
20:14:34 <lpvb> I'm not getting any executable
20:14:38 <lpvb> only an object file
20:15:06 <geekosaur> what exactly are you doing?
20:15:46 <shachaf> geekosaur: It has *some* effect, at least.
20:15:48 <shachaf> ghc: on the commandline: cannot use `--make' with `-S'
20:18:50 <lpvb> okay it works now that I left out module Main where
20:20:52 <geekosaur> odd
20:21:11 <geekosaur> or maybe not odd; the rules there are a bit convoluted IIRC
20:23:02 <JuanDaugherty> the lesson cornihilio: a lot of shit in here is off-scale whack, use your common sense
20:29:35 <YayMe> > [Just 2, Just 3, Nothing, Just 1] >>= id
20:29:36 <lambdabot>   Couldn't match expected type `[b]'
20:29:36 <lambdabot>         against inferred type `Data.Mayb...
20:30:51 <b__> can I use %~ (from Control.Lens) with Arrays?
20:30:54 <edwardk> johnw`: pong
20:30:59 <edwardk> b__: yes
20:31:01 <startling>  > [Just 2, Just 3, Nothing, Just 1] >>= (:[]) . id
20:31:04 <b__> oh what a coincidence
20:31:11 <b__> the man himself
20:31:13 <startling> > [Just 2, Just 3, Nothing, Just 1] >>= (:[]) . id
20:31:15 <lambdabot>   [Just 2,Just 3,Nothing,Just 1]
20:31:19 <startling> YayMe: ^
20:31:28 <edwardk> https://github.com/ekmett/lens/blob/master/src/Data/Array/Lens.hs provides 'ix'
20:31:46 <edwardk> ix 123 +~ 1 $ myarray
20:32:01 <edwardk> or ix 123 %~ ('x':) $ myarray, etc.
20:32:08 <YayMe> startling: thanks, but not exactly what I was trying to figure out
20:32:22 <YayMe> though it does explain it a bit..
20:32:25 <edwardk> and ixmapped %~ length $ myarray   can change out the entire array type
20:32:39 <startling> YayMe, maybe this will help? that's the same as return . id
20:32:41 <edwardk> or traverseArray can be used to edit the entire thing using monadic effects
20:32:55 <startling> YayMe: and >>= return . x is the same as fmap x
20:33:06 <edwardk> er ixmapped actually contramaps the index not the elements
20:33:20 <edwardk> you'd want traverseArray %~ length $ myarray
20:33:28 <b__> thanks :}
20:34:45 <YayMe> startling: I recall reading somewhere the concept that when you have a computation against multiple Maybes where any one is Nothing it would chop the computation short. I've assumed you have to implement this behavior yourself, but I hear such statements often enough I'm curious if such logic is implemented somewhere in the standard lib
20:35:00 <startling> YayMe: oh!
20:35:09 <startling> > Just 12 >> Nothing >> Just 12
20:35:10 <lambdabot>   Nothing
20:35:31 <startling> YayMe: you need to be using Maybe's Monad instance
20:35:37 <YayMe> that's what I was looking for
20:35:39 <shachaf> > sequence [Just 12,Nothing,Just 12]
20:35:40 <lambdabot>   Nothing
20:35:42 <YayMe> is >>= not for monads?
20:35:51 <startling> YayMe: it is, but you were using the list instance
20:35:59 <YayMe> OH
20:36:01 <YayMe> that makes sense
20:36:19 <b__> edwardk inside the State monad I have to use %= though, correct?
20:36:24 <startling> > Just 12 >>= const Nothing >>= const Just 12
20:36:25 <lambdabot>   Nothing
20:36:28 <startling> works just as well
20:36:56 <edwardk> b__: or use modify (foo %~ bar)   -- but yeah %= is the intended way to do it
20:37:13 <startling> YayMe: shachaf is right that you might also want sequence
20:37:18 <startling> if you do have a list of Maybe x
20:37:21 <YayMe> :t sequence
20:37:22 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:37:32 <YayMe> ah interesting
20:38:00 <YayMe> and yeah I think sequence has the behavior I was thinking about, so it is true though then that the standard lib has it implemented for you to stop the computation when it runs into Nothing
20:38:01 <cornihilio> is there a way to convert a difftime into a utctime?
20:38:13 <YayMe> @src Either
20:38:13 <lambdabot> Source not found. My brain just exploded
20:38:22 <startling> YayMe: yep. note that the behavior is the same in do notation
20:38:23 * YayMe feels bad for lambdabot now
20:39:06 <YayMe> sequence [[1,2,3],[4,5,6]]
20:39:18 <YayMe> > sequence [[1,2,3],[4,5,6]]
20:39:19 <lambdabot>   [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
20:39:35 <YayMe> oh right, sequence creates a cartesian product I forgot
20:40:11 <startling> YayMe: that's the Monad instance of list
20:41:25 <YayMe> startling: Right.. how long does it take y'all to memorize what the typeA implementation for dataB is?
20:43:27 <startling> YayMe: heh. you use it for a bit and it makes sense
20:43:37 <startling> I think understanding Monad intuitively helps, too
20:43:45 <YayMe> typeA <- [functor, monad, applicative, ...], dataB <- [maybe, either, list, tuple], implementationC <- [sequence, >>=, >>, ...]
20:44:06 <startling> heh
20:44:24 <startling> YayMe: oh, also, list comprehensions work using the Monad instance of list
20:44:28 <YayMe> startling: Yeah, I think intuition plays a huge role... at first I was assuming these things were just fixed obvious things
20:45:17 <YayMe> startling: Only recently have I realized it's all dependent on the implementation for that type class for that data type and that function...
20:45:35 <startling> well, (>>=) and return are the only ones that matter
20:45:43 <YayMe> for monads
20:45:44 <startling> all the others are in terms of those
20:45:45 <startling> yeah
20:45:52 <YayMe> the applicatives have there own set though
20:46:29 <chersanya> hi) why is it correct, I have no idea:
20:46:29 <chersanya> @pl charToString c = [c]
20:46:30 <lambdabot> charToString = return
20:46:48 * hackagebot digestive-functors-snap 0.5.0.1 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.5.0.1 (JasperVanDerJeugt)
20:46:50 * hackagebot digestive-functors 0.5.0.3 - A practical formlet library  http://hackage.haskell.org/package/digestive-functors-0.5.0.3 (JasperVanDerJeugt)
20:47:21 <startling> chersanya: return for lists just creates a one-element list
20:47:35 <YayMe> startling: seriously, the | and <- are not syntactic sugar in list comprehensions?
20:47:52 <startling> YayMe: they are, but <- is the same as in do notation
20:48:01 <YayMe> ah gotcha
20:48:12 <YayMe> can you use | in do notation?
20:48:13 <startling> [x | <- [1, 2, 3]] = do x <- [1, 2, 3]; return x
20:48:24 <startling> YayMe: I don't think so
20:48:24 <YayMe> oh | means return
20:48:31 <YayMe> makes sense
20:48:41 <chersanya> startling: yes, I see... but why? return is related to monads, but where are monads in that example?
20:49:00 <startling> chersanya: list is a monad.
20:50:31 <YayMe> > [x | x <- Just 3, y <- Nothing, z <- Just 4]
20:50:32 <lambdabot>   Couldn't match expected type `[t]'
20:50:32 <lambdabot>         against inferred type `Data.Mayb...
20:50:39 <startling> chersanya, [1, 2, 3] >>= \x -> [x, x + 1] == [1, 2, 2, 3, 3, 4]
20:50:47 <startling> YayMe: there's an extension you need to switch on for that
20:51:03 <startling> MonadComprehensions
20:51:14 <YayMe> > [[x] | x <- Just 3, y <- Nothing, z <- Just 4]
20:51:15 <lambdabot>   Couldn't match expected type `[t]'
20:51:15 <lambdabot>         against inferred type `Data.Mayb...
20:51:34 <startling> heh
20:51:36 <YayMe> ah I see it's because the <- is not coming from a list
20:51:38 <startling> yeah
20:51:44 <chersanya> startling: looks almost like magic, but with some logic)) thanks
20:51:48 * hackagebot digestive-functors-happstack 0.5.0.1 - Happstack backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-happstack-0.5.0.1 (JasperVanDerJeugt)
20:52:43 <startling> chersanya: it's pretty magical, yeah. :)
20:52:46 <chersanya> startling: however, there seems to be many types of monads, but how return here "knows" that list monad is used?
20:53:23 <YayMe> because list monad is handed in so it's using the >>= defined in the monad instance for list
20:53:23 <startling> chersanya, the type signature you gave it
20:53:46 <startling> chersanya: or, if you didn't give it one, whatever other functions use it
20:53:59 <startling> that could be Monad m => a -> m a
20:54:06 <startling> or it could be a -> [a]
20:54:15 <startling> or Char -> String
20:54:21 <startling> (String is a synonym for [Char[
20:54:32 <cornihilio> is there a way to convert a difftime into a utctime?
20:54:40 <YayMe> startling: what set's a "monad" apart from a "functor" ?
20:54:50 <YayMe> I know a monad is a functor (right?)
20:54:56 <chersanya> startling: yes, now I see)) because just let f = return in ghci gives error
20:55:05 <startling> YayMe: in monads, you can take the item out and put it back in with monadic effects
20:55:37 <YayMe> startling: How is that different from a functor that takes the value out and applies f to it then puts it back in?
20:55:47 <YayMe> startling: Or do functors do the execution inside the context never taking it out?
20:55:53 <startling> YayMe: yes
20:55:57 <YayMe> ah
20:56:03 <startling> > fmap (Just) [1, 2, 3]
20:56:05 <lambdabot>   [Just 1,Just 2,Just 3]
20:56:18 <startling> errr
20:56:28 <startling> > fmap (:[]) [1, 2, 3]
20:56:29 <lambdabot>   [[1],[2],[3]]
20:56:40 <startling> > [1, 2, 3] >>= (:[])
20:56:41 <lambdabot>   [1,2,3]
20:56:44 <Nereid> > fmap return [1,2,3]
20:56:45 <lambdabot>   No instance for (GHC.Show.Show (m a))
20:56:45 <lambdabot>    arising from a use of `M3752429476...
20:56:47 <Nereid> aw.
20:57:04 <YayMe> haha now I wonder what it actually did
20:57:04 <Nereid> > [1,2,3] >>= return
20:57:05 <lambdabot>   [1,2,3]
20:57:14 <startling> YayMe: see, using the Monad things, it concatenates the output
20:57:24 <YayMe> startling: Right, gotcha
20:57:33 <startling> see also
20:57:41 <startling> > fmap Just (Just 12)
20:57:42 <lambdabot>   Just (Just 12)
20:57:48 <startling> > Just 12 >>= Just
20:57:49 <lambdabot>   Just 12
20:57:54 <YayMe> right
20:58:28 <startling> YayMe: the other thing is that functors don't need to have return
20:58:37 <YayMe> startling: that's why monad's feel like side effects- they're acting practically inside of your current context
20:59:17 <startling> YayMe: yep
20:59:40 <YayMe> Which is how they allow imperative style do notation, if do notation were done like a functor the results would just be presented as a tree of a computation rather than as the result of the computation
21:00:01 <startling> right
21:00:56 <YayMe> > [Just 1,Just 2,Just 3] >>= \x -> x+x
21:00:57 <lambdabot>   Couldn't match expected type `[b]'
21:00:57 <lambdabot>         against inferred type `Data.Mayb...
21:01:13 <startling> YayMe: you're mixing them again
21:01:25 <YayMe> > [Just 1, Just 2] >>= id >>= \x -> x+x
21:01:26 <lambdabot>   Couldn't match expected type `[a]'
21:01:26 <lambdabot>         against inferred type `Data.Mayb...
21:01:35 <YayMe> heh
21:02:42 <YayMe> I know I'm mixing them, trying to see how to flatten out 2 different types of monads
21:02:56 <YayMe> :t liftM
21:02:57 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:03:42 <YayMe> > [Just 1, Just 2] >>= liftM (\x -> x+x)
21:03:43 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t'
21:03:43 <lambdabot>         against inferred ...
21:04:09 <shachaf> "flatten out" doesn't make sense, and there are no "types of monads" here, just monads.
21:04:49 <startling> YayMe: that's what monad trasnformers are for
21:04:58 <YayMe> [[[1]],[[2]]] >>= return
21:05:10 <YayMe> > startling:
21:05:11 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
21:05:32 <startling> @info MaybeT
21:05:32 <lambdabot> MaybeT
21:05:45 <YayMe> startling: interesting, thanks I have wondered what monad transformers referred to for a while now
21:05:58 <shachaf> startling: It's unlikely that "monad transformers" are the answers to YayMe's question.
21:06:08 <shachaf> s/are/is/
21:06:11 <shachaf> Whatever YayMe is asking.
21:06:36 <startling> shachaf: he's asking how you would combine the list monad and the maybe monad
21:06:45 <startling> though I admit he seems a little confused
21:07:37 <startling> shachaf: what's wrong with "monad transformers", btw? or are you just quoting for the sake of quoting?
21:08:11 <shachaf> startling: Nothing's wrong with that phrase. I just don't think it's the answer.
21:09:06 <startling> shachaf: k.
21:12:03 <startling> API design question for my curses library: should I make programs that use 256 colors a separate type from programs that use only the ANSI colors?
21:12:59 <startling> maybe I should have an ansi color class and then have the 256-color type be an instance of it.
21:14:38 <YayMe> can you have separate data type where both data types implement the same type class that for ANSI colors gives closest cousin to it's 256 color counterpart?
21:14:55 <startling> YayMe: that's what I'm thinking
21:16:31 <YayMe> you could make it simpler by handling the 2 types internally based on a switch and present the API consumer with one type and they flip the switch based on which they wish to use. Makes the consumer's job of porting back and forth easier
21:16:56 <johnw`> edwardk: ping!
21:17:22 <edwardk> pong again =)
21:17:24 <Luke3> liftM2 (&&) (all $ not . isAlpha) ((< 10) . length) -- what monad is (&&) being lifted to in this case?
21:17:26 <johnw`> yay
21:18:25 <startling> Luke3: ((->) a), i think
21:18:56 <startling> :t liftM2 (&&) (== 1) (== 2)
21:18:57 <lambdabot> forall a. (Num a) => a -> Bool
21:18:59 <Luke3> where is that instance defined?
21:19:14 <startling> @src Monad ((->) a)
21:19:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
21:19:21 <Luke3> especially since I'm not importing it explicitly
21:19:25 <startling> Luke3: control.monad.reader, I think
21:19:48 <Luke3> startling: i'm not importing that though and it compiles
21:19:49 <startling> oh nope, that's MonadReader
21:19:59 <startling> Luke3: http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/Control-Monad-Instances.html
21:20:09 <startling> Luke3: instances are contagious
21:20:53 <Luke3> startling: but if i'm not importing that, how is it coming in?
21:21:02 <lpvb> how would I do this:
21:21:04 <lpvb> :: a -> [a -> m ()] -> m ()
21:21:05 <startling> Luke3: something you import imports it
21:21:15 <startling> Luke3: instances are imported implicitly
21:21:16 <lpvb> I want to supply a to every function in the list
21:21:33 <startling> :t mapM ($ 12)
21:21:34 <lambdabot> forall a (m :: * -> *) b. (Num a, Monad m) => [a -> m b] -> m [b]
21:21:46 <startling> :t mapM . flip ($)
21:21:47 <lambdabot> forall (m :: * -> *) b a. (Monad m) => a -> [a -> m b] -> m [b]
21:21:57 <Luke3> thanks
21:22:01 <lpvb> thanks
21:22:53 <startling> > ((&&) <$> (> 10) <*> (< 20)) 15
21:22:54 <lambdabot>   True
21:23:02 <startling> neat, never thought about that
21:29:51 <test1232123> putStrLn "test"
21:37:01 <meiji11> hi. I'd like to generate random numbers continually, until I get one that satisfies a predicate. I figured that a natural model for this would be to define a state monad encapsulating random s, that feeds the seed of random s back to itself (via the state monad) until the condition is satisfied.
21:37:15 <meiji11> I'm wondering if this is a valid excuse to use MonadFix, as well..
21:37:55 <shachaf> Why not just dropWhile an infinite list?
21:38:07 <shachaf> Or filter or something.
21:38:36 <meiji11> shachaf, i suppose, yeah, but that would break my habit of coming up with convoluted excuses to learn the more esoteric bits of haskell
21:40:34 <KBme> hi
21:41:20 <meiji11> if anyone could direct me to some MonadFix examples in any setting, I'd be grateful, heh
21:41:42 <shachaf> meiji11: The paper that introduced MonadFix is probably good.
21:42:09 <hpaste> KBme pasted “trying to install testpack” at http://hpaste.org/76354
21:42:25 <KBme> I can't get testpack to install, the last three versions give me errors…
21:42:48 <dolio> meiji11: Look up frisby.
21:43:26 <startling> meiji11: wrt randomness, StdGen in System.Random is nice
21:43:37 <startling> you can stick it in a state if you like
21:46:54 <KBme> also, if one has a patch against a cabal package, can on stick it into one's openings?
21:48:08 <meiji11> startling: right, I want to feed g' back into the state, where I have something like State $ \s -> let (a,g') = random s in (if ... )
21:48:25 <meiji11> hmm, DoRec..
21:49:29 <tac> Just checking, but "let fibs = 1 : 1 : zipWith (+) fibs (tail fibs)" isn't a primitively corecursive definition, is it?
21:49:50 <YayMe> startling: Got a moment?
21:50:25 <startling> YayMe: sure
21:51:38 <YayMe> startling: You spoke of monad transformers, I actually have this piece of code I've been playing with I have a data Code = Comment a | Block [Code a] | Unidentified a
21:52:09 <YayMe> startling: Would a monad transformer be how i traverse deeply the Block [Code a]
21:52:10 <cornihilio> is there something like "truncate" for numbers that are Doubles and not Integrals?
21:52:39 <startling> YayMe: not really
21:52:59 <glguy> :t truncate
21:53:00 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
21:53:14 <startling> YayMe: you'd just write fmap et al that call themselves recursively
21:53:15 <glguy> cornihilio: the "Integral" constraint is on the result, not the input
21:53:22 <ihm> gahh hackage is down
21:53:33 <YayMe> startling: So I would implement functor for it?
21:53:47 <YayMe> That makes sense
21:53:58 <startling> YayMe: well, assuming it was actually data Code a =...
21:54:03 <YayMe> the current method I recursed the structure was.. not the best
21:54:31 <cornihilio> glguy: how do I apply that constraint to the result?
21:54:51 <glguy> > truncate (2.5 :: Double)
21:54:52 <lambdabot>   2
21:55:22 <YayMe> startling: Thanks!
21:55:30 <YayMe> Night for now, getting late
22:01:32 <cornihilio> glguy: that's not working for me though: https://gist.github.com/3897300
22:01:51 <cornihilio> I feel like your example is pretty simple, so I have no clue what i am screwing up
22:02:33 * lispy waves at teh glguy 
22:02:50 <lispy> oh, hackage is down? /me goes to check
22:03:08 <lispy> ihm: I can get to the package list
22:03:11 <glguy> cornihilio: You omitted too much
22:03:13 <lispy> ihm: what isn't working?
22:03:15 <glguy> hackage seems back, fyi
22:03:27 <glguy> cornihilio: in your paste that, is
22:03:44 <lispy> > truncate 2.5
22:03:45 <lambdabot>   2
22:03:53 <ihm> ya back up now
22:04:08 <lispy> :t 2.5
22:04:09 <lambdabot> forall t. (Fractional t) => t
22:04:21 <lispy> ah, right so I guess the ".5" implies Fractional
22:04:41 <ihm> :t truncate
22:04:43 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
22:04:59 <lispy> It probably works in lambdabot due to defaulting
22:06:20 <lispy> has anyone here tried to get the 64bit and 32bit windows GHCs to coexist?
22:06:58 <cornihilio> glguy: do you mean the whole function https://gist.github.com/3897308 or my entire file?
22:07:28 <b__> is there a performance difference between rem and mod?
22:07:42 <glguy> cornihilio: timeMinutes = time' - (timeHours * 60 * 60)
22:07:55 <glguy> Here timeHours is an Integral, but time' is a Double
22:07:58 <lispy> b__: have you used criterion before?
22:08:06 <lispy> b__: it would be perfect for answering this question
22:08:17 <b__> I will go try it, thanks :}
22:09:10 <glguy> to make timeHours a double again you can use "fromIntegral"
22:09:12 <lispy> ihm: did hackage go down again?
22:09:17 <ihm> http://www.downforeveryoneorjustme.com/http://hackage.haskell.org/
22:09:20 <ihm> far as i can tell
22:09:27 <ihm> wait
22:09:30 <ihm> now it's back up!
22:10:08 <cornihilio> glguy: ah, thank you! I think I'm starting to get typeclasses :)
22:10:10 <lispy> and it's down again...
22:10:12 <lispy> Something is wrong
22:12:13 <lispy> cornihilio: Good luck. The numeric type classes work, but their design isn't obvious (or optimal).
22:12:49 <ezyang> oh hackage, stop flaking
22:13:07 <shachaf> More like flackage.
22:15:28 <cornihilio> what function do I use for taking a subsequence of a string at a certain point?
22:15:49 <ezyang> @hoogle Int -> [a] -> ([a],[a])
22:15:50 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
22:15:50 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
22:15:50 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
22:16:50 <Nereid> or some combination of drop and take
22:17:04 <jfischoff> I'm trying to come up with a testing strategy for Template Haskell. Would it reasonable (possible) to mock the Q monad with my own Quasi as a testing strategy?
22:17:04 <lambdabot> jfischoff: You have 1 new message. '/msg lambdabot @messages' to read it.
22:17:16 <jfischoff> @messages
22:17:16 <lambdabot> edwardk said 21h 32s ago: substType m (ForallT bs ctx ty) = ForallT bs (substType m' ctx) (substType m' ty) where m' = foldrOf typeVars Map.delete m bs
22:18:08 <jfischoff> cleaner than the TYB version I do say
22:18:46 <jfischoff> are unit tests being written for TH code?
22:19:08 <Geofff> wga
22:19:26 <Geofff> what is haskel programming language?
22:19:37 <jfischoff> @faq
22:19:37 <lambdabot> The answer is: Yes! Haskell can do that.
22:19:40 <jfischoff> hmm
22:19:48 <jfischoff> @where faq
22:19:48 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
22:19:59 <jfischoff> Geoff: ^
22:21:40 <Geofff> oh i c
22:26:31 <lispy> jfischoff: if you were using a free monad you could capture the code and test it
22:26:41 <lispy> jfischoff: But, I've never tried to test TH code
22:26:50 <jfischoff> me either
22:27:18 <lispy> just use Agda to write your TH code, prove it correct and then you're done ;)
22:27:45 <jfischoff> if I had the five years to spend on it I would love to :)
22:28:43 <lispy> jfischoff: Is it possible to separate it into pure code that is called from inside the Q monad so that you increase how much is tested?
22:29:04 <lispy> Basically, separate out the computation and so that the "trusted but untested" Q monad code is trivial?
22:29:16 <jfischoff> almost all of it is in the Q monad to get fresh names
22:29:40 <jfischoff> but it is a possiblity
22:29:43 <jfischoff> hmm
22:30:01 <lispy> I guess your proofs would then be "assuming a fresh name mechanism..."
22:30:09 <jfischoff> I think I make a Quasi monad that could work sort of like Q.
22:30:10 <jfischoff> yeah
22:30:51 <jfischoff> I'm surprised there isn't a TestQ where you put in an environment
22:30:54 <lispy> What I find unsatisfying about making your own Quasi monad is that if you add a lot of smarts to it you spend a lot of time developing a test framework that may have its own bugs
22:31:03 <jfischoff> no doubt
22:31:29 <lispy> Contributing a TestQ monad might be a nice thing for everyone
22:31:39 <jfischoff> That's what I was thinking
22:31:49 <lispy> But again, I don't know of anyone writing QC properties or hunits for TH code
22:32:04 <jfischoff> although if you look at my history of contributing code ...
22:32:15 <jfischoff> yeah I haven't seen any
22:32:41 <cornihilio> can you have multiple where's in a single function?
22:32:44 <lispy> edwardk: Would you use a TH testing facility for your packages if it existed?
22:32:58 <jfischoff> actually I find the flakiness of TH code to be very problematic
22:33:16 <lispy> cornihilio: you can have multiple bindings in one where clause and those bindings can have where clauses insidet hem.
22:34:12 <jfischoff> The limitations of most deriving mechanism are really made explicit. They work and then suddenly you type syn and smash too bad
22:34:27 <jfischoff> err
22:34:35 <KBme> what's syn?
22:34:35 <jfischoff> are rarely made explicit I mean
22:34:36 <cornihilio> this is my code atm: https://gist.github.com/3897369 with the problem area
22:34:55 <cornihilio> I don't think I can put a where in a where, because my function code is handling the case statement for the result from the where
22:34:58 <jfischoff> type synonym
22:35:07 <KBme> ahh
22:35:10 <jfischoff> > type Name = Stirng
22:35:11 <lambdabot>   <no location info>: parse error on input `type'
22:35:14 <jfischoff> ;p
22:35:30 <KBme> ☺
22:36:07 <jfischoff> more people writing TH need to know about this http://hackage.haskell.org/package/th-expand-syns
22:36:38 <jfischoff> or just handle the case but I digress...
22:37:01 <lispy> cornihilio: "if b == False" you can simplify that to "if not b"
22:37:42 <dylukes> or just "if b", and switch the then/else clauses around.
22:38:11 <dylukes> better yet rewrite it as
22:38:20 <dylukes> findHeader (if b then 0 else 24) contents
22:38:44 <Nereid> or pattern match on contents'
22:38:56 <dylukes> We're talking about line 14.
22:38:59 <Nereid> oh.
22:39:52 <lispy> cornihilio: Okay. I stared at it a bit, but I'm not understanding what you want to change/add.
22:40:22 <cornihilio> I don't know what to do with this part  (set', toPrint) <- handlePacket packet set
22:41:11 <cornihilio> because that causes an error
22:41:23 <Nereid> what sort of error?
22:41:43 <cornihilio> https://gist.github.com/3897382
22:41:44 <Nereid> protip: when pasting code with an error, include the error message with it.
22:41:48 <dylukes> We also can't see handleError.
22:41:48 <Nereid> yeah.
22:41:50 <cornihilio> sorry, should have pasted it ealier
22:41:53 <cornihilio> earlier
22:42:12 <Nereid> well, check the type of handlePacket
22:42:29 <cornihilio> handlePacket :: PacketRaw -> DS.Set PacketRaw -> (DS.Set PacketRaw, [PacketRaw])
22:42:32 <Nereid> maybe you want let ... = ... instead of ... <- ...
22:42:34 <Nereid> yep
22:42:49 <Nereid> the thing on the right of <- has to be an IO action
22:42:59 <cornihilio> Nereid: ah, okay
22:43:06 <cornihilio> but changing to = doesn't help
22:43:17 <lispy> "let foo = bar"
22:44:30 <lispy> cornihilio: https://en.wikibooks.org/wiki/Haskell/do_Notation
22:44:35 <lispy> cornihilio: search for "nameDo"
22:44:45 <cornihilio> but now I have this: https://gist.github.com/3897394
22:45:07 <cornihilio> lispy: okay, I will read that. I know I'm misunderstanding something pretty basics, but I just don't know what.
22:46:06 <lispy> cornihilio: this problem is essentially the name as the last
22:46:29 <lispy> cornihilio: Well, I guess it depends on the type of printPacketRaw
22:46:47 <lispy> cornihilio: i'm going to go out on a limb and say you will probably want mapM_
22:46:48 <cornihilio> printPacketRaw :: PacketRaw -> IO ()
22:46:57 <lispy> :t mapM_
22:46:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
22:47:15 <lispy> So, a = PacketRaw, and m = IO
22:47:45 <cornihilio> lispy: yep, I mapM_ is what I needed. Thank you for pointing that out!
22:48:29 <lispy> yw
22:49:57 <ivanm> when using FFI, does foreign import require that I only return Ptr values?
22:50:11 <ivanm> because otherwise I keep getting "unacceptable result type in foreign declaration" errors :s
22:51:43 <lispy> ivanm: Example?
22:51:53 <lispy> ivanm: IO CInt is a valid return type
22:52:10 <dylukes> you can also use unsafe if you're reaaaaaaly sure
22:52:22 <ivanm> I'm trying to do ` foreign import ccall unsafe "test" c_test :: Ptr DangD -> IO SGraph" (where DangD and SGraph are Storable instances)
22:52:39 <ivanm> if I change it to "IO (Ptr SGraph)" it accepts it
22:52:55 <ivanm> dylukes: I already mention unsafe in my foreign import statement
22:52:58 <dylukes> What's the C function signature?
22:53:26 <ivanm> GRAPH test(DANGD *dd)
22:53:46 * ivanm is just trying to blindly work this out via RWH and online examples
22:53:54 <rwbarton> what is GRAPH?
22:55:05 <ivanm> a custom type I defined
22:55:14 <rwbarton> i mean it is a typedef for something I presume
22:55:15 <lispy> ivanm: a struct?
22:55:18 <rwbarton> is it a struct or what
22:55:20 <ivanm> lispy: yeah
22:55:31 <ivanm> typedef'd struct
22:55:53 <lispy> typically in C you'd take a return value like that as a pointer argument
22:56:21 <lispy> I wonder if this is an FFI limitation
22:56:49 <ivanm> lispy: so I'd want to return a GRAPH* rather than a GRAPH?
22:57:05 * ivanm is trying to avoid altering the input value so that it can be used with criterion without multiple poke invocations
22:57:41 <lispy> ivanm: GRAPH test(DANGD *dd) --> void test(DANGD *dd, GRAPH *output)
22:57:53 <shachaf> Well, it depends on the definition of GRAPH.
22:57:54 <ivanm> oh
22:58:35 <ivanm> DANGD has a pointer to a GRAPH in it; I want to return a copy of it though rather than modifying the original
22:59:37 <rwbarton> I don't see how that is relevant
22:59:49 <rwbarton> you can perform lispy's substitution mechanically
23:00:01 <rwbarton> void test2(DANGD *dd, GRAPH *output) { *output = test(dd); }
23:00:18 <edwardk> lispy: honestly? probably not. the issue is i don't want to pay for it in my compile times
23:00:40 <edwardk> that is if you mean using template haskell to generate my test code
23:00:52 <edwardk> if you mean ability to test template haskell code, that'd be trickier
23:01:04 <lispy> "Moreover, the result type rt produced by frtype must be a marshallable foreign result type; that is, it is either a marshallable foreign type, the type (), or a type matching Prelude.IO t, where t is a marshallable foreign type or ()."
23:01:14 <lispy> ivanm: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-100003
23:01:34 <lispy> ivanm: Section 3.2 says which types are marshallable for this discussion and it doesn't include Storable instances-
23:02:05 <lispy> edwardk: ability to test template haskell code
23:02:08 <edwardk> lispy, ivanm: you could always finish fleshing out my little 'foreign' lib if you want to get more ;)
23:02:15 <ivanm> edwardk: heh, no
23:02:25 <ivanm> I've wasted enough time on this just to shut my supervisor up
23:02:29 <edwardk> that hooks into libffi directly
23:02:41 <edwardk> and lets you deal with structs and things the ghc ffi can't do
23:02:49 <ivanm> lispy: OK, that makes more sense then
23:03:15 <ivanm> so, how do I compile my .c file so that ghci can find it? :/
23:03:15 <edwardk> i started it because i needed it for working with objective-c, and then i lost the need to work with objective-c
23:03:28 <edwardk> ivanm: you're using cabal?
23:03:30 <thelopa> I've got a question about parMap. Anyone familiar with it?
23:03:38 <ivanm> edwardk: eventually; just trying to get it to work for now
23:03:43 <lispy> ivanm: You could feed the .c file to ghci
23:03:44 <edwardk> thelopa: ask away. enough of us know how to use it ;)
23:03:50 <lispy> IIRC, that works anyway
23:03:59 <edwardk> ivanm: i ask because through cabal is the way i know how to get it working =P
23:04:05 <ivanm> lispy: how? specifically, when I'm just loading/reloading files within the emacs interface :)
23:04:08 <ivanm> edwardk: heh
23:04:28 <ivanm> I'm guessing it wants me to compile an object file, but "gcc foo.c" seems to want a main method
23:04:30 <lispy> ivanm: I don't know. I don't use emacs for that :(
23:04:37 <lispy> ivanm: -c
23:04:58 <edwardk> fyi you can pass ghc c source files too
23:05:00 <lispy> -c means "compile" as contrasted with "compile and link an executable"
23:05:13 <ivanm> wait, maybe it's because the .c and .h files have different names
23:05:25 <ivanm> since hsc2hs didn't seem to like camelCase :s
23:06:07 <KBme> anyone here able to cabal install testpack?
23:06:25 <ivanm> edwardk: how do you do it in Cabal then (because I _will_ need to do that)?
23:07:27 <edwardk> ivanm: c-sources: foo.c
23:07:36 <edwardk> ivanm: its terribly difficult ;)
23:07:40 <ivanm> heh
23:07:46 <edwardk> https://github.com/ekmett/rounding/blob/master/rounding.cabal#L19
23:07:54 <ivanm> no need to mention .h files?
23:08:01 <edwardk> and extra-source-files: foo.h for the header files, etc.
23:08:08 <edwardk> so they get bundled when you ship it to hackage
23:08:13 <ivanm> what about dealing with hsc2hs?
23:08:18 <thelopa> I don't understand what ghc is complaining about. I have a line that says parMap rdeepseq fun [1..1000000] and ghc complains about the 1..1000000 part
23:08:29 <lispy> ivanm: cabal does that part automagically based on file extension
23:08:30 <thelopa> it works for normal map, btw
23:08:35 <ivanm> edwardk: you might want to update your homepage there though, if you're using github for everything...
23:08:44 <edwardk> just name the module like normal, when it sees a .hsc file it does the right thing iirc
23:08:57 <edwardk> in that package https://github.com/ekmett/rounding/blob/master/Numeric/Rounding.hsc is built with hsc
23:09:16 <dcoutts> thelopa: you'll have to tell us what the complaint it, we can't guess
23:09:43 <edwardk> rounding will probably never see another release. its horribly buggy. and if its not deprecated on hackage should be
23:09:59 <edwardk> it runs afoul of lots of drepper-style wontfix bugs in libm
23:10:31 <thelopa> dcoutts: fair enough. I didn't want to dump a huge wall of type error on everyone. It says this: Ambiguous type variable `a0' in the constraints:       (Enum a0)         arising from the arithmetic sequence `1 .. 1000000'         at pr14.hs:37:43-54       (Integral a0)         arising from a use of `chainLengthTuple' at pr14.hs:37:26-41       (Num a0) arising from the literal `1' at pr14.hs:37:44       (Show a0) arising from a use
23:11:09 <edwardk> assuming i wanted to figure out how to link haskell with crlibm or something portably it could be salvaged, but i'm gambling that copumpkin and i can get mpfr linking properly with ghci to fix up my 'rounded' package and never have to think about this one again
23:11:20 <ivanm> lispy: how do I feed the .c file to ghci?
23:11:22 <edwardk> it was just the only thing i had that had hsc2hs and c-sources and was simple
23:11:25 <thelopa> the line is print (parMap rdeepseq chainLengthTuple [1..1000000])
23:11:28 <lispy> thelopa: in that case, hpaste.org is a good place to dump stuff and then give us the URL
23:11:31 <ivanm> it complains that it isn't a module name or source file when I try :s
23:11:31 <copumpkin> we just need to get me to stop wasting time on skew-binary naturals
23:11:36 <copumpkin> and other shit like study
23:11:46 <edwardk> yeah. ditch that studying stuff
23:11:58 <edwardk> finish the skew binary stuff. i want that for a paper ;)
23:12:24 <copumpkin> :P
23:12:24 <lispy> ivanm: I was hoping it was smart like ghc. Maybe ghci doesn't accept .c files.
23:12:31 <copumpkin> it's tricky!
23:12:42 <hpaste> thelopa pasted “Project Euler problem 14” at http://hpaste.org/76357
23:12:44 <copumpkin> now that I have a clean representation for the numbers themselves, I need to prove that they're unique
23:12:47 <edwardk> so are our ghci linking issues. =P
23:12:51 <ivanm> :(
23:12:54 <efie> could someone help me with this?: http://hpaste.org/76356
23:12:56 <copumpkin> fucking tricky problems
23:12:58 <copumpkin> they're too fun to solve
23:13:03 <dcoutts> ivanm: you pass the .o file to ghci
23:13:06 <lispy> thelopa: it doesn't know that you mean Int or Integer or what have you. Try something like [1..10::Integer]
23:13:08 <ivanm> dcoutts: ahhhh
23:13:31 <thelopa> lispy: thanks, I'll try that
23:13:35 <ivanm> dcoutts: can ghci automatically find the .o file when trying to use FFI? or do I _have_ to pass the .o file in?
23:14:01 <thelopa> lispy: that did it! Thanks a bunch
23:14:04 <dcoutts> ivanm: no it can't find them, there's nothing that indicates what lib or .o file
23:14:34 <ivanm> so if I'm trying to manually play with FFI, I have to explicitly load the .o file in to ghci? :(
23:14:50 <lispy> ivanm: pass it on the command line
23:15:00 <dcoutts> thelopa: note that parMap on a list that long isn't going to get you much parallelism. Remember that there's a fixed size spark pool (usually 4k). So you should look at some other strategy that limits the number of sparks.
23:15:00 <lispy> ivanm: stop running ghci from inside emacs :)
23:15:11 <ivanm> lispy: yeah, but then I still need to quit ghci every time I change the .c file and recompile
23:15:31 <dcoutts> thelopa: making 100,000 sparks at once just means that you'll get 4000 of them, and waste all the others.
23:15:34 <lispy> C-d
23:15:50 <ivanm> yes, I know that will quit ghci for me :)
23:15:58 <lispy> ivanm: :)
23:16:01 <ivanm> but I can't just do :r !
23:16:19 <thelopa> dcoutts: I'm sort of new to parallel haskell. Is there a site you found helpful?
23:16:43 <thelopa> dcoutts: I'm not exactly sure what I'm doing
23:16:58 <lispy> ivanm: you can make a script for ghci to import the modules. Since you can reset the command line parameters, you might be able to make a command to reload your .o file, but UNTESTED.
23:17:26 <ivanm> what do you mean by reset the command line parameters?
23:17:45 <solrize> i didn't know about the 4000 sparks, i thought they were super lightweight and you could make tons of them
23:19:46 <dcoutts> thelopa: there's some links from here http://www.haskell.org/haskellwiki/Parallelism
23:19:47 <lispy> ivanm: :set <option> ...           set options
23:19:58 <ivanm> oh, great, my net is playing up again.....
23:19:59 <lispy> ivanm: this may only apply to System.getArgs
23:20:18 <solrize> efie, http://www.haskellforall.com/2012/07/errors-10-simplified-error-handling.html
23:20:46 <ivanm> lispy: did my question about command line parameters come up?
23:20:50 <ivanm> my net doesn't seem to like me atm :s
23:21:00 <thelopa> dcoutts: thanks. I'll read over that
23:21:41 <lispy> ivanm: yes, and it turns out that I guess you can only set what is seen by System.getArgs inside the ghci session
23:21:48 <ivanm> heh
23:22:20 <ivanm> so.... I'm pretty much limited to explicitly quitting and re-starting ghci any time I change the .c or .hs files?
23:22:25 <ivanm> hooray :s
23:22:30 <dcoutts> thelopa: and more stuff at http://www.haskell.org/haskellwiki/Parallel/Reading
23:22:52 <solrize> ivanm use :l or :r
23:23:03 <lispy> ivanm: yes, but like I said you can make a script for ghci so that you really just lose the time to hit C-d <press up> <press enter>
23:23:06 <ivanm> solrize: for .o files as well?
23:23:18 <ivanm> lispy: just a bash script you mean?
23:23:20 <solrize> you may have to delete the .hi's for that
23:23:27 <lispy> ivanm: no, ghci is scriptable
23:23:51 <ivanm> sure, you can have a .ghci file
23:24:04 <ivanm> but I can't see anything in there that would let me load a .o file :s
23:24:30 <ivanm> oh, you mean :set args <blah> ?
23:24:33 <lispy> ivanm: my point was that you can write a script that gets you back to your "experiment" state. Then you just have to hit 3 keys to reload.
23:25:14 <lispy> ivanm: :set args is just what is returned by System.getArgs.
23:25:20 <lispy> ivanm: so not actually useful here.
23:25:21 <ivanm> oh, duh, misread
23:25:40 <lispy> good luck
23:25:42 * lispy goes to bed
23:25:47 <ivanm> heh
23:25:49 <ivanm> g'night lispy
23:27:18 * ivanm goes with the "write a bash script to re-compile stuff and load ghci" option
23:30:36 <efie> slorize: thanks
23:39:30 <b__> I always get "Atkin.hs|13 col 19 warning| Defaulting the following constraint(s) to type `Integer'" when using ^
23:39:36 <b__> is there a way around this?
23:40:00 <shachaf> Give an explicit Integer signature somewhere?
23:40:26 <b__> hm yes but I use it in a function like 5 times
23:40:44 <mm_freak> hackage down?
23:48:17 <monochrom> hrm, yes
