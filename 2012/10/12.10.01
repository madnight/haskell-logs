00:02:42 <Jupiter123> which book is the best way to learn Haskell
00:02:54 <latro`a> probably LYAH
00:03:15 <Jupiter123> any more
00:03:22 <ivanm> there's Hutton's book
00:03:26 <ivanm> YAHT
00:03:27 <Jupiter123> ok
00:03:28 <ivanm> wikibook
00:03:35 <ivanm> RWH if you already have programming experience
00:04:23 <Jupiter123> ok
00:04:32 <Jupiter123> yaht. what is that
00:04:39 <latro`a> yet another haskell tutorial
00:04:39 <mracrrot> ivanm: Thanks. Now it loads!
00:04:41 <latro`a> (the actual title)
00:04:57 <ivanm> @where tutorials
00:04:57 <lambdabot> http://haskell.org/haskellwiki/Tutorials
00:05:00 <ivanm> @where wikiboo
00:05:01 <lambdabot> I know nothing about wikiboo.
00:05:02 <ivanm> @where wikibook
00:05:02 <lambdabot> http://en.wikibooks.org/wiki/Haskell
00:05:04 <ivanm> @where yaht
00:05:04 <lambdabot> "Yet Another Haskell Tutorial", Hal Daume III,<http://www.cs.utah.edu/~hal/htut/>,<http://en.wikibooks.org/wiki/Haskell/YAHT>,<http://hal3.name/docs/daume02yaht.p(df|s)>,<http://darcs.haskell.org/
00:05:04 <lambdabot> yaht/yaht.p(df|s)>
00:05:07 <ivanm> @where lyah
00:05:07 <lambdabot> http://www.learnyouahaskell.com/
00:05:09 <Jupiter123> Oh that great
00:05:10 <ivanm> @where rwh
00:05:10 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
00:05:54 <Jupiter123> I am from procedural language. and found it bit hard to come to the terms so asking help on books
00:06:52 <Jupiter123> I hope I could learn this haskell, because It looks so interesting for me right now
00:07:34 <m3ga> @lyah
00:07:35 <lambdabot> Unknown command, try @list
00:07:47 <m3ga> @where lyah
00:07:47 <lambdabot> http://www.learnyouahaskell.com/
00:07:53 <Jupiter123> ok
00:07:57 <m3ga> Jupiter123: ^^^^^^^^
00:08:22 <ivanm> m3ga: already done that
00:08:28 <ivanm> keep up! ;)
00:09:13 <Jupiter123> I would trouble you all if I don't understand
00:09:14 <Jupiter123> :)
00:10:26 <m3ga> sure, lot of people here can help
00:10:47 <Jupiter123> thanks
00:10:49 <m3ga> ivan: yes, now it sse it
00:11:04 <Jupiter123> I wanted to create a simple web app. so prior to that I wanted to learn the language very quick
00:11:20 <Jupiter123> I am not sure how long I will take, hope you guys would help the path make easy
00:11:27 <ivanm> Jupiter123: Yesod has its own book that has kinda a Haskell tutorial in it
00:11:33 <ivanm> but it does assume you know web development
00:11:41 <ivanm> (which is why I can't follow along all that well :p)
00:11:45 <Jupiter123> I saw Yesod, but I felt bit liked Snap
00:11:53 <ivanm> *shrug* fair enough
00:11:54 <Jupiter123> But didn't get books as such
00:12:11 <Jupiter123> for SNAP
00:12:33 <Jupiter123> Yesod was also quite catchy
00:12:41 <Jupiter123> whole haskell is quite interesting
00:12:45 <isomorphic> Jupiter123:  Have you found the scaffhold projects?
00:13:04 <isomorphic> *scaffold* even
00:13:26 <Jupiter123> I didn't get you, what you meant by scaffhold?
00:13:33 <Jupiter123> scaffolding
00:13:41 <isomorphic> Jupiter123:  snap init, or yesod init
00:13:43 <Jupiter123> just like Rails you mean (Ror)
00:14:20 <Jupiter123> I know bit of Ruby and Python, in that I found Scaffolding quite interesting , I am not sure about Haskell
00:14:23 <isomorphic> Jupiter123:  both snap and yesod will automatically generate a project
00:14:24 <Jupiter123> or SNaP
00:14:28 <Jupiter123> Oh I know that
00:14:44 <Jupiter123> It would be useful when we know what we are gonna build
00:14:46 <Jupiter123> I felt like that
00:15:16 <isomorphic> I like to modify something that's already working while I'm learning - so I found the scaffolding very useful
00:15:17 <Jupiter123> scaffolding makes makes things very quicker but sometimes we have to configure things later on if missed some bits
00:15:35 <isomorphic> Jupiter123:  I don't mean as the main project - I mean as a learning tool
00:15:37 <Jupiter123> Yes
00:15:48 <Jupiter123> Yes , as a tool its awesomeee
00:16:03 <Jupiter123> Yesterday I talked to Jacob Kaplan Moss of DJango
00:16:09 <Jupiter123> He was having similar views
00:16:27 <Jupiter123> He was awesome
00:16:33 <Jupiter123> Hope Haskell team is great as well
00:17:36 <Jupiter123> Are their any books for Yesod or Snap as well if anyone know
00:18:54 <ivanm> Jupiter123: Yesod has a book on their website
00:19:01 <ivanm> that's also sold through O'Reilly
00:19:07 <Jupiter123> ok
00:19:10 <ivanm> it has a slight haskell tutorial in it
00:19:47 <Jupiter123> oh thats great
00:20:05 <Jupiter123> Quick question: How is the things happening as business perspective for Haskell
00:20:22 <ivanm> there are various companies using Haskell
00:20:28 <Jupiter123> Since I found many organization are more inclined to JAva, Python, c or Ruby as such
00:20:29 <ivanm> there's a link off of haskell.org
00:20:33 <Jupiter123> Yes I saw
00:20:41 <Jupiter123> that link in haskell
00:20:45 <Jupiter123> But I am from India
00:20:48 <ivanm> there's also CUFP
00:21:00 <Jupiter123> in here, most projects are Java, C, C++, Python or Ruby
00:21:10 <Jupiter123> Haskell.. its damn less people who know it
00:21:17 <Jupiter123> but I want to learn Haskell somehow
00:21:21 <ivanm> yes, so which is a bit of a catch-22
00:21:30 <ivanm> Haskell is primarily used in the finance industry
00:21:37 <Jupiter123> yup
00:21:39 <ivanm> some website development coming up thanks to yesod, snap, etc.
00:22:06 <user123abc> on a related note, can you recommend any fun problem sets for someone who knows SML and C, etc.
00:22:07 <ivanm> it's also used in stealth a fair amount (for internal projects, etc.)
00:22:12 <Jupiter123> Since, I was thinking of building a quick web app and show how we can do using haskell
00:23:36 <Jupiter123> Its like if someone does something everyone follows it. So wanted to substantial  for fun and business attraction as well
00:23:44 <ivanm> *nod*
00:23:48 <Jupiter123> Its like if someone does something everyone follows it. So wanted to buildsubstantial  for fun and business attraction as well
00:24:16 <Jupiter123> Not sure how things works out
00:25:47 <kallisti> user123abc: check out the xml-conduit library
00:26:00 <zomg> Seems there's a lot of interest lately in Yesod from non-Haskell programmers
00:26:02 <kallisti> it has an xpath-like syntax to search for elements in a tree.
00:26:25 <kallisti> zomg: Yesod is very straightforward to use, mostly.
00:27:12 <zomg> Yeah well not for non-Haskellers
00:27:12 <zomg> :D
00:27:34 <zomg> I've used Haskell somewhat but even I struggle with it sometimes
00:27:51 <mracrrot> How do I read the content of an LB [String] in ghci? And what is really an LB [String]?
00:28:01 <kallisti> mracrrot: look at the imports in the file
00:28:08 <kallisti> or
00:28:12 <kallisti> find the type of LB
00:28:16 <kallisti> maybe it's an alias?
00:28:23 <kallisti> or a monad?
00:28:37 <ivanm> yeah, I have no idea what LB is off the top of my head
00:28:39 <mracrrot> LB
00:28:39 <mracrrot>   :: Control.Monad.Trans.Reader.ReaderT
00:28:39 <mracrrot>        (IRCRState, GHC.IORef.IORef IRCRWState) IO a
00:28:40 <mracrrot>      -> LB a
00:28:53 <ivanm> I would have thought it would be Lazy Bytestring but that's kind *, not * -> *
00:29:01 <kallisti> okay, so it's that
00:29:16 <ivanm> mracrrot: oh, from lambdabot?
00:29:18 <latro`a> any of you crazy folk happen to know measure theory? (if so I will take to #haskell-blah)
00:29:24 <mracrrot> ivanm: Yep.
00:29:25 <ivanm> this is the lambdabot monad I presume
00:29:46 <latro`a> (I say crazy folk affectionately btw)
00:30:08 <ivanm> latro`a: I used to, but can't remember much off the top of my head
00:30:09 <ivanm> sorry
00:30:11 <mracrrot> I am trying to figure out why lambdabot show the title for some urls, but not for other. (I have enabled the Url-plugin.
00:30:13 <latro`a> k
00:30:16 <Jupiter123> We love to see something more from Snap team
00:30:22 <Jupiter123> I would love to see
00:30:23 <latro`a> trying to show m(lim inf E_n) <= lim inf m(E_n)
00:30:28 <latro`a> and just have no idea where to begin :(
00:31:07 <Jupiter123> I installed haskell in my linux maching
00:31:08 <Jupiter123> I installed haskell in my linux machine
00:31:11 <Jupiter123> how to test it
00:31:24 <zomg> Test what?
00:31:37 <Jupiter123> on Terminal the ghc console
00:31:42 <ivanm> Jupiter123: ghci
00:31:46 <Jupiter123> I initially used on Windows
00:31:46 <ivanm> that gives you the interpreter
00:31:49 <Jupiter123> yes
00:32:00 <Jupiter123> in windows its pretty simple install
00:32:02 <Ferdirand> à$$$$$$$$$$$$
00:32:04 <ivanm> run ghci inside a terminal
00:32:05 <Ferdirand> oops
00:32:08 <Ferdirand> damned cat
00:32:13 <ivanm> Ferdirand: are you offering us all cash?
00:32:14 <ivanm> ;)
00:32:21 <Jupiter123> but in linux it got bit lengthy procedure
00:32:22 <Ferdirand> sorry for that
00:32:36 <Jupiter123> ok got it
00:32:37 <Jupiter123> thanks
00:32:41 <Jupiter123> ls
00:33:39 <mracrrot> Then there is a function called runWebReq that I do not find at all, even when grepping through the source of lambdabot.
00:34:02 <mracrrot> I would want to take a look at the source.
00:34:48 <user123abc> kallisti, thanks
00:35:11 <kallisti> user123abc: there's also HXT, but it's a big scary beast
00:35:14 <kallisti> for SGML
00:35:39 <kallisti> oh wait, I misunderstood.
00:35:43 <kallisti> user123abc: nevermind. :P
00:35:56 <kallisti> user123abc: what do you do with SML?
00:38:20 <mracrrot> The type of runWebReq is like this:
00:38:21 <mracrrot> runWebReq :: Lambdabot.Url.WebReq a -> Proxy -> IO a
00:38:45 <mracrrot> Can I from ghci find in what file it is definied?
00:39:45 <isomorphic> mracrrot:  :i runWebReq
00:40:01 <user123abc> kallisti,  nothing that qualifies as "doing". I just took a course on it as part of Robert Harper's mission to bring FP to the masses
00:40:18 <kallisti> user123abc: are you familiar with monads?
00:40:27 <kallisti> functors? monoids? applicatives?
00:40:36 <kallisti> that's probably where I would start, coming from ML
00:40:53 * hackagebot lojbanParser 0.1.5 - lojban parser  http://hackage.haskell.org/package/lojbanParser-0.1.5 (YoshikuniJujo)
00:40:54 <user123abc> monads, functors yes, the other stuff doesn't sound familiar
00:41:16 <user123abc> but thanks, much appreciated
00:41:31 <kallisti> user123abc: a monoid is just a type with a binary operation and an identity value
00:41:46 <kallisti> for example, any list. <> is concatenation
00:41:48 <kallisti> :t (<>)
00:41:49 <lambdabot> Doc -> Doc -> Doc
00:41:53 <kallisti> :t mappend
00:41:53 <user123abc> ah, got it
00:41:54 <lambdabot> forall a. (Monoid a) => a -> a -> a
00:41:57 <kallisti> well, this
00:41:58 <kallisti> actually
00:42:12 <kallisti> for lambdabot. newer versions of haskell have (<>) defined in Data.Monoid
00:42:14 <user123abc> I think I do recall reading about this in the haskell tut
00:42:27 <kallisti> > [1,2,3] `mappend` [4,5,6]
00:42:28 <lambdabot>   [1,2,3,4,5,6]
00:42:30 <kallisti> > [1,2,3] `mappend` mempty
00:42:31 <lambdabot>   [1,2,3]
00:43:03 <kallisti> :t Product
00:43:04 <lambdabot> forall a. a -> Product a
00:43:20 <kallisti> > Product 5 `mappend` Produce 5
00:43:21 <lambdabot>   Not in scope: data constructor `Produce'
00:43:25 <kallisti> > Product 5 `mappend` Product 5
00:43:26 <lambdabot>   Product {getProduct = 25}
00:43:28 <kallisti> product. produce.
00:43:50 <kallisti> > Sum 5 `mappend` Sum 5
00:43:51 <lambdabot>   Sum {getSum = 10}
00:44:02 <isomorphic> :t mzero
00:44:04 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
00:44:07 <isomorphic> :t mempty
00:44:09 <lambdabot> forall a. (Monoid a) => a
00:44:11 <fmap> :t (++)
00:44:12 <lambdabot> forall m. (Monoid m) => m -> m -> m
00:44:22 <kallisti> fmap: excellent
00:44:27 <kallisti> but, not standard
00:44:46 <kallisti> what if we had like...
00:44:52 <kallisti> 2 interpreters, for lambdabot
00:45:01 <kallisti> one for standard latest version Haskell
00:45:16 <kallisti> (with many imports)
00:45:50 <kallisti> but without the nonstandard "caleskell" changes
00:49:01 <ivanm> kallisti: I believe it's now properly referred to as "skiskell"
00:49:04 <ivanm> @quote skiskell
00:49:04 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
00:49:14 <ivanm> thought someone had @remembered a qutoe to that extent...
00:50:42 <isomorphic> Is there a 'proper' way to write a functor instance for a type with two type parameters, eg: Either?
00:50:55 <ivanm> isomorphic: do you want a BiFunctor?
00:51:00 <ivanm> @src (Either a) Functor
00:51:00 <lambdabot> Source not found.
00:51:02 <ivanm> bah
00:51:30 <ivanm> instance Functor (Either a) where fmap f (Left l) = Left l; fmap f (Right r) = Right $ f r
00:51:57 <isomorphic> ivanm:  Possibly.  I'm going through RWH, and looking for context
00:52:23 <ivanm> well, Functor only works for kind * -> *
00:52:28 <ivanm> i.e. last type variable
00:52:51 <ivanm> if you want an fmap-like function for the second-last type variable, that's what BiFunctor is for (it's been defined a few times)
00:52:54 <ivanm> @hoogle BiFunctor
00:52:54 <lambdabot> package bifunctors
00:52:58 <ivanm> voila!
00:53:58 <isomorphic> ivanm:  Thanks :)
00:54:02 <ivanm> np
01:03:13 <GnomeStoleMyBike> Hi All!
01:04:12 <isomorphic> GnomeStoleMyBike:  Hi.  Wow, Gnome seems to have really gone off the rails in version 3.
01:04:26 <EvanR2> lol
01:04:58 <mcstar> a gnome is a little evil dwarfish thing too, isnt it?
01:05:41 <isomorphic> mcstar:  Not sure about evil.  The little statues that people put in their yards look quite merry for the most part.
01:06:11 <marzipanmartian> excuse me, but I'm very stuck. I can't seem to figure out where 'print' is being imported from in this file (https://gist.github.com/89786)
01:06:23 <mcstar> they are, if i had to make a horror movie, that'd be about them
01:06:28 <Jupiter123> Hi I got one issue while trying install Yesod
01:06:30 <Jupiter123> cabal: Couldn't read cabal file "iteratee/0.8.9.3/iteratee.cabal"
01:06:34 <Jupiter123> how to resolve this
01:06:42 <Jupiter123> is that path is not set
01:07:02 <Jupiter123> how to do  $HOME/.cabal/bin to your PATH in linux
01:07:18 <mcstar> marzipanmartian: dont put parens next to the link next time
01:07:39 <mcstar> print is from the Prelude
01:08:04 <zomg> Jupiter123: what distro are you using?
01:08:17 <Jupiter123> linux mint 12- debian
01:08:29 <zomg> Have you checked if apt has yesod-platform?
01:08:34 <zomg> That would be the easiest way to install it
01:08:38 <Jupiter123> not yet
01:08:54 <Jupiter123> I was following this procedure http://www.yesodweb.com/page/quickstart
01:09:00 <Jupiter123> and did cabal update
01:09:17 <Jupiter123> when tried cabal install yesod-platform I got that issue
01:09:18 <isomorphic> Jupiter123:  So, cabal update caused this error?
01:09:21 <zomg> Yeah you can just install yesod from apt too if it's recent enough
01:09:33 <marzipanmartian> mcstar: what? but Prelude isn't imported, how could that work then? When I added prelude to another file I have using 'print' it didn't work either.
01:09:48 <marzipanmartian> the gist I posted compiles fine
01:09:49 <Jupiter123> you mean sudo apt-get install yesod-platform
01:09:49 <Jupiter123> ?
01:09:59 <zomg> Jupiter123: yes
01:10:00 <mcstar> prelude is imported by default, except if you explicitely import functions from it
01:10:06 <Cale> marzipanmartian: Prelude is the one module which is always implicitly imported
01:10:10 <Jupiter123> but will the path be set when cabal is
01:10:10 <isomorphic> Jupiter123:  Incidentally, how much free disk do you have?
01:10:25 <Cale> (unless you explicitly include a declaration saying not to import everything from it)
01:10:26 <Jupiter123> I do have enough 100 gb around
01:10:40 <Jupiter123> I wanted to know "Make sure to add $HOME/.cabal/bin to your PATH. Once you're set up, run "
01:10:42 <Jupiter123> what that link meant
01:10:45 <Jupiter123> how to do that
01:10:49 <Jupiter123> in terminal
01:10:54 <zomg> echo $PATH
01:10:59 <Jupiter123> oh
01:11:00 <Jupiter123> ok
01:11:13 <zomg> that will output the path variable, so you can just check if the cabal/bin dir is there then
01:11:14 <marzipanmartian> ah, that clears it up! thank you!
01:11:31 <Cale> marzipanmartian: Similarly, many other basic things are in there, such as the basic numerical operations, equality and inequality testing, basic types like Bool, and a bunch of other things likely to be useful in most any program.
01:11:50 <Jupiter123> No it doesn't say
01:12:04 <Jupiter123> it doesn't contain cabal/bin
01:12:27 <TheBrayn> Jupiter123: you can temporarily add it with export PATH="${PATH}:${HOME}/.cabal/bin"
01:12:42 <Cale> marzipanmartian: there's a specification for it here, which is good reading: http://www.haskell.org/onlinereport/standard-prelude.html
01:12:47 <Jupiter123> export PATH="${PATH}:${HOME}/.cabal/bin"   is it
01:12:51 <Jupiter123> in terminal
01:12:55 <zomg> You would probably want to add the export line to your shell's config file (eg. .bashrc or whatever)
01:13:13 <TheBrayn> if you want to add it permamently you'll have to put this line into your bashrc or your /etc/profile (use the first one if you're not sure)
01:13:36 <Jupiter123> I want to add permanently in the in shell config
01:13:51 <dcoutts> Jupiter123: do cabal update, the problem with iteratee should disappear.
01:14:00 <Jupiter123> ok will try that
01:15:21 <Jupiter123> it did't do anything . Ended at Downloading the latest package list from hackage.haskell.org
01:15:27 <Jupiter123> and shell
01:16:09 <isomorphic> Jupiter123:  that's cool
01:16:26 <isomorphic> Jupiter123:  Now, cabal install yesod-platform
01:18:55 <Jupiter123> isomorphic:  its installing I guess. Downloading something :D
01:19:27 <isomorphic> Jupiter123:  It will grab all the dependencies specified in the yesod-platform cabal file … and their dependencies.
01:20:13 <Jupiter123> isomorphic: hope it gets me up and running
01:21:05 <dcoutts> zomg: for future reference, if you see an error like Couldn't read cabal file "blah/1.0/blah.cabal", it's not a local file, its a file in the index
01:23:06 <isomorphic> dcoutts:  Is the part that is printed the suffix of a URL?
01:23:23 <mcstar> sry, totally OT: can i colorize a layer in gimp according to the brightness of another in gimp?
01:24:34 <isomorphic> mcstar: Is that equivalent to having a layer with set opacity and then flattening?
01:25:14 <mcstar> no, i want to change the hue of a layer accrding to the black-white value of another
01:25:30 <mcstar> like modulating it with a gradient mask
01:25:50 <mcstar> working on the background nebula for my Asteroids :)
01:25:55 * hackagebot cmaes 0.2.1 - CMA-ES wrapper in Haskell  http://hackage.haskell.org/package/cmaes-0.2.1 (TakayukiMuranushi)
01:26:17 <mcstar> isomorphic: nvm, i think i can do it
01:26:17 <isomorphic> mcstar:  I'm hearing you, but isn't your modulating step a bit like adding a given hue?  Or are you definitely set on multiplication?
01:26:43 <dcoutts> isomorphic: no, it's the path within the index tar file
01:36:25 <mcstar> isomorphic: http://i.imgur.com/2S3CF.jpg
01:37:07 <isomorphic> mcstar:  How did you do it?
01:37:13 <mcstar> actually setting the black-white gradient mask to be the 'hue' of the cloudy channel didnt work
01:37:23 <mcstar> but 'divide' or somesuch did
01:37:43 <isomorphic> See, I was thinking to make your mask into the right hue
01:37:47 <mcstar> isomorphic: you can select on the top of the layer list, how should one layer act like
01:37:49 <isomorphic> then get the opacity set and add
01:39:00 <mcstar> isomorphic: i used the 'difference' operation, so that might be like what you said
01:39:32 <isomorphic> mcstar:  I had visions that you might be using the scripting functions to achieve it ;)
01:39:52 <mcstar> im a noob to image editing, cant script gimp
01:40:16 <mcstar> i would have done it in mathematica if everything had failed me :)
01:40:34 <isomorphic> mcstar:  Haha.  I've done something a bit like that in Matlab once
01:42:02 <merijn> Is there a way I can get cabal to run HLint whenever I compile?
01:42:53 <dcoutts> merijn: make a script, tell cabal to use that as your ghc binary
01:59:18 <merijn> /Users/merijn/Dropbox/Documents/languages/J\ 7.0.1/bin/jhs.command ; exit;
01:59:33 <merijn> hmm
01:59:39 <merijn> Someone is a bad developer
01:59:58 <merijn> Apparently J tries to execute by starting a terminal and directing input to it directly..
02:00:20 <merijn> Not accounting for possible .profile scripts being run on interactive login shells >.>
02:00:34 <zomg> That can't be
02:00:40 <zomg> There are no bad developers!
02:01:17 <isomorphic> merijn:  ghc-mod gives me useful warnings about things that are defined and not used (re: your question about Hlint)
02:02:35 <fmap> ghc-mod can run hlint directly actually
02:03:11 <Jupiter123> I got error installing yesod
02:03:39 <Jupiter123> yesod-1.1.1 depends on warp-1.3.2 which failed to install
02:03:58 <zomg> Cabal sometimes does that. Simply try again
02:04:20 <zomg> If the problem persists, try installing the failing package separately, eg. in thi case 'cabal install warp' and then try again with yesod
02:05:12 <isomorphic> Jupiter123:  yesod-platform is fairly picky about versions though - so you might need to add a constraint if you do the warp install as zomg suggests
02:05:21 * dcoutts isn't sure that's good advice
02:05:34 <dcoutts> zomg: the problems are not random
02:05:51 <zomg> I don't know, every time I've installed yesod it does that on random packages
02:05:55 * hackagebot alex-meta 0.3.0.4 - Quasi-quoter for Alex lexers  http://hackage.haskell.org/package/alex-meta-0.3.0.4 (JonasDuregard)
02:05:55 <dcoutts> zomg: and installing deps separately is not a good idea, you should always install from the top
02:05:56 <zomg> and then just trying again solves it
02:05:58 * hackagebot happy-meta 0.2.0.5 - Quasi-quoter for Happy parsers  http://hackage.haskell.org/package/happy-meta-0.2.0.5 (JonasDuregard)
02:05:59 * hackagebot cakyrespa 0.0.1 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.1 (YoshikuniJujo)
02:06:28 <zomg> There may be a better way to go about it, but this is something I've tried and found it works =)
02:06:44 <zomg> I tried to figure out why the package failed to install but it wasn't giving me any useful info on it in the output
02:07:02 <zomg> and when you try again, it usually works ok, so you don't even get a chance to use -v3 or whatever
02:07:55 <zomg> I suspect it may have something to do with RAM constraints on my VPS since that has caused issues with some other haskell related things in the past
02:09:05 <dcoutts> zomg: ok, low mem issues may appear random
02:10:32 <zomg> I have seen some odd segfaulting on Ubuntu 12.04, I think it has some compatibility issues with ghc, but I'm not really great at figuring that sort of stuff out
02:12:18 <zomg> one example was certificate-1.2.6, where 1.2.8 works fine. The difference between the versions is really small, and I don't really see any reason (nor did the author of certificate) why any of the changes would make a difference
02:12:46 <merijn> hmmm, how does the RTS deal with signals? Are they translated to exceptions or treated entirely differently?
02:13:43 <EvanR2> System.Posix has wrappers for the signal handler settings
02:14:35 <EvanR2> treated differently from Control.Exceptions
02:17:33 <bford> if there another way to achieve the same effect as this: swap ~(x, y) = (y, x)? I've got swap tup = (snd tup, fst tup)
02:17:52 <bford> (i need the lazyness of the ~ pattern match)
02:18:04 <bford> s/if/is/
02:18:28 <ceii> swap pair = let (x,y) = pair in (y,x) ?
02:18:33 <ceii> not simpler though
02:18:48 <frerich> @pl \x -> (sdn x, fst x)
02:18:48 <lambdabot> liftM2 (,) sdn fst
02:18:58 <frerich> err, 'snd' instead of 'sdn'
02:20:14 <bford> ceii, is your first example lazy in evaluating pair?
02:20:27 <ceii> yes, let pattern bindings are always lazy
02:21:59 <bford> ceii, yes that will work then :-) it's for a little FRP module I'm writing for fay... been trying to track down the source of insufficient lazyness for hours :-)
02:24:59 <merijn> hmm, Data.Serialize doesn't seem very efficient?
02:25:29 <merijn> > Data.Serialize.encode (Data.IntMap.fromList [(1,'a'),(2,'b')])
02:25:31 <lambdabot>   Not in scope: `Data.Serialize.encode'Not in scope: `Data.IntMap.fromList'
02:26:49 <merijn> The produced encoding is something like "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\STX\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOHa\NUL\NUL\NUL\NUL\NUL\NUL\NUL\STXb", seems a bit wasteful with all the nul bytes?
02:27:23 <zomg> NUL NUL NUL NUL NUL NUL NUL NUL NUL NUL NUL NUL NUL NUL NUL batmaaaan
02:27:38 <EvanR2> merijn: looks like 64bit ints to me ;)
02:27:55 <EvanR2> blame intel
02:28:15 <merijn> EvanR2: That'd be odd, I'm using 32bit haskell
02:28:43 <EvanR2> im guessing the instances want your stuff to be deserializable on more than just your machine
02:28:51 <merijn> Lies! :p
02:29:15 <frerich> zomg: Try to make it NaNNaNNaNaNNaN batmaaan
02:29:42 <Jupiter123> I was told to update cabal again
02:29:43 <zomg> Wasn't there a website with implementations of that in various languages? =)
02:30:05 <Jupiter123> when I do it and try cabal install wrap, it says no package
02:30:29 <frerich> zomg" I got it from http://www.youtube.com/watch?v=kXEgk1Hdze0 (a lightning talk looking at oddities in JavaScript and Ruby)
02:30:40 <dcoutts> Jupiter123: there really is no package called wrap, perhaps you mean warp
02:31:09 <EvanR2> OS3 wrap, warp warped
02:33:49 <Jupiter123> thats right thanks
02:34:32 <Jupiter123> I get this error
02:34:33 <Jupiter123> cabal: warp.cabal:59: The 'type' field is required for test suites. The
02:34:33 <Jupiter123> available test types are: exitcode-stdio-1.0
02:34:33 <Jupiter123> cabal: Error: some packages failed to install:
02:34:33 <Jupiter123> warp-1.3.2 failed during the configure step. The exception was:
02:34:33 <Jupiter123> ExitFailure 1
02:40:25 <EvanR2> so im finding myself optimizing space usage by manually setting up sharing with numeric ids instead of direct inclusion
02:40:38 <EvanR2> haskell save me
02:42:35 <Jupiter123> save me to install yesod as well :)
02:43:58 <fmap> Jupiter123: that's strange because test section in warp.cabal is explicitly disabled
02:44:09 <fmap> (on hackage that is)
02:44:31 <Jupiter123> hmm
02:44:39 <Jupiter123> how to do that
02:45:04 <Jupiter123> Is their any place wherein I could post my issue coming up in terminal to forum
02:47:18 <fmap> Jupiter123: could you paste "cabal update; cabal install -v warp" on hpaste?
02:47:20 <fmap> @hpaste
02:47:20 <lambdabot> Haskell pastebin: http://hpaste.org/
02:47:52 <Jupiter123> sure
02:49:38 <hpaste> Rohit pasted “Issue installing Yesod” at http://hpaste.org/75605
02:49:49 <Jupiter123> I did.
02:52:31 <hpaste> Rohit pasted “Issue installing Yesod” at http://hpaste.org/75606
02:52:45 <Jupiter123> I posted two errors
02:52:59 <Jupiter123> http://hpaste.org/75605 and http://hpaste.org/75606
02:54:52 <fmap> interesting
02:56:48 <fmap> Jupiter123: you can remove broken tests manually, you need to "cabal unpack warp; cd warp-1.3.2; {- remove Test-Suite spec section from warp.cabal -}; cabal install"
02:57:13 <Jupiter123> ok will try what you said
02:57:29 <fmap> I wonder why warp.cabal is fixed only in web interface
02:57:39 <dcoutts_> fmap: I fixed it
02:58:36 <dcoutts_> fmap: yes, if users with old cabal versions actually try to install it, then it will not work, but at least it doesn't break all dependency planning
03:00:55 <fmap> dcoutts_: I see. And patching warp-1.3.2.tar.gz manually seems like a pretty bad idea.
03:00:58 * hackagebot BNFC-meta 0.3.0.5 - Deriving Quasi-Quoters from BNF Grammars  http://hackage.haskell.org/package/BNFC-meta-0.3.0.5 (JonasDuregard)
03:02:40 <GnomeStoleMyBike> guys
03:02:55 <GnomeStoleMyBike> do you know when BOS will be releasing new RLWH book ?
03:03:39 <GnomeStoleMyBike> i liked the first version but i left it in my home country i could buy new one if its gone be released soonish :)
03:03:52 <hvr> GnomeStoleMyBike: I'm quite sure it won't be soonish
03:05:10 <hvr> GnomeStoleMyBike: see http://www.reddit.com/r/haskell/comments/10gcpp/real_world_haskell_is_there_a_second_edition/c6ddixk
03:05:52 <EvanR2> aeson has switched to Data.HashMap
03:06:09 <hvr> EvanR2: true
03:06:13 <EvanR2> which claims to be faster than 'other tree based maps'
03:06:27 <GnomeStoleMyBike> hvr: you are breaking my heart. I really thought BoS will add a chapter on stuff like Snap. :)
03:06:30 <EvanR2> unfortunately it seems to be less supported in other libs (like Serialize) than Map
03:08:09 <dcoutts> fmap: yes, you cannot alter the .tar.gz
03:08:18 <EvanR2> also whats the deal with haskell being against hash tables, and HashMap is not a hash table?
03:08:33 <dcoutts> fmap: next version of cabal-install will however be able to use the updated .cabal file from the server when building.
03:08:42 <companion_cube> EvanR2: hashtable algorithms are imperative
03:08:56 <companion_cube> so they are less convenient than purely functional (hash) trees
03:09:27 <certainty> as okasaki pointed out :)
03:11:22 <hpaste> Rohit pasted “Issue installing Yesod” at http://hpaste.org/75607
03:12:36 <fmap> Jupiter123: you need to do the same thing with binary-0.6.1.0 I guess
03:13:12 <Jupiter123> ok
03:14:20 <Jupiter123> it doesn't unpack binary
03:14:50 <Jupiter123> ok now got it
03:14:51 <Jupiter123> thanks
03:15:17 <boara> cabal install directory fails. Is there a replacement which does work?
03:15:59 * hackagebot codo-notation 0.5 - A notation for comonads, analogous to the do-notation for monads.  http://hackage.haskell.org/package/codo-notation-0.5 (DominicOrchard)
03:16:12 <fmap> boara: you shouldn't "cabal install directory", directory package comes with ghc
03:16:32 <EvanR2> codu
03:17:02 <mcstar> lol, im trying to steal an image from the internetz, and opera dies on me
03:17:21 <mm_freak_> Polarina: two integrals depending on each other, a manager wire that commands itself, etc.
03:17:44 <boara> fmap: are you saying that first we had GHC which wanted to become more modular by moving libraries out of GHC and now GHC has absorbed directory again?
03:17:50 <boara> Can't they make up their mind?
03:17:59 <matthiasgorgens> boara: that's a common cycle.
03:18:07 <matthiasgorgens> you'll get that with CPUs and accessory chips, too.
03:18:23 <boara> matthiasgorgens: for hardware it makes sense.
03:18:32 <fmap> boara: well, actually I'm saying there is probably another way to solve problem you are trying to solve
03:19:00 <matthiasgorgens> EvanR2: haskell isn't against hashtables, if you apply a suitable definition of hashtable. :o)
03:19:22 <matthiasgorgens> (I.e. a fast but imprecise lookup chained to a slow but accurate one.)
03:19:35 <boara> I don't understand all the problems people have with hash tables.
03:19:46 <matthiasgorgens> like hashing to a number and putting it in an array, and then looking up in a linked list.
03:19:51 <boara> If you want a fast one, just use C++ <-> C <-> Haskell.
03:19:54 <matthiasgorgens> (which is one of the classic hash tables.)
03:20:02 <matthiasgorgens> why'd you want to use C++?
03:20:13 <boara> matthiasgorgens: because those hash tables are efficient.
03:20:37 <matthiasgorgens> ok, they have a good library in C++ for that.
03:21:01 <matthiasgorgens> also, depending on your needs, you may want to just use a relational database instead.
03:25:59 * hackagebot tagset-positional 0.1.0 - Handling positional tags and tagsets  http://hackage.haskell.org/package/tagset-positional-0.1.0 (JakubWaszczuk)
03:34:25 <boara> How can I force GHC to check for exhaustiveness?
03:34:39 <boara> I.e., fail to compile if it's not exhaustive?
03:35:18 <Lemmih> boara: -Wall -Werror
03:36:01 * hackagebot gluturtle 0.0.8 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.8 (YoshikuniJujo)
03:41:51 <mm_freak_> -W is sufficient
03:41:59 <mm_freak_> -Wall is just annoying
03:43:49 <fmap> -Wall isn't very annoying aside of -fwarn-unused-do-bind
03:49:07 <EvanR2> instance (FromJSON a, ToJSON a) => Serialize a where
03:49:35 <EvanR2>  Illegal instance declaration for `Serialize a'
03:49:37 <hvr> EvanR2: ...why would you want that?
03:49:49 <maukd> that's undecideable
03:50:00 <fmap> are there lenses for Network.URI somewhere?
03:50:01 <EvanR2> so i can define safecopy instance for my thing
03:50:13 <maukd> EvanR2: is Serialize your own class?
03:50:16 <EvanR2> no
03:50:20 <maukd> then you can't do that
03:50:34 <maukd> (if it wasn't, you couldn't really do it either but then you wouldn't need a class)
03:50:45 <EvanR2> i thought this is how all the libs do it
03:50:50 <hpaste> Rohit pasted “Why is this error,when trying init for Yesod” at http://hpaste.org/75608
03:51:04 <EvanR2> define instances for their types for classes in other modules
03:51:07 <maukd> yes
03:51:14 <maukd> but you're not defining an instance for your types
03:51:24 <maukd> you're defining *the* instance for *all* types
03:51:40 <fmap> Jupiter123: do you have ~/.cabal/bin in your PATH?
03:51:41 <EvanR2> err
03:51:54 <EvanR2> oh
03:52:14 <Jupiter123> no
03:52:23 <Jupiter123> I asked initially how to set that
03:52:53 <fmap> Jupiter123: then do export PATH="${HOME}/.cabal/bin:${PATH}"
03:52:57 <EvanR2> then ill use json encode and decode in the safecopy instance and use the serialize instance of bytestring
03:52:58 <hpaste> Rohit pasted “How to set path” at http://hpaste.org/75609
03:53:46 <maukd> what is "directory" doing there?
03:53:49 <fmap> ("export" is a part of command)
03:53:59 <Jupiter123> ok
03:54:04 <maukd> fmap: but not necessary
03:57:06 <Jupiter123> scaffold in YEsod is """""" Awesome guys
03:57:16 <Jupiter123> Just love it
03:57:17 <Jupiter123> :D
03:57:27 <osfameron> scaffold?
03:59:27 <EvanR2> getCopy = contain (decode' <$> safeGet), type error because this results in a Get (Maybe a) instead of Get a
03:59:38 <EvanR2> how do i go from Get (Maybe a) -> Get a
04:00:05 <EvanR2> fromJust is probably not the answer
04:01:17 <maukd> @hoogle Get
04:01:18 <lambdabot> Prelude getChar :: IO Char
04:01:18 <lambdabot> System.IO getChar :: IO Char
04:01:18 <lambdabot> Prelude getContents :: IO String
04:01:31 <EvanR2> Data.Serialize.Get
04:02:08 <fmap> fmap fromJust?
04:02:26 <EvanR2> ok but will that crash the program or be handled by the parser
04:02:40 <maukd> crash
04:02:44 <maukd> you don't use fromJust
04:03:08 <maukd> do Just x <- foo; return x
04:03:27 <merijn> EvanR2: maybe/fromMaybe?
04:03:53 <boara> How can I express 'warn for everything, but not for missing type signatures and ...'?
04:03:55 <EvanR2> theres no sensible value to return on parse failure
04:04:04 <EvanR2> i think i have to use 'fail' like maukd says
04:04:10 <maukd> or mzero
04:04:17 <boara> -Wall -fno-.... (which would be a sane way to do it) doesn't work
04:04:20 <EvanR2> ah
04:04:38 <EvanR2> fmap (fromMaybe mzero)
04:04:57 <maukd> boara: how does it fail?
04:05:00 <EvanR2> so much for plainly readable code ;)
04:05:18 <boara> maukd: it acts as if the -fno... is not there.
04:05:38 <maukd> :-(
04:05:54 <maukd> that seems like a bug in ghc
04:06:57 <boara> maukd: PEBKAC
04:07:34 --- mode: hubbard.freenode.net set +o ChanServ
04:15:09 <boara> What's the magic incantation to get around 'Defined but not used warnings'?
04:15:37 <boara> I already tried -fno-warn-unused-binds .
04:16:56 <zomg> $EDITOR
04:16:57 <zomg> ;>
04:18:01 <fmap> boara: paste the offending line
04:18:40 <fmap> and warning message
04:18:43 <merijn> boara: Why would you define things that aren't used?
04:19:16 <boara> merijn: for the same reason I have programs installed which I am not currently running.
04:19:49 <zomg> That makes no sense :P
04:20:06 <t7> boara: jeez do you have a 1 petabyte hard disc or something
04:20:09 <t7> wasteful jerk
04:20:10 <boara> zomg: sure it does; perhaps I have a debug macro or whatever.
04:20:27 <zomg> Having a debug macro does, but your comparison doesn't
04:20:28 <zomg> :D
04:20:34 * merijn has never really had problems with to many defined but unused warnings
04:20:47 <boara> t7: you actually need less than 500GB to install all packages in Debian, I think.
04:21:17 <boara> t7: so a consumer harddisk will allow you to run Debian Stable, Testing and Unstable on the same system.
04:21:51 <t7> I could install them all 4 times :D
04:21:56 <boara> If you wanted to have all operating systems every developed including all optional packages, you might want to have 1PB.
04:22:01 <t7> bu you can only have 4 partitions :*(
04:22:15 <zomg> space is so cheap so I wonder why server hosting providers are so stingy with it
04:22:39 <boara> zomg: lack of competition.
04:22:45 <t7> i blame apple
04:22:59 <zomg> boara: I think there's quite a lot of competition in that field but nobody seems to be competing with storage space I guess
04:23:33 <zomg> Oh poo, forgot to update my CC expiration date in paypal and now my monthly payments are stuck..
04:24:28 <EvanR2> delete paypal, use bitcoins!
04:24:43 <zomg> EvanR2: now tell that to everyone who accepts online payments
04:24:50 <EvanR2> i do
04:25:02 <zomg> Now make them do it instead of just listening and discarding
04:25:03 <zomg> ;>
04:25:15 <EvanR2> that would be fascism
04:25:48 <merijn> ByteString is an IsString instance, right?
04:26:05 <EvanR2> ByteString.Char8 is
04:26:22 <merijn> Close enough for me :p
04:30:13 <EvanR2> before the latest version of
04:30:27 <EvanR2> bytestring, how do you convert from lazy to strict
04:31:04 <maukd> concat . toChunks or something like that
04:31:18 <EvanR2> ah
04:31:41 <EvanR2> going back to sleep so i can get a few hours before work
04:32:18 <boara> Is there no way to disable the 'Defined but not used' warning?
04:33:27 <osfameron> why would you want to?
04:33:40 <hpaste> Rohit pasted “yesod cabal-dev error” at http://hpaste.org/75610
04:34:05 <boara> osfameron: why would you ever reply to a question with a question?
04:35:05 <osfameron> too early in the day to play Questions ;-)
04:35:06 <hpc> boara: why not?
04:35:23 <boara> hpc: why would you?
04:35:40 <boara> hpc: asking that question suggests that osfameron knows my needs better than I do.
04:35:48 <t7> EvanR2: haven't you heard? we are all moving to open transactions now
04:35:50 <boara> hpc: that alone shows osfameron is arrogant.
04:35:58 <Saizan> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/flag-reference.html <- -fno-warn-unused-binds
04:36:04 <osfameron> boara: no.  I was asking why you'd want to
04:36:12 <osfameron> if you tell me, then I'll have learnt something
04:36:12 <boara> Saizan: it doesn't work.
04:36:38 <boara> Saizan: perhaps this was fixed in ghc7.6.1
04:36:40 <Saizan> btw, sometimes it's necessary to ask such questions to avoid the XY problem
04:36:43 <boara> Saizan: but I don't know that.
04:37:26 <Saizan> boara: how are you using it?
04:38:53 <Saizan> boara: it works for me on ghc-7.4.1
04:39:02 <osfameron> boara: I wasn't sure it would be useful in haskell.  It's sometimes useful in Perl and other dynamic languages to declare a variable but not use it *right here*.  So I guess I'm wondering if your answer would be that you're doing something dynamic.  But I'm genuinely curious, as opposed to telling you that you're "wrong" to want to use it.
04:39:26 <boara> Saizan: ghc --make -imydir -Wall -Werror --make Foo.hs -fno-warn-missing-signatures -fno-warn-unused-do-bind -fno-warn-name-shadowing -fno-warn-unused-binds -fno-warn-unused-imports
04:40:31 <Saizan> osfameron: during developement you might define some functions which you're not using yet even in a static language
04:40:40 <absence> how can i fix the following error? undefined reference to `mtlzm2zi1zi1_ControlziMonadziStateziClass_get_info'
04:41:04 * hackagebot cakyrespa 0.0.3 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.3 (YoshikuniJujo)
04:41:07 <boara> absence: fix the compiler.
04:41:19 <boara> absence: or alternatively, remove all object files.
04:41:45 <Saizan> absence: how are you compiling?
04:41:59 <absence> boara: okay, i deleted all o files, compiled again, same error
04:42:06 <Saizan> boara: i can't reproduce the problem
04:42:11 <boara> absence: hi files too.
04:42:11 <hpc> absence: remove .o and .hi files?
04:42:19 <osfameron> Saizan: agreed.  but it's not an error, only a warning.  well, ok
04:42:38 <absence> Saizan: ghc -c somefile.hs, ghc -c somefile2.c, ghc -shared somefile.o somefile2.o
04:42:50 <boara> Saizan: with 7.4.1?
04:42:54 <Saizan> absence: add --make
04:42:56 <Saizan> boara: yeah
04:43:00 <boara> Saizan: odd
04:43:11 <Saizan> absence: or -package mtl
04:43:49 <absence> Saizan: ghc --make -shared? or --make -c? or both? (the first didn't work)
04:44:34 <Saizan> absence: my guess would be ghc --make -shared somefile.hs somefile.c
04:44:47 <absence> Saizan: that doesn't work, but -package mtl does. thanks :)
04:46:04 <Saizan> --make should figure out the -package flags itself from the imports in the .hs file, though i've not used it with .c files and -shared
04:46:23 <Saizan> maybe there's a way to make it work
04:46:38 <absence> Saizan: oh right, --make works when i provide the source files, i still used .o when i tested
04:47:34 <absence> Saizan: i can't do that though, because the _stub.h file isn't generated in time for the compilation of the c file
05:03:16 <boara> Which command does flymake use to determine the error messages it needs to show?
05:03:42 <boara> It displays a ! before a line where there is an error.
05:03:57 <boara> Except, I need to modify the command that it uses.
05:18:33 <absence> i'm a but confused about the different flavours of pointers available for ffi. if i want to marshal a haskell data structure into something c can use, what is the right way?
05:19:46 <bartavelle> Something I don't understand, in coders at work Simon Peyton Jones says that it is awkward to write a serializer with a static type system
05:19:57 <bartavelle> and it's much easier with a dynamic one
05:20:06 <bartavelle> I just can't see why, but I suppose I lack imagination
05:20:37 <maukd> absence: depends. "use" how?
05:20:44 <Botje> bartavelle: you basically need read bytes and return a different type depending on what you read.
05:20:56 <maukd> usually you have an existing C API with C types, not the other way around
05:23:03 <bartavelle> Botje, I still do not see the problem
05:23:08 <bartavelle> I mean
05:23:09 <bartavelle> yes I do
05:23:21 <merijn> absence: Do you want a struct that C can use or just something you can hand to C and get back?
05:23:30 <bartavelle> but how is that practical ? You need to have a list of types that might come out anyway
05:23:54 <bartavelle> might has well have an algebaraic type to contain this list
05:23:59 <bartavelle> algebraic
05:23:59 <Botje> bartavelle: and they all need to be in a horrible algebraic type.
05:24:11 <merijn> bartavelle: A serializer is trivial. A deserializer is the nasty part ;)
05:24:12 <Botje> with a dynamic language you do what you want
05:24:22 <bartavelle> perhaps the problem is I am so biaised that I don't think this is horrible ;)
05:24:38 <absence> merijn: a struct that c can use
05:25:04 <maukd> absence: what struct is this?
05:25:07 <absence> merijn: or at leat a pointer where i know that "this member is n bytes from the start address", etc
05:25:31 <absence> maukd: a bunch of data i want to pass from haskell to c
05:25:34 <merijn> absence: You need to define your own struct and marshal that to haskell using hsc2hs, etc.
05:25:56 <maukd> absence: no. what is the actual struct?
05:26:11 <merijn> absence: for an example take a look at some code I wrote recently: https://github.com/merijn/SNet2.0/tree/master/SNet/Interfaces
05:26:27 <absence> maukd: i haven't written the struct yet, i just have a haskell record
05:26:42 <absence> maukd: basically i want to access the contents of a haskell record from c
05:26:46 <merijn> absence: I use c2hsc to generate haskell marshalling code for my C struct and then use that in the rest of the haskell side of the interface
05:26:47 <maukd> absence: why?
05:28:02 <absence> merijn: i don't have a c struct yet, but do i just make one that matches the haskell record i want to access?
05:28:13 <merijn> absence: Yes
05:28:42 <merijn> absence: And then define a Storable instance for the Haskell record (using for example hsc2hs to generate the appropriate offsets in the C struct for you)
05:29:35 <maukd> I have an ALIGNOF macro here somewhere if you need it
05:29:44 <absence> merijn: i've made a Storable instance, and tried returning a StablePtr (so the gc doesn't free it) to c, but casting the StablePtr to a pointer and accessing it causes a crash :)
05:30:13 <maukd> ... casting how?
05:30:22 <maukd> also returning how?
05:30:44 <maukd> StablePtr isn't about not freeing things
05:30:49 <absence> maukd: (char*)haskellFunctionThatReturnsStablePtr();
05:30:57 <hirsch_> http://www.spiegel.de/netzwelt/games/browser-spiele-nikki-and-the-robots-voynich-experiment-a-857872.html
05:31:08 <absence> haskellFunctionThatReturnsStablePtr = newStablePtr .....
05:31:09 <merijn> absence: StablePtr are not for accessing things
05:31:13 <maukd> ok, it is actually
05:31:14 <hirsch_> Wow, Haskell game in Spiegel-Online news portal
05:31:21 <merijn> absence: StablePtr can only be used on the Haskell side
05:31:28 <absence> oh i see
05:31:37 <merijn> absence: To the C side a StablePtr is just an opaque void Ptr
05:31:54 <absence> so it's Ptr or ForeignPtr then?
05:32:17 <maukd> absence: ARE YOU GOING TO ACTUALLY ANSWER MY QUESTIONS?
05:32:44 <absence> maukd: i think i did, which one are you refering to?
05:33:07 <merijn> absence: You most likely want malloc and friends from Foreign.Marshal.Alloc
05:33:50 <merijn> Or mallocForeignPtr for automatic freeing
05:34:50 <absence> merijn: isn't automatic freeing kinda dangerous? i mean, can haskell know when C is done with the pointer?
05:35:21 <merijn> absence: No
05:35:31 <statusfailed> hirsch_: cool!
05:35:32 <merijn> That's why you have withForeignPtr
05:35:50 <merijn> absence: You call your C FFI functions using that and it'll guarantee the pointer remains valid until C returns
05:36:07 <merijn> If C keeps the pointer after that...you'll have to do your own memory management
05:36:08 * hackagebot network-info 0.2.0.2 - Access the local computer's basic network configuration  http://hackage.haskell.org/package/network-info-0.2.0.2 (JacobStanley)
05:38:44 <absence> merijn: c keeps it, so it's MarshalAlloc.malloc then i guess, and then poke the Storable record to that ptr and return it? (haskell is called from c)
05:38:57 <maukd> absence: e.g. the one about why you're doing all of this, what the data actually looks like, what you mean by "returning", etc
05:39:04 <maukd> basically what the fuck is actually going on here?
05:39:30 <merijn> absence: Yes. But there's also a function that is "Storable a => a -> IO (ForeignPtr a)" which lets you avoid having to poke
05:39:36 <absence> maukd: ah sorry. i'm calling haskell from a dll which implements a c api
05:40:06 <maukd> what's the API?
05:40:12 <merijn> absence: Foreign.Marshal.Utils has "new :: Storable a => a -> IO (Ptr a)"
05:40:12 <absence> maukd: so i'm calling a haskell function that i want to return a marshalled version of a haskell record so i can pass the data to the api
05:40:16 <absence> maukd: vst
05:40:37 <maukd> Venezuelan Standard Time?
05:40:52 <absence> maukd: virtual studio technology
05:41:19 <absence> merijn: ah, thanks for the tip :)
05:42:10 <maukd> ok, I'll try to find some documentation
05:42:14 <maukd> meanwhile
05:42:22 <maukd> absence: why do you have to allocate on the haskell side?
05:43:03 <absence> maukd: documentation isn't available unless you sign up as a third-party developer i think
05:43:46 <absence> maukd: i want to use haskell to write the dll
05:44:22 <absence> maukd: and as little c glue as possible
05:45:03 <maukd> then why do you need to access data structures from C?
05:46:11 <absence> maukd: it's a c api
05:46:17 <absence> the dll is a plugin
05:46:38 <maukd> and?
05:46:50 <absence> and the host needs access to the plugin data
05:47:00 <maukd> why?
05:47:12 <absence> because the api docs say so :P
05:47:17 <maukd> where?
05:47:18 <jamy23> hello fp world!
05:48:22 <vasu_> guys i have a question , how typetraits differ from type classes
05:48:49 <absence> maukd: http://www.steinberg.net/nc/en/company/developer/sdk_download_portal.html
05:48:54 <vasu_> as far as i know , you can give constraints on types using type classes to do sort of polymorphism
05:49:00 <Saizan> vasu_: what are typetraits?
05:49:29 <vasu_> not typetraits my bad
05:49:42 <maukd> absence: there's just a login form there
05:49:52 <vasu_> typestate :supposedly awesome feature of rust language
05:50:15 <maukd> absence: but I can pretty much guarantee you it doesn't say "the host needs to access Haskell data structures"
05:50:32 <vasu_> i tried to follow the paper which described it , but couldn't grok anything
05:50:46 <vasu_> Saizan:any ideas?
05:51:03 <Saizan> ah, i don't know much about rust, sorry
05:51:09 <absence> maukd: of course it doesn't. as a C api it doesn't mention haskell at all
05:51:22 <maukd> absence: right, so why do you keep talking about Haskell records?
05:51:22 <absence> maukd: but it needs data from the plugin
05:51:36 <vasu_> ok
05:51:43 <maukd> absence: elaborate on "needs data"
05:52:22 <ivanm> how do I specify a RULES to say that f . g = id ?
05:52:27 <vasu_> Saizan: are you aware of type constraints in D language or concepts in c++(which didn't make it into C++11)
05:52:38 <absence> maukd: haskell records are a common way to store data in haskell :P
05:53:00 <maukd> absence: irrelevant
05:53:12 <Saizan> absence: i think the issue here is whether the host needs to inspect this data from the plugin or it just needs to pass it around
05:53:13 <ivanm> (for specific f and g)
05:53:31 <absence> Saizan: it does
05:53:31 <vasu_> i don't see any user visible difference , how do they differ atleast in one or two fundamental ways?
05:53:33 <maukd> Saizan: no, it's much more general
05:53:37 <Saizan> vasu_: not deeply, i know concepts were partly inspired by haskell typeclasses
05:53:46 <vasu_> hmm
05:53:50 <maukd> absence: you just answered "yes" to an either/or question
05:54:29 <Saizan> maukd: "it does" means "the former" to me in this case
05:54:36 <absence> maukd: i have no idea what you're talking about :)
05:54:47 <vasu_> u mean typeclasses are more general than concepts?
05:54:50 <maukd> you didn't answer <maukd> absence: elaborate on "needs data"
05:56:02 <Saizan> maukd: maybe you should describe the (or more) possible meaning of "needs data" that you contemplate and give the solution you'd suggest for each
05:56:02 <bartavelle> absence, perhaps the simplest way is to synchronize a "c" memory zone with the content of your haskell data, and have this read by the host program
05:56:16 <bartavelle> might not be practical though
05:56:16 <Saizan> maukd: so absence can then pick the closest alternative
05:56:49 <maukd> Saizan: there are too many possibilities
05:56:54 <absence> maukd: i don't know what you're looking for. it wants data formatted in a specific way in memory
05:57:04 <maukd> absence: oh, suddenly
05:57:19 <maukd> absence: what data and formatted in what way?
05:57:40 <absence> maukd: integers, floating point numbers, callback functions
05:57:44 <maukd> absence: no
05:58:02 <maukd> stop avoiding my questions, dammit
05:58:08 <absence> bartavelle: how do you do that?
05:58:16 <absence> maukd: where are you going with this?
05:58:18 <maukd> absence: I want the actual memory layout
05:58:34 <maukd> absence: well, my goal is to understand the problem you're trying to solve
05:58:38 <maukd> so I can recommend a solution
05:58:48 <maukd> but you keep not giving me the information I need
05:59:15 <bartavelle> absence, don't know, never used the FFI, but if you know how to do it in c, it should not be hard
06:00:09 <absence> maukd: okay there's an int32, four function pointers, five int32, two "reserved" pointers, three int32, a float, two pointers, two int32, two function pointers
06:00:47 <maukd> how is this format specified? as a sequence of bytes or a C struct?
06:00:49 <Botje> and they all walk into a bar?
06:01:03 <bartavelle> Botje :)
06:02:52 <absence> maukd: it isn't documented directly, only a c++ api built on top of the undocumented c api via classes and stuff, so i'm just looking at it as a sequence of bytes
06:03:28 <maukd> o_O
06:03:40 <maukd> that sounds like exactly the wrong approach
06:03:53 <maukd> if it only exists as a C API, you should treat it as a struct (or whatever)
06:04:27 <absence> maukd: well, a struct is a sequence of bytes so it's pretty much the same
06:04:37 <maukd> nonsense
06:04:55 <Botje> structs have padding, for one
06:05:25 <absence> Botje: yep. taken care of in the Storable instance
06:05:26 <maukd> "a pointer" isn't even a type
06:05:35 <Botje> okay
06:05:37 <maukd> absence: Storable instance of what?
06:06:13 <absence> maukd: the haskell record that contains the data to be formatted in memory and given to the c api
06:06:22 <maukd> argh
06:06:24 <maukd> I give up
06:07:12 <bartavelle> absence, I don't see the problem ? You know where all the bits go already right ? The only problem is writing the callback functions ?
06:07:12 <absence> "a pointer" = void* if that's any better
06:08:20 <absence> bartavelle: yes, i learned about the "new" function and the right Ptr type, so i think i know what has to be done, i just tried to answer maukd's questions
06:08:59 <maukd> ... without giving me any information that would actually enable me to write any code
06:09:04 <bartavelle> what is unclear in your explanation is whether that data has to change dynamically, what the callback functions should do, etc.
06:11:43 <absence> bartavelle: ah. the data will be passed back to the callback functions, so it might change. the callback functions do different stuff like query state of the plugin or generate audio
06:12:11 <bartavelle> so the "only" problem is having the callback function query your haskell data ?
06:13:24 <absence> maukd: i'm sure you can't read my mind, but i can't read yours either. sorry, but i think i understand how to set things up, i've managed to marshal some numbers now at least. on to the callbacks
06:13:44 <absence> bartavelle: pretty much
06:14:16 <bartavelle> anyway, I am pretty much inexperienced with the haskell FFI interface, but it will probably involve writing a stub in c that calls the proper haskell function, which will return the data formatted in the way the c program expects
06:14:29 <bartavelle> and returns that
06:17:38 <absence> bartavelle: that's what i'm trying to do
06:18:02 <absence> bartavelle: it's working for integers at least :P
06:19:08 <bartavelle> heh
06:20:05 <cark> anyone has experience using the JuicyPixels module ?
06:26:51 <hpaste> edlinde annotated “Procedural Code” with “Procedural Code (annotation)” at http://hpaste.org/75576#a75616
06:27:39 <padrian2ss> hello haskellers.. one question about the difference b/w results replicateM 2 [1,0] with result [[1,1],[1,0],[0,1],[0,0]] and replicateM 2 (getLine), for the IO action I see difference behaviour, why?
06:27:59 <maukd> padrian2ss: what different behavior?
06:28:22 <padrian2ss> maukd: I don't see any cart combination
06:28:36 <maukd> padrian2ss: what's a cart?
06:28:43 <opqdonut> cartesian
06:28:45 <padrian2ss> remaukd: cartezian
06:28:55 <maukd> padrian2ss: were you expecting one?
06:28:58 <opqdonut> padrian2ss: replicateM in the list monad does a cartesian combination
06:29:00 <cark> the list monad and the io monads are different things
06:29:09 <opqdonut> padrian2ss: because list monad represents choice/nondeterminism
06:29:20 <opqdonut> the IO monad on the other hand represents side-effects
06:29:45 <opqdonut> let's look at what happens in the Maybe monad, which represents failure
06:29:48 <opqdonut> > replicateM 2 (Just 1)
06:29:49 <lambdabot>   Just [1,1]
06:29:52 <opqdonut> > replicateM 2 Nothing
06:29:53 <lambdabot>   Nothing
06:29:58 <padrian2ss> opqdonut: list monad represent nondeterminism? I don'd understand
06:31:03 <cark> padrian2ss:  [1,2] means both 1 and 2 for the rest of the computation
06:31:58 <cark> or is it either ...
06:32:01 <padrian2ss> mmm... I look stupid :)
06:32:16 <padrian2ss> since I don't understand :)
06:32:38 <cark> nondeterminsm = smart way to say cartesian product ..kinda
06:32:54 <padrian2ss> cark :)
06:33:24 <cark> anyways there is plenty literature on the web about the list monad
06:33:41 <cark> people way smarter than myself axlaining it
06:33:46 <cark> explaining*
06:34:00 <padrian2ss> cark, thank you!
06:36:00 <padrian2ss> another question since hoogle can't find it... the prodCart function does exist in haskell math packages?
06:37:10 <padrian2ss> as per Monad.Reader #20th issue
06:38:09 <rwbarton> never heard of it
06:38:56 <padrian2ss> sorry...
06:38:58 <padrian2ss> cartProd
06:39:20 <cark> it is defined at the begining of the article
06:39:20 <padrian2ss> instead of prodCart
06:39:35 <fryguybob> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:cartProd
06:39:39 <cark> but see, you don't need such a function
06:39:52 <cark> that's what list comprehension is for
06:39:56 <padrian2ss> cark: they are saying... "This is a Cartesian product in maths, which can be found in the library haskell- for-maths"
06:40:39 <fmap> @google haskell-for-maths
06:40:40 <lambdabot> http://www.polyomino.f2s.com/
06:40:40 <lambdabot> Title: Haskell for Maths
06:40:54 <rwbarton> well, so it can. was there a question
06:41:12 * hackagebot tup-functor 0.2.0.2 - Homogeneous tuples  http://hackage.haskell.org/package/tup-functor-0.2.0.2 (BalazsKomuves)
06:41:17 <rwbarton> hoogle doesn't index everything on hackage
06:41:30 <padrian2ss> cark: list comprehension is very wide term, a black hole for the list. anything can go there :)
06:42:02 <Cale> > let cartProd = liftM2 (,) in cartProd [1,2,3] [4,5]
06:42:03 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
06:42:21 <Cale> > let cartProd xs ys = [(x,y) | x <- xs, y <- ys] in cartProd [1,2,3] [4,5]
06:42:21 <rwbarton> it's actually sequence
06:42:22 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
06:42:46 <Cale> > let cartProd = sequence in cartProd [[1,2,3],[4,5]]
06:42:47 <lambdabot>   [[1,4],[1,5],[2,4],[2,5],[3,4],[3,5]]
06:43:00 <Cale> > let cartProd = sequence in cartProd [[1,2,3],[4,5],[6,7,8]]
06:43:01 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
06:43:11 <cark> > [[x,y] | x <- [1,2], y <- [2,3]]
06:43:12 <lambdabot>   [[1,2],[1,3],[2,2],[2,3]]
06:44:12 <cark> let cartProd l1 l2 = [[x,y] | x <- l1, y <- l2] in cartProd [0,1] [0,1]
06:44:16 <cark> > let cartProd l1 l2 = [[x,y] | x <- l1, y <- l2] in cartProd [0,1] [0,1]
06:44:18 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
06:46:51 <padrian2ss> very cool function defined as let cartProd = sequence in cartProd [[1,2,3],[4,5],[6,7,8]]
06:48:31 <Cale> Yeah, sequence in a general monad takes a list of monadic actions, and produces an action which runs each in turn, giving a list of the results. In the list monad, "running" a list means to pick an element from it in all possible ways
06:48:58 <Cale> and so you get a list of all possible ways to pick an element from each list, each being a list of the choices made
06:49:47 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return [x,y,z]
06:49:48 <space_leak> hi, i have a (possibly simple) question about space leaks, is this the right channel for that?
06:49:49 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
06:49:53 <Cale> sure
06:50:29 <Cale> (assuming you're talking about space leaks in Haskell of course :)
06:50:38 <space_leak> yes :) thanks
06:50:40 <space_leak> coming in a second
06:51:24 <padrian2ss> thanks everyone, like allways it's a pleasure using this channel
06:51:36 <space_leak>         linesE <- (liftM lines . readFile) error_file_name;
06:51:36 <space_leak>         print (length linesE);
06:51:36 <space_leak>         let map = (foldl' stats_function_f Map.empty linesE)
06:51:36 <space_leak>         in
06:51:36 <space_leak>           print (Map.lookup "num_error_injected" map);
06:52:24 <space_leak> this is how i process a file which has lines like this: "something: number @number"
06:53:20 <Cale> okay
06:53:26 <space_leak> so, the stats_function_f matches a regex for the lines and keeps passing a "Data.Map" inside the fold
06:53:49 <Cale> are you using a Strict Map?
06:53:53 <space_leak> until now, do you see any problems? basically this code leaks and cannot produce anything
06:53:57 <space_leak> no
06:53:59 <space_leak> i am using Data.Map
06:54:40 <space_leak> i'll try now
06:54:42 <Cale> I'm assuming what's happening is that you're accumulating an expression in one of the elements of the Map and not evaluating that expression until you actually go to print it.
06:54:49 <Cale> (or maybe not at all)
06:55:25 <Cale> You could also just be careful that stats_function_f will actually evaluate things before putting them into the new map
06:57:13 <Cale> actually, it's the same datastructure, but you might find it convenient to use the operations from that module
06:57:33 <space_leak> is it Data.Map.Strict?
06:57:36 <Cale> yeah
06:57:57 <space_leak> my version doesn't have that i guess i need to install that with cabal
06:58:09 <Cale> oh, in that case don't bother
06:58:31 <Cale> Just use seq or $!
06:58:43 <space_leak> i just tried using `seq` before adding the "key" and the "value" to the map but that doesn't seem to help
06:58:55 <Cale> how did you do that?
06:59:10 <Cale> It should look something like:
06:59:43 <space_leak>         stats_function_f map line =
06:59:44 <space_leak>             do {
06:59:44 <space_leak>               let match = (line =~ "(.*): (.*) @(.*)" :: [[String]])
06:59:44 <space_leak>               in
06:59:44 <space_leak>                 if match == [] then
06:59:46 <space_leak>                     map
06:59:48 <space_leak>                 else
06:59:51 <space_leak>                     let key = (head (tail (head match)))
06:59:53 <space_leak>                         value = (head (tail (tail (head match))))
06:59:56 <space_leak>                         cycle = (head (tail (tail (tail (head match)))))
06:59:58 <space_leak>                     in key `seq` value `seq` cycle `seq` map `seq`
07:00:01 <geekosaur> please don't paste into the channel
07:00:01 <space_leak>                       let newMap = (Map.insert key value map)
07:00:03 <space_leak>                       in
07:00:06 <space_leak>                         if (read cycle :: Int64) <= num then
07:00:08 <space_leak>                             map
07:00:11 <space_leak>                         else
07:00:13 <carpi> is it possible for 'main' to take a parameter?
07:00:13 <space_leak>                             newMap
07:00:16 <space_leak>             }
07:00:18 <space_leak> this is how it looks like
07:00:21 <space_leak> sorry!
07:00:33 <Cale> carpi: no, but obviously you can make an immediate helper
07:00:34 <geekosaur> @index getArgs
07:00:34 <lambdabot> System.Environment
07:01:38 <shapr> SHAZAM!
07:01:41 <Cale> space_leak: okay, try this:
07:01:47 <shapr> Perhaps Yi needs a snobol mode too?
07:01:47 <byorgey> space_leak: hpaste.org
07:01:59 <carpi> thanks
07:02:10 <space_leak> thanks byorgey
07:02:14 <space_leak> i'll use that
07:03:03 <hpaste> space_leak pasted “space leak” at http://hpaste.org/75617
07:04:33 <cark> how do I cast an Int to a Double ?
07:04:38 <maukd> fromIntegral
07:04:40 <maukd> and it's not a cast
07:04:45 <space_leak> @Cale, did you write anything, did i miss it?
07:04:46 <lambdabot> Unknown command, try @list
07:05:05 <cark> err sorry I meant cast a double to an Int
07:05:13 <space_leak> Cale: did you write anything, did i miss it?
07:05:22 <maukd> cark: there are no casts
07:05:28 <maukd> cark: what do you want to happen?
07:05:43 <cark> I have an double, and i need to use it in as a double =P
07:05:52 <rwbarton> sounds easy
07:05:52 <cark> as an Int =/
07:05:57 <rwbarton> sounds hard
07:06:03 <cark> harder =)
07:06:09 <rwbarton> how do you "use 3.7 as an Int"
07:06:32 <cark> oh truncate function is what i need
07:06:33 <int-e> > [floor 3.7,ceil 3.7] :: [Int]
07:06:34 <lambdabot>   Not in scope: `ceil'
07:06:39 <hpaste> Cale annotated “space leak” with “space leak (annotation)” at http://hpaste.org/75617#a75618
07:06:43 <byorgey> round, floor, ceil, truncate  -- cark, choose one
07:06:48 <Cale> space_leak: try that ^^
07:06:52 <byorgey> oh, ceiling, not ceil
07:06:56 <byorgey> > ceiling 3.7
07:06:57 <lambdabot>   4
07:07:03 <cark> i've been banging poor hoogle, but didn't get the type right =P
07:07:04 <int-e> yeah
07:07:14 <cark> thanks !
07:07:33 <Cale> space_leak: there are several things to note about your original code...
07:07:37 <rwbarton> @hoogle Double -> Int
07:07:38 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
07:07:38 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
07:07:38 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
07:07:40 <rwbarton> heh
07:07:42 <Cale> space_leak: 1) do is superfluous here
07:07:55 <Cale> (it is only used to glue together actions in some monad
07:07:56 <Cale> )
07:08:48 <Cale> 2) Think of let as a way to allocate named expressions on the heap, and case as a way to force evaluation to occur by pattern matching
07:08:48 <maukd> > sizeOf 3.7
07:08:50 <lambdabot>   Not in scope: `sizeOf'
07:08:59 <rwbarton> when I saw that big paste I honestly thought it was an ML program
07:09:04 <Cale> (this isn't quite 100% true, but it's fairly valid)
07:09:35 <maukd> oh god, all the cadddr's
07:09:57 <Cale> maukd: indeed
07:10:58 <Cale> space_leak: 3) Don't use head and tail. They're there, but you basically don't need them. You should only use them after you're sure they're more convenient than pattern matching, and only then very carefully, because they die if the list is empty.
07:11:00 <ion> cadaver
07:11:37 <osfameron> naming yourself after what bug you're investigating is pretty extreme
07:12:03 <Cale> space_leak: 4) If you want to test if a list is empty, either pattern match or use the function 'null'. Try not to use xs == [], if only because it requires an Eq instance that isn't actually required.
07:12:17 <ion> hetatatahetahead
07:12:23 <maukd> but space_leak is a cool name
07:12:23 <space_leak> Cale: this still causes a leak
07:12:28 <Cale> space_leak: okay!
07:12:35 <rwbarton> right, Cale didn't change what your program does at all
07:12:39 <space_leak> but i'll keep in mind your suggestions
07:12:49 <int-e> ion: replicate 100 "Haskell is not Lisp"
07:12:52 <Cale> Well, I did change it ever so slightly
07:12:59 <rwbarton> well, maybe
07:13:00 <Cale> But I didn't expect to fix anything there
07:13:05 <ion> > replicateM 100 "Haskell is not Lisp"
07:13:06 <lambdabot>   ["HHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHH...
07:13:09 <space_leak> rwbarton: do you have a suggestion?
07:13:09 <rwbarton> not with all the seqs though
07:13:24 <t7> whats is x  to the power of 1/2 ?
07:13:34 <ion> y
07:13:48 <maukd> √x
07:13:58 <t7> > pow 10 (1 / 2)
07:13:59 <lambdabot>   Not in scope: `pow'
07:13:59 <rwbarton> space_leak, I came in midway through the conversation but surely the problem depends on how you are using stats_function_f
07:14:12 <Cale> rwbarton: it's the argument to foldl'
07:14:21 <rwbarton> sounds fine then
07:14:37 <int-e> > 10 ** (1/2)
07:14:38 <lambdabot>   3.1622776601683795
07:14:39 <space_leak> and the list it's working on is read from a file with lines
07:15:02 <maukd> > 10 ** 0.5 ** 2
07:15:04 <space_leak> with liftM, of course
07:15:04 <lambdabot>   1.7782794100389228
07:15:08 <Cale> I'm inherently distrustful of the regex library
07:15:12 <maukd> > (10 ** 0.5) ** 2
07:15:13 <lambdabot>   10.000000000000002
07:15:19 <maukd> > 10 ** (0.5 * 2)
07:15:21 <lambdabot>   10.0
07:16:06 <rwbarton> is this the only thing your program does? why do you think there is a space leak?
07:16:18 <t7> O(N ^ (1/2))    why not just write O(sqrt N) ?
07:16:24 <space_leak> rwbarton: yes, that's inside the main
07:16:33 <space_leak> and for a file of 200MB
07:16:39 <space_leak> it consumes around 10GB of memory
07:16:42 <space_leak> and dies
07:17:12 <rwbarton> oh
07:17:14 <rwbarton> that sounds plausible
07:17:21 <rwbarton> what kind of thing is "value"?
07:17:28 <clahey> Yo haskell peeps!
07:17:29 <space_leak> it's just a string
07:17:34 <space_leak> key is also a string
07:17:47 <space_leak> it's less than 15 characters
07:17:53 <space_leak> if that's what you're asking
07:17:59 <rwbarton> do key and value add up to most of the length of the line?
07:18:07 <Cale> yes, they would
07:18:11 <rwbarton> how many total bytes in key and value are you storing
07:18:16 <rwbarton> and are you on a 64-bit platform
07:18:20 <Cale> oh, well, I guess cycle could :)
07:18:22 <space_leak> yes i am
07:18:28 <clahey> String was going to be my guess.
07:18:34 <rwbarton> okay
07:18:53 <space_leak> in key and value, it's not big
07:18:54 <rwbarton> it costs some ungodly number of bytes to store a character of a String and double that on a 64-bit platform
07:18:59 <rwbarton> so you don't have a space leak
07:19:05 <rwbarton> you just have something that takes a lot of space
07:19:12 <Cale> I agree
07:19:33 <space_leak> i have the same program in ocaml (again with a map structure and on the same architecture)
07:19:33 <rwbarton> I mean 10GB is only 40 times 200MB
07:19:37 <clahey> space_leak: How did you load the file?
07:19:43 <rwbarton> haha I guessed right :)
07:19:46 <space_leak> it doesn't use any memory at all
07:19:48 <Sculptor> hi!
07:20:19 <space_leak> the thing with the map is that
07:20:24 <space_leak> there aren't that many keys in the file
07:20:25 <clahey> Is there a lazy Text class like there are lazy ByteStrings?
07:20:30 <clahey> So that append is super fast?
07:20:35 <rwbarton> what do you mean
07:20:42 <rwbarton> keys are repeated?
07:20:44 <space_leak> it's more like 1000 lines of keyx: 1 @ 2
07:20:45 <space_leak> yes
07:20:52 <rwbarton> hmm
07:20:53 <space_leak> i mean the numbers change
07:20:56 <Cale> space_leak: String = [Char], and Char is a boxed 32 bit character, but probably both the box and actual value are 64 bits on a 64 bit arch, so that's 16 bytes just for each Char, and then you can expect each cons cell of the list to be 3 words, which is another 24 bytes
07:20:57 <space_leak> at every line
07:21:28 <rwbarton> so what is going on, you overwrite the old value in the map at that key?
07:21:30 <space_leak> but if the map updates the keys then it shouldn't take up that much space
07:21:33 <rwbarton> when you see a new one with the same key?
07:21:40 <space_leak> doesn't add do that?
07:21:50 <Cale> space_leak: so that's 40 bytes for each element of the list
07:21:51 <rwbarton> yes but I wanted to make sure you thought that was what was going on
07:22:06 <space_leak> yes, basically
07:22:18 <space_leak> i am trying to get a map of keys until a given cycle
07:22:22 <rwbarton> I suggest outputing the total length of keys and values of the map once you have constructed it
07:22:24 <Cale> (each element of each string)
07:22:26 <space_leak> and it should have the latest values
07:22:29 <space_leak> of the keys
07:22:39 <rwbarton> ah i see
07:22:43 <Cale> space_leak: Another option would be to use Data.Text
07:22:43 <space_leak> it is around 10 keys
07:22:44 <rwbarton> that kind of cycle
07:22:49 <Cale> Or even Data.ByteString
07:22:56 <space_leak> with 15 characters
07:23:09 <space_leak> that shouldn't take up too much space
07:23:35 <space_leak> i mean if you are suggesting Data.Text or Data.ByteString to save space
07:23:55 <Cale> ah, the map only grows to 10 keys?
07:23:58 <space_leak> because what the data.map will have is really a small piece of data in the end
07:24:00 <space_leak> yes
07:24:27 <space_leak> i was wondering if there would be a problem because i am reading the file using lines
07:24:33 <clahey> space_leak: Have you posted the code somewhere we can read it or is it for a class or something?
07:24:33 <Cale> nope
07:24:35 <space_leak> i mean readFile and then lines
07:24:41 <Cale> lines is totally fine
07:24:47 <rwbarton> readFile and then lines is normal
07:25:05 <rwbarton> have you tried any of the space profiling tools?
07:25:06 <space_leak> clahey: it is here: http://hpaste.org/75617#a75618
07:25:29 <int-e> space_leak: I think we'd be happier with the whole program
07:25:53 <rwbarton> or an alternative suggestion, Cale could well be right about the regex library doing something funny. try just using words
07:25:55 <int-e> space behaviour in haskell is not very modular
07:26:08 <t7> @hoogle (=~)
07:26:09 <lambdabot> Text.Regex.Posix.Wrap (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
07:26:09 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
07:26:15 * hackagebot fb 0.12.7 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.12.7 (FelipeLessa)
07:26:49 <hpaste> space_leak annotated “space leak” with “space leak (annotation)” at http://hpaste.org/75617#a75619
07:27:03 <rwbarton> durr
07:27:07 <t7> > "Hello World!" =~ "^[ ]+"
07:27:09 <lambdabot>   No instance for (Text.Regex.Base.RegexLike.RegexContext
07:27:09 <lambdabot>                    ...
07:27:17 <rwbarton> line 23 -- you can't do that
07:27:28 <Cale> ahaha
07:27:34 <Cale> right, I missed that
07:27:39 <space_leak> that was for debugging
07:27:40 <rwbarton> you just forced your program to store the entire input file in memory as a String
07:27:41 <space_leak> it's not there
07:27:45 <space_leak> normally
07:28:11 <rwbarton> well hopefully it was not to debug the space leak
07:28:16 <otters> dudes, what library should I use for parsing and generating YAML
07:28:27 <Cale> space_leak: Well, okay, show us the program you're actually running
07:28:40 <space_leak> yep, apparently, forgetting that gave me my nickname
07:29:41 <Cale> space_leak: Do you see why rwbarton's claim is correct?
07:30:32 <Cale> space_leak: When it prints the length of linesE, it will have to run through the input far enough to know what the length of linesE is, which means, all of it. The list linesE is not garbage though, because you have a reference to it on the very next line.
07:30:32 <space_leak> but the problem is because of lazy evaluation right? because even storing the whole program would not take up that much space
07:30:46 <rwbarton> no
07:30:48 <Cale> Not really
07:30:48 <rwbarton> you mean the whole input?
07:30:59 <int-e> no, it does really take up so much space, using String
07:31:00 <space_leak> i mean yes
07:31:02 <space_leak> the whole input
07:31:22 <Cale> space_leak: String is a linked list of 32 bit Unicode characters.
07:31:24 <int-e> (which is why libraries such as text and bytestring exist)
07:31:32 <rwbarton> if you were using strict IO then you wouldn't be surprised that reading a 200 MB file takes 200 MB of memory already on line 22
07:31:33 <otters> wow, yaml has a LOT of dependenices
07:31:35 <space_leak> ah ok
07:31:44 <Cale> (which are even bigger on a 64 bit platform, just because)
07:31:59 <space_leak> so String is not really a string of char's
07:32:11 <rwbarton> it is a list of Characters
07:32:15 <Cale> It is a list of Char
07:32:17 <rwbarton> er
07:32:19 <rwbarton> yes, that
07:32:19 <Cale> but Char is big
07:32:22 <otters> type String = [Char]
07:32:26 <Cale> Char isn't like C's char
07:32:34 <otters> > maxBound :: Char
07:32:35 <lambdabot>   '\1114111'
07:32:39 <int-e> String = [Char]. literally a linked list of Char values, which are themselves boxed.
07:32:43 <space_leak> cool, and to use it like C's chars i need to use ByteString?
07:32:44 <rwbarton> and lists have substantial per-object overhead when the objects they store are not large
07:32:49 <otters> correct
07:32:56 <int-e> (Does ghc share "small" Char values?)
07:32:59 <rwbarton> it shouldn't matter for your program, here
07:33:07 <Cale> int-e: I think it does actually
07:33:07 <space_leak> yes, asking for general use
07:33:10 <rwbarton> you can delete line 23 and it should run in a small amount of space
07:33:14 <space_leak> in case i want to count lines :)
07:33:17 <space_leak> yes it does
07:33:22 <space_leak> thanks all!
07:33:23 <rwbarton> or you can keep it and switch to ByteString and use 200MB like you expect
07:33:42 <int-e> but even so, the list spine alone weighs at 24 bytes a character, and copying GC means you'll be using twice as much memory easily.
07:33:42 <rwbarton> or you can read the file twice :)
07:33:53 <clahey> rwbarton: Would it work to read the file twice?
07:33:57 <rwbarton> after all that 200MB is already on the disk
07:34:11 <clahey> And it'll probably fit in your file cache.
07:34:36 <rwbarton> clahey: as long as you consume the result of each read once, sure why not.
07:34:55 <JohnBat26> How separate DateTime field at Date and Time in View (simple_form)?
07:35:01 <rwbarton> ghc won't go behind your back and try to cache the result of reading the file or anything
07:35:39 <Cale> JohnBat26: I don't understand your question. What is DateTime?
07:35:46 <absence> ghc says "cannot satisfy -package win32" and says to use -v for more info, but there's no more info
07:36:05 <absence> anyone know why?
07:36:08 <JohnBat26> Cale: I have field action_date: DateTime in mongoid
07:36:28 <Cale> JohnBat26: Are you sure this is the right channel?
07:36:38 <JohnBat26> Cale: yes
07:36:40 <Cale> JohnBat26: Isn't mongoid a ruby library?
07:36:50 <JohnBat26> OOps
07:36:55 <JohnBat26> sorry
07:37:45 <ocharles> Hey, trying to persuade $work that our next programming language should be Haskell, and one of my points was "Defining functions outside classes is quite important for code reuse (so preferably not a everything-is-an-object language)", and I have some backlash against this comment
07:37:47 <ocharles> 'I think I disagree and don’t see how exactly having functions outside classes helps for code reuse.'
07:37:52 <ocharles> any idea how I can back up my statement
07:37:53 <ocharles> ?
07:38:04 <ocharles> I know I don't want classes with only static methods, but I can't quite say why...
07:38:20 <Cale> That's not the real problem, I think...
07:38:39 <Cale> Classes with only static methods are equivalent in some sense to modules, and modules are okay.
07:38:44 <ocharles> yea
07:38:57 <osfameron> ocharles: do you have buyin from your team to write FP?
07:38:59 <ocharles> I don't think I worded myself very well
07:39:06 <ocharles> osfameron: what do you mean?
07:39:11 <clahey> So, { print . length . getLines $ error_file_name; print . Map.lookup "num_error_injected" . getLines $ error_file_name; where getLines = liftM lines . readFile }
07:39:13 <clahey> Something like that?
07:39:49 <osfameron> ocharles: your argument seems very esoteric.  What will stop you getting haskell in would be, for example, people not wanting to learn a new language.  Or thinking haskell is hard/slow/weird.  etc.
07:39:56 <clahey> Oh, that doesn't work because getLines returns a Monad.  hmm.
07:40:02 <Cale> clahey: Presumably with something to build a Map somewhere in it too
07:40:06 <osfameron> ocharles: do they like the libraries?  will they be able to use components they've developed in other systems, etc. ?
07:40:12 <ocharles> osfameron: oh there are plenty of other arguments, this is just one point that I don't have a good answer for
07:40:19 <Philonous_> clahey:  A monadic action, not a monad
07:40:26 <clahey> Cale: Oh, yeah, I forgot to mention that one.
07:40:29 <clahey> Philonous_: Touché.
07:40:31 <Cale> an IO action, most likely
07:40:48 <Cale> (the fact that IO is a monad isn't terribly relevant)
07:40:50 <ocharles> osfameron: people would be ok with moving to haskell if meets other criteria. i'm just trying to make it meet all the criteria :)
07:40:54 <Philonous_> clahey:  I'm not trying to score points
07:41:14 <ocharles> osfameron: other criteria being 'has a good ecosystem', 'has an active community' etc. we're currently debating on how exactly to quantify those things
07:41:18 <osfameron> ocharles: heh.  I guess you could just let that one point slide?
07:41:32 <rwbarton> hmm, a UTF-8-backed Text type would be nice if you want to mmap a text file
07:41:44 <osfameron> ocharles: are you currently at a perl shop?
07:41:49 <ocharles> osfameron: ya
07:42:03 <osfameron> it's cool that they're even thinking about moving wholesale!
07:42:08 <Cale> heh, almost anything would be better
07:42:36 <Cale> lol, watch them switch to groovy
07:42:46 <ocharles> for those interested in reading the oncoming religious war: https://docs.google.com/document/d/1F6cHl_hCDRp2mux2torXTZIxrgZ9yREfqNVYp8vKwNA/
07:42:58 <clahey> So, maybe, { getLines error_file_name ==> print . length; getLines error_file_name ==> print . Map.lookup "num_error_rejected" . (foldl' stats_function_f Map.empty); where getLines = liftM lines . readFile }
07:43:00 <osfameron> Cale: hah!  but perl > groovy by some margin
07:43:17 <Cale> osfameron: Yeah, that's what I meant by "almost anything"
07:43:48 <maukd> ocharles: needs a login
07:43:55 <ocharles> maukd: only to google, no?
07:44:12 <maukd> yes
07:44:15 <maukd> "only"
07:44:20 <ocharles> i can't help that i'm afraid
07:44:26 <frerich> ocharles: I do have a google login, but it redirects me to another URL which lets me edit an empty page.
07:44:28 <clahey> Philonous_: I know you're not trying to score points.
07:44:37 <ocharles> https://docs.google.com/document/d/1F6cHl_hCDRp2mux2torXTZIxrgZ9yREfqNVYp8vKwNA/edit maybe?
07:44:41 <ocharles> that /edit might have been important
07:44:55 <frerich> ocharles: That works.
07:45:51 <Cale> "The boss' nephew really likes Minecraft, so you're all going to be programming our web backend in Redstone circuitry in Minecraft, with a mod to the game to support input and output."
07:46:09 <ocharles> i would totally work for that company
07:46:23 <maukd> "Community participation in Perl 5 is declining"  [citation needed]
07:46:30 <ocharles> maukd: i said that, yea
07:46:42 <ocharles> maukd: but if you just look at job offers graphs, year on year that /is/ declining
07:46:56 <maukd> but that's not community participation
07:46:58 <osfameron> Cale: how generous of you ;-)
07:47:04 <ocharles> maukd: i suppose that's true
07:47:04 <int-e> Cale: old geezers would be using game of life
07:47:09 <maukd> what's a "compilation/linting tool"?
07:47:20 <ocharles> maukd: ghc & hlint, for example
07:47:22 <maukd> I mean, do you want a freestanding executable or a static code checker?
07:47:31 <ocharles> i personally would like both of them
07:47:31 <maukd> those are quite different goals
07:47:39 <maukd> well, perlcritic is a linter
07:47:56 <maukd> par is an application packer
07:47:57 <ocharles> perlcritic is also fairly meh, in my experience
07:48:11 <ocharles> par is pretty deprecated, i remember that catalyst moved away from recommending its use
07:48:35 <maukd> use for what?
07:48:36 <osfameron> there's FatPacker now?
07:48:45 <ocharles> maukd: deployment
07:49:37 <osfameron> ocharles: what's a DAL?
07:49:51 <Cale> lol, you could install the RedPower 2 mod, and program it in FORTH on the 6502-based machines that mod adds to the game :D
07:49:51 <ocharles> maukd: par hasn't been active since 2004 according to cpan
07:49:56 <ocharles> osfameron: data access layer
07:50:03 <osfameron> ah, ta
07:50:49 <ocharles> maukd: oh, I might be looking at the wrong dist
07:51:40 <Cale> int-e: It would be magnificent to have a big table display with the game of life wizardry that you could show people: "and this is our web server"
07:51:51 <osfameron> yeah, refcounting bugs in perl can be a pain.  They *can* be debugged though
07:52:53 <maukd> "    Code should be self documenting, shoud be able to see what the code is meant do without having to read the code itself." - lol wut
07:53:22 <Cale> "You can see the requests coming in on the left here, as parallel waves of gliders."
07:53:32 <ocharles> i didn't get much of that point :) but hey, at least the type system does do a bit of that
07:53:33 <int-e> maukd: that leads to things like   let a' = a + 1 -- a' is now the successor of a
07:53:56 <int-e> maukd: so you have a choice whether to read the code or the comments :)
07:54:06 <ocharles> that would be documenting, not self-documenting
07:54:41 <Cale> "You keep using that word, I do not think it means what you think it means"
07:55:13 <int-e> Cale: and the spaceship to the right is an approaching ping of death :)
07:55:17 <rking> I think that means your symbol names should explain the definitions well enough that you can make reasonable assumptions and move quicker.
07:55:32 <maukd> rking: that's not a language feature, though
07:56:17 * hackagebot lockfree-queue 0.2 - Michael and Scott lock-free queues.  http://hackage.haskell.org/package/lockfree-queue-0.2 (RyanNewton)
07:56:25 <int-e> Cale: (game of life can have visually appealing software crashes)
07:56:46 <osfameron> ocharles: interesting reading
07:57:43 * ski idly wonders how to do RTCG in game of life
07:57:59 <otters> where's the global cabal-dev config file?
07:58:02 <osfameron> ocharles: what are the other proposed languages?
07:58:11 <ocharles> osfameron: there are no proposed languages yet, we're just trying to see what we want
07:58:35 <ocharles> but if we go by the 'someone must be proficient in it' and we have a team of 3, I think the only possible languages are Perl, Python, Java, Haskell
07:58:37 <ocharles> and maybe PHP
07:58:37 <Cale> lol, wtf. LinkedIn can't find an account associated to my email, but somehow I am subscribed to messages and people can send me invites still.
07:58:52 <Cale> whatever, I guess they have an unsubscribe link
07:59:08 <maukd> I don't understand "Perl syntax without a style guide leaves a lot to be desired" and "Errors are hard to decipher"
07:59:15 <maukd> or rather, I don't agree
07:59:21 <Cale> int-e: :D
07:59:36 <ocharles> maukd: try removing random semi colons and tell me that you always get a clear message
07:59:48 <osfameron> perl's error reporting is actually superb compared to most other languages
07:59:55 <maukd> ocharles: try a random error message from PHP or g++
08:00:00 <osfameron> or Ruby
08:00:14 <ocharles> often the actual problem is narrowed down to a line with a vague error message (with lines of garbage after)
08:00:21 <ocharles> i wrote that from experience
08:00:27 <ocharles> i'm sorry to hear it hasn't matched your experience
08:00:43 <maukd> yeah, I tend to not forget random semicolons
08:00:58 <ocharles> heck, just now:
08:00:59 <ocharles> carton exec -- plackup -d -Ilib -s FCGI -E deployment -S fcgi.socket --nproc 20 -keep-stderr=1
08:00:59 <ocharles> Error while loading 20.pm: No such file or directory at (eval 5) line 4.
08:01:02 <ocharles>  
08:01:10 <ocharles> that's literally it
08:01:19 <maukd> that's not a perl message
08:01:27 <ocharles> that is entirely from Perl.
08:01:27 <osfameron> it is
08:01:33 <maukd> it is?
08:01:43 <osfameron> but it's going through 2 layers of crack (plackup and carton)
08:01:45 <ocharles> yes, carton is a like Bundler for Ruby
08:02:17 <ocharles> and carton is basically just a frontend to local::lib
08:02:20 <maukd> I can't find "Error while" in perldoc perldiag
08:02:42 <ocharles> maukd: i don't care if it's in the language, or in a module provided by the ecosystem in that language. it's the same to me
08:02:53 <ocharles> if i can't use this language productively without good error reporting, then it is wasting my time
08:03:00 <ocharles> and right now, it is wasting my time.
08:03:28 <geekosaur> so IU'm looking at that and thinking that looks inconsistent.  --nproc=20 --keep-stderr=1 ?
08:03:42 <geekosaur> (note that the missing = could well trigger such error)
08:03:43 <maukd> yeah, 20.pm is obviously bogus
08:03:56 <ocharles> that is indeed the problem, but it worked before updating libraries
08:04:05 <ocharles> and was it really that obvious? I don't think it was
08:04:10 <maukd> it was to me
08:05:19 <osfameron> so that's a plackup usability enhancement perhaps
08:05:22 <geekosaur> ocharles, there are standards for parameter formats, specifically because bouncing random paramerters through multiple levels of wrappers is a nightmare otherwise
08:05:37 <ocharles> yes, of course, but why was I not told "nproc" requires a parameter?
08:05:39 <clahey> :t fmap lines
08:05:40 <lambdabot> forall (f :: * -> *). (Functor f) => f String -> f [String]
08:05:44 <clahey> :t fmap lines readFile
08:05:46 <lambdabot>     Couldn't match expected type `[Char]'
08:05:46 <lambdabot>            against inferred type `IO String'
08:05:46 <lambdabot>       Expected type: FilePath -> String
08:05:53 <ocharles> with optparse-applicative that would have failed parsing and I would have been given a useful message
08:06:31 <maukd> that depends
08:06:31 <clahey> :t fmap lines (readFile "filename")
08:06:32 <lambdabot> IO [String]
08:06:34 <geekosaur> ocharles, you have multiple layers of wrappers, error reporting is going to suck no matter what
08:06:43 <ocharles> baseless-assertion.jpg
08:06:48 <maukd> ocharles: right now I'm trying to figure out what 'plackup -d' means
08:06:53 <maukd> geekosaur: I don't agree
08:06:58 <geekosaur> because parse problems can happen at one layer but the definition of the parameter is at a different layer
08:07:03 <ocharles> maukd: apparently, nothing any more! joy.
08:07:10 <ocharles> it's now -D
08:07:57 <ocharles> we could argue about me being a retard right now all we wanted, but the point is this type of stuff is almost a weekly occurance
08:08:17 <ocharles> and I've been doing this for 4 years. so either I'm a horrible horrible programmer and should change careers, or this language is adding more friction than it needs to
08:08:22 <geekosaur> I'm not saying you;re anything but unfamiliar with standards --- while also noting the author of whatever package(s) are involved are *also* unfamiliar
08:08:44 <maukd> >implying language
08:08:53 <geekosaur> (and, sadly, that applies to a lot of people, many of whom really ought to know)
08:09:18 <ocharles> geekosaur: sure, which is why I'm a big fan of stuff like haskell that makes me understand the whole domain and is very happy to say "hey dummy! you forgot about this bit"
08:09:28 <boara> ocharles: if something has negative utility, post to your blog how much it sucks and then continue life.
08:09:29 <ocharles> i'm human, I definitely forget/misunderstand things all the time
08:09:57 <boara> ocharles: I search for $TECH sucks before I use it often.
08:09:59 <osfameron> ocharles: someone could write poor option-handling code, or change the usage for a Haskell library as well as a Perl one.  The question there is:  is there a big and enthusiastic enough development community to fix it?
08:10:06 <ocharles> but anyway, i'm derailing conversation in here way too much and as much as I dislike perl it is my job so I better get back to writing it :)
08:10:14 <maukd> ocharles: ok, I found out what the error means. the problem is that there is no --nproc option
08:10:34 <ocharles> maukd: yes there is, see Handler::FCGI
08:10:43 <maukd> plackup configures Getopt::Long to pass unrecognized options on to the application
08:10:47 <maukd> ocharles: what
08:11:05 <ocharles> https://metacpan.org/module/Plack::Handler::FCGI. osfameron: sure, you could, but you'd be working against the grain to produce something bad
08:11:08 <maukd> what does Handler::FCGI have to do with plackup?
08:11:09 <ocharles> I do think that highly of haskell
08:12:58 <maukd> ocharles: out of interest, does 'carton exec -- plackup -d -Ilib -s FCGI -E deployment -S fcgi.socket -- --nproc 20 -keep-stderr=1' fix it or cause other errors?
08:13:11 <osfameron> ocharles: you'd also be working against the grain of haskell to provide useful documentation... but that's another story ;-)
08:13:31 <ocharles> osfameron: sadly :(
08:13:43 <ocharles> maukd: I don't know, but I've got to get back to work shipping code reviews now
08:13:59 <maukd> ah, ok
08:14:01 <ocharles> i appreciate your sentiments that Perl is not 100% evil and I do agree. but it's causing my enough friction now for me to say "thanks, but bye"
08:14:12 <maukd> in any case I think the Plack::Handler::FCGI docs are broken
08:14:33 <maukd> yes, except it's not perl
08:14:41 <ocharles> no, but it's in the perl ecosystem
08:14:42 <maukd> and using Haskell to do this wouldn't fix anything
08:14:48 <maukd> I disagree
08:15:03 <ocharles> it's not /this/ single problem
08:15:06 <ocharles> it's a whole world of problems
08:15:12 <maukd> the root of this particular problem is the design of the command line interface of plackup IMHO
08:15:36 <ocharles> it's someone forgetting to check for defined. it's someone forgetting to pass a hash reference, not a hash. it's someone having to wade through a Moose'ed up stack trace to find what the problem is
08:15:46 <maukd> you could implement the same design in Haskell (and not get a stack trace)
08:15:49 <ocharles> there are countless bugs that just don't need to exist
08:16:23 <osfameron> this is true
08:16:48 <osfameron> ocharles: I'm sad that you're leaving Perl, but excited if it means you get to move to Haskell ;-)
08:17:14 <maukd> it's all good as long as I get software that sucks less
08:18:02 <maukd> "2. Should have a rich standard library and a rich ecosystem of available modules" looks like a good discriminator
08:18:31 <maukd> that is, it's empirically testable and excludes lots of languages
08:19:06 <ocharles> i think that 'someone must be proficient' is the most important thing, and may well just result in us staying with Perl and having to rethink our code guidelines to avoid bugs
08:19:12 <ocharles> (ie, liberal use of Params::Validate)
08:19:37 <ocharles> (we are a team of 3)
08:19:50 <ocharles> 3 + volunteers, to be fair.
08:19:57 <maukd> then why are there 8 colors?
08:20:05 <shachaf> Cale: It's not really worthwhile to have a generalized-to-any-Monoid DList-style module, is it?
08:20:22 <shachaf> Given that Endo has the right instance already, so it pretty much consists of two functions.
08:20:39 <ocharles> maukd: those would be the volunteers
08:21:03 <shachaf> On the other hand the type of Endo is much more general than the (foo ++)
08:21:15 * shachaf .russian.moed
08:41:18 * hackagebot parse-dimacs 1.3 - DIMACS CNF parser library  http://hackage.haskell.org/package/parse-dimacs-1.3 (DenisBueno)
08:41:56 <tac-tics> Can someone remind me of the definition of a positive functor?
08:42:26 <ski> tac-tics : covariant, maybe ?
08:43:37 <shachaf> ski: Aren't all functors covariant?
08:43:41 <shachaf> ...Well, all Functors.
08:44:13 <n-dolio> Positive is covariant.
08:44:17 <otters> how do I convert an Integer to a Double
08:44:19 <otters> ?
08:44:27 <ski> otters : `fromIntegral'
08:44:28 <otters> I swear, all these numeric typeclasses are the worst part of Haskell
08:44:41 <otters> No instance of Integral Double
08:44:59 <ski> > fromIntegral (42 :: Integer) :: Double
08:45:01 <lambdabot>   42.0
08:45:12 <ski> otters : sounds like you want a conversion in the opposite direction ?
08:45:20 <otters> huh
08:45:41 <otters> does lambdabot have a Double instance that the stdlib doesn't?
08:45:53 <otters> No
08:46:15 <otters> Oh man, I was looking at the long error message.
08:46:19 <otters> ski: I did want a conversion in the opposite direction
08:46:23 <otters> *wrong
08:46:25 <ski> @type ceiling
08:46:27 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:46:28 <ski> @type floor
08:46:30 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:46:30 <geekosaur> if it's looking for Integral Double then it probably wants you to use floor or round
08:46:32 <ski> @type truncate
08:46:34 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:46:35 <ski> @type round
08:46:36 <t7> @hoogle IO String
08:46:36 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
08:46:38 <geekosaur> yeh
08:46:41 <lambdabot> Did you mean: :: IO String
08:46:41 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
08:46:41 <lambdabot> System.IO.Error ioeSetErrorString :: IOError -> String -> IOError
08:46:48 <tac-tics> Is a positive functor a KIND-OF covariant functor? Or are the two terms synonyms?
08:46:50 <geekosaur> and the fact thatthere's 4 of them should tell you why it's not automatic
08:47:11 <geekosaur> (C does truncate, which is often the wrong thing)
08:59:09 <clahey> So, I was thinking about the fact that functions can be polymorphic based on their return type.
08:59:12 <Cale> shachaf: yeah, I kinda thought that DList was a bit much to begin with... it does do a nice job of encoding that trick in a way that people who don't know it can use it, but once you know the trick, there isn't too much reason to have a whole module built around it
08:59:21 <clahey> Wouldn't that imply you could make a function that took a variable number of parameters?
08:59:27 <Cale> clahey: absolutely
08:59:36 <Cale> clahey: and this is done in modules like Text.Printf
08:59:51 <clahey> Cale: But it's not used for default arguments in most cases.
09:00:14 <shachaf> Cale: I do like the idea of a restricted type, though.
09:00:14 <Cale> right
09:00:25 <shachaf> Cale: I'd like it even more if it could be expressed in the type system somehow.
09:00:38 <pnielsen> clahey: foo=bar,baz=quux tends to encourage functions with a very large amount of arguments
09:00:42 <Cale> shachaf: Yeah, I suppose it prevents you from screwing up and sticking other list functions in there
09:00:58 <clahey> pnielsen: Huh?
09:01:12 <Cale> You can do optional arguments fairly nicely using the record syntax
09:01:29 <Cale> (and give them names)
09:01:34 <clahey> Oh, yeah, defaultObject { blah = blah }
09:01:46 <pnielsen> clahey: I was guessing that by default arguments you mean optional arguments
09:01:57 <pnielsen> yes
09:01:58 <clahey> pnielsen: Specifically with default values.
09:02:04 <pnielsen> indeed
09:02:26 <clahey> Right now I have mkDSD who distance = ...
09:02:30 <pnielsen> so like def foo(bar="bar", baz="baz", ...). In Python, at least, that has resulted in functions having a very large amount of arguments in general
09:02:39 <monochrom> "default arguments" and "currying" do not mix well
09:02:45 <clahey> monochrom: Understood.
09:03:19 <clahey> pnielsen: True, whereas in functional languages you apply functions to the results to massage them to what you want more often.
09:03:26 <monochrom> but I guess, if you don't also allow "permute arguments anyway you like", it is not too bad
09:03:30 <pnielsen> record syntax is pretty nice for that if you really need it
09:04:28 <clahey> The only problem with replacing mkDSD with defaultDSD { who = who } would be that there are other fields of defaultDSD that would want to be changed as a result.
09:04:43 <clahey> But I could do mkDSD dsdArguments { who = who }
09:04:50 <clahey> But I could do mkDSD $ dsdArguments { who = who }
09:06:03 * ski . o O ( "The OCaml Manual -- 4. Labels and Variants -- 4.1.1 Optional arguments" <http://caml.inria.fr/pub/docs/manual-ocaml-4.00/manual006.html#htoc38> )
09:06:56 <ski> clahey : .. actually, `mkDSD dsdArguments { who = who }' is already parsed as `mkDSD (dsdArguments { who = who })'
09:08:27 <clahey> ski: Oh, even better.
09:09:04 <clahey> Hmm, I wonder if I would want to make a generic arguments type and then be able to pass it to different figures.
09:09:23 <clahey> That would make parsing easier because I could just build an arguments object and pass it to the right function.
09:18:28 <byorgey> lispy: what's the status of     + [ ] diagrams
09:18:31 <byorgey> gah, sorry
09:18:53 <byorgey> lispy: what's the status of https://github.com/haskell-opengl/GLUT/pull/3  (compatibility of GLUT with GHC 7.6) ?
09:26:22 * hackagebot debian 3.64.1 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.64.1 (DavidFox)
09:33:07 <newsham> + [x] diagrams
09:33:15 <newsham> status updated :)
09:33:28 <byorgey> oh good
09:33:33 <byorgey> I thought that would never get done!
09:37:38 <lispy> byorgey: I'll see if I can merge it right now
09:38:39 <Quantumplation> I need to map Pairs of Vector3's to values, but Vector3 doesn't implement Ord so most of the Data.Map functions won't work with it.  Can anyone reccommend an alternative container?
09:39:41 <lispy> byorgey: actually, it's already in.
09:39:50 <lispy> byorgey: I don't know why that pull request doesn't show that
09:41:34 <lispy> byorgey: I guess what folks really want is a new hackage release.
09:41:41 <Lajjla> Haskell doesn't support an easy way to make a type constructor say Matrix I J X which gives me an I by J matrix filled with x type X right?
09:42:01 <Lajjla> Like, I have to actually just make all dimensions 'manually' right?
09:42:16 <lispy> Lajjla: lots of matrix libraries exist, but the language doesn't mandate anything
09:42:31 <Lajjla> lispy, you mean properietary extensions?
09:43:19 <lispy> Lajjla: There are matrix implementations that can take elements from a list and for those you could just repeate the element you want
09:43:42 <lispy> Lajjla: check out hmatrix: http://hackage.haskell.org/package/hmatrix
09:43:54 * lispy has a feeling he doesn't understand Lajjla's question, but he has to run
09:44:55 <Lajjla> lispy, quite, I want the type system to enforce the type I guess, the package does not seem to do that.
09:45:28 <Lajjla> It seems to not statically check a malformed matrix like [[1,2,3], [4,5,6,6.5], [7,8,9]]
09:45:47 <Lajjla> I just want Matrix 3 3 Integer to be able to be a type of a 3x3 matrix filled with Integers
09:47:33 * ski thought Lajjla was asking about a convenience function for creating an array filled with elements (potentially depending on the index)
09:47:55 <Lajjla> Hey, it's not you, it's me, I'm terrible at explaining what exactly I want.
09:48:58 <newsham> Quantumplation: can you just write a quick Ord impl?
09:49:32 <Quantumplation> I'm not sure what a well behaved ord implementation would be for Vector3's
09:49:56 <Quantumplation> distsquared from origin, sort by x then y then z, etc.?
09:50:48 <byorgey> lispy: right, a new Hackage release is really what I'm after =)
09:51:01 <newsham> hrmm :)
09:51:09 <byorgey> lispy: for example, right now this seems to be the only thing holding up gloss from building under 7.6
09:51:20 <Lajjla> ski, so I take it isn't not possible?
09:51:55 <newsham> quant: how about a hashmap?
09:51:56 <byorgey> Quantumplation: any implementation is fine as long as it is a total order.
09:52:14 <byorgey> Quantumplation: just sort lexicographically (by x, y, and then z)
09:52:30 <Quantumplation> byorgey: Thanks :)
09:52:48 <copumpkin> > log ((640320^3 + 744)^2 - 393768 ) / sqrt(652)
09:52:50 <lambdabot>   3.141592653589793
09:53:03 <copumpkin> I see
09:53:03 <ski> Lajjla : it's probably possible, but i'm not sure how pretty it will be
09:53:31 <byorgey> copumpkin: haha, nice
09:53:31 <copumpkin> ski: do you have a link to your zipWith à la foldr thing?
09:54:46 <ski> copumpkin : "`zipWith' using `foldr'" by ski at <http://hpaste.org/47814>
09:54:59 <copumpkin> thanks!
09:55:32 <ski> copumpkin : are particular reason ? :)
09:55:41 <copumpkin> trying to figure out a related problem
09:55:50 <ski> some kind of fusion ?
09:55:53 <copumpkin> thought I'd look to this for inspiration
09:56:21 <ski> each of my `foldr' calls there essentially starts a "coroutine"
09:56:31 <copumpkin> ski: zipWithF on http://unlines.wordpress.com/2010/11/15/generics-for-small-fixed-size-vectors/
09:56:37 <mysticc> I have a datatype as data A = Y | N and I want to randomly choose between Y and N .. How to do that ?
09:56:52 <ski> and they pass the buck (their current state) to each other, alternating until one of the lists run out
09:56:59 <copumpkin> ski: I have a couple of solutions but they aren't quite ideal, so I wanted to try something like your thing
09:57:11 <copumpkin> it isn't really the same though
09:57:23 <Cale> mysticc: Depends on which library you're using to generate random values.
09:57:55 <mysticc> Cale: I dont care. Its just a small part of my program so I just want to get it done with without any mess.
09:58:13 <maukd> mysticc: it still depends on which library you're using to generate random values
09:58:16 <newsham> ?remember copumpkin log ((640320^3 + 744)^2 - 393768 ) / sqrt(652)
09:58:16 <lambdabot> It is forever etched in my memory.
09:58:37 <mysticc> maukd: random-fu ? I dont know, I can use anything.
09:58:45 <maukd> > 355 / 113
09:58:47 <lambdabot>   3.1415929203539825
09:58:48 <Cale> mysticc: Basically though, you'll generate a random Bool, and then map it to Y or N
09:58:56 <maukd> :t randomIO
09:58:58 <lambdabot> forall a. (Random a) => IO a
09:59:00 <maukd> @src Random
09:59:01 <lambdabot> class Random a where
09:59:01 <lambdabot>   random    :: RandomGen g => g -> (a, g)
09:59:01 <lambdabot>   randoms   :: RandomGen g => g -> [a]
09:59:01 <lambdabot>   randomR   :: RandomGen g => (a,a) -> g -> (a,g)
09:59:01 <lambdabot>   randomRs  :: RandomGen g => (a,a) -> g -> [a]
09:59:03 <lambdabot>   randomRIO :: (a,a) -> IO a
09:59:05 <lambdabot>   randomIO  :: IO a
09:59:14 <newsham> > pi - (355/113)
09:59:16 <lambdabot>   -2.667641894049666e-7
09:59:20 <newsham> > log ((640320^3 + 744)^2 - 393768 ) / sqrt(652)
09:59:21 <lambdabot>   3.141592653589793
09:59:25 <newsham> > pi - (log ((640320^3 + 744)^2 - 393768 ) / sqrt(652))
09:59:26 <Cale> If you're using System.Random, you would perhaps want to implement this Random class for A
09:59:26 <lambdabot>   0.0
09:59:39 <mysticc> maukd: Do I have to write an instance .. I love deriving and letting ghc figure out the rest :P
09:59:42 <Cale> (whose minimal complete definition is random and randomR)
09:59:58 <maukd> you'll have to write a bit of code
10:00:12 <maukd> or make A a newtype of Bool :-)
10:00:23 <mysticc> Cale: So much for such a small task.. Well I think I will have to do it anyway ..
10:00:35 <Cale> mysticc: The instance for Bool is already there
10:00:43 <Cale> (and your type is isomorphic to Bool, obviously)
10:00:54 <mysticc> maukd: Then I will have something like newtype A = Y True | N False .. which I dont want ..
10:01:00 <maukd> wat
10:01:01 <copumpkin> ski: for what it's worth, it's really easy to write zipWithF in Agda, or if you amend the definition of Arity a little bit, but I haven't been able to write it in the exact context he has
10:01:02 <Cale> mysticc: no
10:01:08 <centrinia> @let pi' = log ((640320^3 + 744)^2 - 393768 ) / sqrt(652)
10:01:09 <lambdabot>  Defined.
10:01:11 <Cale> mysticc: You would have  newtype A = A Bool
10:01:13 <maukd> newtype A = A Bool
10:01:50 <maukd> data A = N | Y deriving (Eq, Ord, Read, Show, Enum, Bounded)
10:01:53 <mysticc> Then I will have to change lot of code.. I think I will just write the instance
10:02:00 <luite> > showCReal 50 $ pi - log ((640320^3 + 744)^2 - 393768 ) / sqrt(652)
10:02:01 <lambdabot>   "0.00000000000000000000000000000000000000000000009303"
10:02:07 <luite> hm, pretty impressive :)
10:02:13 <maukd> a2bool :: A -> Bool; a2bool = toEnum . fromEnum; bool2a :: Bool -> A; bool2a = toEnum . fromEnum
10:02:14 <mysticc> maukd: What will that do ?
10:02:16 <Cale> mysticc: You can also do without the instance, and just map the random Bools you get to A values
10:02:30 <mysticc> oh ..
10:02:31 <luite> though not really shorter than just writing that number
10:02:33 <mysticc> ok thanks
10:03:15 <maukd> instance Random A where random g = first bool2a (random g); randomR (a,z) g = first bool2a (randomR (a2bool a, a2bool z) g)
10:03:22 <luite> of decimals
10:06:11 <mysticc> maukd: What is first?
10:06:44 <ski> @index first
10:06:45 <lambdabot> Control.Arrow
10:06:54 <Polarina> lispy, what would be nice for your lin-alg package would be the ability to multiply a Mat with a Vec. :)
10:06:56 <maukd> > first (* 10) (3, 4)
10:06:58 <lambdabot>   (30,4)
10:07:08 <maukd> > second (* 10) (3, 4)
10:07:10 <lambdabot>   (3,40)
10:07:41 <gwern> > (((16 - 1) * 532) + ((18 - 1) * 366)) / (18 + 16 - 2)
10:07:43 <lambdabot>   443.8125
10:07:58 <maukd> gwern: a very bad approximation
10:08:33 <gwern> maukd: yeah, but you know your tradeoffs when you're using stirling's approximation for a quick stab at a manifold of zygohistic prepomorphisms
10:08:59 <gwern> > (1199 - 965) / 444
10:09:01 <lambdabot>   0.527027027027027
10:09:37 <nand`> if you avoid the Ord/Eq instances, is showCReal n guaranteed to produce an accurate result up to n digits?
10:09:46 <nand`> or is there any other operation that limits precision artificially
10:11:35 <ski> i don't know of any other such operation (but i don't really know the details of it, either)
10:17:27 <mysticc> Cale: If I do newtype A = A Bool .. Still when I run my program it says "no instance for Random A"
10:18:17 <ski> mysticc : `deriving Random' with `{-# LANGUAGE GeneralizedNewtypeDeriving #-}'
10:56:30 * hackagebot file-embed 0.0.4.6 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.4.6 (MichaelSnoyman)
11:01:27 <Jello_Raptor> o/
11:02:08 <Jello_Raptor> o/
11:02:22 <Sculptor> o/
11:02:25 <scri> o?
11:02:44 <scri> \o/
11:03:36 <nand`> \o
11:04:59 <scri> \_o< quack
11:05:59 <Sculptor> cute
11:06:11 <Sculptor> <_o_/  en garde!
11:09:30 <ParahSa1lin> :t (<_o_/)
11:09:32 <lambdabot> parse error on input `)'
11:09:36 <clahey> :t sequence
11:09:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:15:31 <clahey> :t >==
11:15:33 <lambdabot> parse error on input `>=='
11:15:36 <clahey> :t (>==)
11:15:38 <lambdabot> Not in scope: `>=='
11:15:41 <clahey> :t (==>)
11:15:42 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
11:15:45 <clahey> :t (>>=)
11:15:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
11:17:54 <clahey> :t (<>)
11:17:56 <lambdabot> Doc -> Doc -> Doc
11:21:37 * hackagebot git-annex 3.20121001 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20121001 (JoeyHess)
11:25:20 <clahey> :t (=<<)
11:25:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
11:28:49 <trotro> hi, is there a way to use hoggle with other languages ? is it possible to analyse a .net dll and provide all the types to hoogle ?
11:30:09 <Saizan> trotro: there's a text format that hoogle accepts for the databases
11:30:18 <trotro> cool
11:30:37 <trotro> and i can remove all the information about haskell functions ?
11:30:40 <clahey> > return 5 :: State
11:30:42 <lambdabot>   Type synonym `Control.Monad.Trans.State.Lazy.State' should have 1 argument,...
11:30:46 <clahey> > return 5 :: State Int
11:30:46 <lambdabot>   Expecting an ordinary type, but found a type of kind * -> *
11:30:48 <Saizan> the docs or the source should have examples
11:31:08 <rwbarton> dot noogle
11:31:09 <trotro> thx, that's great news, thx
11:31:12 <clahey> > return 5 :: State (Int) Int
11:31:14 <lambdabot>   No instance for (GHC.Show.Show
11:31:14 <lambdabot>                     (Control.Monad.Trans.Sta...
11:31:29 <clahey> > return 5 :: State (Int) Int $ (3)
11:31:30 <lambdabot>   Only unit numeric type pattern is valid
11:31:41 <clahey> > return 5 :: State (Int, Int) Int $ (3, 2)
11:31:42 <lambdabot>   Only unit numeric type pattern is validOnly unit numeric type pattern is va...
11:31:49 <Saizan> trotro: though i think you'll have to use haskell's syntax for the types
11:32:02 <clahey> > return 5 :: State (Int, Int) Int
11:32:03 <lambdabot>   No instance for (GHC.Show.Show
11:32:03 <lambdabot>                     (Control.Monad.Trans.Sta...
11:32:14 <clahey> > (return 5 :: State (Int, Int) Int) (3, 2)
11:32:15 <lambdabot>   Couldn't match expected type `t1 -> t'
11:32:15 <lambdabot>         against inferred type `Contr...
11:32:24 <clahey> I'll switch to ghci.
11:32:26 <trotro> Saizan, of course but it's not a problem to transform .net types to haskell types (except the POO concept)
11:32:31 <ski> > (return 5 :: State (Int, Int) Int) `runState` (3, 2)
11:32:33 <lambdabot>   (5,(3,2))
11:32:47 <clahey> ski: Thank you.
11:33:38 <clahey> > (return 5 >>= return 3) `runState` (3, 2)
11:33:39 <lambdabot>   No instance for (GHC.Num.Num
11:33:40 <lambdabot>                     (Control.Monad.Trans.State...
11:34:13 <clahey> > (return 5) `runState` (3, 2)
11:34:14 <lambdabot>   (5,(3,2))
11:34:29 <clahey> > (return 3) `runState` (3, 2)
11:34:30 <lambdabot>   (3,(3,2))
11:34:34 <maukd> :t runState
11:34:36 <lambdabot> forall s a. State s a -> s -> (a, s)
11:35:07 <maukd> > runState (do v <- get; put (v + 5); return "hi") 2
11:35:08 <lambdabot>   ("hi",7)
11:35:39 <clahey> runState (do return "hi"; return "hello") 2
11:35:48 <clahey> > runState (do return "hi"; return "hello") 2
11:35:49 <lambdabot>   ("hello",2)
11:36:02 <clahey> > runState (return "hi" >> return "hello") 2
11:36:03 <lambdabot>   ("hello",2)
11:36:30 <clahey> Because I had the type of return wrong.
11:36:39 <clahey> > runState (return "hi" >>= return) 2
11:36:40 <lambdabot>   ("hi",2)
11:38:23 <clahey> > runState (return "hi" >>= \w -> (w ++ "hi", length w)) 2
11:38:25 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.StateT
11:38:25 <lambdabot>        ...
11:39:21 <ski> clahey : just fyi, it's also possible to query lambdabot privately, e.g. like `/msg lambdabot > runState (put . (^ 2) =<< get) 3'
11:39:32 <clahey> ski: That is useful.
11:39:41 <clahey> But it's as useful to do it publicly so that I can get advice from others.
11:40:04 <ski> in your last example above, you possibly forgot a `return'
11:42:53 <clahey> > runState (return "hi" >>= \w -> \s -> (w ++ "hi", s + length w)) 2
11:42:54 <lambdabot>   The lambda expression `\ s -> ...' has one argument,
11:42:54 <lambdabot>  but its type `Control...
11:43:20 <clahey> > runState (return "hi" >>= \w -> State \s -> (w ++ "hi", s + length w)) 2
11:43:21 <lambdabot>   <no location info>: parse error on input `\'
11:43:30 <clahey> > runState (return "hi" >>= \w -> State (\s -> (w ++ "hi", s + length w))) 2
11:43:31 <lambdabot>   Not in scope: data constructor `State'
11:43:49 <ski> > runState (return "hi" >>= \w -> state (\s -> (w ++ "hi", s + length w))) 2
11:43:51 <lambdabot>   ("hihi",4)
11:43:53 <clahey> > runState (return "hi" >>= \w -> state (\s -> (w ++ "hi", s + length w))) 2
11:43:55 <lambdabot>   ("hihi",4)
11:44:13 <clahey> I'm starting to get it.  :)
11:44:40 <ski> > runState (return "hi" >>= \w -> modify (+ length w) >> return (w ++ "hi")) 2
11:44:43 <lambdabot>   ("hihi",4)
11:45:09 <clahey> Gotcha.
11:45:35 <ski> @do runState (return "hi" >>= \w -> modify (+ length w) >> return (w ++ "hi")) 2
11:45:36 <lambdabot> runState (do { w <- return "hi"; modify (+ length w); return (w ++ "hi")}) 2
11:45:40 <nejucomo> :t state
11:45:42 <lambdabot> forall s a. (s -> (a, s)) -> State s a
11:46:00 <clahey> :t modify
11:46:01 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
11:46:27 <ski> @type state random
11:46:28 <lambdabot> forall s a. (Random a, RandomGen s) => State s a
11:47:30 <clahey> Ah, so modify f = \s -> state ((), f s)
11:47:39 <ski> yes
11:47:48 <clahey> And you can mix different types of State s just like you can mix different types of IO.
11:48:10 <ski> not sure what you mean there (by either side)
11:48:41 <clahey> The two IO on either side of the monadic operators (>>=, >>) can be different types.
11:49:29 <clahey> Similarly, a valid type for >> could be State s a -> State s b
11:49:34 <clahey> Similarly, a valid type for >> could be State s a -> State s b -> State s b
11:49:38 <ski> yes
11:49:52 <ski> that's an instance of `m a -> m b -> m b', where `m = State s'
11:50:07 <ski> it's still the same `m', though
11:50:28 <ski> so in the case of `m = State s', it has to be the same `s'
12:03:00 <mcstar> i think cabal died as i tried to cabal init a file
12:03:15 <byorgey> mcstar: ouch
12:03:23 <byorgey> mcstar: can you reproduce it?
12:03:31 * byorgey is the cabal init maintainer
12:03:31 <mcstar> well see
12:03:37 <dcoutts> mcstar: you're lucky to have the author here to report the bug to :-)
12:03:43 <mcstar> haha
12:03:52 <clahey> :t <=<
12:03:53 <lambdabot> parse error on input `<=<'
12:03:59 * dcoutts happily delegates all cabal init problems to byorgey
12:04:01 <dcoutts> ;-)
12:04:05 <clahey> :t (<=<)
12:04:06 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
12:04:07 <mcstar> byorgey: can i have space in the package name?
12:04:13 <geekosaur> no
12:04:16 * byorgey happily delegates all other cabal problems to dcoutts 
12:04:23 <dcoutts> :-)
12:04:24 <clahey> :t (<<=)
12:04:25 <lambdabot> Not in scope: `<<='
12:04:26 <byorgey> mcstar: no
12:04:31 <clahey> :t (=>>)
12:04:32 <lambdabot> Not in scope: `=>>'
12:04:32 <mcstar> maybe that was the error
12:04:40 <clahey> :t (=<<)
12:04:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:04:55 <mcstar> byorgey:
12:04:57 <mcstar> cabal: ModuleName.fromString: invalid module name "Aufgabe8-working"
12:04:59 <mcstar> [2]    25346 exit 1     cabal init
12:05:03 <mcstar> not a nice error though
12:05:34 <clahey> :t putStrLn <=< readLine
12:05:35 <lambdabot> Not in scope: `readLine'
12:05:38 <byorgey> mcstar: ah, OK, it definitely shouldn't crash
12:05:46 <clahey> :t putStrLn <=< readFile "filename
12:05:47 <lambdabot>     lexical error in string/character literal at end of input
12:05:50 <clahey> :t putStrLn <=< readFile
12:05:51 <lambdabot> FilePath -> IO ()
12:05:53 <byorgey> I should have realized ModuleName.fromString is partial
12:06:09 <byorgey> mcstar: can you file a ticket at https://github.com/haskell/cabal/issues ?
12:06:11 <mcstar> byorgey: same error, with no space
12:06:56 <mcstar> ill see, atm im trying to make my asteroids game cabal buildable
12:07:01 <Lajjla> brandonw, what is this trickery?
12:07:03 <mcstar> and idk how to set up a file
12:07:28 <mcstar> ill just copy one over
12:18:07 <mcstar> does someone feel like helping me?
12:18:17 <mcstar> the reward is you get to play a game
12:18:42 <mcstar> git://github.com/liquid-phynix/asteroids.git
12:19:03 <mcstar> i made this game cabal buildabel, if someone has time, i could use feedback
12:19:17 <mcstar> (dont install it though, it isnt worth it)
12:20:07 <clahey> :t void
12:20:08 <lambdabot> Not in scope: `void'
12:20:22 <mcstar> clahey: were you the one i was talking to the other day?
12:20:23 <byorgey> mcstar: what is it you need help with?
12:20:24 <clahey> mcstar: Instructions, please.
12:20:28 <geekosaur> :t Control.Monad.void
12:20:28 <clahey> mcstar: Very possibly.
12:20:29 <lambdabot> Not in scope: `Control.Monad.void'
12:20:34 <geekosaur> hm, too old?
12:20:35 <mcstar> byorgey: just to test it
12:20:46 <geekosaur> probably, not like lb's properly maintained
12:20:48 <mcstar> clahey: git clone it, and then cabal configure && cabal build
12:21:01 <mcstar> the exe will be in the dist/asteroids dir
12:21:45 <mcstar> (the code is quite ugly, i know, it will get better, soon...)
12:23:03 <byorgey> mcstar: building now
12:23:15 <mcstar> thanks
12:23:57 <mcstar> oh, it needs comic.ttf, it might not find it
12:24:06 <mcstar> should i just copy over it to the dir?
12:24:32 <mcstar> font paths can vary..
12:25:02 <byorgey> mcstar: you ought to list Game in an  other-modules  field
12:25:20 <byorgey> like at the end of the Executable section, add   other-modules: Game
12:25:22 <swarley> so, i was looking at https://github.com/tibbe/event and it says its in the GHC main tree, does that mean it should be installed by default?
12:26:06 <mcstar> byorgey: can you see text?
12:26:43 <byorgey> mcstar: what do you mean?
12:26:51 <mcstar> like, text in the game
12:27:00 <mcstar> i added the .ttf file nevertheless
12:27:06 <mcstar> to the repo
12:27:11 <byorgey> I haven't even gotten it to build yet, hang on
12:27:32 <byorgey> oh, I don't have the ftgl C lib
12:27:45 <byorgey> and I can't install it on this machine
12:28:01 <mcstar> bummer
12:28:28 <byorgey> if you still need someone to test it later I can try it at home on my laptop
12:28:38 <mcstar> byorgey: sure
12:28:51 <mcstar> byorgey: i built for me, without other-modules: Game
12:28:59 <mcstar> whats the significance of that?
12:29:04 <mcstar> it *
12:29:22 <byorgey> in this case I guess there is not much consequence
12:29:33 <byorgey> but in general you can get linking errors if you leave out modules
12:29:46 <byorgey> any modules that are used but not exported should be listed in other-modules
12:30:39 <byorgey> right, note I wasn't saying it didn't build for me because of that, I just looked over the .cabal file and noticed that
12:31:30 <mcstar> k
12:32:05 <mcstar> im sure i could not have written this in 400 lines
12:32:08 <mcstar> in c++
12:32:23 <mcstar> but still, feels kind of hacky
12:32:32 <mcstar> unorganized
12:33:43 <sfogarty> Is there a way to make ghc --make look for and compile Happy grammars?
12:34:40 <byorgey> mcstar: I figured out what the bug is in cabal init, BTW
12:34:55 <byorgey> mcstar: so don't worry about filing a bug, I'll file one myself
12:35:26 <mcstar> great
12:36:05 <mcstar> is there a way to partially 'instantiate' a record?
12:36:24 <mcstar> for example, i want to initialize the fields in 2 steps
12:36:30 <maukd> record update syntax
12:36:36 <mcstar> but ghc complains, that i have uninitilized fields
12:36:43 <Clint> default values?
12:36:44 <mcstar> maukd: i know about that ofc, but that doesnt solve it
12:36:52 <geekosaur> those are warnings, by default
12:36:54 <mcstar> i dont want to physically write out all the fields the first time
12:37:11 <sfogarty> I think records can have default values
12:37:12 <mcstar> since ill pass it right to a function that'll do it
12:37:35 <geekosaur> note however that anything you don't initialize will be bottom (specifically, will be initialized to something that throws an exception if evaluated)
12:38:00 <mcstar> i just figured it is bad practice to leave the compiler complain
12:39:24 <sfogarty> Hmn. Any way to get ghc --make to run happy on the grammars? Or do I need a full makefile
12:50:00 <clahey> mcstar: You double use the term "norm"
12:50:15 <clahey> At one point it's a Double and another it's a (Double, Double) -> Double
12:50:23 <mcstar> ok
12:50:29 <mcstar> makes sense
12:50:42 <clahey> mcstar: And you duplicate the definition of the function when you define the value.
12:50:47 <mcstar> you can shadow top level definitions
12:50:57 <mcstar> clahey: that can happen too
12:51:02 <clahey> I know, but it's confusing for the style.
12:51:06 <mcstar> i havent had the chance to go over it
12:51:10 <mcstar> thats what im doing now
12:51:21 <clahey> mcstar: I figured, would you rather not have comments until you go over it?
12:51:21 <mcstar> clahey: ah, nonono, dont look at it
12:51:27 <mcstar> just try to play with it
12:51:32 <jfischoff> what's an easy way to produce an html error report?
12:51:35 <clahey> Ah.
12:51:46 <jfischoff> is there some package I can grab to basically do the work for me?
12:51:46 <clahey> mcstar: :-)
12:51:50 <clahey> I like reading code
12:52:12 <clahey> I have to say, I'm not gonna promise not to look at it.  I want to learn your general ideas.  I won't give feedback until you say it's ready for feedback
12:52:24 <mcstar> :)
12:52:25 <clahey> Ah, I'm missing a ton of dependencies on this machine.
12:52:33 <sfogarty> how do I make a repl cleanly handle end of file (i.e. avoid Repl: <stdin>: hGetLine: end of file)? Is there an hGetLine variant that returns null when it hits end of file?
12:52:35 <mcstar> clahey: but what about the game? is it 'playable'?
12:52:46 <mcstar> nvm
12:52:59 <Polarina> Great! I can't use the OpenGL package.
12:53:05 * Polarina switches to OpenGLRaw.
12:53:17 <sfogarty> or is it better just to wrap it in a tryJust or the like?
12:53:46 <clahey> Oh wait.
12:54:01 <clahey> State s doesn't represent a state.  It represents a state transition?
12:54:40 <Polarina> Wait, why is 'tensor' and 'Tensor' not the same package?
12:54:42 <clahey> A State computation.
12:55:23 <c_wraith> clahey: State s represents an action that depends on a state that must be supplied to it, and it produces a final state and another value
12:55:40 <otters> @pl \a b c d -> not a || not b || not c || not d
12:55:40 <lambdabot> (. ((. ((. not) . (||) . not)) . (.) . (||) . not)) . (.) . (.) . (||) . not
12:55:43 <otters> oh
12:55:59 <clahey> c_wraith: So, put s is an instance where put = \s -> ((), s)
12:56:04 <nand`> any not [a,b,c,d] ?
12:56:15 <c_wraith> clahey: if you ignore the newtype wrapper, yeah
12:56:25 <clahey> c_wraith: I always forget that.
12:56:30 <c_wraith> @unmtl State s a
12:56:30 <lambdabot> s -> (a, s)
12:56:39 <nand`> or not . and
12:57:29 <c_wraith> clahey: actually, that's not right.
12:57:49 <clahey> c_wraith: So, put s is an instance where put s= \s' -> ((), s)
12:57:49 <c_wraith> clahey: put s = State (\_ -> ((), s))
12:57:57 <c_wraith> yeah
12:57:58 <c_wraith> that's it
12:58:07 <c_wraith> it's common to name an unused value _
12:58:12 <clahey> I know...
12:58:15 <clahey> Just forgot.
12:58:21 <c_wraith> but you had the right idea, absolutely
12:58:25 <clahey> So, my state update functions are going to be of the form s -> s
12:58:39 <c_wraith> :t modify
12:58:41 <clahey> And modify kinda lifts that.
12:58:41 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
12:58:49 <c_wraith> yep
12:59:13 <clahey> But if my state update functions have an inputs, I write them as:
12:59:32 <clahey> a -> s -> (out, s')
12:59:49 <clahey> Rather, their type is a -> s -> (b, s)
13:00:06 <clahey> And I can use that with bind.
13:00:09 <nand`> if *all* your state update functions are s -> s you might as well use s -> s and compose them with (.)
13:00:24 <clahey> nand`: Agreed, but some of them are going to have inputs.
13:00:31 <nand`> x -> s -> s works
13:00:51 <nand`> State is just needed if you want to update the state and extract some result at the same time
13:00:54 <clahey> Oh, true, they don't have to have outputs.
13:01:29 <clahey> So, I'm trying to understand how you might combine two Monads.
13:01:33 <clahey> Specifically, State and IO.
13:03:27 <nand`> if you need the results of both at the same time (eg. IO effects may determine how state gets updated), monad transformers are one way
13:03:34 <clahey> I know I can do runLoop state = getLine >>= \input -> runLoop (updateState input)
13:03:36 <ski> @unmtl StateT s IO a
13:03:37 <lambdabot> s -> IO (a, s)
13:06:09 <clahey> So, \s1 -> fmap (\inp -> (f s1 inp, newState s1 inp)) getLine
13:06:12 <nand`> (but if you don't, you can simply use something like IO (s -> s) or IO s -> IO s depending on the circumstances)
13:06:35 <clahey> nand`: I'm trying to minimize the IO in my program and figure out how to do that while still having a concept of the state of the outside world.
13:07:01 <sfogarty> how do I search for a function with a certain type? (I know there's a wb interface somewhere, but I haven't seen it)
13:07:07 <nand`> sfogarty: hoogle
13:07:13 <sfogarty> thanks
13:07:29 <sipa> @hoogle a -> b
13:07:29 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
13:07:29 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:07:29 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
13:07:52 <sipa> @hoogle a -> a
13:07:52 <lambdabot> Prelude id :: a -> a
13:07:52 <lambdabot> Data.Function id :: a -> a
13:07:52 <lambdabot> GHC.Exts breakpoint :: a -> a
13:07:55 <sfogarty> @hoogle (a -> Maybe b) -> Maybe a -> Maybe b
13:07:56 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
13:07:56 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
13:07:56 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
13:08:06 <sfogarty> ..duh
13:08:09 <clahey> :t foldM
13:08:10 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
13:08:34 <clahey> :t foldM1
13:08:36 <lambdabot> Not in scope: `foldM1'
13:08:39 <clahey> :t fold1M
13:08:40 <lambdabot> Not in scope: `fold1M'
13:09:11 <clahey> @hoogle (a -> a) -> ma -> ma
13:09:12 <lambdabot> Data.Generics.Schemes everywhere :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
13:09:12 <lambdabot> Data.Generics.Schemes everywhere' :: (forall a. Data a => a -> a) -> (forall a. Data a => a -> a)
13:09:12 <lambdabot> Data.Data gmapT :: Data a => (forall b. Data b => b -> b) -> a -> a
13:09:25 <clahey> @hoogle (a -> b) -> ma -> mb
13:09:26 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
13:09:26 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
13:09:26 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
13:09:39 <clahey> @hoogle (a -> b) -> m a -> m b
13:09:39 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
13:09:39 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
13:09:39 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
13:10:00 <ski> @hoogle+
13:10:33 <clahey> @hoogle (a -> a -> a) -> Maybe a -> Maybe a
13:10:33 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
13:10:34 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
13:10:34 <lambdabot> Data.Foldable maximumBy :: Foldable t => (a -> a -> Ordering) -> t a -> a
13:10:50 <clahey> None of those seem to match what I asked for.
13:11:09 <sfogarty> what you're asking can be instantted to them, though
13:11:17 <ski> @hoogle (a -> a -> a) -> Maybe a -> Maybe a -> Maybe a
13:11:18 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:11:18 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:11:18 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
13:11:23 <ski> sfogarty : not quite
13:11:31 <sfogarty> maybe isn't Foldable?
13:11:37 <sfogarty> oh, no, not quite
13:12:59 <clahey> @hoogle (a -> a -> a) -> a -> Maybe a -> Maybe a
13:12:59 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
13:12:59 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
13:12:59 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
13:13:02 <clahey> That's what I actually want.
13:13:36 <sfogarty> might be easier to just reutnr hte first element and use the monad apply?
13:13:48 <nand`> :t flip (flip liftM2 . return)
13:13:50 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> a1 -> m a2 -> m r
13:13:53 <sfogarty> ...pardong my spelling.
13:14:28 <clahey> The big difference is that if m a2 is Nothing, I just want a1, instead of Nothing.
13:14:43 <sfogarty> is there a shorthand for if..then without an else in the IO monad, similar to how 'let x = y in do' can be phrased as 'let x = y'?
13:14:45 <ski> @type \comb z -> liftA (comb z) `asTypeOf` (const Nothing)
13:14:46 <lambdabot> forall t a a1. (t -> a -> a1) -> t -> Maybe a -> Maybe a1
13:14:53 <sfogarty> Oh! I see
13:15:07 <ski> sfogarty : `when' and `unless' ?
13:15:16 <sfogarty> fromMaybe
13:15:17 <shapr> :t when
13:15:19 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:15:22 <sfogarty> thanks, ski
13:19:08 <sfogarty> hmn. when doesn't seem to stop execution. it's conditional, but it will fall through in either case
13:19:25 <sfogarty> I want something like 'if eof then return () else do'
13:19:57 <rwbarton> return () will also "fall through"
13:20:02 <geekosaur> there is no such thing as "stop execution"
13:20:12 <rwbarton> @src unless
13:20:12 <lambdabot> unless p s = if p then return () else s
13:20:13 <sfogarty> but 'else do' will not fall through
13:20:15 <geekosaur> it's all one expression, even if it looks like a series of procedural statements
13:20:26 <sfogarty> right
13:20:32 <maukd> when (a > b) $ do
13:20:39 <maukd> foo; bar
13:20:58 <byorgey> sfogarty: you can do    unless condition $ do ... entire rest of the do-block in here ...
13:21:14 <byorgey> (not all on one line of course)
13:21:14 <Eduard_Munteanu> The only thing like a C return is Cont stuff.
13:21:22 <sfogarty> it properly is an else, it just looks icky to have all these nested conditions. 'check if end of line. then read line, and check if it is empty. then..'
13:21:35 <Eduard_Munteanu> Or Nothing in Maybe.
13:21:43 <byorgey> sfogarty: well, if you find yourself doing lots of this, you can use a monad which supports stopping early
13:22:00 <sfogarty> Well, I'm in the IO monad, so I was hoping that it already did :0
13:22:04 <sfogarty> :) even
13:22:04 <byorgey> nope
13:22:19 <byorgey> if these are error conditions you could use   MaybeT IO
13:22:30 <rwbarton> unless you mean REALLY stopping like calling exit()
13:22:38 <sfogarty> Yeah. I'm not sure my students would love me bringing in other monads :)
13:22:50 <Cale> IO has exceptions
13:22:53 <Cale> which you could abuse :)
13:23:17 <byorgey> noooooo
13:23:28 <Cale> (They're even extensible, so you could throw an exception of a new type which is easily identified)
13:23:29 <sfogarty> it sounds like if eof then return () else do is still cleanest
13:23:42 <Eduard_Munteanu> sfogarty: Maybe is pretty straightforward to introduce
13:23:58 <sfogarty> they know Maybe, but not as a monad.
13:24:35 <Cale> But to be honest, writing your code in a style where any given block either runs to completion, or doesn't terminate is good for your brain.
13:25:11 <sfogarty> yeah, it's not that bad. and if I get too many, I can just put the if ... then return () else do on one line.
13:25:32 <Cale> You can also use case () of _ | ... and introduce guards
13:25:42 <rwbarton> you can also use 'unless'...?
13:26:06 <Cale> (though that doesn't necessarily work if you have interleaved IO)
13:26:33 <sfogarty> unless isn't any cleaner, I think, because you'd say 'unless eof do....' and have a long indented block under the do
13:26:43 <rwbarton> it is certainly a little clearner
13:26:45 <rwbarton> *cleaner
13:26:52 <rwbarton> it doesn't avoid the indentation, no
13:27:04 <sfogarty> where's the prefered code-pasting place? MIght be easier to throw up the example
13:27:09 <Cale> hpaste.org
13:27:59 <hpaste> “Seth Fogarty” pasted “repl” at http://hpaste.org/75623
13:28:01 <Cale> sfogarty: If you have code which is repetitious, at the very least you can always invent some new combinator to glue things together :)
13:28:33 <sfogarty> Monads would work great, I just want my students to be able to read it
13:28:57 <sfogarty> ooh, and hpaste gives me suggestions on cleaning
13:29:22 <jfischoff> @where hlint
13:29:23 <lambdabot> http://community.haskell.org/~ndm/hlint/
13:29:32 <jfischoff> sfogarty ^
13:29:58 <sfogarty> thanks, jfischoff
13:30:06 <jfischoff> :)
13:30:13 <Cale> Interesting that hlint doesn't suggest merging lets
13:30:55 <jfischoff> yeah, successive ones shouldn't that hard
13:31:04 <trotro> it's a norm tool ?
13:31:35 <rwbarton> trotro: you can see it in action on hpaste, e.g. here http://hpaste.org/75623
13:32:13 <trotro> yeah it's look like a norm tool
13:32:15 <sfogarty> hmn, 'unless end do' doesn't seem to work as I would expect
13:32:28 <maukd> unless end $ do
13:32:49 <trotro> i got that kind of tools at work, i quit them when they start to suggest awfull things :)
13:32:51 <sfogarty> bah. Stupid $.
13:34:04 <sfogarty> I'll stick with if then. Don't want to confuse them anymore than I have.
13:34:35 <hpaste> “Seth Fogarty” pasted “repl” at http://hpaste.org/75624
13:35:42 <sfogarty> But installing hlint :)
13:35:45 * ski smiles at `hlint' suggesting `unless'
13:35:52 <swarley> i have a question on how you would do something functionally
13:36:16 <maukd> sorry, I only write non-functional software
13:36:25 <ski> also, i'd probably rename `appMaybe' to `extendMaybe'
13:36:44 <hpaste> Cale annotated “repl” with “repl (annotation)” at http://hpaste.org/75624#a75625
13:37:05 <swarley> i'm working on a webserver (using yesod) and i want to have data based on the session. i know you would probably use the database in this situation, but the data i want to store is a socket, so i'm not sure how to associate them
13:37:10 <hpaste> trotro pasted “test hlint” at http://hpaste.org/75626
13:37:26 <ski> sfogarty : you can replace the `let' on line `13' in the paste with `   '
13:37:33 <trotro> hi can someone pass hlint on that http://hpaste.org/75626
13:37:39 <trotro> i'm intrested in that
13:37:51 <rwbarton> you already did
13:38:00 <sfogarty> Weighing elegance vs. clarity, I think the if then is simpler. they are baby haskell programmers, and it's my first time teaching them.
13:38:04 <trotro> ho... the thing at bottom
13:38:07 <trotro> ok it failed
13:38:08 <geekosaur> trotro, hpaste hlints stuff that's pasted and marked as haskell
13:38:12 <rwbarton> it happens automatically as long as the module parses
13:38:19 <hpaste> “Jonathan Fischoff” annotated “test hlint” with “test hlint (annotation)” at http://hpaste.org/75626#a75627
13:38:24 <trotro> it noticed useless things but forget to notice bad things
13:38:28 <sfogarty> ah, right ski
13:38:29 <sfogarty> thanks
13:38:49 <ski> sfogarty : one thing one could do is factor the three `repl' calls outside the `case .. of ...'
13:38:56 <sfogarty> hmn. cabal install hlint worked, but I has no executable
13:39:00 <Cale> trotro: What do you mean by "bad things" here?
13:39:12 <trotro> Cale, the bad typed prelude haskell functions :)
13:39:14 <trotro> read
13:39:23 <trotro> my [arg] <- getArgs
13:39:29 <ski> sfogarty : whether it's a good thing to do depends on whether you always want to call `repl' in the end of each branch there, or if you possibly later want to add a case where you don't
13:39:35 <swarley> anyone able to suggest what i should do? :p
13:39:38 <sfogarty> ski: I could, but doesn't seem any clearer
13:39:40 <trotro> that the two things i'm ashamed of (but that program is really specific)
13:39:43 <Cale> I don't think hlint actually typechecks anything
13:39:49 <Cale> and I don't see any type errors
13:40:05 <swarley> i feel that using a mutable Data.Map is frowned upon for some reason
13:40:07 <trotro> it could say, that i uses dangerous bad typed functions (there must be 20 functions bad typed in prelude)
13:40:13 <rwbarton> he means "read is bad, oh noes"
13:40:23 <trotro> rwbarton, stop, don't want to argue on that
13:40:27 <sfogarty> where does cabal install executables? I seem not to have it in my path
13:40:31 <ski> sfogarty : if you used `repl :: StateT Value IO ()', it might look nicer
13:40:36 <swarley> sfogarty, ~/.cabal/bin
13:41:31 <paolino> hello, how do I bring Constraint kind in scope ?
13:41:45 <sfogarty> thanks
13:41:48 <swarley> np
13:41:53 <paolino> ConstraintKinds seems not enough
13:42:02 <rwbarton> it's in some module GHC.something
13:42:19 <sfogarty> ski: I'm trying to force them to think about state functionally, so I'm not encouraging state monad use.
13:43:11 <sfogarty> hmn. hlint suggests a breaking thing. silly hlint
13:43:20 <paolino> rwbarton, I can't see it in the docs http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/constraint-kind.html
13:43:43 <sfogarty> no, no, I just misunderstood it
13:44:19 <rwbarton> hmm
13:45:56 <ski> sfogarty : "them" ?
13:45:59 <rwbarton> paolino: import GHC.Exts (Constraint)
13:46:06 <rwbarton> I don't know why it is not documented but that works for me
13:46:06 <sfogarty> my students
13:46:13 * ski . o O ( "Douglas Fredericks and the House of They" <http://www.amazon.com/Douglas-Fredericks-House-They-Kelly/dp/1582409943> )
13:46:35 <ski> sfogarty : ok
13:47:00 <sfogarty> man, hlint is great
13:47:10 <sfogarty> thank you jfischoff :)
13:47:48 <rwbarton> trotro: hlint is very customizable. if you personally don't like some particular constructions you can have it warn you about them
13:48:13 <jfischoff> yeah it is integrated into various vim and emacs modes also
13:48:32 <sfogarty> oooh
13:48:57 <mcstar> clahey: did you manage to install the dependencies?
13:49:36 <sfogarty> know where to find the hlint vim integration off the top of your head?
13:50:23 <jfischoff> sfogarty: https://github.com/eagletmt/ghcmod-vim
13:50:48 <sfogarty> thanks, jfischoff. I'd only found http://www.vim.org/scripts/script.php?script_id=2907
13:51:13 <jfischoff> sfogarty: also, https://github.com/jejansse/Haskim collects a bunch of haskell vim stuff
13:51:36 <pnielsen> sfogarty: second that
13:51:47 <pnielsen> hlint is great
13:51:50 * hackagebot monadLib 3.7.1 - A collection of monad transformers.  http://hackage.haskell.org/package/monadLib-3.7.1 (IavorDiatchki)
13:51:52 * hackagebot data-named 0.1.0 - Data types for named entities  http://hackage.haskell.org/package/data-named-0.1.0 (JakubWaszczuk)
13:51:55 <adnauseam> problem with haskim is that its highlight feature MASSIVELY slows down navigation
13:51:58 <adnauseam> :/
13:52:12 <jfischoff> ^ totally
13:52:19 <jfischoff> had to stop using it
13:52:23 <adnauseam> i don;'t know what made things all so bloated. i tried to debug it but im no vim wiz.
13:52:28 <jfischoff> still working a fast usable vimrc
13:52:34 <jfischoff> ditto
13:52:37 <sfogarty> I'll stick with ghcmod-vim then
13:52:37 <adnauseam> clean vim with some fancy colors and proper spacing. that's all one needs
13:52:47 <jfischoff> preach it
13:53:17 <adnauseam> hell yea brother
13:53:35 <nand`> vim's highlighting seems to break constantly for me, when scrolling through or past multi-line comments. I have ‘syntax sync fromstart’ in .vimrc
13:53:37 <sfogarty> well, I'l try ghcmod-vim :) If I don't like it, I'll stop. Assuming I can get it to work
13:54:13 <nand`> but I guess that's a problem for #vim, not #haskell
13:54:28 <paolino> thanks rwbarton
13:54:33 <sfogarty> does that fix it, nand`?
13:55:58 <sfogarty> I haven't installed a vim module in years.
13:56:40 <jfischoff> sfogartey: oh crap you need vimproc installed first which is a pain
13:57:19 <sfogarty> meh. nevermind then.
13:57:38 <sfogarty> I can :!hlint %
13:57:42 <jfischoff> I bet the whole process would take thirty minutes to setup
13:57:44 <jfischoff> yeah
13:58:19 <sfogarty> and I'd have to do it twice: on my cygwin box and my linux account
13:58:36 <jfischoff> ugh cygwin
13:58:50 <jfischoff> you poor soul
13:59:23 <sfogarty> easier to just install all of cygwin than deal with managing my own OS :)
14:01:35 <mcstar> should i upload this stupid game to hackage?
14:01:40 <jfischoff> eys
14:01:43 <jfischoff> yes
14:01:45 <mcstar> whats the minimum thing ppl upload/
14:01:48 <mcstar> ?
14:01:54 <jfischoff> a function
14:01:58 <mcstar> lol
14:02:22 <Clint> a data type
14:03:21 <pnielsen> well, there are several useful programs that can be expressed in one/a few lines in Haskell, e.g. most of the GNU coreutils
14:03:40 <pnielsen> I seem to recall a wiki page with examples of a Haskell BusyBox
14:03:42 <donri> sfogarty: hdevtools is better
14:03:47 <pnielsen> http://www.haskell.org/haskellwiki/Simple_unix_tools
14:03:55 <sfogarty> !where hdevtools
14:04:16 <sfogarty> @where hdevtools
14:04:16 <lambdabot> I know nothing about hdevtools.
14:04:26 <mcstar> hm, id need to register
14:04:54 <sfogarty> I'll take a look
14:04:55 <donri> adnauseam: haskim's slowness is probably my fault due to vim2hs :) problem is it's not slow for me, so i can't debug it.
14:05:15 <mcstar> and people use their real names for hackage
14:05:17 <donri> adnauseam: i'd love some feedback in https://github.com/dag/vim2hs/issues/28
14:06:28 <donri> sfogarty: for hlint integration i recommend syntastic and/or vim2hs
14:07:02 <sfogarty> meh. I never got much into vim hacking. I just use screen and split to run things side by side
14:08:26 <donri> jfischoff: oh, you too re feedback on that vim2hs issue linked above
14:09:26 <pnielsen> hlint suggests replacing case expressions on bools with if. Is that really best practice?
14:09:28 <jfischoff> donri: I let you know when I get my vimrc setup again :).
14:10:03 <lpvb> what algorithm does System.Random use to generate numbers?
14:10:38 <ski> pnielsen : depends
14:10:46 <donri> pnielsen: an if-expression has the benefit that you are forced to consider both cases and it doesn't affect layout (i think?)
14:10:55 <lispy> Lajjla: look at the type naturals extension to GHC. It will make putting the shape of the matrices in the type system much easier than it currently is
14:10:57 <pnielsen> lpvb: "This implementation uses the Portable Combined Generator of L'Ecuyer [System.Random] for 32-bit computers:"
14:11:03 <donri> pnielsen: on the other hand a case might be easier to refactor if the type later changes, and sometimes you do want to leave out a case because it's covered elsewhere
14:11:06 <lpvb> I don't know what that is
14:11:19 <lpvb> and the paper doesn't look publicly available
14:11:22 <lispy> byorgey: noted (BTW, can you just use the GLFW-b backend for gloss for now? I believe the answer is: yes)
14:11:57 <pnielsen> donri: the then is a do block so it suggests surrounding that with parens
14:12:00 <lispy> Polarina: Right. I did a huge refactor this weekend and some of that stuff is either no longer implemented or I haven't gotten around to it yet :) That code hasn't seen battle yet.
14:12:03 <pnielsen> donri: I guess that's fine
14:12:11 <lispy> Polarina: No one has "used it in anger" yet :)
14:12:22 <pnielsen> donri: I don't imagine these will change from being just bools. Thanks
14:12:26 <Polarina> lispy, you're looking at me. :)
14:12:32 <donri> pnielsen: shouldn't be needed? how are you formatting that and are you using Haskell2010/DoAndIfThenElse?
14:13:08 <lispy> Polarina: if you're on linux or osx, you can use hmatrix for now
14:13:12 <donri> pnielsen: or are you referring to what hlint suggests? because it probably uses HSE's pretty printer which likes to insert lots of parenthesis :)
14:13:17 <trotro> rwbarton, no, in fact I got only one criterium when i coded : no copy/paste, and that something to complex today for a machine to understand
14:13:27 <lispy> Polarina: it's very fast and full featured, but it's a) GPL'd, b) hard to build on windows
14:13:28 <Polarina> lispy, I'm actually on Windows, unfortunately.
14:13:29 <pnielsen> donri: yeah, what hslint suggests
14:13:47 <lispy> Polarina: maybe try Vect?
14:13:54 <lispy> Polarina: It's very similar to what I'm writing
14:14:08 <lispy> Polarina: http://hackage.haskell.org/package/vect
14:14:25 * lispy has to run again
14:15:10 <Polarina> lispy, I was looking into http://hackage.haskell.org/package/Vec . Seems to have everything I want, except packed Mat4x4 floats.
14:17:49 <sfogarty> https://github.com/bitc/vim-hdevtools has an error in the help file: it tells you install hdevtools, not vim-hdevtools, in the vim bundle directory
14:17:54 <swarley> what's the operator for sending the result of an action directly to a function? is it >>= or something like that?
14:18:29 <jfischoff> :t (>>=)
14:18:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:18:33 <trotro> @hoogle m a -> (a -> b) -> m b
14:18:33 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
14:18:34 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
14:18:34 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
14:18:34 <donri> depends on the type of the function
14:20:00 <trotro> can haskell see the future ?
14:20:09 <trotro> ho it doesn't work ? :'(
14:20:29 <dimka> Can haskell make me a cake?
14:20:44 <trotro> :'( sic
14:20:47 <dcoutts_> @faq Can haskell make me a cake?
14:20:48 <lambdabot> The answer is: Yes! Haskell can do that.
14:20:55 <trotro> :D
14:20:58 <dcoutts_> @botsnack
14:20:59 <dimka> :[
14:20:59 <lambdabot> :)
14:21:02 <sfogarty> hmn. hdevtools-vim doesn't seem to be working. Anyone familiar with it?
14:21:08 <sfogarty> "hdevtools: hdevtools is not executable! "
14:21:14 <MostAwesomeDude> @faq future, cake, baking thereof; can Haskell perform clairvoyant baking of pastries and confections?
14:21:15 <lambdabot> The answer is: Yes! Haskell can do that.
14:22:13 <dimka> dcoutts_: do you know something about glib package?
14:22:30 <dcoutts_> dimka: that's a rather open ended question :-)
14:22:39 <dimka> Could it be usable in ghc-7.6.1 someday?
14:22:50 <swarley> i'm trying to get a grasp on yesod..
14:22:53 <mcstar> if i have a record that acts like a state, it would actually make sense to use a monad instead
14:22:59 <sfogarty> okay, my .bashrc doesn't seem to be running when I log in
14:23:04 <sfogarty> that's... unusual. and irrelevent to this channel
14:23:04 <dcoutts_> dimka: I'm sure, see the gtk2hs-devel mailing list, I think there's been some discussion of 7.6 patches
14:24:16 <mcstar> or not?
14:24:56 <mcstar> im passing the World record around, and update parts of it
14:25:01 <geekosaur> someone posted patches, yes
14:26:18 <sfogarty> yeah, can't get HDevTools vim to work.
14:26:24 <dimka> It will be better if someone post new package on hackage :[
14:26:29 <dimka> Anyway, thanks for info
14:26:57 <sfogarty> hdevtools: bind: resource busy (Address already in use)
14:27:00 <mcstar> wasnt there a github graph of the number of clones?
14:27:22 <marzipanmartian> hey cabal says I have attoparsec installed, but when I call ":m +Data.Attoparsec" from ghci I get <no location info>: Could not find module `Data.Attoparsec.Combinator': it is not a module in the current program, or in any known package.
14:27:53 <rhodesd> marzipanmartian: have you restarted ghci since installing?
14:29:47 <sfogarty> hmn. I have to run hdevtools at least once before I start vim for it to work
14:30:51 <mcstar> mayeb i should write up small functions, that change World, and compose them
14:31:26 <mcstar> https://github.com/liquid-phynix/asteroids/blob/master/Game.hs#L73
14:31:34 <mcstar> ^^ look at that, really messy
14:32:12 <mcstar> when i start priming ' labels, i think i must be doing something bad
14:33:01 <sfogarty> donri: yeah, too much work to just check the types of my expressions in vim
14:35:22 <donri> sfogarty: not that much work? https://github.com/bitc/vim-hdevtools
14:36:17 <sfogarty> donri: I have to start hdevtools on my machine before it will work (otherwise it gives a bind error), and I could be working on any one of a hundred machines.
14:36:31 <sfogarty> slight exadgeration
14:36:32 <shachaf> Is there some clever way of making an n-ary unzip?
14:36:52 <otters> template haskell?
14:36:52 <maukd> can I redefine the problem first?
14:37:05 <jfischoff> shachaf: using zap
14:37:10 <jfischoff> I think
14:37:17 <jfischoff> also using TH
14:37:27 <shachaf> @ty zap
14:37:29 <lambdabot> Not in scope: `zap'
14:38:24 <donri> sfogarty: hm it Just Works™ for me, no need to start anything
14:38:34 <jfischoff> shachaf: look for zap here
14:38:36 <jfischoff> http://www.soi.city.ac.uk/~ross/papers/Applicative.pdf
14:38:52 <sfogarty> donri: it only works for me if I call hdevtools --check on a file before I start using vim.
14:38:53 <shachaf> jfischoff: That's for zip, not unzip, isn't it?
14:39:10 <jfischoff> yes sir
14:39:11 <shachaf> I know how to make n-ary zip -- that's just <$> and <*> in ZipList.
14:39:13 <donri> sfogarty: are you using the vim plugin for hdevtools or are you using hdevtools itself manually?
14:39:15 <jfischoff> crap
14:39:19 <maukd> shachaf: transpose
14:39:22 <jfischoff> I misread what you asked for
14:39:24 <sfogarty> the vim plugin
14:40:27 <shachaf> maukd: True, except the types aren't homogeneous here.
14:40:28 <marzipanmartian> rhodesd: thank you! that was the issue
14:41:25 <donri> sfogarty: hm, works for me. perhaps report a bug?
14:42:25 <donri> sfogarty: looks like there's already a bug and pull request for your issue
14:42:43 <sfogarty> ok
14:43:48 <sfogarty> I'm also not dying to know the types of expressions in my file.
14:46:38 <marzipanmartian> is there a 'many' function for attoparsec? also, what is the proper way to search a haskell library? right now I'm really just going by hackage, and I can't tell if this is the recommended way to learn about a library.
14:46:38 <hpaste> obk pasted “Monoid + List?” at http://hpaste.org/75632
14:47:45 <donri> marzipanmartian: i think atto is an Alternative
14:47:53 <obk> Is there a type class which is like a Monoid but distinguishes between the singleton element and the collection?
14:48:12 <donri> marzipanmartian: hoogle and hayoo can be used to search librarise
14:48:41 <donri> obk: there's the semigroup which is monoid sans identity
14:49:37 <obk> donri: That is still defined in terms of a single type, though...
14:49:41 <jfischoff> obk: what is your use case?
14:50:13 <donri> obk: skimming your hpaste maybe you're looking for generics
14:50:13 <obk> jfischoff: http://hpaste.org/75632 sort of explains it.
14:50:21 <ocharles> argh, still no 7.6 in arch linux. i want to play with indexed monads :(
14:50:29 <ocharles> maybe index-core is enough for what i want to do
14:50:36 <obk> Hmmm - I haven't played with generics... might be...
14:51:57 <jfischoff> obk: if you want a list like abstraction foldable might work
14:52:10 <obk> I guess what I really need is some sort of "zipN" - can that be written, somehow?
14:52:27 <obk> (My TH generates tuples which could be ~20 entries long)
14:53:45 <obk> jfischoff: Foldable might be it...
14:54:48 <jfischoff> obk: you can look at ZipList for zipN and http://hackage.haskell.org/package/tuple-0.2.0.1 for an example of straightforward way to deal with tuples of different sizes
14:56:18 <danharaj> Has anyone used the reflection package/
14:58:35 <obk> Hmmm. ZipWithN still assumes all the elements have the same type - in that case, one might as well use transpose, no?
14:59:59 <sfogarty> now if only I could figure out how to get ghc --make to deal with happy
15:02:02 <jfischoff> I'm pretty sure cabal will handle that for you
15:02:14 <jfischoff> might be time for cabal init
15:02:28 <sfogarty> oh, happy is installed. I just can't get ghc --make to run happy on the .y file.
15:02:53 <jfischoff> right, I think cabal is smart enough to do stuff like that
15:03:02 <jfischoff> atleast it will for hsc files
15:03:02 <sfogarty> ah
15:03:26 <sfogarty> cabal will make my own files?
15:03:32 <dcoutts_> it'll do .y files
15:03:41 <dcoutts_> just have to list all the modules in the .cabal file
15:03:55 <dcoutts_> (otherwise it doesn't know they exist and need pre-processing)
15:04:10 <sfogarty> ah, well I could just make a Makefile then
15:04:23 <jfischoff> cabal is really easy
15:04:45 <jfischoff> `cabal init` and you'll get a wizard
15:06:19 <sfogarty> make is really easy too :)
15:07:07 <marzipanmartian> is dot notation just for making currying more explicit? "call this function, than all these functions, and wait for last arg" is my understanding of it
15:07:18 <marzipanmartian> then*
15:09:03 <maukd> shachaf: http://hpaste.org/75633 what have I done
15:09:04 <ski> marzipanmartian : it is for focusing more on the functions themselves
15:09:50 <ski> instead of "when this function is called, it calls this, and then that, function" you have "this function is the composition of this and that function"
15:10:26 <ski> @type \cons nil as -> foldl (\k a r -> k (cons a r)) (\r -> r) as nil  -- hmm
15:10:27 <lambdabot> forall t b. (b -> t -> t) -> t -> [b] -> t
15:10:44 <ski> > (\cons nil as -> foldl (\k a r -> k (cons a r)) (\r -> r) as nil) f z [a,b,c,d]
15:10:45 <lambdabot>   f a (f b (f c (f d z)))
15:15:07 <shachaf> mauke++
15:15:30 <maukd> I hope I'm not turning into oleg
15:16:36 <maukd> I'd be interested in a version using type families
15:17:41 <shachaf> Also you can use the fancy DataKinds these days.
15:18:07 <Cale> maukd: Converting that to type families should be easy
15:18:45 <Cale> Just remove the r parameter and add  type UnzipOf a
15:18:50 <Cale> and then use that in place of r
15:19:15 <maukd> it didn't like type UnzipOf a = [a] :- UnzipOf b
15:19:26 <Cale> hmm
15:19:31 <maukd> oh wait
15:21:02 <maukd> http://hpaste.org/75634
15:21:41 <Cale> uh, it worked for me
15:21:43 <Cale> ah
15:22:11 <Cale> yeah, that's pretty much what I have, I think. That's compiling for you now?
15:22:15 <ski> (hm, `nu s. f s' is equivalent to `exists s. (s,s -> f s)' ..)
15:22:19 <maukd> yes
15:22:23 <maukd> and running :-)
15:23:40 <alpounet> what would be the equivalent of urllib.urlretrieve (Python) in Haskell? i think it's pretty much about using the "program associated to some file type"
15:23:50 <Cale> also, you don't need UndecidableInstances
15:24:20 <Cale> alpounet: There's a binding to curl on Hackage.
15:24:34 <maukd> Cale: ghci told me otherwise
15:24:50 <Cale> http://hackage.haskell.org/package/download
15:25:06 <Cale> maukd: Well, try removing it now?
15:25:07 <alpounet> Cale, oh, curl does that? i mean it's supposed to work for local urls, and for files being say PNGs, etc
15:25:38 <alpounet> my question is mostly about finding out the "program associated to that kind of file"
15:25:38 <Cale> alpounet: there's also that download package I just linked
15:25:47 <Cale> er, what do you mean?
15:26:03 * ski . o O ( `data T a b = MkT (a -> b) (T a (T a b))' )
15:26:10 <alpounet> urllib.urlretrieve seems to do that, so i was wondering whether we had that too
15:26:22 <maukd> Cale: well, now that I've switched to type families it's no longer there anyway
15:27:11 <donri> duno urlretreive but urlopen basically gives you a Handle for any URL, including file://, and also plain filepaths. i think that's what alpounet is after?
15:27:27 <Cale> alpounet: That doesn't sound anything like what urllib.urlretrieve does
15:27:47 <Cale> Copy a network object denoted by a URL to a local file, if necessary. If the URL points to a local file, or a valid cached copy of the object exists, the object is not copied. Return a tuple (filename, headers) where filename is the local file name under which the object can be found, and headers is whatever the info() method of the object returned by urlopen() returned (for a remote object, possibly cached). Exception
15:27:47 <Cale> s are the same as for urlopen().
15:28:01 <alpounet> Cale, below you can also read: The public functions urlopen() and urlretrieve() create an instance of the FancyURLopener class and use it to perform their requested actions. To override this functionality, programmers can create a subclass of URLopener or FancyURLopener, then assign an instance of that class to the urllib._urlopener variable before calling the desired function.
15:28:28 <alpounet> anyway, sorry if my first question was unclear, but i think you now see what i mean
15:28:47 <Cale> What?
15:28:50 <Cale> uhhh
15:29:08 <Cale> You want to set a different User-Agent for an HTTP request?
15:29:21 <alpounet> no
15:29:23 <alpounet> alright, nevermind
15:29:36 <Cale> I don't understand what you're trying to accomplish here at all :)
15:30:01 <alpounet> yeah, i can see that, i know i'm unclear, i'll just somehow manage to solve this :P
15:30:25 <Cale> At first it sounded like you were talking about Windows registry file associations.
15:31:18 <Cale> I'm pretty sure there's a binding to the basic Windows APIs somewhere that you could use to get at that kind of information, but I don't know what it has to do with downloading a URL.
15:31:46 <alpounet> kind of yeah, but their urlretrieve thing works on linux too
15:32:33 <Cale> So, it guesses that you're using Gnome or something and looks through Nautilus' configuration?
15:32:50 <Cale> Linux doesn't have a real concept of file associations, so that doesn't make much sense.
15:32:50 <alpounet> yeah gnome
15:32:59 <alpounet> i don't know how it does that, i'll try to find out
15:33:04 <alpounet> thanks anyway
15:33:22 <clahey> So, I'm still failing to understand where I would store global state in a gtk+ haskell program.
15:33:25 <bfig> how can i print the typeclass in ghci without printing the available instances?
15:33:53 <Cale> clahey: Usually in various structures which are created just prior to setting your event handlers
15:34:01 <bfig> clahey, you can store it by using closures and rebinding functions?
15:34:04 <Cale> clahey: IORefs and such.
15:34:51 <Cale> bfig: you can't? I believe :info will always tell you the instances which are in scope.
15:35:15 <Cale> bfig: but why?
15:35:47 <bfig> well, i just wanted to see what Ord had (i haven't used haskell in a while :p) and i had *too many* accessible instances
15:36:03 <byorgey> lispy: sadly, the gloss package depends on the GLUT package no matter what backend you use
15:36:16 <Cale> bfig: just scroll up a bit? :)
15:36:31 <bfig> this time it will do i guess :p
15:36:37 <byorgey> lispy: one might argue that's a problem with gloss's .cabal file, but it's the case nonetheless
15:36:57 <bfig> there should be an easier way to see it... at least the definitions should be on the bottom (so they are more easily visible
15:36:57 <Cale> bfig: apart from that, you'll find source code links in the haddock documentation
15:37:32 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-prim-0.3.0.0/src/GHC-Classes.html#Ord -- what I get by clicking the source link from
15:37:36 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/Prelude.html#t:Ord
15:38:48 <Cale> While programming in Haskell, I generally have three windows open: one with ghci, one with a text editor, and one with a web browser for documentation :)
15:38:51 <Cale> (and source!)
15:39:22 <bfig> :). i usually do that too :p
15:39:36 <bfig> the other window is irc for asking questions and a book for the algorithms :p
15:40:00 <Cale> Yeah, and I guess I never close IRC :P
15:40:28 <bfig> it's not a window in the sense that in can be closed anymore :)
15:48:20 <clahey> rebinding functions?
15:48:30 <clahey> So every time you change your global state you rebind all your callbacks?
15:48:33 <clahey> That sounds expensive.
15:49:49 <bfig> you don't need to rebind everything, since most functions can depend on mutable attributes stored in the different gui features
15:50:31 <clahey> Ah, so you mostly have a Window and then put a haskell object in as glib data.
15:50:47 <clahey> But IORef gives you the same thing in a somewhat more haskell specific way.
15:50:55 <clahey> Cale: No one told me about IORefs.
15:51:12 <bfig> sure, iorefs are prettier, i'd go with Cale's solution
15:51:37 <bfig> i remember i did a simple application just using rebinds but iorefs are fine
15:51:45 <bfig> (are better*)
15:51:59 <dimka> I'm trying to use daemonize function from hdaemonize package. I need a PID of daemonize thread to be able to kill it. daemonize did 2 forkProcesses (https://github.com/madhadron/hdaemonize/blob/master/System/Posix/Daemonize.hs#L79). So could I write getProcessID + 2?
15:52:36 <clahey> bfig: If you use glib data, I don't think you would need to rebind everything.
15:52:58 <clahey> Your IO bindings would just pull the state from the glib data and then write it out the the glib data when you're done.
15:53:06 <clahey> But yeah, definitely going to use IORefs.
15:53:12 <clahey> Or STM if I go with multiple threads.
15:53:14 <bfig> yes, i only used it for something very specific, most functions can just rely on the different object attributes. you can share whatever you want through closures on hidden objects too
15:53:35 <clahey> I didn't realize that you need to yield in gtk programs so often.
15:53:40 <clahey> That seems like a major weakness.
15:53:54 <trotro> dimka, no
15:53:59 <m3ga> dimka: i suspect that getProcessID + 2 is unsafe because you have no guarantee that other processes aren't being started at the same time.
15:54:34 <trotro> dimka, just tweak to code to get the grandchild pid
15:56:26 * ski . o O ( `data T s a b = MkT (s b -> a -> b) (s b -> s (s b))' )
15:56:40 <danharaj> https://github.com/ekmett/reflection/blob/master/fast/Data/Reflection.hs
15:57:01 <danharaj> This works because GHC/Hugs represents typeclasses and explicit dictionary passing functions in the exact same way?
15:57:16 <ski> danharaj : i think so, yes
15:57:47 <danharaj> So reflection has almost no runtime overhead?
15:57:58 <ankan_> Can I use the filter-function on 2 different requirements at the same time using lambda? Like if I want to filter >2 and <7
15:57:59 <clahey> dimka: getProcessID + 2 = NO.
15:58:02 <ski> @free unsafeCoerce :: a -> b
15:58:03 <lambdabot> g . unsafeCoerce = unsafeCoerce . f
15:58:10 <ankan_> without using copypastaprogramming
15:58:18 <trotro> ankan_, yes you can
15:58:29 <monochrom> filter (\x -> x>2 && x<7)
15:58:30 <c_wraith> hahaha.  that's quite a free theorem
15:58:43 <ski> > filter (\x -> x > 2 && x < 7) [1,4,2,8,5,7]
15:58:44 <lambdabot>   [4,5]
15:58:48 <clahey> ankan_: Why not just do (filter (>2)) . (filter (< 7))
15:58:50 <shachaf> c_wraith: A fitting theorem for such a function.
15:58:57 <shachaf> @free undefined :: a
15:58:57 <lambdabot> f undefined = undefined
15:59:08 <danharaj> :t filter ((&&) <$> (>2) <*> (<7))
15:59:10 <lambdabot> forall a. (Num a, Ord a) => [a] -> [a]
15:59:10 <dimka> trotro: how can I get grandchild pid?
15:59:11 <clahey> ankan_: Or is that copypastaprogramming?  I'm not sure what you mean by that.
15:59:15 <ski> clahey : according to it, one can move around the call to `unsafeCoerce' quite a lot ;)
15:59:17 <shachaf> Oh, that's a nice theorem.
15:59:18 <danharaj> pointless pointlessness
15:59:18 <trotro> or foldr (\x -> true) (\p -> f -> \y -> p y && f y) [(< 7), (> 2)] :D
15:59:23 <ski> c_wraith ^
15:59:29 <shachaf> In a total language, all functions are strict, I guess. :-)
15:59:33 <trotro> dimka, each fork return a pid
15:59:50 <trotro> ho dimka
15:59:52 <clahey> danharaj: I haven't gotten the total hang of <$> and <*> yet.
16:00:05 <trotro> the current pid after daemonize is the pid of the daemon
16:00:05 <danharaj> :t (&&)
16:00:07 <lambdabot> Bool -> Bool -> Bool
16:00:21 <clahey> dimka: I believe what daemonizers usually do is fork, set up a pipe, fork again, then pass the grandchild pid over the pipe.
16:00:26 <danharaj> You want something like (&&) that has type (a -> Bool) -> (a -> Bool) -> Bool
16:00:30 <danharaj> fortunately that is functorial.
16:00:31 <ankan_> trotro, ski, clahey: thanks
16:00:32 <c_wraith> shachaf: have you seen conor mcbride's presentations on that topic?
16:00:38 <danharaj> so you can lift it via fmap.
16:00:42 <danharaj> <$> is fmap.
16:00:44 <ankan_> clahey: well yeah, I meant in a single filter, not two different
16:00:47 <ankan_> :)
16:00:49 <cmccann> heh, free theorem for unsafeCoerce
16:00:55 <clahey> ankan_: Why do you want a single filter instead of two?
16:01:02 <ski> @type foldr (\p f y -> p y && f y) (\x -> True) [(< 7), (> 2)]
16:01:03 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
16:01:03 <danharaj> :t (&&) <$> (>2)
16:01:05 <lambdabot> forall a. (Num a, Ord a) => a -> Bool -> Bool
16:01:16 <trotro> ho I was correct :)
16:01:27 <danharaj> :t (<*>)
16:01:29 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:01:29 <c_wraith> shachaf: total languages can return explicit codata - so long as they can prove they do.
16:01:48 <clahey> danharaj: Well, maybe I have the hang of using them, but I don't think of it.
16:01:56 <danharaj> If you want to become a pro at <$>, try to figure out what the functor is!
16:01:56 <ankan_> clahey: Just wanted to know if it was possible,
16:02:04 <ankan_> for learning purposes
16:02:10 <ankan_> kinda new to haskell
16:02:15 <clahey> ankan_: Me too.
16:02:25 <clahey> ankan_: Hence just learning about IORef.
16:02:34 <ankan_> :)
16:02:51 <ski> ankan_ : `forall p q.  filter q . filter p = filter (\x -> p x && q x)'
16:03:26 <clahey> So, if I want mutable global data in a gtk program, would people prefer IORef (a, b, c) or (IORef a, IORef b, IORef c) or something else or am I asking the wrong question?
16:03:56 <ski> clahey : note that those are different things
16:03:58 <trotro> @hoogle m a -> m a -> (a -> a -> a) -> m a
16:03:59 <lambdabot> Data.IntMap unionWith :: (a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
16:03:59 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:03:59 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:04:08 <clahey> ski: That's why I'm asking which is preferred.  :)
16:04:14 <ski> @type liftM2  -- trotro ?
16:04:16 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:04:17 <cmccann> whichever one you need is preferred
16:04:20 <trotro> ski, maybe
16:04:35 <clahey> cmccann: It feels like they're basically the same in practice.
16:04:37 <trotro> ha yes
16:04:46 <shachaf> c_wraith: Nope.
16:04:47 <trotro> hoogle must learn a little bit
16:04:50 <JoeHazzers> oh hell
16:04:51 <trotro> it should have find liftM2
16:04:55 <shachaf> c_wraith: (I haven't seen them.)
16:04:58 <JoeHazzers> i have a functional programming module coming up next term
16:05:03 <shachaf> c_wraith: But that's not inconsistent with what I said.
16:05:10 <JoeHazzers> i should really get back into the flow of things :3
16:05:16 <cmccann> clahey, if they're the same for your purposes then I guess I'd use the single IORef, but I sorta doubt they're truly equivalent
16:05:25 <monochrom> functional programming is easy in haskell
16:05:34 <monochrom> not too hard in scheme
16:05:35 <trotro> no
16:05:42 <trotro> programming is easy in Haskell
16:05:43 <ski> clahey : sometimes you want separatedly updatable pieces of state, sometimes you want a single piece (e.g. compute a single compound new value, and atomically replace the old one in the mutable cell with it)
16:05:44 <monochrom> not entirely impossible in assembly
16:05:51 <clahey> cmccan: From what I'm thinking: The advantage of IORef (a, b, c) is that I can write all the mapping functions pure and lift them to IORefs.  The advantage of (IORef a, IORef b, IORef c) is that if I'm only changing one, it's more efficient.
16:05:53 <ski> @hoogle+
16:05:54 <lambdabot> Data.List unionBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
16:05:54 <lambdabot> Data.IntMap insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
16:05:54 <lambdabot> Data.IntMap insertWith' :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
16:06:05 <c_wraith> shachaf: it's consistent, so long as you explicitly separate data and codata.  haskell uses laziness to combine them, which muddies things a bit.
16:06:06 <JoeHazzers> i've already been doing quite a bit of haskell, i've just never actually *used* it for anything yet :x
16:06:08 <bfig> clahey, do you like STM? that is pretty cool too if you want to do concurrency
16:06:25 <bfig> it allows you to do transactions in monads and share memory at the same time
16:06:36 <clahey> bfig: TVar sounds super similar to IORef except that you can use threads.
16:06:43 <clahey> I tend to not use threads often at all.
16:06:48 <mcstar> hm, im getting stack overflow for using the 'sort' function
16:06:51 <clahey> But then, apparently TVars make them much cleaner.
16:06:56 <bfig> yes... you can use threads in ioref too :)
16:07:14 <bfig> every time you modify something like that you make atomic modifications
16:07:20 <bfig> (with TVar)
16:07:28 <clahey> bfig: Ah, but STM gives me the ability to group them.
16:07:38 <clahey> bfig: Make an atomic change to multiple variables.
16:07:53 <clahey> Whereas with IORef, I can do things atomically, but only one variable is atomic at a time.
16:07:57 <clahey> Only one operation, that is.
16:08:13 <clahey> If I want to do Get and then Put, I need locks.
16:08:15 <shachaf> Compositionality is the main point of STM.
16:08:22 <shachaf> I'd compare TVars to MVars, though, not to IORefs.
16:08:28 <monochrom> mcstar: http://article.gmane.org/gmane.comp.lang.haskell.cafe/37154/ is a nice scenerio of finding out why sort overflows
16:09:36 <c_wraith> shachaf: TVars are more like IORefs than MVars.  They always have a value stored.
16:09:42 <clahey> shachaf: Really, the interface to TVar and IORef is almost identical.
16:10:09 <shachaf> c_wraith: Yes, but in a concurrent setting you'd use MVars a lot more than IORefs.
16:10:10 * ski finds it strange how `foldl' magically appears out of CPSified lists
16:10:20 <shachaf> ski: ?
16:10:37 * cmccann thinks MVars are more like TMVars, surprisingly enough
16:10:37 <clahey> shachaf: Right, the context of TVar is similar to MVar, but the behavior is much much more similar to IOVars.
16:10:38 <ski> shachaf : .. or maybe `SampleVar's
16:10:44 <clahey> cmccann: Shocking.  :)
16:11:03 <clahey> :t TMVar
16:11:05 <lambdabot> Not in scope: data constructor `TMVar'
16:11:08 <clahey> :t TVar
16:11:09 <lambdabot> Not in scope: data constructor `TVar'
16:11:12 <clahey> :t TVar Int
16:11:13 <lambdabot> Not in scope: data constructor `TVar'
16:11:14 <lambdabot> Not in scope: data constructor `Int'
16:11:18 <shachaf> cmccann: MVars are the "MVar-style concurrency" primitive, and TVars are the "STM-style concurrency" primitive.
16:11:25 <clahey> :t TVar 5
16:11:26 <lambdabot> Not in scope: data constructor `TVar'
16:11:33 <shachaf> TMVars are just a library. :-)
16:11:38 <trotro> The lock were abandonned for concurrency/parallelism
16:11:39 <trotro> ?
16:11:55 <shachaf>     Deprecated: "Control.Concurrent.SampleVar will be removed in GHC 7.8. Please use an alternative, e.g. the SafeSemaphore package, instead."
16:11:57 <clahey> cmccann: What's a TMVar?
16:12:10 <shachaf> clahey: It behaves like an MVar but it's transactional.
16:12:15 <cmccann> yeah
16:12:18 <shachaf> @google What's a TMVar?
16:12:18 <lambdabot> http://stackoverflow.com/questions/6915079/difference-between-tvar-and-tmvar
16:12:19 <lambdabot> Title: haskell - Difference between TVar and TMVar - Stack Overflow
16:12:22 <shachaf> That. :-)
16:12:42 <swarley> so i've been poking around miku for a while, and i cannot for the life of me find the actual socket that goes with the request to the server
16:12:48 <swarley> can anyone help me?
16:12:49 <shachaf> STM gives you a different way to implement "blocking", retry.
16:13:12 <cmccann> heh, apparently I wrote the accepted answer to that question
16:13:15 <swarley> I've looking in all the Hack2 as well
16:13:16 <shachaf> swarley: Maybe #haskell-web would know.
16:13:37 <clahey> Oh, so if you get from a TChan, but then some part of your computation fails, the value basically gets ungotten.
16:13:38 <ski> shachaf : `List a' (being `1 + a * List a') to `forall o. (List a -> o) -> o' to `forall o. ListCon a o -> o', where `ListCon a o' is `o * (a -> ListCon a o)' to `exists s. s * (s -> o) -> (s -> a -> s)', so the final result is `forall o. (exists s. s * (s -> o) -> (s -> a -> s)) -> o', which is almost exactly `foldl' (partially applied to a given list)
16:13:50 <clahey> Same with a TMVar.
16:13:53 <clahey> I think I'm starting to get it.
16:15:00 <cmccann> stm is pretty neat.
16:15:16 <ski> (s/exactly/exactly the type of/)
16:15:17 <clahey> I'm trying to decide whether to bother with STM or to stick with IOVars.
16:15:18 <cmccann> a lot of concurrency stuff just works painlessly
16:15:45 <clahey> I guess search and replace wouldn't be so bad and just adding atomically everywhere since I won't have that much to do.
16:15:50 <clahey> I'm pretty convinced.
16:16:12 <ski> shachaf : ok ?
16:16:59 <ski> shachaf : using this idea, i managed to do some loop fusion
16:17:47 <shachaf> ski: I'm not sure I follow.
16:19:10 <cmccann> ski, oh btw--did you have a chance to look at that linear logic stuff I showed you last week?
16:20:23 <mcstar> monochrom: interesting
16:20:31 <mcstar> monochrom: the problem is, that my list is tiny
16:20:38 <ski> shachaf : first, i convert to CPS, then instead of going to Church, i instead turn the continuation into a data type, finally i decompose that into a "state & methods" representation
16:20:43 <mcstar> but possibly i do it a lot of times per second
16:21:44 <ski> shachaf : so, a list is a function that given a `ListCon a o' (a list consumer consuming elements of type `a', yielding a final value of type `o') yields a result of type `o'
16:21:59 <mcstar> monochrom: and doing a reverse doesnt solve it
16:22:29 <mcstar> what i wanted is to sort the asteroids, so that when i draw them, i have a fix number
16:22:45 <ski> shachaf : and a list consumer (initially) contains two parts : the final value to use if we've reached the end of the list; and a function to pass the current element to (yielding a new list consumer to apply to the tail) if we're not at the end
16:22:50 <clahey> I think I like IORef World instead of having World contain a bunch of IORefs.
16:23:01 <clahey> It might be a little slower, but most of the code can be pure.
16:23:02 <trotro> @source sum
16:23:02 <lambdabot> sum not available
16:23:03 <mcstar> and so eliminate a flicker, that i believe results from close asteroids changing position in the pipleline multiple times per sec
16:23:03 <shachaf> ski: Oh, "Con" is consumer, not constructor.
16:23:12 <ski> shachaf : yes
16:24:19 <trotro> @source foldl
16:24:19 <lambdabot> foldl not available
16:24:33 <ski> shachaf : but this list consumer can also be expressed as a pair of an internal state and two methods, one which extract (/computes) the final result from the state (in case there were no more elements); and one which combines the next element into the state, giving a new state (so we don't change the methods when iterating, just the state)
16:24:48 <ski> @src foldl
16:24:49 <lambdabot> foldl f z []     = z
16:24:49 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:24:56 <ski> @src sum
16:24:57 <lambdabot> sum = foldl (+) 0
16:25:23 <swarley> could Data.ByteStream be an open socket?
16:25:30 <swarley> errr
16:25:34 <trotro> sum is not defined with foldr ? wooo....
16:25:35 <swarley> nevermind
16:25:50 <trotro> @src foldr
16:25:51 <lambdabot> foldr f z []     = z
16:25:51 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
16:25:53 <swarley> https://github.com/nfjinjing/hack/blob/master/src/Hack.hs
16:26:04 <swarley> does anyone see any sort of socket IO there? lol
16:26:47 <ski> shachaf : the nice thing in the final list consumer representation is that all the loops in functions that consume lists are gone -- only operations that produce a list without consuming one will contain a loop -- and that's how i get loop fusion here
16:27:41 <clahey> mcstar: Might the flicker be because your update loop is linked to your render loop?
16:27:57 <mcstar> no
16:27:59 <mcstar> not like that
16:28:33 <mcstar> and they are though pairwise-recursive, they are updated in independent intervals
16:28:59 <ski>   sumList' (mapList' my_fun (runningSum' (bits' <my_int>)))
16:29:00 <mcstar> anyway, why 'sort' casuse a SO on a short list is beyond me
16:29:07 <ski> e.g. is translated into
16:29:16 <ski>   <let fun a (0,b) = let val (d,c) = b  in c %+ %my_fun d end
16:29:20 <shachaf> ski: Makes sense.
16:29:25 <ski>          | a (f,e) = a (f %div 2,
16:29:36 <ski>                         let val (h,g) = e  in (h %+ f %mod 2,g %+ %my_fun h) end)
16:29:41 <trotro> to understand lazy, some has to understand why functional = imperative :D
16:29:51 <ski>   in a (%my_int,(0,0)) end>
16:30:25 <ski> (`a' here is the only loop that remains, it comes from `bits' -- `a',`b',`c',`d' are auto-generated names)
16:31:16 <mcstar> hehe, it works if the list has 1 element, and So if it has 2
16:31:20 <trotro> Thus for example "last (f 1000000)" overflows, while "print (f 1000000)"  >> that one is exactly what I said :)
16:31:48 <mcstar> wait, is somebody talking about my problem?
16:32:36 <ski> shachaf : atm, i'm trying to understand why this apparently works, and how (if) it can be generalized to other data types
16:33:05 <trotro> mcstar, people are thinking about it I think
16:33:21 <ski> (btw, the `sumList' example above is the actual result of evaluating code -- no hand-evaluation there)
16:33:48 <mcstar> it is really weird, cause everything works fine, until a throw the sort in on this mostly 2 element list
16:33:53 <mcstar> a -> i
16:36:16 <ski> cmccann : hm, not much yet :/ -- i've been busy pondering the above fusion-related thing ..
16:37:12 <cmccann> ski, ok, no worries. had a few ideas about how to implement the exponential operators, but haven't gotten back to it yet.
16:37:17 <mcstar> clahey: did you manage to build it?
16:37:43 <clahey> mcstar: Haven't really tried.  Let me switch to my 12.04 machine.
16:40:19 <mcstar> ok, i solved it
16:40:25 <mcstar> or rather, went around it
16:40:45 <mcstar> i had an Asteroid record, that had a unique serial number
16:40:45 <clahey> mcstar: I'm missing GLFW-b == 0.1.*
16:40:48 <clahey> OpenGL == 2.5.*
16:41:03 <mcstar> i clahey try lowering them
16:41:06 <clahey> StateVar, colour, cond, and graphics-drawingcombinators
16:41:27 <mcstar> clahey: well, cabal is supposed to install those
16:41:44 <mcstar> so, i defined Ord and Eq for this record
16:41:56 <clahey> mcstar: Is cabal configure supposed to do that?
16:42:19 <mcstar> hm, actually i dont know
16:42:32 <mcstar> i think yeah
16:42:39 <clahey> mcstar: I'll just use apt to get as many as I can and then do the rest with cabal.
16:42:45 <mcstar> k
16:42:51 <clahey> I prefer that anyway.
16:42:57 <clahey> I should just apt-get install libghc-*
16:43:23 <mcstar> is it enough to define defined (<) for Ord and (==) for Eq?
16:43:33 <mcstar> cause if not, then maybe i messed it up here
16:44:16 <mcstar> ski ^^ ?
16:44:28 <clahey> mcstar: I think you want to define compare for Ord, but I could be wrong.
16:44:48 <mcstar> but compare has equality too
16:44:58 <mcstar> but why would you need to define equality for Ord?
16:46:07 <ski> mcstar : `-- Minimal complete definition: (==) or (/=)' resp. `-- Minimal complete definition: (<=) or compare'
16:46:29 <clahey> I would have thought that < would have been good enough.
16:46:33 <mcstar> ok, not < then
16:46:45 <clahey> Since it has == being an instance of Eq.
16:46:58 <ski> mcstar : but `(<)' would also work ..
16:47:12 <jmcarthur> why would (<) work?
16:47:21 <mcstar> it doesnt
16:47:28 <mcstar> loops and exhausts the stack
16:47:32 <ski> hm
16:47:49 <mcstar> i went around by using sortBy compare `on` serialNumber
16:47:50 <jmcarthur> (<=) is sufficient to define a total ordering
16:48:03 <jmcarthur> including (==), although you still have to write the Eq instance
16:51:19 <ski> mcstar : oh, right, now i see
16:51:50 <clahey> Where do <$> and <*> come from?
16:51:57 <c_wraith> Control.Applicative
16:51:57 <ski> @index <$>
16:51:58 <lambdabot> bzzt
16:51:59 <ski> @index <*>
16:52:00 <lambdabot> bzzt
16:52:05 <c_wraith> index hates you
16:52:07 <ski> bah
16:52:08 <Eduard_Munteanu> @index (<$>)
16:52:08 <lambdabot> bzzt
16:52:14 <shachaf> hoogle
16:52:47 <clahey> Data.Functor.
16:52:55 <mcstar> clahey: the code is a bit nicer now, you can take a look :) there are parts that need a rewrite though, the game control part for example
16:53:01 <ski> mcstar : <http://darcs.haskell.org/packages/base/GHC/Classes.hs> shows how `compare' would call `(<=)' calling `compare', if you don't provide a concrete implementation of at least one of them
16:53:01 <mcstar> its too late, im going
16:53:17 <mcstar> bb
16:54:16 <clahey> mcsmash_: Sleep well.
16:54:22 <clahey> Oh, mcstar left.
16:54:47 <clahey> ski: You're one of the few people I know that use <> around URIs correctly.  Hooray.
16:56:24 <ski> clahey : well, i actually (usually) skip the `URL:' part suggested by the RFC
16:56:27 <swarley> miku is freaking impossible to find out how it works for me
16:56:31 <swarley> the code isnt even complicated
16:56:39 <swarley> its just scattered freaking everywhere
16:56:44 <clahey> @hoogle (Bool -> Bool -> Bool) -> (Int -> Int -> Bool) -> (Int -> Int -> Bool) -> Int -> Int -> Bool
16:56:45 <lambdabot> No results found
16:57:13 <jmcarthur> :t on  -- not quite, but close
16:57:15 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
16:57:55 <clahey> Hmm.
16:58:08 <jmcarthur> clahey: what's it for. a comparison of some sort?
16:58:12 <aristid> clahey: f x a b i j = if x i j then a i j else b i j?
16:58:31 <jmcarthur> aristid: that isn't quite right
16:58:35 <clahey> f x a b i j = x (a i j) (b i j)
16:58:54 <clahey> I was trying to write it point-free.
16:59:04 <jmcarthur> do you know about @pl ?
16:59:07 <aristid> @pl f x a b i j = x (a i j) (b i j)
16:59:07 <lambdabot> f = (liftM2 ap .) . (.) . (.)
16:59:12 <aristid> hmm.
16:59:19 <jmcarthur> that has an interesting symmetry to it
16:59:26 <aristid> i still don't like it
17:00:31 <clahey> > ((liftM2 ap .) . (.) . (.)) (||) (==) (<)
17:00:33 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> GHC.Bool.Bool)
17:00:33 <lambdabot>    arisin...
17:00:50 <aristid> clahey: :t
17:00:55 <clahey> :t ((liftM2 ap .) . (.) . (.)) (||) (==) (<)
17:00:56 <lambdabot> forall a. (Ord a) => a -> a -> Bool
17:01:18 * Polarina loves easy refactoring.
17:01:19 <clahey> aristid: So, I didn't actually want it to be that point free.
17:01:41 <clahey> f i j = i < j || i == j
17:01:46 <clahey> @pl f i j = i < j || i == j
17:01:46 <lambdabot> f = ap (ap . ((||) .) . (<)) (==)
17:01:54 <aristid> @fpl f x a b i = x (a i) (b i)
17:01:54 <lambdabot> f = liftM2
17:02:25 <clahey> aristid: Yeah, I knew that it was simple if there was only one input, but I was hoping there was some simple way to do it for two.
17:02:48 <nejucomo> Maybe I've not acquired the taste, but I often don't understand the appeal of point-free.
17:02:49 <clahey> But writing (<=) = ap (ap . ((||) .) . (<)) (==) would not be useful.
17:03:00 <nejucomo> I mean, I understand the appeal, but not the actual result in haskell.
17:03:01 <jmcarthur> :t (liftA2.liftA2) (||) (<) (==)
17:03:03 <lambdabot> forall a. (Ord a) => a -> a -> Bool
17:03:24 <clahey> liftA2.liftA2 (||) (<) (==) 4 2
17:03:27 <clahey> > liftA2.liftA2 (||) (<) (==) 4 2
17:03:28 <lambdabot>   Couldn't match expected type `t -> f (a -> b -> c)'
17:03:29 <lambdabot>         against inferre...
17:03:36 <jmcarthur> the parens are necessary
17:03:40 <clahey> > (liftA2.liftA2 (||) (<) (==)) 4 2
17:03:41 <lambdabot>   Couldn't match expected type `a -> b -> c'
17:03:42 <lambdabot>         against inferred type `G...
17:03:44 <nejucomo> My brain hurts when I see more than one level of (.)
17:03:46 <aristid> not there
17:03:46 <jmcarthur> both of them
17:03:53 <clahey> > (liftA2.liftA2) (||) (<) (==) 4 2
17:03:55 <lambdabot>   False
17:03:58 <clahey> > (liftA2.liftA2) (||) (<) (==) 3 3
17:04:00 <lambdabot>   True
17:04:02 <clahey> > (liftA2.liftA2) (||) (<) (==) 2 4
17:04:04 <lambdabot>   True
17:04:07 <dibblego> nejucomo: more than one level of (.) is typically undesirable
17:04:13 <dibblego> liftA2.liftA2 = liftA2
17:04:19 <clahey> > (liftA2) (||) (<) (==) 2 4
17:04:20 <aristid> that's actually beautifully pointfree, the liftA2.liftA2 there
17:04:20 <lambdabot>   Couldn't match expected type `t -> t1'
17:04:20 <lambdabot>         against inferred type `GHC.B...
17:04:42 <jmcarthur> :t \f a b c d -> (liftA2.liftA2) f a b c d
17:04:44 <lambdabot> forall t t1 a b c. (Applicative ((->) t1), Applicative ((->) t)) => (a -> b -> c) -> (t1 -> t -> a) -> (t1 -> t -> b) -> t1 -> t -> c
17:04:51 <clahey> I like point free cause it kind of gives me an idea of the flow of the information.
17:05:06 <clahey> And I'm trying to learn about functional programming, so it helps me figure out what's possible.
17:05:16 <clahey> I suspect I won't use it as much for actual coding as I do when trying to learn.
17:05:28 <dibblego> liftA2.liftA2 = liftA2 -- with TypeCompose wrap/unwrap
17:05:39 <nejucomo> aristid: Yes, I see the appeal there, I think my qualm is with (.) . (. (.)) . (.) sequences.
17:05:50 <jmcarthur> dibblego: yeah but you have to wrap and unwrap :(
17:05:56 <dibblego> yeah boo
17:06:45 <jmcarthur> nejucomo: i don't think many people actually like those
17:06:51 <nejucomo> I'm back-pedaling here:  Point-free is wonderful in concept and often in practice, but for some cases it's hard to parse.
17:07:21 <clahey> nejucomo: Agreed.
17:07:32 <dibblego> nejucomo: totally, that's why it's only used when readability improves
17:07:34 <rwbarton> the (.) . (. (.)) . (.) nonsense tends to arise when you have too much currying
17:07:39 <clahey> nejucomo: And as soon as it's hard to parse, you should probably rewrite it, unless for pedagogical purposes.
17:07:48 <nejucomo> I think I need to read more real-world haskell (instead of elegant research paper haskell).
17:07:50 <clahey> :t (.) . (. (.)) . (.)
17:07:50 <rwbarton> like (f .) . g -- if you uncurried g it would just be f . g
17:07:51 <jmcarthur> my hypothesis is that beautiful point-free is usually possible for sufficiently short expressions, and still often possible for long ones
17:07:51 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *) b1. (Functor f, Functor f1) => (f1 b -> b1) -> f (a -> b) -> f (f1 a -> b1)
17:07:56 <nejucomo> My ratio of written-to-read is too unbalanced.
17:08:05 <jmcarthur> the stuff @pl produces is often the worst possible, though
17:08:29 <rwbarton> in many cases you really want to think of a two-argument function rather than a function that returns a function
17:08:53 <jmcarthur> i think such cases are actually more rare than it at first may seem
17:08:54 <trotro> http://www.haskell.org/haskellwiki/Iteratee_I/O#The_problem_with_lazy_I.2FO
17:09:05 <rwbarton> (f .) . g is rather common
17:09:05 <trotro> hey folks why is not considered as a bug of ghc ?
17:09:19 <trotro> the io sequential rule violation
17:09:25 <aristid> rwbarton: do you actually uncurry those functions in that case?
17:09:27 <trotro> i don't understand
17:09:32 <jmcarthur> :t \f g -> (f .) . g
17:09:33 <rwbarton> nah
17:09:34 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
17:09:41 <rwbarton> I don't write (f .) . g either though
17:09:48 <jmcarthur> rwbarton: i prefer (fmap.fmap) f g
17:09:53 <rwbarton> I would probably resort to a lambda ^ or that
17:09:55 <rwbarton> I guess...
17:10:09 <rwbarton> still feels like sort of an acquired taste
17:10:37 <clahey> I dislike that uncurry only applies to pairs and not triples.
17:11:01 <BMeph_> rwbarton: I think your argument would make some sense if you had meant "uncurry" instead of "curry" but otherwise, I'm not seeing it.
17:11:01 <clahey> Not that I see how to do it for both, but it makes me uncomfortable.
17:11:21 <clahey> Is (fmap.fmap) the same as (fmap . fmap)
17:11:27 <rwbarton> well say you want to write \x y -> sqrt (x + y)
17:11:29 <Cale> yes
17:11:30 <BMeph_> rwbarton: Okay, NM - I see your later statement, now.
17:11:45 <jmcarthur> rwbarton: you mean    sqrt (+)
17:11:46 <rwbarton> the picture is like a (+) node with two inputs whose output feeds into a sqrt node
17:11:47 <jmcarthur> :)
17:11:48 <clahey> How does the parser know I'm not referring to a module fmap with a variable fmap?
17:11:53 <rwbarton> @slap jmcarthur
17:11:53 * lambdabot orders her trained monkeys to punch jmcarthur
17:12:03 * hackagebot cakyrespa 0.0.4 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.4 (YoshikuniJujo)
17:12:11 <jmcarthur> clahey: modules start with capital letters
17:12:17 <clahey> Okay.
17:12:24 <Cale> clahey: The thing about triples is that they're a completely separate type, unrelated to pairs except that the syntax looks similar.
17:12:26 <rwbarton> clahey, because module names are capitalized. you'd have that problem if you tried to compose a data constructor with a function though
17:12:29 <jmcarthur> clahey: now if the first arg had been a constructor (also starts with a capital letter) it would be confused
17:12:44 <clahey> Cale: I know that.
17:12:48 <jmcarthur> rwbarton: i like sqrt (+)...
17:12:54 <clahey> sqrt (+)
17:12:56 <clahey> :t sqrt (+)
17:12:57 <lambdabot> forall a. (Floating a) => a -> a -> a
17:13:14 <jmcarthur> i just read it as "the square root of the sum"
17:13:16 <trotro> :t (sqrt, (+))
17:13:17 <clahey> :t sqrt
17:13:17 <lambdabot> forall a a1. (Floating a, Num a1) => (a -> a, a1 -> a1 -> a1)
17:13:18 <lambdabot> forall a. (Floating a) => a -> a
17:13:29 <rwbarton> well maybe that is okay, but pick a non-Num-related example
17:13:58 <clahey> Why does that work?  Is a1 -> a1 -> a1     a Floating?
17:14:00 <jmcarthur> all applicatives can work this way (albeit with less sugar unless there is another appropriate type class like num as well)
17:14:07 <trotro> clahey, really strange
17:14:08 <jmcarthur> clahey: it's an instance of Num for functions
17:14:16 <jmcarthur> clahey: it's not in the standard libs
17:14:23 <trotro> ha ok
17:14:27 <clahey> As it probably shouldn't be.
17:14:28 <Cale> clahey: I wouldn't be too unhappy with removing all larger tuples than pairs from the language, actually. There's an occasional case where triples are nice to have, but for the most part when you have more fields you just define your own datatype.
17:14:35 <jmcarthur> clahey: instance Num b => Num (a -> b)
17:14:36 <rwbarton> :t uncurry . uncurry
17:14:37 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
17:14:51 <rwbarton> :t uncurry . fmap uncurry
17:14:53 <lambdabot> forall a a1 b c. (a -> a1 -> b -> c) -> (a, (a1, b)) -> c
17:14:57 <clahey> rwbarton: Yeah, I thought of that, but ((a, b), c) isn't the same.
17:15:07 <rwbarton> :t uncurry3
17:15:08 <lambdabot> Not in scope: `uncurry3'
17:15:10 <Cale> We could then do something like define (a,b,c) as sugar for (a,(b,c)), though yes, that's not the same
17:15:27 <clahey> Cale: Actually, that would be the same, no?
17:15:31 <Cale> no
17:15:31 <aristid> no
17:15:35 <clahey> Why?
17:15:47 <aristid> (a,undefined) is distinct from (a,(undefined,undefined))
17:15:47 <rwbarton> not like any of these uncurry-related functions are actually isomorphisms in Haskell anyways
17:15:50 <jmcarthur> currently there is a difference betwee (a,b,c) and (a,(b,c))
17:15:51 <Cale> (a,undefined) would be different from (a,(undefine...
17:15:52 <monochrom> I am doing string theory computations in haskell and I need 10-tuples. just kidding!
17:15:59 <Cale> aristid beat me to it :)
17:16:19 <clahey> jmcarthur: I agree that it's currently not that way.
17:16:34 <aristid> monochrom: indeed, of course you need HList instead
17:16:34 <clahey> Yes, (a, undefined) would be different from (a, (undefined, undefined))
17:16:37 <jmcarthur> i think i misunderstood the original complaint
17:16:49 <clahey> As it should be.
17:17:00 <clahey> Currently (a, undefined) is different from (a, undefined, undefined)
17:17:01 <Cale> clahey: So there's one extra value in (a,(b,c)) which doesn't correspond to a value in (a,b,c)
17:17:28 <BMeph_> Shouldn't that be more like "(a, undefined, undefined) is distinguishable from (a, (undefined, undefined))"? :)
17:17:34 <clahey> No, they're right.
17:17:57 <clahey> The point is that (a, undefined) is a valid value of (a (b, c))
17:18:04 <clahey> Which is not representable in the current system.
17:18:19 <clahey> Rather, which is not a valid value of (a, b, c)
17:18:26 <Cale> yeah, that's speaking from a semantics point of view, anyway
17:18:35 <aristid> wasn't there a strict tuple type or something like that in ghc 7.6?
17:18:41 <Cale> (or denotational semantics, more specifically)
17:18:49 <rwbarton> while these (a, b, c), ((a, b), c), (a, (b, c)) are indeed different, it's not clear that any is particularly distinguished as the natural thing to uncurry 3-argument functions to
17:18:53 <Cale> In terms of implementation, (a,(b,c)) also involves an extra layer of indirection
17:19:09 <clahey> So, why is that a problem when it comes to getting rid of tuples and replacing them with sugar for pairs?
17:19:10 <Cale> while (a,b,c) consists of a flat structure with 3 pointers (to code) in it
17:19:22 <Cale> So as you nest tuples like that
17:19:30 <Cale> the later elements will become slower to access
17:19:33 <identity> xmonad + guard + vim(neco-ghc, haskellmode-vim, syntastic, ghcmod-vim) is the most beautiful thing I have ever seen. It is a perfectly symbiotic development environment of unrivaled .. sexiness.
17:19:33 <clahey> Cale: And you can't optimize it away, because of the (a, undefined) thing.
17:19:36 <Cale> right
17:19:38 <identity> just wanted to put that out there.
17:19:43 <Cale> exactly
17:19:53 <aristid> identity: now go build an agda mode for vim!
17:19:55 <rwbarton> identity: what is guard
17:20:17 <rwbarton> oh
17:20:19 <clahey> Cale: Actually, could you put a bit into one of the pointers to describe that condition?
17:20:26 <rwbarton> i wasn't expecting google to be able to answer that question but it did
17:20:28 <Cale> heh, well, maybe :)
17:20:33 <identity> rwbarton: it's this ruby utility that can do a bunch of stuff. I'm using it to watch modified .hs files and compile them to see errors
17:20:36 <identity> rwbarton: haha, yeah.
17:20:38 <rwbarton> yes, I see
17:20:42 <Polarina> identity, you will like the vimperator add-on for firefox then.
17:20:46 <identity> rwbarton: it's almost unnecessary with ghcmod and all that stuff
17:20:51 <identity> Polarina: I have vimium for chrome
17:20:56 <identity> i don't need no mouse.
17:21:05 <Polarina> identity, oh, nice. :)
17:21:22 <Cale> clahey: another option would be to have products just be unlifted, so there would be no distinction between undefined and (undefined, undefined)
17:21:36 <jmcarthur> i have emacs. i need an ergonomic keyboard.
17:21:38 <Cale> But sometimes that is less than ideal too.
17:21:38 <luite> clahey: the pointers are already tagged, if the lower bits are nonzero it's a data constructor here (unless one of the tuple elements is a function)
17:22:05 <BMeph_> jmcarthur: You have emacs. "Now you have two problems".... ;)
17:22:22 <Cale> I forget whether that would have been nicer categorically speaking or less nice :)
17:22:30 <Eduard_Munteanu> jmcarthur: you just need lockable buttons for Alt and Ctrl now :)
17:24:36 <aristid> Cale: i'd rather have both unlifted and lifted 2-tuples and no 3+-tuples than only lifted tuples of many sizes, i think
17:24:51 <Cale> aristid: yes, good point
17:24:52 <Cale> :)
17:25:03 <luite> aristid: ghc already had unboxed tuples, but ghc 7.6 removed some restrictions. still pretty limited though
17:25:15 <Cale> aristid: But once we have unlifted tuples, the issue with tuples of larger sizes goes away
17:25:30 <jmcarthur> i'd love to be able to newtype unboxed tuples
17:25:36 <BMeph_> I'd rather have record types. ;)
17:25:47 <jmcarthur> i'd rather have modules, if i had to choose
17:26:18 <Polarina> I'd love to be able to code more in Haskell than humanly possible.
17:26:23 <luite> jmcarthur: problem with unboxed values is that you can't do anything polymorphic with them
17:26:54 <aristid> BMeph_: promise not to be overly excited about this! i'll tell you something: ... you already HAVE record types!
17:27:05 <jmcarthur> luite: can't you put polymorphic values in unboxed tuples? or do you mean that you can't use unboxed tuples to instantiate a type variable?
17:27:26 <luite> oh the first thing is possible
17:27:27 <ski> jmcarthur : the latter
17:27:33 <jmcarthur> yeah, that's a bummer
17:27:57 <aristid> is that ... unfixable?
17:28:02 <jmcarthur> aristid: are you sure you are talking about the same thing BMeph_ is?
17:28:16 <ski> i wonder if we could have `foo :: Unboxed a => ..a..', where `Unboxed a' would carry information about how large an `a' value is
17:28:17 <jmcarthur> aristid: it would require quite some work, i think
17:28:25 <aristid> jmcarthur: he just said record types.. well maybe he meant good record types?
17:28:28 <ski> (where `a :: #', i.e.)
17:28:37 <jmcarthur> aristid: i think the emphasis belongs on *types*
17:28:45 <swarley> :t `
17:28:47 <lambdabot> parse error on input ``'
17:28:50 <swarley> o
17:28:57 <jfischoff> I just had one of those Haskell moments I read about. Wrote 3 thousands lines of code everything worked the first time.
17:29:00 <aristid> BMeph_: is jmcarthur's interpretation correct?
17:29:04 <jfischoff> scared to run it again though
17:29:08 <aristid> jmcarthur: i thought he meant types for records :)
17:29:22 <jmcarthur> aristid: well, that *is* kind of what he meant...
17:29:36 <luite> ski: hmm, that wouldn't be easy to implement, a float might be as big as a pointer, but still require a different treatment, for example passing in some fpu register
17:29:43 <jmcarthur> aristid: namely, the ability to express in the type what fields a record supports, with some reasonable unification of these types
17:30:28 <aristid> jmcarthur: i.e. non-opaque record types? i mean current data also expresses the type of a record, just without telling anything about the record in there
17:30:43 <BMeph_> aristid: Now that jmcarthur has expanded (and expounded), yes, his interp is correct.
17:30:49 <jmcarthur> record types can be used even for anonymous records
17:31:25 <jmcarthur> (and, in fact, are designed for that)
17:31:58 * BMeph_ sways while the preacher "brings it".
17:31:59 <jmcarthur> just like how tuples are like anonymous data constructors (with unnamed fields)
17:32:07 <jmcarthur> heh
17:32:28 <ski> Trex in Hugs is an example of a lightweight record system <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#trex>
17:33:45 <aristid> did we... did we just start a Record Debate?
17:34:16 <Polarina> aristid, it would seem so, unfortunately.
17:34:25 <jmcarthur> no.
17:34:32 <jmcarthur> it's only a debate if we disagree with each other
17:34:48 <gfredericks> it's at least a metadebate
17:34:54 <jmcarthur> and make arguments for our own points of view
17:36:43 <clahey> A metadebate, eh?  I think debates on Records are a good thing!
17:37:53 <identity> Do any of you guys know of any sane directory traversal libraries? IIRC I saw something posted to café but I can't seem to find it
17:38:03 <identity> perhaps something that uses a tree structure
17:38:14 <identity> (For easy filering of empty directories and such)
17:38:29 <dibblego> I use FilePather, but I wrote it
17:39:02 <identity> I am going to roll my own if I don't find something good to be honest. Going to have to.
17:39:28 <identity> IIRC there were a lot of people talking about how often they needed such libraries, and then some guy pointed to one on hackage
17:39:43 <ivanm> there's a few different ones
17:39:51 <ivanm> but I don't know if any of them are generally preferred/used
17:39:55 <ivanm> I think most people tend to roll their own
17:40:43 <ski>   data T s a b = TC (s b -> a -> b) (s b -> s (s b))  -- debate the usefulness/uselessness of this type ?
17:41:28 <clahey> Do most of them have a filePath -> IO Tree function?
17:41:32 <clahey> Do most of them have a FilePath -> IO Tree function?
17:42:03 <Polarina> clahey, how would they deal with symlinks?
17:42:26 <identity> Polarina: ugh. That's one issue I hadn't thought of.
17:42:57 <jmcarthur> ski: wha-?
17:42:59 <clahey> Polarina: That is an interesting question.
17:43:10 <clahey> Polarina: Could they not just be links to the same object in the Tree?
17:43:17 <clahey> Polarina: And just make it so that the Tree isn't actually a Tree?
17:43:38 <clahey> Polarina: And if you mapM over one with a symlink loop, you get an infinite loop!
17:43:39 <ski> jmcarthur : yeah, i'm a bit clueless about how to use it, too ..
17:43:44 <Polarina> clahey, well, one could have a Tree of infinite depth...
17:43:50 <Polarina> clahey, :)
17:44:29 <Polarina> But then there could be symlinks that point somewhere outside of the root of the Tree.
17:44:38 <clahey> Polarina: Not a problem.
17:44:39 <identity> Detecting such loops would make it significantly more annoying to write. but for my purposes, it won't be necessary
17:44:59 <clahey> Polarina: Or rather, no more of a problem than symlinks within the tree.
17:45:13 <Polarina> Oh, of course.
17:45:16 * Polarina is silly.
17:46:09 <ivanm> clahey: I think the usual approach is to use a fold over the file system
17:46:11 <ski> (jmcarthur : supposedly, it's to be used to traverse a binary tree ..)
17:46:30 <ivanm> specifying how to deal with symlinks, etc.
17:46:30 <Polarina> I would include the inode or something similar in the Node datatype, so that Eq can be used to detect recursive symlinks, rather than just identical filenames.
17:46:57 <clahey> ivanm: Which would still be an infinite loop if you didn't put in loop detection.
17:47:20 <hpaste> Acyed pasted “Type error” at http://hpaste.org/75635
17:47:22 <clahey> Is it possible to create recursive hard links?
17:47:25 <ivanm> sure, but it avoid the infinite tree problem
17:47:37 <Polarina> clahey, hard links can only point to files.
17:47:43 <acyed> hey everyone
17:48:01 <ivanm> acyed: use ++ rather than : after replicate
17:48:17 <clahey> ivanm: Actually, I bet you could make mapM work in finite time and just return an infinite tree.  I like it.
17:48:25 <ivanm> but I would instead suggest an Element a -> [a] function with a concatMap
17:48:32 <ivanm> also lets you avoid explicit recursion
17:48:42 <ivanm> also, if you're deriving Show, you might as well derive Read
17:48:53 <ivanm> clahey: RWH had the outline of such an approach
17:49:25 <acyed> ha, I just started with haskell and I'm not as good as I'd like to be.
17:50:01 <ivanm> acyed: so your type error is because replicate returns a list
17:50:03 <ivanm> @type replicate
17:50:04 <lambdabot> forall a. Int -> a -> [a]
17:50:15 <ivanm> but (:) takes an element and a list
17:50:16 <ivanm> @type (:)
17:50:18 <lambdabot> forall a. a -> [a] -> [a]
17:50:25 <ivanm> if you want to put one list on the front of another, use ++
17:50:27 <ivanm> @type (++)
17:50:29 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:50:34 <ivanm> @slap Caleskell
17:50:34 * lambdabot slaps Caleskell
17:50:37 <ivanm> @type (P.++)
17:50:38 <lambdabot> Couldn't find qualified module.
17:50:42 <ivanm> @type (Prelude.++)
17:50:43 <lambdabot> forall a. [a] -> [a] -> [a]
17:50:44 <gfredericks> why does lambdabot print "forall" ?
17:50:54 <ivanm> gfredericks: because she can
17:51:02 <ivanm> it's correct, just not needed
17:51:17 <gfredericks> it's not something I've seen in haskell
17:51:25 <gfredericks> so I have no idea what it's supposed to mean
17:51:51 <Polarina> gfredericks, it's an extension -- not in standard haskell.
17:51:57 <acyed> I'm going to look up the concatMap and see if I can rewrite it
17:52:08 <ivanm> gfredericks: it just means "no matter what type of `a' is being used, this is of type <blah>"
17:52:15 <ivanm> @type concatMap
17:52:16 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
17:52:20 <ivanm> acyed: have a look at concat first
17:52:22 <ivanm> @type concat
17:52:23 <lambdabot> forall a. [[a]] -> [a]
17:52:26 <ivanm> @src concat
17:52:26 <lambdabot> concat = foldr (++) []
17:52:27 <gfredericks> ivanm: okay, thanks
17:52:55 <cl_away> @src concatMap
17:52:56 <lambdabot> concatMap f = foldr ((++) . f) []
17:52:59 <cl_away> Neat.
17:53:34 <cl_away> @src <
17:53:34 <lambdabot> x <  y = case compare x y of { LT -> True;  _other -> False }
17:56:06 <acyed> so, is there a way to make my function a one liner using concatMap? it seems like I'd still have to use the pattern matching for the Single or the Multiple
17:56:39 <ivanm> acyed: yes, you would need an auxiliary function
17:56:50 <ivanm> but then you've split the problem up into more logical parts
17:56:58 <ivanm> and you're not doing the recursion yourself
17:57:04 <jmcarthur> we have lambda case now though!
17:57:46 <Polarina> acyed, just a question, why do you have both Single and Multiple? Can't anything that's a { Single a } be constructed as { Multiple 1 a }?
17:58:05 <ivanm> jmcarthur: true, but you'd need to either mangle it into one line or still have multiple lines
17:58:52 <acyed> It's problem #11 in the haskell 99 problems. I didn't see a simpler way to get the desired output
17:59:06 <acyed> than defining the type that way
18:00:13 <hpaste> Acyed pasted “Encode” at http://hpaste.org/75636
18:00:14 <Polarina> acyed, how about { newtype Element a = (Int, a) deriving (Eq, Show) }?
18:00:27 <ivanm> Polarina: re-read what you wrote... ;)
18:00:55 <Polarina> ivanm, the newtype?
18:01:05 <ivanm> yes
18:01:10 <ivanm> you still need a constructor :)
18:01:18 <Polarina> Aww!
18:01:31 <Polarina> newtype Element a = Element (Int, a) deriving (Eq, Show)
18:02:07 <ivanm> also, if memory serves, GHC can treat "data Element a = Element Int a" as a newtype when pattern matching
18:02:14 <ivanm> or was that the other way round....
18:02:37 <Polarina> I have no idea.
18:02:56 <acyed> doesn't that make a tuple of the data? The example in 99 haskell problems has output of the type Multiple Int Char and Single Char
18:03:21 <acyed> [Multiple 4 'a',Single 'b',Multiple 2 'c']
18:03:23 <hpaste> jmcarthur annotated “Type error” with “Type error (annotation)” at http://hpaste.org/75635#a75637
18:03:40 <Polarina> GHC does many magical things one couldn't dream of. And then also GHC doesn't do some of the "simplest" things.
18:04:27 <jmcarthur> i don't see a point in using newtype around a tuple unless i also plan to use existing functions on tuples on its internals
18:04:27 <Polarina> [Element (4, 'a'), Element (1, 'b'), Element (2, 'c')]
18:04:29 <acyed> that blows my mind
18:04:38 <terrancetao> Hi, I've been trying to study Haskell metarecursion but I've hit a bit of a snag, can someone help me out?
18:04:48 <ivanm> jmcarthur: I'd use (:[]) rather than return
18:04:50 <terrancetao> How do you collapse an n-ary catamorphic bijection across subspaces of R^n into a holomorphic function space
18:04:58 <jmcarthur> acyed: just think of foldElement as providing you a way to replace the constructor with functions
18:04:59 <ivanm> I've been bitten by mixing up lists in other Monads
18:05:04 <jmcarthur> ivanm: i would normally use pure, myself
18:05:14 <ivanm> same thing
18:05:36 <ivanm> if you know you want a list, use the actual constructor rather than a type class
18:05:40 <jmcarthur> i don't think it's a problem for the code to accidentally be more generic
18:05:49 <byorgey> terrancetao: oh, that's simple, you just apply a zygohistomorphic prepromorphism
18:06:01 <ski> hm, there's no type composition in scope in lambdabot, yes ?
18:06:17 <jmcarthur> :k (:.)
18:06:18 <lambdabot> Not in scope: type constructor or class `:.'
18:06:22 <jmcarthur> long shot
18:06:32 <jmcarthur> :k Compose
18:06:33 <lambdabot>     Not in scope: type constructor or class `Compose'
18:07:00 <ski> @type let acc :: (Num a,Functor s) => (forall o s. Functor s => s o -> (s o -> o) -> (s o -> a -> s (s o)) -> o) -> (s o -> (s o -> o) -> (s o -> a -> s (s o)) -> o); acc k s l b = k (0,s) (\(_,s) -> l s) (\(m,s) n -> let o = m + n in (o,fmap ((,) o) (b s o))) in acc  -- needs composition
18:07:01 <lambdabot>     Occurs check: cannot construct the infinite type: o = s o
18:07:01 <lambdabot>     When generalising the type(s) for `acc'
18:07:02 <lambdabot>     In the expression:
18:07:15 <jmcarthur> omg it doesn't even type check
18:07:40 <ski> with a few `newtype' constructors and destructors sprinkled, it ought yo
18:07:48 <ski> s/yo/to/
18:08:30 <jmcarthur> that is one of the most horrible type signatures i have ever seen
18:08:42 <jmcarthur> don't get me wrong, i've seen worse. it's just been a while
18:08:46 <acyed> jmcarthur: can you walk me through how the return replicate part of your code?
18:08:59 <jmcarthur> acyed: return :: a -> [a]
18:09:06 <jmcarthur> acyed: does that help?
18:09:33 <jmcarthur> acyed: foldElement return replicate :: Element a -> [a]
18:09:33 <ski> @src [] return
18:09:34 <lambdabot> return x    = [x]
18:09:37 <byorgey> :t Data.Functor.Compose.Compose
18:09:38 <lambdabot> forall (f :: * -> *) (g :: * -> *) a. f (g a) -> Data.Functor.Compose.Compose f g a
18:09:44 <byorgey> ski: ^^^
18:09:48 <jmcarthur> byorgey: :D
18:10:18 <acyed> jmcarthur: so that's the return of the list monad?
18:10:21 <jmcarthur> yes
18:10:30 <jmcarthur> all it does is make a one-element list
18:10:41 <acyed> man, monads are plowing my brain
18:10:49 <jmcarthur> don't think of it as a monad at all
18:10:59 <jmcarthur> replace return with (\x -> [x]) if you'd like
18:11:46 <Polarina> acyed, { decodeMod ((Element (i, x)):xs) = replicate i x ++ if xs == [] then [] else decodeMod xs }
18:11:59 <Polarina> acyed, just a silly example. :)
18:12:06 <ski> @type let acc :: (Num a,Functor s) => (forall o s. Functor s => s o -> (s o -> o) -> (s o -> a -> s (s o)) -> o) -> (s o -> (s o -> o) -> (s o -> a -> s (s o)) -> o); acc k s l b = k (Data.Functor.Compose.Compose (0,s)) (\(Data.Functor.Compose.Compose (_,s)) -> l s) (\(Data.Functor.Compose.Compose (m,s)) n -> let o = m + n in Data.Functor.Compose.Compose (o,fmap (Data.Functor.Compose.Compose . ((,) o)) (b s o))) in acc  -- yay !
18:12:08 <lambdabot> forall a (s :: * -> *) o. (Functor s, Num a) => (forall o1 (s1 :: * -> *). (Functor s1) => s1 o1 -> (s1 o1 -> o1) -> (s1 o1 -> a -> s1 (s1 o1)) -> o1) -> s o -> (s o -> o) -> (s o -> a -> s (s o)) ->
18:12:08 <lambdabot>  o
18:12:34 <jmcarthur>  o
18:13:36 <ski> this is just a silly example, traversing a tree, replacing each element by the sum of the elements on the path to it
18:14:15 <byorgey> ski: what is this an example of?
18:15:25 <ski> byorgey : attempting to apply a transformation to a tree data type, which when applied to the type of lists yields `foldl'
18:15:36 <byorgey> ah
18:15:38 <acyed> jmcarthur, is your function the solution to problem 13? http://www.haskell.org/haskellwiki/99_questions/11_to_20
18:16:14 <jmcarthur> acyed: no, since my function is just decode
18:16:37 <ski> byorgey : it's CPS & (`mu' |-> `nu' |-> `exists')
18:16:41 <acyed> right! I knew that. but that's the same angle they are getting at
18:16:45 <acyed> ?
18:16:47 <jmcarthur> acyed: looks like my function is a solution to #12
18:17:03 <ski> byorgey : using this idea, i can get fusion for at least simple list traversals
18:17:05 * hackagebot vector-th-unbox 0.1.0.1 - Deriver for Data.Vector.Unboxed using Template Haskell  http://hackage.haskell.org/package/vector-th-unbox-0.1.0.1 (LiyangHu)
18:17:42 <byorgey> ski: neat
18:18:00 <jmcarthur> acyed: it looks like they are asking you to not create an intermediate list, so no, my function doesn't work that way
18:18:03 <ski> (like `map',`filter',`unfoldr',`foldl',`scanl')
18:18:22 <acyed> I guess I don't understand what 13 is asking. I didn't make the sublist in my answer to 11 either (i don't think)
18:18:40 <jmcarthur> acyed: yes you did. "replicate x a"
18:19:15 <acyed> ok, replicate makes a new list. I thought they were saying not to accumulate a list
18:19:31 * ski is still pondering how to fit `zipWith' into this
18:24:29 <geisthaus> can you fit zip into it atm?
18:25:30 <ski> no -- that's basically the same idea, though
18:25:53 <ski> i suspect that the encoding of `zipWith' in terms of `foldr' might help somehow
18:27:28 <ski> geisthaus : exercise : write `zipWith', you may only use a single `foldr' call for each input list, you may not otherwise (directly or indirectly) use recursion or pattern-matching on lists :)
18:31:52 <shachaf> ski: What's "indirectly"?
18:32:18 <ski> shachaf : `head',`tail',`null', e.g.
18:32:23 <ski> or `fix'
18:34:16 <solrize> you're saying use two foldr's?
18:34:37 <ski> or three, or one, if you think it's better
18:37:06 * hackagebot gluturtle 0.0.9 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.9 (YoshikuniJujo)
18:37:08 * hackagebot custom-prelude 0.2.2.0 - An enhanced prelude, serving as a foundation for my projects  http://hackage.haskell.org/package/custom-prelude-0.2.2.0 (AnupamJain)
18:37:21 <shachaf> ski: Would data L a = Z | S a (L a); ... (foldr S Z l1) as indirectly pattern-matching?
18:37:27 <shachaf> count
18:38:33 <ski> shachaf : no (but traversing the `S' and `Z' constructors of your `L a'-typed result would count as recursion)
18:38:57 <hpaste> hardkito pasted “unable to load package `readline-1.0.1.0'” at http://hpaste.org/75638
18:39:26 <shachaf> ski: OK.
18:39:33 <ski> the goal is to encapsulate the whole of the list traversal (matching and recursion) inside `foldr'
18:40:35 <XexonixXexillion> is foldr powerful enough for that?
18:40:51 <ski> (if you prefer, you could take `nil' and `cons' arguments (possibly using `GHC.Exts.build') instead of constructing the output list with `[]' and `(:)' -- that way, you won't even mention those constructors)
18:40:59 <ski> XexonixXexillion : yes
18:41:35 <ski> that is the fun conclusion of this exercise
18:43:21 <XexonixXexillion> ski: is defining "listAlgebra f1 f2 = foldr (\x _ -> const (f1 x)) f2" cheating?
18:44:05 <ski> @type \f1 f2 -> foldr (\x _ -> const (f1 x)) f2
18:44:06 <lambdabot> forall a a1 b. (a -> a1) -> (b -> a1) -> [a] -> b -> a1
18:45:12 <ski> XexonixXexillion : not by itself -- but note that you can't then repeat this by explicit recursion
18:47:06 * hackagebot cakyrespa 0.0.5 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.5 (YoshikuniJujo)
18:50:09 <Polarina> mm_freak_, what does Control.Wire.Prefab.Effect.branch and quit do and what are they useful for? I don't understand what the documentation tells me about them.
18:51:08 <XexonixXexillion> ski: How do you define explicit recursion?
18:51:25 <mm_freak_> Polarina: consider Maybe or [] as the underlying monad
18:52:21 <ski> XexonixXexillion : a definition `foo ... = ..foo..' of an operation `foo' (with or without arguments) whose body refers to itself
18:53:07 <Polarina> mm_freak_, ok, then what?
18:53:29 <mm_freak_> Polarina: branch performs an mplus on the underlying monad
18:54:18 <mm_freak_> stepWire :: Time -> a -> Wire e (Kleisli []) a b -> [(Either e b, Wire e (Kleisli []) a b)]
18:54:31 <mm_freak_> if branch is used, then the list might contain more than one element
18:54:33 <XexonixXexillion> can foldr do unbounded recursion without already having an infinite list?
18:55:15 <mm_freak_> Polarina: the idea is that your main loop does not take a single wire, but a list of wires
18:55:31 <mm_freak_> myLoop :: [MyWire () String] -> IO ()
18:55:44 <mm_freak_> 'quit' drops the wire in question from this list and branch allows forks
18:55:45 <ski> XexonixXexillion : not by itself, i don't think
18:56:05 <mjrosenb> http://paste.debian.net/195137/ -- so, does that look like an issue with runningon ppc64, or something else?
18:57:27 <shachaf> mjrosenb: Is that just from `cabal install vector`?
18:57:54 <mjrosenb> shachaf: emerge darcs, which pulled in vector as a dependency
18:58:02 <shachaf> mjrosenb: Is your GHC built without ghci?
18:58:10 <shachaf> (Or does ppc64 not support it or something?)
18:58:28 <mjrosenb> it does not.
18:58:35 <mm_freak_> Polarina: as a practical example consider a server where the wire itself accepts connections…  'branch' allows the wire to copy the current world and have the two copies branch off to different world states
18:59:00 <shachaf> mjrosenb: That would seem to explain it, then.
18:59:05 <mjrosenb> oh. heh
18:59:10 <mjrosenb> it said exactly what was wrong
18:59:25 <shachaf> Error messages are like that!
18:59:37 <shachaf> (Well... Not as often as I'd like them to be.)
18:59:48 <mm_freak_> Polarina: another practical example is a simulation, where at some point you may want to try more than one possibility
18:59:49 <Polarina> mm_freak_, hmm... I may have to process this for a while. Thanks. :)
19:00:06 <mjrosenb> so what are these annotations that it is talking about?
19:00:10 <ski> mm_freak_ : .. would normally just one "branch" in that list be explored ?
19:00:13 <magicman> Hrm. I have a working solution for the zipWith challenge only if the second list is not infinite.
19:00:19 <shachaf> {-# ANN ... #-}
19:00:24 <mm_freak_> ski: depends on your monad and main loop
19:00:51 <shachaf> mjrosenb: It's in an #ifdef ghc version >= 7.0 or something like that.
19:01:00 <shachaf> I guess it needs a more nuanced ifde.f
19:01:11 <mm_freak_> 'branch' isn't really magical…  it just mpluses
19:01:46 * ski meant the list returned by `stepWire'
19:02:07 <ski> magicman : ok
19:02:13 <mm_freak_> ski: yeah…  depends on your main loop…  it's ultimately your decision =)
19:02:43 <mm_freak_> you can have a simulation that branches all the time and you always select only one of the result lists, or it branches from time to time and you try all possibilities
19:02:46 <ski> yeah, which was why i wondered about the "normal / typical" situation (if any) :)
19:03:00 <ski> ok
19:03:02 <mm_freak_> one nice thing is that the wire itself can choose not to follow a certain path any further by using 'quit' =)
19:03:37 <Polarina> mm_freak_, another question. I want to "evolve"/step a wire (within another wire) a variable number of times with a fixed time delta. Any ideas on how I might do that? Or do I just have to repeat stepWire?
19:03:39 * ski is reminded of strategy resolvers for constraint programming
19:03:39 <mm_freak_> or it can 'conclude' using quitWith
19:04:06 <mm_freak_> Polarina: you want an embedded wire?
19:04:12 <Polarina> mm_freak_, basically.
19:04:25 <mm_freak_> there are many ways to do that depending on what you want to do
19:04:56 <ski> what's the `e' for ?
19:05:05 <mm_freak_> you can write your own wire combinator for example, or you can use one of the combinators from Control.Wire.Trans.Time
19:05:06 <ski> some kind of built-in errors ? (which ?)
19:05:16 <mm_freak_> ski: e is the inhibition monoid
19:05:49 <Polarina> mm_freak_, mapTime, as far as I understand it, only changes the time, not how often the wire is stepped.
19:06:11 <ski> what role does it have ?
19:06:50 <mjrosenb> shachaf: sounds like a patch is necessary!
19:07:09 <shachaf> mjrosenb: Looks like it.
19:07:17 <mm_freak_> ski: inhibitWith e1 <|> inhibitWith e2 = inhibitWith (e1 <> e2)
19:08:03 <mm_freak_> Polarina: yes, just an example…  you can have embedded wires with multiple subinstants per instant by writing your own wire combinator
19:08:04 <ski> `inhibitWith e >>> _ = inhibitWith e' ?
19:08:15 <mm_freak_> ski: yes
19:08:53 <Polarina> mm_freak_, ok, let's say I were to do that. Would using mkState suffice or do I need some other magic?
19:09:21 <Polarina> It seems like it would do.
19:09:23 <mm_freak_> Polarina: mkState or mkGen
19:09:30 <mm_freak_> mkGen is usually easier
19:09:35 <ski> ok, so a kind of (collatable) exception
19:09:43 <mm_freak_> ski: yes
19:09:50 <mm_freak_> ski: inhibition is how netwire handles events
19:10:05 <Polarina> I don't see mkGen documented. :/
19:10:16 <mm_freak_> Polarina: see the Reactive class
19:10:44 <Polarina> mkGen :: (Time -> a -> WireMonad cat (Either e b, Wire e cat a b)) -> Wire e cat a b
19:10:45 * ski doesn't see how events would be related
19:11:05 <Polarina> And WireMonad seems to be defined inside a class. Which dosn't make much sense.
19:11:14 <mm_freak_> ski: an event wire acts like identity when an event happened and inhibits otherwise
19:11:32 <mm_freak_> Polarina: WireMonad (->) ~ Identity
19:11:38 <Polarina> ski, event wires act as { arr id } when an event occurs, inhibit otherwise.
19:11:39 <mm_freak_> WireMonad (Kleisli m) ~ m
19:11:59 <mm_freak_> ski: that way you can write:  x . periodically 1
19:12:01 <ski> mm_freak_ : ok, so a composition is a poll chain
19:12:51 <mm_freak_> ski: as an example:  speed = (1 . keyDown Up <|> 0) + ((-1) . keyDown Down <|> 0)
19:13:19 <ski> (i.e. where when an event is detected, one polls various "sources" until one of them wants to recognize it)
19:13:35 <mm_freak_> ski: yeah, that's a way to look at it
19:14:34 * Polarina goes to figure out how to use WireMonad.
19:14:49 <mm_freak_> Polarina: you can take any predefined wire combinator as an example
19:14:55 <mm_freak_> see .Trans.*
19:15:00 <ski> Polarina : `mkGen' above looks more or less self-explaining ..
19:15:35 <Polarina> It's actually a bit confusing.
19:16:10 <mm_freak_> Polarina: combStep is a version of stepWire in the WireMonad
19:16:32 <mm_freak_> a combinator performs its own stepping
19:16:35 <ski> Polarina : you provide a function that will get the current time, and the current input `a', and (in the `WireMonad cat' monad) yields a pair of either an inhibition or an output value `b', together with a new wire (which is the next local state of the wire at this place)
19:16:46 <ski> Polarina : and `mkGen' just packages this up into a wire
19:17:20 <ski> typically, a wire defined using `mkGen' would be defined recursively, using a function with an accumulator argument to keep the local state
19:17:28 <Polarina> ski, I figured it's a function that takes time and input. The return value baffles me.
19:17:47 <mm_freak_> Polarina: try to understand mkPure first
19:18:01 * ski is of course just guessing here, since he has never used this `Wire' thing ..
19:18:07 <Polarina> mm_freak_, mkPure is pretty straightforward.
19:18:20 <ski> (.. but it sounds like a reasonable interpretation, methinks)
19:18:24 <mm_freak_> Polarina: mkGen is the same, just using the underlying monad
19:18:37 <mm_freak_> ski: yeah
19:19:12 <mm_freak_> Polarina: the reason for writing mkGen is to get along without hordes of type classes
19:20:05 <Polarina> Wait, how can mkPure be used to create a wire if it has to create a wire to create a wire?
19:20:22 <mm_freak_> no, that's how wires work
19:20:23 <ski> Polarina : recursion
19:20:40 <mm_freak_> a wire is a function that returns an output along with a new version of itself
19:20:44 <mm_freak_> see how accum is implemented
19:21:01 <Polarina> accum f = accumT (const f)
19:21:02 <mm_freak_> or integral or avgAll
19:21:10 <mm_freak_> ok, see accumT =)
19:21:16 <Polarina> Ah.
19:21:31 <ski> Polarina : consider `runningSum = loop 0 where loop acc = mkGen (\t n -> return (Right n,loop (acc + n)))' e.g.
19:21:40 <hpaste> mrlemao pasted “How to design such ESDL in Haskell?” at http://hpaste.org/75643
19:21:46 <mm_freak_> Polarina: the underlying concept is the automaton arrow
19:22:07 <mm_freak_> data Auto a b = Auto (a -> (b, Auto a b))
19:22:23 <mm_freak_> Wire is a generalization of that
19:22:28 <ski> aka Synchronous Stream Processor
19:22:30 <mm_freak_> s/data/newtype
19:22:44 <mm_freak_> newtype Wire a b = Wire (a -> (Maybe b, Wire a b))
19:22:55 <mm_freak_> that's about the simplest version of Wire
19:23:45 <lpvb> I have a binary containing a B-tree that I would like to deserialize, do I have to roll my own data structure to represent the tree?
19:23:58 <ski> (er, s/Right n/Right acc/, i meant)
19:26:01 <ski> @type Data.Tree.Node
19:26:02 <lambdabot> forall a. a -> Forest a -> Tree a
19:26:26 <ski>   data Tree a = Node {rootLabel :: a,subForest :: Forest a}
19:26:33 <ski>   type Forest a = [Tree a]
19:26:43 <ski> lpvb : perhaps you can use that, not sure
19:27:02 <Polarina> Ok, I think I understand now. So, let's say we have { :: Wire () (Kleisli IO) a b }, how would one use WireMonad to do some IO?
19:27:53 <ski> Polarina : presumably there's some combinator of type `Category cat => cat a b -> Wire r cat a b' ?
19:28:22 <Polarina> ski, I haven't seen any like that.
19:28:32 <acyed> Alright! I think I'm getting the hang of this! dupli a = concatMap (\x -> x:x:[]) a
19:28:54 <mm_freak_> none is predefined, but you can easily make such a combinator using mkGen
19:29:12 <mm_freak_> there is also 'execute', which is specific to IO-based kleisli categories
19:29:19 <Polarina> mm_freak_, I meant with mkGen.
19:29:39 <mm_freak_> in fact there is mkFixM for that
19:30:25 <ski> > let dupli xs = [y | x <- xs , y <- [x,x]] in dupli "bar"
19:30:26 <lambdabot>   "bbaarr"
19:30:32 <ski> > let dupli xs = [y x | y <- [\x -> x,\x -> x] , x <- xs] in dupli "bar"
19:30:33 <Polarina> That doesn't help me much, mm_freak_.
19:30:33 <lambdabot>   "barbar"
19:30:50 <mm_freak_> Polarina: then perhaps ask a question =)
19:30:54 <Polarina> mkFixM :: (Time -> a -> WireMonad cat (Either e b)) -> Wire e cat a b
19:31:05 <Polarina> How do I lift to an IO inside a WireMonad?
19:31:10 <mm_freak_> Polarina: to do IO you would use .Prefab.Effect
19:31:30 * Polarina is just trying to simplify the question.
19:32:40 <hpaste> XexonixXexillion pasted “zipWith with foldr” at http://hpaste.org/75644
19:32:46 <Polarina> I want to make a combinator that runs a wire repeatedly for a variable amount of times with some time delta with the same input.
19:32:53 <XexonixXexillion> ski: does that meet your requirements?
19:33:19 <mm_freak_> Polarina: do you understand how wires work?
19:33:27 <mm_freak_> internally i mean
19:33:36 <Polarina> mm_freak_, I believe I do. I just don't know how WireMonad works.
19:33:41 <Polarina> That's what I'm asking about.
19:33:57 <mm_freak_> WireMonad is the underlying monad
19:34:11 <Polarina> And how do I use it?
19:34:22 <mm_freak_> mkGen, mkFixM, mkStateM
19:34:26 <Polarina> Inside a mkFixM, I mean, for example.
19:35:33 <Polarina> WireMonad cat (Either e b)
19:35:40 <Polarina> Let's say cat is IO.
19:35:46 <Polarina> How would I lift to IOL
19:35:50 <Polarina> s/L/?/
19:37:52 <Polarina> I'm assuming I couldn't simply do { mkFixM (\_ _ -> print "hello") :: Wire e (Kleisli IO) a b }...
19:38:01 <Polarina> As print "hello" is of type IO ()
19:38:19 <Polarina> not WireMonad (Kleisli IO) (Either e b)
19:39:35 <Polarina> mm_freak_, How would I do that print and have the wire (I presume) act as an identity wire?
19:42:07 * hackagebot stringsearch 0.3.6.4 - Fast searching, splitting and replacing of ByteStrings  http://hackage.haskell.org/package/stringsearch-0.3.6.4 (BryanOSullivan)
19:43:11 <ski> @tell XexonixXexillion hehe, nice attempt at workaround, but sadly no (yes i know the requirements are vaguely expressed) -- you traverse one of `x',`y' more than once (by  length'  and then replicate'  ) -- and you repeatedly traverse the tails with  tail'
19:43:11 <lambdabot> Consider it noted.
19:43:23 <mm_freak_> Polarina: mkFixM (\_ x -> print "blah" >> return (Right x))
19:43:45 <Polarina> mm_freak_, just like that?
19:44:01 * Polarina wonders how that IO magically turned into a WireMonad...
19:44:24 <ski> @tell XexonixXexillion the idea is that we should only need at most one `foldr' call per list, traversing it *once*; and therefore our operation can be incremental, so that it works for infinite lists
19:44:24 <lambdabot> Consider it noted.
19:44:30 <mm_freak_> Polarina: WireMonad (Kleisli m) = m
19:44:38 <mm_freak_> Polarina: WireMonad is an associated type
19:44:41 <ski> magicman : .. still wondering what you had in mind ..
19:44:41 <Polarina> Oh.
19:44:55 <Polarina> haddock made it look like magic.
19:45:08 <mm_freak_> haddock works fine for me
19:45:18 <Polarina> class Monad (WireMonad cat) => Reactive cat where
19:45:19 <mm_freak_> Haddock version 2.11.0, (c) Simon Marlow 2006
19:45:20 <Polarina>     type WireMonad cat :: * -> *
19:45:32 <Polarina> That dosn't tell me much.
19:45:42 <mm_freak_> it tells you that WireMonad is an AT =)
19:45:52 * Polarina has little idea what that is.
19:45:57 <ski> mm_freak_ : .. oh
19:46:00 <mm_freak_> see type families
19:46:12 <mm_freak_> WireMonad (->) = Identity
19:46:19 <mm_freak_> WireMonad (Kleisli m) = m
19:47:15 <Polarina> Just a side question; why { WireMonad (->) = Identity } when you can have { WireMonad (Kleisli Identity) = Identity }?
19:47:42 <ski> `WireMonad (Wire e cat) = WireMonad cat' ?
19:47:48 <mm_freak_> that's where Result comes in
19:48:38 <Polarina> Oh.
19:48:42 <mm_freak_> ski: no
19:48:46 * Polarina should look into type families.
19:49:14 <Polarina> mm_freak_, all right, thanks for everything. I think I can figure out how to make that combinator now. :)
19:49:40 * Polarina hopes she isn't bothering mm_freak_ too much with all these silly questions.
19:50:01 <mm_freak_> no worries =)
19:50:32 <Polarina> (=
19:51:50 * Polarina is headed off to get some sleep now.
19:56:45 <magicman> ski: I feel kind of cheap for using: foldr (\x ~(xs,_) -> (x:xs,Just (x, xs))) ([],Nothing)
19:57:45 <hpaste> magicman pasted “zipWith challenge” at http://hpaste.org/75645
19:58:39 <magicman> (sorry for stupid identifier names <_<)
20:01:14 <ski> magicman : ok. here we have multiple `foldr' calls (from inside `selfHeadTail') for tails of the second list
20:02:13 <ski> but, good try :)
20:02:58 <ski> i suppose one of the points of the exercise is to make one think about the problem
20:03:27 <magicman> *nod*
20:03:49 <ski> iirc, i invented it while pondering `build'/`foldr' -fusion
20:03:57 <magicman> I like the mental exercise.
20:04:09 <magicman> Ah, right.
20:04:09 <ski> so, a goal is to be able to apply such fusion for `zipWith'
20:05:43 <ski> i could probably be somewhat more specific in the requirements -- but i'm not sure how to do that without hinting more at the solution i found (and i'd be happy if someone constructed a "different" solution)
20:06:14 <magicman> Personally, I'd like to think some more about it.
20:07:45 <ski> @type GHC.Exts.build
20:07:46 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
20:07:51 <ski> @type foldr
20:07:53 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:08:01 <magicman> *nod*
20:08:56 <ski>   forall cons nil f.  foldr cons nil (build f) = f cons nil  -- `build'/`foldr' -fusion
20:10:12 <magicman> Right.
20:11:18 <magicman> And now we want something like: forall cons nil f g. foldr cons nil (zipWith (build f) (build g)) = something f g cons nil ?
20:11:42 <magicman> (where something does not involve foldr or build)
20:12:00 <ski> yes :)
20:13:00 <BMeph_> Except, zipWith has another argument.
20:13:08 <magicman> Oh, right.
20:13:23 <magicman> s/zipWith/zip/
20:13:49 <magicman> And then map (uncurry h), which can already be fused fine, so it wouldn't really complicate things, I think.
20:15:06 <ski> yea
20:16:08 <ski>   forall list. (forall cons nil. foldr cons nil = ..cons..nil..) <=> (list = build (\cons nil -> ..cons..nil))  -- one could use this to move from `foldr cons nil (zipWith ...) = ...' to `zipWith ... = build (\cons nil -> ...)'
20:16:49 <megajosh2> <=> is ≡?
20:17:15 <ski> equivalence of propositions
20:17:49 <magicman> Ah, I think I have something. Now to code it up >_>
20:18:12 <ski> (er, s/foldr cons nil =/foldr cons nil list =/)
20:18:27 <ski> (: magicman
20:22:08 * hackagebot cakyrespa 0.0.6 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.6 (YoshikuniJujo)
20:35:50 <carter_> i'm realy excited about how all sorts of haskell jobs are popping up in NYC! :)
20:35:57 <shachaf> They are?
20:36:27 <carter> shachaf: I'm aware of at least 3 that have been advertised in the past 2.5 months ! :)
20:36:32 <carter> all pretty legit
20:36:43 <carter> thats a pretty good start
20:37:02 <carter> for explicitly "we use lots of haskell"
20:37:16 <shachaf> Hmm, which?
20:39:00 <Clint> 10gen
20:39:41 <shachaf> I thought they were in Palo Alto.
20:39:47 <shachaf> I guess they're in NY too.
20:40:13 <dada_cetacean> NY is supposed to be the new hot spot for tech startups
20:40:57 <pnielsen> it's pretty lively
20:41:09 <pnielsen> not nearly as "mature" as the Bay Area, of course
20:42:43 <bgamari> I guess containers don't come with Traversable-like functions
20:42:45 <pnielsen> If you're looking for NYC companies: http://nytm.org/made-in-nyc/
20:42:49 <pnielsen> Coincidentally, 10gen is first on the list
20:42:50 <bgamari> e.g. mapM?
20:45:50 <ew0> hello
20:46:04 <ew0> I need to extract some floats from a file
20:46:26 <ew0> there are tons of lines
20:46:56 <ew0> but the line I want is "Cycle time (ns): 1.4324"
20:46:56 <magicman> ski: I give up for now, heading to bed. I feel it is somehwat related to the right-fold equivalent of https://www.joachim-breitner.de/blog/archives/560-The-might-applicative-left-fold.html or http://squing.blogspot.de/2008/11/beautiful-folding.html
20:47:33 <pnielsen> Is there an easy way to get cabal to look at some cabal file and tell me "Package X and Y have newer versions"?
20:47:48 <magicman> *somewhat
20:49:17 <ski> magicman : yea, i've been pondering roughly that the last few days
20:49:24 <ski> magicman : night
20:50:01 <YayMe> Is Lisp the only homoiconic language out there?
20:50:01 <magicman> I think that construction would work generically too, actually.
20:51:37 <magicman> If you have "data Alg f a = forall b. Alg (f b -> b) (b -> a)", then there should be an "instance (Functor f) => Applicative (Alg f)"
20:51:53 <magicman> That's what my gut feeling tells me.
20:53:35 <ski> YayMe : Lisp is (nowadays) a family of languages. Prolog is commonly considered homoiconic as well, i think
20:53:58 <magicman> And with "data Mu f = In { out :: f (Mu f)}", you can get a "fold :: Alg f a -> Mu f -> a"... for lists you'd have "data ListF a r = NilF | ConsF a r", and "Mu (ListF a)" would be isomorphic to [a]... modulo bottoms, probably.
20:54:41 <YayMe> ski: Homoiconicity is a part of what defines a lisp though right?
20:54:52 <ski> magicman : *nod*
20:55:21 <YayMe> hmm I've been meaning to go look at prolog as I hear read weird off hand statements about it in strange places
20:55:29 <ski> YayMe : well, Dylan is sometimes counted, iiuc -- is it homoiconic ?
20:55:34 <ski> (how about Logo ?)
20:56:04 <YayMe> hmm maybe logo is
20:56:16 <YayMe> I found a pretty awesome online logo interpreter a while back heh
20:56:56 <ski> YayMe : learning Prolog will (probably) make you understand type inference better (among other things)
20:57:18 <YayMe> Really? I would have assumed Haskell had the market cornered on type inference
20:57:36 <YayMe> and if not haskell then ML since it was the first implementor of HM types no?
20:57:40 <ski> well, Prolog doesn't have type inference (it doesn't have any static type system)
20:58:20 <ski> but unification in the type system in Haskell corresponds to unification on the *value* level in Prolog
20:58:35 <mm_freak_> logo looks like cobol to me
20:58:49 <mm_freak_> the only thing missing is the occasional "please"
20:58:51 <ski> also, type classes can be thought of as (quite restricted) predicates
20:59:13 <ski> (which is why som olegy use of type classes can be said to be "programming Prolog in the type system")
21:00:38 <YayMe> huh, prolog does look very interesting
21:03:34 <YayMe> prolog is pure isn't it?
21:04:42 <ski> YayMe : nope
21:05:32 <ski> if you want pure declarative logic programming, you can try Mercury (which has a type system with parametric types, parametric polymorphism, type classes, algebraic data types)
21:05:38 <YayMe> huh, interesting, would think defining computations by logical relations and rules would inherently be pure
21:06:26 <ski> (Mercury is a "purified" Prolog -- and is also meant to be more practical for larger-scale programs)
21:07:17 <ski> in Mercury, you define `main' as a relation between the input state of the world and the output state of the world (the approach is comparable to Clean's uniqueness typing)
21:07:57 <carter> pnielsen & shachaf theres been 2  nyc haskell things advertised
21:08:02 <carter> beyond that
21:08:03 <YayMe> interesting, I'll have to take a look at that tomorrow. Thanks for the info!
21:08:04 <ski> in Prolog, you just have some relations which has side-effects on the world (breaks idempotence, commutativity, more)
21:08:06 <YayMe> night all
21:08:23 <ski> but there's more material on Prolog, so you probably want to learn that first, anyway
21:09:04 <ski> YayMe : there's channels ##prolog and #mercury, which you could visit ..
21:09:09 <ski> YayMe : night
21:26:43 <XexonixXexillion> Does anyone know a compression algorithm that doesn't use much memory that works for data with a high number of common values, but very little repetition (i.e [10,20,21,20,18,10,20,10])
21:26:44 <lambdabot> XexonixXexillion: You have 2 new messages. '/msg lambdabot @messages' to read them.
21:28:49 <XexonixXexillion> I was using huffman encoding, but it uses more memory than I'd like
21:40:12 <centrinia> XexonixXexillion, you might want to do some recency coding first.
21:45:08 <centrinia> > let mtf [] _ = []; mtf _ [] = []; mtf (x:xs) ls = fromJust (elemIndex x ls) : mtf xs ls'  where ls' = x : delete x ls in mtf [10,20,21,20,18,10,20,10] [0..100]
21:45:09 <lambdabot>   [10,20,21,1,20,3,2,1]
21:45:26 <centrinia> > let mtfDecode [] _ = []; mtfDecode _ [] = []; mtfDecode (x:xs) ls = c : mtfDecode xs ls'  where { c = ls !! x; ls' = c : delete c ls}  in mtfDecode [10,20,21,1,20,3,2,1] [0..100]
21:45:27 <lambdabot>   [10,20,21,20,18,10,20,10]
21:47:25 * lispy waves
21:48:22 <centrinia> @let mtfDecode [] _ = []; mtfDecode _ [] = []; mtfDecode (x:xs) ls = c : mtfDecode xs ls'  where { c = ls !! x; ls' = c : delete c ls}
21:48:24 <lambdabot>  Defined.
21:48:30 <centrinia> @let mtf [] _ = []; mtf _ [] = []; mtf (x:xs) ls = fromJust (elemIndex x ls) : mtf xs ls'  where ls' = x : delete x ls
21:48:32 <lambdabot>  Defined.
21:53:45 * lispy is trying to keep an open mind about FRP
21:53:55 <lispy> I'm not sure why I find FRP so objectionable.
21:54:05 <lispy> same with arrows
21:56:52 <liyang> tibbe: cheers!
21:57:00 <tibbe> liyang: np
21:57:13 <liyang> tibbe: when can I expect a new release with those commits?
21:57:22 <liyang> (it's not urgent.)
22:32:11 * hackagebot tagset-positional 0.1.1 - Positional tags and tagsets  http://hackage.haskell.org/package/tagset-positional-0.1.1 (JakubWaszczuk)
22:35:29 <bblum> hi folks, is there an easy way to "multiply" two lists? i don't mean "zipWith (*)", but rather get every combination -- to invent syntax for dependent-typed lists, i'm looking for multiply :: [a]/N -> [b]/M -> [(a,b)]/(M*N)
22:36:03 <shachaf> liftM2 (*)
22:37:09 <bblum> shachaf: almost... that additionally multiplies the elements, unfortunately
22:37:30 <paolino> liftM2 (,)
22:37:39 <shachaf> bblum: Oh, tuples.
22:37:40 <ion> liftA2 :-(
22:37:44 <bblum> paolino: excellent, thank you
22:37:56 <shachaf> That's often called "cartesian product". :-)
22:38:12 <bblum> shows how much i know about using lists as monads that i wasn't able to come up with this on my own
22:38:19 <shachaf> bblum: You can also write a list comprehension [(a,b) | a <- as, b <- bs], which comes out to the same thing.
22:38:35 <bblum> oh yeah, i never built that into my repertoire.
22:38:49 <shachaf> You can also write it with map.
22:39:06 <bblum> yeah but that's not "easy" ;)
22:39:21 <paolino> concatMap == >>=
22:39:32 <shachaf> Not quite.
22:40:01 <paolino> flip ?
22:47:11 * hackagebot gloss 1.7.6.3 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.6.3 (BenLippmeier)
23:01:27 <eyebloom> Does anyone have a moment to discuss a fairly complex "kind" related problem?
23:02:55 <ion> Does anyone have a moment to discuss whether anyone has a moment to discuss a fairly complex “kind” related problem?
23:03:19 <eyebloom> Very meta.
23:03:44 <shachaf> ion: Let's not be hasty. I can discuss whether I have a moment to discuss that, but just for a moment.
23:04:20 <rohit_> is their any haskell video tutorials
23:05:18 <eyebloom> There are good ones of Simon Peyton Jones explaining haskell. They should come up if you google his name.
23:05:32 <ion> rohit: I haven’t seen tutorials per se, but there are some nice videos such as http://youtu.be/b9FagOVqxmI
23:05:48 <hpaste> eyebloom pasted “Kind Hell?” at http://hpaste.org/75648
23:06:28 <eyebloom> Basically I'm trying to compile an embedded language that can thread a global object through it's evaluation.
23:07:31 <rohit_> I heard some ITS Software which uses AI and teaches Haskell
23:08:02 <eyebloom> It's very difficult to do because I can't figure out how to get my code to dispatch based on the kind of a type parameter.
23:09:08 <eyebloom> I've been reading Giving Haskell a Promotion but so far I can't figure out how to work with it.
23:10:49 <shachaf> eyebloom: That sounds like something that you shouldn't be doing.
23:11:31 <eyebloom> it's only global within the embedded language.
23:11:53 <hpaste> Chumma pasted “Yesod Installation Ubuntu11.10” at http://hpaste.org/75649
23:12:39 <eyebloom> the set of "global extensions" are limited to commutative operations.
23:12:49 <shachaf> I mean "dispatch based on the kind of a type parameter"
23:13:00 <chumma>  hello all i am trying to install yesod on ubuntu 11.10 but i am getting this error http://hpaste.org/75649
23:13:06 <eyebloom> I see.
23:13:22 <eyebloom> I may be using the wrong term.
23:14:29 <eyebloom> I'm using dispatch but I mean a compile time choice.
23:14:31 <isomorphic> eyebloom:  Do you mean kind as in * -> *?
23:14:47 <eyebloom> Yes.
23:15:46 <eyebloom> Basically if you take a look at my code http://hpaste.org/75648 you can see there is an instance of a lamda calculus called Lg.
23:16:16 <eyebloom> Lg allows an additional parameter g to be "threaded" through the evaluation.
23:16:54 <eyebloom> And passed to special extensions of the calculus I call "global extensions" which can query or modify g.
23:17:38 <eyebloom> Lg has two type parameters g and t.
23:18:04 <eyebloom> G is the global structure and t is the type of the lambda expression.
23:20:58 <rohit_> any more video tutorial on haskell
23:20:59 <rohit_> ?
23:21:00 <eyebloom> If t has kind *->X then the evaluator needs to pass the global structure through the evaluation and has type a->g->(g,b) whereas if t has kind * then no addition parameter is needed, and the expression has type g->(g,t)
23:22:09 <eyebloom> But I need to know the kind of t in order to determine the proper type of the expression.
23:22:51 <eyebloom> I'm hoping it's possible to do this in haskell but so far the solution has eluded me.
23:34:32 <VCommeLeVent> Get me the praesident of Haskell
23:35:17 <VCommeLeVent> There has to be a way added to make Vector 7 Int or whatever be the same as SevenAryVector Int Int Int Int Int Int Int or something
23:35:46 <VCommeLeVent> The technology is already there, it's just a way to write it more conveniently.
23:36:46 <zomg> *The red phone is ringing*
23:36:54 <charliesome> does haskell have a built in function that is similar to ruby's each_slice ?
23:36:56 <zomg> You have reached the voice mail of... PRESIDENT OF HASKELL
23:37:04 <zomg> Leave your message after the beep *beep*
23:37:45 <rohit_> Hi Guys have you seen the Nirvana language video in youtube
23:39:46 <chumma>  The 'type' field is required for test suites. how can i solve this?
23:40:25 <arcatan> chumma: I don't think there's on in standard library, but chunksOf in the split package comes to mind.
23:40:27 <zomg> chumma: you don't happen to be Jupiter123 or what's his name?
23:41:52 <VCommeLeVent> zomg, sä suomalainen
23:42:00 <VCommeLeVent> Mä unohdan sua.
23:42:01 <chumma> zomg: nope
23:42:14 <zomg> chumma: ah nevermind then, he had the exact same issue yesterday with exact same OS too =)
23:42:24 <zomg> not sure if he ever got it sorted out though
23:42:32 <fmap> chumma: you need to manually fix binary.cabal and warp.cabal. do you know how to do it?
23:42:38 <zomg> VCommeLeVent: okay
23:42:43 <VCommeLeVent> zomg, tiedätkö että miksi se ei ole haskellissa?
23:43:05 <VCommeLeVent> Mä haluan että se on.
23:43:06 <chumma> fmap:nope i am getting started with haskell
23:43:26 <rohit_> No Jupiter is me in here
23:43:42 <rohit_> I think Chumma got issue while installing on his linux mint is it
23:44:11 <chumma> rohit_:so how did you solve it? i am on ubuntu11.10
23:44:17 <rohit_> zomg: suggested me to install binary individually and it worked
23:44:26 <Ralith> VCommeLeVent: you want a dependently typed language
23:44:33 <Ralith> VCommeLeVent: the technology is in fact a lot different.
23:44:38 <VCommeLeVent> Ralith, really?
23:44:40 <VCommeLeVent> In what way?
23:44:54 <Ralith> I can recommend a good introductory textbook if you like
23:45:11 <Ralith> well, more of a scholarly publication
23:45:12 <VCommeLeVent> I mean, it's purely static, surely you can make Vector 3 Int simply syntactic sugar for ThreeVector Int Int Int?
23:45:29 <VCommeLeVent> I don't mean recognise all the values, natural numbers are enough
23:45:52 <rohit_> chumma: cabal unpack binary
23:46:03 <VCommeLeVent> You can already do what I want, it's just not pretty heaving to write down all the different conmbinations of vectors and matrices instead of a simple shorthand Matrix 3 5 Integert or whatever
23:46:05 <rohit_> cd into binary
23:46:09 <chumma> fmap: can you point me to something so that i can try fixing it?
23:46:29 <Ralith> use template haskell, then.
23:46:43 <rohit_> probably you will get some packages which doesn't install
23:46:52 <rohit_> try to update cabal
23:47:08 <rohit_> than which ever packages it shows which doesn't install unpack it
23:47:12 <rohit_> cd into the pack
23:47:43 <rohit_> open binary.cabal file
23:48:29 <chumma> rohit_: yep. then what?
23:48:36 <rohit_> and in that you can see trace or such like that which tracks os, remove that bits of code
23:48:47 <rohit_> save it and cabal install binary again
23:48:51 <rohit_> update cabal
23:48:55 <rohit_> back again
23:49:01 <rohit_> than try installing
23:49:06 <rohit_> similar way do the rest
23:49:24 <chumma> rohit_:ok will try that
23:51:25 <fmap> chumma: sure; do what rohit_ said. the problem is .cabal files containt Test-Suite section which older cabal-install cannot parse, so you need to remove it
23:51:40 <fmap> s/containt/contain/
23:52:10 <rohit_> chumma: as fmap said that was Test-Suite section which you need to remove
23:52:19 <rohit_> thanks fmap for correcting me
23:53:03 <chumma> i removed it but how to make cabal install from that
23:53:47 <fmap> "cabal install"
23:53:48 <rohit_> remove only the test-suite section
23:53:52 <rohit_> and cabal install
23:53:53 <rohit_> thats it
23:54:00 <rohit_> Yup fmap said so
23:54:51 <chumma> cabal install binary.cabal right?
23:55:39 <fmap> that would work too
23:55:39 <rohit_> no only cabal install binary
23:55:48 <rohit_> oh does it work fmap
23:55:51 <rohit_> than its good
23:56:19 <rohit_> I did cabal install binary and i think i had a number next to that in case of warp
23:56:34 <rohit_> like cabal install warp-3.1.2 as such
23:56:37 <rohit_> or similar
23:56:54 <rohit_> install those packages which you get error while doing so
23:57:17 <rohit_> similar way unpack, cd , remove test suite, save, cabal install
23:57:21 <rohit_> same procedure
23:57:24 <rohit_> than update
23:57:25 <fmap> chumma: the idea is to install from fixed binary.cabal, you can do it either by issuing "cabal install" while in binary-0.6.1.0 directory or by directly specifying cabal file "cabal install binary-0.6.1.0/binary.cabal"
23:57:45 <rohit_> ok. thats great fmap
23:59:18 <chumma> yep i run cabal install binary.cabal but this time cannot satisfy -package-id binary-0.6.1.0-inplace?
