00:00:21 <shachaf> It's more than a tad old.
00:05:40 <lpvb> simon: O.o
00:15:33 <blackdog> what ho, haskellers!
00:15:49 <blackdog> anyone done anything with irc in haskell?
00:17:08 <Azel1> blackdog: lambdabot ?
00:17:27 <Shou> blackdog ★ → I'm writing an IRC bot.
00:17:52 <ew_> yo
00:18:01 * hackagebot cakyrespa 0.0.14 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.14 (YoshikuniJujo)
00:18:04 * hackagebot Elm 0.4.0.4 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.4.0.4 (EvanCzaplicki)
00:18:04 <ew_> I wrote my first piece of code using monad transformers!
00:18:05 * hackagebot elm-server 0.4.0.4 - The Elm language server.  http://hackage.haskell.org/package/elm-server-0.4.0.4 (EvanCzaplicki)
00:18:14 <ew_> a StateT with a State inside xD
00:20:41 <blackdog> Shou: oh, that's kinda cool.
00:20:51 <blackdog> i don't know how i didn't think of lambdabot, actually.
00:21:39 <shachaf> Twist: lambdabot is written in C++
00:21:55 <shachaf> (Not really. But there's a C++-evaluating bot written in Haskell.)
00:22:07 <astry_> kthat was funny
00:23:49 <Enigmagic> ivanm: ghc doesn't directly use the llvm libraries. it just calls llc/opt on the command line to turn the .ll into assembly
00:23:59 <lpvb> from now on, anyone who says Monads are like burritos must make a meaningful instance Monad Burrito
00:24:01 <ivanm> Enigmagic: *nod*
00:24:31 <ivanm> blackdog: there's also IRC libraries and an IRC client
00:24:43 <blackdog> ivanm: yeah, i had a bit of a look at simpleirc
00:24:52 <blackdog> but for what i want to do, lambdabot probably makes a lot of sense
00:25:03 <lpvb> blackdog: there's number-six bot on github
00:25:10 <ivanm> even though her codebase is probably rather old and not how you'd do it nowadays?
00:25:50 <blackdog> ivanm: even though:)
00:26:28 <blackdog> i want to experiment with something, and i'm already being a bit indulgent by using haskell in the first place.
00:26:36 <ivanm> *nod*
00:27:13 <shachaf> blackdog: Someone ought to rewrite lambdabot.
00:28:08 <blackdog> shachaf: what would need to be changed?
00:28:34 <ivanm> I guess you'd probably want to use conduit or something nowadays
00:29:00 <blackdog> is there a guide to writing plugins for it anywhere?
00:29:13 * shachaf should probably be keeping track of all the broken things so as to have a good answer to that question.
00:29:21 <shachaf> The plugin system is a mess.
00:29:28 <shachaf> I think it was dons's PhD thesis or something.
00:29:30 <blackdog> (i am honestly delighted it built first time, i've had major trouble with it before)
00:29:43 <blackdog> that and xmonad
00:31:19 <earthy> dons's PhD thesis was on ByteString and that ilk, IIRC
00:31:53 <blackdog> earthy: it was mostly plugins, i think.
00:32:11 <blackdog> safely loading new code at runtime etc... not sure the bytestring stuff made it in at all
00:32:26 * blackdog is once again amazed by how much don managed to get done
00:47:28 <earthy> damn, you're right
00:47:33 <earthy> *totally* forgot about that.
00:48:34 <shachaf> Good old earthy.
00:48:39 <shachaf> Sometimes I confuse you with Earthlink.
00:48:42 <shachaf> I hope you don't mind.
00:53:23 <earthy> no probs ;)
00:56:54 <merijn> blackdog: There was a paper by dons on having plugins for haskell programs but my link for that paper died :(
00:57:03 <merijn> blackdog: Maybe you can find it using google
00:58:17 <earthy> http://code.haskell.org/~dons/papers/thesis/dons-phd-thesis.pdf
00:59:24 <hpaste> jhc pasted “hitori” at http://hpaste.org/75695
01:35:45 <hpaste> jhc pasted “hitori2” at http://hpaste.org/75696
01:50:04 <hpaste> jhc pasted “hitori3” at http://hpaste.org/75697
01:51:25 <divyanshu> (`replicateM` "abc") =<< [0..]
01:53:12 <nicoo> > (`replicateM` "abc") =<< [0..]
01:53:13 <lambdabot>   ["","a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","a...
01:59:13 <ew_> is there a way to profile code to see where's my stack is exploding?
01:59:26 <ew_> uhm, I think I got an extra is there
02:02:13 <divyanshu> :t (=<<)
02:02:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
02:03:52 <divyanshu> putStrLn  =<< Just "hello"
02:04:10 <gargawel> > putStrLn  =<< Just "hello"
02:04:11 <lambdabot>   Couldn't match expected type `GHC.Types.IO GHC.Base.String'
02:04:11 <lambdabot>         against...
02:04:12 <nand`> type error, IO ≠ Maybe
02:19:19 <donri> > Data.Foldable.mapM_ putStrLn (Just "hello")
02:19:20 <lambdabot>   <IO ()>
02:22:22 <hpaste> jhc pasted “hitori4” at http://hpaste.org/75698
02:26:11 <augur> ski: ping
02:28:07 * hackagebot aws-sdk 0.2.0.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.2.0.0 (YusukeNomura)
02:37:48 <t7> is there a name for deconstructing a constructor when pattern matching
02:38:18 <trotro> unfold maybe
02:38:20 <trotro> or fold
02:38:22 <trotro> don't remember
02:38:55 <quicksilver> it is called "pattern-matching" or "deconstruction" quite often :)
02:39:20 <quicksilver> elimination, perhaps
02:39:24 <quicksilver> (by analogy with logical rules)
02:43:30 <companion_cube> I'd say "match"...
03:16:42 <t7> is there a function like this:   [a] -> (a -> a)  -> a     so that   f [1,2,3] (z) = 1 `z` 2 `z` 3
03:17:01 <divyanshu> foldl
03:17:22 <t7> eyah bu i have no starting value
03:17:28 <divyanshu> http://zvon.org/other/haskell/Outputprelude/foldl1_f.html
03:17:30 <t7> is it just foldl1
03:17:41 <divyanshu> yes it does not take starting value
03:17:47 <int-e> is that (1 `z` 2) `z` 3 or 1 `z` (2 `z` 3)?
03:17:54 <jesyspa> That can't be (a -> a), though, should be (a -> a -> a).
03:19:42 <t7> int-e: the latter
03:20:27 <Botje> that's foldr1
03:24:49 <t7> @hoogle mapFst
03:24:50 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
03:25:58 <int-e> > first succ (22,42)
03:25:59 <lambdabot>   (23,42)
03:26:59 <birkenfeld> hi all, anyone interested in contributing darcs support to irker (the replacement for the CIA announcer)?
03:27:22 <birkenfeld> if yes, head over to http://www.catb.org/esr/irker/
03:31:15 <t7> my code turns into a huge clusterfuck so quicly
03:31:26 <t7> and i cant spell
03:37:43 <rob___> anyone here
03:37:45 <rob___> ?
03:38:01 <osfameron> nobody
03:38:01 * donri *tumble weed*
03:38:10 <rob___> *fag*
03:38:31 <t7> no thanks, im giving up
03:38:36 <t7> stoptober and all that
03:38:49 <int-e> only 932 figments of your imagination
03:39:52 <ivanm> now 933
03:40:03 <ivanm> t7: even the fag lollies?
03:40:13 <Botje> they taste like ash :/
03:40:36 <t7> you guys dont have 'conference mode™' enabled?
03:41:33 <ivanm> t7: what's that?
03:41:37 <ivanm> and in what software?
03:41:44 <t7> birkenfeld: the whats new is 7 years old...
03:41:54 <t7> ivanm: chatzilla
03:42:02 <int-e> ivanm: xchat? I guess. an option to ignore join and part messages
03:42:34 <ivanm> oh, I don't mind having the part/join messages
03:42:42 <ivanm> I just wish xchat had the "don't show me netsplits" option
03:42:47 <birkenfeld> t7: it's not the whatsnew for irker, which is about 4 das old :)
03:42:52 <birkenfeld> *days
03:43:00 <int-e> t7: I like knowing when I answer a question that the intended recipient is still there
03:43:37 <ivanm> though tab-completion can help with that
03:43:43 <t7> i usually tab complete the nick when replying
03:43:45 <ivanm> admittedly not if they leave whilst you're typing your response
03:43:59 <t7> i wish i could tab complete everything
03:44:19 <int-e> t7: <tab><tab><tab> <-- like this?
03:44:20 <hiptobecubic> Is there something that does   foo f g x = f x (g x)
03:44:39 <Botje> isn't that just ap?
03:44:44 <int-e> yes, ap.
03:44:51 <hiptobecubic> Botje, oh.
03:44:54 <t7> int-e: like when i walk to the shop i could hit tab and i would be there, then hit tab to get all my items then tab to goto the checkout
03:45:04 <int-e> @pl \f g x -> f x (g x)
03:45:07 <lambdabot> ap
03:45:11 <hiptobecubic> i see
03:45:14 <hiptobecubic> thanks
03:46:04 <int-e> t7: <tab>
03:51:19 <efie> could you tell me an instance of the functor type class, which satisfies the 2. law but not the first one(identity)?
03:51:39 <ivanm> it would really have to be contrived
03:51:58 <ivanm> and I'm not sure if it's possible; I think people have said the first one is a special case of the second
03:52:44 <efie> it's an exercise of the typeclassopedia: ". Give an example of a (bogus) Functor instance which satisfies the second law but not the first. "
03:53:00 <efie> http://www.haskell.org/haskellwiki/Typeclassopedia#Laws
03:53:39 <int-e> efie: fmap f x = undefined
03:54:49 <killy9999> @hoogle encodeFile
03:54:50 <lambdabot> No results found
03:54:54 <t7> "Any Haskeller worth their salt would reject this code as a gruesome abomination. "
03:55:04 <killy9999> Why doesn't hoole find functions from Data.Binary?
03:55:06 <efie> int-: I guess that's true :) any real examples? :P
03:55:22 <t7> killy9999: use hayoo
03:55:26 <int-e> efie: it's possible to do more interesting things - a Functor instance for lists that truncates the results to 42 elements.
03:55:32 <killy9999> t7: that's not an answer :)
03:55:35 <Saizan> int-e: it's the other way around
03:55:42 <Saizan> sorry, that was for ivanm
03:55:49 <t7> killy9999: because hoogle is poo ?
03:55:57 <ivanm> Saizan: oh, right
03:56:07 <ivanm> *shrug* I tend to use all this CT stuff more than reason with it :)
03:56:35 <ivanm> killy9999: you can also tell it to search binary
03:57:35 <efie> int-e: but giving a list of 43 elements would break the identity-law then?
03:58:21 <killy9999> ivanm: how?
03:58:27 <byorgey> efie: fmap f _ = []  is a real example for []
03:58:34 <byorgey> basically anything which generates a constant value
03:59:06 <ivanm> @hoogle put +binary
03:59:07 <lambdabot> Could not find some databases: binary
03:59:07 <lambdabot> Searching in:
03:59:07 <lambdabot>   .
03:59:12 <ivanm> bah
03:59:16 <byorgey> which is only possible for types with polymorphic values, like [] for lists
03:59:28 <byorgey> (if you want to avoid undefined)
03:59:33 <ivanm> killy9999: ^^ that works on the web interface though
04:00:05 <killy9999> ivanm: thanks
04:00:33 <killy9999> though I usually don't need Hoogle if I know the package :)
04:00:39 <byorgey> efie: int-e's example of truncating lists is a good one too.
04:02:04 <nand`> post-composing any idempotent function that is not identity should suffice
04:02:13 <nand`> be it const [] or take 42
04:02:36 <efie> byorgey: int-e: ah thanks, I got it
04:10:37 <int-e> efie: that was the point, wasn't it?
04:10:49 <int-e> efie: to have to composition law, but not the identity one
04:12:02 <killy9999> is there an efficient function for Data.Vector that takes every other element of a vector?
04:13:31 <ivanm> doesn't that kind of get rid of the point of a vector?
04:13:46 <ivanm> though I suppose you could do a map over the indices to get a new list, and then create a new Vector from that list
04:13:56 <killy9999> no if that's only preprocessing
04:14:26 <ivanm> huh?
04:14:44 <killy9999> it doesn't get rid of the point of a vector
04:14:55 <killy9999> because that's first step in my algorithm
04:15:06 <killy9999> to split a vector into odd and even elements
04:15:11 <ivanm> well, vectors are meant to be contiguous blocks of memory
04:15:12 <killy9999> and then work on two vectors
04:15:26 <ivanm> splitting it based upon the index removes that contiguous-ness feature
04:15:34 <ivanm> which means it would need to copy the values IIUC
04:15:35 <efie> int-e: yes, I just realized that :)
04:15:43 <killy9999> so far the best I got was pattern matching + recursion
04:16:11 <killy9999> ivanm: yes, I guess it would
04:16:21 <killy9999> hm
04:16:37 <killy9999> I'm trying to figure out a way to work on vector elements in pairs
04:16:54 <killy9999> so first with second, then third with fourth and so on
04:17:14 <ivanm> recurse on the indices? vectors are O(1) lookup, right?
04:17:21 <efie> I would like to see the prove how the 2. functor law is a special case of the first one but I cannot find it via google
04:17:33 <killy9999> ivanm: no, no
04:18:12 <killy9999> doSth (x:y:xs) = -x : x+y : doSth xs
04:18:15 <killy9999> for example
04:18:20 <killy9999> this is on lists
04:18:23 <efie> sorry, I just found http://stackoverflow.com/questions/8305949/haskell-functor-implied-law
04:18:31 <killy9999> I'm trying to use vector to improve this
04:19:09 <ceii> repa should be able to reshape a 1*2n vector into a 2*n one without copying it, because that's the whole point of the library
04:19:13 <ivanm> well, if Vectors have index-based mapping functions then you've got what you want
04:19:17 <ceii> but I'm not sure you can do it with vector
04:19:32 <ivanm> @hoogle (k -> a -> a) -> Map k a -> Map k a
04:19:33 <lambdabot> Data.Map mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
04:19:33 <lambdabot> Data.Map adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
04:19:33 <lambdabot> Data.Map filterWithKey :: Ord k => (k -> a -> Bool) -> Map k a -> Map k a
04:19:40 <killy9999> ceii: REPA is what I'm planning next
04:19:41 <ivanm> ^^ e.g. Vector versions of mapWithKey
04:20:20 <killy9999> I want to implement an algorithm with different libraries and then benchmark
04:20:54 <ivanm> it depends on a) how you're generating the initial list, b) how you're consuming the list after applying your doSth function
04:21:11 * ivanm <3 lists
04:21:26 <killy9999> a) doesn't matter for me, list can be randomized, read from file or whatever
04:21:45 <killy9999> b) I'm not, I get a processed list of same length as a result
04:22:24 <ivanm> well, if you're just printing the list to screen, then I don't think vectors would have much of a performance advantage
04:22:56 <killy9999> ivanm: resulting vectors can really go to /dev/null, to me its all about efficiency of processing algorithm
04:23:30 <ivanm> killy9999: yes, but something simple like what you've presented doesn't really give Vector any chance to shine
04:23:31 <killy9999> of course they can't go to /dev/null taking the laziness of Haskell
04:24:15 <ivanm> the Show instance for Vectors goes via lists anyway
04:24:31 <ivanm> so that simple definition you had above would be really inefficient for Vectors if that's all you did
04:24:46 <ivanm> especially if laziness can be utilised in the reading/generating part
04:25:17 <killy9999> ivanm: I hoped Vector would get a chance to shine if these vectors were big
04:25:38 <ivanm> not with that function I don't think
04:25:45 <ivanm> admittedly, I haven't used Vectors myself
04:26:02 <ivanm> try something more numerically intensive
04:26:20 <killy9999> ivanm: they key in my algorithm is that it is in fact simple
04:26:22 <ivanm> e.g. compare some type of statistic operations
04:26:29 <ivanm> *shrug*
04:26:32 <killy9999> more complicated than example I gave, but not much
04:26:34 <ivanm> anyway, I've got to go do marking
04:26:43 <killy9999> generaly, the idea is the same
04:33:13 * hackagebot data-named 0.2.0 - Data types for named entities  http://hackage.haskell.org/package/data-named-0.2.0 (JakubWaszczuk)
04:34:51 <t7> @ hoogle (a -> Maybe b) -> [a] -> b
04:34:58 <t7> @hoogle (a -> Maybe b) -> [a] -> b
04:34:59 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
04:34:59 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
04:34:59 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
04:35:16 <t7> i need a find with a custom result
04:35:38 <quicksilver> you want to stop at the first "Just" ?
04:35:48 <t7> filter it?
04:35:57 <quicksilver> head . catMaybes
04:36:07 <quicksilver> :t \f -> head . catMaybes . map f
04:36:08 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> a
04:36:35 <quicksilver> of course it'll crash if there are none.
04:37:16 <t7> @hoogle [a] -> Maybe a
04:37:17 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
04:37:17 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
04:37:17 <lambdabot> Prelude head :: [a] -> a
04:37:48 <t7> i need goals in vim
04:37:54 <t7> and the latest ghc head
04:38:06 <Botje> and a pony
04:38:42 <merijn> t7: Goals = holes, right?
04:38:56 <t7> any hole is a goal
04:39:01 <t7> ;)
04:42:10 <t7> im really sorry
04:43:05 <nand`> I didn't notice anything until you apologized
04:43:13 * hackagebot libexpect 0.3.2 - Library for interacting with console applications via pseudoterminals.  http://hackage.haskell.org/package/libexpect-0.3.2 (StephenRoantree)
04:52:39 <aleator> Hi, does anyone remember out of hand if you can use quickcheck without the result being in IO?
04:53:07 <quicksilver> wouldn't make much sense, would it?
04:53:19 <quicksilver> check :: Property -> Bool wouldn't be a pure function
04:53:32 <quicksilver> whether it passes depends which test cases it chose
04:53:33 <aleator> It wouldn't?
04:53:44 <quicksilver> quickcheck is random testing
04:53:50 <aleator> I mean I could pass a prng for it to use?
04:54:12 <quicksilver> yes, that would make sense
04:54:13 <aleator> Or a seed of one, for that matter.
04:54:18 <quicksilver> then you'd be checking a particular set of cases
04:54:37 <Iceland_jack> I believe the Common Lisp QuickCheck package allows you to do that
04:54:56 <Iceland_jack> and it prints the PRNG seed after each invocation if you'd like to run it again
04:55:01 <aleator> True, but I'd like to enable quickcheck in my course web-page, and I'm not really willing to allow IO there
04:55:53 <t7> is there a sorted equality in the prelude before i define it myself?
04:56:08 <quicksilver> I can't immediately see an exposed interface for a pure check with fixed seed
04:56:12 <quicksilver> :(
04:58:02 <aleator> Oh dear. The IO goes really deep in the quickcheck..
05:09:43 <t7> whos gonna add case splitting et all the ghc then?
05:12:07 <ivanm> t7: you? ;-)
05:12:53 <t7> im not even gonna look at the ghc source. SPJ said it was 80k lines of haskell in my book last night and that is years old
05:13:14 <ivanm> what do you mean by "case splitting" anyway?
05:13:29 <t7> like in agda
05:14:00 <t7> when you have a hole of type SOME-ADT you can get it to make a case statement automagicaly
05:14:22 * ivanm has never used Agda, and doesn't quite understand what holes are
05:14:52 <a11235> has anyone any example of a simple compiler frontend (with type checking) written with alex-happy ?
05:15:43 <hpc> ivanm: so suppose you are writing some haskell code, and you don't know the implementation of some complex function
05:16:07 <hpc> so you just do "foo = undefined", and do other stuff
05:16:11 <ivanm> yup
05:16:21 <hpc> you get the rest of the program to typecheck, with nothing filled in for "foo"
05:16:30 <hpc> that's basically a hole
05:16:36 <ivanm> OK
05:16:44 <hpc> in agda you can query the type of a hole, and so forth
05:16:48 <ivanm> but now there's official syntax/support for them rather than using "undefined" everywhere?
05:16:52 <hpc> yep
05:16:59 <ivanm> gotcha
05:17:02 <hpc> and the compiler can fill them in for you with a command
05:17:04 <hpc> etc
05:17:08 <t7> a11235: you probably want to separate type checking and parsing
05:25:30 <hpaste> killy9999 pasted “DPH install error” at http://hpaste.org/75702
05:25:35 <killy9999> halp!
05:25:55 <killy9999> I get this error when installing dph-examples
05:26:08 <killy9999> googling shows that this is caused by llvm
05:26:55 <killy9999> what is the minimum required version of LLVM for DPH to run?
05:33:29 <t7> @hoogle m [a] -> m ()
05:33:30 <lambdabot> Control.Monad.List ListT :: m [a] -> ListT a
05:33:30 <lambdabot> Prelude concat :: [[a]] -> [a]
05:33:30 <lambdabot> Data.List concat :: [[a]] -> [a]
05:34:32 <Maxdamantus> :t void
05:34:34 <lambdabot> Not in scope: `void'
05:35:12 <t7> > sequence $ (+) [Just 1] [Just 2]
05:35:13 <t7> > sequence (+) [Just 1] [Just 2]
05:35:13 <lambdabot>   No instance for (GHC.Num.Num [Data.Maybe.Maybe a])
05:35:13 <lambdabot>    arising from a use of...
05:35:14 <lambdabot>   Couldn't match expected type `[t -> a]'
05:35:14 <lambdabot>         against inferred type `a1 -...
05:35:34 <t7> oh silly me
05:41:38 <GnomeStoleMyBike> hi All
05:42:11 <Botje> hallo
05:52:31 <Puffton> http://hpaste.org/75703
05:52:37 <Puffton> What do you guize think of my code?
05:53:19 <Lemmih> Too many tuples and 3-tuples.
05:53:28 <nand`> not 80col
05:53:39 <Puffton> It feels a little messy
05:54:11 <Puffton> But I have to use the tuples and triples in all but one case? it's part of the assignment :(
05:54:42 <Puffton> I could probably have shortened it a bit by not using `union` and `difference` etc. too but I wanted it to be as similar to mathematical notation as possible
05:54:47 <Puffton> since the problem was presented mathematically
05:55:22 <nand`> surely at least  S.singleton x1 `S.union` S.singleton x2  can be changed to something like S.fromList [x1, x2]
05:56:17 <hiptobecubic> you have no data types
05:56:27 <hiptobecubic> What does a (string, string, float) mean?
05:56:39 <Botje> Puffton: use a type alias for [(String, String, Float)]
05:56:53 <Botje> and for Map (String, String) Float too
05:57:23 <Botje> Puffton: also, import Data.Set and Data.Map as qualified
05:57:33 <Botje> then you don't get clashes with map
05:57:45 <Lemmih> Puffton: Maybe call 's' something more descriptive.
05:58:22 <Puffton> 's' is also defined as just 's' in the math, that's why it has such a short name
05:58:23 <Mertesacker> whats the chance of rolling exactly 2 sixes with 3 dice? i say 15 combos divided by 6^3
05:58:36 <Puffton> I tend to forget things in 5 minutes after I implement them, that's why I kept so close to the mathematical definition
05:59:43 <Puffton> "as" and "qualified" is not the same thing Botje?
06:01:25 <scopedTV> Puffton: no, afaik no
06:01:36 <ceii> Puffton: import Data.Map as M allows you to access Data.Map.map as M.map but also as map
06:01:51 <Botje> Puffton: if you import them qualified you *have* to give the prefix.
06:01:54 <ceii> import qualified Data.Map as M doesn't clash with prelude's map
06:02:04 <Puffton> oh ok
06:02:04 <scopedTV> import X as Y  allows you to use Y.identifier and identifier
06:02:18 <scopedTV> import qualified X as Y only allows you to use Y.identifier
06:02:41 <Puffton> will fix!
06:04:16 <Botje> line 34: that's basically fi `S.difference` S.fromList [fst mn, snd mn]
06:04:35 <Botje> Puffton: also, you only ever use the components of mn, so pattern match on those.
06:04:47 <Puffton> ah yes good idea
06:04:50 <Botje> (mn_from, mn_to) = ...
06:06:16 <Puffton> Why is List treated different from Map and Set?
06:06:25 <Puffton> i.e. why wouldn't you do qualified import on it, too
06:06:49 <Botje> because Data.List is just chock full of useful functions, and it's very weird to see L.map :)
06:07:36 <blackdog> Botje: Data.List isn't imported by default, is it? Just List, in the prelude...
06:08:04 <ceii> because the Prelude names you don't want to clash with (map, filter, etc) already refer to the List versions
06:08:24 <astry> Puffton: it just shows the developer is used to this module and likes it and expects the people who will work with the code in the future to be able to figure it out
06:08:47 <Botje> blackdog: it's the first thing *I* import anyways :)
06:09:08 <astry> Puffton: the module is not special, it's just that the developer has never worked on a project of even moderate size
06:09:24 <absence> http://hpaste.org/75704 <- is it possible to express this in a simpler way using library functions? foldM and mapM don't seem to fit
06:09:30 <Botje> Puffton: let us know when you've applied those changes
06:09:35 <Puffton> astry, how do you mean?
06:09:37 <Botje> maybe there's more low-hanging fruit
06:10:05 <Mertesacker> whats the chance of rolling exactly 2 sixes with 3 dice? i say 15 combos divided by 6^3. 6,6,X & 6,X,6 & X,6,6 where X can be 1,2,3,4,5 so thats 5 of each times 3 = 15
06:10:25 <astry> Puffton: everyone knows unqualified imports are a bitch when debugging or refactoring or even working with old code
06:10:43 <astry> Puffton: either use import () or import qualified
06:10:45 <Puffton> astry, so you would qualify list too? :p
06:11:03 <astry> if i were only using a few functions from it i'd use import ()
06:11:13 <ceii> > length (replicateM 3 [1..6])
06:11:15 <lambdabot>   216
06:11:34 <ceii> > length $ filter ((==2) . length . filter (==6)) (replicateM 3 [1..6])
06:11:37 <lambdabot>   15
06:11:48 <astry> i like to keep my programs nice and tidy, without namespace pollution and with everything coming from places that are easy to find
06:11:51 <ceii> Mertesacker: I say 15/216
06:12:20 <astry> i guess it's kind of like washing your hands, some people don't
06:15:11 <pordan30> Since finite maps, sets, and lists are container types, a clean solution would be to implement a container class so that common functions like insert, toList, and so forth, could be accessed without module annotations.
06:16:25 <ceii> pordan30: this mostly exists (see classes like Functior, Traversable), but there's a lot of resistance to putting these in the prelude
06:16:53 <ceii> because beginners who write list handling code would much rather see errors about lists than traversables
06:21:05 <mikeplus64> does anyone use ImplicitParams?
06:22:12 <myname_> @pointful \a -> f (g a)
06:22:12 <lambdabot> \ a -> f (g a)
06:22:24 <ivanm> @help pointful
06:22:25 <lambdabot> pointful <expr>. Make code pointier.
06:23:00 <myname_> @pl \a -> f (g a)
06:23:00 <lambdabot> f . g
06:23:01 <t7> @help unpl
06:23:02 <lambdabot> pointful <expr>. Make code pointier.
06:24:28 <absence> with "modifyIORef ref f", there's no way to get at results from f's computation without replacing modifyIORef with readIORef and writeIORef, right?
06:24:44 <myname_> @pl \a b -> f (g a) b
06:24:45 <lambdabot> f . g
06:25:10 <Saizan> ?type Data.IORef.modifyIORef
06:25:11 <ceii> absence: see atomicModifyIORef
06:25:12 <lambdabot> forall a. GHC.IORef.IORef a -> (a -> a) -> IO ()
06:26:57 <rwbarton> @pf f . g
06:26:57 <lambdabot> Maybe you meant: bf pl
06:27:04 <rwbarton> @pointful f . g
06:27:04 <lambdabot> (\ c -> f (g c))
06:27:18 <rwbarton> @pointful join f . g
06:27:18 <lambdabot> (\ c -> (f >>= \ d -> d) (g c))
06:28:45 <absence> ceii: thanks. i don't think i will need atomicity though, so perhaps it's best to not use it simply for the convenience
06:31:24 <Puffton> http://hpaste.org/75705
06:31:25 <Puffton> here we go, sirs
06:32:06 <Puffton> oh, will fix the union in getLeaves too
06:33:01 <Lemmih> getDistanceMatrix = M.fromList . L.map (\(a,b,c) -> ((a,b),c))
06:33:24 <Puffton> http://hpaste.org/75706
06:33:25 <Puffton> there, fixed
06:33:43 <Lemmih> getValue a b = fromMaybe 0 . M.lookup (a,b)
06:34:06 <Puffton> Lemmih, what is the difference between . and $?
06:34:22 <Mertesacker> $ is id
06:34:40 <Cale> (.) is an operation which combines two functions to produce another function
06:34:48 <Mertesacker> > ((+1) . (*5)) 7
06:34:50 <lambdabot>   36
06:34:52 <Lemmih> vi `S.union` S.singleton vli   ==> S.insert vli vi
06:34:58 <ceii> ($) applies its left side to its right side, (.) composes functions sithout mention of the argument
06:35:00 <Mertesacker> > (+1) $ (*5) 7
06:35:01 <lambdabot>   36
06:35:06 <Cale> ($) is an operation which takes a function and a value which is an appropriate type to apply that function to, and applies the function
06:35:13 <Cale> (f . g) x = f (g x)
06:35:18 <Cale> f $ x = f x
06:35:22 <Cale> are the definitions
06:35:54 <Cale> (.) :: (b -> c) -> (a -> b) -> (a -> c)
06:36:03 <Cale> ($) :: (a -> b) -> a -> b
06:37:15 <astry> to me, $ means "open a parenthesis and extend it all the way to the right"
06:37:35 <scopedTV> astry: that's how it's used, but it's not a syntactic operation.
06:37:40 <Cale> astry: don't forget about the other side!
06:37:48 <astry> what about the other side?
06:38:00 <scopedTV> astry: e.g.   f :: a -> $ b -> c  -- ?????
06:38:13 <Cale> f . g . h $ x + y + z
06:38:16 <astry> scopedTV: don't be silly
06:38:18 <Cale> behaves like
06:38:24 <Cale> (f . g . h) (x + y + z)
06:38:56 <scopedTV> ($) is not special; that was my point.
06:39:01 <astry> ok go on Cale
06:39:23 <Cale> (so it's like you're putting parens around each side)
06:39:45 <astry> i thought  . had a higher precedence than application
06:39:50 <Cale> no
06:40:01 <Cale> application has higher precedence than any infix operator
06:40:04 <astry> i didn't know about that
06:40:21 <ceii> application has higher precedence than any operator
06:40:37 <geekosaur> think about it, something which hs no operator either needs to be highest precedence or is *realy* hard to work with
06:40:55 <astry> i'd have thought f ~ g ~ h $ a + b would evaluate to f ~ g ~ (h (a + b))
06:40:57 <Cale> that's not necessarily true
06:41:01 <astry> it's good you pointed it out
06:41:10 <astry> the $ puts parens around both sides
06:41:26 <Cale> Even if (.) had higher precedence, we could still insert parens to fix things up
06:41:27 <astry> so . has higher precedence than $, right?
06:41:31 <Cale> right
06:41:39 <Cale> ($) has the lowest possible precedence
06:41:40 <astry> what things have lower precedence than $?
06:41:42 <astry> oh
06:41:51 <astry> that's cool to know
06:41:57 <astry> thanks for letting me know Cale :)
06:42:27 <lehmat> Cale, sweetie, why aren't you in blah?
06:42:31 <Cale> (.) has the highest possible precedence for an infix operator
06:42:31 <lehmat> Shouldn't you be there, for me?
06:42:44 <astry> lehmat: ...
06:42:48 <Cale> lol
06:42:51 <lehmat> Something I did not know because I'm too lazy to learn all that
06:43:07 <lehmat> Which brings us to our original point, Sussman is always right
06:43:44 <Cale> You rarely need to know any of that, apart from the rule about function application being higher precedence than anything else.
06:44:26 <lehmat> True, that's why I don't know it.
06:44:33 <lehmat> Because I put in all the parentheses.
06:44:50 <lehmat> map f (x : xs) = (f x) : (map f xs) etc
06:45:07 <Cale> oh, if you remember the rule about function application
06:45:11 <Cale> (just that one)
06:45:18 <Cale> then you can remove two sets of parens there
06:45:42 <Cale> and you don't even have to remember that (:) has fixity 5
06:45:54 <lehmat> I don't remember anything, I woke up one day, no idea what happened before that point, who I was, or what my name was, I just felt like I missed several vital organs and the ice bath was too cold too.
06:46:09 <lehmat> I know, but with the parens is just clearer for me and makes me feel 'safer' I guess (irrationally)
06:46:19 <lehmat> I know that infix always comes before "normal" application
06:46:52 <Cale> or "after" depending on whether you're working bottom up or top down :)
06:48:31 <astry> defensive parentheses are a sign of weakness
06:49:15 * t7 looks around for lisp users
06:49:20 <lehmat> Cale, I must admit though, designing a more sensible syntax for haskell is challenging because of the higher order functions, you can't just do it like + - 1 3 4 etc
06:49:28 <lehmat> t7, sup
06:49:56 <Cale> lehmat: It'd be easy to just remove infix operators from the language if you wanted
06:49:58 <astry> sounds like you don't want a language but a hp calculator
06:50:16 <lehmat> I guess map f (cons x xs) = cons (f x) (map f xs) is honestly fine though.
06:50:30 <lehmat> Cale, sure it would, but 'just praefix' isn't the optimal way
06:50:46 <divyanshu> (+) $ (-) 1 3 4
06:51:13 <lehmat> As in, there's a reason you don't write (+ 1 (+ 2 (+ 3 (+ 4)))) in lisp because it's a pain
06:52:06 <mizu_no_oto> Most of lisp's parenthesis are because it has n-ary functions, right?
06:52:15 <lehmat> I guess just keeping haskell the same but removing infix in any and all forms works fine as far as expressions go though
06:52:15 <lehmat> Yeah
06:52:31 <lehmat> S expressions are _Terrible_ to write Haskell in, the syntax is suitable for languagse which have a lot of n-ary functions
06:53:00 <lehmat> The entire purpose of s-expressions is wasted if you say either sat that (f x y z) is the same as (((f x) y) z) or that you _have to_ use the latter because the first makes no sense
06:53:10 <donri> in lisk (+ a b c...) translates to a+b+c...
06:53:40 <mizu_no_oto> lehmat:  variable arity is probably the better term for what I was referring to
06:53:44 <lehmat> Does it do that with everything?
06:53:51 <lehmat> Yeah, but I get what you mean
06:53:56 <donri> it does it with operators
06:54:29 <Cale> But also, n-ary functions are much harder to write down equational rules for in general, and variable arity harder still.
06:54:31 <lehmat> I assume you some-where define that explicitly?
06:54:56 <mizu_no_oto> Every function (in common lisp, at least) can have an &rest paramater that's the list of the additional arguments
06:54:59 <lehmat> You could also see it in reverse honestly, that the binary + is a special case of the variadic +?
06:55:08 <donri> in lisk? it just defines an operator the same way haskell does
06:55:15 <Cale> Because you can't just write down a single rule and call it a day, you have to pass to some meta-notation which handles bunching multiple parameters into single ones
06:55:23 <Cale> and once you do that, well, what's the point?
06:55:34 <Cale> (why not just do it all the time?)
06:55:37 <lehmat> donri, ohhh
06:56:02 <Cale> donri: by lisk, do you mean liskell?
06:56:09 <lehmat> So it basically goes wrong if I define a '3-ary function' as being an operator.
06:56:15 <donri> Cale: nope, i mean chrisdone's lisk
06:56:18 <Cale> ah
06:56:20 <donri> http://chrisdone.com/posts/2010-11-25-lisk-lisp-haskell.html
06:56:23 <lehmat> Say I define (======) = map
06:56:24 <lehmat> or whatever
06:56:28 <Cale> there's actually another one :)
06:56:50 <donri> yep, but IIRC liskell requires a specially compiled ghc that only handles liskell then
06:57:21 <lehmat> That's honestly a pretty good solvation of the problem because operators are 'meant to' exprses binary functions
06:57:22 <lehmat> I like it.
06:57:47 <quicksilver> I find that (common) lisps approach leads to more complexity than simplicity because you have a dichotomy between multiple arguments passed-as-a-list and a single argument which is a list
06:57:54 <donri> yea there's exceptions to that e.g. with lenses, but you can still express that in lisk
06:58:09 <Cale> quicksilver: I agree
06:58:13 <quicksilver> and you end up doing using 'apply' and splices and antiquotes
06:58:21 * hackagebot network-transport 0.3.0 - Network abstraction layer  http://hackage.haskell.org/package/network-transport-0.3.0 (EdskoDeVries)
06:58:29 <quicksilver> just because you have a list when you didn't want one or vice versa
06:58:30 <lehmat> quicksilver, basically every function can be seen as a function that takes a single argument which has tob e a list, and returns a single argument that has to be alist
06:58:34 <lehmat> but lists can have multiple types
06:58:49 <lehmat> And lists can contain lists
06:59:36 <quicksilver> lehmat: yes, I know how it works :)
06:59:42 <Cale> quicksilver: It seems weird for a language which is apparently so concerned with list manipulation to turn around and not use lists for the obvious job :)
07:00:28 <lehmat> Cale, they are generally used for different things though
07:00:51 <lehmat> And compilers also optimize it better in that sense of course.
07:01:03 <lehmat> As in, say you pass (list 1 2 3 4) to + which is just product
07:01:14 <lehmat> How does the compiler know that at runtime, list does not refer to a completely different function
07:01:16 <Cale> (sum?)
07:01:23 <lehmat> Ehh, yeah, sum
07:01:24 <lehmat> Sorry.
07:01:59 <lehmat> If you do (sum (list 1 2 3 4 5)) instead of (+ 1 2 3 4 5) and compile it to the same code stuff might go wrong, list could refer to something else at runtime.
07:02:08 <Cale> what?
07:02:22 <lehmat> You can mutate functions in lisp
07:02:31 <Cale> Oh, well, just remove that :D
07:02:35 <lehmat> Not sure how it's done in common lisp, but in scheme what if I do (set! list 3)
07:02:46 <simon> Cale, couldn't you mutate + as well?
07:02:55 <lehmat> Or rather just (set! list (compose reverse list))
07:03:05 <Cale> Yeah, if you mutate the list formation function, then you deserve what you get.
07:03:16 <lehmat> You could, and the compiler makes no assumptions about it in that way.
07:03:21 * hackagebot network-transport-tests 0.1.0.0 - Unit tests for Network.Transport implementations  http://hackage.haskell.org/package/network-transport-tests-0.1.0.0 (EdskoDeVries)
07:03:30 <lehmat> No, it's extremely common to name a variable locally 'list' if you don't need the list function locally
07:03:39 <lehmat> Well, static scoping solves that issue of course.
07:03:51 <lehmat> But anyway, this is the reason, the spec allows you to update and extend functions
07:04:00 <Cale> lehmat: And of course, it would be less popular if you had to use that function more commonly
07:04:13 <Cale> But also, the name of that function is way too long now
07:04:22 <lehmat> list actually isn't used that often in scheme weirdly enough, cons is used way more.
07:04:32 <lehmat> Probably because you never encounter sum [1,2,3,4] because people just use (+ 1 2 3 4)
07:04:50 <lehmat> I concur, scheme likes long function names I don't like it
07:05:11 <Cale> The other bone I have to pick with scheme and most lisps is that compose is 7 characters, plus the two you'll need to apply it.
07:05:26 <lehmat> I always point out to people who say they like long function names and memorizing short ones is a pain that (contents-of-accessor-part-of-register '(1 2 3 4)) is even more so
07:05:49 <lehmat> I concur, I personally use 'c' for compose
07:06:00 <lehmat> And l for lambda
07:06:19 <lehmat> I might cahnge thoose to & or @ or something like that honestly.
07:07:28 <lehmat> Honestly, if I write lambda calculus to myself I also always just write (x y. x) instead of λx y. x, what's the use of giving a name to a binding operation when it's the only one you use?
07:08:10 <quicksilver> lisp all seemed perfectly sensible to me until I abstracted out some repeated code
07:08:36 <lehmat> quicksilver, how so? Is that hard to do in lisp?
07:08:45 <quicksilver> and the abstracted version took the form (apply 'foo `(a ,(f a b c) ,@(if ....) d e))
07:08:55 <quicksilver> and I thought that was pretty horrible.
07:09:05 <faus> is there a direct download link to the ghc compiler and the other copilers like jhc (some kind of an ftp server so i dont have to use git or darcs)
07:09:07 <faus> ?
07:09:34 <Cale> http://www.haskell.org/ghc/download
07:09:43 <faus> i don't like you already
07:09:52 <Cale> ???
07:09:57 <faus> its not what im looking for
07:10:11 <faus> looking for latest version
07:10:14 <Cale> That's what it *sounds* like you're looking for
07:10:19 <faus> git clone git://darcs.haskell.org/ghc.git  is supposed to work, but its down
07:10:25 <faus> someone forget to update the link
07:10:50 <faus> http://hackage.haskell.org/trac/ghc/wiki/Repositories have some links, seems some are down
07:10:53 <faus> well they've moved
07:11:01 <quicksilver> you said you didn't want to use git?
07:11:08 <quicksilver> what do you mean by 'latest version'
07:11:26 <geekosaur> they want a daily snapshot, I think
07:11:36 <aya_> anyone knows if there's another channel for python for an example?
07:12:07 <Cale> There are links from the page which I linked to
07:12:13 <Cale> to development snapshots
07:12:17 <quicksilver> quite so.
07:12:28 <Eduard_Munteanu> Heh, funny git link... *darcs*
07:12:33 <quicksilver> they're not for the light-hearted though.
07:12:39 <quicksilver> faint-hearted, even.
07:12:48 <Sculptor> hi!
07:12:55 <faus> there no direct links
07:13:02 <aya_> yeah i did it too, but found nothing though
07:13:16 <Cale> faus: It's two clicks from there :)
07:13:21 * hackagebot network-transport-tcp 0.3.0 - TCP instantiation of Network.Transport  http://hackage.haskell.org/package/network-transport-tcp-0.3.0 (EdskoDeVries)
07:13:23 * hackagebot distributed-static 0.2.1 - Compositional, type-safe, polymorphic static values and closures  http://hackage.haskell.org/package/distributed-static-0.2.1 (EdskoDeVries)
07:13:25 * hackagebot distributed-process 0.4.0 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.4.0 (EdskoDeVries)
07:13:37 <Cale> Head branch snapshots -> appropriate exact version
07:14:25 <faus> ->> my download scripts aren't psychic to know what the latest version is
07:14:41 <Cale> What are you trying to do?
07:14:57 <faus> download the latest version every once in a while without a branch anager
07:15:01 <Cale> The development snapshots aren't actually meant to be used
07:15:25 <Cale> In fact, 7.6.1 has been out for a while, and even it's too new to really be totally useful yet.
07:15:44 <Cale> I would recommend getting 7.4.2 at this point
07:15:56 <Cale> if you're just a user
07:16:14 <faus> do you like automation?
07:16:26 <Cale> This isn't really automatable.
07:16:32 <quicksilver> most people will find the latest platform more useful
07:16:36 <quicksilver> because the libraries work with it
07:16:38 <faus> sourceforge have direct links
07:16:44 <faus> lots of software have it
07:16:46 <faus> its trivial
07:16:55 <Cale> faus: How are you using GHC?
07:17:07 <faus> you update the symlink when you put up a new release
07:17:15 <typoclass> faus: honestly, get one of the released versions like cale recommends. building ghc yourself is rarely necessary, and unless you want to do development work yourself that you need to coordinate tightly with the ghc developers ...
07:17:29 <faus> never asked for free honesty
07:18:39 <Cale> http://www.haskell.org/ghc/dist/7.6.1/ghc-7.6.1-i386-unknown-linux.tar.bz2 -- just take this link then and pretend that it says "latest". Eventually that will not be true, but by that point, you'll probably have realised that this doesn't matter.
07:18:57 <typoclass> faus: how do you mean?
07:19:09 <faus> typoclass: just looking for technical talk
07:19:14 <faus> not willing to get personal
07:19:23 <lehmat> quicksilver, I must admit, lisk looks very appealing, much more than liskell
07:19:31 <faus> you're trying to sugarcoat with free honesty, i cannot return the favor
07:19:54 <lehmat> What's with the colons before types however?
07:20:01 <lehmat> It does not support case sensitivity in symbols?
07:20:10 <Cale> I wondered about that too
07:20:38 <faus> without a direct link the user have to have darcs or that fucking git installed
07:21:04 <quicksilver> faus: moderate the language please
07:21:48 <faus> quicksilver: i'm not priviledged in this channel
07:22:29 <Cale> faus: Why would you want the git/darcs version of GHC?
07:22:37 <faus> Cale: for development
07:22:40 <typoclass> faus: i'm sorry, i don't understand you very well. just to be sure, what i meant is: i agree with cale's recommendation. i would recommend the same. nothing personal intended
07:22:46 <Cale> Are you actually hacking on GHC?
07:22:50 <faus> yes
07:23:04 <monochrom> I don't understand this dispute
07:23:08 <Cale> okay, then you *need* the actual repo
07:23:22 * hackagebot distributed-process-simplelocalnet 0.2.0.6 - Simple zero-configuration backend for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.0.6 (EdskoDeVries)
07:23:30 <Cale> So just wait for it to come back up
07:23:42 <faus> i can parse the ftp page and take the first entry at the top, then parse that
07:23:52 <Cale> faus: There's no point in doing that
07:23:55 <faus> but then again i just smoke some dope with my bros
07:24:28 <faus> Cale: yes it is, its smaller than installed a cvs
07:25:16 <Cale> faus: But if you're working on GHC's source code, when you submit patches, it will be good if you can actually use the version control system.
07:25:29 <faus> Cale: sure
07:25:38 <faus> lets talk about getting the source code first
07:25:58 <Cale> and if you're not working on GHC's source code, you have no need to be running one of these versions.
07:26:11 <faus> what is this, a gallager routine?
07:26:22 <Cale> ?
07:27:08 <faus> don't patronize me by repeating yourself when i ask different questions
07:27:08 <Cale> (nor do you typically have any need to touch the source code if you're not hacking on it)
07:27:37 <faus> totally irrelevant
07:27:53 <Cale> Yeah, the reason that I'm repeating myself here is that you seem to be asking for something for which I cannot imagine a reason that anyone would need it.
07:28:19 <Cale> Different GHC versions are not interchangeable
07:28:37 <faus> so ... you're a fascist?
07:29:01 <osfameron> yeah, all the marching and hailing in this channel gets very disconcerting
07:29:18 <typoclass> faus: please be aware that people are trying to help you with your questions. if you say things like "don't patronize me" and "totally irrelevant", you're making it more likely that they will stop helping you
07:29:26 <faus> consider a formal spec for deploying across multiple machine, and me smoking a fatty - do i have time to click through the latest version everytime i want to run a test?
07:29:35 <faus> typoclass: the road to hell is paved on good intentions
07:29:43 <tibbe> Does an Alternative instance for Either make sense?
07:29:45 <Philippa> faus: try #ghc
07:29:53 <Cale> tibbe: I think so
07:29:55 <tibbe> Or put another way, why isn't there an Alternative instance for Either?
07:30:10 --- mode: ChanServ set +o monochrom
07:30:10 <Cale> tibbe: Probably no good reason
07:30:13 <faus> Philippa: interested in all interpreters
07:30:15 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.142.1.223.143
07:30:15 --- kick: faus was kicked by monochrom (faus)
07:30:20 --- mode: monochrom set -o monochrom
07:30:20 <tibbe> (The reason I'm asking is that I have a type that's isomorphic to Either but I can't actually use Either due to missing instances)
07:30:28 <quicksilver> there are two possible Applicative instances for Either
07:30:32 <quicksilver> (at least)
07:30:37 <typoclass> monochrom: you could have given a warning ...
07:30:42 <quicksilver> and I suspect that's why there isnt' an Alternative instance
07:30:43 <monochrom> I'm sorry, "you're a fascist?" is enough for me
07:30:57 <typoclass> monochrom: fair enough
07:30:58 <hiptobecubic> agreed
07:31:00 <quicksilver> just that you'd have to choose.
07:31:02 <monochrom> and "you're a fascist?" does not need a warning
07:31:13 <Philonous> typoclass:  He was warned to moderate his language
07:31:17 <Philippa> it probably does /once/, but only because so much of the rest of the 'net is shitty
07:31:31 <Philippa> (and because people think "moderate your language" means "swear less")
07:32:37 <t7> what does the bit after a guard mean in a class decl?   class foo a b | a -> b where
07:32:41 <Philippa> that said: I have zero problem with the warning not being overly polite. Say, "Cale's not, but I happen to be one of the appointed dictators around here and I'm telling you not to accuse people of fascism in here"
07:32:52 <quicksilver> it's a functional dependency, t7
07:33:27 <quicksilver> it means that b is uniquely determined by a
07:33:52 <Philonous> t7:  It means you can't have two instance of Foo (needs to be upper case, btw), with the same a
07:33:55 <otters> which still doesn't make sense to me
07:33:57 <otters> od
07:33:59 <otters> oh
07:34:25 <tibbe> quicksilver: there are two possible instances for other classes as well, but we already seem to have selected Left to be failure.
07:35:36 <Philonous> t7:  The point is that the compiler can infer b from a, so you need less type declarations
07:35:43 <quicksilver> tibbe: not what I meant.
07:35:55 <quicksilver> tibbe: with Applicative, you can do something different
07:36:07 <tibbe> quicksilver: gotta run, ttyl
07:36:12 <quicksilver> instance Monoid a => Applicative (Either a)
07:36:14 <quicksilver> it's in the paper
07:36:16 <quicksilver> :)
07:36:18 <tibbe> ah
07:37:11 <Saizan> we already have an Applicative (Either e) instance though
07:37:19 <Saizan> so that choice has been made too
07:37:38 <Saizan> i suspect the problem is empty = Left ?
07:38:08 <quicksilver> ah, so perhaps you *need* my version if you want an Alternative instance
07:38:14 <quicksilver> I didn't know that
07:38:24 <quicksilver> although maybe it's in the paper too
07:39:18 <Saizan> you don't need all of Monoid e with this Applicative, just Default e or something
07:39:30 * quicksilver nods
07:42:27 <quicksilver> Saizan: although with the old instance you could use "Left noMsg" for empty
07:42:29 <quicksilver> I guess
07:42:57 <quicksilver> or, equally Left (strMsg "Alternative.empty")
07:43:06 <quicksilver> I forget the actual method names in the old Error class.
07:43:16 <quicksilver> but certainly, there were possible canonical inhabitants there.
07:44:29 <Saizan> yep, i guess since they weren't using Error for the Applicative they didn't introduce Error for Alternative, also because Error was mtl at the time, iirc?
07:49:13 <quicksilver> Saizan: I suspect the Applicative authors didn't much like the 'Error' class
07:59:48 <profmakx> hunger
07:59:58 <profmakx> great. sorrz.
08:09:08 * hackagebot uu-parsinglib 2.7.4 - Fast, online, error-correcting, monadic, applicative, merging, permuting, idiomatic parser combinators.  http://hackage.haskell.org/package/uu-parsinglib-2.7.4 (DoaitseSwierstra)
08:26:37 <apple_user> hello
08:27:09 <apple_user> I'm learning Haskell from http://learnyouahaskell.com ^_^ excellent book, especially as it's gratis
08:27:48 <osfameron> indeed it is
08:27:50 <apple_user> I'm at the Modules chapter; what is the differnce between Haskell modules and C preprocessor #includes and headers?
08:28:25 <Clint> more like headers + libraries
08:28:33 --- mode: ChanServ set +o monochrom
08:28:38 --- mode: monochrom set -b *!*@gateway/web/freenode/ip.142.1.223.143
08:28:42 --- mode: monochrom set -o monochrom
08:28:45 <mcstar> can somebody help me understand this? http://tryfs.net/snippets/snippet-7k
08:29:55 <Clint> is that f#?
08:30:08 <Clint> ah
08:30:12 * Clint should learn to read.
08:30:15 <mcstar> yes
08:31:30 <mcstar> how could i implement this same strategy pattern in haskell?
08:31:33 <monochrom> the "strategy" design pattern is another way to say "take a lambda or callback as a parameter"
08:31:54 <mcstar> argh, i cant keep my poker face
08:31:59 <mcstar> its a joke
08:32:04 <monochrom> hahaha OK!
08:32:08 <hsyl20> :D
08:32:13 <mcstar> it illustrates 'strategy patter' wtf
08:32:40 <typoclass> apple_user: i think they're vaguely similar. a difference is that haskell will tell you if two modules define the same name ("ambiguous function"), where in c, i'm not sure
08:32:47 <apple_user> right
08:33:01 <apple_user> I like the idea of modular programming
08:33:21 <monochrom> both "command" and "strategy" are just passing around functions. but perhaps "command" is more geared to IO, "strategy" is more geared to purely functional algorithms
08:33:27 <scopedTV> C's #include is purely a textual substitution
08:33:34 <apple_user> right
08:34:00 <apple_user> no help from the actual compiler to enforce information hiding, encapsulation and stuff
08:34:09 * hackagebot data-named 0.3.0 - Data types for named entities  http://hackage.haskell.org/package/data-named-0.3.0 (JakubWaszczuk)
08:34:10 <scopedTV> haskell's modules are different; a haskell module must reside in exactly one file
08:34:11 <typoclass> apple_user: oh of course, you have better control over everything. "import Foo (abc, def)" imports only the functions abc and def from the Foo module. "import Foo as F" lets you do "F.abc", in case you have abc imported from some other place and need to disambiguate
08:34:28 <typoclass> also, you can do "import Foo hiding (abc)", i.e. everything except abc
08:36:12 <mcstar> monochrom: it is just an example of using higher order functions, maybe partial application, it is just weird to see it in a language that supports those, idk why is it useful to bring the OO idioms unnecessarily to a functional language
08:37:42 <apple_user> what does the "higher-order" in terms like higher-order functions mean?
08:37:49 <hiptobecubic> apple_user, functions on functions
08:37:57 <mcstar> functions taking functions as arguments
08:38:00 <apple_user> in college, i've heard of higher-order derivates
08:38:07 <apple_user> is it some math concept?
08:38:08 <hiptobecubic> apple_user, instead of functions on "primitive" values
08:38:12 <apple_user> ah
08:38:29 <mcstar> well, a derivative operator is a higher order function
08:38:31 <hiptobecubic> apple_user, what language(s) are you familiar with?
08:38:32 <apple_user> I like how functions are considered primitives in functional languages
08:38:37 <mcstar> takes a function and gives back a function
08:38:45 <typoclass> apple_user: yup, we all like it :)
08:39:10 * hackagebot nkjp 0.1.0 - Manipulating the National Corpus of Polish (NKJP)  http://hackage.haskell.org/package/nkjp-0.1.0 (JakubWaszczuk)
08:39:10 <scopedTV> functional languages are about functions and values, not state and mutation
08:39:15 <typoclass> it sounds like a small thing, but it's just surprisingly handy
08:39:28 <hiptobecubic> it's no small thing
08:39:49 <ion> Please don’t manipulate Polish corpses.
08:39:52 <mcstar> also, haskell is doubly great, it has functions as values, and has IO actions as values too
08:40:07 <apple_user> I've always wanted something like that in C (the only first class objects besides machine words and floats are pointers) and C++ (emulate functions with objects; very clumsy)
08:40:57 <mcstar> you can pass functions around in those languages too
08:41:02 <tromp> you can write a little lambda calculus interpreter in C :)
08:41:02 <typoclass> ion: you could send a patch to make his functions all unsafe
08:41:05 <mcstar> the problem is that you cant make them programmatically
08:41:10 <apple_user> right
08:41:52 <apple_user> always wanted to have a function that returns functions depending on some parameters, and pass that returned function to a greater function.
08:42:06 <apple_user> i.e. have a function that defines a game's rules, and then pass that function to the game itself.
08:42:39 <trotro> you want a functional language
08:42:48 <apple_user> wish I could use ncurses in Haskell
08:42:55 <mcstar> you can
08:42:55 <scopedTV> i think you can, why not?
08:42:58 <apple_user> could I? :D
08:43:03 <mcstar> why couldnt you?
08:43:10 <mcstar> theres even a binding
08:43:11 <scopedTV> calling C from haskell is very easy.
08:43:12 <monochrom> there is an ncurses binding on hackage
08:43:12 <apple_user> ah
08:43:37 <apple_user> excellent
08:43:40 <scopedTV> yeah, in this case the work has already been done for you
08:44:38 <Puffton> How about adding "Learn you a haskell for great good" to the topic? It's great IMO
08:45:02 <typoclass> Puffton: good idea
08:45:25 <mcstar> look at paragraph #7, theres some insider information on haskell http://t-a-w.blogspot.co.uk/2012/08/7-languages-in-7-weeks.html
08:45:29 <apple_user> I like that book; can't wait to learn enough Haskell from it to do useful things ^_^
08:45:43 <mcstar> (not for apple user, for the others)
08:45:53 <apple_user> ah
08:46:01 <shachaf> Better to add a link to the FAQ or something.
08:46:09 <apple_user> not for me? :(
08:46:12 <shachaf> The FAQ links to LYAH but also to other useful things.
08:48:31 <Puffton> apple_user, http://learnyouahaskell.com/chapters
08:48:36 <apple_user> ah what's so bad about monads?
08:49:01 <scopedTV> nothing
08:49:10 * hackagebot Cabal 1.16.0.1 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.16.0.1 (JohanTibell)
08:49:12 * hackagebot cabal-install 1.16.0 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.16.0 (JohanTibell)
08:49:18 <mcstar> apple_user: i told you that link wasnt meant for you
08:49:30 <apple_user> right sorry :(
08:50:18 <monochrom> "sane language doesn't need monad" has been proved false by C# Linq etc
08:50:19 <typoclass> apple_user: don't worry, i think you're allowed to click links and look at them :-)
08:50:39 <ski> apple_user : the derivative operation `D : (|R -> |R) -> (|R -> |R)' is a second-order function
08:50:40 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
08:50:45 <ski> @messages
08:50:45 <lambdabot> edwardk said 1d 1h 55m 35s ago: http://www2.tcs.ifi.lmu.de/~abel/popl13.pdf
08:51:06 <monochrom> also many scala people use monad in scala
08:51:31 <mcstar> monochrom: feel free to comment on the post on his blog :)
08:52:46 <apple_user> I'll eventually learn what monads are ^_^ they seem pretty useful and I've been using them a lot already in things like `sum [x | x <- [1..100000], isPrime x]` and `putStrLn "Hello, World!"`
08:53:35 <mcstar> the first one is called list comprehension
08:53:57 <typoclass> apple_user: yes, don't worry, using things is the important part :-) the understanding will come
08:54:22 <ski> > sum (do x <- [1 .. 100000]; guard (isPrime x); return x)
08:54:23 <lambdabot>   Not in scope: `isPrime'
08:54:28 <mcstar> also, `putStrLn "Hello, World!"` doesnt make sense as n infix operator
08:54:34 <mcstar> as an*
08:54:46 <mcstar> ski tries to do the same thing with the list monad
08:55:00 <apple_user> I thought listcomps were monads
08:55:00 * ski thinks apple_user didn't mean it as an infix operator ..
08:55:03 <TheBrayn> I think it's a way of quoting
08:55:14 <mcstar> ski: yeah, thats why its a joke
08:55:25 <Clint> i laughed
08:55:28 <ski> apple_user : list comprehensions (not including parallel such) are basically the same thing as the list monad
08:55:35 <apple_user> good point I also like how function application is a function in Haskell since everything is curried in haskell
08:56:21 <mcstar> do you mean ($)?
08:56:38 <mcstar> i think ($) is called the function application oprator
08:56:52 * ion laughs at “What's surprising is how many Haskell programmers don't understand that monads are simply a hack to make I/O in Haskell bearable”
08:57:04 <scopedTV> ion: yeah trolololo
08:57:19 <mcstar> i think that guy honestly means it
08:57:21 <apple_user> he links to Smalltalk in the end
08:57:35 <mcstar> who would in their right mind pick up a book called 7 languages in 7 weeks??
08:57:48 <scopedTV> i don't see the problem with that?
08:57:55 <hiptobecubic> mcstar, maybe as a taster to decide which language you want to actually learn?
08:57:56 <mcstar> i sort of do
08:58:04 <nexx> is it from that book?
08:58:05 <scopedTV> i mean, obv you're not going to learn those languages very well
08:58:17 <scopedTV> but i could see myself reading it
08:58:21 <mcstar> read Norvig's 'learn programming in 21 years' article
08:58:28 <hiptobecubic> :)
08:58:41 <hiptobecubic> There was that other one as well
08:58:47 <hiptobecubic> about how it takes to master something
08:58:48 <nexx> learning a language != learning programming
08:58:56 <hiptobecubic> I think the conclusion was something like ten years of regular practice
08:58:59 <apple_user> learn C++ in 3 weeks ^_^
08:59:08 <apple_user> ... and 10 years! :D
08:59:20 <hiptobecubic> you need 21 years to learn C++, and that's without learning programming.
08:59:33 <nexx> :D
08:59:35 <arkx> mcstar: I think you've misunderstood the point of that book. It certainly does not pretend to teach those languages in and out. :)
08:59:56 <mcstar> arkx: i couldnt have possibly done that, since i never read it
08:59:57 <MostAwesomeDude> You need 10000 hours of experience to become an expert at something. That's ten years if you shed constantly.
09:00:01 <typoclass> i think it's fine to get a taste of what's possible and what's out there. nobody expects you to be the world's greatest expert on those 7 languages after reading the book
09:00:17 <Cale> apple_user: Monads are type constructors which support a particular interface consisting of return and (>>=). List comprehensions can be seen as syntax sugar for the list monad, in that in the monad instance for lists, xs >>= f = concat (map f xs)
09:00:28 * monochrom decides not to post a comment on that blog. it's 2 months ago.
09:00:37 <apple_user> what does >>= mean?
09:00:44 <apple_user> bitshift-assign?
09:00:47 <mcstar> nooo
09:00:48 <scopedTV> apple_user: no no no
09:00:49 <Cale> apple_user: It depends on which monad you're using, and no :)
09:00:50 <nexx> ô.o
09:00:53 <mcstar> :t (>>=)
09:00:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
09:00:56 <scopedTV> apple_user: depends on the monad.
09:01:01 * apple_user 's head explode
09:01:03 <hiptobecubic> apple_user, there is no assign anyway
09:01:25 <scopedTV> @src (>>=) Maybe
09:01:25 <lambdabot> Source not found. My pet ferret can type better than you!
09:01:29 <Cale> apple_user: Feel free to ignore all the stuff in that type signature up to the .
09:01:32 <scopedTV> @src Maybe (>>=)
09:01:32 <lambdabot> (Just x) >>= k      = k x
09:01:32 <lambdabot> Nothing  >>= _      = Nothing
09:01:36 <monochrom> (>>=) is a monad operator. it chains up two commands.
09:01:44 <apple_user> ah, so >>= is like . but for monads?
09:02:03 <Cale> It's more like a monadic version of ($)
09:02:07 <typoclass> apple_user: a little bit, yeah :)
09:02:07 <apple_user> oh
09:02:08 <donri> >=> is like . for monads ;)
09:02:13 <Cale> flipped over, as well
09:02:22 <monochrom> I don't like to answer "___ is like ___?" questions because "like" is too flexible
09:02:27 <apple_user> true
09:02:27 <Cale> actually, if we want to make the comparison, let's talk about =<< and <=<
09:02:28 <donri> uh, <=< yea
09:02:39 <monochrom> but today I'll just answer "yes"
09:02:50 <Cale> (=<<) :: (a -> m b) -> m a -> m b
09:02:52 <mcstar> well you marry me?
09:02:54 <mcstar> will*
09:02:56 <mcstar> j/k
09:02:59 <clahey> I think it's more like function application.
09:03:02 <Cale> (<=<) :: (b -> m c) -> (a -> m b) -> (a -> m c)
09:03:05 <clahey> Than .
09:03:22 <typoclass> monochrom: you could point out in which ways the two things are alike, and in which ways they differ
09:03:22 <Cale> ($) :: (a -> b) -> a -> b
09:03:32 <Cale> (.) :: (b -> c) -> (a -> b) -> (a -> c)
09:03:43 <monochrom> that is premature for now. information overload.
09:04:04 <apple_user> I learned what $ and . mean from LYAH
09:04:06 <Cale> So you can see how if we stick some m's into the types of ($) and (.), we get the types of (=<<) and (<=<) respectively
09:04:17 <monochrom> if you haven't seen 10 examples of monad, there is no point in a general description
09:04:19 <hiptobecubic> Monads are like chocolate steam engine trains running in reverse through outer space.
09:04:31 <typoclass> monochrom++
09:04:55 <Cale> apple_user: So yeah, in the IO monad, for example, m = IO, and we have:
09:05:01 <apple_user> when would I use a $ over a pair of parentheses?
09:05:04 <Cale> (>>=) :: IO a -> (a -> IO b) -> IO b
09:05:14 <hiptobecubic> Depending on which train it is, you might expect it to taste differently, or maybe be a different temperature. Or be going to a different place. Backwards.
09:05:15 <mcstar> apple_user: thats a religious question
09:05:18 <Cale> and what that does is to take an IO action producing a result of type a
09:05:29 <Cale> and a function from values of type a to IO actions producing results of type b
09:05:43 <hiptobecubic> apple_user, you use $ when it's prettier.
09:05:44 <Cale> and glues them together into a single IO action producing a result of type b in the obvious way
09:05:47 <monochrom> use $ or parentheses as you see fit. go with your heart
09:05:52 <mcstar> Cale: could you typeset your type variables in italics?
09:05:56 <typoclass> apple_user: it's just personal style *shrug* some people like it when the can save the closing ")"
09:06:02 <Cale> i.e. this action will run the first action, then apply the function to get another, and run that
09:06:30 <apple_user> but $ looks ugly ; it echoes those ugly languages where $ is used to denote variables *leers at perl*
09:06:39 <monochrom> heh
09:06:47 <mcstar> you dont use it like in perl
09:06:50 <mcstar> $some
09:06:52 <apple_user> right
09:06:54 <mcstar> rather one $ two
09:07:16 <mcstar> at least, i like to 'space up' my expressions
09:07:37 <monochrom> sub x y = f $x $y + g $x $y  -- this is so perl :)
09:07:40 <apple_user> I like using $ only once per line :D
09:08:04 <mcstar> monochrom: clay-ball
09:08:05 <typoclass> apple_user: good rule of thumb. why not
09:08:29 <Cale> apple_user: Some general rules to keep things nice: 1) don't rely on the associativity of ($), that is, don't chain them, and 2) use $ when the parens get far apart
09:08:37 <ski> apple_user : typically, when `$' is followed by a keyword (also counting `\')
09:09:07 <Cale> One $ per line is generally the right thing
09:09:11 <Cale> (at most)
09:09:14 <Puffton> ski, what is the notation ` ' ?
09:09:15 <apple_user> right
09:09:22 <Puffton> i.e. one tilted apostrphe and one straight
09:09:24 <ski> Puffton : quotation marks
09:09:35 <Cale> If you have f $ g $ h $ x, you can always turn that into f . g . h $ x
09:09:41 <osfameron> really ugly and semantically wrong quotation marks
09:09:51 <Puffton> oh ok, I just wondered why they were different, if it had a meaning
09:09:54 <Cale> which is nicer algebraically, because (.) is a properly associative operation
09:09:56 * ski often writes `(f . g . h) x' instead
09:09:56 <mcstar> but they are far apart on the keyboard
09:10:01 <Cale> and so g . h has meaning
09:10:11 <Cale> while g $ h in that context would be meaningless
09:10:22 <Puffton> you never know with code ninjas and their notations :D
09:10:29 <apple_user> so like in smalltalk, where everything is an object, is everything a function in Haskell?
09:10:33 <ski> apple_user : no
09:10:39 <mcstar> > let ' = "`":' in '
09:10:40 <lambdabot>   <no location info>:
09:10:40 <lambdabot>      lexical error in string/character literal at chara...
09:10:42 <ion> I only tend to use $ in multiline expressions, like ones beginning as “forM_ xs $ \x -> do …”. IMO the structure of a single line is often easier to see from code with a pair of parentheses than from code with a $ somewhere.
09:10:54 <ski> apple_user : things that are functions .. are functions
09:11:15 <ski> apple_user : sometimes there's a choice whether to represent something as a function or not, but that's a different issue
09:11:16 <ion> I’d write the expression in question like ski said.
09:11:18 <Cale> apple_user: "Function" refers to things which have (->) as the top level type constructor in their type.
09:11:27 <Cale> Every function has exactly one parameter
09:11:37 <Cale> Things which don't directly take arguments are not functions.
09:11:55 <shachaf> @quote argument
09:11:55 <lambdabot> ghc says: On Alpha, I can only handle 4 non-floating-point arguments to foreign export dynamic
09:12:01 <Puffton> Cale, but couldn't a string? a = "hello"
09:12:03 <Puffton> also be a function?
09:12:03 <shachaf> thanks, ghc
09:12:09 <Cale> Puffton: no
09:12:12 <ski> Puffton : no, since it doesn't take an argument
09:12:18 <Cale> "hello" 6  is a type error
09:12:24 <ski> > "hello" 6
09:12:26 <lambdabot>   Couldn't match expected type `t1 -> t'
09:12:26 <lambdabot>         against inferred type `[GHC....
09:12:31 <Cale> and not because 6 is the wrong type :)
09:12:34 <ski> a list is not a function
09:12:41 <Cale> but because the list of characters isn't a function
09:13:09 <mcstar> @pl \a b c d e f = [a,b,c,d,e,f]
09:13:09 <lambdabot> (line 1, column 14):
09:13:09 <lambdabot> unexpected "="
09:13:09 <lambdabot> expecting pattern or "->"
09:13:15 <Puffton> oh ok
09:13:21 <mcstar> @pl \a b c d e f -> [a,b,c,d,e,f]
09:13:21 <Cale> In order for f to be a function, there must exist types A and B such that f :: A -> B
09:13:21 <lambdabot> (. ((. ((. ((. ((. return) . (:))) . (.) . (:))) . (.) . (.) . (:))) . (.) . (.) . (.) . (:))) . (.) . (.) . (.) . (.) . (:)
09:13:44 <mcstar> hm
09:13:47 <trotro> strange way to define a function
09:13:54 <mcstar> why is there a 'return' in it?
09:14:02 <Cale> mcstar: return v = [v]
09:14:16 <mcstar> but it could have just written v : []
09:14:20 <mcstar> thats why im asking
09:14:34 <Cale> It used return instead of writing (: [])
09:14:52 <ion> instance IsString (Int -> String) where fromString s = concat . (`replicate` s)
09:15:30 <Cale> mcstar: It probably considers return simpler because it's not a compound thing
09:15:31 <ski> trotro : in strict languages, functions are means to pass some unevaluated code as parameters, to evaluate later. in Haskell this happens by default for any value, functions are solely used for *parameterizing* some piece of code
09:15:59 <clahey> Ha.
09:16:04 <clahey> I wrote my own FromString class last night.
09:16:09 <clahey> I will switch to IsString.
09:16:19 <clahey> And then all of a sudden I can just use "L" instead of Left.
09:16:25 <clahey> Not sure if that's better or not, but whatever.
09:16:56 <ion> {-# LANGUAGE OverLoadedStringsButIPromiseIWon'tDoAnythingTooEvil #-}
09:17:02 <trotro> ski, no no , i was saying that bec ause of what Cale said about function
09:17:06 <clahey> It's so weird to think of an object as thunked.
09:17:14 <trotro> I find it strange to say f is a function if there are two types...
09:17:28 <mcstar> you dont want to look into the trunk
09:17:37 <clahey> So you can think of it like a function with no parameters as far as execution times are concerned.
09:18:05 <clahey> ion: I see no reason not to use IsString since it has the exact same definition as my FromString typeclass.
09:18:18 <clahey> Literally, the same definition.
09:18:41 <mcstar> well, i think a thrunk is much more optimized in haskell than a regular function in other laguages
09:18:46 <mcstar> but thats just a feeling
09:19:18 <clahey> mcstar: It does have the advantage that if you call it multiple times it only computes once.
09:19:25 <clahey> So you don't have to put in manual caching.
09:19:39 <mcstar> you cant call it multiple times
09:19:54 <mcstar> once evaluated, you cant evaluate it again
09:20:18 <clahey> If you use the value more than once.
09:20:32 <Cale> clahey: Don't think about thunks
09:20:38 <Cale> clahey: Think about expressions
09:21:08 <Cale> When your code runs, expressions get reduced to other expressions, and eventually to constructors which get pattern matched.
09:21:11 <clahey> Cale: It's useful to know that if no one asks for the data that I've created, it doesn't get calculated.
09:21:11 <Rc43> Hi, guys.
09:21:28 <Rc43> Is there an example of parsing using UUAG?
09:21:30 <apple_user> Rc43: hello
09:21:40 <Cale> clahey: If you just think about expressions as things which can exist at runtime, then it's not so weird :)
09:21:54 <apple_user> does haskell patterns get optimized to jump tables in assembly?
09:22:06 <Cale> (thunks are just a name for the particular implementation strategy used to implement expressions at runtime)
09:23:07 <clahey> > (a, b) = ([1..2], [1..]); print a
09:23:08 <lambdabot>   <no location info>: parse error on input `='
09:23:08 <Cale> apple_user: I think at one point they tried that.
09:23:18 <clahey> > let (a, b) = ([1..2], [1..]) in print a
09:23:19 <lambdabot>   <IO ()>
09:23:29 <ski> @help run
09:23:30 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
09:23:36 <clahey> > let (a, b) = ([1..2], [1..]) in putStrLn a
09:23:38 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
09:23:38 <lambdabot>    arising from the literal `1...
09:23:44 <clahey> > let (a, b) = ([1..2], [1..]) in print a
09:23:45 <lambdabot>   <IO ()>
09:23:50 <Cale> I still think it's weird that @run is @run and not @eval
09:23:55 <clahey> run let (a, b) = ([1..2], [1..]) in print a
09:24:07 <Cale> It used to be @eval, but at some point that was changed.
09:24:08 <monochrom> you need @. @run
09:24:08 <clahey> ski: Ah, I see.
09:24:17 <clahey> @run let (a, b) = ([1..2], [1..]) in print a
09:24:18 <lambdabot>   <IO ()>
09:24:28 <ski> Cale : istr we had some untyped lambda calc. evaluator ?
09:24:31 <clahey> @run let (a, b) = ([1..2], [1..]) in a
09:24:32 <lambdabot>   [1,2]
09:24:54 <apple_user> are ther ehaskell debuggers?
09:24:59 <mcstar> "no IO."
09:25:04 <apple_user> like how ocaml has a debugger?
09:25:15 <ski> apple_user : there is some kind of debugger in GHC now, i'm not that familiar with it
09:25:18 <johnw> yay, cabal-install 1.16 is released!
09:25:19 <ski> @where buddha
09:25:19 <lambdabot> http://www.cs.mu.oz.au/~bjpop/buddha/
09:25:21 <johnw> as of 16m ago
09:25:31 <ski> exists, but might be bitrotten
09:25:37 <Rc43> There is words about html examle http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue4/Why_Attribute_Grammars_Matter, but no file attached.
09:25:42 <Rc43> *example
09:25:45 <sopvop1> oooh, cabal install!
09:25:55 <dcoutts> @arr!
09:25:56 <lambdabot> Har de har har!
09:26:14 <mcstar> where does that come from ? ^^
09:26:16 <Cale> apple_user: GHCi has a debugger in it, but almost nobody uses it.
09:26:19 <mcstar> @yar
09:26:19 <lambdabot> Drink up, me 'earties
09:26:22 <mcstar> @yar!
09:26:23 <lambdabot> Avast!
09:26:30 <mcstar> pfff
09:26:31 <Cale> apple_user: Because that's not how you remove bugs from Haskell programs :)
09:26:43 <shachaf> hi dcoutts
09:26:51 <shachaf> @brain
09:26:51 <lambdabot> Be quiet Pinky, or I shall have to hurt you.
09:26:54 <zzing> Does anyone know if there is a way to use EclipseFP to manage a remote code base? I want to edit in eclipse my yesod powered website.
09:27:06 <ski> mcstar : where does what come from ?
09:27:07 <johnw> you can even set breakpoints on expressions in the ghci debugger, it's pretty nifty
09:27:35 <mcstar> ski: "Har de har har!" sounds like a quote from somewhere, otherwise it would bepretty stupid
09:27:36 <apple_user> how do I debug a haskell program? usually everything runs perfectly if i manage to get my code to compile at all ^_^
09:28:18 <zzing> apple_user, Debug.Trace has some unsafe things to inspect things (use with caution)
09:28:22 <clahey> Cale: How do you remove bugs from Haskell programs once they compile?
09:28:36 <johnw> well, that's not usually true of code I write in IO, since it depends not just on type correctness, but valid semantics outside of Haskell (i.e., copying between directories doesn't always mean copying between the right directories)
09:28:41 <mcstar> hard thinking
09:29:10 <ski> @hackage hood
09:29:11 <lambdabot> http://hackage.haskell.org/package/hood
09:29:13 <clahey> Who was trying to come up with a way to access Circles?
09:29:18 <mcstar> clahey: i had to debug why the ship didnt shoot on 'space'
09:29:27 <ski> apple_user : that ^ one is similar to `Debug.Trace', but more advanced
09:29:43 <johnw> does HOOD work with GHC 7.4/6?
09:29:51 * ski doesn't know
09:29:56 <johnw> it looked like that and Hat were getting really long in the tooth
09:30:15 <clahey> mcstar: Tell me about aichallenge?
09:30:30 <mcstar> clahey: what do you want to know?
09:31:48 <clahey> mcstar: What is it? How often does it run? How do you know about asteroids?
09:32:30 <mcstar> there were 4 challenges so far
09:32:36 <mcstar> about 1 year apart
09:32:43 <typoclass> apple_user: i get by without a debugger, mostly by following a few rules ("think twice before using head", "don't use fromJust", ...) and using doctests. they're great to make sure that this or that function performs as intended, and they are for ever, whereas checking something in a debugger is just a check at one point in time. plus, they double as example code and documentation
09:32:46 <mcstar> but seems, that this year will be skipped
09:32:58 <typoclass> apple_user: and there's also trace, as folks have pointed out
09:33:04 <apple_user> right
09:33:11 <mcstar> clahey: "How do you know about asteroids?" i dont understand the question
09:33:13 <krey_> hello, if I have a polymorphic function f : (a,b) -> Either a b, does it have to be (\(a,b) -> Left a) or (\(a,b) -> Right b)? how do I prove this?
09:33:28 <apple_user> what I did when I wrote some C projects was embed printf everywhere
09:33:50 <MostAwesomeDude> krey_: Homework?
09:34:25 <typoclass> apple_user: right, that's the equivalent of trace, but of course the haskell compiler is much more helpful and can tell you about many more things than the c compiler
09:35:06 <krey_> MostAwesomeDude: it would help with my summer project, although it could hardly be called homework
09:35:22 <zzing> typoclass, doctests?
09:36:36 <typoclass> zzing: putting stuff like « >>> reverse "lolcat" » «"taclol" » in haddock comments, and running the doctest tool on it. it's great, i love it
09:36:36 <monochrom> doctest means test cases mixed into API docs
09:37:04 <zzing> That is both scary and potentially useful
09:37:42 <krey_> @djinn (a,b) -> a
09:37:42 <lambdabot> f (a, _) = a
09:37:55 <typoclass> zzing: not sure what's scary :) i think it's great that haskell learned that thing from python
09:38:18 <monochrom> test cases are special cases of specifications. in light that most programmers suck at writing specifications any other way (natural language, formal language), test cases as specifications actually work wonders
09:38:27 <zzing> typoclass, the difference between testing and proving perhaps?
09:38:29 <johnw> i love doctest
09:38:49 <krey_> @djinn ((a,b) -> Either a b) -> Either ((a,b) -> a) ((a,b)->b)
09:38:49 <lambdabot> f a =
09:38:49 <lambdabot>     Left (\ (b, c) ->
09:38:49 <lambdabot>           case a (b, c) of
09:38:49 <lambdabot>           Left d -> d
09:38:49 <lambdabot>           Right _ -> b)
09:38:57 <monochrom> "for example f(123.6) = 124" is infinitely better than "f converts floats to ints"
09:39:23 <mcstar> both are wrong
09:39:25 <typoclass> zzing: hm, perhaps ... however, a proof doesn't tell you how to use the function
09:39:33 <typoclass> monochrom++
09:39:34 <myname_> @pl \a b -> f . g (==a) $ b
09:39:34 <lambdabot> (f .) . g . (==)
09:39:37 <Nisstyre> monochrom: what's hard about "f : Float -> Int" ?
09:39:40 <mcstar> you dont know how 'f' operates in the general case
09:39:47 <zzing> typoclass, I can agree that far
09:40:05 <mcstar> is it ceiling? is it floor? or round?
09:40:15 <monochrom> there are a million things fitting Float->Int
09:40:33 <Nisstyre> monochrom: obviously include a description of the insides as well
09:40:41 <Cale> I'm pretty sure that's a vast underestimate of the number
09:40:54 <myname_> @pl \a -> f . g (==a)
09:40:55 <lambdabot> (f .) . g . (==)
09:40:55 <typoclass> mcstar: well, one of them is ruled out by monochrom's example. write a second doctest, and another one is ruled out as well, and you're done
09:40:58 <krey_> this was a bad idea...
09:41:31 <mcstar> what if 'f' behaves differently on certain inputs?
09:41:37 <monochrom> oh yes, rely on programmers for precise descriptions in prose or any non-coding language
09:41:41 <Nisstyre> mcstar: what?
09:42:04 <Nisstyre> mcstar: we're assuming it's a bijection
09:42:11 <apple_user> does haskell have late-binding, or does it not need them?
09:42:20 <mcstar> > let f x = if x == 1.0 then 0 else round x in (f 1.0, f 2.5)
09:42:21 <lambdabot>   (0,2)
09:42:27 <hiptobecubic> Nisstyre, no he means, round towards zero except for numbers between 3 and 103.5
09:42:35 <Cale> There are closer to (2^32)^(2^32) functions Float -> Int, assuming a 32bit machine.
09:42:51 <Nisstyre> hiptobecubic: well then that should be included in the description I guess
09:42:55 <johnw> apple_user: what do you mean?
09:43:57 <mcstar> the order of definitions in the file doesnt matter, if thats what you are asking
09:44:41 <mcstar> except module definition comes first and then imports
09:44:44 <apple_user> like virtual functions in C++
09:45:02 <mcstar> why is that lates binding?
09:45:05 <mcstar> late*
09:45:16 <johnw> do you mean runtime dispatch?
09:45:32 <typoclass> mcstar: which function will be called isn't known at compile time, only at runtime
09:45:33 <johnw> Haskell does have polymorphic functions
09:45:42 <typoclass> (afaiu)
09:45:49 <krey_> @djinn: forall a. (forall b. (a,b) -> a)
09:45:49 <lambdabot> -- f cannot be realized.
09:46:11 <mcstar> typoclass: i didnt know that was termed late binding
09:46:37 <zzing> When I have a function  a -> [a]   or something like that, does the compiler generate a function for each type used (like C++) or does it have other means of supporting different types?
09:46:46 <typoclass> mcstar: i think it is, i'm not entirely sure. it's mostly an oop term, it seems
09:47:24 <Cale> apple_user: Haskell has first class functions, so it doesn't need late binding.
09:47:28 <apple_user> right
09:48:14 <johnw> also, type classes provide a lot of the functionality you typically look for in virtual functions
09:48:40 <Cale> zzing: the latter
09:48:52 <Cale> zzing: It generates one piece of code which works for all types a
09:49:06 <Cale> zzing: because every value has the same representation: a pointer to code
09:49:09 <Cale> (in GHC)
09:49:50 <shachaf> If you have a type class constraint, it might make sense to specialize the function.
09:49:53 <zzing> Cale, ok. Wouldn't that cause efficiency issues when you are dealing with things as simple as Ints?
09:50:13 <shachaf> But it still won't work behave differently like template specialization in C++.
09:50:20 <Cale> Depends on what you mean by issues.
09:50:29 <Cale> It's typically not a problem.
09:50:33 <shachaf> zzing: Ints are boxed in GHC. Everything is boxed.
09:50:48 <shachaf> http://spl.smugmug.com/Humor/Lambdacats/13227630_j2MHcg/960526161_yXhEz#!i=960526161&k=XwKHSBM&lb=1&s=L
09:50:53 <zzing> Do we have unboxed things?
09:50:57 <Cale> GHC does give you a way to work with unboxed values
09:50:59 <zzing> I recall reading about things like that
09:51:04 <Cale> but you can't use polymorphic functions on them
09:51:05 <shachaf> Well, yes.
09:51:08 <Cale> (obviously)
09:51:09 <typoclass> shachaf: i was going to link to exactly that! :-D
09:51:13 <vwvwvwv> @pl \f g h x y -> if (f . g) x then h x else h y
09:51:13 * typoclass hugs shachaf
09:51:13 <lambdabot> flip flip id . ((ap . ((flip . ((.) .)) .) . liftM2 if') .) . (.)
09:51:20 <johnw> shachaf: Int# isn't :)
09:51:20 <ousado> but there's template haskell for that, right?
09:51:28 <johnw> and there are Unboxed vectors
09:51:30 <Cale> ousado: for what?
09:51:40 <shachaf> zzing: Also keep in mind that GHC does a lot of inlining.
09:51:50 <zzing> ok, fair enough
09:52:09 <ski> apple_user : you can pass around functions (or records of functions), so that when you're handed such a function (and invoke it), you don't statically know which function you invoke
09:52:35 <apple_user> ah
09:52:39 <ousado> Cale: polymorphic code spezializing for certain types
09:52:41 <apple_user> like the strategy pattern?
09:52:59 <Cale> ousado: As far as I know, nobody really uses TH like that
09:53:20 <Cale> ousado: There were some examples of a mandelbrot generator way back when, using TH to unroll some loops
09:53:24 <shachaf> Template Haskell isn't related to C++ templates.
09:53:26 <ski> apple_user : a silly example is `data Counter = NewCounter {reset :: IO (); getCount :: IO Integer; incrCount :: IO ()}' with `newCounter :: IO Counter; newCounter = do countRef <- newIORef 0; return (NewCounter {reset = do writeIORef countRef 0; getCount = do readRef countRef 0; incrCount = do n <- readIORef countRef; writeIORef countRef (n + 1)})'
09:53:59 <n-dolio> It's kind of similar to C++ templates, really.
09:54:16 <ousado> shachaf: I doubt that very much
09:54:30 <mcstar> it is more similar to lisp macros, no?
09:54:42 <n-dolio> Not really.
09:54:49 <mcstar> oh
09:54:57 <johnw> somewhat though
09:54:57 <mcstar> i thought you are manipulating the syntax tree
09:54:58 <n-dolio> I suppose it depends what you mean by that.
09:54:59 <Cale> Actually, it is similar to lisp macros too.
09:55:06 <Cale> These things are all similar
09:55:09 <ski> apple_user : `Counter' is a type of values which are records containing three operations ("methods"). `newCounter' is *one* way of creating such a record, where the methods in it all know about a (hidden) `countRef' (mutable) state cell
09:55:09 <hpaste> plhk pasted “Not in scope: data constructor `Options'” at http://hpaste.org/75712
09:55:43 <apple_user> so Haskell has some mechanisms that are as powerful as lisp macros?
09:55:44 <Cale> plhk: put  Options(..)  in the export list
09:56:02 <Cale> apple_user: Template Haskell allows for compile-time code generation
09:56:09 <ski> apple_user : executing a new invocation of `newCounter' will make a new record where the methods know about a different hidden state
09:56:29 <plhk> Cale: thanks!
09:56:50 <n-dolio> Well, maybe it is more similar to lisp macros than C++ templates.
09:56:57 <apple_user> so it's thanks to lazy evaluation that you can do that?
09:57:07 <ski> apple_user : can do what ?
09:57:10 <Cale> apple_user: We don't tend to abuse it as much as the lisp people do, which is a consequence of 1) It's not quite so trivial to write TH code as lisp macros and 2) Nonstrict semantics means that we need macros less often.
09:57:23 <apple_user> ah
09:57:26 <clahey> mcstar: You said that asteroids was a possibility for the next contest?
09:57:37 <mcstar> clahey: yeah
09:58:09 <mcstar> clahey: still, doesnt explain to me, why are you asking from me 'how do i know about asteroids?'
09:58:29 <mcstar> what does that even mean?
09:58:39 <mcstar> how do you know about chess?
09:58:55 <mcstar> or, that you have to pay money if you buy something
09:59:52 <Cale> apple_user: We also have quasiquotation though, where you can write things like [someIdentifier| ... some code ... |] where the code is in an arbitrary language dependent on someIdentifier, which will be parsed and turned into abstract syntax and then spliced into the program.
10:00:39 <mcstar> theres a ghc option for preparsing a file too
10:00:39 <Cale> http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/template-haskell.html#th-quasiquotation
10:00:42 <klr> hi, does haskell compile to native machine code?
10:00:57 <Cale> klr: GHC has native code generators
10:01:19 <apple_user> klr: haskell's main implementation, GHC, does have a optimizing native compiler ^_^
10:01:20 <klr> Cale: so it generate code in another language which when compiles to native?
10:01:28 <apple_user> yeah it uses something called C--
10:01:34 <mcstar> it does not
10:01:34 <klr> okey
10:01:35 <apple_user> or LLVM, I'm not sure
10:01:39 <Cale> klr: There are a couple of intermediate languages
10:01:46 <klr> do it get similar performance to C?
10:02:29 <klr> maybe a dumb question sorry
10:02:29 <klr> ..
10:02:38 <Cale> klr: Sometimes?
10:02:50 <klr> Cale: what you mean?
10:02:58 <Cale> klr: C programs are not Haskell programs
10:03:00 <mcstar> http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=ghc&lang2=gcc
10:03:17 <Cale> So it's not like you can just plug in a C program and compile it with GHC and see what performance it has.
10:03:32 <klr> Okey
10:03:39 <klr> it was a dumb question when :)
10:03:50 <mcstar> always
10:04:19 <ousado> mcstar: that was a typo, I think
10:04:29 <klr> C do generate assambly code which compiles to machine code?
10:04:47 <mcstar> c is a language not a compiler
10:05:03 <Cale> klr: Yeah, you seem to be confusing languages with language implementations
10:05:07 <apple_user> yes
10:05:20 <ski> klr : C can be interpreted as well, see e.g. <http://root.cern.ch/drupal/content/cint>
10:05:29 <klr> what's an language implementation? (sorry im new to this stuff)
10:05:32 <klr> ski: okey
10:05:42 <Cale> C is a language, it defines what the programs are and what (some of them) mean, but not how to actually run them on real hardware.
10:05:52 <Cale> GCC is an example of an implementation of the C language.
10:06:05 <bgamari> tibbe, Sadly it seems the cabal-install is already broken on ghc 7.7
10:06:18 <klr> so a language is just the syntax, like the text which is human-readable, which then generates down lower and lower and finally to machine code?
10:06:22 <bgamari> tibbe, Control.Concurrent.QSem and friends are deprecated
10:06:30 <tibbe> bgamari: yeah, I know
10:06:33 <mcstar> not just syntax
10:06:37 <klr> okey
10:06:43 <watermind> I've seen some of 'dependent type programming in haskell' with GADTs, and Kind Promotion,  such as vectors with a Nat type... how much can with do with it at this point? e.g.,  could we have a function that may or may not add an element?
10:06:45 <Cale> klr: The syntax and the meaning of that syntax
10:06:46 <mcstar> it usually defines a meaning/behavior
10:06:59 <ski> klr : a language implementation is a way to "realize" a language -- some implementations are interpreters (not to be confused with providing an interactor, i.e. an interactive interface), some are compilers (not to be confused with providing a batch-mode interface) -- some are mixtures (compiling to an intermediate language, then interpreting that at run-time)
10:07:01 <Cale> klr: But not how to implement that meaning on a particular computer.
10:07:05 <bgamari> tibbe, Any plan for that beyond a dependency on SafeSemaphore?
10:07:20 <tibbe> bgamari: probably look for a replacement
10:07:27 <klr> okey, thanks for the help, sry if it was a bit off-topic
10:07:29 <tibbe> bgamari: for QSem
10:07:33 <Cale> klr: No problem :)
10:07:36 <klr> :)
10:07:37 <watermind> remove would always decrease the Nat in the type,  add would always increase the Nat in the type... but a function that may or may not add an element seems to be impossible to write
10:08:14 <Cale> klr: GHC used to have (and may still have?) a mode where it compiled Haskell code via C.
10:08:19 <apple_user> so Haskell is a programming language, and the Glorious Glasgow Haskell Compiler is just an implementation of the awesome Haskell programming language.
10:08:22 <bgamari> tibbe, Would stm or SafeSemaphore be acceptable dependencies?
10:08:31 <klr> Cale: okey
10:08:31 <bgamari> seems like those are the options
10:08:43 <watermind> ghc -C
10:08:44 <Cale> klr: But it also had to mangle the output of the C compiler on the other end, so it wasn't a pure translation.
10:08:48 <watermind> to compile to C
10:08:50 <Cale> ghc -fvia-C
10:08:54 <Cale> I think
10:09:02 <tibbe> bgamari: I like to keep the numbers of dependencies down, escpecially if we will make very little use of it
10:09:03 <klr> okey, thanks
10:09:14 * hackagebot setenv 0.1.0 - A cross-platform library for setting environment variables  http://hackage.haskell.org/package/setenv-0.1.0 (SimonHengel)
10:09:14 <Cale> oh, maybe -C
10:09:16 <Cale> hmm
10:09:28 <bgamari> tibbe, Understandable
10:09:37 <klr> well, may i ask why people say "haskell is a hardcore language" does it mean it is difficult to learn or just that many good hackers use it?
10:09:57 <klr> or something else ofc
10:10:44 <Cale> klr: I don't know exactly what that person meant. But Haskell isn't used so much in industry yet, so if you know Haskell, you're probably someone who actually cares about programming languages.
10:10:48 <ion> You’ll probably need to ask them what they mean.
10:11:07 <klr> Cale: okey, thanks
10:11:34 <k00mi> klr: its different from the programming languages most people use in many ways so its harder to learn than many other languages since there are a lot of new concepts etc.
10:11:35 <Cale> Few people would be learning Haskell just to get a job, not that there aren't Haskell jobs, but there are way more jobs for, say, Java programmers.
10:11:40 * ski . o O ( `filter : {A : Set} -> {n : Nat} -> (p : A -> Bool) -> (v : Vector A n) -> Vector A (sum (map (\a -> boolToNat (p a)) v))' )
10:12:06 <watermind> Cale: there are also more Java programmers
10:12:15 <watermind> Cale: not to say you aren't right :P
10:12:22 <Cale> watermind: right, and so more competition for the jobs which are available
10:12:34 <klr> hmm, i'm reading "How to design programs" by MIT, it uses scheme for its examples which is functional like haskell? will it assist me to later learn haskell? :)
10:12:50 <ski> klr : probably yes
10:12:56 <klr> ski: cool :)
10:13:07 <ski> it will teach recursion, which is used heavily in Haskell as well
10:13:18 <klr> okey
10:13:21 <apple_user> scheme is multiparadigm actually; those good scheme books like htdp and sicp do introduce lots of functional concepts so it will do you quite well if you want to learn functional programming in general
10:13:25 <ski> (and probably other things as well -- i have only skimmed HtDP a little)
10:13:38 <ion> k00mi: It’s harder to learn than another CLispScript *if* you already know CLispScripts.
10:13:46 <Cale> Haskell isn't any harder to learn than Java in absolute terms, and is significantly simpler than C++, even if you throw in the extensions, I would say.
10:13:53 <Cale> But it is *different*
10:14:07 <klr> I won't touch Java or C++
10:14:08 <apple_user> you won't find some of the newer functional programming constructs like Monads et al in SICP and htdp I guess.
10:14:19 <k00mi> ion: yes, if you know only some form of ML it wont be as hard as learning C
10:14:22 <watermind> ski: that agda signature... we're nowhere near having that in haskell right?
10:14:33 <Cale> Most OO imperative languages are basically reskinnings of each other
10:14:34 <ski> watermind : aye
10:14:37 <watermind> :S
10:14:57 <Cale> and so learning more once you know one of them is pretty trivial, and can be done in a week or two
10:15:06 <ski> watermind : the crucial bit there is having the return type depend on the *value* `v' of the argument
10:15:13 <ski> (and also on `p', of course)
10:15:17 <Cale> Programmers get used to how easy it is to pick up another language which is fundamentally similar to the ones they already know
10:15:23 <watermind> ski: yes I understand
10:15:31 <Cale> and then are startled when Haskell is about as hard as learning to program from scratch :)
10:16:09 <Cale> (because it's not just a reskinning of the same language features, but actually embodies a different approach to writing programs which takes getting used to)
10:16:11 <watermind>  how about simply make types depend on 'values' more complicated than Nat's, e.g. types dependent on Sets?
10:16:14 <ski> watermind : in some cases, if you can change the type of the input to reflect the shape, you can approximate something like this in Haskell (with GADTs ior type families) -- but not generally
10:16:25 <klr> thanks for all answers, have a nice day, i'll maybe come back in the future when i've read and understood htdp :)
10:16:59 * ski was about to tell klr to do come back even before finishing HtDP ..
10:17:17 <watermind> ski: I think I've seen promotion for lists... but sets would be even more complex
10:17:40 <centrinia> What about multisets?
10:17:48 <ski> watermind : i'm not quite sure what you mean by "types dependent on Sets" and "promotion for ... sets"
10:18:34 <watermind> ski: e.g. instead of having Vectors parameterized by a Nat, you could have a list of Nats, which would indicate multiple dimensions
10:19:00 <ski> watermind : so a type parameterized by a list of `Nat's ?
10:19:09 <watermind> ski: yeap,
10:19:13 * ski doesn't see how "sets" enter into that
10:19:15 <zzing> Does anyone know a simple but complete sample of a multimode program using cmdargs?
10:19:21 <watermind> ski: and then, more complicated than that, one parameterised by a Set of Nats
10:19:37 <Cale> haha!
10:19:43 <ski> ok, so you did mean "set" as a value (rather than as a type), then
10:20:09 <Cale> YoungTableau (Set Nat)
10:20:18 * ski idly wonders in which sense zzing intends "multimode"
10:20:22 <Cale> YoungTableau :: Set Nat -> *
10:20:31 <zzing> ski, think darcs / cabal style
10:20:40 <watermind> ski: well kind of, that Nat in haskell is implemented as a type, even though it simulates a value
10:20:43 * ski stares blankly
10:20:44 <zzing> program [verb]    where verb = list, get, put, etc.
10:20:55 <watermind> ski: so I'm a bit lost at which word to pick :P
10:20:59 <ClaudiusMaximus> there was that time i wanted a type-level proof of coprimeness of a list of type-level nats, then i wandered off and did something actually non-insane
10:21:26 <ski> watermind : for a while, i was thinking that maybe you intended `Set' in the Agda sense
10:21:34 <watermind> ski: oh no
10:21:39 <watermind> ski: sorry for the confusion
10:22:13 <clahey> @src Bool
10:22:14 <lambdabot> data Bool = False | True deriving (Eq, Ord)
10:22:17 <clahey> So cool!
10:22:20 <clahey> @src Eq
10:22:21 <lambdabot> class  Eq a  where
10:22:21 <lambdabot>     (==), (/=)   :: a -> a -> Bool
10:22:26 <ski> clahey : how so ?
10:22:44 <Cale> The @src command just reads from a text file :)
10:22:57 <clahey> I wasn't impressed by @src, but by haskell.
10:22:59 <Cale> ah
10:23:05 <Cale> The fact that Bool isn't built in?
10:23:09 <clahey> Yeah.
10:23:12 <clahey> == isn't built in.
10:23:24 <Cale> Well, it is *kinda* built in, in that syntax desugars to it :)
10:23:33 <clahey> When?
10:23:43 <Cale> It's involved in guards and if/then/else
10:23:50 <Cale> and n-patterns
10:23:51 <Cale> like
10:23:53 <Cale> f 0 = 1
10:24:02 <Cale> will use == to test if the number is 0
10:24:19 <ski> clahey : `if <condition> then <consequent> else <alternate>' desugars to `case <condition> of True -> <consequent>; False -> <alternate>'
10:24:44 <clahey> So, they're both there in desugaring contexts.  Fair enough.
10:24:56 <apple_user> given a List [a], how do I define a function that returns another [a] containing k randomly-selected elements of the original list?
10:25:08 <bgamari> Cale, Is that true? I always thought pattern matching was distinct from (==)
10:25:12 <clahey> Cale: So if I define == on my type to be within a margin of error, I can do f 0 1 ?
10:25:20 <clahey> Cale: So if I define == on my type to be within a margin of error, I can do f 0 = 1 ?
10:25:21 <Cale> bgamari: In general, it's distinct, but not in that one special case.
10:25:27 <bgamari> Cale, ahh
10:25:38 <ski> apple_user : maybe randomly permute it, and `take k' on the result ?
10:25:38 <clahey> Cale: What is the case?  Number literals?
10:25:44 <clahey> Cale: Or 0 specifically?
10:25:49 <Cale> Yeah, matching against a numeric literal
10:25:54 <apple_user> ski: good idea
10:26:07 * ski supposes there's probably a more efficient way, if `k' is small compared to the number of elements
10:26:08 * bgamari just likes to think of Int as data Int = ... | -2 | -1 | 0 | 1 | 2 | ...
10:26:12 <aya> hey anywhere i can find sth like cheetsheet ? it seems i cant even remember most stupid func names.
10:27:31 <bgamari> aya, sth?
10:27:42 <aya> something
10:27:43 <geekosaur> 'something;
10:27:57 <ski> clahey : generally, you should only have `x == y' evaluating to `True' when `x' and `y' are supposed to be indistinguishable
10:27:58 <clahey> apple_user: take k . sort $ zip [random doubles..] list
10:28:03 <bgamari> aya, haddock?
10:28:14 <clahey> ski: Generally, but the compiler would allow it.
10:28:23 <ski> clahey : s/sort/sortBy fst/
10:28:25 <clahey> ?
10:28:26 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/Prelude.html -- if you open the synopsis, or fold up the insanely long lists of instances, this is pretty good to start with
10:28:29 <bgamari> clahey, Yes
10:28:40 <Cale> http://www.haskell.org/onlinereport/standard-prelude.html -- or perhaps this
10:28:53 <clahey> ski: Right, cause otherwise a needs an Ord, even though it will basically never get called.
10:29:00 <ski> clahey : yes, but you'll break preconditions of some operations if you don't follow the laws that come with classes
10:29:12 <clahey> ski: Fair enough.
10:29:12 <Cale> http://www.cs.utep.edu/cheon/cs3360/pages/haskell-syntax.html is a nice tour of the syntax
10:29:18 <clahey> ski: But 0 == -0, for example.
10:29:19 <bgamari> clahey, the correct way to do this would probably be to define, class ApproxEq a where (~=) :: a -> a -> Bool
10:29:23 <Cale> sort of cheatsheety
10:29:33 <ski> > -0
10:29:35 <lambdabot>   0
10:29:47 <aya> that will do, thanks
10:29:48 <clahey> > -0.0
10:29:49 <lambdabot>   -0.0
10:29:51 <mysticc> Not relevant to haskell but what do you use to draw diagrams (mainly charts) for a paper etc
10:29:55 <clahey> > -0.0 == 0.0
10:29:56 <lambdabot>   True
10:29:59 <ski> clahey : because (as values of type `Integer'), they're indistinguishable
10:30:09 <ski> clahey : `Float' and `Double' are awkward, yes
10:30:20 <clahey> That's pretty standard though.
10:30:25 <clahey> > 1.0/ 0.0
10:30:27 <lambdabot>   Infinity
10:30:27 <bgamari> myme, in the case of haskell I would use diagrams?
10:30:33 <bgamari> mysticc, ^
10:30:41 <Cale> mysticc: If I wanted to be super fancy and professional, I would use TikZ
10:30:46 <clahey> > 1.0/ -0.0
10:30:47 <lambdabot>   Precedence parsing error
10:30:47 <lambdabot>      cannot mix `GHC.Real./' [infixl 7] and prefix...
10:30:49 <bgamari> mysticc, but realistically, for plotting I use matplotlib
10:30:52 <clahey> > 1.0/ (-0.0)
10:30:53 <lambdabot>   -Infinity
10:31:01 <Cale> mysticc: But for most of my diagrams, I use inkscape.
10:31:18 <clahey> For plotting, right now, I would use octave cause that's what I'm up on.
10:31:19 <bgamari> mysticc, The Haskell Chart library is nice, but isn't quite as intuitive
10:31:21 <clahey> Or gnumeric.
10:31:31 <Cale> mysticc: For special classes of diagrams, there are often TeX/LaTeX packages for generating them
10:31:54 <Cale> Like, if you need category theoretic diagrams, there are a couple of major packages
10:32:19 <mysticc> Cale: I am just making a report for a class project so I will not bother to write code to generate diagrams. Thanks for inkscape.
10:36:29 <clahey> Is there something with the type Monad m => a -> m a that causes missing pattern matches call fail instead of error?
10:36:50 <clahey> If that makes any sense?
10:36:59 <Cale> mysticc: yeah, once you get used to it, TikZ is easier than you'd think to produce diagrams which look really nice, but there is a fair sized learning curve
10:37:13 <c_wraith> clahey: no.  that's part of do-notation desugaring
10:37:24 <bgamari> clahey, sadly, no, it's just special cased
10:37:36 <Cale> fail shouldn't really be there :(
10:37:47 <bgamari> clahey, many people regard this as a large blemish on the language
10:38:08 <Cale> I want to go back to Haskell 1.4's translation of the do notation
10:38:14 <Cale> using MonadZero
10:38:19 <clahey> c_wraith: Huh?
10:38:25 <Cale> I also want to split up MonadZero and MonadPlus again :)
10:38:44 <clahey> What's wrong with fail?
10:38:47 <monochrom> do-notation inserts the call to "fail"
10:38:56 <Cale> clahey: It's not formally part of the definition of a monad
10:39:10 <Cale> clahey: and many monads don't have any reasonable way to support that operation
10:39:20 <monochrom> and I want to split up "formally" and "mathematically"
10:39:21 <Cale> clahey: apart from just calling error
10:39:34 <Cale> monochrom: okay okay
10:39:40 <clahey> monochrom: So if I'm in do-notation, any missing patterns will just call fail?
10:39:45 <monochrom> yes
10:39:48 <simon> Cale, mysticc: I prefer dot->tikz so I can specify graphs using dot and compile it to tikz because it looks nicer. there's even a LaTeX environment for transparent compilation.
10:39:50 <Cale> monochrom: It's formally part of the definition of Monad, but not monad ;)
10:40:40 <clahey> do a <- thing that calls lots of other things and has a missing pattern match at some deep level and it'll be a fail?
10:40:50 <clahey> Or only pattern matches at that do level?
10:40:58 <Cale> simon: I guess that solves the problem of determining coordinates for your vertices automatically.
10:41:38 <clahey> Cale: What monads don't support fail?
10:41:43 <Cale> clahey: Matching against a pattern involving a constructor from a type with more than one constructor (i.e. a failable pattern) should induce a MonadZero constraint
10:41:46 <clahey> Cale: Or more to the point, which shouldn't?
10:41:48 <simon> Cale, I suppose it does. I've never dealt with manually specifying coordinates. maybe there are cases where that is desirable.
10:42:00 * fryguybob prefers diagrams.
10:42:00 <Cale> clahey: (->) e for example
10:42:05 <Cale> clahey: Or  State s
10:42:16 <Cale> clahey: Or  Cont r
10:42:22 <Cale> Or really most monads
10:43:19 <clahey> IO, Maybe, List, ZipList all have sensible versions.
10:43:29 <Cale> ZipList isn't a monad
10:43:33 <Cale> Well...
10:43:34 <clahey> My bad.
10:43:58 <clahey> I just realized that's a difference between IsString and my FromString.
10:44:08 <Cale> also, in the case of Maybe and List, you have to throw away the String parameer
10:44:11 <Cale> parameter*
10:44:17 <clahey> class FromString where fromString :: Monad m => String -> m a
10:44:49 <Cale> Please don't use Monad m constraints as a way to say "this may fail"
10:44:54 <Cale> Use Maybe or Either
10:45:03 <clahey> Cale: Why?
10:45:06 <Cale> Or some more precise type
10:45:26 <monochrom> because the focus of Monad should be on return and >>=
10:46:02 <Cale> and we might just wholesale decide that fail doesn't belong in there someday (hopefully)
10:46:24 <otters> why can't we use error for fail?
10:46:37 <Cale> otters: It is *sometimes* convenient
10:46:51 <clahey> otters: Well, in this case I want to be able to handle the error in some contexts.
10:46:52 <Cale> that pattern matching failures can be handled
10:46:55 <monochrom> because for [] you may like "(x:xs) <- action" to be [], not error
10:46:55 <otters> Oh
10:47:04 <clahey> So, if I use Either, I can still use >>= to chain them together.
10:47:05 <otters> ...I didn't know that was possible
10:47:08 <clahey> Or do notation.
10:47:28 <Cale> But I think it should induce a MonadZero or MonadFail constraint or something to use that feature
10:47:42 <Cale> and in other monads, it should just not compile
10:47:45 <clahey> Cale: Would MonadFail be a reasonable class constraint there?
10:47:48 <Cale> yes
10:48:09 <Cale> And for matching against things like (x,y) you wouldn't need that
10:48:11 <clahey> Cale: I think I'm going to use Monad for now so I can test in IO in ghci and use Either when I want to handle the errors.
10:48:16 <Cale> because a pattern match against (x,y) can't fail
10:48:21 <clahey> I'm matching against strings.
10:48:26 <clahey> fromString "L" = return Left
10:48:31 <clahey> fromString "R" = return Right
10:48:38 <Cale> why the return?
10:48:40 <clahey> fromString _ = fail "Unrecognized Direction"
10:48:42 <Cale> er
10:48:49 <Cale> heh
10:48:59 <Cale> fromString "L" = Right Left
10:49:04 <Cale> fromString "R" = Right Right
10:49:16 <otters> :t Right Right
10:49:17 <apple_user> anyone here tried writing a BF interpreter in haskell?
10:49:17 <Cale> fromString _ = Left "Unrecognised direction"
10:49:18 <lambdabot> forall b a a1. Either a1 (b -> Either a b)
10:49:24 <otters> :t Right Left
10:49:26 <lambdabot> forall a b a1. Either a1 (a -> Either a b)
10:49:32 <clahey> I'll change the name.
10:49:57 <clahey> Cale: Which is equivalent if I do fromString "L" :: Either Direction
10:50:06 <Cale> clahey: It's also nice to tell your users which kinds of error they can expect
10:50:15 <clahey> Cale: Huh?
10:50:21 <clahey> Oh.
10:50:25 <clahey> Either String Direction
10:50:27 <Cale> yeah
10:50:39 <clahey> :t fail
10:50:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
10:50:44 <ski> `Either MyError Direction' is better
10:50:49 <clahey> @src Either fail
10:50:50 <lambdabot> fail msg      = Left (strMsg msg)
10:51:05 <clahey> :t strMsg
10:51:06 <lambdabot> forall a. (Error a) => String -> a
10:51:11 <otters> Oh, that's what fail is for
10:51:15 <Cale> Those definitions are from the MTL
10:51:27 <ion> @src strMsg
10:51:28 <lambdabot> Source not found.
10:51:30 <Cale> and its old instance for Either
10:51:46 <Cale> I'm pretty sure that doesn't match the current instance anymore...
10:52:20 <clahey> Cale: So, I understand how this doesn't match the mathematical definition of monad and isn't useful for a bunch of the Monads.
10:52:28 <clahey> But why is it bad from a practical point of view?
10:52:29 <Cale> yeah, that one induced an Error e constraint
10:52:40 <Cale> and the one in Control.Monad.Instances doesn't
10:52:46 <Cale> instance [safe] Monad (Either e)
10:53:08 <Cale> and as such, it's not going to do the same thing with fail
10:53:27 <Cale> ghci> fail "hello" :: Either String Integer
10:53:27 <Cale> *** Exception: hello
10:53:38 <clahey> Oh, Either just calls error anyway?
10:53:39 <Cale> you just get an exception now
10:53:40 <ski> clahey : you might not want a `String' littering your `MyError' type
10:53:41 <Cale> yes
10:53:45 <clahey> Ick.
10:53:59 <clahey> ski: I'll type it for now.
10:54:01 <Cale> Well, think about it, it's either that, or throw away the error message
10:54:04 <clahey> type as in typedef.
10:54:18 <Cale> The reason that Either exists is to universally handle this sort of thing though
10:54:39 <ski> (clahey : "it" being ?)
10:54:53 <clahey> ski: type MyError String
10:55:01 <clahey> ski: That way I can change it later if I wish.
10:55:21 <clahey> Okay, I'm happy using Either as long as I can still use >>= to string them together.
10:55:27 <clahey> Or do notation.
10:55:30 <Cale> yeah
10:56:29 <Phlogistique> j
10:56:34 <Phlogistique> oops
10:56:46 <Cale> clahey: At some point in the future, many of us would like to see fail removed from Monad, and so the more code which exists that makes direct use of fail, the harder that becomes.
10:57:00 <GrandAyatullaah> Cale, I feel that lisk falls apart at (== a b c d) though
10:57:10 <GrandAyatullaah> maybe how that stuff is extended should depend on the type of the operation and the operants?
10:57:20 <Cale> Why is it that every time you speak, you have a new nick?
10:57:34 <GrandAyatullaah> Like, extend a -> a -> a in a particular way and a -> a -> Bool in another?
10:57:36 <clahey> Cale: Fair enough.
10:57:48 <GrandAyatullaah> Cale, that is because I change it every 30 minutes or so if not less.
10:57:55 <GrandAyatullaah> Why is itr that every time you speak you have the same one/
10:58:07 <Cale> Because Cale is my actual name.
10:58:19 <clahey> GrandAyatullaah: So that we can have the illusion of him being the same person each time.
10:58:45 <GrandAyatullaah> clahey, ilussions I say! Even as we speak he's constantly exchanging atoms for new ones.
10:59:13 <clahey> GrandAyatullaah: I do think there is something of a maintained pattern though.  Though even that changes over time.  It just changes continuously.
10:59:14 <GrandAyatullaah> In a couple of months about 90% will have been exchanged, and styill the same nick, trickery and fraud.
10:59:26 * monochrom thinks perhaps you're randomizing your nick modulation to avoid Borg assimilation
10:59:35 <clahey> lol
10:59:39 <GrandAyatullaah> They'd adapt
10:59:48 <clahey> Yes, nicks are quite similar to shield frequencies in that way.
10:59:56 <GrandAyatullaah> I love the technobabble in Voyager "Mr, remodulate our shieldS!"
11:00:28 <GrandAyatullaah> "Oh no, the borg have hacked in and found the pattern by which we remodulate our shields!" "Remodulate that too." "The system won't let us!" "Override it!"
11:00:41 <clahey> Cale: So, is it possible to define type classes with parameters?
11:00:42 <mcstar> thats stupid
11:00:47 <mcstar> GrandAyatullaah: and offending
11:00:50 <clahey> Cale: So "MonadFail ErrorType"?
11:01:01 <GrandAyatullaah> mcstar, is it?
11:01:15 <mcstar> voyager is a bad spinoff
11:01:37 <Cale> clahey: it is possible. You can even add type synonyms alongside the methods
11:01:49 <Cale> (using the TypeFamilies extension)
11:02:06 <GrandAyatullaah> mcstar, Voyager is hilarious for taking treknobabble to the very extremes.
11:02:14 <Cale> class MonadFail m where
11:02:22 <GrandAyatullaah> 99% of problems is solved by firing a condensed tachyon pulse through the deflector array or soemthing like that
11:02:30 <Cale>   type ErrorType m
11:02:43 <Cale>   fail :: ErrorType m -> m ()
11:03:42 <ion> grandayatullaah: Related: http://youtu.be/tDEzKvScglM
11:03:50 <clahey> So Either ErrorType would be a MonadFail ErrorType
11:04:12 <clahey> Yeah?
11:04:13 <Cale> The problem with Star Trek is that they find all these nifty gadgets in their travels and then in future episodes, 90% of the time, they forget that they acquired those technologies.
11:04:36 <clahey> Or, rather Either ErrorType would be a MonadFail with ErrorType ErrorType.
11:05:05 <Cale> instance MonadFail (Either e) where
11:05:12 <Cale>   type ErrorType (Either e) = e
11:05:19 <Cale>   fail = Left
11:05:25 <mcstar> if Haskell also had a pickard syntax besides data, id call it a close to perfect language
11:05:28 <clahey> And why is this not the case today?
11:05:50 <clahey> Pickard syntax?
11:05:57 <ion> Jean-Luc?
11:06:08 <Cale> clahey: Because this type involves an extension which first came into being in a relatively recent GHC.
11:06:09 <GrandAyatullaah> ion, ahaha, yeah, they actually write [tech] in the script, I saw them
11:06:10 <mcstar> yeah, maybe for dependent types, who knows
11:06:18 <mcstar> also, data should be more powerful than pickard
11:06:25 <dmwit> ugh
11:06:29 <dmwit> Picard
11:06:35 <mcstar> hm, i suggest replacing 'type' with 'pickard'
11:06:36 <clahey> Picard.
11:06:47 <ion> Engage!
11:06:48 * dmwit high fives clahey
11:07:08 * dmwit sed s/main/picard/g **/*.hs
11:07:09 <clahey> Hence my assumption that it must be some type theory term I don't know.
11:07:11 <Cale> If an analytic function f(z) has an essential singularity at a point w, then on any open set containing w, the function f(z) takes on all possible complex values, with at most a single exception, infinitely often.
11:07:37 <Cale> I should replace those f(z) by f
11:07:54 <clahey> Yeah.
11:08:12 <mcstar> oh, i missspelled picard
11:08:26 <clahey> If a complex analytic function f has ...
11:08:30 <mcstar> silly me, i do like the series though, i hope you dont think im an impostor or anything...
11:08:40 <mcstar> watched whole TNG 2 times
11:08:42 <clahey> mcstar: It's questionable.  :-P
11:08:48 <clahey> Ah, I just finished my third time.
11:08:54 <clahey> I'm watching all of Star Trek.
11:08:56 <clahey> All the Trek.
11:09:03 <zomg> clahey: including the cartoon?
11:09:05 <clahey> In appx release order.
11:09:09 <clahey> zomg: Oh yes.
11:09:11 <zomg> haha
11:09:16 <zomg> that's the only one I haven't watched!
11:09:20 <ion> http://heh.fi/startrek
11:09:31 <clahey> zomg: I haven't watched large portions of Voyager or Enterprise.
11:09:32 <ion> zomg: It’s horribly awesome, or awesomely horrible.
11:09:47 <clahey> Before this, I had missed bits of TOS and TAS.
11:09:48 <mcstar> i dont really want a star trek without data
11:10:16 <mcstar> clahey: i only watched the movies, TNG and Enterprise
11:10:26 <clahey> I'm at 1994-10-31 or so.
11:10:27 <mcstar> and some seasons of voyager
11:10:30 <zomg> you should definitely watch DS9, along with TNG it's the best
11:10:34 <mcstar> (but i dont like that)
11:10:36 <clahey> I concur.
11:10:45 <clahey> DS9 is greta.
11:10:46 <clahey> great.
11:10:50 <zomg> Enterprise was actually getting better the longer it went on
11:10:53 <zomg> Too bad they canned it
11:11:02 <Cale> If an analytic function f has an essential singularity at a point w, then on any open set containing w, the point f(z) takes on all possible complex values, with at most a single exception, infinitely often. -- better.
11:11:07 <zomg> It was kind of shitty at first but after that they kept building on it a lot
11:11:30 <mcstar> Cale: why are you defining essential singularity?
11:11:38 <Cale> mcstar: hehe
11:12:01 <Cale> mcstar: This theorem is called the Picard theorem.
11:12:15 <mcstar> i thought this was a definitoin
11:12:24 <mcstar> i remember something picard, but dont know what
11:12:24 <Cale> Nope
11:12:49 <Cale> An essential singularity is a singularity which is neither removable nor a pole.
11:13:12 <clahey> zomg: I think that all the Star Treks are like that.
11:13:22 <clahey> It does look like a definition in the wikipedia page.
11:14:07 <zomg> clahey: well Enterprise was the only one I had to really force myself to watch for the first five or so episodes =)
11:14:33 <clahey> God, reading all of this, I keep remembering why I failed complex analysis.
11:14:39 <mcstar> zomg: scott bakula had a terrible acting, also, it was nice to see 'Michael' from atlantis :)
11:14:44 <clahey> Specifically, I just can't be bothered.
11:14:53 <clahey> It's too bad as he was quite good in Quantum Leap.
11:14:57 <Cale> clahey: Can't be bothered to what?
11:14:58 <mcstar> yaeh
11:15:28 <mcstar> to fit the definitions/theorems together and have a complete view of the subject
11:15:33 <Cale> :)
11:15:35 <monochrom> can't be bothered to have exhaustive pattern matching in complex analysis. therefore, fail.
11:16:01 <mcstar> > error "complex analysis, maan!"
11:16:02 <lambdabot>   *Exception: complex analysis, maan!
11:17:04 <Cale> There's also the "Little Picard Theorem" that any entire, non-constant function f: C -> C leaves out at most one point in C in its range.
11:17:19 <typoclass> Cale: make it so?
11:18:00 <MostAwesomeDude> Cale: Even "not"? Or is this a numeric thing?
11:18:16 <Cale> MostAwesomeDude: ?
11:18:17 <clahey> Cale: Care about holomorphic functions.
11:18:29 <MostAwesomeDude> Cale: As in not :: Bool -> Bool.
11:18:33 <dmwit> MostAwesomeDude: not doesn't have the right type, to begin with
11:18:33 <Cale> That point, if it exists, ought to be called the "I just can't do it Captain, I don't have the power" point
11:18:39 <Cale> MostAwesomeDude: C is the complex numbers here
11:18:46 <MostAwesomeDude> Ooh, sorry.
11:18:55 <mcstar> lol
11:18:57 <Cale> MostAwesomeDude: and 'entire' means that the function is differentiable everywhere (in the complex sense)
11:19:11 <MostAwesomeDude> Cale: Okay. Yeah, sorry, I just wasn't on board.
11:19:18 * MostAwesomeDude is this episode's redshirt
11:19:41 <mcstar> thats a mistake comparable to attacking a nausican!
11:19:48 <mcstar> classic picard mistake
11:19:56 <clahey> Cale: Now, Uniform Isomorphisms.  Those I can get into.
11:20:26 <Cale> clahey: More of a real analysis person?
11:20:35 <clahey> Cale: No, not analysis.
11:20:41 <clahey> I eat my corn in rows.
11:21:07 <Cale> (I would have thought by uniform isomorphism that you meant an isomorphism of uniform spaces)
11:21:18 <mcstar> my math teacher was a very smart professor, but couldnt teach dumb smucks like me, and thats why i hate analysis
11:22:44 <mcstar> http://www.math.bme.hu/~jofri/JOFRI/OKTAT/anal.pdf
11:22:53 <clahey> Cale: It's a topology concept.
11:23:00 <mcstar> this was the official lecture note for 2 years of maths
11:23:02 <zomg> anal.pdf... if this wasn't #haskell...
11:23:06 <zomg> lol
11:23:12 <clahey> I like Topology, even though I realize it's probably closer to Analysis than Algebra in some ways.
11:23:19 <mcstar> zomg: yeah, sounds dirty
11:23:23 <Cale> clahey: Well...
11:23:37 <clahey> But it's like algebra in that you're generalizing a concept and seeing what other objects you can apply it to.
11:23:49 <clahey> I never thought about the distinction like that, but it definitely is what I'm into.
11:24:01 <Cale> clahey: I guess you could say that. It's a direct generalisation of a bunch of analytic stuff which you'd normally treat in terms of metric spaces.
11:24:01 <simon> when I try 'cabal update', it asks me to 'cabal install cabal-install'. when I do that (and 65 modules later) and try 'cabal update', it asks me to 'cabal install cabal-install'. I've done this three times now.
11:24:03 <zomg> I'm just going to link that pdf on a few other channels for fun
11:24:04 <clahey> For example, wondering about writing a new type where == means ~=.
11:24:10 <zomg> See if they react to it not being about.. well.. anal
11:24:11 <zomg> lol
11:24:19 <clahey> And wondering what sort of effects that might have.
11:24:35 <clahey> Obviously, it's not a proper implementation of ==, but it was interesting to think about.
11:25:20 <Cale> (I was speaking of uniform spaces there, but I suppose you can consider topological spaces similarly)
11:25:54 <clahey> I could be wrong about the term Uniform Isomorphism.  In all the classes we took, we just called them isomorphisms, but I found that term in wikipedia and it sounded right.
11:26:35 <mcstar> uniform is associated with some limit usually
11:26:45 <mcstar> uniform convergence...
11:26:46 <Cale> With topological spaces, the definition is at the point where it is again simple enough that you can easily see that these things might be nice structures on their own. With uniform spaces, the laws and setup is just elaborate enough that if you lose touch with the idea that this is a slight abstraction of what's going on with metric spaces, I think you'll have a bad time.
11:27:40 <Cale> Though possibly there's a nicer definition that I don't know about :)
11:27:55 <dcoutts> simon: it'll be a $PATH issue, you've probably got a cabal in /usr/bin, and the new one was installed into ~/.cabal/bin
11:28:20 <clahey> God, why was I surprised for a second that people here would know advanced math concepts? Duh!
11:28:31 <simon> dcoutts, yes, I realized. I wonder why my .cabal/bin is even in my PATH, since it isn't in my .zshrc.
11:29:18 * hackagebot safecopy 0.7.1 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.7.1 (DavidHimmelstrup)
11:29:52 <Puffton> What is the prettiest way of building a tree nested in parentheses from a tree of linked tuples?
11:29:58 <Cale> clahey: Even the people here without strong backgrounds in math eventually end up studying category theory.
11:30:22 <mcstar> until you bleed arrows
11:30:47 <Cale> Puffton: I'm not totally clear on what you mean there
11:30:47 <clahey> That's the one issue I have with writing my software in haskell.
11:30:53 <clahey> I don't want it to be hard for other people to hack on.
11:31:48 <Cale> clahey: Well, that's the nice thing about abstractions, is that you can use their instantiations without understanding the more abstract theory surrounding those.
11:31:52 <mcstar> clahey: write an easy to use, dsl, with imitated mutation
11:31:53 <typoclass> simon: i bet it's in ~/.zlogin. i think if you would put it in .zshrc and started a zsh from within a zsh, you'd have the stuff appended twice to PATH
11:32:14 <simon> typoclass, yes I will. I'll look in .zlogin.
11:32:44 <clahey> dsl?
11:32:48 <clahey> Domain specific language.
11:33:00 <mcstar> yeah
11:33:02 <clahey> typoclass!  Awesome!
11:33:30 <typoclass> clahey: not sure what i did, but you're welcome :)
11:34:05 <Puffton> Cale, [(a,v1), (b,v1), (v2,v1), (d,v2)] -> (a,b,(v2(d)))
11:34:08 <Puffton> something like that
11:34:16 <Puffton> from "linked" tree to "nested" tree
11:34:40 <mcstar> a list is a nested constructor
11:34:43 <clahey> typoclass: It's just an awesome nick.
11:34:50 <Puffton> "a is child of v1" etc. (v1 being the root in this case)
11:34:51 <Cale> of course, not every set of pairs is going to work out nicely there
11:35:06 <clahey> Far from it.
11:35:09 <nejucomo> clahey, typoclass +1
11:35:20 <Puffton> root case is a triple, followed by pairs
11:35:21 <Cale> Puffton: and of course you can't really hope to get a nested bunch of tuples
11:35:21 <mcstar> clahey: Am i dead?
11:35:31 <clahey> mcstar: Huh?
11:35:36 <Cale> Puffton: But you could get an element of some tree datatype
11:35:45 <Cale> Let's suppose that we have
11:35:56 <Cale> data Tree a = Node a [Tree a]
11:35:56 <mcstar> clahey: oh, i thought we are playing: you quote the answer, i quote the question form the matrix
11:36:13 <clahey> mcstar: A good game.
11:36:14 <Puffton> But this isn't supposed to be general purpose, just for a specific problem
11:36:25 <Puffton> I have a tree that I have created and I need to display it in newick-form
11:36:34 <clahey> No, I was just suggesting that the number of lists of pairs that resolves to a tree is super tiny.
11:36:56 <Cale> and we want to write an operation  makeTree :: a -> [(a,a)] -> Tree a
11:37:06 <clahey> Puffton: What are a, b, v1 and so forth/
11:37:07 <clahey> ?
11:37:14 <clahey> Puffton: Can we use (==) on them?
11:37:17 <Cale> oh
11:37:19 <Puffton> vertices
11:37:22 <Puffton> (strings)
11:37:31 <Cale> Puffton: So your trees only have values at the leaves, okay
11:37:41 <Puffton> Cale, 1 min, I will show you my code
11:37:47 <Cale> data Tree a = Leaf a | Branch [Tree a]
11:37:55 <Cale> Let's use that then
11:38:08 <Cale> You can easily see how to convert such a thing to an appropriate String
11:38:09 <Puffton> http://hpaste.org/75715
11:38:48 <Puffton> I'm making a tree of joined tuples here, that can look like this: [(a,v1), (b,v1), (v2,v1), (d,v2)]
11:39:01 <clahey> Puffton: Your output above doesn't really make sense.
11:39:15 <clahey> Cale: I think the Branches have values too.
11:39:22 <Cale> clahey: yeah, maybe
11:39:50 <Cale> Though he says he wants Newick form
11:40:01 <Puffton> where v1, v2 are grouping vertices, joining edges a,b,d together
11:40:19 <Cale> Oh, what?
11:40:20 <Puffton> the output is like a linked list, if you see what I mean?
11:40:24 <Puffton>  but with tuples
11:40:25 <Cale> a,b,d are *edges*?
11:40:26 <Puffton> linked tuples
11:40:45 <Puffton> oh sorry, also vertices
11:40:53 <mcstar> do you want the 'real' graph from a list of this specification?
11:40:55 <Puffton> the vertices of interest
11:41:12 <Puffton> no mcstar, I want a string on newick form
11:41:54 <Puffton> [(a,v1), (b,v1), (v2,v1), (d,v2)], a,b,v2 are children of v1, d is a child of v2
11:42:16 <Puffton> so in this tree, if v1 is the root, it has three children
11:42:25 <Puffton> one (v2) of which have a child of its own (d)
11:42:37 <mcstar> ah, 'newick tree format'
11:42:39 <clahey> So, we should build the tree first as a structure and then write out the newick form, I think.
11:42:59 <Cale> clahey: that's what I've been suggesting, yes :)
11:43:07 <Puffton> clahey, but this is a kind of tree, with the tuples, no?
11:43:10 <clahey> Cale: (I know)
11:43:15 <Puffton> I mean at least conceptually
11:43:22 <clahey> Puffton: The problem is tuples aren't named.
11:43:42 <clahey> Puffton: If you're fine with losing the names of the nodes, that's fine.
11:43:52 <mcstar> you can name them
11:43:57 <Puffton> it's ok
11:43:59 <Puffton> I have like
11:44:05 <Puffton> ("human", "monkey")
11:44:17 <Puffton> the only thing I'm interested in here is the string
11:44:18 <clahey> Puffton: Also, a single tuple type can't be extended like this.
11:44:22 <clahey> Neither can lists.
11:44:27 <clahey> They have to hold a specified set of things.
11:44:35 <clahey> You really want your own Tree Format.
11:44:44 <clahey> mcstar: You can't have the string associated in the run time.
11:44:57 <clahey> Puffton: Do you know the root or does the algorithm have to figure it out?
11:45:21 <Puffton> newick is rootless, technically
11:45:47 <mcstar> hm
11:45:50 <Puffton> so I think it can take different shapes
11:45:52 <mcstar> it is like lisp
11:46:00 <clahey> What does it mean for a tree notation to be rootless if the definition of a tree is an acyclic graph with a specified root?
11:46:19 <Puffton> I mean there can be several trees in newick satisfying this tree I have
11:46:51 <clahey> Puffton: But it's definitely a tree in the data?
11:46:53 <Puffton> "When an unrooted tree is represented in Newick notation, an arbitrary node is chosen as its root. Whether rooted or unrooted, typically a tree's representation is rooted on an internal node and it is rare (but legal) to root a tree on a leaf node."
11:47:21 <Puffton> The data is a Map of (String,String)
11:48:25 <Puffton> It's called "unrooted tree" because we don't know exactly where the root should be, biologically, in the newick tree, I think
11:49:05 <clahey> So, mathematically, it might not be a tree, i.e., might not have a root?
11:49:06 <ParahSa1lin> anyone here work with cmdargs?
11:49:18 <Cale> Well, there are unrooted trees in mathematics :)
11:49:21 <Puffton> clahey, like I was trying to say, and like Wikipedia says, it has an arbitrary root
11:49:24 <Cale> They're just graphs with no cycles
11:49:54 <Puffton> i.e. no matter where we decide the root is, it should be fine
11:50:27 <Puffton> but an easy tell is that the top-level has 3 children
11:50:30 <Puffton> all other levels have only 2
11:50:33 <Puffton> at least in this example
11:50:57 <Puffton> (or 1)
11:51:22 <clahey> Puffton is the following true:
11:51:56 <clahey> There exists a node r, such that every node can be reached from r by a set of directed pairs that are in your list?
11:52:31 <Cale> These representations of trees are a subset of  the  standard  adopted  on June  24, 1986 at the annual meetings of the Society for the Study of Evolution at an meeting (the final session in Newick's lobster restaurant  --  hence  its name  --  the  Newick  standard)
11:54:38 <Puffton> clahey, hmm
11:55:57 <clahey> Puffton: If that's true, and if there's no loops, than I can see some ideal algorithms.
11:56:02 <Puffton> I'm not entirely sure I'm following. The tree will be pretty wide (or tall depending on how you look at it) where every grouping vertex vi (v1,v2,v3,?) has 1-2 children except the root that has 3
11:56:06 <mcstar> hm, my first summer!
11:56:08 <Puffton> there are no loops
11:56:59 <MonadDMoore> Cale, okay, say there are two ways to call functions, the old f x and [f x y z] which in some way calls f with all the arguments, let's say that if f :: a -> a-> a then it of course just folds it, say you have f :: a -> b -> Bool then it uses f x y && f y z basically
11:57:14 <kirindave> Has anyone investigated implementing a pattern like lmax's disruptor in haskell?
11:57:19 <MonadDMoore> (f x) is just the same as  f x of course.
11:57:26 <Cale> MonadDMoore: Which way does it fold?
11:57:30 <mcstar>  [("v1",["v2","b","a"]),("v2",["d"])]
11:57:35 <Cale> MonadDMoore: Hopefully to the right!
11:57:37 <mcstar> now put that v2 into its place
11:57:38 <MonadDMoore> Cale, that is the point, I don't know.
11:57:42 <MonadDMoore> Cale, I guess?
11:57:44 <kirindave> Specifically getting a really high performance core for producer with n-step consumers in haskell?
11:57:54 <MonadDMoore> Or maybe you can specify the associativity of that in f itself?
11:58:08 <ski> MonadDMoore : talking about variadic `+',`=' in lisps ?
11:58:09 <MonadDMoore> Since it bascally becomes x `f` y `f` z
11:58:30 <Cale> MonadDMoore: what if the list is empty?
11:58:50 <MonadDMoore> ski, yeah, Cale has gotten on his knees and begged me to make an infix-less Haskell
11:58:53 <MonadDMoore> Cale, you mean [f]
11:58:54 <MonadDMoore> ?
11:58:57 <Cale> lololol
11:58:58 <MonadDMoore> That's just f
11:59:05 <MonadDMoore> It's not a list by the way
11:59:05 <Cale> haha
11:59:08 <MonadDMoore> It's a function call
11:59:12 <Cale> That's terrible
11:59:17 <Puffton> clahey, but since it's a map, I could always do lookups I guess.. i.e. if I get a vx (v1,v2,?) I look up which subtree it is and evaluate
11:59:18 <Cale> It ought to be the identity for f
11:59:22 <Puffton> and gradually evaluate the whole tree
11:59:30 <Cale> and f morally ought to be a monoidal operation
11:59:45 <clahey> @hoogle [(a, b)] -> (a, [b])
11:59:45 <lambdabot> Data.Graph.Inductive.Query.Dominators dom :: Graph gr => gr a b -> Node -> [(Node, [Node])]
11:59:47 <MonadDMoore> Cale, yeah see, that's the point
11:59:54 <MonadDMoore> you can't actually just know what the identity is at comple time.
12:00:07 <clahey> Puffton: I like what mcstar was doing there.
12:00:12 <MonadDMoore> I think [ ...] wih anythig less than 2 arguments should be illegal onetly.
12:00:14 <Cale> MonadDMoore: Which is why we write  foldr f e [x,y,z]
12:00:24 <Cale> MonadDMoore: which is nicely unambiguous
12:00:33 <clahey> Puffton: Though it doesn't quite work right in a mutationless language.
12:00:34 <Cale> while only being a couple more characters
12:00:39 <MonadDMoore> Cale, true, but that's not the point here, the point is to remove infix.
12:00:43 <clahey> What I was thinking was multimap, if that exists.
12:00:59 <mcstar> clahey: called bags
12:01:06 <mcstar> it will work, what i did
12:01:09 <Cale> MonadDMoore: so just remove infix
12:01:16 <Cale> MonadDMoore: No need to invent new syntax
12:01:17 <mcstar> you just need another pass over the map
12:01:20 <mcstar> ill figure it out
12:01:23 <Cale> MonadDMoore: just use list parameters
12:01:31 <Cale> and keep the list syntax
12:02:20 <clahey> mcstar: Bag looks more like set than multimap.
12:02:43 <clahey> http://hackage.haskell.org/packages/archive/Holumbus-Distribution/0.0.1.1/doc/html/Holumbus-Data-MultiMap.html#v%3AfromTupleList
12:03:03 <clahey> :t Holumbus.Data.MultiMap
12:03:04 <lambdabot> Couldn't find qualified module.
12:03:04 <mcstar> clahey: you can always have the values of the map as a list with the actual values
12:03:05 <Cale> Oh but wait a minute, what if comma is too much like an infix operator? OH NO WHITESPACE, THERE'S WHITESPACE IN BETWEEN THINGS
12:03:05 <MonadDMoore> I'm inclined to concur honestly.
12:03:08 <mcstar> if thats what you need
12:03:23 <Puffton> clahey, I also thought about using Data.Map.filter(=="vx")
12:03:44 <Puffton> to get the current vertices that are children of "vx"
12:03:53 <clahey> Puffton: Yes, but slow.
12:03:56 <Puffton> then recursively continue to "v(x+1)"
12:03:58 <MonadDMoore> Just use (+ 1 2) from now on, maybe get special syntax for foldr logic and however you want to call the a == b == c logic
12:04:17 <clahey> Puffton: Oh, actually, not slow.
12:04:18 <Cale> MonadDMoore: (+ 1 2 3) should be a type error
12:04:29 <clahey> Puffton: Maps can only have a single value for a specific key.
12:04:30 <Cale> MonadDMoore: if you want to add more than two things, just use sum
12:04:30 <ski> MonadDMoore : how about `a /= b /= c', what should it mean ?
12:04:38 <clahey> So if you do Map.fromList, you'll lose a bunch of your pairs.
12:04:53 <clahey> Puffton: But do MultiMap.fromTupleList and you'll get exactly what you want.
12:05:01 <Cale> MonadDMoore: Fuck this variadic bullshit, it's pointless
12:05:28 <Cale> and it makes defining things clearly needlessly difficult
12:05:29 <clahey> Puffton: I forgot to ask, is this for programming homework?
12:05:40 <MonadDMoore> (+ 1 2 3) hould not exist
12:05:43 <MonadDMoore> is the point
12:05:56 <MonadDMoore> AT most (((+ 1) 2) 3)
12:05:58 <maukd> > (+ 1 2 3)
12:06:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
12:06:00 <lambdabot>    arising from a use of `...
12:06:01 <MonadDMoore> Whch makes lisp notatin for Haskell useless
12:06:07 <MonadDMoore> Which is why I'm not basing it o that.
12:06:16 <maukd> > (+ 1 2 3) 5
12:06:18 <lambdabot>   6
12:06:22 <Cale> :D
12:06:38 <lightquake> ... wait, what?
12:06:44 <lightquake> > (+ 1 2 3 4) 5
12:06:45 <nand`> hehe
12:06:46 <lambdabot>   6
12:06:54 <Cale> > 1 2 3 4
12:06:55 <lambdabot>   1
12:06:57 <lightquake> oh
12:07:01 <lightquake> it's doing that
12:07:08 <nand`> it's (\x -> x + (1 2 3 4)) 5
12:07:11 <nand`> or 5 + (1 2 3 4)
12:07:14 <Cale> Num instance for functions which makes numeric literals into constant functions
12:07:48 <Cale> So yeah, ((+ 1) 2) 3) should definitely evaluate to 3 ;)
12:07:51 <Puffton> clahey, yes
12:08:00 <Cale> > (((+) 1) 2) 3
12:08:01 <clahey> Puffton: It's for programming homework?
12:08:02 <lambdabot>   3
12:08:05 <Puffton> yes clahey
12:08:26 <Puffton> but I can solve it with successive filtering, that's fine
12:08:27 <clahey> Puffton: I was about to write out my version of the answer, but I think that pointing you to MultiMap should be enough?
12:08:29 <Puffton> it just got a bit messy
12:08:57 <clahey> Puffton: Do it with a recursive list comprehension.  :)
12:09:11 <ski> MonadDMoore : i think the variadic things can appear in several different cases
12:09:35 <ski> MonadDMoore : e.g. it's not clear why one should use `&&' instead of say `||' in "say you have f :: a -> b -> Bool then it uses f x y && f y z basically"
12:09:43 <MonadDMoore> Well, let me put it like this I think abbreviate syntax for comonly repeated logic is a good thing.
12:10:07 <ski> yes, but it's not clear that using the same syntax for conceptually different cases is a good thing
12:10:17 <MonadDMoore> I concur
12:10:24 <Cale> MonadDMoore: Well, that's why we have infix operators. Think of them as the commas for parameter lists to functions which are implied by the name of the comma you're using :)
12:10:48 <Puffton> clahey, but MultiMap, is that part of Haskell natively or something I would have to implement/download?
12:10:49 * ski also happens to think that `a = b = c'-style things are really disguised proofs, rather than propositions
12:10:57 <MonadDMoore> Infix operators are not 'commonly repeated tings', they are completely arbitrary notation for certain functions
12:10:58 <clahey> Puffton: It's a package you can download.
12:11:17 <Cale> MonadDMoore: They're abbreviated notation for certain commonly used functions
12:11:23 <clahey> Puffton: Or implement yourself.
12:11:29 <Puffton> yeah ok, I don't know if I'm allowed to
12:11:34 <Puffton> but multimap seems to do just what my filtering does
12:11:38 <Puffton> although probably faster
12:11:43 <MonadDMoore> Cale, they aren't abreviated, they are just as long!
12:11:54 <Puffton> (i.e. my solution is the slower one)
12:11:56 <Cale> nope!~
12:12:06 <clahey> Puffton: Agreed on that.  The same but faster.
12:12:07 <Puffton> but then I would still have to build the multimap from the map
12:12:09 <Cale> Because of fixity
12:12:10 <MonadDMoore> THey're different for the sake of being different, and some even more common operations are not infix.
12:12:21 <clahey> Puffton: There's a function that takes your exact data structure.
12:12:25 <Cale> which lets you leave out parens
12:12:38 <Cale> making things shorter
12:12:53 <clahey> It would be nice to be able to type if a < b < c then blahdiblah else blahdiblee
12:13:28 <clahey> Puffton: Agreed on that.  The same but faster.
12:13:39 <clahey> Puffton: I tried to install Holumbus-Distribution and it failed.
12:13:46 <Puffton> yeah I was just looking at that
12:14:02 <Puffton> but I think to be safe, I will just stick with native modules
12:14:04 <clahey> Puffton: You could always write a MultiMap meant to be included in ghc itself.  Not sure if that sort of thing happens.
12:14:10 <Puffton> otherwise I could probably find some module that does it all for me :D
12:14:46 <clahey> Possibly.
12:15:20 <Cale> MonadDMoore: just as you might write (* 1 2 3), you could instead write 1*2*3
12:15:41 <Cale> MonadDMoore: you're writing the spaces infix between the elements to your parameter list
12:15:43 <clahey> Puffton: So is this a haskell programming class or some generic class that you chose haskell for?
12:15:54 <Puffton> Programming paradigms
12:15:59 <gabor> mcstar: tehát magyar vagy
12:16:07 <clahey> Puffton: So this is all about functional?
12:16:08 <Puffton> Prolog, Haskell, C, Java or so
12:16:11 <Cale> MonadDMoore: just as you might write asterisks between the elements of your product :)
12:16:16 <mcstar> gabor: szia
12:16:18 <Puffton> Oh, and regular expressions
12:16:30 <clahey> Puffton: Ah, so it's a generic class, but this week is about haskell...
12:16:35 <Puffton> but the major focus and the hard stuff is Prolog/Haskell
12:17:00 <MonadDMoore> Cale, yes, quite consistently, because spaces aren't operators
12:17:15 <MonadDMoore> You don't apply the result of '1 2' to '3' with space being the operator
12:17:22 <Cale> But they kind of are. They're building up these expressions which are being evaluated.
12:17:27 <MonadDMoore> I have nothing against infix notation if everyting s.
12:17:34 <MonadDMoore> Yes, and it' s quite consistent still
12:17:44 <clahey> Cale: But in that case, shouldn't a * b * c be a applied to * applied to b applied to * applied to c?
12:17:49 <MonadDMoore> Because they obviously have nothing to do with +
12:17:54 <MonadDMoore> clahey, mah dog
12:18:05 <Cale> clahey: ?
12:18:15 <zzing> I am trying to do something with persistent in a command line utility, and I am getting an instance error with the second function, that I don't get in the function immediately prior to it.  I don't know why it is happening, any ideas? http://hpaste.org/75716
12:18:17 <MonadDMoore> Put that planetary at Cale's told base
12:18:31 <clahey> Cale: If you're talking about space as an infix operator, that would imply that inserting a space should change the meaning of a statement.
12:18:41 <clahey> a+b is the same as a + b
12:18:51 <clahey> And you can apply without the space, right?
12:18:55 <MonadDMoore> Aww yeah, planetary at the told base
12:18:59 <clahey> (a)(b) does function application no?
12:19:15 <Cale> clahey: I'm not really talking about the lexical syntax
12:19:28 * ski . o O ( "juxtaposition" )
12:19:35 <clahey> I should say, that that one argument not making sense doesn't really mean anything about the overall argument.
12:19:47 <Cale> I'm talking about syntax one level up from this :)
12:20:15 <Cale> I'm also comparing and contrasting two different languages
12:20:30 <clahey> That may all be.
12:20:33 <Cale> (+ 1 2 3) was in scheme or lisp
12:21:03 <Cale> Or whatever Lajjla's favourite language happens to be
12:21:19 <ski> CM, possibly
12:21:20 <Cale> where there's no infix operations and things are variadic
12:21:23 <Lajjla> I hate all languages bout aequally.
12:21:32 <Clint> zzing: explain unpack <$> documentContent <$> entityVal
12:21:32 <Lajjla> variadic is overrated
12:21:44 <Lajjla> infix operations are most unpleasant
12:21:44 <Cale> you also randomly insert 'a' into your words before 'e'
12:21:44 <clahey> I was about to ask MonadDMoore what his argument was all about so I could decide if I thought it made sense overall, but he seems to have gone.
12:21:45 <Cale> :)
12:21:50 <hpaste> “Jonathan Fischoff” pasted “stack trace” at http://hpaste.org/75717
12:22:03 <Cale> clahey: Lajjla is the same person
12:22:03 <Lajjla> clahey, I'm monadicDMoore
12:22:05 <Lajjla> client flipped
12:22:11 <Lajjla> To some exten
12:22:17 <Lajjla> I have exchanged many atoms since
12:22:17 <jfischoff> need help understand this stack trace: http://hpaste.org/75717
12:22:18 <clahey> Okay.
12:22:27 <zzing> Clint,  each one of those unpacks the data structure - pagesInEntity is an m Entity , entityVal gets a Document, documentContent gets back a Text, unpack is a Text -> String
12:22:50 <clahey> Lajjla: Despite the fact that identity is an illusion, it's a useful one.  I concur that the changing nick thing is frustrating.
12:22:51 <clahey> Anyway.
12:23:03 <clahey> Lajjla: What's your overall argument/suggestion?
12:23:05 <jfischoff> first is there an exception occurring that is being caught? Not sure what the reporting due to +RTS -xc means
12:23:28 <jfischoff> also is there a way that I can getter stack trace?
12:23:29 <Cale> jfischoff: Are you running the program with +RTS -xc on the commandline?
12:23:46 <Clint> zzing: so why the <$>'s
12:23:49 <Lajjla> clahey, A: Mathematical textbook notation is terrible for writing mathematics in and is only in common used due to inertia and unwillingnes of people to change. B: Therefore, mathematical textbook notation is a bad strting point for Haskell syntax.
12:24:02 <jfischoff> Cale: most definitely
12:24:08 <apple_user> http://ideone.com/Xaagm is this a closure?
12:24:12 <apple_user> what is a closure
12:24:30 <zzing> Clint, because it is in 'm'  (specific to my backend)
12:24:32 <Cale> apple_user: A closure is a datastructure used in language implementations
12:24:55 <clahey> Lajjla: Okay, a reasonable argument, even if I'm not sure I agree.
12:24:55 <apple_user> http://ideone.com/aICsZ what about this?
12:24:58 <clahey> A -> B makes sense to me.
12:25:02 <clahey> I'm unconvinced of A.
12:25:02 <Cale> apple_user: It consists of a pair of some code with free variables in it, together with an environment mapping some or all of those free variables to values.
12:25:08 <apple_user> ah
12:25:15 <Cale> apple_user: Functions and closures are not the same thing
12:25:18 <ski> Lajjla : mostly agreed
12:25:25 <apple_user> I guess I don't get it :(
12:25:30 <Cale> apple_user: But some people confusingly conflate the two
12:25:43 <Cale> apple_user: because closures are commonly used to implement functions
12:25:45 <Lajjla> ski, hi5 Brohann Sebastian Bach.
12:25:58 <maukd> Cale: I disagree with your definition of "closure", btw
12:26:02 <apple_user> Cale: they are?
12:26:23 <maukd> that's not how the word is used anywhere else
12:26:24 <Clint> zzing: what is in 'm'?
12:26:33 <apple_user> what's a very simple example of a closure in haskell?
12:26:36 <thoughtpolice> whoo, new cabal install builds dependencies in parallel
12:26:38 <thoughtpolice> that's awesome
12:26:51 <dcoutts> @arr!
12:26:52 <lambdabot> Yeh scurvy dog...
12:27:00 <zzing> Clint, I do not know the real type, but it is a Backend abstraction for postgresql
12:27:01 <jfischoff> thoughtpolice: been in using it for awhile and it works great
12:27:02 <Cale> apple_user: It's best not to even use the word closure unless you're talking about a particular implementation of a language at a low level.
12:27:02 <Lajjla> apple_user, f x = \y -> x
12:27:10 <thoughtpolice> dcoutts: i found another bug though, i think :X
12:27:23 <clahey> Lajjla: So what don't you like about mathematical textbook notation?
12:27:32 <Clint> zzing: nono.  pagesInEntity gives (m Entity)?
12:27:35 <dcoutts> thoughtpolice: heh, well file a ticket or reply in the thread about the release.
12:27:47 <Lajjla> clahey, inconsistent, hard to read, often ambiguous, laden with abuse of notation
12:27:49 <thoughtpolice> dcoutts: it seems cabal doesn't like the 'jobs' field in my .cabal/config. specifying -j12 on the command line works beautifully (pandoc installs so fast!) but it's not huge
12:27:50 <zzing> Clint, yes (m being the backend)
12:28:04 <thoughtpolice> dcoutts: right, i'll submit a patch for the other issue too (bootstra.sh is too lax w/ cabal)
12:28:06 <dcoutts> thoughtpolice: ah good since that one we know about and it's fixed in Cabal-1.6.0.1
12:28:12 <thoughtpolice> dcoutts: great
12:28:12 <ski> Lajjla : that is to say, much of the notation used is ok, and much of it isn't
12:28:13 <Clint> zzing: ok, so the type of (unpack <$> documentContent <$> entityVal) should be Entity -> something, right?
12:28:22 <Lajjla> Mathematicla textbook notation is basically the imperial system of measurements
12:28:23 <dcoutts> thoughtpolice: you'll have built using Cabal-1.6.0.0, right?
12:28:35 <Cale> Lajjla is a troll, okay guys?
12:28:36 <maukd> apple_user: your second example could be called a closure
12:28:37 <zzing> I believe    m Entity -> m String
12:28:38 <Lajjla> As in, you have to remember so many things that are arbitrary instead 'Yo, it's times 1000 every time'
12:28:45 <apple_user> right
12:28:50 <thoughtpolice> dcoutts: ah, yeah, it's 1.16.0, not 1.6.0.1
12:28:57 <Lajjla> Cale, ...
12:28:57 <Lajjla> ?
12:29:12 <ski> @quote explode
12:29:12 <lambdabot> RobertXCringely says: If automobiles had followed the same development cycle as the computer, a Rolls-Royce would today cost $100, get a million miles per gallon, and explode once a year, killing
12:29:12 <lambdabot> everyone inside.
12:29:16 <ski> hrm
12:29:21 <Cale> Lajjla: I move that we accept as an axiom that you are trolling.
12:29:23 <ski> @quote they.explode
12:29:24 <lambdabot> Cale says: Here [#haskell], we feed trolls until they explode.
12:29:24 <thoughtpolice> dcoutts: i'll fix that and i'm sure it will work. :) if i submit a patch for that bootstrap.sh tweak, should i make it require 1.16.0.1 at minimum
12:29:29 <thoughtpolice> ?
12:29:34 <Clint> zzing: no, you'd want (fmap (unpack <$> documentContent <$> entityVal)) to be m Entity -> m String
12:29:45 <thoughtpolice> as opposed to 1.16.0
12:29:55 <Cale> Lajjla: We may continue to feed you, because that's what we do in order to generate quotes for later use in bots :)
12:30:13 <nicoo> Cale: This is quote-worthy
12:30:18 <nicoo> Oups, self-reference :o
12:30:27 <Lajjla> ski, what was the original quote of that again?
12:30:31 <Lajjla> I remember that
12:30:37 <ski> Lajjla : not sure
12:30:49 <Lajjla> @quote Kukkua
12:30:49 <lambdabot> Kukkua says: They say there are two things, once mastered, you will harness boundless strength from the cosmos itself, continuations and monads.
12:30:51 <Lajjla> Best quote ever
12:31:27 <apple_user> so a monad is an abstraction of a continuation?
12:31:32 <maukd> wat
12:31:34 <zzing> Clint, I think I will have to do this on paper later then.  The thing that is really bugging me is this:   Expected type: Text -> ghc-prim:GHC.Types.Char      Actual type: Text -> String   Its actual Type is great.  I don't know what is expecting Char
12:31:41 <maukd> how did we get from closures to here?
12:31:51 <mizu_no_oto> apple_user: no, not at all
12:31:52 <Cale> apple_user: Not really, though I could confuse you and try to propose a relationship between them
12:32:26 <ski> Lajjla : much of the (syntactical) problems seem to occur as a result of (syntacitcally) confusing a function with the value of a function in a point
12:32:30 <Clint> zzing: it's because the type of (unpack <$> documentContent <$> entityVal) is not what you intend it to be
12:32:44 <mizu_no_oto> You can implement delimited continuations using a monadic interface.
12:32:47 <ski> (s/it/ti/)
12:32:51 <Lajjla> ski, in mathematical textbook notation?
12:32:58 <nicoo> maukd: Evil will always find a way ;)
12:32:58 <zzing> Clint, any idea why I get that first error when I don't get it in the second last function
12:33:06 <Lajjla> And a lot of abuse o notation does not properly distinguish f from f ( x ) yeah
12:33:10 <ski> mizu_no_oto : you need indexed monads to be able to use the full generality of `shift' and `reset'
12:33:12 <Clint> zzing: because <$> is fmap?
12:33:22 <ski> Lajjla : yes
12:33:45 <Lajjla> (f(x))(y) becomes a bit hard to read, though looks quite mammalian
12:34:06 <Cale> Lajjla: Which is why many mathematicians will just write f x y at that point
12:34:25 <Lajjla> Big O notation is my absolute favourite though, beause 99% of the solutions are still abuses.
12:34:26 <Cale> Or (f x) y
12:34:29 <clahey> Lajjla: How'd you get from there to the discussion of infix operators?
12:34:34 <nicoo> Lajjla: You can wirte f(x)(y)
12:34:37 <nicoo> write*
12:34:38 <ski> Lajjla : as a consequence, we have people writing rubbish like `D (x^2)',`(d f(x) / d x)(x_0)' and `Phi(d / d x)', e.g.
12:34:40 <Lajjla> Obviously it should be f in O(\x.x^2) or something like that.
12:34:41 <maukd> fˣ(y)
12:34:41 <mizu_no_oto> ski: right, my point is, though that monads and continuations have as much to do with each other as monoids and, say, multiplication
12:34:52 <zzing> My brain is spent, and I have to study for a class that is in csh. So I should save my sanity for after that :P  Clint, thank you for your guidance.
12:34:58 <mizu_no_oto> monoids and integers, rather
12:35:09 <Cale> O(x |--> x^2)
12:35:12 <ski> mizu_no_oto : i'm not sure i follow the analogy, but ok
12:35:12 <clahey> mizu_no_oto: Which is to say that monoids are an abstraction of integers.
12:35:12 <Lajjla> ski, indeed, same with big O notation
12:35:27 <nicoo> zzing: Stay pure and there shall be no side-effects ;)
12:35:28 <Lajjla> A lot of people solve it like sayin f(x) in O(x^2)
12:35:29 <clahey> mizu_no_oto: Which is what ski said, no?
12:35:30 <Lajjla> Makes no sense
12:35:39 <mizu_no_oto> No, some of the operations on an integer happen to form monoids
12:35:40 <nand`> monads are abstractions of continuations in that continuations form a monad
12:35:44 <dcoutts> thoughtpolice: no, there's people with ghc-7.6.1 that have 1.16.0.0 already, and we don't want to force an upgrade there.
12:35:48 <nand`> that's about it
12:35:49 <ski> clahey : it is ?
12:35:56 <Cale> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
12:36:07 <Clint> zzing: good luck
12:36:11 <clahey> ski: You said that monads were an abstraction of continuations.
12:36:12 <Cale> ^^ see there for how to make the connection between monads and continuations a little tighter :)
12:36:12 <mizu_no_oto> Similarly, some of the operations on a delimited continuation happen to form a monad
12:36:12 <thoughtpolice> dcoutts: ok, fair enough. i suppose it's a fairly small bug, and most people will have cabal by other means
12:36:13 <zzing> nicoo, Persistent and template haskell ftw
12:36:21 <nicoo> :)
12:36:25 <dcoutts> thoughtpolice: right, the bug only affects the config file, can still use cabal install -j
12:36:33 <clahey> mizu_no_oto: Would you say that a metric space was an abstraction of a euclidean space?
12:36:40 <thoughtpolice> dcoutts: i just point it out because on most of my machines, i use package-provided GHC, or a binary-dist, and use ./bootstrap.sh to only get cabal
12:36:41 <nand`> continuations are just the yoneda lemma for identity functors, what's the big deal?
12:36:44 <thoughtpolice> and go from there
12:36:50 <thoughtpolice> i normally don't get the whole platform. so this is a bit atypical
12:37:09 <clahey> Or that a euclidean space with the standard metric just happens to form a metric space?
12:37:11 <thoughtpolice> (and i use hsenv or whatever to sandbox stuff.) it's not a huge burden, and i just fixed it :)
12:37:19 <thoughtpolice> dcoutts: thanks for all the new features, though :D
12:37:31 <dcoutts> thoughtpolice: you're welcome, not all me though :-)
12:37:33 * ski recommends "Representing Monads" in 1994-01 (and "Representing Layered Monads" in 1999-01) by Andrzej Filinski at <http://www.diku.dk/~andrzej/papers/>, re continuations and monads
12:37:49 <ski> clahey : where did i say that ?
12:39:28 <Cale> There is, by the way, a pretty interesting justification for the confusion of functions and values.
12:39:52 <Cale> Think about things which we ordinarily think of as numbers, such as the temperature.
12:39:54 <clahey> ski: You didn't, apple_user did.
12:40:15 <clahey> ski: But I misread mizu's response to indicate that it was you that had said it.
12:40:21 <clahey> Cale: A function of time?
12:40:30 <Cale> A function of time, and space
12:40:36 <clahey> Right.
12:40:41 <Cale> possibly even a few more things
12:41:17 <clahey> Well, at the quantum level, temperature doesn't really make sense as a concept, so it gets weird.
12:41:21 <clahey> But it's a good example of the idea.
12:41:34 <clahey> In fact, actually.
12:41:34 <Cale> Every element of a set X can also be treated as a function 1 -> X
12:41:46 <Cale> and then function application becomes function composition
12:41:48 <shachaf> Everything is a function!!!
12:41:56 <ski> Cale : yes. the point is to understand that syntactically/conceptually `..x..' and `x |-> ..x..' are different beasts (because different things are in *focus*)
12:42:16 <Cale> If x: 1 -> X and f: X -> Y, then f x: 1 -> Y
12:42:25 <ion> shachaf: In Haskell, everything is a monad!
12:42:28 <clahey> Temperature is a function from a region of space and a time to a value.
12:42:39 <maukd> Cale: I always knew ($) was the same as (.)!
12:42:40 <clahey> You get to be a Monad, and you get to be a Monad!
12:42:43 <Cale> maukd: :D
12:43:07 <clahey> Cale: So x is from unit to X?
12:43:11 <Cale> yes
12:43:14 <clahey> That's what you mean by 1?
12:43:17 <Cale> yes
12:43:22 <clahey> But you can't apply it to something else.
12:43:23 <Cale> 1 can be our one element set
12:43:25 <clahey> x x doesn't make sense.
12:43:28 <Cale> right
12:43:36 <Cale> but now imagine replacing x with something T -> X
12:44:04 <Cale> If x: T -> X and f: X -> Y, then we can still compose and get f . x: T -> Y
12:44:08 <clahey> Cale: I swear, a couple of hours ago, someone on this channel was telling me not to think of variables as functions.
12:44:12 <Cale> :D
12:44:23 <clahey> And I was like, but they kinda are!
12:44:28 <shachaf> Cale: Not if we turn x into 1 -> (T -> X)
12:44:31 <Cale> *kinda*
12:44:38 <maukd> clahey: no, variables are names
12:44:55 <Cale> values of any type are kinda equivalent to functions from the unit type
12:44:55 <shachaf> Then you need a function : (1 -> B -> C) -> (1 -> A -> B) -> (1 -> A -> C) to compose.
12:45:03 <clahey> maukd: True.
12:45:08 <shachaf> Oh not, it just turned into 1 -> (1 -> B -> C) -> (1 -> A -> B) -> (1 -> A -> C)!
12:45:13 * shachaf goes back to -blah
12:45:17 <simon> don't you just call them nullary constructors?
12:45:47 <Cale> So, while it's kind of a bad idea to conflate these things in Haskell, they're really isomorphic
12:46:14 <Cale> Haskell doesn't admit a really proper unit type, though I suppose you could awkwardly use Void :D
12:46:27 <Cale> (which has one more element than its name suggests)
12:46:44 <ion> what what in the bottom
12:46:51 <Cale> Morally, you could use ()
12:46:58 <shachaf> Morally, you could use Void
12:47:16 <maukd> :t undefined :: 1
12:47:17 <lambdabot> Unit
12:47:34 <djahandarie> :t undefined :: 0
12:47:35 <lambdabot> Only unit numeric type pattern is valid
12:48:04 <shachaf> Apparently that's a kind error in a newer GHC with type nats.
12:48:16 <Cale> The definition of function composition then becomes the associativity of function composition :D
12:48:47 <Cale> i.e. if you're identifying composition and application, then (f . g) x = f (g x)
12:48:58 <Cale> becomes the same thing as (f . g) . x = f . (g . x)
12:49:04 <MostAwesomeDude> @pl \c -> scanl brot c $ repeat c
12:49:04 <lambdabot> ap (scanl brot) repeat
12:49:13 <MostAwesomeDude> Hmmmm. That's too much.
12:49:19 <mcstar> Puffton: did you get a solution?
12:49:26 <Cale> Something which is really interesting about this idea of a generalised element
12:49:45 <ski> Cale : .. but sometimes we need to distinguish isomorphic things :)
12:49:45 <Puffton> mcstar, my head knows how to solve it, but I can't seem to nest tuples dynamically?
12:49:47 <Cale> i.e. thinking of a map T -> X as a T-generalised element of X, rather than as a function
12:50:01 <mcstar> Puffton: why do you want tuples???
12:50:05 <mcstar> i mean in haskell
12:50:11 <Cale> is that many definitions which work in set theory don't quite nicely categorify
12:50:20 <Cale> *unless* you use generalised elements
12:50:25 <mcstar> isnt it enough, to have them nicely parenthesized as a strin?
12:50:25 <Puffton> mcstar, you suggest I use some kind of parsing instead?
12:50:28 <mcstar> string*
12:50:29 <Puffton> yeah it is
12:50:34 <ski> (`A * B' is iso to `B * A' -- now by which iso is `A * B * A' iso to `B * A * A' ?)
12:50:34 <Puffton> I thought it would be prettiest by building it
12:50:40 <Cale> For example, what is the Cartesian product in set theory?
12:50:42 <Puffton> and then doing "tshow tuples"
12:50:43 <shachaf> thoughtpolice: Are there named holes?
12:50:50 <Puffton> "show tuples" to make it string
12:50:59 <mcstar> Puffton: http://sprunge.us/EhTd
12:51:38 <Puffton> but you are building a tree separately, it feels like an overkill? :/
12:52:37 <mcstar> Puffton: you need to know if its a leaf or a branch
12:52:59 <mcstar> a,b,c is a leaf
12:53:04 <mcstar> v1,v2 is a branch
12:53:06 <Puffton> mcstar, but all branches are called "vx" and all leaves are called something else
12:53:26 <mcstar> Puffton: then write a little function that makes from your input a tree
12:53:27 <thoughtpolice> shachaf: not yet
12:53:28 <Puffton> but yes, if someone freaked out and named a leaf "v5" it could complicate things
12:53:30 <mcstar> not tree
12:53:34 <mcstar> but a list of little trees
12:53:41 <thoughtpolice> shachaf: i think they're on the roadmap. they were in the original patch i think, as well as actual holes inside types
12:53:53 <mcstar> Puffton: its very easy
12:53:58 <mcstar> i can do it for you
12:54:07 <thoughtpolice> but i guess spj just went forward with the simplest implementation, leaving extensions for later
12:54:09 <shachaf> thoughtpolice: Hooray!
12:54:21 <ski> Puffton : try `data T a = O a | D (T (a,a))' with `(D . D . D . O) (((0,1),(2,3)),((4,5),(6,7))) :: T Integer' ?
12:54:32 <thoughtpolice> i imagine they'll probably get better before HEAD becomes 7.8
12:54:37 <mcstar> Puffton: what was your input list?
12:54:39 <thoughtpolice> so far they've been quite handy though
12:55:37 <thoughtpolice> wow, it's pretty crazy how much of a difference cabal -j is actually making on my 12 core machine
12:55:38 <Puffton> This is actual output mcstar
12:55:40 <Puffton> [(\"FOXP4_COW\",\"v3\"),(\"FOXP4_DOG\",\"v3\"),(\"FOXP4_FROG\",\"v2\"),(\"FOXP4_HUMAN\",\"v4\"),(\"FOXP4_MOUSE\",\"v1\"),(\"FOXP4_RAT\",\"v1\"),(\"v1\",\"v2\"),(\"v2\",\"v4\"),(\"v3\",\"v4\")]
12:55:45 <Puffton> With escaped strings, but still
12:55:54 <thoughtpolice> maybe i don't care about parallel ghc --make as much as i thought :P
12:56:06 <shachaf> thoughtpolice: cabal -j?
12:56:18 <shachaf> Is that cross-package or cross-module?
12:56:21 <thoughtpolice> shachaf: cabal 1.16 (released today) installs package dependencies in parallel
12:56:27 <shachaf> Oh. :-(
12:56:30 <thoughtpolice> only dependencies, modules inside a package are still serial
12:56:32 <shachaf> Doesn't help you when you've got a big program.
12:56:42 <thoughtpolice> it significantly helps for some things though
12:56:50 <thoughtpolice> like, text isn't really that big, but it takes a hell of a long time to compile
12:57:01 <thoughtpolice> so overlapping other compiles right there is a huge win
12:57:17 <Puffton> ski, you mean sucessively pairing?
12:57:34 <thoughtpolice> installing pandoc with all its deps is < 4min for me now, it seems
12:57:58 <ski> Puffton : don't listen to me, i don't know what you're trying to do. i just saw your "nest tuples dynamically" and reacted :)
12:58:01 <shachaf> thoughtpolice: What's blocking ghc -j?
12:58:04 <thoughtpolice> but it won't help e.g. darcs as much, which has a muc more shallow dependency chain, and a lot bigger library
12:58:17 <maukd> shachaf: global variables
12:58:23 <thoughtpolice> shachaf: i think there's just a bit of global mutable state inside GHC. also, ghc --make is often faster than even a makefile+multiple GHCs
12:58:34 <thoughtpolice> because ghc --make caches interface information during compilation, and ghc -c doesn't do that
12:58:38 <watermind> I don't understand why the unary ¬ symbol is a 'problem' when we have similar exceptions for the unary - symbol in place already... http://www.haskell.org/haskellwiki/Unicode-symbols#UnicodeSyntax
12:58:44 <shachaf> maukd: I saw a patch that converted a bunch of IORefs to MVars.
12:58:54 <shachaf> For FastString etc.
12:58:55 <thoughtpolice> so you need parallelism of at least like 3x before you can even get a better build time
12:58:56 <shachaf> Are there others?
12:59:04 <thoughtpolice> according to neil (who authored shake)
12:59:10 <maukd> watermind: because 2 is not 0, 1 or ∞
12:59:22 <shachaf> thoughtpolice: That's with multiple GHCs, but a single ghc -j could be smarter?
12:59:32 <watermind> maukd: what?
12:59:36 <Puffton> ski, yeah but I tried recursively doing something like that, where some tuples are (String,String) and some are (String,*tuple of something*)
12:59:40 <thoughtpolice> possibly, just parallelizing ghc --make would cover most of the use cases, but yeah, global state
13:00:04 <ski> Puffton : in my `T Integer' case, the "depth" of the tree has to be the same everywhere
13:00:18 <Puffton> it's not here
13:00:24 <thoughtpolice> shachaf: i think nominolo was the last person to really look into it
13:00:27 <thoughtpolice> but i may be wrong there
13:00:44 <ski> (it's possible to lift this restriction, but i'm not sure that the cure is not worse)
13:01:06 <shachaf> thoughtpolice: I saw an issue on the GHC Trac that didn't seem to be blocking on anything in particular.
13:01:21 <ski> Puffton : maybe you should state what you're trying to do
13:01:39 <monochrom> ¬ is not a problem, if Haskell 2010 grammar adds it as a unary operator
13:01:44 <typoclass> watermind: as far as i can tell, the problem is that ghc treats ¬ as a symbol, i.e. it's infix by default (like + or / or whatever). in order to make it prefix, you have to put it in parens
13:01:51 <thoughtpolice> shachaf: i'm not aware of all the details these days honestly, but i was under the impression it was still the case. maybe worth bringing up in #ghc
13:02:10 <shachaf> I brought it up in #ghc once. Silence.
13:02:19 <shachaf> Silence is pretty standard in #ghc, though.
13:02:37 * ski . o O ( "silence is golden" )
13:02:39 <apple_user> :t groupBy
13:02:40 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
13:02:43 <thoughtpolice> there's a pretty large timezone spread in there i think, to be fair :P
13:02:45 <typoclass> watermind: in other words, you can't do that by simply making a package that has a function with a funny name. you have to change the language (cf what monochrom said)
13:02:50 <thoughtpolice> especially given the # of people
13:03:01 <Puffton> ski, convert a tree created by linked tuples to a newick tree (essentially nested tuples where the root is a triple)
13:04:00 <ski> Puffton : so, why not use an ordinary algebraic data type with one constructor for each case, taking as many arguments as you need subtrees (plus in-node elements, if any) ?
13:04:34 <Puffton> ski, but that feels ugly, no? that is hard-coding scenarios
13:06:45 <ski> Puffton : not sure ? (i don't know how your two tree types there look like)
13:07:09 <Puffton> [(a,v1),(b,v1),(c,v1)] == (a,b,c)
13:07:14 <Puffton> a, b, and c are children of v1
13:07:55 <Puffton> [(a,v1),(b,v1),(v2,v1),(c,v2),(d,v2)] == (a,b,(c,d))
13:09:02 <Puffton>  a, b and v2 are children of v1, c, d are children of v2
13:09:46 <ski> sounds like you want `data Tree a = Node a [Tree a]' (see `Data.Tree') ?
13:10:55 <Puffton> "The module Data.Tree could be tempting to use, but it is unnecessarily complex for this problem" it says in my notes :/
13:11:39 <Puffton> (from my teacher)
13:11:54 <aristid> Data.Tree is "complex"?
13:12:03 <Puffton> It is my teachers notes on this problem
13:13:49 <Puffton> well, it says "Unnecessarily complicated to use for this problem", if I am to translate it properly
13:14:14 <Cale> Puffton: there are a few problems with this description you're giving... I understand what you want, but there's an issue with how you're writing it which if cleared up will hopefully make the problem a little easier to solve
13:14:43 <Cale> [(a,v1),(b,v1),(v2,v1),(c,v2),(d,v2)] -- here all the pairs are pairs of variables
13:14:53 <Cale> and it's not clear what type of value those variables are bound to
13:14:57 <Cale> are they strings?
13:14:58 <Puffton> yes
13:16:08 <Puffton> Example
13:16:23 <Puffton> [(\"FOXP4_COW\",\"v3\"),(\"FOXP4_DOG\",\"v3\"),(\"FOXP4_FROG\",\"v2\"),(\"FOXP4_HUMAN\",\"v4\"),(\"FOXP4_MOUSE\",\"v1\"),(\"FOXP4_RAT\",\"v1\"),(\"v1\",\"v2\"),(\"v2\",\"v4\"),(\"v3\",\"v4\")]
13:17:26 <Puffton> Since v4 has 3 children, v4 is the root of the tree
13:18:06 <ski> @. read run showsPrecTree showsPrec 0 (Node "v1" [Node "a" [],Node "b" [],Node "v2" [Node "c" [],Node "d" []]]) ""
13:18:08 <Puffton> the tree in newick is like ("FOXP4_HUMAN", "v2", "v3") but where v2 and v3 should in turn be evaluated to their respective subtrees
13:18:09 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
13:18:17 <ski> @botsmack
13:18:18 <lambdabot> :)
13:18:27 <ski> (how come that works in private ?)
13:18:34 <ski> > showsPrecTree showsPrec 0 (Node "v1" [Node "a" [],Node "b" [],Node "v2" [Node "c" [],Node "d" []]]) ""
13:18:34 <jfischoff> Is there an easy way to kill a function is taking to long to evaluate?
13:18:36 <lambdabot>   "Node \"v1\" [Node \"a\" [],Node \"b\" [],Node \"v2\" [Node \"c\" [],Node \...
13:19:00 <Polarina> jfischoff, if you have it run in a separate thread (forkIO), you can kill that thread.
13:19:24 <Cale> Puffton: Okay, next problem: how do we tell which of these strings are names of internal nodes?
13:19:36 <jfischoff> that'll work, is there any function like forkIOWithTimer?
13:19:44 <Cale> Puffton: you gave, as the result of the operation, the string "(a,b,(c,d))"
13:19:50 <Puffton> I generate them using the prefix v
13:20:03 * ski suspects "any string which is the parent of at least one other string"
13:20:03 <Puffton> v1, v2, v3, v100, v200 etc. depending on the size of the tree
13:20:05 <Polarina> jfischoff, http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/System-Timeout.html
13:20:08 <Cale> Puffton: rather than "(a,b,(c,d)v2)v1"
13:20:30 <Puffton> Cale, yes, the v1, v2 etc. information is convayed in the parentheses
13:20:39 <Puffton> it is the grouping of the actual leaves
13:20:39 <jfischoff> Polarina: sweet
13:20:42 <absence> i think i have a space leak problem or something similar. this function causes 32% of the cpu and 41% of the allocations: http://hpaste.org/75718 (that's excluding the stepWireM call that actually does the work). how do i go about to improve the performance?
13:21:27 <absence> m is a reader monad, a and b are Double
13:22:06 <Cale> Puffton: right, so you're looking specifically for strings of a particular form. Do you have a function which picks out which strings will correspond to internal nodes?
13:23:30 <Puffton> Cale, not right now, should I implement one to match "vx" where x is some int?
13:23:38 <Polarina> absence, does it help if you prepend { y `seq` } in front of line 5? I'm just guessing here.
13:23:42 <Cale> Puffton: probably :)
13:24:01 <FireFly> What would be a good name for  \p x -> if (p x) then (Left x) else (Right x)  ?
13:24:02 <ski> absence : it's not tail-recursive, nor incremental
13:25:06 <absence> Polarina: it got slower :D
13:25:15 <Polarina> I suck at this.
13:25:17 <ski> FireFly : `\p -> cond p Left Right', maybe ?
13:25:36 <clahey> Puffton: What's your input size?  Is O(N^2) (N is the number of nodes) good enough?
13:25:41 <clahey> Or do you need O(N log N)?
13:25:51 <Puffton> no limit on time
13:25:55 <Puffton> very small inputs
13:25:58 <ski> absence : why are you defining this `mapWireM' ? how (where/why) is it to be used ?
13:26:03 <absence> ski: okay. are there any guides with tips on solving problems in incremental tail-recursive ways?
13:26:57 <absence> ski: it is used for processing a bunch of input into output
13:27:18 <FireFly> ski: hm, that works
13:27:29 <ski> absence : in some kind of top-level call on a `WireM e m a b' or otherwhere too ?
13:27:32 <ion> > [(25*0.001)*36, 25*(0.001*36), 25*(36/1000)]
13:27:33 <lambdabot>   [0.9,0.9000000000000001,0.8999999999999999]
13:28:24 <ski> (absence : also note that tail-recursive and incremental are more or less mutually exclusive)
13:28:45 <absence> ski: see annotation: http://hpaste.org/75718
13:28:54 <arcatan> I read on the Internet that Haskell is based on System F, that System F is normalizing and that normalizing systems are not Turing-complete
13:28:59 <absence> ski: ah, shows how much i know of these details :D
13:29:21 <trotro> arcatan, I emulated a turing machine with Haskell :D
13:29:23 <arcatan> as Haskell is Turing-complete, what kind of, uh, extra power does it have? or am i just confused?
13:29:27 <trotro> so stop to read silly things :)
13:29:45 <Cale> arcatan: fixed points
13:29:55 <Polarina> arcatan, System F is just the type system.
13:30:23 <Cale> arcatan: you can add to System F a primitive  fix :: forall a. (a -> a) -> a
13:30:35 * Polarina could be wrong on that.
13:30:51 <absence> ski: processPure is in a dll and called by a c program
13:30:55 <Cale> Polarina: System F is a lambda calculus with value level stuff too
13:31:06 <absence> ski: (via some other haskell stuff for gluing it all together)
13:31:12 <Polarina> Cale, :)
13:31:13 <Cale> and it's not really System F that GHC is based on but a variant of that
13:31:15 <arcatan> Cale: makes sense, I was expecting something like that
13:33:12 <Cale> System F is a good starting point for understanding a subset of Haskell
13:33:34 <Cale> (well, GHC Haskell)
13:33:50 <Cale> System F interestingly has some types which can't be expressed in Haskell 98
13:35:04 <clahey> Does anyone have any experience with Fay or any of the other haskell -> js systems?
13:35:44 <clahey> @src nub
13:35:44 <lambdabot> nub = nubBy (==)
13:35:47 <clahey> @src nubBy
13:35:47 <lambdabot> nubBy eq []             =  []
13:35:48 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:36:45 <arcatan> Cale: what kind of types?
13:37:22 <Cale> arcatan: higher rank ones :)
13:37:34 <Polarina> arcatan, take note on that she mentioned Haskell 98. There are many extensions that can let you do more.
13:37:45 <Cale> she?
13:37:52 <Polarina> s/she/he/
13:39:28 <fengshaun> hi all, how can I convert a string like "a" to Char?
13:39:36 <fengshaun> so I get 'a'
13:39:46 <Cale> fengshaun: pattern match it against [x]
13:39:46 <fengshaun> read "a" :: Char gives "no parse" erro
13:39:53 <fengshaun> oh
13:39:56 <fengshaun> thanks
13:40:12 <Cale> (and handle the other cases where the string is empty or has more characters while you're at it :)
13:41:01 <fengshaun> yup, so if I use it in a map, will it look like map (\[x] -> x) ["a", "b", "c"] ?
13:42:16 <apple_user> http://ideone.com/G7rrp so Haskell's `data` keyword is analogous to C's structs?
13:42:43 <maukd> apple_user: it's struct, union, and enum
13:42:46 <ion> apple_user: data Bool = False | True
13:44:09 <apple_user> http://ideone.com/UKYrD how do I define a rectangle?
13:44:54 <Cale> apple_user: data Rectangle = Rect (Pair Double Double)  perhaps
13:45:26 <apple_user> ah
13:45:49 <fengshaun> apple_user, learnyouahaskell.com has a good intro to data and stuff!
13:45:57 <fengshaun> it's a haskell book
13:46:09 <apple_user> I'm on that datatypes and typeclasses chapter ^_^
13:47:25 <fengshaun> :D
13:47:39 <frerich_> Is anybody aware of an existing package which can be used to generate SVG documents? I'm currently building them manually using HaXml, maybe somebody has built something on top of that already which I didn't find on hackage?
13:48:05 <byorgey> @package blaze-svg
13:48:05 <lambdabot> http://hackage.haskell.org/package/blaze-svg
13:48:08 <byorgey> frerich_: ^^^
13:48:09 <Cale> http://hackage.haskell.org/package/diagrams-svg-0.3.7
13:48:31 <byorgey> yes, blaze-svg was actually created to support diagrams-svg
13:48:41 <frerich_> Ok that makes me wonder why I didn't find that myself...
13:48:49 <frerich_> byorgey, Cale: Thanks :-}
13:48:54 <byorgey> well, searching Hackage is still not very easy
13:49:02 <clahey> Damn, my N7 is broken.
13:49:06 <byorgey> but Hackage 2 is coming soon!!
13:49:17 <clahey> I wonder if it's possible to replace just the glass.
13:49:17 <Cale> http://projects.haskell.org/diagrams/ for more information about the diagrams library
13:49:42 <byorgey> =D
13:49:52 <byorgey> I'm working hard on a new release of diagrams
13:50:03 <byorgey> should be out soonish... =)
13:50:37 <nejucomo> apple_user: I found realworldhaskell.org quite helpful, but I haven't read "learn you a haskell".
13:50:45 <Unregistered> Hi guys
13:51:00 <Unregistered> I didn't realise Haskell was this popular
13:51:48 <fengshaun> how can I do an exhaustive pattern match in a lambda?  using case with multiple lines screws up the syntax!
13:52:03 <Cale> fengshaun: you can use case with multiple lines
13:52:19 <fengshaun> inside a lambda?
13:52:23 <Cale> fengshaun: yes
13:52:28 <fengshaun> let me try again
13:52:31 <fengshaun> I got a syntax error
13:52:39 <Cale> maybe it was something else...
13:53:59 <fengshaun> yea, seems to be fine now
13:54:01 <fengshaun> thanks
13:55:32 <fengshaun> there we go, parse error: http://dpaste.org/hEIxZ/
13:55:42 <fengshaun> parse error on input ')'
13:55:53 <Cale> ''
13:55:57 <Cale> is not a valid Char
13:56:06 <fengshaun> oh
13:56:17 <fengshaun> thanks
13:56:58 <Cale> To be fair, you may just want to write (\[x] -> x)
13:57:14 <Cale> if you don't mind having your program die when it's not a length 1 list
13:57:42 <fengshaun> I don't mind that, but ghc complains of non-exhaustive pattern match
13:58:04 <Cale> yeah, but that's not an error
13:58:09 <Cale> Just a warning
13:58:30 <fengshaun> I guess I could disable the warning or ignore it
14:01:02 <apple_user> how do I make a module override the default stuff?
14:01:22 <apple_user> an imported module*
14:02:30 <fengshaun> apple_user, I don't know the answer, but you can always import qualified and use a shorted name.
14:02:37 <fengshaun> it's more readable too
14:03:25 <Cale> apple_user: You can import the first module hiding the names you want from the second
14:03:43 <apple_user> what if I want to override stuff that Prelude imports?
14:03:49 <Cale> Or yes, usually you start importing things qualified
14:04:04 <Cale> but you can also  import Prelude hiding (catch)
14:04:16 <Cale> and then  import Control.Exception  (say)
14:04:53 <Cale> heh, that looks like an import list, but I just mean you can import the whole module for instance, and it won't be ambiguous which catch you want anymore
14:05:09 <Cale> You can also just import both and only qualify things where you need to
14:05:17 <apple_user> so I `import Prelude as std` and then thats it? ^_^
14:05:42 <Cale> std is not a valid module identifier, because it doesn't begin with an uppercase letter
14:05:59 <apple_user> oh :(
14:06:00 <Cale> if you write  import Prelude as Std
14:06:31 <Cale> you can use the things in Prelude unqualified, but also refer to them as  Std.map, Std.filter  etc.
14:07:05 <Cale> (though it would be more common to use an abbreviation of Prelude, like P when importing like that)
14:08:08 <apple_user> does haskell have anyhing like C++ namespaces?
14:08:40 <sipa> modules?
14:10:35 <Cale> apple_user: Yeah, that's what modules are :P
14:10:59 <alpounet> apple_user, except that modules rely on files
14:11:15 <alpounet> apple_user, except that modules rely on files
14:11:17 <alpounet> err
14:11:35 <alpounet> apple_user, whereas in C++ you can nest them, extend them, create them about whenever/wherever you want
14:11:44 <apple_user> yeah :(
14:14:27 * hackagebot tensor 0.2.0 - A completely type-safe library for linear algebra  http://hackage.haskell.org/package/tensor-0.2.0 (NicolaSquartini)
14:14:33 <apple_user> maybe if I knew enough Haskell, I could hack GHC and add them ^_^.... if only...
14:14:37 <Cale> Well, the standard doesn't say that you have to put modules in separate files
14:14:48 <nmlss> How to restrain class to severak type variables?
14:14:52 <Cale> But GHC wouldn't be able to find them automatically if you didn't
14:14:57 <nmlss> *several
14:14:58 <simon> I think there is a kind of class in C# that can be extended across files.
14:14:59 <Kostya> how to list of lists into one big list?
14:15:01 <Cale> so in practice, it's very convenient
14:15:05 <Cale> Kostya: concat
14:15:08 <nmlss> func58 :: (Show (a b c)) => a -> b -> c ->String
14:15:09 <nmlss> ?
14:15:19 <Kostya> thanks
14:15:22 <Cale> nmlss: (Show a, Show b, Show c) => ...
14:15:23 <Cale> ?
14:15:23 <simon> :t concat
14:15:38 <lambdabot> forall a. [[a]] -> [a]
14:15:49 * nejucomo finds it annoying and frustrating when namespaces are decoupled from the file system.
14:16:34 <apple_user> but then you get to have supernamespaces
14:16:35 <simon> nejucomo, I agree. the one C# job I had made a convention about syncronizing namespaces with the filesystem (but failed).
14:16:40 <apple_user> like boost:: and std::
14:17:11 <Cale> apple_user: Module names are hierarchical
14:17:14 <nejucomo> simon: Right.  If there's a "convention" that's even worse, because if you rely on it, then 3% of the time you'll be surprised.
14:17:15 <Cale> (lol)
14:17:35 <nejucomo> If there's no convention, you'll never be surprised but will always have to deal with extra complexity.
14:17:42 <Cale> apple_user: Really all that amounts to is that '.' is a valid character in them, and when that happens, GHC will look in a subdirectory
14:17:47 <apple_user> right
14:17:52 <nejucomo> The best option, IMO, is to make it impossible to decouple them.
14:18:08 <Cale> apple_user: but different packages are allowed to stick things under the same paths
14:18:35 <nmlss> Thnx
14:18:42 <Cale> apple_user: So we have silly top-level things like Control and Data which are filled with way too much because they are highly generic to begin with
14:19:05 <Cale> :D
14:19:13 <nejucomo> I like those very general top-level names.
14:19:25 <nejucomo> Compare that to the python stdlib, for example.
14:19:28 <Cale> I think it would be better to obliterate those levels
14:19:44 <hpaste> clewis pasted “free monad” at http://hpaste.org/75722
14:19:47 <Cale> Just move everything that's under Control or Data up one level
14:20:00 <nejucomo> I'd want to push things down to more levels.  ;-)
14:20:05 <chrslws> can someone answer a simple question about the above paste?
14:20:21 <chrslws> specifically, I'm trying to understand the type of bind
14:20:25 <nejucomo> Consider Data.HTTP versus Network.HTTP.
14:20:33 <Cale> bind :: Free f a -> Free f b
14:21:23 <Cale> (where the a and b are not just any a and b)
14:21:37 <Cale> but the a and b from the type of the surrounding definition
14:21:53 <shachaf> I wonder whether requiring explicit quantification would be a bad thing overall.
14:21:59 <Cale> (i.e. the ones from the type of f)
14:22:25 <chrslws> Cale: thanks, i'm trying to add an explicit type sig to assert that, but I'm not sure how/if that's possible in a where clause
14:22:36 <Cale> chrslws: I don't think it is possible here
14:22:39 <Cale> At least, in Haskell 98
14:22:54 <shachaf> It's possible, but only if you add an extra where clause.
14:22:56 <chrslws> crap :-( - is there anyway i can inspect it's type
14:23:08 <Cale> You could turn it into a hole
14:23:14 <Cale> In the very newest GHC :)
14:23:20 <shachaf> (>>=) = blah where blah :: forall f a b. Free f a -> (a -> Free f b) -> Free f b; blah = ... where bind :: Free f a -> Free f b; bind = ...
14:23:28 <shachaf> Or something like that.
14:23:34 <nejucomo> There's ScopedTypeVariables in GHC.
14:23:40 <Cale> yeah, you can turn on ScopedTypeVariables and do that
14:23:51 <shachaf> Oh, yes, you still need ScopedTypeVariables.
14:24:04 <shachaf> chrslws: I think it's simpler not to give "bind" a name at all. :-)
14:24:16 <Cale> Or:
14:24:19 <chrslws> shachaf: for sure, but i'm trying to understand the formulation
14:24:24 <Cale> :t \f -> (>>= f)
14:24:28 <shachaf> Roll ffa >>= f = Roll (fmap (>>= f) ffa)
14:24:31 <Cale> just understand it generally
14:24:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
14:24:32 <nejucomo> I don't understand if ScopedTypeVariables give more expressive power to internal type assertions or not...
14:24:36 <chrslws> i don't see how >>= can work with Free as there's no proof it's a Monad
14:24:41 <Cale> :t (>>= ?f)
14:24:44 <lambdabot> forall (m :: * -> *) a b. (?f::a -> m b, Monad m) => m a -> m b
14:24:51 <chrslws> so I'm breaking it up and adding types
14:24:52 <shachaf> No proof what's a monad?
14:24:56 <chrslws> Free
14:25:02 <Cale> chrslws: You're inside a proof that it's a Monad
14:25:05 <apple_user> :t \f
14:25:06 <chrslws> unless it's recursive
14:25:08 <shachaf> Oh, well, that proof is an exercise. :-)
14:25:08 <lambdabot> parse error (possibly incorrect indentation)
14:25:10 <SLi> BTW is it always possible to write the correct (most generic possible) type annotation for inner (where) definitions? I've ran into difficulties doing so quite often, and if it should be possible, I guess I'll ask here next time I encounter problems ;)
14:25:12 <chrslws> Cale: yeah :-)
14:25:14 <Cale> chrslws: Of course it's recursive!
14:25:37 <Cale> chrslws: It actually has to be recursive, because look at the definition of Free :)
14:25:38 <shachaf> chrslws: (>>=) is recursive; so is Free.
14:25:54 <SLi> Most often the problem is that the top-level definition type includes a type variable such 'a', and apparently using 'a' in an inner definition makes it a different 'a' than the top-level one?
14:25:55 <chrslws> Cale: yeah, i just don't know the limits of haskell well
14:26:09 <shachaf> Is Free data and Cofree codata or something like that?
14:26:26 <Cale> data and codata are identified in Haskell
14:26:32 <shachaf> Right.
14:26:38 <apple_user> what are codata?
14:26:53 <nmlss> Typeclass of a String
14:27:37 <shachaf> SLi: In particular it's shadowed because there's an implicit forall (which is a sort of "type lambda") on every signature.
14:27:49 <nmlss> ?
14:28:41 <SLi> shachaf, yes, I think I understand that. But does that mean there is no way to refer to the outer a in an inner signature, and hence no way to write the most generic possible type annotation? It's hard to see the purpose of such a limitation, but maybe there's a reason...
14:29:03 <apple_user> sorry wrong channel
14:29:08 <apple_user> sorry* wrong channel again
14:29:12 <shachaf> SLi: There is a way, just not in Haskell 98/2010.
14:29:13 <apple_user> are there doubly-linked lists in Haskell?
14:29:30 <Cale> apple_user: Doubly linked lists are pretty stupid in Haskell
14:29:34 <SLi> shachaf, but using some GHC extensions?
14:29:35 <apple_user> so I can match things like `xsl:x:xsr`
14:29:39 <Cale> apple_user: you can construct them, but they're useless
14:29:40 <shachaf> SLi: GHC allows it, yes.
14:30:05 <Cale> apple_user: Doubly linked lists are more useful when you have mutable data
14:30:19 <SLi> shachaf, how?
14:30:19 <apple_user> I want to simulate the Tape in a turing machine
14:30:26 <shachaf> SLi: ScopedTypeVariables
14:30:28 <SLi> shachaf, or what extension?
14:30:32 <SLi> Hmm.
14:30:52 <shachaf> apple_user: You might want something like a zipper.
14:31:09 <Cale> apple_user: Use something like  data Tape a = Tape { left :: [a], here :: a, right :: [a] }
14:31:28 <Cale> and keep the left in reverse order, so the front of that list is the one which is closest to 'here'
14:31:30 <apple_user> http://ideone.com/C5hbK I did this
14:31:57 <Cale> Now you *could* do this:
14:32:08 <Cale> data Tape a = Tape { left :: Tape a, here :: a, right :: Tape a }
14:32:15 <apple_user> ah
14:32:26 <Cale> but since all data is immutable
14:32:41 <Cale> you're going to find that as soon as you want to modify a Tape, this is horrible
14:32:55 <Cale> you won't be able to just refer to the left and right part of the old tape
14:32:59 <Cale> (which is cheap)
14:33:11 <Cale> you'll have to dig into them and modify them as well
14:33:19 <shachaf> data Tape a = Tape { left :: IORef (Tape a), here :: a, right :: IORef (Tape a) } -- note: don't do this.
14:33:27 <Cale> haha
14:33:27 <SLi> shachaf, hmm, I'll have to investigate. I think I've ran into ScopedTypeVariables only with something like \(x::SomeType) -> ... just to make it possible to infer some class constraint somewhere... I guess it doesn't redefine the syntax anyway so that 'a' would refer to the outer 'a'?
14:33:35 <Cale> Might as well IORef the a while you're at it :)
14:34:03 <frerich_> byorgey: I just tinkered with blaze-svg a bit (thanks for pointing it out) and noticed that a lot of the code is actually generated (many of the combinators corresponding to SVG elements). Unfortunately (?) I give up some type safety, so e.g. Text.Blaze.Svg11.Attributes.width takes a string instead of a Number. This makes me wonder - are you aware of a Haskell program to extract the type information out of the W3C .idl files when
14:34:04 <frerich_> generating such combinators?
14:34:06 <SLi> shachaf, looking at GHC docs, it's really simple. Interesting :)
14:34:11 <SLi> shachaf, thanks for the information.
14:34:30 <Cale> apple_user: but with the two lists, we can write efficient operations which move around in a Tape
14:34:36 <shachaf> Cale: I'll double-IORef it, just in case.
14:34:37 <Cale> apple_user: and update the value at its head
14:34:39 <nmlss> why this is wrong
14:34:40 <nmlss> func59 ::  (Read a, Read b, Read c) => String -> String -> String -> a -> b -> c    func59  a b c = read (a,b,c)
14:34:43 <apple_user> right
14:35:01 <apple_user> wow, lazy Turing machine tapes
14:35:11 <Cale> nmlss: read takes a single String parameter, not a triple
14:35:56 <SLi> shachaf, ah, I'll just need forall to bind the type variable. I had actually wondered when you need that :-)
14:35:56 <nmlss> how fix?
14:36:03 <Cale> nmlss: I don't understand what you're trying to do
14:36:14 <Cale> nmlss: maybe...
14:36:31 <nmlss> take 3 string return their 3 types
14:36:33 <apple_user> what are some useful typeclasses to deriving from?
14:36:38 <Cale> func59 :: (Read a, Read b, Read c) => String -> String -> String -> (a, b, c)
14:36:50 <Cale> func59 x y z = (read x, read y, read z)
14:36:50 <shachaf> SLi: forall is useful for a lot of things.
14:36:55 <ski> fengshaun : maybe `concat' (or `concatMap') ?
14:37:05 <shachaf> ...But all of them are covered under "bind the type variable", I guess!
14:37:12 <ski> (Cale : well, you could already say `Tape (IORef a)' ..)
14:37:19 <SLi> shachaf, yes, but usually it's implicit, I've thought.
14:37:32 <Cale> ski: Indeed I suppose you could.
14:38:00 <shachaf> data Tape a = Tape { left :: IORef (Tape (IORef a)), here :: a, right :: IORef (Tape (IORef a)) }
14:38:04 <shachaf> Now there's a fun type.
14:38:10 <shachaf> SLi: Right.
14:38:10 <Cale> lol
14:38:11 <ski> hehe
14:38:24 <Cale> MOAR IOREFS
14:38:34 <ski> nested data types ftw !
14:38:52 <shachaf> I still find polymorphic recursion weird.
14:38:53 <apple_user> http://www.haskell.org/haskellwiki/Turing_machine#Tape
14:39:16 <apple_user> what's IORef?
14:39:23 <monochrom> mutable variable
14:39:29 * hackagebot fb 0.12.8 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.12.8 (FelipeLessa)
14:39:29 <shachaf> apple_user: Don't use it.
14:39:33 <Cale> apple_user: A mutable reference, accessible from IO actions
14:39:40 <Cale> They have their place
14:39:48 <monochrom> I use it all the time
14:39:51 <nmlss> <interactive>:27:1:     Ambiguous type variable `a0' in the constraint:       (Read a0) arising from a use of `func59'     Probable fix: add a type signature that fixes these type variable(s)     In the expression: func59 "True" "1" "A"     In an equation for `it': it = func59 "True" "1" "A"  <interactive>:27:1:     Ambiguous type variable `b0' in the constraint:       (Read b0) arising from a use of `func59'     Probable fix: add a ty
14:39:51 <shachaf> Cale: Absolutely.
14:40:01 <shachaf> But not yet.
14:40:15 <Cale> nmlss: It doesn't know what type of triple you want to read
14:40:29 <nmlss> meh i want to do this
14:40:47 <Cale> nmlss: try   func59 "True" "1" "\"A\"" :: (Bool, Integer, String)
14:40:49 <nmlss> o wait it inferes
14:40:55 <monochrom> "A" will be problematic
14:41:01 <nmlss> infers
14:41:24 <Cale> It won't infer the type of the result from the values of the arguments though
14:41:34 <Cale> because types are compile time things, and values are runtime things
14:41:39 <nmlss> read "True" || False
14:41:49 <ski> > not (read "False")
14:41:50 <lambdabot>   True
14:42:10 <Cale> right, if you do something with the result of the function, it might get enough information about what types of data to parse
14:42:11 <ski> > not (read "  False  ")
14:42:13 <lambdabot>   True
14:42:15 <nmlss> read "8.2" + 3.8
14:42:27 <nmlss> yep
14:42:29 <Cale> > read "8.2" + 3.8
14:42:30 <lambdabot>   12.0
14:42:31 <ski> nmlss : you're forgetting the initial `> '
14:42:40 <Cale> > read "True" || False
14:42:42 <lambdabot>   True
14:42:49 <Cale> > read "True" :: Bool
14:42:51 <lambdabot>   True
14:43:00 <nmlss> > :q
14:43:01 <lambdabot>   <no location info>: parse error on input `:'
14:43:06 <ski> > read "True" `asTypeOf` otherwise
14:43:08 <lambdabot>   True
14:43:33 <Cale> > read "5" :: Integer
14:43:35 <lambdabot>   5
14:43:37 <Cale> > read "5" :: Double
14:43:39 <lambdabot>   5.0
14:43:56 <Cale> > read "5" :: Complex Double -- I think this stopped working...
14:43:57 <lambdabot>   *Exception: Prelude.read: no parse
14:44:00 <nmlss> mm ok i turns out to be more complex
14:44:10 <Cale> > read "5 :+ 6" :: Complex Double
14:44:12 <lambdabot>   5.0 :+ 6.0
14:44:22 * ski misses being able to bind type variables in pattern ascriptions :/
14:44:35 <Cale> > read "[1,2,3,4,5]" :: [Rational]
14:44:37 <lambdabot>   *Exception: Prelude.read: no parse
14:44:41 <dandennison84> quit
14:44:42 <Cale> > read "[1,2,3,4,5]" :: [Integer]
14:44:43 <lambdabot>   [1,2,3,4,5]
14:45:00 <ski> > read "[1,2,3,4,5]" :: [Double]
14:45:01 <lambdabot>   [1.0,2.0,3.0,4.0,5.0]
14:45:15 <apple_user> http://www.mathrix.org/experimentalAIT/TuringMachineNoLimitAWS2.hs heres a tiny turing machine ^_^
14:45:22 <Cale> It's kind of interesting that it opts to print 1 :: Double as 1.0
14:45:45 <ski> > not (read "  ( ( False ))  ")
14:45:47 <lambdabot>   True
14:45:55 <absence> is there a more idiomatic way to express [0..(n-1)]?
14:46:07 <Cale> absence: that's already pretty good
14:46:24 <ski> absence : mayhaps you like `take n [0 ..]' better ?
14:47:27 <nmlss> then func58 ("True" || False ) ("coRN" ++ ""stuff") (3 + 9.5)
14:47:28 <Cale> apple_user: The license is longer than the program, lol.
14:47:28 <absence> it's strangely appealing. we'll see, thanks :)
14:48:17 <nmlss> mind to rest
14:48:20 <Cale> Reminds me of the implementation of /bin/true
14:48:23 <tromp> [0..n-1] is more idiomatic than [0..(n-1)]  :-)
14:48:46 <Cale> http://trillian.mit.edu/~jc/humor/ATT_Copyright_true.html
14:49:02 <shmoo_> what is the ideal way to test for an error condition with quickcheck? I have a function that fails on malformed input, and i am not interested in the result, just whether or not it fails
14:49:39 <blackdog> shmoo_: fails == returns Nothing? Throws an exception? Sets the computer on fire?
14:50:06 <osa1> I have a FFI binding that returns CDouble, is it safe to convert it to Haskell Float ?
14:50:11 <danharaj> edwardk: I am reading the reflection package, and I'm confused by the signature for reflect, because it is :: proxy s -> a, not Proxy s -> a.
14:50:22 <tdammers> blackdog: keeps running forever
14:50:24 * tdammers ducks
14:50:31 <shmoo_> blackdog: calls error
14:50:37 <Cale> expectFailure :: Testable prop => prop -> Property
14:50:42 <edwardk> danharaj: you can pass it a Proxy s and it works fine, but as it doesn't use the argument you can also pass it a Foo s and it works just dandy
14:50:45 <edwardk> its strictly more general
14:51:04 <Cale> oh, errr
14:51:13 <Cale> maybe that's not what you want
14:51:22 <blackdog> shmoo_: tempted to invoke the old "dr, dr, it hurts when i punch myself in the face" response.
14:51:46 <apple_user> > unwords . map reverse $ words "foo bar baz." -- How do I reverse each word in that sentence, while keeping punctuation intact?
14:51:50 <lambdabot>   mueval-core: Time limit exceeded
14:51:53 <apple_user> O.o
14:51:58 <blackdog> is there a good reason not to return a Maybe or Either type? THen it's easier to test, and you won't get unexpected crashes
14:52:06 <Cale> > unwords . map reverse $ words "foo bar baz." -- How do I reverse each word in that sentence, while keeping punctuation intact?
14:52:08 <krey_> i'm trying to do simple typed lambda calculus inside haskell. is there a library for this?
14:52:09 <lambdabot>   "oof rab .zab"
14:52:32 <Cale> apple_user: you'll need something fancier than words
14:52:36 <danharaj> edwardk: Clever. I have a configuration parameter at the top level of a module. What is the most painless way to modify the code to use reflection?
14:52:39 <Cale> apple_user: Like an actual parser
14:52:44 <apple_user> wow
14:52:54 <cornihilio> hello everyone! could someone perhaps help me understand why I'm getting an ambiguous type error here? https://gist.github.com/3830109
14:53:03 <danharaj> (Also how many GHC releases do you count before Magic stops working :P)
14:53:13 <apple_user> maybe something from Data.Text might help
14:53:16 <tdammers> luckily, writing an actual parser in haskell is a lot less scary than in, say, uh, PHP
14:53:21 <edwardk> danharaj: it works on pretty much _all_ of them historically, and it even works in Hugs
14:53:27 <Cale> cornihilio: that is not your entire program ;)
14:53:28 <apple_user> tdammers: or yacc
14:53:29 <edwardk> plus if magic fails i can fall back on the slow path
14:53:45 <Cale> cornihilio: Specifically, it doesn't include the line which the error mentions
14:53:59 <danharaj> edwardk: Interesting. My interpretation is that the fast path has no compile-time overhead or run-time overhead compared to plumbing a function argument. Is this correct?
14:54:04 <tdammers> apple_user: yacc - the name is *not* a coincidence, and the large land mammal explanation is in fact folk etymology
14:54:05 <krey_> the kind of things I'd like to have are beta reduction and equality testing on terms, I can't seem to find a library online
14:54:08 <Cale> cornihilio: But vaguely, you're confusing Lazy ByteString with String somewhere, I bet
14:54:22 <apple_user> > unwords . map reverse $ words "foo bar baz." -- Any better way of writing this, btw? Also, why does this crash lambdabot?
14:54:24 <lambdabot>   "oof rab .zab"
14:54:31 <edwardk> danharaj: correct. the fast path basically just turns into a lambda with some funny lifting properties
14:54:54 <acowley> I can't find OpenGL's wrapping of glTexEnvi. Where am I not looking? I've had to ffi it directly.
14:55:06 <Cale> apple_user: It just happened the one time because of some load on the server lambdabot is running on probably
14:55:07 <scp> > 1 + 2
14:55:08 <lambdabot>   3
14:55:13 <MostAwesomeDude> acowley: texEnv, lemme find the docs.
14:55:22 <apple_user> oh
14:55:24 <tdammers> if I ever make a parser in C again, I know I'll be staying miles away from yacc
14:55:40 <acowley> MostAwesomeDude: I tried that on hoogle and it came up empty
14:55:43 <scp> tdammers, what's wrong w/ yacc?
14:56:02 <edwardk> re refactoring. i tend to just make a a record with all the methods i'd want my dictionary to have and then make an instance for 'Foo s' where s is an instance of Reifies s Foo_    for some Foo_ dictionary
14:56:03 <acowley> i.e. "texEnv +OpenGL"
14:56:06 <tdammers> have you ever looked at the amount of hackery that is involved, and the incredible mess it outputs?
14:56:09 <shmoo_> blackdog: mostly just because i do not want to wrap it in the maybe monad XD. The function is not a part of the cod being tested, its somewhere between quickcheck and the code to being tested.
14:56:12 <Puffton> Roarr!!
14:56:18 <Puffton> I have risen once again!
14:56:23 <nmlss> Could someone explain read typeclass
14:56:30 <Puffton> http://hpaste.org/75724
14:56:46 <MostAwesomeDude> acowley: I just did this a couple weeks ago, one sec.
14:57:04 <scp> tdammers, a bit of hackery, theoretically sound output -- it's machine generated
14:57:13 <Puffton> Cale, what do you think about this solution (the newick function and the ones it depends on)? a bit cluttered but still, hopefully correct :p
14:57:24 <tdammers> maybe it's just that my brain is more suitable for parser-combinator-style thinking, but I find it hard to believe that anyone has ever found yacc pleasant to work with
14:57:58 <monochrom> I find it pleasant that I do not know how to use yacc
14:58:12 <tdammers> the parsing part isn't that bad, really
14:58:21 <tdammers> but the way it generates output is kinda weird
14:58:36 <Cale> Puffton: of course it would be nicer to go via a proper tree datastructure, but in this case, if it gets the job done, that's all you really need
14:58:42 <MostAwesomeDude> acowley: There's no single texEnv; you set individual bits of the environment. http://hackage.haskell.org/packages/archive/OpenGL/2.5.0.0/doc/html/Graphics-Rendering-OpenGL-GL-Texturing-Environments.html
14:59:06 <Puffton> yeah but my teacher gets a bit whiny, sometimes when we don't follow her suggestions
14:59:09 <Puffton> even if they are just suggestions
14:59:15 <scp> tdammers: ya, the generated output is a table-driven parser. It's impractical for humans to right, but very efficient
14:59:34 <blackdog> shmoo_: well, you can catch error calls with Control.Exception.catch. I'd advocate using quickcheck as close to the actual function you care about as you can, though.
14:59:38 <tdammers> I call that premature optimization ;)
15:00:09 <tdammers> I'm building a compiler. I don't want the compiler itself to blazing fast, just not dead slow; what I want is maintainability and efficient output
15:00:30 <acowley> MostAwesomeDude: That doesn't help someone trying to set some bits that came in after 2.something. What's funny is that the enums I want are defined in Raw, but there's no way to flip the bits.
15:00:51 <danharaj> edwardk: It feels a bit awkward though, I would have to Tagged s all my parameters wouldn't I? It makes them hard to combine with values of the untagged type.
15:00:54 <acowley> MostAwesomeDude: What I was expecting is to find texEnv in Raw
15:00:58 <MostAwesomeDude> acowley: Well, complain to the maintainers.
15:01:13 <MostAwesomeDude> Sorry I couldn't help more. :c
15:01:23 <danharaj> I guess there's no avoiding the sprinkled `untag`s.
15:01:40 <acowley> MostAwesomeDude: I always feel guilty when I complain about the OpenGL package. Everyone who cares about it can always complain more bitterly about it than the last person.
15:01:41 <edwardk> danharaj: Consider: https://github.com/ekmett/rounded/blob/master/src/Numeric/Rounded/Precision.hs
15:01:55 <acowley> MostAwesomeDude: I appreciate you trying!
15:01:56 <danharaj> A library writer who uses his own libraries??? unheard of.
15:02:01 <edwardk> danharaj: that shows how i use reflection in practice
15:02:04 <scp> tdammers: For a compiler, it makes a lot of sense to write your own lexer. It lets you control how errors are handled much more easily
15:02:13 <MostAwesomeDude> acowley: Man, I can complain about GL *itself*; bindings are not that much of a big deal. :3
15:02:44 <byorgey> frerich: I'm not aware of any such tools (but then again I haven't looked, and I didn't write blaze-svg).
15:02:47 <tdammers> if not a compiler, then what are you supposed to use yacc for?
15:03:03 <monochrom> undergrad homework
15:03:03 <acowley> MostAwesomeDude: See? The complaints keep getting deeper until we're all whining about how the plus and minus symbols on circuit diagrams make thinking about electron flow difficult.
15:03:15 <MostAwesomeDude> acowley: Stupid electrons. They're always so emo about things.
15:03:41 <acowley> I need a first word problems image macro featuring a goth electron.
15:03:46 <byorgey> frerich: it's a good question.  And there's always a tradeoff with encoding constraints in the type system.  The benefit is more type safety; the cost is more complicated types.
15:03:47 <acowley> s/word/world
15:03:55 <edwardk> there you can use Rounded TowardZero Double,   Rounded TowardInf 512, Rounded TowardNearest $(bits 1024), or Precision p => Rounded TowardNegInf p, where the latter can be constructed with reifyPrecision
15:04:00 <tdammers> I like "first word problem"
15:04:14 <acowley> ytou would like that!
15:04:24 <edwardk> (the 512 uses type lits)
15:04:32 <acowley> mi first word problem strikes again :(
15:04:32 <edwardk> (the 1024 uses TH to generate the type lit)
15:04:35 <tdammers> As in, "uh, ah, err, heh, well, ok, l-l-l-l-looks like I've got a first word problem!"
15:04:54 <acowley> s/tdammers/tstammers ?
15:04:59 <edwardk> acowley: =)
15:05:22 <edwardk> t-t-t-t-t-tstamers
15:05:22 <tdammers> acowley: if this were #php, I'd have to say "lol" now
15:05:48 <jfischoff> I am trying to debug something in ghci with -fbreak-on-exception, but nothing happens when I hit control-c. Is there something else I need to do?
15:05:53 <clahey> :t [a] -> Either String a
15:05:54 <acowley> In this house we unsafePerformIO "lol"
15:05:54 <lambdabot> parse error on input `->'
15:06:01 <clahey> @hoogle [a] -> Either String a
15:06:02 <lambdabot> No results found
15:06:11 <tdammers> unsafePerformLOL
15:06:29 <ski> clahey : whatcha looking for ?
15:06:33 <clahey> @hoogle String -> [a] -> Either String a
15:06:33 <lambdabot> No results found
15:06:43 <ski> @type listToMaybe
15:06:43 <acowley> god I wish we had that
15:06:44 <lambdabot> forall a. [a] -> Maybe a
15:06:52 <ion> atomically (do unsafeLOL; inc x)
15:07:04 <clahey> @src listToMaybe
15:07:04 <lambdabot> listToMaybe []        =  Nothing
15:07:04 <lambdabot> listToMaybe (a:_)     =  Just a
15:07:11 <clahey> Close.
15:07:18 <clahey> I would like whatever (a:b:_) = Nothing.
15:07:19 <tdammers> unsafeLOL >>= findUser >>= kickBan
15:07:23 <clahey> I just can define it myself.
15:10:35 <danharaj> edwardk: so functions that rely on `precision` take a dummy parameter. There's no way to hide the explicit dictionary?
15:10:49 <edwardk> correct
15:10:57 <edwardk> well, the types that rely on precision do
15:11:55 <edwardk> e.g. https://github.com/ekmett/rounded/blob/master/src/Numeric/Rounded.hs#L191
15:11:58 <apple_user> http://ideone.com/3S35P how do I get this to work? I want to be able to add two Vec objects using +
15:12:15 <edwardk> the code there isn't pretty but its designed to be fast instead
15:12:23 <danharaj> apple_user: (+) is part of the typeclass Num.
15:12:33 <apple_user> so it's reserved? :(
15:12:40 <rwbarton> not exactly
15:12:51 <danharaj> If you want to use it, you need to define a Num instance for Vec.
15:12:57 <rwbarton> you can define an instance of Num for your type but then you're supposed to define (*) and fromInteger also
15:13:12 <edwardk> instance Num Vec where Vec a b c + Vec d e f = Vec (a + d) (b + e) (c + f); ...
15:13:44 <edwardk> the nice thing is pointwise multiplication, etc is well defined for these, even if its counter-intuitive
15:14:00 <rwbarton> not very meaningful if you are doing geometry though
15:14:03 <danharaj> Well, pointwise multiplication in vector spaces isn't well defined :P
15:14:39 <rwbarton> you could do the square zero extension thing
15:15:02 <edwardk> danharaj: here its the full algebra you get for R^n over R, not the simple vector space.
15:15:37 <danharaj> edwardk:
15:15:38 <ion> I’d expect fromInteger and (*) to be defined in a way that results in 2 * Vec a b c = Vec (2*a) (2*b) (2*c)
15:16:00 <edwardk> ion: and that way it does
15:16:05 <ion> edwardk: yes
15:16:15 <danharaj> (oops). yes, I guess it's not problematic for many contexts
15:16:47 <ion> > 2 * (a, b, c)
15:16:49 <lambdabot>   (2 * a,2 * b,2 * c)
15:17:24 <danharaj> edwardk: Oh I see the idiom you're using, the `r where ...` dealie so that you can reference the result phantom type inferred from the surrounding code inside the definition of the term.
15:17:27 <edwardk> danharaj: i just wind up using https://github.com/ekmett/linear/blob/master/src/Linear/Vector.hs and model all my vector spaces as free vector spaces
15:17:33 <d01r> join #haskell
15:17:38 <edwardk> danharaj: yep
15:17:44 <ion> I refuse to join #haskell
15:18:05 <ion> edwardk: Those operators look happy and Japanese.
15:18:16 <edwardk> ion: hahahahah
15:18:30 <edwardk> (^*) doesn't look quite so happy
15:18:44 <absence> tromp: oh, didn't even try that one. thanks ;)
15:18:45 <zomg> There should be a nyoron operator (´･ω･｀)
15:19:01 <edwardk> zomg: http://hpaste.org/51474
15:19:07 <zomg> lol
15:19:08 <zomg> awesome
15:19:31 * hackagebot gluturtle 0.0.20 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.20 (YoshikuniJujo)
15:19:33 * hackagebot vector-algorithms 0.5.4.2 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.5.4.2 (DanDoel)
15:19:50 <ion> "ow!ow!ow!ow!ow!…"?
15:20:04 <edwardk> ion: well, he did have a table thrown at him ;)
15:20:15 <ski> hm .. not `instance (Monoid w,Num a) => Num (w,a)', then ?
15:21:13 <d01r> hello everybody, i have to do some static semantic analysis with haskell, is there an example of a simple compiler written in haskell?
15:21:44 <danharaj> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
15:21:58 <edwardk> do1r: http://code.google.com/p/tapl-haskell/
15:22:12 <acowley> Hooray for linear! I hope other people take it up, it's been serving me very well.
15:22:31 <clahey> :t list
15:22:32 <lambdabot> Not in scope: `list'
15:22:33 <clahey> :t lift
15:22:34 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
15:22:37 <clahey> :liftM
15:22:47 <clahey> :t liftM
15:22:48 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:23:29 <monochrom> @list tell
15:23:30 <lambdabot> tell provides: tell ask messages messages? clear-messages
15:23:38 <monochrom> @messages
15:23:39 <lambdabot> You don't have any new messages.
15:24:16 <edwardk> acowley: i've been meaning to solicit feedback =)
15:24:19 <hpaste> ion annotated “A play in one act” with “A play in one act (annotation)” at http://hpaste.org/51474#a75725
15:25:13 <edwardk> acowley: i've also been looking at adding http://unlines.wordpress.com/2010/11/15/generics-for-small-fixed-size-vectors/ to it
15:25:30 <edwardk> it'd be nicer if the nat solver was in ghc head though
15:25:30 <byorgey> aww, my computer doesn't have glyphs installed for a few of those
15:25:31 <acowley> edwardk: I'm going to write an article about a wonderfully stupid bug I put into linear and subsequently fixed.
15:25:37 <absence> http://hpaste.org/75726 <- is there a clever way to prevent the readerTAction from accessing IO?
15:25:39 <edwardk> acowley: oh?
15:25:43 <edwardk> acowley: do tell =)
15:25:54 <acowley> edwardk: I'm also building up some graphics things around linear, so I'll probably try to package up my 3D camera and such.
15:26:30 <danharaj> does linear unpack the arguments to vectors?
15:26:38 <c_wraith> absence: uh, what? That use of lift *requires* it to be an IO action
15:26:47 <ski> (monochrom : i think lambdabot would have told you if you had had any, on your first sign of activity)
15:27:01 <edwardk> danharaj: linear deliberately keeps the vectors abstract. if you want packed vectors you can deal with the pain of hmatrix, etc. ;)
15:27:04 <acowley> edwardk: I write a lot of Storable instances because I'm infatuated with that particular wheel. When doing the ones for linear, I decided to try peekElemOff instead of peek (ptr `plusPtr` 4) or what have you.
15:27:17 <edwardk> acowley: ah =)
15:27:26 <acowley> edwardk: But I bungled it and wrote, peekElemOff (sizeOf (undefined::a))
15:27:34 <acowley> edwardk: But here's the magic part
15:27:52 <byorgey> c_wraith: I interpreted absence's question as whether there is something to put in place of lift that would allow embedding something of type  Reader a b
15:28:00 <acowley> edwardk: I used linear in some work we recently submitted to a conference that included a somewhat carefully constructed renderer for point cloud data
15:28:11 <acowley> the point cloud data comes in (X,Y,Z) triples of single precision floats
15:28:21 <ski> absence : your variable naming there is counter intuitive
15:28:35 <d01r> thank you guys, but i'm a student and i need a very basic example of a compiler frontend written with happy, with type checking, static analysis, and code generation
15:28:39 <acowley> So my bug was filling an array with [X0,_,_,X1,Y0,_,X2,_,Z0 …]
15:28:57 <acowley> And for this applications, the point data was arranged such that the bug was virtually invisible!
15:29:00 <edwardk> heh
15:29:14 <acowley> You could make out people, desks, computers, and such perfectly clearly because there were so many points so close to each other
15:29:23 <monochrom> ski: yes, but I have recently added a plugin on my side, it speaks on my behalf, so I no longer know whether I spoke or not during my sleep.
15:29:25 <acowley> except at the ends of notional scan lines where you'd have a discontinuity
15:29:25 <edwardk> ahhahahahaa
15:29:35 <ski> absence : `ioAction1 :: ReaderT a IO c',`a :: c',`readerTAction :: c -> IO d',`b :: d',`ioAction2 :: d -> ReaderT a IO b'
15:29:46 <monochrom> to try my plugin, !list
15:29:49 <absence> c_wraith: well, i would like to use the reader in there, but i want the reader to be pure
15:29:49 <clahey> @hoogle [a] -> Maybe a
15:29:49 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
15:29:50 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
15:29:50 <lambdabot> Prelude head :: [a] -> a
15:29:50 <acowley> so we had what seemed like half a dozen bizarrely floating points out of a million
15:29:56 <clahey> @hoogle Maybe a -> [a]
15:29:57 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
15:29:57 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
15:29:57 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
15:29:59 <acowley> I blamed the guy who collected the data, of course
15:30:56 <acowley> Tracking that down was such a hair-pulling descent into madness
15:30:57 <clahey> @hoogle Maybe a -> Either MyError a
15:30:57 <lambdabot> Warning: Unknown type MyError
15:30:57 <lambdabot> Prelude Right :: b -> Either a b
15:30:57 <lambdabot> Data.Either Right :: b -> Either a b
15:31:04 <clahey> @hoogle Maybe a -> Either b a
15:31:04 <lambdabot> Prelude Right :: b -> Either a b
15:31:04 <lambdabot> Data.Either Right :: b -> Either a b
15:31:04 <lambdabot> Prelude Left :: a -> Either a b
15:31:16 <edwardk> acowley: heh, sounds like it worked out in the end
15:31:16 <ski> monochrom : hm, maybe it would be nice if such a plugin used `NOTICE' (and lambdabot didn't count those as activity) ?
15:31:20 <acowley> I don't know why I decided to change the Storable from the one I'd written in my fork of the code.
15:31:30 <edwardk> i also appreciate the er.. torture test ;)
15:31:41 <absence> ski: oh.. hmm
15:31:45 <byorgey> absence: write something like  embedReader :: Reader r a -> ReaderT r m a; embedReader act = runReader act <$> ask
15:31:46 <acowley> edwardk: Yeah, I managed to find it in one morning, so it wasn't the end of the world
15:32:01 <byorgey> actually you can give that a more general type
15:32:05 <edwardk> i saw the patch in question and wondered what prompted it now that you mention it
15:32:08 <monochrom> that is worth a try
15:32:34 <acowley> edwardk: you couldn't tell that the patch was soaked in my sweat and tears?
15:32:38 <cl_away> @hoogle b -> Maybe a -> Either b a
15:32:39 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
15:32:39 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
15:32:39 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
15:32:45 <cl_away> @hoogle Maybe a -> b -> Either b a
15:32:46 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
15:32:46 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
15:32:46 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
15:33:11 <byorgey> monochrom: what does your plugin do?
15:33:17 <edwardk> fraid not. i think the tears were left off the commit. you need to use git commit --sweat-and-tears or the rest of us will never know
15:33:19 <monochrom> try it! !list
15:33:23 <byorgey> !list
15:33:24 <monochrom> http://okmij.org/ftp
15:33:39 <ski> @where oleg
15:33:39 <lambdabot> http://okmij.org/ftp/
15:33:55 <byorgey> !list
15:34:04 <ski> monochrom : nice :)
15:34:11 <monochrom> it implements your wish that when a random stranger comes in and say "!list", we misguide him/her to oleg's files
15:34:24 <byorgey> hahaha
15:34:41 <monochrom> I also add a timeout so no one can cause me to flood. 1 minute.
15:35:04 <byorgey> ah, hence no response to my second try.  I was testing if it was nondeterministic.
15:35:06 <absence> byorgey: ah right, thanks :)
15:35:34 <ion> monochrom: Perhaps make it say “(nick): http://…”
15:36:02 <osfameron> doesn't !list usually send you the data in /query or DCC?
15:36:12 * ski has no idea
15:36:51 <monochrom> I don't know
15:41:06 <hpaste> mcstar pasted “puffont this actually works” at http://hpaste.org/75728
15:41:42 <mcstar> Puffton: ^^
15:50:03 <Rc43> I am started to look at type families.
15:50:11 <Rc43> They are similar to GADT as I think.
15:50:14 <hpaste> Rc43 pasted “GADTs -vs- TypeFamilies” at http://hpaste.org/75731
15:50:23 <Rc43> Which difference? (http://hpaste.org/75731)
15:50:34 <danharaj> edwardk: Ok I think I understand this style of code now. It feels like compiler support could erase a lot of the scaffolding though!
15:51:54 <Saizan> Rc43: the difference is that you can always add instances to a data family while a GADT is closed
15:52:19 <Saizan> Rc43: hence why pattern matching works differently for them
15:52:25 <Puffton> mcstar, yeah but I will cry telling my teacher how it works :p
15:52:42 <Rc43> Saizan, understood; but which difference in pattern matching?
15:52:50 <mcstar> Puffton: oh, it doesnt need those 'show's, http://hpaste.org/75732
15:53:10 <mcstar> Puffton: it is very simple
15:53:29 <Puffton> http://hpaste.org/75733
15:53:33 <Puffton> my current super solution :P
15:53:43 <Puffton> I know it's ugly
15:53:48 <Saizan> Rc43: you can write f :: YList a -> ..; f (YUnits _) = ..; f (YCons _ _) = .. but you couldn't with XList
15:53:50 <mcstar> Puffton: which function is that?
15:54:40 <mcstar> i dont want to read the whole code, which part is equivalent with the one i pasted?
15:54:46 <Saizan> Rc43: you can only pattern match on a XList () or XList Char, not a "XList a"
15:55:13 <Puffton> evaluateNodes
15:56:32 <Rc43> Saizan, it's clear now; thanks
15:56:39 <Puffton> I made sure my output starts with the root node, so the input to this function will always start with the root node now I think
15:57:41 <mikeplus64> > () :: () => ()
15:57:43 <lambdabot>   ()
15:57:49 <mikeplus64> (what?)
15:58:13 <astry> > 2 :: Int -> Int
15:58:14 <lambdabot>   *Exception: show: No overloading for function
15:58:20 <astry> interesting
15:58:31 <Polarina> I'm doing some space profiling on my litte project. It tells me clearly in what several places it is producing all the garbage, but how can I know how I should fix that?
15:58:37 <astry> anyways, mikeplus64, () is of the type ()
15:58:41 <astry> in case you didn't know
15:58:47 <alpounet> mike2, empty constraint i guess
15:58:50 <alpounet> > 1 :: () => Int
15:58:50 <mikeplus64> astry: yeah, i'm confused about the constraint though
15:58:51 <lambdabot>   1
15:58:58 <astry> and i'm not sure what "() =>" means but it probably means nothing at all.
15:59:00 <astry> yeah.
15:59:08 <astry> > 2 :: () => Int
15:59:09 <lambdabot>   2
15:59:28 <mikeplus64> > ()::((),())=>()
15:59:30 <lambdabot>   Type constructor `()' used as a class
15:59:46 <Saizan> > 3 :: Show Char => Int
15:59:47 <lambdabot>   3
15:59:51 <mikeplus64> > ()::()=>()=>()
15:59:53 <lambdabot>   ()
16:00:17 <Iceland_jack> ()::()=>()=>()
16:00:22 <mcstar> Puffton: if you already have a map, why do you turn it into a list?
16:00:30 <astry> i have a question
16:00:35 <mcstar> evaluateNodes (M.toList e)
16:00:38 <astry> is it possible to pass a program to ghci on command line?
16:00:46 <astry> something like python -c
16:00:54 <Puffton> mcstar, I used two list comprehensions instead
16:01:01 <Puffton> and pattern matching
16:01:03 <rwbarton> ghc -e
16:01:06 <Puffton> it doesn't work on maps right?
16:01:09 <astry> thanks rwbarton
16:01:13 <Iceland_jack> astry: runhaskell <(echo 'module ...') ;)
16:01:42 <mcstar> Puffton: i mean, it is just better to recurse on key-value pairs with the map
16:01:43 <astry> Iceland_jack: right, i know about runhaskell, but i always keep on forgetting about file redirections
16:01:44 <rwbarton> ghc -e expects an expression that evaluates to an IO action I think
16:01:56 <Iceland_jack> astry: It's not a file redirection
16:01:57 <astry> rwbarton: yeah, it does
16:01:58 <rwbarton> or maybe a value that can be Shown
16:02:01 <Iceland_jack> but I did mean it as a joke
16:02:05 <astry> Iceland_jack: what do you call those then
16:02:15 <astry> Iceland_jack: it creates a file from an immediate string
16:02:55 <Iceland_jack> Process substitution
16:03:02 <astry> oh ok
16:03:04 <mcstar> say, this is the map, {v4: (v3,v2), v2: (v1)} and you know that v4 is the root, and just call an output function on v4, that will call itself on v3 and v2, etc
16:03:08 <mcstar> Puffton: ^^
16:04:08 <mcstar> Puffton: thats what i did, and a little preprocessing, to deal with your input format, and the root finding function
16:04:25 <mcstar> (the root is the element that no vertex points to)
16:04:37 <trebla> (testing)
16:04:41 <trebla> !list
16:04:41 <monochrom> trebla: http://okmij.org/ftp
16:05:01 <mcstar> !listcomprehension
16:05:05 <monochrom> heh
16:05:23 <Puffton> mcstar, but it doesn't have to be called "v1" necessarily
16:05:34 <mcstar> Puffton: thats not the roots name
16:05:34 <Puffton> in my latest example it was reversed, so v4 or something
16:05:37 <mcstar> it is a trial name
16:05:41 <mcstar> it finds the real root
16:06:02 <mcstar> you could set it to the first vertex of the input list
16:06:05 <mcstar> doesnt matter
16:07:00 <mcstar> (otherwise it would be pointless to call my function findRoot, if you have to give it the root, wouldnt it?)
16:10:26 <Puffton> yes
16:12:29 <ski> (mcstar : .. maybe `fix' ?)
16:12:57 <mcstar> i cant stand 3 letter labels
16:13:36 <ski> no, i meant something like `fix $ \r -> findRoot ..r..'
16:13:56 <mcstar> yeah, i thought that you saw something i didnt
16:14:17 <mcstar> if you say so, it would work
16:14:43 <mcstar> it is a sort of fixpoint
16:14:43 <ski> hm, for some reason i thought you were talking about finding the root of an equation
16:14:53 <mcstar> ah no
16:15:00 <mcstar> but it is a fixpoint
16:15:08 <mcstar> since if you give it r, it will return r
16:15:10 <mcstar> and only then
16:15:15 <ski> mcstar> :t findRoot
16:15:25 <mcstar> lol, right
16:15:30 <ski> ?
16:15:35 <mcstar> root as in root vertex/node
16:16:00 <mcstar> ski: it finds the root of the tree
16:16:16 <ski> what if the graph is disconnected ?
16:16:38 <Puffton> it never is :)
16:17:29 <ski> i suppose one might define a `findRoots' function and then use `head' on that
16:17:40 <ski> (or better, matching on `[root]')
16:18:13 <mcstar> (v4:  (v3: FOXP4_DOG FOXP4_COW )  (v2:  (v1: FOXP4_RAT FOXP4_MOUSE ) FOXP4_FROG ) FOXP4_HUMAN )
16:18:16 <mcstar> this is the output
16:18:29 <Puffton> ski, we are talking about this lab: http://www.csc.kth.se/utbildning/kth/kurser/DD1361/progp12/labbar/f3/ (Warning: Swedish)
16:19:03 <Puffton> mmh
16:19:47 <Puffton> http://hpaste.org/75733
16:19:49 <Puffton> And this is how I solved it
16:19:58 <Puffton> but I will spend a bit more time with the newick-stuff
16:20:03 <Puffton> it doesn't sit entirely right with me
16:20:19 <Puffton> but mcstar yours is a bit complex for me
16:20:24 * ski undrar stilla varför Puffton inte också är i #haskell.se
16:20:25 <Puffton> I'm still n00b
16:20:40 <Puffton> didn't know it existed :p
16:20:56 <mcstar> how can i extract an undrar archive?
16:21:16 <Puffton> it is encryptet with the enigma
16:21:18 <Puffton> from WW2
16:21:22 <Puffton> encrypted*
16:21:31 <Puffton> Muhahah!
16:21:36 <mcstar> Puffton: your code must be doing much more stuff
16:21:45 <mcstar> whats the whole problem?
16:21:58 <mcstar> (not that i want to solve it, just asing)
16:22:00 <mcstar> asing*
16:22:03 <mcstar> asking*
16:22:13 <Puffton> I am building the tree too
16:22:19 <Puffton> I get DNA/Protein sequences
16:22:26 <Puffton> check how much they differ
16:22:39 <Puffton> and build the tree from which we build our newick tree
16:23:07 <mcstar> id love to do work like that
16:24:13 <Puffton> how do you mean mcstar?
16:24:24 <mcstar> for a living
16:24:48 <mcstar> getting paid for
16:24:55 <Puffton> oh, ok
16:25:09 <Puffton> do you work now? or are you a student?
16:26:18 <mcstar> finishing it
16:26:31 <pnielsen> join #haskell.se
16:26:34 <pnielsen> whoops
16:27:00 <Puffton> #haskell.se seems like the place to be :p
16:27:37 * Polarina thinks the RTS just crashed. "Segmentation fault/access violation in generated code"
16:33:09 <Puffton> mcstar, masters in CS?
16:33:25 <mcstar> no, physics
16:33:28 <Puffton> oh ok
16:36:03 <zzing> Is there any functions that can allow me to output the type of something, even if it is evil? My yesod program cannot be loaded into ghci (or I haven't figured out how), so this would be a very handy thing for me
16:36:07 <Puffton> ski, toStr = intercalate ", "
16:36:31 <Puffton> this is a function without any specified arguments right? but it will still be piped if I send an arg
16:37:00 <byorgey> zzing: if the type in question is an instance of Typeable, you can use the typeOf function
16:37:19 <zzing> :t typeOf
16:37:21 <lambdabot> forall a. (Typeable a) => a -> TypeRep
16:37:33 <byorgey> zzing: otherwise there is really no way, there is no type information available at runtime
16:37:40 <zzing> Can I use show on that?
16:37:43 <byorgey> yes
16:37:54 <liyang> But there is type information at compile time!
16:38:15 <pnielsen> Puffton: http://osdir.com/ml/beginners@haskell.org/2012-09/msg00208.html
16:38:21 <byorgey> zzing: ah, but this won't do you any good if you can't even compile your program in the first place
16:38:21 <Puffton> so, is it a function? :P
16:38:36 <zzing> byorgey, I have it in the state now where I can compile it
16:38:44 <byorgey> zzing: it sounds like what you really want is the "holes" feature that just went into GHC HEAD... so just wait a month or six for a new version of GHC to be released ;)
16:38:48 <byorgey> zzing: ah, ok
16:38:53 <zzing> I have no idea what holes are
16:39:06 <byorgey> zzing: it lets you put _ in place of some term you don't know
16:39:10 <zzing> Where is this typeOf function?
16:39:11 <pnielsen> zzing: "customizable undefineds"
16:39:15 <pnielsen> there's a good thread on reddit about it
16:39:18 <byorgey> then when you compile it GHC will tell you what type needs to go in the hole
16:39:31 <zzing> That sounds handy
16:39:32 <byorgey> @hoogle typeOf
16:39:32 <lambdabot> Data.Typeable typeOf :: Typeable a => a -> TypeRep
16:39:33 <lambdabot> Data.Typeable typeOf1 :: Typeable1 t => t a -> TypeRep
16:39:33 <lambdabot> Data.Typeable typeOf1Default :: (Typeable2 t, Typeable a) => t a b -> TypeRep
16:39:37 <zzing> ok
16:39:39 <pnielsen> zzing: http://www.reddit.com/r/haskell/comments/10u7xr/ghc_head_now_features_agdalike_holes/
16:39:45 <pnielsen> aeipp's comment
16:39:49 <pnielsen> aseipp*
16:39:56 <zzing> I am stuck with ghc 7.4.1 until haskell platform/yesod catch up
16:40:19 <byorgey> zzing: right, I wasn't really suggesting to upgrade =)
16:40:23 <monochrom> me too :)
16:40:25 <ion> The Haskell community now features Agda-like ’holes.
16:40:37 <zzing> Have you guys tried idris lately?
16:41:17 <pnielsen> ion: http://www.youtube.com/watch?v=2SmoBvg-etU
16:42:04 <Puffton> pnielsen, I just started thinking of what is a function and what isn't
16:42:09 <Puffton> where the line is
16:42:22 <Cale> ion: what's that ’
16:42:32 <zzing> Now when I get     No instance for (Typeable (DocumentGeneric SqlPersist))    does that give me the same information I could use?
16:42:54 <ski> Puffton : .. yes
16:42:59 <pnielsen> Puffton: in Haskell most things are. I recommend Learn You A Haskell, it's very good: http://learnyouahaskell.com/chapters
16:43:11 <Puffton> I'm reading it as we speak pnielsen
16:43:15 <pnielsen> coolbeans
16:43:22 <Puffton> I was just discussing earlier today, if
16:43:33 <Puffton> a function without arguments is a function :p
16:43:52 <zzing> If I have a pattern that normally would be like   case … of    match1 ->   if ( … ) … this and that   where things kind of nest, are there general strategies that I can follow so that this is not really a problem?
16:44:17 <ski> Puffton : you can "shorten" `toStr xs = intercalate ", " xs' to `toStr = intercalate ", "'
16:44:24 <pnielsen> zzing: indent by two spaces
16:44:51 <zzing> pnielsen, not quite the idea I was looking for :-)  (and it is four spaces or the noose for you)
16:44:54 <pnielsen> it's better to have many levels of indentation than break the flow/readability a la imperative returns IMO
16:45:03 <Puffton> ski yeah I did that
16:45:08 <Puffton> or was it there now?
16:45:09 <ski> zzing : paste what you've got ?
16:45:31 <zzing> ski, I can only give an idea because of my code not being fully written yet
16:45:31 <Puffton> http://hpaste.org/75733 <- latest version
16:45:43 <pnielsen> zzing: you might be able to split up some of the cases into individual x, y, z and put them in a where statement instead
16:46:31 <pnielsen> if you paste it, somebody can probably suggest something
16:46:53 <zzing> ski, http://hpaste.org/75734   Line 59 is where I would be nesting. What I need to do is extract the document out
16:47:15 <zzing> The code at the bottom is close to what needs to be done, (works for listPages) but this is a little bit more involved
16:48:45 <monochrom> use a 50" HDTV to solve deep indentation problems
16:48:46 <ski> zzing : should i ignore lines `65' through `67' ?
16:49:05 <pnielsen> change to a really small font
16:49:10 <pnielsen> change to a font where four spaces appear as two spaces
16:49:28 <zzing> ski, those were kind of old, but generally
16:49:39 <Rc43> With -XDataKinds there are available such lines in haskell: `data Nat = Ze | Su Nat <\n> data XList :: * -> Nat -> * where <\n> XNil :: XList a Ze <\n> XCons :: a -> XList a n -> XList a (Su n)`.
16:49:39 <zzing> It appears that documentContent $ value   is of type Text
16:49:41 <zzing> So I am close
16:50:04 <Rc43> How can we interpret Ze and Su as type-level values?
16:50:20 <Rc43> I mean, we use data constructors on type-level.
16:50:33 <Cale> Rc43: that's what the extension does?
16:50:37 <absence> http://hpaste.org/75735 <- does this suggest a space leak in stepWireM, or is there something else that can cause the memory error?
16:50:56 <Rc43> Cale, I didn't understand fully; does it?
16:51:18 <Rc43> cale, I thought it introduces * -> * -> * notation.
16:51:19 <zzing>                     Just (Entity _ value) -> liftIO $ putStrLn (unpack (documentContent $ value))  seems to work
16:51:19 <Cale> Rc43: It lets you use Ze and Su as type constructors
16:51:34 <Cale> Rc43: No, that's turned on by most extensions
16:51:45 <Cale> (it's just explicit kind quantification)
16:52:13 <Cale> (minimally, it's turned on by KindSignatures)
16:52:25 <Rc43> Cale, it is near to dependent types if I understand correctly; why we can't use e.g. 0, 1, 2 as type-level constants?
16:52:36 <Rc43> Cale, or we can?
16:52:41 <Cale> Rc43: Because you're not using GHC 7.6.1 yet
16:53:08 <Rc43> Cale, type-level literals extension?
16:53:21 <Cale> yes
16:53:35 <Rc43> Cale, cool
16:53:45 <Rc43> So it is depndent types?
16:53:47 <Cale> no
16:53:57 <zzing> ok, more interesting question for http://hpaste.org/75736   now that I can get a Text / String value, how can I take the value (documentContent value) and return it from getPage on line 55/59, with the inner context I am in?
16:54:14 <Cale> Rc43: Dependent types would mean that you can do anything you can normally do with values up at the type level.
16:54:39 <Rc43> Cale, now I can only construct but can't use functions?
16:54:42 <Cale> yeah
16:54:45 <Rc43> :(
16:55:04 <Cale> and you'd be allowed to use arbitrary complex datatypes
16:56:07 <Cale> (the promotion is good, but it is fairly limited in scope of what it tries to lift to the type level)
16:56:56 <thoughtpolice> with all these cool new extensions, it feels like the inevitable result is dependent typing :P
16:56:59 <byorgey> (note that lifting the restrictions on what is promotable is actively being worked on)
16:57:05 <byorgey> (though not by me)
16:57:22 <Cale> thoughtpolice: indeed
16:57:28 <byorgey> thoughtpolice: that's not an accident =)
16:57:45 <thoughtpolice> :D
16:58:11 <thoughtpolice> byorgey: what could we possibly do in the future? i remember a really old talk you gave was about promoting some functions to the type level
16:58:46 <byorgey> yeah, promoting functions would be one thing
16:59:22 <Cale> If I had to summarise a large amount of SPJ's type system research it's been all about figuring out how to keep complete type inference in "simple" programs while making the system more and more like a dependently typed one.
17:00:12 <absence> mm_freak: i'm seeing some high memory usage with netwire and narrowed down a test case: http://hpaste.org/75735 does that mean there's a space leak, or am i doing something wrong?
17:00:27 <byorgey> note there is http://hackage.haskell.org/package/singletons, http://www.cis.upenn.edu/~eir/papers/2012/singletons/paper.pdf, http://www.youtube.com/watch?v=rLJ_YyVRKzs
17:00:38 <byorgey> which has already done a lot of work on the theory of lifting functions
17:00:43 <thoughtpolice> i've seen singletons, but i haven't tried it yet
17:00:49 <byorgey> Cale: sounds accurate
17:00:54 <ew0> hey
17:01:06 <ew0> what are the tricks to findout where my fromJust is exploding?
17:01:27 <thoughtpolice> Cale: it seems kind of like the semi-opposite from theorem provers, where they eventually get more features to be more of a programming language, and start off all dependent type-y and whatnot at the start
17:01:58 <thoughtpolice> i've gotten a lot more interested in learning agda recently; in the past, i tried using it, but mostly wrote actual programs, which is kind of rough :P
17:02:28 <Cale> I've been wanting to really dig into homotopy type theory, so I'll probably end up learning both Agda and Coq now.
17:02:56 <Cale> I understand enough on either side of the bridge which is being built there to maybe do something useful.
17:03:30 <thoughtpolice> ew0: in ghc 7.4+, you can compile your program with profiling, and the runtime system can give you a stack trace
17:03:42 <Cale> thoughtpolice: have you heard anything about that stuff?
17:03:51 <ew0> tare to chare the docs?
17:03:56 <ew0> share*
17:04:01 <ew0> care*
17:04:03 <thoughtpolice> (by passing an argument to your executable, i think it's something like, './foo +RTS -xc' i think?)
17:04:12 <ew0> uhm
17:04:30 <Cale> In fact, that flag has been around for ages
17:04:44 <Cale> It just changed in behaviour in 7.4.1
17:04:49 <thoughtpolice> Cale: homotopy? i have, but i've not enough type-theory foo to really understand it
17:04:59 <thoughtpolice> right, stack traces are new in 7.4 and beyond
17:05:25 <ew0> thanks: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/runtime-control.html#rts-options-debugging
17:05:27 <Cale> It always gave a cost-centre trace, but now the way that cost centres are recorded into stacks has changed
17:05:37 <ew0> this is what you are talking about, right?
17:05:46 <Cale> ew0: yes
17:05:57 <thoughtpolice> yep, -xc is the ticket
17:06:08 <thoughtpolice> there are also a few functions in base you can use to dump a stack trace
17:06:14 <thoughtpolice> you could probably find them with hoogle
17:07:01 <Cale> ew0: then you can figure out approximately where in the code it's happening, and maybe insert some Debug.Trace.trace to print out parameters to whatever function that made it happen, or just stare at the code a bit and play with it to understand why it's failing.
17:07:09 <Cale> Better yet, remove the use of fromJust
17:07:27 <Cale> fromJust is bad unless you can prove that it's not going to fail
17:07:43 <latro`a> honestly it's bad even then >.>
17:08:02 <thoughtpolice> i just assume you can never legitimately prove that :)
17:08:15 <thoughtpolice> and if you can, and you had to explain that to someone, you should probably just rewrite it anyway to not be confusing
17:08:39 <Cale> Well, this applies to head, but there are things like  map head . group . sort
17:08:46 <Cale> which are okay
17:09:15 <Cale> (maybe that could be  concatMap (take 1) . group . sort)
17:09:18 <ew0> it should not fail xD
17:09:35 <ew0> the unit tests are fine
17:09:43 <ew0> but I'm intergating everything now
17:09:56 <ew0> and I probably made some mistakes
17:09:59 <Cale> ew0: are they just single unit tests, or quickCheck tests?
17:10:09 <thoughtpolice> yeah, or doing something like 'head . sort' to take a list minimum is fine. in general i try a lot to just avoid it though, even if it's convenient sometimes
17:10:14 <ew0> single unit tests
17:10:33 <ew0> I have some input data and output data
17:10:36 <ew0> ready from other tool
17:10:46 <Cale> thoughtpolice: well, especially after group, because group never produces empty lists as elements of its result
17:10:59 <Cale> (but you have to trust that :)
17:11:48 <Rc43> How long ago kinds appeared in haskell?
17:11:57 <Cale> Rc43: they're mentioned in the standard
17:12:47 <Rc43> Cale, seems I need to read something monolithic about haskell
17:12:51 <thoughtpolice> there's always been a concept of kinds for things like type constructors, the idea surely predates haskell with ML etc.
17:12:57 <Cale> Rc43: but the kind system was very simple, and all kinds in Haskell 98 (and previous ones) could basically be inferred from context
17:13:05 <Cale> Rc43: so no syntax was introduced for them
17:13:32 <Rc43> Cale, ok, just didn't hear
17:14:13 <Cale> Rc43: There's * (the kind of types with values in them), and for any kinds k1 and k2, there's the kind k1 -> k2 of type constructors which take a parameter of kind k1 and produce a result with kind k2
17:14:28 <Cale> Rc43: and that's all
17:14:40 <Rc43> Cale, simple
17:15:06 <ew0> uhm, it seems I don't have the profiling libraries installed
17:15:32 <Cale> ew0: yeah, I consider it a bit of a bug in cabal that the default configuration doesn't have library profiling turned on
17:15:57 <ew0> is there a quick guide on how to turn it on on debian?
17:16:01 <Cale> ew0: if you look at ~/.cabal/config
17:16:21 <Rc43> Cale, is `* -> *` equal to `(forall a b) a -> b`? Why we need kinds? Or we don't need them, they just exist as simplified form?
17:16:34 <Cale> ew0: you want  library-profiling: True
17:16:40 <dcoutts_> I'm think we can't flip the default until we track profiling separately from normal, or we'll double everyone's build times and get lots of complaints
17:16:46 <Rc43> Cale, aaah; no; they aren't equal
17:16:48 <Cale> ew0: and while you're at it, probably also  documentation: True
17:17:33 <ew0> is the -- before the config a comment?
17:17:38 <ew0> should I delete it?
17:17:41 <Cale> dcoutts_: I will happily double my build times from the beginning than have to sort out the mess of having to recompile all my installed packages with profiling later...
17:17:55 <liyang> Rc43: it's more like: forall a b. a -> b :: * -> * -> *
17:17:56 <Rc43> Cale, or they are; do type like `Map Int -> Map String` exist?
17:17:57 <dcoutts_> Cale: but not everyone
17:18:02 <Puffton> Can I use hlint anywhere online
17:18:05 <Puffton> except hpaste?
17:18:07 <Cale> Rc43: no, that doesn't exist
17:18:13 <Puffton> I often want to run hlint but not paste all my code online
17:18:15 <Cale> Rc43: and that's what the kind system prevents
17:18:17 <ew0> how do I reinstall everything?
17:18:26 <Cale> Rc43: (->) on the type level has kind * -> * -> *
17:18:42 <Cale> and Map Int :: * -> *
17:18:42 <otters> there is no aspell binding for Haskell!
17:18:49 <Rc43> Cale, cool
17:18:51 <Cale> Rc43: which doesn't match *
17:19:04 <Cale> so you get a kind error if you try to write Map Int -> Map String
17:19:40 <danharaj> where do you guys put your quickcheck tests in your module hierarchy?
17:20:36 <Cale> danharaj: I usually just put them alongside the code that's being tested, and if the QuickCheck import is a problem later, I just comment it out. There's probably something better than that though...
17:20:38 <joeyh> ew0: If you're using the ghc package from debian, you can apt-get install ghc-prof to get all the base libraries with profiling. There are also libghc-*-prof packages to go with any libghc-* packages you installed from Debian.
17:21:07 <ew0> thanks!
17:21:14 <danharaj> Cale: I was thinking of putting it at the end so if I have a quickcheck module for Foo it would go in Foo.Quickcheck.
17:21:17 <latro`a> Rc43, you are probably thinking of Map Int a -> Map String b, or similar
17:21:20 <danharaj> But then I have a proliferation of folders.
17:21:22 <latro`a> which is entirely valid
17:21:43 <danharaj> Alternatively I could mirror the hierarchy with the added root Quickcheck.
17:22:06 <ew0> I installed everything with cabal
17:22:12 <joeyh> ew0: and I think cabal install --reinstall for the rest
17:22:21 <ew0> thanks!
17:22:48 <Rc43> latro, yes, it is valid; but I thought about type with incomplete parametes; just didn't grasp
17:23:47 <ew0> hey, is there a way to make a .cabal file quickly?
17:23:52 <ew0> I don't have one
17:23:55 <dcoutts_> cabal init
17:29:39 * hackagebot stylish-haskell 0.5.2.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.2.0 (JasperVanDerJeugt)
17:29:44 <cieplak> Does anyone here have experience in pitching the use of Haskell on a project, in lieu of Java?
17:31:06 <frio> ive got experience in failing
17:31:12 <nejucomo> cieplak: heh...  not here.  Good luck.
17:31:46 <cieplak> Haha thanks
17:32:14 <dcoutts_> cieplak: clients of our have, though of course as a Haskell consultant, the people who get as far as talking to us tend to have had some success already
17:32:20 <cieplak> I love haskell and use it for all my personal projects,
17:32:49 <Polarina> I always regret deciding not to use Haskell.
17:32:49 <cieplak> and as a consultant I talk about it a lot,
17:32:53 <nejucomo> What kind of code is it for?  ie: Interactive tool?  Network/storage infrastructure?  Numerical analysis?
17:33:10 <nejucomo> What kind of application?
17:33:14 <cieplak> but it's hard when you have teams of seasoned C++ developers
17:33:29 <cieplak> Asset Management application
17:33:36 <cieplak> risk rating stuff
17:33:44 <cieplak> portfolio of 10,000 mortgages
17:33:46 <dcoutts_> cieplak: teams does make it harder, if everyone needs to be involved
17:34:38 <dcoutts_> cieplak: sounds like a well-suited application area for it
17:34:38 <cieplak> This project will certainly be done with Grails
17:34:39 <nejucomo> I think there's a strong argument that Java has mature debugging, profiling, and deployment helper tool chains and the total engineer-years of experience is much larger than for ghc.
17:34:59 <copumpkin> MOARtgages
17:35:24 <cieplak> but I want to figure out ways of introducing haskell to smaller projects, and
17:35:41 <dcoutts_> cieplak: prototyping is always a good route in
17:35:50 <carter> cieplak consulting is hard! :) i'm stumbling into doing some here an there myself
17:35:51 <cieplak> thereby demonstrating its excellence
17:36:08 <nejucomo> Yeah, I think a good approach is to introduce it in small pieces.  Start with some standalone tools, make them simple and usable, invite other developers to contribute new features or bugfixes.
17:36:40 <nejucomo> Similar route to the prototyping approach.
17:36:56 <dcoutts_> cieplak: some clients of ours have also had success with simply going to their boss and telling them it's the best tool for the job
17:36:58 <cieplak> nejucomo: I agree; the advantage of haskell though is speed of development and correctness
17:37:17 <nejucomo> Prototyping approach is good because you always leave the door open to rewrite it in another language... and if there's a rewrite, then you can compare the two implementations.
17:37:30 <cieplak> dcoutts: That's rather bold but I could see it working
17:37:47 <dcoutts_> cieplak: it depends a lot on the relationship between developer and manager
17:37:53 <carter> cieplak one problem you may have is there may not be tools apriori in haskell for your specific odmian
17:38:21 <carter> cieplak: yeah... you can just have the haskell code be your spec :)
17:38:37 <dcoutts_> cieplak: but there are some managers who trust their developers on technical issues
17:38:38 <cieplak> Has anyone does much work with XML using haskell?
17:38:39 <carter> and run examples to check that its the desired behavior
17:38:49 <carter> theres a bunch of XML libs
17:39:11 <ew0> is there a way to make cabal compile with more threads?
17:39:13 <bfig> is there a function to split at a certain position, like signature: (a->Bool)->[a]->([a],[a])
17:39:24 <dcoutts_> ew0: only for multiple packages, -j
17:39:41 <ew0> uhm
17:39:56 <mapreduce> @hoogle (a -> Bool) -> [a] -> ([a], [a])
17:39:56 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
17:39:56 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
17:39:56 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
17:40:13 <mapreduce> > break (>10) [1..20]
17:40:13 <dcoutts_> ew0: oh, and only for the very latest cabal version
17:40:14 <lambdabot>   ([1,2,3,4,5,6,7,8,9,10],[11,12,13,14,15,16,17,18,19,20])
17:40:22 <mapreduce> bfig: How's that?
17:40:27 <ew0> xD
17:40:30 <ew0> I don't have it
17:40:33 <ew0> debian is a bit slow
17:40:35 <bfig> mapreduce, :)
17:40:37 <bfig> ty
17:40:53 <dcoutts_> ew0: it's only cabal install cabal-install :-)
17:41:02 <bfig> gonna have to check out the lists again... maybe they are not exactly suited for what i'm doing and i should be using some other datatype :p
17:41:26 <geisthaus> hello bfig
17:41:34 <bfig> hello geisthaus
17:41:38 <dcoutts_> cieplak: so are you in a consultant position, or within the organisation?
17:42:08 <cieplak> I am an analyst that works at a client site
17:42:31 <cieplak> my firm is FI Consulting
17:42:33 <Axman6> do the developers at the client know haskell at all?
17:42:46 <dcoutts_> cieplak: btw, an excellent case for prototyping in financial uses, is translating from a spreadsheet, ie the person who comes up with the calculations makes a spreadsheet, and the dev translated it into a proper program.
17:43:00 <cieplak> Axman6: No
17:43:08 <Axman6> if knot, it's almost certainly the wrong tool for the job, even if it is the right tool for the job
17:43:11 <cieplak> Axman6: Actually, one
17:43:17 <Axman6> not* how did that happen
17:43:50 <cieplak> Axman6: He read Learn You a Haskell
17:44:18 <dcoutts_> Axman6: that's not quite true, we're working with people who don't know Haskell yet, but want the advantages
17:44:29 <carter> cieplak: dcoutts_  has an excellent point: make it a case of "you can just write down the math"
17:44:45 <cieplak> That is a good idea
17:45:01 <dcoutts_> right, and you can actually show the person who wrote the spreadsheet
17:45:14 <dcoutts_> and they'll see it's a lot simpler than Java
17:46:00 <dcoutts_> and then you casually drop in benefits like easier parallelisation etc
17:46:03 <cieplak> basically we're going to rebuild a spreadsheet with a database backend so that it is a web application
17:47:19 <dcoutts_> cieplak: if you get lucky, and need some help later, we help companies that use haskell, http://www.well-typed.com/
17:47:27 * dcoutts_ has to disappear now
17:49:09 <cieplak> dcoutts_: Thanks
17:50:36 <Taslem> Hi. I'm looking for an efficient implementation of the partition function of n (that is, the function that counts the number of partitions of a natural number 'n')
17:50:40 <Taslem> Anyone know of any resources?
17:51:00 <cieplak> dcoutts_: What sorts of businesses are you currently helping develop haskell projects?
17:51:24 <cieplak> I would guess businesses in the financial sector,
17:51:27 <dcoutts_> cieplak: some tiny, some really big (but small teams)
17:51:32 <dcoutts_> cieplak: yes, and related
17:51:43 <dcoutts_> related/similar
17:52:29 <cieplak> My girlfriend is working on her phd in chemical engineering, and she recently fell in love with haskell
17:53:11 <cieplak> It was because of 'Learn You a Haskell for Great Good'
17:53:16 <dcoutts_> nice
17:53:35 <dcoutts_> we find some people love it, some find it gets annoying after a while
17:53:48 <cieplak> It never ceases to make me laugh
17:54:01 <dcoutts_> it's certainly on our recommended list, with that caveat
17:54:41 * hackagebot language-objc 0.4.2.5 - Analysis and generation of Objective C code  http://hackage.haskell.org/package/language-objc-0.4.2.5 (JohnLato)
17:54:53 <Taslem> Anyone know of any resources on partitions?
17:55:15 <cieplak> hackagebot: +1
17:55:34 <BMeph> Taslem: Wikipedia and Wolfram Alpha. :)
17:55:48 <Taslem> BMeph: They provide algorithms with O(2^n) complexity.
17:55:58 <ski> Taslem : perhaps Cale knows of some better algorithm ..
17:56:34 <dcoutts_> hmm, nice, language-objc is based on my C parser :-)
17:56:49 <shapr> dcoutts++
17:58:48 <cornihilio> hey, could somebody please help me understand what I am doing incorrectly here?: https://gist.github.com/3830880
17:59:31 <cornihilio> I think the main problem is that I am using S.readInt, but I am not sure what alternative I should be looking for
18:01:46 <cieplak> Good evening, fellows, off to watch the US presidential debate
18:01:56 <ew0> lol
18:02:13 <ew0> my fromJust was blowing in a place just beside a -- TODO fix this later
18:05:39 <fengshaun> how can I map read?  map (read :: Int) [some string list] fails with "couldn't match expected type 'Int' with type 'String -> a0'"
18:06:09 <ski> `read :: String -> Int' ?
18:06:56 <ski> would possibly be better to use `reads :: ReadS Int' (and no `map'), though ?
18:07:32 <fengshaun> ski, thanks, I didn't know about reads
18:08:05 <pharaun> @pl curry f x y = f (x, y)
18:08:06 <lambdabot> curry = (. (,)) . (.)
18:08:51 <ski> fengshaun : `reads' is used to read some value from a string, and get the rest of the string to continue reading from
18:09:17 <fengshaun> thanks!
18:09:27 <fengshaun> doesn't look like what I'm looking for
18:09:46 <fengshaun> I have a list of int-looking strings like ["123", "234", etc.]
18:10:29 <ski> `reads' would be used before (instead of) you're splitting your string into that list of strings
18:10:55 <ski> fengshaun : otherwise, try `read :: String -> Int' as i suggested (but parse errors will stop the program)
18:11:07 <ski> cornihilio> :t S.readInt
18:11:46 <fengshaun> thanks a lot for your help!
18:12:28 <cornihilio> I'm going kind of nuts trying to write this parser... how do you guys handle it? My programming experience so far has been "add a print statement if you don't know what you are doing" and Haskell seems to become very livid at that notion.
18:12:29 <ski> > map (read :: String -> Int) ["123","234","345"]
18:12:30 <lambdabot>   [123,234,345]
18:12:38 <ski> > map read ["123","234","345"] :: [Int]
18:12:39 <lambdabot>   [123,234,345]
18:12:51 <ski> > map (\s -> read s :: Int) ["123","234","345"]
18:12:52 <lambdabot>   [123,234,345]
18:13:00 <ski> > map read ["123","234","oops","345"] :: [Int]
18:13:02 <lambdabot>   [123,234,*Exception: Prelude.read: no parse
18:13:03 <Jafet> @quote oasis
18:13:04 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
18:13:51 <mm_freak> absence: yes, i see a memory leak there
18:13:56 <cmccann> hooray for unsafePerformPrintfDebugging
18:14:04 <mm_freak> absence: try:  return $! y
18:14:09 <mm_freak> absence: instead of return y
18:14:21 <ski> cornihilio : are you sure you want to discard the second part of the pair you may get from `S.readInt' ?
18:15:19 <cornihilio> ski: nope. I have no clue what I should be trying to do. That's kind of why I want to start adding print/logging statements willy-nilly but I'm not sure how.
18:15:41 <cmccann> cornihilio, try the Debug.Trace module
18:16:16 <cmccann> a.k.a. good old-fashioned printf debugging, like I did in C before discovering real debuggers
18:16:43 <cmccann> but it gets the job done, or at least a job of some sort
18:17:58 <Polarina> I find printf debugging favourable when I just have to add at most two or three of them to figure out the problem. Otherwise I grab my nearest debugger.
18:18:42 * Polarina notes that this does not apply to Haskell programming.
18:18:46 <cornihilio> do people use debuggers with haskell outside of GHC work?
18:19:33 <cmccann> stepping through lazy evaluation in a debugger is not very intuitive
18:19:57 <monochrom> @quote lazy.*ADHD
18:19:58 <lambdabot> cmccann says: you want a debugger? GHC has one. Except that stepping through lazy evaluation is like listening to a stream of consciousness narrative told by a 5-year-old with ADHD.
18:20:04 <cmccann> heh
18:20:09 <monochrom> I just learned of that one from HWN!
18:25:58 <Cale> I'm just realising that it might be a good idea for someone to make a pretty binding to this: http://flintlib.org/
18:26:31 <Cale> http://sage.math.washington.edu/home/fredrik/flint/timings.html#special -- it has some absurdly good implementations of things
18:27:15 <cornihilio> uh... how do I add more trace statements to this?: https://gist.github.com/3830961
18:29:05 <Cale> cornihilio: Is acc always 0 in that?
18:29:30 <Cale> (maybe I'm blind, but I don't see a recursive call to count)
18:30:19 <Cale> cornihilio: A nice trick is to do something like
18:30:56 <Cale> count acc p | trace (concat ["acc ", show acc, " ", show p]) False = undefined
18:31:27 <Cale> (which you can add before the main body of the function, and later comment out to disable tracing)
18:32:03 <Tordek> hi
18:32:11 <Cale> hello
18:32:28 <Tordek> what's this syntax?: "sipRound k Sip{..} = k (Sip v0_c v1_d v2_c v3_d)"  in particular, the Sip{..}
18:32:32 <Tordek> part
18:32:59 <ew0> its a constructor, isnt?
18:33:07 <Cale> Tordek: That locally binds the fields of the Sip data constructor to the values of that parameter
18:33:17 <Cale> to the values extracted from that parameter
18:33:47 <Tordek> ah, so it's like (Sip v0 v1 v2 v3)?
18:34:00 * Polarina has not seen that syntax before. Interesting.
18:34:07 <Cale> yes
18:34:13 <Tordek> cool beans, thanks :)
18:34:14 <ew0> yup
18:34:35 <Polarina> What is that syntax called? I want to read more about it.
18:34:47 <Cale> RecordWildCards
18:34:53 <Polarina> Cale, thanks.
18:35:14 <Cale> It is also really nice for doing object oriented programming in Haskell
18:36:06 <Cale> data Object = Obj { step :: DeltaTime -> Object, draw :: IO (), ... }
18:36:26 <Cale> ball position velocity = Obj { .. }
18:37:04 <Cale>   where step dt = ball (position ^+^ velocity) (0.9 *^ velocity)
18:37:28 <Cale> and then draw also, you get the idea
18:37:29 * Polarina refactors some code.
18:37:59 <Cale> The one bad thing about it is that it binds names without mentioning them.
18:38:31 <Cale> which can make it a little harder to see in the code where some things are coming from
18:38:49 <cornihilio> Cale: okay, that helps me get a better idea of what's going on, but I'm not sure I'm using it right. Right now I just plopped into my code like this: https://gist.github.com/3831000
18:39:05 <Cale> cornihilio: that's right
18:39:17 <Cale> cornihilio: That'll show you all the calls to count which are actually evaluated
18:39:32 <Polarina> I add a prefix to all my constructors, like { data Entity = { entityPosition :: !Position; entityVelocity :: !Velocity; } }
18:39:44 <Polarina> Mostly so that I don't get name conflicts.
18:40:06 <Cale> cornihilio: The message will be printed just before the evaluation proceeds with the next case there.
18:40:23 <cornihilio> ah, okay. but what does the "|" mean? and why does it have False = undefined?
18:40:28 <Cale> that's a guard
18:40:36 <Cale> trace s x
18:40:39 <Cale> evaluates to x
18:40:47 <Cale> but prints the string s when that happens
18:40:55 <Cale> So the guard here always evaluates to False
18:41:04 <Cale> and so the right hand side is never used
18:41:09 <Cale> So I put undefined over there
18:41:45 <cornihilio> Cale: ah, thank you for clearing that up! much appreciated!
18:47:36 <Jafet> That's worse than the seq pattern guard! You should feel remorse.
18:49:07 <ew0> ok, now I want to reduce my stack size. I'm able to run my stuff with 80M stack
18:49:15 <ew0> but I'm probably doing something silly
18:49:19 <ew0> somewhere
18:49:25 <ew0> any ideas?
18:49:32 <ew0> profiling is enabled
18:49:39 <ew0> is there any flag to help me?
18:49:50 <Cale> Jafet: it's only for debugging, and it's really helpful if you can't find the parameters to a function which cause a problem
18:50:14 <Cale> Jafet: You can then go back to playing with the thing in GHCi after you've found the bad ones :)
18:50:29 <Cale> ew0: where's your code?
18:50:31 <Jafet> Well, I've just never seen that use of pattern guards.
18:50:40 <dbp> I have a server with 800+MB free ram and linking HDBC-postgres is getting killed over and over by running out of memory. Is there any way to reduce memory consumption while linking? (I'm on an older GHC - 7.0.4 - has the situation improved?)
18:50:42 <Cale> That's not a pattern guard
18:50:51 <Cale> (it's just an ordinary guard!)
18:50:52 <Jafet> Wait, pattern guards are something else
18:50:57 <ew0> it is a ton of code
18:51:06 <ew0> I don't know where is the problem
18:51:13 <Jafet> It's a non-pattern guard after a pattern
18:51:32 <Cale> ew0: okay, so general hint: the stack which is overflowing is not a call stack
18:52:03 <Cale> ew0: It's a stack which essentially consists of case expressions who are waiting for their scrutinee to be sufficiently evaluated to pattern match
18:52:05 <ew0> it is not?
18:52:05 <Jafet> dbp: perhaps you can strip the libraries, or not use debugging libraries
18:52:11 <ew0> uhm
18:52:27 <Cale> ew0: (at some level, all pattern matching is turned into case expressions, so you can think of it this way)
18:52:52 <Cale> ew0: Now, how this usually occurs is when a very large expression is built
18:53:13 <Cale> (from strict functions which pattern match their arguments)
18:53:21 <Cale> and then evaluated all at once
18:53:31 <ew0> I was having trouble with a foldr, I changed it to foldl' and now its better
18:53:47 <ew0> I'd like to find more places of my code that have the same problem
18:53:55 <Cale> yeah, that's often a solution
18:54:30 <Cale> Or if something is tail recursive or accumulating an expression in its parameter, you want to make sure the expression is pattern matched on or evaluated regularly
18:54:52 <Cale> (which you can force to happen with bang patterns or seq or just plain pattern matching)
18:55:17 <Jafet> (Why does ghc have a stack size limit, anyway?)
18:55:47 <Cale> I think it's because when you get a stack overflow, it tends to need a lot of memory extremely quickly
18:56:11 <dbp> Jafet: how can I get cabal to build without debugging / strip libraries?
18:56:54 <Jafet> I believe the linker problem is with linking the library's dependencies
18:57:02 <dcoutts_> dbp: --disable-executable-stripping
18:57:36 <dbp> dcoutts_: isn't that the reverse? (I want to strip everything, as the linker is OOMing)
18:58:03 <dcoutts_> dbp: oh I thought you meant without stripping
18:58:12 <dcoutts_> dbp: stripping executables is the default
18:58:31 <Jafet> He's building a library, and ld runs out of memory when linking it
18:58:45 <dcoutts_> share lib?
18:58:49 <dcoutts_> erm, shared
18:59:13 <dcoutts_> ld isn't used for linking normal libs, that's ar, and takes next to no mem
18:59:31 <Cale> ew0: As a general rule of thumb, the places which tend to need more strictness are places where you're taking things which have lots of bits which could be evaluated separately (like a list) and bringing them together into a value which is all-or-nothing in terms of evaluation (like a single Integer, say), and you're not doing that by searching, but by honest combination.
19:00:05 <ew0> I have a State monad
19:00:11 <ew0> could be it?
19:00:16 <Cale> could indeed
19:00:28 <ew0> a huge one
19:00:33 <ew0> is there a strict state?
19:00:40 <Cale> If you frequently modify your state without actually pattern matching on it
19:00:50 <Cale> then you might build up a large expression in the state
19:01:16 <dbp> dcoutts_: how do I use shared libs? that would be amazing if it used almost no memory!
19:01:18 <ew0> I'm not sure what counts as matching it
19:01:24 <Cale> which you can fix by using  modify (f $!)
19:01:33 <ew0> uhm
19:01:34 <dcoutts_> dbp: no, I mean linking .a libs takes no memory
19:01:46 <dcoutts_> that is making the .a lib
19:02:03 <dbp> dcoutts_: hmm. well linking something in HDBC-postgres takes over 800 :(
19:02:06 <dcoutts_> linking the .a lib into an executable (using ld) can take a lot
19:02:13 <Cale> or actually, that may or may not help :)
19:02:24 <Cale> x <- get
19:02:24 <ew0> I do a get and a put every iteration
19:02:35 <Cale> x `seq` put (f x)
19:02:42 <ew0> uhm
19:02:43 <Cale> something like that is likely to help
19:03:05 <Cale> ew0: what's the type of your state?
19:03:21 <Jafet> dbp: are you linking hdbc, or linking an executable with hdbc?
19:03:44 <dbp> Jafet: trying to do the latter, but it never even gets to my application… it is just installing hdbc as a dependency
19:03:54 <ew0> StateT SOMESTRUCT (State SOMEHashMap) a
19:03:59 <Cale> ew0: If you were doing something like  case x of ...
19:04:05 <Cale> after the get
19:04:13 <Cale> and pattern matching constructors
19:04:22 <Cale> then you wouldn't need to use seq
19:04:36 <Cale> because it's equivalent to pattern matching against a top-level constructor
19:04:45 <dbp> Jafet: I'm using cabal-dev… that shouldn't make any difference should it (it's just a wrapper, right?)
19:05:17 <ew0> uhm
19:05:22 <Cale> ew0: if you put your code on hpaste.org, I'll have a quick look
19:06:03 <dbp> Jafet dcoutts_: alright, just resized some disks and bumped swap a gig higher and now it's working… thanks anyway! still seems kind of crazy (I remember when I was trying to use 256MB VPSs having this problem, but I wouldn't expect one with three times that memory would have a problem)
19:06:14 <Cale> ew0: It's kind of hard to offer advice in a form which will be useful when I have no idea what your computation looks like :)
19:06:22 <ew0> yeah I know
19:06:24 <Jafet> Well, that's the worst solution.
19:06:31 <ew0> I think I have on function
19:06:35 <ew0> that shows what I'm doing
19:06:37 <dcoutts_> dbp: 500mb used to be around the lower limit
19:06:45 <ew0> just a moment
19:06:51 <dcoutts_> dbp: but yes, dynamic linking should make ld stress less.
19:07:10 <dbp> dcoutts_: yeah, I used to do it anyway, and would swap out for 20 minutes solid :P I've since learned :)
19:07:33 <hpaste> ew0 pasted “mess” at http://hpaste.org/75738
19:07:50 <Jafet> dbp: if you have the same system that's run on the server, better to build it locally
19:07:54 <dcoutts_> dbp: which you can do with --enable-shared
19:08:20 <dbp> Jafet: unfortunately it's different platform (and architecture - 64bit/32bit)
19:08:34 <ew0> Cale, there it is
19:08:50 <Cale> ew0: pull that case out of the put, and see if it helps
19:08:57 <Cale> case a_succs of
19:09:07 <Cale>   [] -> lift (put m)
19:09:10 <ew0> ok
19:09:14 <dcoutts_> dbp: the real problem is that ghc's .a files contain 10s of 1000s of .o files, and that makes ld cry.
19:09:15 <Cale> (you get the idea)
19:09:20 <ew0> yeah
19:09:23 <ew0> I think I got it
19:09:25 <ew0> in general
19:09:38 <Jafet> Do you know if gold cries?
19:09:53 <Cale> ew0: well, that'll force the evaluation of a_succs, which I don't know if it actually matters
19:10:14 <ew0> I guess it does
19:10:29 <Cale> actually, it doesn't mean that m is evaluated!
19:10:34 <Cale> aha
19:10:42 <Cale> right, looking at this more clearly
19:10:48 <ew0> but the important thing is to match the m and the c'
19:11:04 <Cale> try   m `seq` lift $ put ...
19:11:20 <ew0> ok
19:11:31 <Cale> that'll make sure your actual state is evaluated
19:11:55 <ew0> running
19:12:17 <ew0> it is taking about 6 minutes to reach this piece of code
19:12:20 <ew0> ok
19:12:22 <ew0> not really
19:12:28 <ew0> stack overflow
19:13:08 <Cale> hmm!
19:13:34 <ew0> I'll put a seq in the c'
19:13:45 <ew0> din't help much either
19:13:58 <Cale> you'll want to put the seq on one of the statements of your do block
19:14:25 <Cale> depending on how accountForCallM works, it might already evaluate c'
19:14:42 <ew0> man, it would be really nice if I could do some profiling and it tells me how much each piece of code is using of the stack
19:14:59 <Cale> It's probably not gradual
19:15:33 <Cale> If you turn on profiling and run with +RTS -xc and you get a stack overflow, I think it'll tell you basically where the problem is
19:15:43 <Cale> But I haven't done much of that lately
19:16:12 <Cale> ew0: It's important to note that when you have a 'let' like that
19:16:19 <Cale> none of the things in it are necessarily evaluated
19:17:53 <Cale> ew0: but at least with the seq on m, you'll know that you can't build up an expression like  delete 1 (delete 2 (delete 3 (delete 6 ... (delete 473892 m) ...)))
19:18:23 <ew0> uhm
19:18:51 <Cale> (because when you evaluate the map, it'll actually force the delete to happen)
19:19:17 <Cale> Another way to force it to happen would just be to look up a value in it
19:20:16 <Cale> (assuming you actually use the value that you look up!)
19:20:58 <ew0> uhm
19:20:58 <ew0> I have a huge concat
19:21:00 <ew0> here too
19:21:10 <ew0> of a huge list
19:21:21 <Cale> concat is rarely a problem because it can be evaluated lazily
19:21:33 <Cale> and produces a result quickly
19:21:35 <ew0> it is a concat of a list comprehension
19:21:40 <ew0> of a huge list
19:22:44 <hpaste> ew0 pasted “mess2” at http://hpaste.org/75739
19:22:44 <Cale> hmmm, depending on how the list is defined, it might create a problem, if the elements of the list don't get evaluated until you get really far out, and the list is initially defined in terms of iterating some strict function many times
19:22:56 <ew0> this is it
19:23:22 <ew0> rl_ctx is HUGE
19:23:28 <ew0> like 10000 items
19:23:34 <ew0> generally
19:23:56 <Cale> g5 is unused?
19:24:08 <ew0> yeah
19:24:08 <ew0> xD
19:24:34 <ew0> g5 is just wrong
19:24:58 <ew0> g3 and g2 do the job of g5 better
19:25:02 <Cale> okay, I don't think that the computation of es is in itself problematic
19:25:25 <Cale> and 10000 items isn't very large from the stack's point of view
19:25:49 <Cale> You usually need sizes around 10 million before you start getting stack overflows
19:26:10 <ew0> it might be more than 10000
19:26:20 <ew0> like 100.000
19:26:36 <Cale> oh, also, I should check
19:26:41 <Cale> you are compiling with -O2, right?
19:26:45 <Cale> Or at least -O?
19:26:46 <ew0> yes
19:27:08 <Cale> It has happened before :)
19:27:28 <ew0> I'm doing a force recomp
19:27:29 <ew0> here
19:27:44 <ew0> yup, it still overflows
19:27:55 <ew0> I'll try running with -xc
19:28:06 <Cale> yeah, all that stuff, I think is mostly harmless...
19:28:37 <hpaste> ew0 pasted “exception” at http://hpaste.org/75740
19:29:30 <Cale> called from Callgraph2.unrollBe
19:29:34 <Cale> can we look at that?
19:29:44 <Cale> and maybe some of the things up the cost centre stack?
19:29:56 <Cale> (that stack trace isn't the stack that's overflowing :)
19:30:27 <Cale> It just sort of tells us where in the program we were evaluating something when it happened
19:30:45 <Cale> I often wish I could get a trace of the *actual* stack, even if that one is mostly nonsense
19:30:55 <ew0> yeah
19:31:24 <hpaste> ew0 pasted “unrollBE” at http://hpaste.org/75741
19:31:29 <Cale> I wonder if context g is strict
19:31:36 <Cale> I forget what that graph function did
19:31:40 <Cale> It probably is
19:31:45 <ew0> I don't think so
19:32:21 <ew0> context n g gets the context of the node n from the graph g
19:32:25 <Cale> yeah
19:32:33 <Cale> so it probably forces the evaluation of g
19:32:36 <ew0> the context is (preds, n, label of n, succs)
19:32:36 <Cale> (and n)
19:35:14 <Cale> Which graph implementation are you using?
19:35:49 <ew0> Data.Graph.Inductive
19:35:58 <ew0> from fgl
19:37:14 <Cale> Right, and nowadays that uses IntMap internally
19:39:37 <Cale> ew0: is there recursion in this somehow?
19:39:56 <ew0> no at all
19:40:07 <ew0> the unrollBe is inside a foldl'
19:40:11 <ew0> that's it
19:40:13 <Cale> aha
19:40:18 <Cale> and CFG?
19:40:21 <Cale> What is that?
19:40:37 <ew0> its a graph + an entry node
19:40:45 <Cale> Can I see the definition of the datatype?
19:41:05 <Cale> foldl' might not be as effective as it needs to be on it
19:41:19 <hpaste> ew0 pasted “datatypes” at http://hpaste.org/75743
19:41:20 <Cale> so we might need to make the fields of that type strict
19:41:29 <ew0> uhm
19:41:40 <Cale> Is Function an actual Function type?
19:41:48 <Cale> (I'm guessing no)
19:41:50 <ew0> ins a list of INstruction
19:41:58 <ew0> and a name
19:42:41 <hpaste> ew0 pasted “function” at http://hpaste.org/75744
19:42:51 <Cale> Try adding a ! before the types (just after the ::) of the fields in the data declaration for CFG
19:43:13 <ew0> uhm
19:43:23 <ew0> of the M_Graph ?
19:52:30 <ew0> nope, not really working
19:54:11 <zzing> Does anyone happen to know how to deal with the Conduit library? For example in Persistent, I can get a function like this: selectKeys :: PersistEntity val => [Filter val] -> [SelectOpt val] -> Source (ResourceT (backend m)) (Key backend val)      but I have no idea how to actually the these keys out of the Source.
19:56:09 <luite> zzing: you can use $$ consume to get a list of everything
19:56:43 <zzing> $$ looks like it needs a sink, which I have no idea what that really is
19:57:17 <zzing> Looks like some neat stuff if I knew how to use it :P
19:57:20 <luite> the intuition is that you have a source (of keys), and the sink consume things produced by a source
19:57:27 <luite> conduits transform the stream
19:58:24 <luite> but in reality, the underlying type of conduit, source and sink is almost the same, only some differences in type parameters
19:59:46 <zzing> ok, I am assuming that I should be able to get a list of keys. I really have no clue how to do this.  There is a few examples, such as sourceList [1..10] $$ fold (+) 0
19:59:53 <zzing> It does give me an idea
20:00:16 <zzing> perhaps fold?
20:00:27 <luite> zzing: no consume
20:00:54 <luite> that gives you a list with everything produced by the conduit
20:00:58 <zzing> ok, it is this: consume :: Monad m => GSink a m [a]    but what is a GSink?
20:01:05 <Tekmo> A type synonym
20:01:05 <lambdabot> Tekmo: You have 3 new messages. '/msg lambdabot @messages' to read them.
20:01:12 <Tekmo> It will work
20:01:13 <Tekmo> just try it
20:01:59 <zzing> (source $$ consume)  :: [Key backend val]?
20:02:03 <luite> zzing: (keep in mind, consume is strict, it will consume everything from the conduit, build the whole list in memory, you're not really doing stream processing this way, but that might not matter)
20:02:08 <Tekmo> No
20:02:14 <Tekmo> m [Key backend val]
20:02:20 <Tekmo> where m is the base monad
20:02:35 <zzing> Tekmo, which in my case is inside persistent, I will try it out
20:03:01 <zzing> luite, I expect there to be a single item, so it isn't really a concern
20:04:41 <slack1256> when using the 'forever' function on a IO monad, a way to break it to throw an exception and catch it outside forever
20:04:46 <slack1256> is there another way?
20:04:58 <Tekmo> Yes
20:05:00 <Tekmo> Hold on a second
20:05:40 <Tekmo> http://www.haskellforall.com/2012/07/breaking-from-loop.html
20:06:49 <shachaf> Tekmo++ # not using ContT
20:07:06 <Tekmo> Cont is the most over-rated monad
20:07:19 <shachaf> Cont will do what you need.
20:07:22 <Tekmo> Usually when people use Cont, they actually wanted Free or Either
20:07:41 <zzing> ok, I think I am doing this wrong.                       keys <- (selectKeys [DocumentSlug ==. slug] [] $$ consume)      Would this be very wrong?
20:08:13 <Tekmo> That looks right, but if it's not working I'd need to see the type error
20:08:41 <zzing>  Couldn't match expected type `Source (SqlPersist m0) a0'                with actual type `conduit-0.5.2.3:Data.Conduit.Internal.Source                                    (ResourceT (backend0 m1)) (Key backend0 val0)'
20:08:49 <zzing> In the return type of a call of `selectKeys'
20:09:10 <Tekmo> Ok, there is a base monad mismatch
20:09:17 <Tekmo> The issue is that
20:09:20 <Tekmo> your selectKeys command
20:09:22 <Tekmo> has one base monad
20:09:27 <Tekmo> In this case SqlPersist
20:09:37 <Tekmo> and consume uses a different base monad
20:09:42 <Tekmo> ResourceT ...
20:09:49 <Tekmo> This is why youcan't connect them
20:10:09 <zzing> hmm, so I need a transformer?
20:10:11 <Tekmo> Which package provides the selectKeys function?
20:10:18 <zzing> Database.Persist
20:10:26 <Tekmo> Let me check it out.  One second
20:11:17 <Tekmo> Which version of the package are you using?
20:11:31 <luite> zzing: try keys <- runDB (...what you had...)
20:12:12 <zzing>   persistent-1.0.0   conduit-0.5.2.3   conduit-0.5.2.4
20:12:55 <zzing> luite, my source code I don't think would work quite with runDB.    It starts with pageKey slug = withPostgresqlPool connectString 1 $ runSqlPool $ do
20:13:15 <luite> oh right, no yesod
20:13:24 <YayMe> can anybody help me with a bit of parsec, trying to figure out how to handle nested blocks
20:13:28 <luite> then runResourceT
20:13:53 <Tekmo> I can help
20:14:10 <zzing> luite, my utility is mucking with the database behind yesod's back
20:14:28 <Tekmo> Also, zzing, which thing had the type "Source (SqlPersist ...)"
20:14:43 <luite> zzing: yeah i see, the runDB was just a wild guess with a few assumptions
20:14:48 <luite> SqlPersist is the backedn
20:15:04 <luite> the difference seems to be the ResourceT layer
20:15:08 <Tekmo> The part where I'm confused is the error he got
20:15:10 <Tekmo> "Source (SqlPersist m0) a0"
20:15:14 <Tekmo> The type of selectKeys is
20:15:15 <zzing> luite, it is the function at the end of this: http://hpaste.org/75745
20:15:26 <zzing> I am trying to pull it up now
20:15:30 <Tekmo> " Source (ResourceT (backend m)) (Key backend val)"
20:15:40 <zzing> yes I have that here too
20:16:01 <zzing> Posting full error
20:16:14 <zzing> http://hpaste.org/75746
20:16:15 <shachaf> @ty either id id
20:16:16 <lambdabot> forall b. Either b b -> b
20:16:41 <zzing> luite, in which way would I run that runResourceT?
20:16:50 <Tekmo> Oh, now I understand
20:16:56 <luite> keys <- runResourceT (selectKeys .... $$ consume)
20:16:57 <Tekmo> The composition is working
20:17:09 <Tekmo> Yeah, I think luite is on the right track
20:17:14 <zzing> I will try it
20:17:25 <Tekmo> There is a mismatch between the monad returned by the composition
20:17:29 <Tekmo> and the monad you are binding the result in
20:17:50 <hpaste> YayMe pasted “csharp beginnings” at http://hpaste.org/75747
20:17:55 <zzing> I get the same error
20:18:28 <YayMe> the comment/using/namespace parsing stuff works, I just can't figure out how to start doing nesting. haven't touched all the other data types like class/etc yet
20:19:09 <Tekmo> Nesting should work
20:19:09 <YayMe> also, are my anyBetween and anyTill combinators commonly done in a different way?
20:19:52 <KirinDave> Does anyone have a hard copy of "Data Types a la Carte" (Swierstra 2k8)?
20:19:57 <Tekmo> Your anyXXXX functions are fine
20:19:58 <KirinDave> Every link I follow to try and read this fails.
20:20:06 <Tekmo> I don't know of any obvious simplification
20:20:11 <KirinDave> And it seems like a pretty commonly referenced pearl.
20:20:16 <shachaf> KirinDave: http://www.cs.tufts.edu/~nr/cs257/archive/wouter-swierstra/DataTypesALaCarte.pdf
20:20:31 <Tekmo> So, if I understand correctly
20:20:38 <YayMe> my nesting doesn't work I believe, though I was last poking at that bit of code 4 or 5 hours ago (needed a break)
20:20:41 <luite> zzing: hm, runResourceT must be in the wrong place then
20:20:44 <Tekmo> Your "block" is just a list of "csharps"?
20:20:44 <shachaf> KirinDave: (The wonders of filetype:pdf!)
20:20:55 <KirinDave> shachaf: ty, my searches were not going well. :\
20:21:00 <KirinDave> But I did re-find the Monad Zipper paper
20:21:17 <KirinDave> And it reminded me how amazing that paper was and how weird it is that people haven't started adopting that technique.
20:21:27 <Tekmo> YayMe: Just do this
20:21:27 <Tekmo> Block <$> many csharp
20:21:28 <KirinDave> There must be some good reason I dont' understand
20:21:30 <Tekmo> i.e.
20:21:33 <Tekmo> block = Block <$> many csharp
20:21:40 <KirinDave> Tekmo: Btw thank you so much for the free monad pointers on reddit.
20:21:53 <Tekmo> No problem!
20:21:56 <YayMe> Tekmo: Yeah, I want to get a result like Block [Comment "some command", Block [Expr "bunch of code",Comment "woo", Expr "more code"], Block [Comment "woo"]]
20:21:57 <KirinDave> Tekmo: I see what you were getting at now and agree with your assertion that'd be a better way to do things in that case.
20:21:59 <Tekmo> Is that the paper about mixing effects?
20:22:14 <Tekmo> So my understanding is that people are working on that
20:22:30 <YayMe> s/command/comment/f
20:22:37 <KirinDave> Tekmo: The monad zipper paper?
20:22:43 * cmccann posts a sign in front of Tekmo reading "free monads to a good home"
20:22:49 <Tekmo> lol
20:23:27 <KirinDave> Tekmo: Actually I had been asking for a good tutorial that motivated their use. because the type is pretty damn opaque at first glace. At least to many people I have talked to.
20:23:39 <Tekmo> I like the AST analogy
20:23:39 <YayMe> Tekmo: so I actually am kind of using parsec right? :D Whoa, after banging my head against it long enough... I wish there were any simple tutorials that were parsec 3, all the parsec 3 stuff is slightly different and was giving me headaches trying to apply it to parsec 3..
20:24:08 <Tekmo> I think the main reason is that most people use attoparsec
20:24:20 <KirinDave> (because attoparsec is pretty awesome)
20:24:21 <Tekmo> However, both of them have their warts
20:24:24 <YayMe> Tekmo: there's even less I was able to find for that!
20:24:29 <Tekmo> Yeah, I know
20:24:31 <YayMe> Also, when I asked in here everyone said don't bother
20:24:38 <Tekmo> I will add it to my very long list of tutorials to write
20:24:39 <Tekmo> :)
20:24:41 <YayMe> which seemed strange to me
20:24:44 <KirinDave> (you can casually write parsers that have performance on the order of the very best jvm implementations )
20:24:45 <YayMe> haha
20:24:53 <Tekmo> But yeah,
20:24:57 * cmccann is sad that the stream processing thing he's been tinkering with apparently won't work with a more direct encoding along the lines of pipes :T
20:25:03 <Tekmo> Bryan doesn't do a good job of documenting his packages
20:25:16 <Tekmo> Oh
20:25:18 <Tekmo> Speaking of pipes
20:25:20 <Tekmo> I'm about to release
20:25:21 <Tekmo> 2.4
20:25:25 <Tekmo> Which will have lots of cool stuff
20:25:33 <YayMe> I also asked if it was trivially easy to change my parser if I started it in parsec to attoparsec
20:25:41 <Tekmo> If you want to check it out
20:25:43 <YayMe> people seemed to agree, what are your thoughts Tekmo?
20:25:47 <zzing> luite, I am going through types by paper right now to see if I can figure it out
20:25:50 <Tekmo> Just look at the 2.4 branch on my github repository
20:26:06 <mgsloan> anyone know of a good set of slides for intro haskell? Sofar I've looked + will probably use bits of haskell-amuse-bouche and "Why learn Haskell?"
20:26:08 <Tekmo> The coolest feature is the ability to list pipe composition through outer monad transformers
20:26:13 <nejucomo> Do any releases of GHC have the data-promoted kinds feature?
20:26:15 <Tekmo> *lift pipe composition
20:26:34 <Tekmo> So now you can have pipe-local state and error handling
20:26:42 <Tekmo> and catch and handle errors within a pipe
20:26:58 <Tekmo> You can even implement parsing, too
20:27:00 <Tekmo> It's really elegant
20:27:08 * nejucomo is refering to this: http://www.haskell.org/haskellwiki/GHC/Kinds
20:27:24 <YayMe> If I actually finish my parser performance will be totally relevant since I plan to stuff an entire enterprisey source base into it and hopefully have it spit out a full AST of where classes exist and a dependency tree
20:27:42 <Tekmo> Ok, so about your block parser
20:27:55 <cmccann> my current fascination is a stream processing library based roughly on linear logic, for which I wanted an API similar-ish to pipes, but that doesn't seem to be practical :[
20:28:05 <Tekmo> What's linear logic?
20:28:55 <Tekmo> YayMe: Does the "block = Block <$> many csharp" work?
20:29:52 <YayMe> Tekmo: about to try now
20:30:29 <cmccann> Tekmo, a version of logic that doesn't permit duplicating premises or discarding conclusions, among other things
20:30:37 <YayMe> what do I need to import? Control.Applicative?
20:31:07 <cmccann> so in programming-ish terms it means that every argument to a function must be used precisely once
20:31:08 <Tekmo> So it would be like a function where you can't write "\_ -> ..." or "\x -> f x x"
20:31:21 <Tekmo> That would be quite useful for finalizing stuff
20:31:24 <cmccann> yes
20:31:49 <cmccann> though you can use modal operators to allow that in either direction
20:32:10 <Tekmo> Yeah, I find myself wanting something like that for resource management abstractions all the time
20:32:30 <Tekmo> Also, garbage collection
20:32:49 <cmccann> and it has two pairs of conjunction/disjunction to capture different interpretations, which collapse to the same thing if you allow arbitrary nonlinearity
20:32:52 <YayMe> Tekmo: Nope, I have some bad recursion, what's the emacs haskell-mode chord for "kill that thing in ghci" ?
20:33:22 <YayMe> Should I take block out of csharp?
20:33:33 <Tekmo> What do you mean by bad recursion?
20:33:39 <YayMe> it spun
20:33:42 <YayMe> iduno
20:33:48 <Tekmo> Oh, bottom
20:33:53 <YayMe> not error
20:33:56 <cmccann> for stream processing I'm regarding the logical formula as representing one "step" in the stream, so the linearity constraint translates to linearity for input/output
20:33:56 <YayMe> bottom usually errors no?
20:33:58 <ew0> ok, I'm tired. gonna play some diablo 3
20:33:59 <Tekmo> I mean
20:34:01 <Tekmo> non-termination
20:34:04 <YayMe> right
20:34:10 <Tekmo> Then do
20:34:16 <Tekmo> Block <$> many1 csharp
20:34:23 <Tekmo> Or maybe not that
20:34:40 <Tekmo> Most of the time it means that your parser is parsing endlessly without consuming input
20:34:43 <otters> :t (.:)
20:34:44 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
20:34:47 <otters> @src (.:)
20:34:47 <lambdabot> Source not found. My brain just exploded
20:35:09 <YayMe> Tekmo: I think it's parsing recursively
20:35:12 <YayMe> endlessly
20:35:14 <YayMe> same thing
20:35:14 <cmccann> Tekmo, but a lot of the appeal comes from the tidy elegance you get in linear logic--everything has simple de morgan duality as in classical logic, but without losing constructive computational meaning
20:35:27 <Tekmo> cmccann: Well, the problem with a pipes API is that you can discard input and duplicate it
20:35:33 <YayMe> oh that won't work anyway
20:36:06 <Tekmo> But you could replace the primitives
20:36:08 <YayMe> I need to parse a block based on being between (char '{') (char '}') but in a balanced fashion so any blocks between there will be reparsed
20:36:08 <nejucomo> Let say I have an enumish type T, and a type K with kind T -> *, is it possible to write a function of type :: T -> K Tvalue -- where Tvalue is the value of the T?
20:36:34 * nejucomo is doing some exploratory self-confusion ^H^H^H^H study of promoted kinds.
20:36:47 <cmccann> Tekmo, yeah I was actually trying to figure out how I'd translate the semantics of pipes into the roughly linear logic setting I'm toying with
20:36:59 <nejucomo> I'm guessing my question is hard to understand...
20:37:12 <Tekmo> Well, if you restrict the primitives it is possible
20:37:21 <Tekmo> For example, instead of await and yield
20:37:26 <Tekmo> you could define something like "pass"
20:37:30 <Tekmo> which lets one input through
20:37:35 <YayMe> nejucomo: I think being confused is the steady state for a haskeller, not because you guys aren't good at haskell, but every haskeller consistently looks at things he doesn't understand, even as it grows harder to find them
20:37:43 * nejucomo attempts to cook up example code.
20:37:51 <YayMe> or so it appears to me..
20:37:51 <cmccann> Tekmo, keep in mind that I don't have an intrinsic notion of input or output here
20:37:57 <nejucomo> heh...
20:38:02 <shapr> YayMe: I believe it.
20:38:20 <shapr> It never seems to be difficult to find Haskell research papers I don't understand yet.
20:38:26 <Tekmo> YayMe: It will alwaysbe balanced
20:38:31 <Tekmo> YayMe: Don't worry about that
20:38:39 <cmccann> just negation and four different logical operators, with implication essentially defined by "not A or B"
20:38:51 <Tekmo> Well, one thing I want to caution
20:38:53 <YayMe> Tekmo: but your snippet didn't even take into account the char '{' and char '}'
20:38:57 <Tekmo> Is that pipes are really ideal only for streams
20:39:10 <Tekmo> You probably want a different abstraction for working with unstructured input
20:39:21 <Tekmo> Oh yeah
20:39:24 <Tekmo> I forgot about the braces
20:39:26 <Tekmo> You need those!
20:39:50 <YayMe> heh yeah.. here I'll write the version that I would right "not worring about being balanced"
20:40:03 <YayMe> and you can tell me if it's definitely not going to work or how to resolve the balancing issue
20:40:29 <Tekmo> between (try (char "{")) (char "}") $ Block <$> many csharp
20:40:37 <Tekmo> something like that
20:40:45 <YayMe> Yeah that's similar to what I had tried before
20:41:33 <YayMe> based on the hypothesis that a haskeller contiguously reads things he doesn't understand.. I wonder what simon peyton jones sits around reading..
20:41:41 <YayMe> Stephen Hawking's mind?
20:41:45 <Tekmo> Nothing
20:42:42 <cmccann> Tekmo, anyway I think you might find linear logic interesting for its own sake, Wadler has written a bunch of stuff about it that's a good place to start
20:43:08 <nejucomo> I think I am trying to cook up something that requires dependent types and now I wonder if promoted kinds allow this...
20:43:09 <Tekmo> Yeah, I will read more on it
20:43:40 <nejucomo> I want a single function with a different result type based on the relationship of multiple argument types...
20:43:42 <cmccann> Tekmo, I also wrote a simple (not stream processing) encoding of linear logic in Haskell a few days ago
20:43:48 <cmccann> that illustrates at least some of the ideas
20:44:00 <Tekmo> Do you have a link to it?
20:44:05 <Tekmo> I always learn best by studying code
20:44:07 <cmccann> just http://hpaste.org/75222
20:44:16 <nejucomo> So: f :: a -> b -> c  -- in general, unless a and b are the same type, then c must also be that type.
20:44:27 <cmccann> hope you have a font with enough math symbols, heh
20:44:38 <cmccann> also you need a GHC after the type operators change to load that
20:45:04 <cmccann> it would look a lot uglier with : on all the types
20:45:09 <Tekmo> I do, don't worry
20:45:54 <cmccann> note that all four operators are associative and commutative, with de morgan duality for everything and several distributive laws
20:46:19 <Tekmo> Give me a second.  I'm trying to build an intuition for why Lin works
20:46:27 <nejucomo> cmccann: Which type operator change do you mean?
20:46:39 <cmccann> Tekmo, it's a funny way of writing Kleisli Cont basically
20:47:06 <cmccann> with extra indirection because of the forall'd result type
20:47:09 <Cale> nejucomo: the one which means everything is an infix type constructor now
20:47:15 <zzing> If I have a few libraries depending on persistent, and I want to upgrade persistent, does that mean I have to essentially recompile them all?
20:47:18 <Cale> nejucomo: so infix type variables are impossible
20:47:28 <Tekmo> So basically, the universal quantification prevents the discarding or duplication
20:47:39 <cmccann> no, the linearity constraint is enforced manually
20:48:26 <cmccann> I *think* that using arguments linearly forces everything else to work correctly as well, and the linearity is easy to check by visual inspection
20:48:37 <cmccann> but enforcing that directly would be... tricky
20:49:01 <Cale> cmccann: Now, to port this to Clean
20:49:05 <Tekmo> You probably can enforce no discarding
20:49:12 <Tekmo> but not enforcing duplication is harder
20:49:19 <cmccann> Cale, I should try that actually
20:49:26 <Tekmo> *but enforcing not
20:49:47 <cmccann> yeah I basically decided that trying to enforce linearity fully wasn't going to be worth the hassle :T
20:50:26 <YayMe> Tekmo: any idea why my multiLineComment is failing on: /*    *     */ with unexpected " " expecting "*/"
20:50:51 <YayMe> I mean I know why- but what do I do about that? I tried putting a try in ront of my end on between
20:51:11 <cmccann> anyway, the reason Lin is defined that way was to emphasize the symmetry--if you strip out the layers of stuff, "Lin (Var x) (Var y)" is basically (x -> (y -> r) -> r)
20:51:43 <Tekmo> You should avoid "lookahead"
20:51:49 <Tekmo> I've never used it in my parsers
20:52:04 <cmccann> but the definition amounts to (y -> r) -> (x -> r), and the "r" parameters everywhere are necessary for defining negation
20:52:04 <Tekmo> I think what you actually want
20:52:16 <Tekmo> is "anyTill p = manyTill anyChar p
20:52:25 <YayMe> in manyTill if I don't use lookAhead, when it gets to the ending sequence it consumes it so it can't be used for the next sequence
20:53:35 <YayMe> I had to put the lookahead or else if I do anyTill comment for instance, it will consume everything untill "//" and then when I try to parse the comment it will fail because there's no "//" since it was consumed
20:54:21 <YayMe> Am I doing it wrong?
20:54:50 <Tekmo> No, that sounds correct
20:54:55 <Tekmo> Oh
20:55:05 <Tekmo> I forgot this is parsec, not attoparsec
20:55:08 <Tekmo> So basically, in parsec
20:55:19 <Tekmo> The "string" parser does not match atomically
20:55:24 <Tekmo> So what happened was
20:55:28 <Tekmo> when you tried to match "*/"
20:55:30 <YayMe> (should I change over to attoparsec? will it be an easy transition and helpful?)
20:55:35 <Tekmo> It partially matched on the "*" in the middle of the comment
20:55:53 <Tekmo> and then that caused it to commit to parsing string "*/"
20:56:03 <Tekmo> so then it failed because there was no following "/"
20:56:27 <YayMe> right, that same behavior is why I have the try start on my anyBetween, I added try end but it still fails the same
20:56:52 <YayMe> oh I need anyTill try end
20:56:54 <YayMe> probably
20:58:01 <YayMe> yeah that was the problem.. now I've gotten to the issue I ran into with my block calling to csharp as before, it runs into eof and fails
20:58:20 <Tekmo> So you have an unmatched brace?
20:58:36 <YayMe> no
20:58:43 <YayMe> I'm just parsing wrong heh
20:59:04 <hpaste> YayMe pasted “block parser” at http://hpaste.org/75748
21:02:06 <Tekmo> camccann: So what got you interested in linear logic?
21:03:30 <cmccann> Tekmo, heh, don't even recall
21:03:36 <Tekmo> :)
21:03:45 <Tekmo> Oh
21:03:52 <Tekmo> There is one really interesting thing I noticed
21:04:08 <cmccann> ?
21:04:15 <Tekmo> I was comparing the speed of binary/cereal compared to serializing using Handles directly
21:04:29 <Tekmo> the speed difference is almost 5x
21:04:35 <Tekmo> faster for handles
21:05:06 <cmccann> that seems a bit surprising
21:05:13 <Tekmo> You can get significantly faster performance for serialization by not converting to a bytestring first
21:05:38 <Tekmo> Yeah
21:05:49 <Tekmo> I noticed that serialization was frequently a bottleneck in my programs
21:05:59 <Tekmo> and when I just wrote to handles directly I got huge performance gains
21:06:03 * shapr hugs johnw for awesome code
21:06:31 <johnw> hey shapr!  which code in particular?
21:06:36 <shapr> eshell
21:06:43 <shapr> I was just using it, and it made me feel happy.
21:06:46 <johnw> ah, I was hoping it was something in Haskell :)
21:06:52 <shapr> heh, your older code has merit too!
21:07:36 <johnw> well, I still use it every day too :)
21:09:18 <cmccann> Tekmo, anyway as far as stream processing goes, the original motivation was that the additive operators nicely describe interleaving a choice of two streams (pulling or pushing only as needed) while multiplicative operators describe synchronizing two streams with different kinds of causal dependency
21:09:45 <cmccann> Tekmo, plus being able to treat inputs and outputs in an entirely homogeneous way
21:10:08 <Tekmo> Interleaving works well
21:10:29 <Tekmo> But if you mean zipping for multiplication, I don't see how it is associative
21:10:31 <cmccann> and hopefully using the "exponential" modal operators (not implemented in that code I hpaste'd) to describe restricted kinds of nonlinear streams
21:10:55 <Tekmo> Unless you manually associate
21:11:27 <cmccann> Tekmo, it would be in this case, with the caveat that there are more restrictions on how you construct things to begin with
21:11:46 <cmccann> but yeah, the multiplicative conjunction is mostly like zipping two streams
21:13:35 <johnw> shapr: so, I got a Das Keyboard the other day
21:13:39 <johnw> but I'm not so sure I like it
21:14:01 <cmccann> Tekmo, the "causal dependencies" thing is part of why it works, because zipping inputs means something very different from zipping outputs
21:14:06 <shapr> johnw: Is it really like an IBM Model M?
21:14:16 <johnw> this one isn't clacky, it's the Silent model
21:14:28 <johnw> the only real downside to it is that the space bar is a bit long
21:14:38 <user123abc> my thinkpad keyboard is better than all other keyboards in the world, simply because the "mouse" is located on the home row
21:14:45 <shapr> I've been using Kinesis Contoured keyboards for almost ten years: http://www.kinesis-ergo.com/images/kb_adv-blk720x471.jpg
21:14:47 <Tekmo> cmccann: What's the distinction?
21:15:15 <shapr> johnw: I use a heavily modified dvorak layout, but I'd like to rebase my layout on top of programmer dvorak, heard of it?
21:15:18 <user123abc> I don't need to talk about "responsiveness" or "feel" or other frustratingly aesthetic measurements in order to justify my preference
21:15:23 <johnw> no
21:15:27 <johnw> i just use virgin Dvorak
21:15:34 <shapr> johnw: http://upload.wikimedia.org/wikipedia/en/a/a6/KB_Programmer_Dvorak.svg
21:15:42 <cmccann> Tekmo, basically a pair of input values is not the same as an input of a pair of values
21:16:02 <YayMe> attoparsec has implicit try and a proper "string", I think I'm just going to convert now, sounds like attoparsec is not only faster, but easier to use
21:16:02 <shapr> johnw: The idea is that programmers use the symbols above the numbers more than the numbers themselves.
21:16:04 <Tekmo> The linear logic interests me fornother reason
21:16:10 <cmccann> you can see that distinction in the hpaste'd code, actually
21:16:16 <Tekmo> cmccann: So another thing I do in the pipes 2.4 release
21:16:27 <Tekmo> is use categories to type-class proxy behavior
21:16:29 <johnw> eww
21:16:32 <shapr> But I'd still rather have the numbers in order as they are on qwerty
21:16:39 <Tekmo> so that I can program utilities that are abstract over the underlying implementation
21:16:41 <johnw> the positioning of the delimiters kind of blows
21:16:51 <Tekmo> One thing I haven't found a way to abstract
21:16:55 <Tekmo> is a zipping operation
21:17:02 <johnw> shapr, let's move to #haskell-blah
21:17:04 <shapr> k
21:17:07 <Tekmo> and interleaving, too
21:17:17 <cmccann> a pair of inputs would be (not a * not b), while an input of a pair would be (not (a * b)), which is (not a | not b) where | means that inverted ampersand I'm too lazy to copy-paste
21:17:38 <cmccann> Tekmo, right, having that all work nicely is what motivated this whole idea
21:18:22 <Tekmo> Paolo studied some of this a while back
21:18:23 <cmccann> to not only have zipping and interleaving work nicely, but having some distributive laws between them as well
21:18:29 <Tekmo> Let me dig up the article
21:19:12 <Tekmo> https://pcapriotti.wordpress.com/2012/02/04/monoidal-instances-for-pipes/
21:19:55 <zzing> Tekmo, it looks like the issue I had might have been a bug. Now that I updated my libraries to latest, it compiles
21:20:21 <Tekmo> zzing: Interesting.  That might explain why it had a different conduit version in the error message
21:20:33 <zzing> I think that was my fault
21:20:40 <zzing> I installed another version
21:21:23 <boothead_> Hi folks, can anyone tell me how an ArrowLoop can manage to produce an output the first time it's called? I'm trying to implement arrows for fay, but can't get javascript to be lazy enough..
21:21:28 <cmccann> Tekmo, note that linear logic does not correspond to a cartesian closed category, don't remember if I mentioned that earlier
21:22:23 <cmccann> instead it's a symmetric closed monoidal category with a notion of dualization that corresponds to logical negation
21:22:42 <YayMe> How do you parse eof in Attoparsec?
21:25:05 <cmccann> Tekmo, that said, the encoding I used in that hpaste'd code more closely resembles a generalized notion of category where the source and target of an arrow can each be a multiset of objects rather than a single object
21:25:22 <Tekmo> YayMe: You don't
21:25:25 <cmccann> with composition defined by splicing together at a single object
21:25:37 <Tekmo> YayMe: Just use the "parseOnly" command
21:25:51 <Tekmo> YayMe: This is arguably the most confusing thing about attoparsec
21:29:54 <YayMe> so instead of "manyTill csharp eof" I say "parseOnly csharp" ?
21:30:11 <YayMe> or rather, "many1 $ parseOnly csharp" ?
21:32:07 <YayMe> oh attoparsec is a lot more like fparsec, it doesn't use <|> does it
21:32:34 <YayMe> on <* it parses the right side argument and *> parses the left side ?
21:32:54 <YayMe> or do I have them backwards?
21:32:58 <Axman6> :t (*>)
21:33:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
21:33:00 <Axman6> :t (<*)
21:33:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
21:33:16 <Tekmo> YayMe: You would say "parseOnly csharp"
21:33:26 <Tekmo> That runs the parser on the string
21:33:34 <Axman6> it runs both parsers, but returns the result of the left or right one
21:33:45 <Axman6> (the one it points to)
21:33:57 <Tekmo> Example:
21:34:15 <YayMe> Axman6: Right, fparsec behaves like that.. cool, what's attoparsec's replacement for <|> though? or am I just missing an import?
21:34:46 <Tekmo> import Control.Applicative
21:35:06 <Tekmo> Parse implement Alternative
21:35:11 <Tekmo> which provides the <|> operator
21:37:23 <copumpkin> :o
21:38:03 <cmccann> Tekmo, I'm out for the night but if you're interested in the linear logic stuff feel free to bother me later, heh
21:38:17 <Tekmo> Alright
21:38:23 <Tekmo> I'll talk to you later, then!
21:38:26 <Tekmo> Thanks for the intro to it
21:38:29 <Tekmo> It's really fascinating
21:38:35 <cmccann> I think my current encoding for the stream processing will work but it's more awkward than I'd hoped for
21:38:42 <cmccann> and I haven't had time to flesh it out properly
21:38:56 <Tekmo> I think it has real potential for resource management
21:39:09 <cmccann> that's a common conclusion
21:39:20 <copumpkin> have you covered uniqueness types?
21:39:23 <copumpkin> I only just tuned in :)
21:39:34 <cmccann> by which I mean that thinking it has potential is a common conclusion, actual demonstrated use seems to be another matter :[
21:39:50 <cmccann> copumpkin, that's sort of a different idea really
21:39:52 * hackagebot warp 1.3.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.3 (KazuYamamoto)
21:40:33 <copumpkin> they're related to linear types, but uniqueness types seem more desirable
21:40:34 <cmccann> copumpkin, I'm just evangelizing linear logic to Tekmo because I've been tinkering with a stream processing semantics for linear logic and annoyed that I can't get an API as nice as pipes for it, heh
21:40:37 <copumpkin> ah
21:40:41 <copumpkin> fair enough
21:41:13 <cmccann> and also showing a toy (non-stream-related) implementation of linear logic in Haskell to demonstrate the ideas more concretely
21:42:16 <copumpkin> cool
21:44:52 * hackagebot mighttpd2 2.8.1 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.8.1 (KazuYamamoto)
21:46:25 <YayMe> Ok, so how do I make my code aware it's dealing with a B.ByteString, do I have to manually put the pack call in front of each "//" and etc?
21:47:52 <Axman6> do you have {-# LANGUAGE OverloadedStrings #-} ?
21:48:41 <YayMe> no
21:48:45 <YayMe> That'll do it for me?
21:48:51 <Axman6> should do
21:49:27 <YayMe> woot thanks! I've manually called pack in code in the past and always figured I was doing it wrong because it feels way too clunky
21:49:46 <Cale> YayMe: That'll just do the equivalent
21:50:17 <YayMe> awesome
21:50:22 <YayMe> it compiles in attoparsec now
21:50:24 <Axman6> turns the syntax that's notmally for String only into fromString str i think
21:50:26 <Cale> (but if you have a lot of literal strings, I suppose it's helpful)
21:50:59 <YayMe> Cale: Yeah, just a grip of literal strings as delimiters as it's parsing code
21:54:54 <YayMe> anyone got an example of opening a file and feeding it to attoparsec?
21:55:50 <YayMe> my attoparsec version should work now.. just don't know how to pass it a stream, or do you load the file into memory before handing it over?
21:56:15 <Axman6> do you know how to read the file as a bytestring?
21:57:14 <YayMe> nah, but I'm sure that's easy to look up if that's all I do? I was assuming I'm supposed to hand a stream handle to it no?
21:57:27 <Axman6> shouldn't be any need for that
21:57:46 <YayMe> ByteString means it's completely loaded into memory, no?
21:58:03 <Axman6> well, depends if it's a lazy bytestring or not.
21:58:23 <YayMe> ah, are they interchangable?
21:58:24 <Axman6> if it's a strict bytestring then yes, unless you use the mmap package to let the Os load it lazily
21:58:28 <Axman6> no
21:58:59 <YayMe> Any examples of using that mmap package?
21:59:05 <Axman6> i think attoparsec only works with strict bytestrings?
21:59:15 <Axman6> @hoogle mmap
21:59:16 <lambdabot> package mmap
21:59:16 <lambdabot> package bindings-mmap
21:59:17 <lambdabot> package bytestring-mmap
21:59:24 <Axman6> @hackage mmap
21:59:24 <lambdabot> http://hackage.haskell.org/package/mmap
21:59:35 <Axman6> uh, probably want bytestring-mmap
21:59:48 <mysticc> Can I have operators as data constructors ?
21:59:50 <coldpizza72i> Could someone possibly tell me where to begin on my lab. Im a little unsure of what to do. This is all I have http://ideone.com/q8nBg http://www.cs.rit.edu/usr/local/pub/jeh/courses/FP/Labs/CedarRope/
22:00:36 <shapr> coldpizza72i: When is this due?
22:00:48 <coldpizza72i> 23hours
22:00:53 <YayMe> oo memory mapped files for posix and windows, I like
22:00:54 <coldpizza72i> why
22:01:19 <shapr> coldpizza72i: How much prior experience do you have with Haskell?
22:01:37 <coldpizza72i> 4 weeks
22:02:30 <Axman6> coldpizza72i: we won't do your homework for you. we can help with specific questions if you can show us that you've tried and you're stuck
22:02:44 <shapr> coldpizza72i: You should start by reading the paper on ropes.
22:03:28 <shapr> coldpizza72i: Then you should implement the typeclass Rope as described in the assignment.
22:03:30 <mysticc> Is something like this possible data A = (--->) b c ?
22:03:37 <mysticc> with some extension
22:03:43 <Axman6> mysticc: i think you need to begin the name of the operator with :
22:03:49 <Axman6> so :--> should be fine
22:04:07 <Axman6> @src Complex
22:04:08 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
22:04:28 <mysticc> Axman6: Yeah I am doing that right now, but I wanted to know if there is any extension to avoid that ..
22:04:30 <coldpizza72i> shapr: Does what I have so far look like I'm heading in the iright direction
22:05:03 <shapr> coldpizza72i: Yes
22:05:12 <Axman6> coldpizza72i: don't you only have what's been given to you in the specicication?
22:05:25 <shapr> Axman6: yes :-)
22:05:58 <coldpizza72i> In the write up it says TextRope (provided) put i don't see it...
22:07:13 <shapr> coldpizza72i: You could email your instructor and ask for it?
22:07:54 * shapr goes back to writing C++ homework
22:08:19 <Axman6> that lab looks a wee bit like it's been written by someone who doesn't know what they're doing...
22:08:28 <YayMe> if I cabal install a new package do I need to kill ghci to get it to load a file importing it?
22:08:36 <Axman6> YayMe: yeah
22:08:39 <shapr> Axman6: I like Ropes, looks like a fun assignment to me.
22:08:47 <YayMe> how do I kill ghci? quit, exit, not working
22:08:51 <shapr> :q
22:08:57 <shapr> which is short for :quit
22:08:59 <Axman6> me too, but there are some oddities in there: " show :: Rope -> String"
22:09:11 <Axman6> "The traditional string representation of the rope. Rope must derive the type class Show, but not leave it to the system to provide the default implementations of the function."
22:09:21 <shapr> Seems to make sense to me?
22:09:23 <shapr> Why wouldn't it?
22:09:52 <shapr> Axman6: Am I missing something?
22:10:49 <nejucomo> Awesome.  The answer to my previous question of "are promoted kinds" in any ghc release is: yes, it works on 7.4.1 with DataKinds and KindSignatures.
22:11:14 <Axman6> well, it says it must derive Show, but you can't leave it to the system to give the definitions. so it's not really being derived, you need to make an instance yourself
22:17:18 <YayMe> woot it's running in attoparsec now (and failing spectacularly! but running!)
22:17:47 <YayMe> using mmap to read the file, thanks for that axman was way easy
22:20:56 <coldpizza72i> shapr: how long do you think it will take me to code it if i knew what was going on?
22:21:42 <shapr> coldpizza72i: If you already understood ropes and you'd been writing Haskell for awhile, and you had an existing Ropes library to crib from, probably just a few hours.
22:22:50 <YayMe> seems there's so little code to write with haskell to do a thing I'd figure on any given task you spend way more time figuring out what to do than actually writing the code
22:22:54 <shapr> coldpizza72i: Ropes aren't complex, so you could try to read the paper and do all that, but I would strongly suggest starting as early as possible when there are two new things in an assignment, such as Haskell and Ropes together.
22:24:29 <coldpizza72i> damn a few hours
22:24:54 <shapr> coldpizza72i: Having some code that does something will probably get you grade higher than a zero, right?
22:25:32 <YayMe> I feel brain dead for having worked on ginormous state machine parsers in enterprisey software in the past and not knowing about combinatory parsers, what a better way to do it.. large state machine is practically synonymous with bug-rife and we enterprisey ninnies seem far too happy to accept bugs without looking for a solution
22:26:01 <coldpizza72i> What are the 5 coolest purely function data structures in you opinion?
22:26:36 <shapr> er, Trees, Finger Trees, Zippers and ... I dunno what else.
22:26:38 <latro`a> zippers aren't really a single data structure
22:26:40 <latro`a> but
22:26:42 <latro`a> them
22:26:44 <aristid> data Void
22:26:45 * YayMe likes the int, a timeless classic!
22:26:50 <latro`a> uh
22:26:51 <YayMe> night all thanks for the parser help!
22:26:59 <shapr> I also like amortized data structures in Haskell.
22:27:04 <latro`a> strictly speaking the normal numerical types are actually rather impure
22:27:10 <shapr> g'nite YayMe!
22:27:11 <latro`a> as I recall
22:27:32 <latro`a> oh, also, purely functional sharing is rather elegant when it is easy
22:27:44 <latro`a> such as in the most common non-horrible definition of the fibonacci numbers
22:28:22 <latro`a> also not a data structure, but it's a thing lazy data structures do-
22:28:23 <latro`a> *do
22:29:53 * hackagebot cakyrespa 0.0.15 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.15 (YoshikuniJujo)
22:29:58 <nejucomo> Can I make "kind assertions" outside of GADT heads?
22:32:30 <ivanm> IIRC, I've seen someone use criterion to benchmark C code
22:32:38 <ivanm> does anyone know what I'm talking about?
22:34:14 <shapr> ivanm: If you find out, I want to know!
22:34:40 <ivanm> well, I'm guessing you can because how else does bos profile C implementations?
22:35:15 <shapr> good point
22:36:23 <ivanm> then I just have to work out how to re-write my Haskell function in C (including appropriate data structures) just so that I can provie Haskell isn't _too_ slow...
22:36:32 <ivanm> shapr: there's this for starters: http://nathanwiegand.com/wp/2010/03/profiling-c-with-haskell/
22:37:26 <shapr> nifty!
22:37:41 <shapr> I should use this to do QuickCheck testing on my C++ :-P
22:38:04 <ivanm> that sounds like fun
22:38:22 <ivanm> because C++ bindings in Haskell are _so_ convenient/fun :s
22:38:48 <ivanm> (unless something changed recently, most things that I found on the subject were either a) use a C shim, or b) good luck with that :s)
22:39:29 <shapr> heh
22:51:33 <coldpizza72i> shapr: do you think you can critique what i have so far http://ideone.com/Q5hCg
22:54:42 <coldpizza72i> or someone else...
22:57:00 <lispy> coldpizza72i: I'm not sure where to begin
22:57:10 <coldpizza72i> ut oh
22:57:12 <lispy> coldpizza72i: What tutorials have you looked at so far?
22:57:26 <coldpizza72i> its not my first hs program
22:57:34 <lispy> coldpizza72i: a very simple thing, the class at the top is not actually doing anything
22:57:54 <lispy> It just declares a Rope class but it doesn't have anything inside it
22:58:26 <lispy> coldpizza72i: in Haskell, class is for type classes. If this is your first haskell program I would recommend just leaving it out
22:58:50 <coldpizza72i> its supposed to be a type class
22:59:10 <shachaf> coldpizza72i: Uh...
22:59:33 <shachaf> That's a very strange program. What are you trying to accomplish?
22:59:40 <lispy> coldpizza72i: you can't derive a user defined type class, so that "deriving Rope" won't work there
23:00:06 <shachaf> GHC also doesn't do nullary classes.
23:00:14 <shachaf> Did you compile any of this yet?
23:00:48 <lispy> coldpizza72i: You want to make a type class for Ropes?
23:01:36 <coldpizza72i> I believe thats what my lab is saying http://www.cs.rit.edu/usr/local/pub/jeh/courses/FP/Labs/CedarRope/
23:01:55 <coldpizza72i> I could be mistaken… "The simple version to be implemented here is the type class Rope with three derived types."
23:02:04 <latro`a> if that's the case then the class needs to take a parameter
23:02:15 <zzing> What does this syntax do?    import "thaumaturge" Application (getApplicationDev)
23:02:25 <latro`a> a nullary class like that can't actually have any instances
23:02:43 <shachaf> zzing: Specifies package.
23:02:56 <zzing> I take it that PackageImports   is what does this
23:03:07 <lispy> I'm sad to see a homework assignment that teaches students to write partial functions.
23:03:09 <shachaf> "derived types" :-(
23:03:31 <zzing> lispy, define partial function
23:03:42 <lispy> > fromJust Nothing
23:03:43 <lambdabot>   *Exception: Maybe.fromJust: Nothing
23:03:56 <lispy> zzing: it's a function that doesn't work on all of it's domain
23:04:01 <zzing> oh, the ones that can blow up
23:04:13 <shachaf> That homework assignment doesn't promising.
23:04:30 <lispy> shachaf: You just the whole assignment?
23:05:03 * zzing hands lispy a bag containing verbs
23:05:06 <shachaf> lispy: Accidentally, it seems that I indeed.
23:05:44 <Ralith> shachaf: well, you have to give them for.
23:07:14 <zzing> Is there an easy way to support something like what visudo does - you output to a unique file name, spawn an editor and wait, when it quits read in the file
23:08:03 <shachaf> zzing: visudo -f blah
23:08:12 <lispy> coldpizza72i: I would recommend spending some time with a tutorial getting used to the language. I would recommend, http://learnyouahaskell.com/chapters
23:08:21 <zzing> shachaf, I mean written in haskell (my own program)
23:09:20 * certainty was wondering if the ""haskell's pure function are easier to reason about" argument really is thatstrong. Technically the "same return value for same input" rule holds, but under polymorphism, it is not necassarily immediatly ovious which function is actually called. At least not by its name.  hmmm
23:09:21 <shachaf> Presumably you would need to do the same thing visudo does.
23:09:31 <shachaf> I don't think there's a Haskell library for it or anything.
23:09:41 <lispy> zzing: Yeah, one of the functions you would want is here: http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#v:waitForProcess
23:11:22 <lispy> certainty: reasoning about higher order arguments requires stating assumptions about the passed in functions
23:11:29 <zzing> I think this would work very well thank you
23:11:45 <lispy> certainty: those assumptions cane be turned into properties and you can generate lemmas
23:12:18 <ski> certainty : by "polymorphism", do you really mean "(type-class) overloading" ?
23:12:30 <certainty> lispy: i'm not sure i can follow. The point i'm pondering about is more from a pragmatic programmer's point of view
23:12:35 <certainty> ski: yes that's what i mean
23:12:35 <zzing> Is there an easy way to parse a file in form of a series of fields like    title:   ….  \n author: …..  and then after the fields having all the other content? I was hoping I wouldn't have to write my own parser :-)
23:12:49 <lispy> zzing: I was just maintaining a haskell program at work today that we use as a script instead of bash. The script does a bunch of complicated stuff with ssh and whatnot. So Haskell is certainly up to the task.
23:13:13 <johnw> zzing: that would be trivial to do in parsec or attoparsec
23:13:29 <zzing> johnw, I guess I will be continuing my parsec education then
23:13:36 <lispy> zzing: if they are really one field per line you can use lines
23:13:49 <lispy> > lines "hi\nhow\nare\nyou"
23:13:50 <johnw> once the parser stops, it will give you the parsed fields and the 'rest of the output'
23:13:50 <lambdabot>   ["hi","how","are","you"]
23:13:54 <johnw> s/output/input
23:14:24 <lispy> > lines "title: foo\nauthor: me\n"
23:14:25 <lambdabot>   ["title: foo","author: me"]
23:14:44 <zzing> lispy, sounds reasonable
23:14:51 <johnw> map (T.splitOn ' ') . lines $
23:15:10 <johnw> or split on the ": " separator
23:16:59 <zzing> So I wouldn't have to make a new parser for it :-)
23:17:13 <lispy> > map (span (/=':')) (lines ["title: foo\nauthor: me"])
23:17:14 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
23:17:15 <lambdabot>         against inferred type...
23:17:33 <johnw> zzing: well, you also have to split between the header block and the rest of the input
23:17:40 <johnw> honestly, Parsec isn't that hard to use
23:17:40 <zzing> true
23:17:50 <zzing> johnw, I made one applicative parser with it
23:17:55 <johnw> cool!
23:18:04 <zzing> I can probably do it again, I just need to find the code to 'bootstrap' this one
23:18:13 <lispy> > map (span (/=':')) (lines "title: foo\nauthor: me")
23:18:14 <lambdabot>   [("title",": foo"),("author",": me")]
23:19:23 <lispy> > fmap (fmap (tail.tail)) (map (span (/=':')) (lines "title: foo\nauthor: me")) -- This is cheating a bit
23:19:25 <lambdabot>   [("title","foo"),("author","me")]
23:19:45 <johnw> zzing: many (liftM2 (,) (many char <* string ": ") (many char <* newline))
23:19:50 <johnw> something along those lines
23:19:58 * zzing steals the code for later
23:20:37 <zzing> all good code that I will see
23:20:44 <shachaf> > fmap (fmap (fmap (fmap tail tail))) (fmap (span (/=':'))) (lines "title: foo\nauthor: me")
23:20:45 <lambdabot>   [("title","foo"),("author","me")]
23:20:55 <sopvop> cabal install cabal-install -- looks scary :)
23:20:57 <shachaf> > fmap (fmap (fmap (fmap (fmap tail tail))) (fmap (span (/=':')))) lines "title: foo\nauthor: me"
23:20:57 <lambdabot>   [("title","foo"),("author","me")]
23:21:10 <lispy> shachaf: haha
23:21:32 <zzing> excessive?
23:21:41 * shachaf stops here.
23:21:46 <shachaf> You haven't seen excessive.
23:22:17 <lispy> :t (.)
23:22:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:22:33 <johnw> huh?
23:22:47 <zzing> shachaf, I dare you to make something even more excessive
23:23:02 <shachaf> zzing: :-(
23:23:09 <shachaf> Don't spam the channel with bot commands like that.
23:23:15 <shachaf> > fmap (fmap (fmap (fmap fmap fmap fmap fmap tail tail)) (fmap (span (/=':')))) lines "title: foo\nauthor: me"
23:23:16 <lambdabot>   [("title","foo"),("author","me")]
23:24:00 <shachaf> > fmap (fmap (fmap (fmap fmap fmap fmap) (fmap fmap fmap fmap) fmap tail tail) (fmap (span (/=':')))) lines "title: foo\nauthor: me"
23:24:01 <lambdabot>   [("title","foo"),("author","me")]
23:24:23 <shachaf> > fmap (fmap (fmap fmap fmap fmap (fmap fmap) fmap fmap (fmap fmap fmap fmap) fmap tail tail) (fmap (span (/=':')))) lines "title: foo\nauthor: me"
23:24:24 <lambdabot>   [("title","foo"),("author","me")]
23:24:31 <shachaf> Etc.
23:24:41 <zzing> shachaf, what are all of those things doing?
23:25:01 <sopvop> no `cabal sandbox` in cabal-install-0.17. Disappointed.
23:25:01 <shachaf> fmapping
23:27:19 <byorgey> you mean 0.16?
23:27:29 <sopvop> oj
23:27:30 <johnw> or, 1.16
23:27:36 <byorgey> that too
23:27:38 <sopvop> right 16
23:27:57 <byorgey> the sandbox stuff is still being worked out, I think
23:28:17 * byorgey is excited about -j
23:28:28 <sopvop> -j is nice
23:28:33 * shachaf finds the idea of ghc -j much more exciting.
23:28:41 <johnw> indeed!
23:28:45 <byorgey> likewise
23:28:54 <johnw> although, even gcc doesn't have -j
23:29:12 <sopvop> what have we here... "hiddenCommand $  sandboxConfigureCommand `commandAddAction` sandboxConfigureAction"
23:29:16 <YayMe> stupid insomnia
23:29:35 <Nereid> what's -j?
23:29:35 <isomorphic_> -j is a sandbox thing?
23:29:42 <johnw> -j = parallel builds
23:29:54 <Nereid> oh, for cabal.
23:30:22 <Nereid> it wouldn't make sense for gcc to have -j, that's make's job.
23:30:57 <sopvop> Nereid: cabal runs `ghc --make`.
23:31:04 <Nereid> oh.
23:31:10 <Nereid> I understand now.
23:31:31 <johnw> can ghc still do it's cross-module optimizations if it were built module-by-module via make?
23:31:35 <sopvop> But cabal -j is for parallel dependency building
23:35:23 <sopvop> johnw: I think I've read It optimizes only inlines, and inlines are kept in .hi files. But I'm not sure here.
23:35:28 <byorgey> johnw: yes, I think so.  GHC still doesn't do whole-program optimization.  It really does look at each module one at a time.  But it saves extra information in the .hi file and then when compiling a module can use the .hi file from previously compiled modules to do cross-module optimization like inlining etc.
23:35:43 <sopvop> :)
23:35:47 <byorgey> =)
23:37:59 <sopvop> I'll make my own sandbox! With export CABAL_CONFIG (and hookers)
23:38:58 <Robdgreat> you had me at "and hookers"
23:39:33 <Robdgreat> also up above what I read at first was "commandAddiction"
23:39:50 <YayMe> anybody know why attoparsec would complain "not enough bytes" ?
23:40:11 <johnw> thanks
23:40:51 <YayMe> oh I got it
23:40:52 <YayMe> score
23:46:09 <ivanm> is it just me, or does going to bos' blog _not_ show the latest entry?
23:47:17 <ivanm> shapr: still here?
23:48:36 <sopvop> http://www.serpentine.com/blog/ this blog? last entry is Performance: yes, it's worth...
23:49:28 <ivanm> sopvop: the latest post is about hashing
23:49:53 <sopvop> here yo go a direct link. http://www.serpentine.com/blog/2012/10/02/a-fast-new-siphash-implementation-in-haskell/
23:50:05 <ivanm> yeah, I know the link :)
23:50:29 <ivanm> I was just trying to get to it, so I first just went to serpentine.com ... only to find that the last listed post was from June :s
23:50:45 <sopvop> Oh, the wordpress. Guess it's all about PHP then
23:51:05 * sopvop does 5 minutes of PHP hate every morning.
23:52:02 <shachaf> ivanm: @tell bos
23:52:43 <ivanm> shachaf: I'm sending him an email :)
