00:00:09 <neworder> got it, thanks!
00:00:34 <shachaf> newsham: This neworder person is taking up your tab-completion prefix. Are you just going to stand there?
00:00:55 <mm_freak> new-order vs. news-ham
00:01:13 <neworder> haha
00:01:21 <Nereid> ahh.
00:01:21 <neworder> Anything I violated?
00:01:23 <Nereid> type family.
00:01:38 <mm_freak> neworder: you're just cluttering the namespace…  don't worry
00:01:43 <Nereid> "NB: `Hi' is a type function, and may not be injective"
00:01:56 <shachaf> Right.
00:02:24 <Nereid> so I can write x = undefined :: forall a. Hi a
00:02:32 <Nereid> but as soon as I write id x, explosion.
00:02:58 <mm_freak> if bottom is allowed, foo is easy to implement
00:03:00 <mm_freak> foo = undefined
00:03:11 <Nereid> sure.
00:03:18 <Nereid> or even foo x = undefined
00:03:37 <mm_freak> anyway, i don't think it's possible without bottom
00:04:46 <mm_freak> let's translate this to DT:  Hi : Set -> Set, foo : (A : Set) -> ((A' : Set) -> Hi A') -> Hi A
00:05:24 <shachaf> foo : ((A' : Set) -> Hi A') -> ((A : Set) -> Hi a)
00:06:52 <mm_freak> hmm
00:06:57 <mm_freak> weird
00:07:21 <Nereid> you know.
00:07:24 <Nereid> it's probably just
00:07:27 <Nereid> we can't have any values of type forall a. Hi a
00:07:34 <Nereid> other than bottom
00:07:44 <mm_freak> but in that notation foo = id is well-typed
00:07:56 <mm_freak> isn't it?
00:07:58 <shachaf> OK, foo :: (forall a. Hi a -> Hi a) -> (forall b. Hi b -> Hi b)
00:08:20 <shachaf> mm_freak: It looks OK to me, but I don't know. :-)
00:09:51 <Nereid> I clearly have yet to wrap my head around type families.
00:10:09 <mm_freak> wait, no
00:10:12 <mm_freak> foo = id isn't valid
00:11:00 <lpvb> v                                             hggggggggggggggg    g
00:11:03 <lpvb>                                                                                                                   whder
00:11:05 <lpvb> oh sorry
00:11:35 <mm_freak> but foo x = x is valid
00:11:36 <lpvb> what's the difference between the following packages: transformers, mtl, monads-tf ?
00:12:09 <mm_freak> lpvb: monads-tf uses associated types instead of fundeps
00:12:18 <mm_freak> lpvb: mtl is a higher level interface to transformers
00:12:23 <mm_freak> as is monads-tf
00:12:34 <mm_freak> mtl is the new monads-fd
00:13:41 <lpvb> what does it accomplish? I haven't learned type families yet
00:14:02 <mm_freak> shachaf: in agda this works…  that's probably because it's more type-checky than haskell
00:14:26 <shachaf> mm_freak: What's your Hi?
00:14:49 <hpaste> “Ertugrul Söylemez” pasted “Translation of type family to Agda” at http://hpaste.org/76557
00:14:58 <mm_freak> see paste
00:15:46 <shachaf> Oh, well, that's not the same.
00:16:05 <mm_freak> no?
00:16:12 <shachaf> That would be like data X; type family Hi a; type instance Hi a = X; foo :: (forall a. Hi a) -> (forall b. Hi b)
00:16:20 <shachaf> Which does work with foo x = x
00:16:36 <mm_freak> so when does it fail to work?
00:16:53 <shachaf> The Haskell version doesn't have an instance.
00:17:05 <mm_freak> ah, you can't have that in agda
00:17:06 <Nereid> can you write foo : (Hi : Set -> Set) -> ((A' : Set) → Hi A') → ((A : Set) → Hi A)?
00:17:30 <shachaf> Yes, that would be more similar.
00:17:39 <mm_freak> ah
00:17:43 <shachaf> mm_freak: Can you? :-)
00:17:55 * shachaf doesn't have an Agda.
00:17:59 <mm_freak> works
00:18:00 * Nereid either
00:18:08 <shachaf> OK.
00:18:08 <mm_freak> foo : (Hi : Set → Set) → ((A' : Set) → Hi A') → ((A : Set) → Hi A)
00:18:08 <mm_freak> foo Hi x = x
00:18:17 <shachaf> I'm not sure that that corresponds to type families either...
00:18:24 <mm_freak> it doesn't
00:18:26 <shachaf> Type families are weird.
00:18:35 <mm_freak> because the first argument to foo also has to be a total function
00:18:42 <shachaf> They're open like classes.
00:18:50 <mm_freak> type families with missing instances are neither total nor partial
00:18:55 <mm_freak> they're just incomplete
00:19:57 <mm_freak> the closest to the haskell version i could write in agda was:  Hi x = ?
00:20:00 <mm_freak> and it type-checked
00:20:53 <shachaf> That's not really the same.
00:20:58 <minopret> Who will/did write "Category Theory for the Loafing Nerd" (vs Working Mathematician or Computer Scientist)? Would people read it?
00:21:08 <mm_freak> it probably doesn't work because without the instance the haskell compiler can't prove that it's type-correct
00:21:24 <mm_freak> it would be, regardless of the instance, but the compiler simply doesn't know that
00:21:32 <mm_freak> it doesn't invent an instance just to make sure
00:22:13 <mm_freak> agda does in fact type-check up to the hole
00:22:24 <mm_freak> and it's valid up to that
00:22:46 <Nereid> two questions unrelated to this.
00:22:46 <mm_freak> (obviously, because the type makes sense)
00:23:13 <Nereid> (1) is there an easy way to clean up .cabal of packages which aren't registered according to ghc-pkg? (2) is this a good idea?
00:23:43 <mm_freak> Nereid: (1) no, (2) probably not
00:23:51 <Nereid> (2) why not?
00:24:01 <mm_freak> (2), because .cabal contains many things that aren't registered
00:24:08 <mm_freak> binaries, data files, etc.
00:24:21 <Nereid> I mean for packages that only supply libraries.
00:24:43 <mm_freak> they still might supply auxilliary files
00:24:58 <Nereid> ok, what if I know it's ok to remove them?
00:25:02 <mm_freak> only the library files and module interfaces are registered
00:25:12 <mm_freak> then just remove
00:25:15 <Nereid> true
00:25:25 <Nereid> that was a pretty silly question
00:25:36 <mm_freak> if you're certain that GHC doesn't know about the files, it's safe to remove them
00:25:43 <mm_freak> cabal itself doesn't keep track
00:26:05 <Nereid> I know cabal doesn't.
00:26:30 <Nereid> I just don't want my .cabal filled with junk.
00:26:55 <mm_freak> Nereid: to make sure, just run a grep -R through ~/.ghc
00:26:55 <Nereid> maybe I shouldn't care so much.
00:27:01 <mm_freak> if the file isn't mentioned, you can safely remove it
00:27:14 <mm_freak> you probably shouldn't
00:27:30 <mm_freak> unregistered stuff is going to be deleted on your next world upgrade =)
00:27:49 <Ralith> oh good
00:27:53 <Ralith> sounded like a serious space leak there
00:27:59 <mm_freak> rm -rf ~/.cabal/{bin,lib,share}; rm -rf ~/.ghc
00:28:03 <Nereid> heh
00:28:04 <mm_freak> cabal update && cabal upgrade
00:28:20 <mm_freak> there you go, all extra stuff gone, except downloaded packages
00:28:28 <mm_freak> uhm
00:28:31 <mm_freak> upgrade?
00:28:33 <mm_freak> no
00:28:35 <mm_freak> cabal install world
00:28:52 <Nereid> what if my cabal is in .cabal/bin
00:28:54 <Nereid> :v
00:29:13 <mm_freak> is it?
00:29:16 <Nereid> ...yes
00:29:24 <mm_freak> ok, forget everything i said
00:29:33 <mm_freak> get your build system safe first ;)
00:29:41 <Nereid> lol
00:29:59 <Nereid> what's wrong with it?
00:32:35 <elliott> type family Hi a; data Foo = Foo (forall a. Hi a)
00:32:51 <elliott> How do you write foo :: Foo -> Foo?
00:32:53 <elliott> Without just using id.
00:33:02 <Nereid> why not foo x = x
00:33:04 <elliott> (foo (Foo x) = Foo x doesn't type.)
00:33:11 <shachaf> mm_freak: ☝
00:33:19 <elliott> Nereid: That's cheating. I can make the example complex enough that it won't work, if you'd like.
00:33:37 <elliott> type family Hi a; data Foo a = Foo (forall b. Hi a); writeThis :: Foo a -> Foo b
00:33:37 <elliott> Done.
00:33:43 <elliott> er
00:33:45 <elliott> type family Hi a; data Foo a = Foo (forall b. Hi b); writeThis :: Foo a -> Foo b
00:33:46 <Nereid> what?
00:33:51 <Nereid> heh.
00:33:59 <elliott> Now writeThis = id doesn't work.
00:34:06 <Nereid> unsafeCoerce ;)
00:34:10 <elliott> Disclaimer: I don't know of any implementation of writeThis that works that isn't unsafeCoerce.
00:34:15 <elliott> But surely you must be able to write it.
00:34:18 <dibblego> https://gist.github.com/3926241
00:34:27 <dibblego> List zipper "move to nth"
00:34:30 <mm_freak> Nereid: nevermind =)
00:34:35 <Nereid> ?
00:35:04 <Nereid> no, I'd honestly like to know if I'm doing something horrible.
00:35:32 <mm_freak> elliott: obviously it doesn't work
00:35:33 <Nereid> because all I did was install a ghc binary and then install everything else with cabal.
00:35:43 <Nereid> (including cabal-install and its deps)
00:35:48 <mm_freak> but as long as writeThis is an instance of a -> a, you can certainly say writeThis x = x
00:36:05 <elliott> mm_freak: Foo a -> Foo b doesn't unify with a -> a.
00:37:12 <hpaste> JL pasted “Type declaration error” at http://hpaste.org/76558
00:41:32 <Nereid> hpaste: for [1..y] to make sense needs Enum a
00:41:48 <elliott> I think you want to be pinging JL_ instead
00:41:53 <Nereid> hahaha
00:41:53 <Nereid> yes.
00:42:10 <Nereid> but that doesn't explain the error.
00:42:52 <JL_> Nereid: i tried declaring everything, seems like it doesn't work that way
00:42:53 <Nereid> oh.
00:42:56 <Nereid> infinite is fine
00:43:06 <mm_freak> Nereid: just seems to make updates more difficult
00:43:11 <mm_freak> nothing serious
00:43:29 <mm_freak> to update i just clean my .cabal and .ghc and then update/install world
00:43:32 <Nereid> mm_freak: I could just move the cabal binary elsewhere
00:43:37 <mm_freak> with the commands above
00:43:44 <mm_freak> elliott: hence it doesn't work
00:43:59 <Nereid> JL_: it's when you type infinite 1 2 in ghc that it doesn't like it.
00:44:03 <mm_freak> your example is not the same as shachaf's one and it doesn't help his point
00:44:25 <mm_freak> for (forall a. Hi a) -> (forall b. Hi b), id should be a solution
00:44:28 <mm_freak> but it's not in haskell
00:44:33 <Nereid> JL_: it doesn't have a default type that's both Integral and Fractional.
00:44:34 <mm_freak> because of type family weirdness
00:44:36 <JL_> Nereid: yea, you know why ?
00:44:48 <hagb4rd> hi.. i have defined a 'data Vector4 a = Vector4 a a a a;' in a script..but how or where the heck do i have to place the constructing 'p1 = Vector 0.0 0.0 0.0 0.0' part so i access p1 after loading the script with ghci -script.hs
00:44:59 <elliott> mm_freak: what point
00:45:05 <Nereid> JL_: it doesn't know what concrete type to make a
00:45:08 <shachaf> I had a point?
00:45:18 <elliott> i wasn't looking at anything being said earlier
00:45:19 <elliott> fwiw
00:45:24 <elliott> i was just legitimately looking for a solution to this
00:45:28 <JL_> :t (^)
00:45:30 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
00:45:35 <elliott> if shachaf has been talking about related things it will have been because i mentioned the problem to him
00:45:44 <mm_freak> i see
00:45:45 <JL_> :t product
00:45:47 <lambdabot> forall a. (Num a) => [a] -> a
00:45:52 <shachaf> mm_freak: Yes, elliott started it.
00:45:58 <JL_> :t (/)
00:46:00 <lambdabot> forall a. (Fractional a) => a -> a -> a
00:46:12 <mm_freak> hagb4rd: in script.hs?
00:46:16 <Nereid> > (id :: Integral a, Fractional a => a -> a) 3
00:46:17 <lambdabot>   <no location info>: parse error on input `=>'
00:46:23 <Nereid> eh
00:46:25 <mm_freak> hagb4rd: also for scripts there is runhaskell
00:46:38 <shachaf> Nereid: s/,/ =>/
00:46:52 <Nereid> > (id :: (Integral a, Fractional a) => a -> a) 3
00:46:53 <lambdabot>   Ambiguous type variable `a' in the constraints:
00:46:53 <lambdabot>    `GHC.Real.Fractional a'
00:46:54 <lambdabot> ...
00:47:03 <hagb4rd> yea everything works fine while using ghci.. i can use let v1 = Vector bla bla bla bla
00:47:15 <hagb4rd> but ut doensnt work in script
00:47:34 <Nereid> ghci is a bit more liberal in a couple ways
00:47:38 <Nereid> it does more type defaulting
00:47:54 <JL_> Nereid: is it because x^y returns a num a, product returns a num but n / m requires a fractional ?
00:48:12 <hagb4rd> i really just want to load an initial script setting up a few types and functions.. thats all..the really most basic way it is possible
00:48:42 <Nereid> JL_: infinite itself is fine.
00:48:49 <Nereid> JL_: you'll have the exact same issue with *any* function of the same type
00:49:57 <Nereid> JL_: also, there aren't many types that are instances of both Integral and Fractional.
00:50:00 <Nereid> in fact, I can't think of any.
00:50:54 <hagb4rd> mm_freak? let's have 'data Vector4 a = Vector4 a a a a; let p1 = 0.0 0.0 0.0 0.0;' <-- works fine while typed i ghci.. who do i need to fuck to get just this snippet to run intially before the cli starts?
00:51:02 <Nereid> JL_: maybe you should see if you can write a similar function, with type (Fractional a, Integral b) => a -> b -> a
00:51:22 <JL_> Nereid: ok i will try that
00:51:57 <Nereid> JL_: the issue is that when you write "infinite 1 2", ghci has to figure out which concrete type 1 and 2 are.
00:52:08 <Nereid> so it tries some defaults.
00:52:21 <Nereid> but none of those work, because no type in sight is an instance of both Integral and Fractional.
00:52:40 <Nereid> also, the Num constraint is redundant.
00:53:10 <JL_> Nereid: icic, how is num and integral different
00:54:31 <Nereid> JL_:
00:54:33 <Nereid> @type (^)
00:54:33 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
00:54:51 <Nereid> @type \y -> product [1..y]
00:54:52 <lambdabot> forall t. (Num t, Enum t) => t -> t
00:55:10 <Nereid> (it happens that Integral is a subclass of Enum, which is why you don't need an Enum constraint)
00:56:15 <JL_> Nereid: icic and integral is subclass of num as well ?
00:56:38 <Nereid> yes.
00:56:51 <Nereid> you can tell from the class definition, or from :info in ghci
00:57:12 <Nereid> (which tells you the class definition)
00:58:51 <JL_> :info Num
01:00:37 <JL_> Nereid: oh, i think integral is a subclass of real, which is a subclass of num
01:00:48 <JL_> Nereid: if i read :info correctly
01:01:55 <Nereid> yes
01:03:44 <JL_> thanks
01:05:49 <Nereid> if only we could go back in time and tell whoever came up with the numeric class hierarchy how to do it right.
01:07:13 <mikeplus64> anyone gotten wx installed on arch linux (if so how?)
01:08:14 <Nereid> mikeplus64: what problems are you having?
01:08:37 <Nereid> looks like there are some wxhaskell packages for arch. also http://www.haskell.org/haskellwiki/WxHaskell/Linux#Arch_Linux
01:08:52 <fmap> Nereid: and how to do it right?
01:09:52 <mikeplus64> Nereid: one moment
01:10:18 <mikeplus64> Nereid: i'll try what that suggests
01:11:01 <hagb4rd> data Vector4 a = Vector4 a a a a; let p1 = Vector4 0.0 0.0 0.0 0.0; <-- how do i get the 'first' of the four values of p1? let x = p1.??
01:12:36 <opqdonut> hagb4rd: pattern matching
01:13:05 <opqdonut> firstComponent :: Vector4 a -> a; firstComponent (Vector4 x _ _ _) = x
01:13:05 <hagb4rd> please..can u give me just one example?
01:13:34 <hagb4rd> is that the most usual way? it seemed so urggh
01:13:54 <opqdonut> the other ways is record syntax
01:14:24 <opqdonut> i.e. "data Vector4 a = Vector4 { vfirst :: a, vsecond :: a, vthird :: a, vfourth :: a }"
01:14:39 <opqdonut> which generates the functions vfirst :: Vector4 a -> a, etc.
01:15:04 <hagb4rd> so LastName :: Person a -> a; LastName (Person FirstName LastName Adress) = FirstName <-- would this work?
01:15:17 <hagb4rd> or how would you do that with more complex objects
01:15:19 <Nereid> hagb4rd: variables have to be lowercase
01:15:21 <opqdonut> yeah, except it needs to be lastName
01:15:21 <Nereid> otherwise, yes
01:15:30 <hagb4rd> ah
01:15:35 <opqdonut> you can also use pattern matching inside a let, like this: "let (Vector x _ _ _) = vec in 2*x"
01:15:43 <mikeplus64> Nereid: seems the newest wxgtk2.9 does not have --disable-compat28 ... (trying cabal install wx again)
01:16:01 <JL_> whats does "Could not deduce (b ~ a)" >?
01:16:02 <Nereid> lastName :: Person a -> a; lastName (Person firstName _ _) = firstName
01:16:09 <Nereid> JL_: ~ is type equality
01:16:15 <hagb4rd> this really feels kind of unusual
01:16:32 <hagb4rd> having objects with 30 properties i will have to write 30 underscores?
01:16:48 <hagb4rd> ^^
01:16:52 <Nereid> hagb4rd: again, record syntax gives you component functions
01:17:05 <zalenix_> Doing the tryhaskell interactive tutorial right now!
01:17:08 <Nereid> so if you wrote data Person = Person { lastName :: String, firstName :: String, address :: String }
01:17:17 <Nereid> then that would automatically give you functions lastName :: Person -> String, etc.
01:17:21 <hagb4rd> ah that feels more of what i need
01:17:34 <shachaf> I,I data Foo = forall a. Foo { blah :: a }
01:17:49 <Nereid> hagb4rd: the other syntax works too, i.e. you could still write Person a b c
01:18:11 <hagb4rd> okay.. thx Nereid
01:21:58 <mikeplus64> Nereid: no, it fails to build, with http://hpaste.org/76559
01:22:48 <Nereid> I don't know.
01:29:22 <gienah> mikeplus64: it needs the patch in the files directory, you might need to look at the ebuild as well for hints and look around for more patches to wxdirect, wxcore: https://github.com/gentoo-haskell/gentoo-haskell/tree/master/dev-haskell/wxc
01:31:20 <b__> is the use of Word instead of Int a worthwhile optimisation where possible?
01:38:02 <Nereid> b__: it's not an optimization. Word has the same size as Int; it's just unsigned
01:38:45 <b__> are operations on Ints and Words equally expensive?
01:39:09 <Nereid> probably.
01:39:15 <Nereid> just as equally expensive as long and unsigned long would be in C.
01:39:31 <b__> okay
01:39:36 <b__> thanks
01:39:53 <Nereid> there are types like Int32 or Word32 though
01:40:04 <b__> yeah
01:40:38 <Nereid> but on 32-bit ghc they're the same.
01:41:08 <Nereid> at least, on the one 32-bit ghc I have lying around (7.6.1 on win32)
01:42:02 <b__> yes same on 7.6.1 Mac OSX 64-bit
01:42:07 <b__> 7.4.1*
01:43:14 <Nereid> I mean Int is 32 bits.
01:43:24 <Nereid> on my 64-bit linux thing it's 64 bits.
01:43:38 <b__> yeah
01:43:57 <b__> for me it is 64 as well
01:54:16 <Polarina> b__, on x86, unsigned ind and int have the same addition and subtraction instructions. As far as registry and memory is handled, they are the same as well.
01:55:35 <Polarina> b__, if you don't need an unsigned integer, just use Int. Because you'll save yourself an import of Data.Word, and Int is shorter to type that Word. :)
01:57:59 <hpaste> s1yfox1 pasted “8 Queens 1” at http://hpaste.org/76562
01:59:29 * Jafet suddenly feels hungry
02:00:18 <shachaf> permutations defined with Eq? :-(
02:00:41 <Jafet> It's still O(1), dude.
02:00:49 <Jafet> Oh wait
02:00:57 <shachaf> O(wait)
02:01:07 <Jafet> O_WAIT
02:01:27 <mikeplus64> gienah: thanks, that patch fixed wxc
02:02:09 <gienah> mikeplus64: no worries, maybe you could update the entries in the AUR
02:30:44 <hpaste> nooodl pasted “tuple comonad” at http://hpaste.org/76563
02:31:13 <nooodl> ^ is this a correct and complete comonad definition?
02:32:47 <hiptobecubic> i think the functor definition is going to be a problem
02:33:01 <hiptobecubic> f depends on how deep your tuples go
02:33:06 <dibblego> yeah except I think it is better to insert Extend between Functor and Comonad
02:36:46 <nooodl> http://hpaste.org/76564 hmm, it seems to pass the laws for Functor and Comonad
02:37:07 <nooodl> hiptobecubic: could you give an example of where it'd break?
02:37:28 <dibblego> nooodl: you could also hlint that code — a couple of minor improvements
02:38:05 <dibblego> the signature of (=>>) typically has the arguments ordered the other way
02:38:18 <dibblego> and yeah, I like to move coreturn out
02:38:30 <dibblego> e.g. [] has (=>>) but not coreturn
02:39:39 <hiptobecubic> nooodl, i'm not very familiar with comonads in general, but it looks to me like fmap f (a,b) = (a, f b) depends on how many nested tuples b contains, (from cojoin for example). Maybe I'm missing how the whole thing should work
02:40:19 <dibblego> that's the right fmap
02:40:35 <hiptobecubic> feel free to dismiss my comment then. still learning :)
02:40:53 <hiptobecubic> oh i see
02:41:06 <hiptobecubic> from =>>
02:41:17 <dibblego> fmap f x = x =>> f . coreturn
02:41:53 <nooodl> dibblego: according to http://hackage.haskell.org/packages/archive/comonad/0.1.1/doc/html/Control-Comonad.html (=>>) is fine; (<<=) or extend would be the other way around
02:42:23 <dibblego> nooodl: yeah just that (<<=) is more "typical" — it aligns with fmap for example
02:42:51 <dibblego> nooodl: think of (<<=), (=<<), fmap, (<*>) as "functions that take something and return f a -> f b"
02:43:10 <fmap> is it coreader?
02:43:16 <dibblego> (<<=) :: (f a -> b)
02:43:23 <dibblego> (=<<) :: (a -> f b)
02:43:26 <dibblego> fmap :: (a -> b)
02:43:31 <dibblego> (<*>) :: f (a -> b)
02:43:41 <nooodl> ooh i see
02:44:21 <dibblego> brb
02:47:06 <dibblego> CoReader r a = (r, a)
02:54:46 <Tatranca> WWW. JIZZDAY .COM
02:59:13 <hagb4rd> how to concat a string and a doulble type to output string
02:59:14 <hagb4rd> ?
02:59:49 <hagb4rd> let info = "Speed" ++ speed;
02:59:53 <wto> :t show
02:59:54 <lambdabot> forall a. (Show a) => a -> String
03:00:03 <wto> hagb4rd: use show
03:00:40 <hagb4rd> <interactive>:62:1: Not in scope: data constructor `Show'
03:01:09 <wto> hagb4rd: lowercase!
03:01:56 <hagb4rd>  The function `show' is applied to three arguments,
03:01:56 <hagb4rd>  but its type `a0 -> String' has only one
03:01:56 <hagb4rd>  In the expression: show "hallo:" vx (vr)
03:01:56 <hagb4rd>  In an equation for `it': it = show "hallo:" vx (vr)
03:02:00 <hagb4rd> fuck!
03:02:31 <wto> hagb4rd: don't paste all your errors/code in the channel, use hpaste (see topic)
03:02:43 <hagb4rd> HOW CAN BE THE SIMPLEST POSSIBLE ISSUE SO FUCKED UP
03:02:44 <hc> "Speed" ++ (show speed)
03:02:59 <wto> also: do as hc did!
03:03:12 <hagb4rd> wonder what comes next
03:09:49 <hpaste> “Nicholas Grasevski” pasted “milestone3” at http://hpaste.org/76565
03:13:24 <hpaste> “Nicholas Grasevski” annotated “milestone3” with “milestone3 (annotation)” at http://hpaste.org/76565#a76566
03:14:14 * hackagebot language-javascript 0.5.7 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.7 (AlanZimmerman)
03:16:59 <TryingHaskell> Hey, does anyone know what the "$$" mean in haskell?
03:17:10 <ion> What’s its type?
03:17:29 <TryingHaskell> doesn't tell me, parse error
03:17:38 <dibblego> TryingHaskell: :type ($$)
03:17:41 <dibblego> what does that give
03:18:08 <ion> ($$) is just an operator defined somewhere, nothing in base exports that AFAIK.
03:18:40 <TryingHaskell> it doesnt tell me any type, :type ($$) returns a parse error
03:19:04 <TryingHaskell> but I see it show up quite often without it being defined as function anywhere
03:19:10 <dibblego> TryingHaskell: are you using GHCi or where are you seeing this function?
03:19:41 <TryingHaskell> yes GHCi, though I believe in this case it's shown in Hugs
03:19:52 <TryingHaskell> i don't know if it is much different
03:20:11 <ion> Hugs is a long-dead project, better just use ghci instead.
03:20:45 <TryingHaskell> ok, so it doesn't have any specific value in GHCi then?
03:21:16 <dibblego> TryingHaskell: only if you or some library defines it
03:21:59 <TryingHaskell> yes ok thanks
03:23:09 <ion> :t ($$) and :i ($$) give information about it in ghci.
03:23:11 <lambdabot> parse error on input `in'
03:24:10 <TryingHaskell> neither :t or :i give anything other than "not in scope: `$$' "
03:24:20 <TryingHaskell> for ($$) ofc
03:26:51 <ion> Load the file that uses ($$) in ghci first, you can then investigate it. For instance, run “ghci Foo.hs” in the shell.
03:27:24 <mm_freak> it's likely conduit
03:29:14 * hackagebot classify 2012.10.21 - Library for classification of media files.  http://hackage.haskell.org/package/classify-2012.10.21 (DavidHimmelstrup)
03:32:08 <alanz> TryingHaskell: See http://www.haskell.org/hoogle/?hoogle=%24%24
03:32:37 <dzhus> does darcs.haskell.org work for you? :(
03:33:17 <TryingHaskell> aha
03:37:09 <Polarina> In what module can I find the function withForeignPtr?
03:37:36 <Polarina> Hoogle points me to this 404 page: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-ForeignPtr.html#v:withForeignPtr
03:41:45 <haskellnoob> hey, why doesnt 1 == 1 == 1 work?
03:42:38 <dibblego> @type 1 == 1
03:42:40 <lambdabot> Bool
03:42:57 <dibblego> who goes around comparing a Bool to a number?
03:43:12 <ion> instance Num Bool
03:43:40 <fmap> the problem is actually `1 == 1 == 1' is neither `(1 == 1) == 1' nor `1 == (1 == 1)'
03:43:49 <Nereid> not to mention ==  is merely infix, not infixl/infixr
03:46:41 <Jafet> Polarina: Foreign.ForeignPtr.Safe
03:46:43 <ion> mod-4 algebra: instance Num (Either Bool Bool). Also instance Num (Bool,Bool) but for another reason.
03:47:00 <dada-cetacean> ((==1).(==1)) 1
03:47:11 <Jafet> > 2 + 2 == 2 * 2
03:47:14 <lambdabot>   True
03:47:30 <c_wraith> Either x x ≈ (Bool, x)
03:47:33 <Nereid> ion: why should there be a num isntance for Either anything?
03:47:48 <Jafet> Why not?
03:48:03 <Nereid> why?
03:48:14 <nand`> instance Num a => Either e a where (+) = liftM2 (+); fromInteger = Right . fromInteger; ...
03:48:17 <Jafet> No you
03:48:32 <ion> nereid: instance Num Bool to make (1 == 1) == 1 work, and Either instances to make larger mod-n algebras obviously.
03:49:00 <Nereid> Either Bool Int
03:49:11 <ion> Int is cheating.
03:49:19 <Nereid> why?
03:49:35 <Jafet> 0, 1, FileNotFound
03:50:12 <Nereid> nand`: (+) = liftM2 (+) would be surprising, as addition wouldn't be commutative...
03:51:02 <Nereid> I'd be fine with an instance Num Bool
03:51:03 <c_wraith> Nereid: it would with a commutative monad!
03:51:08 <Nereid> yes, it would, but not with Either
03:51:10 <ion> nereid: Disclaimer: i may not have been serious about instance Num Bool or instance Num (Either Bool Bool).
03:51:11 <Nereid> Either e*
03:51:12 <nand`> Nereid: it wouldn't?
03:51:22 <Nereid> nand`: what's Left a + Left b?
03:51:31 <nand`> oh, right
03:51:35 <ion> no, left
03:51:39 <Nereid> :V
03:51:56 <Nereid> anyway, Bool would make for a fine Num instance, as it ought to be the field Z/2Z
03:52:07 <Nereid> and we already have Num instances for tuples
03:52:24 <Nereid> and then (Bool,Bool) would be Z/2Z x Z/2Z
03:52:32 <dibblego> a CoNum instance for Either then?
03:52:33 <Nereid> which is not integers mod 4
03:52:40 <Nereid> haha, what's that :V
03:52:47 <Nereid> I guess there's such a thing as a coring.
03:52:49 <dibblego> yeah
03:53:27 <Nereid> I have never run into one in practice.
03:53:30 <Nereid> cogroups, yes. corings, no.
03:58:00 <Rc43> Hi, guys.
03:58:50 <Rc43> Again build error. Now it is haddock. How it can be? Isn't it stable package?
03:59:05 <Rc43> Not in scope: type constructor or class `SafeHaskellMode'
03:59:14 * hackagebot http-conduit 1.7.0 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.7.0 (MichaelSnoyman)
03:59:19 <Rc43> I just installing it with `cabal install`.
03:59:34 <Rc43> ghc 7.4.1
04:00:34 <Nereid> actually, cogroups don't exist in Set. or Hask, I guess.
04:01:04 <Nereid> well, there is one, the empty cogroup.
04:01:16 <Nereid> but they necessarily come equipped with a map to the initial object
04:02:15 <byorgey> Rc43: doesn't GHC come distributed with haddock?
04:03:01 <Nereid> it does not
04:03:11 <Nereid> although the platform would have it
04:03:19 <byorgey> Rc43: try installing an older version of Haddock, perhaps
04:03:31 <byorgey> maybe the newest version only builds with GHC 7.6 ?
04:03:56 <Nereid> 2.11.0 built fine on 7.4.2 here
04:04:14 * hackagebot dot2graphml 0.1.0.0 - Converter from GraphViz .dot format to yEd GraphML  http://hackage.haskell.org/package/dot2graphml-0.1.0.0 (IlyaPortnov)
04:04:51 <Rc43> byorgey, may be; will try
04:05:25 <Nereid> oh look
04:05:29 <Nereid> 2.13.1 has a dependency on ghc 7.6.*
04:05:43 <Nereid> 2.11.0 is the latest you'll be able to use.
04:06:05 <Nereid> but cabal knows that...
04:06:06 <Rc43> Nereid, doesn't cabal check versin of ghc?
04:11:05 <byorgey> Rc43: of course it does.  When I do 'cabal install haddock-2.13.1' (under ghc 7.4.2) I get this error: rejecting: ghc-7.4.1/installed-eea... (conflict: haddock => ghc==7.6.*)
04:11:08 <b__> I end up SPECIALIZE-ing certain functions that work on Integral values for Int, Integer, Word32 and Word64, but this looks kind of silly. Does it have an actual effect when you SPECIALIZE functions for so many specific types?
04:11:28 <byorgey> *7.4.1
04:12:11 <byorgey> Rc43: if you just did 'cabal install haddock' then it will choose version 2.11 for you
04:12:13 <Rc43> byorgey, if I don't specify version it will use max appropriate version?
04:12:19 <byorgey> yes
04:12:28 <Rc43> byorgey, or try latest version and then fail?
04:12:32 <Rc43> byorgey, ok
04:12:47 <byorgey> Rc43: so it's actually haddock-2.11 that doesn't build for you?
04:13:44 <byorgey> well, try 2.10
04:14:39 <Rc43> byorgey, it tries to install haddock-2.11.0, yes
04:15:29 <Rc43> hackage tells that "ghc (≥7.4 & <7.6)
04:18:51 <Rc43> haddock-2.10.0 succeeded
04:40:40 <Kyraimion> Is there a way to thaw a ByteString into an MArray?
04:44:16 <linduxed> what do you guys use for building projects?
04:44:30 <linduxed> is it good ol' make, or is there something else that Haskell uses?
04:44:41 <linduxed> like ruby has Rake
04:44:45 <Kyraimion> linduxed:  cabal
04:44:58 <linduxed> aaaah yes
04:45:04 <linduxed> that's true
04:59:12 <merijn> linduxed: I mostly use cabal with plain make for C code (if any)
05:02:58 <fmap> When I use `$(something)' syntax on the type level haddock chokes with "haddock: internal error: renameType". What am I doing wrong?
05:04:48 <hpc> there's probably some magic you need to do that makes haddock run on TH output
05:14:17 * hackagebot authenticate 1.3.1.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.3.1.2 (MichaelSnoyman)
05:14:19 * hackagebot yesod-auth 1.1.1.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.1.3 (MichaelSnoyman)
05:19:53 * nand` uses bash scripts
05:26:07 <b__> is there a reason other than indices being out of bounds for unsafeRead/unsafeWrite to fail?
05:30:55 <Nereid> b__: if by "fail" you mean "do weird and unpredictable things" then yes
05:31:15 <b__> yes that's what I mean
05:31:25 <Rc43> Eeeeeee, I have reinstalled haskell-platfrom and there is no cabal...
05:32:07 <b__> Nereid, is this behaviour documented? can't find much on the subject
05:36:00 <srhb> Nereid: Are you sure that's right?
05:36:05 <Nereid> no
05:36:08 <srhb> b__: Me neither, looks like that is the only thing that's left out.
05:36:32 <Nereid> but it's the impression I get from reading the wiki article on arrays
05:37:05 <srhb> "You can use these operations yourself in order to speed up your program by avoiding bounds checking. These functions are marked "unsafe" for good a reason -- they allow the programmer to access and overwrite arbitrary addresses in memory. These operations are especially useful if you need to walk through entire array:"
05:37:19 <srhb> Sounds like "if you use these and you fuck up the bounds, you are screwed - otherwise all is good."
05:37:25 <Nereid> yeah.
05:38:44 <b__> I explicitly check bounds, but still it goes banana's
05:38:52 <b__> I wonder if it has to do with lazy eval
05:41:28 <mcstar> you need to initialize elements before you access them ofc
05:42:02 <b__> I use "l <- newArray (1,lim) False"
05:42:13 <b__> is that enough?
05:43:01 <mcstar> it should be, i think
05:43:17 <mcstar> is this Data.Array?
05:43:23 <b__> and I do a check "when (a < m) $ unsafeRead l a >>= unsafeWrite l a . not"
05:43:29 <b__> yes it is
05:43:47 <mcstar> b__: you should post a whole snippet on hpaste
05:43:52 <b__> ok 1 sec
05:45:43 <hpaste> b__ pasted “unsafeRead” at http://hpaste.org/76569
05:45:45 <mcstar> btw, if you use safe indexing, you should get an oob error, if thats really the case
05:46:05 <b__> yeah I would think so too, so it's something more fundamental that I'm doing wrong probably
05:47:59 <b__> hm snippet has a typo
05:48:09 <b__> should be UArray / runSTUArray
05:48:29 <hpaste> b__ annotated “unsafeRead” with “unsafeRead (annotation)” at http://hpaste.org/76569#a76570
05:49:50 <b__> so with unsafeRead/Write, length $ primes 1000000 == 86158, when it should be 78498
05:51:24 <b__> which indicates that it skips sieving for certain values in that loop, because the unsafeWrite fails somewhere
05:52:44 <mcstar> can you paste Numbers.General?
05:53:02 <b__> yes, hold on
05:53:30 <hpaste> b__ annotated “unsafeRead” with “Numbers.General” at http://hpaste.org/76569#a76571
05:53:48 <Attic> Hey, anyone know the opposite of the filter function?
05:54:11 <b__> filter (not . foo) xs
05:54:18 <b__> as opposed to filter foo xs
05:55:30 <Attic> ahhh thank you!! :D
06:00:34 <mcstar> b__: i get different numbers even if i switch one of them to unsafe
06:00:39 <b__> yeah
06:00:48 <b__> any of them
06:01:58 <mcstar> b__: i think this has to do with unboxing rather than bounds checking
06:02:21 <b__> I tried to use Array / runSTArray
06:02:32 <b__> with unsafe*
06:02:46 <b__> same problems
06:04:44 <b__> in fact, exact same errors it seems
06:05:06 <mcstar> b__: well, with boxed arrays i get segfault
06:05:09 <mcstar> in ghci
06:05:19 <b__> yes, depending on which unsafe* you change
06:06:09 <mcstar> b__: are you on ghc 7.6?
06:06:19 <b__> .4
06:06:26 <mcstar> im on 7.6
06:07:04 <b__> I wonder if the forM_'s have something to do with it, and whether or not an explicit loop would work better
06:07:09 <mcstar> ill try to initialize the array for sure
06:07:21 <Rc43> Guys, does Haskell Platform 2012.2.0.0 contain cabal?
06:09:42 <b__> mcstar I seem to have found it
06:09:52 <b__> and it seems to be a bounds problem after all
06:10:28 <b__> the loops generate values lower than 5, which is the lowest bound
06:10:33 <b__> lower*
06:11:34 <mcstar> you should get an oob error for that with the safe functions
06:11:39 <b__> yeah you're right
06:13:11 <b__> yes nevermind
06:13:15 <b__> that's not it
06:17:29 <mcstar> well, initializing the array didnt help
06:18:58 <mcstar> b__: changing the lower bound of 5 to 1 lead to not having a segfault with unsafeRead, only a wrong result
06:19:18 * hackagebot tuple-hlist 0.1.0.2 - Functions to convert between tuples and HLists.  http://hackage.haskell.org/package/tuple-hlist-0.1.0.2 (NicolasDudebout)
06:19:25 <b__> hm ok
06:20:05 <mcstar> not, not ok :)
06:20:08 <mcstar> -t
06:21:03 <mcstar> b__: and i get the proper answer with 0 as the lower bound
06:21:39 <mcstar> even with both unsafeRead/unsafeWrite
06:22:43 <b__> with unboxed or boxed?
06:23:14 <mcstar> boxed
06:23:16 <mcstar> io
06:23:47 <b__> hm unboxed works too
06:24:37 <mcstar> b__: where are the unsafe functions documented? i cant find them
06:24:47 <b__> they are in Data.Array.Base
06:24:55 <b__> but documented? nowhere afaik
06:25:03 <mcstar> i dont find Base's documentation anywhere
06:25:28 <mcstar> Vector's are documented
06:26:02 <b__> thanks for helping me with this
06:26:03 <mcstar> maybe with unsafeRead/Write you can use arbitrary starting indices
06:26:11 <mcstar> thats why im asking about the documentation
06:26:23 <b__> you have to give bounds
06:26:30 <b__> even with unsafeNewArray_
06:27:32 <b__> fwiw: performance is ~6% better now
06:28:34 <mcstar> well, thats not a great improvement
06:28:41 <mcstar> and you are turning that array into a list
06:30:29 <mcstar> also, you might want a real integer square root
06:31:43 <mcstar> there are some very knowledgeable ppl here, how could shed some light on this indexing problem
06:31:58 <mcstar> i hope they will see this, im interested in their answers
06:33:09 <b__> mcstar, yeah, I am interested in it as well
06:33:22 <mcstar> b__: also, you could write a modifyArray function, if it doesnt exist already :)
06:33:41 <b__> yeah
06:34:00 <merijn> thoughtpolice: Ping?
06:34:13 <mcstar> and you are generating the indices from list comprehensions, i think you can do better than that too
06:34:30 <mcstar> just write a recursive function that does that, if you really care about performance
06:34:48 <mcstar> (but i dont think you should)
06:35:14 <b__> I could probably use a wheel
06:35:49 <b__> but it's not a good representation of the actual algorithm yet
06:55:33 <u_quark> @let baazz = 42
06:55:34 <lambdabot>  Defined.
06:55:39 <u_quark> @let baazz = 42
06:55:39 <lambdabot>  <local>:12:0:
06:55:40 <lambdabot>      Multiple declarations of `L.baazz'
06:55:40 <lambdabot>      Declared at: <loc...
06:56:14 <u_quark> is there a way to redefine in lambdabot ?
06:58:26 <maukd> @undefine
07:00:19 <u_quark> cool :)
07:05:52 <mcstar> maukd: did you read that safe/unsafe array indexing problem from a little while ago?
07:07:26 <maukd> no
07:08:10 <mcstar> maukd: im just asking, cause you might have a explanation..
07:09:11 <mcstar> the algorithm works, with safe indexing an array, minimum index is 5, but stops working with and/or unsafeRead/Write, but does work, if minimum array index is 0
07:09:47 <mcstar> there is no out of bounds error when using safe indexing
07:19:20 <chatsiri> Building haskell for i386 cannot completable with configure script. Flag -no-user present output incorrect.
07:25:11 <maukd> building what?
07:28:14 <scp> If I have a big data structure declared with record syntax, is there an easy way to change just one field of it?
07:28:41 <maukd> record update syntax?
07:28:51 <scp> that sounds like exactly what I need =]
07:28:56 <sipa> oldRecord { someField = newValue }
07:29:12 <scp> cool, thanks. I can google for the specifics
07:29:12 <typoclass> scp: you can do "rec = ..." and later "rec { field = newvalue, otherfield = othernewvalue". this will give you a "copy" of the record with those 2 values changed
07:29:44 <scp> Alright, thanks all. I was unpacking and repacking, and it was getting tedious x_X
07:42:24 <dada-cetacean> could anyone take a look at this? (question is included as a comment in the code) http://hpaste.org/76572
07:43:51 <maukd> "doesn't work" is not a problem description
07:46:46 <typoclass> dada-cetacean: hello, what do you intend the function to output?
07:47:16 <dada-cetacean> is there a way to include sample ghci outputs in hpaste?
07:47:48 <dmwit> You can just put any text you want there.
07:47:50 <typoclass> dada-cetacean: don't think so :) just put them in there
07:49:29 <dmwit> scp: You might also like lenses.
07:50:24 <typoclass> dmwit: in fairness, that's applicable to 92% of all questions anyone asks in here ;)
07:52:02 <hiptobecubic> doesn't work is definitely a problem description
07:52:46 <dada-cetacean> okay, it's been annotated http://hpaste.org/76572
07:53:03 <dada-cetacean> it's supposed to split up a list into a list of sublists by some predicate
07:53:15 <dmwit> dada-cetacean: Your second function is splitting in the reverse order compared to the first function.
07:53:35 <dmwit> Also, I agree with hiptobecubic here, since you gave both a specification and an incorrect implementation.
07:54:29 <dmwit> Anyway, the first function splits by highest index first, and the second by lowest index first.
07:55:44 <dmwit> (Only reason I didn't answer sooner is my browser was still starting... =/)
07:56:42 <dada-cetacean> I reverse the list of indices in the second version because splitWith1 is supposed to recursively split the first sublist of its second argument, which is why it has to apply the splitAts from the greatest index downwards
07:57:14 <dada-cetacean> (something which foldr expresses a lot more elegantly)
07:58:00 <Kyraimion> Why does cereals Data.Serialize.Get not export the constructor of Get?
07:58:57 <merijn> scp: Also, if you have lots of record syntax data structures (potentially nested) you might want to look into lenses
07:59:35 <dmwit> merijn: 9 minutes late
07:59:42 <merijn> dmwit: Meh
08:00:00 <merijn> dmwit: I have joins/leaves turned off for #haskell because it tended to get to spammy at time :p
08:00:24 <typoclass> dada-cetacean: are you aware of the function break? (just checking)
08:00:37 <typoclass> > break (== 'a') "several lolcats"
08:00:39 <lambdabot>   ("sever","al lolcats")
08:01:21 <dada-cetacean> oh, hah
08:01:29 <dmwit> merijn: It has nothing to do with joins or leaves.
08:01:37 <dmwit> merijn: Look at what I said nine minutes ago. =)
08:01:49 <dada-cetacean> no, sorry, I just hoogled elemIndices and found findIndices from there
08:02:36 <dmwit> dada-cetacean: Oh, cool, this bug is even more awesome than I thought.
08:02:40 <merijn> dmwit: aww :(
08:02:54 <typoclass> dada-cetacean: (i thought it's a little detour to find the indices first, and then work with them. i think you could equally well apply the predicate to a list element, and not care about indices)
08:05:23 <typoclass> dada-cetacean: in general, you can use #haskell as a kind of fuzzy intelligent hoogle ;-) if you're very sure of what you need, you could use hoogle directly
08:07:01 <dmwit> dada-cetacean: Well, I can't reproduce your error.
08:07:26 <dmwit> For me, splitWith1 ((==0).(`mod`4)) [1..20] doesn't even typecheck.
08:07:45 <dmwit> err
08:07:49 <dmwit> <- idiot
08:07:50 <typoclass> dmwit: splitWith, not splitWith1
08:09:19 <dmwit> After typing the right thing, I still can't reproduce your error.
08:09:26 <dmwit> It gives me just what I would have expected.
08:09:45 <dmwit> *Main> splitWith ((==0).(`mod`4)) [1..20]
08:09:45 <dmwit> [[1,2,3],[4,5,6,7],[8,9,10,11],[12,13,14,15],[16,17,18,19],[20]]
08:10:24 <typoclass> dmwit: for the first or second implementation of splitWith?
08:11:02 <dmwit> A massaged version of the second one.
08:11:09 <dmwit> Let's restore the exact definition and see what happens here...
08:11:29 <dmwit> Still seems to work.
08:12:19 <dada-cetacean> how odd
08:13:08 <dmwit> I observe that this is clearly not a direct copy-and-paste from your file; can you go ahead and do that?
08:13:26 <dmwit> Like, the whole file from start to finish.
08:14:42 <typoclass> dada-cetacean: same here, i get the result that dmwit pasted
08:15:52 <dada-cetacean> now I can't even get the foldr version to load into ghci
08:16:00 <dada-cetacean> I'm going to look at everything again slowly
08:16:09 <dmwit> Good idea. =)
08:17:49 <typoclass> dada-cetacean: i find this kind of comparison thing easier to figure out if every function has its unique name. try renaming the old one it to splitWit or splitWith' or similar
08:23:38 <beaky> how does pattern matching work/
08:23:48 <sipa> magic
08:24:26 <typoclass> beaky: for a basic example, check out section 1 here: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
08:25:10 <CptCaptain> beaky: also here http://learnyouahaskell.com/syntax-in-functions#pattern-matching
08:25:18 <typoclass> note the function has one argument, and there's 3 equations of the form "fib ... = ..." that together define the function
08:25:21 <dada-cetacean> okay, I figured it out. As it turns out, I had the second implementation right for quite a while (after I fixed it from an earlier version), but I just got emacs and forgot that control+s doesn't save, so I came up with the foldr version afterwards and then saved over it. Silly me.
08:25:41 <sam___> hello, what will "map myMap myList" do in haskell?
08:26:14 <dada-cetacean> (although foldr is much nicer, and I had the arguments for foldr swapped in the code on hpaste)
08:26:19 <mcstar> > map myMap myList
08:26:20 <lambdabot>   Not in scope: `myMap'Not in scope: `myList'
08:26:40 <Botje> sam___: it will apply myMap to every element of myList
08:26:50 <Botje> sam___: that's about all we can say without more information about either.
08:26:56 <typoclass> > toUpper 't'
08:26:58 <lambdabot>   'T'
08:27:07 <typoclass> > map toUpper "lolcats"
08:27:08 <lambdabot>   "LOLCATS"
08:27:18 <sam___> oh, great :)
08:27:25 <sam___> that was all i wanted to know :)
08:28:02 <typoclass> sam___: ^^ toUpper is a function that converts one character to upper-case. "lolcats" is a list of characters, and map means the toUpper function is applied to each character in the list, producing a result list of the same length
08:28:06 <typoclass> sam___: you're welcome :)
08:28:28 <sam___> great!
08:28:37 <beaky> can I pattern match my own types?
08:28:53 <typoclass> beaky: yes, that is no problem
08:29:19 <beaky> even deconstruct them the way the (x:xs) pattern does for lists?
08:29:38 <benjamin`> i have a question about monads/applicatives/functors
08:31:08 <benjamin`> is anybody around who can answer such a question?
08:31:35 <typoclass> benjamin`: just ask your question :)
08:31:40 <benjamin`> haha cool
08:31:43 <preyalone> How can I specify a language literal in hsparql? The docs don't provide an example for the syntax. http://hackage.haskell.org/package/hsparql
08:32:09 <benjamin`> if every monad is an applicative, and every applicative is a functor, why does haskell force you to define them all separately
08:32:37 <benjamin`> furthermore, if every applicative is a functor, why do you have to declare something as a functor _before_ you can make it an instance of applicative
08:32:51 <preyalone> The raw SPARQL would be rdfs:label "D (programming language)"@en               How could I generate this in hsparql?
08:33:05 <benjamin`> i know it's sort of nitpicky but it bugs me a little bit
08:33:30 <hiptobecubic> if every app is a functor, and the type of applicative says so, then you can't declare something as an app without it being a functor or it wouldn't match the type
08:33:42 <osfameron> benjamin`: yes, though I don't think you can make a symbol constructor like (:) for lists
08:34:15 <dada-cetacean> beaky: yes, you can use wildcards for pattern-matching with your own data constructors
08:34:42 <benjamin`> hiptobecubic: sorry, i get that; my second question was stated wrong
08:35:23 <benjamin`> hiptobecubic: i meant to say, why does the type of applicative enforce that when there's an obvious way in which all applicatives are functors
08:36:59 <benjamin`> it's also inconsistent
08:37:20 <benjamin`> because the type of applicative enforces that you start with a functor
08:37:44 <benjamin`> but the type of monad doesn't make you start with an applicative
08:37:46 <typoclass> benjamin`: by "obvious way in which all applicatives are functors", you mean this, right? fmap f x = pure f <*> x
08:37:46 <dada-cetacean> is there a way to get a text file transcript of my sessions with ghci?
08:38:17 <benjamin`> typoclass: exactly
08:38:46 <typoclass> dada-cetacean: you could have a look at ~/.ghc/ghci_history and take some part of that
08:39:03 <preyalone> Anyone here familiar with hsparql? I'm having trouble with the syntax.
08:39:43 <dolio> The Functor f => Applicative f doesn't have anything to do with the order you write the instances in your code.
08:39:48 <nomeata> gwern: Hi. unlambda does not build with GHC-7.4.1. Is that package still maintained?
08:39:58 <dolio> You can write 'instance Functor F where fmap = liftA' if you want.
08:40:05 <benjamin`> dolio: yeah i'm not talking about the order
08:41:03 <dolio> And the 'class Functor f => Applicative f' expresses that every Applicative is a Functor, necessarily.
08:41:13 <dolio> It should be there for Monad, but it isn't.
08:41:21 <dolio> Due to historical accident.
08:41:26 <benjamin`> dolio: ok that basically answers my question :)
08:42:42 <dada-cetacean> typoclass: I'm running ghci out of ~/Haskell Platform/2012.2.0.0/bin, and a search of my haskell directory comes up empty; is there some way to find out where ghci saves its history?
08:42:42 <benjamin`> i have a more general question then
08:43:01 <dolio> It'd be nice if you could define Monad and get Functor and such defined automatically, but there's no facility for that in the language.
08:43:11 <benjamin`> yeah that was my question :)
08:43:13 <dolio> There are proposals, but nothing implemented.
08:43:36 <benjamin`> i did it myself but i had to enable FlexibleInstances and UndecidableInstances
08:43:51 <typoclass> dada-cetacean: do you have a directory .ghc inside your home directory?
08:43:51 <dolio> I assume you wrote 'instance Monad f => Functor f'?
08:43:57 <dolio> Because that's not what you want.
08:43:58 <benjamin`> yep
08:44:02 <dolio> That overlaps with every other instance.
08:44:07 <typoclass> benjamin`: hm, i think it'd be possible to add those 2 lines to class Applicative: "fmap :: ..." and "fmap f x = pure f <*> x". the disadvantage is that if you have some function that takes a Functor and does something useful, and you pass in an Applicative, that won't work. the function wouldn't know that Functor's fmap and Applicative's fmap are equivalent
08:44:15 <benjamin`> dolio: i'm not actually using it in real code
08:44:26 <benjamin`> dolio: it was just to see if i could get it to work
08:44:50 <dolio> Sure.
08:44:54 <dolio> But there's a reason that that isn't done.
08:44:57 <typoclass> benjamin`: so in that case, it won't be long until somebody comes in here and asks "well, all Applicatives are Functors, right? so why can't i pass my nice Applicative into this function that expects a Functor" :)
08:45:13 <benjamin`> typoclass: yeah, that makes sense
08:45:24 <benjamin`> dolio: what's the reason?
08:45:33 <dolio> It overlaps with every other instance. :)
08:45:38 <benjamin`> dolio: hahaha i know
08:46:10 <benjamin`> dolio: but in theory, one could go and look at every case where something is instanced as both a functor AND an applicative
08:46:16 <benjamin`> dolio: and just delete hte functor instance
08:46:27 <benjamin`> dolio: not that anybody would care enough to do that
08:46:31 <dolio> No, it overlaps with every instance.
08:46:38 <dolio> Even ones that aren't Applicatives or Monads.
08:46:53 <dolio> If you define that instance, it's the only instance you get to define.
08:47:00 <benjamin`> dolio: oh bizarre
08:47:32 <benjamin`> dolio: that's a good reason not to do it then, haha
08:47:43 <dolio> Unless you enable OverlappingInstances, which I don't recommend.
08:48:25 <benjamin`> dolio: thanks for the explanation
08:49:03 <dolio> benjamin`: The important thing to know is that 'instance C a => D a' isn't conditionally defining an instance of D a when C a is defined.
08:49:24 <beaky> does Haskell have lisp-style macros?
08:49:26 <dolio> benjamin`: It's defining an instance D a, and when that instance is used, it incurs a C a requirement.
08:49:34 <beaky> or it doesn't need macros?
08:49:47 <benjamin`> dolio: ohhhh
08:49:49 <dolio> The dispatch doesn't look at the stuff before the =>.
08:49:49 <merijn> beaky: For meta programming we have Template Haskell
08:50:17 <otters> who's used plugins (the package)?
08:50:46 <benjamin`> dolio: i guess i was sort of reading the => as "implies"
08:51:30 <gwern> nomeata: no one really maintains unlambda
08:51:43 <benjamin`> dolio: but now i see that's not at all what it is; in some ways it is sort of a reverse implication in that it would require a functor to be an applicative before you could use fmap
08:51:44 <dolio> benjamin`: It does mean that, effectively. But the dispatch happens as I said.
08:51:55 <benjamin`> dolio: ok
08:52:11 <dolio> So if you had both 'instance B a => D a' and 'instance C a => D a' it's totally ambiguous.
08:52:30 <benjamin`> dolio: yes
08:53:14 <benjamin`> dolio: ok thanks i now definitely understand more deeply what's happening
08:53:31 <nomeata> Clint: according to gwern (^) unlambda is unmaintained. Do we really want to have it in Debian then?
08:55:03 <gwern> nomeata: if it makes you feel better, it compiles if you just remove the base constraints
08:56:09 <nomeata> gwern: it would make me feel even better if someone would feel responsible for uploading such a version to hackage
08:56:23 <gwern> ;_; fine! g'wash!
09:01:36 <hpaste> sheriff_ pasted “Doesn't work” at http://hpaste.org/76575
09:01:49 <sheriff_> I'm getting a Kind mis-match
09:01:53 <sheriff_> for the above
09:01:54 <nomeata> gwern: thx
09:02:00 <sheriff_> The first argument of `Functor' should have kind `* -> *',
09:02:06 <sheriff_> but `Foo' has kind `*'
09:02:10 <sheriff_> Can anyone explain?
09:02:26 <otters> well, yeah
09:02:32 <otters> Functor has to have something to map over
09:02:53 <sheriff_> otters: And mapping over the recursive data type doesn't cut it?
09:03:19 <otters> No, because Foo has kind *
09:03:29 <sheriff_> What does that mean?
09:03:37 <otters> It means it doesn't take a type argument
09:03:39 <otters> it's not a type constructor
09:03:47 <otters> you'd have to have Foo a where a is whatever
09:04:01 <typoclass> sheriff_: yeah your data type Foo is the container. a Functor is something that is concerned with 2 types, the container type and the type of the stuff inside
09:04:37 <sheriff_> hrm
09:05:27 <sheriff_> So the thing inside here is values created using FString
09:07:39 <Cale> If you're going to say that, why not make it 3 types? :)
09:07:42 <Cale> :t fmap
09:07:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:08:21 <Cale> There's the type of container, the type of stuff in the first container, and then the type of stuff in the resulting container
09:08:53 <sheriff_> What do you mean by "make it thre types"?
09:09:22 * hackagebot unlambda 0.1.2 - Unlambda interpreter  http://hackage.haskell.org/package/unlambda-0.1.2 (GwernBranwen)
09:09:23 <mcstar> FPair, FList, FString
09:09:51 <Cale> sheriff_: Well, I kinda just explained... there are three type variables in fmap's type
09:09:55 <sheriff_> Ah, you mean instead of three data constructors belonging to one type, use three different types?
09:10:11 <typoclass> sheriff_: i think the problem is going to be this: fmap has type (a -> b) -> f a -> f b, right. so you give it a function (suppose it's a function FPString -> Int that counts the number of characters), and secondly you give it your Foo container with the string, and you expect it to produce a Foo container which has an Int in it. how does it do that? with your pasted code, that wouldn't be possible
09:10:42 <sheriff_> typoclass: Let me think about that for moment
09:11:22 <sheriff_> typoclass: I think I was expecting the function I pass in to do that
09:11:33 <Cale> sheriff_: Sorry if that was confusing, it was sort of in reply to typoclass' remark that there are two types involved with a functor :)
09:11:54 <sheriff_> Cale: I appreciate any help :-)
09:11:55 <typoclass> sheriff_: yup :) the question is, if you have "someFoo :: Foo" of your type, and i now want to write the code "fmap length someFoo", how would that work
09:12:19 <typoclass> Cale: it's alright, my reply to sheriff was sort of a reply to what you said about making it three types =D
09:12:42 <sheriff_> OK. I think I am going to give up on this. I was only trying to get some extra credit on an assignment, but clearly I haven't thought this through
09:13:12 <Cale> sheriff_: Well, what are you trying to do?
09:13:15 * sheriff_ will read rather than skim the chapter on Functors
09:13:28 <beaky> when to use newtype over data?
09:13:30 <Cale> There's really not a whole lot to the basic idea of functors
09:14:01 <typoclass> sheriff_: "I think I was expecting the function I pass in to do that" <- translated into types, that would be something like "(a -> f b) -> f a -> f b". note how the additional f makes this different from the type of fmap ((a -> b) -> f a -> f b)
09:14:03 <startling> beaky: when there's only one constructor which only has one field
09:14:18 <nomeata> gwern: did you really test it with GHC 7.6.1? I get Language/Unlambda.hs:134:15: Not in scope: `catch'
09:14:19 <b_jonas> beaky: at first, use data for everything. newtype is an advanced embellishment.
09:14:43 <beaky> so ill know when i need newtype
09:14:43 <sheriff_> typoclass: Oh. Hrm...
09:14:48 <Cale> beaky: The semantics of newtype are slightly different in order to allow the compiler to implement values of the newtype at runtime with no additional overhead
09:14:56 * sheriff_ goes off to play with this a bit
09:15:02 <typoclass> sheriff_: i'm not totally sure, but i think you can still write and use that function (a -> f b) -> f a -> f b. it's just you can't call it a Functor and you can't call it fmap :)
09:15:19 <startling> beaky, it's not something you ever *need*; it's just a cheap convenient optimization in some cases
09:15:35 <startling> and also GeneralizedNewtypeDeriving is really handy sometimes
09:15:38 <Cale> beaky: i.e. if you have  newtype MyType = T Integer  the values of this type will be no more expensive to store than values of type Integer
09:15:46 <beaky> http://www.haskellforall.com/2012/10/parsing-chemical-substructures.html
09:15:59 <Cale> beaky: and pattern matching against T does not cost anything extra (it does no "work")
09:16:03 <typoclass> nomeata: i think they removed Control.OldException in 7.6 *grrrr* :(
09:16:23 <Cale> beaky: meaning that it's essentially just a compile-time tag to keep types separate
09:16:36 <nomeata> typoclass: yes, that is the predominant reason for packages not building with ghc 7.6 any more in Debian
09:16:44 <beaky> right
09:16:45 <Cale> beaky: In the case of data, the data constructor is a physical thing which will use memory.
09:17:12 <Cale> and pattern matching against it will cause evaluation to occur, in order to decide if the pattern matches
09:17:23 <Cale> (even in the case of a one-constructor datatype)
09:17:58 <hpaste> sheriff_ pasted “Still doesn't work” at http://hpaste.org/76576
09:18:05 <typoclass> nomeata: it's kind of unfortunate. i can see that it's "more beautiful" to not have old stuff around, but still, somehow haskell should do a better job about backwards compatibility :-/
09:18:10 <Clint> nomeata: well, it's a dependency of lambdabot, isn't it?
09:18:10 <sheriff_> typoclass: OK, so given what you said, I would have thought the above would have worked
09:18:26 <Cale> sheriff_: Foo as you have it there absolutely cannot be a Functor
09:18:39 <Cale> sheriff_: because it's just a single datatype with no type parameter
09:18:43 <sheriff_> Cale: As a property of it not being (Foo a)?
09:18:47 <nomeata> Clint: most likely an optional one, I hope
09:19:01 <startling> sheriff_: correct
09:19:04 <sheriff_> OK
09:19:14 <Cale> sheriff_: yeah, you can't even write Foo a, it's not valid, because you didn't put any parameters to the left of =
09:19:14 <nomeata> Clint: if it is not maintained any more, then lambdabot should not depend on it either, I’d say.
09:19:17 <atriq> Is there something like foo :: (b -> Getter a c) -> Getter a b -> Getter a c?
09:19:18 <Cale> in the data declaration
09:19:35 <sheriff_> Thanks for the help. I'm going to let this sink in while I work on something else
09:19:36 <Clint> nomeata: i think Cale will tell you that lambdabot isn't maintained either
09:19:50 <b_jonas> the point is that mathcing a newtype can't fail because the value can't be undefined at top level, right?
09:19:52 <typoclass> sheriff_: yeah erm ... :) you're doing fmap (++"a"). that's a function String -> String, so that's kind of the easy thing. but what if you wanted to do "fmap length" instead? how would your fmap implementation construct a Foo which contains the Int? that's the issue here
09:19:57 <nomeata> Clint: :-(
09:19:58 <nifr> sheriff_: answering the following question may help. As you see it, what kind of values are "inside" of a Foo value?
09:20:00 <startling> sheriff_, re-writing Maybe and Either can be helpful
09:20:04 <atriq> If you expand the Getters to functions it's the same as ap
09:20:26 <efie> What is the difference between "Stack space overflow" and "Killed"?I read that Stack space overflow refers to a too big stack for thunk evaluation, what does Killed refer to? Where to search for what did go wrong?
09:20:31 <Cale> We need someone to write a new IRC bot
09:20:45 <merijn> Cale: Using conduits! And lenses!
09:20:49 <startling> how friendly is lambdabot's code?
09:20:51 <nifr> sheriff: whoops --- don't mind the "kind" in my question, it's just the normal usage of the word, not the "Haskell kinds"
09:20:58 <Cale> merijn: ugh, conduits
09:21:00 <merijn> And GADTs! And type families!
09:21:07 <startling> data kinds!
09:21:10 <Clint> and simpleirc
09:21:15 <merijn> startling: Word.
09:21:15 <edwardk> nonono, using machines, not conduits. its a bot after all
09:21:29 <Cale> Yeah, machines would be better
09:21:33 <merijn> oh, and FRP, naturally
09:21:45 <startling> what's "machines"?
09:21:47 <edwardk> merijn: great now it can reboot every 10 minutes
09:21:53 <edwardk> @hackage machines
09:21:53 <lambdabot> http://hackage.haskell.org/package/machines
09:21:56 <typoclass> sheriff_: (it's not even just "what if you wanted to do fmap length", it's "what if you could release your library and then someone else wanted to do that". by offering a Functor instance, you're making that promise that people will be allowed to do "fmap length", so you've got to be prepared for that)
09:22:21 <edwardk> machines are like conduits/pipes that can have multiple inputs and be composed more readily
09:22:46 <startling> sheriff_, even things like ByteString and Text cannot be Functors because they're not parametric
09:22:56 <edwardk> they can reflect non-deterministic input, or deterministic input from multiple sources rather cleanly
09:22:59 <startling> sheriff_: but these things usually provide a map function regardless
09:23:03 <Cale> Oh, you mean the general Machine type?
09:23:12 <Cale> Nah, just use Mealy
09:23:18 <edwardk> Cale: =P
09:23:21 <startling> edwardk: neat. would you recommend them over conduits/pipes?
09:23:23 <Cale> The entire IRC bot can just be a Mealy machine
09:23:30 <startling> or are they different concepts?
09:23:35 <edwardk> the problem with that is you might want it to say multiple lines =)
09:23:36 * typoclass would be happier if Mealy was called Nommy
09:23:54 <edwardk> but yes, you could just use Mealy and compile it to a machine
09:24:04 * startling once began writing parsing library called "eaten"
09:24:32 <b_jonas> efie: you get Killed if the kernel killed the process without giving it a chance to handle the error. this can happen for multiple reasons, the process allocating too much memory being one of them.
09:24:38 <edwardk> startling: be careful, you might give yourself indigestive functors
09:25:31 <startling> edwardk, I did come down with class-maker's croup
09:25:36 <gwern> nomeata: I never said I tested it on 7.6.1
09:25:39 <merijn> edwardk: Can machines have multiple outputs too? Or is that already an option with conduits too?
09:25:40 <startling> that was really the last big python thing I wrote
09:26:29 <edwardk> machines have a single output. you can of course feed multiple machines from the input graph. basically you get a big set of tributaries that lead to the final assembly line output
09:26:46 <thoughtpolice> merijn: pong?
09:27:34 <beaky> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
09:29:22 * hackagebot direct-sqlite 2.2.1 - Low-level binding to SQLite3. Includes UTF8 and BLOB support.  http://hackage.haskell.org/package/direct-sqlite-2.2.1 (IreneKnapp)
09:29:41 <merijn> thoughtpolice: \o/
09:29:45 <efie> b_jonas: I'm wondering why I sometimes got a stack space overflow error then ... do you know other reasons why this could happen or where to see the exact reason why the process got killed?
09:29:54 <edwardk> currently conduits and pipes have a better story for cleaning up resources and dealing with pushing back unused data back up into the pipe, so its not a panacea, but for crunching numbers like we do it works great
09:30:26 <sheriff_> data Moo = Moo Num
09:30:29 <sheriff_> What's wrong with that?
09:30:33 <merijn> thoughtpolice: Do you use OSX by any chance? I was looking into your NaCl bindings, but I ran into some compiler warnings when building NaCl itself from scratch, was wondering if your bindings solve those
09:30:51 <b_jonas> efie: you can try to look at kernel log messages, they may contain an explanation sometimes
09:31:12 <merijn> thoughtpolice: Additionally I was a bit curious whether your changes were just in the build process of NaCl or also in the actual crypto code
09:31:31 <Cale> sheriff_: Is Num a type?
09:31:39 <sheriff_> I guess not
09:31:43 <sheriff_> I'd just assumed it was
09:31:48 <Cale> sheriff_: Right, it's a type class.
09:31:49 <sheriff_> But I also guess I don't see how that would work
09:31:56 <sheriff_> aight, thanks
09:31:58 <efie> b_jonas: thanks for the help
09:32:06 <Cale> Type classes are things which may be true or false of any given type
09:32:17 <Cale> and when they're true, they say that some bunch of functionality is present
09:32:25 <sheriff_> I understand
09:32:26 <b_jonas> .oO(they can be false?)
09:32:30 <nifr> sheriff_: Num is a property some types may have. Int, Double, etc have it. Bool, for example, does not
09:32:34 <sheriff_> I just hadn't thought it throguh
09:32:55 <Cale> b_jonas: Perhaps it would be more correct to say they can be true or _|_ ;)
09:33:21 <nifr> inhabited or not :)
09:33:31 <alexander`> I have a list that looks like this: [(0,["day 1"]),(1,["Intro 1"]),(2,["Bill 1"]),(1,["Intro 2"]),(2,["Bill 2"])]
09:33:55 <merijn> thoughtpolice: I have to run now for dinner though, either just PM answers or I'll bug you later this evening
09:34:22 * hackagebot bindings-sane 0.0.1 - FFI bindings to libsane  http://hackage.haskell.org/package/bindings-sane-0.0.1 (ClintAdams)
09:35:00 <alexander`> representing different headings in a document
09:35:16 <alexander`> the first item of each tuple is the 'level' of the heading.
09:35:25 <typoclass> sheriff_: you could look at the implementation of Maybe and its Functor ... http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/src/Data-Maybe.html#line-69
09:36:19 <alexander`> how can I make a list of the most nested items, with the data from the headings 'above' it?, like this: [["day 1","Intro 1","Bill 1"],["day 1","Intro 2","Bill 2"]]
09:36:25 <b_jonas> Cale: that sounds better, yes
09:37:24 <b_jonas> alexander`: try to use (Array.//) maybe
09:39:39 <thoughtpolice> merijn: i did test on OS X, was this on mountain lion? i haven't tested it recently, so compiler changes could definitely cause that
09:40:02 <thoughtpolice> RE: changes, i pretty much made no changes, other than eliminating lots of code and slightly tweaking the build to not build the library twice
09:40:11 <typoclass> alexander`: so for (1, "Intro 2"), you want the (0,"day 1") repeated because 0 < 1, right?
09:40:14 <thoughtpolice> all together i shaved the build time down from about 10m -> 2m
09:40:24 <thoughtpolice> but i didn't make any changes to the actual code otherwise, no
09:41:18 <alexander`> typoclass: yes
09:42:29 <maukd> > groupBy (comparing head) [["day 1","Intro 1","Bill 1"],["day 1","Intro 2","Bill 2"]]
09:42:31 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:42:31 <lambdabot>         against inferred type ...
09:42:49 <maukd> > groupBy ((==) `on` head) [["day 1","Intro 1","Bill 1"],["day 1","Intro 2","Bill 2"]]
09:42:50 <lambdabot>   [[["day 1","Intro 1","Bill 1"],["day 1","Intro 2","Bill 2"]]]
09:43:07 <typoclass> > groupBy ((<) `on` fst) [(1,""), (2,""), (1,"")] -- alexander` i think you could use this as a first step ... it cuts the list up
09:43:08 <lambdabot>   [[(1,""),(2,"")],[(1,"")]]
09:43:29 <mcstar> you have to sort it first
09:44:03 <typoclass> mcstar: as far as i understood him, he has a sorted list
09:44:09 <beaky> is it alright ot import Data.List unqualified?
09:44:23 <typoclass> beaky: sure
09:44:41 <mcstar> typoclass: i thought you example wanted to demonstrate grouping by the first item of the sublists
09:45:30 <beaky> what Base modules should be imported qualified?
09:45:53 <typoclass> mcstar: no, that's not what alexander asked for, and it'd have to be (==) then :)
09:46:03 <atriq> beaky, generally, I'd hid conflicts rather than qualifying in base
09:46:22 <atriq> import Control.Monad hiding (mapM_, sequence_), import Data.Foldable
09:46:56 <cieplak> There is a problem on stack overflow that I wondering how to solve in Haskell.  This is the link: http://stackoverflow.com/questions/12748246/sorting-numbers-in-ram
09:47:15 <cieplak> Basically, I don't know how to reason about memory usage in haskell
09:48:18 <cieplak> It seems like a problem that lends itself very well to object oriented design patterns, but not so well to functional ones
09:49:10 <EvanR> sorting numbers 'in ram' ?
09:49:38 <cieplak> i think the problem is to basically sort a million numbers without using more than 1mb of ram
09:49:42 <EvanR> cieplak: its true problems specifically pertaining to the computer hardware arent really very functional
09:50:34 <EvanR> its easier when you only care about a more abstract problem that you expect to be able to solve on any 'sufficiently ideal' computer
09:51:22 <EvanR> cieplak: that being said, you can use unboxed mutable arrays in haskell, for what its worth
09:51:33 <EvanR> swap the numbers in place
09:52:01 <EvanR> you will have more control over the situation than i daresay c++
09:52:28 <cieplak> EvanR: thanks!
09:52:33 <chris___> hello
09:52:40 <beaky> the right abstraction ftw
09:52:41 <chris___> hello user
09:52:45 <cieplak> do you think you could also use FFI
09:52:59 <chris___> sorry I am new to Haskell
09:53:07 <cieplak> and limit memory usage by calling c functions
09:53:09 <chris___> and i am trying out Haskell on  browser
09:53:41 <EvanR> you could write a c program to do it, then call it from haskell with exec ;
09:53:42 <EvanR> ;)
09:53:45 <cieplak> haha
09:54:09 <cieplak> chris___: have you read Learn you a Haskell?
09:54:12 <cieplak> i love that book
09:54:32 <chris___> okay.. I will take a look on that
09:54:37 <EvanR> tryhaskell.org
09:54:51 <cieplak> http://learnyouahaskell.com/
09:54:53 <chris___> do you thinkg which one is good python or haskell
09:54:58 <JL_> anyone know a lib method to convert [True,True,False,True] to "1101"
09:55:05 <EvanR> haskell
09:55:05 <Cale> cieplak: Getting GHC-compiled code to run in 1M of memory is going to be tricky.
09:55:32 <fmap> > map (\x -> if x then '1' else '0') [True,True,False,True]
09:55:34 <lambdabot>   "1101"
09:56:11 <JL_> holyshit
09:56:14 <JL_> i love you
09:56:16 <EvanR> i wish there was a function defined as \a b x -> if x then a else b
09:56:23 <EvanR> f '1' '0'
09:56:26 <KirinDave> Ugh, colloquy
09:56:28 <hpc> EvanR: people tend to call it (??)
09:56:37 <EvanR> cool
09:56:41 <chris___> i see haskell and python does have similarities
09:56:50 <EvanR> cough
09:56:54 <KirinDave> Ugh. I wish I could auto-derive foldable for simple functors.
09:57:00 <Cale> cieplak: I think you'd be better off writing a Haskell program to generate code for whatever machine this is.
09:57:15 <KirinDave> chris___: They really are only similar in that they both instruct computers.
09:57:30 <KirinDave> chris___: There are _very_ big differences in those languages, going back decades now.
09:57:37 <cieplak> Cale: that seems like a very interesting prospect
09:57:42 <KirinDave> Like I think we're at the plural of decades for the history of both those languages?
09:57:57 <fmap> KirinDave: doesn't -XDeriveFoldable do that?
09:58:03 <chris___> whats those
09:58:06 <typoclass> chris___: i think python will get you to some level fairly quickly, but then you stay there. for haskell the climb is longer, but it'll get you to a way higher, better place. if that makes sense :)
09:58:06 <Cale> cieplak: Haskell can make a really nice assembler.
09:58:06 <alexander`> typoclass: I want the first item (0, "day 1") to be added to all the items with a higher fst value
09:58:10 <KirinDave> fmap: Does it?
09:58:24 <fmap> no idea, what else it's for?
09:58:28 <KirinDave> typoclass: I actually think Python is only a shorter walk if you learned OO early on.
09:58:30 <maukd> I could make the argument that Haskell/Perl have at least as much in common as Haskell/Python
09:58:31 <b_jonas> and haskell is pure functional. that's one of the more important differences.
09:58:33 <KirinDave> fmap: I didn't know it existed.
09:58:37 <KirinDave> But if so that's awesome.
09:58:58 <EvanR> python and haskell are not similar
09:59:02 <alexander`> maybe this is a better explanation: add the snd of each item to every other item with a higher fst
09:59:16 <maukd> for Python I'd list whitespace and list comprehensions, for Perl I'd list lexical scoping, lambda functions, and context
09:59:55 <beaky> what is your favorite higher-order function?
10:00:04 <EvanR> fmap!
10:00:10 <hpc> i would say perl signatures are what make it look most haskell-like
10:00:12 <fmap> thanks
10:00:12 <maukd> fix
10:00:18 <beaky> what does fix do?
10:00:20 <KirinDave> (.).(.)
10:00:22 <beaky> :t fix
10:00:24 <lambdabot> forall a. (a -> a) -> a
10:00:27 <beaky> ?
10:00:27 <Cale> beaky: recursion
10:00:34 <hpc> > fix (1:)
10:00:34 <beaky> ah finds fixed points
10:00:34 <maukd> hpc: signatures?
10:00:35 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:00:39 <parcs`> maukd: what's context?
10:00:41 <hpc> er, prototypes
10:00:45 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
10:00:46 <EvanR> :t (1:)
10:00:47 <lambdabot>   3628800
10:00:47 <lambdabot> forall t. (Num t) => [t] -> [t]
10:00:50 <maukd> hpc: hah
10:00:57 <maukd> parcs`: in Haskell or in Perl? :-)
10:01:08 <parcs`> perl
10:01:11 <beaky> fix (print 1) 10
10:01:17 <maukd> parcs`: one of void, scalar, or list
10:01:18 <Cale> > fix ((0:) . scanl (+) 1)
10:01:20 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
10:01:23 <beaky> > fix (print 1) 10
10:01:24 <lambdabot>   Couldn't match expected type `a -> a'
10:01:24 <lambdabot>         against inferred type `GHC.Ty...
10:01:27 <EvanR> > fix sqrt 1024
10:01:28 <beaky> :(
10:01:29 <lambdabot>   *Exception: stack overflow
10:01:33 <maukd> parcs`: what in Haskell would be a type
10:01:49 <beaky> > fix (print n) 10
10:01:50 <lambdabot>   Couldn't match expected type `a -> a'
10:01:50 <lambdabot>         against inferred type `GHC.Ty...
10:02:00 <EvanR> > fix show "foo"
10:02:01 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
10:02:02 <lambdabot>         against inferr...
10:02:04 <Cale> beaky: print 1 is not a function
10:02:10 <typoclass> alexander`: you could try takeWhile ...
10:02:16 <maukd> parcs`: several operations in Haskell pay attention to their surrounding context. e.g. read "asdf" does different things depending on the context it's used in
10:02:18 <Cale> beaky: you need to pass fix a function a -> a
10:02:24 <Cale> for some type a
10:02:24 <cieplak> Cale: I just found this project http://potential-lang.org/
10:02:25 <mcstar> 'fix' is a resonant eigenmode of the #haskell medium
10:02:32 <typoclass> > takeWhile (> 0) [1,2,2,3,0,1,2,3]
10:02:33 <lambdabot>   [1,2,2,3]
10:02:39 <maukd> parcs`: perl has the same concept, e.g. with =~
10:02:41 <cieplak> https://github.com/intoverflow/Potential
10:02:44 <typoclass> > partition (> 0) [1,2,2,3,0,1,2,3]
10:02:46 <lambdabot>   ([1,2,2,3,1,2,3],[0])
10:02:47 <EvanR> > fix (show :: String -> String) "foo"
10:02:48 <maukd> well, m really
10:02:49 <lambdabot>   Couldn't match expected type `[GHC.Types.Char] -> t'
10:02:49 <lambdabot>         against inferr...
10:03:01 <Cale> cieplak: also in this vein: http://hackage.haskell.org/package/atom/
10:03:07 <typoclass> > span (> 0) [1,2,2,3,0,1,2,3]
10:03:09 <lambdabot>   ([1,2,2,3],[0,1,2,3])
10:03:22 <EvanR> Cale: that is really cool
10:03:35 <beaky> map ("foo" ++) ["bar, "baz"]
10:03:43 <beaky> >map ("foo" ++) ["bar, "baz"]
10:03:51 <beaky> > map ("foo" ++) ["bar, "baz"]
10:03:51 <typoclass> alexander`: er partition was wrong :) only takeWhile and span are relevant
10:03:52 <lambdabot>   <no location info>:
10:03:52 <lambdabot>      lexical error in string/character literal at end o...
10:04:09 <typoclass> beaky: lambdabot is also available in private chat windows
10:04:15 <beaky> right sorry
10:04:22 <typoclass> beaky: no worries :)
10:04:39 <cieplak> that's awesome.  I've read through http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours but I've wondered how to get closer to the hardware
10:04:41 <otters> I'm getting an unknown symbol error using System.Plugins.Load
10:04:44 <beaky> I shouldn't use a public lambdabot as my REPL ^^
10:05:10 <Cale> http://dmcc.acm.org/pres/?query=/dmcc///confdata/ICFP2008/2008-09-26_09h56 -- a talk about using atom to control hybrid hydraulic vehicles
10:05:42 <otters> Plugin/Test.o can't locate `_LexieziPlugin_Message_closure'
10:05:52 <otters> But nm tells me that Lexie/Plugin.o contains that symbol
10:06:56 <cieplak> Cale: That's so cool. I just noticed that it was made for Eaton
10:07:17 <cieplak> for automotive control solution
10:07:18 <cieplak> s
10:07:49 <otters> Has anybody used this godforsaken package
10:07:54 <otters> I wish dons was here
10:08:07 <EvanR> cieplak: holy shiz this SO answer is amazing
10:08:12 <Cale> otters: What package?
10:08:17 <otters> plugins
10:08:51 <Cale> otters: Plugins? It relies on being updated for each GHC version, because it doesn't quite use the GHC API thoroughly enough.
10:08:51 <cieplak> EvanR: it is one the front page of HN
10:09:03 <Cale> otters: You'll want to use something like hint instead.
10:09:21 <otters> hint is an interpreter, isn't it?
10:09:27 <c_wraith> hint needs to be updated for each GHC version, too.  the GHC api just flat-out changes
10:09:40 <Cale> Well, yes :)
10:09:44 <otters> I want to provide a bot binary and plugin binaries without end users needing to have the haskell platform installed
10:09:49 <Cale> But hint *does* get updated
10:10:10 <Cale> otters: hint is a wrapper around the GHC API
10:10:22 <otters> Well I'm really out of my depth here
10:10:28 <Cale> and just like GHCi, it can load compiled .o/.hi files when they're present
10:10:28 <c_wraith> plugins is also a wrapper around the ghc api - it just uses a different portion of it.
10:10:36 <otters> Oh it can
10:10:42 <otters> awesome
10:11:05 <typoclass> otters: folks could give you advice if you told us a little more about what you're planning
10:11:06 <hpaste> Clint pasted “haddock unhappiness” at http://hpaste.org/76577
10:11:16 <Clint> anyone know what to do about that? ^
10:11:37 <otters> typoclass: long story short I just want to make an IRC bot that can load plugins that export a value "hooks"
10:12:35 <maukd> heh. it's always IRC bots
10:13:11 <typoclass> otters: do you absolutely need the plugins to be loadable at runtime? it seems to me it'd be not much of a problem if you need to recompile the bot in order to use a new plugin
10:13:17 <hiptobecubic> there aren't many other things a beginner is interested in that warrants a plugin system
10:13:35 <typoclass> (or i might be misunderstanding ...)
10:13:36 <hiptobecubic> typoclass, it's much *cooler* if you do it at runtime
10:13:38 <otters> typoclass: I don't absolutely need it but it seems like it might be easier
10:13:45 <otters> well, it used to seem like that :P
10:14:06 <hiptobecubic> otters, easier for who?
10:14:23 <typoclass> hiptobecubic: seems like a whole can of worms :-/ and xmonad does the same things very reliably without plugins
10:14:32 <otters> now that I think of it
10:14:33 <hiptobecubic> it does, yes
10:14:41 <otters> the only problem I was really concerned with was controlling which plugins are enabled
10:14:58 <typoclass> otters: i think it will in no way be easier for the implementer (you)
10:15:05 <otters> :X
10:15:18 <watermind> using hadock, inside code blocks @ ... @ , after a blank line I lose indentation
10:15:23 <watermind> how do you guys fix that?
10:15:57 <mcstar> "You know..." by Dr. Ralf Lämmel
10:16:37 <watermind> i.e. how can you have a blank line inside a code block and indentation in the next line?
10:17:29 <typoclass> otters: in general, try the simplest thing that could possibly work :) if later the "plugins loadable at runtime" thing turns out to be a such a big problem, you can still improve in that area
10:17:43 <typoclass> (my bet is: it won't turn out to be a large problem)
10:17:58 <otters> it's simpler just to provide plugins and have a config option that specifies which ones I want
10:18:54 <otters> yet another YA acronym
10:19:01 <otters> YAYAA
10:19:03 * typoclass giggles
10:32:07 <dncr> shouldn't (printf "%.2g\n" 1099) print "1.1e3"?  it prints "1099.00" but i thought %g was supposed to work with significant digits while %f works with decimal places.
10:34:23 <Guest26568> hi
10:34:56 <Guest26568> what is the best way to learn haskell?
10:35:26 <mcstar> > printf "%e" 1099.0 :: String
10:35:27 <shachaf> @where faq
10:35:27 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
10:35:28 <lambdabot>   "1.099e3"
10:35:54 <typoclass> Guest26568: welcome :) lyah is a good book available free of charge
10:35:56 <monochrom> the best way to learn haskell is the same as the best way to learn anything
10:35:57 <typoclass> @where lyah
10:35:58 <lambdabot> http://www.learnyouahaskell.com/
10:36:02 <mcstar> > printf "%.10e" 1099.0 :: String
10:36:03 <lambdabot>   "1.0990000000e3"
10:36:11 <typoclass> monochrom: so youtube videos?
10:36:25 <mcstar> no, by doing it, silly
10:37:04 <sm> Guest26568: and Programming in Haskell is a good book available only on paper
10:37:20 <monochrom> not as simple as "only watch videos" or "don't watch videos", of course
10:38:15 <monochrom> but mcstar says something most people overlooked. a lot of doing is involved. not a spectator sport
10:39:20 <typoclass> sure. i coudn't imagine working through lyah without having ghci open right next to it, and messing around constantly. lyah or any other book
10:39:47 <sm> Guest26568: also read http://fpcomplete.com/ten-things-you-should-know-about-haskell-syntax/ and http://pragprog.com/magazines/2012-08/thinking-functionally-with-haskell and their follow-ons
10:39:51 <monochrom> you will have to imagine that. a lot of people actually are that passive
10:39:54 <hpaste> “jim benny” pasted “dwb” at http://hpaste.org/76578
10:41:23 <dncr> I guess I have to reinvent sigfig printing
10:41:37 <Guest26568> I am referring to "learn you a haskell for great good" for learning haskell.I have read first 10 chapters.Next Chapter is Applicative functions.My question is should I keep on reading the book or should spend some days practising what I have learnt from 1st 10 chapters?
10:42:19 <monochrom> a few things claimed in FP Complete articles are false
10:42:23 <mcstar> i think you gonna forgot things if you go through the book wihtout enough hands on experience
10:42:57 <mcstar> forget*
10:43:06 <typoclass> Guest26568: do stuff! :) i don't think reading alone will help you much with anything
10:43:43 <monochrom> nevermind forgetting. you can misunderstand a million things you read, and you won't know it until you use experiments to verify
10:44:02 <monochrom> (in which case I would rather you forget than remember)
10:45:28 <Guest26568> Thank you! I will take that suggestion. Where can I find  problems for practising haskell?
10:46:07 <mcstar> try to write a sudolu solver :)
10:46:21 <mcstar> well, not that, rather a sudoku solver
10:46:51 <mcstar> and it is fun to write games also
10:46:51 <monochrom> design experiments for things you think LYAH tells you. preferrably experiments that try to refute them.
10:47:24 <shachaf> Half of what #haskell tells you is wrong, so don't trust #haskell.
10:47:41 <typoclass> Guest26568: you might be interested in http://www.haskell.org/haskellwiki/99_questions/1_to_10
10:47:50 <Guest26568> I think i need some beginner level questions for practising syntax?
10:48:09 <shachaf> Make up your own questions.
10:48:24 <monochrom> for example if LYAH seems to tell you stuff about Functor, you should write some data types of your own and their Functor instances
10:48:26 <typoclass> Guest26568: also, a lot of people are fond of the "project euler" problems which afaik are mathy kind of problems for you to solve in any language
10:49:03 <shachaf> Don't do projecteuler.
10:49:07 <mcstar> typoclass: yeah, i didnt want to mention it, or rather, say that he shouldnt solve those
10:49:16 <shachaf> You'll learn ~nothing about Haskell and annoy everyone in the process.
10:49:26 <mcstar> (for learning haskell explicitely that is..)
10:50:00 <shachaf> Also, learn how to ask helpful questions on IRC.
10:50:17 <portnov> hi all
10:50:29 <typoclass> shachaf: i dunno ... stuff like "Add all the natural numbers below one thousand" seems like as good as anything for getting to know basic syntax and some list functions from Prelude
10:50:46 <portnov> haskellers.com is down again? :\
10:51:18 <mcstar> the good stuff on PE takes time to come up with, and the language you might use to solve them is largely irrelevant
10:51:21 <parcs`> shachaf: but isn't haskell only good for mathematical things?
10:52:10 <typoclass> shachaf: about the questions thing, i don't think he was very unclear or disruptive or whatever
10:52:33 <monochrom> here is an example. somewhere LYAH says "4==5 will always return False, so its type is Bool". this immediately suggests two experiments. the obvious one is: enter ":type (==)" into ghci, to find its type for real. does it say "blahblah -> Bool"?
10:53:14 <monochrom> the second one is less obvious. it concerns "4", "5" being polymorphic. it is possible to get "4==5" to be True
10:53:52 <wereHamster> I'm using createProcess, and sometimes it works and sometimes it doesn't
10:53:59 <typoclass> Guest26568: oh by the way, this has some lessons: http://tryhaskell.org/
10:54:17 <hiptobecubic> monochrom,how?
10:54:27 <wereHamster> if I use (proc "bash" [ "-c", "X=1;" ++ executable ]) then it does work. But if I use (proc executable []) then it doens't
10:54:34 <startling> > 256 == (0 :: Word8)
10:54:35 <lambdabot>   True
10:54:42 <startling> hiptobecubic: ^
10:54:48 <monochrom> begin by writing your own Num instance
10:54:50 <hiptobecubic> startling, ah ok
10:54:55 <wereHamster> also, (proc "bash" [ "-c", executable ]) does not work, neither does (proc "bash" [ "-c", "exec " ++ executable])
10:54:58 <hiptobecubic> monochrom, .. or that
10:55:02 <hiptobecubic> I guess i considered those cheating
10:55:04 <hiptobecubic> :)
10:55:22 <wereHamster> could this be an issue with threads? (I'm using threads)
10:55:31 <mcstar> wereHamster: try giving the full path to the executable
10:55:36 <monochrom> it's an experiment to confirm or refute a theory. I'm not saying to do this for production code
10:55:37 <wereHamster> it is the full path
10:56:22 <startling> wereHamster, "bash" is the full path?
10:56:30 <wereHamster> startling: no, bash not. executable is
10:56:54 <wereHamster> "bash -c 'X=1; /path/to/exi" worwks
10:57:05 <beaky> http://hackage.haskell.org/packages/archive/base/4.2.0.1/doc/html/src/Data-Ratio.html does Haskell use the C preprocessor?
10:58:57 <geekosaur> beaky, it can (LANGUAGE CPP)
10:59:47 <mcstar> wereHamster: what does 'does not work' exactly mean?
11:00:04 <wereHamster> mcstar: sorry. The process exits with exit code 1 right away
11:00:34 * geekosaur wishes to note that the X=1 there doesn't actually do anything because it's not exported
11:00:44 <wereHamster> yes, strange.
11:00:56 <geekosaur> unless the actual X is something that came from the environment (e.g. PATH)
11:01:26 <wereHamster> no, literally X=1;
11:02:14 <wereHamster> same with "bash -c ':;/path/to/exi'", that works.
11:02:44 <wereHamster> I'm calling createProcess from an IO thread. Could that cause the problem?
11:02:45 <mcstar> wereHamster: what is your executable supposed to do?
11:03:01 <wereHamster> mcstar: generate some output, which I then read back through a pipe
11:03:43 <mcstar> you hold on to its stdout then?
11:04:19 <wereHamster> yes
11:07:01 <geekosaur> exit 1 typically means the program itself threw an error; -1 or 255 would indicate program not found
11:08:01 <mcstar> if  you call the program directly, i dont think your env variables will be set
11:08:05 <mcstar> maybe it depends on them
11:08:13 <mcstar> so, thats why it just exits
11:08:18 <wereHamster> a stranger thing is, depending on whre in the code I call createProgram, it sometimes works and sometimes doens't
11:10:10 <mcstar> @hoogle createProgram
11:10:10 <lambdabot> No results found
11:10:24 <wereHamster> createProcess
11:12:51 <Finde> any chance someone could point me to a script to turn bird-style literate haskell scripts into regular haskell scripts?
11:13:55 <startling> I think ghc can do it?
11:14:32 <startling> ghc -E something.lhs
11:14:48 <maukd> perl -pe 's/> //||/\S/&&s/^/-- //'
11:15:04 <startling> :c
11:15:08 <osfameron> it looks like you just have to call the file .lhs
11:15:10 <maukd> wait, the trailing / is wrong
11:15:56 <startling> oh, or yeah, you can just call the file .lhs and ghc will run/compile it fine
11:16:21 <Finde> oh no I meant like, commenting out the non-code and removing the > from the code lines
11:16:23 <mcstar> i think he wants to read illiterate haskell files instead of literate ones
11:16:28 <Finde> yeah
11:16:43 <startling> Finde, ghc -E, but I don't think that will comment anything
11:16:57 <maukd> I think my code will do it if you remove the last / but I haven't tested anything
11:17:05 <Finde> yeah it seems to work
11:17:09 <Finde> thanks all
11:17:11 <mcstar> it might also delete your files...
11:17:19 <mcstar> you can neve know with perl
11:17:21 <mcstar> r
11:17:21 <Finde> haha
11:17:22 <maukd> yes, you can
11:17:52 <maukd> oh, damn. the first regex is wrong
11:18:05 <Finde> it is? it seemed to output reasonably
11:18:07 <maukd> here's the same line with a bit more whitespace: s/> // || /\S/ && s/^/-- /
11:18:14 <maukd> Finde: should be s/^> //
11:18:43 <maukd> now you have to know a bit of perl to recognize s/// and // as operators and quoting constructs
11:18:55 <wereHamster> so.. I put a 'threadDelay' some place random and it suddenly works.
11:18:59 <maukd> || and && are the usual logic operators
11:19:15 <maukd> but you can see that all it's doing is matching and substituting text
11:19:17 <maukd> no deleting files
11:20:05 <osfameron> maukd: sure, but the visual difference between perl -pe and perl -pie isn't obvious ;-)
11:20:07 <mcstar> maukd: come on, it was a joke
11:20:23 <maukd> mcstar: it was a slur
11:20:43 <maukd> osfameron: -pie would be wrong
11:20:49 <osfameron> mcstar: a perlmonger cannoy permit certain jokes to go uncorrected!
11:21:04 <Finde> the tool I'm using doesn't like ghc -E so the perl script is very welcome, thanks maukd
11:21:05 <mcstar> lesson learned
11:21:05 <osfameron> maukd: pie is always the right answer!
11:21:19 <maukd> I'm tired of this "lol perl is line noise" bullshit
11:21:20 <shachaf> I don't use Perl but I find that sort of joke rather tiresome.
11:21:36 <maukd> because no, it isn't, and reading Perl isn't harder than reading Haskell
11:21:39 <beaky> what is the difference between typeclasses and abstract classes in other languageS?
11:21:47 <maukd> beaky: what do they have in common?
11:22:22 <beaky> they both specify an interface, and they both define a set of types
11:23:46 <osfameron> maukd: yeah, me too, re the jokes.  And yes, you're right, I was thinking of perl -pi -e, youcan't do -pie
11:25:06 <mcstar> ive recently seen a perl one liner, that people used to delete the files of unsuspecting victims
11:25:29 <monochrom> no, I really find reading perl harder than reading haskell. but I haven't seriously investigated why.
11:25:33 <beaky> APL is more obfuscatish than perl imo
11:25:43 <simon> I, too, recently learned that -pie does not work.
11:25:48 <otters> MUMPS is more difficult to read than perl
11:25:55 <monochrom> (but definitely not because I read and wrote less perl, more haskell)
11:25:59 <simon> Perl: the pie is a lie.
11:26:28 <osfameron> COBOLis also fun to read
11:26:41 <osfameron> the fact it has no lexical variables, function parameters or return values is...interesting...
11:27:11 <osfameron> but hey, global variables ar cool! right?
11:27:26 <merijn> Is there any documentation of Hamlet other than the Yesod site?
11:28:21 <monochrom> I think one aspect is the "$x", "$x[0]", "@x" business, i.e., decorators attached to "x" means "the same variable x" sometimes and "it's a different x" sometimes
11:29:33 <osfameron> monochrom: it's largely like the diference between x and xs, except enforced inthe language instead of being a convention
11:30:16 <monochrom> that only explains away $x vs @x
11:30:50 <maukd> well, $x[0] is obviously singular, so it uses $
11:31:04 <osfameron> hence *largely*
11:32:02 <osfameron> it's admittedly not so legible to a newcomer.  it's quite expressive though.  *shrug*
11:32:35 <monochrom> unsafeCoerce is even more expressive
11:32:43 * osfameron thinks sigils are the least of perl''s "warts"
11:33:27 <maukd> monochrom: depends a lot on your definition of "expressive" :-)
11:33:37 <osfameron> well, that's a dangerous feature with a long name that's used as rarely as possible.  perl sigils are used all the time inreal code
11:34:38 * osfameron gets back to writing about business models
11:35:20 <beaky> what would life be like without pattern matching?
11:35:41 <monochrom> lisp and scheme show you what life is like without pattern matching
11:36:14 <hpc> so life is like strange setf macros that look like patterns but aren't?
11:36:33 <osfameron> I bet there are macros to implement it though ;-)
11:37:23 <k0ral> Hello
11:37:51 <k0ral> I'm trying to communicate with a shell through haskell
11:38:11 <k0ral> I call it through createProcess using CreatePipe for stdin and stdout
11:38:37 <monochrom> unsafeCoerce is dangerous, and we seldom use it. I agree. But why don't we use it more? because we have a lot of other choices
11:38:39 <k0ral> but when I call hGetChar on the stdout, it blocks forever
11:38:53 <k0ral> shouldn't I get the prompt ?
11:39:00 <k0ral> well, the first Char of the prompt ?
11:39:20 <mcstar> what prompt?
11:39:25 <k0ral> the shell's prompt
11:39:25 <Ferdirand> no, because the prompt is sent to stderr
11:39:29 <Ferdirand> not stdout
11:39:35 <k0ral> oh, didn't know that
11:39:41 <newsham> shachaf: I'm not concerned about losing messages from peopel who are too lazy to type my name.
11:40:01 <monochrom> sigils are half as dangerous, to me anyway, because they are misleading, to me anyway. perl programmers use them all the time, I agree. But why? because there is no choice (except ditching perl).
11:40:20 <k0ral> mcstar: the shell's prompt
11:40:29 <k0ral> mcstar: I'm trying on /bin/bash right now
11:40:29 <monochrom> I am saying that just because the language forces it on you doesn't mean it's safe
11:41:17 <monochrom> and perhaps s/misleading/error-prone/
11:42:21 <beaky> How does Haskell compare to Scala?
11:42:29 <johnw> they share the letter "a"
11:42:41 <hpc> > compare "haskell" "scala"
11:42:41 <k0ral> Ferdirand: still getting nothing out of stderr
11:42:42 <lambdabot>   LT
11:42:58 <hpc> trecherous robot!
11:43:03 <beaky> lol
11:43:05 <johnw> :t (<=>)
11:43:06 <lambdabot> Not in scope: `<=>'
11:43:09 <geekosaur> <k0ral> I call it through createProcess using CreatePipe for stdin and stdout
11:43:10 <mcstar> k0ral: try setting no buffering
11:43:17 <geekosaur> this is not going to run in interactive mode
11:43:23 <hpc> or line buffering, maybe
11:43:25 <geekosaur> interactive is only with terminals
11:43:30 <geekosaur> so no prompt at all
11:43:43 <geekosaur> you can use "bash -i" and then you'll turn it into a buffering issue
11:44:57 <newsham> ?type compare "to Scala"
11:44:58 <lambdabot> [Char] -> Ordering
11:45:14 <k0ral> geekosaur: I added stderr
11:45:17 <newsham> what did you want to comapre to scala with?
11:45:20 <k0ral> geekosaur: forgot to mention :)
11:45:29 <geekosaur> that's insufficient
11:45:42 <geekosaur> must be "bash -i" to force interactive mode, and set the handles to NoBuffering
11:45:52 <k0ral> allright, let me try
11:46:03 <newsham> when will ghc generate JVM code?
11:46:42 <geekosaur> note that bash itself might still buffer output in that case; the correct way to interact with a shell in that fashion is not pipes but ptys
11:47:12 <geekosaur> @hackage unix-pty-light
11:47:13 <lambdabot> http://hackage.haskell.org/package/unix-pty-light
11:47:22 <newsham> if you want to interact with the sh without a pty, use the "-i" argument ot the shell
11:47:52 <newsham> the shell is too-clever by half and will supress prompts when not on a tty
11:47:55 <hpc> anyone know how to increase the ghci history?
11:48:00 <newsham> alas.. this is not the unix way
11:48:14 <Cale> newsham: GHC will generate JVM code as soon as you write the backend and runtime for that.
11:48:16 <Cale> ;)
11:48:31 <newsham> cale; i was hoping for sooner
11:49:14 <k0ral> geekosaur: it still doesn't work, it complains about broken pipes when I perform a hPutStrLn with "ls"
11:49:23 <k0ral> geekosaur: I'll have a look at ptys
11:49:31 <hiptobecubic> This is the only channel I think I've ever been in where people routinely (incorrectly) type out people's nicks instead of using completion.
11:49:58 <zomg> hiptobecubic: happens on many channels where people aren't familiar enough with irc =)
11:50:33 <k0ral> hmm, not the most maintained library ever :)
11:50:43 <hiptobecubic> zomg, sure i can see why. It's just odd that *this* is one of those channels instead of.. say.. #python
11:51:22 <geekosaur> another thing I should note is that there is no guaranteed way to recognize that you have received a shell prompt and not some other output from the program
11:51:22 <k0ral> oh, there's the unix package actually for ptys
11:51:34 <mcstar> im not sure copletion works from webchat..
11:51:45 <geekosaur> because you're not really supposed to use the shell this way
11:52:08 <beaky> is Data.Sequence standard?
11:52:20 <k0ral> geekosaur: I'm trying to create a terminal emulator
11:52:22 <geekosaur> you *can* use it this way (see "expect" and the variants of it for perl, python, etc.) all of which have the same limitations
11:52:36 <geekosaur> beaky, it's one of the bootlibs
11:52:50 <tntc> mcstar: hiptobecubic: it could also be because python programmers are quite used to tab completion in their IDEs, whereas haskell programmers might not be...
11:53:02 <beaky> what's a bootlib?
11:53:02 <tntc> (having less need for it)
11:53:10 <hpc> tntc: what IDE? ;)
11:53:15 <geekosaur> beaky, if it's listed at http://www.haskell.org/ghc/docs/latest/html/libraries/frames.html then it's one of the libraries that comes with and is required by ghc
11:53:17 <mcstar> emacs ofc
11:53:20 <beaky> also when would I use Data.Sequence over Data.List
11:53:20 <tntc> precisely, hpc. precisely.
11:54:14 <mcstar> thats kind of bs
11:54:14 <maukd> beaky: when you have something that's not a stream
11:54:35 <mcstar> ghci supports tab completion
11:54:38 <maukd> beaky: particularly if you need easy access to the end
11:54:57 <tntc> mcstar: that's a good point. Also, I don't think the command line python interpreter does. IDLE does though.
11:55:02 <beaky> and O(1) append/concat?
11:55:31 <geekosaur> k0ral, in that case you definitely want ptys (and probably full pty support from the unix package).  you might want to study existing terminal emulators first; I suggest a simple one like the original rxvt
11:56:48 <geekosaur> or the source of the Gtk+ VTE widget
11:57:47 <johnw> joeyh: ping
11:58:15 <mcstar> would it be too much spam to link in terminal emulator that someone i knew wrote?
11:58:17 <k0ral> I started reading the rxvt-unicode source, but that's a pain
11:58:44 <merijn> tntc: I don't think I've ever used an IDE when writing python, tbh
11:58:58 <joeyh> johnw: hey
11:59:48 <mcstar> https://github.com/thestinger/termite  it has some nice features
12:00:52 <johnw> hey!
12:02:26 <beaky> > forever $ return ()
12:02:27 <lambdabot>   No instance for (GHC.Show.Show (m b))
12:02:27 <lambdabot>    arising from a use of `M1180202150...
12:03:53 <maukd> > forever "c"
12:03:55 <lambdabot>   *Exception: stack overflow
12:07:12 <johnw> joeyh: did you get my privmsg?
12:07:50 <joeyh> sure
12:10:52 <geekosaur> k0ral, that's why I suggested the original rxvt, it's simpler than rxvt-unicode
12:11:12 <geekosaur> which contains a bunch of other stuff (not just unicode but also terminal factories, transparency, etc.)
12:12:30 <geekosaur> the source to GNU screen or tmux might also be instructive, but again both are much more complex
12:12:32 <k0ral> okay, I'll give it a try, thank you :)
12:17:10 <Ralith> I'm looking for an unordered map-like data structure with O(1) insert, which I want to use for associating keys with multiple (unordered) values each. Can anyone recommend?
12:17:28 <maukd> Map k [v]
12:17:43 <startling> Map k (Set v)
12:18:31 <Ralith> the documentation states that Map has O(log n) insert and adjust.
12:18:52 <Ralith> is it wrong?
12:18:58 <Saizan> no
12:19:06 <Ralith> that doesn't really fit my criteria then :/
12:19:10 <maukd> why not?
12:19:24 <Ralith> because I specified I was looking for something with O(1) insert.
12:19:48 <maukd> yeah, but why?
12:20:37 <Ralith> I'm trying to implement an algorithm such that it has a specific computational complexity, which non-constant-time inserts would make unattainable.
12:21:23 <bitonic> Ralith: I think what they're asking is whether it matters in practice.  or is this some kind of homework?
12:21:29 <byorgey> Lists have O(1) insert.
12:21:38 <Ralith> it's homework, yes.
12:21:54 <osfameron> hash table?
12:21:57 <mcstar> there is hashmap, which is supposed to be close to constant
12:22:01 <dolio> byorgey: They do?
12:22:14 <dolio> I guess it depends what 'insert' means.
12:22:16 <maukd> dolio: (:)
12:22:16 <byorgey> dolio: sure, just (:).  Ralith said "unordered".
12:22:25 <mcstar> i wrote a sudoku solver recently, and switching from hashmap to vector didnt cause a difference
12:22:30 <Ralith> byorgey: problem is I need to insert multiple times to the same key, not necessarily all at once.
12:22:39 <maukd> Ralith: still O(1)
12:22:43 <mcstar> (these were read-only constants..)
12:22:48 <Ralith> maukd: on List? how?
12:22:57 <maukd> Ralith: (:)
12:23:12 <bitonic> Ralith: [(k, v)]
12:23:15 <byorgey> Ralith: my point is that you actually have some other constraints on complexity of some other operations that you have not told us yet.
12:23:18 <bitonic> you can compact it at once in the end
12:23:19 <Ralith> er, right
12:23:23 <johnw> joeyh: how do I stop ~/Desktop/git-annex.app from being created?
12:23:26 <byorgey> because lists fill all the criteria you have said so far.
12:23:37 <johnw> i don't want any files in my Desktop, and I keep having to delete it
12:24:22 <Ralith> byorgey: right, I think I need O(1) lookup too; I'll look into hashmaps
12:26:00 <bitonic> Ralith: what algorithm is it anyway?
12:26:17 <Ralith> the fitting operator
12:26:20 <byorgey> O(1) insert and lookup is not actually possible, even with hashmaps.  You always need to process at least O(log n) bits of information to specify what to look up in a container of n elements.
12:26:42 <bitonic> there are no functional data structures with O(1) lookup and inserts anyway, but hashmaps gets close.  it probably doesn't matter anyway.
12:26:50 <KirinDave> byorgey: You should like graffiti that over college campuses everywehre.
12:27:04 <byorgey> heh
12:27:05 <KirinDave> byorgey: It's kinda frustrating to hear people talk about hashmaps as O(1).
12:27:10 <mcstar> bitonic: i dont think there are. period.
12:27:15 <Ralith> byorgey: mutable arrays have O(1) insert and lookup!
12:27:19 <bitonic> KirinDave: non-functional hashmaps are amortised O(1)
12:27:29 <byorgey> Ralith: no they don't.
12:27:30 <Cale> Ralith: sort of
12:27:38 <Ralith> assuming known size, yes
12:27:38 <Cale> Ralith: If you ignore a log factor
12:27:42 <mcstar> you cant grow a mutable vector with O(1) cost
12:27:49 <mcstar> but you can easily grow a map
12:27:55 * Ralith has known total size in this case so :P
12:27:59 <byorgey> Ralith: it's just that for the sizes of mutable arrays you usually use, you can use a single machine-sized integer as the address, and that gives you VERY good constant factors.
12:28:04 <maukd> Ralith: then every data structure is O(1)
12:28:11 <Ralith> byorgey: okay, fair enough.
12:28:14 <Cale> If you have known maximum size then every operation is O(1)
12:28:17 <joeyh> johnw: by cabal?
12:28:19 <bitonic> they're amortised O(1)
12:28:20 <Ralith> maukd: known, not constant.
12:28:25 <Ralith> nor bounded.
12:28:29 <maukd> Ralith: what
12:28:30 <johnw> joeyh: oh, is that who's doing it?
12:28:37 <joeyh> I've been thinking about turning that off, it was a bit of a stopgap measure
12:28:43 <maukd> Ralith: then array won't be O(1)
12:28:43 <johnw> gotcha
12:29:05 <KirinDave> Pretty soon we're gonna start talking about cool stuff in my domain if this conversation stays on track.
12:29:07 <Ralith> maukd: you misunderstand
12:29:22 <maukd> do I?
12:29:43 <Cale> Ralith: Any function whose range has n elements *must* take at least O(log(n)) time to compute.
12:29:58 <Ralith> the number is a function of input size.
12:30:07 <Ralith> Cale: yes, I ceded that to byorgey.
12:30:19 <maukd> doesn't really make a difference where the number comes from
12:30:23 <johnw> joeyh: did you see that my "sizes" utility now honors git-annex'd files?
12:30:28 <Ralith> I think I've got what I need; thanks
12:31:17 <KirinDave> Hmm
12:31:17 <fommil> is there a function in the stdlib that always returns true? "true :: a -> Bool"
12:31:25 <Cale> We just naturally ignore log factors. It's a little bit silly the way that people ignore some and not others.
12:31:30 <bitonic> fommil: `const True'
12:31:33 <KirinDave> I'm contemplating interview programming exercises for hiring haskellers for my startup.
12:31:42 <KirinDave> It's funny, all the stuff I want to ask people to do is like very pragmatic stuff.
12:31:50 <fommil> bitonic: a function, not the constant
12:31:55 <maukd> fommil: const True
12:31:55 <Cale> fommil: const True
12:32:02 <bitonic> fommil: what?
12:32:03 <KirinDave> I should just say, "Write a restful service to do X."
12:32:05 <Cale> :t const
12:32:07 <lambdabot> forall a b. a -> b -> a
12:32:11 <Cale> :t const True
12:32:13 <lambdabot> forall b. b -> Bool
12:32:18 <KirinDave> Most haskellers have no problem with the theoretical parts. It's the concrete parts I am concerned about.
12:32:22 <mcstar> {-# PRAGMA ? #-}
12:32:23 <fommil> aaah! ok, thanks. I didn't know about 'const' :-)
12:32:35 <osfameron> KirinDave: where is your startup based?
12:32:37 <bitonic> Cale: what's the theorem that gives that result?
12:32:41 <KirinDave> osfameron: SF
12:33:02 <KirinDave> osfameron: It's a financial startup for people in so-called "generation y"
12:33:05 <merijn> KirinDave: Do you hire remote people? ;p
12:33:09 <bitonic> KirinDave: I know a good number of very practical Haskell programmers.  I'd say they're more rare than the theoretical ones.
12:33:18 <bitonic> *they're more common
12:33:21 <beaky> :k
12:33:32 <bitonic> @kind Mu
12:33:33 <lambdabot> (* -> *) -> *
12:33:47 <monochrom> Hi, where can I download a haskell?
12:33:51 <KirinDave> bitonic: Well I am hiring for infrastructure programming, so I want to make sure people know the incidentals. I really don't want to have to teach someone how to use ssh, for example.
12:33:58 <JoeyA> !download
12:34:00 <maukd> monochrom: downloadyouahaskell.com
12:34:01 <JoeyA> bot fail
12:34:11 <JoeyA> !platform
12:34:13 <geekosaur> we haveno bots that speak that language
12:34:21 <geekosaur> @where platform
12:34:21 <lambdabot> http://hackage.haskell.org/platform/
12:34:27 <JoeyA> That
12:34:32 <JoeyA> me fail
12:34:34 <bitonic> KirinDave: what do you mean by "theory" anyway?  type theory?  foundations of FP?
12:34:43 <geekosaur> but you fail twice because that was a joke...
12:35:06 <JoeyA> > fix fail
12:35:09 <lambdabot>   ""
12:35:19 <bitonic> KirinDave: or general CS?
12:35:33 <merijn> KirinDave: I was only half joking with my question whether you were hiring remote people, btw
12:35:33 <KirinDave> bitonic: A lot of haskell programmers do a lot of stuff involving compilers, graphics, math, statistics, etc.
12:35:51 <Cale> bitonic: I'm not sure whether it has a name, but the idea behind it is pretty simple.
12:36:05 <KirinDave> merijn: We're really not. I wish we could, but we're literally at 2 employees, 3 execs. 3 on Nov 1.
12:36:08 <mcstar> rarer seems to be correct
12:36:29 <bitonic> KirinDave: the first two are definitely not only theory, are they?
12:36:38 <bitonic> I mean those things are all going to turn out very useful
12:36:47 <KirinDave> bitonic: No, but they're also not concerned with the details of deployed a distributed software product in most cases.
12:37:01 <KirinDave> bitonic: Which is a LOT of what this product is about and where I wan haskell to be leveraged.
12:37:13 <Cale> bitonic: The basic idea is just that a procedure for computing something which observes only n bits of its input can only produce at most 2^n distinct results
12:37:47 <Cale> bitonic: So anything which produces n distinct results must have observed at least log_2(n) bits of its input.
12:37:59 <bitonic> Cale: so you define "observe" as something that goes towards the complexity
12:38:00 <bitonic> right
12:38:01 <mcstar> i would fire 2 execs and hire 4 programmers
12:39:01 <merijn> KirinDave: Bummer, haskell and distributed software sounds like my area, but I'm not really close to SF or even on the same continent :p
12:39:14 <bitonic> Cale: I think the point with hash tables is the number of comparisons and re-allocating the buckets.  and in that sense functional and non-functional tables are completely different, and the non-FP ones have their advantages, no?
12:39:45 <mcstar> the functionals ones have too, they are persistent
12:39:51 <Cale> bitonic: The advantages which hash-tables have involve constant factors which asymptotic analysis explicitly ignores.
12:39:51 <bitonic> sure
12:40:56 <bitonic> Cale: I don't get your last message
12:41:10 <Cale> Oh, I was comparing hash tables with tree structures
12:41:48 <bitonic> no I'm comparing HAMTs/Patricia trees to classic resizing hash tables
12:41:56 <fommil> I'm trying to use HUnit (for the first time), but when I call runTestTT from my "main =" the return type isn't IO(). How can I run runTestTT?
12:42:01 <bitonic> which do have amortised O(1) insert/lookups
12:42:08 <Cale> Well, Patricia trees aren't hash tables at all.
12:42:30 <mcstar> bitonic: maybe any kind of trees have a bigger space requirement, because of the long pointers
12:42:54 <bitonic> Cale: right, but they are sometimes used as unordered maps, with hashes as keys
12:42:55 <Cale> bitonic: Nothing which can be an arbitrary size has O(1) lookups
12:43:14 <KirinDave> merijn: Maybe in the future. We have some _interesting_ problems to solve.
12:43:31 <bitonic> Cale: "In a well-dimensioned hash table, the average cost (number of instructions) for each lookup is independent of the number of elements stored in the table. Many hash table designs also allow arbitrary insertions and deletions of key-value pairs, at constant average (indeed, amortized[2]) cost per operation." <https://en.wikipedia.org/wiki/Hash_map>
12:43:31 <geekosaur> fommil, discard the result:  runTestTT myTest >> return ()
12:43:39 <bitonic> Cale: you might want to correct that page
12:44:02 <Cale> bitonic: A lot of people are fast and loose about log factors
12:44:11 <Cale> bitonic: and will refer to them as "constant"
12:44:19 <Cale> especially people who work with hashtables for some reason
12:44:25 <mcstar> Cale: isnt this a question, of what do you consider as the elementary operation?
12:44:49 <bitonic> Cale: where is the log factor in the resizing tables mentioned above?
12:45:02 <Cale> Well, okay, in order to distribute n items into buckets according to some hash, your hash function must cost at least O(log n) time to compute.
12:45:26 <bitonic> Cale: I've been saying amortised all along eh
12:45:42 <Cale> That cost doesn't go away through amortisation.
12:45:47 <mcstar> yeah, that cost is not counted in, how long it takes to compute a hash
12:45:53 <mcstar> for strings, it can be quite long
12:45:58 <fommil> geekosaur: thanks, turns out the docs page http://hackage.haskell.org/packages/archive/HUnit/1.2.5.1/doc/html/Test-HUnit.html has *really* bad formatting problems
12:46:31 <fommil> geekosaur: ^ as in, can't be copied and pasted. red bits are strings.
12:46:57 <bitonic> Cale: so you're saying that taking into account comparisons and reallocating of the buckets, they do not have O(1) complexity?  do you have a link?
12:47:08 <bitonic> because it seems like the biggest lie of computer science if that's true
12:47:10 <Cale> I don't have a link, it's just obvious
12:47:38 <maukd> bitonic: what
12:47:40 <Cale> If you compute the hashes of n things and you get O(1) collisions
12:47:58 <bitonic> maukd: what what?
12:48:01 <Cale> then your hash function must have observed at least log(n) bits of each of those things
12:48:01 <fommil> geekosaur: redefing main also works, main :: IO Counts
12:48:14 <Cale> and so must take at least O(log n) time to compute per element
12:48:26 <bitonic> Cale: OK but "complexity" there is defined ignoring the hash computation
12:48:32 <bitonic> which is reasonable
12:48:39 <maukd> why is this reasonable?
12:49:24 <jix> bitonic: it is not reasonable if your algorithm involves changing the hash function (during resizing)
12:49:48 <jix> not sure if it is reasonable otherwise.. but with that you can't just ignore that cost
12:50:05 <monochrom> indeed, I have problem honestly saying that computing hash of a possibly long string takes O(1) time
12:50:15 <Cale> It's unreasonable to ignore the computation of the hash function
12:50:16 <Cale> (and nevermind that memory access is itself not really constant time)
12:50:21 <bitonic> maukd: because it's some neglegible factor per operation.  I'm not sure if taking that into account would make things clearer when assessing data structures
12:50:34 <maukd> bitonic: it's not negligible
12:50:39 <Cale> bitonic: logarithmic factors are frequently negligible
12:50:41 <typoclass> the hash function involves stalling for time so that the hash table can reorganize itself
12:50:48 <bitonic> Cale: OK, I get what you're saying now - you and the wiki page are starting from different points
12:50:57 <Cale> bitonic: But if you're going to neglect them, you might as well be consistent about it
12:51:06 <monochrom> but yes, "hash takes O(1) time" and "memory read takes O(1) time" are some assumptions you should scrutinize
12:51:08 <Cale> and say that lookup in a binary tree is O(1) too
12:51:33 <monochrom> and yes, consistency is the most important
12:52:06 <bitonic> Cale: mhm.  I'm not sure I'm convinced.  hash tables are both intuitively and in practice better performers
12:52:12 <Cale> There's a funny Õ thing called "soft O" which ignores these factors
12:52:39 <Cale> bitonic: The reason for hashtables performing better in the cases where they do are not asymptotic.
12:53:02 <Cale> Hashtables are never asymptotically better than tree structures. They only have better constant factors.
12:53:31 <jix> bitonic: for many problems the asymptotic fastest known algorithm is way slower than "inferior" algorithms for any inputs you'll ever run them on
12:53:34 <Cale> Usually because they can more easily keep the elements stored in a contiguous block of memory
12:53:42 <Cale> and take advantage of cache locality
12:54:23 <monochrom> I can believe "in practice performs better" if you have fair empirical evidence. but "intuitive"? no, definitely not the typical textbook's intuitive story. it's really what Cale says, constant factors and n being small
12:54:28 * hackagebot sizes 2.0.1 - Recursively show space (size and i-nodes) used in subdirectories  http://hackage.haskell.org/package/sizes-2.0.1 (JohnWiegley)
12:55:10 <mcstar> what happened to diff arrays?
12:55:16 <bitonic> Cale: mh mh.  are you sure that there is no article about this?  if it really is incorrect/misleading to advertise hash tables as O(1), somebody should do something about it
12:55:19 <mcstar> cale, you used it for your sudoku solver
12:55:56 <int-e> http://hackage.haskell.org/package/diffarray
12:56:15 <mcstar> i dont think it is developed
12:56:29 <mcstar> and i read on maybe the wiki, that it doesnt perform well in practice
12:56:32 <Cale> bitonic: I'm sure there are articles and textbooks where you can learn this stuff...
12:56:33 <int-e> they used to be abyssmally slow - do the card marking changes to GHC's GC help?
12:56:51 <Cale> bitonic: I don't have one handy, but the reasoning is very straightforward
12:56:58 <bitonic> Cale: CLRS presents hash tables as O(1) and trees as O(lb n), iirc
12:57:03 <Cale> lol
12:57:12 <bitonic> wait, I have it here, I might be wrong
12:57:40 <Cale> It's very unfair to tree structures to do that, I think.
12:58:00 <Cale> Somehow give hash tables a free pass as far as computing the hash function is concerned.
12:58:18 <int-e> yeah, makes you wonder why the database folks are so keen on b-trees :))
12:58:29 <mcstar> is it unreasonable when they key is the machine word?
12:58:30 <jix> I also think it's wrong to count memory accesses as O(1)
12:58:33 <mcstar> -y
12:59:02 <monochrom> I have a guess why so few (or none) articles or books telling the truth, being in academia. it is straightforward, trivial, you can't get publications out of it.
12:59:20 <bitonic> Cale: yes, CLRS does say they're O(1), but the non-resizing ones.  but the same reasoning applies right?
12:59:41 <jix> bitonic: but the non resizing one can only store a finite amount of items
12:59:46 <jix> so they are constant by definition
12:59:47 <Eduard_Munteanu> I don't think the hash function is the problem here, rather handling collisions.
12:59:47 <Saizan> bitonic: what is it taking the hash of?
12:59:50 <Cale> bitonic: Well, if you have a fixed size then every operation is O(1), really :)
13:00:06 <int-e> (there's a flip side to the story - text books and implementations are often binary trees for simplicity, but actually b-trees with nodes filling one or two cache lines should perform much better even in memory)
13:00:25 <bitonic> Cale: right, but we could say the same for a fixed-size binary tree
13:00:58 <bitonic> I'm more concerned about how the tree-hashmap comparison then about the treatment of hash maps
13:01:05 <Cale> Eduard_Munteanu: Well, it's a combination of the two. If you somehow don't have collisions, you must have done logarithmic work to separate your elements well. If you get the collisions and somehow recover fast access anyway, there must be some log factor involved there too.
13:01:19 <Eduard_Munteanu> int-e: in practice, it's pretty straightforward to implement a hash table. Even easier than say red-black trees or other stuff.
13:01:20 <bitonic> I mean everything I've read makes hash maps look asymptotically better
13:01:28 <Saizan> if we are hashing integers by taking the mod against the size of the table it's more reasonable to assume it's O(1)
13:01:32 <lpvb> is there a mathematical meaning / symbol for the double colon ::?
13:01:39 <int-e> Eduard_Munteanu: another excellent point
13:01:42 <bitonic> Saizan: nah, it's actually hashing
13:01:59 <Cale> Saizan: but mod isn't free!
13:02:12 <Cale> > 451237891450762846178945623785612378956137851678516935781231259 `mod` 57834950734895072348950237459034725891
13:02:14 <lambdabot>   44734271673124607517548878697960511067
13:02:16 <mcstar> but it is faster than walking pointers
13:02:26 <bitonic> Cale: I'll bring up this up in my complexity course next term, thanks
13:02:26 <maukd> implying mod isn't walking pointers
13:02:40 <Cale> Is it?
13:02:58 <mcstar> well, on reasonable integers, not on big ints
13:03:05 <typoclass> lpvb: in haskell code i read it as "has type", as in "f has type Int -> Int". not sure about maths
13:03:11 <mcstar> a big int is another story
13:03:14 <nikita-0> Cale: "Hashtables are never asymptotically better than tree structures", well, unless you count "Linear Hashing" as a hash-table.
13:03:18 <jix> I wonder what ignoring log factors would imply about other things
13:03:27 <Cale> mcstar: If you fix a maximum size, then all your operations are O(1) and asymptotics are *meaningless*
13:03:32 <merijn> lpvb: To confuse ML programmers
13:03:34 <int-e> nikita-0: that's a fancy name for an array ...
13:04:01 <nikita-0> int-e: I meant http://en.wikipedia.org/wiki/Linear_hashing
13:04:03 <mcstar> Cale: you mean, because there are a finite number of possible trees?
13:04:27 <Saizan> Cale: 2^32 or ^64 is big enough that you might want to do the analysis as if it were unbounded even if your cost model can't be implemented for that
13:04:44 <Cale> mcstar: Because the total longest amount of time to perform an operation is bounded
13:04:51 <bitonic> mcstar: no, because the N in the complexity is bounded
13:05:00 <Cale> and as soon as you can place a fixed upper bound on the amount of time, you have O(1)
13:05:09 <bitonic> mcstar: so O(lb N) where N has an upper bound is O(1) anyway
13:05:14 <bitonic> I'm repeating Cale.
13:05:19 <Cale> It doesn't matter if that is longer than the age of the universe :)
13:05:19 <mcstar> ok, i get it
13:05:25 <mcstar> but that doesnt reflect practice
13:05:43 <Cale> It's important to understand what asymptotics represent
13:05:50 <bitonic> mcstar: yes but these structures are sold as asymptotically better than others
13:06:19 <mcstar> bitonic: but then, it is obvious, since machines are always finite that that advertising doesnt mean anything in a strict sense
13:06:20 <Cale> They actually don't tell you much practical information about how well things perform. What they tell you about is how the complexity grows as the problem size grows without bound.
13:06:53 <bitonic> mcstar: the asymptotic bound is meaningful when comparing non logarithmic costs for sure
13:07:05 <bitonic> especially when you start to have quadratic or exponential stuff
13:08:08 <Cale> right, in practical, real world terms, log factors rarely matter
13:08:19 * bitonic goes to cook something
13:08:32 <bitonic> Cale: thanks for the enlightenment :)
13:08:34 <nand`> the time complexity is a measure of how well an algorithm scales
13:08:40 <jix> I think you have to specify a computation model when you're arguing about log factors
13:09:24 <Cale> Yeah, you can get even worse.
13:09:26 <jix> if you're using a tape based turing machine you'd even introduce linear factors
13:09:29 <mcstar> do you take acocunt of the cost of the comparison function when you deal with maps?
13:09:51 <mcstar> that is not without cost either
13:09:57 <Cale> Physically speaking, a logarithmic asymptotic cost of accessing memory is unrealistic
13:10:12 <Cale> and O(n^(1/3)) or even O(n^(1/2)) is more reasonable.
13:10:40 <int-e> nikita-0: Aha. This reduces the worst case costs of individual hash map operations. But for algorithms using a hash table only asymptotic costs matter which are not changed.
13:10:41 <Cale> because you can only put a finite amount of memory within distance n of your CPU
13:11:13 <mcstar> Cale: that would be an average over cache1 cache2 ram and swap speed?
13:11:51 <jix> Cale: with n^(1/3) could you get heat away fast enough?
13:11:52 <Cale> mcstar: Yeah, you could look at it that way. It also tends to start mattering in NUMA and distributed systems.
13:12:24 <jix> hmm you could assume that ram that isn't accessed doesn't produce heat
13:12:33 <beaky> how do I write a purely-functional Turing Machine in Haskell ?
13:12:37 <fommil> how do I install the Data.Numbers.Primes module? I would like to be able to just issue a single command
13:12:42 <int-e> jix: asymptotically you'll be building a black hole ;)
13:12:44 <nikita-0> int-e: LH dynamically increases (doubles) the number of buckets, so that asymptotical lookup cost of log(N), like in B-tree.
13:12:54 <jix> int-e: probably
13:13:05 <nikita-0> s/ of l/ is l/
13:13:27 <Cale> beaky: data Tape a = T { before :: [a], here :: a, after :: [a] }
13:13:51 <jix> I think some "standard" model used is an unbounded register machine with constant right shift by one (that was the model I've seen in some course at uni)
13:13:55 <Cale> beaky: use the convention that before is stored in order of increasing distance to the head of the tape
13:14:18 <jix> I wonder what weird results you could get if you try really hard
13:14:31 <Cale> beaky: then you can write basic operations on tapes which move left and right, and replace the value of 'here'
13:14:37 <jix> you could encode arbitrary sized vectors in a single register and add them in O(1)
13:14:58 <beaky> Cale: that works! off I go to implement Data.Tape
13:15:12 <maukd> statically taped language
13:15:38 <shachaf> statistically typed language
13:15:48 <int-e> maukd: all compiler errors say 'hmmmpf'?
13:16:02 <Cale> x :: Integer with probability 1
13:16:07 <mcstar> maybe, we should consider entropy production on which to base complexity analysis
13:16:39 <mcstar> there is such a language^^
13:16:44 <hiptobecubic> beaky, maybe i'm late to the party, but that's basically just a zipper i think
13:16:49 <mcstar> values take on probabilistic values
13:16:55 <mcstar> variables*
13:17:00 <Cale> Yeah, the type I gave is called a list zipper
13:17:07 <beaky> ah
13:17:15 <beaky> seems like a purely-functional doubly-inked list
13:17:19 <beaky> doubly-linked*
13:17:21 <mcstar> no
13:17:25 <Cale> It's not really doubly linked
13:17:35 <Cale> It's just two lists and an element :)
13:17:38 <beaky> ah
13:18:03 <int-e> (if it were doubly linked, you'd have lots of trouble modifying it.)
13:18:08 <beaky> right
13:18:08 <jix> beaky: you could see it as a doubly linked lists where all pointers that point towards you are removed though
13:18:20 <johnw> int-e: you'd have trouble even creating it, wouldn't you?
13:18:28 <Cale> johnw: Oh, you can create them
13:18:32 <beaky> seems that a zipper is just what I need for an infinitely-long turing machine Tape
13:18:32 <int-e> johnw: that's just a knot tying exercise
13:18:36 <maukd> a semi-doubly linked list
13:18:37 <johnw> you just can't evaluate them?
13:18:37 <hpaste> efie pasted “parsing a large file” at http://hpaste.org/76585
13:18:44 <Cale> johnw: You can also evaluate them
13:18:48 <maukd> johnw: you can use them just fine
13:18:50 <int-e> johnw: which can be quite some fun if you've never done it before :)
13:18:51 <johnw> ok
13:18:51 <maukd> you just can't modify them
13:18:58 <Cale> johnw: But it's impossible to distinguish them from infinite structures
13:19:08 <johnw> ah, that's what I was thinking
13:19:10 <mcstar> you can reconstruct them
13:19:13 <Cale> johnw: and modification has a constant cost per-element
13:19:14 <johnw> I guess laziness lets them be usable
13:19:33 <Cale> which builds up and slowly makes things unusable
13:20:29 <Cale> efie: You need to be careful about your parser and what type of strings you're using.
13:20:39 <Cale> efie: What sort of data is it that you're parsing?
13:21:03 <beaky> how different are zippers from doubly-linked lists (like how one would typically handroll them in C, or std::list<T> in C++)?
13:21:41 <Cale> beaky: well, jix provides a nice comparison
13:21:46 <maukd> they're persistent, not ephemeral
13:21:57 <efie> Cale: the parsedData is of type [(String,[(String,Float)])]
13:21:59 <beaky> right
13:22:10 <johnw> a zipper is just "the value, plus what I'd need to know to create a new structure with that value at the given position".  they really really have nothing to do with doubly-linked lists, although that could be an efficient way to implement them in C/C++
13:23:05 <dolio> Not efficient if you want to update persistently.
13:23:06 <Cale> efie: So the file you're parsing is text?
13:23:11 <efie> Cale: yes
13:23:14 <johnw> "could be" :)
13:23:15 * nand` .oO( fromWithin traverse . zipper )
13:23:19 <roconnor> johnw: what you describe is more like a store than a zipper
13:23:23 <johnw> nand`: :)
13:23:31 <Cale> efie: Perhaps use Data.Text, which provides a more efficient representation of strings.
13:23:31 <efie> cale: unicode characters
13:23:39 <johnw> roconnor: isn't every zipper also a comonad?
13:24:14 <Cale> efie: Also, this is a bit silly, but are you compiling with -O2? It's not worth doing anything more unless you're compiling with optimisations :)
13:24:20 <roconnor> johnw: a standard zipper is a list of "nested" stores.
13:24:29 * hackagebot certificate 1.3.0 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.3.0 (VincentHanquez)
13:24:53 <johnw> ah, I was thinking of this quote: "Uustalu points out that behind every zipper lies a comonad."
13:24:56 <johnw> (http://blog.sigfpe.com/2007/01/monads-hidden-behind-every-zipper.html)
13:25:17 <roconnor> johnw: the important part of zippers, that differentiates it from a standard store, is that you have many levels you can go up and down.
13:25:26 <Cale> efie: Depending on what you're doing with the data that you're parsing, you might be able to ensure that parseData can produce part of its output only having read part of the input.
13:25:51 <johnw> roconnor: you can't traverse the whole structure from the focal point in a store?
13:25:54 <Cale> efie: Of course, this will necessarily mean deferring errors until they occur, and not being able to check for them up-front.
13:26:03 <Cale> (unless you parse twice)
13:26:48 <roconnor> johnw: such a traversal is not really a characteristic of zippers.
13:27:05 <Cale> efie: But using a more efficient representation of strings will likely help a good deal.
13:27:05 <johnw> you mean, the "extend" operation?
13:27:25 <nand`> @tell edwardk in the docs for ‘fromWithin’ you have fromWithin l = fromMaybe . within l; surely you mean fromJust?
13:27:25 <lambdabot> Consider it noted.
13:27:58 <johnw> is Zipper is the structure, and Comonad the interface that lets you traverse it with an m a -> b?
13:28:29 <dolio> Not all zippers are comonads.
13:28:30 <johnw> i'm still not clear on the distinction you're making when you said that my description sounded more like a store, since I've seen list zippers implemented exactly that way...
13:29:04 <typoclass> nand`: not sure what's going on there, but fromJust and fromMaybe have different types ...? i think if it typechecks now and you substitute the other, ghc would choke
13:29:31 * hackagebot tls 1.0.0 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.0.0 (VincentHanquez)
13:29:38 <efie> Cale: yes, I compiled with -O2. Doing parsing of the file in several steps sounds like a good idea... i'll definitivly try Text frist, but I'm wondering if this helps for files which have a size of hundreds M
13:29:38 <typoclass> (fromMaybe is the one with the default value on Nothing, fromJust blows up the program on Nothing)
13:29:41 <Saizan> dolio: they aren't?
13:29:41 <efie> MB*
13:29:45 <dolio> No.
13:29:57 <Saizan> dolio: is there a simple example?
13:30:10 <nand`> typoclass: I know; with fromJust I get the type of fromWithin; with fromMaybe it blows up into some type involving stacked Maybe s
13:30:15 <nand`> because ‘within’ is polymorphic enough
13:30:40 <Cale> efie: Well, as the file size increases, this is the sort of thing which lazy stream processing is great for, but you do need to be careful about using operations which consume the whole stream.
13:30:48 <typoclass> nand`: hmm
13:31:08 <nand`> typoclass: it's in the comment, the actual implementation uses neither
13:31:19 <typoclass> nand`: oh i see
13:31:42 <dolio> Saizan: I can define a zipper for a syntax tree, for instance.
13:31:44 <beaky> http://ideone.com/eXP5IN is this alright for a turing machine tape?
13:31:45 <typoclass> nand`: i thought it was in the code, and went "well that's odd"
13:32:14 <dolio> data Expr = Var String | Expr :$ Expr | Lam String Expr
13:32:21 <dolio> It's not going to be a comonad.
13:32:24 <Cale> efie: You generally want to make sure that all the things which process the stream are sufficiently lazy perhaps until the end, where you have something which is sufficiently strict when collapsing the data into something with not so many parts.
13:32:58 <efie> Cale: can stream processing be done with parsec?
13:33:54 <Cale> efie: You know, I'm not sure. Usually Parsec is geared towards parsing human-writable file formats which are not terribly large, but might have complicated grammars
13:34:13 <Saizan> dolio: because it won't be parametric or something else?
13:34:27 <dolio> The former is certainly sufficient. :)
13:34:42 <Cale> efie: There is attoparsec though, which is more aimed at parsing simpler file formats in a streamed fashion.
13:34:43 <Saizan> yeah, but one can get around it
13:34:59 <Cale> http://hackage.haskell.org/packages/archive/attoparsec/0.10.1.1/doc/html/Data-Attoparsec-Text-Lazy.html
13:35:12 <Saizan> in fact i think the usual taking the derivative process would give you something parametric enough
13:35:53 <Cale> or even: http://hackage.haskell.org/packages/archive/attoparsec/0.10.1.1/doc/html/Data-Attoparsec-Text.html
13:36:15 <Saizan> but i guess one might not want to call it a zipper if you can't build the original type from it
13:36:23 <Cale> (because although it works with strict Text, it can operate one chunk at a time)
13:36:46 <roconnor> johnw: a store is something like (dF/dx, x), while a zipper for (mu F) is ([dF/dx], mu F)
13:37:39 <efie> Cale: thanks, I'll take a look
13:38:05 <nand`> ParsecT has a parametrized stream type, no?
13:38:15 <danharaj> roconnor: does a type derivative make sense for nested data types?
13:38:16 <Cale> Yeah, it does
13:38:23 <Cale> So you might be able to do something there
13:38:58 <Eduard_Munteanu> danharaj: nested how?
13:39:10 <nand`> also attoparsec provides a monad, so you can write context sensitive parsers too, no?
13:39:25 <Eduard_Munteanu> (maybe you're asking if the chain rule applies?)
13:39:37 <danharaj> Eduard_Munteanu: i.e. non-regular datatypes
13:39:49 <roconnor> danharaj: I don't know.
13:40:16 <hpaste> otters pasted “will GHC let me put these two data declarations in two different files” at http://hpaste.org/76588
13:40:17 <dolio> Saizan: List is a special case. When you walk down a path in it, you have left a head and a list. So if you avoid walking all the way to the tail, you can represent it as ([a], a, [a]).
13:40:28 <dolio> But the general zipper construction is ([a], [a]).
13:40:39 <Cale> efie: If you know that your data is in a form where you can easily break it into a lazy list of chunks to be parsed separately, then that makes life much simpler.
13:40:50 <dolio> Because D(1 + A*X) = A.
13:40:53 <nand`> otters: not easily; I think something can be done with regards to mutually recursive modules but I have no idea how it works
13:40:56 <nand`> or how well
13:41:15 <Cale> efie: For example, if you're parsing records which are one-line-each, you probably just want to use lines on your input and then map a parser over them
13:41:16 <nand`> (you could of course parametrize Hook instead of adding in ‘Bot’)
13:41:27 <nand`> then data Bot = Bot { hooks :: [Hook Bot] }
13:41:29 <otters> ...oh yeah
13:41:32 <otters> god I'm stupid
13:42:13 <roconnor> johnw: I recommend reviewing the introduciton to "Clowns to the Left of me, Jokers to the Right".
13:42:52 <roconnor> (there seems to be some disagreement as to whether a zipper is just the list of contexts, or also includes the value in focus).
13:42:56 <dolio> Another example is: 'data DoubleList a b = Cons1 a (DoubleList a b) | Cons2 b (DoubleList a b) | Nil'.
13:43:37 <dolio> There are paths into it that aren't focused on a b, so unless you limit your zipper to only having paths to a nodes, it's not a comonad.
13:43:44 <dolio> Paths to b nodes, even.
13:44:23 <otters> nand`: I can't do that because Bot isn't in scope
13:44:40 <otters> oh yeah I can
13:47:45 <dolio> If your type is a functor, you can define a zipper by taking its derivative and pairing it with an element. And that will always be a comonad. But there are more general versions of zippers than that.
13:48:21 <dolio> roconnor: Also, probably ([(dF/dx)muF], muF), right?
13:48:52 <dolio> dF/dx is still a functor, and you fill its holes with muF for the places you didn't walk?
13:48:55 <roconnor> dolio: ugh, that seems bettter
13:49:10 <roconnor> calculus is hard
13:49:29 * hackagebot tls-extra 0.5.0 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.5.0 (VincentHanquez)
13:49:31 * hackagebot tls-debug 0.2.0 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.2.0 (VincentHanquez)
13:52:33 <mcstar> calculemus!
13:55:20 <beaky> writing the turing machine in Haskell is easier than in C :D
13:55:38 <dolio> That isn't surprising. :)
13:55:58 <dolio> C makes you think about lots of irrelevant details for something like that.
14:00:22 <efie> Cale: thanks!
14:00:55 <merijn> Anyone know if it is possible to ask which route is currently being handled in Yesod?
14:01:16 <parcs`> merijn: getCurrentRoute
14:02:26 <merijn> parcs`: Thanks, is there like a cheat sheet anywhere? The yesod book doesn't mention it and I'm having a hardtime searching the documentation for answers
14:04:19 <hpaste> Daroth pasted “findAfterChar” at http://hpaste.org/76590
14:05:15 <Daroth> my first definition line use twice 'c' and I thougth it would mean "the same value must be a two different places a the same time"
14:05:28 <parcs`> merijn: i don't know of any
14:05:40 <parcs`> merijn: perhaps :browse Yesod may be helpful
14:06:03 <parcs`> err, never mind :)
14:06:08 <merijn> ;)
14:06:16 <mcstar> 'c (c' are two bindings to the same label
14:06:22 <Daroth> but compiler do not like it "Conflicting definitions for `c'", is there a better way to do it than an "ugly" if/else condition ?
14:06:29 <merijn> Daroth: Guards
14:06:34 <mcstar> you have to test for equality, like c1 (c2... c1\\c2
14:06:38 <mcstar> ==
14:06:59 <maukd> mcstar: ?
14:07:24 <Cale> findAfterChar c (c':x:xs) | c == c' = Just x
14:07:26 <otters> @pl (\h -> callback h ev)
14:07:27 <lambdabot> flip callback ev
14:07:27 <dolio> Switch to Miranda. :)
14:07:33 <mcstar> somfunc c1 (c2:cs) = if c1 == c2 then....
14:07:35 <mcstar> maukd: ^
14:07:49 <maukd> mcstar: I'd rather use guards
14:07:50 <Cale> Use the guard, so that you can fall through to the next case :)
14:07:50 <Daroth> merijn: yeah cool, I had fogot this one, thx!
14:08:19 <mcstar> a guard doesnt solve it, you still have to test equality
14:08:22 <hpaste> merijn annotated “findAfterChar” with “findAfterChar (annotation)” at http://hpaste.org/76590#a76591
14:08:31 <mcstar> its just a nicer way to write consecutive ifs
14:09:02 <merijn> mcstar: He asked "is there a better way to do this than an ugly if/else condition"
14:09:29 * hackagebot pandoc 1.9.4.5 - Conversion between markup formats  http://hackage.haskell.org/package/pandoc-1.9.4.5 (JohnMacFarlane)
14:09:36 <ryanos> mcstar: i would be interested to see the code for a sudoku solver (if available..)
14:09:48 <mcstar> id first resolve the issue to compile at all, and then remove the ifs... if its necessairy
14:10:02 <dolio> findAfterChar c (((c ==) -> True) : x : _) = Just x -- much less ugly
14:10:16 <mcstar> ryanos: a minute
14:10:25 <ryanos> great tx :)
14:10:37 <dolio> ryanos: The haskell wiki has an entire page full of sudoku solvers.
14:11:06 <ryanos> i'm a n00bie at haskell .. pointers required :)
14:11:08 <mcstar> ryanos: http://hpaste.org/76462 and http://hpaste.org/76464
14:11:28 <ryanos> mcstar+: tx
14:11:40 <mcstar> one is an intuitive one, the other is based on the exact cover representation, ironically, the first one is faster
14:11:41 <dolio> http://www.haskell.org/haskellwiki/Sudoku
14:12:01 <maukd> :t (listToMaybe . drop 1 .: dropWhile) . (/=)
14:12:02 <lambdabot>     Couldn't match expected type `[[a]]'
14:12:02 <lambdabot>            against inferred type `[a1] -> [a1]'
14:12:03 <lambdabot>     In the second argument of `(.:)', namely `dropWhile'
14:12:12 <ryanos> mcstar: awesome, tx much
14:12:18 <ryanos> dolio: tx too
14:12:34 <mcstar> i didnt mean he shouldnt look at the wiki...
14:12:40 <mcstar> in fact he should and he will
14:13:10 <mcstar> but pointers arent really required in haskell
14:13:15 <mcstar> i like that in fact
14:13:17 <ryanos> i will no probl.. just need some more "real life haskell with a manageable complexity level"
14:13:50 <ryanos> mcstar: i meant "pointers" (in RDF sense - or URIs :) no C sense
14:13:58 <mcstar> i know
14:14:17 <ryanos> u guys are great
14:14:37 <ryanos> by far the best irc group i've seen in a long time
14:15:28 <ryanos> makes haskell a lot more fun to learn when you can throw anything you can think of at a group of people who will come up with an answer in like 2 mins.. :)
14:16:51 <johnw> roconnor: what is Mu?
14:17:37 <typoclass> ryanos: clearly you haven't seen the dark side of #haskell yet. if you say something against lolcats for example, the gloves come off
14:18:02 <mcstar> Daroth: i just noticed, line 4 and 5 have different signature then before, you are missing the char parameter
14:18:06 <ryanos> typoclass: here it comes - "lolcats" :)
14:18:15 <beaky> how do I lookup a Data.Map without the Maybe?
14:18:24 <johnw> beaky: !?
14:18:30 <johnw> as in, Data.Map.!
14:18:31 <ryanos> (that's as much i can say about lolcats at this point)
14:19:07 <ryanos> btw... on sudoku solvers.. is there any of the solvers out there able to identify the top fastest/slowest paths of solving a given sudoku puzzle ?
14:19:08 <roconnor> johnw: the (least) fixpoint of a * -> *
14:19:16 <typoclass> beaky: you can unwrap a Maybe by using fromMaybe
14:19:21 <johnw> roconnor: as in "least-defined"?
14:19:26 <typoclass> > fromMaybe 42 (Nothing)
14:19:28 <lambdabot>   42
14:19:29 <typoclass> > fromMaybe 42 (Just 7)
14:19:31 <lambdabot>   7
14:19:45 <mcstar> but make sure the lookup can never fail...
14:20:07 <mcstar> oh, fromMaybe, thats ok
14:20:07 <ryanos> by "fast/slow" i mean in the shortest/longest number of moves
14:20:12 <mcstar> i was thinking frmoJust
14:20:31 <roconnor> johnw: in standard intepretations of type theory (CPO)s the greatest and least fixpoints are the same.
14:22:03 <roconnor> johnw: given F X := 1 + A * X, then mu F = 1 + A * (mu F)  aka mu F = list A.
14:22:49 <johnw> how do you know that mu F = list A?
14:23:05 <johnw> I guess I need to learn a bit about type theory
14:23:28 <johnw> i only just learned what injection is; I have several books on order now
14:23:43 <lispy> johnw: I believe you'd show it via isomorphism, but I don't know enough type theory to know if that's true
14:23:58 <roconnor> data ListA = Nil | Cons A ListA -- this is what you write in haskell.
14:24:21 <lispy> johnw: basically, 1 ~= [], and A * (mu F) ~= Cons a [a]
14:24:23 <roconnor> johnw: | corresponds to + and * corresponds to the multiple arguments in a constructor
14:24:45 <roconnor> johnw: Nil corresponds to 1 because there is a single constructor with no arguments (1 is the identity for multiplication
14:24:53 <shachaf> Too many things are called Mu.
14:25:01 <roconnor> so writing this haskell type in "arithmetic form" we get
14:25:05 <lispy> shachaf: so says mu
14:25:13 <roconnor> ListA = 1 + A * ListA
14:25:38 <roconnor> replace ListA with (mu F) we get  (mu F) = 1 + A * (mu F)
14:26:07 <johnw> mu for any F X is 1 + A * (mu F)?
14:26:22 <johnw> or just for F X := 1 + A * X?
14:26:27 <roconnor> johnw: mu F = F (mu F)
14:26:30 <roconnor> right
14:26:51 <johnw> so is mu F for types similar to what fix F is for definitions?
14:26:58 <roconnor> johnw: precicely
14:27:03 <johnw> got it!  thanks
14:27:05 <lispy> ortmage: ah, so F X := 1 + A * X, and then we applied mu to both saides?
14:27:13 <lispy> side*
14:27:26 <lispy> ortmage: sorry, that was meant for roconnor
14:27:34 <roconnor> lispy: not really
14:27:52 <roconnor> given that F X := 1 + A * X we have ....
14:27:55 <shachaf> lispy: It's the same as "fix" except on the type level.
14:28:27 <roconnor> mu F = F (mu F) ... substituing the definitoin for F we get F (mu F) = 1 + A * (mu f)
14:29:01 <lispy> ah, duh
14:29:04 <lispy> I see it now
14:29:33 <shachaf> "fact = \n -> if n == 0 then 1 else n * fact (n-1)" ==> "fact = fix $ \self n -> if n == 0 then 1 else n * self (n-1)", and so on.
14:29:41 <shachaf> roconnor: Does this Mu have anything to do with the other thing you called Mu?
14:29:43 <shachaf> @where Rec
14:29:44 <lambdabot> I know nothing about rec.
14:29:48 <shachaf> @src Rec
14:29:48 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
14:29:50 <shachaf> Curry's paradox.
14:29:54 <roconnor> shachaf: what was the other thing?
14:30:05 <shachaf> That.
14:31:08 <roconnor> @src Mu
14:31:08 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
14:31:15 <roconnor> it's related to that
14:32:27 <shachaf> edwardk also says data Mu f = Mu (forall a. (a -> f a) -> a)
14:32:45 <shachaf> Which I think is isomorphic to the "Fix" Mu?
14:33:24 <roconnor> shachaf: I find that plausible, but I'm not familiar with that
14:33:47 <Saizan> shachaf: you mean (f a -> a) there?
14:34:25 <shachaf> Er, yes, I do mean that. :-)
14:34:26 <typoclass> shachaf: where does @src get the Rec from? couldn't find it with hoogle
14:34:39 <shachaf> typoclass: It's manually inserted into lambdabot.
14:34:45 <shachaf> Look in the lambdabot repository.
14:34:51 <lispy> ?version
14:34:51 <lambdabot> lambdabot 4.2.2.1
14:34:51 <lambdabot> darcs get http://code.haskell.org/lambdabot
14:35:09 <shachaf> Also data Nu f = forall a. Nu a (a -> f a)
14:35:10 <typoclass> shachaf: hm okay. so Rec is not in a well-known package
14:35:25 <Saizan> cata :: Mu f -> forall a. (f a -> a) -> a, if you want
14:35:39 <roconnor> Nu and Mu should be isomorphic in haskell land
14:35:50 <shachaf> typoclass: https://en.wikipedia.org/wiki/Curry's_paradox
14:35:57 <shachaf> Saizan: Right.
14:36:01 <typoclass> shachaf: thanks
14:36:11 <johnw> is there a list of good haskell blogs somewhere?
14:36:20 <lispy> johnw: planethaskell.org?
14:36:26 <johnw> i only just realized the comonad coreader wasn't in my list
14:36:32 <roconnor> planet.haskell.org?
14:36:35 <johnw> thanks
14:36:45 <lispy> punctuation? I can has it?
14:37:09 <shachaf> There's a Comonad *co*reader now?
14:37:33 <Clint> coedwardk
14:37:55 <roconnor> what's a coreader?
14:38:14 <johnw>  http://comonad.com/reader/
14:38:24 <shachaf> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/src/Control-Comonad-Reader.html
14:38:39 <shachaf> Coreader = Writer?
14:38:50 <maukd> coeducation
14:38:59 <nand`> maukd: heh
14:39:06 <typoclass> colearn me a book
14:39:13 <lispy> coadjoint?
14:41:25 <ryant5000> is there a name for this? map head . group
14:41:30 <johnw> are the haskelle exchange 2012 videos downloadable?
14:41:38 <Ralith> out of curiosity, is there a common 'unordered map' type, or is there no point to such a data structure?
14:41:45 <johnw> their embedded player has only two options it seems: too tiny, and fullscreen
14:41:46 <merijn> Is there an == that lets me compare arbitrary types of elements?
14:41:58 <ryant5000> Ralith: have you looked at Data.Map?
14:42:08 <Ralith> ryant5000: isn't that ordered?
14:42:10 <roconnor> merijn: nope
14:42:21 <shachaf> ryant5000: That's the behavior of the UNIX utility "uniq"...
14:42:23 <merijn> i.e. some "'a' == 'a' = True" and "'a' == 1 = False" type of deal
14:42:32 <roconnor> merijn: nope
14:42:37 <merijn> Bollocks :\
14:42:46 <ryant5000> Ralith: ah, i'm not sure i understand what you mean by unordered
14:42:48 <typoclass> johnw: doesn't work if you zoom the page in your browser?
14:42:49 <roconnor> merijn: time to rethink your design
14:42:50 <shachaf> merijn: (Eq a, Eq b, Typeable a, Typeable b) => a -> b -> Bool?
14:42:51 <companion_cube> merijn: how can elements of different types be equal?
14:42:51 <merijn> Am I doomed if I want to hack something like that?
14:42:59 <merijn> companion_cube: They can't
14:43:02 <shachaf> But ==roconnor
14:43:02 <merijn> companion_cube: Clearly
14:43:14 <companion_cube> well then  \_ _ -> False :D
14:43:22 <merijn> companion_cube: I only want to compare if the types match
14:43:22 <companion_cube> hmm,no
14:43:37 <ryant5000> shachaf: good point; maybe i should call it that; i was hoping there was one in the standard lib
14:43:41 <merijn> roconnor: It's not my design, else I wouldn't have to ask something like this
14:43:43 <Ralith> ryant5000: Data.Map builds a tree based on the ordering of its keys, and can easily and naturally reconstruct an ordered list of its elements
14:43:46 <shachaf> I guess you don't need the Eq b constraint. :-)
14:43:47 <roconnor> merijn: types are normally erased during compilation
14:43:52 <mcstar> ryant5000: try a map
14:43:53 <roconnor> merijn: sucky
14:44:05 <shachaf> ryant5000: What are you doing?
14:44:09 <typoclass> @where (===)
14:44:10 <lambdabot> I know nothing about (===).
14:44:25 <ryant5000> shachaf: i'm just merging adjacent values that are equal
14:44:37 <roconnor> merijn: something can be hacked with typeable
14:44:47 <merijn> roconnor, companion_cube: Basically I'm trying to write a Yesod widget to dynamically generate a menu and I want to compare each element in the menu with "getCurrentRoute", if they match I want to turn on a highlight
14:44:48 <ryant5000> shachaf: specifically, i'm taking the first of each adjacent group in which *part* is equal
14:45:00 <shachaf> So it's groupBy?
14:45:02 <jfischoff> when I'm profiling an app, its only showing the cost centers in my code. Is there a way to show all of the cost centers for the libraries in use too?
14:45:20 <ryant5000> shachaf: yeah, except i don't want the groups
14:45:34 <ryant5000> shachaf: i just don't like having 'head' floating around in my general code
14:45:37 <shachaf> Right.
14:45:40 <merijn> roconnor, companion_cube: Unfortunately, Yesod routes are parameterised and the code that needs to do the comparison has no guarantee which type "getCurrentRoute" will return, so statically fixing the type of the routes is impossible
14:45:47 <Cale> I don't think there's a special name for that, however, this is one idiomatic use of head which is totally safe
14:45:49 <beaky> how do I get the 3rd element in a tuple?
14:45:59 <shachaf> I,I group :: [a] -> [NonEmptyList a]
14:46:05 <ryant5000> Ralith: yeah, that's true; so i was thinking Data.Map was unordered, in that it discards the ordering of its input
14:46:19 <shachaf> Maybe group :: [a] -> [(a,[a])]
14:46:20 <ion> beaky: By pattern matching. But when you are using a 3-tuple you probably want a type of your own instead.
14:46:25 <companion_cube> merijn: hmmm, good luck
14:46:35 <merijn> So the only two sensible approach I can think of are "universal comparison" or "manually writing the menu in every handler"
14:46:35 <nand`> group :: [a] -> [(a, Integer)]
14:46:46 <merijn> I consider the former slightly less offensive than the latter
14:46:48 <nand`> but that wouldn't work too well for groupBy
14:46:49 <jfischoff> @hoogle get3
14:46:50 <lambdabot> No results found
14:46:58 <merijn> (Sense I'm incredibly lazy :p)
14:47:07 <jfischoff> @where Data.Tuple
14:47:07 <lambdabot> I know nothing about data.tuple.
14:47:12 <Cale> nand`: Also, you're now allowing negative integers possibly :)
14:47:33 <ryant5000> shachaf: i think NonEmptyList or pair would not be bad
14:47:56 <shachaf> (a,[a]) ~ NonEmptyList a
14:48:06 <ryant5000> shachaf: right
14:48:08 <shachaf> It could be a nice interface.
14:48:17 <typoclass> merijn: according to docs getCurrentRoute :: GHandler sub master (Maybe (Route sub)) . i'm not familiar with yesod, where does the 'sub' come from?
14:48:19 <ryant5000> yeah
14:48:56 <shachaf> ryant5000: You can write *that* function instead of your "uniq" function. :-)
14:48:57 <merijn> typoclass: The (optional) subsite
14:49:11 <merijn> typoclass: Normall sub ~ master, but if you have subsites sub and master may differ
14:49:23 <ryant5000> shachaf: or i can write uniqBy and be done in about 5 seconds
14:49:29 <ryant5000> :P
14:50:06 <shachaf> ryant5000: Sure, but what sort of useless function is that?
14:50:09 <Cale> Or yeah, just give  map head . group  a name
14:50:36 <mcstar> call it mapheaddotgroup
14:50:37 <ryant5000> shachaf: haha, well i'm not going to submit a patch to base for it :P
14:51:06 <shachaf> group : [a] -> [(l:[a],ProofOfNonEmpty l)]
14:51:19 <Cale> lol
14:51:25 <ryant5000> haha
14:51:35 <mmcdermo> Surprising problem: a long-running haskell program is giving me this error after mysteriously dying:
14:51:39 <mmcdermo> <stdout>: commitBuffer: hardware fault (Input/output error)
14:51:39 <mcstar> Cale: do you know of sets or maps implemented as trees, but not using the less-than ordering, but something else?
14:51:52 <mcstar> for integers, for example
14:51:53 <jfischoff> interesting. when installing profiling libraries cabal doesn't use -auto-all I guess
14:51:55 <mmcdermo> Probably not a problem with haskell. Running on a virtual server.
14:52:15 <ziman> mcstar, there are patricia trees underlying IntMap/IntSet
14:52:16 <Cale> mcstar: IntMap sort of kind of uses something else, though it amounts to keeping things in order anyway
14:52:44 <mcstar> Cale: im thinking something number theoretical, like odering based on prime factorization or similar
14:53:05 <Cale> heh, well, usually the goal is to be inexpensive
14:53:22 <mcstar> maybe it would be super fast for read-only access :)
14:53:28 <mcstar> no, it wouldnt
14:54:11 <Cale> I guess you could have other goals, like a tree structure you could give to someone and they couldn't prove what elements it contained without knowing the keys.
14:54:49 <mcstar> persistent encryption ftw
14:56:42 <merijn> Looks like I can get away with "x === y = case cast y of { Just v -> x == v; Nothing -> False }"
14:56:57 <Cale> mcstar: However, as the FingerTree paper rightly points out, the thing that tree structures really have in common is a way of measuring the elements at the leaves to give elements of some monoid, which is then used to summarize the contents of subtrees.
14:58:18 <mcstar> Cale: which paper is that?
14:58:33 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
14:59:30 <mcstar> i had it downloaded already, i have a bad memory...
15:00:55 <Cale> Essentially every place in CS where we use trees to improve performance, there's some monoidal structure hanging around allowing us to combine summarizing information about the subtrees.
15:01:41 <nifr> I've scanned the easy-to-find discussions of Codensity, but haven't found much (concrete) discussion about why the argument functor needn't be a monad.
15:01:42 <typoclass> merijn: right, i dug it out of the #haskell logs, mauke has sometimes used "let a === b = cast a == Just b" to confuse the newbies
15:01:56 <nifr> is understanding Kan extensions the only path to answering this question?
15:02:10 <Cale> and the monoid axioms allow us to rebalance the trees without recomputing too many summaries
15:02:25 <watermind> in the monoid instance of Ordering... why is <> defined in that order
15:02:25 <Cale> nifr: There's the direct route
15:02:38 <Cale> nifr: Look at the definition, try to prove it's a monad.
15:02:45 <watermind> compA <> compB   first applies compA then compB
15:02:51 <merijn> typoclass: Bollocks, and I just realised I'm still screwed >.>
15:03:03 <copumpkin> watermind: lexicographic
15:03:04 <merijn> typoclass: Because I can't enforce a Typeable constraint on sub
15:03:14 <watermind> copumpkin: yes but why isn't it flipped...
15:03:27 <watermind> copumpkin: so that it would work like composition
15:03:31 <maukd> watermind: wtf?
15:03:33 <copumpkin> watermind: because we like lexicographic ordering?
15:03:35 <nifr> Cale: I was hoping for a broad strokes discussion beyond the technical steps
15:03:54 <copumpkin> watermind: does your library sort by last letter, then by second-to-last?
15:04:06 <nifr> my curiosity was piqued by the resemblance of the definition itself to the third monad law
15:04:15 <maukd> copumpkin: you could just rearrange the tests
15:04:23 <typoclass> merijn: i'm sorry. i just vaguely remembered something and searched the logs, sorry if it doesn't fit
15:04:28 <copumpkin> maukd: sure, but why?
15:04:48 <maukd> copumpkin: because then it works like .
15:04:52 <watermind> copumpkin: I'm not sure if I follow, I understand it should be lexicographic order
15:04:53 <typoclass> watermind: think of <> as an extension of ++
15:05:14 <merijn> typoclass: Time to complain to Yesod people :p
15:05:22 <typoclass> copumpkin: he's asking why (f <> g) isn't like (g . g)
15:05:26 <typoclass> *f
15:05:38 <Cale> nifr: It's also very closely related to Cont
15:05:40 <nifr> but beyond "the second argument of >>= is continuation-like", I'm not seeing a major connect (without yet stepping through the proof, as you suggested to do)
15:05:51 <nifr> *connection
15:06:43 <Cale> Here's the guy you want to talk to
15:06:48 <nifr> ha, yeah
15:06:52 <nifr> I've scanned the easy-to-find discussions of Codensity, but haven't found much (concrete) discussion about why the argument functor needn't be a monad.
15:06:55 <nifr> is understanding Kan extensions the only path to answering this question?
15:06:59 <nifr> my curiosity was piqued by the resemblance of the definition itself to the third monad law
15:07:00 <watermind> copumpkin: it's just a matter of what's most intuitive  to denote lexicographic order,  I would read    (compB <> compA )  x y    as, test compA then compB
15:07:33 <shachaf> nifr: It doesn't even need to be a functor, does it?
15:07:34 <Cale> edwardk: nifr wants a high-level explanation as to why Codensity m is a monad for any type constructor m
15:07:39 <nifr> edwardk: pointer in the right direction? was Cale's suggesting of just proving Codensity f is a monad the recommended path?
15:07:55 <nifr> shachaf: correct, typo on my part: f is totally unrestricted
15:08:03 <shachaf> nifr: Presumably the same proof that Cont is a monad works here, because the Monad instance is exactly the same as Cont.
15:08:12 <beaky> how do I get an infinite list of something?
15:08:13 <watermind> copumpkin: in that <> is similar to composition
15:08:24 <copumpkin> > repeat '5'
15:08:26 <lambdabot>   "55555555555555555555555555555555555555555555555555555555555555555555555555...
15:08:26 <beaky> i.e. infiniteList "foo" = ["foo", "foo", "foo", ...]
15:08:29 <beaky> ah
15:08:32 <typoclass> > [1..] -- beaky, example infinite list
15:08:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:08:34 <parcs`> > repeat "foo"
15:08:36 <lambdabot>   ["foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","foo","f...
15:08:40 <edwardk> i'm a bit distracted in RL
15:08:40 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
15:08:43 <Cale> I suggested just proving it directly, though the proof ought to be quite similar as the proof for Cont r
15:08:48 <parcs`> > cycle "foo"
15:08:48 <copumpkin> edwardk: ralph lauren?
15:08:49 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
15:08:50 <shachaf> beaky: Hoogle is a good way to answer that sort of question. :-)
15:09:12 <beaky> right
15:09:14 <Cale> similar to*
15:09:33 <shachaf> nifr: You might ask the same thing about ContT.
15:09:39 <shachaf> (What *is* ContT? We just don't know.)
15:09:57 <Cale> What *are* birds? We just don't know.
15:10:20 <Cale> http://www.youtube.com/watch?v=wfvEgWINUFc
15:10:20 <beaky> http://ideone.com/kYvchB I've finished the turing machine, but show Tape keeps trying to print the infinitely-long tape :(
15:10:46 <shachaf> I,I ContT Nu Ation
15:11:13 <typoclass> > take 50 (repeat '3') -- beaky
15:11:14 <lambdabot>   "33333333333333333333333333333333333333333333333333"
15:11:16 <shachaf> Cale: I haven't seen series 2.
15:11:27 <copumpkin> watermind: the order of the dot arguments is primarily due to the function application it's replacing
15:11:29 <typoclass> > takeWhile (< 100) [1..] -- beaky
15:11:31 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:11:35 <copumpkin> watermind: I don't really see that justifiaction elsewhere
15:11:46 <nifr> thanks, I'll grep for discussions of ContT
15:12:02 <typoclass> beaky: uh :) we couldn't see that there, but that list stops at 99
15:12:31 <parcs`> 'Codensity f a' is just 'forall r. Cont (f r) a' and 'Cont r a' is a Monad for regardless of what r is
15:12:53 <watermind> copumpkin: right
15:13:40 <byorgey> > takeWhile (< 7) [1..]
15:13:41 <lambdabot>   [1,2,3,4,5,6]
15:13:54 <beaky> if only I could count how many writes the turing machine did, then I would know when to stop printing out the infinite-tape
15:14:04 <beaky> how do I keep a counter in Haskell?
15:14:29 <Cale> beaky: make the initial/current value of the counter a parameter to your function
15:14:44 <beaky> ah, like an accumulating parameter
15:16:07 <shachaf> nifr: If one of the things you're trying to figure out is "how does it work for 'wrapping' a monad, if it doesn't actually use the monadness of the thing it wraps?", the answer might be foo m = Codensity (m >>=) and bar (Codensity f) = f return.
15:17:33 <nifr> my goal is a non-oracular derivation of the definition of Codensity's >>= from the third monad law
15:17:53 <nifr> if I start with an oracular "rewrite these >>=s to `runCodensity`", then it's trivial from there
15:18:21 <nifr> *rewrite should be "change" -- it doesn't preserve the types
15:18:22 <shachaf> From the third monad law?
15:18:28 <nifr> associativity of bind
15:18:44 <shachaf> I don't think there's even a total definition of (>>=) other than the normal one, is there?
15:21:26 <beekor> hiya guys.  I'm getting my module path in my type error like this:  Couldn't match expected type `FilePath' with actual type `system-filepath-0.4.6:Filesystem.Path.Internal.FilePath' .  I'm not figuring out how to connect those two.  any directional pointers?
15:22:00 <beekor> ah shit, i think i did figure that out last night.  i needed Prelude.FilePath.
15:22:05 <shachaf> beekor: The normal FilePath is a synonym for String.
15:22:14 <shachaf> Whatever that package's FilePath is, I assume it's not.
15:22:28 <beekor> hm okay. that makes sense.
15:24:31 * hackagebot hledger-lib 0.19 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.19 (SimonMichael)
15:28:31 <smartviking> Not in scope: `bracketOnError'
15:28:47 <hpc> @hoogle bracketOnError
15:28:47 <lambdabot> Control.Exception.Base bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:28:47 <lambdabot> Control.Exception bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:28:47 <lambdabot> Control.OldException bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
15:29:04 <smartviking> I did import Control.Exception (bracketOnError)
15:29:16 <smartviking> But that error sill showed
15:29:33 <hpc> is it qualified?
15:29:33 * hackagebot hledger 0.19 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.19 (SimonMichael)
15:29:35 <smartviking> When I did it in ghci, bracketOnError got imported
15:30:07 <smartviking> hpc: I don't know, not sure what that means
15:30:21 <hpc> hmm, you should paste what you are doing
15:30:23 <hpc> @where hpaste
15:30:23 <lambdabot> http://hpaste.org/
15:31:01 <hpaste> smartviking pasted “todo” at http://hpaste.org/76593
15:31:21 <smartviking> It's from the book, LYAH
15:31:30 <smartviking> bracketOnError on line 37
15:31:41 <typoclass> smartviking: hm, that file doesn't have the import of Control.Exception ...
15:33:04 <smartviking> Hm, I think I was working on two different files by accident
15:33:14 <smartviking> Now it works, thanks
15:33:32 <typoclass> smartviking: you're welcome. this was one of the easier questions :-)
15:34:17 <smartviking> In the book though, that's all the imports. I guess that's an error
15:34:53 <typoclass> smartviking: yes, that's probably true. what chapter is it from?
15:34:54 <fommil> do any of the haskell compilers generate code to cache the results of purely functional methods? e.g. a factorial method that remembers previous calls, or an (Int -> Bool) -> [Int] that will return the list on the second call instead of calculating it?
15:35:14 <shachaf> fommil: Compilers generally don't, but there are libraries for it.
15:35:26 <fommil> shachaf: does it involve any extra code?
15:35:31 <shachaf> Yes.
15:35:37 <shachaf> You usually don't want it to happen automatically.
15:35:38 <smartviking> typoclass: Chapter 9 "More input and more output". Page 188 in the hard copy
15:36:14 <fommil> shachaf: it would be cool if it wasn't code that did this, but a properties file that listed which functions to cache and what the memory constraints were
15:36:16 <smartviking> I also think there's an error on the last two lines in that program, the author uses "todo.txt" when I think he meant to use fileName
15:36:41 <fommil> shachaf: but I think that really would require the compiler to do the work
15:36:53 <smartviking> I didn't find anything about that on the errata page of the book, maybe I'll send a mail
15:36:58 <fommil> shachaf: actually I thought this was one of the big selling points of Haskell
15:37:34 <shachaf> fommil: Being able to specify memory constraints in one file and an implementation in a different file?
15:38:00 <hiptobecubic> just use memotrie or something
15:38:14 <fommil> shachaf: write purely functional code, define the inputs/outputs to be cached in another.
15:38:49 <fommil> shachaf: I can imagine it would get really complicated in the compiler, because the returned value probably still won't be evaluated at that point.
15:39:10 <fommil> shachaf: so it's not as simple as saving the inputs, saving the output, and then using a map in the future.
15:39:40 <shachaf> fommil: Why not? Just keep thunks in the map.
15:39:44 <typoclass> smartviking: hm ... in the web edition, i don't notice inconsistency with fileName vs. todo.txt. also, bracketOnError doesn't seem to occur there. maybe he noticed the mistakes and fixed them :)
15:39:51 <typoclass> smartviking: http://learnyouahaskell.com/input-and-output
15:39:53 <shachaf> (Which is how the memoization libraries do it, presumably.)
15:42:22 <fommil> shachaf: imagine this: you have a (Int -> Bool) predicate which you use to build up a list of [Int] over some range (Int is in the list if the predicate is True). The method that generates this list will return (as I understand it) a list with pointers to future work that still needs to create the integer list. The caching mechanism would need to store the inputs and the final list, not just the pointers to the work to do
15:42:22 <fommil> work (unless that is cached as well, but that would seem like a lot of running for nothing).
15:43:44 <smartviking> typoclass: Yeah, that's defintely different
15:43:48 <shachaf> fommil: You can look at some of the existing memoization libraries for some strategies that are used for this sort of thing.
15:43:52 <fommil> shachaf: actually, I stand corrected, even caching the pointers to the elements to do the work would not be beneficial. imagine the predicate is the dirac delta, and the range is [-million, millon]
15:43:55 <jix> fommil: using the memoization libraries works usually like this: you have a function f' that isn't memoized... then you simply write f = memo f' and f will be memoized
15:44:04 <jix> faen: it can't get much simpler than that
15:44:12 <jix> *fommil:
15:44:39 <fommil> jix: does it evaluate the results or is it smart enough to do what I described? i.e. in the dirac delta case
15:44:54 <fommil> jix: deferring work, but actually caching the results of that work
15:45:03 <mcstar> computers rarely work on real numbers, thats not a dirac delta
15:45:10 <jix> fommil: it will not evaluate anything that wouldn't be evaluated without memo
15:45:22 <jix> from the return value
15:45:37 <fommil> jix: awesome. which memorisation libs are well supported?
15:45:48 <jix> fommil: I'm using MemoTrie
15:46:30 <fommil> jix: it would be really amazing if a library existed that separated logic and memorisation, e.g. in an XML config file or something
15:46:45 <shachaf> There's MemoTrie. I think there's another one that lets you specify strategies for particular types, rather than just using a type class.
15:47:19 <smartviking> Anyway I'm really starting to digg haskell, I've started reading LYAH on the bus (4.5h/week) and it's really inspirational to think about problems in terms of haskell.
15:47:54 <mcstar> i think you could write a little TH code, to make the memoization boilerplate go away
15:48:49 <typoclass> smartviking: good to hear. but don't forget to get your mother camel, sacrifice day is coming up
15:49:44 <fommil> jix: oh hold on, does MemoTrie actually store the evaluated results, if they are calculated after the function returns? consider my example with dirac delta again
15:50:17 <smartviking> typoclass: I don't know what that means but I'll keep that in mind
15:50:39 <hpaste> KaiSforza pasted “something missing?” at http://hpaste.org/76594
15:51:19 <mcstar> dont use dirac delta, for dirac's sake
15:51:47 <KaiSforza> So I'm reading through Learn you a haskell, and i've been typing in all of the examples, and so far they've been working. but this one is not working...
15:52:06 <fommil> (btw, this is pretty amazing that this channel has almost 1000 people in it! ##java only has 400)
15:52:09 <typoclass> smartviking: i was joking :) enjoying haskell does not actually require that you sacrifice a mother camel on some particular day
15:52:29 <hpc> it can be anytime, day or night :P
15:52:47 <mcstar> typoclass: i thought we were to grill that camel...
15:53:08 <jix> fommil: memo will ensure that the same input value will always return the same output reference... nothing more nothing less
15:53:09 <smartviking> typoclass: That's good to hear, cause I alwaus keep my mother camels dear. :)
15:53:53 <fommil> jix: ok, do references to work eventually get filled with evaluations?
15:54:01 <dylukes> fommil: We're #7 behind #ubuntu, #archlinux, #debian, ##linux, #python and #gentoo.
15:54:07 <Xezlec> Does anybody know whether any of the pipe-like library clases let you split things up, operate on them with multiple sub-pipes, and then put them back together again?
15:54:26 <jix> fommil: yeah it'll be a thunk until it gets forced which then happens exactly once
15:54:44 <jix> but that is just lazy evaluation nothing specific to memo
15:54:48 <dylukes> Xezlec: you could do that with any of them, I imagine
15:55:17 <dylukes> it's just a matter of writing a pipe/enumeratee/adapter/conduit to do the splitting/joining.
15:55:20 <Xezlec> dylukes: I've spent the entire day trying to figure out how to do it with Control.Pipe.  Like literally many hours of just thought.
15:56:07 <Xezlec> dylukes: I might be too dumb to use this language effectively.
15:56:29 <fommil> jix: awesome, so let me get this right: my (Int -> Bool) -> [Int] function returns a "thunk", which could be cached as a reference by MemoTrie. Then later, I want to iterate the list and the "thunk" becomes a value. This means that MemoTrie will return the values in future.
15:56:33 <dylukes> Well, look at it this way. A pipe can't 'await' from multiple pipes obviously...
15:56:41 <dylukes> But what if you have a "pipe" that is parametrized by two others.
15:56:43 <Xezlec> dylukes: sure it can
15:57:01 <dylukes> And then takes its inputs and feeds them, alternating, into those two, with itself as the consumer of their results.
15:57:28 <Xezlec> dylukes: how can it perform that feeding?
15:57:50 <Xezlec> dylukes: what is the syntax?
15:58:00 <dylukes> It's not syntax, it's just more functions.
15:58:34 <Xezlec> dylukes: I've spent all day trying to figure out how to do what you are describing, and I can't do it.
15:58:42 <dylukes> one moment, I'm trying to type.
15:58:49 <smartviking> KaiSforza: on line 3, 0 is returned, but the type declaration says it wants a list of a's. If you replace 0 with [], it will run.
15:59:27 <KaiSforza> smartviking: oh wow. i hate it when i can't read.
15:59:38 <smartviking> KaiSforza: :-)
15:59:45 <dylukes> splitter p1 p2 = do { x <- await; p <- case x of …; y <- runPipe (p <+< return x); yield y}
15:59:46 <dylukes> something like that.
16:00:24 <dylukes> Let me actually check and write it out.
16:01:33 <Xezlec> dylukes: ok but that isn't really using the inner pipes, it's reinvoking them for every piece of data.
16:01:44 <dylukes> Well sure.
16:01:54 <Xezlec> dylukes: so they wouldn't be able to keep state in between.
16:02:27 <dylukes> Okay, well then you could, for instance,
16:02:40 <dylukes> make those pipes loop forever, create them at the beginning and reuse them.
16:03:11 <Xezlec> dylukes: I don't follow.
16:04:18 <dylukes> You want to "feed" the pipes, ys?
16:04:25 <Xezlec> dylukes: yes.
16:04:47 <dylukes> You could write: feed p x = (p <+< yield x)
16:04:57 <dylukes> or return? I forget, but something like that.
16:05:48 <dylukes> hm…
16:06:47 <Xezlec> dylukes: that would pass that x just once... oh, but I need to concatenate... maybe that can work somehow
16:06:58 <dylukes> but the result isn't running the pipe
16:07:00 <dylukes> it's just a new pipe.
16:07:05 <dylukes> with input added on.
16:07:50 <Xezlec> dylukes: I'm finding that pipes can't just be composed into arbitrary networks easily like infinite lists can.  Even though the community disapproves of lazy IO, I think that's the direction I'm going after all.
16:08:12 <dylukes> They can, you just need to be more explicit.
16:08:19 <dylukes> Lazy IO will bite you in the ass down the road.
16:08:29 <dylukes> For simple things it works, but it's a nightmare later.
16:08:33 <Xezlec> dylukes: how exactly?
16:09:32 * hackagebot polh-lexicon 0.1.0 - Interface to a historical dictionary of Polish  http://hackage.haskell.org/package/polh-lexicon-0.1.0 (JakubWaszczuk)
16:09:49 <Cale> Xezlec: Basically, control over resources. When you apply hGetContents to a handle, you're no longer allowed to close the handle, and basically have to rely on that happening at some point after the whole thing is read.
16:10:01 <Cale> Xezlec: (and you don't know when that is, exactly)
16:10:24 <Xezlec> Cale: obviously I wouldn't want to close it though, since that's where my data is coming from.  What's the problem?
16:10:39 <Cale> Xezlec: Let's suppose you have a lot of small files to read.
16:11:00 <Cale> Xezlec: It's easy to run out of file descriptors, as you have no idea how many of those things you have open anymore.
16:11:25 <Xezlec> Cale: OK, I guess that could be an issue if I wasn't careful.
16:11:55 <Cale> Yeah, to be honest, I'm playing devil's advocate here, as I personally hate lazy IO a whole lot less than some people :)
16:12:43 <Cale> There are some sharp corners, and places where you can just get stuck and have to go do something more clever, but I think there are also a lot of applications where it's fine
16:13:05 <Xezlec> I still can't see how to compose and operate on pipes as easily as lists though, so things aren't looking good.  In particular, I can't see how to make a data structure full of pipes that provide each piece of that structure's data.
16:13:26 <Cale> What do you mean by pipes here?
16:13:40 <Xezlec> Control.Pipe is what I've been looking at
16:14:08 <Cale> Ah, I've only glanced at that library
16:14:37 <Xezlec> Oops, I have company.  Talk to you later.
16:16:01 <mcstar> i hope the girl didnt see him chat about haskell...that'd be embarassing
16:16:50 <dylukes> Cale: you'd likely enjoy it. it's much more rigorous than conduits.
16:17:04 <Cale> dylukes: It looks like I would hate it less than conduits
16:17:13 <Cale> I'm not sure whether I'd actually like it yet :)
16:17:17 <dylukes> :P
16:17:19 <Cale> The core of it looks okay
16:17:22 <dylukes> Control.Pipe is really simplistic/useless.
16:17:40 <dylukes> Control.Frame is more useful, but hard to use because of indexed monads.
16:17:50 <dylukes> (it's type safe to a painful degree, but it's certainly workable)
16:17:59 <Cale> But there are some things in there which involve 8 type parameters which make me really start to question whether this is really necessary generalisation.
16:18:15 <dylukes> haven't seen what Gabriel has done w/ Control.Proxy yet. I guess he worked out upwards communication somehow.
16:18:20 <Cale> (/</) :: (Interact p, Monad m) => (c' -> p b' b x' x m c) -> (b' -> p a' a x' x m b) -> c' -> p a' a x' x m c
16:18:26 <Cale> It's like... seriously?
16:19:01 <Cale> It looks like maybe they're trying to do something which would be sensible with more type-level data.
16:19:33 * hackagebot secure-sockets 1.2.9.2 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.2.9.2 (ThomasDuBuisson)
16:19:44 <typoclass> that has only two constraints in the context. lame.
16:20:20 <dylukes> Cale: I personally thing it could be cleaned up with some type families.
16:20:22 <Cale> typoclass: Yeah, it would almost make more sense if it had more constraints, in a way.
16:20:44 <Cale> Because then you could see why there were so many type parameters.
16:20:51 <dylukes> `Proxy req_a resp_a req_b resp_b m r' could be `Proxy upstrm dwnstrm m r;
16:21:11 <dylukes> where upstrm/downstrm are constrained by some interfaces with related types or something.
16:21:26 <dylukes> but that's just moving the bulk elsewhere.
16:23:44 <typoclass> it could be worse. they could have taken "a b c d e f g" instead of "p b' b x' x m c"
16:24:20 <Cale> Well, that's pretty much what they do have, up to alpha-conversion
16:24:33 * hackagebot filestore 0.5.0.1 - Interface for versioning file stores.  http://hackage.haskell.org/package/filestore-0.5.0.1 (JohnMacFarlane)
16:27:29 <typoclass> Cale: yes, but i mean, i don't know what x and x' are, but at least i know they have something to do with each other, and the Monad is called m, and so forth. switching to abcdefg would erase even this basic bit of clarity
16:27:46 <Cale> yeah, I suppose so :)
16:28:00 <Cale> At least you have some hint at what the *kinds* are at least
16:28:20 <shachaf> a a' a'' a''' a'''' a''''' a''''''
16:28:49 <Cale> p :: * -> * -> * -> * -> (* -> *) -> * -> *  -- I think
16:28:57 <gienah> gwern: I'll darcs send you a patch to make unlambda build with ghc 7.6.1
16:29:10 <shachaf> Or Miranda's * ** *** **** ***** ****** *******
16:29:33 * hackagebot linearEqSolver 1.1 - Use SMT solvers to solve linear systems of equations over integers and rationals.  http://hackage.haskell.org/package/linearEqSolver-1.1 (LeventErkok)
16:30:21 <Cale> I don't know what it is, but it seems really hard for people to come up with an iteratee-like abstraction without somehow involving things with absurd-looking types.
16:30:52 <shachaf> s/n iteratee-like/ haskell/
16:31:01 <shachaf> It's what they do.
16:31:16 <Cale> Nah, there are lots of things in Haskell which have perfectly sensible types by contrast.
16:33:00 <gienah> gwern: did you want me to try to create darcs patches to make lambdabot build with ghc 7.6.1?
16:37:20 <gienah> @tell gwern: did you want me to try to create darcs patches to make lambdabot build with ghc 7.6.1?
16:37:20 <lambdabot> Consider it noted.
16:37:33 <shachaf> gienah: That won't work.
16:37:59 <gienah> shachaf: oh thanks, I thought it would
16:38:34 <shachaf> gienah: Not eith the :
16:38:53 <gienah> @tell gwern did you want me to try to create darcs patches to make lambdabot build with ghc 7.6.1?
16:38:54 <lambdabot> Consider it noted.
16:50:47 <xplat> Cale: don't think of Pipe b b' x x' m c as a type, think of Pipe b b' x x' as a monad transformer
16:51:48 <xplat> Cale: then there are just four type arguments, with two nice symmetries among them (request/response symmetry, and upstream/downstream symmetry)
17:00:51 <typoclass> xplat: that makes sense very well
17:02:51 <Cale> So perhaps this has something to do with my prejudice against non-newtype-enclosed uses of monad transformers as well :)
17:05:37 <Cale> I would be tempted to try to use TypeFamilies to bundle those b b' x x' together.
17:06:16 <gwern> gienah: is there any reason not to?
17:06:17 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:06:31 <gwern> @messages
17:06:32 <lambdabot> gienah said 29m 12s ago: did you want me to try to create darcs patches to make lambdabot build with ghc 7.6.1?
17:06:32 <lambdabot> gienah said 27m 39s ago: did you want me to try to create darcs patches to make lambdabot build with ghc 7.6.1?
17:06:33 * typoclass would be tempted to use a keyboard to transmogrify those b b' x x' into "req resp up down"
17:07:17 <Cale> typoclass: It's not like that, it's upreq upresp downreq downresp
17:07:24 <Cale> or something
17:07:30 <Cale> (some permutation of that)
17:07:58 <gienah> gwern: no, ok, thanks, I'll try to patch it
17:08:01 <typoclass> Cale: i have no clue
17:10:36 <tertl3-laptop> hi
17:11:51 <parcs`> hi
17:41:51 <lispy> hello
17:42:53 * lispy notes that levent is up to something
17:47:21 <lispy> Cale: do you want me to upgrade to ghc-7.6.1 on the linode?
17:47:30 <lispy> I think we're still back on 6 something.
17:47:40 <shachaf> lispy: lambdabot builds on 7.6?
17:47:55 <lispy> shachaf: I don't think so, but looks like people are woring on it.
17:47:59 <lispy> working*
17:49:55 <KirinDave> Just curious; how long do we expect before 7.6 is what everyone is supporting?
17:50:04 <KirinDave> I remember it took about 3-5 months for 7.4 to really be usable.
17:50:18 <stepcut> happstack should  support 7.6 now
17:51:10 * gienah has happstack, snap, yesod built with ghc 7.6.1 in the gentoo overlay
17:51:48 <geekosaur> chunks of the ecosystem did not become 7.4 compatible until a platform release including it was planned
17:51:50 <lispy> KirinDave: The HP intentionally lags behind ghc releases to give people a chance to update stuff. Once the HP updates to 7.6, I think you can expect that most libraries will update to support it. The next HP release is already underway, so not much longer.
17:52:15 <lispy> It also lags behind so that kinks in the latest release can be fixed
17:52:30 <lispy> You get a stable ghc and the ecosystem has a chance to react
17:54:21 <gienah> lispy: hmm, but I'm not sure if the HP 2012.4.0.0 will release with ghc 7.6.1 or ghc 7.4.2 (it currently has network 2.3, ancient glut, async needs a trivial dep upper bound to be loosened for ghc 7.6.1)
17:54:49 <Cale> lispy: Well, not if it's going to break lambdabot :P
17:54:52 <gienah> the package most thoroughly broken by ghc 7.6.1 is darcs
17:54:56 <lispy> Is it possible to define/type check 'fix' if all you have is the simply typed lambda calculus plus type-schemes?
17:55:26 <lispy> gienah: oh, I thought they were going for 7.6. Interesting.
17:55:31 <Cale> What's type-schemes?
17:55:38 <lispy> Cale: rank 1 types
17:55:55 <Cale> no
17:55:58 <lispy> damas-milner types
17:56:01 <gienah> lispy: I'm not sure, I thought it wasn't decided
17:56:05 <Cale> It's not possible to define fix in System F
17:56:05 <lispy> Cale: what do you need to add to write fix?
17:56:14 <Cale> Recursion
17:56:36 <Cale> Usually fix is the thing which you add
17:56:43 <Cale> in order to obtain recursion
17:57:03 <Cale> Recursive types will also work
17:57:27 <Cale> You can type check the Y combinator by sticking some isomorphisms in via a recursive newtype
17:57:31 <lispy> Ah, so the recursion we added to Haskell to make this possible is recursive of functions definitions and lets?
17:58:03 <byorgey> lispy, gienah: yeah, I think HP 2012.4.0.0 will include 7.4.2
17:58:41 * lispy was trying to understand the impact of adding type-schemes to the STLC while trying to keep it "sound for logics"
17:58:55 <gienah> byorgey: I will of course vote for ghc 7.6.1
17:59:15 <lispy> forall a. (a -> a) -> a, would be bad for soundness if you could write it once it type checks
17:59:35 * gienah probably gets a vote since I package HP for gentoo
17:59:37 <byorgey> I vote for whichever will give new Haskell users the best experience.
18:00:06 <lispy> byorgey: likewise. I just install whatever I need (piecewise even) but that's because I've deeply invested already
18:00:31 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (1:)
18:00:32 <lispy> Newbies? They are a rightfully fickle lot that needs a good impression
18:00:33 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
18:01:08 <lispy> Cale: right, but you're using the Rec type that is already recursive
18:01:11 <Cale> right
18:01:22 <lispy> great, your explanation helps me a lot
18:01:33 <Cale> lispy: But it's a display of how recursion on the type level can be brought down to recursion on the value level.
18:01:33 <ion> Ooh, so that’s what InR is used for. I saw it in shachaf’s .ghci but didn’t figure its use out immediately.
18:01:43 * lispy hope that some day he groks type theory without so many simple questions
18:01:51 <shachaf> ion: Yep. It's Curry's paradox.
18:02:05 <Cale> newtype Rec a = InR { outR :: Rec a -> a }
18:02:13 <parcs`> recursive newtypes are magic
18:02:36 <shachaf> Especially newtypes with recursion in the negative position.
18:02:52 <lispy> this positive/negative thing is something I still need to understand
18:03:00 <lispy> Know of a good intro?
18:03:17 <Cale> lispy: In classical logic, A -> B is equivalent to B or not A
18:03:41 <lispy> oh, so "negative position" refers to the "not"?
18:03:48 <Cale> In a way, yeah
18:04:25 <Cale> The negative positions in a type are those which are to the left of an odd number of ->'s
18:04:53 <shachaf> Well, negative is on the left side of ->. But negative-negative is positive.
18:04:59 <lispy> A -> B -> C, A is positive position and B is negative position?
18:05:14 <shachaf> lispy: No, the -> "tree"
18:05:22 <ion> A -> B ≡ Either B (Void -> A)?
18:05:23 <shachaf> A -> B -> C = (->) A ((->) B C)
18:05:35 <shachaf> So A and B are negative, C is positive.
18:05:36 <dmwit> ion: Only in classical logic (i.e. not Haskell).
18:05:52 <ion> ok
18:05:59 <Cale> lispy: It's important to put the parens in :)
18:06:08 <shachaf> ion: You can go from Either (Not a) b to (a -> b), but not the other way around. :-)
18:06:15 <Cale> lispy: A -> (B -> C) the B is to the right of the outermost ->
18:06:20 <lispy> dmwit: we can type the law of the excluded middle in general though :) http://okmij.org/ftp/Computation/lem.html
18:06:40 <shachaf> lispy: That's not "in general".
18:06:50 <lispy> Cale, shachaf: I see. I was hoping to clarify that :)
18:06:50 <Cale> and the A is on its left
18:07:11 <Cale> (but the other -> in in a different subexpression)
18:07:18 <lispy> shachaf: well, I lied a little. You need a monad constraint
18:07:47 <shachaf> lispy: Right. There's no ((a -> Void) -> Void) -> a
18:07:47 <dmwit> That's a different not.
18:08:03 <Cale> lispy: Another way to think of it is in terms of the communication or contract between the user of the definition and the definition of the thing itself.
18:08:35 <Cale> lispy: When you're using a value, you in some sense obtain all the things in positive position, but have to provide all the things in negative position.
18:08:50 <Cale> and the situation is reversed when defining the function
18:08:52 <shachaf> Hmm. In one sense forall is like negative position and exists is like positive position?
18:09:01 <shachaf> Well, that makes sense.
18:09:34 <lispy> shachaf: like in the article you linked about any
18:09:46 <shachaf> I linked an article?
18:10:09 <Cale> For example, imagine using withCString :: String -> (CString -> IO a) -> IO a
18:10:53 <Cale> You provide a String, and a function CString -> IO a, and it gives an IO a, and inside that function (CString -> IO a), you're provided with a CString, and have to provide an IO a.
18:12:04 <Cale> The CString is in positive position.
18:12:19 <dmwit> > undefined :: Void
18:12:21 <lambdabot>   Not in scope: type constructor or class `Void'
18:12:31 <Cale> If you're looking through an API asking yourself "how to I get a value of type X", you're looking for definitions where X occurs in positive position.
18:12:32 <scp> Can anyone tell me why debug.trace wouldn't be working in a do block?
18:12:59 <shachaf> scp: Nope.
18:13:08 <shachaf> (Unless you say a bit more about what's going wrong.)
18:13:10 <dmwit> scp: Probably you aren't evaluating it.
18:13:12 <Cale> (not just for things where X is the result of some function, or on its own, but also for things like withCString, which provide it to a function which is then consumed)
18:13:27 <Cale> "how do*"
18:13:55 <scp> hmm
18:14:08 <parcs`> scp: how are you using it?
18:14:15 <Cale> scp: Typically the only reason that Debug.Trace.trace doesn't print anything is that you're not actually evaluating the expression that you put it around.
18:14:38 <zzo38> Why can't you use pattern guards in a do-notation?
18:14:52 <lispy> shachaf: I thought you had lambdabot post this:  http://www.vex.net/~trebla/weblog/any-all-some.html
18:15:04 <Cale> zzo38: What do you mean by that?
18:15:37 <zzo38> Cale: I mean like    do { x | odd x <- [1..10]; ... }
18:15:57 <Cale> oh, so normal guards
18:16:01 <Cale> hm!
18:16:26 <Cale> well, I don't know, but you can replace that with  do x <- [1..10]; guard (odd x)
18:16:39 <Cale> It's a syntactic thing, probably
18:16:49 <Jafet> :t guard
18:16:51 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:17:05 <zzo38> Yes I know, but normally it uses fail, not guard, to fail at patterns in a do-notation?
18:17:10 <Nereid> odd x <- ... doesn't make sense as a pattern guard
18:17:15 <Cale> (at least, you'll be able to use guard in any case where it would be morally correct)
18:17:33 <Cale> Pretend that fail doesn't exist.
18:17:44 <zzo38> Something like   do { x <- [1..10]; True <- return $ odd x; ... }   would work
18:17:55 <zzo38> But I intend something like using | instead
18:18:15 <Cale> fail should never have been included in Monad in the first place, and people shouldn't use it
18:18:28 <ion> You can’t use guards in lambdas either, can you? I’d expect to see support for them in lambdas at the same time do notation gets them.
18:18:43 <zzo38> Of course in this case guard does work, but if they have do-notation with fail, why shouldn't guards work as well?
18:19:07 <Cale> Probably because the syntax is ambiguous
18:19:13 <zzo38> I agree that fail should not be included in Monad in the first place; it should be separate class, and then have a macro "do" which uses that class to fail with.
18:19:23 <Cale> Your guard ends with <-
18:19:32 <Cale> but <- is also part of the syntax of pattern guards
18:19:39 <Cale> making it hard to tell where things stop
18:19:49 <zzo38> O, OK.
18:20:10 <Jafet> @quote best.view
18:20:11 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
18:20:48 <dmwit> Has anybody written a type like type ComputableAndAlsoSometimesComparable = Either Rational CReal, with associated eq :: CAASC -> CAASC -> Maybe Bool, cmp :: CAASC -> CAASC -> Maybe Ordering, etc.?
18:21:06 <dmwit> ...and published it on Hackage?
18:21:44 <Jafet> > (pi :: CReal) == pi
18:21:45 <lambdabot>   True
18:21:58 <Jafet> > (pi :: CReal) == (pi - 1/10^100)
18:22:00 <lambdabot>   True
18:22:05 <dmwit> > (pi :: CReal) == pi + 1e-1000
18:22:07 <lambdabot>   True
18:22:08 <maukd> > (pi :: CReal) /= pi
18:22:09 <lambdabot>   False
18:22:12 <zzo38> What case will you have a <- there which make it ambiguous?
18:22:23 <zzo38> What if they use parentheses?
18:22:35 <Jafet> We hate parentheses.
18:22:43 <dmwit> > let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x -- do view patterns really start with \ ?
18:22:45 <Cale> http://www.haskell.org/haskellwiki/Pattern_guard
18:22:45 <lambdabot>   0
18:22:51 <ion> > let f (fmap succ -> a) | Just b <- a = b in f (Just 42)
18:22:53 <lambdabot>   43
18:23:07 <dmwit> ...oh
18:23:10 <dmwit> OH
18:23:23 <Jafet> You can use any function in a view pattern.
18:23:27 <dmwit> right
18:24:10 <Jafet> dmwit: why stop at Rational
18:24:20 <Jafet> Why not Q[a]
18:24:33 <dmwit> Probably because I don't know what Q[a] is.
18:24:36 <Cale> Why not all algebraic numbers? :)
18:24:37 * hackagebot bmp 1.2.3.1 - Read and write uncompressed BMP image files.  http://hackage.haskell.org/package/bmp-1.2.3.1 (BenLippmeier)
18:24:48 <zzo38> O, it is like replacing the pattern of the guards to something other than True, is that it?
18:24:53 <dmwit> I would be fine with that, if you know of a package that does it already.
18:24:55 <liyang> Except other functions declared at the same scope as the function whose argument you are matching. :(
18:25:03 <Cale> zzo38: Yeah, kinda
18:25:13 <byorgey> dmwit: what do you need it for?
18:25:15 <dmwit> > let (id -> x) = 0 in x -- zzo38
18:25:17 <lambdabot>   0
18:25:18 <dmwit> byorgey: fun =)
18:25:22 <byorgey> ah =)
18:25:35 <Cale> zzo38: It lets you make additional bindings based on previously bound things, and still fall through if the patterns don't match.
18:25:50 <Cale> based on *functions of* previously bound things
18:25:57 <ion> I see bmp gained parseBMP :: ByteString -> Either Error BMP. I think someone was asking about that here recently.
18:26:00 <dmwit> Oh, I see zzo38 is asking about something different than I thought. Apologies.
18:26:42 <zzo38> It still seem that it would work something like   do { x | y <- z <- ...    that you know the first <- is a pattern guard?
18:26:49 <zzo38> And that the second one isn't
18:26:52 <byorgey> dmwit: do you know about @package cyclotomic ?
18:27:07 <byorgey> dmwit: it's not really what you're asking for, but since it's for fun anyway...
18:27:19 <byorgey> oh, I guess you would have heard snwalck talk about it at hac phi
18:28:26 <dmwit> Oh, yeah, I forgot about that.
18:29:24 <Cale> zzo38: I think putting complicated things on the left of <- is already pretty awkward. It's not quite what you're looking for, but another option would be to use >>= and \case
18:29:42 <Cale> (with the new lambda-case syntax, which unfortunately didn't quite turn out how I wanted it to look)
18:30:15 <dmwit> Yeah, this is pretty good. Thanks for the reminder. =)
18:30:31 <Jafet> How did you want it to look?
18:30:39 <zzo38> Then fix it
18:30:57 <Cale> zzo38: Well, the community agreed on something else.
18:31:13 <maukd> make your own community!
18:31:19 <Jafet> Cale is a community
18:31:26 <maukd> mmunity?
18:31:34 <Cale> I would have liked case expressions to be "sectionable", and turn into functions when you leave the scrutinee out.
18:31:55 <Cale> i.e.  case of ...   would become  \fresh -> case fresh of ...
18:31:56 <dmwit> There's no such thing as a mmunity; however, it's provable (in intuitionistic category theory) that cococommunities are the same as communities.
18:32:03 <maukd> that would require parens
18:32:34 <Cale> maukd: where?
18:32:43 <maukd> in sections
18:32:49 <maukd> they all require surrounding parens
18:32:59 <Cale> Well, okay
18:33:06 <Cale> Maybe not in this case then :)
18:33:26 <maukd> this special case is hard
18:33:28 <zzo38> I also wanted   case of ...   to work the same thing too
18:33:38 <Cale> I don't see why it has to be hard
18:34:03 <Cale> The idea is just that if you leave the scrutinee blank, which is easily detectable because of is a keyword, then you get a function instead.
18:34:23 <Cale> So you could write things like:
18:34:27 <zzo38> Yes I agree with you it is how it should be
18:34:28 <Cale> foo >>= case of
18:34:31 <Cale>   Nothing -> ...
18:34:34 <Cale>   Just y -> ...
18:34:40 <Jafet> How is that different from \case of
18:34:44 <crdueck_> is there a parallel version of Data.Foldable.mapM_ ?
18:34:46 <Cale> \case doesn't have of
18:34:47 <Jafet> Besides RSI
18:34:53 <Jafet> O kay
18:35:02 <dmwit> I think it's mildly amusing that something as inconsequential as syntax is so controversial that people are still discussing it months after a decision has been reached (and likely will be for the next decade or two).
18:35:09 <Cale> I dunno, it just seemed weird to me to introduce a new \case keyword
18:35:29 <Jafet> Syntax isn't inconsequential
18:35:34 <Jafet> Who thinks that
18:35:35 <zzo38> Especially since there is layout syntax I think it is a problem; without layout syntax that rule is not relevant but since you have layout syntax, it mean that "of" introduces layout, "case" doesn't so it isn't very good.
18:35:39 * dmwit thinks that
18:35:50 <Cale> dmwit: Syntax is the user interface of the languaeg
18:35:53 <Cale> language*
18:36:01 <dmwit> In particular, I think the differences between the proposals for *this particular feature* are so small as to be inconsequential.
18:36:05 <zzo38> And "\case" is like two token anyways it doesn't make sense
18:36:17 <Cale> zzo38: Well, it becomes one token with that extension
18:36:22 <dmwit> crdueck_: Yes, there is. Let's see if I can remember where I saw it now...
18:36:35 <Cale> and it becomes a layout keyword
18:36:38 <Cale> but yeah, it's weird
18:36:48 <zzo38> Cale: Yes, and I think that is a strange way to do it.
18:36:53 <Jafet> crdueck: you can obtain a list and then use any old parallel mapM_.
18:37:28 <dmwit> crdueck_: http://hackage.haskell.org/packages/archive/monad-loops/0.3.0.2/doc/html/Control-Monad-Loops.html#v:forkMapM
18:37:35 <gaze__> anyone here understand the buffers used in Yi? I'm trying to understand how far a jump it is from kiselyov's paper on zippers to what's actually used in yi
18:37:39 <crdueck_> Jafet: i think that would be significantly less performant, wouldnt it?
18:37:46 <crdueck_> dmwit: thanks
18:37:49 <Jafet> Why would you think that
18:38:05 <dmwit> crdueck_: No, I don't think it should be significantly less performant.
18:38:05 <crdueck_> converting to and from Data.Map.Map to a list over and over?
18:38:10 <Jafet> Yep, dmwit linked to some old parallel mapM_.
18:38:14 <dmwit> yep
18:39:01 <rwbarton> async has a parallel mapM
18:39:10 <rwbarton> mapConcurrently
18:39:21 <Jafet> > let f [] = []; f (x:xs) = x : f xs; in foldl' (+) 0 $ iterate f [0..10^6] !! 10
18:39:25 <Cale> Since when did performant become a real word that people use?
18:39:25 <lambdabot>   mueval-core: Time limit exceeded
18:39:32 <Jafet> > let f [] = []; f (x:xs) = x : f xs; in foldl' (+) 0 $ iterate f [0..10^6] !! 10
18:39:36 <lambdabot>   500000500000
18:39:37 <zzo38> Making it up entirely myself the new way (Ibtlfmm), would be, there is no layout and all lambdas may have any number of parts by \{ ... } and if you omit the braces then it is just one, and that is how you do case; if you want Haskell's "case ... of" you can make up a macro, I think this way make sense more better isn't it?
18:39:43 <rwbarton> but not, I guess, a mapM_
18:41:12 <rwbarton> of course, concurrent mapM_ is very easy
18:41:50 <Cale> zzo38: ugh, don't remove layout. Layout is one of the nicer things in Haskell :)
18:42:02 <Jafet> http://english.stackexchange.com/questions/38945/what-is-wrong-with-the-word-performant
18:43:21 <zzo38> Cale: Perhaps then we could have a option -XLayout which supports such syntax extension, indicating which keywords (including macros) introduce layout and using colons at the end of a line if necessary to introduce layout (like Python does)
18:44:08 <dmwit> If you don't remove layout, then having \ be a block herald causes real problems with a very common Haskell idiom.
18:44:17 <dmwit> namely, >>= \
18:44:44 <Jafet> Text editors should just support perspective shearing
18:44:47 <zzo38> I know! That is why I do want to remove layout.
18:44:49 <Jafet> And be done with it
18:45:17 <zzo38> Possibly having the option to enable it but with certain syntax rules define to know that it works
18:45:20 <Cale> Support lambda, but not pattern matching in lambda.
18:45:25 <Cale> and then have case of
18:45:45 <Ralith> is ST Haskell98?
18:45:46 <dmwit> Jafet: Google isn't helping. What would "perspective shearing" mean with respect to text editors?
18:45:50 <zzo38> Well, that is another way; and with Haskell the way it is, it is how I think Haskell should be.
18:45:51 <copumpkin> Ralith: no
18:45:53 <Ralith> thought so
18:45:54 <Ralith> thanks
18:45:59 <zzo38> But I think Ibtlfmm should be the new one.
18:46:01 <copumpkin> it needs Rank2Types
18:46:12 <Jafet> Shear the text so that right-leaning code appears vertical
18:46:27 <dmwit> hahahaha
18:47:02 <dmwit> "Does your code have Too Much INDENTATION? Just rotate your screen, dummy!"
18:47:10 <dmwit> for your health
18:51:02 <gaze__> hahaha
18:51:31 <zzo38> You could have -XColonLayout and -XKeywordLayout and then you can enable both if you want to; -XKeywordLayout to make some keywords introduce layout, -XColonLayout makes a colon at the end of a line introduce layout unless { is not allowed there anyways
18:52:39 <sipa> is there some construct for (\x -> case x of ...), actually?
18:52:40 <Cale> That steals colon
18:52:47 <Cale> Which is unacceptable
18:53:00 <donri> list already stole colon from types :(
18:53:12 <Cale> sipa: yeah, in 7.6.1, there's \case ...
18:53:27 <sipa> ah, cool!
18:53:28 <donri> LANGUAGE LambdaCase
18:53:29 <donri> IIRC
18:53:51 <sipa> always felt like it needed some shorter notation
18:54:02 <Jafet> Come to think of it, I'm not sure why case expressions can only have one argument.
18:54:25 <donri> Jafet: tuples tuples all the way!
18:54:52 <sipa> Jafet: because all functions take one argument?
18:55:31 <Jafet> (\case ...) .:: (,,,)
18:55:41 <Jafet> Or is it called .:.
18:55:55 <donri> what would be the syntax for multi-argument case, without tuples, and syntactically distinguishing, Just x, from (Just) (x)?
18:56:56 <donri> i guess exactly that, the latter, as in functions. but that takes away the neat thing about case that parenthesis are less necessary
18:57:30 <zzo38> Cale: Yes, maybe, well, then just use -XKeywordLayout and you can make macros for whatever you want introducing layout where you want, would work too, it can be made without -XColonLayout so that you have -XLayout
18:57:35 <Jafet> case x, y of
18:57:45 * Jafet evils
18:57:50 <donri> heh
18:57:59 <Cale> zzo38: So where can I download your implementation of all this? :)
18:58:18 <zzo38> Cale: There is no implementation it is not finish designed yet.
18:58:22 <Jafet> From THE FUTURE
18:58:39 <donri> from __future__ import keyword_layout
19:00:04 <Jafet> {-# LANGUAGE please #-}
19:00:28 <Cale> {-# LANGUAGE gooby pls #-}
19:01:10 <liyang> {-# LANGUAGE kthxbai #-}
19:01:35 <MostAwesomeDude> Wait, normal people know about gooby? Did it escape to reddit when I wasn't looking?
19:02:02 <Jafet> Normal people? Where?
19:02:03 <maukd> yes
19:02:04 <Cale> It's not like it's new
19:02:30 <dmwit> "escape reddit" is such a weird concept
19:02:55 * maukd rolls eyes
19:03:48 <MostAwesomeDude> No, I said "escape to reddit;" it's not native to there.
19:04:11 <MostAwesomeDude> It's a 4chan thing and it still weirds me out to see 4chan memes in normal-people situations.
19:04:16 <Cale> MostAwesomeDude: Apparently there's an entire subreddit http://www.reddit.com/r/gooby
19:04:28 <MostAwesomeDude> Cale: Oh jeez.
19:04:58 <maukd> there's a 4chan subreddit
19:05:23 <Jafet> "FUUUU"
19:05:34 <MostAwesomeDude> I'm gonna go eat ice cream and watch Lifetime now. :c
19:06:26 <dmwit> iiiiiiitttttttttttt > fffffffuuuuuuuuuuuu
19:07:14 <dmwit> TV is getting a bit meta.
19:07:21 <dmwit> Make money by showing commercials.
19:07:25 <dmwit> Show commercials for other shows.
19:08:59 <jmcarthur> i'm missing commercials for other commercials
19:09:51 <xplat> dolio: a zipper for an AST is still a cosemigrip, right?
19:09:57 <johnw> "Stay tuned and don't miss the commercial just coming up!"
19:11:58 <bio44> Why "import qualified"? Isn't qualified redundant if you already have "as"? And worse of all, module names don't line up!
19:12:13 <Cale> You can have as without qualified
19:12:27 <Cale> But I agree, the qualified should be allowed on the other side.
19:12:46 <Cale> import Data.ByteString.Lazy qualified as B
19:12:54 <Cale> would be much nicer
19:12:55 <dolio> xplat: Not sure.
19:13:10 <rwbarton> can I use TH to get at the definition of a datatype whose constructors are not exported?
19:13:31 <dmwit> bio44: "as" changes the qualified name; "qualified" prevents the unqualified name
19:13:38 <dmwit> Neither one subsumes the other.
19:13:53 <bio44> hmm
19:15:01 <dmwit> If you can turn "hmm" into a concrete question, we can try to answer it for you. =)
19:15:06 <bio44> dmwit, Cale: "as" without qualified imports the module both with and without a qualified name?
19:15:16 <bio44> so impatient :)
19:15:18 <dmwit> yes
19:15:33 <bio44> interesting. is that common?
19:15:43 <dmwit> no =)
19:15:45 <Cale> bio44: It renames the module when you import it, so it imports everything normally, but you can use an abbreviation when disambiguating
19:15:48 <bio44> or in what circumstances is that useful?
19:16:07 <bio44> readability?
19:16:15 <Cale> It's useful if most of the names don't conflict anyway
19:16:57 <bio44> I see. Thanks.
19:17:34 <Cale> and you don't want to have to write qualified names everywhere
19:17:34 <Cale> but when they do conflict, you'd prefer to write something shorter than the full module name
19:17:34 <Cale> But usually people end up just doing:
19:17:34 <Cale> import qualified Data.Set as S
19:17:34 <Cale> import Data.Set (Set, ... other stuff ...)
19:18:43 <dolio> xplat: Did you mean cosemigroup?
19:19:02 <dolio> Also, how are cosemigroups less trivial than comonoids for this question?
19:19:33 <bio44> dmwit, Cale: Thanks. That doesn't quite solve my OCD problems, but I learned something valuable at least!
19:19:41 <dolio> It's clear that they're less obviously trivial, but I'm not sure what actions we can have besides \x -> (x, x)
19:25:20 <dolio> left split . split ~ right split . split, so I guess we also have \x -> (y, x) and \x -> (x, y) as valid actions, where y is some arbitrary other element.
19:25:45 <xplat> Cale: thank you, your discussion of negative/positive position earlier clarified for me very well how 'strictly positive' is stronger than positive
19:26:10 <dolio> Because ((y, y), x) ~ (y, (y, x)) and so on.
19:26:12 <Cale> xplat: no problem
19:26:56 <xplat> a strictly positive X means you can write code that definitely will receive an X (barring nontermination), whereas positive just means you can write code that will receive an X if it runs at all
19:27:20 <xplat> which also explains why the difference is less important in turing-complete languages
19:30:28 <bio44> One more newbie question about syntax: Is dealing with maps via Data.map something you just get used to? Needing to import, then fromList et al... Isn't this bulky for such a common data structure?
19:30:37 <pordan30> There are several containers interfaces available, most using functional dependencies. There are also classes like Functor, Foldable, and Traversable that generalize some container operations. I'm wondering what the best interface to generic containers - say maps and sets - might be. I see that there is an algebra package supporting lattices of different kinds, but that has more generality than is necessary.
19:32:39 <jmcarthur> bio44: i find that i actually tend to use Data.Map functions rarely, having wrapped them in higher level abstractions by the time they would be used more frequently
19:32:40 <pordan30> For instance, is the functional dependencies approach the best way to capture something like the following: for all types a, if an ordering is provable on a, then a containers interface is constructible? This seems to the be approach adapted to associated types in the containers api
19:33:06 <xplat> Jafet: what is perspective shearing?
19:36:03 <dmwit> xplat: 21:45 < Jafet> Shear the text so that right-leaning code appears vertical
19:36:51 <xplat> dolio: i mean a cosemigroup in the category of endofunctors (wtbd?)
19:37:18 <dolio> xplat: Then no, for the same, obvious reason.
19:37:22 <dolio> It's not an endofunctor at all.
19:37:33 <dolio> It's just a type.
19:37:36 <bio44> jmcarthur: Thanks. So maybe I'm still thinking in other languages too much? I'll, think, about that
19:38:28 <xplat> dolio: ah, right, well, i mean if you generalize it on (some arbitrary subset of) nodes with the same type
19:39:02 <xplat> *with a constructor argument of the same type
19:39:20 <dolio> Why would I do that?
19:39:24 <dolio> Are you going to do that for all types?
19:39:58 <xplat> just how you could generalize String to List, or ColoredString to ColoredList
19:40:01 <dolio> data Nat a = Wat a | Zero | Suc a
19:40:13 <dolio> Er, Suc (Nat a).
19:41:37 <dolio> The syntax tree was just an example. The point was that there is a definition of zippers which works for all recursive types.
19:41:38 <xplat> or XMLGrove to XMLGroveWithArbitraryThingsInsteadOfCDATA
19:41:50 <dolio> And they're not comonads.
19:41:56 <dolio> Or endofunctors, generally.
19:42:02 <xplat> well, yeah
19:42:34 <xplat> but there's probably a generalization of comonad that follows along
19:43:11 <xplat> just like there's RMonads that allow Set, or probably a monadesque thing that even allows Strings
19:44:07 <xplat> replacing all your Vars with some arbitrary thingy might be useful anyway when you go stomping around making analysis passes, but it's also a step along the road of generalizations
19:46:06 <xplat> (a stepping stone from comonads to a concept that describes any zipper)
19:46:15 <Cale> bio44: I don't know, it might be nice to have neater syntax for Data.Map values, though that would make Data.Map somehow more special than other finite map container libraries. While it is quite popular and useful, I'm not sure it's so much more popular that it deserves its own syntax?
19:47:18 <Cale> bio44: People have been thinking about abstractions for Map-like container libraries for a while, and if anyone could agree on one of those, then having syntax for such an abstraction might be nice.
19:47:56 <Cale> But the best of those tend to involve type system features which didn't exist at the time that most of the Haskell syntax was fleshed out.
19:48:13 <xplat> Cale: a nice literal syntax could work even with just a typeclassed fromList
19:48:29 <Cale> Indeed, that's true.
19:49:05 <Cale> But yeah, we're talking about saving 8 or 10 characters not-so-often.
19:49:21 <bio44> Cale: Thanks. Well, that's what I was wondering. In other languages, it gets its own syntax. In Haskell, you got syntax for Lists and tuples, but assoc lists seem to get less support than maps. It makes me wonder what people do with their choice of data structors...
19:49:42 <Xezlec> OK, my friend is gone now.  I had to help him with his GRE prep.
19:49:50 <Cale> bio44: Data.Map is actually fairly popular, it's just we don't really use any special syntax for it
19:50:04 <xplat> bio44: assoc lists actually don't get used as much in haskell as in other languages
19:50:34 <xplat> bio44: er, associative dictionaries.  whatever the general term is
19:50:41 <Cale> Association lists are really only good if you're not accessing them randomly.
19:50:52 <Cale> (and are iterating over the whole bunch of them consistently)
19:51:08 <Cale> Actually, that's true of lists in general
19:51:11 <xplat> because in a lot of languages they're used as a substitute for records, and haskell prefers to use defined datatypes for that
19:51:17 <Cale> Lists are loops that haven't happened yet :)
19:51:30 <shachaf> Cale: Forced lists are loops that have happened yet!
19:51:37 <Cale> shachaf: :D
19:51:39 <Xezlec> bio44: sorry to just jump in here, but you can always define your own operators if you want a quick syntax to define and manipulate maps.
19:52:00 <Cale> shachaf: But even once the list is constructed, you'll have to consume it again then.
19:52:01 <xplat> shachaf: forced lists are loops that have happened and might happen again
19:52:15 <shachaf> > let (==>) = (,); m = M.fromList in m['a' ==> 1, 'b' ==> 2]
19:52:17 <lambdabot>   fromList [('a',1),('b',2)]
19:52:32 <shachaf> Look at that, special-purpose syntax.
19:52:37 <bio44> Xezlec: No problem :) Neat idea
19:52:41 <xplat> (otherwise they'll become garbage as they're forced, and garbage doesn't count)
19:53:09 <Xezlec> bio44: and there's no shame in doing that.  it might even catch on ;)
19:53:59 <Nereid> I wish we were allowed to put a trailing comma at the end of a list/record, like [ 1, 2, 3, ]
19:54:16 <Nereid> (or module export list, or ...)
19:55:02 <Xezlec> Nereid: you mean to make the text editing easier?
19:55:08 <xplat> Nereid: yes, it's annoying to have to distinguish the last occurrence of something syntactically when it is not distinguished semantically
19:55:15 <Nereid> Xezlec: a bit of that, yeah.
19:55:24 <shachaf> Nereid: Just use Haskell-style formatting.
19:55:32 <Nereid> shachaf: ???
19:55:38 <Nereid> xplat: exactly.
19:55:38 <bio44> shachaf: Ha. Thanks. I'll geto to work on the shachaf Data.Map DSL/syntax
19:55:40 <Nereid> Lua lets you do this.
19:55:44 <Xezlec> [ something
19:55:46 <Xezlec> , next thing
19:55:49 <Xezlec> ]
19:55:52 <Nereid> that's gross.
19:55:56 <xplat> (oddly, you do *not* have to syntactically distinguish the last line in a do {} even though it *is* distinguished semantically!)
19:55:56 <shachaf> bio44: Ooh, you could use do-notation + Writer to make it all curlyy.
19:56:16 <MostAwesomeDude> Nereid: Haskell is not Python nor Lua.
19:56:24 <MostAwesomeDude> Er, *neither?
19:56:30 <Nereid> MostAwesomeDude: I never suggested it was.
19:56:44 <Nereid> I was merely using lua as an example of a lanaguage that lets you do this.
19:56:55 <bio44> shachaf: Go ahead, keep piling the work on...!
19:57:10 <xplat> Xezlec: i've done that, but not only is it gross, it just moves the unnecessary distinction from the last element to the first
19:57:23 <bio44> Nereid: MostAwesomeDude's words are deeper than they seem! Meditate on them...
19:57:37 <Nereid> what
19:57:40 <Xezlec> xplat: I know, but how often do you append to the beginning of a list?
19:57:41 <shachaf> > let { x =: y = tell [(x,y)]; m = M.fromList . execWriter } in m $ do { 'a' =: 1; 'b' =: 2 }
19:57:43 <lambdabot>   fromList [('a',1),('b',2)]
19:57:47 <MostAwesomeDude> bio44: Wat.
19:58:11 <bio44> Wat.... Wat.... Of course! :)
19:58:11 <Nereid> shachaf: cute.
19:58:48 <Xezlec> Nereid, xplat: how about this:
19:58:49 <Xezlec> [
19:59:03 <shachaf> That's a good style, Xezlec.
19:59:05 <Nereid> [ is nice.
19:59:06 <Xezlec> oh wait nm
19:59:08 <Xezlec> lol
19:59:13 <bio44> That's deep
19:59:16 <shachaf> How about this variation:
19:59:17 <shachaf> [
19:59:26 <shachaf> ('a',1),('b',2)]
19:59:34 <xplat> [
19:59:36 <xplat>   a
19:59:38 <xplat> ,
19:59:40 <xplat>   b
19:59:42 <xplat> ]
19:59:50 <shachaf>   [
19:59:52 <shachaf>     a
19:59:54 <shachaf> ,
19:59:57 <shachaf>     b
19:59:57 <shachaf> ]
20:00:03 <Nereid> now that's just way too many lines.
20:00:04 <bio44> It's like life... [ .... it begins, but, does it really end? Yes, of course. But not like how you expected it..
20:00:04 <dmwit> Is this a competition for the worst style or something?
20:00:05 <shachaf> Oops, that should be "  ]"
20:00:22 <Xezlec> You could use a preprocessor that removes the last comma.  Not hard at all.
20:00:24 <rwbarton> a : b : []
20:00:26 <bio44> dmwit: haskell obfuscation
20:00:27 <shachaf> dmwit: It's a competition for how long you can spam #haskell before getting kicked.
20:00:58 <Xezlec> bio44: life ends with a "missing ]" error?
20:01:08 <rwbarton> doesn't it, in a way
20:01:17 <rwbarton> (no)
20:01:19 <bio44> Xezlec: You never see it coming
20:01:30 <xplat> Xezlec: when life ends, you might not get the closure you were looking for
20:01:38 <Nereid> > let {m = execWriter; e x = tell [x]} in do { e 1; e 2; e 3; }
20:01:39 <xplat> the things you started are left unfinished
20:01:39 <lambdabot>   No instance for (GHC.Show.Show (m ()))
20:01:39 <lambdabot>    arising from a use of `M672385198...
20:01:44 <shachaf> rwbarton's Law of #haskell Questions
20:01:46 <Nereid> > let {m = execWriter; e x = tell [x]} in m $ do { e 1; e 2; e 3; }
20:01:47 <lambdabot>   [1,2,3]
20:01:49 * lpvb kicks shachaf figuratively.
20:01:49 <Nereid> there !
20:01:56 <Xezlec> xplat: can I at least have objects?  With them I can simulate closures.
20:01:58 <Nereid> (doesn't help with records or modules though)
20:02:29 <dmwit> Wait, you're allowed to have a trailing semicolon?
20:02:34 <dmwit> Just when you think you know a gal...
20:02:40 * Xezlec makes a note to put a ] on his tombstone.
20:02:50 <bio44> xplat: Wise words.
20:02:57 <geekosaur> interlisper?
20:03:39 <Nereid> ok, practical question:
20:03:51 <Nereid> would changing the syntax to allow a trailing comma affect any existing code?
20:04:06 <rwbarton> there's TupleSections
20:04:08 <shachaf> Nereid: Tuples sections would be affected.
20:04:13 <shachaf> s/s//
20:04:22 <Nereid> ok. what if we don't do it for tuples?
20:04:31 <xplat> afaik, it wouldn't affect any current code that compiles
20:04:36 <shachaf> Come on, only bad people allow trailing ,
20:04:38 <xplat> rwbarton: this is specifically for lists
20:04:39 <dmwit> I would be happy to give up TupleSections for trailing commas.
20:04:43 <rwbarton> was it
20:04:45 <Nereid> lists and records and modules
20:05:02 <xplat> however, changing haskell-src-exts to match could cause real problems
20:05:32 <bio44> Nereid: Or, get rid of all commas.... think about it.
20:05:49 <Nereid> what would [a b] mean?
20:06:05 <shachaf> syntax error
20:06:12 <Xezlec> apply a to b
20:06:17 <xplat> a list of a and b
20:06:28 <Nereid> wow, 3 different answers.
20:06:30 <xplat> if you want the current [a b], write [a$b] :)
20:06:38 <Nereid> gross
20:06:45 <shachaf> xplat: Not to be confused with [a $ b]
20:07:00 <Nereid> what about [a-b]?
20:07:04 <ion> xplat: *shiver*
20:07:29 <rwbarton> this is why i just assume that anyone suggesting syntax changes is being facetious
20:07:42 <Nereid> I am 100% serious.
20:07:50 <lpvb> a minus b?
20:08:02 <Nereid> why not a list of a and -b?
20:08:06 <rwbarton> Nereid: stop intruding on my fantasy world
20:08:14 <xplat> i was only being facetious in response to bio44's latest suggestion
20:08:19 <Nereid> :p
20:08:31 <rwbarton> fortunately syntax never changes and it's all good
20:09:10 <Xezlec> So if I may once again bring up my eternal problem figuring out the Right Way to move data around...
20:09:12 <Nereid> is it just me or is darcs sloooooooow?
20:09:18 <Nereid> or is it code.haskell.org
20:09:22 <Clint> darcs is always slow
20:10:30 <xplat> rwbarton: the problem is that if syntax changes, it breaks existing code, so it must be bad.  if it doesn't change, it doesn't improve in response to experience, so it must be bad.  so assuming the law of excluded middle, all syntax is bad.
20:11:07 <Xezlec> I'm trying to find an example of how one can use pipes/enumerators/whatever-you're-supposed-to-use to pipe data around in as arbitrary a way as you can move data around, i.e. being able to split into two pipes and then merge results again into one pipe.
20:11:14 <shachaf> xplat: Why would you assume that?
20:11:24 <Nereid> haha shachaf.
20:11:30 <xplat> rwbarton: well, i don't.  it's the whole reason i'm a constructivist :)
20:11:31 <dmwit> "it doesn't improve in response to experience, so it must be bad" is a logical fallacy
20:11:39 <xplat> shachaf: ^
20:11:48 <dmwit> Syntax can be designed by people who already have experience.
20:11:57 <Xezlec> dmwit: the real world changes
20:12:06 <dmwit> Not in really significant ways.
20:12:14 <dmwit> Or maybe I'm just getting cynical in my old age.
20:12:28 <pordan30> how do you turn off line highlighting of checked code in haskell mode in emacs?
20:13:03 <Cale> Xezlec: Well, what are you trying to do?
20:13:14 <Xezlec> dmwit: you wouldn't mind what historical period you were dropped into then?  still think any programming language will be relevant after the popularization of artificial intelligence?
20:13:33 <Cale> Xezlec: I've been programming in Haskell for 11 years, and I've never yet really had a good reason to use those libraries.
20:13:48 <Cale> (I'm sure some people have great reasons)
20:13:51 <xplat> dmwit: okay, syntax can be designed in response to experience, so either the semantics is not innovative, therefore bad, and the syntax is bad because it does not allow access to good semantics, or the semantics is innovative (so possibly good) and the syntax is designed from inapplicable experience, therefore bad.
20:14:50 <dmwit> The semantics of Haskell is almost 85 years old.
20:15:05 <dmwit> "not innovative therefore bad" is just another logical fallacy of exactly the same kind.
20:15:08 <bio44> pordan30: also try #emacs if no one here knows
20:15:37 <xplat> dmwit: only the subset without algebraic datatypes or type polymorphism
20:16:12 <Xezlec> Cale: OK, here are my choices: 1. store my data as a list of occurrences of this big, complicated structure, just like C.  This is very disappointing.  2. Use just one big complicated structure containing infinite lists.  Potentially simplifies code immensely.  3. Use pipes somehow.
20:16:15 <xplat> dmwit: which is a pretty impoverished subset of haskell
20:16:22 <Cale> dmwit: Whoa, whoa, I'm not sure I agree.
20:16:28 <Xezlec> pordan30: try customizations
20:16:33 <Cale> Where do you get the 85 years old number?
20:17:13 <dmwit> I got it from \ calculus first being proposed in the 1930s. Naturally I understand that the lambda calculus doesn't cover everything Haskell does.
20:17:14 <xplat> dmwit: and 'not innovative therefore bad' comes also from the fact that we are still in the infancy of computing
20:17:40 <KirinDave> I wish I trusted Criterion on this box.
20:17:53 <Cale> dmwit: Yeah, you're missing even basic type theory if you count from then
20:18:04 <dmwit> Type theory is not part of the semantics.
20:18:05 <KirinDave> Could someone run a piece of code for me and give me the output?
20:18:07 <Cale> Let alone all the other cool stuff
20:18:11 <pordan30> bio44, xezlec: thanks; it doesn't seem to appear in the (visible) customization options, though.
20:18:22 <KirinDave> Preferably not on a macosx box running 32-bit haskell where timing information seems unreliable?
20:18:24 <xplat> dmwit: dynamic semantics is not the only semantics of haskell
20:18:29 <Cale> It's pretty safe to say that Church didn't know anything about GADTs.
20:18:51 <xplat> dmwit: anyway you can't even define the dynamic semantics without types because of typeclasses and unboxed types
20:18:59 <Cale> Or software transactional memory
20:19:03 <dmwit> Types are about reducing the number of programs you even bother stuffing through the semantics, not about changing the semantics.
20:19:13 <Cale> Or parallelism annotation
20:19:14 <Cale> s
20:19:35 <Cale> Or stream fusion
20:19:46 <KirinDave> Or maybe I am using Criterion Wrong.
20:19:48 <KirinDave> https://gist.github.com/dc270c1b45e585ec3ae6
20:19:54 <KirinDave> Could someone run that?
20:20:02 <KirinDave> You may need to cabal install arithmoi first.
20:20:09 <KirinDave> I just want to confirm my numbers.
20:20:13 <Cale> Xezlec: I think I'd need to know more about the problem that your code solves to be able to suggest much
20:20:22 <xplat> dmwit: the semantics of 2000000000 + 2000000000 :: Integer are different from 2000000000 + 2000000000 :: Int32
20:20:34 <KirinDave> Plleeeeeez?
20:20:43 <shachaf> xplat: The latter is undefined behavior or something, isn't it?
20:20:58 <shachaf> Or is that just Int?
20:21:03 <xplat> shachaf: for Int they are, for specifically Int32 they are not
20:21:09 <shachaf> Ah, makes sense.
20:21:23 <shachaf> KirinDave: I don't have Mac OS X or a 32-bit GHC.
20:21:33 <shachaf> So there.
20:21:36 <KirinDave> shachaf: That's exactly what I want.
20:21:39 <KirinDave> Not OSX
20:21:45 <Cale> KirinDave: Installing arithmoi, I was meaning to do that anyway
20:21:45 <KirinDave> Or 32-bit ghc.
20:21:50 <Xezlec> Cale: I'm writing a file format library for a format that stores a set of "fields", where each field can be a structure array or a multidimensional array of one of many different types, and structures also contain fields, and this same deep structure can be repeated over and over in a stream to indicate time-varying data, etc.
20:21:51 <KirinDave> Ty.
20:22:00 <KirinDave> Basically it says the IO benchmark is faster than the whnf one.
20:22:07 <KirinDave> Oh btw, -O2 please
20:22:39 <xplat> Xezlec: so your 'time-varying data' is just lists?
20:22:43 <dmwit> KirinDave: That second one is going to be sharing the computation of "dimensionPassingThreshold" across all runs, making it much faster, no?
20:22:54 <KirinDave> dmwit: Is it?
20:23:00 <KirinDave> dmwit: So don't use let?
20:23:08 <Xezlec> xplat: infinite lists if using lazy IO, yes, that's the elegant approach
20:23:14 <Nereid> whoa.
20:23:18 <dmwit> You may have to do more than just "not use let", what with GHC's optimizer.
20:23:19 <Nereid> you *can* put a trailing comma in a module export list.
20:23:26 <xplat> KirinDave: or use a dummy argument of () maybe
20:23:35 <Xezlec> xplat: where "elegant" in this case is threatened only by the use of lazy IO
20:23:40 <dmwit> Why not use a real argument of 0.10 instead of a dummy argument?
20:23:45 <KirinDave> xplat: ?
20:24:14 <KirinDave> The numbers just seem super low
20:24:23 <KirinDave> For me it's "mean: 379.6532 us, lb 375.5095 us, ub 384.5956 us,"
20:24:28 <KirinDave> But if I time it' it's 200ms.
20:24:36 <KirinDave> So startup time like woah, I guess?
20:24:37 <Nereid> exports     ->     ( export1 , ... , exportn [ , ] )     (n>=0)
20:24:42 <Nereid> see, why don't we have this for lists or records.
20:25:06 <Nereid> haha, you can write module Blah (,) where ...
20:25:24 <Xezlec> Nereid: I support your crusade on the grounds that it makes Haskell more C-like. ;)
20:25:36 <Nereid> no, not more C-like.
20:25:43 <xplat> Xezlec: is this file format defined publically anywhere (even if your code using it isn't)?
20:25:52 <Xezlec> :)
20:25:58 <Xezlec> xplat: no
20:26:00 <xplat> more Lua-like
20:26:07 <Nereid> I just want to be able to treat all elements of a list/record uniformly, including the last.
20:26:18 <rwbarton> what is unlikely to happen when I unsafeCoerce between two data types which differ only in whether some fields are marked with !(...)? suppose I know they are not unpacked
20:26:32 <Xezlec> Nereid: I was just humorously pointing out that C does allow that for arrays.
20:26:38 <Nereid> it does?
20:26:50 <Xezlec> Yes.  int a[] = { 1, 2, 3, };
20:26:53 <shachaf> rwbarton: Lots of things are unlikely to happen.
20:27:04 <rwbarton> haha how did I type that
20:27:04 <Nereid> whoa.
20:27:10 <Nereid> Xezlec: I didn't know that.
20:27:24 <xplat> Xezlec: it's going to be hard for you to get useful advice about processing a file format whose spec people can't see
20:27:31 <shachaf> rwbarton: I'm under the vague impression that if they're not unpacked, they're represented the exact same way, i.e. the constructor is made strict and nothing else.
20:27:40 <xplat> Xezlec: at least, unless your descriptions of it get a lot less ambiguous
20:27:42 <rwbarton> right
20:28:02 <rwbarton> but I wonder whether ghc might generate code that assumes that the things pointed to by these fields are never thunks
20:28:05 <xplat> Xezlec: there's a lot left unsaid about what can be nested in what and what that means
20:28:24 <Xezlec> xplat: Well then let's keep the question simple: how does one make pipes split and merge again.
20:28:46 <Xezlec> Nereid: Happy to inform.
20:28:47 <Cale> KirinDave: use whnfIO
20:28:48 <shachaf> I'm vaguely under the impression that it doesn't.
20:29:00 <shachaf> I guess there are some things that it could do, though?
20:29:01 <Cale> errr
20:29:19 <xplat> Xezlec: there are different ways to split and merge pipes so it depends which ones you mean
20:29:21 <dmwit> I think just un-let'ing it is *probably* enough.
20:29:22 <shachaf> Like assume a tagged pointer if there're sufficiently few constructors, or something like that?
20:29:25 <pordan30> "Constraint" doesn't register as a valid kind in ghc 7.4.1 using constraintkinds when indexing a class. It should, no?
20:29:26 <rwbarton> I am also vaguely under that impression, but it seems like it should use this info somehow
20:29:28 <KirinDave> Cale: Not sure I know what you mean
20:29:30 <shachaf> rwbarton: What are you doing that for, anyway?
20:29:36 <shachaf> pordan30: Did you import GHC.Whatever?
20:29:36 <dmwit> But I wasn't 100% sure, so I threw some FUD in.
20:29:43 <shachaf> .Exts or .Prim or something.
20:29:44 <Xezlec> xplat: I've been looking at Control.Pipe
20:29:47 <rwbarton> say I want to produce a Data.Map lazily
20:29:51 <rwbarton> a Data.Map.Map
20:29:51 <shachaf> rwbarton: What would it use it for?
20:29:51 <KirinDave> Cale: Btw for the copypaste: ghc -O2 -funbox-strict-fields -main-is FiftyEight FiftyEight.hs
20:29:53 <dmwit> KirinDave: (My last two messages are aimed at you, and Cale by association.)
20:29:57 <rwbarton> hmm
20:30:10 <KirinDave> dmwit: Ah, it seems to not be
20:30:12 <KirinDave> I think what I gotta do is
20:30:25 <shachaf> you gotta do what you gotta do
20:30:32 <rwbarton> well I don't know that much about the details of ghc compiles things but what if I had a list type data SList a = Nil | Cons !a (SList a)
20:30:38 <rwbarton> and I want to write sum on SList Int
20:30:47 <rwbarton> seems like ghc could generate better code
20:30:58 <xplat> Xezlec: for example, merging two streams under the control of the consumer, or to some extent splitting streams under the control of the producer, can be implemented using Pipe to transform another Pipe type
20:31:00 <pordan30> shachaf: no, but that seems to work. it's not in the documentation, for anyone interested
20:31:04 <shachaf> https://lh4.googleusercontent.com/-EghSG52Sy4E/Tk8PKrS-_OI/AAAAAAAAAj8/VDt05JXQN3o/s808/You-Gotta-Python.png
20:31:11 <KirinDave> whnfIO (\x -> return (dimensionPassingThreshold 0.10)) ()
20:31:22 <Xezlec> xplat: I know that, but splitting and then re-merging seems much harder.
20:31:28 <xplat> like Pipe a c (Pipe b ()) m r
20:31:33 <shachaf> rwbarton: What sort of better code?
20:31:41 <dmwit> KirinDave: ...why not use 0.10 as your parameter, though?
20:31:50 <rwbarton> well if I want to sum a normal [Int]
20:31:55 <KirinDave> dmwit: Fair
20:32:00 <dmwit> Also, I don't see how whnfIO is going to help at all.
20:32:06 <Xezlec> xplat: The problem is that I can't figure out how you pipe both outputs to both inputs in the same pipeline.
20:32:08 <rwbarton> I imagine it basically is going through this linked list, and looking at each "Int", and checking whether it is a thunk or not and evaluating it if it is
20:32:10 <KirinDave> It doesn't matter
20:32:14 <bio44>  I've gotten used to git's cheap branching. What's the Darcs way?
20:32:16 <rwbarton> then adding to some accumulator
20:32:21 <rwbarton> is that wildly inaccurate?
20:32:22 <KirinDave> I just want some sort of verification I am not coming up with totally absurd numbers
20:32:28 <KirinDave> Because it seems odd that I measure 0.2 sec
20:32:41 <KirinDave> But then come up with WAY less than that on the actual criterion benchmark
20:32:42 <rwbarton> of course the "next" links in the linked list may be thunks too, but that is the same in both cases so let's disregard that
20:32:42 <dmwit> Do your two benchmarks differ by a lot?
20:32:47 <KirinDave> Oh yeah
20:32:48 <shachaf> rwbarton: Well, I don't know about GHC specifically, but with STG in general I think it just has a code pointer that it jumps to.
20:32:55 <KirinDave> But also my "time ./FiftyEight"
20:32:57 <rwbarton> oh
20:33:02 <shachaf> If it's unevaluated, the code pointer evaluates the value and replaces the code pointer in the "thunk".
20:33:06 <rwbarton> and that pointer gets updated to a
20:33:08 <rwbarton> hmm
20:33:10 <dmwit> KirinDave: ...you do know criterion is running each benchmark a lot of times, right?
20:33:14 <KirinDave> yes
20:33:22 <rwbarton> to what? a pointer to code that returns the known value?
20:33:25 <shachaf> Yes.
20:33:31 <xplat> Xezlec: there's i believe an adapter you can write from Pipe a b (Pipe () c) m r to Pipe a (Either b c) m r
20:33:33 <shachaf> Well, not necessarily "returns" -- I think it's more CPSy than that.
20:33:46 <rwbarton> fair enugh
20:33:48 <shachaf> As in you push arguments onto the stack and then jump to the code pointer.
20:34:05 <shachaf> rwbarton: On the other hand pointer tagging for sum types might be one place where it could use this assumption.
20:34:19 * dmwit wonders what happens if GHC does a strictness analysis and then you unsafeCoerce out from under its feet
20:34:26 <shachaf> I'd be a bit surprised if it did that but I don't know much about the details of it.
20:34:52 <rwbarton> I think maybe my sanest solution might just be to duplicate Data.Map
20:34:57 <xplat> Xezlec: which represents the fact that if you have two pneumatic tubes connecting two desks, only one desk can be in control which tube the next parcel goes through
20:35:02 <shachaf> rwbarton: What are you actually doing here?
20:35:29 <rwbarton> I'm (planning on) writing a library to convert Haskell data types to packed formats in a way that allows for efficient random access
20:35:31 <xplat> Xezlec: the other desk just has to adapt to the desk that's in control
20:35:46 <rwbarton> so that you don't have huge extra constant factors in memory use
20:36:06 <shachaf> rwbarton: Oh, you're generating a "spine-lazy" Data.Map and hoping to use to unsafeCoerce it to the regular one?
20:36:10 <rwbarton> yes
20:36:11 <rwbarton> exactly
20:36:28 <shachaf> Hmm...
20:36:33 <rwbarton> that's what I thought too
20:36:34 <shachaf> Well, Data.Map has an unpacked size.
20:36:36 <tertl4> anyone tried the halvm?
20:36:39 <rwbarton> yeah that's fine
20:36:48 <shachaf> Oh, you know the size, you just don't want to use the memory.
20:36:53 <rwbarton> I don't mind unpacking the size, I ... yeah
20:36:58 <rwbarton> I just don't want to unpack the whole spine
20:37:21 <shachaf> Sounds sneaky.
20:37:52 <rwbarton> I thought it was a cute use of lazy evaluation
20:37:53 <Nereid> well
20:38:05 <Nereid> it was pretty trivial to modify haskell-src-exts to accept trailing commas in lists
20:38:07 <Xezlec> xplat: I'm talking about just sort of general wiring stuff around.  For example, with plain old data values, I can easily do \ x -> binaryFunc (f x) (g x), and hence I know I can do stuff like that with infinite lists.  But I'm not clear on whether pipes can do those kinds of operations.
20:38:08 <xplat> Xezlec: you have a similar thing going on with lazy IO, but with lazy IO essentially the consumer is always in control, but the things the producer produces are automatically buffered to let it think it's in control too
20:38:40 <shachaf> rwbarton: It is. You should do it and tell me whether it works! :-)
20:38:45 <dmwit> KirinDave: Anyway, for any sane Show instance, it's pretty clear that printing the result of a computation can't be significantly faster than running the computation and not printing the result.
20:38:46 <xplat> Xezlec: which works fine until it produces 10GB of stuff before the thing it was actually asked for and your program gets killed for OOM
20:38:55 <Cale> KirinDave: yeah, it's really tricky getting GHC to not lift the constant out
20:38:58 <dmwit> So if your second thing is getting much lower times, it's not right.
20:39:04 <rwbarton> I already implemented this for a specific type for a project, then I had the idea that it could be done generically
20:39:04 <dmwit> And yes, I don't know how to fix it.
20:39:20 <shachaf> Do you also want to "GC" the unpacked spine if it's not used?
20:39:29 * shachaf isn't sure how that'd work.
20:39:29 <rwbarton> right
20:39:43 <Xezlec> xplat: so you're saying pipes have problems too.
20:39:57 <rwbarton> so for simplicity let's suppose you have some huge constant data structure you want in your program
20:39:58 <Xezlec> xplat: oh nm
20:40:12 <rwbarton> somehow, you first get the packed form of this data structure in a file
20:40:29 <rwbarton> read it in as a ByteString (or use bytestring-mmap if you are cool)
20:40:30 <Xezlec> xplat: you were talking about Lazy IO.  But hopefully you saw my explanation above.
20:40:42 * shachaf wonders whether mmap + GHC's IO manager is actually cool.
20:40:45 <shachaf> I suspect not.
20:40:45 <rwbarton> then every time you want to do a query, "decode" it
20:40:53 <xplat> Xezlec: no, the problem i've described is for lazy IO.  pipes just force you to be more explicit about when things are done and what buffering you do.  but for non-toy problems this can really be a Good Thing.
20:41:13 <KirinDave> Cale: Just your numbers for the bench would be swell.
20:41:16 <KirinDave> I am just surprised
20:41:32 <rwbarton> throw away the decoded structure so that it doesn't stick around in memory
20:41:35 <KirinDave> It's like an order of magnitude for startup time, I guess.
20:41:36 <rwbarton> but keep the ByteString
20:41:48 <rwbarton> this probably involves a little being careful with ghc and sharing
20:41:54 <Xezlec> xplat: so you didn't see my explanation above maybe?  To me it seems pipes are vastly, vastly, vastly less powerful, and most things I would want to do with them literally can't be done.  So it's a blind alley for me.
20:41:59 <rwbarton> I think I saw a library for this on hackage though (making sure a value is not shared)
20:42:21 <xplat> shachaf: you can do mmap on a stable pointer i think, but not a plain GC'd pointer
20:42:28 <dmwit> KirinDave: I think you are misinterpreting what we are saying.
20:42:29 <Xezlec> xplat: but if there is a way, I wanna know about it.
20:42:38 <shachaf> xplat: I just meant blocking capabilities on page faults.
20:42:47 <Cale> KirinDave: There we go, I found a way: move the 0.10 out into an IORef and use readIORef
20:42:53 <rwbarton> ah, interesting
20:43:09 <Cale> KirinDave: Then GHC can't prove it's constant and stops lifting the whole computation to the top level :)
20:43:27 <rwbarton> that does seem like it would be a downside, yes
20:43:27 <shachaf> Or just {-# NOINLINE #-} it?
20:43:38 <xplat> shachaf: ah, yeah, that could be a problem compared to other methods of IO, but then the same thing can happen if you read a file into memory strictly instead of mmaping it, so it's really only a problem in comparison to streaming
20:44:12 <Cale> I get the same results with IO and no IO that way (I also replaced print with Control.Exception.evaluate to be less obnoxious)
20:44:21 <shachaf> I guess that's true.
20:44:33 <xplat> shachaf: the real problem is the semantic iffiness of using an mmaped file as a pure value since they can change, but you can always wrap it so it doesn't look like a pure value
20:44:35 <rwbarton> but if I read the file into memory strictly and I block on waiting for the disk, other Haskell threads can run
20:44:51 <hpaste> Cale pasted “benchmark” at http://hpaste.org/76596
20:44:58 <Cale> oh, I only used -O2
20:45:01 <rwbarton> that's what you meant right shachaf?
20:45:05 <Xezlec> I keep being told that pipes are flat-out superior to infinite lists, but I can't see how you can do all the things with pipes that you can do with normal data containers like lists.
20:45:09 <shachaf> rwbarton: Right.
20:45:13 <xplat> shachaf: or just punt and promise yourself you won't let the file change while your program is running
20:45:27 <shachaf> rwbarton: (Unless the memory you read it into gets paged out, which I think is what xplat was referring to.)
20:45:33 <rwbarton> oh i see
20:45:36 <rwbarton> hmm
20:45:46 <shachaf> But there's only so much you can do in that case.
20:45:51 <Cale> -funbox-strict-fields makes essentially no difference
20:45:51 * shachaf wants async page faults!
20:46:11 <Cale> Xezlec: Just use lists :P
20:46:18 <KirinDave> Cale: Cool. thanks!
20:46:54 <KirinDave> Cale: It just blows my mind that that code actually takes ~400us.
20:46:57 <rwbarton> okay, that makes me feel better about using bytestring-mmap again
20:47:10 <rwbarton> shachaf: is that a thing that any os has done?
20:47:14 <rwbarton> it sounds scary!
20:47:17 <xplat> Xezlec: the problem is lists let you do things that you really can't do in a streaming fashion, pipes don't exactly prevent you from doing these things, but they do make them hard, which makes memory or other resource explosions less likely
20:47:20 <shachaf> rwbarton: What, async page faults?
20:47:22 <Cale> KirinDave: Why? Is that high?
20:47:22 <rwbarton> yes
20:47:27 <shachaf> I think some microkernels do it?
20:47:28 <rwbarton> but almost possible?
20:47:31 <KirinDave> Cale: No I think it's crazy fast.
20:47:36 <KirinDave> Cale: Esp given the primality test.
20:47:38 <shachaf> If I remember correctly Linux does it internally for Xen or something like that.
20:47:46 <rwbarton> hmm
20:47:50 <rwbarton> that I can believe
20:47:52 <KirinDave> Cale: I am reasonably sure we're approaching the limits of that primality test, not anything else.
20:48:05 <KirinDave> Cale: I should confirm, but I suspect it basically ends up entirely in cache.
20:48:16 <Xezlec> xplat: But the pipes also make a large number of things impossible that I would obviously need to do sometimes.
20:48:20 <KirinDave> Cale: And probably the fold is mostly in register.
20:48:32 <shachaf> rwbarton: If you want to be really confident that some memory doesn't get paged out, you can presumably mlock() it.
20:48:40 <Cale> 400 us * 2.66 GHz = 1064000 cycles
20:48:45 <Xezlec> xplat: I guess I don't understand how people use them, unless somehow normal folks don't ever need anything beyondf a straight pipeline.
20:48:52 <KirinDave> Cale: Right, but it's primality testing.
20:48:54 <shachaf> Which I guess works for mapped memory just as much as for unmapped memory.
20:48:54 <KirinDave> Cale: So.
20:48:55 <xplat> Xezlec: things that you can do in a purely streaming fashion you can write Pipes code to do, but a few of the tricky primitives may not have been written yet.  (but they don't need any private access to library internals so they can be added on)
20:49:20 <Xezlec> xplat: I have spend about 10 hours of thought on this and nobody has been able to help me out.
20:49:34 <Cale> I wonder what the largest number it's testing the primality of is.
20:49:39 <Xezlec> xplat: so if it is possible, it is not possible for *me*.
20:49:39 <KirinDave> Oh it's not high.
20:49:43 <KirinDave> Have it print the solution result.
20:49:46 <xplat> Xezlec: conduits probably has a larger set of primitives since it's an older and more mature library, even more so iteratee and enumerator
20:50:00 <KirinDave> Should be the bottomRight param
20:50:18 <KirinDave> I really gotta do some soldering, gonna be quieter. I can still see things
20:50:37 <Xezlec> xplat: Well, I guess I'll check those out, if you're really sure this is possible.
20:51:42 <rwbarton> shachaf: in my case I am writing a server to do queries on a large data set that won't fit in RAM--but I don't want to guess which parts of the set will be "hot", I would rather just let the OS deal with that
20:52:25 <shachaf> rwbarton: Right. Making that work with the I/O manager seems pretty tricky, if you're relying on page faults.
20:52:28 <xplat> Xezlec: but actually for you i'd have to reluctantly select lazy IO as probably more realistic for you to finish your project, because iteratee has everything you need if you're oleg (joke), pipes is probably not finished enough for a relatively new haskeller to do this, and conduit probably has some hacky way so i would check that out briefly but probably you'll end up using lazy IO
20:52:32 <shachaf> (Regardless of whether you use mmap or read everything into memory.)
20:52:36 <Cale> KirinDave: I can imagine that a fairly significant amount of computation can happen in a million cycles though :)
20:52:53 <Cale> KirinDave: It is impressive how fast our computers are these days though
20:52:59 <rwbarton> maybe running with -N<some medium number> would help a bit with that
20:53:02 <xplat> Xezlec: if you were doing this next year i'd probably say use pipes without hesitation, but it's not next year yet
20:53:09 <shachaf> rwbarton: The last time I worked on a thing like that we implemented our own page cache and did direct I/O to the disk. :-)
20:53:20 <KirinDave> Cale: So you're confident that number is close to right?
20:53:25 <rwbarton> will ghc tend to schedule threads on distinct capabilities if it has enough capabilities to do so?
20:53:47 <shachaf> I'd hope so.
20:53:49 <Cale> KirinDave: Well, it's much more likely than the 5 nanoseconds or whatever when GHC lifted the constant :)
20:53:57 <rwbarton> yeah I guess that would make sense :P
20:53:57 <Xezlec> xplat: Also, all the pipey stuff seems so ugly, and the list approach is so beautiful... since I started this project to convince myself that Haskell had some benefit over C, that would be a disappointing direction.
20:54:07 <KirinDave> Cale: WINK. :)
20:54:08 <rwbarton> since as far as it knows I have <some medium number> of hardware cores
20:54:12 <xplat> Xezlec: (if you were doing this open source or were able to hire more experienced haskellers you realistically could do it with pipes now)
20:54:40 <Cale> mean: 10.72945 ns, lb 10.70092 ns, ub 10.77347 ns, ci 0.950
20:54:40 <Cale> std dev: 179.7092 ps, lb 128.3914 ps, ub 270.3304 ps, ci 0.950
20:54:47 <xplat> Xezlec: (but your interface to the requisite knowledge and experience is too low-bandwidth)
20:54:52 <Cale> lol, 10 ns with a standard deviation of 179 picoseconds
20:55:11 <Xezlec> xplat: I can do it right now also using the same approach I used in C.  I don't know whether that would end up being better or worse than the pipes approach in terms of simplicity.
20:56:13 <xplat> Xezlec: probably much worse than both pipes and lazy IO in terms of simplicity, and better than lazy IO in terms of predictable performance
20:56:35 <Nereid> hmm, records are harder
20:56:58 <Jafet> Picoseconds
20:57:15 <Xezlec> xplat: Hmm... not sure about that at all.  Pipes do seem really restrictive.  I'd love to see some pipe code that does something fancy with them.
20:57:42 <Jafet> I'm only 5% confident that criterion is accurate in that range
20:58:50 <Cale> Jafet: But there's a 95% confidence interval! How could it go wrong? :)
20:59:01 <Xezlec> xplat: then again, you're the expert.  Maybe I should just keep plugging away at it and worry about a pipe-using variation later.
20:59:46 <KirinDave> Cale: Ty very much btw.
20:59:51 <Cale> Xezlec: My suggestion is just to write the code in a way which makes sense to you. Maybe even write the straightforward strict-IO code and see if you can abstract it in your own way.
21:00:14 <Cale> KirinDave: no problem
21:00:25 <Xezlec> Cale: now that you mention it, it wouldn't hurt to try that too.
21:00:29 <Cale> KirinDave: If you want, I can paste the code where I fixed the IO
21:01:03 <Cale> KirinDave: But all I did was r <- newIORef 0.10 at the top of main, and then  v <- readIORef r; evaluate (dimensionPassingThreshold v)
21:01:56 <Xezlec> Well, I've harped on my silly project enough for one night.  I leave you all to your monads.
21:02:13 <KirinDave> Cale: sure
21:03:00 <Cale> I just put the print back in, and it doesn't affect the time much -- it becomes 416 us
21:03:39 <hpaste> Nereid pasted “haskell-src-exts with trailing commas” at http://hpaste.org/76597
21:03:48 <Nereid> it seems to work
21:03:50 <hpaste> Cale pasted “avoiding lifting” at http://hpaste.org/76598
21:06:41 <Nereid> so now it accepts things like [1,2,] or x {a = 1,} or data X = X {a :: X,} ...
21:06:55 <Nereid> I don't know what I did all this for though.
21:07:01 <shachaf> @slap Nereid
21:07:01 <lambdabot> stop telling me what to do
21:07:06 <shachaf> @slap Nereid
21:07:07 <Nereid> haha
21:07:07 <lambdabot> go slap Nereid yourself
21:07:14 <shachaf> :-(
21:07:15 <shachaf> @slap Nereid
21:07:16 * lambdabot orders her trained monkeys to punch Nereid
21:07:21 <Nereid> :(
21:09:21 <Jafet> @yow
21:09:21 <lambdabot> Couldn't find fortune file
21:18:35 <dmwit> xset--
21:18:55 <shachaf> As in X11?
21:19:08 <dmwit> yes
21:19:27 <shachaf> Remember the good old days when dmwit was in #-blah?
21:19:42 <dobblego> heh
21:24:25 <dmwit> Huh, there's no setEnv in System.Environment?
21:24:42 * hackagebot sylvia 0.2.2 - Lambda calculus visualization  http://hackage.haskell.org/package/sylvia-0.2.2 (ChrisWong)
21:25:55 <Nereid> @hoogle setEnv
21:25:55 <lambdabot> System.Posix.Env setEnv :: String -> String -> Bool -> IO ()
21:25:55 <lambdabot> System.Posix.Env unsetEnv :: String -> IO ()
21:29:02 <Nereid> @hoogle putEnv
21:29:02 <lambdabot> System.Posix.Env putEnv :: String -> IO ()
21:29:12 <dmwit> argh
21:29:52 <dmwit> I can't build xmonad because cabal-install is too old, and I can't build the new cabal-install either (for the same reason).
21:30:10 <rwbarton> can you build a medium cabal-install?
21:30:38 <Nereid> we should be able to write setEnv for win32 too, since win32 has a SetEnvironmentVariable function
21:30:46 <dmwit> I doubt it. The error is the "catch is not in scope" thing.
21:31:05 <shachaf> Which version of GHC and cabal-install?
21:31:18 <dmwit> GHC-7.6.1, cabal-install-1.16.0
21:31:41 <dmwit> (currently using cabal-install-0.10.2 with Cabal-1.10.2.0)
21:31:42 <shachaf> GHC-7.6.1 can build cabal-install 1.16.0
21:32:13 <hpaste> dmwit pasted “it's not GHC's fault” at http://hpaste.org/76599
21:35:50 <mysticc> Does ghci uses no buffering by default for IO ?
21:36:03 <dmwit> yes
21:36:18 <mysticc> dmwit: I could not find the source where it mentions that.
21:36:59 <dmwit> You mean like, the source code, or a source like documentation?
21:37:44 <mysticc> dmwit: mentioning that "ghci has NoBuffering by default".
21:38:06 <mysticc> I meant docs or in wiki.
21:38:24 * dmwit shrugs
21:38:31 <dmwit> Maybe it's not mentioned in the docs or on the wiki.
21:38:34 <Nereid> mysticc: http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ghci-faq.html bottom
21:39:43 <Nereid> fwiw, first google result for ghci buffering
21:40:32 <mysticc> Nereid: I searched for ghci no buffering :P
21:40:42 <dmwit> ...but not on the list for ghci nobuffering
21:40:46 <Nereid> lol
21:40:48 <dmwit> Yeah, what mysticc said.
21:40:54 <Nereid> try some different search terms then!
21:42:59 <mysticc> It doesn't mention for stdin buffering?
22:01:15 <notola> if I'm doing a qualified import such as "import qualified Data.Set as Set" how do I later use Set.Tip in pattern matching?
22:01:44 <shachaf> notola: You don't, because Set.Tip isn't exported.
22:01:58 <notola> shachaf: so how do I pattern match for the empty set?
22:02:11 <shachaf> Set.null
22:02:18 <shachaf> No pattern matching on sets, unfortunately.
22:02:34 <liyang> (Set.null -> True)
22:02:36 <shachaf> (You can probably use view patterns somehow.)
22:02:45 <notola> shachaf: thanks, will do
22:03:01 <shachaf> liyang: That's pattern matching but doesn't have most of the benefits of pattern matching. :-)
22:04:00 <shachaf> I wonder whether S.fromList is lazy enough to give you a (:) immediately without traversing the set.
22:04:07 <shachaf> (If the size is nonzero.)
22:04:42 * hackagebot connection 0.1.0 - Simple and easy network connections API  http://hackage.haskell.org/package/connection-0.1.0 (VincentHanquez)
22:04:51 <shachaf> I mean toList.
22:05:29 <shachaf> Looks like not.
22:05:39 <dobblego> is zip <*> tail in a library yet?
22:05:44 <shachaf> dobblego: Nope.
22:06:53 <Jafet> shachaf: Set is strict.
22:07:43 <shachaf> Jafet: Yes, I'm just concerned about the efficiency of (S.toList -> []) vs. (S.null -> True)
22:10:04 <Jafet> > let s = S.fromList [0..99999] in [ undefined | _ <- [0..99999], null (S.toList s) ]
22:10:05 <lambdabot>   []
22:10:17 <Jafet> > let s = S.fromList [0..99999] in [ undefined | _ <- [0..99999], length (S.toList s) == 0]
22:10:21 <lambdabot>   mueval-core: Time limit exceeded
22:10:30 <shachaf> Come on, not length.
22:10:34 <Jafet> > let s = S.fromList [0..99999] in [ undefined | _ <- [0..99999], S.size s == 0]
22:10:36 <lambdabot>   []
22:10:42 <shachaf> > let s = S.fromList [0..99999] in [ undefined | _ <- [0..99999], null (S.toList s)]
22:10:44 <lambdabot>   []
22:10:50 <rwbarton> that's what he did first
22:11:00 <shachaf> Oh, whoops.
22:11:08 <Jafet> I'm subtle.
22:11:21 <rwbarton> so according to highly reliable lambdabot benchmarking toList is at least somewhat lazy
22:12:02 <Jafet> It probably walks the height of the tree
22:12:06 <shachaf> I think it'll traverse log n nodes.
22:12:10 <Jafet> According to highly reliable me
22:12:13 <shachaf> Right, what Jafet said.
22:12:45 <shachaf> toList is defined with foldr, where foldr f z = go z where { go z' Tip = z'; go z' (Bin _ x l r) = go (f x (go z' r)) l }
22:14:12 <rwbarton> does anyone use the automatic multiline input mode of ghci? i just happened across the documentation for it
22:14:48 <Jafet> I use it when I want to check what modules I have imported
22:15:04 <Jafet> Automatic?
22:15:11 <rwbarton> :set +m
22:15:17 <rwbarton> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/interactive-evaluation.html#ghci-multiline
22:15:38 <shachaf> whoa, dude
22:15:55 <shachaf> As long as it always prints all the modules you have imported, it's pretty useless to me.
22:16:09 <Jafet> You should start with: "has anyone heard of the automatic multiline input mode"
22:16:11 <shachaf> I have 90 modules imported.
22:16:35 <Jafet> Well, that is mainly the reason I sometimes want to know what I have imported.
22:16:48 <rwbarton> hmm
22:16:59 <rwbarton> probably you can customize the continuation prompt too
22:17:33 <shachaf> I want something like %s except it only prints the "*" module, not everything.
22:17:57 <Jafet> :set prompt should take a [String] -> String
22:18:16 <rwbarton> there ought to be a direct way to see what imports are in scope
22:18:56 <Jafet> :m -TAB
22:19:25 <Jafet> Hmm
22:19:28 <Jafet> [String] -> IO String
22:19:41 <rwbarton> but what if I've done something lik import Foo as R, import Bar as R
22:20:19 <shachaf> :m -TAB will show Foo and Bar, apparently.
22:20:38 <Jafet> Now I want zsh style prompts for ghci
22:20:47 <rwbarton> would be nice to see under what names you imported them
22:20:53 <rwbarton> some kind of :i-style list
22:21:18 <shachaf> :i should show you where a symbol actually got imported from.
22:21:24 <rking> Jafet: The zsh line editor is tops.  I love the menus that come up e.g. when you tab-complete.  One could use a socket and talk to ghci but otherwise use zle for interaction.
22:21:29 <shachaf> This is different from "where it got defined" -- I don't usually care about GHC.Foo
22:23:03 <dmwit> oh, what
22:23:32 <Jafet> :i is showing too much, actually. I get screen after screen of instances
22:24:44 <Jafet> Not helped by the fact that Doc is pretty bad at printing large things
22:25:16 <dmwit> Pressing 's' in htop starts strace on the highlighted process. This is awesome.
22:25:24 <rwbarton> I'm not sure whether :set +m would actually be more useful than annoying
22:25:30 <shachaf> dmwit: Yes, strace++ htop++
22:25:39 <rwbarton> but I guess hitting enter an extra time after "let x = 5" isn't too bad
22:25:50 <shachaf> rwbarton: I think the Python REPL works like set +m
22:26:01 <shachaf> But on the other hand Python doesn't support one-liners.
22:26:23 <rwbarton> yes, it does basically
22:28:45 <rking> dmwit: Oh, that's too cool.
22:29:21 <pordan30> is there a canonical way to define λ (f :: * -> * -> *) x y = f y x, i.e., type-level flip?
22:29:43 <Jafet> type Flip f a b = f b a
22:29:51 <Jafet> This is probably not what you want
22:30:22 <rwbarton> alternatively newtype Flip f a b = Flip (f b a) -- also probably not what you want
22:30:30 <pordan30> no, because Flip will wrap my types, and doesn't really approximate a type level lambda
22:30:41 <shachaf> data Flip f a b = Flip (f b a) -- almost certainly not what you want
22:30:55 <shachaf> pordan30: Well, there aren't really type-level lambdas.
22:31:27 <dmwit> All attempts to mimic type-level lambdas suck, each in its own subtle and distinct way.
22:34:42 <rwbarton> most likely what you think you want isn't what you want either
22:36:26 <pordan30> jafet, rwbarton, dmwit, shachaf: thanks; i think the last comment is right also. i suppose the proper question would be: given a type constructor of eg arity 2, is there a way to define a class instance with the second argument occurring on the rhs of the instance declaration but parametric in the first?
22:37:11 <shachaf> Not without a newtype.
22:39:21 <rwbarton> or maybe by redesigning the class
22:39:34 <shachaf> Well, yes.
22:39:54 <rwbarton> you can't make (a,b) a "Functor in a", but you can write a different type class that expresses functoriality in the first of two type arguments
22:41:18 <Nereid> you could also newtype Flip f b a = Flip { unFlip :: f a b } and write a functor instance for Flip (,) b
22:41:38 <Nereid> or yeah isn't there a Bifunctor class?
22:41:47 <shachaf> Well, Bifunctor is something else.
22:41:58 <Nereid> since when?
22:42:05 <Nereid> http://hackage.haskell.org/packages/archive/bifunctors/3.0/doc/html/Data-Bifunctor.html
22:42:06 <pordan30> so with, e.g., type classes in coq, if i want to build an instance for (f a b) it suffices to prove an instance for (flip f b a), although this will cause nontermination issues. will ghc's type checker build the correct proof?
22:43:38 <Nereid> shachaf: oh sure, he's not looking for a full Bifunctor.
22:43:50 <rwbarton> there was also this whole fancy thing on reddit recently http://csks.wordpress.com/2012/10/17/redshift-phase-2-types-classes-for-types-with-arbitrary-numbers-of-parameters/
22:43:54 <Nereid> pordan30: but yeah, something like Flip will let you do that.
22:44:48 <rwbarton> well "FunctorFirst" was just my example, don't know what pordan30 wants
22:45:41 <Nereid> I did fail to read the discussion earlier
22:45:46 <rwbarton> wonder if that post could be generalized to other type classes
22:45:53 <rwbarton> I didn't really attempt to understand how it worked
22:46:07 <pordan30> nereid, rwbarton: thanks. it looks like using flip will build the correct instances, then; i'll experiment some.
22:53:34 * shachaf wonders what the "data Stack" declaration in IntSet.hs is for.
22:57:00 <shachaf> Oh, whoops.
22:57:03 <shachaf> It's used, just not named.
22:59:33 <copumpkin> shachaf: what is it used for?
23:00:33 <shachaf> copumpkin: fromDistinctAscList
23:00:48 <copumpkin> oh I see
23:01:14 * lispy thought "ascList" meant association list for the longest time
23:01:29 * lispy blames his background in common lisp
23:01:51 <shachaf> Haskell has association lists too!
23:02:32 <pordan30> in retrospect, i don't think flip is what i want. i /think/ that what i want, although i was advised i don't, is something like: given class C m where type M m a :: Constraint, build instance C (λ k, Map k a), so that i can constrain k. it doesn't look like flip gives the cleanest solution, because then the method declarations want everything in terms of e.g., Flip Map a -  although it might be the only way?
23:02:45 <pordan30> association lists - /that/ unnamed data structure
23:03:53 <lispy> shachaf: yeah, and it looks like Eq a => [(a, b)], but ascList means ascending list
23:04:01 <shachaf> Right.
23:04:03 <lispy> (yoeu probably knew all that)
23:04:19 <shachaf> lispy: Clearly you need more SQL in your life.
23:04:54 <lispy> shachaf: that's one interpretation... ;)
23:05:46 * lispy goes back to reading typing haskell in haskell
23:06:31 <dmwit> pordan30: Yep, we've all been there. Nothing quite does what you want, I'm afraid.
23:06:38 <shachaf> lispy: Pft. To properly understand that paper you need to type all the code into your editor and make it compile.
23:06:39 <dmwit> If you have control of the class, you can change how it's defined.
23:06:42 <lispy> I was realizing earlier that I need a better understanding of unification and I'm hoping I can get it from this paper
23:06:44 <shachaf> Typing "Typing Haskell in Haskell" in Haskell.
23:06:51 <dmwit> That's about the best you can do.
23:07:04 <dmwit> Who's typing "Typing Haskell in Haskell" in #haskell?
23:07:21 <shachaf> Well, that was lispy, not me.
23:07:37 <lispy> oh, man, they recommend I go learn Haskell first
23:07:39 <lispy> brb
23:07:39 <shachaf> I was typing «Typing "Typing Haskell in Haskell" in Haskell» in #haskell.
23:08:53 <lispy> :t (\\) -- I can't even remember the last time I used this
23:08:54 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
23:09:05 <lispy> > [1..3] \\ [2,3]
23:09:05 <lambdabot>   [1]
23:10:10 <pordan30> an interesting case of dependent types decreasing boilerplate code :)
23:10:18 <shachaf> lispy: Typing Haskell is very different from typing GHCskell.
23:11:26 <shachaf> lispy: Of course, if you want to understand unification the natural thing to do is Prolog.
23:11:49 <lispy> shachaf: I want to start by understanding the unification step in H-M type checking :)
23:12:16 <lispy> The other paper I picked up today just said, "We use algorithm U by Robinson"
23:12:29 <lispy> I suspect this paper will give it more treatment
23:52:11 <dmwit> Oh man, all this time I've been getting the joke wrong!
23:52:38 <Cale> dmwit: Which joke?
23:52:45 <dmwit> There are 2 hard problems in computer science: caching, naming, and off-by-1 errors.
23:52:57 <dmwit> This is much better than the version I used to tell, which left off the last one. =)
23:53:02 <Cale> hah
23:53:28 <shachaf> Telling jokes correctly is a hard part of computer science.
23:53:36 <johnw> is it NP hard?
23:54:00 <Cale> JOKES is #P complete
23:54:43 <sheriff_> no no no
23:55:18 <sheriff_> There are concurrency three hard problems in computer science, caching, naming and off-by-1 errors.
23:56:27 <dmwit> JOKES is in PPT http://web.archive.org/web/20080211140314/http://cs-people.bu.edu/charlton/probpt.pdf
23:58:49 <Cale> heh
