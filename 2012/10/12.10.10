00:01:05 <carpi> osa1: --make is for compiling and linking. no wonder it doesn't run in GHCi
00:18:46 <hughfdjackson> sorry to be OT, but hopefully you guys won't mind an FP question that's language agnostic
00:19:02 <shachaf> Ask first, apologize later. :-)
00:19:05 <hughfdjackson> :p
00:19:14 <hughfdjackson> what's compose with the arguments backwards called?
00:19:31 <bitonic> hughfdjackson: (>>>)?
00:19:38 <hughfdjackson> language agnostically ;)
00:19:40 <bitonic> supposing that with compose you mean (.)
00:19:44 <shachaf> Sometimes it's called ";".
00:19:54 <shachaf> Sometimes it's called "cps", in Haskell.
00:19:58 <bitonic> shachaf: I'd call that "sequence"
00:20:15 <hughfdjackson> hrm
00:20:21 * hughfdjackson was considering going with 'pipe'
00:20:27 <shachaf> Not a regular semicolon, actually. It's ⨾
00:20:35 <shachaf> 2A3E   Z NOTATION RELATIONAL COMPOSITION     [⨾]
00:20:54 <shachaf> https://en.wikipedia.org/wiki/Composition_of_relations confirms it.
00:21:06 <hughfdjackson> i'm doing this for javascript, btw, so infix fns are way out i fear :/
00:21:26 <bitonic> shachaf: I don't see how that is the inverse of ∘
00:21:54 <shachaf> Inverse?
00:21:58 <shachaf> It's flipped.
00:22:21 <bitonic> yeah, that's what I meant.  ; is `m () -> m () -> m ()', or whatever
00:22:26 <hughfdjackson> for clarity, i mean f ' g ' h --> h(g(f()))
00:22:35 <hughfdjackson> rather than the traditiona f(g(h()))
00:22:43 <hughfdjackson> *traditional
00:22:55 <bitonic> hughfdjackson: yeah, you're not looking for ;, but for >>>
00:23:06 <hughfdjackson> i'm actually looking for the generic name for >>> ;)
00:23:18 <rwbarton> some category theorists write f;g for gf
00:23:27 <rwbarton> so I think ; is the generic name
00:23:48 <hughfdjackson> well, most people write composition f . g, right?  but they call it composition in conversation rather than 'f dot g' ;)
00:23:54 <bitonic> I'd simply call it left-to-right composition
00:24:05 <rwbarton> oh you want an english name
00:24:11 <bitonic> in programming ; is >>
00:24:53 <hughfdjackson> :P hehe, sorry, i feel like i'm leading a merry dance
00:24:57 <rwbarton> "and-then"
00:25:23 * hughfdjackson will settle on his original 'pipe' 
00:25:34 <hughfdjackson> :D thanks for your thoughts though
00:27:39 <rwbarton> huh, both wikipedia and nlab say that "f;g" is based in computer science and the C ;
00:27:48 <rwbarton> I never really thought of it that way before
00:27:59 <rwbarton> figured it was just a way to flip the order without being super confusing
00:35:28 <kmbt> I've got a question on acid-state. I would like to store a List of Records in the database. I would like to know if the record fields are fully evaluated before storing. If not, I would like to learn how to make them fully evaluate.
00:35:43 <kmbt> Could anyone help?
00:40:36 <merijn> kmbt: They will be fully evaluated, otherwise they couldn't be serialised to disk
00:41:02 <merijn> kmbt: The serialisation will force any unevaluated fields/thunks in your data structure
00:42:24 <merijn> And now I'm wondering whether serialising [1..] to disk would make you run out of disk space or loop infinitely...guess that depends on your serialisation implementation...
00:43:14 <sipa> it's like a serializer can determine in finite time that a sequence is equal to [n..], right?
00:43:37 <sipa> *not
00:43:41 <kmbt> well I just do things like $(deriveSafeCopy 0 'base ''MyRecord)
00:44:14 <kmbt> did not write any custom serializer
00:44:38 <merijn> sipa: No, obviously it will become bottom. I was just wondering whether it is crash due to lack of diskspace bottom or loop infinitely bottom :)
00:45:12 <merijn> kmbt: Serialisation can be derived. i.e. if MyRecord contains only serialisable values then it is serialisable too
00:45:43 <merijn> hmm, nice dc
00:45:48 <merijn> As I was saying
00:45:53 <merijn> kmbt: Serialisation can be derived. i.e. if MyRecord contains only serialisable values then it is serialisable too
00:46:11 <merijn> kmbt: deriveSafeCopy takes care of making things serialisable automatically if possible
00:47:03 <kmbt> Is there an easy way to check how much memory my data structure takes when fully loaded from acid-state into RAM? Currently i just do putStrLn $ show but I believe it is a sub-optimal solution
00:47:28 <elliott> could try the profiler
00:47:29 <merijn> kmbt: GHC has extensive profiling options, including memory usage
00:47:41 <merijn> kmbt: I believe RWH has a chapter on using them
00:51:49 <lpvb> is there anything to gain from learning lisp when you already know haskell?
00:51:55 <merijn> Man, Control.Arrow really needs a \f -> f &&& f combinator...
00:52:08 <lpvb> when you are already investing time in haskell*
00:52:14 <nicoo> merijn: IIRC, the Wiki page about Haskell generics even have a generic construction for serialization
00:52:35 <Ralith> lpvb: some interesting stuff pertaining to OOP, metaprogramming, and syntax, perhaps.
00:52:47 <merijn> nicoo: Yes, but some things aren't serialisable (at least not automatically), e.g. functions
00:53:07 <merijn> lpvb: I'd say so, but I haven't really started learning lisp beyond the basics, I have to admit :p
00:53:11 <lpvb> Wouldn't haskell have the same metaprogramming power form template haskell?
00:53:23 <merijn> lpvb: It's not the *same* power
00:53:30 <lpvb> s/form/from
00:53:42 <AfC> merijn: (at least, not until we get the static operator added to the language :))
00:53:44 <merijn> Lisp has runtime metaprogramming, granted combined with laziness haskell can do many of the same things Lisp can, but very differently
00:53:46 <Ralith> lpvb: in the same sense that brainfuck has the same computational ability as a normal programming language
00:54:09 <lpvb> that's a drastic analogy
00:54:11 <Ralith> indeed.
00:54:22 <merijn> Ralith: I don't think that's an honest comparison
00:54:22 <Ralith> it's a drastic difference.
00:54:27 <lpvb> haskell metaprogramming can't be that bad?
00:54:34 <Ralith> I guess I misrepresent myself
00:54:35 <kmbt> merijn: I guess i need to dig into it then :) Currently my database takes 9MB on disk and the program takes up to 512MB while just printing it to stdout. The data structure is built out of Records, Lists and Lazy Bytestrings. So either I've done some sub-optimal coding or the haskell data structures are far from optimal memory-wise. I hope the former is the case :)
00:54:40 <merijn> Ralith: Template Haskell + laziness can get you very close to what Lisp can do...
00:54:41 <Ralith> haskell metaprogramming is not bad
00:54:45 <Ralith> and it is not weak
00:54:59 <Ralith> it is also not the same.
00:55:07 <merijn> kmbt: Or maybe you're somehow keeping things in memory longer than you expect :p
00:56:18 <lpvb> is lisp easier and simpler than haskell in the same way that python is simpler than other OOP languages? lisp being dynamically typed and allowing impurity...
00:56:33 <Ralith> depends.
00:56:42 <merijn> lpvb: Lisp is mostly just different
00:57:09 <Ralith> I'd probably say it's ultimately harder to write really good code in, just because there are so many ways to do things wrong.
00:57:13 <merijn> lpvb: Although, after the massive brain rewiring of Haskell you'll probably think Lisp is pretty obvious once you get it
00:57:14 <lpvb> lisp makes me curious, but I don't know what benefit there is to gain
00:57:18 <Ralith> but that'd be finagling technicalities
00:57:48 <Ralith> indeed, the only novel paradigms you'll find are interactive development and perhaps rich OOP
00:57:49 <merijn> lpvb: I don't expect you'll gain a lot per se, other than a different view of computing from haskell
00:58:03 <Ralith> which aren't quite as mindbending to pick up as, say, arrows.
00:58:15 <merijn> But you didn't really ask whether it had any practical benefits, you asked whether it was worth learning :p
00:58:30 <Ralith> of course, that depends what your objectives are for learning.
00:58:33 <lpvb> okay, so what are the practical benefits?
00:58:39 <Ralith> define practical!
00:58:51 <lpvb> faster to get a project done
00:58:57 <lpvb> maybe
00:59:01 <merijn> Depends on the project
00:59:08 <Ralith> you'll be fastest in the environment you know best, modulo library availability.
00:59:11 <sp3ctum> :D
00:59:36 <merijn> If you're project is begging for online, interactive development then Lisp seems a clear winner, for example
00:59:55 <merijn> The ability to serialise/deserialise arbitrary code is nice too
01:00:01 <Ralith> what project begs for that so badly that ghci won't suffice?
01:00:07 <Ralith> you can't really do that...
01:00:18 <Ralith> not for most useful meanings of the terms, anyway
01:00:20 <merijn> Ralith: Yeah, that's a bit too strongly worded, I guess
01:00:31 <lpvb> haskell has a lot of nice web frameworks so wouldn't that point be moot?
01:00:39 <Ralith> not that kind of online.
01:00:45 <Ralith> online as in 'while the software is running'
01:00:51 <merijn> Ralith: Well, if your goal is to develop a MUD with friends then I could certainly see benefits to doing online development
01:01:02 <merijn> lpvb: online as in "change the program while it is executing"
01:01:21 <merijn> lpvb: Having a game where you can code new game behaviour from inside the game, for example
01:01:26 <Ralith> merijn: right, for some reason the usual usecases slipped my mind
01:01:43 <Ralith> modifying behavior at runtime can be a lot of fun for tweaking/tuning/playing
01:01:58 <Ralith> also, high-availability bugfixing
01:02:24 <merijn> Like the moon lander running Lisp that was remote bugfixed while it was running on the moon :)
01:02:50 <Ralith> lpvb: personally, the only reason I'd recommend learning lisp is to expose yourself to a wider variety of ways of doing things.
01:03:13 <Ralith> merijn: I thought that was a deep space probe?
01:03:53 <merijn> I don't know tbh
01:04:00 <merijn> Something in space at least :p
01:04:05 <Ralith> ^^
01:04:51 <Jafet> Who needs remote patching, just deploy a grad student with the probe.
01:05:06 <Ralith> lifting mass is expensive!
01:05:08 <fmap> the only thing i've got from learning lisp is rainbow_parenthesis.vim :[
01:05:21 <Ralith> sounds like a win to me
01:05:49 <fmap> yeah, that's nice plugin
01:06:18 <Jafet> Ralith: get a grad student who's just bound their thesis
01:06:36 <merijn> libraries@haskell.org is where additions to the libraries should go, right?
01:07:03 * merijn wants both = join (***)
01:07:42 <fmap> merijn: there is `both' as lens
01:08:14 <fmap> mapOf both succ (1,2) ===> (2,3)
01:08:26 <shachaf> @djinn (a -> b) -> (a,a) -> (b,b)
01:08:26 <lambdabot> f a (b, _) = (a b, a b)
01:08:31 <shachaf> thanks djinn
01:08:37 <shachaf> Just what I wanted.
01:08:45 <shachaf> Isn't it supposed to use all the variables where possible?
01:08:56 <Ralith> haha
01:09:04 <merijn> fmap: Yes, but needing the mapOf kinda ruins the nice point-freeness of "both f"
01:09:08 <Jafet> Clearly both is a bad function, its type is underspecified
01:09:14 <shachaf> merijn: Why?
01:09:22 <merijn> shachaf: Extra words, man!
01:09:26 <shachaf> mapOf both :: (a -> b) -> (a,a) -> (b,b)
01:09:32 <shachaf> Oh, you don't mean that it's not point-free.
01:10:28 <merijn> If I'm composing arrows "foo >>> both bar >>> baz" vs "foo >>> mapOf both bar >>> baz"
01:10:45 <shachaf> Wait, you ahve actual arrows?!
01:11:23 <merijn> shachaf: Well, so far I've mostly used it for functions, but now that I'm playing with Netwire I find I need it for other arrows too
01:13:54 <merijn> While I'm at it I can also suggest: "withJust :: Monad m => (a -> m ()) -> Maybe a -> m ()" and "onNothing :: Monad m => m (Maybe a) -> m a -> m a" because I keep rewriting those things all the freaking time too...
01:15:22 <hpaste> JKnuzzo pasted “What makes this code resulting in an error?” at http://hpaste.org/76074
01:18:12 <merijn> If I send a message to libraries@ will I need to be subscribed to get replies?
01:21:39 <dmwit> no
01:22:14 <dmwit> Whoever JKnuzzo is, you'll get a better response if you post the error.
01:25:35 * hackagebot data-memocombinators 0.4.4 - Combinators for building memo tables.  http://hackage.haskell.org/package/data-memocombinators-0.4.4 (DmitryMalikov)
01:37:57 <kmbt> merijn: I think I've nailed down my problem. Most memory is allocated for ARR_WORDS, which I've learned is for Bytestrings and Text. My data stucture contains lots of Text which is much shorter than the default chunk size. To you think that this might be the cause for memory overhead?
01:39:36 <kmbt> Now I wonder if I should swich from Text to [Char]
01:40:11 <shachaf> How much shorter?
01:40:31 <randomclown> @pl \xs -> return (zip cs xs)
01:40:31 <lambdabot> return . zip cs
01:41:43 <kmbt> 0-800 characters with approximate mean of about 20 i think
01:43:52 <randomclown> @pl \mp -> return (mp ! c)
01:43:52 <lambdabot> return . (! c)
01:46:53 <kmbt> I wonder if there is some kind of structure for storing large amounts of short strings. Like some kind of memory area with null-terminated strings packed all tightly together.
01:47:58 <kmbt> Or perhaps ghc does that kind of optimization to [Char]?
01:48:50 <cjh`> kmbt: something like a trie could be useful
01:50:36 * hackagebot const-math-ghc-plugin 0.1.0.0 - Compiler plugin for constant math elimination  http://hackage.haskell.org/package/const-math-ghc-plugin-0.1.0.0 (ConradParker)
01:51:18 <kmbt> cjh`: Didn't think of it this way, but...
01:52:11 <cjh`> kmbt: im not sure if it helps, it is primarily useful for strings with similar prefixes.
01:54:13 <kmbt> cjh`: Seems like It might be useful for some fulltext search applications
01:55:52 <cjh`> kmbt: they are primarily used for comparing a string to a set, it is the only thing that came to mind. goodluck :)
01:56:13 <kmbt> cjh`: thanks :)
02:01:37 <kmbt> It seems that Data.Text.Array is what I need
02:14:32 <Trudko> Guys I am thinking about list comprehension and what if I want to do more complicated things with lists , it seems that list comprehension is good only for small changes
02:19:22 <kranius> Trudko: you can do a lot with pattern matching
02:19:46 <Trudko> kranius that some different functionality?
02:20:43 <kranius> I don't understand ? what do you want to do
02:21:48 <Jafet> But the list comprehension doesn't use higher-order functions, which are evil.
02:22:01 <Trudko> kranius: I am asking if matching is part of list comprehension or it is something different
02:22:23 <kranius> they are different
02:22:28 <Trudko> Jafet I did not learn about higher order functions yet so I cant commnet
02:22:38 <kranius> you use pattern matching inside list comprehension often
02:22:45 <Trudko> kranius ok does it mean tthat you agree that list compr. should be used only for smaller changes to list
02:23:23 <Trudko> kranius ou i see now so for bigger changes I can still use list comprehension but Its better to do that with pattern matching
02:23:58 <Jafet> Trudko: list comprehensions can only express map and filter operations.
02:24:36 <kranius> this^
02:25:37 * hackagebot activehs 0.3.0.1 - Haskell code presentation tool  http://hackage.haskell.org/package/activehs-0.3.0.1 (PeterDivianszky)
02:27:14 <dmwit> More precisely, list comprehensions can only express concatMap and guard operations.
02:27:44 <dmwit> > [ x + y | x <- [1..5], y <- [10,20..50] ] -- not a map or filter
02:27:45 <lambdabot>   [11,21,31,41,51,12,22,32,42,52,13,23,33,43,53,14,24,34,44,54,15,25,35,45,55]
02:29:24 <Jafet> Two cheers for reductionism!
02:30:31 * dmwit shrugs uncomfortably
02:30:33 <ousado> dmwit: huh? honestly?
02:30:35 <ivanm> I'm probably going about this the wrong way, but if I want to represent something in C with two arrays with size defined at runtime and then use FFI to create values of that type, is pokeArray the correct function to use?
02:30:44 <ivanm> or does it require I pre-specify a size for the arrays?
02:31:10 <Jafet> @undo [ x + y | x <- [1..5], y <- [10,20..50], even x ]
02:31:11 <lambdabot> concatMap (\ x -> concatMap (\ y -> if even x then [x + y] else []) [10, 20 .. 50]) [1 .. 5]
02:31:28 <ivanm> :o didn't realise @undo could deal with list comprehensions
02:31:33 <Jafet> Well, undo undid guard there.
02:31:35 <dmwit> ousado: If you can flesh out the question to a full sentence, I'll do my best to answer it.
02:32:13 <ousado> dmwit: yes, one sec, looking it up
02:32:53 <absence> mm_freak: i understand that i can add wires like that, and that if i had a static list of wires to sum i could simply make "fold (+) (pure 0) wires" part of the network. but the list changes contents and size dynamically based on wire events, so i'm passing the list of wires as wire input (wire inside wire - is this the wrong approach?). when implementing a "WireM cat [WireM cat Double Double] Double" with internal state [WireM cat Double Double] i 
02:36:43 <matthiasgorgens> Is there a maximumDefault function in one of the libraries?
02:36:50 <matthiasgorgens> (Or something like that.)
02:37:18 <dmwit> http://hackage.haskell.org/packages/archive/safe/0.3.3/doc/html/Safe.html#v:maximumDef
02:37:36 <ivanm> matthiasgorgens: what do you want it to do?
02:37:50 <dmwit> 10:1 odds he wants it to do what that does. =)
02:38:26 <fmap> @type \xs -> maximum <$> (xs <$ listToMaybe xs)
02:38:28 <lambdabot> forall a. (Ord a) => [a] -> Maybe a
02:38:41 <matthiasgorgens> dmwit: yeah, just found that one myself. :o)
02:38:52 <matthiasgorgens> I guess I should have searched for a bit longer before asking.
02:38:53 <matthiasgorgens> :o)
02:39:32 <dmwit> :t \xs -> [maximum xs | not (null xs)]
02:39:34 <lambdabot> forall a. (Ord a) => [a] -> [a]
02:39:48 <matthiasgorgens> (I'm glad I didn't look at all the stuff Neil Mitchell's been doing for Haskell before I had the interview with him at Standard Chartered.  I would have been way to nervous. :o)
02:39:48 <dmwit> :t take 1 . sort
02:39:50 <lambdabot> forall a. (Ord a) => [a] -> [a]
02:40:10 <fmap> @type \xs x -> fromMaybe x $ maximum <$> (xs <$ listToMaybe xs)
02:40:12 <matthiasgorgens> listToMaybe . take 1 . sort
02:40:12 <lambdabot> forall a. (Ord a) => [a] -> a -> a
02:40:12 <Trudko> Jafet not sure what you mean
02:40:25 <ivanm> ahhh, maximum with a default
02:40:31 <ousado> dmwit: oh, I guess I misunderstood you there - I interpreted your sentence as list comprehensions not being able to express map or filter
02:40:31 <ivanm> I was thinking maxBound or something :s
02:41:03 * dmwit suggests that you consider *not* converting to Maybe
02:42:42 <matthiasgorgens> dmwit: why?
02:42:50 <matthiasgorgens> anyway, maximumDef does what I need.
02:42:55 <dmwit> It's rarely necessary.
02:43:01 <matthiasgorgens> or at least, what the hand-rolled code I am replacing with does at the moment.
02:43:02 <dmwit> Just call sortBy (>) and leave it at that.
02:43:15 <dmwit> If you were going to pattern match on Nothing and Just x, pattern match on [] and (x:_) instead.
02:43:22 <matthiasgorgens> yeah.
02:43:51 <matthiasgorgens> unless you want to make sure that the other code can not look beyond that one element.
02:44:06 <dmwit> take 1 accomplishes that just as well.
02:44:16 <matthiasgorgens> yes.
02:44:33 <matthiasgorgens> but if you are more general, then yes, you can just pass the whole list around.
02:44:40 <matthiasgorgens> if your code only looks at the first element, it's the same.
02:44:48 <matthiasgorgens> (modulo garbage collection..)
02:44:49 <dmwit> Something to think about. Of course it's not always the right choice to leave it as a list, but I've recently caught the "listToMaybe is a code smell" bug.
02:45:07 <matthiasgorgens> I don't know if the compiler is smart enough to figure out without a take 1 that the code's only ever looking at at most 1 element.
02:45:25 <dmwit> Why would the compiler need to figure that out?
02:45:33 <matthiasgorgens> to garbage collect the rest.
02:45:37 <matthiasgorgens> of the list.
02:45:42 <matthiasgorgens> or rather, it's thunk.
02:45:46 <matthiasgorgens> and the variables it might refer to.
02:45:52 <dmwit> hm
02:46:34 <dmwit> Okay, yep, that would be another good reason to call take 1.
02:46:39 <matthiasgorgens> yes.
02:47:04 <dmwit> uh
02:47:04 <dmwit> hm
02:47:09 <matthiasgorgens> a sufficiently smart compiler might get by without that in most situations.  (excluding solving the halting problem in general.)
02:47:45 <dmwit> It's actually not that clear to me that "take 1"/"listToMaybe" helps at all for that purpose.
02:48:07 <matthiasgorgens> here's a situation where it will help:
02:48:16 <dmwit> The garbage collection can't happen until the thing is forced (by a pattern match) anyway, and at that point even if you haven't called take 1/listToMaybe you can do the collection.
02:48:29 <matthiasgorgens> suppose you keep the thing around.
02:48:33 <matthiasgorgens> for using it multiple times.
02:48:52 <matthiasgorgens> then the first element will be forced, and with take 1 the compiler knows that that's it.
02:48:57 <dmwit> ...of course.
02:49:03 <Eduard_Munteanu> Well you have max:compute_rest_of_sort as a thunk so...
02:49:05 <dmwit> Okay, I'm going to bed. =)
02:49:36 <matthiasgorgens> by the way listToMaybe is good to communicate with humans. :o)
02:49:49 <matthiasgorgens> because the take 1 is expressed in the type.
02:50:07 <dmwit> Yes, people have made this argument to me before, but I find it unconvincing. =)
02:50:15 <matthiasgorgens> that's your prerogative.
02:50:22 <matthiasgorgens> (I wonder whether I can spell..)
02:50:31 <ivanm> @wn perogative
02:50:31 <lambdabot> No match for "perogative".
02:50:34 <ivanm> @wn prerogative
02:50:35 <lambdabot> *** "prerogative" wn "WordNet (r) 3.0 (2006)"
02:50:35 <lambdabot> prerogative
02:50:35 <lambdabot>     n 1: a right reserved exclusively by a particular person or
02:50:35 <lambdabot>          group (especially a hereditary or official right);
02:50:35 <lambdabot>          "suffrage was the prerogative of white adult males" [syn:
02:50:37 <lambdabot>          {prerogative}, {privilege}, {perquisite}, {exclusive
02:50:39 <lambdabot>          right}]
02:50:40 <ivanm> huh, you _were_ right
02:51:04 <matthiasgorgens> and English'sn't even my first language. :-P
03:07:26 <osfameron> it's what you do *before* rogatizing, obviously
03:10:01 <carpi> say i had a list [5,6,7,8,9,10,11,12,13,14,15,16] and i wanted to apply a function on each element in the list as long as I don't encounter an element that is divisible by 8 ... how would i do it without using 'break'?
03:10:35 <carpi> i tried a comprehension list but it processes all the elements .. even if i gave something like [5..]
03:10:38 <Botje> a standard tail recursive function would do the trick
03:11:42 <carpi> if i did [x | x <- [5..], x `mod` 8 == 0] it gives [5,6,7,9,10,11,12,13,14,15,17..] and so on.. but i want it to be [5,6,7]
03:12:02 <Jafet> Use span!
03:12:51 <dobblego> @type \x y -> if x then pure y else empty
03:12:53 <lambdabot>     Ambiguous occurrence `empty'
03:12:53 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
03:12:53 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
03:12:59 <dobblego> @type \x y -> if x then pure y else Control.Applicative.empty
03:13:00 <lambdabot> forall a (f :: * -> *). (Alternative f) => Bool -> a -> f a
03:13:11 <dobblego> does this function exist somewhere?
03:15:01 <Botje> carpi: or maybe something like mapaccuml
03:16:21 <ozgura> any vim users here? can anyone tell me which one of these alternatives is the "leading" one nowadays? http://www.haskell.org/haskellwiki/IDEs#Vim
03:17:04 <t7> raw vim ftw
03:17:08 <t7> IDEs are for girls
03:17:35 <raichoo> ozgura: I'm using neocomplcache with neco-ghc and syntastic. That's pretty much it.
03:17:38 <Jafet> Chauvinist.
03:17:44 <dobblego> t7: please be careful regarding sexism
03:18:02 <ozgura> t7: what if I was a girl?
03:18:21 <t7> ozgura: then you can use an IDE
03:18:33 <dobblego> please
03:18:44 <ozgura> t7: alright then, I'll stop.
03:19:15 <ozgura> raichoo: I need to search for those stuff.
03:19:57 <fmap> ozgura: ghc-mod can be useful too
03:20:08 <raichoo> yep neco-ghc needs it
03:20:33 <raichoo> And you need hlint to make syntastic work.
03:21:00 <raichoo> ozgura: neocomplcache and neco-ghc are up on vim.org
03:21:43 <raichoo> ozgura: After that just cabal install ghc-mod and you are good to go. syntastic is nice to have but one step at a time :)
03:22:57 <fmap> well, neco-ghc needs ghc-mod executable, i'm about ghc-mod vim plugin
03:23:43 <raichoo> ah ok, didn't know that.
03:25:41 <t7> gloss crashes when i close the window, but not when i press esc
03:28:59 <ozgura> raichoo: these are mostly for autocompletion then? do you use anything for indentation for example?
03:29:26 <ozgura> I am coming from textmate, trying to set up a nive vim environment for haskell now
03:29:37 <ozgura> textmate didn't really give me a lot, so I should probably do this slowly
03:30:32 <raichoo> ozgura: there is an indentationfile up on vim.org. But I'm not very happy with it, I maintain the vim indentation for idris and it's based on it. Maybe I'll work out a better one for haskell.
03:32:03 <ozgura> raichoo: thanks for the pointers!
03:32:17 <raichoo> ozgura: Hope it helps. Enjoy :)
03:36:24 <fmap> ozgura: there are some kludgy indentation scripts for haskell but no general purpose solution (and writing it would be painful)
03:36:46 <totte> I'm trying to compile haskell-xdg-basedir in Arch Linux but I get the error "System/Environment/XDG/BaseDir.hs:23:29: Module `System.IO.Error' does not export `try'". I didn't find anything similar on Google, any ideas what to do?
03:37:40 <fmap> totte: ghc version?
03:37:41 <ozgura> fmap: I can understand that, after all it is a whitespace sensitive language and there must be cases where correctly indenting is not possible without user intervention.
03:37:44 <t7> @ hoogle a -> b -> b
03:37:53 <t7> @hoogle a -> b -> b
03:37:54 <lambdabot> Prelude seq :: a -> b -> b
03:37:54 <lambdabot> GHC.Conc.Sync par :: a -> b -> b
03:37:55 <lambdabot> GHC.Conc par :: a -> b -> b
03:37:57 <totte> 7.6.1
03:38:19 <t7> :t const
03:38:21 <lambdabot> forall a b. a -> b -> a
03:38:30 <t7> :t flip const
03:38:32 <lambdabot> forall b a. a -> b -> b
03:38:37 <quuuux> ozgura: well, you can always write it bracefully, but that's a last resort usually
03:39:05 <fmap> totte: i see, System.IO.Error function was deprecated and finally removed in 7.6.1
03:39:20 <ozgura> quuuux: yes.
03:39:28 <fmap> one solution is to s/try/tryIOError/
03:39:50 <fmap> er, System.IO.Error.try function was deprecated rather*
03:40:01 <totte> fmap: Alright, thanks. :)
03:40:22 <ozgura> quuuux: but then I lose so much cool syntax I wouldn't want it just for auto-indentation.
03:42:58 <fmap> ozgura: and another problem there are different indentation styles
03:43:03 <fmap> many of them!
03:43:42 <ozgura> fmap: yes. I've been using textmate and it has some support for haskell indentation
03:43:51 <ozgura> but it is not very good really
03:44:09 <ozgura> I don't think I'll fell the lack of it
03:44:23 <ozgura> let's see, I first need to live with vim for a few days
03:47:18 <t7> so drawing a circle crashes my gloss then ...
03:48:31 <ClaudiusMaximus> t7: in ghci?
03:48:44 <t7> runghc
03:49:17 <ClaudiusMaximus> hm, does that compile (i don't recall) - but there's some issues with GLUT being crap in ghci iirc
03:49:47 <Jafet> runghc is ghci
03:52:14 <ivanm> OK, my attempt at using FFI just failed
03:53:30 <ivanm> if I have "foo *bar", how should I be referencing that in hsc2hs if I want to get a pointer?
03:53:32 <ivanm> bar or *bar ?
03:54:11 <ClaudiusMaximus> foreign import "&bar" :: Ptr foo  -- iirc
03:54:29 <ClaudiusMaximus> wait
03:54:41 <ClaudiusMaximus> maybe it needs to be foreign import "&bar" :: Ptr (Ptr foo)
03:55:10 <ClaudiusMaximus> assuming it's a global variable
03:55:46 <hpaste> t7 pasted “gloss crasher” at http://hpaste.org/76076
03:57:15 <ClaudiusMaximus> ivanm: http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#verbatim-153
03:58:27 <ivanm> ClaudiusMaximus: it's a field in a struct
04:00:53 * hackagebot polimorf 0.1.0 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.1.0 (JakubWaszczuk)
04:01:22 <ClaudiusMaximus> ivanm: oh
04:02:01 <ClaudiusMaximus> ivanm: let me double check my codes
04:03:49 <ClaudiusMaximus> ivanm: here's my simplest example https://gitorious.org/maximus/mandulia/blobs/master/src/Sort.hsc https://gitorious.org/maximus/mandulia/blobs/master/src/qsort.h  but it doesn't have a Ptr field
04:05:53 * hackagebot doctest 0.9.2 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.2 (SimonHengel)
04:06:02 <ClaudiusMaximus> ivanm: you can probably use something like   bar <- (#peek struct foo, bar) ptr :: IO (Ptr ())
04:06:05 <ivanm> ClaudiusMaximus: the wiki has a hsc2hs pragma to generate the alignment method
04:07:06 <ClaudiusMaximus> ivanm: ah thanks - could be handy if i ever update that code..  but if you only want one field then a little pair of functions is probably easier than writing a Storable instance
04:07:31 <ivanm> ahh, you don't bother writing a Storable instance for the bit with the array pointer
04:09:44 <ivanm> anyway, I've got one array working
04:09:52 <ivanm> for some reason the other one doesn't work
04:10:04 <ivanm> my list of CInts seems to have its endianness flipped or something...
04:10:32 <ClaudiusMaximus> 64bit?
04:10:53 * hackagebot blaze-html-truncate 0.1.0.4 - A truncator for blaze-html  http://hackage.haskell.org/package/blaze-html-truncate-0.1.0.4 (MarcelRuegenberg)
04:10:57 <ClaudiusMaximus> guess - there may be a 32bit value prepended to the array, jumbling everything
04:11:31 <ivanm> yeah, I'm using 64bit
04:11:41 <ClaudiusMaximus> and possibly reducing perfomance due to less optimal alignment
04:12:10 * ClaudiusMaximus would need to see code to make sane comments
04:14:57 <ivanm> trying to work out whether my peek or poke definition is wrong
04:15:56 * hackagebot blaze-html-truncate 0.2.0.2 - A truncator for blaze-html  http://hackage.haskell.org/package/blaze-html-truncate-0.2.0.2 (MarcelRuegenberg)
04:15:58 * hackagebot hs-pkpass 0.1.2.0 - A library for Passbook pass creation & signing  http://hackage.haskell.org/package/hs-pkpass-0.1.2.0 (VincentAmbo)
04:16:23 <ivanm> oh, I wonder if it's because of bad conversions between Int and CInt...
04:16:36 <ivanm> yeah, CInt is a wrapper around Int32
04:17:45 <ivanm> if so, that's strange because it doesn't happen for the other case...
04:18:30 <ivanm> or I could be talking utter garbage due to lack of sleep
04:20:22 <hpc> is there a version of readProcess that operates on ByteString?
04:20:22 <hpc> http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html#v:system
04:20:54 * hackagebot hs-pkpass 0.1.2.2 - A library for Passbook pass creation & signing  http://hackage.haskell.org/package/hs-pkpass-0.1.2.2 (VincentAmbo)
04:20:56 * hackagebot polimorf 0.2.0 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.2.0 (JakubWaszczuk)
04:23:42 <hpc> or should i just be packing the results from the stringy versions?
04:24:49 <hpc> ooh, found it!
04:24:50 <hpc> http://hackage.haskell.org/packages/archive/process-extras/0.1.3/doc/html/System-Process-ByteString.html
04:25:07 <ClaudiusMaximus> ivanm: i use int32_t etc from stdint.h in C
04:26:20 <ivanm> OK, so my struct is { int numNodes; int *firstEdge; int numEdges; EDGE *edges; } (where EDGE is another struct)
04:26:37 <ivanm> the values of numNodes, numEdges and edges is correct
04:26:39 <ivanm> only firstEdge is wrong :s
04:28:05 <ClaudiusMaximus> messily, structs are differently padded on different systems, and int varies between 32bit / 64bit even on different 64bit OS (i think win64 has int 32bit, while linux64 has int 64bit)
04:28:21 <ClaudiusMaximus> hopefullly hsc2hs should do the right thing though
04:28:23 <ivanm> well, this is just meant to be a benchmark hack
04:28:27 <ivanm> and I'm using hsc2hs :s
04:28:56 <ivanm> I think I've worked out my error though; type problem
04:29:03 <ivanm> I was reading them in as Word values rather than CInts :s
04:29:11 <ClaudiusMaximus> oops
04:29:31 <ClaudiusMaximus> bug fixing is fun
04:30:48 <ivanm> yup
04:34:39 <teneen> Why is there no Applicative instance for Data.Sequence?
04:35:09 <hpc> teneen: that's... a good question
04:35:19 <hpc> hysterical raisins most likely
04:36:29 <teneen> hpc: I wonder why not include the default monadic instance (ap, return)
04:36:57 <hpc> someone forgot, or the module predates Applicative, or something like that
04:37:07 <hpc> submit a patch
04:37:28 <hpc> https://github.com/haskell/containers/issues
04:37:29 <ivanm> how would you do it? ala lists?
04:37:33 <teneen> hpc: I will. Thanks
04:38:44 <teneen> ivanm: yes
04:39:08 <teneen> ivanm: Or irrespectively just use the free monadic applicative instance, since there is already a monad instance.
04:40:55 * hackagebot polimorf 0.3.0 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.3.0 (JakubWaszczuk)
04:41:51 <absence> anyone know how to install the llvm bindings? cabal install llvm --configure-option=--with-llvm-prefix="c:\clang+llvm-3.1-i386-mingw32-EXPERIMENTAL" results in "setup.exe: llvm.buildinfo.windows.in: does not exist"
04:42:20 <ClaudiusMaximus> absence: maybe needs more \\\\\ ?
04:42:45 <ClaudiusMaximus> absence: i don't know how string escaping works in your shell
04:43:58 <absence> ClaudiusMaximus: i don't think \ is an escape character. adding more \ doesn't change things anyway
04:54:45 <hpc> bleh, having to upgrade cabal just so i can use the apache license
05:00:55 * hackagebot polimorf 0.3.1 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.3.1 (JakubWaszczuk)
05:00:57 * hackagebot wai-extra 1.3.0.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.0.3 (MichaelSnoyman)
05:20:23 <hpc> does haskell have a cross-platform named pipe library?
05:23:04 <Baughn> Do named pipes exist outside unix?
05:23:21 <Baughn> ..looks like they do.
05:24:38 <earthy> they do indeed
05:24:48 <earthy> in e.g. windows
05:25:42 <Spockz> I did cabal install --global cabal-install and gave my password, but the /usr/bin/cabal is still at 0.14.0. What else could I try?
05:26:37 <hpc> it installs to /usr/local/bin, iirc
05:30:28 <byorgey> Spockz: if you look at the output of  cabal install  it tells you where it is installing any executables.
05:30:37 <byorgey> "Installing foo in /usr/local/bin ... "
05:31:28 <Spockz> byorgey: yes that one is ambiguous, https://gist.github.com/793b070014c99ef1a80b
05:33:15 <Spockz> byorgey: fixed it now manually
05:34:08 <Spockz> great, now build-wrapper is complaining: https://gist.github.com/0d043450b57f3d455dc2
05:35:33 <hpaste> sdfk pasted “titke” at http://hpaste.org/76078
05:35:57 * hackagebot directory 1.2.0.1 - library for directory handling  http://hackage.haskell.org/package/directory-1.2.0.1 (IanLynagh)
05:40:31 <powerman-asdf1> hi. after reading learnyouahaskell.com I still have one question unanswered. it's a little stupid, but I'm just curious. book uses suffix "s" for value names which contain lists, like in "x:xs", etc. why "s" was chosen? it looks like _l_ist or _a_rray or _t_ail makes more sense for this…
05:41:22 <maukd> powerman-asdf1: heh, then why did you say "names which contain lists" instead of "namel which contain listl"?
05:42:05 <powerman-asdf1> maukd: got it, thanks :)
05:42:22 <merijn> powerman-asdf1: one x, multiple ... :)
05:50:53 <quuuux> there's no convenient way to get the transitive closure of package dependencies from a .cabal file, is there?
05:52:40 <merijn> mm_freak: ping?
05:53:41 <alpounet> quuuux, the cabal library probably provides that
05:53:47 <alpounet> or you can find that in cabal-install's source code
05:54:21 <b__> anyone here work with sublime text 2 for their haskell stuff?
05:54:57 <Jafet> If you have already registered the package, you can use ghc-pkg dot.
05:55:23 <Jafet> However, you'll need to work out the transitive closure yourself.
06:01:59 <hpaste> dd pasted “reverse-polish-notation” at http://hpaste.org/76079
06:03:39 <dd> hi, i was working through the learn you a haskell tutorial and am in the tutorial for the reverse polish calculator http://learnyouahaskell.com/functionally-solving-problems#reverse-polish-notation-calculator.  I wanted to refactor the exercise a bit.
06:04:25 <merijn> dd: Yes?
06:04:28 <dd> I tried using some of the other stuff in the tutorial as well.  How does the code in the paste look?
06:04:53 <dd> stylistically I mean
06:05:25 <dd> i basically tried replacing a bunch of pattern matches that looked the same with the map lookup
06:06:04 <merijn> dd: Well, Personally I wouldn't use parenthesis around the call in "case x of" or around the just pattern below it
06:06:06 <dd> the tutorial has ff (x:y:ys) '*" = ... followed by "+", "-", etcd
06:06:30 <Cale> looks fairly reasonable to me
06:06:37 <merijn> dd: I think I would also move the case statement in the where of solveRPN to the next line
06:06:48 <merijn> That way you don't have to march all your code to the right so much
06:07:11 <dd> ok
06:07:14 <quuuux> ff doesn't need to be defined in a where, since solveRPN takes no arguments. You can just put it at the top level
06:08:15 <merijn> quuuux: I like defining functions locally if they're not used anywhere else, so I think that's fine
06:08:32 <dd> quuuux: i don't understand that, what about the [] . words, where would that go then?
06:08:54 <Cale> dd: He means you could move the definition of ff out of the where clause
06:08:59 <dd> oh
06:09:08 <Cale> (at least, this is a choice which is available to you)
06:09:11 <dd> i see
06:09:25 <dd> took me hours just to figure out how ot get the stupid func out of the Maybe -)
06:09:31 <dd> i was just happy it worked
06:09:34 <quuuux> yes. Personally I would definitely move it, but that's personal preference
06:09:41 <hpaste> merijn annotated “reverse-polish-notation” with “reverse-polish-notation (annotation)” at http://hpaste.org/76079#a76080
06:09:55 <merijn> oh, I missaligned the arrows
06:10:12 <dd> I get the idea
06:10:20 <hpaste> ceii annotated “reverse-polish-notation” with “reverse-polish-notation (with pattern guards)” at http://hpaste.org/76079#a76081
06:10:22 <merijn> Anyway something like that, keeps it slightly more compact :)
06:10:44 <merijn> ceii: Yeah, pattern guards is an obvious idea, but I wasn't sure whether that'd complicate things to much for a newcomer :)
06:10:45 <mikeplus64> how does lambdabot's @check work? (other than quickcheck)
06:10:58 * hackagebot data-dword 0.2 - Stick two binary words together to get a bigger one  http://hackage.haskell.org/package/data-dword-0.2 (MikhailVorozhtsov)
06:11:01 <ceii> dd: you can use pattern guards (which are standard haskell 2010) to clean up the case matching
06:11:30 <merijn> ceii: I'd put the guard on the next line
06:11:30 <dd> merijn: I spent a long time trying to figure out how to move the pattern matching in the case statement to the where should things could fall through to the bottom one
06:11:45 <dd> but I gave up and did the case
06:12:06 <merijn> dd: Yeah, that's because it can't be done using normal pattern matching/guards
06:12:19 <Cale> dd: aha, there's something called pattern guards, which are actually part of the standard now :)
06:12:34 <dd> oh, i don't know what those are
06:12:34 <merijn> dd: There is a Haskell2010 feature that allows you to do it, though (take a look at ceii's example)
06:12:36 <Cale> (it was originally an extension)
06:12:42 <dd> or is that the '|' thing?
06:13:02 <Cale> dd: It's | with something like pat <- expr after it
06:13:10 <dd> ok
06:13:23 <merijn> dd: Yeah, normal guards only allow boolean expressions like "f x | even x = whatever"
06:13:47 <Cale> dd: you can, in a single pattern guard, also do multiple nested pattern matches like that, separated by commas
06:13:49 <merijn> dd: Patternguards let you do pattern matching inside guards so you can first run a function on an argument (i.e. lookup) and then pattern match on the result
06:14:18 <dd> merijn: funny, that is what I was trying to figure out how to move that lookup into the matching
06:14:21 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#pattern-guards
06:14:28 <Cale> has a little tutorial
06:14:36 <dd> thanks
06:14:58 <dd> Writing haskell makes me feel like I'm in the gym doing a strenous workout, making me use mental muscles I never thought I had
06:15:31 <merijn> dd: Thinking about the mental muscle mass you're gaining ;)
06:15:37 <merijn> eh, "think about" even
06:15:51 <quuuux> it gets a bit better after a while, but then you discover some new amazing feature and the cycle starts all over again
06:15:53 <merijn> Man, that muscle mass really sacrifices your ability to type normally, apparently
06:15:58 * hackagebot text-binary 0.1.0 - Binary instances for text types  http://hackage.haskell.org/package/text-binary-0.1.0 (JakubWaszczuk)
06:16:10 <merijn> I need to implement a haskell RPG where you get XP for mastering new extensions :>
06:16:14 <frerich> merijn: Maybe it's like with steroids, pumping up your muscle but making your wee wee shrink.
06:16:43 <dd> heh
06:17:06 <quuuux> oh, one more thing
06:17:09 <quuuux> subtract = flip (-)
06:17:27 <dd> isn't that what I did in the lookup?
06:17:28 <alpounet> merijn, monsters would be "understanding edwardk's undocumented libraries"
06:17:41 <quuuux> yes, but subtract is defined in the prelude for you :)
06:17:56 <dd> oh, lol
06:18:01 <dd> I did not know that
06:18:12 <dd> as Johnny Carson used to say
06:19:37 <merijn> It exists because partial application of (-) leads to weird parser complaints otherwise
06:19:58 <merijn> i.e. (-1) parses is the number minus one, not the function \x -> x - 1
06:20:03 <merijn> s/is/as
06:20:25 <dd> for you pros out there, how is haskell for implementing parsing (I seen parsec in a few tutorials).  I want to prototype a DSL we are working on at work that has to parse an industry message type
06:20:40 <dd> I see
06:21:00 <dd> and here I thought I was being cool figuring out flip (-). hah
06:21:00 <merijn> dd: Brilliant, check out parsec/attoparsec
06:21:20 <merijn> dd: Whatever keeps you entertained as you learn, right? :)
06:21:21 <maukd> @pl \x y -> y - x
06:21:21 <lambdabot> subtract
06:21:28 <merijn> > map (-1) [1..10]
06:21:29 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
06:21:35 <merijn> Oh
06:21:38 <merijn> Caleskell strikes again
06:21:45 <dd> I could write in my sleep in my regular languages, so I know what it should do and all that.  I want to see how it compares in Haskell
06:21:51 <maukd> @pl (\f x y -> f y x) (-)
06:21:51 <lambdabot> subtract
06:22:06 <merijn> > map (subtract 1) [1..10]
06:22:07 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
06:22:12 <Jafet> @pl flip (-)
06:22:13 <lambdabot> subtract
06:22:28 <merijn> Are those hardcoded rules in @pl?
06:22:29 <jaj> > map (- 1) [1..10]
06:22:30 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
06:22:39 <maukd> @pl fmap fix return (flip (-))
06:22:39 <lambdabot> fix (return subtract)
06:22:51 * merijn watches jaj become confused
06:22:54 <Jafet> pl is a big bunch of hardcoded rules
06:23:05 <dd> just curious, but what happens if you type some kind of infinite thing, will the bot crash?
06:23:12 <osfameron> woss Caleskell?
06:23:14 <merijn> > [1..]
06:23:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:23:28 <Eduard_Munteanu> > fix id
06:23:30 <jaj> dd: many have tried
06:23:32 <lambdabot>   mueval-core: Time limit exceeded
06:23:34 <maukd> > fix error
06:23:35 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
06:23:36 <ceii> Caleskell is the variant of Haskell used by lambdabot (which is hosted by Cale)
06:23:46 <merijn> osfameron: Built in definitions for some things like a Num instance for functions
06:23:59 <dd> nifty
06:24:01 <merijn> osfameron: And (.) = fmap
06:24:12 <Cale> merijn: Well, I'm not sure that's a "weird parser complaint"
06:24:13 <osfameron> and different definition of (-) ?
06:24:14 <maukd> if by "built in" you mean "imports some modules by default"
06:24:26 <Cale> It's not really a variant of Haskell, btw
06:24:30 <maukd> @where NumInstances
06:24:30 <lambdabot> I know nothing about numinstances.
06:24:38 <ceii> yes, it's an augmented Prelude
06:24:41 <maukd> @ackage NumInstances
06:24:41 <lambdabot> http://hackage.haskell.org/package/NumInstances
06:24:54 <Jafet> It's the 6.12 variant
06:24:55 <Cale> There are just some definitions in scope in the local module and the Prelude is imported hiding those.
06:25:01 <Cale> and yeah, 6.12.x :)
06:25:02 <merijn> osfameron: No, - is the same "(-1)" just parses as a number and lambdabot has a Num instances for functions so :p
06:25:15 <Cale> I do need to work out how to update the GHC on this machine
06:25:25 <osfameron> ah
06:25:41 <merijn> osfameron: Don't forget that "(-1)" is really "fromIntegral (-1)", and since "Num r -> Num (a -> r)" fromIntegral returns a function to map over the list
06:26:11 <merijn> The fromIntegral instance for "Num r => Num (a -> r)" is just "const
06:26:30 <maukd> liftA
06:26:45 <merijn> So "(-1)" becomes "const (-1)" which should explain why "map (-1) [1..10]" produces the results it does
06:26:45 <osfameron> ah.  that kinda makes sense
06:27:05 <osfameron> so how do you get the desired operator slice functionality?
06:27:06 <maukd> > (sin + 1) 0.5
06:27:07 <lambdabot>   1.479425538604203
06:27:18 <maukd> osfameron: you don't. (-) is forever broken
06:27:20 <merijn> osfameron: ((-) 1) or subtract
06:27:29 <merijn> > map ((-) 1) [1..10]
06:27:30 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9]
06:27:32 <osfameron> pesky broken (-)
06:27:34 <merijn> oh, wait
06:27:37 <typoclass> > subtract 1 4 -- osfameron
06:27:39 <lambdabot>   3
06:27:40 <merijn> > map (flip (-) 1) [1..10]
06:27:42 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
06:27:45 <Jafet> > ((*) + (/)) 1 2
06:27:46 <lambdabot>   2.5
06:27:50 <merijn> or subtract as we started this discusion with :p
06:27:58 <ksf> unary - should be abolished.
06:28:10 <quuuux> is anyone still fussing about using type families for monad transformers any more, or has mtl pretty much won that?
06:28:21 <ksf> just write 0-
06:28:43 <maukd> > (+) (+) 3 4 5
06:28:44 <lambdabot>   12
06:28:59 <merijn> quuuux: I think mtl has won because it's more portable for the other compilers?
06:29:57 <ksf> @quote
06:29:58 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
06:30:23 <maukd> preflex: quote
06:30:42 <preflex>  <alexalex> while we all know that md5($string) encrypts a string into md, how can i encrypt a string into a numerical value between 1 and 99 numbers?
06:37:50 <Cale> @quote
06:37:51 <lambdabot> I says: couldn't get through the day as it is without the Prozac and Jack Daniels I keep on the shelf, behind my Tops-20 JSYS manuals.
06:38:16 <Cale> preflex: quote
06:38:33 <preflex>  <exn> how it can be wrong ? `sleep 1000000` if fork()  ;  ?
06:39:11 <mysticc> Is it possible to use the derived class instance to write your own class instance .. ?
06:39:35 <Cale> mysticc: Not really?
06:39:46 <Cale> mysticc: Once you derive an instance, you're not allowed to write another.
06:40:00 <Cale> (for the same class, of course)
06:40:31 <maukd> you could newtype your way around it
06:40:42 <maukd> preflex: quote
06:40:56 <preflex>  <foosball> #math thinks im trolling but im really just an idiot
06:41:21 <Cale> One thing which it just struck me that it might be nice for someone to write is a bit of TH which would follow the Report spec as far as constructing the methods of derived instances, but only construct individual functions with a user-specified name.
06:41:32 <bfgun> is there any structure like a map that also lets me see the elements that are next to some particular key?
06:41:57 <ion> > (zip<*>tail) [0..5]
06:41:58 <lambdabot>   [(0,1),(1,2),(2,3),(3,4),(4,5)]
06:42:25 <Cale> bfgun: You can split a Data.Map around a given key, and you also can efficiently get the maximum and minimum key, I think.
06:42:49 <merijn> bfgun: BK trees
06:42:51 <bfgun> Cale, ideally i'd like to perform this operation in log(n) time
06:43:12 <merijn> (Burkhard-Keller tree)
06:43:14 <bfgun> (well, ideally in constant time with the key...)
06:43:14 <bfgun> :p
06:43:20 <merijn> Are other related metric trees
06:43:27 <merijn> s/are/or
06:43:27 <bfgun> are they implemented in the standard libraries?
06:43:35 <merijn> bfgun: No, but there's a package
06:43:46 <merijn> Are your keys an Enum?
06:43:57 <quuuux> bfgun: what do you mean by 'next to some particular key'?
06:44:04 <Cale> split :: Ord k => k -> Map k a -> (Map k a, Map k a)  is O(log n)
06:44:04 <Cale> minView :: Map k a -> Maybe (a, Map k a)
06:44:05 <Cale> maxView :: Map k a -> Maybe (a, Map k a)
06:44:06 <Cale> yes
06:44:06 <Cale> all these are in Data.Map
06:44:06 <merijn> I think there's you can use Enum's as array indices, in which case, why not use an array?
06:44:08 <Cale> which is about as standard a library as you can get without being in the Report
06:44:26 <bfgun> quuuux, if i was in c++ consider finding something in a tree and getting it through a random access iterator
06:44:30 <Athas> Hm, can you write type-level functions over type constraints?
06:44:33 <Athas> That would be useful.
06:44:34 <bfgun> then the operation i want to  do is --/++
06:44:37 <Cale> quuuux: Presumably the least key in the map larger than a given one, or the greatest one in the map which is less
06:46:02 <Cale> bfgun: If it's super-important to iterate around like this, you might also want to make something out of a finger tree. They're designed to support efficient (log time) splitting/concatenation and also give constant time access to both ends.
06:46:28 <bfgun> i am trying to rewrite monotone polygon decomposition in haskell
06:47:08 <bfgun> i need two things, a sweep line and some map of edge intersections that i need to query and modify locally
06:47:51 <bfgun> every time i sweep through a vertex i'll need to touch the edge map in some way (removing two adjacent edges, removing one edge and adding one adjacent to it, adding two adjacent edges
06:48:52 <bfgun> the structure i'm having trouble imagining is the one to hold the edges, because the queries i need to make involve getting some context information
06:49:09 <bfgun> (local context)
06:50:02 <Cale> bfgun: So, if you don't mind paying a log time cost to access the ends of the split Map, that'll be a decent approach.
06:50:14 <Sculptor> hi!
06:50:22 <Cale> Sculptor: hello!
06:51:00 * hackagebot amqp 0.3.3 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.3.3 (HolgerReinhardt)
06:51:18 <Cale> bfgun: If you want to represent a cursor into a Map which can be moved around, you can use something like a pair of maps, perhaps with one key/value pair "between" them as the focus
06:52:24 <Cale> bfgun: To move left or right, you just do a maxView on the left or minView on the right, and an insert into the other Map.
06:53:35 <bfgun> ok. i think it might be more prudent now to pay the cost of repeated queries and after i get the rest of the algorithm implemented come back to this
06:53:49 <ksf> abstraction to the rescue!
06:55:34 <nand`> map zippers?
06:55:42 <mysticc> Can I define a new instance for type synonym ?
06:55:57 <maukd> no
06:55:57 <nand`> use a newtype
06:57:51 <merijn> I have an asynchronous exception question
06:58:10 <merijn> The docs mention that the state of pure code is saved so it can be resumed
06:58:43 <merijn> But I didn't see any sort of catching function that'd deal with the exception and then continue?
06:59:29 <Cale> wat
06:59:30 <quicksilver> well the point is if you try to evaluate that expression again
06:59:33 <Cale> oh
06:59:36 <quicksilver> (having caught the exception)
06:59:40 <quicksilver> then everything will just work
06:59:52 <quicksilver> the thunks which you already evaluated and updated remain saved
06:59:54 <Jafet> ErrorCall is only one of the asynchronous exceptions
07:00:01 <quicksilver> and the work which isn't yet done will be done as normal
07:00:04 <Jafet> (It's probably the only one that does not make sense to resume)
07:00:19 <merijn> ah
07:00:20 <Cale> yeah, or, more likely, subexpressions
07:00:39 <Jafet> If you get HeapOverflow, you can try again.
07:00:46 <Cale> I suppose you could
07:00:51 <quicksilver> Jafet: or get thread killed
07:01:09 <quicksilver> (HeapOverflow doesn't exist in GHC)
07:01:10 <Jafet> Ok, I've never tried to try them again.
07:01:28 <quicksilver> if you're using exceptions as signals between threads
07:01:43 <quicksilver> then of course they will almost inevitably sometimes arrive in the middle of pure computation
07:01:49 <quicksilver> and it would be pretty useless if that broke
07:02:02 <merijn> I guess what I want then is to either have my code execute masked and occasionally use allowInterrupt to check if one appeared.
07:02:15 <Jafet> Oh, it's referring to that.
07:03:43 <merijn> My idea was to have graceful restart in my application by throwing an exception to all threads to indicate that they should stop, checkpoint and serialise their state so that the process can restart and continue
07:04:52 <merijn> So it only makes sense to check at points where checkpointing is realistically possible, in which case just running everything inside mask with the occasional allowInterrupt would be best
07:05:07 <quicksilver> it depends what "state" means.
07:05:26 <quicksilver> if your "state" is no more than the evaluatedness of nested thunks
07:05:32 <quicksilver> then you don't need to do any more
07:05:42 <quicksilver> that built-in mechanism we were discussing is enough.
07:05:51 <quuuux> using asynchronous exceptions for that sounds like overkill. Why not use an MVar and check it where you would use allowInterrupt?
07:05:54 <merijn> quicksilver: No, I mean an actualy restart as in new process
07:06:03 <merijn> quuuux: Yeah, that was my next thought
07:06:18 <merijn> quuuux: Although an MVar seem silly, that'd block. STM makes more sense
07:06:23 <quuuux> or that, yes
07:07:14 <Jafet> The point of an exception is that the receiving thread doesn't have to agree.
07:07:18 <merijn> quicksilver: So, finish processing current message, write queues to disk so the freshly started process can read in the queues and continue where things left off
07:07:20 <quicksilver> MVars don't have to block.
07:07:27 <quicksilver> it's a question of how you use them.
07:07:47 <Jafet> t <- forkIO (evaluate $ length [0..]); throwTo t
07:07:48 <merijn> quicksilver: No, but TVar's seem superior for something like checking a termination condition from multiple threads
07:08:10 <quicksilver> maybe
07:08:18 <quicksilver> it all depends what you're doing.
07:08:35 <quicksilver> if a TVar gets changed your whole transaction is restarted.
07:08:39 <quicksilver> is that good or bad?
07:08:49 <quicksilver> what's your "whole transaction"
07:08:50 <quicksilver> ?
07:09:01 <merijn> Actually, maybe I just want an IORef Bool
07:09:02 <quicksilver> if your "whole transaction" is just readTVar then ... why use a TVAR?
07:09:59 <merijn> quicksilver: "It all depends what you're doing" and "what's your whole transaction" <- I have no clue yet :)
07:10:26 <merijn> I'm just messing around for fun, I have some vague directions where I want to go to, but no clue specifically how I intend to get there
07:10:33 <quicksilver> I humbly submit that until you know at least some of those answers, it is not clear that TVar will help you.
07:10:46 <merijn> Like I said, I probably want IORef Bool
07:17:48 <hpaste> “Jeff Polakow” pasted “CPS Streams” at http://hpaste.org/76082
07:19:15 <Cale> merijn: One nice way to play around is to apply the read and write functions to whatever type of memory cell you're using, and pass the results of those around, i.e. readEnd :: IO a, writeEnd :: a -> IO ()
07:19:51 <Cale> merijn: this effectively abstracts over which kind of cell you're using, and unless you decide that you need to do something really transactional with it, can be pretty flexible
07:20:03 <byorgey> first class IO ftw!
07:20:57 <Cale> Especially in cases where you're not sure whether it's okay to miss updates or not, it's quite nice to be able to try Chan vs. IORef, say.
07:21:53 <merijn> Cale: Well, that part for now is pretty straight forward, what I'm essentially doing is creating a message broker that farms various message types out to running forkIO threads and manages their coming and going
07:22:31 <merijn> Cale: So there I just need some counter updatable by each thread to indicate when they're done
07:24:50 <mapf> i'm wondering why most packages on hackage have bsd license. it's because bsd in cabal init by default?
07:25:34 <Igloo> No, cabal init uses BSD by default because most packages use BSD
07:26:21 <mapf> Igloo: but why? is there a some history i guess :]
07:26:28 <Cale> mapf: why not?
07:27:01 <mapf> Cale: i like bsd but i don't understand that fact
07:27:15 <Cale> BSD is very permissive. It's a natural license to choose when you want to let people do pretty much whatever they want with the code you've written.
07:27:47 <mapf> why not MIT then?
07:28:03 <osfameron> or Artistic
07:28:06 <Clint> ISC
07:28:09 <mapf> lol
07:28:21 <mapf> too much permissive
07:28:21 <quuuux> wasn't there also something to do with GHC's aggressive cross-module inlining and worries about the GPL?
07:28:31 <Clint> ISC is exactly as permissive as MIT
07:29:24 <mapf> quuuux: GPL applies on object files?
07:30:21 <Jeanne-Kamikaze> yes
07:30:37 <quuuux> actually, that might have specifically been an LGPL worry (that is, that using the LGPL on Haskell programs was no different in practice to GPLing it)
07:31:33 <merijn> Unless you have LGPL + static linking exception
07:34:33 <merijn> What'd be the best way to have a finite chan? "Chan (Maybe a)" or is there a better alternative?
07:34:53 <mapf> such Chan is not a finite
07:35:19 <merijn> It is if you use Nothing to indicate a termination element
07:36:04 <Attic> Hello! Question, if i do:   filter (<5) [1..]    in ghci, it gets stuck. It seems like it still continues to count? Since Haskell is lazy shouldn't it just stop once it reaches 4?
07:36:06 <merijn> I don't mean finite capacity, but some way to indicate to the reader that no more input is coming
07:36:17 <merijn> Attic: Why would it?
07:36:21 <mapf> But if one thread keep writing in chan isn't it grow without end?
07:36:44 <Mortchek> Attic, you probably want takeWhile
07:36:47 <Cale> Attic: It doesn't know that there aren't other elements in the list which are less than 5 or not
07:36:53 <Cale> Attic: It's looking for more.
07:37:02 <Attic> Cale: Ah that makes sense
07:37:24 <Attic> Thanks, all I needed to know
07:37:47 <ksf> in general, haskell is smart only up to magic behaviour.
07:38:02 <mapf> there are finite Chans on Hackage, but i can't find
07:38:25 <copumpkin> @hackage 4chan
07:38:26 <lambdabot> http://hackage.haskell.org/package/4chan
07:39:00 <merijn> mapf: Are you thinking of BoundedChan? Because that is completely different from what I'm asking
07:39:08 <quuuux> Chan model: first in, first out. 4chan model: first in, AAARGH I DID NOT TO SEE THAT /out
07:39:34 <mapf> merijn: yep. i just wondering
07:39:35 <merijn> That provides Chan's of finite size, whereas I want Chan's with someone way to indicate to the reader that there'll be no more input
07:39:44 <merijn> s/someone/some
07:39:59 <mapf> merijn: why not just pass a list?
07:40:02 <ksf> merijn, default chans already do that.
07:40:14 <ksf> just make sure the write end gets gc'ed.
07:41:28 <merijn> ksf: How do I make sure of that?
07:41:36 <merijn> And what happens in that scenario?
07:42:00 <ksf> the read end gets an ThreadBlockedIndefinitelyOn... Exception
07:42:29 <ksf> as to making sure it get's gc'ed, lobby for it in #ghc
07:42:36 <ksf> *brrr*
07:42:39 <ksf> s/get's/gets
07:43:05 <merijn> hmmm, I don't think relying on the GC will work for me, but I can try
07:43:37 <merijn> I guess I could also do "type Stream a = (Chan a, IORef Bool)"
07:43:57 <ksf> type Stream a = Maybe (Chan a)
07:44:09 <merijn> ksf: That wouldn't work
07:44:25 <ksf> ...for the GC case.
07:44:48 <merijn> ksf: I use dupChan too
07:45:05 <merijn> Hmm, that might screw me regardless..
07:45:09 <merijn> oh, no
07:45:11 <merijn> That's fine
07:46:33 <mapf> suppose we have a data type and two instances Read' and Show'. Read' for parsing a data (with not a haskellish syntax, it's because Read' and not just Read) and Show' to render data. So Read' and Show' are pretty similar
07:46:33 <merijn> I dunno how dupChan affects the entire exception thing, but it seems brittle to rely on all sorts of potential exception without security
07:46:53 <mapf> i have an idea that both Read' and Show' can be expressed through the same combinators
07:47:47 <byorgey> mapf: indeed.  e.g. see http://www.informatik.uni-marburg.de/~rendel/unparse/
07:48:08 <byorgey> it's a very nice paper and has an implementation on Hackage
07:48:30 <ksf> the concept is great, but the implementation side lacks a lot of sugar.
07:48:51 <ksf> though not as bad as hxt's picklers.
07:49:11 <quuuux> sugared pickles
07:49:16 <byorgey> yum
07:51:08 <mapf> cool. i almost start rewriting it ^_^
07:54:49 <merijn> @pl \x -> do { v <- foo; return (v, x) }
07:54:49 <lambdabot> (line 1, column 10):
07:54:49 <lambdabot> unexpected "{"
07:54:49 <lambdabot> expecting variable, "(", operator or end of input
07:54:56 <merijn> @undo \x -> do { v <- foo; return (v, x) }
07:54:56 <lambdabot> \ x -> foo >>= \ v -> return (v, x)
07:55:05 <merijn> @pl \ x -> foo >>= \ v -> return (v, x)
07:55:05 <lambdabot> (`fmap` foo) . flip (,)
08:00:16 <JuanDaugherty> is it being compiled in channel?
08:00:44 <typoclass> JuanDaugherty: yes, lambdabot runs haskell code and prints the result
08:01:11 <JuanDaugherty> i've never seen it do so on it's own
08:01:38 <typoclass> > 1 + 2
08:01:40 <lambdabot>   3
08:01:40 <JuanDaugherty> without an interlocutur
08:02:11 <typoclass> JuanDaugherty: well, merijn was sending some commands
08:02:19 <JuanDaugherty> ah
08:03:27 <typoclass> JuanDaugherty: if it starts with ">" or "@", it's a lambdabot command
08:03:46 <asante> can i fmap over an array?
08:04:11 <asante> that should work when the index is an functor?
08:04:16 <JuanDaugherty> :t _
08:04:16 <typoclass> > fmap pred [4..9] -- asante, in haskell we use mostly lists and rarely arrays, but yes
08:04:17 <lambdabot> Pattern syntax in expression context: _
08:04:18 <lambdabot>   [3,4,5,6,7,8]
08:04:32 <merijn> asante: If they're instance of Functor, then yes
08:04:43 <merijn> Can I hide Prelude imports in ghci?
08:05:09 <typoclass> merijn: ":set -XNoImplicitPrelude"? "import Prelude ()" ?
08:05:52 <merijn> typoclass: Nope
08:06:09 <merijn> Or rather "import Prelude hiding (id,(.))" doesn't work
08:06:29 <merijn> And that's really painful while working with netwire...
08:06:38 <mapf> i have trouble with ghci too. i don't know do to deimport
08:06:55 <mapf> is it possible?
08:07:45 <mapf> unimport is more convenient term through
08:08:09 <merijn> @hoogle Monad m => a -> m b -> m (a, b)
08:08:09 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
08:08:09 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
08:08:09 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
08:09:12 <elliott> mapf: :m -Foo
08:11:03 <mapf> elliott: yep
08:11:56 * frerich looks at his code at work saying 'std::find_if( c.begin(), c.end(), std::not( std::bind1st( std::equals<int>(), id ) ) );' and sighs...
08:12:30 <merijn> Golfing for clarity \o/
08:12:49 * danharaj sometimes wishes liftIO were unecessary
08:13:01 <merijn> danharaj: Word.
08:13:03 <merijn> :t map (`fmap` newChan) . map (,)
08:13:05 <lambdabot> Not in scope: `newChan'
08:13:13 <merijn> :t map (`fmap` undefined) . map (,)
08:13:14 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => [a1] -> [f (a1, a)]
08:14:03 <merijn> @src mapM
08:14:03 <lambdabot> mapM f as = sequence (map f as)
08:14:27 <typoclass> frerich: we sympathize ...
08:15:17 <mapf> in lisp partial apply is (apply-partially 'f arg). coding in lisp is like training in typing
08:15:47 <mapf> in elisp in particular
08:16:07 <b__> do people use UnicodeSyntax or is it actually frowned upon?
08:16:28 <merijn> b__: Yes and Yes ;)
08:16:51 <b__> >_>
08:17:54 <mapf> b__ isn't nice font lock in emacs do the job?
08:18:18 <b__> I use vim
08:18:39 <mapf> through i have then () is prettified then i don't want
08:18:47 <mapf> s/have/hate
08:18:56 * fmap uses -XUnicodeSyntax even in ghci
08:19:56 <ion> Alas, UnicodeSyntax doesn’t make ghci print things like types using UnicodeSyntax.
08:21:47 <quuuux> > let p → q = not (p || q)
08:21:48 <lambdabot>   <no location info>: parse error on input `
08:22:20 <b__> might be better though to write myself a plug-in for vim that does not actually modify the buffer I write to disk
08:22:44 <b__> so I can use more symbols without making my files unusable to others
08:23:02 <frerich> b__: Maybe https://github.com/frerich/unicode-haskell is useful to you (it injects Unicode when loading files from disk and replaces them back to ASCII when writing); there's a screenshot on the page to show what it looks like
08:23:18 <merijn> b__: Just add the pragma to enable it and GHC will fix things for you?
08:23:59 <b__> merijn I want to use symbols beyond the tiny subset that is available through the pragma
08:24:39 <Cale> b__: What do you mean?
08:25:06 <merijn> Cale: The pragma affects syntax, operator and function names can use unicode always
08:25:16 <Cale> merijn: yes, I know that
08:25:26 <merijn> eh
08:25:29 <merijn> misdirection :p
08:25:33 <merijn> I meant b__
08:25:46 <Cale> I guess you explained why I was confused by b__'s statement :)
08:25:54 <merijn> > let (☃) = (+) in 3 ☃  6
08:25:55 <lambdabot>   9
08:26:21 <merijn> No pragma necessary :)
08:28:08 <ion> The vim script doesn’t handle the width differences between things like -> and →, does it? You’ll have to be careful about layout then.
08:29:21 <b__> oh merijn who
08:29:23 <b__> wow*
08:29:35 <b__> didn't really know that, thanks
08:30:07 <nominolo> is there a way to stop cabal from specifying --disabl-benchmarks when using an old GHC?
08:30:12 <Cale> ion: yeah, that's what implicitly troubles me about UnicodeSyntax
08:30:38 <Cale> ion: It isn't possible to simply search and replace it with ordinary syntax, because it affects layout
08:31:20 <merijn> b__: GHC by default treats all source as unicode and except for a small number of characters all unicode characters are allowed in names and operators (depending whether they're on the operator code plane or not)
08:31:39 <b__>  but I take it from some of the comments here that it's a bad idea to use this pragma?
08:32:37 <merijn> Personally I feel it's a bit unnecessary
08:32:50 <Cale> b__: UnicodeSyntax lets you replace -> by an actual Unicode arrow and such
08:33:30 <Cale> which never quite looks right to me, for some reason
08:33:37 <Cale> the arrow is too small :)
08:34:01 <Cale> and it's hard to convert things in UnicodeSyntax to non-UnicodeSyntax, because layout is affected
08:34:12 <Cale> (search and replace will break the file)
08:34:18 <merijn> Ok, I have some code I need help cleaning up. I just can't find more readable ways of writing
08:34:22 <merijn> fromList <$> (mapM (<$> newChan) (map (,) tags))
08:34:24 <dylukes> The only thing I use UnicodeSyntax for ever is operators.
08:34:34 <b__> Cale it depends on the font
08:34:35 <dylukes> Set operations are nicer with operators.
08:35:22 <merijn> Basically, I want "[a] -> IO [(a, Chan v)]"
08:35:31 <b__> The arrows in Adobe Source Code look nice
08:35:45 <dylukes> ASCP is generally pretty nice.
08:35:47 <merijn> Or rather, I guess "[a] -> IO (Map a (Chan v))"
08:35:53 <dylukes> I use ASCP and Lucida Grande mostly.
08:36:27 <b__> yeah it is quite nice though takes a while to get used to
08:36:36 <dylukes> I actually like the Light version on my retina display.
08:36:40 <b__> I don't think it works as well as Consolas, but I am giving it a try anyway
08:36:56 <dylukes> I like it a little more than consoles for some reason.
08:38:07 <b__> dylukes, now that I'm trying it, light looks pretty good, even on my non-retina Air
08:39:00 <dylukes> some things with it (such as !) don't look very good w/o high density.
08:39:46 <typoclass> dylukes: ... or modern font rendering, but that's another issue
08:40:52 <chreekat> Does cabal complain about GHC_PACKAGE_PATH for other people using virthualenv, or is it just me
08:41:03 <sky_> @pl \x -> x `xor` (x - 1)
08:41:04 <lambdabot> ap xor (subtract 1)
08:46:39 <asante> i'm trying to count letters in a file. so i read that file with "readFile path" but when running that code with an existing file, i get a "hGetContents: invalid argument (invalid byte sequence)" error
08:47:43 <hpaste> asante pasted “readFile” at http://hpaste.org/76088
08:47:44 <c_wraith> asante: that's an encoding error. GHC defaults to your system encoding. The file you're reading must not be in that encoding
08:48:41 <merijn> Is there a reason (a, b) isn't an instance of Foldable and Traversable?
08:49:13 <c_wraith> merijn: edwardk complained about that same thing when he started writing the lens package
08:49:18 <merijn> Seems (a,) it should trivially map to the implementation of Maybe
08:49:28 <c_wraith> merijn: so..  no, there isn't a reason
08:49:42 <c_wraith> merijn: and it's simpler than that.  It should be the implementation for identity
08:49:44 <merijn> Off to libraries@haskell.org I go
08:50:04 <merijn> That'll teach them to let me subscribe to that list :p
08:53:15 <sixohsix> man… so today I learned: do not use the String type for _anything_ ever. Use Data.Text.
08:53:28 <sixohsix> reduced memory footprint from 100+ mb to 30 mb.
08:53:51 <merijn> sixohsix: :)
08:53:52 <c_wraith> String is fine for things that are only 10 characters long.
08:53:56 <sixohsix> decreased startup time to like 30% of what it was before.
08:54:19 <sixohsix> c_wraith: true… but if you have a few hundred or thousand of those things...
08:55:37 <merijn> Is (a,) at least a functor?
08:55:38 <sixohsix> i'm writing a text editor and I do all my testing with a 147,000 line text file. It finds performance issues quickly, let me tell ya. :)
08:55:52 <merijn> > fmap (+1) ('c', 0)
08:55:53 <lambdabot>   ('c',1)
08:56:01 <merijn> Oh, wait is that just lambdabot...
08:56:20 <merijn> Apparently that works, at least
08:58:07 <mbuf> for a mapM_ function [a] operation, is it possible to temporarily store the exit status of the execution of each function?
08:58:24 <c_wraith> mbuf: try mapM instead
08:59:15 <c_wraith> sixohsix: actually, Text is inefficient for lots of very small chunks, such that String isn't really any worse. It's when chunks get bigger that Text has huge advantages
08:59:30 <mapf> sixohsix: how do you implement editing? through zippers?
09:00:30 <ksf> sixohsix, we do have a haskell editor, btw. It's called yi.
09:00:55 <sixohsix> mapf: it's much more naive than that. the buffer is essentially (Data.Sequence.Seq Data.Text).
09:00:58 <mapf> list are like iterators for more appropriate structures like Text. long living objects should not use list
09:00:59 <sixohsix> this is good enough for now.
09:01:03 <ksf> granted, the code is not for the faint of heart.
09:02:04 <sixohsix> ksf: yeah, i wanted to make my own mistakes before i looked into yi's mistakes. :P
09:02:29 <sixohsix> as a learning project, writing an editor is great.
09:02:35 <mbuf> c_wraith: thanks!
09:02:38 <mapf> sixohsix: hm, finger trees could be degradated with the time, but i don't know
09:02:52 <tac> Yi's biggest mistake was no one loved it.
09:03:02 <mapf> tac: why?
09:03:20 <tac> IIRC, it was originally a project of... I think Dons?
09:03:22 <danharaj> Does Yi build nowadays?
09:03:25 <tac> For some paper
09:03:29 <ksf> yi's biggest drawback is an ex mode that's a bad joke, and /me not getting around fixing it, partly due to vim.
09:03:44 <tac> Then it was repeatedly abandoned by others who picked it up as a hobby.
09:03:48 <ksf> danharaj, yes, it does.
09:04:17 <ksf> ...apperently there's no english term for "leidensdruck".
09:04:31 <sixohsix> mapf: flying through the middle of the 147,000 line file is slightly slower due (probably) to tree lookups, but not enough to be a concern.
09:04:34 <ksf> ..."suffering pressure".
09:04:42 <ksf> it itches, but it's not my leg ;)
09:06:08 <asante> is it possible to change the encoding for hgetcontents, instead of changing the encoding of the file?
09:06:17 <ksf> hSetEncoding
09:06:25 <asante> ah, thx ksf
09:06:42 <ksf> or use the strictly byte-oriented functions from Data.ByteString
09:10:27 <mapf> sixohsix: So, Data.Sequence is the whole text of buffer and Data.Text is a line?
09:10:41 <sixohsix> yes, exactly.
09:14:52 <mapf> i'm just thinking why do you use Sequence. Is it support fast insertions in middle of sequence?
09:16:23 <sixohsix> yeah, fast insertion anywhere in the file. able to copy and paste large segments of lines. able to store complete buffer states for undo with tiny memory use.
09:18:44 <mapf> ha, persistent data structures is great for undoing!
09:42:03 <monochrom> @messages
09:42:04 <lambdabot> You don't have any new messages.
09:44:42 <__name__> hello.
09:45:08 <__name__> i keep finding more or less unbased claims that hugs is the best for educational purposes, could anyone elaborate why that might be the case?
09:45:52 <nand`> the claim goes that GHC has confusing error messages or something
09:45:59 <nand`> personally I used ghc from the start and see nothing wrong with it
09:46:06 <nand`> error messages are most confusing when you don't read them
09:46:34 <__name__> nand`, Oh, thank you :)
09:48:25 <monochrom> ghc does not have confusing error messages. it has professional error messages.
09:49:03 <Cale> @ghc
09:49:03 <lambdabot> ghc says: Couldn't match type `No' with `Yes'
09:49:04 <kartoffelbrei> but they are kind of big and scary for beginners
09:49:08 <Cale> @ghc
09:49:08 <lambdabot> ghc says: Inferred type is less polymorphic than expected
09:49:12 <Cale> @ghc
09:49:13 <lambdabot> ghc says: lexical error in string/character literal
09:49:14 <kartoffelbrei> at least they were for me
09:49:15 <monochrom> they tell you way more technicalities than a novice can understand.
09:49:17 <Cale> @ghc
09:49:18 <lambdabot> ghc says: Multiple default declarations
09:49:38 <kartoffelbrei> monochrom: exactly
09:49:41 <Cale> @ghc
09:49:41 <lambdabot> ghc says: In a case expression, type of scrutinee does not match patterns
09:50:21 <kartoffelbrei> @ghc
09:50:21 <lambdabot> ghc says: Duplicate binding in parallel list comprehension
09:50:22 <monochrom> it also doesn't help that ghc accomodates a lot more extensions. even though you turn them all off, those extensions mean a very generalized type-checking algorithm underneath that must emit very technical error messages
09:50:53 <nand`> “ghc says: My brain just exploded” <- where's that one? :(
09:50:55 <monochrom> hugs error messages are simpler because hugs is simpler and written for novices
09:51:49 <quuuux> nand`: that's a (GHC error) message, not a GHC (error message)
09:51:50 <mapf> nand`: yep.
09:51:55 <monochrom> haha
09:52:17 <klr> where is BONUS,the learnyouahaskell author?
09:52:26 <nand`> spirited away
09:52:33 <Cale> klr: good question, he hasn't been on IRC in quite a while
09:52:41 <Cale> preflex: seen BONUS
09:52:41 <preflex>  Sorry, I haven't seen BONUS
09:52:42 <klr> hmm, okey
09:52:44 <nand`> Haskellers have a tendency to disappear from IRC completely after releasing a book
09:52:45 <Cale> huh
09:52:49 <Cale> lol
09:52:50 <kartoffelbrei> nand`: wasn't that about pattermatching GADTS in function arguments/bindings or something
09:52:59 <Cale> bos: still with us? :)
09:53:00 <nand`> kartoffelbrei: with existential types
09:53:04 <nand`> and yeah
09:53:22 <klr> okey, anyway, what is "set comprehensions"?
09:53:51 <Cale> klr: The notation from mathematics where you restrict the elements of a set to those which satisfy a given condition
09:53:54 <mapf> klr: {a | a <- b, ...}
09:54:12 <klr> hmm, i havent done this in school =o
09:54:13 <Cale> {x in Q : x^2 < 2}
09:54:24 <Cale> you've never seen anything like that?
09:54:26 <bos> Cale: more or less
09:54:34 <klr> Cale: nope
09:54:35 <nand`> some schools don't teach formal logic or set theory in maths classes, I cannot possibly imagine why
09:54:57 <kartoffelbrei> nand`: that's just beyond sad
09:55:00 <klr> I'm in swedish elementary school, perhaps we got a bad math school plan...
09:55:02 <danharaj> nand`: at my uni it was pretty much expected that you already knew it or would learn it by osmosis.
09:55:05 <Cale> nand`: Even my shitty grade 10 highschool math class managed to introduce set comprehensions though
09:55:26 <nand`> danharaj: well by uni I'd expect every sane person to have picked it up manually if the school neglected it
09:55:46 <danharaj> It depends on what you mean by formal logic :P
09:56:14 <klr> lol, i feel retarded stupid and dumb, i'll try to search the www again
09:56:25 <danharaj> please don't use the word retarded like that :3
09:56:30 <Cale> klr: So, it's a fundamental assumption about sets, that if A is any set, and P(x) is any predicate on the elements of A, then there is a set which consists of exactly the elements x of A for which P(x) is true.
09:56:37 <nand`> well, for example the various models of logical truths and implications and whatnot
09:56:57 <Cale> klr: and that is written {x in A: P(x)}
09:57:02 <clahey> klr: You're in elementary school and learning?  That's awesome.
09:57:09 <clahey> Learning this, I mean.
09:57:17 <clahey> klr: Don't feel stupid or dumb.
09:57:31 <klr> clahey: i try
09:57:32 <clahey> klr: It's not your fault if you school hasn't taught you something yet.
09:57:49 <arkx> klr: it's not a bad school plan, just egalitarian.
09:57:56 <nand`> interestingly enough, my school tends to use logic or set theory without ever having covered it with rigor; eg. you'll see stuff like A∩B to represent the intersection between vectors or probabilities
09:58:02 <arkx> klr: if you're ready to tackle sets already, you can do it on your own.
09:58:35 <mapf> once i started read Haskell Curry book "Introduction to Logic" and thats been really "i fell reatrded stupid and dumb"
09:58:39 <MostAwesomeDude> (Americans, FYI, "Elementary school" in Sweden is nine years, IIRC.)
09:58:44 <nand`> klr: the best way to circumvent frustration with the school system is to self-learn
09:58:56 <Cale> klr: More generally, people tend to write things like {f(x,y) : x in A, y in B, ... some conditions on x and y ...} to mean the set of all values f(x,y) where x is any element of A, and y is any element of B, and the conditions on x and y hold, etc.
09:58:58 <MostAwesomeDude> (Not that it isn't awesome that a ninth-grader is learning Haskell. That's pretty awesome.)
09:59:02 <nand`> if you're capable of gaining the knowledge you need yourself, you become independent of the school and/or its failures
09:59:06 <klr> Cale: thanks for your explaination, i think ill try to find a explaination in swedish, there is some words i dont understand
09:59:13 <nand`> MostAwesomeDude: oh. I figured he'd be in 4th grade or something
09:59:30 <edwardk> @hpaste
09:59:31 <lambdabot> Haskell pastebin: http://hpaste.org/
09:59:32 <kartoffelbrei> me too, i was kinda stunned by that
09:59:42 <nand`> it gave me hope
09:59:50 <hpaste> edwardk pasted “hoas-to-bound” at http://hpaste.org/76090
09:59:57 <nand`> hope for a future where Haskell is the first programming language people are introduced to at young ages
10:00:15 <quuuux> bah, that'll only promote laziness in the youth
10:00:15 <edwardk> so i'm playing around with a nice little dsl, and wanted to use hoas for the representation i show to the end user
10:00:25 <edwardk> and work internally with my 'bound' library.
10:00:33 <edwardk> trying to figure out a nicer conversion between the two
10:00:43 <edwardk> i was able to derive the version i just hpasted: http://hpaste.org/76090
10:01:09 <nand`> Hoas?
10:01:11 <edwardk> but ideally i'd like to kill the use of Int's to count scopes because it requires me to flatten things inappropriately it seems
10:01:13 <kartoffelbrei> i'm not sure how haskell would feel as your first language, though. It was so radically different and exciting, precisly because i learned procedual and OOP languages in advance.
10:01:16 <edwardk> higher order abstract syntax
10:02:04 <edwardk> here i'm using ken, oleg and jacques' "finally tagless" representation to start off, then converting to something that sucks less to work with
10:02:17 <edwardk> example1 = lam $ \x -> lam $ \y -> x `app` y `app` free "z"
10:02:23 <nand`> kartoffelbrei: I think it, or pure/declarative/equational programming in general, fits much better with the system of mathematics we tend to be exposed to at young ages, the algebra of rings, equations and substitutions
10:02:32 <edwardk> gives you a term, then the 'locallyNameless' function converts that to something that isn't terrible
10:02:49 <edwardk> but its kind of galling that i need to start with 'undefined' as my bound variable base case
10:02:58 <nand`> which is why I really want to know what it feels like to learn it first
10:03:52 <nand`> oh, I thought your Hoas was an existential there and got confused
10:04:00 <nand`> yes that makes sense
10:04:21 * theorbtwo was exposed to imperitive programming before much, if any, algebra.
10:04:30 <edwardk> basically i'm trying to figure out a nice way to encode things that gets rid of the two Int's
10:04:54 <edwardk> maybe by using an HList of bound variable scopes and an index into it or something like that
10:05:06 <edwardk> that would kill the need to handle exotic terms
10:05:17 <edwardk> and i also realize i'm mostly talking to myself ;)
10:05:20 <danharaj> edwardk: What about using a representation that disallows exotic terms?
10:05:22 * nand` was introduced to the concepts of natural numbers, addition, subtraction and multiplication around the age of 4 or 5, well before imperative programming (around age 9)
10:05:26 <mapreduce> life thru a lens
10:05:29 <edwardk> danharaj: the target representation does
10:05:33 <klr> it's a bit frustrating, each time i read a programming book i always get stuck on chapter 1 or so -.-
10:05:54 <nand`> klr: because of the language barrier or the knowledge barrier?
10:06:52 <klr> nand`: mostly due to my lack of knowledge about math and english, i simply can't understand some stuff, i dont understand how i can get C and B in math in school, but in real life can't do anything...
10:07:18 <nand`> I guess it depends on what kind of programming books you're picking up
10:07:20 <theorbtwo> nand`: well, yes, but it's not like those aren't used equally in haskell and imperitive languages.
10:07:26 <endojelly> simple question, but I forgot: what exactly constitutes rank-2 polymorphism?
10:07:32 <nand`> “Category Theory for Computing Science” may not be the best starting point, for example
10:08:04 <nand`> endojelly: a universal quantifier to the left of two nodes if you represent the type as a tree
10:08:46 <klr> nand`: i've read(or rather tried to read) k&r and now leanyouahaskell, i also read some chapters in How to design programs by MIT
10:08:47 <nand`> in practical terms, if an argument to a function is itself quantified; for example: f :: (forall a. a -> a) -> (Int, Char) -> (Int, Char)
10:08:57 <nand`> I could implement f as:   f g (i, c) = (g i, g c)
10:09:10 <Cale> endojelly: parameters to functions are allowed to be forall quantified
10:09:17 <nand`> since the type of ‘g’ itself is polymorphic; I can use it as if it were any other polymorphic function, on both an Int and a Char
10:09:50 <nand`> this is distinct from f :: forall a. (a -> a) -> (Int, Char) -> (Int, Char)  which would make the above definition illegal
10:09:58 <pxz> @help
10:09:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:10:09 <kartoffelbrei> klr: where did you get stuck in learn you a haskell? maybe we can help.
10:10:38 <endojelly> nand`, ah! your last line cleared it up. got it, thanks!
10:10:40 <nand`> note that if you go further; eg. f :: (forall b. (forall a. a -> a) -> b -> b) -> c -> c; then you have a rank 3 type (since the parameter is itself a rank 2 type); and you'd need RankNTypes
10:11:36 <endojelly> nand`, right now I have difficulties imagining a scenario where you'd need more than rank 2 types, but that's just because I haven't looked. do you know any example?
10:11:37 <Cale> endojelly: Or more precisely, forall quantifiers are *not* permitted to the left of 2 or more arrows (but are allowed to the left of 0 or 1 arrows, so you're allowed (forall s. A s) -> T, for example
10:12:00 <klr> kartoffelbrei: "I'm a list comprehension" in chapter one, but it makes no point, i dont even know what "comprehensions" is or the word "predicate" for example.. (thanks for your offering help though :-) )
10:12:03 <nand`> endojelly: not immediately, I tend to use rank 2 types where higher-rank types are necessary
10:12:29 <nand`> but it can show up where perhaps not expected if you use type synonyms which themselves contain abstractions, eg. for something like lenses
10:12:56 <nand`> (by abstractions I mean ‘forall’)
10:13:17 <Cale> klr: A predicate is like a function whose result is either true or false.
10:13:37 <Cale> klr: A statement which may or may not be true of something
10:13:48 <klr> hmm
10:13:52 <endojelly> nand`, I see. that makes a lot of sense.
10:13:53 <klr> i kind of get it
10:14:10 <klr> so, a predicate is a function which may only return a boleon?
10:14:13 <Cale> yeah
10:14:25 <klr> okey that makes it a bit clearer :-)
10:14:47 <endojelly> Cale, hmm, I think I'm misunderstanding this. (forall a . a -> a -> a) -> b is not illegal, or is it?
10:14:51 <Cale> Though in formal logic, they tend to be something which is built into the logic and not treated quite the same way as general functions perhaps would be.
10:15:08 <Cale> endojelly: that's rank-2
10:15:12 <nand`> endojelly: perhaps noteworthy is the fact that rank-n types (for n ≥ 3) can not be inferred automatically. rank-2 types *can* be inferred, but afaik GHC doesn't do it. rank-1 types can be inferred eg. by algorithms like HM
10:15:39 <mapf> klr: matematician use words predicate and functional to type functions
10:15:43 <endojelly> Cale, okay, so "more than two arrows" means... aah, I see it now. what I did was actually (forall a . a -> (a -> a)) -> b, and that's left of one arrow, right?
10:15:45 <mapf> intuitively
10:15:52 <klr> mapf: okey
10:15:56 <Cale> endojelly: right
10:16:12 <endojelly> Cale, great, thanks.
10:16:13 * hackagebot classy-prelude 0.3.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.3.1 (MichaelSnoyman)
10:16:15 * hackagebot classy-prelude-conduit 0.3.1 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.3.1 (MichaelSnoyman)
10:16:17 * hackagebot keter 0.3.0 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.0 (MichaelSnoyman)
10:16:20 <bfgun> can i use a type alias to redefine typeclasses?
10:16:24 <klr> god, wish i've learned math from the english perspective, sometimes the swedish words are completly differend
10:16:28 <endojelly> nand`, that *is* interesting, yes
10:16:42 <Cale> endojelly: ((forall a. a -> a) -> r) -> r would be a rank 3 type
10:17:17 <mapf> klr: for exsample? in russian it's almost the same i think
10:17:18 <Cale> bfgun: no, the type alias isn't a genuinely new type
10:17:24 <bfgun> :(
10:17:26 <Cale> bfgun: but you can use newtype
10:17:32 <nand`> endojelly: if you take (->) as nodes in a tree and its operands as branches; then the top node is (->) to the right of which is ‘b’ and the left of which is ‘forall a. a -> a -> a’; which has a quantifier and is to the left of one node. That itself is divided into ((->) a ((->) a a)), which has no more quantifiers
10:17:52 <bfgun> too messy :(. i wanted to override the horrible show function
10:17:59 <kartoffelbrei> klr: predicates are funtions that usually take one argument and return either True or False. Thus the function: isGreaterThenThree x = x > 3  is a predicate
10:18:19 <bfgun> sorry i alt+w without meaning it
10:18:23 <klr> mapf: i did translate "comprehension" to swedish with my dictionary, then i googled the answer and checked on wikipedia, didn't find anything related to mathematics
10:18:27 <Cale> bfgun: you could likely just write a separate function T -> String?
10:18:27 <nand`> bfgun: depending on what you're doing you'd either want a newtype to give it new semantics, or you'd use a different function (which has different semantics)
10:18:45 <klr> kartoffelbrei: okey
10:18:48 <bfig> Cale, yeah that's what i did but i'd prefer to be able to override Show :(
10:18:58 <nand`> bfig: which type are you overriding and for what purpose?
10:19:05 <bfig> just show n
10:19:08 <bfig> nand`, ^
10:19:14 <Cale> klr: yeah, I was hoping to translate it using wikipedia's language links, but it seems there isn't a page
10:19:19 <nand`> bfig: I meant the Show instance for which type?
10:19:28 <Ferdirand> the purpose of Show is to create strings that can be evaluated back to what is shown, right ?
10:19:30 <bfig> nand`, Vector2
10:19:33 <nand`> Ferdirand: no, not really
10:19:39 <nand`> Ferdirand: it's more or less arbitrary
10:19:44 <klr> but in learnyouahaskell, it tells that x < 10 is a predicate, but x < 10 does return 12345678910, not true or false?
10:19:45 <endojelly> Cale, nand`, got it, thanks!
10:19:51 <nand`> I would go ahead and claim the purpose of Show is to give the repl something to output
10:20:12 <Ferdirand> nand`: oh, ok. I've heard criticism about using Show for pretty printing because it was not meant to be that way
10:20:18 <bfig> it prints {Vector2 v2x = , v2y = .. } instead of something more compact like  <x,y>
10:20:19 <nand`> yeah
10:20:42 <danharaj> edwardk: Reference to where finally tagless representation is defined/
10:20:43 <danharaj> ?
10:20:44 <nand`> you'd use your own prettyPrint :: ... -> String for that purpose, imo
10:20:44 <bfig> because i want to print huge lists and i want to read them in ghci i need a better way :p
10:20:45 <endojelly> Cale, now what makes ranks > 2, e.g.  ((forall a. a -> a) -> r) -> r, so different that they aren't (immediately) allowed? intuitively, I mean?
10:20:58 <nand`> bfig: that does make sense, yeah
10:21:10 <edwardk> danharaj: http://www.cs.rutgers.edu/~ccshan/tagless/jfp.pdf
10:21:14 * hackagebot network-conduit 0.6.1 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.6.1 (MichaelSnoyman)
10:21:16 * hackagebot network-conduit-tls 0.6.0 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-0.6.0 (MichaelSnoyman)
10:21:21 <Cale> klr: x < 10 is a predicate on x in the sense that it's something which might or might not be true of any particular x
10:21:34 <arkx> klr: http://www.ida.liu.se/~TDDC75/info/misc/sets.pdf
10:21:37 <Cale> klr: 5 < 10 is true, while 19 < 10 is not
10:21:41 <edwardk> danharaj: http://www.haskell.org/pipermail/haskell-cafe/2010-June/078780.html shows me using it to define a pi calculus using IO
10:22:03 <klr> arkx: ill check that later, i dont have a pdf viewer
10:22:05 <kartoffelbrei> klr: but x > 10 does return a boolean
10:22:29 <kartoffelbrei> > :t \x -> x > 10
10:22:30 <lambdabot>   <no location info>: parse error on input `:'
10:22:35 <kartoffelbrei> :t \x -> x > 10
10:22:36 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
10:22:40 <klr> Cale: okey, but it feels strange that he use that when x < 10 is used to get a list of numbers, not true or false?
10:22:46 <klr> kartoffelbrei: it does?
10:22:57 <Cale> klr: do you mean in the case of something like:
10:23:02 <nand`> Nu? I thought that was called Mu? Or is Mu more often used for the ‘indexed’ version?
10:23:08 <Cale> > [x | x <- [1..20], x < 10]
10:23:09 <lambdabot>   [1,2,3,4,5,6,7,8,9]
10:23:19 <klr> Cale: exactly
10:23:30 <Cale> klr: here, we're selecting x from the list [1..20], and we're adding the condition that x must be less than 10
10:23:45 <Cale> So any x which doesn't satisfy this condition will be thrown out
10:23:57 <klr> okey
10:24:00 <edwardk> its least vs. greatest fixed point. they coincide in Haskell, but "Nu" is bigger in other settings
10:24:05 <kartoffelbrei> the result is not a number, but a  list of numbers. kind of like a set
10:24:11 <klr> ill try read everything again :-)
10:24:17 <nand`> edwardk: oh, okay
10:24:27 <Cale> klr: We can impose quite interesting conditions, for example, I can use this to look for triples of numbers (x,y,z) so that x^2 + y^2 = z^2
10:24:46 <Cale> > [(x,y,z) | x <- [1..20], y <- [x..20], z <- [y..20], x^2 + y^2 == z^2]
10:24:47 <lambdabot>   [(3,4,5),(5,12,13),(6,8,10),(8,15,17),(9,12,15),(12,16,20)]
10:24:56 <Cale> > 3^2 + 4^2
10:24:58 <lambdabot>   25
10:25:00 <Cale> > 5^2
10:25:02 <lambdabot>   25
10:25:33 <klr> Cale: hmm, that i dont understand, but ill focus on comprehension lists/sets for now
10:25:37 <edwardk> nand`: a fun exercise is converting between each of these: newtype Mu f = Mu { runMu :: forall r. (f r -> r) -> r }; data Nu f = forall a. Nu a (a -> f a); newtype Fix f = In { out :: f (Fix f) }
10:26:04 <edwardk> and then you can reason about them by analogy to folding, unfolding, and just stuffing crap in the environment ;)
10:26:18 * hackagebot disjoint-set 0.1 - Persistent disjoint-sets, a.k.a union-find.  http://hackage.haskell.org/package/disjoint-set-0.1 (MaxwellSayles)
10:26:47 <Cale> klr: So that says, the list of all (x,y,z) where we pick x from the list [1..20], and pick y from the list [x..20], and pick z from the list [y..20] (this ensures that x <= y <= z), and then make sure that x^2 + y^2 == z^2
10:27:43 <Cale> we could also do it a little more simply, but we'll get "duplicates" of sorts:
10:27:51 <Cale> > [(x,y,z) | x <- [1..20], y <- [1..20], z <- [1..20], x^2 + y^2 == z^2]
10:27:53 <lambdabot>   [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(8,6,10),(8,15,17),(9,12,15),(12,5,13),...
10:28:16 <kartoffelbrei> klr: the "[(x,y,z) | x <- [1..20], y <- [x..20],  z <- [y..20]" part constructs a list of all possible triples from (1,1,1) to (20,20,20) and the ", x^2 + y^2 == z^2]" filters them and keeps only the triples which return true through that expression
10:28:26 <bfig> dammit gvim and mouse missclicks
10:28:59 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
10:29:01 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
10:29:20 <nand`> edwardk: what, like forall f. Mu f -> Nu f -- ?
10:29:26 <danharaj> edwardk: does it matter that you say `runLN h 0 ...`? If I understand correctly `runLN h i ...` would work for any integer i.
10:29:48 <klr> im sry but i don't understand anything...
10:30:00 <edwardk> danharaj: probably
10:30:10 <edwardk> nand`: with Functor constraints on f as appropriate
10:30:49 <Cale> klr: well, stare at some examples and perhaps play around with it a bit and you'll start to get the idea I'm sure
10:30:52 <kartoffelbrei> klr: try to type these coprehensions in ghci and mess with them to see what happens, maybe that makes more sense then us talking gibberish
10:31:14 <Cale> > [x + y | x <- [10,20,30], y <- [4,5]]
10:31:15 <lambdabot>   [14,15,24,25,34,35]
10:31:42 <mapf> klr: you can just use filter and map instead
10:31:48 <Cale> (and concat)
10:31:57 <mapf> Cale: yep
10:32:19 <joeyh> is there any trick to simplify (\x y -> Just $ foo x y) ? If there were only one parameter, I'd (Just . foo) of course..
10:32:28 <kartoffelbrei> :t on
10:32:29 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:32:31 <mapf> klr: (Just .) . foo
10:32:47 <mapf> s/klr/joeyh
10:32:56 <klr> okey, here is the example in the book "S = { 2*x | x -> N, x < 10 }" does this means S is equal to the product of x multiplied with 2, and X is N only if it's less than 10 ?
10:33:55 <mapf> :t (Just .) . (<>)
10:33:56 <lambdabot> Doc -> Doc -> Maybe Doc
10:34:38 <Cale> klr: I believe the -> should really be a symbol like ∈
10:34:55 <endojelly> stupid question maybe, but now that I have thought about forall in types, does existential quantification make any sense there at all?
10:35:01 <Cale> klr: and it means that S is the set of values 2*x where x is in the set N, and x is less than 10
10:35:02 <klr> Cale: yes, didnt know how to write the symbol or what it means, sry about that
10:35:14 <mapf> klr: is like [2 * x | x <- a, x < 10]
10:35:16 <danharaj> edwardk: ok I think I understand the ugliness now. I don't think it is that ugly though :P
10:35:31 <nand`> endojelly: forall b. (exists a. (a, a -> b)) -> b -- should be a valid type
10:35:36 <Cale> If S is a set, then x ∈ S means that x is a member of that set.
10:35:36 <edwardk> danharaj: well, with bound i can do things like bind a lot of names at the same time
10:35:37 <mapf> where a is list of some numbers
10:35:41 <edwardk> with a flat Int that is harder
10:36:04 <klr> my mind is messed up, ill try firgure out by trying stuff in ghci ...
10:36:15 * hackagebot halfs 2.0 - The HAskelL File System ("halfs" -- intended for use on the HaLVM)  http://hackage.haskell.org/package/halfs-2.0 (JoelStanley)
10:37:12 <dd> stick with it klr, it better not to mess up your mind with OO and imperative programming first
10:37:21 <nand`> oh wait, there's no exists keyword in Haskell, but you can hide it behind an existential data type
10:37:33 <mapf> actually i don't like list comprehensions and don't use them at all. (>>=), map, filter is more composable i think
10:37:45 <Cale> klr: N (especially in a typeface which looks like this: http://en.wikipedia.org/wiki/Blackboard_bold) is often used to represent the set of natural numbers: {0, 1, 2, 3, ...}
10:38:16 <endojelly> nand`, if it existed, what would be the difference to the same type without the existential quantification?
10:38:19 <nand`> data App b = forall a. App (a -> b) a;  f :: forall b. App b -> b
10:38:23 <danharaj> edwardk: ah, so the ugliness would be worse in the other direction, Exp a -> Hoas a?
10:38:27 <klr> thanks for all help, ill take a break before i get too mad at myself, have nice day
10:38:40 <edwardk> danharaj: well that direction is largely a non-issue to me
10:38:42 <klr> have a nice day*
10:38:44 <Cale> klr: In that case, the set S being described would be {2*0, 2*1, 2*2, 2*3, 2*4, 2*5, 2*6, 2*7, 2*8, 2*9}
10:38:50 <Cale> heh
10:39:00 <edwardk> danharaj: i want to go from the nice to write form to the nice to work with form ;)
10:39:14 <tibbe> what's the best way to convert from a boxed Vector to an unboxed Vector and vice versa
10:39:16 <tibbe> ?
10:39:26 <kartoffelbrei> klr: don't get mad at yourself
10:39:29 <nand`> endojelly: ‘exists’ means there's some type, but your code can't actually know what it is; so the caller can pass anything - but unlike polymorphism+instantiation the types are still the same when applied, so you could store them in a list or something
10:41:13 <nand`> see my ‘App’ example; map f :: forall b. [App b] -> [b] -- is a perfectly valid type, even though the expanded pseudo-type :: forall b. [exists a. (a, a -> b)] -> [b]  -- essentially allows you to use different ‘a’s for different elements of the list
10:41:21 <endojelly> nand`, ah. I think I know what you mean. unlike polymorphism, there's still just one function
10:41:25 <Jetbeard> Hi all. I'm doing some parsing with parsec. I understand the monad operator (>>) is useful, as I can parse one thing, throw away the result, and then parse another thing.
10:41:31 <danharaj> edwardk: could you give an example that illustrates the problem? I haven't used bound before so I'm not entirely sure where I'm thinking towards.
10:41:37 <Cale> Jetbeard: right
10:41:40 <Jetbeard> Is there a similar combinator that instead throws away the right-hand argument?
10:41:59 <Cale> Jetbeard: you might like *> and <* from Applicative
10:42:34 <dd> So I'm reading about Applicative Functors now.  I have a question, I get fmap for functors and <*> for applicatives, I also understand what pure does, or at least I think I do, my question is, why is pure defined in Applicative as opposed to some other class like functor?
10:42:38 <Cale> Jetbeard: which throw away the result of the argument on the side where the star is (the arrow points at the parser whose result is returned)
10:42:40 <edwardk> danharaj: one example is I like to use things like Let :: [Scope Int Exp a] -> Scope Int Exp a -> Exp a
10:42:46 <edwardk> danharaj: there i'm binding n variables at once
10:42:51 <edwardk> in this form i have to count them
10:42:57 <edwardk> but what happens when n is infinite? =)
10:42:57 <Cale> dd: Because you don't need pure to be a functor
10:43:08 <Jetbeard> ah, Cale, awesome :D so (*>) is equivalent to (>>)?
10:43:16 <nand`> dd: it's not in functor because not all functors have pure
10:43:18 <edwardk> nothing _requires_ me to bind a finite number of variables at a time
10:43:23 <endojelly> nand`, yap, okay, makes sense, thanks
10:43:32 <Cale> dd: However, if we wanted to have an ultra-fine class hierarchy, we could have a class for pointed functors
10:43:43 <Cale> dd: which would sit in between Functor and Applicative with pure
10:43:58 <nand`> dd: and it's in applicative because applicative functors need pure to be called that. There could hypothetically be some other class of functors that also needs it, but that's simply how things are laid out in the Prelude
10:44:23 <nand`> dd: for example, category-extras (or whatever the package it got split off into is called now) has ‘class Pointed’, which is for functors that have just ‘pure’ but not <*>
10:44:27 <nand`> but it's not very useful
10:44:32 <dd> I was just wondering because fmap and <*> seem analoguous but there is no equiv for pure
10:44:33 <edwardk> dd: though if you break up the structure more, then you are torn between making a class class with only (<*>) and not 'pure'    or one with pure and not (<*>) and the former is more useful to a mathematician
10:44:44 <Cale> It might be worth pointing out that there's another way to look at the Applicative class.
10:45:07 <Cale> :t liftA2 (,)
10:45:09 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
10:45:15 <danharaj> edwardk: ah I see. So I should imagine Exp a has a Let clause that binds a potentially infinite list of variables and now we need a finally tagless representation that can handle that.
10:45:26 <edwardk> danharaj: yep
10:45:29 <Cale> Applicative functors are functors which have ^^ that sort of operation
10:45:51 <nand`> :t let eval (f, x) = f x in fmap eval . liftA2 (,)
10:45:53 <lambdabot> forall t a b. (Monoid t) => ((a, b) -> t, a) -> ((a, b) -> t, b) -> t
10:45:56 <nand`> :t let eval (f, x) = f x in fmap eval .: liftA2 (,)
10:45:58 <lambdabot> forall t t1 (f :: * -> *). (Applicative f) => f (t -> t1) -> f t -> f t1
10:46:20 <dd> I see
10:46:20 <nand`> hoho, eval = uncurry id
10:46:38 <kirindave_> Does anyone know of applicable papers on modeling financial transactions and account balances functionally and immutably?
10:46:43 <kirindave_> It's a difficult topic to google because of the overload of the term "functional"
10:46:52 <nand`> kirindave_: you mean like STM?
10:47:04 <kirindave_> nand`: I mean at a higher level, like experience reports
10:47:08 <nand`> ah
10:47:20 <nand`> sorry, overread ‘immutably’
10:47:23 <kirindave_> Not architecting software, architecting a system.
10:47:30 <Cale> and pure is a kind of "unit" for that pairing, in that  liftA2 (,) (pure x) y = fmap (\v -> (x,v)) y
10:47:51 <Cale> and  liftA2 (,) x (pure y) = fmap (\v -> (v,y)) x
10:47:55 <kirindave_> nand`: It's np. Same thing happens when I say "logging for haskell" and people say "WriterT" like oh yeah that'll totally do what you want. ;)
10:48:06 <nand`> dd: the interesting property about pure and <*> is that pure f <*> x  behaves like fmap f x
10:48:15 <nand`> which is why it's associated with applicative functors, at the least
10:48:41 <kirindave_> nand`: It's not so much a property as the definition, isn't it? :)
10:48:43 <Cale> You can see the laws for Applicative all involve pure in some way -- it helps to constrain which operation <*> is allowed to be
10:48:53 <nand`> kirindave_: defined property :)
10:48:58 <kirindave_> word.
10:49:43 <Cale> If things had been done a little differently, we might instead have
10:49:52 <Cale> class Functor f => Monoidal f where
10:50:00 <Cale>   pure :: a -> f a
10:50:11 <Cale>   pair :: f a -> f b -> f (a,b)
10:50:36 <Cale> satisfying analogous laws :)
10:50:40 <edwardk> i'm much happier with Applicative than I would be with Monoidal
10:50:41 <conal> Cale: or unit :: f () in pace of pure.
10:50:48 <Cale> indeed
10:50:52 <nand`> applicative is wonderful
10:51:14 <Cale> yeah, that would be a little closer to the mathematical definition
10:51:20 <edwardk> Cale: not all of the laws for applicative. there should be an associative law you can state without it
10:51:48 <edwardk> using fmap instead
10:52:04 <ornicar> hello, newbie here! I'm looking at Data.Sequence (file:///usr/share/doc/ghc/html/libraries/containers-0.4.2.1/Data-Sequence.html) to make a FIFO list. But I find no function to return the first element of the sequence!
10:52:04 <Cale> edwardk: ah, yeah, I think you're right
10:52:09 <ornicar> Seq a -> Maybe a
10:52:10 <edwardk> thats a bit quibbly though ;)
10:52:19 <edwardk> Cale: i use the fmap version of the law for Apply ;)
10:52:24 <ornicar> I don't understand why it does not exist, I must be missing something, but what?
10:52:55 <dd> Thanks everyone, that makes more sense now, it helps with the laws and definations that an applicative has to fulfill
10:52:59 <kirindave_> Cale: That pair function reminds me of Control.Arrows.
10:53:00 <ornicar> (sorry for the file: link, here is the http one http://hackage.haskell.org/packages/archive/containers/0.2.0.1/doc/html/Data-Sequence.html)
10:53:06 <nand`> fmap (.) u <*> v <*> w = u <*> (v <*> w)
10:53:14 <kirindave_> I wonder why Control.Arrows was the package that ended up with so many useful pairing functions.
10:53:23 <nand`> I wonder why the law isn't written that way, with <$>
10:53:28 <mapf> ornicar: you can just use Queue?
10:53:56 <Cale> kirindave_: because Control.Arrow is almost but not quite exactly an implementation of the concept of a monoidal category
10:54:04 <monochrom> ornicar: viewL
10:54:06 <ornicar> oh I'll look into it mapf
10:54:27 <Cale> kirindave_: and those operations are (some of) the natural things which you get with a monoidal category
10:54:32 <nand`> there are those who would argue that &&& should be liftA2 (,)
10:54:43 <nand`> and sometimes I feel it may come in handy
10:54:43 <Cale> (where your monoid operation is just pairing, though)
10:54:50 <ornicar> I see viewL but not yet how to write `Seq a -> Maybe a` from it
10:54:59 <kartoffelbrei_> ornicar: you could use the viewl function and the separte the head via patternmatching
10:55:02 <nand`> certainly works for arrows which are also applicatives (when applied to one type)
10:55:21 <ornicar> oh got it
10:55:42 <ornicar> ViewL is either `EmptyL` or `a <: Seq a`
10:55:50 <mapf> ornicar: i don't know where is, but it's implementing in ammotized O(1) time. If you want just FIFO Queue should be faster.
10:55:51 <ornicar> thank you very much!
10:55:58 <Cale> kirindave_: If you look at the definition of a monoidal category, you'll see it says that it's a category which is equipped with a particular bifunctor: ⊗: CxC -> C
10:56:24 <Cale> kirindave_: The fact that it's a bifunctor is what gives you (***)
10:56:57 <Cale> Or, it's what corresponds to (***) anyway
10:57:40 <ornicar> mapf are you referring to fgl Data.Graph.Inductive.Internal.Queue? http://www.haskell.org/hoogle/?hoogle=Queue
10:58:27 <sleepster> what limits haskell to be used in AI programming?
10:58:36 <sleepster> people seem to list LISP and prolog a lot
10:58:45 <sleepster> but aren't they all *similarly* designed languages
10:59:06 <Cale> sleepster: Um, nothing is stopping Haskell from being used in AI programming
10:59:23 <Cale> sleepster: and Haskell, Lisp and Prolog are quite dissimilar languages
10:59:24 <sleepster> I guess I should reword it.. why would someone choose LISP or Prolog over Haskell
10:59:27 <ornicar> I'm doing AI to learn haskell :) https://github.com/ornicar/haskant
10:59:50 <danharaj> edwardk: how revolted would you be if I said to use (Int,Int) instead of Int? ;)
10:59:58 <Cale> sleepster: because one was more familiar with those languages, perhaps?
11:00:10 <edwardk> danharaj: that only addresses one kind of structure though ;)
11:00:18 <edwardk> danharaj: what happens when b isn't flat? =)
11:00:37 <sleepster> I see.. well that's good then.. I thought maybe there was something glaringly defective in the language that made it not possible
11:00:37 <dd> The big AI boom was in full swing before Haskell was around?  Lisp is a very old language
11:00:45 <sleepster> I like haskell.. very nice language.. I am new though
11:00:46 <kirindave_> Cale: Funny. I though the motivation for the creation of Arrows was to provide a model for composition that had a more rich feature set.
11:00:47 <Cale> yes, that's a big reason
11:00:49 <endojelly> I think it's the built-in database aspect that makes Prolog interesting for some aspects of AI
11:00:57 <sleepster> so I apologize for the newb-sih questions that are sure to come
11:00:58 <edwardk> say b was a value from: data Named a = Named String a
11:01:06 <Cale> kirindave_: Well, what is a model for composition if not some sort of category?
11:01:09 <Cale> :)
11:01:16 <edwardk> danharaj: starting to see the problem?
11:01:20 <kirindave_> Cale: True. I just didn't realize they were connected in that way
11:01:27 <dd> sleepster: it is a good question
11:01:43 <Cale> kirindave_: It's just, they did a sort of funny reinvention of monoidal categories with a few extras and some restrictions.
11:01:49 <dd> Lisp had its own hardware back then as well, made using functional based languages performant
11:01:57 <kirindave_> Cale: The discovery came from optimizing parsers, right? They used them to compose parser that would automatically fail if no characters they were interested in at point 1 were in the string.
11:02:22 <Cale> kirindave_: I'm not sure if that was before or after the use for FRP
11:02:38 <kirindave_> Cale: I was told and sort of internalized that Arrows are like monadic composition but you have richer control over how they are chained.
11:02:46 <dd> I learned AI programming on a lisp box
11:02:52 <kirindave_> Cale: Maybe that model is why the arrow notation is so alien to me.
11:03:09 <alpounet> ornicar, cool!
11:03:15 <Cale> kirindave_: you have *less* control, in a way
11:03:24 <danharaj> edwardk: tricky indeed
11:03:26 <dd> prolog is designed with formal logic in mind, so it is easy to express rule-based systems within it
11:03:30 <ornicar> alpounet: it's probably very crappy code, being my first try at haskell
11:03:31 <Cale> kirindave_: or, I suppose, as a library author, you have more control
11:03:34 <ornicar> but I have a lot of fun
11:03:42 <Cale> kirindave_: as a user of the library, you are more restricted
11:04:02 <dd> but haskell seems like a good language for doing AI, but I'm learning it myself, so can't comment very well on it yet
11:04:12 <danharaj> edwardk: incidentally I found a paper on representing open terms in HOAS-style, but it was opaque to me on first reading.
11:04:18 <alpounet> ornicar, getting things done is important, it gets you more and more comfortable with the language. once you are able to write code to do what you want, you can care about how idiomatic your code is, or how efficient.
11:04:20 <danharaj> idk if it's very relevant at all.
11:04:20 <Cale> kirindave_: When you write a monadic computation, you're constantly using (>>=) :: M a -> (a -> M b) -> M b
11:04:49 <edwardk> yeah, i'm not worried about open hoas terms. thats lickable by using the 'free' thing i have there, or by using Hoas -> Hoas  for a term with one variable open or
11:04:58 <edwardk> [Hoas] -> Hoas for one with more
11:05:24 <Cale> kirindave_: As a library author, you have control over the constructors of the type M a, and so your implementation of >>= or some interpreter for your monadic computations can examine this first computation in order to plan how to carry out the computation
11:05:37 <Cale> kirindave_: but it *can't* see through the function a -> M b without first applying it
11:05:53 <Cale> kirindave_: because functions are black boxes
11:05:54 <danharaj> edwardk: let's say we have b = Named String a, but no let expressions, what would we change Int to?
11:06:23 <edwardk> danharaj: well. one thought is to define a 'Gamma' GADT and define a variable reference into Gamma as another GADT
11:06:30 <Cale> kirindave_: but with the Arrow interface, you give the user a compositional operation (>>>) :: A u v -> A v w -> A u w
11:06:36 <edwardk> this gets fairly traditional fairly fast ;)
11:07:03 <Cale> kirindave_: since both parameters to that are data structures which you control, you have more opportunity to control how the computation proceeds, or "plan ahead"
11:07:31 <kirindave_> Cale: Right; you can have more sophisticated rules for composition as the library author.
11:07:40 <kstt`> FWIW : haskell-platform 2012.2 makefile is broken -> make clean does not clean enough files, leading to strange failures during "make", like missing alex/happy
11:08:04 <danharaj> edwardk: I'm having trouble imagining Exp without b = ()
11:08:08 <kirindave_> Cale: In their case they had a set of valid first characters they'd compose, and application to a string checked these. If I'm remembering this right, of course.
11:08:21 <Cale> kirindave_: But of course, as a library *user* it means that you have limited options for how you can use the result of an arrow computation. You can't just use an arbitrary function to decide "what to do next"
11:08:22 <edwardk> danharaj: did you look at the bound package?
11:08:30 <danharaj> I am atm
11:08:50 <kirindave_> Cale: Well, except that you gotta provide a functor from function to your arrow category, right?
11:08:50 <Cale> kirindave_: and so you in some sense, have to build much more "static" computations.
11:08:58 <edwardk> danharaj: newtype Scope b f a = Scope (f (Either b (f a)) -- is a fancy version of EitherT b f a
11:09:17 <edwardk> (in the code there I use 'Var' as a renamed version of Either)
11:09:18 <kirindave_> Cale: Yeah, I use Hakyll a lot which is entirely based around arrows. So it's actually something I have a lot of experience with.
11:09:32 <edwardk> its fancy because it offers 'lift' in O(1) unlike EitherT
11:09:33 <Cale> kirindave_: yes, so there is that, but even with arr, you can't use the result of one arrow computation to determine which arrow computation comes next
11:09:40 <endojelly> Cale, kirindave_, here's one thing I found Arrows useful for, which illustrates the point that Cale just made, I think. Maybe you'd like to take a look at it. Be careful, it's from a *very* practical viewpoint and you may even take offense at some of the terms I use %) http://dl.dropbox.com/u/6617799/Arrows%20for%20CPU%20Emulation.pdf
11:09:59 <kirindave_> Cale: Is that question even sensible before composition?
11:09:59 <edwardk> because you can use Scope . return . Right to lift
11:10:03 <endojelly> it's pretty short, just 8 slides
11:10:19 <edwardk> Now, we can bind multiple variables at a time, using abstract
11:10:46 <endojelly> and the example use case, "parallelizing a CPU", is kind of dumb, but I needed something simple which was easy to understand.
11:10:50 <danharaj> yes, the example for abstract is illuminating indeed :)
11:10:54 <kirindave_> endojelly: I am enjoying it.
11:10:55 <edwardk> abstract :: Monad f => (a -> Maybe b) -> f a -> Scope b f a
11:11:01 <Cale> kirindave_: ArrowApply gives you a way to do that, but if you implement ArrowApply, then you really secretly have a monad.
11:11:23 <edwardk> danharaj: =) i wanted to use functors and monads that people had lying around so, [] was as good as anything ;)
11:11:24 <kirindave_> Cale: Aren't all monads arrows?
11:11:30 <Cale> kirindave_: "yes"
11:11:37 <Cale> kirindave_: But most of them are immoral arrows :)
11:11:45 <kirindave_> Whatever that means. :)
11:12:06 <Cale> The original arrow paper decided not to adopt the law that (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
11:12:17 <Cale> in order that they could make that generalisation
11:12:33 <Cale> but this law is really required in order to keep one's sanity while programming with arrows
11:13:03 <kirindave_> It's funny I use arrows constantly in my day-to-day haskell
11:13:06 <nand`> that doesn't even hold for Kleisli IO, does it?
11:13:07 <kirindave_> But never use the proc notation.
11:13:15 <nand`> kirindave_: I've only ever used proc notation for netwire
11:13:15 <Cale> It sort of says that no matter how we decompose a circuit diagram into arrow combinators, it will produce the same computation
11:13:23 <nand`> it was a little mind-bending at first
11:13:26 <Cale> nand`: It fails spectacularly for Kleisli IO
11:13:39 <edwardk> danharaj: http://hackage.haskell.org/packages/archive/bound/0.5.0.1/doc/html/Bound-Name.html#v:abstractName captures the name as it abstracts
11:13:48 <Cale> g and h happen in the reverse order
11:13:59 <nand`> ah, yeah
11:14:03 <endojelly> kirindave_, part of why I thought about showing you those slides is because I thought that the proc notation can be pretty illustrative
11:14:20 <edwardk> so if you have an Exp String you can get a Scope (Name String b) f String  using a function (String -> Maybe b)
11:14:29 <Cale> Another way to put this law is that it expresses a kind of "locality of state"
11:14:32 <edwardk> er Scope (Name String b) Exp String
11:14:43 <Cale> individual arrow computations are allowed to keep internal state
11:14:48 <nand`> Cale: does this allow commutation of sequencing in general?
11:14:54 <endojelly> kirindave_, take a look at the last slide. you can see exactly which values are fixed while "decoding" the emulated CPU instructions, and which will be supplied when running the emulator
11:15:00 <edwardk> Name is just a convenient comonad that holds onto some metadata for you
11:15:01 <danharaj> edwardk: makes sense
11:15:03 <Cale> but the state of one arrow is not allowed to influence the state of one which is being run alongside it
11:15:04 <edwardk> you can extract and throw it away
11:15:38 <Cale> nand`: yes, in the sense that (id *** f) >>> (g *** id) = (g *** id) >>> (id *** f)
11:15:55 <Cale> If the computations are on different "wires", then you can slide one past the other
11:15:56 <nand`> yes fair enough
11:16:15 <nand`> I guess that fails for a lot of kleislis
11:16:22 <Cale> yes, most Kleislis
11:16:29 <Cale> You need a commutative monad
11:16:34 <Cale> in order to satisfy this
11:17:14 <nand`> Does Kleisli [] work?
11:17:24 <kirindave_> FRP is another one of those things I need to consider...
11:17:30 <Cale> That's not technically a commutative monad
11:17:36 <kirindave_> But I just haven't seen anything compelling using it.
11:17:38 <Cale> It works if you disregard order of the resulting lists
11:17:44 <nand`> ah
11:17:45 <kirindave_> I really want to see an awesome haskell GUI framework
11:18:00 <kirindave_> It seems like it'd be so easy, but it ends up being so difficult.
11:18:30 <nand`> kirindave_: yeah same, I see citations like reactive-banana constantly but I look at code written in it and I just don't really feel it
11:19:12 <kirindave_> Nor have I seen anything even remotely usable come out of it.
11:19:13 <nand`> same for stuff like sodium. Netwire has interested me, but lack of examples of use cases (for me) has made this fruitless
11:19:20 <kirindave_> Like why isn't there something like Xmonad
11:19:21 <nand`> examples or*
11:19:49 <nand`> I would like to see something like yknow an MPD client written with FRP
11:20:03 <nand`> because what I use now, vimus, is a large imperative StateT IO
11:21:24 <nand`> (and what's worse, it's written without lenses ;)
11:21:35 <edwardk> nand`: so sad
11:22:08 <hiptobecubic> I wish pms wasn't so buggy
11:22:18 <nand`> edwardk: the result is a bunch of boilerplate setters, getters and modifiers, one for each field :P
11:25:47 <alpounet> nand`, there's always guitv, but it lacks a lot of controls and stuffs like that
11:26:14 <nand`> GuiTv spectacularly fails to build for me
11:26:31 <nand`> (even GtkHs does, admittedly)
11:27:29 <kirindave_> nand`: You know what would be a good candidate for arrows and the proc notation? A Webserver generating and processing forms.
11:28:31 <nand`> maybe. webservers has never been an area of interest for me
11:30:48 <danharaj> edwardk: for some reason I feel like there should be an invasive version of Scope where you take a monad and then smash Scopes into it so that when you are inside a term you have access to the scopes you've entered during your traversal.
11:32:04 <danharaj> I'm not sure that sentence makes sense.
11:38:59 <alpounet> nand`, tried to report it to conal or investigate yourself?
11:40:15 <conal> nand`: when i have wxhaskell working on the mac again, i'll make a new version of GuiTV for it.
11:41:15 <nand`> alpounet: I'm not interested enough to tackle it myself, especially since I have no clue how to interact with the Gtk and C FFI stuff; but conal's the one that warned me about GuiTv probably not working when I tried using it in the first place
11:45:41 <hpaste> beaky pasted “isomorphism” at http://hpaste.org/76092
11:46:05 <beaky> hello
11:46:10 <beaky>  http://hpaste.org/76092 is this an isomorphism?
11:47:11 <mapf`> no?
11:47:20 <ocharles> no
11:47:25 <atriq> Not by any definition of "isomorphism" I've came across
11:47:27 <ocharles> because you can't get the actual score back if you have a grade
11:47:30 <beaky> ah
11:47:36 <beaky> so its a catamorphism
11:47:37 <ocharles> (that transformation is not information preserving)
11:47:51 <mapf`> it's homomorphism maybe
11:47:54 <beaky> oh
11:48:25 <mapf`> oh no
11:48:28 <beaky> we can get a grade range for each letter grade though, so thats what makes it a homomorphism
11:48:34 <beaky> ?
11:49:00 <ocharles> i'd just call it a many to one function :) i forget the name for a function with that property
11:49:15 <ocharles> surjection?
11:49:28 <quuuux> homomorphism w.r.t. what? They're mostly useful where you're talking about some property that's preserved
11:49:48 <mapf`> ocharles: yep
11:51:13 <bgamari> cassava is quite nice but I can't quite get it to parse without consuming hundreds of megabytes in ByteStrings
11:51:52 <beaky> so atm haskell is the most advanced programming language?
11:51:54 <ocharles> i don't think it's surjection. the means the image = the codomain. not that a function is many-one
11:52:04 <Clint> how big is the csv?
11:52:10 <bgamari> Clint, 10MB
11:52:21 <Clint> hmm
11:52:50 <bgamari> yeah, it's a bit odd
11:53:04 <atriq> beaky, I'm not sure there's such a thing
11:53:26 <bgamari> Clint, all of this appears to be happening in parseRecord
11:53:32 <atriq> But we seem to be ahead of the category theorists, so that's pretty good
11:53:46 <beaky> ^^
11:54:54 <mapf`> ocharles: image = codomain means (a -> a) ?
11:56:00 <ocharles> no it means that if f:A -> B, then forall b:B, there exists an a:A where f(a) = b
11:56:05 <ocharles> worded betterer than that :)
11:56:17 * hackagebot DSH 0.8.0.1 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.8.0.1 (GeorgeGiorgidze)
11:56:55 <sleepster> is http://book.realworldhaskell.org the best online book available?
11:57:07 <ocharles> sleepster: as always, it depends
11:57:10 <mapf`> sleepster: pretty good.
11:57:11 <atriq> I preferred Learn You A Haskell
11:57:14 <ocharles> if you're new to haskell, i think learn you a haskell is a better start
11:57:20 <kirindave_> Yes.
11:57:21 <atriq> But Real World Haskell is good for some things
11:57:24 <kirindave_> Only good monad tutorial.
11:57:27 <sleepster> I see.. I already started reading it and it seems fine, but if there is a better source, then I don't want to waste my time :0
11:57:28 <ocharles> i stil go back to RWH for things like profiling, optimization, etc
11:57:28 <dd> http://learnyouahaskell.com/
11:57:29 <kirindave_> RWH needs a new edition.
11:57:35 <atriq> So does LYAH
11:57:43 <beaky> yes
11:57:44 <kirindave_> LYAH needs it less.
11:57:47 <ocharles> well volunteered, all of you ;)
11:57:49 <sleepster> thanks guys
11:57:52 <kirindave_> Maybe.
11:57:58 <kirindave_> If I really do this system in haskell...
11:58:02 <kirindave_> Then I might feel qualified.
11:58:07 <atriq> preflex: seen bonus
11:58:07 <preflex>  Sorry, I haven't seen bonus
11:58:17 <edwardk> danharaj: heh the version you describe is exactly what Scope was written to get away from
11:58:21 <dd> I've read them all now and lyah is the best so far, but the others are good to read as well as they explain some things differently and realworld haskell gives some good implementations of things to compare
11:58:26 <kirindave_> I am not the pro category theorist many people in here are.
11:58:39 <mapf`> RWH a bit old, but i like the chapters due self-contained maner
11:58:39 <ocharles> Bay Area haskellers -- is there a venue for the october meetup yet?
11:58:40 <kirindave_> But I've deployed, maintained, and authored systems that use hundreds and in one cases thousands of machines. :)
11:58:48 <kirindave_> So I do have _some_ valuable perspective on the subject.
11:58:54 <ocharles> we're only a week away, and this brit would like to have some idea of what he's doing in your scary city :)
11:58:59 <kirindave_> Btw
11:59:03 <ocharles> shachaf ^
11:59:04 <edwardk> danharaj: you can make a GADT based abomination in two ways. you can make data Exp a = Lam (Exp (Maybe a)) | App (Exp a) (Exp a) | …    or you can make
11:59:05 <kirindave_> Cloud Haskell has me all aquiver.
11:59:16 <edwardk> a GADT with an explicit weakening to get the generalized form i have
11:59:19 <kirindave_> It is the most exciting thing I've seen since I first learned Erlang.
12:00:27 <quuuux> hmm, well, that's no good
12:00:48 <quuuux> ghci probably ought not to segfault on me
12:01:03 <ocharles> oh great, there is a venue on the mailing list
12:01:04 <ocharles> woohoo!
12:01:37 <bgamari> quuuux, Are you on OS X running the Platform?
12:01:44 <shachaf> ocharles: Yes, it'll be at Google SF.
12:02:06 <ocharles> yep, only half an hour walk from my hotel
12:02:11 <ocharles> so i can explore a bit of SF on the way :)
12:02:19 <kirindave_> shachaf: You gonna be at the cafe in SF this sunday?
12:02:33 <quuuux> bgamari: no, linux
12:02:40 <kirindave_> I am gonna show and hack on aristid's aws library to add dynamodb support. Should be a nice exercise.
12:02:45 <shachaf> kirindave_: I'm not sure. It's possible.
12:03:09 <bgamari> quuuux, hmm, which GHC?
12:03:13 <ocharles> can't wait for this talk!
12:03:17 <kirindave_> shachaf: I will be. Even though I _should_ be hacking on a magical cauldron to delight children.
12:03:35 <quuuux> bgamari: 7.4.1, but I'm not convinced it's GHC. It might just be a borked lens-3.0.2 package
12:03:51 <danharaj> edwardk: what about attaching a type that is basically a list of scopes entered to get to that term and then deriving LN for that?
12:03:54 <bgamari> quuuux, alright
12:04:05 <edwardk> lens borked, wut?
12:04:11 <danharaj> Not a single type, rather a type family.
12:04:21 <edwardk> danharaj: thats basically what i'm looking to do
12:04:26 <danharaj> oh ok
12:04:38 <edwardk> danharaj: you've now grasped the issue =)
12:04:38 <quuuux> borked installation, that is. I was futzing around with upgrades earlier
12:04:47 <danharaj> Not bad for me to go from "huh what" to vaguely getting your current idea in a couple of hours :P
12:05:24 <edwardk> =)
12:06:01 * quuuux recompiles half of Hackage in a fresh package database and tries again...
12:07:17 <ahihi2> speaking of which, is there a fix for the OS X segfaults yet?
12:07:27 <ahihi2> last I checked, the best suggestion was to compile your own ghc
12:11:56 <beaky> anyone here try Miranda? it looks very similar to Haskell
12:12:01 <hpaste> “Anders Leino” pasted “How is the type ambiguous?” at http://hpaste.org/76093
12:12:31 <ksf> quick!
12:12:45 <mapf`> zippers!
12:12:52 <leino> If anyone would care to take a quick look, I'd appreciate it. The error I got is pasted at the bottom of the file. http://hpaste.org/76093
12:12:57 <leino> yes! :)
12:13:01 <ksf> beaky, you *must* say "Miranda is a trademark of Resarch Software Ltd", or they'll sue you!
12:14:01 <mapf`> leino: why not class Tree t where leftTree :: t a -> t a
12:14:01 <mapf`> ?
12:14:35 <c_wraith> beaky: Miranda was more-or-less a direct predecessor to Haskell.
12:14:43 <beaky> so Miranda(r) is the proprietary precursor of Haskell?
12:14:51 <atriq> Yeah
12:14:56 <leino> mapf: hmm yeah that does look strange
12:14:56 <c_wraith> beaky: http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm
12:15:18 <ksf> yep. part of why the haskell comittee was formed was because of that annoying trademark issue.
12:15:21 <beaky> oooh didn't know microsoft was interested in Haskell
12:15:24 <c_wraith> beaky: that paper is an easy-to-read history of haskell.  It includes a lot about languages that contributed.
12:15:32 <c_wraith> Microsoft employs the two main authors of GHC
12:15:34 <ksf> beaky, they most likely aren't.
12:15:36 <ocharles> beaky: very interested :)
12:15:50 <leino> mapf: so I can read Tree t a either as (Tree t) a or as Tree (t a) ?
12:15:50 <ksf> they're interested in having smart people next door to their researchers.
12:15:56 <beaky> so maybe someday we will be using Microsoft Visual Haskell .NET professional enterprise edition
12:16:08 <ocharles> beaky: doubtful, they have F# for that
12:16:11 <c_wraith> F# is as close as they'll get
12:16:12 <beaky> ah
12:16:44 <c_wraith> It's mostly a case of a lot of good ideas coming out of spj and simon marlow...  And they're paying them to continue having really good ideas.
12:17:03 <c_wraith> A few of them make it into .NET
12:17:03 <mapf`> leino: kind of Tree (and it will be * -> *) derived from type annotations
12:17:09 <c_wraith> which is enough to justify the investment
12:17:27 <mapf`> oh
12:17:35 <ocharles> i always idly wonder what the bus factor is on the Simons
12:17:39 <mapf`> leino: just as Tree t
12:18:39 <danharaj> I love reading bug reports on ghc trac where simon marlow solves the issue and adds "Also made code 20% faster."
12:20:08 <mapf`> leino: so that class is just wrong if you don't use any existensial quantification
12:20:43 <leino> mapf: I'm not familiar with that term
12:22:10 <mapf`> leino: so, for exsample treeLeft takes a `t` and returns a `t` but i this case t is not parametrized by type
12:22:18 <efie> when dealing with monads, it is recommended to use fmap or liftM? Why is there liftM anyway if it does the same as fmap? Only because not every monad was made an instance of Functor, too?
12:22:29 <danharaj> efie: that is correct
12:22:37 <mapf`> type should hardcoded
12:23:16 <efie> danharaj: ok, thanks for confirming this
12:23:39 <S11001001> efie: there are situations when getting Functor m is annoying, but you have Monad m, so why mess with it
12:24:15 <mapf`> leino: error actually happens because it's impossible derive a type from such strange class constrait
12:24:34 <mapf`> derive a type `a`
12:25:14 <hpaste> “Anders Leino” pasted “This works...” at http://hpaste.org/76095
12:25:43 <leino> it's time to think...
12:26:33 <mapf`> leino: http://dpaste.com/812096/
12:27:03 <mapf`> continue hacking with this class :]
12:27:12 <leino> yeah that is what I just pasted! :)
12:27:46 <leino> but I had to do some unexpected things with the type signatures in the functions below that I dont quite understand yet
12:28:05 <leino> like: "up :: Tree t a => Zipper (t a) a -> Zipper (t a) a"
12:28:10 <mapf`> i don't sight
12:28:26 <leino> This: http://hpaste.org/76095
12:29:11 <mapf`> leino: you don't need to state `a` in class `header`
12:29:29 <mapf`> it's polymorphic without any constraits
12:29:35 <leino> aha!
12:29:53 <leino> and it is still "the same a" whever I mention it in the class definition?
12:31:14 <leino> (i.e. the 'a' in "treeCons :: a -> t a -> t a -> t a" is the same as the 'a' in treeLeft :: t a -> t a ?)
12:31:25 * hackagebot simple-log 0.1.4 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.1.4 (AlexandrRuchkin)
12:31:50 <mapf`> leino: unnecessary
12:34:38 <leino> mapf: yeah, maybe you're right... I can't think of any trouble that I might run into
12:35:52 --- mode: hubbard.freenode.net set +o ChanServ
12:36:05 <mapf`> well, you can think of class methods as a overloaded by constrined by typeclass parameter functions. `a` is 'fully' polymorphic and that typeclass with two parameters has no useful meaning
12:36:31 <mapf`> ph
12:36:45 <mapf`> well you catch i hope
12:36:46 <leino> mapf: it kind of does make sense if I think of the treeX function signatures as equations that t needs to satisfy for any a
12:37:20 <leino> mapf: thanks for the help
12:38:00 <mapf`> leino: no
12:38:17 <mapf`> t should be instance of typeclass
12:38:28 <mapf`> a is not constrained at all
12:38:55 <leino> yeah, I understand that now. they are not simultaneous equations :)
12:39:19 <mapf`> and then you put class in type context of function you can use `methods` of the typeclass
12:39:20 <leino> they are just signatures of functions that each need to be specified for t, for any given a
12:39:39 <mapf`> leino: yep
12:40:06 <mapf`> exactly
12:40:11 <leino> I think I understand, I was just careless about the analogy
12:40:38 <leino> and I can get rid of MultiParamTypeclasses
12:41:19 <leino> mapf: thanks again. have to go to bed now
12:41:51 <mapf`> MultiParamTypeclasses can cause ambigious
12:42:12 <mapf`> it's why we have fundep
12:42:24 <leino> what is fundep?
12:42:37 <mapf`> Functional Dependencies
12:42:43 <ksf> ...prolog on the type level
12:43:10 <mapf`> leino: oh wait
12:43:14 <danharaj> fundeps is weirder than prolog
12:43:20 <mapf`> i'd remebered one nice paper
12:44:26 <mapf`> leino: http://web.cecs.pdx.edu/~mpj/pubs/springschool.html
12:45:14 <leino> mapf: thanks! I'll add it to my reading list
12:45:31 <mapf`> to face up typeclasses it's pretty nice
12:46:13 <doomlord> i just made what i guess is a poor mans state threading helper function ... assuming N functions which take 's', each returning s,value,  call each in turn and return a tupple with s' and each value; ... does something like this already exist or does everyone just use the state monad
12:46:19 <leino> mapf: "face up"?
12:46:36 <mapf`> i constantly fogetting articles
12:47:19 <doomlord> pipeState3  inputState f0  f1 f2 = (outputState,result0,result1,result2) where ... (s''' malarchy..)
12:47:40 <mapf`> leino: to learn i mean
12:47:51 <doomlord> is this just a terrible idea
12:48:13 <watermind> Has anyone tried  ghc-mod  for emacs with emacs 24.x ?
12:48:17 <watermind> it's not working for me :(
12:48:26 <watermind> flymake for instance while activated does nothing
12:48:31 <watermind> I miss flymake
12:48:54 <mapf`> watermind: M-x flymake-mode <RET> ?
12:49:55 <mzero> doomlord: I think what you want is sequence
12:49:57 <mzero> :t sequence
12:49:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:50:04 <leino> mapf: I have been looking for something beyond the basics of how to use typeclasses. It was not obvious to me that I can (I assume) essentially sprinkle arbitrary type parameters in my class function signatures
12:50:07 <watermind> mapf`: it seems activated
12:50:09 <mzero> and the state monad
12:50:15 <leino> mapf: I have been looking for something beyond the basics of how to use typeclasses. It was not obvious to me that I can (I assume) essentially sprinkle arbitrary type parameters in my class function signatures
12:50:25 <doomlord> yeah i figure what i just made is a sort of stone-age state monad
12:50:36 <watermind> mapf`: I can even change between hlint and ghci
12:50:39 <leino> (sorry about the double post)
12:50:48 <watermind> mapf`: it just doesn't do anything
12:50:49 <mapf`> watermind: and C-c C-c ?
12:51:05 <watermind> mapf`: yes it changes between hlint and ghci
12:51:07 <leino> good night, folks!
12:51:16 <mapf`> well i don't know. i have 23 version
12:51:20 <watermind> mapf`: but neither checks anything
12:51:39 <watermind> mapf`: it was working not long ago, so I suppose it was the change to 24
12:51:44 <doomlord> they're all different types though. so i have a series of these helper functions,   pipeState3 pipeState4 ... all returning a tuple (s,a,b,c) (s,a,b,c,d) etc
12:51:57 <mapf`> so ghc-mod itself sometimes doesn't work
12:52:00 <ziarkaen> Can the empty string be writen as "" instead of []? Is there a stylistic preference?
12:52:07 <mapf`> and i do not understand why
12:52:17 <watermind> mapf`: I've had to restart it sometimes in the past
12:52:27 <doomlord> i'll relax and use this for a bit then when i'm feeling more immersed in monads have another go..
12:52:37 <doomlord> more immersed in haskell not monads
12:52:38 <watermind> mapf`: but the issue would be it not verifying valid programs...
12:52:46 <mzero> if you flip your f's arguments around you can just use state
12:52:58 <watermind> mapf`: but now it just seems inactive, no blue nor red colouring
12:53:33 <mapf`> watermind: try something like "$ ghc-mod info file-name module-name function-name"
12:53:55 <mzero> then you can write something like:     pipeState s0 fns = runState (sequence $ map state fns) s0
12:54:11 <mapf`> if it's not work it's not work in emacs eventually
12:54:15 <latro`a> mzero:
12:54:16 <latro`a> @src mapM
12:54:16 <lambdabot> mapM f as = sequence (map f as)
12:54:23 <latro`a> (just saying)
12:54:24 <mzero> or mapM
12:54:26 <mzero> !
12:54:48 <sixohsix> > :t fromJust
12:54:49 <lambdabot>   <no location info>: parse error on input `:'
12:54:59 <sixohsix> darn
12:55:10 <doomlord> ok thanks .. i'll look into it.
12:55:22 <mzero> or, for the terse     pipeState = runState . mapM state
12:55:31 <mzero> (assuming you flip the args to pipeState
12:55:33 <watermind> mapf`: weird..     Dummy:0:0:Error:parse error on input `:'
12:55:44 <mzero> :t runState . mapM state
12:55:45 <lambdabot> forall s b. [s -> (b, s)] -> s -> ([b], s)
12:55:49 <watermind> mapf`: it only has the module declaration and then h = 1
12:56:01 <mzero> :!
12:56:12 <mapf`> watermind: i get the same sometime. it's why i don't use it for my small mode
12:56:30 <doomlord> when i see mapM, i'm expecting something which needs homogeneous types; in my case its just differnt calls , resulting in different temporaries... but i'm guessing the state monad still works, with a bind sequence or  something
12:56:56 <mzero> AH - wait, the b's are all different
12:57:09 <mapf`> watermind: hm, no. do you pass correct args?
12:57:14 <mzero> then you can't use sequence or mapM
12:57:21 <doomlord> yeah thats what i thought
12:57:32 <doomlord> but presumably the bind operator comes into it somewhere
12:57:37 <watermind> mapf`:  ghc-mod info Test.hs Test h
12:57:49 <doomlord> runState inputState  (f0>>=f1>>=f2) .. something like that ?
12:58:04 <mapf`> watermind: and h is top level staf for exsample?
12:58:11 <hpaste> wm pasted “eh” at http://hpaste.org/76096
12:58:24 <mapf`> s/staf/stuff
12:58:27 <doomlord> i know the do blocks have syntactic sugar for extracting /assigning values with <- ... i guess what i'm doing is dodging that sugar
12:58:48 <watermind> wtf
12:58:50 <doomlord> i think it would help me to know how to work without it
12:58:50 <mzero> but then....       doTheseThreeThings s0 = runState (do a <- fa `fmap` get; b <- fb `fmap` get; c <- fc `fmap` get; return (a, b, c) ) s0
12:58:59 <watermind> mapf`: wait... now I can't start ghci... wtf
12:59:00 <beaky> why is Haskell called Haskell?
12:59:12 <MostAwesomeDude> beaky: It's named after Haskell Curry, a famous logician.
12:59:45 <watermind> mapf`: http://hpaste.org/76096
12:59:50 <watermind> mapf`: it's just that...
12:59:53 <beaky> so Haskell is based on Haskell Curry's ideas?
13:00:01 <watermind> just a module declaration and then  h = 1
13:00:12 <MostAwesomeDude> Some of them, sure.
13:00:29 <doomlord> the last bit "return (a, b, c)"  - that 'lifts' the values into a monad, whats the type of the final return value ... and how do i use the values from somthing calling doTheseThreeThings
13:01:31 <ion> return (a,b,c) :: Monad m => m (aType, bType, cType)
13:01:48 <mzero> that is what runState is there for --- you can think of it as introducing the monadic context, running a monadic computation (our in-line do block), and then unwrapping the result
13:01:50 <mzero> :t runState
13:01:51 <lambdabot> forall s a. State s a -> s -> (a, s)
13:02:07 <mzero> Notice that the result of runState is _not_ in the State monad
13:02:11 <watermind> mapf`: in fact ghc-mod check Test.hs   ../Prelude.hs:87:6:parse error on input `:'
13:02:23 <doomlord> ah nice
13:02:24 <watermind> mapf`: what ghc do you have?
13:02:28 <sleepster> yeah I like LearnYouAHaskell better than the realworldhaskell book
13:02:34 <doomlord> ok that makes a lot more sense
13:02:37 <sleepster> thanks for the suggestion
13:02:50 <watermind> mapf`: I have 7.4.1... maybe it was my ghc update...  :S
13:02:52 <strebe> sleepster: why?
13:03:15 <armlesshobo> sleepster: i don't
13:03:26 <mzero> but then....       doTheseThreeThings s0 fa fb fc = runState (do a <- state fa; b <- state fb; c <- state fc; return (a, b, c) ) s0
13:03:46 <mzero> :t \ s0 fa fb fc = runState (do a <- state fa; b <- state fb; c <- state fc; return (a, b, c) ) s0
13:03:47 <lambdabot> parse error on input `='
13:03:57 <mzero> :t \ s0 fa fb fc -> runState (do a <- state fa; b <- state fb; c <- state fc; return (a, b, c) ) s0
13:03:58 <armlesshobo> ->
13:03:59 <lambdabot> forall s a a1 a2. s -> (s -> (a, s)) -> (s -> (a1, s)) -> (s -> (a2, s)) -> ((a, a1, a2), s)
13:04:05 <armlesshobo> -> that way
13:04:23 <mzero> I know - I was cut-n-pasting from a func def....
13:04:27 <sleepster> strebe: it explains things at the right time... when I was reading the realworldhaskell book, it assumed a lot which confused me
13:04:34 <ion> @type \s0 fa fb fc -> runState (liftA3 (,,) (state fa) (state fb) (state fc)) s0
13:04:35 <armlesshobo> mzero: lol gotcha
13:04:36 <lambdabot> forall a b c s. s -> (s -> (a, s)) -> (s -> (b, s)) -> (s -> (c, s)) -> ((a, b, c), s)
13:05:10 <doomlord> ok thats lookin more like an evolution of things from my helper functions
13:05:17 <mapf`> watermind: i have 7.4.1 now. debian retard lol
13:05:19 <mzero> good
13:05:24 <sleepster> strebe: then again, I am super newb.. so maybe that is the reason for my propensity to learnyouahaskell
13:05:24 <ion> @type \s0 fa fb fc -> runState ((,,) <$> state fa <*> state fb <*> state fc) s0
13:05:26 <lambdabot> forall a a1 a2 s. s -> (s -> (a, s)) -> (s -> (a1, s)) -> (s -> (a2, s)) -> ((a, a1, a2), s)
13:05:38 <watermind> mapf`: hmm so that can't be it...
13:06:00 <watermind> mapf`: ghc-mod complains about prelude
13:06:03 <armlesshobo> i appreciate the humor in LYAH
13:06:04 <mzero> notice that it -might- indicate that your functions should all be *in* the state monad, so your fn's should be of the form    State s a   rather than   s -> (a, s)
13:06:09 <ziarkaen> I've just written a function to test whether a string s is a palindrome by testing for equality between s and reverse s.  Is there a more fundamental way to do this, i.e. one that would be instructive to someone learning Haskell?
13:06:18 <armlesshobo> but like the exercises in RWH
13:06:24 <mapf`> watermind: i don't know. for it works on any files but misbehave sometimes
13:06:27 <mzero> but it kindof depends on what is going on in those functions to see which style is more natural
13:06:33 <watermind> :S
13:06:51 <rwbarton> ziarkaen, that is the best way
13:06:56 <mapf`> watermind: and it seems there are no rule for that misbehaving
13:07:08 <rwbarton> ziarkaen: but you could try to do it by pattern matching too. note that there is no way to match on the end of a list directly
13:07:21 <strebe> sleepster: hm, ok - I'm fairly new myself, but I'm finding RWH fairly clear for the most part. I guess I'll check out the other guide too
13:07:38 <armlesshobo> ziarkaen: it seems to be the most appropriate to do it that way, since Haskell uses the f*** out of lists and pattern matching
13:07:46 <armlesshobo> it's one of the many services it provides
13:07:58 <sleepster> strebe: there is also cute pictures in the LearnYouAHaskell :)
13:08:10 <strebe> ziarkaen: that's the way I ended up defining it recently too
13:08:12 <doomlord> the specific example here is very simple.. random seed being thrown in and out of initializing entities. i figure its the same pattern as reading from a file or whatever. (Of course here i also have a cop-out available, not making the random seed sequential :)
13:09:06 <strebe> sleepster: ahh, I've done a moderate amount of non-haskell, non-lazy, non-pure fp, and it looks like LearnYouAHaskell is aimed at people who've only done imperative programming :-)
13:09:10 <ziarkaen> rwbarton, armlesshobo, strebe: Thanks.
13:09:21 <mzero> well, there is a difference with the file -- if you are going to read from a file, you need to be in IO --- with State, you can create sort of an "island" that is restricted to only modifing this little bit of state, rather than the whole world
13:09:37 <mzero> and the island is still pure
13:10:12 <solrize> @pl (\f g n -> f n && g n)
13:10:12 <lambdabot> liftM2 (&&)
13:10:41 <solrize> :t (liftA2 (&&))
13:10:42 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
13:10:55 <solrize> :t (liftM2 (&&))
13:10:57 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
13:11:04 <mzero> didn't someone do a nice simple random monad in some package?
13:11:07 <kirindave_> So someone sends me haskell saying, "Your fizzbuzz should use a semigroup here si why."
13:11:09 <kirindave_> https://gist.github.com/3862632
13:11:26 <kirindave_> I am not sure how (fromMaybe . show <*> ) typechecks.
13:11:39 <atriq> :t fromMaybe . show
13:11:40 <lambdabot> forall a. (Show a) => a -> Maybe String -> String
13:11:51 <kirindave_> :t (fromMaybe . show <*>)
13:11:53 <lambdabot> forall a. (Show a) => (a -> Maybe String) -> a -> String
13:11:56 <kirindave_> So
13:12:03 <atriq> So that's got to be in the (->) (a -> Maybe String)
13:12:06 <atriq> Applicative
13:12:10 <kirindave_> Right.
13:12:18 <kirindave_> But on line 17
13:12:39 <kirindave_> That's not what it implies is happening.
13:12:47 <solrize> i liked the monoid fizzbuz except it should have used mconcat
13:12:50 <kirindave_> :t (Data.Semigroup.<>)
13:12:51 <lambdabot> Couldn't find qualified module.
13:13:02 <solrize> @src liftA2
13:13:02 <lambdabot> liftA2 f a b = f <$> a <*> b
13:13:04 <atriq> :t \x y -> guard y >> x
13:13:05 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => m b -> Bool -> m b
13:13:19 <atriq> (that's (.|), btw)
13:13:24 <kirindave_> atriq: Yeah I wrestled with that.
13:13:28 <solrize> :t ap
13:13:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:13:30 <kirindave_> atriq: I didn't write this code.
13:14:11 <atriq> :t \s q -> (\b -> guard b >> s) . (0 ==) . (`rem` q)
13:14:12 <lambdabot> forall (m :: * -> *) b a. (MonadPlus m, Integral a) => m b -> a -> a -> m b
13:14:14 <kirindave_> solrize: I am just confused because that's on line 18-20 is not a (a -> Maybe String)
13:14:32 <atriq> That's Maybe b -> Integer -> Integer -> Maybe b
13:14:45 <mzero> I saw that code in some post, kirindave_, I didn't really think much of it - seems way complex for the task or the point the blog post was trying to make
13:14:46 <doomlord> mzero: "well, there is a difference with the file -- if you are going to read from a file, you need to be in IO" - i'm told lazy eval means you can still write all the parsing logic outside of IO blocks .. the IO block just makes a lazy sequence that reads the file on demand
13:14:57 <atriq> So "fizz" ~> 3 is oh dear
13:14:58 <kirindave_> mzero: I agree.
13:15:11 <atriq> It's using the [] MonadPlus, not the Maybe one there
13:15:13 <kirindave_> mzero: And I do not understand why using a semigroup here does anything but add a nice sense of snugness to things.
13:15:25 <atriq> So (~>) :: String -> Int -> Int -> String
13:15:26 <mapf`> that paper about unifying parsing and pretty printing redefines half of Control.Monad
13:15:36 <atriq> So "fizz" ~> 3 :: Int -> String
13:15:42 <kirindave_> Ah
13:15:47 <mapf`> my mind is blowing as said ghc
13:15:49 <strebe> sleepster: anyhow, thank you for the heads up, it's good to know about LYAH too
13:15:54 <kirindave_> So it's using the Semigroup instance on ->
13:15:54 <mzero> doomlord: yes, and you should -- but somewhere, with that file, you've got to be in IO for at least some of the code
13:15:57 <atriq> :t fromMaybe . show -- again, I forgot
13:15:58 <lambdabot> forall a. (Show a) => a -> Maybe String -> String
13:15:58 <kirindave_> Not Option or Maybe
13:16:09 <mzero> kirindave_: agreed
13:16:09 <kirindave_> Yeah that code seems a little more lifted.
13:16:36 <armlesshobo> I like RWH because it gets to the point, and says the important things about the language that it needs to say
13:16:48 <armlesshobo> (lazy evaluation, scoping, etc.)
13:17:09 <atriq> It's using the Semigroup a => Semigroup (b -> a) instance
13:17:15 <kirindave_> Yeah I see that now.
13:17:21 <armlesshobo> plus, RWH has a lot of exercises that not only reinforce the material, but has you gradually thinking functionally
13:17:26 <atriq> So the whole semigroup chunk is Int -> String
13:17:27 <kirindave_> I woulda seen it right away if he had used guard or liftA2. :\
13:17:29 <mapf`> how can we catch error in read. only way is readIO?
13:18:17 <kirindave_> What's that rconnor said to me?
13:18:31 <kirindave_> "Argh! This is the worst code in the world. Type inference is for compilers, not for humans!"
13:18:31 <mzero> mapf`: use reads
13:18:31 <mapf`> it's looks strange that we don't have   read :: Read a => String -> Maybe a
13:18:41 <mzero> :t reads
13:18:43 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:19:04 <atriq> > reads "1 2 3" :: [(Int, String)]
13:19:05 <lambdabot>   [(1," 2 3")]
13:19:12 <atriq> > reads "12 2 3" :: [(Int, String)]
13:19:13 <lambdabot>   [(12," 2 3")]
13:19:19 <rwbarton> kirindave_, that was more or less what I said
13:19:24 <kirindave_> Oh sorry
13:19:25 <mzero> I like to use      readMaybe = listToMaybe . filter (empty . snd) . reads
13:19:27 <kirindave_> I meant rwbarton
13:19:28 <atriq> Is there a way such that length (reads a) > 1?
13:19:29 <kirindave_> Doh
13:19:36 <mzero> :t listToMaybe . filter (empty . snd) . reads
13:19:37 <lambdabot>     Ambiguous occurrence `empty'
13:19:37 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
13:19:37 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
13:19:47 <armlesshobo> mzero: what version is that 'reads' from?
13:19:57 <mzero> :t listToMaybe . map fst . filter (null . snd) . reads
13:19:59 <lambdabot> forall a. (Read a) => String -> Maybe a
13:20:03 <armlesshobo> mzero: mine shows 'reads :: Read a => ReadS a
13:20:04 <armlesshobo> '
13:20:06 <mapf`> mzero: : well, but prelude doesn't export appropriate function to deal with
13:20:14 <atriq> @info ReadS
13:20:14 <mzero> ReadS is just a typedef
13:20:14 <lambdabot> ReadS
13:20:17 <strebe> armlesshobo: yeah, with the occasional shortcoming - i'm about to rewrite some code using bytestrings, because taking 22 seconds and 12 gigs of allocs to parse a 34 meg file is pretty horrible
13:20:27 <mapf`> mzero: ok
13:20:29 <atriq> :t undefined :: ReadS a
13:20:30 <lambdabot> forall a. String -> [(a, String)]
13:20:35 <atriq> There you go
13:20:36 <kirindave_> I'd better buckle down and do this coding.
13:20:46 <armlesshobo> strebe: what?
13:20:48 <kirindave_> strebe: Text
13:20:48 <armlesshobo> strebe: lol
13:21:07 <efie> it's a pity the author of LYAH never updated the webpages with the promised exercises. I'd also like to read a LYAH #2 about monad transformers, extensions and such
13:21:11 <clahey> strebe: How could String cause it to take up 300 times the space?
13:21:15 <kirindave_> strebe: Like, just use attoparsec al the time every time.
13:21:18 <strebe> armlesshobo: I'm using real world haskell, and trying to branch into a toy app to experiment a bit, and using readFile has been less than ideal
13:21:35 <mzero> +1 for attoparsec
13:21:41 <atriq> efie, I think the author of LYAH has disappeared of the face of the Earth
13:21:47 <kirindave_> strebe: My experience is that attoparsec and parsec are the only parser frameworks worth using with non-trivial input. Everything else has let me down.
13:21:50 <armlesshobo> strebe: ahh. well, yes.
13:21:50 <mzero> and use Text if you are really parsing text, only use ByteString if you are parsing bytes
13:21:51 <strebe> kirindave_: hmm. Could do, though the strings are just ^ delimited, so it's practically like csv
13:21:53 <kirindave_> strebe: And I was let down a few times.
13:21:54 <nor> how hard would it be to get a haskell RTOS running on a microcontroller?
13:22:03 <kirindave_> strebe: Then your attoparsec spec should be trivial.
13:22:36 <nor> how hard would it be to get a haskell RTOS running on a microcontroller? Id need to compile to that architecture so if i chose some ARM platform.
13:22:41 <kirindave_> strebe: even better
13:22:48 <kirindave_> strebe: http://hackage.haskell.org/package/attoparsec-conduit-0.5.0.2 and http://hackage.haskell.org/package/pipes-attoparsec-streaming exist already.
13:23:16 <kirindave_> CSV-like input is very amenable to streamed processing
13:23:23 <mzero> nor: it has been done, see HalvM - but porting the RTOS is not trivial, unles your microcontroller has essentially a POSIX runtime on it
13:23:30 <kirindave_> Even more fun I've had: you can have conduits and pipes lead into TChans.
13:23:52 <mzero> @hackage casava
13:23:52 <lambdabot> http://hackage.haskell.org/package/casava
13:24:01 <strebe> kirindave_: ok; I started writing it with parsec, but using Text.splitOn seemed worth trying, and then when I benchmarked it I was a bit horrified and wondered how to best make performance acceptable (top shows about 3 gigs of memory being used at peak, so I actually had to profile it on a machine with more ram than I'm writing the app on to get useful results)
13:24:05 <clahey> strebe: http://book.realworldhaskell.org/read/using-parsec.html#csv2.hs:all
13:24:09 <strebe> thank you
13:24:17 <mzero> kirindave_: if it is really CSV but delimited by ^, see casava
13:24:50 <kirindave_> strebe: I did this with data-enumerator, but
13:24:50 <kirindave_> https://github.com/KirinDave/redis-conduit/blob/master/Tap/Redis.hs
13:25:18 <clahey> strebe: Also: http://book.realworldhaskell.org/read/using-parsec.html#x_CK
13:25:31 <kirindave_> RWH's parsec thing is WAY out of date tho
13:25:34 <kirindave_> So take it as an advistory
13:25:49 <clahey> Oh.
13:25:52 <clahey> I haven't actually used it.
13:26:01 <clahey> But my main point was to show the general idea and how easy it was.
13:26:17 <strebe> kirindave_: yeah. I actually prototyped most of this using parsec, and then switched back to using Text when I ran into some minor problems
13:26:35 <strebe> (pebkac problems, but even so :-))
13:26:40 <kirindave_> strebe: bos & co have kinda proven Text can be crazy-fast.
13:26:49 <kirindave_> But you need to use it correctly.
13:27:04 <strebe> kirindave_: which I'd gladly learn how to do
13:27:27 <strebe> about 1/3rd of execution time is in
13:27:30 <strebe> cleanAndSplitLine l =
13:27:30 <strebe>      let p = map T.unpack (T.splitOn (T.pack "^") (T.pack l))
13:27:30 <strebe>      in map (filter (/= '~')) p
13:27:42 <strebe> which seems a bit excessive, so I'm clearly doing something in a backwards way
13:27:47 <doomlord> the big benefit of monads over state threading is that monads enforce that each state is read once i guess
13:28:15 <kirindave_> God has Data.Enumerator already become so baroque compared to conduit or pipes?
13:28:28 <kirindave_> I look at this code and I'm like, "Damn, the conduit stuff I am doing is better."
13:29:08 <strebe> kirindave_: so, for using Text correctly, is there any good documentation, or barring that, code or papers that illustrate it and hopefully mention pitfalls?
13:29:23 <kirindave_> strebe: I'm not the guy to ask.
13:29:42 <kirindave_> strebe: I use it primarily via blaze and attoparsec.
13:29:56 <strebe> hm, ok; I'll give attoparsec a whirl
13:30:01 <kirindave_> And blaze
13:30:07 <strebe> thank you
13:31:58 <sleepster> can you use "read" to compile code on the fly?
13:32:05 <sleepster> err. interpret it I mean
13:32:14 <geekosaur> read is not a general intepreter, no
13:32:24 <sleepster> it seems pretty cool that it can convert a string to a type
13:33:13 <geekosaur> it can parse some simple literals; it can't even handle all literal formats (IIRC if you deriving (Read) on a type using record syntax, it only accepts record syntax on input?  something like that)
13:33:23 <mapf`> sleepster: xmobar read config such way
13:33:47 <sleepster> ah I see
13:33:48 <sleepster> thanks
13:34:18 <rwbarton> I think that's right, derived Read only accepts record syntax
13:34:20 <benmachine> oh wow, 1006 nicks
13:34:22 <benmachine> hurray for haskell
13:34:32 <MostAwesomeDude> Nearly overtaking #python.
13:35:07 <atriq> Tying with #gentoo
13:35:17 <benmachine> perhaps someone can solve a mystery for me: I git clone http://darcs.haskell.org/packages/base.git/ but then no directory appears
13:35:27 <benmachine> no error, it looks exactly like a normal clone
13:35:36 <benmachine> only nothing actually comes of it
13:36:19 <atriq> I'm trying to badly port some C code so I can make sense of it
13:36:44 <atriq> Does "foo = unsafePerfomeIO $ newIORef 0" do anything useful?
13:36:47 <geekosaur> benmachine, I get a core dump from git-http-helper fwiw
13:37:00 <benmachine> geekosaur: huh. I don't know what that is :P
13:37:14 <rwbarton> that git clone worked normally for me, eventually
13:37:36 <geekosaur> er, git-remore-http
13:37:44 <geekosaur> possibly an os x specific issue
13:37:55 <strebe> kirindave_: hmm. Conduits look like overkill for files of perhaps a few tens of megs, which I actually want to read fairly strictly, in a toy app, though they're good to know about - or do you think they're simple enough to make sense even in that scenario?
13:38:01 <clahey> atriq: Make sense of the C code?
13:38:08 <atriq> Yeah
13:38:13 <atriq> I can only vaguely read C
13:38:18 <clahey> atriq: Why not just stay in the IO monad all the time if you're just looking to badly port it?
13:38:25 <atriq> I'm translating it into Haskell
13:38:32 <atriq> And there's a static int
13:38:37 <atriq> And I don't know what to do with it
13:38:40 <clahey> atriq: Can you share with us?
13:38:45 <kirindave_> strebe: What makes conduit good (and this is an opinion) is that its ecosystem is strongly tied to ResourceT
13:39:01 <kirindave_> strebe: The really irritating part of pipes and co is the lack of consideration for Resource management.
13:39:07 <atriq> clahey, probably, but I'm not sure it'd do any good
13:39:13 <kirindave_> That said I like Pipe's api a lot more.
13:39:19 <atriq> I'm, in the long term, porting it into Haskell well
13:39:24 <kirindave_> strebe: In practice it's not hard to write conduits for your work tho.
13:39:25 <atriq> I just want to figure out the algorithms
13:40:26 <clahey> atriq: If you give us a link, we can help understand it.  Some of us are actually much more proficient in C than haskell.
13:40:29 <rwbarton> strebe, if you don't mind storing your entire file in memory at once, nothing wrong with strict IO from Data.Text
13:40:35 <rwbarton> or ByteString, depending
13:40:37 <strebe> kirindave_: hmm. I'm reading http://www.yesodweb.com/book/conduits although it warns it's outdated; is there something else I should be reading about it?
13:40:49 <atriq> clahey, I'm afraid I'm one of the people who does a lot better figuring stuff out for myself
13:41:06 <atriq> And I'm doing this in the wrong order anyway
13:41:07 <atriq> arrgh
13:41:09 <clahey> atriq: Okay.  In that case, I have no idea the answer to your question.
13:41:12 <strebe> rwbarton: that would make a lot of sense for this particular app; what are the pros/cons of those two approaches?
13:41:21 <rwbarton> Text vs. ByteString?
13:41:24 <miguelnegrao> Hi, newbie haskeller here.
13:41:32 <rwbarton> or regular strict IO vs. conduits/pipes
13:41:32 <strebe> yes
13:41:41 <strebe> Hm. Both, actually.
13:41:50 <rwbarton> Text is for text (Unicode strings) while ByteString is for strings of bytes
13:42:05 <miguelnegrao> don't know if this is the right place to ask: how to I debug a GLUT program on osx, given that I can't use ghci (GLUT + ghci broken on osx)
13:42:07 <atriq> Basically, does "foo = unsafePerformIO $ newIORef 0" do similar to "static int foo = 0" or whatever the actually correct C code is
13:42:30 <monochrom> yes
13:42:31 <strebe> The input files are latin1, so ByteString would map to it a bit more cleanly I guess, as it's not entirely 7-bit ascii
13:42:34 <rwbarton> atriq, you should add a {-# NOINLINE foo #-}
13:42:42 <nand`> also foo should be monomorphic?
13:42:52 <atriq> It should be IORef Int, I think
13:42:52 <miguelnegrao> putStrLn statements don't seem to post anything...
13:42:53 <rwbarton> yes, that would probably be a good idea :)
13:42:55 <mzero> I *thought* that GLUT + OS X + gchi was happy if you used 32bit --- but not certain of that
13:43:22 <miguelnegrao> hum, and how do I use 32 bits ?
13:43:38 <rwbarton> strebe: what were you doing with these files?
13:43:45 <clahey> miguelnegrao: (Disclaimer, I'm a VMware employee) You should run linux inside a fusion VM and debug it there.
13:43:48 <mzero> you have to install the 32-bit platform (or ghc), and rebuild all libs, so that may not be feasible for you
13:44:07 <mzero> (alas, ghc/ghci isn't multi-arch.)
13:44:23 <merijn> edwardk: Where do I submit a patch and in which format for the (a,) Foldable/Traversable instances? :p
13:44:32 <clahey> miguelnegrao: Also, I think that might be a poor way to do it.
13:44:49 <miguelnegrao> ok, I see.
13:45:28 <strebe> rwbarton: parsing all the data, and then either dumping it into a database or creating a few indexed Maps on it - I'll probably try the latter first
13:45:29 <edwardk> merijn: good question. if you're doing it, Either also needs to go in
13:46:08 <rwbarton> strebe: I guess using ByteString for latin1-encoded data is sensible enough, or certainly if you don't care about the encoding at all (though surely you do, if you are parsing it...)
13:46:14 <miguelnegrao> Regarding putStrLn statements, they don't seem to post anything If I place them in the function that gets called every time the display updates. Is this expected ?
13:46:39 <miguelnegrao> without being able to post stuff it's difficult to see what's going on...
13:46:52 <merijn> edwardk: I guess I'll just submit a unified diff to the mailing list and wait for someone to tell me what the proper location to file tickets/enhancement requests is :p
13:47:26 <strebe> rwbarton: I do care about the encoding, but surprisingly little compared to usual, as the only characters with the high bit set are left and right double quote marks
13:47:32 <mzero> miguelnegrao: you might need to flush stdout after each
13:47:43 <mzero> or turn off buffering on stdout / stderr
13:47:46 <mzero> when you start
13:48:02 <danharaj> GHC has line buffering by default.
13:48:06 <danharaj> GHCi has something else, I forgot what.
13:48:41 <dmwit> "I care about encoding, but only a little bit" <- wut
13:48:51 <acowley> I'm getting a parse error in 7.6.1 with an {-# INLINE[1] CONLIKE f #-} pragma
13:48:51 <lambdabot> acowley: You have 1 new message. '/msg lambdabot @messages' to read it.
13:49:09 <merijn> > fst (1, throw (ErrorCall "test"))
13:49:10 <lambdabot>   Not in scope: `throw'Not in scope: data constructor `ErrorCall'
13:49:29 <merijn> > fst (1, Control.Exception.throw (Control.Exception.ErrorCall "test"))
13:49:30 <lambdabot>   Not in scope: `Control.Exception.throw'Not in scope: data constructor `Cont...
13:49:34 <merijn> oh, bah
13:49:39 <danharaj> > fst (1, error "ponies")
13:49:40 <lambdabot>   1
13:50:00 <dmwit> > "ponies" == "test"
13:50:02 <lambdabot>   False
13:50:11 <merijn> \o/ laziness
13:50:45 <strebe> dmwit: ehm, a lot of files I routinely use are in utf-8, or other multibyte encodings. For once, I'm dealing with latin1 files (and since I'm trying to improve my haskell in the process, not just iconv'ing them to a different encoding), and only a couple of not particularly important bytes per file aren't clean 7-bit ascii, so for once, I barely care about the encoding because even quite naive byte-oriented approaches won't go horri
13:50:46 <strebe> bly wrong
13:50:54 <miguelnegrao> ok hFlush stdout does it
13:50:56 <miguelnegrao> thanks !
13:50:59 <merijn> I realised I could solve my "how to signal termination of a Chan" problem by stuffing an error value in there and it would just be raised when the receiver tries to use it :)
13:51:46 <merijn> laziness++ :)
13:53:25 <monochrom> yikes
13:54:04 <efie> why is it "instance Alternative [] where ... (<|>) = (++)" and not for example "l <|> r = r"? I'm trying to figure out what Alternative is useful for, for example in use with Lists and Maybe's
13:54:15 <strebe> what, monochrom?
13:54:28 <monochrom> send an error value into a Chan
13:54:41 <merijn> monochrom: I'm open to better suggestions?
13:54:45 <danharaj> efie: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
13:54:49 <atriq> efie, Alternative is a monoid on applicatives
13:55:02 <danharaj> efie: some equations should be satisfied
13:55:05 <sleepster> are type classes similar to c++ concepts?
13:55:12 <monochrom> I have no suggestion
13:55:32 <nooodl> "send an error value into a Chan" this is what #haskellers do daily
13:55:36 <geekosaur> sleepster, type classes are unfortunately named, they are not related to OOP in any meaningful sense
13:55:57 <merijn> monochrom: The alternative ideas were: "Chan (Maybe a)" and Nothing to signal the closing of a Chan, asynchronous exceptions, or checking an IORef before every read
13:56:06 <dmwit> strebe: ASCII/latin1 is an encoding, too
13:56:35 <merijn> monochrom: The IORef idea is nasty because you're likely to get races when you switch the Chan of while blocked. Maybe would work but is not particularly nice/elegant
13:56:41 <danharaj> efie: In particular `empty <|> x` should equal `x <|> empty` and empty is naturally [] for this case.
13:56:43 <hpaste> acowley pasted “conlike” at http://hpaste.org/76100
13:56:57 <strebe> dmwit: yes, it is. But it's a single-byte one, so treating the input as raw bytes has a smaller set of pitfalls than with some other encodings
13:56:57 <acowley> can someone confirm the parse error with that sample?
13:57:03 <merijn> asynchronous exceptions aren't much better than "writeChan chan (error "foo")", and require more bookkeeping
13:57:12 <monochrom> type class is similar to concept. to answer the question
13:57:20 <sleepster> I see.. geekosaur well I was curious because it looks like in haskell, types can be categorized based on the "functionality" they support...  I haven't finished my tutorial, but I am guessing there are ways to add new classes?
13:57:37 <dmwit> strebe: If you're treating it as raw bytes, then you're not using an encoding (because you're not extracting characters).
13:57:37 <sleepster> new type classes I mean
13:57:42 <dmwit> So either you care about the encoding or you don't.
13:57:47 <dmwit> is what I'm saying
13:58:00 <acowley> Ah!
13:58:03 <acowley> It's a documentation bug
13:58:04 <quuuux> oh, uck. OverloadedStrings applies to TH, even if the spliced-in functions are defined in a module without it
13:58:06 <mzero> efie: you can think of Alternative as the case where there are some values to be considered, possible none.  Then using <|> on a list preserves all the options, using <!> on Maybe preserves the first option, if any
13:58:07 <merijn> sleepster: Yes, you can even add instances to existing types without changing them
13:58:24 <sleepster> merijn: interesting
13:58:27 <merijn> sleepster: For instance, haskell doesn't by default have a Num instance for tuples, but lambdabot defines one
13:58:27 <sleepster> thanks
13:58:33 <merijn> > (1,2) + (5,9)
13:58:35 <lambdabot>   (6,11)
13:58:47 <mzero> now you can write code which processes options, and then appy it in contexts where you only care about one result (Maybe), or otherse where you care about all (list)
13:58:49 <strebe> dmwit: I'll be extracting characters eventually, the question is at what step of the process it makes sense
13:58:58 <efie> danharaj:  ok, adding than that "l <|> [] = l"
13:59:11 <merijn> sleepster: Try running that locally in GHC :)
13:59:19 <merijn> eh, ghci
13:59:28 <sleepster> ha, I already did.. it failed
14:00:07 <merijn> sleepster: Or, weirder. Lambdabot also defines a Num instances for functions
14:00:14 <merijn> > map 1 [1..10]
14:00:15 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
14:00:29 <hpc> quuuux: one of many casualties to the sinister poison of source to source transformations
14:00:31 <merijn> (Although I wouldn't worry about that one for now)
14:00:43 <rwbarton> dmwit: well if I want to write a program to extract the second column of a CSV file, I would care very little about the encoding. only need to know the representation of ',' and the fact that that representation cannot appear as part of a longer character representation
14:00:48 <rwbarton> plus same for newlines
14:01:06 <merijn> rwbarton: And the representation of "!
14:01:14 <rwbarton> depending on how much CSV syntax I support, sure
14:01:14 <merijn> CSV files allow quoting with , inside
14:01:20 <mapf`> > map 1 [1..10]
14:01:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
14:01:33 <mapf`> wat
14:01:37 <rwbarton> anyways the program will work on utf-8 data or latin1 data but not utf-16 data or other weird encodings
14:01:48 <dmwit> rwbarton: Yeah, I've worked with formats that go that route. It ain't pretty.
14:02:02 <merijn> mapf`: Lambdabot has: "instance Num r => Num (a -> r) where fromIntegral i = const i"
14:02:03 <dmwit> Generally just caring about the encoding in the first place is going to be simpler. =)
14:02:04 <rwbarton> not particularly, no
14:02:05 <sleepster> is there a way to get ghci to add patterns for function -- sorry I probably butchered the terminology there.. but if I do:   let myDouble 0 = 2  then let myDouble x = x*2  it overwrites the previous one
14:02:27 <hpc> sleepster: let myDouble 0 = 2; myDouble x = x*2
14:02:27 <rwbarton> perhaps there ought to be a Latin1Text type (= ByteString)
14:02:51 <rwbarton> so that we don't get it confused with the EBCDICText type (= ByteString)
14:02:52 <sleepster> hpc: ah thanks..
14:02:53 <merijn> sleepster: Like hpc said, but it's usually easier to save a hs file and load/reload it using :l and :r
14:02:55 <hpc> sleepster: you should really be doing definitions in a file
14:02:58 <hpc> like merijn says
14:03:00 <efie> mzero: hm ok, but where is this useful? like MonadPlus is useful for the guard-function, what is Alternative useful for?
14:03:04 <sleepster> thanks guys
14:03:06 <sleepster> will do
14:03:27 <dmwit> Anyway, that seems like a plausible interpretation of an otherwise questionable sentence, so I withdraw my "wut". =)
14:03:51 <mzero> efie: parsing is one common usage
14:04:26 <rwbarton> or with DataKinds we have LatinNText :: Int -> * :)
14:05:18 <dmwit> hahaha
14:06:02 <strebe> dmwit: Thank you. And yes, I can see why your initial reaction would be that. :-)
14:09:11 <efie> mzero: I guess parsing isn't done with lists, so I changing the implementation for "Alternative []" to "l <|> [] = l, l <|> r = r" wouldn't hurt?
14:09:22 <merijn> The easiest way to prevent constantly having to hide id, (.), mapM and lord knows what everytime I should disable ImplicitPrelude and just makes a file importing and reexporting the relevant modules with the troublesome functions hidden, right?
14:10:28 <monochrom> wait, why do you want to hide id, (.), and mapM? :)
14:10:32 <merijn> Isn't there like a GenericPrelude package that exports the Foldable/Traversable/Category versions of functions
14:10:32 <mzero> efie: that changes the semantics of Alternative for lists, why would you do that? Also, yes, it hurts: Using [] in Alternative means that you want to collect all options, so   l <|> r = r   drops them
14:10:47 <monochrom> but yeah, make your own module for re-exporting exactly what you want
14:10:48 <merijn> monochrom: Control.Category, Data.Foldable, Data.Traversable, etc.
14:11:28 <merijn> Having to hide those functions from like 5 different modules all reexporting them gets tiresome quickly :p
14:11:39 <monochrom> it may be unnecessary to disable implict prelude
14:12:08 <rwbarton> NoImplicitPrelude is rather more invasive than a simple import Prelude (), isn't it
14:12:52 <monochrom> module MyHeader(module Prelude) where import Prelude hiding (id, (.), mapM)  may be sufficient
14:13:03 <dmwit> Honestly, I'd say NoImplicitPrelude is less invasive than import Prelude ()
14:13:06 <rwbarton> I would prefer "import Prelude (); import MyPrelude" unless you actually want to do things like redefining do notation or Num instances
14:13:16 <merijn> monochrom, rwbarton: I was thinking NoImplicitPrelude and then having Internal.hs "module Internal where (module Prelude) where import Prelude hiding (id, (.))"
14:13:25 <mzero> efie: Have you read the section on Alternative in the Typeclassopedia? 9.4 Other monoidal classes: Alternative, MonadPlus, ArrowPlus
14:13:26 <rwbarton> well, what I mean is if I am reading a module with NoImplicitPrelude I have no idea wtf is going on anywhere
14:13:30 <dmwit> depends what you mean by invasive, yeah
14:13:31 <mzero> http://www.haskell.org/haskellwiki/Typeclassopedia#Other_monoidal_classes:_Alternative.2C_MonadPlus.2C_ArrowPlus
14:13:46 <rwbarton> whereas with import Prelude () at least I still know what '3' means
14:13:53 <merijn> :p
14:14:08 <dmwit> rwbarton: Oh, even with NoImplicitPrelude it means the same thing. It's just that fromInteger might not be in scope.
14:14:18 <dmwit> So if it builds without an error, '3' still means '3'.
14:14:27 <dmwit> You have to use RebindableSyntax if you want to change that.
14:14:30 <rwbarton> oh
14:14:33 <rwbarton> oaky
14:14:34 <rwbarton> okay
14:14:39 <rwbarton> I think they changed this at some point
14:14:44 <dmwit> possibly, yeah
14:14:51 <rwbarton> but I could have a weird Num Int instance
14:14:58 <mzero> Alternative is an Applicative that is also a Monoid - hence certain laws need to be obeyed, and I don't think      l <|> r = r    for lists obeys
14:14:59 <dmwit> yes, you could, that's true
14:15:09 <efie> mzero: no, thanks I will do this. and think of Alternative as "collect/preserve all options" :)
14:15:42 <mzero> only for lists, for Maybe it is "just the first real option, thank you"
14:16:02 <dmwit> or... could you?
14:16:05 <efie> mzero: you dropped the "l <|> [] = l"
14:16:16 <dmwit> To get the Num class you'd have to import it from the Prelude, which would also bring in the Int instance.
14:16:24 <dmwit> So... I don't think you could have a weird Num Int instance.
14:16:27 * dmwit tests
14:16:52 <hpaste> boreeas pasted “quicksort” at http://hpaste.org/76101
14:17:08 <merijn> wow, I'm dumb...
14:17:14 <merijn> "zipWith (,)" >.<
14:17:29 <dmwit> rwbarton: Yeah, you can't get Num without instance Num Int
14:17:37 <Boreeas> Does someone mind why "xs !! (length xs / 2)" causes an error in http://hpaste.org/76101?
14:17:46 <Boreeas> *mind telling me, even
14:17:56 <merijn> Boreeas: Ouch, that code is going to be ridiculously slow
14:17:59 <dmwit> Boreeas: You can't divide Int's with (/), you need to use `div`.
14:18:13 <rwbarton> wait, what does 3 mean then?
14:18:27 <Boreeas> dmwit: Ouch. Well, thanks
14:18:28 <rwbarton> 3 :: (Prelude.Num a) => a?
14:18:32 <dmwit> rwbarton: It means something crazy like GHC.Primitive.ReallyPrelude.fromInteger 3
14:18:38 <rwbarton> oh huh
14:18:45 <merijn> rwbarton: Only in #haskell can you ask that question and be legitimately serious about it :D
14:18:45 <Boreeas> merijn: Yeah, I know, it's more of a practice thing
14:19:25 <rwbarton> x :: integer-gmp:GHC.Integer.Type.Integer
14:19:48 <rwbarton> or without MR, x :: GHC.Num.Num a => a
14:19:57 <rwbarton> so, I guess that's all right then
14:20:51 <rwbarton> so basically if I want to use numeric literals with NoImplicitPrelude, I have to import Num anyways
14:21:04 <rwbarton> and it's "the real Num"
14:21:20 <dmwit> right
14:21:29 <rwbarton> that's sensible then
14:21:31 * hackagebot binary-indexed-tree 0.1 - Binary Indexed Trees (a.k.a. Fenwick Trees).  http://hackage.haskell.org/package/binary-indexed-tree-0.1 (MaxwellSayles)
14:22:14 <dbp> does anyone have experience using System.Process's runInteractive*, and could they point me to some use? reading from it seems to either hang or close the process (there aren't examples in the docs)
14:22:38 <dbp> I basically want to keep sending input strings, and read all the output it gives after each one
14:23:04 <merijn> dbp: Doesn't interactive hand you the terminal?
14:23:12 <merijn> That's what the name implies to me anyway
14:23:30 <dbp> merijn: it hands you Handles for stein, stdout, and stderr.
14:23:50 <rwbarton> you might be having buffering troubles
14:24:14 <merijn> Aren't interprocess pipes block buffered?
14:24:16 <rwbarton> you need to make sure both that you are not buffering your output (easy) and that the other program isn't buffering its output (possibly hard)
14:24:29 <rwbarton> yes, that is the problem
14:24:31 <merijn> Try toggling no buffering or having one thread for input and one for output
14:24:45 <merijn> (then reading won't block input as well, thus guaranteeing progress)
14:25:08 <rwbarton> the other program can still screw you over by buffering its own output
14:25:32 <merijn> rwbarton: Assuming the program is reasonable behaved it will output it some point, even if it is when it exits
14:25:48 <merijn> As long as you feed in input it shouldn't matter
14:25:50 <rwbarton> right, but it sounds like dbp wants to get the output from one input string before writing the next input string
14:25:52 <dbp> rwbarton: well, right now the problem is that I can't even consistently read data without hanging. hGetContents and hGetLine hang waiting for more input
14:26:08 <merijn> dbp: Because the Handles are buffered
14:26:23 <merijn> dbp: hSetBuffering NoBuffering (or whatever the correct incantation is)
14:26:30 <rwbarton> just to see what is going on, try closing your stdin handle after writing your input
14:26:32 <dbp> merijn: well I hSetBuffering NoBuffering… is it buffering on the other side that's causing it?
14:26:33 <rwbarton> the first input
14:26:44 <merijn> dbp: Could be
14:26:52 <rwbarton> most likely that will convince the other program to exit and flush its output in the process
14:27:26 <dbp> rwbarton: okay, that worked. so the problem is with the other process?
14:27:45 <rwbarton> sounds like it. is this a line-based thing, where you give it a line of input and you expect a line of output?
14:27:58 <rwbarton> (also what OS, I presume unix)
14:28:10 <beaky> what is the difference between Prelude and the Haskell stldib?
14:28:12 <beaky> stdlib*
14:28:26 <ion> What’s the Haskell stdlib? Do you mean base?
14:28:52 <ion> Prelude is a module included in base, and it (and only it) is imported by default.
14:29:00 <beaky> ah
14:29:01 <dbp> rwbarton: yeah, line based. Let me play around with the other program (I wrote it too, it's that they are different languages that I'm dealing with this mess)
14:29:05 <rwbarton> aha
14:29:21 <beaky> I like how Data structures in Haskell are actually functions
14:29:31 <beaky> being evaluated
14:29:35 <rwbarton> then it should hopefully just be a matter of fflush(stdout); after the other program writes a line, or whatever the equivalent in your language is
14:30:21 <dmwit> beaky: Very few data structures in Haskell are actually functions, so I suspect you have a misconception somewhere.
14:31:12 <ion> @hackage base
14:31:13 <lambdabot> http://hackage.haskell.org/package/base
14:31:27 <jfischoff> There is a common misconception that: functional language == everything is a function
14:31:35 <beaky> ah
14:31:59 <beaky> I'm confused now :( I thought everything in haskell was either a function or a syntactical construct
14:32:13 <ion> I guess one could also call the packages that come with the Haskell Platform the “standard library”. Prelude is contained in base, and base is contained in the Platform.
14:32:35 <ion> "hello" is a value that is not a function.
14:33:12 <strebe> beaky: no, it's not like smalltalk, where everything is an object
14:33:16 <beaky> right
14:33:38 <beaky> I had that misconception where I thought that things like literal 1 was actually \_ -> 1
14:33:50 <jfischoff> yes that is common
14:33:54 <fmap> ion: until someone overloads string literals to (a -> b) :)
14:34:50 <ion> A literal 1 corresponds to fromInteger TheIntegerOne (where TheIntegerOne is hypothetical).
14:39:16 <acowley> Anyone have any tips for debugging rewrite rule firings? Simplifier output is crazy, and the ghc-core package doesn't install anymore.
14:40:07 <dbp> rwbarton: okay, still having sort of the same problem. it works except that I can't seem to figure out when there is no more input. I used the command "hWaitForInput handle 1" (to tell me if there is anything more) and it returns true, but when I try to read a line (hGetLine) it just hangs, not giving me anything, as if there isn't any more input. hIsEOF returns false too
14:40:16 <c_wraith> isn't there a flag to dump rule firings?
14:40:55 <rwbarton> dbp, you can't really ever know whether the program is done replying to your line of input
14:41:07 <rwbarton> unless you impose some fixed protocol like one line of output per line of input
14:41:18 <rwbarton> or have some other kind of in-band terminator
14:41:22 <dmwit> acowley: There's optimization fuel, if you haven't heard of it. No idea if it will help you.
14:41:25 <dbp> rwbarton: but a timeout would be reasonable, wouldn't it be?
14:41:53 <dmwit> A timeout sounds sort of racy.
14:42:50 <acowley> Racy programming is both less and more exciting than the general public might suspect.
14:43:52 <rwbarton> racy and also will make your program run unnecessarily slowly even when it works correctly
14:44:01 <acowley> dmwit: I can give that a shot, but I keep hoping there will come a day when I'll be able to somehow annotate an expression and see all the decisions the optimizer made about it.
14:46:40 <acowley> Even with -dopt-fule=0 my rewrite fires against the code I know it works against, so this may not help me track down why it doesn't fire on the code I want it to fire on.
14:46:44 <acowley> fuel, too
14:47:13 <dmwit> ugh
15:12:57 <merijn> Anyone heard of the ioscope package?
15:13:20 <merijn> I have some code apparently depending on it but don't see anything on Hackage or github
15:13:39 <shachaf> merijn: Does it allow you to cope with mobile devices made by Apple?
15:14:44 <merijn> shachaf: ha!
15:15:05 <shachaf> What's the code that depends on it?
15:15:30 <merijn> zeromq3-haskell has a "safe" branch that lists it as dependency
15:16:28 <merijn> I guess I'll base my changes on master for now and see if the maintainer contacts me and tells me where I can find it
15:17:34 <shachaf> Does this package abuse type classes? :-(
15:17:59 <merijn> Most likely :p
15:20:06 <shachaf> What's with all the types and classes?
15:20:24 <acowley> my GHC.Prim doesn't seem to export the inline function.
15:21:10 <shachaf> acowley: What about GHC.Magic?
15:21:41 <shachaf> acowley: Oh, or GHC.Exts.
15:21:51 <acowley> Ah! Magic has it.
15:21:59 <acowley> so does Exts
15:22:02 <shachaf> It's defined in Magic but I get it from Exts.
15:22:04 <acowley> why does Prim claim to export it?
15:22:52 <shachaf> GHC.Exts is a mixed bag.
15:23:14 <acowley> Specifically, the main haddocks and this, http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/special-ids.html
15:23:25 <strebe> it's a pity Data.ByteString.Char8 doesn't seem to have something like readDouble, just readInt
15:23:36 <rwbarton> there is a readDouble somewhere
15:23:41 <strebe> hmm
15:23:47 <rwbarton> bytestring-lexers or something
15:23:58 <rwbarton> http://hackage.haskell.org/packages/archive/bytestring-lexing/latest/doc/html/Data-ByteString-Lex-Double.html#v:readDouble
15:24:12 <strebe> Ah, thanks - hoogle didn't show me that
15:24:16 <shachaf> acowley: To be fair, that link only says that they're described in GHC.Prim, not exported. :-)
15:24:18 <rwbarton> I found it through hayoo
15:24:28 <rwbarton> which indexes more (all?) packages
15:24:46 <Clint> does not seem to be all
15:24:51 <strebe> ahh, good to know; thank you
15:24:55 <acowley> shachaf: :((((( http://www.haskell.org/ghc/docs/7.6.1/html/libraries/ghc-prim-0.3.0.0/GHC-Prim.html looks pretty convincing to me
15:25:03 <acowley> s/looks/looked
15:25:07 <acowley> now I know better, thanks to you :)
15:25:08 <shachaf> acowley: Where does GHC.Prim even come from?
15:25:20 <shachaf> acowley: I agree that it looks convincing. This is probably a bug.
15:25:26 <acowley> shachaf: I have no idea, I'm just following links here
15:25:34 <thoughtpolice> GHC.Prim is particularly special, because IIRC it doesn't even exist in source form
15:25:51 <thoughtpolice> it's directly part of the compiler's frontend, where all the built-in stuff is wired together
15:26:07 <acowley> This rewrite rule is killing me
15:26:07 <shachaf> thoughtpolice: That's the conclusion I was arriving at.
15:26:34 * hackagebot primitive 0.5.0.1 - Primitive memory-related operations  http://hackage.haskell.org/package/primitive-0.5.0.1 (RomanLeshchinskiy)
15:26:36 * hackagebot vector 0.10.0.1 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.10.0.1 (RomanLeshchinskiy)
15:27:30 <rwbarton> I wonder whether it would be possible to give vector the "repa 3 treatment" of marking the representation in the type
15:27:44 <rwbarton> because I found that to be extremely helpful in understanding repa's cost model
15:28:08 <acowley> I have a definition like, f = g x, marked INLINE. If, at some call site, I write "g x y" my RULE fires, but if I write "f y" it does not.
15:28:47 <shachaf> Is it a stage thing or something?
15:28:59 <rwbarton> isn't there a notion of phases for RULES/INLINE, yeah
15:29:05 <shachaf> Is it simple enough to @paste? :-)
15:29:06 <acowley> Probably, but I haven't stumbled upon the right ordering for me
15:29:19 <acowley> I'll try to make a standalone example
15:29:37 <acowley> I have some lower level rewrites at later phases that are firing, and I feel like they might be getting in the way
15:29:46 <acowley> but I don't know why that INLINE isn't kicking in immediately letting the new rule fire
15:30:05 <shachaf> acowley: You could try -dverbose-core2core to see how things are getting simplified, maybe.
15:30:31 <thoughtpolice> acowley: you need to fully apply 'f'. when SPJ did overhauling of the inliner a few releases ago, one of the changes he made was that inlining like that only kicks in for fully saturated applications. but 'f' is defined as a partial application
15:30:40 <thoughtpolice> acowley: if you define f as 'f y = g x y' i bet your rule will fire
15:30:45 <thoughtpolice> or it will be inlined, i mean
15:30:48 <acowley> shachaf: Is a magic 8-ball naming these options?
15:31:14 <acowley> thoughtpolice: Yeah, the saturation of the application must match the LHS
15:31:16 <shachaf> thoughtpolice: That's related to the (.) f g = \x -> f (g x) vs. (.) f g x = f (g x) thing, isn't it?
15:31:26 <acowley> but in this case, they do match
15:31:31 <acowley> and I've tried eta expanding, too
15:31:40 <acowley> because I have no faith in documentation claims :/
15:31:42 <thoughtpolice> shachaf: yes
15:31:45 <shachaf> thoughtpolice: What's not saturated about f = g x?
15:32:05 <thoughtpolice> oh, i misunderstood the original statement a bit
15:38:07 <acowley> Crud, my attempt at making a standalone example isn't exhibiting the same problem
15:38:30 <acowley> So I'm getting some kind of fighting between rules
15:47:00 <mcstar> oh my, trouble
15:47:39 <mcstar> lets say, i have a function, that takes a record, also, i give it a record field getter function too, as an argument
15:47:54 <mcstar> now, this way, i can access the field according to which getter i pass
15:48:12 <mcstar> but, is there a way to update that field in that function, and return a modified record?
15:48:15 <maukd> lenses
15:48:26 <sipa> indeed, that's exactly what lenses are
15:48:28 <mcstar> lens or lenses?
15:48:46 <sipa> a lens is a pair of a getter and a setter, or something equivalent to it
15:48:51 <madhadron> mcstar, The latter is the plural of the former
15:48:56 <mcstar> i know
15:49:00 <mcstar> but there are 2 packages
15:49:00 <dustingetz> what paper are you citing
15:49:02 <dustingetz> "lense"
15:49:03 <mcstar> lens and lenses
15:49:06 <shachaf> mcstar: The package you want is "lens".
15:49:07 <madhadron> Ah.
15:49:11 <mcstar> shachaf: thanks
15:49:15 <monochrom> "lenses" because that's the package name
15:49:27 <dustingetz> is there a paper that goes with it, this concept is new to me
15:49:29 <shachaf> monochrom: The package name is "lens". :-(
15:49:30 <dustingetz> of lenses
15:49:30 <monochrom> oh, yikes, I see
15:49:44 <mcstar> is it hard to use? :P
15:50:01 <mcstar> i better man up...
15:50:07 <maukd> len : lens
15:50:30 <shachaf> hThere's some nice documentation for lens.
15:51:04 <madhadron> mcstar: Actually, they're a really straightforward, useful idea as soon as you twist your head just right.
15:51:05 <mcstar> omg
15:51:10 <mcstar> huge diagram
15:51:12 <madhadron> You've probably written half baked versions of them many times.
15:51:30 <acowley> Aha!
15:51:32 <mcstar> madhadron: impossible, im a green beret
15:51:51 <hpaste> acowley pasted “inline issues” at http://hpaste.org/76104
15:52:11 <acowley> If g is not a class method, then the rule fires twice
15:52:14 <madhadron> mcstar: green beret?
15:52:20 <acowley> but if g is a class method, it only fires the first time
15:52:27 <monochrom> go with the one with a huge UML diagram :)
15:53:22 <mcstar> madhadron: i just signed up to the army(haskell, that is)
15:54:04 <madhadron> mcstar: Ah. A boot private, then. Green beret is about as high as you go in military skill and still be part of a regular branch.
15:54:08 <acowley> It feels like g is being inlined too early when it's a class method
15:54:18 <madhadron> No, you've still probably implemented half baked versions of lenses.
15:54:37 <mcstar> ive got it backwards then :)
15:56:29 <madhadron> Basically, say you have a record types containing record types containing record types.
15:56:45 <madhadron> And you want to create a new value from the old one, changing one value in one of the most nested records
15:57:27 <madhadron> So {a: {b: 1, c: 2}, q: 3} -> {a: {b: 5, c:2}, q:3}, for example
15:58:23 <madhadron> The naive way of doing it in Haskell is just painful compared with an imperative update of object.a.b = 5
15:58:55 <acowley> Anyone have any input on my phase control issue?
15:59:17 <madhadron> But all such update functions look roughly the same, so someone figured out how to write an algebra so you can just combine the pieces for each layer of records.
15:59:33 <madhadron> which makes it as straightforward as object.a.b = 5.
16:00:00 <lispy> is there a reason why finally isn't defined as finally m1 m2 = bracket (return ()) (const m2) (const m1)  ?
16:00:22 <maukd> lispy: does that type?
16:00:23 <lispy> for reference: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Exception-Base.html#finally
16:00:33 <madhadron> Anyway, off to a meeting
16:00:39 <lispy> checking
16:00:46 <quuuux> lispy: my immediate suspicion is asynchronous exception safety
16:00:53 <latro`a> madhadron: we have lenses for that
16:01:02 <lispy> maukd: yes
16:01:02 <latro`a> (or do you mean that's why we have lenses)
16:01:12 <shachaf> @src finally
16:01:13 <lambdabot> a `finally` sequel = block $ do
16:01:13 <lambdabot>     r <- catch (unblock a) (\e -> do { sequel; throw e })
16:01:13 <lambdabot>     sequel
16:01:13 <lambdabot>     return r
16:01:14 <maukd> interesting
16:01:15 <shachaf> @src bracket
16:01:16 <lambdabot> bracket before after thing = block $ do
16:01:16 <lambdabot>     a <- before
16:01:17 <lambdabot>     r <- catch (unblock (thing a)) (\e -> do { after a; throw e })
16:01:19 <lambdabot>     after a
16:01:21 <lambdabot>     return r
16:01:27 <lispy> those definitions are old
16:01:46 <lispy> shachaf: bracket (return ()) (const m2) (const m1)
16:01:47 <lispy> oop
16:01:52 <lispy> shachaf: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Control-Exception-Base.html#finally
16:02:53 <lispy> I only ask because it seems like if you get bracket right you might as well reuse it
16:03:10 <lispy> The way it is, finally might be more efficient than a finally in terms of bracket?
16:03:11 <shachaf> lispy: Looks correct to me.
16:03:53 <shachaf> There are more things in the standard library implementations of various functions to worry about than this, though. :-)
16:03:54 <hpaste> acowley pasted “inline issues 2” at http://hpaste.org/76105
16:04:19 <lispy> shachaf: It came up for me because I'm using monad transformers but excptions happen in IO
16:04:25 <acowley> Even better demonstration of the different inliner behavior between instance definitions and top-level definitions.
16:04:50 <lispy> I need define finally but I don't have access to the constructor for this monad but I was provide with bracket for my monad
16:04:53 <shachaf> acowley: It only happens with classes?
16:04:58 <acowley> shachaf: yes
16:05:05 * shachaf doesn't trust type classes.
16:05:08 <acowley> test2 is the only one where a RULE doesn't fire
16:05:11 <mcstar> im getting naked expression at top level for makeLenses ''Record
16:05:29 <maukd> needs more TH
16:05:34 <mcstar> oh
16:05:45 <mcstar> maukd: i have absolutely no idead how to use TH
16:05:46 <acowley> The class is helpful because it lets you cast a wider net with fewer RULES
16:05:59 <shachaf> mcstar: That's obviously not correct.
16:06:03 <maukd> {-# LANGUAGE TemplateHaskell #-} or something like that
16:06:08 <shachaf> You just used it above!
16:06:15 <shachaf> {-# LANGUAGE ThanksMauke #-}
16:06:25 <armlesshobo> lol
16:06:31 <mcstar> maukd: thanks
16:06:48 <c_wraith> That's almost a nethack scroll
16:06:55 <otters> is there a function that allows me to get the OS my program is running on
16:07:25 <shachaf> Thinking of Maukd you forget everything else
16:07:37 <otters> oh
16:07:39 <otters> System.Info.os
16:08:54 <acowley> Who would be a knowledgeable person to run this inline business past before I think about filing a bug?
16:09:04 <shachaf> Maybe #ghc?
16:09:28 <shachaf> They tend to know about GHC.
16:09:32 <kartoffelbrei> @pl ((a,c)->(b,c)) -> a -> b
16:09:32 <lambdabot> (line 1, column 7):
16:09:32 <lambdabot> unexpected ">"
16:09:33 <lambdabot> expecting variable, "(", operator or ")"
16:09:34 <shachaf> The rest of us all use Hugs or NHC.
16:09:42 <mapf`> lol
16:10:39 <kartoffelbrei> @djinn ((a,c)->(b,c)) -> a -> b
16:10:39 <lambdabot> -- f cannot be realized.
16:11:02 <maukd> @pl \f x -> let (y, c) = f (x, c) in y
16:11:02 <lambdabot> (line 1, column 13):
16:11:02 <lambdabot> unexpected "("
16:11:03 <lambdabot> expecting "()", natural, identifier or "in"
16:11:14 <shachaf> kartoffelbrei: Control.Arrow.loop
16:11:39 <hpc> kartoffelbrei: that's definable if you assume tuples always match (a, b)
16:11:52 <hpc> (ie, they are never undefined)
16:12:32 <otters> an even more fun question
16:12:34 <otters> nvm
16:13:43 <DanBurton> ok, so I have a function "f", and two monadic values "ma" and "mb"
16:13:47 <kartoffelbrei> shachf,hpc: thanks, but my goal is to figure out how that recursion over these tuples work out. i just wanted to know what djinn might spit out, hoping that this could help me tp understand it.
16:13:56 <DanBurton> I want to invoke "ma" then "mb" then pass them both to "f"
16:14:02 <maukd> liftM2
16:14:04 <DanBurton> Is there a pretty one-liner to do this?
16:14:30 <DanBurton> oh but there's a catch
16:14:39 <shachaf> maukd: A literal interpretation would have you do { m1; m2; f m1 m2 }
16:15:10 <DanBurton> It's essentially this: do { a <- ma; b <- m b; f a b }
16:15:18 <strebe> everyone: switching from String to ByteString made performance acceptable, thank you.
16:15:20 <shachaf> join .:: liftM2
16:15:34 <hpc> :t join .: liftM2
16:15:35 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
16:15:35 <quuuux> f `ap` ma `ap` mb
16:15:35 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
16:15:35 <lambdabot>     In the second argument of `(.:)', namely `liftM2'
16:15:42 <shachaf> @let (.::) = (.) . (.:)
16:15:44 <lambdabot>  Defined.
16:16:07 <DanBurton> @type \f ma mb -> f `ap` ma `ap` mb
16:16:08 <lambdabot> forall (m :: * -> *) a a1 b. (Monad m) => m (a -> a1 -> b) -> m a -> m a1 -> m b
16:16:10 <shachaf> @ty \f a b -> f <*> a <*> b
16:16:12 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> f a -> f a1 -> f b
16:16:14 <lispy> strebe: yes, but please use Data.Text instead of bytestrings storing Char8 (bytestring of Word8 still makes a lot of sense though)
16:16:15 <shachaf> quuuux++
16:16:28 <shachaf> Wait, no.
16:16:36 <lispy> strebe: because, unicode
16:16:37 <DanBurton> no then function needs to be a -> b -> m c
16:16:40 <shachaf> You can keep the karma point but that's not what I thought that was. :-(
16:16:50 <DanBurton> @type \f ma mb -> f `fmap` ma `ap` mb
16:16:51 <shachaf> But what I said works.
16:16:52 <lambdabot> forall a a1 b (m :: * -> *). (Functor m, Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
16:16:59 <strebe> lispy: I'm dealing with latin1 characters; dmwit was satisfied eventually that this was a sane approach. In general, I would agree with you.
16:17:06 <DanBurton> and we're back to essentially join .:: liftM2
16:17:27 <shachaf> That looks like braille.
16:17:31 <lispy> strebe: cool
16:17:38 <shachaf> "looks like braille" is a silly phrase, of course.
16:17:44 <lispy> strebe: (I promise I'm not the unicode police ;)
16:18:02 <shachaf> Wait, wait, someone is "latin1"ing?
16:18:22 <DanBurton> I want a pretty one-liner because I'm translating from an imperative language and I want the effects to happen from left to right, and also visually provide the args left to right
16:18:25 <strebe> lispy: I _am_ the unicode police, but things happen. ;-)
16:18:42 <cmccann> DanBurton, why not just use Applicative-style infix operators?
16:18:54 <strebe> shachaf: it's been known to happen, sadly
16:19:18 <otters> does anybody know what string System.Info.os returns on Windows?
16:19:30 <shachaf> You mean "is", not "returns". :-(
16:19:42 <fryguybob> otters: "mingw32" here
16:19:42 <shachaf> That's an evil "string".
16:19:46 <otters> those are our priorities
16:19:46 <lispy> otters: no, but we should be able to check via hackage
16:19:54 <otters> lispy: it isn't there
16:19:57 <lispy> ah
16:20:03 <otters> it's like, if the compiler is GHC, then it's defined to HOST_OS
16:20:05 <otters> or something like that
16:20:05 <lispy> github then :)
16:20:07 <otters> I just closed the tab
16:20:12 <otters> fryguybob: thank you
16:20:14 <DanBurton> cmccann: I can use applicatives, but then I'll have to `join`, and I sort of want to avoid join
16:20:31 <shachaf> DanBurton: join is exactly what you want.
16:20:33 <DanBurton> I think I'll just make a function "apply2 = join .:: liftM2"
16:20:37 <shachaf> It's the future.
16:20:38 <fryguybob> otters: It might be different if you are on 64-bit, but it might not (I do not have 64-bit ghc on windows).
16:20:41 <DanBurton> I do want join
16:20:41 <cmccann> DanBurton, f =<* x = join $ f <*> x
16:20:44 <DanBurton> but I don't want to write it
16:20:45 <shachaf> "apply2"? How about "bind2"?
16:20:47 <cmccann> then end the string of applications with that
16:20:57 <otters> fryguybob: I'll just check if "mingw" `isPrefixOf` os
16:20:59 <lispy> This reminds me: Now that windows ghc is either 64bit or 32bit, we could use a way to detect which one you have when making ffi bindings on windows
16:21:04 <shachaf> =<*^#$@
16:21:19 <DanBurton> shachaf: because functions of the form "a -> b -> m c" are what functions in this pseudo-imperative-language look like
16:21:26 <cmccann> note that effect order remains unambiguous (assuming Applicative conventions are followed) and the visual mnemonic of a cross between =<< and <*>
16:21:32 <lispy> (I guess win64 doesn't have stdcall anymore)
16:21:34 <quuuux> liftM2 (,) ma mb >>= uncurry f ?
16:21:36 <DanBurton> shachaf: so "apply" in that context means applying arguments to a "function"
16:21:53 <quuuux> you're going to have to either join or manually manage currying in this case, I think
16:21:54 <shachaf> DanBurton: (>>=) is the one-argument version of the same thing.
16:22:05 <quuuux> I'd prefer the former to the latter, personally
16:22:08 <shachaf> So it's only snesbislbe.
16:22:29 <DanBurton> true point
16:22:34 <mcstar> can TH be used from ghci?
16:22:48 <cmccann> mcstar, you can't do anything interesting with it
16:23:17 <mcstar> i just wanted to make a record and use it with lens
16:23:26 <shachaf> Just write the lens yourself.
16:23:32 <cmccann> yeah
16:23:34 <mcstar> i think i have to resort to writing it to a file
16:23:46 <mcstar> shachaf: how?
16:23:48 <shachaf> You can do that too, if you don't want to write the lens yourself.
16:24:29 * cmccann continues to use (=<*) to end a string of (<*>)s with a join and regrets nothing
16:25:39 <shachaf> cmccann: You weren't in PGH last time, were you?
16:26:04 <cmccann> I was the last time you asked about that
16:26:08 <shachaf> Yes, but before that.
16:26:11 <cmccann> and I am this time as well
16:26:15 <cmccann> no, I moved recently
16:26:25 <shachaf> What are you doing in PGH?
16:26:36 <shachaf> ...That's not even an airport code, is it?
16:26:41 <cmccann> the same thing I'm always doing, shachaf
16:26:55 <shachaf> @brain
16:26:55 <lambdabot> Uh, I think so, Brain, but I get all clammy inside the tent.
16:26:59 <cmccann> :D
16:29:42 <cmccann> hm
16:30:45 <mcstar> why is that, i can use my passed accessor as a getter, but not as a setter?
16:31:07 <mcstar> should i write out an explicit type sig for the function?
16:31:27 <shachaf> People aren't going to be able to answer your question because you haven't said what you're doing.
16:31:59 <mcstar> i have a function, that takes a record, and a lens-whatever-i-call-accessor
16:32:02 <AxiomOfChoice> lambdabot: @pl \x -> if x == y then f x else g
16:32:03 <lambdabot> flip (liftM2 if' (y ==) f) g
16:32:11 <mcstar> it tried to read a field, and set a field, and give back a new record
16:32:17 <mcstar> i said this before btw
16:32:51 <shachaf> English is pretty bad at expressing Haskell code.
16:33:23 * cmccann wonders if there's any information on how to implement type inference/checking in a setting that's "kinda H-M but also with extra stuff" that's less intimidating than GHC and the giant stack of papers SPJ's written about it
16:33:24 <mcstar> http://sprunge.us/XZGe
16:33:26 <acowley> schachaf: #ghc isn't exactly active, should I try #hugs?
16:33:46 <mcstar> http://sprunge.us/jiTZ
16:33:58 <acowley> I should rely on nick autocomplete more
16:34:40 <AxiomOfChoice> lambdabot: @help
16:34:41 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:34:47 <AxiomOfChoice> lambdabot: @help list
16:34:47 <lambdabot> list [module|command]
16:34:48 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
16:35:05 <shachaf> AxiomOfChoice: You can /msg lambdabot, by the way. :-)
16:35:20 <mcstar> shachaf: could you take a look at my pastes?
16:35:22 <AfC> cmccann: every alt-js language popping up claiming strong types claims to have implemented h-m type inference so perhaps you might (at second hand) find some pointers that way.
16:35:34 <mcstar> im sure its pretty trivial
16:36:32 <cmccann> AfC, pretty sure that wouldn't help me very much
16:36:38 <shachaf> mcstar: Probably. Did you try adding a type signature?
16:36:49 <mcstar> no
16:36:50 <cmccann> there's plenty out there about H-M and any extra stuff those languages would need doesn't interest me at the moment
16:37:03 <cmccann> thanks, though
16:37:04 <mcstar> it is complicated, so i was waiting for your anser
16:37:35 <shachaf> mcstar: That's the worst way to ask a question on IRC. :-(
16:38:01 <shachaf> I don't really know what's going on, so I'm not really able to answer your question without a bunch of thinking that shouldn't be necessary if there was more context.
16:38:03 <mcstar> i dont follow
16:38:03 <edwardk> mcstar: an explicit type signature will fix that. the problem is that a lens is a rank2 type so inference gives you a simpler type that is wrong when you use the same lens twice
16:38:05 <cmccann> shachaf, "worst"? that sounds like a challenge.
16:38:09 <cornihilio> what's a good way to practice working with monads?
16:38:20 <mcstar> edwardk: thanks
16:38:25 <dustingetz> implement them
16:38:28 <dustingetz> write a monadic parser
16:38:31 <dustingetz> write a lisp interpereter
16:38:34 <shachaf> Oh, see, in this case adding a type signature would have solved your problem! :-)
16:38:34 <kartoffelbrei> is there a way to define the loop function analogous to the fix functions? like: "fix x = let x = f x in x" can be written as "fix f = f (fix f)"; "loop f a = let (b,c) = f (a,c) in b" can be written as ????
16:38:39 <monochrom> translate list comprehension to monad notation
16:38:47 <AxiomOfChoice> cornihilio: Travel around the world without a permanent home.
16:38:47 <edwardk> mcstar: that said, you can usually contort it into something that doesn't need the signature and which uses the lens once, its just tricky =)
16:39:28 <mcstar> edwardk: i didnt think i would be relying on your magical lens soo soon :)
16:39:45 <edwardk> for what its worth you can simplify parts of that. board^.access.at outerIndex     instead of M.lokup outerIndex (board^.access)
16:39:47 <lispy> :t let fx f = f (fx f)
16:39:49 <lambdabot> <no location info>: not an expression: `let fx f = f (fx f)'
16:39:53 <lispy> :t let fx f = f (fx f) in fx
16:39:54 <lambdabot> forall t. (t -> t) -> t
16:39:59 <acowley> edwardk: Do you have any suggestions for automatically producing a basis for a free vector space ala linear?
16:40:05 <cornihilio> dustingetz: well, I kind of really still don't know what I'm doing, and I'd ideally like to work on something where I have access to the answers too, since I don't want to keep pestering people on this channel.
16:41:23 <edwardk> acowley: data V3 a = V3 { __x, __y, __z :: a }; makeLenses ''V3; instance Representable V3 where rep f = V3 (f _x) (f _y) (f _z); instance Monad V3 where (>>=) = bindRep; return = pureRep
16:41:53 <AxiomOfChoice> :t if'
16:41:54 <edwardk> mcstar: the rest of those bindings in there can probably be cleaned up quite a bit with the lens machinery too
16:41:55 <lambdabot> Not in scope: `if''
16:42:41 <edwardk> mcstar: what does deleteFromUnit do?
16:42:42 <mcstar> edwardk: thats just an initial version the stuf''' will go away, but ill see
16:42:45 <lispy> kartoffelbrei: you would need to use some tuple functions to write it in the same style
16:43:03 <edwardk> mcstar: i see you deleting some indices from things, etc. but trying to understand its actual meaning
16:43:19 <edwardk> is this like a chess board?
16:43:25 <mcstar> edwardk: well, it deletes a value from the 3 kinds of units from a sudoku board
16:43:58 <edwardk> units being row, column and sub-square?
16:44:01 <mcstar> when i set a value for a square, this will eliminate that value from the possiblities in the matching units
16:44:04 <mcstar> edwardk: yes
16:45:20 <rwbarton> kartoffelbrei: I think you would need a second "helper" function
16:45:31 <AxiomOfChoice> @help if'
16:45:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:45:42 <AxiomOfChoice> @haddock if'
16:45:43 <lambdabot> Unknown command, try @list
16:45:45 <shachaf> AxiomOfChoice: if' b x y = if b then x else y; if' doesn't exist anywhere.
16:46:01 <rwbarton> kartoffelbrei: something like loop f a = fst (f a (loopC f a)); loopC f a = snd (f a (loopC f a))
16:46:03 <AxiomOfChoice> shachaf: Thanks.
16:46:20 <rwbarton> kartoffelbrei: um, except passing a tuple to f instead of two arguments separately
16:46:54 <kartoffelbrei> lispy, rwbarton: thanks
16:47:34 * shachaf read about how recursive do works recently.
16:47:40 <shachaf> It's more complicated than regular do. :-(
16:48:36 <shachaf> Also, fixIO uses MVars and unsafeInterleaveIO and things of that sort.
16:49:22 <shachaf> preflex: seen SamB
16:49:23 <preflex>  Sorry, I haven't seen SamB
16:49:26 <shachaf> preflex: seen SamB_XP
16:49:26 <preflex>  Sorry, I haven't seen SamB_XP
16:49:53 <acowley> edwardk: Why is Lookup a superclass of Indexable?
16:50:12 <edwardk> originally because it has a default definition in terms of Indexable
16:50:39 <edwardk> keys is somewhat unprincipled
16:51:29 <acowley> I'm left with a partial index function if I do this the obvious way
16:52:32 <shachaf> Have there been any proposals for checked "minimal complete definitions" for type classes?
16:53:33 <acowley> Actually, I'm also not sure how to generate a basis using these pieces
16:54:05 <mcstar> edwardk: what would be the correct type sig for 'doubleRec'? http://sprunge.us/KQbH?haskell
16:54:14 <edwardk> one sec
16:54:25 <edwardk> i'm putting together a nicer version of the code you pasted ;)
16:54:41 <acowley> Oh
16:54:43 <acowley> I did it
16:54:50 <mcstar> oh, im in your debt
16:55:28 <edwardk> doubleRec :: Simple Lens a [b] -> a -> a
16:55:30 <mcstar> edwardk: that code has an error, btw
16:55:49 <edwardk> you can do it better with
16:55:54 <mcstar> in if M.null (M.filter ((==0) . size) unit'') then Just ((access .~ (M.insert outerIndex unit'' (board ^. access))) board) else Nothing
16:56:01 <mcstar> edwardk: that should be the last line ^^
16:56:03 <edwardk> doubleRec l rec = l %~ \s -> s ++ s
16:58:21 <edwardk> @hpaste
16:58:22 <lambdabot> Haskell pastebin: http://hpaste.org/
16:58:36 <hpaste> edwardk pasted “for mcstar” at http://hpaste.org/76107
16:58:55 <edwardk> that still needs a signature, but uses some more lens goodies
16:59:13 <hpaste> acowley pasted “basis” at http://hpaste.org/76108
16:59:19 <mcstar> edwardk: thanks, the sig worked, after i added rank2types :)
16:59:27 <acowley> edwardk: Is that the general shape of what you were suggesting?
17:00:04 <roconnor> edwardk: what's %?
17:00:10 <acowley> flip ($)
17:00:15 <edwardk> % :: a -> (a -> b) -> b
17:00:24 <edwardk> its also 'mod' in c/c++
17:00:32 <roconnor> <_<
17:00:35 <edwardk> so %= becomes 'mod-equals' ;)
17:00:39 <edwardk> for modify ;)
17:00:46 <danharaj> I did not know about % :3
17:00:47 <shachaf> @slap edwardk
17:00:48 <lambdabot> I won't; I want to go get some cookies instead.
17:00:57 <edwardk> danharaj: its in Control.Lens
17:01:05 <roconnor> I understand %=
17:01:12 * shachaf wonders why GHC doesn't have a name for (ptext . sLit)
17:01:21 <shachaf> Given that it uses ptext (sLit "blah") thousands of times.
17:01:29 <roconnor> oh I see
17:01:31 <roconnor> mod
17:01:34 <roconnor> okay
17:01:38 <edwardk> roconnor: %= becomes the infix use of % to the target of the lens. Basically it was retconning a principled application of an operator
17:01:38 * hackagebot dynamic-linker-template 0.1.0.1 - Automatically derive dynamic linking methods from a data type.  http://hackage.haskell.org/package/dynamic-linker-template-0.1.0.1 (SylvainHenry)
17:01:39 <acowley> I've been avoiding using (%) as I find it confusing
17:01:43 <mcstar> edwardk: it is remainder, not mod, (wrt negative numbers)
17:01:45 <roconnor> crap
17:01:50 <roconnor> it is so readable now.
17:01:50 <edwardk> mcstar: fair nuff
17:01:57 <roconnor> it's almost nice
17:02:12 <shachaf> edwardk: Now I can't import Control.Lens and Data.Ratio!
17:02:23 <edwardk> shachaf: sure you can, just use / instead of %
17:02:27 * shachaf gets a sense of déjà vu.
17:02:35 <shachaf> edwardk: (%) :: Integer -> Integer -> Rational
17:02:39 <rwbarton> quite
17:02:45 <edwardk> > 4/5 :: Rational
17:02:46 <lambdabot>   4 % 5
17:02:50 <edwardk> > 4%5 :: Rational
17:02:51 <lambdabot>   4 % 5
17:02:55 <edwardk> zomg
17:02:56 <edwardk> so different
17:03:08 <monochrom> @let x :: Integer; x = 4
17:03:12 <lambdabot>  Defined.
17:03:16 <shachaf> > (20 `div` 4) % 5 :: Rational
17:03:17 <monochrom> > x / 5 :: Rational
17:03:17 <lambdabot>   1 % 1
17:03:18 <shachaf> > (20 `div` 4) / 5 :: Rational
17:03:18 <lambdabot>   Ambiguous occurrence `x'
17:03:20 <lambdabot>  It could refer to either `L.x', defined at <local...
17:03:22 <lambdabot>   No instance for (GHC.Real.Integral GHC.Real.Rational)
17:03:24 <lambdabot>    arising from a use...
17:03:24 <monochrom> oh haha
17:03:26 <maukd> > (4 `mod` 5) % 5
17:03:27 <lambdabot>   4 % 5
17:03:28 <monochrom> @undefine
17:03:37 <shachaf> @@ @let rot13 = @where rot13
17:03:37 <monochrom> @let mono :: Integer; mono = 4
17:03:39 <lambdabot>  Defined.
17:03:39 <danharaj> edwardk: any insights on your hoas-bound task?
17:03:40 <lambdabot>  Defined.
17:03:48 <edwardk> danharaj: got distracted ;)
17:03:49 <monochrom> > mono / 5 :: Rational
17:03:51 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
17:03:51 <lambdabot>         against inferred t...
17:03:59 <danharaj> edwardk: you mean preempted by a more important thread :P
17:04:07 <monochrom> > mono % 5 :: Rational
17:04:09 <lambdabot>   4 % 5
17:04:16 <monochrom> they're so the same!
17:04:36 <edwardk> roconnor: for a while i was using |> like f#, but the problem with that is that you then want |>= to become mod-equals
17:04:47 <edwardk> which is okay for a while, then you realize you get <|>= for the chaining version
17:04:52 <edwardk> and that looks like something very different ;)
17:05:01 <edwardk> and its longer and pretty ugly
17:05:20 <shachaf> edwardk: Should've used ▶
17:05:21 <edwardk> monochrom: totally =)
17:05:24 <edwardk> shachaf: =)
17:05:44 <edwardk> anyways, % was the least used operator i could repurpose. i wanted to avoid stealing #
17:05:56 <shachaf> No one uses ▶
17:06:01 <edwardk> shachaf: =P
17:06:06 <thoradam> Hello everyone, how can I create a list from 0 to n where n is the parameter to the function? For example: tri n = foldr (+) [0..n]
17:06:08 <shachaf> Is (#) valid with MagicHash?
17:06:12 <shachaf> thoradam: scanl
17:06:25 <monochrom> @undefine
17:06:25 <edwardk> > let x ▶ y = x + y in 4 ▶ 5
17:06:27 <lambdabot>   9
17:06:34 <edwardk> shachaf: yeah
17:06:39 <edwardk> that was the problem
17:06:39 <shachaf> > scanl1 (+) [1..]
17:06:41 <lambdabot>   [1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
17:06:59 <shachaf> Haskellers gotta have their MagicHash.
17:07:00 <edwardk> because the lens style tends to favor lack of spaces in a lot of places, and that becomes ambiguous
17:07:15 <roconnor> > (enumFromTo 0) 5
17:07:15 <edwardk> and i just have a prejudice that # looks ugly
17:07:16 <lambdabot>   [0,1,2,3,4,5]
17:07:27 <roconnor> thoradam: ^^
17:07:33 <shachaf> Oh, wait.
17:07:41 <koala_man> thoradam: you're missing the starting value for foldr. foldr (+) 0 [0..n]
17:07:41 <rwbarton> i don't understand the question
17:07:43 <shachaf> thoradam: Ignore what I said. :-(
17:07:59 <thoradam> Thanks dudes!
17:08:32 <edwardk> roconnor: you saw the zipper stuff where i use % all over the place, right?
17:09:10 <monochrom> I cannot understand how "a list from 0 to n where n is the parameter to the function? For example: tri n = foldr (+) [0..n]" leads to scanl
17:09:25 <roconnor> edwardk: nope; I've been out of the loop for the last month
17:09:45 <edwardk> acowley: anyways, the way i tend to build bases is to make them explicit. data E3 = X3 | Y3 | Z3; instance Indexable V3 where
17:09:54 <shachaf> monochrom: It doesn't unless you only read part of the text and think it means somethign different from what it does.
17:10:03 <edwardk> acowley: the reason for the use of Control.Lens.Representable is to _avoid_ the crap in keys ;)
17:10:21 <edwardk> because that way we don't have to name each basis differently. _x works as a key
17:10:21 <monochrom> it is, in fact, on par with some of the student proofs I was grading that got 0/10
17:10:30 <edwardk> foo^._x
17:10:53 <acowley> oh, different Representable class
17:11:07 <edwardk> zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip      ==> ("Jelly","world")
17:11:22 <shachaf> monochrom: I'll take that grade.
17:11:28 <edwardk> roconnor: that uses lenses and traversals as layers of the zipper and lets you move left and right within a traversal
17:11:38 * hackagebot dynamic-linker-template 0.1.0.2 - Automatically derive dynamic linking methods from a data type.  http://hackage.haskell.org/package/dynamic-linker-template-0.1.0.2 (SylvainHenry)
17:11:43 <roconnor> edwardk: I'm not sure I want to understand that
17:11:44 <acowley> edwardk: And I guess we can still use Vector with some indexable lens mummery
17:12:01 <edwardk> :t zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y'        ==> Top :> (String,String) :> String :> Char
17:12:03 <lambdabot> Not in scope: `zipper'
17:12:03 <lambdabot> Not in scope: `down'
17:12:03 <lambdabot> Not in scope: `_1'
17:12:14 <acowley> edwardk: You should write a blog post on just that example
17:12:37 <edwardk> acowley: i plan on using it as the capstone for a talk i'm giving at bay area haskell next week
17:12:42 <danharaj> I wonder how that code looks in core.
17:12:48 <monochrom> I am fine with reading just part of the text. I am not fine with "think it means something different". there are a million somethings different, which one should I choose, and how do I know?
17:12:50 <edwardk> danharaj: surprisingly not terrible
17:13:54 <danharaj> muted enthusiasm in that phrase :P
17:13:58 <edwardk> roconnor: basically 'down' takes a lens and adds a layer to the current zipper's breadcrumb, fromWithin takes a traversal
17:14:17 <edwardk> and assumes its not empty and goes down focusing on the first element
17:14:22 <shachaf> monochrom: I agree.
17:14:23 <edwardk> then you can move left and right within the traversal
17:14:48 <edwardk> danharaj: well, the lens stuff works pretty well, and inlines away almost completely, the traversal stuff gets a bit uglier
17:15:00 <roconnor> edwardk: so focus is no longer focus?
17:15:18 <edwardk> roconnor: nah zoom subsumed it at some point, and i removed the alias
17:15:28 <roconnor> hmm
17:15:29 <edwardk> and later on focus came along as the lens for the target of the zipper
17:15:49 <danharaj> edwardk: I wrote a traversal for unboxed vectors but I am skeptical that stream fusion is possible through the fmap.
17:16:03 <danharaj> unless GHC will specialize the code for known functors?
17:16:09 <edwardk> stream fusion probably won't happen
17:16:14 <acowley> edwardk: Do I still need an Indexed instance to construct the individual vectors of the basis?
17:16:46 <edwardk> acowley: just use 'set _x 1 0' as the unit x vector
17:17:00 <acowley> I want a function basis : t a -> [t a]
17:17:16 <acowley> that colon should have been ::
17:17:27 <danharaj> if it ever becomes an issue for me I'll look at the core and see if maybe specialize pragmas on the applicative it takes lets GHC fuse.
17:17:30 <edwardk> acowley: ah you want an enumerable basis =)
17:17:36 <acowley> edwardk: Yes
17:17:52 <edwardk> let me see if i can remember the trick
17:18:08 <danharaj> (maybe GHC would need a rule about commuting stream . runIdentity . unstream . Identity)
17:18:14 <acowley> edwardk: I wrote this dogleg nonlinear function optimizer, and it's great, but I have to pass it a basis of the parameter's vector space. It's lame, and I want to come up with a default basis on my own.
17:18:58 <acowley> Also, now that there are different people here, does anyone have any insight into my phase control over INLINE problems? http://hpaste.org/76105
17:20:24 <roconnor> danharaj: GHC is a constant disappointment to me
17:20:53 <danharaj> roconnor :(
17:21:13 <roconnor> the only bright spot is computers are so fast and my problems so small that even GHC makes my computations run fast.
17:21:19 <edwardk> hrmm, given a diagonal matrix its pretty easy. i have tricks for constructing one in 'ad', but i'm trying to concoct a minimal version without all that plumbing
17:23:41 <acowley> It's funny because making a zero vector is easy, and it would seem like all we want to do is focus on each element, one at a time, and put in a 1, then collect the results
17:23:47 <edwardk> yeah
17:24:11 <edwardk> you can do it in a funny way, by taking the 0 vector, getting its length, then making n vectors by using mapAccum
17:24:44 <acowley> how does that let me turn on the particular index of each basis vector?
17:24:49 <edwardk> there should be another way by using traverse of the 0 vector
17:25:21 <edwardk> you can make a state monad that tracks the current index
17:25:34 <edwardk> let me bang it out the hard way ;)
17:25:56 <roconnor> using lens is like learning a new language.
17:26:01 <edwardk> basis :: (Representable f, Traversable f, Num a) => [f a]
17:26:04 <edwardk> or something like that
17:26:04 <sleepster> why is it that in the expression (x:xs), x matches the first element and xs matches the rest of the list? isn't [x, xs] = x:xs:[] ?
17:26:25 <mcstar> the last one is true
17:26:28 <edwardk> roconnor: not sure if that is a compliment ;)
17:26:39 * hackagebot dynamic-linker-template 0.1.0.3 - Automatically derive dynamic linking methods from a data type.  http://hackage.haskell.org/package/dynamic-linker-template-0.1.0.3 (SylvainHenry)
17:26:42 <avpx> sleepster: You can't have [x, xs] because x and xs are of different types.
17:26:47 <avpx> sleepster: x :: A, xs :: [A]
17:26:57 <rwbarton> note that x:xs:[] means x:(xs:[])
17:27:00 <acowley> does Traversable have a way of setting a particular element?
17:27:04 <sleepster> ah I see.. x and xs in this case are type variables.. of course
17:27:08 <sleepster> thanks
17:27:11 <avpx> sleepster: Woah now
17:27:11 <mcstar> no
17:27:15 <sleepster> no?
17:27:16 <edwardk> acowley: i have several with lens
17:27:19 <rwbarton> what? no they are just ordinary value level variables
17:27:21 <sleepster> uh oh
17:27:21 <avpx> sleepster: No, x and xs are ordinary values.
17:27:42 <edwardk> oh yeah, this got easier, thanks =)
17:27:57 <mcstar> > [1,2] == 1:2:[]
17:27:59 <lambdabot>   True
17:28:14 <mcstar> > let x:xs = "abcd" in (x,xs)
17:28:15 <lambdabot>   ('a',"bcd")
17:28:28 <mcstar> > let (:) x xs = "abcd" in (x,xs)
17:28:29 <lambdabot>   ('a',"bcd")
17:28:48 <mcstar> > [1,2] == (:) 1 ((:) 2 [])
17:28:49 <lambdabot>   True
17:29:27 <sleepster> mcstar: correct.. so intuitively, I'd imagine that if I had x:xs match "abcd", I think x = "a" and xs = "b"
17:29:38 <mcstar> no
17:29:46 <mcstar> thats not intuitive
17:29:55 <mcstar> a list is: head + tail
17:29:57 <avpx> sleepster: (:) is the constructor for lists. It takes x :: a and xs :: [a] and gives you a new list (x:xs) :: [a]
17:30:24 <sleepster> ah that's right
17:30:34 <avpx> sleepster: It's just an ordinary linked list. So it has some value and then more list.
17:30:35 <sleepster> that's what I was missing
17:30:36 <rwbarton> if you had [x, xs] match "ab", then x = 'a' and xs = 'b' (and you probably chose the name xs wrong)
17:30:38 <mapf`> :t (:)
17:30:38 <mcstar> sleepster: you cant do anything else with a list, except putting an element in front of it, or removing an elementr from the front
17:30:39 <lambdabot> forall a. a -> [a] -> [a]
17:30:48 <edwardk> basis = [ element k .~ 1 $ zero | k <- [0..lengthOf traverse zero - 1]] where zero = pure 0
17:30:51 <bgamari> Is there a nice way to enumerate the indices of a Repa Shape?
17:31:09 <sleepster> thanks guys.. it makes sense now
17:31:22 <avpx> Cool.
17:31:23 <edwardk> basis = [ set (element k) 1 zero | k <- [0..lengthOf traverse zero - 1]] where zero = pure 0
17:31:31 <edwardk> whichever of those is clearer to you
17:32:22 <edwardk> acowley: that work?
17:32:34 <sleepster> I forgot the type of (:) which as mentioned previously (:) :: a -> [a] -> [a]
17:33:27 <edwardk> basis :: (Applicative t, Traversable t, Num a) => [t a]
17:34:10 <dmj> I get a lexical error when I try to build a project in haskell... HelloWorld.hs:1:1: lexical error (UTF-8 decoding error)
17:34:18 <dmj> any idears?
17:34:27 <dmj> ghc --make -threaded HelloWorld.hs -c helloworld
17:34:37 <shachaf> dmj: Something is messed up with your .hs file.
17:34:50 <dmj> its a happstack file
17:34:58 <dmj> with a hello world server
17:35:00 <rwbarton> sounds like you maybe have an editor that likes to write utf-16 files with a byte order mark or something
17:35:06 <dmj> vim?
17:35:17 <shachaf> xxd HelloWorld.hs | head -n 1
17:35:35 <rwbarton> well it does seem unlikely, doesn't it. but yeah, find out what is really in your file like shachaf suggested
17:36:08 <dmj> that command says 1 doesn't exist
17:36:30 <shachaf> xxd HelloWorld.hs and paste the first line.
17:36:35 <avpx> He left...
17:36:42 <shachaf> (Or look at the first line. But anyway, you're gone.)
17:37:39 <edwardk> doh
17:38:00 <shachaf> OK, time to figure out what this BOX thing in GHC is.
17:38:03 <edwardk> acowley: basis :: (Applicative t, Traversable t, Num a) => [t a]; basis = [ set (element k) 1 zero | k <- [0..lengthOf traverse zero - 1]] where zero = pure 0
17:38:27 <acowley> edwardk: ah! I didn't know about lengthOf traverse, so I used a Foldable
17:38:39 <acowley> I also did a fmap (const 0) instead of the Applicative constraint
17:38:49 <edwardk> you can use 0..lengthOf folded zero - 1 -- might be a little faster
17:38:56 <acowley> sorry for the disconnect, btw, I didn't notice it happened and wondered why everyone was so quiet
17:39:25 <edwardk> acowley: this version doesn't need to take 't a' as an argument
17:39:38 <shachaf> Hmm, kinds have kinds in GHC?
17:39:45 <acowley> edwardk: I have designs to do this with Vector, though, which isn't statically sized
17:40:01 <edwardk> acowley: fair nuff, then its easier
17:40:03 <shachaf> Ah, no.
17:40:03 <acowley> I'm currently just using ZipList to give me access to Linear.Vector
17:40:18 <hpc> shachaf: types can be lifted to kinds
17:40:42 <edwardk> you can use 0 <$ rather than fmap (const 0) too
17:40:45 <Jafet> shachaf: sort of.
17:40:50 <edwardk> for some container types thats more efficient
17:40:55 <acowley> where is lengthOf?
17:41:08 <edwardk> Control.Lens.Fold i think
17:42:43 <acowley> Is there any reason lengthOf traverse would be better than foldl'?
17:42:57 <edwardk> nah, it was just there =)
17:43:14 <acowley> yeah, I was looking for it in Foldable
17:43:34 <edwardk> yeah there could be a generic 'length' function in Data.Foldable
17:43:40 <acowley> Ah, so now I have the problem of needing to define a Representable instance for Vector
17:43:45 <edwardk> its one of the few cases i'd advocate adding it to the class
17:43:46 <acowley> which means I need a LensFactory
17:43:59 <edwardk> yeah Vector isn't Representable
17:44:08 <edwardk> basis didn't use representable though
17:44:28 <edwardk> you can make a fixed length vector type that sits on TOP of vector that can be representable
17:44:36 <acowley> huzzah!
17:44:44 <acowley> edwardk: This is great, thanks for the help!
17:44:53 <edwardk> e.g. newtype Vec (n :: Nat) a = Vec { unvec :: Vector a }
17:45:22 <acowley> You know, I've used lens quite a lot now, and I still don't really understand it to any depth
17:45:29 <acowley> I need to rectify that
17:45:30 <edwardk> then you can make up some Fin n type for finite naturals < n that is the index into it
17:45:43 <edwardk> the fact that you can do so was my goal ;)
17:45:44 <acowley> type level Nats already gave me heart burn earlier today
17:45:46 <shachaf> acowley: You should come to edwardk's talk in CA next week!
17:46:11 <acowley> shachaf: I was lucky enough to get a private tutorial, but my brain bounced when it hit the ground and it took me a while to find it
17:46:38 <edwardk> acowley: i've been playing with adding http://unlines.wordpress.com/2010/11/15/generics-for-small-fixed-size-vectors/ to the linear package
17:46:59 <edwardk> acowley: that would necessitate me adding Fin, etc. anyways
17:47:10 <acowley> I would absolutely love a Fin type, btw
17:48:15 <shachaf> What's with GHC showing a different number of arguments for things involving polymorphic kinds some of the time?
17:48:17 <edwardk> from there i guess its not a HUGE step to make 'Vec n a', hopefully with removable hand and eye
17:48:25 <acowley> Obviously I haven't read this at all closely yet, but my concern is that there is a natural expectation that small vectors will have very high performance. I don't' want any fancy machinery getting the way of that.
17:48:45 <ParahSailin> what's a dynamic array (mutable) data structure to use?
17:48:55 <avpx> STArrays?
17:48:57 <acowley> this does look really good
17:49:05 <edwardk> roman's code vanishes when compiled even better than the lens code
17:49:09 <acowley> who's is it?
17:49:14 <acowley> Oh, this is Roman L.?
17:49:16 <edwardk> he's far more performance conscious than i am
17:49:18 <edwardk> yeah
17:49:32 <acowley> Alrighty then, let's steal his ideas! :)
17:49:39 <edwardk> yep
17:49:59 <edwardk> trick is deciding if i want to shackle us to 7.6
17:50:09 <edwardk> DataKinds make this a lot nicer
17:50:39 <acowley> I have accepted 7.6 into my heart
17:50:47 <ParahSailin> dynamic resizing?
17:50:49 <acowley> my OpenCV bindings are all DataKinded up
17:51:06 <edwardk> k. i'll commit Linear.Dim then and you can play with it
17:51:39 * hackagebot linear 0.2.0.2 - Linear Algebra  http://hackage.haskell.org/package/linear-0.2.0.2 (EdwardKmett)
17:51:52 <edwardk> thats not it btw =) that was an earlier commit ;)
17:51:58 <mm_freak> ParahSailin: MVector
17:52:14 <ParahSailin> thanks
17:52:33 <mm_freak> ParahSailin: are you new to haskell?
17:52:45 <ParahSailin> pretty much
17:53:05 <edwardk> acowley: https://github.com/ekmett/linear/blob/master/src/Linear/Dim.hs
17:53:10 <mm_freak> then mutable arrays are likely not what you want, just what your earlier experience with programming languages makes you think you want =)
17:53:29 <ParahSailin> no it is what i want-- im not _that_ new
17:53:43 <mm_freak> what's the application?
17:53:47 <acowley> why is there no Traversable instance for ZipList?!
17:54:00 <shachaf> want++
17:54:00 <mm_freak> acowley: laziness =P
17:54:09 <edwardk> acowley: propose it to the libraries@ mailing list
17:54:15 <edwardk> some folks have been making noise about instances
17:54:27 <ParahSailin> i have one list that i'm splitting each item into one of tens of thousands of lists
17:54:40 <acowley> oh lawdy, a real proposal? Can't I just fork base on github? :P
17:55:57 <mm_freak> ParahSailin: anything else or just splitting/splicing?
17:56:20 <ParahSailin> might be other things, but yes, pretty much "binning"
17:56:36 <mm_freak> use a regular immutable Vector then
17:56:58 <mm_freak> less code, likely faster, same memory requirement
17:57:45 <ParahSailin> that somehow doesnt involve allocating an entire new chunk of memory and copying contents?
17:57:58 <mm_freak> why should it?  it's immutable after all =)
17:58:18 <rwbarton> you can use accumArray
17:58:20 <mm_freak> in fact, if possible, the intermediary vectors get fused away
17:58:34 <ParahSailin> how does that work?
17:58:53 <mm_freak> you have "abcdefg" and extract two vectors "abc" and "defg"
17:58:56 <rwbarton> the documentation http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array-IArray.html#v:accumArray even includes a similar sort of example
17:58:56 <ParahSailin> immutable, but you can modify without copying contents and creating new one?
17:58:57 <mm_freak> those use the same memory block
17:59:03 <ParahSailin> ah
17:59:11 <acowley> edwardk: I think we should put basis into linear
17:59:22 <edwardk> sure
17:59:27 <acowley> in Linear.Vector
17:59:30 <acowley> I'll do it
17:59:49 <edwardk> i think the one i just pasted is probably the right one. the one that takes an extra parameter is probably something like basisFor or basisOf
17:59:53 <mm_freak> ParahSailin: the real bonus is stream fusion…  if possible, your vectors disappear entirely, so your vector operations become mere memory operations
18:00:06 <edwardk> probably basisFor  since Of is universally parameterized on a lens in my code
18:00:23 <acowley> Okay
18:00:31 <mm_freak> ParahSailin: that's not possible for mutable vectors
18:00:39 <ParahSailin> that would probably be a stack overflow in my case
18:00:55 <mm_freak> how?
18:00:55 <ParahSailin> dealing with lists hundeds of milions of items long
18:01:01 <edwardk> adding Linear.Dim broke the travis tests, so i'm going to shut them down
18:01:29 <mm_freak> ParahSailin: not at all…  you shouldn't think of traditional imperative execution principles, because a haskell program works differently…  it doesn't even have a call stack
18:02:04 <mm_freak> > foldl' (+) 0 [1..1000000]
18:02:05 <lambdabot>   500000500000
18:02:09 <mm_freak> uses O(1) memory
18:02:20 <ParahSailin> i'm not a complete newb, i've had it die on stack overflow errors before
18:02:52 <mm_freak> ok, but those are not caused by the vectors…  you probably have too many nested pattern matches
18:03:19 <mm_freak> (nested in the operational sense, not the literal sense)
18:04:01 <rwbarton> if you are doing binning then why would you need to resize the array?
18:04:50 <ParahSailin> each "bin" list will have to be held in memory in its entirety though
18:05:18 <rwbarton> oh, the individual bins are what you're resizing?
18:05:30 <ParahSailin> yeah
18:06:02 <mm_freak> ParahSailin: only the original memory block will be in memory…  a Vector is essentially just a pointer and a size…  only if you change the bins and fusion does not apply, then additional memory will be allocated
18:06:20 <mm_freak> in other words the vector library does The Right Thing most of the time
18:07:16 <mm_freak> for example if you append to a bin, calculate the element sum and then forget the bin, no allocation will occur
18:07:44 <rwbarton> or you can just use accumArray and then there is no "most of the time" to worry about
18:08:07 <edwardk> acowley: the repo is bumped to 0.3, Linear.Dim is added. feel free to flesh it out
18:08:11 <ParahSailin> i don't understand how i can use a regular immutable array without doing a bunch of mem cpy
18:08:15 <mm_freak> an MVector will not save you there anyway, if you want to resize the bins, because a vector is a continuous block of memory…  to resize an individual bin, except the last, you would need to copy anyway
18:08:18 <edwardk> acowley: it may be a while before this version sees hackage though
18:08:22 <acowley> edwardk: Yeah, I'm having rebase fun at the m omen :)
18:08:24 <acowley> moment
18:08:27 <acowley> shoot
18:08:36 <edwardk> i just hit you again, didn't i ;)
18:08:36 <acowley> well, I guess that's okay. Nobody I work with can use Haskell anyway
18:08:57 <acowley> I end up jumping through dozens of hoops to make things usable, and github isn't the worst hoop
18:09:08 <mm_freak> ParahSailin: vectors are essentially copy-on-write…  that's how it works
18:09:24 <ParahSailin> yeah i dont want to copy vectors millions of times
18:09:45 <ParahSailin> that seems like it would be slow
18:09:54 <mm_freak> just to get you right…  will you change the boundaries of the bins, or will you actually change/append to the contents
18:09:58 <mm_freak> ?
18:10:38 <mm_freak> if you have "abcdef" and take bins like ["abc", "def"], will you change to ["ab", "cdef"] or actually something like ["abcx", "def"]?
18:10:56 <acowley> GHC hates my six year old CPU
18:11:00 <ParahSailin> i have 20000 lists; i'm going through a list of hundreds of millions of items-- each item will be appended to one of the 20000 lists depending on some information of the item
18:11:08 <shachaf> items++
18:11:56 <mm_freak> ParahSailin: in that case you can use Map Key (Vector Item) or even Vector (Vector Item)
18:12:10 <mm_freak> particularly if your long list doesn't need to be in RAM
18:12:16 <mm_freak> like if it comes from a file handle
18:12:36 <ParahSailin> long list will be lazy, sure
18:12:48 <ParahSailin> bytestring
18:12:51 <acowley> edwardk: pushed
18:13:23 <mm_freak> ParahSailin: what are the keys?  just continuous Int indices?  like [0..19999]?
18:13:28 <ParahSailin> but i dont want to copy a new vector for each item in it
18:13:35 <mm_freak> you won't
18:13:50 <ParahSailin> how does append work without copy
18:14:25 <mm_freak> simple:  if the source is an actual list, you won't append at all =)
18:14:30 <mm_freak> you can construct vectors lazily
18:14:34 <lispy> jmcarthur: Looks like optimal evalution has a ton of book keeping overhead and complete laziness has some open questions about it too
18:14:50 <lispy> jmcarthur: http://lambda-the-ultimate.org/node/2343#comment-35029
18:15:07 <mm_freak> ParahSailin: if i showed you code how i would take a long list of random numbers and put them into vectors by divisibility, would that help?
18:15:13 <ParahSailin> i tried something like that before with foldl
18:15:30 <ParahSailin> that would be helpful, yes
18:17:15 <jmcarthur> lispy: optimal evaluation is indeed known to have a ton of bookkeeping overhead
18:17:24 <shachaf> λ> type Foo k = Int
18:17:24 <shachaf> λ> :i Foo
18:17:24 <shachaf> type Foo k k = Int 	-- Defined at <interactive>:2:6
18:17:45 <rwbarton> k :: k
18:17:50 <jmcarthur> lispy: optimal evaluation actually has so much that it makes it asymptotically worse
18:18:11 <jmcarthur> lispy: thyer's thesis proves that completely lazy evaluation's overhead at least isn't that bad, though
18:18:27 <jmcarthur> lispy: and with a JIT it's possibly even worth it
18:20:03 <jmcarthur> lispy: i also think thyer isn't quite right when he says "for everyday programs the memo-tables don't stop growing". i think he just never removed anything from his memo tables even when the keys are long dead.
18:20:26 <rwbarton> shachaf: I suppose the k's don't shadow each other because the first k is a kind, and the second k is a type!
18:20:36 <rwbarton> is this 7.6?
18:20:46 <shachaf> Yes.
18:21:04 <shachaf> Happens with 7.4 too, though.
18:21:25 <kirindave> jmcarthur: It's weird to imagine a memoization scheme for production-ready code that doesn't include a real-size memory bound and an LRU eviction scheme.
18:21:42 <rwbarton> hmm
18:21:45 <mm_freak> ParahSailin: are duplicate elements allowed in a bin?
18:21:51 <rwbarton> sometimes I have seen it print AnyK instead of a kind variable
18:22:18 <ParahSailin> potentially, but unlikely
18:22:27 <rwbarton> oh, that happens for newtypes. how odd
18:22:37 <mm_freak> ParahSailin: an implementation that disallows duplicates is much easier to write
18:22:42 <jmcarthur> kirindave: even an LRU eviction scheme isn't necessary. just having finalizers that evict entries once the keys are GCed is enough
18:22:48 <ParahSailin> ok, not allowed
18:23:08 <kirindave> jmcarthur: Err, you want to have a space based eviction scheme.
18:23:12 <jmcarthur> kirindave: (for this specific case)
18:23:20 <kirindave> jmcarthur: Ah, in that case carry on
18:23:24 <ParahSailin> in my data sets, all items are unique
18:23:28 <jmcarthur> kirindave: these are not memo tables being used the the typical way
18:23:34 <kirindave> jmcarthur: In general you really want to be able to put an uppoer bound on space consumed.
18:23:38 <jmcarthur> right
18:23:45 <shachaf> rwbarton: It looks like it's more of a "it just always prints k" thing.
18:23:51 <jmcarthur> in this case, doing that would actually change semantics
18:24:17 <jmcarthur> (operational semantics, that is)
18:24:22 <rwbarton> > accumArray (flip (:)) [] (0,2) 0 $ map (\n -> (n `mod` 3, n)) $ [1..5]
18:24:24 <lambdabot>   Couldn't match expected type `a -> b'
18:24:24 <lambdabot>         against inferred type `GHC.Ar...
18:24:36 <rwbarton> > accumArray (flip (:)) [] (0,2) 0 $ map (\n -> (n `mod` 3, [n])) $ [1..5]
18:24:37 <lambdabot>   Couldn't match expected type `a -> b'
18:24:38 <lambdabot>         against inferred type `GHC.Ar...
18:24:48 <rwbarton> > accumArray (flip (:)) [] (0,2) $ map (\n -> (n `mod` 3, [n])) $ [1..5]
18:24:50 <lambdabot>   array (0,2) [(0,[[3]]),(1,[[4],[1]]),(2,[[5],[2]])]
18:24:55 <rwbarton> oops
18:25:01 <rwbarton> > accumArray (flip (:)) [] (0,2) $ map (\n -> (n `mod` 3, n)) $ [1..5]
18:25:02 <lambdabot>   array (0,2) [(0,[3]),(1,[4,1]),(2,[5,2])]
18:25:15 <rwbarton> shachaf: haha, indeed.
18:25:30 <rwbarton> type Foo2 k k k l = Int -- Defined at <interactive>:12:6
18:25:44 <shachaf> How did you get that?
18:25:52 <rwbarton> type Foo2 k l = Int
18:26:05 <shachaf> Oh, it's one k per variable.
18:26:32 <rwbarton> it is showing you the kind polymorphism of Foo2
18:26:32 <shachaf> Right.
18:26:38 <shachaf> It would be nice if it pretty-printed something that GHC accepts...
18:26:50 <monochrom> please don't use 3 k's consecutively :)
18:26:50 <rwbarton> can't have that, too easy
18:26:57 <hpaste> “Ertugrul Söylemez” pasted “Classify list elements” at http://hpaste.org/76110
18:27:29 <mm_freak> ParahSailin: see the paste…  it's far from optimal, but it sufficed for most of my needs
18:27:41 <shachaf> Also is there a way to use the "forall (k :: BOX) (a :: k). ..." syntax yourself?
18:27:49 <shachaf> Or is it only something that GHC pretty-prints?
18:27:50 <ParahSailin> mm_freak, thanks
18:28:24 <lispy> jmcarthur: I see
18:29:05 <hpaste> “Ertugrul Söylemez” annotated “Classify list elements” with “Classify list elements (annotation)” at http://hpaste.org/76110#a76111
18:29:25 <mm_freak> ParahSailin: slightly nicer version annotated…  same thing, just using foldl' instead of explicit recursion =)
18:29:56 <rwbarton> that is going to have pretty gross overhead compared to a simple accumArray/[]
18:30:10 <rwbarton> when the keys happen to be consecutive integers
18:30:40 <rwbarton> could also accumArray an Array of Vectors, I don't know how good those are for repeated cons
18:31:16 <lispy> :t accumArray
18:31:18 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
18:31:26 <ParahSailin> ah, Set is binary trees-- makes sense
18:31:30 <shachaf> trees++
18:31:52 <lispy> Haskell arrays are pretty terrible
18:31:53 <mm_freak> rwbarton: could you show how to use accumArray here?
18:31:57 <rwbarton> see above
18:32:02 <rwbarton> > accumArray (flip (:)) [] (0,2) $ map (\n -> (n `mod` 3, n)) $ [1..5]
18:32:04 <lambdabot>   array (0,2) [(0,[3]),(1,[4,1]),(2,[5,2])]
18:32:14 <rwbarton> why are they terrible
18:32:21 <Saizan> shachaf++ #balancing karma
18:32:22 <mm_freak> rwbarton: vectors are not that good for repeated cons
18:32:29 <mm_freak> Seq is probably the best option here
18:32:34 <shachaf> Saizan: shachaf-- :-)
18:32:38 <mm_freak> let's see how Seq performs
18:33:08 <mm_freak> 2.5 secs to classify 10M elements with the Set solution
18:33:16 <lispy> rwbarton: everytime I used arrays, there was always an equally elegant way to do it with better performance
18:33:21 <rwbarton> what you would really want for space-efficient repeated cons is something like a linked list of up-to-n elements for some smallish n (maybe like n=6)
18:33:32 <rwbarton> I would suspect you were using arrays wrong then
18:33:39 <rwbarton> I have had nothing but good experiences with them
18:34:02 <rwbarton> and every time I try to use Vector it's a disaster
18:34:02 <mm_freak> Seq needs 1.8 secs
18:34:25 <rwbarton> mm_freak: btw I don't think your code is strict enough unless you import Data.Map.Strict
18:34:44 <rwbarton> because nothing is forcing the values in the map otherwise
18:34:46 * Ralith wonders how you do better performing sequential lookup than on an array
18:35:17 <rwbarton> actually, that is not true about Vector. half the time it is a disaster, and half the time it is blazingly fast
18:35:33 <rwbarton> but I have never been able to predict which
18:35:45 <mm_freak> rwbarton: just switching to insertWith' made it strict enough, but also slower
18:35:45 <shachaf> Twist: It's a blazingly fast disaster every time.
18:36:00 <cmccann> rwbarton, the latter happens when dons ninjas into your house and optimizes your code when you're not looking
18:36:06 <cmccann> I'm pretty sure that's how Vector works
18:36:06 <rwbarton> aha
18:36:28 <mm_freak> yeah, Vector is black magic
18:36:40 <mm_freak> dons feels when you use it
18:36:41 <shachaf> cmccann: dons has given a wrong and/or irrelevant answer to every Haskell question I've asked on StackOverflow. :-(
18:37:07 <rwbarton> mm_freak, can you paste your entire test program?
18:37:10 <lispy> I thought vector was rewriting to get good fusion plus a bit of magic to get good unboxed representations when possible
18:37:13 <mm_freak> shachaf: dons is the performance guy…  his approach isn't always nice, but it's fast
18:37:29 <mm_freak> rwbarton: main = print $ classify (`mod` 20000) [1..1000000]
18:37:35 <rwbarton> my actual conclusion about vector is that it is not a replacement for array at all
18:37:36 <mm_freak> that's the missing part
18:37:39 <lispy> (eg., not that magical, just well designed for performance)
18:37:40 <rwbarton> mm_freak: thanks
18:38:02 <lispy> rwbarton: The multidimensional support is not there for vector.
18:38:11 <mm_freak> lispy: i mostly use boxed vectors
18:38:15 <lispy> rwbarton: so that's an obvious place where array can be simpler
18:38:22 <mm_freak> because that allows some vector creation craziness
18:38:26 <mm_freak> through laziness
18:38:48 <lispy> But, you can use indexing tricks to make a multidimensional interface to a vector
18:38:59 <mm_freak> lispy: or just use repa =)
18:39:09 <rwbarton> probably this benchmark shouldn't print the output...
18:39:20 <lispy> mm_freak: yeah, I should try out repa. I still haven't touched it
18:40:13 <mm_freak> not sure if repa is a good approach…  i like the idea of DPH
18:40:49 <rwbarton> repa 2 had a lot of the black magic problems of vector. repa 3 is much nicer
18:41:44 <Saizan> where black magic = rewrite rules ?
18:42:39 <mm_freak> if a single-core repa solution took 10 secs, the dual-core solution took around 7 secs
18:42:41 <rwbarton> actually it was not even that black
18:42:46 <mm_freak> the simple vector solution took less than a second
18:44:33 <rwbarton> in repa 2 an array was basically a sum type over different representations of the array, most importantly "as a index -> value function" vs. "as a chunk of memory"
18:44:57 <sinelaw> Hello! I'm trying to work with emacs + haskell, but the haskell-mode doesn't recognize the types of anything except simple (Prelude only?) functions
18:45:16 <sinelaw> is there a way to make it know about whatever is imported at the current file?
18:45:19 <rwbarton> if you try to work with the wrong representation you might get a big slowdown
18:45:34 <rwbarton> in repa 3 the representation is indicated by part of the array type
18:46:34 <mm_freak> sinelaw: the proper search term is "inferior-haskell"
18:53:22 <rwbarton> in my tests Vector of [] was the fastest, beating Array of [] by about 20%
18:53:45 <rwbarton> Vector of Seq and Vector of Vector were 3-4 times worse
18:54:33 <rwbarton> mm_freak's code about 16x worse which is not really that bad considering it's using a Map
18:54:51 <rwbarton> oh wait
18:54:53 <rwbarton> more like 8x worse
18:55:34 <rwbarton> apparently the best data structure for a linked list is still a linked list
18:55:37 <randomclown> @pl \x -> f y x
18:55:37 <lambdabot> f y
18:55:42 <randomclown> @pl \x -> f x y
18:55:43 <lambdabot> flip f y
18:59:04 <mm_freak> rwbarton: Vector or MVector?
18:59:09 <rwbarton> just Vector
18:59:12 <tac> @pl \f -> fix f
18:59:12 <lambdabot> fix
18:59:16 <sinelaw> mm_freak, thanks, seems that I have inferior-haskell up and running
18:59:19 <rwbarton> using accum or accumulate (they had about the same performance)
18:59:20 <tac> damn smartass pointless.....
18:59:40 <sinelaw> but it still doesn't find the function i'm looking at (which comes from the hxt package)
18:59:42 <rwbarton> test code is main = do { let x = V.accumulate (flip (:)) (V.replicate 20000 []) $ V.map (\n -> (n `mod` 20000, n)) $ V.enumFromTo 1 1000000; print $ sum . map length $ V.toList x}
19:01:43 * hackagebot wl-pprint-extras 3.0.0.1 - A free monad based on the Wadler/Leijen pretty printer  http://hackage.haskell.org/package/wl-pprint-extras-3.0.0.1 (EdwardKmett)
19:02:03 <mm_freak> rwbarton: notice that the input is a lazy list
19:02:14 <mm_freak> yours is probably fused
19:03:03 <rwbarton> I had a version with a lazy list input too, that's what I was saying
19:03:06 <rwbarton> same performance
19:03:25 <rwbarton> accum takes a list rather than a vector
19:05:52 <mm_freak> i think i've never used accum/accumulate before
19:06:35 <rwbarton> they are pretty useful! magic pure interface to impure implementation
19:06:42 <rwbarton> accumArray is the same thing in array
19:08:31 <rwbarton> I guess Data.Array has to do index conversion since it doesn't know the indices will be of the form (0,n)
19:08:35 <rwbarton> maybe that is why it is a bit slower
19:12:46 <sinelaw> mm_freak, inferior haskell doesn't seem to be loading ghci the same way it runs from a terminal
19:12:49 <rwbarton> mm_freak, your code also becomes faster if I replace Set by []
19:12:53 <sinelaw> because it doesn't find the type
19:13:10 <sinelaw> :(
19:13:27 <mm_freak> rwbarton: by reversing the element order?
19:13:39 <rwbarton> I guess, of course I am adding new elements at the front
19:13:41 <mm_freak> or does accum actually allow unfolding?
19:13:46 <mm_freak> ok
19:13:58 <sinelaw> hmm...it runs ghci fine, just doesn't load the source file I'm looking at
19:13:58 <rwbarton> this is the one using a Map
19:14:00 <mm_freak> that's basically why i chose Seq instead of [] =)
19:14:09 <mm_freak> sinelaw: no idea, because i don't use it
19:14:15 <mm_freak> i just know that it exists =)
19:14:26 <randomclown> > uncurry (flip (+)) $ (1,2)
19:14:28 <lambdabot>   3
19:14:31 <sinelaw> mm_freak, heh thanks though!
19:17:55 <rwbarton> now it is only 4x as slow as the best version
19:18:54 <rwbarton> > 20000 ** 0.25
19:18:55 <lambdabot>   11.89207115002721
19:21:57 <jmcarthur> i like both Vector and Repa. am i crazy?
19:25:18 <jmcarthur> mm_freak: "or does accum actually allow unfolding?"  if by unfolding you mean fusion, then no, but it does allow array recycling (basically meaning that if you follow it with another operation that is implementing using mutable arrays then it will just keep using the existing one instead of making a copy)
19:25:22 <BMeph> jmcarthur: Yes. Just not because of that. ;)
19:25:42 <jmcarthur> *implemented using
19:40:14 <dmwit> > 1024/60
19:40:16 <lambdabot>   17.066666666666666
19:48:29 <dmwit> yum++
19:57:18 <danharaj> how is the llvm backend for ghc nowadays?
19:58:10 <jmcarthur> good for numeric computation, as it always has been
19:58:17 <jmcarthur> doesn't seem to hurt otherwise
19:58:29 <danharaj> sounds nice
19:58:34 <jmcarthur> slower compilation
19:59:06 <danharaj> can ghc build things in parallel yet?
19:59:09 <jmcarthur> i've witness ghc generate some pretty dump assembly that llvm would never do, also
19:59:21 <jmcarthur> ghc can't, but cabal-install can build multiple packages at once now
19:59:25 <danharaj> hm
19:59:36 <danharaj> define pretty dump
19:59:42 <jmcarthur> *dumb
19:59:45 <danharaj> ah
19:59:51 <danharaj> I thought it was some young kids slang ;)
19:59:53 <jmcarthur> things like storing and then loading things immediately after
20:00:05 <jmcarthur> over and over and over
20:00:46 <dmwit> let () = () in let () = () in let () = () in let () = () in 3
20:02:08 <shachaf> > let in let in let in let in 3
20:02:10 <lambdabot>   3
20:02:39 <dmwit> we're running out of zero-bit registers mang
20:04:29 <shachaf> Uh-oh.
20:05:32 <rwbarton> fortunately i heard there is a way to store two zero-bit registers in a single zero-bit register somehow
20:05:54 <danharaj> rwbarton: I think that requires quantum circuits.
20:05:59 <dmwit> The real question is can you diagonalize and store zero zero-bit registers in a single zero-bit register?
20:06:20 <stew> its pointless, since you can store so many more in a 1 bit register
20:06:53 <shachaf> stew: 1-bit registers are hard to come by!
20:07:01 <danharaj> 1-bit registers don't scale
20:07:17 <shachaf> Whereas 0-bit registers don't even register on the scale.
20:21:26 <Xezlec> Hello
20:22:15 <Xezlec> I'm trying to make complex integers an instance of Num so I can add them and such
20:23:16 <dmwit> sounds fun
20:23:19 <Xezlec> well, more specifically, I'm trying to make complex reals an instance of Num
20:23:47 <dmwit> (I assume this is a learning exercise. If not, you can grab and implementations of complex numbers from Hackage.)
20:23:48 <Xezlec> but I can't find many conversion functions for types like Real
20:23:56 <shachaf> Data.Complex.Complex is already a Num instance.
20:23:59 <Xezlec> No, not a learning exercise
20:24:08 <Xezlec> only for RealFloat
20:24:08 <dmwit> > 3 :: Complex Double
20:24:09 <lambdabot>   3.0 :+ 0.0
20:24:27 <dmwit> > 3 :: Complex CReal
20:24:28 <lambdabot>   3.0 :+ 0.0
20:24:34 <rwbarton> > 3 :+ 1
20:24:35 <lambdabot>   3.0 :+ 1.0
20:24:41 <rwbarton> > (3 :+ 1) * (4 :+ 2)
20:24:42 <lambdabot>   10.0 :+ 10.0
20:24:53 <Xezlec> > (3 :+ 1) :: Complex Int * 3
20:24:54 <lambdabot>   <no location info>: parse error on input `*'
20:25:07 <dmwit> > ((3 :+ 1) :: Complex Int) * 3
20:25:08 <lambdabot>   No instance for (GHC.Float.RealFloat GHC.Types.Int)
20:25:08 <lambdabot>    arising from a use o...
20:25:19 <dmwit> =)
20:25:24 <rwbarton> Complex Int is no good I guess, because of abs .........
20:25:27 <rwbarton> friggin' abs
20:25:31 <rwbarton> or signum
20:25:53 <Xezlec> Yes, well, I need complex integers, so I'm trying to figure out how to do it
20:26:06 <Xezlec> I don't see why no abs shoudl prevent me from being able to add
20:26:28 <shachaf> You can probably take the Data.Complex code as it is, more or less, and relax the constraints while adding errors for things like abs.
20:26:39 <rwbarton> @type sqrt
20:26:40 <lambdabot> forall a. (Floating a) => a -> a
20:27:02 <shachaf> Xezlec: "abs" is a method of "Num".
20:27:05 <rwbarton> I should probably not suggest the horrible alternative I'm thinking of.
20:27:06 <Xezlec> shachaf: good point
20:27:10 <Xezlec> Yes I know that
20:27:22 <shachaf> rwbarton: No?
20:27:31 <Xezlec> I was just saying that grouping operations into classes is kind of weird.  but errors are the answer I suppose
20:28:01 <dysinger> If I'm looking for something python/ruby's mechanize am I out of luck currently ?  I tried shpider (assumes everytihng's html) & http-conduit (not really a robot lib).
20:28:10 <dysinger> s/something/something like
20:28:13 <rwbarton> shachaf, writing an instance Floating Int
20:28:27 <sinelaw> I need to write something that does: [HashMap k v] -> HashMap k [v]
20:28:32 <rwbarton> it's code reuse!
20:28:36 <shachaf> rwbarton: OK, you were right.
20:28:53 <Xezlec> That makes me wonder why typeclasses are better than just plain old polymorphism, where each function can be defined for any number of different type signatures.  I guess that would make inference harder
20:29:27 <dmwit> class PlainOldPolymorphism a where name :: a
20:29:38 <shachaf> That's not what people in here associate with the phrase "plain old polymorphism".
20:30:00 <Xezlec> I don't know what else to call it, sorry
20:30:05 <dmwit> class PlainOldAdHocPolymorphism a where perhapsThisWillPleaseShachaf :: a
20:31:24 <Xezlec> Regardless of what you want to call it, I bet it's possible to write a type inference engine that does that.  Maybe I should add that to my bucket list...
20:31:37 <dmwit> We have one. I just told you how to have it.
20:31:52 <shachaf> Xezlec: If you're figuring out types based on values, and values based on types, you run into a bit of a problem. :-)
20:32:13 <rwbarton> the designers of Haskell 98 could have split Num into more classes
20:32:16 <Xezlec> shachaf: I wasn't using values
20:32:31 <Xezlec> dmwit: I'm having trouble understanding
20:32:35 <tswett> Ahoy.  I'm trying to use Cabal to install Idris on a relatively fresh Linux box.  I'm getting ExitFailure 127.  Here's the tail of the output using maximum verbosity: http://pastie.org/5033224
20:33:22 <tswett> Apparently the command "make -C rts clean IDRIS=../dist/build/idris/idris" failed for some reason?
20:33:32 <rwbarton> tswett: the error may be much (much much) earlier
20:33:40 <rwbarton> I guess
20:33:45 <shachaf> Xezlec: class Plus a where (+) :: a -> a -> a; instance Plus Int where (+) = ...; instance Plus Double where (+) = ...
20:33:49 <shachaf> You can do that if you want.
20:33:55 <shachaf> Although you shouldn't want.
20:34:38 <tswett> It couldn't take that long to look through 268 lines of errors and stuff.
20:34:51 <Xezlec> And then you have to use fundeps and such to cover the case of multiple types.
20:34:59 <sinelaw> @hoogle x -> [x]
20:35:00 <lambdabot> Prelude repeat :: a -> [a]
20:35:00 <lambdabot> Data.List repeat :: a -> [a]
20:35:00 <lambdabot> Test.QuickCheck.Arbitrary shrinkNothing :: a -> [a]
20:35:00 <Xezlec> Why shouldn't I want?
20:35:11 <rwbarton> tswett: actually, in this case it looks more like that make actually is failing
20:35:15 <dmwit> Xezlec: It's code. There's nothing left to explain. =)
20:35:16 <tswett> class MagmaWithRespectToAddition where ...
20:35:22 <shachaf> Xezlec: class Plus a where (+) :: a; instance Plus (Int -> Int -> Int) where (+) = ...
20:35:28 <sinelaw> @type :[]
20:35:30 <lambdabot> parse error on input `:'
20:35:35 <dmwit> :t (:[])
20:35:36 <lambdabot> forall a. a -> [a]
20:35:37 <sinelaw> @type \x -> x:[]
20:35:38 <lambdabot> forall a. a -> [a]
20:35:41 <bgamari> Man, zippers on quad-trees seem like they could be rough
20:35:49 <sinelaw> hoogle :#$@#@
20:35:57 <sinelaw> never mind that.
20:37:35 <Xezlec> shachaf: Oh, I see now.  So why would it be bad to do things that way?
20:38:15 <shachaf> Xezlec: Try it out and you'll see.
20:38:48 <Xezlec> Immediately?  Or in the long term?  ;)
20:39:21 <shachaf> I suspect you'll see it pretty quickly but who knows.
20:40:22 <Xezlec> And that will explain why it's bad to be able to add things that can't be abs'ed?
20:40:47 <shachaf> It's not bad.
20:40:58 <shachaf> The numeric hierarchy isn't great.
20:41:35 <Xezlec> I guess I picked a bad problem for my first non-toy use of Haskell.
20:42:05 <Xezlec> I'm trying to make a library for a file format we use at work.  It can store more than one type of data.
20:44:23 <rwbarton> tswett: you can always try the hammer of strace-ing cabal install... might give you some insight into what is going wrong
20:45:16 <shachaf> strace++
20:45:30 <rwbarton> fwiw I installed idris 0.9.3.1 without a hitch a few weeks ago here
20:46:17 <Mortchek> Xezlec, data Foobar a b = Foo a | Bar b
20:46:28 <clahey> edwardk, Around?  Do you have that trifecta example?
20:46:32 <shachaf> idris doesn't build for me.
20:46:37 <shachaf> ...But that's with 7.6.
20:46:43 <edwardk> the STG one i linked to the other day?
20:46:59 <clahey> edwardk, Probably.
20:47:01 <alpounet> clahey, the one from dylan lukes' repo?
20:47:05 <clahey> Yeah.
20:47:06 <rwbarton> strace ought to have an option to show only system calls that errored
20:47:07 <edwardk> https://github.com/DylanLukes/Winchester-STG-Compiler/blob/master/WSC/Parser.hs
20:47:08 * tswett does that.
20:47:10 <tswett> ...wut
20:47:10 <clahey> Thanks.
20:47:22 <Xezlec> Mortchek: even better, I'm just doing data Foobar = Foo a | Bar b | ... without any type arguments.
20:48:20 <tswett> 6,375 lines of output.  I guess that's not *that* many...
20:48:31 <Xezlec> Mortchek: but when I real in a file full of 8-bit integers, and I'm told to average them, I have a problem.  Converting to float would be pretty bad as this data is 8-bit for a reason (it's huge).
20:48:36 <Xezlec> *read
20:48:53 <sinelaw> @hoogle a -> Vector a
20:48:54 <lambdabot> Warning: Unknown type Vector
20:48:55 <lambdabot> Prelude id :: a -> a
20:48:55 <lambdabot> Data.Function id :: a -> a
20:49:05 <sinelaw> I meant: [a] -> Vector a
20:49:15 <Mortchek> Xezlec, exact or truncated average?
20:49:17 <shachaf> @hackage vector
20:49:18 <lambdabot> http://hackage.haskell.org/package/vector
20:49:44 <shachaf> sinelaw: Click Data.Vector, search for [a] -> Vector a. :-)
20:49:51 <Xezlec> Mortchek: Truncated is fine.  And sorry, I should have been more specific: 8-bit *complex* integers.
20:50:14 <sinelaw> shachaf, heh thanks (fromList does it)
20:50:17 <Xezlec> Mortchek: And averaging was just one example.
20:50:18 <Nereid> what's a complex integer?
20:50:29 <rwbarton> if you need really fine control over your data representation then Haskell can be a pain
20:50:46 <Xezlec> Nereid: I guess nothing, in Haskell-land.  But in C-land, it's just two integers in a file.
20:51:05 * rwbarton was hoping for 4 bits for the real part and 4 bits for the imaginary part
20:51:07 <dmwit> tswett: Can't you just use make's own debugging facilities?
20:51:37 <Xezlec> In fact, we even use 3-bit data because sometimes 8-bit can end up going to more petabytes than we have available.
20:51:42 <rwbarton> that is another option yeah
20:51:45 <tswett> dmwit: I didn't know make had debugging facilities.
20:52:00 <clahey> How can you do " " <* parser?   How does " " become a parser?
20:52:13 <rwbarton> can you control that with an environment variable? otherwise it would be a bit of a pain
20:52:15 <shachaf> @google overloadedstrings
20:52:17 <lambdabot> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/type-class-extensions.html
20:52:17 <lambdabot> Title: 7.6.�Class and instances declarations
20:52:48 <clahey> Overloaded strings was going to be my guess.
20:52:53 <rwbarton> what's that character after "7.6."
20:52:55 <clahey> So you can't do that with anything else.
20:53:05 <clahey> Though I guess you could do pure 5 <* parser
20:53:32 <rwbarton> @eval 3
20:53:42 <Xezlec> rwbarton: It still might be possible.  I'm not giving up yet.  I think I have an idea.
20:53:42 <rwbarton> is there an @ command for > ?
20:54:02 <rwbarton> @run 3
20:54:02 <copumpkin> @run 3
20:54:03 <lambdabot>   3
20:54:04 <lambdabot>   3
20:54:05 <rwbarton> thanks
20:54:07 <shachaf> rwbarton: NO-BREAK SPAEC
20:54:08 <copumpkin> high five!
20:54:13 <dmwit> tswett: make --debug=[abvijm]
20:54:20 <rwbarton> @. @run " @google overloadedstrings "
20:54:20 <lambdabot> Plugin `compose' failed with: Unknown command: "@run"
20:54:24 <rwbarton> this isn't going to work is it
20:54:27 <rwbarton> @@ @run " @google overloadedstrings "
20:54:28 <lambdabot>   " @google overloadedstrings "
20:54:32 <shachaf> rwbarton: You might want @show
20:54:33 <tswett> dmwit: so I somehow add that to the call to 'make' that cabal is performing?
20:54:34 <geekosaur> drop the @s
20:54:36 <geekosaur> I think
20:54:38 <shachaf> Or parentheses.
20:54:40 <sinelaw> @hoogle (a -> b) -> (t a -> t b)
20:54:41 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
20:54:41 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
20:54:41 <lambdabot> Data.Functor fmap :: Functor f => (a -> b) -> f a -> f b
20:54:44 <rwbarton> help
20:54:46 <shachaf> @@ @run " (@google overloadedstrings) "
20:54:48 <lambdabot>   " (@google overloadedstrings) "
20:54:51 <dmwit> tswett: right
20:54:54 <rwbarton> @show me
20:54:55 <lambdabot> "me"
20:55:02 <rwbarton> @show me test
20:55:02 <lambdabot> "me test"
20:55:04 <shachaf> @@ @show (@google overloadedstrings)
20:55:05 <lambdabot>  "http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/type-class-extensions.html Title: 7.6.\239\191\189Class and instances declarations"
20:55:05 <rwbarton> better
20:55:08 <rwbarton> aha
20:55:10 <rwbarton> that looks wrong
20:55:11 <rwbarton> :P
20:55:13 <shachaf> @@ @show " (@google overloadedstrings) "
20:55:14 <lambdabot>  "\" (@google overloadedstrings) \""
20:55:17 <shachaf> Weird.
20:55:18 <dmwit> tswett: It even tells you exactly what make command it tried so it should be easy. =)
20:55:21 <bgamari> Xezlec, What is your application?
20:55:27 <rwbarton> I guess @@ knows about "", unfortunately
20:55:30 <bgamari> out of curiosity
20:55:44 <shachaf> rwbarton: That can probably be worked around with @run and a second @@.
20:55:47 <tswett> dmwit: and where am I supposed to run this command?
20:55:55 <rwbarton> oh really
20:56:01 <dmwit> in a terminal?
20:56:05 <Xezlec> bgamari: There are lots of applications.  It's just a file format for storing generic data, mostly acoustics-related.
20:56:22 <rwbarton> tswett, you will have to cabal unpack idris first, poke around a bit
20:56:26 <bgamari> Xezlec, I see
20:56:50 * hackagebot mighttpd2 2.8.2 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.8.2 (KazuYamamoto)
20:56:52 * hackagebot wai-websockets 1.3.1 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.3.1 (MichaelSnoyman)
20:57:45 <rwbarton> shachaf, wouldn't the inner @run still need quotes around @google overloadedstrings
20:58:38 <Xezlec> Well, It's tired and I'm getting late.  Thanks for the discussion.  Bye.
20:58:58 <rwbarton> I guess that is what @show is for
20:59:09 <shachaf> rwbarton: Oh, uh, right.
20:59:20 <shachaf> There's also @read for the other direction.
20:59:24 <rwbarton> amazing
20:59:36 <shachaf> You can do fancy metaprogramming with lambdabot.
20:59:40 <rwbarton> I wonder what purpose whoever added these had in mind
20:59:42 <shachaf> Much more powerful than CPP.
20:59:43 <carter_> shapr yo
21:00:36 <rwbarton> > map (printf "%x" :: Int -> String) [239,191,189]
21:00:37 <lambdabot>   ["ef","bf","bd"]
21:01:09 <rwbarton> oh, so it really is a replacement character this time
21:01:22 <rwbarton> shachaf, where did you get the nonbreaking space
21:01:25 <rwbarton> from the actual page?
21:01:50 * hackagebot conduit 0.5.2.6 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.2.6 (MichaelSnoyman)
21:01:54 <shachaf> rwbarton: Yes. The actual page just has a single \xA0
21:02:07 <shachaf> The UTF-8 decoding is turning it into the replacement character.
21:02:15 <tswett> rwbarton: so I unpack the Idris package and then... poke around in it.  Am I supposed to run make in there somewhere?
21:02:23 <rwbarton> I guess my browser is turning it into an actual space then
21:02:30 <shachaf> Yep, mine too.
21:02:30 <rwbarton> tswett, hmm
21:02:34 <shachaf> shachaf@carbon:~$ curl http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/type-class-extensions.html | xxd | less
21:02:38 <rwbarton> aha
21:02:40 <rwbarton> mystery solved, then
21:03:08 <dmwit> tswett: I guess I would "cabal configure && cabal build", then run the failing make command with debug options.
21:03:10 <shachaf> Doesn't solve the fact that that page uses ISO-8859-1. :-(
21:03:21 <rwbarton> tswett: probably you can somehow configure debugging from the Makefile itself, then cabal build
21:04:03 * tswett nods.
21:06:52 * hackagebot network-conduit 0.6.1.1 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.6.1.1 (MichaelSnoyman)
21:06:54 * hackagebot resourcet 0.4.0.2 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.0.2 (MichaelSnoyman)
21:06:56 * hackagebot dtd 0.6.1.2 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-0.6.1.2 (MichaelSnoyman)
21:10:22 <clahey> Oh, I missed <$ being different from <*.  Duh.
21:11:50 * hackagebot persistent 1.0.1.3 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.0.1.3 (MichaelSnoyman)
21:14:05 <clahey> edwardk, Where are the top level functions to run a parser once you've built it?
21:14:51 <edwardk> http://hackage.haskell.org/packages/archive/trifecta/0.53/doc/html/src/Text-Trifecta-Parser-ByteString.html has parseByteString and parseFromFie and a couple others
21:16:51 * hackagebot to-haskell 0.3.0 - A type class and some utilities for generating Haskell code.  http://hackage.haskell.org/package/to-haskell-0.3.0 (ConalElliott)
21:20:51 <tswett> Okay, I can cabal configure and cabal build.  And... apparently it worked.
21:21:33 <clahey> edwardk, In Parser r e k, what are the parameters?
21:21:41 <clahey> Or should I just use parsec for now?
21:21:41 <tswett> I've got an executable there and everything.
21:21:49 <clahey> And not bother you?
21:21:52 * hackagebot warp 1.3.3.2 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.3.2 (MichaelSnoyman)
21:21:54 * hackagebot http-conduit 1.6.1.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.6.1.2 (MichaelSnoyman)
21:21:55 <tswett> So now that it's built, how can I install it?
21:21:58 <edwardk> parsec has better docs and everything ports to trifecta
21:22:19 <edwardk> the parameter r is for the continuation, after that i have to look it up ;)
21:24:06 <edwardk> Parser r e a, the r is the type of the result continuation, just expect that to be out of your hands. the 'e' is the type of the messages used by the diagnostic subsystem, and the 'a' is the type the parser returns
21:25:00 <edwardk> i don't mind answering questions though
21:25:28 <clahey> When I try to load my module in ghci, I get a complicated error message about type variable r escaping its scope.
21:25:50 <clahey> Couldn't match type `m0' with `Parser r String'
21:25:50 <clahey>       because type variable `r' would escape its scope
21:25:50 <clahey>     This (rigid, skolem) type variable is bound by
21:25:50 <clahey>       a type expected by the context: Parser r String [[[Char]]]
21:28:20 <Cale> clahey: did you make a paste of your code somewhere?
21:28:28 <clahey> Cale, One sec.
21:29:00 <hpaste> clahey pasted “Trifecta Test” at http://hpaste.org/76113
21:29:33 <Cale> clahey: Okay, try adding {-# LANGUAGE NoMonomorphismRestriction #-} to the top of your file
21:29:44 <Cale> and see if things are magically okay
21:29:57 <clahey> Yep.
21:30:07 <Cale> They're okay now?
21:30:11 <clahey> Yep.
21:30:17 <Cale> Okay, the MR sucks
21:30:37 <Cale> Basically, if you have a definition which is not explicitly a function binding
21:30:39 <edwardk> that was going to be my suggestion. the problem is parseFromFile has a rank2 type
21:31:05 <Cale> then it's not allowed to be type class polymorphic
21:31:42 <Cale> and this assumption that it's not polymorphic can cause weird and confusing problems elsewhere, giving terribly bad error messages
21:32:23 <Cale> Oh, this only applies to pattern bindings (i.e. no function parameters) with no type signature
21:32:36 <Cale> Adding explicit type signatures would also have worked
21:32:54 <clahey> Adding them to my different parsers.
21:34:49 <rwbarton> funny that it could not deduce that m = Parser r and then r is no longer bounded by a type class
21:35:10 <rwbarton> or Parser r String rather
21:39:46 <edwardk> in theory i could reduce the polymorphism required by that function and then the MR wouldn't bite you
21:40:11 <edwardk> i think i quantified over 'r' in 0.90 so it should go away regardless
21:40:25 <edwardk> (i mean i wrapped that up as part of the newtype)
21:46:51 * hackagebot yesod-auth 1.1.1.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.1.2 (MichaelSnoyman)
21:46:53 * hackagebot yesod-core 1.1.2.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.2.2 (MichaelSnoyman)
22:30:55 <pharaun> @pl fromPairsSyncSet xs = IS.fromList $ fmap (\(a, b) -> UniqueStatus (a, b)) xs
22:30:55 <lambdabot> fromPairsSyncSet = IS.fromList . fmap (uncurry ((UniqueStatus .) . (,)))
22:32:36 <notNicolas> can Haskell be used for Serious Work?
22:33:01 <shachaf> That's an upcoming feature scheduled for GHC 7.10.
22:33:08 <shachaf> It's not in the Report, though.
22:33:22 <notNicolas> :o lol
22:34:02 <notNicolas> on another topic, does there exist tools to support using Haskell as a scripting language for a C/C++ application?
22:34:34 <notNicolas> I know you can compile Haskell and link it to C, but that's not really scripted.
22:34:46 <solrize> you mean embed haskell in a C program?  there is an FFI but may not be what you have in mind
22:34:49 <c_wraith> Nothing's pre-built to do it, but the pieces all exist
22:35:21 <solrize> scripting languages are traditionally untyped... i wonder how things would go with a typed one
22:35:23 <notNicolas> I'm only halfway through LYAH so I'm not really on the ball about those things
22:35:31 <solrize> especially a pure one
22:36:07 <notNicolas> C++ has powerful type features that might help make an API safe to use
22:36:34 <solrize> i wasn't even thinking of typed traffic across the FFI
22:37:05 <c_wraith> I mean, there are a couple nice interpreter libraries around the GHC api
22:37:11 <solrize> i just meant do you really want people to script in Haskell?
22:37:23 <c_wraith> and you can embed the whole mess inside a C program, sure
22:37:32 <notNicolas> a proof of concept would be fun to me
22:38:51 <notNicolas> the game series Uncharted uses a LISP derivative for scripting the behaviour of things
22:39:16 <notNicolas> so Haskell might be worth a shot
22:39:19 <c_wraith> Well, there are two steps.  Embed GHC in a C program, and have the haskell code run one of the interpreter libraries
22:39:35 <c_wraith> Neither is especially hard, but both have definite learning curves.  I've only ever done the latter.
22:39:56 <c_wraith> The biggest issue is that ghc isn't really designed for that kind of use.
22:40:06 <notNicolas> hmm
22:40:18 <c_wraith> And it needs its libraries to be around to interpret code
22:40:41 <c_wraith> which would make it a *lot* of parts to include with a program
22:40:50 <notNicolas> that's true
22:41:12 <notNicolas> a scripting language should be lightweight anyways, so maybe a lot of libraries can be thrown out?
22:41:34 <solrize> err, haskell itself is huge
22:41:40 <solrize> you need an awful lot of ghc
22:41:42 <c_wraith> Less than you think.  the library structure isn't really designed for being pared down
22:41:45 <solrize> i mean ghc is huge
22:42:09 <solrize> why not get rid of the C part of the program?
22:42:36 <c_wraith> that doesn't reduce the size of the code base you need to distribute much, if you want it to use the interpreter.
22:42:58 <c_wraith> Though it is generally nicer to embed C in haskell than vice-versa
22:43:39 <notNicolas> it's possible to write a LISP interpreter in 200 lines and Haskell is that big?
22:44:13 <c_wraith> GHC is not an interpreter
22:44:16 <c_wraith> it's an optimizing compiler
22:44:28 <c_wraith> that also has an interpreter built in
22:44:44 <c_wraith> But yes, haskell is bigger than basic lisps, no question.
22:44:52 <Ralith> haskell also has a few more features than a 200 line lisp interpreter.
22:45:04 <notNicolas> hehe
22:45:08 <Ralith> (you can actually implement a usable lisp in more like 20 lines)
22:45:47 <c_wraith> the type system is probably a *huge* part of GHC's code - and it's something basic LISPs can ignore completely
22:46:24 <Ralith> then there's the whole "optimizing compiler" bit
22:46:28 <rwbarton> plus all the base containers array etc. libraries you might want to include
22:47:05 <carter> yay, i rebuilt ghc 7.6.1 with a nice mac installer etc with the fixed version of bytestring
22:47:07 <carter> :)
22:47:26 <solrize> @src some
22:47:26 <lambdabot> some v = some_v
22:47:26 <lambdabot>   where many_v = some_v <|> pure []
22:47:26 <lambdabot>         some_v = (:) <$> v <*> many_v
22:47:38 <solrize> @src many
22:47:38 <lambdabot> Source not found. The more you drive -- the dumber you get.
22:49:01 <rwbarton> what an odd thing to include in @src
22:49:33 <shachaf> It's a generic lambdabot insult.
22:49:34 <shachaf> @quote jsldbls
22:49:35 <lambdabot> No quotes match. Wrong!  You cheating scum!
22:49:40 <rwbarton> no, I meant some
22:49:48 <shachaf> Oh.
22:50:01 <shachaf> src has no rhyme or reason.
22:50:03 <rwbarton> mostly the @src definitions aren't written in the worker/wrapper style either
22:56:34 <rwbarton> shachaf: You know what would be cool?
22:56:49 <shachaf> @brain
22:56:50 <lambdabot> I think so, Brain, but there's still a bug stuck in here from last time.
22:56:57 <rwbarton> hahaha
22:57:15 <rwbarton> how appropriate
22:57:50 <rwbarton> (I was going to say, A new lambdabot.)
22:58:45 <arcatan> A new kind of lambdabot
22:59:30 <shachaf> A new lambdabot isn't cool. You know what's cool? A new (U+E9278)bot.
23:01:54 * hackagebot hothasktags 0.2.2 - Generates ctags for Haskell, incorporating import lists and qualified imports  http://hackage.haskell.org/package/hothasktags-0.2.2 (JohnLato)
23:06:20 <shachaf> rwbarton: Are you going to write it?
23:07:28 <rwbarton> Not right now.
23:11:54 * hackagebot HPDF 1.4.3 - Generation of PDF documents  http://hackage.haskell.org/package/HPDF-1.4.3 (alpheccar)
23:16:53 <notNicolas> I wish Haskell could do my physics homework
23:17:38 <mikeplus64> notNicolas: i'm sure it can help, or at least, you can learn a lot trying to make it do it
23:22:36 <shachaf> Is there a reasonable way to make something like this possible? data Foo = forall a. Foo a (a -> Int); let blah :: Foo -> Int; blah hmm@(Foo x f) = f (getX hmm) where getX (Foo x' f') = x'
23:23:04 <shachaf> If you change the last x' to x it works, of course. But they're the same type.
23:34:17 <kmbt> Hi, does anyone know where I could download this document: http://www.happstack.com/docs/crashcourse/index.html in a more printable format, i.e. PDF or all-in-one HTML?
