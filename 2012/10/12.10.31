00:00:46 <lispy> Sonarpulse: what does that mean?
00:01:15 <Sonarpulse> well i know you can over load like f 6 = ; f 6 = ;f 7 =
00:01:40 <Sonarpulse> but what about have one definition for f of 2 though 4, and anoher for five through 6
00:01:51 <lispy> ah, guards
00:02:04 <shachaf> guarr!
00:02:04 <Sonarpulse> I figured it was a common problem
00:02:04 <shachaf> @arr
00:02:04 <lambdabot> Har de har har!
00:02:05 <lispy> f x | 1 <= x <= 4 = ...
00:02:17 <shachaf> lispy: That's not valid. :-)
00:02:24 <lispy> oh right &&
00:02:30 * lispy is sleepy :)
00:02:39 <lispy> f x | 1 <= x && x <= 4 = ...
00:03:07 <Sonarpulse> in generall can you use guards then for polymorphism that static typing can't handle?
00:03:26 <shachaf> No.
00:03:53 <Sonarpulse> oh well
00:04:09 <shachaf> (That sentence doesn't even make any sense, so I'll just go with "no". :-) )
00:04:37 <shachaf> If you clarify maybe the answer would be yes.
00:04:42 <edwardk> @hpaste
00:04:42 <lambdabot> Haskell pastebin: http://hpaste.org/
00:05:17 <hpaste> edwardk pasted “mix id algorithm for sonarpulse” at http://hpaste.org/77041
00:05:42 <edwardk> hpaste: thats a crappy quick implementation i dashed together that is probably full of bugs, but at least gives you a way to proceed ;)
00:05:51 <shachaf> Wait, why are using Strings here?
00:06:25 <Sonarpulse> oh, I think edwardk just answered that question too
00:06:26 <edwardk> shachaf: because i couldn't be bothered to contort it to use bytestrings and he was getting the filename from various system calls that give him a string in the first place
00:06:45 <Sonarpulse> so that as a more general, scheme like cond way of things
00:06:47 <shachaf> At least contort it to use [Word8].
00:07:21 <Sonarpulse> which was kind of what i was getting at, when you need something more dynamic
00:08:15 <edwardk> shachaf: i used strings because using words just forced you to put that logic somewhere else
00:08:25 <Jafet> unsafeCoerce :: String -> [Word8]
00:08:25 <Sonarpulse> edwardk : I see you hardcoded the ascii limit in
00:08:39 <Sonarpulse> I beleie IsAsciii (or something like that) would work to
00:08:46 <Sonarpulse> (it's in Data.Char)
00:08:47 <shachaf> edwardk: Well, yes.
00:08:55 <edwardk> Sonarpulse: you can do whatever you like. i spent a minute dashing it out =P
00:09:00 <Sonarpulse> oh, Jafet beet me too it
00:09:15 <Sonarpulse> Well, that's certainly faster than my hours spent :D
00:09:31 <Sonarpulse> I do agree, I would like to replicate the tar interface as much as possible
00:09:58 <edwardk> Sonarpulse: jafet's answer is a joke that unfortunately works
00:10:53 <Iceland_jack> The worst kind of joke
00:11:16 <edwardk> but the reason it works isn't worth explaining and isn't a good idea to rely upon
00:11:23 <Sonarpulse> ok
00:11:30 <Sonarpulse> well there is a isAscii
00:11:45 <edwardk> sure.
00:11:50 <Sonarpulse> is that coerce as in lazy force and delay?
00:11:58 <edwardk> i just assumed the ascii bound. for all i know it could be an arbitrary codepage
00:12:03 <shachaf> No, it's coerce as in you shouldn't do it.
00:12:15 <Jafet> That's coerce as in pretend the machine words of the String represent a [Word8]
00:12:24 <Jafet> Which they do
00:12:31 <Jafet> Sometimes
00:12:43 <edwardk> unsafeCoerce tells the compiler you know better than it does and tells it to completely trust you that you got the types right
00:13:02 <Sonarpulse> ooo
00:13:03 <edwardk> as long as the runtime representation of two thinsg are the same, and the tag bits all work out, etc. then it does the right thing
00:13:06 <shachaf> λ> unsafeCoerce ('ש' :: Char) :: Word8
00:13:06 <shachaf> 1513
00:13:21 <edwardk> note that that Word8 is bigger than a Word8 ;)
00:13:31 <Sonarpulse> also, I found a isLatin1 which should be even better
00:13:50 <Twey> edwardk: o.@
00:13:50 <shachaf> Sonarpulse: No it shouldn't.
00:14:05 <Twey> shachaf: @.o
00:14:11 <Twey> How did that come to be?
00:14:31 <shachaf> Twey: magic :'(
00:14:34 <edwardk> i'd stick to ascii for now, lest you run into problems with utf-8 enoding/decoding
00:14:47 <Jafet> data Word8 = W8 Word#; data Char = C# Char#
00:14:49 <shachaf> fre enoding
00:14:49 <lispy> Cale: rebooting
00:14:54 <Twey> Ack
00:15:16 <prophile> :(
00:15:32 <Sonarpulse> ok
00:16:03 <Sonarpulse> though i know for some translations they use all sorts of code pages and upper ansi in the early Command and Conquer games
00:16:32 <edwardk> Sonarpulse: in the filenames in the mix files?
00:16:42 <Sonarpulse> probably not in the filenames though :D
00:16:44 <edwardk> or just inside of the files
00:16:48 <edwardk> exactly =)
00:17:01 <shachaf> Sonarpulse: You really oughtn't be using strings and UTF-8 decoding in the first place.
00:17:16 <Sonarpulse> Well, when you gotta be backwards compatabel
00:17:18 <Sonarpulse> ...
00:17:43 <edwardk> shachaf: he was looking to use this for filenames he'd be reading off disk, presumably to build this silly little archive from.
00:17:55 <shachaf> edwardk: Ah, I see.
00:18:04 <shachaf> Well, depending on the OS, filenames on disk are actually bytes.
00:18:11 <edwardk> shachaf: that i think is where the impedence mismatch came from
00:18:23 <Sonarpulse> this is all for https://github.com/Sonarpulse/CnC-Red-Alert
00:18:48 <edwardk> sure. but ultimately, C&C never used non-ascii filenames, so i don't think this issue is worth anywhere near the amount of time folks have spent bandying it about
00:18:49 <shachaf> edwardk: Anyway, you have to decide on some encoding.
00:19:02 <edwardk> shachaf: i'm well aware ;)
00:19:11 <Sonarpulse> BTW. somebody else is allready reverse engineering bits of the game, and right now theres a gazillion fan things you have to put in the archives yourself, so I was trynig to make a build system for it
00:19:49 <Sonarpulse> also, what is the difference between frumEnum and ord? (or are they opposites)
00:20:03 <edwardk> > fromEnum 'c'
00:20:10 <edwardk> > Data.Char.ord 'c'
00:20:18 <edwardk> lambdabot die?
00:20:21 <shachaf> edwardk: OK, OK. :-)
00:20:25 <shachaf> edwardk: Machine is rebooting.
00:20:31 <edwardk> ah
00:20:35 <shachaf> I guess Cale isn't online to rerun lambdabot.
00:20:40 <shachaf> Apparently we're getting an upgrade to 7.4!
00:21:11 <Sonarpulse> well in this case, which do you think is more elegant?
00:21:18 <edwardk> Sonarpulse: the ord, chr functions are just one-off functions in Data.Char
00:21:28 <edwardk> fromEnum and toEnum work for any instance of Enum
00:21:39 <Sonarpulse> aha, well since we are just dealing with charcters
00:21:41 <edwardk> and the instance of Enum for Char defines them in terms of ord and chr
00:21:51 <edwardk> but doesn't require a random import
00:21:53 <Sonarpulse> i figured what was on Data.Char might be more proper
00:22:05 <edwardk> and the fromEnum and toEnum are better known to folks in haskell
00:22:05 <Sonarpulse> and I already have that import
00:22:09 <Sonarpulse> ok
00:22:12 <Sonarpulse> that's a good reason
00:22:26 <marzy> is there opposite of fromEnum?  int -> Enum
00:22:40 <edwardk> ord and chr basically exist as a consequence of the great monomorphism revolution of 98.
00:22:51 <shachaf> marzy: Yes. You have three guesses about its type. :-)
00:22:52 <edwardk> marzy: toEnum
00:22:57 <shachaf> s/type/name/
00:23:04 <lispy> Cale: I think it's up again
00:23:05 <shachaf> hi lispy
00:23:11 <shachaf> Do we have 7.4 now?
00:23:17 <lispy> Cale: I might reboot again soon to do a more recent kernel
00:23:34 * lispy just learned with linode you control the kernel via a control panel not by installing packages
00:23:40 <lispy> shachaf: nope
00:24:00 <marzy> heh sorry, I tried it in ghci and I interpreted ambiguous error as proof it didn't exist
00:24:09 <RussianKid> if i have a variable x of type Maybe Text, how can I check if it exists or not?
00:24:48 <shachaf> RussianKid: case x of Nothing -> ...; Just y -> ...
00:25:27 <ivanm> isJust, use maybe/fromMaybe, etc.
00:26:18 <RussianKid> ty
00:27:27 <Sonarpulse> edwardk, I have a few more questions about the syntax of your code
00:27:49 <Sonarpulse> the (c:_) bit?
00:28:09 <lispy> Cale: $ ghc --version
00:28:10 <lispy> The Glorious Glasgow Haskell Compilation System, version 7.4.2
00:28:15 <lispy> shachaf: there :)
00:28:18 * lispy goes to bed
00:28:23 <edwardk> Sonarpulse: thats a pattern match looking for somthing cons'd onto a list
00:28:25 <Sonarpulse> since he have been talking about emums I get it has something to do with that
00:28:39 <Sonarpulse> oh, ok
00:28:46 <shachaf> Cale: Now install lambdabot with 7.4!
00:28:50 <shachaf> And install lens.
00:29:31 <Sonarpulse> and how is drop different from head?
00:29:43 <shachaf> Sonarpulse: Do you have ghci?
00:29:46 <Sonarpulse> yeah
00:29:58 <shachaf> Type ":t drop" and ":t head" into ghci.
00:30:02 <marzy> I think would [c] work too in place of (c:_)
00:30:12 <Sonarpulse> oh, I assumed it would be a more semantic issue
00:30:12 <marzy> [c] woudl
00:30:20 <shachaf> And then type "drop 2 [1,2,3,4]" and "head [1,2,3,4]"
00:30:26 <shachaf> In other words, experiment. :-)
00:30:51 <Sonarpulse> always a good idea
00:31:09 <Sonarpulse> but then i have GHC errors to debug ;)
00:31:17 <shachaf> That's a good skill.
00:31:58 <edwardk> drop 4 "hello world"    ==> "o world"
00:32:10 <Sonarpulse> I see, silly me that's in scheme too
00:48:09 <hpaste> pooya pasted “cabal-dev” at http://hpaste.org/77042
00:48:46 <pooya72> hi everyone, just getting a random error on a clean cabal-dev install when I try to run cabal-dev ghci: http://hpaste.org/77042
00:50:54 <marzy> is this how one would implement drop'? any improvements?   http://hpaste.org/77044
00:51:54 <Sonarpulse> edwardk, do you know if your byte function can be made to return a Word32 instead of an int?
00:52:17 <shachaf> marzy: Well, it's wrong if it gets a negative number.
00:52:31 <edwardk> you can do so. you'll need to sprinkle a few fromIntegrals in it in the right places
00:52:36 <Sonarpulse> i tried fromIntegral, but that didn't work
00:52:53 <edwardk> then you picked the wrong places ;)
00:52:57 <Sonarpulse> probably
00:52:59 <frelux> cloud haskell on iOS update: i've now successfully recreated http://alenribic.com/writings/post/raspberry-pi-in-a-haskell-cloud with iPads and iPhones (via ghc-ios)! blogpost coming as soon as I get it all cleaned up.
00:53:19 <shachaf> Sonarpulse: http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#verbatim-267
00:55:29 <Sonarpulse> tuplet? wouldn't have guessed that
00:56:28 <pooya72> I'm getting a random error on a clean cabal-dev install when I try to run cabal-dev ghci: http://hpaste.org/77042
00:57:50 <hamid> @src reverse
00:58:03 <hamid> hmm no lambdabot :P
00:58:35 <hamid> i wrote my reverse like this => reverse' (x:ys) = (reverse' ys ) ++ [x]
00:58:46 <shachaf> hamid: That works, but isn't as efficient as it could be.
00:59:01 <ChristianS> hamid: avoid ++ if you can
00:59:23 <Jafet> reverse = foldl' (flip (:)) []
00:59:29 <Jafet> There is nothing wrong with (++)
01:00:06 * hackagebot Elm 0.5.0.1 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.5.0.1 (EvanCzaplicki)
01:00:56 <fenton> trying to install yesod, but get the following error: http://pastie.org/5141676, any ideas?
01:01:15 <hamid> Jafet, is ++ exactly same O(1) operation as in C ( like linking linked lists) ?
01:01:22 <marzy> shachaf good catch. fixed. http://hpaste.org/77044
01:01:43 <Jafet> Linking linked lists is not O(1)
01:02:31 <Jafet> a ++ b does (length a) work when evaluated.
01:03:03 <pooya72> fenton: have you tried installing it with cabal-dev?
01:03:12 <ChristianS> hence the tip to avoid it
01:03:17 <Jafet> That means reverse' (x:xs) does (reverse' xs + length xs) work.
01:03:50 <ChristianS> which is quadratic
01:04:13 <RussianKid> alright I'm completely stuck: the .ppcommand printing c2 in the CmdIf bit needs to be conditional on whether c2 is just or not, and I'm not sure of the correct syntax to use.
01:04:14 <RussianKid> http://hpaste.org/77045
01:04:47 <fenton> pooya72: no, i'll look up what that means...thanks for the pointer...
01:04:56 <RussianKid> i tried to get it to print nothing if the command doesnt exist, but even that didn't work
01:05:02 <akamaus> hello. I need to write a parser for simple network protocol. I can do it quite easily by hand with Data.Binary, but I'd like to make use of C header files describing data structures. Is there a tool for that?
01:06:12 <akamaus> fenton, do you have happy installed? Is it in your PATH?
01:07:45 <fenton> akamaus: yes, that's shown in the pastie...
01:09:20 <marzy> can someone implement reverse' more efficiently without foldl etc? I'd be curious to see what it would look like
01:09:59 <akamaus> fenton, oh, sorry. Why not to unpack language-javascript and look at the actual test it makes for happy then?
01:10:02 <shachaf> marzy: It would look like inlining foldl into it.
01:10:44 <marzy> that would help if I knew how foldl is implemented. :)
01:11:26 <fenton> akamaus: hmmm, don't know how, but i'll look into doing that, thanks!
01:12:10 <akamaus> fenton, cabal unpack language-javascript, then dig into Setup.hs
01:13:07 <fenton> akamaus: thanks a lot!
01:13:35 <akamaus> fenton, have you already find the test?
01:13:55 <fenton> akamaus: no, i started trying to install cabal-dev, but that failed too...
01:14:21 <fenton> i think if cabal-dev makes dependency hell less...i should aim for that...
01:14:52 <akamaus> fenton, that's strange. Which version of ghc do you use btw?
01:15:42 <fenton> The Glorious Glasgow Haskell Compilation System, version 7.6.1
01:16:26 <fenton> akamaus: there was only two lines in Setup.hs...: import Distribution.Simple and main = defaultMain
01:17:32 <fenton> akamaus: however in language-javascript.cabal there is the reference to happy >= 1.18.5
01:18:04 <fenton> do i install cabal-dev with: cabal install cabal-dev?
01:18:11 <fenton> do i install cabal-dev with: cabal install cabal-dev --force-reinstalls
01:19:38 <akamaus> fenton, hmm, I thought they implemented some custom magic. I'll try to compile it myself now.
01:19:58 <fenton> akamaus: thanks a lot!!!
01:20:09 <akamaus> fenton, hmm, I'm done. which version of cabal do you have?
01:20:25 <akamaus> fenton, I mean, the library, not cabal-install
01:21:32 <fenton> $ cabal --version
01:21:34 <fenton> cabal-install version 1.16.0.1
01:21:36 <fenton> using version 1.16.0 of the Cabal library
01:22:35 <fenton> on arch linux, I've tried to use only cabal to install packages to ~/.cabal, instead of pacman
01:25:08 * hackagebot timeplot 1.0.17 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.17 (EugeneKirpichov)
01:25:39 <akamaus> fenton, I'm afraid, I've run out of ideas. You have basically the same setup as me. I'm on ubuntu and using ghc-7.6.1. Never had any problems with happy. Some silly reason, I guess.
01:26:25 <fenton> akamaus: thanks for taking a stab at it!!!
01:27:36 <akamaus> fenton, I don't know would it help or not, but you could strace the cabal and see it's actual behavior when it tests for happy. Maybe it would give some additional clues.
01:29:14 <fenton> akamaus: let me lookup how to do that, thanks!
01:45:09 * hackagebot timeplot 1.0.18 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.18 (EugeneKirpichov)
02:16:45 <merijn> It's not possible to use partially applied type functions in instance declarations?
02:17:01 <shachaf> merijn: Type functions as in type families?
02:17:20 <merijn> i.e. "type family Foo x y; instance Bar (Foo Int) where"
02:17:22 <merijn> shachaf: Yes
02:17:39 <shachaf> How would that make sense?
02:17:53 <Cale> merijn: You can do it if you eta contract the definition of the type family and its instances
02:18:06 <merijn> Cale: What's that mean?
02:18:08 <shachaf> You'd want a data family, wouldn't you?
02:18:11 <merijn> shachaf: Why wouldn't it make sense?
02:18:18 <shachaf> Since you need it to be injective.
02:18:18 <Cale> I mean delete the last parameter :)
02:18:44 <shachaf> merijn: Even "type family Foo a; instance Bar Foo where" isn't valid, is it?
02:18:59 <merijn> Cale: That won't work as then my type family's definition is incorrect :\
02:19:02 <merijn> shachaf: I dunno, is it?
02:19:05 <Cale> but instead of having  type family Foo x y :: *, you'll have type family Foo x :: * -> *
02:19:26 <shachaf> type family Foo a; type instance Foo a = Int
02:19:29 <Cale> but this limits your instances
02:19:32 <shachaf> How would you resolve instances on that?
02:19:58 <shachaf> On the other hand, if you have a data family, what you wrote is fine.
02:20:01 <shachaf> (Should be fine?)
02:20:57 <merijn> I guess I was hoping to smuggle composition in using type families, but I won't get around GHC that easy :\
02:20:57 <shachaf> Cale: I don't think that makes much of a difference.
02:21:02 <Cale> No, it does
02:21:22 <shachaf> λ> type family Foo a :: * -> *
02:21:23 <shachaf> λ> instance Functor (Foo Int)
02:21:25 <Cale> You can't write unsaturated applications of type family constructors, but you can define type families with higher-kinded results
02:21:26 <shachaf>     Illegal type synonym family application in instance: Foo Int
02:21:37 <Cale> oh, well then :)
02:21:38 <merijn> shachaf: Lemme give you a concrete example that clearly makes semantic sense (although GHC won't let me write it)
02:21:43 <Cale> yeah, I hadn't even thought as far as that
02:22:14 <shachaf> I mean, *maybe* it could do it in some really boring cases, but I think in general you need injectivity even here.
02:22:14 <Cale> But the way that he'd defined his type family, Foo Int wasn't valid anywhere
02:22:21 <shachaf> Right.
02:22:33 <Cale> while if you define it the way I suggested, at least Foo Int is a thing
02:22:35 <shachaf> Cale: But with a data family, data family Foo a b; instance Functor (Foo Int) works.
02:22:41 <merijn> "type family Compose f g x; type instance Compose f g x = f (g x); instance (Functor f, Functor g) => Functor (Compose f g) where" (and yes, I was just reinventing Data.Functor.Compose)
02:22:54 <shachaf> merijn: Nope, that won't work. :-)
02:23:06 <merijn> shachaf: Lazy bastards at GHC headquarters...
02:23:26 <Cale> merijn: If you tried to implement it, you'd see what was wrong almost immediately
02:23:29 <shachaf> I don't think this has to do with GHC in particular.
02:23:38 <Cale> it has nothing to do with GHC
02:23:40 <merijn> shachaf: This specific definition not, maybe
02:23:48 <Cale> the code doesn't actually make any sense
02:23:58 <merijn> But lack of type level composition is really ruining my ability to define useful instances when using DataKinds...
02:24:13 <shachaf> merijn: This has nothing to do with families.
02:24:17 <shachaf> Your "family" is just a synonym.
02:24:18 <merijn> shachaf: I know
02:24:28 <merijn> shachaf: I was just trying yet another approach to getting my way
02:24:36 <merijn> Which clearly also doesn't work...
02:24:43 <shachaf> When GHC tries to resolve a Functor instance for (Compose f g), it'll end up resolving the one for g, instead.
02:25:02 <shachaf> Cale: You like/dislike Foldable?
02:25:04 <merijn> shachaf: Why?
02:25:34 <shachaf> merijn: Because it has an instance Functor for anything of the form (Maybe a) already.
02:25:42 <shachaf> Maybe (Tree a) is of the form (Maybe a)
02:25:48 <shachaf> Therefore it'll use its existing instance.
02:26:04 <merijn> shachaf: How is this relevant to the compose example?
02:26:25 <shachaf> merijn: Your compose thing is exactly equivalent to a type synonym.
02:26:27 <Cale> shachaf: Foldable is a bit weird. I guess it's somewhat useful to have around.
02:26:35 <Cale> shachaf: I would have called it Listable
02:26:40 <merijn> shachaf: Yes, except that my f and g are not actually nested
02:26:52 <shachaf> Cale: It's slightly smarter than Listable -- more like Monoidable.
02:26:56 <merijn> shachaf: I guess my instance example was wrong
02:27:04 <Cale> But lists are the free monoid!
02:27:23 <shachaf> Cale: Yes, but if you foldMap with Last of a binary tree, it'll only look at log n nodes. :-)
02:27:50 <Cale> Yeah, I'm not saying do away with the generalised foldMap
02:28:11 <Cale> But the name Listable is okay, especially if we're going to call our monoid operations mempty and mappend
02:28:23 <shachaf> "Listable" implies a particular order of folding it, since lists are loops. :-)
02:28:28 <merijn> Basically, I have something like: "data Foo :: Maybe * -> * where" and Foo is only a Functor when Maybe * is Just
02:28:42 <Cale> shachaf: That order is still present
02:28:50 <shachaf> Well, yes.
02:28:53 <Cale> shachaf: It's not commuted, it's only reassociated
02:29:05 <shachaf> But lists also imply as associativity.
02:29:08 <merijn> i.e. "Functor (Compose Foo Maybe)" but using Data.Functor.Compose requires manual wrapping/unwrapping using getCompose...
02:29:17 <shachaf> Cale: Anyway, my issue is that you have to define a newtype and Monoid instance for anything you want to pass to foldMap.
02:29:19 <Cale> Sequenceable?
02:29:33 <Cale> (though that has the problem that sequenceA is part of Traversable)
02:29:43 <Cale> which would be confusing
02:29:49 <shachaf> Is there a way to pass it first-class mappend and mempty?
02:30:01 <shachaf> You can use foldr or foldl but that has a right or left bias, which I don't want.
02:30:11 <Cale> right, that's a bit silly
02:30:20 <shachaf> I just want to be able to supply a function that e.g. refers to a lexical variable.
02:30:35 <Cale> though I guess it means you're somewhat more committed to really having a good monoid instance
02:30:40 <merijn> I don't suppose there's any other tricks I can try to beat GHC into what I want?
02:30:41 <shachaf> (What I actually want this for is for Folds from lens, not Foldables. But they're pretty equivalent.)
02:31:11 <merijn> (Although the conversation seems to have somewhat derailed from my initial problem >.>)
02:31:48 <Cale> merijn: Suppose I write  fmap reverse [[[1,2,3],[4,5]],[[6,7,8],[9,10]]]
02:32:03 <Cale> merijn: What would that mean in the presence of your instance?
02:32:21 <merijn> Cale: My initial instance was wrong
02:32:47 <shachaf> Cale: By the way, if you like lenses, you should join the lens channel!
02:32:47 <Cale> okay, so what is it that you're trying to do now?
02:32:51 <merijn> That was a quick example, the later one is the actual problem I have
02:33:00 <Cale> shachaf: Why isn't that #haskell?!
02:33:13 <shachaf> Cale: It's #haskell-blah
02:33:28 <merijn> Cale: I have "data Foo :: Maybe * -> * where" which can only be made a instance of Functor when the Maybe is a Just
02:33:32 <Cale> ...
02:33:53 <Cale> merijn: This is with DataKinds?
02:33:57 <merijn> Cale: So the only sensible definition of functor would be "Functor (Compose Foo Maybe)"
02:34:00 <merijn> Cale: Yes
02:34:16 <Cale> what are the constructors?
02:35:04 <Cale> How does that work?
02:35:21 <Cale> Surely that's at least a data family?
02:35:33 <merijn> Cale: Why?
02:36:08 <GnomeStoleMyBike> Hi All
02:36:12 <GnomeStoleMyBike> @nixon
02:36:27 <Cale> Oh, well, I guess maybe you have other type functions like  * -> Maybe * -> *  hanging around or something
02:36:40 <Cale> merijn: is that the case?
02:36:45 <GnomeStoleMyBike> lambda bot is not quoting nixon anymore ?
02:36:54 <Cale> lambdabot isn't here right now
02:36:58 <GnomeStoleMyBike> > x y = y z
02:37:03 <merijn> Cale: It's GADT syntax so the constructors take care of that
02:37:05 <shachaf> Cale: Hey, speaking of lambdabot not being here right now...
02:37:17 <GnomeStoleMyBike> :(
02:37:28 <GnomeStoleMyBike> i feel sad, and its holloween
02:37:40 <Cale> there
02:37:44 <shachaf> Cale: Can you get lambdabot running on 7.4?
02:37:51 <Cale> later
02:37:51 <shachaf> 00:27 <lispy> The Glorious Glasgow Haskell Compilation System, version 7.4.2
02:37:54 <shachaf> Aw.
02:37:55 <Cale> yes, I know
02:38:00 <Cale> It's 5:30 am
02:38:05 <Cale> and I'm tired
02:38:07 <shachaf> Hah, OK. :-)
02:38:15 <shachaf> Make sure to install lens!
02:38:17 <merijn> Cale: Maybe I'm approaching this wrong anyway. What I had was a heterogeneous container which is potentially empty and I had that as type "Foo ()" and other values as "Foo v" and then of course "Foo" would be a Functor instance. But then I realised I couldn't tell empty containers apart from containers of ()
02:38:45 <merijn> Cale: So I switched to the "Maybe *" approach, but that still leaves me unable to specify a functor instance xD
02:39:11 <Cale> How do you expect to have a Functor instance for a heterogeneous container?
02:39:25 <merijn> Cale: The functor isn't affecting the heterogeneous part
02:39:40 <Cale> okay
02:40:04 <merijn> My indexes are heterogeneous, but values (if any) are just *
02:40:11 <Cale> Can I just see your code?
02:41:37 <merijn> Cale: Essentially I'm revisiting my earlier attempts at these data types: https://github.com/merijn/SNet2.0/blob/master/SNet/Variants.hs
02:42:15 <merijn> Cale: I ended up splitting it into separate types and providing and instance for one, but I just wanted to try again and see if I could type hack my way around it as intellectual challenge
02:42:29 <shachaf> Cale: So no solution for first-class Monoid for foldMap? :-(
02:42:32 <merijn> But by now I'm guessing the answer is no
02:42:49 <shachaf> I guess this is the same as the issue with multiple Ord instances for a set.
02:42:49 <Cale> shachaf: If you were designing the class, you could provide one
02:43:00 <Cale> shachaf: But if you're asking whether Foldable has one, it doesn't.
02:43:05 <shachaf> Cale: The actual relevant class is Applicative in this case.
02:43:09 <Jafet> Local Monoids?
02:43:50 <Cale> I guess you could make a ridiculously bad monoid
02:43:58 <Cale> which isn't one
02:44:10 <Cale> where you bundle the multiplication and unit along with the values
02:44:20 <shachaf> Hmm...
02:44:21 <Cale> except that the unit can't go
02:44:31 <Jafet> https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
02:44:32 <shachaf> Why not?
02:44:35 <Cale> So, you'll need another value to represent that sometimes when you don't know what it is
02:45:31 <shachaf> Jafet: Oh, looks good.
02:45:32 <Cale> ah, there you go, that would be the smart way to do it
02:45:49 <shachaf> Never mind the evil implementation. :-)
02:46:06 <Jafet> /evil/fast
02:47:33 <merijn> Completely unrelated note to my earlier questions
02:47:48 <merijn> Implicit parameters are essentially just ad hoc typeclass definitions right?
02:49:16 <shachaf> merijn: Not really.
02:49:20 <merijn> i.e. to take the manual example "f :: (?x :: [a]) => Int -> Int; f n = n + length ?x" here it essentially obviates the need for a one-shot type class "Foo" with a single function that produces a list
02:49:27 <Cale> merijn: without the uniqueness
02:49:31 <shachaf> merijn: They're more like arguments.
02:49:33 <merijn> shachaf: I don't mean in implementation, I meant as use case
02:49:38 <shachaf> Like parameters, except implicit. :-)
02:49:47 <Cale> merijn: but you can supply more than one instance of that class with the same type
02:49:55 <merijn> Cale: Yeah
02:49:56 <Cale> merijn: in different parts of the program
02:50:04 <shachaf> Being able to do let ?x = ... makes a big difference.
02:50:14 <Cale> So the only thing they have in common with typeclasses is that they're implicit parameters ;)
02:50:16 <merijn> Cale: That's what I implied by the "one-shot" part in my elaboration
02:50:46 <nyc> I've never figured out the implicit parameter bits.
02:50:50 <Cale> Type classes are like implicit parameters with some automatic instantiation and construction of instances
02:50:52 <shachaf> @quote kmc forget
02:50:52 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
02:50:59 <merijn> I guess a better way of phrasing it would be that I can place ad hoc constraints without needing to define an instance for the relevant constraint
02:51:10 <shachaf> s/monad/implicitparam/g s/container/typeclass/g
02:51:39 <Cale> By "automatic construction of instances" I mean like what happens when you apply show for [[[(Integer,Bool)]]]
02:52:19 <Axman6> hasn't the implicit params horse already died?
02:53:52 <merijn> I was thinking along the lines of "sort   :: (?cmp :: a -> a -> Bool) => [a] -> [a]" I can think of implicitly constructing and hiding the construction of a Ord-like typeclass for any "a -> a -> Bool" I pick
02:54:11 <merijn> Axman6: Maybe, I'm just going over the type system extensions and reading up on everything I didn't know/understand yet
02:54:31 <Axman6> righto
02:56:00 <merijn> I actually think the entire thing is rather neat, don't think I'd need it often, but seems like a useful trick to have up one's sleeve
02:57:37 <Axman6> isn't the sort idea served just as well by sort :: (a -> a -> Bool (or Ord)) -> [a] -> [a]?
02:59:45 <merijn> Axman6: Sure, that one is. But I'm sure there are cases where something that simple isn't possible
02:59:49 <Jafet> But not foldMap :: m -> (m -> m -> m) -> (a -> m) -> t m -> m
03:02:38 <Kinnison> Hi all, I have a question about cabal -- specifically about uninstalling packages
03:02:52 <Kinnison> Does anyone have a moment to explain to me how I cleanly remove packages from my ~/.cabal ?
03:03:03 <Kinnison> (I found ghc-pkg unregister to remove them from ghc)
03:04:15 <Jafet> Once you remove them from .ghc, you are done
03:04:25 <merijn> Kinnison: The only way to do that is to "rm -rf" the relevant package's folder
03:04:42 <Jafet> .cabal makes no difference
03:04:47 <merijn> Kinnison: Cabal doesn't (and I think can't?) track installed files, and as such doesn't know what to remove
03:04:48 <Cale> Well, you might want to recover the space for the actual compiled binaries and source code of things
03:04:50 <Kinnison> Jafet: Except that it consumes disk space)
03:05:00 <Cale> But yeah, you just remove the directories
03:05:08 <Kinnison> what about this 'world' file?
03:05:12 <Kinnison> do I need to remove the lines from that?
03:05:22 <Cale> I've never touched that file
03:05:29 <Kinnison> okay, cool
03:05:33 <Jafet> I think that's just a log of what you've ever installed
03:05:36 * Kinnison should probably learn about cabal-dev though
03:05:45 <Kinnison> Someone told me that was what I should be using
03:05:58 <Cale> I seem to recall that you can do something like  cabal install --reinstall world
03:06:04 <Cale> and it will reinstall everything
03:06:08 <Cale> probably by reading that file :)
03:06:24 <Jafet> So you shouldn't name a package world?
03:06:26 <Cale> so if you were going to do that for whatever reason, it might be good to have a look
03:06:48 <Cale> Jafet: apparently
03:07:10 <Jafet> cabal-install needs a manual...
03:07:50 <Cale> there is http://www.haskell.org/cabal/users-guide/ but it's not so much about cabal-install itself
03:08:18 <simon> I end up doing something like this a lot: fromMaybe def $ do { from <- foo; to <- bar; compose(from, to) } or something more complicated than that... I wonder if prefixing longer monadic Maybe-expressions with fromMaybe is idiomatic.
03:08:23 <Kinnison> Thank you all.  Should I bother with learning what 'cabal-dev' is, or is that something I can ignore for now?
03:08:52 <Cale> simon: seems quite reasonable
03:09:06 <simon> Cale, ok.
03:09:18 <Jafet> @@ @pl @undo do { from <- foo; to <- bar; compose from to }
03:09:18 <lambdabot>  (bar >>=) . compose =<< foo
03:09:33 <Jafet> @@ @pl @undo do { from <- foo; to <- bar; return (compose from to) }
03:09:33 <lambdabot>  (`fmap` bar) . compose =<< foo
03:09:35 <Cale> Kinnison: It sounds kinda cool if you needed a very picky set of packages for something
03:09:57 <Kinnison> Cale: I have had to blow away my ~/.cabal and ~/.ghc twice now just trying to get yesod to work
03:09:58 <Jafet> Strange, that should produce liftM2
03:10:21 <Cale> Kinnison: Yeah, that was the one thing I was going to say, maybe if you were using yesod or something :)
03:10:31 <Kinnison> Perhaps I should give up on Yesod
03:10:41 <Kinnison> It looks quite funky but honestly it's causing me a heck of a lot of pain to play with
03:10:41 <dcoutts> Kinnison: the trick is always to ask for everything you want to install, all at once, don't do it piecemeal
03:10:44 <simon> Jafet, yeah, right :) I do use liftM* whenever the monadic actions I'm lifting into aren't too long to fit into one line.
03:10:51 <dcoutts> Kinnison: and cabal-dev can also help
03:10:57 <Cale> Kinnison: Personally I like the look of happstack a lot more
03:11:08 <Kinnison> Cale: perhaps I might look at that
03:11:22 * Kinnison is also stuck trying to find a YAML parser which doesn't need IO actions
03:11:25 <Cale> Yesod has too much magic
03:11:48 <Kinnison> Although the Yaml need is at least a different project
03:12:50 <Kinnison> I found YamlReference which is old but pure at least
03:13:06 <Kinnison> Everything else seems incomplete or IO bound
03:13:15 <Kinnison> (and YamlReference is only a tokeniser :-( )
03:13:48 <Kinnison> Still needs something to turn the stream into a data structure, and I don't feel confident enough yet to start writing Happy parsers :-)
03:15:50 <Cale> lol, apparently HsSyck uses Data.HashTable
03:16:11 <Cale> Which is a library which probably nobody should ever use
03:16:45 <shachaf> Cale: To be fair, it's from 2007.
03:16:46 <Kinnison> All I want, ultimately, is fromYaml :: String -> YamlStructure where YamlStructure is reasonably plausible to manipulate
03:16:56 <Kinnison> and ideally a toYaml :: YamlStructure -> String
03:17:01 <Cale> shachaf: Even in 2007, it wasn't a good idea
03:17:16 <Cale> Map has always been better than Data.HashTable
03:18:08 <Cale> (and before that, there was FiniteMap, and the HashTable structure was still bad)
03:18:42 <shachaf> (And before that, it was lists. Still better than HashTable.)
03:19:34 <Cale> Well, at least performance-wise, I think Data.HashTable will beat association lists for a fair range of things
03:19:59 <Cale> but it's not a good hashtable implementation from what I recall
03:20:23 <Cale> (maybe it's improved since I last really looked closely at it)
03:21:33 <shachaf> I think Data.HashMap is more popular these days.
03:21:49 <srhb> oooh, segmentation fault.
03:21:54 <srhb> How'd that happen.
03:22:00 <shachaf> Well, HashMap isn't the same sort of thing.
03:22:04 <Palmik> Those are always fun in Haskell.
03:22:20 * Kinnison had best get on with his work.  Thank you all once again -- #haskell is always really friendly and helpful.  One day I'll get to loiter in here and help others :-)
03:22:26 <shachaf> srhb: Did you accidentally unsafeCoerce?
03:22:39 <Cale> shachaf: You have to be a little careful with Data.HashMap, but it is competitive with Data.Map at least
03:22:44 <srhb> shachaf: Nope..
03:22:45 <shachaf> Sometimes #haskell is friendly but not helpful, or helpful but not friendly.
03:23:08 <Cale> (sometimes a bit faster, sometimes a bit slower, from what I've seen)
03:23:49 <Jafet> Try unsafeCoercing intentionally
03:23:56 <srhb> > round $ logBase 10 0.000123
03:24:00 <lambdabot>   -4
03:24:02 <srhb> Weird.
03:24:22 <srhb> That produces a segfault in my ghci
03:24:27 <shachaf> Uh oh.
03:24:34 <shachaf> Sounds like something is pretty messed up.
03:24:37 <srhb> Yes :P
03:24:45 <shachaf> What OS/GHC/etc.?
03:24:47 <srhb> 7.4.1 though, so it might have been fixed.
03:25:13 <shachaf> Works in my 7.4.1
03:25:27 <srhb> How do I check if my GHC is 64 bit?
03:25:29 <srhb> Oh, bounds..
03:26:05 <srhb> 32 bit ghc on Mac OS
03:27:31 <srhb> Any number < 1 appears to crash that. Rewriterule that's fubared?
03:29:11 <Jafet> Rules don't get fired in ghci?
03:29:22 <srhb> Oh.
03:30:05 <merijn> srhb: You're right, segfaults in 32bit ghci on OSX here
03:30:10 <srhb> merijn: Funtimes.
03:30:18 <merijn> 7.6 too
03:30:27 <srhb> Welp.. There goes the Haskell platform release. :(
03:30:31 <srhb> Let's not tell anyone.
03:30:46 <srhb> <_<
03:30:52 <shachaf> @remember srhb <srhb> How do I check if my GHC is 64 bit? <srhb> Oh, bounds..
03:30:52 <lambdabot> Done.
03:30:59 <srhb> shachaf: Damn you :P
03:31:26 <srhb> It's still early here and I haven't had my coffee.
03:31:35 <ivanm> what's HsSyck?
03:31:46 <shachaf> ?
03:31:50 <shachaf> ivanm: Bindings to Syck.
03:32:15 <srhb> So am I reporting this bug, or will someone else?
03:32:34 <shachaf> srhb: It's up to you, man.
03:32:40 <shachaf> You could ask in #ghc, I guess.
03:32:45 <srhb> Ah, good idea
03:33:17 <Erstarrung> Hello.
03:33:35 <Erstarrung> I have a problem building the plugins library in cabal.
03:33:37 <shachaf> srhb: Wait, you're using 7.4.1? Have you tried 7.4.2?
03:33:59 <shachaf> srhb: I think the new Platform will have 7.4.2.
03:34:10 <Erstarrung> I type in "cabal install plugins" in order to install http://hackage.haskell.org/package/plugins-1.5.2.3
03:34:31 <Erstarrung> But there is a mistake in a file that prevents it to be compiled :/
03:34:34 <shachaf> srhb: http://hackage.haskell.org/trac/ghc/ticket/7043
03:34:37 <Erstarrung> How can I fix it ?
03:40:11 <merijn> shachaf: Considering it's still broken in 7.6 I'm assuming 7.4.2 is also broken
03:52:31 <srhb> Erstarrung: Well, that depends on the error.
03:54:43 <Erstarrung> I'll give you that.
03:54:50 <srhb> Erstarrung: Thanks. ;)
03:54:55 <donri> Erstarrung: talk to stepcut, should be on in a few hours
03:55:05 <Erstarrung> Is it possible to give a multi-line message on IRC ?
03:55:12 <Erstarrung> I'm quite new here.
03:55:16 <srhb> Erstarrung: Use a pastebin instead, for instance hpaste.org
03:55:17 <donri> @where hpaste
03:55:18 <lambdabot> http://hpaste.org/
03:55:45 <Erstarrung> Okay :)
03:56:35 <hpaste> Erstarrung pasted “Problem compiling plugins from hackage” at http://hpaste.org/77051
03:57:35 <Jafet> @hackage plugins
03:57:35 <lambdabot> http://hackage.haskell.org/package/plugins
03:59:10 <Jafet> To fix a package manually: cabal unpack package; ed package/blah; cabal configure --user --blah && cabal install
03:59:19 <Erstarrung> Okay.
03:59:24 <Jafet> rm -r package/
03:59:30 <Erstarrung> Is it possible to make the modification public ?
03:59:50 <Jafet> You can leave a message for stepcut.
03:59:59 <Erstarrung> URL ?
04:00:08 <Jafet> He's right here.
04:00:50 <monsieurlu> Day after day learning haskell it seems that creativity is a really important factor to be productive, what do you think?
04:01:13 <Erstarrung> Okay.
04:01:13 <shachaf> monsieurlu: I think cocreativity is what you want.
04:02:00 <donri> Erstarrung: cabal install plugins --constraint='directory < 1.2'
04:03:20 <monsieurlu> shachaf: sry, what do you mean by cocreativity ?
04:03:20 <Erstarrung> donri: I may have broken packages if I do so.
04:04:21 <donri> Erstarrung: ghc-pkg unregister each package that would break
04:05:06 <donri> wait, is directory tied to ghc releases?
04:05:15 <Erstarrung> Okay. Is there a way to fix it if I break it ?
04:05:23 <Erstarrung> donri: What directory ?
04:05:36 <donri> the package. not really asking you ;)
04:05:40 <fmap> donri: yep
04:06:10 <donri> Erstarrung: are you using ghc 7.6 per chance?
04:06:23 <Erstarrung> The Glorious Glasgow Haskell Compilation System, version 7.6.1
04:09:24 <donri> phone
04:20:16 <Erstarrung> Done.
04:20:29 <Erstarrung> stepcut: I've done two modifications on plugins.
04:23:17 <atriq> I tried to write a game in Haskell, but my indentation got a tad out of hand
04:24:57 <atriq> Some lines have 49 spaces before any code
04:25:37 <KBme> maybe you could refactor some?
04:25:58 <Jafet> That's not much
04:27:16 <atriq> It's just a little vaguely Homestuck themed Hunt the Wumpus clone
04:28:04 <fmap> atriq: do you indent by 7 spaces?
04:28:23 <atriq> I indent what I feel like at the time, evidently
04:30:17 <byorgey> fmap: must be either 7... or 1  ;-)
04:30:28 <KBme> heh
04:30:44 <Jafet> It might be 49
04:30:45 <atriq> I indent by 49
04:30:46 <KBme> or sometimes 3 sometimes 4 and sometimes 7 ;)
04:31:01 <byorgey> hehehe
04:31:23 <KBme> btw is there a datatype for dates? or do people just use some standard format and strings?
04:31:40 <atriq> Data.Time.Calendar
04:31:58 <KBme> ah
04:31:59 <KBme> thanks
04:32:03 <hpc> time is a strangely complicated thing, so there's actually a couple of types
04:32:07 <atriq> There's one in there, but I don't like it for reasons that probably won't be relevant to you
04:32:36 <KBme> hpc, yeah, I know, which is why I ask.
04:32:56 <Jafet> In haskell, it's a strangely overcomplicated thing
04:33:09 <KBme> dates are one of the most buggy types in pretty much any language afaic
04:33:23 <KBme> atriq, care to share?
04:35:04 <KBme> Data.Time.Calendar.Day doesn't seem so bad, I don't think any of my users will be born on negative days according to this calculation.
04:35:17 <donri> Erstarrung: did you get it to install?
04:35:27 <atriq> KBme, I do genealogy stuff
04:35:36 <KBme> ah well yeah, then it's not useful
04:35:46 <KBme> atriq, you have to use formatted strings then
04:35:54 <KBme> either that or a record
04:35:58 <atriq> I think I use a custom data-type
04:36:08 <KBme> yeah, that sounds reasonable
04:36:11 <atriq> Oh no, I use that
04:36:30 <atriq> Okay, the family-tree package is awful, don't use it
04:36:35 <atriq> I should know, I wrote it
04:36:38 <KBme> actually a record sounds simpler that mucking with strings but whatever
04:36:40 <Erstarrung> donri: Yep, by modifying the code.
04:36:50 <Erstarrung> (Jafet's solution)
04:37:06 <byorgey> formatted strings is a terrible idea for storing any kind of information.
04:37:08 <KBme> s/that/than/
04:37:12 <KBme> yeah
04:37:45 <byorgey> including text.
04:37:53 <byorgey> ;-)
04:38:01 <KBme> heh
04:38:09 <atriq> Isn't formatted strings like, all of Perl?
04:38:10 <KBme> so is Data.Text unicode?
04:38:13 <Jafet> Especially text.
04:38:24 <atriq> KBme, yes
04:38:36 <KBme> atriq, yep, usually what perl uses is not the right thing to do.
04:39:07 <KBme> great, so one should always use Data.Text for strings, right?
04:39:15 <shachaf> Sometimes.
04:39:32 <atriq> Always use Data.Text for actual Text
04:39:44 <KBme> so when Strings?
04:39:57 <atriq> If you're teaching, I think
04:40:21 <Jafet> > repeat 'A'
04:40:24 <lambdabot>   "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA...
04:40:33 <atriq> Or when it's short enough that using Data.Text or whatever isn't worth it
04:40:45 <KBme> hmmm
04:40:50 <pnielsen> or bytestring if it's just ascii
04:40:54 <KBme> or when you want unicode, I guess
04:41:01 <hpc> or when you know the abstraction of "linked list of chars" is useful
04:41:11 <atriq> Or when you want list functions
04:41:28 <KBme> all right
04:41:44 <KBme> great, I made a good decision of using Data.Text then, thanks
04:42:30 <dreixel__> @pf (\f -> f2 . f . t1)
04:42:31 <lambdabot> Maybe you meant: bf pl
04:42:36 <dreixel__> @pl (\f -> f2 . f . t1)
04:42:37 <lambdabot> (f2 .) . (. t1)
04:42:44 <KBme> but if you use overloadedstrings then you can even use list functions on Data.Text, no?
04:42:50 <atriq> No
04:42:53 <KBme> ok
04:43:02 <atriq> You can write "Hello" :: Text
04:43:15 <atriq> But you can't do map chr [1..10] :: Text
04:48:29 <atriq> Hehe, family-tree still uses data-lens
04:49:44 <joshuah> how would i check that "read a" is of type Integer or Double?
04:50:09 <atriq> read a :: Integer is an Integer
04:50:13 <atriq> read a :: Double is a double
04:50:20 * hackagebot idris 0.9.5.1 - Functional Programming Language with Dependent Types  http://hackage.haskell.org/package/idris-0.9.5.1 (EdwinBrady)
04:50:30 <atriq> It's tricker to make read' a :: Either Integer Double
04:53:18 <hpc> :t reads -- you might try something with this
04:53:20 <lambdabot> forall a. Read a => ReadS a
04:53:32 <hpc> @src ReadS
04:53:32 <lambdabot> Source not found.
04:53:33 <atriq> :info ReadS
04:53:35 <hpc> pah
04:53:42 <atriq> @info ReadS
04:53:42 <lambdabot> ReadS
04:53:46 <hpc> String -> [(a, String)]
04:53:57 <hpc> function from a string to a list of (parse, remaining string) pairs
04:54:33 <hpc> a string that doesn't represent anything useful will produce an empty list
04:54:34 <aleator> Silly question. It seems that Miranda was quite popular tool for teaching CS1 and various algorithmic courses. It seems that of late, using FP in such courses is much more rare. What happened after miranda?
04:55:01 <atriq> Haskell, basically
04:55:09 <atriq> Wait
04:55:10 <Jafet> Java?
04:55:47 <aleator> I mean, naturally modula-2 guys would migrate to java, but why does it appear that miranda teachers didn't migrate to haskell?
04:55:59 <atriq> Yeah, probably Java
04:56:10 <Jafet> Perhaps you should ask those teachers.
04:56:20 <hpc> aleator: perhaps they migrated back to writing research papers
04:56:32 <Jafet> And perhaps don't ask the ones who are teaching Haskell.
04:56:47 <aleator> Probably, but you know "Hey, you wrote a paper in -89, and I've got a question" isn't the best opening line ;)
04:57:07 <Jafet> Why not
04:57:35 <atriq> In 1989, I wasn't born.
04:58:10 <aleator> Well.. Perhaps I should just mail those guys, but my idle curiosity isn't yet worth bothering people personally
04:59:13 <ivanm> lispy: so, the bits where I'm pre-allocating arrays is working
04:59:53 <hiji> (Just starting out with Haskell, but) how essential is it to define function type signatures in Haskell?
05:00:05 <ivanm> hiji: in most cases it isn't needed
05:00:11 <ivanm> but it's preferable to do so for documentation
05:00:18 <Jafet> aleator: academics get all excited when other academics refer to their papers. Just play along with it.
05:00:34 <ivanm> also, many of us tend to write type sigs first to say what we want to do, then use that as a way of checking our implementation is correct :)
05:00:49 <hiji> is it best practice or so?
05:00:54 <ivanm> yeah
05:00:58 <hiji> I see
05:01:07 <ivanm> if nothing else, it stops ghc -Wall from complaining :p
05:01:13 <zomg> Yep I find it pretty useful to make sure my function actually does what I think it does since I'm not a super eleet pro haskell guy
05:01:26 <ivanm> hiji: but if you're just quickly hacking something together there's no need
05:01:31 <zomg> Sometimes I might get types a bit wrong so having the signature ensures they are correct =)
05:01:33 <hiji> I guess that would work if you could get your code to compile
05:01:39 <hpc> sometimes, your type signature gives you the definition for free
05:01:53 <hpc> @djinn a -> b -> (a -> b -> c) -> (c -> d) -> d
05:01:53 <lambdabot> f a b c d = d (c a b)
05:03:22 <merijn> aleator: You're making an unfounded (in my experience) assumption
05:03:31 <merijn> aleator: i.e. that mailing academics == bothering them
05:03:43 <merijn> In my experience they can't shut up about the topics they work on :p
05:04:51 <fmap> hiji: if you throw a paste of code with more that 10 lines of code without any type sigs here they will yell at you, mind
05:05:01 <fmap> s/of code//
05:05:12 <Jafet> They?
05:05:23 <hpc> you know... them
05:10:29 * hackagebot language-boogie 0.1.1 - Interpreter and language infrastructure for Boogie.  http://hackage.haskell.org/package/language-boogie-0.1.1 (NadiaPolikarpova)
05:11:03 <ivanm> I look at that package, and I have nfi what Boogie is
05:11:46 <ivanm> though from the bitbucket repo, I find this: http://boogie.codeplex.com/
05:11:48 <aleator> merijn: Well. Maybe I am.
05:12:03 <ivanm> the devs of that aren't at all pretentious: "aka The World's Best Program Verification System"
05:13:12 <ivanm> it looks like QC for C...
05:14:01 * fmap :-( at containers (0.4.*)
05:17:34 <hiji> could someone please explain the relation between "a" and "a1" is, in an error message that goes like "Couldn't match expected type `a -> (a1, a1)' against inferred type `(b, t)' " ?
05:17:49 <ivanm> hiji: just arbitrary variable names
05:18:07 <ivanm> hiji: it just means that you're using a function that returns a pair rather than just a pair
05:18:13 <ivanm> so you probably forgot to supply the argument
05:18:16 <hiji> ivanm, even a and a1?
05:18:28 <ivanm> sorry, other way round: you provided the argument when you shouldn't have
05:18:32 <hpc> hiji: the compiler names things about as well as a first-year CS student
05:18:37 <hpc> naming things the_variable
05:18:40 <ivanm> hiji: yup; ghc has some kind of naming rules but I don't recall what they are
05:18:41 <Jafet> It's roughly the same relationship between a car and a card
05:18:42 <hpc> the_variable1, the_variable2
05:18:58 <hiji> hpc: :D
05:19:11 <Jafet> No, they name variables worse than that.
05:19:34 <hpc> i posit that there's a finite limit to the terribleness of a variable name
05:19:55 <hiji> @hpc, and do you intend to prove that?
05:19:55 <lambdabot> Unknown command, try @list
05:20:09 <hiji> hpc: and do you intend to prove that?*
05:20:19 <hpc> someday, somehow
05:20:40 <hiji> you'd really have a lot of opposing evidence from thedailywtf
05:21:32 <Jafet> But, is there a variable attaining that limit?
05:22:07 <hpc> Jafet: yes
05:22:19 <hpc> they call it... m_pEntityRef2
05:22:53 <Jafet> Oh. I had conjectured it was _'
05:23:13 <hpc> nah, that underscore implies that the value doesn't matter
05:23:35 <hpc> whereas m_pEntityRef2 holds the information that it's a pointer to a thing (4 times!)
05:23:41 <hpc> and that it's the second of those pointers
05:23:44 <hpc> (or maybe third)
05:25:28 <nand`> on the other side of the spectrum, there's a best variable name
05:25:29 <nand`> x
05:26:40 <ivanm> nand`: and each function should be called `f' ? :p
05:26:56 <o-_-o> I don't know if this is a dumb question. But I am writing some code and I need to found out the type of something.
05:27:13 <hpc> o-_-o: you can do it in ghci with :t
05:27:15 <hpc> :t False
05:27:16 <lambdabot> Bool
05:27:19 <o-_-o> I am using ghc to compile the code, is there something like :t for code.
05:27:23 <hpc> ah
05:27:31 <hpc> you... probably want to be doing something different
05:27:48 <ivanm> o-_-o: at runtime?
05:27:56 <hpc> something like
05:27:56 <ivanm> no, I believe all types are thrown away at run-time
05:27:59 <o-_-o> Yes
05:28:24 <o-_-o> Ok...
05:28:26 <hpc> data FooType = FooInt Int | FooDouble Double | FooList [FooType]
05:28:46 <ivanm> hpc: yeah, explicit tagging for the limited type of types you want to support
05:30:28 <tdammers> o-_-o: types resolve at compile time, so runtime type checks are useless
05:30:46 <o-_-o> Ah...yeah.
05:33:10 <tdammers> if you want something like the runtime type checks (or runtime polymorphism) like in a dynamically-typed language, you have to implement dynamic types on top of the compile-time type system
05:33:12 <merijn> hpc: I am known in a very heated discussion with a colleague whether your theorem is stating that "∀p∈Person . p has a finite limit to the terribleness of variable names" or "∃t . ∀p∈Person . p has t as finite limit to the terribleness of variable names"
05:33:24 <merijn> hpc: i.e. is the finite limit universal or per person :p
05:33:51 <o-_-o> tdammers, Ok.
05:33:59 <o-_-o> No that is not what I wanted to do
05:34:08 <merijn> hpc: lrn2GADT :p
05:34:40 <o-_-o> I am writing some code and it keeps saying it is a Maybe, I couldn't find out what it meant. Now I just 'print'ed it and it worked.
05:35:23 <merijn> o-_-o: Can you put the problematic code + error on hpaste.org?
05:35:54 <o-_-o> One moment.
05:37:43 <badkins> I just read this in Real World Haskell: "Although Haskell represents characters and strings internally using Unicode, there is no standardized way to do I/ O on files that contain Unicode data. Haskell’s standard text I/ O functions treat text as a sequence of 8-bit characters, and do not perform any character set conversion."
05:37:44 <badkins>  
05:37:54 <badkins> along with: "There are third-party libraries that will convert between the many different encodings used in files and Haskell’s internal Unicode representation."
05:38:12 <badkins> What are the recommended "third-party libraries" to perform unicode-aware file I/O ?
05:38:15 <ivanm> badkins: yeah, that's not quite true any more
05:38:15 <o-_-o> http://hpaste.org/77057
05:38:24 <ivanm> as GHC now has locale-based support
05:38:42 <ivanm> badkins: it wasn't true when RWH was written, but nowadays use text and text-icu to do encoding conversion
05:38:58 <ivanm> and unless you're doing something really simple/short, Text > String
05:39:18 <Jafet> Or something really specific
05:39:32 <ivanm> or that
05:39:37 <badkins> I'll give it a shot. I have a simple IRC bot and someone entered a unicode ellipsis that displayed fine in all the irc clients, but when the bot wrote to the history file, it got munged
05:39:40 <ivanm> o-_-o: and the error is?
05:39:56 <Jafet> IRC is not unicode-aware.
05:40:14 <o-_-o> read.hs:14:35:
05:40:15 <o-_-o>     Couldn't match expected type `Maybe a0'
05:40:15 <o-_-o>                 with actual type `BS.ByteString -> Maybe (Int, BS.ByteString)'
05:40:17 <badkins> Jafet: well, it worked fine, so that doesn't appear to be the case
05:40:25 <merijn> badkins: Not really anything you can do about it
05:40:30 <ivanm> @hoogle readInt
05:40:30 <lambdabot> Numeric readInt :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
05:40:30 <lambdabot> Text.Read.Lex readIntP :: Num a => a -> (Char -> Bool) -> (Char -> Int) -> ReadP a
05:40:30 <lambdabot> Data.ByteString.Char8 readInt :: ByteString -> Maybe (Int, ByteString)
05:40:40 <Jafet> That's because IRC clients pass bytes that happen to be encodings of unicode
05:40:52 <merijn> badkins: IRC just transfers bytes in whatever encoding the local user entered it and the same for displaying
05:40:57 <ivanm> o-_-o: you'd be better off using print . fst . fromJust . BS.readInt
05:41:00 <ivanm> rather than $
05:41:15 <merijn> badkins: It just happens that *most* people are using utf-8 for their clients and thus it works fine on both sides
05:41:31 <ivanm> o-_-o: also, you should probably use something like `maybe 0 fst . BS.readInt' rather than fromJust
05:41:46 <o-_-o> ivanm, yeah, when I hit an error and am under pressure, I revert to $ :-)
05:41:59 <o-_-o> ivanm, ah...nice
05:41:59 <ivanm> merijn: and it would be a hell of a lot easier to write user-oriented software if we could do s/most/all/ ;-)
05:42:11 <ivanm> @type print $ fst
05:42:12 <lambdabot>     No instance for (Show ((a0, b0) -> a0))
05:42:12 <lambdabot>       arising from a use of `print'
05:42:12 <lambdabot>     Possible fix:
05:42:18 <ivanm> ^^ doesn't make sense :)
05:42:19 <merijn> badkins: You're three options are: 1) Log as bytestring and don't do any unicode 2) assume everything is utf-8 3) say screw this and stop caring :)
05:42:46 <ivanm> option 1) is probably the best approach
05:42:53 <merijn> badkins: Or I guess you could try to guess encodings, but my recommendation is to pick one of those three :p
05:43:05 <badkins> I hate encoding issues :(
05:43:06 <Jafet> Even if you use UTF-8, you should do IO with ByteString so that you can deal with errors.
05:43:24 <ivanm> Jafet: IO as in reading/writing to file?
05:43:30 <ivanm> not with Text?
05:43:36 <Jafet> A common error is long IRC messages that are broken in the middle of a codepoint.
05:43:44 <Jafet> No, all IO.
05:43:53 <ivanm> just for this use-case, or always?
05:44:33 <Jafet> This is obviously in the context of implementing an ad-hoc protocol from the eighties
05:44:41 <ivanm> heh, fair enough
05:44:47 <Jafet> Which silly people still use for some reason
05:44:54 <ivanm> I initially went "wtf" because I thought you meant for _all_ cases
05:44:57 <ivanm> Jafet: like us? ;-)
05:45:04 <badkins> merijn: I'm using:  hPutStrLn outh (escapeHistoryLine ((show now) ++ ": " ++ s))
05:45:13 <badkins> doc says hPutStrLn uses Bytestring
05:45:15 <Jafet> Though, ByteString-IO is still not used everywhere it should.
05:45:28 <ivanm> badkins: are you using the ByteString hPutStrLn?
05:45:31 <ivanm> or the String one?
05:45:46 <Jafet> The latter, evidently
05:46:04 <badkins> ah, the String one
05:46:12 <badkins> ok, I'll try ByteString
05:46:24 * ivanm uses ByteString-IO for graphviz only because it's easier to catch encoding errors that way than when relying upon glibc to do it
05:46:30 <Jafet> Yes.
05:46:47 <Jafet> If you use String IO, encoding errors become IO errors.
05:46:53 <ivanm> and since one of my test cases is the sample Latin1-encoded Dot file that Graphviz ships with...
05:47:00 <ivanm> Jafet: no, I meant the Text-based IO function
05:47:13 <ivanm> with new enough GHC, it uses GHC's underlying "use the system locale" encoding stuff
05:47:22 <ivanm> which crashes horribly with glibc errors if the encoding is wrong
05:47:41 <mapf> why it's impossible to define instance for type family?
05:47:49 <ivanm> I also wanted to make sure I was using utf-8 on systems where the locale _wasn't_ utf-8
05:47:57 <ivanm> mapf: for a specific one or for any one?
05:48:39 <badkins> merijn: when you say "1) Log as bytestring and don't do any unicode", will the file contain a valid unicode char then? Or are you saying ignore unicode issues?
05:48:48 <mapf> ivanm: i have type family TF and instance IN. instance IN TF  is forbidden
05:48:54 <ivanm> badkins: ignore the encoding, just operate on a stream of bytes
05:49:07 <mapf> sorry, instance IN (TF a) is forbidden
05:49:09 <Jafet> Everything is valid unicode, suitably decoded
05:49:19 <ivanm> mapf: I hope you mean class IN
05:49:26 <ivanm> rather than instance IN
05:49:39 <mapf> ivanm: hm
05:49:39 <badkins> ivanm: and writing a String to a file instead of a ByteString won't write a stream of bytes?
05:49:42 <ivanm> but if it's a specific one, you should probably paste the code + errors up somewhere if you want help :)
05:49:45 <mapf> icambridge: nope
05:50:14 <ivanm> badkins: no, there'll be encoding issues going on
05:50:17 <ivanm> mapf: do you mean me?
05:50:18 <Jafet> It will convert the characters to bytes in some unspecified way, then write the bytes.
05:50:25 <badkins> gotcha - thanks all
05:50:26 <ivanm> > "ivanm" == "icambridge"
05:50:27 <lambdabot>   False
05:50:46 <parcs`> mapf: because type families are not injective
05:53:58 <hpaste> mapf pasted “type family instance” at http://hpaste.org/77058
05:54:09 <gal_bolle> since I ran cabal update, cabal keeps complaining about "cabal: Couldn't read cabal file "warp/1.3.4.2/warp.cabal"", even though I don't care about warp at all. What can I do?
05:54:38 <dcoutts> gal_bolle: hang on a sec...
05:55:31 <mapf> parcs`: so, i guess i should make instance for each right hand side of type instance declaration then?
05:56:13 <mapf> ok, i can't even imagine that it means to be type family instance
05:56:50 <dcoutts> gal_bolle: ok, try cabal update and try again. Lemme know if it works.
05:57:09 <gal_bolle> one moment
05:57:28 <gal_bolle> yes it works
05:58:10 <bxc> in the standard library, applicative is a specialisation of functor... but it already contains enough to be a functor so without that requirement, you could say that any applicative induces a functor instance? (/me busy untangling in his head all the different type classes)
05:58:28 <ivanm> @where typeclassopedia
05:58:29 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:58:32 <ivanm> bxc: ^^
05:59:23 <bxc> ivanm: yeah i know that
06:00:57 <bxc> what i'm asking about is, is there a reason for it to be the other way round in the standard library?
06:01:06 <ivanm> bxc: OK, so yes, technically you don't need the Functor instance for Applicative, as you have liftA that can be used for the fmap definition
06:01:19 <bxc> that i'm missing
06:01:25 <ivanm> but generally you prefer simpler, more universal classes to be the super-classes
06:01:27 <bxc> or is it just the way its implemented
06:01:28 <parcs`> mapf: yep
06:01:35 <ivanm> there are things that are Functors that aren't Applicatives
06:01:50 * ivanm -> sleep
06:01:51 <bxc> ivanm: right
06:02:41 <bxc> maybe ewhat i'm asking (to myself) is is there a definition of Applicative that doesn't overlap in implementation with Functor - it uses fmap + something
06:02:50 <bxc> but where the something doesn't then induce an fmap
06:03:04 <bxc> (which the 'something' in the applicative definition now does)
06:04:36 <mapf> parcs`: i get the point. we can have the two type instances TI A = A; TI B = B and it seems impossible to resolve which one type from right hand side maps to which one from left hand side.
06:08:50 <merijn> mapf: You're expression data type looks like something that wants to use GADTs to me? But maybe I'm wrong...
06:10:33 * hackagebot btree-concurrent 0.1.5 - A backend agnostic, concurrent BTree  http://hackage.haskell.org/package/btree-concurrent-0.1.5 (JohanBrinch)
06:11:13 <mapf> merijn: it is
06:12:54 <mapf> it is GADT and it have constructor App :: Function a b -> Arguments a -> Expression b
06:13:03 <mapf> where Argument is type family
06:13:36 <merijn> mapf: hmm, why does Arguments have to be a type family?
06:13:48 <mapf> because i need to remap (a, .., a) to (E a, .. E a) and vise versa
06:14:32 <merijn> mapf: I'm not sure why that'd be necessary?
06:14:44 <mapf> I can't make first type variable of Function like (Expression a, Expression b)
06:14:57 <mapf> so it's like (a, b)
06:15:24 <mapf> but yes, maybe it's possible to make simpler
06:15:25 <merijn> Why can't you make it (Expression a, Expression b)? (Keep in mind I've only seen the one small paste so it's hard to tell
06:15:43 <hiji> hey if I need to show some code where should I post it? pastebin?
06:15:52 <merijn> hiji: hpaste.org
06:15:58 <hiji> merijn, thanks
06:16:38 <merijn> hiji: It will HLint your code and report cleanup suggestions, which is nice
06:16:43 <fmap> bxc: there is alternative definition of Applicative (in terms of unit and (**)) and it should be in typeclassopedia too.
06:17:01 <bxc> fmap: yeah i see that - but that is stated as being equivalent to pure and <*>
06:17:02 <bxc> so
06:17:19 <mapf> well, because ... i have to think maybe you're right...
06:17:37 <bxc> fmap: so it still induces  version of fmap
06:17:44 <bxc> (presumably)
06:18:17 <mapf> at first i think (Expression a) is lift a type 'a' so we get nice type safiety
06:18:29 <mapf> and with Function as well
06:18:53 <mapf> but maybe it's not reasonable
06:19:39 <dmwit> :t (<*>)
06:19:45 <lambdabot> forall (f :: * -> *) a b. Applicative f => f (a -> b) -> f a -> f b
06:19:47 <fmap> bxc: well, you can write fmap in terms of (<*> and pure), i don't know if you can write it in terms of (** and unit)
06:19:55 <hpaste> hiji pasted “[Noob] Mean function” at http://hpaste.org/77059
06:20:00 <fmap> (i guess you can't)
06:20:03 <dmwit> fmap: Yes, you can.
06:20:07 <fmap> hm
06:20:09 <dmwit> That is what "equivalent" means.
06:20:17 <dmwit> Anything you can do with the one, you can do with the other, too.
06:20:32 <hiji> Could someone tell me how I should go about annotating the second example with a type signature?
06:20:38 <bxc> fmap: if its equivalent to <*> and pure then you must be able to
06:20:41 <bxc> fmap: else they're not equivalent...
06:20:47 <dmwit> fmap, bxc: I take it back.
06:20:50 <bxc> oh dmwit go tthere first
06:20:56 <bxc> dmwit: ...
06:21:08 <dmwit> bxc: But "they're equivalent" may be in the context of "assuming fmap exists". =)
06:21:28 <fmap> i think (<*> + pure) is equivalent to (** + unit + fmap)
06:21:30 <dmwit> i.e. perhaps fmap, (**), and unit are equivalent to fmap, (<*>), and pure.
06:21:35 <merijn> hiji: The problem is that function application *always* binds tighter than operators
06:21:36 <joshuah> how can i check if type of "read a" is Integer or Double?
06:21:39 <S11001001> hiji: do the first example, ask ghci for :t mean, and write that in
06:21:42 * bxc nods
06:21:57 <dmwit> fmap: Right, you're right, I think, and I was wrong.
06:22:08 <S11001001> hiji: as for actual problem ^merijn
06:22:25 <merijn> hiji: So your code parses as "(uncurry (/)) . (foldl ... xs)" instead of "(uncurry (/) . foldl ...) xs"
06:22:42 <bxc> i think to implement <*> you need fmap and ** at least...
06:22:43 <hiji> S11001001: mean :: [Double] -> Double is what I get
06:23:22 <HugoDaniel> is there any way to check if there are newer versions of the build depends described in my project .cabal file ?
06:23:24 <hiji> merijn, trying to wrap my head around that slowly
06:23:30 <bxc> something like a <*> b = fmap $ (a ** b)
06:23:33 <S11001001> hiji: yeah, that's close enough (you can fix the monomorphism thing later).  apply merijn's idea to fix
06:23:35 <merijn> hiji: Let me give you a simpler example
06:23:48 <HugoDaniel> some command that tells "new version of websocket available" or something like that
06:23:57 <HugoDaniel> so that i don't have to check them by hand
06:24:27 <merijn> hiji: Your code is currently this: "f . g xs" which parses as "f . (g x)", but this is a type error, since you intended to write "(f . g) x"
06:24:35 <S11001001> hiji: in general if you're messing with a function with inferred type and want to make sure it doesn't change type, you can just get the original type from ghci and copypaste that in
06:24:37 <merijn> hiji: Which is why the version without the xs *does* work
06:24:56 <hiji> merijn, yes that is what I want to do
06:25:09 <bxc> dmwit: i guess ** puts the two things "near enough to apply to each other" but doesn't apply them
06:25:23 <merijn> hiji: There's multiple possible solutions, the simplest one being "put parentheses around the entire thing before the xs"
06:25:39 <hiji> merijn, is there some opposite of $
06:25:51 <merijn> hiji: Others include "use the first definition without xs", "use $", etc.
06:26:11 <merijn> hiji: even $ should work, you can do "f . g $ x" to achieve "(f . g) x"
06:26:17 <dmwit> bxc: yup
06:26:31 <merijn> hiji: "f $ g x" would also work the same
06:26:40 <ski> @pl f . g $ x
06:26:41 <lambdabot> f (g x)
06:26:48 <dmwit> bxc: One way I like to think of it is that functors give you 1-ary maps, and applicatives give you n-ary maps.
06:26:49 <bxc> dmwit: ok thats probably the definition i'm seeking then
06:26:49 <hiji> merijn, YES!! THAT WORKED !!!
06:27:01 <merijn> hiji: btw, for readability's sake I would recommend splitting the lambda into a where clause
06:27:04 <hiji> merijn, thank you for taking the time to explain it :)
06:27:10 <dmwit> bxc: (pure is like a 0-ary map, and (<*>) is a funny way of spelling a 2-ary map, and all the other n can be built from those)
06:27:20 * bxc nods
06:27:45 <dmwit> bxc: (similarly, unit is like a 0-ary map where the function hasn't been applied yet, and (**) is a 2-ary map where the function hasn't been applied yet)
06:27:55 <bxc> now how to add that into typeclassopedia?
06:28:05 <hpaste> merijn annotated “[Noob] Mean function” with “[Noob] Mean function (annotation)” at http://hpaste.org/77059#a77061
06:28:24 <merijn> eh, damn
06:28:27 <merijn> Forgot the where >.>
06:28:41 <hpaste> merijn annotated “[Noob] Mean function” with “fixed where” at http://hpaste.org/77059#a77062
06:29:15 <hiji> merijn, how come you didn't have to use the "where" clause?
06:29:23 <merijn> hiji: I did, it was a typo xD
06:29:30 <hiji> :D got it
06:29:38 <hiji> merijn, thanks a lot again :)
06:30:04 <hiji> merijn, I've been all over the place for two days mucking around with type signatures and shit :D
06:31:12 <merijn> hiji: Just keep in mind the simple "function application always beats operators" rule
06:31:43 <merijn> hiji: If you look at the error, that's also what it says (albeit a bit obfuscated)
06:32:18 <merijn> hiji: "Couldn't match expected type `a -> (a1, a1)'" -> "I was expecting a function returning a tuple"
06:32:32 <merijn> "against inferred type `(b, t)'" -> "but I got a tuple instead"
06:32:48 <merijn> "In the second argument of `(.)', namely" -> fairly self explanatory
06:33:28 <merijn> hiji: In which case the debugging step is "why is it getting a tuple?" and "why do I think that's a function?" :)
06:33:34 <dmwit> Whenever I end up having to actually read a GHC error message, it's always very helpful.
06:33:37 <dmwit> ghc++
06:33:46 <hiji> merijn, how do I debug in ghci?
06:34:08 <nand`> yes the main problem with confusing error messages seems to be that people don't actually read and try to understand them
06:34:17 <dmwit> hiji: -fdefer-type-errors and you're on your way
06:34:31 <merijn> nand`: Well, they can be a bit intimidating if you're a newcomer
06:34:48 <akamaus> hi! what's the best way to receive data from the socket and parse it as a C struct? I tried to use c2hs, but it operates on Ptr's and I receive bytestrings. How to connect them?
06:35:35 <dmwit> hiji: (This turns type-incorrect code that barfs at compile time to type-correct code that warns at compile time and barfs at runtime. So long as you debug the type-correct fragment of your code, nothing barfs.)
06:35:43 <hiji> dmwit, googling that
06:36:00 <dmwit> hiji: (You will need the most recent GHC if you want to use this feature.)
06:36:49 <hiji> dmwit: I'll have to compile ghc7.2 then
06:37:09 <dmwit> Wait, you're using a GHC even older than 7.2?
06:37:21 <hiji> 6.12.1
06:37:22 <merijn> hiji: I don't think defer-type-errors is that helpful for debugging
06:37:32 <bxc> if you have a Reader monad, theres no value added by it beind a monad beyond it being an Applicative, because you can't use a value to influence the only operation, which is read?
06:37:34 <dmwit> Your final goal is GHC 7.6, for which there should be binaries on GHC's website...
06:37:41 <Jafet> It was intended to be helpful for debugging
06:38:05 <merijn> bxc: Well, you get do syntax which is nice
06:38:10 <bxc> yeah
06:38:11 <Jafet> Or maybe it was an exercise in reorganizing the type checker. That's what the paper sounded like.
06:38:34 <Philonous> Are there known bugs with the ghc 7.6.1 version of bytestring, because code that used to work fine suddenly exhibits the strangest behaviours
06:38:48 <Philonous> ?
06:38:50 <dmwit> bxc: Well, you can decide whether to do a read or not, and you can decide what function to apply if you do decide to do a read.
06:39:16 <hiji> dmwit, problem is that I'm on Ubuntu 10.04 for which apparently there are no binaries
06:39:29 <dmwit> bummer
06:39:45 <Jafet> No, you go to the GHC website and download the binaries.
06:39:52 <hiji> ohh
06:39:59 <Jafet> And while you're doing that, upgrade to debian
06:40:10 <shachaf> Jafet: GHC's website will do that for me?
06:40:24 <Jafet> It should
06:40:35 <Jafet> Wait, shachaf, you use ubuntu?
06:40:41 <shachaf> No, I use Debian.
06:41:01 <shachaf> I used to use Ubuntu but then it got terrible.
06:41:06 <Jafet> Well then, I suggest you upgrade debian using apt.
06:41:15 <hiji> Jafet, thanks for that, I found 7.6 on the GHC site
06:41:30 * dmwit wonders briefly how "there should be binaries on GHC's website" could be interpreted to not mean "go to the GHC website"
06:41:34 <hiji> never struck me that GHC and the Haskell Platform were two diff projects
06:41:56 <dmwit> aha
06:42:04 <shachaf> http://hdiff.luite.com/ is another diff project.
06:42:05 <hiji> dmwit, sorry, I went to haskell.org
06:42:28 <hiji> whereas the ghc 7.6 link was in www.haskell.org/ghc
06:42:52 <byorgey> dmwit: there's another level of interpretation you forgot, which is what exactly "the GHC website" resolves to
06:42:58 <byorgey> sadly DNS does not help
06:42:59 <hiji> dmwit, to a noob a big dowload button says "CLICK" http://www.haskell.org/platform/linux.html
06:43:02 <dmwit> byorgey: right =)
06:43:13 <hiji> byorgey, yes DNS-wise :D
06:43:19 <shachaf> dmwit: When you go to haskell.org, there's a big "Download Haskell" (who came up with that phrasing?) button. When you click on it, there's a Linux link. When you click on that, there's an Ubuntu link. When you click on that, you get to packages.ubuntu.com
06:43:30 <shachaf> Not very helpful.
06:43:35 <byorgey> DOWNLOAD ALL THE HASKELL
06:43:37 <hiji> shachaf, and that page doesnt have binaries for Ubuntu 10.04
06:43:41 <Jafet> I didn't know the Haskell website was that malevolent.
06:43:45 <hiji> which is what I dutifully reported :D
06:43:56 <bxc> dmwit: i don't get that "deicding whether to do a read or not" adds any value: you either decide based on some input, in which case this isn't monadic, or you decide based on the read value, in which case you already have the read value and don't get anything more by being able to read it again (aside from some syntax)
06:44:02 <Philonous> shachaf:  Does "download haskell" lead to a pdf of the language report?
06:44:02 <hiptobecubic> I want some haskell
06:44:08 <shachaf> Philonous: It should.
06:44:18 <merijn> Is there a list of Haskell98 extensions which became "builtin" in Haskell2010?
06:44:21 <Philonous> shachaf:  That would actually be hilarious
06:44:27 <dmwit> bxc: Nevertheless, it is common (for abstraction reasons) to do multiple reads.
06:44:35 <byorgey> maybe we should make a website called "Get You a Haskell For Great Good" with exact step-by-step instructions
06:44:37 <Jafet> Philonous: the implementation is left as an exercise
06:44:42 <bxc> dmwit: surebut you can do that in applicative
06:44:50 <dmwit> bxc: I write a piece that does a read, you write a piece that does a read, and then we plumb them together without looking inside each other's implementations.
06:45:19 <dmwit> bxc: Yes, but the Applicative can't write plumbing that chooses to call or not to call this black box (that *happens* to do a read).
06:45:21 <Jafet> bxc: by that argument you don't even need Reader, just plumb the value around directly
06:45:28 <hiji> byorgey, Sorry about that :)
06:45:38 <byorgey> hiji: sorry about what?
06:45:57 <byorgey> hiji: I was not making fun of you, I was being serious!
06:46:07 <hiji> byorgey, I wasn't quite sure :D
06:46:23 <byorgey> it really should be easier to figure out what "download haskell" means, and exactly how to do it
06:46:30 <shachaf> <byorgey> I was not trying to help you, I was being hilarious!
06:46:42 <byorgey> well, that too =P
06:47:01 <byorgey> I was making a serious suggestion in the guise of a joke
06:47:35 <dmwit> bxc: Is 10.04 the latest LTS release of Ubuntu?
06:47:48 <bxc> dmwit: no
06:47:55 <bxc> dmwit: theres a 12. something
06:48:01 <bxc> dmwit: why are you asking me?
06:48:07 <dmwit> ...I don't know.
06:48:12 <dmwit> by mistake
06:48:28 <dmwit> hiji: You should upgrade your system. =)
06:48:31 <bxc> 12.04 is latest, i think
06:48:38 <merijn> byorgey: It means "install Haskell Platform", doesn't it?
06:48:52 <Jafet> > 2012 `mod` 100
06:48:53 <hiji> dmwit, Yes I should. Just lazy about having to uninstall the Unity crapware
06:48:56 <lambdabot>   mueval-core: Time limit exceeded
06:49:07 <merijn> Or rather, isn't that one of the main reasons for the existence of HP
06:49:58 <shachaf> I thought the main reason for the existence of HP was to sell printer ink.
06:50:15 <byorgey> merijn: yes, but what does "install HP" mean?  should you get it from your distro, or from source, does it come with GHC or not...
06:50:21 <byorgey> all this ought to be more clearly explained than it is
06:50:32 <dmwit> merijn: Yes, the HP is supposed to ease noobs into Haskell. Clearly, though, people run distributions older than the platform, which makes blanket "here's a link to your distribution's package manager" things not quite right...
06:51:05 <bxc> when packaging systems cold...
06:51:14 <bxc> *colide...*
06:51:19 <bxc> collide?
06:51:22 * bxc sighs
06:51:29 <Philippa> yeah, we move our stable stuff substantially faster than a lot of distros with awkward results
06:51:33 <shachaf> colllide
06:51:46 <shachaf> Philippa: FSVO "stable"
06:51:52 <dmwit> shachaf: you should ellllide an l
06:52:07 <shachaf> dmwit: For short, ell-lide.
06:52:10 <mauke> ł
06:52:10 <merijn> byorgey: That's only a problem for silly linux users :>
06:52:15 <bxc> wasted too much of my life on packaging...
06:52:16 <bxc> bleugh
06:52:36 <merijn> byorgey: I guess I'm spoiled by the download and click to install experience of HP on OSX
06:52:40 <bxc> now i just prefer to get on this channel and bitch about -p not working
06:52:41 <nand`> merijn: agree; if you use a silly linux distro then it's your problem :P
06:52:47 <shachaf> merijn: What version of GHC are you running?
06:53:00 <shachaf> 32-bit?
06:53:00 <dmwit> Silly Linux is best Linux!
06:53:15 <merijn> shachaf: 32bit 7.4.2 I have a separate install for 32bit 7.6 because I'm abusing DataKinds
06:53:15 <bxc> merijn: download and click to install is one step more than apt-get haskell-platform
06:53:28 <shachaf> Oh, you already confirmed the segfault.
06:53:30 <Jafet> On linux, you get two versions of every package. On windows, you don't manage to build any packages. On Mac OS, ghc crashes.
06:53:36 <merijn> bxc: Except when it turns out apt-get installs the wrong haskell platform :)
06:53:42 <bxc> yeah
06:53:55 <bxc> clearly the solution is to have no packacging sytem in your OS at all...
06:54:13 <merijn> bxc: You're joking, but I'm slowly starting to think that
06:54:13 <nand`> the solution is to use NixOS
06:54:17 <nand`> disclaimer: I've never used NixOS
06:54:30 <jrajav> ghc has worked fine for me so far on OSX
06:54:33 <merijn> bxc: The only thing I'd really want is OS features to track what gets installed so it can be uninstalled easily
06:54:38 <jrajav> And I ran one command to install it ;)
06:54:59 <jrajav> I used Linux for years and Homebrew is one of the best package managers I've used
06:56:07 <dmwit> bxc: Also, click to install is one click, apt-get haskell-platform is like... lots of clicks
06:56:13 <dmwit> > length "apt-get haskell-platform"
06:56:16 <lambdabot>   24
06:56:18 <dmwit> 24 clicks
06:56:35 <Jafet> Only if you're one of those nerds with clicky keyboards.
06:56:37 <Jafet> You nerd.
06:56:39 <dmwit> and the buttons are smaller, we all know how much of a UI disaster small buttons are
06:56:47 <jrajav> Jafet: *happy nerds
06:58:17 <fmap> > length "apt-g\ti\thask\t-p\t"
06:58:18 <lambdabot>   16
06:58:51 <Jafet> > length "apt-g\ti\thask\t-p\t\n"
06:58:52 <lambdabot>   17
06:59:16 <dmwit> alias i="sudo apt-get install"
07:00:38 <shachaf> alias ih='sudo apt-get install haskell-platform'
07:01:14 <Jafet> echo apt-get install haskell-platform >> ~/.bashrc
07:02:03 <shachaf> echo 'echo apt-get install haskell-platform >> ~/.bashrc' >> ~/.bashrc
07:03:30 <dmwit> You see? Silly Linux is best Linux!
07:03:42 <Jafet> chsh `which ghci`
07:05:00 <Philonous> can cabal-dev handle custom ghc version?
07:05:26 <merijn> Philonous: Just make sure your custom ghc is first on your path
07:05:45 <merijn> And then it should just work, I think?
07:06:20 <fmap> Philonous: --with-ghc=/path/to/custom/ghc
07:06:39 <Philonous> Ah, nice
07:08:08 <nand`> Jafet: haha
07:14:46 <earthy> there's another point to apt-get install, which is that those 17 clicks also *download* the haskell platform
07:16:21 <dmwit> Jafet: Haha, thank goodness. Now that unsightly, untyped, unreadable cd foo can be the much saner changeDirectory "foo" instead.
07:19:29 <earthy> dmwit: don't laugh too hard:
07:19:40 <earthy> Alias           cd                                                  Set-Location
07:19:53 <earthy> (directly from PowerShell)
07:20:56 <joshuah> how could i check what type "read a" is after being evaluated?
07:21:10 <identity> joshuah: Depends on the context
07:21:11 <shachaf> dmwit: ghci has :cd
07:21:18 <shachaf> joshuah: You get to decide!
07:21:22 <Philonous> :t read
07:21:23 <lambdabot> forall a. Read a => String -> a
07:21:29 <identity> did you explicitly specify the type of the function where read is?
07:21:42 <shachaf> read doesn't "figure out" the type. You tell it what to look for.
07:22:11 <Philonous> > read "123" :: Int
07:22:13 <lambdabot>   123
07:22:15 <Philonous> > read "123" :: Double
07:22:17 <lambdabot>   123.0
07:22:33 <Philonous> > read "123" :: Bool
07:22:34 <lambdabot>   *Exception: Prelude.read: no parse
07:25:27 <Philonous> > let x :: Read a => a; x = read "123" in (x, x, x) :: (Int, Double, Bool)
07:25:28 <lambdabot>   (123,123.0,*Exception: Prelude.read: no parse
07:27:39 <nicoo> :t read
07:27:40 <lambdabot> forall a. Read a => String -> a
07:29:15 <Philonous> joshuah:  Read returns a polymorphic value, that means, you can choose what type it should have (within the restriction that it must be an instance of Read), you can even use the same value in multiple contexts with different type.
07:39:29 <merijn> > read "3" :: Bool
07:39:31 <lambdabot>   *Exception: Prelude.read: no parse
07:39:33 <merijn> > read "3" :: Int
07:39:35 <lambdabot>   can't find file: L.hs
07:39:43 <merijn> aww :(
07:39:47 <merijn> That's not right
07:39:54 <shachaf> merijn: I hate it when I use read with :: Int and get an L.hs error.
07:40:33 <shachaf> The GHC developers really ought to do something about that bug.
07:41:56 <int-e> > read "3" :: Int
07:41:57 <merijn> btw, I remember seeing that readMaybe would be exposed by Prelude in GHC, any clue when that's happening?
07:41:57 <lambdabot>   3
07:42:11 <int-e> shachaf: there, they fixed it :P
07:43:58 <donri> merijn: it's already in base anyway
07:44:11 <hpaste> plhk pasted “is there a better way?” at http://hpaste.org/77065
07:45:43 <mapf> there is; data User = User {...} and User :: String -> String -> String
07:45:52 <merijn> donri: It is? Where?
07:46:18 <donri> merijn: Text.Read
07:46:24 <fmap> plhk: where do you get list from?
07:46:43 <merijn> donri: \o/
07:46:44 <shachaf> I don't want to import Text.Read!
07:46:45 <fmap> if it's parsing result it would be better to avoid using lists at all
07:46:57 <shachaf> Text.Read exports the useless symbol "get".
07:47:16 <tdammers> import Text.Read hiding (get)
07:47:42 <plhk> fmap: yeah, it is a result of Text.split
07:49:25 <joshuah> Philonous: ok, so how would you suggest i go about finding out if user input is Integer or Double (or whatever type)?
07:49:29 <plhk> oh well, it will be Text then. i posted a simpified example i'm playing with in ghci
07:50:58 <fmap> I'd use parsec/attoparsec instead of that Text.split thing
07:51:02 <shachaf> joshuah: I can tell you right now.
07:51:08 <shachaf> joshuah: User input is a String.
07:51:12 <shachaf> Problem solved. :-)
07:52:46 <Philonous> joshuah:  You get the input string, write a parser that decides how to interpret it.
07:52:53 <jrajav> What if the user opens up their CPU and updates a register with a charged needle?
07:53:12 <jrajav> Surely we must account for edge cases
07:53:50 <joshuah> you mean edge of sanity?
07:55:40 <geekosaur> high voltage on the case.  *zaaap* one edge case dealt with...
07:56:33 <mapf> i stuck with ghc panic, should i report?
07:57:14 <mapf> there are too much code and it's too bad to find out why panic happened
07:58:28 <hpaste> mapf pasted “should i report?” at http://hpaste.org/77066
07:58:35 <mapf> here is it
07:59:05 <shachaf> That looks like a bug.
07:59:07 <mapf> i'm novice and i'm doubt
07:59:12 <shachaf> It looks a bit like http://hackage.haskell.org/trac/ghc/ticket/7093
07:59:29 <mapf> yep
07:59:32 <shachaf> Er, http://hackage.haskell.org/trac/ghc/ticket/5951
08:00:12 <shachaf> Looks like your instance declaration is messed up.
08:00:21 <shachaf> Also looks like this is fixed in newer GHC.
08:00:24 <mapf> i don't know
08:00:25 <stepcut> Erstarrung: hmm, the findFile stuff is already patched in darcs,but for some reason I did not upload a new version to hackage, http://hub.darcs.net/stepcut/plugins/changes
08:00:32 <stepcut> Erstarrung: I'll do that in a few minutes
08:00:49 <mapf> shachaf: yes, i use 7.4.*
08:02:08 <jfischoff> has anyone messed around with the singletons library?
08:02:51 <jfischoff> in this declaration is 'k' a kind variable? data family Sing (a :: k)
08:03:19 <byorgey> jfischoff: yes
08:03:32 <notdan> Can anyone help me out with setting up lexical states with alex?
08:03:37 <jfischoff> interesting
08:03:49 <notdan> In the example in the documentation they use begin <STATE>, but apparantly, begin is not defined
08:04:24 <byorgey> jfischoff: Richard (the author) sits right behind me
08:04:32 <jfischoff> oh cool!
08:04:42 <byorgey> jfischoff: he doesn't hang out on IRC but says you're welcome to email him with questions
08:04:48 <byorgey> jfischoff: or I can pass along questions to him
08:04:53 <jfischoff> hmm well I'll try to come with intelligent question
08:04:58 <byorgey> ok =)
08:05:20 <jfischoff> I'm still not sure if the singleton library is what I need
08:05:28 <jfischoff> but it is intereting nonetheles
08:05:30 <jfischoff> s
08:06:32 <jfischoff> byorgey: ah it looks like when you make a data instance you specify the k with a DataKind (perhaps star too)
08:07:10 <ocharles> hey, does anyone have any suggestions on reducing the horrible duplication in https://gist.github.com/7af74a9699f43c13267f ?
08:07:27 <ocharles> Those 2 files are almost identical, but a query SQL queries change
08:07:34 <mapf> it is pretty strange that malformed instance spawn such behavior
08:08:31 <ocharles> One idea I have is to have a 'data CreateGeneric' type which contains the various queries, and then 'create = createGeneric CreateGeneric { treeTable = "artist_tree"}' etc
08:08:44 <ocharles> I wonder if people can see other useful abstractions there?
08:08:51 <byorgey> jfischoff: yes, the purpose of Sing is to reflect promoted type-level things back to the value level.  k would usually be a promoted type.
08:10:40 * hackagebot reactive-banana 0.7.1.0 - Practical library for functional reactive programming (FRP).  http://hackage.haskell.org/package/reactive-banana-0.7.1.0 (HeinrichApfelmus)
08:10:42 * hackagebot reactive-banana-wx 0.7.1.0 - Examples for the reactive-banana library, using wxHaskell.  http://hackage.haskell.org/package/reactive-banana-wx-0.7.1.0 (HeinrichApfelmus)
08:13:04 <merijn> @hoogle Monad m => Int -> (a -> m a) -> a -> m a
08:13:05 <lambdabot> No results found
08:13:08 <Philonous> This is just bonkers, the exact same program compiled with 7.4.2 works and with 7.6.2 it gives the strangest results.
08:15:12 <merijn> There's nothing like "iterateM" ?
08:15:22 <ocharles> :t iterate
08:15:23 <lambdabot> forall a. (a -> a) -> a -> [a]
08:15:31 <ion> @type \n -> foldr (<=<) return . replicate n
08:15:32 <lambdabot> forall (m :: * -> *) b. Monad m => Int -> (b -> m b) -> b -> m b
08:15:33 <ocharles> merijn: do you mean replicateM?
08:15:35 <ocharles> :t replicateM
08:15:36 <lambdabot> forall (m :: * -> *) a. Monad m => Int -> m a -> m [a]
08:15:39 <merijn> ocharles: No
08:15:40 <ocharles> oh, no
08:20:10 <ski> @type runStateT  -- where did this go ?
08:20:11 <lambdabot> Not in scope: `runStateT'
08:30:12 <hpaste> killy9999 pasted “replacing IO monad with ST monad” at http://hpaste.org/77069
08:30:20 <killy9999> guys, I'm stuck
08:30:49 <killy9999> I'm writing A Very Ugly Imperative Algorithm that initializes a vector using destructive updates
08:31:36 <killy9999> and this has to be done in a PrimMonad - only ST and IO are instances of this class
08:31:55 <killy9999> but I don't know how can I use ST monad for this :/
08:31:57 <Jafet> PrimMonad is just another name for ST or IO
08:33:03 <killy9999> mhm
08:33:45 <killy9999> but I don't understand why using IO monad is fine and ST is not
08:34:10 <Jafet> Why do you think it isn't?
08:34:45 <killy9999> well, perhaps it is, but I don't see how
08:35:01 <killy9999> if I just replace unsafePerformIO with runST I get a type error
08:37:10 <hpaste> killy9999 annotated “replacing IO monad with ST monad” with “replacing IO monad with ST monad (annotation)” at http://hpaste.org/77069#a77070
08:38:44 <Jafet> That code is correctly typed
08:38:59 <Jafet> if ill-behaved
08:40:44 <killy9999> if it's correctly type than why does the typechecker complain? o_O
08:41:01 <ryant5000> is there a way to create an SCC dynamically?
08:41:07 <Jafet> Because the code that you offered to the typechecker was ill-typed.
08:41:26 <srhb> killy9999: It doesn't / your're wrong.
08:41:27 <srhb> :P
08:41:31 <Jafet> ryan: probably not
08:41:41 <Jafet> Why do you need one
08:42:59 <ryant5000> Jafet: well, i'm looking into getting stack trace and profiling information for a web app
08:43:40 <ryant5000> Jafet: and it would be nice to be able to break things down by some aspects of the request that aren't defined statically
08:44:11 <killy9999> I don't get it :/
08:44:45 <Jafet> GHC provides some hooks for programs to use, but I don't think it is anywhere possible to add new debugging points with them
08:44:45 <ryant5000> Jafet: not a big deal, just something i thought would be nice to have
08:44:56 <Jafet> But you can look at the manual
08:44:59 <ryant5000> Jafet: yeah, i'm looking at GHC.stack
08:45:05 <simpson> killy9999: Did you want runSTArray?
08:45:18 <Jafet> No, that is for STArray.
08:45:43 <simpson> Oh, what's this generic array business? I've not seen these.
08:45:46 <simpson> Hm.
08:46:20 <killy9999> simpson: nope, as Jafet said
08:46:26 <killy9999> I'm working with Vectors
08:46:41 <copumpkin> you want New?
08:48:15 <Saizan> killy9999: the ST version typechecks fine here if i import Control.Monad.ST
08:48:23 <Saizan> killy9999: on ghc-7.4.1
08:48:50 <josephle> killy9999: like Saizan says, the ST version typechecks just fine on ghc-7.4.1
08:48:58 <killy9999> wtf...
08:49:04 <killy9999> OK, I'm checking my code
08:49:31 <killy9999> copumpkin: New might be an alternative, I'd had to read the haddock
08:49:54 <copumpkin> New is the fancy approach to building vectors mutably and then freezing them
08:50:43 <KBme> hi
08:51:31 <KBme> so do I understand correctly that if many modules in my app use a database connection, the simplest would be to use a monad to have a database connection in the DatabaseTransaction context?
08:52:38 <ocharles> KBme: that's how I do it, yea
08:52:56 <ocharles> i usually just newtype over ReaderT MyAppContext IO
08:53:08 <KBme> ocharles, ooo, do you have an example? I'm kind of new to haskell, and it's really confusing how to create a monad…
08:53:17 <ocharles> sure
08:53:22 <KBme> yeah, I started implementing it using the readert
08:54:07 <ocharles> https://github.com/metabrainz/musicbrainz-data/blob/master/src/MusicBrainz.hs#L42 -- lines 42-60 for the general monad, and lines 76 for 'primitives' in that monad
08:54:18 <KBme> lemme see
08:54:33 <KBme> and thank you so much…my brain hurts trying to understand how to do this
08:54:55 <ocharles> np
08:55:04 <KBme> oh, and you use postgres aswell, wow how convenient
08:55:07 <ocharles> learning how monad transformers work is important, RWH has a good chapter on that
08:55:23 <ocharles> this would be even more convenient if mightybyte released his MonadSnap type class :)
08:55:31 <ocharles> sorry, MonadPostgres
08:55:34 <KBme> ☺
08:55:38 <KBme> oh :D
08:56:35 <bgamari> I'm not sure I understand why the Reified* types must exist in lens
08:56:40 <killy9999> ok, I stripped my original code so it compiles.. now I'm adding stuff back to see when it breaks
08:57:47 <ocharles> bgamari: I believe it's due to the type system forcing a traversal to be a specific type, but if your traversal could be used to produce different types, then you have a problem
08:58:02 <ocharles> so you can use cloneTraversal to get the same traversal over different types, but Reified is just an optimization to make that faster
08:58:07 <ocharles> that's my shitty understanding of it
08:59:11 <bgamari> ocharles, I think that sounds reasonable
08:59:52 <ocharles> I believe I need them when I had some code that would do one traversal to 'extract' replace values by their primary key, run all of them through a database lookup, and then replace the primary key with the result of the database query
09:00:04 <ocharles> so that's a traversal that would change the type twice, and you can't do that without cloning or reifying
09:00:29 <ocharles> (or in my case using platesOf, but that doesn't help this example ;))
09:01:10 <rwbarton> in case you want to have a list or something of lenses
09:01:16 <rwbarton> type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
09:01:32 <rwbarton> ghc doesn't deal terribly well with types like [forall f. Functor f => (c -> f d) -> a -> f b]
09:01:50 <Clint> gwern: is mail to gwern.net supposed to work?
09:01:57 <ocharles> well that would be a heterogenous list, right?
09:02:48 <ski> no
09:04:36 <papyrus> hello, ..
09:04:54 <rwbarton> it's a list of values each of which is polymorphic
09:05:02 <ocharles> oh, right
09:05:11 <gwern> Clint: no
09:05:17 <ocharles> yes, i see it now
09:05:23 <Clint> gwern: oh, oops
09:06:06 <papyrus> i have a question.  "something :: j a" ,  a is always "*" ?  i think it can be "*->*
09:06:33 <Jafet> It can be any kind
09:06:52 <papyrus> thanks Jafet :-)
09:07:12 <ocharles> really? I thought something would have to be a 'fully applied' type?
09:07:27 <ocharles> ie, you couldn't have something :: Either
09:07:29 <tac> :t List --papyrus:
09:07:30 <lambdabot>     Not in scope: data constructor `List'
09:07:30 <lambdabot>     Perhaps you meant `Last' (imported from Data.Monoid)
09:07:35 <tac> oops
09:07:37 <tac> :t Right
09:07:38 <lambdabot> forall a b. b -> Either a b
09:07:43 <tac> wait
09:07:51 <tac> :k Either
09:07:53 <lambdabot> * -> * -> *
09:08:04 <tac> hmm
09:08:04 <Jafet> ocharles: data j (a :: * -> *)
09:08:10 <tac> I'm gonna stop thinking today
09:08:15 <ocharles> Jafet: sure
09:08:18 <ocharles> so a can't be any kind
09:08:19 <simpson> J could be a type alias for something with kind * -> * -> * too, couldn't it?
09:08:40 <Jafet> data j (a :: **)
09:08:44 <ocharles> oh
09:08:45 <Jafet> if that is legal
09:08:57 <merijn> Jafet: You can do that using PolyKinds
09:09:03 <Jafet> GHC 7.8, now with muffled expletives
09:10:06 <dmwit> four levels ought to be enough for any type system
09:10:30 <ocharles> heh
09:10:38 <edwardk> 640k ought to be enough for anybody
09:11:00 <simpson> Isn't it just values, types, kinds, and a single sort?
09:11:09 <simpson> Do we *need* more?
09:11:11 <fryguybob> rwbarton: moar s t a b
09:11:17 <edwardk> just give in and use * :: *
09:11:20 <dmwit> The "improved" Moore's law: type systems grow twice as many levels every three decades.
09:11:53 <dmwit> simpson: Isn't it just values, types, and a single kind? Do we *need* more?
09:12:23 <dmwit> Or hell, let's talk Scheme: isn't it just values and a single type? Do we *need* more?
09:12:25 <edwardk> dmwit: i think its more about programmers. programmers learn how to effectively leverage another sort in their type hierarchy each decade. less exponential, but probably more accurate
09:12:36 <Jafet> Clearly we need kind omega
09:12:36 <shergill> just get onto programming in coq. write your proof, and then extract your program in haskell/ocaml
09:12:37 <simpson> dmwit: Hey, I'm a Python guy; I'm happy with my single unified type and object. :3
09:12:38 <Jafet> etc.
09:12:40 <shergill> *on to
09:13:49 <ocharles> I think Coq might be the only language where sloccount's estimated 'cost' is actually correct
09:14:03 <ocharles> 5 lines of code, estimated cost $50,000. Sounds about right for the amount of wizardry it takes
09:14:17 <copumpkin> nah, grad students are cheap labor
09:14:19 <edwardk> ocharles: but i like producing 100s of millions of dollars worth of code each year
09:14:39 <ocharles> edwardk: :) I apparently need to invoice $25k for these 1000 lines I wrote. not bad.
09:14:46 <edwardk> makes me feel underpaid
09:15:00 <copumpkin> poor edwardk
09:15:03 <ocharles> edwardk: oh, can I steal you to talk lenses now that you've popped up?
09:15:10 <edwardk> sure
09:15:11 <merijn> dmwit: Racket has a typed scheme implementation...
09:15:13 <dmwit> edwardk: P.S. vouching for my HTML skills -- appreciated, but confusing
09:15:24 <copumpkin> dmwit: you have excellent HTML skills
09:15:31 <copumpkin> I've seen your mouth open and close
09:15:38 <dmwit> hahaha
09:15:45 <edwardk> i'm stuck on an ipad, since i'm transferring stuff to my new laptop, so i'll suck with hpastes
09:15:46 <copumpkin> if I could get to the web
09:15:51 <copumpkin> I'd add you to linkedin and endorse you
09:15:59 <copumpkin> luckily, my web is down
09:16:00 <merijn> Man...I need to add more haskell people on linkedin and spam them until they vouch for my haskell skill >.>
09:16:05 <copumpkin> (I need better HTML skills)
09:16:15 <ocharles> edwardk: I couldn't get what I wanted out of projections. It seems to be that projections are for sort of working 'inside' the projection, but never escaping it? For example, in Aeson.hs the aeson.both +~ 2 still produces a ByteString
09:16:16 <copumpkin> merijn: you could be a Functional Support guy ;)
09:16:31 <copumpkin> edwardk: how sweet is it, on a scale from 1-11?
09:16:39 <edwardk> dmwit: it pops up a block of 4. i try to filter it down to unembarassing skills. apparently i screwed upmand HTML'd you :)
09:16:42 <ocharles> I was hoping for something would let me go from FromJSON -> ByteString and ByteString -> Maybe (ToJSON), or something
09:17:09 <edwardk> copumpkin: well i got to run it for about 5 minutes before i started migration assistant
09:17:16 <dmwit> edwardk: heh, I didn't realize it was a UI puzzle
09:17:49 <ocharles> (I'm actually working with MBID -> String and String -> Maybe MBID)
09:18:12 <edwardk> ocharles: foo^.by yourProjection
09:18:16 <ocharles> somehow I managed to generate MBID -> String and String -> MBID from that projection, which is certainly not correct, unless a projection can magically force people to only provide valid input :)
09:18:31 <ocharles> edwardk: sure, that goes one direction. what about the other?
09:18:35 <edwardk> and ^? is also convenient
09:18:36 <ocharles> or does that work both ways?
09:18:45 <ocharles> to ghci!
09:18:49 <edwardk> by flips it around
09:20:40 <edwardk> copumpkin: i get to play musical computers. upgrading mine, putting amy's stuff in my old computer, and shipping her old one out to michigan to get my mother finally off of a pc ;)
09:20:51 <copumpkin> :)
09:20:57 <edwardk> sounds like a riveting day
09:20:57 <copumpkin> sounds like a blast
09:20:59 <copumpkin> yeah
09:21:46 <edwardk> foo^?aeson would try to extract it giving a Maybe.
09:22:09 <edwardk> bar^.by aeson would inject it
09:22:13 <ocharles> and what happens if I don't use ^? and the projection generates a Nothing?
09:22:27 <ocharles> so foo^.aeson when foo is not valid json?
09:22:40 <edwardk> try to type check it. ;)
09:22:51 <edwardk> it'll complain unless the target is a monoid then
09:22:55 <edwardk> and it
09:23:06 <edwardk> will use the mempty if it fails
09:23:13 <ocharles> ahhh
09:23:17 <ocharles> I definitely saw that when I was playing with this
09:23:26 <ocharles> it must have been because I didn't use ^?
09:23:26 <edwardk> magically doing the only thing that makes sense
09:23:33 <ocharles> ^? was probably the operator I wanted
09:23:44 <ocharles> I got the 'by' stuff working ok, I just couldn't get back the other direction :)
09:24:30 <edwardk> yeah. a lot of stuff uses a traversal for optional fields, so ^? was addeed to give you something prettier than headOf.
09:24:48 <edwardk> you can use ^.. when you have multiple targets
09:25:10 * ocharles commits these operators to his growing internal lens operator lookup map
09:25:36 <edwardk> its a big vocabulary to learn i admit
09:25:45 * hackagebot sendfile 0.7.8 - A portable sendfile library  http://hackage.haskell.org/package/sendfile-0.7.8 (JeremyShaw)
09:26:00 <ocharles> it's not so bad, a lot of the operators I have no need for (like the state-aware stuff)
09:26:07 <ocharles> so it's more a case of knowing what you're looking for
09:26:19 <edwardk> and the state stuff fits the pattern of the other stuff
09:26:26 <ocharles> right
09:26:28 <edwardk> just swap ~ to =
09:29:09 <ocharles> "10adbe5e-a2c0-4bf3-8249-2b4cbf6e6ca8"^?mbid
09:29:10 <ocharles> Just (MBID 10adbe5e-a2c0-4bf3-8249-2b4cbf6e6ca8)
09:29:11 <ocharles> woohoo!
09:29:16 <ocharles> thanks :)
09:29:25 <edwardk> =)
09:29:37 <copumpkin> everyone is lensing
09:29:54 <edwardk> oppa lensman style
09:30:03 <ocharles> though '("10adbe5e-a2c0-4bf3-8249-2b4cbf6e6ca8"^?mbid)^.by mbid' doesn't work, probably because of the forall a in 'forall a. SimpleProjection String (MBID a)'
09:30:06 * copumpkin cries
09:30:11 <ocharles> oh wait
09:30:17 <ocharles> it's because of the Maybe MBID that's returned
09:30:45 <edwardk> ^?mbid gives you a maybe. so .traverse it then inject it
09:30:52 <ocharles> right
09:31:17 <ocharles> ("10adbe5e-a2c0-4bf3-8249-2b4cbf6e6ca8"^?mbid)^.traverse.by mbid == "10adbe5e-a2c0-4bf3-8249-2b4cbf6e6ca8". perfect.
09:31:23 <edwardk> smth like ^?mbid.traverse.by mbid
09:32:14 * ocharles happily adds 'lens' to 'Build-Depends' and gets back to work
09:32:21 <edwardk> :)
09:35:57 <jakubmal> hi guys, how would you implement bind for ConsT ?
09:39:07 <qasi> Leider find ich keine sourcen von date, dann könnte ich wenigstens rausfinden, was für Argumente es denn jetzt so akzeptieren würde :/
09:40:57 <qasi> sorry, wrong window
09:41:56 <qasi> (In case you're wondering, I am actually talking about a XENIX system from 1986... no kidding. It runs on 8086 CPUs.)
09:43:40 <geekosaur> mmm, altos 586/986
09:45:58 <Radox1> Hello
09:46:51 <ocharles> hi there!
09:47:20 <Radox1> I was wondering if anyone could help me with what I presume is a fairly trivial question.
09:47:45 <ocharles> is that the trivial question?
09:47:49 <ocharles> if so, 'yes'
09:48:15 <simpson> ocharles: Can't be a question; it didn't end with a question mark and didn't have any inquiring words. :3
09:48:49 <merijn> ocharles: That was more of a statement, tbh
09:48:57 <merijn> He just observed that he was wondering
09:49:09 <ocharles> Radox1: you should probably just go ahead and ask your question :)
09:49:10 <Radox1> I have a list of statements which I need to execute. I have an executeStatment function which takes a statement and a list of tuples. It modifies the  list of tuples based on the statment and then returns this modified list of tupes
09:49:12 <simpson> At any rate, don't ask to ask; just ask.
09:50:18 <Radox1> SO I wam wanting to build a function which can execute all of these statements one by one giving the next one in the list it's return value
09:50:45 <merijn> Radox1: Sounds like you want the State monad
09:50:47 <Radox1> I was hopping I could somehow use the map function? If not should I build my own recursive method?
09:50:48 <simpson> Radox1: Kind of like sequence?
09:51:00 <simpson> Radox1: Could you show us some of your code?
09:51:04 <Radox1> Yeah sure
09:51:06 <merijn> Radox1: You can't do that using map, no
09:51:18 <merijn> Radox1: Because map can't give the result of one iteration to the next
09:51:20 <Radox1> My executeStatement is of type
09:51:21 <Radox1> executeStatement :: Stmt -> Env -> Env
09:51:24 <merijn> Radox1: A fold could work
09:51:35 <merijn> :t foldl
09:51:37 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:51:48 <merijn> :t foldr
09:51:49 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:51:51 <Radox1> A statement can be any of the following
09:51:52 <Radox1> data Stmt   = Begin [Stmt] -- contains a list of declarations AND a list of statements   | Assign Var IntExp    | Read Var   | Write IntExp   | IfThenElse BoolExp Stmt Stmt   | While BoolExp Stmt   deriving (Read, Show)
09:52:07 <merijn> Radox1: Please use hpaste for code bits more than 1 or 2 lines :)
09:52:32 <Radox1> So if I see a Begin [stmt] I need to execute them all in turn passing each the previous return value.
09:52:48 <ocharles> is there a easy way to find out what top levels don't have haddock documentation? `cabal haddock` says '94% ( 30 / 32) in 'MusicBrainz.Types'' but I'm hardly going to wade through all 32 tlds to try and find what I missed...
09:53:22 <merijn> Radox1: You either want to make it a fold or use State
09:54:41 <Radox1> I would rather avoid state for now if at all possible. Any good examples of fold knocking around?
09:55:01 <Craig> Hi, I am trying to use the System.plugins.load module to dynamically compile, load and run a function from another file called "SimpleGraphics.hs", but am stuck on how to proceed. I have the following file which I am loading into ghci: http://pastebin.com/92WwGAMh . What command do I now need to run to execute the main function from SimpleGraphics.hs?
09:55:05 <mauke> The paste 92WwGAMh has been copied to http://hpaste.org/77073
09:55:17 <ocharles> Radox1: if you write out how you expect code to run for a list of no elements, then one element, then 2 elements, you should naturally see yourself writing the fold
09:55:30 <ocharles> that can be one way to identify a fold anyway
09:55:47 <ski> > foldl f 0 [2,3,5,7] :: Expr
09:55:48 <lambdabot>   f (f (f (f 0 2) 3) 5) 7
09:55:56 <ski> > foldl (flip f) 0 [2,3,5,7] :: Expr
09:55:58 <lambdabot>   f 7 (f 5 (f 3 (f 2 0)))
09:56:38 <Radox1> @ski thank you
09:56:39 <lambdabot> Maybe you meant: ask src wiki
09:56:51 <Radox1> That seems exactly what I need
09:57:33 <ski> yw
09:57:50 <merijn> Radox1: "I would rather avoid state for now" <- why?
09:57:56 <rwbarton> Craig: I guess that on line 11, v *is* the main function from that other file.
09:58:05 <rwbarton> so you just use it the way you would use main
09:58:22 <ski> Radox1 : IRC custom is to start the message by the nick in question, and follow it by e.g. `:' or `,' -- please don't prefix with `@'
09:58:47 <Radox1> merijn. I have just started learning Haskell so have barely touched Monads yet. I have wrote a large proportion of the program passing around the state. So it would be a fairly big re-write
09:58:50 <edwardk> @botsnack
09:58:50 <lambdabot> :)
09:59:09 <rwbarton> Craig: i.e. by putting v in a do block, or whatever
09:59:34 <botsnack> what is wrong with prefixing with @? :)
09:59:47 <ski> @slap botsnack
09:59:47 * lambdabot smashes a lamp on botsnack's head
10:00:18 <ski> > foldl (\s n -> concat ["(",s," + ",show n,")"]) "0" [2,3,5,7]  -- Radox1, another example of using `foldl'
10:00:20 <lambdabot>   "((((0 + 2) + 3) + 5) + 7)"
10:00:22 <Craig> rwbarton: What I have tried is to run the command exampleMake in ghci followed by main <- exampleLoad. Then If I type main I just get the output ()
10:00:45 <Craig> whereas what I should get is a graphics window appearing with various shapes on it etc.
10:00:50 * hackagebot unlambda 0.1.3 - Unlambda interpreter  http://hackage.haskell.org/package/unlambda-0.1.3 (GwernBranwen)
10:00:51 <rwbarton> Craig, add more type signatures
10:01:44 <rwbarton> actually your exampleLoad cannot type check correctly
10:02:22 <rwbarton> add "exampleLoad :: IO (IO ())" and delete the LoadFailure line or change print to error or something
10:02:25 <rwbarton> then try again
10:03:13 <Radox1> ski : if I want the function to take the return value from the previous fold as the second argument rather than as the first how can I do that?
10:03:46 <nejucomo> Radox1: flip
10:03:46 <ski> Radox1 : `flip' is one way
10:04:05 <nejucomo> Or you can use a different fold, but they have different performance characteristics.
10:04:21 <Craig> rwbarton: Out of interest, what is this type signature conveying?
10:04:23 <ski> .. or you can use a lambda expression
10:04:56 <Craig> that it returns an IO value which has as output another IO value? Im rather new to haskell's ways
10:05:01 <rwbarton> yes
10:05:01 <ski> Craig : `exampleLoad' is an I/O-action that when executed will yield an I/O-action that when executed will yield a value of type `()'
10:06:14 <rwbarton> the latter action being main from SimpleGraphics.hs
10:06:43 <Craig> ah, kk
10:07:20 <Craig> and the fact that I left out the type signature meant that haskell was not interpreting the function as such. Rather, it was simply making educated guesses at the return type?
10:07:34 <rwbarton> well, it "knew"
10:07:36 <rwbarton> because of the print
10:08:10 <rwbarton> print msg is an IO action with result of type (), so return v also has to be an IO action with result of type ()
10:08:16 <rwbarton> that's why when you tried to run "main" you saw ()
10:08:30 <rwbarton> I guess there is no type safety with this plugin stuff
10:11:30 <rwbarton> that is, it trusts you to use the result of load at the actual type of the symbol you loaded
10:12:04 <Craig> ok
10:12:21 <Craig> btw, It works as I intended it to when I implement the changes you suggested
10:12:41 <Craig> it also has similar functionality if I just replace "return" with "do"
10:12:57 <rwbarton> then exampleLoad will run main right away
10:13:03 <Craig> yea
10:13:05 <rwbarton> btw you don't need the "do", you can just delete it
10:13:06 <rwbarton> do x = x
10:13:19 <Craig> ah
10:13:24 <Craig> well thats useful to know
10:13:32 <Craig> thanks for the help :D
10:13:39 <johnw> rwbarton: what is do x = x?
10:13:50 <rwbarton> an equation
10:13:55 <johnw> oh
10:13:58 <johnw> you aren't writing haskell
10:14:23 <johnw> do x ≡ x
10:14:40 <rwbarton> = is too useful a symbol to restrict to Haskell meaning
10:15:26 <bitonic> is there a consensus on alpha-renaming vs. de Bruijn?  it seems that most people use alpha renaming when evaluating terms in type checkers
10:15:26 <lambdabot> bitonic: You have 1 new message. '/msg lambdabot @messages' to read it.
10:16:00 <edwardk> bitonic check out bound on hackage. in particular the examples
10:16:36 <bitonic> edwardk: thanks!
10:16:41 <fruitFly> ho do you make a block in haskell? { }? Or do you just line code up, I remember reading something about that (maybe only for gaurds)
10:16:43 * ski doesn't like it when people use `==' to express that two Haskell expressions will have the same value
10:16:51 <bitonic> ivanm: no, I didn't notice, what's wrong?
10:16:58 <bitonic> I didn't really look at existing packages before
10:17:13 <ski> fruitFly : perhaps you mean a `do'-expression ?
10:17:29 <edwardk> i started using then triple-equal unicode symbol in my haddocks to denote equality
10:17:30 <fruitFly> ski: I think so
10:17:40 <ski> edwardk :(
10:18:22 <edwardk> the = is too dangerous. could be a definition with arguments, etc.
10:18:27 <fruitFly> so you create a block with just { }
10:18:39 <josephle> edwardk: do you intend for it to be the same semantics as Agda's propositional equality?
10:18:45 <ski> edwardk : context
10:22:56 <ocharles> so I'm working on some code that needs to do a 3 way merge of arbitrary data structures, with the ability to do different merge strategies depending on the type being merged, and also see which fields are in conflict
10:23:31 <ocharles> so data Artist = Artist { artistName :: Text, artistAlbums :: Set Album } would use equality to merge the artistName, but a set merge for artistAlbums
10:24:56 <ocharles> I'm not quite sure how to go about implementing this though. I've previously done this with a Mergable type class, and a Merge functor, so I can: merge :: Mergeable a => a -> a -> a -> Merge a and runMerge :: Merge a -> Either [Conflict] a. Does this seem sensible? Is there any other prior art I can steal/be inspired by?
10:25:23 <ocharles> mostly the annoying thing above is being able to identify what is in conflict - I have to label every field I'm merging with some sort of 'path'
10:28:50 <rwbarton> how about @f x@ = @f (-x)@? i suppose that runs a high risk of being indistinguishable (or nearly so) from @f x = f (-x)@, but I like it in theory
10:28:54 <johnw> edwardk: i found a definition in my book on sets: D = { X `elem` P(E) : X' `elem` C }, where C is a collection of the subsets in E.  What is "D" typically called?
10:29:11 <johnw> s/the subsets in E/subsets in E
10:30:18 <johnw> is it something like the "complementary of subsets of the powerset"?
10:30:28 <rwbarton> I was about to ask, what is "X'"
10:30:34 <johnw> rwbarton: you probably know the answer to this too
10:31:03 <johnw> X' = all E except X
10:31:09 <johnw> E - X
10:31:46 <rwbarton> so D is the set of complements (in E) of things in C
10:31:51 <rwbarton> don't know a name or notation for it
10:31:52 <johnw> yes
10:32:00 <johnw> the book introduced it like it was something noteworthy
10:32:06 <rwbarton> hm
10:32:08 <johnw> but then said nothing about it's name, use, or why it was presented
10:32:40 <johnw> it used a cursive D to represent it, thought that might be a clue
10:32:49 <johnw> like, "the inverse power subset" :)
10:32:58 <johnw> ok, I'll just skip past it for now
10:33:12 <edwardk> ski: foo bar = baz. -- is that the body of the definition of foo, e.g. pattern matching on a variable bar that you don't use or a statement of a law that when you apply foo to bar the result is baz
10:33:33 <johnw> aka, foo = const baz
10:33:58 <Radox1> ski : I have another problem; a runtime error.
10:33:59 <edwardk> in the lens docs i try to always write definitions with =, and state laws with triple-equal
10:34:05 <Radox1> hpaste executeListOfStatements :: [Stmt] -> Env ->Env executeListOfStatements [] env = env executeListOfStatements (x:xs) env = executeListOfStatements xs (executeStatement x env)
10:34:17 <clahey> How do you write triple equal in binary?
10:34:32 <Radox1> *** Exception: parserInterp.hs:(259,1)-(281,46): Non-exhaustive patterns in function executeStatement
10:34:42 <ski> edwardk : context will tell
10:34:52 <edwardk> i hit ctrl-k =3 in vim :)
10:35:14 <Radox1> I understand that it means my recursive function is not matching all cases. But why?
10:35:14 <edwardk> ski it can, but then i have to disambiguate with surrounding language
10:35:26 <rwbarton> edwardk: and it doesn't produce this? http://www.fileformat.info/info/unicode/char/1f63b/index.htm
10:35:27 <clahey> Did I really say that?
10:35:32 <clahey> How do you write triple equal in ascii?
10:35:38 <clahey> ===?
10:35:56 <edwardk> rwbarton: hahahaha
10:37:02 <clahey> Radox1: That's the definition for executeListOfStatements, but it says the problem is in function executeStatement.
10:37:12 <ski> edwardk : i dislike using a different symbol since that suggests that it's somehow that symbol that makes it a definition (and also that it means something different from equality -- cf. people distinguishing between "equality" and "identity")
10:37:22 <johnw> clahey: you mean ≡?
10:38:07 <clahey> johnw: Yeah.
10:38:19 <edwardk> well, i had a couple of questions from users who misunderstood the old ='s in different directions, so i gave up and made it dinternally consistent
10:38:41 <killy9999> I get a seemingly random segfault - how can I approach debugging such a thing?
10:38:41 <edwardk> johnw: thats the symbol
10:38:46 <Ralith> Radox1: you should use a fold there
10:39:14 <Ralith> explicit recursion should be avoided when a standard pattern will suffice
10:39:33 <johnw> {
10:39:37 <johnw> ≡
10:39:43 <edwardk> ralith: i tend to actually just write the explicit recursion if its clearer
10:39:48 <johnw> heh, i just installed apl-ascii for Emacs
10:39:59 <edwardk> but its good practice to know how to spot the patterns
10:40:07 <Ralith> edwardk: under what circumstances do you find it to be clearer?
10:40:37 <ski> Ralith : e.g. when the recursive pattern isn't hidden under a ton of intervening code
10:40:39 <edwardk> when the function i pass to foldr or whatever does case analysis, generally
10:40:59 <Ralith> ah, yes
10:41:15 <Ralith> that does come out a lot cleaner then doesn't it
10:41:16 <johnw> f ∘ g
10:41:34 <Radox1> I was trying to understand how fold works and also if I used fold I would need to use flip to change the arguments around
10:41:50 <Ralith> :t foldl
10:41:50 <yitz> killy9999: switch to haskell ;)
10:41:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
10:41:52 <Ralith> :t foldr
10:41:53 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:41:57 <johnw> Radox1: you can always use lambdas with any fold
10:42:13 <ski> Radox1 : .. alternatively change the order of the argument in the definition of the function -- or use lambda-expressions
10:42:16 <`Jake`> does the forall actually do anything there?
10:42:26 <Ralith> it makes explicit what is usually implicit
10:42:49 <killy9999> yutz: the problem is I get it in Haskell
10:42:49 <`Jake`> ok
10:42:50 <Radox1> I guess changing the order of the arguments is one way :)
10:42:52 <ski> `Jake` : it's allowed to omit it in a type signature when it occurs just after `::', if that's what you mean
10:42:54 <edwardk> jake in that case, no.
10:42:55 <killy9999> yitz: ^^^
10:43:04 <yitz> killy9999: please tell us more about your segfault
10:43:06 <Radox1> Still before I use fold I would like to know why my fold function does not work :(
10:43:09 <killy9999> sure
10:43:19 <killy9999> It's a testing binary
10:43:30 <killy9999> it runs QC and HUnit tests
10:43:33 <lispy> I guess cale was able to get lambdabot working again
10:43:33 <lambdabot> lispy: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:43:36 <Ralith> Radox1: a good way to debug that sort of thing is to add a final case:
10:43:47 <`Jake`> @type (/x -> [x])
10:43:47 <Ralith> myFunc x = error ("Unhandled case: " ++ show x)
10:43:48 <lambdabot> parse error on input `->'
10:43:54 <killy9999> all put together with test-franework
10:43:55 <`Jake`> @type (\x -> [x])
10:43:56 <lambdabot> forall t. t -> [t]
10:44:08 <killy9999> sometimess all tests run, sometimes the binary segfaults at some point
10:44:10 <edwardk> now if he can only get her upgraded to 7.4
10:44:29 <lispy> @tell ivanm I'm not sure without seeing more code. I guess it depends on life span of data.
10:44:29 <lambdabot> Consider it noted.
10:44:44 <edwardk> then the lens revolution can begin its next phase!
10:44:55 <lispy> edwardk: well, that's why I rebooted the machine. I had to upgrade my kernel to be able to build or run 7.4+
10:45:03 <edwardk> woot!
10:45:17 <Ralith> Radox1: since there are no patterns, it catches any otherwise unmatched arguments, and the show tells you what precisely was not matched.
10:45:20 <lispy> In the process I learned that upgrading a kernel on a linode is as easy as changing the machine config in the linode UI
10:45:46 <edwardk> brutal
10:46:17 <Radox1> Ralith : is there a way to see what was not matched?
10:46:23 <ski> Radox1 : as clahey said, the error says that the problem is in `executeStatement', not in `executeListOfStatements'
10:46:33 <GeneralButtnaked> 4 way handshake for releasing connection. I send FIN and get ACK and then Im down. Then the other guy sends FIN but how can I ACK if Im terminated?
10:46:34 <Ralith> Radox1: I just provided an example--but listen to ski.
10:46:40 <thoughtpolice> lispy: oh wow, never noticed that!
10:46:52 <yitz> killy9999: it is very unlikely that the testing libraries themselves will cause a segfault themselves. it all depends on what they are testing.
10:46:56 <edwardk> afk a bit
10:47:06 <Radox1> Ah
10:47:10 <lispy> thoughtpolice: yeah, I always wondered why the kernel upgrade wasn't present in apt.
10:47:10 <Radox1> I missed that bit of the error
10:47:13 <Radox1> Thank you
10:47:15 <yitz> killy9999: there is probably some library around using ffi, or unsafe functions. you have to find out about that.
10:47:16 <ski> Radox1 : have you provided the code of `executeListOfStatements' (and the definition of `Stmt') somewhere ?
10:47:29 <killy9999> yitz: probably yes
10:47:33 <lispy> thoughtpolice: I still managed to do the wrong thing and install a kernel package, but now I'm booting one of their blessed kernels, so I guess it doesn't matter
10:47:58 <lispy> thoughtpolice: I think it has to do with needing to turn on the paravirt flags to build a working xen kernel.
10:48:02 <killy9999> I'm trying to find the test that might be causing this
10:48:06 <lispy> otherwise I don't know why they would do this
10:48:26 <`Jake`> GeneralButtnaked: client sends fin, server sends ack, server sends fin, client sends ack, server terminates, client waits to see if server sends fin again, client terminated after a certain time
10:49:29 <yitz> killy9999: or maybe it's just that some dlls got changed/upgraded on your system. the usual kind of stuff that can segfault independently of your program.
10:49:51 <yitz> killy9999: yeah, good idea. selectively disable tests. how many are there?
10:50:26 <killy9999> yitz: about 50 or so, but divided into groups
10:50:39 <killy9999> I guess I managed to locate the code that is causing this
10:50:59 <yitz> killy9999: ok sounds doable. except the intermittent part is going to make it take more time. annoying.
10:51:06 <yitz> killy9999: oh, good.
10:51:13 <thoughtpolice> lispy: hopefully that'll go away soon-ish, modern linux has full xen dom0/domU support built into the kernels now
10:51:25 <thoughtpolice> as opposed to it being a special patchset. they may have blessed kernels for other reasons, though
10:52:17 <thoughtpolice> lispy: but on fedora for example, you can just 'yum install xen' and reboot and just boot your dom0, and then boot the same kernel as domU, pretty much untouched, and you're done
10:52:36 <yitz> killy9999: well, your unit tests weren't *quite* as helpful as they could have been, but they did alert you to the problem.
10:53:12 <killy9999> yitz: I guess I shot myself in the foot
10:53:41 <killy9999> I have some code that performs destructive initialization of a vector using unsafeWrite
10:54:00 <yitz> killy9999: naughty naughty
10:54:00 <hpaste> AgentM pasted “Existential Equality Failure” at http://hpaste.org/77074
10:54:08 <killy9999> I tested it using safe functions, switched to unsafe ones when everytheing was OK and THEN I did refactoring
10:54:30 <yitz> killy9999: oh what a tangled web we weave...
10:54:47 <Radox1> Hmm it seems that if I call executeListOfStatments with a list containing one statement is works but if I call it with two (identical) statements it doesn't
10:54:56 <ski> AgentM : doesn't work
10:55:00 <AgentM> Sorry- first time poster here. I don't understand the compiler error.
10:55:24 <ski> AgentM : consider `foo :: IM.IntMap Int' and `bar :: IM.IntMap String'
10:55:37 <Radox1> executeStatement (Begin [(Write (IVar "a"))]) env WORKS
10:55:42 <Radox1> executeStatement (Begin [(Write (IVar "a")), (Write (IVar "a"))]) env Does not Work
10:55:48 <ski> AgentM : then `Tuple foo :: Tuple' and `Tuple bar :: Tuple'
10:56:18 <killy9999> yitz: It's actually possible that I generated test data that this function shouldn't receive :)
10:56:34 <ski> AgentM : so, given two values of type `Tuple', the "internal" `a' type hiding inside one value (`Int' above) need not be the same type as the one hiding inside the other value (`String') above
10:56:49 <GeneralButtnaked> `Jake`: why would it wait for another FIN?
10:57:13 <AgentM> ski: I assumed if they both adhere to "Eq", then the process should be clear, no?
10:57:14 <ski> AgentM : so, you only know `m1 :: IM.IntMap x' and `m2 :: IM.IntMap y' for some unknown types `x' and `y'
10:57:25 <`Jake`> GeneralButtnaked: If the server doesn't receive the ack, then it will send the fin again
10:57:32 <ski> AgentM : you *don't* know that the type `x' is the same as the type `y' -- and in general, they'll be different
10:57:40 <AgentM> ski: but all the types must adhere to "Eq", no?
10:57:42 <`Jake`> GeneralButtnaked: To make sure the client has received it
10:57:55 <lispy> thoughtpolice: Ah yeah. That is nice. I bet you're right that they did it this way before that was common.
10:57:57 <AgentM> Oh- I see- one could compare two different types via equality.
10:58:06 <`Jake`> GeneralButtnaked: http://en.wikipedia.org/w/index.php?title=File:TCP_CLOSE.svg&page=1
10:58:15 <ski> AgentM : yes, but if a type `Blah' is in `Eq', that only means it knows how to compare two values, *both* of type `Blah', to each other
10:58:30 <thoughtpolice> lispy: yeah, although there's no reason to fix what isn't broken in their UI, i actually kind of like it.
10:58:37 <AgentM> ski: So I will probably need to use Data.Typeable, then. Thanks for the help.
10:58:46 <lispy> thoughtpolice: right. it makes it super easy for me.
10:58:50 <ski> AgentM : at this point, the relevant question would be : what are you *really* trying to achieve, here ?
10:58:51 <thoughtpolice> and it means you can't accidentally hurt yourself, too
10:59:00 <nyc> `Jake`: Liberian warlords aren't on-topic.
10:59:17 <ski> `Typeable' might be a way -- but depending on what you want, there might be a simpler and better way
10:59:41 <killy9999> yitz: yup, I allowed QC to generate Int, while my function can accpet only positive values :)
11:00:06 <`Jake`> nyc: Well, the warlord was summoned to answer a question
11:00:54 * hackagebot hashable-generics 1.1 - Automatically generates Hashable instances with GHC.Generics.  http://hackage.haskell.org/package/hashable-generics-1.1 (ClarkGaebel)
11:01:47 <joevar> How do I understand the importance of monad transformers?
11:01:50 <`Jake`> <- dinner
11:02:36 <AgentM> ski: I am trying to create a tuple type for use in relational algebra. I want to create an "Atom" type which can be any type stored in a relational tuple. The IntMap represents the attribute id to atom mapping. I created a type class synonym and encountered this error, which you clarified. So, I need to check first if the types themselves are equal, no?
11:03:56 <Radox1> Ski : can you help?
11:05:54 * hackagebot hashable-generics 1.1.1 - Automatically generates Hashable instances with GHC.Generics.  http://hackage.haskell.org/package/hashable-generics-1.1.1 (ClarkGaebel)
11:07:07 <johnw> joevar: can you ask in a different way?
11:07:15 <lispy> joevar: monad transformers basically encodes many things that other languages would call design patterns. Want to add state to something? use StateT. Need logging? Add WriterT. Need controlled error handling? ErrorT. etc.
11:07:17 <johnw> i'm not sure how *you* would understand them
11:07:38 <johnw> lispy: you mean, "Need X in addition to monad Y?"
11:07:50 <lispy> johnw: sure, but Y could be Id, right?
11:07:52 <joevar> johnw, lispy. So monad transformers are builtin
11:08:02 <joevar> Opps. didnt' finish
11:08:09 <johnw> yes, but the way you described it sounded as thought transformers "just give you logging", or some such
11:08:19 <joevar> johnw, lispy. So monad transformers are just builtin design patterns?
11:08:30 <johnw> they transform another monad to enrich its capabilities
11:08:39 <lispy> johnw: oh I see. Yeah, what I mean is that they add specific capabilities to another monad
11:08:51 <johnw> joevar: they are not "builtin" in the sense that other languages have builtin features
11:09:15 <johnw> transformers is just another library providing you with types and functinos
11:09:38 <lispy> joevar: I have a paper that you might like: http://www.grabmueller.de/martin/www/pub/Transformers.pdf
11:09:57 <lispy> joevar: that's the paper that helped me see the value of them
11:10:36 <joevar> I'm following along this page: http://www.haskell.org/haskellwiki/Typeclassopedia . thanks lispy and johnw.
11:10:46 <lispy> joevar: also worth noting, often you will see monad transformers used with newtypes and the GeneralizedDeriving extension
11:11:15 <lispy> GeneralizedNewtypeDeriving? /me can't recall how to spell every extension :)
11:11:42 <joevar> err.. Okay.
11:11:47 <lispy> doing this allows you to not expose the fact that your monad is constructed as a transformer stack
11:14:35 <ocharles> is there a way to do 'prefixed' RecordWildCards?
11:15:10 <joevar> lispy, I'll read the pdf. Although, I'll probably come back. Thanks.
11:15:11 <ocharles> I have a 'a b :: Artist -> Artist -> ...`, and need all fields of both a and b
11:15:54 * hackagebot hashable-generics 1.1.2 - Automatically generates Hashable instances with GHC.Generics.  http://hackage.haskell.org/package/hashable-generics-1.1.2 (ClarkGaebel)
11:16:39 * ski notes AgentM leaves shortly before ski noticed the question
11:17:49 <ski> Radox1 : i still haven't seen your code for `executeStatement', nor the definition of `Stmt'
11:27:27 <Radox1> Anyone still active?
11:27:40 <Sculptor> everyone looks passive to me
11:27:54 <johnw> i am in a flux state
11:28:07 <Radox1> :)
11:28:32 <Radox1> Still having issues with the following
11:28:34 <Radox1> executeStatement env (Begin [(Assign "ben" (ICon 10)),(Assign "ben" (ICon 11))  ])
11:28:44 <Radox1> If I make the list of size one. It runs
11:29:07 <Radox1> Non-exhaustive patterns in function executeStatement
11:29:08 <Radox1> Any more than one statement in the list and
11:29:43 <clahey> Radox1: Why don't you paste your code to hpaste?  We can't tell you what's up with your definition of executeStatement if we can't see it.
11:30:07 <Radox1> Sorry how do I do that
11:30:12 <ski> @where hpaste
11:30:12 <lambdabot> http://hpaste.org/
11:30:21 <ski> use that link in a web browser
11:30:55 <hpaste> Radox1 pasted “Statement” at http://hpaste.org/77077
11:31:02 <Radox1> Thanks
11:31:36 <ski> Radox1 : replace `[stmt]' with `stmts'
11:32:06 <bxx> is there no fold function in haskell, just foldl and foldr?
11:32:20 <ski> you can define `fold', if you like
11:32:24 <tac> bxx: what would fold do that one of foldl and foldr does not?
11:32:44 <bxx> I have some code snippet that uses fold, must be a typo
11:32:52 <ski>   fold :: Functor f => (f r -> r) -> (Mu f -> r)  -- would be one possibility
11:33:17 <bxx> if either will do should I prefer one over the other? IIRC one is more efficient
11:33:17 <ski> @src Mu
11:33:18 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
11:33:38 <bxx> foldl I guess? since it can work on list in sequence
11:33:41 <ski> bxx : `foldr' for when you want it to work on infinite lists
11:34:05 <bxx> okay. thought that would be foldl
11:34:21 <Radox1> ski : Thanks very much!
11:34:28 <ski> bxx : for when you want to summarize information into a "small" thing, like a number : foldl'
11:34:29 <Radox1> I guess I was getting types messed up with variables!
11:34:44 <ski> Radox1 : instead of `do', you want `let'
11:35:05 <ski>   let newEnv = executeStatement env stmt
11:35:05 <ski>    in executeStatement env (While boolExp stmt)
11:35:12 <bxx> foldl (-) 100 [1,2,3] does (100 - 1 - 2 -3) right?
11:35:35 <Radox1> Ok. Please could you try to explain why
11:35:36 <ski> > foldl (-) 100 [1,2,3] :: Expr
11:35:37 <lambdabot>   100 - 1 - 2 - 3
11:35:40 <bxx> why can't that work on infinite lists?
11:35:49 <ski> because `foldl' is tail-recursive
11:36:06 <ski> > foldl f 100 [1,2,3,4,5,6,7,8,9] :: Expr
11:36:07 <lambdabot>   f (f (f (f (f (f (f (f (f 100 1) 2) 3) 4) 5) 6) 7) 8) 9
11:36:19 <`Jake`> > foldr f 100 [1,2,3,4,5,6,7,8,9] :: Expr
11:36:20 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 100))))))))
11:36:24 <bxx> if it wasn't implemented as tail recursive it could work on infinite lists?
11:36:32 <ski> for an infinite list, the `f 100 1' would occur at the "innermost" of an infinite computation
11:36:42 <copumpkin> bxx: it can't do anything useful before it gets to "the end"
11:36:43 <ski> it would never "get to the outside"
11:36:43 <Eduard_Munteanu> bxx: you want foldr for infinite lists.
11:36:56 <merijn> ski: Wait, if f never inspects the first argument it'd work on infinite lists, right? (although I guess that'd be a bit pointless xD)
11:37:09 <ski> merijn : not `foldl', no
11:37:10 <deggis> hmm, while i know that this is not the way to generate list of random values, how come every random bool created with different stdgen is true? http://hpaste.org/77078
11:37:17 <Eduard_Munteanu> But the operation you're folding with better be productive.
11:37:26 <merijn> @src foldl
11:37:26 <lambdabot> foldl f z []     = z
11:37:27 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:37:30 <bxx> copumpkin why can foldr  do something useful before the end of the list but not foldl? not really getting
11:37:36 <bxx> it
11:37:38 <copumpkin> @src foldr
11:37:38 <lambdabot> foldr f z []     = z
11:37:38 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:37:40 <merijn> ski: Oh, yeah, you're right
11:37:41 <copumpkin> @src foldl
11:37:41 <lambdabot> foldl f z []     = z
11:37:41 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:38:05 <copumpkin> bxx: note that the f gets "control" with foldr (it's outermost), and the foldl gets control with foldl
11:38:07 <ski> bxx : `foldr' is not tail-recursive
11:38:30 <merijn> bxx: If f in foldr never looks at the second argument than the fold will terminate, even though the end of the list is n't reached
11:38:33 <ski> bxx : `f x (foldr f z xs)' can decide to give something useful, even if `foldr f z xs' there would hang
11:38:45 <copumpkin> bxx: foldl is a big train that will keep going until it's done. foldr will only go as far as you ask it to
11:39:11 <ski> bxx : in `f x (foldr f z xs)', control is first passed to `f', while in `foldl f (f z x) xs', control is first passed to `foldl'
11:39:20 <bxx> oh i think I get it f 1 can return a function, while foldl can't begin any computation before it gets to inner most operation?
11:39:39 <merijn> bxx: Imagine if f is (||), if the first argument is True it can return without looking at the second
11:39:46 <merijn> bxx: Yes
11:39:54 <yitz> bxx not exactly
11:40:18 <merijn> bxx: f 1 always returns a function (f accepts to arguments according to fold)
11:40:25 <ski> > foldr (||) (error "nothing here") (True : error "no more elements")
11:40:27 <lambdabot>   True
11:40:33 <ski> > foldl (||) (error "nothing here") (True : error "no more elements")
11:40:34 <lambdabot>   *Exception: no more elements
11:40:57 <merijn> > foldr (||) (error "nothing here") (True : error "no more elements") :: Expr
11:40:59 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
11:40:59 <lambdabot>         against inferred ...
11:41:01 <merijn> aww
11:41:13 <ski> (i would have, if i could)
11:41:21 <bxx> foldl f 100 [1,2,3,4,5,6,7,8,9] :: Expr <- is this a bot feture or can it be done in ghci too?
11:41:39 <ski> bxx : it can be used in GHCi as well, if you load `SimpleReflect'
11:41:42 <johnw> Expr is from simple-reflect
11:41:54 <yitz> bxx: foldl (+) 0 [some numbers] stats adding right away, but doesn't return anything until it's done.
11:42:13 <yitz> starts*
11:42:14 <bxx> yitz yes I got it after looking how they are expanded
11:43:30 <yitz> bxx: whereas foldr returns a thunk right away. that's good for lazy things like (:), but bad for things like (+).
11:44:17 <yitz> well usually bad
11:44:32 <bxx> that part i don't get. why is it would be worse for + ?
11:44:38 <bxx> s/is//
11:45:56 * hackagebot plugins 1.5.3.0 - Dynamic linking for Haskell and C objects  http://hackage.haskell.org/package/plugins-1.5.3.0 (JeremyShaw)
11:46:00 <merijn> bxx: (+) doesn't return anything until both sides are evaluated, (:) does
11:46:41 <merijn> bxx: (:) being a constructor will happily immediately return "<value thunk> : <fold thunk>" and not evaluate anything from the fold until you inspect either of the thunks
11:54:29 <kirindave> So maybe I am being overly enthusiastic
11:54:38 <kirindave> But Control.Lens should be part of the new haskell standard.
11:55:38 <tac> @where Control.Lens
11:55:39 <lambdabot> I know nothing about control.lens.
11:55:49 <tac> lambdabot disagrees
11:55:50 <johnw> tac: cabal install lens
11:56:03 <rwbarton> @where Control.Monad
11:56:03 <lambdabot> I know nothing about control.monad.
11:56:08 <johnw> edwardk: i'm starting to wonder about the wisdom of "lens everywhere"
11:56:09 <rwbarton> does @where even do anything
11:56:18 <rwbarton> @where permutations
11:56:19 <lambdabot> I know nothing about permutations.
11:56:19 <johnw> for shall data structures, it seems a bit obfuscatory
11:56:24 <rwbarton> @help where
11:56:24 <lambdabot> where <key>. Return element associated with key
11:56:24 <johnw> s/shall/shallow
11:56:24 <byorgey> it looks up its argument in a big association list.
11:56:29 <rwbarton> oh that @where, right
11:56:37 <johnw> @where tac
11:56:37 <lambdabot> I know nothing about tac.
11:56:41 <monochrom> @where lyah
11:56:41 <lambdabot> http://www.learnyouahaskell.com/
11:56:46 <monochrom> that's something
11:56:51 <rwbarton> quite
11:56:55 <tac> @quote tac-tics
11:56:55 <lambdabot> tac-tics says: If you wish to create the universe from scratch, you must first invent the continuation.
11:57:02 <tac> johnw: he knows a little about me
11:57:05 <monochrom> it needs you to use @where+ to add stuff
11:57:24 <otters> @pl p x r = fromMaybe r $ x <$ listToMaybe x
11:57:24 <lambdabot> p = flip fromMaybe . ap (<$) listToMaybe
11:57:43 <rwbarton> hoogle still doesn't even know the lens package exists btw
11:58:05 <kirindave> Although sometimes the lens composition rules confuse me a bit.
11:58:12 <rwbarton> the way i get to the lens documentation is hoogle for lens, click on the result for package lenses and remove 'es' from the URL
11:58:37 <merijn> rwbarton: I just keep the github wiki permanently open :p
11:58:52 <typoclass> rwbarton: outside of the packages that come with ghc, hoogle doesn't know very much
11:59:11 <rwbarton> typoclass: http://www.haskell.org/hoogle/?hoogle=lens
11:59:27 <johnw> @google lens kmett
11:59:28 <lambdabot> http://www.youtube.com/watch?v=efv0SQNde5Q
12:00:21 <clahey> So, if I want to use lensa as a setter and lensb as a getter to move the data, I do:
12:02:29 <clahey> lensa .~ (view lensb objb) obja
12:03:53 <kirindave> johnw: Why is lenseverywhere a bad plan?
12:04:06 <clahey> Or in the state monad:   use lensb >>= (lensa .=)
12:04:16 <kirindave> clahey: yes for the first one.
12:04:29 <kirindave> clahey: There are special operators to make life easier for the state monad.
12:05:02 <clahey> kirindave: That actually looks pretty simple to me.
12:05:07 <johnw> kirindave: because foo ^. recordMember is not clearer than recordMember foo, or map recordMember [list of foos] vs. map (^. recordMember) [list of foos]
12:05:19 <clahey> kirindave: Or is there a way to do it even more simply?
12:05:31 <johnw> it starts looks like lenses-for-the-sake-of-lenses
12:05:40 <startling> johnw: map (view recordMember) isn't so bad.
12:05:46 <kirindave> clahey http://ekmett.github.com/lens/Control-Lens-Setter.html#v:.-61-
12:05:48 <johnw> yeah, but it's not needful in any way
12:05:54 <johnw> it just adds another layer
12:05:54 <startling> johnw: sure
12:05:58 * hackagebot hashable-generics 1.1.3 - Automatically generates Hashable instances with GHC.Generics.  http://hackage.haskell.org/package/hashable-generics-1.1.3 (ClarkGaebel)
12:06:07 <clahey> kirindave: I thought that's what I used.  :)
12:06:10 <kirindave> johnw: Yeah but the instant you have nested records the lens way becomes way cleaner.
12:06:30 <merijn> Or just one record as State
12:06:44 <johnw> for deeper nesting I totally get the benefit; the alternative is wicked pattern matching and value reconstruction to do even the simplest mutations (think triply-nested tuples, for example)
12:06:46 <kirindave> clahey: Sorry reading two channels and i got distracted.
12:06:51 <clahey> kirindave: Not a problem.  :)
12:06:54 <johnw> but for one level deep, where the program in general won't go deeper, I think I'll eschew lenses
12:07:01 <kirindave> johnw: Yeah so it's basically equal on the depth 1 case
12:07:03 <typoclass> rwbarton: yes yes, but it doesn't normally find things inside those packages
12:07:06 <johnw> exactly
12:07:07 <clahey> kirindave: I sorta dislike writing it that way.
12:07:13 <rwbarton> but it finds the package, which is useful
12:07:19 <clahey> (lensa .=) =<< use lensb ?
12:07:23 <kirindave> johnw: Except that now your accessors and mutators are composable.
12:07:36 <kirindave> johnw: Which is cool because then it's pretty easy to lift mutation functions into the lens.
12:08:19 <johnw> I was doing a small code review with someone on a project where I was using depth-1 lenses only, and it was hard to defend
12:08:37 <johnw> it really looked like I was using them just to use them, not because their use was justified
12:08:52 <johnw> but I do believe they have justification in other cases
12:09:10 <johnw> it would be nice if they didn't change my record accessor names...
12:09:17 <saml> why not use haskell instead of lense?
12:09:29 <kirindave> johnw: I can see what you're saying, but then someone else comes along and wants to re-use your library and if you have lenses suddenly it's better interop futurewise.
12:10:02 <startling> kirindave, they can just import your accessors qualified and make the lenses themselves
12:10:32 <kirindave> startling: Yes you can ask clients to do that for you.
12:10:33 <copumpkin> saml: wat
12:11:01 <kirindave> That said, depth 1 records are hardly where anyone is going to ding you for style points.
12:11:20 <startling> kirindave: the other thing you can do is provide lenses but not require `lens`.
12:11:39 <startling> all the lens types are just synonyms for functions after all
12:11:50 <kirindave> The only place where I'd like a better syntax is when I have N mutations I'd like to make to a single object.
12:12:01 <kirindave> So I have like a lensLike that reaches the object then I'd like to do several mutations.
12:12:09 <startling> yeah, that bugs me too
12:12:32 <startling> if I've got data Twice a = Twice a a I can't really update both nicely
12:13:00 <startling> because you can't have a Twice a b.
12:13:10 <kirindave> data Account = Account Int Date
12:13:17 <kirindave> Even worse.
12:13:22 <kirindave> Twice A at least you could traverse.
12:14:55 <startling> kirindave, what's difficult about that?
12:14:56 * ski thinks saying `data Twice a = MkTwice a a' would help with keeping "data constructor" and "type constructor" separate in the minds of newbies
12:17:19 <kirindave> startling: Nevermind
12:18:00 <startling> k
12:18:03 <johnw> kirindave: for library code I see that
12:18:11 <johnw> kirindave: I'm more thinking about the utility program case
12:18:26 <kirindave> Still
12:18:51 <kirindave> Hmm, is there a combinator already?
12:19:22 <copumpkin> for what?
12:19:41 <startling> combinating.
12:19:42 <kirindave> copumpkin: For what startling and I were talking about
12:19:47 <copumpkin> lol
12:19:48 <copumpkin> ok
12:20:13 <kirindave> copumpkin: Specifically given multiple Setters, take a LensLike and use that over the top of the multiple Setters.
12:20:50 <kirindave> You can combine setters, but what you'd like to see is less a . x .~ value >>> a . y .~ value >>> a . z .~ value
12:20:53 <startling> I'm not sure it's possible.
12:21:08 <startling> if we're talking about the same thing.
12:21:20 <kirindave> Well I just laid out code to do what I want.
12:21:28 <kirindave> That code works.
12:21:33 <startling> oh, you could stick undefined where hasn't been updated.
12:21:59 <startling> kirindave, I don't think it'd work with my Twice
12:22:02 <kirindave> What I want to do is say combine a (x .~ value1 >>> y .~ value2) $ thingToMutate
12:22:38 <kirindave> See what I am saying?
12:23:53 <hiptobecubic> I don't get it
12:24:22 <hiptobecubic> if you have two functions that you want to apply to something, why can't you just compose them and then use the lens to apply that?
12:24:25 <kirindave> Otherwise you write a lot of superfluous "a ."'s
12:24:26 <rwbarton> i think you can write a lens family that updates both simultaneously
12:24:36 <rwbarton> or maybe i don't get what you are asking either
12:25:26 <kirindave> combineThingIWant a (x .~ value1 >>> y .~ value2) $ thingToMutate = a . x .~ value1 >>> a . y .~ value2 $ thingToMutate
12:25:29 <rwbarton> actually i am fairly sure that i do not
12:25:50 <kirindave> That's as clear as I know how to make it.
12:26:02 <rwbarton> i was talking about what startling was talking about
12:26:13 <kirindave> Ah
12:26:16 <startling> here's what I'm talking about; not sure if it's what kirindave is talking about. I have data Twice a = Twice a a". If i have _1 and _2 on it, I can't just do _1 .~ 'a' unless I've already got a Twice Char
12:26:41 <startling> so I want to do _1 and _2 in parallel.
12:26:50 <rwbarton> right, you can concoct a custom lens family for that
12:26:56 <rwbarton> but you can't build it out of _1 and _2 afaik
12:27:08 <startling> rwbarton: yeah.
12:27:22 <rwbarton> i just mean the lens family that exposes a (a,a) inside Twice a (rather trivially)
12:28:08 <startling> I understand, but I'm curious whether composing _1 and _2 that way is possible.
12:28:12 <startling> It seems like it's not.
12:28:22 <copumpkin> it doesn't really make sense for it to be, I don't think
12:28:25 <copumpkin> if I understand what you want
12:29:00 <startling> you can do it in the special case that your type can be deconstructed, though.
12:29:03 <fliip> how are the variables applied to the following function? Im getting confused:
12:29:05 <fliip> functionH :: Int -> Int -> Int
12:29:05 <fliip> functionH = functionF . functionG
12:29:05 <startling> that's how map works
12:29:24 <copumpkin> fliip: Int -> (Int -> Int)
12:29:29 <fliip> is it functionH x y = (functionF . functionG) x y?
12:29:32 <rwbarton> yes
12:30:09 <startling> fliip: that's the same as functionF y (functionG x), though
12:30:11 <rwbarton> then you have to work out what that means
12:30:25 <fliip> Ah ok!
12:30:26 <fliip> Thanks.
12:30:58 <startling> er wait
12:30:59 <copumpkin> > (f . (g :: Expr -> Expr)) x y :: Expr
12:31:02 <lambdabot>   f (g x) y
12:31:11 <startling> functionF (functionG x) y
12:31:12 <startling> ^
12:31:21 <fliip> Ok.
12:34:14 <Radox1> If I am in the IO monad how can I call a function that returns type x?
12:34:18 <Radox1> From within a do block
12:34:25 <fliip> Can you pm lambdabot?
12:34:31 <johnw> let y = function
12:34:44 <Iceland_jack> fliip: You can, but it doesn't speak well of you
12:34:52 <fliip> lol
12:35:49 <fliip> Im used to being bitched about =P
12:35:59 * hackagebot hashable-generics 1.1.4 - Automatically generates Hashable instances with GHC.Generics.  http://hackage.haskell.org/package/hashable-generics-1.1.4 (ClarkGaebel)
12:36:47 <Radox1> johnw : wold that evaluation the function there and then?
12:36:51 <Radox1> would*
12:37:17 <johnw> it would evaluate it when the IO action needing y gets evaluated, if it uses y
12:37:26 <johnw> so, not "there and then"
12:37:52 <startling> Radox1, it depends on a lot of things
12:37:59 <Radox1> Ah ok. Basically the function does several actions which i need to be executed but it will never ben used in the IO action
12:38:37 <rwbarton> what is the actual type of the function you want to "call"?
12:38:41 <startling> Radox1, does your "function" return an IO Something ?
12:39:21 <rwbarton> is that how we got to 1000 users
12:39:34 <startling> rwbarton: shh
12:39:48 <Radox1> No it returns a custom type
12:40:19 <startling> Radox1, we'd have to see your code to give you an accurate answer.
12:40:50 <rwbarton> it sounds like you might have some misconceptions about IO in haskell
12:41:04 <startling> indeed.
12:44:27 <rwbarton> specifically, evaluation can never cause IO effects to occur
12:45:38 <tac> someone should write a step-evaluator for a toy pure functional language with IO
12:45:41 <tac> to illustrate that fact.
12:46:16 <startling> once you've got Monad, you've got most of haskell.
12:47:25 <josephle> I once had a step-evaluating interpreter for Goedel's System T written in haskell. I'm not sure where it is now :(
12:47:44 <tac> What is Godel System T? josephle?
12:47:48 <tac> I've heard the name
12:48:15 <josephle> basically simply typed functional language with no general recursion
12:48:19 <startling> kylcarte: what's up?
12:48:19 <josephle> only natural recursion
12:48:32 <tac> natural meaning only structural recursion on Nat?
12:48:38 <josephle> tac: yes
12:48:46 <tac> does it have equality types?
12:48:49 <startling> kylcarte1: what's up?
12:49:16 <josephle> I don't remember off the top of my head
12:49:44 <Eduard_Munteanu> josephle: if you're looking for a total language, look at Agda.
12:49:57 <kirindave> startling: "once you've got Monad, you've got most of haskell."
12:50:06 <josephle> tac: a formal specification for Goedel's T is in chapter 9 of http://www.cs.cmu.edu/~rwh/plbook/book.pdf
12:50:11 <Eduard_Munteanu> Not as simple as what you mentioned though.
12:50:11 <kirindave> startling: More like, "Once you've got Monad, you've got non-agonizing functional programming."
12:50:21 <tac> josephle: ty
12:50:26 <startling> kirindave: yeah.
12:50:27 <kirindave> How Lisp folks tolerate passing 800 arguments to functions, I will never understand.
12:50:57 <josephle> Eduard_Munteanu: Homotopy Type Theory has me scared of agda. Trying to prove weak equivalences has me dizzy.
12:50:58 <kirindave> Also how I lived with only explicit currying...
12:51:07 <startling> kirindave: ikr
12:51:54 <Eduard_Munteanu> josephle: mm, I'm not sure what you mean, Agda isn't based on HTT. Or are you trying to prove things about HTT in Agda?
12:52:14 <josephle> Eduard_Munteanu: trying to prove things about HoTT in Agda x_x
12:53:13 <startling> someone want to take care of kylcarte?
12:53:19 <josephle> I will admit that agda's willingness to beta reduce my types when possible is quite nice
12:56:00 * hackagebot alpha 0.9.9 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9.9 (MarcCoiffier)
12:56:08 <Saizan> that's all it does
13:03:34 <startling> I've got a complicated tree that corresponds nicely to filesystem hierarchies. If I'm using Data.ByteString.Lazy.readFile, do I need to do something special so that reading one file node doesn't go back and read the file nodes read before it?
13:04:29 <c_wraith> startling: no.
13:04:51 <c_wraith> startling: the only thing you really need to worry about is running out of file handles due to having too many files open
13:05:07 <c_wraith> startling: also, it kind of sounds like you're duplicating the directory-tree package
13:06:31 <startling> c_wraith, does it work because D.B.L.readFile uses unsafeInterleaveIO or something?
13:07:08 <startling> c_wraith: also, directory-tree seems really nice.
13:07:21 <c_wraith> startling: yes, that's exactly why it works
13:07:55 <startling> c_wraith: cool, thanks.
13:08:51 <startling> I'm using a newtype Tree k v = Tree k (Map (Either v (Tree k v)), which is a little different. mainly I don't want files to be able to exist on their own.
13:09:18 <startling> that also gives me straightforward a Monoid instance which works with my api a lot more nicely.
13:09:38 <Eduard_Munteanu> What do you mean "exist on their own"?
13:09:44 <startling> Eduard_Munteanu, as a Tree.
13:09:52 <copumpkin> startling: that Map looks ill-kinded
13:10:04 <startling> errr, yeah, wrote that wrong
13:10:14 <startling> Tree (Map k (Either v (Tree k v)))
13:10:56 <johnw> why not: Tree (Either v (Map k (Tree k v)))
13:11:18 <startling> johnw, then I can't have a Monoid instance
13:11:21 <johnw> ah
13:11:24 <startling> because files can be Trees on their own.
13:12:52 <startling> though I think I could hang the filename on the file or directory, and have File `mappend` File be a directory.
13:13:11 <startling> oh, but then I wouldn't have a directory name. that doesn't work.
13:14:11 <idnar> "The -XTupleSections flag enables Python-style partially applied tuple constructors. "
13:14:17 <idnar> how on earth is that Python-style?
13:14:30 <c_wraith> that's..  a good question
13:14:33 <ion> ಠ
13:14:51 <johnw> idnar: ("hello",)
13:15:03 <johnw> that's kind of common in Python
13:15:06 <idnar> that's not a partially applied constructor in python, though
13:15:10 <johnw> true
13:15:13 <idnar> that's a fully applied 1-tuple
13:15:32 <johnw> we then have to define "style" :)
13:15:46 <idnar> I suppose
13:15:51 <idnar> or maybe whoever wrote this didn't realise what the Python version did
13:16:01 <c_wraith> I suspect the latter
13:16:38 <startling> (1,) is a 1-tuple in python, which is sort of but not at all like TupleSections
13:16:52 <idnar> anyway, it's just funny, because somebody was trying to solve a problem in Python and I ended up looking up some Haskell stuff to compare, so now I've come full circle
13:17:49 <parcs`> what's the point of a one-tuple
13:18:14 <johnw> parcs`: it's one more than a no-tuple
13:18:20 <idnar> tuples in python are just immutable lists
13:18:20 <startling> I don't get it either.
13:18:40 <johnw> you can use tuple operations on one-tuples
13:18:43 <startling> tuples are used for e.g. function arguments by python itself, though
13:19:34 <startling> "def someFn (first, *rest): " <- rest will be a tuple
13:19:37 <startling> (possibly empty)
13:19:46 <johnw> (,)
13:20:44 <johnw> > join (a,) b
13:20:45 <lambdabot>   Illegal tuple section: use -XTupleSections
13:20:58 <startling> > :set -XTupleSections
13:20:59 <parcs`> ah, right
13:20:59 <lambdabot>   <no location info>: parse error on input `:'
13:21:03 <startling> >:(
13:22:26 <parcs`> so you can do something like map(lambda x: 1 + x, (1,))
13:22:54 <johnw> yep
13:23:14 <merijn> parcs`: Some python formatting operations demand tuples as input
13:23:22 <johnw> and foo(1) == foo(*(1,)) for functions that take foo(*args)
13:23:38 <simpson> johnw: Actually, no, for *all* functions.
13:23:42 <johnw> oh, ok
13:23:47 <johnw> i'm actively seeking to forget python
13:23:49 <simpson> johnw: def f(x): print x; foo(*(1,))
13:23:54 <simpson> johnw: Why? It's a delightful language.
13:23:57 <simpson> Forget PHP instead.
13:24:04 <johnw> it's just a boring language
13:24:16 <johnw> with anemic lambdas, no case, and painfully verbose regexps
13:24:28 <startling> hehe
13:24:32 <johnw> i really dislike python
13:24:37 <startling> it's the best "normal" language I know
13:24:40 <merijn> johnw: Complaints about python lambda's are like the one thing I don't get
13:24:41 <simpson> That's a pretty cool story.
13:24:59 <startling> merijn: yeah, lambda is really only for sorting or mapping
13:25:03 <merijn> There's so many things I find a bit annoying, lambda's have never been one
13:25:19 <merijn> If you can't do it in a lambda just define a local named function, it's not that hard...
13:25:33 <parcs`> .. like the lack of scope checking
13:26:09 <startling> parcs`: hm? you mean "it's easy to shadow things"?
13:26:29 <johnw> "just define a local named function".  BORING
13:26:49 <startling> oh, you probably mean the mutable/immutable weirdness with mutation and scoping
13:26:53 <merijn> johnw: Oh, I don't say it was exciting. Just that complaining about lambda's doesn't make sense
13:26:53 <johnw> can a local named function close over variables in scope at the call to map?
13:27:09 <merijn> johnw: Yes, if you define it in the same scope as the map
13:27:21 <johnw> at least that's better than C++ without lambdas
13:27:27 <parcs`> startling: it's easy to mistype a variable name only to have the application fail at runtime instead of compile time
13:27:52 <typoclass> i lost interest in python because of haskell's type system, i agree it's not attractive. but we shouldn't forget it does some things much better than haskell, like documentation
13:27:56 <johnw> parcs`: that's assuming you don't use pylint in the background
13:28:07 <merijn> johnw: Python let's you define functions in any scope and properly captures the variables in scope. (Although you need a nonlocal declaration to write to variables in scope but not local to the function)
13:28:12 <startling> parcs`: yeah, fair enough.
13:28:48 <startling> *but you can mutate nonlocals as you'd expect, which is weird.
13:29:12 <merijn> startling: No, it's not
13:29:41 <startling> *if they're not one of python's built-in specifically-marked "immutable" types
13:30:00 <startling> merijn: you're right, it makes sense, it just trips new people up sometimes
13:30:22 <startling> is anyone here an op?
13:30:35 <johnw> yes
13:30:38 <johnw> but not on this channel :)
13:30:43 <startling> D:
13:31:08 <merijn> startling: All python variables are references, so mutation being possible is pretty much a given
13:31:20 <simpson> startling: Do you really need to summon an op?
13:31:27 <simpson> @where ops
13:31:28 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
13:31:40 <c_wraith> that summons them, but beware of drawing their wrath. :P
13:31:45 <dcoutts> @yarr!
13:31:45 <lambdabot> Gangway!
13:31:45 <copumpkin> if you want to talk to ops, join #haskell-ops
13:31:50 <copumpkin> @yow
13:31:51 <lambdabot> Couldn't find fortune file
13:31:53 <copumpkin> damn
13:31:55 <dcoutts> heh
13:32:10 * typoclass pacifies the ops with some lambdacats
13:32:13 <Cale> I wonder where it's looking for the fortune file and whether we can install that
13:32:19 <dcoutts> @botsnack
13:32:19 <lambdabot> :)
13:32:27 <copumpkin> Cale: it's looking in z:\fortune.txt
13:32:30 <startling> I'm just really annoyed at kylcarte at al's constant quits/rejoins
13:32:38 <typoclass> Cale: i think the guy who knows about lambdabot is called ... erm ... omg
13:32:43 <c_wraith> huh.  wli never uses that name anymore, dons is just never here anymore..  That list could use some updating.
13:32:58 <copumpkin> haven't seen sjanssen in years
13:32:59 <parcs`> startling: configure your irc client to hide joins and quits
13:33:15 <Cale> typoclass: I just try to make sure it stays running
13:33:22 <Cale> typoclass: I haven't actually read much of the code
13:33:32 <typoclass> startling: you could try to talk to that guy directly?
13:33:38 <ski> preflex: xseen sjanssen
13:33:38 <Cale> (and I certainly wasn't involved much in writing it)
13:33:41 <startling> typoclass: tried already
13:33:42 <typoclass> Cale: sure :) i was just kidding
13:33:45 <copumpkin> no preflex either
13:33:46 <ski> preflex: xseen preflex
13:39:52 <typoclass> is there some 7.6-compatible package that provides OldExceptions? does this have anything to do with that? http://hackage.haskell.org/package/extensible-exceptions-0.1.1.4
13:41:04 <merijn> startling: Which IRC client are you using? Most support hiding joins/parts...
13:41:48 <dcoutts> typoclass: I don't think so. The Control.OldException module was in base up until ghc-7.4.x
13:42:15 <dcoutts> typoclass: the extensible-exceptions package provides the new exceptions model, but compatible with older ghc before it was added to base
13:42:28 <dcoutts> typoclass: basically there's no excuse now for using old style exceptions
13:42:32 <typoclass> dcoutts: oh i see, thanks
13:42:42 <dcoutts> since you can use new exceptions with old or new ghc
13:42:54 <typoclass> dcoutts: well, the reason would be backwards compatibility. there's just code that depends on the old thing
13:43:09 <dcoutts> typoclass: it's had years to be updated :-)
13:43:43 <dcoutts> ever since ghc-6.10
13:45:02 <acowley> Has anyone updated c2hs to work with 7.6 or is it defunct?
13:45:59 <bgamari> acowley, I have a patch kicking around
13:46:06 <dcoutts> acowley: ah someone sent me a patch...
13:46:07 <typoclass> dcoutts: yes yes, but there's also people who subscribe to the philosophy of if it ain't broke, don't fix it. i think it's actually not so far-fetched. if it works and is stable, why fiddle with it for little to no gain, just because someone brought out a new exception mechanism, or a new lens library, or a new iteratee-ish thing ...
13:46:10 <acowley> bgamari: Is it kicking around on github?
13:46:21 <dcoutts> typoclass: mm, though it was actually broken :-)
13:46:38 <bgamari> acowley, Nope, the repository I have is in darcs
13:46:48 <bgamari> so at best I "darcs sent" it
13:47:04 <acowley> dcoutts: Okay, then consider this a request from the peanut gallery that a new version be pushed :)
13:47:14 <bgamari> given there's a darcs-temp-mail-0~ file in the directory, it seems I at least tried to send it
13:47:39 <dcoutts> typoclass: no it's a fair point. The Haskell people tend to be relatively eager about getting changes in and deprecating stuff. In fact this was one of kinder examples, since the old style was supported for 5 major versions.
13:48:02 <acowley> My darcs setup is not in a good state atm
13:48:29 <acowley> Last time I tried to build it, it didn't work with 7.6 either
13:49:00 <acowley> ah, I do have a binary I downloaded
13:49:17 <Athas> dcoutts: well, the "GHC people" anyway.  Standard Haskell moves glacially. :-)
13:49:30 <dcoutts> yes, libraries
13:50:05 <acowley> Haskell's forward velocity is pretty spectacular, but it does leave a lot of twisted wreckage in its wake.
13:50:21 <typoclass> dcoutts: that's true. we were just talking about it over in -blah. haskell has tons of advantages :-) but somehow the backwards compatibility thing just isn't figured out yet
13:50:39 <acowley> bgamari: Can you pastebin the c2hs patch somewhere I can grab it?
13:51:06 <dcoutts> typoclass: I disagree, we provided backwards compat for five versions. Your complaint is that the compat was removed, but that's a deliberate decision, not not figuring it out.
13:51:17 <lispy> typoclass: yeah, we pay a high price to allow the language/libraries to continue to improve at whatever pace they see fit
13:51:19 <dcoutts> typoclass: and it was removed because these things are a maintenance burden
13:51:19 <acowley> or if it's really trivial, I'll just make the changes myself actually
13:51:39 <bgamari> acfoltzer,
13:51:42 <bgamari> acowley, sure
13:51:45 <lispy> So, what was removed?
13:51:59 <dcoutts> lispy: Control.OldException
13:52:12 <lispy> ah, yeah that's been a pain
13:52:53 <lispy> Not that switching to new exceptions has caused me any problems or been hard
13:52:59 <acowley> bgamari: I think I made the necessary changes
13:53:07 <lispy> But finding all the places to switch and then doing the reupload has been tedious
13:53:07 <bgamari> yeah, it's pretty straightforward
13:53:21 <bgamari> just Control.Exception and importing the CInt constructor
13:53:25 <acowley> yeah
13:53:30 <acowley> there are a couple warnings still
13:53:34 <acowley> wish it was on github
13:53:35 <dcoutts> bgamari: looking at it now...
13:54:02 * bgamari 's darcs-fu is unbelievably weak apparently
13:54:36 <typoclass> dcoutts: sure, i don't know about the reasoning behind removing OldException, it's just that i ran into it, googled, and saw the release notes say it has been removed (laconically in one line, iirc)
13:54:36 <acowley> bgamari: Mine too
13:54:41 <lispy> typoclass: I grumble as much as anyone (probably more) about things breaking with each GHC release, but once I've adapted to the change I'm usually happy about the new status quo. It's not my favorite dance, but I don't think I would like Haskell as much as I do if we didn't go through this.
13:54:57 <acowley> bgamari: I've made a serious hash of sending darcs patches almost every time I've needed to send them to someone.
13:55:53 <typoclass> dcoutts: but when you say 'maintenance burden', i think that undercuts your argument a little, since frequent changes actually create maintenance burden ...
13:56:11 <dcoutts> typoclass: I mean the people maintaining the system, not the users of the lib
13:58:19 <jfischoff> dcoutts: are you gonna kickstart it?
13:58:29 <typoclass> dcoutts: anyway, by "compatibility not figured out" i meant not so much OldException (as you said, there was a long transition period, and the decisions were deliberate). i meant more the general situation that haskell code from a year ago is not likely to compile anymore, unless you archived all the packages, and probably ghc
13:58:30 <dcoutts> jfischoff: been thinking about it
13:58:41 <jfischoff> dcoutts: I'd contribute
13:58:46 <typoclass> (just as far as i can tell, it's not that i have 1000 packages and some good overview of how things are)
13:59:38 <typoclass> also, i'm not criticizing anyone :) i wouldn't really know how to fix the situation. it'd probably have to be something technical in combination with something cultural (policies)
14:00:23 <dcoutts> jfischoff: quite a few people responsed positively on reddit. My concern is if we can find a sufficiently useful task, that's realistic for the sort of funds we might raise. The danger is high expectations and not getting enough resources.
14:00:59 <dcoutts> typoclass: in practice, you'd have to test your stuff with ghc pre-releases and complain or send patches.
14:01:12 <bxx> .
14:02:03 <jfischoff> dcoutts: yeah I am terrible at managing expectations so I have no advice there
14:03:07 <fruitFly> how do you make a block in haskell? { }?
14:03:23 <Psycho_gr> Can anyone point me in the direction of a Haskell tutorial for non-programmers (as a first-language)?
14:03:23 <bxx> why is this giving me different result than foldr?  http://hpaste.org/77082
14:03:26 <typoclass> fruitFly: usually by newline and indenting
14:03:47 <typoclass> Psycho_gr: hello and welcome. have you seen lyah? it's available free of charge
14:03:47 <tac> Psycho_gr: Sounds like a bad time ;[
14:03:49 <typoclass> @where lyah
14:03:49 <lambdabot> http://www.learnyouahaskell.com/
14:03:59 <tac> Psycho_gr: you might want to start with helium perhaps?
14:04:04 <tac> Is Helium still relevant?
14:04:08 <Psycho_gr> It's not for me, it's for a friend.
14:04:17 <fruitFly> typoclass: do the lines have to be exactly in line, and you said usually
14:04:26 <rwbarton> bxx: because that's not the definition of foldr?
14:04:27 <dcoutts> acowley, bgamari: c2hs uploaded
14:04:30 <Psycho_gr> Why bad time? lyah says in its introduction that it assumes you have imperative programming experience.
14:04:39 <dcoutts> acowley, bgamari: lemme know if it works/doesn't
14:04:42 <acowley> I would love if cabal work were kickstarted, but I have no idea how much support it would get
14:05:11 <typoclass> fruitFly: yes, they have to be aligned, indentation is significant in haskell. the other (rarely used) way is "do { ... ; ... }"
14:05:13 <rwbarton> bxx: try expanding the two definitions manually and you will see
14:05:21 <typoclass> tac: what do you mean by helium?
14:05:34 <fruitFly> typoclass: thanks!
14:05:39 <tac> @where helium
14:05:40 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
14:05:41 <acowley> I saw on reddit someone suggested there are 700 active Haskellers. At $20 each, that's not a ton of money.
14:05:55 <tac> It's a "haskell for pedagogy"
14:05:55 <dcoutts> tac: the idea is great, the implementation is probably not usable really at the moment.
14:06:03 <tac> dcoutts: that's what I thought :[
14:06:04 * hackagebot c2hs 0.16.4 - C->Haskell FFI tool that gives some cross-language type safety  http://hackage.haskell.org/package/c2hs-0.16.4 (DuncanCoutts)
14:06:05 <typoclass> Psycho_gr: how about tryhaskell.org? it has a few lessons built in, although i'm not sure how far they go. probably far enough to get started with lyah :)
14:06:05 <dcoutts> tac: though might still work, within its limited scope
14:06:18 <johnw> 700?  that's quite low
14:06:22 <Psycho_gr> Thanks.
14:06:25 <bgamari> acowley, Ditto regarding kickstarter
14:06:26 <acowley> johnw: I think so, too
14:06:28 <typoclass> tac: interesting, thanks. link is dead however :-/
14:06:40 <tac> figures
14:06:45 <rwbarton> how many people are on haskell-cafe?
14:06:54 <acowley> johnw: but perhaps the originator of that number was only counting people who contribute to the ecosystem
14:06:55 <tac> typoclass: It's a haskell without type classes and a strong focus on making the error messages not suck.
14:07:05 <johnw> acowley: ah, that would necessarily be a much smaller number
14:07:05 <rwbarton> or haskell or (insert mailing-list-related statistic of your choice here)
14:07:08 <merijn> acowley: Well...ton of money...
14:07:10 <johnw> the same is true in any community
14:07:18 <johnw> Emacs users vs. Emacs contributors is an even worse percentage
14:07:21 <typoclass> tac: sounds nice!
14:08:04 <acowley> It's an important distinction, though. A college student who took a Haskell class probably won't chip in
14:08:16 <merijn> acowley: $20 * 700 haskellers is 14k, that's less than my current yearly salary and my salary *sucks*. To invest any sort of extra effort into cabal would probably take at least one person year...
14:08:37 <merijn> acowley: Considering the amount of money the people working on cabal could probably earn working that doesn't seem like a lot...
14:08:44 <nicoo> johnw: I believe it's quite high on Exherbo (a GNU/Linux distro that *expects* you to contribute back)
14:08:45 <acowley> But as dcoutts said, it will be hard to clearly state what work will be done.
14:09:05 <dcoutts> acowley: we'd want to pick something rather specific
14:09:07 <acowley> merijn: I know, but kickstarter is a bit tough since you pay someone but then have no control over things after that
14:09:17 <johnw> nicoo: does it uninstall if you don't meet your quota?
14:09:22 <typoclass> "put nix into cabal" :-)
14:09:30 <acowley> merijn: If you employ someone, you can regularly make sure work is moving in a direction that is worthwhile to you
14:09:40 <dcoutts> typoclass: yes that's one of the options
14:09:42 <nicoo> johnw: It doesn't, no xD
14:09:58 <dcoutts> typoclass: we've been working towards that for years
14:10:01 <nicoo> But everything is designed for contributing to ba hassle-free.
14:10:16 <johnw> ah
14:10:25 <nicoo> (git clone, hack, git formatpatch | wgetpaste, send to IRC bot)
14:10:25 <rwbarton> that is one issue with hackage right now i think
14:10:29 <acowley> So people are justifiably conservative with kickstarter donations. They're still better than just an open PayPal tip jar, though, because they avoid the feeling of flushing your $20 down the toilet by requiring that the funding target be hit.
14:11:06 <acowley> dcoutts: c2hs 0.16.4 installed!
14:11:10 <dcoutts> great
14:11:15 <typoclass> dcoutts: wow interesting! hadn't known about efforts in that direction, beyond that one discussion you had with someone a few weeks ago
14:11:17 <rwbarton> nicoo: interesting. what does the irc bot do with the patch? apply it automatically?
14:11:20 <dcoutts> acowley: yes, the threshold is an important issue
14:11:31 <rwbarton> or are the patches still human-reviewed
14:11:49 <dcoutts> typoclass: this is the reason package ids now have these big hashes
14:11:58 <nicoo> rwbarton: Enqueue it for a contributor or a dev to review it
14:12:03 <bxx> rwbarton I still did not figure out how to expand in ghci. i imported SimpleReflect and typed "foldl f 100 [1,2,3,4,5,6,7,8,9] :: Expr" as someone typed in this channel earlier and got errors
14:12:21 <rwbarton> bxx: just do it manually. you will learn more
14:12:52 <nicoo> bxx: lambdabot doesn't come just with Prelude ;)
14:13:50 <ciaranm> what's the canonical name for flip ($) ?
14:14:14 <acowley> ciaranm: edwardk calls it (%) but there is not unanimous support for that name.
14:15:56 <osa1> is there a way to make this parser: `string "a" `sepBy` string ","` parse this string: "a,a," without giving an error because of last comma ?
14:16:00 <ciaranm> i don't particularly like $ for that matter...
14:16:05 * hackagebot bzlib 0.5.0.4 - Compression and decompression in the bzip2 format  http://hackage.haskell.org/package/bzlib-0.5.0.4 (DuncanCoutts)
14:16:19 <johnw> osal: many (string "a" <* string ",")
14:16:31 <johnw> do you want the final comma optional?
14:16:39 <osa1> johnw: yes
14:16:47 <johnw> do you want to allow a,,?
14:16:54 <osa1> johnw: no, just one extra comma
14:17:27 <parcs`> osa1: chainr
14:17:35 <johnw> :t chainr
14:17:36 <lambdabot> Not in scope: `chainr'
14:18:25 <johnw> chainr doesn't handle the dangling comma, does it?
14:18:27 <lispy> @hoogle chainr
14:18:27 <lambdabot> Text.ParserCombinators.ReadP chainr :: ReadP a -> ReadP (a -> a -> a) -> a -> ReadP a
14:18:27 <lambdabot> Text.ParserCombinators.ReadP chainr1 :: ReadP a -> ReadP (a -> a -> a) -> ReadP a
14:18:27 <lambdabot> Text.Parsec.Combinator chainr :: Stream s m t => ParsecT s u m a -> ParsecT s u m (a -> a -> a) -> a -> ParsecT s u m a
14:18:40 <johnw> osal: you want sepEndBy
14:18:47 <johnw> "sepEndBy p sep parses zero or more occurrences of p, separated and optionally ended by sep"
14:19:03 <parcs`> ah, never mind..
14:19:44 <osa1> johnw: great. thanks.
14:20:06 <osa1> johnw: does that consume the last optional separator ?
14:20:19 <acowley> dcoutts: the new c2hs works! Thanks!
14:21:03 <osa1> johnw: nevermind. I just tried and it works great.
14:21:05 * hackagebot iconv 0.4.1.1 - String encoding conversion  http://hackage.haskell.org/package/iconv-0.4.1.1 (DuncanCoutts)
14:21:23 <Rc43> Hi, guys.
14:21:29 <johnw> :)
14:21:35 <johnw> parsec to the rescue
14:22:21 <mcstar> have you guys heard of http://elm-lang.org/?
14:22:28 <johnw> yes, just recently
14:22:30 <Ralith> am I weird for finding production grammars easier to use than parsec (for simple syntaxes)?
14:22:34 <mcstar> friend of mine just brought it to my attention
14:22:36 <johnw> in a post from Snoyman about Yesod and javascript
14:22:52 <stepkut> mcstar: yup
14:22:55 <johnw> mcstar: http://www.yesodweb.com/blog/2012/10/yesod-fay-js
14:23:08 <mcstar> looks like a neat solution.. haskell+yesod+elm
14:23:39 <stepkut> happstack+acid-state+fay is a pretty neat solution as well. Though some fay bugs are preventing me from releasing a tutorial/screencast :(
14:23:45 <kini> I have a list of type [a] and a test of type a -> Bool, and want to replace the first element of the list which passes the test with some function of that element
14:23:45 <kini> is there some standard function which does this, or should I roll my own?
14:24:19 <fruitFly> how do you return something in haskell?
14:24:33 <johnw> kini: partition the list, change the head of the second list, then recombine
14:24:39 <c_wraith> fruitFly: all expressions have values.
14:24:40 <simpson> fruitFly: Are you just getting started?
14:24:42 <stepkut> fruitFly: you can't not return something.. that is all haskell does
14:25:43 <Rc43> In which way does functional programming separate data and code? Doesn't it contradict with the fact that functions are first-class?
14:25:46 <johnw> kini: i.e., takeWhile (not . pred) xs : y : tail (dropWhile pred xs)
14:25:52 <fruitFly> simpson: stepkut: I have a function with an if and I understand haskell requires an else.. if I want to return a list in the else do I just write "else listName"?
14:26:03 <simpson> fruitFly: Pretty much.
14:26:14 <fruitFly> simpson: thanks
14:26:20 <simpson> fruitFly: if cond then thing else other_thing
14:26:20 <c_wraith> Rc43: it just means they're typically not bundled together, unlike standard OO methodology.
14:26:20 <kini> johnw: thanks, I'll look up those functions :)
14:26:32 <simpson> fruitFly: Where cond's type is Bool and thing and other_thing have the same type.
14:26:42 <c_wraith> Rc43: instead you design in terms of functions that take some data and return some data
14:27:08 <Rc43> c_wraith, ok, I got it; thanks.
14:27:30 <fruitFly> simpson:  my thing is a recursive call to the parent function that modifies a list, other_thing is returning the list. Will this not work?
14:27:43 <c_wraith> Rc43: you are absolutely correct that functions can be the data, though.
14:27:52 <simpson> fruitFly: Sounds alright.
14:28:10 <johnw> kini: pred isn't a function, it's just a name for your a -> Bool function
14:28:17 <kini> sure
14:28:27 <kini> I meant takeWhile and dropWhile (though I can guess what they do haha)
14:28:30 <fruitFly> simpson: since it calls itself do I have to define a return type?
14:28:51 <simpson> fruitFly: Haskell can figure it out.
14:28:52 <kirindave_> Hmm
14:29:04 <fruitFly> simpson: Thanks!
14:29:33 <simpson> > let f x = if x > 10 then [x] else x:(f (x + 1)) in f 1
14:29:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
14:29:46 <kirindave_> Does anyone know a nice straightforward example of writing a parsec parser that populates a free monad? It's been explained to me that the smart way to write an interpreter is around the free monad. And for an EDSL that's great. But it's not so clear to me how I'd write an attoparsec parser for it.
14:30:07 <johnw> kirindave_: just use Parser MyFree
14:30:35 <kirindave_> johnw: I sort of get that's what I should do, but I'm not entirely clear on the execution. Please do forgive me, I'm not nearly the haskell programmer most people in here are.
14:30:37 <johnw> there is also FreeT
14:30:41 <bxx> ah i finally got it i think. foldr (-) 100 [1,2,3] expands to (1 - (2 - (3 - 100))) while my function expanded to (100 - (1 - (2 - 3)))
14:31:06 <rwbarton> bxx, yes
14:31:30 <simpson> kirindave_: Okay, do you see the general trick for making Parsec expressions of types that you choose?
14:31:48 <johnw> kirindave_: well, each Parsec parser return a value created by the parser.  So, you'd match on the string "foo", and then return a value constructed with MyFoo, and the parser type would have to be Parser MyFree in order to return that value
14:31:55 <simpson> kirindave_: Like, do { x <- parseAnX; return $! MyStruct x }
14:32:15 <kirindave_> Right but the free thing can't be constructed without the "rest" of the computation.
14:32:22 <kirindave_> Like I've seen how people put lists of statements into []
14:32:27 <kirindave_> Or into a packed structure
14:32:31 <johnw> yeah, just like simpson is doing
14:32:42 <kirindave_> But when it's using the functor pattern I am not so clear.
14:32:50 <johnw> kirindave_: the whole "rest" thing is done by the Free monad
14:32:54 <simpson> kirindave_: Oh. Well, you're using a Functor inside, and then Free on the outside, right?
14:32:55 <johnw> so maybe you do need FreeT
14:32:58 <kirindave_> Yeah
14:33:11 <johnw> FreeT MyFree Parser String
14:33:28 <simpson> Parser (MyFree String)
14:33:30 <kirindave_> johnw: Isn't it wiser to just have the parser produce the structure?
14:33:50 * kirindave_ hrrms.
14:33:52 <johnw> simpson: how do you bind values between two Parser (MyFree String)?
14:33:53 <lispy> Was the hackage2 instance taken down intentionally?
14:34:00 <simpson> johnw: However you like, probably.
14:34:16 <lispy> This is URL I have (which does not work): http://new-hackage.haskell.org/packages/
14:34:17 <johnw> parsec won't do that binding for you if the free monads are on the "inside"
14:34:43 <johnw> but, I guess you can always foldr (>>) Empty xs
14:34:45 <simpson> johnw: Well, MyFree is hopefully just a Functor parameterized on a single type, and not actually a free monad.
14:34:52 <johnw> after you get the list of Parser (MyFree String) back from Parsec
14:35:03 <johnw> aka, sequence
14:35:15 <kirindave_> yeah I was going to say
14:35:16 <johnw> kirindave_: so, use Parser (MyFree a), and then sequence the results
14:35:20 <kirindave_> Transforming a list to a sequence
14:35:37 <fruitFly> what's wrong with this semi colon..  fibCons fib = if (fib.head + fib.tail.head) < 4000000 then (fib.head + fib.tail.head:fib; fibCons fib) else fib ???
14:35:56 <rwbarton> what's right with it
14:36:08 <johnw> fruitFly: haskell doesn't have "statements"
14:36:11 <rwbarton> also, what on earth
14:36:14 <rwbarton> fib.head?
14:36:15 <geekosaur> why would you expect a semicolon to work there?
14:36:21 <rwbarton> is this haskell?
14:36:30 <johnw> rwbarton: it's Javaskell
14:36:35 <fruitFly> rwbarton: fib is a list
14:36:44 <kini> <johnw> kini: i.e., takeWhile (not . pred) xs : y : tail (dropWhile pred xs)
14:36:49 <kini> just checking, but shouldn't one of those : be a ++ ?
14:36:51 <elliott> fruitFly: there are more things wrong with that code than right
14:36:59 <johnw> kini: yaeh, the first one
14:37:01 <johnw> good catch
14:37:02 <kini> k, thanks
14:37:04 <kini> :)
14:37:04 <rwbarton> okay
14:37:09 <rwbarton> for starters, it should be "head fib"
14:37:13 <rwbarton> not "fib.head"
14:37:24 <kirindave_> Peano?
14:37:25 <kirindave_> ;)
14:37:26 <fruitFly> rwbarton: just realized.. coming from scala sorry
14:37:28 <rwbarton> however, this is almost certainly not how you want to go about this at all
14:37:43 <kirindave_> fruitFly: No worries. Everyone is a newbie at some point.
14:37:54 <rwbarton> oh i get it, you are trying to build the list backwards
14:37:55 <kirindave_> fruitFly: Braze yourself though, because people will want you to do this with zip.
14:37:57 <rwbarton> interesting
14:37:59 <kirindave_> erhem brace.
14:38:10 <elliott> well you do not want to use head or tail there
14:38:12 <johnw> {yourself}
14:38:12 <elliott> at least
14:38:16 <merijn> Everytime someone computes fibonacci using non-linear recursion god kills a kitten >.>
14:38:19 <rwbarton> okay, I think this can be repaired
14:38:33 <rwbarton> fruitFly: what did you intend by "fib.head + fib.tail.head:fib; fibCons fib"
14:38:44 <kirindave_> merijn: And yet we still have an excess of kittens in the world.
14:38:58 <merijn> kirindave_: Of course, to keep the redditors inside
14:38:59 <johnw> we just need deeper linear recursion then
14:39:01 <fruitFly> kirindave_:  I'll check out the zip
14:39:15 <merijn> kirindave_: And provide us with more lambdacats
14:39:18 <fruitFly> rwbarton: try to build a list backwards of the fibanacci sequence
14:39:36 <merijn> fruitFly: What did you expect the ; to do?
14:39:59 <merijn> fruitFly: I can guess + was supposed to be list concatenation. But the semicolon has me stumped...
14:40:44 <Cale> merijn: The exponential Fibonacci computation is a reasonable thing to write when demonstrating some things, because there are plenty of similar computations which can't be so easily turned into something linear -- if you were to replace addition with something slightly less nice.
14:40:46 <fruitFly> merijn: I was adding an element to fib then I wanted to call the function again immediately
14:40:48 <mcstar> the fibonacci sequence is unbounded in one direction
14:40:54 <mcstar> i dont think you can reverse it
14:40:56 <rwbarton> fruitFly: okay
14:41:02 <rwbarton> you can't "add an element to fib"
14:41:05 <merijn> fruitFly: What does "then" mean?
14:41:18 <rwbarton> however you can just call the function on the list with the added value
14:41:41 <fruitFly> merijn: if cond then blah blah else blah
14:41:44 <mcstar> Cale: it was very educational to actually come up with the closed solution XD
14:42:09 <merijn> fruitFly: No, I meant in your answer "add an element to fib then I want to call it again"
14:42:23 <fruitFly> merijn: yes
14:42:34 <merijn> fruitFly: Haskell has no notion of time, "then" is nonsensical in that sentence
14:43:39 <fruitFly> merijn: right, I should take some notes. So just omit then, fix the list functions (head.fib to head fib) and remove the semi colon?
14:43:44 <merijn> You could say "I want to call the function with a list consisting of fib and a new element added to it"
14:44:19 <merijn> fruitFly: But saying "add an element to fib" is nonsensical since fib is immutable and "then" is nonsensical since haskell has no notion of time
14:44:42 <rwbarton> fortunately, you can avoid both of these nonsensicalities at once
14:44:58 <rwbarton> rather than "modify and then pass new value", just "pass modified value"
14:45:23 <merijn> You probably wanted "fibCons (head fib) + (head (tail fib)) : fib" or something similar
14:45:28 <merijn> eh
14:45:29 <fruitFly> merijn: how is fib immutable.. it's a parameter of my function.. can't I add something to it and use that as the parameter
14:45:41 <merijn> fruitFly: Everything is immutable in haskell
14:45:59 <johnw> fruitFly: "adding something to it" == "creating a new list" in Haskell
14:46:00 <merijn> Imagine I added parenthesis around everything after "fibCons", btw.
14:46:07 <mcstar> language extensions?
14:46:10 <mcstar> even*
14:46:35 <fruitFly> merijn: fib = [1,2].. 3:fib = [3,1,2], right? Is this immutability?
14:46:44 <typoclass> fruitFly: it is immutable, the only thing is, when your function is called again, fib may have a different value
14:47:12 <merijn> fruitFly: That example works, yes.
14:47:21 <merijn> Lemme haskellify your original attempt a bit
14:47:57 <rwbarton> it is just like with numbers
14:48:07 <rwbarton> if I have x = 1000 then I can form x + 1 and it will equal 1001
14:48:13 <rwbarton> that does not mean I have mutated 1000, or mutated x
14:49:01 <nand`> > let 1000 = 1000+1 in "I broke math"
14:49:02 <lambdabot>   "I broke math"
14:49:10 <fruitFly> parse error on else? fibCons fib = if (head fib + head tail fib) < 4000000 (head fib + head tail fib:fib fibCons fib) else fib
14:49:36 <rwbarton> you weren't supposed to delete the "then
14:49:37 <rwbarton> "
14:49:38 <typoclass> yes, you always need "if ... then ... else"
14:50:19 <rwbarton> "head fib + head tail fib:fib fibCons fib" is still quite a mess
14:50:20 <fruitFly> rwbarton: yeah, thought merijn: meant that. Ok I'll put it back
14:51:07 * hackagebot epub-metadata 2.3.1 - Library for parsing and manipulating ePub files and OPF package data  http://hackage.haskell.org/package/epub-metadata-2.3.1 (DinoMorelli)
14:51:19 <fruitFly> rwbarton: needs parens? assuming it would parse correctly would it cons fib and then call fib again?
14:51:22 <hpaste> merijn pasted “haskellified fibCons” at http://hpaste.org/77089
14:51:33 <rwbarton> you want to apply the function fibCons to something
14:51:39 <rwbarton> that means you should write "fibCons (...)"
14:51:56 <rwbarton> you have fibCons in the middle, that's not going to be right
14:52:08 <merijn> eh, doh
14:52:12 <merijn> I mised a fibCons call there
14:53:05 <nand`> (head (tail fib)) <- the lisp is strong in this one
14:53:07 <hpaste> merijn annotated “haskellified fibCons” with “haskellified fibCons (annotation)” at http://hpaste.org/77089#a77090
14:53:24 <merijn> fruitFly: Does that paste make sense to you?
14:53:56 <merijn> nand`: Wanted to stay as clase as possible to the original code while still being valid haskell
14:54:11 <elliott> not sure handing out solutions will help in this case
14:54:23 <merijn> elliott: This is hardly a solution
14:54:34 <mcstar> reading LYAH would help
14:54:36 <rwbarton> isn't it?
14:54:42 <nand`> merijn: yes; I didn't necessarily mean you
14:54:53 <merijn> rwbarton: Well, not one *I'd* consider a solution
14:55:02 <rwbarton> nand`: well it didn't start out as (head (tail fib)) :)
14:55:04 <merijn> As that code is awful
14:55:15 <nand`> rwbarton: wasn't it fib.tail.head first?
14:55:19 <elliott> well it's awful code but it's still code
14:55:22 * nand` .oO( the lens is strong in this one )
14:55:22 <fruitFly> merijn: Thanks I get it.. but do you have to paren tail fib in head (tail fib)?
14:55:28 <elliott> and i am not sure it will explain why fruitFly's previous code did not work
14:56:12 <merijn> fruitFly: Yes, although you wouldn't normally write it like this anyway, and other ways wouldn't require that hassle
14:57:15 <merijn> fruitFly: The basic problem in your original code is the following: "(fib.head) + (fib.tail.head) : fib; fibCons fib"
14:57:24 <rwbarton> i'm not really sure either, on the one hand if someone writes stuff like "head fib + head tail fib:fib fibCons fib" they should slow down and try to understand exactly what they are doing, on the other hand not having any working code as an example can be frustrating
14:57:43 <nand`> I'd like to help, but I have zero clue what the original code is supposed to be doing
14:57:54 <merijn> fruitFly: It seems to assume that you do this "modify fib to have a new element in front" and then "call fibCons on it"
14:58:28 <mcstar> fib usually denotes the fibonacci sequence
14:58:32 <fruitFly> rwbarton: it can be at times
14:58:33 <merijn> fruitFly: The problem is that both are wrong. "fib" has one value within the entire context of fibCons, you cannot change the value of fib"
14:59:20 <merijn> fruitFly: "newElement : fib" doesn't add an element fo fib, it creates a new list consisting of "newElement" followed by "fib"
14:59:35 <fruitFly> merijn: OHHHHHHHHHHHHHH
14:59:38 <merijn> fruitFly: If you don't pass that new list to any code as argument, it'd just get garbage collected
14:59:59 <mcstar> also, if you dont have pattern matching, thats how you would have written it
15:00:04 <mcstar> with heads and tails
15:00:20 <johnw> :t heads
15:00:21 <lambdabot>     Not in scope: `heads'
15:00:21 <lambdabot>     Perhaps you meant one of these:
15:00:21 <lambdabot>       `reads' (imported from Prelude), `head' (imported from Prelude)
15:00:21 <mcstar> (constructing the list of the elements of the sequence in question)
15:00:29 <fruitFly> merijn: I understand. Fib is immutable.. it made so much more sense to passed the new consed list to fib
15:00:39 <mcstar> johnw: funny
15:00:50 <mcstar> heads means multiple uses of head
15:00:54 <beaky> hello
15:01:00 <fruitFly> merijn: pass*
15:01:01 <johnw> i thought you were creating a hydra
15:01:10 <merijn> fruitFly: There's still a lot you could clean up in that code (for example, using pattern matching instead of head/tail)
15:01:14 <mcstar> heads . johnw
15:01:37 <nand`> going by the style of ‘inits’ and ‘tails’; surely ‘heads’ would have to be: map return
15:01:47 <merijn> fruitFly: The second problem is that your use of "foo; bar" seems to imply "first do foo then do bar" which only makes sense if there is some sort of start that foo can change
15:02:06 <merijn> fruitFly: If there is no state that can be changed, then the order of when you do foo or bar doesn't matter, right?
15:02:14 <fruitFly> I'll take a look into it merijn: Thanks A LOT for all your help. And Elliot: merijn by no means was just feeding me the solution
15:02:17 <Cale> heads = id
15:03:42 <merijn> fruitFly: and since *everything* is immutable it is guaranteed foo can't change anything, thus having a notion of "first X then Y" makes no sense in haskell. As a result we don't actually have a way of writing it (i.e. no semi-colon).
15:03:54 <fruitFly> merijn: are you saying the condition (< 4000000) doesn't need to proceed the new calling of fibcons and that another construct would be more efficient?
15:04:11 <mcstar> do { x; y }
15:04:19 <merijn> fruitFly: (Well, the last bit is a bit of a lie, we use semi-colons, but they're very different from anything like Java or so which yours seems to follow)
15:04:31 <merijn> mcstar: I'm a big fan of pretending do notation doesn't exist for newbies :p
15:04:49 <mcstar> heh, ok, i take ^ that back then
15:05:46 <merijn> fruitFly: Well, it doesn't proceed to call fibCons again, else the function would never return
15:06:14 <fruitFly> merijn: I understand everything you just said about foo; bar and no state :) thanks A LOT
15:06:57 <fruitFly> merijn: I didn't mean proceed. I get you. Thanks soo much :)
15:07:13 <acowley> does anyone have any code for tabular pretty printing of a vector-backed data structure?
15:07:19 <fruitFly> #haskell never fails me. Love this community
15:07:28 <merijn> fruitFly: A more haskelly way to do fibonaci would be something like
15:07:44 <mcstar> poster child of haskell:
15:07:47 <merijn> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
15:07:48 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:09:10 <merijn> (I was trying to come with an example without zipWith, i.e. some more explicit recursion, but realised I couldn't remember one quickly >.>)
15:09:25 <fruitFly> merijin I will look into zip functions again
15:09:35 <fruitFly> merijn: Thanks again :)
15:10:22 <rwbarton> even if you don't use zipWith in particular, the idea of generating an infinite 'fibs' list and taking just what you want with takeWhile is very much the Haskell way to do this
15:10:25 <hpaste> shapr pasted “WordCount.lhs - any suggested improvements?” at http://hpaste.org/77092
15:10:49 <shapr> I guess I should hpaste the WordCount.hs, since it's easier to read...
15:11:01 <johnw> shapr!
15:11:03 <mcstar> shapr: whats that?
15:11:37 <hiptobecubic> > let fibs prev curr = prev + curr : fibs curr (prev+curr) in fibs 0 1
15:11:38 <lambdabot>   [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,177...
15:11:59 <merijn> hiptobecubic: Oh, yeah. That's the one :)
15:12:01 <shapr> mcstar: My instructor wants us to implement a word frequency count in a language that doesn't have a string type, but only an array of characters.
15:12:11 <shapr> We get to suggest the language and the data structure to use.
15:12:15 <mcstar> shapr: oh, i meant the file/editing
15:12:20 <hiptobecubic> merijn, :)
15:12:30 <mcstar> do you edit it like that, or it is just for latex?
15:12:31 <shapr> So I figured I'd try to overkill the assignment with kosmikus' lhs2tex
15:12:40 <johnw> shapr: mapM_ putStrLn . results <$> readFile "inputs.txt"?
15:12:42 <shapr> mcstar: That's real Haskell code, it compile just fine.
15:13:20 <johnw> maybe that only works with map, and then a sequence around it...
15:13:38 <shachaf> johnw: mapM_ ... <$> ... doesn't look right.
15:13:38 <shapr> I'm trying to aim for readability to my instructor who only knows *of* Haskell.
15:13:46 <johnw> shachaf: yeah, to me neither
15:13:54 <shachaf> shapr: Haskell doesn't have a string type, only a list of characters. :-)
15:14:09 <shapr> shachaf: I'm pretending array == list :-)
15:14:51 <shapr> Also, this assignment is actually a persuasive essay, I just decided to include an implementation since it fits in a single page.
15:15:01 <johnw> yeah, you have to sequence_ (map (+c) <$> return [a,b])
15:15:16 <shachaf> johnw: Hmm?
15:15:18 <typoclass> shapr: man, if you had any other name, you'd be in the middle of a multi-hour lecture now on how lists are technically in no way arrays at all :-)
15:15:21 <johnw> to use <$>
15:15:22 <shachaf> ... <$> return ... also looks wrong.
15:15:24 <johnw> which means, don't in this case
15:15:28 <shachaf> Oh.
15:15:31 <johnw> <$> return was just fabricated a list in IO
15:15:31 * shachaf has no context here.
15:15:40 <merijn> typoclass: I was tempted
15:15:45 <johnw> shachaf: no context == no monad?
15:16:06 <johnw> or, no functor, that would explain why <$> looks weird...
15:16:10 <shapr> typoclass: hehe, true that :-)
15:16:11 <lispy> :t \a b -> a <$> return b
15:16:12 <lambdabot> forall (f :: * -> *) a b. (Monad f, Functor f) => (a -> b) -> a -> f b
15:16:38 <shapr> typoclass: I know lists aren't arrays, but she said we could suggest any language we wanted.
15:16:58 <shachaf> Haskell has arrays.
15:17:01 <shapr> Then last night she changed her mind and said it had to be a C or Pascal descendant, but I was already done with the whole document :-(
15:17:20 <shapr> I don't think I can stretch to saying that Haskell is a C or Pascal descendant.
15:17:23 <johnw> shapr: kind of last minute, huh?
15:17:42 <johnw> Haskell is most certainly not such a descendant :)
15:17:50 <johnw> thank goodness
15:17:52 <lispy> shapr: oy. I hate it when stuff like that happens.
15:17:54 <shapr> Yah, I totally agree.
15:18:05 <nand`> > let fibs = 0 : scanl (+) 1 fibs in fibs
15:18:06 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
15:18:08 <`Jake`> shapr: Just change the wikipedia document so that it says "Influenced by: C, Pascal"
15:18:16 <nand`> still my favorite version
15:18:17 <Cale> I think the argument that Haskell is a good language in which to implement a word frequency count *because* it has a literate LaTeX mode is perhaps a little bit weak ;)
15:18:18 <simpson> shapr: For some reason I thought you were all done with school. Weren't you a Divmod fellow?
15:18:19 <shapr> `Jake`: that's an amusing idea :-)
15:18:20 <johnw> Turing vs. Church
15:18:23 <lispy> shapr: I had a professor that said she would always accept solutions to the homework that was assigned, even if she didn't assign what she meant to
15:18:31 <lispy> shapr: I felt like that's the right philosophy
15:18:46 <shapr> simpson: No, I just know most of them. But this is my second windmill joust, after a 15 year break for a career.
15:18:55 <merijn> simpson: shapr is an old guy pretending to be a student to corrupt the minds of young CS students with haskell
15:18:56 <shapr> lispy: I agree
15:19:00 <shapr> merijn: haha, so true!
15:19:09 <simpson> shapr: Oh, I see. Well played, good sir.
15:19:13 <johnw> shapr: i'm thinking of heading back to school in a couple years too
15:19:15 <merijn> So am I, except I'm not old yet
15:19:17 <simpson> I expect to be in those shoes in a couple decades.
15:19:31 <merijn> I'm TA'ing the FP class and the professor insists on using ocaml
15:19:34 <shapr> In this Programming Languages class the student get to suggest any language they want. This year eight people suggested Haskell, and it's the first time anyone has ever suggested Haskell!
15:19:43 <shapr> johnw: Oh cool, any particular degree?
15:19:43 <merijn> First question of the first lecture "what about haskell?"
15:19:54 <johnw> CS and Math
15:19:54 <lispy> shapr: nice
15:20:02 <johnw> edwardk has inspired me
15:20:08 <johnw> but we'll see if I stay inspired in a few years
15:20:14 <lispy> shapr: you should suggest idris or agda next time :)
15:20:22 <johnw> but I have started guide independent study
15:20:24 <shapr> johnw: That's a great idea! I think you'll enjoy much of it, and despise some of the "basic training" aspects.
15:20:40 <shapr> lispy: I'm hoping to pass this class the first time through :-)
15:20:42 <fliip> Whats the best way to find the difference between two integrals as a positive number?
15:20:43 <johnw> i'm realizing that math is a lot like haskell
15:20:52 <shapr> johnw: oh I agree! and Agda is more so!
15:21:02 <merijn> I should learn Agda...
15:21:04 <johnw> it seems impenetrable (well, to me) until you get enough familiarity, and then what was complex starts appearing simple, almost trivially so
15:21:14 <merijn> I keep running into the limits of the haskell type system :<
15:21:35 <merijn> Agda will finally give me type level lambda, right?
15:21:37 <johnw> are we all going to be on #agda in 10 years?
15:21:39 <lispy> johnw: yeah. Agda tutorials look approachable, but you quickly realize that the approachability is a very shallow impression
15:21:46 <lispy> merijn: yup
15:21:57 <merijn> lispy: w00t
15:22:01 <shapr> johnw: Yes, we will be.
15:22:07 <shapr> Agda is the next step past Haskell!
15:22:18 <johnw> but the next step in what direction?
15:22:19 <merijn> Man, I should just go there now and be all hipster about it
15:22:25 <shapr> johnw: Anyway, thanks for the code suggestions, any other thoughts?
15:22:32 <Saizan> merijn: you won't be able to pattern match on types though
15:22:33 <lispy> merijn: I bet you'd enjoy this, just make your own implementation as you read it: http://www.andres-loeh.de/LambdaPi/index.html
15:22:34 <johnw> shapr: can you show me the .hs version?
15:22:45 <shapr> johnw: the next step towards types being first class values in the language!
15:22:48 <shapr> oh sure
15:23:08 <Eduard_Munteanu> Haskell is too popular now, Agda lets me phrase answers ending with "you probably never heard of it". :)
15:23:13 <merijn> Saizan: I also couldn't get anything real done in it, so :p
15:23:16 <hpaste> shapr pasted “WordCount.hs” at http://hpaste.org/77093
15:23:32 <Earnestly> Eduard_Munteanu: You mean, Agda is now a hipster language?
15:23:41 <Eduard_Munteanu> Could be!
15:23:45 <`Jake`> That looks a lot more readable.
15:23:50 <lispy> go with idris, even more obscure!
15:23:59 <typoclass> johnw: "it seems impenetrable (well, to me) until you get enough familiarity, and then what was complex starts appearing simple, almost trivially so" <- that's an excellent way of putting it. i thought the same, although it came out as "it's a ton of jargon for a gram of insight", but i wouldn't say it like that because that's unkind and i guess unfair :-/
15:24:12 <johnw> getWords can't be written using "words"?
15:24:12 <shapr> `Jake`: Yah, but it doesn't produce a pretty PDF that way!
15:24:18 * Eduard_Munteanu awaits some HTT implementation
15:24:18 <Earnestly> Quick, to the moleskins and thick rimmed glasses!
15:24:31 <shapr> johnw: Yah, that's true. I was hoping that would be more readable to my instructor.
15:24:32 <`Jake`> shapr: Yes, unfortunately
15:24:39 <ruuns> hi
15:24:45 <johnw> typoclass: i'm start to really appreciate the jarcgon
15:25:01 <johnw> it's important to have very accurate words when you're discussing highly abstract structures
15:25:02 <Eduard_Munteanu> ruuns: hi
15:25:03 <shapr> hi ruuns
15:25:25 <johnw> shapr: I still don't quite get what "span" does...
15:25:47 <shapr> > span isAlpha "aaaa bbb"
15:25:48 <lambdabot>   ("aaaa"," bbb")
15:25:49 <typoclass> johnw: interesting, i'm not really convinced of the whole "accurate" business ...
15:26:06 <lispy> re: Agda, someone on my G+ explained that formal methods are really good at exploring an idea to fleshout the mathematical understanding of the problem
15:26:17 <johnw> typoclass: take for example the distinction between "if" and "if and only if"
15:26:21 <lispy> That's really where I see agda being useful. I don't think most people intend to ever run their Agda code
15:26:21 <shapr> johnw: it returns a tuple where the first chunk is the contiguous matches of the predicate, and the second is everything else.
15:26:21 <typoclass> johnw: span and break are basically takeWhile that also gives you the part that wasn't taken
15:26:34 <shapr> This is like "word count without using parsec"
15:26:40 <johnw> shapr: it just partitions the list into a pair?
15:26:46 <shapr> My instructor prefers low level explicit code.
15:26:54 <shapr> johnw: Yah, is there an easier way?
15:26:57 <johnw> typoclass: cool, I could have used that to answer kirin's qusetion
15:27:10 <lispy> shapr: are you the one that posted the shell script for word counts?
15:27:20 <lispy> shapr: something like 5-6 pipes and you're done
15:27:24 <Eduard_Munteanu> lispy: FWIW, I tried to run some Agda code, but instead I got myself pulled into defining a convenient do notation and different other stuff.
15:27:33 <shapr> lispy: Yah, that was me. I was researching this same assignment.
15:27:40 <johnw> (takeWhile f xs,dropWhile f xs) == scan f xs
15:27:45 <lispy> shapr: that was a cool article. I enjoyed it
15:27:53 <shapr> Me too! But then I didn't want to write Pascal code :-(
15:28:11 <shapr> I strongly suspect our instructor will tell us to implement this in Pascal tomorrow.
15:28:25 <johnw> does Agda have an IO Monad?
15:28:37 <Eduard_Munteanu> Yep.
15:28:41 <johnw> oh, cool
15:28:43 <lispy> johnw: it also has an FFI to Haskell
15:28:44 <typoclass> johnw: oh i agree there's a time and place for "iff", i'm just not convinced that everything would be better if everything was more precise (which *seems* to be a belief of a sizeable number of people)
15:29:07 <shapr> :t span
15:29:08 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
15:29:08 <lispy> johnw: but if your intent is to run the code and get reasonable performance, I don't think Agda aspires to that. Idris on the other hand, does see that as a goal.
15:29:22 <johnw> typoclass: I think the deeper you go, the more the precision is valuable; but at higher levels, informality is acceptable
15:29:33 <shapr> :t scan
15:29:34 <lambdabot>     Not in scope: `scan'
15:29:34 <lambdabot>     Perhaps you meant one of these:
15:29:35 <lambdabot>       `scanl' (imported from Prelude), `scanr' (imported from Prelude),
15:29:35 <johnw> because otherwise, without the precision, it's hard to be sure two people mean the same thing by what they're saying
15:29:45 <merijn> typoclass: It depends, I really like specifying my bugs away at the type level :p
15:29:52 <johnw> is there an Agda -> Haskell compiler?
15:29:54 <lispy> At least at the moment, I think Agda is about proofs/denotations and Idris is about exploring what it takes to make dependently typed languages high performance
15:30:03 <lispy> johnw: inside Agda there is
15:30:05 <Eduard_Munteanu> johnw: that's what the default backend does.
15:30:10 <johnw> haha, cool!
15:30:14 <merijn> lispy: Does Idris have mixfix?
15:30:15 <typoclass> merijn: umm...?
15:30:22 <johnw> i'll have to play around with it then as a theorem (read: program) prover :)
15:30:32 <shapr> Ok, thanks for the suggestions guys! I'm off for statistics tutoring...
15:30:32 <lispy> merijn: No more so than Haskell, AFAICT
15:30:41 <lispy> merijn: it does allow overloading of constructors though
15:30:56 <johnw> hmm.. no agda in homebrew
15:31:09 <lispy> merijn, johnw: http://idris-lang.org/
15:31:22 <johnw> oh, wait, you install Agda using cabal?
15:31:32 <rwbarton> idris has this cool syntax for EDSLs though
15:31:33 <merijn> typoclass: Because you said "not convinced that everything would be better if everything was more precise" but without some of that precision you limit your ability to write the types you sometimes want
15:31:43 <lispy> johnw: Agda can be a pain to build (small user community). I often get it from hackage or darcs. You also need to separately install the "standard" agda library.
15:31:58 <merijn> lispy: I'll check it out, a colleague already told me to look into it
15:31:58 <lispy> rwbarton: idiom brackets or something else?
15:32:37 <typoclass> merijn: i dunno if there's this sort of direct connection between human language and a computer language ...
15:32:40 <rwbarton> lispy: see http://www.cs.st-andrews.ac.uk/~eb/writings/idris-tutorial.pdf page 41
15:32:47 <johnw> bleh, Agda 2.3.0.1 doesn't like GHC 7.6.1
15:32:54 <merijn> lispy: It's not lazy, right?
15:33:23 <rwbarton> lets you reuse lambda syntax and so on for constructions in the EDSL
15:33:28 <lispy> merijn: Not really. I think the repl might be lazy at the moment, but I thought I heard edwinb say he would make it strict at some point
15:33:45 <tac> merijn: in a total language, it can be evaluated lazy or strict or mixed. It doesn't matter.
15:33:55 <tac> (but Idris is not totally total. Just mostly total)
15:34:00 <deggis> > length . filter not . take 10000 . map (\s -> fst (random (mkStdGen s) :: (Bool,StdGen))) $ [1236483..]
15:34:01 <merijn> tac: It does matter
15:34:02 <lambdabot>   10000
15:34:05 <rwbarton> it can still matter though
15:34:19 <tac> it doesn't matter in terms of semantics
15:34:20 <merijn> tac: Unless you consider operational behaviour irrelevant
15:34:27 <tac> right
15:34:34 <nope4323> cabal question: I want to build a gtk+ app that statically links all gtk dlls into the final executable.  I have read all over that -static will do so but it doesn't work, any ideas?
15:34:38 <tac> but it means that you can make it operationally behave in any way you want.
15:34:42 <lispy> rwbarton: oh wow. I hadn't noticed that in the features. I'll have to look at it more.
15:34:48 <merijn> i.e. "map f (x:xs) = f x : map f xs" is terrible in a strict language
15:35:00 <tac> lazy or strict. It's a choice you get to make (in a sufficiently nice implementation)
15:35:28 <Eduard_Munteanu> nope4323: -static doesn't cover system libs
15:35:48 <deggis> i'd expect above to have 50% of Falses, any ideas on why's every Bool False there
15:35:54 <Eduard_Munteanu> nope4323: so you probably want -optc-static or something like that
15:35:57 <deggis> > length . filter not . take 10000 . map (\s -> fst (random (mkStdGen s) :: (Bool,StdGen))) $ [0..]
15:35:59 <lambdabot>   0
15:36:00 <Eduard_Munteanu> Or -optl, dunno.
15:36:32 <nope4323> Eduard_Munteanu: I've tried -optl-static also, hadn't heard of -optc
15:36:58 <typoclass> nope4323: hello, if Eduard_Munteanu's suggestions don't go anywhere, try putting the complete error message on hpaste, and also the command that you ran. it'll help folks here figure out what's going wrong
15:37:00 <typoclass> @where hpaste
15:37:01 <lambdabot> http://hpaste.org/
15:37:02 <tac> anyway, merijn, Idris is currently strict, except for if else statements
15:37:39 <nope4323> typoclass: I'm not getting any kind of error, it is just not statically linking in the gtk libs
15:37:55 <rwbarton> deggis, there's no guarantee that mkStdGen s will be independent for similar values of s
15:38:49 <lispy> I'm not a huge fan of Idris being strict, but given the totality and codata I think it may not be a huge problem
15:38:51 <deggis> rwbarton: ah, okay
15:39:03 <rwbarton> System.Random is not so great in a number of ways
15:39:05 <deggis> (it propably says somewhere and i just didn't read it)
15:39:23 <rwbarton> but you're intended to use the same generator repeatedly, rather than make a bunch of generators and use each once
15:40:03 <deggis> rwbarton: yes that i did know, i was simply amazed by how the first Bool (in this case) in every series is the same
15:40:35 <Eduard_Munteanu> That is a bit weird, if you could predict every sequence started with the same number.
15:40:50 <deggis> at least with seeds [0..10000]
15:40:52 <Eduard_Munteanu> What are you supposed to do, throw away the beginning?
15:41:38 <deggis> i naively thought that by simply varying seeds by hand it would be enough (with System.Random) but it certainly isn't so
15:41:46 <Eduard_Munteanu> Oh well, I guess it's not meant for cryptography.
15:42:03 <deggis> i guess by checking what mwc-random does differently than System.Random i'd learn many thing
15:42:06 <deggis> things*
15:44:13 <rwbarton> well I think if you use newStdGen, the preinitialized seed is better spread over the whole range of inputs
15:44:19 <rwbarton> so that you can't predict the first value
15:45:04 <rwbarton> > take 10 $ randomRs (False, True) $ mkStdGen 0
15:45:05 <lambdabot>   [True,True,True,False,False,True,True,True,True,False]
15:45:07 <rwbarton> > take 10 $ randomRs (False, True) $ mkStdGen 1
15:45:08 <lambdabot>   [True,False,True,True,False,True,False,True,False,False]
15:45:39 <johnw> dilbertRandom = [9..]
15:47:30 <rwbarton> mwc-random is much faster besides, the downsides of mwc-random are (1) doesn't come with ghc (2) not splittable, but split for System.Random sort of doesn't work anyways
15:49:05 <deggis> okay. my codings are such dependency hells that (1) doesn't matter and i'm not sure about (2) :) but thanks, learned a bit
15:55:10 <KBme> does it happen that one returns a Maybe Either?
15:55:28 <johnw> if you want to
15:55:28 <KBme> it seems controted to me, but it also seems logical in this situation
15:55:32 <johnw> Maybe (Either a b)
15:55:36 <KBme> right
15:55:42 <johnw> all depends on the semantics of your situation
15:55:45 <KBme> all right
15:55:45 <johnw> it could be perfectly valid
15:56:12 <johnw> it possible Either a (Maybe b) is closer to what you want
15:56:14 <KBme> yeah, I want to have an error message, but the function might return a nothing  that's not an error
15:56:20 <KBme> AH!
15:56:22 <KBme> yes
15:56:28 <KBme> I think you're right. thanks
15:59:48 <typoclass> how do i get the non-code bits of an .lhs?
16:00:08 <typoclass> (as plaintext. 'bits' in the sense of 'parts')
16:00:28 <lil`nbv4> how do you compile files within a ghci repl? when I type ':1 file' it says "unknown command ':1'"
16:00:50 <c_wraith> l, not 1
16:00:55 <c_wraith> or :load
16:00:56 <typoclass> lil`nbv4: hello, the command is ":l" as in ":load"
16:00:57 <lil`nbv4> oh
16:01:05 * ion suggests a change of typeface.
16:02:21 <ksf_> typoclass, sed -e '/^>/d'
16:03:26 <typoclass> ksf_: erm ok :) that'll work
16:04:43 <ksf_> oh. there's also grep -v, of course.
16:05:16 <ksf_> TIMTOWTDI
16:09:11 <scp> haskell folk
16:09:21 <hpaste> typoclass annotated “WordCount.lhs - any suggested improvements?” with “WordCount.lhs - any suggested improvements? (annotation)” at http://hpaste.org/77092#a77094
16:09:35 <scp> will (a ++ b) be evaluated lazily?
16:09:44 <DMcGill> yes
16:09:51 <scp> oh man, that is so cool
16:10:21 <DMcGill> > take 5 ("123" ++ ['4'..])
16:10:25 <lambdabot>   "12345"
16:10:37 <scp> hmmm
16:10:39 <DMcGill> > take 10 ("123" ++ ['4'..])
16:10:42 <lambdabot>   "123456789:"
16:11:06 <scp> > take 5 ("123456789" ++ undefined)
16:11:08 <lambdabot>   "12345"
16:11:11 <scp> sweet
16:11:11 * hackagebot lens 3.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.1 (EdwardKmett)
16:11:32 <scp> so, no copying has to occur there w/ haskell =]
16:11:43 <DMcGill> unless you say otherwise, everything in Haskell is lazy
16:11:53 <DMcGill> > fst (1, undefined)
16:11:54 <lambdabot>   1
16:12:22 <scp> I'm reading okasaki for the first time
16:12:26 <scp> mind being blown =]
16:12:30 <DMcGill> > [undefined, undefined, "element"] !! 2
16:12:31 <lambdabot>   "element"
16:13:09 <rwbarton> 'take 5 ("123456789" ++ undefined)' still copies the elements of "12345", twice
16:13:36 <scp> rwbarton, how so?
16:13:54 <rwbarton> it copies the list cells at least
16:13:58 <ksf_> rwbarton, the spine, not the elements.
16:14:11 <ksf_> and hopefully the spine copying gets fused away.
16:14:31 <scp> how about
16:14:51 <scp> > foldl (+) 0 ([1, 2, 3, 4, 5] ++ [6, 7, 8, 9, 10])
16:14:53 <lambdabot>   55
16:15:03 <scp> err
16:15:06 <scp> pretend I used foldl'
16:15:24 <johnw> scp: you're one iota away from being sicp
16:15:33 <ksf_> ++ will not have finished evaluating before foldl' hits '6'
16:15:56 <scp> ?src ++
16:15:57 <lambdabot> []     ++ ys = ys
16:15:57 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
16:15:57 <lambdabot> -- OR
16:15:57 <lambdabot> xs ++ ys = foldr (:) ys xs
16:16:11 * hackagebot epub-tools 2.0.0 - Command line utilities for working with epub files  http://hackage.haskell.org/package/epub-tools-2.0.0 (DinoMorelli)
16:16:49 <ksf_> well, yes, depending on implementation.
16:17:00 <ksf_> but those are the data dependencies, and they're always a good approximation.
16:18:04 <scp> ksf_, not sure I understand
16:18:17 <ksf_> not sure it's explainable :)
16:18:30 <scp> johnw, ಠ_ಠ
16:18:39 <ksf_> but rest assured, confusion is the first step to enlightenment.
16:18:49 <johnw> that is so true
16:19:08 <johnw> in fact, seeking out a state of confusion is a fairly fruitful approach to finding enlightenment
16:19:27 * ksf_ thinks johnw is a closet discordian.
16:19:39 <johnw> assuming the confusing nature of your subject is due to its complexity, rather than to its complications
16:24:01 <ziarkaen> I've been asked to give the type signature of the function stranger, defined by stranger f = f f.  I don't think this is possible.  Is it?
16:24:19 <rwbarton> not in Haskell
16:25:14 <ziarkaen> Is there a particularly good way to phrase *why* is isn't possible?
16:25:32 <byorgey> not without a rank-2 impredicative type at least
16:25:55 <rwbarton> well if you try to type check stranger, you will run into an infinite type
16:26:03 <typoclass> > let stranger f = f f in stranger id
16:26:04 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> t1
16:26:21 <byorgey> ziarkaen: yes, you can reason something like this: if f is being applied to something, it must have a function type, like  a -> b.   Since it is being applied to f, the type of f must be a.
16:26:43 <ziarkaen> byorgey, Perfect. Thanks.
16:26:44 <byorgey> (because a function of type  a -> b  can only be applied to arguments of type  a)
16:26:58 <byorgey> hence  a = a -> b,  which is only possible if a is an infinite type, which is not allowed.
16:27:11 <johnw> type recursion!
16:27:27 <byorgey> type recursion is super useful.  infinite types, not so much.
16:27:38 <johnw> infinite type recursion!
16:27:43 <byorgey> hehe
16:27:48 <johnw> by which I mean infinite type recursion!
16:27:53 <shachaf> It's possible to type-check infinite types.
16:27:58 <shachaf> It's just usually not what you want.
16:28:07 <johnw> happy halloween peeps
16:28:14 <johnw> just had a bunch of ghosts and goblins at my door
16:28:17 <fliip> Can lambdabot show how things are evaluated?
16:28:31 <shachaf> Not really
16:28:41 <fliip> ok =)
16:28:44 <shachaf> You can sometimes get away with things like
16:28:48 <shachaf> > foldr f z [a,b,c,d]
16:28:49 <lambdabot>   f a (f b (f c (f d z)))
16:28:58 <shachaf> Which is just a package lambdabot includes.
16:29:07 <DMcGill> :t a
16:29:08 <lambdabot> Not in scope: `a'
16:29:46 <byorgey> fliip: http://bm380.user.srcf.net/cgi-bin/stepeval.cgi
16:30:52 <acowley> what's a shorter word than unchecked or unsafe?
16:31:34 <typoclass> doom
16:31:37 <typoclass> junk
16:31:39 <rwbarton> safe
16:31:45 <acowley> haha
16:31:50 <int-e> bad
16:31:53 <typoclass> bork
16:31:59 <nand`> ba--ah int-e beat me to it
16:32:07 <edwardk> evil
16:32:12 <typoclass> uhoh
16:32:21 <acowley> ooh, evil is pretty good!
16:32:29 <int-e> uhohPerformIO. I like it.
16:32:32 <acowley> It speaks to intention, not quality
16:32:43 <typoclass> stinky
16:32:51 <edwardk> fast
16:33:09 <typoclass> wtf
16:33:32 <typoclass> omgPerformIO
16:33:38 <hiptobecubic> there you go
16:33:53 <hiptobecubic> screwItPerformIO
16:33:57 <int-e> thisWillVoidYourWarranty -- I thought the idea was to make the names long enough that people hesitate to use the functions,
16:34:02 <typoclass> cbaCoerce
16:34:33 <typoclass> cbaToDoItProperlyCoerce
16:34:51 <int-e> (e.g. thisWillVoidYourWarrantyButNeverthelessPerformIO)
16:35:03 <typoclass> ceilingCatIO
16:35:24 <jrajav> int-e: Rather English :P
16:35:43 <jrajav> doBeADandyAndPerformATouchOfIOThereOldChap
16:37:10 <bobolat> it there a pretty way of writing multiple patterns that map to the same expression? so f :: a -> a -> Bool  --- Con a Con b = expr | Str a Str a = expr ? just something that says, whatever the constructors, the expression evaluates to expr?
16:37:11 <acowley> int-e: Yes, but I want to indicate that this is more like handling hot chili peppers.
16:37:30 <int-e> acowley: "hot" then
16:37:36 <acowley> !
16:37:38 <acowley> YES!
16:37:53 <Ralith> bobolat: f _ _ = expr
16:38:02 * acowley goes back and prefixes every function with "hot"
16:38:05 <nand`> unsafeSafePerformIO
16:38:10 <bobolat> yes, but i need the a's in the arguments
16:38:14 <nand`> throw in a mixture of uncertainty
16:38:16 <int-e> acowley: or use color codes. green = safe. red = unsafe.
16:38:18 <acowley> now people will think Paris Hilton is my coauthor
16:38:50 <acowley> nand`: doYouFeelLuckyPunkPerformIO
16:39:23 <ksf_> punkPerformIO is good.
16:40:18 <int-e> acowley: hmm. "yes" is also short. ... so many possibilities.
16:40:42 <Ralith> bobolat: you can't destructure multiple constructors with the same pattern.
16:40:59 <Cale> Ralith: ?
16:41:23 * int-e goes back to painting bikesheds in colors of the rainbow. And octarine.
16:41:30 <ksf_> well, you can, with view patterns.
16:41:55 <Cale> > let f ((x,Just y):zs) = x + y in f [(4,Just 5), (6, Nothing)]
16:41:56 <lambdabot>   9
16:42:18 <ksf_> Cale, you're not matching Nothing and Just at the same time, there, though.
16:42:26 <conal> ML has "or patterns", thanks to Chris Okasaki, IIRC. I've often wished we had them in Haskell.
16:42:27 <Ralith> ^
16:42:30 <jrajav> acowley: Do you seriously just equate Paris Hilton with Clint Eastwood
16:42:37 <typoclass> bobolat: maybe a helper function? "foo (Con a) (Con b) = foo' a b" and "foo (Str a) (Str b) = foo' a b", and then the complicated stuff in foo'
16:42:41 <Cale> Oh, I see what you mean
16:42:57 <startling> Cale: how in the world does that work?
16:43:10 <nand`> what happens when you pass a list shorter than the upper index bound to newListArray?
16:43:12 <Cale> startling: You can nest patterns
16:43:14 <startling> oh, the (:)
16:43:15 <acowley> Next question: do we have a more limited type class that includes just extend from Comonad?
16:43:19 <nand`> are the other values undefined, or does the function itself error?
16:43:21 <startling> Cale: yeah, I see.
16:43:29 <edwardk> acowley: 'Extend' in semigroupoids
16:43:31 <startling> you're just pattern-matching on the head.
16:43:40 <acowley> jrajav: Paris prefixed all my functions with "hot"
16:43:52 <edwardk> it has instances for things like Maybe and []
16:43:53 <jrajav> Phew
16:44:05 <Ralith> Cale: ah, I guess I did phrase that badly
16:44:14 <acowley> edwardk: I can't do duplicated :/
16:44:31 <edwardk> ?
16:44:39 <edwardk> duplicated = extended id
16:44:51 <edwardk> you have something that uses 'duplicated' already?
16:45:01 <acowley> No, my problem is various constraints
16:45:13 <edwardk> on the argument type
16:45:15 <edwardk> ?
16:45:23 <edwardk> then you are off in one-off land ;)
16:45:25 <acowley> Yes
16:45:27 <acowley> exactly
16:45:33 <edwardk> no class for you =P
16:45:36 <acowley> I spend too much time in one-off land
16:45:55 <ivanm> int-e: isn't octarine in the Discworld rainbow though? ;-)
16:45:55 <acowley> If it's not Storable… it's crap!
16:46:04 <edwardk> Storable is vastly overrated
16:46:06 <int-e> > let f (x, fromMaybe 0 -> y) = x+y in map f  [(4,Just 5), (6, Nothing)]
16:46:07 <lambdabot>   [9,6]
16:46:25 <acowley> edwardk: I basically write in StorableHaskell
16:46:32 <edwardk> my condolences
16:46:49 * edwardk looks at himself
16:46:56 <edwardk> and wonders what gadget that is
16:47:09 <lispy> int-e: cute
16:47:16 <acowley> I do a lot of OpenGL/OpenCL/C interop
16:47:26 <acowley> keeping everything Storable makes this rather transparent
16:47:31 <lispy> acowley: do you use any of the standard packages?
16:47:42 <acowley> lispy: ?
16:47:56 <edwardk> acowley: for opengl, etc.
16:48:04 <lispy> acowley: I mean, the Haskell OpenGL binding (OpenGL or OpenGLRaw), or the OpenCL bindings?
16:48:19 <acowley> Oh, yeah, I use OpenGL and OpenGLRaw, and I frequently contribute to the OpenCL package
16:48:24 <lispy> acowley: either way, your feedback would be interesting
16:48:37 <lispy> acowley: which opencl package?
16:48:38 <acowley> I also made and use GLUtil (on hackage) and CLUtil (only on github)
16:48:44 <acowley> it's called OpenCL
16:48:50 <scp> ?src seq
16:48:50 <lambdabot> Source not found. My mind is going. I can feel it.
16:48:52 <lispy> cool. I think I know the one
16:49:05 <acowley> With CLUtil, I think it's pretty close
16:49:27 <lispy> acowley: The next OpenGLRaw will use type aliases for the GLfoo types instead of newtyes
16:49:30 <lispy> newtypes*
16:49:45 <lispy> acowley: I made an announcement on the haskell-opengl list but many people don't follow it
16:49:53 <lispy> So far positive feedback that change
16:49:56 <acowley> lispy: I didn't even know it existed!
16:49:59 <acowley> Yes that's a great change
16:50:13 <startling> what kinds of GLFoos?
16:50:17 <scp> lispy: Does Haskell support OpenGL beyond 1.x?
16:50:20 <lispy> startling: they are kind *
16:50:22 <acowley> scp: yes!
16:50:38 <acowley> I dip into OpenGL 3, but mostly stay in 2.1
16:50:49 <lispy> startling: The types I mean are things like GLfloat, GLdouble, GLenum, GLsizei, etc
16:51:05 <startling> heh, oops, shouldn't have used "kind"
16:51:12 <startling> lispy: weird.
16:51:12 <Ralith> haskell supports an (afaik) complete CFFI, so in theory you can use any C API (such as any OpenGL version) that you like.
16:51:20 <startling> yeah
16:51:20 <lispy> startling: I didn't think you actually meant kind :)
16:51:32 <edwardk> its not quite complete. there are some issues with small struct support
16:51:52 <scp> Ralith, it's much nicer if I don't have to do the ffi-ing myself =P
16:51:53 <prototrout> I'm about to write a program that does some processing and generates a list of images after each "round": what library/binding would be best/easiest to display those on the screen?
16:52:06 <Ralith> edwardk: that seems to be a common element in C FFIs. I take it the calling conventions are hairy?
16:52:10 <Ralith> scp: of course.
16:52:22 <scp> but mostly I'm curious if anyone has written effective OpenGL code in haskell?
16:52:22 <acowley> edwardk: Solution to that: just pass the fields individually and pray to the packing gods
16:52:23 <lispy> prototrout: JuicyPixels does a good job of reading/writing image formats.
16:52:25 <Ralith> scp: it just struck me as strange to ask whether "Haskell" supported those things.
16:52:25 <edwardk> lispy: whenever you ship OpenGLRaw with GLfoo type aliases, i'll think about doing opengl again ;)
16:52:28 <Ralith> oh, sure
16:52:36 <Ralith> depending how you define 'effective', tons.
16:52:38 <lispy> prototrout: To actually put it on the screen? You need a different kind of library than JuicyPixels
16:52:49 <ivanm> lispy: currently trying using Ptr CGraph, etc. and having custom with functions to do all the allocations
16:52:56 <ivanm> seems to be working so far with my peek/poke tests...
16:53:01 <acowley> prototrout: If you can install OpenCV, you can try out my OpenCV bindings on github
16:53:05 <lispy> edwardk: Should happen before Monday
16:53:06 <edwardk> acowley: yes, i've done this. ;) it just bit me when i started doing a bunch of objective c work and needed to pass some structs that turn into a pair of ints packed into an int64
16:53:06 <scp> Ralith: ah, good point, I intended it as "Is there already a good binding" =]
16:53:15 <acowley> protorout: It includes ffi to just show an image in a window.
16:53:15 <edwardk> lispy++
16:53:17 <edwardk> lispy++
16:53:21 <edwardk> you get a double upvote ;)
16:53:46 <prototrout> lispy, thanks; I also have some image reading/writing to do, so I'll probably use JuicyPixels for that.
16:53:49 <scp> like, efficient rendering of 3D scenes? Basically, can it compete with C/C++ for such real-time applications as 3D graphics?
16:53:51 <prototrout> acowley, I'll look into it. Thanks.
16:53:59 <lispy> hehe, thank Trevor Elliott and others. I didn't actually implement the change. I just merged it
16:54:09 <Ralith> scp: depends on the graphics. I wouldn't want to try to do anything cutting edge.
16:54:16 <acowley> prototrout: It works best if your package manager can deal with OpenCV (brew on mac works great)
16:54:24 <Ralith> but you can get a lot done without being Crysis.
16:54:30 <edwardk> i need to go back and dust off my cuda<->opengl code at some point
16:54:33 <acowley> prototrout: A benefit is that you can easily decode/encode videos too
16:54:43 <scp> My impression of Haskell thus far has been that it offers excellent amortized efficiency, but laziness is too unpredictable for real-time stuff
16:54:47 <prototrout> acowley, I'm on Ubuntu so I can probably get it running.
16:54:54 <Ralith> edwardk: why cuda when we have the vastly more portable opencl?
16:54:59 <acowley> I've been doing GPGPU stuff in GLSL recently for maximum compatibility
16:55:03 <acowley> it's surprisingly not that bad
16:55:09 <edwardk> ralith: because there is the vastly less sucky cuda
16:55:23 <Ralith> edwardk: can you elaborate?
16:55:34 <startling> scp, BangPatterns and/or -O2 will help with the latter
16:55:39 <edwardk> opencl is portable, cuda lets me have function pointers, recursion, template metaprogramming, decent APIs, etc.
16:55:41 <lispy> cuda is a higher level language that OpenCL
16:55:43 <Ralith> scp: I understand that it's entirely practical to do quake 3 level graphics, and of course anything you do in shaders won't care what your host app is.
16:55:54 <lispy> I think OpenCL was intended as a target language not something you code in
16:56:03 <acowley> opencl isn't so bad
16:56:07 <Ralith> any haskell-to-OpenCL compilers yet? ^^
16:56:24 <acowley> Ralith: eventually!
16:56:27 <lispy> Ralith: accelerate has a backend for cuda and an experimental backend for opencl
16:56:31 <lispy> and there is Gpipe
16:56:34 <edwardk> opencl supports a bunch of crappy amd cards that have no real notion of a stack to speak of, so you wind up with terrible compute kernels
16:56:50 <edwardk> especially for things like ray-tracing, etc.
16:56:52 <acowley> OpenCL also runs really nicely on the CPU.
16:56:58 <edwardk> there is that
16:57:04 <acowley> It's the right language for multi-core SIMD work
16:57:16 <acowley> So I'd like to target it with an EDSL (hence my AST questions yesterday)
16:57:16 <edwardk> i try to target both, but its hard to get some kernels to work with the opencl model
16:57:30 <acowley> The worst is the inability to spawn new jobs from an OpenCL kernel
16:57:42 <acowley> control keeps bouncing back to the CPU robbing you of precious cycles
16:57:47 <edwardk> e.g. using the nikola observable function application and in cuda turn that into an actual call, but in opencl expand it like i do in AD
16:58:30 <edwardk> that ability to have real calls with real recursion makes a huge difference in kernel size
16:58:48 <Ralith> wait, opencl doesn't support recursion at all? o.O
16:58:50 <lispy> edwardk: does that come at a steep cost?
16:58:53 <Ralith> or is that just a limitation of some hardware
16:58:56 <lispy> Ralith: nope.
16:59:06 <acowley> Yes, well, that is certainly true. But to get good performance from this kind of hardware, you probably don't want too much abstraction over control flow if the perf. will fall off a cliff and splat.
16:59:18 <lispy> the OpenCL variant of C99 that they use disallows recursion and function pointers
16:59:18 <acowley> Ralith: It does loops, though!
16:59:29 <Ralith> lispy: damn.
16:59:37 <edwardk> Ralith: at all
16:59:55 <lispy> The function pointers part almost makes me more sad. It means you can't use a struct with functions in it
17:00:03 <edwardk> lispy: recursion? not terribly. i don't use it a lot, just over the kind of big blocks that its good for
17:00:27 <edwardk> but it is really important for making highly pluggable kernels that can deal with a lot of render paths
17:00:36 <thread__> how can i unbox a value from the IO monad when using readFile and return the read string? can't really use IO for pattern matching
17:00:36 <edwardk> otherwise i waste all my time in code gen
17:01:09 <lispy> thread__: instead of taking the value out IO you put the computation inside the IO
17:01:12 <acowley> cache the code gen!
17:01:28 <lispy> thread__: you are of course, free to define the computation outside of, and independently, of the IO
17:01:49 <josephle> related to that IO question (in a sense), can anyone explain to me the practical benefits of comonads?
17:02:06 <josephle> I understand the categorial theory behind them, but I'm not so clear on how they're useful for computation
17:02:06 <startling> thread__: readFile x >>= \x -> case x of ...
17:02:21 <lispy> thread__: so you might have something like, do { cs <- readFile f; return (length cs) }
17:02:54 <edwardk> josephle: the first thing to understand is you usually won't be structuring your entire application around a comonad. its more that you can have lots of little bits of data that have comonads wrapped around them that carry useful information
17:03:00 <lispy> thread__: We're saying, read the file and name the result cs. Now we return the length of cs.
17:03:21 <edwardk> there are some comonads that have larger scope, but in general you'll live in one monad and interact with a lot of comonads
17:03:37 <thread__> lispy: yea got it
17:03:53 <edwardk> now, there are some useful comonads. we can make a comonadic zipper: data Zipper a = Zipper [a] a [a] into a non-empty list
17:03:54 <thread__> just thought return would give it a monad context
17:04:06 <lispy> thread__: it will
17:04:23 <lispy> thread__: so to continue working on that data you will need to do so inside the IO monad
17:04:28 <josephle> edwardk: Ah, I see
17:04:51 <edwardk> other comonads occur in odd contexts like with lenses. a lens is a store comonad coalgebra. you don't really use the comonad per se, but its there, and the laws for the coalgebra reflect the right structure a lens should have
17:05:17 <startling> josephle: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html is a good application
17:05:31 <josephle> thanks!
17:05:38 <lispy> let fileLen f = do { cs <- readFile f; return (length cs) } :: FilePath -> IO Int. So then you could do { len <- fileLen "/etc/passwd"; print len }
17:05:43 <lispy> thread__: ^^
17:06:18 <thread__> lispy: but what if i want my function returning a value not boxed in the io monad?
17:06:20 <edwardk> josephle: you can use comonads for cellular automata, image manipulation, i use them in my parsers in scala, because in scala monad transformers are nigh unusable, but every comonad gives rise to a monad transformer, etc.
17:06:32 <startling> thread__: you can't.
17:06:45 <hpaste> prototrout pasted “cabal install HOpenCV failed” at http://hpaste.org/77095
17:06:46 <edwardk> i use the store comonad and the 'bazaar' comonad in my lens library.
17:06:51 <startling> thread__: IO isn't a box, it's instructions for creating a value
17:07:22 <edwardk> traced is sort of a dual to a monad writer. its a way to make an object that knows 'what happened to it' a as a log, rather than a monad where you record what you are doing.
17:07:33 <startling> thread__: you can't do anything with that value except by going through the instructions, and the only way to go through the instructions is to call it from main.
17:07:47 <lispy> thread__: you have to go back into the IO context to continue to work on a value that depends on the IO context
17:08:06 <edwardk> (,) e forms something like a reader monad, where you have a piece of environment already present, and can extract (e,a) = a, or extend f w@(e,_) = (e, f w)
17:08:07 <prototrout> acowley, should I grab HOpenCV directly from github, rather than hackage? (See my paste above for the error I'm hitting)
17:08:11 <edwardk> instead of what reader does
17:08:17 <josephle> ok
17:08:20 <lispy> thread__: But nothing stops you from defining lots of non-monadic functions for the type of data that you want to work on. You just use those functions from an IO context
17:08:22 <acowley> prototrout: yes
17:08:24 <thread__> is there then a way to read a file to a string without the IO monad? need it to pass to a given function
17:08:28 <edwardk> and there are comonad transformers so you can mix and match between these
17:08:42 <acowley> prototrout: https://github.com/acowley/HOpenCV
17:08:45 <startling> thread__: you're approaching this in the wrong way.
17:09:01 <thread__> startling: yea probably, i'll try and look more into that
17:09:05 <startling> thread__: write a String -> Whatever function
17:09:14 <edwardk> they also arise in recursion schemes. you can generalize the notion of an anamorphism to take a monad and a distributive law that pushes the monad out of sight. this gives you things like apomorphisms, that are relatively less well known
17:09:19 <startling> thread__: let's say you call it myFunction
17:09:32 <startling> thread__: then do readFile x >>= return . myFunction
17:09:36 <edwardk> but you can also generalize a catamorphism to take a comonad and a distributive law. and these give rise to paramorphisms, zygomorphisms, etc.
17:09:37 <startling> that's an IO Whatever
17:09:53 <edwardk> the fact that most comonads and comonad-transformers have a meaningful interpretation there is interesting
17:10:27 <startling> thread__: the answer isn't to do the impure computation outside of IO, it's to call all the pure computations from inside of IO as well as the impure computations
17:10:43 <josephle> edwardk: that's quite the detailed response! A lot to look up and think about
17:11:06 <edwardk> thats not to mention the data flow processing uses for comonads that uustalu and company came up with (though they were focused on semantics it can be implemented that way directly)
17:11:10 <lispy> thread__: there is unsafePerformIO :: IO a -> a, but this does not have the right behavior. It's really meant for extending the language as it puts a very specific proof burden on the programmer.
17:11:31 <acowley> josephle: edwardk only knows how to give detailed responses that give you a lot to look up and think about.
17:11:43 <prototrout> acowley, does that require GHC 7.6? I'm using the platform (7.4.2) right now.
17:11:49 <edwardk> in other languages "futures" form a comonad as well. (in haskell it'd have to be a comonad over the kleisli category of IO or something)
17:11:56 <prototrout> and it's complaining about having the wrong version of base.
17:11:58 <acowley> prototrout: D'OH! Yes, the head version does require 7.6
17:12:04 <startling> lispy: shhh
17:12:04 <edwardk> on that note i'm going to go get food ;)
17:12:59 <lispy> startling: showing people that using unsafePerformIO will blow up in their face is instructive :)
17:13:29 <thread__> lispy: yea alright, it's just that i need to implement a function of the signature FilePath -> MyType based on the file contents using readFile, but that's impossible since MyType is outside the IO monad
17:13:32 <monochrom> except when unsafePerformIO doesn't blow up
17:14:46 <lispy> thread__: Ah. So this is a good time to mention "separation of concerns"
17:15:06 <lispy> thread__: in this case, you have two concerns: a) getting the data from a file, b) processing a string
17:15:07 <rwbarton> thread__: yes, that is impossible
17:15:32 <lispy> thread__: A common strategy would be to have something like FilePath -> IO String and something else String -> MyType
17:15:57 <startling> thread__: why do you "need" this function?
17:16:31 <acowley> Everyone needs IO String -> String when getting started. It's the rebellion of youth!
17:16:40 <josephle> hahahaha
17:17:20 <thread__> to hookup with some existing code
17:17:26 <startling> thread__: typically you just write a String -> Mything function and then call it from main.
17:17:43 <startling> thread__: that's not going to work.
17:18:02 <monochrom> inseparation of concerns and the rebellion of youth lead the this kind of C++ student code: class ComplexNumber { public ComplexNumber() { cout << "please enter the real part"; cin >> realpart; ...
17:18:15 <monochrom> s/lead the/lead to/
17:18:41 <thread__> right, i'll read up - seems like a good idea
17:18:43 <Ralith> and this is why I do group projects myself
17:18:49 <startling> monochrom: haha
17:19:07 <startling> thread__: if you can paste code somewhere, we can be more specific
17:19:28 <monochrom> "I want the constructor to read input" is the same as "I want FilePath -> MyType to read a file"
17:19:43 <DMcGill> hmm, I have [j1, j2, ..., jn)] and want [j2 - j1, j3 - j2, ..., jn - j(n-1)]
17:19:49 <fruitFly> how do you make a comment?
17:19:55 <DMcGill> I was thinking about doing something abusing laziness
17:20:00 <rwbarton> -- like this
17:20:02 <rwbarton> {- or
17:20:06 <rwbarton> this -}
17:20:21 <fruitFly> rwbarton: thanks
17:20:28 <startling> DMcGill: mything = map (uncurry (-) (zip mylist [1..])
17:20:37 <startling> missed a parens there, you get the idea
17:20:43 <byorgey> DMcGill: zipWith (-) (tail lst) lst
17:20:44 <startling> oh, wait
17:20:49 <ion> > (zipWith (-) =<< tail) [a,b,c,d,e]
17:20:50 <lambdabot>   [b - a,c - b,d - c,e - d]
17:20:54 <DMcGill> oops! I said that wrong sorry
17:20:55 <acowley> a -> (a -> Maybe a) -> a
17:20:56 <DMcGill> let me try again
17:20:58 <acowley> what is its name?
17:20:59 <ion> > (zipWith (-) <*> tail) [a,b,c,d,e]
17:21:01 <lambdabot>   [a - b,b - c,c - d,d - e]
17:21:19 <DMcGill> I want [j1 - j2, j3 - j2, ..., jn - j1]
17:21:33 <lispy> ?hoogle a -> (a -> Maybe a) -> a
17:21:33 <lambdabot> Data.IntMap update :: (a -> Maybe a) -> Key -> IntMap a -> IntMap a
17:21:33 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
17:21:34 <lambdabot> Data.IntMap mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
17:21:35 <startling> DMcGill, is there a pattern?
17:21:48 * byorgey doesn't get the pattern either
17:21:55 <rwbarton> do you mean j2 - j3 in the second position?
17:22:02 <DMcGill> yes, sorry
17:22:05 <DMcGill> it's late
17:22:06 <DMcGill> each element
17:22:14 <DMcGill> is j_i - j_(i+1)
17:22:18 <DMcGill> module n
17:22:21 <byorgey> you can still do it with zipWith (-)
17:22:23 <DMcGill> modulo*
17:22:29 <lispy> :t zipWith (-)
17:22:29 <lambdabot> forall c. Num c => [c] -> [c] -> [c]
17:22:34 <byorgey> with a little extra something to handle  jn - j1
17:22:51 <startling> you could cycle it.
17:22:53 <DMcGill> that's why I was talking about abusing laziness to get a knot or something
17:23:04 <ion> > (zipWith (-) <*> tail . cycle) [a,b,c,d,e]
17:23:06 <lambdabot>   [a - b,b - c,c - d,d - e,e - a]
17:23:11 <DMcGill> great, thanks
17:23:28 <startling> woah, neat, didn't know lamdabot could do that
17:23:41 <lispy> startling: it's actually just Haskell
17:23:47 <lispy> startling: a clever instance of Num
17:23:54 <lispy> :t a
17:23:54 <lambdabot> Not in scope: `a'
17:23:56 <startling> lispy: oh, ha
17:24:06 <ion> > typeOf a
17:24:07 <lambdabot>   SimpleReflect.Expr
17:24:12 <startling> I guess a - b is "a - b" ?
17:24:14 <byorgey> @where expr
17:24:14 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
17:24:18 <startling> :t a - b
17:24:19 <lambdabot> Not in scope: `a'
17:24:19 <lambdabot> Not in scope: `b'
17:24:26 <byorgey> you can read about it there ^^^
17:24:29 <lispy> :t a - b :: Expur
17:24:29 <gds> :t (<*>)
17:24:30 <lambdabot> Not in scope: `a'
17:24:30 <lambdabot> Not in scope: `b'
17:24:30 <lambdabot> Not in scope: type constructor or class `Expur'
17:24:30 <lambdabot> forall (f :: * -> *) a b. Applicative f => f (a -> b) -> f a -> f b
17:24:32 <aninhumer> > print a
17:24:34 <lambdabot>   <IO ()>
17:24:35 * lispy can't type
17:24:45 <aninhumer> >show a
17:24:45 <josephle> :t cycle
17:24:46 <lambdabot> forall a. [a] -> [a]
17:24:54 <lispy> aninhumer: you need a space after ">"
17:25:00 <lispy> > show a
17:25:01 <lambdabot>   "a"
17:25:04 <lispy> > text a
17:25:05 <lambdabot>   Couldn't match expected type `GHC.Base.String'
17:25:06 <lambdabot>         against inferred typ...
17:25:08 <aninhumer> > show a
17:25:09 <lambdabot>   "a"
17:25:17 <lispy> > show $ a + b
17:25:18 <lambdabot>   "a + b"
17:25:33 <startling> > show $ zip [a] [b]
17:25:34 <lambdabot>   "[(a,b)]"
17:25:54 <startling> > show $ join (+) a
17:25:55 <lambdabot>   "a + a"
17:26:03 <rwbarton> not sure what all this "show" is supposed to achieve
17:26:09 * Ralith reminds everyone that lambdabot accepts PMs
17:26:19 <ion> > (show . show . show . show) (zip [a] [b])
17:26:22 <lambdabot>   "\"\\\"\\\\\\\"[(a,b)]\\\\\\\"\\\"\""
17:26:25 <aninhumer> incedentally, why is >show a :: forall a. [a] -> [a] ?
17:26:33 * startling show rwbarton. startling will show them all!
17:26:43 <ion> show a :: String
17:26:44 <josephle> aninhumer: I did a :t cycle right before you
17:27:11 <thread__> startling: i just have a function i need to call with that signature ... FilePath -> MyType
17:28:29 <startling> thread__: how many times do we have to tell you? you can't.
17:28:35 <startling> you're going to need to reorganize code.
17:29:36 <thread__> alright, i'll rethink the library
17:29:41 <Ralith> such a function would make no sense; haskell functions must always return the same output for the same input, and a function like you describe would return different output if the file was edited.
17:29:54 <Ralith> (or absent)
17:30:06 <aninhumer> rwbarton: I think the point was that free variables take an expression type?
17:30:28 <aninhumer> and that
17:30:35 <aninhumer> > show a + b
17:30:36 <lambdabot>   Couldn't match expected type `GHC.Base.String'
17:30:37 <lambdabot>         against inferred typ...
17:30:43 <aninhumer> > show $ a + b
17:30:45 <lambdabot>   "a + b"
17:30:50 <aninhumer> demonstrates this well
17:31:01 <rwbarton> you could demonstrate it just as well without "show $"
17:31:09 <rwbarton> there is a show implicitly, anyways
17:31:26 <aninhumer> > a + b
17:31:27 <lambdabot>   a + b
17:32:29 <aninhumer> Well, there is a difference at least, but point taken
17:33:11 <edwardk> > a + b + c
17:33:13 <lambdabot>   a + b + c
17:33:20 <startling> thread__: rewrite your thing as String -> Mything
17:33:28 <startling> thread__: or FilePath -> String -> Mything
17:33:33 <edwardk> just checking if it overenthusiastically paren'd
17:34:04 <rwbarton> > a + (b + c)
17:34:06 <lambdabot>   a + (b + c)
17:35:03 <aninhumer> > (False && a) || b
17:35:05 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:35:05 <lambdabot>         against inferred type ...
17:35:08 <aninhumer> boo
17:35:30 <byorgey> > (a && b) || c
17:35:31 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:35:31 <lambdabot>         against inferred type ...
17:35:42 <DMcGill> they're a num instance
17:35:43 <byorgey> oh, duh, && and || are not type-class polymorphic
17:35:46 <rwbarton> unfortunately(?) the boolean operators are not overloaded
17:35:49 <DMcGill> it's not like Bool are a type class
17:35:58 <aninhumer> Oh right yeah
17:36:06 <aninhumer> silly Prelude
17:36:20 <byorgey> yes, but perhaps it should be? =)
17:36:28 <DMcGill> @src gcd
17:36:28 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
17:36:28 <lambdabot> gcd x y = gcd' (abs x) (abs y)
17:36:29 <lambdabot>    where gcd' a 0  =  a
17:36:29 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
17:36:54 <DMcGill> is it worth shortcircuiting gcd?
17:37:14 <DMcGill> i.e. I have
17:37:15 <DMcGill> gcds' current [] = current
17:37:19 <DMcGill> gcds' 1       _  = 1
17:37:20 <twanvl_> that first line of gcd is a bug (IMO)
17:37:24 <DMcGill> gcds' current (x:xs) = gcds' (gcd current x) xs
17:37:32 <DMcGill> could I just replace what with a fold and be done with it?
17:37:39 <rwbarton> a bug that got fixed!
17:37:46 <DMcGill> I think this certainly counts as "premature optimisation"
17:38:08 <nand`> > gcd 0 0
17:38:09 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
17:38:35 <nand`> oh, old version of GHC
17:38:37 <rwbarton> guess that is how we will know when Cale updates lambdabot to 7.4
17:38:49 <nand`> it's still on 6.some.ungodly.version
17:38:54 <startling> 6.66?
17:38:58 <nand`> heh
17:39:04 <nand`> I've been hoping for lambdabot on 7.6.1
17:39:18 <nand`> except it doesn't compile and I'm too lazy to update it
17:39:41 <flkzt> does GHC do any automatic unboxing of floats, or is the # thing always required?
17:42:00 <ivanm> lispy: ZOMG, this latest version seems to work without segfaulting! :o
17:42:09 <flkzt> It's not clear to me why floats need to be boxed at all. I usually associate that with dynamic type languages that require tag bits.
17:42:42 <ivanm> flkzt: you can pass -funbox-strict-fields to ghc, that will automatically unbox floats that it can
17:42:48 <rwbarton> laziness and polymorphism are two potential reasons
17:42:58 <ivanm> but most types in Haskell are boxed, for reasons rwbarton pointed
17:43:05 <ivanm> s/$/ out/
17:43:18 <ivanm> note that unboxed values don't have bottom
17:43:54 <rwbarton> i certainly hope that ghc can do strictness analysis and unbox floats into registers in tight loops the same way it can for Int, though
17:44:35 <shachaf> If you have a strict float field inside a data structure, you can have it be unpacked automatically.
17:45:32 <flkzt> Is there a way to automate the defining of strictness? Like a strict section of definitions, or something.
17:45:33 <rwbarton> also {-# UNPACK #-} doesn't require you to literally type a '#'
17:45:40 <rwbarton> oh
17:45:42 <shachaf> rwbarton It requires two of them!
17:45:42 <rwbarton> i guess it does :)
17:45:52 <flkzt> I have a bunch of formulas, and it'd be nice to not litter them all with strictness annotations.
17:45:56 <shachaf> But -funpack-strict-fields doesn't.
17:45:59 <shachaf> Or is it unbox?
17:46:07 <shachaf> Yes.
17:46:09 <startling> funbox and funpack sound so dirty.
17:46:10 <rwbarton> i believe it is unbox
17:46:31 <ivanm> flkzt: bang the fields in your data structures
17:46:39 <ivanm> rwbarton: it is, I listed the option earlier
17:46:55 <rwbarton> yes
17:47:06 <shachaf> Fun box, strict field.
17:47:07 <rwbarton> bang them and then funbox them
17:47:18 <ocharles> I've been playing around with my 3-way-merging stuff a bit more, and also experimenting with my new excitement of composed applicative functors, and have https://gist.github.com/e0654d335ec2b017ef61
17:47:23 <ocharles> I wondered if anyone here had any thoughts
17:47:42 <flkzt> ok thanks all for the tips
17:47:44 <ocharles> one potential problem I see, is that it's technically possible to have Compose (["Some Conflicts"], Just "But success!") which is madness
17:48:13 <ocharles> if I newtype Merge, I can at least prevent that, but it smells to me that maybe this isn't the composition of some primitave applicatives at all
17:49:26 <rwbarton> what's the purpose of Merge as opposed to Either [Conflict]?
17:49:33 <flkzt> I suppose I am weighing the pros and cons of using haskell for scientific computing. More abstract / more knowledge required / complexities with boxing versus simpler / less complex /  conventional numerics
17:49:38 <ocharles> rwbarton: probably nothing :)
17:49:50 <ocharles> but I couldn't see an instance of Either that was applicative, and took a monoid
17:49:54 <rwbarton> oh yeah
17:50:06 <rwbarton> oh i see
17:50:23 <ocharles> so maybe I should newtype around Either and write my own applicative instance
17:50:25 <rwbarton> this Merge automatically has the right Applicative instance, is that the idea
17:50:25 <rwbarton> yeah
17:50:39 <rwbarton> right Applicative instance but wrong underlying type :)
17:50:49 <rwbarton> I would just do what you said last
17:51:37 <ocharles> ok. away from the representation a moment... the thing that gets messy is applying merges for more complex types. E.g., Artist <$> mergeEq "name" (artistName cur) (artistName new) (artistName anc)
17:51:51 <ocharles> i'm not really sure what I can do to ease that pain
17:52:09 <ocharles> (that would be the way to do a 3 way merge on 'artists', sort of building up on the principle of mergeEq)
17:52:12 <flkzt> If have am doing a bunch of linear algebra with array, matrices, etc, would you honestly recommend haskell? Or shall I just go the conventional route of matlab or whatever.
17:52:26 <DMcGill> well matlab is super super slow
17:52:41 <ivanm> lispy: now my Haskell code is only 8x as slow, even with nf! (as opposed to 40x previously); the fact that I'm forcing it to clone a graph by traversing the entire node and edge arrays might help explain that... :p
17:52:48 <DMcGill> it's not even compiled
17:53:01 <DMcGill> unless you pay extra
17:53:11 <rwbarton> flkzt: i hear that hmatrix is good for this sort of computing
17:53:14 <rwbarton> though I don't know how good
17:53:41 <flkzt> well afaik once the matrices are in there, matlab is internally fast since it's just calling fortran routines underneath
17:54:02 <flkzt> even if the dressing is slow
17:54:20 <rwbarton> same with hmatrix, possibly even the same fortran routines
17:54:46 <flkzt> ok i'll look at it, thanks
17:55:00 <ivanm> rwbarton: nah, matlab has more fortran/C routines under the hood that are probably more optimised
17:55:36 <carter> flkzt hmatrix is nice, its internals are just blas and gsl
17:56:23 <carter> flkzt: whats your problem domain / use case?
17:57:06 <carter> depending on the specific domain, theres a lot of great tools
17:57:11 <carter> and theres A LOT more pending :)
17:58:33 <carter> though untill some code by geoff mainland makes ghc aware of more float/double registers,  certain types of numerical code will be ~ 4x-8x slower than SSE assembly intrinsics in C or fortant
17:58:37 <carter> *fortran
17:59:22 <mrlemao1> How do I unwrap the return value from a stack of 3 monads StateT > Process -> IO?
18:10:14 <nope4323> anyone have a clue how to get cabal to build dependencies in statically?  I'm trying to build a gtk project and would like a single executable as the result
18:11:11 <zeiris> I'd like to know too. A static build of gitit would be nice.
18:11:37 <carter> zeiris nope4323 , what does your cabal .config file say youre building as by default?
18:12:02 <carter> zeiris if ghc is building static libs, the binary should be there too
18:12:24 <carter> nope4323: are you refeerring to static linking to the cpp gtk libs?
18:12:30 <carter> or just the haskell?
18:12:45 <nope4323> carter: I have tried ld-options: -static and ghc-options: -optl-static
18:12:49 <ocharles> rwbarton: I'm not sure Either does work actually. sure that means that at the first failure, the 'left hand' side of <*> becomes Left, and thus I can't try and further merges
18:13:04 <ocharles> i.e., (,) <$> merge1 <*> merge2 -- if merge1 fails, then merge2 can never run, can it?
18:13:08 <nope4323> I get no errors, everything builds, but the executable is small and still requires .dll's
18:13:08 <carter> nope4323: unless you have the static lib version of gtk
18:13:27 <carter> I think you can't do that unless youv'e got the static lib version
18:13:32 <rwbarton> ocharles: well it can "run"
18:13:43 <ocharles> rwbarton: oh wait, of course it can, it just can't store its result anywhere, but that's fine
18:13:50 <rwbarton> not if it succeeds, right
18:13:52 <ocharles> yea
18:13:54 <rwbarton> but if it fails, you will get both errors
18:13:58 <ocharles> and if it fails, I mappend
18:14:02 <rwbarton> right
18:14:03 * ocharles shuts up and writes code
18:14:06 <hdev> Say I have a data R = R Int Int Int, is there a function like apply :: (Int -> Int) -> R -> R -> R?
18:14:19 <nope4323> carter: not sure what you mean by static lib version of gtk, i have a bunch of gtk .a files in the gtk/lib directory
18:14:30 <carter> ok
18:14:51 <carter> what os and arch?
18:14:52 <rwbarton> sounds like a yes
18:14:53 <ion> hdev: data R a = R a a a deriving Functor; fmap :: (Int -> Int) -> R Int -> R Int
18:14:56 <shachaf> hdev: As in apply (*) (R x y z) (R x' y' z') = R (x * x') (y * y') (z * z') ?
18:15:10 <nope4323> carter: windows 64bit
18:15:13 <carter> ok
18:15:18 <ion> Oh, like that.
18:15:22 <carter> i have no clue how to helpyou :)
18:15:32 <rwbarton> neither of those answers matches the type in the question
18:15:32 <nope4323> carter: yeah, no one does
18:15:59 <shachaf> rwbarton: Hmm? Mine seems to.
18:16:10 <rwbarton> your (*) is binary
18:16:11 <carter> try to bulid the gtk2hs libs with only the static object versions of the gtk c/cpp libs visible
18:16:16 <carter> rather than the dlls too
18:16:21 <carter> OR, write an installer :)
18:16:23 <rwbarton> mind you, this is likely because the question was wrong
18:16:28 <shachaf> rwbarton: Oh, wait.
18:16:30 * shachaf sighs.
18:16:50 * ion huohs.
18:16:54 <hdev> ion: this is what I wanted, thank you
18:17:01 <hdev> shachaf: yes
18:17:05 <nope4323> carter: that's what i'm doing.. i'm only including the gtk/includes and gtk/libs paths
18:17:12 <nope4323> carter: it all builds fine, still requires the .dlls
18:17:31 <carter> nope4323 did you start with building gtk2hs like that?
18:17:41 <carter> i'd suggest emailing the mainter and asking nicely
18:17:49 <ajcave_> Haha I just read about Rust for the first time. It seems like it's designed to deceive Java/C/Ruby programmers into starting functional programming. I like.
18:17:52 <nope4323> carter: i'm using cabal-dev, i've deleted cabal-dev multiple times to attempt to rebuild everything
18:18:07 <nope4323> carter: deleted the cabal-dev build directory
18:18:12 <rwbarton> does cabal build -fstatic work? or appear to do anything differently
18:18:13 <carter> nope: sounds like you really should talk with the gtk2hs director
18:18:26 <carter> *maintainer
18:19:04 <nand`> (I don't know what this is about, only read the bottom line but I should note that gtk2hs is currently incompatible with GHC 7.6.1, if that's causing your problems)
18:19:12 <rwbarton> also there might be a non-haskell specific windows-y way to turn your dynamic executable + gtk DLLs into a static executable
18:19:30 <nope4323> nand: i'm on 7.4 it compiles fine
18:19:44 <nand`> okay, disregard me
18:20:05 <shachaf> rwbarton: I think you can just put the .dll in the same directory in Windows to have an executable use it?
18:20:10 <shachaf> That might be good enough.
18:20:11 <nand`> in retrospect I should probably have read what this is about in the first place; I blame tiredness giving me bad ideas
18:20:16 <shachaf> What happens with GMP on Windows, anyway?
18:21:22 <nope4323> rwbarton: i'm trying out -fstatic now, we'll see
18:21:33 <rwbarton> i may or may not have just made that up
18:21:34 <rwbarton> it's hard to tell
18:21:50 <rwbarton> i remember someone here asking for advice on getting cabal to build a statically linked executable
18:21:52 <centrinia> What about GMP?
18:21:53 <nope4323> rwbarton: googling it shows a bug discussion about it.. but this is the first mention i've seen online of it
18:22:07 <shachaf> centrinia: Licensing issues prevent it from being statically linked, right?
18:22:07 <rwbarton> oh
18:22:13 <rwbarton> this was them: http://hpaste.org/75925
18:22:20 <nand`> rwbarton: yeah, a self-extracting zip archive
18:22:25 <nand`> that unpacks the .dlls + .exes to some temp folder then runs that; surely would do the job, no?
18:22:52 <johnw`> this was them is like saying I am me
18:22:55 <rwbarton> so try 'ghc-options: -static' or more stuff from that line
18:23:19 <nand`> shachaf: doesn't that depend on the license of your program?
18:23:25 <nand`> I thought it just forces your program to be GPL or something
18:24:06 <shachaf> nand`: Well, OK.
18:24:39 <nand`> licensing issues are like encoding issues; the only way to retain sanity is to just ignore them and pray nothing goes wrong
18:24:47 <startling> only if you give out the binaries, right?
18:24:50 <shachaf> @slap nand`
18:24:50 * lambdabot is overcome by a sudden desire to hurt nand`
18:24:58 <shachaf> You and I both, lambdabot.
18:24:59 <startling> if it's server-side, you don't have to do anything, do you?
18:26:08 <rwbarton> as far as I can tell, according to The Internet the GHC/GMP GPL licensing issue is The User's Problem.
18:26:20 <nand`> startling: you could email and ask rms
18:26:37 <rwbarton> http://haskell.forkio.com/gmpwindows but this is sort of old
18:27:48 <rwbarton> nope4323: did you try building with 'ghc-options: -static -optl-static' ?
18:28:14 <nope4323> rwbarton: yes
18:28:27 <nope4323> rwbarton: i also finished building with -fstatic and that didn't work
18:28:38 <rwbarton> yeah the -fstatic thing in retrospect i don't expect to work
18:28:48 <rwbarton> that is probably a flag for some specific cabal file which defines that ghc-options setting
18:29:51 <nope4323> ugh, i don't like giving up on things, but i'm about at that point
18:29:53 <rwbarton> what happened with -static -optl-static?
18:30:07 <nope4323> rwbarton: builds fine, doesn't produce a standalone executable
18:30:11 <rwbarton> heh
18:30:37 <rwbarton> well that is unhelpful
18:32:18 <startling> isn't there a way to build with an alternative to gmp written in haskell?
18:32:27 <startling> it might require rebuilding ghc, too
18:33:43 <startling> OverloadedStrings should give you "" for mempty.
18:44:15 <startling> what typeclass do I need to have `sequence' on some structure? Foldable?
18:44:21 <startling> or is this what Traversable is for?
18:44:47 <shachaf> sequence need Traversable
18:44:51 <shachaf> sequence_ just need Foldable
18:44:55 <johnw> startling: there are multiple definitions for sequence
18:45:02 <shachaf> My "s" key isn't working very well...
18:45:03 <johnw> the most general one is in Traversable
18:45:14 <johnw> hachaf: why?
18:45:20 <shachaf> johnw: "the most general one" -- never say that in #haskell!
18:45:37 <johnw> the one that is applicable to the widest range of values?
18:45:40 <johnw> :t sequence
18:45:41 <lambdabot> forall (m :: * -> *) a. Monad m => [m a] -> m [a]
18:45:45 <johnw> that one is only for Monad
18:45:53 <byorgey> only for Monad, and only for lists
18:45:55 <johnw> Traversable.sequence is for any Traversable
18:45:58 <byorgey> :t sequenceA
18:45:59 <lambdabot>     Not in scope: `sequenceA'
18:45:59 <lambdabot>     Perhaps you meant one of these:
18:45:59 <lambdabot>       `sequence' (imported from Prelude),
18:46:07 <johnw> yeah, and only for just lists
18:46:08 <startling> oh, I see where i was unclear.
18:46:08 <byorgey> :t Data.Traversable.sequenceA
18:46:08 <shachaf> johnw: sequenceOf is for any Traversal. :-)
18:46:09 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Applicative f, Data.Traversable.Traversable t) => t (f a) -> f (t a)
18:46:19 <startling> I have a tree of monadic actions; I want to sequence those actions.
18:46:28 <byorgey> :t Data.Traversable.sequence
18:46:29 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
18:46:35 <byorgey> startling: use that ^^^
18:46:37 <johnw> o
18:46:38 <johnw> h
18:46:39 <startling> k
18:46:42 <hpaste> mrlemao pasted “How to unwrap the state and return value from this?” at http://hpaste.org/77097
18:46:45 <johnw> i didn't realize it also had the Monad constraint
18:46:58 <byorgey> startling: oh, do you care about the outputs of the actions?
18:47:00 <johnw> i'll have to remember sequenceA
18:47:12 <startling> byorgey: nope
18:47:16 <shachaf> mrlemao1: You can't.
18:47:22 <byorgey> startling: ah, then you'll want  sequence_
18:47:28 <shachaf> mrlemao1: Assuming Process is some sort of IOy monad.
18:47:31 <byorgey> :t Data.Foldable.sequence_
18:47:32 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Foldable.Foldable t) => t (m a) -> m ()
18:47:35 <byorgey> startling: ^^^
18:47:35 <johnw> shachaf: surely I can say "the more general one"?
18:47:41 <startling> byorgey: right. thanks!
18:47:46 <mrlemao1> shachaf: afaik, Process is wrapping IO
18:47:52 <shachaf> mrlemao1: So you can't.
18:47:58 <shachaf> You might as well ask how to turn IO String to String.
18:47:58 <johnw> :t Data.Foldable.sequenceA_
18:47:59 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Applicative f, Data.Foldable.Foldable t) => t (f a) -> f ()
18:48:24 <johnw> ppsst... over here, you see this call to unsafePerformIO?  The first one is free...
18:48:27 <byorgey> johnw: *a* more general one. =)
18:48:35 <johnw> byorgey: point taken
18:48:40 <mrlemao1> shachaf: but how can I do this then? I would like to add a layer above Process so I can attach my own state and I would like to get the result of the initialize/handle/etc calls
18:49:07 <ocharles> grrr, all my mail is bouncing to haskell cafe :(
18:49:35 <shachaf> mrlemao1: You'll have to do everything "inside" Process.
18:49:37 <mrlemao1> shachaf: I want to thread the "server" state through calls to initialize/handle/terminate + allow the method to return values
18:49:43 <ocharles> oh good, i've signed up as @googlemail.com
18:49:59 <shachaf> mrlemao1: OK, so do that.
18:50:12 <shachaf> StateT isn't giving you any magic powers. It's just threading some state for you.
18:50:15 <johnw> edwardk: what's an example of using sequenceOf?
18:50:56 <mrlemao1> shachaf: so do that what? explicitly thread the state as an argument and don't use StateT?
18:51:00 <edwardk> sequenceOf_ both (putStrLn "hello", putstrLn "there")
18:51:27 <johnw> what if it was a [IO ()]?
18:51:42 <johnw> sequenceOf_ view xs?
18:51:44 <edwardk> sequenceOf_ traverse
18:51:54 <johnw> ah
18:51:56 <shachaf> sequenceOf_ folded :-)
18:51:57 <edwardk> or sequenceOf_ folded
18:51:59 <shachaf> mrlemao1: Or do you use StateT, but don't pretend it can get you out of Process.
18:52:13 <johnw> i don't grok the traversal side of lenses at all yet
18:52:23 <shachaf> runServer :: StateT s Process () -> Process s -- or something
18:52:34 <shachaf> johnw: Traversal is the central concept of Control.Lens, I think.
18:52:41 <shachaf> Once you figure that out everything makes sense.
18:52:54 <johnw> what is the current best resource for figuring that out?
18:53:14 <shachaf> Bugging someone on IRC? :-)
18:53:16 <startling> yeah, I don't get that either. :/
18:53:34 <shachaf> edwardk has some nice slides somewhere but I suspect they're not very useful on their own.
18:53:34 <startling> haskellers really need to start writing not-monad tutorials.
18:53:53 <shachaf> I can clarify it in #haskell-overflow in a bit if you'd like.
18:54:00 <johnw> shachaf: yes please
18:54:56 <johnw> shachaf: i tried to read them on their own, and they weren't
18:56:48 <mrlemao1> shachaf: so maybe the issue here is that I shouldnt be stacking StateT on top of Process, but have a loop::Process() that in turn calls initialize/handle/terminate?
18:57:20 <johnw> loop::Process() looks scarily like a C++ function call :)
18:57:27 <rwbarton> i thought it was too
18:57:32 <johnw> loop :: Process ()
18:57:35 <johnw> feels so much better...
18:57:38 <mrlemao1> :-)
18:58:30 <spckd> What is this error about and how can I fix it? I am getting it when attempting to build scion. src-execs\Server.hs:130:10: Not in scope: `NL.send'
19:02:48 <flkzt> Is there a reason that 62-bit floats are not implemented in boxing language implementations such as GHC and Lisp? Is the overhead for boxing smaller than the implementation of 62-bit (or whatever bit) floats?
19:03:20 <flkzt> floats could be tagged just like fixed-size integers
19:03:55 <shachaf> flkzt: GHC doesn't do the 29-bit integer thing, as far as I know.
19:08:43 <rwbarton> there is that clever Double tagging trick that js implementations use
19:09:29 <rwbarton> or some anyways
19:09:49 <flkzt> shachaf: so are Ints boxed too by default?
19:10:10 <shachaf> flkzt: In general, yes.
19:10:29 <shachaf> As rwbarton mentioned, there are all sorts of tricks GHC might do involving the strictness analyzer and what not.
19:11:17 <rwbarton> http://evilpie.github.com/sayrer-fatval-backup/cache.aspx.htm#post-485
19:11:22 <flkzt> Is GHC able to do a global pass on the final program, or can it only analyze per object file compiled?
19:11:57 <shachaf> Well, GHC does a lot of cross-module inlining.
19:12:01 <monochrom> the answer is somewhere in-between
19:12:52 <flkzt> In principle, GHC could unbox everything that's unboxible, given a whole program, right? It's only a matter of whether the programmer resources are feasible to do that.
19:13:02 <shachaf> @let blah = 1
19:13:02 <lambdabot>  .L.hs:6:1:
19:13:02 <lambdabot>      Failed to load interface for `Control.Arrow.Operations'
19:13:02 <lambdabot>     ...
19:13:03 <Eduard_Munteanu> Even typechecking requires looking into other files, since you don't do what C does with headers.
19:13:06 <shachaf> Cale: ☝
19:13:16 <Cale> hmm
19:13:18 <shachaf> flkzt: Well, there's still laziness...
19:13:42 <rwbarton> > gcd 0 0
19:13:43 <lambdabot>   *Exception: Prelude.gcd: gcd 0 0 is undefined
19:13:57 <rwbarton> too bad i can't catch that exception
19:14:00 <rwbarton> hm
19:14:33 <Cale> spckd: It means that whatever module NL is (you'll have to examine the imports of Server.hs to see what that is) doesn't export anything with the name 'send'
19:14:47 <shachaf> rwbarton: spoon to the rescue!
19:14:59 <flkzt> shachaf: but in my GHC fantasy world where everything that is determinable is determined, GHC would know exactly what needs laziness and what doesn't, right? Given a whole program to analyze (not piecemeal).
19:15:05 <rwbarton> no need my friend!
19:15:29 <shachaf> flkzt: In your fantasy world, does GHC solve the halting problem?
19:15:33 <rwbarton> @@ @run text (if (@show (@run 0)) == "  0\n" then "yay, ghc 7.4!" else "Cale, fix lambdabot!")
19:15:36 <lambdabot>   yay, ghc 7.4!
19:15:36 <rwbarton> oops
19:15:37 <Eduard_Munteanu> Let it crash.
19:15:41 <rwbarton> @@ @run text (if (@show (@run gcd 0 0)) == "  0\n" then "yay, ghc 7.4!" else "Cale, fix lambdabot!")
19:15:43 <lambdabot>   Cale, fix lambdabot!
19:15:44 <Eduard_Munteanu> Wait, this isn't #erlang. :P
19:16:03 <flkzt> shachaf: Is GHC's type system turing complete? I thought it wasn't.
19:16:26 <shachaf> flkzt: What does this have to do with the type system?
19:17:35 <flkzt> shachaf: you're saying that determining what things can be strictified amounts to solving the halting problem?
19:18:37 <shachaf> flkzt: Seems pretty likely to me.
19:19:13 <monochrom> in my fantasy world, llvm recognizes it if you write a bubble sort algorithm, and replaces it with a real sort algorithm
19:20:21 <startling> monochrom: haha
19:46:56 <gwern> @quote edwardk
19:46:57 <lambdabot> edwardk says: A Computer Scientist is a Mathematician who took the maxim "if you can't say something constructive, don't say anything at all" literally.
19:48:07 <shachaf> @quote gwern
19:48:07 <lambdabot> gwern says: J'accuse tu, Pikachu!
19:49:37 <ludamad> Done lots of programming before ... haskells kicking my ass
19:49:47 <ludamad> Starting to wrap my head around it
19:55:17 <Cale> ludamad: feel free to ask any questions
19:55:35 <ion> All the languages you used before were probably CLispScripts. :-)
19:56:05 <ludamad> ion, well, I wrote a scripting language with only pure functions :)
19:56:21 <ludamad> if that counts as any different
19:57:06 <ludamad> (to clarify, it was the scripting language that only had pure functions)
19:57:42 <latro`a> "A man saw a woman on a mountain with a telescope"...
19:59:02 <ludamad> bfevalImpl :: BFState -> IO BFState
19:59:02 <ludamad> bfevalImpl = do
19:59:02 <ludamad> 	putStrLn "Hello World!"
19:59:02 <ludamad> 	return bfStartState
19:59:07 <ludamad> what am I doing wrong here ?
19:59:30 <byorgey> ludamad: you declared bfevalImpl to take an argument, but you didn't give it one
19:59:34 <Cale> ludamad: You said that bfevalImpl is a function, but it doesn't have a parameter
19:59:46 <ludamad> ahh
19:59:48 <ludamad> touche
20:00:29 <byorgey> and if there's one thing the Haskell compiler really hates, it's hypocrisy ;)
20:00:52 <rwbarton> That and type errors.
20:01:07 <shachaf> byorgey: Hypocritically, the compiler itself doesn't mind being hypocritical.
20:02:06 <vamega1> Hi
20:02:14 <vamega1> I'm reading through Learn you a Haskell
20:02:16 <byorgey> hi vamega1
20:02:31 <byorgey> welcome, feel free to ask questions in here
20:02:34 <vamega1> and I was wondering if someone was aware of questions I could solve to cement my understanding of the material
20:02:34 <monochrom> you can use unsafeCoerce
20:03:18 <vamega1> I've realized that just reading the book is useful, but I only ever learn the concepts, and don't really remember the syntax until I actually write code
20:03:23 <byorgey> vamega1: http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
20:03:31 <startling> byorgey beat me.
20:04:01 <vamega1> Thanks
20:04:05 <vamega1> I'l go through that.
20:05:55 <ion> I’ve got ninety-nine Haskell problems but unsafePerformIO ain’t one.
20:06:06 <ludamad> vamega1, I realized that when I tried to dive into haskell... starting with a really dumb sort and making it efficient was fun
20:06:22 <startling> vamega1, writing a "real" application is lots of fun too
20:06:44 <hpaste> Marzhall pasted “Errors with map and trying to fold a tree into a Map” at http://hpaste.org/77098
20:06:48 <ludamad> My 'real' application atm is a brainfuck interpreter
20:06:49 <ludamad> :)
20:06:54 <monochrom> writing a real application requires already knowing a substantial subset of haskell
20:07:32 <ludamad> does return a == do return a ?
20:07:37 <monochrom> yes
20:07:39 <shachaf> x === do x
20:08:09 <dolio> x =/=/==/= do x
20:08:30 <vamega1> The ghc-mod package on hackage
20:08:37 <vamega1> Do I install that with cabal?
20:10:06 <monochrom> yes
20:10:13 <shachaf> Cale: What's going on with lambdabot?
20:10:25 <shachaf> Is it just a matter of installing a package or something?
20:10:35 <shachaf> For @let, I mean.
20:10:37 <byorgey> vamega1: yes, but I think there might be some extra installation steps required
20:10:52 <Ralith> is it safe to move to ghc 7.6 yet?
20:10:53 <byorgey> vamega1: see http://www.mew.org/~kazu/proj/ghc-mod/en/
20:11:07 <vamega1> byorgey, I'm there right now, and looking into it
20:11:08 <vamega1> thanks
20:11:18 <monochrom> @undefine
20:11:20 <shachaf> Ralith: Well, I use 7.6.
20:11:26 <Ralith> good enough for me!
20:11:28 <shachaf> @let blah = "hi"
20:11:28 <lambdabot>  .L.hs:6:1:
20:11:28 <lambdabot>      Failed to load interface for `Control.Arrow.Operations'
20:11:29 <lambdabot>     ...
20:11:43 <monochrom> I see, that's strange
20:11:43 * Ralith blames shachaf when he configuration breaks
20:11:57 <shachaf> monochrom: The server was upgraded to 7.4 yesterday.
20:12:58 <vamega1> I was just installing ghc-mod
20:13:11 <vamega1> when I noticed that after it finished compiling 22 files
20:13:14 <vamega1> It started all over again?
20:13:17 <vamega1> Is that normal?
20:13:53 <startling> what makes you think it started all over again?
20:14:12 <vamega1> 22 of 22] Compiling Language.Haskell.Exts ( src/Language/Haskell/Exts.hs, dist/build/Language/Haskell/Exts.o )
20:14:19 <vamega1> [ 1 of 22] Compiling Language.Haskell.Exts.Annotated.Syntax ( src/Language/Haskell/Exts/Annotated/Syntax.hs, dist/build/Language/Haskell/Exts/Annotated/Syntax.p_o )
20:14:29 <shachaf> vamega1: Profiling libraries.
20:14:30 <vamega1> I seems like it's cycled from 22 to 1
20:14:56 <vamega1> Oh I guess that explains the p_o extension
20:15:13 <vamega1> Why are those necessary?
20:15:22 <hpaste> Marzhall annotated “Errors with map and trying to fold a tree into a Map” with “Errors with map and trying to fold a tree into a Map (annotation)” at http://hpaste.org/77098#a77099
20:17:43 <rwbarton> they're only necessary if you ever want to profile a program that uses haskell-src-exts
20:17:55 <byorgey> vamega1: they aren't, you can turn it off if you don't want profiling versions of libraries installed
20:18:46 <byorgey> set library-profiling: False  in your  .cabal/config
20:19:02 <byorgey> or wherever your cabal config file is stored
20:19:23 <vamega1> Adding that right now, thanks a tonne
20:19:33 <rwbarton> if you ever want to profile a program though it's kind of a pain to get the profiling libraries installed after the fact
20:20:02 <byorgey> that's true
20:20:23 <vamega1> Could you explain what you mean by a pain?
20:20:35 <byorgey> but since vamega1 is just learning that probably won't happen for a while
20:20:36 <rwbarton> precisely what I mean is "I don't know how to do it off-hand"
20:20:41 <vamega1> If it's just I need to leave my computer on for hours while I compiles stuff
20:20:52 <byorgey> it's not that bad
20:21:10 <byorgey> you just have to do some cabal install --force-reinstall --enable-profiling  or so
20:21:20 <vamega1> Alright
20:21:21 <vamega1> Thanks
20:21:38 <byorgey> or more likely just delete your installed package db and recompile everything with profiling turned on
20:22:02 <vamega1> I too think it'll be a while before I get to the point where I need to profile my applications for performance
20:22:15 <rwbarton> hey, maybe by then you will be using a different version of ghc anyways :)
20:22:27 <byorgey> that's also true =)
20:23:32 <hpaste> Marzhall annotated “Errors with map and trying to fold a tree into a Map” with “Errors with map and trying to fold a tree into a Map (annotation) (annotation)” at http://hpaste.org/77098#a77100
20:28:53 <copumpkin> dcoutts: http://marketing555.files.wordpress.com/2012/10/suatmm1.jpg
20:29:20 <copumpkin> I think the primary difficulty would be to decide what tiered rewards to give out on kickstarter :)
20:29:44 <shachaf> I hear there are stickers!
20:31:09 <fruitFly>  not in scope true and false.. prime p pl = if null pl then true else if p `mod` head pl /= 0 then prime p tail pl else false
20:31:29 <shachaf> true
20:31:33 <shachaf> Next question?
20:31:52 <geekosaur> hint:  they're data constructors
20:31:56 <fruitFly> it tests if a number is a prime number.. eg num 777 [776,775..2] would be the parameters I enter
20:33:02 <fruitFly> geekosaur: could you elab a little?
20:33:20 <shachaf> Please, geekosaur. Do elab.
20:33:41 <startling> well, you could do true = True
20:33:45 <fruitFly> geekosaur: yeah geekosaur
20:34:08 <fruitFly> shachaf: I'm a nub... alright
20:34:52 <shachaf> No, this is a nub:
20:34:53 <shachaf> @ty nub
20:34:54 <lambdabot> Not in scope: `nub'
20:35:02 <shachaf> ...Hmm, lambdabot is messed up.
20:35:05 <fruitFly> lol.. I got it.. thanks startling:
20:35:50 <Jafet> shachaf: you're a nubby
20:37:43 <startling> fruitFly: ;)
20:37:53 <fenton> i'm stuck in haskell dependency hell...how can i reset?  blow away ~/.cabal?
20:38:16 <shachaf> fenton: That would do it. Though you should probably rename, rather than delete. :-)
20:38:51 <fenton> I'm really only wanting xmonad and yessod...after a blow away of .cabal, should I expect that those two alone will compile?
20:39:22 <startling> fenton, you can try cabal install xmonad --reinstall
20:39:37 <shachaf> Sounds like a bad idea.
20:40:09 <Jafet> apt-get remove xmonad libghc*; cabal install xmonad
20:40:28 <Jafet> Heh wait, libghc* won't work
20:40:46 <parcs`> > 0x1680
20:40:50 <lambdabot>   5760
20:41:07 <fruitFly> ghci syas my func is applied to 3 arguments but it's type only has 2. Where are these 3 args? prime p pl = if null pl then True else if p `mod` head pl /= 0 then prime p tail pl else False
20:41:32 <startling> " prime p tail p"
20:41:39 <startling> prime only takes two.
20:42:03 <fruitFly> so will it work if i do prime p (tail p) startling:
20:42:11 <fenton> i'm a tad confused if we should be using our distribution's packages or cabal...i've seen strong suggestions either way...I'm using arch and I just did ghc and cabal-install through pacman, then i got cabal-install and since then just use cabal...is that reasonable?
20:42:39 <shachaf> It's what I do.
20:42:57 <byorgey> yes, that's quite reasonable
20:43:00 <startling> fruitFly, dunno, I'm context-switching too much as is
20:43:14 <fenton> ok thx.
20:43:15 <parcs`> > filter isSpace ['
20:43:23 <lambdabot>   mueval: Prelude.undefined
20:43:27 <dolio> For a while, Arch was recommended for having extremely up to date packages.
20:43:28 <parcs`> 0wat
20:43:39 <byorgey> fruitFly: I don't know if it will work, but that looks like the proper way to give prime two arguments.
20:43:41 <dolio> So that'd be the one place where you might not have to use cabal-install much.
20:43:42 <parcs`> > filter isSpace ['\0'..'\x1680']
20:43:47 <lambdabot>   mueval-core: Time limit exceeded
20:44:41 <dolio> But, by contrast, Ubuntu tends to be way behind on even GHC versions.
20:44:51 <parcs`> > filter ((== NotAssigned) . generalCategory) ['\0'..'\x1680']
20:44:56 <lambdabot>   mueval-core: Time limit exceeded
20:45:01 <parcs`> omg lambdabot
20:45:08 <dolio> Which leads people using that to recommend just installing manually and using cabal-install.
20:45:56 <dolio> Lately I've veen using Fedora, where the GHC packages are out of date, _and_ the GHC headquarters packages don't work.
20:46:04 <byorgey> I still think installing Hackage packages via your OS package manager is a mistake, even if you're on arch.
20:46:05 <dmwit> copumpkin: ohai
20:46:08 <dolio> But there's a 3rd party repo that has an up to date GHC.
20:46:09 <fruitFly> byorgey: you try it... doesn't want it... I put parens now I'm getting a different error
20:46:16 <copumpkin> dmwit: trying to endorse you for HTML
20:46:24 <dmwit> =P
20:46:36 <byorgey> I think the only time that would make sense is if you just wanted some program or library but didn't know Haskell and didn't care to
20:46:46 <fruitFly> byorgey: prime p pl = if null pl then True else if p `mod` head pl /= 0 then prime p tail pl else False
20:46:55 <byorgey> but anyone actually trying to *write* Haskell programs should use cabal-install.
20:48:22 <dolio> byorgey: Yeah.
20:48:35 <fenton> byorgey: for newbies following your advice, who do want to program in haskell, i wonder what we should do when we start to fall into dependency hell...
20:48:46 <vamega1> If there is an emacs user here, do you know of a way I can run code in ghci from within emacs?
20:48:54 <startling> vamega1, haskell-mode
20:48:56 <copumpkin> dmwit: there, enjoy your HTML-fu
20:48:59 <fenton> vamega1: of course you can
20:49:04 <dolio> byorgey: Although there was a while there when (from reports I heard) Arch would have packages a day or two after they were released on Hackage.
20:49:04 <vamega1> startling: I'm in haskell mode
20:49:05 <startling> vamega1: C-c C-l is the thing
20:49:17 <byorgey> dolio: I think that's true
20:49:24 <fenton> C-c C-z will start the repl.
20:49:24 <vamega1> Startling, thanks a tonne
20:49:29 <dolio> Maybe even auto-generated, so you'd get everything available.
20:49:37 <copumpkin> does dolio know about hadoop?
20:49:42 <startling> vamega1: no problem
20:49:47 <copumpkin> linkedin wants to know
20:49:47 <dolio> Does he?
20:49:51 <dmwit> -_-
20:49:53 <copumpkin> too late
20:49:54 <Ralith> speaking of haskell-mode, what magic is necessary to get ghc-mod set up and working with all its bells and whistles?
20:50:17 <byorgey> fenton: dependency hell happens much less often with newer versions of Cabal.  But in any case, I would say, ask questions, learn, start clean and reinstall stuff, the usual.
20:50:20 <fenton> i died following the wiki at some point, only got haskell-mode going...
20:50:22 <dolio> copumpkin: I've heard about it, so yes.
20:50:27 <copumpkin> cool
20:50:31 <dolio> That's what that sentence means, right?
20:50:38 <byorgey> fenton: if you install things through your OS package manager, you won't get dependency hell, but also it simply won't work
20:50:39 <copumpkin> totally
20:50:48 <fenton> byorgey: lol
20:51:03 <byorgey> so, take your pick.
20:51:46 <fenton> i'm willing to take the time it takes to learn it right!  but from a spanking clean install, +xmonad, +yessod = breaks...ouch!
20:52:25 <byorgey> fenton: yesod is a particularly difficult one, because it has so many dependencies.
20:52:49 <byorgey> I don't actually know what the latest and greatest yesod installation technology is, but they actually have special tools to do it
20:53:03 <stepcut> fenton: try happstack ;)
20:53:06 <fenton> byorgey: on the webpage they say: cabal install yesod!
20:53:07 <Ralith> I seem to have it ghc-mod loaded but I'm not getting any errors marked or anything
20:53:17 <byorgey> fenton: ah
20:53:25 <stepcut> fenton: or help contribute to scoutess
20:53:26 <fenton> stepcut: happstack died too, snap made it, but it broke later on...
20:54:01 <stepcut> fenton: well.. I can fix happstack, unless it is your system that is screwed up
20:54:11 <stepcut> fenton:do you remember the error ?
20:54:54 <fenton> stepcut: i'll re-go check...f--k, simply 'cabal install cabal-install' died!
20:55:15 <fenton> stepcut: scoutess = continuous integration...sounds like a wicked good idea...
20:56:15 <jfischoff> byorgey: had a lot of fun with the singleton library. Enjoying promoted types all around actually.
20:56:16 <stepcut> fenton: yup. I run into issues every week that scoutess would have caught
20:56:48 <byorgey> jfischoff: excellent =)
20:56:59 <Ralith> with ghc-mod, flymake seems to be doing nothing, no errors are marked on save, and C-c C-t with point in an expression gives a "wrong type argument" error; can anyone advise?
20:57:24 <Cale> Integration is usually continuous, unlike differentiation :)
20:57:34 <fenton> stepcut: hmmm...i did like jenkins from the java world...i'll definitely look into this...
20:57:46 <fenton> Cale: ha ha!
20:58:05 <fenton> Cale: I thought differentiation required continuity!
20:58:20 <stepcut> fenton: I am familiar with jenkins. The major problem with jenkins is that it doesn't really know anything about Haskell.. and so it misses out on a lot of useful information that it could be providing
20:58:44 <Jafet> It's not easy to differentiate between continuous things
20:58:46 <fenton> stepcut: oh sure, i'm not suggesting jenkins at all for haskell...just that it was an okay tool in java world!
20:59:07 <jfischoff> byorgey: I can know make the type: GLMesh UnsignedByte TRIANGLES [Float3 "position", Short3 "extraData"] and be assured that the meta information and the underlying bytes match (type level literals are pretty cool too).
20:59:21 <fenton> Jafet: good one!
20:59:31 <Cale> fenton: It requires continuity, but you can have a sequence of functions which are getting closer together, converging to some limit, but for which the derivatives will diverge
20:59:37 <fenton> Jafet: I think it's infitely hard!
20:59:50 <Ralith> does anyone here have ghc-mod working at all?
21:00:00 <rwbarton> bah, http://hackage.haskell.org/packages/archive/type-level/0.2.4/doc/html/Data-TypeLevel-Num-Aliases.html is all i need
21:00:01 <byorgey> jfischoff: neat!
21:00:22 <rwbarton> 5000 type-level literals ought to be enough for anyone
21:00:42 <fenton> Cale: ah right...i tried to forget that stuff! lol
21:00:45 <Cale> For example, f_n(x) = sin(n^2 x)/n
21:01:20 <Cale> these functions are getting closer and closer to zero -- the nth one is within 1/n in distance from the zero function at every point
21:01:48 <Cale> But the derivatives... f_n'(x) = n cos(n^2 x)
21:02:13 <Cale> aren't converging to anything
21:02:17 <stepcut> my spell checker does not recognize, composible or composable or composeable as valid.. what does that mean?
21:02:24 <fenton> Cale: ur making my head hurt, which already pains from cabal-install not compiling!
21:02:43 <Jafet> It means you need a better spell checker
21:02:55 <parcs`> stepcut: same here actually
21:03:03 <stepcut> fenton: the idea for scoutess came about because haskell users were trying to use jenkins and complaining about the limitations ;)
21:03:12 <fenton> lol!
21:03:22 <stepcut> parcs`: yeah.. this seems to be true on both linux and OS X
21:03:38 <fenton> well if i can get it, or anything else to install, I'll start to pitch in!
21:03:42 <frio> does scoutess exist yet? or is just a GSoC proposal at this stage?
21:05:19 <frio> id suggest that improving jenkins' support for for haskell might be more productive than making a buildbot from scratch
21:05:28 <hdev> How would I write something like instance (Applicative (b a), Num a) => Num (b a)?
21:05:32 <frio> but then, i haven't worked with jenkins plugins so don't understand the limitations people have seen :)
21:05:53 <tswett> > 1
21:05:59 <lambdabot>   mueval-core: Time limit exceeded
21:05:59 <lambdabot>  mueval: ExitFailure 1
21:05:59 <lambdabot>  mueval: Prelude.un...
21:06:17 <fenton> stepcut: looks cool, should we carry on discussion on #happs?
21:07:00 <stepcut> fenton: if you want to discuss happstack, then we could move to #happs.. if you want to discuss scoutess we could move to #scoutess, or we can stay here and inform in the ignorant masses ;)
21:08:13 <fenton> stepcut: i'm more interested in scoutess at the moment...since the dependency hell is a big problem for newbies, like me...once that's resolved I'll start looking at app servers.
21:08:41 <stepcut> then #scoutess it is!
21:09:07 <shachaf> > 1
21:09:09 <lambdabot>   Could not find module `Debug.SimpleReflect':
21:09:09 <lambdabot>    Use -v to see a list of the...
21:09:16 <fenton> stepcut: or we can discuss with 'ignorant masses' until someone tells us to take it somewhere else...sorry I don't really know irc etiquette...
21:10:05 <stepcut> :) well.. scoutess is entirely dedicated to Haskell, and nothing else. Plus.. this channel is larger than ever.. an also less active than it was when it was 1/10th the size :-/
21:10:09 <Cale> The linker on the machine where lambdabot is running is either broken or very slow
21:10:31 <Cale> Well, at least, the new GHC takes a very long time to link some things now.
21:10:34 <startling> shachaf: that's pretty bad.
21:10:43 <espringe> I have a [Int] and I want to add them together, using a fold. So I've got like:  foldl (+) 0 my_list_of_int   -- but I need the return to be an Integer, not an Int
21:10:52 <espringe> so I want to write it like:
21:10:52 <espringe> foldl (+) (0: Integer) my_list_of_int
21:10:55 <espringe> how do i do that? :D
21:11:14 <startling> espringe: fromIntegral $ foldl (+) 0 my_list_of_int
21:11:26 <espringe> Nah, the problem is it's overflowing during the computation
21:11:32 <startling> oh.
21:11:38 <espringe> (in my case, it's not a (+)  )
21:11:52 <espringe> It's a:  (\ a b -> a * 10 + b)
21:11:53 <Cale> foldl (+) 0 (map fromIntegral myListOfInt)
21:11:55 <startling> foldl (+) 0 (map fromIntegral my_list_of_int)
21:11:58 <startling> yeah
21:11:58 <espringe> So it can overflow pretty quick :P
21:12:15 <Cale> espringe: btw, you may like to use foldl'
21:12:33 <espringe> Is there a more efficient way, than map fromIntegral myListOfInts   ?
21:12:41 <espringe> because myListOfInts are all numbers 0-9
21:12:52 <Cale> espringe: Turn on the optimiser
21:13:08 <Cale> espringe: and the map will be fused with the foldl (or foldl')
21:13:28 <hpaste> vamega pasted “99 Problems - Question 3” at http://hpaste.org/77101
21:13:29 <Cale> espringe: or, if you really want to do it by hand, of course you can
21:13:47 <Cale> > foldl (\s n -> s + fromIntegral n) 0
21:13:51 <vamega1> Hi, could someone help me identify what was wrong with my code above?
21:13:52 <lambdabot>   mueval-core: Time limit exceeded
21:13:53 <espringe> But honestly the type seems wrong, I kind of want fold to be:  ( foldl :: (Integer -> Int -> Integer) -> Integer -> [Int] -> Integer )
21:14:07 <espringe> Instead of just mapping over the [Int] and converting it to Integer's
21:14:49 <startling> espringe: see Cale's last line of code
21:15:14 <Cale> espringe: Of course, foldl's type unifies with that one
21:15:25 <espringe> Cool, thanks Cale
21:15:28 <espringe> that does the trick
21:15:33 <espringe> It's inferring it all right
21:15:33 <espringe> nice
21:15:50 <Cale> espringe: that's equally as efficient as using map if you use -O
21:16:31 <espringe> Oh well, i kind of like the way it looks now
21:19:30 <vamega1> vamega pasted “99 Problems - Question 3” at http://hpaste.org/77101, anyone?
21:22:30 <espringe> let x = 1 :: Integer      and   let y = 2 :: Int       -- is the most efficient way to add them:   "x + fromIntegral y" ?
21:22:41 <espringe> Or is there some other better way?
21:23:00 <Cale> espringe: that's good
21:23:01 <rwbarton> that is a fine way
21:23:11 <rwbarton> you can also use toInteger rather than fromIntegral, if you want to be more explicit
21:23:17 <startling> espringe: why not write it and then profile?
21:23:35 <espringe> Wasn't sure what the alternative was, to profile it against :D
21:23:51 <rwbarton> wait, we are talking about runtime efficiency?
21:23:57 <rwbarton> this is a silly thing to worry about
21:24:03 <Cale> espringe: Well, if that part of your program isn't what's causing the problem, then there's no sense worrying about it :)
21:24:04 <rwbarton> the most efficient way is to write 3 :: Integer
21:24:08 <startling> espringe: well, you could compare how little it matters compared to the rest of your code
21:24:22 <espringe> Thought there might be some specialized functions for adding arbitrary ints with fixed size ints or something
21:24:31 <espringe> Yeah, not really too concerned. Just want to do it the right way :D
21:24:55 <espringe> I'm just porting some of my scala code to haskell, so i don't want to do it in the wrong way and end up with misleading results
21:25:27 <Jafet> Obviously it is case y of I# i -> plusInteger x (S# i)
21:26:08 <rwbarton> ghc will probably generate that anyways, no
21:26:17 <espringe> That's that # syntax mean called, and I'll google it :D
21:26:22 <espringe> I don't know it
21:26:44 <Jafet> That syntax doesn't exist
21:26:47 <rwbarton> Jafet is joking (I hope?)
21:26:47 <espringe> Sorry, What* is that hash called
21:26:47 <Jafet> Move along now
21:28:09 <Cale> Jafet: *** Exception: Non-exhaustive patterns in case
21:28:40 <Jafet> Hm, your Int has two constructors?
21:28:49 <Cale> oh, you're taking apart the Int
21:28:53 <Cale> nevermind :)
21:28:59 <startling> is there a typeclass somewhere for fmap with a key?
21:29:19 <Jafet> A key, you want to lock out your users?
21:32:20 <Cale> http://hackage.haskell.org/packages/archive/keys/2.2/doc/html/Data-Key.html
21:32:34 <rwbarton> i was too slow
21:32:43 <rwbarton> forgot the trick of staring at the big diagram in category-extras
21:32:47 <rwbarton> until too late
21:35:30 <vamega1> Is there a mistake on Problem 5 in the 99 Questions page
21:35:35 <vamega1> http://www.haskell.org/haskellwiki/99_questions/1_to_10
21:36:05 <vamega1> I think they meant to use a List of Char[]
21:36:09 <vamega1> Instead of a String
21:36:09 <startling> Cale, wow, thanks!
21:36:18 <startling> vamega1, [Char] is String
21:36:29 <Jafet> Heh, nice diagram
21:36:31 * hackagebot vector-th-unbox 0.1.0.2 - Deriver for Data.Vector.Unboxed using Template Haskell  http://hackage.haskell.org/package/vector-th-unbox-0.1.0.2 (LiyangHu)
21:36:48 <Jafet> > ()
21:36:49 <byorgey> String is just a convenient synonym for [Char]
21:36:53 <lambdabot>   mueval-core: Time limit exceeded
21:37:02 <rwbarton> > 0
21:37:06 <lambdabot>   Could not find module `Debug.SimpleReflect':
21:37:06 <lambdabot>    Use -v to see a list of the...
21:37:17 <rwbarton> > let
21:37:22 <lambdabot>   Could not find module `Debug.SimpleReflect':
21:37:22 <lambdabot>    Use -v to see a list of the...
21:37:27 <rwbarton> ...?
21:37:29 <rwbarton> > =
21:37:34 <lambdabot>   mueval-core: Time limit exceeded
21:37:37 <rwbarton> weird
21:39:13 <vamega1> startling, yes I know that [Char] is String
21:39:23 <vamega1> which means that reverse on a String
21:39:38 <vamega1> is equivalent to reverse on a [Char]
21:39:49 <startling> vamega1: sure
21:40:05 <startling> rwbarton: lambdabot's got a bit of a cold today
21:40:08 <vamega1> But in that question if the example output is correct interprets the String as a list of nested strings
21:40:21 <vamega1> Prelude> reverse "A man, a plan, a canal, panama!"
21:40:21 <vamega1> "!amanap ,lanac a ,nalp a ,nam A"
21:40:34 <rwbarton> it is just reversing the string.
21:40:41 <startling> nah, that's just reversing the characters
21:40:43 <rwbarton> perhaps you are interpreting the string as a list of words...
21:41:02 <startling> vamega1, are you confused because the string is a palindrome?
21:41:34 <vamega1> Oh yes I am
21:41:46 <vamega1> Nevermind, I'm an absolute moron.
21:42:09 <startling> hehe
21:42:23 <vamega1> I think I'm going to go to bed now, obviously I'm not being productive at this time
21:42:45 <vamega1> So Long and Thanks for All the Fish
21:42:58 <byorgey> hehehe
21:43:03 <byorgey> sleep well
21:45:14 <lispy> Cale: ping
21:45:18 <Cale> hi
21:45:30 <lispy> Cale: I hope the reboot and upgrade to 7.4 wasn't too distruptive
21:46:02 <Cale> Well, it's broken everything, but I'm reinstalling packages now
21:46:19 <lispy> hmm
21:46:27 <lispy> Cale: how can I help?
21:46:57 <Cale> Make the linker faster :P
21:47:19 <lispy> Cale: oh, do you need a ghc without split-obj?
21:47:28 <Cale> okay, it's working
21:47:37 <Cale> > 1
21:47:38 <lambdabot>   1
21:47:55 <lispy> @version
21:47:56 <lambdabot> lambdabot 4.2.2.1
21:47:56 <lambdabot> darcs get http://code.haskell.org/lambdabot
21:47:57 <rwbarton> @@ @run text (if (@show (@run gcd 0 0)) == "  0\n" then "yay, ghc 7.4!" else "Cale, fix lambdabot!")
21:47:59 <lambdabot>   yay, ghc 7.4!
21:48:02 <rwbarton> :)
21:48:41 <startling> @let n = n
21:48:42 <lambdabot>  <local>:2:5:
21:48:42 <lambdabot>      Ambiguous occurrence `n'
21:48:42 <lambdabot>      It could refer to either `L....
21:49:08 <lispy> Cale: I'm tempted to install 7.6, but I don't really know how to do that and keep the default `ghc` invoking ghc-7.4
21:49:34 <lispy> Obviously I can install to a weird place, but I want to install to /usr/local like all the other ghcs
21:49:59 <Cale> lispy: I think you just have to keep all the symlinks pointing to the right things
21:50:27 <rwbarton> maybe do a make install for ghc-7.4 after make install for ghc-7.6?
21:50:28 <edwardk> startling: https://github.com/ekmett/lens/blob/master/src/Control/Lens/WithIndex.hs#L96
21:50:49 <byorgey> lispy: use GNU stow!
21:50:51 <startling> oh yeah, forgot about that
21:50:55 <shachaf> Use NixOS!
21:50:56 <startling> edwardk: thanks!
21:50:59 * byorgey has a blog post almost written about that
21:51:05 <byorgey> probably post it tomorrow
21:51:13 <lispy> rwbarton: if I do that I think I'll break the packages that Cale just ...oh right, he wouldn't have installed them globally
21:51:30 <shachaf> edwardk: lens has imap now?
21:51:31 <lispy> byorgey: I've seen stow but I have to admit, I don't trust it
21:51:35 <shachaf> Zawinski's law, I guess.
21:51:43 <Cale> lispy: I *never* install packages globally
21:51:51 <lispy> Cale: right.
21:51:55 <byorgey> lispy: that's fair I suppose.
21:52:00 <lispy> Cale: so I should be able to do what rwbarton suggest
21:52:02 <lispy> +s
21:52:09 <lispy> byorgey: is it?
21:52:27 <lispy> byorgey: having never used it I lack evidence that it is either trustworthy or untrustworthy
21:52:44 <byorgey> lispy: it's certainly reasonable to distrust a perl program that munges your /usr/local.
21:53:09 <byorgey> lispy: but I've been using it to manage 5-6 parallel GHC installs for quite a while and I've never had anything go wrong.
21:53:24 <lispy> Cale: I'm going to try installing 7.6 followed by reinstalling 7.4. Any objections or want me to wait a bit?
21:53:49 <lispy> byorgey: Cool. So when is your blog post going up again? ;)
21:54:02 <byorgey> lispy: tomorrow
21:54:12 <byorgey> right now I'm going to bed
21:54:19 <lispy> byorgey: g'night
21:54:23 <byorgey> night
21:54:33 <edwardk> shachaf: its had it for a long while
22:07:19 <bxx> can you pattern match on something other than exact values?  for example can i match numbers less than zero
22:07:31 <johnw> you can use guards
22:07:47 <johnw> foo x | x < 10 = x; otherwise = 100
22:09:05 <bxx> II was thinking something like this: foo (< 0) = ...    foo n = ...  I guess not?
22:09:47 <Cale> bxx: Well, see johnw's response
22:10:30 <Cale> actually, that probably shouldn't be a ; but a |
22:11:09 <Cale> bxx: If you want to write a completely separate line pattern matching n, you can
22:11:20 <Cale> foo n | n < 0 = ...
22:11:22 <Cale> foo n = ...
22:11:50 <lispy> > 1
22:11:54 <lambdabot>   1
22:12:24 <mikeplus64> i kind of find myself wishing that you could show equality in patterns, like foo [x,x,y] = ...\nfoo [x,y,z] = ...
22:12:44 <mikeplus64> where the first would fall through to the second if those two xs aren't actually equal
22:12:45 <liyang> mikeplus64: you can in Agda…
22:12:53 <liyang> (sort of.)
22:12:58 <mikeplus64> i'
22:13:07 <mikeplus64> m not sure how complicated implementing it would be
22:13:24 <Saizan> with an Eq constraint it's quite easy
22:13:38 <bxx> Cale, johnw thanks
22:13:39 <startling> @pl \fn p l = fn (p : l)
22:13:39 <lambdabot> (line 1, column 9):
22:13:40 <lambdabot> unexpected "="
22:13:40 <lambdabot> expecting pattern or "->"
22:13:57 <startling> @pl \fn p l -> fn (p : l)
22:13:57 <lambdabot> (. (:)) . (.)
22:14:00 <startling> ouch.
22:14:18 <Cale> mikeplus64: Miranda, Haskell's predecessor in many ways, had that feature
22:14:39 <mikeplus64> or even match equality from the current scope, like let x = foo in case y of Just x -> ..., but that would definitely confuse with the current shadowing behaviour
22:14:57 <syskk> is it possible to call an haskell dynamic library from a C program?
22:15:09 <liyang> > let f x ((==) x -> True) = "yes" ; f x y = "no" in f 1 2
22:15:11 <lambdabot>   "no"
22:15:54 <mikeplus64> neat
22:16:33 * hackagebot http-reverse-proxy 0.1.0.4 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.0.4 (MichaelSnoyman)
22:17:31 <dmwit> syskk: You need to set things up a bit, but yes. The FFI spec has details.
22:17:48 <syskk> dmwit: thanks
22:17:57 <Cale> mikeplus64: It's not so easy to define exactly what repeated variables ought to mean precisely, especially when there's more than one pair of them, and you have to consider that making a different choice about the order in which to put the comparisons can change the termination behaviour of some programs
22:18:11 <Cale> mikeplus64: there's some discussion of the trickiness of it here: http://research.microsoft.com/en-us/um/people/simonpj/papers/slpj-book-1987/PAGES/065.HTM
22:18:37 * dmwit -> bed
22:18:57 <syskk> dmwit: isn't that the other way around? calling shared libraries from haskell?
22:19:55 <liyang> syskk: you can foreign export as well as import.
22:21:18 <syskk> liyang: ok thanks
22:22:25 <bxx> what's the reason behind requiring parenthesis in 5 * (-3) ?
22:23:13 <espringe> Just so it knows you mean "negative 3" as a number, not - as a function
22:23:13 <espringe> (-) :: Num a => a -> a -> a
22:23:19 <simpson> bxx: Grammar ambiguity. You can use parentheses to partially apply operators in Haskell.
22:23:30 <simpson> :t (-3)
22:23:32 <lambdabot> forall a. Num a => a
22:23:36 <simpson> :t (*3)
22:23:37 <lambdabot> forall a. Num a => a -> a
22:23:43 <mikeplus64> :t (- 3)
22:23:44 <lambdabot> forall a. Num a => a
22:23:57 * liyang dislikes that part.
22:24:00 <bxx> so there is no negative literal, (-1) is a a function call ?
22:24:05 <Ralith> - is a bit weird.
22:24:14 <simpson> bxx: Other way around.
22:24:24 <Ralith> not quite
22:24:25 <liyang> No, (-1) is a negative literal, which is inconsistent with (*1) being a function.
22:24:36 <Ralith> there are negative literals *and* a subtraction function.
22:24:40 <Ralith> :t (-)
22:24:41 <lambdabot> forall a. Num a => a -> a -> a
22:24:45 * liyang would rather write "negate 1" instead of "(-1)"
22:24:53 <Ralith> :t -1
22:24:54 <lambdabot> forall a. Num a => a
22:25:32 <espringe> I wonder if haskell could live without having negative literals
22:25:39 <espringe> so -4 would be consistent with *4
22:25:55 <espringe> But there would be no way of having a negative literal, but not sure if you ever need one :D
22:26:19 <dolio> Haskell doesn't have negative literals.
22:26:44 <startling> > map (- 4) [1, 2, 3]
22:26:45 <lambdabot>   [-4,-4,-4]
22:26:52 <dolio> > let n = 5 in -n
22:26:53 <startling> :S
22:26:53 <lambdabot>   -5
22:26:54 <Jafet> It's much easier to think of unary - as a literal, because its behaviour is too annoying to be that of an operator
22:27:09 <Jafet> except in that case
22:27:10 <startling> oh, that's just Caleskell
22:27:30 <dolio> That's not the only case.
22:27:35 <espringe> So in template haskell or what ever, is "-5" a literal or a function call ?
22:27:40 <dolio> > - 5 `mod` 6
22:27:42 <lambdabot>   -5
22:27:48 <dolio> > (-5) `mod` 6
22:27:50 <lambdabot>   1
22:27:59 <liyang> espringe: a literal, I bet.
22:28:18 <dolio> - is looser than `mod`.
22:29:38 <Ralith> dolio: wait, - actually names *two* functions?
22:29:45 <Ralith> o.O
22:29:46 <startling> man, file i/o is by far the worst part of haskell
22:30:02 <Ralith> startling: surely someone's bound mmap.
22:30:06 <espringe> startling: Really? It was the thing that convinced me to use haskell :D
22:30:11 <dolio> Unary minus is baked into the language, and desugars to negate.
22:30:18 <dolio> There's also a binary minus.
22:30:24 <Ralith> ugly.
22:30:26 <startling> Ralith: well, navigating directory structures at least
22:30:33 <Ralith> startling: that's another issue entirely!
22:30:37 <startling> indeed.
22:30:39 <Ralith> startling: define 'navigating'
22:31:01 <dolio> I don't remember if the unary minus' precedence is baked in, or if it corresponds to the binary minus, or something else.
22:31:49 <bxx> so how do you do the (+ 4) equivalent with - ?
22:32:01 <cmears> (subtract 4)
22:32:24 <startling> Ralith, I've got a tree that I want to turn into a directory. It's easy to get traverse writeFile over the leaves and get an IO (), but it's so much work to make sure that all the directories (subtrees) exist
22:32:24 <espringe> lazy io is what convinced me to  start learning haskell. My friend wrote some code that lazily reads gigabytes of clang symbols and merges it, all lazily -- in like a dozen lines of code. It was several hundred to do it in C++ [it was far to big to bring all into memory, so it had to chunk it up and all sorts of nasty stuff]
22:32:39 <cmears> > map (subtract 4) [1..3]
22:32:40 <lambdabot>   [-3,-2,-1]
22:32:49 <Jafet> Ironically, many people don't like lazy IO.
22:33:06 <bxx> cmears thanks
22:33:07 <Ralith> startling: (\x -> ensureDirectory x >> writeFile x ...)
22:33:16 <startling> Ralith: yeah, fair enough
22:33:21 <Ralith> @pl (\x -> f x >> g x)
22:33:21 <lambdabot> liftM2 (>>) f g
22:33:50 <Ralith> there must be some fancy operator to do that shorter still
22:34:08 <otters> not really
22:34:13 <Jafet> liftM2 (>>)
22:34:15 <otters> you have (>>), you have f, and you have g
22:34:20 <Jafet> So I heard you like monads
22:34:22 <Cale> To those people's credit, they're advocating another model of stream processing. But I think it is good to appreciate how often plain lazy I/O works well.
22:34:50 <Ralith> there's just so many various abstract monadic operators out there
22:34:53 <startling> yeah, lazy IO is nice for those cases
22:35:02 <startling> Ralith: >=> is almost there
22:35:30 <otters> :t \f g x -> f x >> g x
22:35:31 <lambdabot> forall (m :: * -> *) a b t. Monad m => (t -> m a) -> (t -> m b) -> t -> m b
22:35:36 <otters> :t (<=<)
22:35:38 <lambdabot> forall (m :: * -> *) b c a. Monad m => (b -> m c) -> (a -> m b) -> a -> m c
22:35:49 <Jafet> @hoogle (t -> m a) -> (t -> m b) -> t -> m b
22:35:50 <otters> so it's (>=>)
22:35:50 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:35:51 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:35:51 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
22:36:02 <Jafet> otters: nope
22:36:16 <otters> oh rats
22:36:33 * hackagebot pipes 2.5.0 - Compositional pipelines  http://hackage.haskell.org/package/pipes-2.5.0 (GabrielGonzalez)
22:36:35 <Jafet> Though oddly, bracket looks nearly right
22:36:41 <otters> why isn't it
22:36:48 <Jafet> :t (>=>)
22:36:49 <lambdabot> forall (m :: * -> *) a b c. Monad m => (a -> m b) -> (b -> m c) -> a -> m c
22:36:56 <Jafet> :t liftM2 (>>)
22:36:58 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a b. (Monad m1, Monad m) => m (m1 a) -> m (m1 b) -> m (m1 b)
22:37:14 <espringe> With lazy IO, does it close the file synchronously after the last byte is read [and memoize the file, incase you have multiple passes and still have a reference] ?
22:37:17 <Jafet> ...who even suggested that
22:37:38 <espringe> And if you don't have a reference, gc could clean up the memoized version of the file
22:37:45 <Jafet> espringe: haskell has no memoization. If you bind the file contents to a variable, the variable holds the file contents
22:37:48 <startling> espringe: probably, probably not
22:38:00 <Cale> espringe: Well, it won't read any byte of the file more than once
22:38:15 <espringe> So if you do multiple passes of a file, how many times does the file get read?
22:38:16 <Cale> espringe: So once it's read, it's in memory, and if it's garbage, then it's garbage.
22:38:17 <Jafet> This is not what memoization means, anyway
22:38:48 <bxx> is there a function that walks the directory tree  ?  I am not seeing it in System.Directory docs
22:39:30 <Cale> and the file handle stays open so long as you could possibly need to read more of the file -- if the remainder of the string becomes garbage, or the entire string is fully observed, then the file handle becomes potential garbage and when it's GCed, it gets closed
22:39:52 <Cale> The tricky thing about this is if you have a lot of files to open and process, this can become extremely fiddly
22:40:06 <Cale> because operating systems have draconian limits on the number of open files
22:40:29 <espringe> So if you do multiple passes of the file, you'll actually be reading the file multiple times?
22:40:32 <Cale> no
22:40:36 <Cale> as I said
22:40:44 <Cale> it won't read any byte of the file more than once
22:40:51 <espringe> So if you do multiple passes, it would mean the whole file gets loaded into memory?
22:40:54 <Cale> yes
22:40:57 <Jafet> What does "multiple passes" mean
22:41:03 <espringe> Which means, you could safely synchronously close the file when you hit the end?
22:41:05 <Cale> well, depending on what you mean by passes
22:41:08 <Jafet> readFile f; readFile f; readFile f
22:41:14 <Jafet> That reads the file three times
22:41:21 <Cale> Jafet: *maybe*
22:41:29 <Jafet> Well, it opens the file three times
22:41:38 <dolio> I think it's pretty likely that the handle gets closed when you observe the end of the list.
22:41:42 <dolio> Synchronously.
22:41:48 <espringe> ah, very nice
22:41:52 <espringe> exactly what i hoped for! :D
22:41:53 <Cale> espringe: yes, you can, but it's hard to know when it's safe to close the handle
22:41:55 <startling> I've got [a, b, c]. how do I run a function over [a], [a, b], and [a, b, c]?
22:42:07 <Jafet> > inits [a,b,c]
22:42:09 <lambdabot>   [[],[a],[a,b],[a,b,c]]
22:42:14 <startling> neat
22:42:24 <Cale> espringe: but it will be closed on its own at some point after you finish observing the end of the list
22:42:43 <otters> > [a..c]
22:42:45 <lambdabot>   *Exception: not a number
22:42:49 <otters> huh
22:43:07 <Cale> You're not really meant to apply hClose to a file handle which has had hGetContents applied to it
22:43:10 <espringe> But asynchronously if you lose a reference to it (when gc find it) and synchronously if you observe the end of the file?
22:43:43 <Cale> espringe: hmm, I think that's actually correct, but I'd need to check
22:44:05 <espringe> Cool, that's exactly the behavior I want/need :D
22:44:17 <Cale> espringe: In any case, "synchronously" when it comes to anything involving the timing of *evaluation* relative to *execution* is weird.
22:45:13 <Jafet> If you need the file to be closed at a certain point in execution, you should not be using lazy IO
22:46:24 <Jafet> What happens when you hClose a semi-closed handle, anyway?
22:46:33 <dolio> It closes.
22:46:41 <espringe> Well it should just mean that if I have a list of files, I can just run over them 1 at a time, and not worry about running out of FDs  (as i'll be reading to the very end of each file) ?
22:46:46 <pharaun> heh
22:47:29 <Ralith> espringe: that depends on how the data's used.
22:47:37 <Jafet> Then, I suppose you could close each file after reading to the end.
22:47:51 <dolio> You don't need to.
22:48:29 <dolio> That's why the deepseqing that people sometimes recommend works.
22:49:20 <Cale> espringe: So long as you make sure that you do the output which is relevant to each file before opening the next one, and that that output involves all the contents of the file, you should be okay.
22:49:26 <dolio> Because it's pretty likely that hGetContents' base case closes the handle when it reads EOF.
22:49:35 <dolio> Before yielding [].
22:49:56 <dolio> Because, might as well.
22:49:56 <Jafet> Knowing that and depending on that are different matters though
22:50:29 <dmwit> Somebody pointed out to me the other day that the documentation guarantees that.
22:50:44 <Jafet> And then there's knowing that.
22:50:50 <Cale> If you really really care, then you have to worry already when you go to open the first file, because you might be out of file descriptors :P
22:51:05 <dmwit> "A semi-closed handle becomes closed: if hClose is applied to it; if an I/O error occurs when reading an item from the handle; or once the entire contents of the handle has been read."
22:51:18 <startling> why doesn't Data.ByteString.Lazy.ByteString have a IsString instance?
22:51:54 <Jafet> Cale: if you get only one fd, but your program could run with only one fd, it should
22:52:07 <Jafet> I wonder if I can ulimit to one fd
22:52:23 <Jafet> That would probably break everything
22:52:26 <Jafet> including zsh
22:52:36 <dmwit> startling: it does
22:52:39 <Cale> I don't really understand why fds aren't only limited by available memory.
22:52:57 <Cale> In a general setting, anyway
22:53:00 <espringe> Just out of interest -- does ghc have any optimizations, where it can statically tell that at a certain point there's no more references to something and synchronously free the object (and call the "destructor" (AKA the thing that would've called close on the f)
22:53:05 <Jafet> Probably because the process descriptor table uses like a linked list for them
22:53:18 <startling> dmwit: do I need to have IsString imported or something? I'm getting " No instance for (Data.String.IsString ByteString)"
22:53:44 <Jafet> espringe: that's not a really important optimization, and one that could even interfere with the garbage collector
22:53:45 <lispy> espringe: are you asking if ghc supports finalizers?
22:53:46 <Cale> espringe: It doesn't do region inference, but that's been talked about a lot
22:53:59 <dolio> startling: It might be because only the Char8 versions are IsString.
22:54:03 <dolio> But I'm not sure.
22:54:21 <Cale> espringe: The generational GC that GHC uses is really pretty good at picking up a lot of short-lived garbage though
22:54:24 <startling> Char8 versions?
22:54:24 <dolio> The others are arguably not character strings.
22:54:28 <Jafet> ByteString shouldn't have an IsString instance
22:54:33 <dolio> Data.ByteString.Lazy.Char8
22:54:34 <Jafet> Though you can write one if you really want
22:54:39 <bxx> is there a way to fetch Bool out of IO Bool to directly, without assigning it to a variable with <- first?
22:54:45 <startling> dolio: ah
22:54:53 <dolio> Assuming I got that in the right order.
22:54:56 <Rogach> bxx: I think there is no "pure" way.
22:54:57 <Cale> bxx: An IO Bool is nothing like a Bool.
22:55:05 * lispy notes that it's that part of the fp courses again
22:55:08 <dmwit> startling: Perhaps the documentation is wrong. I'd be sort of surprised about that, though.
22:55:10 <bxx> Cale I know that
22:55:13 <Cale> bxx: It's a program, which if you were to run it, would result in a Bool.
22:55:26 <Cale> bxx: v <- x means "run the action x, and name its result v"
22:55:39 <dmwit> http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Lazy.html <- ^F IsString ByteString
22:55:45 <bxx> yes. and I want to run the action and fetch the result without assigning it to v first
22:55:58 <lispy> bxx: >>=
22:55:59 <Cale> bxx: But what happens to the result?
22:56:25 <dmwit> startling: could not reproduce
22:56:28 <startling> dmwit: weird.
22:56:41 <dmwit> startling: ghc-pkg list bytestring ?
22:57:10 <bxx> Cale the value is used in place
22:57:27 <bxx> I don't need to name it (unless haskell requires me to for some reason)
22:57:33 <startling> dmwit: bytestring-0.9.2.1
22:57:50 <bxx> lispy how does that work?  kind of hard to google it
22:58:10 <lispy> bxx: you can do things like, readFile "/etc/hosts" >>= print
22:58:10 <espringe> So in linux at least, it looks like a file-descriptor is just an offset into an open-file table. So regardless how many file-descriptors you use, it uses a constant amount of memory. So that's why they're so stingy with the max
22:58:21 <lispy> bxx: in that case, I didn't name the result but I did pass it to print
22:58:24 <dmwit> Well, the documentation says it's an instance.
22:58:27 <dmwit> Dunno what to tell you.
22:58:34 <yitz> @type (>>=) -- bxx
22:58:37 <lambdabot> forall (m :: * -> *) a b. Monad m => m a -> (a -> m b) -> m b
22:58:52 <Cale> bxx: If x is an IO action, and f is a function which takes the result of x as a parameter, and produces another IO action based on that, the action x >>= f will do the obvious thing, and run x first, getting its result, and then apply f to that, running the resulting action.
22:59:02 <bxx> lispy I wanted to do something like this   if   doesDirectoryExist p.  doesDirectoryExist returns IO Bool
22:59:09 <Cale> bxx: that is,  x >>= f = do v <- x; f v
22:59:37 <bxx> can I use the result in if ?
23:00:15 <lispy> do { b <- doesDirectoryExist p; if b then ... else ... }
23:00:25 <bxx> so I have to assign it.. ok
23:00:29 <Cale> bxx: You could however, write something like  ifM :: (Monad m) => m Bool -> m a -> m a -> m a
23:00:33 <Cale> and then use that :)
23:00:48 <Cale> (or replace all the m's by IO)
23:01:18 <Cale> ifM b t e = do bv <- b; if bv then t else e
23:01:31 <lispy> bxx: you don't have to assign it, but you do have to run the action
23:01:49 <dmwit> startling: oh god
23:01:50 <Cale> ifM (doesDirectoryExist p) (...) (...)
23:01:53 <lispy> bxx: the other option is as Cale says, put the if inside the IO
23:02:00 <dmwit> startling: The instance is in D.BS.L.Char8
23:02:15 <dmwit> startling: So just import D.BS.L.Char8 () and it'll work fine.
23:03:15 <bxx> is there any reason why something like this isn't possible?   if (runAction doesDirectoryExist p)
23:03:16 <Ralith> dmwit: unless he uses a unicode character that takes more than one byte, yes?
23:03:23 <startling> dmwit: oh bleh
23:03:35 <Ralith> startling: you should probably handle encodings explicitly
23:03:35 <Cale> bxx: Because what would the type of runAction be?
23:03:37 <lispy> bxx: yes, there is a very good technical reason
23:03:45 <lispy> bxx: mathematically deep even
23:03:49 <Cale> bxx: It would be  IO a -> a  right?
23:03:53 <startling> Ralith: this is a dumb test case to make sure things are reasonably correct
23:04:06 <bxx> I don't know what it would be. It would make working with IO more convenient though
23:04:28 <Cale> bxx: Well, suppose we had that  runAction getLine = "hello, there"
23:04:41 <Cale> bxx: But that would defeat the purpose of runAction
23:04:55 <Ralith> startling: playing it fast and loose with character encoding doesn't sound reasonably correct!
23:05:04 <Cale> Because then it would have to always produce "hello, there" in every program for all time, when applied to getLine!
23:05:04 <Ralith> but I don't know your situation, so.
23:05:16 <Cale> So it wouldn't really be running the action at all
23:05:16 <bxx> I see no technical reason why you have to assign action to a name to run it
23:05:25 <Cale> bxx: Oh, you don't have to.
23:05:35 <Cale> bxx: You mean naming the result?
23:05:38 <startling> Ralith: I just want to make sure my directories get made okay
23:05:41 <bxx> Cale yes
23:05:43 <Cale> You don't have to name the result
23:05:44 <Ralith> :P
23:05:55 <Ralith> startling: think of the poor unicode snowman directory!
23:06:00 <Ralith> all unsupported and alone
23:06:24 <Cale> You can combine an action with a function which will take the result of that action and decide how to proceed with another action
23:06:39 <Cale> without necessarily naming the parameter to that function
23:06:46 <Cale> and the primitive which does this is called >>=
23:06:53 <bxx> Cale that limits the use though. can't use it in if etc
23:06:57 * lispy has this urge to explain monads as a 'context' of computation. Without that 'context' the computation you want to do is not defined.
23:07:05 <Cale> Yeah, well, if is kind of a bad notation to begin with.
23:07:49 <bxx> I'd be happy with some syntactic sugar that runs it in place and returns result
23:07:51 <startling> Ralith: heh
23:07:58 <Cale> (don't get me wrong, it's nice sometimes)
23:08:01 <lispy> You can bring computations into the context, but you can't take them out without extra knowledge
23:08:52 <Cale> bxx: With the very latest GHC, there's an extension called lambda-case
23:09:13 <Cale> (which has not-my-favourite-choice of concrete syntax, but does just what you want)
23:09:19 <Cale> You could write:
23:09:23 <bxx> ah, interesting
23:09:41 <Cale> doesDirectoryExist p >>= \case True -> ...; False -> ...
23:09:55 <Cale> (and you can split that onto multiple lines)
23:10:09 <Cale> \case is a new keyword
23:10:20 <Cale> and that turns into:
23:10:20 <Ralith> startling: so long as you're only relying on the characters *you* enter being 1-byte, you can keep things under control--but don't assume user-supplied names or stuff already on the FS is.
23:10:30 <thirsteh> can I use an untyped literal for a Word8, e.g. Data.ByteString.breakByte 'c' "mybytestring"?
23:10:35 <Cale> doesDirectoryExist p >>= \freshVar -> case freshVar of True -> ...; False -> ...
23:10:44 <startling> Ralith: yes, of course
23:10:53 <Ralith> kk
23:11:06 <Ralith> a lot of people seem to completely ignore that issue and it sucks to deal with
23:11:12 <bxx> Cale odd that they went that route though, instead of some syntax that just runs it in place and lets you use result with existing syntax
23:11:14 <thirsteh> the examples suggest so, but getting Couldn't match expected type `GHC.Word.Word8' with actual type `Char' In the first argument of `B.breakByte', namely 'c'
23:11:21 <startling> Ralith: yeah, I'm familiar with it
23:11:26 <bxx> ie with if, case etc
23:11:34 <Cale> bxx: "just runs it in place" makes no sense
23:11:38 * Ralith wasn't sure
23:11:53 <startling> Ralith: everything's going to be read as bytes, decoded, encoded, and written as bytes
23:11:56 <Cale> bxx: An action like  getLine  doesn't have a definite result
23:12:38 <lispy> bxx: You might think of `IO a` (such as getLine) as a command to be interpreted by main.
23:12:39 <Cale> bxx: If I give you an action like getLine, and ask you, "what's the result of that?" there's no sensible way that you can answer me.
23:12:42 <bxx> if (runIt iOAction)   would be the same as   tmp <- ioAction  if tmp ..
23:12:51 <Ralith> thirsteh: what is "an untyped literal for a Word8"?
23:12:55 <Ralith> thirsteh: if it's a Word8, it's typed...
23:13:00 <startling> Cale, the result is getLine
23:13:06 <thirsteh> Ralith:  Couldn't match expected type `GHC.Word.Word8' with actual type `Char' In the first argument of `B.breakByte', namely 'c'
23:13:19 <Ralith> thirsteh: that doesn't answer my question.
23:13:24 <Cale> startling: he's asking for something of type IO a -> a
23:13:33 <startling> oh.
23:13:37 <Cale> bxx: Functions in Haskell have to be actual functions.
23:13:41 <thirsteh> Ralith: do you want to argue pedantics, or do you not understand the question?
23:13:44 <Jafet> I think bxx just wants to extend syntax to inside monads
23:13:47 <Ralith> thirsteh: the latter.
23:13:49 <bxx> Cale I never said it would be a function but syntactic sugar
23:14:07 <thirsteh> Ralith: I want to use Data.ByteString.breakByte, and I'm trying to do B.breakByte 'c' mybytestring
23:14:07 <Jafet> Thus making this conversation a strange inversion of wadler's law
23:14:08 <Cale> bxx: Okay, so runIt in your example would be a new keyword?
23:14:26 <thirsteh> Ralith: GHC gives me an error that it's expecting a Word8 and getting a Char. ('c' :: Word8) gives the same error
23:14:31 <bxx> Cale yes
23:14:38 <startling> I sort of wish you could combine a <- action; case a of
23:14:51 <Jafet> thirsteh: that's because 'c' is a Char. You can get its value with toEnum.ord.
23:15:03 <lispy> startling: you can in a limited way, Just a <- action
23:15:07 <Cale> bxx: Well, some people have considered syntaxes like that: if <- doesDirectoryExist p then ... else ...
23:15:07 <Ralith> thirsteh: ah, you mean you want to use a character literal as an ASCII literal.
23:15:14 <startling> lispy: yeah
23:15:19 <Ralith> thirsteh: that can't be done.
23:15:22 <lispy> :t guard -- startling and this
23:15:25 <lambdabot> forall (m :: * -> *). MonadPlus m => Bool -> m ()
23:15:25 <thirsteh> Jafet, Ralith: okay, I understand. I was confused and thought there was some implicit conversion/"overloading" going on since these are how all the examples in Data.ByteString are
23:15:31 <Cale> bxx: But it'd be much more elegant to not do something which is specific to monads.
23:15:47 <thirsteh> e.g. http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString.html#g:29 -> breakByte
23:16:04 <startling> could all of do notation be generalized to Applicative?
23:16:13 <Cale> bxx: this \case syntax (even if it's a bit uglier than what I'd have proposed), works in lots of other cases
23:16:21 <Ralith> thirsteh: as I was just discussing with startling, you should be very careful with implicit conversion/"overloading" that makes assumptions about character encoding; especially bad assumptions, like "characters are all 8 bits"
23:16:21 <Cale> which have nothing to do with do-notation.
23:16:32 <Ralith> Cale: what would you have proposed?
23:16:38 <thirsteh> Ralith: yeah, I just read some of the discussion, heh. Good timing
23:16:42 <lispy> startling: there is a doA in the applicative library
23:16:47 <Cale> What I would have done to the language is to allow you to leave the scrutinee of case and if blank.
23:16:50 <lispy> startling: or maybe just the paper
23:16:55 <Jafet> There is some artistic license in those examples, thirsteh
23:16:58 <startling> lispy: yeah, but is that exactly as powerful?
23:17:00 <Cale> and have that be a "section"
23:17:02 <Jafet> All character literals have type Char
23:17:05 <Ralith> Cale: so "case of ..."?
23:17:06 <thirsteh> Ralith: but indeed, what I want is the ASCII ':' as a Word8
23:17:10 <startling> why can't IsString for ByteString assume utf-8?
23:17:11 <Ralith> of "if then ... else ..."?
23:17:14 <Ralith> or*
23:17:15 <Cale> So  case of ...  means  \fresh -> case fresh of ...
23:17:20 <Cale> right
23:17:21 <Cale> exactly
23:17:25 <Jafet> startling: why should it?
23:17:26 <Ralith> that does sound nice.
23:17:34 <Cale> and then you could have written
23:17:44 * Ralith may try to get that in idris
23:17:45 <Cale> doesDirectoryExist p >>= if then ... else ...
23:17:59 <startling> Jafet: don't string literals assume utf-8 already?
23:18:16 <lispy> startling: when you ask about generalizing I'm not sure what you mean. Applicative is more general than Monad in the sense that all Monads are Applicatives, IIRC. But, if you "generalize" do-notation to applicative, wouldn't you have to "take out" the monad specific bits since applicative is more general and thus has less structure?
23:18:32 <shachaf> startling: Huh? No.
23:18:32 <Jafet> That's a behaviour of the compiler. The IsString instance is not.
23:18:33 <Ralith> thirsteh: I'm not sure if Haskell makes any guarantees about the value of toEnum.ord; if not, you'll need to use some character encoding lib.
23:18:59 <Ralith> thirsteh: Haskell may, however, guarantee that a unicode scalar value is obtained, in which case you can safely use it on characters you know to be ASCII.
23:19:01 <thirsteh> I could just express ':' as an integer, I suppose
23:19:07 <Jafet> Ralith: it guarantees that you get the value of the unicode codepoint
23:19:11 <startling> Jafet: okay.
23:19:11 <Ralith> wonderful!
23:19:13 <Jafet> Which happens to match all ascii characters
23:19:27 <Ralith> I wasn't sure it made any guarantees other than 'you get a value'
23:19:29 <startling> shachaf: to which?
23:19:36 <Ralith> thirsteh: so just use toEnum.ord as Jafet advises.
23:19:38 <Jafet> If it doesn't guarantee it, it's morally the correct behaviour anyway
23:19:41 <thirsteh> Ralith: this is bytestring on ASCII, no unicode
23:19:44 <thirsteh> I will, thanks
23:19:47 <shachaf> Jafet: don't string literals assume utf-8 already?
23:19:53 <shachaf> Also to 23:16 <startling> why can't IsString for ByteString assume utf-8?
23:20:02 <startling> shachaf: okay.
23:20:04 <shachaf> Jafet: Er, that was meant to have <startling> at the beginning.
23:20:25 <Jafet> Doctor No
23:21:47 * lispy thinks it time for sleep
23:23:49 <johnw> shachaf: you know that version of Context we talked about, the Context (b -> d) c one?
23:24:03 <johnw> (as a simpler form of (c -> f b) -> f d)
23:24:20 <shachaf> johnw: Yep.
23:24:37 <johnw> i've found that exact type called Costate, Comonad and Context in three separate papers
23:24:39 <johnw> is it all of them?
23:24:48 <johnw> (the implementation were all identical too)
23:24:56 <shachaf> "Comonad" is a class, like "Monad".
23:25:02 <johnw> sorry, Costate, Store, and Context
23:25:08 <shachaf> Ah.
23:25:24 <johnw> whereas Edward had made it clear that Store is not really Costate
23:25:26 <bxx> .
23:25:39 <shachaf> I think they're all at least very similar, if not identical. :-)
23:25:47 <johnw> heh, ok
23:26:05 <johnw> thanks for spending so much time with me, I'll came at it all again a little further down the road, but this definitely helped moved me along
23:26:11 <johnw> s/came/come
23:26:45 <johnw> i went ahead and filled out the implementation of the (b -> d) c version, which was trivial compared to the other one (no need for Compose)
23:27:16 <bxx> ok it seems that having to do isDir <- doesDirectoryExist p was the least of my problems. :) how can I make this work?  http://hpaste.org/77103
23:27:19 <shachaf> johnw: If you want to be sure that they're equivalent, write functions to convert back and forth. :-)
23:27:22 <hpaste> johnw pasted “context.hs” at http://hpaste.org/77104
23:27:25 <johnw> I ended up with this ^^
23:27:39 <johnw> I'm not clear yet on how to write getF in that pastie
23:27:45 <johnw> I need to figure that out before I can go back and forth
23:27:58 <shachaf> johnw: By the way, Bazaar (with Applicative) is a rather different thing from "(b -> d) c".
23:28:26 <shachaf> johnw: I don't think you can write getF like that.
23:28:41 <johnw> it sure defeated all my attempts, so that's good to hear
23:28:41 <shachaf> Er, wait.
23:28:52 <bxx> if/then/ is forcing me to put else result even though I don't care about it
23:29:05 <Jafet> :t when
23:29:21 <lambdabot> thread killed
23:29:30 <simpson> Wat.
23:29:32 <simpson> @ty when
23:29:43 <lambdabot> forall (m :: * -> *). Monad m => Bool -> m () -> m ()
23:30:12 <Jafet> @hoogle m () -> Bool
23:30:13 <lambdabot> Data.IntMap null :: IntMap a -> Bool
23:30:14 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
23:30:14 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
23:30:18 <Jafet> @hoogle m () -> Bool -> m ()
23:30:21 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
23:30:21 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
23:30:21 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
23:30:42 <Jafet> Heh, never used unless
23:31:07 <shachaf> johnw: Oh, wait.
23:31:14 <shachaf> johnw: You probably should just not listen to me.
23:31:32 <shachaf> Jafet will confirm that I spout off nonsense all the time.
23:31:40 <johnw> shachaf: gasp
23:31:41 <Jafet> Nonsense.
23:32:06 <simpson> shachaf: Nah, you're pretty cool.
23:32:39 <shachaf> simpson: Well, I'm hardly the most awesome dude.
23:32:49 <johnw> shachaf: so getF is possible and I should carry on the good fight?
23:34:04 <bxx> I am getting errors with when being last line in a procedure returning IO ().  Couldn't match expected type `IO ()' with actual type `[b0]'
23:34:22 <shachaf> johnw: Yep.
23:34:33 <johnw> ok, will do
23:34:34 <otters> Okay I don't understand which multiline string syntax is correct
23:34:43 <otters> everybody says that "this should\
23:34:46 <otters>     \ work"
23:34:47 <shachaf> johnw: (I didn't know it was possible until just now, but I just wrote it, so clearly it is. :-) )
23:34:56 <otters> but my cabal-dev ghci says parse error
23:35:00 <otters> and "this actually\
23:35:02 <otters>  does work"
23:35:06 <shachaf> johnw: Remember, you can pick any functor you like.
23:35:19 <johnw> you didn't use runIdentity (g Identity), I hope
23:35:31 <otters> But then
23:35:35 <otters> hlint hates that syntax
23:35:39 <otters> because it says \ is a parse error
23:35:41 <shachaf> johnw: That wouldn't type-check.
23:35:47 <johnw> ok, just making sure I'm sane
23:36:35 <bxx> here's the error:  http://hpaste.org/77105
23:37:18 <otters> @hoogle [m a] -> m ()
23:37:22 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
23:37:22 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
23:37:22 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
23:37:57 <johnw> getF (ContextF g) = getConst (g Const)
23:38:07 <shachaf> johnw: Yep.
23:38:16 <shachaf> Do you see how it works? It's just like Getter.
23:38:23 <johnw> sweet.  plus you just taught me about Const today :)
23:38:25 <shachaf> You're "sneaking out" the c inside the f.
23:38:34 <johnw> yeah
23:38:41 <johnw> Identity gets the value part, Const gets the context part
23:39:16 <shachaf> johnw: Now think about what would happen if you used Bazaar instead of Context. :-)
23:39:30 <johnw> i missed the whole bazaar thing, let me read my scrollback in that buffer
23:39:44 <shachaf> johnw: Bazaar = Context, with Applicative instead of Functor
23:40:28 <johnw> ah, found it
23:40:56 <johnw> with Bazaar I can do more good stuff
23:40:59 <johnw> <*> and all
23:42:11 <shachaf> johnw: Right.
23:42:31 <shachaf> 20:04 <edwardk> data Bazaar c d a = Buy a | Trade (Bazaar c d (d -> a)) c
23:42:46 <OceanSpray> > This is most likely traverses more than a purpose-written Functor instance.
23:42:52 <lambdabot>   mueval-core: Time limit exceeded
23:42:53 <OceanSpray> http://www.haskell.org/haskellwiki/Scrap_your_boilerplate
23:43:26 <shachaf> OceanSpray: Man, a *wiki article* has bad grammar?
23:43:31 <shachaf> What are we going to do?
23:43:59 <OceanSpray> I don't even know what the fuck the sentence is supposed to mean in the first place
23:44:18 <OceanSpray> so don't pull that "OH U COULD HAVE FIXED IT URSELF" pile of manure
23:44:33 <startling> why doesn't Map have traverseWithKey? :(
23:44:48 <johnw> it has been suggested that syb and lens have a huge overlap, is that right?
23:45:15 <shachaf> startling: itraverse
23:45:26 <startling> shachaf, where do I find that?
23:45:30 <shachaf> Control.Lens
23:45:37 <startling> of course
23:45:43 <shachaf> johnw: Well, sort of.
23:45:53 <johnw> once lens gets fully dependent types, we'll all be good
23:48:17 <startling> haha
23:51:54 <johnw> shachaf: is my type signature for modifyF even possible?
23:51:57 <johnw> modifyF :: (c -> c) -> ContextF c d b -> b
23:52:13 <johnw> or should it be f b with a Functor constraint?
23:54:16 <shachaf> Wouldn't it be modifyF :: (c -> c) -> ContextF c c b -> b ?
23:54:22 <shachaf> Or modifyF :: (c -> d) -> ContextF c d b -> b
23:54:25 <bxx> it looks like you can do  whenM (doesDirectoryExist dir)
23:54:29 <johnw> the latter
23:54:37 <johnw> wait
23:54:44 <johnw> the first argument is modifying the context only
23:55:18 <startling> shachaf, doesn't seem to be a TraversableWithKey instance for Map k ?
23:55:30 <johnw> like, modifyF (+1) x, where x is a ContextF
23:55:49 <shachaf> startling: You mean WithIndex?
23:56:10 <startling> er yeah
23:56:35 <shachaf> startling: Yes there does.
23:58:13 <startling> what is wrong with me today? found it.
