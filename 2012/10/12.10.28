00:06:40 <donri> dreixel: are we supposed to use generic-deriving rather than ghc-prim directly?
00:09:18 <dreixel> donri: yes, I think that's best
00:10:30 <donri> #if __GLASGOW_HASKELL__ < 710
00:10:37 <donri> bug?
00:11:01 <dmwit> Can you elaborate?
00:11:17 <rwbarton> that means 7.10 doesn't it?
00:11:21 <dreixel> nope
00:11:24 <dreixel> that means 7.1
00:11:32 <donri> no, 7.1 is 701
00:11:36 <donri> afaik?
00:11:54 <donri> the same file uses 701 in another #if
00:12:03 <dreixel> ohw
00:12:04 <donri> https://github.com/dreixel/generic-deriving/blob/master/src/Generics/Deriving/Base.hs#L10
00:13:06 <dmwit> "For version x.y.z of GHC, the value of __GLASGOW_HASKELL__ is the integer xyy (if y is a single digit, then a leading zero is added)."
00:13:10 <dmwit> So, yeah, looks like a bug.
00:13:48 <dreixel> yes, thanks a lot
00:13:50 <dreixel> fixing it straight away
00:13:56 <donri> \o/
00:14:02 <dreixel> pretty nasty one
00:14:13 <donri> __GLASGOW_HASKELL__ isn't very intuitive
00:14:19 <dreixel> true
00:14:21 <donri> but consider that 6.12 is 612 and it makes more sense
00:15:33 <dmwit> We're going to have a real problem when 7.98 gets patched.
00:15:46 <donri> :)
00:15:47 <dreixel> :)
00:15:59 <dreixel> new version on Hackage, thanks again, donri
00:16:05 <donri> 70A
00:16:31 <donri> cool
00:17:54 <donri> incidentally i only knew it was wrong because i learned __GLASGOW_HASKELL__ when using generics without generic-deriving
00:18:47 <donri> though guess i still need that for DefaultSignatures
00:22:03 <dreixel> donri: what version of the compiler are you using?
00:22:24 <donri> personally, 7.4.1, but the code is meant to work without generics if not available
00:22:39 <donri> (web-routes, also working on safecopy)
00:25:51 <donri> i suppose it's doable without DefaultSignatures and DeriveGeneric by exporting the generic functions and derive Generic with TH... but then it's not really a big win over deriving our classes with TH
00:26:11 <donri> which is already supported anyway
00:27:10 <dreixel> donri: yes
00:30:30 <donri> kinda wish we could do `deriving (Class)` as sugar for `deriving (Generic); instance Class T`... or at least, `deriving (Generic, Class)` as sugar for `instance Class T`
00:31:34 <donri> although i guess the current way is easier to refactor e.g. with safecopy when you want to bump the 'version' or if you want to override the generic methods
00:32:59 <donri> and i guess it could be confusing to have implicitly derived classes (Generic)... especially since Generic exposes things about the type you might hide from module exports...
00:33:12 * donri sleep deprived ramblings
00:45:06 <ectospasm> If I've got a function that returns X (Maybe a)... How do I get from X (Maybe a) -> a ? I'm trying something in XMonad, and I'm getting stumped on this little piece of Haskell.
00:45:48 <donri> depends on the definition of X, and you'll need to deal with the Nothing case somehow
00:59:09 <dada-cetacean> actually, Table[] can be emulated using map and anonymous functions
01:06:22 <ectospasm> donri: I'm only concerned with the a part of X (Maybe a).  X is the X monad (from XMonad), but since this seemed to be more Haskell specific I asked here.
01:08:09 <donri> ectospasm: aha. in that case you probably want something like, thing >>= maybe (action to take if Nothing) (function to run with the `a` if not Nothing)
01:08:21 <donri> where thing is the X (Maybe a)
01:09:01 <ectospasm> donri: OK, I'll try that
01:09:04 <donri> the arguments to maybe should produce computations in the X monad
01:20:49 <ectospasm> hmmm, I still don't know how to get to 'a' in this context.  It's a WorkspaceId, and I'm just trying to find the workspace on the visible (but not focused) screen, and send a particular window to it.
01:24:37 <donri> well I don't know xmonad, but something like, getWID >>= maybe (return ()) (`moveWID` window), where moveWID :: WorkspaceID -> Window -> X ()
01:26:26 <donri> looks like xmonad provides a whenJust helper for this pattern
01:27:09 <donri> do ma <- getWID; whenJust ma $ \a -> moveWID a window
01:28:05 <ectospasm> All I need to do is get the WorkspaceID... I can doShift WorkspaceId to send the window to that workspace.  I feel like I'm close with X (Maybe WorkspaceId), I just need to be able to get to the workspace ID from the funciton that returns X (Maybe WorkspaceId)
01:30:57 <donri> ectospasm: getWorkspaceId >>= flip whenJust doShift
01:34:39 <donri> assuming doShift :: WorkspaceId -> X ()
01:36:45 <ectospasm> donri: actually, doShift :: WorkspaceId -> ManageHook
01:37:16 <ectospasm> ...but I can call doShift on a window class and it will move the window to that workspace
01:37:32 <ectospasm> ...I just pass it a string if I want it to go to a specific named workspace
01:37:42 <donri> well if it's a ManageHook it looks like from the types you'll need to runQuery
01:38:05 <ectospasm> ...but I need to figure out programatically which workspace is visible on my left monitor (there should be only one)
01:39:03 <ectospasm> ...since I want this window to appear only on the left monitor (screen 0)
01:39:56 <donri> well it looks like the only way to call doShift from inside the X monad is to runQuery
01:40:12 <ectospasm> ManageHook may be a wrapper for that
01:40:23 <donri> type ManageHook = Query (Endo WindowSet)
01:40:47 <donri> gah freenode i hate you :p
01:41:14 <ectospasm> actually, that's the first major net split I've noticed in a long time
01:41:21 <ectospasm> I do lurk quite often, though
01:41:58 <paolino> sure
01:41:58 <Maxdamantus> What's important is what sort of problems become type errors in Haskell.
01:41:58 <covi> So, why particularly Haskell
01:41:58 <covi> Maxdamantus: can you give me an example?
01:42:00 <Maxdamantus> I think it comes a lot from functional programming: everything's about putting something in and getting something out, rather than changing states of objects.
01:42:01 <paolino> IO and monads to model effectful computation
01:42:02 <dreixel> donri: see http://hackage.haskell.org/trac/ghc/ticket/7346, comment if you like the feature request
01:42:03 <donri> ectospasm: getWorkspaceId >>= (`whenJust` $ \a -> runQuery (doShift a) window >> return ())
01:42:10 <paolino> Maxdamantus, and referential transparency.
01:42:11 <paolino> same in same out
01:42:11 <Maxdamantus> covi: in an OO language, you might be required to do something like: o.foo(); o.bar(); o.baz();, where each statement changes the state of o.
01:42:11 <Maxdamantus> covi: if you forget about o.bar(), what happens?
01:42:12 <Maxdamantus> You'd probably think about it differently functionally, where foo, bar and baz are functions that each map from one type to another.
01:42:12 <Maxdamantus> Depending what they actually do.
01:42:13 <Maxdamantus> It'd be sort of like, in the case above, having a type for each state of o.
01:42:37 <ectospasm> donri: where is getWorkspaceId coming from?
01:42:47 <ectospasm> ...or is that the function definition?
01:42:58 <donri> ectospasm: it's your thing that returns X (Maybe WorkspaceId)
01:43:20 <donri> i just gave it a random name because i don't have your code
01:44:51 <donri> you will also need a window :: Window
01:45:05 <donri> presumably the window you're moving
01:46:35 <paolino> Is there a standard way to name a kind of monoid with 2 operations insert, delete :: a -> a -> a ?
01:47:27 <donri> dreixel: ah, nice
01:55:20 <paolino> relative numbers are an instance of it
02:03:03 <ectospasm> donri: no, you seem to misunderstand.  The line I'm using looks like this , className =? "Orage"  --> doFloat <+> doShift (screenWorkspace 0), where (screenWorkspace 0) is what returns X (Maybe WorkspaceId)
02:03:23 <ectospasm> All I need is to be able to extract the WorkspaceId from (screenWorkspac 0)
02:03:55 <donri> well you need to be in, and stay in, the X monad
02:03:59 <ectospasm> s/ac /ace /
02:04:12 <donri> presumably this thing is part of a bigger thing that runs in the X monad?
02:04:20 <ectospasm> donri: yes
02:04:59 <ectospasm> I think I've gotten close enough to back to #xmonad and try again.
02:05:09 <ectospasm> ...or the mailing list
02:05:44 <donri> you still need to figure out what you want to do if it returns Nothing
02:06:11 <donri> presumably, not doing anything, or defaulting to some known WindowId
02:06:16 <donri> uh WorkspaceId
02:06:47 <donri> but you can get at the Maybe with a <- in do notation
02:07:45 <donri> do a <- screenWorkspace 0; ... className bla bla doShift (fromMaybe defaultWorkspaceId a)
02:08:15 <donri> import Data.Maybe -- for fromMaybe
02:09:57 <Ralith> what's a good, easy to use lib for simple 2D scatter/line plots?
02:10:17 <ectospasm> gnuplot?
02:10:33 <Ralith> preferably something I can use from within haskell and feed haskell data directly
02:10:43 <ectospasm> I can't answer that
02:10:58 <Ralith> gnuplot is a good, moderate-difficulty lib for complex 2/3D plots of very many kinds.
02:11:06 <ectospasm> maxima is the only other thing I can think of
02:11:17 <Ralith> except s/lib/tool/
02:11:17 <Ralith> holy
02:11:18 <ectospasm> ...but that's more like maple/mathematica
02:11:29 <Ralith> maxima is even less convenient for these purposes
02:11:36 <Ralith> I have some data in haskell, I want to plot it.
02:14:47 <donri> Ralith: there's a 'plot' package, does it look relevant?
02:14:55 <donri> i don't suppose 'diagrams' does what you want directly
02:15:11 <Ralith> I'm looking at the plot docs already; it looks like overkill, but certainly usable.
02:20:45 <Paprikachu> is it allowed to call main recursively?
02:23:52 <donri> sure why not
02:27:54 <Ralith> Paprikachu: you may find that some questions can be answered more quickly by experimentation than by asking IRC.
02:28:15 <Paprikachu> just because it works, it doesn't mean it's allowed
02:28:41 <Ralith> just because we say so doesn't mean that either.
02:29:55 <Paprikachu> it's more likely though
02:30:04 <donri> uh, if it works, it is allowed. what do you mean? are you asking for best practices?
02:30:33 <Paprikachu> i'm coming from c++, where this isn't true
02:30:47 <Paprikachu> just because something compiles, it may still be wrong
02:30:54 <Ralith> it's more likely though
02:30:59 <Paprikachu> so that's why i'm asking.
02:31:01 <donri> i think Ralith was assuming that you'd also run the compiled program
02:31:25 <Paprikachu> even if it works, it may be disallowed or wrong
02:31:36 <Paprikachu> compiles + works != correct
02:31:44 <Paprikachu> at least in my language background
02:32:11 <donri> main = do x <- getLine; when (x /= "quit") $ do thingsWith x; main
02:32:12 <hpaste> ectospasm pasted “Got it (donri)” at http://hpaste.org/76885
02:33:16 <ectospasm> donri: I need OODavo's help in #xmonad to get me through.  donri, thanks for helping me, you got me closer than you think.
02:33:28 <donri> \o/
02:33:35 <Ralith> Paprikachu: if you are interested only in what is precisely 'correct', your only reference should be the specification.
02:34:08 <Paprikachu> i was assuming you know what the specification says about that since it's a rather basic question
02:37:26 <Paprikachu> oh you netsplits
02:37:26 <Ralith> why assume when you can check? it's not a terribly opaque document.
02:37:26 <donri> Paprikachu: 'main' isn't really special, only in that it's called for you at the start. beyond that, it's like any IO action.
02:37:26 <dada-cetacean> is there a general-purpose math library?
02:37:26 <donri> Paprikachu: and recursion is bread and butter in haskell.
02:37:27 <donri> dada-cetacean: not sure what you're asking for. i think vector and repa cover some of the things numpy does, for example. http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Vector_Tutorial http://www.haskell.org/haskellwiki/Numeric_Haskell:_A_Repa_Tutorial
02:37:34 <lazard> lam
02:37:46 <lazard> oops
02:38:06 <Paprikachu> my client can barely handle that amount of quits D:
02:38:13 <dada-cetacean> donri: these look neat, thanks!
02:38:32 <Paprikachu> also, thanks donri.
02:39:31 <Botje> @pl \x -> filter (const $ p x) [f x]
02:39:31 <lambdabot> ap (filter . const . p) (return . f)
02:40:01 <sohum> Botje: thanks, but using filter is kinda cheating for my purpose :P
02:40:46 <sohum> basically, I _think_ there's a correspondence between return/mempty and True/False, but I don't know enough category theory to figure out what it is
02:44:28 <Paprikachu> :t const
02:44:30 <lambdabot> forall a b. a -> b -> a
02:44:33 <Paprikachu> > "hi"
02:44:34 <Paprikachu> :(
02:44:34 <lambdabot>   "hi"
02:44:46 <Paprikachu> ah.
02:44:50 <Paprikachu> what's const?
02:44:53 <Paprikachu> > const 42
02:45:03 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
02:45:03 <lambdabot>    arising from a use of `...
02:45:13 <Botje> const takes two arguments and returns its first argumetn
02:45:15 <sohum> > (const 42) undefined
02:45:21 <lambdabot>   42
02:45:26 <Botje> > map (const "hallo") [1..55]
02:45:28 <lambdabot>   ["hallo","hallo","hallo","hallo","hallo","hallo","hallo","hallo","hallo","h...
02:45:30 <sohum> const x is the constant function returning x
02:46:11 <Paprikachu> what's undefined?
02:46:25 <ivanm> Paprikachu: it's the Haskell implementation of the "bottom" value
02:46:26 <alex-shpilkin> > undefined
02:46:27 <lambdabot>   *Exception: Prelude.undefined
02:46:39 <alex-shpilkin> >[1,2,undefined]
02:46:45 <alex-shpilkin> > [1,2,undefined]
02:46:45 <lambdabot>   [1,2,*Exception: Prelude.undefined
02:46:53 <ivanm> @type undefined
02:46:54 <lambdabot> forall a. a
02:48:05 <Paprikachu> so when does undefined raise an exception?
02:48:11 <sohum> whenever it is evaluated
02:48:12 <ivanm> that's how it's defined
02:48:14 <ivanm> @src undefined
02:48:14 <lambdabot> undefined =  error "Prelude.undefined"
02:48:19 <ivanm> oh, sorry, _when_, not _how_
02:48:31 <ivanm> > take 2 [1, 2, undefined] -- no error here!
02:48:32 <lambdabot>   [1,2]
02:48:42 <sohum> that's the point I was making, that const doesn't evaluate its second argument
02:48:54 <Paprikachu> i see
02:49:26 <ivanm> sohum: with all the netsplits I couldn't see what was going on before I got back to my computer just now :s
02:49:36 <sohum> (which is a far less general way of saying that haskell is lazy and unused values are never evaluated but WHATEVER)
02:49:41 <sohum> ivanm: sure sure :P
02:49:47 <sohum> ivanm: actually, if you're around
02:49:53 <ivanm> shoot
02:50:04 <sohum> is there a correspondence between return/mempty and True/False?
02:50:16 <ivanm> ummmm.... I don't think so.....
02:50:25 <sohum> in the sense that there's a clever category-theoretic version of \x -> if p x then [x] else [] ?
02:50:50 <paolino> :t mempty
02:50:51 <lambdabot> forall a. (Monoid a) => a
02:51:00 <ivanm> I've gotten into the habit of using (:[]) rather than return, but in terms of your actual question I don't do much stuff with CT :)
02:51:10 <sohum> sure :P thanks!
02:51:26 <sohum> :t (:[])
02:51:27 <lambdabot> forall a. a -> [a]
02:51:34 <sohum> oh, derp
02:51:35 <sohum> right
02:51:43 <ivanm> I figured you were referring to using return somehow to turn x into [x]
02:51:48 <sohum> yes, I was
02:52:07 <paolino> :t listToMaybe
02:52:08 <lambdabot> forall a. [a] -> Maybe a
02:52:14 <mikeplus64> is there a reader/writer monad (not a reader/writer/state monad) somewhere?
02:52:23 <ivanm> not pre-defined
02:52:27 <ivanm> unless you abuse State for it
02:52:32 <ivanm> you can write your own
02:52:37 <mikeplus64> alright
02:52:41 <ivanm> or use ReaderT (WriterT Identity)
02:52:46 <paolino> :t maybeToList
02:52:47 <lambdabot> forall a. Maybe a -> [a]
02:53:01 <ivanm> listToMaybe == safeHead
02:53:11 * hackagebot language-spelling 0.2 - Various tools to detect/correct mistakes in words  http://hackage.haskell.org/package/language-spelling-0.2 (FrancescoMazzoli)
02:53:56 <mikeplus64> and then use ask >=> tell as the moral equivalent to tell, ivanm?
02:54:24 <mikeplus64> i mean something else
02:54:28 <ivanm> for ReaderT (WriterT Identity) ?
02:54:36 <mikeplus64> oh actually nevermind
02:54:38 <ivanm> just use tell, if you're using mtl rather than just transformers
02:54:44 <mikeplus64> yeah
02:54:47 <ivanm> @type ask >=> tell
02:54:48 <lambdabot> forall (m :: * -> *) b. (MonadWriter b m) => m b -> m ()
02:54:52 <ivanm> (just curious)
02:55:10 <ivanm> @type tell
02:55:11 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
02:55:38 <ivanm> the ask there is completely useless, right?
02:56:07 <paolino> :t ask >>= tell
02:56:08 <lambdabot> forall (m :: * -> *) a. (MonadReader a m, MonadWriter a m) => m ()
02:57:02 <paolino> :t runWriter ask
02:57:03 <lambdabot> forall w a. (Monoid w, MonadReader a Identity) => (a, w)
02:57:11 <paolino> bah
02:59:46 <shachaf> ?
03:01:43 <paolino> Did I mention Identity ?
03:02:19 <efie> I have the function myIterate :: a -> a which I want to apply a few times to a data to make the data "better". If I do "myIterate data" it works, but if I do "myiterate (myIterate data)" I get "Killed", probably because myIterate takes a lat of space and creates thunks. So I thought, if "myIterate data" works, it should also work when I make it strict: "myIterate $! (myIterate data)", but I also get "Killed". What am I missing?
03:02:30 <shachaf> paolino: Yep -- runWriter.
03:02:34 <shachaf> (Implcitly.)
03:02:39 <fmap> :t runWriterT ask
03:02:41 <lambdabot> forall w (m :: * -> *) a. (Monoid w, MonadReader a m) => m (a, w)
03:03:08 <shachaf> efie: I don't know. Surely there's something more useful than "Killed".
03:03:28 <paolino> :src Writer
03:03:33 <shachaf> Are you just running myIterate twice?
03:03:33 <efie> shachaf: sorry, what do you mean?
03:03:35 <ivanm> efie: where is the "Killed" coming from?
03:03:38 <paolino> @src Writer
03:03:39 <lambdabot> Source not found.
03:03:49 <shachaf> efie: I mean that you're not providing enough information for people to help you. :-)
03:03:52 <randomclown> is it me or is Monad.Reader the same thing as Monad.State?
03:03:55 <ivanm> paolino: Writer = WriterT Identity
03:03:59 <ivanm> randomclown: it isn't
03:04:02 <shachaf> randomclown: It's you.
03:04:14 <ivanm> * the same
03:04:20 <shachaf> Reader r a = r -> a; State s a = s -> (a,s)
03:04:23 <randomclown> seems like ask = get, local = put
03:04:24 <ivanm> randomclown: if you use State as a Reader, it will be much slower
03:04:29 <ivanm> than just using Reader
03:04:29 <shachaf> randomclown: Nope.
03:04:38 <shachaf> A good exercise is to figure out why not. :-)
03:04:38 <ivanm> because of the definition of >>=
03:05:34 <paolino> local is local
03:05:47 <shachaf> ivanm: Slower?
03:05:59 <shachaf> This is really not a question of performance.
03:06:17 <ivanm> shachaf: I had some code with State, but I slowly started removing the State-ful aspect and was just using it to pass around some values (i.e. Reader)
03:06:28 <ivanm> when I replaced State with Reader, the speed improved dramatically
03:06:44 <ivanm> oh, I didn't see that randomclown was also equating local with put
03:06:50 <shachaf> Improving performance of your code is great. Fixing things that use State when they should use Reader is also great.
03:07:04 <ivanm> I thought he was just talking about being able to use State as a Reader
03:07:09 <shachaf> But the difference between Reader and State is definitely not just operational. :-)
03:07:18 <shachaf> Oh.
03:07:26 <shachaf> You also can't use a State as a Reader.
03:07:28 <ivanm> randomclown: local is more like do { s <- get; put s'; <do stuff>; put s{
03:07:53 <ivanm> @type local
03:07:54 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
03:08:08 <ivanm> shachaf: why can't you?
03:08:26 <shachaf> ivanm: Whatever laws you can expect Reader to have, it probably doesn't obey them.
03:08:51 <ivanm> if you're only using ask/get, doesn't it do the same thing?
03:09:15 <shachaf> Well, yes.
03:09:23 <shachaf> IO is also basically Reader. :-)
03:09:45 <shachaf> Anyway, never mind all that.
03:09:54 <randomclown> so put = return
03:10:04 <shachaf> No.
03:10:25 <randomclown> and local is just temporally change the enviroment to run another thing
03:10:38 <ivanm> shachaf: using an MVar or something?
03:10:43 <ivanm> wait, forget that
03:10:47 <shachaf> Maybe you can look at some kind of CPSed Reader, where you do "local" for every operation, as being like State. :-)
03:11:12 <shachaf> (Don't.)
03:12:25 <paolino> randomclown, return is a monad method
03:13:12 * hackagebot aivika 0.4.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.4.1 (DavidSorokin)
03:14:21 <efie> shachaf: ivanm: sorry, I hope this is more helpful?: http://hpaste.org/76886
03:14:26 <randomclown> So it's like state, but only has "get", and a way to temporally change the enviroment to run another computation. There is no direct equalvalent to "put". Return behaves the same as in "state"/
03:14:52 <ivanm> @type state
03:14:53 <lambdabot> forall s a. (s -> (a, s)) -> State s a
03:15:00 <shachaf> randomclown: Reader is like a function.
03:15:01 <ivanm> that's not return
03:15:01 <shachaf> That's all.
03:15:17 <ivanm> ((->)a) is the Reader monad!
03:15:23 <shachaf> efie: You should take ivanm's advice.
03:15:32 <ivanm> efie: what am I looking at here?
03:15:49 <ivanm> shachaf: what advice did I give? >_>
03:15:56 <ivanm> I just asked where the "Killed" came from!
03:16:01 <shachaf> efie: Anyway, putting one $! at the top isn't going to help you much if myIterate has bad strictness.
03:16:06 <shachaf> You'll have to fix myIterate itself.
03:16:15 <paolino> randomclown return should not reveal the effect of the monad
03:16:17 <shachaf> 03:03 <ivanm> efie: where is the "Killed" coming from?
03:16:28 <ivanm> how is that advice?  That's me wondering what's going on! ;)
03:16:40 <shachaf> ivanm: OK, you were being a role model, not giving advice.
03:16:53 <ivanm> I would think that using lazy IO for this probably isn't the best possible idea
03:17:24 <ivanm> also, using return there isn't that great; corpusE = (map T.words . T.lines) <$> T.IO.readFile "..."
03:17:41 <randomclown> fmap is fine...
03:17:48 <ivanm> randomclown: <$> == fmap :)
03:17:59 <shachaf> ivanm:: You're almost as fast as hpaste!
03:18:01 <ivanm> I think that's also the first time I've seen someone do a qualified import containing .
03:18:10 <ivanm> shachaf: how so?
03:18:29 <shachaf> hpaste detected the ">>= return ." thing.
03:18:30 <ivanm> though I note that hpaste has a suggestion to use liftM down the bottom... :/
03:18:34 <ivanm> yeah
03:18:37 <ivanm> well, hlint did
03:18:43 <shachaf> Yes, liftM is the only correct suggestion it can make.
03:18:54 * shachaf superclass blah blah
03:18:57 <ivanm> heh
03:19:16 <ivanm> efie: can you paste the source of myIterate up somewhere?
03:25:37 <efie> ivanm: I'd be happy if you look at it, but it is rather long: http://hpaste.org/76888
03:26:42 <ivanm> efie: OK, I still have nfi where that "Killed" comes from
03:26:53 <ivanm> are you running this in some kind of special interpreter that has a time limit on it or something?
03:27:18 <efie> hm no
03:27:19 <ivanm> though I can see why this is so inefficient... look at all those uses of `!!'
03:27:31 <randomclown> check memory/cpu usage, most like killed by rlimits
03:27:35 <randomclown> likely*
03:27:39 <ivanm> randomclown: oh, didn't think about the OS doing it
03:28:11 <ivanm> efie: I highly suggest you re-consider how you defined all those functions; using !! - especially with an increasing parameter - is a code smell
03:28:25 <ivanm> (also, doing an == test after a /= test is redundant; use otherwise!)
03:28:53 <ivanm> you're also using length over and over :s
03:29:02 <ivanm> consider either using an Array or a Map rather than a list
03:29:19 <randomclown> mutable arrays in ST, standard.
03:29:43 <ivanm> I don't think efie needs to go with the ST approach quite yet
03:29:54 <randomclown> that was a joke
03:29:59 <ivanm> ahhhh
03:30:15 <efie> ivanm: I call length when I have a list of T.Text, I don't know if its right to use a Map here
03:31:12 <efie> ivanm: I also thouht about adding $! operators in all these recursion... but then again, if myIterate works if I apply it once, why does it not work If I apply it twice and force the first evaluation to be done strictly?
03:31:24 <ivanm> efie: using $! blindly won't help
03:31:46 <ivanm> efie: if you're repeatedly indexing a list or calculating its length, you're either a) doing something wrong, or b) using the wrong data structure
03:32:06 <ivanm> you can use a Map as an "indexed list", though an Array would probably be better
03:32:32 <ivanm> though using a Map would allow you to change the size (I didn't look at the code that much to see if you change the size of the list)
03:34:30 <efie> what do you by that you can use a Map as an indexed list?
03:35:29 <ivanm> `Map Int a' instead of [a]
03:35:41 <ivanm> then when you want to do xs !! i, do mXs M.! i
03:35:50 <ivanm> which is O(log n) instead of O(n)
03:35:55 <efie> ah ok :)
03:36:29 <fmap> and Map Int is IntMap
03:37:05 <efie> but I am sure I get killed because it takes too much memory, changing from a List to Map won't help me with this I guess
03:38:33 <romildo> I have a parser called pLet written with parsec using monadic operations (do notation), and I want to rewrite it using applicative operators: http://dpaste.com/819341/  . My attempt at that is giving a type error. Any help is welcome.
03:39:24 <romildo> updated code: http://dpaste.com/819342/
03:40:33 <efie> I guess lists are more space efficient than maps, aren't they?
03:42:21 <ivanm> fmap: oh, right, I tend to forget about that; the few times I use "Map Int" for something, I find that IntMap doesn't tend to improve performance (and if anything decreases it since it doesn't store the size of the Map, which I sometimes need)
03:42:36 <ivanm> in efie's case, since he's calculating the length, using Map is probably better than IntMap because of that
03:42:59 <abizern> This type system is kicking my butt.
03:43:01 <abizern> :(
03:43:09 <ivanm> efie: yes, in that you're not storing key values as well, etc.
03:43:28 <ivanm> but, they're cheaper to update if you have to update a single value rather than mapping over the entire list
03:43:30 <abizern> I just want to read the contents of the standard input as a list of strings.
03:43:37 <ivanm> romildo: what's the error?
03:43:52 <abizern> I've got this in a do block:
03:43:52 <ivanm> @hoogle IO String
03:43:52 <lambdabot> Did you mean: :: IO String
03:43:52 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
03:43:53 <lambdabot> System.IO.Error ioeSetErrorString :: IOError -> String -> IOError
03:43:56 <hpaste> fmap pasted “for romildo” at http://hpaste.org/76889
03:44:00 <abizern> inp <- getContents >>= return $ (\s -> lines s)
03:44:03 <mikeplus64> instance Monoid a => Monoid (IO a) where mappend x y = do {rx <- x; ry <- y; return (mappend rx ry) }; mempty = return mempty
03:44:05 <fmap> you probably meant something like this
03:44:08 <mikeplus64> anyone care to disuade me from using that?
03:44:12 <fmap> (highly untested)
03:44:18 <ivanm> abizern: nah, that's not right
03:44:24 <ivanm> if you want it like that, use . rather than $
03:44:35 <ivanm> or you can just do: inp <- fmap lines getContents
03:44:41 <ivanm> or lines <$> getContents
03:44:58 <abizern> :t <$>
03:45:00 <lambdabot> parse error on input `<$>'
03:45:12 <ivanm> mikeplus64: any particular reason you're not doing your computations in pure functions?
03:45:15 <ivanm> @type (<$>)
03:45:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:45:21 <ivanm> abizern: <$> == infix fmap
03:45:23 <mikeplus64> ivanm: i'm just playing around
03:45:24 <ivanm> @src (<$>)
03:45:25 <lambdabot> f <$> a = fmap f a
03:45:46 <mikeplus64> ivanm: (also this is very nifty for things like getLine <> getLine <> ...)
03:45:57 <ivanm> hmmmmm......
03:45:59 <ivanm> true
03:46:09 <ivanm> I can't think of any particular reason _why_ you wouldn't do that
03:46:21 <ivanm> (as in no reason why it will break something)
03:46:27 <ivanm> apart from being an orphan instance, etc.
03:46:58 <hpaste> romildo pasted “error compiing http://dpaste.com/819342/” at http://hpaste.org/76890
03:48:21 <abizern> So - please tell me if I've got this wrong. with: inp <- fmap lines getContents
03:48:30 <abizern> The functor is IO
03:49:02 <abizern> lines is the (a -> b) which in this case is String to [String]
03:49:03 <ivanm> abizern: yup
03:49:07 <efie> ivanm: maybe switching from Map to HashMap will also help
03:49:19 <ivanm> efie: no, because you want Int as your key type
03:49:19 <abizern> and getContents has type IO String
03:49:23 <ivanm> which isn't what HashMap is for
03:49:24 <ivanm> abizern: yes
03:49:27 <abizern> which matches the functor type f
03:49:32 <ivanm> romildo: are you missing the val parser?
03:50:54 <abizern> I think I'm getting this. I'll have to review my Functor notes again.
03:50:56 <abizern> Thanks
03:55:27 <efie> ivanm: I still don't get why "myIterate initData" works, but "myIterate $! (myIterate initData)" doesn't - I mean, "myIterate initData" takes the same space as initData, and if it is strictily computed, there is no space being used of the the first myIterate call, when the second call starts, if I get the concept of $! right
03:56:18 <ivanm> efie: as randomclown said earlier, that's probably an OS thing
03:56:24 <ivanm> because you're using too much RAM/CPU
03:56:34 <ivanm> nothing to do with being strict
03:56:52 <ivanm> (especially since $! isn't making it fully strict, just enforcing that the first constructor is returned)
03:57:05 <ivanm> so no, you're not understanding $! properly :)
03:59:27 <efie> ok, assuming that I know how to enforce evaluating the first "myIterate initData" call strict, how can more RAM/CPU being used then? because as the second myIterate call does not do anything untill the first one is finished
03:59:52 <romildo> ivanm, the error regarding use of applicative operators is this: http://hpaste.org/76890
04:01:40 <ivanm> well, what I pointed out doesn't help :)
04:02:25 <ivanm> efie: as I'm only guessing as to it being an OS limit thing going on (as I can't work out where else "Killed" would be coming from), the best guess I can say is fix up myIterate
04:02:29 <ivanm> as I suggested above
04:03:31 <donri> mikeplus64: mappend = liftM2 mappend ?
04:03:34 <ivanm> romildo: comment out the type sig for pLet', and then see if a) it's accepted, b) what :type says the type sig is
04:03:48 <ivanm> donri: yeah
04:03:57 <ivanm> romildo: I think it's because you're missing a term
04:05:06 <donri> instance (Monoid a, Applicative f) => Monoid (f a) where mappend = liftA2 mappend; mempty = pure mempty
04:05:07 <donri> mwahah
04:05:33 <ivanm> donri: doesn't that require extensions?
04:05:40 <donri> probably a ton of 'em
04:05:43 <romildo> ivanm, commenting out the signature do fix it.
04:05:44 <donri> thus evil laughter
04:05:46 <ivanm> and couldn't it cause issues with custom Monoid instances for various APplicatives?
04:06:01 <ivanm> romildo: yeah, and the type is... ? ;-)
04:06:04 <ivanm> donri: ahhh, right
04:06:52 <romildo> ivanm, Expected type: ParsecT
04:06:52 <romildo>                      String u0 Data.Functor.Identity.Identity ([Char] -> b0)
04:06:55 <romildo> Actual type: ParsecT
04:06:56 <romildo>                      String u0 Data.Functor.Identity.Identity [Char]
04:07:08 <ivanm> yup
04:07:12 <ivanm> add the missing term!
04:07:21 <ttmrichter> Is there any way to install yesod from cabal or do I have to go from the source and manually build all the components?
04:07:53 <ivanm> ttmrichter: why not just "cabal install yesod" ?
04:08:04 <ivanm> I can't think of any reason why you can't
04:08:13 * hackagebot jdi 0.0.3 - Implementation of Java Debug Interface  http://hackage.haskell.org/package/jdi-0.0.3 (VictorDenisov)
04:08:15 <ttmrichter> ivanm: Because it fails rather spectacularly.
04:08:17 <donri> ivanm: ghci accepts it with FlexibleInstances and OverlappingInstances ^_^
04:08:19 <ivanm> though I think there might be some reocmmended ways of doing it (meta-packages, etc.) on the yesod site
04:08:20 <donri> evilness
04:08:28 <ivanm> ttmrichter: probably because it's picky about versions
04:08:35 <ivanm> donri: yeah, figured that'd be the case
04:08:39 <donri> and it works for getLine <> getLine
04:09:28 <donri> i wonder if it does something different from the Monoid (a,b) instance it overlaps with
04:09:54 <donri> seems likely...
04:10:11 <ttmrichter> ivanm: http://vpaste.net/XZJkc
04:10:30 <ivanm> @google how to install yesod
04:10:31 <lambdabot> http://www.yesodweb.com/page/quickstart
04:10:31 <lambdabot> Title: Yesod quick start guide
04:11:09 <ttmrichter> Please don't be insulting, ivanm.
04:11:16 <ivanm> I wasn't
04:11:19 <ttmrichter> Reporting that it "failed rather spectacularly" would kind of hint that I used cabal.
04:11:23 <donri> hm, nope, they do the same :o
04:11:29 <ttmrichter> Which means I've likely actually read that document.
04:12:02 <ivanm> ttmrichter: I was doing it so that I could see whether they suggested some meta-package or something
04:12:17 <ttmrichter> Ah.  Sorry, then.
04:12:22 <ivanm> it appears that some TH dep or something has changed
04:12:33 <ivanm> IIRC, Yesod is rather specific about version of the HP you use and everything
04:12:39 <ivanm> so: which version of GHC do you have?
04:13:06 <ttmrichter> λ ~ → ghc --version
04:13:07 <ttmrichter> The Glorious Glasgow Haskell Compilation System, version 7.4.1
04:13:17 <donri> have you tried it with cabal-dev
04:13:23 <ivanm> huh; I figured that version would work
04:13:39 <ttmrichter> donri: I've never *heard* of cabal-dev.  ;)
04:13:52 <ttmrichter> Doesn't appear to be in my path either.
04:14:10 <donri> cabal install cabal-dev; cabal-dev install yesod-platform
04:14:27 <donri> will sandbox the install and only consider the system-wide cabal packages
04:14:38 <donri> skipping ~/.cabal
04:14:42 * ttmrichter facepalms.
04:14:50 <ttmrichter> cabal won't let me install cabal-dev.
04:14:59 <ivanm> it appears that it should indeed let you use 7.4
04:15:02 <ivanm> ttmrichter: oh? why?
04:15:24 <ttmrichter> It lists a bunch of packages which are "likely to be broken" in trying to install it.
04:15:48 <donri> exactly the kind of problem cabal-dev tends to avoid ;)
04:15:58 <ttmrichter> If I just zap ~/.cabal what are the ramifications?
04:16:08 <donri> not much. most of it is in .ghc ;)
04:16:14 <ivanm> ttmrichter: backup ~/.cabal/config
04:16:24 <ivanm> and possibly ~/.cabal/world
04:16:38 <ivanm> if you zap ~/.cabal and ~/.ghc, then you lose all the packages you installed with cabal-install
04:16:40 <donri> you could just rename those two dirs to try a clean slate
04:17:04 <donri> but if you're going to zap them, you might as well --force-reinstalls and let some packages break
04:17:14 <ttmrichter> ivanm: Since it appears the packages I've installed with cabal-install are all in a useless state anyway I'm fine with that.  :D
04:17:30 <donri> or ghc-pkg unregister the packages that would break
04:17:31 <ivanm> heh
04:18:13 <ttmrichter> I've moved both directories to ~/junk for now and am trying from scratch.
04:18:33 <ttmrichter> I'll cabal update ; cabal install cabal-dev ; cabal-dev install yesod-platform
04:18:36 <ttmrichter> See if that works.
04:18:40 <donri> also you might want to make sure you have latest cabal-install and then use cabal install -j
04:18:49 <donri> to use all your cpu cores, since yesod has a ton of deps
04:18:52 <ivanm> if you've customised ~/.cabal/config, I'd move that over
04:19:09 <ttmrichter> I've never touched anything in ~/.cabal manually.
04:19:32 <ivanm> so, you haven't enabled profiling and you don't upload stuff to Hackage with cabal-install?
04:19:43 <donri> if you're starting over, you don't really need cabal-dev. although you might like to start using it now either way, to avoid these issues in the future. (although it can bring its own share of problems too)
04:20:13 <b__>  /join #finance
04:20:48 <ttmrichter> What issues does cabal-dev bring to the table?
04:21:02 <ivanm> ttmrichter: installing stuff multiple times
04:21:11 <ivanm> can be fiddlier to do some things (as cabal-dev isn't perfect)
04:21:22 <ivanm> IIRC "cabal-dev ghci" doesn't always work
04:21:27 * ivanm hasn't bothered with cabal-dev
04:21:38 <ttmrichter> ivanm: I'd rather install stuff multiple times than deal with the headaches I was having with yesod.
04:21:46 <donri> tricky or not possible to use runhaskell/runghc; certain uses of ghci made harder (others made easier); $PATH problems
04:21:48 <ivanm> *nod*
04:21:56 <ivanm> admittedly, I tend to deal primarily with my own packages :)
04:22:12 <ivanm> donri: which are made easier?
04:22:13 <ttmrichter> I can spare CPU cycles.  I can't spare any more hair.  That bald spot is increasing too rapidly for my tastes.
04:22:21 <donri> ivanm: well the fact there is cabal-dev ghci :)
04:22:31 <donri> cabal repl isn't done yet
04:22:46 <ivanm> sure, but how is that any easier compared to just using ghci?
04:23:00 <ivanm> when cabal-install gets native sandboxing support, I might start using it
04:23:07 <ivanm> (the sandboxing stuff that is)
04:23:13 * hackagebot binary-bits 0.2 - Bit parsing/writing on top of binary.  http://hackage.haskell.org/package/binary-bits-0.2 (LennartKolmodin)
04:23:19 <donri> it loads your dependencies, and only your dependencies, and imports your modules for you, and :r rebuilds with cabal, etc
04:23:46 <ivanm> sure, but only the dependencies I use are loaded when I do :load in ghci normally
04:25:10 <donri> also can be tricky to get ghci to load some source files, if they're relying on things set up in .cabal like extensions, CPP defs...
04:25:18 <ivanm> hmmmm
04:32:53 <ttmrichter> OK things are working nicer using cabal-dev.  Thanks guys.
04:33:19 <ttmrichter> Of course I'm contributing to global warming but...  :D
04:35:11 <b__> what is a nice database interface in haskell? SQL or not, doesn't matter much
04:36:35 <ivanm> b__: depends on what you think is "nice" :)
04:36:49 <b__> simple and I don't want to write SQL
04:37:02 <ivanm> IIUC, persistent lets you avoid writing anything that looks like SQL
04:37:12 <ivanm> esquileto is aimed at writing type-safe SQL
04:37:31 <ivanm> simple-{mysql,postgresql} use OverloadedStrings to parse SQL
04:37:45 <ivanm> there's also the older HDBC, Takusen, HaskellDB
04:37:46 <ivanm> etc.
04:37:51 <ivanm> take your pick :)
04:38:01 <ivanm> (persistent also supports various NoSQL DBs)
04:38:05 <b__> alright I'll go check docs, thanks for the overview =}
04:38:15 <ivanm> note: I've never used any of them
04:38:46 <b__> it's enough to get me going =]
04:39:08 <ivanm> heh, fair enough :)
04:39:24 <ivanm> persistent uses Template Haskell, which for many is a turn-off
04:39:26 <efie> ivanm: I replaced $! with $!!, and the program achieves a few more myIterate function calls more, I haven't figured out to which limit yet. To improve the performance I will use your hints above, thanks
04:39:45 <ivanm> efie: right, so it sounds like it is a resource issue
04:39:58 <ivanm> and I'm the one that suggested adding $!! to deepseq! :p
04:40:35 <efie> :)
04:44:19 <donri> b__: acid-state!
04:45:17 <b__> the description sounds really cool
04:45:20 <b__> will check it out
04:53:13 <ttmrichter> OK, I thanked too early.  When using cabal-dev, where do the binaries get put?  Yesod isn't in my path and I can't find the bin anywhere.
04:53:17 <merijn> b__: I second acid-state if you just want to safe haskell state safely to disk (rather than use SQL)
04:53:32 <ivanm> ttmrichter: I believe it's local to your project directory
04:53:47 <ttmrichter> Project.  Directory?
04:53:52 <byorgey> ttmrichter: it's in  cabal-dev/bin
04:54:06 <ivanm> the directory you have your project in and run cabal-dev from
04:54:12 <byorgey> all of the output of cabal-dev goes into the cabal-dev/ directory
04:54:23 <ttmrichter> OK, it appears I'm not understanding what cabal-dev does.
04:54:28 <ttmrichter> This is not a surprise.
04:54:37 <ivanm> byorgey: I notice that Eelis uploaded the last version of boxes; I take it you don't deal with it any more?
04:54:43 <ivanm> ttmrichter: heh
04:54:45 <byorgey> ttmrichter: what did you think cabal-dev does?
04:54:50 <ivanm> I think the Yesod book had a bit on cabal-dev
04:54:55 <byorgey> ivanm: I haven't been the maintainer for a long time
04:55:20 <ivanm> OK, just checking that it was the right thing to do to send Eelis a pull request :)
04:55:24 <ttmrichter> byorgey: I was assuming that cabal-dev just did some monkeying around in ~/.cabal to cure versionitis problems.
04:55:27 <ttmrichter> It appears I erred.
04:55:39 <ivanm> ttmrichter: nope; it's all relative to your code base
04:55:57 <byorgey> ttmrichter: no, cabal-dev doesn't do anything with ~/.cabal.  It does completely sandboxed, localized builds.
04:56:20 <byorgey> so when you build something with cabal-dev it doesn't actually have any effect on your system
04:56:38 <byorgey> (other than sticking some stuff in a local directory)
04:57:17 <b__> merijn, yes that sounds like it fits nicely to my use-case
04:59:27 <ttmrichter> byorgey: And causing rather massive contributions to global warming.  :D
04:59:52 <byorgey> that too
05:00:31 <byorgey> ivanm: is boxes broken?
05:00:41 <ivanm> nah, just wanted to get it using the latest version of split
05:00:59 <ivanm> you might not maintain it any more, but I'm finding it useful to draw ASCII-art trees (rather than trying to get images)
05:01:18 <ivanm> currently getting pagination happening so I can print off a large number of them, and then hopefully be able to spot a pattern
05:01:23 * ivanm is sick of drawing them by hand
05:03:14 * hackagebot hinotify 0.3.3 - Haskell binding to inotify  http://hackage.haskell.org/package/hinotify-0.3.3 (LennartKolmodin)
05:04:10 <byorgey> ivanm: I expect it ought to work with the latest version of spit as-is
05:04:16 <ivanm> nope
05:04:18 <byorgey> *split
05:04:24 <ivanm> chunks got deprecated
05:04:25 <byorgey> oh? what's the error?
05:04:28 <byorgey> ah
05:04:32 <ivanm> and isn't in 2.*
05:05:11 <byorgey> just change it to chunksOf
05:05:14 <ivanm> realised this when I wanted to use chunksOf in my code using boxes and it wouldn't work :p
05:05:17 <ivanm> yup, done that
05:05:22 <byorgey> ok =)
05:05:23 <ivanm> and fixed the dep in the .cabal file
05:05:35 <ivanm> just have to wait and see if Eelis still cares about maintaining boxes :p
05:05:39 <byorgey> oh, I see
05:09:24 <fliip> Does anyone know much about lambda calculus?
05:09:29 <merijn> Is there a cleaner way to interleave values than "x : intersperse x myList ++ [x]"?
05:09:39 <hiptobecubic> fliip, probably
05:09:46 <merijn> fliip: I think a considerable amount of people here know quite a bit about it :p
05:09:53 <romildo> @pl \m -> (s,eval a m):m
05:09:53 <lambdabot> (:) =<< (,) s . eval a
05:09:57 <ivanm> merijn: oh, to have it on either end as well?
05:10:00 <hiptobecubic> merijn, you flat zip a list?
05:10:01 <merijn> ivanm: Yeah
05:10:03 <yitz> byorgey: there ought to be a diagrams backend for boxes
05:10:03 <hiptobecubic> you mean*
05:10:05 <dcoutts_> merijn: try Data.List.intercalate
05:10:17 <merijn> > intercalate (-1) [0..10]
05:10:17 <fliip> ok, Im stuck on a problem: I have to come up with a term for t where t=ts
05:10:18 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
05:10:18 <lambdabot>    arising from a use...
05:10:19 <ivanm> > intercalate 0 [1..5]
05:10:20 <lambdabot>   No instances for (GHC.Num.Num [a], GHC.Enum.Enum [a])
05:10:20 <lambdabot>    arising from a use...
05:10:23 <ivanm> bah
05:10:26 <merijn> heh
05:10:29 <fliip> so I came up with Y(\xy.x)
05:10:32 <merijn> :t intercalate
05:10:34 <lambdabot> forall a. [a] -> [[a]] -> [a]
05:10:42 <merijn> ah
05:10:50 <fliip> but im stuck with a term t for t(\x.x)ss = ts
05:11:03 <ivanm> > concat $ zipWith (\ a b -> [a,b]) (repeat 0] [1,2,3,4,5]
05:11:03 <merijn> > intercalate [-1] (map (:[]) [0..10])
05:11:04 <lambdabot>   <no location info>: parse error on input `]'
05:11:05 <lambdabot>   [0,-1,1,-1,2,-1,3,-1,4,-1,5,-1,6,-1,7,-1,8,-1,9,-1,10]
05:11:15 <ivanm> > concat $ zipWith (\ a b -> [a,b]) (repeat 0) [1,2,3,4,5]
05:11:16 <lambdabot>   [0,1,0,2,0,3,0,4,0,5]
05:11:19 <ivanm> oh, that won't do the end
05:11:23 <hiptobecubic> > let f (x:xs) ys = x : f ys xs in f [1,2,3] [4,5,6]
05:11:23 <merijn> dcoutts_: No, intercalate has the same behaviour as intersperse
05:11:24 <lambdabot>   [1,4,2,5,3,6*Exception: <interactive>:3:4-28: Non-exhaustive patterns in fu...
05:11:31 <hiptobecubic> well you get the idea :)
05:11:31 <dcoutts_> merijn: 'k
05:11:32 <ivanm> merijn: ^^ you could adapt something like that and then shove an extra value on the front...
05:12:04 <ivanm> > (:) 0 . concat $ zipWith (\ a b -> [b,a]) (repeat 0) [1,2,3,4,5]
05:12:06 <lambdabot>   [0,1,0,2,0,3,0,4,0,5,0]
05:12:09 <ivanm> \o/
05:12:18 <hiptobecubic> gross
05:12:28 <ivanm> *shrug* works though :)
05:12:35 <ivanm> duh, you can just use concatMap
05:12:42 <hiptobecubic> > let f (x:xs) ys = x : f ys xs in f (repeat 0) [4,5,6]
05:12:43 <lambdabot>   [0,4,0,5,0,6,0*Exception: <interactive>:3:4-28: Non-exhaustive patterns in ...
05:12:49 <dcoutts_> > foldr (\x r -> '.' : x : r) ('.':[]) "hello"
05:12:51 <lambdabot>   ".h.e.l.l.o."
05:12:52 <ivanm> > 0 : concatMap (:[0]) [1..5]
05:12:53 <lambdabot>   [0,1,0,2,0,3,0,4,0,5,0]
05:12:56 <dcoutts_> merijn: like that ^^ ?
05:13:00 <ivanm> hiptobecubic: ^^ that more to your liking?
05:13:12 <hiptobecubic> can you specify more than one pattern in a let binding?
05:13:18 <merijn> dcoutts_: Yeah, although I think ivanm's is prettier
05:13:22 <merijn> hiptobecubic: Sure
05:13:23 <dcoutts_> bah
05:13:23 <ivanm> hiptobecubic: yup, use `;' to separate them
05:13:24 <dcoutts_> ;-)
05:13:26 <hiptobecubic> ivanm, nice
05:13:28 <ivanm> sorry dcoutts_
05:13:33 <dcoutts_> :-)
05:13:48 <hiptobecubic> > let f (x:xs) ys = x : f ys xs; f [] _ = [] in f (repeat 0) [4,5,6]
05:13:49 <lambdabot>   [0,4,0,5,0,6,0]
05:17:19 <yitz> > let intercalateEx x ys = take (2 * length ys + 1) $ interleave (repeat x) ys in intercalateEx 0 [10,20,30] -- merijn, not sure if i like this better
05:17:20 <lambdabot>   [0,10,0,20,0,30,0]
05:17:37 <fliip> Can anyone please help me? I need to create a lambda calculus term t where t(\x.x)ss = ts
05:17:47 <ivanm> @help lambda
05:17:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:17:57 <ivanm> OK, I thought lambdabot had a lambda calculus plugin
05:18:44 <ivanm> fliip: I assume this is homework?
05:18:51 <ivanm> (not that I can really help either way)
05:19:32 <fliip> I just need a point in the right direction.
05:19:39 <fliip> But yeh, it's for a weekly problem sheet.
05:19:48 <ivanm> my lambdacalc-fu is weak
05:19:58 <yitz> fliip: how about \xyz.z ?
05:20:09 <byorgey> yitz: no, that just reduces to s
05:20:13 <ivanm> yitz: he needs to get the t back
05:20:14 <byorgey> fliip said ts
05:20:15 <yitz> oh, ts.
05:20:31 <ivanm> so you want something recursive
05:20:40 <byorgey> fliip: because of the requirement to get the t back you will need something similar to the Y combinator
05:20:42 <fliip> Yeh, I need to use a fixed point combinator.
05:20:49 <byorgey> if you don't know what that is, looking it up might be a good place to start.
05:21:02 <fliip> I worked out that t = ts = Y(\xy.x)
05:21:08 <fliip> but this one is puzzling me.
05:22:01 <fliip> sorry, t = Y(\xy.x)
05:22:35 <fliip> Where Y is a fixed point
05:27:09 <ivanm> so, you could always just expand and simplify Y(\xy.x) ...
05:27:24 <fliip> What do you mean?
05:28:06 <ivanm> if you know that t = Y(\xy.x), get the definition of the Y combinator and simplify
05:28:20 <fliip> Sorry, t = Y(xy.x) for t=ts
05:28:43 <fliip> I need to find t for t(\x.x)ss = ts
05:28:57 <ivanm> "t = ts"? :/
05:29:19 <Philonous_> Y (\t a b c. c) ?
05:29:31 <Philonous_> Y (\t a b c. t c), rather
05:29:43 <fliip> I put that down, but if you apply that to s...
05:30:16 <fliip> Y(\tabc.tc)s
05:30:49 <fliip> It wont equal the same answer for T(\tabc.tc)(\x.x)ss
05:30:57 <fliip> Y*
05:33:09 <Philonous_> So, let T = Y (\t a b c. t c), then T id s s = (\t a b c. t c) T id s s = T s
05:33:48 <Philonous_> Becaust T = Y (\t a b c. t c) = (\t a b c. t c) (Y (\t a b c. t c) ) = (\t a b c. t c) T
05:33:48 <hpaste> solirc pasted “imprecise exceptions” at http://hpaste.org/76891
05:34:11 <ttmrichter> OK, so even using cabal-dev and following the tutorial at http://yannesposito.com/Scratch/en/blog/Yesod-tutorial-for-newbies/ yesod dies on impact.
05:34:25 <ttmrichter> How are people actually using this?  I appear to be missing something important.
05:34:27 <fliip> Ah ok. Thanks Philonous.
05:34:30 <fliip> I get it now.
05:34:43 <ivanm> ttmrichter: you've read through the Yesod Book I presume?
05:34:59 <solirc> Would the imprecise exception semantic still allow to result in an ErrorCall here?
05:34:59 <ivanm> have you tried using one of the official Yesod project sites/demos?
05:35:12 <ttmrichter> ivanm: I'm reading the tutorial linked to by the official site.
05:35:16 <ttmrichter> Was that an error?
05:35:23 <ivanm> might be out of date
05:35:37 <ivanm> I believe there's a more targeted IRC channel
05:35:43 <ivanm> @google haskell yesod IRC freenode
05:35:44 <lambdabot> http://www.yesodweb.com/page/community
05:35:44 <lambdabot> Title: Community
05:35:52 <ivanm> might get more help there
05:36:10 <ttmrichter> This still actually seems to be a Haskell/Hackage/Cabal infrastructure problem.
05:36:14 <ttmrichter> http://vpaste.net/nu6Kn
05:36:47 <ivanm> oh, a cabal-dev error
05:36:54 <ttmrichter> To be specific, versionitis.
05:36:56 <ivanm> maybe you haven't set cabal-dev up properly?
05:37:09 <ivanm> which version of GHC are you using?
05:37:19 <ttmrichter> Same as last time: 7.4.1.  ;)
05:37:20 <ivanm> wait, you said that already, 7.4.1 right?
05:37:23 <ivanm> yeah, sorry, forgot
05:37:41 <ivanm> OK< so it's unlikely to be that cabal-dev doesn't grok how to deal with 7.4.1
05:37:58 <ivanm> where is your ghc found? /usr/bin/ ?
05:38:29 <ttmrichter> /usr/local/bin
05:38:38 <ivanm> I wonder if that's it
05:38:59 <ivanm> is ~/.cabal/bin/fake-ghc-cabal-dev a shell script ?
05:39:11 <ivanm> I'm guessing it has the location of ghc hard-baked, or there's a PATH problem
05:39:23 <ttmrichter> No.  It's a binary.  A big one.
05:39:28 <ivanm> hmmmmmm
05:39:48 <ivanm> try creating a symlink from /usr/bin/ghc to /usr/local/bin/ghc (if you can) and see if it magically fixes it?
05:41:57 <ttmrichter> I'll have to do that tomorrow.  I've just hit the end of my allotted time today for evaluating yesod.  Thanks for the help so far, ivanm, byorgey.
05:42:05 <ivanm> np
05:42:09 <ivanm> and I should go hit the sack
05:42:18 <ivanm> I spent way too much time on IRC instead of hacking :s
05:42:41 <ivanm> (which is why I stopped going on IRC a while back until Axman6 begged me to come back because apparently he missed me :p)
05:44:10 <werd> hi
05:53:15 * hackagebot cake 0.4.2.0 - A build-system library and driver  http://hackage.haskell.org/package/cake-0.4.2.0 (JeanPhilippeBernardy)
05:58:08 <akosch> is there something like LYAH, but for C?
05:58:23 <plat0> It's called DLYAC for great good.
05:58:33 <merijn> akosch: Define "like LYAH"
05:58:35 <plat0> ;)
05:58:45 <merijn> akosch: K&R is good, though
05:58:49 <merijn> Very short and readable too
05:59:05 <plat0> Actually I'm glad I learned C and think it does make me a better programmer.  I agree with merijn.  K&R is great.
05:59:11 <merijn> Might need to be suplmented with some info on a more recent std like C99/C11
05:59:13 <akosch> merijn: yeah, I know K&R is great :)
05:59:24 <merijn> Not sure if there's books for those
05:59:44 <akosch> I have a relative who's trying to learn C and I wanted to come up with something that's not very dry material
06:00:02 <mroman> Good luck with that.
06:00:10 <akosch> I figured ruby has why's poignant guide
06:00:25 <akosch> Haskell has LYAH, etc.
06:00:57 <mroman> Let's write learn you some c then ;)
06:01:08 <merijn> Learn C The Hard Way?
06:01:28 <nicoo> merijn: Enter and despair ?
06:01:29 <merijn> http://c.learncodethehardway.org/book/
06:01:42 <nicoo> Ah, it really exists ?
06:02:05 <akosch> merijn: oh god
06:02:46 <merijn> nicoo: Yes
06:05:21 <nicoo> « C is harder on you because it requires you to plan out what you'll create first. »
06:05:26 <nicoo> Very funny.
06:05:28 <linduxed> i'm actually torn on the choice between K&R vs. Learn C the hard way
06:07:08 <linduxed> the first one goes deeper on the technical stuff, like the fact that if you point to the start of an array, incrementing the pointer by one actually means moving to the next int (or whatever it was an array of), and why that is
06:07:10 <bootcode> is it possible to tell uhc to use a package from cabal/ghc? Data.DList for example, first
06:07:11 <linduxed> so that's helpful
06:07:41 <linduxed> but on the other hand, i found LCTHW was far more useful for actually starting to code
06:09:09 <arcatan> LCTHW's opinion of K&R: http://c.learncodethehardway.org/book/learn-c-the-hard-waych55.html
06:11:17 <mcstar> so, i come here, to make sure i dont have to read about C and stuff, and what do i get?
06:13:21 <linduxed> mcstar: hahaha
06:25:35 <Polarina> nicoo, I've find it to be the opposite. I'm absolutely unable to code in Haskell without at least a clue on what I want to do.
06:36:25 <merijn> Polarina: I am, it just looks like crap until the first refactor :p
06:36:38 <merijn> (or even second refactor sometimes :p)
06:36:39 <GnomeStoleMyBike> \o hi all
06:37:17 <Polarina> merijn, if one doesn't refactor his or her Haskell code at least once, GHC will hate you. :P
06:37:58 <hpaste> merijn pasted “ugly code without planning!” at http://hpaste.org/76893
06:38:28 <merijn> That's the first refactoring, before it was a hundred times less readable, and even now it's crap :p
06:39:25 <efie> uh oh, the nub function is evil ... :)
06:39:38 <merijn> Point-free like a boss, though
07:00:04 <portnov> hi all
07:03:16 * hackagebot cabal-sort 0.0.5.1 - Topologically sort cabal packages  http://hackage.haskell.org/package/cabal-sort-0.0.5.1 (HenningThielemann)
07:04:57 <wigtion> http://www.youtube.com/watch?v=YAfRZBh4Lh8&feature=plcp cool pumpkin carving video for all you board people :P
07:23:08 <eh> hey
07:23:53 <eh> does ta
07:24:36 <eh> does someone now an algorythm, that shows all permutations of a list? :)
07:24:50 <mauke> > permutations "abc"
07:24:51 <lambdabot>   ["abc","bac","cba","bca","cab","acb"]
07:25:15 <sipa> > permutations "aaa"
07:25:16 <lambdabot>   ["aaa","aaa","aaa","aaa","aaa","aaa"]
07:26:09 <Botje> eh: as long as the list isn't empty, pick an element to put in front.
07:26:32 <Botje> the grab all the permutations for the rest of the list, and put the chosen element in front of each
07:26:44 <portnov> @src permutations
07:26:44 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
07:28:04 <dada-cetacean> I just discovered what dollar signs are used for in source code...
07:28:09 <dada-cetacean> so many wasted parentheses
07:29:19 <hpc> dada-cetacean: now come up with a justification for using a section of ($)
07:29:23 <hpc> like ($ 5)
07:29:24 <ParahSailin> @ty ($)
07:29:25 <lambdabot> forall a b. (a -> b) -> a -> b
07:29:28 <hpc> :D
07:29:32 <eh> do i have to load something for this, because it doesent work on my win hugs :(
07:29:39 <byorgey> eh: import Data.List
07:29:40 <hpc> you should be using ghc
07:29:44 <nand`> > map ($3) [succ, pred, sqrt]
07:29:45 <lambdabot>   [4.0,2.0,1.7320508075688772]
07:29:53 <hpc> hugs is so far beyond obsolete at this point
07:29:59 <byorgey> that too.  but you still have to import Data.List if you're using ghc.
07:30:09 <hpc> also that ;)
07:30:10 <Philonous_> > [succ, pred, sqrt] <*> [3]
07:30:11 <lambdabot>   [4.0,2.0,1.7320508075688772]
07:30:33 <portnov> > [succ, pred, sqrt] <*> [3,16]
07:30:35 <lambdabot>   [4.0,17.0,2.0,15.0,1.7320508075688772,4.0]
07:30:37 <hpc> > flip [succ, pred, sqrt] 3
07:30:38 <lambdabot>   Couldn't match expected type `a -> b -> c'
07:30:38 <lambdabot>         against inferred type `[...
07:30:41 <hpc> :t flip
07:30:43 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:30:49 <hpc> nooooooooooo!!!!
07:30:53 <hpc> the magic flip is gone
07:30:58 <xplat> has anyone here worked on haskell projects that include substantial amounts of both C and haskell?  (not just stubs for FFI)
07:31:29 <xplat> :t (.)
07:31:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:31:58 <hpc> @let flip' f x = fmap ($ x) f
07:32:00 <lambdabot>  Defined.
07:32:03 <xplat> at least we still have magic dot
07:32:07 <hpc> > flip' [succ, pred, sqrt] 3
07:32:09 <lambdabot>   [4.0,2.0,1.7320508075688772]
07:32:22 <hpc> > flip' (++) "second" "first"
07:32:24 <lambdabot>   "firstsecond"
07:32:46 <eh> import Data.List doesnt work either :()
07:33:35 <hpc> @hoogle permutations
07:33:36 <lambdabot> Data.List permutations :: [a] -> [[a]]
07:33:36 <lambdabot> package action-permutations
07:33:38 <mauke> the lesson here is to not say "doesn't work" ever
07:33:52 <mauke> it's meaningless
07:34:49 <byorgey> eh: what exactly did you do, what did you expect to happen, and what happened instead?
07:34:58 <xplat> > map (flip id 3) [succ, pred]
07:35:00 <lambdabot>   [4,2]
07:35:01 <byorgey> mauke speaks wisdom
07:35:40 <clahey> @djinn [([a], b)] -> [(a, [b])]
07:35:40 <lambdabot> Error: Undefined type []
07:35:51 <portnov> ah flip flip...
07:35:52 <mauke> > sequence [succ, pred] 3
07:35:53 <lambdabot>   [4,2]
07:35:58 <hpc> :t flip flip
07:35:59 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
07:36:17 <hpc> @@ djinn type flip flip
07:36:17 <lambdabot>  djinn type flip flip
07:36:24 <hpc> @@ @djinn @type flip flip
07:36:25 <lambdabot>  f a b c = b c a
07:36:32 <hpc> oh duh
07:36:48 <xplat> > flip sequence 3 [pred, id, succ]
07:36:49 <lambdabot>   [2,3,4]
07:37:34 <xplat> :t flip sequence
07:37:35 <lambdabot> forall b a. b -> [b -> a] -> [a]
07:38:29 <Philonous_> Where is the Monad instance for ((->) r) defined?
07:38:46 <byorgey> Control.Monad.Instances
07:38:52 <Philonous_> THanks
07:39:54 <clahey> @djinn [([a], b)] -> [[(a, b)]]
07:39:55 <lambdabot> Error: Undefined type []
07:40:25 <xplat> 9 * succ $ 3
07:40:29 <xplat> > 9 * succ $ 3
07:40:30 <lambdabot>   36
07:41:28 <clahey> Does anyone have any suggestions for easy ways to implement  [([a], b)] -> [[(a, b)]] ?   Summing up, the [a] are always the same length and I want that [] to become the outer [].
07:41:57 <clahey> In other words, I have an assoc list where the key is always a 3 tuple and I want a 3 tuple of assoc lists.
07:42:15 <mauke> :t map (\(as, b) -> map (\a -> (a, b)) as)
07:42:16 <lambdabot> forall t a. [([a], t)] -> [[(a, t)]]
07:42:46 <xplat> well, if you implement ([a],b) -> [(a,b)], then just transpose . (map that)
07:43:08 <xplat> and 'that' is just the strength for the list monad
07:43:32 <clahey> the strength?
07:44:16 <byorgey> @type  let strength (fa,b) = fmap (\a -> (a,b)) fa  in  strength
07:44:18 <lambdabot> forall (f :: * -> *) a t. (Functor f) => (f a, t) -> f (a, t)
07:44:41 <byorgey> I think Haskell just called me fat
07:45:33 <byorgey> clahey: called "strength" because it corresponds to the notion of a "strong functor" in category theory
07:45:34 <clahey> So what mauke gave me, but then transpose.  Cool.
07:45:37 <Adeon\SIGSEGV> apply soap to haskell's mouth
07:45:37 <byorgey> in Haskell all functors are strong.
07:46:09 <clahey> byorgey, But there's no common library functions so I implement it myself.  Will do.
07:46:22 <portnov> soap... haskell... wait, what!?
07:46:24 <portnov> :)
07:46:47 <clahey> Really what I want is [((a, a, a), b)] -> ([(a, b)], [(a, b)], [(a, b)])
07:46:48 <byorgey> clahey: right.  strength is probably in some package on Hackage somewhere but it's probably best to just implement it yourself.
07:46:50 <zomg> The functor is strong in this one
07:47:03 <clahey> @djinn [((a, a, a), b)] -> ([(a, b)], [(a, b)], [(a, b)])
07:47:03 <lambdabot> Error: Undefined type []
07:47:26 <xplat> @ty let strength (fa,b) = fmap (\a -> (a,b)) fa in transpose . map strength
07:47:27 <lambdabot> forall a t. [([a], t)] -> [[(a, t)]]
07:47:41 * ClaudiusMaximus ponders making some script to generate pseudo-random abstract nonsense phrases from a category theory glossary
07:48:59 <hpaste> efie pasted “how to write data efficiently to a file ?” at http://hpaste.org/76896
07:50:42 <clahey> Actually, what I really want is Array i e -> (e -> ((a, a, a), b)) -> ([(a, b)], [(a, b)], [(a, b)]), but I know how to do the rest of it.
07:51:06 <clahey> Oh, no.
07:51:14 <clahey> Actually, what I really want is Array i e -> (e -> Maybe ((a, a, a), b)) -> ([(a, b)], [(a, b)], [(a, b)]), but I know how to do the rest of it.
07:51:17 <merijn> efie: Have you looked into conduits for doing the IO?
07:51:34 <xplat> > let strength (fa,b) = fmap (\a -> (a,b)) fa in transpose . map strength $ [([1,2,3],"hello"),([4,5,6],"sailor")]
07:51:36 <lambdabot>   [[(1,"hello"),(4,"sailor")],[(2,"hello"),(5,"sailor")],[(3,"hello"),(6,"sai...
07:52:13 <clahey> xplat, Yep, exactly what I want.  Thank you very much.
07:52:35 <ClaudiusMaximus> efie: also, floatshow package has faster Float -> String functions than the default Show instance
07:52:38 <efie> merijn: I haven't heard of conduits yet
07:53:11 <xplat> clahey: in general for this kind of thing you may want the lens package though
07:53:21 <ClaudiusMaximus> efie: http://hackage.haskell.org/package/floatshow
07:53:33 <clahey> xplat, I'll get this working and then learn lenses and perhaps rewrite this bit.
07:54:38 <Jaxan> So data Mu f = In (f (Mu f)) givers the greatest fixpoint of f, is there also a way to get the smallest, or is there no difference?
07:54:52 <byorgey> Jaxan: in Haskell there is no difference, actually.
07:55:00 <byorgey> because of laziness.
07:55:12 <Jaxan> hmm, it kinda makes sense...
07:55:58 <byorgey> Jaxan: but traditionally 'mu' is used to indicate the least fixed point, and 'nu' the greatest
07:56:09 <xplat> in a total language Mu as written would be the least fixpoint, which is why it's called Mu instead of Nu
07:56:32 <Jaxan> xplat: what is a total language?
07:56:53 <merijn> efie: Conduits are supposed to avoid a lot of the issues lazy IO has (i.e. resource leaks, exceptions, etc)
07:57:03 <xplat> Jaxan: a language that disallows general recursion so that all functions terminate
07:57:19 <randomclown> nothing can avoid the general haskell issue: slow.
07:57:42 <xplat> in a strict language Mu is the least fixpoint as well
07:57:44 <Ferdirand> would someone kindly explain to noobs (or provide pointers to) what is this type-level fixpoint you are talking about and for what can it be useful ?
07:57:59 <Jaxan> xplat: ok thanks :)
07:58:21 <hpc> hmm, the way i am abstracting out IO is making it hard to write useful combinators...
07:58:41 <xplat> repeating an earlier question: has anyone here worked on haskell projects that include substantial amounts of both C and haskell?  (not just stubs for FFI)
07:59:04 <hpc> xplat: not i
07:59:23 <Jaxan> Ferdirand: as far as I encoutered it gives a nice/abstract way of defining lists, trees and such, of course it can be done without though....
08:00:07 <Jaxan> but I'm very new to haskell, so I'm not the person to ask :P
08:00:19 <xplat> i'm looking for tips because projects like that seem hard to build
08:01:21 <merijn> xplat: Not yet, but I will be including more C code in my project, soonish
08:01:42 <merijn> xplat: What would make it hard to build?
08:02:19 <morel> is there a (pre-defined) function (in the base package) which applies another function to the first element of a list holding a predicate? (withThisType :: (a -> Bool) -> (a -> a) -> [a] -> [a])
08:02:37 <efie> merijn: thanks, but it looks difficult, I'm not sure if I'm up to this task and try floatshow first (thanks ClaudiusMaximus)
08:02:52 <gwern> @wn copulate
08:02:52 <lambdabot> *** "copulate" wn "WordNet (r) 3.0 (2006)"
08:02:52 <lambdabot> copulate
08:02:52 <lambdabot>     v 1: engage in sexual intercourse; "Birds mate in the Spring"
08:02:52 <lambdabot>          [syn: {copulate}, {mate}, {pair}, {couple}]
08:03:00 <xplat> merijn: it seems hard to get cabal and conventional C tools (like autotools and make) to either talk to each other or do each other's jobs
08:03:11 <merijn> Ferdirand: The sort of typelevel chicanery usually means people are either 1) trying to generalise something so they can reuse the code more frequently or 2) trying to encode static guarantees in the type system
08:03:46 <merijn> xplat: Oh, I don't use autotools anyway, I just have a cabal hook calling make at the right time
08:04:45 <Ferdirand> mhhh
08:04:47 <xplat> merijn: maybe combining that with the well-known hook to get cabal to run configure would work well ...
08:04:55 <Jaxan> Is there a way to annotate a type for strict evaluation (like in the clean language)?
08:04:59 <randomclown> merijn: look it up on hoogle, but it seems easy enough to write
08:05:27 <xplat> merijn: do you have a sample .cabal file with that hook?
08:05:32 <morel> (or rather “:: (a -> Bool) -> (a -> a) -> [a] -> Maybe [a]” because i'd like to know whether it was updated (, that is, i'd like to know whether there was an element holding the predicate…))
08:05:47 <beaky> hello
08:05:52 <morel> hi beaky :)
08:05:53 <merijn> Jaxan: `seq` annotates strictness i.e. forcing something to be evaluated before the rest of an expression
08:06:00 <merijn> > undefined `seq` 1
08:06:01 <lambdabot>   *Exception: Prelude.undefined
08:06:35 <merijn> Jaxan: Usually you'd use it as "a `seq` f a" (i.e. evaluate a before running "f a")
08:06:46 <Jaxan> hm ok
08:06:51 <randomclown> Jaxan: you probably want a strict fields, and for the love of god use bang patterns
08:07:15 <jix> morel: I don't think ther is such a function, but there is span which allows you to split the list at that point
08:07:19 <merijn> randomclown: What was the hoogle remark directed at? I don't remember asking a question?
08:07:20 <xplat> @ty break
08:07:21 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:07:33 <randomclown> meant to type morel:
08:07:36 <morel> oh, yeah. that's a good one
08:07:49 <randomclown> merijn:
08:07:57 <morel> randomclown: i don't know bang patterns
08:08:57 <hpaste> merijn pasted “setup.hs” at http://hpaste.org/76897
08:08:58 <morel> thanks jix and xplat
08:09:13 <merijn> xplat: See that hpaste for a simple Setup.hs hooking "prebuild"
08:09:52 <osa1> is there a way to tell ghci to "define every undefined name as `undefined` and load that module" ?
08:10:23 <merijn> osa1: I hope that'll be part of GHC getting holes
08:10:40 <xplat> merijn: sweet, thanks
08:10:54 <osa1> merijn: in the next release ?
08:11:17 <merijn> osa1: I heard holes won't be in until 7.8 :\
08:11:27 <osa1> ;-(
08:11:44 <xplat> osa1: it'd be easy to make a template haskell thingy to let you just list the names
08:12:40 <xplat> (instead of giving each their own line)
08:13:34 <xplat> still not quite as convenient, but at least you get to have some typo checking
08:14:23 <clahey> I just got to use Data.Map.fromListWith (.)   This language is so cool.
08:14:35 <clahey> :t fromListWith (.)
08:14:36 <lambdabot> Not in scope: `fromListWith'
08:14:41 <clahey> :t Data.Map.fromListWith (.)
08:14:43 <lambdabot> forall a k. (Ord k) => [(k, a -> a)] -> M.Map k (a -> a)
08:14:52 <clahey> Yeay!
08:17:09 <beaky> how do you define a circular singly-linked-list in Haskell?
08:17:10 <Lajjla> :t Data.Map.fromListwith
08:17:11 <lambdabot> Not in scope: `Data.Map.fromListwith'
08:17:32 <clahey> Lajjla, Capital w
08:17:38 <Lajjla> :t Data.Map.fromListWith
08:17:39 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> [(k, a)] -> M.Map k a
08:17:48 <xplat> > let meditate = "om " ++ meditate in meditate
08:17:50 <lambdabot>   "om om om om om om om om om om om om om om om om om om om om om om om om om...
08:18:05 <Lajjla> clahey, you gent.
08:18:06 <xplat> beaky: ^
08:18:09 <beaky> ah
08:18:29 <beaky> let foo = cycle [1..3]
08:18:33 <xplat> > let meditate = cycle "om " -- shorter
08:18:34 <lambdabot>   not an expression: `let meditate = cycle "om " -- shorter'
08:18:35 <beaky> > let foo = cycle [1..3]
08:18:36 <lambdabot>   not an expression: `let foo = cycle [1..3]'
08:18:40 <beaky> :(
08:18:45 <xplat> > cycle "om " -- shorter
08:18:46 <lambdabot>   "om om om om om om om om om om om om om om om om om om om om om om om om om...
08:19:15 <xplat> > unwords (repeat "om")
08:19:16 <lambdabot>   "om om om om om om om om om om om om om om om om om om om om om om om om om...
08:19:25 <nicoo> > cycle "Nom"
08:19:26 <lambdabot>   "NomNomNomNomNomNomNomNomNomNomNomNomNomNomNomNomNomNomNomNomNomNomNomNomNo...
08:19:36 <beaky> so just take any singly-linked list, slap `cycle` on it, and then I have a circuarly-linked list?
08:19:44 <beaky> @src cycle
08:19:44 <lambdabot> cycle [] = undefined
08:19:44 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
08:19:53 <hpc> yep
08:20:12 <hpc> technically you just have an infinite list that repeats the same string over and over
08:20:35 <beaky> in C I had to go through a lot of pain to define proper circularly linked lists :D
08:20:37 <xplat> hpc: depends what you mean by 'technicallu'
08:20:39 <hpc> ghc happens to make it circular, but that's easy to undo
08:20:53 <hpc> > map id $ cycle "uncircular "
08:20:54 <lambdabot>   "uncircular uncircular uncircular uncircular uncircular uncircular uncircul...
08:21:01 <hpc> that's enough to do it
08:21:25 <jmcarthur> i just uploaded a package yesterday that shows how to define map in a way that doesn't unroll the cycle using memoization
08:21:32 <nand`> I don't understand what you mean by ‘circular’ and ‘uncircular’. To me they look the same
08:21:46 <hpc> nand`: implementation details ;)
08:21:51 <jmcarthur> http://hackage.haskell.org/package/stable-memo
08:22:30 <beaky> > fmap show [1..10]
08:22:31 <lambdabot>   ["1","2","3","4","5","6","7","8","9","10"]
08:22:33 <xplat> nand`: if you keep a reference to cucle "Nom" while you print it, it will print forever but you'll never run out of RAM.  uncircular, not so much
08:22:33 <byorgey> jmcarthur: interesting
08:22:39 <beaky> > [1..10] >>= show
08:22:40 <lambdabot>   "12345678910"
08:22:40 <clahey> nand`, In a circular list when you unthunk the last step, it points to the first step.
08:23:05 <clahey> nand`, In an uncircular list, when you unthunk the last step, it points to a new copy of the value from the first step and a new thunk.
08:23:11 <byorgey> the other way you can map over "cyclic" data structures without destroying sharing is by encoding the cyclic data structure using abstract graphs/PHOAS
08:23:13 <nand`> clahey: that makes sense
08:23:18 <hpc> jmcarthur: that's terrifying and awesome
08:23:22 <byorgey> which is super-neat
08:23:36 <byorgey> but of course doesn't work directly with normal lists etc.
08:23:43 <beaky> so map id $ cycle [1..3] is circular?
08:23:43 <jmcarthur> you can also encoded the sharing via an arrow-like interface
08:23:47 <jmcarthur> *encode
08:23:47 <beaky> whereas cycle [1..3] isn't?
08:23:55 <jmcarthur> beaky: other way
08:23:57 <byorgey> beaky: other way around
08:24:00 <beaky> ah
08:24:01 <clahey> beaky, Vice versa according to what was just said.
08:24:23 <byorgey> cycle  actually constructs a cyclic representation in memory
08:24:24 <beaky> >  "foo" >>= show
08:24:25 <lambdabot>   "'f''o''o'"
08:24:30 <byorgey> but there is no way to actually observe the cycle
08:24:58 <jmcarthur> not without IO or unsafe things anyway
08:25:03 <byorgey> right
08:25:03 <beaky> (cycle [1..3]) >>= show
08:25:07 <beaky> > (cycle [1..3]) >>= show
08:25:08 <lambdabot>   "12312312312312312312312312312312312312312312312312312312312312312312312312...
08:25:12 <jmcarthur> which is the black magic that stable-memo uses
08:25:22 <jmcarthur> to support polymorphic recursion i even used unsafeCoerce...
08:25:24 <nand`> I guess this comes down to the difference between cycle x = let xs = x ++ xs in xs  and  cycle' xs = xs ++ cycle' xs  -- ?
08:25:24 <byorgey> beaky: if you're interested in this sort of thing you can use ghc-vis to actually visualize the in-memory structures
08:25:26 <xplat> jmcarthur: or a machine with finite memory where you can observe that your program doesn't crash :)
08:25:29 <byorgey> it's pretty cool
08:25:40 <byorgey> nand`: exactly.
08:26:02 <hpc> xplat: that would be the most horrible library ever
08:26:11 <jmcarthur> how does ghc-vis compare to vacuum (which has been picked up by another maintainer)?
08:26:13 <hpc> detect sharing by spawning a VM programatically, with a very low resource limit
08:26:28 <byorgey> ghc-vis is much cooler IMO
08:26:39 <byorgey> it's actually interactive, you can click on the graph to evaluate thunks etc.
08:26:40 <jmcarthur> woah, *live* visualization?
08:26:45 <jmcarthur> that's awesome!
08:27:04 <xplat> i'm surprised there's no characterization commonly known of (some) functions that are safe to use on cyclic structures, like there are for functions that consume finite trees or produce infinite trees
08:27:12 * jmcarthur watches the video in the ghc-vis documentation
08:28:19 <jmcarthur> xplat: i'm not, because most people don't pay attention to such things when writing recursive functions anyway
08:28:25 <clahey> @hoogle Maybe (a -> a) -> (a -> a) -> (a -> a)
08:28:25 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
08:28:25 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
08:28:25 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
08:28:27 <monochrom> on topic: http://ro-che.info/ccc/09.html :)
08:28:31 <jmcarthur> usually if you care at all you're up to something weird, like me
08:29:28 <xplat> rooted potentially-cyclic graphs are also called 'rational trees'
08:29:38 <Philonous_> I wonder what's a nicer interface for a network client library, having TVars with callbacks that are called on each incoming stream element or dumping the elements in a TChan.
08:29:45 <beaky> what parts of other languages have been influenced by Haskell?
08:30:03 <xplat> but there doesn't seem to be a lot of work on them, even though they arise naturally in a number of situations
08:30:22 <jmcarthur> byorgey: i'm totally sold on ghc-vis now after watching that video
08:30:43 <byorgey> I told you it was neat =)
08:31:06 <jmcarthur> it's exactly the tool i've wanted for so long
08:31:14 <hiptobecubic> jmcarthur, which video?
08:31:23 <jmcarthur> hiptobecubic: http://felsin9.de/nnis/ghc-vis/#combined-debugger
08:31:44 <xplat> beaky: if you want to trace the influence to haskell specifically, there's LINQ and also there's some complete haskell-clone languages on VMs
08:31:49 <efie> ClaudiusMaximus: could you take a look at my second try with "fshow" ?: http://hpaste.org/76896 I annotated my attempt, the two last paragraphs are what I tried
08:32:23 <xplat> beaky: also the constructor polymorphism in scala is probably traceable directly to haskell
08:32:42 <xplat> more often the influence goes through something like 'functional languages in general' though
08:32:43 <jmcarthur> darn, compilation errors :(
08:33:19 <xplat> oh, disciple is basically a spinoff of haskell with effects, and Eff has a pretty strong haskell influence too
08:33:37 <xplat> but those are pretty much into the realm of esolangs currently
08:33:43 <jmcarthur> oh it's gtk
08:34:51 <clahey> esolangs?
08:35:05 <strebe> esoteric languages
08:35:14 <xplat> i often feel like the best things i can come up with to say about gtk are 'it's not wxwidgets' and 'it's easier to write non-C++ bindings for than Qt'
08:35:34 <hiptobecubic> oh
08:35:40 <hiptobecubic> wow
08:35:54 <strebe> xplat,: do the things you say about wxwidgets include 'it's not gtk'?
08:36:26 <clahey> I like Gtk+ quite a bit, but I've been using it since '98 or '99.
08:36:31 <jmcarthur> xplat: there are very few good things i have to say about GUI tookits in general
08:36:36 <xplat> strebe: the things i say about wxwidgets include '$&@*&%(@$#' and 'of all the things to clone, why microsoft foundation classes?'
08:36:42 <beaky> why does fmap have the same effect as (.)?
08:36:57 <yitz> xplat: i don't think disciple is esoteric. it has solid foundations, created and maintained by someone who really knows what he's doing, and has a number of sollid contributors. last i heard, it was getting to the point that you could use it to write real programs.
08:37:13 <byorgey> beaky: try implementing the Functor instance for  ((->) e)
08:37:13 <jmcarthur> beaky: if you mean lambdabot, (.) has a weird definition. if you mean generally, that's because fmap for functions happens to be (.)
08:37:14 <nand`> because (.) is fmap specialized to ((->) r)
08:37:20 <ClaudiusMaximus> efie: hm, don't know why it is slower, maybe map f . map g isn't getting fused into map (f . g) ?
08:37:23 <beaky> ah
08:37:26 <yitz> that said, i like haskell's non-strict approach, so i don't use disciple.
08:37:27 <beaky> what does -> mean
08:37:39 <monochrom> -> means function type
08:37:41 <xplat> yitz: if even experts can't use a programming language to write real programs, it's esoteric by definition
08:37:44 <nand`> a -> b is a function from a to b
08:37:52 <clahey> beaky, So, the type ((->) r) means a function returning r.
08:37:59 <nand`> no
08:37:59 <beaky> > fmap (+1) 3
08:38:00 <lambdabot>   No instance for (GHC.Num.Num (f a))
08:38:00 <lambdabot>    arising from a use of `e_113' at <in...
08:38:00 <nand`> accepting r
08:38:03 <byorgey> beaky: -> can be written prefix like    (->) Int Char =  Int -> Char
08:38:03 <xplat> yitz: maybe it'll graduate from esolang, but that's where it's been
08:38:07 <yitz>                                                                                                                                                                                                                                                                                                                                                                                      ccp
08:38:10 <nand`> ((->) r) is (r ->)
08:38:10 <Jaxan> clahey: that's not true
08:38:12 <Jaxan> yeah
08:38:14 <nand`> but that latter section is illegal
08:38:14 <clahey> I was wrong.
08:38:20 <beaky> > fmap 3 (+3)
08:38:21 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
08:38:22 <lambdabot>    arising from a use of `...
08:38:31 <clahey> Sorry.
08:38:37 <beaky> I think I understand what fmap does
08:38:40 <beaky> but what is a functor?
08:38:51 <yitz> xplat: i disagree. a real language in development is not esoteric, it's just in development. languages like unlambda and BF are esoteric.
08:39:05 <jmcarthur> oh well, i guess i can't use ghc-vis until gtk works with ghc 7.6 :(
08:39:06 <Jaxan> beaky: a typeconstructor that has a corresponding fmap function
08:39:20 <nand`> beaky: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass
08:39:22 <Jaxan> the easy example is that [] is a functor
08:39:23 <xplat> yitz: i guess it's a question of semantics then
08:39:54 <yitz> xplat: the classification on the 99 bottles of beer site agrees with me :)
08:40:42 * nand` .oO( a functor is just a Cat-homomorphism, what's the problem? )
08:41:04 <beaky> > fmap (+3) (Just 5)
08:41:05 <lambdabot>   Just 8
08:41:15 <clahey> In ghci, if I have an IO a, can I turn it into an a?
08:41:41 <nand`> you can use do-block like syntax to bind it
08:41:45 <nand`> ‘x <- foo’
08:41:52 <clahey> That's what I was looking for.
08:42:00 <nand`> this is also done implicitly after every evaluation, as ‘it’
08:42:13 * xplat .oO( a catamorphism is just an F-algebra morphism out of the initial algebra, what's the problem? )
08:42:30 <beaky> also, what's a category?
08:42:53 <nand`> sort of like a monoid, if you know those
08:42:57 <Philonous_> It's an object int the category of categories
08:43:06 <xplat> beaky: the 'haskell for all' blog has a good recent post on it called 'the category design pattern'
08:43:26 <xplat> iirc
08:44:19 <beaky> ah
08:44:44 <beaky> Maybe if I understood what a cateory was, I would understand what a functor was, and what a monad is
08:44:46 <yitz> xplat: see also http://esolangs.org
08:45:01 <xplat> yitz: okay, i give up :)
08:45:13 <yitz> xplat: :)
08:45:28 <Philonous_> beaky:  You don't need to care about category theory to understand how haskell functors and monads work.
08:45:47 <nand`> you don't have to understand functors and monads to understand Functor and Monad
08:45:47 <PSV> Mayube if you were a Functor you'd understand arrows
08:45:54 <Jaxan> beaky: (in haskell context, not the general mathematical context) given a typeconstructor F, it is a functor if you can make a sensible function fmap :: (a->b)->(F a -> F b)
08:46:02 <hiptobecubic> it's really annoying that you can't specify executable dependencies in cabal. tried to install ghc-vis, but it requires gtk2hs stuff. fine. there is no gtk2hs package... google around a bit... cabal list gtk2hs reveals "gtk2hs-buildtools", install that first, then try again.. success. Why couldn't that just have been part of the dependency list?
08:46:05 <rainey> Hi all
08:46:07 <nand`> Jaxan: has to adhere to laws, mind
08:46:11 <yitz> hi rainey
08:46:20 <Jaxan> nand`: "sensible" is exactly that
08:46:25 <beaky> what are arrows?
08:46:28 <rainey> I have a question, if you guys don't mind?
08:46:28 <Jaxan> ->
08:46:34 <nand`> fair enough
08:46:36 <sipa> rainey: ask, don't ask to ask
08:46:52 <xplat> beaky: http://www.haskellforall.com/2012/08/the-category-design-pattern.html -- if you didn't google it already
08:46:58 <beaky> ah
08:47:19 <hiptobecubic> beaky, i have a long irc log of someone in here explaining things to me, but it's not a great starting point.
08:47:32 <rainey> I am keen to learn functional programming, but what do you guys think I should learn first. Lisp or Haskell. I know lisp is not pure functional like Haskell, but generally speaking it will introduce me to the ideas.
08:47:43 <nand`> beaky: there's a good reference to what Functor, Monad, Arrow etc. consist of here: http://www.haskell.org/haskellwiki/Typeclassopedia
08:47:53 <xplat> i wonder if it would be okay to ask for permission to ask the channel if it wouldn't be too impolite to ask a question?
08:47:55 <nand`> rainey: I think Haskell would be a better starting language, in all honesty
08:48:11 <nand`> but that's the response you were bound to get in here, imo
08:48:27 <hiptobecubic> do the left and right identities have to be the same object?
08:48:52 <nand`> hiptobecubic: what do you mean?
08:49:04 <beaky> try asking in ##lisp :D
08:49:05 <hiptobecubic> f . id = f   and   id . f = f
08:49:06 <xplat> rainey: the main point of interest lisp has over haskell is macros, and those aren't really a functional programming topic
08:49:17 <nand`> those identities are not objects
08:49:24 <rwbarton> ML is a better language to learn as a stepping-stone to Haskell
08:49:28 <beaky> how can haskell get away without macros?
08:49:29 <Petit_Dejeuner_> but macros are still cool and you should learn them some time
08:49:31 <jmcarthur> rainey: my somewhat biased claim is that haskell is by far the more useful language to learn first. the only thing lisp has to offer, IMO, is an easier time of defining and using macros
08:49:40 <hiptobecubic> nand`, oh.
08:49:53 <hiptobecubic> beaky, there's template haskell
08:49:54 <xplat> meanwhile, haskell has easier-to-read syntax (for humans), better names for a lot of its functions, and more uniformity of implementations
08:49:59 <strebe> jmcarthur: clos is kinda cool
08:50:04 <jmcarthur> beaky: with enough expressive power in the core language, macros are rarely useful. we do have some macro facilities though
08:50:19 <nand`> ‘id’ is a family of morphisms; the identity for each object is a different morphism but they're collectively in the same ‘family’, you could say
08:50:22 <strebe> xplat: I kinda prefer lisp syntax; I find Haskell's a bit baroque
08:50:27 <beaky> ah
08:50:48 <jmcarthur> strebe: you can always just use prefix syntax everywhere if you prefer
08:50:49 <Philonous_> hiptobecubic:  Suppose you had left and right identity idl and idr, then idl = idl . idr (right identity law) = idr (left identity law)
08:51:03 <nand`> I think lisp's syntax is counterproductive for educational purposes since you have to squint too much to make out all of the closing parentheses
08:51:22 <strebe> jmcarthur: not in other people's code :-)
08:51:28 <clahey> :t \a b -> maybe b (.) a :: Maybe (a -> a) -> (a -> a) -> (a -> a)
08:51:29 <jmcarthur> well, it's true that after a while you stop getting distracted by the parens in lisp so much
08:51:29 <lambdabot>     Couldn't match expected type `(a -> a) -> a -> a'
08:51:29 <lambdabot>            against inferred type `Maybe b'
08:51:29 <lambdabot>     In the expression:
08:51:49 <jmcarthur> strebe: other peoples' code in any language normally sucks ;)
08:51:50 <clahey> Can anyone tell me what I'm doing wrong there?
08:52:00 <hiptobecubic> Philonous_, yes of course. thanks.
08:52:04 <strebe> nand`: I've had less problems with closing parens than with syntax in other languages
08:52:15 <randomclown> clahey: what did you want?
08:52:21 <strebe> rainey: these things said, I'd still say "do Haskell first"
08:52:23 <nand`> also I think lisp isn't really “logical” enough to make a lot of sense. I think it muddles a lot of things together that are logically fairly separate concepts in the interest of having a “consistent syntax”
08:52:47 <rainey> I see
08:52:47 <xplat> another answer to 'how can haskell get away without macros?' is that with laziness you can do a lot of things with higher-order functions that would require macros in a strict language
08:52:49 <clahey> randomclown, I want it to do a compose, unless the maybe is nothing in which case just return the original value.
08:52:59 <rainey> I think you guys (although biased) have sold it to me
08:53:05 <nand`> add to that the carefree nature with which side effects and mutability are approached
08:53:32 <clahey> Oh, I see why it's not working.
08:53:46 <Saizan> ?type maybe id (.)
08:53:47 <lambdabot> forall b (f :: * -> *). (Functor f) => Maybe (b -> b) -> f b -> f b
08:53:48 <rainey> Generally, I only have experience in OOP and all that comes with that, so want to give functional programming a blast to broaden my mind (and reach "enlightenment")
08:53:50 <clahey> No big deal, I wrote it by hand.
08:54:14 <strebe> rainey: Haskell forces you to think about programming in another way; lisp is more multi-paradigm-friendly, which is often good, but not as much if you want to get your head around FP
08:54:22 <randomclown> :t fmap (:) (Just 1)
08:54:23 <zomg> rainey: you gonna have to go to tibet and become a monk for the enlightment part though
08:54:24 <lambdabot> forall a. (Num a) => Maybe ([a] -> [a])
08:54:25 <zomg> lol
08:55:01 <randomclown> something like (:) <$> (Just 1) ?
08:55:19 <randomclown> > (:) <$> (Just 1) (Just [1])
08:55:20 <lambdabot>   Couldn't match expected type `t -> f a'
08:55:20 <lambdabot>         against inferred type `Data...
08:55:22 <xplat> randomclown: exactly like that, since <$> is fmap
08:55:34 <randomclown> > (:) <$> (Just 1) <*> (Just [1])
08:55:36 <lambdabot>   Just [1,1]
08:55:46 <randomclown> > (:) <$> Nothing <*> (Just [1])
08:55:48 <lambdabot>   Nothing
08:55:49 <monochrom> hiptobecubic: I agree about executable dependency, but I don't understand this particular instance. ghc-vis has build-depends cairo and gtk, so cabal will automatically attempt cairo and gtk. when attempting them, their Setup.hs's already know to say "please install gtk2hs-buildtools first". in no step of this process do I see any need to use google or cabal list
08:55:49 <BennyLajjva> zomg, mun rakastettu porosyöjä, miten menee?
08:55:54 <strebe> rainey: for what it's worth, the first standardized OO languge was.... common lisp
08:56:28 <randomclown> clahey:
08:57:09 <rainey> I see
08:58:00 <xplat> common lisp doesn't do much by half-measures either
08:58:19 * hackagebot packunused 0.1.0.0 - Tool for detecting redundant Cabal package dependencies  http://hackage.haskell.org/package/packunused-0.1.0.0 (HerbertValerioRiedel)
08:58:27 <xplat> CL has a meta-object protocol and multiple dispatch, singleton objects, all kinds of stuff
08:58:31 <hiptobecubic> monochrom, no. What is said was "/home/john/.../Hierarch.chs.template: openFile: does not exist (No such file or directory); Failed ot install pango-0.12.3. so #$@% you, chief."
08:58:44 <hiptobecubic> no mention of buildtools anywhere
08:59:02 <xplat> common lisp in general is like a fractal kitchen sink
08:59:04 <hiptobecubic> except that it is part of the path of that file that it's looking for
08:59:14 <clahey> randomclown, Not what I'm looking for really, but I got it working.
08:59:23 <Jaxan> smalltalk is a funny OO language
08:59:26 <nand`> I often find myself wanting an overloaded Boolean typeclass when golfing
08:59:32 <clahey> randomclown, I want maybeCompose Nothing to be id
08:59:33 <strebe> Jaxan: smalltalk is lovely
08:59:38 <nand`> because stuff like: filter (condA || condB) -- looks so logical
08:59:48 <nand`> where condA, condB :: T -> Bool
08:59:56 <hiptobecubic> Why does their seem to be such an overlap between haskell and smalltalk fans?
09:00:13 <byorgey> there is?
09:00:18 <xplat> nand`: yeah, lifting it over naked-reader explicitly is a pain for operators
09:00:26 <jix> I think CL not giving you guaranteed tail call optimization is a problem for many cool functional things
09:00:32 <rainey> What are your favourite haskell books?
09:00:38 <nand`> arguably it might be more useful for || && than for + * etc.
09:00:44 <nand`> where it works fine
09:00:51 <byorgey> rainey: introductory books, or any books?
09:01:03 <beaky> don't serious CL implementations implemen tailcall anyway?
09:01:14 <xplat> (||) <$> condA <*> condB -- blech
09:01:17 <rainey> Any, just your favourite (haskell related) books or even papers
09:01:19 <jix> and IIRC there is no compiler that will optimize tail calls inside bindings for dynamically scoped variables
09:01:32 <strebe> hiptobecubic: they're both interestingly-designed languages that can do amazing things and feel nice to use, but where 3rd-party libraries are a bit scarce compared to more popular implementations, and both are popular in some parts of academia?
09:01:36 <jix> which scheme manages to do AFAIK
09:01:38 <xplat> liftM2 (||) condA condB is hardly better either
09:02:30 <byorgey> rainey: "pearls of functional algorithm design" by richard bird; anything listed on http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
09:02:39 <jix> beaky: but in my experience, it's easy to hit corner cases where they don't (dynamic bindings) and suddenly the code produces a stack overflow
09:02:46 <xplat> i sometimes do things like (<||>) = liftM2
09:02:48 <dada-cetacean> what does <> do?
09:02:51 <xplat> (||)
09:02:52 <strebe> rainey: I like 'real world haskell'; newbies on this channel seem to prefer 'learn you a haskell', and if you decide to look at category theory and don't have a degree in maths, awodey
09:02:54 <monochrom> hiptobecubic: that is not what I can reproduce here. and theoretically, if you don't have gtk2hs-buildtools, the process cannot even get as far as trying pango
09:03:36 <byorgey> dada-cetacean: it depends where you saw it
09:03:44 <nand`> xplat: hey, that looks half-decent
09:03:47 <byorgey> dada-cetacean: typically it is a synonym for 'mappend' from the Monoid type class
09:03:54 <byorgey> but there are other uses as well
09:03:59 <Philonous_> xplat:  idiom brackets would be nice for that
09:04:09 <nand`> I've seen it used for Semigroup
09:04:15 <xplat> dada-cetacean: <> itself is the generic monoid operation, but wrapping an operator in <> is entirely up to the person who wrote the <>-wrapped version
09:05:04 <xplat> also, is there a <> used for pretty-printing?  i think i might have seen something like that for some library
09:05:06 <byorgey> oh, right.  often <x> is some sort of "lifted" variant of x
09:05:07 <nand`> (<>) :: Doc -> Doc -> Doc is pretty common too I think
09:05:08 <byorgey> xplat: yes
09:05:12 <xplat> @hoogle <>
09:05:12 <lambdabot> Language.Haskell.TH.PprLib (<>) :: Doc -> Doc -> Doc
09:05:12 <lambdabot> Text.PrettyPrint.HughesPJ (<>) :: Doc -> Doc -> Doc
09:05:12 <lambdabot> Text.PrettyPrint (<>) :: Doc -> Doc -> Doc
09:05:44 <xplat> > text "hello" <> text "world"
09:05:45 <lambdabot>   helloworld
09:05:57 <nand`> :t (<>)
09:05:58 <xplat> in which case it does that ^
09:05:58 <lambdabot> Doc -> Doc -> Doc
09:06:03 <nand`> :t (++)
09:06:05 <lambdabot> forall m. (Monoid m) => m -> m -> m
09:06:22 <xplat> heh, lambdabot has the other <> called ++
09:06:38 <xplat> not a bad name for it, really
09:06:49 <xplat> if it weren't already taken in the prelude
09:08:17 <hiptobecubic> monochrom, i won't disagree that I can usually do a better job of reading and interpreting all error messages, but the message I pasted was the only one, and it was how every package that pointed at gtk ended. pango, gio, gtk, etc
09:08:18 <xplat> i once had a language where i used ++ as the operation for all the *free* monoids ...
09:08:49 <monochrom> I cannot even get that error message
09:10:43 <xplat> it's probably something that happens if you mess with your OS GTK packages after having built some haskell Gtk stuff already
09:10:56 <Philonous_> What would be a nicer interface for a network library, having TVars with callbacks that are called on each incoming stream element or dumping the elements into a TChan?
09:11:11 <xplat> which would explain being hard to reproduce
09:11:35 <rainey> Thanks guys, you've been real helpful
09:11:55 <nand`> xplat: like Haskell?
09:12:25 <xplat> Philonous_: probably a TChan, if nobody else answers (i'm not really an expert)
09:13:19 <Philonous_> xplat:  That's what I wanted to hear ;)
09:13:32 <monochrom> I get http://www.vex.net/~trebla/tmp/e.txt
09:14:37 <xplat> it seems like the TChan would make it easier to structure transactions in a nice way
09:15:20 <xplat> with TVars your transaction granularity would be controlled by the library, so, headache
09:16:34 <xplat> on the other hand, it's probably easier to write an efficient adapter from the TVar interface to the TChan interface than vice versa
09:16:59 <xplat> maybe make the TVar interface but have an adapter on it by default?
09:17:50 <osa1> how can I get command line parameters that my program called with ?
09:18:06 <xplat> @hoogle getArgs
09:18:06 <lambdabot> System.Environment getArgs :: IO [String]
09:18:06 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
09:18:19 <osa1> thanks
09:20:38 <Philonous_> xplat:  That's was my second thought. It's more general so I'm not sacrificing anything (except a bit of speed, but performance if not all that important)
09:20:46 <Philonous_> is*
09:21:44 <Philonous_> Actually, it's not really more general.
09:22:16 <twice11_> Hi, on the "Dealing with binary data", I read that Data.Binary.Get is lazy. That's not what I observer with ghci 7.4.1. Is the info out od date?
09:22:51 <twice11_> I expect to get one value printed before the exception in (runGet (do a<-getWord8;b<-getWord8;return (a,b)) (LBS.replicate 1 0))
09:25:04 <twice11_> > (Data.Binary.Get.runGet (do a<-Data.Binary.Get.getWord8;b<-Data.Binary.Get.getWord8;return (a,b)) (Data.ByteString.Lazy.replicate 1 0))
09:25:05 <lambdabot>   Not in scope: `Data.Binary.Get.runGet'Not in scope: `Data.Binary.Get.getWor...
09:27:07 <beaky> why do I keep faling to build darcs in archlinux?
09:29:42 <byorgey> beaky: magic 8-ball says: too many errors
09:30:27 <roconnor> @free mp : (A -> b) -> F A -> F b
09:30:27 <lambdabot> Extra stuff at end of line
09:30:32 <roconnor> @free mp :: (A -> b) -> F A -> F b
09:30:33 <lambdabot> $map_F f . mp g = mp (f . g) . $map_F $id
09:32:56 <beaky> :(
09:33:22 <byorgey> beaky: we are happy to provide help but you will have to provide a bit more information first =)
09:34:02 <beaky> ah right
09:34:12 <beaky> ill hpaste wahat cabal says
09:38:47 <clahey> mcstar, So, I finished the non recursive part of my sudoku solver.
09:38:58 <beaky> :D
09:39:04 <clahey> The one that just follows rules until it can't do any more tightening of things.
09:39:31 <clahey> I've got other stuff to do, but next I'll add the bit that starts to make guesses.
09:39:42 <clahey> Like cleaning my house type stuff to do.  :)
09:40:11 <clahey> It's pretty slow, but I'll add more optimizations later.  The big one is keeping track of which cells changed, I think.
09:41:15 <clahey> Right now, once a cell has been cut down to a single value, for example, every time through the cycle it does an and on all the other cells in the row, column, and box.
09:41:43 <clahey> Actually, maybe I'll do that optimization before writing the recursive bit...  hmm.
09:58:59 <atriq> Easiest way to update GHC?
09:59:32 <strebe> atriq: clap your heels 3 times, point west, and... which operating system are you using?
09:59:43 <atriq> Ubuntu
09:59:58 <atriq> Also, I have no idea which way is west
10:00:18 <monochrom> I only know the eastest way, but not the easiest way
10:00:25 <rwbarton> there is no "update" really beyond "install the new version"
10:00:39 <ion> atriq: https://gist.github.com/2815423
10:01:13 <atriq> ion, that looks ridiculous
10:01:15 <strebe> atriq: it's in the ubuntu repositories, so aptitude will work nicely; if you want to compile a newer version yourself, consider making a .deb with checkinstall
10:01:55 <rwbarton> you can skip steps 6-7 since you already have an old cabal-install, unless it is very old
10:02:08 <rwbarton> or replace with "cabal update; cabal install cabal-install"
10:02:30 <monochrom> indeed, don't upgrade cabal unless you know why you need it
10:02:41 <monochrom> s/cabal/cabal-install
10:03:01 <atriq> How did cabal get its name?
10:03:03 <rwbarton> or you can "just" distupgrade ubuntu :)
10:03:28 <monochrom> anyway, I don't know why you think that procedure is ridiculous
10:03:33 <atriq> rwbarton, slightly overkill, considering I'm sitting in a hotel in a country I don't speak the language to
10:03:46 <rwbarton> well of course ubuntu will only give you the version in that ubuntu
10:04:51 <beaky> How different is something from the ML Family (OCaml, SML, F#) from Haskell?
10:05:01 <beaky> i.e. if I grok haskell will I easily pick up those as well?
10:05:13 <monochrom> they are eager. they have nicer modules
10:05:19 <rwbarton> most likely yes
10:05:26 <Eduard_Munteanu> And impure.
10:05:56 <beaky> nicer module systems? how
10:05:59 <Zeus|work> Уотсон?
10:06:04 <Eduard_Munteanu> First class modules.
10:06:15 <Zeus|work> resure?
10:06:18 <Zeus|work> Ты тут?
10:06:21 <Eduard_Munteanu> Zeus|work: english?
10:06:24 <beaky> why aren't modules in Haskell first class?
10:06:30 <hiptobecubic> I never understood why first class modules would be helpful, actually.
10:06:30 <Zeus|work> Ok.
10:06:36 <monochrom> have you thought of parameterizing your modules?
10:06:49 <hiptobecubic> apparently not?
10:06:51 <Zeus|work> I bad speak Eanglish ^^
10:07:18 <dimka> Eangleesh
10:08:01 <monochrom> SML module is not first-class, actually.
10:08:03 <Zeus|work> Oh, there are very much people!
10:08:16 <Eduard_Munteanu> Yep :).
10:08:17 <skchrko_> beaky, Haskell is from ML family :)
10:08:17 <akamaus> it's time to create haskell_ru I guess ;)
10:08:36 <atriq> Is there a nicer way to do "\s f -> execState $ at s <<.= Nothing >>= assign (at f)"?
10:08:42 <atriq> With the lens library
10:09:06 <Zeus|work> In Russian channel #scp not many people
10:09:12 <Eduard_Munteanu> beaky: also, ML has uglier syntax IMO, a bit more verbose and C-ish.
10:09:27 <Zeus|work> Bye :)
10:09:35 <atriq> Bye
10:10:12 <Eduard_Munteanu> Maybe we need a #haskell-simple-english :P
10:10:14 <beaky> I heard ocamlopt compiles better code than ghc, is that true?
10:10:40 <mauke> no
10:10:45 <rwbarton> it was true a long time ago
10:10:57 <mauke> ghc compiles haskell, which is by definition better code
10:10:59 <Eduard_Munteanu> @where shootout
10:10:59 <lambdabot> http://shootout.alioth.debian.org/
10:11:03 <beaky> ah
10:11:13 <beaky> so GHC is as fast as C?
10:11:17 <atriq> Can be
10:11:29 <mauke> according to einstein's theory, nothing can be faster than c
10:11:31 <Eduard_Munteanu> beaky: depends on the workload
10:11:36 <beaky> right
10:11:46 <atriq> Well written Haskell in GHC is about as fast as well written C in gcc
10:11:55 <portnov> long time ago, in far galaxy...
10:12:07 <hiptobecubic> :D
10:12:08 <Eduard_Munteanu> I kinda disagree, that's way too general.
10:12:26 <monochrom> @quote monochrom faster
10:12:26 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
10:12:45 <Adeon\SIGSEGV> tachyonic code
10:12:54 <Eduard_Munteanu> Most of the shootout apps aren't really "well-written Haskell".
10:12:55 <Adeon\SIGSEGV> faster than c
10:12:59 <sipa> @quote neutrino
10:12:59 <lambdabot> No quotes match. I've seen penguins that can type better than that.
10:13:13 <beaky> ah
10:13:16 <Eduard_Munteanu> Adeon\SIGSEGV: to optimize tachyonic code means making it slower :P
10:13:25 <mauke> cooptimize
10:13:34 <tromp__> to make ghc as fast as c you usually have to write ugly non-idiomatic code
10:13:43 <Eduard_Munteanu> Of course, that's all imaginary. :P
10:13:44 <mauke> oh shit, I'mma cooptimize de
10:13:49 <hiptobecubic> it also takes as long as it would in C
10:13:52 <beaky> so I shouldn't really care that GHC code isn't as fast as C?
10:14:42 <Eduard_Munteanu> beaky: again, depends on what you're doing. E.g. if you're doing CPU-intensive number crunching you might have some problems.
10:14:53 <beaky> ah
10:15:12 <monochrom> Enterprise java is faster than C
10:15:21 <beaky> it is?
10:15:21 <geekosaur> ...but in that case you probably want a good fortran compiler :)
10:15:40 <monochrom> yes. NCC-1701
10:15:58 <Eduard_Munteanu> If you're writing a high-level application (and maybe calling C libs to do the hard work), then Haskell can do better in terms of development time.
10:15:59 <merijn> geekosaur: Well, I've seen some impressive numbers from compiled APL
10:17:47 <mauke> http://memory-beta.wikia.com/wiki/USS_Java
10:18:37 <Eduard_Munteanu> @protontorpedo
10:18:37 <lambdabot> why would u write a interpreter for perl in haskell?
10:19:02 <Philippa> tromp__: you don't necessarily have to write the ugly non-idiomatic code /everywhere/ as an app grows, though
10:19:22 <Philippa> that's something where (constrained/bounded) parametric polymorphism really makes life easier
10:19:46 <Philippa> C+abstractions-in-haskell is a powerful language still
10:20:35 <tromp__> you can limit it to the parts of the code that tak e 95% of running time
10:21:48 <yitz> mauke: for a while, it seemed like results from lhc showed that the speed of c could be exceeded.
10:22:10 <mauke> ooh, where can I download lhc?
10:22:22 <yitz> mauke: however, the haskell software was then replaced, and the result was deemed to be an experimental error
10:22:28 <Eduard_Munteanu> I thought that wasn't LHC.
10:22:45 <Eduard_Munteanu> But OPERA something.
10:23:12 * Eduard_Munteanu . o O ( Lazy Haskell Compiler )
10:24:00 <madhadron> yitz, Oh dear, are we trying to use C as a gold standard for speed again?
10:24:54 <hpc> @quote speed.limit
10:24:54 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
10:26:16 <Eduard_Munteanu> It kinda makes sense when relatively naive C implementations outperform optimized Haskell.
10:26:46 <Eduard_Munteanu> For a certain class of algorithms Haskell doesn't add much value.
10:27:21 <madhadron> Sure, but FORTRAN's a much better choice.
10:27:44 <madhadron> C is fast because it maps fairly closely onto the predecessors to our most common architectures.
10:28:09 <madhadron> FORTRAN is typically faster, and is less dependent on a particular architecture's details
10:28:17 <Iceland_jack> Hopefully one will invent an ignore function for irc allowing to you ignore an entire class of conversations, namely comparing two languages together, namely comparing something to C for speed
10:28:23 <Philippa> that depends on what kind of work you're doing in it
10:28:27 <beaky> heh
10:28:35 <Philippa> I'd sooner C than fortran for symbolic work, much as I'd rather just run screaming
10:30:19 <madhadron> Philippa, Sure. Plus there's the issue that the speed of nontrivial software is usually more dependent on finding the bottlenecks and optimizing them, so microbenchmarks after a certain point are nearly irrelevant.
10:30:35 <madhadron> And if you're running on a Burroughs or a Scheme chip, then the whole balance shifts again
10:31:25 <ParahSailin> jhc isnt very good compared to ghc, but sometimes its useful to get ansi c generated?
10:32:21 <madhadron> But anyone writing C for speed reasons isn't behaving sensibly.
10:34:52 <hiptobecubic> madhadron, ?
10:35:41 <madhadron> hiptobecubic: It takes a lot of prior assumptions before C is sane choice for speed.
10:36:34 <madhadron> Most simply, if you're doing something in FORTRAN's purview, it will outperform C on regular basis.
10:37:16 <sclv> oh great another dissatisfied customer: http://www.txt.io/t-2kv5h
10:37:17 <hiptobecubic> ah, ok sure.
10:37:17 <madhadron> Less simply, it assumes that the speed of every statement is relevant to the speed of your resulting program, rather than the ability to quickly find and replace the parts that are slowing it down.
10:37:38 <madhadron> C slows your development cycle down and restricts a lot of what you might be able to do
10:38:05 <EvanR3> sclv: his font makes me question the value here
10:38:07 <EvanR3> lol
10:38:17 <rwbarton> just wait till you read the text
10:38:23 <EvanR3> lol
10:38:42 <sclv> i do have to say i've never read a rant like this about happstack or snap
10:38:43 <monochrom> semantic versioning doesn't solve GHC's fundamental issue of needing to rebuild things on version changes
10:39:06 <sclv> (we used to get them about happs and darcs back in the day, but the devs changed their process and we stopped getting them)
10:39:19 <ClaudiusMaximus> ugh, *## +## etc have no fixity declarations, so must add brackets everywhere in my lowlevel numeric inner loops
10:39:36 <sclv> so it does make one ponder
10:40:03 <ClaudiusMaximus> does make it 3x faster though
10:40:24 <ClaudiusMaximus> to use unboxed doubles instead of nice friendly syntax...
10:40:29 <identity> did anyone read this yet? http://www.txt.io/t-2kv5h
10:40:37 <sclv> identity: just posted it
10:40:39 <identity> I was thinking of posting it on reddit and letting the wizards rage
10:40:41 <sclv> to the channel
10:40:41 <identity> sclv: ah
10:40:44 <sclv> not to reddit
10:40:58 <sclv> i don't see the point of trolling reddit again with this suff
10:41:02 <identity> at any rate, I knew the post was garbage from the second paragraph
10:41:05 <identity> but I read all of it.
10:41:06 <sclv> it seems like the dude had genuine problems
10:41:16 <sclv> but just got into rage mode
10:41:25 <identity> Aye, I don't doubt that
10:41:28 <sclv> where instead of understanding what was happening, and working through it
10:41:29 <rwbarton> he was here before (still is actually)
10:41:35 <sclv> just was like "blow it away and try again"
10:41:35 <identity> I see
10:41:41 <rwbarton> a lot more interested in complaining than solving his actual problems though
10:41:42 <sclv> and then was like "cabal dev"
10:41:44 <identity> sclv: Indeed.
10:41:47 <sclv> and then etc
10:41:48 <identity> rwbarton: I suspected as much
10:41:56 <sclv> like i've never gotten anything working that way, ever
10:41:58 <sclv> in any language
10:42:09 <identity> indeed
10:42:11 <EvanR3> pages like this fuel 'its true because i can find a webpage that says it' argument style
10:42:19 <EvanR3> which annoys me
10:42:19 <identity> exactly.
10:42:28 <sclv> but i also distrust yesod's infrastructure, honestly
10:42:31 <monochrom> if you want reddit, or more like haskell subreddit, to be better, don't post it. if you want haskell subreddit to be worse, post it.
10:42:36 <sclv> because they keep building and promoting tools to work around cabal
10:43:01 <sclv> instead of just digging into how to make their process play better with cabal
10:43:29 <identity> I don't know enough about yesod as I haven't tried it, but I can still see that the post is full of childish irritation and so on
10:43:36 <monochrom> customers who like http://www.txt.io/t-2kv5h also like: http://www.vex.net/~trebla/humour/lmcify.html
10:44:31 <monochrom> anyway, he doesn't know that the crazy kind of code optimizations done by GHC makes semantic versioning a joke
10:45:27 <monochrom> i.e., have you heard of cross-package inlining?
10:47:25 <Eduard_Munteanu> monochrom: well, I think GCC can do it now too, sort of, they call it link-time optimization
10:47:49 <rzys> question: i tried to implement a dynamic programming algorithm (sequence alignment) in haskell. i made a 2d vector and passed that in a statemonad recursively to fill the matrix. in each function call the matrix gets modified at one cell. is there a better way to do this? im thinking this has some serious performance issues.
10:47:53 <Eduard_Munteanu> Though it's not cross-library.
10:48:21 * hackagebot language-ecmascript 0.9.1 - JavaScript analysis tools  http://hackage.haskell.org/package/language-ecmascript-0.9.1 (AndreyChudnov)
10:48:22 <monochrom> that's cool, but if you postpone it to link-time, you don't run into even one-tenth of the difficulties that GHC faces
10:48:44 <EvanR3> rzys: yeah, if you edit one cell of an immutable array the whole thing gets copied
10:49:16 <roconnor> @free mapA
10:49:18 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `mapA'\n\n"
10:49:25 <Eduard_Munteanu> rzys: you could use a mutable ST array
10:49:26 <roconnor> @free liftA
10:49:27 <lambdabot> Expected variable or '.'
10:49:52 <EvanR3> whats the difference between an array and a vector in haskell
10:50:02 * madhadron hears sequence alignment and gets biology PTSD flashbacks.
10:50:34 <madhadron> EvanR3, A vector in Haskell usually refers to something isomorphic to an n-tuple, representing an element of R^n
10:50:49 <madhadron> An array is the data structure you know and love
10:50:58 <EvanR3> vector is for numbers only?
10:51:19 <rzys> EvanR2, Eduard_Munteanu: if i chose a mutable ST array, what would the type signature of my function look like? currently its: fillGrid :: ReaderT ScoreMatrix (State Grid) ()? Grid is a type synonym for Vector (Vector Int) and ScoreMatrix which tells me how to fill the grid.
10:51:20 <EvanR3> and has 1d index
10:51:28 <monochrom> but then, hackage.haskell.org/package/vector changes all that
10:52:11 <madhadron> EvanR2: *shrugs* Those are the definitions of vector I remember seeing around Hackage. I'm out of date though, so don't trust me.
10:52:32 * EvanR3 stops trusting madhardon
10:52:33 <madhadron> EvanR2: Over in lisp-land and C++, vector is what you would think of as array, of course
10:52:35 <rzys> basically just replace State Grid with ST array something?
10:52:43 <newsham> ?help free
10:52:43 <lambdabot> free <ident>. Generate theorems for free
10:52:56 <Eduard_Munteanu> rzys: no, you'd work in the ST monad.
10:53:10 <EvanR3> madhadron: i know these jargons are thrown about randomly, which is why i specifically asked about haskell data structures, not for instance math or shudder c++
10:53:29 <Eduard_Munteanu> Also...
10:53:31 <Eduard_Munteanu> :t runST
10:53:32 <lambdabot> forall a. (forall s. ST s a) -> a
10:53:41 <madhadron> EvanR3: Right. In Haskell, array generally refers to the data structure. Vector tends to be an element of a vector space.
10:53:56 <EvanR3> no, Vector is an array-like data structure
10:54:05 <EvanR3> in addition to whatever it is in linear algebra lis
10:54:07 <EvanR3> libs
10:54:37 <jix> EvanR3: Vector from the vector package is a 1d array with integer indices starting at 0
10:54:58 <EvanR3> ok
10:55:12 <Eduard_Munteanu> rzys: if you're done with the array when fillGrid returns, you can construct that array in ST and freeze it to an immutable array
10:55:29 <Eduard_Munteanu> @hoogle runSTArray
10:55:29 <lambdabot> Data.Array.ST runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
10:55:34 <jix> EvanR3: Array from the array package (that comes with GHC) allows any instance of Ix as index type
10:55:54 <jix> EvanR3: and allows any subrange as index range (so it doesn't have to be 0 based)
10:56:23 <EvanR3> so vector could have higher performance
10:56:37 <monochrom> if you read something and have a jargon problem, you should ask the author. seriously. any person different from the author is bound to use different, unrelated definitions. clearly.
10:57:11 <EvanR3> is the 'author of vector' here often?
10:57:19 <monochrom> case in point: you likely can't even get two mathematicians, bloody mathematicians, to agree on whether 0 is a natural number or not.
10:57:34 <EvanR3> lol
10:57:53 <rwbarton> the author in this case being rzys i guess
10:59:49 <hiptobecubic> I never understood why 0 was not a natural
10:59:53 <rzys> Eduard_Munteanu, thanks!
11:00:03 <hiptobecubic> *would not be considered* a natural
11:00:17 <EvanR3> why would it ;)
11:00:37 <EvanR3> for that matter why is 1/2 not natural
11:00:46 <monochrom> here is why. first of all, all definitions are made for convenience. that's it. convenience. no platonic truth or similar deep philosophy behind
11:00:59 <madhadron> EvanR3: Hard to reach as a Peano number...
11:01:04 <newsham> heh.. platonic truth.
11:01:19 <EvanR3> uh oh peano == natural ;)
11:01:29 <EvanR3> definition trolls
11:01:30 <monochrom> ok, now, convenience. if 0 is not a natural number, the real analysis people can conveniently say: consider the sequence 1/n, n natural. conveniently avoids 1/0
11:02:15 <newsham> clearly what is needed is a second name
11:02:19 <newsham> i nominate n0tural
11:02:20 <EvanR3> consider the sequence 1/n, where n is 1, 2, 3 or so on
11:02:53 <monochrom> well, the real analysis people also keep harping on rigour, so "or so on" won't do
11:02:59 <nand`> n∈ℕ⁺
11:03:22 * hackagebot anansi 0.4.5 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.4.5 (JohnMillikin)
11:03:24 * hackagebot anansi-hscolour 0.1.1 - Colorized looms for Anansi  http://hackage.haskell.org/package/anansi-hscolour-0.1.1 (JohnMillikin)
11:03:54 <monochrom> well yeah, I agree with ℕ⁺, but if you crack open a real analysis textbook and start correcting it to using ℕ⁺, you will find that you never use ℕ, only ℕ⁺
11:04:44 <beaky> what's real analysis?
11:05:08 <monochrom> at that point, you can see that they start thinking, "let's do the Dennis Ritchie thing. if assignment is used 99% of the time and equality just 1% of the time, why don't we optimize notation, = for assignment, == for equality"
11:05:10 <madhadron> beaky: Calculus with OCD
11:05:24 <newsham> > babbage [1,2,3,9]
11:05:26 <lambdabot>   [1,2,3,9,25,56,107,183,289,430,611,837,1113,1444,1835,2291,2817,3418,4099,4...
11:05:32 <newsham> and so on
11:05:49 <monochrom> similarly, if all you ever do is ℕ⁺, you are tempted to say, ok, re-define things, make it ℕ
11:05:57 <EvanR3> any theory is going to be undefined terms, is 9 undefined terms more righter than 19 </inane>
11:05:59 <beaky> ah
11:06:01 <EvanR3> is going to have*
11:06:05 <beaky> > :t babbage
11:06:06 <lambdabot>   <no location info>: parse error on input `:'
11:06:17 <beaky> :t babbage
11:06:19 <lambdabot> forall a. (Num a) => [a] -> [a]
11:06:23 <beaky> @src babbage
11:06:24 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:06:37 <madhadron> EvanR3: One of the things VI Arnold harps on is that the theorems are forever. The definitions wander around under them.
11:06:48 <monochrom> haha
11:06:51 <EvanR3> cute
11:06:58 <newsham> babbage code is from http://codepad.org/WDXeV59b
11:08:05 <newsham> > babbage [1,4,9,25]
11:08:08 <lambdabot>   [1,4,9,25,61,126,229,379,585,856,1201,1629,2149,2770,3501,4351,5329,6444,77...
11:08:09 <madhadron> EvanR3: But true. If your formulation of place geometry makes Pythagoras's theorem inconvenient, it's going to be ignored.
11:08:22 * hackagebot anansi-pandoc 0.1.1 - Looms which use Pandoc to parse and produce a variety of formats.  http://hackage.haskell.org/package/anansi-pandoc-0.1.1 (JohnMillikin)
11:08:41 <newsham> > babbage [1,4,9,16]
11:08:42 <newsham> oops :)
11:08:43 <lambdabot>   [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
11:08:46 <madhadron> Similarly, if P=NP, you can violate the second law of thermodynamics, which pretty well means that P!=NP.
11:08:49 <EvanR3> pythagorean theorem is the undefined term! >:)
11:08:59 <madhadron> The second law of thermodynamics pretty much trumps anything else.
11:09:16 <madhadron> EvanR3: Yeah, yeah...and yet you manage to pass the Turing test.
11:09:27 <EvanR3> P=NP having any physical bearing on anything sounds dubious
11:09:43 <madhadron> EvanR3: And yet there it is.
11:09:50 <EvanR3> bullshit
11:10:11 <EvanR3> that tipler guy works down the street from and gives me the creeps
11:10:31 <byorgey> > babbage [1,7,19]  -- centered hexagonal numbers
11:10:33 <lambdabot>   [1,7,19,37,61,91,127,169,217,271,331,397,469,547,631,721,817,919,1027,1141,...
11:10:44 <byorgey> neat =)
11:10:49 <hiptobecubic> neat indeed
11:10:55 <madhadron> EvanR3: The guy who wrote the intro textbooks? He gives us all the creeps.
11:11:05 <hpaste> Marzhall pasted “Taking the Tree out of IO” at http://hpaste.org/76900
11:11:09 <newsham> byorgey: babbage was clever
11:11:23 <EvanR3> madhadron: frank tipler
11:11:35 <byorgey> newsham: indeed
11:11:58 <byorgey> > ([1,7,19]...)
11:11:59 <lambdabot>   Not in scope: `...'
11:12:02 <byorgey> aw
11:12:12 <madhadron> EvanR3: This guy: http://129.81.170.14/~tipler/
11:12:13 <madhadron> ?
11:12:23 <EvanR3> yes
11:12:24 <newsham> i dont think the ... formulation works anymore in ghc :(
11:12:28 <byorgey> > ([1,7,19]...)
11:12:30 <lambdabot>   [1,7,19,37,61,91,127,169,217,271,331,397,469,547,631,721,817,919,1027,1141,...
11:12:33 <byorgey> no?
11:12:38 <newsham> oh i guess it does
11:12:49 <rwbarton> it needs an extension though
11:12:52 <marzhallo> Hi all, I think I"m coming up on the final battle with understanding monads. I'm having an error with the "parseIncludeTree" function, "    Couldn't match expected type `IncludeTree
11:12:52 <marzhallo>                                     (Either ParseError String)'
11:12:52 <marzhallo>                 with actual type `IO (IncludeTree [Either ParseError String])'
11:12:52 <marzhallo>     Expected type: [IncludeTree (Either ParseError String)]". I need to pull the tree out of IO, and I"m not quite sure I understand how to do it. Code is at http://hpaste.org/76900
11:12:54 <hpc> :t (...)
11:12:55 <lambdabot> forall a. (Num a) => [a] -> [a]
11:13:03 <marzhallo> gah, sorry for the quadra-post
11:13:15 <rwbarton> also lambdabot's ghc is ancient so byorgey's test proves little about "anymore"
11:13:15 <byorgey> newsham: oh, you might be right.  "The operator `(...)' takes two arguments, but its type `[b0] -> [b0]' has only one"
11:13:19 <monochrom> you need section. "xs ..." does not work, binary operator missing 2nd operand. "(xs ...)" works, operator section
11:13:19 <dmwit> marzhallo: Yeah, it's preferred that you put the error in the paste.
11:13:23 <byorgey> right
11:13:26 <rwbarton> -XPostfixOperators
11:13:31 <dmwit> marzhallo: Anyway, the conclusion (I need to pull the tree out of IO) doesn't follow from the premise.
11:13:39 <byorgey> rwbarton: ah, right
11:13:42 <monochrom> oh, postfix also works, yes
11:13:53 <ion> marzhallo: return (IncludeFile …), return NoIncludes
11:13:55 <monochrom> but postfix is evil
11:15:01 <marzhallo> ALright, so I had tried this before; however, I"m still getting an error. I"ll annotate it to the hpaste.
11:15:22 <hpaste> Marzhall annotated “Taking the Tree out of IO” with “Taking the Tree out of IO (annotation)” at http://hpaste.org/76900#a76901
11:15:23 <dmwit> marzhallo: As you say, return isn't enough. You need a more sophisticated map.
11:15:47 <dmwit> marzhallo: You can try to write it yourself as an exercise, or you can search the standard library for the existing one using Hoogle; which would you prefer help on?
11:15:50 <marzhallo> What does this map need to do?
11:15:58 <dmwit> It needs to deal with IO. =)
11:16:12 <dmwit> marzhallo: Here's why:
11:16:23 <marzhallo> Well, I shuold write it as an exercise, I think, but I"m not exactly usre how it needs to deal with IO.
11:16:33 <martin___> hello?
11:16:47 <dmwit> If we have f :: String -> IO Result, and we just blindly plug types into map's (a -> b) -> ([a] -> [b]), then what we get is
11:16:55 <dmwit> map f :: [String] -> [IO Result]
11:17:01 <dmwit> which isn't *quite* what what we want, right?
11:17:07 <dmwit> We really want [String] -> IO [Result]
11:17:26 <dmwit> So you should try to write a function that does the conversion [IO a] -> IO [a].
11:17:29 <marzhallo> ouch, my head. O.k., I think I get that
11:17:31 <dmwit> (It's tricky!)
11:17:50 <dmwit> martin___: Hello!
11:17:52 <marzhallo> Alright, I"ll work on that, thanks.
11:17:56 <newsham> ?type sequence
11:17:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:18:02 <EvanR3> tricky depending on what primitives you get ;)
11:18:31 <dmwit> And yes, as mentioned above, while this makes a great exercise, once you've done it yourself half a dozen times you should start using the standard library. =)
11:19:07 <marzhallo> Hahah, I think I"ll end up using the standard library after I implement my own, if I can get that far; it'll dountless be prettier and more robust in some fashion.
11:19:17 <marzhallo> doubtless*
11:23:59 <merijn> marzhallo: There's also our good friend mapM
11:24:01 <merijn> :t mapM
11:24:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:24:32 <merijn> which is basically "mapM f = sequence . map f"
11:28:04 <marzhallo> I've heard of mapM, but haven't used it yet. Learning monads for me so far reminds me of when I first started to understand pointers and references. I'm trying to drop the do notation for the moment because it seems to just be confusing me :/
11:28:22 * hackagebot yajl 0.3.1 - Bindings for YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-0.3.1 (JohnMillikin)
11:28:43 <newsham> ?src mapM
11:28:44 <lambdabot> mapM f as = sequence (map f as)
11:33:22 * hackagebot chell-quickcheck 0.2.1 - QuickCheck support for the Chell testing library  http://hackage.haskell.org/package/chell-quickcheck-0.2.1 (JohnMillikin)
11:36:20 <roconnor> @hoogle (Traversal t) => (a -> b) -> t a -> t b
11:36:21 <lambdabot> Warning: Unknown class Traversal
11:36:21 <lambdabot> Data.Traversable fmapDefault :: Traversable t => (a -> b) -> t a -> t b
11:36:21 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
11:36:33 <roconnor> fmapDefault!
11:37:31 <JoeyA> I want to make an action idempotent by first checking a concurrent variable, so only one caller ever gets access.
11:37:54 <JoeyA> Would it be faster to do MVar () and tryTakeMVar, or IORef Bool and atomicModifyIORef?
11:39:10 <JoeyA> I guess I should just benchmark it.
11:42:21 <hpc> JoeyA: i would think more about semantics than performance
11:42:47 <hpc> like, if you want two threads to execute that action one after the other, use MVar (), takeMVar/putMVar
11:43:23 * hackagebot gsasl 0.3.5 - Bindings for GNU libgsasl  http://hackage.haskell.org/package/gsasl-0.3.5 (JohnMillikin)
11:43:24 * hackagebot cpython 3.1.3 - Bindings for libpython  http://hackage.haskell.org/package/cpython-3.1.3 (JohnMillikin)
11:44:19 <rwbarton> you could also use IORef (IO ()) and atomicModifyIORef
11:45:13 <JoeyA> Well, I'm basically comparing MVar Thing to IORef (Maybe Bool)
11:45:20 <parcs`> why do people criticize cabal so much?
11:45:55 <JoeyA> parcs`: Can you give an example?
11:46:04 <hpc> parcs`: because when they tried to do something specific, it broke?
11:46:11 <parcs`> http://news.ycombinator.com/item?id=4709144
11:46:18 <parcs`> (i should stop reading hn)
11:46:53 <merijn> parcs`: I saw the someone, notice how he didn't mention an example language that *does* work
11:47:13 <merijn> So haskell is doing it wrong, but silence when you ask who's doing it right
11:48:23 * hackagebot network-enumerator 0.1.4 - Enumerators for network sockets  http://hackage.haskell.org/package/network-enumerator-0.1.4 (JohnMillikin)
11:50:52 <beaky> @src map
11:50:52 <lambdabot> map _ []     = []
11:50:52 <lambdabot> map f (x:xs) = f x : map f xs
11:51:09 <beaky> @src fmap
11:51:09 <lambdabot> Source not found.
11:51:53 <hpc> parcs`: the original link to txt.io is broken
11:59:27 <beaky> what is the kleisi category
12:01:08 <hpc> beaky: there's a definition in i-forget-which-module called
12:01:11 <hpc> @src Kleisli
12:01:11 <lambdabot> Source not found. stty: unknown mode: doofus
12:01:15 <hpc> :(
12:01:33 <hpc> newtype Kleisli m a b = Kleisli {runKleisli :: a -> m b}
12:01:56 <beaky> :t (>=>)
12:01:57 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
12:02:01 <hpc> :t Kleisli putStrLn -- if Kleisli is in scope...
12:02:02 <beaky> :t (.)
12:02:02 <lambdabot> Kleisli IO String ()
12:02:03 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:02:21 <Cale> beaky: Do you know what a category is?
12:02:22 <hpc> beaky: so for all Monads m, (Kleisli m) is a category
12:02:26 <hpc> with these operations:
12:02:34 <beaky> Cale: not really; what't a category
12:02:39 <hpc> Category.id = return -- with some wrapping
12:02:45 <beaky> what is a category?
12:02:53 <hpc> ah
12:02:54 <Cale> Okay, so a category consists of a bunch of things:
12:02:54 <GnomeStoleMyBike> using amqp in haskell is cool thing :>
12:03:06 <hpc> Category is a class that defines id and (.)
12:03:08 <GnomeStoleMyBike> examples could be more explicite but overall i liked it
12:03:17 <hpc> with some laws
12:03:18 <Cale> hpc: I want to give the general definition
12:03:23 * hackagebot yajl-enumerator 0.4.1 - Enumerator-based interface to YAJL, an event-based JSON implementation  http://hackage.haskell.org/package/yajl-enumerator-0.4.1 (JohnMillikin)
12:03:29 <Cale> the Category class is sort of a distorted version :)
12:03:42 <hpc> ah true
12:03:45 <Cale> So a category C consists of
12:04:12 <adimit> if I want to do regular expressions directly on Text values, is D.T.ICU.Regex my only option?
12:04:14 <merijn> Arrow and morphism are synonyms, right?
12:04:28 <dmwit> merijn: right
12:04:28 <Cale> 1) A collection Ob(C) of "objects" of C. From the point of view of category theory, these have no structure (apart from being able to tell them apart) and are just labels.
12:04:29 <fds> What's a good paper for an introduction to category theory for programmers/CS students?
12:04:36 <adimit> (I don't like that most its functions live in the IO monad.)
12:04:45 <merijn> fds: I've heard good things about Awodey
12:04:52 <beaky> ah
12:05:04 <Cale> 2) For each two objects X and Y in C, a collection C(X,Y) of arrows. When f is an arrow in C(X,Y), we write f: X -> Y.
12:05:28 <beaky> so functions belong to a category?
12:05:30 <Cale> The arrows themselves are also considered not to have any internal structure
12:05:33 <Cale> yeah
12:05:43 <Cale> There's a category of sets and functions between them
12:05:46 <merijn> fds: There's also "Basic Category Theory for Computer Scientists" by Piece, but it seems a bit...dense
12:05:53 <Cale> Or Haskell types and Haskell-definable functions
12:05:57 <beaky> ah
12:06:05 <beaky> so functions are arrows between objects?
12:06:09 <Cale> yeah
12:06:14 <beaky> that's it?
12:06:16 <Cale> and objects in that category are types
12:06:25 <Cale> Well, I'm not quite done with the definition :)
12:06:35 <beaky> oh ^^
12:06:48 <hpaste> “Joey Adams” pasted “IORef vs MVar to make something idempotent” at http://hpaste.org/76902
12:07:06 <Cale> 3) For any three objects X, Y, Z and arrows f: Y -> Z, and g: X -> Y, there is a composite f . g: X -> Z
12:07:22 <hpaste> “Joey Adams” annotated “IORef vs MVar to make something idempotent” with “Criterion output” at http://hpaste.org/76902#a76903
12:07:39 <Cale> 4) For any object X, there is an arrow id_X: X -> X
12:07:44 <JoeyA> Sorry for the noise.  Just using hpaste as a blogging platform.
12:07:57 <Cale> and then we have a few laws
12:08:25 <fds> merijn: Thanks, I'll look those up.
12:08:44 <Cale> 5) for any arrows objects, X, Y, Z, and arrow f: X -> Y, and g: Z -> X, we have f . id_X = f and id_X . g = g
12:08:59 <Cale> that is, these id_X arrows act as identities with respect to composition
12:09:08 <beaky> so category theory just declares objects in a category, arrows between those objects, and laws that specify how those arrows can be composed?
12:09:15 <Cale> sorry, that first "arrows" was spurious
12:09:20 <beaky> ah
12:09:26 <beaky> id isn't an arrow?
12:09:32 <Cale> id is an arrow
12:09:33 <Eduard_Munteanu> It is.
12:09:39 <Cale> Well, id_X is for each X
12:09:43 <roconnor> @type liftA
12:09:44 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
12:10:22 <Cale> Lastly, 6) For any four objects, X, Y, Z, W and arrows f: X -> Y, g: Y -> Z, h: Z -> W, we have (h . g) . f = h . (g . f)
12:10:25 <beaky> so id is just an arrow pointing back to itself?
12:10:33 <Cale> id_X is an arrow X -> X
12:10:45 <beaky> ah, an arrow pointing to its own type?
12:10:51 <Cale> which is special in that composing it with any arrow you're allowed to compose it with will "do nothing"
12:11:05 <Cale> There may be other arrows X -> X which aren't so simple
12:11:11 <Eduard_Munteanu> There are objects, and there are arrows between objects.
12:11:14 <beaky> what's the point of the id arrow?
12:11:18 <Cale> For example, if you're thinking in terms of functions, there are lots of functions Integer -> Integer
12:11:24 <beaky> right
12:11:34 <Cale> but we have the function  id x = x
12:11:40 <Cale> which is particularly simple
12:12:13 <Cale> and id . f = f and g . id = g for any f and g
12:12:46 <beaky> > (id . id . product . id) [1..10]
12:12:48 <lambdabot>   3628800
12:12:52 <Cale> Categories abstract the idea of a collection of things we're studying and the structure-preserving maps between them.
12:12:57 <Eduard_Munteanu> beaky: do you know what a monoid is?
12:13:07 <beaky> Eduard_Munteanu: not yet :(
12:13:13 <Eduard_Munteanu> Ah, neverind then.
12:13:16 <merijn> beaky: Well, there's not really a point per se. Asking "what's the point of the id arrow" is sorta like asking "what's the point of an associative operation"
12:13:17 <Eduard_Munteanu> *nevermind
12:13:19 <beaky> but I think I have a basic idea of what categories are now :D
12:13:23 <Cale> Ah, perhaps now would be a good time to introduce you :)
12:13:45 <Cale> A monoid is essentially the same thing as a category with one object. But there's a more straightforward way to define it
12:13:49 <rwbarton> id is the result of composing a string of 0 functions
12:14:28 <Cale> A monoid consists of a set M together with a function *: M x M -> M (usually called multiplication, even though it doesn't necessarily have much to do with usual multiplication)
12:14:44 <Cale> Such that for any a, b, c in M we have a * (b * c) = (a * b) * c
12:15:00 <Cale> and there is some e in M such that for any a in M we have e * a = a and a * e = a
12:15:25 <clahey> beaky, Don't forget:
12:15:27 <clahey> > (id id . product . id) [1..10]
12:15:30 <lambdabot>   3628800
12:15:36 <Cale> There are lots of examples of monoids. Perhaps the most important is lists under concatenation.
12:15:47 <Cale> With the empty list being the identity
12:16:21 <Eduard_Munteanu> Or natural numbers under multiplication.
12:16:22 <clahey> What about functions with id as the identity?
12:16:41 <clahey> Or natural numbers under addition.
12:16:54 <Cale> clahey: Right, functions from a set to itself
12:17:01 <Cale> under composition
12:17:07 <clahey> Cale, Endomorphisms?
12:17:22 <Cale> Or more generally, in any category, the arrows from an object to itself under composition
12:17:37 <Cale> will form a monoid where id_X is the identity (X being the chosen object)
12:18:19 <clahey> A morphism is from one category to another or?
12:18:32 <Eduard_Munteanu> Morphisms are arrows usually.
12:18:41 <clahey> Oh, okay, that's what I thought before.
12:18:43 <Cale> "Morphism" is just another word for "arrow"
12:18:53 <Cale> Also "homomorphism"
12:18:55 <beaky> so monoids are like data types ?
12:19:06 <Eduard_Munteanu> But if you're talking about monoid homomorphisms, then yeah, you can think of functors between monoid categories.
12:19:16 <Cale> beaky: Well, yeah, if you want to think of sets as being like data types :)
12:19:42 <clahey> Eduard_Munteanu, No, I was just confused by Cale using the word arrow and for some reason I thought arrow and morphism couldn't be the same.
12:19:44 <Cale> In Haskell we have a class for types with a Monoid structure
12:19:49 <Cale> class Monoid m where
12:19:51 <Cale>   mempty :: m
12:19:58 <Cale>   mappend :: m -> m -> m
12:20:07 <Cale> mempty and mappend are sort of ugly names
12:20:16 <Cale> but it gets the idea across
12:20:37 <Cale> The laws are that  mappend x (mappend y z) = mappend (mappend x y) z
12:20:39 <hiptobecubic> i like them
12:20:41 <clahey> Can you give some examples of why you would use mempty and mappend instead of the spectific ones?
12:20:53 <Cale> and that  mappend mempty x = x and mappend x mempty = x
12:21:04 <Eduard_Munteanu> clahey: the Writer monad
12:21:13 <Cale> clahey: one sec while I find you a reddit post :)
12:21:30 <Cale> http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx
12:21:31 <beaky> so a monoid is like a monad that doesn't contain a type?
12:21:35 <Eduard_Munteanu> clahey: it should work with any monoid
12:21:38 <clahey> Eduard_Munteanu, Oh, and some of the folding stuffs.
12:21:44 <Cale> beaky: There's a relationship there
12:21:51 <Cale> beaky: But it's pretty abstract
12:21:55 <clahey> A function that takes a list of monoids and returns a single one.
12:21:55 <beaky> ah
12:22:01 <Eduard_Munteanu> It's probably not what you thought of.
12:22:14 <clahey> @hoogle Monoid m => [m] -> m
12:22:14 <lambdabot> Data.Monoid mconcat :: Monoid a => [a] -> a
12:22:15 <lambdabot> Prelude head :: [a] -> a
12:22:15 <lambdabot> Data.List head :: [a] -> a
12:22:27 <dmwit> beaky: Yes, a monoid induces a one-object category (and vice versa).
12:22:41 <clahey> @hoogle (Monoid m, Foldable f) => f m -> m
12:22:41 <lambdabot> Data.Foldable fold :: (Foldable t, Monoid m) => t m -> m
12:22:42 <lambdabot> Data.Foldable foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
12:22:42 <lambdabot> Data.Foldable foldr1 :: Foldable t => (a -> a -> a) -> t a -> a
12:22:46 <Cale> beaky: Instead of return :: a -> M a, we have a unit which is an element of m... well, an element of m is like a function 1 -> m
12:22:56 <beaky> ah
12:23:23 * hackagebot network-protocol-xmpp 0.4.4 - Client library for the XMPP protocol.  http://hackage.haskell.org/package/network-protocol-xmpp-0.4.4 (JohnMillikin)
12:23:31 <beaky> what's a monoid in Haskell that I've probably been using without knowing it's a monoid?
12:23:31 <Cale> beaky: and instead of join :: m (m a) -> m a, we have a multiplication which is a function m -> m -> m, or if you prefer (m,m) -> m
12:23:39 <Eduard_Munteanu> beaky: lists
12:23:40 <clahey> Oh, so if you have a Monad m, then m () is a monoid?
12:23:44 <dmwit> (Well, okay, I was talking about a monoid in SET, but...)
12:23:49 <beaky> :t mappend
12:23:49 <dmwit> ?instances Monoid
12:23:50 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:23:50 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:24:01 <Eduard_Munteanu> clahey: no, that wasn't the point
12:24:03 <beaky> > mappend [1..10] [1..3]
12:24:04 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,1,2,3]
12:24:07 <Cale> clahey: well, that's true, but that's also not the analogy I'm talking about
12:24:16 <clahey> Okay.
12:24:17 <beaky> :t mempty
12:24:18 <lambdabot> forall a. (Monoid a) => a
12:24:26 <beaky> > mempty []
12:24:27 <lambdabot>   ()
12:24:31 <dmwit> clahey: In fact, for any monoid a, there's a good monoid for Monad m => m a.
12:24:32 <beaky> > mempty [1..10]
12:24:33 <lambdabot>   ()
12:24:35 <Cale> clahey: You can get a monoid from (>>) with return ()
12:24:59 <Eduard_Munteanu> Also there's the famous "a monad is a monoid in the category of endofunctors".
12:25:00 <clahey> Cale, Exactly what I was imagining.
12:25:04 <Cale> > mempty :: [Integer]
12:25:04 <dmwit> clahey: (and () is a monoid)
12:25:06 <lambdabot>   []
12:25:12 <Eduard_Munteanu> Or infamous, anyway. :P
12:25:15 <Cale> > mappend [1,2,3] [4,5,6]
12:25:17 <lambdabot>   [1,2,3,4,5,6]
12:25:30 <Cale> > mappend (Just [1,2,3]) (Just [4,5])
12:25:32 <lambdabot>   Just [1,2,3,4,5]
12:25:37 <Cale> > mappend (Just [1,2,3]) Nothing
12:25:39 <lambdabot>   Just [1,2,3]
12:26:10 <clahey> Oh, (Monad m, Monoid m') can give an instance of Monad for m m'
12:26:19 <Cale> > sortBy (mappend (comparing length) compare) (words "here is a bunch of words to sort by length and then alphabetically")
12:26:20 <lambdabot>   ["a","by","is","of","to","and","here","sort","then","bunch","words","length...
12:26:39 <Cale> (see my reddit post for an explanation of that)
12:26:42 <Eduard_Munteanu> clahey: hm, what do you mean?
12:27:01 <Eduard_Munteanu> That's sort of a kind error.
12:27:17 <Cale> clahey: itym an instance of Monoid
12:27:23 <beaky> so monoids are things that define mappend and mempty?
12:27:29 <hiptobecubic> @src mappend Maybe
12:27:29 <lambdabot> Source not found. My mind is going. I can feel it.
12:27:40 <Cale> beaky: yeah, in such a way that the mappend is associative and mempty is the identity element
12:27:46 <clahey> Right, I meant an instance of Monoid.
12:27:47 <Eduard_Munteanu> beaky: yes, alternatively an associative operation and a unit for it.
12:27:55 <hiptobecubic> is it   (Just x) (Just y) = Just (mappend x y)  ?
12:27:59 <hiptobecubic> or is there a trick
12:28:01 <clahey> That's neat though.
12:28:15 <Cale> hiptobecubic: you left out an mappend there, but yeah
12:28:27 <Cale> mappend Nothing y = y
12:28:31 <Cale> mappend x Nothing = x
12:28:39 <hiptobecubic> oh, yes, mappend at the left too
12:28:40 <beaky> ah
12:28:42 <Cale> mappend (Just x) (Just y) = Just (mappend x y)
12:28:55 <Eduard_Munteanu> Also there's the MonadPlus stuff.
12:29:08 <Cale> yeah, that's actually another monoid instance for Maybe types
12:29:25 <ion> What was the conceptual difference between Alternative and MonadPlus again?
12:29:32 <dmwit> hiptobecubic: There's *many* plausible monoids for Maybe.
12:29:38 <beaky> > sortBy (comparing length ++ compare) (words "here is a bunch of words to sort first by length and then alphabetically")
12:29:39 <lambdabot>   ["a","by","is","of","to","and","here","sort","then","bunch","first","words"...
12:29:43 <beaky> ah
12:29:46 <Cale> ion: MonadPlus implies Monad
12:30:04 <beaky> :t comparing length
12:30:05 <lambdabot> forall a. [a] -> [a] -> Ordering
12:30:05 <hpc> ion: it's the same hysterical raisin that makes Monad not imply Applicative
12:30:13 <clahey> I thought mempty in that normal way was Just mempty, but it's Nothing.
12:30:19 <beaky> :t sortBy
12:30:20 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
12:30:43 <Cale> beaky: One thing to be careful about is that I've redefined (++) in lambdabot
12:30:45 <Cale> :t (++)
12:30:47 <lambdabot> forall m. (Monoid m) => m -> m -> m
12:30:47 <clahey> If you define mappend (Just x) Nothing as Nothing, then mempty is Just mempty.
12:30:51 <Cale> so that it means mappend :)
12:31:02 <Cale> this does the right thing for lists, but is a bit more general
12:31:33 <adimit> is a function (a -> IO b) -> (IO (a -> b)) possible?
12:31:45 <adimit> I have a hunch it's not.
12:31:57 <ion> cale, hpc: Ah, indeed, i forgot about the superclass.
12:31:57 <rwbarton> not a sensible one
12:32:20 <beaky> :t mappend
12:32:21 <lambdabot> forall a. (Monoid a) => a -> a -> a
12:32:23 <beaky> :D
12:32:29 <hpc> adimit: the other way is possible though
12:32:37 <hpc> apply action = do
12:32:42 <hpc>   f <- action
12:32:43 <hpc> er
12:32:51 <beaky> where do functors fit in categories?
12:32:55 <hpc> "apply action a = do f <- action..."
12:32:59 <hpc>   f a
12:33:04 <hpc> er, return $ f a
12:33:05 <adimit> hpc: yeah, the other one's trivial. I just had some need to reverse the process. bah. Using text-icu for regex matching is really awful.
12:33:05 <Cale> beaky: Functors are the natural structure-preserving maps between categories
12:33:08 * hpc lrns2hpaste
12:33:09 <Eduard_Munteanu> beaky: functors are maps between categories
12:33:21 <Cale> beaky: So if we have two categories C and D, a functor F: C -> D consists of
12:33:35 <Cale> 1) A mapping sending objects X in C to objects FX in D.
12:33:59 <Cale> 2) A mapping sending each arrow a: X -> Y in C to an arrow Fa: FX -> FY in D.
12:34:23 <Cale> Such that F(id_X) = id_(FX) for every X in C
12:34:43 <Cale> and such that F(a . b) = Fa . Fb for every composable pair of arrows a, b in C.
12:35:14 <Cale> In Haskell, we have a Functor class which is just for functors from the category of Haskell types to itself.
12:35:18 <clahey> I could totally see IO (Maybe m) being a useful Monoid.
12:35:28 <Cale> (We have a pretty limited ability to discuss other categories inside of Haskell)
12:35:37 <Eduard_Munteanu> I wonder if there's some sort of duality, in that Haskell's monads are strong, you can do that for sums but not for products.
12:35:48 <Eduard_Munteanu> (products in the sense of Pi)
12:35:53 <dmwit> If, like me, you find this definition both perfectly natural and totally unenlightening: the effect is that you have a little (possibly collapsed) image of the source category in the target category.
12:35:56 <Cale> So if Hask is the category of Haskell types and functions, we have that a functor Hask -> Hask consists of
12:36:04 <clahey> Oh, what about Maybe (a -> a)
12:36:07 <hpc> you can use type families and things to express subsets of Hask
12:36:09 <Cale> 1) An assignment to each type t some type F t
12:36:17 <clahey> Is that defined as a Monoid?
12:36:20 <Cale> (which is just like a type constructor)
12:36:36 <dmwit> clahey: Yes, Maybe (Endo a) is a monoid, though probably not the way you want it to be.
12:36:47 <dmwit> s/probably/possibly/
12:36:48 <Cale> 2) An assignment to each function f: a -> b some function F f: F a -> F b
12:36:50 <clahey> dmwit, Why not?
12:37:09 <Cale> This part is provided by the operation fmap which we define for each Functor instance
12:37:20 <Cale> class Functor f where
12:37:24 * dmwit tries to reconstruct the two obvious ways of doing it in his head to compare them
12:37:28 <Cale>   fmap :: (a -> b) -> (f a -> f b)
12:37:46 <Cale> and fmap is required to satisfy the following laws:
12:37:49 <Cale> fmap id = id
12:37:54 <Cale> fmap (f . g) = fmap f . fmap g
12:38:19 <dmwit> clahey: Basically, you have sort of a free choice when combining (Just f) and Nothing: do you return Nothing or Just f?
12:38:30 <Cale> In some way, these say that fmap f won't affect the overall structure of the data structure it's acting on, just applying the function to the "elements" of the structure.
12:38:35 <dmwit> clahey: For the former, (Just id) is the identity; for the latter, Nothing is the identity.
12:39:04 <Cale> beaky: Make sense?
12:39:07 <clahey> dmwit, I want Nothing as the identity.
12:39:14 <Cale> beaky: For example, suppose we have this data type:
12:39:16 <dmwit> Then you're in luck.
12:39:24 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
12:39:46 <dmwit> This time.
12:39:51 <Cale> this assigns to each type t the type Tree t of binary trees with values of type t in the branches
12:40:04 <Cale> and in addition to this, we have a natural definition of fmap
12:40:10 <clahey> dmwit, Yep.
12:40:11 <Cale> fmap f Tip = Tip
12:40:11 <beaky> > (map (+3) . map (+2)) [1..10]
12:40:13 <lambdabot>   [6,7,8,9,10,11,12,13,14,15]
12:40:19 <beaky> :O
12:40:24 <Cale> fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)
12:40:35 <clahey> Why is it Monoid (Endo a) instead of Monoid (a -> a) ?
12:40:53 <Cale> clahey: Because there's already an instance of Monoid for functions which was considered more important.
12:40:57 <dmwit> Because there's already a Monoid b => Monoid (a -> b) instance.
12:41:44 <Cale> The Monoid b => Monoid (a -> b) "lifting" instance is considered more important, because it recursively "creates" lots of useful monoids
12:41:57 <Cale> Like the a -> a -> Ordering monoid I was playing with earlier
12:43:46 <lightquake> is anybody in here good with lenses?
12:44:40 <Cale> lightquake: Well, how good do you need?
12:45:00 <lightquake> i'm running into this issue: i have a bunch of Entities, right now in a list but later as keys in a Map. each entity has a function aiUpdate :: Entity -> World -> [EntityAction]
12:45:11 <Cale> beaky: http://cale.yi.org/share/S.%20Awodey%20-%20Category%20Theory.pdf -- if you're interested in this stuff :)
12:45:22 <beaky> :D
12:45:22 <lightquake> and each EntityAction either corresponds to updating the world, or the entity
12:46:04 <clahey> So, I would have to add an Endo wrapper and then unwrap it after the combination.
12:46:10 <Cale> clahey: yeah
12:46:13 <clahey> And unwrap the Maybe.
12:46:22 <ion> and the IO
12:46:32 <clahey> I don't actually have an IO there.
12:46:39 <lightquake> so i want a performAction function that 'performs' a given EntityAction, mutating the Entity and the World respectively, and then a processActions that gets the [Entity] out of the World and performs all of their actions
12:47:40 <lightquake> oh wait, hm, the value of the aiUpdate  field actually has type Entity -> World -> Rand StdGen [EntityAction]
12:48:18 <Cale> beaky: Apart from monoids, there's another really nice simple example which creates lots of categories
12:48:24 * hackagebot cereal-vector 0.2.0.0 - Serialize instances for Data.Vector types.  http://hackage.haskell.org/package/cereal-vector-0.2.0.0 (AdamFoltzer)
12:48:26 <clahey> I could use Maybe a -> [a] to unwrap the Maybe since I then concat a bunch of them.
12:48:37 <Cale> beaky: If we have a set S with a relation <= on it such that
12:48:54 <Cale> for every x in S, we have x <= x (reflexivity)
12:49:12 <Cale> and for every x, y, z in S, whenever x <= y and y <= z we have x <= z (transitivity)
12:49:47 <Cale> then (S, <=) is called a preorder
12:50:18 <Cale> All the familiar kinds of orderings you might be familiar with are typically preorders
12:50:24 <mcstar> clahey: roger
12:50:41 <Cale> Like the standard ordering on the real numbers or the integers
12:51:13 <clahey> mcstar, I'm actually log off.  I'm planning to add implicit back tracking next.
12:51:20 <Cale> Whenever (S, <=) is a preorder, we can form a category whose objects are the elements of S, and where there is exactly one arrow x -> y whenever x <= y, (and no other arrows)
12:51:22 <clahey> I'm actually about to log off*
12:51:42 <mcstar> k
12:51:57 <clahey> I'll be on and off for the next 2 hours or so.
12:53:27 <beaky> so categories are useful because their properties make them extremely composable?
12:53:50 <mcstar> i think they are universal
12:53:53 <Cale> beaky: Functors between categories of this type are monotone (non-decreasing) functions. Whenever we have an arrow x -> y in C, we get an arrow Fx -> Fy in D, which means that if x <= y, then Fx <= Fy
12:54:44 <Cale> beaky: Categories are an important thing to study because throughout mathematics (and maybe even elsewhere), we're usually not content to study objects of any given type in isolation.
12:55:21 <Cale> We want to study them by way of analogies between them, relating structures to one another in such a way that perhaps we can understand the more complicated ones by a series of analogies with simpler ones.
12:55:34 <Eduard_Munteanu> beaky: category theory lets you define universal constructs that easily generalize to different things
12:56:36 <Cale> Categories abstract this whole process, and whenever we can explain what the objects we're studying are, and how analogies between those structures compose in a sensible way in order to give new ones, we have a category.
12:56:53 <Cale> Essentially every branch of mathematics describes at least one, if not many categories.
12:57:11 <beaky> so numbers are a category?
12:57:15 <Cale> There's a category of sets and functions, a category of vector spaces (over a given field) and linear transformations
12:57:33 <Cale> a category of rings and ring homomorphisms, a category of topological spaces and continuous maps
12:57:42 <Cale> a category of metric spaces and contraction mappings
12:57:50 <Cale> a category of graphs and graph homomorphisms
12:57:57 <Cale> a category of monoids and monoid homomorphisms
12:58:07 <Cale> a category of categories and functors
12:59:03 <Cale> and indeed, there are lots of smaller ones... numbers can be turned into categories in multiple ways -- either through their addition or multiplication, or via any ordering we might have on them
13:00:23 <Cale> Given practically any sort of logical system by which statements can be deduced from other statements, you can also form a category whose objects are the statements of the logic, and there is an arrow X -> Y whenever X entails Y logically.
13:01:43 <nohonor> how can i ask ghci for the type of []'s (>>=)
13:02:19 <nohonor> i.e. can i somehow force it to substitute the type constructor
13:02:33 <byorgey> nohonor: there's not really a way to ask for a specific instance of a polymorphic type without already knowing it
13:02:48 <Cale> nohonor: There's this asTypeIn thing which you could steal from lambdabot...
13:02:48 <byorgey> in particular there's no way to explicitly instantiate type arguments.
13:03:04 <Cale> a `asTypeIn` f = a where _ = f a
13:03:11 <byorgey> nohonor: however, it's not too hard to ask for the type of (>>=)  and then substitute [] everywhere you see m
13:03:12 <Cale> and then you can write something like
13:03:24 <byorgey> Cale: oh, interesting
13:03:44 <nohonor> Cale, byorgey: thanks :-)
13:03:48 <Cale> :t (>>=) `asTypeIn` \(>>=) -> [1,2,3] >>= (\x -> [x,x+1])
13:03:50 <lambdabot> forall a. (Num a) => [a] -> (a -> [a]) -> [a]
13:03:58 <ion> Also useful: asAppliedTo :: (a -> b) -> a -> a -> b ; f `asAppliedTo` x = f `asTypeIn` ($ x) ; infixl 0 `asAppliedTo`
13:03:59 <Cale> :t (>>=) `asTypeIn` \(>>=) -> [1,2,3] >>= (\x -> [show x, show (x+1)])
13:04:00 <lambdabot> forall a. (Num a) => [a] -> (a -> [String]) -> [String]
13:04:23 <efie> tibbe: I hope it's ok to disturb- I import qualified Data.HashMap.Strict as M (!) and I get no error while compiling - but I can't find (!) at http://hackage.haskell.org/packages/archive/unordered-containers/0.1.3.0/doc/html/Data-HashMap-Strict.html
13:04:50 <beaky> why is >>= like mappend?
13:04:57 <byorgey> beaky: it isn't
13:05:04 <byorgey> who said that?
13:05:11 <Cale> beaky: A better question is why join is like mappend
13:05:15 <beaky> > (mappend . show) [1..10]
13:05:16 <lambdabot>   Overlapping instances for GHC.Show.Show
13:05:16 <lambdabot>                              (GHC.B...
13:05:18 <byorgey> join is like mappend on the type level.
13:05:21 <Cale> beaky: but that connection is very abstract
13:05:26 <beaky> ah
13:05:36 <efie> tibbe: sorry, I mean ((!)) of course
13:07:54 <patrickstarfish> hi, i'm a beginner writing an interpreter for an imperative language. I've reached a point where I can interpret non-io statement (like "var = 5") and io statements (like "read var") but i can't seem to figure out how to mix them into one single expression. http://hpaste.org/76907 is what i've got so far
13:08:19 <mmirman> has anybody ever seen any interesting programs for the linear lambda calculus?
13:09:22 <Philippa> patrickstarfish: when you're just doing something pure, return the result
13:09:52 <Cale> patrickstarfish: return :: Env -> IO Env
13:11:24 <patrickstarfish> Philippa, Cale: thanks, but for instance, I need to interpret a while statement recursively... this is where i'm stuck because if I return IO Env, I can't call it recursively
13:11:27 <mkaito> I've been writing an IRC bot in Haskell, taking the one on the wiki as inspiration. I'm porting a bot I wrote in python. This is all a learning exercise in Haskell too. I'd like to keep most things in separate modules, tho. Like, each command the bot can handle should not have to be a function in Main.hs. In Python, I just had a module (file) for each of these, which defined a handle() function to deal with things. What can I do in Haskell about this?
13:11:48 <marzhallo> patrickstarfish: I know that feel
13:11:58 * gwern always feels this way http://ro-che.info/ccc/16.html 
13:12:47 <typoclass> gwern: awww :-/ nice link :-)
13:13:33 <Cale> patrickstarfish: Well, you can do your whole Env -> Env thing first, and then turn that into an IO Env at the end.
13:14:23 <Cale> mkaito: Roughly the same thing, I'd imagine?
13:14:32 <Philippa> Cale: or make everything env -> IO env
13:14:44 <Cale> Indeed
13:14:56 <Philippa> but this is what /sensible/ expression/statement separations are about
13:17:52 <Pcmaniac92> Hello :)
13:19:45 <Pcmaniac92> why is the operator "-" left fixitied? :)
13:19:54 <patrickstarfish> Cale, so how could I just do the Env -> Env stuff first, then turn it into IO Env?
13:29:50 <clahey> Can someone either explain the monomorphism restriction or URL me?
13:30:09 <sipa> ;;google dreaded monomorphism restriction
13:32:11 <mkaito> Cale, I'm not entire sure how to structure things in haskell. In python I was able to keep the module references in an array and then just map module.handle(stuff)
13:33:19 <Cale> mkaito: You can still form a list of the handlers from each module
13:34:01 <typoclass> clahey: i think the grey code box at the top explains it pretty well http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:34:14 <mkaito> I'll see if I can figure out how to do such imports
13:34:20 <clahey> typoclass, It explains the rule, but not the reason.
13:34:24 <beaky> is fmap an example of an isomorphism?
13:34:36 <mkaito> can I have a list of strings with module names, and import the corresponding modules?
13:34:45 <Cale> beaky: no
13:34:48 <clahey> I don't think so.  I think an isomorphism requires an inverse.
13:35:10 <beaky> ah
13:35:13 <clahey> typoclass, It explains things that are legal and things that aren't, but not the reason for it.
13:35:25 <Cale> beaky: There are isomorphisms between categories, which are functors which have inverses.
13:35:45 <Cale> beaky: But most functors you'll come across in Haskell won't be invertible, with the one exception of Identity
13:35:49 <beaky> so fmap is a mere homomorphism
13:35:57 <Cale> fmap is *part of* a functor
13:36:05 <clahey> beaky, [Int], [Int] -> [Int] is a category, no?
13:36:06 <typoclass> clahey: check the paragraph starting "So why is the restriction imposed?", or of course the H98 report (link is on the page) :)
13:36:12 <Cale> which you can think of as a homomorphism of categories
13:36:22 <beaky> right
13:36:26 <Cale> ("homomorphism" is just a fancy tern for "structure preserving function")
13:36:29 <Cale> term*
13:36:41 <Cale> clahey: no
13:36:52 <Cale> clahey: errr
13:36:57 <Cale> clahey: Depends on what you mean by that
13:36:59 <beaky> btw, what does structure mean in the context of morphisms?
13:37:16 <Cale> beaky: Whatever we need it to mean
13:37:47 <Cale> beaky: It's probably more helpful just to look at lots of examples
13:38:16 <clahey> Cale, I mean define a category with the objects being the elements of [Int] and the arrows being the functions from [Int] to [Int]
13:38:21 <Cale> beaky: But throughout mathematics, we have lots of things that we try to study, many of which are sets together with some extra operations or structures of some sort
13:38:43 <Cale> beaky: (like graphs, which are sets of vertices with a relation saying which vertices have edges between them)
13:38:53 <latro`a> it's more useful to define a category with just one object, namely the type [Int]
13:38:56 <Refried__> hey -- what is the V in IterV?
13:39:00 <latro`a> and then functions from it to itself
13:39:03 <Cale> (or like rings, which are sets of elements together with functions defining an addition and multiplication)
13:39:29 <typoclass> mkaito: unfortunately not. you'd have to resort to template haskell (a preprocessor for haskell code). however, you can group imports that you frequently use in a module. for example, i wrote a module "Base" that contains only imports from the libraries (Data.Maybe ...), and exports everything. this means i can do simply "import Base" and have 2 dozen commonly used modules available
13:39:32 <beaky> so structure is basically a component of any formal system
13:39:45 <Cale> beaky: yeah, kinda
13:40:00 <rwbarton> you shouldn't try to define "structure"
13:40:15 <rwbarton> at least, not yet
13:40:21 <Eduard_Munteanu> beaky: for example, monoid homomorphisms preserve monoid structure.
13:40:26 <mkaito> typoclass, I'm basically looking to give my bot plugins
13:40:29 <mkaito> so maybe that's not practical
13:40:33 <mkaito> but I'
13:40:37 <mkaito> I'll look into it
13:40:38 <mkaito> thanks :)
13:40:39 <Cale> beaky: So when we study rings for example, we become interested in functions between rings which preserve addition and multiplication, that is, f(x + y) = f(x) + f(y), and f(x * y) = f(x) * f(y)
13:40:54 <merijn> mkaito: That should be possible, I remember a paper (by dons, I think?) about doing plugins in haskell, but my bookmark for it is dead...
13:41:01 <Cale> beaky: and such functions we call ring homomorphisms, or ring morphisms for short.
13:41:11 <rwbarton> mkaito: you can just list explicitly, in whichever is your bot's "main" module, all the plugins you want to use
13:41:13 <merijn> Maybe someone else here has a valid URL for it still?
13:41:19 <rwbarton> assuming these are compile-time "plugins"
13:41:33 <Eduard_Munteanu> beaky: if you have a homomorphism f : (A, *, id_A) -> (B, +, id_B), then f(x * y) = f(x) + f(y) and f(id_A) = id_B
13:42:01 <typoclass> mkaito: you could do the whole plugin thing (a running haskell program loading more modules into itself), but honestly, i think it's pretty complex for little gain :) i think it'd be perfectly fine if you need to restart and recompile your bot if you want to add or remove a plugin
13:42:07 <Eduard_Munteanu> So that's the sort of compatibility / preservation we're interested in.
13:42:31 <Cale> beaky: Or for example, in graph theory -- do you know what a graph is? (In the sense of a collection of vertices and edges)
13:42:47 <rwbarton> mkaito: by "list explicitly" I mean have a literal list "botPlugins = [PluginOne.handle, PluginTwo.handle, PluginThree.handle]"
13:43:05 <rwbarton> after "import qualified PluginOne; import qualified PluginTwo; import qualified PluginThree"
13:43:11 <rwbarton> i.e. just use normal functional programming
13:43:31 <ParahSailin> "(Packable a1, Packable a2, Packable a3, Packable a4, Packable a5) => Packable (a1, a2, a3, a4, a5)" there's gotta be a prettier way to write this
13:43:43 <ParahSailin> template haskell?
13:43:58 <Cale> beaky: A graph G = (V,E) is a set V of vertices, together with a set E of unordered pairs of vertices in V. If x and y are vertices in V, we write x ~ y whenever {x,y} is an edge in E.
13:44:52 <Cale> beaky: If G and H are graphs, we can define a graph homomorphism f: G -> H to be a function from the vertices of G to the vertices of H such that whenever x ~ y in G, we have f(x) ~ f(y) in H.
13:46:01 <Cale> So a graph homomorphism defined this way is allowed to fold G up, but isn't allowed to send vertices with an edge between them to vertices without an edge between them.
13:46:08 <beaky> right
13:47:08 <Cale> and you might be able to imagine some other possible definitions of graph homomorphisms -- there's at least one or two other common ones which people discuss
13:47:27 <rwbarton> so in this case you are preserving the "structure" of adjancency
13:47:38 <Cale> But once we pick one, then we can form a category of graphs along with whatever sort of graph homomorphisms we've defined
13:48:06 <rwbarton> as opposed to mapping vertices of G to vertices of H willy-nilly which would not preserve that structure
13:48:56 <beaky> so category theory is all about these structure-preserving transformations?
13:49:25 <rwbarton> that is just one take on it
13:50:04 <rwbarton> you can have categories where you're not thinking of the objects as any kinds of "things with structure" at all
13:50:48 <rwbarton> but, it is one rich source of examples
13:50:53 <beaky> right
13:51:08 <rwbarton> here is a different flavor of example of a category
13:51:10 <rwbarton> it has two objects
13:51:13 <rwbarton> I'll call them a and b
13:51:21 <rwbarton> it also has a morphism from a to b
13:51:35 <rwbarton> and, since it is a category, it has identity morphisms id_a and id_b
13:51:39 <rwbarton> that is it
13:52:28 <rwbarton> nothing about "structure"
13:52:29 <mcstar> id_a :: a -> b ?
13:52:34 <rwbarton> no
13:52:40 <rwbarton> id_a : a -> a of course
13:52:40 <mcstar> oppposite?
13:52:43 <mcstar> ah
13:52:52 <rwbarton> so it has a total of three morphisms
13:53:36 <clahey> rwbarton, Is there a special name for the tiny categories of that type?
13:53:43 <mcstar> but can there be an identity morphism from a to b?
13:53:55 <rwbarton> clahey, hmm
13:53:59 <beaky> singleton category?
13:54:01 <clahey> mcstar, What would that mean?
13:54:12 <beaky> so what's the difference between arrows and functions?
13:54:15 <rwbarton> well, you can say that it is a finite category
13:54:54 <mcstar> clahey: there are only 2 objects, a and b, so i thought, there can be one morphism
13:54:59 <clahey> beaky, Functions from one set to another are arrows in Set, right?
13:55:10 <rwbarton> beaky: there is a particular category in which the objects are sets and the arrows are functions between them. or another "category" in which the objects are Haskell types and the arrows are functions between them
13:55:15 <clahey> mcstar, Nope.  You can have plenty of morphisms there.
13:55:45 <clahey> rwbarton, Is there a category where the objects are Haskell objects and the arrows are functions between them?
13:56:03 <Eduard_Munteanu> clahey: what do you mean by objects?
13:56:08 <clahey> Eduard_Munteanu, values?
13:56:23 <beaky> so arrows are basically synonymous to functions
13:56:23 <rwbarton> what's a function from a value to another value?
13:56:36 <clahey> rwbarton, Ah, got it.
13:56:37 <rwbarton> beaky, *in those categories*
13:56:42 <Eduard_Munteanu> beaky: not generally
13:56:47 <beaky> wouldn't it be cool if there were arrows between arrows?
13:56:54 <rwbarton> beaky, yes
13:56:57 <Eduard_Munteanu> beaky: that's possible too
13:57:26 <Eduard_Munteanu> Either in certain categories, or 2-categories.
13:57:30 <mcstar> what does 'object' mean then, in category theory?
13:57:49 <dmwit> What if there were, like, a whole hierarchy of categories, where every category had a whole *category* between its objects.
13:57:51 <mcstar> "it has two objects"
13:57:51 <clahey> mcstar, Whatever you want it to.
13:57:55 <dmwit> ?google n category
13:57:56 <lambdabot> http://golem.ph.utexas.edu/category/
13:57:56 <lambdabot> Title: The n-Category Café
13:57:59 * beaky looks at the stuff in Control.Arrow
13:58:06 <rwbarton> mcstar: the "set of objects" of the category has two elements
13:58:08 <Eduard_Munteanu> For example, there's something called the slice category.
13:58:16 <rwbarton> where "set of objects" is a term that is defined as part of the definition of a category
13:58:20 <clahey> Control.Arrow is not talking arrows in the category sense, is it?
13:58:36 <mcstar> rwbarton: ok, so in your example, a and b has some kind of elements?
13:58:43 <rwbarton> if you want to be pedantic in a particular way then it is the first component of the 5-tuple or whatever that is your category (objects, arrows, composition, ...)
13:58:44 <mcstar> have*
13:58:46 <rwbarton> no
13:58:52 <Eduard_Munteanu> clahey: no, those are arrows as in arrow categories.
13:58:52 <rwbarton> they are just things
13:58:53 <dmwit> http://nlab.mathforge.org/nlab/show/higher+category+theory
13:59:04 <rwbarton> if the category is named C then Ob C = {a,b}
13:59:22 <mcstar> rwbarton: ok, then how many morphisms can exist between a and b?
13:59:29 <rwbarton> however many I like
13:59:34 <rwbarton> but in the example I gave, there is one
13:59:51 <clahey> mcstar, Draw two lines with arrows between a and b and label them.
13:59:56 <clahey> mcstar, Two morphisms.
13:59:57 <rwbarton> but I could have chosen zero or two or any cardinality of a set
14:00:00 <rwbarton> yep
14:00:09 <mcstar> i dont get it
14:00:12 <mcstar> nvm
14:00:15 <dmwit> (You can actually define categories *just* in terms of arrows if you like. Objects arise as those arrows which happen not to do anything when composed with other arrows.)
14:00:17 <clahey> Draw 7 lines and label them A through G and you've got 7 morphisms.
14:00:36 <mcstar> that doesnt make sense to me
14:00:54 <clahey> mcstar, You're familiar with graph theory, right?
14:01:01 <mcstar> sort of
14:01:14 <mcstar> i read the 4 coloring proof
14:01:22 <rwbarton> right, it is exactly the same as in graph theory
14:01:26 <brunonery> anyone experienced with http.conduit and HTTPS?
14:01:27 <Eduard_Munteanu> * => * is one way of representing graphs as a category.
14:01:29 <clahey> mcstar, So a basic undirected graph is a bunch of points and lines between them, right?
14:01:40 <Eduard_Munteanu> (where there are two arrows)
14:01:43 <brunonery> I'm trying to access the Twitter API and it works with HTTP, but not HTTPS :(
14:01:50 <brunonery> I just get an empty response
14:01:51 <clahey> mcstar, Now make the lines arrows and we have a directed graph.
14:02:00 <mcstar> yeah
14:02:10 <mcstar> maybe connected maybe not
14:02:19 <fruitFly> what's a nice irc client?
14:02:22 <clahey> mcstar, Now put a label next to each arrow and you're allowed to have multiple arrows in the same direction between two points.
14:02:28 <rwbarton> a category is just a graph where you have some additional information telling you how to "compose" arrows
14:02:34 <Eduard_Munteanu> fruitFly: depends, what OS?
14:02:36 <rwbarton> that satisfies some laws
14:02:38 <merijn> fruitFly: Depends on what you mean, by nice, I guess?
14:02:42 <mkaito> typoclass, I've seen programs like ZNC (an irc bouncer) that load C++ object files at runtime as plugins. The bouncer is itself written in C++.
14:02:43 <mcstar> weechat
14:02:45 <clahey> mcstar, And you've got a labeled directed graph.
14:02:58 <fruitFly> I'm running win 7, but I
14:03:06 <fruitFly> but I'll prob get linux soon
14:03:10 <Eduard_Munteanu> Not all graphs are categories though, but you given a graph you can find a completion to a category.
14:03:26 <dmwit> There's a lot of cooks stirring this pot.
14:03:27 <Eduard_Munteanu> s/but you/but/
14:03:47 <merijn> dmwit: Must be a quiet evening with no one having anything to do :p
14:03:52 <mcstar> crooks? me?
14:04:00 <clahey> mcstar, So given a finite graph, you can check it if it's a category.
14:04:05 <dmwit> no crooks =)
14:04:05 <parcs`> > map (\a -> 1/sqrt a * 1/(2*pi)**(a+0.5)) [1..]
14:04:07 <lambdabot>   [6.349363593424097e-2,7.145544550467035e-3,9.285597048453126e-4,1.279854491...
14:04:14 <rwbarton> you can't "check"
14:04:17 <rwbarton> it is extra structure
14:04:26 <clahey> rwbarton, Oh, composition, good point.
14:04:40 <parcs`> > map (\a -> 1/sqrt a * 1/(2*pi)**(a+0.5)) (iterate (*100) 10)
14:04:42 <lambdabot>   [1.3155621873294257e-9,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,...
14:04:46 <mcstar> clahey: but why would i want to have more than one directed edge between two vertices?
14:04:58 <rwbarton> why would you want to have more than one function between two types?
14:05:04 <nand`> personally I see categories as an extension of monoids
14:05:16 <mcstar> rwbarton: good point, it is stupid
14:05:55 <Eduard_Munteanu> mcstar: um what?
14:05:58 <clahey> mcstar, Well let's say your graph was a bunch of geographical points.
14:05:58 <clahey> mcstar, And the arrows were possible paths from one point to another.
14:06:02 <mcstar> j/k
14:06:40 <clahey> That is a category, right?
14:07:07 <nand`> makes sense for it to be one
14:07:07 <clahey> People with more experience than I?
14:07:08 <clahey> Oh, I have to run for a minute.
14:07:18 <nand`> you can get to a point from the same point trivially
14:07:23 <mcstar> categories are very generic thats for sure
14:07:29 <nand`> and if you can get from A to B, and from B to C, you can clearly get from A to C
14:07:32 <typoclass> mkaito: sure, it's possible :) in c++ as well as in haskell. i just think it's quite some effort, and not much advantage over just restarting the thing. xmonad (for example) does the plugin thing very well without loading things at runtime
14:07:39 <dmwit> For all graphs G, there is a category whose objects are nodes of G and whose arrows are paths in G. So yes, it's a category.
14:08:00 <mcstar> nand`: not clearly
14:08:03 <dmwit> (paths? trails? I always forget the difference)
14:08:06 <mcstar> what if you dont have enough fuel?
14:08:22 <nand`> yeah, or if paths are mutually exclusive (bike only vs car only)
14:08:30 <Eduard_Munteanu> dmwit: you have to complete G to get a category
14:08:34 <mkaito> typoclass, xmonad exposes functions for the whole thing to recompile itself and restart if it compiles fine. That certainly eases things. I suppose that I could roll the whole thing into an init script for a daemon bot for certain.
14:08:34 <Ralith> 3/lastlog mkaito
14:08:36 <Ralith> er
14:08:36 <beaky> so arrows between arrows can be expressed as a chain of arrows bewteen objects>
14:08:37 <nand`> I guess I was working in an idealized path abstraction
14:08:38 <Eduard_Munteanu> dmwit: for example, if the graph doesn't have identities.
14:08:51 <dmwit> Eduard_Munteanu: I think "whose arrows are paths in G" is the completion process, no?
14:09:09 <Eduard_Munteanu> Ah, paths. I guess so.
14:09:54 <mcstar> rwbarton: wrt you example, are 'a' and 'b' similar to types then? and the morphism between them are functions from values of 'a' to values of 'b'?
14:10:09 <dmwit> That's one popular mental model.
14:10:19 <dmwit> It's not always accurate, but often enough that you shouldn't disabuse yourself of it yet.
14:10:24 <Eduard_Munteanu> mcstar: functions go from type to type
14:10:28 <rwbarton> mcstar: they are just dots on a piece of paper
14:10:42 <rwbarton> nobody ever asks "what are the elements of this vertex of my graph"
14:10:50 <mcstar> i just cant grasp, what are 'a' and 'b' made of, in your example
14:10:53 <rwbarton> nothing
14:11:00 <rwbarton> immaterial
14:11:09 <rwbarton> just names for elements of a set
14:11:13 <Eduard_Munteanu> This is a category: *
14:11:20 <mcstar> how can you interpret morphisms between them, then?
14:11:33 <rwbarton> who said anything about interpreting
14:11:46 <Eduard_Munteanu> mcstar: you don't "interpret" them, they just have to obey the composition and identity laws.
14:11:47 <mcstar> i did :)
14:12:00 <Eduard_Munteanu> Where composition isn't necessarily function composition.
14:12:19 <mcstar> but i cant reason about what can and cant exist between them
14:12:34 <rwbarton> mcstar: I get to pick the morphisms, just like I get to pick the objects.
14:12:38 <Eduard_Munteanu> That's part of specifying the category in the first place.
14:13:02 <dmwit> It's just a definition. There's nothing to understand.
14:13:29 <rwbarton> now *one* way to get a category is to pick some Haskell types for the objects and let morphisms from a to b = Haskell functions from a to b
14:13:34 <mcstar> dmarker: lol?
14:13:34 <rwbarton> that is a very, very special kind of category
14:13:40 <mcstar> heh
14:13:43 <mcstar> sry dmarker
14:13:46 <mcstar> i mean shachaf_
14:13:52 <beaky> is it correct to think oof Haskell data types (those declared with data) as Functors?
14:14:05 <beaky> or only some of them*
14:14:14 <Eduard_Munteanu> beaky: only some of those
14:14:16 <rwbarton> only some of them
14:14:26 <shachaf_> only none of them
14:14:36 <shachaf_> Functors have two pieces, an object mapping and an arrow mapping.
14:14:45 <shachaf_> data declarations give an object mapping but not an arrow mapping.
14:14:52 <beaky> ah
14:15:05 <mcstar> why the name change?
14:15:06 <rwbarton> but in this case the arrow mapping part is unique if it exists, so it's okay to let that slide
14:15:07 <Eduard_Munteanu> Also, a functor is something * -> *.
14:15:08 <beaky> so the arrow mapping comes from fmap?
14:15:16 <Eduard_Munteanu> Yes.
14:15:18 <Eduard_Munteanu> :t fmap
14:15:19 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:16:00 <shachaf_> mcstar: Apparently, as part of an elaborate practical joke, it has been revealed that dmwit and shachaf are the same person.
14:16:10 <shachaf> I don't know what's going on anymore!
14:16:13 <beaky> lol
14:16:16 <fruitFly> In the last function is x a keyword? What else could it be? lucky :: (Integral a) => a -> String   lucky 7 = "LUCKY NUMBER SEVEN!"   lucky x = "Sorry, you're out of luck, pal!"
14:16:27 <nand`> shachaf and shachaf_ have the same color for me. This is immensely confusing
14:16:34 <mcstar> shachaf: i can help, you are dmwit
14:16:49 <shachaf> mcstar: Who're you calling a dmwit!
14:16:50 <Eduard_Munteanu> fruitFly: no, you could just as well use 'y'
14:16:53 <shachaf_> fruitFly: No, it's not a keyword, it's a variable name.
14:16:56 <mcstar> sry...
14:17:00 <beaky> fruitFly: x is just a parameter name
14:17:05 <shachaf_> fruitFly: (It just so happens the variable isn't used in the function body.)
14:17:12 <beaky> right
14:17:26 <fruitFly> so any non integral could be catch
14:17:28 <typoclass> fruitFly: hello, the x is called an argument (or parameter). you could use it on the right side of the "=", although in your example it isn't used
14:17:30 <nand`> a variable name matches any value, and binds it to that
14:17:47 <mcstar> better to use _ in that case
14:17:58 <nand`> so here it's functioning as a catch-all (though there is separate syntax for that, _, which matches any value but doesn't bind it)
14:18:08 <shachaf_> fruitFly: No, this function can still only be applied to values whose type is in the Integral class.
14:18:16 <fruitFly> _ is good practice, but I could use any non integral, correct?
14:18:30 <shachaf_> Oh, now I understand the question.
14:18:33 <nand`> I'm not sure what you mean
14:18:33 <mcstar> (Integral a)
14:18:34 <shachaf_> Yes, you can use any variable name.
14:18:51 <shachaf_> The key thing is that it's a valid variable name, not that it isn't an integer literal.
14:18:57 <nand`> you mean any non-numeral?
14:19:19 <nand`> yeah; there are many things that are not numerals but still not valid variable names
14:19:26 <fruitFly> right shachaf, I don't even know all valid variable names
14:19:35 <beaky> you can have unicode characters as variable names :D
14:19:38 <fruitFly> nand1 correct
14:19:48 <shachaf> fruitFly: Are you confusing me with shachaf_?
14:19:55 * dmwit looks around
14:19:59 <dmwit> I don't see a shachaf_ in here.
14:20:00 <fruitFly> do I just type your name to alert you? I used to type @ then the name
14:20:31 <geekosaur> the @ thing is from twitter and not used on IRC; usually the @ prefix indicates a bot command
14:20:32 <typoclass> fruitFly: yes, we usually just say the name and a colon :-)
14:20:32 <nand`> a variable name is, roughly, a lower case letter (or _) followed by any sequence of letters (or _ or ')
14:20:42 <beaky> right
14:20:44 <beaky> @src map
14:20:44 <lambdabot> map _ []     = []
14:20:44 <nand`> that is not a reserved name (like let, in, where, case, of)
14:20:45 <lambdabot> map f (x:xs) = f x : map f xs
14:20:49 <beaky> @type map
14:20:50 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:21:59 <fruitFly> did I alert you nand`: I get it thanks. You guys are the most helpful community I've encountered yet. :)
14:22:38 <mcstar> was the typeclass/instance mechanism developed to solve the expression problem, originally?
14:23:01 <Eduard_Munteanu> mcstar: what do you mean by that?
14:23:05 <mauke> I think its origin is the == and + problems
14:23:08 <nand`> fruitFly: you didn't the first time; since the extra ‘1’ made my IRC client think of it as distinct
14:23:22 <dmwit> Eduard_Munteanu: Try Wikipedia. =)
14:23:38 <mcstar> Eduard_Munteanu: did they have that in mind, to solve it generally, or this just happened as a side effect
14:23:50 <mcstar> but mauke seem to have answered it
14:23:54 <fruitFly> nand: nand extra 1? To alert you in the chat type youor name or your name then acolon?
14:23:56 * dmwit is assuming Eduard_Munteanu did not realize that "expression problem" is a technical term.
14:23:58 <nand`> typeclasses were developed for ad-hoc overloading of functions; no?
14:24:01 <nand`> whatever that may entail
14:24:11 <CmrPantoufle> Erstarrung: you have a bit of a twisted nick, but hello again anyway
14:24:19 <Eduard_Munteanu> No, I know what it is.
14:24:22 <beaky> http://ideone.com/pEpABE I understand what Haskell Functors are now :D
14:24:25 <beaky> thanks guys
14:24:30 <dmwit> Oh, okay. My apologies, then.
14:25:17 <beaky> How does the expression problem manifest itself in haskell, and how do you counteract the problem
14:25:27 <nand`> fruitFly: earlier you said ‘nand1 correct’. It depends from IRC client to IRC client but for me any instance of ‘nand’ will trigger a highlight, with non-character symbols ignored; so eg. ‘nand: foo’ or ‘nand, bar’ would trigger it, as would ‘nand`: baz’; but generally the most common way is to simply write the recipient's name verbatim followed by a :
14:25:32 <dmwit> data ThingLabel = Foo | Bar | Baz; newtype Thing a = Thing (ThingLabel, a) deriving (Show, Functor)
14:25:35 <shachaf> mcstar: The expression problem is unsolved.
14:25:50 <mcstar> oh
14:26:08 <mcstar> im watching ralf laemmel, and he seems to be confident
14:26:18 <mauke> fruitFly: nand`'s nick is not "nand" or "nand1"
14:27:07 <Erstarrung> hello CmrPantoufle.
14:27:22 <Erstarrung> It means "Numbness" in German. It's from Schubert's Winterreise.
14:27:34 <fruitFly> mauke nand's nick? So I should just write the recipients name to alert them then? Or is the colon after safe?
14:27:59 <fruitFly> mauke: ooooooooooh .. type nand`:
14:28:07 <nand`> yes that looks right
14:28:15 <Eduard_Munteanu> fruitFly: type nan and press tab.
14:29:03 * beaky types 'n', pressed TAB, and voila! nand` 
14:29:28 <fruitFly> nand`:
14:29:33 <fruitFly> hahahaaaaaaaaaaa
14:29:35 <fruitFly> muahhahahaaaa
14:29:44 <beaky> lol
14:29:53 <fruitFly> beaky:
14:29:59 <fruitFly> muahahahhaaaaaaaa
14:30:26 <nand`> just be careful it doesn't come out as ‘Nanar’ or ‘nanobeard_’
14:30:31 <mcstar> nand`:
14:30:33 <mcstar> nand`:
14:30:35 <mcstar> no, its good
14:30:45 <nand`> though intelligent IRC clients prioritize tab completion based on last activity
14:30:47 <nand`> instead of alphabetically
14:30:49 <Ralith> I can't seem to get the 'plot' package to install
14:31:22 <Ralith> for some reason it depends on gtk2hs-buildtools, which doesn't seem to build
14:31:38 <Ralith> but gives no useful error
14:32:30 <rwbarton> gtk2hs-buildtools produces some executables which are needed to build gtk2hs, make sure they are in your path
14:33:11 <dmwit> I've got a more likely explanation: gtk2hs-buildtools doesn't build on GHC 7.6 currently.
14:33:30 <dmwit> If you build the tools with an older GHC, you can still use them, though.
14:33:58 <dmwit> You can use --with-compiler to tell cabal which GHC to use.
14:34:28 <gienah> dmwit: gtk2hs-buildtools needs a patch for its generated code to compile with ghc 7.6.1
14:34:47 <dmwit> Ugh, really?
14:34:54 * dmwit sighs an even bigger sigh than usual
14:35:51 <gienah> dmwit: yeah: this one: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/gtk2hs-buildtools/files/gtk2hs-buildtools-0.12.3.1-remove-conditional-compilation-as-it-is-ignored-ghc-7.6.patch there are other patches in that dir
14:36:03 <nand`> when will Gtk2Hs be compatible with 7.6.x in general?
14:36:04 <nanobeard_> somebody rang?
14:36:06 <gienah> dmwit: its probably easier to use hamishmack s repo
14:36:19 <nand`> nanobeard_: I was demonstrating the fallacies of alphabetical tab completion, move along
14:36:56 <bgamari> nand`, There's a patch
14:36:58 <watermind> isn't there a synonym for (=<<)  using non-operator syntax?  like extend in comonad
14:37:05 <bgamari> nand`, But no one has done anything with it yet
14:37:15 <edwardk> watermind: no
14:37:16 <bgamari> I'm running it locally, things seem to work
14:37:20 <nand`> watermind: not in Prelude, though ‘bind’ would make sense
14:37:25 <watermind> edwardk: :(
14:37:29 <rwbarton> coextend
14:37:34 <watermind> :D
14:37:49 <watermind> nand`: yeap, it isn't >>= read bind?
14:38:04 <watermind> nand`: yeap, BUT it isn't >>= read bind?
14:38:11 <nand`> it is; but I think =<< is the one that should be named, for consistency -> function as first parameter makes sense
14:38:17 <watermind> geez I can't write today
14:38:27 <watermind> nand`: right
14:38:37 <nand`> they're the same function either way up to isomorphism
14:38:43 <nand`> so naming both ‘bind’ is fine
14:38:44 <watermind> yes of course
14:43:15 <gienah> Ralith: this is hamishmack s gtk2hs repo that builds with ghc 7.6.1: darcs get hamish@patch-tag.com:/r/hamish/gtk2hs
14:43:40 <Ralith> gienah: I'm using GHC 7.4.2
14:44:16 <Ralith> rwbarton: gtk2hs-buildtools doesn't build, so I can't very well ensure it's in my path.
14:45:15 <rwbarton> i wasn't sure how you were determining that it was failing, given that it gave "no useful error"
14:45:22 <dmwit> Can you paste cabal's output somewhere, e.g. hpaste?
14:45:55 <gienah> nand`: gtk2hs is compatible with ghc 7.6.1 in this repo: darcs get hamish@patch-tag.com:/r/hamish/gtk2hs
14:46:56 <hpaste> Ralith pasted “gtk2hs-buildtools failure” at http://hpaste.org/76908
14:47:21 <dmwit> "no useful error"?
14:47:27 <Ralith> rwbarton: by trying to install it and seeing that it fails :P
14:47:30 <dmwit> It says right there: "The program alex is required but it could not be found."
14:47:33 <gienah> its says it wants alex
14:47:38 <Ralith> oh wow
14:47:42 * Ralith headdesk
14:48:00 <Ralith> thanks
14:49:22 <rwbarton> now write a 2000-word essay full of profanities about how cabal is the worst package manager ever
14:49:24 <tac> is it idiomatic to run cabal install as root?
14:49:32 <tac> aka sudo cabal install blah
14:49:34 <dmwit> no
14:49:54 <dmwit> These days it is very common to do user installs (since that is the default).
14:50:07 <tac> ok
14:50:08 <tac> thanks
14:50:35 <ksf> ...to the point where my system-wide ghc is still 6.12.3
14:50:46 <geekosaur> cabal install as root installs stuff in root's private ghc package store; this is rarely useful
14:51:08 <dmwit> geekosaur: Unless you've changed the defaults. Which I've done on some systems.
14:51:17 <Ralith> can anyone recommend a plotting library simpler than 'plot'?
14:51:22 <geekosaur> (there *is* a way to get global installs, but that's just asking for package management issues; best is to leave that to howevre you installed ghcin the first place, so you can use that same way to recover from hosage)
14:51:30 <Ralith> I just want simple line/scatter plots
14:51:32 <Ralith> in 2D
14:52:25 <rwbarton> how about the gnuplot package
14:53:26 * hackagebot blank-canvas 0.2.3 - HTML5 Canvas Graphics Library  http://hackage.haskell.org/package/blank-canvas-0.2.3 (AndyGill)
14:53:48 <typoclass> Ralith: not sure if it's applicable, but a cheap universal way is the google chart api. basically you construct a url "http://charts...?..." in a certain way with all the data points, and it sends you a png with the chart. it's very well documented and surprisingly powerful
14:54:10 <starurchin> Built ghc-7.6.1 from source - now cabal-install-0.14.0/bootstrap.sh fails - "Setup: At least the following dependencies are missing: base >=4 && <3 && >=2 && <5, unix >=2.0 && <2.6" - help!
14:54:36 <dmwit> starurchin: You'll want to use cabal-install-1.16 with GHC 7.6.
14:55:15 <dmwit> starurchin: (And you may need to build it with an older GHC.)
14:55:15 <starurchin> @dimwt - thanks, will do, stay tuned
14:55:15 <lambdabot> Supported dictionary-lookup commands:
14:55:16 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
14:55:16 <lambdabot> Use "dict-help [cmd...]" for more.
14:55:46 <Ralith> typoclass: interesting, though not quite what I had in mind
14:56:58 * gienah notes that cabal install as root is a bad idea on gentoo
14:58:53 <beaky> is it possibe to have lists of arrows?
14:59:18 <Eduard_Munteanu> beaky: what do you mean by arrows there, functions? If so, yes.
14:59:19 <ksf> :t [(+),(-)]
14:59:20 <lambdabot> forall a. (Num a) => [a -> a -> a]
14:59:59 <Eduard_Munteanu> :t map ($)
15:00:00 <lambdabot> forall a b. [a -> b] -> [a -> b]
15:00:11 <starurchin> OK, where do I get cabal-install-1.16 ? http://www.haskell.org/cabal/release/ only has cabal-install-0.14.0 (and earlier).
15:01:20 <beaky> :t <*>
15:01:21 <lambdabot> parse error on input `<*>'
15:01:29 <beaky> :t (<*>)
15:01:30 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:01:54 <beaky> [(+1), (*2)] <*> [1..10]
15:01:59 <beaky> > [(+1), (*2)] <*> [1..10]
15:02:00 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,2,4,6,8,10,12,14,16,18,20]
15:02:04 <beaky> O.o
15:02:27 <beaky> what's an applicative
15:02:29 <gienah> starurchin: http://hackage.haskell.org/package/cabal-install
15:02:45 <ksf> beaky, a functor with <*>
15:02:51 <rwbarton> @where typeclassopedia
15:02:51 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
15:03:24 <mcstar> shachaf: is going from the type level to the typeclass level actually cause more problems than it solves? (while trying to formulate open types and operations on them)
15:03:34 <mcstar> does*
15:03:56 <mcstar> 'is' was correct when i started the sentence, but became the wrong choice...
15:04:14 <shachaf> mcstar: ?
15:04:29 <mcstar> you said the expression problem is not solved
15:04:45 <beaky> what are some useful applicatives?
15:04:56 <Cale> mcstar: Open types themselves intrinsically pose some problems.
15:05:04 <beaky> > (\_ -> 1) <*> []
15:05:05 <lambdabot>   Couldn't match expected type `t -> a' against inferred type `[a1]'
15:05:13 <Cale> beaky: every monad
15:05:22 <beaky> > take 5 $ (\_ -> 1) <*> [0..]
15:05:23 <rwbarton> just the useful monads ;)
15:05:24 <lambdabot>   The lambda expression `\ _ -> 1' has one argument,
15:05:24 <lambdabot>  but its type `[a1 -> a]...
15:05:34 <beaky> > take 5 $ [(\_ -> 1)] <*> [0..]
15:05:35 <lambdabot>   [1,1,1,1,1]
15:05:45 <beaky> ah I never knew monads were applicatives
15:06:07 <Cale> The expression problem isn't really a problem that can be "solved" once and for all.
15:06:28 <starurchin> @<gienah> - thanks, downloading
15:06:28 <lambdabot> Unknown command, try @list
15:06:40 <Cale> It's more an expression of a concern which can be dealt with and chopped up in many different ways, each with some advantages and disadvantages.
15:06:46 <starurchin> @gienah - thanks, downloading
15:06:47 <lambdabot> Unknown command, try @list
15:06:50 <mcstar> Cale: ralf laemmel posed a lot of 'open questions' in the end of his talk
15:07:07 <Ferdirand> @type (<$)
15:07:09 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
15:07:23 <mcstar> i had my hopes up, throughout the lecture, but got disappointed by the end
15:07:33 <CmrPantoufle> :t fmap fmap fmap
15:07:34 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
15:07:41 <CmrPantoufle> wow
15:07:47 <starurchin> gienah - thanks, downloading (and sorry for incompently yanking lambdabot's chain)
15:08:02 <Cale> mcstar: Well, you shouldn't be too disappointed. Sure, there's no such thing as a free lunch, but you can cut up the work you need to do in any way that you can imagine.
15:08:10 <beaky> > 3 <$ [1]
15:08:11 <lambdabot>   [3]
15:08:15 <fruitFly> so what are tools of functional languages like haskell other than functions? Like what are monads, maps and other constructs and do they provide higher order ways to organize functions?
15:08:16 <Necro> Hi guys! When doing a list like [3..5], does the second number have to be a number literal or can it be a variable?
15:08:35 <beaky> > let n = 5 in [3..n]
15:08:36 <lambdabot>   [3,4,5]
15:08:46 <beaky> it can be a variable :D
15:08:55 <merijn> Necro: Any variable of the appropriate type works
15:09:18 <mcstar> :t enumFromTo
15:09:19 <lambdabot> forall a. (Enum a) => a -> a -> [a]
15:09:20 <Cale> fruitFly: You just asked about 10 different questions, and I'm not sure which to answer.
15:09:23 <typoclass> > [7..] -- may even be absent
15:09:25 <lambdabot>   [7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32...
15:09:48 <Cale> fruitFly: There are lots of data structures other than functions which get used on a regular basis.
15:09:50 <Necro> > 2:[3,5 .. floor(50^0.5)]
15:09:51 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:09:52 <lambdabot>    `GHC.Real.Fractional t'
15:09:52 <lambdabot> ...
15:10:12 <mcstar> > 2:[3,5 .. floor(50^0.5)] :: [Int]
15:10:13 <Cale> fruitFly: Indeed, lists, sets, maps, various sorts of arrays and trees, all get used.
15:10:14 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:10:14 <lambdabot>    `GHC.Real.Fractional t'
15:10:14 <lambdabot> ...
15:10:25 <mcstar> :t (^)
15:10:27 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:10:34 <fruitFly> thanks cale:
15:10:40 <mcstar> :t (**)
15:10:41 <lambdabot> forall a. (Floating a) => a -> a -> a
15:10:43 <Cale> fruitFly: Are you familiar with type classes?
15:10:46 <mcstar> > 2:[3,5 .. floor(50**0.5)] :: [Int]
15:10:48 <lambdabot>   [2,3,5,7]
15:11:05 <Necro> mcstar: I don't understand the difference, but thank you
15:11:19 <mcstar> Necro: ** is for floating powers, not integral powers
15:11:20 <fruitFly> cale: yes, just finished that chapter. Should I move on to pattern matching or perhaps something else?
15:11:26 <typoclass> fruitFly: also, functions are surprisingly powerful. more complex things are avialable, but really, functions go a very long way
15:11:31 <Necro> mcstar: oh okay. thanks
15:11:35 <beaky> pattern matching ftw
15:11:39 <fruitFly> typoclass: Thanks
15:12:12 <Cale> fruitFly: Monad is a type class that collects together type constructors that support a particular API. We abstract over it, because it's pretty common (lots of libraries define something which happens to be a monad), and there are a bunch of useful things which can be defined for any monad. So the abstraction lets us define them once, and when we recognise that a new library can be made an instance of the class, it gi
15:12:12 <Cale> ves us lots of functionality for free.
15:12:25 <Cale> (I haven't said what exactly this API is)
15:12:48 <fruitFly> cale: eg of type construct?
15:12:52 <Cale> You can read about it in more detail here: http://www.haskell.org/haskellwiki/Monads_as_computation
15:13:08 <nicoo> Cale: Would @src Monad tell him ?
15:13:12 <nicoo> @src Monad
15:13:12 <lambdabot> class  Monad m  where
15:13:12 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:13:12 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:13:12 <lambdabot>     return      :: a -> m a
15:13:12 <lambdabot>     fail        :: String -> m a
15:13:22 <Cale> ignore the presence of fail there ;)
15:13:46 <mcstar> Cale: do you know ocaml?
15:13:53 <Cale> mcstar: To some extent
15:13:57 <Cale> mcstar: I haven't used it much
15:14:13 <mcstar> it has explicit open value constructors
15:14:24 <mcstar> like extendable sum types
15:14:37 <fruitFly> thanks guys!
15:14:42 <mcstar> i wonder if it makes things better or worse...
15:14:43 <nicoo> Polymorph variants
15:14:57 <nicoo> mcstar: They are quite usefull in lots of cases
15:15:01 <Cale> fruitFly: It's best to understand a bunch of things which happen to be monads before you start asking questions like what monads "are"
15:15:15 <nicoo> However, most of the time, you use plain old sum types
15:15:25 <starurchin> Thanks to everyone who pointed me at a cabal-install that works on GHC-7.6.1 - that was some impressively quick help!
15:15:30 <fruitFly> cale: right, hence why I'm continuing the lyah ciriculum
15:15:38 <Cale> fruitFly: For example, a lot of parsing libraries define a type constructor Parser such that Parser t is the type of parsers which eat some input and construct a result of type t.
15:15:47 <mcstar> nicoo: i cant really imagine how would you deal with unanticipated constructors...
15:16:14 <mcstar> with typeclasses, you just write a new instance declaration..., idk how that works in ocaml
15:16:19 <Cale> fruitFly: In addition to that, they'll typically have a way to define a parser which eats no input, but always succeeds, producing a given value. That is, a function  return :: t -> Parser t
15:16:51 <Necro> What's the comment symbol in haskell?
15:16:57 <Cale> fruitFly: and then in addition to that, they'll have a way to chain parsers together end-to-end, using the result of the first parser to determine which parser to run afterward
15:16:57 <mcstar> --
15:17:02 <mcstar> {-- }
15:17:04 <mcstar> {- -}
15:17:11 <Cale> fruitFly: which will be a function  Parser a -> (a -> Parser b) -> Parser b
15:17:32 <Cale> fruitFly: and that we call (>>=)
15:17:45 <mcstar> a well commented lua and haskell code can look pretty similar superficially
15:18:07 <Cale> fruitFly: any type constructor M for which we can define operations  return :: a -> M a  and  (>>=) :: M a -> (a -> M b) -> M b  we call a monad.
15:18:19 <Cale> fruitFly: (that is, the type constructor M is called a monad)
15:18:27 * hackagebot scrobble 0.2.1.0 - Scrobbling server.  http://hackage.haskell.org/package/scrobble-0.2.1.0 (ChrisDone)
15:18:35 <typoclass> Necro: it's "--" for a comment till end of line, and "{- ... -}" for multiline comments
15:18:55 <Cale> fruitFly: This pattern shows up a lot, and by giving it a name, we can reuse lots of code which is written in terms of return and (>>=) generally.
15:19:12 <nicoo> mcstar: In OCaml, you have to state that a given variant is polymorphic
15:19:16 <Cale> (all the things in the Control.Monad library)
15:19:37 <nicoo> So you know when you might get « unexpected » constructors
15:20:00 <nicoo> And the compile insults on incompletes pattern-matching
15:20:03 <mcstar> nicoo: can you give me a link to some resource?
15:20:05 <nicoo> compiler*
15:21:02 <fruitFly> cale: thanks.. I'll read more
15:21:17 <Cale> mcstar: Fundamentally, no matter what you do, you need to define all the operations for all the types of data.
15:21:42 <Cale> mcstar: so you have n*m work to do. It's just a matter of how you chop that up into modules.
15:21:47 <mcstar> Cale: except, for those that can be automatically derived
15:22:05 <Cale> Well, yeah, generics can solve the really boring cases of this
15:23:07 <nicoo> mcstar: http://caml.inria.fr/pub/docs/manual-ocaml/manual006.html#toc36
15:23:56 <fliip> Anyone have any idea which channel I could ask about pushdown automata?
15:24:43 <Cale> fliip: Might as well try here
15:24:44 <nicoo> mcstar: Be careful about the [< and [> in types; the second char denotes co/contra-variance
15:24:46 <ksf> fliip, if you don't find any specific one, #haskell is probably the best.
15:24:53 <Ralith> okay, trying to use the plot lib
15:24:59 <Ralith> got: *** Exception: user error (invalid matrix (not invertible))
15:25:14 <Ralith> when attempting to plot a simple Double -> Double function :/
15:25:23 <mcstar> Ralith: replace user
15:25:34 <mcstar> nicoo: ok, thanks
15:25:40 <Ralith> :P
15:25:42 <Ralith> oh, there's a NaN
15:25:58 <Ralith> that's a weirdass way of reporting it
15:26:14 <fliip> Ok, well I hope you dont mind if I ask here. I have a specification that states "Record the current input symbol in the finite control. For convenience call this symbol a"
15:26:17 <fliip> What does that mean?
15:26:39 <fliip> Pushdown automata related btw.
15:26:39 <nicoo> Ralith: Barfing on NaN-containing matrixes is waaaaay saner than what some "mathematical" languages do
15:27:03 <dmwit> It means in the text that follows, the letter "a" refers to whatever the current input symbol was.
15:27:11 <typoclass> nicoo: still, the message could be a little clearer than "invalid matrix (not invertible)"
15:27:22 <nicoo> typoclass: True.
15:28:10 <fliip> Oh ok thanks. Do I have to specify that then for the whole automata?
15:28:34 <fliip> so if say it reads 1, associate that with a, and if it reads 0 associate that with b?
15:28:38 <Ralith> nicoo: some "mathematical" languages are completely insane
15:28:39 <Ralith> :P
15:28:54 <dmwit> fliip: huh?
15:29:05 <dmwit> Whether it reads a 1 or a 0, we're calling that thing a.
15:29:15 <typoclass> fliip: i would expect that whatever you read (0 or 1), you then call it "a"
15:29:26 <nicoo> Ralith: I was thinking about MatLab, which lets you invert non-square matrices
15:29:34 <fliip> Im confused. Im not pushing/popping anything am I?
15:29:41 <typoclass> fliip: (however, i don't know what 'finite control' means in your quote)
15:29:47 <fliip> Nor do I.
15:29:56 <nicoo> typoclass: Nor do I
15:30:00 <fliip> I was assuming it meant the stack.
15:30:02 <Ralith> nicoo: yes, matlab's pretty screwy in my experience
15:30:04 <Ralith> maple too
15:30:45 <callen> okay, so I did `cabal install snap`, but I can't find snap *anywhere*
15:30:56 <callen> I ran my updatedb and locate and still couldn't find the snap binary.
15:31:10 <callen> it's not in my ~/.cabal/bin either. So uhhhh...
15:31:24 <nicoo> Actually, the only sane « math-oriented » language I saw is Julia, and it is heavily oriented towards numerical stuff
15:31:27 <nicoo> :°(
15:31:38 <callen> nicoo: Julia is immature for now though.
15:32:10 <typoclass> fliip: if you could quote a couple more sentences, i think people would understand it better. you could use hpaste.
15:32:14 <typoclass> @where hpaste
15:32:15 <lambdabot> http://hpaste.org/
15:32:22 <nicoo> callen: True; but it is quite nice already
15:32:43 <callen> nicoo: I just have a hard time imagining I could trust it for hardcore numerical work where performance matters.
15:32:56 <callen> for prototyping, the maturity of Python's NumPy and SciPy are better for now.
15:33:11 <callen> I sincerely hope Julia turns out well though, it'd save me a lot of hassle to not have to endlessly rewrite slow Python code.
15:33:49 <nicoo> callen: NumPy and SciPy are quite shitty, IMHO, and Julia allows for quite fast prototyping, in my experience
15:34:14 <mcstar> julia is closer to a lisp, and has a relatively badass type system + general functions
15:34:36 <mcstar> i am still pretty excited by it
15:34:38 <nicoo> mcstar: Indeed; I'm just unhappy about the more-or-less-dynamic typing
15:34:50 <mcstar> i hope they will manage to reduce startup time
15:34:53 <nicoo> And the typed macro system is a nice thing
15:35:04 <niteria> "Perhaps you haven't installed the profiling libraries for package `base'?" I've just enabled library profiling, deleted everything in .cabal except config and deleted everything in .ghc
15:35:31 <SLi> I must say that I prefer numpy and scipy to all similarly targeted systems I have tried, which I think would be {Matlab, Octave, R}.
15:35:41 <mcstar> nicoo: are you a numerical person, btw?
15:36:33 <mcstar> (i dont want to define that term, if you are, you will know you are :))
15:36:49 <nicoo> mcstar: I'm not at all
15:37:20 <nicoo> But I had to work on a project about convex optimization last year
15:37:56 <nicoo> I was pretty impressed that the first draft, in Julia, took less than 10 minutes and worked reasonably well
15:38:02 <SLi> But perhaps I should familiarize myself with julia. It's syntax doesn't look nice, though (which mostly reduces to "yet another syntax for numerical computing?").
15:38:24 <mcstar> it looks like matlab+lua i think
15:38:58 <nicoo> SLi: Well, the syntax is a bit weird
15:39:03 <ksf> why aren't there numerical libraries for haskell, btw?
15:39:06 <SLi> Not too familiar with lua; yes, it looks like matlab, and that's another reason to dislike it. Matlab is not a nice programming language IMO.
15:39:09 <mcstar> little more verbose than python, since it is not indentation aware
15:39:23 <ksf> if you want something to do, I'd say implement arbitrary-precision reals.
15:39:29 <patrickstarfish> is it possible to compare two IO Integer?
15:39:36 <mcstar> SLi: that is very superficial, dont dismiss it because of the 'looks'
15:39:58 <nicoo> SLi: MatLab, SciLab and friends were designed by computer ingeneers to turn numerician mads
15:40:01 <nicoo> mad*
15:40:03 <SLi> mcstar, I'm not dismissing the entire language, just the syntax. It's just obvious that it could use a better syntax :-)
15:40:07 <ksf> well, "arbitrary precision" meaning that you can say, for the result, "this has to be +-N correct" and then fast code is generated.
15:40:28 <nicoo> SLi: And static typing, typeclasses, monads ... oh, wait
15:40:52 <SLi> nicoo, not sure I would view them as central to numerical computing.
15:41:05 <mcstar> i had the idea to use haskell for numerical stuff, but that is just silly, it has better uses for its power
15:41:19 <SLi> But not every niche language should have a completely different syntax.
15:41:21 <nicoo> SLi: I was just kidding ;)
15:41:46 <nicoo> Though typeclasses to abstract over number representations is nice
15:42:07 <mcstar> another PITA is that im forced to use mathematica...
15:42:10 <ksf> mcstar, I once had the idea of using a chain saw to cut down a tree, but as I figured sculpuring was a cooler use for a chainsaw I fell the tree with a file.
15:42:26 <nicoo> mcstar: Having a powerful language for simple tasks isn't silly at all ;)
15:42:57 <mcstar> well, go ahead, but dont tell me i didnt warn you
15:43:47 <parcs`> patrickstarfish: liftM2 compare
15:44:08 <SLi> Actually that's one of the reasons why I like numpy. Python is a good enough programming language, and numpy provides fair numerical tools (though I wouldn't consider myself a numerical person either). Matlab provides good numerical tools with such a horrible language that when the numerical tools are inadequate, I suddenly want to stop considering the problem out of fear that I have to actually program something in matlab :-)
15:44:15 <nicoo> :t liftM2 compare
15:44:16 <lambdabot> forall a1 (m :: * -> *). (Ord a1, Monad m) => m a1 -> m a1 -> m Ordering
15:45:45 <mcstar> python is not good enough, it is useful, but not good enough
15:45:52 <mcstar> if it were, id be happy with it
15:46:30 <callen> so, nobody had any thoughts on where the hell my snap binary when when I `cabal install snap`'d it?
15:46:34 <callen> went*
15:46:44 <mcstar> thats why, people are excited with julia, because it brings some good ideas together, and they seem to work
15:46:50 <lightquake> https://github.com/jonsterling/Data.Records/blob/master/README.lhs what are your thoughts on this?
15:46:57 <ClaudiusMaximus> callen: ~/.cabal/bin
15:47:15 <SLi> Depends for what. Maybe static typing would be nice with n*m matrices to verify that your matrix dimensions are correct for the operations, but then that isn't easily doable in Haskell either.
15:47:17 <callen> ClaudiusMaximus: yeah uh, I said earlier that it doesn't exist.
15:47:27 <callen> .cabal just has config and something else.
15:47:31 <lightquake> callen: find ~ -iname snap ?
15:47:40 <callen> lightquake: tried that with locate/updatedb
15:48:05 <callen> lightquake: haha, that worked.
15:48:11 <lightquake> where'd it wind up?
15:48:11 <mcstar> SLi: if you can fit your problem into fast python primitives, you will have reasonable speed, but without a jit or some compilation, other codes will be slow
15:48:12 <callen> lightquake: It's in ~/Library/Haskell
15:48:15 <lightquake> … oh
15:48:18 <lightquake> you're on OS X
15:48:18 <callen> lightquake: yeah.
15:48:21 <callen> lightquake: yeah.
15:48:25 <callen> pain, horror, I know.
15:48:29 <lightquake> no i am too
15:48:44 <lightquake> but iirc that gets you a different ~/.cabal/config
15:49:33 <callen> lightquake: ...long as it works...
15:49:36 <lightquake> yeah
15:49:36 <SLi> mcstar, that's true. And it's probably not always easy for a non-computer-scientist person to invent the proper way to fit the problem into primitives (like making matrices with only 0s and 1s and using multiplication with them to do if/then/else kind of things). I agree.
15:51:49 * callen clippy the paperclip pops up from the depths
15:52:07 * callen hello there SLi! I see you're trying to avoid branching in your code with bit hacks. How can I help you?
15:52:28 <Ralith> hm, anyone know how to create a density plot using the plot package?
15:54:03 <Necro> Can someone help me fix this code? http://pastebin.com/RmV91En5
15:54:06 <mauke> The paste RmV91En5 has been copied to http://hpaste.org/76910
15:54:59 <callen> Necro: not to be pedantic, but your types are wrong.
15:55:26 <callen> Necro: when you encounter problems like this, you need to break it down.
15:55:53 <callen> Necro: you're taking Integer as an argument and returning a list of Integers, yet the first you're doing is producing something other than an Integer with sqrt.
15:56:06 <mcstar> > let x = 12 in [a | a <- 2:[3,5.. floor(sqrt(fromIntegral x))], x `mod` a == 0]
15:56:08 <lambdabot>   [2,3]
15:56:13 <callen> Necro: experiment in ghci and find out why the sqrt and floor stuff is bad mojo.
15:56:26 <callen> mcstar: sigh. don't give them the answer.
15:56:35 <callen> mcstar: let them figure out how to resolve their type problems.
15:56:36 <mcstar> he was asking for it
15:57:01 <ksf> floor . sqrt of an integer is a bad idea.
15:57:01 <callen> mcstar: if you give every child that asks for it a cupcake, you produce fat children, not children that know how to bake.
15:57:13 <mcstar> i like fat children
15:57:16 <mcstar> they are funny
15:57:21 <callen> mcstar: I like bakers.
15:57:24 <mcstar> i mean, they look funny
15:57:31 <callen> what, like the stay puft man?
15:57:35 <ksf> you won't get correct results above the precision of Double, anyway, so you can just use Double.
15:58:32 <fliip> Non-haskell related question, but hopefully someone can help me... Anyone have any idea how I create a pushdown automata for the language {a#b| a,b members of {0,1}^*, a != b}?
15:58:59 <mcstar> smells like a homework
15:59:15 <mcstar> callen: thats what i wont help with ^^
15:59:28 <callen> mcstar: I'm so glad you have standards.
15:59:33 <mcstar> XD
15:59:34 <fliip> I just need a pointer.
15:59:44 <callen> fliip: you need a pair of eyes with which to read.
15:59:46 <mcstar> void* ptr = NULL;
15:59:52 <callen> LOL
15:59:52 <fliip> That's rude...
15:59:58 <typoclass> callen: very helpful :-(
16:00:00 <callen> fliip: so is using void *.
16:00:24 <callen> fliip: I mena, we're really just talking about the CS nerd version of a stack, no?
16:00:30 <callen> mean*
16:01:03 <fliip> Yes, but I have no idea how to test that the two strings are different.
16:01:27 <fliip> You can push one onto the stack, but then its the wrong way around.
16:01:37 <td123> hi, i'm trying to use the aeson package to parse a json response, when I try to use decode on a long response, it returns Nothing, does anyone know how to get more information about the failure, maybe an error or something?
16:02:07 <callen> fliip: sorry, I only answer blue collar questions like td123's
16:02:20 <td123> yay
16:03:01 <callen> td123: hpaste a test case/repro.
16:03:16 <typoclass> fliip: try posting the problem description, and describe how far you got in understanding it, and where you're stuck. use hpaste if it's more than a couple sentences
16:03:31 <dmwit> td123: Don't celebrate yet. Being blue-collar is a necessary but not sufficient condition for callen to answer your question.
16:03:44 <callen> fliip: actually I'm going to take typoclass's recommendation one step further: everything you say should be an hpaste link.
16:03:48 <callen> dmwit understands me well.
16:04:10 <fliip> The algorithm doesnt make sense though.
16:04:24 <fliip> http://i46.tinypic.com/10mjuib.png
16:04:27 <dmwit> fliip: tricky question
16:04:27 <fliip> But there it is anyway.
16:04:42 <callen> td123: Nothing -> error "fail to parse via Aeson"
16:05:23 * lispy can't tell if the channel is hostile today or just lots of sacrasm
16:05:26 <rking> What are "functional data structures"? (Context: https://twitter.com/KentBeck/status/262581228161617922  Note: I don't know any FP stuff)
16:05:35 <callen> lispy: not insanely hostile, just playful.\
16:05:49 <typoclass> lispy: i don't think there's really a difference :-( it certainly is low-quality today
16:05:56 <callen> rking: Okasaki, Hickey, Datomic
16:05:57 <fliip> lol
16:06:52 <callen> rking: roughly speaking, they really mean persistent data structures that don't mutate in general terms. There's a pretty big overlap in interest in persistent data structures and pure functional programming languages.
16:06:55 <dmwit> fliip: That's a pretty clever solution. =)
16:07:05 <dmwit> Okay, if you have that, then what's the question?
16:07:10 <fliip> You understand it?
16:07:14 <dmwit> yes
16:07:15 <fliip> Whats the "finite control"?
16:07:28 <dmwit> You know have PDA's have a state?
16:07:29 <dmwit> That.
16:07:44 <fliip> I know they can have many states, yes.
16:07:46 <callen> rking: http://en.wikipedia.org/wiki/Persistent_data_structure
16:08:00 <callen> fliip: perhaps even infinite states...
16:08:04 <dmwit> callen: no
16:08:09 <dmwit> finitely many
16:08:09 <rking> callen: So… hrm. Thanks.
16:08:13 <fliip> Haha.
16:08:16 <dmwit> Or else it's not a PDA.
16:08:16 <callen> rking: what do you want to know?
16:08:22 <callen> dmwit: you're not imaginative enough.
16:08:32 <niteria> persistent > functional
16:08:45 <niteria> where > is set inclusion
16:08:53 <dmwit> callen: You can have other kinds of automata that have infinitely many states, but they're not PDAs.
16:08:58 <rking> callen: Well, I guess I'm struggling to see why it's important. I know this is naïve, but I can get immutable data by not mutating things. ☺
16:08:59 <fliip> Sorry, so yes, is "a" a state?
16:09:19 <callen> rking: it's about structure.
16:09:45 <callen> rking: sure, you can "simply not mutate things", but if you want to efficiently insert keys into a hash-map, naively returning a new hash-map everytime isn't very efficient.
16:09:52 <rwbarton> fliip: the state is a combination of where we are in that algorithm and the symbol we remembered
16:10:00 <dmwit> fliip: No, "a" is not a state.
16:10:03 <flonum> seems like virthualenv/hsenv/cabal-dev aren't buildable with ghc 7.6.n -- any suggestions ? try to build from a github fork or what ??
16:10:04 <hpaste> td123 pasted “callen's request for aeson snippet” at http://hpaste.org/76911
16:10:09 <callen> rking: stuff like PDS/Okasaki is designed to make those modes of interaction efficient and to also solve some of the burgeoning problems in scaling up data structures for concurrency.
16:10:22 <td123> callen: ^
16:10:27 <callen> td123: what and that breaks?
16:10:42 * callen fiddles
16:10:48 <td123> no, it works
16:10:55 <frio> flonum: I didn't realise there were more tools than just cabal-dev. Are virthualenv/hsenv any better?
16:11:01 <callen> td123: I asked for a repro :(
16:11:01 <td123> the problem is that it doesn't print out any reason for why the decoding failed
16:11:24 <callen> rking: but hey, if you want to keep returning newly instantiated hash-maps every time you insert a key, that's your business.
16:11:31 <frio> td123: your JSON string is missing object2
16:11:36 <td123> i know
16:11:39 <frio> you've said object2 is a String, not a Maybe String
16:11:41 <frio> so it won't parse
16:11:53 <frio> that string isn't an instance of the data structure you've described :)
16:12:02 <fliip> dmwit, so how does it record the current input symbol in the "finite control"?
16:12:42 <flonum> frio: I haven't used cabal-dev, but the other two (hsenv is virthualenv's successor) weren't building ... they are super easy to set up; cabal-dev might be more configurable, not sure
16:12:46 <td123> so my question is if anyone knew if there was a way to make aeson spit out some kind of error about why it gave me Nothing
16:13:06 <niteria> fliip: just do a product of algorithm step and a symbol, like (2, "a")
16:13:07 <rking> callen: Well, I wouldn't do that. I would just change the table. I'm just trying to understand what adding this functionality to Smalltalk would look like. Perhaps I first have to understand Haskell or similar.
16:13:33 <dmwit> fliip: Suppose you had a (finite) set of states where you couldn't record an input symbol.
16:13:40 <frio> ah, i see td123
16:13:41 <typoclass> rking: in principle yes, you can just "not mutate" and have something immutable. but it still may be beneficial to have the language or the data structure ensure immutability. i guess it's similar to saying "java has a keyword 'private' to hide a method, yes you could just 'not call' methods if you want them private, but it's still a good double-check if the compiler enforces it"
16:13:46 <callen> rking: I don't know anything about Smalltalk. Not really. I'm principally familiar with the strengths of persistent data structures as it relates to Java, Clojure, Haskell, and C++
16:13:53 <callen> rking: they happen to be insanely useful.
16:13:57 <fliip> Right.
16:13:58 <frio> td123: in my experience, no, there isn't
16:14:00 <dmwit> fliip: I could easily construct a new (still finite) set of states the following way: the elements of the new set are tuples of a state from the old set and an input symbol.
16:14:03 <callen> typoclass: we're a little bit beyond that.
16:14:08 <frio> but i could very well be wrong
16:14:14 <dmwit> fliip: Since there's finitely many input symbols, this results in a new finite set.
16:14:30 <dmwit> fliip: Now, I have a set of states that has all the old information it used to have plus some new information: one input symbol.
16:14:34 <dmwit> QED?
16:14:47 <td123> frio: hmm, if a value could be null I probably have to make it a Maybe
16:14:59 <frio> yes td123 :)
16:15:05 <td123> ah, that might be the problem
16:15:29 <fliip> ffs.
16:15:43 <rking> typoclass: Well, in that particular case, I have no particular fondness for protected/private except for their benefit of being able to sort a method list by likelihood of interest to the outside classes. In Ruby I do .send :something_i_should_not_be_calling from time to time, and it's an important backdoor for me.
16:15:50 <fliip> Sorry, my brain isnt working.
16:16:00 <beaky> @pl \x -> x*x
16:16:00 <lambdabot> join (*)
16:16:02 <callen> rking: whoa, no, don't talk to him.
16:16:08 <callen> rking: he's giving you the stupid people java programmer answer.
16:16:21 <callen> typoclass: stoppit. he's a smalltalker.
16:16:22 <rwbarton> rip #haskell
16:16:33 <niteria> fliip: do you know how to make a DFA that accepts when last two letters are "ab"?
16:16:37 <beaky> :t join
16:16:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:16:42 <hpaste> Marzhall annotated “Taking the Tree out of IO” with “Taking the Tree out of IO (annotation) (annotation)” at http://hpaste.org/76900#a76912
16:16:44 <callen> rking: it has nothing to do with programming semantics or how you structure data access.
16:16:45 <rking> callen: I know Java/C++ well enough that I can relate to the explanation from that perspective. In a similar vein to the protected/private keyword, I found 'const' to be handy for communicating intent but irritating when it came to practical matters (such as debugging)
16:16:45 <beaky> @src monad
16:16:46 <lambdabot> Source not found. Maybe you made a typo?
16:16:48 <dmwit> fliip: I'm not sure how to interpret that. Was what I said helpful or not? If not, I will try again.
16:16:49 <fliip> Yes.
16:16:51 <beaky> @src join
16:16:51 <lambdabot> join x =  x >>= id
16:16:58 <shachaf> What happened to #haskell?
16:17:06 <callen> rking: it has nothing to do with private/protected.
16:17:10 <fliip> I dont want to be a pain. If you've exmaplined it's my fauly for not understanding. lol
16:17:10 <callen> nothing. at. all.
16:17:22 <rking> callen: So that's what I'm trying to understand, what immutability does in the FP world beyond what const does in C/C++/Java
16:17:25 <dmwit> Not understanding can be the fault of bad teaching as well.
16:17:33 <nicoo> shachaf: What do you mean ?
16:17:33 <callen> rking: if you read a bit from that wikipedia page I linked you, that would help a lot.
16:17:33 <dmwit> Maybe even s/can be/usually is/
16:17:35 <rking> callen: Yeah, I just meant that comparison in that they're both language features that restrict what can be done.
16:17:47 <callen> rking: alternately, look into the problems of making data structures that are well-suited to concurrent programming.
16:17:54 <shachaf> nicoo: I don't know!
16:17:55 <niteria> fliip: so you can make one that accepts when last n letters are some particular string, right?
16:17:57 <ksf> rking, it is related to "static final", though.
16:18:00 <dmwit> fliip: It's getting a bit noisy in here, though; let's move to #haskell-overflow.
16:18:02 <callen> rking: work on Software Transactional Memory is relevant as well.
16:18:06 <ksf> ...or just final.
16:18:07 <callen> ksf: no. it's. not.
16:18:10 <callen> ksf: please just stop.
16:18:15 <osfameron> rking: its very different from consts
16:18:24 <callen> you guys are distracting him with stuff that doesn't matter. PDS has nothing to do with how you structure your code specifically.
16:18:34 <beaky> http://ideone.com/x32Iuz why is my algoithm incorrect?
16:18:50 <ksf> well, it *is* more related to final than public or private.
16:18:57 <callen> it's not related to ANY of those things
16:19:09 <callen> for the love of god, it has nothing to do with something as petty as property/data protection.
16:19:24 <osfameron> rking: if you shift the number 1 onto the list [2,3] you get [1,2,3].  In a mutable structure, you'd have 1 list with [1,2,3], whereas in immutable structures, you'd still have [2,3] as it's immutable (if you want it)
16:19:26 <marzhallo> Okay, so, I played around with trying to create a sequence function, went on a long and existential journey of reading LYAH, and made some bacon, but I couldn't quite get the concept. So I figured I'd add an 'M' to the end of my map function and see if that could help me, but I'm still pretty stuck. So, how do I get the types to play well when trying to use a recursive function that plays around in the IO mon
16:19:29 <callen> PDSs are about structuring data for modes of access that are often advantageous in languages that are pure and also for concurrency.
16:19:47 <ezyang> Hey #haskell, please don't distribute widely, but if you've got any heap profiles lying around you'd like visualized sometime in the near future, can you upload them here? http://heap.ezyang.com/
16:19:52 <rking> osfameron: Yeah, I was trying to understand http://en.wikipedia.org/wiki/Persistent_data_structure#Linked_lists which sounds similar
16:19:52 <niteria> is this http://projects.haskell.org/haskellmode-vim/ the latest and greatest haskellmode?
16:19:57 <ezyang> Tell me if anything breaks. The app doesn't really do anything yet.
16:20:01 <typoclass> callen: i'd appreciate it if you could stick to the facts a little more (describe *why* in your opinion it's not relating to data protection, etc., instead of just making claims) and do a little less bullying
16:20:04 <callen> ezyang: it 500'd
16:20:14 <callen> typoclass: I was trying to get him to read the wikipedia page on the subject
16:20:23 <callen> which would've answered all his questions. Then you idiots distracted him.
16:20:28 <callen> and turned it into a bikeshedding exercise
16:20:32 <rwbarton> shachaf: Have you figured it out yet?
16:20:32 <typoclass> @where ops
16:20:32 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
16:20:33 <callen> when it could've been about the specific subject at hand.
16:20:40 <osfameron> rking: yeah.  lists are the easiest data structure to get your head around the differences between mutable and immutable structures
16:20:45 <ezyang> callen: aight, try again
16:20:51 <dibblego> typoclass ?
16:20:56 <osfameron> rking: but it doesn't really start to make sense about why it's *useful* until you look at trees
16:20:57 <callen> ezyang: seems to be up again. Cool stuff!
16:21:01 <typoclass> callen: in my opinion it's not acceptable to call people idiots
16:21:04 <Cale> typoclass: what?
16:21:06 <shachaf> rwbarton: Nope, lots of scrollback to read.
16:21:16 <callen> typoclass: it's not acceptable to turn a conversation about data structures into a pointless flamewar.
16:21:18 <ezyang> My first Yesod app \o/
16:21:31 <callen> typoclass: you literally shat all over what could've been a cool opportunity to introduce somebody to Okasaki's work
16:21:35 <shachaf> Unless I'm missing something...
16:21:47 <mcstar> ezyang: i got failure
16:21:48 <callen> typoclass: and turned it into HURRR OOP PRIVATE PROTECTED
16:21:49 <mauke> callen: ok, I can tolerate "idiots". but misusing "literally"?
16:21:52 <mauke> wtf, dude
16:21:59 <callen> mauke: figuratively shat all over.
16:22:00 <rwbarton> well, you can just read the past 2 minutes or so
16:22:00 <ezyang> mcstar: What kind of failure
16:22:02 <callen> mauke: happy?
16:22:04 <mauke> better
16:22:07 <osfameron> mauke: you got your 'e' back!
16:22:09 <mcstar> As a protection against cross-site request forgery attacks, please confirm your form submission.
16:22:14 <mcstar> ezyang:
16:22:19 <shachaf> ezyang: Hah, is that why you were asking about UTF-8?
16:22:25 <ezyang> shachaf: Yes ^.^
16:22:28 <td123> uh, aeson still fails to parse, I  searched and only found 1 null
16:22:31 <ezyang> mcstar: Huh.
16:22:38 <ezyang> mcstar: Refresh the form submission page and try again
16:22:40 <callen> mcstar: <input type="hidden" name="_token"
16:22:53 <callen> mcstar: it didn't like your CSRF token. for some reason.
16:22:57 <osfameron> rking: callen is also right that okasaki's stuff is really interesting
16:22:59 <typoclass> dibblego, Cale: thanks for responding, i think callen's tone is not appropriate for #haskell, i'd appreciate it if you could warn him about that. if you wish, i can hpaste the irc log of his messages that i specifically have a problem with
16:23:08 <osfameron> ... it's also quite *hard* if you've not done maths or Comp Sci recently
16:23:11 <osfameron> (at least, I found it hard)
16:23:12 <rking> I think I understand part of it, but it seems to me like the operations on the data structures could just opt to copy or not and achieve the same thing. (Again back to the "I can get immutability by just not mutating things")
16:23:16 <typoclass> (it's from the last few minutes)
16:23:24 <rking> osfameron: Good tip
16:23:28 * osfameron is meaning to write a "Functional data structures for dynamic language programmers" book
16:23:57 <osfameron> rking: so, if you want to *undo*.  Go back from one version of a dictionary to the previous one...
16:24:01 <shachaf> rwbarton: I must be imssing something.
16:24:03 <callen> rking: copying sucks and is inefficient, and making that work in concurrent modes of access without locks also sucks.
16:24:24 <callen> rking: PDS are incredibly useful for making lock-free data structures for which you can have many writers/readers operating on the same data efficiently without locks.
16:24:38 <callen> rking: these are useful things in any context or programming language where those properties are useful.
16:24:41 <osfameron> rking: just not mutating things doesn't get you very far.  Everything useful requires new things.  otherwise you'd switch the computer on and it'd sit there, not doing anything.
16:24:44 <rking> callen: But that link says that it copied the 'xs' stuff.
16:24:54 <callen> rking: that was an example of a trivial way to implement PDS
16:25:00 <rking> (BBIAB, will read backlog)
16:25:07 <callen> rking: please don't take trivial examples as some indication of the entirety of a field of research.
16:25:28 <callen> just because most programming language books start with hello world doesn't mean printing strings is the only thing you can do.
16:25:29 <mcstar> ezyang: i must be doing something wrong, same error, is it worth my trouble? XD
16:25:36 <osfameron> rking: you'll always have to copy *something*.  in the case of dictionaries, you end up having to copy about log n of the data for most changes (which is much less than copying *all* of it)
16:25:50 <callen> osfameron: not really...
16:26:02 <ezyang> OK, I'll investigate your bug some. Can you PM your session key?
16:26:20 <callen> mcstar: what web browser are you using?
16:26:25 <ezyang> also, can you go to http://scripts.mit.edu , scroll to the bottom, and tell me "You are currently connected to ____"?
16:26:42 <osfameron> callen: of trees?  well, it depends on exactly what you change.  It's something along those lines on average though, no?
16:26:46 * osfameron handwaves wildly
16:26:59 <osfameron> (I did mention I found this stuff hard ;-)
16:27:02 <callen> osfameron: you have to understand your audience.
16:27:35 <callen> osfameron: you cannot describe it as merely copying everything or boiling down to copy-on-write semantics. The goal is to get them to seek a deeper understanding not to dismiss it as being trivial in their current mode of thought.
16:27:43 <callen> osfameron: it's a failure in communication, not summarization.
16:27:55 <osfameron> callen: oddly, I'm not sure I understand *you* ;-)
16:27:58 <mcstar> ezyang: miracle-cure.mit.edu
16:28:13 <callen> osfameron: no point. Just take what I say for granted.
16:28:31 <callen> ezyang: miracle-cure.mit.edu.
16:28:41 <ezyang> callen: OK, please try submitting once more
16:28:48 <ezyang> Remember to refresh the homepage before clicking submit
16:29:20 <callen> ezyang: I'm not having a problem, I'm just providing more data.
16:29:26 <callen> ezyang: mcstar has the problem, sorry for the confusion.
16:29:28 <mauke> heh
16:29:33 <mcstar> i dont have a problem
16:29:40 <callen> mcstar: you have a lot of problems.
16:29:40 <td123> wow found my mistake, one of the definitions had a list of types but instead it should just be 1 type
16:29:44 <mcstar> just tested that webapp for curtesy
16:29:50 <td123> that was highly annoying to debug
16:29:50 <callen> courtesy
16:29:58 <mcstar> callen: exquize me?
16:30:05 <callen> mcstar: exsqueeze me?
16:30:10 <callen> td123: OTOH, it would've been worse had you simply misunderstood the program.
16:30:18 <ezyang> mcstar: I saw your attempt in th elogs
16:30:22 <osfameron> callen: rking noted that a lot of list manipulations require a load of copying.  That's why I mentioned trees, as they are much more interesting from that point of view.
16:30:29 <ezyang> uhh, yeah, I have no idea
16:30:37 <callen> osfameron: trees are a good place for a discussion about PDS to go.
16:30:59 <callen> rking: Datomic couldn't exist without PDS.
16:31:02 <mcstar> i dont particularly like this tone of voice
16:31:09 <osfameron> what's datomic?
16:31:12 <mcstar> and it is late, so gn
16:31:17 <callen> :(
16:31:20 <callen> osfameron: a database.
16:33:55 <twopoint718> Sorry if this is wide-ranging, but I see this common pattern: I have function that takes a lot of parameters. What's an idiomatically-functional way to reduce that number?
16:35:10 <osfameron> combinators?
16:35:26 <typoclass> twopoint718: you could group the parameters in a record or similar data structure, or you could use a Reader. (also, you could use implicit parameters which are available through a compiler extension)
16:35:49 <osfameron> twopoint718: might be helpful to give an example of such a function?
16:36:38 <frio> it can also be a sign that you're doing too much in your function, and could consider breaking some parts of it into their own functions
16:36:58 <shachaf> ezyang: Your first Yesod app? What do you think of the language?
16:37:48 <twopoint718> osfameron: I was afraid you'd ask that. I'm just trying to figure out what's the spiritual equivalent of making an argument to a method into an instance variable.
16:38:15 <osfameron> twopoint718: you're wanting to think of a function as a kind of OO class?
16:38:46 <osfameron> twopoint718: typoclass's suggestion of using a record probably applies
16:38:52 <dibblego> twopoint718: a data structure with the reader monad
16:39:05 <osfameron> typoclass: but probably decomposing the problem space into combinators may get you further
16:39:19 <ezyang> "heh language"
16:39:28 <ezyang> It's not as type safe as Ur/Web. Being in Haskell is nice.
16:39:37 <ezyang> Deployment is still a bitch
16:39:40 <osfameron> e.g. try to think about it differently (which is the whole point of picking up a functional language in the first place, right?)
16:39:45 <osfameron> ur/Web?
16:39:52 <callen> osfameron: http://www.impredicative.com/ur/
16:40:08 <callen> osfameron: awww yeeaahhh, just discovered this cool new thing called google.
16:40:57 <twopoint718> Oh yes, I consider myself "on the bandwagon", I am actually writing a blog post and I was trying to think of the functional equivalent of a refactoring that I do quite a bit in ruby.
16:41:22 <dibblego> twopoint718: equational reasoning
16:41:28 <osfameron> twopoint718: so you *do* have an example piece of code you're thinking of, then?
16:41:33 <dibblego> (which you also do in ruby, to some extent)
16:41:51 <callen> twopoint718: I find that most abstractions and refactoring are something that happen progressively in functional languages, especially Haskell. As a result, without a specific instance to be resolved, it's hard to recommend a solution
16:42:03 <callen> the answer really is often to break down the function into smaller smarts.
16:42:08 <callen> parts. I meant parts.
16:42:09 <twopoint718> No example yet, I was going to go off and read something. I have been looking at the reader monad just based on some SO questions and answers.
16:42:28 <callen> twopoint718: it might be better to just try building something and see how it shakes out, rather than vague conjecture as to what you'll need.
16:42:49 <callen> the sort of thing you're talking about isn't something I run into very often. When it does, record types, decomposition, maps, are often though.
16:42:52 <callen> enough*
16:42:57 <callen> today is not my day for typing.
16:43:00 <twopoint718> callen: I realized that the first step. Just like in an OO language lots of arguments usually means "doing too much"
16:43:08 <osfameron> twopoint718: mjd has an example in Higher Order Perl of taking a web spider (OO class) and turning it into a series of functions which can be applied together to give the same behaviour as the (much more complicated, yet less flexible) object class
16:43:09 <twopoint718> s/that/that's/
16:43:25 <callen> osfameron: Higher Order Perl is *great*
16:43:27 <osfameron> twopoint718: might be interesting to read, I'm guessing you can at least read Perl, if you program in Ruby
16:43:38 <callen> osfameron: not a safe assumption.
16:43:45 <callen> Perl has some idiosyncratic syntax.
16:43:50 <osfameron> true, and vice versa
16:43:51 <callen> it's a bigger blocker than you think.
16:43:55 <osfameron> I found it hard to read Ruby, for example
16:43:56 <callen> nah, Ruby isn't that hard to read.
16:44:01 <Refried__> Hey, what's the V in IterV?
16:44:01 <osfameron> but mjd's examples are quite clear
16:44:02 <dibblego> twopoint718: "lots of arguments" is solved the same way with a record type. What you can with the reader monad is "pass that read-only context around implicitly", for which some people use funny things like "dependency injection" and other silly ideas
16:44:03 <callen> osfameron: we are very different, you and I.
16:44:34 <osfameron> callen: *shrug*, I found ruby (and python) hard to read.  Now that I've worked with them a bit, I find them less hard to read.  Who'da thought
16:44:45 <callen> osfameron: I've spent a lot of time in Python, that may have some bearing.
16:45:05 <hvr> @pl \x -> if x then "true" else "false"
16:45:05 <lambdabot> flip (flip if' "true") "false"
16:45:06 <osfameron> python is quite nice to write, actually
16:45:16 <twopoint718> I *much* prefer haskell for readability over Ruby, but Ruby is the audience that I'm trying to reach :)
16:45:18 <callen> is there a light-weight web framework for Haskell like Sinatra? I find that Yesod is in its own little world and Warp/Happstack are bewildering.
16:45:27 <osfameron> I find the installation infrastructure a pain, but I'm prepared to believe that's my inexperience
16:45:31 <osfameron> callen: Snap maybe?
16:45:34 <flonum> callen: Scotty ?
16:45:50 <callen> osfameron: I'm looking into Snap but still seems too big. Scotty might be the way to go.
16:45:54 <callen> flonum: have you used Scotty?
16:45:59 <frio> <3 scotty
16:46:09 * osfameron hasn't heard of scotty
16:46:13 <frio> scotty's great
16:46:15 <callen> osfameron: https://github.com/xich/scotty
16:46:17 <flonum> callen: not really, I just remembered it was Sinatra-inspired and the examples seem easy to read
16:46:25 <callen> osfameron: once again, my powers of Googling are the victor.
16:47:20 <frio> it gets out of your way, which is great
16:47:33 <osfameron> ah, "WAI Application interface" sounds like plack/rack/etc.
16:47:38 <osfameron> at least, that code looks like it
16:48:03 <osfameron> the yesod / ur/web stuff looks theoretically very interesting, but quite a lot of work
16:48:06 <frio> but it's worth keeping in mind that, like sinatra/bottle/etc., it doesn't roll in all the Big Boy Framework stuff like some form of ORM, form validation, built-in utilities like user manage, etc.
16:48:10 <frio> *management
16:49:20 <frio> get "/blog/entries/:year/:month/:slug" $ \ year month slug -> (html . Entry.render . Entry.retrieve) year month slug
16:49:27 <twopoint718> Thanks for the pointers all and sorry to be so vague. I was trying to blog first, and JIT my examples. :)
16:49:28 <typoclass> Refried__: hello, where is IterV defined? do you have a link to a package?
16:49:42 <ezyang> osfameron: Yeah, but it's a very well integrated environment
16:49:54 <frio> so, yeah, scotty for simple sites or as a basic routing DSL is quite cool. for more advanced stuff, you'
16:50:00 <frio> ll probably want a bigger framework
16:50:16 <osfameron> ezyang: sure
16:50:47 <callen> frio: you'd be surprised.
16:51:02 <callen> frio: I've gotten a lot of work done in Python with Flask. Previously I'd used Django.
16:52:07 <osfameron> I've done a fair chunk of upgrading legacy CGI code in Perl to pure Plack (equiv of rack/wsgi/wai)
16:52:24 <callen> osfameron: surprisingly refreshing, no?
16:52:43 <osfameron> yeah.  lots of fun.  though once you've reimplemented a few wheels the novelty wears off a little ;-)
16:52:48 <callen> although Flask is a bit higher up the abstraction pyramid. It's on top of werkzeug which is on top of WSGI.
16:53:03 <callen> osfameron: Flask is really a proper framework though, not an equivalent to Plack.
16:53:12 <osfameron> yeah
16:54:40 <patrickstarfish> is it possible to call print on something of type IO Integer?
16:54:47 <mauke> no
16:54:53 <mauke> @src print
16:54:53 <lambdabot> print x = putStrLn (show x)
16:54:56 <mauke> :t show
16:54:57 <lambdabot> forall a. (Show a) => a -> String
16:55:04 <typoclass> patrickstarfish: you probably want "print =<< the_io_integer"
16:55:04 <mauke> there's no Show instance for IO a
16:55:51 <tac_> patrickstarfish: you can use "do" syntax to get an Integer out of an IO integer
16:55:54 <tac_> do
16:56:00 <tac_>   x <- myIOIntThing
16:56:02 <dibblego> tac_: you can't actually
16:56:02 <tac_>   print x
16:56:16 <tac_> dibblego: if you hadn't interrupted my code, that code would work
16:56:34 <dmwit> You can use "do" syntax to turn a continuation expecting an Integer into a continuation expecting an IO Integer.
16:56:39 <dibblego> you can use do notation to pass a closure on the integer
16:56:41 <dmwit> You cannot use "do" syntax to get an Integer out of an IO Integer.
16:56:48 <dibblego> you cannot use do notation to get an Integer out of an IO Integer
16:57:02 <mauke> you can use do notation to pretend to get an Integer out of an IO Integer
16:57:03 <osfameron> lambdabot: stereo?
16:57:12 <mauke> at the cost of being trapped in IO yourself
16:57:18 <osfameron> bah
16:57:18 <tac_> Don't get bogged down in the details, dibblego.
16:57:34 <dibblego> tac_: this is not a detail, it is extremely important both in practice and for the purpose of learning
16:57:36 <tac_> You need an Int to play with, you can get an Int to play with.
16:57:40 <dibblego> No.
16:57:59 <dibblego> this is wrong pedagogically, theoretically and practically
16:58:00 <osfameron> dibblego: you're right.  but tac_'s answer was probably what patrickstarfish needed to know
16:58:02 <frio> callen: flask provides a lot more than scotty does, and the plugin ecosystem for it is great :)
16:58:04 <callen> sidebar: this is hilarious.
16:58:07 <dibblego> osfameron: sure
16:58:14 <callen> frio: I'm not surprised. Flask is great.
16:58:31 <beaky> :t (***)
16:58:32 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:58:46 <dmwit> osfameron: disagree; the code tac_ posted was what patrickstarfish needed, but the sentence prefacing it made the answer as a whole misleading
16:58:49 <beaky> when is Control.Arrow.*** useful?
16:58:53 <typoclass> dibblego: what do you think of the way mauke described it?
16:58:54 <patrickstarfish> thanks
16:59:02 <dibblego> yes and the code that was posted had already been posted
16:59:08 <callen> beaky: when you're a three-star programmer.
16:59:12 <dibblego> typoclass: mauke's answer is direct and correct
16:59:19 <osfameron> callen: heh
16:59:30 <callen> ooh, someone knows the reference.
16:59:30 <tac_> who the heck even uses =<< ? >_____>
16:59:37 <dibblego> lots of people, lots of the time
16:59:41 <beaky> lol
16:59:54 <dmwit> (=<<) makes a lot more sense to me as a primitive than (>>=) does.
16:59:54 <tac_> lol
16:59:59 <callen> http://c2.com/cgi/wiki?ThreeStarProgrammer
17:00:01 <dibblego> dmwit: again, we agree
17:00:03 <beaky> I use 3 starts in C
17:00:05 <beaky> 3 stars*
17:00:06 <dmwit> (=<<) turns an (a -> m b) into an (m a -> m b)
17:00:08 <dibblego> (=<<) has the arguments around the right way at least!
17:00:12 <typoclass> > (pred, succ) *** (3,7) -- beaky, here's an example
17:00:13 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
17:00:13 <lambdabot>    arising from a use of `Control...
17:00:18 <beaky> > show =<< "Foo"
17:00:20 <lambdabot>   "'F''o''o'"
17:00:23 <dmwit> > (pred *** succ) (3,7)
17:00:23 <typoclass> urgh sorry
17:00:25 <lambdabot>   (2,8)
17:00:30 <typoclass> yes ^^
17:00:51 <typoclass> thanks dmwit
17:00:51 <beaky> :t pred
17:00:52 <lambdabot> forall a. (Enum a) => a -> a
17:01:01 <typoclass> > pred 6
17:01:03 <lambdabot>   5
17:01:08 <mauke> :t [(>>=), flip concatMap]
17:01:09 <lambdabot> forall a b. [[a] -> (a -> [b]) -> [b]]
17:01:11 <dmwit> beaky: It's useful when you have two pieces of data, and two functions to run (one on each piece).
17:01:15 <beaky> ah
17:01:37 <beaky> what if I have n pieces of data, and n functions to run on them?
17:01:40 <mauke> > (show *** sqrt) ('x', 2)
17:01:41 <dmwit> s/functions/arrows/ in general, but I don't think I've ever seen it used with any arrow other than (->)
17:01:42 <lambdabot>   ("'x'",1.4142135623730951)
17:01:50 <osfameron> obviously (\(a,b) ->  (pred a, succ b)) would just be horrible
17:01:50 <mauke> beaky: zipWith id
17:01:55 <beaky> ah
17:01:59 <dmwit> beaky: more (***), obviously ;-)
17:02:04 <dibblego> dmwit: (***) can run on non-arrows though :)
17:02:21 <hpaste> Marzhall annotated “Taking the Tree out of IO” with “Taking the Tree out of IO (annotation) (annotation) (annotation)” at http://hpaste.org/76900#a76914
17:02:23 <beaky> Arrows seem really neat
17:02:33 <dibblego> http://hackage.haskell.org/packages/archive/data-lens/2.10.2/doc/html/Control-Category-Product.html
17:04:03 <beaky> > map (pred *** succ) [(x,y)|x <- [1..10], y <- [1..10]]
17:04:05 <lambdabot>   [(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(0,11),(1,2),(1,3),...
17:04:18 <dmwit> The longer I keep learning, the less I think Arrow is really neat and the more I think it was a sort of ad-hoc creation.
17:04:45 <osfameron> what do Arrows actually *mean*?
17:04:46 <beaky> so arrow is actually something basic?
17:04:55 <osfameron> as opposed to the "something cool with tuples!" thing
17:05:07 <dmwit> Arrow is a generalization of functions.
17:05:18 <beaky> arrows are like a bijection between sets of objects
17:05:28 <dmwit> It is not the only reasonable generalization, and there are other, more principled ones lying around various places.
17:05:55 <osfameron> what does that have to do with (***) ?
17:06:22 <dmwit> (***) is one of the operations you expect to be able to do on "function-like" objects: you expect to be able to run them in parallel on the two halves of a tuple.
17:06:27 <dibblego> Arrow gives rise to (***) but there are also many structures with (***) that are not arrows
17:07:08 <dmwit> FSVO "you"
17:07:17 <cornihilio> how does haskell compare to ada?
17:07:30 <cornihilio> in terms of the compiler making sure it is safe
17:07:37 <cornihilio> code*
17:07:52 <beaky> Ada is unsafe since it lets you perform side-effects
17:08:09 <dmwit> cornihilio: Google suggests http://haskell.cs.yale.edu/?post_type=publication&p=366
17:08:12 <beaky> on the other-hand, Haskell is purely-functional and disallows such effects in code.
17:08:21 <osfameron> yeah, but haskell doesn't have a Military Standard Reference!
17:11:21 <typoclass> (this question might be stupid) is there anything like an arrow but containing three things? or is the "2" built in and unchangeable?
17:11:44 <dmwit> What do you mean by "containing"?
17:12:07 <dmwit> Are you asking about the kind of the parameter to the Arrow type class or the number of arguments to (***) and friends?
17:12:41 <typoclass> i mean, Arrow famously has an instance for (,). would an instance for (,,) make any sense?
17:12:52 <typoclass> (i suspect not, btw)
17:12:59 <dibblego> there is no instance for (,)
17:12:59 <dmwit> Arrow does not have an instance for (,).
17:13:09 <callen> typoclass: anything is possible in math-magic land!
17:13:28 <clahey> So, I may have missed something, but wouldn't multiple *** give you operations over ((a, b), c) ?
17:13:30 <typoclass> > (pred &&& succ) 6 -- what instance is this using?
17:13:31 <lambdabot>   (5,7)
17:13:33 <dmwit> :t pure -- because WTF would you do for pure
17:13:35 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
17:13:41 <dmwit> typoclass: It is using the (->) instance.
17:13:44 <dmwit> clahey: yes
17:13:55 <cornihilio> dmwit: thank you for that link!
17:14:21 <osfameron> what other instances of Arrow are there?
17:14:28 <dibblego> Monad m => Kleisli m
17:14:28 <dmwit> Hm, what is the Arrow equivalent of pure called?
17:14:31 <dibblego> arr
17:14:35 <rwbarton> @arr
17:14:35 <lambdabot> Drink up, me 'earties
17:14:39 <beaky> > ((+1) *** (+2) *** (+3)) (0,0,0)
17:14:40 <lambdabot>   Couldn't match expected type `(b, (a, a1))'
17:14:40 <lambdabot>         against inferred type `...
17:14:41 <dmwit> ?instances Arrow
17:14:42 <lambdabot> (->), Kleisli m
17:14:44 <beaky> :(
17:14:51 <beaky> what's a Kleisli?
17:14:53 <typoclass> ah right, sorry i was mixing up the front and the back. what came *out* of the (&&&) is a 2-tuple
17:15:07 <dmwit> osfameron: I would guess relations are arrows; there's an automaton arrow; there's a parsing arrow which does static analysis of the grammar.
17:15:23 <dmwit> beaky: roughly, type Kleisli m a b = a -> m b
17:15:36 <typoclass> thanks for explaining even though my question was borked
17:15:40 <dmwit> beaky: And the instance is actually instance Monad m => Arrow (Kleisli m), not just plain instance Arrow (Kleisli m).
17:16:41 <osfameron> dmwit: interesting instances
17:16:48 <dmwit> > ((+1) *** (+2) *** (+3)) (0,(0,0))
17:16:49 <lambdabot>   (1,(2,3))
17:17:08 <typoclass> :t (&&&)
17:17:10 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:17:15 <beaky> > ((+1) &&& (+2)) 0
17:17:16 <lambdabot>   (1,2)
17:18:04 <beaky> map ((+1) &&& (+2)) [1..10]
17:18:08 <beaky> > map ((+1) &&& (+2)) [1..10]
17:18:09 <lambdabot>   [(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12)]
17:18:19 <beaky> :D
17:18:38 <typoclass> to answer my own question, no, (c, c') is obviously a 2-tuple, the type is fixed, and you'd need to define your own (&&&&) or whatever that's that gives a 3-tuple, and lives outside Control.Arrow
17:18:39 <beaky> are arrows related to monads?
17:19:01 <Eduard_Munteanu> beaky: yes, they're more general than monads.
17:19:05 <beaky> :( wish there was an arrow composition operator that would let you do that thing
17:19:38 <dylukes> beaky: A monad is just a monoid in the category of endofunctors…
17:19:42 <Eduard_Munteanu> beaky: all monads are arrows (via Kleisli), but not the other way around.
17:20:19 <beaky> as I learn more haskell everyday that monoid in the category of endofunctors makes more sense ^^
17:20:38 <dmwit> :t \f g h -> (f &&& g &&& h) >>> \(a,(b,c)) -> (a,b,c)
17:20:40 <lambdabot> forall a c c1 c'. (a -> c) -> (a -> c1) -> (a -> c') -> a -> (c, c1, c')
17:20:50 <dmwit> uh
17:20:52 <dmwit> not quite =P
17:20:55 <rwbarton> arr
17:21:02 <Eduard_Munteanu> @arr
17:21:02 <lambdabot> Yeh scurvy dog...
17:21:04 <beaky> :t (>>>)
17:21:05 <shachaf> arrwbarton
17:21:05 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
17:21:05 <dmwit> ah
17:21:12 <shachaf> arrwbarrton?
17:21:13 <beaky> what's >>>?
17:21:18 <Eduard_Munteanu> Heh.
17:21:22 <dmwit> :t \f g h -> (id &&& h) >>> ((f &&& g) *** h)
17:21:24 <lambdabot> forall a c c'. (a -> c) -> (a -> c') -> (a -> a) -> a -> ((c, c'), a)
17:21:35 <ksf> beaky, (.), but for categories.
17:21:36 <Eduard_Munteanu> beaky: it's a general flipped composition operator.
17:21:47 <Eduard_Munteanu> :t (>>>)
17:21:48 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
17:22:03 <beaky> ah
17:22:11 <dmwit> :t \f g h -> (id &&& h) >>> ((f &&& g) *** id)
17:22:12 <lambdabot> forall a c' c c'1. (a -> c) -> (a -> c'1) -> (a -> c') -> a -> ((c, c'1), c')
17:22:22 <Eduard_Munteanu> You get (>=>) if you replace cat by Kleisli m for some m, or flip (.) for cat = (->)
17:22:33 <dmwit> Where is this getting specialized? =/
17:22:38 <Eduard_Munteanu> :t (>=>)
17:22:39 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:22:53 <dmwit> Oh, id.
17:23:27 <rwbarton> :t \f g h -> (f &&& g &&& h) >>> arr (\(a,(b,c)) -> (a,b,c))
17:23:28 <lambdabot> forall (cat :: * -> * -> *) a c c1 c'. (Arrow cat) => cat a c -> cat a c1 -> cat a c' -> cat a (c, c1, c')
17:23:43 <dmwit> Dang, a few seconds too slow. I was typing the exact same thing. =P
17:24:07 <beaky> what does arr do?
17:24:10 <beaky> :t arr
17:24:11 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
17:24:14 <shachaf> @help arr
17:24:15 <lambdabot> arr. Talk to a pirate
17:24:22 <beaky> lol
17:24:31 <beaky> seems arr just turns a function into an arrow
17:24:34 <dmwit> ?arr you ready to go to the dance with me
17:24:35 <lambdabot> Yeh scurvy dog...
17:24:39 <dmwit> =(
17:24:42 <callen> LOL
17:24:54 <Eduard_Munteanu> Yes, it lifts an arrow in Hask to an arrow in that arrow category.
17:25:05 <beaky> Hask?
17:25:23 <dmwit> Hask: the category whose objects are Haskell types and whose morphisms are Haskell functions
17:25:24 <Eduard_Munteanu> The category of Haskell types and functions.
17:25:51 <beaky> ah
17:25:51 <dmwit> With a bit of blurry eyes to the fact that (a -> b) is both an object and the type of a morphism.
17:27:06 <Eduard_Munteanu> @src Category
17:27:07 <lambdabot> Source not found. stty: unknown mode: doofus
17:27:31 <Nereid> beaky: somewhat analogous to "return" for monads...
17:28:17 <Nereid> in fact, arr f = return . f when the arrow is the kleisli category for a monad.
17:28:42 <Nereid> (i.e. a b c = b -> m c)
17:35:41 <callen> By the way, emacs' "fill-region" is pretty heavenly.
17:35:48 <callen> especially when you're editing latex.
17:41:48 <Nereid> vim can do the same thing, with fewer keystrokes :v
17:57:39 <callen> Nereid: shunnn the unbeliever shunnnn
17:57:58 <Nereid> :V
18:00:13 <marzhallo> how would I go about doing that fancy "show me the source" thing with lambdabot?
18:00:22 <ivanm> @src maybe
18:00:22 <lambdabot> maybe n _ Nothing  = n
18:00:23 <lambdabot> maybe _ f (Just x) = f x
18:00:25 <shachaf> marzhallo: /msg lambdabot @src foo
18:00:26 <ivanm> marzhallo: ^^
18:01:08 <marzhallo> @src Data.Tree::drawTree
18:01:08 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:01:16 <marzhallo> awww, he's mean
18:01:36 <ivanm> she
18:01:40 <ivanm> lambdabot is female
18:01:51 <marzhallo> @src Data.Tree.drawTree
18:01:51 <lambdabot> Source not found. My brain just exploded
18:01:58 <ivanm> also, lambdabot only has a predefined DB of source definitions; she doesn't look up actual GHC sources :)
18:02:05 <marzhallo> well, I killed her, so it's no issue now
18:02:07 <ivanm> @index Data.Tree
18:02:07 <lambdabot> bzzt
18:02:15 <ivanm> @hackage containers
18:02:15 <lambdabot> http://hackage.haskell.org/package/containers
18:02:19 <ivanm> marzhallo: ^^ look them up :)
18:02:34 <typoclass> marzhallo: it's not very fancy though, it's really just a plaintext file. you can click the "source" link that is present next to all functions (see hackage)
18:02:39 <shachaf> marzhallo: lambdabot won't find most sources.
18:02:44 <shachaf> Learn how to find them yourself. :-)
18:02:48 <ivanm> in case you weren't aware, I just uploaded pretty-tree to hackage the other day to get prettier trees :)
18:02:49 <shachaf> Useful skill.
18:03:00 <marzhallo> haha, I'm lookin already
18:03:06 <marzhallo> just thought I'd try it the cool way first
18:03:09 * ivanm is currently tweaking it and about to upload a newer version with some slight improvements
18:03:31 <dibblego> is (<<=) :: ([a] -> b) -> [a] -> [b] in the base library?
18:03:50 <dibblego> (tails then map)
18:03:56 <ivanm> I don't think so
18:04:01 <ivanm> map f . tails ?
18:04:05 <dibblego> yeah
18:04:19 <Eduard_Munteanu> dibblego: don't use that symbol, edwardk uses it for 'extend' for comonads ;)
18:04:21 <Cale> Yeah, that's not there, just write map f . tails
18:04:25 <dibblego> Eduard_Munteanu: that is extend
18:04:29 <ivanm> unless you can do something fancy with one of the scan functions, I doubt it ;)
18:04:31 <dibblego> tails is cojoin, but wondering about the extend
18:04:40 <dibblego> coolo, will use tails
18:04:45 <Eduard_Munteanu> Oh, hrm, I didn't actually look.
18:04:58 <edwardk> Eduard_Munteanu: the operator in question is an actual extension ;)
18:05:08 <edwardk> dibblego: and no, its not.
18:05:13 <dibblego> s/cojoin/duplicate
18:05:21 <dibblego> edwardk: ?
18:05:35 <edwardk> its not quite tails because you need to keep the list of lists the same length
18:05:48 <edwardk> so the operation you get when you use fmap and tails is wrong
18:05:56 <dibblego> wait a minute
18:06:00 <edwardk> so its pretty much nowhere, except in semigroupoids
18:06:03 <tibbe> Anyone know how to run a process and send both stdout and stderr to the same handle?
18:06:18 <dibblego> ok I seem to have a broken assumption somewhere deep down
18:06:26 <edwardk> dibblego: ?
18:06:27 <rwbarton> "foo 2>&1"? or in haskell?
18:06:47 <hpc> tibbe: pass the same handle as stdout and stderr with readProcess or whatever
18:06:48 <edwardk> dibblego: did you assume it was like tails?
18:06:48 <dibblego> edwardk: "no it's not" — you mean \f → map f . tails is not extend?
18:06:56 <edwardk> nope
18:06:58 <dibblego> yeah I always thought tails was the [] comonad
18:06:58 <tibbe> hpc: does that actually work?
18:06:59 <edwardk> its not
18:07:02 <dibblego> er extend
18:07:05 <edwardk> > tails [1,2,3]
18:07:06 <lambdabot>   [[1,2,3],[2,3],[3],[]]
18:07:20 <edwardk> note that that took a _3_ element list and gave you a _4_ element list?
18:07:29 <edwardk> you need to drop the , []] on the end
18:07:35 <ivanm> edwardk: so init . tails ?
18:07:35 <edwardk> > init (tails [1,2,3])
18:07:37 <lambdabot>   [[1,2,3],[2,3],[3]]
18:07:39 <edwardk> yep
18:07:45 <edwardk> now you're more comonadic ;)
18:07:48 <edwardk> > init (tails [])
18:07:49 <ivanm> tibbe: I believe some of the functions in System.Process do that
18:07:49 <lambdabot>   []
18:07:52 <edwardk> there ya go
18:07:53 <dibblego> well blimey you're right
18:08:02 <rwbarton> now you're cooking with comonads
18:08:02 <edwardk> you can prove the associativity law on that
18:08:21 <edwardk> the one in semigroupoids is that thing, not fmapped tails
18:08:22 <hpc> tibbe: it should work
18:08:24 <tibbe> ivanm: ok, I was under the impression that it didn't, will try
18:08:28 <tibbe> ivanm: hpc: thanks
18:08:32 <callen> "now you're cooking with comonads" <--- I need to put this on my "overheard" twitter.
18:08:55 <hpc> callen: the sequel to "now you're oking with monads" ;)
18:09:01 <Eduard_Munteanu> Make sure you're oking with monads, OTOH.
18:09:05 <Eduard_Munteanu> Heh.
18:09:56 <ivanm> tibbe: I recall that one of the simpler ones combined the outputs so I had to switch to the more detailed variant to prevent that
18:10:09 <tibbe> ivanm: ok, that's useful to know
18:13:09 <tibbe> ivanm: remember which one?
18:14:09 <ivanm> IIRC, it was of type ` String -> IO String ' (that is, it returned stdout + stderr)
18:18:16 <fengshaun> hi all, how can I delete one occurrence of an item from a list?  (\\) seems to delete all instances!
18:18:32 <ivanm> delete
18:18:41 <ivanm> > delete 1 [1,2,3,1]
18:18:41 <fengshaun> thanks
18:18:42 <lambdabot>   [2,3,1]
18:18:51 <ivanm> though \\ only deletes the first value as well, unless it's changed...
18:18:57 <ivanm> > [1,2,3,1] \\ [1]
18:18:58 <lambdabot>   [2,3,1]
18:19:03 <fengshaun> oh
18:19:07 <ivanm> (which I actually find annoying :s)
18:19:20 <fengshaun> I probably misinterpretted what hoogle said!
18:19:21 <ivanm> if you do want to delete all occurrences, use filter
18:19:29 <fengshaun> ivan, yea, that one's easy
18:19:44 <fengshaun> ivan, what do you mean "unless it's changed"?
18:20:13 <ivanm> well, I didn't recall anyone proposing to change the semantics of how \\ worked, but I suppose it was possible :)
18:20:22 <ivanm> or you might be using some kind of alternate Prelude or something
18:20:34 <fengshaun> oh, in that sense
18:20:58 <fengshaun> thanks
18:21:40 <callen> Not in scope: `delete'
18:22:22 <callen> have to import Data.List, how odd.
18:22:24 <fengshaun> callen, Data.List
18:22:43 <callen> fengshaun: yeah, I'm starting to wonder what lambdabot's env looks like.
18:22:55 <fengshaun> f.a
18:22:56 <fengshaun> yea*
18:24:50 <tibbe> ivanm: me real problem seems to be that I need to create a pipe first, which I can't do in a portable fashion
18:24:58 <ivanm> ugh
18:26:03 <ivanm> I don't suppose unix-compat has anything like that in there?
18:26:06 <fengshaun> are there any indenting guidelines (best practices) for haskell?
18:26:26 <fengshaun> I'm often tripped on making the code look decent when I have to use 'when', 'let', 'case' and such expressions
18:27:12 <jfischoff> is there an existing 3d mesh library on Hackage? Perhaps using Data.Vector or Repa?
18:33:08 <tibbe> ivanm: nethier unix-compat or Win32 provides ways to create pipes
18:33:40 <ivanm> oh, hooray :s
18:38:12 <Cale> fengshaun: http://urchin.earth.li/~ian/style/haskell.html has some very uncontroversial style guidelines, but perhaps doesn't quite specify as much as you want
18:38:42 <Cale> fengshaun: the basic idea is that things which are siblings ought to be vertically aligned, and things which are inside other things ought to start in a deeper column
18:38:54 <Cale> (apart from the stuff in that guide)
18:39:22 <Petit_Dejeuner__> reading the last of a list takes O(n), right?
18:39:46 <dibblego> last traverses the list yes
18:44:34 <joeyh> funny, I manage to disagree with almost every line of those guidelines :) For one thing, it mixes tabs and spaces for indentation, and then uses that to argue that tabs for intendation don't work. No: mixed tabs+spaces don't work.
18:46:04 <typoclass> Petit_Dejeuner__: yes it's O(n), but that will (probably) only play a role if your n is very very big
18:46:08 <Cale> joeyh: So you're suggesting just-tabs is reasonable?
18:46:18 <Cale> joeyh: It doesn't quite work as well for Haskell.
18:46:35 <joeyh> Yes. However, I'll admit to being heretical. (I have 30 thousand lines of code in which it works just fine)
18:46:53 <joeyh> let .. in  is the only place it falls on its face. Luckily, we have where
18:47:02 <rwbarton> then you need to always put a newline after case/let/of/where
18:47:06 <joeyh> yep
18:47:07 <rwbarton> and do
18:47:12 <rwbarton> -case
18:47:15 <Cale> Yeah, nobody else is going to enjoy working on that code without converting it to spaces for you :)
18:47:18 <rwbarton> I knew it was four!
18:47:58 <mauke> I use "tab indentation" in my code too
18:48:06 <Cale> I personally think tab characters should be considered lexical errors
18:48:09 <mauke> it just so happens that it's built from spaces
18:48:15 <Cale> heh
18:48:24 <joeyh> so do a few modules I've found on hackage, which is the only reason I now state my opinion at all ..
18:48:53 <dmwit> Mixed tab and spaces can work if you're consistent.
18:49:05 * dmwit uses mixed tabs and spaces to deal with let ... in ...
18:49:11 <Cale> dmwit: Seriously?
18:49:14 <beaky> anyone here use Xmonad?
18:49:16 <dmwit> Seriously.
18:49:21 <guidj0s> ski: 'You there?
18:49:22 <Cale> dmwit: Why not just use spaces?
18:49:23 <rwbarton> what if you have a let ... in ... within a let ... in ...
18:49:33 <dmwit> Cale: Because spaces don't change width according to the preferences of the viewer.
18:49:36 <rwbarton> or nest some other layout construct in between
18:49:50 <dmwit> rwbarton: hpaste a sample you think would be hard, and I'll hpaste the way I would do it.
18:49:51 <mauke> what's the problem with let/in?
18:49:59 <dmwit> That seems like the easiest way to handle these challenges.
18:50:11 <Cale> dmwit: What if the viewer's preferences (like mine) are to see the code as its author wrote it?
18:50:13 <dmwit> I'll use the literal string \t instead of a tab, to make it easy to see.
18:50:24 <joeyh> dmwit: it can work if you consistently put the spaces after the tabs, but then you're not using spaces for indentation, but for layout
18:50:28 <rwbarton> let me see first if i understand, tabs to indent any construct except four spaces to indent a let block?
18:50:31 <joeyh> um, layout in the non-haskell sense
18:50:40 <dmwit> Cale: Ask the author. =) But if the author is doing it correctly, you *will* see it as its author wrote it.
18:50:40 <mauke> dmwit: viewer preferences only work if the language has "indentation levels" that can be adjusted to any width you like
18:50:44 <mauke> Haskell doesn't
18:50:59 <Cale> dmwit: No I won't, because there's no way to tell how the author had their editor configured.
18:51:26 <mauke> Haskell is all about making things line up with other things, not indenting things N levels
18:51:30 <dmwit> The only thing my proposal *doesn't* handle is aligning things on two lines of differing indentation levels (which you shouldn't want to do anyway).
18:51:37 <Cale> Whereas if everyone uses spaces, the result is unambiguous, and any work that the author put into lining things up and making the code lexically pretty will be reflected accurately.
18:51:43 <joeyh> hmm, I thought haskell was all about typed lambda calculus :)
18:51:49 <dmwit> Cale: My proposal does not break alignment.
18:51:52 <seliopou> Cale: modline magic
18:52:00 <dmwit> Cale: Seriously, show me something and I'll show you how to make it tab-width agnostic.
18:52:12 <dmwit> Cale: (Again, barring things that are aligned on two lines of different indentation levels.)
18:52:23 <seliopou> what if everybody used tabs?
18:52:27 <seliopou> wouldn't that be just as good?
18:52:38 <otters> no
18:52:40 <mauke> seliopou: no
18:52:43 <otters> because github displays tabs as 8 spaces
18:52:43 <seliopou> y
18:52:49 <geekosaur> seliopou, a tab is aligned to 8 spaces on unix'
18:52:50 <otters> which is honestly abominable
18:52:50 <seliopou> that's an issue of rendering
18:52:57 <Cale> It would be less flexible with respect to the available alignment levels.
18:53:00 <otters> yeah, and usually when you read code, it's rendered
18:53:01 <dmwit> Tabs for indentation, spaces for alignment. It works, baby.
18:53:02 <seliopou> and decisions like that shouldn't hinge on how github does it
18:53:14 <Cale> You could only align anything to a multiple of 8 spaces then.
18:53:15 <geekosaur> it's a render of people's editors/displays doing the same thing so the code is comprehensible
18:53:16 <otters> seliopou: github can be substituted for any other user tool
18:53:18 <mauke> dmwit: in that case you shouldn't use any tabs in haskell
18:53:26 <mauke> because haskell is all alignment, no indentation
18:53:27 <seliopou> otters: most others are configurable by the user
18:53:40 <dmwit> mauke: I respectfully disagree.
18:53:40 <otters> but with spaces, they don't need to be
18:53:43 <mauke> seliopou: that only makes it worse
18:53:43 <Cale> If it were up to me, GHC would outright reject any program with tab characters in it.
18:53:44 <otters> that's the point
18:53:53 <seliopou> mauke: users of tabs would disagree
18:54:00 <seliopou> (I use spaces myself, but I understand their argument)
18:54:05 <mauke> seliopou: they're wrong
18:54:07 <dmwit> There are many places where indentation is commonly used in Haskell code.
18:54:10 <seliopou> mauke: it means that if you use tabs, people can render it however they want
18:54:12 <Cale> I think the world would be better off if tab characters had never existed.
18:54:15 <mauke> seliopou: not in haskell
18:54:15 <seliopou> mauke: thanks for declaring that
18:54:16 <seliopou> helpful
18:54:29 <joeyh> Cale: well, Hamlet already does..
18:54:31 <dmwit> Cale: No, the real problem is that people treat tabs as some number of spaces. If tabs and spaces had incomparable width, everything would be fine.
18:54:32 <callen> tabs are dumb and only dumb people like them.
18:54:52 <hpaste> rwbarton pasted “indentation” at http://hpaste.org/76925
18:54:53 <Cale> dmwit: There's no need for two incomparable types of whitespace
18:54:53 <callen> dmwit: so what you're saying...is that assuming tabs are equivalent to spaces...is a type error?
18:55:01 <mauke> seliopou: thanks for generalizing to all "users of tabs" :-)
18:55:06 <rwbarton> dmwit, this is just intended to be a very easy example for me to understand what you mean
18:55:11 <Cale> dmwit: at least, horizontally.
18:55:14 * joeyh generalizes all people who makes statements like callen's
18:55:21 <Cale> We also don't need vertical tabs
18:55:27 <Cale> but that's less controversial somehow
18:55:40 <Eduard_Munteanu> Nobody uses tabs correctly.
18:55:46 <dmwit> rwbarton: This sample would have no tabs.
18:55:47 <Eduard_Munteanu> (or rarely, anyway)
18:55:48 * tac-tics doesn't understand why tabs exist in 2012
18:55:51 <guidj0s> Cale: Is there a v-tab key, anywhere?
18:55:53 <tac-tics> (or \r for that matter)
18:55:57 <rwbarton> i see
18:56:09 <seliopou> tac-tics: ever used a typewriter?
18:56:12 <beaky> tabs used to be important in the old days
18:56:15 <Cale> guidj0s: you could bind one, but it's a pretty unpopular character
18:56:15 <beaky> or something
18:56:17 <tac-tics> seliopou: NOPE! :D
18:56:19 <dmwit> rwbarton: (Because no matter where you put a tab, I could choose a tab width which broke that choice.)
18:56:20 <davesque> is there a show function for rational numbers that outputs a more human-readable version? ex: goodShow (5 % 7) == "5/7" -or- goodShow (2 % 1) == "2"?
18:56:28 <hpaste> mauke annotated “indentation” with “indentation (annotation)” at http://hpaste.org/76925#a76926
18:56:31 <beaky> even more useless is capslock :D
18:56:40 <seliopou> tac-tics: the carriage return's very important in that context
18:56:42 <Eduard_Munteanu> For instance, in certain C coding styles, they mix tabs and spaces to line up things. They also assume they're 8 spaces wide.
18:56:44 <beaky> and even more useless than capslock is scrolllock :D
18:56:58 <dmwit> mauke: This sample could have tabs, if you wished. Would you like me to annotate with how I would do it, or was that a facetious sample?
18:57:09 <Cale> davesque: Well, it's not hard to write one, I don't know if there is one handy.
18:57:21 <mauke> dmwit: huh? that example has tabs
18:57:22 <seliopou> is somebody arguing that you can't properly align haskell code (so it compiles) using just tabs?
18:57:34 <mauke> seliopou: no
18:57:41 <seliopou> mauke: good
18:57:42 <Eduard_Munteanu> beaky: not really, scroll lock had a reasonably good purpose
18:57:44 <guidj0s> Cale: It not existing is probably why there's no controverse over \v.
18:57:45 <dmwit> mauke: Yes, the sample is tab-correct. =)
18:58:02 <Cale> seliopou: You can always do it, but you end up writing things that look awful
18:58:10 <davesque> Cale: okay...seemed like a common thing that would be done so figured there might be a prelude function
18:58:12 <rwbarton> so basically you use tab when you are setting the starting column for a block on a new line
18:58:14 <Cale> seliopou: and you make anyone who has to work on your code hate you
18:58:17 <dmwit> mauke: (Though not very pretty. =)
18:58:20 <seliopou> Cale: do you adjust how tabs are rendered in your editor?
18:58:27 <mauke> dmwit: that's kind of the point
18:58:30 <rwbarton> and spaces when you are aligning to the column set after a layout keyword, dmwit?
18:58:32 <seliopou> Cale: Anybody who doesn't use tabs
18:58:35 <Eduard_Munteanu> Cale: actually such a style might come in handy if you're forcing yourself to use proportional fonts
18:58:38 <dmwit> rwbarton: Actually, you might use it in other situations. I'll show you a funny example.
18:58:38 <Cale> seliopou: Yes. They show up in bright red.
18:58:53 <seliopou> Cale: lol, you know what I mean
18:58:56 <seliopou> (I do the same)
18:58:59 <ezyang> And here's an example of a visualized graph. Needs some important bits, like labels for regions ^_^ http://heap.ezyang.com/view/3545fa9f556ef12b5210e864d5a62a16926d7bb8#form
18:59:06 <Eduard_Munteanu> Cale: if you do that, you can't really count on aligning things vertically at all.
18:59:26 <Eduard_Munteanu> Or maybe you can, but you're not the one who should do it.
18:59:35 <typoclass> ezyang: sweet animations! :-O
18:59:43 <mauke> Eduard_Munteanu: tabs aren't a good solution to that problem
18:59:55 <Cale> Eduard_Munteanu: The only sensible way to do that is to have additional structure which can't really be encoded by ASCII or as far as I know Unicode.
18:59:58 <hpaste> dmwit annotated “indentation” with “indentation (annotation)” at http://hpaste.org/76925#a76927
19:00:01 <shachaf> Those transition animations really clarify the, uh, thing.
19:00:03 <ezyang> typoclass: I'm particularly proud of the overlayed area -> stacked graph one :-) (I cribbed the other two off of some d3.js samples)
19:00:13 <dmwit> rwbarton: for example
19:00:14 <Eduard_Munteanu> mauke: yeah, I'm not saying that, it's just using tabs requires some of the same precautions you'd take with proportional fonts.
19:00:21 <Cale> Eduard_Munteanu: I guess you could have the code stored with semicolons and braces and have your editor display it in a proportional font with nice layout.
19:00:31 <seliopou> Also, for vim users out there: http://vim.wikia.com/wiki/Modeline_magic
19:00:34 <rwbarton> right
19:00:38 <dmwit> rwbarton: But your rule of thumb is pretty much right, yeah.
19:00:54 <mauke> dmwit: yeah, that is about the point where I'd say "fuck it"
19:00:55 <Eduard_Munteanu> Cale: well, the compiler might be in a better position to layout your code (just as Agda takes care of highlighting)
19:00:58 <dmwit> rwbarton: The "spaces to align to the column after a layout keyword" I would tweak to be restricted to when the block starts on the same line as the keyword.
19:01:22 <rwbarton> yeah, i mean "after on the same line"
19:01:25 <dmwit> right
19:01:34 <Cale> Eduard_Munteanu: Yeah, if you wanted to do that right, you'd definitely want to give way to automatic structural editing/layout.
19:01:35 <ezyang> Eventually, you'll be able to add annotations to it, and filter, and...
19:01:36 <rwbarton> do you have your tabs set to a fixed width?
19:01:48 <Eduard_Munteanu> I should look into structural editors sometime.
19:01:51 <Cale> Eduard_Munteanu: Have you seen any of Chris Done's recent YouTube videos?
19:01:59 <dmwit> rwbarton: I do, but only because I haven't found an editor that can do something else.
19:02:00 <typoclass> ezyang: does the order of the areas mean anything? i mean, is it possible to (say) put the orange area on top without changing the meaning of the, er, thing?
19:02:09 <rwbarton> I mean as opposed to "next multiple of 8"
19:02:09 <Eduard_Munteanu> Cale: Hm, no, any particular video?
19:02:14 <dmwit> rwbarton: Ah, no.
19:02:16 <rwbarton> which I'm sure you can find an editor that does!
19:02:19 <Cale> https://www.youtube.com/user/ChristopherDone/videos?flow=grid&view=0
19:02:26 <ezyang> typoclass: Yeah, definitely. Ordering right now is just "sort by max"
19:02:27 <rwbarton> gotcha
19:02:30 <dmwit> rwbarton: I have them set to "next multiple of 4".
19:02:45 <Cale> They're not terribly exciting videos, but you can get the idea from any one of them.
19:02:49 <dmwit> I'd love to find a vim plugin that implements elastic tabstops. ;-)
19:02:57 <Cale> (the Structural Editing for Haskell ones)
19:03:29 <Cale> Though he's using Haskell-src-exts' prettyprinter, and it screws up the layout of if/then/else pretty badly.
19:03:36 <Eduard_Munteanu> I see.
19:03:53 <rwbarton> there was that gedit plugin some time back
19:03:55 <Cale> (but that's an easy bug to fix)
19:04:50 <davesque> i seem to remember there is a way to declare a copy of a type for the purpose of overriding instance declarations of it...is that correct?
19:04:50 <Eduard_Munteanu> Hrmpf... it makes me wonder, is vimscript really that bad, or why is it this sort of stuff gets implemented only in Emacs? :(
19:05:00 <dmwit> davesque: Yes, "newtype".
19:05:14 <dmwit> vimscript is really that bad
19:05:18 <Eduard_Munteanu> Well, Lisp being more of a programming language might have something to do with it, I suppose.
19:05:40 <davesque> dmwit: ahh...so i could do something like "newtype HRational = Rational" "instance Show HRational..."?
19:06:02 <dmwit> davesque: Almost, except that, like "data", your type needs a constructor.
19:06:11 <dmwit> e.g. newtype HRational = HRational Rational
19:06:19 <Eduard_Munteanu> I should really try one of those Vim emulation modes for Emacs one more time.
19:06:51 <davesque> dmwit: ahh, right.  thx!
19:08:59 <typoclass> ezyang: i had some vague idea that it might be clearest if the areas that change the least are in the middle, and the areas that are all over the place are at the very top and bottom, so that they don't unnecessarily push around others. (could have sworn i saw a blog post on that, but can't find it atm)
19:10:01 <ezyang> typoclass: Yeah, that sounds plausible
19:10:11 <ezyang> Or, for a streamgraph, you want those in the center
19:10:50 <typoclass> ezyang: yes, for stream it's middle, for stacked it's bottom :)
19:10:56 <ezyang> do you know how hp2ps sorts?
19:11:56 <fengshaun> how can I find whether a String is inside another String? (finding a substring)
19:12:05 <fengshaun> :t breakSubstring
19:12:07 <lambdabot> Not in scope: `breakSubstring'
19:12:11 <typoclass> > "ca" `isInfixOf` "lolcat"
19:12:12 <lambdabot>   True
19:12:16 <typoclass> fengshaun: ^^
19:12:16 <ezyang> @hoogle String -> String -> String
19:12:16 <lambdabot> System.FilePath.Windows (<.>) :: FilePath -> String -> FilePath
19:12:17 <lambdabot> System.FilePath.Posix (<.>) :: FilePath -> String -> FilePath
19:12:17 <lambdabot> System.FilePath.Windows addExtension :: FilePath -> String -> FilePath
19:12:18 <fengshaun> breakSubstring doesn't...
19:12:25 <fengshaun> thanks!
19:12:42 <fengshaun> I was gonna say breakSring works with ByteStrings
19:13:16 <typoclass> ezyang: no idea, sorry
19:16:36 <fengshaun> thanks for the link on haskell style Cale!
19:32:58 <niteria> @pl (\x y z -> y (x z))
19:32:59 <lambdabot> flip (.)
19:33:08 <niteria> @pl (\x y z -> x (y z))
19:33:08 <lambdabot> (.)
19:41:44 <shapr> callen: be nice
19:43:32 * hackagebot gluturtle 0.0.56 - turtle like LOGO with glut  http://hackage.haskell.org/package/gluturtle-0.0.56 (YoshikuniJujo)
19:43:34 * hackagebot haskell-modbus 0.2 - A haskell implementation of the Modbus protocol  http://hackage.haskell.org/package/haskell-modbus-0.2 (JasonHickner)
19:43:36 * byorgey -> bed
19:43:58 <byorgey> well, this isn't the channel I meant to say that in, but in any case, goodnight all =)
19:44:14 <ezyang> gnight
19:50:50 <amathew> ap3pm6974a
19:50:57 <amathew> lkjdf
19:52:06 <thoughtpolice> @seen conal
19:52:06 <lambdabot> Unknown command, try @list
19:52:17 <thoughtpolice> hm, i wonder where preflex is
19:52:18 <conal> thoughtpolice: hi
19:52:56 <thoughtpolice> conal: hi! i remember i mentioned hsenv to you the other day. i actually got around to merging some pull requests in a private fork of mine and it's working nicely now in case you cared
19:53:27 <thoughtpolice> (i don't know where Paczesiowa is, so there are a couple competing patches out there to fix it)
19:53:41 <conal> thoughtpolice: glad to hear about the progress.
19:54:00 <thoughtpolice> it makes me feel much better. i hope cabal sandboxing comes soon and acts similarly :)
19:56:53 <tac_> if I accidentally install a package locally, can I just delete my ~/.cabal and get rid of it?
19:57:06 <tac_> Or do I need to unregister the packages from ghc first?
19:57:52 <bgamari> What to do when you have to profile code that stack overflows when compiled with -prof
19:58:01 <jojo_> Hello, I have some general questions about Haskell if anyone would like to help
19:58:09 <tac_> jojo_: ask away
19:58:50 <jojo_> Is there a book about Haskell that has a good language description in it? I have the 2010 Haskell report from online, but I also need a book as a source, unfortunately...
19:59:04 <tac_> Real World Haskell is available free online
19:59:12 <tac_> @where real world haskell
19:59:12 <lambdabot> http://book.realworldhaskell.org/read/ <-- the comprehensive xmonad configuration syntax reference
19:59:31 <jojo_> That has the language description in it? I didn't realize.
19:59:42 <tac_> What do you mean by "description"?
19:59:53 <tac_> If you mean the language's specification, you can always cite the specification itself
20:00:27 <jojo_> My professor needs at least one book, I know it's stupid but... yes, I do need one. Her rules, not mine. =/
20:01:29 <tac_> If you need the specification, the specification is found in the Haskell 2010 report. That's where it's specified. I'm sure one of the authors had a print copy at some point.
20:01:35 <tac_> :P
20:01:57 <Cale> Though to be honest, the language specification isn't really as relevant as it could be
20:02:10 <Cale> (in some ways that is a good thing)
20:02:18 <tac_> yeah
20:02:27 <jojo_> That's what I would say, too. There's even a detailed history of the language online. Everything I need is online... The book rule kinda drives me crazy
20:02:31 <Cale> It specifies the basic language, but almost any real programs these days use extensions
20:02:37 <tac_> To be fair, the Haskell spec is the weakest language spec there is among all languages that claim to have one, IMO
20:03:46 <jojo_> Well, that's certainly not promising. ^^;;;;
20:04:00 <jojo_> You guys know someone named shapr?
20:04:04 <tac_> yeah
20:04:11 <jojo_> He's a classmate of mine
20:04:19 <shapr> jojo_: howdy
20:04:20 <tac_> oh neat
20:04:20 <rwbarton> @get-shapr
20:04:21 <lambdabot> shapr!!
20:04:40 <jojo_> Oh, I didn't realize he was awake.... Hi shapr. =P
20:04:57 <shapr> oh hai jojo_
20:05:14 <shapr> jojo_: Are you learning Haskell?
20:05:44 <jojo_> Well, I'm writing that paper, if that's what you mean.
20:06:06 <jojo_> And by writing I mean hurriedly gathering it together
20:06:38 <myname_> @help
20:06:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:07:23 <myname_> @pl (\g f x y -> g (f x) (f y))
20:07:23 <lambdabot> join . ((flip . ((.) .)) .) . (.)
20:08:26 <myname_> @pl (\g f_x f_y x y -> g (f_x x) (f_y y))
20:08:26 <lambdabot> ((flip . ((.) .)) .) . (.)
20:09:29 <myname_> @pl (\g f_a f_b x -> g (f_a x) (f_b x))
20:09:29 <lambdabot> liftM2
20:11:00 <myname_> @pl (\g f_a f_b x y -> g (f_a x y) (f_b x y))
20:11:00 <lambdabot> (liftM2 ap .) . (.) . (.)
20:11:43 <myname_> @help
20:11:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:11:57 <myname_> @list
20:11:57 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:12:28 <myname_> @pointful ((.)(.))
20:12:28 <lambdabot> (\ b c e f -> b c (e f))
20:13:01 <myname_> @pointful ((.).(.))
20:13:02 <lambdabot> (\ i b c f -> i (b c f))
20:13:16 <myname_> @pointful ((.)..(.))
20:13:17 <lambdabot>  Parse error at "..(.)..." (column 5)
20:13:22 <myname_> @pointful ((.)(.)(.))
20:13:23 <lambdabot> (\ c e f i -> c (e f i))
20:13:34 <myname_> @pointful ((.)(.)(.)(.))
20:13:34 <lambdabot> (\ e f i k l -> e f i (k l))
20:13:46 <pdxleif> I've been trying to convert xmonad-utils from OldException to the new Exception, because OldException's been dropped in GHC 7.6
20:13:50 <myname_> @pointful ((.).)
20:13:50 <lambdabot> (\ d g b c -> d g (b c))
20:13:58 <myname_> @pointful ((.)(.).)
20:13:58 <lambdabot> (\ g j c e f -> g j c (e f))
20:14:04 <beaky> @pl (.)
20:14:04 <lambdabot> (.)
20:14:09 <myname_> @pointful ((.)($).)
20:14:09 <lambdabot> (\ f i c e -> f i c e)
20:14:13 <pdxleif> This commit makes it compile, at least: https://github.com/LeifW/xmonad-utils/commit/dd264051038a34b31c31ef45bbeca6bfa0b71c91
20:14:21 <myname_> @pointful (($)(.).)
20:14:22 <lambdabot> (\ f i d e -> f i (d e))
20:14:29 <myname_> @pointful (($)(.)$)
20:14:29 <lambdabot> (\ f d e -> f (d e))
20:14:30 <typoclass> myname_: hello, welcome to #haskell. lambdabot is also available privately. you can use the command "/query lambdabot" for that
20:15:48 <pdxleif> The conversion of Hslock seems straightforward enough, but Hhp no longer works - it doesn't hide the mouse pointer, and the program exits after a few seconds.
20:16:33 <pdxleif> And it says block and unblock are deprecated in favor of mask.
20:18:10 <typoclass> pdxleif: i have no idea how to port away from OldException :) but have you found a blog post or SO question or something? i'd be interested in a link
20:18:15 <pdxleif> I don't know much about threads and exceptions in haskell; the code in question seems to be throwing an exception to another thread.  I thought I could just move that exception over to the new stuff in the Exception typeclass, but it doesn't seem to work.
20:18:33 * hackagebot cakyrespa 0.0.29 - run turtle like LOGO with lojban  http://hackage.haskell.org/package/cakyrespa-0.0.29 (YoshikuniJujo)
20:20:37 <pdxleif> I'd like if I did find such a guide on making the conversion.
20:25:08 <pdxleif> II
20:28:35 <pdxleif> I just replaced ExitException ExitSuccess with ExitSuccess, and a ExitCode->IO () type declaration to the catch statement, to make it compile, but it doesn't seem to work. :(
20:31:32 <typoclass> pdxleif: i don't know what ExitException is, but ExitSuccess is the status code (as in, exit the program with status 42). unless they're using some other thing which has the same name by coincidence
20:32:14 <typoclass> pdxleif: in other words, i don't think you can throw an ExitStatus. you need to wrap it in something
20:32:34 <typoclass> s/ExitStatus/ExitSuccess
20:33:57 <pdxleif> It said there's an Exception instance for ExitCode: http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html#t:ExitCode
20:34:59 <pdxleif> There's also exitSuccess, which is equivalent to exitWith ExitSuccess.  Wish I knew more about what this code's actually doing - how this works.
20:35:14 <pdxleif> The Hslock one was just getting an env var - at least I know how to do that.
20:35:15 <typoclass> pdxleif: oh i see. i guess i should be quiet, you're way ahead of me :-)
20:36:18 <pdxleif> I don't know what I'm doing, I've just been reading through the haddocks and making guesses.
20:36:48 <pdxleif> There's this wiki article on Exception - maybe I need to grok the business about asynch exceptions and masking threads and stuff. :( http://www.haskell.org/haskellwiki/Exception
20:37:23 <typoclass> i wish they had just moved OldException to some package that you can install if you want, instead of just removing it
20:41:57 <pdxleif> Yeah. Has been deprecated for a while now, though.  Maybe there was some GHC internals necessary to support it, that they didn't want to maintain anymore?
20:43:56 <micahjohnston> dibblego:
20:44:05 <dibblego> yes
20:44:14 <micahjohnston> Are you referring to the message “<tac_> patrickstarfish: you can use "do" syntax to get an Integer out of an IO integer”?
20:44:25 <micahjohnston> I looked up the logs at the time of your tweet :P
20:44:26 <dibblego> No. I will have to remember
20:44:58 <dibblego> <twopoint718> Sorry if this is wide-ranging, but I see this common pattern: I have function that takes a lot of parameters. What's an idiomatically-functional way to reduce that number?
20:46:27 <micahjohnston> oh, ok, so my statements were ill-founded regarding functional program construction/factoring, not regarding IO?
20:46:30 <micahjohnston> or what
20:46:41 <dibblego> I know you gave a false dichotomy
20:47:19 <dibblego> specifically, two non-solutions that should both be avoided — but you also implied they were somehow necessary
20:48:06 <pdxleif> The "Exceptional" monad described here reminds me of scalaz's Validation, which in turn reminds me of Either - is there some fundamental difference between the three? http://www.haskell.org/haskellwiki/Exception
20:48:11 <micahjohnston> ok, here's the tweet with the false dichotomy “I can either make tons of things take more arguments or make tons of things inside the IO monad.”
20:48:33 * hackagebot fsnotify 0.0.1 - Cross platform library for file creation, modification,  and deletion notification.  http://hackage.haskell.org/package/fsnotify-0.0.1 (GregWeber)
20:48:53 <dibblego> pdxleif: FYI http://hackage.haskell.org/package/Validation
20:49:10 <dibblego> micahjohnston: sure, you can do those things, but that would be a bad idea
20:49:18 <micahjohnston> yeah, I understand that both are a bad idea
20:49:30 <micahjohnston> and that there's probably a more fundamentally different, better way
20:49:32 <dibblego> they are not necessary either
20:49:34 <dibblego> right
20:49:56 <pdxleif> You can bundle the arguments into a structure.
20:50:07 <micahjohnston> that's not really applicable to my situation
20:50:21 <micahjohnston> for more context:
20:50:26 <micahjohnston> I wanted to make a little reactive library
20:50:26 <dibblego> "putting arguments into a structure" is definitely applicable
20:50:34 <dibblego> specifically, uncurrying exists — QED
20:50:38 <pdxleif> Also, if it's the IO monad's style of having some "state" in the "environment", there's like the "state" monad and Reader monad and stuff and stuff.
20:50:43 <micahjohnston> dibblego: heh ok
20:50:56 <micahjohnston> so say I were making a game with it
20:51:01 <micahjohnston> I didn't want to have everything look like
20:51:33 <micahjohnston> character :: Signal KeyboardState -> Signal Environment -> Signal Character
20:51:37 <micahjohnston> the Signal KeybaordState
20:51:49 <micahjohnston> and then if you want to have mouse input as well, add another argument
20:51:53 <micahjohnston> or you can have
20:52:03 <micahjohnston> Signal <all the input to the program>
20:52:12 <dibblego> that would not be the same structure
20:52:13 <micahjohnston> and that seems to undermine functional design and whatnot
20:52:27 <dibblego> (f a, f b) and f (a, b) are quite distinct
20:52:31 <Eduard_Munteanu> There's also Oleg's paper on configurations, which also summarizes other methods.
20:52:36 <Eduard_Munteanu> @google oleg configurations
20:52:38 <lambdabot> http://wl500g.info/showthread.php?10307-How-To-Install-and-Configure-Olegs-firmware
20:52:41 <Eduard_Munteanu> Bah.
20:52:58 <micahjohnston> dibblego: not sure how this is (f a, f b)?
20:53:02 <Eduard_Munteanu> @google oleg implicit configurations
20:53:04 <lambdabot> http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
20:53:04 <lambdabot> Title: Functional Pearl: Implicit Configurations
20:53:15 <Jafet> @hackage reflection
20:53:16 <lambdabot> http://hackage.haskell.org/package/reflection
20:53:18 <dibblego> let f=Signal, a=KeyboardState, b=Environment
20:53:55 <micahjohnston> well, I was planning on keeping Signal Environment as a separate argument anyway
20:53:57 <dibblego> (Signal KeyboardState, Signal Environment) -> Signal Character
20:53:58 <micahjohnston> I wasn't clear
20:54:00 <micahjohnston> I meant
20:54:04 <dibblego> Signal (KeyboardState, Environment) -> Signal Character
20:54:04 <Eduard_Munteanu> (Although his stuff is pretty heavyweight.)
20:54:06 <dibblego> not the same
20:54:12 <micahjohnston> Signal KeyboardState -> Signal Environment -> Signal Character
20:54:13 <micahjohnston> then add mouse
20:54:24 <dibblego> arbitrarily adding function arguments like that seems a bit backward
20:54:31 <micahjohnston> Signal KeyboardState -> Signal MouseState -> Signal Environment -> Signal Character
20:54:38 <micahjohnston> or
20:54:47 <dibblego> but if you do just end up with a read-only environment to thread through, it's hinting toward a ReaderT stack
20:54:47 <micahjohnston> Signal KeyboardAndMouseState -> Signal Environment -> Signal Character
20:55:00 <dibblego> yes, that's the same thing as I said
20:55:14 <micahjohnston> well yeah, I was just saying that that's an alternative way to structure the program
20:55:16 <dibblego> I just pronounced "And" like this (,)
20:55:21 <micahjohnston> ok :P
20:55:22 <dibblego> but it's quite different
20:55:50 <micahjohnston> well if it's just a Signal (KeyboardState, MouseState), what are the important differences?
20:55:51 <dibblego> (f a, f b) -> f (a, b) required an applicative functor f
20:55:58 <Petit_Dejeuner__> How do you feel about using show and read for serilization?
20:56:10 <dibblego> aka zip
20:57:21 <micahjohnston> well, Signal does implement Applicative, but that's not relevant because I wasn't talking about being able to make function (Signal KeyboardState, Signal Environment) -> Signal (KeyboardState, Environment)
20:57:41 <dibblego> sure, I am just saying they are not the same
20:57:42 <micahjohnston> I was just talking about how I could write the proram based on either structure and it would be equally useful
20:57:51 <dibblego> you'll need a Distributive Signal to get back again
20:57:55 <dibblego> but it wouldn't
20:57:58 <Jafet> Eduard_Munteanu: reflection is fairly easy to use.
20:58:20 <dibblego> unless signal is both Applicative and Distributive, which is very unlikely
20:58:29 <Jafet> petit: I feel bad when implementing them. But after that I feel good.
20:59:17 <micahjohnston> dibblego: I understand how they're importantly different for Functor f => f (a, b) and (f a, f b)
20:59:28 <micahjohnston> because in general that's potentially very different
20:59:40 <dibblego> and in this case specifically
21:00:15 <micahjohnston> is Distributive in Control.Something?
21:00:16 <micahjohnston> or
21:00:23 <dibblego> http://hackage.haskell.org/packages/archive/distributive/0.1.2/doc/html/Data-Distributive.html
21:00:30 <micahjohnston> ok
21:00:31 <dibblego> Signal is not Distributive, I'll put a house on it
21:00:32 <micahjohnston> thanks
21:01:26 <Eduard_Munteanu> Jafet: yeah, though there's quite a bit of type noise involved, at least in his paper
21:01:41 <callen> shapr: I'm well-typed, but I don't know if I'm deriving Nice.
21:02:12 <Jafet> The reflection implementation is quite different from the paper
21:02:16 <micahjohnston> ok, let me think through this
21:02:23 <micahjohnston> pretending Signal a is T -> a
21:02:41 <micahjohnston> then (T -> a, T -> b) and T -> (a, b) are what we're talking about
21:02:46 <dibblego> yes
21:02:53 <dibblego> that's just the reader monad already
21:03:05 <micahjohnston> it feels like there is a bijection?
21:03:10 <dibblego> there isn't
21:03:18 <dibblego> there is a duality
21:03:25 <pordan30> \join #emacs
21:03:49 <dibblego> actually, I should have said Counzip, which is just Functor, sorry
21:04:06 <dibblego> *Cozip
21:04:20 <Eduard_Munteanu> Hm, I see.
21:04:28 <dibblego> I really think that is all beside the point of the original discussion — not sure where you want to go
21:04:38 <micahjohnston> yeah it is
21:05:01 <micahjohnston> I see though how Signal (Either a b) is definitely not the same as Either (Signal a) (Signal b)
21:05:30 <micahjohnston> anyway, the Reader monad was suggested
21:05:36 <dibblego> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/src/Control-Functor-Zip.html#Cozip
21:05:50 <dibblego> well you already have the Reader monad
21:05:54 <dibblego> Signal = Reader T
21:06:03 <micahjohnston> and I was just grumbling about how that still puts things throughout the code
21:06:21 <dibblego> then you probably need ReaderT
21:06:26 <dibblego> depends specifically on the use-case
21:06:50 <micahjohnston> and this is perhaps not the most beautiful solution, and not really Haskelley or anything
21:06:54 <micahjohnston> but I though of having sources
21:07:05 <micahjohnston> like a possible value of Signal a is Source (IO a)
21:07:09 <micahjohnston> or Source String
21:07:16 <dibblego> instance MonadIO Signal
21:07:19 <micahjohnston> and then the runner knows how to map the String to a specific input
21:08:20 <micahjohnston> and I don't think I want arbitrary liftIO in Signal because I want it to be pure in most cases
21:08:29 <micahjohnston> idk
21:08:54 <dibblego> that's what liftIO is for
21:09:24 <dibblego> I cannot say specifically what you want without the use-case, but I can tell you definitely what you do not want
21:11:12 <beaky> how come I've never heard of Monads or Category Theory before being introduced to Haskell?
21:11:36 <dibblego> because you confused your schooling with your education
21:12:37 <micahjohnston> because computer science, oddly, seems to consider itself separate from mathematics
21:13:28 <john_door> i have a question if anyone has a second
21:13:28 <ion> Computer science hates being anthropomorphized.
21:13:34 <lightquake> is there any way with lenses to traverse the object and perform a monadic action that also gets access to a lens pointing at that specific object?
21:13:43 <dibblego> we will always have a second in Control.Arrow
21:13:59 <dibblego> lightquake: of what type? did you see the lens package with traversals?
21:14:11 <lightquake> for example, if i wanted to write a lens that traverses the list [1,2,3] and replaces each element with 0, to give [[0,2,3], [1,0,3], [1,2,0]]
21:14:43 <lightquake> (except with some monadic action on the side)
21:14:51 <edwardk> lightquake: use holesOf for that one
21:15:14 <edwardk> Control.Lens.Plated.holesOf
21:15:22 <lightquake> interesting
21:15:24 <edwardk> that gives you the set of one hole contexts
21:15:42 <edwardk> and you can use the operations from Store on them to change the target to a 0
21:16:22 <john_door> i'm trying to rewrite:
21:16:23 <john_door> parseNumber = liftM (Number . read) $ many1 digit
21:16:28 <lightquake> Store?
21:16:40 <john_door> using a) do notation and b) bind operators
21:16:40 <lightquake> john_door: looks perfectly intelligible to me
21:16:45 <john_door> instead of liftM
21:16:51 <john_door> it's an excersize
21:16:59 <john_door> exercise
21:17:02 <dibblego> start here:
21:17:06 <dibblego> do many1 digit
21:17:50 <beaky> > map (show &&& succ) ['a'..'z']
21:17:51 <lambdabot>   [("'a'",'b'),("'b'",'c'),("'c'",'d'),("'d'",'e'),("'e'",'f'),("'f'",'g'),("...
21:18:24 <lightquake> edwardk: where's Store defined?
21:18:29 <micahjohnston> edwardk: does the set of one hole contexts have something to do with comonads?
21:18:55 <edwardk> Control.Comonad.Trans.Store in comonad-transformers, and Control.Comonad.Store in comonads-fd
21:18:56 <dibblego> micahjohnston: ListZipper a = [a] a [a] is this comonad
21:19:10 <lightquake> … I googled lens store and that wasn't helpful!
21:19:39 <john_door> dibblego: i keep getting expected type vs actual type errors
21:19:40 <edwardk> lightquake: start with comonad, comonad-transformers, comonads-fd   and reason about them by analogy to transformers and mtl
21:19:59 <john_door> expected type Text.Parsec.Prim.ParsecT String () Data.Functor.Identity.Identity LispVal
21:20:03 <john_door> actual type LispVal
21:20:15 <john_door> i don't think i understand exactly what liftM is doing
21:20:16 <lightquake> i feel like i'm learning haskell all over again
21:20:23 <dibblego> john_door: perhaps you should transform the expression to do-notation independently of that specific program
21:20:25 <beaky> liftM <=> fmap
21:20:29 <beaky> :t liftM
21:20:30 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
21:20:31 <beaky> :t fmap
21:20:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:21:07 <micahjohnston> john_door: do you know Functors/fmap?
21:21:17 <lightquake> i feel like there's some awesome payout for all the work i'm putting into this, i just can't see it
21:22:00 <john_door> micahjohnston: not practically
21:23:43 <micahjohnston> john_door: that would be a good place to start
21:25:12 <micahjohnston> john_door: map is fmap on []
21:25:54 <micahjohnston> so just like you can map a function over a list, you can map a function over any instance of Functor
21:26:19 <john_door> right
21:27:06 <micahjohnston> so liftM does the same thing, for Monads
21:27:10 <micahjohnston> because all Monads are Functors
21:27:14 <john_door> so if i'm trying to apply (Number . read) to an action
21:27:23 <john_door> i would use fmap?
21:27:33 <dibblego> liftM is the same as fmap
21:27:37 <micahjohnston> you could use liftM, or <$>, or fmap, or any synonyms thereof
21:27:38 <dibblego> you're already using it
21:27:42 <micahjohnston> > liftM (+1) [1, 2, 3]
21:27:43 <lambdabot>   [2,3,4]
21:27:45 <dibblego> do-notation is something else
21:28:25 <john_door> what is the difference between . and $
21:28:57 <john_door> i know $ replaces brackets and . combines functions
21:29:14 <Clint> :t (.)
21:29:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:29:19 <Clint> :t ($)
21:29:20 <lambdabot> forall a b. (a -> b) -> a -> b
21:29:22 <micahjohnston> john_door: $ applies a function to an argument
21:29:28 <micahjohnston> john_door: . composes two functions
21:29:35 <micahjohnston> so . will have a function on either side
21:29:48 <micahjohnston> $ will have a function on the left and a value of any type on the right
21:29:56 <micahjohnston> as those types say
21:30:02 <john_door> can't you apply a function to a function?
21:30:15 <micahjohnston> yeah, you can
21:30:41 <john_door> so you could replace . with $?
21:30:44 <micahjohnston> no
21:30:48 <micahjohnston> it would do something different
21:31:02 <micahjohnston> > (+1) . (+2)
21:31:03 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
21:31:03 <lambdabot>    arising from a use of `...
21:31:11 <micahjohnston> well, you can't show function
21:31:14 <micahjohnston> s
21:31:21 <micahjohnston> but that's a function that adds 3
21:31:22 <micahjohnston> whereas
21:31:29 <micahjohnston> hm
21:31:56 <micahjohnston> oh, here's something interesting
21:32:02 <micahjohnston> ($) is the same as id
21:32:05 <micahjohnston> and (.) is the same as fmap
21:32:32 <micahjohnston> john_door: here's how the implementations look
21:32:38 <micahjohnston> f $ x = f x
21:32:44 <micahjohnston> (f . g) x = f (g x)
21:32:49 <micahjohnston> you can see how those do different things
21:32:58 <micahjohnston> (f . g) doesn't apply f to g
21:33:05 <micahjohnston> (f $ g) does apply f to g
21:33:16 <micahjohnston> (f . g) applies f to the *result* of g, applied to another argument
21:33:23 <micahjohnston> make sense?
21:33:24 <john_door> okay that makes sense
21:33:33 <john_door> heh thanks
21:33:50 <lightquake> @undo { tell "zeroed"; return 0 }
21:33:51 <lambdabot>  Parse error at "{" (column 1)
21:33:58 <lightquake> @undo do { tell "zeroed"; return 0 }
21:33:58 <lambdabot> tell "zeroed" >> return 0
21:34:01 <lightquake> oh right
21:34:40 <micahjohnston> john_door: glad to help
21:35:09 <micahjohnston> dibblego: any pernicious semantic errors in my explanation? :P
21:50:40 <alfgaar> hi
21:50:47 <lightquake> .. oh hm, i just realized my action model is fundamentally unsound
21:51:03 <alfgaar> i have a simple question about haskell
21:51:10 <alfgaar> i just started learning
21:51:23 <Cale> alfgaar: ask away
21:51:36 <alfgaar> and it got me that variables in haskell are immutable
21:51:42 <alfgaar> is that right?
21:51:46 <Cale> Well, pretty much, yes
21:51:57 <alfgaar> so i cant understand a thing
21:52:04 <lightquake> it's close enough to right for now
21:52:07 <alfgaar> an example in the tutorial worked
21:52:16 <alfgaar> and it should not have worked
21:52:23 <Cale> What shouldn't have worked?
21:52:27 <alfgaar> cause it changed a variable within a function
21:52:36 <Cale> What was the example?
21:52:52 <Cale> It's possible to shadow a variable from an outer scope
21:53:03 <alfgaar> this is the tutorial
21:53:05 <alfgaar> http://learnyouahaskell.com/recursion
21:53:16 <lightquake> which example?
21:53:17 <alfgaar> the example is the first version of maximum funtion
21:53:38 <alfgaar> it extracts the head of the variable xs
21:53:54 <alfgaar> then pass xs to the function again in a call
21:54:06 <arbn> Ah. The pattern-matching looks like it changes the value of xs, eh?
21:54:13 <Cale> Well, maximum' (x:xs) means the value of maximum' applied to a list whose first element is x and whose tail is xs
21:54:14 <alfgaar> the variable have to be changed for it to work
21:54:32 <alfgaar> yes
21:54:35 <Cale> Also, you can still apply a function to different parameters throughout the evaluation of a program
21:54:39 <alfgaar> it does not extract the tail
21:54:46 <alfgaar> to pass to the recursive call
21:55:04 <arbn> alfgaar: (x:xs) just names the head x and whatever the tail is to xs.
21:55:22 <rwbarton> how bad would it be to allow , as a symbol in operator identifiers?
21:55:53 <lightquake> rwbarton: i can't think of any cases off the top of my head where it would be ambiguous, but i don't like it
21:55:58 <rwbarton> the only conflicts I can think of with current syntax are in the forms (,,,,) and (with -XTupleSections) (3,,,,-5)
21:56:05 <lightquake> ah, yeah
21:56:08 * shachaf refers rwbarton to #agda.
21:56:34 <Cale> alfgaar: Is that cleared up then?
21:56:35 <rwbarton> it would be nice to have a name <,> for the pairing operator for Applicatives
21:56:49 <rwbarton> good for this record stuff too perhaps
21:56:49 <shachaf> rwbarton: <*> could be a good name for it.
21:56:52 <rwbarton> not that one
21:56:54 <rwbarton> well, yes
21:56:55 <Cale> hah
21:57:00 <shachaf> You could use <> for plain application.
21:57:09 <rwbarton> hm
21:57:19 <Cale> Yeah, that would have been a little nicer. Too late probably now.
21:57:21 <rwbarton> you mean rename <*> to <> and "<,>" to <*>
21:57:31 <Jafet> :t (<>)
21:57:33 <lambdabot> Doc -> Doc -> Doc
21:57:44 <dibblego> fzip
21:58:07 <hpaste> thetallguy pasted “Sunday night stupidity” at http://hpaste.org/76932
21:58:23 <rwbarton> if i'm going to give it a prefix name i may as well just call it phi like on the wikipedia page :P
21:58:33 <Cale> alfgaar: But yeah, there is something to realise here: any program you could write where variables change over time can be turned into one where all the mutable variables are replaced by function parameters, and control flow is replaced by function calls.
21:59:25 <rwbarton> any time you have a tuple construct in an EDSL you might want a name like this
21:59:30 <rwbarton> @hoogle (<&>)
21:59:32 <lambdabot> No results found
21:59:37 <thetallguy> anyone care to lend a fresh pair of eyes and tell me why my Other types aren't getting the same scope? http://hpaste.org/76932
21:59:38 <rwbarton> @hoogle <&>
21:59:39 <lambdabot> No results found
21:59:42 <rwbarton> i guess that could work too
22:00:12 <Cale> alfgaar: In a stupid and mechanical way, you could turn each line of your imperative program into a function, whose parameters are the mutable variables which are in scope, and whose result is the next line of the function applied to the new values of the variables.
22:00:19 <Cale> er, the next line of the program*
22:00:58 <Cale> alfgaar: Usually there is a more straightforward translation than this, but it actually has served me in the past to understand particularly convoluted imperative programs.
22:01:12 <dibblego> hey edenc
22:01:15 <dibblego> er edwardk
22:01:24 <edwardk> heya
22:01:36 <thetallguy> it fails with:     Couldn't match type `Other a0' with `Int'
22:01:42 <Cale> alfgaar: (once I've translated them into a pile of mutually recursive functions, I can transform them algebraically into a simpler program)
22:01:46 <thetallguy> which is a dirty lie
22:01:58 <dibblego> edwardk: a friend is trying to compile semigroups but: Data.List.NonEmpty is #ifdef LANGUAGE_DeriveDataTypeable — where does this define come from?
22:02:37 <edwardk> it was defined by the cabal file but should probably be just tied to whether its compiled with GHC honestly
22:02:44 <rwbarton> thetallguy, nothing is forcing 'defaultOther' on line 18 to correspond to the type String
22:02:51 <edwardk> i may have broken it at some point, but that seems strange
22:02:54 <rwbarton> in fact there is no way to ever use defaultOther at all
22:03:22 <rwbarton> because the type "Other a" does not determine the type "a"
22:03:29 <thetallguy> rwbarton: I was afraid of that
22:03:45 <dibblego> he might be using an old cabal-install
22:07:05 <thetallguy> rwbarton: defaultOther should be of type  Other a = Int, not String
22:07:21 <rwbarton> I mean there is no reason for a = String
22:07:38 <rwbarton> all it can see is it needs a value of type Int and it has the term defaultOther which it knows has type Other a
22:07:41 <rwbarton> for some a
22:07:44 <rwbarton> any a
22:08:13 <rwbarton> there could be many a that satisfy the equation Other a = Int
22:08:33 <alfgaar> do you have any idea why the value of xs seems to change
22:08:51 <alfgaar> i thing the where expression should be something like
22:09:02 <alfgaar> where maxTail = maximum'  tail xs
22:09:16 <dibblego> living on the edge there
22:09:20 <alfgaar> for it to work, preserving variable immutability
22:10:58 <Cale> alfgaar: Because you can apply a function to different parameters over the course of the program
22:10:58 <thetallguy> rwbarton: this should be clear, but it's not.  Either I am misreading the type family docs or it is very late on a sunday evening.
22:11:11 <alfgaar> the expression (x:xs) should only create an x variable and give it the value of the head of xs
22:11:26 <Cale> alfgaar: If I write a function like  f x = x^2  then the value of x doesn't change inside of any particular application of f
22:11:41 <Cale> alfgaar: But over the lifetime of the program, I might apply f to many different values x
22:11:46 <john_door> alfgaar: xs isn't the whole list, it is the tail of the list
22:12:00 <john_door> xs is the list without x
22:12:03 <Cale> oh, that too
22:12:28 <Cale> > let f (x:xs) = (x,xs) in f [1,2,3,4,5]
22:12:29 <pordan30> you can rebind the variable, but its value cannot be mutated
22:12:29 <lambdabot>   (1,[2,3,4,5])
22:12:36 <alfgaar> xs is the maximum parameter
22:12:42 <alfgaar> so, the whole list
22:12:48 <alfgaar> ah
22:12:50 <Cale> alfgaar: no (x:xs) is the parameter to maximum'
22:13:07 <Cale> and (x:xs) means a list whose first element is x, and where the rest of the list after that is called xs
22:13:12 <alfgaar> you mean (x:xs)
22:13:23 <alfgaar> returns a tule
22:13:25 <alfgaar> tuple
22:13:31 <Cale> No, (x,xs) does
22:13:35 * hackagebot java-character 0.0.1 - Functions to simulate Java's Character class.  http://hackage.haskell.org/package/java-character-0.0.1 (TonyMorris)
22:13:49 <Cale> I turned the (x:xs) into a pair so that you could see what x and xs were bound to
22:13:55 <alfgaar> ah
22:14:10 <Cale> when we apply this f (x:xs) = (x,xs) to the list [1,2,3,4,5] we get x = 1 and xs = [2,3,4,5]
22:14:55 <Cale> It should be mentioned that [1,2,3,4,5] is really syntax sugar
22:15:06 <Cale> for 1 : (2 : (3 : (4 : (5 : []))))
22:15:46 <Cale> > let (x:xs) = 1 : (2 : (3 : (4 : (5 : [])))) in x
22:15:48 <lambdabot>   1
22:15:49 <Cale> > let (x:xs) = 1 : (2 : (3 : (4 : (5 : [])))) in xs
22:15:51 <lambdabot>   [2,3,4,5]
22:16:46 <alfgaar> ah yeah
22:16:50 <alfgaar> i got it
22:16:50 <Cale> Every list is either the empty list [], or it is a nonempty list constructed as x : xs from a first element x and tail xs (which is another list)
22:16:57 <alfgaar> the parameter is the list
22:17:12 <alfgaar> and the variables members of the list
22:17:17 <Cale> right, and it gets matched against the pattern (x:xs)
22:17:34 <Cale> which breaks the list apart into a first element x and a remainder xs
22:18:33 <Cale> > let sum [] = 0; sum (x:xs) = x + sum xs in sum [1,2,3,4,5]
22:18:34 <lambdabot>   15
22:18:37 * hackagebot java-character 0.0.2 - Functions to simulate Java's Character class.  http://hackage.haskell.org/package/java-character-0.0.2 (TonyMorris)
22:20:19 <alfgaar> thank you very much
22:23:13 <startling> is there a way I can make a dummy Paths_X module, so I can mess with a thing in ghci without building with cabal?
22:23:29 <beaky> > ((+1) *** (-1)) (0,0)
22:23:30 <lambdabot>   (1,-1)
22:23:37 <beaky> :t (***)
22:23:38 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
22:24:37 <ksf> startling, use -i<path/to/Paths_X> ?
22:24:38 <startling> beaky, (->) is an Arrow, so that's (b -> c) -> (b
22:25:01 <startling> ' -> c' -> a (b, b') (c, c')
22:25:04 <ksf> and don't have recent cabal versions a 'cabal ghci' command?
22:25:32 <startling> ksf, not that I know of?
22:25:45 <startling> ksf, and Paths_ is made/installed by cabal.
22:25:52 <ksf> there's http://hackage.haskell.org/package/cabal-ghci
22:26:09 <ksf> startling, well, do cabal configure and then you can -i it.
22:26:28 <startling> oh, true
22:26:56 <shachaf> Can someone write a patch to doctest that tests type signatures in comments?
22:27:02 <shachaf> "thx"
22:27:18 <startling> ksf: and really I want to use it in emacs' haskell-mode, so "cabal ghci" wouldn't work anyway.
22:27:38 <startling> shachaf, you're saying we should have a tool for haskell that checks types?
22:27:41 <thetallguy> hmm.. so the equations in the class aren't forced into the same type scope.
22:28:01 <shachaf> startling: Yes, in comments.
22:28:41 <startling> shachaf, why would you want that?
22:29:32 <shachaf> startling: Because I want to make sure the commented out types are right?
22:29:47 <startling> shachaf, why not just uncomment the types and let the type-checker do it?
22:30:19 <shachaf> Because there are many signatures for the same function.
22:30:25 <startling> ah
22:30:56 <shachaf> One is the "real" signature and others are specialized docummentation signatures.
22:31:06 <startling> right. makes sense.
22:32:33 <donri> see 'lens' package for an example of that
22:32:55 * shachaf is changing the signature of almost every type in "lens".
22:39:13 <john_door> :)
22:39:30 <john_door> do and bind versions done
22:39:34 <john_door> thanks for the help before
22:41:37 <mysticc> I have 2 packages in the same directory that I am working on say A/B and A/C. Now C is dependency of B. When I run cabal configure on B it says dependency C missing. How can I satisfy the dependency ?
22:43:28 <donri> mysticc: cabal install ../C
22:44:23 <donri> see also cabal-src, cabal-meta
22:44:30 <mysticc> donri: That will install the package in ~/.cabal. I have build the package in directory of C. Can I do that without actually installing it.
22:45:12 <donri> nope. try cabal-dev
22:46:08 <donri> build requires deps be installed
22:59:21 <hpaste> thetallguy annotated “Sunday night stupidity” with “Sunday night stupidity (annotation)” at http://hpaste.org/76932#a76933
22:59:55 <beaky> Is Haskell related to ML or is are they more like distant cousins?
23:00:27 <shachaf> @google is haskell related to ml
23:00:27 <lambdabot> http://en.wikipedia.org/wiki/ML_(programming_language)
23:00:27 <lambdabot> Title: ML (programming language) - Wikipedia, the free encyclopedia
23:01:22 <lightquake> ok, every time i think i understand lenses i realize i don't
23:01:58 <thetallguy> lightquake: :-D
23:02:45 <lightquake> i'm trying to figure out what the lens-y way to rewrite (^.position) (w^.monsters) is
23:02:48 <lightquake> er
23:02:49 <thetallguy> lightquake: I'm finding them less slippery all the time.
23:02:52 <pordan30> beaky: haskell derives from / work done on lml
23:02:55 <lightquake> map (^.position) (w^.monsters)
23:03:36 * hackagebot java-character 0.0.3 - Functions to simulate Java's Character class.  http://hackage.haskell.org/package/java-character-0.0.3 (TonyMorris)
23:08:15 <donri> lightquake: what is the question?
23:08:38 <lightquake> i have a World, which has a monsters lens, and the monster type has a position lens
23:08:49 <lightquake> given a world, how do i come up with the list of all of its monsters' positions?
23:09:22 <hpaste> hamid pasted “Is this really a bug?” at http://hpaste.org/76934
23:09:56 <lightquake> so the obvious way is map (^.position) (w^.monsters), but that's silly and i feel like there's a better way
23:10:13 <hamid> thanks hpaste . any idea on my paste?
23:11:30 <lightquake> hamid: that's definitely a bug (and you want Show, not show)
23:12:19 <lightquake> donri: basically i'm having trouble wrapping my head around lenses beyond basic x^.f.g.h usage
23:12:50 <hamid> lightquake, ow! i forgot about capitalism :P. thanks
23:12:51 <shachaf> lightquake: It's a bug which has been fixed in GHC 7.6
23:12:57 <shachaf> s/lightquake/hamid/
23:13:19 <shachaf> lightquake: Any opinions on alpha-renaming?
23:13:21 <donri> lightquake: w^.monsters.to (map (^.position))  ok not much better :p
23:13:32 <lightquake> shachaf: alpha-renaming?
23:13:34 <hamid> shachaf, thanks. so no need to report that :)
23:13:43 <shachaf> lightquake: For Lens a b c d = ...
23:13:48 <shachaf> Lens c d a b? Lens s t a b?
23:13:52 <lightquake> ah
23:14:02 <shachaf> s t a b has a nice ring to it.
23:14:04 <lightquake> no opinion
23:14:15 <lightquake> in general i'm in favor of more descriptive type variable names
23:14:19 <donri> need moar traversals, maybe?
23:15:30 <lightquake> yeah i think so, just trying to figure out how
23:16:45 <shachaf> donri: Shouldn't positions be a traversal there?
23:16:50 <shachaf> Then you could just use it.
23:17:29 <shachaf> lightquake: What's positions?
23:17:36 <shachaf> Oh, wait.
23:17:42 <donri> position is a lens on individual monsters, as i understood it
23:17:58 <lightquake> yeah, position is a lens on an individual monster
23:18:14 <shachaf> Does monsters.position type-check?
23:18:23 <lightquake> nope
23:18:24 * shachaf is probably misunderstanding.
23:18:30 <shachaf> Can you paste a simple example?
23:19:05 <hpaste> lightquake pasted “monsters” at http://hpaste.org/76935
23:19:52 <lightquake> all i need to a (Entity -> f Entity) -> World -> f World, then I can use (^..) to get what i need
23:21:56 <john_door> why is it that:
23:21:59 <john_door> parseNumber'' = return (many1 digit) >>= \r -> fmap (Number . read) r
23:22:02 <john_door> needs return to work
23:22:09 <john_door> but parseNumber = fmap (Number . read) $ many1 digit
23:22:10 <shachaf> lightquake: monsters.traverse.position?
23:22:11 <john_door> doesn't
23:22:20 <lightquake> shachaf: that's it :)
23:22:32 <shachaf> Well, if you want to traverse, traverse. :-)
23:22:42 <lightquake> i just was having problems figuring out where to put the traverse
23:22:52 <shachaf> lightquake: You might be able to get away with monsters.mapped.position
23:23:01 <shachaf> iIf you're just setting.
23:23:03 <shachaf> ...Oh, you're not.
23:23:14 <lightquake> yeah, i'm gettig
23:23:16 <lightquake> *getting
23:23:30 <shachaf> monsters.folded.position :-)
23:23:54 <shachaf> Gives you a read-only thing which I *think* can be more efficient in some cases?
23:24:02 <shachaf> Not that it's particularly worth it or anything.
23:24:15 * lightquake shrugs
23:24:32 <shachaf> lightquake: traverse :: Simple Traversal [a] a
23:24:46 <lightquake> john_door: what's the type of parseNumber''?
23:24:58 <john_door> parseNumber :: Parser LispVal
23:25:02 <Maxdamantus> john_door: the first one is trivially the same as the second.
23:25:07 * shachaf goes back to changing every type signature in Control.Lens
23:25:16 <Maxdamantus> john_door: (return a >>= b) .. b a
23:26:00 <lightquake> shachaf: one of these days someone ought to write a 'learn you a Control.Lens'
23:26:56 <shachaf> lightquake: I was thinking of doing something like that.
23:27:15 <ew0> what's all these lenses stuff everyone is always talking about?
23:27:17 <shachaf> (After Control.Lens started making sense to me, which was shortly after seeing edwardk's talk on it.)
23:27:20 <thetallguy> lightquake: Ed Kmett just gave a talk at google.  Maybe the video is available?
23:27:32 <shachaf> thetallguy: Google has a no-recording policy.
23:27:33 <donri> shachaf: is that plain old Traversable traverse?
23:27:38 <shachaf> donri: Yep.
23:27:56 <shachaf> donri: Control.Lens is pretty much a generalization of Data.Traversable.
23:28:00 <thetallguy> shachaf: say what?  Didn't thye have a site full of lectures...?
23:28:05 <donri> and it composes with lenses? coolness
23:28:06 <john_door> oh of course that's the monad law
23:28:19 <shachaf> thetallguy: OK, no-recording-by-strangers.
23:28:26 <shachaf> And they didn't have enough advance notice to record it themselves.
23:28:43 <shachaf> donri: traverse :: Traversable t => Traversal (t a) (t b) a b
23:29:30 <donri> +1 on a lens tutor
23:29:35 <thetallguy> shachaf: because none of them had an iphone? :-D
23:30:07 <lightquake> donri: one of the benefits of lenses is that you can you can write lens-compatible code without actually depending on the lens package
23:30:09 <thetallguy> lightquake: What's your current mental model on what a lens is?
23:30:21 <lightquake> a magnifying glass?
23:31:03 <thetallguy> lightquake: I feel like responding like an elementary school teacher... Are you asking me or telling me"
23:31:10 <lightquake> hahaha
23:31:14 <lightquake> i'm not entirely sure if i have one to begin with
23:31:24 <donri> yea, just didn't know packages predating lens where already lenses
23:31:36 <donri> were
23:31:40 <thetallguy> lightquake: Thinking of them as a pair of getters and setters is a bit limiting, I think
23:32:05 <thetallguy> lightquake: that's the realization made in Twan van L...'s type signature
23:32:12 <shachaf> thetallguy: The central concept of Control.Lens-style lenses is a Traversal, I think.
23:32:25 <lightquake> shachaf: have you seen the new Data.Records type-level stuff?
23:32:27 <shachaf> Everything else is a generalization/specialization along some reasonably obvious lines.
23:32:33 <shachaf> lightquake: Nope.
23:32:47 <lightquake> https://github.com/jonsterling/Data.Records/blob/master/README.lhs
23:33:08 <lightquake> apparently you can subtype/coerce them. not sure how typo-resilient it is, though, since i don't have a ghc 7.6 install
23:33:18 <thetallguy> shachaf: a Traversal is a series of lenses, isn't it?
23:33:36 <shachaf> lightquake: Structural typing?
23:33:39 <shachaf> Sounds interesting.
23:33:47 <lightquake> looks like it, yeagh
23:33:48 <lightquake> *yeah
23:33:55 <shachaf> thetallguy: Sort of?
23:34:13 <thetallguy> A lens points to a spot in a data structure
23:34:15 <shachaf> I think Traversal (also known as Multiplate) is the right intuition to be able to reason about lens-like things.
23:34:25 <shachaf> A Lens points to exactly one spot.
23:34:26 <thetallguy> early lenses just let you get/set at that spot
23:34:26 <lightquake> shachaf: also, if you do make a lens tutorial, put it somewhere wiki-editable
23:34:31 <shachaf> A Traversal points to zero-or-more spots.
23:34:37 <thetallguy> yes, a particular spot
23:34:56 <donri> "getting the string wrong will indeed cause your program to fail to compile (because the actual type of the function would not be able to be unified with the given type)"
23:34:59 <shachaf> A Traversal is just a "mapM", though.
23:35:02 <donri> re records
23:35:06 <lightquake> donri: oh neat
23:35:20 <lightquake> that was one of my big concerns :)
23:35:25 <thetallguy> shachaf: hence, sequence of lenses
23:35:52 <thetallguy> the functor signature for the lens generalizes what you can do at that location.
23:35:55 <shachaf> I wouldn't quite put it that way, since it can be zero lenses, for instance. :-)
23:36:06 <shachaf> But close enough to my intuition for it, I guess.
23:36:12 <rwbarton> more like an array of lenses, in parallel; except not really
23:36:20 <thetallguy> you can't have a sequence with zero elements?
23:36:30 <shachaf> Well, OK.
23:36:36 <donri> lenses are like burrito
23:36:43 <shachaf> Not funny.
23:36:49 <rwbarton> sequence of lenses sounds like in serial
23:36:53 * thetallguy kicks donri
23:37:06 <donri> you can but things in, and you can take things out! totally burrito, come on guys
23:37:10 <shachaf> rwbarton: Well, there *is* a particular arbitrary ordering.
23:37:19 <shachaf> rwbarton: It's a monoid of lenses. :-)
23:37:37 <thetallguy> collection, then
23:37:49 <shachaf> > runIdentity $ mapM (\x -> Identity (x + 1)) [1,2,3]
23:37:50 <lambdabot>   [2,3,4]
23:38:01 <shachaf> > execWriter $ mapM (\x -> tell [x])) [1,2,3]
23:38:01 <lambdabot>   <no location info>: parse error on input `)'
23:38:06 <shachaf> > execWriter $ mapM (\x -> tell [x]) [1,2,3]
23:38:08 <lambdabot>   [1,2,3]
23:38:17 <shachaf> ...That wasn't very useful, that execWriter thign.
23:38:24 <shachaf> But you get the point, I hope.
23:38:37 <shachaf> @let both :: Applicative f => (a -> f b) -> (a,a) -> f (b,b); both f (x,y) = (,) <$> f x <*> f y
23:38:39 <lambdabot>  Defined.
23:38:53 <shachaf> > execWriter $ (mapM.both) (\x -> tell [x]) [(1,2),(3,4),(5,6)]
23:38:56 <lambdabot>   [1,2,3,4,5,6]
23:39:04 <shachaf> > execWriter $ (both.mapM) (\x -> tell [x]) ("abc","def")
23:39:06 <lambdabot>   "abcdef"
23:39:41 <shachaf> rwbarton: How should I alpha-rename Lens?
23:39:57 <shachaf> Right now it's Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b
23:40:02 <shachaf> Lens c d a b?
23:40:07 <shachaf> Lens s t a b?
23:40:40 <shachaf> edwardk vetoed Lens ta tb a b
23:41:19 <rwbarton> Lens α β a b
23:41:39 <shachaf> I suggested that too, and he vetoed it.
23:41:42 <shachaf> (Thankfully.)
23:41:44 <rwbarton> good
23:42:06 <rwbarton> i'm sure cmccann can hook you up with some fraktur letters
23:42:18 <Nereid> what's wrong with ta tb a b?
23:42:28 <shachaf> Nereid: Two-letter identifiers.
23:42:32 <Nereid> bleh
23:42:47 <shachaf> Also, apparently that's not quite enough to express all lenses.
23:42:49 <rwbarton> i guess you would like some names that work well for the types of composition and so on
23:42:54 <donri> L a b c d
23:43:15 <shachaf> rwbarton: What I really want is the Lens ? ? a b part.
23:43:26 <shachaf> Because it matches the types of traverse and all those other good things.
23:44:41 <shachaf> I wish we had type-level _
23:50:03 <plat0> What's wrong with two-letter identifiers?
23:51:07 <donri> they're 100% longer than one-letter identifiers
23:51:41 <plat0> Yeah, but what's *really* wrong with them?
23:52:46 * Maxdamantus wonders if type variables over expressions have ever been considered for inclusion in Haskell.
23:52:46 <donri> one-letter identifiers are 50% shorter
23:53:26 <plat0> Two-letter type variables would really make lenses clearer, IMO.
23:54:42 <donri> agreed
23:54:53 <rwbarton> it does really seem natural to use two-letter type variables here
23:55:57 <efie> in f $!! (g x), ($!!) means that (g x) is fully evaluated before f evaluates anything, but it does not mean that everything inside g x has to be strictly evaluated, does it?
23:56:45 <Maxdamantus> :t ($!!)
23:56:46 <lambdabot> Not in scope: `$!!'
23:57:06 <Maxdamantus> Unless there's some class for that .. no.
23:57:15 * Maxdamantus doesn't know about $!! though.
23:57:27 <Nereid> isn't that from DeepSeq?
23:57:30 <efie> yes
23:57:30 <Nereid> @hoogle $!!
23:57:30 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
23:57:39 <Maxdamantus> Ah. So there's a class for it.
