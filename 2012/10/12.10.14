00:13:42 <startling> what's the equivalent of a void * in haskell's Foreign?
00:13:55 <shachaf> Ptr something
00:14:12 <startling> what if I don't know or care what the thing is, though?
00:14:27 <shachaf> Ptr something for any something
00:14:34 <shachaf> Did you see the slides I linked to before?
00:14:43 <shachaf> data Blah
00:14:51 <shachaf> foreign import ... :: Ptr Blah -> ...
00:15:28 <orzo_> http://jerkface.net/~joe/falling-bricks.txt
00:15:31 <startling> is it alright to use Ptr ()?
00:15:38 <startling> shachaf: I have them open right now
00:15:57 <shachaf> startling: Read them. :-)
00:16:14 <shachaf> Some thoughts on designing an API around the FFI are good for you too.
00:16:18 <shachaf> You can use Ptr (), but why?
00:16:26 <shachaf> You probably have more type information than that.
00:16:35 <shachaf> And someone might dereference a Ptr like that, which you don't want.
00:17:15 <startling> oh, so data Something is the way to go
00:17:20 <shachaf> Better to use Ptr Void than Ptr () :-)
00:17:29 <shachaf> startling: Note that I said "Ptr something" before, not "Ptr Something".
00:17:50 <shachaf> But anyway it's best to add a little bit of type information while you're at it.
00:18:02 <startling> shachaf, noted. Not sure what to make of that, though
00:18:17 <mietek> startling: you can take a look at libvm.h and VM.hs for a very simple example of raw FFI use; https://github.com/leastfixed/icfp2012/tree/master/src
00:18:49 <shachaf> Or you can look at the slides.
00:19:01 <shachaf> The slides come with an associated project.
00:19:23 <startling> shachaf: what did you mean when you said "Ptr something" rahter than "Ptr Something"?
00:19:33 <mietek> startling: specifically, data CState; type CStatePtr = Ptr CState; type CStateFPtr = ForeignPtr CState; data State = State !(CStateFPtr)
00:19:47 <shachaf> I mean that you can unify it with whatever you like.
00:19:56 <shachaf> It's a bit of a silly point. :-) Ignore it.
00:20:01 <startling> shachaf: okay.
00:21:44 <startling> so if I don't know how the size of what I'm pointing to, I should use ForeignPtr?
00:22:33 <shachaf> I think ForeignPtr is orthogonal to knowing a size.
00:22:37 <mietek> Indeed
00:22:56 <mietek> ForeignPtr is meant to help you manage memory, by leveraging Haskell's garbage collector
00:23:08 <startling> Okay. Ptr says: A value of type Ptr a represents a pointer to an object, or an array of objects, which may be marshalled to or from Haskell values of type a.
00:23:30 <mietek> A ForeignPtr can have a finalizer associated with it, which fires when the Haskell value gets garbage collected.  This finalizer can, say, call free()
00:23:35 <shachaf> startling: But there are no values of type Foo, when you say "data Foo"; so you can't marshal it. :-)
00:23:49 <startling> shachaf: ah, okay
00:23:56 <startling> mietek: that's interesting
00:24:24 <shachaf> Finalizer? I just met 'er, isn't that a bit drastic?
00:24:33 <mietek> startling: you should read http://book.realworldhaskell.org/read/interfacing-with-c-the-ffi.html
00:24:47 <shachaf> Yes, I hear that chapter is good.
00:24:52 <shachaf> You should also see the slides. :-)
00:26:03 <startling> mietek: I have that open too
00:26:11 <startling> shachaf: what slides?
00:26:56 <mietek> Has anyone ran into yesod devel using tons of CPU when idling?
00:41:11 <lispy> mietek: nope, but I suspect it's because I've never installed or run yesod :)
00:42:02 <arbn> mietek: I use Yesod a lot, and have never had that problem.
00:42:11 <shachaf> lispy: Sometimes yesod devel uses so much CPU that it overflows the computer that it's running on and spills into mine.
00:42:13 <shachaf> It's a problem.
00:42:43 <arbn> mietek: Is it only the devel server, or do you have the same problem in production?
00:43:31 <arbn> What is "provisional" stability supposed to mean?
00:44:07 <arbn> What are the provisions on the stability of all the provisionally stable packages on Hackage?
00:45:06 <lispy> arbn: I've often wondered that too
00:45:28 <lispy> arbn: at some point I assumed it was a british or australian english thing
00:46:47 <arbn> lispy: I see.
00:47:41 <cmccann> I think "provisionally stable" means something like "stable until some undisclosed time when it will not be stable"
00:47:51 <Cale> They're stable, provided that nobody discovers any problems with them :)
00:47:52 <cmccann> so basically a slower kind of unstable
00:51:49 <cmccann> Cale, btw: http://stackoverflow.com/questions/12085260/recursive-type-families/12087428#comment16152266_12087428
00:51:51 <cmccann> heh
00:52:30 <Cale> I take it you saw my comment on reddit?
00:52:37 <cmccann> yeah
00:53:11 <cmccann> and replied to similar effect that it usually takes me a couple paragraphs to recognize his style, heh
00:53:51 <Cale> Yeah, in this case as soon as he mentioned derivatives in this context, I was pretty much sure it was him.
00:54:50 <cmccann> he's not the only person who'd mention that, but combined with the writing style, yeah
00:54:59 <Cale> yeah
00:55:07 <Cale> Then I went to the end and sure enough a term worker with a shovel :)
00:55:16 <kosc> Hello, I am new in haskell. Right now I am downloading ghc. What I shold start with?
00:55:51 <cmccann> his amusing turns of phrase also tend to be pretty distinct, the answer the comment I linked to having a few examples
00:56:10 <cmccann> "(...) which are equal by definition of the type family and joy radiates over the world."
00:56:24 <Cale> http://strictlypositive.org/winging-jpgs/
00:56:36 <arbn> kosc: What do you mean? Have you read a book or tutorial yet?
00:57:21 <cmccann> Cale, the drop shadow kinda ruins the effect of his gravatar though
00:59:11 * hackagebot arbb-vm 0.1.1.17 - FFI binding to the Intel Array Building Blocks (ArBB) virtual machine.  http://hackage.haskell.org/package/arbb-vm-0.1.1.17 (JoelSvensson)
01:00:40 <arbn> Is there a good comonad tutorial that someone could recommend? I don't want to hear that comonads are like inverted boxes or burritos, either. :P
01:01:06 <cmccann> no, it's the other way around
01:01:08 <cmccann> coburritos are like a comonad
01:02:35 <cmccann> anyway, I'm not aware of anything other than the obvious sources
01:02:42 <Cale> arbn: Do you know what a monoid is?
01:03:27 <Cale> I can give you what is possibly the best example -- a fairly general family of comonads
01:03:54 <hiptobecubic> Basketballs made of gelatin
01:03:56 <Cale> (at least, I don't know of many examples of comonads being used in practice which are not at least somewhat like this one)
01:04:02 <hiptobecubic> rolling laterally through time
01:04:27 <arbn> Cale: I know what a monoid is in category theory. It's been a while since I've thought about how that relates to Haskell, though. Still, an example would be helpful.
01:04:38 <mietek> arbn: it's probably my combination of GHC 7.6.1 and OS X 10.8.2
01:05:01 <Cale> Okay, so a monoid for our purposes is just a set (or type) with a binary operation which is associative, and has an identity element
01:05:12 <Cale> For example, the integers under addition
01:05:24 <Cale> (with 0 as the identity element)
01:05:31 <Cale> Or lists under concatenation
01:05:43 <arbn> Right. Semigroup with an identity element.
01:05:48 <Cale> right
01:06:04 <Cale> So if m is any monoid, we can consider the functor (->) m
01:06:13 <Cale> which sends each type e to the type of functions m -> e
01:06:17 <mietek> arbn: it's only when I run "yesod devel", as opposed to "mysite Development"
01:06:47 <Cale> There's a natural way to take such a function and get an e from it: apply it to the identity element of the monoid
01:07:53 <Cale> and now we just need a  duplicate :: (m -> e) -> (m -> m -> e)
01:08:04 <Cale> Well, there's also a natural one of those:
01:08:26 <Cale> duplicate f = \x y -> f (x * y) -- where * is the monoid operation
01:08:43 <Cale> arbn: yeah?
01:09:29 <Cale> So, just to be clear about the other bit, we have extract :: (m -> e) -> e given by  extract f = f 1 -- where 1 is the identity element of the monoid
01:09:48 <Cale> You will want to use mempty and mappend if you're really writing this in Haskell
01:09:51 <mietek> arbn: and it is the ghc process which uses ~100% CPU, not mysite
01:09:55 <Cale> So we'd have:
01:10:10 <Cale> instance (Monoid m) => Comonad ((->) m) where
01:10:10 <AND_MY_MASS0UD> Everyone, don't mistreat Cale, he's my buddy.
01:10:18 <AND_MY_MASS0UD> You have to go through me first.
01:10:27 <Cale>   extract f = f mempty
01:10:30 <mietek> arbn: does "mysite Development" scan the filesystem for changes?
01:10:40 <Cale>   duplicate f x y = f (mappend x y)
01:10:55 <arbn> Cale: Hmm. OK, yeah, that makes sense to me.
01:11:14 <Cale> arbn: Okay, that happens to satisfy the comonad laws (and you use the monoid laws to prove it)
01:11:33 <Cale> But how can we think of this? Well, what if m is integers under addition? What is this doing?
01:11:45 <Cale> Well, extract gets us the value at 0
01:12:27 <Cale> let's picture a function Integer -> e as being like a doubly infinite sequence of cubbyholes with values of type e in each one
01:13:11 <Cale> well, duplicate takes such a sequence, and builds a corresponding sequence of all the shiftings of that sequence
01:14:02 <Cale> So that when we fmap extract, we'll get the element at 0 in each of them, which will be exactly the elements of the original sequence (which is actually one of the comonad laws)
01:14:26 <Cale> Now, how is this useful? Well, imagine you're implementing a cellular automaton
01:14:36 <Cale> (a 1-D cellular automaton in this case)
01:15:16 <Cale> The new value of each cell will be computed in some uniform way by looking at the values near 0 in each of the shiftings
01:15:38 <Cale> So it'll essentially be  fmap f . duplicate, for some f
01:16:22 <arbn> Cale: Ah. OK. That's helpful. I'll need to play with it some, but this is a good start. Thanks.
01:16:24 <Cale> f :: (Integer -> Bool) -> Bool  say, computing the next value of the cellular automaton at 0
01:16:33 <startling> what happens if I lie and say "forein import ccall "whatever" whatever :: IO () ?
01:16:38 <startling> when it's really a CInt?
01:16:54 <Cale> arbn: 2D cellular automata just use a monoid of pairs of integers under addition
01:17:11 <startling> or should I just do whatever = c_whatever >> return () ?
01:19:40 <hiptobecubic> arbn, there's an example of the cellular automaton on sigfpe i think
01:19:48 <snorble_> Is it possible to configure cabal to leave the source unpacked in the packages directory after "cabal install"?
01:20:26 <Cale> http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
01:21:07 <mietek> arbn: any ideas?
01:21:15 <arbn> Ah. OK. Thanks. I'll stare and poke at that some.
01:22:10 <ClaudiusMaximus> snorble_: there's cabal unpack, which does something slightly different (unpacks to a new directory under current direcctory)
01:23:31 <Cale> arbn: he's using a couple of lists with an element in between them in that code rather than a function from Integer, but of course that's the same thing (however, the lists will perform much better after a few iterations)
01:29:21 <arbn> mietek: I think it is an issue with how yesod devel determines when a rebuild is required, probably.
01:29:56 <arbn> mietek: You seem to be correct, that just running the executable in Development mode does not do that.
01:30:05 <mietek> OK
01:30:10 <mietek> I'll probably downgrade to 7.4.1 anyway
01:30:31 <snorble_> ClaudiusMaximus: just thought it would be nifty to have the source of every library I install easily accessible, guess it's pretty trivial to write a script to unpack them.
01:31:18 <ClaudiusMaximus> there's some haddock option to hyperlink source to documentation
01:31:28 <ClaudiusMaximus> not sure how it integrates with cabal
01:31:38 <mietek> Sadly, it does not.
01:31:47 <mietek> I was just looking into that yesterday.
01:32:13 <ClaudiusMaximus> http://hackage.haskell.org/trac/hackage/ticket/534
01:33:16 <mietek> It's been an issue for over 4 years: http://hackage.haskell.org/trac/hackage/ticket/517 http://hackage.haskell.org/trac/hackage/ticket/534
01:33:19 <mietek> There's a manual workaround: http://vorotylo.livejournal.com/68074.html
01:34:05 <ClaudiusMaximus> http://hackage.haskell.org/trac/hackage/ticket/517#comment:6
01:35:46 <snorble_> Thanks
01:36:21 * ClaudiusMaximus might try it when he's brave enough to get a ghc-7.6
01:39:47 * oish waves
01:40:14 <oish> anyone on here have a preference for a library for XML parsing?
01:45:10 <arbn> oish: Here's a tip‚Ä¶ use one that compiles on the latest GHC. I've run into so many packages that don't.
01:45:48 <arbn> Hackage dependency hell seems to especially thwart the compilation of the XML libraries.
01:55:57 <oish> arbn: thanks
01:56:33 <oish> will keep an eye out for that...
01:57:11 <arbn> oish: Also, have a look at hxt.
01:57:22 <arbn> http://hackage.haskell.org/package/hxt
01:58:39 <arbn> It's relatively new, is designed pretty well, and there's a large family of additional modules that build on it.
01:58:50 <arbn> Including a module for XPath, if that's your thing.
02:06:28 <gienah> hxt 9.3.1.0 looks like fun, it wants network >= 2.4
02:07:45 <Polarina> gienah, it's scary, I know.
02:09:22 <hpaste> killy9999 pasted ‚Äúproblem with type synonym‚Äù at http://hpaste.org/76266
02:09:41 <hpaste> killy9999 pasted ‚Äúproblem with type synonym‚Äù at http://hpaste.org/76267
02:09:57 <killy9999> hm...
02:10:13 <killy9999> what am I doing wrong?
02:10:49 <Polarina> killy9999, what's the type signature of R.map?
02:11:04 <killy9999> (Shape sh, Source r a) => (a -> b) -> Array r sh a -> Array D sh b
02:11:26 <shachaf> killy9999: What's r?
02:11:31 <killy9999> associated type
02:11:40 <shachaf> "myType" has to start with an uppercase letter.
02:11:42 <shachaf> For one.
02:12:08 <killy9999> shachaf: it does in the real code, I shortened it here for readibility
02:12:31 * gienah thinks the biggest problem with htx wanting network >= 2.4 is that cabal-dev wants network < 2.4
02:12:32 <killy9999> s/readibility/readability
02:12:33 <shachaf> Well, there are several bugs in your shortened version, so I can't say much about this.
02:13:05 <killy9999> well, that's actually a minimy (non)working example
02:13:17 <killy9999> and my problem is I don't see these bugs
02:13:43 <killy9999> code works fine if I comment out code signatures
02:14:08 <killy9999> so the problem is my type synonym. I introduced it to savemyself some typing when handling DIM1 Double arrays
02:14:09 <shachaf> What if you ask ghci for the types and then put in the inferred types?
02:14:12 <Polarina> killy9999, what's the infered signature then?
02:14:16 <shachaf> Oh.
02:14:26 <shachaf> Well, "MyType" uses the name "r" but there's no "r" in scope there.
02:14:31 <shachaf> So it doesn't make any sense.
02:14:58 <killy9999> shachaf: but r is in the constraint. Isn't that OK?
02:15:26 <shachaf> Oh, maybe it inserts an implicit forall.
02:15:34 <shachaf> Do you *intend* to have a forall there?
02:17:34 <killy9999> Polarina: the code works if I use type signature like this:
02:17:35 <killy9999> (Source r Double) => Array r DIM1 Double -> Array D DIM1 (Double, Double)
02:17:54 <killy9999> shachaf: honestly speaking I am not sure, but I tried adding forall and that didn't help
02:18:24 <shachaf> killy9999: With the type synonym it turns into this:
02:18:34 <shachaf> (forall r. (Source r Double) => Array r DIM1 Double) -> Array D DIM1 (Double, Double)
02:18:39 <shachaf> That's a very different type.
02:19:09 <killy9999> hm? But why? I mean r doesn't reach the return type anyway
02:19:39 <killy9999> sorry, maybe this is a newbie question, but I guess I'm not that good with Haskell's type system yet
02:19:51 <killy9999> after 6 months or so of using it :|
02:20:21 <dibblego> tips for this ugly function? https://gist.github.com/3888095
02:20:38 <Polarina> killy9999, it's the extensions... they do bad things to you.
02:21:22 <shachaf> Polarina: It's no different without the extensions.
02:22:10 <killy9999> Polarina: sure, if I'll find a way to do this without extensions...
02:22:29 <oish> arbn: yeh, had looked at hxt; I'm just writing up a toy xml parser i made to learn parsec -- want to direct ppl who end up on my blog looking for something actually useful to a proper lib ;-)
02:22:49 <oish> so i'll send them to hxt
02:23:09 <dibblego> I use HXT for GPS track logs and OSM map data ‚Äî works well
02:23:22 <dibblego> I think others use that library for android/iphone apps too
02:23:45 <oish> dibblego: nice
02:25:30 <killy9999> so? Is there any way to achieve what I'm trying to do?
02:25:52 <killy9999> that is to introduce type synonym that contains a type variable?
02:26:22 <nand`> (I only caught the tail wind of this discussion) pipe along the type variable?
02:26:47 <nand`> forall r. Foo r a b -> Foo r b c
02:27:36 <killy9999> hm...
02:28:06 <killy9999> I did something diferent (give me a moment to annotate my paste)
02:28:47 <hpaste> killy9999 annotated ‚Äúproblem with type synonym‚Äù with ‚Äúproblem with type synonym (annotation)‚Äù at http://hpaste.org/76267#a76268
02:29:02 <killy9999> but that's very verbose
02:29:10 <killy9999> I used type synonym to save somy typing
02:29:27 <killy9999> so this solution is not what I'm trying to do
02:29:32 <shachaf> You could make a second synonym for the constraint...
02:29:39 <shachaf> Or you could make something that takes the return type as an argument.
02:29:47 * killy9999 wonders if existencial quantification would work
02:30:04 <shachaf> type MyType a = (Source r Double) => Array r DIM1 Double -> a
02:30:15 <shachaf> foo :: MyType (Array D DIM1 (Double,Double))
02:31:00 <killy9999> I guess that will obscure the readability of my types signatures
02:31:01 <shachaf> killy9999: What does existential quantification have to do with it?
02:31:21 <killy9999> but that's a nice trick, I'll note it down - might be useful some day
02:32:22 <nand`> not exactly existential quantification, but a newtype with the constraint on the constructor would pass it along when pattern matching
02:32:44 <killy9999> mhm
02:32:51 <shachaf> nand`: ?
02:33:31 <killy9999> shachaf: I thought that EQ would allow me to hide type variable, but I guess I can do that already with Rank2Types
02:34:15 <nand`> oh, not a newtype, but a regular ‚Äòdata‚Äô would work
02:35:05 <shachaf> nand`: ?
02:35:22 <nand`> data OrdList a = Ord a => OL [a];  f (OL xs) = sort xs; f :: OrdList a -> [a]
02:36:04 <nand`> so for your example I guess data MyType r = Source r Double => MT (Array r DIM1 Double); fun :: MyType r -> Array D DIM1 (Double, Double)
02:38:11 <nand`> oh, still registers as existential quantification for GHC; since it asserts the instance I guess
02:40:40 <killy9999> nand`: thanks
02:40:54 <killy9999> but this will still force me to add a constraint for r
02:41:02 <killy9999> and I was trying to avoid verbosity :)
02:41:13 <killy9999> so I guess I'll just give up on that synonym
02:56:46 <Guest323> hello
03:29:21 * hackagebot arbb-vm 0.1.1.18 - FFI binding to the Intel Array Building Blocks (ArBB) virtual machine.  http://hackage.haskell.org/package/arbb-vm-0.1.1.18 (JoelSvensson)
03:29:23 * hackagebot arbb-vm 0.1.1.20 - FFI binding to the Intel Array Building Blocks (ArBB) virtual machine.  http://hackage.haskell.org/package/arbb-vm-0.1.1.20 (JoelSvensson)
03:40:24 <startling> how do I deal with c's wchar_t in haskell? stick them in strings and use the things in Foreign.C.String?
03:40:37 <startling> or is there some easier way?
03:46:49 <shachaf> That depends on what wchar_t is.
03:47:07 <shachaf> It means something very different on Windows and UNIX, if I remember correctly.
03:50:22 <Kinnison> Hello all.  I am very new to Haskell (a few weeks of tinkering) but I am amusing myself by trying to work through turning a program I wrote into a DPH test case for myself
03:50:44 <Kinnison> Unfortunately, following http://www.haskell.org/haskellwiki/GHC/Data_Parallel_Haskell is proving difficult because I am getting compiler errors of the form:
03:50:53 <Kinnison>     Failed to load interface for `Data.Array.Parallel'
03:50:53 <Kinnison>     It is a member of the hidden package `dph-lifted-vseg-0.6.1.2'.
03:51:03 <Kinnison> Is there something obvious I'm missing?
03:51:29 <Kinnison> I get complaints that ghc knows nothing about -fdph-par if I put that on the commandline, so I tried removing it which produced that error
03:51:57 <Kinnison> My guess is that the removal of -fdph-par is causing the error I'm seeing, but I have no idea how to solve the
03:52:00 <Kinnison> ghc: unrecognised flags: -fdph-par
03:52:03 <Kinnison> which I get if I leave it on the command line
03:52:21 <Kinnison> (I apologise if this is horrifically newbie-like, but I would like to continue playing :-)
03:53:34 * Kinnison should probably add that he's using ghc as packaged in Ubuntu 12.04 (gch 7.4.1)
03:53:39 <Kinnison> ghc 7.4.1 even
03:54:40 <adnam> Kinnison: did you install dph?
03:55:40 <Kinnison> I did 'cabal install dph-examples' and that completed
03:55:56 <Kinnison> I have a ~/.cabal full of stuffs
03:56:01 <alephomega> It says it's hidden: usge ghc-pkg to expose it.
03:56:39 <Kinnison> Can you explain how I do that?
03:56:48 <Kinnison> (Sorry, I'm being horribly newbie here :-)
03:57:31 <alephomega> I... don't remeber the syntax.
03:57:40 <Kinnison> I did ghc-pkg expose dph-lifted-vseg
03:57:59 <Kinnison> and now the compiler gives me a whole bunch more errors (which I expected since I've not recoded this in DPH yet :-)
03:58:12 <Kinnison> I'm really enjoying Haskell
03:58:29 <alephomega> ghc-pkg expose blah
03:58:42 * alephomega sighs...
03:58:56 * Kinnison grins
03:59:01 <Kinnison> This is exciting :-)
03:59:06 <alephomega> Indeed.
03:59:09 <alephomega> Haskell is exciting.
04:00:20 <Kinnison> I have emacs+flymake+hlint going and it's proving to be good fun to remove all the red underlines :-)
04:00:54 <alephomega> Heh. :)
04:01:29 <alephomega> I should really learn how to use emacs, for completion's sake...
04:02:00 <alephomega> But I already have trouble not hitting "Esc:wq" anytime I'm editing anything.
04:02:18 <alephomega> Adding more bizarre incantations seems like a bad plan.
04:03:32 * alephomega is off to learn some universal algebra.
04:03:33 <alephomega> cheers.
04:08:51 <Kinnison> :-)
04:09:00 <Kinnison> *** Vectorisation error ***
04:09:00 <Kinnison>     Tycon not vectorised:  []
04:09:04 <Kinnison> Boo hiss :-(
04:09:23 * hackagebot hosc 0.11.1 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.11.1 (PaoloVeronelli)
04:09:27 * killy9999 is playing with REPA
04:11:24 <paolino> When gtk is planned to work with 7.6.1 ?
04:12:20 <paolino> The darcs version is is still  not compiling :-/
04:12:53 <paolino> there is a dpatch around, but archlinux doesn't handle it
04:13:56 <hamishmack> paolino: darcs get hamish@patch-tag.com:/r/hamish/gtk2hs
04:14:31 <hamishmack> also has Gtk3 patches (-fgtk3)
04:16:46 <paolino> to use glade 3 ?
04:17:25 <hamishmack> I have not tried glade
04:17:59 <paolino> it's good I'm using stow, even darcs doesn't compile with 7.6.1
04:20:11 <paolino> thanks hamishmack , I will feed back when ever my atom machine will finish all this :-P
04:26:26 * MagneticDuck is back (gone 00:16:53)
04:28:16 <maukd> MagneticDuck: please turn that off
04:28:35 <MagneticDuck> er, sorry
04:28:43 <MagneticDuck> using it for other channels
04:28:50 <MagneticDuck> I can turn it off for #haskell?
04:29:00 <Nereid> ask your irc client
04:29:41 <maukd> I recommend you don't use it in any channels
04:30:01 <maukd> anyone who cares can simply check your 'away' status
04:30:45 <nomeata> Interesting, I don‚Äôt even see what MagneticDuck should turn off.
04:30:58 <nomeata> ah, nevermind, spotted it
04:32:27 <mcstar> i can see when he is here, all my magnetic ducks turn towards my computer
04:35:19 <wlangstroth> magnetic ducks in a row?
05:15:43 <cornihilio> hey, is it possible to use a do for a case branch, so I can create a variable to return?
05:16:15 <maukd> I don't understand the question
05:16:21 <maukd> the answer to the first part is "yes"
05:16:31 <maukd> I don't know what the second part means
05:22:48 <cornihilio> uh... so for this https://gist.github.com/3888390 I have an error saying Couldn't match expected type `Either BL.ByteString t0' with actual type `PacketSimple' in the do expression
05:23:25 <cornihilio> I know that second part isn't the best way of phrasing it. what's a better way of saying that?
05:23:40 <Kyraimion> cornihilio:  The branches of case all have to have the same type. So if your entire case expression is of type IO (IORef a) you can have a branch that creates and returns an IORef
05:24:31 <Kyraimion> cornihilio:  Looks to me like you don't need do (no monad involved) but rather just let packet = (...) in Right (...)
05:25:24 <maukd> cornihilio: saying what?
05:25:48 <cornihilio> Kyraimion: thank you! that's very helpful!
05:26:11 <cornihilio> maukd: the part you didn't understand, creating a variable
05:26:33 <Kyraimion> cornihilio:  https://gist.github.com/3888397
05:26:50 <maukd> cornihilio: are you asking me how to phrase something I don't understand?
05:26:51 <Kyraimion> cornihilio:  You are not creating a variable, you are just binding a value to a name
05:27:20 <zebr> http://sprunge.us/gJQO # currently unable to install pandoc due to zip-archive compiler errors. what should i do? >.>
05:27:35 <cornihilio> but I thought a variable was a name representing a value?
05:27:56 <cornihilio> http://en.wikipedia.org/wiki/Variable_(computer_science)
05:28:05 <cornihilio> is that the wrong term for haskell?
05:28:12 <maukd> no
05:28:25 <cornihilio> so I was misusing it?
05:28:37 <maukd> unknown
05:28:41 <cornihilio> ?
05:28:43 <maukd> I still have no idea what you're trying to say
05:29:10 <Kyraimion> cornihilio:  "In computer programming, a variable is a storage location and an associated symbolic name".
05:29:17 <cornihilio> in python, in this statement "foo = 1",  foo is a variable
05:29:28 <maukd> cornihilio: no
05:29:31 <Kyraimion> packet is not a storage location, you can't assign a value to it,
05:29:33 <maukd> not according to your definition
05:29:42 <nand`> ‚Äòvariables‚Äô are usually called that because their value can vary
05:30:04 <Kyraimion> nand`:  Unless they are constant...
05:30:06 <maukd> cornihilio: 'foo' doesn't represent the value 1, it represents a mutable cell
05:30:37 <cornihilio> "an associated symbolic name (an identifier) which contains some known or unknown quantity or information, a value."
05:30:40 <Kyraimion> maukd:  Isn't that what a variable is?
05:31:11 <maukd> Kyraimion: depends on how you define "variable"
05:31:46 <Saizan> cornihilio: in haskell what we call variables are more like variables in algebra, they are names for some value but they aren't storage location which can be updated
05:32:07 <Saizan> cornihilio: if you want storage locations you need to use an explicit reference type, like IORef
05:32:13 <cornihilio> Saizan: can you link me to a page talking about that?
05:32:30 <cornihilio> is that an advanced topic?
05:32:36 <Kyraimion> cornihilio:  No
05:32:47 <Saizan> cornihilio: IORef, you mean?
05:33:09 <cornihilio> what 'variable' means for haskell people
05:33:40 <sixohsix> this is probably an annoying question but‚Ä¶ why does a 60 mb tarfile for ghc become 580 mb on disk?
05:33:43 <nand`> generally nothing
05:33:50 <merijn> cornihilio: An identifier for an arbitrary (but not yet known) value
05:33:57 <merijn> sixohsix: GHC is really, really big?
05:34:07 <nand`> I prefer ‚Äòname‚Äô for names, ‚Äòvalue‚Äô for values and ‚Äòparameter‚Äô for abstractions
05:34:08 <Saizan> merijn: could also be known, if bound by a let
05:34:14 <cornihilio> so... should I just not use that when I talk about haskell code, because it's meaningless?
05:34:15 <sixohsix> merijn: but before it's untarred it's really really small.
05:34:20 <nand`> cornihilio: that would be a fair approach
05:34:25 <merijn> sixohsix: Source code compresses really well
05:34:42 <merijn> sixohsix: There is a 42kb zip file that expands to several petabyte somewhere on the web
05:34:47 <maukd> sixohsix: "by tarfile", do you mean a bzip2 file?
05:34:54 <maukd> quotefail
05:34:55 <Saizan> cornihilio: we routinely use the term variable, meaning a name for a value
05:35:13 <merijn> sixohsix: 4.5 petabyte even: https://en.wikipedia.org/wiki/Zip_bomb
05:35:15 <nand`> for some value of ‚Äòwe‚Äô
05:35:37 <sixohsix> i mean when i install the ghc package in Arch linux it's a 60 mb download, but it becomes 580 mb on disk.
05:35:49 <sixohsix> one way or another that ghc install holds a lot of redundant info.
05:35:56 <sixohsix> redundant but necessary i guess.
05:36:01 <sixohsix> i just want to know what it is.
05:36:26 <Kyraimion> cornihilio:  I shouldn't have said "You are not creating variable", but rather, what I meant was "You are not creating a reference cell", that is, you can't assign to it later, it's merely a new name for a value.
05:36:28 <merijn> sixohsix: 580mb sounds about right for a GHC install, I think?
05:36:40 <merijn> sixohsix: My binary install of ghc 7.6 is around 650 mb
05:37:00 <sixohsix> i'm not saying it's unusual, i'm just asking what the heck is in there.
05:37:13 <merijn> sixohsix: Libraries, code generators, optimisers, etc.
05:37:33 <Saizan> sixohsix: http://stackoverflow.com/a/4867236/1207745
05:37:34 <merijn> sixohsix: A bunch of libraries are built into/shipped with the compiler
05:38:22 <sixohsix> there we go, thanks Saizan.
05:39:23 <cornihilio> just googled a bit, I guess haskell implements something called 'tacit programming' and that's why variable is a pretty meaningless term
05:40:04 <maukd> what the hell is "tacit programming"
05:40:18 <sixohsix> next question, is the Haskell community really tiny? because I see Christopher Done's name everywhere. :P
05:40:38 <maukd> he's done a lot
05:40:39 <Kyraimion> cornihilio:  No, you have lambda abstraction, and you could call the formal parameters of a function "variables"
05:41:16 <nand`> cornihilio: what's ‚Äútacit programming‚Äù ?
05:41:25 <sixohsix> maukd: definitely, and he's got lots of neat projects. just funny that i keep seeing his name wherever i go on the net that's hs related.
05:41:27 <Saizan> http://en.wikipedia.org/wiki/Tacit_programming
05:41:36 <nand`> ah, I should have gone there first
05:42:19 <maukd> sixohsix: *sunglasses*
05:43:11 <nand`> cornihilio: some Haskellers enjoy point-free programming (aka ‚Äòpointless programming‚Äô), but it's not required
05:44:11 <Saizan> btw the "variables can vary" thing has been there before anyone used them for storage locations
05:44:13 <cornihilio> but I think (I am definitely not sure) that allowing for point free programming might be why variable is not the correct term?
05:44:32 <cornihilio> I have no support for that guess though
05:45:52 <Saizan> nope
05:45:57 <Kyraimion> cornihilio:  You can call the formal parameters of functions "variables", they are just not reference cells.
05:46:21 <Saizan> it's not just that you can call them, that's the most commonly used name
05:47:05 <cornihilio> is calling the names in a let binding 'variables' accurate?
05:47:33 <sipa> i've wondered about that as well... they don't really vary, do they?
05:48:09 <Kyraimion> You could argue that let foo = bar in e is syntactic sugar for (\foo -> e) bar, so foo is a variable.
05:48:35 <Algue-Rythme> Hello all !
05:48:47 <maukd> cornihilio: I call them variables
05:49:04 <maukd> Kyraimion: modulo types
05:49:17 <nand`> when referring to ‚Äúfoo‚Äù I say ‚Äòname‚Äô or ‚Äòidentifier‚Äô; when referring to the value of foo I call it a ‚Äòvalue‚Äô
05:49:51 <zebr> surely they're variables in the mathematical (not programming 'assignable') sense?
05:50:07 <Kyraimion> maukd:  What do you mean?
05:50:35 <zebr> though admittedly that does cause a little confusion wrt lambda bound variables
05:50:36 <maukd> > let f = show in (f 'a', f ())
05:50:37 <lambdabot>   ("'a'","()")
05:50:38 <b__> the proper way to rewrite lots of values in an array is mapM_ right?
05:50:44 <maukd> > (\f -> (f 'a', f ()) show
05:50:46 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:50:50 <maukd> > (\f -> (f 'a', f ())) show
05:50:51 <lambdabot>   Couldn't match expected type `()'
05:50:52 <lambdabot>         against inferred type `GHC.Types....
05:50:56 <nand`> Kyraimion: if ‚Äòfoo‚Äô is polymorphic the function would have to be higher-rank, which can't be inferred
05:51:00 <nand`> so you'd need to add a type signature
05:51:34 <nand`> basically, what maukd demonstrated
05:51:49 <merijn> sixohsix: dons is an android built to make all other haskell programmers look bad...
05:52:19 <sixohsix> sometimes i see his code and i feel that way ;_;
05:52:26 <merijn> sixohsix: Just like edwardk is secretly just a highly advanced contrivance for finding edge cases in compilers
05:52:34 <sixohsix> lol
05:52:40 <nand`> > ((\f -> (f 'a', f ())) :: (forall a. Show a => a -> String) -> (String, String)) show
05:52:41 <lambdabot>   ("'a'","()")
05:52:53 <sixohsix> i'm actually a robot for asking stupid yet poignant questions.
05:53:20 <merijn> sipa: They're variables in the sense that a variable may have different values in different applications of the function
05:53:21 <Kyraimion> Apparently, rank-2 types could actually be inferred. But that's probably not enough anyway.
05:53:46 <nand`> edwardk is an algorithm set to program every conceivable library via depth first search
05:53:47 <merijn> sipa: So they vary between function applications, just not within one function
05:54:28 <nand`> Kyraimion: even so, if foo was rank 2 the function would be rank 3
05:54:36 <sipa> merijn: fair point
05:54:37 <nand`> which can still be inferred (theoretically) in the former case
05:55:00 <ski> zebr : variables are commonly bound in math as well
05:55:00 <sipa> merijn: it's the same in math, actually
05:56:02 <Kyraimion> nand`:  That's what I meant by "not enough"
05:56:16 <nand`> indeed
05:57:10 <zebr> ski: more often akin to a 'let', i would think
05:57:27 <zebr> ski: but not in function theory or w/e obv
05:58:58 <ski> also "big sum","big product",integral notation, Leibniz derivative notation, limit notation, set comprehension, quantifiers
05:59:29 * hackagebot libssh2 0.2 - FFI bindings to libssh2 SSH2 client library (http://libssh2.org/)  http://hackage.haskell.org/package/libssh2-0.2 (IlyaPortnov)
06:01:01 <zebr> ski: fair point
06:01:30 <zebr> they're still called variables when they aren't, though :p
06:02:55 <ski> (when they aren't, in which sense ?)
06:02:59 <nand`> what's the origin of the usage of -- for comments in Haskell?
06:03:21 <Sculptor>  they should be called: invariables
06:03:33 <hpc> nand`: languages it's based on
06:03:48 <hpc> dunno where something like ML would have gotten it from
06:03:57 <nand`> I figured as much, but is there some ulterior source or did some early language developer just pull it out of his hat?
06:03:59 <t7> because pre-decrementing variables is evil
06:04:17 <merijn> t7: uh-oh, better not work on some of my C code...
06:04:37 <t7> post-decrement is allowed
06:05:04 * merijn uses pre-increment and pre-decrement in several places
06:05:25 * nand` tends to write code that avoids mutation and side effects
06:05:40 * merijn also tends to avoid writing C xD
06:06:54 <ski> hpc : (* in the MLs *)
06:07:19 <nand`> clearly, this is a case for stackoverflow
06:10:06 <maukd> nand`: probably English
06:11:14 <nand`> if so, UnicodeSyntax totally needs em-dashes for --
06:13:12 <maukd> that won't be confusing at all
06:15:21 <b__> is there a fast way to diff two lists of numbers?
06:15:39 <maukd> "diff" how?
06:16:12 <b__> diff [1..10] [2,4..10] = [1,3..10]
06:16:30 <ski> > [1 .. 10] \\ [2,4 .. 10]
06:16:31 <lambdabot>   [1,3,5,7,9]
06:16:32 <nand`> > zipWith (-) [1..10] [2,4..10]
06:16:34 <lambdabot>   [-1,-2,-3,-4,-5]
06:16:35 <nand`> oh
06:16:52 <nand`> I see what you meant, list difference
06:17:21 <b__> ah yes ski, that was what I was looking for
06:17:28 <b__> and nand` sorry for the bad example
06:18:29 <maukd> that's not a diff at all :-|
06:19:07 <nand`> is (\\) quadratic?
06:19:30 <nand`> or rather, the product of the lengths
06:20:01 <b__> yeah I'm afraid the performance makes it unusable for lists as large as I am working with
06:20:08 <t7> after doing a "sudo make install" theres not an easy way to remove it right?
06:20:15 <nand`> if you don't need order you could use Set and set difference
06:20:23 <nand`> ‚Äúmake uninstall‚Äù? :)
06:20:33 <b__> yes nand` seems like a good idea, I'll go try it
06:20:52 <nand`> or even IntSet
06:20:59 <b__> yeah
06:21:14 <nand`> O(n+m)
06:30:45 <b__> hm it's really slow
06:31:15 <b__> I bet it's faster if I use an array and toggle
06:39:22 <johnw> sniff, there hasn't been in update to lens in... days!
06:39:38 <Nereid> unbelievable!
06:39:55 <johnw> i know.  I keep updating cabal and keeping my fingers crossed
06:40:19 <johnw> I hardly even use record syntax anymore
06:40:20 <jonkri> anyone on ghc 7.0.4 that knows how to build happstack? i get "cabal: cannot configure threads-0.5.0.1", http://hpaste.org/76274
06:40:24 <johnw> only for pattern matching
06:57:35 <truble> hey could someone write for my a small program that records names stores them and them check if any name is repeated and delete it ;D
06:58:01 <hpc> cat | sort | uniq
06:58:09 <truble> i am studying medicine and anatomy is a pain in the ass so to remember things you have to check each word
06:58:12 <hpc> | tee outfile
06:58:52 <truble> btw also learning some haskell but i think i dont have the knowledge
06:59:10 <hpc> ah
06:59:34 <hpc> do you know how to do file IO?
07:00:19 <truble> in learn you a haskell i am starting guards but i cant spent all the time in haskell because you know i have to study
07:01:05 <jonkri> then haskell sounds like the wrong language for you
07:01:17 <jonkri> haskell takes a long time to learn compared to other languages
07:01:47 <jonkri> maybe you should learn, like, python or something
07:02:01 <jonkri> visualbasic? :)
07:02:12 <truble> i know a some c but i would like to see the implementation in haskell so maybe in the future i can expand it
07:02:34 <sixohsix> hah, wow‚Ä¶ so i was complaining about ghc being so big‚Ä¶ i have a 3.5 mb executable. stripped symbols and it went down to 2.5 mb‚Ä¶
07:02:42 <sixohsix> then gzipped it, and now‚Ä¶ 600 kb.
07:02:53 <truble> is just this semester the others i have more free time
07:02:55 <ion> jonkri: No. If you already know language A and language B is very similar but language Q is very different, it will be faster to learn B than Q. That completely depends on whether you know A.
07:03:00 <sixohsix> why ghc so fat, yo?
07:03:11 <hpc> sixohsix: is that ghc itself?
07:03:17 <hpc> or programs compiled with it?
07:03:22 <sixohsix> hpc: no, it's an application of mine.
07:03:25 <hpc> ah
07:03:43 <ion> You can link dynamically.
07:03:44 <jonkri> ion: yeah, ok, that may be right
07:03:45 <truble> so would someone help?
07:03:46 <sixohsix> but previously i was complaining how the ghc compiler and libs expand from 60 mb to 580 mb on disk when de-gzipped.
07:04:07 <hpc> yeah, most of it is static linking
07:04:08 <strebe> truble: if you have some time this semester, consider reading http://book.realworldhaskell.org/read/ and/or http://learnyouahaskell.com/ . The former covers file I/O quite early on
07:04:17 <hpc> try running "ldd" on your program
07:04:37 <truble> Ok .
07:05:17 <hpc> it shows you what's linked in
07:05:33 <strebe> truble: here's about half your program - http://zvon.org/other/haskell/Outputprelude/readFile_f.html
07:05:37 <hpc> ghc also leaves some debugging info in the binary
07:05:47 <hpc> and you have your own code, plus the RTS
07:06:07 <hpc> the ghc RTS can do some pretty neat magic, depending on how you build it
07:06:18 <truble> i know it is easy but i dont manage the concepts yet
07:06:26 <hpc> you have garbage collecter, lightweight threads, etc
07:10:53 <hpc> i make a lot of monads, just to pass () to every single one of them...
07:11:14 <hpc> but do-notation is so nice!
07:12:00 <strebe> truble:  if you ask specific questions, this channel tends to be quite helpful, but asking someone to write the program for you is a bit harder to deal well with
07:12:46 <truble> stores names check if names arent repeated ;P
07:12:58 <truble> display names xD
07:15:07 <strebe> one name per line?
07:18:43 <zomg> truble: well since you study medicine you will be able to afford to hire someone to write those apps for you when you become a doctor
07:18:46 <zomg> lol
07:19:05 <truble> shure
07:19:29 <strebe> truble: try to write it, and ask specific questions, and i'd be shocked if you didn't get help
07:19:58 <truble> lol ok ...
07:19:59 <truble> ;D
07:20:31 <truble> 4 years ahead
07:20:49 <t7> ewho is Csaba Hruska ?
07:21:00 <strebe> truble: have you done any programming before?
07:21:27 <truble> as a job no as a little hobby yes
07:21:56 <atriq> What's a better name for mempty
07:22:10 <atriq> Don't say something like "Steve"
07:22:13 <strebe> truble: yeah, I meant as a hobby
07:22:34 <cmccann> atriq, Steve is a data constructor so clearly not
07:22:40 <cmccann> but "steve" would work
07:22:40 <Clint> numpty
07:22:45 <atriq> :)
07:23:00 <truble> not really Programming ...
07:23:10 <cmccann> I often alias mempty as "unit", and mappend as (++).
07:23:34 <atriq> mappend already has (<>), which I prefer
07:23:48 <atriq> And some people pronounce () as "unit"
07:23:59 <atriq> So... unit == unit
07:24:06 <cmccann> (<>) is a recent-ish thing
07:24:26 <cmccann> and wasting a perfectly good operator like (++) on a specific type annoys me
07:24:48 <cornihilio> hey, what does "Prelude.undefined" mean as an error? I'm using !! on a list btw
07:24:56 <atriq> I'm gonna actually stick with "steve"
07:24:56 <cornihilio> it's a runtime error
07:25:05 <cmccann> anyway, there's a bajillion things that could be called "unit", including both pure and return
07:25:21 <cornihilio> I'mg guessing out of bounds? but I've seen that error before, and it mentioned being out of bounds (at least I think so).
07:25:27 <cmccann> mempty is the one I prefer to let actually have that name
07:25:32 <cmccann> > undefined
07:25:33 <lambdabot>   *Exception: Prelude.undefined
07:26:40 <cornihilio> thanks!
07:26:50 <cornihilio> on another note, is there a way to make a record field optional?
07:27:17 <cmccann> make its type use "Maybe"?
07:27:27 <cmccann> I don't think there's any way to make initializing a field optional
07:27:31 <cmccann> or to give it a default value
07:27:32 <cmccann> unfortunately
07:28:14 <cmccann> the usual approach is to define a default value for the record type and then "update" that with the fields you care about.
07:29:44 <atriq> Can the Monoid instance for Endo be extended across ALL categories?
07:30:27 <atriq> newtype Endo (~>) a = Endo {appEndo :: a ~> a}; instance Category (~>) => Monoid (Endo (~>) a) where...
07:30:33 <atriq> Actually, of course it can
07:30:37 <hpc> atriq: yes
07:30:41 <cmccann> heh
07:30:42 <atriq> My question really should have been "Should it"?
07:30:55 <hpc> for extra fun, you don't even have to change ANY Endo code at all
07:31:01 <hpc> you just import a different (.) and id
07:31:45 <hpc> (er, i suppose you would have to pass the category but you see my point)
07:32:04 <atriq> Yeah
07:33:26 <profil> Hey guys, I'm playing around with QuickCheck and wondering if its possible to create an "instance Arbitrary Pos", where "type Pos = (Int,Int)"
07:34:01 <profil> I'm getting an error, "Illegal instance declaration for `Arbitrary Pos'
07:34:03 <profil> "
07:34:13 <atriq> Already exists
07:34:31 <atriq> Also, you can't make instances for type synonyms, you have to expand it
07:34:52 <maurer> Hey, do people have preferences/experiences with different sql db abstraction layers? hsql? haskelldb? Any reccomendations?
07:34:56 <atriq> If you want to make a completely new one, make "data Pos = Pos {x :: Int, y :: Int} or something
07:34:58 <atriq> "
07:35:09 <maurer> (this is for interacting with an existing schema, so persistent and similar are out)
07:35:14 <profil> atriq: ah okay, that's what I thought..
07:35:27 <Kyraimion> With -XTypeSynonymInstances you can, actually
07:36:01 <profil> atriq: that's seems like a bit to much for what I'm doing right now, would it be better to use "==>" in the property?
07:36:45 <atriq> I'm afraid I don't know Quickcheck very well, and I'm just reading it now
07:36:57 <atriq> I can't tell, sorry
07:38:58 <profil> okay, in the course I'm taking we use QuickCheck pretty much, our lecturer is one of the creators of it
07:43:32 <profil> another question, is it possible to do "pos >= (0,0) && pos <=(8,8)" where pos is a Pos
07:43:35 <profil> ?
07:44:00 <hiptobecubic> not if Pos doesn't have Ord
07:44:21 <hiptobecubic> you can define it
07:44:31 <profil> hiptobecubic: Pos is "type Pos = (Int,Int)"
07:44:37 <hpc> ah, then yes
07:44:43 <atriq> hiptobecubic, I'd use Data.Ix.inRange
07:44:46 <atriq> Wait
07:44:49 <atriq> Yes
07:44:55 <hpc> > (0, 100) < (8, 8)
07:44:56 <lambdabot>   True
07:45:13 <hpc> > inRange (0, 100), ((0, 0), (8, 8))
07:45:15 <lambdabot>   <no location info>: parse error on input `,'
07:45:21 <hpc> > inRange (0, 100) ((0, 0), (8, 8))
07:45:22 <lambdabot>   True
07:45:28 <hpc> O.o
07:45:30 <profil> hmm, it doesnt work like I want
07:45:36 <hiptobecubic> @src inRange
07:45:36 <lambdabot> Source not found. Are you on drugs?
07:45:39 <hpc> :t inRange
07:45:40 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Bool
07:45:40 <atriq> > inRange ((0,0), (8,8)) (0, 100)
07:45:42 <lambdabot>   False
07:45:44 <hpc> oh, dammit
07:45:47 <jyeo> > let fix f = f (fix f)
07:45:48 <lambdabot>   not an expression: `let fix f = f (fix f)'
07:45:49 <hpc> > flip inRange (0, 100) ((0, 0), (8, 8))
07:45:50 <profil> > (1,-1) >= (0,0)
07:45:51 <lambdabot>   True
07:45:51 <lambdabot>   False
07:45:55 <hpc> there we go
07:46:05 <hpc> use inRange range value
07:46:05 <atriq> hpc, you had it backwards and lambdabot played its tricks on you
07:46:12 <hpc> i know :P
07:46:19 <jyeo> > fix f = f (fix f)
07:46:21 <lambdabot>   <no location info>: parse error on input `='
07:47:31 <gds> @let fix f = f (fix f)
07:47:31 <lambdabot>  <local>:11:11:
07:47:32 <lambdabot>      Ambiguous occurrence `fix'
07:47:32 <lambdabot>      It could refer to either...
07:47:36 <hpc> @src fix
07:47:36 <lambdabot> fix f = let x = f x in x
07:48:03 <rfdickerson> I was wondering if the haskell community (and FP) have looked into solving problems in signal processing functionally
07:48:04 <hpc> (same definition as yours, with some knots tied for sharing)
07:48:23 <hpc> rfdickerson: signal processing as in radio?
07:48:33 <hiptobecubic> as in the field
07:48:39 <rfdickerson> as in convolution and filters
07:48:42 <hpc> i am sure you could do that nicely with one of the stream libraries
07:49:00 <hpc> or pipes or conduit
07:49:13 <rfdickerson> oh, i'll check that out
07:49:44 <hpc> disclaimer: i have never used them and only cursory...-ly read their documentation)
07:49:53 <hpc> however that's adverb'd
07:50:22 <spaceships> scanned?
07:50:25 <spaceships> skimmed?
07:50:34 <gds> cursorily ?
07:52:58 <hpc> skimmed
08:05:34 <jdnavarro> I see these guards (http://hackage.haskell.org/packages/archive/network/2.4.0.1/doc/html/Network-Socket-Internal.html#g:4) are being used when sending and receiving data from a socket. Does that mean I can safely have multiple threads trying to send or receive data to/from a socket?
08:13:11 <jdnavarro> I just found an answer to my question: http://www.haskell.org/pipermail/glasgow-haskell-users/2004-December/007536.html
08:25:30 <kdridi_> how can i deal with config file needed by a program without passing them as parameters of function nor reading them every time i need them ?
08:25:38 <kdridi_> is there any way ?
08:26:24 <maukd> @hackage reflect
08:26:24 <lambdabot> http://hackage.haskell.org/package/reflect
08:26:25 <t7> who i brian@lorf.org aka BSL
08:26:33 <t7> who is *
08:26:46 <maukd> @hackage reflection
08:26:47 <lambdabot> http://hackage.haskell.org/package/reflection
08:27:14 <hpc> kdridi_: use Reader
08:27:22 <hpc> @unmtl ReaderT Config m a
08:27:22 <lambdabot> Config -> m a
08:27:30 <hpc> :t ask
08:27:31 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
08:27:44 <hpc> it does all the annoying argument passing for you
08:27:53 <hpc> and to get the config, you "ask" for it
08:28:17 <maukd> :t ask show
08:28:19 <lambdabot> forall a. (Show a) => a -> String
08:28:22 <t7> why aren't tuples functors!
08:28:37 <hpc> :t asks show
08:28:38 <lambdabot> forall r (m :: * -> *). (Show r, MonadReader r m) => m String
08:28:40 <maukd> t7: 2-tuples are
08:28:53 <t7> maukd: do i have to import something?
08:30:15 <t7> maukd: are you sure?
08:31:11 <atriq> Is there an extension where you can do something like "a `flip foo` b"
08:31:41 <maukd> > fmap id (0,0)
08:31:43 <lambdabot>   (0,0)
08:32:13 <hpc> atriq: yes, i forget what it's called
08:32:17 <Nereid> > fmap (+1) (0,0)
08:32:18 <lambdabot>   (0,1)
08:32:22 <fmap> > ("a",succ) <*> ("b",0)
08:32:24 <lambdabot>   ("ab",1)
08:32:33 <t7> oh Control.Monad.Instances ofcourse ! that makes sense :P
08:33:12 <kdridi_> hpc, you think Control.Monad.Reader or Data.Global.Config ?
08:33:44 <hpc> ghc-man-completion isn't finding it :(
08:34:04 <hpc> kdridi_: what package is that config module?
08:34:16 <hpc> oh, found it
08:34:21 <kdridi_> http://hackage.haskell.org/packages/archive/global-config/0.3.1/doc/html/Data-Global-Config.html
08:34:40 <hpc> use reader
08:34:58 <hpc> :t local -- kdridi_: you never know when you might want this
08:34:59 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
08:35:00 <maukd> or reflection
08:35:25 <kdridi_> humÖ thx a lot, i'm having a look :)
08:35:47 <t7> @pl (\(x, y) -> (fromIntegral x, fromIntegral y)) <$> getMousePosition :: IO (GLfloat, GLfloat)
08:35:47 <lambdabot> (fromIntegral *** fromIntegral) <$> getMousePosition :: IO (GLfloat, GLfloat)
08:36:24 <t7> :t fmap fromIntegral $ (1, 2)
08:36:25 <lambdabot> forall b t. (Num b, Num t) => (t, b)
08:37:58 <t7> (fmap $ fmap fromIntegral) getMousePosition :: IO (GLfloat, GLfloat)
08:38:03 <t7> @pl (fmap $ fmap fromIntegral) getMousePosition :: IO (GLfloat, GLfloat)
08:38:03 <lambdabot> fmap (fmap fromIntegral) getMousePosition :: IO (GLfloat, GLfloat)
08:38:36 <Nereid> t7: that won't work.
08:39:05 <Kyraimion> Is there a way to find out how many haskell threads are running at a certain point?
08:40:19 <t7> ah its bound by first type in tuple right?
08:40:54 <Nereid> t7: (***) is probably the way to go.
08:41:06 <t7> @hoogle (***)
08:41:06 <lambdabot> Control.Arrow (***) :: Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:41:53 <t7> > ((+1) *** (+2)) (1, 2)
08:41:54 <lambdabot>   (2,4)
08:42:20 <t7> still a bit awkward
08:42:28 <t7> a
08:42:41 <Abraxas> let's say i define: type Field = [Maybe Player] and i want to make an instance of the show class, casing on the Maybe; now if i start: instance Show Field... i run into the TypeSynonymInstances error
08:43:01 <Abraxas> how can i avoid this without using the corresponding pragma?
08:43:20 <Nereid> Abraxas: you could use a newtype instead
08:43:33 <Abraxas> how can i avoid newtype? :D
08:43:38 <Kyraimion> Abraxas:  instance Show [Maybe Player]; though that won't work, because [a] already has a Show instance
08:43:40 <Nereid> then you can't.
08:43:44 <Nereid> Kyraimion: indeed it won't.
08:44:02 <Nereid> Abraxas: a newtype is probably a good idea in any case.
08:44:48 <Kyraimion> Abraxas:  You might forgo a show instance and instead define a function prettyPrintField.
08:44:59 <Nereid> yeah
08:45:07 <Abraxas> newtype is considered unknown at this point
08:45:23 <hpc> you probably want to do prettyPrintField, plus a derived Show instance
08:45:28 <Kyraimion> Abraxas:  Data Field = Field [Maybe Player]
08:45:31 <hpc> one to look nice, other for debugging
08:45:34 <Abraxas> show is demanded
08:45:36 <Nereid> the purpose of show is pretty much to output a string that looks like a valid expression
08:45:49 <Nereid> well...
08:45:57 <hpc> it gets misused sometimes
08:46:10 <hpc> you can show filehandles, for instance
08:46:29 <Nereid> sure, but it shouldn't be used as a pretty printer.
08:46:32 <Abraxas> it is possible that i am on the wrong track using "type" and should use "data"
08:46:33 <hpc> > text "Text abuses it in an only-somewhat horrendous way"
08:46:34 <lambdabot>   Text abuses it in an only-somewhat horrendous way
08:46:54 <Abraxas> but that seemed wrong to me
08:46:55 <hpc> Abraxas: yeah, type aliases are not actually different types
08:47:02 <Abraxas> i know that
08:47:35 <Abraxas> ok, i can use just one value constructor
08:47:54 <Abraxas> that's not an ugly solution?
08:48:10 <Kyraimion> Abraxas:  Actually, newtype / data seems right to me, because it abstracts away the implementation details
08:49:12 <Kyraimion> Abraxas:  [Maybe Player] sounds a bit brittle anyway.
08:56:05 <jmcarthur> Abraxas: making a game?
08:57:05 <jmcarthur> Abraxas: you should hop into #haskell-game if you are
09:00:19 <Abraxas> no, just trying tic tac toe in haskell as a task
09:00:51 <davean> willb: 22
09:00:54 <davean> er, sorry
09:01:21 <Abraxas> with a code validation tool
09:01:48 <Abraxas> there is a certain outline for the program given you have to fill with code
09:11:25 <t7> @hoogle flip
09:11:25 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
09:11:25 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
09:11:26 <lambdabot> package Flippi
09:11:31 <otters> so correct me if I'm wrong, but attoparsec's module for lazy Text just re-exports the module for strict Text and adds a parse function that acts on Lazy
09:11:43 <otters> which means that all the combinators such as takeWhile are hardcoded to act on strict Text
09:22:38 <atriq> Wow, you're right
09:26:58 <donri> attoparsec has its own scheme for lazy consumption
09:32:29 <b__> not haskell related but pretty interesting: http://www.redbullstratos.com/live/
09:32:57 <t7> is there a sortBy style function that just takes an Ord  ::( a -> b)
09:33:11 <t7> Ord b :: (a -> b) -> [a] -> [a]
09:33:46 <alephomega> @hoogle (a->b) -> [a] -> [a]
09:33:47 <lambdabot> GHC.Exts sortWith :: Ord b => (a -> b) -> [a] -> [a]
09:33:47 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
09:33:47 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
09:34:24 <alephomega> sortWith, perhaps?
09:34:36 <jmcarthur> t7: no, but i always want one
09:34:57 <jmcarthur> t7: you can always say   sortOn = sortBy . comparing
09:35:05 <jmcarthur> that's isn't optimal though
09:35:44 <jmcarthur> more optimal is to map over the list, making tuples, sort on the appropriate component, then drop the unnecessary bits again
09:35:56 <jmcarthur> unless the f is already very fast (it usually is, at least)
09:36:30 <jmcarthur> huh i didn't know sortWith was already a thing
09:36:42 <t7> doesnt seem to work correctly
09:36:56 <jmcarthur> @src sortWith
09:36:57 <lambdabot> Source not found. My brain just exploded
09:37:01 <t7> > sortWith (+10) [5..1]
09:37:03 <lambdabot>   Not in scope: `sortWith'
09:37:03 <jmcarthur> @src GHC.Exts.sortWith
09:37:04 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:37:18 <t7> oh lol ignore me
09:37:24 <jmcarthur> heh
09:37:31 <jmcarthur> [5,4..1]
09:39:26 <otters> > [5..1]
09:39:27 <lambdabot>   []
09:39:30 <otters> > [5,4..1]
09:39:32 <lambdabot>   [5,4,3,2,1]
09:50:20 <t7> what does this mean in linear algebra ||v||
09:50:31 <sipa> norm of a vector
09:50:42 <t7> like unit vector?
09:51:02 <sipa> no, norm, aka "size"
09:51:07 <t7> aaah thanks
09:51:37 <sipa> for example the euclidean norm, ||(x,y)|| is sqrt(x*x+y*y)
09:51:51 <sipa> but there are other norms
09:51:55 <hpc> the unit vector is v/||v||
09:52:11 <hpc> er, unit vector in that direction
09:52:29 <sipa> v/‚à•v‚à•
10:00:41 <t7> my code is working :D this is a miracle
10:01:13 <JuanDaugherty> anyone succeeded in building haskell platform with 7,6?
10:05:24 <Xezlec> I was about to give up on Haskell because of the type system, but then I realized that there are compiler extensions that solve most of my problems...
10:05:57 <Xezlec> And it seems that compiler extensions are not quite seen as being so exotic or dangerous as they are in other languages...
10:06:16 <lispy> lack of cabal-dev (with the latest cabal) means I'm back to cabal hell.
10:06:31 <KirinDave> shachaf: Hey, am I going to see you today?
10:06:37 <Xezlec> But I'm wondering if there's any resource to be able to tell what extensions are safe to rely on?
10:06:54 <lispy> Xezlec: yeah, people have made lists
10:07:15 <Xezlec> lispy: where should I look?  I apparently suck at Google
10:07:15 <lispy> Xezlec: I don't know off the top of my head where such a list would be, but asking here should give you reasonable answers too
10:07:21 <Xezlec> ok
10:07:37 <lispy> MultiParameterTypeClasses is considered safe, for example
10:07:43 <Xezlec> thank God
10:07:54 <lispy> But that one is going to typically need FunctionalDependencies or TypeFamilies
10:08:05 <dcoutts> most are ok except for incoherent instances and undecidable instances
10:08:33 <Xezlec> Yes I was using fundeps before, but got rid of them when I realized they weren't in Haskell98
10:08:43 <Xezlec> Now I guess I shouldn't be so strict
10:08:49 <shachaf> KirinDave: Possibly.
10:08:51 <danharaj> undecidable instances isn't terribly unsafe, is it?
10:08:54 <shachaf> Should I go to the thing?
10:09:11 <KirinDave> shachaf: The city is a bit of a mess today what with the race and the game. Do plan your route carefully.
10:09:22 <dcoutts> danharaj: depends what you mean
10:09:27 <lispy> danharaj: how much do you like for your compilation jobs to terminate :)
10:10:00 <danharaj> lispy: I think it's pretty hard to get ghc to hang with undecidable instances unless you're looking for it :p
10:10:32 <lispy> danharaj: could be. I haven't used that extension before
10:11:06 <dcoutts> danharaj: so it's not so much the issue of typechecking termination, it's more about that style of type-level programming
10:11:17 <lispy> dcoutts: do you know if there are any plans to incorporate cabal-dev into cabal or to work with the cabal-dev folks to get cabal-dev working again?
10:11:21 <shachaf> KirinDave: How long is it going to go?
10:11:48 <danharaj> I thought there was a gsoc project to add sandboxes to cabal-install
10:11:53 <dcoutts> lispy: yes it's called cabal sandboxing and a student completed a GSoC on it this summer, he's still working on incorporating it
10:11:56 <Xezlec> Also, I was reading this: http://www.haskell.org/haskellwiki/GADTs_for_dummies and I was very confused because it seems like teh author is saying Haskell supports things it doesn't
10:12:05 <dcoutts> lispy: I don't know why cabal-dev isn't working (I didn't know it wasn't)
10:12:21 <KirinDave> shachaf: No idea
10:12:34 <KirinDave> I was going to show up and, you know, try and recruit other systems engineers to come work with me.
10:12:36 <KirinDave> :)
10:12:38 <Xezlec> Specifically, class instances that differ only by constraints.
10:12:57 <KirinDave> And also get advice on how to implement a lightweight binding to DynamoDB.
10:13:02 <Xezlec> When I try those I get an error.
10:13:13 <KirinDave> I'm not sure what the "clean" and least-resistance approach in in haskell for dealing with schemaless key-value datastores.
10:13:30 <KirinDave> I feel like what I want is a thing that can try to populate a Data definition from calls to AWS.
10:13:40 <KirinDave> But then every type wants a Maybe and it seems awkward.
10:13:46 <lispy> dcoutts: I just tried it again on something now that I finished upgrading to cabal 1.16. Looks like it does work with ghc-7.6 again, but I can't build cabal-dev against the latest cabal.
10:14:17 <lispy> dcoutts: so the problems I saw with cabal-dev and 7.6 I'll just ignore and make note to install cabal 1.16.
10:14:18 <dcoutts> lispy: oh, that's a different issue. you should be able to use your existing cabal-dev binary and a newer cabal binary together.
10:14:31 <gatlinjohnson> I have a question for anyone familiar with the finer points of repa
10:15:11 <danharaj> gatlinjohnson: shoot
10:15:28 <KirinDave> If anyone has any advice on how one WOULD write that kind of interface, I'd love advice
10:15:33 <gatlinjohnson> say I want to use a repa array to represent an adjacency matrix
10:16:02 <gatlinjohnson> and I want to map an operation over every cell in the matrix, which happens in parallel,
10:16:17 <KirinDave> Writing the code to send an authenticated request to Amazon; done.
10:16:26 <gatlinjohnson> would there be race conditions where modifying one cell could impact one of the parallel computations?
10:16:33 <Xezlec> "instance Float a => Complex a" and "instance Int a => Complex a" can't coexist, right?
10:16:39 <danharaj> gatlinjohnson: repa arrays are persistent.
10:16:46 <danharaj> So no.
10:16:59 <KirinDave> The question is how to go from a the untyped key-value set you get back from Amazon to a specific Data instance efficiently.
10:17:04 <gatlinjohnson> danharaj, just to clarify (and thanks for the prompt reply)
10:17:08 <KirinDave> Any papers or advice people have on this WOULD BE WELCOME. ;)
10:17:10 <dcoutts> gatlinjohnson: right, as danharaj says, the repa arrays are immutable, you can't write the operation to change them :-)
10:17:26 <gatlinjohnson> ah, cool. I'm going to be playing with recurrent neural nets
10:17:52 <rwbarton> Xezlec: you really want Complex to be the type class there?
10:17:59 <gatlinjohnson> and evaluating every neuron in parallel could be a problem
10:18:02 <gatlinjohnson> (in theory)
10:18:02 <dcoutts> gatlinjohnson: so you only need a flat array for the adjacency thing? no arrays of arrays?
10:18:11 <Xezlec> rwbarton: Sorry, let's call it ArbitraryClass then.
10:18:24 <rwbarton> Float isn't a type class either
10:18:32 <Xezlec> rwbarton: I meant Floating
10:18:33 <rwbarton> just trying to figure out what you really meant
10:18:46 <rwbarton> how about start over, try again :)
10:19:00 <gatlinjohnson> dcoutts: the shape would be 4 dimensional
10:19:02 <rwbarton> (in particular did you mean ArbitraryClass a or ArbitraryClass (Complex a))
10:19:08 <rwbarton> I guess in either case the answer is no
10:19:11 <gatlinjohnson> or 3d where each cell is an aray
10:19:18 <gatlinjohnson> *array. it might not matter
10:19:26 <dcoutts> gatlinjohnson: ok, and dense is ok?
10:19:36 <Xezlec> "instance Floating a => ArbitraryClass a" and "instance Int a => ArbitraryClass a" can't coexist, right?
10:19:50 <Xezlec> that's me trying again :)
10:20:00 <rwbarton> they cannot
10:20:03 <gatlinjohnson> yes. the algorithm I ultimately aim to implement is biased toward denser nets with minimal topology
10:20:11 <rwbarton> in fact once you have even one of those you can't have any other instances at all
10:20:12 <gatlinjohnson> so I'm not worried about wasting ram
10:20:36 <dcoutts> gatlinjohnson: ok, you're good then, repa should be fine
10:20:39 <parcs`> @check \x n -> not (n > 0 && x > 0) || x^n `rem` product [1..n] == 0
10:20:41 <lambdabot>   "Falsifiable, after 6 tests:\n2\n3\n"
10:20:48 <Xezlec> rwbarton: Because this page: http://www.haskell.org/haskellwiki/GADTs_for_dummies seems to be saying you can do stuff like that, and using it to introduce GADT's (which I don't understand)
10:21:16 <gatlinjohnson> dcoutts: cool, so when I evaluate one neuron and it recursively must go grab values at other cells, it'll have its own copy of the origin matrix
10:21:29 <rwbarton> where does it say that?
10:21:31 <gatlinjohnson> that would make sense since that's kind of Haskell's modus operandi but I like to make sure
10:22:02 <Xezlec> rwbarton: find the second box containing the "HasInt" definition
10:22:12 <Xezlec> rwbarton: the one that uses instances
10:22:15 <dcoutts> gatlinjohnson: oh, you can't have dependencies between elements in a parallel array (since then it couldn't be done in parallel)
10:22:22 <rwbarton> those last two overlap
10:22:34 <rwbarton> so you can't have both of the last two, that's true
10:22:36 <rwbarton> the rest are fine
10:22:55 <dcoutts> gatlinjohnson: that's unlike ordinary haskell lazy arrays which can have dependencies between cells (and lazy eval will just do it in the right order)
10:23:28 <gatlinjohnson> dcoutts: Ah, that's the rub. I might be better off then without repa? Because I imagine parallel evaluation of neurons is going to ultimately be faster
10:23:33 <dcoutts> gatlinjohnson: for parallel arrays you have to structure things so that all the elements can be calculated independently
10:23:38 <monochrom> heh, "random rubbish from previous versions"
10:23:49 <Xezlec> rwbarton: he goes on to say "You can compare it to the hypothetical definition we gave earlier. It's important to note that type class instances, as opposed to function statements, are not checked in order. Instead, the most _specific_ instance is automatically selected."  That seems to rely completely on that kind of thing being allowed.
10:24:02 <danharaj> relevant is the genericTraversal operation in repa
10:24:20 <dcoutts> gatlinjohnson: if it's something iterative where each element in the next array only depends on values from the previous array, then it's all fine
10:24:23 <gatlinjohnson> dcoutts: the only solution I could think of would be to have another dimension where new values are stored, and then one big "overwrite the old values" cell
10:24:45 <gatlinjohnson> er, one such *operation*
10:24:53 <dcoutts> gatlinjohnson: right, calculating a sequence of arrays, where each array can be evaluated in parallel. That's quite common.
10:24:55 <rwbarton> Xezlec: well, so. they may be using OverlappingInstances, which are Bad
10:25:13 <monochrom> "instance C a => D a" is very different from what the page really has: "instance C a => D [a] or D (UArray a) or ..."
10:25:17 <dcoutts> gatlinjohnson: so long as each intermediate array is big enough then you can get some performance improvement
10:25:32 <rwbarton> most of the instances there are not overlapping; but some are
10:25:43 <Xezlec> rwbarton: oh, that's what that does.  OK.  so why are they bad?
10:25:53 <rwbarton> no idea what this has to do with gadts anyways...
10:26:03 <lispy> gatlinjohnson: are you familiar with stencil computations?
10:26:21 <lispy> gatlinjohnson: that's what folks in other areas might call this.
10:26:24 <gatlinjohnson> lispy: if I do, not by that name
10:26:29 <gatlinjohnson> ah, thanks
10:26:37 <dcoutts> gatlinjohnson: e.g. consider a conway game of life sim, each element at time t only depends on the array from time t-1, all elements can be calculated in parallel
10:27:10 <dcoutts> gatlinjohnson: so you'll have to think about the data dependencies
10:27:14 <gatlinjohnson> dcoutts: ah, yes, I only need the array from t-1
10:28:42 <dcoutts> gatlinjohnson: I've written an article on exactly this, it's not quite published yet, if you send me an email I can send it to you
10:28:52 <dcoutts> the pre-pub version
10:29:01 <gatlinjohnson> basically, for each time step, in parallel for every neuron I see which ones feed into it, calculate a sum of their output * weight, and then store this new value (conceptually)
10:29:14 <gatlinjohnson> once I have that, I have no more use for anything older
10:29:25 <gatlinjohnson> dcoutts: sure, PM?
10:29:30 <dcoutts> 'k
10:30:06 <monochrom> that article demonstrates two fatal problems with the haskell wiki. problem 1: too polite to just delete obsolete stuff, see "rubbish from previous versions".  2: get carried away by writer's private excitement rather than staying focused and coherent for readers' sake, see section 4
10:31:38 <rwbarton> Xezlec, here is some discussion http://stackoverflow.com/questions/10942136/whats-so-bad-about-overlappinginstances
10:32:03 <monochrom> problem 1 is most lame. do people realize that the wiki system is also a version control system? so that you can go ahead delete stuff, it's safe, the stuff won't be lost?
10:32:43 <Xezlec> monochrom: Just ignorance of wikis I suppose.
10:32:59 <lispy> "The deprecated function catch has been removed from Prelude."  <-- so where is catch located now?
10:33:31 <Kyraimion> lispy:  Control.Exception
10:33:33 <monochrom> there is a different "catch" in Control.Exception
10:34:00 <lispy> I used that import and got a type error, so I assumed it was wrong
10:34:40 <monochrom> there is the same "catch" in System.IO.Error
10:35:37 <Springwight> What do you think the effect would be on a linked list if it were made of tuples?
10:36:00 <lispy> I think I have to look at the source of Distribution.ParseUtils to figure out what catch I want
10:36:41 <Kyraimion> lispy:  Prelude.catch is Control.Exception.Catch with a more restrictive type. There shouldn't be any errors
10:36:49 <Xezlec> rwbarton: So it sounds like the problem with them is just that GHC allows new instances to "propagate back" to the module that defines the class, instead of being visible only in the module where they're defined?
10:37:41 <rwbarton> new instances are automatically imported to any module that imports the module that contains them, and can change the behavior of code in that other module
10:38:36 <Xezlec> but if I import a module, I *expect* it to change the behavior of my code.
10:39:10 <alpounet> dcoutts, may i see it too?
10:39:19 <rwbarton> no you don't
10:39:48 <rwbarton> not if you don't use anything exported from that module
10:40:16 <Xezlec> Why not just change GHC so that instances not explicitly exported don't escape?
10:40:17 <rwbarton> or if you use something exported from that module in one function, you don't expect the behavior of some other function to change
10:40:36 <dcoutts> alpounet: it probably doesn't tell you anything you don't know, but I can if you like
10:40:49 <rwbarton> then you can easily run into instance incoherence problems
10:41:04 <dcoutts> alpounet: it's for a general audience, intro to the idea of parallel /= concurrent, with a little repa example
10:41:33 <rwbarton> the compiler is supposed to guarantee that if module A imports f from module B and g from module C then f and g will see the same instance X t
10:41:47 <hpaste> lispy pasted ‚Äúimport Control.Exception (catch)‚Äù at http://hpaste.org/76279
10:41:48 <rwbarton> or rather, that they won't see two different instances
10:41:59 <lispy> Kyraimion: does that help?
10:42:06 <alpounet> dcoutts, oh, alright. it's just that gatlin's helping out on my neural nets lib (which i just resumed working on), but i'll see with him how we can grab ideas from your paper's example :)
10:42:14 <maurer> Is there a good way to ask cabal why it's doing something? It keeps trying to install transformers 0.2.2 (which conflicts with 0.3.0, which my package manager's packages are using)
10:42:29 <rwbarton> otherwise you could get say a Set returned from f and pass it to g, and g would go wrong because it is using a different Ord instance on the elements of the Set
10:42:49 <Xezlec> rwbarton: my brain hurts.  I guess we just have to cope with the lack of ability to change the constraints on a class once it's defined once.
10:42:49 <dcoutts> alpounet: oh ok
10:43:07 <lispy> Kyraimion: oh, maybe I just need to add a case for (SomeException e) ...
10:43:12 <alpounet> dcoutts, cool CH talk by the way
10:43:35 <rwbarton> anyways an instance that is overlapped with is semantically wrong. instance X a should mean you are defining that instance for every a
10:43:41 <dcoutts> alpounet: ta
10:44:08 <dcoutts> maurer: yes, --dry-run -v
10:44:40 <Xezlec> rwbarton: but when it comes to things like Complex, that's extremely frustrating.  Since Complex floats are defined as nums, Complex ints can never, ever be.  It just seems so illogical.
10:44:57 <rwbarton> that is because of abs
10:45:07 <Xezlec> sorry, I meant floatings and integrals, not floats and ints
10:45:22 <rwbarton> if abs were in its own class you wouldn't have this problem
10:45:33 <lispy> and my GHC just segfaulted....
10:45:50 <KirinDave> So cany anyone recommend some techniques or a library for taking unstructured data and trying to parse it into specific Data instances?
10:46:12 <KirinDave> I see a lot of advice on how to take vaguely structured data and map it to a SPECIFIC data instance.
10:46:23 <Xezlec> No, not just because of that.  I can't define "instance Integral a => Num (Complex a)" because "instance RealFloat a => Num (Complex a)" exists.
10:46:29 <KirinDave> But a schemaless database requires a more generic approach
10:46:38 <rwbarton> it is just because of that
10:46:52 <lispy> KirinDave: Well, per run of the application will the schema be fixed?
10:46:57 <rwbarton> because without abs/signum the instance for Num (Complex a) would have been written with just a Num a constraint
10:47:00 <lispy> KirinDave: does the service provide a way to "discover" the schema?
10:47:06 <KirinDave> lispy: It does not.
10:47:10 <KirinDave> lispy: There is no schema
10:47:11 <maurer> Ugh, overrestriction of versions strikes again (looks like haskelldb is pulling in old mtl which pulls in old transformers, and new transformers which everything else is linked against then makes everything sad :( )
10:47:32 <KirinDave> lispy: Well except for the keys to index into the table. Which you CAN discover, but generally are considered implicit since you need them to access records.
10:47:41 <Xezlec> rwbarton: Well, I have a ComplexInt class that is an instance of Num and works fine.  I just define abs to throw an exception.
10:48:04 <rwbarton> sure
10:48:14 <Xezlec> not pretty but does the job
10:48:19 <KirinDave> lispy: I imagine the easiest way is to simply define a Data object with haskell data types that match up with what you want, then get an either back.
10:48:27 <KirinDave> lispy: It's DynamoDB I am taling about, btw.
10:48:40 <rwbarton> if abs/signum were in a separate class then you could have instance (Num a) => Num (Complex a) and instance (Floating a) => AbsSignum (Complex a)
10:49:00 <rwbarton> as it is, the Num instance for Complex is not the one you need so you need your own Complex type
10:49:09 <lispy> KirinDave: another way to do this is to model what it stores and then let people privode translations from that blobby structure to their types
10:49:23 <KirinDave> lispy: This seems like a lot of work for the clients. :\
10:49:29 <lispy> KirinDave: get the data into a typesafe (but non-descriptive) format ASAP and then further process?
10:49:37 <KirinDave> lispy: yes.
10:50:08 <KirinDave> lispy: Consider the perspective of a library user.
10:50:29 <KirinDave> lispy: Esp given how most other languages will handle this problem; parse the kv store to a map.
10:50:35 <KirinDave> And then assume types are correct.
10:50:38 <Xezlec> rwbarton: OK, I think I see what you're saying.  The answer to the no-overlapping-instances problem is just to be sure that your definition is all-encompassing, so that's why the abs/signum thing is the source of the problem.
10:51:13 <rwbarton> right, when you are defining an instance you shouldn't put an unnecessarily strong constraint on the type variables that appear
10:51:27 <rwbarton> here Floating isn't too strong because of abs/signum
10:51:32 <rwbarton> but without them, it would be
10:52:00 <Xezlec> rwbarton: then maybe somebody should redo the type hierarchy to more closely match mathematics (group, ring, field, etc.)
10:52:01 <rwbarton> in theory you could still run into this problem if abs/signum didn't exist and the standard Num (Complex a) still required Floating a; but that would be stupid
10:52:58 <Xezlec> rwbarton: OK, that makes sense to me.
10:53:44 <rwbarton> a redesigned numeric hierarchy is a longtime wish list item but it doesn't seem very likely to ever happen
10:54:04 <KirinDave> lispy: I take it by your silence there is not much more to be said. :)
10:54:10 <KirinDave> lispy: Ty anyways!
10:54:59 <rwbarton> at least, not until we get some extension that makes it easier to refactor class hierarchies without breaking any code that defines an instance
10:55:21 <KirinDave> lispy: I suspect only template haskell can actually do what would be most pleasant for the library user.
10:55:36 <KirinDave> lispy: Which is, "Make this Data full of things from key A, or tell me why that operation fails."
10:56:03 <Xezlec> rwbarton: Couldn't someone just roll their own and stick it on hackageDB?  Use some +', *', -', /' and stuff like that.
10:56:22 <rwbarton> there are several already
10:56:29 <Xezlec> ooh I must have missed that
10:56:58 <Xezlec> OK well I need lunch, so I'll look for it later.  But thanks for the very enlightening discussion.
11:02:50 <lispy> KirinDave: sorry, I was off writing this bug report: http://hackage.haskell.org/trac/ghc/ticket/7329
11:03:42 <lispy> KirinDave: I'm not sure I fully understand the problem.
11:04:02 <KirinDave> lispy: So the data in DynamoDB tables is sort of freeform.
11:04:17 <lispy> KirinDave: Are you having trouble writing a specific client or a problem making a reusable API for a library?
11:04:42 <KirinDave> lispy: I'd like advice on making a client for it that can let you go from a request to an Either WhyItFailed YourDataInstance
11:05:27 <lispy> That sounds like the same problem parsers have to solve
11:05:28 <KirinDave> lispy: I'd like advice on approaching the problem. I know how to parse more well-defined things in Haskell. But when the receiving structure may or may not conform to what you wnat to parse (and is generic) then I am not sure.
11:05:40 <KirinDave> lispy: In general parsers know what they are parsing to.
11:06:12 <KirinDave> But I think the approach you suggested: just get it into a set of tagged k-v pairs and then worry about populating a specific data instance.
11:07:05 <KirinDave> lispy: I don't want users of the client to have to write code specific to parsing into their Data instance. I want them to be able to just specify a Data and maybe some extra bits and have the process otherwise automated.
11:07:19 <lispy> KirinDave: Sounds like you can make "parsers" that take k-v pairs and return those data instances.
11:07:23 <lispy> ah
11:07:40 <lispy> I suspect you're trying to be too general :)
11:07:48 <KirinDave> lispy: Please don't say that.
11:07:54 <KirinDave> lispy: Every other AWS library does this.
11:08:18 <KirinDave> Even haskell json libraries do to some extent!
11:09:37 <lispy> How about this, get it working with custom "parsers" first and then look at it and see if you can think of ways to make the parsing type directed?
11:10:05 <KirinDave> lispy: Perhaps I can go to the well of Data Typeable.
11:10:22 <KirinDave> Or Data.Dynamc.
11:16:59 <minopret> Hi, I'm just another bored student of Odersky's MOOC (class.coursera.org/progfun-2012-001) with a Java career, a degree or two in math, and a mini-Lisp (minopret.github.org); now trying tryhaskell.org.
11:17:42 <hiptobecubic> lhi
11:18:26 <lispy> minopret: heh. I didn't realize those credentials were common
11:18:51 <KirinDave> lispy: Hum.
11:19:00 <KirinDave> oh sorry
11:19:12 <KirinDave> I wonder if I could find some trick with named lenses and Data.Dynamic.
11:19:36 <edwardk> KirinDave: see Data.Dynamic.Lens
11:19:36 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
11:20:21 <KirinDave> edwardk: Ooooh.
11:20:41 <KirinDave> edwardk: I was gonna say there had to be something like that, because it's a pretty common real world problem.
11:20:57 <edwardk> There is also Data.Typeable.Lens and some other stuff
11:24:46 <lispy> bah. It seems that ghc on windows is still quite klunky
11:25:23 <lispy> It seems that the bug I hit is due to code model sizes
11:25:42 <lispy> And the fix is scheduled for 7.8 not 7.6.2
11:26:01 <lispy> I guess i meant code size models
11:30:11 <minopret> I think that "let" and "lambda" are alternate syntax for the same thing. I just looked at (http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html) and now I suppose that "let" and monads' "bind" are similar to each other too.
11:30:47 <lispy> minopret: let and lambda in haskell are fairly different
11:32:25 <mcstar> why? they are both lazy, and a let can be 'simulated' with a lambda
11:32:35 <minopret> lispy: Thanks, that will be interesting to learn. Maybe you mean something like that they have different types and that types are a Big Deal in Haskell.
11:32:45 <mcstar> the thing is recursivity, that makes them different
11:32:50 <rwbarton> typing rules are different yes, and also you can't directly emulate a recursive let with a lambda
11:33:22 <hpc> mcstar: 'let' can't be simulated with a lambda
11:33:39 <mcstar> in haskell, not
11:35:09 <lispy> let is polymorphic and lambda is monomorphic
11:35:22 <latro`a_> uh
11:35:23 <latro`a_> what?
11:35:36 <latro`a_> :t (\(x:_) -> x)
11:35:37 <lambdabot> forall t. [t] -> t
11:35:43 <Ferdirand> let foo = bar in baz  <=>  (\foo -> baz) bar,  why not ?
11:36:05 <mcstar> > let a = b; b = a in a
11:36:09 <lambdabot>   mueval-core: Time limit exceeded
11:36:12 <rwbarton> :t (\f -> (f True, f 'a')) id -- latro`a_
11:36:13 <lambdabot>     Couldn't match expected type `Char' against inferred type `Bool'
11:36:13 <lambdabot>       Expected type: Char -> t
11:36:13 <lambdabot>       Inferred type: Bool -> t1
11:36:21 <Ferdirand> there's why
11:36:31 <latro`a_> that's not monomorphism
11:36:32 <latro`a_> per se
11:36:47 <hpc> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs -- do that with lambda
11:36:48 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
11:36:52 <lispy> Look at point 12.1: http://www.haskell.org/tutorial/pitfalls.html
11:36:52 <jmcarthur> lispy: let is monomorphic now, as well
11:37:15 <jmcarthur> except, apparently, in do notation... (just discovered this today. was very confused)
11:37:16 <latro`a_> anyway yeah the corecursion doesn't work with lambda
11:37:35 <latro`a_> why is let monomorphic
11:37:42 <latro`a_> and does that persist with NoMR enabled?
11:38:02 <jmcarthur> oh, and i should clarify, is monomorphic *by default*, but you can make it polymorphic with a type signature or by using -XNoMonoLocalBinds
11:38:12 <rwbarton> something to do with making type inference easier in the presence of fancy features like type families and equality constraints
11:38:18 <latro`a_> bah
11:38:24 <latro`a_> too many extensions duking it out
11:38:33 <jmcarthur> most of the time you want it to be monomorphic anyway
11:38:44 <jmcarthur> and it's pretty good practice to put type signatures on local declarations anyway
11:38:55 <hpc> it can infer bound type variables, though
11:38:57 <latro`a_> it's good practice to put type signatures on almost everything
11:39:04 <jmcarthur> i wouldn't say that
11:39:14 <jmcarthur> top-level, sure
11:39:14 <hpc> which is going to be most polymorphism you encounter with let-in
11:39:26 <latro`a_> top level stuff and actual declarations
11:40:00 <minopret> and my obsessive-compulsive tendency says "ahh, that's nice" :-)
11:40:10 <latro`a_> there are some tiny little lets/wheres where it's not as important, sure, but like a local utility function should get a signature usually
11:40:17 <hpc> local binds don't need type signatures imo
11:40:21 <hpc> unless the types are messy
11:40:38 <hpc> it should be immediately obvious from how it is used in the outer definition
11:40:40 <rwbarton> or maybe if you have a really huge 'where' clause
11:40:45 <hpc> or that
11:40:55 <latro`a_> this all depends on the underlying style of the function really
11:40:55 <ziman> ~~
11:40:55 <hpc> but a huge where clause is an entirely different sort of problem
11:41:02 <lispy> hpc: yeah, that's my feeling too. If I have to go in and spend more than 5 seconds figuring out why I have a type error in a local definition, I usually add the type.
11:41:04 <latro`a_> sometimes most of the machinery is naturally in local declarations
11:41:25 <latro`a_> a really really huge where is bad, but, eh, lemme give an example
11:41:32 <hpc> i don't put type signatures on all my top-level definitions, either
11:41:43 <hpc> i leave them off for 2-liner "who cares as long as it does this" kind of things
11:41:52 <jmcarthur> i put them on all my top level definitions, but for local stuff i only put them if i need the polymorphism
11:42:11 <latro`a_> https://github.com/mlatuprosa/jboskrabl/blob/master/src/ScrabbleMoves.hs I think scoreMove is fairly well written
11:42:12 <lispy> jmcarthur: when was this change made?
11:42:14 <jmcarthur> for the top-level stuff i do it for the documentation as much as for the type checking
11:42:20 <jmcarthur> lispy: ghc 7 i think
11:42:29 <latro`a_> (albeit perhaps too concretely typed)
11:42:34 <lispy> jmcarthur: I guess I didn't notice
11:42:50 <jmcarthur> just goes to show how little we usually depend on local polymorphism
11:44:06 <minopret> My Haskell-inexperienced and Coq-lightly-experienced guess is that we should add a type signature where we want to express to humans (ourselves included) that it's important to keep the type in mind.
11:44:13 <DanMere34567> hi, is there a simple module i can use to make charts to run under ghc and windows. i tryed installing Chart but it just errors all the time. then I find that you need to do some complicated install. What i need is somthing that is simple to install.
11:44:23 <latro`a_> definitely then, minopret, but I'd say it's useful otherwise too
11:44:47 <hpc> ive been using type signatures to help me muddle through function definitions all day today
11:44:57 <hpc> (up until the stratos jump, at least)
11:45:02 <latro`a_> heh
11:45:05 <latro`a_> that was pretty awesome
11:45:21 <latro`a_> but I must admit that the possibility of him getting caught in the helicopter blades occurred to me
11:45:23 <latro`a_> -_-
11:45:32 <lispy> DanMere34567: look at diagrams (I don't know if it does text). I've used the gnuplot bindings on osx/linux but not windows (Just make sure to stick to the "simple" api, the rest is a nightmare)
11:45:37 <hpc> he was a long ass-way away from the helicopters :P
11:45:51 <latro`a_> yeah, but it didn't look like it
11:45:54 <latro`a_> with the geometry of the cameras
11:46:02 <monochrom> "lambda is similar to let, let is similar to bind". to close the circle and confuse you, bind and lambda together is similar to ocaml's let: "m >>= \x -> ..." translates to ocaml "let x = m in ..."
11:46:21 <DanMere34567> ok thanks.
11:46:25 <mcstar> what?
11:46:29 <mcstar> m >>= ?
11:46:47 <mcstar> ocaml's let is not recursive
11:46:56 <mcstar> thats the main difference between that and haskell's
11:47:00 <mcstar> and ocaml is not lazy
11:47:07 <hpc> mcstar: ocaml is impure
11:47:13 <monochrom> you don't know ">>="?
11:47:15 <mcstar> yeah
11:47:15 <hpc> so let bindings happen in order
11:47:22 <hpc> hence (>>=)
11:47:41 <monochrom> "m >>= \x -> ..." is also not recursive in x
11:48:01 <hpc> and afaik, you can only letrec a function definition
11:48:01 <lispy> but there's an extension for that ;)
11:48:10 <mcstar> m >>= \x -> is not let x = m in.., return m >>= \x -> is sort of like let x = m
11:48:27 <rwbarton> you saw the word "ocaml" right
11:48:32 <lispy> monochrom: although, to be fair, I think the extension only works when you use do-notation?
11:48:56 <DanMere34567> hmmmm still getting these fialed to install dependancys in cabal. :(
11:49:24 <monochrom> consider "getChar >>= \x -> putChar x"
11:49:52 <DanMere34567> it all seems to be dependant on the cairo libary and thats what i couldnt get to work in the first time.
11:50:19 <monochrom> if you use mfix, you need no extension
11:54:16 <DanMere34567> is there a package i can just install with cabal that wont require hours of custom installs so i can do some simple plot digrams under windows?
11:54:44 <monochrom> works for me
11:57:11 <hpc> DanMere34567: if you can bring your own batteries, blaze-svg may be able to help ;)
11:57:43 <solong> which branch of mathematics is most relevant to Haskell and FP?
11:58:17 <hpc> probably category theory
11:58:24 <Eduard_Munteanu> solong: category theory, type theory...
11:58:26 <hpc> but there's a lot of overlap with a lot of other fields
11:58:39 <DanMere34567> cheers hpc will have a look at that
11:58:43 <malorie> is there a common name for `foldr ($)'?
11:59:27 <hpc> :t foldr ($)
11:59:28 <lambdabot> forall b. b -> [b -> b] -> b
11:59:46 <solong> how relevant is calculus?
11:59:57 <hpc> :t foldr (.)
11:59:58 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> [b -> b] -> f b
12:00:02 <malorie> I'm thinking about `thread = foldr ($)', but I'm not quite satisfied
12:00:12 <Eduard_Munteanu> solong: not very relevant AFAIK.
12:00:29 <minopret> monochrom: That was funny. Were you expressing that the m >>= \x -> ... construct evaluates an expression immediately rather than lazily?
12:03:13 <hpc> > sequence [(*2), (+5), id] 10 -- 30
12:03:14 <lambdabot>   [20,15,10]
12:03:19 <hpc> pah
12:03:25 <hpc> :t sequence
12:03:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:03:27 <malorie> hpc: why is it printing that type for `foldr (.)'?
12:03:42 <hpc> malorie: in lambdabot, (.) = fmap
12:03:48 <malorie> ah. I see
12:14:28 <minopret> If I implement arithmetic on lists of zeros and ones, will that be as slow as I expect it will?
12:14:39 <maukd> yes
12:14:52 <hpc> addition alone would be O(n)
12:15:43 <minopret> Still slow if I use 32 processors and expect my values to be bounded by 2^32, right? :-)
12:16:18 <minopret> or 2^16 for that matter
12:17:37 <DanMere34567> hmmmm when i try and install chart all i get is depends on glib-0.12.3.1 which failled to intall. cairo 0.12.3.1 failled during the configure step. the exception was: ExitFailure 1 gio-0.12.3.1 failled duirng the configure step. the exception was : ExitFailure 1 gtk-0.12.3.1 pango 0.12.3
12:17:51 <DanMere34567> is there a easy way to get this to work? it seems everything requires linix...
12:18:53 <minopret> DanMere34567: VirtualBox, but that's not likely what you want to hear and I wouldn't know the other answers.
12:19:08 <DanMere34567> awww lol.
12:19:26 <ClaudiusMaximus> DanMere34567: see gtk2hs website for installers for your OS
12:20:40 <ClaudiusMaximus> DanMere34567: http://code.haskell.org/gtk2hs/INSTALL
12:20:59 <DanMere34567> ok will have a look thanks.
12:26:15 <minopret> I have this fantasy that arithmetic should be written in software and applying hardware arithmetic should be a "mere" optimization. Impossible? Useless? I don't know.
12:32:33 <gfredericks> I'm looking into using haskell more robustly, especially w.r.t. external libraries. I currently have ghc 7.0.3 installed via ubuntu apt-get, and was looking into haskell-platform. Is that the right direction? Should I be uninstalling the 7.0.3 and trying to install 7.4.1 manually (since that's what the haskell-platform page says is required)?
12:36:03 <Cale> gfredericks: Yeah, the generic linux binaries are what I use under Ubuntu
12:37:06 <gfredericks> Cale: binaries for what? ghc or HP?
12:37:13 <Cale> gfredericks: You may want to get 7.4.2, as the differences from 7.4.1 are just bug fixes
12:37:18 <Cale> GHC
12:37:26 <Cale> I don't explicitly install the Haskell platform
12:37:42 <Cale> I just get cabal install and then install the things I want from there
12:39:03 <gfredericks> cabal claims you need HP to use it
12:39:03 <gfredericks> or maybe that was hackage; I'm having trouble keeping track
12:40:32 <Cale> You don't *need* the Haskell Platform for anything, it's just a collection of packages.
12:42:05 <Cale> If you grab the tarball of cabal-install from http://hackage.haskell.org/packages/archive/cabal-install/0.14.0/cabal-install-0.14.0.tar.gz -- that version should work with 7.4.{1,2}
12:42:21 <Cale> and it contains a bootstrap.sh script which you can run to get things set up
12:43:29 <Cale> and then you can run  cabal install <packagename>  to install other packages
12:44:04 <gfredericks> Cale: okay cool, I'll try that; thanks
12:45:30 <Cale> gfredericks: You may also want to set library-profiling: True and documentation: True in your ~/.cabal/config fairly early on as well.
12:46:28 <DanMere34567> hmmm its still not working
12:46:43 <DanMere34567> i get the feeling that this will just take hours.
12:47:26 <Cale> DanMere34567: What's not working?
12:47:40 <DanMere34567> ah im trying to get cabal to install chart
12:47:49 <DanMere34567> i installed gtk2hs
12:48:03 <DanMere34567> but i cant get chart to install in cabal :(
12:48:37 <Cale> What's going wrong?
12:48:57 <DanMere34567> well the all in one i unziped to the opt directory as it said.
12:49:14 <Cale> um...
12:49:18 <DanMere34567> then i went to the c:\program files\haskell platform\
12:49:19 <Cale> what?
12:49:21 <Cale> oh
12:49:28 <DanMere34567> and typed in
12:49:33 <DanMere34567> cabal install chart
12:50:05 <DanMere34567> then it said that cairo-0.12.3.1 which failed to install. failed in the configure step. Exit failure 1.
12:50:38 <Cale> What did it say while trying to install cairo? Do you have gtk2hs-buildtools installed?
12:51:41 <DanMere34567> i dont realy understand, the instructions were very patchy. i unziped the file to opt
12:51:44 <DanMere34567> on th C drive
12:51:53 <DanMere34567> the gtk-demo works fine
12:52:34 <DanMere34567> its saying somthing about %path% but i dont realy get that? im not a computer expert.
12:52:52 <Cale> I've never installed gtk2hs on Windows before, so I'm not really sure whether there are other steps necessary -- presumably you'd have to install the GTK library separately.
12:53:04 <DanMere34567> pkg-config --cflags gtk+-2.0
12:53:06 <DanMere34567> runs fine
12:53:14 <DanMere34567> from the opt directory
12:53:26 <DanMere34567> i think haskell cannot see the files maby?
12:53:55 <Cale> But the usual procedure is to  cabal install gtk2hs-buildtools  and then  cabal install gtk
12:53:58 <DanMere34567> i just wanted a simple way i can display charts from list data.
12:54:25 <t7> how do i make a new TextureObject ?
12:54:37 <DanMere34567> i will give it a go :)
12:55:05 <t7> aha idnote
12:55:09 <t7> ignore *
12:56:10 <burbul> @undo process_returning_scion_leaf (s, bn) = { do bn' <- process_scion_node bn ; return (s, bn') }
12:56:10 <lambdabot>  Parse error at "=" (column 38)
12:56:36 <Cale> @undo do bn' <- process_scion_node bn ; return (s, bn')
12:56:37 <lambdabot> process_scion_node bn >>= \ bn' -> return (s, bn')
12:56:45 <burbul> hm. is there a cleaner way to write that function?
12:57:09 <Cale> @pl process_scion_node bn >>= \ bn' -> return (s, bn')
12:57:10 <lambdabot> (,) s `fmap` process_scion_node bn
12:57:11 <burbul> I think I want something like 'second'
12:57:42 <DanMere34567> gtk2hsc2hs installed.
12:57:46 <burbul> But for a monad
12:57:52 <Cale> yeah
12:58:10 <Springwight> anyone remember how I popped in here at some point and said I had an implementation for a real time O(1) queue
12:58:21 <gfredericks> \forall_{X,Y \in \{caball, ghc, haskell-platform\}} X can be installed with Y, and X's documentation claims that Y is a prereq
12:58:31 <Springwight> Cale, you probably do :P
12:58:59 <Cale> gfredericks: hah
12:59:16 <Cale> Springwight: yeah, well, I recall you talking about various queues
12:59:41 <latro`a_> lol gfredericks
12:59:43 <burbul> May be some combination of liftM/ap and second?
13:00:07 <burbul> [fmap ((,) s) is a little hard to read, at least for me.]
13:00:15 <Springwight> Well. Nevermind lol. I just found a paper by tarjan that implemented a deque on very similar principles. Except he got to them through a very different route than I did o_o
13:00:28 <Springwight> And his is much more efficient
13:01:24 <DanMere34567> ahhh! i cannot beleve this is so difficult. I cannot for the life of me get cairo to install. :S i just want to make some line graphs.
13:01:30 <Springwight> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.13.3451
13:01:39 <swarley> what's the easiest way to get the filepath separator?
13:01:51 <swarley> eg linux its / in windows its \
13:02:01 <ClaudiusMaximus> @hoogle (</>)
13:02:02 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
13:02:02 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
13:02:21 <Cale> swarley: Use the FilePath library to construct paths in a platform independent way :)
13:02:35 <Cale> But you can use / as a file path separator on Windows.
13:02:35 <ClaudiusMaximus> use that to make paths (importing the one from System.FilePath which is the independent re-export of whichever you are on)
13:02:45 <swarley> Ah, I'm trying to get the name of the current directory only, is there an easier way to just do that?
13:03:03 <swarley> test from /home/swarley/test
13:03:36 <ClaudiusMaximus> @hoogle getCurrentDirectory
13:03:37 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
13:03:44 <ClaudiusMaximus> FilePath = String
13:03:54 <ClaudiusMaximus> then presumably...
13:03:59 <ClaudiusMaximus> @hoogle splitFilePath
13:03:59 <lambdabot> No results found
13:04:04 <ClaudiusMaximus> @hoogle splitDir
13:04:05 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
13:04:05 <lambdabot> System.FilePath.Posix splitDirectories :: FilePath -> [FilePath]
13:04:11 <swarley> swarley@OctaviasViolin ~/Documents/Programming/Haskell/GenEnv $ runhaskell genenv.hs
13:04:11 <swarley> /home/swarley/Documents/Programming/Haskell/GenEnv
13:04:29 <Cale> splitPath :: FilePath -> [FilePath]
13:04:35 <swarley> ah
13:05:00 <DanMere34567> is there a simple update i can get to work on windows so i can make line graphs from a list. i already wasted 2 hours trying to get this cairo program to work. i just want somthing that will work easly without lots of work. :S i thought this would have been simple. but it appears that I need to use linux to get anything done :'(
13:05:17 <ClaudiusMaximus> DanMere34567: diagrams-svg
13:05:22 <Cale> oh, maybe it is splitDirectories that you want
13:06:39 <Cale> Well, diagrams is a pretty serious library to pick up...
13:06:59 <ClaudiusMaximus> DanMere34567: or roll your own svg thing like i did in hp2pretty (which could do with an update/testing with ghc-7.6 /etc)
13:07:22 <ClaudiusMaximus> but that is kinda boring if all you want to do is output graphs
13:07:40 <Cale> It'd do what you want very nicely, but it's not specifically tailored to drawing line graphs
13:07:50 <DanMere34567> ah ok
13:08:00 <ClaudiusMaximus> but yes, Cale is right that diagrams isn't the easiest library to learn
13:08:14 <DanMere34567> thanks seems to be installing just fine :D
13:08:18 <Cale> I honestly have no idea how Windows users manage to get anything done :/
13:08:20 <ClaudiusMaximus> on the plus side it has lots of documentation
13:08:39 <DanMere34567> thats fantastic, documentation and a working module on windows. i will wake up soon haha.
13:08:44 <Cale> http://projects.haskell.org/diagrams/documentation.html
13:09:10 <DanMere34567> i realy should just bite the bullet and install linux.
13:09:14 <fryguybob> Cale: ssh to a linux box of course.
13:10:22 <fryguybob> DanMere34567: I regularly make sure that Diagrams sans cairo works on Windows.
13:10:23 <spaceships> DanMere34567: come on down the rabbit hole. it's perfectly safe.
13:10:34 <fryguybob> I use either svg or postscript for output.
13:10:39 <latro`a_> unless you start out with a source distro
13:10:42 <latro`a_> then you have issues
13:11:36 <DanMere34567> ok i will have a play :D it is realy boring, i just want to output a bunch of graphs of list data :D
13:12:25 <minopret> :t toUpper
13:12:27 <lambdabot> Char -> Char
13:13:09 <spaceships> DanMere34567: Just watch out for forgotten beasts if you get in too deep
13:18:30 <DanMere34567> hmmm still not working :(
13:21:07 <minopret> "comment" -- yeah, trying out lambdabot in front of everyone is probably a waste of everyone's attention
13:21:18 <minopret> > "comment" -- yeah, trying out lambdabot in front of everyone is probably a waste of everyone's attention
13:21:24 <lambdabot>   "comment"
13:22:13 <minopret> :t "comment" -- yeah, trying out lambdabot in front of everyone is probably a waste of everyone's attention
13:22:14 <lambdabot> [Char]
13:22:41 <DanMere34567> hours and hours lol, diagram  installed but when i try and execute the first tutorial file it will not compile. it says it cannot load cairo.
13:23:38 <Cale> DanMere34567: That's using the cairo backend -- since you couldn't get cairo to install before, using that backend is not going to be very easy :)
13:24:19 <DanMere34567> so diagrams will not work
13:24:38 <Cale> It'll work, you just can't use that backend for it
13:24:40 <DanMere34567> hmmmm agrraaa *bangs head against desk*
13:25:15 <swarley> so i know this is a noob question, but how do i consolidate these lines? I just want the name in d
13:25:20 <DanMere34567> how can i get the example to compile? is there a shortcut?
13:25:23 <swarley>      d <- getCurrentDirectory
13:25:23 <swarley>      putStrLn (last (splitPath d))
13:25:32 <Cale> import Diagrams.Backend.SVG.CmdLine
13:25:45 <Cale> instead of import Diagrams.Backend.Cairo.CmdLine
13:26:04 <DanMere34567> thank you Cale
13:26:12 <fryguybob> DanMere34567: And replace any "Cairo"s with "SVG"s.
13:26:24 <Cale> putStrLn . last . splitPath =<< getCurrentDirectory
13:26:26 <hpc> :t putStrLn . last . splitPath =<< getCurrentDirectory
13:26:27 <lambdabot> Not in scope: `splitPath'
13:26:27 <lambdabot> Not in scope: `getCurrentDirectory'
13:26:51 <hpc> maybe parens, depending on (=<<) precedence
13:27:15 <copumpkin> I MADE A THING: https://gist.github.com/3889687
13:28:37 <hpc> OMG IT HAS STUFF INSIDE
13:28:40 <hpc> BEST THING EVER
13:28:43 <swarley> Cale; how would i get that value into d, or at least some where that i can reference it easily
13:29:24 <Cale> do d <- fmap (last . splitPath) getCurrentDirectory
13:29:56 <Cale> Or you can just use let
13:30:09 <Cale> do dir <- getCurrentDirectory
13:30:17 <Cale>    let d = last (splitPath dir)
13:30:22 <swarley> oh
13:30:23 <Cale>    ... use d here ...
13:30:53 <DanMere34567> the program compiled but when i run it it says Unknown file type :pdf
13:31:17 <ClaudiusMaximus> DanMere34567: it should have a --help page
13:32:03 <Cale> DanMere34567: How are you running the program? (Which commandline parameters?)
13:32:20 <minopret> tryhaskell.org is terrific, but so short. Is there another interactive thing that I should try? Or are RWH and LYAH really the next steps? Does it make a difference that I already have deep experience with C, Perl, and Java plus additional experience with Python, Mathematica, etc. plus usable chunks of Scheme, Coq, and Scala?
13:32:23 <DanMere34567> ah i used DiagramsTutorial -o circle.pdf -w 400
13:32:34 <Cale> Ah, replace .pdf with .svg
13:32:42 <nand`> of those, Coq would be the most useful I think
13:32:55 <nand`> minopret: I do recommend LYAH next (or rather, first)
13:33:06 <DanMere34567> thanks very much! ahahah it works!!!
13:33:11 <DanMere34567> time for a cup of tea.
13:34:25 <Cale> minopret: Of course, if you haven't installed GHC yet, that would be a good place to begin, and then yeah, one of those sounds good.
13:35:44 <minopret> Thanks for the recommendations and I'll try it. I confess I suspect that I might have more fun and hit more topics by re-implementing my Project Euler solutions in Haskell for a while.
13:36:05 <Cale> minopret: The Scala might be helpful. Coq will maybe be too, though Coq's notation is so very different that it's hard to imagine it being directly useful. Basic functional programming stuff from Mathematica and Scheme will likely be a bit of help.
13:36:42 <nand`> well if you already understand nonstrict semantics, higher order algebraic typing, purity and how it relates to I/O, etc.; then you'd be set as far as that's concerned
13:37:08 <Cale> minopret: There's http://www.haskell.org/tutorial/ -- its name is basically only relative to reading the Report :)
13:37:51 <t7> @google (m a) -> m ()
13:37:52 <lambdabot> http://en.wikipedia.org/wiki/Mam_language
13:37:52 <lambdabot> Title: Mam language - Wikipedia, the free encyclopedia
13:37:56 <t7> @hoogle (m a) -> m ()
13:37:56 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
13:37:56 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:37:56 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
13:37:59 <Cale> and http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf which we used to recommend to everyone, but it's somehow fallen out of common recommendation
13:38:08 <monochrom> minopret: "m >>= \x -> ..." and ocaml "let x = m" perform I/O.
13:38:49 <t7> @hoogle (a -> b) -> Either a b -> b
13:38:49 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
13:38:49 <lambdabot> Data.Either either :: (a -> c) -> (b -> c) -> Either a b -> c
13:39:45 <Cale> minopret: http://www.cs.utep.edu/cheon/cs3360/pages/haskell-syntax.html is a decent cheat sheet when you're starting out
13:39:47 <monochrom> Moggi's monad papers also use "let" as syntax sugar for bind
13:40:15 <DanMere34567> spoke to soon all the svg files are blank :(
13:40:17 <mcstar> i noticed this in my code:
13:40:20 <mcstar> where fun b (i,ch)
13:40:29 * Cale tries to understand what monochrom's comments have to do with minopret's question about Haskell tutorials
13:40:58 <monochrom> oh, it answers a 3-hour-ago question
13:41:35 <monochrom> but The Gentle Introduction ftw!
13:42:19 <minopret> Thanks again, Cale, nand`, monochrom (yes, regarding the 3-hour-ago question), and all. I have an article that leads me into HOAS as it applies to implementing an interpreter for the lambda calculus. I don't know HOAT. I get nonstrict eval (I played with Clean a long time ago) and purity (freedom from side effects, right?). I think I can fake my way through IO from some examples I that I have in hand. I'll make a collection of tho
13:42:20 <Cale> It's not very gentle, but there is something about its general approach which is good.
13:42:42 <mcstar> it was gentle, after LYAH
13:42:47 <nand`> minopret: your message got cut off after ‚Äútho‚Äù
13:43:22 <Cale> minopret: re: faking your way through IO, http://www.haskell.org/haskellwiki/Introduction_to_IO is my quick explanation of what IO is about in Haskell.
13:43:23 <mcstar> those
13:43:41 <minopret> repeated and completed, "I'll make a collection of those documents in my Zotero. Bye."
13:44:06 <Cale> minopret: You should hang around and ask questions :)
13:44:09 <mcstar> Cale: you have a priority queue package right? i found it to be slower than the other one, without fingertrees
13:44:11 <monochrom> nice, I'll suggest "LYAH and then Gentle" next time, seems like the best combination I know
13:44:13 <minopret> ok
13:44:40 <Cale> mcstar: Yes, I wrote that in 15 or 30 minutes and didn't do anything special to try to make it fast or good.
13:44:50 <mcstar> oh
13:44:56 <mcstar> then nvm
13:44:57 <Cale> mcstar: I wrote it more as an example of how the fingertrees package can be used
13:45:06 <Cale> than as something practical
13:45:11 <monochrom> RWH seems to be way too shallow on some topics and way too diving on others
13:45:13 <nand`> after LYAH there's also the typeclasseopedia (or however you spell it)
13:45:43 <Cale> mcstar: Use PSQueue :)
13:45:54 <mcstar> yeah i did, but i dont have to now
13:46:07 <nand`> monochrom: my main gripe with RWH is the verbose, ugly and sometimes badly written code examples
13:46:33 <DanMere34567> this is the file can you guys see if theres anything wrong? when i check it out in firefox its just blank.
13:46:39 <DanMere34567> {-# LANGUAGE NoMonomorphismRestriction #-}
13:46:39 <DanMere34567>  
13:46:39 <DanMere34567> import Diagrams.Prelude
13:46:42 <DanMere34567> import Diagrams.Backend.SVG.CmdLine
13:46:42 <DanMere34567>  
13:46:45 <DanMere34567> main = defaultMain (circle 1)
13:46:47 <nand`> I believe it's important to present beautiful code
13:46:48 <ClaudiusMaximus> DanMere34567: nooo
13:46:48 <mcstar> Cale: turned out, 3 implementations of priority queues just slowed down that algorithm, and a simple map->list>sort list was way faster
13:46:49 <DanMere34567>  
13:46:52 <DanMere34567> circle1 = circle 1 	# fc blue
13:46:55 <DanMere34567> 					# lw 0.05
13:46:56 <ClaudiusMaximus> @where paste
13:46:56 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
13:46:57 <fryguybob> DanMere34567: Paste to hpaste
13:46:58 <DanMere34567> 					# lc purple
13:46:59 <Cale> mcstar: ah, haha
13:47:01 <DanMere34567> 					# dashing [0.2,0.05] 0
13:47:17 <monochrom> yeah, you need hpaste
13:47:41 <DanMere34567> hpaste
13:47:51 <Cale> DanMere34567: http://hpaste.org/
13:48:34 * monochrom has an evil idea!
13:48:40 <hpaste> DanMere34567 pasted ‚Äúcircle‚Äù at http://hpaste.org/76281
13:49:05 <Cale> DanMere34567: btw, configure your text editor to convert tabs to spaces
13:49:16 <DanMere34567> ok.
13:49:18 <swarley> What's the easiest way to do something like `touch filename`?
13:49:22 <Cale> DanMere34567: this program ought to compile, but you are soon going to run into problems :)
13:49:27 <swarley> just create the file, and put nothing in it
13:49:34 <DanMere34567> http://hpaste.org/76281
13:49:39 <DanMere34567> yea it compiled fine
13:49:46 <DanMere34567> but when i loaded it its just blank
13:49:57 <Cale> DanMere34567: you can see on hpaste how the compiler sees this code (multiple-of-8-space tabs), and when you start trying to line up bits of code, you'll run into trouble
13:50:17 <DanMere34567> ahhh i see
13:50:27 <DanMere34567> no wonder its broke :S
13:50:53 <Cale> Well, it shouldn't be broken -- the code as written like that is valid for now
13:50:59 <basti_> hi people - is there a trick how to annotate runST in functions so that there'll be no ambiguities which appear too hard for me to resolve?
13:52:01 <DanMere34567> it compiles but its still showing nothing. :(
13:52:14 <fryguybob> DanMere34567: I can reproduce the issue here.  Just a minute.
13:52:34 <basti_> http://pastebin.com/9GhJ3rhu
13:52:38 <maukd> The paste 9GhJ3rhu has been copied to http://hpaste.org/76282
13:53:19 <fryguybob> DanMere34567: The line width is too small.
13:53:28 <DanMere34567> oh
13:53:33 <monochrom> that is not runST ambiguity. that's STArray ambiguity
13:53:43 <DanMere34567> its a bit worrying as this is the first example on the tutorial... :(
13:53:46 <basti_> monochrom: i understand that much.
13:54:07 <Cale> oh, also, you're not running circle1
13:54:16 <Cale> you're drawing  circle 1
13:54:19 <Cale> heh
13:54:27 <t7> @pl \a b -> tcoord a >> vertex b
13:54:28 <lambdabot> (. vertex) . (>>) . tcoord
13:54:32 <fryguybob> DanMere34567: Well, the units are different in Cairo.  And what Cale said.
13:54:42 <monochrom> the combination of "IArray blah" and "MArray" seems to say you're mixing up what shouldn't be mixed
13:55:01 <DanMere34567> so theres no real way to do this in windows then :(
13:55:18 <Cale> DanMere34567: Why do you say that? All you have to do is change a couple of numbers.
13:55:28 <Cale> (and actually use the drawing that you defined)
13:55:40 <ClaudiusMaximus> DanMere34567: supply some command line arguments to create a bigger image
13:55:45 <ClaudiusMaximus> DanMere34567: instead of 1x1 pixel
13:55:58 <t7> @hoogle IO a -> IO ()
13:55:58 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
13:55:58 <lambdabot> Control.Exception.Base block :: IO a -> IO a
13:55:58 <lambdabot> Control.Exception block :: IO a -> IO a
13:56:42 <Cale> DanMere34567: yeah, the -w 400 that you were passing before might've helped
13:57:11 <DanMere34567> i typed DiagramsTutorial -o circle1.svg -w 800 but its still blank.
13:57:28 <Cale> I wonder why vim seems to hate the lines with # as their first non-whitespace character
13:57:37 <fryguybob> DanMere34567: I'll paste an updated version so you can see what to change.
13:57:43 <hpc> Cale: that idiotic comment continuation?
13:57:56 <hpc> i found a command to shut that off...
13:58:01 * hpc -> el goog
13:58:07 <DanMere34567> thanks
13:58:34 <hpc> autocmd FileType * setlocal formatoptions-=c formatoptions-=r formatoptions-=o
13:58:53 <hpaste> fryguybob annotated ‚Äúcircle‚Äù with ‚Äúcircle (annotation)‚Äù at http://hpaste.org/76281#a76283
13:59:43 <maukd> hpc: did you mean: setl fo-=cro
14:01:32 <Cale> hpc: nope, that doesn't seem to be it -- it's colouring them with a red background
14:01:53 <DanMere34567> its like a double rainbow! i have a blue circle on my browser window thanks! :D
14:02:01 <DanMere34567> haha very good.
14:03:30 <DanMere34567> thanks guys
14:04:01 <Cale> I wonder if there is an easy way to get an explanation for which highlighting rule is causing the colour of a given piece of text in vim
14:04:35 <maukd> Cale: put 'let g:hs_allow_hash_operator = 1' in your .vimrc
14:05:14 <Cale> aha
14:05:37 <maukd> do :e $VIMRUNTIME/syntax/haskell.vim to see the culprit
14:08:12 <t7> @hoogle when
14:08:12 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
14:08:12 <lambdabot> System.Posix.Terminal WhenDrained :: TerminalState
14:08:12 <lambdabot> Test.QuickCheck.Property whenFail :: Testable prop => IO () -> prop -> Property
14:13:21 <nsxt> is there anything like 4clojure.com for haskell?
14:13:52 <hpc> whatis?
14:14:35 <hpc> ah
14:14:41 <hpc> tryhaskell.com perhaps?
14:15:32 <Cale> 4clojure seems to be a set of programming problems
14:16:10 <nsxt> right, so tryhaskell, while interactive, doesn't really fit the bill.
14:20:47 <hpc> Cale: ping
14:20:58 <Cale> hi
14:21:05 <hpc> does this type make sense for building a module and set of combinators around?
14:21:11 <hpc> type CompileT s r c m a = StateT (s, r -> c r) m a
14:21:24 <hpc> (obviously newtyped instead of aliased)
14:21:39 <kdridi> i don't understand the differences between haskelldb, hdbc and hsql
14:21:56 <hpc> kdridi: what other DBIs have you used?
14:22:03 <Cale> hpc: Do you really *need* 5 type parameters? ;)
14:22:03 <kdridi> i just wan't to use a mysql db driver
14:22:24 <kdridi> hpc, what other ? in haskell ? none
14:22:26 <Clint> you might have more fun with persistent-mysql
14:22:29 <hpc> any language
14:22:44 <hpc> hdbc is very similar to perl, and would likely be the most comfortable to start with
14:22:49 <hpc> dunno about hsql
14:23:00 <hpc> and i couldn't get haskelldb to install, many moons ago
14:23:13 <Cale> So, haskelldb is a fancy embedded language for constructing relational queries, and requires a bit of additional setup to construct types that match your database and so on.
14:23:21 <Clint> haskelldb works fine but there's negative documentation
14:23:33 <kdridi> hpc, hibernate in java, activerecord and datamapper in ruby
14:24:41 <minopret> nsxt: Maybe you like any of these: http://stackoverflow.com/questions/2055932
14:24:43 <Cale> HDBC is more like what you'll find for database access in other languages. Strings for queries, though it does represent SQL datatypes
14:25:20 <kdridi> actually, i just need something that works :) nothing ins
14:25:24 <hpc> Cale: afaict, that CompileT type is kind of a "reverse Cont"
14:25:43 <hpc> in that you have access to a "what happened before" (r -> c r) value
14:25:53 <hpc> instead of a "what happened after" (a -> m r) value
14:26:11 <Cale> kdridi: Well, they all work
14:26:39 <nsxt> minopret: kudos, thanks!
14:27:20 <Cale> hpc: I'm not sure I understand that
14:28:53 <kdridi> Cale, actually haskelldb-hsql-mysql doesn't seem to be installable via cabal
14:29:06 <Cale> kdridi: What happens?
14:29:56 <kdridi> Cale, https://gist.github.com/3889873
14:30:21 <Cale> oh, that's cute
14:30:44 <kdridi> i spend 2 hours finding a solution to that problem yesterday but i gave up :/
14:30:54 <Cale> wait, what?
14:31:06 <Cale> Why is it even considering the haskell98 package?
14:31:21 <ClaudiusMaximus> hm, what's the best way to structure code that aims to show version X is faster than version Y of a given cabal package?
14:31:21 <Cale> oh, version 0.10
14:31:50 <kdridi> Cale, perhaps i've to install a fresh new haskell-platform from sources ?
14:31:54 <Cale> ClaudiusMaximus: use Criterion?
14:32:18 <Cale> kdridi: I don't usually use Haskell Platform myself, I just install GHC, and then cabal install
14:32:36 <Cale> kdridi: anyway, I see what the problem is
14:32:37 <ClaudiusMaximus> Cale: right - and use   cabal install --constraint="foo==X" foo-test  etc
14:32:41 <kdridi> Cale, ah ? never tried :)
14:32:49 <ClaudiusMaximus> ?
14:33:01 <Cale> ClaudiusMaximus: ah, I guess so, yeah
14:33:20 <Cale> ClaudiusMaximus: to be honest, installing multiple versions of the same package gets annoying quickly
14:33:21 <ClaudiusMaximus> maybe with --executable-suffix  options, will investigate
14:33:30 <Cale> ClaudiusMaximus: Maybe you can use this cabal-dev thing I've heard about
14:33:39 <ClaudiusMaximus> yeah, that might be sensible
14:34:06 <Cale> kdridi: Okay, version 0.10 of haskelldb-hsql is not likely installable with any recent GHC
14:34:10 <ew0> I'm getting an <<loop>> in my haskell program
14:34:21 <hpc> you have an infinite loop
14:34:25 <ew0> xD
14:34:31 <kdridi> Cale, how did you learn that ?
14:34:33 <ew0> how do I find it?
14:34:33 <hpc> @where hpaste
14:34:33 <sipa> ew0: yes, haskell is really nice; it does infinite loops in 5 seconds
14:34:33 <lambdabot> http://hpaste.org/
14:35:02 <Cale> kdridi: looking at its dependencies: http://hackage.haskell.org/package/haskelldb-hsql-0.10
14:35:07 <Cale> base, haskell98 <-- these are now mutually incompatible packages
14:35:18 <Cale> You can't depend on both
14:35:32 <kdridi> Cale, ah ? cool, maybe i should use ghc-6.6
14:35:33 <Cale> 1.0.0 looks saner though
14:35:40 <Cale> That would be silly :)
14:35:56 <Cale> I would just choose another DB library before reverting to such an old GHC :)
14:36:06 <hpc> ew0: you can comment out parts of code that might be looping
14:36:13 <hpc> use Debug.Trace.trace
14:36:16 <ew0> lol
14:36:19 <ew0> I think I just found it
14:36:23 <hpc> or that
14:36:55 <Cale> kdridi: What are your goals with respect to accessing the mysql database?
14:37:00 <ew0> it is a rl = rl `seq` stuff
14:37:04 <ew0> probably
14:37:08 <hpc> that's definitely it
14:37:22 <Cale> kdridi: are you developing a new application from scratch, or trying to access data in a specific DB layout?
14:37:27 <hpc> er, (a rl = ...) or (rl = ...)?
14:37:38 <kdridi> Cale, simple mysql driver with a possibility to do some clever thing like persistence (if possible)
14:38:00 <kdridi> Cale, accessing an existing database without touching it
14:38:08 <Cale> HaskellDB is definitely not the simplest thing to get set up
14:38:13 <kdridi> i mean, the database layout
14:38:17 <Cale> ah, okay
14:39:19 <kdridi> the thing is, can i use haskelldb without hsql nor hdbc  on a mysql db ?
14:40:28 <Cale> no
14:40:54 <kdridi> haskelldb is "just" an sql queries builder/generator isn't it ?
14:41:15 <Cale> HaskellDB implements HDBC and HSql backends, and then those in turn allow it to be used with the backends that those libraries support.
14:41:23 <Cale> well...
14:42:45 <Cale> It's more like its own query language embedded in Haskell which happens to be compileable to SQL
14:43:41 <Cale> oh, there is this: http://hackage.haskell.org/packages/archive/haskelldb/2.1.1/doc/html/Database-HaskellDB-Sql-MySQL.html
14:43:45 <Cale> I didn't actually know about that
14:44:00 <kdridi> ah, ok
14:44:26 <kdridi> i think i'm going to use haskelldb over hdbc
14:44:51 <zxspectrum> hi. does anyone know of a good way (if there is one) to extract useful error messages from combinatorial parsers?
14:45:28 <lpvb> fsep :: [Doc] -> Doc
14:45:51 <Cale> zxspectrum: Are the error messages which Parsec gives you not useful?
14:46:29 <zxspectrum> I'm working with code that doesn't use Parsec
14:47:13 <Cale> Which library does it use? Some parser libraries produce nice messages, other ones don't.
14:48:38 <zxspectrum> there isn't a library... it's just combinators ([Token] -> (a, [Token]). I'm trying to modify it to support error messages
14:48:54 <Cale> aha, okay
14:49:11 <Cale> oh, it's a deterministic parser?
14:49:38 <Cale> [Token] -> Either ErrorMessage (a, [Token])  would be the first easy thing to do
14:50:18 <Cale> Given the type you just gave, your parsers currently have no way to fail at all.
14:50:21 <maukd> [Token] -> (Either ErrorMessage a, [Token])
14:51:00 <Cale> maukd's suggestion is also possible, if you want to be able to continue working with the remainder of the tokens after a parse failure
14:51:03 <zxspectrum> oh, sorry. I left out some brackets. [Token] -> [(a, [Token])]
14:51:13 <maukd> Cale: or just see where the error occurred
14:51:17 <zxspectrum> it's not deterministic, but it should be unambiguous
14:52:20 <maukd> [Token] -> Either ([Error], [Token]) [(a, [Token])]
14:52:34 <zxspectrum> *the grammar I'm working with should be unambiguous
14:54:16 <zxspectrum> that looks good
14:55:18 <zxspectrum> what's the purpose of [Error] rather than Error?
14:55:22 * hackagebot language-javascript 0.5.5 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.5 (AlanZimmerman)
14:56:47 <maukd> multiple errors at the same location
14:58:12 <ddrone> Hello! Can you point me at some good Parsec tutorial? Official site has a very outdated one
14:58:33 <hpc> ddrone: there's a RWH chapter that's also rather dated
14:58:34 <Cale> You mean http://legacy.cs.uu.nl/daan/download/parsec/parsec.html ?
14:58:36 <zxspectrum> how would that happen without continuing to parse after an error?
14:58:39 <hpc> but the docs are probably your best bet
14:58:41 <Cale> It's dated, but quite good
14:58:42 <ddrone> Cale, yep
14:59:03 <cmccann> it may be outdated, but the basic concepts haven't changed much.
14:59:08 <Cale> ddrone: There are only a few differences you really have to watch out for: the module names have changed, and some things have been generalised
14:59:47 <Cale> You now import Text.Parsec usually along with an appropriate module for which kind of input you're parsing, like Text.Parsec.String, for instance
15:00:49 <ddrone> Cale, maybe there are some examples that use modern version of Parsec?
15:01:35 <Cale> http://hackage.haskell.org/packages/archive/parsec/3.1.3/doc/html/Text-Parsec-Prim.html#v:parse -- you can see how to use the parse function here.
15:02:10 <Cale> ddrone: It's entirely analogous to the one discussed in the tutorial.
15:02:26 <Cale> parseTest is also still around...
15:02:42 <Cale> (as you can see from the next function after parse in that link)
15:04:19 <ddrone> Cale, okay, thanks for you help
15:04:23 <ddrone> your*
15:05:22 * hackagebot hjsmin 0.1.3 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.3 (AlanZimmerman)
15:06:39 <teneen> when I use "ghc -C" I get a warning "Compiler not unregistered so ignoring -C"
15:06:42 <teneen> what does this mean?
15:06:57 <hpc> do you know what the -C flag does?
15:06:59 <hpc> (i don't)
15:07:23 <shachaf> It stops after generating C.
15:07:33 <shachaf> GHC doesn't normally compile via C these days, though.
15:08:25 <burbul> @hoogle Monad m => m a -> m b -> m (a,b)
15:08:26 <lambdabot> Data.Sequence zip :: Seq a -> Seq b -> Seq (a, b)
15:08:26 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
15:08:27 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
15:09:03 <teneen> shachaf: so it will not work?
15:11:11 <shachaf> teneen: What will not work?
15:11:26 <teneen> shachaf: the -C flag?
15:11:34 <shachaf> What do you want to do?
15:11:50 <teneen> shachaf: I want to see the C output
15:11:59 <shachaf> There is no C output.
15:12:31 <teneen> shachaf: not even in old versions of ghc?
15:13:15 <shachaf> In old versions of GHC, and in special cases in newer versions, C code is generated and given to GCC.
15:13:21 <shachaf> But it's not very C-y C code.
15:15:31 <Cale> Not to mention that it doesn't compile to a working executable
15:15:53 <Cale> and the assembly output had to be mangled into something which actually worked
15:16:39 <johnw> does anyone remember what the Haskell constraints checker/theorem prover on Github was called?  I can't remember the name, or who was working it...
15:16:41 <Cale> teneen: But these days, GHC compiles to native code
15:16:45 <dmwit> Maybe somebody should ask why you want to see the C code.
15:17:03 <johnw> there was presentation on it from Microsoft Research
15:17:36 <companion_cube> johnw: there are paradox and equinox theorem provers that are written in haskell, iirc
15:18:04 <johnw> no, those weren't the names...
15:18:05 <luite> teneen: with -ddump-cmm you get a somewhat readable version of your program, the language is sort of between assembly and C (local variables, somewhat c-like syntax, but now higher level control flow like while and for)
15:18:17 <luite> no
15:19:09 <teneen> luite: I see, thanks
15:19:10 <Cale> Though usually -ddump-simpl (the Core code after simplification) is enough to understand what's going on.
15:19:11 <johnw> it was a way of encoding properties of functions at the type level, and then a theorem prover would prove that your program could not "crash"
15:19:12 <hpaste> ew0 pasted ‚Äúwarning‚Äù at http://hpaste.org/76286
15:19:28 <johnw> I think edwardk pointed me to it
15:19:33 <ew0> I'm fixing my warnings and now I got to this one
15:19:52 <johnw> ah, it was https://github.com/danr/contracts
15:20:24 <dmwit> ew0: Read about the monomorphism restriction and type defaulting
15:20:37 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/index.htm
15:20:47 <ew0> ok
15:20:59 <Cale> http://research.microsoft.com/en-us/um/people/simonpj/papers/verify/contracts-dec07.pdf
15:21:01 <luite> yeah -ddump-cmm is mainly useful if you want to know how the stack and heap are used
15:21:28 <Cale> ew0: You don't have to fix that warning.
15:21:44 <Cale> ew0: But if you really want to, just add an explicit type signature to the expression
15:23:03 <Cale> ew0: It's just letting you know that the type of 128 * 1024 * 1024 is ambiguous (it could just as well be any numeric type, like Float or Rational, or Complex Double), and that it's defaulting to Integer
15:24:49 <Cale> Because all you do with the value is to apply show, and show is polymorphic, it's unable to decide which numeric type is actually meant. But because numeric literals are so often a source of ambiguity, Haskell defines a way to default them -- the default default is to choose the first type from (Integer, Double) which works. This can be altered with the default keyword.
15:26:32 <hpc> > show 5
15:26:33 <lambdabot>   "5"
15:26:39 <hpc> > show (5 :: Double)
15:26:40 <lambdabot>   "5.0"
15:26:45 <hpc> > show (5 :: Rational)
15:26:46 <lambdabot>   "5 % 1"
15:27:15 <ew0> yeah, and the type signature forces it to be always integer
15:27:22 <ew0> it would be the same with a read
15:27:28 <ew0> let a = read :: Integer
15:27:45 <ew0> erm read b
15:28:05 <ew0> I still have the same stack space overflow since last week
15:28:21 <ew0> increasing the stack size solves my problem, but I still can't sleep that well
15:28:33 <ew0> I wish I could profile my code
15:42:17 <Jetbeard> :t 5
15:42:19 <lambdabot> forall t. (Num t) => t
15:45:46 <Frogulis> f [x] = 1; f (x:xs) = 2
15:45:57 <Frogulis> can someone explain to me why [x] matches a list with only one element?
15:46:30 <Frogulis> is it just because it doesn't match (x:xs) but does match [x] so it can say with ambiguity that it has to take the [x] option?
15:46:47 <sipa> because [x] is syntactic sugar for (x:[])
15:47:04 <Frogulis> ahh, that's lovely
15:54:03 <Frogulis> thanks
16:09:14 <ExternalReality> I there anyone willing to chat and an explain to me a few things about Haskell's lazy evaluation model.
16:09:27 <coldpizza72i> are $ and . synonymous?
16:09:28 <shachaf> ExternalReality: Not if you don't ask your questions.
16:09:32 <shachaf> coldpizza72i: No.
16:09:40 <ExternalReality> Ha
16:09:41 <shachaf> @google haskell dollar vs dot
16:09:42 <lambdabot> http://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign
16:09:42 <lambdabot> Title: function composition - Haskell: difference between . (dot) and $ (dollar sign) - ...
16:09:51 <parcs`> :O
16:10:05 <shachaf> :√ò
16:21:47 <Ralith> @hoogle (s -> (a,s)) -> State s a
16:21:47 <lambdabot> Control.Monad.Trans.State.Lazy state :: (s -> (a, s)) -> State s a
16:21:47 <lambdabot> Control.Monad.Trans.State.Strict state :: (s -> (a, s)) -> State s a
16:21:47 <lambdabot> Control.Monad.State.Lazy state :: (s -> (a, s)) -> State s a
16:22:00 <Ralith> oh heh
16:22:43 <Ralith> hoogle-the-website turned up nothing for that, weird
16:28:13 <jmcarthur> ExternalReality: i think shachaf was trying to say you should just ask
16:38:23 <merijn> jmcarthur: Although, to be fair, it made a pretty funny joke too (I didn't even realise at first...)
16:38:58 <jmcarthur> lol
16:40:50 <mcstar> typical lazy evaluation joke
16:40:58 <mcstar> i hear one every weak
16:41:40 <shachaf> merijn: What joke?
16:41:57 <Ralith> @hoogle Double -> String
16:41:57 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
16:41:57 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
16:41:58 <lambdabot> Prelude show :: Show a => a -> String
16:42:08 <Ralith> @hoogle Floating a => a -> String
16:42:08 <lambdabot> Network.BufferType buf_toStr :: BufferOp a -> a -> String
16:42:09 <lambdabot> Prelude show :: Show a => a -> String
16:42:09 <lambdabot> Text.Show show :: Show a => a -> String
16:42:11 <Ralith> hm.
16:42:27 <Ralith> are there any formatting functions for floats to control number of significant digits?
16:42:57 <mcstar> > printf "%05d" 3
16:42:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:42:58 <lambdabot>    `Text.Printf.PrintfType ...
16:43:05 <merijn> shachaf: I know it wasn't meant to be a joke, but you can interpret it as "we won't answer questions about lazy evaluation until you force the thunk (ask them)" ;)
16:43:10 <mcstar> > printf "%05d" (3::Int)
16:43:11 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:43:11 <lambdabot>    `GHC.Show.Show a'
16:43:11 <lambdabot>      a...
16:43:20 <shachaf> merijn: Oh, I get it.
16:43:24 <hpc> > printf "%05d" (pi :: Double) :: String
16:43:24 <shachaf> That was a good joke I made there!
16:43:25 <lambdabot>   "*Exception: Printf.printf: bad argument
16:43:33 <hpc> > printf "%05f" (pi :: Double) :: String
16:43:34 <lambdabot>   "3.141592653589793"
16:43:36 <mcstar> > printf "%05d" 3 :: String
16:43:37 <lambdabot>   "00003"
16:43:40 <mcstar> :)
16:43:44 <shachaf> @karma+ shachaf # good joke
16:43:44 <hpc> ah
16:43:44 <lambdabot> You can't change your own karma, silly.
16:44:21 <mcstar> > printf "%.5d" pi :: String
16:44:22 <lambdabot>   "*Exception: Printf.printf: bad argument
16:44:34 <mcstar> > printf "%.5f" pi :: String
16:44:36 <lambdabot>   "3.14159"
16:52:17 <Ralith> hpc, mcstar: I was hoping for something a bit more idiomatic than that
16:53:07 <mcstar> i dont know of other way of formatted output
16:53:09 <hpc> eh, printf is fine imo
16:56:36 <startling> so how do I turn a c wchar_t into a haskell Char? is it even possible?
16:56:55 <startling> or do I just treat it as a wide c string, marshal it to haskell, and take the first character?
16:58:44 <shachaf> 03:46 <shachaf> That depends on what wchar_t is.
16:58:47 <burbul> Stylistically, when should one use a let block , rather than a where block?
16:58:55 <shachaf> 03:46 <shachaf> It means something very different on Windows and UNIX, if I remember correctly.
16:59:24 <dmwit> burbul: go with your heart
16:59:25 <danharaj> burbul: where blocks scope over all guards in a pattern binding, top-level or otherwise.
17:00:02 <startling> shachaf: that was last night? there were no answers by the time I /quit to sleep, sorry if I missed it
17:00:19 <startling> shachaf: this is for ncurses, though, so screw windows
17:00:31 <ihm> I'm having a problem installing warp: "cabal: warp.cabal:60: The 'type' field is required for test suites. The
17:00:31 <ihm> available test types are: exitcode-stdio-1.0"
17:00:31 <ihm> I downloaded the warp source and tried removing the test suite section from the cabal file but now cabal seems to be installing from its own files instead of the downloaded version as I'm now getting: "Resolving dependencies...
17:00:31 <ihm> cabal: Couldn't read cabal file "warp/1.3.4/warp.cabal""
17:00:31 <ihm> which is not the directory I downloaded to
17:00:32 <shachaf> Right, it was after you left.
17:00:46 <ihm> any ideas?
17:00:54 <shachaf> startling: What's wchar_t?
17:01:21 <johnw> shachaf: I often find myself asking that quaestion
17:01:27 <johnw> wchar_t is evil
17:01:37 <shachaf> johnw: I know. That's why I'm asking startling. :-)
17:01:42 <johnw> oh, it's UCS2, no wait, it's UCS4, no wait, it's just a DWORD
17:01:56 <startling> shachaf: the one in man ncurses. Is there a way I can get more information?
17:02:10 <johnw> startling: there is no definitive answer
17:02:17 <johnw> startling: it's "implementation defined"
17:02:20 <startling> johnw: oh. :|
17:03:25 <shachaf> startling: In practice on UNIX it's probably just a 32-bit integer or something.
17:03:36 <johnw> I'm at the C++ Standards Meeting this week, and I can tell you that many of us hang our heads in shame when people bring up wchar_t, std::locale, and basic_string ;)
17:03:37 <carter_> edwardk: could you elaborate the point you made on twitter yesterday about the problems with that generalized bind?
17:03:49 <carter_> (if you want to)
17:03:55 <johnw> edwardk!
17:04:17 <carter_> johnw!
17:04:19 <startling> shachaf: so I should just try that? fair enough
17:04:20 <danharaj> johnw: what about allocators :P
17:04:21 <carter_> (echo)
17:04:24 <edwardk> (>>=) :: m a -> (a -> m b) -> m b  -- once you pass the 'a' into the function, if its not captured in the environment then its done with the 'a'
17:04:32 <shergill> i upgraded to cabal 1.16. and upgraded ghc to 7.6.1. running 'cabal list foo' in a setting where GHC_PACKAGE_PATH has been set, gives me a helpful message stating how GHC_PACKAGE_PATH is incompatible with Cabal and that i should use --package-db to specify a package database. however upon invoking 'cabal --package-db=bar foo' i get an 'unrecognized option' error. any ideas?
17:04:49 <carter_> edwardk: versus the generalized action machinery of the other rep?
17:04:55 <edwardk> when you use erik's version, you have a funtion (a,b) -> c  that will take the a later, but the function is opaque so you can't know it won't be used
17:05:18 <edwardk> so the garbage collector can't free the 'a' while executing the function
17:05:31 <dcoutts> ihm: cabal update, the thing with reading "warp/1.3.4/warp.cabal" should be fixed.
17:05:39 <johnw> danharaj: omg, don't even get me started
17:05:40 <edwardk> it has to hold onto it in for the misguided hope that you'll use it when you're done
17:05:54 <edwardk> its just unnecessary
17:05:56 <carter_> ick... that makes in cache nursery stuff less nice
17:06:17 <ihm> dcoutts: how do you mean? I saw you were talking about it a few weeks ago in here in the logs but I couldn't find the conclusion
17:06:21 <edwardk> Thats my major issue, the others are obvious
17:06:46 <carter> too much generality + the need to define what the monadic fold like op does?
17:07:04 <startling> johnw: so we've got a fox in the coop. excellent
17:07:23 <carter> the main thing that was "obvious" to me is that its too general in that other way
17:07:30 <shergill> hmm am i the only one who's run into the --package-db error, or am i just being incredibly dense?
17:07:35 <Jetbeard> @pf op s = (reservedOp s >> return s)
17:07:35 <lambdabot> Maybe you meant: bf pl
17:07:38 <dcoutts> ihm: if you run cabal update now, the error about 'Couldn't read cabal file "warp/1.3.4/warp.cabal"' will go away.
17:08:18 <Jetbeard> @pl op s = (reservedOp s >> return s)
17:08:18 <lambdabot> op = liftM2 (>>) reservedOp return
17:08:27 <edwardk> carter: well, its just needlessly redoing what 'having an environment' already does for you
17:08:38 <carter> ooooo
17:08:56 <carter> yeah
17:09:18 <carter> thats what it looked like to me, though I wasn't clearly thinking it quite that articulately
17:09:29 <burbul> dmwit +: thanks
17:09:34 <edwardk> shergill: i get the warning every time i use ghc 7.6.1 with an older cabal. do you have -Werror turned on?
17:09:36 <hpaste> ihm pasted ‚ÄúWarp install failure‚Äù at http://hpaste.org/76290
17:10:00 <ihm> dcoutts: indeed it did, though now I get a new error (http://hpaste.org/76290)
17:10:16 <ihm> this is the same one i got when trying to install from a downloaded copy actually
17:10:56 <dcoutts> ihm: yes, it's a bug in an old version of the Cabal lib, you can workaround it by deleting the test-suite section from the .cabal file.
17:11:03 <burbul> Can one put a 'type' statement locally in a function?
17:11:15 <burbul> [ I get the bug, if I try, but I can't see any reason why it shouldn't be possible
17:11:18 <dcoutts> ihm: ie do cabal upack, fix the .cabal file and install
17:11:19 <burbul> *I get a bug
17:11:41 <shergill> edwardk: i believe i do. thanks
17:11:52 <edwardk> shergill: it should be a warning not an error. In my code for my test suites i avoid promoting it with "if impl(ghc <7.6) ghc-options: -Werror"
17:12:07 <dcoutts> ihm: another solution is to upgrade cabal, since the bug is fixed in more recent versions. Warp just happens to tickle that bug.
17:12:18 <Cale> burbul: You can't. There's no particularly good reason that you can't, but the only declarations allowed inside let/where are function and pattern bindings and their associated type declarations.
17:12:25 <BMeph> @pl s op ess = (reservedOp s >> return s)
17:12:25 <lambdabot> s = fix (const . const . liftM2 (>>) reservedOp return)
17:12:37 <BMeph> @pl s op ess = (reservedOp ess >> return ess)
17:12:37 <lambdabot> s = const (liftM2 (>>) reservedOp return)
17:12:53 <ihm> dcoutts: I was able to install successfully by removing the relevant section, thanks
17:15:50 <burbul> Cale: shame. Thank you
17:16:26 <cfar> hello guys
17:16:30 <Cale> hello
17:17:09 <cfar> how would one index a repa array by an enumarable, bounded type?
17:17:19 <burbul> If anyone has a moment, could you have a glance at  http://hpaste.org/76291? I'm  certain that in various places my monadic code should be be expressible more cleanly/shortly/elegantly, but I don't know how...
17:17:42 <kdridi> is there any way to find with package brings "Database.HaskellDB.Extra" ?
17:18:23 <shachaf> @google hackage Database.HaskellDB.Extra
17:18:24 <lambdabot> http://hackage.haskell.org/packages/archive/haskelldb/2.1.0/doc/html/doc-index-E.html
17:18:24 <lambdabot> Title: haskelldb-2.1.0: A library of combinators for generating and executing SQL state ...
17:19:03 <kdridi> @hackage Database.HaskellDB.Extra
17:19:03 <lambdabot> http://hackage.haskell.org/package/Database.HaskellDB.Extra
17:19:04 <cfar> or maybe some data type that is an instance of Ix as you can do with 'standard' arrays
17:19:15 <kdridi> @google hackage Database.HaskellDB.Extra
17:19:15 <lambdabot> http://hackage.haskell.org/packages/archive/haskelldb/2.1.0/doc/html/doc-index-E.html
17:19:16 <lambdabot> Title: haskelldb-2.1.0: A library of combinators for generating and executing SQL state ...
17:19:26 <gertc> :q
17:19:43 <kdridi> @google hackage val
17:19:43 <lambdabot> http://hackage.haskell.org/packages/archive/base/4.4.0.0/doc/html/Data-HashTable.html
17:19:44 <lambdabot> Title: Data.HashTable
17:25:04 <startling> oh hey, Cwchar is an integral. that simplifies things
17:25:05 <startling> maybe
17:25:21 <identity> This happens every time I don't use parsec for a while -- I just can't get started. I basically want to try a bunch of parsers in a list, and get the results of all the successful parsers. Is there any "duh" way to do this?
17:25:51 <Csigusz> hehe
17:26:53 <startling> identity, parsec is PEG, so you have to do this using runParser i think
17:27:03 <startling> or whatever that function is called
17:27:04 <identity> startling: PEG?
17:27:34 <startling> parsing expression grammar
17:27:42 <startling> it basically means | is an ordered choice
17:28:22 <startling> rather than "run all of these" like it means in traditional parsers
17:28:43 <identity> Hmm. Well, there's also the fact that for every successful parser, I want to continue parsing the data wherever that parser "parsed to", and try all of those parsers again, rinse and repeat
17:28:52 <identity> and thus basically get all permutations of possibly parsed outcomes
17:30:56 <identity> i'll probably have to manipulate positions and shit manually
17:31:04 <identity> oh golly, this will be so much fun
17:31:32 <Cale> identity: There's a permutation parser module for Parsec
17:31:39 <identity> Cale: really? :|
17:31:52 <identity> Cale: what am I looking for?
17:31:58 <Cale> http://hackage.haskell.org/packages/archive/parsec/3.1.3/doc/html/Text-Parsec-Perm.html
17:32:02 <identity> a separate package.. oh
17:32:14 <startling> wait, is parsec PEG? I thought it was but I can't find anything saying it is
17:32:35 <Cale> It's in the same package
17:32:37 <Cale> separate module
17:33:33 <Cale> startling: More or less
17:33:47 <startling> Cale: thought so
17:33:53 <Jetbeard> fuckit i'm off to bed
17:33:59 <Jetbeard> gonna get up early and have pancakes for breakfast
17:34:10 <Jetbeard> oops wrong channel, disregard my breakfast plans
17:35:01 <Cale> startling: There's actually some additional subtlety to how choice works in Parsec which isn't modelled by parsing expression grammars
17:36:13 <dolio> frisby is PEG.
17:36:36 <identity> Cale: Well, shiiet. You just saved me an awful lot of time there.
17:36:39 <identity> thanks!
17:36:44 <Cale> identity: no problem!
17:37:29 <Tekmo> How do you use lambdabot to leave messages for others?
17:37:47 <Cale>  @tell person message
17:38:02 <person> @messages
17:38:03 <lambdabot> You don't have any new messages.
17:38:23 <Cale> :D
17:40:30 * hackagebot alpha 0.9.6 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9.6 (MarcCoiffier)
17:43:24 <Tekmo> Thanks, that worked
17:45:30 * hackagebot alpha 0.9.7 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9.7 (MarcCoiffier)
17:48:10 <identity> Cale: I played around a little bit with the permutation parser, and i must admit I'm not entirely sure how this allows me to retrieve all permutations(combinations?) of possible parsed outputs
17:49:13 <identity> Let's say 1 can parse to a or b, and 2 to c or d. parsing "12" would then give ["ac", "ad", "bc", "bd"]
17:50:30 * hackagebot alpha 0.9.8 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9.8 (MarcCoiffier)
18:01:03 <YayMe> :t liftA
18:01:04 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
18:01:46 <YayMe> > liftA (map (+1)) [1,2,3]
18:01:48 <lambdabot>   No instance for (GHC.Num.Num [a])
18:01:48 <lambdabot>    arising from a use of `e_11123' at <in...
18:03:50 <YayMe> > liftA (fmap (+1)) [1,2,3]
18:03:51 <lambdabot>   No instance for (GHC.Num.Num (f a))
18:03:52 <lambdabot>    arising from a use of `e_11123' at <...
18:04:49 <YayMe> > liftM (map (+1)) [1,2,3]
18:04:51 <lambdabot>   No instance for (GHC.Num.Num [a])
18:04:51 <lambdabot>    arising from a use of `e_11123' at <in...
18:05:01 <YayMe> :t liftM
18:05:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:05:22 <augur> Nisstyre arbn beep
18:05:58 <arbn> argur: Hi.
18:06:20 <jonkri> anyone who built threads for base 4.6? i want to install happstack-server but threads wont install
18:06:45 <stepkut> >:(
18:07:07 <arbn> augur: Yeah, and a lot of editors let you insert the inferred type with a keystroke.
18:07:13 <arbn> Which is handy.
18:07:18 <stepkut> jonkri: I've only built threads against base 4.5
18:07:25 <augur> arbn: no no but like
18:07:48 <stepkut> jonkri: you are using GHC 7.6 ?
18:07:56 <augur> arbn: often types people dont even need to do that, i think most haskell programmers just write types before defs and dont even think of using inferred types
18:08:11 <augur> maybe im wrong, but thats the impression i get
18:08:18 <augur> its just second nature to think in types
18:08:45 <jonkri> stepcut: hi :) i'm running fedora 17. ghc report 7.0.4
18:09:15 <jonkri> haskell-platform is installed from the standard fedora repositories
18:09:24 <stepkut> jonkri: how did you end up with base 4.6? I have 7.4.1 and only have base 4.5.0.0
18:09:27 <arbn> augur: Huh. Maybe I'm not fully "thinking in types", then. I started programming with Scheme, so that might be to blame. :P
18:10:09 <augur> arbn: felleisen tried to teach students to use type comments
18:10:39 <jonkri> stepkut: no idea. maybe i've broken something. another thing is that cabal keeps yapping about "Note: there is a new version of cabal-install available. To upgrade, run: cabal install cabal-install", even though i run "cabal install cabal-install"
18:10:41 <augur> arbn: apparently they just ignored them or did them poorly, and so some followup modifications were made to drracket, i think it was, making it possible to force type signatures
18:10:46 <augur> the students got better overall as a result
18:11:01 <stepkut> jonkri: do you have ~/.cabal/bin in your PATH?
18:11:33 <augur> arbn: also, im deep in typeland. i program mostly in Agda which is about as tactical-nuke as you can get without leaving the obviously-programming world
18:11:37 <stepkut> jonkri: if you don't that is probably why cabal-install keeps reporting that.. it installs the new version to ~/.cabal/bin but you are running the old version in /usr/bin/cabal
18:11:48 <geekosaur> also, if you are in the same shell session after running it, you may need "hash -r" or "rehash" t get the shell to see the new one
18:12:15 <stepkut> jonkri: but that would be unrelated to the threads error most likely.. what error do you get ? (if it is long you can paste it at hpaste.org)
18:12:34 <jonkri> ah, thanks for that
18:12:52 <jonkri> stepkut: http://hpaste.org/76274
18:13:03 <arbn> augur: Ah. I see. I'm rapidly writing web applications in Haskell as quickly as I can, for business reasons. :P Maybe I should slow down sometimes and get in the habit of thinking type-first.
18:13:14 <geekosaur> aha, that error
18:13:41 <jonkri> oh, you meant the error for compiling threads? :)
18:13:50 <stepkut> jonkri: yeah
18:13:53 <geekosaur> ok, so the problem is not that you have base 4.6, it is that your base is too *old* for what it's trying to do.  it's going through the compatible base versions, but base is part of the compiler and not upgradeable
18:14:10 <jonkri> stepkut: sorry, just woke up :)
18:14:19 <stepkut> :)
18:14:26 <arbn> augur: That pedagogical approach is interesting, though.
18:14:27 <geekosaur> so it lists out a (somewhat bogus) reason why it can't use any of the compatible versions of base, the real reason being that your compiler doesn't come with those versions of base
18:14:33 <augur> arbn: i find that the type-first approach is cleaner and simplifies problem solving
18:14:49 <augur> arbn: it forces you to be clear about what you're trying to achieve in the first place
18:15:04 <augur> and often, once you've got the right type, the answer to the problem is obvous
18:15:23 <augur> and i include local definitions in that too
18:15:43 <augur> its often useful to type local definitions for things like the combiners for folds, and so forth
18:15:54 <geekosaur> cabal-install needs to do a better job of handling this situation :/ currently it drives a spike into base ot prevent attempts at upgrading, but doesn't otherwise treat it specially, so a "not compatible with yoru base" error comes out like that which is highly confusing
18:18:48 <jonkri> stepkut: export PATH=/home/jonkri/.cabal/bin:$PATH seemed to fix it :P
18:19:23 <stepkut> jonkri: fix everything? or just the cabal-install issue ?
18:20:24 <startling> how do I represent a c array of n length in haskell?
18:20:33 <jonkri> stepkut: happstack-server installed now
18:21:17 <stepkut> jonkri: epic!
18:21:25 <jonkri> stepkut: thanks :)
18:21:38 <stepkut> jonkri: you can also ask in #happs, btw
18:21:40 <jonkri> maybe i should compile haskell-platform myself, so i know what i get, and so that i can choose the version myself
18:21:45 <jonkri> oh, good to know
18:21:47 <Xezlec> rm=0000000000000 x=2       y=2       key=0000000000000000000000 t=groon field
18:21:47 <Xezlec> *** - [http://www.fossevents.org], and soon we'll repeat last years
18:21:47 <Xezlec> *** - success with Picnics for Geeks across the globe, more info at
18:21:47 <Xezlec> *** - [http://geeknic.org]
18:21:47 <Xezlec> *** -
18:21:48 <bfgun> hello, can i nest guards easily? or what would be the cleanest way to nest two conditions together?
18:21:48 <Xezlec> *** - freenode is a service of Peer-Directed Projects Center Ltd,
18:21:48 <Xezlec> *** - a not for profit organisation registered in England and Wales.
18:21:49 <Xezlec> *** -
18:21:49 <Xezlec> *** - If you support the work we do and wish to donate to the PDPC,
18:21:50 <Xezlec> *** - you may do so over at http://freenode.net/pdpc_donations.shtml
18:21:50 <Xezlec> *** -
18:21:51 <Xezlec> *** - Thank you for using freenode!
18:22:05 <ion> bfgun: &&
18:22:12 <danharaj> @ops
18:22:12 <lambdabot> Maybe you meant: docs oeis pl
18:22:15 <bfgun> ie, i have five possible conclusions, first a three way branch, then two of those branches have two questions to ask
18:22:16 <stepkut> jonkri: if you wait around long enough in #happs someone will generally answer your question
18:22:22 <danharaj> blah
18:22:31 * danharaj will never remember that command
18:22:33 <jonkri> nice, thanks again :)
18:23:03 <startling> how do I eveluate some C macro (it's just a number) with hsc2hs?
18:24:37 <augur> seriously who thinks its a good idea to spam for geekery
18:26:08 <augur> why did augustss have a coathanger :|
18:27:04 <ion> Just in case the pregnancy test is positive.
18:27:20 <augur> ..
18:27:35 <augur> thats a slightly distasteful joke
18:29:04 <hpaste> some pasted ‚Äúcode style‚Äù at http://hpaste.org/76296
18:30:00 <kdridi> @hackage Database.HaskellDB.Query
18:30:00 <lambdabot> http://hackage.haskell.org/package/Database.HaskellDB.Query
18:30:08 <kdridi> @google hackage Database.HaskellDB.Query
18:30:09 <lambdabot> http://hackage.haskell.org/packages/archive/haskelldb/0.10/doc/html/Database-HaskellDB-Query.html
18:30:09 <lambdabot> Title: Database.HaskellDB.Query
18:34:27 <Xezlec> Oh, God, did my terminal just dump a bunch of random text in this channel?
18:34:52 <geekosaur> not unless your userid qualifies :)
18:34:59 <bfgun> http://hpaste.org/76296 <- ion i want to do that but only with guards, is it possible? or is there a prettier way to say all this?
18:35:04 <Xezlec> OK good.
18:35:44 <Ralith> bfgun: use spaces.
18:36:11 <bfgun> Ralith, do you mind explaining a bit more?
18:36:20 <Ralith> you are indenting with tabs
18:36:22 <bfgun> spaces where? can i just use double guards?
18:36:22 <Ralith> this is resulting in errors
18:36:43 <bfgun> wait, there are no errors with the tabs
18:36:48 <Cale> Xezlec: it looked like you were spamming info about Picnics for Geeks and donating to Freenode, lol
18:36:51 <bfgun> i'm being consistent
18:37:10 <bfgun> but the question is, can i do two nested guards? or if i can't, what is the best way to structure the code?
18:37:14 <Ralith> "being consistent" is not sufficient to avoid errors
18:37:16 <Cale> (which would indeed be a hilarious way to troll)
18:37:41 <bfgun> tabs are a valid spacing mechanism, i don't know what the problem is
18:37:41 <Xezlec> Cale: shit, so it did then.  sorry about that!!
18:38:45 <Ralith> bfgun: no, they aren't.
18:40:02 <geekosaur> oh, I missed the stuff above
18:40:10 * geekosaur trying to track too much, sigh
18:41:01 <Xezlec> the worst thing is, all that showed up on my end were some messages about throttling due to flooding
18:41:48 <Eduard_Munteanu> Some IRC clients will warn you if you're trying to paste more than a few lines.
18:41:52 <Xezlec> so it took me a while to realize something funny had happened (I think I moved the mouse wheel while trying to paste or something)
18:42:57 <Xezlec> What I was actually trying to do was ask about the subject on this page: http://www.haskell.org/haskellwiki/Let_vs._Where
18:43:12 <JuanDaugherty> Xezlec, I saw nothing in xchat, have no idea what you and Cale are talking about
18:43:45 <Xezlec> JuanDaugherty: it showed up in the logs on the web.  I just checked.
18:44:26 <JuanDaugherty> maybe xchat filtered it
18:44:37 <Xezlec> that's nice of it
18:44:42 <JuanDaugherty> cause I don't see nuthin
18:45:22 <Xezlec> Anyway, that page discusses a weird case where using an explicit argument in a function definition changes its performance
18:45:24 <JuanDaugherty> oh, had to scroll up
18:45:45 <Xezlec> (Near the end)
18:45:49 <startling> running hsc2hs on this https://gist.github.com/090287f863e9d4c2f796 gets me "Types.hsc:6: error: ‚ÄòCCHARW_MAX‚Äô undeclared (first use in this function)"
18:45:58 <startling> CCHARW_MAX *is* in ncurses.h
18:46:01 <startling> what's going on?
18:46:22 <Xezlec> startling: there are two versions of ncurses.h
18:46:42 <Xezlec> one is "wide"
18:46:52 <maukd> Language CPP? that makes me uncomfortable
18:47:02 <startling> maukd: that's what real world haskell told me to do
18:47:12 <maukd> :-/
18:47:24 <JuanDaugherty> is there some great thing in ghc 7.6.1 that makes one not mind the stuff it breaks?
18:47:39 <Tekmo> I'm still using 7.4.1
18:47:52 <startling> Xezlec: i've just got a single ncurses.h
18:47:54 <maukd> startling: I question the wisdom of RWH then
18:48:08 <Xezlec> startling: <ncursesw/ncurses.h> is the one with the wide functions.
18:48:35 <Xezlec> maybe that's the issue?
18:48:48 <Tekmo> What's the alternative approach if he wants to get access to the file at compile time?
18:49:17 <startling> maukd: k. just thought it might be what was wrong
18:49:57 <startling> Xezlec: i'm telling you, I just have a single ncurses.h
18:50:13 <geekosaur> startling, older ncurses had separate files, newer versions combined them
18:50:18 <startling> I'm assuming that's the wide one, since it has the wide functions
18:50:20 <startling> geekosaur: ah
18:50:43 <Xezlec> geekosaur: really?  how recently?
18:50:44 <startling> and I'm looking in my ncurses.h right now. it says #define CCHARW_MAX	5
18:50:49 <geekosaur> used to be you needed to -I/usr/include/ncursesw to activate the wide-character-support version, and link against -lncursesw instead of -lncurses
18:51:08 <geekosaur> Xezlec, the actual chabnge was over a year ago but some OSes have only just caught up with it
18:51:25 <geekosaur> and some may not have yet (for eample, debian stable tends to be fairly slow on the uptake)
18:51:30 <Xezlec> aha.  I was about to say, I ran into that like 2 months ago.
18:51:39 <Tekmo> startling: Are you sure there isn't another ncurses.h in your include path that is taking priority over that one?
18:52:28 <startling> Tekmo: locate ncurses.h just finds the one
18:52:47 <geekosaur> the flip side of that change, btw, is the one that comes up where some linkers whine about missing -lncursesw or about not finding something in an INPUT directive
18:53:09 <Tekmo> startling: Do other constants work?
18:53:29 <geekosaur> because some OSes replaced /usr/lib/libncursesw.so with a linker script that is not understood by some versions of ld (or by the custom linker in ghci)
18:53:45 <MostAwesomeDude> s/some OSes/dammit Fedora/
18:54:08 <startling> Tekmo: ...oddly enough, yes
18:54:22 <startling> lemme make sure it's not in an #if
18:55:06 <Xezlec> do you need #define _XOPEN_SOURCE_EXTENDED or something?
18:55:19 <maukd> startling: http://hpaste.org/76297
18:55:36 <startling> ah, probably
18:56:00 <Tekmo> startling: You can use a #define statement before the #include to enable the condition for the #if
18:56:01 <startling> maukd: do I need {-# Language CPP #-} for that, or will hsc2hs let it fly?
18:56:20 <spaceships> how does deriving work?
18:56:26 <startling> Tekmo, Xezlec: yeah, looks like that's it
18:56:28 <startling> thanks, ya'll
18:57:09 <startling> maukd: answered my own question, never mind
18:57:16 <Xezlec> Cool.  Hth.
18:58:21 <spaceships> nevermind found docs
18:58:30 <startling> my other question: how do I represent a wchar_t x[5] in haskell?
18:58:42 <startling> do I just make it a list and have peek/poke take care of it?
18:59:04 <Tekmo> If you know it's representation in memory you return it as a (Ptr a) and then just use peek/poke
18:59:13 <startling> it's not a pointer, though
18:59:16 <startling> it's part of a struct
18:59:42 <Tekmo> Yes, but you can get a pointer to an internal part of a struct using hsc2hs
18:59:49 <startling> ah, okay
19:00:14 <Tekmo> Use the #peek and #poke hsc2hs commands
19:00:58 <Tekmo> Let me hpaste a code example from my own project
19:01:13 <Xezlec> So what I was asking a minute ago was does using a pointfree style have performance implications?
19:01:34 <Tekmo> Only if the composition is not inlined
19:01:37 <startling> pretty sure ghc inlines most of (.) and ($)
19:02:11 <Xezlec> Well, the example on the URL I mentioned earlier doesn't use composition at all
19:02:34 <Xezlec> but claims that whether you use an explicit argument makes a huge difference
19:02:54 <hpaste> ‚ÄúGabriel Gonzalez‚Äù pasted ‚Äúhsc2hs example‚Äù at http://hpaste.org/76299
19:03:03 <Xezlec> it was at the end of a let vs. where discussion
19:03:56 <Tekmo> startling: That hpaste shows how to use peek and poke
19:04:35 <startling> Tekmo: neat, thanks
19:04:45 <Tekmo> You're welcome
19:06:22 <Cale> Xezlec: of course, that has little to do with let-vs-where
19:06:44 <Xezlec> I thought that too
19:06:52 <Cale> Xezlec: but yeah, using function bindings vs. pattern bindings can trade time vs. space
19:07:19 <Xezlec> Pattern bindings?
19:07:32 <Cale> Things without explicit function parameters
19:08:04 <Xezlec> OK, where can I learn about these distinctions?  I want to understand why those two aren't identical.
19:08:59 <Cale> Variables, once their value is computed, remain computed so long as they stay in scope.
19:09:23 <Cale> Functions on the other hand are not memoised.
19:09:52 <Xezlec> Wait, what about variables that store a function?
19:10:56 <Cale> Even those will remain evaluated
19:11:28 <startling> how should I find alignment for my Storable instance?
19:11:35 <Xezlec> So then what do we consider a "function" that is not a variable?  just anything that explicitly takes arguments?
19:11:42 <Cale> right
19:11:56 <Cale> a function binding is one with explicit arguments
19:12:14 <Cale> You can also write these things with lambda if you want to see an important difference
19:12:31 <Cale> The first one is   fib = let ... in (\x -> ...)
19:12:42 <Cale> the second one is  fib = \x -> let ... in ...
19:13:26 <Xezlec> weird
19:13:33 <Cale> actually...
19:13:45 <Cale> That's not quite enough to explain this one
19:13:58 <Xezlec> It sounds like it is
19:13:59 <Cale> because they put the list inside the function
19:14:11 <Cale> the list is what's doing the memoisation here
19:14:41 <Cale> if you replace (map fib' [0..] !!) with (\x -> map fib' [0..] !! x), I think you'll find the same drop in performance happens
19:15:08 <Xezlec> I don't understand how those two are different
19:15:32 <Cale> the first one is just an application of (!!) to (map fib' [0..]), while the second is a lambda abstraction
19:16:20 <Cale> @src (!!)
19:16:21 <lambdabot> xs     !! n | n < 0 = undefined
19:16:21 <lambdabot> []     !! _         = undefined
19:16:21 <lambdabot> (x:_)  !! 0         = x
19:16:21 <lambdabot> (_:xs) !! n         = xs !! (n-1)
19:16:44 <Cale> well, I don't know if the source will help us any
19:17:22 <Cale> The core might, if we had it handy
19:17:36 <Xezlec> maybe I don't know what a lambda abstraction is.  They both return a dynamically-created function that calls map and then !!, right?
19:17:55 <Cale> A lambda abstraction is an expression of the form (\x -> ...)
19:18:11 <Cale> An application is an expression of the form e1 e2 where e1 and e2 are expressions
19:18:15 <Xezlec> OK that sounds like a purely syntactic distinction.
19:18:18 <Cale> yeah
19:18:47 <Xezlec> But we're talking about a performance difference.
19:18:50 <Cale> But some of this syntactic distinction carries through to runtime, because (representations of) expressions exist at runtime
19:18:54 <startling> can I make ghci play nicely with hsc2hs?
19:18:56 <Mortchek> In the former, would the left side of !! be evaluated only once, whereas it would be evaluated each time an x is supplied in the latter?
19:19:03 <Cale> Mortchek: yes
19:19:19 <Cale> The parameters to a function are evaluated at most once
19:19:32 <Cale> If I have \xs n -> case xs of ...
19:19:48 <hashnoob> hi
19:19:57 <hashnoob> anybody here?
19:19:59 <Cale> and xs (or parts thereof) occurs multiple times inside the body of the lambda
19:20:09 <hashnoob> hmm??
19:20:10 <Cale> xs will be evaluated at most once and shared between the copies
19:20:11 <Mortchek> hashnoob, just us ghosts.
19:20:12 <parcs`> hashnoob: 918 of us!
19:20:21 <hashnoob> what?
19:20:27 <parcs`> BOO!
19:20:35 <hashnoob> wt!
19:20:36 <Cale> hashnoob: What IRC client are you using? Most of them will display a list of users.
19:20:43 <Cale> (and often a count)
19:20:46 <hashnoob> whats IRC?
19:20:52 <Xezlec> heh
19:20:57 <Cale> IRC is what we're talking through right now
19:21:17 <Cale> It stands for Internet Relay Chat
19:21:18 <hashnoob> what im saying whats the meaning of I R C
19:21:23 <hashnoob> got it
19:21:26 <Eduard_Munteanu> I guess he visited the Freenode page and used their client.
19:21:44 <hashnoob> im just trying this haskell
19:21:53 <hashnoob> i really dont know about ut
19:22:10 <Cale> hashnoob: Feel free to hang around and ask any questions you might have
19:22:11 <Mortchek> @where lyah
19:22:11 <lambdabot> http://www.learnyouahaskell.com/
19:22:13 <Mortchek> \o/
19:22:31 <hashnoob> thanks!
19:22:36 <hashnoob> ur admin CALE?
19:23:23 <Eduard_Munteanu> hashnoob: he is an operator in this channel
19:23:34 <hashnoob> ahh i see
19:24:11 <anonymous69> noob
19:24:15 <Cale> Xezlec: So, does that make things any clearer?
19:24:15 <hashnoob> well i saw this haskell from my friend and try
19:24:21 <shachaf> CALE: i didnt no ur admin!
19:24:23 <hashnoob> yeah
19:24:31 <Cale> shachaf: haha
19:24:39 <Xezlec> Cale, Mortchek: ok, so why doesn't (\x -> map fib' [0..] !! x) memoize and therefore avoid re-running the LHS every time it's invoked?
19:25:04 <hashnoob> brb guys
19:25:07 <Mortchek> Xezlec, I was just speculating, but my speculation is that it can't be reduced until you have an x.
19:25:09 <hashnoob> try this first
19:25:12 <Eduard_Munteanu> anonymous69: welcome to you too
19:26:09 <Eduard_Munteanu> shachaf: u trying this haskell too? :P
19:26:11 <Cale> Xezlec: Yeah, you need to have a particular x before you can reduce that expression, at which point the map fib' [0..] will remain in scope just long enough to work out the resulting value.
19:26:42 <Xezlec> Oy.
19:26:48 <Cale> I guess it's not all that obvious that constants occurring in the bodies of functions will be re-evaluated each time the function is applied.
19:27:06 <Cale> and a compiler *could* opt to lift out the definition of that list
19:27:15 <Xezlec> Cale: why shouldn't it be able to reduce that function?  It know the type of x.
19:27:23 <Xezlec> exactly.
19:27:34 <Cale> so that when the function body is instantiated with the value of x, it contains a pointer to the list  map fib' [0..]
19:27:44 <Cale> which would be shared between all the instantiations of the function body
19:27:47 <Cale> however
19:28:06 <Cale> this would result in worse space usage for many programs
19:28:19 * Xezlec ponders
19:28:43 <maukd> Xezlec: what is the value of n * 2 + 1? n is an int
19:29:02 <maukd> why can't you reduce that expression? you know the type of n, etc
19:29:04 <Xezlec> Cale: but doing the same thing when currying is used instead of a lambda doesn't result in worse space usage?
19:29:46 <gwern> maukd: obviously it could overflow, therefore it invokes undefined behavior and the compiler can reduce it to unsafePerformIO launchAllMissiles per the spec
19:29:59 <Xezlec> maukd: I can.  Its value is (+ 1) . (* 2)
19:30:31 <startling> so how do I poke a wchar_t x[5] when I'm storing it as a Ptr CWchar ?
19:30:50 <maukd> Xezlec: that's not an int
19:31:21 <startling> maukd: id :: Int -> Int
19:31:34 <newsham> pred maukd
19:31:39 <Xezlec> maukd: neither is (map fib' [0..] !!), but it apparently has no problem
19:31:41 <startling> oh wait, I'm misunderstanding
19:31:55 <rwbarton> @hoogle pokeArray
19:31:56 <lambdabot> Foreign.Marshal.Array pokeArray :: Storable a => Ptr a -> [a] -> IO ()
19:31:56 <lambdabot> Foreign.Marshal.Array pokeArray0 :: Storable a => a -> Ptr a -> [a] -> IO ()
19:32:02 <startling> rwbarton: oh nice
19:32:06 <maukd> Xezlec: there are no unknown variables in there
19:32:25 <Xezlec> maukd: nor in (+ 1) . (* 2)
19:32:28 <Cale> Xezlec: well, the first (implicit) lambda inside the function body of (!!) will capture the value of the list there, and the list will remain evaluated as long as needed then -- since it's bound to a single variable at that point, it'll remain evaluated
19:32:35 <maukd> Xezlec: yes, but that's not the expression I gave you
19:32:37 <Cale> Xezlec: maybe I can explain better...
19:32:41 <maukd> Xezlec: I said n * 2 + 1
19:32:50 <Xezlec> maukd: and I reduced it.
19:32:56 <maukd> no, you didn't
19:32:58 <maukd> you rewrote it
19:33:09 <maukd> and in the process you turned it from an int into a function
19:33:51 <Cale> Xezlec: okay, so do you know how lazy evaluation is outermost-first evaluation plus sharing?
19:34:05 <Cale> I think I can explain this better if you understand that much
19:34:14 <Cale> (if not, then I'll explain that first)
19:34:28 <Xezlec> No.  But maybe I should read more about that.
19:34:31 <Cale> okay
19:34:37 <Cale> So, my favourite example...
19:34:48 <Cale> Suppose we have  double x = x + x
19:34:53 <Cale> and we evaluate double (double 5)
19:35:13 <Cale> Innermost (strict) evaluation will go like this:
19:35:16 <Cale> double (double 5)
19:35:19 <Cale> -> double (5 + 5)
19:35:21 <Cale> -> double 10
19:35:23 <Cale> -> 10 + 10
19:35:24 <Cale> -> 20
19:35:38 <Cale> But that's not the only order in which we can evaluate the expression
19:35:51 <shachaf> http://www.reddit.com/r/haskell/comments/ywula/yet_another_reason_not_to_be_lazy_or_imperative/c5znykk
19:35:53 <Cale> We could also opt to expand the outermost function first:
19:35:57 <Cale> double (double 5)
19:35:59 <Xezlec> Ohhhhh...
19:36:03 <Cale> -> (double 5) + (double 5)
19:36:09 <Cale> -> (5 + 5) + (double 5)
19:36:16 <Cale> -> 10 + (double 5)
19:36:19 <Cale> -> 10 + (5 + 5)
19:36:22 <Cale> -> 10 + 10
19:36:23 <Cale> -> 20
19:36:28 <Cale> okay, but this was bad
19:36:33 <Xezlec> So lazy goes backwards
19:36:37 <Cale> We did the work of computing double 5 twice
19:36:38 <shachaf> That wasn't lazy.
19:36:50 <Cale> because x occurred twice in the body of double
19:36:51 <Xezlec> shachaf: well but it would have to, right?
19:36:55 <newsham> that was "non-strict"
19:37:01 <Cale> So lazy evaluation is a modification of this
19:37:03 <newsham> not so much "backwards"
19:37:14 <shachaf> That was "call-by-name"
19:37:35 <Xezlec> I mean from where the result is back to where the innermost term is
19:37:41 <Xezlec> as opposed to the reverse
19:37:55 <Cale> Whenever a parameter to a function occurs more than once in the body of the function, any evaluation done to that parameter is shared amongst the copies
19:38:13 <Cale> So it's *still* outermost first evaluation
19:38:18 <Xezlec> Cale: I see
19:38:20 <Cale> but with this sharing rule
19:38:31 <Cale> and we'll represent the sharing using let ... in ... syntax
19:38:34 <Cale> double (double 5)
19:38:43 <Cale> -> let x = double 5 in x + x -- still outermost first
19:38:49 <Cale> -> let x = 5 + 5 in x + x
19:38:53 <Cale> -> let x = 10 in x + x
19:39:03 <argiopeweb> Is there a way to write a polymorphic type signature (thing :: a -> IO ()) such that "a" is not ()?
19:39:04 <Cale> -> 10 + 10 -- may or may not count as a real evaluation step
19:39:05 <Cale> -> 20
19:39:29 <shachaf> argiopeweb: a can be anything. I think you should rephrase your question.
19:39:41 <Cale> So, in innermost-first evaluation, we evaluate every parameter to a function exactly once
19:39:56 <Cale> In outermost-first evaluation, we evaluate each parameter to a function zero or more times
19:39:56 <newsham> ?type const (return () :: IO ())
19:39:58 <lambdabot> forall b. b -> IO ()
19:40:08 <Cale> and in lazy evaluation, we evaluate each parameter zero or one times
19:40:23 <Xezlec> Cale: Sure.
19:40:27 <Cale> okay
19:40:27 <argiopeweb> shachaf: I want a to be anything except unit. I'm guessing it's not possible, since a is inherently everything via parametric polymorphism.
19:40:34 <Cale> So now, let's look at an expression like:
19:40:38 <shachaf> argiopeweb: Oh, I see.
19:40:46 <reet_teer> lo
19:40:46 <Cale> (\x -> (\y -> x + y)) (5 + 5)
19:40:55 <shachaf> argiopeweb: It's sort of possible to do type inequality constraints, kind of, I think, but you shouldn't.
19:41:01 <Cale> when we evaluate this, we get:
19:41:10 <Cale> let x = 5 + 5 in \y -> x + y
19:41:17 <Mortchek> argiopeweb, what's to stop someone from using a different unit type there?
19:41:22 <Mortchek> data Foo = Foo
19:41:34 <shachaf> Mortchek: Nothing.
19:41:40 <argiopeweb> Mortchek: Talented restrictions on module exports, I suppose.
19:41:40 <Mortchek> shachaf, that's my point.
19:41:48 <newsham> you nit, mortchek
19:42:08 <Xezlec> Cale: yeah, ok
19:42:10 <argiopeweb> I'm sure I can find a better way though. Thanks all.
19:42:11 <Cale> now, it may be good to keep in mind that my 'let' syntax here is really implemented as x being a pointer to some representation of the expression 5 + 5 in memory (a thunk)
19:42:16 <Mortchek> newsham, I'm not sure I know what that means. :P
19:42:21 <shachaf> newsham: no ()
19:42:40 <Cale> and when x gets evaluated (the code for the thunk is entered), the expression is replaced by the final value that is computed for it
19:42:40 <newsham> ()pick
19:42:51 <Cale> and all references to that will thereafter evaluate instantly
19:43:27 <Cale> (really, the pointer is updated with a pointer to another piece of code which returns the already-computed value immediately)
19:43:48 <Cale> So, we get this function value  let x = 5 + 5 in \y -> x + y
19:44:07 <Cale> and the first time we apply it (and, say, print the resulting number, forcing the evaluation to complete)
19:44:13 <Cale> x will be evaluated to 10
19:44:34 <Xezlec> after y is substituted
19:44:35 <Cale> but then subsequent times we apply that same function value to other parameters, x will already be evaluated
19:44:40 <Cale> yeah
19:44:45 <startling> alright, I'm stumped. how should I find the alignment for my instance of Storable for some struct?
19:44:55 <startling> should I add the offsetof for each field?
19:46:04 <shachaf> startling: Doesn't hsc2hs do it for you or something like that?
19:46:26 <Cale> If instead, we had the function \y -> let x = 5 + 5 in x + y -- this sort of operationally represents doing the allocation of the expression for x after the parameter to the function is supplied
19:46:40 <startling> shachaf: I don't think so.
19:46:49 <Cale> This might be a little weird, but it would seem a whole lot less weird if the definition of x involved y somehow
19:47:00 <Cale> You wouldn't expect it to keep x evaluated in that case
19:47:07 <startling> shachaf: I can do #offset for some struct's field and #size for the whole struct
19:47:15 <Xezlec> Cale: ok, but then shouldn't map fib' [0..] already be evaluated after the first time we invoke (\x -> map fib' [0..] !! x)?
19:47:24 <shachaf> startling: Ah, but you still need to name each field?
19:47:25 <Cale> Now, you're right, the language spec itself doesn't say what happens in memory here
19:47:32 <startling> shachaf: apparently.
19:47:35 <Cale> In fact, it doesn't say anything much about evaluation order either
19:47:41 <startling> should I just add up all the #offset s?
19:47:57 <shachaf> startling: Wait, what are you trying to figure out?
19:48:23 <startling> shachaf: alignment for a storable instance. on reflection, adding up #offsets doesn't make sense at all
19:48:37 <Cale> Xezlec: no, because it's like that "template" for an expression is reinstantiated each time we supply a new x
19:48:59 <Cale> Xezlec: so every time, we're stuck evaluating  map fib' [0..]
19:49:12 <shachaf> startling: Oh, I see.
19:49:23 <Cale> but if we give that list a name from outside the function, and refer to it by name
19:49:46 <Cale> then it'll genuinely be a pointer back to that same list
19:50:08 <Xezlec> ok
19:50:20 <Cale> OR, if we leave out the lambda here, and write (!!) (map fib' [0..])  then the (map fib' [0..]) will be like the (5 + 5) in my previous example
19:50:41 <Cale> the lambda inside the definition of (!!) will capture that list and give it a name
19:50:42 <luite> Cale: ghc does share the x here btw, at least with optimization on
19:51:09 <Cale> luite: You mean it shares the evaluation of map fib' [0..]?
19:51:17 <startling> shachaf: I dont. :(
19:51:22 <luite> Cale: on no in \y -> let x = 5 + 5 in x + y
19:51:35 <Cale> oh, it lifts the let out of the lambda?
19:51:42 <luite> yeah, it has no local free vars
19:51:51 <Cale> ah, that's interesting :)
19:52:04 <luite> in fact, it will just insert a constant 10 here, but suppose it was something more complicated it would be let floated :)
19:53:15 <Xezlec> I think this is all too abstract for me to understand quickly.  I'm going to need time to develop more of a mental picture before coming back to this.
19:53:24 <shachaf> > constant 10ople
19:53:26 <Cale> Ah, right, it does do some floating of lets past lambdas, but never between lambdas
19:53:27 <lambdabot>   is 10bul
19:54:00 <Cale> Xezlec: It's pretty subtle, and it *is* influenced by compiler optimisations
19:54:20 <Cale> Xezlec: There's nothing saying that a compiler *has* to do it like we've been discussing
19:54:28 <shachaf> Xezlec: None of this lazy evaluation business is part of the semantics of Haskell.
19:54:34 <Xezlec> Well, plus, I'm an EE, and I mostly picture code as circuit diagrams
19:55:46 <Cale> Xezlec: Basically, at an operational level, functional program evaluation is graph-rewriting: http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
19:56:29 <Cale> Xezlec: even if you can't see the graphs like this in GHC (and they're not so plainly represented), there's still a corresponding bunch of pointers (essentially all pointers to code) in memory.
19:56:39 <startling> ah, I can use #const alignOf(x)
19:56:41 <Xezlec> I'll check it out in a bit
19:56:52 <Cale> Xezlec: (that's just a couple of animated gifs)
19:57:27 <Xezlec> Yeah.  OK Lemme switch over to a machine manufactured post-1985.
19:57:32 <Cale> :)
19:57:50 <Cale> I actually really wish that language implementation was available online for people to play with
19:58:09 <cornihilio> hey, what am I supposed to use instead of 'print'? when I run 'print "hello"' it outputs "hello", keeping the quotes
19:58:18 <Cale> it's a very good way to get a sense for how things will perform in terms of time and space
19:58:29 <Cale> cornihilio: putStrLn
19:58:38 <Cale> cornihilio: print = putStrLn . show
19:58:51 <cornihilio> Cale: thanks!
19:58:54 <Cale> cornihilio: and when you show a String, it is quoted, and special characters in it get escaped
19:59:14 <Xezlec> It's very cool-looking
19:59:49 <Xezlec> But super-fast
20:00:05 <Cale> yeah, I also wish the gifs were a little slower so you could see what's happening :)
20:01:37 <Cale> (would also be nicer for the root to be in a fixed position)
20:01:45 <Xezlec> Yeah.
20:02:15 <Xezlec> Well, anyway, I'm going to go spend some time thinking about that.  But for now I need to go.
20:02:21 <Cale> okay, see you around!
20:02:27 <Xezlec> Later, thanks a lot!
20:05:04 <cmccann> Cale, those term reduction animations are neat
20:05:20 <shachaf> How would you write fromList for data Tree a = One a | Two (Tree (a,a))?
20:05:52 <cmccann> how would you write fromList for any tree?
20:06:24 <parcs`> with dependent types
20:06:35 <dolio> For that tree there will be a lot of gaps in the function.
20:07:00 <shachaf> dolio: Right.
20:07:10 <dolio> Or a lot of gaps in the tree.
20:07:24 <shachaf> I'm fine with fromList :: [a] -> Maybe (Tree a), or whatever type you prefer.
20:08:44 <maukd> pairs :: [a] -> Maybe [(a, a)]
20:08:49 <rwbarton> isn't it just fromList [a] = One a; fromList xs = Two (fromList (pair xs)) where pair [] = []; pair (x1:x2:xs) = (x1,x2) : pair xs
20:08:56 <rwbarton> plus error checking if you like
20:09:48 <shachaf> Oh.
20:09:56 <shachaf> It's exactly the inverse of the toList function I already wrote.
20:10:10 <shachaf> I'm not sure why it seemed trickier...
20:11:17 <parcs`> cool use of polymorphic recursion
20:11:22 <rwbarton> it sounded tricky until I tried to write it
20:12:35 <shachaf> I guess that's where I went wrong. :-)
20:13:11 <rwbarton> I seem to recall something similar that was trickier. maybe search in a perfectly balanced binary search tree
20:16:04 <shachaf> That would be something like data Tree k a = One k a | Two (Tree k (k,a,a))?
20:17:01 <rwbarton> I think so
20:17:09 <rwbarton> or wait
20:18:27 <rwbarton> is that supposed to represent a map k -> a?
20:18:44 <shachaf> I think so.
20:18:55 <rwbarton> oh
20:19:30 <rwbarton> it looks plausible
20:20:31 <rwbarton> I was just thinking of a set of a's though. represented as data Tree a = One a | Two a (Tree (a,a))
20:20:44 <shachaf> Wouldn't that have weird keys?
20:21:17 <rwbarton> I don't know what you mean by "keys"
20:21:36 <rwbarton> it just represents a list of a's, of a length one less than some power of 2, presumably in sorted order
20:21:46 <rwbarton> so that you can do membership tests
20:22:30 <rwbarton> basically it is stored in "row-major" order
20:22:35 <shachaf> Oh, I see how it works.
20:23:02 <rwbarton> I haven't figured out how yours works, except that it seems to have the correct number of k's and a's :)
20:24:21 <rwbarton> maybe I should rewrite it as "Two (Tree k (a,k,a))"? then there are alternating k's and a's
20:24:32 <shachaf> What would an inhabitant of yours look like?
20:24:40 <shachaf> Yes, k in the middle is probably better.
20:25:15 <rwbarton> Two 4 (Two (2, 6) (One ((1, 3), (5, 7)))) -- I think
20:25:42 <shachaf> Ah, right.
20:28:43 <shachaf> Bah, these types are confusing even when I write them.
20:30:27 <Cale> One thing which I'd really like to see a theoretical foundation for is exactly what kinds of constraints on trees can be expressed by non-regular algebraic types
20:32:00 <Cale> It's sort of like a funny limited kind of dependent typing
20:32:04 <rwbarton> you'd first need a formal sense in which my Tree is a tree at all
20:32:09 <reet_teer> FUCK TYPES
20:32:15 <Cale> lol
20:33:06 <Cale> I seem to recall someone enforcing the red-black tree balance constraints using a similar trick
20:34:29 <kdridi> i use haskelldb to access a mysql server. it works well inside ghci but when i compile the program, sometime it connects, sometime not
20:34:53 <Cale> kdridi: that's interesting
20:34:58 <kdridi> how can i resolve this problem or how do i report it ?
20:35:18 <Cale> does it produce any messages?
20:35:32 <kdridi> Main: user error (SQL error: SqlError {seState = "", seNativeError = 2003, seErrorMsg = "Can't connect to MySQL server on '192.168.1.10' (4)"})
20:35:52 <Cale> The biggest difference between ghci and plainly compiled programs is that GHCi is using the threaded runtime, so compiling your program with -threaded can sometimes help behaviour to match.
20:36:28 <Cale> Is that the right IP address?
20:37:12 <kdridi> yes, but the server is on another computer
20:37:46 <kdridi> and how do i add -threaded ?
20:38:21 <danharaj> ghc main -threaded
20:39:52 <kdridi> same problem with this option enabled :x
20:44:56 <startling> I'm getting a sigbus from using peek on an alloca'd pointer
20:45:14 <startling> is there any way I can make peek strict, so that when the pointer dies I already have what I need?
20:45:23 <hpaste> kdridi pasted ‚ÄúHaskellDB‚Äù at http://hpaste.org/76300
20:45:32 <startling> oh no, wait, I see the problem
20:45:38 <startling> my thing contains a pointer
20:46:01 <kdridi> here is a sample program that has the problem
20:46:06 <startling> (the thing that I'm getting from peek, I mean)
20:46:25 <kdridi> maybe i do something wrong :x
20:46:53 <rwbarton> (peek is strict)
20:47:07 <rwbarton> in the sense that it reads the pointer when the peek IO action occurs
20:48:10 <startling> rwbarton: yeah, I see the problem now
20:48:13 <startling> good to know, though
21:01:02 <startling> I *should* be able to use peek from an alloca'd pointer, shouldn't I?
21:01:11 <startling> my peek uses pokeArray, though
21:01:42 <startling> I keep getting sigbuses.
21:04:08 <rwbarton> peek uses pokeArray? sounds odd
21:04:41 <startling> err, I mean peekarray.
21:06:42 <rwbarton> as long as you didn't mess up your Storable instance, yes. of course the data will be garbage until something writes to it
21:07:30 <startling> right. but just running the function wouldn't sigbus if the data was garbage, would it?
21:07:47 <rwbarton> what function, peek?
21:07:51 <startling> yes.
21:08:01 <shachaf> instance Storable Peaker
21:08:10 <rwbarton> probably not; depends on the Storable instance
21:08:20 <JoshTriplett> Given a ForeignPtr, does any means exist to *remove* the finalizer?
21:08:23 <Canaimeroxx> mieeerda 900 personas en este chat
21:08:26 <Canaimeroxx> O____________O
21:08:41 <startling> Canaimeroxx: heh
21:09:37 <JoshTriplett> I have a C API to wrap that has various functions to create a foo_t, a foo_free function that frees a foo_t, and a foo_delete function that deletes the underlying foo on disk and *then* calls foo_free.
21:10:26 <JoshTriplett> Before the foo_delete function existed, I'd wrap a foo_t in a ForeignPtr as soon as I got it, with foo_free as a finalizer.
21:10:32 <Canaimeroxx> i speak spanish
21:12:44 <JoshTriplett> Now that foo_delete exists, I need some sensible way to allow destroying a foo_t and not double-freeing it.
21:12:55 <JoshTriplett> How might I do that?
21:13:40 <shachaf> I like to triple-free() just in case.
21:13:42 <shachaf> It's like sync.
21:14:42 <fryguybob> :q
21:15:00 <JoshTriplett> shachaf: :P
21:19:28 <johnw> hi there joeyh
21:19:39 <johnw> how stable is your git-annex master branch?
21:19:47 <johnw> i.e., should I trust data to it? :)
21:27:16 <startling> alright, here's more context on the SIGBUS: this is the function that sigbuses: https://github.com/startling/curslet/blob/master/UI/Curslet/Bindings/NCurses.hs#L99 and here's the Storable instance where peek is defined: https://github.com/startling/curslet/blob/master/UI/Curslet/Bindings/NCurses/Types.hsc#L25
21:27:22 <startling> anything seem immediately wrong about those?
21:29:07 <johnw> is the call to c_wget_wch succeeding?  you aren't checking the return value
21:29:18 <rwbarton> did you check that it is the peek that gives the SIGBUS?
21:29:26 <rwbarton> e.g. try replacing it with "return undefined"
21:29:46 <startling> rwbarton: yes. I did >> return () after w_wget_wch and it didn't SIGBUS
21:30:15 <startling> johnw: I have checked it, and it's always 0 (which ncurses.h defines as OK)
21:31:28 <rwbarton> "#{peek cchar_t, attr} p >>= peek" this looks odd to me
21:31:31 <shachaf> The big six-wheeler, scarlet painted, London transport, Diesel engine, ninety-seven power omnibus!
21:31:39 <rwbarton> though I haven't used hsc
21:32:12 <rwbarton> but don't you mean just "#{peek cchar_t, attr}"? or does it really work that way
21:32:18 <shachaf> #peek gives you a function that does the peeking.
21:32:37 <startling> rwbarton: oh, that is weird
21:32:39 <rwbarton> does that mean you are agreeing with me or explaining to me why startling's thing is right
21:32:51 <shachaf> Agreeing with you.
21:33:05 <rwbarton> ok
21:33:06 <shachaf> I don't think you're supposed to do a double-peek.
21:33:08 <startling> the intention is to wrap it in an AttrT but that's wrong
21:33:15 <startling> thanks!
21:33:22 <rwbarton> you've effectively told it that attr is a field of type Ptr AttrT
21:33:33 <startling> right, and it's just attr_t
21:33:38 <startling> that's probably what i was thinking
21:34:55 <startling> rwbarton: yep, that fixed it
21:34:57 <startling> thanks a bunch
21:35:17 <rwbarton> btw I don't know if you want to redo what you've done at this point but I found bindings-DSL quite pleasant to use
21:36:10 <startling> rwbarton: neat. I'll keep that in mind but I don't think I have much binding left to do
21:36:20 <rwbarton> basically here you would write "#starttype cchar_t ; #field attr , attr_t ; #array_field chars , wchar_t ; #stoptype" (; = newline) and it will define the data type for you and write the Storable instance automatically
21:36:41 <startling> interesting
21:37:01 <rwbarton> it can even automatically work out the size of chars here and will use peekArray 5 to produce a Haskell list
21:37:38 <startling> very cool
21:37:52 <startling> how did you know it was 5???
21:39:35 <cornihilio> what does this run time error mean from attoparsec?: Failed reading: satisfyWith
21:39:58 <rwbarton> i looked in ncurses.h to make sure your code matched the C type
21:39:58 <johnw> cornihilio: your predicate parser failed, sounds like
21:40:03 <johnw> are you calling satisfyWith anywhere?
21:40:07 <startling> rwbarton: ah
21:40:38 <cornihilio> johnw: ha okay. nope, I'm not using satisfyWith anywhere.
21:40:52 <johnw> i wonder if you some function that you're using does
21:41:00 <johnw> if you build with profiling, you can run again with +RTS -xc
21:41:05 <johnw> and that should tell you just where it's dying
21:41:40 <johnw> (although, I cannot get profiling builds to work on 7.6.1 for the life of me)
21:44:20 <cornihilio> I have a very big lazy bytestring, is there a cheap way to tell if it's empty?
21:44:32 <johnw> BL.null?
21:44:51 <cornihilio> johnw: turns out that error is normal, it's getting stuck trying to find the length of the bytestring
21:44:53 <johnw> i don't see why any way would be expensive
21:45:23 <cornihilio> right now I'm checking BL.length contents every time I parse something to check if there is more, I think that's the most naive way :P
21:45:26 <johnw> oh, you mean is there an attoparsec parser that can tell if it's at the end of input?
21:45:32 <dmj> is anyone running virthualenv on osx?
21:45:39 <johnw> attoparsec already has a way to do what you're doing manually
21:46:08 <dmj> I keep getting a "openNewBinaryFile: does not exist (No such file or directory)" error when I cabal install
21:46:17 <johnw> the 'parse' function return 'Done remander result'
21:46:19 <johnw> remainder
21:46:41 <johnw> where remainder is the rest of the input, which will be BL.null if there is no more input
21:47:06 <jfischoff> shachaf: ya there?
21:47:08 <johnw> you definitely *don't* want to be calling 'length' on a lazy bytestring
21:47:15 <johnw> that's undoing all of your laziness in one fell swoop
21:48:04 <shachaf> hi jfischoff
21:48:13 <hpaste> ‚ÄúJonathan Fischoff‚Äù pasted ‚ÄúSpecialize TH‚Äù at http://hpaste.org/76301
21:48:36 <johnw> cornihilio: in essence you want something like: fix \f x -> case parse myParser x of Fail [] -> Nothing; Done rest result -> (result:f rest)
21:48:41 <jfischoff> ^ I think I finally got the specialize function working, or at least a much better start
21:48:59 <johnw> that returns a list of all the successful parses.  You'd probably want a way to distinguish Error from EOF, though
21:49:17 <johnw> and I meant to say: Fail {} -> []
21:49:37 <cornihilio> johnw: thank you very much! you have been incredibly helpful; I am absolutely terrible at figuring out the intricacies of parsing in haskell.
21:49:41 <shachaf> jfischoff: Great. The way you mentioned?
21:49:49 <jfischoff> yeah
21:50:00 <jfischoff> pretty much
21:50:19 <johnw> cornihilio: you may find this simple parser instructive: https://github.com/jwiegley/svndump/blob/master/src/Subversion/Dump/Raw.hs
21:50:30 <johnw> in that, I'm doing exactly what you want to do: I'm parsing a series of entries in a file until I reach the end
21:50:34 <johnw> (or an error)
21:50:38 <startling> hm, there's a function-like macro getyx(WINDOW *win, int y, int x) that puts the results in x and y variables.
21:50:47 <startling> how would I interface with that from haskell?
21:50:51 <rwbarton> those are no fun
21:50:58 <johnw> startling: with hsc, using #cinline
21:51:12 <johnw> you then need a .hsc.helper.c file
21:51:12 <startling> johnw: hsc2hs, you mean?
21:51:17 <johnw> yeah
21:51:22 <startling> interesting. thanks
21:52:09 <johnw> startling: read here: https://bitbucket.org/mauricio/bindings-dsl/wiki/DetailedUsageGuide/FunctionsAndMacros
21:52:26 <johnw> in the section starting "A different problem is posed by inline functions..."
21:52:58 <startling> do I need to be using bindings-dsl to do this #cinline thing?
21:53:08 <johnw> yes
21:53:18 <startling> k
21:53:25 <johnw> #cinline will turn into the appropriate import to the binding created by the BC_INLINE* macro
21:53:38 <johnw> sorry, the right section begins: "The final case to be approached involves bindings to C macros..."
21:53:56 <johnw> Bindings-DSL is *super* handy
21:54:10 <johnw> in fact, if all you want is an ncurses bindings library, consider starting out with my c2hsc tool
21:54:29 <johnw> https://github.com/jwiegley/c2hsc
21:54:51 <startling> johnw: neat. that's not *all* I want, but it could be a nice start
21:55:02 <johnw> it's just meant to take out some of the initial drudgery
21:55:45 <startling> johnw: will it do the function-like macros for me?
21:55:51 <johnw> no
21:55:54 <startling> k
21:55:58 <johnw> it's only works like that for actual inline functions
21:56:02 <johnw> but the principal is the same
21:56:17 <startling> sure
21:57:20 <startling> oh, they're just pseudo-functions for the struct members
21:57:46 <startling> hmm, maybe I could do that.
21:58:23 <johnw> the only downside I've found to Bindings-DSL's #cinline magic is that it doesn't give you a p'function pointer, only a c'function function
21:58:34 <johnw> that has made it largely useless to me
21:59:00 <johnw> i mean, you *can* take the address of an inline function in C, so that should be an extra consideration; I understand that I couldn't do it if it were a macro
21:59:17 <johnw> but #cinline treats inline function as if they were just macros
22:02:26 <johnw> g'nigh
22:02:27 <johnw> t
22:02:43 <startling> can you do hsc2hs et al in a cabal build file?
22:11:33 <startling> wtf, GHC.Int.Int16 isn't Integral?
22:11:46 <shachaf> instance Integral Int16 -- Defined in `GHC.Int'
22:12:04 <startling> oh, guess I should import that.
22:12:05 <dmwit> Yeah, it's Integral here.
22:12:05 <startling> heh
22:12:15 <dmwit> I imported Data.Int, that was enough.
22:12:30 <dmwit> I doubt you can get Int16 in scope without getting the instance in scope, too.
22:12:37 <startling> dmwit: I did!
22:12:49 <shachaf> Given that the type is defined in the same module as the instance, I doubt it too.
22:12:49 <dmwit> What did you import?
22:13:12 <startling> dmwit, shachaf: i used #{type ... } in hsc2hs
22:13:12 <dmwit> I think you're lying, and additionally that you misunderstood what GHC is telling you.
22:13:32 <startling> dmwit: No instance for (Integral (IO GHC.Int.Int16))  arising from a use of `fromIntegral' is what I got
22:13:38 <startling> ...oh
22:13:44 <dmwit> =)
22:13:50 <startling> whoops
22:13:59 <shachaf> instance Integral a => Integral (IO a)
22:14:01 <shachaf> It's only sensible!
22:14:10 <dmwit> too restrictive
22:14:24 <dmwit> instance (Applicative f, Integral a) => Integral (f a)
22:14:35 <shachaf> Does that work with the (r ->) instance?
22:14:58 <dmwit> > liftA2 (+) 3 4 5
22:15:00 <lambdabot>   7
22:15:07 <dmwit> > (3 + 4) 5
22:15:08 <lambdabot>   7
22:15:10 <dmwit> I dunno.
22:15:43 <dmwit> I can't imagine how else (+) would be implemented for (r ->) than as liftA2 (+).
22:15:50 <dmwit> (or some equivalent spelling)
22:16:13 <dmwit> ?djinn (a -> a -> a) -> ((r -> a) -> (r -> a) -> (r -> a))
22:16:13 <lambdabot> f a b c d = a (c d) (b d)
22:16:27 <dmwit> oooo, liftA2 (flip (+)) -- ;-)
22:18:18 <startling> dmwit: liftA2 $ \a b -> (a * b) - (a * b - 1)
22:56:21 <lispy> dmwit: I guess a different module could introduce the type Int16 without exporting the type class
22:56:54 <lispy> dmwit: For example, it exports sometihng that returns Int16 without exporting anything from Data.Int
22:57:41 <shachaf> lispy: It still needs to have imported Int16 indirectly.
22:57:55 <shachaf> And the instance is defined in the same module that defines the type.
22:58:17 <startling> lispy: instances are contagious
22:58:28 <liyang> Like the GPL.
22:58:40 <startling> lispy: you can do "import Some.Module ()" and get all the instances defined therein
22:58:51 <lispy> startling: indeed
22:58:53 <lightquake> hmm
22:59:03 <lispy> startling: but what about exports?
22:59:19 <startling> lispy: good question
22:59:27 <shachaf> Exports?
22:59:30 <startling> I *think* they all get passed
22:59:46 <startling> shachaf: say module M imports Data.Int and exports only Int16
23:00:05 <shachaf> startling: You can't not export an instance.
23:00:13 <startling> shachaf: k. that's what I thought
23:00:22 <shachaf> If you could, you could use that to break things.
23:00:42 <lightquake> for example: you could define two Ord Complex instances, then have two Set Complex values that use different comparators
23:00:50 <lightquake> and then when you try to merge them, bad things happen
23:01:18 <lightquake> anyway
23:01:20 <lispy> goood points
23:01:21 <shachaf> I heard Ord Complex will be in DSM-V
23:01:56 <liyang> shachaf: I see what you did there.
23:02:14 <lightquake> is FRP a good choice for managing animation state in an openGL game? i realize i'm being horribly vague here but i'm not sure what to do
23:02:31 <shachaf> Don't worry. In my experience, FRP is also horribly vague.
23:02:58 <shachaf> liyang: "There once lived a man named Oedipus Rex / You may have heard about his Ord Complex"
23:03:01 <lispy> lightquake: the original examples do just that
23:03:04 <slack1256> is okasaki's tesis(1997) and book(1998) very different or roughly the same?
23:03:18 <slack1256> does the book contain more ADT meaning that is worth buying?
23:03:31 <ion> shachaf: I grew a monad in my knee, they had to cut it off before it metastasized.
23:03:45 <lightquake> lispy: oh, cool
23:04:11 <lightquake> shachaf: what would you recommend (if anything)?
23:04:34 <shachaf> lightquake: I've never used any FRP thing.
23:04:36 <lispy> lightquake: I've been wondering about the same question lately. I think some caveats are due.
23:04:56 <lightquake> i mean, recommend for the notion of managing animations in a game
23:04:58 <lightquake> lispy: caveats?
23:05:26 <lispy> lightquake: http://stackoverflow.com/questions/12685430/how-to-implement-a-game-loop-in-reactive-banana
23:05:39 <lispy> lightquake: it seems that unless some care is taken you can't guarantee numerical stability
23:05:50 <lightquake> numerical stability?
23:05:53 <lispy> lightquake: and then lots of FRP implementations have either space or time leaks
23:06:02 <lightquake> ah
23:06:16 <lispy> lightquake: right. So in that SO question the numerical stability would be wrt a physical integral
23:06:26 <lispy> lightquake: the error of the integral is dependent on the time step.
23:06:33 <lightquake> this isn't about physics simulation, this is more about 'switching between animation frames'
23:06:40 <startling> so I was wondering why erc makes random words bold
23:06:42 <lispy> lightquake: reproducibility of the physics simulation depends on the error of the integral
23:06:46 <startling> turns out they're all nicks
23:06:52 <shachaf> One FRP implementation even has a spacetime leak.
23:06:52 <startling> like "integral" and "fmap"
23:06:59 <lightquake> haha
23:07:09 <lightquake> yeah weechat has a feature like that too, but i turned it off
23:07:17 <lispy> shachaf: relatively speaking
23:07:18 <liyang> It must be annoying to have those as your nick.
23:07:37 <startling> it's kind of annoying to have mine sometimes
23:07:37 <ion> I had a time leak so I had to get a temporal diaper.
23:08:04 <shachaf> liyang: I should introduce a Haskell primitive called a liyang.
23:08:40 <startling> shachaf: just rename "monad"
23:08:45 <startling> that's a terrible name
23:08:57 <liyang> I had a space leak so I had to put on a spacesuit but I was also hungry and so I ate a banana-burrito and now I'm trapped in a reactive space-burrito.
23:09:30 <slack1256> startling: monad isn't that bad name
23:09:41 <slack1256> in spanish sound as "monada" which means
23:09:49 <slack1256> ... "not serious"
23:10:36 <shachaf> "Monad" sounds a little bit like the Hebrew word "monada".
23:10:39 <shachaf> Which means "monad"
23:10:55 <lispy> shachaf: how much hebrew do you know?
23:11:00 <lightquake> in any case i'm probably going to play around with FRP in a toy program independent of the one i'm working on, see if i can grok it, and if not i'll just do it manually
23:11:27 <shachaf> lispy: A reasonable amount, given that it was the only language I spoke for ~8 years.
23:11:33 <lispy> ah
23:11:56 <lispy> shachaf: I don't recall you having an accent
23:12:06 <shachaf> Really?
23:12:10 <startling> shachaf: heh
23:12:22 <shachaf> Most people I've met said I had an accent.
23:12:34 <liyang> shachaf: I'm having difficulties pronouncing your name in my head. Please enlighten me.
23:13:10 <shachaf> liyang: It's pronounced ◊©◊ó◊£.
23:13:38 <rking> shachaf: Are there RTL markers around that I'm not seeing?
23:13:42 <shachaf> "At that moment liyang was enlightened."
23:14:17 <shachaf> rking: I don't think the RTL markers are needed. Copy the text somewhere outside your terminal that does proper Unicode rendering.
23:14:19 <Cale> Oh come on, at least include the nikud.
23:14:26 <startling> liyang: it's sha like the hash
23:14:49 <rking> shachaf: Yes, it pasted flipped in Firefox. I don't get what's going on with that, though.
23:15:23 <shachaf> Cale: I don't have those keys on my keyboard.
23:17:11 <liyang> kittiwake?
23:17:35 <liyang> There's a road near Nottingham's CS department called Kittiwake Mews.
23:18:48 * cmccann considers telling people that his name is pronounced ‚òÉ.
23:19:22 * lispy laments his terminals poor unicode handling
23:19:42 <lispy> I'm amazed it gets ASCII right, except that I'm not.
23:20:11 <rking> lispy: What is it doing instead?
23:20:29 <shachaf> preflex: seen lament
23:20:29 <preflex>  Sorry, I haven't seen lament
23:21:19 <lispy> rking: I either see blanks or empty boxes.
23:21:29 <rking> lispy: Then that's probably just a font issue.
23:21:36 <lispy> or is it?
23:21:46 <rking> I was toying with urxvt's super-cool font layering just a few hours ago. Here's what I came up with for now:
23:21:58 * lispy knows that can be an issue, but doesn't trust his current setup to work that well
23:22:01 <rking> URxvt*font: xft:Monospace-8,xft:Code2000,xft:Code2001,xft:Code2002,xft:Quivira
23:22:15 <rking> That's a mammoth stack, yet still a few are getting past it.
23:22:51 <lispy> I'm using putty on windows with the consolas font, connected to a linux server through ssh and tmux, and irssi is doing the IRC bits.  Who knows where the problem is!
23:23:22 <lispy> one of the core strengths of CS seems to be layers
23:23:22 <rking> lispy: Easy test is to switch to Arial. I know it has a good wad of glyphs.
23:23:32 <rking> CS?
23:24:42 <lispy> rking: well, software engineering might be more accurate than CS
23:25:08 <startling> lispy: it usually is
23:25:27 <lispy> putty doesn't seem to allow me to use Arial
23:25:38 <shachaf> lispy: Why are you using Windows these days?
23:27:36 <lispy> shachaf: I have a windows machine at home for the things that need windows. I happen to be sitting at in right now.
23:27:52 <lispy> shachaf: I use it for things like testing haskell packages on windows and playing games
23:27:54 <rking> lispy: Nevermind the Arial thing. The Consolas range should be good enough. You see this right? √∂  What about this? ‚ò∫?
23:28:05 <lispy> rking: yes, I see those
23:28:32 <shachaf> ¬∞Õú¬∞
23:28:36 <cmccann> but it's all meaningless if you can't see unicode snowmans
23:28:40 <cmccann> because come on
23:28:56 <Cale> http://i.imgur.com/NKSRv.jpg shachaf caught stealing
23:29:04 <rking> lispy: OK, well, the snowman was one I couldn't see before I played with those fonts this evening, so maybe you aren't missing out on too many common ones.
23:29:30 <rking> cmccann: The one I still don't have is Pile of Poo. I'm not sure what free font goes there.
23:29:37 <cmccann> awww
23:30:16 <lispy> rking: wait, you didn't do a snowman just now did you? I only saw an o with 2 dots above it, a smiley face, and then shachaf did two high circles and the second one had an arc under it
23:30:40 <lispy> rking: OSX includes pile of poo in the default font, for whatever reason
23:30:51 <cmccann> the jokes practically write themselves
23:31:14 <rking> lispy: No, I didn't. The thing that started this thread, "‚òÉ" is the reason I mentioned the snowman.
23:31:20 <rking> LOL
23:31:31 <lispy> a coworker changed his computer name to pile of poo so that when you browse the network for his computer  you see it. But only if you also have a mac.
23:31:40 <shachaf> U+2603    YESOD DEVELOPER [‚òÉ]
23:31:57 <kini> lispy: http://i.imgur.com/GP8sh.png
23:32:17 <lispy> kini: oh wow, that's very different than how it renders here
23:32:21 * lispy kicks putty
23:32:38 <kini> it's pretty different from how it renders here too - I had to copy and paste it into another application to get it to render properly
23:32:59 <kini> here it looks like this http://i.imgur.com/UZaki.png
23:33:23 <Ralith> shachaf: hah
23:33:44 <Ralith> kini: your decoder is broken
23:33:46 <bos> @pl \t a -> insert (f a) t
23:33:46 <lambdabot> flip (insert . f)
23:33:57 <cmccann> ùî¶ùî∞ ùî¶ùî± ùî±ùî¶ùî™ùî¢ ùî∂ùî¢ùî± ùî£ùî¨ùîØ ùî™ùî¢ ùî±ùî¨ ùî°ùî¨ ùî±ùî•ùî¶ùî∞ ùîûùî§ùîûùî¶ùî´?
23:34:07 <Ralith> man
23:34:08 <kini> Ralith: I guess it's Qt's renderer?
23:34:11 <Ralith> kini: no.
23:34:13 <shachaf> cmccann: My non-BMP UTF-8 is broken. :-(
23:34:17 <cmccann> pf
23:34:23 <shachaf> cmccann clearly wins.
23:34:28 <Ralith> cmccann: none of the several fonts my terminal searches has those.
23:34:32 <Ralith> I am impressed.
23:34:42 <shachaf> I bet it's DOUBLE-STRUCK.
23:34:44 <kini> Ralith: I don't think it's the decoder since if I copy and paste it elsewhere it looks fine. Also it has the basic elements, it's just not rendering both the circles
23:34:49 <rking> __C·¥è·¥è ü. I ·¥Ñ·¥è·¥ú ü·¥Ö…¥'·¥õ Íú±·¥á·¥á ·¥õ ú·¥èÍú±·¥á  ô·¥áÍú∞·¥è Ä·¥á ·¥ç è Íú∞·¥è…¥·¥õ ·¥õ·¥°·¥á·¥Ä·¥ãÍú±.__
23:34:52 <cmccann> ùîßùî≤ùî∞ùî± ùî¥ùîûùî±ùî†ùî•, ùî∞ùî¨ùî™ùî¢ùî°ùîûùî∂ ùî¥ùî¢'ùî©ùî© ùîûùî©ùî© ùîüùî¢ ùî±ùîûùî©ùî®ùî¶ùî´ùî§ ùî¶ùî´ ùî£ùîØùîûùî®ùî±ùî≤ùîØ.
23:34:52 <Cale> It's Fraktur
23:34:54 <shachaf> Oh.
23:35:12 <shachaf> Mathematicians. :-(
23:35:13 <Ralith> kini: oh, I thought you were quoting the snowman for some reason, whoops
23:35:17 * lispy has terminal envy
23:35:34 <Ralith> lispy: urxvt!
23:35:57 <rking> lispy: Cygwin + (u?)rxvt should do the trick.
23:36:01 <ion> Ôº°ÔΩàÔºå„ÄÄÔΩóÔΩÖ„ÄÄÔΩÅÔΩíÔΩÖ„ÄÄÔΩÑÔΩèÔΩâÔΩéÔΩá„ÄÄÔΩîÔΩàÔΩâÔΩì„ÄÄÔΩîÔΩàÔΩâÔΩéÔΩá„ÄÄÔΩîÔΩèÔΩÑÔΩÅÔΩôÔºé
23:36:11 <Ralith> ion: how pedestrian.
23:36:14 <lispy> rking: I won't use windows if it has cygwin...
23:36:18 * lispy is a snob
23:36:25 <Cale> ùïÄ ùïîùïíùïü ùïïùï† ùïïùï†ùï¶ùïìùïùùïñùï§ùï•ùï£ùï¶ùïîùïú ùïöùïó ùï™ùï†ùï¶ ùïùùïöùïúùïñ
23:36:42 * Polarina thinks this is getting too far.
23:36:52 <Ralith> that one works :D
23:36:58 <shachaf> ùïÄ ùïîùïíùïü ùïïùï† ùïïùï†ùï¶ùïìùïùùïñùï§ùï•ùï£ùï¶ùïîùïú ùïöùïó ùï™ùï†ùï¶ ùïùùïöùïúùïñ
23:37:02 <rking> lispy: Interesting. You're the anti-me in that regard.
23:37:04 <shachaf> I bet that came out all replacement characters.
23:37:07 <lispy> Polarina: and we're very off topic
23:37:08 <Cale> nope
23:37:11 <Ralith> renders fine
23:37:17 <jfischoff> Getting an odd error from some generated TH code:  Kind mis-match. The left argument of the equality predicate had kind `*', but `()' has kind `()'.
23:37:23 <Polarina> lispy, that too. Let's talk some Haskell.
23:37:27 <jfischoff> kind () ?
23:37:36 <Cale> jfischoff: hah, that's interesting
23:37:44 <cmccann> btw http://i.imgur.com/nfMOK.png is how it looked to me
23:37:51 <lispy> :k ()
23:37:52 <lambdabot> *
23:37:57 <shachaf> :k '()
23:37:58 <lambdabot>     lexical error in string/character literal at character ')'
23:37:59 <jfischoff> Cale: let me past the code in question
23:38:08 <Cale> cmccann: Looked about the same for me, except with better contrast :)
23:38:17 <Ralith> cmccann: what font?
23:38:18 <shachaf> jfischoff: It sounds like you're using the promoted value '() instead of the type ()
23:38:19 <hpaste> ‚ÄúJonathan Fischoff‚Äù pasted ‚ÄúKind ()‚Äù at http://hpaste.org/76304
23:38:31 <jfischoff> shachaf: yeah it does
23:38:47 <ion> I challenge thee to a fishoff.
23:38:48 <cmccann> I've gotten some awesome error messages recently that tell me a function is applied to one argument, but it's type a -> b only has one argument
23:38:59 <cmccann> I think GHC is getting confused somewhere along the line
23:39:15 <shachaf> cmccann: I got those sorts of messages!
23:39:16 <jfischoff> shachaf: I wonder if it is getting confused by ''()
23:39:35 <Cale> cmccann: shachaf got one which even had the inequality completely backward
23:39:35 <cmccann> Ralith, can't recall. I installed a whole pile of random unicode font crap a while ago
23:39:40 <shachaf> cmccann: :t fmap fmap fmap join join join
23:40:13 <cmccann> "applied to five arguments but its type has only six"
23:40:15 <cmccann> bwahahahaha
23:40:33 <ion> :-D Which version says that? 7.6?
23:40:36 <shachaf> Yes.
23:40:45 <cmccann> I'm using 7.6.1
23:40:47 <Ralith> cmccann: what client, then?
23:40:47 <Polarina> All I get is a "Occurs check: cannot construct the infinite type:"
23:40:51 <shachaf> 7.4 doesn't do it.
23:41:10 <Cale> Ralith: Probably XChat
23:41:28 <cmccann> yeah
23:41:57 * cmccann figures that the arity mismatch error is getting included in other errors for some reason
23:42:14 <cmccann> and that it reports the actual arity it counts or something
23:42:21 <shachaf> @arr ity
23:42:22 <lambdabot> Avast!
23:42:36 <cmccann> every time I've gotten the bogus errors it was tacked on to the real error for no obvious reason
23:43:56 <Ralith> Cale: looked that way
23:44:01 <Ralith> I guess GTK has magic unicode powers?
23:44:13 <shachaf> hi pizzaplane
23:44:59 <cmccann> I'm assuming it will find other fonts that provide missing characters from the font you specify
23:45:03 <Cale> Ralith: Sorta. Everything using Freetype does -- when the requested font doesn't have a glyph, it will try to find the most similar font which does.
23:45:12 <cmccann> because if I change the font in xchat it doesn't change the appearance of the fraktur letters
23:45:17 <Cale> Ralith: and there's a bunch of configuration for how it prioritizes things.
23:45:37 <shachaf> Cale: So you're saying that glyphs are Freetype-variable.
23:45:41 <Cale> I'm amazed that other systems don't even attempt to do this
23:46:10 <Cale> heh
23:46:10 <Ralith> that is pretty neat
23:46:33 <Ralith> urxvt has a manually supplied search list for that
23:46:36 <jfischoff> Well I got around that by using mkName instead of '()
23:46:38 * cmccann is always surprised when other systems don't do it that way
23:46:42 <Ralith> would be nice if it'd just go through everything on my system (maybe it does?)
23:46:43 <jfischoff> but I feel dirty
23:47:30 <cmccann> jfischoff, did you try tricking it with a type synonym, if that'd be possible?
23:47:49 <cmccann> I had to make a synonym to get TH to stop flipping its shit over (+) on type nats
23:48:05 <jfischoff> hmm I'm not sure I follow?
23:48:16 <jfischoff> I need to reify the DataD for ()
23:48:44 <edwardk> cmccann: didn't like the fact that it doesn't start with a : ?
23:48:47 <jfischoff> and I need to make the ConT ()
23:48:55 <cmccann> oh, I read that as something involving type/kind promotions, heh
23:49:08 <cmccann> edwardk, beats me
23:49:28 <jfischoff> cmccann: I think that might be why ghc is getting confused
23:49:29 <cmccann> I pretty quickly gave up on quoting anything at all
23:49:39 <cmccann> because too much stuff didn't work well
23:56:59 <Polarina> What are the significant differences between vectors and arrays? When should I pick one over the other?
