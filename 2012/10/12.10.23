00:19:21 <unlink> monochrom: haskell-indent-mode
00:24:12 <unlink> which I suppose is the same as turn-on-haskell-indent
00:31:48 <Sam734> I have these two datatype: data Data: I Integer| S String| List [Data]
00:32:28 <Sam734> and type Constraint = Data->String
00:32:37 <shachaf> The name "Constraint" is taken. :-)
00:32:52 <Sam734> I need to define a function called list
00:33:01 <shachaf> (Is this homework?)
00:33:28 <Sam734> with this signature: list :: Constraint -> Constraint
00:33:53 <Sam734> that datum is a list, the elements of which satisfy the argument constraint.
00:34:20 <Sam734> that datum is a list, the elements of which satisfy the argument constraint.
00:34:27 <Sam734> van anyone help?
00:34:33 <mcstar> (Is this homework?)
00:34:39 <Sam734> yes
00:34:47 <dimka> van datum
00:34:54 <mcstar> best dj ever
00:35:07 <dmwit> type Constraint = Data -> String -- what justifies the name "constraint" here?
00:35:35 <Sam734> expressing constraints, with which one can validate data.
00:35:58 <mcstar> it looks like a conversion function
00:36:02 <dmwit> How does returning a String correspond to validation?
00:36:32 <Sam734> for example, I have written a integer function like this:
00:36:38 <shachaf> @quote AlanPerlis string
00:36:39 <lambdabot> AlanPerlis says: The string is a stark data structure and everywhere it is passed there is much duplication of process. It is a perfect vehicle for hiding information.
00:36:46 <Sam734> >integer :: Constraint
00:36:53 <Sam734> integer (I _) = "ok"
00:36:59 <Sam734> integer x = "error: expected integer, but found" ++ show x
00:37:36 <mcstar> heh, is that really good? according to shachaf and alan perlis thats nonsensical
00:37:36 <dmwit> Okay.
00:37:50 <dmwit> If you're allowed to, I would recommend using a better type than String.
00:38:10 <dmwit> For example, data Validation = OK | Problem String -- would be one such better type
00:38:27 <dmwit> That's orthogonal to your question, though.
00:38:38 <Sam734> yes i am allowed
00:38:57 <dmwit> For your actual question, you'll need to decide a few things, like: should this be like a "forall" constraint or an "exists" constraint?
00:39:24 <sheriff_> Sam734: How's FPR going?
00:39:27 <dmwit> Once you've done that, you should consider building analogs of these two functions:
00:39:30 <dmwit> ?src any
00:39:30 <lambdabot> any p =  or . map p
00:39:31 <dmwit> ?src all
00:39:31 <lambdabot> all p =  and . map p
00:39:37 <dmwit> ?src or
00:39:37 <lambdabot> or    =  foldr (||) False
00:39:40 <dmwit> etc.
00:39:56 <mcstar> i dont really why you want to validate, in haskell you can already pattern match on the constrcutor
00:40:01 <dmwit> :t any -- note the close analogue between any's type and your type
00:40:02 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:40:03 <mcstar> understand*
00:40:56 <mcstar> just go along, and pattern match your functions that manipulate Data on I,S,List
00:41:05 <shachaf> I,I anyOf traverse p, allOf traverse p
00:41:13 <dmwit> > mapM (\x -> if even x then Left "NO EVENS ALLOWED" else Right x) [3, 5, 7]
00:41:14 <lambdabot>   Right [3,5,7]
00:41:18 <dmwit> > mapM (\x -> if even x then Left "NO EVENS ALLOWED" else Right x) [3, 5, 7, 8]
00:41:19 <lambdabot>   Left "NO EVENS ALLOWED"
00:41:20 <shachaf> Well, if your tree was parameterized.
00:41:27 <shachaf> Cale: Can we have Control.Lens in lambdabot? :-)
00:41:41 <shachaf> Oh, maybe not.
00:42:23 <mcstar> shachaf: whats 'I,I' ?
00:42:32 <hpaste> astor pasted “Making Cloud Haskell testable” at http://hpaste.org/76647
00:42:33 <sheriff_> I have no joke, I just like to say
00:42:34 <shachaf> mcstar: Ask maukd.
00:42:50 <sheriff_> It's an old throwback from 1996-era #perl on Efnet
00:42:52 <mcstar> i dont dare to do that
00:42:58 <shachaf> OK, ask sheriff_.
00:43:09 <mcstar> sheriff_: whats 'I,I' ?
00:43:13 <astor> can someone help me understand how to get rid of the IO in my past (XProcess) and still have the GeneralizedNewtypeDeriving stuff work?
00:43:19 <sheriff_> mcstar: 07:42 < sheriff_> I have no joke, I just like to say
00:43:31 <shachaf> I think it's "point", not "joke"
00:43:37 <shachaf> Anyway I don't know what it means.
00:43:42 <mcstar> k
00:43:54 <sheriff_> mcstar: It's a way of highlighting interesting or odd sounding phrases
00:44:10 <sheriff_> awwww, Sam734 quit when I knew which bit of homework he was doing
00:44:26 <sheriff_> He has 5 hours and 17 minutes to get it completed
00:44:29 <astor> Process in that past is the Process monad in Cloud Haskell, but I'd want it to look more like XProcess in order to be able to test/mock.
00:44:53 <sheriff_> If he still hasn't reached dmwit's solution of using a parameterized return type, he's in trouble.
00:45:03 <mcstar> you cant put anything else besides Integer, String and Data into a Data, so i dont get that validation stuff
00:45:25 <dmwit> astor: You can use StandaloneDeriving to give explicit contexts.
00:45:36 <sheriff_> mcstar: The assignment makes you specify a DSL around a datatype called Data
00:45:42 <sheriff_> mcstar: And then a DSL specifying constraints against it
00:45:48 <dmwit> err...
00:45:48 <mcstar> ML's type system was developed to 'not allow non-proofs infiltrate proofs'
00:46:00 <dmwit> Maybe I'd better see what the actual problem is instead of guessing.
00:46:00 <astor> dmwit: thanks.  Will investigate.
00:46:10 <mcstar> sheriff_: is that assigment in haskell originally?
00:46:14 <dmwit> astor: Don't investigate yet. likelihood of wild goose chase >70%
00:46:17 <sheriff_> mcstar: yes
00:46:29 <sheriff_> mcstar: Well, as handed to us
00:46:46 * sheriff_ got it finished this morning, after perhaps 120 hours of work
00:46:52 <mcstar> coursera or similar?
00:48:39 <dmwit> ah, yeah, I have no idea what that error even means let alone how to deal with it. =P
00:48:50 <dmwit> Shouldn't be hard to write your own instances for Monad and MonadIO, though.
00:49:00 <sheriff_> I changed all references to "parametric polymorphism" to "quasi parametric polymorphism" and "apparenty - from a programmers perspective - parametric polymorphism"
00:49:09 <sheriff_> and am hoping I have saved the essay
00:49:28 <dmwit> astor: Any good reason not to have the m visible to the left of the equals sign?
00:50:12 <dmwit> You can get everything but Typeable if you do.
00:50:19 <neworder> Hi guys
00:50:32 <neworder> I have problems understanding the following function
00:50:46 <neworder> transpose l = map (\i->map (!!i) l) [0 .. (length l - 1)]
00:50:47 <astor> dmwit: no that's fine I think.  But I think I need Typeable as well.
00:51:21 <neworder> If I apply the function to [[1,2,3],[4,5,6],[7,8,9]]
00:51:45 <sheriff_> What is !!?
00:51:52 <dmwit> list indexing
00:51:53 <sheriff_> That looks like a Perl programmer trying to coerce to bool
00:51:53 <mcstar> list indexing
00:51:54 <dmwit> :t (!!)
00:51:55 <lambdabot> forall a. [a] -> Int -> a
00:52:08 <sheriff_> What's the difference between that and !?
00:52:15 <mcstar> ! is for arrays
00:52:22 <dmwit> (!) is for arrays, maps, etc.
00:52:36 * dmwit high fives mcstar
00:52:36 <sheriff_> Where'll I find this documented?
00:52:41 <mcstar> not to conflict with prelude
00:52:41 <dmwit> ?hoogle (!!)
00:52:42 <lambdabot> Prelude (!!) :: [a] -> Int -> a
00:52:42 <lambdabot> Data.List (!!) :: [a] -> Int -> a
00:52:42 <lambdabot> Control.DeepSeq ($!!) :: NFData a => (a -> b) -> a -> b
00:52:44 <dmwit> ?hoogle (!)
00:52:45 <lambdabot> Prelude (!!) :: [a] -> Int -> a
00:52:45 <lambdabot> Data.List (!!) :: [a] -> Int -> a
00:52:45 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
00:52:48 <dmwit> In there.
00:52:49 <sheriff_> nice, thanks
00:53:06 <sheriff_> Google makes ! rather hard to search for :{P
00:53:18 <neworder> The function basically transposees a matrix
00:53:19 <dmwit> Yes, Hoogle is the One True Way to search for Haskell operators.
00:53:19 <mcstar> oh, use hoogle
00:53:32 <mcstar> sheriff_: hoogle is available on the command line too
00:53:37 <dmwit> neworder: Yep, we're with you. We're just waiting for you to finish your question.
00:53:46 <mcstar> (i guess google can be too, but thats not my point)
00:54:06 <neworder> Oh ok
00:54:20 <neworder> I don't exactly see how the transpose matrix is formed
00:54:25 <neworder> I know that
00:54:41 <sheriff_> I think I was just deeply confused, and secretly knew already that in Haskell it was !!.
00:54:57 * sheriff_ has spent a week studying Erlang and may be overestimating his familiarity with !
00:55:43 <dmwit> neworder: Okay, let's specialize the map a bit. What do you think the function "foo l = map head l" would do?
00:56:13 <neworder> I know that transpose [[1,2,3],[4,5,6],[7,8,9]] = map (\i->map (!!i) l) [0,1,2]
00:56:16 <neworder> Hmm
00:56:23 <neworder> lemme think
00:57:11 <mcstar> i think you should break down the expressions, like understanding separately what the 2 maps do
00:58:32 <neworder> The function foo gives the head element of the list l
00:58:39 <neworder> right?
00:58:44 <mcstar> no
00:58:44 <dmwit> Not quite, actually.
00:58:48 <dmwit> Perhaps we should back up farther.
00:58:51 <dmwit> Do you know what map does?
00:59:11 <mcstar> in general, not here
00:59:25 <neworder> yes, it takes in a function and a list and maps the function to every element in the list
00:59:33 <dmwit> Right, okay.
00:59:46 <mcstar> whats the function here?
00:59:47 <dmwit> So, let's take that sentence and substitute in blindly:
01:00:09 <dmwit> map head takes in a list and maps head to every element in the list
01:00:21 <mcstar> dmwit: i wanted him to say that
01:00:39 <neworder> haha ok
01:00:48 <dmwit> Now, this is a bit interesting, because it means *each element* of the list must be something "head" can be applied to... meaning each element of the list is itself a list.
01:00:56 <neworder> map applies the function head to every element in the list
01:01:02 <mcstar> neworder: great
01:01:25 <dmwit> Okay, without asking GHC, can you tell me what map head [[1,2,3],[4,5,6],[7,8,9]] outputs?
01:02:29 <neworder> [1,2,3]
01:02:34 <mcstar> nah
01:02:36 <neworder> [4,5,6]
01:02:42 <mcstar> nah
01:02:48 <neworder> Ohh!
01:02:52 <neworder> Haha!
01:02:54 <neworder> Got it
01:03:15 <neworder> So it returns [1,4,7]
01:03:31 <mcstar> now replace head with (!!i)
01:04:41 <mcstar> think of l!!i as the ith element of l, 0 based
01:05:20 <neworder> [1,2,3]
01:05:25 <neworder> eh
01:05:27 <neworder> no
01:05:34 <mcstar> map (!!i) [[1,2,3],[4,5,6],[7,8,9]] for all the is
01:05:43 <dmwit> mcstar: You're going way too fast, I think.
01:05:45 <mcstar> there is no one answer
01:05:57 <mcstar> dmwit: feel free to intervene
01:05:57 <neworder> So it returns the 1 index, 4th index, and 7 index? Am I missing something
01:05:59 <dmwit> neworder: Anyway, yes, it returns [1,4,7].
01:06:09 <dmwit> neworder: No, it doesn't return different indices.
01:06:21 <dmwit> neworder: Let's go slow, and ignore mcstar for now.
01:06:37 <dmwit> (I just had to jiggle the handle on my toilet, sorry for being gone a bit.)
01:07:05 <dmwit> Okay, I have a few more map head exercises before we move on.
01:07:17 <neworder> Hmm ok
01:07:28 <neworder> sure
01:07:38 <dmwit> What do you think map head [[82,16,35],[46]] returns? map head [[82,16,35],[]]? what does map head [1,2,3] do?
01:08:13 <dmwit> How about map head []?
01:08:16 <neworder> map head [[82,16,35],[46]] returns 82 and 46
01:08:23 <dmwit> right so far
01:09:02 <shachaf> Well, it's [82,46] :-)
01:09:25 <neworder> Oh yah, was just thinking whether its [82,46] or seperate
01:09:37 <sheriff_> Is it possible to construct a map function over an empty list that doesn't simply return an empty list?
01:09:44 <dmwit> Ah, I'm glad that shachaf spoke up, then.
01:09:47 <mcstar> :t map --map returns a list
01:09:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:09:50 <neworder> map head [[82,16,35],[]] returns [82,[]]?
01:10:04 <dmwit> sheriff_: No, and you can prove it with the free theorem for map's type.
01:10:14 <sheriff_> > head []
01:10:15 <lambdabot>   *Exception: Prelude.head: empty list
01:10:21 <dmwit> sheriff_: (Assuming you don't allow things like undefined and friends.)
01:10:32 <sheriff_> > map head [[82,16,35],[]]
01:10:33 <dmwit> neworder: Aha! I tricked you. =)
01:10:34 <lambdabot>   [82,*Exception: Prelude.head: empty list
01:10:57 <sheriff_> > map head []
01:10:58 <lambdabot>   []
01:11:02 <sheriff_> OK, all is right in the world.
01:11:02 <neworder> haha, so there's only a tail for empty list right? I think I have head that before
01:11:17 <mcstar> no tail no head
01:11:17 <dmwit> neworder: Remember, all the elements of a list have to have the same type. So [82,[]] should already be a red flag for you: 82 is a number, but [] isn't!
01:11:30 <sheriff_> > tail []
01:11:31 <lambdabot>   *Exception: Prelude.tail: empty list
01:11:40 <dmwit> (up to some shoddy business that we won't get into here)
01:11:51 <neworder> oh
01:11:54 <neworder> alright
01:12:20 <dmwit> Right, so head of an empty list throws an exception. So map head of a list containing an empty list does, too.
01:12:27 <mcstar> neworder: have you seen the definition of the list type?
01:12:30 <neworder> > map head [1,2,3]
01:12:31 <lambdabot>   No instance for (GHC.Num.Num [a])
01:12:31 <lambdabot>    arising from a use of `e_1123' at <int...
01:12:33 <dmwit> Let's keep going. What do you think map head [1,2,3] does?
01:12:37 <mcstar> if not, look at that first
01:12:45 <neworder> ohh
01:12:52 <dmwit> Ah, you cheated and asked GHC. =P
01:13:02 <neworder> it doesn't make sense to apply head function to a number
01:13:04 <neworder> haha, soryr
01:13:06 <dmwit> right!
01:13:06 <neworder> sorry*
01:13:20 <dmwit> How about the last one, map head []?
01:13:34 <mcstar> sheriff_ blew that one
01:13:36 <mcstar> too
01:13:38 <sheriff_> sorry
01:13:48 <sheriff_> I was trying to sound clever
01:14:00 <dmwit> Maybe neworder didn't see, or will choose not to look while he thinks. =)
01:14:01 <mcstar> sheriff_: you can chat privately with lambdabot if you wish
01:14:48 <neworder> haha, I won't see
01:15:15 <neworder> I think it would return an empty list, that's the definition of the map function right? =)
01:15:35 <dmwit> right!
01:15:53 <dmwit> Alright.
01:15:59 <dmwit> Now, another way to spell head is (!!0).
01:16:09 <dmwit> Have you seen operator sections before? Have you seen the (!!) operator before?
01:16:29 <neworder> sorry, gimme a min
01:16:35 <mcstar> yes or no
01:16:37 <mcstar> right now
01:16:59 <dmwit> (mcstar is just joking... I think)
01:17:00 <neworder> yes :)
01:17:09 <mcstar> never
01:17:22 <dmwit> Okay.
01:17:33 <neworder> 1 min, attending to something else.....
01:17:33 <dmwit> So, then, now you know how map (!!0) works.
01:17:39 <dmwit> Yep, let us know when you're back.
01:18:57 <sheriff_> safeHead [] = [] \n safeHead = head
01:19:07 <mcstar> nah
01:19:16 <mcstar> try it out and see
01:19:25 <dmwit> safeHead = take 1
01:20:01 <mcstar> also, it might not be that practical, since you might really want to do something else when the list is empty
01:20:05 <mcstar> better not to mask it
01:20:10 <sheriff_> Sorry, was just thinking outloud
01:20:54 * sheriff_ will be starting a new job with no programming component in 8 weeks, and is in a last-ditch attempt to have some fun before then
01:21:06 <Cale> sheriff_: Type error aside, it's also worth noting that there's a somewhat arbitrary syntactic restriction against providing multiple equations with different numbers of arguments
01:21:25 <sheriff_> I did wonder if I wanted: safeHead x = head x for the second part
01:22:42 <Cale> I guess that's not a type error actually, just a bit funny :)
01:23:05 <Cale> :t let safeHead [] = []; safeHead x = head x in safeHead
01:23:06 <lambdabot> forall a. [[a]] -> [a]
01:23:45 <mcstar> it is a type error in my book, since it doesnt do what a safe head supposed to do
01:23:49 <sheriff_> Ah, that's a neat way of defining one-line functions
01:23:50 <mcstar> :t head
01:23:51 <lambdabot> forall a. [a] -> a
01:24:15 <mcstar> the inferred type is not what you want
01:24:27 <mcstar> how do you call these errors?
01:24:33 <sheriff_> :t let safeHead [] = Nothing; safeHead x = Just (head x) in safeHead
01:24:34 <lambdabot> forall a. [a] -> Maybe a
01:24:36 <dmwit> mcstar: "bug"
01:24:39 <mcstar> lol
01:24:51 <mcstar> dmwit: never heard of those
01:24:51 <sheriff_> although what utility that gives, I have no idea
01:25:06 <mcstar> @hoogle listToMaybe
01:25:07 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
01:25:15 <mcstar> sheriff_: its already written
01:25:33 <mcstar> i used it for a depth first search for example
01:25:35 <mcstar> it made sense
01:29:29 <akamaus> please, advice a lightweight regex package. I will apply regexes to small chunks of text, so efficiency is not of primary concern.
01:31:09 <sopvop> oh, regex packages... there are too much of them :(
01:31:45 <fmap> akamaus: why not parsec/attoparsec?
01:33:22 <akamaus> fmap, hmm, really :) Probably I've been doing too much scripting.
01:33:38 <sopvop> http://www.haskell.org/haskellwiki/Regular_expressions my guess is regex-pcre-builtin
01:33:51 <sopvop> or posix
01:40:23 * hackagebot aws-sdk 0.4.3.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.4.3.0 (YusukeNomura)
01:43:15 <mcstar> i hurt maukd's feelings one regarding perl, so to balance, id suggest now that you use perl for regular expressions
01:43:33 <mcstar> once*
01:46:00 <neworder> dmwit mcstar: Yup, I know how (!!0) works, understood how the function works, thanks! =)
01:46:26 <mcstar> im glad
01:50:00 <akamaus> fmap, can you remind me is there parser for floats in parsec or I should define one myself?
01:51:17 <mcstar> neworder: another transpose: transpose lst = splitEvery (length lst) $ concat lst
01:52:08 <mcstar> also, dont use lists in place of matrices if you want to work on larger ones
01:53:10 <mcstar> yeah, i know, my transpose doesnt tranpose
01:53:15 <mcstar> fail
01:55:19 <neworder> Hmm alright
01:56:11 <neworder> How do I ask lambdabot about the  : operator
01:56:16 <alpounet> @type (:)
01:56:17 <lambdabot> forall a. a -> [a] -> [a]
01:56:28 <fmap> akamaus: I don't know. Attoparsec should have parsers for numbers defined.
01:56:30 <nicoo> @def (:)
01:56:30 <lambdabot> Maybe you meant: bf do let
01:57:14 <alpounet> attoparsec does. parsec has a "float" parser associated to GenTokenParser or smth, see http://hackage.haskell.org/packages/archive/parsec/3.0.0/doc/html/Text-Parsec-Token.html
01:57:41 <alpounet> @src []
01:57:41 <lambdabot> data [] a = [] | a : [a]
01:57:43 <mcstar> neworder: and you can turn a function into an operator with ``
01:57:57 <mcstar> > div 4 2 == 4 `div` 2
01:57:59 <lambdabot>   True
01:58:12 <merijn> neworder: Surrounding operators with () turns them into prefix functions (which you can then use :t on)
01:58:30 <neworder> Hmm, I see
01:58:49 <neworder> > 2 `+` 5
01:58:50 <lambdabot>   <no location info>: parse error on input `+'
01:59:02 <neworder> > (+) 2 5
01:59:03 <lambdabot>   7
01:59:05 <mcstar> + is already infix
01:59:16 <neworder> Hmm I see!
01:59:18 <mcstar> it isnt alphanumerical
01:59:41 <merijn> > 1 `elem` [1..]
01:59:42 <lambdabot>   True
01:59:58 <merijn> > (==) 1 2
02:00:00 <lambdabot>   False
02:00:03 <mcstar> neworder: but watch out, it is not like lisp
02:00:10 <mcstar> > (+) 1 2 3
02:00:11 <lambdabot>   3
02:00:21 <merijn> mcstar: Ha!
02:00:24 <mcstar> well, lambda accepts it
02:00:28 <mcstar> lambdabot*
02:00:31 <merijn> mcstar: Tricked by lambdabot :p
02:00:38 <neworder> haha, didn't expec tthat!
02:00:41 <neworder> expect*
02:00:50 <merijn> neworder: Ignore that result, it only happens in lambdabot
02:01:00 <mcstar> merijn: i expected it to be accepted, but it doesnt add 3 to 3
02:01:02 <merijn> neworder: GHC/ghci will produce a compile error
02:01:08 <mcstar> so it still demonstrates what i wanted
02:02:35 <neworder> Hmm ok
02:02:40 <akamaus> alpounet, found it, I'm not sure how to be with the language definition, though. It seems to be oriented on programming languages and I'm going to parse short English sentences.
02:03:16 <osa1> how can I use a cabal-dev installed package with ghc ?
02:04:29 <merijn> neworder: Basically, in haskell numeric literals are overloaded and can be any numeric type and lambdabot has a numeric type for functions (where 3 = \_ -> 3)
02:05:16 <alpounet> akamaus, yeah, i know :/ but attoparsec for sure does provide that, and is more efficient
02:05:24 <neworder> Hmm ok
02:05:49 <merijn> > 2 3 -- identical to "(\_ -> 2) 3"
02:05:51 <lambdabot>   2
02:06:11 <neworder> I was looking at the function definition for map
02:06:13 <neworder> map f (x:xs) = f x : map f xs
02:06:26 <neworder> why is x:xs not in square brakets
02:06:41 <startling> neworder, because that's different
02:06:43 <neworder> I expected this map f [x:xs] = f x : map f xs
02:06:52 <statusfailed> Can I get Aeson to parse a JSON object as an association list of smaller objects?
02:06:57 <startling> neworder, the parens are just for order of operations
02:07:06 <startling> > [1:[]]
02:07:07 <lambdabot>   [[1]]
02:07:11 <merijn> neworder: [1,2,3,4] is syntactic sugar for "1 : (2 : (3 : (4 : [])))"
02:07:12 <Ferdirand> [x:xs] would be (x:xs):[]
02:07:16 <startling> > (1:[])
02:07:17 <lambdabot>   [1]
02:07:56 <akamaus> alpounet, you seem to be a fan of it :) Can you please describe a difference in a few words? I know Attoparsec is for parsing bynary protocols and I'm parsing peaces of text grabbed with html-couduit.
02:08:09 <merijn> neworder: matching (x:xs) with 1 : (2 : (3 : (4 : []))) results in "x = 1" and "xs = 2 : (3 : (4 : []))"
02:08:48 <neworder> hmm ok
02:08:53 <merijn> neworder: Hence, no square brackets are needed. They are only used as convenience for programmers, because explicitly writing it like that is very tedious
02:09:28 <neworder> what happens if we don't have the parantheses
02:09:30 <neworder> like this
02:09:36 <neworder> map f x:xs = f x : map f xs
02:09:44 <merijn> neworder: Using "[x]" as pattern matches "x:[]" as Ferdirand points out, so "[x:xs]" would match "(x:xs):[]", which is something different
02:10:08 <alpounet> akamaus, it's not only for binary protocols. it's not the one that will let you have awesome errors/reports handling, but it's well designed and fast. anyway, it's either attoparsec, parsec or trifecta, so...
02:10:18 <merijn> neworder: Then it can be unclear whether you wrote "map (f x) : xs" or "map f (x:xs)"
02:10:52 <neworder> Hmm I see!
02:10:57 <ivanm> and function binding trumps operator precedence
02:11:17 <alpounet> akamaus, see Don's post there: http://stackoverflow.com/questions/3077207/choosing-a-haskell-parser it sums up what we've been saying
02:11:26 <merijn> neworder: An example where it is ambiguous without parenthesis: "f :: [Maybe a] -> [Maybe a]; f (Just x):xs = x"
02:11:32 <ivanm> merijn: even better, wouldn't that parse as "(map f x) : xs ?
02:11:58 <merijn> ivanm: that is supposed to be the left hand of an equation
02:12:04 <ivanm> oh, right
02:12:13 <merijn> neworder: Clearly you could also have
02:12:14 <ivanm> still, can the parser tell that?
02:12:37 <neworder> Didn't understand this part  "f :: [Maybe a] -> [Maybe a]; f (Just x):xs = x"
02:12:48 <merijn> neworder: Wait
02:12:54 <merijn> neworder: That code is wrong :p
02:13:01 <merijn> I started writing one function and meant another
02:13:06 <merijn> that should return xs, not x
02:13:09 <neworder> haha ok
02:13:23 <mcstar> let transpose list = let tr list = map head list : tr (map tail list) in take (length $ head list) (tr list)
02:13:40 <mcstar> this is a way to transpose an nxm listmatrix
02:13:48 <merijn> Another way of parsing f would be "f (Just (x:xs)) = Just xs" which'd be "Maybe [a] -> Maybe [a]"
02:14:10 <mcstar> pretty lame, but it works, as long as you give it sane inputs
02:14:11 <merijn> neworder: So the parenthesis are mostly there to keep the parser unconfused about how to group constructors in the patterns
02:14:25 <shachaf> Is there a way to write the function foo :: (a -> b) -> a -> Identity b which doesn't eta-expand its argument, without using unsafeCoerce?
02:14:27 <neworder> yup, got that
02:14:29 <neworder> thanks
02:15:21 <mcstar> > let tr list = map head list : tr (map tail list) in [[1,2],[3,4],[5,6]]
02:15:23 <lambdabot>   [[1,2],[3,4],[5,6]]
02:15:28 <mcstar> > let tr list = map head list : tr (map tail list) in tr [[1,2],[3,4],[5,6]]
02:15:30 <lambdabot>   [[1,3,5],[2,4,6],[*Exception: Prelude.head: empty list
02:15:40 <mcstar> so thats why there is a take at the end
02:15:55 <akamaus> alpounet, wow, almost two order of magnitude difference in performance between parsec and attoparsec. Impressive! http://www.serpentine.com/blog/2010/03/03/whats-in-a-parser-attoparsec-rewired-2/
02:16:03 <alpounet> yeah...
02:16:04 <mcstar> to take only so much elements, before that head reaches a []
02:16:45 <mcstar> also, its annoying, to copy unintended newlines...
02:19:56 <mcstar> also, i should point out, that this works, because haskell evaluates things as you need them
02:20:55 <neworder> I saw this on page 61 of learn you a haskell
02:21:06 <neworder> sum ' :: (Num a) => [a] -> a
02:21:07 <neworder> sum ' xs = foldl (\ acc x -> acc + x) 0 xs
02:21:35 <neworder> what's acc
02:21:37 <mcstar> sum ' is wrong
02:21:40 <danr> neworder: accumulator
02:21:55 <neworder> hmm
02:22:05 <merijn> neworder: It's just a variable name in a lambda function :)
02:22:12 <danr> think of it as the sum of all numbers so far
02:22:25 <merijn> neworder: It's just that acc is a semi-standard name for accumulators in folds, etc.
02:23:03 <merijn> > foldl (\ acc x -> acc + x) 0 [1..10]
02:23:04 <lambdabot>   55
02:23:13 <merijn> > foldl (\ xyzzy x -> xyzzy + x) 0 [1..10]
02:23:14 <lambdabot>   55
02:23:39 <neworder> Ah I see
02:23:43 <mcstar> > foldl (+) 0 [1..10] == (1+10)*10`div`2
02:23:44 <lambdabot>   True
02:24:38 <merijn> neworder: Lambda functions can have any number of names or patterns to the left of the arrow
02:24:57 <mcstar> and to the right of \
02:25:25 <akamaus> alpounet, fmap, do like the AttoParsec's API :) It's simple and more than enough for my task. Thanks for the suggestion!
02:25:41 <alpounet> you're welcome, enjoy :)
02:27:45 <pordan30>  foo = (Identity .) :: (a -> b) -> a -> Identity b doesn't eta expand, no
02:28:00 <shachaf> pordan30: Yes it does.
02:28:12 <shachaf> I mean strictness-wise.
02:28:30 <shachaf> > let foo :: (a -> b) -> a -> Identity b; foo = (Identity .) in foo undefined `seq` ()
02:28:33 <lambdabot>   ()
02:28:33 <shachaf> > let foo :: (a -> b) -> a -> Identity b; foo = (Identity .) in undefined `seq` ()
02:28:35 <lambdabot>   *Exception: Prelude.undefined
02:29:38 <mcstar> :t Identity
02:29:39 <lambdabot> forall a. a -> Identity a
02:29:46 <pordan30> i see - sorry :/
02:30:29 <mcstar> ah, so . IS the composition
02:33:30 <mcstar> Identity seems like an applicative functor, am i close/far?
02:33:48 <mcstar> well, Identity .
02:33:49 <statusfailed> is there a cool way to turn a (a, m b) into an m (a, b) ?
02:33:58 <statusfailed> where m is a monad
02:34:03 <ivanm> don't think so...
02:34:13 <ivanm> @hoogle (a, m b) -> m (a,b)
02:34:14 <lambdabot> No results found
02:34:25 <ivanm> @free (Monad m) => (a, m b) -> m (a,b)
02:34:25 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
02:34:29 <ivanm> :o
02:34:37 <statusfailed> whut
02:34:47 <statusfailed> what does @free do?
02:34:49 <Botje> liftM2 (,) (return $ fst x) (snd x)
02:34:51 <ivanm> @help free
02:34:51 <lambdabot> free <ident>. Generate theorems for free
02:35:07 <ivanm> @free b -> (a -> b) -> Maybe a -> b
02:35:07 <lambdabot> Extra stuff at end of line
02:35:12 <ivanm> bah
02:35:19 <ivanm> obviously I've forgotten how to use @free
02:35:35 <statusfailed> Botje: oh, nice... :D
02:35:40 <ivanm> @type liftM2 (,) (return . fst) snd
02:35:42 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a, b) -> (m a, b)
02:35:46 <statusfailed> ivanm: so it's like djinn?
02:35:55 <ivanm> statusfailed: oh, maybe I've mixed them up...
02:36:00 <ivanm> I was probably wanting djinn :s
02:36:04 <statusfailed> I don't think djinn can handle type classes though
02:36:13 <ivanm> @type \ x -> liftM2 (,) (return . fst $ x) (snd x)
02:36:15 <lambdabot> forall a2 (m :: * -> *) a. (Monad m) => (a, m a2) -> m (a, a2)
02:36:18 <ivanm> it can Monads IIRC
02:36:25 <ivanm> @djinn b -> (a -> b) -> Maybe a -> b
02:36:26 <lambdabot> f a b c =
02:36:26 <lambdabot>     case c of
02:36:26 <lambdabot>     Nothing -> a
02:36:26 <lambdabot>     Just d -> b d
02:36:29 <ivanm> \o/
02:36:37 <statusfailed> or I lied
02:36:39 <ivanm> @djinn (Monad m) => (a, m b) -> m (a,b)
02:36:39 <lambdabot> -- f cannot be realized.
02:36:42 <ivanm> heh
02:37:26 <fmap> akamaus: I tend to write prototype parser in parsec since it gives better errors and then rewrite it in attoparsec (both APIs are very similar)
02:38:00 <mcstar> shachaf: is eta expansion the turning of a value into a function with a dummy argument?
02:38:20 <mcstar> > let f _ = 4 in f ()
02:38:22 <lambdabot>   4
02:38:36 <shachaf> mcstar: Eta-expansion is f --> (\x -> f x)
02:38:51 <neworder> map' f xs = foldr (\x acc -> f x : acc ) [] xs
02:38:56 <alang> :t uncurry $ liftM . (,)
02:38:57 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a, m a1) -> m (a, a1)
02:39:24 <neworder> It says this in the book, If we’re mapping (+3) to [1,2,3], we approach the list from the right side.
02:39:26 <neworder> We take the last element, which is 3 and apply the function to it, which ends
02:39:28 <neworder> up being 6. Then, we prepend it to the accumulator, which is was [].
02:39:49 <mcstar> ah!
02:39:55 <neworder> I don't really get this part, Then, we prepend it to the accumulator, which is was [].
02:40:06 <neworder> there's a typo also right
02:40:10 <nicoo> neworder: The specification of map shouldn't specify its implementation :$
02:40:19 <GnomeStoleMyBike> @nixon
02:40:19 <lambdabot> Voters quickly forget what a man says.
02:40:31 <ivanm> neworder: it's easier to see when you use the foldr definition of map
02:40:31 <dmwit> neworder: What book?
02:40:33 <ivanm> @src map
02:40:34 <lambdabot> map _ []     = []
02:40:34 <lambdabot> map f (x:xs) = f x : map f xs
02:40:37 <ivanm> bah
02:40:51 <GnomeStoleMyBike> > :k Maybe
02:40:52 <lambdabot>   <no location info>: parse error on input `:'
02:40:54 <nicoo> @src liftM
02:40:54 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:40:55 * ivanm always has to remember how this works
02:40:56 <ivanm> :k Maybe
02:40:58 <ivanm> GnomeStoleMyBike: ^^
02:40:58 <lambdabot> * -> *
02:41:18 <neworder> I understand the original definition, but using the foldr, it's slightly confusing
02:41:28 <mcstar> > foldl f a [b,c,d,e]
02:41:30 <lambdabot>   f (f (f (f a b) c) d) e
02:41:31 <mcstar> vs
02:41:32 <neworder> Why do we prepend it to the accumulator, which is was [].
02:41:34 <mcstar> > foldr f a [b,c,d,e]
02:41:36 <lambdabot>   f b (f c (f d (f e a)))
02:41:40 <merijn> > foldr (\x acc -> f x : acc) a [b,c,d,e,g]
02:41:41 <lambdabot>   Couldn't match expected type `[a]'
02:41:41 <lambdabot>         against inferred type `SimpleRef...
02:41:50 <merijn> > foldr (\x acc -> f x : acc) a [b,c,d,e,g] :: Expr
02:41:51 <lambdabot>   Couldn't match expected type `[a]'
02:41:52 <lambdabot>         against inferred type `SimpleRef...
02:41:54 <merijn> aww
02:42:02 <ivanm> neworder: by "prepend" they mean use (:)
02:42:11 <merijn> > foldr f a [b,c,d,e,g]
02:42:13 <lambdabot>   f b (f c (f d (f e (f g a))))
02:42:13 <ivanm> as in "shove it on the front of the list"
02:42:18 <dmwit> merijn: Your base case is wrong.
02:42:39 <merijn> dmwit: oh, duh
02:42:50 <merijn> > foldr (\x acc -> f x : acc) [] [a,b,c,d,e] :: Expr
02:42:52 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
02:42:52 <lambdabot>         against inferred ...
02:43:06 <merijn> > foldr (\x acc -> f x : acc) [] [a,b,c,d,e] :: [Expr]
02:43:07 <lambdabot>   [f a,f b,f c,f d,f e]
02:43:39 <mcstar> anyway, it is better imho to look at foldl/foldr the way that above application of 'f' shows, rather than 'eats the list form left/right'
02:43:44 <merijn> neworder: Compare the result with
02:43:51 <merijn> > foldr f a [b,c,d,e,g]
02:43:53 <lambdabot>   f b (f c (f d (f e (f g a))))
02:44:15 <merijn> neworder: And try substituting "\x acc -> f x : acc" into that result by hand
02:44:22 <merijn> neworder: Working it out by hand should really help
02:44:43 <neworder> Hmm alright, trying that
02:44:45 <mcstar> now you can see, how you can terminate with foldr early on an infinite list
02:53:51 <startling> I'm playing with writing a parser by hand. I'd like detailed error messages for "a <|> b <|> c" -- I want to be able to say "expected an a or a b or a c". Would I need to have a separate constructor for choices?
02:56:05 <mcstar> shachaf: im sorry to sound stupid, but foo takes a second parameter, so 'foo undefined' cannot result in bottom in any case, can it?
02:56:21 <shachaf> mcstar: It can if you use unsafeCoerce!
02:56:51 <mcstar> :t unsafeCoerce
02:56:52 <shachaf> And also maybe if you do foo !f = \x -> Identity (f x)
02:56:53 <lambdabot> Not in scope: `unsafeCoerce'
02:56:58 <shachaf> unsafeCoerce :: a -> b
02:57:23 <mcstar> shachaf: so, you hide the fact that the first parameter is a function type with unsafeCoerce?
02:57:49 <shachaf> Hide?
02:57:52 <mcstar> nvm
02:59:53 <dmwit> I don't know the context of the question, but "foo f = undefined" is a perfectly good definition and can be given a type which has "two" arguments.
03:00:20 <dmwit> In this definition, "foo undefined" would indeed result in bottom.
03:06:23 <dmwit> Is there a collection of seq red-flags somewhere to point noobs at?
03:06:33 <mcstar> > let foo f = f `seq` \x -> Identity (f x) in (foo undefined)`seq`8
03:06:34 <lambdabot>   *Exception: Prelude.undefined
03:06:37 <mcstar> shachaf: ^^
03:06:58 <shachaf> mcstar: Yep, I ended up with that.
03:07:01 <dmwit> Like, "x `seq` x" is wrong, "x `seq` thing where x does not occur" is almost certainly wrong, "anything that is not a variable `seq` anything" is almost certainly wrong, etc.
03:08:05 <startling> how are you supposed to use seq? x `seq` (x + 10) or whatever?
03:08:14 <dmwit> Actually, looking at that list, I'm starting to think ($!) should really be the default thing instead of seq.
03:08:15 <mcstar> thats good
03:08:31 <dmwit> startling: Yeah, "variable `seq` some expression that uses variable".
03:08:32 <mcstar> startling: + is already strict though
03:08:44 <mcstar> in both arguments
03:08:57 <startling> mcstar, true; was just an example, though
03:10:26 <mcstar> dmwit: how does $! compose? you can do x`seq`y`seq`f x y
03:10:48 <mcstar> does f $! x $! y work?
03:11:09 <dmwit> I'm not sure. You might need parentheses. But yes, that idea works fine.
03:11:21 <dmwit> ?src ($!)
03:11:21 <lambdabot> f $! x = x `seq` f x
03:11:30 <dmwit> (f $! x) $! y = y `seq` x `seq` f x y
03:11:37 <mcstar> ?info ($!)
03:11:38 <lambdabot> ($!)
03:11:46 <mcstar> lambdabot: give me fixity!
03:11:50 <dmwit>  ?info autocorrects to ?undo
03:12:01 <dmwit> infixr 0
03:12:13 <dmwit> which is dumb
03:12:17 <dmwit> but consistent with ($)
03:12:22 <mcstar> yeah
03:15:25 <mcstar> im wondering why i didnt notice before that $ was infixr
03:16:00 <mcstar> ah well, thats natural
03:16:03 <mcstar> thats why
03:16:15 <mcstar> but here x is not another function
03:16:24 <mcstar> thats why we need the parens
03:16:39 <mcstar> dmwit: why is it dumb then?
03:16:52 <mcstar> it makes sense, since it is not function compisition
03:17:23 <dmwit> Everything that can be done with infixr ($) can be done with (.) and infixl ($); however, there are useful constructs that are possible with infixl ($) but not infixr ($).
03:17:39 <Nereid> dmwit:  that's what I've been saying!
03:17:56 <dmwit> Nereid: It's been known and said by many people for a long time.
03:18:01 <Nereid> :v
03:18:01 <mcstar> but you dont have to parenthesize when you use $ 'correctly'
03:18:08 <mcstar> f $ g $ h x
03:18:20 <dmwit> mcstar: Try removing the parentheses from f (g x) (h y)
03:18:32 <mcstar> i dont want to
03:18:34 <mcstar> thats bs
03:18:41 <Nereid> lol
03:19:00 <Nereid> dmwit: try removing the parentheses from f (g (h x) (k y))
03:19:01 <Nereid> :(
03:19:03 <shachaf> dmwit: You can't do "stick length $ in front of your big expression in ghci" with infixl $
03:19:05 <mcstar> ah, no offense intended, im just saying it wouldnt work
03:19:13 <dmwit> f $ g $ h x can just as well (perhaps, even, better) be written f . g $ h x
03:19:27 <mcstar> (f . g . h) x is better
03:19:42 <dmwit> Not if the goal is eliminating parentheses. =)
03:19:59 <mcstar> i consider . and $ in the same expression ugly
03:20:18 <Nereid> I consider having two $ ugly
03:20:21 <Nereid> :c
03:20:30 <dmwit> And you're free to. However, I don't agree.
03:20:54 <t7> which is the pythonic way... :P
03:21:04 <shachaf> Nereid: If you consider having two $ ugly, you shouldn't care which way $ is infix. :-)
03:21:15 <Iceland_jack> “Not if the goal is eliminating parentheses.” is that the goal now?
03:21:19 <Nereid> shachaf: I'd be fine with it if the alternative was a bunch of parentheses
03:21:21 <mcstar> though, you cant eliminate the parens from around (f . g . h) x since function application binds stringest
03:21:32 <Nereid> f . g . h $ x
03:21:43 <dmwit> Iceland_jack: That was mcstar's stated goal. "but you dont have to parenthesize when you use $ 'correctly'"
03:22:15 <Nereid> I stayed up too late working on homework.
03:22:16 <mcstar> dmwit: that was re: (f $! x) $! y , since that is not its intended use
03:22:23 <Nereid> this algebraic geometry stuff is tedious. :(
03:22:33 <mcstar> f $ g $ h x is
03:23:02 <dmwit> I am not confident I know the right fixity for ($!).
03:23:16 <Nereid> when in doubt, use parentheses
03:23:28 <mcstar> when in doubt, undoubt yourself
03:23:35 <mcstar> and fast, before you drown
03:23:38 <dmwit> I mean, I know the current fixity. Just not what the fixity *ought* to be. =)
03:23:47 <Nereid> yeah.
03:24:01 <dmwit> Perhaps it ought to be infix. =)
03:24:15 <mcstar> i got it
03:24:21 <Nereid> dmwit: heh.
03:24:26 <mcstar> [f g h] x could stand for composition
03:24:30 <Nereid> gross
03:24:34 <mcstar> XD
03:24:44 <dmwit> [f g h] already stands for [f g h]
03:24:51 <Nereid> foldr (.) id [f g h] x
03:24:57 <startling> {f g h} x
03:24:58 <mcstar> i know.. you can replace []with something else
03:25:05 <mcstar> thats records
03:25:09 <shachaf> I,I %c{f g h}
03:25:11 <Nereid> why not just let c = foldr (.) id in c[f g h] x
03:25:25 <startling> mcstar, only in specific places and separated by :: or =
03:25:26 <mcstar> `f g h` x
03:25:32 <Nereid> eww
03:25:34 <dmwit> Nereid: Because c's type is too restrictive.
03:25:54 <Nereid> not in caleskell
03:25:55 <shachaf> Clearly HList is the solution.
03:26:01 <dmwit> Even in Caleskell.
03:26:01 <shachaf> Nereid: Yes in Caleskell.
03:26:07 <Nereid> or are we talking about the list bit
03:26:18 <shachaf> We're taking about the type of foldr (.) id
03:26:21 <shachaf> @ty foldr (.) id
03:26:23 <lambdabot> forall b. [b -> b] -> b -> b
03:26:41 <Nereid> I guess I meant use the (.) and id from Category.
03:26:44 <mcstar> well, you might want 2 types there
03:26:49 <Nereid> and then replace [] with any foldable.
03:26:54 <dmwit> Nereid: That doesn't help.
03:26:56 <mcstar> [a -> b] -> a -> b
03:26:57 <Nereid> so what's wrong
03:26:59 <dmwit> It's *still* too restrictive.
03:27:15 <mcstar> ah right
03:27:25 <mcstar> the inner types are erased
03:27:25 <Nereid> oh right.
03:27:26 <Nereid> duh.
03:27:31 * Nereid moron
03:27:47 <mcstar> lists are homogeneous
03:27:52 <mcstar> stupid lists
03:28:35 <Nereid> whatever, TH will do it.
03:28:52 <mcstar> does olge use TH?
03:28:55 <mcstar> oleg
03:29:02 <elliott> edwardk: when you say "uniplate is a useful default definition for plate" and link to a nonexistent Control.Plated module, what is that? some WIP stuff?
03:29:05 <mcstar> i dont think so
03:29:16 <edwardk> Control.Lens.Plated
03:29:22 <edwardk> I must have a bad hyperlink in there
03:29:38 <edwardk> feel free to push a patch or send me where it is and i'll try to remember to fix it
03:29:51 <Nereid> or some sort of non-homogeneous list type. with a constraint on the types of adjacent elements
03:29:58 <elliott> edwardk: ah, thanks
03:30:00 <edwardk> er and uniplate is actually in Data.Data.Lens
03:30:00 <Nereid> something weird like
03:30:01 <mcstar> tuples?
03:30:22 <mcstar> compose (f,g,h) x
03:30:55 <mcstar> and write a compose for all tuples, but it wont work
03:31:09 <mcstar> so, you will look at typeclasses
03:31:15 <Nereid> data NHList :: (* -> * -> *) -> * -> * -> * where Nil :: NHList k a a; Cons :: k b c -> NHList k a b -> NHList k a c
03:32:03 <mcstar> class Composable where compose :: idk -> a -> b
03:32:08 <Nereid> and then foldr :: NHList k a b -> k a b
03:32:15 <Nereid> and we take k = (->)
03:32:24 <elliott> edwardk: yes it is
03:32:29 <neworder>     addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
03:32:30 <neworder>     addVectors a b = (fst a + fst b, snd a + snd b)
03:32:45 <neworder> what does fst and snd mean
03:32:58 <elliott> :t fst
03:33:00 <lambdabot> forall a b. (a, b) -> a
03:33:02 <elliott> :t snd
03:33:03 <lambdabot> forall a b. (a, b) -> b
03:33:08 <Iceland_jack> neworder: first and second value of a tuple
03:33:17 <mcstar> of a 2-tuple
03:33:29 <elliott> neworder: you might want to read a haskell tutorial like http://learnyouahaskell.com/ if you haven't -- covers the basics like that nicely
03:33:29 <neworder> Ah I see
03:33:30 <edwardk> clearly we need to replace fst with fst = view _1 =)
03:33:47 <neworder> Yup, reading that =)
03:33:59 <neworder> Think I missed that somehow
03:34:15 <Iceland_jack> If they don't know what fst/snd are I don't think whether 2-tuple adds more information than just saying tuple
03:34:26 <elliott> edwardk: what we need is unlifted tuples so we can make (,) an associative type-level operator instead :P
03:34:42 <edwardk> =P
03:35:25 * hackagebot hlint 1.8.32 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.32 (NeilMitchell)
03:36:08 <Nereid> yeah, and then we can write foldNH :: Category k => NHList k a b -> k a b
03:37:59 <Nereid> but this doesn't generalize []
03:38:22 <Nereid> or does iot
03:39:10 <neworder> addVectors (x1 , y1) (x2 , y2) = (x1 + x2 , y1 + y2)
03:39:28 <neworder> I mean this addVectors a b = (fst a + fst b, snd a + snd b)
03:39:37 <neworder> I called it using addVectors 4 5
03:39:42 <neworder> ohh
03:39:45 <Nereid> well duh :V
03:39:54 <neworder> just realized a and b are tuples
03:40:04 <mcstar> 2-tuples
03:40:14 <neworder> hmm, yeah
03:40:15 <mcstar> (lets see the reaction of Iceland_jack)
03:40:36 <Iceland_jack> mcstar: let's
03:40:40 <mcstar> XD
03:43:29 <neworder> I realized addVectors a b = (fst a + fst b, snd a + snd b)   can be called without type declaration
03:43:43 <neworder> how does the compiler know that a and b are 2 tuples?
03:43:54 <mcstar> :t fst
03:43:55 <lambdabot> forall a b. (a, b) -> a
03:44:00 <mcstar> (a, b)
03:44:12 <neworder> hmm
03:44:13 <mcstar> thats not the same 'a' and 'b' though
03:44:31 <mcstar> those are type variables, while in your original text they stand for 2 2-tuples
03:44:53 <neworder> alright
03:44:58 <neworder> get it
03:45:36 <hpaste> Nereid pasted “How to write a Show instance?” at http://hpaste.org/76648
03:45:44 <mcstar> is it possible to write vararg functions with typeclasses?
03:45:47 <Nereid> if possible.
03:46:17 <Nereid> I tried something silly like deriving instance (forall c d. Show (k c d)) => Show (NHList k a b)
03:46:20 <mcstar> i dont want Nereid reification, if thats the proper terminology
03:46:21 <Nereid> but that's silly and doesn't work
03:46:57 <Nereid> > f a b c d e
03:46:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
03:46:58 <lambdabot>    `GHC.Show.Show a'
03:46:58 <lambdabot>      a...
03:47:01 <Nereid> > f a b c d e  :: Expr
03:47:02 <lambdabot>   f a b c d e
03:47:05 <Nereid> "yes you can"
03:48:42 <mcstar> Nereid: was i correct to call reification what you are doing now?
03:48:50 <Nereid> no?
03:49:00 <mcstar> f
03:49:22 <mcstar> but you are trying to encode the composition of functions into data
03:49:28 <Nereid> no
03:49:32 <Nereid> well
03:49:43 <mcstar> id like a vararg compose function
03:49:43 <Nereid> I'm not putting any values into the type level.
03:49:59 <Nereid> yes, look
03:50:26 * hackagebot biofastq 0.1 - A library for reading FASTQ files  http://hackage.haskell.org/package/biofastq-0.1 (KetilMalde)
03:52:15 <mcstar> looking
03:52:37 <hpaste> Nereid pasted “nonhomogeneous lists” at http://hpaste.org/76649
03:53:04 <mcstar> oh man
03:53:08 <Nereid> I dunno if this gets anywhere
03:53:15 <mcstar> ive got so little haskell knowledge
03:53:18 <Nereid> but
03:53:23 <Nereid> if I have some functions
03:53:27 <Nereid> f :: a -> b, g :: b -> c
03:53:39 <Nereid> then foldNH (g :> f :> Nil) = g . f
03:54:03 <Nereid> you can ignore the Refl business for this
03:54:12 <Nereid> that's just because I wanted to put ordinary lists into NHList.
03:54:23 <Nereid> er
03:54:31 <Nereid> hmm
03:54:38 <Nereid> that foldNH is silly, why doesn't it take arguments
04:00:23 <maukd> mcstar: for the record, you didn't hurt my feelings :-)
04:01:05 <mcstar> k, wasnt my intention, it was a silly joke
04:02:41 <neworder> > :type show
04:02:43 <lambdabot>   <no location info>: parse error on input `:'
04:02:55 <neworder> > :t show
04:02:57 <lambdabot>   <no location info>: parse error on input `:'
04:03:03 <neworder> or sorry for spamming
04:03:08 <neworder> oh*
04:03:43 <hpaste> Nereid annotated “nonhomogeneous lists” with “nonhomogeneous lists (annotation)” at http://hpaste.org/76649#a76650
04:03:45 <Nereid> much better
04:03:55 <mcstar> :t show -- neworder
04:03:57 <lambdabot> forall a. (Show a) => a -> String
04:04:48 <neworder> thanks
04:09:03 <arcatan> @type (.)
04:09:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:10:08 <merijn> We need clippy for Caleskell
04:10:37 <merijn> "Looks you are trying to see the type signature for a Prelude function: Did you mean (Prelude..)?"
04:13:53 <arcatan> i actually wanted to see the signature for the Caleskell version :P
04:14:01 <Nereid> I want to be able to say fold Nil (:>) = id but hmm
04:16:00 <mcstar> i need a typelevel flip
04:16:36 <Nereid> weren't you saying that yesterday, or was that someone else?
04:16:45 <mcstar> not me
04:16:48 <Nereid> heh
04:16:57 <mcstar> or should i say, i dont remember it
04:17:59 <startling> mcstar: oh shit, you must have discovered the type-level flip
04:18:03 <startling> don't risk it again
04:18:15 <Nereid> haha cool, slight generalization of the type did it
04:18:23 <Nereid> foldNH :: (forall a. l a a) -> (forall a b c. k b c -> l a b -> l a c) -> NHList k a b -> l a b
04:18:31 <Nereid> then foldNH Nil (:>) works as expected
04:20:13 <Nereid> hey
04:20:18 <Nereid> could I call this a listoid?
04:20:18 <Nereid> :D
04:21:19 <fmap> what's super annoying is that you can't change fixity of imported things; i want my lens oneliner without parens :[
04:21:36 <edwardk> fmap: which oneliner?
04:21:54 <fmap> edwardk: well, it mixes ^.. and ^!
04:22:00 <ivanm> fmap: import qualified and re-define?
04:22:13 <edwardk> ah yes, those bind pretty tightly
04:22:25 <Nereid> who likes my name
04:23:10 <Nereid> I mean the listoid name :s
04:23:47 <mcstar> why is this an error? type a <- b = b -> a
04:23:55 <Nereid> <- isn't a valid type operator
04:24:06 <mcstar> im king it
04:24:10 <Nereid> it's special syntax
04:24:10 <mcstar> im making it
04:24:17 <Nereid> it's already taken for do
04:24:20 <mcstar> ah f
04:24:37 <mcstar> but it is in the typeleve
04:24:42 <Nereid> you're no worse off doing type Flip f a b = f b a
04:24:43 <mcstar> wouldnt interfere with do
04:24:49 <Nereid> unfortunately there's not much you can do with it
04:26:24 <Nereid> you could type a :<- b = a -> b
04:26:33 <sheriff_> [6~[6~[6~[6~
04:26:38 <Nereid> or even type a -< b = b -> a
04:26:44 <mcstar> i did type Flip a b = b -> a
04:26:45 <Nereid> (I got the first one backwards oops)
04:27:03 <Nereid> you can put just about any symbols for a type operator, just not <- and a couple others
04:27:13 <Nereid> -< wouldn't work if you have -XArrows though
04:27:26 <mcstar> i dont fortunately
04:27:32 <mcstar> i build my ghc without arrows
04:27:33 <Nereid> or a <-- b
04:30:11 <sheriff_> Is this channel logged anywhere?
04:30:25 <Nereid> it's logged on my computer :o
04:30:32 <Nereid> (which isn't public)
04:30:53 <mcstar> tunes.org
04:30:59 <Nereid> http://tunes.org/~nef/logs/haskell/
04:31:12 <Nereid> according to http://www.haskell.org/haskellwiki/IRC_channel
04:31:14 <maukd> /topic
04:31:23 <sheriff_> thanks
04:31:39 <Nereid> oh it's in the topic too
04:33:02 <sheriff_> Someone's been asking people here to do their homework for acourse I'm on
04:33:18 <sheriff_> However, having read the transcript, I am not convinced they've had much success :-P
04:33:23 <Nereid> lol
04:33:35 <maukd> oh, was that the guy I was talking to?
04:33:45 <sheriff_> The guy talking about Constraint and Bool
04:33:51 <maukd> yeah
04:33:59 <sheriff_> Deadline was today at 12
04:34:04 <mcstar> sam734
04:34:10 <sheriff_> And John370 before that
04:34:17 <mcstar> lol
04:34:27 <sheriff_> Anyway, having read the chat log, I think he's screwed anyway
04:34:43 <maukd> <John370> Hi, sorry to disturb you, I really need some help, can I ask you here?
04:34:48 <maukd> he msg'd me
04:34:58 <startling> he msg'd me too
04:35:06 <shachaf> Didn't /msg me. :-(
04:35:15 <mcstar> me neither
04:35:16 <shachaf> Am I not good enough for you, John370?!
04:35:24 <mcstar> i should use my bank account number as my nick
04:35:26 <sheriff_> He didn't respond to my messages asking how his homework was going
04:35:34 * shachaf -- not worth spamming.
04:35:41 <arcatan> you should put that one CV
04:35:44 <Nereid> can anyone think of a good name for data C :: * -> * -> * where C :: a -> C a a ?
04:35:56 <elliott> C
04:35:59 * startling -fno-spam
04:35:59 <Nereid> lol
04:36:05 <Nereid> edwardk: ?
04:36:07 <Nereid> :)
04:38:11 <mcstar> i need to change this type into prefix form, with parameters 'a' and 'c'
04:38:15 <mcstar> (b -> c) -> (a -> b)
04:38:34 <mcstar> oh, well, i think a 'type' can help
04:38:40 <Nereid> type A b a c = (b -> c) -> (a -> b) ?
04:39:30 <mcstar> sort of
04:39:36 <mcstar> i cant hide the 'b' can i?
04:39:51 <mcstar> maybe with an explicite forall?
04:39:54 <Nereid> not if you don't want an existential type
04:40:37 <elliott> That won't be existential.
04:40:48 <elliott> mcstar: You can do type A a c = forall b. (b -> c) -> (a -> b).
04:40:59 <Nereid> er
04:41:03 <mcstar> ill try
04:41:39 <Nereid> are there even any values with that type?
04:42:00 <elliott> I don't think so.
04:42:03 <Nereid> me either.
04:42:25 <elliott> (FWIW: Existential is Constructor :: forall a. ... a ... -> Type (not mentioning a); universal is Constructor :: (forall a. ...) -> Type (not mentioning a); here we have the latter)
04:42:37 <Nereid> yeah.
04:42:56 <shachaf> forall r. (forall b. (b -> c) -> (a -> b) -> r) -> r -- that b is totally existential!
04:43:20 <Nereid> shachaf: I don't think that's right.
04:43:38 <Nereid> is it still so if you put in the parentheses?
04:43:49 <shachaf> Nereid: Well, it's isomorphic to forall r. ((exists b. (b -> c) -> (a -> b)) -> r) -> r
04:43:59 <Nereid> not without some more parentheses.
04:44:23 <shachaf> Oh, um, yes.
04:44:32 <shachaf> forall r. (forall b. ((b -> c) -> (a -> b)) -> r) -> r
04:44:47 <shachaf> #haskell is so great. I don't even need a type checker to tell me that I'm wrong!
04:47:21 <raymank26> Hi all. There is some example of using StateT with List and IO monad?
04:48:06 <mcstar> weird, i can make (->) an instance of a typeclass, but cant make type C1 a b = a -> b, C1, in its place
04:48:34 <Nereid> yes, you'd need TypeSynonymInstances for that
04:48:40 <mcstar> Nereid: even with that
04:48:55 <Nereid> hopefully you're not overlapping them
04:48:58 <mcstar>  Type synonym `C1' should have 2 arguments, but has been given none
04:49:11 <mcstar> (->) should have 2 arguments too
04:49:15 <maukd> mcstar: type C1 = (->)
04:49:22 <maukd> mcstar: (->) is not a type synonym
04:49:33 <mcstar> no it isnt
04:49:44 <mcstar> but why cant i fully parameterize C1?
04:49:58 <mcstar> i have to do that later on
04:50:09 <maukd> because of how type synonyms work
04:50:24 <maukd> type [MATCH THIS] = [AND REPLACE IT BY THIS]
04:50:28 * hackagebot lifted-async 0.0.0.1 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.0.0.1 (MitsutoshiAoe)
04:50:34 <maukd> if you do type Foo x, then Foo alone is invalid
04:50:37 <maukd> the pattern is Foo x
04:50:38 <mcstar> maukd: but ghc accepts my
04:50:43 <mcstar> 'type' declaration
04:50:50 <mcstar> (accidental newline)
04:51:15 <mcstar> type C1 a b = a -> b is totally ok
04:51:32 <mcstar> i just cant use it later on in an instance declaration
04:51:57 <maukd> yes, that's what I said
04:52:19 <mcstar> ok
04:52:45 <mcstar> so, it is closer to a textual substitution?
04:53:36 <maukd> yes
04:58:17 <mcstar> can forall appear in an instance declaration?
04:59:01 <mcstar> let me paste what i want in pseudo haskell
05:00:39 <hpaste> mcstar pasted “composeable” at http://hpaste.org/76651
05:01:28 <mcstar> now i know, i cant use 'type' that way, but is there a way to arrive at what i want?
05:02:32 <maukd> I don't understand what you want
05:03:34 <mcstar> well, you werent listening when we talked about this with Nereid , so it isnt directed specifically at you
05:03:56 <martingw> Hi anyone, in Bird' Functional Pearls, chapter 2, he says that tails (xs++ys)=map (++ys) (tails xs) ++tails ys.
05:04:09 <martingw> Is that true?
05:04:16 <mcstar> but the thing is, i want a vararg compose function, that takes other functions, and an argument, and composes them and applies them to the last argument maukd
05:04:17 <Nereid> mcstar: line 8 is definitely not what you want
05:05:07 <mcstar> i just thought, it would be possible to use typeclasses here, so that i make an instance for every comp function with different number of function arguments
05:05:19 <mcstar> but it seems i cant solve it, or it isnt possible
05:05:27 <maukd> mcstar: what would you use that for?
05:05:39 <mcstar> just exercising my haskell muscles
05:06:00 <maukd> > tails "abc"
05:06:01 <lambdabot>   ["abc","bc","c",""]
05:06:08 <mcstar> we were talking about function composition and operator precedence and stuff, and i thought...
05:06:42 <maukd> @check \xs ys -> xs ++ ys == map (++ ys) (tails xs) ++ tails (ys :: String)
05:06:43 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
05:07:09 <mcstar> tails
05:07:33 <neworder> Is there a way to see the implementation of a function in ghci?
05:07:49 <mcstar> neworder: you can look at them on haskell.org
05:07:56 <maukd> @check \xs ys -> tails (xs ++ ys) == map (++ ys) (tails xs) ++ tails (ys :: String)
05:07:58 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\345860\"\n\"\"\n"
05:07:59 <neworder> alright
05:08:05 <mcstar> http://www.haskell.org/ghc/docs/7.4-latest/html/libraries/index.html
05:08:07 <maukd> martingw: no
05:09:13 <Nereid> ha, I generalized that fold type further.
05:09:26 <mcstar> it might just differ in the order of the elements
05:09:44 <mcstar> @check \xs ys -> sort $ tails (xs ++ ys) == sort $ map (++ ys) (tails xs) ++ tails (ys :: String)
05:09:45 <lambdabot>   Couldn't match expected type `[[a]]'
05:10:15 <mcstar> @check \xs ys -> sort (tails (xs ++ ys)) == sort (map (++ ys) (tails xs) ++ tails (ys :: String))
05:10:15 <martingw> But it's Bird! Functional Pearls! How can it be wrong :-( ...
05:10:18 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\466557\"\n\"\"\n"
05:10:33 <maukd> martingw: the difference is minor
05:10:42 <maukd> there's a duplicated element in the middle
05:12:52 <martingw> Yeah, saw that with xs=[1], ys=[2]...
05:12:54 <mcstar> @check \xs ys -> nub (tails (xs ++ ys)) == nub (map (++ ys) (tails xs) ++ tails (ys :: String))
05:12:57 <lambdabot>   "OK, passed 500 tests."
05:15:10 <mcstar> Nereid: can you tell me at least, if what i want is possible, or am i just wasting my time with it?
05:15:29 <Nereid> I'm not sure exactly what you're looking for but
05:15:44 <Nereid> I think it's possible, but it's going to take some amount of trickery
05:15:57 <ivanm> martingw: note also that Bird likes to re-define operators....
05:16:02 <mcstar> as i said, a compose function, that takes an arbitrary number of functions and composes them
05:16:03 <ivanm> s/operators/functions/
05:16:08 <ivanm> so check his definition of tails
05:16:15 <mcstar> basically thats it, and i want it done through type classes
05:16:43 <Nereid> My brain just exploded
05:16:43 <Nereid>     I can't handle pattern bindings for existential or GADT data constructors.
05:16:45 <Nereid> aww.
05:17:06 <Nereid> mcstar: try doing it for tuples
05:17:16 <Nereid> anyway my listoid can already do that
05:25:17 <Nereid> I want overloaded list notation.
05:25:46 <Nereid> such that I can make a Listoid using list notation.
05:26:20 <startling> it'd be cool if you could run arbitrary compile-time checks on data from OverloadedStrings
05:26:28 <startling> same with your OverloadedLists
05:26:37 <Nereid> hmm, yeah
05:26:41 <startling> e.g. for a non-empty list
05:27:58 <Lemmih> startling: You might be able to do that with a plugin.
05:30:29 * hackagebot friendly-time 0.2.2 - Print time information in friendly ways  http://hackage.haskell.org/package/friendly-time-0.2.2 (PatrickBrisbin)
05:33:19 <neworder> I'm having problems understanding this function which computes primenumbers
05:33:21 <neworder> primes = sieve [2..] where sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0]
05:33:31 <neworder> > primes = sieve [2..] where sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0]
05:33:32 <lambdabot>   <no location info>: parse error on input `='
05:34:09 <shachaf> > nubBy(((>1).).gcd)[2..]
05:34:11 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:34:21 <osfameron> how do I install cabal from debuntu?
05:34:34 <osfameron> I've already apt-got ghc
05:34:41 <mcstar> neworder: at one point you have to start thinking for yourself though...
05:34:42 <shachaf> Is that the "C/C++" of Debian and Ubuntu? :-(
05:35:01 <b_jonas> shachaf: nice one
05:35:07 <osfameron> well, specifically ubuntu ;-)
05:35:08 <neworder> true mcstar
05:35:24 <shachaf> osfameron: apt-get install cabal-install?
05:35:29 * hackagebot distributed-process 0.4.0.2 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.4.0.2 (EdskoDeVries)
05:35:44 <osfameron> shachaf: thanks
05:35:45 <neworder> p becomes 2
05:36:00 <neworder> and xs is rest of the list of numbers till infinity
05:37:01 <neworder> I don't understand this part [x | x<-xs, x `mod` p /= 0]
05:37:52 <maukd> @undo [x | x<-xs, x `mod` p /= 0]
05:37:52 <lambdabot> concatMap (\ x -> if x `mod` p /= 0 then [x] else []) xs
05:37:54 <neworder> for every element in xs which is not divisible by 2
05:37:57 <maukd> HOPE THAT CLEARS THINGS UP
05:38:18 <shachaf> neworder: Weren't you reading an introduction to Haskell before? You should go back to it and read it until it makes sense. :-)
05:38:19 <nand`> nice, I didn't know @undo does list comprehensions
05:38:28 <shachaf> It might help to write little snippets in ghci.
05:38:36 <shachaf> That's how we all* did it, you know.
05:38:51 <neworder> hmm alright, will try it =)
05:38:55 <nand`> though I'd prefer it used the generalized MonadPlus functions
05:38:58 <nand`> eg. guard
05:39:15 <mcstar> id write it as filter ((/=0).(`mod`p)) xs
05:39:46 <shachaf> Fortunately you don't normally read code written by mcstar. :-)
05:40:05 <mcstar> shachaf: i mean, in response to @undo
05:40:27 <shachaf>  @undo is not meant to be smart.
05:40:28 <nand`> I'd write it as filter (\x -> x `mod` p /= 0); probably
05:40:29 * hackagebot distributed-process-simplelocalnet 0.2.0.7 - Simple zero-configuration backend for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.0.7 (EdskoDeVries)
05:40:48 <mcstar> [x | x<-xs, x `mod` p /= 0] this is not bad at all
05:40:56 <shachaf> There's a very simple definition of the notation, and it expands it.
05:41:31 <mcstar> shachaf: anyway, "Fortunately you don't normally read code written by mcstar" can change, if i become a well respected haskell hacker
05:41:54 <shachaf> mcstar: Not as long as you write ((/=0).(`mod`p)), it won't! :-)
05:42:15 <startling> there's worse out there
05:42:19 <maukd> yeah, it should be ((0 /=) . (`mod` p))
05:42:20 * shachaf just likes to make fun of gratuitously point-free code.
05:42:24 <maukd> much more readable
05:43:04 <startling> ((/=) 0 . flip mod p)
05:43:17 <maukd> needs more fmap
05:43:39 <int-e> shachaf: yeah. point-free code often has an abundance of dots. :)
05:44:30 <maukd> :t fmap ((/=) 0) (fmap (fmap (ask p)) mod)
05:44:31 <lambdabot> Top level:
05:44:31 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
05:44:32 <lambdabot>     When using functional dependencies to combine
05:44:38 <startling> heh
05:44:40 <maukd> :t \p -> fmap ((/=) 0) (fmap (fmap (ask p)) mod)
05:44:41 <lambdabot> forall t a b. (Num b, MonadReader (a -> b) ((->) t), Integral a) => t -> a -> Bool
05:44:54 <int-e> :t ((1 <) . gcd ?p)
05:44:55 <lambdabot> forall t. (Integral t, ?p::t) => t -> Bool
05:45:06 <Ferdirand> @undo [x | x <- xs, c1 x, c2 x, c3 x]
05:45:06 <lambdabot> concatMap (\ x -> if c1 x then if c2 x then if c3 x then [x] else [] else [] else []) xs
05:45:13 <Ferdirand> that is somewhat disappointing
05:45:36 <shachaf> @ty \p -> fmap (fmap (fmap fmap fmap fmap) (fmap fmap fmap fmap)) fmap fmap (/=) 0 flip mod p
05:45:37 <lambdabot> forall a. (Integral a) => a -> a -> Bool
05:46:09 <maukd> :t fmap (fmap (fmap fmap fmap fmap) (fmap fmap fmap fmap)) fmap fmap (/=) 0 flip mod
05:46:10 <lambdabot> forall a. (Integral a) => a -> a -> Bool
05:46:15 <maukd> do you even lambda lift?
05:46:18 <int-e> > nubBy(((1<).).gcd)[2..]
05:46:20 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
05:46:35 <shachaf> maukd: Hey, I was transforming the original expression.
05:46:39 <shachaf> The original expression had a p in it.
05:46:55 <int-e> @type (.:)
05:46:56 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
05:49:14 <shachaf> @ty \p -> fmap fmap (fmap (fmap (fmap fmap fmap fmap) fmap fmap fmap fmap) (fmap fmap fmap)) fmap fmap fmap (/=) 0 flip mod p
05:49:16 <lambdabot> forall a. (Integral a) => a -> a -> Bool
05:49:17 * shachaf sighs.
05:50:16 <int-e> :)
05:53:11 <hpaste> Nereid pasted “Listoid” at http://hpaste.org/76654
05:53:13 <Nereid> ^
05:53:31 <Nereid> I don't know what I did this all for but whatever.
05:53:39 <Nereid> oh yeah, someone wanted to compose lists of functions.
05:53:40 <int-e> shachaf: you can always use the fact that (.)(.)(.)(.)(.)(.) == (.)(.)(.)(.)(.)(.)(.)(.)(.)(.) :)
05:53:50 <Nereid> int-e: haha.
05:53:59 <Nereid> I proved that myself the other day.
05:54:02 <Nereid> it was silly
05:54:28 <hpaste> mcstar pasted “comp -- nereid” at http://hpaste.org/76655
05:54:37 <Nereid> oh dear I mistyped prerequisites
05:54:50 <Nereid> mcstar: disgusting
05:54:52 <Nereid> :p
05:54:54 <int-e> shachaf: (where f . g =
05:55:03 <int-e> \x -> f (g x), not (.) = fmap)
05:55:08 <Nereid> also why is comp not flipped?
05:55:18 <Nereid> or, why is it flipped from how it should be?
05:55:31 <Nereid> anyway, with my thing you'd be able to write
05:55:36 <Jafet> :t (.)(.)(.)(.)(.)(.) `asTypeOf` (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
05:55:37 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) a1 b. (Functor f1, Functor f) => (a -> a1 -> b) -> f1 a -> f1 (f a1 -> f b)
05:55:42 <Nereid> compose (f :> g :> h :> Nil) a = f (g (h a))
05:55:42 <shachaf> int-e: It works with fmap, too.
05:56:02 <shachaf> int-e: I wasn't trying to use as many fmaps as possible.
05:56:20 <mcstar> Nereid: yeah, thats better, dont need multiple constructors, like Ci
05:56:31 <mcstar> but thats far from what i wanted originally :(
05:56:37 <shachaf> int-e: I was trying to get rid of parentheses.
05:56:40 <Nereid> it would be great if we had overloaded lists
05:56:47 <shachaf> I have the feeling a function other than fmap is necessary.
05:56:52 <Nereid> so I could write compose [f,g,h] a
05:57:21 <shachaf> Nereid: ...Or you could just write (f.g.h) a
05:57:25 <Nereid> sure...
05:57:25 <Nereid> :D
05:57:39 <typoclass> Nereid: foldr (.) ?
05:57:49 <shachaf> typoclass: No, f/g/h have different types
05:57:51 <int-e> shachaf: oh, right, it does. I just didn't have the functor instance of (->) a in scope so the type signature looked different.
05:57:53 <Nereid> typoclass: that only works if all the functions have the same type a -> a
05:58:02 <typoclass> oh i see
05:58:06 <b_jonas> int-e: wait, the : is not part of the expression? so that's why I couldn't parse it
05:58:07 <Jafet> Clearly foldr has the wrong type.
05:58:19 <Nereid> so see my paste :)
05:58:30 <int-e> b_jonas: ... right :)
05:58:33 <Nereid> maybe I'll put this together as a library.
05:58:39 <Nereid> and throw it onto hackage.
05:58:41 <Nereid> my very first :O
05:59:12 <int-e> b_jonas: it didn't occur to me that a smiley would be confusing there. it's in a different syntactical class, but a lexer will have trouble disambiguating. :)
05:59:31 <shachaf> I kind of feel like I should have a Hackage account.
05:59:41 <Jafet> Are you accountable?
05:59:54 <shachaf> No.
05:59:58 <Nereid> also I never realized that :> is a smiley
06:00:01 <Nereid> :>
06:00:16 <Jafet> http://hpaste.org/51474
06:00:18 <Nereid> I mean I never realized there was a smiley all over my code.
06:00:18 <int-e> o_O
06:00:26 <Nereid> haha I remember that.
06:00:33 <neworder> For this function, primes = sieve [2..] where sieve (p:xs) = p : sieve [x | x<-xs, x `mod` p /= 0]
06:00:47 <shachaf> Nereid: 003E   ROTATED LATIN CAPITAL LETTER V [>]
06:00:52 <Nereid> neworder: I believe that's slow
06:01:19 <neworder> After 2 is assigned to p ( Don't know the correct terminology)
06:01:49 <shachaf> neworder: I think it's more than terminology that's at issue here.
06:01:56 <Nereid> sieve [2,3,4,5,...] = 2 : sieve [3,5,7,9,...] = 2 : 3 : sieve [5,7,11,13,...]
06:02:03 <shachaf> neworder: This is tricky business and it takes a while to get used to this way of thinking.
06:02:09 <Nereid> but still, it's very slow. see http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf
06:02:10 <shachaf> I recommend starting with simpler examples.
06:02:20 <neworder> Hmm, it's lazy evaluation
06:02:40 <neworder> I see
06:02:44 <neworder> Sure
06:03:03 <neworder> Would love to read the whole book like you said, but I am lacking time.. Haha
06:03:11 <neworder> Please don't mind
06:03:16 <int-e> shachaf: 0065 + 0070 MIRRORED LOWER CASE LETTER Q?
06:03:21 <Nereid> neworder: that algorithm is basically trial division
06:03:39 <shachaf> int-e: 65?
06:03:39 <neworder> Hmm
06:03:41 <int-e> hmm. I mean 0064, of course.
06:03:41 <neworder> I see
06:03:46 <shachaf> Oh.
06:03:59 <int-e> counting is hard :)
06:04:12 <neworder> I got it now, thanks
06:04:36 <neworder> I just wanted to see how haskell compuotes it, this helped a lot. sieve [2,3,4,5,...] = 2 : sieve [3,5,7,9,...] = 2 : 3 : sieve [5,7,11,13,...]
06:04:48 <neworder> computes*
06:05:11 <neworder> There's no way I can see how Haskell computes this function right?
06:05:22 <Nereid> there... kind of is
06:05:23 <Nereid> one moment
06:05:47 <neworder> I've done Prolog before, and when I enter a semi colon, it just shows more answers... Something like that
06:06:06 <neworder> sure
06:08:03 <Jafet> > let sieve (p:xs) = p : sieve (filter $ (==0).(`mod`p)) xs in sieve [2..]
06:08:04 <lambdabot>   Couldn't match expected type `[a] -> [a]'
06:08:05 <lambdabot>         against inferred type `[a]'
06:08:18 <Jafet> > let sieve (p:xs) = p : sieve (filter ((==0).(`mod`p)) xs) in sieve [2..]
06:08:22 <lambdabot>   mueval-core: Time limit exceeded
06:08:32 <Jafet> > let sieve (p:xs) = p : sieve (filter ((==0).(`mod`p)) xs) in take 10 $ sieve [2..]
06:08:34 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
06:11:18 <Nereid> still working
06:14:13 <Nereid> forget it, just use Debug.Trace
06:14:13 <Nereid> :D
06:14:51 <b_jonas> why, if you only want to see the values of the list, you could always just mapM_ print it
06:14:54 <b_jonas> couldn't you?
06:15:23 <b_jonas> that should print each value without necessarily computing the next
06:15:53 <Nereid> no, he wants to see the steps in the computatoin
06:16:11 <Nereid> and I need sleep
06:16:12 <Nereid> by
06:16:13 <Nereid> e
06:18:15 <Jafet> > exp 1 :: CReal
06:18:16 <lambdabot>   2.7182818284590452353602874713526624977572
06:20:39 <Nereid> but I mean my idea was to make the recursion explicit (sieve = fix sieve'), monadify sieve', and then stick a print action or so in there
06:20:58 <b_jonas> back to list of primes,
06:20:59 <Nereid> but I'm too tired to make it work, so bye :v
06:21:05 <b_jonas> {- am I too imperative if I just say this? -} snd (execRWS (mapM_ (\c -> rws (\_ s -> let { n = if elem 0 (map (mod c) s) then [] else [c] } in (undefined, s ++ n, n))) [2..]) undefined [])
06:21:14 <b_jonas> > snd (execRWS (mapM_ (\c -> rws (\_ s -> let { n = if elem 0 (map (mod c) s) then [] else [c] } in (undefined, s ++ n, n))) [2..]) undefined [])
06:21:16 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
06:22:54 <Nereid> I just realized
06:23:08 <b_jonas> that one looks ugly if you remove all the unnecessary spaces:
06:23:13 <Nereid> Listoid cat is basically a path in cat.
06:23:16 <b_jonas> > snd(execRWS(mapM(\c->rws(\_ s->let n=if elem 0(map(mod c)s)then[]else[c]in(1,s++n,n)))[2..])1[])
06:23:18 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
06:23:38 <mcstar> Nereid: bed, now!
06:23:42 <Nereid> fffffffff
06:23:44 <b_jonas> but anyway, if I write that, does it show I'm too much infected by imperative programming style?
06:23:54 <Nereid> (I do this all the time, you better get used to it)
06:24:10 <Jafet> :t execRWS
06:24:11 <lambdabot> forall r w s a. RWS r w s a -> r -> s -> (s, w)
06:24:18 <Jafet> Isn't that excessive
06:24:42 <merijn> Bags are just sets with duplicates, right?
06:24:46 <b_jonas> Jafet: I only use WS in that snippets obviously
06:25:23 <Jafet> > let sieve (p:xs) = let (as,bs) = span (<p^2) $ p:xs in as ++ sieve (filter (\x -> all ((/=0).mod x) as) bs) in sieve [2..] !! 10000
06:25:28 <lambdabot>   mueval-core: Time limit exceeded
06:26:03 <Jafet> @doit
06:26:04 <lambdabot> Maybe you meant: dict do docs join quit
06:28:07 <b_jonas> Jafet: try with a number smaller than 10000 maybe?
06:28:14 <Jafet> > let sieve (p:xs) = let (as,bs) = span (<p^2) $ p:xs in as ++ sieve (filter (\x -> all ((/=0).mod x) as) bs) in sieve [2..] !! 10000
06:28:17 <lambdabot>   104743
06:31:16 <nyc> There's a paper about the "true sieve of Eratosthenes" floating around.
06:33:17 <Jafet> My sieve uses authentic greek columns
06:34:38 <tsou> Jafet: and i use an authentic greek sieve in my kitchen :P
07:15:57 <preyalone> Anyone familiar with rdf4h/hsparql? I want to specify a language literal in a SPARQL query, but I can't find the syntax for it.
07:18:22 <linduxed> how would i configure ghc-mod like "no, you shouldn't warn me about Top-level binding with no type signature if it's 'main'"
07:19:36 <byorgey> linduxed: you can't.  ghc-mod just gets its warnings straight from GHC, and there's no way to tell GHC not to warn you about certain identifiers only.
07:19:49 <linduxed> byorgey: oh i see
07:19:54 <byorgey> probably the only way would be to hack the ghc-mod source code and insert a special case to check for main
07:20:06 <linduxed> haha, not anything i'd care to do
07:20:12 <byorgey> right, I didn't think so =)
07:20:40 <linduxed> then i'd better make syntastic use hlint instead of ghc-mod :-)
07:20:58 <linduxed> or wait a minute... does hlint check those kind of things?
07:21:09 <linduxed> like type issues and such?
07:21:12 <Jafet> Or
07:21:13 <byorgey> no
07:21:15 <Jafet> main :: IO ()
07:21:17 <linduxed> byorgey: aaaah, thought so
07:21:25 <byorgey> linduxed: hlint checks for style
07:21:39 <byorgey> yeah, what Jafet said =P
07:22:01 <linduxed> yeah i know, but it feels a bit redundant since it will _always_ be IO ()
07:22:16 <linduxed> that's boilerplate at its finest :-)
07:22:28 <linduxed> unless i'm mistaken
07:22:42 <byorgey> it could be   IO (any type here), actually
07:22:43 <Jafet> > let main = 5 in main
07:22:44 <lambdabot>   5
07:22:47 <byorgey> not that it matters =)
07:23:10 <rwbarton> i've seen people accidentally write a main of type IO (IO ()) that did nothing
07:23:31 <rwbarton> so it is a good sanity check to include that signature
07:24:27 <linduxed> oooh, wait a minute
07:24:36 <linduxed> just checked, hlint is indeed used as well
07:24:45 <linduxed> thought it wasn't :-/
07:25:24 <preyalone> <rwbarton> so it is a good sanity check to include that signature
07:25:29 <preyalone> yes, yes, and yes!
07:25:31 * hackagebot CC-delcont-alt 0.1.1.1 - Three new monad transformers for multi-prompt delimited control  http://hackage.haskell.org/package/CC-delcont-alt-0.1.1.1 (KidoTakahiro)
07:25:38 <byorgey> rwbarton: good point!
07:27:45 <preyalone> When you manually specify your type declarations, Haskell is merely background-checking them and letting you know when you're wrong.
07:28:56 <byorgey> and when you don't specify your type declarations, Haskell is inferring some type that you probably didn't mean and letting you know when some remote place elsewhere in your code ends up being wrong.
07:30:39 <Jafet> @check (==) <*> sort
07:30:40 <lambdabot>   "OK, passed 500 tests."
07:33:47 <mcstar> rwbarton: me!
07:33:57 <mcstar> it was a good lesson
07:43:18 <mcstar> ok, so if i run into a type for a function, that repeats ad infinitum, i can escape that with a type alias, right?
07:45:38 <merijn> mcstar: No, but you can newtype it, afaik
07:46:30 <mcstar> ok
07:46:36 <merijn> You mean something like "a -> IO (a, a -> IO (..."?
07:46:49 <mcstar> not IO, but similar
07:47:29 <mcstar> i need a function that takes a function and gives back a function that takes a function and gives back a function that takes a function that gives back a function that takes a function and gives back a func....SO
07:47:31 <merijn> mcstar: Yeah, I just ran into a similar situation once trying to describe a prompt like this: "newtype Prompt a = Prompt (a -> IO (a, Prompt a))"
07:48:25 <merijn> mcstar: type aliases aren't allowed to be recursive, but newtype's are. Of course you'll have to unwrap the newtype explicitly
07:48:31 <mcstar> it will be similar except IO and the tuple is semantically on the left side of the arrow
07:49:08 <merijn> That starts to sound a lot like "app" too
07:49:11 <merijn> :t app
07:49:13 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
07:56:56 <mcstar> it is going to be 'function composition in prefix form without parenthesis'
07:57:15 <mcstar> if 'c' is the composition,
07:57:23 <mcstar> c f c g c h id 4
07:57:26 <mcstar> for example
07:57:53 <mcstar> anyway, i have to stop now, there are more important things to do
08:06:45 <Attic> Hey, anyone using Yi editor?
08:10:35 <tac> Attic: I developed for it a few years back, but I never actually used it :P
08:11:01 <Attic> tac: Oh haha
08:11:35 <Attic> I was just wondering how I could make my own themes, whenever i use a default theme of Yi it changes :: to a weird symbol
08:11:39 <Attic> same for <- and others
08:11:49 <Attic> however if it's a plain text file it doesn't do that
08:12:02 <Entroacceptor> that is to beautify haskell
08:12:10 <Entroacceptor> it changes :: to a :: symbol in one char
08:12:21 <Entroacceptor> if it looks funny your font or locale is broken :)
08:13:08 <Attic> Well, is there a way to uglify haskell? :p
08:13:24 <Attic> i just want it to be plain text, but with syntax colors of course
08:13:28 <int-e> Attic: @pl ;-)
08:13:41 <n-dolio> Damn, int-e beat me to it.
08:13:56 <Attic> @pl?
08:13:56 <lambdabot> (line 1, column 1):
08:13:56 <lambdabot> unexpected end of input
08:13:56 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:14:26 <n-dolio> @pl \x y -> x + y
08:14:27 <lambdabot> (+)
08:14:28 <merijn> @pl \s i m p l e -> e l m s i
08:14:29 <lambdabot> ((const .) .) . flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))
08:15:01 <saep> Attic, i tried to use yi once because i thought it's cool. But when pasting longer chunks of text it reacted very slowly. Also, when a file was open for quite some time the reaction time was noticeable. So I just switched back to emacs, but this time in daemon mode.
08:15:09 <Cale> For the record, I think UnicodeSyntax is ugly
08:15:11 <merijn> Attic: "@pl" tries to produce pointless (i.e. without name bindings) haskell code
08:15:37 <Jafet> @pl \x -> x x
08:15:37 <lambdabot> join id
08:15:38 <Attic> ah
08:15:38 <Cale> Even if only because it screws with layout in a way that's hard to automatically fix.
08:15:53 <merijn> Attic: Oh, wait I only just saw your original question >.>
08:15:56 <int-e> Cale: the right arrows are too short :)
08:16:02 <int-e> (in a fixed width font)
08:16:13 <int-e> (which is the only sane choice due to layout)
08:16:18 <merijn> Attic: Yi must be using UnicodeSyntax and replacing your ascii characters with unicode
08:16:31 <merijn> Attic: I don't think very many people here actively use Yi, tbh
08:16:32 <Attic> merijn: Yeah that's probably it
08:17:00 <Attic> I was just curious, I think I'll check it out a little longer. But I'll probably go back to vim anyway lol
08:17:15 * merijn just uses vim as well
08:17:20 <int-e> Attic: join the dark side, use emacs
08:17:31 <Attic> I actually just left emacs haha
08:17:37 <Attic> vim -> emacs -> back to vim
08:18:29 <Entroacceptor> oh, right, I wanted to check if there's something like evil's s/ support in plain emacs
08:19:41 <int-e> Entroacceptor: what's the requirement? does C-M-% (query-replace-regexp) come close?
08:20:02 <int-e> (yes I do realize it's a 4 key combo, which is what emacs is infamous for)
08:20:12 <Entroacceptor> int-e: not at all. Try it ;)
08:20:42 <int-e> no evil here ...
08:20:52 <Entroacceptor> it does inline syntax checking and progressivly shows which words will be selected and even the replacements
08:20:56 <danr> Entroacceptor: are you referring to the incremental search and replace feature in evil?
08:21:05 <Entroacceptor> danr: yeah
08:21:05 <int-e> Entroacceptor: I see. sounds neat :)
08:21:13 <danr> yeah, it's really handy :)
08:21:41 <beaky> hello
08:21:52 <danr> there's a emacswiki page about it: http://www.emacswiki.org/emacs/IncrementalSearchAndReplace
08:22:19 <beaky> is Data.List.tail O(1)?
08:22:30 <danr> yes
08:22:49 <Jafet> Occasionally it can be O(2).
08:22:49 <n-dolio> Entroacceptor: You mean, it shows the new version of the file as you're entering the regex?
08:22:52 <beaky> im using lists in my code and they're slow :(
08:23:12 <latro`a> lists are slow, especially if you're not using them for control flow but rather as an actual data structure
08:23:17 <mcstar> if  you take tail as many times as the length of a list it will be O(n)
08:23:20 <Entroacceptor> n-dolio: yep
08:23:25 <n-dolio> That's pretty sweet.
08:23:25 <latro`a> for example (++) is O(n) in the left argument
08:23:41 <mcstar> but, it is done lazily
08:23:54 <beaky> http://ideone.com/r8zXv1 Im using lists as part of a data structure.
08:24:19 <beaky> profiling says windL and windR is hogging lots of time :(
08:24:28 <mcstar> dejavu
08:24:34 <mcstar> ive seen that code yesteday
08:24:36 <beaky> ^^
08:24:59 <beaky> I wont rest until it is faster than the C version :D
08:25:20 <mcstar> was that you?
08:25:29 <mcstar> you had a python version also
08:25:29 <beaky> yes
08:25:43 <beaky> yes
08:26:19 <n-dolio> Entroacceptor: Have you gotten surround mode to work with evil, by the way?
08:26:29 <n-dolio> I had to start it up manually every time when I tried it out.
08:26:42 <Entroacceptor> n-dolio: there's evil-surround, a friend just patched that
08:27:08 <Entroacceptor> and that works
08:27:13 <Entroacceptor> but it's OT here, let's go to #emacs
08:27:17 <Entroacceptor> or -blah
08:27:20 <beaky> emacs ftw
08:28:11 <int-e> Entroacceptor: I asked aunt Google. There is an incremental regexp search (C-M-s) (I knew that) and typing M-% during incremental search will allow you to enter a replacement (I was unaware of that).
08:28:35 <Entroacceptor> int-e: but that's not half as neat as evil's
08:30:06 <nicoo> > show (Pi :: CReal)
08:30:07 <lambdabot>   Not in scope: data constructor `Pi'
08:30:10 <beaky> M-x optimize-code
08:30:10 <nicoo> > show (pi :: CReal)
08:30:11 <lambdabot>   "3.1415926535897932384626433832795028841972"
08:30:32 * hackagebot hlint 1.8.33 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.33 (NeilMitchell)
08:30:59 <yitz> > show pi
08:31:01 <lambdabot>   "3.141592653589793"
08:31:17 <Jafet> @where pi_10
08:31:17 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
08:31:24 <beaky> :O
08:32:53 <latro`a> > (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
08:32:56 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
08:33:00 <latro`a> lolwut
08:33:12 <latro`a> I refuse to figure out what the hell that actually means
08:33:21 <latro`a> probably some famous approximation or something
08:33:35 <beaky> what should I use if I want something that behaves like a List, but performs much better?
08:33:56 <Cale> beaky: Performs much better for what?
08:34:03 <rwbarton> ~~~a magic computer~~~
08:34:04 <yitz> see also jerzy's famous paper from many years ago to generate *all* digits of pi lazily
08:34:08 <beaky> http://ideone.com/r8zXv1 a turing machine ^^
08:34:26 <Jafet> The Cirque du Soleil performs very well
08:34:37 <beaky> cirque du soleil?
08:35:00 <arcatan> Jafet: :)
08:35:26 <Cale> beaky: Is that too slow?
08:35:44 <Jafet> Is anything not too slow?
08:35:45 <yitz> beaky: if you can convince ghc to fuse your List code into a tight loop in assembly using only registers, it's going to be hard to beat that.
08:36:05 <Cale> Those operations are already almost trivial.
08:36:11 <mcstar> well, you can go left and right, either take from the left and give to the right or vica versa
08:36:16 <mcstar> i think a list is optimal
08:36:20 <beaky> right
08:36:23 <mcstar> you always only touch the head of them
08:36:40 <yitz> beaky: if your algorithm is parallelisable and you convince ghc to use all of your cores, it's going be hard to beat that too.
08:36:52 <beaky> how do I make GHC optimize the stuff out of Tape and parallelize my turing machine? :D
08:36:59 <Cale> heh
08:37:00 <rwbarton> you don't of course
08:37:11 <Cale> Turing machines aren't very parallelisable in general.
08:37:23 <beaky> :(
08:37:31 <rwbarton> you could try a specialized/unboxed list type
08:37:43 <rwbarton> i doubt you would gain very much
08:37:46 <beaky> I'm out of ideas on optimizing my code :(
08:37:52 <mcstar> and reduce allocation as much as you can
08:37:52 <Cale> beaky: Do you have a program which is running too slowly?
08:38:21 <mcstar> someone reached a pretty good state yesterday
08:38:27 <mcstar> wasnt that fast enough already?
08:38:40 <Cale> I guess you might be able to do some insanely-clever thing to CPS-ify all this, which GHC might optimise better.
08:39:09 <beaky> yes: http://ideone.com/CdMVmY
08:39:22 <mcstar> he just rewrote it to CPS?
08:39:31 <beaky> what is CPS?
08:39:48 <mcstar> neckbeards use it
08:39:57 <beaky> lol
08:39:59 <Cale> heh, what?
08:41:01 <beaky> someone wrote something even faster than the oe I just pasted?
08:41:06 <beaky> I wanna see :D
08:41:30 <rwbarton> how are you compiling it?
08:41:47 <beaky> ghc -O2 -fflvm
08:41:57 <beaky> -fllvm*
08:42:15 <mcstar> i dont think llvm helps much with non numerical code
08:42:19 <beaky> :(
08:43:12 <rwbarton> how does the runtime compare to C currently?
08:43:51 <mcstar> you could try a mutable list... so that when you go back, dont deconstruct the state , but overwrite it
08:44:19 <beaky> does haskell have mutable lists?
08:44:25 <mcstar> no, i dont think so
08:44:41 <mcstar> lets call it a growable vector
08:44:48 <Cale> beaky: Apparently, my machine just did 11798826 steps of your Turing machine in 0.167 seconds, which means that your Turing machine was running at 70.6 MHz. Is that really not fast enough?
08:45:02 <int-e> latro`a: oh, that use of transpose is really clever.
08:45:09 <latro`a> I didn't do it
08:45:21 <latro`a> @where pi_10
08:45:21 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
08:45:27 <mcstar> who, thats fast
08:45:53 <int-e> well, whoever came up with it :)
08:45:53 <mcstar> you can almost operate a FM radio station with that turing machine
08:46:24 <beaky> my C version runs that fast in 0.1 seconds :D the Haskell version is about twice as slow on the same machine :(
08:46:44 <mcstar> GC
08:46:47 <latro`a> that is probably pretty reasonable, to be honest
08:46:49 <Cale> I doubt your C version has an infinite tape
08:46:52 <latro`a> also ^
08:46:57 <rwbarton> the C version also is using a linked list
08:47:06 <rwbarton> so it does, i think
08:47:10 <beaky> ah
08:47:13 <int-e> but laziness?
08:47:19 <mcstar> but do you deconstruct that list, or overwrite it?
08:47:28 <beaky> I overwrite it ^^
08:47:47 <int-e> beaky: a factor of 2 sounds really good then.
08:47:48 <rwbarton> it is basically the same data structure
08:48:15 <Cale> hmm
08:48:28 <Cale> I guess you could maintain a Tape of IORefs
08:48:29 <rwbarton> i guess it is a little cheaper in C because it is using a doubly-linked list so winding the tape is just updating a pointer
08:48:40 <Jafet> http://www.haskell.org/pipermail/haskell-cafe/2004-March/005939.html
08:48:41 <rwbarton> with the zipper you have to update a few pointers
08:49:10 <Cale> Jafet: That will never stop being relevant
08:49:21 <beaky> what is that? a flame war?
08:49:23 <int-e> Jafet: hah :)
08:50:17 <beaky> wow that looks so... imperative ^^
08:50:39 <Cale> Well, Simon directly translated the C program into FFI primitives
08:52:13 <Cale> The C program didn't compute anything useful, so the first person to respond just turned it into its result directly.
08:52:14 <int-e> Honestly I've found that Haskell is an awful language to write C code in. Better to write it in C and use FFI :)
08:52:27 <Cale> What? It's nice!
08:52:57 <rwbarton> if you want an awful language to write C code in try writing LLVM assembly directly using the Haskell LLVM bindings
08:52:58 <int-e> peek and poke? :P
08:53:12 <maukd> not really FFI, I'd say. just memory allocation/pointers
08:53:13 <Cale> int-e: Normally you wouldn't be doing so much of that directly.
08:53:20 <maukd> and he's fused the operations :-)
08:53:23 <beaky> http://stackoverflow.com/a/5269180
08:53:32 <maukd> Simon is an optimizing C compiler
08:53:35 <beaky> never imagined you can code imperatively in Haskell :D
08:53:36 <Cale> maukd: Well, okay, but that stuff is all part of the FFI spec.
08:53:48 <int-e> Cale: I know that we can have great abstractions like demonstrated in the vector/dph packages :)
08:53:57 <Cale> Haskell makes a great imperative language
08:56:38 <int-e> Cale: But IME it isn't good at what I had in mind when I wrote "C code": pointer chasing or intricate loops manipulating a few arrays.
08:57:15 <Cale> int-e: The thing which sucks about writing C code in C is that often the order of operations which change things becomes unclear. Even if you're forced into a small bit of extra verbosity (which is usually easy to abstract away without much harm), you end up sequencing things much more clearly where it matters.
08:57:48 <c_wraith> I've run into issues where things just aren't as optimized as you'd think.
08:57:48 <Cale> I often find myself having to translate imperative programs into a more verbose style where one thing happens at a time just to be able to understand them properly.
08:58:04 <c_wraith> like swapping elements in unboxed vectors..
08:58:22 <c_wraith> The standard function to do that boxes the elements in the process.  what?
08:58:55 <Cale> c_wraith: because it reads them both?
08:59:15 <c_wraith> Cale: yes. I really expected it'd be optimized more than that, since it's a class function
08:59:47 <Jafet> Presumably, it needs to make one extra value of the type, and that value is unboxed.
09:00:32 <c_wraith> one of my co-workers and I were optimizing some RC4 code.  We had to go to GHC primops to do the swap efficiently, on mutable unboxed vectors.  That seemed like unnecessary overkill.
09:01:19 <mcstar> and you made it insecure against timing attacks
09:01:32 <c_wraith> uh.  No.
09:01:45 <Jafet> Shouldn't the strictness analyser remove the boxing?
09:01:59 <rwbarton> where is this swap class method?
09:02:10 <c_wraith> oh, maybe it isn't a class function.
09:02:15 <beaky> so all I have to do to make my turing machine faster is to implement a foreign Tape module?
09:02:17 <int-e> c_wraith: so in the end, do you think there is still an advantage over using FFI and C?
09:02:50 <mcstar> you can encode your state with numbers and use a mutable unboxed vector
09:03:19 <Jafet> beaky: that doesn't make it faster; that clobbers it with another.
09:03:26 <mcstar> @hoogle grow
09:03:27 <lambdabot> Test.QuickCheck.Gen growingElements :: [a] -> Gen a
09:03:27 <lambdabot> Test.QuickCheck growingElements :: [a] -> Gen a
09:03:27 <lambdabot> package GrowlNotify
09:03:39 <c_wraith> yeah, ok.  It's in the generic module, but it isn't part of the MVector class.  That'd be why it's not optimized
09:03:40 <mcstar> grow :: PrimMonad m => MVector (PrimState m) a -> Int -> m (MVector (PrimState m) a)
09:03:48 <Jafet> You probably don't want to use Tape over FFI, because FFI calls have overheads.
09:04:11 <mcstar> you dont want to grow 1 by 1
09:04:15 <rwbarton> you could replicate your C structure with IORefs
09:04:23 <beaky> right
09:04:32 <beaky> so IORefs are like baby malloc blocks?
09:04:33 <int-e> beaky: it's tricky - I really only want to advertise FFI for inner loops, not for data structures.
09:04:36 <rwbarton> yes basically
09:04:39 <monochrom> no, implement tape by zipper
09:04:44 <rwbarton> he has a zipper
09:04:50 <rwbarton> but apparently 2x C runtime is not fast enough
09:04:53 <mcstar> you dont want a list either
09:04:59 <mcstar> just go with the vector
09:05:01 <monochrom> yikes
09:05:05 <rwbarton> indeed
09:05:19 <mcstar> (if you really cant sleep with knowing ghc performed worse than gcc)
09:05:31 <rwbarton> you can also just make your C program slower somehow
09:05:38 <mcstar> XD
09:05:41 <Jafet> You don't need a vector either. It's a linked list.
09:06:14 <monochrom> "FFI for inner loops" means: write the whole inner loop in C. not: call C in the inner loop
09:06:23 <int-e> monochrom: thanks
09:06:24 <mcstar> so, you think it is cheaper do deconstruct the ioreffed list, than allocating big chunks of vector rarely?
09:06:27 <monochrom> hehe
09:07:00 <mcstar> also, you can use the vector as a ring
09:07:10 <mcstar> if you are certain, you dont go back more than N steps
09:08:12 <Jafet> If I was making a UTM, I'd make it faster than the fastest C version that someone could write in the same amount of time.
09:08:14 <beaky> where can I learn about IORef?
09:08:40 <int-e> Jafet: say, compile it using llvm?
09:08:50 <startling> beaky: the wiki has a good page I think. sec
09:08:54 <Jafet> Perhaps, but you can also use llvm from C.
09:09:00 <int-e> true.
09:09:11 <Jafet> You could express more optimization passes
09:09:57 <startling> beaky: can't find it, sorry
09:10:27 <mcstar> newIORef, readIORef, writeIOREf, modifyIORef, thats all you need to know
09:10:39 <mcstar> and the types of them, but those are pretty self exlanatory
09:10:41 <mcstar> p
09:10:57 <beaky> :t newIORef
09:10:58 <lambdabot> Not in scope: `newIORef'
09:11:01 <beaky> :(
09:11:06 <c_wraith> hmm.  do the foreign allocation functions clear the memory they allocate?
09:11:15 <mcstar> lmbdabot doesnt have IO i heard
09:11:16 <jfischoff> Has anyone else thought about changing the type of repa-devil's arrays Array F DIM3 Word8 to Array r DIM2 (Word8, Word8, Word8)? For resampling i'm doing all of the index calculations three times
09:11:28 <mcstar> @hoogle newIORef
09:11:28 <lambdabot> Data.IORef newIORef :: a -> IO (IORef a)
09:11:36 <monochrom> IORef stuff is in Data.IORef
09:11:50 <startling> > putStrLn "hello"
09:11:51 <lambdabot>   <IO ()>
09:12:04 <mcstar> hehe
09:12:13 <startling> > putStrLn "hello" >> return 3
09:12:14 <lambdabot>   <IO Integer>
09:12:15 <mcstar> > putStrLn "<IO ()>"
09:12:17 <lambdabot>   <IO ()>
09:12:19 <mcstar> > putStrLn "<IO ()>"
09:12:20 <lambdabot>   <IO ()>
09:12:25 <mcstar> look it worked^
09:12:26 <Jafet> jfischoff: does repa-devil always have three bytes of channels?
09:12:27 <startling> mcstar: it works!
09:12:39 <int-e> Jafet: mm, harpy has only one reverse dep on hackage :/ I was wondering whether it could be a starting point for reinventing llvm.
09:12:40 <beaky> so with IORef I have python-style variables?
09:12:48 <startling> I wonder if Cale has a log somewhere with a thousand "hello, world"s
09:12:49 <jfischoff> Jafet: three or four depending on the image
09:12:56 <startling> beaky: uhhh
09:13:01 <mcstar> not really
09:13:08 <jfischoff> and grey scale but that one is fine
09:13:19 <mcstar> python style variables are string in a dictionry
09:13:27 <Jafet> That's strange then, many image formats have 16-bit channels
09:13:29 <Cale> startling: ?
09:13:36 <killy9999> is there an O(1) method of converting Storable Vector to an Unboxed one?
09:13:48 <Jafet> int-e: just convince Apple to throw money at you
09:13:48 <startling> Cale, putStrLn to lambdabot
09:14:09 <startling> beaky, why not use a State or Reader?
09:14:11 <int-e> Jafet: eww.
09:14:36 <jfischoff> Jafet: IL might support them, repa-devil just might not be exposing them
09:14:40 <beaky> right
09:15:01 <startling> beaky, then you can use these things from pure code
09:15:21 <mcstar> but the whole thing is the code
09:15:38 <mcstar> IO | pure little code | ST
09:15:52 <mcstar> little pure code*
09:16:11 <startling> oh, you're a good little code, aren't you
09:16:13 <Jafet> killy9999: unsafely, yes
09:16:25 <killy9999> Jafet: how?
09:16:33 <startling> yes you are, yes you areeee
09:16:39 <Jafet> Well, I'd need to find out
09:16:54 <killy9999> I'm working with FFI so I'll probably end up using unsafePerfomrIO anyway
09:16:57 <mcstar> startling: you are peting someone else's code?
09:17:16 <c_wraith> killy9999: you could do it with a combination of unsafeThaw and unsafeFreeze
09:17:20 <startling> mcstar: essentiallly
09:17:23 <Jafet> No, more unsafe than that
09:17:24 <c_wraith> killy9999: which is a bit silly, but it would work
09:17:41 <Jafet> unsafePerformIO is pretty safe compared to some of the array internals
09:18:59 <killy9999> c_wraith: I'm looking at haddock and it seems that unsafeThaw/Freeze operate on Storable vectors
09:19:03 <killy9999> or am I wrong?
09:19:41 <killy9999> perhaps I should expand my question a little bit
09:19:43 * typoclass is not really convinced that whenever you use the FFI, you'll "probably" end up using unsafePerformIO
09:19:48 <Jafet> Well, just unsafeFreeze should work
09:20:29 <killy9999> I have a C function that returns mallocated array of doubles. How to avoid unnecessary data copying?
09:20:30 <Jafet> And GHC even guarantees it
09:20:37 <c_wraith> killy9999: hmm.  well, there are unsafeFreeze/unsafeThaw for each of storable and unboxed - but it looks like there's no common representation they'll convert to
09:21:14 <Jafet> "In GHC, The following pairs of array types have a non-copying O(1) implementation of unsafeFreeze"
09:21:21 <Jafet> "STUArray -> UArray"
09:21:33 <c_wraith> Jafet: I'm looking at vector, not array
09:22:16 <killy9999> isn't data.Array deprecated?
09:22:25 <rwbarton> no??
09:22:28 <Jafet> Oh
09:22:34 <c_wraith> No, but vector definitely is better for many cases
09:22:52 <dsdeiz> hi, is this fine? function sum = [ x | x <- [1..1000], x `mod` 5 == 0, x `mod` 3 == 0]? just wondering how i can pass an integer as the parameter and make the set accept that instead of [1..1000]?
09:23:03 <killy9999> I'd like to go with Vector, because it nicely integrates with Repa
09:23:09 <dsdeiz> oops i mean function = sum [*
09:23:56 <c_wraith> so, right.  the C function giving you a bunch of doubles matches nicely with Storeable vectors, but not unboxed
09:24:07 <monochrom> > [ x | x <- [1..1000], x `mod` 5 == 0, x `mod` 3 == 0]
09:24:09 <lambdabot>   [15,30,45,60,75,90,105,120,135,150,165,180,195,210,225,240,255,270,285,300,...
09:24:14 <monochrom> seems to work
09:24:22 <killy9999> so I'm left with Storable Vector, unless I explicitly copy it to a new Unboxed vector?
09:24:23 <maukd> > sum [ x | x <- [0, 15 .. 1000] ]
09:24:24 <lambdabot>   33165
09:24:31 <monochrom> heh
09:24:56 <dsdeiz> ah is it possible to have it pass an integer in place  of that 1000?
09:24:57 <typoclass> dsdeiz: hello, it looks ok to me :) if you want to add an argument to the function, write it between the function name and the "=". you could use "function limit = ...". you can then refer to limit, e.g. write "[1..limit]"
09:25:09 <mcstar> ah great
09:25:11 <dsdeiz> ah cool. thanks
09:25:15 <mcstar> all the people are here who know arrays
09:25:20 <maukd> > let function n = sum [ x | x <- [0, 15 .. n] ] in function 500
09:25:21 <lambdabot>   8415
09:25:31 <mcstar> there was a question here couple days ago, that id really like to hear the answer to
09:26:12 <mcstar> basically, there was a code that worked well, with safe read/write functions, the array's min index was 5
09:26:24 <c_wraith> killy9999: well, you can *probably* do something really dirty, involving internal representations. Though the fact that the memory was allocated C-side means you'd have to be *really* careful about making sure it gets freed at the right time.
09:26:59 <mcstar> but when the guy changed in one place either a read or a write function to its unsafe counterpart, the code gave wrong results
09:27:03 <mcstar> even segfaults
09:27:16 <mcstar> but worked again, if the starting index was set to 0
09:27:16 <c_wraith> mcstar: yes. unsafeRead and unsafeWrite don't use the Ix interface
09:27:24 <rwbarton> they use raw indices starting from 0, yes
09:27:29 <mcstar> heh
09:27:33 <monochrom> interesting
09:27:35 <rwbarton> that way you can save index computations
09:27:46 <mcstar> but there is a function that creates unsafely an array with the given min-max indices
09:27:59 <c_wraith> honestly, that should be obvious from the types
09:28:00 <mcstar> newUnsafeArray or similar
09:28:05 <rwbarton> "creates unsafely"?
09:28:12 <mcstar> yeah...
09:28:12 <rwbarton> the version that just hands you uninitialized memory?
09:28:26 <Jafet> killy9999: unsafeFreeze :: PrimMonad m => MVector (PrimState m) a -> m (Vector a)
09:28:27 <mcstar> idk, Data.Array.Base isnt even documented
09:28:27 <c_wraith> read's type involves Ix, unsafeRead's type doesn't
09:28:33 <Jafet> That looks correct
09:28:44 <c_wraith> mcstar: types tell you a lot
09:29:08 <mcstar> i know, but the unsafeRead, unsafeWrite isnt even anywhere in Data.Array.*
09:29:17 <mcstar> i was surprised
09:29:31 <mcstar> anyway, yeah, if its Int and not Ix a, that should tell a lot
09:30:11 <killy9999> c_wraith: don't finalizers handle memory deallocation automtically?
09:30:11 <mcstar> unsafeRead :: (GHC.Arr.Ix i, MArray a e m) => a i e -> Int -> m e
09:30:28 <mcstar> the thing that fooled me, was that Ix was present as a constraint
09:30:33 <mcstar> but for the array type
09:30:36 <mcstar> not the index type
09:30:55 <mcstar> c_wraith: rwbarton thanks
09:32:21 <mcstar> b__ was his name
09:32:26 <rwbarton> that is a bit sneaky yes, the constraint shouldn't even be needed
09:34:57 <dsdeiz> the predicates in a list comprehension should be read like 'x % 5 == 0 or x % 3 == 0' or 'x % 5 == 0 and x %3 == 0'?
09:35:26 <typoclass> dsdeiz: read it with 'and'
09:35:45 <ciccio> ciao
09:35:52 <dsdeiz> ok thanks
09:35:59 <ciccio> list
09:36:11 <rwbarton> @src []
09:36:11 <lambdabot> data [] a = [] | a : [a]
09:36:37 <ciccio> :!list
09:36:55 <rwbarton> ciccio, see above
09:37:35 <Jafet> @tuple
09:37:36 <lambdabot> <no location info>: not an expression: `'
09:37:45 <ciccio> i don't know mIRC and i don't speak englash );....
09:38:00 <ciccio> please can I have a list?
09:38:03 <maukd> ciccio: how did you find this channel?
09:38:09 <Cale> ciccio: A list of what?
09:38:13 <dsdeiz> so i guess if i wanted 'or' i can't use list comprehensions?
09:38:19 <maukd> dsdeiz: ||
09:38:29 <shapr> preflex: seen desrt
09:38:30 <preflex>  Sorry, I haven't seen desrt
09:38:32 <Cale> ciccio: A list of prime numbers?
09:38:35 <rwbarton> wow I always thought those "ciao" things were bots
09:38:42 <shapr> I guess not.
09:38:43 <maukd> rwbarton: no, italians
09:38:54 <shapr> maukd: or Portuguese/Brazilians
09:39:11 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) (takeWhile (\p -> p*p <= n) primes) in primes
09:39:12 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
09:39:13 <maukd> with *.it hostmasks?
09:39:22 <dsdeiz> oh cool thanks
09:39:29 <rwbarton> they are 90% from .it yeah
09:39:30 <shapr> maukd: point :-)
09:39:30 <Cale> ciccio: ^^ there is a list
09:39:36 <mcstar> ciccio: i give you (:), the list constrcutor, make as many and long lists as you want
09:39:59 <typoclass> dsdeiz: you could do [... | x <- [...] , x `mod` 3 == 0 || x `mod` 5 == 0]
09:40:00 <maukd> > cycle "ciao a tutti "
09:40:01 <lambdabot>   "ciao a tutti ciao a tutti ciao a tutti ciao a tutti ciao a tutti ciao a tu...
09:40:08 <dsdeiz> typoclass: yeah, thanks
09:40:36 <ciccio> ciao italiano sai dirmi come usare mirc?
09:40:55 <monochrom> the correct command is !list , not :!list
09:40:58 <mcstar> #mirc
09:41:02 <ciccio> ciao sai dirmi come si usa mirc?
09:41:04 <typoclass> ciccio: if you need a list of channels, use "/list"
09:41:06 <maukd> FSVO "correct"
09:41:32 <rwbarton> "try asking on #freenode"
09:41:57 <mcstar> well, to be honest, my first command probably was /list
09:42:03 <mcstar> i was overwhelmed
09:42:11 <mcstar> probably quit from the client
09:42:48 <clahey> What's FSVO?
09:42:53 <Clint> "for some value of"
09:42:55 <mcstar> for certain values of
09:43:05 <mcstar> yeah, some
09:44:17 <mcstar> i think somebody tricked him into joining #haskell
09:44:46 <mcstar> probably promised ascii art of nude women in the topic
09:46:39 <Saizan> they look for "file servers"
09:47:47 <Saizan> i.e. bots from which they can download stuff through dcc
09:47:50 <Cale> someone should put up an XDCC of hackage
09:48:01 <monochrom> oh, hackage!
09:48:01 <Cale> just for such cases :)
09:48:13 <mcstar> can i coin FCDO ?
09:48:28 <Clint> for certain dccs of?
09:48:34 <mcstar> definitions
09:48:45 <Clint> sure
09:48:49 <mcstar> it is one of the few non-dcc related acronyms
09:49:57 <typoclass> Cale: oh that will lead to swell complaints ... "was looking for erotic stories of threesome donkey-on-librarian action, but instead got category-extras"
09:52:12 <beaky> > let 0 = 1
09:52:13 <lambdabot>   not an expression: `let 0 = 1'
09:52:20 <beaky> > let 0 = 1 in 0
09:52:21 <lambdabot>   0
09:52:29 <atriq> Anyone feel like answering not very interesting lens questions?
09:52:38 <startling> I can try.
09:52:47 <trebla> !list
09:52:47 <monochrom> trebla: http://hpaste.org
09:53:23 <rwbarton> still think the best would be http://okmij.org/ftp/Haskell/
09:53:27 <fmap> atriq: sure
09:53:30 <kylcarte> atriq, shoot
09:53:35 <mcstar> typoclass is rightfully embarrassed
09:54:13 <monochrom> yes, I have that one too. I have 3 urls, randomly chosen. they are: oleg, hpaste, hackage. hackage is just added a minute ago, inspired by Cale!
09:54:15 <atriq> If I've got a function a -> Simple Lens a b; is there a way I could sort of "double level" that
09:54:27 <rwbarton> ah good
09:54:36 <atriq> In a simple way
09:54:37 <clahey> Can I have multiple assignments with the same variable at the top level of a haskell file if they are the same value?
09:54:47 <trebla> !list
09:54:47 <monochrom> trebla: http://hackage.haskell.org/packages/archive/pkg-list.html
09:54:52 <monochrom> hehe!
09:55:04 <rwbarton> monochrom++
09:55:08 <mcstar> !list
09:55:28 <mcstar> chill, i wont repeat that
09:55:31 <monochrom> you'll need to wait a minute for !list to be effective again.
09:55:54 <monochrom> it's counter-lure-me-to-flood measure
09:55:55 <Clint> rate-limited
09:56:00 <atriq> Simple Lens b a, rather
09:56:06 <kylcarte> atriq: can you elaborate?
09:56:14 <kylcarte> "double level"
09:56:31 <mcstar> clahey: i would think ghc would complain, but you have already tried that, didnt you?
09:56:57 <mcstar> anyway, it isnt really an assigment
09:57:07 <mcstar> rather a top level definition
09:57:15 <monochrom> it's an error to do that, clahey
09:57:17 <atriq> kylcarte, using as a getter to get the value out, then running the function again to get a new lens with that getter, then using that to get the value?
09:57:55 <atriq> (a -> Getter b a) -> a -> Getter b a
09:58:21 <killy9999> how do I convert CInt <-> Int, CDouble <-> Double  and so on?
09:58:31 <killy9999> fromIntegral, realToFrac and so on?
09:58:37 <monochrom> yes that's right
09:58:41 <killy9999> ok
09:59:03 <clahey> mcstar: Good point about my language usage.
09:59:35 <killy9999> what if I have Ptr Double and I need to convert it to Ptr CDouble?
09:59:55 <monochrom> I do hate all other languages using "=" for assignment. x=x+1, that's a contradiction, not an assignment.
09:59:56 <rwbarton> why do you have a Ptr Double
10:00:03 <rwbarton> but you can use castPtr
10:00:06 <monochrom> x := x + 1 is an assignment
10:00:15 <solrize> halvm.org is down, anyone know who takes care of it?
10:00:29 <atriq> kylcarte, \f a -> f (view (f a) a) is the best I could do
10:00:54 <killy9999> rwbarton: I declared function imported from C to accept Ptr CDouble as a parameter
10:01:01 <rwbarton> yes good
10:01:24 <killy9999> is castPtr safe in this case?
10:01:36 <rwbarton> I still don't understand why you have a Ptr Double
10:01:45 <killy9999> um...
10:01:49 <killy9999> gimme a second
10:01:54 <rwbarton> if you want to (un)marshall that from C you should use CDouble's Storable instance
10:01:59 <monochrom> whether CDouble and Double are equivalent depends on the compiler. for GHC I think yes
10:02:01 <rwbarton> now almost assuredly they are the same
10:02:14 <hpaste> killy9999 pasted “Ptr Double” at http://hpaste.org/76661
10:02:19 <killy9999> there
10:02:25 <startling> they're the same as per haskell 2010 I think
10:02:39 <killy9999> it's implicit
10:02:49 <rwbarton> if you want to be totally correct and zero-copy you should return a Vector CDouble
10:02:54 <killy9999> due to using unsafeToForeignPtr on a Vector of Doubles
10:03:13 <kylcarte> atriq, from this statement "to get a new lens with that getter", it seems that you're looking for a lens into a lens
10:03:33 <atriq> I... think maybe?
10:03:36 <killy9999> rwbarton: I guess I want the function doubleVec to look like it was an ordinary Haskell function
10:03:49 <killy9999> so I want it to use ordinary Haskell types
10:04:06 <wolfjb> how do I get the status bar at the top of the screen to go all the way across, and is there a way to configure xmonad to not have that area of the screen overlapped by windows?
10:04:12 <rwbarton> well then your options are (1) copy (2) rely on CDouble having the same Storable instance as Double and then use castPtr
10:04:43 <efie> Is the implementation of map a good one for lazy evaluation?  I mean, as it is "f x : map f xs" the whole mapping has to be evaluated before an element can be accessed. Can this still be used for lazy evaluation? Wouldn't "[f x] ++ map f xs" better?
10:05:11 <beaky> how powerful are Haskell's pattern matching features compared to other languageS?
10:05:14 <rwbarton> efie: yes, what?, yes?, no
10:05:30 <clahey> efie: Why would the whole mapping have to be evaluated to get the first element?
10:06:08 <monochrom> "[f x] ++ map f xs" first takes a few steps to become "f x : map f xs"
10:06:44 <monochrom> anyway, "f x : map f xs" is good for lazy evaluation
10:07:03 <byorgey> beaky: which other languages?
10:07:17 <beaky> Prolog, ML, Lisp, C#
10:07:17 <rwbarton> data constructors like (:) are (by default) lazy
10:07:23 <monochrom> > sin 1 : map sin undefined
10:07:25 <lambdabot>   [0.8414709848078965*Exception: Prelude.undefined
10:07:35 <monochrom> > head (sin 1 : map sin undefined)
10:07:37 <lambdabot>   0.8414709848078965
10:07:38 <jfischoff> I think performance Haskell exercises would be real useful. I'm imagining something were you see a C loop and then you see the Haskell code that produces something equivalent, with the optimization steps compiler took.
10:07:46 <efie> ok, but if you have "(f x) : ( ... )", how can (f x) be accessed? The list will be constructed if the end of the mapping with ... : [] is reached, will it not?
10:07:59 <monochrom> this shows that "map sin undefined" does not affect getting at the "sin 1" part
10:08:07 <jfischoff> after about twenty I might get the hang of it
10:08:17 <byorgey> beaky: compared to ML and Prolog, I'd say about the same.  Lisp doesn't really have pattern matching at all.  and I am not familiar with C#.
10:08:27 <monochrom> use head or pattern matching or take or ...
10:08:34 <kylcarte> atriq, still a bit hazy on what you're looking for, but if that *is* the case, then maybe this is along the lines of what you want: http://pastebin.com/NRzzB11Y
10:08:36 <beaky> pattern matching ftw.
10:08:41 <maukd> The paste NRzzB11Y has been copied to http://hpaste.org/76662
10:08:59 <monochrom> then again, head and take and ... all use pattern matching
10:09:08 <rwbarton> efie: let (y:ys) = (f x) : (...) in {- use y -} does not evaluate the (...)
10:09:33 <monochrom> even if you "print (f x : ...)", print uses pattern matching. it just doesn't stop early
10:09:37 <kylcarte> atriq: maybe? what do you think?
10:10:10 <atriq> I'm not sure
10:10:12 <clahey> monochrom: Specifically, show List uses pattern matching, right?
10:10:13 <atriq> I'll think about it
10:10:19 <efie> hm ok
10:10:59 <Jafet> Heh, runghc has a memory leak when printing.
10:12:02 <Jafet> echo 'main = mapM_ putStrLn $ repeat ":-)"' | runghc > /dev/null
10:12:30 <byorgey> I am SO not going to run that.
10:12:55 <Jafet> The :-) is actually shellcode, dude.
10:13:49 <merijn> efie: The list is constructed as necessary. Not when the last entry is mapped
10:14:41 <merijn> efie: "f x : map f xs" immediately returns "<pointer to computation for f x> : <pointer to computation for map f xs>", those computations will only be run once you try to look at one of the sides of the :
10:15:26 <efie> merijn: ok thanks :)
10:16:04 <merijn> Where "looking at a side" is defined as "trying to pattern match it"
10:17:16 <merijn> Pattern matching (z:zs) with <pointer to computation for map f xs> will set z to <pointer to computation for f (head xs)> and zs to <pointer to computation for map f (tail xs)>, etc
10:18:19 <byorgey> except it does not actually involve calls to head and tail.
10:19:14 <merijn> byorgey: I didn't know how else to describe those values since they don't have a name :\
10:19:45 <byorgey> pattern matching (z:zs) with <pointer to computation for map f xs> will cause that computation to be carried out just far enough to turn it into  <pointer...> : <pointer...>
10:19:52 <byorgey> and then it will assign those to z and zs
10:29:14 <beaky> what does unboxing mean
10:30:28 <c_wraith> well..  it means...  um.  unboxing.  Answering the question from the other side is much easier.
10:30:40 <c_wraith> "what does it mean to be boxed?"
10:30:59 <c_wraith> boxed values are how GHC represents most data.
10:31:10 <beaky> so its like references?
10:31:59 <c_wraith> Boxed values have an extra level of indirection, that works as a thunk for lazy evaluation
10:32:44 <c_wraith> It contains a pointer, and a tag saying either "this is a value" or "this is an expression that will give you a value when it's evaluated".  More or less.
10:33:07 <c_wraith> (there are some extra values for dealing with things being calculated already, but they can be ignored for this perspective)
10:34:08 <c_wraith> an unboxed value removes that pointer and tag.  consequences of this are that the value must always be evaluated before it's stored, and that there's one less pointer to follow to use the value
10:35:10 <klr> hi all haskellers!
10:35:18 <rwbarton> so if you have data A = X Double Double; a value constructed with the X constructor will contain two pointers to boxed Doubles
10:35:48 <c_wraith> Oh, and GHC considers the types of unboxed values to be special.  regular polymorphism implies only boxed values, because the boxing is how GHC knows to treat values of unknown types uniformly
10:36:05 <clahey> rwbarton: How does that work in implementation with thunks?  Does the pointer contain information about whether it's to a thunk or a boxed value or undefined?
10:36:11 <rwbarton> (or maybe it should be "two boxed Doubles, which are pointers to either thunks or actual Doubles)
10:36:14 <rwbarton> "
10:36:19 <rwbarton> I don't know exactly
10:36:36 <clahey> Okay.  :)
10:36:36 <rwbarton> I should get around to reading that paper one of these days.
10:37:34 <rwbarton> but if you have data B = Y {-# UNPACK #-} !Double {-# UNPACK #-} !Double, then a value constructed with Y will literally have 16 bytes of memory containing one double followed by another double -- no pointers
10:38:34 <DMcGill> certainly I've found that if you have primitive data type and aren't using them polymorphically, unboxing and making them strict will really help program performance
10:38:39 <fmap> FSVO 16?
10:38:53 <c_wraith> doubles should be 8 bytes each on every platform I know of
10:38:54 <fmap> oh, probably not
10:38:57 <c_wraith> err, that GHC runs on
10:42:12 <mcstar> lets add that boxing is ubiquitious in most high level language implementations
10:42:19 <mcstar> if i spelled it right
10:42:27 <c_wraith> close
10:42:41 <beaky> http://ideone.com/JeO8BO no ideas on ways to optimize this code?
10:42:59 <beaky> windL and windR are still top consumers :(
10:45:11 <mcstar> beaky: i dont think you understood, but we said repeatedly, that it runs with excellent performance
10:45:29 <mcstar> you have to make significant changes for dubious performance increase
10:45:56 <c_wraith> Those functions are as efficient as possible.
10:46:09 <saep> maybe a 'PointedList' is more efficient than the tape :o
10:46:20 <c_wraith> If you want to make them faster, you'll need to change your data representation significantly
10:46:37 <c_wraith> like, chunk the tape, or the like
10:50:33 <mcstar> PointedList [a] a [a]
10:50:46 <mcstar> yeah, seems to be a better representation
10:50:49 <monochrom> I know. you need to JIT-compile the turing machine on the fly
10:51:11 <c_wraith> That is the same as the tape, except not including the default symbol
10:51:13 <Kyraimion> rwbarton:  Doesn't the constructor take up one word?
10:51:13 <rwbarton> import LLVM.Turing
10:51:25 <mcstar> c_wraith: yeah, sarcasm
10:51:39 <rwbarton> Kyraimion, I didn't mean to imply that there wouldn't be other space used for other things
10:51:57 <rwbarton> just that the "Double"s are stored directly in the value rather than via pointers
10:52:21 <rwbarton> I think the constructor always takes one word yes
10:52:28 <rwbarton> for data
10:53:16 <mcstar> well, we could sell HaskellMachines, these machines would implement these things at the hardware level
10:53:29 <mcstar> and everything would be unboxed, basically
10:53:46 <mcstar> the GC would run on stream processors, to not interfere with normal operations
10:53:50 <Kyraimion> rwbarton:  Ah, I was just confused because you said a value constructed by Y will "have" 16 bytes of memory, I read it as "uses" 16 bytes.
10:55:41 <mcstar> "A strictness annotation forces the compiler to ensure that the field is fully evaluated before building the constructor, and if it turns out that the field was already evaluated then this is just wasted work."
10:55:44 <klr> Real World Haskell first example, could someone please step by step explain the example, i dont understand much of it, there is even a "magic variable" which i didnt know if it's a variable or not etc. ?
10:55:52 <mcstar> "(GHC does a poor job, currently)"
10:56:19 <klr> here the example is: https://gist.github.com/3940345
10:56:46 <mcstar> " When a constructor field is marked strict, and it is a single-constructor type, then it is possible to ask GHC to unpack the contents of the field directly in its parent."
10:56:53 <mcstar> rwbarton: has this changed? ^
10:57:15 <rwbarton> i think that has been true for quite a while
10:57:18 <mcstar> stress is on 'single constructor'
10:57:44 <c_wraith> yes, that's how GHC has been for a long time
10:57:50 <mcstar> so, i think the constrctor can be eliminated, too, cant it?
10:58:09 <c_wraith> the constructor *for value being stored*
10:58:17 <c_wraith> not the constructor for the value storing it
10:58:17 <rwbarton> the constructor for Double is eliminated
10:58:19 <rwbarton> right
10:58:37 <mcstar> data B = Y {-# UNPACK #-} !Double {-# UNPACK #-} !Double
10:58:47 <mcstar> im just trying to understand how much space that takes ^
10:58:57 <mcstar> 16 or 16 + word
10:59:06 <Kyraimion> 16 + word
10:59:36 <mcstar> but the plus information, the Y or the B isnt needed anymore
10:59:47 <rwbarton> even data X = X uses a word
10:59:52 <mcstar> if the program typechecked, and it is not a 'variant' type...
11:00:04 <mcstar> yeah, thats true
11:00:13 <rwbarton> the word is needed e.g. for the gc to know what parts of the data are pointers
11:01:16 <mcstar> another anagle, if the type has multiple constructors, it is superfluous to use the UNPACK pragma, since it cannot be unpacked
11:01:21 <mcstar> correct?
11:01:27 <mcstar> angle*
11:01:34 <rwbarton> if you mean the type after the UNPACK pragma, then yes
11:01:48 <rwbarton> data B = Y {-# UNPACK #-} !Double {-# UNPACK #-} !Double | Z {-# UNPACK #} !Double is fine
11:01:54 <beaky> so my turing machine is as optimal as it gets? :(
11:02:26 <c_wraith> beaky: it's optimal unless you make big changes to core structures and assumptions
11:02:48 <beaky> so I'm at the brink of a paradigm shift
11:03:26 <yitz> beaky: write a compiler for your turing machine programs that produces optimized assembler
11:03:40 <beaky> in Haskell :D great idea for a second project
11:04:05 <mcstar> rwbarton: yeah, the second one, i got interrupted
11:04:05 <c_wraith> beaky: I mean, a lot of the cost you're paying is chasing a couple (boxing!) pointers for each position change in the tape.
11:04:38 <beaky> that seems a high cost
11:04:57 <c_wraith> beaky: if you changed your tape representation significantly, you could make that a lot cheaper.  But you'd probably lose polymorphism and have to work in ST or IO to do that particularly well.
11:05:16 <mcstar> newtype Color = Color Int deriving (Eq,Ord,Enum)
11:05:19 <mcstar>  (red:blue:black:_) = [Color 1 ..]
11:05:29 <mcstar> heh, optimization for enums
11:06:22 <mcstar> beaky: it is fast, write it in lisp/ocaml the same thing, haskell will win probably
11:06:37 <mcstar> at least, it will win in readability
11:07:29 <mcstar> beaky: you could try this trick, i told you to use numbers instead your enum like types, this trick shows you how to define them comfortably
11:08:23 <mcstar> but i think your time is better spent on learning more type system stuff
11:11:02 <beaky> right
11:19:54 <efie> is Data.HashMap better than Data.Map concerning speed and, more important, space?
11:21:38 <yitz> efie: Data.HashMap from which package?
11:22:05 <efie> yitz: unordered-container (is there a better implementation?)
11:22:13 <efie> containers*
11:23:05 <yitz> efie: that's excellent. written by tibbe.
11:23:58 <tibbe> efie: better in both speed and space
11:24:11 <jeff_s1> I doubt HashMap will win for space, since it keeps the keys and their hashes. If space is important, hash manually and use Data.IntMap.
11:25:10 <yitz> tibbe: did unordered-containers make it in to the next platform?
11:25:18 <tibbe> yitz: no
11:25:23 <yitz> too bad
11:25:36 * hackagebot HStringTemplate 0.6.12 - StringTemplate implementation in Haskell.  http://hackage.haskell.org/package/HStringTemplate-0.6.12 (SterlingClover)
11:25:38 <tibbe> efie: Data.HashMap is about ~4.5 words overhead per key-value pair, Data.Map is 6 words
11:25:57 <tibbe> efie: http://blog.johantibell.com/2011/06/memory-footprints-of-some-common-data.html
11:26:11 <tibbe> efie: and for the latest unordered-containers: http://blog.johantibell.com/2012/03/announcing-unordered-containers-02.html
11:27:05 <Jafet> Uh, why would this cause a memory leak?
11:27:12 <Jafet> main = sequence $ repeat ()
11:27:45 <ahkurtz> isn't that an infinite sequence and you are forcing it?
11:27:49 <geekosaur> sequence collects the results, no?  sequence_ discards them
11:28:00 <c_wraith> :t sequence
11:28:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:28:05 <rwbarton> it wants to print "[(),(),()..."
11:28:06 <c_wraith> what's the monad?
11:28:15 <rwbarton> given the name 'main' I am going to guess IO
11:28:18 <ahkurtz> IO
11:28:18 <geekosaur> ^^
11:28:26 <c_wraith> I mean in "repeat ()"
11:28:26 <Jafet> main = sequence_ $ repeat $ return ()
11:28:34 <Jafet> Is the one
11:28:35 <jeff_s1> efie: If you don't need to retrieve the original keys from the container, use IntMap instead of HashMap.
11:28:43 <c_wraith> ah, that return is really important
11:28:45 <rwbarton> repeat doesn't involve a monad...?
11:28:50 <rwbarton> @type repeat
11:28:51 <lambdabot> forall a. a -> [a]
11:28:57 <efie> tibbe: thanks, I'll look at it, - what do you say to jeff_s1 s suggestion?
11:29:08 <c_wraith> rwbarton: did you read the code he showed first? There was no return in it. hence my question
11:29:18 <rwbarton> oh i see
11:29:36 <geekosaur> :t sequence $ repeat ()
11:29:36 <Jafet> Yes, the first won't even type check (thus averting the memory leak)
11:29:37 <lambdabot>     Couldn't match expected type `m a' against inferred type `()'
11:29:37 <lambdabot>     In the first argument of `repeat', namely `()'
11:29:37 <lambdabot>     In the second argument of `($)', namely `repeat ()'
11:29:40 <c_wraith> Jafet: sequence has to run *all* of the actions, then it gives you back the list of results.  in that order.
11:29:55 <geekosaur> hm, point
11:30:04 <Jafet> runghc still has a memory leak on the second program.
11:30:15 <rwbarton> maybe Jafet has OverloadedZeroTuple
11:30:23 <c_wraith> Jafet: yes, sequence of an infinite list will always run out of memory
11:30:31 <ahkurtz> it's not a memory leak
11:30:34 <Jafet> But not sequence_.
11:30:50 <rwbarton> do you see the leak with 'forever'?
11:31:06 <S11001001> @src repeat
11:31:06 <lambdabot> repeat x = xs where xs = x : xs
11:31:12 <yitz> jeff_s1: tibbe (and others) started with the idea of hashing and using IntMap. then they did a huge amount of research to optimize and improve. it's very very unlikely that it will be better to go back to the primitive way of hashing manually and using IntMap. (although it wouldn't be terrible either)
11:31:14 <S11001001> good
11:31:42 <Jafet> rwbarton: I do; do you?
11:31:49 <Jafet> main = forever $ return ()
11:31:55 <rwbarton> let me test
11:32:23 <c_wraith> I believe there's an optimization necessary for the IO constructors to not build up
11:32:35 <c_wraith> and that if you run interpreted, you lack that optimization
11:32:40 <jeff_s1> yitz: I'm confident HashMap is quite fast, but it keeps track of the original key values, which uses more memory, which efie is concerned about. IntMap might be better for him due to space reasons.
11:32:46 <rwbarton> Jafet, yes i do
11:32:59 <Jafet> c_wraith: notwithstanding the fact that this optimization seems morally necessary, it only happens with runghc
11:33:20 <efie> tibbe: sorry if I don't get this right, but does your table not say that the memory footprint of Data.HashMap is bigger than Data.Map? Because 5N + 4(N-1) > 6N?
11:33:22 <yitz> jeff_s1: i guess efie could try both and profile it
11:33:23 <c_wraith> Jafet: and runghc interprets.  but does it not happen with ghci?
11:33:33 <Jafet> I don't think so
11:33:52 <hamid> gush! quicksort with just 4line in haskell i'm ruining the hour in c++ :D
11:34:03 <Jafet> It does not happen with ghci.
11:34:18 <c_wraith> hamid: don't worry, the 4-line version in haskell doesn't actually perform very well. :)
11:34:48 <Jafet> hamid: some people argue that the list program is so slow, it shouldn't really be called quicksort.
11:35:00 <tibbe> efie: the first table is old, see the second blog post
11:35:04 <c_wraith> hamid: but that's more an issue with immutable linked lists being a horrible structure to sort with a quicksort-like algorithm
11:35:12 <tibbe> efie: unordered-containers is likely to be faster than IntMap, even for Int keys.
11:35:21 <Jafet> I wonder how runghc is different from ghci then. I thought they were the same thing.
11:35:25 <c_wraith> quicksort is designed for mutable arrays, where the things it does actually make sense
11:35:25 <t3o> hi, I've got a problem on tryhaskell.org in step26. I cannot reach step27 ?
11:35:28 <yitz> tibbe: jeff_s1 is asking about space
11:35:41 <monochrom> depending on your philosophy, you could say "quicksort includes in-place mutation"
11:35:45 <tibbe> yitz: sorry, I'm only half paying attention to IRC
11:35:49 <Jafet> And presumably no one knows about this problem because no one actually uses runghc
11:35:53 <yitz> tibbe: understood :)
11:36:03 <hamid> c_wraith, so what usually is effective in haskell?
11:36:12 <efie> yes, space is more important for me than speed
11:36:24 <tibbe> efie: if you really don't care about the keys (i.e. they're not held on to by any other part of the program), then yes an IntMap will use less memory.
11:36:30 <hamid> Jafet, i'm using std::list. same performance issue kinda
11:36:31 <c_wraith> hamid: well, Data.List.sort is a bottom-up merge sort.
11:36:47 <tibbe> efie: but if you hash and insert only Int keys in an IntMap, how do you deal with collisions?
11:40:42 <t3o> test
11:40:43 * hackagebot classify 2012.10.23 - Library for classification of media files.  http://hackage.haskell.org/package/classify-2012.10.23 (DavidHimmelstrup)
11:41:25 <tibbe> jeff_s1, efie: if you're interning the strings anyway, you'll still be holding on to them and thus not save any space.
11:42:23 <t3o> sorry for the test, wrong window
11:44:23 <efie> thank you, I think I will play around with HasMap and IntMap and look what fits best :)
11:44:45 <tibbe> efie: great
11:45:43 * hackagebot Semantique 0.2.0 - Command-line tool for maintaining the Semantique database.  http://hackage.haskell.org/package/Semantique-0.2.0 (DavidHimmelstrup)
11:47:53 <beaky> :t empty
11:47:54 <lambdabot>     Ambiguous occurrence `empty'
11:47:54 <lambdabot>     It could refer to either `Control.Applicative.empty', imported from Control.Applicative
11:47:54 <lambdabot>                           or `Text.Regex.Posix.empty', imported from Text.Regex.Posix at State/L.hs:55:0-22
11:50:44 * hackagebot Semantique 0.2.1 - Command-line tool for maintaining the Semantique database.  http://hackage.haskell.org/package/Semantique-0.2.1 (DavidHimmelstrup)
11:51:20 <beaky> how do I map to a Data.Seq?
11:52:08 <Kyraimion> Is ghc taking ages to compile code with lots of overloaded string literals a know bug?
11:53:10 <fmap> beaky: Data.Seq is a functor, so you can use fmap
11:53:34 <beaky> ah
11:54:04 <Kyraimion> Not only does it take ages, but the memory usage explodes as well
11:54:10 <beaky> :(
11:54:23 <beaky> how do I transform a Seq of integers into a string?
11:55:59 <Kyraimion> beaky:  That depends on what exactly the string is supposed to contain. show would be one way
12:04:53 <beaky> http://ideone.com/8bYGIN I've converted my turing machine to use Data.Sequence, but now it's never ending :(
12:06:07 <Cale> There's no way that's going to be as fast as the list version.
12:07:21 <beaky> I guess readTape and writeTape are not as optimal when using that tree of Lists
12:07:34 <beaky> not as optimal as the version that used Lists*
12:07:57 <Cale> beaky: Also, make the Int field strict
12:08:15 <Cale> Well, the left and right moves are not as optimal
12:09:00 <Cale> Even if extending Seq on the left or right with an element is O(1), it's more expensive than a list cons.
12:09:08 <beaky> :(
12:09:24 <beaky> I guess Data.Sequence was the wrong way to go
12:09:29 <Cale> (Nothing is simpler than a list cons)
12:09:43 <Cale> Apart from something which managed somehow to do no allocation at all
12:09:47 <Cale> which you're not going to get
12:10:23 <beaky> right
12:10:33 <beaky> even my C version allocates on the fly :D
12:12:05 <Cale> Oh, I know, just compute BB(n) and then allocate that much space at the beginning! Easy! ;)
12:12:44 <ezyang> "Haha, 'compute BB(n_'"
12:12:51 <beaky> valgrind says the haskell version needs 59000 byts
12:14:13 <beaky> I tried that in the C version and it didn't speed up that much :(
12:19:15 <beaky> all problems can be solved with an extra layer of inderection
12:19:39 <gentleben> lens doesn't have anything for building the instances other than TH does it?
12:21:48 <fmap> gentleben: what instances?
12:23:10 <clahey> beaky: Did you make a C++ version?
12:26:32 <mcstar> the men just finished builing our new fireplace
12:26:38 <beaky> clahey: not yet
12:26:51 <beaky> clahey: I'll start now ^_^ and make extensive use of C++11
12:27:25 <appamatto> How is Haskell on Solaris?
12:27:31 <mcstar> oh, what would you use specifically from the new standard?
12:27:37 <mcstar> beaky: ^
12:27:40 <gentleben> fmap: equivilent to what is generated by Control.Lens.TH but specifically I would like support for constraint kinds
12:27:47 <gentleben> which TH does not have
12:27:51 <beaky> I would use lambdas ^_^
12:27:56 <mcstar> why?
12:28:04 <beaky> lambdas are fun :D
12:28:10 <mcstar> lol, i see no place for lambdas at all in that code
12:28:20 <beaky> true
12:28:20 <mcstar> not even in haskell...
12:30:54 <mcstar> beaky: can you give me the url to a list based version?
12:31:05 <mcstar> im toying with the idea of writing a mutable version out of it
12:31:34 <beaky> http://ideone.com/28mSfu
12:31:52 <mcstar> now that i said that, 70 expert haskell hackers will finish before me
12:32:06 <beaky> lol
12:38:25 <mcstar> "Turing imagines not a mechanism, but a person whom he calls the "computer""
12:38:38 <mcstar> what a misnomer
12:44:01 <mcstar> beaky: ok, so the machine is in a given state A.., and the tape can have 0 or 1 in each cell, the transition rule says, what the to write in the current cell on the tape, and in which direction wind the tape, and what will be the next state of the machine?
12:44:16 <mcstar> -the
12:44:40 <mcstar> write -> wind, and change state
12:45:53 <beaky> right
12:45:58 <mcstar> so, the machine needs to have a memory of the whole tape it ever reached
12:46:03 <beaky> :D
12:46:09 <mcstar> kind of obvious
12:46:17 <mcstar> just thinking out loud
12:47:00 <mcstar> and dont laugh, this is the first turing machine i see
13:08:01 <tromp> you've never seen brainfuck?
13:09:38 <uniquenick> is it possible to add a derived instance to a data type I am importing from somewhere else?
13:09:53 <byorgey> uniquenick: yes, using the StandaloneDeriving extension
13:10:11 <byorgey> deriving instance SomeClass SomeType
13:10:45 * hackagebot tuple-hlist 0.1.0.3 - Functions to convert between tuples and HLists.  http://hackage.haskell.org/package/tuple-hlist-0.1.0.3 (NicolasDudebout)
13:20:46 * hackagebot tuple-hlist 0.1.0.4 - Functions to convert between tuples and HLists.  http://hackage.haskell.org/package/tuple-hlist-0.1.0.4 (NicolasDudebout)
13:27:46 <unlink> What's the best way to mix pure and monadic functions in a series of combinators? I would like to do  f >>= g >>> h >>> i >>= j >>= k
13:27:58 <unlink> But that has fixity ambiguity issues.
13:28:25 <dmwit> k =<< j =<< i . h . g =<< f
13:29:15 <akamaus> is there an easy way to swap two values in a data type  using fclabels?
13:30:23 <preyalone> Can someone help me look through the hsparql docs for how to specify a language literal in SPARQL queries?
13:32:02 <dmwit> Looking in the 0.1.4 documentation, Database.HSparql.Connection.BindingValue has a LangLiteral constructor. Perhaps that's relevant?
13:32:45 <preyalone> dmwit: Perhaps. I've tried using this constructor, but when I do, my hsparql query code no longer compiles.
13:32:56 <preyalone> dmwit: It's as if hsparql only accepts plain literal queries.
13:33:07 <mcstar> i dont even have vector installed :(
13:35:17 <preyalone> dmwit: Ah, none of the hsparql maintainers ever did add syntax for lang literals. https://github.com/cordawyn/hsparql/issues/2
13:35:31 <preyalone> Hopefully this will work on my machine when I test it later.
13:35:46 * hackagebot tuple-hlist 0.1.0.5 - Functions to convert between tuples and HLists.  http://hackage.haskell.org/package/tuple-hlist-0.1.0.5 (NicolasDudebout)
13:37:30 <unlink> dmwit: That's cute. I like it.
13:39:51 <mcstar> Not in scope: `!='
13:40:25 <mcstar> also, now i understand why ski chose his quotation style `something'
13:42:51 <Saizan> it comes from latex
13:42:55 <FireFly> the `' quotes have been used for a long while
13:43:54 <mcstar> ive neve seen them used before
13:44:25 <mcstar> not even in latex, what do you mean they come from latex?
13:45:02 <rwbarton> that is how you write open/close single quotes in latex
13:45:22 <mcstar> i guess i never had to write it
13:45:25 <FireFly> ``foo'' would render as “foo”
13:45:37 <mcstar> i see, thanks
13:45:39 <FireFly> I think I've seen it in places like manpages too
13:54:48 <clahey> Is there a standard operator for  flip (.)  ?
13:55:19 <shachaf> Control.Arrow has (>>>)
13:55:36 <shachaf> Sorry, Control.Category these days.
13:55:55 <shachaf> (Category is a much more honest type class than Arrow.)
14:00:12 <djahandarie> Hmm. My long-running Haskell process has '18.3g' memory usage under the VIRT column, but '13m' under the RES column.
14:00:42 <djahandarie> What in the world would have caused that to happen? If it was a memory leak, I imagine that memory would still be reserved.
14:00:44 <beaky> writing a turing machine in Haskell was easier than I thought ^^ easier than even the python or C++ version
14:01:00 <dmwit> Doesn't RES stand for "resident" not "reserved"?
14:01:28 <djahandarie> Yeah, sorry.
14:03:01 <shachaf> djahandarie: Why would it be resident?
14:03:35 <dmwit> So, yeah, a memory leak that lasted a long time and finally got plugged or something?
14:04:00 <merijn> djahandarie: Isn't virt the amount of address space claimed, rather than actual memory used?
14:04:12 <dmwit> yes
14:04:14 <djahandarie> shachaf, why would it not be resident? A memory leak means that something is actually eating up all that memory.
14:04:16 <djahandarie> And yeah.
14:04:39 <djahandarie> I just added some more columns to top, it has '18g' under DATA, and '18g' under SWAP.
14:04:41 <merijn> djahandarie: Why care about how much it uses then? virtual address space is cheap
14:04:46 <shachaf> djahandarie: Well, it doesn't mean that the memory is being "used". It could've been used and then paged out.
14:05:10 <merijn> shachaf: If it's address space claimed it doesn't even have to be live (i.e. swapped) anymoe
14:05:13 <dmwit> merijn: Well, it does mean that at some point the process probably topped out at around 18G of actual needs, no?
14:05:22 <shachaf> Or it could've been allocated and never used in the first place (which might suggest another kind of bug).
14:05:28 <shachaf> dmwit: Not necessarily.
14:05:43 <dmwit> oh?
14:05:48 <shachaf> dmwit: E.g. some VMs just allocate a huge amount of memory once and then don't use most of it.
14:05:54 <merijn> dmwit: Not necessarily, if you continuosly using and freeing consecutively bigger address space you can't reuse previously freed values
14:06:02 <shachaf> Address space is cheap(er than RAM). :-)
14:06:41 <merijn> dmwit: I've written code that exhausted a 32bit address space without ever going over a few hundred mb actual memory usage
14:07:07 <shapr> I get exhausted just thinking about that.
14:07:10 <merijn> dmwit: Once you mess around with mmap or sbrk actual memory usage and address space usage are wildly incongruent
14:07:16 <djahandarie> This just doesn't seem right to me. What would result in a lot of address space being allocated without actual memory usage aside from a memory leak, in a Haskell program?
14:07:48 <shachaf> djahandarie: It could be a bug in some library like ByteString that mallocs a very large chunk of memory.
14:08:09 <shachaf> (I had a few of those when I was messing with Data.Text.)
14:08:10 <merijn> djahandarie: Lots of things, I'm not sure how the GHC RTS handles memory allocation, but most malloc when they run out will sbrk/mmap large chunks of address space without necessarily using them
14:08:38 <pauser> hi, could you please help me telling me why this error show up http://pastebin.com/9KnwZJuM
14:08:41 <mauke> The paste 9KnwZJuM has been copied to http://hpaste.org/76668
14:08:41 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
14:09:13 <merijn> If you hit a weird edge case I can see consecutive allocations and frees where the interleaving and increasing size never allow reusing previous allocations (resulting in continuous sbrk'ing for more address space) while never consuming more than hundreds of megabytes of memory
14:09:44 <merijn> djahandarie: Many malloc implementations never return address space after claiming it, I can imagine the haskell runtime doing the same
14:09:50 <shachaf> Yes, there are many non-"bug" situation that could result in that behavior.
14:10:35 <djahandarie> Hmm.
14:10:46 <merijn> djahandarie: How much RAM does your system have?
14:10:47 * hackagebot sandi 0.1 - Data encoding library  http://hackage.haskell.org/package/sandi-0.1 (MagnusTherning)
14:10:48 <mcstar> beaky: i think i got it
14:10:57 <mcstar> have to check it though
14:11:02 <thoughtpolice> GHC maps the space for the heap via mmap() iirc
14:11:09 <djahandarie> merijn, 10GB. 6GB of swap.
14:11:32 <shachaf> But Linux normally allows overcommitting.
14:11:35 <mcstar> beaky: ah, your nick was monad_magician
14:11:45 <mauke> @messages
14:11:45 <lambdabot> rwbarton said 1m 7d 21h 26m 16s ago: welcome back!
14:12:01 <shachaf> rwbarton++
14:12:16 <merijn> djahandarie: If your program manages to get >18g with 13m RES without any ill effect on the system I wouldn't worry so much
14:12:33 <merijn> djahandarie: Although you could profile to see what's going on
14:12:56 <merijn> (Also, wth? 10 GB + 6GB swap?! My desktop still only has 2GB and my laptop 4GB...)
14:12:59 <djahandarie> It'd be hard. This daemon has been running for months.
14:13:08 <djahandarie> It's a server.
14:13:16 <djahandarie> The server itself has more memory, this is a VM
14:13:20 <djahandarie> I forget to be honest :P
14:13:24 <djahandarie> I think it's 16GB
14:13:32 <merijn> djahandarie: Oh, then I find it even less worrisome
14:13:45 <merijn> (process running for months)
14:13:57 <shachaf> djahandarie: Is the VIRT going up?
14:14:09 <djahandarie> How do I get a more granular view of VIRT?
14:14:14 <djahandarie> Than what top gives me.
14:14:50 <djahandarie> Ah, ps probably has it.
14:15:42 <shachaf> /proc/pid/status
14:15:44 <djahandarie> shachaf, yes, looks like it. By like 4 bytes a second.
14:16:00 <djahandarie> RSS is not changing at all.
14:16:05 <shachaf> djahandarie: OK, that's maybe a little more worrying...
14:16:11 <shachaf> 4 bytes a second is weird.
14:16:33 <shachaf> Are you sure ps is showing  bytes?
14:16:47 <shachaf> I would assume that you'd see it in units of 4 kilobytes.
14:16:55 <djahandarie> Err, yeah, you're right, kilobytes.
14:17:24 <shachaf> So it's mapping a new page every second?
14:17:25 <djahandarie> Off by a factor of 1000, more or less right.
14:18:19 <djahandarie> Yeah, I guess. I do spawn a linux process every second or so, maybe that's related.
14:18:39 <shachaf> Maybe strace it for a bit?
14:18:46 <djahandarie> Yeah, I'll give that a shot.
14:19:04 <shachaf> By the way, if you use htop instead of top, it has all sorts of fancy features.
14:21:50 <mcstar> hehe, 23% productivity
14:21:59 <pauser> why is this false ?
14:21:59 <pauser> stretch :: Char -> Integer -> String -> String
14:21:59 <pauser> stretch c i (x:rs)
14:21:59 <pauser> 	| c == x = take (fromIntegral i)(repeat c) : if(rs == []) then ([]) else stretch c i rs
14:21:59 <pauser> 	| c /= x = x : if(rs == []) then [] else stretch c i rs
14:21:59 <pauser> error: *** Type           : Char -> Integer -> String -> a -> [Char]
14:21:59 <pauser> *** Does not match : Char -> Integer -> String -> String
14:22:00 <ocharles> anyone here using projections in the 'lens' package yet?
14:22:10 <mcstar> pauser: come on!
14:22:21 <pauser> sorry for the lines
14:22:31 <djahandarie> shachaf, hmm, strace is being spammed by futex calls.
14:22:49 <djahandarie> futex(0x1367fac, FUTEX_WAIT_PRIVATE, 23, NULL) = ? ERESTARTSYS (To be restarted)
14:23:03 <shachaf> djahandarie: Lesson 1 in using strace is learning to ignore the irrelevant bits. :-)
14:23:21 <mauke> pauser: still using hugs?
14:23:22 <pauser> mcstar: hier the past, sorry for the lines http://pastebin.com/9KnwZJuM
14:23:23 <mauke> The paste 9KnwZJuM has been copied to http://hpaste.org/76668
14:23:39 <pauser> mauke: yes why ?
14:24:22 <dmwit> pauser: I can't reproduce your problem. That code loads fine here.
14:24:32 <Cale> pauser: you're using stretch incorrectly
14:24:40 <Cale> pauser: somewhere else in your program
14:25:09 <djahandarie> shachaf, well, right, was just wonder if that's perhaps related. The only other thing going on is..... write(6, "\377\0\0\0\0\0\0\0", 8)       = 8
14:25:18 <pauser> but hugs is telling the line 36 and thats  (| c == x = take (fromIntegral i)(repeat c) : if(rs == []) then ([]) else stretch c i rs )
14:25:20 <djahandarie> Every second or so.
14:25:51 <djahandarie> Which looks suspicious I suppose.
14:25:55 <mauke> pauser: that line is not in your paste
14:25:55 <shachaf> djahandarie: Well, neither strace nor futex() should be allocating memory.
14:26:06 <shachaf> Maybe the program has multiple OS threads and you're not looking at the right one?
14:26:16 <djahandarie> You mean write() nor futex() ?
14:26:22 <shachaf> Er, yes.
14:26:35 <shachaf> (What's fd 8, anyway?)
14:28:06 <pauser> http://paste.ubuntu.com/1301245/ and the error http://paste.ubuntu.com/1301248/
14:28:27 <djahandarie> shachaf, 8 -> socket:[2166455641]
14:28:55 <shachaf> djahandarie: What about the thread thing? :-)
14:29:25 <dmwit> pauser: You probably meant (++) instead of (:) on line 36.
14:30:32 <dmwit> ...but the errors you posted *still* don't match with the file you posted.
14:30:44 <dmwit> Are you definitely hitting "save" in your text editor?
14:30:52 <pauser> dmwit: where ?
14:31:04 <djahandarie> shachaf, yeah, looks like there are quite a few other threads, I'll look through them
14:31:11 <mcstar> File->Save
14:31:38 <dmwit> pauser: Can you flesh that question out to a complete sentence?
14:31:55 <shapr> This is where I wish I had all the bugs worked out of ghclive
14:32:04 <shapr> Cause it would be perfect.
14:32:26 <mcstar> that follows from the definition of 'no bugs'
14:32:57 <ciaranm> no bugs is necessary but not sufficient for perfection
14:33:08 <JuanDaugherty> ghclive?
14:33:13 <shapr> I mean ghclive would be perfect for across-the-web teaching of Haskell.
14:33:18 <shapr> That was what I designed it for, at least.
14:33:37 <shapr> JuanDaugherty: http://ghclive.wordpress.com/
14:33:59 <shapr> Oh hey, I'm giving a talk on ghclive at the Mid-SouthEast ACM Conference in November!
14:34:10 * JuanDaugherty doesn't see the point of another thing like that.
14:34:30 <shapr> JuanDaugherty: I would explain it, but I have to finish my homework instead.
14:34:41 <shapr> JuanDaugherty: But I would love to hear which tools you know of that already handle that.
14:35:28 <JuanDaugherty> nm, I'm not the typical audience you're addressing. My opinions would be noise for you.
14:35:38 <shapr> JuanDaugherty: I'm interested in any feedback actually.
14:36:34 <beaky> a
14:36:36 <shapr> b
14:36:41 <shapr> beaky: No?
14:36:47 <pauser> i've found the problem. is was the geany editor sucked all this thing. thank you all :D
14:37:13 <mcstar> sure, np
14:37:13 * dmwit high fives himself
14:37:19 * shapr high fives dmwit
14:37:30 * dmwit goes for a high five with shapr and misses slightly
14:37:33 <dmwit> aaaaawkward
14:37:34 <shapr> haha
14:37:54 <shapr> Aw, I wanted to hear what JuanDaugherty had to say :-(
14:38:54 <dmwit> I conclude he was bluffing.
14:38:56 <shapr> but I should go finish writing my Dynamic Scope CRETs
14:38:59 <shapr> dmwit: Perhaps, I dunno.
14:39:10 <dmwit> g'luck
14:39:36 <djahandarie> shachaf, well, there's a lot of shit going on. Nothing terribly suspicious though.
14:39:58 <shachaf> djahandarie: mmap()/sbrk() calls?
14:40:42 <djahandarie> Nope.
14:41:42 <shachaf> Well, it has to be allocating that memory somehow...
14:42:21 <mcstar> was recursive IO regressed in 7.6.x ???
14:42:35 <djahandarie> shachaf, think any of the epoll_* calls could be responsible?
14:42:41 <shachaf> djahandarie: No.
14:43:34 <djahandarie> How about vfork. That sound suspcious.
14:43:52 <shachaf> Uh, maybe?
14:44:01 <shachaf> strace -f will tell you what's happening to the forked process.
14:44:05 <shachaf> It doesn't sound too likely.
14:45:49 <djahandarie> Well, there are mmaps in the forked process, but the forked process is a C program.
14:46:50 <shachaf> That shouldn't be accounted for in the process's address space, and at any rate I assume the forked process is exiting pretty soon.
14:47:01 <djahandarie> Yeah, they exit after a few seconds.
14:47:31 <djahandarie> I call them with forkIO . readProcessWithExitCode, essentially.
14:47:58 * shachaf has the feeling djahandarie isn't seeing everything.
14:48:04 <shachaf> VIRT is still steadily increasing?
14:48:36 <shachaf> It should be increasing at >300MB a day if what you said is correct.
14:50:46 <djahandarie> shachaf, yes, it increases proportionally to the number of vforks.
14:50:54 <djahandarie> (Not that that means it's due to the vforks.)
14:51:16 <mcstar> horrible >> http://i.imgur.com/yZQTG.png
14:52:32 <djahandarie> I essentially fork one of these processes for every valid line of input I read, so there is a lot going on, but it seems it's 4 bytes for every valid line.
14:53:06 <djahandarie> (The timing of the 4 byte increase matches exactly with when a valid line is read.)
14:53:08 <shachaf> Kilobytes.
14:53:14 <djahandarie> God damn it.
14:54:58 <mcstar> lol
14:55:00 <mcstar> wtf
14:55:09 <mcstar> n + 1 why isnt it strict/?
14:55:32 <shachaf> Because it's not a function!
14:55:38 <mcstar> that previous profiling was cause of a n + 1 in a tail recursive monadic action
14:55:51 <mcstar> but i thought + was strict
14:56:19 <shachaf> It normally is.
14:56:40 <mcstar> what does that mean?
14:56:44 <mcstar> when is it not?
14:56:47 <parcs`> + is overloaded
14:56:55 <mcstar> overcooked
14:56:57 <mcstar> f
14:56:58 <parcs`> you can make a non-strict Num instance
14:57:13 <mcstar> i get it
14:57:17 <mcstar> it is Integer not Int
14:57:23 <mcstar> and it isnt strict for Integer
14:57:28 <int-e> mcstar: yes it is
14:57:28 <mcstar> nice trap, thak you
14:57:55 <mcstar> then?
14:58:08 <parcs`> then ghc is stupid and you should help it out with a couple of seqs
14:58:34 <djahandarie> shachaf, I wonder if it's the exit statuses of the forked processes that are piling up in memory.
14:58:38 <int-e> mcstar: that's not the point - the point is that the strictness of + doesn't really matter. If the compiler sees an expression n + 1, but cannot prove that this will be evaluated, then the resulting code will usually create a thunk for it, representing the unevaluated expression n+1.
14:58:52 <shachaf> djahandarie: Maybe?
14:59:07 <shachaf> djahandarie: Are you not waiting on the processes or something?
14:59:09 <mcstar> int-e: it is printed at the end of a long recursion, it is a counter
14:59:12 <shachaf> Not that that would cause that.
14:59:17 <mcstar> anyway, im gonna paste the code for beaky
15:00:42 <mcstar> http://sprunge.us/KjBd?haskell -- beaky
15:00:45 <int-e> mcstar: apparently it's not obvious enough. better help out ghc by using `seq` (or its friend, $! -- e.g. return $! n+1 rather than return (n+1))
15:00:58 <mcstar> it not like that
15:01:16 <mcstar> run ... n = .... run ... (n+1)
15:01:37 <int-e> mcstar: note: the fact that the result is used is not quite enough. if 'n' could - as far a the compiler can make out - be bottom (undefined), then evaluating n+1 early is also wrong.
15:02:03 <mcstar> hm
15:02:19 <mcstar> but if it was once bottom it will always be bottom
15:02:25 <mcstar> so that doesnt count for arithmetic
15:02:32 <mcstar> + is not a list constrctor
15:04:17 <merijn> djahandarie: Are you maybe spawning pipes to interact with the forked child and not cleaning them up?
15:05:04 <int-e> mcstar: the easiest way may be to enable the BangPatterns extension and change that to run ... !n =
15:05:17 <mcstar> yeah, right
15:05:32 <shachaf> Or ... run ... $! (n+1)
15:05:33 <merijn> So many sexual jokes run through my mind when I hear BangPatterns...
15:05:38 <djahandarie> merijn, every pipe([x, y]) is followed by some closes, though it's hard to tell if every single thing is getting closed or not.
15:05:40 <mcstar> it is alraedy enables, as you can see
15:05:53 <mcstar> i just put it everywhere in my big confusion
15:06:00 <mcstar> before i did that profiling
15:06:16 <mcstar> except at !n, since i was 'convinced' thats not a problem
15:06:17 <int-e> merijn: keep in mind that Haskell is a pure language. So it's all happening in your mind alone.
15:06:32 <mcstar> merijn: see? remember it!
15:07:32 <merijn> djahandarie: Probably not it anyway, if you're spawning many processes and it's been running for months...
15:07:40 <merijn> djahandarie: You'd have run out of filedescriptors
15:07:45 <mcstar> Productivity  98.5%, thats pretty neat
15:08:18 <djahandarie> merijn, there is more or less a constant amount of fds in /proc/pid/fd
15:09:18 <merijn> Time to switch to an OS supporting DTrace so you can debug in production ;)
15:12:13 <djahandarie> With grep -v -e "futex\|rt_sig\|SIGVTALRM\|read\|write\|sendto\|getrusage\|epoll\|recvfrom\|fcntl\|ioctl\|settime", there is absolutely nothing but vfork, pipe, close, wait4 going on.
15:12:31 <djahandarie> And I don't think any of those grep'd out functions would cause trouble.
15:12:59 <djahandarie> So I'm pinning the blame on vfork doing something which isn't getting freed properly.
15:14:10 <mcstar> another joke, im using Data.Vector, i get .8s for something, change read/write to unsafeRead/unsafeWrite, get 1.24s
15:15:35 <mcstar> yeah, unsafeWrite takes more time than write
15:16:00 <shachaf> Sounds like some fusion thing?
15:16:17 <mcstar> shachaf: you can look at the code if you want
15:16:24 <mcstar> let me relink
15:16:27 <mcstar> http://sprunge.us/KjBd?haskell
15:16:51 <mcstar> turnTheWheel
15:29:38 <djahandarie> shachaf, I think I'll just open a bug on the GHC bug tracker and make them figure it out for me.
15:30:01 <shachaf> djahandarie: Isn't the bug in your code?
15:30:35 <djahandarie> I'm replicating it with some much smaller code.
15:30:45 <djahandarie> I'll trim it down more then run it by you before posting it there.
15:31:09 <shachaf> Fair enough.
15:34:31 <merijn> djahandarie: Wait...
15:34:35 <merijn> djahandarie: vfork?
15:34:44 <djahandarie> Yes.
15:35:00 <djahandarie> I'm honestly not sure why GHC is using vfork. Sounds dangerous.
15:35:22 <merijn> djahandarie: Not really, but vfork is a prime suspect of address space abuse
15:36:03 <merijn> iirc it forks and copies the entire address space of the source program, but doesn't actually copy memory until it is written to (i.e. COW copying of the entire address space)
15:36:34 <shachaf> merijn: Well, just like fork()?
15:36:39 <merijn> I'm not sure on the exact details, but weird VIRT values and vfork are likely correlated
15:36:53 <merijn> shachaf: Not necessarily
15:37:26 <mauke> IIRC vfork doesn't copy
15:37:40 <merijn> There's usually multiple fork like calls, which one fork calls depends on your OS
15:37:50 <merijn> mauke: Isn't that what I said?
15:38:02 <shachaf> merijn: Well, strace should be telling you what the actual syscall being made is.
15:38:12 <mauke> you said "... until it is written to", implying that vfork does copy
15:39:07 <merijn> mauke: Eventually, I thought but according to the manpage not even that
15:39:17 <merijn> mauke: I'm confusing it with one of the other forks, I think
15:39:25 <mauke> unsafePerformFork
15:39:41 <merijn> djahandarie: Basically, your spawned of processes use the same address space as the parent
15:39:59 <merijn> djahandarie: When they exit the memory is available again but the address space remains in use
15:40:23 <merijn> That seems the most likely explanation
15:40:27 <djahandarie> And no one considers that to be an issue?
15:40:39 <djahandarie> Seems like it'd be a massive issue if I was forking thousands of processes a second.
15:40:54 <merijn> djahandarie: Why?
15:41:08 <merijn> Address space is cheap, on 64bit it's ridiculously cheaper
15:41:17 <djahandarie> Eventually you'd run out of address space, wouldn't you?
15:41:53 <merijn> You can reuse it if you run out, presumably the GHC runtime keeps track
15:42:08 <merijn> There's no reason to reuse sooner, so why bother?
15:42:09 <shachaf> merijn: ?
15:42:20 <koala_man> merijn: surely they don't share address space. the address space layout is copied (but not the allocated pages). the parent can then modify anything it wants
15:42:21 <sfogarty> I always forget: where might I paste code I was looking for advice on?
15:42:31 <mcstar> pastebin.com
15:42:37 <sfogarty> Thanks
15:42:42 <beaky> besides a Turing Machine, what's another interesting project that's simple to implement in Haskell as a learning exercise?  ^_^
15:42:51 <mcstar> sfogarty: hpaste.org
15:42:53 <beaky> the classic Banking example?
15:42:56 <merijn> koala_man: I don't remember the exact details of the implementation
15:42:58 <mauke> mcstar: never pastebin.com
15:42:59 <mcstar> beaky: did you check my code?
15:43:43 <beaky> http://sprunge.us/KjBd?haskell
15:43:45 <beaky> http://sprunge.us/KjBd?haskell
15:43:51 <mcstar> yeah
15:43:53 <beaky> oops
15:43:57 <mcstar> i know, i pasted it
15:44:11 <hpaste> “Seth Fogarty” pasted “Ugly recursive let interpretation” at http://hpaste.org/76669
15:45:01 <sfogarty> So I am assigning recursive let binding in an interpreter (see above). My evaluation functions return a Maybe type. This creates ugliness when I do recursive let, because I have to pattern match on Just val. Is there a better way?
15:45:16 <merijn> anyhoo, bed time
15:45:49 <beaky> it's faster than C :D
15:46:01 <mcstar> beaky: really?
15:46:11 <mcstar> both compiled optimized?
15:46:20 <mcstar> beaky: can you quote timings?
15:46:47 <mcstar> beaky: if you set a large enough chunk size ~10K it will not use the zipper structure
15:46:56 <mcstar> not that it was costly...
15:47:01 <beaky> ./tmvector  0.16s user 0.04s system 81% cpu 0.251 total
15:47:19 <beaky> ./ctm 5  0.06s user 0.00s system 67% cpu 0.094 total -- C version
15:47:38 <sfogarty> Both of those times are so low as to be meaningless, no?
15:47:40 <mcstar> heh, so why is it faster then?
15:47:46 <mcstar> sfogarty: no
15:48:00 <sfogarty> 0.16s? That could be garbage collector startup time
15:48:22 <mcstar> that can be, but the number itself is not too small
15:48:27 <mcstar> and if its stable...
15:48:45 <mcstar> anyway, yeah, i always forget, ghc runtime has some startup overhead
15:49:13 <sfogarty> IMO, it'd be more interesting if you had an example that took at least 30 seconds
15:49:38 <beaky> let it compute bb 5 100 times :D
15:50:04 <mcstar> beaky: why did you say haskell was faster?
15:52:51 <mcstar> Productivity  99.9%
15:54:23 <mcstar> 6.18s for 10 runs
15:54:51 <mcstar> so thats 0.62 for one, i got 0.67 before, when running only once
15:55:02 <mcstar> 0.05s the difference sfogarty
15:56:06 <sfogarty> Beware clever memoization too. I don't think haskell does it, but I know languages that will (smv)
15:56:34 <mcstar> no, all replicateM_'s took the same time, approximately
15:57:38 <edo507> hi
15:58:18 <ksf> using haskell to out-C C is kinda misguided.
15:58:59 <ksf> if you really need a tight loop just drop to C, otherwise abuse the hell out of abstractions, as that's going to improve those 99.9% of your code that aren't tight-loop critical.
15:59:08 <mcstar> ksf: beaky was restless, he couldnt sleep, or go to work, until the haskell version runs close to the C one
15:59:17 <sfogarty> premature optimization is the root of all evil :)
15:59:18 <mcstar> thats why i wrote a mutable version of his code
15:59:25 <sfogarty> aha. fromMaybe to the recue.
15:59:26 <sfogarty> rescue.
16:02:26 <hpaste> mcstar pasted “beaky” at http://hpaste.org/76671
16:02:58 <mcstar> well, thats all i could do
16:03:16 <mcstar> excuse my unnecessary !s
16:04:22 <ksf> mcstar, while your'e at it, in fiveStateBusyBeaver, do (s `shiftL` v) and match on the result.
16:04:40 <ksf> in general, your code still is way too readable.
16:05:17 <mcstar> ksf: thanks for your kind words
16:06:13 <ksf> oh, and I guess you need to shift by more than one, so shiftL v by three, first.
16:06:24 <beaky> I guess I should just accept that it's alright for Haskell to be twice as slow as C :(
16:07:17 <mcstar> v * 10 + s will do it
16:07:18 <ksf> the good news is that it doesn't (necessarily) become slower as you add abstractions, unlike C/C++
16:07:39 <Iceland_jack> beaky: Is there anything you need to be just as faster or are you just playing the speed game?
16:07:46 <Iceland_jack> s/er//
16:07:59 <mcstar> speed game
16:08:03 <mcstar> what else
16:08:32 <beaky> yes
16:08:48 <Iceland_jack> The accepting-that-you're-not-using-C game :)
16:09:07 <sfogarty> if you are only twice as slow, who cares :)
16:09:27 <Iceland_jack> Exactly
16:10:27 <mcstar> maybe mod takes too much time
16:10:40 <sfogarty> Now, for my pet PSPACE problems, haskell is, oh.... exponentially slower. That's when I'm sad.
16:10:41 <mcstar> now would be a good time to use callgrind
16:12:36 <beaky> so optimization in Haskell is all about using smart-enough abstractions for a sufficiently-smart compiler to optimize?
16:14:59 <mcstar> well, you can inspect the core, or write almost c in haskell
16:15:16 <mcstar> but you are a beginner, and shouldnt think about those at this time
16:15:25 <mcstar> (im am one too)
16:17:47 <mcstar> 18% for the mod
16:18:26 <mcstar> and 80% for an stg_ap_0_fast'2 call
16:18:35 <mcstar> not that fast apparently
16:19:33 <mcstar> i wonder what these mean
16:19:50 <bgamari> stg_ap is function application I believe
16:19:50 <lispy> You know you're a hardcore haskell user when your shell is ghci and your ~/.ghci loads this module by default: http://hackage.haskell.org/package/shelly
16:19:51 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
16:19:56 <lispy> lambdabot: hi!
16:20:30 <shachaf> lispy: That sounds terrible.
16:20:44 <shachaf> I do have a keybinding to open a terminal with ghci, as well as one with a shell.
16:21:02 <mcstar> thats usual for tiling wm users
16:21:12 <mcstar> which you are shachaf, arent you?
16:21:16 <shachaf> Nope.
16:21:43 <mcstar> well, i had super+t for konsole even on kde
16:22:07 <gentleben> has anyone built Plated instances for a GADT?
16:22:08 <mcstar> i just supposed you hardcore guys all use xmonad
16:22:14 <lispy> ivanm: Without seeing your code I can't really comment. Maybe?
16:22:21 <lispy> gentleben: Plated?
16:22:34 <ivanm> lispy: heh
16:22:36 <lispy> mcstar: xmonad no-worky on the mac
16:22:53 * lispy uses a mac except when he doesn't
16:23:10 <mcstar> do you by any change know, what platform does SPJ develop on?
16:23:13 * lispy gives tautological answers some of the time
16:23:16 <mcstar> im just curious
16:23:19 <gentleben> lispy: from the lense library. its a replacment/generalization of uniplate
16:23:26 <lispy> mcstar: I would guess OSX but I don't know that.
16:23:33 <gentleben> at least the plated part
16:23:36 <lispy> mcstar: ICFP tends to have many macs
16:23:50 <mcstar> doesnt he work for MS?
16:23:58 <lispy> gentleben: wasn't uniplate the simplification of something that was too general?
16:24:18 <lispy> mcstar: yes, but so do lots of people that use macs in their day job :)
16:24:18 <mcstar> well, MSR
16:24:38 <mcstar> lispy: you mentioned ICFP, thats why i asked MS
16:24:46 <lispy> ah
16:24:54 <lispy> SPJ works at MSR in the UK
16:25:07 <gentleben> lispy: no. it is very useful for AST rewriting which is what I am trying to do
16:25:08 <mcstar> yeah, where he regularly unicycles
16:25:44 <lispy> gentleben: neat
16:26:13 <lispy> gentleben: this is why I want a fortran parser/AST in Haskell. Being able to perform source to source transformations in Haskell would be nice
16:26:43 <sleepster> are there any huge projects that use haskell?
16:26:47 <gentleben> lispy: yeah. this is over my own AST which is a GADT
16:26:59 <sleepster> it seems like such a cool language and it has been around for a long time so I'd assume there'd be at least one
16:27:11 <mcstar> there is my asteroids game...
16:27:14 <lispy> gentleben: higher-order abstract syntax tree, by any chance?
16:27:32 <gentleben> sleepster: whats huge? We have ~100K lines of human written. Plus a lot of generated
16:27:41 <lispy> sleepster: darcs is one of the larger open source Haskell projects. GHC is even larger.
16:28:05 <gentleben> lispy: I guess it could be called higher order. It describes and execution plan
16:28:16 <sleepster> I see. so there isn't any well-known commericial projects huh?
16:28:30 <mcstar> niki and the robots
16:28:33 <Cale> sleepster: There are many not-so-well-known large commercial projects
16:28:51 <lispy> gentleben: I guess I don't know what that means. I asked because often when someone does GADT representation of an AST they make it into a HOAS
16:29:04 <Cale> i.e. private ones
16:29:04 <sleepster> I gotcha.. thanks
16:29:07 <lispy> sleepster: cryptol
16:29:20 <lispy> sleepster: https://en.wikipedia.org/wiki/Cryptol
16:29:31 <sleepster> thanks lispy
16:30:05 <mcstar> ah, what about hardware verifiers?
16:30:13 <lispy> lava?
16:30:16 <mcstar> and how long could agda be?
16:30:16 <Kyraimion> lispy:  I don't know how X11 works on OSX, but apparently you can run xmonad on it
16:30:40 <lispy> Kyraimion: But if you do that, xmonad only has dominion over things that run in the X server.
16:30:49 <lispy> Kyraimion: For me that is the empty set.
16:31:09 <cmccann> yes, but you'd be able to tile those non-windows like a boss
16:31:38 <lispy> It has the following benefits: <insert vacuously true statements>
16:31:54 <mcstar> osx doesnt need tiling
16:32:10 <lispy> I run full screen terminals that have tmux inside them
16:32:13 <mcstar> you press command+whatever and you see your windows
16:32:15 <lispy> That's my tiling WM on OSX
16:32:18 <mcstar> see all your*
16:32:29 <lispy> iterm2 to be specific
16:32:39 <Kyraimion> lispy:  I have literally never used OSX, so I have absolutely no idea how X11 is handled (nested server?), but at least xmonad does work on OSX, even if it's useless
16:32:54 <parcs`> sleepster: ghc!
16:33:05 <parcs`> also, agda
16:33:40 <gentleben> lispy: HOAS?
16:33:48 <lispy> gentleben: higher-order abstract syntax
16:34:23 <gentleben> lispy: oh, yes well GADTs are nice. They just to play friendly with all the machinery
16:34:26 <lispy> gentleben: https://en.wikipedia.org/wiki/GADT#Higher-order_abstract_syntax
16:34:30 <gentleben> *don't
16:35:20 <mcstar> i forgot how to use ghc-core
16:35:32 <mcstar> do i need to save the core before, with ghc?
16:35:34 <mcstar> i guess so
16:35:52 <lispy> mcstar: the way I've always used it is in place of ghc
16:35:56 <ben_m> Is there an extension or something that allows re-use of identifiers in patterns? Something like startsWithDouble (x:x:xs) = True
16:36:34 <lispy> ben_m: that has a name. Non-linear pattern? I don't know of any haskell extensions that allow it
16:36:47 <mcstar> lispy: doesnt it matter, that im not able to supply -O2 for ghc-core?
16:37:06 <lispy> mcstar: ghc-core -O2 Foo.hs
16:37:13 <lispy> mcstar: that should do the magic
16:37:15 <ben_m> lispy, too bad, thanks
16:37:21 <lispy> I don't have ghc-core built or I would test it
16:37:42 <mcstar> ghc-core -O2 beaky.hs
16:37:52 <mcstar> user error (unrecognized option `-O'
16:37:54 <mcstar> unrecognized option `-2'
16:37:59 <lispy> ben_m: Well, would this require an Eq constraint on x?
16:38:18 <mcstar> ah
16:38:24 <mcstar> i think i need a -- separator
16:38:25 <ben_m> I suppose
16:38:26 <lispy> ben_m: startsWithDouble (x:y:xs) = x == y -- this is something you can do right now
16:38:45 <mcstar> lispy: ghc options come after a --
16:38:51 <lispy> ben_m: and in more interesting cases you can use a guard: startsWithDouble (x:y:xs) | x == y = ...
16:38:54 <lispy> mcstar: ah!
16:38:55 <ben_m> lispy, yeah I know, it would just get rid of guards in a lot of cases :D
16:46:47 <teneen> how to run a pure function and stop it if it didn't complete in a certain time period?
16:48:44 <teneen> like what lambdabot does for example
16:49:44 <copumpkin> teneen: http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/System-Timeout.html
16:49:51 <copumpkin> you'll want to use evaluate
16:50:16 <copumpkin> @hoogle evaluate
16:50:17 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
16:50:17 <lambdabot> Control.Exception evaluate :: a -> IO a
16:50:17 <lambdabot> Control.OldException evaluate :: a -> IO a
16:53:31 <teneen> compumkin: evaluate or timeout?
16:54:21 <ivanm> teneen: evaluate just helps force evaluation
16:54:28 <ivanm> use timeout for the actual timing out :p
16:54:35 <ivanm> lambdabot uses mueval IIRC for the actual computations
16:54:39 <ivanm> as does tryhaskell.org
16:59:31 <lispy> teneen: I think he meant both. Set a timeout on evaluate.
16:59:53 <lispy> teneen: but mueval is probably a lot cleaner, esp. if you want to run untrusted code
17:00:49 <teneen> lispy: I see, thanks!
17:01:22 <lispy> teneen: you can look at the lambdabot sources too
17:01:24 <lispy> ?version
17:01:25 <lambdabot> lambdabot 4.2.2.1
17:01:25 <lambdabot> darcs get http://code.haskell.org/lambdabot
17:03:36 <teneen> lispy: mueval is a binary not a haskell library?
17:07:24 <Cale> teneen: Yeah, running the code in a separate process is a good deal cleaner, because you can have separate system limits for it.
17:13:01 <jfischoff> I want do some conditional compilation based on the version of template-haskell. Does cabal have some built in way of doing that, or do I use if impl (ghc < 7.0.3) ghc-options: -D TEMPLATE_2_5 etc. ?
17:18:22 <clahey_> So, I'm having trouble installing things because my cabal has two different versions of semigroupoids installed.  Is it possible to uninstall one of them?
17:18:31 <ezyang> You can ghc-pkg hide one
17:19:08 <danharaj> is there a common library for containers containing GADT values without wrapping them?
17:25:51 * hackagebot xml-to-json 0.1.0.0 - Simple command line tool for converting XML files to json  http://hackage.haskell.org/package/xml-to-json-0.1.0.0 (NoamLewis)
17:26:10 <sinelaw> woohoo :)
17:28:09 <clahey_> When I cabal install -p, does it install both profiled and non or just profiled?
17:28:27 <hpc> it should be both
17:28:28 <ozgura> clahey_: both.
17:30:19 <clahey_> Perhaps I should just wipe out my cabal and reinstall it all with -prof?
17:30:27 <clahey_> Rather, -p
17:32:52 <kirindave_> So has the Monatron package been totally abandoned as an approach?
17:32:57 <kirindave_> Seems like a bummer.
17:33:12 <kirindave_> it seemed a lot more workable than monad transformers.
17:36:24 <dmwit> clahey_: Yes, you should do that, but instead of -p you should just toggle the option in ~/.cabal/config.
17:48:06 <clahey_> I deleted my .cabal directory and now when I try to install it, it's really confused.
17:48:58 <hpc> also delete .ghc
17:49:34 <hpc> cabal just does compilation, ghc-pkg keeps track of what's installed
18:11:51 <sleepster> in LearnYouAHaskell, he says "Types that can act like a box can be functors"  what does that mean?
18:11:54 <sleepster> types that can act like a box
18:12:48 <hpc> sleepster: stuff that looks like "data Foo a = ..."
18:12:49 <shachaf> sleepster: It's bad intuition anyway. You can ignore it.
18:12:52 <hpc> also that
18:13:01 <kirindave_> sleepster: A common way to approach functors is to call them container types.
18:13:03 <shachaf> hpc: Huh? Plenty of things of the form data Foo a = ... aren't functors.
18:13:28 <shachaf> sleepster: What he means is that a few instances of Functor "contain" values, in some sense (most don't, though).
18:13:29 <hpc> shachaf: i assumed BONUS was refering to the kind of the type?
18:13:35 <kirindave_> sleepster: Namely, that if you have a type like "data Foo a = Foo a" then it's safe to change what foo holds.
18:13:42 <shachaf> hpc: data Foo a = Foo (a -> Bool) -- not a functor!
18:13:51 <hpc> i know :P
18:14:09 <kirindave_> sleepster: As suggested tho it's a very basic intuition.
18:14:23 <sleepster> thanks guys.. I appreciate the feedback
18:14:28 <shachaf> Funnily enough, "Set" *is* a functor, even though (-> Bool) acts a lot like a set.
18:15:44 <kirindave_> sleepster: Good luck. Haskell's functor typeclass is fairly important to grasp.
18:16:12 <sleepster> thanks kirindave_ yeah I am still trying to grasp the terminology
18:16:26 <sleepster> I am not only new to haskell but the functional programming paradigm as a whole
18:16:28 <sleepster> so everything is new
18:16:32 <sleepster> kind of exciting though...
18:16:35 <sleepster> feel like a little boy again!
18:17:11 <kirindave_> sleepster: Just to comfort you, Haskell is a level of functional programming most other langs do not go to.
18:17:45 <kirindave_> sleepster: So that confusion is probably justified. :)
18:18:02 <sleepster> :)
18:18:33 <mcstar> hehe, i almost double the speed by replacing mod with a recursive function
18:19:04 <mcstar> mod !n = if n < 0 then mod (n + chunk) else if n >= chunk then mod (n - chunk) else n
18:19:10 <mcstar> good old trick
18:19:18 <mcstar> anyway, how can i message with lambdabot?
18:19:34 <mcstar> leave a message to someone
18:20:00 <mcstar> @help message
18:20:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:20:07 <mcstar> @list
18:20:08 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:20:41 <mcstar> @help tell
18:20:41 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
18:21:17 <mcstar> @tell beaky i got an almost 2x improvement by replacing mod with: mod !n = if n < 0 then mod (n + chunk) else if n >= chunk then mod (n - chunk) else n
18:21:17 <lambdabot> Consider it noted.
18:22:46 <Girls_Escort> Porn SEx Girls http://fredfilms.blogspot.com
18:23:00 <mcstar> timely
18:24:39 <parcs`> resisting the urge to click on the totally legit link
18:25:03 <mcstar> not worth it
18:25:32 <mcstar> the clicking, not the resisting
18:30:06 <jmcarthur> mcstar: for what it's worth, rem is faster than mod
18:30:22 <jmcarthur> mcstar: at least for the primitive types
18:30:33 <mcstar> quot?
18:30:39 <jmcarthur> err, yes
18:30:41 <jmcarthur> quot
18:30:43 <mcstar> it wasnt
18:30:47 <mcstar> it is, in CL
18:30:47 <jmcarthur> no
18:30:49 <jmcarthur> rem
18:31:01 <jmcarthur> div and mod   vs.   quot and rem
18:31:12 <mcstar> heh,ok
18:31:23 <mcstar> well, i can try
18:31:25 <jmcarthur> i know for a fact that rem is faster than mod, at least for Int and Word
18:31:39 <mcstar> is it faster 100%?
18:32:08 <jmcarthur> by 100% do you mean 100% faster you do you mean faster 100% of the time?
18:32:10 <mcstar> timing went from 0.6 to 0.35
18:32:22 <mcstar> 2x increase of speed
18:32:24 <mcstar> roughly
18:32:38 <jmcarthur> ah, no, not that much faster
18:32:55 <jmcarthur> of course your recursive mod implementation is only faster for certain inputs
18:33:27 <jmcarthur> mcstar: i wrote this a while ago http://creativelad.wordpress.com/2011/04/28/euclidean-division/
18:33:59 <sinelaw> > 1/1
18:34:00 <lambdabot>   1.0
18:34:03 <mcstar> jmcarthur: the value being modded is not too large in absolute value
18:34:14 <mcstar> max 100K
18:34:38 <mcstar> jmcarthur: i didnt know you had a blog
18:34:50 <jmcarthur> it's not very well maintained
18:35:10 <jmcarthur> only 4 posts, iirc
18:35:31 <jmcarthur> old ones, at that. i've been meaning to blog more (i've *always* been meaning to, though)
18:35:32 <roconnor> is this Functor AB job for real?
18:35:41 <sinelaw> jmcarthur, cool, bookmarked for later abuse :)
18:35:52 * hackagebot gdiff-th 0.1.0.4 - Generate gdiff GADTs and Instances.  http://hackage.haskell.org/package/gdiff-th-0.1.0.4 (JonathanFischoff)
18:36:19 <jmcarthur> roconnor: it doesn't seem like something alpounet would make up
18:36:28 <sinelaw> jmcarthur, I see you're still pondering (as of May) reactive stuff
18:36:39 <jmcarthur> sinelaw: off and on
18:36:54 <jmcarthur> those are not new thoughts there :)
18:36:57 <sinelaw> me too, but never have the time to materialize any idea
18:37:34 * roconnor didn't realize the job market for Idris programmers was so large
18:37:38 <mcstar> hm, falling through 10 cases in a case of is faster then looking up an array
18:38:02 <MostAwesomeDude> roconnor: There's a market for it?
18:38:14 <jmcarthur> mcstar: ... that's surprising
18:38:54 <jmcarthur> oh, i misunderstood that i think. i thought you meant 10 nested cases, but i now interpret that as a single caseof having 10 cases
18:39:07 <jmcarthur> less surprising, but still interesting
18:40:10 <mcstar> yeah
18:40:28 <mcstar> instead of matching 10 consecutive integers i put the other sides into an array
18:40:32 <mcstar> it is measurably slower
18:40:44 <mcstar> the array is boxed though
18:40:52 <roconnor> MostAwesomeDude: http://alpmestan.com/posts/2012-10-23-haskell-job-opening-at-functor.html
18:41:15 <roconnor> not exactly an Idris job, but the fact that it is mentioned at all ...
18:43:40 <MostAwesomeDude> roconnor: Nifty.
18:43:51 <MostAwesomeDude> I didn't know that people were starting to actually use it for serious things. That's nifty.
18:47:30 <mhitza> hi guys, I'm dealing with Data.Text.Lazy.IO.writeFile that throws an exception on invalid filename, but its type doesn't use the Exception constraint for me to use Control.Exception.try . How else could I catch the exception?
18:47:49 <mcstar> well, C code is around 0.22s, haskell is 0.3s, i think im gonna stop
18:49:10 <Clint> mhitza: the Exception constraint is on the e
18:49:36 <mhitza> Data.Text.Lazy.IO.writeFile  :: FilePath -> Data.Text.Lazy.Internal.Text -> IO ()
18:49:43 <mhitza> oh
18:49:51 <mhitza> stupid me
18:51:52 <mhitza> :t Control.Exception.try (Data.Text.Lazy.IO.writeFile "test" (Data.Text.Lazy.pack "test"))
18:51:54 <lambdabot> forall e. (GHC.Exception.Exception e) => IO (Either e ())
19:00:42 <mhitza> what signature should I use for this type ambiguity http://hpaste.org/76678  ?
19:01:49 <shachaf> Depends on what kinds of exceptions you want to catch.
19:02:09 <mhitza> I have the error message, but how can I find the type from that?
19:02:28 <mhitza> *** Exception: data/: openFile: inappropriate type (Is a directory)
19:02:35 <shachaf> @ty Control.Exception.try
19:02:37 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
19:02:37 <shachaf> Oh.
19:02:42 <shachaf> Probably IOException?
19:03:07 <Cale> Yeah, that'll be IOException. If you want to figure that out, you can catch SomeException, and pattern match out the contents, and apply typeOf to them
19:03:15 <shachaf> Hmm, you can probably take it as SomeException and then print the tpy.e
19:03:18 <mhitza> yeah that works
19:03:21 <shachaf> What Cale said.
19:03:23 <Cale> It's mildly awkward, perhaps there should be something like...
19:03:25 <mhitza> IOException
19:03:31 <mhitza> thank you guys
19:07:02 <Cale> describeException x = do v <- try x; case v of Left (SomeException e) -> return (Just (typeOf e, show e)); _ -> return Nothing
19:07:30 <Cale> Maybe this? I don't know. There needs to be something to make exception types more discoverable.
19:07:40 <mhitza> I'm new to handling exceptions in haskell, is SomeException some kind of catch all?
19:07:44 <Cale> Yeah
19:08:17 <mhitza> I see, thanks for the info
19:08:22 <Cale> Attempting to catch SomeException will catch every exception.
19:09:50 <shachaf> The Exception system is such a mess.
19:09:57 <Cale> disagree
19:10:10 <Cale> Well, particularly now that the Prelude stuff is gone
19:10:15 <mhitza> is SomeException the blessed exception typeclass, or they are also a case where everybody writes they separate one in their module ? (like I've experienced with EitherT)
19:10:24 <Cale> It was a mess before, the new extensible exception stuff is good
19:10:58 <jmcarthur> Control.Exception is the one most people use. i've not seen anybody reinvent it, at least
19:10:58 <Cale> Maybe some of the specific exception types which things throw should be cleaned up a bit more. IOException needs refinement, but we can thankfully do that without harming existing programs in this framework.
19:11:25 <Cale> mhitza: SomeException is an existential type around Exception.
19:11:37 <Cale> data SomeException = forall e . Exception e => SomeException e
19:11:56 <Cale> Or if you prefer GADT notation:
19:12:24 <Cale> data SomeException where  SomeException :: Exception e => e -> SomeException
19:12:38 <shachaf> data SomeException = SomeException (exists e. Exception e *> e)
19:12:44 <Cale> The Exception class itself provides these two operations:
19:12:54 <Cale> class (Typeable e, Show e) => Exception e where
19:12:57 <shachaf> copumpkin: That was ski's syntax, right?
19:12:59 <Cale>   toException :: e -> SomeException
19:13:04 <Cale>   fromException :: SomeException -> Maybe e
19:13:20 <Cale> and also provides good default implementations so that you can usually just write
19:13:26 <Cale> instance Exception MyType
19:13:29 <copumpkin> shachaf: yeah
19:13:30 <Cale> and get a valid instance
19:14:50 <Cale> However, writing your own instances of Exception makes it possible to make arbitrary hierarchies of exception types
19:15:25 <lispy> hello
19:15:34 <lispy> BEGIN SESSION #haskell
19:15:53 * hackagebot ddc-base 0.2.1.2 - Disciple Core language common utilities.  http://hackage.haskell.org/package/ddc-base-0.2.1.2 (BenLippmeier)
19:15:55 * hackagebot ddc-core 0.2.1.2 - Disciple Core language and type checker.  http://hackage.haskell.org/package/ddc-core-0.2.1.2 (BenLippmeier)
19:15:56 <shachaf> EHLO
19:15:57 * hackagebot ddc-core-eval 0.2.1.2 - Disciple Core language semantic evaluator.  http://hackage.haskell.org/package/ddc-core-eval-0.2.1.2 (BenLippmeier)
19:15:59 * hackagebot ddc-core-simpl 0.2.1.2 - Disciple Core language simplifying code transformations.  http://hackage.haskell.org/package/ddc-core-simpl-0.2.1.2 (BenLippmeier)
19:16:01 * hackagebot ddci-core 0.2.1.2 - Disciple Core language interactive interpreter.  http://hackage.haskell.org/package/ddci-core-0.2.1.2 (BenLippmeier)
19:16:19 <lispy> What is this Disciple that Ben Lippmeier speaks of?
19:16:37 <shachaf> Isn't it that strict Haskell-like language?
19:16:42 <Cale> Yeah
19:16:51 <Cale> With weird effect typing
19:16:56 <lispy> "Disciple is a dialect of Haskell that uses strict evaluation as the default and supports destructive update of arbitrary data structures."
19:17:13 <lispy> I completely lost interest due to that sentence
19:17:20 <lispy> Strict, why?
19:17:27 <lispy> You lose so much
19:17:33 <shachaf> You gain some too.
19:17:57 <copumpkin> if it's strict, you don't need StrictAnal
19:18:17 <liyang> No, only LooseAnal.
19:18:23 <copumpkin> ಠ_ಠ
19:19:09 * liyang hands out some free eye-rinse.
19:23:00 <ivanm> liyang: not enough to warrant full-blown eye bleach?
19:23:17 <copumpkin> I read that as full-brown
19:23:47 <roconnor> lispy: indeed.  Functions are for abstraction, not for evaluation hinting
19:24:12 * ivanm begins to suspect that copumpkin's mind has left the gutter, washed through the sewer but has somehow been blocked from entering the treatment plant
19:25:12 <copumpkin> :)
19:25:40 <jfischoff> Mu Haskell is strict, the standard charter guys like it.
19:26:12 <shachaf> Strictness and nonstrictness are both the devil.
19:26:15 <liyang> It iss mandatory that they like it.
19:26:15 <shachaf> Total languages are the future.
19:26:24 <jfischoff> preach it!
19:26:32 <liyang> Amen!
19:26:43 <copumpkin> good luck compiling the agda std lib to a strict evaluator
19:26:43 <ivanm> liyang: "you will like it or you will be shot"?
19:26:52 <ivanm> shachaf: what do you mean by "total" language?
19:26:53 <Nisstyre> which edition of the Bird and Wadler book is the best one? I've heard the later editions are more about Haskell and less about FP in general, is that true?
19:26:56 <roconnor> jfischoff: what's Mu Haskell?
19:27:03 <lispy> It this discussion, how frequently is strict different than eager?
19:27:06 <copumpkin> roconnor: the fixed point of the Haskell functor
19:27:12 <shachaf> copumpkin: "compiling" ... "agda"?
19:27:26 <jfischoff> roconnor: http://www.youtube.com/watch?v=hgOzYZDrXL0
19:27:27 <roconnor> lispy: different in theory or different in practice?
19:27:28 <liyang> Banish that notion from your corrupted mind.
19:27:33 <shachaf> Mu Haskell ~ Mu Haskell -> Haskell
19:27:34 <ivanm> Nisstyre: depends: do you want to learn Haskell or FP?
19:27:35 <ivanm> wasn't the first edition of Bird's book using Miranda?
19:27:41 <lispy> roconnor: either?
19:27:43 <shachaf> ivanm: Have you ever heard that Agda is "totally cool"?
19:27:47 <Nisstyre> ivanm: I'm more interested in a language agnostic treatment of FP
19:27:59 <copumpkin> ivanm: Agda is "totally cool", man
19:28:04 <copumpkin> shachaf: let's see what he says
19:28:05 <liyang> Compiling leads to linking, linking leads to executing, and execution leads to the dark side…
19:28:10 <roconnor> lispy: in practice memory use blows up to the size of the universe before settling down
19:28:19 <jfischoff> liyang: :)
19:28:40 <copumpkin> liyang: I haven't seen you writing much Agda recently! wherefore didst thou forsake us?
19:28:44 <lispy> Well, I aske because I tend to read strict as "eager", but I guess that's not necessarily the case, is it?
19:28:45 <roconnor> jfischoff: i'm scared
19:28:55 <roconnor> jfischoff: over 1 hour
19:28:57 <liyang> copumpkin: I finished my thesis corrections. ^^;;
19:29:06 <Nisstyre> ivanm: I might show it to a professor who I was discussing the lack of language agnostic books with, but if the good edition is out of print then it might not be worth it
19:29:13 <roconnor> liyang: I rarely execute my libraries before releasing them.
19:29:15 <solrize> lispy, lippmeier's thesis about disciple is pretty good and talks about why he chose strict evaluation
19:29:24 <Nisstyre> s/good/different/
19:29:28 <liyang> copumpkin: later, after I recover a little more from the trauma.
19:29:34 <ivanm> shachaf: heh
19:29:36 <jfischoff> roconnor: its a strict dialect of haskell without general recursion used by traders at standard charter
19:29:52 <copumpkin> liyang: fair enough :) I remember taking Latin in my first high school and hating it, and then I took a couple of years to recover, took it again later in HS, and loved it
19:30:01 <liyang> roconnor: I know, and we aspire to your example! (No, seriously.)
19:30:03 <ivanm> Nisstyre: not sure if that's possible, since any way you consider how to do it will depend upon the quirks of the language
19:30:09 <shachaf> jfischoff: Without general recursion? I hope it doesn't limit you to primitive recursion.
19:30:16 <roconnor> jfischoff: ah; well without general recursion, strictness isn't quite as terrible.
19:30:21 <shachaf> Being able to compute the Ackermann function is very important for trading.
19:30:23 <parcs`> jfischoff: is it a fork of ghc or something? (i can't watch the video atm)
19:30:34 <ivanm> e.g. do you allow side-effects (Haskell vs OCaml for example)?
19:30:36 <shachaf> How else will you compute your profits?
19:30:38 <roconnor> liyang: It surpised even me when I reached programming nirvana.
19:30:51 <Nisstyre> ivanm: well obviously I don't mean a book that completely ignores the language, but I'm thinking it should only use the language concepts it needs to discuss the concepts
19:30:52 <jfischoff> parks`: nope its a totally separate implementation
19:30:55 <jfischoff> ugh
19:31:01 <Nisstyre> *the general concepts
19:31:10 <copumpkin> shachaf: we can write Ackermann in Agda the simple way
19:31:10 <parcs`> neat
19:31:14 <copumpkin> shachaf: or in more complicated ways
19:32:19 <solrize> Nisstyre, maybe you should read PFPL, though it's not about FP per se
19:32:25 <solrize> @pfpl
19:32:25 <lambdabot> Maybe you meant: pl unpl
19:32:28 <solrize> @where pfpl
19:32:28 <lambdabot> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
19:32:51 <solrize> @were SICP
19:32:51 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
19:32:54 <shachaf> rwh?
19:32:58 <shachaf> Real World Harper?
19:33:00 <Nisstyre> solrize: oh, interesting, does that use SML a bit?
19:33:14 <ivanm> Nisstyre: hmmm.... Bird's Functional Pearls book isn't bad in that respect, since it kinda abuses Haskell by using alternate definitions here and there :p
19:33:25 <ivanm> but it still relies upon laziness, purity, etc.
19:33:28 <Nisstyre> ivanm: yeah I saw that one as well
19:33:31 <solrize> Nisstyre, pfpl isn't language specific, it's not really about programming but more about PL theory
19:33:33 <solrize> SICP uses scheme
19:33:48 <Nisstyre> solrize: cool, I'll look into that. I like Robert Harper's stuff that I've read.
19:33:50 <solrize> harper has some course notes that use SML
19:34:10 <ivanm> solrize: heh, I saw a paper comparing different languages (including Haskell) via call-graphs that called itself SICP as a "homage" (i.e. they were too damn lazy to think of a better name)
19:34:32 <solrize> @where sicm
19:34:32 <lambdabot> http://mitpress.mit.edu/sicm/
19:34:53 <Nisstyre> solrize: that Harper book looks really good for understanding type theory.
19:35:24 <Nisstyre> solrize: have you seen the talk Sussman gave about SICM?
19:35:39 <solrize> haven't seen the talk
19:35:40 <roconnor> Nisstyre: which book?
19:35:48 <solrize> roconnor, pfpl
19:35:49 <Nisstyre> roconnor: pfpl
19:36:02 <roconnor> Nisstyre: any dependent types?
19:36:18 <Nisstyre> solrize: http://youtu.be/fAY0_pesZ6s
19:36:20 <Nisstyre> roconnor: no clue
19:36:26 <solrize> roconnor no
19:36:34 <solrize> unless he's added them
19:36:42 <Nisstyre> solrize: skip to ~30 minutes if you want to just hear about SICM
19:37:51 <solrize> the beginning is interesting
19:38:10 <sclv> the sicm code is a cross between awesome and ridiculous
19:38:25 <solrize> these days he says all programming is crap and we don't know a thing about how to do it and all programming languages suck.  but he's gotten interested in haskell because it sucks the least.
19:39:27 <sclv> awesome because expressions have lots of neat multiple interpretations and you can mix symbolic and numeric stuff very elegantly
19:40:02 <sclv> ridiculous because it is all done ad-hoc and fragile with macros, and the numeric stuff is as ad-hoc as the pl stuff
19:40:12 <sclv> and also the code is totally confusing and disorganized
19:40:23 <sclv> its like a brilliant scrapbook
19:50:04 <roconnor> solrize: Gerry Sussman?
19:50:19 <solrize> yeah
19:53:29 <YayMe`> I implemented a my first monad, and correctly! yay me. (I think correctly.. guess I should test the laws)
19:53:56 <MostAwesomeDude> YayMe`: What's its type?
19:54:21 <roconnor> why is he talking about Lagrangians?
19:54:35 <solrize> sicm is about lagrangian mechanics
19:55:39 <roconnor> ... this isn't going to end well
19:56:04 <solrize> http://mitpress.mit.edu/books/structure-and-interpretation-classical-mechanics
19:56:41 <solrize> http://en.wikipedia.org/wiki/SICM
19:57:22 <tromp> > 2.5*582
19:57:22 <shachaf> SICM? I hardly know'em!
19:57:24 <lambdabot>   1455.0
19:59:23 <otters> @pl \x y -> concatMap y x
19:59:23 <lambdabot> (>>=)
19:59:51 <solrize> @pl concatMap
19:59:51 <lambdabot> (=<<)
19:59:55 <solrize> lol
20:00:05 <roconnor> solrize: I'm impressed given that the task of computerizing CM seems impossible on the face of it.
20:00:12 <rwbarton> @pl flip (>>=)
20:00:12 <lambdabot> (=<<)
20:00:54 * hackagebot yst 0.3.0.1 - Builds a static website from templates and data in YAML or  CSV files.  http://hackage.haskell.org/package/yst-0.3.0.1 (JohnMacFarlane)
20:00:54 <shachaf> @pl flip (+)
20:00:55 <lambdabot> (+)
20:01:07 <rwbarton> @pl flip (==)
20:01:07 <lambdabot> (==)
20:01:16 <rwbarton> @pl flip (<=)
20:01:16 <lambdabot> flip (<=)
20:01:19 <rwbarton> what
20:01:36 <rwbarton> i guess since (=>) is not available :)
20:02:04 <otters> >= is
20:02:07 <shachaf> I'm a proponent of data Bool = True | False deriving Ord
20:02:18 <rwbarton> yes but it's not the reflection of <=
20:02:19 <shachaf> So that (<=) works as implication.
20:02:22 <hotaru2k3> @pl flip (>=)
20:02:22 <lambdabot> flip (>=)
20:02:23 <ivanm> shachaf: but not deriving anything else? :p
20:02:43 <shachaf> ivanm: Well, presumably deriving Eq, too. But that's not the point.
20:02:48 <ivanm> :)
20:02:49 <roconnor> shachaf: usually false is considered less than true.
20:02:49 <hotaru2k3> @pl flip (>)
20:02:50 <lambdabot> flip (>)
20:02:54 <ivanm> @src Bool
20:02:54 <lambdabot> data Bool = False | True deriving (Eq, Ord)
20:03:01 <roconnor> shachaf: in lattices
20:03:04 <shachaf> roconnor: Yes, but <= works out to be => that way!
20:03:20 <Cale> So it does
20:03:23 <roconnor> shachaf: I think you'd be losing more than you are gaining
20:03:34 <shachaf> roconnor: I agree.
20:03:37 <Cale> If you just accept that, it's fine.
20:03:40 <roconnor> shachaf: :D
20:03:45 <shachaf> Someone at bahaskell was pretty upset that instance Ord Bool.
20:03:54 <Cale> wat
20:03:56 <Cale> why?
20:04:05 <roconnor> that said I often put false on the top of my lattice for some reason.
20:04:21 <shachaf> He said that Bool is really Z/2Z, and should have no ordering, or something like that.
20:04:39 <ivanm> shachaf: I would be more upset about Bool having an Eq instance for newbies to abuse
20:04:50 <Cale> hah
20:04:57 <Cale> But there's no instance of Num!
20:05:14 <Mortchek> ivanm, how could that be abused?
20:05:19 <shachaf> Cale: Well, Num is just crazy.
20:05:26 <Cale> It's not that crazy
20:05:32 <Mortchek> 1 :: Bool -- :P
20:05:32 <ivanm> isEmptyList xs | xs == [] = True = True; | otherwise = False
20:05:34 <ivanm> Mortchek: ^^
20:05:35 <Cale> It's Z/2Z after all
20:05:47 <shachaf> Is Bool a Monoid?
20:05:52 <ivanm> Z/2Z = 1/2, right? *ducks*
20:05:53 <shachaf> I guess not.
20:06:02 <ivanm> > True `mappend` False
20:06:03 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Bool.Bool)
20:06:04 <lambdabot>    arising from a use of...
20:06:30 <Mortchek> ivanm, I am failing to parse that.
20:06:33 <ivanm> shachaf: yeah, do you use Or or And for mappend?
20:06:43 <Mortchek> The isEmptyList one I mean
20:06:43 <shachaf> ivanm: I know, All and Any.
20:06:43 <roconnor> > Any True `mappend` Any False
20:06:44 <lambdabot>   Any {getAny = True}
20:06:48 <ivanm> oh, right, that should be "xs == [] == True"
20:06:50 <roconnor> > All True `mappend` All False
20:06:52 <lambdabot>   All {getAll = False}
20:07:01 <ivanm> Mortchek: a lot of newbies have "== True" in their code
20:07:03 <shachaf> Cale: When is L.hs getting import Control.Lens?
20:07:05 <Cale> ivanm: For some interpretations of 1/2
20:07:22 <Cale> shachaf: Uhh... can I install that on 6.12?
20:07:32 <edwardk> cale: sadly no =( it needs 7.2+ iirc
20:07:36 <ivanm> Mortchek: and for bonus marks have something like `if (b == True) then True else False"
20:07:44 <Cale> edwardk: I thought so
20:07:44 <Mortchek> o_0
20:07:59 <shachaf> Cale: Time to upgrade!
20:07:59 <ivanm> Mortchek: zigackly
20:08:04 <shachaf> I know lambdabot works with 7.0.
20:08:09 <Cale> hmm
20:08:40 <Cale> shachaf: 7.0 apparently wouldn't be enough
20:08:42 <Mortchek> ivanm, does this have to do with people coming from dynamically typed languages, do you think?
20:08:53 <ivanm> Mortchek: nope, a lot of these had never programmed before
20:08:59 <shachaf> Hmm, lambdabot's dependencies don't work with 7.6.
20:09:00 <ivanm> just lack of familiarity with boolean logic, etc.
20:09:30 <shachaf> ivanm: To be fair, in some dynamically-typed languages "== True" might make sense.
20:09:41 <ivanm> shachaf: oh? implicit conversions?
20:09:46 <Mortchek> Not much though.
20:10:15 <shachaf> ivanm: Nothing implicit. == might compare types as well as values.
20:10:17 <roconnor> ivanm: I learned a few years ago that == is associative.
20:10:28 <jmcarthur> not = (1-)
20:10:35 <ivanm> shachaf: how so?
20:10:37 <edwardk> so all we need to do is fix up lambdabot to work with 7.4 or 7.6?
20:10:45 <Cale> edwardk: yeah
20:10:55 <rwbarton> i thought i saw someone posting about getting lambdabot working with either 7.4 or 7.6 (i forget which)
20:10:55 <edwardk> might be a fun experiment some time
20:10:57 <shachaf> The issue is probably not lambdabot itself but all its dependencies.
20:11:00 <Mortchek> If == represents equality, it should be associative, reflexive, and commutative
20:11:18 <shachaf> Mortchek: Associative? Don't you mean transitive?
20:11:23 <Mortchek> Which is the minimum for something to be an equivalence
20:11:23 <roconnor> edwardk: interestingly, VL traversals are potentially more lazy that Kleene Store Coalgebras when it comes to infinite traversals.
20:11:26 <shachaf> And symmetric, rather than commutative?
20:11:29 <Mortchek> Maybe?
20:11:43 <mauke> > join (==) (0/0)
20:11:44 <lambdabot>   False
20:11:45 <edwardk> yep
20:11:45 <shachaf> Mortchek: The property roconnor is talking about is different.
20:11:47 <ivanm> shachaf: I still don't see how "== True" might make sense in dynamically-typed languages :s
20:12:00 <edwardk> you mean than the ADT based kleene store?
20:12:04 <Mortchek> a == a, a == b and b == c → a == c, a == b → b == a
20:12:04 <shachaf> ivanm: (2 == True) #=> False
20:12:18 <roconnor> edwardk: an infinite KleeneStore can never be extracted, but an infinite VL store can be.
20:12:22 <jmcarthur> ivanm: consider looking for booleans in a heterogeneous list
20:12:23 <ivanm> OK, do I want to know wtf that means? :s
20:12:32 <roconnor> edwardk: right an ADT KleeneStore
20:12:32 <shachaf> Mortchek: Yes, I know. That's not the same thing.
20:12:41 <edwardk> since the forall f. Applicative f => (c -> f d) -> f a      bazaar works fine iirc
20:12:47 <Mortchek> Guess I mixed up my terminology. I am sleepy :P
20:12:48 <shachaf> roconnor is talking about an associative function, not a transitive relation.
20:12:53 <ivanm> jmcarthur: so what is the result of something like "1 == True" then in that case?
20:12:54 <roconnor> edwardk: right;  I don't know what to call that thing
20:13:04 <edwardk> I just call it the bazaar
20:13:09 <roconnor> fair
20:13:17 <jmcarthur> ivanm: it of course depends on what == means, but in the hypothetical language i'm thinking of, that would give false
20:13:19 <rwbarton> "1 == True" might be false when "1" is true
20:13:32 <ivanm> shachaf: why would you test if 2 is True? :/  And what is #=> meant to be?
20:13:40 <ivanm> jmcarthur: oh, a _hypothetical_
20:13:46 <jmcarthur> ivanm: this is just that weirdness that is dynamically typed languages
20:13:51 <roconnor> edwardk: another notch in favour of the VL representation.
20:13:54 <ivanm> rwbarton: *ow, my brain* :s
20:13:54 <edwardk> its a bunch of stores where you an traverse it easily and add more. plus the a a r is indicative of the two extra parameters that need to be the same
20:13:58 <shachaf> rwbarton: In Python, 1 == True and 2 != True, but both 1 and 2 are "truthy"
20:14:03 <shachaf> ivanm: "evaluates to"
20:14:15 <ivanm> ahhhh
20:14:16 <shachaf> ivanm: And it's because you have some argument whose type you don't know.
20:14:42 <roconnor> edwardk: also, making HolesOf lazy is proving difficult. :D
20:14:50 <ivanm> shachaf: so you're combining an "is type of" operation with "is it this value" operation?
20:14:53 <edwardk> roconnor: hahaha
20:15:00 <shachaf> ivanm: In one sense, yes.
20:15:04 <roconnor> edwardk: though I still expect it is do able.
20:15:06 <edwardk> you can do it! i have faith in you
20:15:31 <shachaf> Cale: lambdabot depends on a lot of packages that break under 7.6, probably most of them unmaintained.
20:15:32 <roconnor> edwardk: but I learned I cannot use a KleeneStore
20:15:36 <shachaf> What should we do?
20:15:39 <edwardk> shachaf has been working on making mapped %~ f = fmap f     be a little more accurate
20:15:54 * hackagebot monad-coroutine 0.8 - Coroutine monad transformer for suspending and resuming monadic computations  http://hackage.haskell.org/package/monad-coroutine-0.8 (MarioBlazevic)
20:15:59 <edwardk> as it is now mapped %~ f = fmap (\x -> f x)
20:16:00 <jmcarthur> ivanm: that python weirdness is also true in ruby
20:16:10 <Mortchek> JS has some fun rules to do with truthiness and coercive equality
20:16:34 <Cale> shachaf: Someone should write a new IRC bot and steal code from lambdabot for anything particularly interesting/non-obvious
20:16:35 <jmcarthur> if 1; puts "foo"; end   outputs foo.   if 1 == true; puts "foo"; end   does not
20:16:37 <edwardk> Mortchek: this is one of the things that drove me to haskell
20:16:37 <Mortchek> For one thing, == in JS is not transitive: 0 == '' and 0 == '0' but '' != '0'
20:16:47 <shachaf> edwardk: That led to finding a GHC optimizer bug!
20:17:00 <edwardk> shachaf: did that turn into a bug report for ghc yet?
20:17:01 <shachaf> rwbarton: See? Even Cale thinks you should do it.
20:17:14 * ivanm hugs Haskell
20:17:19 <Cale> It doesn't need dynamic module loading
20:17:20 <shachaf> edwardk: Yep, http://hackage.haskell.org/trac/ghc/ticket/7364
20:17:21 <rwbarton> someonechaf
20:17:22 <edwardk> i saw you guys yammering about it over there, but i didn't see the resolution
20:17:24 <edwardk> k
20:17:28 <shachaf> someonewbarton
20:17:30 <Mortchek> === is transitive, but because of NaN, neither is reflexive over the whole domain of JS values
20:17:36 <Cale> (if that helps)
20:17:43 <roconnor> Mortchek: PERs are nice
20:17:47 <Mortchek> PER?
20:17:50 <rwbarton> technically == is not transitive in java either
20:17:55 <roconnor> Partial Equivalence Relation.
20:18:04 <jmcarthur> > (1/0) == (1/0)
20:18:06 <lambdabot>   True
20:18:16 <jmcarthur> > (0/0) == (0/0)
20:18:18 <lambdabot>   False
20:18:23 <hpaste> YayMe pasted “monad tests” at http://hpaste.org/76681
20:18:27 <roconnor> like partial orders, but for equivalence relations.
20:18:31 <djahandarie> Oh wow, next ICFP is in Boston.
20:18:34 <ivanm> with 7.6, is there an NFData instance for Seq? (can't recall if they're in deepseq or containers nowadays)
20:18:37 <Mortchek> === is that, but == only has commutativity
20:18:38 <jmcarthur> djahandarie: sweet!
20:18:42 <djahandarie> I have no excuse to not go.
20:18:45 <roconnor> djahandarie: Boston is closeish to Ontario
20:18:50 <djahandarie> What does one do at these things anyways?
20:18:52 <YayMe`> my hpaste valid for testing monads?
20:18:54 <djahandarie> I've never been to one before.
20:18:56 <geekosaur> fsvo closeisg
20:19:00 <YayMe`> to make sure I get the implementation correct
20:19:01 <geekosaur> closeish even
20:19:13 <roconnor> djahandarie: usually the ACM refuses to publish your articles
20:19:19 <Mortchek> Err, s/commutativity/symmetry/
20:19:24 <djahandarie> Haha.
20:19:25 <roconnor> djahandarie: at least that the my experience.
20:19:31 <djahandarie> I remember that post.
20:19:49 <roconnor> Finally I'm not longer a member of the ACM
20:21:18 <shachaf> roconnor: Do you know about the monthly Haskell meetings in Toronto?
20:22:10 <shachaf> Cale: Where's the latest version of lambdabot? Is it the darcs repository?
20:22:23 <shachaf> @version
20:22:24 <lambdabot> lambdabot 4.2.2.1
20:22:24 <lambdabot> darcs get http://code.haskell.org/lambdabot
20:22:45 <Cale> I think so... gwern would actually probably know better though
20:22:49 <shachaf> gwern: ☝
20:23:04 <shachaf> Cale: You should export the state once in a while. Imagine if the @quote database got lost!
20:23:06 <roconnor> shachaf: no
20:23:08 <shachaf> "terrible"
20:23:27 <shachaf> roconnor: I don't know if you're nearby, but you should ask monochrom about them if you are.
20:23:29 <gwern> shachaf: why are you making rude gestures at me
20:23:41 <roconnor> I am fairly close to Toronto
20:23:52 <shachaf> monochrom: ☝
20:24:03 <rwbarton> how hard would it be to make a complete hackage mirror, try to build everything under 7.4 and then fix every package that builds under 7.4 to build under 7.6
20:24:06 <eyebloom> Can anyone explain the difference between a data family and a type family.
20:24:07 <rwbarton> i bet it wouldn't even take that long
20:24:25 <shachaf> rwbarton: It would probably take a lot of doing things by hand.
20:24:27 <Cale> Perhaps I should try to make it out for one of the Toronto Haskell things
20:24:38 <shachaf> Cale: Make it out at the same time as roconnor!
20:24:39 <rwbarton> yeah but aren't all the things you have to do by hand really easy?
20:24:49 <shachaf> They usually have one random guest, but they can have 2 that day.
20:25:28 <shachaf> rwbarton: Possibly. I think the main issue is that people don't maintain their code.
20:25:37 <shachaf> But I guess we can upload packages on top of theirs.
20:25:42 <shachaf> Is that rude?
20:25:46 <rwbarton> could i just make an nmu upload of everything then, yeah
20:25:48 <shachaf> dmwit does that a lot, right?
20:25:59 <rwbarton> like this doesn't seem actually that hard to fix
20:26:04 <shachaf> I think some of the 7.6 fixes might be nontrivial.
20:26:18 <shachaf> But probably most of them aren't.
20:26:40 <ivanm> @ask lispy from the docs of withForeignPtr, should I have my data structures use ForeignPtr inside them rather than Ptr?  IIUC, constructing a value that stores the Ptr and returning it could be unsafe :s
20:26:40 <lambdabot> Consider it noted.
20:27:11 <rwbarton> well i haven't tried at all since i haven't installed 7.6 anywhere yet
20:27:16 <shachaf> ivanm: Yes, if there are no references to the ForeignPtr it might be GCed, presumably.
20:27:30 <ivanm> oh, hooray *sighs*
20:27:35 <shachaf> (And when the ForeignPtr gets GCed, the finalizer is run.)
20:27:42 <shachaf> rwbarton: You should install it! It's easy.
20:27:53 <rwbarton> yes but it's the using it part which is tricky :P
20:27:58 <shachaf> It all works magically.
20:28:07 <shachaf> Sigh, readline.
20:28:19 <shachaf> 7.6 is stricter about the FFI, among other things.
20:29:14 <solrize> is it difficult to call a c++ library thru the ffi?
20:29:15 <rwbarton> that is just changing CInt -> CInt(..) in imports right
20:29:26 <rwbarton> or are there other changes too
20:29:27 <shachaf> Yep.
20:29:31 <shachaf> Well, that's the one I know of.
20:30:02 <lispy> lambdabot: messages
20:30:06 <lispy> @messages
20:30:07 <lambdabot> ivanm asked 3m 27s ago: from the docs of withForeignPtr, should I have my data structures use ForeignPtr inside them rather than Ptr? IIUC, constructing a value that stores the Ptr and returning it
20:30:07 <lambdabot> could be unsafe :s
20:30:19 <lispy> ivanm: looks like shachaf already answered you
20:30:23 <ivanm> yeah :)
20:30:39 <shachaf> hispy
20:30:44 <ivanm> but it's OK to use withForeignPtr within a peek/poke definition? (since you have to pass the pointer through _somehow_)
20:30:49 <rwbarton> solrize: equally hard as calling a c++ library from c, afaik.
20:31:14 <lispy> solrize: yes. The standard Haskell FFI only knows about C. What you can do is reduce the C++ api to something that C could consume without a C++ compiler and use that.
20:31:16 <sudochop> hmm.. now how does one speak in just one particular channel when im connected to 2..
20:31:17 <rwbarton> basically that goes for ffi to any language
20:31:44 <rwbarton> well, except agda or something :P
20:32:00 <shachaf> FFI to Agda? That means running the typechecker, right?
20:32:18 <lispy> ivanm: Yes if the C code doesn't hold on to the Ptr that you pass it
20:32:39 <lispy> ivanm: if it holds on to it on the C side then the Haskell GC will clean it up and you'll have FUN on the C side
20:32:58 <lispy> Fun by the C side....sounds like a novel
20:33:06 <ivanm> lispy: what do you mean by "holds on"?  I have a C data structure composed of pointers
20:33:16 <ivanm> I pass that to various C methods, which pass various pointers around
20:33:25 <ivanm> is that "holding on"?
20:33:35 <ivanm> if so... then I'm screwed _again_
20:33:36 <lispy> ivanm: Does it add the pointers to any state it has?
20:33:47 <ivanm> lispy: no, I don't have any state
20:33:54 <shachaf> ivanm: If there are references to the pointer that GHC's GC can't reach as ForeignPtr, the ForeignPtr will be GCed and the finalizer will be run.
20:33:55 <lispy> you're good then
20:34:01 <ivanm> *phew*
20:34:26 <lispy> ivanm: if it somehow cached the pointers and then used them in a later API call, you'd need a different strategy
20:35:01 <ivanm> how do I get a FinalizerPtr to be able to turn a Ptr into a ForeignPtr then?
20:35:12 <lispy> solrize: automated tools to generate a C style api from C++ apis might exist. Seems useful at least.
20:35:24 <ivanm> (when peeking, if my marshalling data structures use ForeignPtr)
20:35:28 <lispy> :t Ptr a -> ForeignPtr a
20:35:30 <lambdabot> parse error on input `->'
20:35:34 <lispy> @hoogle Ptr a -> ForeignPtr a
20:35:35 <lambdabot> Foreign.ForeignPtr newForeignPtr_ :: Ptr a -> IO (ForeignPtr a)
20:35:35 <lambdabot> Foreign.Concurrent newForeignPtr :: Ptr a -> IO () -> IO (ForeignPtr a)
20:35:35 <lambdabot> Foreign.ForeignPtr newForeignPtr :: FinalizerPtr a -> Ptr a -> IO (ForeignPtr a)
20:35:45 <shachaf> Hmm, hoogle requires cabal <= 1.15
20:36:02 <ivanm> IIUC, newForeignPtr requires me to specify the finalizer later
20:36:02 <lispy> ivanm: You have a ForeignPtr and you want to provide a Ptr?
20:36:12 <lispy> ivanm: or do you have a Ptr and want a ForeignPtr?
20:36:19 * lispy is confused
20:36:33 <ivanm> lispy: so I have "data Foo = F { ... barP :: ForeignPtr Baz ... }"
20:36:48 <ivanm> I then define poke on that using withForeignPtr
20:37:00 <ivanm> how do I define peek?
20:37:17 <shachaf> The same way as poke, presumably?
20:37:18 <lispy> oh, isn't there a mallocForeignPtr?
20:37:32 <lispy> @hoogle mallocforeignptr
20:37:33 <lambdabot> Foreign.ForeignPtr mallocForeignPtr :: Storable a => IO (ForeignPtr a)
20:37:33 <lambdabot> Foreign.ForeignPtr mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
20:37:33 <lambdabot> Foreign.ForeignPtr mallocForeignPtrArray0 :: Storable a => Int -> IO (ForeignPtr a)
20:37:34 <shachaf> Oh, you want to allocate a new pointer.
20:37:49 <rwbarton> is there a Storable (ForeignPtr a) instance? presumably not?
20:38:03 <rwbarton> i don't think you should attempt to write one
20:38:19 <shachaf> Nope, you probably want to do your own allocation or something.
20:38:23 <ivanm> lispy: so I create a new ForeignPtr, and then somehow copy the contents of the Ptr into it? :s
20:38:33 <ivanm> rwbarton: nope
20:38:40 <shachaf> ivanm: Do you know what a ForeignPtr is? :-)
20:38:49 <ivanm> shachaf: kinda? ;)
20:39:12 <ivanm> lispy was telling me yesterday that I should really use ForeignPtrs rather than Ptrs in my Haskell representations
20:39:21 <ivanm> which I'm trying to do :s
20:39:35 <lispy> ivanm: Well, it depends on what context you're in
20:39:43 <shachaf> ivanm: A ForeignPtr is a Ptr + a finalizer that gets called sometime after there are no references to the ForeignPtr.
20:40:04 <shachaf> You can make a ForeignPtr out of a Ptr + finalizer easily enough, or you can allocate one directly with functions like the one lispy mentioned.
20:40:13 <lispy> ivanm: I'm not confident in saying this, but maybe "data Foo" above should have a Ptr Baz
20:40:39 <ivanm> that's what I had...
20:40:42 <lispy> it shouldn't make too much difference
20:40:52 <ivanm> but from what shachaf said earlier I thought I should use ForeignPtr :s
20:40:56 * ivanm is confused again
20:41:06 <shachaf> ivanm: It depends on what you're doing, I suppose.
20:41:17 * ivanm grabs his code
20:41:19 <lispy> ivanm: let's stick with ForeignPtr for now
20:41:25 <rwbarton> if you're defining peek for Foo then it sounds like you are getting pointers from C and in that case you better understand the memory management of the memory pointed to by those pointers
20:41:52 <ivanm> shachaf: here are my C types: http://hub.darcs.net/ivanm/dangd/browse/utils/bench_match_bud.h
20:41:53 <rwbarton> like if the C function is allocating memory and handing it to you in these pointers, that could be a different situation than if C is just passing you pack a pointer you passed to it
20:42:13 <lispy> ivanm: it sounds like you need to make a copy of whatever the C ptr points to and poke that into a newly allocated ForeignPtr
20:42:20 <ivanm> rwbarton: I'm going to allocate the memory on the Haskell side
20:42:34 <ivanm> lispy: oh, hooray :s
20:42:50 <rwbarton> possibly you should just not define peek at all or ignore that ForeignPtr field or something
20:43:07 <rwbarton> why do you need peek anyways
20:43:07 <ivanm> that makes it a little difficult to debug then....
20:43:17 <ivanm> because I'm not sure if my C code is right?
20:43:20 <rwbarton> hm
20:43:21 <ivanm> and want to compare it to my Haskell code
20:43:59 <rwbarton> I mean
20:44:13 <rwbarton> do you ever expect to peek a Foo and get a pointer you didn't allocate in Haskell
20:44:25 <ivanm> no
20:44:54 <ivanm> but then, I was blindly using with and alloca to try and allocate memory yesterday without ForeignPtrs and seemed to keep getting random memory garbles :s
20:45:21 <shachaf> Well, uh...
20:46:17 <ivanm> yes, I'm quite aware I have nfi what I'm doing :)
20:46:35 <lispy> ivanm: the main point is that you need to do a deep copy of the data structures when you marshall
20:46:42 <saml> case expr of { Nothing -> defaultValue; Just x -> f x }   is there shorthand for this?
20:46:55 <shachaf> saml: maybe defaultValue f
20:47:03 <saml> shachaf, thanks
20:47:10 <shachaf> (Hoogle would've told you! :-) )
20:47:25 <ivanm> lispy: I _think_ I am
20:47:40 <ivanm> lemme record and push my new attempt so you can see if I'm on the right track or not
20:47:52 <shachaf> Sigh...
20:47:57 <rwbarton> @@ @hoogle @type \defaultValue f expr -> case expr of { Nothing -> defaultValue; Just x -> f x }
20:47:58 <lambdabot>  Prelude maybe :: b -> (a -> b) -> Maybe a -> b
20:47:58 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
20:47:58 <lambdabot> Data.Generics.Aliases mkQ :: (Typeable a, Typeable b) => r -> (b -> r) -> a -> r
20:48:07 <shachaf> This thing where packages break trivially and their maintainers aren't around is quite annoying.
20:48:17 <lispy> shachaf: yes
20:48:24 <saml> shachaf, do you know equivalent of maybe in scala?
20:48:25 <shachaf> Is luqui usually around here?
20:48:28 <saml> scala sucks
20:48:32 <lispy> or you have maintainers like me that drag their feet :)
20:48:33 <shachaf> saml: No. Maybe #scala would know.
20:48:44 <saml> they don't know maybe
20:49:05 <saml> http://stackoverflow.com/questions/1244014/is-there-anything-like-haskells-maybe-function-built-into-scala  oh nice
20:49:06 <shachaf> Well, this isn't a Scala channel.
20:49:18 <lispy> Usuall, the magic hash go at the end, {-# LANGUAGE MagicHash #-} Maybe (Scala#) ?
20:49:20 <rwbarton> I think it is Option
20:49:20 <rhodesd> it might be  option
20:49:34 <shachaf> rwbarton: "maybe", not "Maybe"
20:49:40 <rwbarton> oh
20:50:06 <lispy> You could write a good chunk of Haskell's prelude in scala
20:50:07 <shachaf> Looks like Scala has fromMaybe
20:50:25 <lispy> They have something H-M-ish for types and you have cases.
20:50:32 <AfC> {-# LANGUAGE Scala #-} works, no?
20:50:39 <lispy> And I guess you'd do type classes as traits?
20:50:48 <shachaf> Type classes are the devil.
20:51:20 <lispy> shachaf: sarcasm?
20:51:31 <shachaf> lispy: Partly.
20:51:42 <shachaf> If I want to submit a patch for someone on GitHub, but I don't want their repository to appear in my account's repository list, what do I do?
20:52:11 <lispy> shachaf: I don't know, I get annoyed by that.
20:52:18 <shachaf> Maybe I fork and submit it and then delete it?
20:52:21 <lispy> I think github philosophy is just clone it
20:52:35 <lispy> I'm not sure if you can clone later if you do that. Maybe they fixed that bug?
20:52:56 <shachaf> Wait, someone already fixed it.
20:53:01 <shachaf> He just didn't upload to Hackage!
20:53:01 * lispy goes back to reading this paper
20:53:02 <shachaf> luqui!
20:53:58 <rwbarton> how terrible an idea is an alternative hackage server where nmu patches are actively encouraged
20:54:19 <rwbarton> because this 7.6 thing isn't the only issue, you also have random version range issues, documentation patches etc.
20:54:20 <shachaf> nmu?
20:54:25 <rwbarton> non-maintainer upload
20:54:29 <shachaf> Oh.
20:54:33 <rwbarton> basically a hackage server where there is no notion of package owner
20:54:38 <shachaf> It's mildly terrible, but so is the current situation.
20:55:03 <shachaf> Versions are unfortunately totally ordered.
20:55:18 <rwbarton> i guess that is true even between hackage servers
20:55:47 <shachaf> Someone needs to come up with a version number scheme which works as a distributed lattice.
20:56:06 <jmcarthur> something like vector clocks?
20:56:39 <ivanm> shachaf, lispy: http://hub.darcs.net/ivanm/dangd/browse/utils/bench_match_bud.hsc
20:57:03 <ivanm> e.g. from line 126
20:57:19 <rwbarton> my version number = the set of all version numbers that are less than me
20:57:32 <roconnor> edwardk: BTW someone suggested functions of types Setter a b -> (b -> m b) -> StateT a m ()  and Setter a b -> (b -> m (c, b)) -> StateT a m c
20:57:35 <ivanm> I allocate foreign pointers in toCGraph which starts at line 158
20:57:36 <rwbarton> plus some authorship info I guess
20:57:39 <roconnor> edwardk: do you have names for theses?
20:57:46 <ivanm> will the memory then be freed as soon as that function ends? :s
20:58:07 <edwardk> they don't work right iirc
20:58:26 <jmcarthur> each component of the vector clock corresponding to an author, would probably work. would get pretty big for projects with lots of contributors though
20:58:32 <roconnor> edwardk: really?
20:58:51 <edwardk> the problem is the traversal. if it touches multiple targets. how an it string together the edits to the self-same state?
20:58:52 <jmcarthur> if the complexity was okay, an interval tree clock could possibly be better
20:58:53 <roconnor> my lens-familiy has:
20:59:04 <rwbarton> jmcarthur, you would only need separate components for non-cooperating authors
20:59:06 <roconnor> (%=) :: Monad m => Ref (Focusing m c) a b -> (b -> (c, b)) -> StateT a m c
20:59:07 <roconnor> l %= f = focus l (StateT (return . f))
20:59:11 <edwardk> oh you have them without the State in the monadic action
20:59:18 <roconnor> It seems natural to drop the "return ."
20:59:27 <shachaf> I,I return `o` f
20:59:34 <shachaf> Who's maintaining unlambda?
20:59:39 <shachaf> Cale: Is it you?
20:59:45 <jmcarthur> rwbarton: interval tree clocks have a join operation that helps to reduce its size
20:59:46 <shachaf> http://hackage.haskell.org/packages/archive/unlambda/0.1.2/unlambda.cabal
20:59:51 <edwardk> those work. i just don't like the fact that they unlike all the other combinators need the state at the outside and can't be transformed
21:00:01 <roconnor> ah
21:00:03 <jmcarthur> rwbarton: so somebody could fork for a while and then later merge back
21:00:14 <roconnor> edwardk: okay then
21:00:15 <edwardk> it feels very ad hoc to me
21:00:17 <Cale> shachaf: I have never in my life touched that code
21:00:26 <shachaf> Cale: Why are you listed as the maintainer?
21:00:27 <roconnor> edwardk: sush is the life of Haskell 98
21:00:30 <roconnor> *such
21:00:30 <Cale> shachaf: no idea
21:00:34 <shachaf> You think you could hide behind that comment, huh?
21:00:38 <edwardk> well, i'm pretty far away from 98 in lens at least ;)
21:00:39 <shachaf> gwern: Beep.
21:00:45 <roconnor> edwardk: ;)
21:00:55 <Cale> shachaf: But it comes with lambdabot, so maybe whoever wrote me in as the maintainer of lambdabot did the same with unlambda?
21:01:02 <jmcarthur> ah, but the ITC removes the ability to name the author, since it no longer partitions into static components
21:01:08 <edwardk> bbiab,running out of juice
21:01:10 <lispy> ivanm: pNs and pEs are Ptr
21:01:16 <ivanm> yup
21:01:22 <ivanm> so, should I change those to ForeignPtr?
21:01:40 <gienah> shachaf: I sent an unlambda patch to gwern
21:01:42 <lispy> ivanm: you don't hold on to references to fpNs and fpEs, so their finalizers will run
21:01:43 <ivanm> and then try and avoid getting headaches for peek?
21:01:50 <ivanm> that's what I was afraid of :(
21:01:54 <lispy> ivanm: and the underlying pEs and pNs will get collected
21:01:54 <shachaf> rwbarton: What's the nice non-intrusive way to fix something that uses Prelude.catch?
21:02:23 <lispy> `Control.Exception.catch` \(Control.Exception.SomeException e) -> ...
21:02:30 <shachaf> Disgusting.
21:02:35 <ivanm> wouldn't you use the IOException instead?
21:02:40 <shachaf> Also that.
21:02:42 <ivanm> isn't that all that Prelude.catch did?
21:02:45 <shachaf> @ty catch
21:02:47 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
21:02:50 <rwbarton> does Control.OldException still exist?
21:02:55 <ivanm> @hoogle IOException
21:02:55 <lambdabot> Control.OldException IOException :: IOException -> Exception
21:02:56 <lambdabot> Control.Exception.Base data IOException
21:02:56 <lambdabot> Control.Exception data IOException
21:02:56 <shachaf> Nope, it's gone in 7.6
21:02:56 <ivanm> rwbarton: nope
21:02:57 <rwbarton> and was that ever the right answer to that question?
21:03:00 <shachaf> That's why nothing is compiling.
21:03:02 <Cale> We should subtype IOException now.
21:03:03 <shachaf> rwbarton: Yep.
21:03:07 <Cale> Like, heavily.
21:03:09 <rwbarton> solution: put a Control.OldOldException on hackage
21:03:10 <shachaf> FSVO "right"
21:03:14 <gienah> shachaf: this is the unlambda patch for ghc 7.6.1 I darcs sent: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/unlambda/files/unlambda-0.1.2-ghc-7.6.patch
21:03:24 <shachaf> gwern: Accept the patch!
21:03:27 <shachaf> gwern: ☝
21:03:39 <gwern> what makes you think I didn't?
21:03:54 <ivanm> lispy: so, I use withForeignPtr just for pokeArray in my marshalling functions?
21:03:54 <shachaf> gienah: Wait, does that work in 7.4?
21:03:59 <gwern> also stop giving me the middle finger
21:04:03 <Cale> heh
21:04:09 <shachaf> gienah: Oh, I see.
21:04:15 <lispy> ivanm: you can use it in things that are scoped by withForeignPtr
21:04:17 <shachaf> gwern: Excuse me, that's a 261D   WHITE UP POINTING INDEX     [☝]
21:04:18 <gienah> shachaf: not sure I haven't tested it with 7.4
21:04:31 * gienah oops wrong nick
21:04:33 <gwern> an index can be a middle finger
21:04:33 <shachaf> gwern: Upload it to hackage!
21:04:36 <lispy> ivanm: so yeah, poke works because the poke is also scoped by withForeignPtr
21:04:47 <Cale> You're thinking of 261C WHITE UP POINTING MIDDLE
21:04:50 <ivanm> lispy: right, that's what I mean; shove stuff in there, but then in CGraph store the ForeignPtr
21:05:03 <lispy> ivanm: yeah, that sounds workable
21:05:09 <shachaf> I,I Index I copy from old Vladivostok telephone directory
21:05:19 <gwern> shachaf: what makes you think I didn't?
21:05:35 <lispy> ivanm: you're now at the frontier of my experience with FFI bindings
21:05:40 <shachaf> gwern: The version on Hackage is broken
21:05:43 <Cale> It's curious that there are black left and right pointing hands, but no black up and down pointing hands.
21:05:44 <ivanm> lispy: heh
21:05:48 <shachaf> Or was when I cabal updated a few minutes ago.
21:05:52 <lispy> ivanm: from here out, I know the theory and understand C, but I don't have much experience
21:06:00 <shachaf> Still is.
21:06:07 <gwern> shachaf: the version on hackage has the patch applied I was given
21:06:11 <Cale> But there are all four directions of white hands.
21:06:32 <shachaf> gwern: It doesn't have https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/unlambda/files/unlambda-0.1.2-ghc-7.6.patch applied.
21:06:41 <Cale> You'd think they'd be systematic about it.
21:06:59 <shachaf> Cale: It's annoying.
21:07:09 <shachaf> The BLACK characters are much more visible.
21:07:34 <ivanm> so, is it safe to just wrap a Ptr I got from a peek with "newForeignPtr finalizerFree" ?
21:07:48 <gwern> Sun Oct 21 19:24:16 EDT 2012  gienah@gentoo.org   * unlambda ghc-7.6.1 changes     {     hunk ./unlambda/Language/Unlambda.hs 1     +{-# LANGUAGE CPP, ScopedTypeVariables #-}     hunk ./unlambda/Language/Unlambda.hs 28     +#if !MIN_VERSION_base(4,6,0)     +import Prelude hiding(catch)     +#endif     +import Control.Exception (catch, IOException)     +     hunk ./unlambda/Language/Unlambda.hs 140      dat <- io $ catch (fmap Just getChar) (const $ ...
21:07:54 <gwern> ... return Nothing)     +  dat <- io $ catch (fmap Just getChar) (\(_ :: IOException) -> return Nothing)     hunk ./unlambda/Main.hs 1     -{-# LANGUAGE PatternGuards #-}     +{-# LANGUAGE CPP, PatternGuards, ScopedTypeVariables #-}     hunk ./unlambda/Main.hs 7     +#if !MIN_VERSION_base(4,6,0)     +import Prelude hiding(catch)     +#endif     +import Control.Exception (catch, IOException)     hunk ./unlambda/Main.hs 35     -  c <- catch (hGetChar h) ...
21:08:00 <gwern> ... (\_ -> error "Parse error at end of file")     +  c <- catch (hGetChar h) (\(_ :: IOException) -> error "Parse error at end of file")     }
21:08:03 <gwern> looks familiar?
21:08:21 * gienah looks familar, thanks
21:09:03 <ivanm> shachaf: so, is it safe to just wrap a Ptr I got from a peek with "newForeignPtr finalizerFree" ?
21:09:21 <rwbarton> it sounds quite unsafe
21:09:22 <shachaf> ivanm: These questions can't be answered locally.
21:09:29 <shachaf> But it's probably not safe.
21:09:31 <ivanm> "locally" ?
21:09:51 <ivanm> so, what's the alternative? create a new ForeignPtr, then clone the contents?
21:09:52 <shachaf> I mean that you need to know the behavior of the whole program (or all the parts of it that use the pointer) in order to know what to do at a particular place.
21:09:53 <ivanm> if so, hooray :s
21:09:58 <shachaf> That's why people don't like C memory management!
21:10:09 <ivanm> *sighs*
21:10:27 <shachaf> gwern: I'm not sure what you mean.
21:10:38 <gwern> I'm not sure what you mean either
21:11:24 <ivanm> shachaf: what happens if this is memory that I allocated with a ForeignPtr that's still floating around, and then I want to use peek to get it later?
21:11:37 <hpaste> gienah pasted “hi gwern unlambda 1.2 build log showing it applying the patch ok then building” at http://hpaste.org/76682
21:12:16 <shachaf> gwern: lambdabot-0.1.2.tar.gz doesn't have gienah's patch.
21:12:16 <gienah> hi gwern: the unlambda 1.2 build log on hackage: http://hackage.haskell.org/packages/archive/unlambda/0.1.2/logs/failure/ghc-7.6
21:12:29 <shachaf> Are we expected to use Gentoo to build lambdabot now?
21:12:30 * gienah is just trying to clear up some confusion
21:12:50 * gienah appreciates gwern's efforts in maintaining stuff
21:13:15 <gwern> 'The shachafs raise a dust and complain they cannot see'
21:13:33 <shachaf> gwern: I must be missing something.
21:13:36 <shachaf> But what?
21:15:05 <shachaf> rwbarton: If you build such an alternate Hackage, I'll be happy to fix some packages on it.
21:15:43 <shachaf> gienah: Did you also fix lambdabot-utils?
21:16:07 <gienah> shachaf: no, I tried and failed to fix lambdabot-utils and lambdabot
21:17:32 * gienah has been able to patch other pkgs to use Control.Exception, but lambdabot's asynchronous exceptions and error monad stuff is a beyond my understanding at the moment, I would need help but have run out of time at the moment
21:19:58 <hpaste> gienah pasted “most likely incorrect attempt to patch lambdabot-utils for ghc 7.6.1” at http://hpaste.org/76683
21:20:50 <hpaste> gienah pasted “failed, incorrect, incomplete, aborted attempt to patch lambdabot for ghc 7.6.1” at http://hpaste.org/76684
21:22:16 <shachaf> Cale: You're a big fan of the current Exception, right?
21:22:18 <Cale> I think I'll make up a module of types representing the classes of IOErrors/IOExceptions
21:22:24 <shachaf> Cale: Can you fix lambdabot-utils and lambdabot?
21:24:30 <shachaf> gienah: Are you sure that's incorrect?
21:24:48 <shachaf> gienah: (Other than not fixing the Windows version.)
21:24:52 <gienah> shachaf: no, but I just have no confidence in it
21:26:14 <shachaf> gwern: ?
21:26:21 <shachaf> gienah: What about readline?
21:26:32 <gwern> what makes you think I know anything
21:27:05 <gienah> shachaf: as in there might be some tiny chance the lambdabot-utils patch could be correct (give that it compiles), but I'm not sure if that was the correct approach.  And the lambdabot patch is incomplete, gets to a point where it fails to compile, and at that point I'm not sure if the earlier stuff was correct or not.
21:27:08 <shachaf> gwern: You're the maintainer of the package, apparently. And you said that you uploaded the patch, I thought.
21:27:21 <gwern> I just apply patches
21:27:28 <gienah> s/give that it compiles/given that it compiles/
21:27:29 <shachaf> gwern: Where did you apply the patch to?
21:27:31 <cbode> Can anyone explain what Ord is to me?  My understanding is that it is any type Int, Integer, Double, Char, Float or any type using those 5 types.. Clarify please?
21:27:41 <gwern> shachaf: to a darcs repo
21:28:01 <shachaf> cbode: Any type taht can be compared is an instance of Ord. As in "x < y".
21:28:06 <shachaf> gwern: And not to Hackage?
21:28:18 <gwern> shachaf: that's a type error
21:28:40 <cbode> @shachaf thanks!!
21:28:40 <lambdabot> Unknown command, try @list
21:28:42 <hpaste> Cale pasted “Example of subtyping IOException” at http://hpaste.org/76685
21:28:43 <shachaf> gwern: Did you upload the new package to Hackage?
21:28:49 <gwern> yes
21:28:57 <gienah> shachaf: readline is easy: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/readline/files/readline-1.0.1.0-ghc-7.6.patch
21:29:26 <shachaf> gienah: I thought you might've rewritten it to use haskeline.
21:29:45 <gienah> shachaf: no, just patched readline :-)
21:29:56 <Cale> shachaf: What do you think of that thing?
21:30:23 <Cale> cbode: Ord is a type class for types with a definition of <= and other comparison operations
21:30:36 <shachaf> Cale: I think it looks like a sort of thing I wouldn't want to read.
21:30:44 <Cale> cbode: It stands for "Ordered"
21:30:52 <Cale> shachaf: Well, it's boilerplate
21:30:59 <rwbarton> what's the status of hackage 2?
21:31:16 <Ghoul> Is there a way I can force haskell to gc
21:31:18 <shachaf> ezyang: ☝?
21:31:28 <Cale> shachaf: But it's something that we can easily do to make the various sorts of IO errors more easily catchable
21:31:29 <rwbarton> I don't see hackage on hackage, what kind of server is it anyways?
21:31:56 <Cale> Ghoul: System.Mem.performGC
21:32:47 <rwbarton> the server mentioned at http://hackage.haskell.org/trac/hackage/wiki/HackageDB/2.0 is down
21:32:48 <Ghoul> Cale: thanks
21:33:51 <rwbarton> wasn't there quite a lot of activity around hackage 2 a while back? did it just fizzle out?
21:34:04 <shachaf> rwbarton: As far as I can tell.
21:34:20 <Cale> cbode: You might notice this operation:  compare :: (Ord a) => a -> a -> Ordering  which is probably the best thing to define if you're defining an instance of Ord. It produces a value of type Ordering, which is one of LT, EQ, or GT depending on whether its first argument was Less Than, EQual, or Greater Than its second.
21:34:41 <shachaf> GreaTerthan
21:36:33 <lispy> Right now my substititions are done with a function, but the THIH paper uses association lists. I think the association lists are nicer.
21:36:39 <Cale> shachaf: Anyway, the cool thing about the new exception stuff is that you can stick in new sub or super types of exceptions.
21:36:43 <lispy> So I guess that implies I should refactor
21:37:12 <Cale> (arbitrarily, after the fact)
21:37:13 <lispy> Cale: because subtyping is a good idea??
21:37:17 <Cale> heh
21:37:26 <Cale> Well, it doesn't even *really* require subtyping
21:37:37 <cbode> Cale: what's the difference between Eq and Ord?
21:37:47 <Cale> Eq defines only (==) and (/=)
21:37:53 <Cale> So equality comparison
21:37:54 <lispy> rwbarton: oh that's unfortunate
21:38:16 <lispy> we desparately need an update to hackage
21:38:21 <cbode> Cale: Is Ord a subtype of Eq?
21:38:30 <Cale> Ord is a subclass of Eq
21:38:31 <lispy> Before people revert to using git tags and pull scripts
21:38:35 <Cale> Ord and Eq aren't types
21:38:41 <Cale> (they are type classes)
21:39:03 <Cale> cbode: As an example of the difference, you might see   sort :: Ord a => [a] -> [a]
21:39:17 <Cale> But a function of type  Eq a => [a] -> [a]  could never be expected to sort a list.
21:39:27 <Cale> Because it can only compare the elements of the list for equality
21:39:39 <cbode> Cale: Perfect, cheers.  Also, what is /=  ?  is that not equal
21:39:43 <Cale> yes
21:39:55 <lispy> well, you could sort Maybe () with it, but only because a partition could sort Maybe ()
21:40:13 <Cale> lispy: Could it?
21:40:48 <Cale> (you couldn't ensure that Nothing came first)
21:40:49 <lispy> I would consider something of the form [Nothing ... Nothing, Just (), ..., Just ()] to be sorted
21:41:32 <Cale> Right, but how do you tell the difference between that and [Just (), ..., Just (), Nothing, ..., Nothing] ?
21:41:40 <lispy> that's also sorted
21:41:44 <Cale> heh
21:41:57 <Cale> > sort [Just (), Just (), Nothing, Nothing]
21:41:58 <lambdabot>   [Nothing,Nothing,Just (),Just ()]
21:42:03 <lispy> I'm being super pendantic here
21:42:09 <Cale> It's not sorted.
21:42:14 <Cale> Nothing < Just x  for any x :)
21:42:17 <lispy> But also ambiguous about asc vs. desc
21:42:29 <ezyang> shachaf: Hmmm?
21:42:32 <lispy> Sorted up to reverse?
21:42:37 <Cale> heh, okay
21:43:27 <rwbarton> monotonic
21:43:37 <lispy> I guess the substition function in the Dependently Typed Tutorial Implementation paper, is really the "broadcast" step.
21:44:17 <lispy> I'm kind of surprised it works. It must be the least general thing that works in their context.
21:45:05 <Cale> The least general thing that works in a general context is often the right thing :)
21:46:19 <shachaf> ezyang: What's going on with the Hackage 2 efforts?
21:46:20 <Cale> (also the most general thing which works in a specific context)
21:46:53 <ezyang> shachaf: https://github.com/haskell/cabal/issues?labels=hackage2%2Cimportant&state=open
21:46:59 <ezyang> Also, bug dcoutts about it
21:47:04 <ezyang> Or help solve those issues ;-)
21:48:09 <rwbarton> can I open an issue "Hackage isn't running Hackage 2 yet"
21:48:38 <rwbarton> anyways these dates are somewhat encouraging
21:48:44 <rwbarton> more recent than i would have feared
21:49:26 <shachaf> ezyang: rwbarton is opening a competitor.
21:49:32 <shachaf> Anarchist Hackage
21:49:40 <ezyang> May the best platform win
21:50:44 <rwbarton> Hackage "what's a version number"
21:51:18 <lispy> they have a judgement like this: Gamma, x :: tau |- e :: tau' ==> Gamma |- \x -> e :: tau -> tau'
21:51:19 <shachaf> rwbarton: Your Hackage should just have git commits as version numbers.
21:51:36 <lispy> When they apply that judgement is the only place that substitution happens
21:51:51 <rwbarton> it's very tempting
21:51:52 <lispy> They substitute tau for the type of x in e
21:52:25 <lispy> software releases are still a useful forcing function
21:52:44 <lispy> therefore, I think tags are better than git commit hashes
21:53:03 <shachaf> lispy: The goal here is naming version numbers.
21:53:19 <Cale> http://channel9.msdn.com/posts/Erik-Meijer-and-Gilad-Bracha-Dart-Monads-Continuations-and-More -- in this video, Erik Meijer and Gilad Bracha both need to use the washroom, but were forced to do the interview first.
21:53:33 <shachaf> So that uncoöperative authors can still work together somehow.
21:54:23 <rwbarton> there's also the cabal-nirvana project, does anyone use that?
21:54:31 <rwbarton> semi-related
21:54:32 <lispy> I use cabal-dev
21:54:36 <Jafet> Breaking news: Hackage announces migration to emerge
21:54:38 <lispy> sandboxes for the win
21:55:04 <rwbarton> that doesn't really solve the problem of an individual package not installing at all
21:55:18 <rwbarton> not that cabal-nirvana does either, directly
21:55:28 <rwbarton> I am thinking along the lines of the debian model
21:56:13 <randomclown> @pl \xs -> (snd . unzip) xs
21:56:13 <lambdabot> snd . unzip
21:57:05 <lispy> rwbarton: please elaborate
21:57:23 <lispy> rwbarton: you want different brands of hackage? unstable, testing, stable/
21:57:33 <rwbarton> something like that
21:57:41 <rwbarton> well
21:58:31 <rwbarton> more like a "view" of hackage that sits downstream of the actual hackage and has consistent versions of everything
21:59:18 <lispy> that's called the Haskell Platform
21:59:18 <rwbarton> a key feature being that when packages don't install, that is a bug in this "view" rather than a bug in the packages
21:59:21 <rwbarton> right
21:59:27 <rwbarton> but the Haskell Platform is much too small and moves too slowly
21:59:39 <shachaf> sits downstream consistently and consists of consistent versions of the constituents of Hackage
22:00:11 <rwbarton> I mean how many packages are there in debian, probably tens of thousands
22:00:17 <Cale> I don't think of the Haskell Platform as something I'm actually meant to install
22:00:25 <rwbarton> lord knows apt-get takes long enough to start these days :)
22:00:29 <lispy> Cale: yes, that's a failing, IMO
22:00:30 <shachaf> Cale is too good for the Haskell Platform.
22:00:45 <Cale> I think of it as something which some people are taking care of which has a good effect on a particular collection of packages.
22:00:48 <rwbarton> of course debian is not known for moving very quickly either
22:01:08 <rwbarton> yes, i agree. but those packages are relied on by ~everybody and are actually maintained
22:01:14 <shachaf> Debian gives you a choice between stability and speed!
22:01:32 <Cale> i.e. the packages in the Haskell Platform are usable together, or at least, there is guaranteed to exist a consistent set of fairly-recent-ish versions which work together.
22:01:46 <rwbarton> debian doesn't rely on upstream maintainers to be responsive
22:02:07 <lispy> yeah, they just patch openssl as they see fit
22:02:13 <Cale> and that's fine
22:02:17 <lispy> or was it openssh?
22:02:34 <Cale> I would be totally happy with people taking care of the Haskell Platform and having it be nothing more than a meta-package on Hackage
22:02:52 <shachaf> I never meta-package on Hackage I didn't like.
22:02:58 <shachaf> (That's a lie.)
22:03:15 <Cale> otoh, I think that GHC should come with a working cabal-install (if it doesn't already)
22:03:42 <lispy> Cale: AFAICT, it does not come with cabal-install or make
22:04:20 <Cale> I don't even particularly care if it comes with the source for cabal-install
22:04:28 * lispy nods
22:04:36 <Cale> Throwing a working cabal-install binary into the package would help lots of people out.
22:04:44 <geekosaur> ghc doesnt come with cabal-install, it comes with cabal the library.  the platform includes cabal-install
22:04:58 <Cale> geekosaur: yeah, I know that much
22:05:50 <Cale> But carefully curating this garden of packages seems like a separate concern from making sure that people who have a Haskell compiler also have the tools to get libraries from our package repository.
22:05:52 <rwbarton> even a bugs.hackage.org would be a welcome step
22:05:57 <lispy> the "batteries included" bit about the platform is a bit of a deception where windows is concerned. Because many packages still won't build there if only because they need to run a makefile, configure script, or use a C library.
22:06:44 <rwbarton> even packages in the HP itself?
22:07:12 <lispy> rwbarton: no, but the HP is small and moves slowly, so presumably Haskell users look to hackage pretty quickly after the HP install is done
22:07:26 <rwbarton> well, those aren't the batteries that are claimed to be included
22:07:34 <rwbarton> as far as i understand
22:07:46 <lispy> the HP doesn't offer anything competitive with numpy or scipy, right? hmatrix is miserable to build on windows.
22:08:29 <lispy> rwbarton: so, batteries included but some assembly required? :)
22:08:44 <rwbarton> batteries included but nuclear power plants not included
22:09:15 <rwbarton> "lol, HP doesn't even include a dependently typed programming language??"
22:09:48 <lispy> I get your point that it's a slippery slope, but I do think the HP should bundle more on windows.
22:10:13 <lispy> You get Haskell but you don't get enough to build lots of common Haskell packages
22:10:25 <Lajjla> unsafeCoerce isn't necessarily pure is it? Or does the language spec mandat ethat?
22:10:59 <mikeplus64> Lajjla: it's not pure it all, it's explosive
22:11:01 <Cale> Lajjla: You can screw anything up with unsafeCoerce
22:11:25 <Cale> Lajjla: You can write unsafePerformIO with unsafeCoerce, as well as cause arbitrary code execution.
22:11:26 <Lajjla> Nahh, it's cool.
22:11:29 <Lajjla> Best practices
22:11:39 <Lajjla> I know what unsafecoerce does.
22:11:46 <Lajjla> And it's fabulous.
22:11:53 <Cale> So calling it pure is a bit weird
22:12:09 <Cale> However, if its domain and codomain are equal types, it should be the identity function.
22:12:18 <Cale> That's pretty much the only guarantee you really have.
22:12:27 <Lajjla> Well, I'm not sure about that either I mean.
22:12:28 <solrize> lispy, the python distro doesn't contain anything like scipy or numpy either ;)
22:12:35 <lispy> Really, it's just a simple generalization of the identity function ;)
22:12:45 <Lajjla> I mean there migt be some implementation which decides to give different internal reps in different situations for optimization sake.
22:13:03 <lispy> solrize: Okay, but those are easy to install on windows.
22:13:44 <Cale> Lajjla: By that, I mean, its behaviour will be indistinguishable from the perspective of pure code from the identity function.
22:14:20 <Cale> It might make the CPU hotter or something.
22:14:24 <Lajjla> I'm not going to praetend that I can understand what you just wrote, rephrase, sweetie.
22:14:35 <Lajjla> I do love some hot CPU's.
22:14:40 <Lajjla> Hubba hubba hubba
22:14:43 <lispy> rwbarton, solrize: I guess you could summarize what I want from the HP is that once I install it, I have the tools to get going with Haskell packages. The obvious blocker here is that the FFI means people could try to build arbitrary C projects.
22:14:49 <Cale> If I write
22:14:52 <Cale> foo :: a -> a
22:14:56 <Cale> foo = unsafeCoerce
22:15:05 <Cale> then foo is safe and equivalent to the identity function
22:15:31 <rwbarton> it's not 100% trivial on unix either, if I install bindings to some C library and I don't have the appropriate -dev package installed I need to do a little poking around to figure out what it is called
22:15:37 <Lajjla> Cale, what if it's used in an implementation that gives different internal repraesentations for the same datum based on for instance how many memory is still available?
22:15:38 <Cale> (but as for memory usage or time, no real guarantees, though in practice, you will see no difference)
22:15:54 <Lajjla> As in, it migt give a less memory expensive but more CPU expensive repraesentation then?
22:16:02 <rwbarton> or if I want to install llvm on debian stable right now, I have to somehow get a newer version of llvm than is available through apt
22:16:18 <Cale> Lajjla: You should not be able to tell the difference between those different representations anyway
22:16:40 <lightquake> what's the recommended Text interpolation quasiquoter?
22:16:47 <Cale> But even then, it's not generally going to make a copy, in a reasonable implementation.
22:16:48 <Lajjla> Cale, well, maybe how the system works it crashes because it doesn't check which is used as it can prove beforehand which will be used in certain cases?
22:17:55 <Cale> Lajjla: Basically, all that unsafeCoerce does is to turn the typechecker off locally. You're responsible for understanding what the implementation will do.
22:17:57 <lispy> rwbarton: I think the HP could be much closer to what I want by simply fixing this (and the obvious related variants): ls: /c/Program Files (x86)/Haskell Platform/2011.2.0.0/mingw/bin/make.exe: No su
22:18:01 <lispy> ch file or directory
22:18:19 <rwbarton> HP should just include a linux VM image already
22:18:23 <Cale> Lajjla: However, you may reasonably expect that the behaviour of foo that I gave above and the id from Prelude are indistinguishable.
22:18:34 <rwbarton> the fact that it has to include make is a bit ridiculous
22:18:52 <shachaf> rwbarton: Until the Haskell Platform is a piece of hardware that I can physically put things on, it's not a platform!
22:18:54 <lispy> rwbarton: they bundle gcc, and I can manually add it to my path, and get a C compiler. Now I'm "just" missing make.exe and a few others.
22:19:07 <rwbarton> and once you add those then you will "just" be missing something else
22:19:10 <Cale> Lajjla: If you can find an implementation where that's not true (I don't think there is one in existence), then sure, watch out for that.
22:19:37 <shachaf> http://www.canonical.org/~kragen/tao-of-programming.html#book7
22:19:46 <lispy> rwbarton: I want to make the delta a bit smaller. We don't have to close the gap completely.
22:20:15 <rwbarton> anyways I have neither the motivation nor the skills nor the resources to improve the situation of haskell on windows
22:21:12 <lispy> maybe the solution is to build a purely haskell reimplementation of make
22:21:17 <lispy> gnu make, I should say
22:21:22 <lispy> and then have people install that first
22:21:28 <ivanm> I seem to recall some attempts at that, but not gnu make
22:21:40 <lightquake> hmake
22:21:45 <lispy> (I'm only half serious)
22:21:48 <lightquake> or hake or something
22:21:50 <lightquake> i know ruby has rake
22:21:51 <lispy> at most even
22:21:57 <Cale> Lajjla: If you're asking what a Haskell programmer would generally expect unsafeCoerce to do operationally, the answer would generally be "nothing at runtime"
22:22:29 <Lajjla> Cale, indeed, but those are all not answers to my quaestion.
22:22:38 <Cale> Lajjla: Then I don't know what you're asking.
22:22:45 <Lajjla> But I feel it's me baby, not you, because people tend to answer whatever I ask with completely unrel;ated things.
22:22:58 <ivanm> we have: hmk, hake, shake (not sure if it's really a drop-in)
22:23:10 <Lajjla> Cale, I was told that every haskell function is pure, clearly unsafecoerce is not, what up with that?
22:23:23 <Lajjla> They lied to me Cale, they are mean.
22:23:23 <lispy> ivanm: shake is a different beast
22:23:33 <ivanm> yeah, thought it would be
22:23:37 <ivanm> doesn't it call make?
22:23:47 <lispy> Lajjla: unsafeCoerce is outside the standard, IIRC
22:23:55 <ivanm> Lajjla: unsafeCoerce isn't usually considered part of Haskell
22:23:58 <ivanm> nor is unsafePerformIO, etc.
22:24:05 <Cale> Lajjla: I don't think of unsafeCoerce as a Haskell function, I think of it as a low-level hook that GHC provides which sometimes prevents me from having to modify GHC.
22:24:18 <ivanm> Cale: heh, nice way of putting it
22:24:19 <Lajjla> Well, that is lying to me as well honestly, they called it a haskell function.
22:24:24 <Lajjla> It is a function as far as the type system goes.
22:24:32 <Cale> Yeah, but it's not a function.
22:24:38 <ivanm> hence the push for Safe Haskell, etc.
22:24:39 <Lajjla> Well, they lied to me again.
22:24:51 <ivanm> who is this mysterious "they"?
22:24:52 <Lajjla> unless... you do and you're trying to set us up against each other.
22:24:56 <shachaf> Lajjla: You really ought to stop trolling #haskell.
22:25:04 <Lajjla> People who write stuff on ze haskell wiki.
22:25:09 <Cale> Using unsafeCoerce should be treated with the same gravity as modifying your compiler.
22:25:16 <ivanm> the Haskell Cabal? ;-)
22:25:18 <Lajjla> I concur.
22:25:19 <Cale> and should be done about as sparingly
22:25:34 <ivanm> Cale: unless you're called edwardk? :p
22:25:34 <shachaf> Cale: I used unsafeCoerce instead of (Identity .) just yesterday!
22:25:48 <Cale> heh
22:26:12 <lispy> I used unsafeCoerce on a phantom type once, a phantom type that is normally only ever bound existentially. I found out the hard way that it was still not safe.
22:26:20 <lispy> unsafeCoerce really means unsafe :)
22:26:32 <shachaf> lispy: I think it was perfectly safe in my case.
22:26:44 <shachaf> Also I found a bug in GHC when I tried to do it without unsafeCoerce.
22:26:56 <lispy> shachaf: nic
22:26:59 <lispy> +e
22:27:03 <shachaf> So clearly unsafeCoerce is safer.
22:27:05 <edwardk> shachaf++
22:27:15 <Cale> Lajjla: The same goes for unsafePerformIO. You should have to use unsafePerformIO about as often as you should have to modify your compiler.
22:27:29 <Cale> (For most people, that's "never")
22:27:50 <Lajjla> I concur, but those are still not answers to my quaestions. However, rest assured, you are not at fault, clearly I am.
22:27:52 <shachaf> Cale: I think you're overstating it.
22:28:00 * Lajjla <- not a native speaker.
22:28:22 <ivanm> Cale: unless you do lots of FFI bindings?
22:28:58 <Cale> ivanm: You can think of the whole FFI as a sort of way to extend the primitives in the language too if you want.
22:29:07 <ivanm> *nod*
22:29:29 <ivanm> though I've used unsafePerformIO when doing something FFI-y without actually using the FFI (namely calling an external program)
22:29:35 <shachaf> Someone should name a cat "Dedekind Cat"
22:30:16 <Cale> It's not impossible, or even that hard in some cases, to use these safely, but I don't think they deserve to be included when we speak of "functions" in general.
22:30:42 <Cale> For one, they're just not functions, mathematically speaking.
22:30:46 <ivanm> agreed
22:32:25 <Cale> Lajjla: Does that help?
22:34:20 <Lajjla> Cale, sure, I was unaware that they weren't part of the haskell standard you see, the haskell wiki speaks like they are.
22:34:33 <Lajjla> THey don't call them GHC extensions or anything.
22:34:42 <Cale> Lajjla: They're part of the FFI
22:35:02 <Cale> If you're doing FFI to C code, it's pretty much assumed that you can make anything go wrong.
22:35:16 <ivanm> well, FFI is an addendum to the report
22:35:19 <Cale> yes
22:35:30 <ivanm> did it become official as of Haskell2010, or still just an addendum?
22:35:46 <Cale> So in that sense, they're "standardised", though "Haskell" doesn't generally even mean "Haskell 98" or "Haskell 2010"
22:36:20 <Cale> ivanm: I'm not sure there's really a distinction to be made
22:36:45 <Lajjla> Ah yes, de facto standard. Well, I have to say, this was an improvement for me, I got a 'yes/no' answer in less than 50 lines this time. I must be mastering English even more.
22:36:55 <ivanm> as in "it's part of the official Haskell standard" rather than "it's an extension to the standard"
22:38:08 <Cale> Lajjla: So in practical terms, if you're trying to provide an environment for Haskell evalution, you do need to be careful that this and certain other features of the implementation are not exposed.
22:38:25 <Cale> (i.e. a safe one for executing other people's programs)
22:38:45 <Cale> So, there's something called Safe Haskell now to help you do this in some ways.
22:39:06 <Cale> and a system of package trust
22:39:37 <Cale> (Because some packages may internally use unsafePerformIO, say, but only export things which are considered safe.)
22:40:08 <Cale> The author of such a package will mark it as Trustworthy, but then it's still up to you to accept that you trust the author.
22:40:20 <Cale> (If you're using the Safe language)
22:40:57 * hackagebot network-conduit-tls 0.6.0.1 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-0.6.0.1 (MichaelSnoyman)
22:41:07 <Cale> Packages which don't use unsafe primitives can be inferred to be safe without any special treatment.
22:41:55 <shachaf> Cale: This is true in many languages.
22:42:11 <shachaf> (In one sense, in every language.)
22:42:28 <Cale> Well, no, this is an actual implemented thing in software
22:42:49 <Cale> I don't know of many other languages with a system that's quite like this
22:44:11 <Cale> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/safe-haskell.html
22:44:23 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/safe-haskell.html
22:44:53 <hamid> @src (&&)
22:44:53 <lambdabot> True  && x = x
22:44:53 <lambdabot> False && _ = False
22:45:57 * hackagebot mega-sdist 0.2.0.5 - Handles uploading to Hackage from mega repos  http://hackage.haskell.org/package/mega-sdist-0.2.0.5 (MichaelSnoyman)
22:45:59 * hackagebot http-conduit 1.8.0 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.0 (MichaelSnoyman)
22:47:49 <Lajjla> Cale, indeed, but that is not an answer to my quaestion. =(
22:47:55 <Lajjla> I swear, this is me though,m not you, I always get iths.
22:55:57 * hackagebot network-conduit-tls 0.6.0.2 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-0.6.0.2 (MichaelSnoyman)
22:55:59 * hackagebot warp-tls 1.3.3 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.3.3 (MichaelSnoyman)
23:10:32 <shachaf> gienah: I don't think your readline fix is sufficient.
23:11:01 <gienah> shachaf: oh, I could check
23:11:15 <shachaf> gienah: Unless you did something about the __hscore_hs_fileno thing?
23:11:31 <gienah> shachaf: I checked, that's all I do
23:12:08 <dmwit> shachaf: I've clobbered lots of Hackage packages maintained by other people, yes; one which is a community-maintained package anyway; one where the maintainer had not been spotted in the Haskell community for over two years; and all the remaining ones with the blessing of the previous maintainer.
23:12:22 <shachaf> gienah: What's all you do?
23:12:44 <gienah> shachaf: all I do is apply that one patch to readline, I don't do any other magic or patches
23:13:05 <shachaf> What patch?
23:13:26 <shachaf> Ah, https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/readline/files/readline-1.0.1.0-ghc-7.6.patch
23:13:34 <shachaf> Never mind.
23:13:40 <dolio> shachaf: Is it necessary?
23:13:46 <gienah> shachaf: yeah that one, it defines a C procedure that was removed from ghc 7.6.1
23:14:42 <gienah> shachaf: on line 32 of that patch
23:14:59 <shachaf> dolio: Is that necessary?
23:15:05 <shachaf> gienah: Right, I missed that before.
23:15:11 <shachaf> dolio: Oh.
23:15:13 <dolio> Is the fix necessary?
23:15:30 <shachaf> It's sufficient but not necessary.
23:15:45 <shachaf> (Though it might be necessary up to isomorphism.)
23:27:32 <exbb2> How do I register on hackage? I've sent a few mails to ross, but he's either dead, ignores me, or my mails got filtered as spam.
23:29:37 <zomg> Maybe you shouldn't call your package Viagra
23:30:02 <kfish> exbb2, perhaps mail haskell-cafe or cabal-devel@haskell.org
23:30:02 <exbb2> There's a package named Viagra on hackage?
23:30:08 <zomg> Nah :P
23:30:23 <zomg> But if you were mailing him about Viagra it would probably get flagged as spam..
23:30:26 <zomg> :D
23:31:08 <exbb2> I only mailed my name, then mailed a "hello?" after a few days.
23:31:34 * shachaf should probably get a Hackage account.
23:31:47 <Cale> Perhaps you should try sending a message which indicates that you'd actually like an account on Hackage.
23:32:23 <Cale> Ross is a real person, and that's not a special email address for this purpose.
23:32:32 <ivanm> exbb2: if the email body only contained your name, it might get flagged as spam for being rather short...
23:32:41 <exbb2> I tried mailing from gmail and asked him, in a human and non-spam way, about whether my other message got flagged as spam.
23:32:48 <exbb2> No answer still.
23:32:51 <ivanm> maybe he's just busy?
23:33:17 <ivanm> aren't we meant to have Hackage2 by now, anyway?  what happened to the switch-over?
23:33:24 <shachaf> ivanm: See above.
23:33:55 <ivanm> shachaf: about Ross? I thought he had nothing to do with Hackage2
23:34:24 <rwbarton> further above
23:35:10 <Cale> I see some stuff about readline
23:35:19 <shachaf> Still abover.
23:36:01 <ivanm> oh, as in almost 2 hours ago?
23:36:11 <ivanm> with ezyang giving you a link toa  github bug list?
23:36:23 <shachaf> That's the one.
23:36:40 <shachaf> (If you want to go even more above, there may have been a relevant discussion in 2009.)
23:37:38 <ivanm> don't think my IRC logs go back that far :p
23:48:28 <shachaf> Cale; Can you fix lambdabot?
23:48:35 <shachaf> I don't like this exception mess.
23:50:17 <Cale> shachaf: What's the problem?
23:50:41 <Cale> shachaf: I don't have 7.6.1 installed, but I can maybe help you with errors?
23:51:06 <Cale> You're trying to get it to run on 7.6.1, right?
23:51:16 <Cale> I've made it run on 7.4.1 before
23:51:51 <shachaf> Cale: Just make it not use Control.OldException.
23:52:07 <shachaf> I can do it but it's not much fun, and you like the new exception mechanism.
23:52:18 <Cale> heh
23:52:43 <shachaf> (I've done a chunk of it but now it looks like doing it nicely will require a bit more rethinking.)
23:52:48 <shachaf> Anyway it's a noble cause, right?
23:53:03 <Cale> Well, throw up some errors on hpaste and we'll figure it out?
23:53:37 <Cale> Usually, it's just pattern matching against SomeException
23:53:43 <exbb2> If the old exception mechanism doesn't have asynchronous exceptions, than there's a good reason to like it.
23:53:56 <shachaf> They do their own exception thing with Typeable which I tried to migrate halfway to Exception but that ends up being a mess.
23:54:22 <Cale> shachaf: Oh, whoa, what?
23:54:30 <Cale> Lambdabot has its own Typeable exception mechanism?
23:55:16 <shachaf> Cale: Oh, not really.
23:55:23 <shachaf> They just use throwDyn in a couple of places.
23:56:34 <Cale> ah, okay
23:57:02 <shachaf> I think I'd rather rewrite lambdabot than think about this. :-)
23:57:18 <Cale> and if you take the type of value that they're throwing and you write  instance Exception Foo   and replace throwDyn with throw, what happens?
23:58:09 <shachaf> That's what I did.
23:58:21 <Cale> actually, maybe you should make a wrapper instead
23:58:27 <Cale> well, I dunno
23:58:33 <Cale> What went wrong?
23:58:42 <shachaf> Nothing, actually.
23:58:42 <neworder> Hi guys
23:58:47 <neworder> For this Program, let f=f in if 1>0 then 1 else f 0
23:58:47 <Cale> ...
23:59:09 <neworder> how do I write a similar program in a hs file
23:59:09 <shachaf> Cale: I got mixed up. :-)
23:59:13 <neworder> which should be compiled
23:59:34 <shachaf> Cale: Now I need to do something about this sum type.
23:59:39 <Cale> neworder: You can write something like  main = print (let f = f in if 1 > 0 then 1 else f 0)
23:59:54 <Cale> neworder: or of course, you can lift the definition of f to the top level
